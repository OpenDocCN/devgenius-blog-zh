<html>
<head>
<title>Python Up Your Code: Operators</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python Up 您的代码:运算符</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/python-up-your-code-operators-455164611481?source=collection_archive---------8-----------------------#2022-06-27">https://blog.devgenius.io/python-up-your-code-operators-455164611481?source=collection_archive---------8-----------------------#2022-06-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="957e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">Python 中运算符的概述</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/99993c3924d8298719e3985088ea632c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V38ENQ5UL3AFxTBbwaBVkg.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">Pawel Czerwinski 在<a class="ae kv" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="bcc1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">简而言之，Python 中(一般来说，编程中)的运算符是用于执行特定数学、关系或逻辑运算的符号/结构，这些运算将产生有形的具体结果值。</p><p id="fec0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Python 中有多种类型的操作符，我们将逐一介绍它们。</p><h2 id="e7be" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">算术运算符</h2><p id="94bc" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">这些运算符用于执行基本的算术运算，如求和、乘积、除法等。Python 中至少有 7 个算术运算符:</p><ul class=""><li id="54e0" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated"><strong class="ky ir">加法</strong> ( <code class="fe mz na nb nc b">+</code> ) —将两个操作数相加；</li><li id="d3c3" class="mq mr iq ky b kz nd lc ne lf nf lj ng ln nh lr mv mw mx my bi translated"><strong class="ky ir">减法</strong> ( <code class="fe mz na nb nc b">-</code> ) —从一个操作数中减去另一个操作数；</li><li id="f836" class="mq mr iq ky b kz nd lc ne lf nf lj ng ln nh lr mv mw mx my bi translated"><strong class="ky ir">乘法</strong> ( <code class="fe mz na nb nc b">*</code> ) —一个操作数乘以另一个操作数；</li><li id="a213" class="mq mr iq ky b kz nd lc ne lf nf lj ng ln nh lr mv mw mx my bi translated"><strong class="ky ir">除法</strong> ( <code class="fe mz na nb nc b">/</code> ) —一个操作数除以另一个操作数；</li><li id="d28d" class="mq mr iq ky b kz nd lc ne lf nf lj ng ln nh lr mv mw mx my bi translated"><strong class="ky ir">模数</strong> ( <code class="fe mz na nb nc b">%</code> ) —两个操作数相除的余数；</li><li id="e2b3" class="mq mr iq ky b kz nd lc ne lf nf lj ng ln nh lr mv mw mx my bi translated"><strong class="ky ir">取幂</strong> ( <code class="fe mz na nb nc b">**</code> ) —一个操作数的另一个操作数的幂；</li><li id="8f7c" class="mq mr iq ky b kz nd lc ne lf nf lj ng ln nh lr mv mw mx my bi translated"><strong class="ky ir">Floor</strong><strong class="ky ir">division</strong>(<code class="fe mz na nb nc b">//</code>)—返回两个操作数相除的 Floor 输出</li></ul><pre class="kg kh ki kj gt ni nc nj nk aw nl bi"><span id="3778" class="ls lt iq nc b gy nm nn l no np"><em class="nq"># addition</em><br/>result = 3 + 2<br/><strong class="nc ir">print</strong>(f"3 + 2 = {result}")</span><span id="a590" class="ls lt iq nc b gy nr nn l no np"><em class="nq"># subtraction</em><br/>result = 2 - 3<br/><strong class="nc ir">print</strong>(f"2 - 3 = {result}")</span><span id="1906" class="ls lt iq nc b gy nr nn l no np"><em class="nq"># multiplication</em><br/>result = 3 * 2<br/><strong class="nc ir">print</strong>(f"3 * 2 = {result}")</span><span id="cee6" class="ls lt iq nc b gy nr nn l no np"><em class="nq"># division</em><br/>result = 3 / 2<br/><strong class="nc ir">print</strong>(f"3 / 2 = {result}")</span><span id="9b8c" class="ls lt iq nc b gy nr nn l no np"><em class="nq"># modulus</em><br/>result = 3 % 2<br/><strong class="nc ir">print</strong>(f"3 % 2 = {result}")</span><span id="d67e" class="ls lt iq nc b gy nr nn l no np"><em class="nq"># exponentiation</em><br/>result = 3 ** 2<br/><strong class="nc ir">print</strong>(f"3 ** 2 = {result}")</span><span id="7e90" class="ls lt iq nc b gy nr nn l no np"><em class="nq"># floor division</em><br/>result = 3 // 2<br/><strong class="nc ir">print</strong>(f"3 // 2 = {result}")</span><span id="1ff5" class="ls lt iq nc b gy nr nn l no np">Output:<br/>3 + 2 = 5<br/>2 - 3 = -1<br/>3 * 2 = 6<br/>3 / 2 = 1.5<br/>3 % 2 = 1<br/>3 ** 2 = 9<br/>3 // 2 = 1</span></pre><h2 id="12be" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">比较运算符</h2><p id="a91e" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">顾名思义，这些运算符用于执行操作数之间的比较。Python 中目前有 6 个这样的比较运算符:</p><ul class=""><li id="be02" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated"><strong class="ky ir">小于</strong> ( <code class="fe mz na nb nc b">&lt;</code> ) —如果第一个操作数小于第二个操作数，则计算为<code class="fe mz na nb nc b">True</code>，否则为<code class="fe mz na nb nc b">False</code>；</li><li id="1f3f" class="mq mr iq ky b kz nd lc ne lf nf lj ng ln nh lr mv mw mx my bi translated"><strong class="ky ir">小于或等于</strong> ( <code class="fe mz na nb nc b">&lt;=</code> ) —如果第一个操作数小于或等于第二个操作数，则计算为<code class="fe mz na nb nc b">True</code>，否则为<code class="fe mz na nb nc b">False</code>；</li><li id="b2b3" class="mq mr iq ky b kz nd lc ne lf nf lj ng ln nh lr mv mw mx my bi translated"><strong class="ky ir">大于</strong> ( <code class="fe mz na nb nc b">&gt;</code> ) —如果第一个操作数大于第二个操作数，则计算为<code class="fe mz na nb nc b">True</code>，否则为<code class="fe mz na nb nc b">False</code>；</li><li id="6766" class="mq mr iq ky b kz nd lc ne lf nf lj ng ln nh lr mv mw mx my bi translated"><strong class="ky ir">大于或等于</strong> ( <code class="fe mz na nb nc b">&gt;=</code> ) —如果第一个操作数大于或等于第二个操作数，则计算为<code class="fe mz na nb nc b">True</code>，否则为<code class="fe mz na nb nc b">False</code>；</li><li id="6651" class="mq mr iq ky b kz nd lc ne lf nf lj ng ln nh lr mv mw mx my bi translated"><strong class="ky ir">等于</strong> ( <code class="fe mz na nb nc b">==</code> ) —如果两个操作数的值相等，则计算为<code class="fe mz na nb nc b">True</code>，否则为<code class="fe mz na nb nc b">False</code>；</li><li id="fd5f" class="mq mr iq ky b kz nd lc ne lf nf lj ng ln nh lr mv mw mx my bi translated"><strong class="ky ir">不等于</strong> ( <code class="fe mz na nb nc b">!=</code> ) —如果两个操作数的值不同，则计算为<code class="fe mz na nb nc b">True</code>，否则为<code class="fe mz na nb nc b">False</code>—这与<strong class="ky ir">等于</strong> ( <code class="fe mz na nb nc b">==</code>)正好相反。</li></ul><pre class="kg kh ki kj gt ni nc nj nk aw nl bi"><span id="b7a1" class="ls lt iq nc b gy nm nn l no np"><em class="nq"># lt<br/></em>result = 1 &lt; 2<br/><strong class="nc ir">print</strong>(f"is 1 less than 2?: {result}")</span><span id="f590" class="ls lt iq nc b gy nr nn l no np"><em class="nq"># lte<br/></em>result = 3 &lt;= 3<br/><strong class="nc ir">print</strong>(f"is 3 less than or equal to 3?: {result}")</span><span id="b8ee" class="ls lt iq nc b gy nr nn l no np"><em class="nq"># gt<br/></em>result = 3 &lt; 2<br/><strong class="nc ir">print</strong>(f"is 3 greater than 2?: {result}")</span><span id="3e53" class="ls lt iq nc b gy nr nn l no np"><em class="nq"># gte<br/></em>result = 3 &gt;= 3<br/><strong class="nc ir">print</strong>(f"is 3 greater than or equal to 3?: {result}")</span><span id="908b" class="ls lt iq nc b gy nr nn l no np"><em class="nq"># eq<br/></em>result = 4 == 4<br/><strong class="nc ir">print</strong>(f"is 4 equal to 4?: {result}")</span><span id="955f" class="ls lt iq nc b gy nr nn l no np"><em class="nq"># neq<br/></em>result = 4 == 4.0<br/><strong class="nc ir">print</strong>(f"is 4 not equal to 4.0?: {result}")</span><span id="4a1b" class="ls lt iq nc b gy nr nn l no np">Output:<br/>is 1 less than 2?: True<br/>is 3 less than or equal to 3?: True<br/>is 3 greater than 2?: False<br/>is 3 greater than or equal to 3?: True<br/>is 4 equal to 4?: True<br/>is 4 not equal to 4.0?: True</span></pre><h2 id="6f02" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">按位运算符</h2><p id="5578" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">它们用于执行逻辑运算，如与、或、非、异或等。让我们一个一个地看一下:</p><ul class=""><li id="6de2" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated">AND:<code class="fe mz na nb nc b">&amp;</code>运算符对两个操作数执行按位 AND 运算:</li></ul><pre class="kg kh ki kj gt ni nc nj nk aw nl bi"><span id="b315" class="ls lt iq nc b gy nm nn l no np"><em class="nq"># the AND operation returns 1 when both operands are 1.<br/># Bitwise AND means we'll perform AND operations on the<br/># two numbers below, bit by bit, starting with the rightmost bits:<br/># 11 (decimal) = 1011 (binary)<br/># 13 (decimal) = 1101 (binary)<br/># ------------------------------------------<br/># 11 &amp; 13      = 1001 (binary) = 9 (decimal)</em></span><span id="53a5" class="ls lt iq nc b gy nr nn l no np"><strong class="nc ir">print</strong>(11 &amp; 13)</span><span id="fd9e" class="ls lt iq nc b gy nr nn l no np">Output:<br/>9</span></pre><ul class=""><li id="aea6" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated">OR:<code class="fe mz na nb nc b">|</code>运算符对两个操作数执行按位 OR 运算:</li></ul><pre class="kg kh ki kj gt ni nc nj nk aw nl bi"><span id="6b42" class="ls lt iq nc b gy nm nn l no np"><em class="nq"># the OR operation returns 1 when at least one operand is 1.<br/># Bitwise OR means we'll perform OR operations on the<br/># two numbers below, bit by bit, starting with the rightmost bits:<br/># 11 (decimal) = 1011 (binary)<br/>#  9 (decimal) = 1001 (binary)<br/># ------------------------------------------<br/># 11 | 9       = 1011 (binary) = 11 (decimal)</em></span><span id="3947" class="ls lt iq nc b gy nr nn l no np"><strong class="nc ir">print</strong>(11 | 9)</span><span id="d425" class="ls lt iq nc b gy nr nn l no np">Output:<br/>11</span></pre><ul class=""><li id="2303" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated">XOR:<code class="fe mz na nb nc b">^</code>运算符对两个操作数执行按位 XOR 运算:</li></ul><pre class="kg kh ki kj gt ni nc nj nk aw nl bi"><span id="948c" class="ls lt iq nc b gy nm nn l no np"><em class="nq"># the XOR operation returns 1 when exactly one operand is 1,<br/># while the other is 0.<br/># Bitwise XOR means we'll perform XOR operations on the<br/># two numbers below, bit by bit, starting with the rightmost bits:<br/># 11 (decimal) = 1011 (binary)<br/># 13 (decimal) = 1101 (binary)<br/># ------------------------------------------<br/># 11 ^ 13      = 0110 (binary) = 6 (decimal)</em></span><span id="dcd6" class="ls lt iq nc b gy nr nn l no np"><strong class="nc ir">print</strong>(11 ^ 13)</span><span id="b239" class="ls lt iq nc b gy nr nn l no np">Output:<br/>6</span></pre><ul class=""><li id="06f6" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated">NOT:<code class="fe mz na nb nc b">~</code>运算符对操作数执行 NOT 运算:</li></ul><pre class="kg kh ki kj gt ni nc nj nk aw nl bi"><span id="407d" class="ls lt iq nc b gy nm nn l no np"><em class="nq"># the NOT operation effectively turns all 0 bits into 1<br/># and vice-versa. Or, in other words, it returns one's<br/># complement of the number<br/># 11 (decimal) = 1011 (binary)<br/># ---------------------------------------------------<br/># ~11          = -(1011 + 1) (binary) = -12 (decimal)</em></span><span id="f810" class="ls lt iq nc b gy nr nn l no np"><em class="nq"># 11 (decimal) = <br/># 0000000000000000000000000000000000000000000000000000000000001011<br/># ~11 = -12 (decimal) = <br/># 1111111111111111111111111111111111111111111111111111111111110100</em></span><span id="b4ae" class="ls lt iq nc b gy nr nn l no np"><strong class="nc ir">print</strong>(~11)</span><span id="656f" class="ls lt iq nc b gy nr nn l no np">Output:<br/>-12</span></pre><ul class=""><li id="c5c2" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated">左移:<code class="fe mz na nb nc b">&lt;&lt;</code>运算符将左操作数的所有位左移，其位数等于右操作数的值。空出的位置被有效地用 0 填充。实际上，<code class="fe mz na nb nc b">a &lt;&lt; b</code>相当于以下内容:<code class="fe mz na nb nc b">a * (2 ** b)</code>(将<code class="fe mz na nb nc b">a</code>的位左移若干个<code class="fe mz na nb nc b">b</code>位置):</li></ul><pre class="kg kh ki kj gt ni nc nj nk aw nl bi"><span id="7ef1" class="ls lt iq nc b gy nm nn l no np"><em class="nq"># the left shift operation shifts all of the bits<br/># to the left, a number of positions:<br/># 11 (decimal) = 1011   (binary)<br/># 11 &lt;&lt; 2      = 110100 (binary) = 44</em></span><span id="8d14" class="ls lt iq nc b gy nr nn l no np"><strong class="nc ir">print</strong>(11 &lt;&lt; 2)</span><span id="21e9" class="ls lt iq nc b gy nr nn l no np">Output:<br/>44</span></pre><ul class=""><li id="3390" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated">右移:<code class="fe mz na nb nc b">&gt;&gt;</code>运算符将左操作数的所有位向右移动，移动的位置数等于右操作数的值。移位会覆盖在此过程中丢失的许多位。本质上，<code class="fe mz na nb nc b">a &gt;&gt; b</code>操作相当于<code class="fe mz na nb nc b">a // (2 ** b)</code>(将<code class="fe mz na nb nc b">a</code>的位向右移动若干个<code class="fe mz na nb nc b">b</code>位置):</li></ul><pre class="kg kh ki kj gt ni nc nj nk aw nl bi"><span id="08e4" class="ls lt iq nc b gy nm nn l no np"><em class="nq"># the right shift operation shifts all of the bits<br/># to the right, a number of positions:<br/># 44 (decimal) = 101100 (binary)<br/># 44 &gt;&gt; 2      = 001101 (binary) = 11</em></span><span id="fdc5" class="ls lt iq nc b gy nr nn l no np"><strong class="nc ir">print</strong>(44 &gt;&gt; 2)</span><span id="a252" class="ls lt iq nc b gy nr nn l no np">Output:<br/>11</span></pre><h2 id="3e80" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">赋值运算符</h2><p id="3357" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">这些运算符用于给变量赋值。我们会发现，实际上，只有一个真正的赋值操作符和十二个快捷操作符在实际赋值之前执行特定的操作。我们马上就会明白这意味着什么:</p><ul class=""><li id="59eb" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated">这是我们刚刚提到的赋值操作符。它有效地将右操作数(变量或表达式)的值赋给左操作数(通常是变量):</li></ul><pre class="kg kh ki kj gt ni nc nj nk aw nl bi"><span id="b20b" class="ls lt iq nc b gy nm nn l no np">a = 2<br/><strong class="nc ir">print</strong>(a)</span><span id="d7e2" class="ls lt iq nc b gy nr nn l no np">b = a + 5<br/><strong class="nc ir">print</strong>(b)</span><span id="0043" class="ls lt iq nc b gy nr nn l no np">Output:<br/>2<br/>7</span></pre><ul class=""><li id="5562" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated"><code class="fe mz na nb nc b">+=</code>:加法赋值。将两个操作数之和赋给左操作数:</li></ul><pre class="kg kh ki kj gt ni nc nj nk aw nl bi"><span id="8463" class="ls lt iq nc b gy nm nn l no np"><em class="nq"># regular assignment</em><br/>a = 2<br/>a = a + 3<br/><strong class="nc ir">print</strong>(a)</span><span id="4a61" class="ls lt iq nc b gy nr nn l no np"><em class="nq"># addition assignment</em><br/>a = 2<br/>a += 3<br/><strong class="nc ir">print</strong>(a)</span><span id="e6c6" class="ls lt iq nc b gy nr nn l no np">Output:<br/>5<br/>5</span></pre><p id="f0a1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从上面可以看出，第一个例子中的<code class="fe mz na nb nc b">a</code>最初的值是 2。然后，<code class="fe mz na nb nc b">a = a + 3</code>被执行了。因此，<code class="fe mz na nb nc b">a + 3</code>被评估为 5，并被分配到<code class="fe mz na nb nc b">a</code>。第二个例子只是用快捷加法赋值运算符<code class="fe mz na nb nc b">a += 3</code>替换了<code class="fe mz na nb nc b">a = a + 3</code>，也可以理解为<em class="nq">将变量</em> <code class="fe mz na nb nc b"><em class="nq">a</em></code>加 3，或者<em class="nq">将</em> <code class="fe mz na nb nc b"><em class="nq">a</em></code> <em class="nq">增加 3 </em>。</p><ul class=""><li id="b374" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated"><code class="fe mz na nb nc b">-=</code>:减法赋值。类似于加法赋值，但不是 sum，而是两个操作数之间的差被赋值给左操作数:</li></ul><pre class="kg kh ki kj gt ni nc nj nk aw nl bi"><span id="02fa" class="ls lt iq nc b gy nm nn l no np"><em class="nq"># regular assignment</em><br/>a = 3<br/>a = a - 2<br/><strong class="nc ir">print</strong>(a)</span><span id="5075" class="ls lt iq nc b gy nr nn l no np"><em class="nq"># subtraction assignment</em><br/>a = 3<br/>a -= 2<br/><strong class="nc ir">print</strong>(a)</span><span id="2b36" class="ls lt iq nc b gy nr nn l no np">Output:<br/>1<br/>1</span></pre><p id="1a13" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">加法赋值操作符使我们能够用快捷方式<code class="fe mz na nb nc b">a -= 2</code>成功地替换第一个例子中的常规赋值操作(<code class="fe mz na nb nc b">a = a — 2</code>)，这可以翻译成类似于<em class="nq">减 2 </em>。</p><ul class=""><li id="d44b" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated"><code class="fe mz na nb nc b">*=</code>:产品分配。将两个操作数的乘积结果赋给左操作数:</li></ul><pre class="kg kh ki kj gt ni nc nj nk aw nl bi"><span id="e2e4" class="ls lt iq nc b gy nm nn l no np"><em class="nq"># regular assignment</em><br/>a = 3<br/>a = a * 2<br/><strong class="nc ir">print</strong>(a)</span><span id="5f42" class="ls lt iq nc b gy nr nn l no np"><em class="nq"># product assignment</em><br/>a = 3<br/>a *= 2<br/><strong class="nc ir">print</strong>(a)</span><span id="9d10" class="ls lt iq nc b gy nr nn l no np">Output:<br/>6<br/>6</span></pre><p id="8284" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个快捷操作符将<code class="fe mz na nb nc b">a = a * 2</code>翻译成可读性更好，但绝对更简单的<code class="fe mz na nb nc b">a *= 2</code>来获得相同的结果。</p><ul class=""><li id="4cba" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated"><code class="fe mz na nb nc b">/=</code>:分部分配。将两个操作数相除的结果赋给左边的操作数:</li></ul><pre class="kg kh ki kj gt ni nc nj nk aw nl bi"><span id="3728" class="ls lt iq nc b gy nm nn l no np"><em class="nq"># regular assignment</em><br/>a = 3<br/>a = a / 2<br/><strong class="nc ir">print</strong>(a)</span><span id="ee2c" class="ls lt iq nc b gy nr nn l no np"><em class="nq"># division assignment</em><br/>a = 3<br/>a /= 2<br/><strong class="nc ir">print</strong>(a)</span><span id="0f1d" class="ls lt iq nc b gy nr nn l no np">Output:<br/>1.5<br/>1.5</span></pre><ul class=""><li id="9232" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated"><code class="fe mz na nb nc b">%=</code>:模数分配。计算两个操作数相除的余数，并将其赋给左操作数:</li></ul><pre class="kg kh ki kj gt ni nc nj nk aw nl bi"><span id="37f3" class="ls lt iq nc b gy nm nn l no np"><em class="nq"># regular assignment</em><br/>a = 3<br/>a = a % 2<br/><strong class="nc ir">print</strong>(a)</span><span id="daa6" class="ls lt iq nc b gy nr nn l no np"><em class="nq"># modulus assignment</em><br/>a = 3<br/>a %= 2<br/><strong class="nc ir">print</strong>(a)</span><span id="e190" class="ls lt iq nc b gy nr nn l no np">Output:<br/>1<br/>1</span></pre><ul class=""><li id="ccdd" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated"><code class="fe mz na nb nc b">//=</code>:楼层划分分配。对两个操作数执行浮点除法，并将结果赋给左边的操作数:</li></ul><pre class="kg kh ki kj gt ni nc nj nk aw nl bi"><span id="788b" class="ls lt iq nc b gy nm nn l no np"><em class="nq"># regular assignment</em><br/>a = 3<br/>a = a // 2<br/><strong class="nc ir">print</strong>(a)</span><span id="a09b" class="ls lt iq nc b gy nr nn l no np"><em class="nq"># floor division assignment</em><br/>a = 3<br/>a //= 2<br/><strong class="nc ir">print</strong>(a)</span><span id="1725" class="ls lt iq nc b gy nr nn l no np">Output:<br/>1<br/>1</span></pre><ul class=""><li id="42c2" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated"><code class="fe mz na nb nc b">**=</code>:取幂赋值。对两个操作数执行取幂运算，并将结果赋给左边的操作数:</li></ul><pre class="kg kh ki kj gt ni nc nj nk aw nl bi"><span id="fb5f" class="ls lt iq nc b gy nm nn l no np"><em class="nq"># regular assignment</em><br/>a = 3<br/>a = a ** 2<br/><strong class="nc ir">print</strong>(a)</span><span id="f9b2" class="ls lt iq nc b gy nr nn l no np"><em class="nq"># exponentiation assignment</em><br/>a = 3<br/>a **= 2<br/><strong class="nc ir">print</strong>(a)</span><span id="ec1a" class="ls lt iq nc b gy nr nn l no np">Output:<br/>9<br/>9</span></pre><ul class=""><li id="8fa9" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated"><code class="fe mz na nb nc b">&amp;=</code>:和赋值。对两个操作数执行按位 AND 运算，并将结果赋给左边的操作数。在下面的例子中，我们的两个操作数的值分别是 11 和 13。对这两个值进行简单的按位 AND 运算，得到的结果正好是 9:</li></ul><pre class="kg kh ki kj gt ni nc nj nk aw nl bi"><span id="bac3" class="ls lt iq nc b gy nm nn l no np"><em class="nq"># the AND operation returns 1 when both operands are 1.<br/># Bitwise AND means we'll perform AND operations on the<br/># two numbers below, bit by bit, starting with the rightmost bits:<br/># 11 (decimal) = 1011 (binary)<br/># 13 (decimal) = 1101 (binary)<br/># ------------------------------------------<br/># 11 &amp; 13      = 1001 (binary) = 9 (decimal)</em></span></pre><p id="5784" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面进一步演示了该示例:</p><pre class="kg kh ki kj gt ni nc nj nk aw nl bi"><span id="1b29" class="ls lt iq nc b gy nm nn l no np"><em class="nq"># regular assignment</em><br/>a = 11<br/>a = a &amp; 13<br/><strong class="nc ir">print</strong>(a)</span><span id="15c3" class="ls lt iq nc b gy nr nn l no np"><em class="nq"># and assignment</em><br/>a = 11<br/>a &amp;= 13<br/><strong class="nc ir">print</strong>(a)</span><span id="9bf7" class="ls lt iq nc b gy nr nn l no np">Output:<br/>9<br/>9</span></pre><ul class=""><li id="669d" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated"><code class="fe mz na nb nc b">|=</code>:或分配。对两个操作数执行按位“或”运算，并将结果赋给左边的操作数。在下面的例子中，我们的两个操作数的值分别是 11 和 9。对这两个值进行简单的按位“或”运算正好得到 11:</li></ul><pre class="kg kh ki kj gt ni nc nj nk aw nl bi"><span id="9b4e" class="ls lt iq nc b gy nm nn l no np"><em class="nq"># the OR operation returns 1 when at least one operand is 1.<br/># Bitwise OR means we'll perform OR operations on the<br/># two numbers below, bit by bit, starting with the rightmost bits:<br/># 11 (decimal) = 1011 (binary)<br/>#  9 (decimal) = 1001 (binary)<br/># ------------------------------------------<br/># 11 | 9       = 1011 (binary) = 11 (decimal)</em></span></pre><p id="42c1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面进一步演示了该示例:</p><pre class="kg kh ki kj gt ni nc nj nk aw nl bi"><span id="6438" class="ls lt iq nc b gy nm nn l no np"><em class="nq"># regular assignment</em><br/>a = 11<br/>a = a | 9<br/><strong class="nc ir">print</strong>(a)</span><span id="9648" class="ls lt iq nc b gy nr nn l no np"><em class="nq"># or assignment</em><br/>a = 11<br/>a |= 9<br/><strong class="nc ir">print</strong>(a)</span><span id="06a4" class="ls lt iq nc b gy nr nn l no np">Output:<br/>11<br/>11</span></pre><ul class=""><li id="3998" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated"><code class="fe mz na nb nc b">^=</code>:异或赋值。对两个操作数执行按位 XOR 运算，并将结果赋给左边的操作数。在下面的例子中，我们的两个操作数的值分别是 11 和 13。对这两个值进行简单的按位“或”运算正好得到 6:</li></ul><pre class="kg kh ki kj gt ni nc nj nk aw nl bi"><span id="a093" class="ls lt iq nc b gy nm nn l no np"><em class="nq"># the XOR operation returns 1 when exactly one operand is 1,<br/># while the other is 0.<br/># Bitwise XOR means we'll perform XOR operations on the<br/># two numbers below, bit by bit, starting with the rightmost bits:<br/># 11 (decimal) = 1011 (binary)<br/># 13 (decimal) = 1101 (binary)<br/># ------------------------------------------<br/># 11 ^ 13      = 0110 (binary) = 6 (decimal)</em></span></pre><p id="d03e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面进一步演示了该示例:</p><pre class="kg kh ki kj gt ni nc nj nk aw nl bi"><span id="1d71" class="ls lt iq nc b gy nm nn l no np"><em class="nq"># regular assignment</em><br/>a = 11<br/>a = a ^ 13<br/><strong class="nc ir">print</strong>(a)</span><span id="9ed7" class="ls lt iq nc b gy nr nn l no np"><em class="nq"># xor assignment</em><br/>a = 11<br/>a ^= 13<br/><strong class="nc ir">print</strong>(a)</span><span id="4195" class="ls lt iq nc b gy nr nn l no np">Output:<br/>6<br/>6</span></pre><ul class=""><li id="da9e" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated"><code class="fe mz na nb nc b">&gt;&gt;=</code>:右移赋值。对操作数执行按位右移，并将结果赋给左操作数:</li></ul><pre class="kg kh ki kj gt ni nc nj nk aw nl bi"><span id="7852" class="ls lt iq nc b gy nm nn l no np"><em class="nq"># the right shift operation shifts all of the bits<br/># to the right, a number of positions:<br/># 44 (decimal) = 101100 (binary)<br/># 44 &gt;&gt; 2      = 001101 (binary) = 11</em></span></pre><p id="735e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从上面可以看出，<strong class="ky ir">对于某种类型的数字来说——</strong>这些数字被称为两个的<strong class="ky ir">次方，我们都很熟悉其中的一些(2、4、8、16、32、64、128、256、512、1024 等等。)，相当于将数字除以 2 的<code class="fe mz na nb nc b">n</code>次方，其中<code class="fe mz na nb nc b">n</code>是要移位的位置数。在我们的例子中，我们将所有的位向右移动了两次，所以就像说<em class="nq">用 4 除 44</em>。</strong></p><p id="4e4b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不幸的是，对于奇数来说，这并不成立。尝试在比如 11 上执行 1 位置右移，将得到 5:</p><pre class="kg kh ki kj gt ni nc nj nk aw nl bi"><span id="c60b" class="ls lt iq nc b gy nm nn l no np"><em class="nq"># 11 (decimal) = 1011 (binary)<br/># 11 &gt;&gt; 1      = 0101 (binary) = 5</em></span></pre><p id="62ed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，我们可以认为<strong class="ky ir">右移</strong>操作等同于我们之前经历的<strong class="ky ir">地板分区</strong>操作:</p><pre class="kg kh ki kj gt ni nc nj nk aw nl bi"><span id="7142" class="ls lt iq nc b gy nm nn l no np"><em class="nq"># </em><strong class="nc ir"><em class="nq">a &gt;&gt; b</em></strong><em class="nq"> would be equivalent to </em><strong class="nc ir"><em class="nq">a // (2 ** b)</em></strong></span></pre><p id="0933" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们来总结一下如何成功使用右移位赋值运算符:</p><pre class="kg kh ki kj gt ni nc nj nk aw nl bi"><span id="b58a" class="ls lt iq nc b gy nm nn l no np"><em class="nq"># regular assignment<br/></em>a = 44<br/>a = a &gt;&gt; 2<br/><strong class="nc ir">print</strong>(a)</span><span id="ca6b" class="ls lt iq nc b gy nr nn l no np"><em class="nq"># right shift assignment<br/></em>a = 44<br/>a &gt;&gt;= 2<br/><strong class="nc ir">print</strong>(a)</span><span id="17c2" class="ls lt iq nc b gy nr nn l no np">Output:<br/>11<br/>11</span></pre><ul class=""><li id="a039" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated"><code class="fe mz na nb nc b">&lt;&lt;=</code>:左移分配。对操作数执行按位左移，并将结果赋给左操作数:</li></ul><pre class="kg kh ki kj gt ni nc nj nk aw nl bi"><span id="06de" class="ls lt iq nc b gy nm nn l no np"><em class="nq"># the left shift operation shifts all of the bits<br/># to the left, a number of positions:<br/># 11 (decimal) = 1011   (binary)<br/># 11 &lt;&lt; 2      = 110100 (binary) = 44</em></span></pre><p id="ecc9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从上面可以看出，这相当于将数字乘以 2 的<code class="fe mz na nb nc b">n</code>次方，其中<code class="fe mz na nb nc b">n</code>是要移动的位置数。在我们的例子中，我们将所有的位左移两次，所以就像说<em class="nq">用 4 乘以 11</em>。</p><p id="fd12" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面进一步演示了该示例:</p><pre class="kg kh ki kj gt ni nc nj nk aw nl bi"><span id="c32b" class="ls lt iq nc b gy nm nn l no np"><em class="nq"># regular assignment</em><br/>a = 11<br/>a = a &lt;&lt; 2<br/><strong class="nc ir">print</strong>(a)</span><span id="b881" class="ls lt iq nc b gy nr nn l no np"><em class="nq"># left shift assignment</em><br/>a = 11<br/>a &lt;&lt;= 2<br/><strong class="nc ir">print</strong>(a)</span><span id="4797" class="ls lt iq nc b gy nr nn l no np">Output:<br/>44<br/>44</span></pre><h2 id="de3b" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">逻辑运算符</h2><p id="f86a" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">Python 中的条件表达式广泛使用了三种逻辑运算符，我们将介绍如下:</p><ul class=""><li id="ba46" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated">逻辑与—应用于两个操作数，如果两个操作数都是<code class="fe mz na nb nc b">True</code>，则计算结果为<code class="fe mz na nb nc b">True</code>。如果其中至少有一个是<code class="fe mz na nb nc b">False</code>，则表达式求值为<code class="fe mz na nb nc b">False</code>；</li><li id="645d" class="mq mr iq ky b kz nd lc ne lf nf lj ng ln nh lr mv mw mx my bi translated">逻辑 OR —应用于两个操作数，如果两个操作数中的任何一个为<code class="fe mz na nb nc b">True</code>，则计算结果为<code class="fe mz na nb nc b">True</code>。如果两者都是<code class="fe mz na nb nc b">False</code>，则表达式求值为<code class="fe mz na nb nc b">False</code>；</li><li id="e9a6" class="mq mr iq ky b kz nd lc ne lf nf lj ng ln nh lr mv mw mx my bi translated">逻辑非—应用于一个操作数时，它反转操作数的布尔值。如果是<code class="fe mz na nb nc b">True</code>，操作评估为<code class="fe mz na nb nc b">False</code>，反之亦然:</li></ul><pre class="kg kh ki kj gt ni nc nj nk aw nl bi"><span id="33d7" class="ls lt iq nc b gy nm nn l no np"><em class="nq"># initialize two boolean variables</em><br/>a = <strong class="nc ir">True</strong><br/>b = <strong class="nc ir">False</strong></span><span id="dd3d" class="ls lt iq nc b gy nr nn l no np"><em class="nq"># perform some logical operations</em><strong class="nc ir"><br/>print</strong>(a <strong class="nc ir">and</strong> b)<br/><strong class="nc ir">print</strong>(a <strong class="nc ir">or</strong> b)<br/><strong class="nc ir">print</strong>(<strong class="nc ir">not</strong> b)</span><span id="9879" class="ls lt iq nc b gy nr nn l no np">Output:<br/>False<br/>True<br/>True</span></pre><h2 id="175a" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">成员运算符</h2><p id="6f63" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">这是本文中非常简短但极其重要的小节。因为 Python 中只有两个成员操作符，但它们被广泛用作检查一个值是否出现在序列中的最佳方式。这两个运算符是:</p><ul class=""><li id="8fe4" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated"><code class="fe mz na nb nc b">in</code>；</li><li id="0cc2" class="mq mr iq ky b kz nd lc ne lf nf lj ng ln nh lr mv mw mx my bi translated"><code class="fe mz na nb nc b">not in</code>。</li></ul><p id="74c5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以有效地使用它们来检查一个值是否是整数列表的成员，是否在字符串中找到了一个字符，或者是否在字典中找到了一个键，这样的例子还可以继续下去。如果是这种情况，那么运算结果为<code class="fe mz na nb nc b">True</code>，否则，如果值不包含在我们的序列中，我们的结果将为<code class="fe mz na nb nc b">False</code>。</p><pre class="kg kh ki kj gt ni nc nj nk aw nl bi"><span id="2f28" class="ls lt iq nc b gy nm nn l no np"><em class="nq"># list of integers</em><br/>my_list = [0, 1, 2, 3, 4, 5]</span><span id="e023" class="ls lt iq nc b gy nr nn l no np"><strong class="nc ir">print</strong>(9 <strong class="nc ir">in</strong> my_list)<br/><strong class="nc ir">print</strong>(4 <strong class="nc ir">in</strong> my_list)<br/><strong class="nc ir">print</strong>(8 <strong class="nc ir">not</strong> <strong class="nc ir">in</strong> my_list)</span><span id="c3b0" class="ls lt iq nc b gy nr nn l no np">Output:<br/>False<br/>True<br/>True</span></pre><h2 id="3639" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">标识运算符</h2><p id="33a6" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">类似于成员操作符的重要性，Python 中的标识操作符也被广泛使用。他们只有两个人:</p><ul class=""><li id="5b2d" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated"><code class="fe mz na nb nc b">is</code>；</li><li id="1840" class="mq mr iq ky b kz nd lc ne lf nf lj ng ln nh lr mv mw mx my bi translated"><code class="fe mz na nb nc b">is not</code>。</li></ul><p id="1cde" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它们用于检查两个操作数是否是同一个对象:</p><pre class="kg kh ki kj gt ni nc nj nk aw nl bi"><span id="b9b1" class="ls lt iq nc b gy nm nn l no np"><em class="nq"># integers are immutable</em><br/>a = 2<br/>b = 2<br/><strong class="nc ir">print</strong>(a <strong class="nc ir">is</strong> b)</span><span id="eb4a" class="ls lt iq nc b gy nr nn l no np"><em class="nq"># lists are mutable</em><br/>list_a = [1, 2, 3]<br/>list_b = [1, 2, 3]<br/><strong class="nc ir">print</strong>(list_a <strong class="nc ir">is not</strong> list_b)</span><span id="b6b5" class="ls lt iq nc b gy nr nn l no np">Output:<br/>True<br/>True</span></pre><p id="5e24" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第一个例子中有两个整型变量被声明为具有相同的值。因为整数是不可变的，它们有相同的 id，所以它们确实是同一个对象。</p><p id="558b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在第二个例子中，两个列表以相同的顺序被声明为具有相同的元素。然而，由于列表是可变的，两个 id 不会相同，所以即使列表碰巧具有相同的值，它们也不会指向同一个对象。</p><p id="eb51" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">关于 Python 中的操作符的话题，这就差不多了。最重要的是，我们要先了解这些经营者，以便更好地了解我们可以通过他们做些什么来改进我们的工艺。</p><p id="e261" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，可能比运算符本身更重要的是，运算符优先级表应该为我们提供很多帮助。当然，最可靠的来源是官方文档，<a class="ae kv" href="https://docs.python.org/3/reference/expressions.html#operator-precedence" rel="noopener ugc nofollow" target="_blank">这里的</a>是 Python 中运算符优先级的表格。它解释了哪些操作符首先被求值，我们是否应该有包含多类操作符的复杂表达式。</p><p id="35b1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">话虽如此，干杯，期待<a class="ae kv" href="https://medium.com/@deck451/python-up-your-code-scopes-72f367e26b09" rel="noopener">下一个</a>一个。编码快乐！</p></div><div class="ab cl ns nt hu nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ij ik il im in"><p id="0546" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="nq"> Deck 是软件工程师、导师、作家，有时甚至是老师。他拥有 12 年以上的软件工程经验，现在是 Python 编程语言的真正倡导者，同时他的热情是帮助人们提高他们的 Python(以及一般的编程)技能。你可以在</em> <a class="ae kv" href="https://www.linkedin.com/in/deck451/" rel="noopener ugc nofollow" target="_blank"> <em class="nq">【领英】</em></a><em class="nq"/><a class="ae kv" href="https://www.facebook.com/deck451/" rel="noopener ugc nofollow" target="_blank"><em class="nq">【脸书】</em></a><em class="nq"/><a class="ae kv" href="https://twitter.com/Deck45100" rel="noopener ugc nofollow" target="_blank"><em class="nq">推特</em></a><em class="nq"/><a class="ae kv" href="https://discord.com" rel="noopener ugc nofollow" target="_blank"><em class="nq">不和谐</em> </a> <em class="nq"> : Deck451#6188，以及跟随他写在这里的</em> <a class="ae kv" href="https://medium.com/@deck451" rel="noopener"> <em class="nq">中</em> </a> <em class="nq"/></p></div></div>    
</body>
</html>