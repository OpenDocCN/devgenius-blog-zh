<html>
<head>
<title>Props and functions in React made easy!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React中的道具和功能变得简单！</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/props-and-functions-in-react-made-easy-2ccbf69b135?source=collection_archive---------19-----------------------#2020-07-02">https://blog.devgenius.io/props-and-functions-in-react-made-easy-2ccbf69b135?source=collection_archive---------19-----------------------#2020-07-02</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/8933e4fa3854e49902a096a7f2866351.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y6C4nSvy2Woe0m7bWEn4BA.png"/></div></div></figure><p id="9ec5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Props类似于ReactJS中传递给函数的参数。React中的每个组件都被视为一个函数。所以，道具是不可改变的。这肯定是任何人开始写文章的最粗鲁的方式，但是真的，来这里寻找道具信息的人不会在乎。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi kt"><img src="../Images/89320d86958bb2acace1982e3c49834d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nRKrRK-HL8GW6ENk0eOjcw.jpeg"/></div></div></figure><p id="cdde" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">通过将属性传递给构造函数，可以在实例化时配置组件——这些属性称为props。props可以像<code class="fe ky kz la lb b">this.props</code>一样从组件的方法中访问，以便改变组件的呈现方式和/或行为方式。然而，道具不能从组件的方法中被修改。</p><pre class="ku kv kw kx gt lc lb ld le aw lf bi"><span id="cb61" class="lg lh in lb b gy li lj l lk ll">function Hello_to_you(props) {</span><span id="642e" class="lg lh in lb b gy lm lj l lk ll"> return &lt;h1&gt;Hey there, {props.name} !&lt;/h1&gt;;</span><span id="e4ee" class="lg lh in lb b gy lm lj l lk ll">}</span></pre><p id="e3e3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果props被传递给一个类而不是一个函数，那么它就变成了<code class="fe ky kz la lb b">this.props.whatever </code>而不仅仅是<code class="fe ky kz la lb b"> props.whatever</code>。这就是代表属性的props在不同情况下的访问方式。</p><pre class="ku kv kw kx gt lc lb ld le aw lf bi"><span id="48fc" class="lg lh in lb b gy li lj l lk ll">class<!-- --> <!-- -->Hello_to_you<!-- --> <!-- -->extends<!-- --> <!-- -->React.Component<!-- --> <!-- -->{</span><span id="a214" class="lg lh in lb b gy lm lj l lk ll">  render()<!-- --> <!-- -->{</span><span id="25b7" class="lg lh in lb b gy lm lj l lk ll">   return<!-- --> <!-- -->&lt;h1&gt;Hey there, {this.<!-- -->props<!-- -->.<!-- -->name<!-- -->} !&lt;/h1&gt;;</span><span id="c6b3" class="lg lh in lb b gy lm lj l lk ll">  }</span><span id="98ce" class="lg lh in lb b gy lm lj l lk ll">}</span></pre><p id="2073" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">构造器方法在类中用于初始化状态，在此之前，声明一个超级全局变量。</p><pre class="ku kv kw kx gt lc lb ld le aw lf bi"><span id="4ae9" class="lg lh in lb b gy li lj l lk ll">class App extends React.Component{</span><span id="56b9" class="lg lh in lb b gy lm lj l lk ll"> constructor() {</span><span id="9696" class="lg lh in lb b gy lm lj l lk ll">  <strong class="lb io">super()</strong></span><span id="d315" class="lg lh in lb b gy lm lj l lk ll"><strong class="lb io">  this.state = {</strong></span><span id="4a10" class="lg lh in lb b gy lm lj l lk ll"><strong class="lb io">   answer: “Yes”</strong></span><span id="ae76" class="lg lh in lb b gy lm lj l lk ll">  }</span><span id="cf02" class="lg lh in lb b gy lm lj l lk ll"> }</span><span id="7764" class="lg lh in lb b gy lm lj l lk ll"> render() {</span><span id="d83d" class="lg lh in lb b gy lm lj l lk ll">  return (</span><span id="8baf" class="lg lh in lb b gy lm lj l lk ll">   &lt;div&gt;</span><span id="bde4" class="lg lh in lb b gy lm lj l lk ll">    &lt;p&gt;Is the state important to know? {this.state.answer}&lt;/p&gt;</span><span id="ccab" class="lg lh in lb b gy lm lj l lk ll">   &lt;/div&gt;</span><span id="1658" class="lg lh in lb b gy lm lj l lk ll">  )</span><span id="adba" class="lg lh in lb b gy lm lj l lk ll"> }</span><span id="9d59" class="lg lh in lb b gy lm lj l lk ll">}</span></pre><p id="322f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">【HTML元素的JavaScript函数</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div class="gh gi ln"><img src="../Images/85bc48b072fe71bcdebd8f172133a97c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/format:webp/1*MTPXkFkJHMS4hz3YBS934g.jpeg"/></div></figure><p id="cfef" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果您需要在React页面上创建一些东西，通过点击一个按钮或通过其他方式触发来不断改变它的值，那么您就来对地方了。</p><p id="fec0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">React给了你特权，让你可以在HTML所在的地方编写函数，并用它的元素绑定它。这将吸引我的懒惰上瘾的同伴。我将展示两个非常简单的函数的工作原理，它实际上类似于我们用DOM操纵编写的函数，只是没有复杂性。下面的函数在单击按钮时增加变量的值。</p><p id="6a5b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们首先需要在构造函数中初始化它。</p><pre class="ku kv kw kx gt lc lb ld le aw lf bi"><span id="16be" class="lg lh in lb b gy li lj l lk ll">constructor() {</span><span id="d30d" class="lg lh in lb b gy lm lj l lk ll"> super()</span><span id="2b69" class="lg lh in lb b gy lm lj l lk ll">  this.state = {</span><span id="e01b" class="lg lh in lb b gy lm lj l lk ll">  count: 0</span><span id="dc02" class="lg lh in lb b gy lm lj l lk ll">}</span></pre><p id="f982" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">1.接下来，我们将按照通常的方式编写函数，在类中编写<strong class="jx io">:</strong></p><pre class="ku kv kw kx gt lc lb ld le aw lf bi"><span id="06e6" class="lg lh in lb b gy li lj l lk ll">handleClick(condition) {</span><span id="404a" class="lg lh in lb b gy lm lj l lk ll"> this.setState(prevState =&gt; {</span><span id="bac6" class="lg lh in lb b gy lm lj l lk ll">  if(condition == 1){</span><span id="3e6d" class="lg lh in lb b gy lm lj l lk ll">  return {</span><span id="1e5f" class="lg lh in lb b gy lm lj l lk ll">   count: prevState.count + 1</span><span id="ab28" class="lg lh in lb b gy lm lj l lk ll">  }</span><span id="18d6" class="lg lh in lb b gy lm lj l lk ll"> }</span><span id="4767" class="lg lh in lb b gy lm lj l lk ll">  else if(condition == 2) {</span><span id="06f0" class="lg lh in lb b gy lm lj l lk ll">  return {</span><span id="be24" class="lg lh in lb b gy lm lj l lk ll">   count: prevState.count + 2</span><span id="b259" class="lg lh in lb b gy lm lj l lk ll">  }</span><span id="a786" class="lg lh in lb b gy lm lj l lk ll"> }</span><span id="1100" class="lg lh in lb b gy lm lj l lk ll">});</span><span id="7049" class="lg lh in lb b gy lm lj l lk ll">}</span></pre><p id="2180" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">条件被传递给函数<code class="fe ky kz la lb b">handleClick();</code>。它检查哪个按钮被点击，并相应地改变值。因为它的状态之前已经声明过了，所以现在我们可以操作它了。<code class="fe ky kz la lb b">prevstate</code>检查变量条件的先前状态，而<code class="fe ky kz la lb b">this.setstate</code>用于改变React中变量的状态。</p><p id="bdd2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">2.将此功能添加到所需的按钮中。</p><pre class="ku kv kw kx gt lc lb ld le aw lf bi"><span id="2513" class="lg lh in lb b gy li lj l lk ll"> &lt;button onClick={() =&gt; this.handleClick(1)}&gt;Increment by 1!&lt;/button&gt;&lt;br /&gt;</span><span id="6271" class="lg lh in lb b gy lm lj l lk ll">&lt;button onClick={() =&gt; this.handleClick(2)}&gt;Increment by 2!&lt;/button&gt;&lt;br /&gt; </span></pre><p id="8541" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">3.上述函数将不起作用，因为它尚未绑定到构造函数。为此，我们需要在构造函数中编写<strong class="jx io">下面的语句。</strong></p><pre class="ku kv kw kx gt lc lb ld le aw lf bi"><span id="d64f" class="lg lh in lb b gy li lj l lk ll"> this.handleClick = this.handleClick.bind(this)</span></pre><p id="b9a7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">4.您需要打印count的值，因此，在return语句中，您需要将下面的语句放在某个地方。</p><pre class="ku kv kw kx gt lc lb ld le aw lf bi"><span id="0153" class="lg lh in lb b gy li lj l lk ll">render() {</span><span id="c9ca" class="lg lh in lb b gy lm lj l lk ll">return (</span><span id="3e36" class="lg lh in lb b gy lm lj l lk ll"> &lt;div className=”main-content”&gt;</span><span id="0d77" class="lg lh in lb b gy lm lj l lk ll">  &lt;h1&gt;{this.state.count}&lt;/h1&gt;</span><span id="13fe" class="lg lh in lb b gy lm lj l lk ll">  &lt;button onClick={() =&gt; this.handleClick(1)}&gt;Increment by 1! &lt;/button&gt;&lt;br /&gt;&lt;br /&gt;</span><span id="8cc6" class="lg lh in lb b gy lm lj l lk ll">  &lt;button onClick={() =&gt; this.handleClick(2)}&gt;Increment by 2!&lt;/button&gt;&lt;br /&gt;&lt;br /&gt;</span><span id="0346" class="lg lh in lb b gy lm lj l lk ll"> &lt;/div&gt;</span></pre><p id="5e18" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，去点击你的按钮，果然，你会看到屏幕上的数字正在增加。创建递增、递减、相乘和相除的按钮，享受更多的乐趣。别忘了道具。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div class="gh gi lo"><img src="../Images/d7f476415c940ae813d027632849ef6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:450/format:webp/1*kTdQwIfVpxNqwao0TiH-mg.jpeg"/></div></figure></div></div>    
</body>
</html>