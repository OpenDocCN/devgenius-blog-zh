<html>
<head>
<title>JavaScript Best Practices — Arrow Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript最佳实践—箭头函数</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/javascript-best-practices-arrow-functions-259b890df795?source=collection_archive---------25-----------------------#2020-06-22">https://blog.devgenius.io/javascript-best-practices-arrow-functions-259b890df795?source=collection_archive---------25-----------------------#2020-06-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/3c57545682322d3d35832b34d0432a29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CS7fCbi762drpjnQ"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://unsplash.com/@jasonhafso?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Jason Hafso </a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="f802" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像任何类型的应用程序一样，JavaScript应用程序也必须写得很好。</p><p id="9a1d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">否则，我们以后会遇到各种各样的问题。</p><p id="0a6b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究一些使用箭头函数的最佳实践。</p><h1 id="edf1" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">箭头功能的放置</h1><p id="92c2" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">箭头功能的放置完全取决于偏好。</p><p id="4334" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以把它们放在顶层。</p><p id="93e8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们可以将它们放在对象或函数中。</p><p id="6596" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这完全取决于我们。</p><p id="ccf3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="b734" class="mn lc iq mj b gy mo mp l mq mr">const person = {<br/>    getData: (id) =&gt; ajax(URL,{ id })<br/>};</span></pre><p id="784d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="373e" class="mn lc iq mj b gy mo mp l mq mr">export default id =&gt; person.getData(id)</span></pre><p id="f6e9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="b4b1" class="mn lc iq mj b gy mo mp l mq mr">export const getPerson = id =&gt; person.getData(id)</span></pre><p id="b926" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="bb84" class="mn lc iq mj b gy mo mp l mq mr">const getPerson = id =&gt; People.getData(id,onData)</span></pre><p id="1b52" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以将它们放在顶层，作为导出或内部对象。</p><h1 id="0895" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">返回数据</h1><p id="3d76" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们应该确保正确地编写返回语法。,</p><p id="0671" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="fd08" class="mn lc iq mj b gy mo mp l mq mr">const fn = prop =&gt; ( val =&gt; { return { [prop]: val }; } );</span></pre><p id="2ffc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="7542" class="mn lc iq mj b gy mo mp l mq mr">const fn = (x, y) =&gt; {<br/>  return (<br/>    x &gt; 3 ? x : y<br/>  );<br/>};</span></pre><p id="368d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们有一个表达式，我们应该把它们放在括号里。</p><p id="5bbe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，我们应该添加<code class="fe ms mt mu mj b">return</code>关键字，除非我们的函数只有一个语句，并且只返回一个短表达式。</p><p id="cb2c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们也可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="2878" class="mn lc iq mj b gy mo mp l mq mr">const cube = x =&gt; x ** 3;</span></pre><p id="a2aa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这也是可读的。</p><p id="00f9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们有比这更长的箭头函数，那么我们应该添加括号、花括号和关键字<code class="fe ms mt mu mj b">return</code>。</p><h1 id="0b42" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">这个的用途</h1><p id="3866" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们不应该在不需要<code class="fe ms mt mu mj b">this</code>的回调中使用它们。</p><p id="4b6d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="ce5c" class="mn lc iq mj b gy mo mp l mq mr">const squared = arr.map(a =&gt; a ** 2, this);</span></pre><p id="d95a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么我们不需要<code class="fe ms mt mu mj b">this</code>，因为它什么也不做。</p><p id="a8a3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">箭头函数没有自己的<code class="fe ms mt mu mj b">this</code>，所以<code class="fe ms mt mu mj b">this</code>引用函数外<code class="fe ms mt mu mj b">this</code>的任何值。</p><p id="98aa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，<code class="fe ms mt mu mj b">this</code>不应该在顶层，因为它将在严格模式下成为<code class="fe ms mt mu mj b">undefined</code>。</p><p id="35b9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以有这样的东西:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="005f" class="mn lc iq mj b gy mo mp l mq mr">a =&gt; this.bar(a);</span></pre><p id="bc87" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在高层是行不通的。</p><h1 id="f60d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">不要使用arguments关键字</h1><p id="c36f" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们永远不应该使用<code class="fe ms mt mu mj b">arguments</code>关键字。</p><p id="d912" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它用于将所有参数传递给一个传统函数。</p><p id="f00a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它不具备箭头功能。</p><p id="2f98" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，它是一个类似数组的可迭代对象，所以它没有任何数组方法。</p><p id="dc21" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，不使用:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="ac92" class="mn lc iq mj b gy mo mp l mq mr">function sum() {<br/>  const numbers = [...arguments];<br/>  return numbers.reduce((a, b) =&gt; a + b);<br/>}</span></pre><p id="4c1f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以使用rest操作符来代替:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="bd6b" class="mn lc iq mj b gy mo mp l mq mr">const sum = (...numbers) =&gt; {<br/>  return numbers.reduce((a, b) =&gt; a + b);<br/>}</span></pre><p id="a07d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">numbers</code>将是一个数组，所以我们可以对它调用<code class="fe ms mt mu mj b">reduce</code>。</p><p id="a7ac" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">rest操作符为我们省去打字和头痛的麻烦。</p><h1 id="cca7" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">类别的使用</h1><p id="dba1" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以对构造函数使用<code class="fe ms mt mu mj b">class</code>。</p><p id="ed94" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">理想情况下，我们尽量少用它们，因为它们拥有内部状态，并且拥有会产生副作用的方法。</p><p id="f864" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，只要有可能，我们就使用纯函数。</p><p id="42c7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="ec28" class="mn lc iq mj b gy mo mp l mq mr">const rectangle = (height, width) =&gt; {<br/>  return {<br/>    height: height,<br/>    width: width<br/>  };<br/>}</span></pre><p id="363f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而不是:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="6aa3" class="mn lc iq mj b gy mo mp l mq mr">class Rectangle{<br/>  constructor(height, width) {<br/>    this.height = height;<br/>    this.width = width;<br/>  }<br/>}</span></pre><h1 id="bb6e" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">不要使用删除关键字</h1><p id="b60d" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">关键字<code class="fe ms mt mu mj b">delete</code>从一个对象中删除一个属性。</p><p id="71fa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这意味着物体发生了变异。</p><p id="e49f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，最好制作一个没有我们想要的属性的对象的副本。</p><p id="efc5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而不是写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="720a" class="mn lc iq mj b gy mo mp l mq mr">delete foo.bar;</span></pre><p id="413a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以使用类似Lodash的东西来创建一个没有属性的新对象:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="9743" class="mn lc iq mj b gy mo mp l mq mr">const _ = require('lodash/fp');<br/><br/>const fooWithoutBar = _.omit('bar', foo);</span></pre><h1 id="7677" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">不要使用事件模块</h1><p id="12d8" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果我们想坚持函数式编程，那么我们就不应该使用节点的<code class="fe ms mt mu mj b">events</code>模块。</p><p id="db20" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它让我们通过发射和监听事件来制造副作用。</p><p id="490c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，我们可以创建纯函数来传递数据。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/1753d9464deb877b6537ec475a9c3014.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qPioYkIUCe-xiTMq"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://unsplash.com/@jtc?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">赫塞·科林斯</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><h1 id="9ee8" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="8f33" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">编写纯函数使我们的生活更容易，因为它们不会产生副作用。</p><p id="d3da" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们应该注意如何在箭头函数中返回数据。</p></div></div>    
</body>
</html>