<html>
<head>
<title>From imperative to declarative JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从命令式到声明式JavaScript</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/from-imperative-to-declarative-javascript-f6bd8eec05bd?source=collection_archive---------3-----------------------#2020-08-06">https://blog.devgenius.io/from-imperative-to-declarative-javascript-f6bd8eec05bd?source=collection_archive---------3-----------------------#2020-08-06</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/e59983fde2bea7a584a059e68d26f06d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i3N0k63aznESiDPuY032Gg.jpeg"/></div></div></figure><div class=""/><h1 id="6589" class="jv jw iy bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">介绍</h1><p id="1a8e" class="pw-post-body-paragraph kt ku iy kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">在这篇文章中，我将解释为什么<em class="lr">声明式</em>代码比<em class="lr">命令式</em>代码更好。</p><p id="af36" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">然后，我将列出一些在常见情况下将命令式JavaScript转换为声明式JavaScript的技术，同时定义一些关键术语。</p><h1 id="7c88" class="jv jw iy bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">为什么是声明性的？</h1><p id="832d" class="pw-post-body-paragraph kt ku iy kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">首先，我们来定义一下<em class="lr">陈述性</em>和<em class="lr">命令性</em>是什么意思。</p><p id="23b3" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated"><em class="lr">声明性</em>代码是一种强调它所做事情意图的代码。</p><p id="2fac" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">比起“如何”,它更喜欢“是什么”。</p><p id="3228" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">换句话说，实际执行工作的确切实现(也称为“如何”)是隐藏的，以便传达工作实际上是什么(也称为“什么”)。</p><p id="738c" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">相反，<em class="lr">命令式</em>代码是一种更喜欢“如何”而不是“什么”的代码。</p><p id="2f26" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">让我们看一个例子:</p><p id="20ae" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">下面的代码片段执行两件事:它计算<code class="fe lx ly lz ma b">x</code>的平方，然后检查结果是否均匀。</p><figure class="mb mc md me gt ip"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="f7b6" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">在这里，我们可以看到，在我们必须按顺序遵循的几个步骤之后，我们终于得到了<code class="fe lx ly lz ma b">isEven</code>。</p><p id="d0df" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">这些步骤描述了我们“如何”知道<code class="fe lx ly lz ma b">x</code>的正方形是否均匀，但这并不明显。</p><p id="3e7e" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">如果你找一个非程序员给他看这个，他可能很难破译。</p><p id="ce1b" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">现在让我们来看另一个片段，在这里我引入了一个神奇的<code class="fe lx ly lz ma b">isSquareEven</code>函数，它执行了与前一个相同的两件事情。</p><figure class="mb mc md me gt ip"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="d3ba" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">简洁多了吧？</p><p id="51c6" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">因为函数的名字，我们得到的结果是显而易见的。</p><p id="c63e" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">即使不是程序员也能很容易理解。</p><p id="62ba" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">但我在作弊。我用了一个神奇的功能。</p><p id="ddbf" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">我们看不到它实际上“如何”工作。</p><p id="ab42" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">这是一件好事，因为这让我们有时间、精力和内存来关注这段代码在一天结束时做什么。</p><p id="8fc2" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">如果我们只是想用它，那是最理想的。</p><p id="f848" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">但是如果我们好奇的话，我们仍然有可能，通过函数的定义。(大多数编辑器允许您轻松跳转到它)</p><p id="8731" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">那么让我们来看看<code class="fe lx ly lz ma b">isSquareEven</code>的实现(“如何”):</p><figure class="mb mc md me gt ip"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="21af" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated"><em class="lr">声明性</em>代码的基本构件是函数。</p><p id="d8e2" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">在JavaScript中，它们具有“一流”的特殊性。</p><p id="73f7" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">这意味着我们可以将它们作为普通的数据结构，如数字、字符串等。</p><p id="a09e" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">换句话说，你可以在一个变量中存储一个函数。您可以将一个函数作为参数传递给另一个函数。一个函数可以返回另一个函数。</p><p id="0f2c" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">所以现在我们已经定义了这两个术语，更容易看出哪些<em class="lr">声明性</em>代码比<em class="lr">命令性</em>代码好。</p><blockquote class="mh mi mj"><p id="cec9" class="kt ku lr kv b kw ls ky kz la lt lc ld mk lu lg lh ml lv lk ll mm lw lo lp lq ig bi translated">声明性的<em class="iy">代码可读性更好。</em></p></blockquote><p id="5a7d" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">就像我们看到的，它更简洁，更容易理解。</p><p id="6c51" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">在前面的例子中，我们没有处理太多的代码，所以这两段代码都很容易理解。</p><p id="53a8" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">但是你可以想象一个真实的项目包含更多的代码，因此也更复杂。</p><p id="0f40" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">因此，随着代码库的增长，优化可读性会越来越有帮助，如果多人一起工作，这就更重要了。</p><blockquote class="mh mi mj"><p id="caad" class="kt ku lr kv b kw ls ky kz la lt lc ld mk lu lg lh ml lv lk ll mm lw lo lp lq ig bi translated">声明性的<em class="iy">代码是可重用的。(因为它经常暗示函数)</em></p></blockquote><p id="7954" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">您可能已经注意到在第一个代码片段(<em class="lr">命令式</em> one)中，<code class="fe lx ly lz ma b">x</code>的值在开始时是硬编码的。</p><p id="97e5" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">如果我们不这样做，下面的行就不能工作。</p><p id="969f" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">相反，当我们使用类似于<em class="lr">声明性</em>片段中的函数时，我们可以<em class="lr">重用</em>任何输入的逻辑，只要它是一个数字。</p><h1 id="6e81" class="jv jw iy bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">技术</h1><p id="7366" class="pw-post-body-paragraph kt ku iy kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">这些技术涉及控制流语句:if/else、while、for循环。</p><p id="21ca" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">这些都是必须的。</p><p id="9291" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">他们描述的是工作是如何完成的，而不是工作是什么。</p><p id="3a60" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">一般来说，您可以简单地将一段逻辑抽象成一个带有描述性名称的函数，以使您的代码更具声明性。</p><p id="e1d0" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">但是当涉及到控制流语句时，要做什么就不那么明显了。</p><h1 id="5079" class="jv jw iy bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">If/else语句</h1><p id="dc40" class="pw-post-body-paragraph kt ku iy kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">有时，<code class="fe lx ly lz ma b">if/else</code>语句非常明确和简短，所以我认为在这种情况下，坚持使用它们是合法的。</p><p id="f77c" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">但其他时候，他们的条件不太明显和/或更长。</p><p id="20f7" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">所以我们可以将它们抽象成具有声明性名称的函数。</p><p id="2bc8" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">例如，假设我们想检查一个对象是否为空:</p><p id="8ed2" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated"><a class="ae mn" href="https://gist.github.com/e0be9a60a4b4dfb0bca1a46aaad85168" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/e0be9a60a4b4dfb0bca1a46aaad85168</a></p><p id="29fd" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">在JavaScript中，没有简单的方法来确定一个对象是否为空。</p><p id="0e87" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">你可能倾向于这样做:</p><figure class="mb mc md me gt ip"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="5da5" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">但是该条件将评估为false，因为当对对象(包括数组、函数、类)使用<code class="fe lx ly lz ma b">==</code>或<code class="fe lx ly lz ma b">===</code>符号时，它们是通过引用进行比较的，而不是通过它们属性的相等性进行比较的。</p><p id="509d" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">如果您不熟悉这种机制，可以探索一下<a class="ae mn" href="http://adripofjavascript.com/blog/drips/object-equality-in-javascript.html" rel="noopener ugc nofollow" target="_blank">这个</a>。</p><p id="307f" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">回到我们的例子，需要一点时间来认识到<code class="fe lx ly lz ma b">Object.keys(o).length === 0</code>是一个检查对象是否为空的技巧。</p><p id="d342" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">因此，我们可以通过将它封装在一个函数中来实现这一点:</p><figure class="mb mc md me gt ip"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="9cbe" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">现在我们要记录“对象为空”或者“对象不为空”基于这个结果。</p><p id="6759" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">不使用<code class="fe lx ly lz ma b">if/else</code>语句，我们可以使用<em class="lr">三元表达式</em>。</p><p id="5f3a" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">除了语法之外，两者的区别可以归结为一个<em class="lr">语句</em>和一个<em class="lr">表达式</em>的区别。</p><p id="eb0a" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">一个<em class="lr">语句</em>的计算结果为空，而一个<em class="lr">表达式</em>的计算结果总是为一个值。</p><p id="9132" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">所以我们可以把一个表达式当作一个值，这意味着我们可以把它存储在一个变量中，传递给一个函数，等等。</p><p id="70c2" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">你不能用<code class="fe lx ly lz ma b">if/else</code>语句做到这一点，例如:</p><figure class="mb mc md me gt ip"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="0478" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">最后，使用一个函数和一个三元表达式将我们的第一个<em class="lr">命令式</em>片段转换成一个<em class="lr">声明式</em>片段:</p><figure class="mb mc md me gt ip"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="b15c" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">你可以将<em class="lr">三元表达式</em>的结果放入一个变量中，以获得更好的可读性和/或在以后重用它。</p><figure class="mb mc md me gt ip"><div class="bz fp l di"><div class="mf mg l"/></div></figure><h1 id="50d8" class="jv jw iy bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">对于循环</h1><p id="1f08" class="pw-post-body-paragraph kt ku iy kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">当你想使用一个<code class="fe lx ly lz ma b">for</code>循环时，你可以使用<a class="ae mn" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map" rel="noopener ugc nofollow" target="_blank">映射</a>或<a class="ae mn" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach" rel="noopener ugc nofollow" target="_blank"> forEach </a>来代替。</p><p id="43eb" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">如果您的数据还没有转换成数组，那么您可能需要将它转换成数组，因为这些函数只适用于它。</p><p id="5cf1" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">例如，您可以使用<a class="ae mn" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries" rel="noopener ugc nofollow" target="_blank"> Object.entries() </a>从一个对象中获取一个键值对子数组。</p><p id="089a" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">然后，在映射之后，您可以使用<a class="ae mn" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/fromEntries" rel="noopener ugc nofollow" target="_blank"> Object.fromEntries() </a>将结果转换回一个对象。</p><p id="6842" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated"><code class="fe lx ly lz ma b">forEach</code>通常用于副作用，而<code class="fe lx ly lz ma b">map</code>必须是纯的。</p><p id="a0a0" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">换句话说，当你需要取回一个数组时，你使用<code class="fe lx ly lz ma b">map</code>,而如果你想执行一些动作，但不在乎它是否返回什么，你使用<code class="fe lx ly lz ma b">forEach</code>。</p><p id="dffb" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">这就是为什么<code class="fe lx ly lz ma b">forEach</code>返回<code class="fe lx ly lz ma b">undefined</code>。</p><p id="8ef0" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">以下是我所说的一个例子:</p><figure class="mb mc md me gt ip"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="214a" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">现在让我们看看<code class="fe lx ly lz ma b">map</code>和<code class="fe lx ly lz ma b">forEach</code>给了我们什么:</p><figure class="mb mc md me gt ip"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="4fbc" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">我们可以简单地通过在<code class="fe lx ly lz ma b">forEach</code>回调中创建“presentation”字符串并在之后记录它来获得相同的结果，但是我想展示<code class="fe lx ly lz ma b">map</code>和<code class="fe lx ly lz ma b">forEach</code>的用例。</p><p id="2e9b" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">现在你可能会说:</p><blockquote class="mh mi mj"><p id="972b" class="kt ku lr kv b kw ls ky kz la lt lc ld mk lu lg lh ml lv lk ll mm lw lo lp lq ig bi translated"><em class="iy">好。但是如果我想要，比方说，所有年龄的总和呢？</em></p></blockquote><p id="0ed1" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">使用<code class="fe lx ly lz ma b">for</code>循环，这非常简单:</p><figure class="mb mc md me gt ip"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="95a3" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">用<code class="fe lx ly lz ma b">map</code>怎么实现呢？</p><p id="abcb" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">我们不能，因为它总是给我们一个数组，而这里，我们想要一个数字。</p><p id="eec4" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">现在我们需要另一个函数:<code class="fe lx ly lz ma b">reduce</code>:</p><figure class="mb mc md me gt ip"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="a525" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">我不会在这里解释<code class="fe lx ly lz ma b">reduce</code>是如何工作的，但这是一个非常强大的工具，你必须学习，因为它只是...太神奇了。(如果你愿意，我会在帖子的最后放一些资源。)</p><p id="9880" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">任何时候你想计算任何东西(另一个数组，一个对象，一个数字，一个字符串等等。)从一个数组中，你可以使用它。</p><p id="ba8c" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">事实上，你可以用它实现<code class="fe lx ly lz ma b">map</code>、<code class="fe lx ly lz ma b">filter</code>、<code class="fe lx ly lz ma b">slice</code>以及其他“声明性”功能。</p><p id="86bd" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">这也是为什么一开始比较难把握的原因。</p><p id="97b2" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">但是，有没有一种不平凡的乐器，在演奏出美妙的音乐之前不需要学习？</p><p id="c2b7" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">我不这么认为。</p><p id="aa14" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">正如我提到的，还有其他方便的功能，如<code class="fe lx ly lz ma b">filter</code>和<code class="fe lx ly lz ma b">slice</code>，可以代替<code class="fe lx ly lz ma b">for</code>循环来完成特定的任务。(再次声明，资源在帖子的末尾。)</p><p id="2642" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">好吧！让我们来解决最后一项技术。</p><h1 id="18a3" class="jv jw iy bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">While循环</h1><p id="67ed" class="pw-post-body-paragraph kt ku iy kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">而循环可以用递归来代替，更准确地说，是递归函数。</p><p id="ca72" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">那是什么鬼东西？</p><p id="01fc" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">好吧。递归函数有两个特征:</p><ol class=""><li id="f875" class="mo mp iy kv b kw ls la lt le mq li mr lm ms lq mt mu mv mw bi translated">它自称(递归情况)。</li><li id="c0b1" class="mo mp iy kv b kw mx la my le mz li na lm nb lq mt mu mv mw bi translated">它作为一个停止条件(基本情况),当满足时，展开调用堆栈并最终返回所需的值。</li></ol><p id="802b" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">让我们看一个例子:</p><figure class="mb mc md me gt ip"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="a89c" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">这里有一个视觉化的结果:</p><figure class="mb mc md me gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi nc"><img src="../Images/dfc48b10df72e1c2bd9449f37333d75b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ooKDOLyPA4Lr2pgXwEO_RQ.png"/></div></div></figure><p id="c95b" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">每个黑色箭头都可以替换为“returns”。</p><p id="499b" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">整个过程从字面上解释:</p><ol class=""><li id="f60e" class="mo mp iy kv b kw ls la lt le mq li mr lm ms lq mt mu mv mw bi translated">foo(16): x === 16所以x &gt; 5，因此我们返回<code class="fe lx ly lz ma b">foo(16 / 2)</code>。所以我们调用它并将返回这个调用返回的任何内容。</li><li id="f80a" class="mo mp iy kv b kw mx la my le mz li na lm nb lq mt mu mv mw bi translated">foo(8): x === 8所以x &gt; 5，因此我们返回<code class="fe lx ly lz ma b">foo(8 / 2)</code>。所以我们调用它并将返回这个调用返回的任何内容。</li><li id="47eb" class="mo mp iy kv b kw mx la my le mz li na lm nb lq mt mu mv mw bi translated">foo(4): x === 4所以x &lt; 5，满足停止条件。因此我们返回4。</li><li id="a5da" class="mo mp iy kv b kw mx la my le mz li na lm nb lq mt mu mv mw bi translated">回到步骤2，我们想要返回任何<code class="fe lx ly lz ma b">foo(8 / 2)</code>(在步骤3中也称为foo(4 ))返回的内容。现在我们知道是4，我们返回4。</li><li id="458c" class="mo mp iy kv b kw mx la my le mz li na lm nb lq mt mu mv mw bi translated">回到步骤1，我们想要返回任何<code class="fe lx ly lz ma b">foo(16 / 2)</code>(在步骤2中也称为foo(8 ))返回的内容。现在我们知道是4，我们返回4。</li><li id="3842" class="mo mp iy kv b kw mx la my le mz li na lm nb lq mt mu mv mw bi translated">因为最初的调用是<code class="fe lx ly lz ma b">foo(16)</code>，所以结果是4。</li></ol><p id="6e63" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">这个例子很简单，但是最终，每个递归函数都有我上面列出的两个特征。</p><p id="3fd6" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">这是一个我很难掌握的技巧，所以如果是你的情况，不要放弃，定期接触不同的学习材料。</p><p id="c2dd" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">最终，这一天会到来。</p><p id="e96e" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">现在让我们看一个例子，其中我们将while循环转换为递归函数:</p><figure class="mb mc md me gt ip"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="95bb" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">现在，你能告诉我这个循环是干什么的吗？</p><p id="f11d" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">它计算5的阶乘。</p><p id="1f3f" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">所以最后x是120。</p><p id="a38b" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">即使在这个相当简单的例子中，<code class="fe lx ly lz ma b">while</code>循环的作用也不明显。</p><p id="4abc" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">使用递归函数，我们可以通过给它一个有意义的名称来轻松解决这个问题:</p><figure class="mb mc md me gt ip"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="534b" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">漂亮吧？</p><p id="bb77" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">尝试像我在之前的可视化中所做的那样分解函数。</p><p id="3033" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">把它写在纸上，真正地与信息联系起来。</p><h1 id="d43c" class="jv jw iy bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">更进一步</h1><p id="06a2" class="pw-post-body-paragraph kt ku iy kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">学习“简化”:</p><ul class=""><li id="4fbf" class="mo mp iy kv b kw ls la lt le mq li mr lm ms lq nd mu mv mw bi translated">MDN文档</li><li id="1b4a" class="mo mp iy kv b kw mx la my le mz li na lm nb lq nd mu mv mw bi translated"><a class="ae mn" href="https://www.youtube.com/watch?v=Wl98eZpkp-c" rel="noopener ugc nofollow" target="_blank">趣味趣味功能</a></li><li id="60c1" class="mo mp iy kv b kw mx la my le mz li na lm nb lq nd mu mv mw bi translated"><a class="ae mn" href="https://www.youtube.com/watch?v=gU3wOcpbfCM" rel="noopener ugc nofollow" target="_blank">再次来自Fun Fun功能</a></li></ul><p id="b7f8" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">学习递归:</p><ul class=""><li id="298b" class="mo mp iy kv b kw ls la lt le mq li mr lm ms lq nd mu mv mw bi translated"><a class="ae mn" href="https://javascript.info/recursion" rel="noopener ugc nofollow" target="_blank"> javascript.info </a></li><li id="170f" class="mo mp iy kv b kw mx la my le mz li na lm nb lq nd mu mv mw bi translated"><a class="ae mn" href="https://www.youtube.com/watch?v=k7-N8R0-KY4" rel="noopener ugc nofollow" target="_blank">趣味趣味功能</a></li><li id="ef32" class="mo mp iy kv b kw mx la my le mz li na lm nb lq nd mu mv mw bi translated"><a class="ae mn" href="https://www.youtube.com/watch?v=py7ZWFjrwEs" rel="noopener ugc nofollow" target="_blank">所有JavaScript的东西</a></li><li id="d75d" class="mo mp iy kv b kw mx la my le mz li na lm nb lq nd mu mv mw bi translated"><a class="ae mn" href="https://github.com/getify/Functional-Light-JS/blob/master/manuscript/ch8.md/#chapter-8-recursion" rel="noopener ugc nofollow" target="_blank">更多</a></li></ul><p id="7512" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated"><a class="ae mn" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter" rel="noopener ugc nofollow" target="_blank">过滤器</a></p><p id="1a96" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated"><a class="ae mn" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice" rel="noopener ugc nofollow" target="_blank">切片</a></p><p id="e76a" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">在这篇文章中，我强调了术语<em class="lr">命令性的</em>和<em class="lr">声明性的</em>，本质上声明了后者给了我们更多可读的代码。</p><p id="3e41" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">但是这些术语经常被用在OOP(通常是命令式的)和FP(更多的是声明式的)的上下文中。</p><p id="12e2" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">这是两种编程范例(如果你愿意，这是解决软件问题的方法)。</p><p id="e223" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">FP代表函数式编程，OOP代表面向对象编程。</p><p id="1cfc" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">虽然<code class="fe lx ly lz ma b">for</code>循环并不是一个“面向对象”的东西，但是我介绍的<a class="ae mn" href="https://medium.com/javascript-scene/higher-order-functions-composing-software-5365cf2cbe99" rel="noopener">高阶函数</a>是函数式编程中的核心工具，它们经常被认为是函数式编程的核心工具。</p><p id="d226" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">函数式范例真的让我很感兴趣，我想你会喜欢学习它的。</p><p id="9f44" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">除了更具声明性之外，它还提供了其他强大的思想/特性，比如数据结构的不变性，这有助于避免与可变性相关的一系列错误。</p><p id="e114" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">不幸的是，JS没有提供开箱即用的功能，所以试图强制执行它有点像逆水行舟，所以您可以使用一个类似于<a class="ae mn" href="https://clojure.org/index" rel="noopener ugc nofollow" target="_blank"> Clojure </a>的功能。</p><p id="26bc" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">但是它们是学习JavaScript这种范式的很好的资源，我推荐它们，因为函数式语言通常不太受欢迎，学习材料的生态系统也不太成熟。</p><p id="718d" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">以下是其中的几个:</p><p id="0138" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">书籍:</p><ul class=""><li id="6ac2" class="mo mp iy kv b kw ls la lt le mq li mr lm ms lq nd mu mv mw bi translated"><a class="ae mn" href="https://github.com/getify/Functional-Light-JS" rel="noopener ugc nofollow" target="_blank">轻量级功能JavaScript </a></li></ul><p id="0bd6" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">- <a class="ae mn" href="https://github.com/MostlyAdequate/mostly-adequate-guide" rel="noopener ugc nofollow" target="_blank">基本上足够的FP指南(在JS中)</a></p><p id="9277" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">视频:</p><ul class=""><li id="11e2" class="mo mp iy kv b kw ls la lt le mq li mr lm ms lq nd mu mv mw bi translated"><a class="ae mn" href="https://www.youtube.com/playlist?list=PL0zVEGEvSaeEd9hlmCXrk5yUyqUag-n84" rel="noopener ugc nofollow" target="_blank">趣味Fun功能播放列表</a></li></ul><p id="4466" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">图书馆:</p><ul class=""><li id="1d80" class="mo mp iy kv b kw ls la lt le mq li mr lm ms lq nd mu mv mw bi translated"><a class="ae mn" href="https://ramdajs.com/" rel="noopener ugc nofollow" target="_blank">拉姆达JS </a></li></ul><p id="bbc4" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated"><a class="ae mn" href="https://github.com/stoeffel/awesome-fp-js" rel="noopener ugc nofollow" target="_blank">更多</a></p><h1 id="c603" class="jv jw iy bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">结论</h1><p id="6f18" class="pw-post-body-paragraph kt ku iy kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">就是这样！</p><p id="629b" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">我希望你喜欢这篇文章，更重要的是，它会很有用。</p><p id="2963" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">继续编码！😄</p></div><div class="ab cl ne nf hr ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ig ih ii ij ik"><p id="de2c" class="pw-post-body-paragraph kt ku iy kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated"><em class="lr">最初发布于</em><a class="ae mn" href="https://yannsalmon.netlify.app/blog/from-imperative-to-declarative-javascript/" rel="noopener ugc nofollow" target="_blank"><em class="lr"/>https://yannsalmon . netlify . app/blog/from-important-to-declarative-JavaScript/</a><em class="lr">。</em></p></div></div>    
</body>
</html>