<html>
<head>
<title>Java 8 Interview Questions and Answers -1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java 8 面试问答-1</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/java-8-interview-questions-and-answers-1-19ad105123f7?source=collection_archive---------0-----------------------#2022-10-13">https://blog.devgenius.io/java-8-interview-questions-and-answers-1-19ad105123f7?source=collection_archive---------0-----------------------#2022-10-13</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/8e27e61afcbcb52067fb1c58fc486b4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XY0nPLz4QAWFHCGdjEmjjA.png"/></div></div></figure><h1 id="b611" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">嘿读者，</h1><p id="71b3" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">如果您正在准备 Java 面试，那么这篇文章会非常有用。因为，在 Java 版本不断升级之后，面试问题也越来越多。在这里，我列出了 Java 8 上最有用、最常被问到的面试问题。</p><h1 id="819b" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">文章内容包括以下主题的面试问题及示例:</h1><ol class=""><li id="19e1" class="lr ls in kv b kw kx la lb le lt li lu lm lv lq lw lx ly lz bi translated">λ表达式</li><li id="bee9" class="lr ls in kv b kw ma la mb le mc li md lm me lq lw lx ly lz bi translated">方法参考</li><li id="d8b3" class="lr ls in kv b kw ma la mb le mc li md lm me lq lw lx ly lz bi translated">功能接口</li></ol><h1 id="c14f" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">λ表达式</h1><figure class="mg mh mi mj gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mf"><img src="../Images/57cb1ed315fd9ddc601fe56d9d8f0286.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RvmXzyW2uXY83503"/></div></div></figure><p id="99a9" class="pw-post-body-paragraph kt ku in kv b kw mk ky kz la ml lc ld le mm lg lh li mn lk ll lm mo lo lp lq ig bi translated"><strong class="kv io"> 1。什么是 lambda 表达式？</strong></p><p id="e49d" class="pw-post-body-paragraph kt ku in kv b kw mk ky kz la ml lc ld le mm lg lh li mn lk ll lm mo lo lp lq ig bi translated">Lambda 表达式是行为类似于常规方法的代码段。它们被设计成接受一组参数作为输入，并返回一个值作为输出。与方法不同，lambda 表达式不强制要求特定的名称。</p><p id="7366" class="pw-post-body-paragraph kt ku in kv b kw mk ky kz la ml lc ld le mm lg lh li mn lk ll lm mo lo lp lq ig bi translated"><strong class="kv io"> 2。为什么我们需要 lambda 表达式？</strong></p><ul class=""><li id="9482" class="lr ls in kv b kw mk la ml le mp li mq lm mr lq ms lx ly lz bi translated">Lambda 可以在不实例化类的情况下创建</li><li id="5377" class="lr ls in kv b kw ma la mb le mc li md lm me lq ms lx ly lz bi translated">Lambda 可以被视为一个对象</li><li id="801c" class="lr ls in kv b kw ma la mb le mc li md lm me lq ms lx ly lz bi translated">它支持函数式编程并减少编码行数</li></ul><p id="e3c3" class="pw-post-body-paragraph kt ku in kv b kw mk ky kz la ml lc ld le mm lg lh li mn lk ll lm mo lo lp lq ig bi translated"><strong class="kv io"> Lambda 表达式语法:</strong></p><p id="2312" class="pw-post-body-paragraph kt ku in kv b kw mk ky kz la ml lc ld le mm lg lh li mn lk ll lm mo lo lp lq ig bi translated"><strong class="kv io">(参数列表)-&gt;{正文} </strong></p><p id="a1b4" class="pw-post-body-paragraph kt ku in kv b kw mk ky kz la ml lc ld le mm lg lh li mn lk ll lm mo lo lp lq ig bi translated">Java lambda 表达式由三部分组成。</p><p id="7876" class="pw-post-body-paragraph kt ku in kv b kw mk ky kz la ml lc ld le mm lg lh li mn lk ll lm mo lo lp lq ig bi translated"><strong class="kv io">参数列表:</strong>可以为空，也可以不为空。</p><p id="91c7" class="pw-post-body-paragraph kt ku in kv b kw mk ky kz la ml lc ld le mm lg lh li mn lk ll lm mo lo lp lq ig bi translated"><strong class="kv io">箭头标记:</strong>用于连接参数列表和表达式体。</p><p id="5d83" class="pw-post-body-paragraph kt ku in kv b kw mk ky kz la ml lc ld le mm lg lh li mn lk ll lm mo lo lp lq ig bi translated"><strong class="kv io"> Body: </strong>包含 lambda 表达式的表达式和语句。</p><figure class="mg mh mi mj gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mt"><img src="../Images/64ce62cfac9f240e8d2eae9d75c0b269.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oqp45FNOwGj3Mq6rqnQ41A.png"/></div></div></figure><p id="68a9" class="pw-post-body-paragraph kt ku in kv b kw mk ky kz la ml lc ld le mm lg lh li mn lk ll lm mo lo lp lq ig bi translated"><strong class="kv io"> 3。lambda 表达式和函数接口是如何关联的？</strong></p><p id="2c76" class="pw-post-body-paragraph kt ku in kv b kw mk ky kz la ml lc ld le mm lg lh li mn lk ll lm mo lo lp lq ig bi translated">函数接口是 java 的一个接口，带有一个抽象方法。除了通过声明和实例化一个类来创建一个接口实例之外，还可以用 lambda 表达式来创建函数接口的实例。</p><p id="984c" class="pw-post-body-paragraph kt ku in kv b kw mk ky kz la ml lc ld le mm lg lh li mn lk ll lm mo lo lp lq ig bi translated"><strong class="kv io"> 4。lambda 表达式在执行时会创建一个对象吗？</strong></p><ul class=""><li id="e33d" class="lr ls in kv b kw mk la ml le mp li mq lm mr lq ms lx ly lz bi translated">不，只创建一个实例，它为所有不获取值的表达式创建单例。</li><li id="2ef6" class="lr ls in kv b kw ma la mb le mc li md lm me lq ms lx ly lz bi translated">每次求值时，不需要分配新的对象。</li><li id="2500" class="lr ls in kv b kw ma la mb le mc li md lm me lq ms lx ly lz bi translated">由不同 lambda 表达式创建的对象不一定属于同一个类。</li><li id="9fe5" class="lr ls in kv b kw ma la mb le mc li md lm me lq ms lx ly lz bi translated">通过评估创建的每个对象不必属于同一类。</li><li id="d9a0" class="lr ls in kv b kw ma la mb le mc li md lm me lq ms lx ly lz bi translated">如果现有实例已经存在，则没有必要创建先前的 lambda 评估。</li></ul><h1 id="6aa9" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">方法引用</h1><figure class="mg mh mi mj gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mu"><img src="../Images/319689fbf0fe555fd0e1ad68d408c904.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VBiLAy1RF9Lwr1k-"/></div></div></figure><p id="3b56" class="pw-post-body-paragraph kt ku in kv b kw mk ky kz la ml lc ld le mm lg lh li mn lk ll lm mo lo lp lq ig bi translated"><strong class="kv io"> 1。什么是方法引用？</strong></p><p id="5eca" class="pw-post-body-paragraph kt ku in kv b kw mk ky kz la ml lc ld le mm lg lh li mn lk ll lm mo lo lp lq ig bi translated">方法引用是 lambda 表达式的一种特殊类型。它们用于通过引用现有方法来创建简单的 lambda 表达式。</p><p id="9ac8" class="pw-post-body-paragraph kt ku in kv b kw mk ky kz la ml lc ld le mm lg lh li mn lk ll lm mo lo lp lq ig bi translated"><strong class="kv io"> 2。方法引用的类型有哪些？</strong></p><p id="8bc6" class="pw-post-body-paragraph kt ku in kv b kw mk ky kz la ml lc ld le mm lg lh li mn lk ll lm mo lo lp lq ig bi translated">有 4 种方法参考。</p><ul class=""><li id="ca77" class="lr ls in kv b kw mk la ml le mp li mq lm mr lq ms lx ly lz bi translated">静态方法引用</li><li id="b686" class="lr ls in kv b kw ma la mb le mc li md lm me lq ms lx ly lz bi translated">特定对象的实例方法。</li><li id="8f21" class="lr ls in kv b kw ma la mb le mc li md lm me lq ms lx ly lz bi translated">特定类型的任意对象的实例方法</li><li id="6cf8" class="lr ls in kv b kw ma la mb le mc li md lm me lq ms lx ly lz bi translated">构造器</li></ul><p id="bac4" class="pw-post-body-paragraph kt ku in kv b kw mk ky kz la ml lc ld le mm lg lh li mn lk ll lm mo lo lp lq ig bi translated"><strong class="kv io">静态方法的引用:</strong></p><figure class="mg mh mi mj gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mv"><img src="../Images/c3538b46761a454b3cf8b5a20dd359f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zWX7t3R4SQ45_rehvjGfRg.png"/></div></div></figure><p id="7262" class="pw-post-body-paragraph kt ku in kv b kw mk ky kz la ml lc ld le mm lg lh li mn lk ll lm mo lo lp lq ig bi translated">或者，我们可以使用方法引用来简单地引用大写静态方法:</p><figure class="mg mh mi mj gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mw"><img src="../Images/51613dba4170a2b89ae257bf9ee713d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DYfqly7C6JkTZ7hbg-5dEg.png"/></div></div></figure><p id="e0a1" class="pw-post-body-paragraph kt ku in kv b kw mk ky kz la ml lc ld le mm lg lh li mn lk ll lm mo lo lp lq ig bi translated">对特定对象的实例方法的引用</p><p id="4a29" class="pw-post-body-paragraph kt ku in kv b kw mk ky kz la ml lc ld le mm lg lh li mn lk ll lm mo lo lp lq ig bi translated">为了演示这种类型的方法引用，让我们考虑两个类:</p><figure class="mg mh mi mj gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mx"><img src="../Images/d1d762d4e72a03aac53a2a05eb53b921.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xccytKHYtLSqntNHnkDz-w.png"/></div></div></figure><p id="cfde" class="pw-post-body-paragraph kt ku in kv b kw mk ky kz la ml lc ld le mm lg lh li mn lk ll lm mo lo lp lq ig bi translated">并且，让我们创建一个 BicycleComparator 对象来比较自行车的车架尺寸:</p><figure class="mg mh mi mj gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi my"><img src="../Images/2e8ffa30fe309e81f6d58a7cdb92e868.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eZJJ9mkw9GwNegRMhUEj-w.png"/></div></div></figure><p id="04ef" class="pw-post-body-paragraph kt ku in kv b kw mk ky kz la ml lc ld le mm lg lh li mn lk ll lm mo lo lp lq ig bi translated">我们可以使用 lambda 表达式按车架大小对自行车进行排序，但是我们需要指定两辆自行车进行比较:</p><figure class="mg mh mi mj gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mz"><img src="../Images/71d99cffefed679f7c500ab76d0dd53c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LoJ-jCj3GXsB3Q7eLtfBGA.png"/></div></div></figure><p id="f3f4" class="pw-post-body-paragraph kt ku in kv b kw mk ky kz la ml lc ld le mm lg lh li mn lk ll lm mo lo lp lq ig bi translated">相反，我们可以使用方法引用让编译器为我们处理参数传递:</p><figure class="mg mh mi mj gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi na"><img src="../Images/7aa24a75da782a4ed9bbfc32c9c89747.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vPEeU7MlG5YpopMyVqdNCA.png"/></div></div></figure><p id="00c9" class="pw-post-body-paragraph kt ku in kv b kw mk ky kz la ml lc ld le mm lg lh li mn lk ll lm mo lo lp lq ig bi translated">方法引用更加清晰，可读性更好，因为代码清楚地表明了我们的意图。</p><p id="6c4e" class="pw-post-body-paragraph kt ku in kv b kw mk ky kz la ml lc ld le mm lg lh li mn lk ll lm mo lo lp lq ig bi translated"><strong class="kv io">引用特定类型的任意对象的实例方法</strong></p><p id="5a6e" class="pw-post-body-paragraph kt ku in kv b kw mk ky kz la ml lc ld le mm lg lh li mn lk ll lm mo lo lp lq ig bi translated">这种类型的方法引用类似于前面的示例，但是不需要创建自定义对象来执行比较。让我们创建一个要排序的整数列表:</p><p id="8961" class="pw-post-body-paragraph kt ku in kv b kw mk ky kz la ml lc ld le mm lg lh li mn lk ll lm mo lo lp lq ig bi translated">List numbers = Arrays.asList(5，3，50，24，40，2，9，18)；</p><p id="a4b4" class="pw-post-body-paragraph kt ku in kv b kw mk ky kz la ml lc ld le mm lg lh li mn lk ll lm mo lo lp lq ig bi translated">如果我们使用经典的 lambda 表达式，两个参数都需要显式传递，而使用方法引用要简单得多:</p><figure class="mg mh mi mj gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nb"><img src="../Images/907582297e7c32996a28ae2e31f55528.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3k4sU5krjIJwHSZqSwRg5g.png"/></div></div></figure><p id="58fc" class="pw-post-body-paragraph kt ku in kv b kw mk ky kz la ml lc ld le mm lg lh li mn lk ll lm mo lo lp lq ig bi translated">尽管它仍然是一行程序，但是方法参考更容易阅读和理解。</p><p id="3622" class="pw-post-body-paragraph kt ku in kv b kw mk ky kz la ml lc ld le mm lg lh li mn lk ll lm mo lo lp lq ig bi translated"><strong class="kv io">引用一个构造函数</strong></p><p id="68be" class="pw-post-body-paragraph kt ku in kv b kw mk ky kz la ml lc ld le mm lg lh li mn lk ll lm mo lo lp lq ig bi translated">我们可以像在第一个例子中引用静态方法一样引用构造函数。唯一的区别是我们将使用新的关键字。</p><p id="07e8" class="pw-post-body-paragraph kt ku in kv b kw mk ky kz la ml lc ld le mm lg lh li mn lk ll lm mo lo lp lq ig bi translated">让我们用不同品牌的字符串列表创建一个自行车数组:</p><figure class="mg mh mi mj gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nc"><img src="../Images/009dd358a9f513d4bba75c0910281fe7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FppJWNaBIQRjP1-_Lf187w.png"/></div></div></figure><p id="427c" class="pw-post-body-paragraph kt ku in kv b kw mk ky kz la ml lc ld le mm lg lh li mn lk ll lm mo lo lp lq ig bi translated">首先，我们将向自行车类添加一个新的构造函数:</p><figure class="mg mh mi mj gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi gj"><img src="../Images/05cd37fd1fca069f58f95ac56aae2ab3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RZj736ay2nGyIX7MVEwUFg.png"/></div></div></figure><p id="7450" class="pw-post-body-paragraph kt ku in kv b kw mk ky kz la ml lc ld le mm lg lh li mn lk ll lm mo lo lp lq ig bi translated">接下来，我们将从方法引用中使用新的构造函数，并从原始字符串列表中创建一个自行车数组:</p><figure class="mg mh mi mj gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nd"><img src="../Images/5eaae29ddcac94b1109a3f3cf3284aef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nctT2ctZGNPQaeyX7srg2w.png"/></div></div></figure><p id="831b" class="pw-post-body-paragraph kt ku in kv b kw mk ky kz la ml lc ld le mm lg lh li mn lk ll lm mo lo lp lq ig bi translated">注意我们是如何使用方法引用来调用 Bicycle 和 Array 构造函数的，这使得我们的代码看起来更加简洁明了。</p><h1 id="e252" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">功能接口</h1><figure class="mg mh mi mj gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ne"><img src="../Images/af830cf3cb57f738a2975c83d5287338.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ECRpNQpuZHxK094Y"/></div></div></figure><p id="f667" class="pw-post-body-paragraph kt ku in kv b kw mk ky kz la ml lc ld le mm lg lh li mn lk ll lm mo lo lp lq ig bi translated"><strong class="kv io"> 1。什么是功能界面？</strong></p><p id="d6d8" class="pw-post-body-paragraph kt ku in kv b kw mk ky kz la ml lc ld le mm lg lh li mn lk ll lm mo lo lp lq ig bi translated">只包含一个抽象方法的接口称为函数接口。它可以有任意数量的默认和静态方法。它还可以声明对象类的方法。它可以有任意数量的默认和静态方法。它还可以声明对象类的方法。</p><p id="4c58" class="pw-post-body-paragraph kt ku in kv b kw mk ky kz la ml lc ld le mm lg lh li mn lk ll lm mo lo lp lq ig bi translated">函数接口也称为单一抽象方法接口(SAM 接口)。只有当一个函数接口没有任何抽象方法时，它才能扩展另一个接口。</p><p id="03b3" class="pw-post-body-paragraph kt ku in kv b kw mk ky kz la ml lc ld le mm lg lh li mn lk ll lm mo lo lp lq ig bi translated"><strong class="kv io"> 2。Java 8 之前已有的功能接口有哪些？</strong></p><ol class=""><li id="c6b8" class="lr ls in kv b kw mk la ml le mp li mq lm mr lq lw lx ly lz bi translated">可追捕的</li><li id="c021" class="lr ls in kv b kw ma la mb le mc li md lm me lq lw lx ly lz bi translated">动作监听器</li><li id="23f6" class="lr ls in kv b kw ma la mb le mc li md lm me lq lw lx ly lz bi translated">可比较的</li></ol><p id="4c06" class="pw-post-body-paragraph kt ku in kv b kw mk ky kz la ml lc ld le mm lg lh li mn lk ll lm mo lo lp lq ig bi translated"><strong class="kv io"> 3。命名并解释 Java 8 预定义的函数接口？</strong></p><p id="b95d" class="pw-post-body-paragraph kt ku in kv b kw mk ky kz la ml lc ld le mm lg lh li mn lk ll lm mo lo lp lq ig bi translated">有 4 个主要的功能接口，可用于不同的场景。</p><p id="0253" class="pw-post-body-paragraph kt ku in kv b kw mk ky kz la ml lc ld le mm lg lh li mn lk ll lm mo lo lp lq ig bi translated"><strong class="kv io"> 1。消费者:</strong>它表示接受单个参数并且不返回结果的操作</p><figure class="mg mh mi mj gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mw"><img src="../Images/8dbf29436a76847b36e79d544a009b0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AVIP8XzQ7Wiv0DTkh0lFlQ.png"/></div></div></figure><p id="d670" class="pw-post-body-paragraph kt ku in kv b kw mk ky kz la ml lc ld le mm lg lh li mn lk ll lm mo lo lp lq ig bi translated"><strong class="kv io"> a. BiConsumer: </strong>表示接受两个输入参数，不返回结果的操作。它是消费者的一个子类。</p><figure class="mg mh mi mj gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nf"><img src="../Images/4bdec21c1ce20e51fb3b071003988501.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X4WFHoEyZS8--ITEmo8xtw.png"/></div></div></figure><p id="6da4" class="pw-post-body-paragraph kt ku in kv b kw mk ky kz la ml lc ld le mm lg lh li mn lk ll lm mo lo lp lq ig bi translated"><strong class="kv io"> 2。谓词</strong></p><p id="7e4c" class="pw-post-body-paragraph kt ku in kv b kw mk ky kz la ml lc ld le mm lg lh li mn lk ll lm mo lo lp lq ig bi translated">谓词将接受一个参数，进行一些处理，然后返回布尔值</p><figure class="mg mh mi mj gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ng"><img src="../Images/47d6da02d0d87ac408605e41fb422722.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fj-OFHY1BMKYbpiRsGijzg.png"/></div></div></figure><p id="187a" class="pw-post-body-paragraph kt ku in kv b kw mk ky kz la ml lc ld le mm lg lh li mn lk ll lm mo lo lp lq ig bi translated"><strong class="kv io">a . BiPredicate</strong>BiPredicate 将接受两个参数并返回布尔值，而不是一个参数。双谓词是谓词的一个亚型。</p><p id="dd72" class="pw-post-body-paragraph kt ku in kv b kw mk ky kz la ml lc ld le mm lg lh li mn lk ll lm mo lo lp lq ig bi translated"><strong class="kv io"> 3。功能</strong></p><p id="2a9e" class="pw-post-body-paragraph kt ku in kv b kw mk ky kz la ml lc ld le mm lg lh li mn lk ll lm mo lo lp lq ig bi translated">该接口接受一个参数，并在所需的处理后返回值。其定义如下。所需的处理逻辑将在调用 apply 方法时执行。</p><figure class="mg mh mi mj gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nh"><img src="../Images/92cecd6b07da1e294461ed10f81f8547.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YCBLMFURcJX67HxgLBUv4Q.png"/></div></div></figure><p id="9511" class="pw-post-body-paragraph kt ku in kv b kw mk ky kz la ml lc ld le mm lg lh li mn lk ll lm mo lo lp lq ig bi translated"><strong class="kv io">a . bi Function:</strong>bi Function 类似于 Function，只是它接受两个输入，而 Function 接受一个参数。</p><p id="1e03" class="pw-post-body-paragraph kt ku in kv b kw mk ky kz la ml lc ld le mm lg lh li mn lk ll lm mo lo lp lq ig bi translated"><strong class="kv io"> b .一元运算符和二元运算符</strong></p><p id="1c1e" class="pw-post-body-paragraph kt ku in kv b kw mk ky kz la ml lc ld le mm lg lh li mn lk ll lm mo lo lp lq ig bi translated">一元运算符和二元运算符，分别扩展了 Function 和 BiFunction。</p><figure class="mg mh mi mj gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ni"><img src="../Images/a9c420855f20eed1a656eda79c810d1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p-JVb0vVwO9xDtsqOOOF6g.png"/></div></div></figure><p id="8923" class="pw-post-body-paragraph kt ku in kv b kw mk ky kz la ml lc ld le mm lg lh li mn lk ll lm mo lo lp lq ig bi translated">从上面的接口很容易理解，一元运算符接受单个参数并返回单个参数，但输入和输出参数应该是相同或相似的类型。</p><p id="c434" class="pw-post-body-paragraph kt ku in kv b kw mk ky kz la ml lc ld le mm lg lh li mn lk ll lm mo lo lp lq ig bi translated">另一方面，BinaryOperator 接受两个参数并返回一个类似于 BiFunction 的参数，但所有输入和输出参数的类型都应该是类似的类型。</p><p id="5528" class="pw-post-body-paragraph kt ku in kv b kw mk ky kz la ml lc ld le mm lg lh li mn lk ll lm mo lo lp lq ig bi translated"><strong class="kv io"> 4。供应商:</strong>供应商功能界面不接受任何输入；而是返回一个输出。为了便于理解，给出以下接口代码。</p><figure class="mg mh mi mj gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nj"><img src="../Images/4d7d0af94b43bd499128854a18844041.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ruI7U_lILSbPcA8X4pwriQ.png"/></div></div></figure><p id="6e6c" class="pw-post-body-paragraph kt ku in kv b kw mk ky kz la ml lc ld le mm lg lh li mn lk ll lm mo lo lp lq ig bi translated"><em class="nk">感谢您的阅读和在此度过的时光。如果你喜欢这篇文章，请鼓掌，它会鼓励我写更多这样的文章。请分享您的宝贵建议，感谢您的真诚反馈！！</em></p></div></div>    
</body>
</html>