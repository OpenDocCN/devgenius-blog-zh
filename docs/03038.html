<html>
<head>
<title>What’s New In Typescript 4.0?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Typescript 4.0 有什么新功能？</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/whats-new-in-typescript-4-0-4a8e2182cea7?source=collection_archive---------11-----------------------#2020-09-22">https://blog.devgenius.io/whats-new-in-typescript-4-0-4a8e2182cea7?source=collection_archive---------11-----------------------#2020-09-22</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/9ca2a0fb6ea999536bef987c36c6c8b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qhejO1lJW4ukEH1Zi_4H9g.jpeg"/></div></div></figure><p id="c423" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">今天我要谈谈 Typescript 4.0 的新特性。</p><p id="167d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">TypeScript 4.0 提供了许多新特性，使得 JavaScript 开发更加容易。</p><h1 id="09f6" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">标记元组元素</h1><p id="7baf" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">您可以标记元组元素。</p><p id="777e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你可以写:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="f935" class="mf ku in mb b gy mg mh l mi mj">type Range = [start: number, end: number];</span></pre><p id="add2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">限制<code class="fe mk ml mm mb b">args</code>为一个字符串和一个数字。</p><p id="308c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你也可以写:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="be98" class="mf ku in mb b gy mg mh l mi mj">type Foo = [first: number, second?: string, ...rest: any[]];</span></pre><p id="f0cf" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在元组中有 rest 条目。</p><p id="b5f1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你的元组有类型<code class="fe mk ml mm mb b">Foo</code>，那么元组以一个数字和一个字符串开始。</p><p id="8784" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">那么其余的条目可以是任何东西。</p><p id="74e2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">标签不要求你在析构时用不同的名字命名变量。</p><p id="d405" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">例如，如果您有:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="4311" class="mf ku in mb b gy mg mh l mi mj">function foo(x: [first: string, second: number]) {<br/>  const [a, b] = x;<br/>}</span></pre><p id="5d1a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后你可以给析构变量起任何你想要的名字。</p><h1 id="8dd0" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">从构造函数推断类属性</h1><p id="15b5" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">TypeScript 4.0 可以从构造函数推断类属性的类型。</p><p id="fc7c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">例如，如果您有:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="e966" class="mf ku in mb b gy mg mh l mi mj">class Square {<br/>  area;<br/>  length;<br/><br/>  constructor(length: number) {<br/>    this.length = length;<br/>    this.area = length ** 2;<br/>  }<br/>}</span></pre><p id="7728" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后 TypeScript 4.0 自动知道<code class="fe mk ml mm mb b">this.length</code>和<code class="fe mk ml mm mb b">this.area</code>是数字。</p><p id="a300" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果它们的值有可能是<code class="fe mk ml mm mb b">undefined</code>，那么 TypeScript 编译器会通知你。</p><p id="894d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以如果你有:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="02e5" class="mf ku in mb b gy mg mh l mi mj">class Square {<br/>  length;<br/><br/>  constructor(length: number) {<br/>    if (Math.random()) {<br/>      this.length = length;<br/>    }<br/>  }<br/><br/>  get area() {<br/>    return this.length  ** 2;<br/>  }<br/>}</span></pre><p id="d0d0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后你就知道<code class="fe mk ml mm mb b">this.length</code>可能是<code class="fe mk ml mm mb b">undefined</code>。</p><p id="e54a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你需要一个类型断言，即使你知道它总是被定义的。</p><p id="c9c9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">例如，您可以写:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="b30a" class="mf ku in mb b gy mg mh l mi mj">class Square {<br/>  length!: number;<br/><br/>  constructor(length: number) {<br/>    this.initialize(length);<br/>  }<br/><br/>  initialize(length: number) {<br/>    this.length = length;<br/>  }<br/><br/>  get area() {<br/>    return this.length ** 2;<br/>  }<br/>}</span></pre><p id="e6f0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您用符号<code class="fe mk ml mm mb b">!</code>将<code class="fe mk ml mm mb b">length</code>设置为非空，并将其类型显式设置为<code class="fe mk ml mm mb b">number</code>，以确保<code class="fe mk ml mm mb b">this.length</code>始终是一个数字。</p><h1 id="6fd5" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">可变元组</h1><p id="31f0" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">TypeScript 4.0 附带了元素数量可变的元组的数据类型。</p><p id="3c27" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您可以使用 spread 操作符创建一个类型，其中包含您希望在元组中包含的元素。</p><p id="f894" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">例如，如果您写道:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="03ac" class="mf ku in mb b gy mg mh l mi mj">type Strings = [string, string];<br/>type Numbers = number[];<br/><br/>type Unbounded = [...Strings, ...Numbers, boolean];</span></pre><p id="4c1a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">创建一个<code class="fe mk ml mm mb b">Unbounded</code>数据类型来添加一个包含字符串、数字和布尔值的元组类型。</p><p id="2000" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">推断过程也是自动的，因此如果您有两个顺序相同的字符串、数字和一个布尔值，TypeScript 将推断该元组具有<code class="fe mk ml mm mb b">Unbounded</code>类型。</p><h1 id="111c" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated"><code class="fe mk ml mm mb b">unknown</code>关于<code class="fe mk ml mm mb b">catch</code>条款绑定</h1><p id="67b5" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">您可以将<code class="fe mk ml mm mb b">catch</code>子句的绑定变量指定为<code class="fe mk ml mm mb b">unknown</code>类型，而不是<code class="fe mk ml mm mb b">any</code>类型。</p><p id="ee81" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对于<code class="fe mk ml mm mb b">unknown</code>类型，在使用异常对象之前，您必须显式地转换它。</p><p id="add3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">例如，您可以写:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="239b" class="mf ku in mb b gy mg mh l mi mj">try {<br/>  // ...<br/>} catch (e: unknown) {<br/>  if (typeof e === "string") {<br/>    console.log(e.toUpperCase());<br/>  }<br/>}</span></pre><p id="496a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后在调用<code class="fe mk ml mm mb b">toUpperCase</code>之前检查<code class="fe mk ml mm mb b">e</code>是否是一个字符串。</p><h1 id="04dd" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">短路赋值运算符</h1><p id="6521" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">TypeScript 4.0 有新的赋值运算符 shorthands。</p><p id="a1f6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，您用快捷键编写逻辑 AND、逻辑 OR 和看涨合并运算符。</p><p id="722d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">例如，不要写:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="cc02" class="mf ku in mb b gy mg mh l mi mj">a = a &amp;&amp; b;<br/>a = a || b;<br/>a = a ?? b;</span></pre><p id="44f1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你可以写:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="66c4" class="mf ku in mb b gy mg mh l mi mj">a &amp;&amp;= b;<br/>a ||= b;<br/>a ??= b;</span></pre><h1 id="079b" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">结论</h1><p id="4fa4" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">TypeScript 4.0 提供了许多新功能，您可以使用这些功能来检查类型。</p><p id="fce3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">类型推断也得到了改进。</p><p id="4bcd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">今天到此为止。</p><p id="b1f3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">感谢您的阅读！</p></div></div>    
</body>
</html>