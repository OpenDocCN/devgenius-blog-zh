<html>
<head>
<title>The optimal solution to shuffle an Array in Javascript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Javascript中混洗数组的最佳解决方案</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/jthe-optimal-solution-to-shuffle-an-array-in-javascript-2d9c8ac066d9?source=collection_archive---------5-----------------------#2020-07-27">https://blog.devgenius.io/jthe-optimal-solution-to-shuffle-an-array-in-javascript-2d9c8ac066d9?source=collection_archive---------5-----------------------#2020-07-27</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/c818bbd57184f9f2cfffa5600b093275.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*377SJy9bTI4mvtslto6IAw.png"/></div></div></figure><p id="63a6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我最近遇到了一个小问题，关于在旧数组的基础上创建一个新的随机有序数组。简而言之，最终目标是得到一个混洗的数组。</p><p id="2f4f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">【https://pitayan.com/posts/javascript-shuffle-array/】访问<a class="ae kt" href="https://pitayan.com/posts/javascript-shuffle-array?ref=medium" rel="noopener ugc nofollow" target="_blank"/>阅读原文带<strong class="jx io">源代码集锦</strong>。</p><p id="2cd1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">以下是我在搜索网页之前，经过几分钟的实验后得出的解决方案。(我以为我自己能行:p)</p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="9e9a" class="ld le in kz b gy lf lg l lh li">var arr = [1, 2, 3, 4, 5, 6, 7]</span><span id="0c39" class="ld le in kz b gy lj lg l lh li">function shuffle (arr) {<br/>  let i = 0,<br/>      res = [],<br/>      index</span><span id="45b0" class="ld le in kz b gy lj lg l lh li">  while (i &lt;= arr.length - 1) {<br/>    index = Math.floor(Math.random() * arr.length)</span><span id="859a" class="ld le in kz b gy lj lg l lh li">    if (!res.includes(arr[index])) {<br/>      res.push(arr[index])<br/>      i++<br/>    }<br/>  }</span><span id="40c3" class="ld le in kz b gy lj lg l lh li">  return res<br/>}</span><span id="0621" class="ld le in kz b gy lj lg l lh li">// expected<br/>arr = shuffle(arr)<br/>// [6, 3, 4, 1, 7, 2, 5]</span></pre><p id="2498" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">正如你所看到的，这不是一个处理洗牌的好方法，所以我决定做一些研究。</p><p id="3c6f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在google和stackoverflow上找了一些答案后，找到了一个最满意的<a class="ae kt" href="https://stackoverflow.com/questions/2450954/how-to-randomize-shuffle-a-javascript-array" rel="noopener ugc nofollow" target="_blank">解</a>来洗牌。(答案从2010年就有了……但是，确实非常合格。)</p><p id="592b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先，我们来看看答案。这很简单，但足够快。</p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="d8c0" class="ld le in kz b gy lf lg l lh li">function shuffle(array) {<br/>  var currentIndex = array.length, temporaryValue, randomIndex;</span><span id="f823" class="ld le in kz b gy lj lg l lh li">  // While there remain elements to shuffle...<br/>  while (0 !== currentIndex) {</span><span id="d22a" class="ld le in kz b gy lj lg l lh li">    // Pick a remaining element...<br/>    randomIndex = Math.floor(Math.random() * currentIndex);<br/>    currentIndex -= 1;</span><span id="e2d3" class="ld le in kz b gy lj lg l lh li">    // And swap it with the current element.<br/>    temporaryValue = array[currentIndex];<br/>    array[currentIndex] = array[randomIndex];<br/>    array[randomIndex] = temporaryValue;<br/>  }</span><span id="c656" class="ld le in kz b gy lj lg l lh li">  return array;<br/>}</span></pre><h1 id="7364" class="lk le in bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated"><a class="ae kt" href="https://pitayan.com/#why-my-solution-is-bad" rel="noopener ugc nofollow" target="_blank">为什么我的解决方案不好</a></h1><p id="2136" class="pw-post-body-paragraph jv jw in jx b jy mh ka kb kc mi ke kf kg mj ki kj kk mk km kn ko ml kq kr ks ig bi translated">一开始，我只是考虑在一个<code class="fe mm mn mo kz b">while</code>循环中创建新的随机索引，并将旧的数组元素作为返回推送到一个新的数组中。</p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="9d8f" class="ld le in kz b gy lf lg l lh li">while (i &lt;= arr.length - 1) {<br/>  // create random index<br/>  index = Math.floor(Math.random() * arr.length)</span><span id="e042" class="ld le in kz b gy lj lg l lh li">  // insert the element to new array<br/>  if (!res.includes(arr[index])) {<br/>    res.push(arr[index])<br/>    i++<br/>  }<br/>}</span></pre><p id="5031" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">它运行良好，回报非常令人满意。但是时间复杂度相当糟糕。在<code class="fe mm mn mo kz b">while</code>循环中，它检查要插入的元素是否存在于每个循环的新数组中。这就产生了<em class="mp"> O(n2) </em>。</p><p id="993e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果一个数组没有那么大，那么我的函数就很好。但事实是，我的项目需要生成一个超过1000个元素的列表。所以还是优化算法比较好。(我觉得做这样的优化总是比较好的。不要害怕对计算机指手画脚(:D)</p><h1 id="e9fc" class="lk le in bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated"><a class="ae kt" href="https://pitayan.com/#the-fisheryates-shuffle" rel="noopener ugc nofollow" target="_blank">费希尔-耶茨洗牌</a></h1><p id="8ede" class="pw-post-body-paragraph jv jw in jx b jy mh ka kb kc mi ke kf kg mj ki kj kk mk km kn ko ml kq kr ks ig bi translated">stackoverflow的答案似乎很简单，然而实际上它使用了由罗纳德·费雪和弗兰克耶茨发明的算法。</p><blockquote class="mq mr ms"><p id="7b04" class="jv jw mp jx b jy jz ka kb kc kd ke kf mt kh ki kj mu kl km kn mv kp kq kr ks ig bi translated"><em class="in">Fisher–Yates shuffle是一种用于生成有限序列的随机排列的算法——简单来说，该算法对序列进行洗牌。</em></p><p id="396d" class="jv jw mp jx b jy jz ka kb kc kd ke kf mt kh ki kj mu kl km kn mv kp kq kr ks ig bi translated"><em class="in">…后又被称为</em> <a class="ae kt" href="https://en.wikipedia.org/wiki/Donald_Knuth" rel="noopener ugc nofollow" target="_blank"> <em class="in">唐纳德·克努特</em> </a> <em class="in">。</em></p><p id="6ef0" class="jv jw mp jx b jy jz ka kb kc kd ke kf mt kh ki kj mu kl km kn mv kp kq kr ks ig bi translated"><em class="in"> —来自</em> <a class="ae kt" href="https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle" rel="noopener ugc nofollow" target="_blank"> <em class="in">百科</em> </a></p></blockquote><p id="161e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">有一篇旧的博客文章可视化了洗牌算法。<a class="ae kt" href="https://bost.ocks.org/mike/shuffle/" rel="noopener ugc nofollow" target="_blank">https://bost.ocks.org/mike/shuffle/</a></p><p id="4c77" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe mm mn mo kz b">shuffle</code>函数是算法的描述。</p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="a252" class="ld le in kz b gy lf lg l lh li">function shuffle(array) {<br/>  var currentIndex = array.length, temporaryValue, randomIndex;</span><span id="61b9" class="ld le in kz b gy lj lg l lh li">  // While there remain elements to shuffle...<br/>  while (0 !== currentIndex) {</span><span id="ce79" class="ld le in kz b gy lj lg l lh li">    // Create a random index to pick from the original array<br/>    randomIndex = Math.floor(Math.random() * currentIndex);<br/>    currentIndex -= 1;</span><span id="a267" class="ld le in kz b gy lj lg l lh li">    // Cache the value, and swap it with the current element<br/>    temporaryValue = array[currentIndex];<br/>    array[currentIndex] = array[randomIndex];<br/>    array[randomIndex] = temporaryValue;<br/>  }</span><span id="30ba" class="ld le in kz b gy lj lg l lh li">  return array;<br/>}</span></pre><p id="6824" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个解决方案很好，但仍有改进的潜力。我相信在这里做一个纯函数更有意义。所以我宁愿返回一个新的数组，而不是修改原来的参数作为副作用。</p><p id="5632" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了避免修改原始数据，我还可以在传递arugment的同时创建一个克隆。</p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="0c6d" class="ld le in kz b gy lf lg l lh li">shuffle(arr.slice(0))</span></pre><h1 id="920f" class="lk le in bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated"><a class="ae kt" href="https://pitayan.com/#other-variations" rel="noopener ugc nofollow" target="_blank">其他变化</a></h1><p id="fa38" class="pw-post-body-paragraph jv jw in jx b jy mh ka kb kc mi ke kf kg mj ki kj kk mk km kn ko ml kq kr ks ig bi translated">对于我在<a class="ae kt" href="https://stackoverflow.com/questions/2450954/how-to-randomize-shuffle-a-javascript-array" rel="noopener ugc nofollow" target="_blank"> stackoverflow </a>上找到的解决方案，有一些值得尊敬的替代方案，我认为它们是经过适当优化的。</p><h2 id="45c8" class="ld le in bd ll mw mx dn lp my mz dp lt kg na nb lx kk nc nd mb ko ne nf mf ng bi translated"><a class="ae kt" href="https://pitayan.com/#the-durstenfeld-shuffle" rel="noopener ugc nofollow" target="_blank">德斯滕费尔德洗牌</a></h2><p id="b572" class="pw-post-body-paragraph jv jw in jx b jy mh ka kb kc mi ke kf kg mj ki kj kk mk km kn ko ml kq kr ks ig bi translated">该解决方案出现在<a class="ae kt" href="https://stackoverflow.com/questions/2450954/how-to-randomize-shuffle-a-javascript-array" rel="noopener ugc nofollow" target="_blank">堆栈溢出</a>页面上。最后我找到了一个要点备忘录。</p><p id="e6b0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae kt" href="https://gist.github.com/webbower/8d19b714ded3ec53d1d7ed32b79fdbac" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/web bower/8d 19 b 714 ded 3 EC 53d 1d 7 ed 32 b 79 fdbac</a></p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="4f28" class="ld le in kz b gy lf lg l lh li">// Pre-ES6<br/>function shuffleArray(array) {<br/>  for (var i = array.length - 1; i &gt; 0; i--) {<br/>    var j = Math.floor(Math.random() * (i + 1));<br/>    var temp = array[i];<br/>    array[i] = array[j];<br/>    array[j] = temp;<br/>  }<br/>}</span><span id="13b9" class="ld le in kz b gy lj lg l lh li">// ES6+<br/>function shuffleArray(array) {<br/>  for (let i = array.length - 1; i &gt; 0; i--) {<br/>    let j = Math.floor(Math.random() * (i + 1));<br/>    [array[i], array[j]] = [array[j], array[i]];<br/>  }<br/>}</span></pre><h2 id="35f9" class="ld le in bd ll mw mx dn lp my mz dp lt kg na nb lx kk nc nd mb ko ne nf mf ng bi translated"><a class="ae kt" href="https://pitayan.com/#array-extension-method" rel="noopener ugc nofollow" target="_blank">数组扩展方法</a></h2><p id="06da" class="pw-post-body-paragraph jv jw in jx b jy mh ka kb kc mi ke kf kg mj ki kj kk mk km kn ko ml kq kr ks ig bi translated">实际上，我更喜欢这个，因为它简单，而且有一个关于整数的小技巧。这里的窍门是用<code class="fe mm mn mo kz b">&gt;&gt;&gt;</code> ( <a class="ae kt" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Unsigned_right_shift" rel="noopener ugc nofollow" target="_blank">无符号右移运算符</a>)代替<code class="fe mm mn mo kz b">Math.floor</code>。</p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="0c44" class="ld le in kz b gy lf lg l lh li">Array.prototype.shuffle = function() {<br/>  let m = this.length, i;<br/>  while (m) {<br/>    i = (Math.random() * m--) &gt;&gt;&gt; 0;<br/>    [this[m], this[i]] = [this[i], this[m]]<br/>  }<br/>  return this;<br/>}</span></pre><p id="b295" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">好了，研究到此为止。希望您也能从这篇文章中很好地理解<code class="fe mm mn mo kz b">shuffle</code>算法。如果你觉得这篇文章很棒，请分享到社交网络上。</p><p id="0dec" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">感谢阅读！</p><h1 id="429c" class="lk le in bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated"><a class="ae kt" href="https://pitayan.com/#references" rel="noopener ugc nofollow" target="_blank">参考文献</a></h1><ul class=""><li id="c5ed" class="nh ni in jx b jy mh kc mi kg nj kk nk ko nl ks nm nn no np bi translated"><a class="ae kt" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Unsigned_right_shift" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/Reference/Operators/Unsigned _ right _ shift</a></li><li id="2d3d" class="nh ni in jx b jy nq kc nr kg ns kk nt ko nu ks nm nn no np bi translated"><a class="ae kt" href="https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Fisher–Yates_shuffle</a></li><li id="f6c2" class="nh ni in jx b jy nq kc nr kg ns kk nt ko nu ks nm nn no np bi translated"><a class="ae kt" href="https://stackoverflow.com/questions/2450954/how-to-randomize-shuffle-a-javascript-array" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/2450954/how-to-randomize-shuffle-a-JavaScript-array</a></li><li id="0d8e" class="nh ni in jx b jy nq kc nr kg ns kk nt ko nu ks nm nn no np bi translated"><a class="ae kt" href="https://gist.github.com/webbower/8d19b714ded3ec53d1d7ed32b79fdbac" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/web bower/8d 19 b 714 ded 3 EC 53d 1d 7 ed 32 b 79 fdbac</a></li></ul></div><div class="ab cl nv nw hr nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="ig ih ii ij ik"><p id="2365" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">原本在<a class="ae kt" href="https://pitayan.com?ref=medium" rel="noopener ugc nofollow" target="_blank">Pitayan.com</a></p><p id="e855" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae kt" href="https://pitayan.com/posts/javascript-shuffle-array/?ref=medium" rel="noopener ugc nofollow" target="_blank">https://pitayan.com/posts/javascript-shuffle-array/</a></p><div class="oc od gp gr oe of"><a href="https://pitayan.com/posts/javascript-shuffle-array/?ref=medium" rel="noopener  ugc nofollow" target="_blank"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd io gy z fp ok fr fs ol fu fw im bi translated">Javascript - Pitayan中混洗数组的最佳解决方案</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">我最近遇到了一个小问题，关于在旧数组的基础上创建一个新的随机有序数组。简而言之，决赛…</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">pitayan.com</p></div></div><div class="oo l"><div class="op l oq or os oo ot jt of"/></div></div></a></div></div></div>    
</body>
</html>