<html>
<head>
<title>What is an API?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是 API？</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/what-is-an-api-ac88130c5ebb?source=collection_archive---------16-----------------------#2022-06-30">https://blog.devgenius.io/what-is-an-api-ac88130c5ebb?source=collection_archive---------16-----------------------#2022-06-30</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="638e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你知道什么是 API 吗？为什么使用你喜欢的框架的 API 很重要？你听说过接口和黑盒吗？在本帖中，我们将用例子来谈论所有这些话题。</p><p id="241a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我本来打算写为什么你应该使用 WordPress 的 API，但是我不得不回到很多概念上，我们不得不开始讨论什么是 API。这篇文章面向初级和高级开发人员。是的，我们将讨论<em class="ki">的概念</em>，但不要离开，这些是一些重要的概念。</p><blockquote class="kj kk kl"><p id="0219" class="jk jl ki jm b jn jo jp jq jr js jt ju km jw jx jy kn ka kb kc ko ke kf kg kh ig bi translated"><em class="in"> API 是</em> <strong class="jm io"> <em class="in">应用编程接口</em> </strong> <em class="in">的缩写。但是这到底意味着什么呢？！</em></p></blockquote><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi kp"><img src="../Images/a7b5b05f4560690acb26c53f473c381e.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/0*wtBZIakrLdvnieDR.png"/></div></figure><p id="7717" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">“应用”和“编程”是容易的部分。是我们需要更好理解的“接口”。</p><h1 id="234e" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">什么是接口？</h1><p id="28e6" class="pw-post-body-paragraph jk jl in jm b jn lv jp jq jr lw jt ju jv lx jx jy jz ly kb kc kd lz kf kg kh ig bi translated">一个接口无非是外层，<strong class="jm io">与外部</strong>连接的部分，保持内部的安全。</p><p id="86f0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们每天都在处理这个概念，如果不可能，我们会抓狂。想象一下，如果你必须知道你周围一切的来龙去脉！一些界面示例:</p><ul class=""><li id="07dd" class="ma mb in jm b jn jo jr js jv mc jz md kd me kh mf mg mh mi bi translated"><strong class="jm io">图形界面:</strong>你点击，程序执行。你不需要知道它是如何工作的，如果你点击它，它就会做你想做的事情，这才是最重要的。</li><li id="1e09" class="ma mb in jm b jn mj jr mk jv ml jz mm kd mn kh mf mg mh mi bi translated"><strong class="jm io">在餐馆点餐:</strong>你下订单，然后收到食物。他们有多少厨师，锅的颜色，或者炉子的品牌都无关紧要。</li><li id="2544" class="ma mb in jm b jn mj jr mk jv ml jz mm kd mn kh mf mg mh mi bi translated">感觉系统:你不需要知道你的身体<em class="ki">是如何闻到</em>某种东西的，它只是为你做了这些。</li></ul><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/8c1ea8cdc7a9fc16cd95f22a1245f9fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/0*mwNotppA9YfGh31X.gif"/></div></figure><p id="7c14" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">整个想法基于<em class="ki">输入</em>和<em class="ki">输出</em>的概念。给定一个输入，期望一个输出，忽略实现。</p><p id="695e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这种输入-输出-内部无关的概念我们称之为<strong class="jm io">黑盒</strong>。这里有一个重要的区别:</p><ul class=""><li id="9313" class="ma mb in jm b jn jo jr js jv mc jz md kd me kh mf mg mh mi bi translated">黑盒就是我们所说的接受输入并返回输出的东西，而不一定揭示它是如何创建输出的。</li><li id="82b8" class="ma mb in jm b jn mj jr mk jv ml jz mm kd mn kh mf mg mh mi bi translated"><strong class="jm io">一个接口就是你如何与系统</strong>连接，确切的预期输入是什么(一个数字，两个数字，一个字符串)以及输出会是什么样子(另一个数字，另一个字符串)。这就像一份合同。</li></ul><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/983eadc2068697d71eb2d9bfb42b147a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1190/format:webp/0*3WJh3KsKoWmvyeP3.jpg"/></div></figure><h1 id="0372" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">OOP 中的接口</h1><p id="11b8" class="pw-post-body-paragraph jk jl in jm b jn lv jp jq jr lw jt ju jv lx jx jy jz ly kb kc kd lz kf kg kh ig bi translated">这里我必须开一个简短的括号。接口也是面向对象编程中非常重要的东西。想法是完全一样的:如果一个类声明它实现了某个接口，它就需要实现该接口的所有方法。我将把关于接口的官方 PHP 文档留在这里，但是如果这是你想在另一篇文章中看到的话题，请留下评论。</p><h1 id="bdc5" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">好吧…我们现在可以回到 API 了吗？</h1><p id="71f3" class="pw-post-body-paragraph jk jl in jm b jn lv jp jq jr lw jt ju jv lx jx jy jz ly kb kc kd lz kf kg kh ig bi translated">这里是真正的帖子开始的地方！让我们回到缩写:</p><blockquote class="kj kk kl"><p id="d149" class="jk jl ki jm b jn jo jp jq jr js jt ju km jw jx jy kn ka kb kc ko ke kf kg kh ig bi translated"><strong class="jm io"> <em class="in">应用</em> </strong> <em class="in"> </em> <strong class="jm io"> <em class="in">编程</em> </strong> <em class="in"> </em> <strong class="jm io"> <em class="in">接口</em> </strong> <em class="in">是应用</em>的一部分，只能通过一组有输入和输出的方法组成的代码来访问，与它们的实现<em class="in">无关。</em></p></blockquote><p id="4a1e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在更有意义了吗？</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi kp"><img src="../Images/72b6a261018a2b91d1544c478a58abe7.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/0*FthhZj_kfebUzgmC.jpg"/></div></figure><p id="1069" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">(对于抱怨者来说，是的，我知道你可以用浏览器访问 REST API，但这不是它的预期用途。)</p><h1 id="9ea2" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">WordPress 的 API</h1><p id="d3bc" class="pw-post-body-paragraph jk jl in jm b jn lv jp jq jr lw jt ju jv lx jx jy jz ly kb kc kd lz kf kg kh ig bi translated">当我有写这篇文章的想法时，我打算谈谈使用 WordPress 内部 API 的重要性。WP 有很多这样的 API，我们已经在这里(用葡萄牙语)讨论过其中的一些了:<a class="ae mq" href="https://felipeelia.com.br/cache-facil-no-wordpress-transients-api/" rel="noopener ugc nofollow" target="_blank">瞬态 API </a>和<a class="ae mq" href="https://felipeelia.com.br/como-criar-uma-tela-de-configuracao-para-o-seu-plugin-wordpress-com-a-settings-api-parte-1/" rel="noopener ugc nofollow" target="_blank">设置 API </a>就是一些例子。WordPress API 的完整列表可以在 https://developer.wordpress.org/apis/获得。</p><blockquote class="kj kk kl"><p id="03c1" class="jk jl ki jm b jn jo jp jq jr js jt ju km jw jx jy kn ka kb kc ko ke kf kg kh ig bi translated">但是我们为什么要使用这些 API 而不是简单地直接在数据库中写一些东西或者在服务器中保存一个文件呢？</p></blockquote><p id="bb79" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">原因有很多，我们来查一下其中的一些。</p><p id="5bb4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">注:</strong>这些概念不是孤立的，而是互补的。此外，我没有试图涵盖所有可能的方面，所以请在评论部分随意探索任何其他方面。</p><h1 id="4f38" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">关注点分离</h1><p id="36f8" class="pw-post-body-paragraph jk jl in jm b jn lv jp jq jr lw jt ju jv lx jx jy jz ly kb kc kd lz kf kg kh ig bi translated">这是一个旨在将应用程序分成模块的原则，每个模块只负责一件事。这些模块使用——你猜对了——接口相互通信。这样，<strong class="jm io">创建产品的代码与处理订单的代码</strong>分开，只有<em class="ki">调用</em>负责存储数据的模块。</p><p id="e7a9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">不幸的是，许多年前，经常可以看到 PHP 应用程序多次调用<code class="fe mr ms mt mu b">mysqli_real_connect</code>和类似的东西。今天，这不再是现实。例如，在 WordPress 中，我们有<code class="fe mr ms mt mu b">wpdb</code>类，其他框架使用 ORM，但是每次需要存储/保存一些数据时，都有一个我们可以依靠的抽象层。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/23bc4ccc9ccf36a1f5447af746940e15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/0*YDMl4-3qG-DyqaPl.gif"/></div></figure><h1 id="d305" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">可读性</h1><p id="49e3" class="pw-post-body-paragraph jk jl in jm b jn lv jp jq jr lw jt ju jv lx jx jy jz ly kb kc kd lz kf kg kh ig bi translated">我们不是为机器写代码，而是为其他人写代码。毕竟，我们说“代码是诗”是有原因的。也就是说，第一次看代码并理解它的作用是很重要的。</p><p id="ca49" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">什么更容易理解？这</p><pre class="kq kr ks kt gt mv mu mw mx aw my bi"><span id="f1d6" class="mz ky in mu b gy na nb l nc nd">&lt;?php<br/>global $wpdb;<br/>$wpdb-&gt;query(<br/>	$wpdb-&gt;prepare(<br/>		"INSERT INTO `$wpdb-&gt;options` (`option_name`, `option_value`, `autoload`)<br/>			VALUES (%s, %s, %s)<br/>			ON DUPLICATE KEY<br/>			UPDATE<br/>				`option_name` = VALUES(`option_name`),<br/>				`option_value` = VALUES(`option_value`),<br/>				`autoload` = VALUES(`autoload`)", <br/>		$option,<br/>		$serialized_value,<br/>		$autoload<br/>	)<br/>);</span></pre><p id="02b1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">还是这个？</p><pre class="kq kr ks kt gt mv mu mw mx aw my bi"><span id="9c3c" class="mz ky in mu b gy na nb l nc nd">&lt;?php<br/>update_option( 'my_option', 'value' );</span></pre><p id="af27" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">第二种选择，对吧？很容易理解，我们正在保存一个选项，如果我们想使用任何其他存储机制，如 Redis 或 Memcached(下面将详细介绍)，调用<code class="fe mr ms mt mu b">update_option()</code>函数的软件部分不需要更改。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi ne"><img src="../Images/0d7ddc033a4809c252ec86d0c8be2a73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*QzEk_HwhN4CfMa2b.jpg"/></div></div></figure><h1 id="8493" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">实际例子</h1><blockquote class="kj kk kl"><p id="e726" class="jk jl ki jm b jn jo jp jq jr js jt ju km jw jx jy kn ka kb kc ko ke kf kg kh ig bi translated">使用 WordPress APIs 让生活变得更简单。有时，不使用它们会使项目不可行。</p></blockquote><h1 id="f4eb" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">文件 API</h1><p id="f6e1" class="pw-post-body-paragraph jk jl in jm b jn lv jp jq jr lw jt ju jv lx jx jy jz ly kb kc kd lz kf kg kh ig bi translated">这是一个经典案例。程序员使用<code class="fe mr ms mt mu b">fopen</code>、<code class="fe mr ms mt mu b">fclose</code>等功能保存文件。一切正常。项目增长了一点，<strong class="jm io">基础设施需要扩展，文件开始消失</strong>。让我们看一些图表来更好地理解它。</p><h1 id="e4a4" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">直接保存到服务器(只有一个 web 服务器)</h1><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi nj"><img src="../Images/c173bcb628c2f2b5aa3918ea4dc6d8fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*82CxCz_uiMBxpkqZ.jpg"/></div></div></figure><p id="fc8f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">到目前为止，一切顺利。管理员用户将文件发送到单个服务器，当用户访问站点时，文件将会在那里。</p><h1 id="eccf" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">直接保存到服务器(有多个 web 服务器)</h1><p id="2e79" class="pw-post-body-paragraph jk jl in jm b jn lv jp jq jr lw jt ju jv lx jx jy jz ly kb kc kd lz kf kg kh ig bi translated">现在让我们假设我们需要另一台服务器。在两个 web 服务器的前面，我们放置了一个<em class="ki">负载平衡器</em>，在它们之间分配流量。</p><p id="bfdd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果我们将文件直接保存到服务器中，它将只存储在管理员用户上传文件的服务器中，而不是每次请求被发送到其他 web 服务器时都被发现。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi nk"><img src="../Images/62be8d67fe311fe38934acca2237c3dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*-r2uBUyN0wQMGL4V.jpg"/></div></div></figure><h1 id="5229" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">把它保存在别的地方</h1><p id="c662" class="pw-post-body-paragraph jk jl in jm b jn lv jp jq jr lw jt ju jv lx jx jy jz ly kb kc kd lz kf kg kh ig bi translated">通常，解决方案依赖于将文件保存在其他地方，比如亚马逊 S3 存储桶。它可以在任何地方，这里重要的是成为一个所有服务器都可以访问的地方。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi nl"><img src="../Images/1ec590fc9cab3f2e1c32ffb34e54da2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*d6VR-9_zw8eIGyAT.jpg"/></div></div></figure><h1 id="9ec9" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">我们如何解决这个问题？</h1><p id="280e" class="pw-post-body-paragraph jk jl in jm b jn lv jp jq jr lw jt ju jv lx jx jy jz ly kb kc kd lz kf kg kh ig bi translated">这个例子的解决方案很简单，使用了一个<a class="ae mq" href="https://github.com/humanmade/S3-Uploads" rel="noopener ugc nofollow" target="_blank">插件</a>。</p><p id="0d15" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里对我们来说最重要的是<strong class="jm io">插件将只为使用 WordPress 的文件 API </strong>的代码工作。它将不能改变对<code class="fe mr ms mt mu b">fopen</code>的直接调用，而只能改变对<code class="fe mr ms mt mu b">$wp_filesystem-&gt;put_contents()</code>或通过文件 API 传递的函数的调用。</p><h1 id="4505" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">瞬态 API</h1><p id="da01" class="pw-post-body-paragraph jk jl in jm b jn lv jp jq jr lw jt ju jv lx jx jy jz ly kb kc kd lz kf kg kh ig bi translated">如果你阅读了<a class="ae mq" href="https://felipeelia.com.br/cache-facil-no-wordpress-transients-api/" rel="noopener ugc nofollow" target="_blank">关于瞬态 API </a>的帖子和<a class="ae mq" href="https://developer.wordpress.org/apis/handbook/transients/#function-reference" rel="noopener ugc nofollow" target="_blank">官方文档</a>，你会发现它基本上由三个函数组成:<code class="fe mr ms mt mu b">set_transient()</code>、<code class="fe mr ms mt mu b">get_transient()</code>和<code class="fe mr ms mt mu b">delete_transient()</code>。您可以快速实现三个函数来存储、获取和删除数据库中的值，但是您将失去一个最常用的提高性能的基础设施:<strong class="jm io">内存存储</strong>。</p><p id="4ac9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">放松，没什么大不了的。当我谈到<a class="ae mq" href="https://felipeelia.com.br/tipos-de-plugin-do-wordpress/" rel="noopener ugc nofollow" target="_blank">插件类型</a>时，我已经谈到了<em class="ki">插件</em>，其中之一就是<code class="fe mr ms mt mu b">object-cache.php</code>。有了它，就可以用 Redis 或者 Memcached 之类的软件把东西存到内存里，而不是每次都去磁盘。内存访问比磁盘访问快，正因为如此，这些程序比数据库更快地返回数据。</p><p id="bb5e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果您直接在数据库中存储东西，那么在基础设施中添加类似这些程序的东西不会有什么不同。另一方面，<strong class="jm io">如果你使用 WordPress 的 API，一个插件就足够了</strong>，只需要配置和放置它的<em class="ki">插件</em>就可以了，一切都会自动运行。如果你想在 Redis 和 Memcached 之间转换，你也不需要担心，因为实现会改变，但是你使用的接口保持不变。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi nm"><img src="../Images/51152b160a4eb2735dc9b5520317872e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*LyzIGbtL5l6S_fe7.png"/></div></div></figure><h1 id="d97e" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">WordPress REST API</h1><p id="1e17" class="pw-post-body-paragraph jk jl in jm b jn lv jp jq jr lw jt ju jv lx jx jy jz ly kb kc kd lz kf kg kh ig bi translated">几年前我已经谈过这个话题，但它仍然有用。如果你来到这里想了解更多关于 WordPress REST API 的信息，你可以查看另一篇文章。我很肯定你会喜欢的！</p></div><div class="ab cl nn no hr np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ig ih ii ij ik"><p id="346e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我知道这是一个大帖子。如果你能在你的社交网络上分享它，订阅时事通讯，并留下评论，你就帮了我大忙了。谢谢大家！</p></div></div>    
</body>
</html>