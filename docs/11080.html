<html>
<head>
<title>Swift Programming Tutorial: Generics</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift 编程教程:泛型</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/swift-programming-tutorial-generics-d0ea4dd94574?source=collection_archive---------6-----------------------#2022-12-17">https://blog.devgenius.io/swift-programming-tutorial-generics-d0ea4dd94574?source=collection_archive---------6-----------------------#2022-12-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4663" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">灵活编码的基本工具</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/c01c62cc9a3e8c1167c861aebc4d42b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u7-YIx7xFa6ORRizaLIuMA.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">凯利·西克玛在 unsplash.com 拍摄的照片</figcaption></figure><p id="0df0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi lr translated">wift 对泛型的支持允许你编写可以用于多种类型的代码，同时仍然保持类型安全。通过使用泛型，您可以创建灵活且可重用的函数和类型，这意味着它们可以很容易地适应不同的类型，而无需为每种类型编写单独的代码。泛型还允许您编写可应用于多种类型的抽象代码，从而帮助您避免重复。这可以使您的代码更简洁、更易读，因为它清楚地表达了代码的意图，而不需要重复。</p><p id="5d01" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">本文是我的<a class="ae ma" href="https://arc-sosangyo.medium.com/list/introduction-to-swift-programming-tutorials-0a558ad90722" rel="noopener"> Swift 编程教程</a>系列的一部分。</p><p id="4488" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">您可以通过在函数、类或其他类型的名称后添加所需类型的占位符来使用泛型，写为<code class="fe mb mc md me b">&lt;GenericName&gt;</code>。下面是一个语法示例:</p><pre class="kg kh ki kj gt mf me mg bn mh mi bi"><span id="8203" class="mj mk iq me b be ml mm l mn mo">func printDataType&lt;T&gt;(data: T) {}</span></pre><blockquote class="mp mq mr"><p id="c449" class="kv kw ms kx b ky kz jr la lb lc ju ld mt lf lg lh mu lj lk ll mv ln lo lp lq ij bi translated"><strong class="kx ir">注意:</strong>在定义泛型类型时，字母“T”通常被用作占位符，但是它可以被任何其他有效的标识符替换。</p></blockquote><h2 id="e62a" class="mw mk iq bd mx my mz dn na nb nc dp nd le ne nf ng li nh ni nj lm nk nl nm nn bi translated">在函数中使用泛型</h2><p id="1d6b" class="pw-post-body-paragraph kv kw iq kx b ky no jr la lb np ju ld le nq lg lh li nr lk ll lm ns lo lp lq ij bi translated">从一个非常简单的使用函数的例子开始，这就是泛型的创建方式。</p><pre class="kg kh ki kj gt mf me mg bn mh mi bi"><span id="a159" class="mj mk iq me b be ml mm l mn mo">func printDataType&lt;T&gt;(data: T) {<br/>    print(data, "is", type(of: data))<br/>}<br/><br/>printDataType(data: "Hello World")<br/>printDataType(data: 45.0000087)</span></pre><p id="3e20" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果你好奇，这里是输出:</p><pre class="kg kh ki kj gt mf me mg bn mh mi bi"><span id="f150" class="mj mk iq me b be ml mm l nt mo">Hello World is String<br/>45.0000087 is Double</span></pre><h2 id="2cb0" class="mw mk iq bd mx my mz dn na nb nc dp nd le ne nf ng li nh ni nj lm nk nl nm nn bi translated">使用具有类型约束的泛型</h2><p id="fda8" class="pw-post-body-paragraph kv kw iq kx b ky no jr la lb np ju ld le nq lg lh li nr lk ll lm ns lo lp lq ij bi translated">再举个例子怎么样。让我们创建一个比较两个数字并返回较小数字的函数。下面是没有使用泛型的代码:</p><pre class="kg kh ki kj gt mf me mg bn mh mi bi"><span id="34e7" class="mj mk iq me b be ml mm l mn mo">func showLowerNumber(firstNum: Int, secondNum: Int) {<br/>    if firstNum &lt; secondNum {<br/>        print("First number is lower")<br/>    } else {<br/>        print("Second number is lower")<br/>    }<br/>}<br/><br/>showLowerNumber(firstNum: 34, secondNum: 89)</span></pre><p id="d881" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">上面显示的函数用于显示哪个数字更小。但是，它只接受整数数据类型<a class="ae ma" href="https://medium.com/@arc-sosangyo/swift-programming-tutorial-variables-670ceea20bd1" rel="noopener">。如果我们想使用其他数值数据类型，比如 double 或 float，我们可以利用泛型修改函数来处理这些数据类型。像这样编辑上面的代码:</a></p><pre class="kg kh ki kj gt mf me mg bn mh mi bi"><span id="d682" class="mj mk iq me b be ml mm l mn mo">func showLowerNumber&lt;AnyNum: Comparable&gt;(firstNum: AnyNum, secondNum: AnyNum) {<br/>    if firstNum &lt; secondNum {<br/>        print("First number is lower")<br/>    } else {<br/>        print("Second number is lower")<br/>    }<br/>}<br/><br/>showLowerNumber(firstNum: 0.067, secondNum: 0.0001)</span></pre><p id="0433" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">以下是输出结果:</p><pre class="kg kh ki kj gt mf me mg bn mh mi bi"><span id="842d" class="mj mk iq me b be ml mm l nt mo">Second number is lower</span></pre><blockquote class="mp mq mr"><p id="2b1f" class="kv kw ms kx b ky kz jr la lb lc ju ld mt lf lg lh mu lj lk ll mv ln lo lp lq ij bi translated"><a class="ae ma" href="https://developer.apple.com/documentation/swift/comparable" rel="noopener ugc nofollow" target="_blank"> Comparable </a>是一个协议，允许使用关系<a class="ae ma" href="https://medium.com/@arc-sosangyo/swift-programming-tutorial-basic-operators-72dc48116b1c" rel="noopener">操作符</a>来比较特定类型的实例。</p></blockquote><h2 id="ebf5" class="mw mk iq bd mx my mz dn na nb nc dp nd le ne nf ng li nh ni nj lm nk nl nm nn bi translated">在类中使用泛型</h2><p id="74ff" class="pw-post-body-paragraph kv kw iq kx b ky no jr la lb np ju ld le nq lg lh li nr lk ll lm ns lo lp lq ij bi translated">泛型也可以用在类中，因为它们允许创建可重用的对象。这里有一个例子:</p><pre class="kg kh ki kj gt mf me mg bn mh mi bi"><span id="c985" class="mj mk iq me b be ml mm l mn mo">class ShowDataType&lt;T&gt; {<br/>    <br/>    var data: T<br/>    <br/>    init(data: T) {<br/>        self.data = data<br/>    }<br/>    <br/>    func printDataType() {<br/>        print(data, "is", type(of: data))<br/>    }<br/>    <br/>}<br/><br/>var showAny = ShowDataType(data: [1, "Hi"])<br/>showAny.printDataType()<br/><br/>var showString = ShowDataType&lt;String&gt;(data: "Hello World")<br/>showString.printDataType()<br/><br/>var showInt = ShowDataType&lt;Int&gt;(data: 45)<br/>showInt.printDataType()</span></pre><p id="9b32" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">以下是输出结果:</p><pre class="kg kh ki kj gt mf me mg bn mh mi bi"><span id="c557" class="mj mk iq me b be ml mm l mn mo">[1, "Hi"] is Array&lt;Any&gt;<br/>Hello World is String<br/>45 is Int</span></pre><p id="bd50" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在提供的例子中，没有为<code class="fe mb mc md me b">showAny </code>变量指定数据类型，但是为<code class="fe mb mc md me b">showString</code>和<code class="fe mb mc md me b">showInt </code>变量都指定了数据类型。</p><h2 id="f8eb" class="mw mk iq bd mx my mz dn na nb nc dp nd le ne nf ng li nh ni nj lm nk nl nm nn bi translated">在 SwiftUI 这样的结构中使用泛型</h2><p id="185b" class="pw-post-body-paragraph kv kw iq kx b ky no jr la lb np ju ld le nq lg lh li nr lk ll lm ns lo lp lq ij bi translated">由于<a class="ae ma" href="https://medium.com/@arc-sosangyo/list/swiftui-tutorial-03734e631240" rel="noopener"> SwiftUI </a>使用 struct，您将基本上使用泛型来存储视图，作为可重用 SwiftUI 视图的属性。这里有一个例子:</p><pre class="kg kh ki kj gt mf me mg bn mh mi bi"><span id="3b2e" class="mj mk iq me b be ml mm l mn mo">struct BlueCirclePlaceholder&lt;Content: View&gt;: View {<br/>    <br/>    var content: () -&gt; Content<br/>    <br/>    var body: some View {<br/>        content()<br/>            .frame(maxWidth: .infinity)<br/>            .frame(height: 50)<br/>            .background(Color.blue)<br/>            .clipShape(Circle())<br/>    }<br/>    <br/>}</span></pre><p id="3a9c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在上面的代码中，我们将<code class="fe mb mc md me b">Content</code>类型声明为泛型，并指定它符合作为类型约束的<code class="fe mb mc md me b">View</code>协议。</p><p id="a053" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们现在可以这样使用新视图:</p><pre class="kg kh ki kj gt mf me mg bn mh mi bi"><span id="fc82" class="mj mk iq me b be ml mm l mn mo">struct ContentView: View {<br/><br/>    var body: some View {<br/>        VStack {<br/>            BlueCirclePlaceholder {<br/>                Text("AS")<br/>                    .font(.system(size: 30))<br/>                    .padding()<br/>            }<br/>        }<br/>        .background(Color.white)<br/>    }<br/><br/>}</span></pre></div><div class="ab cl nu nv hu nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="ij ik il im in"><p id="67a5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">总的来说，泛型帮助您创建适应性强的函数和类型，它们可以处理不同的数据类型，而不需要重复，从而提高代码的效率和可维护性。</p><p id="0f08" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">愿法典与你同在，</p><p id="a609" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">-电弧</p></div></div>    
</body>
</html>