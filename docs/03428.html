<html>
<head>
<title>Best of Modern JavaScript — Generators</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">现代JavaScript的精华——生成器</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/best-of-modern-javascript-generators-c069cf15ace1?source=collection_archive---------7-----------------------#2020-11-02">https://blog.devgenius.io/best-of-modern-javascript-generators-c069cf15ace1?source=collection_archive---------7-----------------------#2020-11-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/ffba1ee2c1aabc8af71ae71550fa9b45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kPmvud2oTYm9nV09"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">Jason Blackeye 在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="639f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">自2015年以来，JavaScript有了巨大的进步。</p><p id="c894" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在用起来比以前舒服多了。</p><p id="193a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究JavaScript生成器。</p><h1 id="44f0" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">发电机的种类</h1><p id="d38b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">有各种各样的发电机。</p><p id="db75" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以将生成器定义为生成器函数声明。</p><p id="e667" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这采取以下形式:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="1eb2" class="mn lc iq mj b gy mo mp l mq mr">function* genFn() {<br/>  //...<br/>}<br/>const genObj = genFn();</span></pre><p id="8c2c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">生成器函数表达式是我们将生成器函数赋给变量的地方:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="c026" class="mn lc iq mj b gy mo mp l mq mr">const genFn = function*() {<br/>  //...<br/>}<br/>const genObj = genFn();</span></pre><p id="ffaf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对象文字中的生成器方法让我们创建生成器方法:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="eee6" class="mn lc iq mj b gy mo mp l mq mr">const obj = {<br/>  * gen() {<br/>    //...<br/>  }<br/>};<br/>const genObj = obj.gen();</span></pre><p id="0b8e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">生成器方法也可以在类中。</p><p id="f6df" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="53b7" class="mn lc iq mj b gy mo mp l mq mr">class Foo {<br/>  * gen() {<br/>    //..,<br/>  }<br/>}<br/>const foo = new Foo();<br/>const genObj = foo.gen();</span></pre><p id="07d6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们创建了一个类，并添加了生成器方法<code class="fe ms mt mu mj b">gen</code>。</p><p id="780e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以使用生成器函数来创建我们自己的iterable对象。</p><p id="76fe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="cafc" class="mn lc iq mj b gy mo mp l mq mr">function* keys(obj) {<br/>  const propKeys = Reflect.ownKeys(obj);</span><span id="6d83" class="mn lc iq mj b gy mv mp l mq mr">  for (const propKey of propKeys) {<br/>    yield propKeys;<br/>  }<br/>}</span><span id="13da" class="mn lc iq mj b gy mv mp l mq mr">const obj = {<br/>  a: 1,<br/>  b: 2<br/>};</span><span id="25ee" class="mn lc iq mj b gy mv mp l mq mr">for (const key of keys(obj)) {<br/>  console.log(key);<br/>}</span></pre><p id="f3ef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们创建了<code class="fe ms mt mu mj b">keys</code>生成器函数，它从一个对象获取密钥并返回密钥。</p><p id="11fd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们用for-of循环遍历这些键。</p><p id="9b75" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">async</code>和<code class="fe ms mt mu mj b">await</code>下面也用发电机，。</p><p id="9203" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">await</code>的工作方式类似于<code class="fe ms mt mu mj b">yield</code>，它暂停代码，直到检索到结果。</p><p id="e370" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">语法还使用了表面下的生成器。</p><p id="9402" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以这样使用它:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="2525" class="mn lc iq mj b gy mo mp l mq mr">async function fetchJson(url) {<br/>  try {<br/>    const request = await fetch(url);<br/>    const res = await request.json();<br/>    return res;<br/>  } catch (error) {<br/>    console.log(error);<br/>  }<br/>}</span></pre><p id="1f5d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">异步函数只返回承诺。</p><p id="743d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">return</code>语句返回解析为返回值的承诺。</p><h1 id="39ff" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">发电机</h1><p id="de40" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">发生器是可以暂停和恢复的功能。</p><p id="78a8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">生成器是唯一可以返回生成器的函数。</p><p id="4f5d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以如果我们有一个生成器函数，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="9a7e" class="mn lc iq mj b gy mo mp l mq mr">function* keys(obj) {<br/>  const propKeys = Reflect.ownKeys(obj);</span><span id="c613" class="mn lc iq mj b gy mv mp l mq mr">  for (const propKey of propKeys) {<br/>    yield propKeys;<br/>  }<br/>}</span><span id="45c9" class="mn lc iq mj b gy mv mp l mq mr">const obj = {<br/>  a: 1,<br/>  b: 2<br/>};</span><span id="01b2" class="mn lc iq mj b gy mv mp l mq mr">const gen = keys(obj)</span></pre><p id="2b73" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们调用<code class="fe ms mt mu mj b">keys</code> genereator函数来返回一个生成器。</p><p id="decf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">发电机是<code class="fe ms mt mu mj b">gen</code>并且ot不运行，直到我们调用<code class="fe ms mt mu mj b">next</code>。</p><p id="622d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="30c0" class="mn lc iq mj b gy mo mp l mq mr">const gen = keys(obj);</span><span id="aece" class="mn lc iq mj b gy mv mp l mq mr">console.log(gen.next());<br/>console.log(gen.next());</span></pre><p id="daa9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后发电机功能将运行。</p><h1 id="0209" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">发电机的使用</h1><p id="26d1" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">生成器可以用于迭代器。</p><p id="164e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们用<code class="fe ms mt mu mj b">yield</code>产生数据，可以用<code class="fe ms mt mu mj b">next</code>方法访问。</p><p id="04a2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">生成器可以产生带有循环和递归的值序列。</p><p id="944d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这意味着生成器可以与for-of和spread运算符一起使用。</p><p id="5927" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">他们也可以是数据消费者。</p><p id="e2fd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">yield</code>可以从<code class="fe ms mt mu mj b">next</code>方法或任何其他来源获取值。</p><p id="c252" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们也可以同时存在，因为它们可以暂停。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/2204563755561614fec6cae474b4144d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uHjEawZ-HxcRPJVG"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">由<a class="ae kc" href="https://unsplash.com/@claudelrheault?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Claudel Rheault </a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="bee2" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="105b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">生成器可以是数据生产者，也可以是消费者。</p><p id="2fe9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">async</code>和<code class="fe ms mt mu mj b">await</code>也在表面下使用生成器语法。</p></div></div>    
</body>
</html>