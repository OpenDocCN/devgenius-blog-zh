<html>
<head>
<title>SQL Subqueries, The (Mostly) Complete Guide</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SQL 子查询,(大部分)完整指南</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/sql-subqueries-the-mostly-complete-guide-ddd5b7f24f47?source=collection_archive---------6-----------------------#2022-06-09">https://blog.devgenius.io/sql-subqueries-the-mostly-complete-guide-ddd5b7f24f47?source=collection_archive---------6-----------------------#2022-06-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3150" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">对最常见的子查询用途和关注点的深入回顾</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/8e08bc08cc80254705c13606acda1895.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0oTz7BdPcdSieRqc93CnQQ.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">Clark Van Der Beken 在<a class="ae kv" href="https://unsplash.com/s/photos/geometric?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="acbf" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">基础知识</h1><p id="2f24" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">子查询是嵌套在主查询的 SELECT、FROM 或 WHERE 子句中的查询。子查询用括号括起来，以便与主查询分开。</p><p id="7114" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在下面的示例中，使用 WHERE 子句中的子查询选择年龄大于平均值的所有用户。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="bdb3" class="mu kx iq mq b gy mv mw l mx my">SELECT first_name,<br/>       last_name,<br/>       age<br/>FROM   users<br/>WHERE  age &gt; (SELECT <em class="mz">Avg</em>(age)<br/>              FROM   users)</span></pre><p id="f724" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">子查询出现在 WHERE 子句中比较的右侧。该子查询返回平均值的单个值(标量值)。如果我们用子查询代替实际平均值，查询的功能将完全相同:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="d706" class="mu kx iq mq b gy mv mw l mx my">SELECT first_name,<br/>       last_name,<br/>       age<br/>FROM   users<br/>WHERE  age &gt; 31</span></pre><h1 id="ee82" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">深潜</h1><p id="9aea" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">为了更深入地研究子查询，我们可以看看子查询在 SELECT、FROM 和 WHERE 子句中的行为。这是一个很好的轨迹，因为每个用例都有独特的关注点。</p><p id="245a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">所以让我们从顶部开始，用 SELECT。</p><h1 id="d817" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">在 SELECT 中使用子查询</h1><p id="e510" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">select 子句<strong class="lq ir">中的子查询必须只返回一行和一列；否则，出现错误</strong>。因此，select 中的子查询通常用于生成聚合值，而不将行分组在一起。</p><p id="26cc" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">考虑这个例子:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="162e" class="mu kx iq mq b gy mv mw l mx my">SELECT first_name,<br/>       last_name,<br/>       age,<br/>       (SELECT <em class="mz">Avg</em>(age)<br/>        FROM   users) as avg_age<br/>FROM   users</span></pre><p id="1a3f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">类似上面例子的子查询的行为类似于聚合窗口函数。然而，与窗口函数不同，子查询不支持分区。</p><p id="4c65" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">此外，SELECT 子句中的子查询可以从外部查询中访问表列。<strong class="lq ir">当子查询引用外部查询表中的列时，它被称为相关子查询</strong>。下面是 SELECT 子句中相关子查询的一个示例。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="d8e7" class="mu kx iq mq b gy mv mw l mx my">SELECT first_name,<br/>       last_name,<br/>       (SELECT verification_status<br/>        FROM   verified_users<br/>        WHERE  users.id = verified_users.user_id)<br/>FROM   users<br/></span></pre><p id="1880" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在相关子查询中，查询是逐行执行的。SQL 引擎首先执行外部查询，然后执行内部查询。执行顺序允许内部查询引用外部查询中的列值。</p><p id="dc5d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">当内部查询不引用外部查询列时(换句话说，当它不是相关子查询时)，查询不会逐行执行。<strong class="lq ir">相反，SQL 引擎首先执行内部查询，然后执行外部查询。</strong></p><p id="58a2" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><em class="mz">*注意，如果在上面的示例中，verified_users 包含重复的 user _ ids，查询将会失败。</em></p><h1 id="e6df" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">在 FROM 中使用子查询</h1><p id="98a4" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">子查询可以在 FROM 子句中用作查询选择的主结果集，也可以用作连接到标准表的结果集。</p><p id="ca21" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">让我们看一下第一个场景的简单版本。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="78cb" class="mu kx iq mq b gy mv mw l mx my">SELECT first_name,<br/>       last_name<br/>FROM   (SELECT first_name,<br/>               last_name,<br/>               state<br/>        FROM   users<br/>        WHERE  state = 'Kansas') kansas</span></pre><p id="2c7d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">请注意，在本例中，子查询被赋予了一个别名(kansas)。这是因为 FROM 子句中的所有子查询都必须有别名。</p><p id="c565" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这里是一个在连接中使用的子查询的例子。这里，子查询必须有别名。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="628e" class="mu kx iq mq b gy mv mw l mx my">SELECT first_name,<br/>       last_name,<br/>       verification_status<br/>FROM   users<br/>       INNER JOIN (SELECT verification_status,<br/>                          user_id<br/>                   FROM   verified_users<br/>                   WHERE  verification_status = 'true') v<br/>               ON users.id = v.user_id</span></pre><h1 id="937b" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">在 WHERE 中使用子查询</h1><p id="311c" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">本节介绍如何在 WHERE 子句中使用子查询。这些查询有两种类型:单行和多行。</p><h2 id="93c9" class="mu kx iq bd ky na nb dn lc nc nd dp lg lx ne nf li mb ng nh lk mf ni nj lm nk bi translated">单行子查询</h2><p id="7541" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在本文开头的基本示例中，我们在 WHERE 子句中使用了一个返回单个值的子查询。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="2a0b" class="mu kx iq mq b gy mv mw l mx my">SELECT first_name,<br/>       last_name,<br/>       age<br/>FROM   users<br/>WHERE  age &gt; (SELECT <em class="mz">Avg</em>(age)<br/>              FROM   users)</span></pre><p id="444f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">下面是一个更复杂的示例，其中子查询本身是一个复杂的查询，用于确定雇员最近的奖金支出，然后选择所有更高的奖金支出。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="510b" class="mu kx iq mq b gy mv mw l mx my">SELECT user_id,<br/>       bonus_amount<br/>FROM   bonus_table<br/>WHERE  bonus_amount &gt; (SELECT bonus_amount<br/>                FROM   (SELECT user_id,<br/>                               bonus_amount,<br/>                               <strong class="mq ir">Row_number</strong>()<br/>                                 OVER(<br/>                                   partition BY user_id<br/>                                   ORDER BY date DESC) AS last_bonus<br/>                        FROM   bonus_table<br/>                        WHERE  user_id = 123) lb<br/>                WHERE  last_bonus = 1)</span></pre><p id="36cd" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这个例子演示了子查询可以像普通查询一样复杂和健壮(并且包括它们自己的子查询！).当您需要基于从复杂查询返回的单个值过滤数据<strong class="lq ir">时，子查询通常是首选方法。</strong></p><p id="5ecd" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">此外，这被称为单行子查询。</strong></p><p id="e351" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">关联时，单行子查询可以近似内部连接。例如，如果我们有一个包含所有用户的用户表和一个只包含电子邮件已验证的用户的 verified_users 表，下面的代码将模拟它们之间的内部连接。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="fd79" class="mu kx iq mq b gy mv mw l mx my">SELECT first_name,<br/>       last_name<br/>FROM   users<br/>WHERE  users.id = (SELECT user_id<br/>                         FROM   verified_users<br/>                         WHERE  users.id = user_id)</span></pre><p id="604a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><em class="mz">*注意，触发关联的是内部查询引用外部查询列。</em></p><p id="baae" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">下面是相关单行子查询的另一个示例。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="c653" class="mu kx iq mq b gy mv mw l mx my">SELECT first_name,<br/>       last_name,<br/>       state,<br/>       age<br/>FROM   user_states AS outer_states<br/>WHERE  age = (SELECT <em class="mz">Min</em>(age)<br/>              FROM   user_states AS inner_states<br/>              WHERE  inner_states.state = outer_states.state<br/>              GROUP  BY inner_states.state)</span></pre><p id="3cae" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">该查询选择年龄等于其所在州的最小年龄的用户列表。</p><p id="325e" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><em class="mz">*注意，该查询需要别名才能执行。</em></p><h2 id="fdf8" class="mu kx iq bd ky na nb dn lc nc nd dp lg lx ne nf li mb ng nh lk mf ni nj lm nk bi translated">多行子查询</h2><p id="8e89" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">WHERE 子句中使用的返回多行的子查询称为多行子查询。必须将多行子查询与集合比较运算符(in、ALL、ANY)结合使用。<strong class="lq ir">此外，像单行子查询一样，多行子查询必须只返回一列。</strong></p><p id="c54d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">如果您不熟悉这些集合运算符，请务必记住，每个运算符都用于确定一行是否包含在查询的输出中。</p><p id="16f0" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">使用 IN 运算符</strong></p><p id="44b2" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">IN 运算符确定一个值是否存在于列值列表中。在下面的例子中，我们返回一个所有用户的列表，这些用户的年龄出现在居住在俄亥俄州的所有用户的年龄列表中。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="7ba3" class="mu kx iq mq b gy mv mw l mx my">SELECT first_name,<br/>       last_name,<br/>       age<br/>FROM   user_states<br/>WHERE  age IN (SELECT age<br/>               FROM   user_states<br/>               WHERE  state = 'Ohio')</span></pre><p id="f5fa" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">使用 ALL 运算符</strong></p><p id="de75" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">ALL 运算符确定单个行值与结果集的每个行值之间的比较是否一致为真。如果比较一致为真，则包括与比较左侧关联的行。</p><p id="11d7" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在下面的示例中，我们返回一个用户列表，这些用户的年龄大于居住在堪萨斯州的每个用户的年龄。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="df18" class="mu kx iq mq b gy mv mw l mx my">SELECT first_name,<br/>       last_name,<br/>       age<br/>FROM   user_states<br/>WHERE  age &gt; ALL (SELECT age<br/>               FROM   user_states<br/>               WHERE  state = 'Kansas')</span></pre><p id="0275" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">使用任意运算符</strong></p><p id="1476" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">ANY 运算符确定单个行值与结果集的每个行值之间的比较是否至少有一次为真。如果比较至少有一次为真，则包括与比较左侧关联的行。</p><p id="5b33" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在下面的示例中，我们返回年龄大于各州用户最大年龄的用户列表。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="4b9f" class="mu kx iq mq b gy mv mw l mx my">SELECT first_name,<br/>       last_name,<br/>       state,<br/>       age<br/>FROM   user_states<br/>WHERE  age &gt; ANY (SELECT <em class="mz">Max</em>(age)<br/>                  FROM   user_states<br/>                  GROUP  BY state)</span></pre><h2 id="93e9" class="mu kx iq bd ky na nb dn lc nc nd dp lg lx ne nf li mb ng nh lk mf ni nj lm nk bi translated">概括我们所学的内容</h2><p id="d4a0" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">子查询是 SQL 中比较令人困惑的主题之一。如果你感到迷茫，请记住以下亮点:</p><ol class=""><li id="c799" class="nl nm iq lq b lr mk lu ml lx nn mb no mf np mj nq nr ns nt bi translated">所有子查询都必须用括号括起来🎯</li><li id="dbde" class="nl nm iq lq b lr nu lu nv lx nw mb nx mf ny mj nq nr ns nt bi translated">SELECT 子句中使用的子查询必须返回单个值🎯</li><li id="a0a2" class="nl nm iq lq b lr nu lu nv lx nw mb nx mf ny mj nq nr ns nt bi translated">FROM 子句中使用的子查询必须有别名🎯</li><li id="e138" class="nl nm iq lq b lr nu lu nv lx nw mb nx mf ny mj nq nr ns nt bi translated">如果 WHERE 子句中的子查询返回多行，则它必须使用集合比较运算符(in、ALL、ANY)🎯</li><li id="3414" class="nl nm iq lq b lr nu lu nv lx nw mb nx mf ny mj nq nr ns nt bi translated">引用外部查询列的子查询是相关的🎯</li></ol><p id="792b" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">如果您想阅读子查询的一些不同解释，请尝试以下文章:</p><ul class=""><li id="ec7c" class="nl nm iq lq b lr mk lu ml lx nn mb no mf np mj nz nr ns nt bi translated"><a class="ae kv" href="https://www.w3resource.com/sql/subqueries/understanding-sql-subqueries.php" rel="noopener ugc nofollow" target="_blank"> W3 资源—什么是子查询</a></li><li id="f5e4" class="nl nm iq lq b lr nu lu nv lx nw mb nx mf ny mj nz nr ns nt bi translated"><a class="ae kv" href="https://www.w3resource.com/sql/subqueries/multiplee-row-column-subqueries.php" rel="noopener ugc nofollow" target="_blank"> W3 资源多行子查询</a></li><li id="c3de" class="nl nm iq lq b lr nu lu nv lx nw mb nx mf ny mj nz nr ns nt bi translated"><a class="ae kv" href="https://www.sqlservertutorial.net/sql-server-basics/sql-server-correlated-subquery/" rel="noopener ugc nofollow" target="_blank"> SQL Server 相关子查询</a></li><li id="bed9" class="nl nm iq lq b lr nu lu nv lx nw mb nx mf ny mj nz nr ns nt bi translated"><a class="ae kv" href="https://mode.com/sql-tutorial/sql-sub-queries/" rel="noopener ugc nofollow" target="_blank">模式—带有练习题的子查询概述</a></li></ul></div><div class="ab cl oa ob hu oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="ij ik il im in"><p id="b4f6" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">感谢阅读。我希望这篇文章对你有所帮助。如果你这样做了，一定要给我一个关注更多的 SQL 内容！</p></div></div>    
</body>
</html>