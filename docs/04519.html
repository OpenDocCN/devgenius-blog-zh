<html>
<head>
<title>Regular Expressions Cheatsheet</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">正则表达式备忘单</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/regular-expressions-cheatsheet-e6b666f5a5c7?source=collection_archive---------8-----------------------#2021-03-27">https://blog.devgenius.io/regular-expressions-cheatsheet-e6b666f5a5c7?source=collection_archive---------8-----------------------#2021-03-27</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/c76fca4e552d569bd30d904cb5231271.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KKq9cF16O2rCnoZ34KWPVQ.jpeg"/></div></div></figure><div class=""/><p id="1fad" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">正则表达式是大多数开发人员害怕的最可怕的话题之一。事实上，我也是其中之一，但我决定更努力地学习这个话题。所以，我把我所有的学习成果都加上了例子，让这个话题容易理解。</p><p id="022b" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们开始吧。</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="704f" class="lc ld iy ky b gy le lf l lg lh">const regex = //;<br/><em class="li">or</em><br/>const regex = <!-- -->new RegExp('');<br/>---<br/>/&lt;expression&gt;/&lt;flags&gt;</span></pre><p id="07ae" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这些是使用 regex 所需的 JS 方法。</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="7a9d" class="lc ld iy ky b gy le lf l lg lh">match(); // returns matching strings in an array<br/>test(); // returns true or false</span></pre><p id="3e4e" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们用一个例子来理解这个概念。</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="5803" class="lc ld iy ky b gy le lf l lg lh">const str = 'hello world';<br/>const regex = /hello/;</span><span id="3b3b" class="lc ld iy ky b gy lj lf l lg lh">console.log(regex.test(str)); //true<br/>console.log(str.match(regex)); //["hello"]</span></pre><p id="ad06" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">match 函数用给定的正则表达式检查字符串，并返回第一个匹配项。如果字符串匹配以下表达式，测试函数返回 true，反之亦然。</p><h1 id="15ed" class="lk ld iy bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">旗帜</h1><p id="1fb6" class="pw-post-body-paragraph jv jw iy jx b jy mh ka kb kc mi ke kf kg mj ki kj kk mk km kn ko ml kq kr ks ig bi translated">如果我们将上面的字符串更改为“hello world hello ”,它仍然会返回一个“hello ”,因为它会返回第一个出现的内容。为了匹配每一次出现，我们必须给出与正则表达式模式全局匹配的标志“g”。</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="5d73" class="lc ld iy ky b gy le lf l lg lh"><em class="li">// global<br/></em>const str = "hello world hello";<br/>const regex = /hello/g;<br/>console.log(str.match(regex)); //["hello", "hello"]</span></pre><p id="5144" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果我们将字符串改为“hello world Hello ”, match 函数将返回一个 Hello，因为 regex 区分大小写。通过启用“I”标志，我们可以匹配字符串“hello”的每一次出现，而不考虑它们的大小写。</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="70b2" class="lc ld iy ky b gy le lf l lg lh"><em class="li">// case insensitive<br/></em>const str = "hello world Hello";<br/>const regex = /hello/gi;<br/>console.log(str.match(regex)); //["hello", "Hello"]</span></pre><p id="aa60" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们将字符串改为“hello world \nHello”。如果我们想检查字符串是否以单词“hello”开始，我们必须在表达式前给一个^(cap。</p><blockquote class="mm mn mo"><p id="1510" class="jv jw li jx b jy jz ka kb kc kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ks ig bi translated"><strong class="jx iz">^用于匹配输入的开始。</strong></p></blockquote><p id="0dec" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以我们需要改变这个表达式，比如/^hello/gi，即使我们使用了“I”标志，它也会返回一个 hello。我们必须使用“m”标志来匹配多行输入中的表达式，因为我们在字符串中添加了“\n”。</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="ddf7" class="lc ld iy ky b gy le lf l lg lh"><em class="li">// mutiline<br/></em>const str = "hello world \nHello";<br/>const regex = /<em class="li">^</em>hello/gim;<br/>console.log(str.match(regex)); //["hello", "Hello"]</span></pre><p id="acae" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">类似地，如果我们想要匹配输入的结尾，我们必须在表达式的结尾给出$(美元)。</p><blockquote class="mm mn mo"><p id="4eb6" class="jv jw li jx b jy jz ka kb kc kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ks ig bi translated"><strong class="jx iz">$用于匹配输入的结束。</strong></p></blockquote><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="d97a" class="lc ld iy ky b gy le lf l lg lh">const str = "hello world \nHello World";<br/>const regex = /<em class="li">world$</em>/gim;<br/>console.log(str.match(regex)); //["world", "World"]</span></pre><h1 id="18d3" class="lk ld iy bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">字符类别</h1><p id="fb51" class="pw-post-body-paragraph jv jw iy jx b jy mh ka kb kc mi ke kf kg mj ki kj kk mk km kn ko ml kq kr ks ig bi translated">\d =匹配数字</p><p id="50d6" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">\D =匹配非数字</p><p id="2fdc" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">\w =匹配单词</p><p id="a9b5" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">\W =匹配非单词</p><p id="916c" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">\s =匹配空格</p><p id="5e5d" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">\S =匹配非空格字符</p><p id="412f" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下面提到的例子有助于更清楚地理解这个概念。</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="693b" class="lc ld iy ky b gy le lf l lg lh">"123 hello %".match(/\d/); //matches "123"<br/>"123 hello %".match(/\D/); //matches " hello %"<br/>"123 hello %".match(/\w/); //matches "123" and "hello"<br/>"123 hello %".match(/\W/); //matches " "," " and "%"<br/>"123 hello %".match(/\s/); //matches " " and " "<br/>"123 hello %".match(/\S/); //matches "123", "hello" and "%"</span></pre><blockquote class="mm mn mo"><p id="47d1" class="jv jw li jx b jy jz ka kb kc kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ks ig bi translated"><strong class="jx iz">美国。(点)运算符匹配除行结束符</strong>之外的任何单个字符</p></blockquote><p id="1d5b" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">比如我们给 regex /t.n/g .它匹配“tin”、“t5n”、“t@n”、“t n”。</p><blockquote class="mm mn mo"><p id="fc1b" class="jv jw li jx b jy jz ka kb kc kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ks ig bi translated"><strong class="jx iz">/(反斜杠)运算符用于转义字符。</strong></p></blockquote><p id="6419" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">例如，如果我们想要匹配字符串“t\n ”,那么我们不能给 regex/t\n/g，因为它匹配 t 和 newline，而不是 t \ n。在这种情况下，我们必须使用转义字符，如果我们在反斜杠前面使用它，那么它将被视为一个字符，而不是一个运算符，那么表达式将类似于/t\\n/g。</p><h1 id="4504" class="lk ld iy bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">组和范围</h1><p id="2e01" class="pw-post-body-paragraph jv jw iy jx b jy mh ka kb kc mi ke kf kg mj ki kj kk mk km kn ko ml kq kr ks ig bi translated">在'<strong class="jx iz"> ( </strong>)和'<strong class="jx iz"> ) </strong> ' <strong class="jx iz">之间提到组。</strong></p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="17aa" class="lc ld iy ky b gy le lf l lg lh">"123 hello %".match(/(123|hello)/g); //matches "123" and "hello"</span></pre><blockquote class="mm mn mo"><p id="8f2f" class="jv jw li jx b jy jz ka kb kc kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ks ig bi translated"><strong class="jx iz">|(管道)运算符用于“或”条件。</strong></p></blockquote><p id="ad45" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">范围在'<strong class="jx iz"> [ </strong>'和'<strong class="jx iz">]【T19]'之间，用连字符(<strong class="jx iz"> - </strong>)分隔。</strong></p><p id="dc4b" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">例如，[0–9]匹配所有数字，[^0-9]匹配除数字以外的任何数字。</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="6325" class="lc ld iy ky b gy le lf l lg lh">/\d/g = /[0–9]/g<br/>/\D/g = /[^0–9]/g<br/>/\w/g = /[a-zA-Z0-9_]/g<br/>/\w/g = /[^a-zA-Z0-9_]/g<br/>/\s/g = / /g<br/>/\S/g = /[^ ]/g</span></pre><blockquote class="mm mn mo"><p id="f36b" class="jv jw li jx b jy jz ka kb kc kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ks ig bi translated">在上面的例子中你可能会怀疑<strong class="jx iz">“为什么我们需要/[^ ]/g 来匹配非空格字符我们不能给/^ /g 吗？”</strong></p><p id="1121" class="jv jw li jx b jy jz ka kb kc kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ks ig bi translated"><strong class="jx iz">回答:不会，</strong>因为/^ /g 读的是“匹配输入以空格开始”。<strong class="jx iz"> ^ </strong>只有在<strong class="jx iz"> [] </strong>内部使用时才作为 not 运算符。</p></blockquote><h1 id="9f2c" class="lk ld iy bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">量词</h1><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="7911" class="lc ld iy ky b gy le lf l lg lh">"a aa".match(/a{2}/g); //matches the letter 'a' sequentially occurring two times<br/>"a aa aaa".match(/a{2,}/g); //matches the letter 'a' sequentially occurring 2 times and greater<br/>"a aa aaa aaaa".match(/a{2,4}/g); //matches the letter 'a' sequentially occurring 2 to 3 times</span></pre><p id="56be" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="li">一个</em>？=与前面的项目“a”匹配 0 或 1 次。</p><p id="7a65" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="li"> a </em> + =匹配前一项“a”1 次或多次。</p><p id="d160" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="li"> a </em> * =与前一项“a”匹配 0 次或更多次。</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="f190" class="lc ld iy ky b gy le lf l lg lh">/(hello)? %/g; <em class="li">// matches both " %" and "hello %"</em></span><span id="3118" class="lc ld iy ky b gy lj lf l lg lh">/(hello)+ %/g; <em class="li">// matches both "hello %","hellohello %", "hellohellohello %", etc...</em></span><span id="92c0" class="lc ld iy ky b gy lj lf l lg lh">/(hello)* %/g; <em class="li">// matches both " %", "hello %","hellohello %", "hellohellohello %", etc...</em></span></pre><blockquote class="mm mn mo"><p id="15b5" class="jv jw li jx b jy jz ka kb kc kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ks ig bi translated"><strong class="jx iz">简单来说，“*”是“+”和“？”的结合</strong></p></blockquote><h1 id="9011" class="lk ld iy bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">向前看和向后看</h1><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="dd1f" class="lc ld iy ky b gy le lf l lg lh"><strong class="ky iz">positive lookahead</strong><br/>/a(?=b)/g; matches a only if it is followed by b</span><span id="90cc" class="lc ld iy ky b gy lj lf l lg lh"><strong class="ky iz">negative lookahead</strong><br/>/a(?!b)/g; matches a only if it is not followed by b</span><span id="4eb3" class="lc ld iy ky b gy lj lf l lg lh"><strong class="ky iz">postive lookbehind</strong><br/>/(?&lt;=b)a/g; matches a only if it is preceded by b</span><span id="617b" class="lc ld iy ky b gy lj lf l lg lh"><strong class="ky iz">negative lookbehind</strong><br/>/(?&lt;!b)a/g; matches a only if it is not preceded by b</span></pre><p id="1f7f" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在上面的前瞻示例中，条件是在“(”和“)”之间提到的。如果任何字符串满足条件，那么匹配函数匹配前面的字符。</p><p id="f4c4" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">同样，对于后面的例子。如果任何字符串满足条件，那么匹配函数匹配以下字符。为了区分后视和前视，在后视中，我们使用“</p><p id="41dd" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">就这样，我们涵盖了正则表达式中的大部分主题。下次在任何地方看到正则表达式模式时，不要害怕。回到本文来修改概念，然后尝试理解模式。</p></div></div>    
</body>
</html>