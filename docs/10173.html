<html>
<head>
<title>How to Troubleshoot Log Rotation Issue</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何解决日志轮换问题</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-to-troubleshoot-log-rotation-issue-954a3be4d454?source=collection_archive---------10-----------------------#2022-10-12">https://blog.devgenius.io/how-to-troubleshoot-log-rotation-issue-954a3be4d454?source=collection_archive---------10-----------------------#2022-10-12</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="7ceb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当涉及到日志循环时，其中一个问题是日志文件看起来并不像配置文件所说的那样循环。它通常以一个大的日志文件结束。预期的日志文件应该相对较小。在本文中，我将带您完成日志轮换。</p><p id="74a9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果我们有一个生产就绪的 Django 应用程序，我们主要对三种日志轮换感兴趣。一个是应用程序日志。第二个是服务器日志。根据服务器的不同，可能是 uWSGI、Gunicorn 等。在本文中，我将使用 uWSGI 作为一个例子。第三个是默认安装在 Ubuntu 上的<a class="ae ki" href="https://manpages.ubuntu.com/manpages/xenial/man8/logrotate.8.html" rel="noopener ugc nofollow" target="_blank"> logrotate 实用程序</a>。</p></div><div class="ab cl kj kk hr kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="ig ih ii ij ik"><h1 id="0c1c" class="kq kr in bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">示例项目</h1><p id="b87a" class="pw-post-body-paragraph jk jl in jm b jn lo jp jq jr lp jt ju jv lq jx jy jz lr kb kc kd ls kf kg kh ig bi translated">在本文中，我将使用一个示例项目来演示。我把它上传到了我的 Github 上。如果您感兴趣，请查看下面的 Git 资源库。</p><div class="lt lu gp gr lv lw"><a href="https://github.com/slow999/DjangoAndLogrotate" rel="noopener  ugc nofollow" target="_blank"><div class="lx ab fo"><div class="ly ab lz cl cj ma"><h2 class="bd io gy z fp mb fr fs mc fu fw im bi translated">GitHub-slow 999/DjangoAndLogrotate</h2><div class="md l"><h3 class="bd b gy z fp mb fr fs mc fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="me l"><p class="bd b dl z fp mb fr fs mc fu fw dk translated">github.com</p></div></div><div class="mf l"><div class="mg l mh mi mj mf mk ml lw"/></div></div></a></div></div><div class="ab cl kj kk hr kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="ig ih ii ij ik"><h1 id="1236" class="kq kr in bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">日志旋转 101</h1><p id="dedc" class="pw-post-body-paragraph jk jl in jm b jn lo jp jq jr lp jt ju jv lq jx jy jz lr kb kc kd ls kf kg kh ig bi translated">日志轮转是如何工作的？有几种方法。最常见的方法是，当触发循环时，它会删除最旧的副本，按照下一个序列号将其余副本和当前副本一起重命名，并创建一个新的日志文件。例如，当前日志文件是<strong class="jm io"> mysite.log </strong>。在第一轮之后，文件列表将会是<strong class="jm io"> mysite.log </strong>和<strong class="jm io"> mysite.log.1 </strong>。第二次循环后，文件列表将为<strong class="jm io"> mysite.log、mysite.log.1 </strong>和<strong class="jm io"> mysite.log.2 </strong>。假设我们将拷贝数设为 2。因此，在第三次循环之后，文件列表仍然是<strong class="jm io"> mysite.log、mysite.log.1、</strong>和<strong class="jm io"> mysite.log.2 </strong>。</p><p id="7fc9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里我们要稍微了解一下<a class="ae ki" href="https://en.wikipedia.org/wiki/Inode" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> inode </strong> </a>。随着日志轮转的运行，一个新的<strong class="jm io"> mysite.log </strong>被创建并与一个新的 inode 相关联。如果文件被删除，其信息节点将不会被回收。因此，我们可以使用 inode 来验证日志轮转是否正常运行。接下来，我将使用我们的示例项目向您介绍这三种类型的日志轮换。</p><h1 id="709b" class="kq kr in bd ks kt mm kv kw kx mn kz la lb mo ld le lf mp lh li lj mq ll lm ln bi translated">Django/Python 日志旋转</h1><p id="d9eb" class="pw-post-body-paragraph jk jl in jm b jn lo jp jq jr lp jt ju jv lq jx jy jz lr kb kc kd ls kf kg kh ig bi translated">要启动项目，请键入如下命令:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="1ed1" class="na kr in mw b gy nb nc l nd ne">docker compose up -d</span></pre><p id="c7d3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们期望控制台中的输出如下:</p><figure class="mr ms mt mu gt ng gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi nf"><img src="../Images/b04d717987213e9e4538393b5bc94a4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3H1XJSHGt9CFGqcHTr5MLg.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">合成输出</figcaption></figure><p id="3d99" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在浏览器中打开<a class="ae ki" href="http://127.0.0.1:8000/polls/" rel="noopener ugc nofollow" target="_blank">http://127 . 0 . 0 . 1:8000/polls/</a>。我们将期待如下页面。这意味着我们的项目正在运行。</p><figure class="mr ms mt mu gt ng gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi nf"><img src="../Images/038086e834b3a43a654d894ca78a2b6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mTYOy4E-Q3tvmLtUOOAaTg.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">/polls/ endpoint 的网页</figcaption></figure><p id="5284" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">要显示正在运行的容器，请按如下方式键入命令:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="ae0e" class="na kr in mw b gy nb nc l nd ne">docker ps</span></pre><p id="44cb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们预计输出如下。让我们记下用黄色突出显示的容器 id。我的情况是 0d56a6ed21f0。</p><figure class="mr ms mt mu gt ng gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi nf"><img src="../Images/34cf679c1d1f94d02be10cd3de0a51a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2WzXTx8uvElqXz8cHjyT3w.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">Docker 运行容器的控制台输出</figcaption></figure><p id="14de" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">要进入正在运行的容器，请键入如下命令:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="541a" class="na kr in mw b gy nb nc l nd ne">docker exec -it 0d56a6ed21f0 sh</span></pre><p id="a3de" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们期望得到以下输出。这意味着我们在集装箱里。</p><figure class="mr ms mt mu gt ng gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi nq"><img src="../Images/acc57314d6aba4d03ba341ff9cd799c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NSg5dK2Ay8B_5rwL_Co6wQ.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">容器的控制台输出</figcaption></figure><p id="6df9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们通过键入如下命令来列出<strong class="jm io">代码</strong>目录中的内容:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="2d68" class="na kr in mw b gy nb nc l nd ne">ls -li</span></pre><p id="69d1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们期望得到以下输出。请注意，第一列代表 inode。<strong class="jm io"> mysite.log </strong>的 inode 是 43132。<strong class="jm io"> mysite.log </strong>由 Django 应用程序生成。</p><figure class="mr ms mt mu gt ng gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi nf"><img src="../Images/f60b3281e4940e35288e56cbeae12557.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d1KCPQsK3iUcGcg2A7XcYA.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">列出/code 目录中的文件和目录</figcaption></figure><p id="7cfa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">应用程序日志的配置在<strong class="jm io"> mysite/settings.py </strong>文件中设置。原木旋转部分如下。这意味着如果文件大小超过 1KB，它将调用日志轮换。Django 会保留日志文件的 2 个副本。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="852d" class="na kr in mw b gy nb nc l nd ne">logging.config.dictConfig({<br/>    …<br/>    'handlers': {<br/>        'logfile': {<br/>            'level': 'DEBUG',<br/>            'class': 'logging.handlers.RotatingFileHandler',<br/>            'filename': 'mysite.log',<br/>            'maxBytes':  1024 * 1,  # 1KB<br/>            'backupCount': 2,<br/>            'formatter': 'standard',<br/>        },<br/>        'console': {<br/>            'level': 'DEBUG',<br/>            'class': 'logging.StreamHandler',<br/>            'formatter': 'standard',<br/>        },<br/>    },<br/>   …<br/>})</span></pre><p id="5e7a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们来刷新一下<a class="ae ki" href="http://127.0.0.1:8000/polls/" rel="noopener ugc nofollow" target="_blank">http://127 . 0 . 0 . 1:8000/polls/</a>页面。再次列出<strong class="jm io">代码</strong>目录。我们应该期待以下输出。根据 inode，我们知道 inode 为 43132 的文件已经从<strong class="jm io"> mysite.log </strong>重命名为<strong class="jm io"> mysite.log.1 </strong>。创建了一个新的日志文件，其 inode 为 42870。此外，请注意两个日志文件的修改时间是相同的。</p><figure class="mr ms mt mu gt ng gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi nf"><img src="../Images/272a195a50c89630fe82fd410762bb30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tRZtjy9Jdn4iKGChgW1mPg.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">第一次刷新后，列出/code 目录中的文件和目录</figcaption></figure><p id="54d8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们再刷新一下<a class="ae ki" href="http://127.0.0.1:8000/polls/" rel="noopener ugc nofollow" target="_blank">http://127 . 0 . 0 . 1:8000/polls/</a>页面。继续观察日志文件的变化。第三次刷新的输出如下:</p><figure class="mr ms mt mu gt ng gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi nf"><img src="../Images/a9ed10c6af262d8f9933782c9df9f739.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ho0ONe1Aa1uSkMSlTholPw.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">第二次刷新后，列出/code 目录中的文件和目录</figcaption></figure><p id="fb93" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">第四次刷新的输出如下。inode 为 43132 的日志文件被删除。</p><figure class="mr ms mt mu gt ng gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi nf"><img src="../Images/a98286c3adb35e0aa7470047997b5746.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8Imfwe0jC1OAd0TKXUVueQ.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">在第四次刷新后，列出/code 目录中的文件和目录</figcaption></figure><p id="6d4e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们呆在控制台里。接下来，我们将深入了解 uWSGI。</p><h1 id="7fb8" class="kq kr in bd ks kt mm kv kw kx mn kz la lb mo ld le lf mp lh li lj mq ll lm ln bi translated">uWSGI 日志旋转</h1><p id="aefb" class="pw-post-body-paragraph jk jl in jm b jn lo jp jq jr lp jt ju jv lq jx jy jz lr kb kc kd ls kf kg kh ig bi translated">在我们的示例项目中，uWSGI 日志旋转设置在<strong class="jm io"> mysite.uwsgi.ini </strong>文件中。它看起来如下。它表明，如果文件大小超过 2048 字节，它将旋转。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="d8ab" class="na kr in mw b gy nb nc l nd ne">[uwsgi]</span><span id="b395" class="na kr in mw b gy nr nc l nd ne">socket = /tmp/uwsgi/mysite.sock<br/>module = mysite.wsgi<br/>master = true<br/>processes = 2<br/>chmod-socket = 666<br/>logger = file:logfile=/tmp/uwsgi.log,maxsize=2048<br/>vacuum = true</span></pre><p id="f8aa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">要列出 uWSGI 日志，请键入以下命令。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="c257" class="na kr in mw b gy nb nc l nd ne">ls -li /tmp/</span></pre><p id="250f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">刷新网页几次。输出的快照如下。请注意，索引节点为 42871 的日志文件已被重命名，而其余副本的文件名保持不变。由于对副本的最大数量没有限制，它会一直生成日志，直到磁盘满为止。如果你知道如何设置最大份数，请留下你的评论。非常感谢。在这种情况下，我们可以创建一个 Cron 作业来清理旧的副本。</p><figure class="mr ms mt mu gt ng gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi nf"><img src="../Images/41c4beac45ca5dfe9111459e35818126.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*phGXAR0lln9DHzvpYKuteA.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">/tmp/目录中的文件和目录列表</figcaption></figure><h1 id="8798" class="kq kr in bd ks kt mm kv kw kx mn kz la lb mo ld le lf mp lh li lj mq ll lm ln bi translated">Linux 日志旋转实用程序</h1><p id="50d4" class="pw-post-body-paragraph jk jl in jm b jn lo jp jq jr lp jt ju jv lq jx jy jz lr kb kc kd ls kf kg kh ig bi translated">Logrotate 是一个系统实用程序，允许自动旋转、压缩、删除和邮寄日志文件。配置的快照如下。这意味着 logrotate 工具每天运行，如果日志文件丢失，它不会写入错误消息，保留 14 个旧的日志文件，压缩循环的文件，并且 prerotate/postrotate 脚本只运行一次。</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="9907" class="na kr in mw b gy nb nc l nd ne">/var/log/uwsgi/*.log {<br/>    daily<br/>    missingok<br/>    rotate 14<br/>    compress<br/>    sharedscripts<br/>}</span></pre><p id="36e1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对于使用过非常旧版本的 uWSGI 的人来说，上面的设置可能对您来说很熟悉。我们之前提到过 uWSGI 支持基于文件大小的旋转。为什么我们需要 logrotate 实用程序来处理 uWSGI 日志文件的循环？原因是当时旧的 uWSGI 服务器不支持基于文件大小的轮换。因此，一种解决方法是使用 logrotate 作为替代方法。</p><p id="4d24" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是，上述配置有一个问题。即使文件已被重命名，uWSGI 也会继续写入同一个日志文件(同一个 inode)。要解决这个问题，我们必须在每次轮换后重新启动 uWSGI。当 uWSGI 重新启动时，它应该会生成一个新的日志文件(新的 inode)。修改后的配置如下:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="a8a2" class="na kr in mw b gy nb nc l nd ne">/var/log/uwsgi/*.log {<br/>    daily<br/>    missingok<br/>    rotate 14<br/>    compress<br/>    sharedscripts<br/>    postrotate<br/>        systemctl stop uwsgi.service &gt;/dev/null 2&gt;&amp;1<br/>        systemctl start uwsgi.service &gt;/dev/null 2&gt;&amp;1<br/>    endscript<br/>}</span></pre><h1 id="bd22" class="kq kr in bd ks kt mm kv kw kx mn kz la lb mo ld le lf mp lh li lj mq ll lm ln bi translated">结论</h1><p id="f751" class="pw-post-body-paragraph jk jl in jm b jn lo jp jq jr lp jt ju jv lq jx jy jz lr kb kc kd ls kf kg kh ig bi translated">在本文中，我们经历了三种日志轮换。它们是应用程序日志循环、服务器日志循环和系统日志循环。关于 Linux logrotate 实用程序的讨论并没有结束。因为修改后的配置有负面影响。在日志循环期间，应用程序可能会出现问题。如果企业要求应用程序全天候运行，这可能是个问题。我想让你决定。请留下评论，让我知道你的想法。感谢阅读。敬请关注。</p></div></div>    
</body>
</html>