<html>
<head>
<title>Kafka schema registry</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kafka模式注册表</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/kafka-schema-registry-abea44b88714?source=collection_archive---------4-----------------------#2021-12-26">https://blog.devgenius.io/kafka-schema-registry-abea44b88714?source=collection_archive---------4-----------------------#2021-12-26</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div class="gh gi jk"><img src="../Images/1bdd9450c21b18d701a83d0e3d8bb837.png" data-original-src="https://miro.medium.com/v2/resize:fit:1328/format:webp/1*7mq9G32EtqRfWa-Broc5uw.png"/></div></figure><p id="8e4d" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">你刚开始工作/学习卡夫卡吗？偶然发现模式注册表，但不知道它到底是什么？你找对了地方。今天我们将探索Kafka schema registry是什么，在registry中创建和存储我们的第一个Avro schema，并生成和使用一些数据。唷！这么多事要做。我们先来了解一下什么是模式注册中心。</p><p id="e2a0" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">顾名思义，模式注册与我们数据的模式有关。如果你猜对了，你已经了解了90%的模式注册表。它确实存储了我们的数据的模式，Kafka生产者和消费者都使用它来理解他们在生产或阅读数据时数据是什么样子的。但是最大的问题是为什么我们需要一个模式注册中心？当我们使用Avro等模式时，生产者和消费者都需要知道数据的模式，因此需要有一个他们都可以访问的地方。它可以是文件系统，也可以是RESTful层，比如模式注册表。添加RESTful层而不是使用文件系统的好处是，正如您已经猜到的，是可伸缩性。</p><p id="e660" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">那么，如果数据不是作为文件系统的一部分存储的，那么它是如何存储的呢？又一个好问题。Schema registry使用Kafka作为其后端存储。所有的数据，如模式、版本、元数据等都作为日志存储在Kafka主题' _schemas '中。说到教程部分，老实说，我觉得更有趣。:p</p><p id="5970" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">出于本教程的目的，我们将使用一个融合的本地平台，该平台为我们提供了启动所有Kafka服务(包括模式注册)的功能。从这里下载软件<a class="ae kp" href="https://www.confluent.io/get-started-v2/?product=software" rel="noopener ugc nofollow" target="_blank">https://www.confluent.io/get-started-v2/?product=software</a>，你只需要提供你的电子邮件地址就可以了。</p><p id="e2fa" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">解压缩下载的文件</p><pre class="kq kr ks kt gt ku kv kw kx aw ky bi"><span id="f05a" class="kz la in kv b gy lb lc l ld le">tar -xvf <em class="lf">FILENAME</em></span></pre><p id="6076" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">设置一些环境变量，最好在。巴沙尔或或。长期运行的配置文件。</p><pre class="kq kr ks kt gt ku kv kw kx aw ky bi"><span id="296a" class="kz la in kv b gy lb lc l ld le">export CONFLUENT_HOME<strong class="kv io">=&lt;</strong>path<strong class="kv io">-</strong>to<strong class="kv io">-</strong>confluent<strong class="kv io">&gt;<br/></strong>export PATH=$PATH:$CONFLUENT_HOME/bin</span></pre><p id="0e39" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">所有这些都完成后，你只需要运行下面的命令，所有的服务都会启动。瞧啊。</p><pre class="kq kr ks kt gt ku kv kw kx aw ky bi"><span id="917c" class="kz la in kv b gy lb lc l ld le">bash-3.2$ confluent local services start<br/>The local commands are intended for a single-node development environment only,<br/>NOT for production usage. <a class="ae kp" href="https://docs.confluent.io/current/cli/index.html" rel="noopener ugc nofollow" target="_blank">https://docs.confluent.io/current/cli/index.html</a><br/>Using CONFLUENT_CURRENT: /var/folders/4h/5lg7fz191g18pzl1rwvdkqlh0000gp/T/confluent.780135<br/>Starting ZooKeeper<br/>ZooKeeper is [UP]<br/>Starting Kafka<br/>Kafka is [UP]<br/>Starting Schema Registry<br/>Schema Registry is [UP]<br/>Starting Kafka REST<br/>Kafka REST is [UP]<br/>Starting Connect</span></pre><p id="3ab5" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">现在我们的服务已经启动，让我们开始快速模式注册教程。我们将存储一家冰淇淋店的交易数据。我们的模式将由字段组成:customer_name、order、cost、new _ customer[如果客户是新客户]，所选择的字段是不言自明的。我们将为我们的数据创建一个avro模式，并在其上生成一些数据，这些数据将被我们正在运行的消费者读取。</p><pre class="kq kr ks kt gt ku kv kw kx aw ky bi"><span id="5a27" class="kz la in kv b gy lb lc l ld le">bash-3.2$ cat schema1.avsc</span><span id="9b56" class="kz la in kv b gy lg lc l ld le">{<br/>“type” : “record”,<br/>“name” : “transaction_record”,<br/>“fields” : [<br/>{<br/>“name”:”customer_name”,<br/>“type”:”string”<br/>},<br/>{<br/>“name”:”order”,<br/>“type”:”string”<br/>},<br/>{<br/>“name”:”cost”,<br/>“type”:”float”<br/>},<br/>{ “name”:”new_customer”,<br/>“type”:”boolean”<br/>}<br/>]}</span></pre><p id="f0fc" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">这就是我们的模式目前的样子，正如您可以看到的，我们正在定义的每个字段都定义了类型，如string、float等。我们的生产者对作为生产者的数据一无所知，消费者也一样，除了值之外，字段的定义存储在带有模式注册中心的模式中。在模式注册中心注册我们的模式之前，我们需要做两件事。那些是什么？<br/>好吧，我们知道我们的模式注册中心在启动合流本地平台的时候已经启动了，但是它在哪里运行呢？好吧，它从localhost:8081开始，这是我们之前谈到的RESTful层。如果您访问<a class="ae kp" href="http://localhost:8081/subjects" rel="noopener ugc nofollow" target="_blank">http://localhost:8081/subjects</a>并且还没有注册一个模式，就像我们还没有注册一样，您可能会在访问url时看到一个空数组。如果您看不到任何东西，那么可以检查模式注册是否已经启动。一种方法是使用下面的命令:</p><pre class="kq kr ks kt gt ku kv kw kx aw ky bi"><span id="50d5" class="kz la in kv b gy lb lc l ld le">bash-3.2$ confluent local services status<br/>The local commands are intended for a single-node development environment only,<br/>NOT for production usage. <a class="ae kp" href="https://docs.confluent.io/current/cli/index.html" rel="noopener ugc nofollow" target="_blank">https://docs.confluent.io/current/cli/index.html</a><br/>Using CONFLUENT_CURRENT: /var/folders/4h/5lg7fz191g18pzl1rwvdkqlh0000gp/T/confluent.780135<br/>Connect is [UP]<br/>Control Center is [UP]<br/>Kafka is [UP]<br/>Kafka REST is [UP]<br/>ksqlDB Server is [UP]<br/>Schema Registry is [UP]<br/>ZooKeeper is [UP]</span></pre><p id="7eb9" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">我们忘记的第二个要点是，我们需要一个主题来存储我们的数据，模式定义我们的数据看起来像什么，模式注册表有助于存储模式，但kafka中的数据最终存储在一个主题上。让我们为自己创建一个“交易”主题。我们走吧。</p><pre class="kq kr ks kt gt ku kv kw kx aw ky bi"><span id="4a20" class="kz la in kv b gy lb lc l ld le">bash-3.2$ kafka-topics.sh — create — bootstrap-server localhost:9092 — replication-factor 1 — partitions 1 — topic transactions<br/>Created topic transactions.</span></pre><p id="047a" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">我们已经完成了主题的创建。在产生关于数据的数据之前，让我们开始我们的消费吧。</p><pre class="kq kr ks kt gt ku kv kw kx aw ky bi"><span id="d4a2" class="kz la in kv b gy lb lc l ld le">bash-3.2$ kafka-avro-console-consumer — bootstrap-server localhost:9092 — topic transactions<br/>..</span></pre><p id="55c6" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">终端没有卡顿，使用Kafka提供的avro控制台，我们已经开始监听主题为‘transactions’的传入数据。每当有关于这个主题的数据产生时，我们都会在我们的消费者控制台上看到它。让我们创建这些数据。</p><pre class="kq kr ks kt gt ku kv kw kx aw ky bi"><span id="038f" class="kz la in kv b gy lb lc l ld le">bash-3.2$ kafka-avro-console-producer — topic transactions — bootstrap-server localhost:9092 — property value.schema=”$(&lt; /Users/Archi/Downloads/kafka_2.13–3.0.0/schema1.avsc)”</span><span id="3b54" class="kz la in kv b gy lg lc l ld le">{“customer_name”:”Archita”,”order”:”kesarpista”,”cost”:60.7,”new_customer”:false}<br/>{“customer_name”:”Ritika”,”order”:”strawberry”,”cost”:30,”new_customer”:true}<br/>..</span></pre><p id="af93" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">我们从生产者那里生产了两张唱片，现在让我们看看消费者</p><pre class="kq kr ks kt gt ku kv kw kx aw ky bi"><span id="00eb" class="kz la in kv b gy lb lc l ld le">bash-3.2$ kafka-avro-console-consumer — bootstrap-server localhost:9092 — topic transactions<br/>{“customer_name”:”Archita”,”order”:”kesarpista”,”cost”:60.7,”new_customer”:false}{“customer_name”:”Ritika”,”order”:”strawberry”,”cost”:30.0,”new_customer”:true}</span></pre><p id="2b6d" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">看来我们从制作人那里拿到了所有的唱片。除非您在终端中按下ctrl+c，否则使用者和生产者可能仍处于运行状态。<br/>现在让我们来看看我们的模式注册中心，在<a class="ae kp" href="http://localhost:8081/subjects" rel="noopener ugc nofollow" target="_blank">http://localhost:8081/subjects</a>，您必须看到已经注册了一个新的subject，格式为topicname-value，在我们的例子中低于1。</p><pre class="kq kr ks kt gt ku kv kw kx aw ky bi"><span id="3556" class="kz la in kv b gy lb lc l ld le">["transactions-value"]</span></pre><p id="b906" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">如果您尝试访问这个URL:<a class="ae kp" href="http://localhost:8081/subjects/transactions-value/versions/1" rel="noopener ugc nofollow" target="_blank">http://localhost:8081/subjects/transactions-value/versions/1</a>，您将看到我们在上面创建的模式，这个模式被生产者和消费者用于序列化和反序列化。</p><pre class="kq kr ks kt gt ku kv kw kx aw ky bi"><span id="24a8" class="kz la in kv b gy lb lc l ld le">{“subject”:”transactions-value”,”version”:1,”id”:1,”schema”:”{\”type\”:\”record\”,\”name\”:\”transaction_record\”,\”fields\”:[{\”name\”:\”customer_name\”,\”type\”:\”string\”},{\”name\”:\”order\”,\”type\”:\”string\”},{\”name\”:\”cost\”,\”type\”:\”float\”},{\”name\”:\”new_customer\”,\”type\”:\”boolean\”}]}”}</span></pre><p id="076d" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">Schema registry为我们提供了模式版本化的好处，新的模式更改可以成为新版本的一部分，而不会中断使用旧版本模式的人的模式。在下一篇文章中，我们将深入探讨与模式进化相关的各种兼容性。如果你发现了这个有用的:D，别忘了鼓掌</p></div></div>    
</body>
</html>