<html>
<head>
<title>How to use Jest &amp; Supertest to Test an Express Server in TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用 Jest &amp; Supertest 在 TypeScript 中测试 Express 服务器</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-to-use-jest-supertest-to-test-an-express-server-in-typescript-ab4fc73524e3?source=collection_archive---------3-----------------------#2022-12-25">https://blog.devgenius.io/how-to-use-jest-supertest-to-test-an-express-server-in-typescript-ab4fc73524e3?source=collection_archive---------3-----------------------#2022-12-25</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="0249" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">查看我在<a class="ae kc" href="https://yumingchang1991.medium.com/technical-article-structure-on-medium-954850e1ef4d" rel="noopener">我的技术文章</a>中的所有其他帖子</h2></div><p id="560a" class="pw-post-body-paragraph kd ke in kf b kg kh jo ki kj kk jr kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">测试是一个可怕的话题，但对于初级 web 开发人员来说，绝对是一项引人注目的技能。我决定学习测试技能，这样我就能在工作面试中讲更多的故事。</p><h1 id="48df" class="kz la in bd lb lc ld le lf lg lh li lj jt lk ju ll jw lm jx ln jz lo ka lp lq bi translated">会发生什么</h1><p id="b3a9" class="pw-post-body-paragraph kd ke in kf b kg lr jo ki kj ls jr kl km lt ko kp kq lu ks kt ku lv kw kx ky ig bi translated">本文分享了如何使用 Jest 测试用 TypeScript 编写的 Express 服务器。</p><ul class=""><li id="0260" class="lw lx in kf b kg kh kj kk km ly kq lz ku ma ky mb mc md me bi translated">我们将首先获得 Jest 的一般知识，它是什么，以及 Jest 经常与其他什么库一起使用</li><li id="e5b8" class="lw lx in kf b kg mf kj mg km mh kq mi ku mj ky mb mc md me bi translated">然后，让我们配置我们的环境，以便测试文件以一种不会弄乱我们的生产代码的方式来组织</li><li id="22c1" class="lw lx in kf b kg mf kj mg km mh kq mi ku mj ky mb mc md me bi translated">然后，我们将开始构建测试文件来测试 JWT 用户认证特性</li></ul><h2 id="baa6" class="mk la in bd lb ml mm dn lf mn mo dp lj km mp mq ll kq mr ms ln ku mt mu lp mv bi translated">在继续阅读之前，要记住什么</h2><p id="65d2" class="pw-post-body-paragraph kd ke in kf b kg lr jo ki kj ls jr kl km lt ko kp kq lu ks kt ku lv kw kx ky ig bi translated">我只是另一个软件开发的新手。我将要分享的技术不仅会发生变化，而且会受到我的知识的限制。欢迎不同的意见，所以如果你有意见，请留下评论。</p></div><div class="ab cl mw mx hr my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ig ih ii ij ik"><h1 id="ea8e" class="kz la in bd lb lc nd le lf lg ne li lj jt nf ju ll jw ng jx ln jz nh ka lp lq bi translated">什么是玩笑</h1><figure class="nj nk nl nm gt nn gh gi paragraph-image"><div role="button" tabindex="0" class="no np di nq bf nr"><div class="gh gi ni"><img src="../Images/fc3d881cfca2f9a68311d41d622007b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YXjx5g1V14iPrvyKb4Xv_g.png"/></div></div><figcaption class="nu nv gj gh gi nw nx bd b be z dk translated">这张图表是由 JS 公司制作的。如果你有兴趣，可以去看看他们的调查。</figcaption></figure><p id="78ae" class="pw-post-body-paragraph kd ke in kf b kg kh jo ki kj kk jr kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">Jest 是一个基于 JavaScript 的全栈测试框架，在过去的 5 年里，它越来越受到开发人员的关注。</p><p id="bb5c" class="pw-post-body-paragraph kd ke in kf b kg kh jo ki kj kk jr kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">我说的全栈是指 Jest 可以用于</p><ol class=""><li id="da68" class="lw lx in kf b kg kh kj kk km ly kq lz ku ma ky ny mc md me bi translated">前端用户界面的快照测试</li><li id="0d2d" class="lw lx in kf b kg mf kj mg km mh kq mi ku mj ky ny mc md me bi translated">前端和后端的单元测试</li></ol><p id="c5d1" class="pw-post-body-paragraph kd ke in kf b kg kh jo ki kj kk jr kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">然而，如果我们想要模拟一个发送到我们的 express 服务器的 HTTP 请求，并查看它是如何被处理的，我们需要使用另一个库<code class="fe nz oa ob oc b">supertest</code>和<code class="fe nz oa ob oc b">Jest</code>。</p><p id="e402" class="pw-post-body-paragraph kd ke in kf b kg kh jo ki kj kk jr kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated"><code class="fe nz oa ob oc b">supertest</code>是 NodeJS 中的一个独立测试库，用于测试路由和端点。它可以模拟发送到我们的服务器端点的 HTTP 请求，看看它是如何被处理的。</p><p id="0f87" class="pw-post-body-paragraph kd ke in kf b kg kh jo ki kj kk jr kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">Jest 目前没有模拟 HTTP 请求的内置库；因此，在本文中，<code class="fe nz oa ob oc b">supertest</code>将与 Jest 一起使用。</p><h1 id="2139" class="kz la in bd lb lc ld le lf lg lh li lj jt lk ju ll jw lm jx ln jz lo ka lp lq bi translated">在 TypeScript 中设置 Jest 测试环境</h1><h2 id="3e5d" class="mk la in bd lb ml mm dn lf mn mo dp lj km mp mq ll kq mr ms ln ku mt mu lp mv bi translated">组织文件结构</h2><p id="3b30" class="pw-post-body-paragraph kd ke in kf b kg lr jo ki kj ls jr kl km lt ko kp kq lu ks kt ku lv kw kx ky ig bi translated">在 Express 服务器中，大多数时候我们想要测试的是我们安装的中间件和路由控制器是否按照预期处理请求。</p><p id="8642" class="pw-post-body-paragraph kd ke in kf b kg kh jo ki kj kk jr kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">我把我的测试文件放在我想测试的控制器旁边，而不是创建另一个<code class="fe nz oa ob oc b">tests</code>文件夹来存储所有的测试文件。好处是我可以很容易地识别哪个控制器有相关的测试文件。</p><pre class="nj nk nl nm gt od oc oe bn of og bi"><span id="8c42" class="oh la in oc b be oi oj l ok ol"># Example File Structure<br/><br/>controller<br/>    |<br/>    |--- xxxController.ts<br/>    |<br/>    |--- xxxController.test.ts<br/>    |<br/>    |--- aaaController.ts<br/>    |<br/>    |--- aaaController.test.ts</span></pre><h2 id="7841" class="mk la in bd lb ml mm dn lf mn mo dp lj km mp mq ll kq mr ms ln ku mt mu lp mv bi translated">配置 TypeScript 编译器</h2><p id="6c34" class="pw-post-body-paragraph kd ke in kf b kg lr jo ki kj ls jr kl km lt ko kp kq lu ks kt ku lv kw kx ky ig bi translated"><em class="om">* *注意:本部分分享的内容可能不符合您的要求** </em></p><p id="6c95" class="pw-post-body-paragraph kd ke in kf b kg kh jo ki kj kk jr kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">这个项目通过持续交付部署到 AWS。当 GitHub repo 发生变化时，typescript 的构建过程会自动触发。构建过程完成后，它会自动将编译后的 JavaScript 推送到适当的 AWS EC2 实例。<br/>(我写过一篇文章分享<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/3-steps-to-deploy-typescript-to-aws-elastic-beanstalk-with-continuous-delivery-611bc7ecf15c"> <em class="om">如何分 3 步把 TypeScript 部署到 AWS</em></a>)</p><p id="9b46" class="pw-post-body-paragraph kd ke in kf b kg kh jo ki kj kk jr kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">事实是，我只需要开发中的测试文件，不需要生产中的测试文件。然而，当前的构建过程将编译<strong class="kf io">所有的</strong>文件，包括测试文件，并将它们传递给 AWS EC2。</p><p id="0d63" class="pw-post-body-paragraph kd ke in kf b kg kh jo ki kj kk jr kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">我需要一种方法来告诉 TypeScript <strong class="kf io">而不是</strong>编译测试文件。</p><p id="8be5" class="pw-post-body-paragraph kd ke in kf b kg kh jo ki kj kk jr kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">首先想到的是把<code class="fe nz oa ob oc b">exclude</code>添加到我的<code class="fe nz oa ob oc b">tsconfig</code>文件中。它看起来像下面这样:</p><pre class="nj nk nl nm gt od oc oe bn of og bi"><span id="4b9d" class="oh la in oc b be oi oj l ok ol">## tsconfig.json<br/>{<br/>  "compilerOptions": {<br/>    ...<br/>  },<br/>  "exclude": [<br/>    "**/*.test.ts"<br/>  ]<br/>}</span></pre><p id="81a7" class="pw-post-body-paragraph kd ke in kf b kg kh jo ki kj kk jr kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">编译时构建过程确实排除了所有测试文件，但也带来了我没有预料到的副作用。强大的 TypeScript 静态检查器在我的 VSCode 上无法正常工作。</p><p id="28dd" class="pw-post-body-paragraph kd ke in kf b kg kh jo ki kj kk jr kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">发生的情况是，TypeScript 编译器不再识别 IDE 中的任何<code class="fe nz oa ob oc b">jest</code>函数，即使我安装了来自<code class="fe nz oa ob oc b">jest</code>的所有类型定义。即使我们在<code class="fe nz oa ob oc b">compilerOption</code>下添加<code class="fe nz oa ob oc b">type</code>来强制 TypeScript 使用来自<code class="fe nz oa ob oc b">jest</code>的类型定义，也不起作用。</p><p id="00ec" class="pw-post-body-paragraph kd ke in kf b kg kh jo ki kj kk jr kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">在我看来，当我们在<code class="fe nz oa ob oc b">tsconfig</code>中添加 exclude 时，它也会忽略我们在编译器选项中指定的任何内容。</p><p id="8610" class="pw-post-body-paragraph kd ke in kf b kg kh jo ki kj kk jr kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">幸运的是，<code class="fe nz oa ob oc b">tsconfig</code>文件内置了从其他<code class="fe nz oa ob oc b">tsconfig</code>文件继承<strong class="kf io">的能力。此外，我们可以指定编译时使用哪个<code class="fe nz oa ob oc b">tsconfig</code>。命令行选项是<code class="fe nz oa ob oc b">tsc --project YourTSConfig.json</code>。</strong></p></div><div class="ab cl mw mx hr my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ig ih ii ij ik"><p id="8bcd" class="pw-post-body-paragraph kd ke in kf b kg kh jo ki kj kk jr kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">这里总结一下。</p><p id="728b" class="pw-post-body-paragraph kd ke in kf b kg kh jo ki kj kk jr kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">我想要实现的是</p><ul class=""><li id="4a05" class="lw lx in kf b kg kh kj kk km ly kq lz ku ma ky mb mc md me bi translated">在构建过程中不编译所有测试文件</li><li id="15b5" class="lw lx in kf b kg mf kj mg km mh kq mi ku mj ky mb mc md me bi translated">同时在开发中享受 TypeScript 静态类型检查支持</li></ul><p id="74d3" class="pw-post-body-paragraph kd ke in kf b kg kh jo ki kj kk jr kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated"><strong class="kf io">我现在需要做的是</strong></p><ol class=""><li id="da3c" class="lw lx in kf b kg kh kj kk km ly kq lz ku ma ky ny mc md me bi translated">创建一个新文件，我们将其命名为<code class="fe nz oa ob oc b">tsconfig.build.json</code>，这是我们将要在编译时在命令行中指定的文件</li><li id="2a59" class="lw lx in kf b kg mf kj mg km mh kq mi ku mj ky ny mc md me bi translated">(在<code class="fe nz oa ob oc b">tsconfig.build.json</code>中)添加指向原<code class="fe nz oa ob oc b">tsconfig.json</code>的<code class="fe nz oa ob oc b">extends</code>选项，具有从该文件继承选项的效果</li><li id="f7f2" class="lw lx in kf b kg mf kj mg km mh kq mi ku mj ky ny mc md me bi translated">将<code class="fe nz oa ob oc b">exclude</code>选项从<code class="fe nz oa ob oc b">tsconfig.json</code>移到<code class="fe nz oa ob oc b">tsconfig.build.json</code>，这样我们的 IDE 就不会在开发中排除静态类型检查</li><li id="04af" class="lw lx in kf b kg mf kj mg km mh kq mi ku mj ky ny mc md me bi translated">将<code class="fe nz oa ob oc b">--project tsconfig.build.json</code>添加到<code class="fe nz oa ob oc b">buildspec.yml</code>中的<code class="fe nz oa ob oc b">build commands</code>，这样 AWS 就知道在编译我们的打字稿时使用<code class="fe nz oa ob oc b">tsconfig.build.json</code></li><li id="11f3" class="lw lx in kf b kg mf kj mg km mh kq mi ku mj ky ny mc md me bi translated">享受魔法吧</li></ol><p id="24b2" class="pw-post-body-paragraph kd ke in kf b kg kh jo ki kj kk jr kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated"><em class="om">这是这三个文件的快照</em></p><pre class="nj nk nl nm gt od oc oe bn of og bi"><span id="aa8b" class="oh la in oc b be oi oj l ok ol"># buildspec.yml<br/>phases:<br/>  build:<br/>    commands:<br/>      - tsc --project tsconfig.build.json</span></pre><pre class="on od oc oe bn of og bi"><span id="9564" class="oh la in oc b be oi oj l ok ol">// tsconfig.build.json<br/>// this file is consumed by AWS CodeBuild<br/>"extends": "/tsconfig.json",<br/>"exclude": [<br/>  "**/*.test.ts"<br/>]</span></pre><pre class="on od oc oe bn of og bi"><span id="1d5a" class="oh la in oc b be oi oj l ok ol">// tsconfig.json<br/>// this file is consumed by local IDE<br/>"compilierOptions": {<br/>  ...<br/>}<br/><br/>// Do not add exlcude here, move it to tsconfig.build.json</span></pre></div><div class="ab cl mw mx hr my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ig ih ii ij ik"><h1 id="3922" class="kz la in bd lb lc nd le lf lg ne li lj jt nf ju ll jw ng jx ln jz nh ka lp lq bi translated">开始测试我们的 TypeScript 控制器的身份验证</h1><p id="a5f0" class="pw-post-body-paragraph kd ke in kf b kg lr jo ki kj ls jr kl km lt ko kp kq lu ks kt ku lv kw kx ky ig bi translated">我们将创建一个测试文件，以确保身份验证过程在我们的 TypeScript 服务器中正常工作。它将测试路线<code class="fe nz oa ob oc b">api/auth/login</code>以查看:</p><ol class=""><li id="1e1e" class="lw lx in kf b kg kh kj kk km ly kq lz ku ma ky ny mc md me bi translated">缺少凭据时，它会返回预期的错误消息</li><li id="cf13" class="lw lx in kf b kg mf kj mg km mh kq mi ku mj ky ny mc md me bi translated">当凭证有效时，它向客户端返回预期的字段</li></ol><p id="8069" class="pw-post-body-paragraph kd ke in kf b kg kh jo ki kj kk jr kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">这三个主题足以让您了解如何使用<code class="fe nz oa ob oc b">jest</code>和<code class="fe nz oa ob oc b">supertest</code>来测试 express 服务器。</p><h2 id="2971" class="mk la in bd lb ml mm dn lf mn mo dp lj km mp mq ll kq mr ms ln ku mt mu lp mv bi translated">了解基本知识</h2><ol class=""><li id="e9a6" class="lw lx in kf b kg lr kj ls km oo kq op ku oq ky ny mc md me bi translated"><code class="fe nz oa ob oc b">supertest</code>库建立在<code class="fe nz oa ob oc b">superagent</code>之上。<code class="fe nz oa ob oc b">superagent</code>是一个模仿 HTTP 客户端的 JavaScript 库，而<code class="fe nz oa ob oc b">supertest</code>扩展了<code class="fe nz oa ob oc b">superagent</code>提供的所有功能，还提供了用于测试的高级抽象。任何可以在<code class="fe nz oa ob oc b">superagent</code>中使用的东西，都可以在<code class="fe nz oa ob oc b">supertest</code>中使用。因此，如果你是第一次接触<code class="fe nz oa ob oc b">superagent</code>，你可能需要阅读他们的<a class="ae kc" href="https://ladjs.github.io/superagent/" rel="noopener ugc nofollow" target="_blank"> <em class="om">文档</em> </a> <em class="om"> </em>来了解情况。</li><li id="688c" class="lw lx in kf b kg mf kj mg km mh kq mi ku mj ky ny mc md me bi translated">我们可以将我们想要的 HTTP 服务器传递给<code class="fe nz oa ob oc b">supertest</code>来模拟发送到该服务器的 HTTP 请求。语法看起来像这样<code class="fe nz oa ob oc b">request(app).get(API_ENDPOINT)</code>。<code class="fe nz oa ob oc b">request</code>来自<code class="fe nz oa ob oc b">supertest</code>。它的参数<code class="fe nz oa ob oc b">app</code>就是我们设置的 HTTP 服务器。那行代码意味着向我们指定的应用服务器发送一个 GET 请求。</li><li id="6719" class="lw lx in kf b kg mf kj mg km mh kq mi ku mj ky ny mc md me bi translated">通常，我们将测试分组是为了更好的管理。分组是上面第一点中提到的高级测试抽象。<code class="fe nz oa ob oc b">describe</code>将相关的<code class="fe nz oa ob oc b">test</code>分组到同一个块中，以便于阅读。你可以阅读<a class="ae kc" href="https://jestjs.io/docs/api#describename-fn" rel="noopener ugc nofollow" target="_blank"> <em class="om"> Jest API 文档来进一步了解</em> </a>的描述。</li></ol></div><div class="ab cl mw mx hr my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ig ih ii ij ik"><p id="df32" class="pw-post-body-paragraph kd ke in kf b kg kh jo ki kj kk jr kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">现在我们对语法有了基本的了解，我们可以开始构建我们的测试了。</p><h2 id="bb6f" class="mk la in bd lb ml mm dn lf mn mo dp lj km mp mq ll kq mr ms ln ku mt mu lp mv bi translated">测试场景#1 —缺少凭据时返回预期的错误消息</h2><p id="e398" class="pw-post-body-paragraph kd ke in kf b kg lr jo ki kj ls jr kl km lt ko kp kq lu ks kt ku lv kw kx ky ig bi translated">这个简单的场景将向我们指定的 API 端点发送一个 POST 请求。</p><pre class="nj nk nl nm gt od oc oe bn of og bi"><span id="9a6c" class="oh la in oc b be oi oj l ok ol">import request from 'supertest'<br/>import app from '../app'<br/><br/>const AUTH_ROUTE = '/api/auth/login'<br/><br/>describe('#1 Return ERROR when credential is missing', () =&gt; {<br/>  test('should throw error when there is no credentials', async () =&gt; {<br/>    const res = await request(app).post(AUTH_ROUTE).send({})<br/>    expect(res.body.status).toBe('error')<br/>    expect(res.body.message).toBe('missing account and password')<br/>  })<br/><br/>  test('should throw error when there is no account', async () =&gt; {<br/>    const res = await request(app).post(AUTH_ROUTE).send(CREDENTIALS_NO_ACCOUNT)<br/>    expect(res.body.status).toBe('error')<br/>    expect(res.body.message).toBe('missing account')<br/>  })<br/><br/>  test('should throw error when there is account but no password', async () =&gt; {<br/>    const res = await request(app).post(AUTH_ROUTE).send(CREDENTIALS_NO_PASSWORD)<br/>    expect(res.body.status).toBe('error')<br/>    expect(res.body.message).toBe('missing password')<br/>  })<br/>})</span></pre><h2 id="deb1" class="mk la in bd lb ml mm dn lf mn mo dp lj km mp mq ll kq mr ms ln ku mt mu lp mv bi translated">测试场景#2 —当凭证有效时，将预期字段返回给客户端</h2><pre class="nj nk nl nm gt od oc oe bn of og bi"><span id="e40f" class="oh la in oc b be oi oj l ok ol">describe('#2 Return success, username and accessToken when credential is valid', () =&gt; {<br/>  test('should return with username and accessToken when the credentials are valid', async () =&gt; {<br/>    const res = await request(app).post(AUTH_ROUTE).send(CORRECT_CREDENTIALS)<br/>    expect(res.body.status).toBe('success')<br/>    expect(res.body).toHaveProperty('username')<br/>    expect(res.body).toHaveProperty('accessToken')<br/>  })<br/>})</span></pre></div><div class="ab cl mw mx hr my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ig ih ii ij ik"><h1 id="693e" class="kz la in bd lb lc nd le lf lg ne li lj jt nf ju ll jw ng jx ln jz nh ka lp lq bi translated">我们成功了！</h1><p id="f88e" class="pw-post-body-paragraph kd ke in kf b kg lr jo ki kj ls jr kl km lt ko kp kq lu ks kt ku lv kw kx ky ig bi translated">我们刚刚成功地实现了测试，看看我们的控制器是否按预期处理了请求。现在，您知道了如何从这里开发测试场景。</p><p id="2469" class="pw-post-body-paragraph kd ke in kf b kg kh jo ki kj kk jr kl km kn ko kp kq kr ks kt ku kv kw kx ky ig bi translated">玩得开心，祝你圣诞快乐！</p></div><div class="ab cl mw mx hr my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ig ih ii ij ik"><h1 id="213c" class="kz la in bd lb lc nd le lf lg ne li lj jt nf ju ll jw ng jx ln jz nh ka lp lq bi translated">参考</h1><ul class=""><li id="b4cc" class="lw lx in kf b kg lr kj ls km oo kq op ku oq ky mb mc md me bi translated"><a class="ae kc" href="https://ladjs.github.io/superagent/" rel="noopener ugc nofollow" target="_blank"> <em class="om">超级代理 API 文档</em> </a></li><li id="a512" class="lw lx in kf b kg mf kj mg km mh kq mi ku mj ky mb mc md me bi translated"><a class="ae kc" href="https://jestjs.io/docs/getting-started" rel="noopener ugc nofollow" target="_blank"> <em class="om"> Jest 文档</em> </a></li></ul></div></div>    
</body>
</html>