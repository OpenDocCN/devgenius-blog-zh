<html>
<head>
<title>MUST known React questions for your next frontend interview — Part 3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">下一次前端面试必须知道的问题——第三部分</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/must-known-react-questions-for-your-next-frontend-interview-part-3-70818c6481d?source=collection_archive---------17-----------------------#2022-12-06">https://blog.devgenius.io/must-known-react-questions-for-your-next-frontend-interview-part-3-70818c6481d?source=collection_archive---------17-----------------------#2022-12-06</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/ede4cb65f9bae2758075b825322c2add.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*PeZT1ioz4odmRHQM.jpg"/></div></div></figure><p id="ec28" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这篇文章是上一篇文章的延续，在上一篇文章中，我为你的下一次前端面试列出了一些重要的问题和答案。</p><ol class=""><li id="ec94" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated"><strong class="jx io">使用带 props 实参的超级构造函数的目的是什么？</strong></li></ol><p id="e118" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在调用<code class="fe lc ld le lf b">super()</code>方法之前，子类构造函数不能使用<code class="fe lc ld le lf b">this</code>引用。这同样适用于 ES6 子类。将 props 参数传递给<code class="fe lc ld le lf b">super()</code>调用的主要原因是为了访问子构造函数中的<code class="fe lc ld le lf b">this.props</code>。</p><p id="4af3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">传球道具:</p><pre class="lg lh li lj gt lk lf ll bn lm ln bi"><span id="026c" class="lo lp in lf b be lq lr l ls lt">class MyComponent extends React.Component {<br/>  constructor(props) {<br/>    super(props)<br/><br/>    console.log(this.props) // prints { name: 'John', age: 42 }<br/>  }<br/>}</span></pre><p id="8123" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">不传递道具:</p><pre class="lg lh li lj gt lk lf ll bn lm ln bi"><span id="5c15" class="lo lp in lf b be lq lr l ls lt">class MyComponent extends React.Component {<br/>  constructor(props) {<br/>    super()<br/><br/>    console.log(this.props) // prints undefined<br/><br/>    // but props parameter is still available<br/>    console.log(props) // prints { name: 'John', age: 42 }<br/>  }<br/><br/>  render() {<br/>    // no difference outside constructor<br/>    console.log(this.props) // prints { name: 'John', age: 42 }<br/>  }<br/>}</span></pre><p id="d0cf" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">上面的代码片段揭示了<code class="fe lc ld le lf b">this.props</code>只是在构造函数中有所不同。在构造函数之外也是如此。</p><p id="f8b0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> 2。如何用动态键名设置状态？</strong></p><p id="b1a6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你使用 ES6 或 Babel transpiler 来转换你的 JSX 代码，那么你可以用<em class="lu">计算属性名</em>来完成。</p><pre class="lg lh li lj gt lk lf ll bn lm ln bi"><span id="ed95" class="lo lp in lf b be lq lr l ls lt">handleInputChange(event) {<br/>  this.setState({ [event.target.id]: event.target.value })<br/>}</span></pre><p id="d644" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> 3。为什么 React 使用</strong> <code class="fe lc ld le lf b"><strong class="jx io">className</strong></code> <strong class="jx io">胜过</strong> <code class="fe lc ld le lf b"><strong class="jx io">class</strong></code> <strong class="jx io">属性？</strong></p><p id="42fd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe lc ld le lf b">class</code>是 JavaScript 中的关键字，JSX 是 JavaScript 的扩展。这就是 React 使用<code class="fe lc ld le lf b">className</code>而不是<code class="fe lc ld le lf b">class</code>的主要原因。传递一个字符串作为<code class="fe lc ld le lf b">className</code>道具。</p><pre class="lg lh li lj gt lk lf ll bn lm ln bi"><span id="d133" class="lo lp in lf b be lq lr l ls lt">render() {<br/>  return &lt;span className={'menu navigation-menu'}&gt;{'Menu'}&lt;/span&gt;<br/>}</span></pre><p id="4255" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> 4。什么是碎片？</strong></p><p id="1325" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是 React 中的一种常见模式，用于一个组件返回多个元素。<em class="lu"> Fragments </em>让你不用给 DOM 添加额外的节点就能分组一个孩子列表。</p><pre class="lg lh li lj gt lk lf ll bn lm ln bi"><span id="57b5" class="lo lp in lf b be lq lr l ls lt">render() {<br/>  return (<br/>    &lt;React.Fragment&gt;<br/>      &lt;ChildA /&gt;<br/>      &lt;ChildB /&gt;<br/>      &lt;ChildC /&gt;<br/>    &lt;/React.Fragment&gt;<br/>  )<br/>}</span></pre><p id="5eaf" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">还有一个更短的语法，但是它在许多工具中不被支持:</p><pre class="lg lh li lj gt lk lf ll bn lm ln bi"><span id="ef5e" class="lo lp in lf b be lq lr l ls lt">render() {<br/>  return (<br/>    &lt;&gt;<br/>      &lt;ChildA /&gt;<br/>      &lt;ChildB /&gt;<br/>      &lt;ChildC /&gt;<br/>    &lt;/&gt;<br/>  )<br/>}</span></pre><p id="1a48" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> 5。为什么片段比容器 div 好？</strong></p><p id="09ba" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">以下是原因列表</p><ul class=""><li id="2563" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks lv kz la lb bi translated">通过不创建额外的 DOM 节点，片段速度更快，使用的内存更少。这只对非常大和深的树有真正的好处。</li><li id="a0df" class="kt ku in jx b jy lw kc lx kg ly kk lz ko ma ks lv kz la lb bi translated">有些 CSS 机制像<em class="lu"> Flexbox </em>和<em class="lu"> CSS Grid </em>有特殊的父子关系，在中间添加 div 很难保持想要的布局。</li><li id="79c4" class="kt ku in jx b jy lw kc lx kg ly kk lz ko ma ks lv kz la lb bi translated">DOM 检查器不那么杂乱。</li></ul><p id="ec2f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> 6。什么是无状态组件？</strong></p><p id="dfb2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果一个组件的行为独立于它的状态，那么它可能是一个无状态的组件。您可以使用函数或类来创建无状态组件。但是除非你需要在组件中使用生命周期挂钩，否则你应该选择功能组件。如果你决定在这里使用函数组件，会有很多好处；它们易于编写、理解和测试，速度稍快，并且您可以完全避免使用<code class="fe lc ld le lf b">this</code>关键字。</p><p id="e167" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> 7。什么是有状态组件？</strong></p><p id="1e37" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果组件的行为依赖于组件的<em class="lu">状态</em>，那么它可以被称为有状态组件。这些<em class="lu">有状态组件</em>总是<em class="lu">类组件</em>，并且有一个在<code class="fe lc ld le lf b">constructor</code>中被初始化的状态。</p><pre class="lg lh li lj gt lk lf ll bn lm ln bi"><span id="723d" class="lo lp in lf b be lq lr l ls lt">class App extends Component {<br/>  constructor(props) {<br/>    super(props)<br/>    this.state = { count: 0 }<br/>  }<br/><br/>  render() {<br/>    // ...<br/>  }<br/>}</span></pre><p id="d279" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">React 16.8 更新:</p><p id="bbc2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">钩子让你不用写类就可以使用状态和其他 React 特性。</p><p id="0274" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="lu">等效功能部件</em></p><pre class="lg lh li lj gt lk lf ll bn lm ln bi"><span id="3052" class="lo lp in lf b be lq lr l ls lt"> import React, {useState} from 'react';<br/><br/> const App = (props) =&gt; {<br/>   const [count, setCount] = useState(0);<br/><br/>   return (<br/>     // JSX<br/>   )<br/> }</span></pre><p id="f018" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">8。如何在 React 中对道具应用验证？</p><p id="84be" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当应用程序在<em class="lu">开发模式</em>下运行时，React 将自动检查我们在组件上设置的所有属性，以确保它们具有<em class="lu">正确的类型</em>。如果类型不正确，React 将在控制台中生成警告消息。由于性能影响，它在<em class="lu">生产模式</em>中被禁用。强制道具用<code class="fe lc ld le lf b">isRequired</code>定义。</p><p id="3628" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一组预定义道具类型:</p><ol class=""><li id="6bdb" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated"><code class="fe lc ld le lf b">PropTypes.number</code></li><li id="c771" class="kt ku in jx b jy lw kc lx kg ly kk lz ko ma ks ky kz la lb bi translated"><code class="fe lc ld le lf b">PropTypes.string</code></li><li id="643d" class="kt ku in jx b jy lw kc lx kg ly kk lz ko ma ks ky kz la lb bi translated"><code class="fe lc ld le lf b">PropTypes.array</code></li><li id="7104" class="kt ku in jx b jy lw kc lx kg ly kk lz ko ma ks ky kz la lb bi translated"><code class="fe lc ld le lf b">PropTypes.object</code></li><li id="7e8b" class="kt ku in jx b jy lw kc lx kg ly kk lz ko ma ks ky kz la lb bi translated"><code class="fe lc ld le lf b">PropTypes.func</code></li><li id="bf40" class="kt ku in jx b jy lw kc lx kg ly kk lz ko ma ks ky kz la lb bi translated"><code class="fe lc ld le lf b">PropTypes.node</code></li><li id="3dab" class="kt ku in jx b jy lw kc lx kg ly kk lz ko ma ks ky kz la lb bi translated"><code class="fe lc ld le lf b">PropTypes.element</code></li><li id="ed7a" class="kt ku in jx b jy lw kc lx kg ly kk lz ko ma ks ky kz la lb bi translated"><code class="fe lc ld le lf b">PropTypes.bool</code></li><li id="0d38" class="kt ku in jx b jy lw kc lx kg ly kk lz ko ma ks ky kz la lb bi translated"><code class="fe lc ld le lf b">PropTypes.symbol</code></li><li id="9f85" class="kt ku in jx b jy lw kc lx kg ly kk lz ko ma ks ky kz la lb bi translated"><code class="fe lc ld le lf b">PropTypes.any</code></li></ol><p id="4bab" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们可以将<code class="fe lc ld le lf b">User</code>组件的<code class="fe lc ld le lf b">propTypes</code>定义如下:</p><pre class="lg lh li lj gt lk lf ll bn lm ln bi"><span id="dfd4" class="lo lp in lf b be lq lr l ls lt">import React from 'react'<br/>import PropTypes from 'prop-types'<br/><br/>class User extends React.Component {<br/>  static propTypes = {<br/>    name: PropTypes.string.isRequired,<br/>    age: PropTypes.number.isRequired<br/>  }<br/><br/>  render() {<br/>    return (<br/>      &lt;&gt;<br/>        &lt;h1&gt;{`Welcome, ${this.props.name}`}&lt;/h1&gt;<br/>        &lt;h2&gt;{`Age, ${this.props.age}`}&lt;/h2&gt;<br/>      &lt;/&gt;<br/>    )<br/>  }<br/>}</span></pre><p id="a03d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">注意:在 React v15.5 <em class="lu">中，属性类型</em>从<code class="fe lc ld le lf b">React.PropTypes</code>移到了<code class="fe lc ld le lf b">prop-types</code>库中。</p><p id="ba66" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="lu">等效功能部件</em></p><pre class="lg lh li lj gt lk lf ll bn lm ln bi"><span id="20a3" class="lo lp in lf b be lq lr l ls lt">import React from 'react'<br/>import PropTypes from 'prop-types'<br/><br/>function User({name, age}) {<br/>  return (<br/>    &lt;&gt;<br/>      &lt;h1&gt;{`Welcome, ${name}`}&lt;/h1&gt;<br/>      &lt;h2&gt;{`Age, ${age}`}&lt;/h2&gt;<br/>    &lt;/&gt;<br/>  )<br/>}<br/><br/>User.propTypes = {<br/>    name: PropTypes.string.isRequired,<br/>    age: PropTypes.number.isRequired<br/>  }</span></pre><p id="2f6a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> 9。React 的局限性是什么？</strong></p><p id="2059" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">React 也有一些限制，</p><ul class=""><li id="09b5" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks lv kz la lb bi translated">React 只是一个视图库，不是一个完整的框架。</li><li id="ffbc" class="kt ku in jx b jy lw kc lx kg ly kk lz ko ma ks lv kz la lb bi translated">对于刚接触 web 开发的初学者来说，有一个学习曲线。</li><li id="cdc0" class="kt ku in jx b jy lw kc lx kg ly kk lz ko ma ks lv kz la lb bi translated">将 React 集成到传统的 MVC 框架中需要一些额外的配置。</li><li id="f87c" class="kt ku in jx b jy lw kc lx kg ly kk lz ko ma ks lv kz la lb bi translated">代码复杂性随着内联模板和 JSX 而增加。</li><li id="bb1b" class="kt ku in jx b jy lw kc lx kg ly kk lz ko ma ks lv kz la lb bi translated">过多的小组件导致过度工程化或样板化。</li></ul><p id="a501" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">10。事件的反应如何不同？</p><p id="7c69" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在 React 元素中处理事件有一些语法差异:</p><ul class=""><li id="6b53" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks lv kz la lb bi translated">React 事件处理程序使用 camelCase 命名，而不是小写。</li><li id="cf96" class="kt ku in jx b jy lw kc lx kg ly kk lz ko ma ks lv kz la lb bi translated">使用 JSX，你传递一个函数作为事件处理器，而不是一个字符串。</li></ul></div><div class="ab cl mb mc hr md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ig ih ii ij ik"><p id="70ec" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这里，我列出了另外 10 个 ReactJs 问题，这是这个系列的最后一部分。</p><ul class=""><li id="3413" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks lv kz la lb bi translated">给它鼓掌</li><li id="55cd" class="kt ku in jx b jy lw kc lx kg ly kk lz ko ma ks lv kz la lb bi translated">关注我<a class="mi mj ep" href="https://medium.com/u/8a9ce53808fd?source=post_page-----70818c6481d--------------------------------" rel="noopener" target="_blank"> Mohit garg </a>，获取基于 JavaScript、ReactJs、Web 开发、Web3 等其他文章的通知。</li></ul></div></div>    
</body>
</html>