# 自识别标识符

> 原文：<https://blog.devgenius.io/the-self-identifying-identifier-5ede360d0313?source=collection_archive---------1----------------------->

*让我们轻松一点，为什么不…*

![](img/804932397dad7eaa506b90e85cb05975.png)

照片由[布雷特·乔丹](https://unsplash.com/@brett_jordan?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄

在每个程序员的旅程中，总会有那么一个时刻，你只是想知道“为什么？”例如，“为什么我要在我创建的每个项目中重写相同的例程？”或者“为什么我的样板文件总是比我的核心逻辑花更多的时间？”或者“为什么我还是程序员？”

这些问题都是合理的，但是其中一个让我越来越困惑的问题是“为什么标识符必须是整数？”或者与之密切相关的一个问题，“为什么标识符必须像 GUID 一样是随机的？”我的意思是，难道我们不是在试图检索一些对我们有用的数据吗？为什么我们要用这些随机数和字母来定位这些数据呢？

这是一个合理的问题。这是我的看法…

# 标识符及其用途

通常，标识符(ID)只用于一个目的:根据单个可寻址单元(ID)定位一个数据或一组数据。拿回 ID 没有太多其他目的。您可能会认为 ID 是一个求和工具(也就是说，所有包含的数据都可以通过这个标识符求和)，或者它可以用作一个实体的唯一分类器(也是为了检索)。但是标识符是关于某个对象的回忆，而不是身份。

没有上下文，标识符本身并没有多大用处。例如，在传统意义上，ID 是数据库表中的一个`int`或一个`bigint`，比如说`tblUsers`。在这种情况下，该列将被命名为类似于`Id`或`UserId`的名称。它将从`1`开始，或者如果你是那些聪明的开发者之一，从`1362`开始。从那里开始，随着你的系统获得越来越多的用户，价格会越来越高。

所以当你从系统中取回这个标识符时，它会是类似于`984`的东西。让我们只希望你知道这指的是`UserId`并且它来自**我们的**表`tblUsers`，而不是其他维护用户的系统。那个`984`就像你所在街道的门牌号。你可以说这个用户的**真** ID 的范围是`984 UserId, tblUsers, MySystemDatabase, MyCompany`。也就是说，对于我们要加载的实体的所有上下文，我们必须知道所有这些才能正确地获取数据，就像邮寄地址一样。然而，我喜欢称之为标识符的**范围**。没有范围，你就无法真正知道那个`int`指的是哪个实体。

# 更好的方法？

这是一个加载的子标题，我知道。这就是为什么问号必须包含在内。但是有没有更好的方法让标识符更有用呢？如果是，在什么情况下？

传统的`int` ID 实际上并不占用太多空间，通常只有 4 个字节。这意味着要传递这个信息，你只需要 4 个字节来完全识别实体。当然，这是假设你知道上下文。然而，当我们编写应用程序时，我们可以(大部分)确信我们可以保持这一点。

但是在当今世界，在大多数商业应用程序中，4 字节和 256 字节并没有太大区别。在 5G 速度和 1Gb 家庭互联网服务的情况下，将 252 字节的差异添加到有效载荷中真的不会被注意到。

这并不是说，我认为我们应该轻率地对待数据效率、压缩算法或任何其他节省流量的方法。一点也不。但是，如果我们可以通过增加一些标识符来减少后端成本，从而获得一些价值，为什么我们不应该计算这种权衡来确保我们有足够的 ROI 呢？

让我们讨论一个更具体的例子，传统的关系数据库包含典型的 SQL 连接。

假设我们有一个锦标赛系统，我们为一个组织举办比赛。我们有以下表格:

```
tblOrganizations => Holds Organization Details
tblTournaments => Holds Tournament Master Record
tblMatches => Holds Match data for the tournament
```

现在，假设我们有一个查询，我们想要获取我们组织内特定锦标赛的所有匹配。该查询可能如下所示:

```
SELECT M.*
FROM tblMatches M
JOIN tblTournament T
  ON T.TournamentID = M.TournamentID
JOIN tblOrganization O
  ON O.OrganizationID = T.OrganizationID
WHERE
  O.OrganizationID = @UserOrganizationID AND
  T.TournamentID = @TournamentID
```

这真的没什么大不了的，但是为了找到我们需要的信息，必须进行一些连接。在这个简单的例子中，我们可能没有问题，但是如果我们可以搜索一个单独的列呢？也许就像标识符本身？如果我们像对待 RESTful 服务一样命名我们的标识符会怎么样？这能简化我们的系统吗？

让我们对此进行一些探索。

# 命名空间标识符

命名空间已经存在很长时间了。几十年来，它帮助我们识别各种各样的物体和实体。您可以在 XML 模式中看到它。你看到的是代码类(`System.IO`)。你到处都能看到它。这是有益的，因为我们可以将对象分类成不同的类型。

然而，这些类型的名称空间本质上通常更加静态。如果我们走一条更动态的路线，比如 REST，其中标识符的前缀是到达那里的路线，会怎么样？

以上面的例子为例，如果我们有相同的表，`tblMatches`但是我们稍微改变了 ID。我们没有使用`TournamentID`来加入，而是将`MatchID`改为如下形式:

`/organization/**sparcpoint**/tournament/**2022-annual-tourney**/match/**a**`

那么，这增加了什么优势呢？

首先，我们不必连接到另一个表来执行搜索本身。相反，我们可以在`MatchID`上搜索以找到我们想要的匹配。

第二，标识符是自描述的。如果我们查看原始数据库表，我们将能够快速识别这场比赛属于哪个锦标赛和组织。

现在，您可能会对自己说，“这很好，但是我们使用 SQL Server，像这样的`varchar`标识符只会减慢速度，尤其是当我们必须执行`LIKE`语句时。”你是对的。如果我看到一个建筑师直接这样做，我会大吃一惊。即使添加了索引，也无法在不影响性能的情况下进行这样的更改。

这就是为什么我喜欢标识符有一个**范围**的想法。范围是一种快速识别记录在更大的段中的位置的方法。在上面的例子中，我认为这些匹配的范围是，

`/organization/**sparcpoint**/tournament/**2022-annual-tourney**`

当然，我们必须将它添加到我们的表中…

现在我们的`tblMatches`有了`ScopeID = /organization/**sparcpoint**/tournament/**2022-annual-tourney**`和一个`MatchID = /organization/**sparcpoint**/tournament/**2022-annual-tourney**/match/**a**`。

看看这个表的大小是如何比以前更快地从兆字节增长到千兆字节的…

但是我们可以在`ScopeID`和`MatchID`上索引这个表，并且在两种情况下都有非常可伸缩的查找。我们可以快速抓取所有匹配，并快速抓取单个匹配，即使有数百万条记录。

# 真正的可扩展性

让我们假设存储很便宜，从 10GB(每月 0.18 美元)的数据库升级到 100GB(每月 1.80 美元)的数据库不会让你多花多少钱。我们还假设您希望高速读取和无争议写入。

您会注意到，我没有在上面的任何粗体标识符中使用数字。相反，我用蛞蝓是为了独特。这意味着多个组织可以拥有相同的锦标赛名称。这也意味着同一组织内的不同锦标赛可以有相同的比赛名称。**这很重要**。

通过使用 slugs，我们创造了一个可预测的标识符系统。当您拥有可预测的标识符时，保存和加载数据的许多方面都变得更加容易:批量插入、组成新实体、事务一致性、多个表插入等。

如果反过来增加范围，现在就可以创建一套可查询的表，通过简单地创建许多链接表(或者，如果大胆的话，创建一个查询表)，就可以更快地进行搜索。例如，我们可能想要一个与特定游戏相关的锦标赛(比如说**堡垒之夜**)。我们可以创建一个名为`tblQuery`的表，它只有三列:`ScopeID`、`Table`和`ID`，而不是直接添加到我们的`ScopeID`或`MatchID`中。然后，我们可以看到下面的条目，将我们的锦标赛与**堡垒之夜**联系起来。

```
// Entry #1
ScopeID = /game/fortnite
Table = tblTournaments
ID = /organization/sparcpoint/tournament/2022-annual-tourney

// Entry #2
ScopeID = /game/fortnite
Table = tblMatches
ID = /organization/sparcpoint/tournament/2022-annual-tourney/match/a
```

当然，您可以索引这个表以便快速访问。是的，您仍然需要调用另一个表，但是这些查询会非常快。您可以扩展这个表，根据需要包含带有像`tags`或`categories`这样的实体或者甚至其他类型的元数据的范围。

这种设计的限制实际上是围绕着你的查询创造力。当你开始做`LIKE`查询和诸如此类的事情时，嗯……你将会遇到和今天一样的问题，扫描。但是，如果您可以将查询组织到合理的方面，大多数(如果不是全部)查询可以以几乎相同的高速运行。

# 还不服气？

我也不是…至少对 SQL 关系表来说不是。如果您坚持使用`int`和`bigint`标识符，同时保持查询使用适当的索引，关系表将按照相同的性能指标运行，如果不是更好的话。当然，你会失去可预测性，但这是可以接受的。

这确实是一种在 NoSQL 空间中更有用的模式。Azure 的表存储就是一个很好的例子。桌子储物就是围绕着`PartitionKey` ( `ScopeID`)和`RowKey` ( `ID`)这个概念打造的。所以我们的`tblQuery`将被转换成这两列加上表名本身。由于存储很便宜，将相同的数据多次复制到不同的分区是非常实用的，也是值得推荐的。通过这种方式，您可以实现高速写入和读取，同时拥有廉价的存储资源，并在软件方面具有更大的灵活性(我可以在另一篇文章中详细介绍)。

但是如果你只有 SQL Server 或者 MySQL 可以使用呢？理论上，你可以将你的实例转换成 NoSQL 风格的数据库，为将来的云计算做准备。例如，让这个`ScopeID`和`ID`成为所有表格中的标准。然后向表中添加一个`VARCHAR(MAX)`(或等效的)来存储 JSON、XML 或二进制文件。从速度的角度来看，它(几乎)等同于表存储。您仍然可以为特殊情况拆分一些列，在这些情况下，您可以缩小查询范围，然后对剩余的记录进行扫描。从建筑的角度来看，这是我赞同的。更重要的是，如果需要的话，可以使用`ScopeID`在服务器之间共享数据库。嘿…也许只是考虑一下…

在过去的几年里，我已经以多种方式使用了这种技术，并且我发现提前知道标识符，让它(几乎)自动地成为惟一的，使得我的代码、围绕我的代码的推理以及系统的稳定性变得更好。这是因为不必等待数据库给我标识符，同时也为实体提供了一个自然的 RESTful 接口。通过这种设置，即使是 web 端点对于基本的 CRUD 方面也变得自然动态，因为 lookup 只是简单地调用正确的表并使用从 URI 提供的路径。我承认，这种方法的许多优点是在软件开发中获得的，而不是在数据库本身。

我敢肯定，你可能还会考虑其他事情来解决这个问题。这样做很自然。例如，如何在服务器上生成 GUIDs 呢？那么至少对于批量上传、插入等，你有可预测性。但是，接下来您需要处理长时间的聚集索引问题。或者把`ScopeID`从`ID`中分离出来，这样 ID 就更短了，但是这样就失去了表内的直接连接。

这种技术肯定有利有弊。但至少我希望我已经提供了一些东西，让你在下一个项目中思考！

评论开始…我想这是一个非常有争议的话题！所以让我们开始吧！