<html>
<head>
<title>How to write eBPF programs with Golang</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用 Golang 编写 eBPF 程序</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-to-write-ebpf-programs-with-golang-933d58fc5dba?source=collection_archive---------2-----------------------#2022-09-22">https://blog.devgenius.io/how-to-write-ebpf-programs-with-golang-933d58fc5dba?source=collection_archive---------2-----------------------#2022-09-22</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="b5cb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我对 Linux 内核开发和生态系统中的所有工具都非常好奇。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/564db088c62a85eaacd1185e06474f2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*7TjK8npQavcMwhGD1Y5z_g.png"/></div></figure><p id="ce76" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">虽然 eBPF 并不完全是新的(现在已经 7 岁了)，但就 Linux 内核而言，它仍然是早期的，新技术的采用通常进展缓慢。我早就迫不及待地想投入其中了。</p><p id="e291" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最近，我有一些时间奉献给<strong class="jm io"> eBPF </strong>和<strong class="jm io"> BTF </strong>，所以我才开始在【kernel.org】T5<a class="ae kq" href="https://www.kernel.org/doc/html/latest/bpf/instruction-set.html" rel="noopener ugc nofollow" target="_blank">看文档(真的推荐！)，而且因为<strong class="jm io">做</strong>是最好的学习方式，我只是简单地在 Golang 中围绕<strong class="jm io"> sk_lookup </strong>写了一个库<strong class="jm io"> sklookup-go </strong>，这将帮助我使用一些遗留的 TCP 服务器。</a></p></div><div class="ab cl kr ks hr kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ig ih ii ij ik"><h2 id="489c" class="ky kz in bd la lb lc dn ld le lf dp lg jv lh li lj jz lk ll lm kd ln lo lp lq bi translated">图书馆，什么是 sklookup-go？</h2><p id="4393" class="pw-post-body-paragraph jk jl in jm b jn lr jp jq jr ls jt ju jv lt jx jy jz lu kb kc kd lv kf kg kh ig bi translated"><a class="ae kq" href="https://github.com/fbac/sklookup-go" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> sklookup-go </strong> </a>是一个项目，提供:</p><ul class=""><li id="5ed8" class="lw lx in jm b jn jo jr js jv ly jz lz kd ma kh mb mc md me bi translated">一个<strong class="jm io"> cli </strong>来运行绑定到一个 socket 中的程序，为这个程序(由其 PID 指定)提供一些额外的端口。(Max。1024)</li><li id="5cd9" class="lw lx in jm b jn mf jr mg jv mh jz mi kd mj kh mb mc md me bi translated">它也是一个<strong class="jm io">包</strong>，你可以从你的 Golang 代码中使用它。也许你有一些程序绑定到一个端口，由于某种原因，你不想把它绑定到其他地方。这不成问题，导入库，传递侦听器的文件描述符和一些附加端口，就可以开始了。</li><li id="b737" class="lw lx in jm b jn mf jr mg jv mh jz mi kd mj kh mb mc md me bi translated">这两个能力依赖于一个<strong class="jm io"> sk_lookup </strong> eBPF 程序，通过<a class="ae kq" href="https://github.com/cilium/ebpf/tree/master/cmd/bpf2go" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> bpf2go </strong> </a>和逻辑编写感谢 Golang 包<a class="ae kq" href="https://github.com/cilium/ebpf" rel="noopener ugc nofollow" target="_blank"><strong class="jm io">cilium/eBPF</strong></a><strong class="jm io">。</strong></li></ul><h2 id="5bf3" class="ky kz in bd la lb lc dn ld le lf dp lg jv lh li lj jz lk ll lm kd ln lo lp lq bi translated">而 sk_lookup 到底是什么？</h2><p id="c411" class="pw-post-body-paragraph jk jl in jm b jn lr jp jq jr ls jt ju jv lt jx jy jz lu kb kc kd lv kf kg kh ig bi translated">eBPF 程序类型很多，<a class="ae kq" href="https://www.kernel.org/doc/html/latest/bpf/prog_sk_lookup.html" rel="noopener ugc nofollow" target="_blank">SK _ LOOKUP</a>(<strong class="jm io">BPF _ PROG _ TYPE _ SK _ LOOKUP</strong>)只是其中一种。</p><p id="5905" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这种类型的程序运行在内核协议层，就在将连接附加到套接字中现有的接收缓冲区之前。</p><p id="9acf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">或者<strong class="jm io">粗略地说</strong>当内核试图弄清楚把它接收到的这个特定的数据块传递到哪里时，sk_lookup 进入内核，把数据传递到一个指向套接字的文件描述符。</p><h2 id="8e3f" class="ky kz in bd la lb lc dn ld le lf dp lg jv lh li lj jz lk ll lm kd ln lo lp lq bi translated">但是…那么，eBPF 是什么？</h2><p id="7a5a" class="pw-post-body-paragraph jk jl in jm b jn lr jp jq jr ls jt ju jv lt jx jy jz lu kb kc kd lv kf kg kh ig bi translated">不可否认，eBPF 是一项革命性的技术。它在一个空间中引入了可编程性，Linux 内核(<a class="ae kq" href="https://github.com/microsoft/ebpf-for-windows" rel="noopener ugc nofollow" target="_blank"> Windows </a>，也是如此)，这在传统上仅限于内核模块。</p><p id="1308" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">由于显而易见的原因，内核是每个操作系统中最关键的部分，它的发展通常很慢，但是由于 eBPF，这不再是真的了。作为系统程序员，每个人都可以将程序加载到内核中，并以沙箱的方式运行它们。</p></div><div class="ab cl kr ks hr kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ig ih ii ij ik"><h2 id="a208" class="ky kz in bd la lb lc dn ld le lf dp lg jv lh li lj jz lk ll lm kd ln lo lp lq bi translated">那么，为什么这对我们有用呢？</h2><p id="395e" class="pw-post-body-paragraph jk jl in jm b jn lr jp jq jr ls jt ju jv lt jx jy jz lu kb kc kd lv kf kg kh ig bi translated">首先，因为它极其<strong class="jm io">酷</strong>。永远不要忘记酷的法则；你知道…什么都可以做，只要是<a class="ae kq" href="https://en.wiktionary.org/wiki/cool" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io">酷</strong> </a>。</p><p id="c91b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">另外，严肃地说，想象一下这样一种场景，您必须为一个遗留应用程序提供额外的端口，而这个遗留应用程序恰好只监听一个套接字或一个 IP。你真的需要它来监听更多的套接字。</p><p id="551f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">或者您可能想要实现一个<a class="ae kq" href="https://simple.wikipedia.org/wiki/OSI_model#Layer_7:_Application_layer" rel="noopener ugc nofollow" target="_blank"> L7 代理</a>，同时将您的代理只绑定到一个 IP 或套接字。</p><p id="d0ca" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你有梦想，你就能做到。</p><h2 id="19a6" class="ky kz in bd la lb lc dn ld le lf dp lg jv lh li lj jz lk ll lm kd ln lo lp lq bi translated"><strong class="ak">为什么要用 Cilium 开发的 ebpf 包？</strong></h2><p id="6632" class="pw-post-body-paragraph jk jl in jm b jn lr jp jq jr ls jt ju jv lt jx jy jz lu kb kc kd lv kf kg kh ig bi translated">有许多好的库可以与 ebpf 交互，但是我选择了<strong class="jm io"> cilium/ebpf </strong>，因为它们的方法是<strong class="jm io">纯 Go 实现</strong>。这感觉完全合理，因为我们不再依赖其他构建工具或工作流来完成工作。</p><p id="70bf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">此外，当与<strong class="jm io"> bpf2go </strong>一起使用时，它允许你与程序交互，而不必自己编译 ELF 二进制文件，这是一件不用担心的事情。</p><blockquote class="mk ml mm"><p id="f3d5" class="jk jl mn jm b jn jo jp jq jr js jt ju mo jw jx jy mp ka kb kc mq ke kf kg kh ig bi translated">记住，<strong class="jm io"> bpf2go </strong>会将源代码编译成 eBPF 字节码，其方式与 cli <strong class="jm io"> bpftool gen skeleton </strong>类似。</p></blockquote></div><div class="ab cl kr ks hr kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ig ih ii ij ik"><h2 id="9a61" class="ky kz in bd la lb lc dn ld le lf dp lg jv lh li lj jz lk ll lm kd ln lo lp lq bi translated">C 和 eBPF 中的一些技术细节</h2><p id="d63d" class="pw-post-body-paragraph jk jl in jm b jn lr jp jq jr ls jt ju jv lt jx jy jz lu kb kc kd lv kf kg kh ig bi translated">eBPF 程序是用 C 语言编写的，到目前为止，我们还不能自由地编写程序。可以查看<strong class="jm io"> eBPF C 程序</strong> <a class="ae kq" href="https://github.com/fbac/sklookup-go/tree/main/pkg/ebpf/src" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io">这里</strong> </a>。这就是 sk_lookup 程序，它作为<strong class="jm io"> sklookup-go </strong>的后端。</p><p id="7b64" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">实现是基于<a class="ae kq" href="https://github.com/jsitnicki/ebpf-summit-2020/blob/master/echo_dispatch.bpf.c" rel="noopener ugc nofollow" target="_blank">这个</a> <a class="ae kq" href="https://github.com/jsitnicki" rel="noopener ugc nofollow" target="_blank"> Jakub Sitnicki </a>代码的，尽管我改变了地图以支持 BTF(我们将在下一篇文章中讨论)</p><p id="d92e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">此外，重要的是要提到用户通过加载到内核内存中的<a class="ae kq" href="https://www.kernel.org/doc/html/latest/bpf/maps.html" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> eBPF 映射</strong> </a>与 eBPF 程序交互，这是用户能够在用户空间和内核之间共享信息的方式，也是我们将在 Go 库中做的事情。</p><p id="1a4b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下面两张地图是神奇之处:</p><ul class=""><li id="be21" class="lw lx in jm b jn jo jr js jv ly jz lz kd ma kh mb mc md me bi translated">在<strong class="jm io">散列表</strong>中，最多存储 1024 个 key:value。关键是实际的端口号，我们不关心它的值。</li><li id="c7fe" class="lw lx in jm b jn mf jr mg jv mh jz mi kd mj kh mb mc md me bi translated">在<strong class="jm io"> sockMap </strong>中，key 0 处只能有一个值；目标套接字的文件描述符。</li></ul><pre class="kj kk kl km gt mr ms mt mu aw mv bi"><span id="b2df" class="ky kz in ms b gy mw mx l my mz">/* List of additional service ports. Key is the port number. */<br/>struct { <br/>  __uint(type, BPF_MAP_TYPE_HASH); <br/>  __type(key, __u16); <br/>  __type(value, __u8); <br/>  __uint(max_entries, 1024);} <br/>add_ports SEC(".maps");</span><span id="6e51" class="ky kz in ms b gy na mx l my mz">/* Target socket */<br/>struct { <br/>  __uint(type, BPF_MAP_TYPE_SOCKMAP); <br/>  __type(key, __u32); <br/>  __type(value, __u64); <br/>  __uint(max_entries, 1);} <br/>target_socket SEC(".maps");</span></pre><h2 id="5d72" class="ky kz in bd la lb lc dn ld le lf dp lg jv lh li lj jz lk ll lm kd ln lo lp lq bi translated">最后，去敲打</h2><p id="2d55" class="pw-post-body-paragraph jk jl in jm b jn lr jp jq jr ls jt ju jv lt jx jy jz lu kb kc kd lv kf kg kh ig bi translated">到目前为止，您可能已经注意到，我没有将 C 代码显式编译成 ELF 二进制文件，尽管我们需要它来运行 eBPF 程序。</p><p id="6789" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以看一下<strong class="jm io"> ebpf.go </strong>，特别是这一点:</p><pre class="kj kk kl km gt mr ms mt mu aw mv bi"><span id="c009" class="ky kz in ms b gy mw mx l my mz">//go:generate go run github.com/cilium/ebpf/cmd/bpf2go -cc $BPF_CLANG -cflags $BPF_CFLAGS bpf src/ebpf/sk_dispatch.c -- -Isrc/headers</span></pre><p id="bf6f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这一行调用<strong class="jm io"> bpf2go </strong>，并分别为 Big 和 Little Endian 生成所需的 ELF 和两个 go 文件<strong class="jm io"> bpf_bpfeb.go </strong>和<strong class="jm io"> bpf_bpfel.go </strong>，其中包含您需要从 go 代码中调用的所有函数。</p><p id="aaaa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">ebpf.go 上的代码是主要魔力所在，它处理相当多的东西:</p><ul class=""><li id="ee27" class="lw lx in jm b jn jo jr js jv ly jz lz kd ma kh mb mc md me bi translated">它加载需要加载到内核内存中的 BPF 对象(地图和程序)。</li><li id="3467" class="lw lx in jm b jn mf jr mg jv mh jz mi kd mj kh mb mc md me bi translated">它<strong class="jm io">销()</strong>这些物体进入系统。</li></ul><blockquote class="mk ml mm"><p id="8157" class="jk jl mn jm b jn jo jp jq jr js jt ju mo jw jx jy mp ka kb kc mq ke kf kg kh ig bi translated">()中的 P <!-- -->是用于创建文件的方法，eBPF 图将在该文件中被访问。它需要一个 BPF 文件系统，通常是/sys/fs/bpf。</p></blockquote><ul class=""><li id="275d" class="lw lx in jm b jn jo jr js jv ly jz lz kd ma kh mb mc md me bi translated">另外，<strong class="jm io">不要忘记</strong>到 U <strong class="jm io"> npin() </strong>和<strong class="jm io"> Close() </strong>使用后的地图和程序，否则会将地图和程序留在 fs 中。</li><li id="c0d9" class="lw lx in jm b jn mf jr mg jv mh jz mi kd mj kh mb mc md me bi translated">它创建了<a class="ae kq" href="https://github.com/fbac/sklookup-go/blob/main/pkg/ebpf/ebpf.go#L269" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> dispatcher 链接</strong> </a>，克隆了调用者网络命名空间，所以进程之间的通信是可以发生的。</li></ul><pre class="kj kk kl km gt mr ms mt mu aw mv bi"><span id="a86c" class="ky kz in ms b gy mw mx l my mz">func getDispatcherLink(p *ebpf.Program) (*link.NetNsLink, error) {<br/> // Get self net-namespace<br/> netns, err := os.Open("/proc/self/ns/net")<br/> if err != nil {<br/>  return nil, err<br/> }<br/> defer netns.Close()</span><span id="184f" class="ky kz in ms b gy na mx l my mz">// Attach the network namespace to the link<br/> lnk, err := link.AttachNetNs(int(netns.Fd()), p)<br/> if err != nil {<br/>  return nil, err<br/> }</span><span id="5069" class="ky kz in ms b gy na mx l my mz">return lnk, nil<br/>}</span></pre><ul class=""><li id="8b27" class="lw lx in jm b jn jo jr js jv ly jz lz kd ma kh mb mc md me bi translated">当将<a class="ae kq" href="https://github.com/fbac/sklookup-go/blob/main/pkg/ebpf/ebpf.go#L237" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io">附加到外部进程</strong> </a>时，程序还会执行一个<strong class="jm io"> pidfd_getfd(pidfd_open(PID，o)，fd，0) </strong>的系统调用，以复制目标套接字的文件描述符，这样它就可以被我们的调用程序使用。它看起来像下面这样:</li></ul><pre class="kj kk kl km gt mr ms mt mu aw mv bi"><span id="0f67" class="ky kz in ms b gy mw mx l my mz">func (e *EbpfExternalDispatcher) getListenerFd() uintptr {<br/> // pidfd_open<br/> pidFd, err := pidfd.Open(e.TargetPID, 0)<br/> if err != nil {<br/>  e.Log.Panic().Err(err).Msgf("Unable to open target pid %v", e.TargetPID)<br/> }<br/> e.Log.Trace().Msgf("getListenerFd.pidFd: %v", pidFd)</span><span id="3dbf" class="ky kz in ms b gy na mx l my mz">// pidfd_getfd<br/> listenFd, err := pidFd.GetFd(int(pidFd), 0)<br/> if err != nil {<br/>  e.Log.Panic().Err(err).Msgf("Unable to duplicate target fd %v", pidFd)<br/> }<br/> e.Log.Trace().Msgf("getListenerFd.listenFd: %v", listenFd)</span><span id="fc1f" class="ky kz in ms b gy na mx l my mz">file := os.NewFile(uintptr(listenFd), "")</span><span id="ce23" class="ky kz in ms b gy na mx l my mz">return file.Fd()<br/>}</span></pre><ul class=""><li id="5699" class="lw lx in jm b jn jo jr js jv ly jz lz kd ma kh mb mc md me bi translated">最后，它处理添加目标套接字的文件描述符，添加要使用的源端口，以及一些样板代码。</li></ul></div><div class="ab cl kr ks hr kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ig ih ii ij ik"><h2 id="ee43" class="ky kz in bd la lb lc dn ld le lf dp lg jv lh li lj jz lk ll lm kd ln lo lp lq bi translated">包扎</h2><p id="220f" class="pw-post-body-paragraph jk jl in jm b jn lr jp jq jr ls jt ju jv lt jx jy jz lu kb kc kd lv kf kg kh ig bi translated">这个库正在大量开发中，现在是 v 0 . 1 . 0-alpha 版本，因为这是我推出的第一个迭代。</p><p id="107e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我写这个的时候很兴奋，并且已经写了一个基于它的 TCP 代理(这很有效！).所以，如果你对 eBPF 和 Go 感兴趣，欢迎使用这个包，修改，贡献。</p><p id="deda" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">总之，我对 eBPF 技术和我们将来会看到的用例非常感兴趣。通常内核开发进展缓慢，也是创建内核模块并将其推向稳定并被社区广泛采用的过程。</p><p id="bc0f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有了这项技术，我相信我们将会看到令人惊叹的项目做一些很酷的事情，从 SDN 开始，到安全和许多其他用例。</p><p id="e5bf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">保持好奇！</strong></p></div></div>    
</body>
</html>