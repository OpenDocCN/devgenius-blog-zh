<html>
<head>
<title>Django — Extended pagination</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Django —扩展分页</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/django-extended-pagination-36e18e21d10d?source=collection_archive---------10-----------------------#2022-01-04">https://blog.devgenius.io/django-extended-pagination-36e18e21d10d?source=collection_archive---------10-----------------------#2022-01-04</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div class="gh gi jk"><img src="../Images/a246a5cab9cfc17f0b8561aeea670a1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:758/format:webp/1*rAfA_5kNpm_6UlaO0HjCHg.png"/></div></figure><p id="d404" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">一般来说，大多数Django教程和书籍都很浅地触及了分页这个主题。当然，出于本文的目的，我将跳过使用Django模板有点过时这一点，最好是使用Django作为后端引擎。简而言之，现在让我们言归正传。</p><h1 id="754e" class="kp kq in bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated"><strong class="ak">假设</strong></h1><p id="c00d" class="pw-post-body-paragraph jr js in jt b ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk lr km kn ko ig bi translated">让我们假设我们正在创建一个基于CBV的简单细节视图，例如显示某种电子产品制造商品牌的信息。</p><p id="6de2" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><em class="ls">举例:</em></p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="4bd3" class="mc kq in ly b gy md me l mf mg">class BrandDetailView<em class="ls">(</em>DetailView<em class="ls">)</em>:<br/>    model = Brand<br/>    context_object_name = 'brand'<br/>    template_name = 'brands/brand_detail.html'</span></pre><p id="e0e1" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">我们怎么能假设每个品牌都有一个产品列表，我们希望在同一个页面上显示品牌的详细信息。</p><h1 id="ff9d" class="kp kq in bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">扩展DetailView并添加分页</h1><p id="08f1" class="pw-post-body-paragraph jr js in jt b ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk lr km kn ko ig bi translated">好，所以在这篇文章的开始，我们能够让我们的假设更精确。现在让我们继续实施我们的想法。</p><p id="055d" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">如果现在每个品牌都有产品，我们可以尝试先检索它们。为此，我们将通过覆盖<em class="ls"> get_context_data </em>方法<em class="ls">来扩展我们的<em class="ls"> BrandDetailView </em>。</em>我希望你对此很熟悉，但如果不熟悉，你可以在Django官方<a class="ae mh" href="https://docs.djangoproject.com/en/3.2/topics/class-based-views/generic-display/#adding-extra-context" rel="noopener ugc nofollow" target="_blank">文档</a>中阅读更多内容。</p><figure class="lt lu lv lw gt jo"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="ffeb" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">好了，看来现在我们可以在BrandDetailPage上列出所有品牌的产品了。但是本文的主题是分页，所以让我们扩展一些产品的假设。所以让我们假设一个品牌可以有成百上千种产品，对吗？</p><p id="b304" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">在一个页面上向用户提供如此大量的数据一点也不优雅。因此，最好的方法是将我们的产品包装到Django Paginator类中。</p><figure class="lt lu lv lw gt jo"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="0b73" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">此外，我还在代码中添加了一些注释，使其不言自明。</p><p id="0092" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">快好了！现在我们必须在HTML模板中处理分页，为此，我将使用文档中的一个简单模板。但是请注意，我们的Paginatior对象现在是上下文管理器的“产品”。</p><figure class="lt lu lv lw gt jo"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="d874" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io">额外糖:</strong></p><p id="1551" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">上面的例子非常简单，对于大量的产品，Django将对每个产品进行额外的数据库查询，例如，如果我们有1000个属于Brand的产品，那么Django将进行1000次以上的查询。这似乎不是一个有效的解决办法，不是吗？那么，如何防止数据库中的查询过度扩展呢？我再次简化了解决方案，但是Django让我们准备好使用依赖于模型之间关系的解决方案。您可以阅读更多关于select_related和prefetch_related的内容。</p><p id="bcb8" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">对于我们的示例，如果我们假设该品牌有许多产品，那么我们的model.py将如下所示:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="7473" class="mc kq in ly b gy md me l mf mg">class Brand<em class="ls">(</em>models.Model<em class="ls">)</em>:<br/>    name = models.CharField<em class="ls">()<br/><br/></em>class Product<em class="ls">(</em>models.Model<em class="ls">)</em>:<br/>    brand = models.ForeignKey<em class="ls">(</em>Brand, on_delete=models.CASCADE<em class="ls">)</em></span></pre><p id="29d0" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">首先，我将覆盖get_queryset方法并添加几行附加代码，这样最终的有效代码将如下所示:</p><figure class="lt lu lv lw gt jo"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="b8c1" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">我希望通过这种简单的方式，我能够消除您对创建分页器对象的疑虑。</p><p id="8881" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">别忘了订阅我！:)</p></div></div>    
</body>
</html>