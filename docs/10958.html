<html>
<head>
<title>Recursion Algorithm: Definition, Comparisons vs loop, When to use, and How to implement it</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">递归算法:定义、比较与循环、何时使用以及如何实现</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/recursion-algorithm-definition-comparisons-vs-loop-when-to-use-and-how-to-implement-it-69a4d86f5f61?source=collection_archive---------8-----------------------#2022-12-10">https://blog.devgenius.io/recursion-algorithm-definition-comparisons-vs-loop-when-to-use-and-how-to-implement-it-69a4d86f5f61?source=collection_archive---------8-----------------------#2022-12-10</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="7907" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这篇文章中，我将讨论递归。我们将了解递归的定义，递归和循环的比较，何时使用递归，以及如何在 golang 中实现递归。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9cac5b95fc4502c94eb9b47a4c723247.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mbKBjw3vWQCMG5ejGWeiWQ.png"/></div></div></figure><h1 id="5f1d" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">介绍</h1><p id="7887" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">递归是函数调用自己。当一个函数被调用时，它将被存储在一个堆栈中，如果最后一个函数结束或返回，该函数将从堆栈中弹出。无休止的递归会导致堆栈溢出，这是一种当我们的内存没有剩余空间时的情况。为了实现递归，我们必须注意这三条规则:</p><ul class=""><li id="5247" class="lx ly in jm b jn jo jr js jv lz jz ma kd mb kh mc md me mf bi translated">确定基本案例</li><li id="0485" class="lx ly in jm b jn mg jr mh jv mi jz mj kd mk kh mc md me mf bi translated">识别递归情况</li><li id="730c" class="lx ly in jm b jn mg jr mh jv mi jz mj kd mk kh mc md me mf bi translated">越走越近，需要的时候再回来。通常，你有两个回报。</li></ul><h2 id="fba0" class="ml kv in bd kw mm mn dn la mo mp dp le jv mq mr li jz ms mt lm kd mu mv lq mw bi translated">递归与迭代</h2><p id="7f77" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">基本上，用递归可以做的任何事情都可以迭代完成(循环)。下面是递归算法的优点和缺点。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mx"><img src="../Images/16c93b8e44624c869e29edbd8cae35ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WIwcWOIlQ3HE0mz4WpzO-Q.png"/></div></div></figure><h2 id="4086" class="ml kv in bd kw mm mn dn la mo mp dp le jv mq mr li jz ms mt lm kd mu mv lq mw bi translated">何时使用递归</h2><p id="9833" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">每当你使用树或者把东西转换成树的时候，考虑使用递归。递归适用于以下情况:</p><ul class=""><li id="2aee" class="lx ly in jm b jn jo jr js jv lz jz ma kd mb kh mc md me mf bi translated">分成许多子问题，这些子问题是同一问题的较小实例</li><li id="a424" class="lx ly in jm b jn mg jr mh jv mi jz mj kd mk kh mc md me mf bi translated">子问题的每个实例本质上都是相同的</li><li id="207c" class="lx ly in jm b jn mg jr mh jv mi jz mj kd mk kh mc md me mf bi translated">每个子问题的解决方案可以组合起来解决手头的问题</li></ul><h1 id="7e40" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">如何使用递归:斐波那契数列研究案例</h1><p id="9cc9" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">斐波纳契数列是一系列数字，其中 I 处的数字是它前面两个数字的和。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi my"><img src="../Images/204480adb08563ec72e6911ee825f6ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:906/0*JUCrj8F-2jWeN71z"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mz"><img src="../Images/81f1808ac4a1b98961282bf9c81a1f62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IrgvkcmhsGlasbn1"/></div></div></figure><h2 id="7484" class="ml kv in bd kw mm mn dn la mo mp dp le jv mq mr li jz ms mt lm kd mu mv lq mw bi translated">递归的</h2><p id="81a5" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">要用递归创建斐波那契数列，我们必须确定何时需要返回。在这种情况下，当索引小于 2 时，只返回 1，因为我们不想添加 0。如果索引大于 2，则返回索引-1 和索引-2 之和的两个函数。在下面的例子中，我们想得到索引为 6 的斐波那契数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/1edfa39f6891ce76f60d1e6cb0423957.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wDU7QLi8IyqTy6or"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/f8908992c6b21ea8b63e60613c744089.png" data-original-src="https://miro.medium.com/v2/resize:fit:586/0*b3_FaCndntn6qJFi"/></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk translated">输出</figcaption></figure><p id="2bf4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是，使用递归函数有一个缺点，那就是被调用的函数的数量。看下面的图片，仅仅为了得到一个索引为 5 的斐波那契数，我们必须调用 15 个函数，这些函数并不是真正高效的。想象一下，如果我们想得到指数大于 10 的斐波那契数，我们会有很多调用栈，这会导致栈溢出。斐波那契递归的时间复杂度是 O(2^n)</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/ad51649f08c3d428a2cd980e988dab13.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/0*4KdPbP1aW4EmFHXE"/></div></figure><h2 id="d129" class="ml kv in bd kw mm mn dn la mo mp dp le jv mq mr li jz ms mt lm kd mu mv lq mw bi translated">环</h2><p id="c438" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">要创建一个具有循环的斐波那契数列，首先，我们必须存储两个第一数字 0 和 1。然后，迭代并将 y 处的当前数字移动到 x，并将 x 和 y 的和存储在 y 中。完成此操作后，返回 x，因为 y 与 1 个索引重叠。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/3dc5f55e7e0e488d4e0b34fbbb2a0830.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*t0UHqKaCpXaP_nVr"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/f33003d7330f5976d97ab0183f757365.png" data-original-src="https://miro.medium.com/v2/resize:fit:566/0*v_bGgKatweyYZcXr"/></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk translated">输出</figcaption></figure><p id="7aa6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">循环的缺点是它不是真正可读的。理解背后的逻辑需要时间。但是循环的优点是性能更好，效率更高，因为时间复杂度是 O(n)。</p><h1 id="b706" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">结论</h1><p id="7476" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">递归是函数调用自己。递归的优点是它是可读的，当我们有一个可以分成子问题的问题，并且每个子问题都是相同的时候，使用它是很好的。递归的缺点是调用堆栈太大，会导致堆栈溢出。</p></div></div>    
</body>
</html>