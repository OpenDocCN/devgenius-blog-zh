<html>
<head>
<title>Linux — Zero Copy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Linux —零拷贝</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/linux-zero-copy-d61d712813fe?source=collection_archive---------0-----------------------#2022-08-22">https://blog.devgenius.io/linux-zero-copy-d61d712813fe?source=collection_archive---------0-----------------------#2022-08-22</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><div class=""><h2 id="f85e" class="pw-subtitle-paragraph jo iq ir bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated">什么是零拷贝，它是如何工作的？</h2></div><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj kg"><img src="../Images/333fae9516d949544aae664871337fc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k2smmvxDHVNLW7KSCbvrvw.png"/></div></div></figure><p id="eb51" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">许多 Web 应用程序提供大量的静态内容，这相当于从磁盘读取数据并将完全相同的数据写回响应套接字。每次数据穿越用户-内核边界时，都必须进行复制，这会消耗 CPU 周期和内存带宽。</p><p id="581d" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">零拷贝技术的作用是消除内核和用户空间之间所有不必要的拷贝。无论是卡夫卡还是内蒂，都是运用了零复制的知识。那么零拷贝到底是什么？让我们在这篇文章中探索一下。</p><h1 id="52a8" class="lo lp ir bd lq lr ls lt lu lv lw lx ly jx lz jy ma ka mb kb mc kd md ke me mf bi translated">什么是零拷贝</h1><ul class=""><li id="8d6c" class="mg mh ir ku b kv mi ky mj lb mk lf ml lj mm ln mn mo mp mq bi translated">“零”:表示复制数据的次数为 0。</li><li id="7bc2" class="mg mh ir ku b kv mr ky ms lb mt lf mu lj mv ln mn mo mp mq bi translated">“拷贝”:是指将数据从一个存储区转移到另一个存储区。</li></ul><p id="926f" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">所以，如果把“零”和“复制”两个词放在一起，“零复制”是指当计算机执行 IO 操作时，CPU 不需要将数据从一个存储区域复制到另一个存储区域，从而减少上下文切换和 CPU 复制时间。它是一种 IO 操作优化技术。</p><h1 id="4896" class="lo lp ir bd lq lr ls lt lu lv lw lx ly jx lz jy ma ka mb kb mc kd md ke me mf bi translated">传统 IO 的执行过程</h1><p id="790e" class="pw-post-body-paragraph ks kt ir ku b kv mi js kx ky mj jv la lb mw ld le lf mx lh li lj my ll lm ln ik bi translated">例如，如果要实现下载功能，服务器的任务是从连接的套接字发送服务器主机磁盘中的文件。关键代码如下:</p><pre class="kh ki kj kk gu mz na nb nc aw nd bi"><span id="fe2d" class="ne lp ir na b gz nf ng l nh ni">while((n = read(diskfd, buf, BUF_SIZE)) &gt; 0)<br/>    write(sockfd, buf , n);</span></pre><p id="c1dd" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">传统的 IO 过程包括读取和写入过程</p><ul class=""><li id="233f" class="mg mh ir ku b kv kw ky kz lb nj lf nk lj nl ln mn mo mp mq bi translated">读取:从磁盘读取数据到内核缓冲区，复制到用户缓冲区</li><li id="91c4" class="mg mh ir ku b kv mr ky ms lb mt lf mu lj mv ln mn mo mp mq bi translated">写:先把数据写到 socket 缓冲区，最后写到网卡设备</li></ul><p id="64d4" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">整个流程看起来像:</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj nm"><img src="../Images/456d61486b28e380f9c3711d5acd5c2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-MMXU-oClpK9PgnBerY20w.png"/></div></div></figure><ul class=""><li id="c0b6" class="mg mh ir ku b kv kw ky kz lb nj lf nk lj nl ln mn mo mp mq bi translated">应用程序调用<code class="fe nn no np na b">read</code>函数，发起对操作系统的 IO 调用，上下文从用户模式切换到内核模式</li><li id="1879" class="mg mh ir ku b kv mr ky ms lb mt lf mu lj mv ln mn mo mp mq bi translated">DMA 控制器将数据从磁盘读取到内核缓冲区</li><li id="6b39" class="mg mh ir ku b kv mr ky ms lb mt lf mu lj mv ln mn mo mp mq bi translated">CPU 读取内核缓冲区并将数据复制到用户应用程序缓冲区，上下文从内核模式切换到用户模式，read 函数返回</li><li id="ab73" class="mg mh ir ku b kv mr ky ms lb mt lf mu lj mv ln mn mo mp mq bi translated">用户应用进程通过 write 函数发起 IO 调用，上下文从用户态切换到内核态<br/>并将数据复制到 socket buffer</li><li id="d965" class="mg mh ir ku b kv mr ky ms lb mt lf mu lj mv ln mn mo mp mq bi translated">DMA 控制器将数据从套接字缓冲区复制到网卡设备，上下文从内核模式切换到用户模式，此时写功能返回</li></ul><p id="622b" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">从流程图可以看出，传统的 IO 过程包括 4 次上下文切换，4 次复制数据(两次 CPU 复制和两次 DMA 复制)。</p><h1 id="b3c7" class="lo lp ir bd lq lr ls lt lu lv lw lx ly jx lz jy ma ka mb kb mc kd md ke me mf bi translated">内核空间与用户空间</h1><p id="0460" class="pw-post-body-paragraph ks kt ir ku b kv mi js kx ky mj jv la lb mw ld le lf mx lh li lj my ll lm ln ik bi translated">运行在服务器上的应用程序需要通过操作系统来执行一些特殊的操作，比如磁盘文件的读写，内存的读写等等。</p><p id="76d2" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">因为这些都是比较危险的操作，不能被应用搞砸，只能交给底层操作系统。</p><p id="9940" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">因此，操作系统为用户应用程序分配两个内存空间:用户空间和内核空间。</p><ul class=""><li id="6940" class="mg mh ir ku b kv kw ky kz lb nj lf nk lj nl ln mn mo mp mq bi translated">内核空间:主要提供进程调度、内存分配、硬件资源连接等功能。</li><li id="cdcd" class="mg mh ir ku b kv mr ky ms lb mt lf mu lj mv ln mn mo mp mq bi translated">用户空间:提供给每个程序进程的空间。它没有访问内核空间资源的权限。如果应用程序需要使用内核空间的资源，它需要通过一个系统调用。进程从用户空间切换到内核空间，完成相关操作后，从内核空间切换回用户空间。</li></ul><h2 id="b40f" class="ne lp ir bd lq nq nr dn lu ns nt dp ly lb nu nv ma lf nw nx mc lj ny nz me oa bi translated">用户模式和内核模式</h2><ul class=""><li id="6037" class="mg mh ir ku b kv mi ky mj lb mk lf ml lj mm ln mn mo mp mq bi translated">如果一个进程运行在内核空间，它被称为进程的内核状态。</li><li id="474b" class="mg mh ir ku b kv mr ky ms lb mt lf mu lj mv ln mn mo mp mq bi translated">如果一个进程运行在用户空间，它被称为进程的用户空间。</li></ul><h1 id="1923" class="lo lp ir bd lq lr ls lt lu lv lw lx ly jx lz jy ma ka mb kb mc kd md ke me mf bi translated">直接存储器存取</h1><p id="1451" class="pw-post-body-paragraph ks kt ir ku b kv mi js kx ky mj jv la lb mw ld le lf mx lh li lj my ll lm ln ik bi translated">DMA 代表直接内存访问。它本质上是主板上的一个独立芯片，允许外围设备和内存存储之间的直接 IO 数据传输，并且该过程不需要 CPU 的参与。</p><p id="729a" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">简单来说就是帮助 CPU 转发 IO 请求，复制数据，那为什么需要它呢？其实主要是效率的问题。它帮助中央处理器做事情。这时候 CPU 就可以空闲下来做别的事情，提高了 CPU 的利用效率。</p><p id="97ec" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">让我们来看看这个过程:</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj ob"><img src="../Images/7867d235d93aac006fe888329c68870b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-vT8uju7sgJn5JiAkSHsMQ.png"/></div></div></figure><ul class=""><li id="c9cd" class="mg mh ir ku b kv kw ky kz lb nj lf nk lj nl ln mn mo mp mq bi translated">用户应用调用 read 函数，向操作系统发起 IO 调用，进入阻塞状态等待数据返回。</li><li id="8934" class="mg mh ir ku b kv mr ky ms lb mt lf mu lj mv ln mn mo mp mq bi translated">在 CPU 接收到指令后，它向 DMA 控制器发起指令调度。</li><li id="47cd" class="mg mh ir ku b kv mr ky ms lb mt lf mu lj mv ln mn mo mp mq bi translated">DMA 收到请求后，将请求发送到磁盘</li><li id="fc27" class="mg mh ir ku b kv mr ky ms lb mt lf mu lj mv ln mn mo mp mq bi translated">磁盘将数据放入磁盘控制缓冲区，并通知 DMA</li><li id="460e" class="mg mh ir ku b kv mr ky ms lb mt lf mu lj mv ln mn mo mp mq bi translated">DMA 将数据从磁盘控制器缓冲区复制到内核缓冲区</li><li id="fc9e" class="mg mh ir ku b kv mr ky ms lb mt lf mu lj mv ln mn mo mp mq bi translated">DMA 向 CPU 发送数据读取信号，CPU 负责将数据从内核缓冲区复制到用户缓冲区</li><li id="02ad" class="mg mh ir ku b kv mr ky ms lb mt lf mu lj mv ln mn mo mp mq bi translated">用户应用程序进程从内核状态切换到用户状态，并解除状态阻塞</li></ul><h1 id="5a61" class="lo lp ir bd lq lr ls lt lu lv lw lx ly jx lz jy ma ka mb kb mc kd md ke me mf bi translated">如何实现零拷贝</h1><p id="11b8" class="pw-post-body-paragraph ks kt ir ku b kv mi js kx ky mj jv la lb mw ld le lf mx lh li lj my ll lm ln ik bi translated">理解了 DMA 的工作原理之后，让我们来讨论一下零拷贝是如何实现的。首先，零拷贝并不意味着不拷贝数据，而是减少了用户态和内核态切换的次数和 CPU 拷贝的数量；实现零拷贝有两种主要方法:</p><ul class=""><li id="7938" class="mg mh ir ku b kv kw ky kz lb nj lf nk lj nl ln mn mo mp mq bi translated"><strong class="ku is">方法一:</strong> mmap + write</li><li id="4a4a" class="mg mh ir ku b kv mr ky ms lb mt lf mu lj mv ln mn mo mp mq bi translated"><strong class="ku is">方法二:</strong>发送文件</li></ul><h2 id="41fb" class="ne lp ir bd lq nq nr dn lu ns nt dp ly lb nu nv ma lf nw nx mc lj ny nz me oa bi translated">mmap +写</h2><p id="9b62" class="pw-post-body-paragraph ks kt ir ku b kv mi js kx ky mj jv la lb mw ld le lf mx lh li lj my ll lm ln ik bi translated">mmap 的功能原型如下</p><pre class="kh ki kj kk gu mz na nb nc aw nd bi"><span id="cc3a" class="ne lp ir na b gz nf ng l nh ni">void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);</span></pre><p id="9ee7" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">mmap+write 实现的零拷贝过程如下:</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj oc"><img src="../Images/c558a2d960b6bc16f89391dfaccc50ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vnjW6EA8ydyg6GmXznQd2A.png"/></div></div></figure><p id="7bf6" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">与<code class="fe nn no np na b">read()</code>调用相比，这里的主要区别是用户进程通过调用<strong class="ku is"> mmap 方法</strong>向操作系统内核发起 IO 调用，上下文从用户模式切换到内核模式，然后 CPU 使用 DMA 控制器将数据从硬盘复制到内核缓冲区。主要步骤是:</p><ul class=""><li id="f04d" class="mg mh ir ku b kv kw ky kz lb nj lf nk lj nl ln mn mo mp mq bi translated">用户进程通过调用 mmap 方法发起对操作系统内核的 IO 调用，上下文从用户模式切换到内核模式</li><li id="2484" class="mg mh ir ku b kv mr ky ms lb mt lf mu lj mv ln mn mo mp mq bi translated">CPU 使用 DMA 控制器将数据从硬盘复制到内核缓冲区</li><li id="4bf5" class="mg mh ir ku b kv mr ky ms lb mt lf mu lj mv ln mn mo mp mq bi translated">上下文从内核状态切换到用户状态，mmap 方法返回</li><li id="4479" class="mg mh ir ku b kv mr ky ms lb mt lf mu lj mv ln mn mo mp mq bi translated">用户进程通过调用 write 方法再次对操作系统内核进行 IO 调用，上下文从用户状态切换到<br/>内核状态。到套接字缓冲区</li><li id="1935" class="mg mh ir ku b kv mr ky ms lb mt lf mu lj mv ln mn mo mp mq bi translated">CPU 使用 DMA 控制器将数据从套接字缓冲区复制到网卡，上下文从内核模式切换到用户模式，写方法返回</li></ul><p id="631d" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">可以发现 mmap+write 实现的零拷贝有 4 个上下文切换和 3 个拷贝(2 个 DMA 拷贝+ 1 个 cpu 拷贝)</p><h2 id="467b" class="ne lp ir bd lq nq nr dn lu ns nt dp ly lb nu nv ma lf nw nx mc lj ny nz me oa bi translated">发送文件()</h2><p id="dab0" class="pw-post-body-paragraph ks kt ir ku b kv mi js kx ky mj jv la lb mw ld le lf mx lh li lj my ll lm ln ik bi translated"><code class="fe nn no np na b">sendfile</code>是 Linux 版以后内核引入的系统调用函数。原型如下</p><pre class="kh ki kj kk gu mz na nb nc aw nd bi"><span id="0abe" class="ne lp ir na b gz nf ng l nh ni">ssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count);</span></pre><p id="66df" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated"><strong class="ku is"> sendfile 是指在两个文件描述符之间传递数据，它在操作系统内核中运行，避免了从内核缓冲区和用户缓冲区复制数据的操作，因此可以用来实现零复制</strong>。流程看起来像:</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj od"><img src="../Images/a45e3dadc787a3d59fa7c702a8b53ce4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OpEZL1jpvtGJ7IFIGS3xzg.png"/></div></div></figure><ul class=""><li id="c044" class="mg mh ir ku b kv kw ky kz lb nj lf nk lj nl ln mn mo mp mq bi translated">用户进程启动 sendfile 系统调用，上下文从用户模式切换到内核模式</li><li id="d57c" class="mg mh ir ku b kv mr ky ms lb mt lf mu lj mv ln mn mo mp mq bi translated">DMA 控制器将数据从硬盘复制到内核缓冲区</li><li id="b813" class="mg mh ir ku b kv mr ky ms lb mt lf mu lj mv ln mn mo mp mq bi translated">CPU 将读缓冲区中的数据复制到套接字缓冲区</li><li id="ff08" class="mg mh ir ku b kv mr ky ms lb mt lf mu lj mv ln mn mo mp mq bi translated">DMA 控制器将数据从套接字缓冲区异步复制到网卡</li><li id="0b6a" class="mg mh ir ku b kv mr ky ms lb mt lf mu lj mv ln mn mo mp mq bi translated">上下文从内核模式切换到用户模式，sendfile 函数返回</li></ul><p id="a5d7" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">可以发现 sendfile 实现的零拷贝只有 2 个上下文切换和 3 个拷贝(2 个 DMA 拷贝+ 1 个 CPU 拷贝)</p></div></div>    
</body>
</html>