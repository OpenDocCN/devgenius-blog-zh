<html>
<head>
<title>Interfaces in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Go 界面</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/interfaces-in-go-a0bab96f1027?source=collection_archive---------8-----------------------#2022-07-18">https://blog.devgenius.io/interfaces-in-go-a0bab96f1027?source=collection_archive---------8-----------------------#2022-07-18</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="8a85" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你打算广泛使用 Go，你需要理解如何使用接口。界面并不是一个特别流行的东西，但是 Go 是这个特性的更广泛的用户之一。接口允许你编写可重用的代码。</p><h1 id="82c8" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">什么是接口？</h1><p id="b1bc" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">接口是将对象分组到它们的公共行为中的一种方式。接口由其名称和对象需要定义的方法来定义。任何定义了这些方法的对象都会“实现”该接口。</p><p id="8e87" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">比如说甲、乙、丙三个学生都会做饭。他们试图给我提供美味的食物。然而，由于 A、B 和 C 都是在不同的厨师手下受训，所以他们烹饪的东西不同。尽管如此，他们都是会做饭的厨师。我们可以说 A、B、C 实现了“chef”接口，因为它们都可以用不同的方式烹饪。</p><p id="707f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们看看这是如何在 Go 中实现的。</p><h1 id="41cf" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">在围棋中如何使用它？</h1><p id="2783" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">下面是上面例子的代码。</p><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="6058" class="lu kj in lq b gy lv lw l lx ly">package main</span><span id="4ba5" class="lu kj in lq b gy lz lw l lx ly">import (<br/>    "fmt"<br/>    "math/rand"<br/>)</span><span id="e604" class="lu kj in lq b gy lz lw l lx ly">type cook interface {<br/>    cookFood()<br/>    getName() string<br/>}</span><span id="7fb5" class="lu kj in lq b gy lz lw l lx ly">type chef struct {<br/>    name    string<br/>    cuisine string<br/>}</span><span id="72b4" class="lu kj in lq b gy lz lw l lx ly">func (c chef) cookFood() {<br/>    result := fmt.Sprintf("%s the professional chef is cooking %s food", c.name, c.cuisine)<br/>    fmt.Println(result)<br/>}</span><span id="240c" class="lu kj in lq b gy lz lw l lx ly">func (c chef) getName() string {<br/>    return c.name<br/>}</span><span id="da66" class="lu kj in lq b gy lz lw l lx ly">type homeCook struct {<br/>    name string<br/>}</span><span id="cdf0" class="lu kj in lq b gy lz lw l lx ly">func (h homeCook) cookFood() {<br/>    result := fmt.Sprintf("%s the home cook is cooking food", h.name)<br/>    fmt.Println(result)<br/>}</span><span id="1699" class="lu kj in lq b gy lz lw l lx ly">func (h homeCook) getName() string {<br/>    return h.name<br/>}</span><span id="5d72" class="lu kj in lq b gy lz lw l lx ly">func serve(c cook) {<br/>    c.cookFood()<br/>    result := fmt.Sprintf("%s: dinner is served!", c.getName())<br/>    fmt.Println(result)<br/>}</span><span id="44f1" class="lu kj in lq b gy lz lw l lx ly">func main() {<br/>    chef1 := chef{"Brian", "Korean"}<br/>    chef2 := chef{"Vincenzo", "Italian"}<br/>    homeCook1 := homeCook{"Amara"}<br/>    homeCook2 := homeCook{"Dana"}</span><span id="507d" class="lu kj in lq b gy lz lw l lx ly">    cooks := []cook{chef1, chef2, homeCook1, homeCook2}</span><span id="550f" class="lu kj in lq b gy lz lw l lx ly">    numCustomers := 100<br/>    for i := 0; i &lt; numCustomers; i++ {<br/>        serve(cooks[rand.Intn(len(cooks))])<br/>    }<br/>}</span></pre><p id="253e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们定义了一个名为<code class="fe ma mb mc lq b">cook</code>的接口。我们希望任何能够扮演<code class="fe ma mb mc lq b">cookFood</code>和<code class="fe ma mb mc lq b">getName</code>的人能够将自己视为<code class="fe ma mb mc lq b">cook</code>。</p><p id="d27e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下面，我们定义两个结构<code class="fe ma mb mc lq b">chef</code>和<code class="fe ma mb mc lq b">homeCook</code>。两者都有<code class="fe ma mb mc lq b">name</code>字段，但是只有<code class="fe ma mb mc lq b">chef</code>有一个<code class="fe ma mb mc lq b">cuisine</code>字段来定义他或她擅长什么菜。</p><p id="70d9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对于实现<code class="fe ma mb mc lq b">cook</code>接口的<code class="fe ma mb mc lq b">chef</code>和<code class="fe ma mb mc lq b">homeCook</code>结构，它们都需要定义<code class="fe ma mb mc lq b">cookFood</code>和<code class="fe ma mb mc lq b">getName</code>方法。实现的细节很简单——只是一个简单的打印语句。</p><p id="e226" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在我们来看看<code class="fe ma mb mc lq b">main</code>函数。我们定义了两个<code class="fe ma mb mc lq b">chef</code>对象<code class="fe ma mb mc lq b">chef1</code>和<code class="fe ma mb mc lq b">chef2</code>。我们还定义了两个<code class="fe ma mb mc lq b">homeCook</code>对象<code class="fe ma mb mc lq b">homeCook1</code>和<code class="fe ma mb mc lq b">homeCook2</code>。这四个对象存储在我们的<code class="fe ma mb mc lq b">cooks</code>切片中，类型为<code class="fe ma mb mc lq b">cook</code>，我们的接口。通常你不能在一个片上存储不同类型的对象，但是使用一个接口可以让我们做到这一点。</p><p id="f768" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们在 for 循环内部调用<code class="fe ma mb mc lq b">serve</code>函数，它接受一个<code class="fe ma mb mc lq b">cook</code>。这通常是行不通的——我们需要定义两个<code class="fe ma mb mc lq b">serve</code>函数，一个用于<code class="fe ma mb mc lq b">chef</code>类型，一个用于<code class="fe ma mb mc lq b">homeCook</code>类型。然而，使用接口有助于我们避免这种重复。</p><p id="c011" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当你的代码库很小的时候，很难理解接口。小项目不需要太多的结构，所以你可以不使用结构。然而，随着项目的增长，接口允许真正干净、可预测的代码。</p><h1 id="1a51" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">它是如何在引擎盖下工作的？</h1><p id="1748" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">界面不仅在设计代码时非常有用，而且在实现时也非常酷。接口可以描述为两个相连的指针块:一个指向类型定义，另一个指向其基础值。很困惑，对吧？看看上面例子中的这一行。</p><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="90a9" class="lu kj in lq b gy lv lw l lx ly">chef1 := chef{"Brian", "Korean"}</span></pre><p id="1569" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ma mb mc lq b">chef1</code>实现了<code class="fe ma mb mc lq b">cook</code>接口。如果我们以接口形式剖析<code class="fe ma mb mc lq b">chef1</code>，第一个指针会指向<code class="fe ma mb mc lq b">chef</code>结构体的类型定义，第二个指针会指向<code class="fe ma mb mc lq b">chef1</code>的实际值。</p><h1 id="749d" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">什么是空接口？</h1><p id="4d45" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">现在我们可以考虑一个更高级，或者更简单的概念:空接口。我们在上面说过，接口通过特定的行为对对象进行分组。空界面会是什么样子？它没有任何类型可以实现的方法。这意味着任何类型的对象都可以实现接口。这就像把活着的人类归为一个类别，叫做“有机体”。年龄、身高、种族和性别并不重要——人类都是有机体。</p><p id="dbbf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">看一下这个片段:</p><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="7e0e" class="lu kj in lq b gy lv lw l lx ly">func main() {<br/>    a := "hello"<br/>    b := 100<br/>    c := 3.14</span><span id="5202" class="lu kj in lq b gy lz lw l lx ly">    objects := []interface{}{a, b, c}<br/>}</span></pre><p id="2a85" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这段代码可以编译，因为<code class="fe ma mb mc lq b">objects</code>是一个存储任何实现空接口的对象的片。</p><h1 id="9c5b" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">技巧</h1><p id="9359" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">在这篇文章的最后，我想和你分享我在短暂的围棋发展历程中积累的一些技巧。</p><ul class=""><li id="5e74" class="md me in jm b jn jo jr js jv mf jz mg kd mh kh mi mj mk ml bi translated">请记住，虽然空接口提供了很大的灵活性，但是您有责任关注不同的可能类型。例如，假设您正在解组一个 JSON 对象。有时，您不知道传入的 JSON 的确切结构。Go 将巧妙地使用类型<code class="fe ma mb mc lq b">map[string]interface{}</code>来解组 JSON 对象。JSON 键将被存储为<code class="fe ma mb mc lq b">string</code>，值将被存储为<code class="fe ma mb mc lq b">interface{}</code>。当操作这个值时，你必须考虑每一个可能的类型，否则你的代码将会失败。这是您在使用空接口时必须缴纳的税款。</li><li id="1b42" class="md me in jm b jn mm jr mn jv mo jz mp kd mq kh mi mj mk ml bi translated">一致地命名你的接口。当我把我的接口命名为<code class="fe ma mb mc lq b">--er</code>时，它帮了我很大的忙。比如<code class="fe ma mb mc lq b">copier</code>、<code class="fe ma mb mc lq b">reader</code>、<code class="fe ma mb mc lq b">parser</code>等。标准库中有一个明显的例外，那就是<code class="fe ma mb mc lq b">builtin.Error</code>接口。我想这是可以的，因为它仍然与其他以<code class="fe ma mb mc lq b">--er</code>结尾的接口押韵。</li><li id="30b6" class="md me in jm b jn mm jr mn jv mo jz mp kd mq kh mi mj mk ml bi translated">将接口和结构/结构方法定义保存在单独的文件中有助于提高可读性。这不是每个人都喜欢的，但我发现这在很多情况下都有帮助。</li><li id="857c" class="md me in jm b jn mm jr mn jv mo jz mp kd mq kh mi mj mk ml bi translated">你不必重新发明轮子。如果你需要一个接口，看看标准库是否已经提供了。您可以实现的一些最常见的方法有<code class="fe ma mb mc lq b">fmt.Stringer</code>、<code class="fe ma mb mc lq b">io.Reader</code>、<code class="fe ma mb mc lq b">io.Writer</code>、<code class="fe ma mb mc lq b">builtin.Error</code>、<code class="fe ma mb mc lq b">http.ResponseWriter</code>、<code class="fe ma mb mc lq b">sort.Interface</code>等。</li><li id="8203" class="md me in jm b jn mm jr mn jv mo jz mp kd mq kh mi mj mk ml bi translated">界面是一把强有力的锤子，但不是每个问题都是钉子。你不需要所有的东西都有一个接口。有时创建一个这样的系统的开销和努力是不值得的。试着在没有界面的情况下构建你的应用，你会遇到一种情况，你希望有一个界面。</li></ul><h1 id="5e18" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">结论</h1><p id="d881" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">我希望这篇文章能帮助你澄清一些关于 Go 接口的不确定性。接口是 Go 编程语言必不可少的一部分，在你的旅途中你无疑会碰到它们。到时候，我相信你能处理好。继续努力，下周我会带着新的帖子来看你。</p><p id="3eba" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这篇文章也可以在<a class="ae mr" href="https://dev.to/jpoly1219/interfaces-in-go-169i" rel="noopener ugc nofollow" target="_blank"> Dev.to </a>和<a class="ae mr" href="https://jpoly1219.github.io" rel="noopener ugc nofollow" target="_blank"> my personal site </a>上看到。</p></div></div>    
</body>
</html>