<html>
<head>
<title>Salts and UUIDs for your PostgreSQL database</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">PostgreSQL 数据库的 Salts 和 UUIDs</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/salts-and-uuids-for-your-postgresql-database-7c144e228097?source=collection_archive---------1-----------------------#2022-11-03">https://blog.devgenius.io/salts-and-uuids-for-your-postgresql-database-7c144e228097?source=collection_archive---------1-----------------------#2022-11-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="f1ad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用 PostgreSQL 数据库时 UUIDs 和密码加盐散列的实际实现步骤。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/9be14d7b6d16a935672a7f0324bd8686.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pygTr5Qto6kXgr9LL0HZDA.png"/></div></div></figure><h1 id="eb18" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">到…里面</h1><p id="f632" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">这篇文章展示了在使用 PostgreSQL 数据库时 UUIDs 和密码加盐散列的实际实现步骤。</p><p id="1734" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将讨论的主题是:</p><ul class=""><li id="ab9b" class="ma mb iq jp b jq jr ju jv jy mc kc md kg me kk mf mg mh mi bi translated">使用数据库、创建新用户和创建 demousers 表</li><li id="93e2" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated">PostgreSQL UUIDs 使用 uuid()函数</li><li id="8450" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated">2 种散列和加盐方法—使用<strong class="jp ir">触发器</strong></li><li id="9d6b" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated">2 个版本的验证存储的<strong class="jp ir">功能</strong></li></ul><h1 id="7bf9" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">先决条件</h1><p id="961c" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">假设你已经理解了基本的数据库概念，<a class="ae mo" href="https://en.wikipedia.org/wiki/Universally_unique_identifier" rel="noopener ugc nofollow" target="_blank"> UUID </a>和<a class="ae mo" href="https://www.okta.com/uk/blog/2019/03/what-are-salted-passwords-and-password-hashing/" rel="noopener ugc nofollow" target="_blank">密码加盐和散列</a>。我之前的帖子对这些主题有所了解:</p><div class="mp mq gp gr mr ms"><a href="https://medium.com/@zzpzaf.se/salts-and-uuids-for-your-databases-intro-41cc58fe100a" rel="noopener follow" target="_blank"><div class="mt ab fo"><div class="mu ab mv cl cj mw"><h2 class="bd ir gy z fp mx fr fs my fu fw ip bi translated">所有数据库的 Salts 和 UUIDs</h2><div class="mz l"><h3 class="bd b gy z fp mx fr fs my fu fw dk translated">这是一篇关于 Salts 和 UUIDs 的介绍性文章，也是我的其他文章中关于如何在…</h3></div><div class="na l"><p class="bd b dl z fp mx fr fs my fu fw dk translated">medium.com</p></div></div><div class="nb l"><div class="nc l nd ne nf nb ng kv ms"/></div></div></a></div><p id="815c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，为了理解本文中的例子，您必须能够访问正在运行的 MariaDB 实例和<a class="ae mo" href="https://www.postgresql.org/docs/current/app-psql.html" rel="noopener ugc nofollow" target="_blank"> psql </a> CLI 工具。[ <a class="ae mo" rel="noopener ugc nofollow" target="_blank" href="/the-database-command-line-tools-you-can-add-to-your-dev-environment-without-database-installation-9091dd0c0277?sk=50026b887181c062144e6fbb9130663e">在这里</a>您可以找到如何将它作为独立工具安装到您的系统中]。如果你愿意的话，你可以看看我下面关于如何创建和开始使用一个<a class="ae mo" href="https://medium.com/@zzpzaf.se/postgresql-database-in-docker-876dc60467e9?sk=f33d8a09e8c1f3a19fe03a2f236fa7e8" rel="noopener"> PostgreSQL 容器</a>的帖子。</p><div class="mp mq gp gr mr ms"><a href="https://medium.com/@zzpzaf.se/postgresql-database-in-docker-876dc60467e9" rel="noopener follow" target="_blank"><div class="mt ab fo"><div class="mu ab mv cl cj mw"><h2 class="bd ir gy z fp mx fr fs my fu fw ip bi translated">Docker 中的 PostgreSQL 数据库</h2><div class="mz l"><h3 class="bd b gy z fp mx fr fs my fu fw dk translated">三分钟指南。轻松全面！</h3></div><div class="na l"><p class="bd b dl z fp mx fr fs my fu fw dk translated">medium.com</p></div></div><div class="nb l"><div class="nh l nd ne nf nb ng kv ms"/></div></div></a></div><h1 id="5ac7" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">开始使用 PostgreSQL 数据库，并创建一个新用户和 demousers 表</h1><p id="b44c" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">通过<a class="ae mo" href="https://www.devxperiences.com/pzwp1/2022/10/30/the-database-command-line-tools-you-can-add-to-your-dev-environment-without-database-installation/#psql" rel="noopener ugc nofollow" target="_blank"> psql </a> CLI 连接到正在运行的 PosgreSQL 实例，使用您喜欢的凭证(用户名和密码)。下面是一个连接到远程实例的示例:</p><pre class="km kn ko kp gt ni nj nk nl aw nm bi"><span id="bc6e" class="nn ky iq nj b gy no np l nq nr">~ psql -h 192.168.0.17 -p 5462 -U postgres -W</span></pre><p id="f832" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后创建一个名为 ticket-management 的新数据库</p><pre class="km kn ko kp gt ni nj nk nl aw nm bi"><span id="2473" class="nn ky iq nj b gy no np l nq nr">postgres=# create database "ticket-management";<br/>postgres=# \c ticket-management;</span></pre><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="9cd9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">之后，创建一个新用户“user1 ”,密码为“upassw1 ”,然后为他分配票证管理数据库的所有权限。</p><pre class="km kn ko kp gt ni nj nk nl aw nm bi"><span id="20d7" class="nn ky iq nj b gy no np l nq nr">CREATE USER user1 WITH PASSWORD 'upassw1';</span></pre><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ns nt l"/></div></figure><pre class="km kn ko kp gt ni nj nk nl aw nm bi"><span id="3200" class="nn ky iq nj b gy no np l nq nr">GRANT CONNECT ON DATABASE "ticket-management" TO user1;<br/>GRANT ALL ON DATABASE "ticket-management" TO user1;</span></pre><p id="f2a3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">之后，注销并重新登录，作为用户 1:</p><pre class="km kn ko kp gt ni nj nk nl aw nm bi"><span id="ea97" class="nn ky iq nj b gy no np l nq nr">~ psql -h 192.168.0.17 -p 5462 -U user1 -W ticket-management</span></pre><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="9c49" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就是这样。现在是时候看看如何在 PostgreSQL 中使用 UUIDs 了。</p><h1 id="4a5a" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">PostgreSQL UUIDs</h1><p id="fd6f" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated"><strong class="jp ir">创建并使用</strong><a class="ae mo" href="https://www.postgresql.org/docs/10/uuid-ossp.html" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">uuid _ ossp</strong></a><strong class="jp ir">扩展</strong></p><p id="0e91" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Postgres 使用扩展。可以使用常规命令在每个特定的数据库中安装扩展:</p><pre class="km kn ko kp gt ni nj nk nl aw nm bi"><span id="7bcf" class="nn ky iq nj b gy no np l nq nr">CREATE EXTENSION <strong class="nj ir">IF</strong> NOT EXISTS “&lt;extension-name&gt;”;</span></pre><p id="cb49" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，为了使用自动生成的 uuid 值作为 id 主键列的默认值，我们必须首先安装<a class="ae mo" href="https://www.postgresql.org/docs/10/uuid-ossp.html" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> uuid-ossp </strong> </a>扩展:</p><pre class="km kn ko kp gt ni nj nk nl aw nm bi"><span id="2483" class="nn ky iq nj b gy no np l nq nr">CREATE EXTENSION <strong class="nj ir">IF</strong> NOT EXISTS “uuid-ossp”;</span></pre><p id="2d61" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，您总是可以使用 psql <strong class="jp ir"> \df </strong>命令来列出所有可用的函数。下面，您可以看到已安装的 uuid 扩展提供的功能:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="e5e8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">创建一个新表 demousers 表</strong></p><p id="ba4c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">PostgreSQL 非常强大，它提供了一个特定的列类型，即<a class="ae mo" href="https://www.postgresql.org/docs/current/datatype-uuid.html" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> uuid </strong> </a>类型，这是将其用作 id 列类型的合适类型。此外，我们将使用之前安装的 uuid 扩展提供的 uuid_generate_v4()函数作为 id 列的默认值。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="11f0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">或者，您可以对用户名和密码字段使用更具体的类型，如 varchar 和 char，而不是一般的文本类型:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="7593" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">表创建后，您可以使用<strong class="jp ir"> \dt </strong> psql 命令检查它是否存在:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="bf8f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，是时候通过添加新用户来测试 uuid 是否工作正常了</p><pre class="km kn ko kp gt ni nj nk nl aw nm bi"><span id="72d0" class="nn ky iq nj b gy no np l nq nr">BEGIN;<br/>INSERT INTO demousers <strong class="nj ir">(</strong>username, password<strong class="nj ir">)</strong> VALUES <strong class="nj ir">('</strong>panos', 'panospassw1<strong class="nj ir">)</strong>;<br/>COMMIT;</span></pre><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="b06b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就是这样！如您所见，自动创建的“<strong class="jp ir">cb5e 9022-f45b-45ea-b9c 6–952428 cc 45 e 8</strong>”UUID 已经作为值正确地插入到 ID 字段中！</p><p id="6c4d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意:正如您可能已经理解的那样，PostgreSQL 为我们提供了 uuid 的“交钥匙”解决方案:uuid 数据类型，以及使用函数作为字段默认值的能力(id 字段的 uuid_generate_v4())，因此不需要实现触发器。</p><p id="8a1b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，我们将需要一个哈希/盐的需求。</p><h1 id="b0cd" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">PostgreSQL 散列和加盐</h1><p id="3214" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated"><strong class="jp ir">添加并使用</strong><a class="ae mo" href="https://www.postgresql.org/docs/current/pgcrypto.html" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">pg crypto</strong></a><strong class="jp ir">扩展名</strong></p><p id="2b65" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">同样，在继续之前，我们需要安装另一个 Postgres 扩展，即<a class="ae mo" href="https://www.postgresql.org/docs/current/pgcrypto.html" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">pg crypto</strong></a><strong class="jp ir"/>扩展。这是必要的，因为<strong class="jp ir"> pgcrypto </strong>包提供了选择和使用散列算法、随机生成值、加盐等所有“标准”功能。</p><p id="6586" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，pgcrypto 扩展还提供了一些非常具体的功能，特别是专用于密码散列和加盐。</p><p id="fbcb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，在这里我们将看到如何实现 2 个触发器和它们的触发器函数，两者都使用:“标准”方式，类似于我们使用 MariaDB 的方法，以及通过 crypt()函数的 PostgreSQL pgcrypto 包。然而，首先，我们必须创建/安装 pgcrypto 扩展:</p><pre class="km kn ko kp gt ni nj nk nl aw nm bi"><span id="0622" class="nn ky iq nj b gy no np l nq nr">CREATE EXTENSION IF NOT EXISTS "pgcrypto";</span></pre><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="5277" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们有了 pgcrypto 扩展之后。我们可以继续创建触发器并使用必要的 pgcrypto 函数。实际上，我们将看到两种方法:</p><h2 id="618a" class="nn ky iq bd kz nu nv dn ld nw nx dp lh jy ny nz ll kc oa ob lp kg oc od lt oe bi translated">使用“标准”方式的第一种方法。</h2><p id="2c76" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">我们将使用以下函数:</p><ul class=""><li id="3635" class="ma mb iq jp b jq jr ju jv jy mc kc md kg me kk mf mg mh mi bi translated">pg crypto<strong class="jp ir">gen _ random _ bytes()</strong>函数生成 8 字节的随机数</li><li id="a791" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated"><strong class="jp ir"> encode() </strong>函数用于将一个字节数转换成十六进制字符串</li><li id="9283" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated"><strong class="jp ir"> concat() </strong>函数用于连接两个或更多的字符串</li><li id="c57e" class="ma mb iq jp b jq mj ju mk jy ml kc mm kg mn kk mf mg mh mi bi translated">pgcrypto <strong class="jp ir"> digest() </strong>函数为作为参数传递的算法创建一个散列值。在我们的例子中，我们使用 SHA256 算法。</li></ul><p id="eae1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以阅读更多关于 pgcrypto 模块及其功能，在官方文档中，<a class="ae mo" href="https://www.postgresql.org/docs/current/pgcrypto.html" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">这里</strong> </a>。</p><p id="0784" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们可以继续创建一个触发器，以支持每次插入新行时，在密码列中自动生成和自动插入加盐哈希值，而不是密码纯文本。在 PostgreSQL 中，<a class="ae mo" href="https://www.postgresql.org/docs/current/sql-createtrigger.html" rel="noopener ugc nofollow" target="_blank">触发器创建</a>假定执行了一个触发器函数。这意味着我们必须创建两者，触发器本身和触发器函数，它将被触发器主体触发(执行)。触发函数很容易识别，因为它应该返回一个触发器。</p><p id="54e0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，在下面，您可以找到创建这样一个触发器函数的示例代码，以及触发器本身。</p><p id="57f2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">触发功能:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="aea8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">创建函数后，您可以使用<strong class="jp ir"> \df </strong> psql 命令检查它是否已被创建:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="fa05" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们可以创建触发器本身:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="a1c2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">创建触发器后，您可以使用 sql 命令检查它是否已创建:</p><pre class="km kn ko kp gt ni nj nk nl aw nm bi"><span id="41f5" class="nn ky iq nj b gy no np l nq nr">SELECT <strong class="nj ir">*</strong> FROM pg_trigger;</span></pre><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="dc2c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们准备通过插入一个新用户来测试刚刚创建的触发器“Hash_Password_insert_1 ”:</p><pre class="km kn ko kp gt ni nj nk nl aw nm bi"><span id="42f0" class="nn ky iq nj b gy no np l nq nr">BEGIN;<br/>INSERT INTO demousers <strong class="nj ir">(</strong>username, password<strong class="nj ir">)</strong> VALUES <strong class="nj ir">(</strong>‘panos2’, ‘panospassw2’<strong class="nj ir">)</strong>;<br/>COMMIT;</span></pre><p id="1257" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，让我们看看表格中的行:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="02e5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">到目前为止，一切顺利。验证功能的时间。</p><p id="b668" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">密码验证的第一种情况</strong></p><p id="4eaf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用以下代码创建一个存储函数，该函数可以验证密码是否对应于存储的哈希值:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="2b1b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您愿意，您可以再次使用<strong class="jp ir"> \df </strong>命令来确保‘isuserpasswordvality _ 1’已被创建。</p><p id="e601" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如您在上面看到的，该函数接受两个文本参数作为用户名和密码。首先，它使用提供的用户名获取现有的用户密码。然后，提取 salt，它实际上是存储的哈希密码的前 16 个字符的字符串。接下来，使用相同的算法重新计算新的哈希值。最后将新计算的散列值与现有散列值进行比较，现有散列值是现有密码串的最后一部分(从第 17 个字符直到末尾)。如果匹配，则返回 TRUE (t ),否则，返回 FALSE (f)。</p><p id="83f7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们检查一下:</p><pre class="km kn ko kp gt ni nj nk nl aw nm bi"><span id="1ef2" class="nn ky iq nj b gy no np l nq nr">SELECT IsUserPasswordValid<strong class="nj ir">(</strong>‘panos2’, ‘panospassw2’<strong class="nj ir">)</strong>;</span></pre><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="dfab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就是这样。它工作正常。</p><h2 id="8898" class="nn ky iq bd kz nu nv dn ld nw nx dp lh jy ny nz ll kc oa ob lp kg oc od lt oe bi translated">使用 pgcrypt()函数的第二种方法</h2><p id="6bcd" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">我之所以决定使用 pgcrypt 扩展的 crypt()和 gen_salt()函数来包含触发器函数的替代函数，是因为官方文档声明:“crypt()和 gen_salt()函数是专门为散列密码而设计的。crypt()进行哈希运算，gen_salt()为其准备算法参数。而且，实际实现只是 1 行代码。验证功能也是如此。让我们看看它是如何实现的。</p><p id="3d78" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是我们如何在触发函数中使用它们。实际上，代码创建了先前触发器函数的第二个版本，这次的名称是‘trigger _ function _ password _ hash _ 2’:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="4646" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">触发器本身保持相同的名称，但是现在它调用/执行第二版本的触发器函数:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="1255" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">同样，让我们再插入一个用户来检查加盐散列密码是什么样子的:</p><pre class="km kn ko kp gt ni nj nk nl aw nm bi"><span id="c137" class="nn ky iq nj b gy no np l nq nr">BEGIN;<br/>INSERT INTO demousers <strong class="nj ir">(</strong>username, password<strong class="nj ir">)</strong> VALUES <strong class="nj ir">(</strong>‘panos3’, ‘panospassw3’<strong class="nj ir">)</strong>;<br/>COMMIT;</span></pre><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="08e2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意，现在存储的散列密码的输出字符串的长度为 60 个非十六进制字符。这就是为什么 crypt()函数实际上是一个<a class="ae mo" href="https://en.wikipedia.org/wiki/Bcrypt" rel="noopener ugc nofollow" target="_blank"> bcrypt </a>实现。您也可以使用<a class="ae mo" href="https://bcrypt.online/" rel="noopener ugc nofollow" target="_blank">在线加密</a>验证器亲自检查:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><a href="https://bcrypt.online/"><div class="gh gi of"><img src="../Images/37718f2001bc3bbdda3f64303d033f7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*60muya4cyhZZ9nTl13XFYA.png"/></div></a></figure><p id="85fd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，这也是 crypt()接受最长 72 个字符的密码的原因，正如官方文档所述，这也适用于 bcrypt。因此，输出是一个$2a$- null 结尾的 UTF-8 编码的散列字符串，60 个字符长。</p><p id="298c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">到目前为止，一切顺利！现在让我们创建自己的验证函数。</p><p id="4fb8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">使用 pgcrypt crypt()函数进行密码验证的第二种情况</strong></p><p id="e589" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用以下代码创建一个存储函数，该函数可以验证密码是否对应于使用<strong class="jp ir"> pgcrypt </strong> crypt()函数创建的存储哈希值:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="6d45" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第二版也接受相同的用户名和密码两个参数，并且通常与之前的验证功能非常相似。然而，这里我们再次使用 crypt()函数，但是这次我们使用获得的存储散列密码，就像 salt 一样！然后，我们测试结果(newHash)是否与存储的哈希值匹配。</p><p id="0090" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们检查一下:</p><pre class="km kn ko kp gt ni nj nk nl aw nm bi"><span id="f4e8" class="nn ky iq nj b gy no np l nq nr">select isuserpasswordvalid_2<strong class="nj ir">(</strong>'panos3', 'panospassw3'<strong class="nj ir">)</strong>;</span></pre><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="9ce4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如您所见，它返回 TRUE (t)，所以提供的密码与存储散列值匹配。</p><p id="2879" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi">— — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — —</p><p id="1118" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是演示如何在 PostgreSQL 中开始处理 UUID、盐和散列的全部内容</p><p id="847b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">继续阅读我的其他帖子，了解其他数据库的实现示例。</p><p id="fc52" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就这样…暂时的！我希望你喜欢它！<br/>感谢阅读👏敬请关注！</p></div></div>    
</body>
</html>