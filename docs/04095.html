<html>
<head>
<title>[Handbook] AWS Step Functions Input and Output Manipulation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">[手册] AWS 步进功能输入和输出操作</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/handbook-aws-step-functions-input-and-output-manipulation-f94d57087e41?source=collection_archive---------0-----------------------#2021-01-25">https://blog.devgenius.io/handbook-aws-step-functions-input-and-output-manipulation-f94d57087e41?source=collection_archive---------0-----------------------#2021-01-25</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="bcd3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在本手册中，我们将解释<strong class="jm io"> AWS 阶跃函数输入和输出操作</strong>。</p><p id="26b0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有很多关于 AWS 阶跃函数的话题。自 2016 年 Step Functions 引入以来，网上有很多关于 AWS Step Functions 的文章。这些文章中的大部分可能会让您认为 Step Functions 实际上是 Lambda 函数的扩展，允许您组合几个 Lambda 函数来相互调用。</p><p id="dcc9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">但事实并非如此，阶跃函数远不止如此。</strong> AWS Step Functions 允许用户以非常简单的方式在您的应用程序中设计和构建<strong class="jm io">整个流程执行模块</strong>。所有这些都使开发人员能够专注于确保<strong class="jm io">每个模块运行其主要任务</strong>，并且您不必担心将每个模块与所有其他模块连接起来。</p><blockquote class="ki kj kk"><p id="6fa9" class="jk jl kl jm b jn jo jp jq jr js jt ju km jw jx jy kn ka kb kc ko ke kf kg kh ig bi translated">您可以在我们的<a class="ae kp" href="https://dashbird.io/blog/ultimate-guide-aws-step-functions/" rel="noopener ugc nofollow" target="_blank">阶跃函数最终指南</a>和<a class="ae kp" href="https://dashbird.io/blog/aws-step-functions-use-cases/" rel="noopener ugc nofollow" target="_blank">最佳阶跃函数用例</a>文章中了解更多关于阶跃函数的信息。</p></blockquote><h1 id="d9d2" class="kq kr in bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">什么是阶跃函数输入/输出？</h1><p id="c14e" class="pw-post-body-paragraph jk jl in jm b jn lo jp jq jr lp jt ju jv lq jx jy jz lr kb kc kd ls kf kg kh ig bi translated">为了在 AWS Step Functions 中有效地设计和实现工作流，理解信息从一种状态到另一种状态<strong class="jm io">的流动是至关重要的。不过，学会如何处理和过滤这些数据也很重要。</strong></p><p id="eb9b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在下图中，您将注意到 JSON 信息在整个任务状态中的移动:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi lt"><img src="../Images/78b821a1ff57020f50fea41d22c90ead.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*JsTvLq1RXDt8Fz8A"/></div></div></figure><p id="0e45" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="kl">输入路径、输出路径、结果路径、参数</em>和<em class="kl">结果选择器</em>，将在 JSON 通过工作流中的每个状态时对其进行操作。</p><h1 id="cb7a" class="kq kr in bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">小路</h1><p id="5b09" class="pw-post-body-paragraph jk jl in jm b jn lo jp jq jr lp jt ju jv lq jx jy jz lr kb kc kd ls kf kg kh ig bi translated">路径是亚马逊州语言中以<em class="kl"> $ </em>开头的<strong class="jm io">字符串，您可以用它来<strong class="jm io">识别 JSON 文本中的组件</strong>。当您确定<em class="kl">输入路径、结果路径</em>和<em class="kl">输出路径</em>的值时，您可以指定一个允许您<strong class="jm io">访问输入的子集的路径。</strong></strong></p><h1 id="508b" class="kq kr in bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">参考路径</h1><p id="798d" class="pw-post-body-paragraph jk jl in jm b jn lo jp jq jr lp jt ju jv lq jx jy jz lr kb kc kd ls kf kg kh ig bi translated">引用路径也是一条路径，但是它的语法受到限制，只能识别整个 JSON 结构中的一个节点:</p><ul class=""><li id="a6de" class="mf mg in jm b jn jo jr js jv mh jz mi kd mj kh mk ml mm mn bi translated">您只需要使用点<code class="fe mo mp mq mr b">(.)</code>和方括号<code class="fe mo mp mq mr b">([ ]) </code>符号就可以成功访问对象字段。</li><li id="9fc1" class="mf mg in jm b jn ms jr mt jv mu jz mv kd mw kh mk ml mm mn bi translated">这些运营商<code class="fe mo mp mq mr b">@ .. , : ? *</code>是不被支持的。</li><li id="7a45" class="mf mg in jm b jn ms jr mt jv mu jz mv kd mw kh mk ml mm mn bi translated"><code class="fe mo mp mq mr b">length()</code>等功能也不支持。</li></ul><p id="6923" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一个很好的例子是状态输入数据具有以下值:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi mx"><img src="../Images/de923631a11a4b6a93c79583ec0d06b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HWm9W0FQIi7apVDp"/></div></div></figure><p id="fa6b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">此外，这些引用路径将返回:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi mx"><img src="../Images/4b30cb0bbf853fda9489c55925b0edce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*v2zwO9VjmPF75diG"/></div></div></figure><p id="e1e1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一些状态利用路径，它们也引用路径，这样它们可以<strong class="jm io">控制状态机</strong>的整个流程，甚至配置状态的选项或设置。</p><h1 id="3603" class="kq kr in bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">输入路径、结果选择器和参数</h1><p id="95d4" class="pw-post-body-paragraph jk jl in jm b jn lo jp jq jr lp jt ju jv lq jx jy jz lr kb kc kd ls kf kg kh ig bi translated"><em class="kl">输入路径、结果选择器</em>和<em class="kl">参数</em>字段让您有可能在 JSON 在您的工作流程中移动时对其进行<strong class="jm io">操作。<em class="kl"> InputPath </em>可以<strong class="jm io">限制通过过滤 JSON 符号和利用路径传递的输入</strong>。<em class="kl"> ResultSelector </em>字段为您提供了甚至在<em class="kl"> ResultPath </em>被应用</strong>之前<strong class="jm io">操纵状态结果的可能性。Parameters 字段为您提供了传递一组键值对的可能性。这些值或者是您利用路径从输入</strong>中选择的值，或者是您将在您的状态机定义中<strong class="jm io">定义的静态值。</strong></p><p id="89b8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">AWS Step 函数将应用<em class="kl"> InputPath </em>字段作为主字段，只有在此之后，它才会应用 Parameters 字段。如果您首先通过<em class="kl">输入路径</em>将原始输入过滤成您想要的选择，那将是最好的。然后你应该应用参数，这样你就可以<strong class="jm io">进一步操作那个特定的输入</strong>或者添加新的值。完成这一步后，您可以使用<em class="kl"> ResultSelector </em>字段，这样您就可以在<em class="kl"> ResultPath </em>被应用之前操纵状态的输出。</p><h1 id="8c12" class="kq kr in bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">输入路径</h1><p id="9b67" class="pw-post-body-paragraph jk jl in jm b jn lo jp jq jr lp jt ju jv lq jx jy jz lr kb kc kd ls kf kg kh ig bi translated">最好使用<em class="kl">输入路径</em>，这样就可以<strong class="jm io">选择状态输入</strong>的一段。一个很好的例子是，假设状态的输入包括:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi my"><img src="../Images/2496a5df2a8e5f8c556f06053aee4f20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*AHkzB3ep4xZGpW2P"/></div></div></figure><p id="547b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后，您可以应用<em class="kl">输入路径</em>:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi mx"><img src="../Images/f81cc61ee7a02e5718552d4edab6ee5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*N83malVB2T8VritI"/></div></div></figure><p id="9bfe" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">考虑到前面的<em class="kl">输入路径</em>，这是作为输入传递的 JSON:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi mx"><img src="../Images/25c6f2d92f9d3f04fd1cd6798f55d962.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Bqb5g5mcWhc2x9LQ"/></div></div></figure><p id="3bfe" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">重要的是要知道路径可以产生特定值的选择，例如:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi mz"><img src="../Images/bbfee4aa9bdfb9b5a0030ccd33f5f70b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZFvl3ETIOiqi0X-p"/></div></div></figure><p id="dcd1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你已经应用了路径<em class="kl"> $。a[0:2] </em>，这将是结果:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi na"><img src="../Images/1c3520d2c71e46de377f7955cd2f42fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tgpyY_7bCXDfAf3P"/></div></div></figure><h1 id="7f68" class="kq kr in bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">结果选择器</h1><p id="81b6" class="pw-post-body-paragraph jk jl in jm b jn lo jp jq jr lp jt ju jv lq jx jy jz lr kb kc kd ls kf kg kh ig bi translated">利用<em class="kl"> ResultSelector </em>字段，这样您甚至可以在<em class="kl"> ResultPath </em>被应用之前<strong class="jm io">操纵一个状态的结果。<em class="kl"> ResultSelector </em>字段允许您创建一个<strong class="jm io">键值对</strong>的集合，如果这些值是静态的或者甚至是从状态结果中选择的。此外，<em class="kl"> ResultSelector </em>的输出将替换状态的结果，并将其传递给<em class="kl"> ResultPath </em>。</strong></p><p id="2004" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在以下状态中,<em class="kl">结果选择器</em>不是必填字段:</p><ul class=""><li id="ce90" class="mf mg in jm b jn jo jr js jv mh jz mi kd mj kh mk ml mm mn bi translated">工作</li><li id="998d" class="mf mg in jm b jn ms jr mt jv mu jz mv kd mw kh mk ml mm mn bi translated">平行的</li><li id="16db" class="mf mg in jm b jn ms jr mt jv mu jz mv kd mw kh mk ml mm mn bi translated">地图</li></ul><p id="e74d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">此外，步骤函数服务集成将<strong class="jm io">返回元数据</strong>到<strong class="jm io">结果的有效负载</strong>。<em class="kl"> ResultSelector </em>能够<strong class="jm io">选择结果的片段</strong>，并<strong class="jm io">将它们与<em class="kl"> ResultPath </em> </strong>中的<strong class="jm io">状态输入全部合并</strong>。这个例子显示您可以选择<em class="kl"> resourceType </em>和<em class="kl"> ClusterId </em>，这样您就可以将它们与来自 Amazon 的 EMR <em class="kl"> createCluster.sync </em>的状态输入合并在一起。下面是一个例子:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi nb"><img src="../Images/1433798d4d4ce848644a055798b5ec82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Fb0i4IXq1zP9MhDD"/></div></div></figure><p id="f133" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">通过使用<em class="kl"> ResultSelector </em>，您将能够选择<em class="kl"> resourceType </em>和<em class="kl"> ClusterId </em>:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi nc"><img src="../Images/274f571f95ee45d253b81825d8e13678.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jQIF0QSE6awqCMa4"/></div></div></figure><p id="752b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">考虑到给定的输入，利用<em class="kl">结果选择器</em>将产生:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi my"><img src="../Images/dbdef7e5946567a00a9340f863d67ff3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*U5kmOpVHn7C1IgpI"/></div></div></figure><h1 id="bbd8" class="kq kr in bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">因素</h1><p id="03fd" class="pw-post-body-paragraph jk jl in jm b jn lo jp jq jr lp jt ju jv lq jx jy jz lr kb kc kd ls kf kg kh ig bi translated">使用参数字段将帮助您<strong class="jm io">创建一个键值对集合，这些键值对都作为输入</strong>传递。这些值可以从带有路径的输入或上下文对象中选择，也可以是包含在状态机定义中的静态值。<strong class="jm io">密钥名必须以<em class="kl">结尾。$ </em> </strong>用于键值对，使用路径选择其值<strong class="jm io">。</strong></p><p id="e9d7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">看一下下面的输入示例:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi nd"><img src="../Images/bcf3fd7c74a8e82367ccb2def7c1e521.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*nX2JpjbcFiNt0Ubo"/></div></div></figure><p id="f5dd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在状态机定义中指定这些参数将使您能够选择一些信息。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi my"><img src="../Images/320a9ef007393d14d97420a6b1d090f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qtvZPsy7vun-njAb"/></div></div></figure><p id="f9a4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">考虑到前面的输入和参数字段，这是将要通过的 JSON:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi nb"><img src="../Images/b1cab816d058106e96ba8d7a87598ef3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2aTFHJ7VWE_fmAQn"/></div></div></figure><p id="4229" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">除了提供的输入之外，您还可以轻松访问一个特殊的 JSON 对象，称为“<strong class="jm io">上下文对象</strong>”这个对象包括<strong class="jm io">所有关于状态机执行</strong>的信息。</p><p id="53b2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">值得一提的是，Parameters 字段还能够将信息传递给其他连接的资源。如果您的任务状态编排了一个 AWS 批处理作业，您将很容易<strong class="jm io">将所有相关的 API 参数直接传递给该服务的 API 操作</strong>。</p><h1 id="19b7" class="kq kr in bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">ItemsPath</h1><p id="8578" class="pw-post-body-paragraph jk jl in jm b jn lo jp jq jr lp jt ju jv lq jx jy jz lr kb kc kd ls kf kg kh ig bi translated">在<strong class="jm io">映射状态</strong>中使用了<em class="kl"> ItemsPath </em>字段，因此您可以<strong class="jm io">在输入</strong>中选择一个数组。映射状态用于<strong class="jm io">迭代在输入</strong>中找到的数组中的每个项目的步骤。默认情况下，通过选择<strong class="jm io">整体输入</strong>，地图状态会将<em class="kl">项目路径</em>设置为<em class="kl"> $ </em>。如果 Map 状态的输入是一个 JSON 数组，它将对数组中的每个条目运行一次迭代，并将该条目作为输入进一步传递给迭代。</p><p id="6881" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="kl"> ItemsPath </em>字段将允许您<strong class="jm io">在输入中选择一个位置</strong>，这样您就可以找到用于迭代的 JSON 数组。<em class="kl"> ItemsPath </em>的值必须是一个<strong class="jm io">引用路径</strong>，并且它还必须标识 JSON 数组的值。想象一个包含两个数组的映射状态的输入，如下例所示:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi ne"><img src="../Images/50dc42cec9c0c935bcba34bc15fe192f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5yZYyjmt1wxNR-bR"/></div></div></figure><p id="de28" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这种情况表明，您可以通过简单地选择一个带有<em class="kl"> ItemsPath </em> 的<strong class="jm io">特定数组来指定要将哪个数组用于贴图状态迭代。该状态机定义仅使用<em class="kl"> ItemsPath </em>指定输入中的<em class="kl">thingspiratesay</em>数组。尽管如此，它还是会对位于<em class="kl">thingspiratasay</em>数组中的每一项运行<em class="kl"> SayWord </em>的传递状态迭代。</strong></p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi nf"><img src="../Images/151536f1a40fd94cecbf08e3055b2f5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lHJuQ_sM-yFkNN0T"/></div></div></figure><p id="4e1b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">处理输入时，<em class="kl"> ItemsPath </em>应用在<em class="kl"> InputPath </em>之后。此外，当<em class="kl">输入路径</em>完全过滤输入时，它将对状态的有效输入进行操作。</p><h1 id="82ed" class="kq kr in bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">结果路径</h1><p id="1dea" class="pw-post-body-paragraph jk jl in jm b jn lo jp jq jr lp jt ju jv lq jx jy jz lr kb kc kd ls kf kg kh ig bi translated">任何状态的<strong class="jm io">输出</strong>也可以是其输入的<strong class="jm io">副本，其结果与输入</strong>的<strong class="jm io">组合，或其产生的<strong class="jm io">结果</strong>(例如。来自任务状态的 Lambda 函数的输出)。使用<strong class="jm io"> <em class="kl"> ResultPath </em> </strong>允许<strong class="jm io">控制</strong>这些<strong class="jm io">组合中的哪一个将被转发到状态输出</strong>。</strong></p><p id="9579" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这些是可以生成结果的状态类型，也可以包括<em class="kl">结果路径</em>:</p><ul class=""><li id="253d" class="mf mg in jm b jn jo jr js jv mh jz mi kd mj kh mk ml mm mn bi translated">工作</li><li id="37f9" class="mf mg in jm b jn ms jr mt jv mu jz mv kd mw kh mk ml mm mn bi translated">平行的</li><li id="57ce" class="mf mg in jm b jn ms jr mt jv mu jz mv kd mw kh mk ml mm mn bi translated">及格</li></ul><p id="4533" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果您利用<em class="kl"> ResultPath </em>来组合任务输入和任务结果或者甚至选择这些选项中的一个，将会有所帮助。您提供给<em class="kl"> ResultPath </em>的路径将控制传递给输出的所有信息。</p><p id="87bb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">此外，<em class="kl"> ResultPath </em>仅限于使用引用路径，将范围限制为仅识别 JSON 中的单个节点。</p><h1 id="9234" class="kq kr in bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">利用结果路径</h1><p id="e7d0" class="pw-post-body-paragraph jk jl in jm b jn lo jp jq jr lp jt ju jv lq jx jy jz lr kb kc kd ls kf kg kh ig bi translated">您可以利用<em class="kl">结果路径</em>来:</p><ul class=""><li id="3569" class="mf mg in jm b jn jo jr js jv mh jz mi kd mj kh mk ml mm mn bi translated">用结果替换输入</li><li id="8a33" class="mf mg in jm b jn ms jr mt jv mu jz mv kd mw kh mk ml mm mn bi translated">放弃结果并保留输入</li><li id="beff" class="mf mg in jm b jn ms jr mt jv mu jz mv kd mw kh mk ml mm mn bi translated">将结果包含在输入中</li><li id="c2cd" class="mf mg in jm b jn ms jr mt jv mu jz mv kd mw kh mk ml mm mn bi translated">用结果更新输入中的节点</li><li id="cb25" class="mf mg in jm b jn ms jr mt jv mu jz mv kd mw kh mk ml mm mn bi translated">在 Catch 中包含输入和错误</li></ul><h1 id="932c" class="kq kr in bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">利用 ResultPath 用结果替换输入</h1><p id="4954" class="pw-post-body-paragraph jk jl in jm b jn lo jp jq jr lp jt ju jv lq jx jy jz lr kb kc kd ls kf kg kh ig bi translated">如果您<strong class="jm io">没有指定<em class="kl"> ResultPath </em> </strong>，默认行为将与您指定了“<em class="kl">result path</em>”:" $ "相同。由于这个<strong class="jm io">告诉状态用结果</strong>替换整个输入，状态输入将被来自任务结果的结果完全替换<strong class="jm io"/>。</p><p id="0d5d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这个图中，您可以看到<em class="kl"> ResultPath </em>如何用给定任务的结果完全替换输入:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi ng"><img src="../Images/07d8bc523d68e123b3431fb7e3b32186.png" data-original-src="https://miro.medium.com/v2/resize:fit:1232/0*u9KfXBYP_sRgbXiH"/></div></div></figure><p id="e310" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">通过以下输入使用 Lambda 函数和状态机:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi nh"><img src="../Images/1c317b259386b1a292937fcbe404af5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*JDJbJHBGmy3OnIWB"/></div></div></figure><p id="5c04" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后，Lambda 函数将为您提供以下结果:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi ni"><img src="../Images/1e5eb8e6acceff1fd7cb51f1c30fb42d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BPjQYs9TnqGwYNQP"/></div></div></figure><p id="3ee0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果在状态中没有指定<em class="kl"> ResultPath </em>，或者如果设置了“<em class="kl">result path</em>”:" $ "，则状态的输入被 Lambda 函数的结果替换，而状态的输出如下:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi ni"><img src="../Images/d2640e0136477657db357d1a045ad93c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DwQxCQRuOD7NTlIE"/></div></div></figure><p id="9d39" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="kl"> ResultPath </em>用于在内容被传递到输出之前包含来自输入结果的所有内容。然而，如果没有指定<em class="kl"> ResultPath </em>，默认情况下它将替换整个输入。</p><h1 id="d8d6" class="kq kr in bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">丢弃结果并保留原始输入</h1><p id="4df1" class="pw-post-body-paragraph jk jl in jm b jn lo jp jq jr lp jt ju jv lq jx jy jz lr kb kc kd ls kf kg kh ig bi translated">如果您将<em class="kl"> ResultPath </em>设置为<strong class="jm io"> null，</strong>将<strong class="jm io">将原始输入直接传递给输出。</strong>利用“<em class="kl">result path</em>”:“null”，将状态的输入载荷直接复制到输出，不管结果如何。</p><p id="888d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个图展示了 null <em class="kl"> ResultPath </em>如何将输入直接复制到输出。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/61b855aa29203f7defee710791403915.png" data-original-src="https://miro.medium.com/v2/resize:fit:1208/0*XBRyG06VpHGXAH57"/></div></figure><h1 id="8769" class="kq kr in bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">利用 ResultPath 包含给定输入的结果</h1><p id="7d94" class="pw-post-body-paragraph jk jl in jm b jn lo jp jq jr lp jt ju jv lq jx jy jz lr kb kc kd ls kf kg kh ig bi translated">这个例子展示了<em class="kl"> ResultPath </em>如何将结果包含在输入中。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi nk"><img src="../Images/b845cfbc9338ef47306daa0d7f5252b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IiC4PwlvVRBwSo6l"/></div></div></figure><p id="e378" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">利用 Lambda 函数和状态机，您可以传递以下输入:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi nl"><img src="../Images/de44ae40264a1e0af9bd3019a78b6a88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*JbbZ2k1UTIkVktz0"/></div></div></figure><p id="e380" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">λ函数的结果将是:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi nm"><img src="../Images/21bbb2a9f76de388ce544612e8574da0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_DN2TMkTLnr1W4Lx"/></div></div></figure><p id="086d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了保存这个输入，您应该插入 Lambda 函数的结果，然后将合并的 JSON 传递到下一个状态，您将能够设置<em class="kl"> ResultPath </em>:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi nn"><img src="../Images/2b9f7df78cd9ab7de1ed1b3012297adb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gfkfjaLBNzDCBmnV"/></div></div></figure><p id="e301" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这也包括 Lambda 函数与原始输入的结果。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi no"><img src="../Images/f99c482c2c8c1dbd51a29c836fe12088.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Oc2dVMc8l7gwtQsN"/></div></div></figure><p id="5e94" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Lambda 函数的输出位于原始输入的<strong class="jm io">端，并呈现为<em class="kl"> taskresult </em>的值。输入和新插入的值一起被转发到下一个状态。</strong></p><p id="5d76" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您可以将结果放入输入的<strong class="jm io">子节点</strong>，并且<em class="kl"> ResultPath </em>将被设置如下:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi np"><img src="../Images/00aa8cf9e3384235cbb369162c528960.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cB9LEOxYxjElyxjl"/></div></div></figure><p id="7db6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">利用以下输入开始执行:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi nq"><img src="../Images/5010122f720848eaf19ba2b872d6c83e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1R59TkQuMD0W0haN"/></div></div></figure><p id="1250" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Lambda 函数的结果作为<em class="kl">字符串</em>节点的子节点插入到输入中。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi ni"><img src="../Images/1e85ba0ba1d70ee2e7cbb28890fc8751.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*EltHGidkwPKSAY8Q"/></div></div></figure><p id="ac8b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">状态输出现在将包括原始的 JSON 输入，产生一个子节点。</p><h1 id="3812" class="kq kr in bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">利用 ResultPath 用结果更新输入中的节点</h1><p id="1688" class="pw-post-body-paragraph jk jl in jm b jn lo jp jq jr lp jt ju jv lq jx jy jz lr kb kc kd ls kf kg kh ig bi translated">下图展示了<em class="kl"> ResultPath </em>如何使用任务结果的值更新输入中现有的 JSON <strong class="jm io">节点的值</strong>:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/1ecc9ae3b322829a7af7b81109a6e978.png" data-original-src="https://miro.medium.com/v2/resize:fit:1386/0*hRCJgLLnHk8v7AlC"/></div></figure><p id="9671" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">利用“创建使用 Lambda 的阶跃函数状态机的教程”中描述的 Lambda 函数和状态机的示例，您可以传递以下输入:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi no"><img src="../Images/c6f8410e91375173d49fbfcf0ec5feb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tIQp8GdLZW-sJFcg"/></div></div></figure><p id="e932" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">λ函数的结果是:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi nh"><img src="../Images/d326cee81cc6697ed46d9df237883529.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*df7Bd0CyTttNBzGt"/></div></div></figure><p id="c1a2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您可以<strong class="jm io">完全覆盖现有的节点</strong>，而不是将结果作为新节点插入 JSON 并保留输入。</p><p id="9f5e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">例如，设置一个<em class="kl"> "ResultPath": "$" </em>将会用<strong class="jm io">覆盖整个节点</strong>，并且您可以指定一个想要用结果覆盖的节点。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi nn"><img src="../Images/7b27fa9b0ef067e8b6d35ce6f65d4ddc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ya8AdEurwT2eNCtw"/></div></div></figure><p id="7310" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因为注释节点已经存在于状态输入中，所以将<em class="kl"> ResultPath </em>设置为<em class="kl"> "$。注释"</em>用 Lambda 函数结果替换输入中的节点。这将被传递到输出<strong class="jm io">而没有由<em class="kl"> OutputPath </em> </strong>进行任何进一步的过滤:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi nq"><img src="../Images/ee874f6823359944b5992923cd80148b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*szaAX-aIiPuijxmZ"/></div></div></figure><p id="c39d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">注释节点的值，“这是一个任务状态的输入和输出测试。”，将<strong class="jm io">替换为 Lambda 函数的结果</strong>:“您好，AWS Step Functions！”在状态输出内。</p><h1 id="a14d" class="kq kr in bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">利用 ResultPath 在 Catch 中包含输入和错误</h1><p id="108e" class="pw-post-body-paragraph jk jl in jm b jn lo jp jq jr lp jt ju jv lq jx jy jz lr kb kc kd ls kf kg kh ig bi translated">教程“使用阶跃函数状态机处理错误条件”解释了如何利用状态机来捕捉错误。有时，您可能希望保存包含错误的原始输入。在 Catch 中使用<em class="kl"> ResultPath </em>,这样就可以包含来自原始输入的错误。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi nm"><img src="../Images/d52689648d729f631dae16bf3c43100b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*n5n_9fRT00YOHDQ3"/></div></div></figure><p id="5d1c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果前面的 Catch 语句捕捉到任何错误，它还会在状态输入的错误节点中包含结果。以下输入是这种情况的一个很好的例子:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi np"><img src="../Images/d17b380ec64996ac82f103e2d4e6f30c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8OxeG9FpcTxegSol"/></div></div></figure><p id="ba81" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">捕获错误时的状态输出如下所示:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi np"><img src="../Images/65743993ea452b02b270f695528bef2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IQ08yjNbnSnGds4f"/></div></div></figure><h1 id="edfd" class="kq kr in bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">输出路径</h1><p id="e6c3" class="pw-post-body-paragraph jk jl in jm b jn lo jp jq jr lp jt ju jv lq jx jy jz lr kb kc kd ls kf kg kh ig bi translated"><em class="kl"> OutputPath </em>允许你选择状态输出的一个片段，将其传递给下一个状态。这也允许你<strong class="jm io">过滤掉所有不想要的信息，只传递你真正关心的 JSON 片段</strong>。</p><p id="b533" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">通过不指定<em class="kl">输出路径</em>，缺省值将总是<em class="kl"> $ </em>。这将把由任务结果<em class="kl"> ResultPath </em>确定的整个 JSON 节点，包括状态输入，直接传递到下一个状态。</p><h1 id="08e2" class="kq kr in bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">输入路径、输出路径和结果路径示例</h1><p id="6d1b" class="pw-post-body-paragraph jk jl in jm b jn lo jp jq jr lp jt ju jv lq jx jy jz lr kb kc kd ls kf kg kh ig bi translated">除失败状态之外的任何状态都可以包括<em class="kl">输入路径、输出路径</em>或<em class="kl">结果路径</em>。所有这些都允许您利用一个路径来过滤 JSON，因为它在您的工作流中移动。</p><p id="818a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">例如，您可以修改状态机，使其包括<em class="kl">输入路径、输出路径</em>和<em class="kl">结果路径</em>:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi ne"><img src="../Images/0c6accf1c0841d3ed79761873dac7ad3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ex8xvcI98NGQV_Nj"/></div></div></figure><p id="e693" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">利用此输入开始执行:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi ne"><img src="../Images/eae75a57a34be2862127076ac9bbd820.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6H97RdRjshbU7RmF"/></div></div></figure><p id="1516" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">假设额外的节点和注释可以被丢弃，并且包括<a class="ae kp" href="https://dashbird.io/knowledge-base/aws-lambda/introduction-to-aws-lambda/" rel="noopener ugc nofollow" target="_blank">AWSλ</a>函数输出以保存位于数据节点内的信息。</p><p id="ea05" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">修改任务状态以在更新的状态机内处理对任务的输入。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi ns"><img src="../Images/7068f35ca07d9c19cf856ceed8b3fc69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gMotO5PT63drM-VI"/></div></div></figure><p id="f5fd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">状态机定义中的这行代码<strong class="jm io">将任务输入限制在状态输入中的 Lambda 节点</strong>。Lambda 函数将只接收 JSON 对象{"who": "AWS Step Functions"}作为输入。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi nt"><img src="../Images/c56774f39e79ee0989fcb90e55df35a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ki5-miB3M4M82yFK"/></div></div></figure><p id="03ab" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个特定的<em class="kl"> ResultPath </em>将告诉状态机<strong class="jm io">将 Lambda 函数结果</strong>插入到名为“lambdaresult”的节点中，作为原始状态机输入中的<strong class="jm io">数据节点的子节点</strong>。该状态的输入现在包括具有原始输入的 Lambda 函数结果，并且没有使用<em class="kl"> OutputPath </em>的任何进一步处理。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi nu"><img src="../Images/c719f06fbf272023a7c1deaa71193db6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xnbBOsP_rzpdnB6S"/></div></div></figure><p id="681c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，由于目标是<strong class="jm io">仅保存数据节点</strong>，同时包含<strong class="jm io"> Lambda 函数结果</strong> , <em class="kl"> OutputPath </em>在将 JSON 传递给状态输出之前对其进行过滤。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi nv"><img src="../Images/cfa92133840d2189b6c8251e6f7656fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bkOaI7gmV9b0Equk"/></div></div></figure><p id="d55e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">它专门选择来自原始输入的数据节点，以进一步向输出前进。从这里开始，过滤整个状态输出:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi nf"><img src="../Images/9adc3fd4a7554f33859b7869e871b5fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jR-J8VDsIU50IpyU"/></div></div></figure><p id="6337" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">此外，在这个特定的任务状态中:</p><ul class=""><li id="76a5" class="mf mg in jm b jn jo jr js jv mh jz mi kd mj kh mk ml mm mn bi translated"><strong class="jm io"> <em class="kl"> InputPath </em> </strong>将只发送 Lambda 函数输入中的 Lambda 节点。</li><li id="2d19" class="mf mg in jm b jn ms jr mt jv mu jz mv kd mw kh mk ml mm mn bi translated"><strong class="jm io"> <em class="kl"> OutputPath </em> </strong>将过滤状态输入(包括 Lambda 函数结果)以将数据节点进一步传递到状态输出。</li><li id="9e2a" class="mf mg in jm b jn ms jr mt jv mu jz mv kd mw kh mk ml mm mn bi translated"><strong class="jm io"> <em class="kl"> ResultPath </em> </strong>将结果作为数据节点的子节点插入到原始输入中。</li></ul><h1 id="d58b" class="kq kr in bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">上下文对象</h1><p id="91e7" class="pw-post-body-paragraph jk jl in jm b jn lo jp jq jr lp jt ju jv lq jx jy jz lr kb kc kd ls kf kg kh ig bi translated">上下文对象也被称为在执行过程中可用的内部 JSON 结构，它包含了关于执行和状态机的信息。得益于此，您的工作流将获得<strong class="jm io">对有关其具体执行的信息</strong>的访问权。可以从以下字段访问上下文对象:</p><ul class=""><li id="7fde" class="mf mg in jm b jn jo jr js jv mh jz mi kd mj kh mk ml mm mn bi translated"><em class="kl">输入路径</em></li><li id="f82e" class="mf mg in jm b jn ms jr mt jv mu jz mv kd mw kh mk ml mm mn bi translated"><em class="kl">输出路径</em></li><li id="fd23" class="mf mg in jm b jn ms jr mt jv mu jz mv kd mw kh mk ml mm mn bi translated"><em class="kl">结果选择器</em></li><li id="ebdd" class="mf mg in jm b jn ms jr mt jv mu jz mv kd mw kh mk ml mm mn bi translated"><em class="kl">项目路径(在地图状态内)</em></li><li id="4b4a" class="mf mg in jm b jn ms jr mt jv mu jz mv kd mw kh mk ml mm mn bi translated"><em class="kl">变量对其他变量的比较运算符</em></li><li id="c360" class="mf mg in jm b jn ms jr mt jv mu jz mv kd mw kh mk ml mm mn bi translated"><em class="kl">变量(在选择状态内)</em></li></ul><h1 id="7cfc" class="kq kr in bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">上下文对象格式</h1><p id="ff24" class="pw-post-body-paragraph jk jl in jm b jn lo jp jq jr lp jt ju jv lq jx jy jz lr kb kc kd ls kf kg kh ig bi translated">上下文对象有关于<strong class="jm io">执行、状态、任务和状态机</strong>的信息。此外，这个 JSON 对象包括每种数据类型的节点，通常格式如下:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi my"><img src="../Images/43d205a0f2a0eef22ff54d1713a5b326.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QjNeEyFkEBDgIuC8"/></div></div></figure><p id="4c5a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在每次执行期间，上下文对象被填充与从访问的参数字段相关的数据<strong class="jm io">。如果参数字段完全在任务状态之外，则任务字段值为 null。</strong></p><p id="9b96" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">正在运行的执行中的内容还包括以下格式的细节:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi nw"><img src="../Images/1bd7b785e42fd1feeebf9244c1954485.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZICwSZy6wUUV8ahe"/></div></div></figure><h1 id="739e" class="kq kr in bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">如何访问上下文对象？</h1><p id="924d" class="pw-post-body-paragraph jk jl in jm b jn lo jp jq jr lp jt ju jv lq jx jy jz lr kb kc kd ls kf kg kh ig bi translated">为了<strong class="jm io">成功访问上下文对象</strong> t，首先需要通过放置<em class="kl">来指定参数名。$ </em>到最后，这和你用路径选择状态输入是一样的。此外，为了让<strong class="jm io">访问上下文对象数据而不是访问输入</strong>，用<em class="kl"> $$开始路径。</em>。这将通知 AWS 步骤函数使用该路径来选择上下文对象中的节点。</p><p id="d8db" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个任务状态示例利用一个路径将<a class="ae kp" href="https://dashbird.io/knowledge-base/aws-cloud/arn-amazon-resource-name/" rel="noopener ugc nofollow" target="_blank">亚马逊资源名称(ARN) </a>执行传递和检索到<a class="ae kp" href="https://dashbird.io/knowledge-base/sqs/introduction-to-sqs-queue-service/" rel="noopener ugc nofollow" target="_blank">亚马逊 SQS </a>消息。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi mx"><img src="../Images/6724365c569316c2b884b1564b4f458d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NKFH_CswHxY_f0cG"/></div></div></figure><h1 id="20ed" class="kq kr in bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">用于地图状态处理的上下文对象数据</h1><p id="3586" class="pw-post-body-paragraph jk jl in jm b jn lo jp jq jr lp jt ju jv lq jx jy jz lr kb kc kd ls kf kg kh ig bi translated">在处理映射状态时，上下文对象中还有两项可用:<strong class="jm io">值和索引</strong>。索引项包含当前迭代中处理的数组项的索引号。地图状态中的上下文对象包括:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi mx"><img src="../Images/336d10e6529fbf61bf352c52eb33a7f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GW-MzLrns3bOGOKC"/></div></div></figure><p id="1e1f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然而，这些仅在<strong class="jm io">映射状态</strong>中可用，并且它们可以在参数字段中的迭代器部分之前指定<strong class="jm io">。此外，您必须在主 Map 状态的 parameters 块中定义来自上下文对象的参数，而不是在迭代器部分包含的状态中定义。</strong></p><p id="e808" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果给定一个带有简单映射状态的状态机，就可以从上下文对象中注入信息:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi nx"><img src="../Images/506e315084b27558c25df067aaa98faf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7CEUQWhZy64nlaJP"/></div></div></figure><p id="1f30" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">通过用所提供的输入执行前面的状态机，值和索引都将被插入到输出中。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi nh"><img src="../Images/ff3462befffb9fae8527795f960b83f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4-u8lKKHpanpqOle"/></div></div></figure><p id="a8dd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">执行输出是:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi mx"><img src="../Images/8552fd30329d2c698f3307f6c8c309a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*eg6Kl_MqJdndBHdx"/></div></div></figure><h1 id="ce56" class="kq kr in bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">包扎</h1><p id="13c6" class="pw-post-body-paragraph jk jl in jm b jn lo jp jq jr lp jt ju jv lq jx jy jz lr kb kc kd ls kf kg kh ig bi translated">一个步骤功能的准确描述应该是“<em class="kl">状态即服务</em>”没有他们，我们就没有机会用多个 Lambda 活动维护每个州的执行。</p><p id="1084" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">掌握步骤功能的性能至关重要，因为工作流可能出错，这会严重影响您的最终用户。AWS Step Functions 将事件和指标发布到<a class="ae kp" href="https://docs.aws.amazon.com/step-functions/latest/dg/procedure-cloud-trail.html" rel="noopener ugc nofollow" target="_blank"> CloudTrail </a>和<a class="ae kp" href="https://docs.aws.amazon.com/step-functions/latest/dg/procedure-cw-metrics.html" rel="noopener ugc nofollow" target="_blank"> CloudWatch </a>，它们由 Dashbird 监控并导入到单个仪表板，结合其他 AWS 服务的指标并转化为<strong class="jm io">易于理解的可操作数据</strong>。</p><p id="a833" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Dashbird 的 Insights 引擎可以实时检测与状态机定义或任务执行失败相关的错误，当您的工作流中出现问题或即将出错时，<strong class="jm io">会通过 Slack 或电子邮件立即通知您</strong>。Insights 引擎基于<a class="ae kp" href="https://aws.amazon.com/architecture/well-architected/?wa-lens-whitepapers.sort-by=item.additionalFields.sortDate&amp;wa-lens-whitepapers.sort-order=desc" rel="noopener ugc nofollow" target="_blank"> AWS 架构良好的最佳实践</a>，并根据其规则持续运行您的整个无服务器基础设施的数据，以帮助您确保您的应用在任何规模下都是优化的和可靠的。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi ny"><img src="../Images/77c1c3c7d6660bcb6a374103c48e4211.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*i3fCRzOD4f3y2aF7.gif"/></div></div></figure><p id="84ad" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae kp" href="https://dashbird.io/features/" rel="noopener ugc nofollow" target="_blank">你可以试试大鸟</a>——免费的！</p><ul class=""><li id="0bae" class="mf mg in jm b jn jo jr js jv mh jz mi kd mj kh mk ml mm mn bi translated">没有代码更改</li><li id="6391" class="mf mg in jm b jn ms jr mt jv mu jz mv kd mw kh mk ml mm mn bi translated">不需要信用卡</li><li id="128f" class="mf mg in jm b jn ms jr mt jv mu jz mv kd mw kh mk ml mm mn bi translated">简单的两分钟设置</li><li id="608c" class="mf mg in jm b jn ms jr mt jv mu jz mv kd mw kh mk ml mm mn bi translated">获得所有高级功能</li><li id="d894" class="mf mg in jm b jn ms jr mt jv mu jz mv kd mw kh mk ml mm mn bi translated">立即开始接收自动警报并安全处理您的数据<strong class="jm io"/></li><li id="413f" class="mf mg in jm b jn ms jr mt jv mu jz mv kd mw kh mk ml mm mn bi translated">在几秒钟内找到并调试已知和未知的错误</li><li id="9684" class="mf mg in jm b jn ms jr mt jv mu jz mv kd mw kh mk ml mm mn bi translated">获得定制的可行见解，以改进和精心设计您的系统，使其能够随着时间的推移承担更多的复杂性</li><li id="df10" class="mf mg in jm b jn ms jr mt jv mu jz mv kd mw kh mk ml mm mn bi translated">简单、干净、易于理解的界面</li><li id="eea3" class="mf mg in jm b jn ms jr mt jv mu jz mv kd mw kh mk ml mm mn bi translated">市场上最经济实惠的监控和故障排除解决方案之一</li><li id="fc7d" class="mf mg in jm b jn ms jr mt jv mu jz mv kd mw kh mk ml mm mn bi translated">到处都支持和友好🙂— <a class="ae kp" href="https://dashbird.io/customers/" rel="noopener ugc nofollow" target="_blank">看看 Dashbird 用户怎么说</a></li></ul></div></div>    
</body>
</html>