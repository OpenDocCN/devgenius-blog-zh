<html>
<head>
<title>How to write unit tests easily with Gtest(C++) (Part 1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用 Gtest(C++)轻松编写单元测试(第 1 部分)</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-to-write-unit-tests-easily-with-gtest-c-part-1-2399f36693e6?source=collection_archive---------6-----------------------#2022-11-19">https://blog.devgenius.io/how-to-write-unit-tests-easily-with-gtest-c-part-1-2399f36693e6?source=collection_archive---------6-----------------------#2022-11-19</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/c415aff6adeec27b104c383cf79327a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p3JJZBNg9UwQgtJm-WAEkA.jpeg"/></div></div></figure><h1 id="3628" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">介绍</h1><p id="9116" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi lr translated">这是一个快速入门指南，所以没有太多的解释，但我已经包括了参考资料。对于本教程，我使用的是 Visual Studio 2022。</p><p id="f661" class="pw-post-body-paragraph kt ku in kv b kw ma ky kz la mb lc ld le mc lg lh li md lk ll lm me lo lp lq ig bi translated">提醒一下，以下是你需要知道的:</p><ul class=""><li id="fabd" class="mf mg in kv b kw ma la mb le mh li mi lm mj lq mk ml mm mn bi translated">要编写单元测试，应该使用什么库？</li><li id="579e" class="mf mg in kv b kw mo la mp le mq li mr lm ms lq mk ml mm mn bi translated">测试类应该放在哪里？</li><li id="a134" class="mf mg in kv b kw mo la mp le mq li mr lm ms lq mk ml mm mn bi translated">在 C++中，我如何模仿对象？</li><li id="196e" class="mf mg in kv b kw mo la mp le mq li mr lm ms lq mk ml mm mn bi translated">测试功能:我如何执行它们？</li><li id="f9d3" class="mf mg in kv b kw mo la mp le mq li mr lm ms lq mk ml mm mn bi translated">包管理:它是如何工作的？</li></ul><h1 id="3c61" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">为什么是 GTest？</h1><p id="ff33" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">C++中单元测试的框架有很多，比如 Catch2、Gtest、CppUnit、Doctest 等。我们的软件部门目前正在使用 Catch2。但是，我决定用 Gtest 代替 Catch2。您可以阅读以下文档，了解不同之处以及我选择 Gtest 而不是 Catch2 的原因:</p><div class="mt mu gp gr mv mw"><a href="https://cuhkszlib-xiaoxing.readthedocs.io/en/latest/external/gtest/googletest/docs/FAQ.html" rel="noopener  ugc nofollow" target="_blank"><div class="mx ab fo"><div class="my ab mz cl cj na"><h2 class="bd io gy z fp nb fr fs nc fu fw im bi translated">为什么要用 Google Test 而不是我喜欢的 C++测试框架？-cuhkszlib-小星…</h2><div class="nd l"><h3 class="bd b gy z fp nb fr fs nc fu fw dk translated">如果您在这里找不到问题的答案，并且您已经阅读了初级和高级指南，请将它发送到…</h3></div><div class="ne l"><p class="bd b dl z fp nb fr fs nc fu fw dk translated">cuhkszlib-Xiaoxing . readthedocs . io</p></div></div></div></a></div><h1 id="e767" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">准备使用 GTest</h1><p id="fe51" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">在 Visual Studio 中安装最新版本的 Gtest 框架</p><figure class="ng nh ni nj gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nf"><img src="../Images/ff2d1fe598eebae875f7cd12fa8c8806.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3XjTcxDhXx4ktZU3VpVuCA.png"/></div></div></figure><p id="0eac" class="pw-post-body-paragraph kt ku in kv b kw ma ky kz la mb lc ld le mc lg lh li md lk ll lm me lo lp lq ig bi translated">以下是我将添加到测试类中的所有头文件:</p><pre class="ng nh ni nj gt nk nl nm bn nn no bi"><span id="6502" class="np jw in nl b be nq nr l ns nt">#include &lt;gmock/gmock.h&gt;<br/>using ::testing::Return;<br/>using ::testing::_;</span></pre><h1 id="47ca" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">包装管理</h1><p id="2ce5" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">为了保持整洁，我将通过创建一个并行源代码树，把测试放在“同一个”包中。</p><pre class="ng nh ni nj gt nk nl nm bn nn no bi"><span id="9584" class="np jw in nl b be nq nr l ns nt">Header files/<br/>  repository/<br/>    mappers/<br/>      TimeMapper.h</span></pre><pre class="nu nk nl nm bn nn no bi"><span id="086a" class="np jw in nl b be nq nr l ns nt">Tests/<br/>  repository/<br/>    mappers/<br/>      TimeMapperTest.cpp</span></pre><h1 id="9229" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">生产代码</h1><blockquote class="nv nw nx"><p id="90ef" class="kt ku ny kv b kw ma ky kz la mb lc ld nz mc lg lh oa md lk ll ob me lo lp lq ig bi translated">出于本文的目的，我们将把包含项目逻辑并在生产中运行的系统部分称为“生产代码”。<strong class="kv io">我们将项目中包含测试的部分称为“测试代码”,这些测试验证应用程序(生产代码)是否按预期工作</strong></p></blockquote><div class="mt mu gp gr mv mw"><a href="https://hackernoon.com/how-to-deal-with-test-and-production-code-c64acd9a062" rel="noopener  ugc nofollow" target="_blank"><div class="mx ab fo"><div class="my ab mz cl cj na"><h2 class="bd io gy z fp nb fr fs nc fu fw im bi translated">如何处理测试和生产代码</h2><div class="nd l"><h3 class="bd b gy z fp nb fr fs nc fu fw dk translated">在处理测试代码和产品代码时，我们可以识别一些模式。为了这篇文章的目的，我们…</h3></div><div class="ne l"><p class="bd b dl z fp nb fr fs nc fu fw dk translated">hackernoon.com</p></div></div><div class="oc l"><div class="od l oe of og oc oh jt mw"/></div></div></a></div><h1 id="c127" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">单元测试的三个部分</h1><p id="dbcd" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">任何语言中的任何单元测试函数都有三个主要部分:</p><ul class=""><li id="0143" class="mf mg in kv b kw ma la mb le mh li mi lm mj lq mk ml mm mn bi translated"><strong class="kv io">安排</strong></li><li id="b93e" class="mf mg in kv b kw mo la mp le mq li mr lm ms lq mk ml mm mn bi translated"><strong class="kv io">行动</strong></li><li id="0ada" class="mf mg in kv b kw mo la mp le mq li mr lm ms lq mk ml mm mn bi translated"><strong class="kv io">断言</strong></li></ul><blockquote class="nv nw nx"><p id="1b08" class="kt ku ny kv b kw ma ky kz la mb lc ld nz mc lg lh oa md lk ll ob me lo lp lq ig bi translated">单元测试方法<strong class="kv io">的 Arrange 部分初始化对象，并设置传递给测试方法</strong>的数据值。</p><p id="ceff" class="kt ku ny kv b kw ma ky kz la mb lc ld nz mc lg lh oa md lk ll ob me lo lp lq ig bi translated">Act 部分用安排好的参数调用测试中的方法。</p><p id="eb22" class="kt ku ny kv b kw ma ky kz la mb lc ld nz mc lg lh oa md lk ll ob me lo lp lq ig bi translated">断言部分验证被测方法的行为是否符合预期。</p></blockquote><div class="mt mu gp gr mv mw"><a href="https://automationpanda.com/2020/07/07/arrange-act-assert-a-pattern-for-writing-good-tests/" rel="noopener  ugc nofollow" target="_blank"><div class="mx ab fo"><div class="my ab mz cl cj na"><h2 class="bd io gy z fp nb fr fs nc fu fw im bi translated">Arrange-Act-Assert:一种编写好测试的模式</h2><div class="nd l"><h3 class="bd b gy z fp nb fr fs nc fu fw dk translated">测试是对行为进行测试以确定该行为是否正常运行的过程。有几个…</h3></div><div class="ne l"><p class="bd b dl z fp nb fr fs nc fu fw dk translated">automationpanda.com</p></div></div><div class="oc l"><div class="oi l oe of og oc oh jt mw"/></div></div></a></div><h1 id="7086" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">单元测试方法</h1><p id="489f" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">单元测试函数可以用两种方式编写。它们各有利弊。我们不能说哪一个更好，但是要用在合适的地方。</p><h1 id="a2fa" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">最后测试方法</h1><blockquote class="nv nw nx"><p id="72d0" class="kt ku ny kv b kw ma ky kz la mb lc ld nz mc lg lh oa md lk ll ob me lo lp lq ig bi translated">最后测试方法是我们大多数人坚持的常规方法，也是编写测试最直观的方法。</p><p id="59cb" class="kt ku ny kv b kw ma ky kz la mb lc ld nz mc lg lh oa md lk ll ob me lo lp lq ig bi translated">基本上，您首先编写应用程序代码，然后用测试覆盖它。这里没什么太复杂的；这是开发软件的“正常”方式。</p></blockquote><h1 id="3ae0" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">测试优先方法(TDD)</h1><blockquote class="nv nw nx"><p id="dbb5" class="kt ku ny kv b kw ma ky kz la mb lc ld nz mc lg lh oa md lk ll ob me lo lp lq ig bi translated">测试优先的方法是相反的:您首先为您将要开发的功能编写一个测试，然后编写功能本身。</p><p id="0bac" class="kt ku ny kv b kw ma ky kz la mb lc ld nz mc lg lh oa md lk ll ob me lo lp lq ig bi translated">简言之，这就是测试驱动开发(TDD)。TDD 不仅仅如此(见下文)，但是测试和生产代码的排序是与传统方法最重要的区别。</p></blockquote><p id="7e59" class="pw-post-body-paragraph kt ku in kv b kw ma ky kz la mb lc ld le mc lg lh li md lk ll lm me lo lp lq ig bi translated">下面是 TDD 流程示意图:</p><figure class="ng nh ni nj gt jo gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/3e0f79948ca6ccf709d34a9341123c60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1110/format:webp/0*3-PxP6SKbuC_uxRM.png"/></div></figure><div class="mt mu gp gr mv mw"><a href="https://khorikov.org/posts/2022-01-24-test-first-vs-test-last-approaches/" rel="noopener  ugc nofollow" target="_blank"><div class="mx ab fo"><div class="my ab mz cl cj na"><h2 class="bd io gy z fp nb fr fs nc fu fw im bi translated">先试验与后试验的方法</h2><div class="nd l"><h3 class="bd b gy z fp nb fr fs nc fu fw dk translated">今天，我想谈谈何时编写测试的话题:在生产代码之前还是之后。最后一次测试…</h3></div><div class="ne l"><p class="bd b dl z fp nb fr fs nc fu fw dk translated">khorikov.org</p></div></div><div class="oc l"><div class="ok l oe of og oc oh jt mw"/></div></div></a></div><p id="05d5" class="pw-post-body-paragraph kt ku in kv b kw ma ky kz la mb lc ld le mc lg lh li md lk ll lm me lo lp lq ig bi translated">因为我选择了长期的方法，所以我选择了 TDD。我希望本文中的测试是这样编写的。</p><h1 id="b413" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">嘲弄的</h1><p id="6d74" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">在我们的例子中，我们将模仿类并存根它们的函数。我们先来复习一下。</p><blockquote class="nv nw nx"><p id="cace" class="kt ku ny kv b kw ma ky kz la mb lc ld nz mc lg lh oa md lk ll ob me lo lp lq ig bi translated">Mocking 是<strong class="kv io">当被测试的单元有外部依赖</strong>时，在单元测试中使用的过程。模仿的目的是隔离并关注被测试的代码，而不是外部依赖的行为或状态。</p><p id="9003" class="kt ku ny kv b kw ma ky kz la mb lc ld nz mc lg lh oa md lk ll ob me lo lp lq ig bi translated">在模拟测试中，<strong class="kv io">依赖区域单元被替换为模拟重要单元行为的对象</strong>。它基于基于行为的验证。模拟对象通过创建一个伪对象来实现真实对象的接口。因此，它被称为模拟。</p></blockquote><h1 id="308e" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated"><strong class="ak">存根</strong></h1><blockquote class="nv nw nx"><p id="ea45" class="kt ku ny kv b kw ma ky kz la mb lc ld nz mc lg lh oa md lk ll ob me lo lp lq ig bi translated">Stub 是一个对象，它将基于一组特定的输入返回特定的结果，并且通常不会响应测试程序之外的任何内容。使用 JustMock，您可以用最少的代码在测试中创建一个存根，清楚地表明依赖项将如何响应以及被测试的系统应该如何表现。</p></blockquote><div class="mt mu gp gr mv mw"><a href="https://www.telerik.com/products/mocking/unit-testing.aspx#:~:text=What%20is%20mocking%3F,or%20state%20of%20external%20dependencies" rel="noopener  ugc nofollow" target="_blank"><div class="mx ab fo"><div class="my ab mz cl cj na"><h2 class="bd io gy z fp nb fr fs nc fu fw im bi translated">单元测试的模拟框架</h2><div class="nd l"><h3 class="bd b gy z fp nb fr fs nc fu fw dk translated">单元测试在软件开发中越来越受欢迎。然而，众多的框架、工具和…</h3></div><div class="ne l"><p class="bd b dl z fp nb fr fs nc fu fw dk translated">www.telerik.com</p></div></div><div class="oc l"><div class="ol l oe of og oc oh jt mw"/></div></div></a></div><h1 id="1b0f" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">测试套件和测试用例</h1><blockquote class="nv nw nx"><p id="a93e" class="kt ku ny kv b kw ma ky kz la mb lc ld nz mc lg lh oa md lk ll ob me lo lp lq ig bi translated">测试套件是为了测试执行目的而分组的测试用例的集合。</p></blockquote><div class="mt mu gp gr mv mw"><a href="https://www.ibm.com/docs/en/elm/7.0.3?topic=scripts-test-cases-test-suites" rel="noopener  ugc nofollow" target="_blank"><div class="mx ab fo"><div class="my ab mz cl cj na"><h2 class="bd io gy z fp nb fr fs nc fu fw im bi translated">测试用例及测试套件</h2><div class="nd l"><h3 class="bd b gy z fp nb fr fs nc fu fw dk translated">一个测试用例回答了这个问题:“我要测试什么？”你开发测试用例来定义你必须…</h3></div><div class="ne l"><p class="bd b dl z fp nb fr fs nc fu fw dk translated">www.ibm.com</p></div></div></div></a></div><p id="fd80" class="pw-post-body-paragraph kt ku in kv b kw ma ky kz la mb lc ld le mc lg lh li md lk ll lm me lo lp lq ig bi translated">正如我所说的，这里我们想要测试一个服务类。那么这里的测试套件名称是什么呢？是“ServiceTest”。然后，我们应该考虑我们的测试用例名称。</p><blockquote class="nv nw nx"><p id="c57f" class="kt ku ny kv b kw ma ky kz la mb lc ld nz mc lg lh oa md lk ll ob me lo lp lq ig bi translated">测试用例中有什么？</p><p id="2ca3" class="kt ku ny kv b kw ma ky kz la mb lc ld nz mc lg lh oa md lk ll ob me lo lp lq ig bi translated">什么是测试用例？在软件测试的上下文中，测试用例指的是验证特定特性或功能所需的一系列动作。本质上，测试用例详细描述了验证一个特性所必需的步骤、数据、先决条件和后置条件。</p></blockquote><div class="mt mu gp gr mv mw"><a href="https://www.browserstack.com/guide/how-to-write-test-cases" rel="noopener  ugc nofollow" target="_blank"><div class="mx ab fo"><div class="my ab mz cl cj na"><h2 class="bd io gy z fp nb fr fs nc fu fw im bi translated">如何用示例编写测试用例| BrowserStack</h2><div class="nd l"><h3 class="bd b gy z fp nb fr fs nc fu fw dk translated">在软件测试的上下文中，测试用例指的是验证特定功能所需的一系列动作…</h3></div><div class="ne l"><p class="bd b dl z fp nb fr fs nc fu fw dk translated">www.browserstack.com</p></div></div><div class="oc l"><div class="om l oe of og oc oh jt mw"/></div></div></a></div><p id="4790" class="pw-post-body-paragraph kt ku in kv b kw ma ky kz la mb lc ld le mc lg lh li md lk ll lm me lo lp lq ig bi translated">这是我们运行第一个测试需要知道的一切。我们将在文章的下一部分编写我们的第一个场景。</p><div class="mt mu gp gr mv mw"><a href="https://medium.com/@miladv33/how-to-write-unit-tests-easily-with-gtest-c-part-2-bb6b8fd0b3db" rel="noopener follow" target="_blank"><div class="mx ab fo"><div class="my ab mz cl cj na"><h2 class="bd io gy z fp nb fr fs nc fu fw im bi translated">如何用 Gtest(C++)轻松编写单元测试(第 2 部分)</h2><div class="nd l"><h3 class="bd b gy z fp nb fr fs nc fu fw dk translated">介绍</h3></div><div class="ne l"><p class="bd b dl z fp nb fr fs nc fu fw dk translated">medium.com</p></div></div><div class="oc l"><div class="on l oe of og oc oh jt mw"/></div></div></a></div></div></div>    
</body>
</html>