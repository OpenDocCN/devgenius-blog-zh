<html>
<head>
<title>Unit Tests are a must-have for Extension methods. See why?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">单元测试是扩展方法的必备工具。明白为什么了吗？</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/unit-tests-are-a-must-have-for-extension-methods-see-why-f803211e14fa?source=collection_archive---------1-----------------------#2020-01-09">https://blog.devgenius.io/unit-tests-are-a-must-have-for-extension-methods-see-why-f803211e14fa?source=collection_archive---------1-----------------------#2020-01-09</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><p id="5fed" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">我一直以懒散著称。因此，我必须说服自己编写单元测试用例。这篇文章是写给那些避免为基本的和低风险的方法编写单元测试的人(比如我)。</p><figure class="kn ko kp kq gu kr gi gj paragraph-image"><div class="gi gj km"><img src="../Images/672f15e525e4af887d4e777098098496.png" data-original-src="https://miro.medium.com/v2/resize:fit:888/format:webp/0*Hrcj2fsibIuhrupZ.jpg"/></div><figcaption class="ku kv gk gi gj kw kx bd b be z dk translated">来自我的开发机器的图像</figcaption></figure><p id="4fc4" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">C#中的<a class="ae ky" href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/extension-methods" rel="noopener ugc nofollow" target="_blank">扩展</a>方法是实现<a class="ae ky" href="https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle" rel="noopener ugc nofollow" target="_blank">开闭原则</a>最简单也最不常用的方法。棘手的部分是调试由扩展方法引起的错误。</p><p id="5170" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">防止这些错误的最好方法是确保为扩展方法编写单元测试。</p><p id="b5f4" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">在我用一个例子演示之前，需要快速介绍一下扩展方法:</p><blockquote class="kz"><p id="a887" class="la lb ir bd lc ld le lf lg lh li kl dk translated">扩展方法是静态方法，就像被扩展的类的普通方法一样使用。因此，新的功能可以添加到现有的类中，而不需要更改或重新编译类本身。但是，由于扩展不是类的直接组成部分，因此它们不能访问私有或受保护的方法、属性或字段。</p></blockquote><p id="0a24" class="pw-post-body-paragraph jo jp ir jq b jr lj jt ju jv lk jx jy jz ll kb kc kd lm kf kg kh ln kj kk kl ik bi translated">让我们试着用一些代码来理解这一点。</p><p id="4595" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">我正在创建一个控制台应用程序，将外币转换为印度卢比。有一个名为 Currency.cs 的类，其成员变量为“Amount”和“Type”。</p><figure class="kn ko kp kq gu kr gi gj paragraph-image"><div class="gi gj lo"><img src="../Images/8f7eb362320bf9384386ab5b54bdb26d.png" data-original-src="https://miro.medium.com/v2/resize:fit:684/format:webp/1*hXvn-pFpUG2dgn5OV2goSQ.png"/></div></figure><p id="0571" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated"><strong class="jq is">用户 A </strong>为<strong class="jq is"> Currency.cs </strong>类编写一个扩展方法。<strong class="jq is"> ConvertToInr() </strong>是将货币转换成 Inr(印度卢比)的扩展方法。该方法将如下所示:</p><figure class="kn ko kp kq gu kr gi gj paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gi gj lp"><img src="../Images/7c49043deb5c326ad0d44e1f52b817bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cnWcyBId-VOvX_30refF2A.png"/></div></div></figure><p id="3e2d" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">对<strong class="jq is">用户 A </strong>的要求是只实现 AUD 和 GBP 的逻辑。正如你从上面的快照中看到的，我已经硬编码了转换率(例如，50 &amp; 90 分别对应于澳元&amp; 90 英镑)。</p><p id="17c6" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated"><strong class="jq is">用户 A </strong>使用库 NUnit 编写单元测试进行验证。测试用例如下所示。在执行时，测试用例执行成功。</p><figure class="kn ko kp kq gu kr gi gj paragraph-image"><div class="gi gj lu"><img src="../Images/6ec5dab6bb88d64ed91d51d36f4d182d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1380/format:webp/1*Ot-qD_ONeY3ncjzIRxqDBQ.png"/></div></figure><p id="e89c" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated"><strong class="jq is">用户 B </strong>出现并提出了类似的要求。在不知道扩展方法的情况下，用户 B 在 Currency.cs 类中编写了一个方法(非静态的)。</p><figure class="kn ko kp kq gu kr gi gj paragraph-image"><div class="gi gj lv"><img src="../Images/c8ecca213a82ddde05630319b0faba7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1316/format:webp/1*GERvOVvN8PSOiAMo14V6BQ.png"/></div></figure><p id="223f" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">对<strong class="jq is">用户 B </strong>的要求是只实现逻辑 GBP 而不是 AUD。</p><p id="c17a" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">尽管用户 A 编写的测试用例中没有编译错误，但是测试执行仍然会失败。类<strong class="jq is"> Currency.cs </strong>中的方法<strong class="jq is"> ConverToInr() </strong>将优先于<strong class="jq is"> CurrencyExtension.cs </strong>中定义的扩展方法。<strong class="jq is">ConvertToInr()</strong>in currency . cs 不包含任何将 AUD 转换为 Inr 的逻辑，这是测试用例失败的原因。</p><p id="e873" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">见下文:</p><figure class="kn ko kp kq gu kr gi gj paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gi gj lw"><img src="../Images/f4bea314d4ca527be5ecf2aee80d8115.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n8qRazMUqR3qIn5R_w2g5w.png"/></div></div></figure><p id="6b58" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">如果没有用户 A 编写的测试用例，来自用户 B 的代码更改将会导致后期的错误。如果扩展方法是在不同的库中编写的，调试这样的问题会更加困难。</p><p id="979a" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">这里需要注意的重要一点是，Currency.cs 中的 ConvertToInr 方法不是静态方法。这是主要原因，扩展被覆盖。</p><p id="a183" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">谢谢</p><p id="55ef" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">塔伦</p></div><div class="ab cl lx ly hv lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ik il im in io"><p id="b172" class="pw-post-body-paragraph jo jp ir jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ik bi translated">页（page 的缩写）s-Medium 是一个阅读、写作和向其他作者学习的绝佳平台。如果你想加入我的旅程，今天就加入<a class="ae ky" href="https://tarunbhatt9784.medium.com/membership" rel="noopener"> medium </a>。</p></div></div>    
</body>
</html>