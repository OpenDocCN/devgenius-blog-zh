<html>
<head>
<title>Getting started in Natural Language Processing with spaCy: Part 5</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">spaCy 自然语言处理入门:第 5 部分</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/getting-started-in-natural-language-processing-with-spacy-part-4-287975381254?source=collection_archive---------32-----------------------#2020-06-08">https://blog.devgenius.io/getting-started-in-natural-language-processing-with-spacy-part-4-287975381254?source=collection_archive---------32-----------------------#2020-06-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="5cd1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这个故事中，我们将关注词汇和搭配。</p><p id="09bc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">到目前为止，我们已经看到了如何将一段文本划分为标记，以及如何解析各个标记并使用词性、依存关系和词条进行标记。如果你错过了我以前的故事，在这里看看。</p><div class="ki kj gp gr kk kl"><a href="https://medium.com/dev-genius/getting-started-in-natural-language-processing-with-spacy-part-4-4ab7f005464" rel="noopener follow" target="_blank"><div class="km ab fo"><div class="kn ab ko cl cj kp"><h2 class="bd io gy z fp kq fr fs kr fu fw im bi translated">spaCy 自然语言处理入门:第 4 部分</h2><div class="ks l"><h3 class="bd b gy z fp kq fr fs kr fu fw dk translated">在这个故事中，我们将着重于词汇化和停用词</h3></div><div class="kt l"><p class="bd b dl z fp kq fr fs kr fu fw dk translated">medium.com</p></div></div><div class="ku l"><div class="kv l kw kx ky ku kz la kl"/></div></div></a></div><p id="5228" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这一节中，我们将识别和标记与我们自己定义的模式相匹配的特定短语。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lb"><img src="../Images/a3ee50418fc6cd06fea40cfd88b930b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HTtQseukwrBiREJf8MSVcA.jpeg"/></div></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk translated">图片来自 Spacy.io</figcaption></figure><h2 id="2513" class="lq lr in bd ls lt lu dn lv lw lx dp ly jv lz ma mb jz mc md me kd mf mg mh mi bi translated">基于规则的匹配</h2><p id="be53" class="pw-post-body-paragraph jk jl in jm b jn mj jp jq jr mk jt ju jv ml jx jy jz mm kb kc kd mn kf kg kh ig bi translated">spaCy 提供了一个名为<code class="fe mo mp mq mr b">Matcher</code>的规则匹配工具，允许您构建一个令牌模式库，然后将这些模式与一个 Doc 对象进行匹配，以返回找到的匹配列表。您可以匹配令牌的任何部分，包括文本和注释，并且可以向同一个匹配器添加多个模式。</p><pre class="lc ld le lf gt ms mr mt mu aw mv bi"><span id="3aae" class="lq lr in mr b gy mw mx l my mz">In [1]:<em class="na"># Perform standard imports<br/></em><strong class="mr io">import</strong> spacy<br/>nlp <strong class="mr io">=</strong> spacy.load('en_core_web_sm')<br/># Import the Matcher library<br/>from spacy.matcher import Matcher<br/>matcher = Matcher(nlp.vocab)</span></pre><p id="9e6f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里的<code class="fe mo mp mq mr b">matcher</code>是与当前的<code class="fe mo mp mq mr b">Vocab</code>对象配对的对象。我们可以根据需要在<code class="fe mo mp mq mr b">matcher</code>中添加和删除特定的命名匹配器。</p><h2 id="4e02" class="lq lr in bd ls lt lu dn lv lw lx dp ly jv lz ma mb jz mc md me kd mf mg mh mi bi translated">创建模式</h2><p id="4fce" class="pw-post-body-paragraph jk jl in jm b jn mj jp jq jr mk jt ju jv ml jx jy jz mm kb kc kd mn kf kg kh ig bi translated">在文学作品中，短语“太阳能”可能以一个词或两个词出现，带或不带连字符。在本节中，我们将开发一个名为“SolarPower”的匹配器，它可以找到所有三个:</p><pre class="lc ld le lf gt ms mr mt mu aw mv bi"><span id="0694" class="lq lr in mr b gy mw mx l my mz">In [3]:pattern1 <strong class="mr io">=</strong> [{'LOWER': 'solarpower'}]<br/>pattern2 <strong class="mr io">=</strong> [{'LOWER': 'solar'}, {'LOWER': 'power'}]<br/>pattern3 <strong class="mr io">=</strong> [{'LOWER': 'solar'}, {'IS_PUNCT': <strong class="mr io">True</strong>}, {'LOWER': 'power'}]<br/>matcher.add('SolarPower', <strong class="mr io">None</strong>, pattern1, pattern2, pattern3)</span></pre><p id="54d5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们来分解一下:</p><ul class=""><li id="a0bc" class="nb nc in jm b jn jo jr js jv nd jz ne kd nf kh ng nh ni nj bi translated"><code class="fe mo mp mq mr b">pattern1</code>查找小写文本为“solarpower”的单个令牌</li><li id="90bd" class="nb nc in jm b jn nk jr nl jv nm jz nn kd no kh ng nh ni nj bi translated"><code class="fe mo mp mq mr b">pattern2</code>查找两个相邻的令牌，其顺序为“太阳能”和“电力”</li><li id="a65c" class="nb nc in jm b jn nk jr nl jv nm jz nn kd no kh ng nh ni nj bi translated"><code class="fe mo mp mq mr b">pattern3</code>查找三个相邻的标记，中间的标记可以是任何标点符号。单个空格是没有标记的，所以不能算作标点。<br/>一旦我们定义了我们的模式，我们就用‘solar power’的名字将它们传递给<code class="fe mo mp mq mr b">matcher</code>，并将<em class="na">回调</em>设置为<code class="fe mo mp mq mr b">None</code>(稍后将详细介绍回调)。</li></ul><h2 id="9792" class="lq lr in bd ls lt lu dn lv lw lx dp ly jv lz ma mb jz mc md me kd mf mg mh mi bi translated">将匹配器应用于 Doc 对象</h2><pre class="lc ld le lf gt ms mr mt mu aw mv bi"><span id="b505" class="lq lr in mr b gy mw mx l my mz">In [4]:doc <strong class="mr io">=</strong> nlp(u'The Solar Power industry continues to grow as demand for solarpower increases. Solar-power cars are gaining popularity.')<br/>In [5]: found_matches <strong class="mr io">=</strong> matcher(doc)<br/>print(found_matches)</span><span id="a640" class="lq lr in mr b gy np mx l my mz">[(8656102463236116519, 1, 3), (8656102463236116519, 10, 11), (8656102463236116519, 13, 16)]</span></pre><p id="d26f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe mo mp mq mr b">matcher</code>返回元组列表。每个元组包含一个匹配 ID，start &amp; end 标记映射到 span <code class="fe mo mp mq mr b">doc[start:end]</code></p><pre class="lc ld le lf gt ms mr mt mu aw mv bi"><span id="68f8" class="lq lr in mr b gy mw mx l my mz">In [6]:<br/><strong class="mr io">for</strong> match_id, start, end <strong class="mr io">in</strong> found_matches:<br/>   string_id <strong class="mr io">=</strong> nlp.vocab.strings[match_id]  <em class="na"># get string representation<br/></em>span <strong class="mr io">=</strong> doc[start:end]                    <em class="na"># get the matched span<br/></em>print(match_id, string_id, start, end, span.text)</span><span id="0e01" class="lq lr in mr b gy np mx l my mz">8656102463236116519 SolarPower 1 3 Solar Power<br/>8656102463236116519 SolarPower 10 11 solarpower<br/>8656102463236116519 SolarPower 13 16 Solar-power</span></pre><p id="7d0e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe mo mp mq mr b">match_id</code>只是<code class="fe mo mp mq mr b">string_ID</code>‘太阳能’的哈希值</p><h2 id="e306" class="lq lr in bd ls lt lu dn lv lw lx dp ly jv lz ma mb jz mc md me kd mf mg mh mi bi translated">设置模式选项和量词</h2><p id="3653" class="pw-post-body-paragraph jk jl in jm b jn mj jp jq jr mk jt ju jv ml jx jy jz mm kb kc kd mn kf kg kh ig bi translated">您可以通过传递一个<code class="fe mo mp mq mr b">'OP':'*'</code>参数来使令牌规则可选。这让我们可以简化我们的模式列表:</p><pre class="lc ld le lf gt ms mr mt mu aw mv bi"><span id="a950" class="lq lr in mr b gy mw mx l my mz">In [7]:<em class="na"># Redefine the patterns:<br/></em>pattern1 <strong class="mr io">=</strong> [{'LOWER': 'solarpower'}]<br/>pattern2 <strong class="mr io">=</strong> [{'LOWER': 'solar'}, {'IS_PUNCT': <strong class="mr io">True</strong>, 'OP':'*'}, {'LOWER': 'power'}]<br/><em class="na"># Remove the old patterns to avoid duplication:<br/></em>matcher.remove('SolarPower')<br/><em class="na"># Add the new set of patterns to the 'SolarPower' matcher:<br/></em>matcher.add('SolarPower', <strong class="mr io">None</strong>, pattern1, pattern2)<br/>In [8]:<br/>found_matches <strong class="mr io">=</strong> matcher(doc)<br/>print(found_matches)</span><span id="6e96" class="lq lr in mr b gy np mx l my mz">[(8656102463236116519, 1, 3), (8656102463236116519, 10, 11), (8656102463236116519, 13, 16)]</span></pre><p id="cefc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这找到了两个单词的模式，有和没有连字符！</p><p id="54d4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">以下量词可以传递给<code class="fe mo mp mq mr b">'OP'</code>键:</p><p id="1e23" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">OPDescription\！通过要求模式精确匹配 0 次来否定模式？通过允许模式匹配 0 次或 1 次，使模式可选\-要求模式匹配 1 次或多次\ *允许模式匹配 0 次或多次。小心旅鼠！<br/>如果我们想同时匹配“太阳能”和“太阳能供电”，寻找“供电”的<em class="na">词条</em>并期望它是“电力”可能很有诱惑力。情况并不总是这样！<em class="na">形容词</em>‘powered’的引理还是‘powered’:</p><pre class="lc ld le lf gt ms mr mt mu aw mv bi"><span id="2791" class="lq lr in mr b gy mw mx l my mz">In [9]: pattern1 <strong class="mr io">=</strong> [{'LOWER': 'solarpower'}]<br/>pattern2 <strong class="mr io">=</strong> [{'LOWER': 'solar'}, {'IS_PUNCT': <strong class="mr io">True</strong>, 'OP':'*'}, {'LEMMA': 'power'}] <em class="na"># CHANGE THIS PATTERN<br/># Remove the old patterns to avoid duplication:<br/></em>matcher.remove('SolarPower')<br/><em class="na"># Add the new set of patterns to the 'SolarPower' matcher:<br/></em>matcher.add('SolarPower', <strong class="mr io">None</strong>, pattern1, pattern2)<br/>In [10]:<br/>doc2 <strong class="mr io">=</strong> nlp(u'Solar-powered energy runs solar-powered cars.')<br/>In [11]:<br/>found_matches <strong class="mr io">=</strong> matcher(doc2)<br/>print(found_matches)<br/>[(8656102463236116519, 0, 3)]</span></pre><p id="5673" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">matcher 找到了第一个词，因为 lemmatizer 将“Solar-powered”视为动词，而不是第二个词，因为它认为它是形容词。对于这种情况，最好设置显式令牌模式。</p><pre class="lc ld le lf gt ms mr mt mu aw mv bi"><span id="32ff" class="lq lr in mr b gy mw mx l my mz">In [12]:pattern1 <strong class="mr io">=</strong> [{'LOWER': 'solarpower'}]<br/>pattern2 <strong class="mr io">=</strong> [{'LOWER': 'solar'}, {'IS_PUNCT': <strong class="mr io">True</strong>, 'OP':'*'}, {'LOWER': 'power'}]<br/>pattern3 <strong class="mr io">=</strong> [{'LOWER': 'solarpowered'}]<br/>pattern4 <strong class="mr io">=</strong> [{'LOWER': 'solar'}, {'IS_PUNCT': <strong class="mr io">True</strong>, 'OP':'*'}, {'LOWER': 'powered'}]<br/><em class="na"># Remove the old patterns to avoid duplication:<br/></em>matcher.remove('SolarPower')<br/><em class="na"># Add the new set of patterns to the 'SolarPower' matcher:<br/></em>matcher.add('SolarPower', <strong class="mr io">None</strong>, pattern1, pattern2, pattern3, pattern4)<br/>In [13]: found_matches <strong class="mr io">=</strong> matcher(doc2)<br/>print(found_matches)</span><span id="f4c5" class="lq lr in mr b gy np mx l my mz">[(8656102463236116519, 0, 3), (8656102463236116519, 5, 8)]</span></pre><h2 id="4983" class="lq lr in bd ls lt lu dn lv lw lx dp ly jv lz ma mb jz mc md me kd mf mg mh mi bi translated">其他令牌属性</h2><p id="69dd" class="pw-post-body-paragraph jk jl in jm b jn mj jp jq jr mk jt ju jv ml jx jy jz mm kb kc kd mn kf kg kh ig bi translated">除了引理之外，我们还可以使用各种令牌属性来确定匹配规则:</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi nq"><img src="../Images/881d3c9887c7e69eb6203f7a66df43a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MYiYSqmsAMxFjviTo1Du2g.jpeg"/></div></div></figure><h2 id="2731" class="lq lr in bd ls lt lu dn lv lw lx dp ly jv lz ma mb jz mc md me kd mf mg mh mi bi translated">令牌通配符</h2><p id="b18a" class="pw-post-body-paragraph jk jl in jm b jn mj jp jq jr mk jt ju jv ml jx jy jz mm kb kc kd mn kf kg kh ig bi translated">你可以传递一个空的字典<code class="fe mo mp mq mr b">{}</code>作为通配符来代表<strong class="jm io">任意的令牌</strong>。例如，您可能想在不知道什么可能跟在<code class="fe mo mp mq mr b">#</code>字符后面的情况下检索标签:</p><p id="3ec6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">[{'ORTH': '#'}，{}]</p><h2 id="da4d" class="lq lr in bd ls lt lu dn lv lw lx dp ly jv lz ma mb jz mc md me kd mf mg mh mi bi translated">短语匹配器</h2><p id="758a" class="pw-post-body-paragraph jk jl in jm b jn mj jp jq jr mk jt ju jv ml jx jy jz mm kb kc kd mn kf kg kh ig bi translated">在上一节中，我们使用了令牌模式来执行基于规则的匹配。另一种方法——通常也是更有效的方法——是在术语列表上进行匹配。在本例中，我们使用 PhraseMatcher 从短语列表中创建一个 Doc 对象，并将其传递给<code class="fe mo mp mq mr b">matcher</code>。</p><pre class="lc ld le lf gt ms mr mt mu aw mv bi"><span id="f271" class="lq lr in mr b gy mw mx l my mz">In [14]:<em class="na"># Perform standard imports, reset nlp<br/></em><strong class="mr io">import</strong> spacy<br/>nlp <strong class="mr io">=</strong> spacy.load('en_core_web_sm')<br/>In [15]:<br/><em class="na"># Import the PhraseMatcher library<br/></em><strong class="mr io">from</strong> spacy.matcher <strong class="mr io">import</strong> PhraseMatcher<br/>matcher <strong class="mr io">=</strong> PhraseMatcher(nlp.vocab)</span></pre><p id="a7b5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这个练习中，我们将导入一篇关于<em class="na">里根经济学</em> <br/>的维基百科文章来源:<a class="ae nr" href="https://en.wikipedia.org/wiki/Reaganomics" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Reaganomics</a></p><pre class="lc ld le lf gt ms mr mt mu aw mv bi"><span id="b600" class="lq lr in mr b gy mw mx l my mz">In [16]:<strong class="mr io">with</strong> open('../TextFiles/reaganomics.txt', encoding<strong class="mr io">=</strong>'utf8') <strong class="mr io">as</strong> f:<br/>doc3 <strong class="mr io">=</strong> nlp(f.read())<br/>In [17]:<br/><em class="na"># First, create a list of match phrases:<br/></em>phrase_list <strong class="mr io">=</strong> ['voodoo economics', 'supply-side economics', 'trickle-down economics', 'free-market economics']<br/><em class="na"># Next, convert each phrase to a Doc object:<br/></em>phrase_patterns <strong class="mr io">=</strong> [nlp(text) <strong class="mr io">for</strong> text <strong class="mr io">in</strong> phrase_list]<br/><em class="na"># Pass each Doc object into matcher (note the use of the asterisk!):<br/></em>matcher.add('VoodooEconomics', <strong class="mr io">None</strong>, <strong class="mr io">*</strong>phrase_patterns)<br/><em class="na"># Build a list of matches:<br/></em>matches <strong class="mr io">=</strong> matcher(doc3)<br/>In [18]:<br/><em class="na"># (match_id, start, end)<br/></em>matches<br/>Out[18]:</span><span id="4d5e" class="lq lr in mr b gy np mx l my mz">[(3473369816841043438, 41, 45),<br/> (3473369816841043438, 49, 53),<br/> (3473369816841043438, 54, 56),<br/> (3473369816841043438, 61, 65),<br/> (3473369816841043438, 673, 677),<br/> (3473369816841043438, 2985, 2989)]</span></pre><p id="028b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">前四个匹配项是里根经济学定义中使用这些术语的地方:</p><pre class="lc ld le lf gt ms mr mt mu aw mv bi"><span id="80f1" class="lq lr in mr b gy mw mx l my mz">In [19]:doc3[:70]<br/>Out[19]:</span><span id="ecb8" class="lq lr in mr b gy np mx l my mz">REAGANOMICS<br/><a class="ae nr" href="https://en.wikipedia.org/wiki/Reaganomics" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Reaganomics</a><br/><br/>Reaganomics (a portmanteau of [Ronald] Reagan and economics attributed to Paul Harvey)[1] refers to the economic policies promoted by U.S. President Ronald Reagan during the 1980s. These policies are commonly associated with supply-side economics, referred to as trickle-down economics or voodoo economics by political opponents, and free-market economics by political advocates.</span></pre><h2 id="c816" class="lq lr in bd ls lt lu dn lv lw lx dp ly jv lz ma mb jz mc md me kd mf mg mh mi bi translated">查看比赛</h2><p id="c2c6" class="pw-post-body-paragraph jk jl in jm b jn mj jp jq jr mk jt ju jv ml jx jy jz mm kb kc kd mn kf kg kh ig bi translated">有几种方法可以获取匹配周围的文本。最简单的方法是从文档中获取一片比匹配更宽的令牌:</p><pre class="lc ld le lf gt ms mr mt mu aw mv bi"><span id="2a49" class="lq lr in mr b gy mw mx l my mz">In [20]:doc3[665:685]  <em class="na"># Note that the fifth match starts at doc3[673]<br/></em>Out[20]:<br/>same time he attracted a following from the supply-side economics movement, which formed in opposition to Keynesian<br/>In [21]:doc3[2975:2995]  <em class="na"># The sixth match starts at doc3[2985]<br/></em>Out[21]:against institutions.[66] His policies became widely known as "trickle-down economics", due to the significant</span></pre><p id="ed7e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">另一种方法是首先将<code class="fe mo mp mq mr b">sentencizer</code>应用于文档，然后遍历句子直到匹配点:</p><pre class="lc ld le lf gt ms mr mt mu aw mv bi"><span id="4836" class="lq lr in mr b gy mw mx l my mz">In [22]:<em class="na"># Build a list of sentences<br/></em>sents <strong class="mr io">=</strong> [sent <strong class="mr io">for</strong> sent <strong class="mr io">in</strong> doc3.sents]<br/><em class="na"># In the next section we'll see that sentences contain start and end token values:<br/></em>print(sents[0].start, sents[0].end)<br/>0 35<br/>In [23]:<em class="na"># Iterate over the sentence list until the sentence end value exceeds a match start value:<br/></em><strong class="mr io">for</strong> sent <strong class="mr io">in</strong> sents:<br/>  <strong class="mr io">if</strong> matches[4][1] <strong class="mr io">&lt;</strong> sent.end:  <em class="na"># this is the fifth match, that starts at doc3[673]<br/></em>print(sent)<br/><strong class="mr io">break</strong></span><span id="9047" class="lq lr in mr b gy np mx l my mz">At the same time he attracted a following from the supply-side economics movement, which formed in opposition to Keynesian demand-stimulus economics.</span></pre><p id="46f6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">欲了解更多信息，请访问<a class="ae nr" href="https://spacy.io/usage/linguistic-features#section-rule-based-matching" rel="noopener ugc nofollow" target="_blank">https://spacy . io/usage/language-features # section-rule-based-matching</a></p><p id="5f89" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是我的 NLP 空间系列的最后一个故事。以下是我之前的故事:</p><div class="ki kj gp gr kk kl"><a href="https://medium.com/dev-genius/getting-started-in-natural-language-processing-with-spacy-part-4-4ab7f005464" rel="noopener follow" target="_blank"><div class="km ab fo"><div class="kn ab ko cl cj kp"><h2 class="bd io gy z fp kq fr fs kr fu fw im bi translated">spaCy 自然语言处理入门:第 4 部分</h2><div class="ks l"><h3 class="bd b gy z fp kq fr fs kr fu fw dk translated">在这个故事中，我们将着重于词汇化和停用词</h3></div><div class="kt l"><p class="bd b dl z fp kq fr fs kr fu fw dk translated">medium.com</p></div></div><div class="ku l"><div class="kv l kw kx ky ku kz la kl"/></div></div></a></div><div class="ki kj gp gr kk kl"><a href="https://medium.com/dev-genius/getting-started-in-natural-language-processing-with-spacy-part-3-824c1b291d22" rel="noopener follow" target="_blank"><div class="km ab fo"><div class="kn ab ko cl cj kp"><h2 class="bd io gy z fp kq fr fs kr fu fw im bi translated">spaCy 自然语言处理入门:第 3 部分</h2><div class="ks l"><h3 class="bd b gy z fp kq fr fs kr fu fw dk translated">在这个故事中，我们将重点关注词干。</h3></div><div class="kt l"><p class="bd b dl z fp kq fr fs kr fu fw dk translated">medium.com</p></div></div><div class="ku l"><div class="kv l kw kx ky ku kz la kl"/></div></div></a></div><div class="ki kj gp gr kk kl"><a href="https://medium.com/dev-genius/getting-started-in-natural-language-processing-with-spacy-part-2-73ecb4eac11d" rel="noopener follow" target="_blank"><div class="km ab fo"><div class="kn ab ko cl cj kp"><h2 class="bd io gy z fp kq fr fs kr fu fw im bi translated">spaCy 自然语言处理入门:第 2 部分</h2><div class="ks l"><h3 class="bd b gy z fp kq fr fs kr fu fw dk translated">如果您错过了第 1 部分。如果您正在寻找基本安装、基本命令、令牌化，请查看它</h3></div><div class="kt l"><p class="bd b dl z fp kq fr fs kr fu fw dk translated">medium.com</p></div></div><div class="ku l"><div class="kv l kw kx ky ku kz la kl"/></div></div></a></div><div class="ki kj gp gr kk kl"><a href="https://medium.com/dev-genius/getting-started-in-natural-language-processing-with-spacy-part-1-5026748cadc2" rel="noopener follow" target="_blank"><div class="km ab fo"><div class="kn ab ko cl cj kp"><h2 class="bd io gy z fp kq fr fs kr fu fw im bi translated">spaCy 自然语言处理入门:第 1 部分</h2><div class="ks l"><h3 class="bd b gy z fp kq fr fs kr fu fw dk translated">spaCy(https://spacy.io/)是一个开源的 Python 库，可以解析和“理解”大量的文本…</h3></div><div class="kt l"><p class="bd b dl z fp kq fr fs kr fu fw dk translated">medium.com</p></div></div><div class="ku l"><div class="kv l kw kx ky ku kz la kl"/></div></div></a></div></div></div>    
</body>
</html>