<html>
<head>
<title>Graphs Data Structure: Breadth First Search</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">图形数据结构:广度优先搜索</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/graphs-data-structure-breadth-first-search-ec662dc73079?source=collection_archive---------14-----------------------#2020-07-24">https://blog.devgenius.io/graphs-data-structure-breadth-first-search-ec662dc73079?source=collection_archive---------14-----------------------#2020-07-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="c157" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一周前我们学习了<a class="ae kl" href="https://medium.com/better-programming/data-structures-with-javascript-graphs-42084ec4db22" rel="noopener">图数据结构</a>。今天我们将讨论如何使用图表。我们将试图找出图中两个节点之间的距离。这是图的主要用途之一，叫做图遍历。有两种主要的图形算法:广度优先搜索(BFS)和深度优先搜索(DFS ),今天我们将讨论BFS。</p><p id="7465" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的图表看起来是这样的:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/8d3262cba49e4a6793ea4299932d442b.png" data-original-src="https://miro.medium.com/v2/resize:fit:828/format:webp/1*Fd6li4Ow_uVN9N7HHOw3lA.png"/></div></div></figure><p id="ef44" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">广度优先搜索</strong></p><p id="b5aa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们的例子中，我们将使用邻接矩阵。这就是矩阵如何表示上图:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi ky"><img src="../Images/4bb754f6c579038250dc98e8187f7867.png" data-original-src="https://miro.medium.com/v2/resize:fit:464/format:webp/1*G3wD8Cn_wRkKJUIzZqApgg.png"/></div></figure><p id="e6e6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将从一个输入节点开始，然后访问它的所有邻居，这是一个边缘。然后拜访他们所有的邻居。点是确定节点离根节点有多近。</p><p id="5680" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们马上要写的函数将返回一个带有键值对的对象，其中key表示节点，而value表示这个节点离根节点有多远。</p><p id="5f3e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们将循环遍历邻接矩阵(2D数组)，在图上创建尽可能多的键值对。最初，我们将把距离分配给代表节点间缺乏连接的<strong class="jp ir">无穷大</strong>。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi kz"><img src="../Images/df62012b4b5a0f402b7ce17d9ea842ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:886/format:webp/1*4Z6WN-GnXZ2WpwVwgXT4Fw.png"/></div></figure><p id="6109" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，我们将根节点指定为0，因为到根节点的距离始终为0:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi la"><img src="../Images/9d64b4dce749c34e97fa1a720e08ff73.png" data-original-src="https://miro.medium.com/v2/resize:fit:574/format:webp/1*aDrX2mSfwZbm8WOLyuTc3w.png"/></div></figure><p id="5a25" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，让我们创建一个队列来跟踪要访问的节点。而<strong class="jp ir"> current </strong>变量将保存我们此刻正在处理的一个节点:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi lb"><img src="../Images/2564a139b7fe3c1b833ca5a235d2fbc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:646/format:webp/1*xq2i9yz-01Fr70EpnhTI7w.png"/></div></figure><p id="6956" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们将开始一个while循环，继续遍历队列中的节点，直到它们都被遍历完。首先从队列中移除根节点，并将其存储在变量<strong class="jp ir"> current </strong>中。</p><p id="1103" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，我们将创建一个空数组来存储当前节点的连接节点列表。<strong class="jp ir"> idx </strong>变量将从索引为1的连接节点中获取节点。如果没有索引为1的节点，那么变量的值将被设置为-1。</p><p id="738d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">之后，我们将执行另一个while循环，条件是如果idx不等于-1，则继续。在这个循环中，我们将把idx的值放入邻居节点的数组中。并将值idx重置为连接节点数组中的下一个值:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi lc"><img src="../Images/4c3da30e61d602fb76c57b5857d7d693.png" data-original-src="https://miro.medium.com/v2/resize:fit:808/format:webp/1*Q7w6zsFtq6OWJzGzfoII-g.png"/></div></figure><p id="75b7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我们需要建立另一个循环。这次我们将对循环执行<strong class="jp ir">，该循环将循环通过连接的节点并获得一个距离:</strong></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi ld"><img src="../Images/48f799fefdc59c75cdc41c1db0f16587.png" data-original-src="https://miro.medium.com/v2/resize:fit:1088/format:webp/1*yPIwfMeBtp3OkY3R9gqsSw.png"/></div></figure><p id="1356" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是BFS算法的完整代码:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="le lf l"/></div></figure><p id="f18a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">结论</strong></p><p id="84d5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">邻接矩阵广度优先搜索的时间复杂度为O(V*E)。</p><p id="e430" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下次我们将讨论深度优先搜索算法。</p><p id="6cf4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">可以在<a class="ae kl" href="https://repl.it/@PavelIlin/Graphs-breadth-first-search#index.js" rel="noopener ugc nofollow" target="_blank"> repl </a>里玩代码。</p><p id="5d8e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不断学习，不断成长！</p><p id="618f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们上<a class="ae kl" href="https://www.linkedin.com/in/pavel-ilin/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>连线吧！</p></div></div>    
</body>
</html>