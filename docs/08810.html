<html>
<head>
<title>Singleton Pattern in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Go 中的单例模式</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/singleton-pattern-in-go-538d999d752c?source=collection_archive---------3-----------------------#2022-07-12">https://blog.devgenius.io/singleton-pattern-in-go-538d999d752c?source=collection_archive---------3-----------------------#2022-07-12</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/f09aba40748a1a5f498d6dee4d0324f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yErlVpIDQVT5MxOgpKAWWw.png"/></div></div></figure><p id="6de2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Singleton 是一种创造性的模式，它允许在整个执行过程中确保只有一个来自“struct”类型的实例。</p><p id="092a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了保持相同的引用，使用 Golang 指针更容易实现单例模式。</p><p id="0476" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">示例:</p><p id="bc2a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="kt">在下面的代码中定义了一个包，其中包含一个名为</em><strong class="jx io"><em class="kt">sigleton _ connection . go</em></strong><em class="kt">的文件。文件内部定义了一个与“单例模式”相关的逻辑，由:</em>组成</p><ul class=""><li id="fc1f" class="ku kv in jx b jy jz kc kd kg kw kk kx ko ky ks kz la lb lc bi translated">私有 struct 类型，本例中为<strong class="jx io"><em class="kt">singletonCon</em></strong><em class="kt">。</em></li><li id="b11e" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks kz la lb lc bi translated">指向<strong class="jx io"> <em class="kt"> singletonCon </em> </strong>类型的私有变量。</li><li id="bb55" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks kz la lb lc bi translated">一个执行其余魔术的函数，<strong class="jx io"> GetInstance </strong>。该函数将用于验证<strong class="jx io"><em class="kt">singleton con</em></strong><em class="kt">是否已经初始化，如果为假，则设置该值，如果为真，在这种情况下，我们打印一条消息。</em></li></ul><figure class="lj lk ll lm gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi li"><img src="../Images/583020bf475e83083d73c75d723a7165.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-OHxkRK7rQoFXeJ0S6WyeA.png"/></div></div></figure><p id="d1bf" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="kt">下面的代码运行"</em><strong class="jx io"><em class="kt">【getInstace()</em></strong><em class="kt">"函数，以便在每次迭代中得到一个连接实例。</em></p><figure class="lj lk ll lm gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ln"><img src="../Images/6072f80db93343e4a33f2b71749eda4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T-HEPcmuguaYwkri7lyfgA.png"/></div></div></figure><p id="06c2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="kt">在控制台输出中，我们可以看到只有第一次迭代创建了连接实例。</em></p><figure class="lj lk ll lm gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lo"><img src="../Images/4574c8830a19de13b548a51796722850.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3QfGKgjRWOSabANXPXwOcQ.png"/></div></div></figure><h1 id="83cf" class="lp lq in bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">附加说明</h1><p id="9786" class="pw-post-body-paragraph jv jw in jx b jy mn ka kb kc mo ke kf kg mp ki kj kk mq km kn ko mr kq kr ks ig bi translated">在学习了如何用 Golang 实现这个模式之后，在结束本文之前，让我给你一些额外的信息，我将提到一些优点和缺点，以及这个模式如何与其他模式相关联。</p><h2 id="8240" class="ms lq in bd lr mt mu dn lv mv mw dp lz kg mx my md kk mz na mh ko nb nc ml nd bi translated">与其他模式的关系</h2><figure class="lj lk ll lm gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ne"><img src="../Images/4d4ccea8f72b42a4ecb0443dfcb3cd4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PRdg1jLaGMnXVSu4L-e-vA.png"/></div></div></figure><ul class=""><li id="2174" class="ku kv in jx b jy jz kc kd kg kw kk kx ko ky ks kz la lb lc bi translated">一个 Facade 通常可以被转换成一个 Singleton 模式，因为在大多数情况下一个 Facade 对象就足够了。</li></ul><h2 id="17a4" class="ms lq in bd lr mt mu dn lv mv mw dp lz kg mx my md kk mz na mh ko nb nc ml nd bi translated">利弊</h2><figure class="lj lk ll lm gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nf"><img src="../Images/d49571b41c56413c71a77c97193c4bb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2uKimBY4EeA5GbFUx0kkgg.png"/></div></div></figure><ul class=""><li id="9f88" class="ku kv in jx b jy jz kc kd kg kw kk kx ko ky ks kz la lb lc bi translated">你可以确定一个类只有一个实例。</li><li id="5160" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks kz la lb lc bi translated">帮助获得该实例的全局访问点。</li><li id="5bb7" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks kz la lb lc bi translated">Singleton 对象只有在第一次被需要时才会被初始化。</li></ul><figure class="lj lk ll lm gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ng"><img src="../Images/d714504168c9ac1d8cf05ed2b31958bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YEX5W_VD6PN_haHcCGht7Q.png"/></div></div></figure><ul class=""><li id="f524" class="ku kv in jx b jy jz kc kd kg kw kk kx ko ky ks kz la lb lc bi translated">它违反了单一责任原则。该模式同时解决了两个问题。</li><li id="a202" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks kz la lb lc bi translated">单例模式可以掩盖糟糕的设计，例如，当程序组件彼此知道太多的时候。</li><li id="e751" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks kz la lb lc bi translated">不是线程安全的，所以编写代码时要确保只为所有线程创建一个实例。</li></ul><blockquote class="nh ni nj"><p id="39ec" class="jv jw kt jx b jy jz ka kb kc kd ke kf nk kh ki kj nl kl km kn nm kp kq kr ks ig bi translated">注:<br/>本文与你能在此找到的“Golang 中的设计模式”系列相关<a class="ae nn" href="https://medium.com/@josueparra2892/desing-patters-in-golang-24a142d2cc91" rel="noopener">https://medium . com/@ josueparra 2892/Desing-Patters-in-Golang-24a 142 d2c 91</a></p></blockquote></div></div>    
</body>
</html>