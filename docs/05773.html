<html>
<head>
<title>Writing an X86–64 Assembly Language Program</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编写X86–64汇编语言程序</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/writing-an-x86-64-assembly-language-program-function-arguments-and-result-dfff25970dee?source=collection_archive---------3-----------------------#2021-10-25">https://blog.devgenius.io/writing-an-x86-64-assembly-language-program-function-arguments-and-result-dfff25970dee?source=collection_archive---------3-----------------------#2021-10-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/db5d0eb5909d19cd90eb44426cc39891.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1f4ovNyav2IyrPS5"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">由<a class="ae jd" href="https://unsplash.com/@pawel_czerwinski?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Pawel Czerwinski </a>在<a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><div class=""/><div class=""><h2 id="7294" class="pw-subtitle-paragraph kd jf jg bd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dk translated">第四部分:发送函数参数并接收返回值</h2></div><h2 id="3817" class="kv kw jg bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">本指南是系列的第四部分</h2><ul class=""><li id="77ef" class="lr ls jg lt b lu lv lw lx le ly li lz lm ma mb mc md me mf bi translated">第一部分:<a class="ae jd" href="https://medium.com/@tony.oreglia/getting-started-writing-assembly-language-8ecc116f3627" rel="noopener">开始编写汇编语言</a></li><li id="37e7" class="lr ls jg lt b lu mg lw mh le mi li mj lm mk mb mc md me mf bi translated">第二部分:<a class="ae jd" href="https://medium.com/@tony.oreglia/finding-an-efficient-development-cycle-for-writing-assembly-language-be2092e6db6a" rel="noopener">寻找编写汇编语言的高效开发周期</a></li><li id="c63b" class="lr ls jg lt b lu mg lw mh le mi li mj lm mk mb mc md me mf bi translated">第三部分:<a class="ae jd" href="https://medium.com/@tony.oreglia/writing-an-x86-64-assembly-language-program-648b6005e8e" rel="noopener">打印命令行参数</a></li></ul><h2 id="1ffd" class="kv kw jg bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">本指南后面是</h2><ul class=""><li id="220d" class="lr ls jg lt b lu lv lw lx le ly li lz lm ma mb mc md me mf bi translated">第五部分:<a class="ae jd" href="https://tony-oreglia.medium.com/writing-an-x86-64-assembly-language-program-1aade03f3b9b" rel="noopener">条件句、跳转和循环</a></li><li id="739f" class="lr ls jg lt b lu mg lw mh le mi li mj lm mk mb mc md me mf bi translated">第六部分:<a class="ae jd" href="https://tony-oreglia.medium.com/writing-an-x86-64-assembly-language-program-84e2432cf16b" rel="noopener">如何确定字符串长度</a></li><li id="f8fa" class="lr ls jg lt b lu mg lw mh le mi li mj lm mk mb mc md me mf bi translated">第七部分:<a class="ae jd" href="https://tony-oreglia.medium.com/writing-an-x86-64-assembly-language-program-f847d4edf577" rel="noopener">快速参考</a></li></ul></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h2 id="2135" class="kv kw jg bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">发送函数参数并返回结果</h2><p id="43d8" class="pw-post-body-paragraph ms mt jg lt b lu lv kh mu lw lx kk mv le mw mx my li mz na nb lm nc nd ne mb ij bi translated">在本系列的上一篇文章中，我们看到了如何在x86–64汇编中定义和调用函数。</p><p id="f53d" class="pw-post-body-paragraph ms mt jg lt b lu nf kh mu lw ng kk mv le nh mx my li ni na nb lm nj nd ne mb ij bi translated">现在我想知道如何给函数提供参数并返回值。换句话说，当这是用高级语言完成的时候，在汇编代码级别是如何翻译的呢？</p><p id="98cb" class="pw-post-body-paragraph ms mt jg lt b lu nf kh mu lw ng kk mv le nh mx my li ni na nb lm nj nd ne mb ij bi translated">答案很简单。在x86–64汇编中，有一个约定定义了哪些寄存器应该用于第一个参数、第二个参数等等。</p><figure class="nk nl nm nn gt is"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="85e2" class="pw-post-body-paragraph ms mt jg lt b lu nf kh mu lw ng kk mv le nh mx my li ni na nb lm nj nd ne mb ij bi translated">所有进一步的参数都被推送到堆栈上。</p><p id="9555" class="pw-post-body-paragraph ms mt jg lt b lu nf kh mu lw ng kk mv le nh mx my li ni na nb lm nj nd ne mb ij bi translated">返回值将存储在寄存器<code class="fe nq nr ns nt b">$rax</code>中。</p><p id="dd6a" class="pw-post-body-paragraph ms mt jg lt b lu nf kh mu lw ng kk mv le nh mx my li ni na nb lm nj nd ne mb ij bi translated">下面是一个代码示例，它利用传统的寄存器来传递参数和结果，以便打印出命令行参数</p><figure class="nk nl nm nn gt is"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="c87d" class="pw-post-body-paragraph ms mt jg lt b lu nf kh mu lw ng kk mv le nh mx my li ni na nb lm nj nd ne mb ij bi translated">还有一些定义明确的调用约定，遵循这些约定会很有帮助。见<a class="ae jd" href="https://en.wikipedia.org/wiki/X86_calling_conventions" rel="noopener ugc nofollow" target="_blank">此处</a>。</p><p id="cf75" class="pw-post-body-paragraph ms mt jg lt b lu nf kh mu lw ng kk mv le nh mx my li ni na nb lm nj nd ne mb ij bi translated">我希望你喜欢这篇文章。要了解更多，请在这里找到本系列的下一部分:<a class="ae jd" href="https://tony-oreglia.medium.com/writing-an-x86-64-assembly-language-program-1aade03f3b9b" rel="noopener">条件、跳转和循环</a>。</p></div></div>    
</body>
</html>