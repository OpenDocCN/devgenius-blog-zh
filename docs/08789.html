<html>
<head>
<title>Using Goroutines is Slower??</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 Goroutines 比较慢？？</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/using-goroutines-is-slower-ba99c2fadce9?source=collection_archive---------4-----------------------#2022-07-11">https://blog.devgenius.io/using-goroutines-is-slower-ba99c2fadce9?source=collection_archive---------4-----------------------#2022-07-11</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="fdfa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">啊，戈鲁丁斯。Go 编程语言最重要的特性之一。一旦你理解了 goroutines 的语法和并发性背后的理论，你会觉得好像获得了一种超能力。一把锤子，如果你愿意的话。我们很兴奋能让一切同时进行。我肯定有罪。我是说，为什么不呢，对吧？并发性解决了代码阻塞的问题，所以尽可能让所有事情都并发会加快速度，对吗？</p><p id="df9b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有时候，太多太多，并不是所有的事情都是你可以钉的钉子。</p><h1 id="cce7" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">但是首先，介绍一下 Go 中的并发性</h1><p id="e3e6" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">阅读这篇文章，你可能至少有一些编写并发 Go 代码的经验。但是为了以防万一，我将快速解释并发性和 goroutines。</p><p id="bec6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">随着我们越来越擅长编程和构建更大的项目，我们不可避免地会遇到障碍。有一项工作至少需要几秒钟。也许那份工作就是给你的用户发一封电子邮件。可能是读取解析 CSV 或者 JSON。也许只是一个傻乎乎的复杂计算。如果你的程序一次只为一个或两个用户服务，那就更好了。然而，想象一下必须发送一百万封电子邮件或者必须解析一百万个 JSON 流对象。你的服务会被这些缓慢的操作屏蔽掉，人们使用起来会有很恐怖的体验。</p><p id="e663" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们如何解决这个问题？一个人想了一段时间这个问题，决定做好晚饭后再多想想。他想要一只美味多汁的烤鸡。他开始腌制鸡肉，并把它放进冰箱，让它静置 30 分钟。当鸡肉放在冰箱里的时候，他开始切一些生菜和洋葱做沙拉…然后它来了。这是他需要做的！让阻塞代码先运行，同时运行代码的其他部分！他可以在鸡肉腌好之后检查一下，然后再烤！</p><p id="5607" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">上面的故事是对并发程序如何工作的一种过于简单化的描述。Go 使用 goroutines 来委派这些任务。主 goroutine 负责运行<code class="fe ll lm ln lo b">main</code>函数，工作 go routine 各自处理并发运行的代码部分。</p><p id="8108" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，并发与并行有点不同，并行是一个类似的概念。然而，并行就像让两个厨师同时做不同的菜，而并发就像让一个厨师处理不同的任务。是的，这可能会令人困惑。我认为这种困惑源于我们把每一个 goroutine 都当成了独立的物体。为了简化，我们称他们为<em class="lp">工人 T2，但他们实际上并不是一起工作的独立工人。它们仅仅是由一个厨师完成的<em class="lp">道独立工序</em>。他们是<em class="lp"> goroutines </em>，不是<em class="lp"> goworkers </em>(懂了吗？协程和同事？是吗？…好吧，我停下来)。</em></p><h1 id="3f86" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">超级有效！</h1><p id="02ca" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">我们将在实验中使用下面的片段。</p><pre class="lq lr ls lt gt lu lo lv lw aw lx bi"><span id="e910" class="ly kj in lo b gy lz ma l mb mc">package main</span><span id="bbce" class="ly kj in lo b gy md ma l mb mc">import (<br/>    "encoding/csv"<br/>    "fmt"<br/>    "os"<br/>)</span><span id="a02b" class="ly kj in lo b gy md ma l mb mc">func main() {<br/>    db := map[string][][]string{<br/>        "AgeDataset-V1.csv": nil,<br/>        "neo_v2.csv":        nil,<br/>        "nba.csv":           nil,<br/>        "airquality.csv":    nil,<br/>        "titanic.csv":       nil,<br/>    }<br/>    for file := range db {<br/>        db[file] = ReadCsv(file)<br/>    }<br/>}</span><span id="0e7e" class="ly kj in lo b gy md ma l mb mc">func ReadCsv(filepath string) [][]string {<br/>    f, err := os.Open(filepath)<br/>    if err != nil {<br/>        fmt.Println(err)<br/>    }<br/>    defer f.Close()</span><span id="a6aa" class="ly kj in lo b gy md ma l mb mc">    csvr := csv.NewReader(f)<br/>    rows, err := csvr.ReadAll()<br/>    if err != nil {<br/>        fmt.Println(err)<br/>    }</span><span id="5351" class="ly kj in lo b gy md ma l mb mc">    return rows<br/>}</span></pre><p id="de94" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ll lm ln lo b">ReadCsv</code>是一个非常简单的代码，用来读取 CSV 文件。它接受文件的路径，并以<code class="fe ll lm ln lo b">[][]string</code>的格式返回文件中的数据。<code class="fe ll lm ln lo b">main</code>函数包含一个<code class="fe ll lm ln lo b">db</code>对象，它是一个映射，将文件路径匹配到里面的数据。这个<code class="fe ll lm ln lo b">main</code>函数是串行的，因为在循环内部的操作完成之前，for 循环不会进入下一次迭代。</p><p id="01b1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下面是<code class="fe ll lm ln lo b">main</code>函数的一个并发版本:</p><pre class="lq lr ls lt gt lu lo lv lw aw lx bi"><span id="c623" class="ly kj in lo b gy lz ma l mb mc">func main() {<br/>    db := map[string][][]string{<br/>        "AgeDataset-V1.csv": nil,<br/>        "neo_v2.csv":        nil,<br/>        "nba.csv":           nil,<br/>        "airquality.csv":    nil,<br/>        "titanic.csv":       nil,<br/>    }</span><span id="5947" class="ly kj in lo b gy md ma l mb mc">    var wg sync.WaitGroup</span><span id="b50b" class="ly kj in lo b gy md ma l mb mc">    wg.Add(5)<br/>    for file := range db {<br/>        go func(file string) {<br/>            defer wg.Done()<br/>            db[file] = ReadCsv(file)<br/>        }(file)<br/>    }<br/>    wg.Wait()<br/>}</span></pre><p id="423e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们首先创建<code class="fe ll lm ln lo b">wg</code>，一个 waitgroup，它检查有多少 goroutines 仍在工作。对于每个文件，我们启动一个运行<code class="fe ll lm ln lo b">ReadCsv</code>的 goroutine，并在完成后从<code class="fe ll lm ln lo b">wg</code>中减去 1。我们在最后等待，直到每一次例行公事都结束。</p><p id="7ee7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们的基准代码非常简单:</p><pre class="lq lr ls lt gt lu lo lv lw aw lx bi"><span id="4d52" class="ly kj in lo b gy lz ma l mb mc">func BenchmarkMain(b *testing.B) {<br/>    for i := 0; i &lt; b.N; i++ {<br/>        main()<br/>    }<br/>}</span></pre><p id="6870" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">以下是基准测试结果:</p><pre class="lq lr ls lt gt lu lo lv lw aw lx bi"><span id="b72b" class="ly kj in lo b gy lz ma l mb mc">// serial<br/>$ go test -bench=Main -benchtime=10s<br/>goos: linux<br/>goarch: amd64<br/>pkg: example.com/slowconc<br/>cpu: Intel(R) Core(TM) i7-7700K CPU @ 4.20GHz<br/>BenchmarkMain-8               18         609132683 ns/op<br/>PASS<br/>ok      example.com/slowconc    11.633s</span><span id="2e26" class="ly kj in lo b gy md ma l mb mc">// concurrent<br/>$ go test -bench=Main -benchtime=10s<br/>goos: linux<br/>goarch: amd64<br/>pkg: example.com/slowconc<br/>cpu: Intel(R) Core(TM) i7-7700K CPU @ 4.20GHz<br/>BenchmarkMain-8               20         559101265 ns/op<br/>PASS<br/>ok      example.com/slowconc    11.781s</span></pre><p id="b402" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您可以看到并发代码比串行代码快了大约 50 毫秒。在这些情况下，我们很高兴:并发确实使我们的代码运行得更快。让我们看看当这不发生时会发生什么。</p><h1 id="c676" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">不是很有效…</h1><p id="f01a" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">让我们看看什么时候使用 goroutines 适得其反。</p><pre class="lq lr ls lt gt lu lo lv lw aw lx bi"><span id="3c93" class="ly kj in lo b gy lz ma l mb mc">func FindSum(list []int) int {<br/>    sum := 0<br/>    for _, number := range list {<br/>        sum += number<br/>    }<br/>    return sum<br/>}</span><span id="ac95" class="ly kj in lo b gy md ma l mb mc">func FindSumConc(list []int) int {<br/>    sum := 0<br/>    var rwm sync.RWMutex</span><span id="1021" class="ly kj in lo b gy md ma l mb mc">    var wg sync.WaitGroup<br/>    wg.Add(len(list))<br/>    for _, number := range list {<br/>        go func(number int) {<br/>            defer wg.Done()<br/>            rwm.Lock()<br/>            defer rwm.Unlock()<br/>            sum += number<br/>        }(number)<br/>    }<br/>    wg.Wait()</span><span id="f52c" class="ly kj in lo b gy md ma l mb mc">    return sum<br/>}</span></pre><p id="d3ce" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是我们将用来运行第二个实验的两个函数。这两个函数都返回列表中整数的和。并发版本使用互斥来防止数据竞争。这意味着当一个 goroutine 写入<code class="fe ll lm ln lo b">sum</code>时，其他 go routine 无法写入。</p><p id="7063" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们将使用这个基准代码:</p><pre class="lq lr ls lt gt lu lo lv lw aw lx bi"><span id="58a4" class="ly kj in lo b gy lz ma l mb mc">func BenchmarkFindSum(b *testing.B) {<br/>    list := make([]int, 0)<br/>    for i := 0; i &lt; 1000000; i++ {<br/>        list = append(list, rand.Intn(1000000))<br/>    }<br/>    b.ResetTimer()<br/>    for i := 0; i &lt; b.N; i++ {<br/>        FindSum(list)<br/>    }<br/>}</span><span id="da37" class="ly kj in lo b gy md ma l mb mc">func BenchmarkFindSumConc(b *testing.B) {<br/>    list := make([]int, 0)<br/>    for i := 0; i &lt; 1000000; i++ {<br/>        list = append(list, rand.Intn(1000000))<br/>    }<br/>    b.ResetTimer()<br/>    for i := 0; i &lt; b.N; i++ {<br/>        FindSumConc(list)<br/>    }<br/>}</span></pre><p id="2d6a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">结果如下:</p><pre class="lq lr ls lt gt lu lo lv lw aw lx bi"><span id="fdaf" class="ly kj in lo b gy lz ma l mb mc">$ go test -bench=FindSum -benchtime=10s<br/>goos: linux<br/>goarch: amd64<br/>pkg: example.com/slowconc<br/>cpu: Intel(R) Core(TM) i7-7700K CPU @ 4.20GHz<br/>BenchmarkFindSum-8                 50497            243623 ns/op<br/>BenchmarkFindSumConc-8                45         266713213 ns/op<br/>PASS<br/>ok      example.com/slowconc    27.144s</span></pre><p id="7ac4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">令人惊讶，不是吗？您会认为并发版本运行得更快。毕竟有一百万个整数要加。但是不行，并发版本要慢 1000 倍左右。</p><h1 id="534b" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">为什么会这样呢？</h1><p id="2b38" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">简单来说，就是因为两个问题的性质。软件开发人员遇到的瓶颈主要有两种类型:</p><ul class=""><li id="2c82" class="me mf in jm b jn jo jr js jv mg jz mh kd mi kh mj mk ml mm bi translated"><strong class="jm io"> CPU 受限的作业。</strong>这些工作依赖于你的 CPU 速度。像复杂的计算、破解加密和寻找圆周率的第 n 位数字这样的工作都是受 CPU 限制的。</li><li id="e756" class="me mf in jm b jn mn jr mo jv mp jz mq kd mr kh mj mk ml mm bi translated">与 IO 相关的工作。这些工作依赖于读取速度和写入速度。像从文件中读取数据和通过网络请求资源这样的工作是 IO 绑定的。</li></ul><p id="6d20" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在我们的例子中，读取 CSV 文件的第一个例子是 IO 绑定的，因为 goroutines 必须调用操作系统来读取文件，并等待数据被使用。我们计算总和的第二个例子是 CPU 受限的，因为我们一直在计算，直到我们处理完列表中的最后一个整数。</p><p id="1ff1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在处理并发时，我们需要理解一个概念。当有多个 goroutine 运行时，我们管理 go routine 的调度程序需要决定运行哪个 go routine。记住，并发不是同时运行几个作业；这是关于任务之间的转换。这种变戏法的行为被称为<strong class="jm io">上下文切换。</strong></p><p id="7812" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里有一个问题:当我们从一个 goroutine 切换到另一个 goroutine 时，被换出的 go routine 在技术上暂时被暂停。更确切地说，它们进入两种状态之一:等待或可运行。等待状态意味着 goroutine 正在等待系统或网络的响应。可运行状态意味着 goroutine 需要关注，这样它就可以运行它正在做的任何事情。</p><p id="76e2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们想想这个。当 goroutine 处于等待状态时，调度程序现在不必花时间担心它，因为 goroutine 无论如何都要等待响应。因此，短暂的停顿通常是好的。但是，如果 goroutine 处于运行状态，这意味着计算会暂停，直到调度程序将其换入。这里的短暂停顿会对性能造成毁灭性的影响。</p><p id="ca47" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你需要投掷和捕捉十个球，这是一个 IO 绑定的任务。你扔一个球，然后继续下一个球。当你转换的时候，你并没有放慢你的进度，因为当你扔出一个球的时候，这个球需要时间飞起来，然后再落下来。你基本上是在休息时间扔剩下的球。</p><p id="f9e1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然而，如果你需要清空十个球篮，这是一个 CPU 密集型的任务。唯一能让它更快的方法就是更快地扔掉球。从一个篮切换到另一个篮会阻止其他篮中发生任何清空。所以在这里，切换并不能帮助你更快地完成。如果有的话，切换到另一个篮子的行为将增加延迟，降低您的速度。</p><p id="806b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">与 CPU 相关的作业相比，IO 相关的作业从并发设计中获益更多。我们也可以在我们的基准测试结果中看到这一点。</p><h1 id="d3cd" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">结论</h1><p id="b569" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">希望这篇文章不会太混乱。我记得在尝试研究并发性时，我完全迷失了方向。如果您想知道为什么您的并发代码运行缓慢，请检查您的作业是受 CPU 限制还是受 IO 限制。如果受 CPU 限制，您可能需要利用并行性。或者更简单的说，做一些优化，提高你的算法的时间复杂度。</p><p id="7ac9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">感谢阅读！你可以在<a class="ae ms" href="https://dev.to/jpoly1219/using-goroutines-is-slower-3b53" rel="noopener ugc nofollow" target="_blank">发展到</a>和<a class="ae ms" href="https://jpoly1219.github.io" rel="noopener ugc nofollow" target="_blank">我的个人网站</a>上阅读这篇文章。</p></div></div>    
</body>
</html>