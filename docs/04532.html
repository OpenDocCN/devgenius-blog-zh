<html>
<head>
<title>Caching with NSCache in iOS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在 iOS 中使用 NSCache 进行缓存</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/caching-with-nscache-in-ios-2e97be8d6b53?source=collection_archive---------1-----------------------#2021-03-30">https://blog.devgenius.io/caching-with-nscache-in-ios-2e97be8d6b53?source=collection_archive---------1-----------------------#2021-03-30</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/478312259c5ad8f82e22bca60eef6a40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qrzU_8ey993nF1dHIyKO9A.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">图书馆里的书架(<a class="ae jz" href="https://www.flickr.com/photos/opengridscheduler/22468805072/in/photolist-AeuuWU-9L4DC-akFR3u-akFR6d-9tba2y-9t8aqZ-GvPgzi-2XUSwK-n3VAH-8ds4hQ-LRd69z-54AriK-8ew2F6-6goydB-6cFVL4-9uPVG8-rX7yXD-82iqbY-4h2pzN-PDrUTj-82ipB5-hW9GkX-ci8s7s-5Emj44-923VJQ-sTdb6-HRXqoR-4ZUyno-dvUBA7-bVpm9T-aVn2eF-7X3HF7-6tQvry-afnzip-afqnMW-dvNU6a-72DYa6-anxHwx-29gdmz9-zeT59-n3S1U-eem4U-iEvVHU-LYVZXx-C2vb6p-ghnoDc-9Dp34Y-5Y64MV-kb9aZB-25Gs167" rel="noopener ugc nofollow" target="_blank"> Flickr </a></figcaption></figure><p id="cf71" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">与 Swift 标准库(如<code class="fe ky kz la lb b">Dictionary</code>)中的集合相比，<code class="fe ky kz la lb b">NSCache</code>更适合缓存对象，因为当系统内存不足时，NSCache 会自动驱逐对象，这反过来使我们的应用程序本身能够在内存中保留更长时间。</p><figure class="lc ld le lf gt jo"><div class="bz fp l di"><div class="lg lh l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">NSCache</figcaption></figure><p id="64b1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">ns cache 的局限性</strong></p><ul class=""><li id="48c8" class="li lj in kc b kd ke kh ki kl lk kp ll kt lm kx ln lo lp lq bi translated">这是一个客观的 C 类</li><li id="ed47" class="li lj in kc b kd lr kh ls kl lt kp lu kt lv kx ln lo lp lq bi translated">它可以存储类实例</li><li id="8fed" class="li lj in kc b kd lr kh ls kl lt kp lu kt lv kx ln lo lp lq bi translated">键应该基于 NSObject(例如 NSString vs String，NSNumber vs Int)</li><li id="731c" class="li lj in kc b kd lr kh ls kl lt kp lu kt lv kx ln lo lp lq bi translated">缓存值没有现成的到期日<em class="lw"/></li></ul><p id="4759" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在围绕 NSCache 编写了一个简单的代理类之后，您可以在 Swift 中最大限度地利用它。</p><figure class="lc ld le lf gt jo"><div class="bz fp l di"><div class="lg lh l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">通用自定义缓存</figcaption></figure><p id="a502" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">想法是能够使用任何引用或值类型作为符合<a class="ae jz" href="https://developer.apple.com/documentation/swift/hashable" rel="noopener ugc nofollow" target="_blank"> Hashable </a>协议的键。</p><p id="6fb5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们从一个内部 CacheEntry 类开始，其中一个<code class="fe ky kz la lb b">Value</code>与一个可选的 expiryDate 属性驻留在一起。</p><p id="75ff" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">页（page 的缩写）如果不想将 CacheEntry 定义为 CustomCache 的内部类，也可以在 CustomCache 上定义一个扩展来访问泛型值。</p><figure class="lc ld le lf gt jo"><div class="bz fp l di"><div class="lg lh l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">值容器类</figcaption></figure><p id="47f4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">接下来，我们将需要一个自定义的 NSObject 子类来托管我们的 hashable 键，以便能够将其用于 NSCache。如果您想只使用 String 作为缓存的键，可以跳过这一部分，在 insert 函数中将 String 转换为 NSString。</p><figure class="lc ld le lf gt jo"><div class="bz fp l di"><div class="lg lh l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">保存可散列密钥的 KeyWrapper。</figcaption></figure><p id="21a2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们的自定义类可以保存一个私有的 NSCache 对象用于内部访问。</p><figure class="lc ld le lf gt jo"><div class="bz fp l di"><div class="lg lh l"/></div></figure><p id="890c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们可以定义所需的插入、删除和获取值函数。</p><figure class="lc ld le lf gt jo"><div class="bz fp l di"><div class="lg lh l"/></div></figure><p id="29b8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">用途</strong></p><figure class="lc ld le lf gt jo"><div class="bz fp l di"><div class="lg lh l"/></div></figure><p id="568f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">订阅</strong></p><p id="c065" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们可以定义一个下标来更容易地访问缓存的值。</p><figure class="lc ld le lf gt jo"><div class="bz fp l di"><div class="lg lh l"/></div></figure><p id="46a4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你可以从下面的<a class="ae jz" href="https://gist.github.com/IronLeash/7d4a5583a85d60cb36d2e35e53427c42" rel="noopener ugc nofollow" target="_blank">链接</a>中获得完整的类。</p><p id="9c0d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">结论</strong></p><p id="7193" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">使用 NSCache 而不是简单的字典带来的好处主要在内存管理部分。一旦你有了一个通用的自定义缓存类，你就可以将它用于任何本地缓存目的。</p></div></div>    
</body>
</html>