<html>
<head>
<title>Using Machine Learning to Predict Patients’ Diabetes Status</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用机器学习来预测患者的糖尿病状态</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/using-machine-learning-to-predict-patients-diabetes-status-481643dc7389?source=collection_archive---------0-----------------------#2020-12-19">https://blog.devgenius.io/using-machine-learning-to-predict-patients-diabetes-status-481643dc7389?source=collection_archive---------0-----------------------#2020-12-19</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><h1 id="2be1" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">"数据科学家严重短缺。"</h1><p id="0906" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">米（meter的缩写））斯通布拉克(图灵奖获得者)，2020年3月。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi lg"><img src="../Images/e3376799fc5fdfc64eb25a864e2eef17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*M4dv3Xjo40XyyW2YBsX-3w.jpeg"/></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk translated">www.unsplash.com</figcaption></figure><p id="60be" class="pw-post-body-paragraph ki kj in kk b kl ls kn ko kp lt kr ks kt lu kv kw kx lv kz la lb lw ld le lf ig bi translated">在本文中，我们将介绍一些关于<strong class="kk io">机器学习</strong>的基础知识，并使用<strong class="kk io"> Python库</strong>来实现它们。我会尽量简单，避免使用太多的<em class="lx">【技术术语】</em>来表达那些在编程或机器学习方面还不扎实的人。</p><h2 id="2707" class="ly jl in bd jm lz ma dn jq mb mc dp ju kt md me jy kx mf mg kc lb mh mi kg mj bi translated">关于数据集</h2><p id="55ea" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">该数据集包含来自患者的2000个观察结果，具有8个特征和一个表明他们是否患有糖尿病的目标。关于患者的8个记录特征包括怀孕、葡萄糖、血压、皮肤厚度、胰岛素、身体质量指数、糖尿病谱系功能(基于家族的糖尿病可能性)和年龄。这里的目标名为“结果”，如果患者有糖尿病，则为“1”，如果没有糖尿病，则为“0”。</p><p id="aef6" class="pw-post-body-paragraph ki kj in kk b kl ls kn ko kp lt kr ks kt lu kv kw kx lv kz la lb lw ld le lf ig bi">𝐅𝐞𝐚𝐭𝐮𝐫𝐞𝐬 (𝐈𝐧𝐝𝐞𝐩𝐞𝐧𝐝𝐞𝐧𝐭 𝐕𝐚𝐫𝐢𝐚𝐛𝐥𝐞𝐬 𝐨𝐫 𝐈𝐧𝐩𝐮𝐭):</p><ol class=""><li id="f8b4" class="mk ml in kk b kl ls kp lt kt mm kx mn lb mo lf mp mq mr ms bi translated">怀孕</li><li id="8210" class="mk ml in kk b kl mt kp mu kt mv kx mw lb mx lf mp mq mr ms bi translated">葡萄糖</li><li id="5717" class="mk ml in kk b kl mt kp mu kt mv kx mw lb mx lf mp mq mr ms bi translated">血压</li><li id="0c04" class="mk ml in kk b kl mt kp mu kt mv kx mw lb mx lf mp mq mr ms bi translated">表皮厚度</li><li id="b8be" class="mk ml in kk b kl mt kp mu kt mv kx mw lb mx lf mp mq mr ms bi translated">胰岛素</li><li id="f3db" class="mk ml in kk b kl mt kp mu kt mv kx mw lb mx lf mp mq mr ms bi translated">身体质量指数</li><li id="4f47" class="mk ml in kk b kl mt kp mu kt mv kx mw lb mx lf mp mq mr ms bi translated">糖尿病谱系功能</li><li id="943e" class="mk ml in kk b kl mt kp mu kt mv kx mw lb mx lf mp mq mr ms bi translated">年龄</li></ol><p id="5c8f" class="pw-post-body-paragraph ki kj in kk b kl ls kn ko kp lt kr ks kt lu kv kw kx lv kz la lb lw ld le lf ig bi">𝐓𝐚𝐫𝐠𝐞𝐭 (𝐃𝐞𝐩𝐞𝐧𝐝𝐞𝐧𝐭 𝐕𝐚𝐫𝐢𝐚𝐛𝐥𝐞 𝐨𝐫 𝐎𝐮𝐭𝐩𝐮𝐭):</p><ol class=""><li id="82c6" class="mk ml in kk b kl ls kp lt kt mm kx mn lb mo lf mp mq mr ms bi translated">结果</li></ol><h2 id="2276" class="ly jl in bd jm lz ma dn jq mb mc dp ju kt md me jy kx mf mg kc lb mh mi kg mj bi translated">想了解一些机器学习的基础知识？</h2><p id="f0e5" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">机器学习是一门训练计算机根据数据做出决策的科学，而不是针对每种情况进行显式编程。机器学习可以大致分为两个分支，即<strong class="kk io">监督</strong>和<strong class="kk io">非监督</strong>学习。</p><p id="3790" class="pw-post-body-paragraph ki kj in kk b kl ls kn ko kp lt kr ks kt lu kv kw kx lv kz la lb lw ld le lf ig bi translated"><strong class="kk io">监督学习:</strong>是机器学习的一种最常见的分支，通常是人们在使用术语<strong class="kk io">机器学习</strong>时所指的，并且是<strong class="kk io">学习</strong>的任务，即基于示例<strong class="kk io">输入输出对</strong>将<strong class="kk io">输入</strong>映射到<strong class="kk io">输出</strong>的功能。最常见的<strong class="kk io">监督学习</strong>是<strong class="kk io">分类模型，</strong>如<strong class="kk io">决策树</strong>，其目的是根据输入<strong class="kk io"> </strong>和<strong class="kk io">回归</strong>对观察值进行分类，后者根据一组输入变量预测标量响应变量。</p><p id="854d" class="pw-post-body-paragraph ki kj in kk b kl ls kn ko kp lt kr ks kt lu kv kw kx lv kz la lb lw ld le lf ig bi translated"><strong class="kk io">无监督学习:</strong>是一种类型的<strong class="kk io">机器学习</strong>算法，用于从由没有标记响应的输入数据组成的数据集进行推断。最常见的<strong class="kk io">无监督学习</strong>方法是<strong class="kk io">聚类分析</strong>，用于探索性数据分析，寻找数据中隐藏的模式或分组。</p><p id="f3c2" class="pw-post-body-paragraph ki kj in kk b kl ls kn ko kp lt kr ks kt lu kv kw kx lv kz la lb lw ld le lf ig bi translated">此外，数据科学项目中一个关键但被忽视的步骤是<strong class="kk io">数据可视化</strong>和<strong class="kk io">探索性数据分析(EDA) </strong>。<strong class="kk io"> EDA </strong>是一个必要的步骤，以便在我们训练模型和查看有助于决策的结果之前，更好地了解我们的数据看起来如何，以及它是否符合所有要求。</p><h2 id="695f" class="ly jl in bd jm lz ma dn jq mb mc dp ju kt md me jy kx mf mg kc lb mh mi kg mj bi translated">我们在本文中的范围</h2><p id="b146" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">在本文中，我们将使用:</p><p id="eba7" class="pw-post-body-paragraph ki kj in kk b kl ls kn ko kp lt kr ks kt lu kv kw kx lv kz la lb lw ld le lf ig bi translated">通过一个名为<code class="fe my mz na nb b"><strong class="kk io">scikit-learn</strong></code>的流行库对方法进行分类，这个库处理算法背后的大量技术数学。</p><p id="dd03" class="pw-post-body-paragraph ki kj in kk b kl ls kn ko kp lt kr ks kt lu kv kw kx lv kz la lb lw ld le lf ig bi translated"><strong class="kk io">二。NumPy: </strong>一个Python库，允许我们处理数组、矩阵和执行线性代数(它代表数值Python)。</p><p id="cecb" class="pw-post-body-paragraph ki kj in kk b kl ls kn ko kp lt kr ks kt lu kv kw kx lv kz la lb lw ld le lf ig bi translated"><strong class="kk io">三。Pandas: </strong>一个Python库，提供了快速、灵活、富于表现力的数据结构，用于处理<em class="lx">关系数据</em>和*标签数据。它是用Python进行实际的、真实世界的数据分析的一个基本的高级构建块。</p><p id="dbc0" class="pw-post-body-paragraph ki kj in kk b kl ls kn ko kp lt kr ks kt lu kv kw kx lv kz la lb lw ld le lf ig bi translated"><strong class="kk io">四。</strong>两个流行的Python库，用于创建可视化(<strong class="kk io"> Matplotlib </strong>和<strong class="kk io"> Seaborn </strong>)以及查看数据分析第一步中使用的一些常用步骤。</p><p id="55cc" class="pw-post-body-paragraph ki kj in kk b kl ls kn ko kp lt kr ks kt lu kv kw kx lv kz la lb lw ld le lf ig bi translated">总的来说，我们将看看如何通过<strong class="kk io">探索性数据分析(EDA) </strong>来理解糖尿病数据集。我们还将看看如何用<strong class="kk io">糖尿病数据集</strong>训练一个模型(<strong class="kk io"> k近邻</strong>分类算法)，并使用它来预测新患者是否患有糖尿病。最后，我们将讨论确定我们的模型有多好的各种方法。</p><h2 id="c7cc" class="ly jl in bd jm lz ma dn jq mb mc dp ju kt md me jy kx mf mg kc lb mh mi kg mj bi translated">先决条件</h2><p id="db62" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">对于本文，我将使用<strong class="kk io">Python</strong>&amp;<strong class="kk io">Jupyter笔记本</strong>。</p><p id="f9ae" class="pw-post-body-paragraph ki kj in kk b kl ls kn ko kp lt kr ks kt lu kv kw kx lv kz la lb lw ld le lf ig bi translated">使用<strong class="kk io"> Python </strong>最简单的方法是通过<a class="ae nc" href="https://docs.anaconda.com/anaconda/install/" rel="noopener ugc nofollow" target="_blank"> <strong class="kk io"> Anaconda </strong> </a>，因为它附带了你可能需要的所有必需的包。</p><p id="831e" class="pw-post-body-paragraph ki kj in kk b kl ls kn ko kp lt kr ks kt lu kv kw kx lv kz la lb lw ld le lf ig bi translated"><strong class="kk io">小心！</strong>笔记本本质上是Python的一个交互会话，因此当你创建变量时，它们会被存储在内存中。当不按顺序重新运行单元时(即，在运行上一个单元之前运行一个单元)，这可能会有问题，因此您的代码可能不会按预期运行。这对于那些不太熟悉编程的人来说尤其成问题，但是即使是有经验的用户也会被它绊倒，因为它不直观。</p><p id="1e21" class="pw-post-body-paragraph ki kj in kk b kl ls kn ko kp lt kr ks kt lu kv kw kx lv kz la lb lw ld le lf ig bi translated"><strong class="kk io">本文使用的笔记本和数据集可以在Github上</strong> <a class="ae nc" href="https://github.com/nuhu-ibrahim/Articles/tree/main/Machine%20Learning" rel="noopener ugc nofollow" target="_blank"> <strong class="kk io">这里</strong> </a> <strong class="kk io">找到。</strong></p><h2 id="d1dc" class="ly jl in bd jm lz ma dn jq mb mc dp ju kt md me jy kx mf mg kc lb mh mi kg mj bi translated">探索性数据分析</h2><p id="e7a2" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">首先，我们需要导入一些常用于EDA和可视化的库。Matplotlib和Seaborn是Python中两个简单的绘图库。</p><p id="27ae" class="pw-post-body-paragraph ki kj in kk b kl ls kn ko kp lt kr ks kt lu kv kw kx lv kz la lb lw ld le lf ig bi translated">𝐍𝐨𝐭𝐞:是一个样式表，我们用它来使我们的可视化看起来更像样。</p><pre class="lh li lj lk gt nd nb ne nf aw ng bi"><span id="7478" class="ly jl in nb b gy nh ni l nj nk">import numpy as np<br/>import pandas as pd</span><span id="1bc9" class="ly jl in nb b gy nl ni l nj nk"># We will use the Seaborn library<br/>import seaborn as sns</span><span id="1f12" class="ly jl in nb b gy nl ni l nj nk"># Matplotlib forms basis for visualisation in Python<br/>import matplotlib.pyplot as plt</span><span id="63db" class="ly jl in nb b gy nl ni l nj nk"># Set the default style for plots<br/>plt.style.use('Datern.mplstyle')<br/>colors = plt.rcParams["axes.prop_cycle"]()</span><span id="c6c3" class="ly jl in nb b gy nl ni l nj nk">#Gradient colours<br/>from matplotlib.colors import LinearSegmentedColormap<br/>nodes = [0,0.5,1.0]<br/>color = ['#00ACF0','#ffffff']<br/>cmap = LinearSegmentedColormap.from_list("", list(zip(nodes, color)))</span><span id="bb2a" class="ly jl in nb b gy nl ni l nj nk">%config InlineBackend.figure_format='retina'</span></pre><p id="6246" class="pw-post-body-paragraph ki kj in kk b kl ls kn ko kp lt kr ks kt lu kv kw kx lv kz la lb lw ld le lf ig bi translated">现在，我们将糖尿病数据集(<code class="fe my mz na nb b">diabetes-dataset.csv</code>)加载到笔记本中，并开始探索其中的特征:</p><pre class="lh li lj lk gt nd nb ne nf aw ng bi"><span id="7948" class="ly jl in nb b gy nh ni l nj nk">df = pd.read_csv('diabetes-dataset.csv')</span></pre><p id="4bf0" class="pw-post-body-paragraph ki kj in kk b kl ls kn ko kp lt kr ks kt lu kv kw kx lv kz la lb lw ld le lf ig bi translated">然后，我们可以使用Panda，使用<code class="fe my mz na nb b">.dtypes</code>查看数据集中的特征类型，或者使用<code class="fe my mz na nb b">.info()</code>查看更多细节</p><pre class="lh li lj lk gt nd nb ne nf aw ng bi"><span id="ec6f" class="ly jl in nb b gy nh ni l nj nk">df.dtypes</span></pre><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="nn no di np bf nq"><div class="gh gi nm"><img src="../Images/0e1e6dc71d1462657c1a21b5ead5a3bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1eT0xbvo56I7F61NVqcQeQ.png"/></div></div></figure><pre class="lh li lj lk gt nd nb ne nf aw ng bi"><span id="30e0" class="ly jl in nb b gy nh ni l nj nk">df.info()</span></pre><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="nn no di np bf nq"><div class="gh gi nr"><img src="../Images/62b7f5178a243a0e02d6e516412a725d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wObF2qmOYZYGPUebZM7Bsw.png"/></div></div></figure><p id="4bc3" class="pw-post-body-paragraph ki kj in kk b kl ls kn ko kp lt kr ks kt lu kv kw kx lv kz la lb lw ld le lf ig bi translated">现在来看看我们的一些数据，我们可以使用<code class="fe my mz na nb b">.head()</code>来查看前5个条目</p><pre class="lh li lj lk gt nd nb ne nf aw ng bi"><span id="38fb" class="ly jl in nb b gy nh ni l nj nk">df.head()</span></pre><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="nn no di np bf nq"><div class="gh gi ns"><img src="../Images/7641924d94ff5437daf2af2a766ec4b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2D8Z6YyBPxcO1tjAkvqFFA.png"/></div></div></figure><p id="0847" class="pw-post-body-paragraph ki kj in kk b kl ls kn ko kp lt kr ks kt lu kv kw kx lv kz la lb lw ld le lf ig bi translated">我们可以使用<code class="fe my mz na nb b">.tail()</code>和<code class="fe my mz na nb b">.sample()</code>查看数据的其他部分</p><pre class="lh li lj lk gt nd nb ne nf aw ng bi"><span id="b56b" class="ly jl in nb b gy nh ni l nj nk"># Prints the last 10 entries <br/>df.tail(10)</span></pre><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="nn no di np bf nq"><div class="gh gi nt"><img src="../Images/6c0241abcc2f917168f335c0026124af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l1gm_GTfdNrkNooLia36Pg.png"/></div></div></figure><pre class="lh li lj lk gt nd nb ne nf aw ng bi"><span id="fc23" class="ly jl in nb b gy nh ni l nj nk"># Produces a random sample from the data<br/>df.sample(frac=.01)</span></pre><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="nn no di np bf nq"><div class="gh gi nt"><img src="../Images/6d7d47cee7bdeb1e6680d35c7932ce8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1LgIyiG-ISZc_TssMXoBig.png"/></div></div></figure><p id="a784" class="pw-post-body-paragraph ki kj in kk b kl ls kn ko kp lt kr ks kt lu kv kw kx lv kz la lb lw ld le lf ig bi translated">在我们开始可视化之前，我们还可以更好地理解数据集中的定量变量，这些变量有助于理解我们的连续数据，使用<code class="fe my mz na nb b">.describe()</code>:</p><pre class="lh li lj lk gt nd nb ne nf aw ng bi"><span id="0e67" class="ly jl in nb b gy nh ni l nj nk">df.describe()</span></pre><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="nn no di np bf nq"><div class="gh gi nu"><img src="../Images/6deeac827e6cf92c0410230fa4df1244.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_37LSnRAbfJz_hsIwI3-Og.png"/></div></div></figure><h1 id="6b5b" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">数据可视化</h1><p id="279e" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">数据可视化是我们数据的图形化表示。我们使用图表、图形和地图来更容易地查看数据集中的趋势和其他特征。</p><pre class="lh li lj lk gt nd nb ne nf aw ng bi"><span id="0bea" class="ly jl in nb b gy nh ni l nj nk"># Now we make continous plots of quantitative data<br/>fig=plt.figure(figsize=(20,20))<br/>for i,col in enumerate(df.drop(['Outcome'],axis=1)):<br/>    ax=fig.add_subplot(4,2,i+1)<br/>    sns.distplot(df[col])</span></pre><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="nn no di np bf nq"><div class="gh gi nv"><img src="../Images/04431dcda5606bd91e3eb48ec4e62d10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Gk6wi63uEfFJpXe1EqknZw.png"/></div></div></figure><h2 id="e1bf" class="ly jl in bd jm lz ma dn jq mb mc dp ju kt md me jy kx mf mg kc lb mh mi kg mj bi translated">观察</h2><ol class=""><li id="c746" class="mk ml in kk b kl km kp kq kt nw kx nx lb ny lf mp mq mr ms bi translated">血压、葡萄糖和身体质量指数分布均匀。</li><li id="b533" class="mk ml in kk b kl mt kp mu kt mv kx mw lb mx lf mp mq mr ms bi translated">皮肤厚度、糖尿病谱系功能、怀孕和年龄是正(右)倾斜的。</li><li id="8f69" class="mk ml in kk b kl mt kp mu kt mv kx mw lb mx lf mp mq mr ms bi translated">血压、皮肤厚度、胰岛素和身体质量指数具有可以被视为异常值的零值。</li></ol><pre class="lh li lj lk gt nd nb ne nf aw ng bi"><span id="1023" class="ly jl in nb b gy nh ni l nj nk">_ = sns.countplot(x='Pregnancies', hue='Outcome', data=df).set(title='Pregnancies against Outcome', xlabel='Pregnancies', ylabel='Outcome')</span></pre><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="nn no di np bf nq"><div class="gh gi nz"><img src="../Images/ee6caa309b962093062763b4742e5702.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wDaKBcASTYhbQR-Q80YXGQ.png"/></div></div></figure><h2 id="9169" class="ly jl in bd jm lz ma dn jq mb mc dp ju kt md me jy kx mf mg kc lb mh mi kg mj bi translated">解释</h2><p id="187f" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">我们将在这里观察到，尽管有更多的人怀孕次数少，但可以假设怀孕次数多的人更有可能患有糖尿病。这是因为怀孕次数少(0-2次)的女性中不到一半患有糖尿病。然而，一半或超过一半的怀孕3次以上的患者患有糖尿病。</p><pre class="lh li lj lk gt nd nb ne nf aw ng bi"><span id="063e" class="ly jl in nb b gy nh ni l nj nk">_ = sns.countplot(x='Outcome', data=df).set(title='Patients Diabetes Status Count', xlabel='Outcome', ylabel='Count')</span></pre><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="nn no di np bf nq"><div class="gh gi oa"><img src="../Images/d4339343afefe19dde7595355d19a470.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CzLLNmmKX5Ua6axaa2-9EA.png"/></div></div></figure><h2 id="e6d9" class="ly jl in bd jm lz ma dn jq mb mc dp ju kt md me jy kx mf mg kc lb mh mi kg mj bi translated">解释</h2><p id="c4de" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">这个柱状图显示了更多的人没有患糖尿病。</p><pre class="lh li lj lk gt nd nb ne nf aw ng bi"><span id="5723" class="ly jl in nb b gy nh ni l nj nk">_ = sns.countplot(x='Pregnancies', data=df).set(title='Patients Pregnancies Status Count', xlabel='Pregnancies', ylabel='Count')</span></pre><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="nn no di np bf nq"><div class="gh gi nz"><img src="../Images/df37534eebb6dc9abcd7d44646662b3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DXz7W0ZGXIkC3zWeUUTEAg.png"/></div></div></figure><h2 id="4b3b" class="ly jl in bd jm lz ma dn jq mb mc dp ju kt md me jy kx mf mg kc lb mh mi kg mj bi translated">解释</h2><p id="3287" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">接受观察的人越多，怀孕次数越少。</p><h1 id="b63a" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">分类(K-最近邻)</h1><p id="3865" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">分类是监督学习的一个众所周知的领域，其中目标变量采取类别的形式，例如给定一个电子邮件示例，分类它是否是垃圾邮件。在这个例子中，我们将使用<code class="fe my mz na nb b">k-nearest-neigbour</code>分类器，这是最直观的分类算法之一。<code class="fe my mz na nb b">k-nearest-neighbors</code>分类器是一种简单的算法，它存储所有可用的案例，并根据相似性度量(例如，距离函数)对新案例进行分类。</p><h2 id="b510" class="ly jl in bd jm lz ma dn jq mb mc dp ju kt md me jy kx mf mg kc lb mh mi kg mj bi translated">构建我们的模型</h2><p id="86cd" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">现在我们已经准备好构建我们的初始模型了。<code class="fe my mz na nb b">Scikit-learn</code>内置了一个<code class="fe my mz na nb b">KNeighborsClassifier</code>模块，这对我们来说非常简单。在这里，我们将看到如何预测患者是否可能患有糖尿病。</p><p id="c314" class="pw-post-body-paragraph ki kj in kk b kl ls kn ko kp lt kr ks kt lu kv kw kx lv kz la lb lw ld le lf ig bi translated">我们将首先为我们的目标和特征创建两个独立的数据框架。</p><pre class="lh li lj lk gt nd nb ne nf aw ng bi"><span id="b54e" class="ly jl in nb b gy nh ni l nj nk"># Create feature and target arrays<br/>y = df["Outcome"].values<br/>X = df.drop(["Outcome"], axis = 1)</span></pre><p id="b614" class="pw-post-body-paragraph ki kj in kk b kl ls kn ko kp lt kr ks kt lu kv kw kx lv kz la lb lw ld le lf ig bi translated">由于KNN使用观测值之间的距离(不一定是欧几里德距离),我们将需要调整我们的数据:</p><pre class="lh li lj lk gt nd nb ne nf aw ng bi"><span id="cc68" class="ly jl in nb b gy nh ni l nj nk">#Scaling - crucial for knn<br/>from sklearn.preprocessing import StandardScaler<br/>ss = StandardScaler()<br/>X = ss.fit_transform(X)</span></pre><p id="8ef4" class="pw-post-body-paragraph ki kj in kk b kl ls kn ko kp lt kr ks kt lu kv kw kx lv kz la lb lw ld le lf ig bi translated">现在我们需要将数据分成训练集和测试集。请注意，我们分为80%的训练和20%的测试。</p><pre class="lh li lj lk gt nd nb ne nf aw ng bi"><span id="a515" class="ly jl in nb b gy nh ni l nj nk">from sklearn.model_selection import train_test_split</span><span id="4381" class="ly jl in nb b gy nl ni l nj nk"># Split into training and test set<br/>X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.2, random_state = 42, stratify = y)</span></pre><p id="2b7c" class="pw-post-body-paragraph ki kj in kk b kl ls kn ko kp lt kr ks kt lu kv kw kx lv kz la lb lw ld le lf ig bi translated">最后，是时候构建和训练我们的模型了:</p><pre class="lh li lj lk gt nd nb ne nf aw ng bi"><span id="1786" class="ly jl in nb b gy nh ni l nj nk">from sklearn.neighbors import KNeighborsClassifier</span><span id="4ec2" class="ly jl in nb b gy nl ni l nj nk"># Create a k-NN classifier<br/>knn1 = KNeighborsClassifier()</span><span id="2c85" class="ly jl in nb b gy nl ni l nj nk"># Fit the classifier to the training data<br/>knn1.fit(X_train,y_train)</span></pre><h2 id="c496" class="ly jl in bd jm lz ma dn jq mb mc dp ju kt md me jy kx mf mg kc lb mh mi kg mj bi translated">检查我们模型的准确性</h2><p id="6924" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">现在我们需要确定我们的模型有多好。最常见的度量是准确性，即在根据数据集的20%测试数据测试模型时，我们做对了多少与做错了多少，这些数据不是用于训练模型的训练数据的一部分。</p><pre class="lh li lj lk gt nd nb ne nf aw ng bi"><span id="55e4" class="ly jl in nb b gy nh ni l nj nk"># Print the accuracy<br/>print(knn1.score(X_test, y_test))</span></pre><p id="2a75" class="pw-post-body-paragraph ki kj in kk b kl ls kn ko kp lt kr ks kt lu kv kw kx lv kz la lb lw ld le lf ig bi translated"><strong class="kk io">我们的模型可以以81%的准确率预测某人是否可能患有糖尿病——这是可以接受的！。</strong></p><p id="e105" class="pw-post-body-paragraph ki kj in kk b kl ls kn ko kp lt kr ks kt lu kv kw kx lv kz la lb lw ld le lf ig bi translated">非常感谢<a class="ae nc" href="https://twitter.com/DaternSocial" rel="noopener ugc nofollow" target="_blank"> <strong class="kk io"> Datern </strong> </a>激励我写下这篇文章。</p><p id="0023" class="pw-post-body-paragraph ki kj in kk b kl ls kn ko kp lt kr ks kt lu kv kw kx lv kz la lb lw ld le lf ig bi translated">就这样吧。</p><p id="b101" class="pw-post-body-paragraph ki kj in kk b kl ls kn ko kp lt kr ks kt lu kv kw kx lv kz la lb lw ld le lf ig bi translated">让我们继续这次谈话。在Twitter上关注我<strong class="kk io">@</strong><a class="ae nc" href="https://twitter.com/_NuhuIbrahim" rel="noopener ugc nofollow" target="_blank"><strong class="kk io">_ NuhuIbrahim</strong></a>。</p></div></div>    
</body>
</html>