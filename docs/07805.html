<html>
<head>
<title>Publisher-Subscriber Pattern 101</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">发布者-订阅者模式 101</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/publisher-subscriber-pattern-101-a0dd921025b9?source=collection_archive---------8-----------------------#2022-04-24">https://blog.devgenius.io/publisher-subscriber-pattern-101-a0dd921025b9?source=collection_archive---------8-----------------------#2022-04-24</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="b05d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这篇博客是我们从零开始讨论 101 个<strong class="jm io"> </strong>概念的系列文章的一部分，读者的入门知识有限。这篇文章属于<em class="ki">中级</em>系列，因为它涉及理解<strong class="jm io">消息传递设计原则的基础，</strong>主要是异步通信中使用的基于发布者-订阅者架构的用例。</p><p id="1703" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">101 系列中的一些早期博客如下:</p><p id="c493" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae kj" rel="noopener ugc nofollow" target="_blank" href="/api-101-773ec501b485"><strong class="jm io">API 101</strong></a><a class="ae kj" rel="noopener ugc nofollow" target="_blank" href="/async-communication-101-b04d5c95333a"><strong class="jm io"><br/>异步通信 101</strong></a><strong class="jm io"><br/></strong><a class="ae kj" rel="noopener ugc nofollow" target="_blank" href="/database-101-13d593ec4078"><strong class="jm io">数据库 101</strong></a><strong class="jm io"><br/></strong><a class="ae kj" rel="noopener ugc nofollow" target="_blank" href="/database-design-101-7c019d69b97f"><strong class="jm io">数据库设计 101 </strong> </a></p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi kk"><img src="../Images/6a2a38402d9d78dd82cc504c3a83a6cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-pg2lTz3m61MzJmIURK1uw.png"/></div></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated"><strong class="bd la">云原生消息解决方案</strong></figcaption></figure><h1 id="16c4" class="lb lc in bd la ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">什么是 Pub-Sub？</h1><p id="7180" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">在分布式架构的情况下，为了将事件生成源与事件接收源分离，并解除对大规模运行的端到端系统的阻塞，设计了<em class="ki">发布者-订阅者</em>消息传递模式。也称为发布者的发送者将消息作为事件以预定义的消息格式传输到中间层代理(<strong class="jm io"> Kafka、EventHub、Service Bus 等</strong>)中，单个/多个订阅者可以根据所选的订阅策略监听该中间层代理。</p><p id="45a9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">发布-订阅模型支持<em class="ki">单播</em> <strong class="jm io"> <em class="ki"> </em> </strong>以及<em class="ki">广播</em> <strong class="jm io"> <em class="ki"> </em> </strong>用例，而不像<a class="ae kj" href="https://badia-kharroubi.gitbooks.io/microservices-architecture/content/patterns/communication-patterns/message-queue-pattern.html" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io">消息队列模式</strong> </a> <strong class="jm io"> </strong>只支持基于<em class="ki">单播</em>的用例。</p><h1 id="361f" class="lb lc in bd la ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">常用术语</h1><ul class=""><li id="863e" class="md me in jm b jn ly jr lz jv mf jz mg kd mh kh mi mj mk ml bi translated"><strong class="jm io">发布者</strong> —生成消息并将其在消息传递基础架构中排队的客户端。</li><li id="f21d" class="md me in jm b jn mm jr mn jv mo jz mp kd mq kh mi mj mk ml bi translated"><strong class="jm io">订户</strong> —接收消息并在消息传递基础设施中将其出队的客户端。</li><li id="7349" class="md me in jm b jn mm jr mn jv mo jz mp kd mq kh mi mj mk ml bi translated"><strong class="jm io">消息代理— </strong>处理来自不同客户端的消息发布和读取请求的中间层。它以主题的形式跨副本和分区在集群内复制数据。</li><li id="7ead" class="md me in jm b jn mm jr mn jv mo jz mp kd mq kh mi mj mk ml bi translated"><strong class="jm io">主题— </strong>代理中唯一的逻辑类别，该代理提供与特定应用程序/业务用例相关的消息/事件。</li><li id="354b" class="md me in jm b jn mm jr mn jv mo jz mp kd mq kh mi mj mk ml bi translated"><strong class="jm io">分区— </strong>主题可以进一步划分为称为<a class="ae kj" href="https://medium.com/event-driven-utopia/understanding-kafka-topic-partitions-ae40f80552e8" rel="noopener"> <strong class="jm io"> <em class="ki">分区</em> </strong> </a>的逻辑单元，以实现消息的并行处理。每个分区包含由偏移量标识的唯一记录。</li><li id="8cd0" class="md me in jm b jn mm jr mn jv mo jz mp kd mq kh mi mj mk ml bi translated"><strong class="jm io"> QOS- </strong>发布者和订阅者之间的协议，告知实际消息要传递多少次- <em class="ki"> </em> <strong class="jm io"> <em class="ki">至少一次，最多一次，正好一次。</em> </strong></li></ul><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi mr"><img src="../Images/d6df882a5141cd54bf09fc13f990e63e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4PD6kc77jHEoPeJMC32FBA.png"/></div></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated"><strong class="bd la">简单发布-订阅消息模式</strong></figcaption></figure><h1 id="134f" class="lb lc in bd la ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">用例</h1><p id="58b7" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">发布者-订阅者模型用于需要生成大量事件并且即时消息保证不是最重要的应用程序用例。属于给定类别的应用程序很适合这种模式。</p><ul class=""><li id="d357" class="md me in jm b jn jo jr js jv ms jz mt kd mu kh mi mj mk ml bi translated">发送方和接收方之间的事件不需要<a class="ae kj" href="https://www.adservio.fr/post/consistency-and-completeness-in-apache-kafka" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io">强一致性</strong> </a>并且数据/事件的排序不会产生业务影响的应用。这是一个最终一致的设计模式。</li><li id="3927" class="md me in jm b jn mm jr mn jv mo jz mp kd mq kh mi mj mk ml bi translated">来自用户的实时响应对实际业务流程没有影响的应用。</li><li id="9742" class="md me in jm b jn mm jr mn jv mo jz mp kd mq kh mi mj mk ml bi translated">属于不同主题的订阅者是独立的，可以有不同的可用性和正常运行时间指标。</li></ul><h1 id="6983" class="lb lc in bd la ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">设计考虑</h1><p id="3748" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">为了将发布者-订阅者扩展到合适的可靠性和可用性 SLA，以服务于端到端业务用例，建议考虑以下设计事项。</p><ul class=""><li id="81a0" class="md me in jm b jn jo jr js jv ms jz mt kd mu kh mi mj mk ml bi translated"><strong class="jm io">幂等用户- </strong>根据整个 QOS 集，在失败的情况下，多个用户可以不止一次地发送相同的消息。因此，要求订户保持<a class="ae kj" href="https://www.cloudkarafka.com/blog/apache-kafka-idempotent-producer-avoiding-message-duplication.html" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> <em class="ki">等幂</em> </strong> </a>，即，不处理重复的消息超过一次，并且不进行重复的消息处理。</li><li id="beda" class="md me in jm b jn mm jr mn jv mo jz mp kd mq kh mi mj mk ml bi translated"><strong class="jm io">消息排序和优先级- </strong>消息可以在不同于其创建的时间线中进行处理，这取决于多个因素，例如分区、消费者群体。因此，每条消息在整个业务/应用程序流中都应该是独立的。</li><li id="5ee4" class="md me in jm b jn mm jr mn jv mo jz mp kd mq kh mi mj mk ml bi translated"><strong class="jm io">死信队列— </strong>根据消息的 TTL 设置和消费者的可用性/错误处理，一些消息可能会在<a class="ae kj" href="https://en.wikipedia.org/wiki/Dead_letter_queue" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io">死信队列</strong> </a>中结束。这些消息应该由发布者重新处理，以避免任何业务影响。</li><li id="55a8" class="md me in jm b jn mm jr mn jv mo jz mp kd mq kh mi mj mk ml bi translated"><strong class="jm io">安全性— </strong>消息代理上的不同主题应该是独立的授权策略，以确保客户不会意外地交换来自不同主题的信息。客户端证书和<a class="ae kj" href="https://www.cloudflare.com/en-in/learning/access-management/what-is-mutual-tls/" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> <em class="ki">相互 TLS </em> </strong> </a>是一些很好的安全策略。</li></ul><h1 id="2d82" class="lb lc in bd la ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">蔚蓝海岸的酒馆</h1><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi mv"><img src="../Images/58ec78fb08d3c5547285b7b6349b850b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hFxvzf5pAxFzEVSJE7Ixfg.jpeg"/></div></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated"><strong class="bd la">多层发布-订阅模型</strong></figcaption></figure><h1 id="e34c" class="lb lc in bd la ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">摘要</h1><p id="e329" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">Pub-Sub 是一种常见、简单的设计模式，用于基于 Aysnc 的分布式系统，因为它有助于为数百万客户进行扩展，而无需维护复杂的交付语义。然而，对于消息/事件需要动态路由模式的复杂用例，其他设计模式如<strong class="jm io">基于优先级队列、基于请求-回复、基于队列的负载均衡等</strong>。我们将在即将到来的关于学习功能架构的 101 篇博客中讨论它们。</p><p id="10d9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ki">如需反馈，请留言至</em><strong class="jm io"><em class="ki">Amit[dot]894[at]Gmail[dot]com</em></strong><em class="ki">或联系</em><a class="ae kj" href="https://about.me/amit_raj" rel="noopener ugc nofollow" target="_blank"><em class="ki">https://about.me/amit_raj</em></a><em class="ki">的任何链接。</em></p></div></div>    
</body>
</html>