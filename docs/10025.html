<html>
<head>
<title>Loosely coupled Microservices in PHP</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">PHP 中松散耦合的微服务</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/loosely-coupled-microservices-in-php-130699e80344?source=collection_archive---------0-----------------------#2022-10-01">https://blog.devgenius.io/loosely-coupled-microservices-in-php-130699e80344?source=collection_archive---------0-----------------------#2022-10-01</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/ed7f1372c4eaf839454be888bb6bc465.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kSYq8mkwAyQLCFOnLrR01g.jpeg"/></div></div></figure><div class=""/><p id="2f84" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在本文中，我们将深入探讨在 PHP 中集成<em class="kt">微服务</em>并保持它们松散耦合的主题。<br/>我们将关注通过<code class="fe ku kv kw kx b">messaging</code>的集成，因为通过<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/how-to-integrate-microservices-a506fe2d1a48"> HTTP 集成微服务有很多缺点</a>，需要单独的文章来解决。</p><p id="e85d" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">除了如何实现的细节和理论，我们将学习如何在 PHP 中用<a class="ae ky" href="https://github.com/ecotoneframework/ecotone" rel="noopener ugc nofollow" target="_blank">生态区框架</a>实现它(与<code class="fe ku kv kw kx b">Symfony</code>和<code class="fe ku kv kw kx b">Laravel</code>一起工作)。</p><h1 id="732b" class="kz la iy bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">共享邮件类别</h1><p id="d14a" class="pw-post-body-paragraph jv jw iy jx b jy lx ka kb kc ly ke kf kg lz ki kj kk ma km kn ko mb kq kr ks ig bi translated">因此，PHP 中最常用的解决方案之一是在单独的包中共享类，或者只是在每个服务中复制它们。<br/>这暗示了我们正在处理什么，并有助于反序列化。</p><p id="7b77" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然而，我们分享的课程越多，我们需要做的改变就越多。<br/>然后是螺旋式下降，在这种情况下，当我们进行更改时，不是发布单个服务，而是发布几个服务，因为我们需要保持它们同步。</p><h1 id="0824" class="kz la iy bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">路由消息，而不是类</h1><p id="5995" class="pw-post-body-paragraph jv jw iy jx b jy lx ka kb kc ly ke kf kg lz ki kj kk ma km kn ko mb kq kr ks ig bi translated">按类路由消息的工作原理是将类名保存在消息头中。这个头文件稍后会用到，以便知道我们应该反序列化到哪个类。</p><p id="ce6f" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当我们期望其他服务理解我们的类时，就会产生这样的情况，即其他服务需要有一个名称完全相同的类。<br/>我们很容易想象这样一种情况，我们忘记更改其中一个服务的名称，或者延迟发布另一个服务，这会产生<code class="fe ku kv kw kx b">failure due to mismatch in class names</code>。</p><blockquote class="mc md me"><p id="3717" class="jv jw kt jx b jy jz ka kb kc kd ke kf mf kh ki kj mg kl km kn mh kp kq kr ks ig bi translated">实际上，如果我们在单一服务中处理消息，仍然会产生问题。<br/>如果消息在队列中，我们将<code class="fe ku kv kw kx b">change class name or namespace</code>，将无法反序列化它。</p></blockquote><p id="fb71" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">那么，消息应该如何路由呢？<br/>在大多数情况下，我们已经使用了该解决方案，但是我们没有将其提升到应用程序级别，该解决方案是<code class="fe ku kv kw kx b">routing keys</code>。</p><blockquote class="mc md me"><p id="56bf" class="jv jw kt jx b jy jz ka kb kc kd ke kf mf kh ki kj mg kl km kn mh kp kq kr ks ig bi translated">路由关键字可以被视为事件和命令的应用程序级名称。<br/>它们在服务之间创建契约和共享命名，因此我们可以理解消息背后的意图。</p></blockquote><p id="3e8b" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当消息由路由关键字路由时，我们可以将给定的路由关键字映射到类名。<br/>结果，一个服务中的重构类名不需要在另一个服务中进行更改。</p><figure class="mi mj mk ml gt ip"><div class="bz fp l di"><div class="mm mn l"/></div></figure><blockquote class="mc md me"><p id="1e7a" class="jv jw kt jx b jy jz ka kb kc kd ke kf mf kh ki kj mg kl km kn mh kp kq kr ks ig bi translated">有了生态交错区，你实际上不需要构建任何类型的<code class="fe ku kv kw kx b">routing-key -&gt; class-name</code>地图。<br/>消息被路由到基于<code class="fe ku kv kw kx b">routing key</code>的给定处理器，然后消息的<code class="fe ku kv kw kx b">payload</code>被反序列化<code class="fe ku kv kw kx b">based on first method parameter</code>。</p></blockquote><h1 id="77eb" class="kz la iy bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">明确你的公共 API</h1><p id="6bb4" class="pw-post-body-paragraph jv jw iy jx b jy lx ka kb kc ly ke kf kg lz ki kj kk ma km kn ko mb kq kr ks ig bi translated">每当给定的事件或命令向其他服务公开时，它就成为公共 API 的一部分。<br/>如果你向外界发布每一个事件，当你想改变它的时候就成了一个问题，因为不容易清楚它是否会影响外部服务。</p><blockquote class="mc md me"><p id="30cc" class="jv jw kt jx b jy jz ka kb kc kd ke kf mf kh ki kj mg kl km kn mh kp kq kr ks ig bi translated">服务之间的契约是应用层的一部分，它们应该是显式的，而不是隐藏在 Message Broker 实现中。</p></blockquote><p id="b51b" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">生态区为发布消息的服务提供<em class="kt">分布式总线</em>。<br/>这样，如果事件要被其他服务消费，而我们需要成为<code class="fe ku kv kw kx b">aware, if we want to change it</code>，我们就可以成为<code class="fe ku kv kw kx b">explicit on the application level</code>。</p><figure class="mi mj mk ml gt ip"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="42d9" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在消费者方面，我们明确表示我们订阅的消息来自外部服务。</p><figure class="mi mj mk ml gt ip"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="56e5" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果我们不将<code class="fe ku kv kw kx b">Distributed</code>添加到<code class="fe ku kv kw kx b">Event Handler</code>中，此事件将被视为本地(私人)事件。<br/>同样适用于<code class="fe ku kv kw kx b">Distributed Command Handler</code>，如果没有明确的<code class="fe ku kv kw kx b">distributed</code>，没有一个服务能够执行我们的<code class="fe ku kv kw kx b">Command Handler</code>。</p><p id="a4b2" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这对新加入者和项目的长期来说都很清楚，哪些处理程序由<code class="fe ku kv kw kx b">external services</code>执行，哪些由<code class="fe ku kv kw kx b">local ones</code>执行。</p><blockquote class="mc md me"><p id="1120" class="jv jw kt jx b jy jz ka kb kc kd ke kf mf kh ki kj mg kl km kn mh kp kq kr ks ig bi translated">为了推进这一点，您可以使用<a class="ae ky" href="https://docs.pact.io/" rel="noopener ugc nofollow" target="_blank">契约</a>添加消费者驱动的契约。这将允许你知道你的消息中的哪些字段被其他服务使用，因此你可以容易地修改那些没有被使用的字段。</p></blockquote><h1 id="de07" class="kz la iy bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">公共和私人活动</h1><p id="8622" class="pw-post-body-paragraph jv jw iy jx b jy lx ka kb kc ly ke kf kg lz ki kj kk ma km kn ko mb kq kr ks ig bi translated">甚至，如果我们明确地发布分布式事件并限制它们的数量，我们仍然可能被其他服务阻止进行内部更改。如果我们将修改<code class="fe ku kv kw kx b">payload</code>或者我们将想要放弃或替换该事件，那么我们可能最终会影响其他方。</p><p id="f250" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这就是区分<code class="fe ku kv kw kx b">public</code>和<code class="fe ku kv kw kx b">private</code>事件的原因。通过使用<code class="fe ku kv kw kx b">DistributedBus</code>,我们已经向前迈进了一步，明确了我们要向外部发送什么事件，然而这样做还有一个好处。</p><blockquote class="mc md me"><p id="49ed" class="jv jw kt jx b jy jz ka kb kc kd ke kf mf kh ki kj mg kl km kn mh kp kq kr ks ig bi translated">在发布事件之前，我们现在可以将其转换为不同的事件。这个事件将成为我们的公共 API，另一个将在发布服务中保持私有。</p></blockquote><p id="3268" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这给了我们很多动力。只要我们能够交付这个<code class="fe ku kv kw kx b">public event</code>，我们就可以以我们想要的方式修改我们的内部服务，而不会影响其他方。</p><blockquote class="mc md me"><p id="aa97" class="jv jw kt jx b jy jz ka kb kc kd ke kf mf kh ki kj mg kl km kn mh kp kq kr ks ig bi translated">我们可以用额外的细节来丰富公共事件，所以<code class="fe ku kv kw kx b">need for consumption of other events or calling our HTTP Api will decrease</code>。</p></blockquote><figure class="mi mj mk ml gt ip"><div class="bz fp l di"><div class="mm mn l"/></div></figure><h1 id="897d" class="kz la iy bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">知道你送什么</h1><p id="84cb" class="pw-post-body-paragraph jv jw iy jx b jy lx ka kb kc ly ke kf kg lz ki kj kk ma km kn ko mb kq kr ks ig bi translated"><code class="fe ku kv kw kx b">Command</code>和<code class="fe ku kv kw kx b">Events</code>都是<code class="fe ku kv kw kx b">Messages</code>，但是它们在语义上是有区别的。</p><p id="7c7b" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="kt">命令</em> <code class="fe ku kv kw kx b">targets specific handler</code>，这意味着只有一个端点处理这个消息。<br/> <em class="kt">事件</em>则相反，不针对任何东西。它已经出版了，感兴趣的团体可以。这意味着可能有 20 个用户，但也可能没有。</p><p id="5c2b" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">那么在分布式环境下如何处理这个呢？<br/>当我们<code class="fe ku kv kw kx b">send</code>命令的时候，我们应该针对特定的服务和这个服务中给定的处理程序。这标识了目标服务，并确保没有其他服务将处理该命令。</p><blockquote class="mc md me"><p id="fdcc" class="jv jw kt jx b jy jz ka kb kc kd ke kf mf kh ki kj mg kl km kn mh kp kq kr ks ig bi translated">服务名，就像路由键一样，是应用层的一部分。我们需要知道，我们在和谁交流，为什么交流。</p></blockquote><figure class="mi mj mk ml gt ip"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="8837" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">第一个参数是目标服务名，命令将去往何处，第二个参数是处理程序的路由键。</p><blockquote class="mc md me"><p id="ddda" class="jv jw kt jx b jy jz ka kb kc kd ke kf mf kh ki kj mg kl km kn mh kp kq kr ks ig bi translated">如果目标服务中有<code class="fe ku kv kw kx b">no given handler</code>或<code class="fe ku kv kw kx b">Handler</code>不是<code class="fe ku kv kw kx b">distributed</code>，消息将失败，并可能根据配置到达<code class="fe ku kv kw kx b">DLQ</code>。</p></blockquote><p id="89dd" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在事件的情况下，每个服务也明确地声明它想要订阅什么事件。</p><blockquote class="mc md me"><p id="1430" class="jv jw kt jx b jy jz ka kb kc kd ke kf mf kh ki kj mg kl km kn mh kp kq kr ks ig bi translated">只订阅和接收给定服务感兴趣的事件，有助于保持消息流的性能。</p></blockquote><h1 id="b54b" class="kz la iy bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">消息负载可以是任何东西</h1><p id="9b36" class="pw-post-body-paragraph jv jw iy jx b jy lx ka kb kc ly ke kf kg lz ki kj kk ma km kn ko mb kq kr ks ig bi translated">PHP 中当前的框架已经建立了<code class="fe ku kv kw kx b">PHP Message implementation</code>等于<code class="fe ku kv kw kx b">Class</code>或<code class="fe ku kv kw kx b">payload</code>等于<code class="fe ku kv kw kx b">Class</code>的心理模型。<br/>消息传递原则从来不是这样，消息的有效载荷可以是任何东西，如<code class="fe ku kv kw kx b">json/xml</code>、<code class="fe ku kv kw kx b">array</code>、<code class="fe ku kv kw kx b">class</code>，甚至是<code class="fe ku kv kw kx b">int</code>或<code class="fe ku kv kw kx b">simple text string</code>。</p><blockquote class="mc md me"><p id="8416" class="jv jw kt jx b jy jz ka kb kc kd ke kf mf kh ki kj mg kl km kn mh kp kq kr ks ig bi translated">消息和消息的负载都不能是类。消息有可以反序列化到<code class="fe ku kv kw kx b">Class</code>的有效载荷，但是同时我们应该能够反序列化到<code class="fe ku kv kw kx b">array</code>或者甚至保持为<code class="fe ku kv kw kx b">json</code>，如果我们希望这样处理的话。</p></blockquote><p id="2e25" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你只需要意图呢？例如，知道发票已生成，向客户发送 sms 就足够了。你根本不需要知道细节。以这种方式查看消息会创建更加松散耦合的接口。</p><p id="f46f" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们以发布事件<code class="fe ku kv kw kx b">Order Was Placed</code>为例。</p><figure class="mi mj mk ml gt ip"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="7f96" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们可能真的不想创建类，因为我们唯一需要它来检索<code class="fe ku kv kw kx b">userId</code>发送的电子邮件。<br/>其他场景可能是，我们只想将消息有效负载直接存储在<code class="fe ku kv kw kx b">json</code>中，以便以后进行审计。</p><figure class="mi mj mk ml gt ip"><div class="bz fp l di"><div class="mm mn l"/></div></figure><blockquote class="mc md me"><p id="7e92" class="jv jw kt jx b jy jz ka kb kc kd ke kf mf kh ki kj mg kl km kn mh kp kq kr ks ig bi translated">在 Ecotone 中，无论消息的内容类型是什么(xml、json、avro、protobuf 等),只要你已经为它注册了转换器，你就可以将它反序列化为类。</p></blockquote><p id="326a" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一般来说，如果需要，我们甚至可以使用空方法声明。</p><figure class="mi mj mk ml gt ip"><div class="bz fp l di"><div class="mm mn l"/></div></figure><blockquote class="mc md me"><p id="74b9" class="jv jw kt jx b jy jz ka kb kc kd ke kf mf kh ki kj mg kl km kn mh kp kq kr ks ig bi translated">这就把权力还给开发者了。当我们觉得有必要时，我们创建类，而不是因为我们需要。</p></blockquote><h1 id="851f" class="kz la iy bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">元数据的东西</h1><p id="1d7c" class="pw-post-body-paragraph jv jw iy jx b jy lx ka kb kc ly ke kf kg lz ki kj kk ma km kn ko mb kq kr ks ig bi translated">如果我们想提供细节，比如谁是给定操作的执行者，或者发生的时间地点，或者一些基础设施信息，比如给定的订单是从哪个域发出的？</p><p id="5ff2" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这可能会在加浓<code class="fe ku kv kw kx b">public event</code>的步骤中添加到<code class="fe ku kv kw kx b">payload</code>中。然而，这可能会模糊事件的图像，而且一般来说可能与它根本没有关系。</p><p id="43f8" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">假设我们有多个客户下订单的站点，我们想用下订单的域来丰富事件的元数据。</p><figure class="mi mj mk ml gt ip"><div class="bz fp l di"><div class="mm mn l"/></div></figure><blockquote class="mc md me"><p id="38fc" class="jv jw kt jx b jy jz ka kb kc kd ke kf mf kh ki kj mg kl km kn mh kp kq kr ks ig bi translated">生态区提供了一种简单的方法来处理元数据，它会通过消息代理来传递它，并允许你在另一端使用它。</p></blockquote><h1 id="4c22" class="kz la iy bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">摘要</h1><p id="39f9" class="pw-post-body-paragraph jv jw iy jx b jy lx ka kb kc ly ke kf kg lz ki kj kk ma km kn ko mb kq kr ks ig bi translated">随着时间的推移和项目的成熟，我们需要更可靠和长期的集成解决方案。那些解决方案在其他被认为更成熟的语言中使用过，现在<code class="fe ku kv kw kx b">Ecotone</code>将它们引入 PHP，所以我们都可以从中受益并建立在坚实的基础上。</p><p id="ed56" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">松散耦合是一种艺术。它通过将隐藏的东西显化来揭示它们。以前看起来很难的事情，变得很顺利，做起来感觉很好。<br/>这是我们的目标，给我们良好的体验和共同的理解，因此我们可以面带微笑地改变服务。</p><p id="d282" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你想就<code class="fe ku kv kw kx b">Ecotone</code>或<code class="fe ku kv kw kx b">Messaging</code>提出问题或进行一般性讨论，请加入<a class="ae ky" href="https://discord.gg/CctGMcrYnV" rel="noopener ugc nofollow" target="_blank">生态脆弱区的社区频道</a>。让我们一起围绕 PHP 中的消息传递建立社区，并进一步推动我们的语言:)</p></div></div>    
</body>
</html>