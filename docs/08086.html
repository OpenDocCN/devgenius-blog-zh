<html>
<head>
<title>Linked List in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Go 中的链接列表</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/linked-list-in-go-c663eb684291?source=collection_archive---------6-----------------------#2022-05-16">https://blog.devgenius.io/linked-list-in-go-c663eb684291?source=collection_archive---------6-----------------------#2022-05-16</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="4762" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">欢迎来到我的新系列:Go 中的数据结构介绍！我们将以一个关于<em class="ki">链表</em>的帖子开始这个系列。如果你是计算机专业的学生，你可能在课堂上遇到过这些。链表不仅是 CS 课程的一部分，而且也是编码面试中一个非常受欢迎的话题，所以希望对这个话题有一个扎实的掌握。我们开始吧！</p><h1 id="61c8" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">什么是链表？</h1><p id="066a" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">链表是一种用来存储许多数据的数据结构。基本结构由通过指针相互链接的多个<em class="ki">节点</em>组成。一个节点通常由存储的数据和指向下一个节点的指针组成。</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi lm"><img src="../Images/defc5238820960188c05bfbaa8367a26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aG4lwXL0fxzMXxD-MzZM4Q.png"/></div></div></figure><p id="c87a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们通过跟随指向第一个节点的指针进入列表，也称为<em class="ki">头</em>。不要混淆，上图中只有三个节点。第一个项目<em class="ki">头</em>仅仅是指向第一个节点的指针。最后一个节点指向空值，表示列表结束。</p><p id="b7cb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">链表是用来存储数据的。然而，它们也是更复杂的数据结构(如堆栈和队列)的主干。用指针链接每个节点的想法也适用于其他数据结构，比如树和图。</p><h1 id="619e" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">链表与数组</h1><p id="74dd" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">你可能想知道，“为什么我们还要学习这种数据结构？我们没有数组吗？我们不就是在这里重新发明轮子吗？”数组是有道理的，但是数组和链表在结构上是不同的。</p><p id="d9e7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">数组在程序编译前被初始化。它需要分配一定的内存块。</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi lm"><img src="../Images/10c8b5f2675b30565c8c62f76c75c45b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-w_lwjywKYOIyzqv93iTzw.png"/></div></div></figure><p id="8c5c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当你需要寻找元素时，数组是非常有用的。数组中的每一项都有一个索引，我们可以通过使用<code class="fe ly lz ma mb b">myArr[n]</code>访问它来快速找到第 n 个元素。</p><p id="55f8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里的问题是数组不能在运行时调整大小。这意味着我们不能在运行程序后改变它的大小。如果我们的数组有四块内存，这意味着我们不能存储超过四个项目。解决这个问题的一个方法是创建一个两倍于原始数组的新数组，并复制所有元素。</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi lm"><img src="../Images/7ca55e5634ead2d7e5dedd78e93bb7a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sEBCBQ2cAOcwdy0G9_12AQ.png"/></div></div></figure><p id="fb45" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Go 切片就是这样实现的。这种方法的问题是复制大量数据的效率很低，而且我们还有很多剩余的空间。</p><p id="8392" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">链表旨在通过指针连接分散在内存中的节点来解决这个问题。这样，我们不需要事先知道我们的列表的大小。如果我们想添加一个新的节点，我们只需要创建一个并链接它。</p><p id="20f2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">虽然这里没有浪费内存，但问题是每个数据点需要比数组更多的内存，因为它还必须存储指向下一个节点的指针。另外，为了在索引<em class="ki"> n </em>处搜索元素，我们需要遍历列表，直到到达第 n 个位置。每个节点只知道下一个节点的存在，所以我们不能从一开始就访问第 n 个元素。</p><h1 id="4695" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">Go 实现</h1><p id="04d9" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">让我们看看如何在 Go 中创建一个链表。</p><pre class="ln lo lp lq gt mc mb md me aw mf bi"><span id="f265" class="mg kk in mb b gy mh mi l mj mk">type Node struct {<br/>    data int<br/>    next *Node<br/>}</span></pre><p id="cdd9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这就是节点的定义方式。每个节点保存数据和指向下一个节点的指针。我们将为该指南存储<code class="fe ly lz ma mb b">int</code>数据，但是您可以很容易地将其切换到其他类型。我们甚至可以使用<code class="fe ly lz ma mb b">interface{}</code>来存储我们想要的任何类型的数据。</p><pre class="ln lo lp lq gt mc mb md me aw mf bi"><span id="21e7" class="mg kk in mb b gy mh mi l mj mk">type LinkedList struct {<br/>    head *Node<br/>    length int<br/>}</span></pre><p id="1106" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这就是链表的定义。其中最重要的部分是头部，它存储了指向第一个节点的指针。其他属性是可选的，但是非常有用。我们添加了存储链表长度的<code class="fe ly lz ma mb b">length</code>属性。</p><pre class="ln lo lp lq gt mc mb md me aw mf bi"><span id="bce1" class="mg kk in mb b gy mh mi l mj mk">package main</span><span id="cdfc" class="mg kk in mb b gy ml mi l mj mk">import (<br/>    "fmt"<br/>)</span><span id="a232" class="mg kk in mb b gy ml mi l mj mk">func main() {<br/>    list := LinkedList{nil, 0}<br/>}</span></pre><p id="64e6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们可以这样初始化链表。初始长度为零，因为我们的列表中还没有节点。头指向<code class="fe ly lz ma mb b">nil</code>是因为没有节点可以指向。</p><p id="dbde" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在我们可以定义 struct 方法来插入和删除节点。</p><h1 id="9c80" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">插入</h1><p id="6253" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">这里我们可以考虑三种主要情况:在头部、尾部和任意位置插入。</p><pre class="ln lo lp lq gt mc mb md me aw mf bi"><span id="39bf" class="mg kk in mb b gy mh mi l mj mk">func (l *LinkedList) insertAtHead(data int) {<br/>    temp1 := &amp;Node{data, nil}</span><span id="fb2b" class="mg kk in mb b gy ml mi l mj mk">    if l.head == nil {<br/>        l.head = temp1<br/>    } else {<br/>        temp2 := l.head<br/>        l.head = temp1<br/>        temp1.next = temp2<br/>    }<br/>    l.length += 1<br/>}</span></pre><p id="0266" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个结构方法是使用指向我们的<code class="fe ly lz ma mb b">LinkedList</code>对象的指针定义的，因为我们需要对它进行修改。</p><p id="25f4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们首先创建一个节点，并将指向它的指针保存为<code class="fe ly lz ma mb b">temp1</code>。这个节点存储我们给定的数据，最初指向<code class="fe ly lz ma mb b">nil</code>。</p><p id="f045" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们需要注意两种情况。第一种情况是当列表为空时。在这种情况下，我们只需设置<code class="fe ly lz ma mb b">head</code>指向我们刚刚创建的节点。</p><p id="94d2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">第二种情况是列表不为空。这意味着<code class="fe ly lz ma mb b">head</code>已经指向了某个节点。我们需要对其进行调整，以便 head 指向我们的新节点，而新节点指向 head 曾经指向的节点。</p><ul class=""><li id="95c0" class="mm mn in jm b jn jo jr js jv mo jz mp kd mq kh mr ms mt mu bi translated">我们首先将<code class="fe ly lz ma mb b">head</code>的副本保存为<code class="fe ly lz ma mb b">temp2</code>。</li><li id="5e88" class="mm mn in jm b jn mv jr mw jv mx jz my kd mz kh mr ms mt mu bi translated">然后我们设置<code class="fe ly lz ma mb b">head</code>指向<code class="fe ly lz ma mb b">temp1</code>。</li><li id="68e3" class="mm mn in jm b jn mv jr mw jv mx jz my kd mz kh mr ms mt mu bi translated">最后，我们设置<code class="fe ly lz ma mb b">temp1</code>指向<code class="fe ly lz ma mb b">temp2.</code></li></ul><p id="46fb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我在下面画了一个图，帮助你理解其中的逻辑。</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi lm"><img src="../Images/786960a72649d1c58aa68aa5d7e5c63b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yyh2KFGFwGx5PL7P0P0Gyw.png"/></div></div></figure><p id="7d21" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最后，我们将长度增加 1。</p><p id="3275" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在尾部(末端)插入节点怎么样？</p><pre class="ln lo lp lq gt mc mb md me aw mf bi"><span id="9ebe" class="mg kk in mb b gy mh mi l mj mk">func (l *LinkedList) insertAtTail(data int) {<br/>    temp1 := &amp;Node{data, nil}</span><span id="70e6" class="mg kk in mb b gy ml mi l mj mk">    if l.head == nil {<br/>        l.head = temp1<br/>    } else {<br/>        temp2 := l.head<br/>        for temp2.next != nil {<br/>            temp2 = temp2.next<br/>        }<br/>        temp2.next = temp1<br/>    }<br/>    l.length += 1<br/>}</span></pre><p id="1334" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这也很简单。我们创建一个新节点，并将指向它的指针保存为<code class="fe ly lz ma mb b">temp1</code>。这里，我们还必须处理列表为空的情况。步骤同上。</p><p id="e82d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在有趣的部分是:为了在列表后面插入一个元素，我们需要遍历整个列表，直到到达最后一个元素。如果没有这一步，就无法访问最后一个元素。</p><ul class=""><li id="4d47" class="mm mn in jm b jn jo jr js jv mo jz mp kd mq kh mr ms mt mu bi translated">我们首先创建一个<code class="fe ly lz ma mb b">head</code>的副本作为<code class="fe ly lz ma mb b">temp2</code>。</li><li id="e740" class="mm mn in jm b jn mv jr mw jv mx jz my kd mz kh mr ms mt mu bi translated">我们通过将<code class="fe ly lz ma mb b">temp2</code>设置为<code class="fe ly lz ma mb b">temp2.next</code>来遍历列表。我们继续这样，直到<code class="fe ly lz ma mb b">temp2.next</code>是<code class="fe ly lz ma mb b">nil</code>，这意味着<code class="fe ly lz ma mb b">temp2</code>指向最后一个节点。</li><li id="b6a2" class="mm mn in jm b jn mv jr mw jv mx jz my kd mz kh mr ms mt mu bi translated">简单地说，让最后一个节点指向<code class="fe ly lz ma mb b">temp1</code>所指向的同一个节点。</li></ul><p id="9bd3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里有一个图表解释了它是如何工作的。我们将使用大量的图表，因为它们能极大地帮助我们理解。</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi lm"><img src="../Images/39615e59083150bff076f5a29bd8246d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CyORsl-lfxhhl5R1_t9lbw.png"/></div></div></figure><p id="3778" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最后，让我们看看如何在任意位置插入数据。</p><pre class="ln lo lp lq gt mc mb md me aw mf bi"><span id="178d" class="mg kk in mb b gy mh mi l mj mk">func (l *LinkedList) insert(n, data int) {<br/>    if n == 0 {<br/>        l.insertAtHead(data)<br/>    } else if n == l.length-1 {<br/>        l.insertAtTail(data)<br/>    } else {<br/>        temp1 := &amp;Node{data, nil}<br/>        temp2 := l.head</span><span id="4e06" class="mg kk in mb b gy ml mi l mj mk">        for i := 0; i &lt; n-1; i++ {<br/>            temp2 = temp2.next<br/>        }<br/>        temp1.next = temp2.next<br/>        temp2.next = temp1<br/>    }<br/>    l.length += 1<br/>}</span></pre><p id="4fbd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里的逻辑与上面两个函数非常相似。</p><ul class=""><li id="f20f" class="mm mn in jm b jn jo jr js jv mo jz mp kd mq kh mr ms mt mu bi translated">当我们想在列表的开头或结尾插入时，我们可以调用<code class="fe ly lz ma mb b">insertAtHead()</code>或<code class="fe ly lz ma mb b">insertAtTail()</code>来代替。</li><li id="de15" class="mm mn in jm b jn mv jr mw jv mx jz my kd mz kh mr ms mt mu bi translated">为了在第 n 个位置插入数据，我们需要遍历列表到达第<em class="ki"> n-1 </em>个位置。</li><li id="fbd7" class="mm mn in jm b jn mv jr mw jv mx jz my kd mz kh mr ms mt mu bi translated">一旦我们到达第 n-1 个位置，我们设置<code class="fe ly lz ma mb b">temp1.next</code>，指向新节点的指针，指向第 n+1 个位置。然后我们设置<code class="fe ly lz ma mb b">temp2</code>指向我们的新节点。</li></ul><p id="b3ab" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你现在知道该怎么做了。:)</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi lm"><img src="../Images/59bf5272a134cba7e4cc548b0bf53bad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QKarfbOSPSeND30cC4hH7w.png"/></div></div></figure><h1 id="3775" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">删除项目</h1><p id="aaa6" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">既然我们理解了整个指针操作的工作原理，我们就可以更容易地理解删除是如何工作的。我们也将把它分成三种情况:删除头部、尾部和任意位置的项目。</p><pre class="ln lo lp lq gt mc mb md me aw mf bi"><span id="3de1" class="mg kk in mb b gy mh mi l mj mk">func (l *LinkedList) deleteAtHead() {<br/>    temp := l.head<br/>    l.head = temp.next</span><span id="332e" class="mg kk in mb b gy ml mi l mj mk">    l.length -= 1<br/>}</span></pre><p id="ec3a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是删除列表中第一项的方法。我们只需要改变<code class="fe ly lz ma mb b">head</code>，使它指向第二个节点。你可能认为第一个节点会留在内存中，除非我们显式地清除它，但是我们没有。Go 内置的垃圾收集器会为我们清除这个。</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi na"><img src="../Images/2268a402188b2503e87729d5529c15fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D4lLp6TTCXxNlyV9P10yGg.png"/></div></div></figure><pre class="ln lo lp lq gt mc mb md me aw mf bi"><span id="98cf" class="mg kk in mb b gy mh mi l mj mk">func (l *LinkedList) deleteAtTail() {<br/>    temp1 := l.head<br/>    var temp2 *Node<br/>    for temp1.next != nil {<br/>        temp2 = temp1<br/>        temp1 = temp1.next<br/>    }<br/>    temp2.next = nil</span><span id="a4b4" class="mg kk in mb b gy ml mi l mj mk">    l.length -= 1<br/>}</span></pre><p id="d660" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是删除列表中最后一项的方法。逻辑是熟悉的:</p><ul class=""><li id="52f0" class="mm mn in jm b jn jo jr js jv mo jz mp kd mq kh mr ms mt mu bi translated">我们遍历列表，直到到达最后一个节点。然而，这一次，我们也跟踪了恰好在<code class="fe ly lz ma mb b">temp1</code>之前的节点。</li><li id="9658" class="mm mn in jm b jn mv jr mw jv mx jz my kd mz kh mr ms mt mu bi translated">我们设置<code class="fe ly lz ma mb b">temp2</code>指向<code class="fe ly lz ma mb b">nil</code>而不是<code class="fe ly lz ma mb b">temp1</code>。最后一个节点将被垃圾收集器清除。</li></ul><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi na"><img src="../Images/785dc31b94a635089df313ac9872e56d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*66DsCLzZWpwiUyPRL-Txpg.png"/></div></div></figure><pre class="ln lo lp lq gt mc mb md me aw mf bi"><span id="3fe2" class="mg kk in mb b gy mh mi l mj mk">func (l *LinkedList) delete(n int) {<br/>    if n == 0 {<br/>        l.deleteAtHead()<br/>    } else if n == l.length-1 {<br/>        l.deleteAtTail()<br/>    } else {<br/>        temp1 := l.head<br/>        for i := 0; i &lt; n-1; i++ {<br/>            temp1 = temp1.next<br/>        }<br/>        temp2 := temp1.next<br/>        temp1.next = temp2.next<br/>    }<br/>    l.length -= 1<br/>}</span></pre><p id="b9e5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最后，我们来看看如何在任意位置删除一个项目。</p><ul class=""><li id="4c09" class="mm mn in jm b jn jo jr js jv mo jz mp kd mq kh mr ms mt mu bi translated">如果删除第一项或最后一项，我们可以使用<code class="fe ly lz ma mb b">deleteAtHead()</code>和<code class="fe ly lz ma mb b">deleteAtTail()</code>来代替。</li><li id="4d54" class="mm mn in jm b jn mv jr mw jv mx jz my kd mz kh mr ms mt mu bi translated">逻辑和<code class="fe ly lz ma mb b">deleteAtTail()</code>很像。我们遍历列表，直到到达第 n-1 个节点。我们设置<code class="fe ly lz ma mb b">temp2</code>指向第 n 个节点。</li><li id="f272" class="mm mn in jm b jn mv jr mw jv mx jz my kd mz kh mr ms mt mu bi translated">我们将<code class="fe ly lz ma mb b">temp1.next</code>设置为指向<code class="fe ly lz ma mb b">temp2.next</code>，这有效地去除了第 n-1 个和第 n 个元素之间的联系。</li></ul><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi na"><img src="../Images/79eea936a7d47c805f7482305a814faf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jfWh2V-z0Tgr0sfNNflnpQ.png"/></div></div></figure><p id="f67a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">恭喜你！我们现在知道了如何创建一个链表、插入一个节点和删除一个节点。让我们更进一步。</p><h1 id="604d" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">反转链接列表</h1><p id="55c2" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">能够反转我们的列表是很有用的。让我们来看看如何做到这一点。</p><pre class="ln lo lp lq gt mc mb md me aw mf bi"><span id="07b3" class="mg kk in mb b gy mh mi l mj mk">func (l *LinkedList) Reverse() {<br/>    var curr, prev, next *Node<br/>    curr = l.head<br/>    prev = nil</span><span id="2897" class="mg kk in mb b gy ml mi l mj mk">    for curr != nil {<br/>        next = curr.next<br/>        curr.next = prev<br/>        prev = curr<br/>        curr = next<br/>    }<br/>    l.head = prev<br/>}</span></pre><p id="2d7e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">看图表比我用简单的语言解释步骤要快。</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi na"><img src="../Images/a901c864bf090d5343ac7c377674ebf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HyT5gotJ1EBhmhrP-b_M4Q.png"/></div></div></figure><h1 id="5f4d" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">结论</h1><p id="6a4c" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">链表是一种很容易实现的有用的数据结构。对于初学者来说，链表可能具有挑战性，因为这是指针第一次被广泛使用。我希望这个指南能帮助你理解链表是如何工作的。祝你学业有成！</p><p id="977a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你也可以在<a class="ae nb" href="https://dev.to/jpoly1219/linked-lists-in-go-3g63" rel="noopener ugc nofollow" target="_blank">发展到</a>和<a class="ae nb" href="https://jpoly1219.github.io" rel="noopener ugc nofollow" target="_blank">我的个人网站</a>上阅读这篇文章。</p></div></div>    
</body>
</html>