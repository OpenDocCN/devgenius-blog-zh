<html>
<head>
<title>An Introduction to KubeVela Addons: Extend Your Own Platform Capability</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">KubeVela 插件简介:扩展你自己的平台能力</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/an-introduction-to-kubevela-addons-extend-your-own-platform-capability-d5a32ef03d17?source=collection_archive---------17-----------------------#2022-10-31">https://blog.devgenius.io/an-introduction-to-kubevela-addons-extend-your-own-platform-capability-d5a32ef03d17?source=collection_archive---------17-----------------------#2022-10-31</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="62a5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ki">由查理·蒋(库比韦拉团队)</em></p><p id="971a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">众所周知，KubeVela 是一个高度可扩展的平台，用户可以在其上使用<a class="ae kj" href="https://kubevela.io/docs/platform-engineers/oam/x-definition" rel="noopener ugc nofollow" target="_blank">定义</a>构建自己的定制。KubeVela 插件是一种将所有这些定制及其依赖项打包在一起的便捷方式，可以扩展您自己的平台功能！</p><p id="0ae4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个博客介绍了插件的主要概念，并指导你快速开始构建一个插件。最后，我们将向您展示最终用户的体验，以及所提供的功能是如何整合到一致的用户友好体验中的。</p><h1 id="550c" class="kk kl in bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">为什么要使用<a class="ae kj" href="https://kubevela.io/blog/2022/10/18/building-addon-introduction#why-use-addons" rel="noopener ugc nofollow" target="_blank">插件</a></h1><p id="40e5" class="pw-post-body-paragraph jk jl in jm b jn li jp jq jr lj jt ju jv lk jx jy jz ll kb kc kd lm kf kg kh ig bi translated">我们通常使用带有<a class="ae kj" href="https://github.com/kubevela/catalog" rel="noopener ugc nofollow" target="_blank">插件目录</a>的插件，这是一个包含插件的注册表，包含 KubeVela 社区精心制作的各种定制。你只需点击一下就可以下载并安装这些插件。例如，通过安装<code class="fe ln lo lp lq b"><a class="ae kj" href="https://github.com/kubevela/catalog/tree/master/addons/fluxcd" rel="noopener ugc nofollow" target="_blank">fluxcd</a></code> addon，您可以将 KubeVela 应用程序中的 Helm Chart 部署到集群中。</p><p id="88b9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">与一键安装的便利性相反，如果没有 KubeVela 插件，您必须以这种方式手动安装<a class="ae kj" href="https://fluxcd.io/" rel="noopener ugc nofollow" target="_blank"> FluxCD </a>:</p><ol class=""><li id="1f8e" class="lr ls in jm b jn jo jr js jv lt jz lu kd lv kh lw lx ly lz bi translated">使用舵图或下载的 yaml 清单安装 FluxCD</li><li id="872b" class="lr ls in jm b jn ma jr mb jv mc jz md kd me kh lw lx ly lz bi translated">手动将 FluxCD CRD 与您的系统粘合，这可以通过在 KubeVela 中添加组件或特征定义来完成</li></ol><p id="2df6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">实际上，这是我们在 KubeVela v1.1 之前安装 FluxCD 的方式。虽然看起来只需要 2 个步骤，但我们发现这相当麻烦:</p><ol class=""><li id="49b5" class="lr ls in jm b jn jo jr js jv lt jz lu kd lv kh lw lx ly lz bi translated"><strong class="jm io">安装复杂:</strong>用户需要参考文档手动安装 FluxCD 并解决可能出现的错误</li><li id="970c" class="lr ls in jm b jn ma jr mb jv mc jz md kd me kh lw lx ly lz bi translated"><strong class="jm io">零散资源:</strong>用户需要从不同的地方获取不同的资源文件</li><li id="4fe0" class="lr ls in jm b jn ma jr mb jv mc jz md kd me kh lw lx ly lz bi translated"><strong class="jm io">硬分发:</strong>用户必须手动下载清单，这使得很难以统一的方式分发所有这些资源</li><li id="a2e7" class="lr ls in jm b jn ma jr mb jv mc jz md kd me kh lw lx ly lz bi translated"><strong class="jm io">缺乏多集群支持:</strong> KubeVela 非常强调多集群交付。然而，手动安装使得多集群支持难以实现。</li><li id="d3c4" class="lr ls in jm b jn ma jr mb jv mc jz md kd me kh lw lx ly lz bi translated"><strong class="jm io">无版本管理:</strong>用户需要自行管理定义、控制器、对应版本之间的关系。</li></ol><p id="57ed" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">KubeVela 插件就是为了解决这些问题而诞生的。</p><h1 id="668d" class="kk kl in bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">库伯韦拉如何工作<a class="ae kj" href="https://kubevela.io/blog/2022/10/18/building-addon-introduction#how-kubevela-addons-work" rel="noopener ugc nofollow" target="_blank"> </a></h1><p id="97fb" class="pw-post-body-paragraph jk jl in jm b jn li jp jq jr lj jt ju jv lk jx jy jz ll kb kc kd lm kf kg kh ig bi translated">KubeVela 插件主要包含两个部分:</p><ul class=""><li id="b4d3" class="lr ls in jm b jn jo jr js jv lt jz lu kd lv kh mf lx ly lz bi translated">一个是能力提供者的安装，它通常是 CRD 运营商。安装过程本质上是利用 KubeVela 应用程序来工作。</li><li id="d1b8" class="lr ls in jm b jn ma jr mb jv mc jz md kd me kh mf lx ly lz bi translated">另一个是粘合层，它是 OAM 定义和其他扩展。这些 OAM 定义通常依赖于功能提供者，并从最佳实践中提供用户友好的抽象。</li></ul><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi mg"><img src="../Images/00baab0fb18b0cbb5f6fcb778a591c32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*fXINffot7NEAiYGU.jpg"/></div></div></figure><p id="f3b3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">插件的整个工作机制如上图所示。KubeVela 应用程序具有多集群功能，有助于将附加组件的 CRD 操作符交付到这些集群中。定义文件仅由 KubeVela 控制平面使用，因此它们将仅存在于控制平面集群中。</p><p id="c54c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">提示</strong></p><p id="74e3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">安装后，将创建一个应用程序对象，所有相关资源将标记对该应用程序的 Once 引用。当我们想要卸载一个插件时，我们只需要删除该应用程序，Kubernetes 的 ownerReference 机制将帮助清理所有其他资源。</strong></p><p id="0ddf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们构建一个 Redis 插件作为例子，它使得在应用程序中使用 Redis 组件来创建 Redis 集群成为可能。这样的插件将至少包括一个 Redis 操作符(创建 Redis 集群)和一个 ComponentDefinition(定义什么是<code class="fe ln lo lp lq b">redis</code>组件)。</p><p id="87e2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">插件的安装过程包括安装应用程序(包括 Redis 操作符)、定义等。</p><h1 id="50b0" class="kk kl in bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">创建自己的插件<a class="ae kj" href="https://kubevela.io/blog/2022/10/18/building-addon-introduction#create-your-own-addon" rel="noopener ugc nofollow" target="_blank"> </a></h1><p id="76fa" class="pw-post-body-paragraph jk jl in jm b jn li jp jq jr lj jt ju jv lk jx jy jz ll kb kc kd lm kf kg kh ig bi translated"><strong class="jm io"> <em class="ki">注</em> </strong></p><p id="e4b4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> <em class="ki">确保你使用的是 KubeVela 1.5+版，拥有下面提到的所有这些功能。</em> </strong></p><p id="1107" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们将指导你完成制作 redis 插件的整个过程。本指南的完整源代码位于<a class="ae kj" href="https://github.com/kubevela/catalog/tree/master/experimental/addons/redis-operator" rel="noopener ugc nofollow" target="_blank">目录/redis-operator </a>中。</p><p id="fed9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">提示</strong></p><p id="dcc8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">作为介绍，我们不会涵盖所有功能。如果有兴趣自己搭建 addon，最好参考 <a class="ae kj" href="https://kubevela.io/docs/platform-engineers/addon/intro" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io">“自制 Addon”</strong></a><strong class="jm io">文档了解详情。</strong></p><p id="20e2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">首先，我们需要考虑我们的插件能给最终用户提供什么。假设我们的 Redis 插件可以提供一个名为<code class="fe ln lo lp lq b">redis-failover</code>的组件，当在应用程序中声明时，它将创建一个完整的 Redis 集群。</p><p id="4568" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后我们会想出如何实现这一点。为了定义一个<code class="fe ln lo lp lq b">redis-failover</code>组件，我们需要编写一个 ComponentDefinition。为了能够创建 Redis 集群，我们使用一个<a class="ae kj" href="https://github.com/spotahome/redis-operator" rel="noopener ugc nofollow" target="_blank"> Redis 操作符</a>作为功能提供者。</p><p id="427c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在我们的目标很明确:</p><ul class=""><li id="f1dc" class="lr ls in jm b jn jo jr js jv lt jz lu kd lv kh mf lx ly lz bi translated">编写一个 OAM 应用程序，其中包括 Redis 操作符的安装。(参考完整源代码中的<code class="fe ln lo lp lq b"><a class="ae kj" href="https://github.com/kubevela/catalog/blob/master/experimental/addons/redis-operator/template.cue" rel="noopener ugc nofollow" target="_blank">template.cue</a></code>和<code class="fe ln lo lp lq b"><a class="ae kj" href="https://github.com/kubevela/catalog/tree/master/experimental/addons/redis-operator/resources" rel="noopener ugc nofollow" target="_blank">resources/</a></code>。)</li><li id="1a1a" class="lr ls in jm b jn ma jr mb jv mc jz md kd me kh mf lx ly lz bi translated">写一个<a class="ae kj" href="https://kubevela.io/docs/platform-engineers/components/custom-component" rel="noopener ugc nofollow" target="_blank"> ComponentDefinition </a>，它定义了名为<code class="fe ln lo lp lq b">redis-failover</code>的组件。(参考<code class="fe ln lo lp lq b"><a class="ae kj" href="https://github.com/kubevela/catalog/tree/master/experimental/addons/redis-operator/definitions" rel="noopener ugc nofollow" target="_blank">definitions/</a></code>文件夹中的完整源代码。)</li></ul><p id="2d3e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是在我们开始编码之前，我们需要理解一个插件目录的结构。我们将在后面描述每个文件，只是对现在需要哪些文件有一个基本的了解。</p><p id="4918" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">提示</strong></p><p id="0441" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">命令</strong> <code class="fe ln lo lp lq b"><strong class="jm io">vela addon init</strong></code> <strong class="jm io">可以帮助你创建 scaffold addon 目录和文件作为初始化。</strong></p><pre class="mh mi mj mk gt ms lq mt mu aw mv bi"><span id="fbd3" class="mw kl in lq b gy mx my l mz na">redis-operator/ <br/>├── definitions <br/>│   └── redis-failover.cue <br/>├── resources              <br/>│   ├── crd.yaml       <br/>│   ├── redis-operator.cue <br/>│   └── topology.cue       # (Optional)<br/>├── metadata.yaml          <br/>├── parameter.cue         <br/>├── README.md            <br/>└── template.cue</span></pre><p id="75ac" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们逐一解释所有这些文件和文件夹:</p><ol class=""><li id="03fb" class="lr ls in jm b jn jo jr js jv lt jz lu kd lv kh lw lx ly lz bi translated"><code class="fe ln lo lp lq b">redis-operator/</code>是目录名，和 addon 名一样。</li><li id="cc94" class="lr ls in jm b jn ma jr mb jv mc jz md kd me kh lw lx ly lz bi translated"><code class="fe ln lo lp lq b">definitions/</code>文件夹存储定义，包括 TraitDefinition、ComponentDefinition 等。</li><li id="e346" class="lr ls in jm b jn ma jr mb jv mc jz md kd me kh lw lx ly lz bi translated"><code class="fe ln lo lp lq b">redis-failover.cue</code>定义组件定义了如何使用<code class="fe ln lo lp lq b">redis-failover</code>组件，以及它如何与底层资源集成。</li><li id="f2de" class="lr ls in jm b jn ma jr mb jv mc jz md kd me kh lw lx ly lz bi translated"><code class="fe ln lo lp lq b">resources/</code>文件夹包含资源文件，这些文件将在<code class="fe ln lo lp lq b">template.cue</code>中组成一个完整的应用程序。</li><li id="0533" class="lr ls in jm b jn ma jr mb jv mc jz md kd me kh lw lx ly lz bi translated"><code class="fe ln lo lp lq b">crd.yaml</code>在<code class="fe ln lo lp lq b">resources/</code>文件夹中是 Redis 操作符附带的 CRD。这个文件夹中的 Yaml 文件将直接应用到 Kubernetes。</li><li id="6de0" class="lr ls in jm b jn ma jr mb jv mc jz md kd me kh lw lx ly lz bi translated"><code class="fe ln lo lp lq b">redis-operator.cue</code>定义一个 web 服务组件，它安装 Redis 操作符。</li><li id="262c" class="lr ls in jm b jn ma jr mb jv mc jz md kd me kh lw lx ly lz bi translated"><code class="fe ln lo lp lq b">topology.cue</code>是可选的，它帮助 KubeVela 建立应用程序和底层资源之间的关系。</li><li id="f2bf" class="lr ls in jm b jn ma jr mb jv mc jz md kd me kh lw lx ly lz bi translated"><code class="fe ln lo lp lq b">metadata.yaml</code>定义该插件的元数据，包括名称、版本、标签、维护者等。这个信息可以是对任何注册表暴露的插件的概述。</li><li id="db1a" class="lr ls in jm b jn ma jr mb jv mc jz md kd me kh lw lx ly lz bi translated"><code class="fe ln lo lp lq b">parameter.cue</code>定义了这个插件的参数，最终用户可以使用它们来定制他们的插件安装。</li><li id="93b6" class="lr ls in jm b jn ma jr mb jv mc jz md kd me kh lw lx ly lz bi translated"><code class="fe ln lo lp lq b">README.md</code>引导用户快速开始使用该插件。</li><li id="d32c" class="lr ls in jm b jn ma jr mb jv mc jz md kd me kh lw lx ly lz bi translated">是插件的模板，安装后将形成整个应用程序。</li></ol><p id="3758" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在让我们一个一个地深入研究如何写它们。</p><p id="9c31" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">提示</strong></p><p id="2a21" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">我们将在以下部分广泛使用提示语言，因此</strong> <a class="ae kj" href="https://kubevela.io/docs/platform-engineers/cue/basic" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io">提示基本</strong> </a> <strong class="jm io">可能会有用。</strong></p><h1 id="6d42" class="kk kl in bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">parameter . cue<a class="ae kj" href="https://kubevela.io/blog/2022/10/18/building-addon-introduction#parametercue" rel="noopener ugc nofollow" target="_blank">T24】</a></h1><pre class="mh mi mj mk gt ms lq mt mu aw mv bi"><span id="828d" class="mw kl in lq b gy mx my l mz na">parameter: {<br/>    //+usage=Redis Operator image.<br/>    image: *"quay.io/spotahome/redis-operator:v1.1.0" | string<br/>    // ...omitted</span></pre><p id="6eb6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ln lo lp lq b">parameter.cue</code>中定义的参数是用户在安装插件时可以自定义的，就像头盔值一样。您可以稍后通过<code class="fe ln lo lp lq b">parameter.&lt;parameter-name&gt;</code>在 CUE 中访问这些参数的值。在我们的例子中，<code class="fe ln lo lp lq b">image</code>用于让用户定制 Redis 操作员图像，并且可以通过<code class="fe ln lo lp lq b">parameter.image</code>在<code class="fe ln lo lp lq b">redis-operator.cue</code>中访问。</p><p id="a85a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">除了定制一些字段，你还可以做一些有创意的事情，比如参数化安装插件。比如<code class="fe ln lo lp lq b">fluxcd</code> addon 有一个参数叫<code class="fe ln lo lp lq b"><a class="ae kj" href="https://github.com/kubevela/catalog/blob/master/addons/fluxcd/parameter.cue" rel="noopener ugc nofollow" target="_blank">onlyHelmComponents</a></code>。因为<code class="fe ln lo lp lq b">fluxcd</code>插件很大，包括 5 个不同的控制器，不是所有的用户都想要这么重的安装。因此，如果用户将<code class="fe ln lo lp lq b">onlyHelmComponents</code>参数设置为<code class="fe ln lo lp lq b">true</code>，将只安装 2 个控制器，这是一个相对较轻的安装。如果你对这是如何实现的感兴趣，你可以参考<a class="ae kj" href="https://github.com/kubevela/catalog/blob/master/addons/fluxcd/template.cue#L25" rel="noopener ugc nofollow" target="_blank"> fluxcd addon </a>了解详情。</p><p id="0335" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当您设计向用户提供什么参数时，您可以遵循我们的最佳实践，使其对用户友好。</p><p id="a3be" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">最佳实践</strong></p><ul class=""><li id="cfef" class="lr ls in jm b jn jo jr js jv lt jz lu kd lv kh mf lx ly lz bi translated"><strong class="jm io">不要给你的用户提供每一个可能的参数，让他们自己想办法拨几十个旋钮。将细粒度的旋钮抽象成一些宽泛的参数，这样用户可以输入几个参数，得到一个可用但可定制的插件。</strong></li><li id="39c0" class="lr ls in jm b jn ma jr mb jv mc jz md kd me kh mf lx ly lz bi translated">首先决定合理的违约。让用户开始使用你的插件，即使他们没有提供参数(如果可能的话)。</li><li id="bf99" class="lr ls in jm b jn ma jr mb jv mc jz md kd me kh mf lx ly lz bi translated"><strong class="jm io">提供每个参数的用法，可以像示例一样在参数上方标注注释。</strong></li><li id="4bd3" class="lr ls in jm b jn ma jr mb jv mc jz md kd me kh mf lx ly lz bi translated"><strong class="jm io">保持不同版本的参数一致，以避免升级过程中的不兼容性。</strong></li></ul><h1 id="1eeb" class="kk kl in bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated"><code class="fe ln lo lp lq b">template.cue</code>和<code class="fe ln lo lp lq b">resources/</code>文件夹<a class="ae kj" href="https://kubevela.io/blog/2022/10/18/building-addon-introduction#templatecue-and-resources-folder" rel="noopener ugc nofollow" target="_blank">和</a></h1><p id="f618" class="pw-post-body-paragraph jk jl in jm b jn li jp jq jr lj jt ju jv lk jx jy jz ll kb kc kd lm kf kg kh ig bi translated">OAM 应用程序存储在这里，它包含了插件的实际安装过程。在我们的例子中，我们将创建一个包含 Redis 操作符的应用程序，让我们的集群能够创建 Redis 集群。</p><p id="ceb7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ln lo lp lq b">template.cue</code>和<code class="fe ln lo lp lq b">resources/</code>目录都服务于相同的目的——定义一个应用程序。抛开历史原因，我们之所以一分为二，是为了可读性。当我们在 template.cue 中拥有大量资源时，它最终会变得太长而无法阅读。因此，我们通常将应用程序支架放在<code class="fe ln lo lp lq b">template.cue</code>目录中，将应用程序组件放在<code class="fe ln lo lp lq b">resources</code>目录中。</p><h2 id="1979" class="mw kl in bd km nb nc dn kq nd ne dp ku jv nf ng ky jz nh ni lc kd nj nk lg nl bi translated">template . cue<a class="ae kj" href="https://kubevela.io/blog/2022/10/18/building-addon-introduction#templatecue" rel="noopener ugc nofollow" target="_blank">T12】</a></h2><p id="f3df" class="pw-post-body-paragraph jk jl in jm b jn li jp jq jr lj jt ju jv lk jx jy jz ll kb kc kd lm kf kg kh ig bi translated"><code class="fe ln lo lp lq b">template.cue</code>定义一个应用程序的框架。这里的大部分内容可以是样板文件，它们被解释为代码块中的注释。</p><pre class="mh mi mj mk gt ms lq mt mu aw mv bi"><span id="0ff8" class="mw kl in lq b gy mx my l mz na">// package name should be the same as the CUE files in resources directory,<br/>// so that we can refer to the files in resources/.<br/><em class="ki">package</em> main<br/><br/>output: {<br/>    // This is just a plain OAM Application<br/>    apiVersion: "core.oam.dev/v1beta1"<br/>    kind:       "Application"<br/>    // No metadata required<br/>    spec: {<br/>        components: [<br/>            // Create a component that includes a Redis Operator<br/>            redisOperator // defined in resources/redis-operator.cue<br/>        ]<br/>        policies: [<br/>        // What namespace to install, whether install to sub-clusters<br/>        // Again, these are boilerplates. No need to remember them. Just refer to the full source code.<br/>        // https://github.com/kubevela/catalog/blob/master/experimental/addons/redis-operator/template.cue<br/>        // Documentation: https://kubevela.io/docs/end-user/policies/references<br/>        ]<br/>    }<br/>}<br/>// Resource topology, which can help KubeVela glue resources together.<br/>// We will discuss this in detail later.<br/>// Documentation: https://kubevela.io/docs/reference/topology-rule<br/>outputs: topology: resourceTopology // defined in resources/topology.cue</span></pre><p id="1d19" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ln lo lp lq b">output</code>字段是该模板的关键字，它包含将要部署的应用程序。在应用程序中，<code class="fe ln lo lp lq b">spec.components</code>字段将引用在<code class="fe ln lo lp lq b">resources/</code>文件夹中定义的对象。</p><p id="9255" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ln lo lp lq b">outputs</code>字段是另一个关键字，可以用来定义任何你想和这个插件一起部署的辅助资源。这些资源必须遵循 Kubernetes API。</p><h2 id="7a84" class="mw kl in bd km nb nc dn kq nd ne dp ku jv nf ng ky jz nh ni lc kd nj nk lg nl bi translated"><code class="fe ln lo lp lq b">resources/</code>文件夹<a class="ae kj" href="https://kubevela.io/blog/2022/10/18/building-addon-introduction#resources-folder" rel="noopener ugc nofollow" target="_blank">文件夹</a></h2><p id="67d2" class="pw-post-body-paragraph jk jl in jm b jn li jp jq jr lj jt ju jv lk jx jy jz ll kb kc kd lm kf kg kh ig bi translated">这里我们定义了将在<code class="fe ln lo lp lq b">template.cue</code>中引用的应用组件。我们将使用一个<code class="fe ln lo lp lq b">webservice</code>组件来安装 Redis 操作符。当然，如果你对额外的依赖(FluxCD addon)感到舒服，你可以使用<code class="fe ln lo lp lq b">helm</code>组件直接安装 Redis 操作员舵图。但是写 addon 的一个原则就是减少外部依赖，所以我们用的是<code class="fe ln lo lp lq b">webservice</code>组件，是 KubeVela 的内置组件，而不是<code class="fe ln lo lp lq b">helm</code>。</p><pre class="mh mi mj mk gt ms lq mt mu aw mv bi"><span id="c3ae" class="mw kl in lq b gy mx my l mz na">// resources/redis-operator.cue<br/><br/>// package name is the same as the one in template.cue. So we can use `redisOperator` below in template.cue<br/><em class="ki">package</em> main<br/><br/>redisOperator: {<br/>    // an OAM Application Component, which will create a Redis Operator<br/>    // https://kubevela.io/docs/end-user/components/references<br/>    name: "redis-operator"<br/>    type: "webservice"<br/>    properties: {<br/>        // Redis Operator container image (parameter.image is defined in parameter.cue)<br/>        image:           parameter.image<br/>        imagePullPolicy: "IfNotPresent"<br/>    }<br/>    traits: [<br/>        // ...omitted<br/>    ]<br/>}</span></pre><p id="8fe9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您可以参考代码块中的注释来了解每个字段的详细用法。</p><h2 id="4533" class="mw kl in bd km nb nc dn kq nd ne dp ku jv nf ng ky jz nh ni lc kd nj nk lg nl bi translated">KubeVela <a class="ae kj" href="https://kubevela.io/blog/2022/10/18/building-addon-introduction#highlights-of-the-glue-capability-provided-by-kubevela" rel="noopener ugc nofollow" target="_blank"> </a>提供的胶水功能亮点</h2><p id="79e8" class="pw-post-body-paragraph jk jl in jm b jn li jp jq jr lj jt ju jv lk jx jy jz ll kb kc kd lm kf kg kh ig bi translated">其中一个显著的特点就是<a class="ae kj" href="https://kubevela.io/docs/reference/topology-rule" rel="noopener ugc nofollow" target="_blank"> <em class="ki">拓扑规则</em> </a>(或者资源拓扑，资源关系)。虽然不是必需的，但它可以帮助 KubeVela 构建由 KubeVela 应用程序管理的资源的拓扑关系。这就是 KubeVela 如何将各种资源粘合到一个应用程序中。当我们使用 Kubernetes 定制资源(CR)时，这尤其有用(在这个例子中正是这种情况)。</p><pre class="mh mi mj mk gt ms lq mt mu aw mv bi"><span id="126c" class="mw kl in lq b gy mx my l mz na">// resources/topology.cue<br/><br/><em class="ki">package</em> main<br/><br/><em class="ki">import</em> "encoding/json"<br/><br/>resourceTopology: {<br/>    apiVersion: "v1"<br/>    kind:       "ConfigMap"<br/>    metadata: {<br/>        name:      "redis-operator-topology"<br/>        namespace: "vela-system"<br/>        labels: {<br/>            "rules.oam.dev/resources":       "true"<br/>            "rules.oam.dev/resource-format": "json"<br/>        }<br/>    }<br/>    data: rules: json.Marshal([{<br/>        parentResourceType: {<br/>            group: "databases.spotahome.com"<br/>            kind:  "RedisFailover"<br/>        }<br/>        // RedisFailover CR manages the three resource below<br/>        childrenResourceType: [<br/>            {<br/>                apiVersion: "apps/v1"<br/>                kind:  "StatefulSet"<br/>            },<br/>            // Topologies of Deployment and etc. are built-in.<br/>            // So we don't need to go deeper to Pods.<br/>            {<br/>                apiVersion: "apps/v1"<br/>                kind:  "Deployment"<br/>            },<br/>            {<br/>                apiVersion: "v1"<br/>                kind:  "Service"<br/>            },<br/>        ]<br/>    }])<br/>}</span></pre><p id="c688" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在我们的例子中，<code class="fe ln lo lp lq b">redis-failover</code>组件将创建一个名为<code class="fe ln lo lp lq b">RedisFailover</code>的 CR。如果我们没有<em class="ki">拓扑规则</em>，尽管我们知道<code class="fe ln lo lp lq b">RedisFailover</code>正在管理几个部署和服务，但 KubeVela 不会神奇地知道这一点。所以我们可以<em class="ki">用<em class="ki">拓扑规则</em>告诉</em> KubeVela 我们的理解。一旦 KubeVela 知道了一个<code class="fe ln lo lp lq b">RedisFailover</code>里面有什么，它就会知道应用程序内部所有资源的关系。</p><p id="c218" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">提示</strong></p><p id="11ef" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">这可以带来巨大的好处，并为我们提供所有扩展资源的一致体验:</strong></p><ul class=""><li id="5571" class="lr ls in jm b jn jo jr js jv lt jz lu kd lv kh mf lx ly lz bi translated"><strong class="jm io">在 VelaUX </strong>中可以提供从应用到底层 pod 的资源拓扑图</li><li id="d993" class="lr ls in jm b jn ma jr mb jv mc jz md kd me kh mf lx ly lz bi translated"><strong class="jm io">对各种应用组件使用</strong> <code class="fe ln lo lp lq b"><strong class="jm io">vela exec</strong></code>一致执行命令成舱</li><li id="bba5" class="lr ls in jm b jn ma jr mb jv mc jz md kd me kh mf lx ly lz bi translated"><strong class="jm io">使用</strong>T5 为各种应用组件提供一致的转发端口</li><li id="33e2" class="lr ls in jm b jn ma jr mb jv mc jz md kd me kh mf lx ly lz bi translated"><strong class="jm io">一致使用</strong> <code class="fe ln lo lp lq b"><strong class="jm io">vela log</strong></code>从 pods 获取各种应用组件的日志</li><li id="e3b4" class="lr ls in jm b jn ma jr mb jv mc jz md kd me kh mf lx ly lz bi translated"><strong class="jm io">一致使用</strong> <code class="fe ln lo lp lq b"><strong class="jm io">vela status --pod/--endpoint</strong></code>为各种应用组件获取 pod 或访问端点</li></ul><p id="56f5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">可以参考<a class="ae kj" href="https://kubevela.io/blog/2022/10/18/building-addon-introduction#run-our-addon" rel="noopener ugc nofollow" target="_blank">运行我们的插件</a>看看真实的用户体验。</p><h1 id="7c6f" class="kk kl in bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated"><code class="fe ln lo lp lq b">definitions/</code>文件夹<a class="ae kj" href="https://kubevela.io/blog/2022/10/18/building-addon-introduction#definitions-folder" rel="noopener ugc nofollow" target="_blank">文件夹</a></h1><p id="a8a3" class="pw-post-body-paragraph jk jl in jm b jn li jp jq jr lj jt ju jv lk jx jy jz ll kb kc kd lm kf kg kh ig bi translated">Definitions 文件夹包含 KubeVela <a class="ae kj" href="https://kubevela.io/docs/getting-started/definition" rel="noopener ugc nofollow" target="_blank">定义</a>，包括 ComponentDefinitions、TraitDefinitions 等。这是插件最重要的部分，因为它为最终用户提供了真正的能力。使用这里定义的组件和特征类型，用户可以在他们的应用程序中使用它们。</p><p id="154a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">编写插件的定义和编写常规的 OAM 定义是一样的，这是一个很大的主题，所以我们不会深入介绍插件，你可以参考下面的文档来学习如何编写各种定义。</p><ul class=""><li id="18a6" class="lr ls in jm b jn jo jr js jv lt jz lu kd lv kh mf lx ly lz bi translated"><a class="ae kj" href="https://kubevela.io/docs/platform-engineers/components/custom-component" rel="noopener ugc nofollow" target="_blank">组件定义</a></li><li id="4f79" class="lr ls in jm b jn ma jr mb jv mc jz md kd me kh mf lx ly lz bi translated"><a class="ae kj" href="https://kubevela.io/docs/platform-engineers/traits/customize-trait" rel="noopener ugc nofollow" target="_blank">特质定义</a></li><li id="06a7" class="lr ls in jm b jn ma jr mb jv mc jz md kd me kh mf lx ly lz bi translated"><a class="ae kj" href="https://kubevela.io/docs/platform-engineers/policy/custom-policy" rel="noopener ugc nofollow" target="_blank">政策定义</a></li><li id="387c" class="lr ls in jm b jn ma jr mb jv mc jz md kd me kh mf lx ly lz bi translated"><a class="ae kj" href="https://kubevela.io/docs/platform-engineers/workflow/workflow" rel="noopener ugc nofollow" target="_blank">工作流程步骤定义</a>。</li></ul><p id="ea9c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在我们的 redis 插件示例中，我们应该参考<a class="ae kj" href="https://kubevela.io/docs/platform-engineers/components/custom-component" rel="noopener ugc nofollow" target="_blank">组件定义</a>和<a class="ae kj" href="https://github.com/spotahome/redis-operator/blob/master/README.md" rel="noopener ugc nofollow" target="_blank"> Redis 运算符</a>来编写我们的组件定义。我们将此组件类型命名为<code class="fe ln lo lp lq b">redis-failover</code>。它将创建一个名为 RedisFailover 的 CR。随着 RedisFailover 的创建，我们插件应用程序中的 Redis 操作符将为我们创建一个 Redis 集群。</p><p id="b0e9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这里可以参考源代码<a class="ae kj" href="https://github.com/kubevela/catalog/blob/master/experimental/addons/redis-operator/definitions/redis-failover.cue" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="c30e" class="kk kl in bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">元数据. yaml <a class="ae kj" href="https://kubevela.io/blog/2022/10/18/building-addon-introduction#metadatayaml" rel="noopener ugc nofollow" target="_blank"> </a></h1><p id="0f72" class="pw-post-body-paragraph jk jl in jm b jn li jp jq jr lj jt ju jv lk jx jy jz ll kb kc kd lm kf kg kh ig bi translated">顾名思义，这些都是一个插件的元数据，包括插件的名称、版本、系统要求等。详见本<a class="ae kj" href="https://kubevela.io/docs/platform-engineers/addon/intro#basic-information-file" rel="noopener ugc nofollow" target="_blank">文件</a>。下面列出的示例包含所有可用字段。</p><p id="5ed5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> TIP </strong></p><p id="8b2a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">有一些遗留支持，而我们关注的是 kubella v 1.5+中引入的新插件格式。例如，旧的</strong> <code class="fe ln lo lp lq b"><strong class="jm io">deployTo.runtimeCluster</strong></code> <strong class="jm io">应弃用而用</strong> <code class="fe ln lo lp lq b"><strong class="jm io">topology policy define in application</strong></code>作其替代。你可以参考 <code class="fe ln lo lp lq b"><a class="ae kj" href="https://github.com/kubevela/catalog/blob/master/experimental/addons/redis-operator/template.cue#L28" rel="noopener ugc nofollow" target="_blank"><strong class="jm io">template.cue</strong></a></code> <strong class="jm io">中的完整源代码。</strong></p><pre class="mh mi mj mk gt ms lq mt mu aw mv bi"><span id="7153" class="mw kl in lq b gy mx my l mz na"># addon name, the same as our directory name<br/>name: redis-operator<br/># addon description<br/>description: Redis Operator creates/configures/manages high availability redis with sentinel automatic failover atop Kubernetes.<br/># tags to show in VelaUX<br/>tags:<br/>  - redis<br/># addon version<br/>version: 0.0.1<br/># addon icon<br/>icon: https://xxx.com<br/># the webpage of this addon<br/>url: https://github.com/spotahome/redis-operator<br/># other addon dependencies, e.g. fluxcd<br/>dependencies: []<br/><br/># system version requirements<br/>system:<br/>  vela: "&gt;=v1.5.0"<br/>  kubernetes: "&gt;=1.19"</span></pre><h1 id="1bcd" class="kk kl in bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">运行我们的插件<a class="ae kj" href="https://kubevela.io/blog/2022/10/18/building-addon-introduction#run-our-addon" rel="noopener ugc nofollow" target="_blank"> </a></h1><p id="f552" class="pw-post-body-paragraph jk jl in jm b jn li jp jq jr lj jt ju jv lk jx jy jz ll kb kc kd lm kf kg kh ig bi translated">现在我们已经完成了大部分工作。是时候运行它了！如果有任何细节被跳过，您可以下载完整的<a class="ae kj" href="https://github.com/kubevela/catalog/tree/master/experimental/addons/redis-operator" rel="noopener ugc nofollow" target="_blank">源代码</a>来完成它们。</p><p id="40a9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在我们完成所有的<code class="fe ln lo lp lq b">redis-operator</code>插件后，我们可以使用命令<code class="fe ln lo lp lq b">vela addon enable redis-operator/</code>在本地启用它。它可以帮助我们调试和编写关于最终用户体验的文档。</p><p id="c1ca" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">至于说我们的例子 addon，你可以参考<a class="ae kj" href="https://github.com/kubevela/catalog/tree/master/experimental/addons/redis-operator/README.md" rel="noopener ugc nofollow" target="_blank">自述</a>来了解应该如何介绍。</p><p id="fe1d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> <em class="ki">注意事项</em> </strong></p><p id="413e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">README.md 非常重要，因为它指导用户开始使用一个不熟悉的插件。 </p><p id="11ae" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用这个插件，用户只需要写 4 行 yaml 就可以得到一个 3 节点的 Redis 集群！与手动安装 Redis Operator 相反，即使是手动管理 Redis 实例，使用一个插件也大大改善了用户体验。</p><pre class="mh mi mj mk gt ms lq mt mu aw mv bi"><span id="0390" class="mw kl in lq b gy mx my l mz na">apiVersion: core.oam.dev/v1beta1<br/>kind: Application<br/>metadata:<br/>  name: redis-operator-sample<br/>spec:<br/>  components:<br/>    # This component is provided by redis-operator addon.<br/>    # In this example, 2 redis instance and 2 sentinel instance<br/>    # will be created.<br/>    - type: redis-failover<br/>      name: ha-redis<br/>      properties:<br/>        # You can increase/decrease this later to add/remove instances.<br/>        replicas: 3</span></pre><p id="88fb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">只用几行 yaml 就创建了一整棵树的复杂资源，如下图所示。由于我们已经为插件编写了<em class="ki">拓扑规则</em>，用户可以很容易地看到 Redis 集群的所有资源(Pods、服务)的拓扑。他们现在不局限于 KubeVela 应用程序的可观察性级别，相反，他们可以浏览底层资源的状态。例如，在我们的图中，我们可以看到某些 Redis Pods 仍未就绪:</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi mg"><img src="../Images/d65a3d2f92bafd298b6a23ce335d2c0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Zjnj7sUovth-DNEm.png"/></div></div></figure><p id="b2b5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在执行<code class="fe ln lo lp lq b">vela exec/log/port-forward</code>时，用户还可以选择我们的示例应用程序的底层资源，即 3 个 Redis Pods 和 3 个 Sentinal Pods。</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi mg"><img src="../Images/5f3f54bc55d9d5fafdf22a5a02fff60d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*-xms4gTiqmVE0cg3.png"/></div></div></figure><p id="268e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">提示</strong></p><p id="93b1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">乍一看，如果您正在运行单个集群，那么将</strong> <code class="fe ln lo lp lq b"><strong class="jm io">exec</strong></code> <strong class="jm io">放入一个 Pod 似乎并不有用。但是，如果您正在运行多集群安装，选择跨多个集群的资源可以节省大量时间。</strong></p><p id="1d55" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ln lo lp lq b">vela status</code>可以获得一个应用程序的状态。有了<code class="fe ln lo lp lq b">Topology Rules</code>，我们可以更进一步——直接找出应用程序中的端点。在我们的示例中，用户可以通过以下方式连接到 Redis Sentinel 的端点:</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi mg"><img src="../Images/d8d0a9f47b5fec17d5119425a4c4d54d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*FT2qBThtUJHl7p1G.png"/></div></div></figure><h1 id="4e38" class="kk kl in bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated"><a class="ae kj" href="https://kubevela.io/blog/2022/10/18/building-addon-introduction#wrap-up" rel="noopener ugc nofollow" target="_blank">总结</a></h1><p id="c69b" class="pw-post-body-paragraph jk jl in jm b jn li jp jq jr lj jt ju jv lk jx jy jz ll kb kc kd lm kf kg kh ig bi translated">在本指南结束时，你可能已经很好地掌握了插件的功能和制作方法。总之，您将获得以下好处:</p><ol class=""><li id="33bf" class="lr ls in jm b jn jo jr js jv lt jz lu kd lv kh lw lx ly lz bi translated">将平台功能扩展成一个捆绑包，易于使用并与整个社区共享。</li><li id="4f0e" class="lr ls in jm b jn ma jr mb jv mc jz md kd me kh lw lx ly lz bi translated">通过 KubeVela 应用程序和 CUE，以灵活的方式将所有基础架构资源编排和模板化到多集群中。</li><li id="ca97" class="lr ls in jm b jn ma jr mb jv mc jz md kd me kh lw lx ly lz bi translated">通过各种扩展功能为最终用户提供一致的体验。</li></ol><p id="92dd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最后，如果你已经成功地建立了自己的插件，我们非常欢迎你把它加入到插件目录中。因此，KubeVela 社区中的每个人都可以发现并受益于扩展您强大的平台功能！</p></div></div>    
</body>
</html>