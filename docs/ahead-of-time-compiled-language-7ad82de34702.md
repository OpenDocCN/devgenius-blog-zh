# 超前的编译语言

> 原文：<https://blog.devgenius.io/ahead-of-time-compiled-language-7ad82de34702?source=collection_archive---------10----------------------->

Rust 是一种提前编译的语言，这意味着你可以编译一个程序并把可执行文件给其他人，他们甚至可以在没有安装 Rust 的情况下运行它。如果你给某人一个*。rb* ，*。py* ，或*。js* 文件，他们需要分别安装 Ruby、Python 或 JavaScript 实现。

重要**

评论里的知识比整篇文章都多

评论

1.  刚听说过“超前编译”语言这个术语。但这就是二进制文件和可执行文件的作用。但是它们是为非常特定的目标机器构建的，例如，如果我在 x86 机器- Windows 机器上编译二进制文件，它将在另一台相同的机器上运行良好。但是同样的二进制文件不能在 arm64-Linux 机器上运行。
2.  如果我用 Linux 目标编译它并把它给 Windows 用户，那么这个人需要安装运行时 Linux。发行版是相关的，因为它将动态链接到特定版本的 glibc
3.  除非你的目标是 musl。那么无论 glibc 版本如何，您都可以在任何 Linux 目标上运行。货物交叉是伟大的。
4.  然后发行不再是一个问题，但 Windows/Linux/Mac 仍然存在。
5.  你好，MUSL 爱好者👋
6.  通常是这样，但不总是/完全正确。如果你编译🦀信任一个目标，然后你会得到一个字节码文件，它不能在任何平台上执行，但是需要一个合适的 WASM 运行时，比如 Wasmtime，Wasmi，Wasmer，WAMR，WaVM，WasmVM，或者十几个中的一个，或者内置在现代网络浏览器中的一个。
7.  用 Rust 瞄准 WASM 基本上遵循了与 [#Java](https://www.linkedin.com/feed/hashtag/?keywords=java) 相同的原则:创建将由运行时 VM 执行的字节码工件。根据所选择的运行时，执行可以是解释的(最常见的)，实时编译的(JITC)，或者两者的混合。缺省情况下，Java 运行时通常主要使用 JITC，现在解释只是在边缘情况下的一种备用方法。
8.  WASM 和 JVM(或 C#)字节码之间的主要区别是，WASM 规范和环境至少要简单一个数量级。因为 I 不像 JVM、CLR 和大多数脚本语言那样，在标准库中有成千上万的类和方法。这就是为什么它更容易实现，因此它已经有过多的运行时。
9.  诚然，如果以原生 CPU 为目标，如 x86–32/64、arm 7–8、RISC-V 等，Rust 是一种纯粹超前的编译语言。但是铁锈能做的不止这些。
10.  显然，你不能给某人一个. rb 文件，然后期望它被运行。这就像给某人一个. rs 文件。文件与。rb 和。rs 扩展是用高级语言编写，旨在使人可读，而不是由机器执行。
11.  提前编译只是意味着代码在执行前被编译(编译成某种东西，可能是 C)，但并不意味着编译的结果是本机代码。
12.  首先生成 java 字节码，然后在 JVM 中执行它的 java 编译器是超前编译器。即使 Java 字节码需要运行 JVM。
13.  与提前相反的是及时编译。代码在执行的同时被编译(就像 python 一样)。
14.  这些概念可能很复杂，有时甚至没有明确的界限来区分它们😂。当我研究这个概念时，我记得我认为将源代码翻译成 AST 可以被认为是一种编译形式。因此，每一个不直接执行源代码的编译器在某种意义上都是超前编译器。
15.  说 rust 是一种“超前”的编译语言有点多余和误导。
16.  基本上有编译和解释或“即时”(正如你所想的)语言，还有一些处理编译的字节码，但仍然需要解释。在我看来，没有真正的“实时”语言，只有“实时”编译器，例如 LuaJIT，它采用传统的编译语言，例如 Lua，并有效地解释它。
17.  “超前”编译意味着它不同于常规编译，但实际上并不是。这是多余的和误导性的，因为你是在与一个特定的术语“实时编译”相区别，这个术语已经被设计来与它的基础和互斥的对应术语“编译”相区别
18.  同样值得注意的是，二进制文件只能运行在为其构建的发行版和架构中。基于 arm 的 raspberry pi 不会运行针对我的 x86_64 桌面构建的 rust 二进制文件。