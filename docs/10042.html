<html>
<head>
<title>Sessionized Incrementals — Managing Partitioned Data Accretions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">会话化增量—管理分区数据增量</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/sessionized-incrementals-managing-partitioned-data-accretion-77378c329df1?source=collection_archive---------8-----------------------#2022-10-02">https://blog.devgenius.io/sessionized-incrementals-managing-partitioned-data-accretion-77378c329df1?source=collection_archive---------8-----------------------#2022-10-02</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jm jn jo jp gh gi paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="gh gi jl"><img src="../Images/a512ed9dc78e94ce45e3dcd369fcac12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_k3zCepMK8_dYppwTFIhQg.png"/></div></div></figure><p id="4226" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated"><strong class="jy io">简介</strong>:</p><p id="e165" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">在各种数据分析中，将原始事件对象转换为经过处理的计算会话具有核心意义。当处理代表跨多个用户项目收集的数据的一组事件时，通常第一件事是将数据分组到单独的会话中。根据标记每个会话的唯一值，分组过程需要在分段中执行计算。</p><p id="0371" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">当需要重复计算(对于报告、仪表板等)时，挑战就出现了。).然后，对从时间开始收集的所有数据从头开始重复该过程是繁重且昂贵的。因此，为了避免这个冗余过程，使用了增量持久派生表。</p><p id="89cc" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">在这篇短文中，我将大致介绍会话化增量的核心方法，并重点介绍我们开发的概念框架，以便实现高效可靠的增量方法。对 Looker 和 bigQuery 实现的技术方面及其引发的相应挑战的深入研究，将在接下来的论文中进行演示，该论文基于我和 Eli Libman 在 Hyro ( <a class="ae ku" href="https://www.hyro.ai/" rel="noopener ugc nofollow" target="_blank">自适应对话式人工智能平台</a>)所做的工作。</p><p id="73f7" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated"><strong class="jy io">增量 PDT</strong></p><p id="85ce" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">持久派生表(PDT)代表在给定触发间隔内更新的物化视图。表更新过程可以是从头开始，删除并创建整个表，也可以是基于时间启发式(增量 PDT)限制到最后记录的压缩更新。应该注意的是，PDT 术语是一个 Looker 本地命名，但在这篇文章中，将从如上所述的更广泛的角度来看待它。</p><p id="fe15" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">查询将在构建的压缩会话表(<em class="kv">目标表</em>)上运行，以预先包含相关的计算结果，而不是对表数据的每次使用运行全表扫描查询，执行所有原始的分组转换。</p><p id="a5c5" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">在增量 PDT 中，目的表的一个重要特性是它的更新方案:它不是从头开始构建所有的行，而是在特定的时间范围内从原始表(<em class="kv">源表</em>)添加相关的内容。该机制将在根据用例需求定义的时间间隔内触发。</p><figure class="kx ky kz la gt jp gh gi paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="gh gi kw"><img src="../Images/084649b05c1e893fc3917273c044f7db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J4qyEK4zDsRrV1kHbis8Vw.png"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">用黄色标记的是增加的记录</figcaption></figure><p id="6633" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated"><strong class="jy io">增量过程</strong></p><p id="fa2a" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">为防止重复，增量过程将包括以下步骤:</p><ol class=""><li id="c68c" class="lf lg in jy b jz ka kd ke kh lh kl li kp lj kt lk ll lm ln bi translated">删除目标表中某个时间(<code class="fe lo lp lq lr b">start_time</code>)帧的所有行</li><li id="dcb3" class="lf lg in jy b jz ls kd lt kh lu kl lv kp lw kt lk ll lm ln bi translated">从用于删除(1)中的行的同一时间段查询源表</li><li id="2098" class="lf lg in jy b jz ls kd lt kh lu kl lv kp lw kt lk ll lm ln bi translated">将(2)中计算出的查询数据添加到目标表中</li></ol><p id="103e" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated"><strong class="jy io">问题</strong></p><p id="cb73" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">虽然看起来我们正在删除正在添加的相同数据块，但仔细观察增量边界时会发现一个差异。</p><p id="f015" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">在目标表中，我们根据一个聚合时间维度来擦除行，该维度是为一个会话中的多个事件选择的。相反，断言到目的表的数据由每个事件的时间维度查询。</p><p id="f9fb" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">例如，将时间维度确定为会话的第一个事件的时间会打开一个窗口，其中可能会生成潜在的重复。</p><p id="b72e" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">当擦除在特定时间之后开始的所有会话时，比如说<code class="fe lo lp lq lr b">00:00</code>，并且添加基于在<code class="fe lo lp lq lr b">00:00</code>之后创建的事件的会话时，可能会发生重复。对于有两个事件的会话，第一个事件在<code class="fe lo lp lq lr b">23:55</code>创建，第二个事件在<code class="fe lo lp lq lr b">00:05</code>创建，该会话不会从目标表中删除(因为其开始时间是<code class="fe lo lp lq lr b">23:55</code>)，但第二个事件将作为新会话单独添加，从而创建一个重复记录。</p><p id="f783" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">另一方面，选择会话的结束时间会导致潜在的事件丢失。回到示例情况，现在，会话将从目的表中删除(因为它的结束时间是<code class="fe lo lp lq lr b">00:05</code>)，而只有第二个事件将包含在断言中。</p><p id="c1ef" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">因此，为会话选择的任何聚合时间维度，无论是开始、结束还是始终的任何时间，都将在具有来自增量屏障两侧的事件的会话的分组转换中赋予差异。</p><p id="c5c2" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">这适用于回溯 X 偏移(回溯 X 天)，因为删除维度和断言维度之间的差异将导致“尾部”调用这些间隙。</p><p id="c8d1" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated"><strong class="jy io">解决方案</strong></p><p id="3c20" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">基本概念是将两个表对齐以进行“通信”:从目标表中删除，并将来自源表的查询投射到同一个键上。此外，事件应该具有每个会话统一的新时间维度(例如<code class="fe lo lp lq lr b">MAX(created_at)</code>)，以便将它们集中在单个时间点。基于此，会话的所有事件将位于增量障碍的一侧。</p><p id="1ab6" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">从鸟瞰图来看，该过程将包括创建中间增量持久派生表(<em class="kv">中间表</em>)。该表将是原始源表的一对一副本，但将包含会话中最后一个事件的时间列(<code class="fe lo lp lq lr b">last_event_time_of_session</code>)。</p><p id="e4f6" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">先决条件是同一会话中事件之间的间隔不长于一个确定的常数(<code class="fe lo lp lq lr b">events_max_gap_minutes</code>)。该常量不能超过增量窗口，在本例中为 24 小时。这个需求是中间表的基础，所以它不允许相同的会话事件有两个不同的<code class="fe lo lp lq lr b">last_event_time_of_session</code>。</p><p id="1345" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">当从会话中的最后一个事件开始还没有经过所定义的恒定时间(<code class="fe lo lp lq lr b">events_max_gap_minutes</code>)时，关于会话是否已经结束存在不确定性。在这种情况下，对于该会话中的所有事件，<code class="fe lo lp lq lr b">last_event_time_of_session</code>将被视为<code class="fe lo lp lq lr b">null</code>。因此，这种标记将阻止潜在的正在进行的会话限定查询条件并进入目标表。</p><p id="8ee0" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">该维度将表述为:</p><pre class="kx ky kz la gt lx lr ly lz aw ma bi"><span id="938f" class="mb mc in lr b gy md me l mf mg">CASE</span><span id="acb4" class="mb mc in lr b gy mh me l mf mg">WHEN TIMESTAMP_ADD(MAX(created_at) OVER (PARTITION BY session_id), INTERVAL last_event_time_of_session MINUTE) &lt; CURRENT_TIMESTAMP() THEN MAX(created_at) OVER (PARTITION BY session_id)</span><span id="3e71" class="mb mc in lr b gy mh me l mf mg">END</span><span id="0ba9" class="mb mc in lr b gy mh me l mf mg">AS last_event_time_of_session</span></pre><p id="e3ba" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">与事件之间的间隔长度相反，会话的绝对长度不受限制。这是因为能够设置增量周期应该返回的偏移量。</p><figure class="kx ky kz la gt jp gh gi paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="gh gi mi"><img src="../Images/082b786dd8652e74e0cb0642a3f94f34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7msJpjreozW1k_8zdmos6Q.png"/></div></div></figure><p id="3eb0" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">中间表包含一个列<code class="fe lo lp lq lr b">last_event_time_of_session</code>，它表示每个事件会话的最后时间。现在，断言查询将投射到中间表中的<code class="fe lo lp lq lr b">last_event_time_of_session</code>上。这样，从目标表中删除的每个会话的事件都将包含在恢复的记录中。</p><p id="433b" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">回到上面的例子，<code class="fe lo lp lq lr b">23:55</code>事件和<code class="fe lo lp lq lr b">00:05</code>事件将具有相同的<code class="fe lo lp lq lr b">last_event_time_of_session</code>值- <code class="fe lo lp lq lr b">00:05</code>。因此，确保将为目的表中的单个更新的会话对象查询和计算这两个对象。</p><p id="9315" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">新流程如下:</p><ol class=""><li id="3666" class="lf lg in jy b jz ka kd ke kh lh kl li kp lj kt lk ll lm ln bi translated">基于事件时间删除中间表中的行(<code class="fe lo lp lq lr b">created_at</code></li><li id="e42e" class="lf lg in jy b jz ls kd lt kh lu kl lv kp lw kt lk ll lm ln bi translated">从(1)中用于删除行的相同时间范围查询源表，并将结果插入中间表。在这个阶段，在查询中计算分区的<code class="fe lo lp lq lr b">last_event_time_of_session</code>列。如上所述，潜在的正在进行的会话将把<code class="fe lo lp lq lr b">last_event_time_of_session</code>作为<code class="fe lo lp lq lr b">null</code>。</li><li id="346b" class="lf lg in jy b jz ls kd lt kh lu kl lv kp lw kt lk ll lm ln bi translated">删除目标表中特定时间(<code class="fe lo lp lq lr b">start_time</code>)的所有行</li><li id="dc5c" class="lf lg in jy b jz ls kd lt kh lu kl lv kp lw kt lk ll lm ln bi translated">从(3)中用于删除行的相同时间范围查询中间表，并将结果插入到目标表中。潜在的正在进行的会话将从查询中排除，因为它们的<code class="fe lo lp lq lr b">last_event_time_of_session</code>是<code class="fe lo lp lq lr b">null</code>。</li></ol><p id="48ee" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated"><strong class="jy io">后记</strong></p><p id="8d23" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">创建一个可以与源表和目的表“通信”的表是这个解决方案的秘密所在，这是通过将分散的事件转换为单个时间点来实现的。这个过程能够跨越严格的时间限制将事件收集到会话中。</p><p id="8bcf" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">这些原则和其他原则是 Looker 和 bigQuery 技术实现的核心，这是未来出版物的主题。尽管在当前模型中需要进行调整，但关键的基本要素仍将作为解决方案的主角，并对理解其指导方针和目标至关重要。</p></div></div>    
</body>
</html>