<html>
<head>
<title>Leetcode Contest 296</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Leetcode 竞赛 296</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/leetcode-contest-296-c48a8c476b7d?source=collection_archive---------8-----------------------#2022-06-05">https://blog.devgenius.io/leetcode-contest-296-c48a8c476b7d?source=collection_archive---------8-----------------------#2022-06-05</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/aba3d10f65ecda73fb60cb0fb0b293c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qOtTFUPIRHImlEmyY00oDg.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">穆罕默德·拉赫马尼在<a class="ae jz" href="https://unsplash.com/s/photos/coding-competition?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="9316" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">问题 1</h1><h2 id="4e7b" class="ky kb in bd kc kz la dn kg lb lc dp kk ld le lf ko lg lh li ks lj lk ll kw lm bi translated"><a class="ae jz" href="https://leetcode.com/contest/weekly-contest-296/problems/min-max-game/" rel="noopener ugc nofollow" target="_blank">最小最大游戏</a></h2><blockquote class="ln lo lp"><p id="bd05" class="lq lr ls lt b lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo ig bi translated">给你一个<strong class="lt io"> 0 索引的</strong>整数数组<code class="fe mp mq mr ms b">nums</code>，其长度是<code class="fe mp mq mr ms b">2</code>的幂。</p><p id="2e2b" class="lq lr ls lt b lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo ig bi translated">在<code class="fe mp mq mr ms b">nums</code>上应用以下算法:</p><p id="ea79" class="lq lr ls lt b lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo ig bi translated">设<code class="fe mp mq mr ms b">n</code>为<code class="fe mp mq mr ms b">nums</code>的长度。如果<code class="fe mp mq mr ms b">n == 1</code>，<strong class="lt io">结束</strong>过程。否则，<strong class="lt io">创建一个新的长度为<code class="fe mp mq mr ms b">n / 2</code>的<strong class="lt io"> 0 索引的</strong>整数数组<code class="fe mp mq mr ms b">newNums</code>。</strong></p><p id="1fe2" class="lq lr ls lt b lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo ig bi translated">对于每个<strong class="lt io">偶数</strong>索引<code class="fe mp mq mr ms b">i</code>其中<code class="fe mp mq mr ms b">0 &lt;= i &lt; n / 2</code>，<strong class="lt io">将<code class="fe mp mq mr ms b">newNums[i]</code>的值分配给</strong>作为<code class="fe mp mq mr ms b">min(nums[2 * i], nums[2 * i + 1])</code>。</p><p id="8970" class="lq lr ls lt b lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo ig bi translated">对于每一个<strong class="lt io">奇数</strong>索引<code class="fe mp mq mr ms b">i</code>，其中<code class="fe mp mq mr ms b">0 &lt;= i &lt; n / 2</code>，<strong class="lt io">将<code class="fe mp mq mr ms b">newNums[i]</code>的值指定为<code class="fe mp mq mr ms b">max(nums[2 * i], nums[2 * i + 1])</code>。</strong></p><p id="4170" class="lq lr ls lt b lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo ig bi translated"><strong class="lt io">用<code class="fe mp mq mr ms b">newNums</code>替换</strong>数组<code class="fe mp mq mr ms b">nums</code>。</p><p id="ef5c" class="lq lr ls lt b lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo ig bi translated"><strong class="lt io">从步骤 1 开始重复</strong>整个过程。</p><p id="d461" class="lq lr ls lt b lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo ig bi translated">应用算法后，返回 <code class="fe mp mq mr ms b">nums</code> <em class="in">中剩余的最后一个数字<em class="in">。</em></em></p></blockquote><h2 id="7931" class="ky kb in bd kc kz la dn kg lb lc dp kk ld le lf ko lg lh li ks lj lk ll kw lm bi translated"><strong class="ak">接近</strong></h2><p id="4409" class="pw-post-body-paragraph lq lr in lt b lu mt lw lx ly mu ma mb ld mv me mf lg mw mi mj lj mx mm mn mo ig bi translated">解决方案是问题中描述的简单实现。</p><ul class=""><li id="d6ad" class="my mz in lt b lu lv ly lz ld na lg nb lj nc mo nd ne nf ng bi translated">对于<strong class="lt io">偶数</strong>索引，我们取<strong class="lt io"> nums[2*i] </strong>和<strong class="lt io"> nums[2*i + 1] </strong>中的最小值</li><li id="30aa" class="my mz in lt b lu nh ly ni ld nj lg nk lj nl mo nd ne nf ng bi translated">对于奇数索引<strong class="lt io">和奇数索引</strong>，我们取最大值<strong class="lt io"> nums[2*i] </strong>和<strong class="lt io"> nums[2*i + 1] </strong></li></ul><p id="4e0a" class="pw-post-body-paragraph lq lr in lt b lu lv lw lx ly lz ma mb ld md me mf lg mh mi mj lj ml mm mn mo ig bi translated">我们这样做，直到数组中只存在一个数字。</p><h2 id="ddff" class="ky kb in bd kc kz la dn kg lb lc dp kk ld le lf ko lg lh li ks lj lk ll kw lm bi translated">解决办法</h2><div class="nm nn gp gr no np"><a href="https://github.com/bumblebee211196/lc_contests/blob/main/contest_296/python/problem1.py" rel="noopener  ugc nofollow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd io gy z fp nu fr fs nv fu fw im bi translated">LC _ contracts/problem 1 . py 在主大黄蜂 211196/LC _ contracts</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">此文件包含双向 Unicode 文本，其解释或编译可能与下面显示的不同…</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">github.com</p></div></div><div class="ny l"><div class="nz l oa ob oc ny od jt np"/></div></div></a></div><blockquote class="ln lo lp"><p id="1d2c" class="lq lr ls lt b lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo ig bi translated">时间复杂度:O(n)</p><p id="bdcf" class="lq lr ls lt b lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo ig bi translated">空间复杂度:O(n)</p></blockquote><h1 id="538c" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">问题 2</h1><h2 id="97ad" class="ky kb in bd kc kz la dn kg lb lc dp kk ld le lf ko lg lh li ks lj lk ll kw lm bi translated"><a class="ae jz" href="https://leetcode.com/contest/weekly-contest-296/problems/partition-array-such-that-maximum-difference-is-k/" rel="noopener ugc nofollow" target="_blank">划分数组，使最大差值为 K </a></h2><blockquote class="ln lo lp"><p id="040d" class="lq lr ls lt b lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo ig bi translated">给你一个整数数组<code class="fe mp mq mr ms b">nums</code>和一个整数<code class="fe mp mq mr ms b">k</code>。你可以将<code class="fe mp mq mr ms b">nums</code>分割成一个或多个<strong class="lt io">子序列</strong>，这样<code class="fe mp mq mr ms b">nums</code>中的每个元素都会出现在<strong class="lt io">的</strong>子序列中。</p><p id="6675" class="lq lr ls lt b lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo ig bi translated">返回<em class="in">所需的</em> <strong class="lt io"> <em class="in">最小</em> </strong> <em class="in">个数，使得每个子序列中的最大值和最小值之差最多为</em><strong class="lt io"><em class="in"/></strong><em class="in"/><code class="fe mp mq mr ms b">k</code><em class="in">。</em></p><p id="214e" class="lq lr ls lt b lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo ig bi translated"><strong class="lt io">子序列</strong>是可以通过删除一些或不删除元素而不改变剩余元素的顺序从另一个序列中导出的序列。</p></blockquote><h2 id="f824" class="ky kb in bd kc kz la dn kg lb lc dp kk ld le lf ko lg lh li ks lj lk ll kw lm bi translated">方法</h2><p id="7508" class="pw-post-body-paragraph lq lr in lt b lu mt lw lx ly mu ma mb ld mv me mf lg mw mi mj lj mx mm mn mo ig bi translated">对元素进行分组的条件是最大和最小元素之间的差必须是<em class="ls"> ≤ k </em>。我们对数组进行排序，并使用双指针方法，我们固定第一个指针的位置并移动第二个指针，直到两个指针处的元素之差为<em class="ls"> ≤ k </em>。当条件失败时，我们更新第一个指针的位置并重复这个过程。子序列的数量是第一个指针被更新的次数。</p><h2 id="a981" class="ky kb in bd kc kz la dn kg lb lc dp kk ld le lf ko lg lh li ks lj lk ll kw lm bi translated">解决办法</h2><div class="nm nn gp gr no np"><a href="https://github.com/bumblebee211196/lc_contests/blob/main/contest_296/python/problem2.py" rel="noopener  ugc nofollow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd io gy z fp nu fr fs nv fu fw im bi translated">LC _ contracts/problem 2 . py 在主大黄蜂 211196/LC _ contracts</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">此文件包含双向 Unicode 文本，其解释或编译可能与下面显示的不同…</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">github.com</p></div></div><div class="ny l"><div class="oe l oa ob oc ny od jt np"/></div></div></a></div><blockquote class="ln lo lp"><p id="15d3" class="lq lr ls lt b lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo ig bi translated">时间复杂度:O(nlogn)</p><p id="ee7c" class="lq lr ls lt b lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo ig bi translated">空间复杂度:O(1)</p></blockquote><h1 id="1d41" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">问题 3</h1><h2 id="f620" class="ky kb in bd kc kz la dn kg lb lc dp kk ld le lf ko lg lh li ks lj lk ll kw lm bi translated"><a class="ae jz" href="https://leetcode.com/contest/weekly-contest-296/problems/replace-elements-in-an-array/" rel="noopener ugc nofollow" target="_blank">替换数组中的元素</a></h2><blockquote class="ln lo lp"><p id="825a" class="lq lr ls lt b lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo ig bi translated">给你一个由<code class="fe mp mq mr ms b">n</code> <strong class="lt io">不同的</strong>正整数组成的<strong class="lt io"> 0 索引的</strong>数组<code class="fe mp mq mr ms b">nums</code>。对该数组应用<code class="fe mp mq mr ms b">m</code>操作，在<code class="fe mp mq mr ms b">ith</code>操作中，用<code class="fe mp mq mr ms b">operations[i][1]</code>替换数字<code class="fe mp mq mr ms b">operations[i][0]</code>。</p><p id="d07c" class="lq lr ls lt b lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo ig bi translated">保证在<code class="fe mp mq mr ms b">ith</code>操作中:</p><p id="89cf" class="lq lr ls lt b lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo ig bi translated"><code class="fe mp mq mr ms b">operations[i][0]</code> <strong class="lt io">存在于<code class="fe mp mq mr ms b">nums</code>中的</strong>。</p><p id="667b" class="lq lr ls lt b lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo ig bi translated"><code class="fe mp mq mr ms b">operations[i][1]</code>在<code class="fe mp mq mr ms b">nums</code>中<strong class="lt io">不存在</strong>吗？</p><p id="095c" class="lq lr ls lt b lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo ig bi translated">返回<em class="in">应用所有运算</em>后得到的数组。</p></blockquote><h2 id="5b5b" class="ky kb in bd kc kz la dn kg lb lc dp kk ld le lf ko lg lh li ks lj lk ll kw lm bi translated">方法</h2><p id="c579" class="pw-post-body-paragraph lq lr in lt b lu mt lw lx ly mu ma mb ld mv me mf lg mw mi mj lj mx mm mn mo ig bi translated">我们为给定数组中的每个元素维护一个值到索引的映射器。对于每个更新操作，我们找到<strong class="lt io">操作[i][0] </strong>的索引，并更新<strong class="lt io"> nums[operation[i][0]] </strong>到<strong class="lt io">操作[i][1] </strong>中的值，并更新索引映射器。</p><h2 id="e433" class="ky kb in bd kc kz la dn kg lb lc dp kk ld le lf ko lg lh li ks lj lk ll kw lm bi translated">解决办法</h2><div class="nm nn gp gr no np"><a href="https://github.com/bumblebee211196/lc_contests/blob/main/contest_296/python/problem3.py" rel="noopener  ugc nofollow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd io gy z fp nu fr fs nv fu fw im bi translated">LC _ contracts/problem 3 . py 在主大黄蜂 211196/LC _ contracts</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">此文件包含双向 Unicode 文本，其解释或编译可能与下面显示的不同…</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">github.com</p></div></div><div class="ny l"><div class="of l oa ob oc ny od jt np"/></div></div></a></div><blockquote class="ln lo lp"><p id="3639" class="lq lr ls lt b lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo ig bi translated">时间复杂度:O(n)</p><p id="3f73" class="lq lr ls lt b lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo ig bi translated">空间复杂度:O(n)</p></blockquote><h1 id="a6e7" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">问题 4</h1><h2 id="b42a" class="ky kb in bd kc kz la dn kg lb lc dp kk ld le lf ko lg lh li ks lj lk ll kw lm bi translated"><a class="ae jz" href="https://leetcode.com/contest/weekly-contest-296/problems/design-a-text-editor/" rel="noopener ugc nofollow" target="_blank">设计一个文本编辑器</a></h2><blockquote class="ln lo lp"><p id="7613" class="lq lr ls lt b lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo ig bi translated">设计一个带有光标的文本编辑器，它可以执行以下操作:</p><p id="ef8c" class="lq lr ls lt b lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo ig bi translated"><strong class="lt io">将</strong>文本添加到光标所在的位置。</p><p id="d0c2" class="lq lr ls lt b lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo ig bi translated"><strong class="lt io">删除光标所在位置的</strong>文本(模拟退格键)。</p><p id="8a37" class="lq lr ls lt b lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo ig bi translated"><strong class="lt io">向左或向右移动</strong>光标。</p><p id="a18e" class="lq lr ls lt b lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo ig bi translated">删除文本时，只会删除光标左侧的字符。光标也将保留在实际文本中，不能移动到文本之外。更正式的说法是，<code class="fe mp mq mr ms b">0 &lt;= cursor.position &lt;= currentText.length</code>永远成立。</p><p id="431b" class="lq lr ls lt b lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo ig bi translated">实现<code class="fe mp mq mr ms b">TextEditor</code>类:</p><p id="a0a3" class="lq lr ls lt b lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo ig bi translated"><code class="fe mp mq mr ms b">TextEditor()</code>用空文本初始化对象。</p><p id="231d" class="lq lr ls lt b lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo ig bi translated"><code class="fe mp mq mr ms b">void addText(string text)</code>将<code class="fe mp mq mr ms b">text</code>追加到光标所在的位置。光标在<code class="fe mp mq mr ms b">text</code>右侧结束。</p><p id="beeb" class="lq lr ls lt b lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo ig bi translated"><code class="fe mp mq mr ms b">int deleteText(int k)</code>删除光标左侧的<code class="fe mp mq mr ms b">k</code>字符。返回实际删除的字符数。</p><p id="77ed" class="lq lr ls lt b lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo ig bi translated"><code class="fe mp mq mr ms b">string cursorLeft(int k)</code>向左移动光标<code class="fe mp mq mr ms b">k</code>次。返回光标左侧的最后一个<code class="fe mp mq mr ms b">min(10, len)</code>字符，其中<code class="fe mp mq mr ms b">len</code>是光标左侧的字符数。</p><p id="cf22" class="lq lr ls lt b lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo ig bi translated"><code class="fe mp mq mr ms b">string cursorRight(int k)</code>向右移动光标<code class="fe mp mq mr ms b">k</code>次。返回光标左侧的最后一个<code class="fe mp mq mr ms b">min(10, len)</code>字符，其中<code class="fe mp mq mr ms b">len</code>是光标左侧的字符数。</p></blockquote><h2 id="5949" class="ky kb in bd kc kz la dn kg lb lc dp kk ld le lf ko lg lh li ks lj lk ll kw lm bi translated">方法</h2><p id="69cc" class="pw-post-body-paragraph lq lr in lt b lu mt lw lx ly mu ma mb ld mv me mf lg mw mi mj lj mx mm mn mo ig bi translated">我们可以使用两层方法。<em class="ls"> lstack </em>和<em class="ls"> rstack </em>。光标将始终位于<em class="ls">堆栈</em>的顶部。</p><ol class=""><li id="dbbb" class="my mz in lt b lu lv ly lz ld na lg nb lj nc mo og ne nf ng bi translated"><strong class="lt io">追加</strong>给定的文本将被追加到<em class="ls">堆栈</em>中。</li><li id="d234" class="my mz in lt b lu nh ly ni ld nj lg nk lj nl mo og ne nf ng bi translated"><strong class="lt io">删除</strong>我们从<em class="ls"> lstack </em>中删除字符，直到 k 达到 0 并且<em class="ls"> lstack </em>不为空。</li><li id="ecaf" class="my mz in lt b lu nh ly ni ld nj lg nk lj nl mo og ne nf ng bi translated"><strong class="lt io">向左移动光标</strong>向左移动光标的意思是，移动其下方的顶部指针，只是从<em class="ls"> lstack </em>中弹出元素。弹出的元素将被存储在<em class="ls"> rstack </em>中。</li><li id="e162" class="my mz in lt b lu nh ly ni ld nj lg nk lj nl mo og ne nf ng bi translated"><strong class="lt io">向右移动光标</strong>向右移动光标的意思是，移动上方的指针，只是从<em class="ls"> rstack </em>中弹出元素。弹出的元素将存储在<em class="ls"> lstack </em>中。</li></ol><h2 id="b8a8" class="ky kb in bd kc kz la dn kg lb lc dp kk ld le lf ko lg lh li ks lj lk ll kw lm bi translated">解决办法</h2><div class="nm nn gp gr no np"><a href="https://github.com/bumblebee211196/lc_contests/blob/main/contest_296/python/problem4.py" rel="noopener  ugc nofollow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd io gy z fp nu fr fs nv fu fw im bi translated">LC _ contracts/problem 4 . py 在主大黄蜂 211196/LC _ contracts</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">此文件包含双向 Unicode 文本，其解释或编译可能与下面显示的不同…</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">github.com</p></div></div><div class="ny l"><div class="oh l oa ob oc ny od jt np"/></div></div></a></div><blockquote class="ln lo lp"><p id="1baf" class="lq lr ls lt b lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo ig bi translated">时间复杂度:O(n)其中 n 是添加、删除的字符数或光标移动的位置数。</p><p id="01c2" class="lq lr ls lt b lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo ig bi translated">空间复杂度:O(n)其中 n 是存储在任一堆栈中的字符总数。</p></blockquote><p id="fb14" class="pw-post-body-paragraph lq lr in lt b lu lv lw lx ly lz ma mb ld md me mf lg mh mi mj lj ml mm mn mo ig bi translated">我希望你们喜欢这篇文章。</p><p id="e417" class="pw-post-body-paragraph lq lr in lt b lu lv lw lx ly lz ma mb ld md me mf lg mh mi mj lj ml mm mn mo ig bi translated">如果你觉得有帮助，请分享和鼓掌非常感谢！😄</p><p id="e9e6" class="pw-post-body-paragraph lq lr in lt b lu lv lw lx ly lz ma mb ld md me mf lg mh mi mj lj ml mm mn mo ig bi translated">欢迎在评论区提问！。</p></div></div>    
</body>
</html>