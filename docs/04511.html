<html>
<head>
<title>Dockerizing Spring App &amp; Automating Docker with Gradle</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Dockerizing Spring应用程序&amp;用Gradle自动化Docker</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/dockerizing-spring-app-with-gradle-3b6fbd650bf7?source=collection_archive---------0-----------------------#2021-03-27">https://blog.devgenius.io/dockerizing-spring-app-with-gradle-3b6fbd650bf7?source=collection_archive---------0-----------------------#2021-03-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="db63" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">Docker是一个工具，旨在通过使用容器来简化应用程序的创建、部署和运行。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/d6fff5f8cf70372595a00fb299ed6223.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ssd_uhlc6Ef5am31"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@exdigy?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">张秀坤·吕克曼</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="b971" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">今天我们将讲述贝娄的事情</strong></p><ol class=""><li id="699a" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">码头工人的重要性</li><li id="ecd4" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">docker概述</li><li id="4866" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">带有详细解释的Dockerizing spring应用程序</li><li id="3db3" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">Docker各种操作，例如:图像创建和删除，容器创建和删除等等</li><li id="92b9" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">使用命令行和docker桌面应用程序监控Docker图像</li><li id="6cd5" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">高级部分:docker任务的自动化，例如:docker构建、运行和从Gradle命令推送到docker hub</li></ol><p id="d12a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">先决条件:</strong>在开始这篇文章之前，您必须了解spring boot与Gradle依赖关系。你可以通过下面的链接了解这一点</p><div class="mg mh gp gr mi mj"><a href="https://mesukcse08.medium.com/spring-data-jpa-a-to-z-6c957ed17a66" rel="noopener follow" target="_blank"><div class="mk ab fo"><div class="ml ab mm cl cj mn"><h2 class="bd ir gy z fp mo fr fs mp fu fw ip bi translated">深入探讨spring boot和数据JPA实现:A到Z</h2><div class="mq l"><h3 class="bd b gy z fp mo fr fs mp fu fw dk translated">根据Spring文档，Spring Data JPA是更大的Spring数据家族的一部分，它使得轻松地…</h3></div><div class="mr l"><p class="bd b dl z fp mo fr fs mp fu fw dk translated">mesukcse08.medium.com</p></div></div><div class="ms l"><div class="mt l mu mv mw ms mx kp mj"/></div></div></a></div><ol class=""><li id="8f99" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><strong class="ky ir">码头工人的重要性</strong></li></ol><ul class=""><li id="208d" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr my ly lz ma bi translated">是一种工具，旨在通过使用容器来简化应用程序的创建、部署和运行。</li><li id="4064" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr my ly lz ma bi translated">容器非常适合持续集成和持续交付(CI/CD)工作流。</li><li id="780d" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr my ly lz ma bi translated">Docker的便携性和轻量级特性也使得动态管理工作负载变得容易，可以根据业务需求近乎实时地扩展或删除应用程序和服务。</li><li id="caf8" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr my ly lz ma bi translated">Docker是轻量级和快速的。它为基于虚拟机管理程序的虚拟机提供了一种可行且经济高效的替代方案，因此您可以利用更多计算能力来实现您的业务目标。</li><li id="24fd" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr my ly lz ma bi translated">容器允许开发人员将应用程序与它需要的所有部分打包在一起，比如库和其他依赖项，然后作为一个包发送出去。因此，开发人员可以放心，应用程序将在任何其他Linux机器上运行，而不管该机器的任何定制设置可能与用于编写和测试代码的机器不同。</li><li id="ddcd" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr my ly lz ma bi translated">Docker有点像虚拟机。但与虚拟机不同的是，Docker不是创建一个完整的虚拟操作系统，而是允许应用程序使用与运行它们的系统相同的Linux内核，并且只要求应用程序附带主机上尚未运行的东西。这极大地提高了性能，并减小了应用程序的大小。</li><li id="8a2e" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr my ly lz ma bi translated">重要的是，Docker是开源的。这意味着任何人都可以对Docker做出贡献，如果他们需要额外的功能，可以扩展Docker来满足他们自己的需求。</li></ul><p id="63c3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> 2。docker <br/> </strong>概述docker是一个软件平台，用于构建基于<em class="mz">容器</em>的应用程序——小型轻量级的执行环境，它们共享操作系统内核，但在其他方面彼此独立运行。Docker最初是为Linux开发的，现在也可以在Windows和macOS上运行。为了理解Docker是如何工作的，让我们来看看一些可以用来创建Docker容器化应用程序的组件。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi na"><img src="../Images/6ebd4db5427317af8ab834ec9e9101e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6EmCQJrsi0DdZfOFaFoaKw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">Docker生态系统和架构</figcaption></figure><p id="2e09" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我正在解释基本术语</p><p id="22d9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> Docker图像</strong>:</p><ul class=""><li id="aca8" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr my ly lz ma bi translated">一个只读模板，包含创建Docker容器的说明。</li><li id="69bc" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr my ly lz ma bi translated">文件名是Dockerfile，放在code文件夹中</li><li id="bbc1" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr my ly lz ma bi translated">包含说明和图像相关文件</li><li id="dd63" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr my ly lz ma bi translated">出于我们的目的，它将描述我们的java依赖项和一个war文件及其运行命令。</li><li id="6cc9" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr my ly lz ma bi translated">它管理版本，并像docker hub一样将其推送到注册表</li></ul><p id="6776" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">码头集装箱</strong></p><ul class=""><li id="38c1" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr my ly lz ma bi translated">容器是图像的可运行实例</li><li id="6d05" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr my ly lz ma bi translated">您可以使用Docker API或CLI创建、启动、停止、移动或删除容器</li><li id="9609" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr my ly lz ma bi translated">当容器被移除时，任何未存储在持久性存储中的对其状态的更改都会消失。</li><li id="293f" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr my ly lz ma bi translated">我们从docker映像构建一个容器，并在特定的端口运行这个容器。这些步骤需要端口映射</li></ul><p id="9d70" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> Docker注册表</strong></p><ul class=""><li id="83b7" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr my ly lz ma bi translated">存储具有适当版本的Docker图像</li><li id="9523" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr my ly lz ma bi translated">所有著名的应用程序必须在注册表中有条目</li><li id="89b5" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr my ly lz ma bi translated">Docker Hub是一个任何人都可以使用的公共注册表，默认情况下Docker被配置为在Docker Hub上查找图像。</li><li id="0a02" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr my ly lz ma bi translated">你甚至可以运行自己的私人注册。</li><li id="0de5" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr my ly lz ma bi translated">docker push和pull命令用于从公共注册表的</li></ul><p id="e8de" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">Docker守护进程</strong></p><ul class=""><li id="bc71" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr my ly lz ma bi translated">监听Docker API请求并管理Docker对象</li><li id="dd40" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr my ly lz ma bi translated">一个守护进程也可以与其他守护进程通信来管理Docker服务。</li></ul><p id="fa58" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> Docker客户端</strong></p><ul class=""><li id="eb68" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr my ly lz ma bi translated">许多Docker用户与Docker交互的主要方式</li><li id="e184" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr my ly lz ma bi translated">它接受客户端命令并将其发送到Docker守护进程</li><li id="6ddd" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr my ly lz ma bi translated">可以与多个守护进程通信</li></ul><p id="cf43" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> 3。Dockerizing spring app附详细讲解<br/> </strong>对于dockerizing spring boot应用，我们不会做多余的事情。我们只需在主目录中添加一个名为<strong class="ky ir"> Dockerfile </strong>的文件。该文件将包含运行该应用程序的所有指令</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nb"><img src="../Images/a56621d897eff6204d361aa7a162fdb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DZn53S3nk-FOL_SSqwvpPQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">docker文件位置和代码</figcaption></figure><p id="2ab4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的docker文件代码是</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="5827" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">来自:</strong>我们正在使用openjdk:8 alpine image构建这张图片。JDK有更多的图像，我们正在使用这个版本。您可以从docker hub link <br/> <strong class="ky ir"> ARG: </strong>查看更多图片我们将jar path作为ARG变量。这里我们的jar文件在<strong class="ky ir">build/libs/springreadyapp . jar</strong>中。ARG仅在构建Docker映像(RUN etc)期间可用，在创建映像并从中启动容器后不可用(ENTRYPOINT，CMD) <br/> <strong class="ky ir"> Copy: </strong>将此jar文件复制为springreadyapp.jar。我们将在此jar文件上执行RUN命令，其名称为<br/> <strong class="ky ir"> ENTRYPOINT: </strong>这将在容器启动时可执行。我们必须将它们定义为<em class="mz"> JSON-Array </em>，因为对于一些应用程序参数，我们将结合使用<em class="mz">入口点</em>和<em class="mz"> CMD </em>。这里我们传递jar文件运行命令</p><p id="91f3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> 4。Docker的各种操作<br/> </strong>我们必须遵循以下步骤</p><ul class=""><li id="be0a" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr my ly lz ma bi translated">使用Gradle命令和Jar创建来构建项目。</li><li id="f973" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr my ly lz ma bi translated">基于我们的jar文件构建docker映像</li><li id="36b5" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr my ly lz ma bi translated">使用提供的docker映像运行容器</li><li id="f5a0" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr my ly lz ma bi translated">删除docker容器和docker图像</li></ul><p id="cb8a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">构建项目<br/> </strong>使用gradlew命令可以清理并构建项目。有时它会显示一个可执行权限错误。在这种情况下，您必须允许可执行权限升级。其命令如下所示:</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="514f" class="nj nk iq nf b gy nl nm l nn no">chmod 777 gradlew<br/>./gradlew clean build -x test</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/4ddeab25f45a9192d938a0843ec419fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nTIO4HEyKay65ZMlMpIePQ.png"/></div></div></figure><p id="4980" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在jar文件已经准备好了。我们可以开始基于docker文件构建图像</p><p id="c818" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">构建docker映像<br/> </strong>命令从一个Docker文件和一个“上下文”中构建Docker映像。构建的上下文是位于指定的<code class="fe nq nr ns nf b">PATH</code>或<code class="fe nq nr ns nf b">URL</code>中的一组文件。使用此命令，它会用该上下文的指定指令和文件压缩映像。在我们的例子中，我们将从OpenJDK 8版本构建一个映像，从libs文件夹中复制jar并添加一个执行命令。<br/>下面是带有标签的构建命令:</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="a5a8" class="nj nk iq nf b gy nl nm l nn no"><strong class="nf ir">Build Image</strong><br/>docker image build -t springreadyapp .<br/><strong class="nf ir">View Images<br/></strong>docker images</span></pre><p id="c172" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里，我们用标签<strong class="ky ir"> springreadyapp构建了一个docker映像。</strong>您的应用程序已经编译、打包并转换为Docker映像。输出如下所示</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/7a3dc750a1c6d47ec3d7f0ec30960bdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T4ixamD4m9_yjNGz7BoMcw.png"/></div></div></figure><p id="8c15" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里我们的映像构建完成了，映像id是:<strong class="ky ir"> c7b3be12d247 </strong></p><p id="588b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> Docker容器从映像<br/> </strong>运行现在我们必须从我们的映像<strong class="ky ir"> c7b3be12d247运行一个容器。</strong>为此，我们还必须进行端口映射。下面是命令</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="1a71" class="nj nk iq nf b gy nl nm l nn no"><strong class="nf ir">Run command</strong><br/>docker run -d -p 8081:8081 <strong class="nf ir">c7b3be12d247</strong></span><span id="9e65" class="nj nk iq nf b gy nu nm l nn no"><strong class="nf ir">Container List</strong><br/>docker container ps</span></pre><p id="3db7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里，-d表示分离模式，<strong class="ky ir"> -p 8081:8081 </strong>表示外部端口is 8081与内部端口8081映射。这里，您必须确保外部端口必须是空闲的。这里，定义端口映射很重要，它将主机(8081)上的端口映射到Docker (8081)内部的端口，这是我们在Spring Boot应用程序的属性中定义的端口。输出如下所示</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nv"><img src="../Images/4e9461e3e0d2883d12dedbef15bb7f3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IBGcSfK-jzvr_gIkLl4lSQ.png"/></div></div></figure><p id="e84f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">容器正在运行，容器id为:<strong class="ky ir"> c7b3be12d247。</strong></p><p id="b383" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> 5。监控docker洞察<br/> </strong>我们可以使用命令行和docker桌面UI工具来监控docker容器洞察。</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="92fe" class="nj nk iq nf b gy nl nm l nn no"><strong class="nf ir">Insights the docker container</strong><br/>docker exec -it 804c6b86d49a /bin/sh<br/>Using exec command you entered the docker containe. Now you can execute all your necessary command here</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/787f3f313f0a86e14678f958ab21aed3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xIeUUVgW039DrUFPOM84_A.png"/></div></div></figure><p id="c1e7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你也可以使用Docker桌面来实现。这就像贝娄的形象</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/0b64b441f097ac5ae90fae3941c88548.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mlbFrmmMG5DZhorB39H2NQ.png"/></div></div></figure><p id="a1f6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在您的应用程序正在运行，它运行在永恒端口8081上。您可以从这里检查输出</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ny"><img src="../Images/7559867ce088ff10111e27ad2d29cc27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-3vAj1_5a6npbQni8LdeYg.png"/></div></div></figure><p id="a141" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">容器和图像控制</strong></p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="1db4" class="nj nk iq nf b gy nl nm l nn no"><strong class="nf ir">Docker container stop</strong><br/>docker container stop <strong class="nf ir">35ce00ba436f<br/></strong>Here,<strong class="nf ir"> 35ce00ba436f </strong>is the container id<br/><strong class="nf ir">Docker container removed<br/></strong>docker container rm -f <strong class="nf ir">35ce00ba436f<br/></strong>Here, -f means forcefully removing the container. This is optional</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nz"><img src="../Images/d4cb1a9a06b980146a968ef05c32623d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*96k-8F8Ne4IuoxC0WeFoOg.png"/></div></div></figure><p id="f8b7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> Docker图像删除</strong></p><p id="92da" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">docker image RM<strong class="ky ir">c 7 B3 be 12d 247</strong>T13】这里的<strong class="ky ir"> c7b3be12d247 </strong>是docker image id。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oa"><img src="../Images/9a33b43a5aaf726e261819ed2db9b1a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EBQMY93nIqvbBijkBM9b8A.png"/></div></div></figure><p id="ca40" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> 6。高级部分:Automotion <br/> </strong>现在，您可能希望在gradle项目中使用Gradle命令构建docker映像、运行容器并将映像推送到docker hub。我们将使用<a class="ae kv" href="https://plugins.gradle.org/search?term=com.palantir.docker" rel="noopener ugc nofollow" target="_blank"> <em class="mz"> Palantir Docker插件</em> </a> <em class="mz"> </em>进行Docker自动化。为了实现这一点，我们必须在build.gradle文件上执行dome步骤。这是格雷尔的档案</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="e95d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里我只添加了与自动化相关的变化。我们需要docker和docker-run这两个插件。在<strong class="ky ir"> docker </strong>闭包中，我添加了Dockerfile路径和文件访问指令。在<strong class="ky ir"> dockerRun </strong>闭包中，我添加了从docker映像运行docker容器的指令。</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="ce1b" class="nj nk iq nf b gy nl nm l nn no"><strong class="nf ir">Docker push image to docker hub<br/></strong>It’s command is : ./gradlew dockerPushDockerHub<br/>Using this command, this new version of image will push to docker hub account. <br/>Here, my repository path is <br/>tag <strong class="nf ir">'DockerHub'</strong>, <strong class="nf ir">"mesuk08/springreadyapp:</strong>$<strong class="nf ir">{</strong>project.version<strong class="nf ir">}" </strong>in docker closure</span></pre><p id="ec02" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在从命令行执行docker推/拉操作期间，您可能需要从终端登录和注销。登录和注销命令如下</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="a8e0" class="nj nk iq nf b gy nl nm l nn no">docker logout<br/>docker login</span></pre><p id="961f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">如何使用docker映像<br/> </strong>其他用户将从docker hub中提取带有标签号的映像，然后将该映像运行到他们的房屋中。现在这里我们的标签是:0.7它的命令是这样的:<br/><strong class="ky ir">docker pull mesuk 08/springreadyapp:0.7</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/ffd0c357a900382b0ebfe9b84da2c36b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8AJdMhDmuB_A7TnWbtGtfw.png"/></div></div></figure></div><div class="ab cl oc od hu oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="ij ik il im in"><p id="2879" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以在这个<a class="ae kv" href="https://github.com/mesuk/SpringReadyApp" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>中获得完整的源代码。<br/> <strong class="ky ir"> Swagger网址</strong>:<a class="ae kv" href="http://localhost:8081/springreadyapp/swagger-ui.html#/" rel="noopener ugc nofollow" target="_blank">http://localhost:8081/springreadyapp/Swagger-ui . html #/</a></p><p id="845a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢阅读:)</p></div></div>    
</body>
</html>