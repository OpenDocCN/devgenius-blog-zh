<html>
<head>
<title>Zero-Downtime Deployment in Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes 的零停机部署</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/zero-downtime-deployment-in-kubernetes-fe7470210b6a?source=collection_archive---------1-----------------------#2022-05-28">https://blog.devgenius.io/zero-downtime-deployment-in-kubernetes-fe7470210b6a?source=collection_archive---------1-----------------------#2022-05-28</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><h2 id="a7cf" class="il im in bd b dl io ip iq ir is it dk iu translated" aria-label="kicker paragraph">KUBERNETES 操作指南</h2><div class=""/><div class=""><h2 id="4489" class="pw-subtitle-paragraph jt iw in bd b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk dk translated">如何轻松实现滚动部署</h2></div><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/976ffa8938f38259e9c339735fb7ab61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wmRLVF1ykZALZfl6"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated"><a class="ae lb" href="https://unsplash.com/@spacex?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> SpaceX </a>在<a class="ae lb" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的展开图</figcaption></figure><blockquote class="lc"><p id="ebf3" class="ld le in bd lf lg lh li lj lk ll lm dk translated">在大多数地方，以零停机时间迁移为目标应该是常态，而不是例外。</p><p id="a460" class="ld le in bd lf lg ln lo lp lq lr lm dk translated">格尔吉利·奥罗兹</p></blockquote><p id="997a" class="pw-post-body-paragraph ls lt in lu b lv lw jx lx ly lz ka ma mb mc md me mf mg mh mi mj mk ml mm lm ig bi translated">零停机部署是许多工程团队的梦想。在这个高速增长的时代，无需通知用户“维护期”就能交付价值的“魔法”是一个致命的弱点。</p><p id="f187" class="pw-post-body-paragraph ls lt in lu b lv mn jx lx ly mo ka ma mb mp md me mf mq mh mi mj mr ml mm lm ig bi translated">尽管如此，实现零停机部署并不总是容易的。然而，不要害怕，因为 Kubernetes 来救援。在本文中，我将指导您使用滚动方法在 Kubernetes 集群中创建零停机部署。</p><p id="6495" class="pw-post-body-paragraph ls lt in lu b lv mn jx lx ly mo ka ma mb mp md me mf mq mh mi mj mr ml mm lm ig bi translated"><em class="ms">注意:虽然我们将使用滚动方法，但这不是唯一的方法。你可以在这里</em>  <em class="ms">阅读更多关于部署策略</em> <a class="ae lb" href="https://harness.io/blog/continuous-verification/blue-green-canary-deployment-strategies/" rel="noopener ugc nofollow" target="_blank"> <em class="ms">。</em></a></p><p id="f006" class="pw-post-body-paragraph ls lt in lu b lv mn jx lx ly mo ka ma mb mp md me mf mq mh mi mj mr ml mm lm ig bi translated"><em class="ms">注意:我不打算在这篇文章中解释 Kubernetes。你可以在这里</em>  <em class="ms">阅读关于 Kubernetes 对象</em> <a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/deploy-socket-io-to-kubernetes-part-2-infrastructure-7764fec252d0"> <em class="ms">的基本解释，或者你也可以在 YouTube 上查看 Kubernetes 教程。</em></a></p><h1 id="aec0" class="mt mu in bd mv mw mx my mz na nb nc nd kc ne kd nf kf ng kg nh ki ni kj nj nk bi translated">创建应用程序和图像</h1><p id="09f2" class="pw-post-body-paragraph ls lt in lu b lv nl jx lx ly nm ka ma mb nn md me mf no mh mi mj np ml mm lm ig bi translated">端点将非常简单，只返回当前版本。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="b7d5" class="pw-post-body-paragraph ls lt in lu b lv mn jx lx ly mo ka ma mb mp md me mf mq mh mi mj mr ml mm lm ig bi translated"><em class="ms">注意:如果我们想要测试滚动部署，我们需要在构建第二个映像之前替换响应。</em></p><p id="8ba6" class="pw-post-body-paragraph ls lt in lu b lv mn jx lx ly mo ka ma mb mp md me mf mq mh mi mj mr ml mm lm ig bi translated">至于 15 秒睡眠，我想在 Kubernetes 中模拟启动一个新 pod 时的延迟。15 秒钟模拟实际服务器连接到数据库和其他外部依赖项的时间。滚动应该有效，即使没有睡眠时间。</p><p id="b639" class="pw-post-body-paragraph ls lt in lu b lv mn jx lx ly mo ka ma mb mp md me mf mq mh mi mj mr ml mm lm ig bi translated">对于 Docker 图片，我只是用了 FastAPI 网站的<code class="fe ns nt nu nv b">Dockerfile</code> <a class="ae lb" href="https://fastapi.tiangolo.com/deployment/docker/" rel="noopener ugc nofollow" target="_blank">。这是我的图像文件:</a></p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="62eb" class="pw-post-body-paragraph ls lt in lu b lv mn jx lx ly mo ka ma mb mp md me mf mq mh mi mj mr ml mm lm ig bi translated">现在我们有了一个简单的应用程序和<code class="fe ns nt nu nv b">Dockerfile</code>，接下来我想做的是测试滚动策略。</p><h1 id="41c8" class="mt mu in bd mv mw mx my mz na nb nc nd kc ne kd nf kf ng kg nh ki ni kj nj nk bi translated">设置集群</h1><p id="aaa7" class="pw-post-body-paragraph ls lt in lu b lv nl jx lx ly nm ka ma mb nn md me mf no mh mi mj np ml mm lm ig bi translated">虽然我使用的是谷歌云提供商(GCP)，但也可以使用任何具有 Kubernetes 功能的云提供商。我选择 GCP，因为我仍然有一个免费的计划。</p><p id="9acd" class="pw-post-body-paragraph ls lt in lu b lv mn jx lx ly mo ka ma mb mp md me mf mq mh mi mj mr ml mm lm ig bi translated">如果你想使用美国地区，你可以阅读关于如何使用 Google Kubernetes 引擎提供 Kubernetes 集群的指南。然而，如果你想在其他地区使用，我不知道它是否有效。根据我的经验，在雅加达(而不是美国地区)有一个与服务帐户相关的错误。因此，我们必须自己调配 GKE 群集，而不使用上面指南中的模块。</p><h2 id="9cec" class="nw mu in bd mv nx ny dn mz nz oa dp nd mb ob oc nf mf od oe nh mj of og nj it bi translated">网络配置</h2><p id="8c85" class="pw-post-body-paragraph ls lt in lu b lv nl jx lx ly nm ka ma mb nn md me mf no mh mi mj np ml mm lm ig bi translated">为了自己调配 Kubernetes 集群，我们需要首先创建 VPC 和子网。这是我使用的配置:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="9e9f" class="pw-post-body-paragraph ls lt in lu b lv mn jx lx ly mo ka ma mb mp md me mf mq mh mi mj mr ml mm lm ig bi translated"><em class="ms">注:原始代码可以在</em> <a class="ae lb" href="https://github.com/iamdejan/k8s-rollout-demo/blob/main/03-network.tf" rel="noopener ugc nofollow" target="_blank"> <em class="ms">这里</em> </a> <em class="ms">找到。</em></p><h2 id="3335" class="nw mu in bd mv nx ny dn mz nz oa dp nd mb ob oc nf mf od oe nh mj of og nj it bi translated">GKE 集群配置</h2><p id="14e0" class="pw-post-body-paragraph ls lt in lu b lv nl jx lx ly nm ka ma mb nn md me mf no mh mi mj np ml mm lm ig bi translated">对于 GKE 集群配置，我们使用标准的<code class="fe ns nt nu nv b">google_container_cluster</code>资源。然而，根据来自<a class="ae lb" href="https://learn.hashicorp.com/tutorials/terraform/gke" rel="noopener ugc nofollow" target="_blank"> HashiCorp Learn </a>的提示，我们需要在调配我们自己的节点池后“放弃”默认节点池。事实上，下面的代码是对那篇文章中提到的 GitHub repo 的修改。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="e723" class="pw-post-body-paragraph ls lt in lu b lv mn jx lx ly mo ka ma mb mp md me mf mq mh mi mj mr ml mm lm ig bi translated">现在你明白了(在上面的代码中)为什么我们需要“手动”创建我们自己的子网。这些子网将由 GKE 群集使用。</p><p id="2e0f" class="pw-post-body-paragraph ls lt in lu b lv mn jx lx ly mo ka ma mb mp md me mf mq mh mi mj mr ml mm lm ig bi translated"><em class="ms">注:HashiCorp Learn 的文章和我的代码的一个重要区别是，我在</em> <code class="fe ns nt nu nv b"><em class="ms">google_container_cluster</em></code> <em class="ms">资源中添加了</em> <code class="fe ns nt nu nv b"><em class="ms">ip_allocation_policy</em></code> <em class="ms">。如果我们不添加该配置，每次应用 Terraform 配置时，我们都“被迫”重新创建集群，这不是我们想要的。</em></p><h1 id="7adc" class="mt mu in bd mv mw mx my mz na nb nc nd kc ne kd nf kf ng kg nh ki ni kj nj nk bi translated">创建部署和服务</h1><p id="a3e4" class="pw-post-body-paragraph ls lt in lu b lv nl jx lx ly nm ka ma mb nn md me mf no mh mi mj np ml mm lm ig bi translated">为了测试我们的应用程序，我们需要创建<code class="fe ns nt nu nv b">Deployment</code>和<code class="fe ns nt nu nv b">Service</code>，这样我们就可以通过互联网访问端点。</p><p id="59be" class="pw-post-body-paragraph ls lt in lu b lv mn jx lx ly mo ka ma mb mp md me mf mq mh mi mj mr ml mm lm ig bi translated">这是我用来创建部署和服务的 Kubernetes 对象文件:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="8604" class="pw-post-body-paragraph ls lt in lu b lv mn jx lx ly mo ka ma mb mp md me mf mq mh mi mj mr ml mm lm ig bi translated">注意:我还没有添加滚动配置。这将在下一小节中完成。</p><p id="c1ed" class="pw-post-body-paragraph ls lt in lu b lv mn jx lx ly mo ka ma mb mp md me mf mq mh mi mj mr ml mm lm ig bi translated">如您所见，我创建了一个<code class="fe ns nt nu nv b">Deployment</code>，然后用一个<code class="fe ns nt nu nv b">LoadBalancer</code>服务公开它。这允许我们从互联网访问容器。</p><p id="b5c6" class="pw-post-body-paragraph ls lt in lu b lv mn jx lx ly mo ka ma mb mp md me mf mq mh mi mj mr ml mm lm ig bi translated">在我的配置文件中，我为我的 pod 添加了健康检查配置。原因是我想让 Kubernetes 知道什么是健康指标，所以如果有任何 pod 不“健康”，Kubernetes 将自动删除 pod 并重新创建一个新的。</p><p id="cad7" class="pw-post-body-paragraph ls lt in lu b lv mn jx lx ly mo ka ma mb mp md me mf mq mh mi mj mr ml mm lm ig bi translated">另外，如果你注意到了，我用地形创造了这些 Kubernetes 物体，而不是 YAML。原因是滚动部署可以从<code class="fe ns nt nu nv b">terraform apply</code>命令自动触发。</p><p id="1e12" class="pw-post-body-paragraph ls lt in lu b lv mn jx lx ly mo ka ma mb mp md me mf mq mh mi mj mr ml mm lm ig bi translated">我没有使用 Google Container Registry (GCR)来配置 Kubernetes 对象的一个原因是，Kubernetes 需要额外的工作来从 GCR 获取图像。你可以在这里看到关于在 Kubernetes 中使用 GCR 图片的指南。</p><h2 id="ed65" class="nw mu in bd mv nx ny dn mz nz oa dp nd mb ob oc nf mf od oe nh mj of og nj it bi translated">配置滚动</h2><p id="0f96" class="pw-post-body-paragraph ls lt in lu b lv nl jx lx ly nm ka ma mb nn md me mf no mh mi mj np ml mm lm ig bi translated">现在，谈谈滚动策略。</p><p id="0f75" class="pw-post-body-paragraph ls lt in lu b lv mn jx lx ly mo ka ma mb mp md me mf mq mh mi mj mr ml mm lm ig bi translated">默认情况下，Kubernetes 在 Terraform 中的部署已经包括滚动。但是，如果您不确定或者想要自定义行为，您可以自定义滚动模式。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi oh"><img src="../Images/1a809be0a6ea77d29f6b2fe345c385aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LMHpJdTavR--PpnqWv6M1g.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">添加滚动更新配置。</figcaption></figure><p id="b47c" class="pw-post-body-paragraph ls lt in lu b lv mn jx lx ly mo ka ma mb mp md me mf mq mh mi mj mr ml mm lm ig bi translated"><em class="ms">注:最终的源代码可以在这里</em> <a class="ae lb" href="https://github.com/iamdejan/k8s-rollout-demo/blob/main/05-kubernetes.tf" rel="noopener ugc nofollow" target="_blank"> <em class="ms">找到</em> </a> <em class="ms">。</em></p><p id="3f8a" class="pw-post-body-paragraph ls lt in lu b lv mn jx lx ly mo ka ma mb mp md me mf mq mh mi mj mr ml mm lm ig bi translated">现在你可能想知道，<code class="fe ns nt nu nv b">max_surge</code>和<code class="fe ns nt nu nv b">max_unavailable</code>是什么意思。让我试着简单解释一下。滚动部署意味着在部署期间将会有一个或多个额外的单元，并且在新单元被认为是健康的之后，旧单元将被删除。<code class="fe ns nt nu nv b">max_surge</code>表示在轧制开始前应该提供多少个新的 pod，而<code class="fe ns nt nu nv b">max_unavailable</code>表示在 pod 终止部分有多少个 pod 不可用。</p><h2 id="e97d" class="nw mu in bd mv nx ny dn mz nz oa dp nd mb ob oc nf mf od oe nh mj of og nj it bi translated">如何触发滚动部署</h2><p id="e5ae" class="pw-post-body-paragraph ls lt in lu b lv nl jx lx ly nm ka ma mb nn md me mf no mh mi mj np ml mm lm ig bi translated">前面我说过之所以用 Terraform 写 Kubernetes 配置文件是为了实用(用<code class="fe ns nt nu nv b">terraform apply</code>触发滚动部署)。但是，它是如何工作的呢？</p><p id="3f67" class="pw-post-body-paragraph ls lt in lu b lv mn jx lx ly mo ka ma mb mp md me mf mq mh mi mj mr ml mm lm ig bi translated">根据<a class="ae lb" href="https://www.goodreads.com/book/show/44144501-kubernetes-patterns" rel="noopener ugc nofollow" target="_blank"> Kubernetes 模式书</a>，为了触发对<code class="fe ns nt nu nv b">Deployment</code>对象的更新，有三个选项:</p><ol class=""><li id="e008" class="oi oj in lu b lv mn ly mo mb ok mf ol mj om lm on oo op oq bi translated">用带有<code class="fe ns nt nu nv b">kubectl replace</code>的新版本替换整个<code class="fe ns nt nu nv b">Deployment</code>。</li><li id="8b93" class="oi oj in lu b lv or ly os mb ot mf ou mj ov lm on oo op oq bi translated">使用<code class="fe ns nt nu nv b">kubectl patch</code>为部署打补丁。</li><li id="64ff" class="oi oj in lu b lv or ly os mb ot mf ou mj ov lm on oo op oq bi translated">用<code class="fe ns nt nu nv b">kubectl set image</code>改变 pod 的图像。</li></ol><p id="e516" class="pw-post-body-paragraph ls lt in lu b lv mn jx lx ly mo ka ma mb mp md me mf mq mh mi mj mr ml mm lm ig bi translated">我的猜测是，Terraform 使用第二或第三选项。</p><h1 id="393e" class="mt mu in bd mv mw mx my mz na nb nc nd kc ne kd nf kf ng kg nh ki ni kj nj nk bi translated">配置配置项/光盘</h1><p id="979c" class="pw-post-body-paragraph ls lt in lu b lv nl jx lx ly nm ka ma mb nn md me mf no mh mi mj np ml mm lm ig bi translated">GitHub Actions 是 GitHub 为开源库提供的免费使用的 CI/CD 管道。在这篇文章中，我使用 GitHub 动作来执行<code class="fe ns nt nu nv b">terraform apply</code>命令。</p><p id="2de9" class="pw-post-body-paragraph ls lt in lu b lv mn jx lx ly mo ka ma mb mp md me mf mq mh mi mj mr ml mm lm ig bi translated"><em class="ms">注意:我不会在这篇文章中深入讨论 GitHub 动作。可以从 GitHub 网站</em> <a class="ae lb" href="https://docs.github.com/en/actions/learn-github-actions/understanding-github-actions" rel="noopener ugc nofollow" target="_blank"> <em class="ms">这里</em> </a> <em class="ms">了解。</em></p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="beb1" class="pw-post-body-paragraph ls lt in lu b lv mn jx lx ly mo ka ma mb mp md me mf mq mh mi mj mr ml mm lm ig bi translated"><em class="ms">注:源代码可以在</em> <a class="ae lb" href="https://github.com/iamdejan/k8s-rollout-demo/blob/main/.github/workflows/default.yaml" rel="noopener ugc nofollow" target="_blank"> <em class="ms">这里找到</em> </a> <em class="ms">。</em></p><p id="c637" class="pw-post-body-paragraph ls lt in lu b lv mn jx lx ly mo ka ma mb mp md me mf mq mh mi mj mr ml mm lm ig bi translated">逻辑很简单。我们克隆存储库(虽然我不明白为什么这个动作使用了<code class="fe ns nt nu nv b">checkout</code>术语)，然后我们用<code class="fe ns nt nu nv b">mypy</code>和<code class="fe ns nt nu nv b">pycodestyle</code>验证代码。之后，我们设置了 Terraform 访问和修改 GCP 资源所需的<code class="fe ns nt nu nv b">gcloud</code>命令。之后，我们运行<code class="fe ns nt nu nv b">terraform apply</code>命令，这将触发滚动部署。</p><h1 id="2e02" class="mt mu in bd mv mw mx my mz na nb nc nd kc ne kd nf kf ng kg nh ki ni kj nj nk bi translated">秀场</h1><p id="7913" class="pw-post-body-paragraph ls lt in lu b lv nl jx lx ly nm ka ma mb nn md me mf no mh mi mj np ml mm lm ig bi translated">在提供了集群和 Kubernetes 对象之后，现在是测试应用程序的时候了。让我们首先通过浏览器、终端(<code class="fe ns nt nu nv b">cURL</code>或其他 CLI 应用程序)或用于 HTTP 端点测试的 GUI 应用程序(如 Postman)访问端点来测试现有应用程序。</p><p id="9c54" class="pw-post-body-paragraph ls lt in lu b lv mn jx lx ly mo ka ma mb mp md me mf mq mh mi mj mr ml mm lm ig bi translated">为了访问端点，请按照下列步骤操作:</p><ol class=""><li id="cf78" class="oi oj in lu b lv mn ly mo mb ok mf ol mj om lm on oo op oq bi translated">运行<code class="fe ns nt nu nv b">kubectl get services</code>。您将在<code class="fe ns nt nu nv b">EXTERNAL-IP</code>栏获得 IP 地址。</li><li id="14fd" class="oi oj in lu b lv or ly os mb ot mf ou mj ov lm on oo op oq bi translated">使用以下格式的 URL 访问端点:<code class="fe ns nt nu nv b">${external ip}/version</code>。您将等待 15 秒钟，然后您将得到如下图所示的响应。</li></ol><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ow"><img src="../Images/2a965b839a8ecbe976784d2a2c512a1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eP1dk8-QQzifvhM7aHCOnw.png"/></div></div></figure><p id="5611" class="pw-post-body-paragraph ls lt in lu b lv mn jx lx ly mo ka ma mb mp md me mf mq mh mi mj mr ml mm lm ig bi translated">现在，让我们更新代码并推入 GitHub，看看滚动部署是否有效。这是我的变化:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ox"><img src="../Images/a8af8763ae43529ee773183e4467afa3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tTqlRKNW8EcwGU73nzCJlQ.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">更改端点中返回的版本。</figcaption></figure><p id="50b9" class="pw-post-body-paragraph ls lt in lu b lv mn jx lx ly mo ka ma mb mp md me mf mq mh mi mj mr ml mm lm ig bi translated">如果你使用<code class="fe ns nt nu nv b">watch “kubectl get pods — field-selector=status.phase=Running”</code>观看豆荚，你会看到类似这些截图的东西:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi oy"><img src="../Images/5edbe9e2c684efeb054ac026f79f93a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jeH4KS2AN-82VM0eOf3gdQ.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">(1)第一个旧 pod 正在终止。</figcaption></figure><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi oz"><img src="../Images/9aef1da62355ee043dc9297ff7b45934.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P-NYGdOiV3hfFhGYJ9iQgQ.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">(2)一个新的 pod 已经在运行，而第二个 pod 正在终止。</figcaption></figure><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi oy"><img src="../Images/eb4b7ea202020d761e1667eb9370c1ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GzPukfQfBHHoUszAbp_T5g.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">(3)第二个和第三个旧 pod 正在终止，而第二个新 pod 正在运行。</figcaption></figure><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi pa"><img src="../Images/2df3af8782b8b550bd8c56de6d1577e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zw4yNum3aaOUfgN_9HWkUw.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">(4)旧的荚被终止并用新的荚代替。</figcaption></figure><p id="1d7e" class="pw-post-body-paragraph ls lt in lu b lv mn jx lx ly mo ka ma mb mp md me mf mq mh mi mj mr ml mm lm ig bi translated">现在，要测试部署是否成功，请访问同一个端点。你会得到不同的输出。这是我更新后的输出:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi pb"><img src="../Images/83cf81c911c9ef442632bd2b007f2e9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MNH8AqBrrKSvMynU_eOtCA.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">端点已更新！</figcaption></figure><p id="9a83" class="pw-post-body-paragraph ls lt in lu b lv mn jx lx ly mo ka ma mb mp md me mf mq mh mi mj mr ml mm lm ig bi translated">嗯，有效！很棒，对吧？这里可以看到完整的代码<a class="ae lb" href="https://github.com/iamdejan/k8s-rollout-demo" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="dc02" class="pw-post-body-paragraph ls lt in lu b lv mn jx lx ly mo ka ma mb mp md me mf mq mh mi mj mr ml mm lm ig bi translated"><em class="ms">注意:我意识到我应该在滚动过程中测试端点，因为这是滚动更新的好处。不过，我认为通过监控豆荚将足以证明滚动更新是成功的。此外，在实践中，我很难做到这一点，因为我需要在测试端点时截屏滚动过程，所以我选择截屏。</em></p><h1 id="9ca3" class="mt mu in bd mv mw mx my mz na nb nc nd kc ne kd nf kf ng kg nh ki ni kj nj nk bi translated">一个制作技巧</h1><p id="6444" class="pw-post-body-paragraph ls lt in lu b lv nl jx lx ly nm ka ma mb nn md me mf no mh mi mj np ml mm lm ig bi translated">当您想在生产中这样做时，我的一个建议是，您需要将 Kubernetes 集群供应的 Terraform 代码与 Kubernetes 对象配置文件(包含<code class="fe ns nt nu nv b">Deployment</code>和<code class="fe ns nt nu nv b">Service</code>)分开。原因是出于安全目的，我们希望限制对 Kubernetes 集群配置的访问。开发者将直接与 K8s 对象交互。</p></div><div class="ab cl pc pd hr pe" role="separator"><span class="pf bw bk pg ph pi"/><span class="pf bw bk pg ph pi"/><span class="pf bw bk pg ph"/></div><div class="ig ih ii ij ik"><p id="27b4" class="pw-post-body-paragraph ls lt in lu b lv mn jx lx ly mo ka ma mb mp md me mf mq mh mi mj mr ml mm lm ig bi translated">我希望您通过本指南了解如何在 Kubernetes 中设置滚动部署。回头见！</p></div></div>    
</body>
</html>