<html>
<head>
<title>Serialization and Deserialization in Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java 中的序列化和反序列化</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/serialization-and-deserialization-in-java-49025b40c45d?source=collection_archive---------5-----------------------#2022-02-14">https://blog.devgenius.io/serialization-and-deserialization-in-java-49025b40c45d?source=collection_archive---------5-----------------------#2022-02-14</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="c818" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们可能都听说过这些术语在软件开发过程中到处出现。在本文中，我们将通过例子和用例来揭开这些术语的神秘面纱。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4cf711a1a91b10d7bb1dce2edf986c8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FV_xM4GDef_tOp9v"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">马库斯·斯皮斯克在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="225b" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">定义</h1><p id="db87" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated"><code class="fe mc md me mf b">define: serialization</code>和<code class="fe mc md me mf b">define: deserialization</code></p><blockquote class="mg mh mi"><p id="b326" class="jk jl mj jm b jn jo jp jq jr js jt ju mk jw jx jy ml ka kb kc mm ke kf kg kh ig bi translated">在计算中，<strong class="jm io">串行化</strong>(美国拼法)或<strong class="jm io">串行化</strong>(英国拼法)是将数据结构或对象状态转换成可以存储(例如，在文件或内存数据缓冲区中)或传输(例如，通过计算机网络)并在以后重建(可能在不同的计算机环境中)的格式的过程</p><p id="1322" class="jk jl mj jm b jn jo jp jq jr js jt ju mk jw jx jy ml ka kb kc mm ke kf kg kh ig bi translated">相反的操作，从一系列字节中提取数据结构，是<strong class="jm io">反序列化</strong></p></blockquote><h1 id="b5fc" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">通过一个例子来理解它</h1><p id="c50e" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">在本节中，我们将以一个非常常见的数据结构<strong class="jm io">二叉树</strong>为例，尝试将其序列化为 S <strong class="jm io"> tring </strong>并反序列化回<strong class="jm io">二叉树</strong>。</p><p id="113e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们已经创建了一个算法类，它有两个方法叫做 serialize 和 deserialize，将二叉树序列化为一个字符串，并将字符串反序列化为二叉树。</p><p id="c6ae" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">序列化</strong>算法非常简单。我们以<strong class="jm io">预排序</strong>的方式遍历树，并创建一个字符串，其中节点值由“，”连接，无论我们在哪里得到<code class="fe mc md me mf b">null</code>，我们都将其表示为特殊字符“N”(该特殊字符必须是唯一的，以便我们可以区分可能的节点值和<code class="fe mc md me mf b">null</code></p><p id="6943" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在<strong class="jm io">反序列化</strong>中，我们在“”处分割字符串，并将这些字符串存储为队列。然后遍历队列，每当我们检测到一个特殊字符(在我们的例子中是“N”)时，我们知道我们必须在这里停下来并返回<code class="fe mc md me mf b">null</code>，否则，我们递归地继续创建节点。</p><pre class="kj kk kl km gt mn mf mo mp aw mq bi"><span id="2155" class="mr la in mf b gy ms mt l mu mv">import java.util.ArrayList;<br/>import java.util.Arrays;<br/>import java.util.LinkedList;<br/>import java.util.Queue;</span><span id="365d" class="mr la in mf b gy mw mt l mu mv">/**<br/> * Definition for a binary tree node.<br/> * public class TreeNode {<br/> *     int val;<br/> *     TreeNode left;<br/> *     TreeNode right;<br/> *     TreeNode(int x) { val = x; }<br/> * }<br/> */</span><span id="2516" class="mr la in mf b gy mw mt l mu mv">/**<br/> * This algorithm class gives two methods<br/> * to serialize and deserialize to serialize <br/> * a Binary Tree to String and String to <br/> * Binary Tree respectively.<br/> * <br/> * We will just separate nodes value with ","<br/> * and whenever there is null then we can represent<br/> * that node with "N" so that later we can decrypt it.<br/> */<br/>public class Algorithm {<br/>    public String serialize(TreeNode root) {<br/>        if (null == root) return "N";<br/>        StringBuilder sb = new StringBuilder();<br/>        sb.append(root.val);<br/>        sb.append(",");<br/>        sb.append(serialize(root.left));<br/>        sb.append(",");<br/>        sb.append(serialize(root.right));<br/>        return sb.toString();<br/>    }</span><span id="5a0a" class="mr la in mf b gy mw mt l mu mv">    public TreeNode deserialize(String data) {<br/>        Queue&lt;String&gt; q = new LinkedList&lt;&gt;(<br/>                new ArrayList&lt;String&gt;(<br/>                    Arrays.asList(data.split(","))<br/>                )<br/>            );<br/>        return util(q);<br/>    }</span><span id="ab44" class="mr la in mf b gy mw mt l mu mv">    public TreeNode util(Queue&lt;String&gt; q) {<br/>        String str = q.poll();<br/>        if (str.equals("N")) return null;<br/>        TreeNode node = new TreeNode(Integer.valueOf(str));<br/>        node.left = util(q);<br/>        node.right = util(q);<br/>        return node;<br/>    }<br/>}</span></pre><h1 id="d2cf" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">Spring Boot 的序列化和反序列化</h1><p id="b8bf" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated"><em class="mj">Rest 方面，API</em><strong class="jm io"><em class="mj">序列化</em> </strong> <em class="mj">是 Spring boot 将 Java 对象转换为 JSON 对象时所做的事情，同理，</em> <strong class="jm io"> <em class="mj">反序列化</em> </strong> <em class="mj">是将 JSON 对象转换为 Java 对象时所做的事情。</em></p><h2 id="0038" class="mr la in bd lb mx my dn lf mz na dp lj jv nb nc ln jz nd ne lr kd nf ng lv nh bi translated">序列化</h2><p id="22d2" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">通常，我们使用<code class="fe mc md me mf b">Serializable</code>接口将我们的类标记为可序列化的。通过这样做，我们确保我们的类对象可以被转换成流。例如，这里我们的<code class="fe mc md me mf b">Student</code>类实现了 Serializable，并且定义了<code class="fe mc md me mf b">serialVersionUID</code>。</p><pre class="kj kk kl km gt mn mf mo mp aw mq bi"><span id="c285" class="mr la in mf b gy ms mt l mu mv">@Builder<br/>@NoArgsConstructor<br/>@AllArgsConstructor<br/>@Data<br/>public class Student implements Serializable {<br/>    private static final long serialVersionUID = 1L; <br/>    private Integer id;<br/>    private String name;<br/>    private String class;<br/> <br/>    // Client don't want this unprocessed data<br/>    @JsonIgnore<br/>    private String jsonResult; <br/> <br/>    // They want processed data instead<br/>    private Result result;<br/>}</span></pre><p id="c2d2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用这种方法时，我们需要考虑的几个注意事项是</p><ol class=""><li id="ec70" class="ni nj in jm b jn jo jr js jv nk jz nl kd nm kh nn no np nq bi translated">当一个类实现了<em class="mj"> </em> <code class="fe mc md me mf b">Serializable</code>接口时，它的所有子类也是可序列化的。相反，当一个对象引用另一个对象时，这些对象必须单独实现<code class="fe mc md me mf b">Serializable</code>接口，否则将抛出<code class="fe mc md me mf b">NotSerializableException</code>。</li><li id="a243" class="ni nj in jm b jn nr jr ns jv nt jz nu kd nv kh nn no np nq bi translated">我们使用<code class="fe mc md me mf b">serialVersionUID</code>来验证保存和加载的对象具有相同的属性，因此与序列化兼容。如果我们不声明它，那么 JVM 将在运行时自动生成一个依赖于编译器的，因此可能会导致意外的<code class="fe mc md me mf b">InvalidClassException</code>。</li></ol><h2 id="5151" class="mr la in bd lb mx my dn lf mz na dp lj jv nb nc ln jz nd ne lr kd nf ng lv nh bi translated">反序列化</h2><p id="8416" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">当我们从某个 API 获取数据或者读取某个外部 JSON 文件并将其存储为一个定义良好的类时，我们可以使用<code class="fe mc md me mf b">ObjectMapper</code>。例如，这里我们正在读取一个 JSON 值，并将该值存储为 Student class。</p><pre class="kj kk kl km gt mn mf mo mp aw mq bi"><span id="5b3c" class="mr la in mf b gy ms mt l mu mv">try {<br/>    ObjectMapper objectMapper = new ObjectMapper();<br/>    studentDetails = objectMapper.<br/>        readValue(studentJson,  Student.class);<br/>} catch (JsonProcessingException e) {<br/>    return null;<br/>}</span></pre><p id="f166" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="mj">有各种</em> <strong class="jm io"> <em class="mj">禅师注解</em> </strong> <em class="mj">也有助于我们在</em> <strong class="jm io"> <em class="mj">序列化</em> </strong> <em class="mj">和</em> <strong class="jm io"> <em class="mj">反序列化</em> </strong> <em class="mj">的过程。我在这篇</em><strong class="jm io"><em class="mj"/></strong><a class="ae ky" href="https://medium.com/dev-genius/three-jackson-annotations-which-all-spring-boot-developers-should-know-1b6304dda19" rel="noopener"><strong class="jm io"><em class="mj">文章</em> </strong> </a> <em class="mj">中已经涵盖了重要的。</em></p></div><div class="ab cl nw nx hr ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="ig ih ii ij ik"><p id="db5b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果您有兴趣了解更多，请查看这些文章。</p><ol class=""><li id="9022" class="ni nj in jm b jn jo jr js jv nk jz nl kd nm kh nn no np nq bi translated"><a class="ae ky" href="https://www.baeldung.com/java-serialization" rel="noopener ugc nofollow" target="_blank">https://www.baeldung.com/java-serialization</a></li><li id="3cfd" class="ni nj in jm b jn nr jr ns jv nt jz nu kd nv kh nn no np nq bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Serialization" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Serialization</a></li><li id="9e2a" class="ni nj in jm b jn nr jr ns jv nt jz nu kd nv kh nn no np nq bi translated"><a class="ae ky" href="https://www.endpointdev.com/blog/2020/03/serialization-issues-spring-rest/" rel="noopener ugc nofollow" target="_blank">https://www . endpoint dev . com/blog/2020/03/序列化-问题-spring-rest/ </a></li><li id="de49" class="ni nj in jm b jn nr jr ns jv nt jz nu kd nv kh nn no np nq bi translated"><a class="ae ky" href="https://www.javaguides.net/2018/06/guide-to-serialization-in-java.html" rel="noopener ugc nofollow" target="_blank">https://www . javaguides . net/2018/06/guide-to-serialization-in-Java . html</a></li><li id="2b43" class="ni nj in jm b jn nr jr ns jv nt jz nu kd nv kh nn no np nq bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/three-jackson-annotations-which-all-spring-boot-developers-should-know-1b6304dda19">https://blog . dev genius . io/three-Jackson-annotations-which-all-spring-boot-developers-should-know-1b 6304 DDA 19</a></li></ol></div></div>    
</body>
</html>