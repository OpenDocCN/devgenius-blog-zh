<html>
<head>
<title>Coding Interview Question — Median of Two Sorted Arrays</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编码面试问题—两个排序数组的中间值</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/coding-interview-question-median-of-two-sorted-arrays-3fbff60fed34?source=collection_archive---------9-----------------------#2022-09-24">https://blog.devgenius.io/coding-interview-question-median-of-two-sorted-arrays-3fbff60fed34?source=collection_archive---------9-----------------------#2022-09-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="ccc3" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">软件工程之旅</h2><div class=""/><div class=""><h2 id="7c4e" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">软件工程师面试问题</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/faab6866490c0d233fb2b7bc196d67f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cwJgbpFOJ32YTfZY"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">照片由来自 unsplash.com 的克里斯里德拍摄</figcaption></figure><h1 id="efe9" class="lf lg iq bd lh li lj lk ll lm ln lo lp kf lq kg lr ki ls kj lt kl lu km lv lw bi translated">概观</h1><p id="afe8" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">让我们在我们的系列文章中继续解决问题。我们将在本文中解决“两个有序数组的中值”问题。这篇文章会更复杂，因为难度很大，但我会尽我所能向你解释清楚这个问题。</p><h1 id="5be4" class="lf lg iq bd lh li lj lk ll lm ln lo lp kf lq kg lr ki ls kj lt kl lu km lv lw bi translated">问题</h1><p id="3882" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated"><strong class="lz ja">难度:</strong>难</p><p id="5e6f" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">给定两个大小分别为 m 和 n 的排序数组 nums 1 和 nums 2，返回两个排序数组的中间值。</p><p id="ed5f" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">总的运行时间复杂度应该是 O(log (m+n))。</p><h1 id="a6bb" class="lf lg iq bd lh li lj lk ll lm ln lo lp kf lq kg lr ki ls kj lt kl lu km lv lw bi translated">例子</h1><h2 id="2c45" class="my lg iq bd lh mz na dn ll nb nc dp lp mg nd ne lr mk nf ng lt mo nh ni lv iw bi translated">示例 1:</h2><p id="8021" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated"><strong class="lz ja">输入:</strong> nums1 = [1，3]，nums2 = [2]</p><p id="43e8" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated"><strong class="lz ja">输出:</strong> 2.00000</p><p id="4d28" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated"><strong class="lz ja">说明:</strong>合并数组= [1，2，3]且中位数为 2。</p><h2 id="958b" class="my lg iq bd lh mz na dn ll nb nc dp lp mg nd ne lr mk nf ng lt mo nh ni lv iw bi translated">示例 2:</h2><p id="a7f7" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated"><strong class="lz ja">输入:</strong> nums1 = [1，2]，nums2 = [3，4]</p><p id="7b2a" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated"><strong class="lz ja">输出:</strong> 2.50000</p><p id="426f" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated"><strong class="lz ja">说明:</strong>合并数组= [1，2，3，4]，中位数为(2 + 3) / 2 = 2.5。</p><h1 id="8fb8" class="lf lg iq bd lh li lj lk ll lm ln lo lp kf lq kg lr ki ls kj lt kl lu km lv lw bi translated">限制</h1><p id="8f04" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">nums1.length == m</p><p id="e82c" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">nums2.length == n</p><p id="da09" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">0 &lt;= m &lt;= 1000</p><p id="2ffc" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">· 0 &lt;= n &lt;= 1000</p><p id="05a3" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">· 1 &lt;= m + n &lt;= 2000</p><p id="e787" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">· -106 &lt;= nums1[i], nums2[i] &lt;= 106</p><h1 id="3967" class="lf lg iq bd lh li lj lk ll lm ln lo lp kf lq kg lr ki ls kj lt kl lu km lv lw bi translated">Analyze</h1><p id="2837" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">- There is no special mentions in the description of our problem, therefore I think we need to care about some special cases below:</p><p id="51b6" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">o Both <strong class="lz ja"> nums1 </strong>和<strong class="lz ja"> nums2 </strong>为空</p><p id="2916" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">o 两个输入之一为<strong class="lz ja"> nums1 </strong>或<strong class="lz ja"> nums2 </strong>空</p><p id="fed9" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">-看看例 1 和例 2 我们可以看到，我们需要处理的数组中的数据从来没有接触到合并数组的末尾(除了两个输入数组都只有一两个值)。因此，我们不需要遍历数组的所有元素来获得结果。</p><p id="13fd" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">有了上面的分析，我就可以得到处理问题的解决方案了。让我们看一下求解部分，看看我是如何求解的。</p><h1 id="a701" class="lf lg iq bd lh li lj lk ll lm ln lo lp kf lq kg lr ki ls kj lt kl lu km lv lw bi translated">解决</h1><p id="c9b5" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated"><strong class="lz ja">解决方案 1:组合数组并获得中间值</strong></p><p id="ab39" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">在这个解决方案中，我们使用了一种随意的方式来解决这个问题，它只是组合两个排序的数组，并获得中间值来计算中值。以下是我们应该如何做的步骤。</p><p id="0778" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated"><em class="nj">使用输入 nums1 和 nums2: </em></p><ol class=""><li id="5ed8" class="nk nl iq lz b ma mt md mu mg nm mk nn mo no ms np nq nr ns bi translated"><em class="nj">创建第三个数组来组合 nums1 和 nums2 数组的值。</em></li><li id="38e2" class="nk nl iq lz b ma nt md nu mg nv mk nw mo nx ms np nq nr ns bi translated"><em class="nj">做一段时间，直到数组 nums1 或数组 nums2 出值。</em></li><li id="b12c" class="nk nl iq lz b ma nt md nu mg nv mk nw mo nx ms np nq nr ns bi translated"><em class="nj">比较两个数组的值，将较小的一个加到第三个数组，然后增加提供该值的数组的索引。</em></li><li id="0115" class="nk nl iq lz b ma nt md nu mg nv mk nw mo nx ms np nq nr ns bi translated"><em class="nj">while 循环结束时。将剩余数组的所有值添加到第三个数组中。</em></li><li id="3dda" class="nk nl iq lz b ma nt md nu mg nv mk nw mo nx ms np nq nr ns bi translated"><em class="nj">检查数组的大小。如果计算两个中间值的中间值，否则只取中间值，这就是我们想要的结果。</em></li></ol><p id="6d6e" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">我们提供了 java 和 python 两种版本的解决方案代码，您可以参考如下:</p><p id="8bbe" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">MedianOfTwoSortedArraysSolution1.java<strong class="lz ja"/></p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="dd20" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated"><strong class="lz ja">medianoftwosortedarraysolution 1 . py</strong></p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="021c" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">时间复杂度:O(m+n)</p><p id="b2bd" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated"><strong class="lz ja">解决方案 2:转到中间并获取值</strong></p><p id="3df3" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">当我们实现解决方案 1 时，它对我们来说更容易。然而，时间复杂度为 O(m+n)时，这可能不是一个好的选择。因此，在这个解决方案中，我将为您提供一个更好的解决方案。它可能会帮助我们将这个问题的时间复杂度减半。让我们看看解决方案将如何实施。</p><p id="9d75" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated"><em class="nj">使用输入 nums1 和 nums2: </em></p><ol class=""><li id="07ab" class="nk nl iq lz b ma mt md mu mg nm mk nn mo no ms np nq nr ns bi translated"><em class="nj">检查两个数组是否都为空，然后返回 0，否则进入下一步。</em></li></ol><p id="1546" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated"><em class="nj"> 2。获取两个输入数组的中间大小。</em></p><p id="a36c" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated"><em class="nj">例如:nums1 = [0，3，5]，nums2[4，6，9，11] </em></p><p id="efc5" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated"><em class="nj">中间尺寸为:(3 + 4 + 1 )/2 = 4 </em></p><p id="5861" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated"><em class="nj"> 3。从 0 到中等大小值执行 for 循环。比较每个数组的小值，得到并增加索引，直到循环到达中间值。立刻，我们有了第一个中间值。</em></p><p id="d58c" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated"><em class="nj"> 4。如果两个数组的总长度是偶数，那么再次比较两个数组的下一个值，得到。计算两个中间值的中间值，我们将得到最终结果。否则，步骤 3 中的值就是最终结果。</em></p><p id="8260" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">让我们参考代码，以便更清楚地了解它的求解方式。</p><p id="069d" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated"><strong class="lz ja">MedianOfTwoSortedArraysSolution1.java</strong></p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="554d" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated"><strong class="lz ja">medianoftwosortedarraysolution 1 . py</strong></p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="3d8d" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">时间复杂度:O(log(m+n))</p><p id="3d94" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">我们经历了两个解决方案来解决这个问题，对于第一个，我们只是应用了一个正常的方法来使它成为一个逻辑，对于第二个，我们考虑如何使它更快。如果您想看看它是如何处理测试数据的，您可以使用下面的主要代码:</p><p id="98e0" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated"><strong class="lz ja"> Java </strong></p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="58a3" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated"><strong class="lz ja"> Python </strong></p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ny nz l"/></div></figure><h1 id="40d5" class="lf lg iq bd lh li lj lk ll lm ln lo lp kf lq kg lr ki ls kj lt kl lu km lv lw bi translated">结论</h1><p id="e736" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">一旦你读完这篇文章，我想你会对数组有更清楚的了解，并在数组中处理数据。有时我们不需要循环数组的所有元素来解决问题，这就是我在解决这个问题时得到的结果。如果有比这个解决方案更好的想法，希望大家分享。我会为你提供越来越多的关于解决问题的文章，如果你有任何想解决的问题，你可以联系我们，我们可以一起解决。希望你喜欢这篇文章，谢谢！</p><h1 id="79a0" class="lf lg iq bd lh li lj lk ll lm ln lo lp kf lq kg lr ki ls kj lt kl lu km lv lw bi translated">参考</h1><p id="4496" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">本文问题来自<a class="ae le" href="https://leetcode.com/problems/median-of-two-sorted-arrays/" rel="noopener ugc nofollow" target="_blank"> Leetcode </a>。</p></div></div>    
</body>
</html>