<html>
<head>
<title>Stop Using Return Values and Use Classes Instead</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">停止使用返回值，改用类</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/stop-using-return-values-use-classes-instead-28b82d68c913?source=collection_archive---------12-----------------------#2022-04-01">https://blog.devgenius.io/stop-using-return-values-use-classes-instead-28b82d68c913?source=collection_archive---------12-----------------------#2022-04-01</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="dff4" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">如何(不)在 OOP 中接吻。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/102676362c9c4ef0baada96efc18f307.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y0bj91TubhPQqF5SmIwiNA.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">轻量级模式的 Eclipse Java IDE 才是最好的！</figcaption></figure><p id="1a63" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi lo translated">我经常遇到程序员同事(自称“软件工程师”，你能相信吗？)，他们没有最大程度地使用自己选择的编程语言。让我告诉你，我的意思是:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="bbf1" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">然后他们像这样调用函数:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="0087" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">正如所料，输出如下所示:</p><pre class="kd ke kf kg gt lz ma mb mc aw md bi"><span id="e367" class="me mf in ma b gy mg mh l mi mj">6 + 2 = 8<br/>6 - 2 = 4<br/>6 * 2 = 12<br/>6 / 2 = 3</span></pre><p id="baca" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">现在，乍一看，这似乎是实现这些功能的完美有效的方法，其性能可能与生产中编写这种代码的人的大脑一样流畅。但实际上，这是最糟糕的写作方式。所以我们开始重构吧。</p><h2 id="803c" class="me mf in bd mk ml mm dn mn mo mp dp mq lb mr ms mt lf mu mv mw lj mx my mz na bi translated">改进 1:消除膨胀</h2><p id="ed26" class="pw-post-body-paragraph ks kt in ku b kv nb jo kx ky nc jr la lb nd ld le lf ne lh li lj nf ll lm ln ig bi translated">对于这个小功能来说，上面的例子太长了。这是因为文档注释。在这种情况下，我们可以删除它们，因为代码已经非常简单明了。</p><p id="4e22" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">之后，为了弥补文档的不足，我们可能还想简化参数列表，这样我们就不需要每次调用函数时都写<code class="fe ng nh ni ma b">6</code>和<code class="fe ng nh ni ma b">2</code>。我们可以通过将数字移入类变量来实现这一点，如下所示:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="7197" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">使用这些函数即使不简单，也一样简单:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lx ly l"/></div></figure><h2 id="1c18" class="me mf in bd mk ml mm dn mn mo mp dp mq lb mr ms mt lf mu mv mw lj mx my mz na bi translated">改进 2:缓存结果并减少返回</h2><p id="2b4f" class="pw-post-body-paragraph ks kt in ku b kv nb jo kx ky nc jr la lb nd ld le lf ne lh li lj nf ll lm ln ig bi translated">还记得你计算器上的<code class="fe ng nh ni ma b">Ans</code>吗？是的，那个:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nj"><img src="../Images/e7b643f2b821bba8f24b92af6cc62ef6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EdgRsqT7PGO5UG-i14KyMw.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">这是我的钥匙</figcaption></figure><p id="331b" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">猜猜当你按下它时会发生什么。它是否重做最后一次计算来得到结果？不，它保存了上次计算的结果，并使用保存的值。在我们的例子中，我们也可以通过将结果保存到一个全局变量来做类似的事情。为了保持一致，我们也去掉函数的返回值，这样我们总是以同样简单的方式访问计算结果:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lx ly l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">现在有了缓存的结果</figcaption></figure><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lx ly l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">如何访问结果</figcaption></figure><h2 id="03fe" class="me mf in bd mk ml mm dn mn mo mp dp mq lb mr ms mt lf mu mv mw lj mx my mz na bi translated">改进 3:隔离内部状态</h2><p id="0bd2" class="pw-post-body-paragraph ks kt in ku b kv nb jo kx ky nc jr la lb nd ld le lf ne lh li lj nf ll lm ln ig bi translated">这些优化工作得很好，但是我们已经向我们的<code class="fe ng nh ni ma b">Arithmetic</code>类引入了内部状态，并且我们一次只能存储一组参数。因为我们使用 Java，一种面向对象的编程语言，我们可以改变我们的方法，不要成为<code class="fe ng nh ni ma b">static</code>。当我们这样做时，我们还应该将<code class="fe ng nh ni ma b">RESULT</code>变量改为 private，并通过 getter 访问它，这样我们就不会意外地从外部更改它:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lx ly l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">嘿，看，这是一个构造函数！</figcaption></figure><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lx ly l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">使用算术的实例</figcaption></figure><h2 id="816e" class="me mf in bd mk ml mm dn mn mo mp dp mq lb mr ms mt lf mu mv mw lj mx my mz na bi translated">改进 4:每个计算一个实例</h2><p id="90b4" class="pw-post-body-paragraph ks kt in ku b kv nb jo kx ky nc jr la lb nd ld le lf ne lh li lj nf ll lm ln ig bi translated">但是，如果您不知道最近执行了哪个操作，那么重用结果仍然是危险的。我们可以为此使用<code class="fe ng nh ni ma b">enum</code> s，并将一个操作绑定到<code class="fe ng nh ni ma b">Algorithm</code>的一个实例，并重用和存储多个计算:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lx ly l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">枚举是一个伟大的语言功能！</figcaption></figure><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lx ly l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">这么有用！</figcaption></figure><h2 id="b377" class="me mf in bd mk ml mm dn mn mo mp dp mq lb mr ms mt lf mu mv mw lj mx my mz na bi translated">改进 5:继承</h2><p id="d0cb" class="pw-post-body-paragraph ks kt in ku b kv nb jo kx ky nc jr la lb nd ld le lf ne lh li lj nf ll lm ln ig bi translated">虽然<code class="fe ng nh ni ma b">enum</code> s 非常有用，但我们不应该忘记，每次调用<code class="fe ng nh ni ma b">calculate()</code>时，程序都必须检查您想要执行的操作，这可能会在现代硬件上花费一些时间(我还没有检查过，但无论如何让我们提前优化)。我们可以通过制作<code class="fe ng nh ni ma b">Arithmetic</code> <code class="fe ng nh ni ma b">abstract</code>并在一个独立的类中实现每个算术运算来轻松解决这个问题，继承自<code class="fe ng nh ni ma b">Arithmetic</code>。这样，我们将来也可以很容易地扩展算术运算的范围。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lx ly l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">需要更多的构造者！</figcaption></figure><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lx ly l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">如何使用它</figcaption></figure><h2 id="1b51" class="me mf in bd mk ml mm dn mn mo mp dp mq lb mr ms mt lf mu mv mw lj mx my mz na bi translated">改进 6:子类和子实例</h2><p id="6a38" class="pw-post-body-paragraph ks kt in ku b kv nb jo kx ky nc jr la lb nd ld le lf ne lh li lj nf ll lm ln ig bi translated">我们重构后的代码看起来已经很不错了，但是我们实际上又遇到了一个老问题:我们需要为每个实例重新编写<code class="fe ng nh ni ma b">6</code>和<code class="fe ng nh ni ma b">2</code>。如果一组<code class="fe ng nh ni ma b">Arithmetic</code>的实例可以共享这些值并将其用于不同的操作，这不是很好吗？事实上，我们可以通过从类的定义中移除<code class="fe ng nh ni ma b">static</code>并让它们实现一个接口(在本例中为<code class="fe ng nh ni ma b">Calculation </code>)来实现。以下是方法:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lx ly l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">这点燃了欢乐的火花。</figcaption></figure><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lx ly l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">如此漂亮整洁！比以前好多了！</figcaption></figure><p id="e9e7" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">我们完事了。这是我能想到的最好的代码版本。</p><h1 id="5993" class="nk mf in bd mk nl nm nn mn no np nq mq jt nr ju mt jw ns jx mw jz nt ka mz nu bi translated">结论</h1><p id="2202" class="pw-post-body-paragraph ks kt in ku b kv nb jo kx ky nc jr la lb nd ld le lf ne lh li lj nf ll lm ln ig bi translated">优化可能是一个漫长而复杂的过程，但这是值得努力的。当其他人看到你重构和简化的代码时，他们一定会认出你是天才。</p><p id="abf2" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">在这篇文章中，我只展示了一些秘密技术，程序员(哈哈)用这些技术来保住他们的工作，并花更多的时间呆在他们经理的办公室里。你有什么建议，如何进一步改进上面的例子或者知道更多这些技巧吗？如果你喜欢这篇文章，请在下面评论并留下你的掌声。</p><p id="aac2" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><strong class="ku io"> <em class="nv">愚人节快乐！</em>T19】</strong></p></div></div>    
</body>
</html>