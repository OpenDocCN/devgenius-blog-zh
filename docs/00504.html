<html>
<head>
<title>How to implement Offline Mode in an Online-First React Native app: Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在在线优先的本地应用程序中实现离线模式:第2部分</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-to-implement-offline-mode-in-an-online-first-react-native-app-part-2-f0c5abc03900?source=collection_archive---------8-----------------------#2020-06-09">https://blog.devgenius.io/how-to-implement-offline-mode-in-an-online-first-react-native-app-part-2-f0c5abc03900?source=collection_archive---------8-----------------------#2020-06-09</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/155e4e5ac9f2a7a6eaa8c96785e52060.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Scli7GCWnGmBWCXSNS1Apg.jpeg"/></div></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk translated">Johannes Plenio 在<a class="ae ja" href="https://unsplash.com/s/photos/sail-storm?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><div class=""/><p id="0bc8" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><a class="ae ja" href="https://medium.com/dev-genius/how-to-implement-offline-mode-in-an-online-first-react-native-app-a28a1f1d9c07" rel="noopener">在前一部分</a>中，我们已经开始探索如何升级我们现有的项目，以应对不利的网络条件。我们已经学会了如何利用现有的库，比如<code class="fe ky kz la lb b"><a class="ae ja" href="https://github.com/rgommezz/react-native-offline" rel="noopener ugc nofollow" target="_blank">react-native-offline</a></code>，通过了解当前的网络状态来增强我们的组件。今天我们将学习如何实现第二个需求:<strong class="kc je">推迟对服务器的请求，直到我们重新获得连接</strong>。</p></div><div class="ab cl lc ld hr le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ig ih ii ij ik"><h1 id="1415" class="lj lk jd bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">不要忘记我！</h1><p id="1898" class="pw-post-body-paragraph ka kb jd kc b kd mh kf kg kh mi kj kk kl mj kn ko kp mk kr ks kt ml kv kw kx ig bi translated">如果您遵循了前一部分中描述的步骤，现在您应该在redux状态中有一个名为<code class="fe ky kz la lb b">network</code>的有用分支，其结构如下。</p><figure class="mm mn mo mp gt ip"><div class="bz fp l di"><div class="mq mr l"/></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk translated">摘自` react-native-offline` <a class="ae ja" href="https://github.com/rgommezz/react-native-offline#state" rel="noopener ugc nofollow" target="_blank">自述</a>。</figcaption></figure><p id="7d1c" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您会注意到一个代表<code class="fe ky kz la lb b">Array&lt;*&gt;</code>的<code class="fe ky kz la lb b">actionQueue</code>元素。嗯，我的朋友，这个<code class="fe ky kz la lb b">actionQueue</code>是开启你的应用程序离线潜力的强大钥匙！</p></div><div class="ab cl lc ld hr le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ig ih ii ij ik"><p id="0ecb" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe ky kz la lb b">actionQueue</code>做的是在app离线的时候，持有已经被<code class="fe ky kz la lb b">react-native-offline</code>中间件拦截的<code class="fe ky kz la lb b">actions</code>和<code class="fe ky kz la lb b">thunks</code>。一旦连接恢复，同一个中间件将负责清空队列并重新分发内容。</p><p id="27d0" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这意味着，如果您正在调度<code class="fe ky kz la lb b">actions</code>或<code class="fe ky kz la lb b">thunks</code>来触发对API的调用，那么在离线时拦截它们并以更好的连接性再次发送它们是非常容易的。让我们看看它是怎么做的！</p></div><div class="ab cl lc ld hr le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ig ih ii ij ik"><p id="724e" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">首先，我们需要向我们的商店添加<code class="fe ky kz la lb b">react-native-offline</code>中间件。请注意，<code class="fe ky kz la lb b">createNetworkMiddleware</code> <strong class="kc je">应该是链中第一个正常工作的中间件</strong>。</p><figure class="mm mn mo mp gt ip"><div class="bz fp l di"><div class="mq mr l"/></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk translated">来自` react-native-offline` <a class="ae ja" href="https://github.com/rgommezz/react-native-offline#usage-3" rel="noopener ugc nofollow" target="_blank">自述</a>。</figcaption></figure><p id="d3d4" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe ky kz la lb b">createNetworkMiddleware</code>函数具有以下签名。</p><figure class="mm mn mo mp gt ip"><div class="bz fp l di"><div class="mq mr l"/></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk translated">来自` react-native-offline` <a class="ae ja" href="https://github.com/rgommezz/react-native-offline#createnetworkmiddleware" rel="noopener ugc nofollow" target="_blank">自述</a>。</figcaption></figure><p id="c997" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">根据<a class="ae ja" href="https://github.com/rgommezz/react-native-offline#usage-3" rel="noopener ugc nofollow" target="_blank">文档</a>，这个中间件的默认行为是拦截所有遵循Redux的<a class="ae ja" href="https://redux.js.org/advanced/async-actions" rel="noopener ugc nofollow" target="_blank">约定</a>的异步动作，这意味着它会捕捉所有类似<code class="fe ky kz la lb b">FETCH_USER_ID_REQUEST</code>的动作。默认行为将阻止动作被发送，而是发送一个<code class="fe ky kz la lb b">@@network-connectivity/FETCH_OFFLINE_MODE</code>，我们可以在我们的缩减器中拦截它。</p><figure class="mm mn mo mp gt ip"><div class="bz fp l di"><div class="mq mr l"/></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk translated">来自` react-native-offline` <a class="ae ja" href="https://github.com/rgommezz/react-native-offline#usage-3" rel="noopener ugc nofollow" target="_blank">自述</a>。</figcaption></figure><p id="3c58" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">请注意，这只<em class="ms">阻止</em>我们的<code class="fe ky kz la lb b">FETCH</code>动作被发送，并发送一个<em class="ms">替代动作</em>。虽然有用，但我们想做的是<em class="ms">推迟</em>动作，并在连接恢复时再次发送。幸运的是，按照下面的结构，我们可以通过向想要推迟的动作添加一个<code class="fe ky kz la lb b">meta</code>字段来轻松做到这一点。</p><figure class="mm mn mo mp gt ip"><div class="bz fp l di"><div class="mq mr l"/></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk translated">来自` react-native-offline` <a class="ae ja" href="https://github.com/rgommezz/react-native-offline#plain-objects" rel="noopener ugc nofollow" target="_blank">自述</a>。</figcaption></figure></div><div class="ab cl lc ld hr le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ig ih ii ij ik"><p id="15de" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所以，假设我们有一个<code class="fe ky kz la lb b">FETCH_USER_SELECTED_PRODUCT_REQUEST</code>动作，它将触发一个<code class="fe ky kz la lb b">saga</code>。saga会告诉我们的服务器用户已经选择了一个新产品。如果我们离线，不要让呼叫失败，我们可以标记<code class="fe ky kz la lb b">FETCH_USER_SELECTED_PRODUCT_REQUEST</code>在离线时被拦截，因此推迟触发传奇直到我们重新上线。</p><figure class="mm mn mo mp gt ip"><div class="bz fp l di"><div class="mq mr l"/></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk translated">我们的行动被拦截</figcaption></figure><p id="2bc8" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后我们可以在我们的reducer中监听<code class="fe ky kz la lb b">@@network-connectivity/FETCH_OFFLINE_MODE</code>，让我们的用户知道他的选择已经被记录下来，一旦连接可用，就会被上传到我们的服务器。</p><figure class="mm mn mo mp gt ip"><div class="bz fp l di"><div class="mq mr l"/></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk translated">我们的“产品”行动减速器。</figcaption></figure><p id="70db" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们完了！我们的应用程序现在将能够在离线时拦截动作，在线时重新调度它们，并让用户了解当前的连接状态。</p></div></div>    
</body>
</html>