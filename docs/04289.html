<html>
<head>
<title>Dependency Injection 101</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">依赖注入 101</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/dependency-injection-101-a56cb6ef639a?source=collection_archive---------4-----------------------#2021-02-21">https://blog.devgenius.io/dependency-injection-101-a56cb6ef639a?source=collection_archive---------4-----------------------#2021-02-21</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/dabbd5a52db40eefcbb1a3383072e4f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KQ9V7lsyP1C8Wjsww-Pvxg.jpeg"/></div></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk translated"><a class="ae ja" href="https://unsplash.com/@markusspiske" rel="noopener ugc nofollow" target="_blank">图片致谢名单</a></figcaption></figure><div class=""/><div class=""><h2 id="3961" class="pw-subtitle-paragraph ka jc jd bd b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dk translated">框架的核心。</h2></div><blockquote class="ks kt ku"><p id="776c" class="kv kw kx ky b kz la ke lb lc ld kh le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">“依赖注入是一种使类独立于其依赖项的编程技术。它通过将对象的使用与创建分离来实现这一点。’—<a class="ae ja" href="https://stackify.com/dependency-injection/" rel="noopener ugc nofollow" target="_blank">设计模式讲解</a></p></blockquote><p id="ebf7" class="pw-post-body-paragraph kv kw jd ky b kz la ke lb lc ld kh le ls lg lh li lt lk ll lm lu lo lp lq lr ig bi translated">这是最受推崇的设计模式之一，也是许多框架(如 Spring 和 ASP.NET 核心)的基本方面之一。虽然已经有很多资源在讨论如何用特定的语言实现依赖注入，以及有哪些不同的方法，但是这篇文章将试图把重点放在非依赖注入世界(我曾经面对过)固有的一些问题上，以便更好地理解为什么框架吹嘘自己有现成的解决方案。</p><h1 id="7d1e" class="lv lw jd bd lx ly lz ma mb mc md me mf kj mg kk mh km mi kn mj kp mk kq ml mm bi translated">易测性</h1><p id="ee13" class="pw-post-body-paragraph kv kw jd ky b kz mn ke lb lc mo kh le ls mp lh li lt mq ll lm lu mr lp lq lr ig bi translated">测试是任何软件项目的关键。为了验证和确认我们系统的功能，我们努力编写可测试的代码。</p><p id="e9b8" class="pw-post-body-paragraph kv kw jd ky b kz la ke lb lc ld kh le ls lg lh li lt lk ll lm lu lo lp lq lr ig bi translated">为了测试任何给定的功能，我们模拟它的依赖关系，以便它可以被“单元”测试。然而，当我们使用<em class="kx">新的</em>操作符创建一个对象时，我们不再有能力模仿它，因此函数变得不可测试，或者你依赖<a class="ae ja" href="https://stackoverflow.com/questions/5920153/test-class-with-a-new-call-in-it-with-mockito/5920394#5920394" rel="noopener ugc nofollow" target="_blank">黑客</a>。</p><blockquote class="ks kt ku"><p id="07a5" class="kv kw kx ky b kz la ke lb lc ld kh le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">注意:移动对象创建可以转移到一些工厂和模仿将工作。但是，这仍然是一项工作，同样的工作必须在所有地方重复，以实现我们代码的真正可测试性，这违反了 DRY(不要重复自己)原则。</p></blockquote><h1 id="cf46" class="lv lw jd bd lx ly lz ma mb mc md me mf kj mg kk mh km mi kn mj kp mk kq ml mm bi translated">单一责任原则</h1><blockquote class="ks kt ku"><p id="f450" class="kv kw kx ky b kz la ke lb lc ld kh le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">"一个类应该有且只有一个改变的理由."</p></blockquote><p id="b093" class="pw-post-body-paragraph kv kw jd ky b kz la ke lb lc ld kh le ls lg lh li lt lk ll lm lu lo lp lq lr ig bi translated">一个类应该有单一的责任。依赖关系的实例化只是应该避免的额外责任。</p><p id="d867" class="pw-post-body-paragraph kv kw jd ky b kz la ke lb lc ld kh le ls lg lh li lt lk ll lm lu lo lp lq lr ig bi translated">这一开始似乎没什么大不了的。但是当一个类专注于一个单一的职责时，它使得代码更容易理解和维护。</p><h1 id="95c4" class="lv lw jd bd lx ly lz ma mb mc md me mf kj mg kk mh km mi kn mj kp mk kq ml mm bi translated">搬运生命周期</h1><p id="e640" class="pw-post-body-paragraph kv kw jd ky b kz mn ke lb lc mo kh le ls mp lh li lt mq ll lm lu mr lp lq lr ig bi translated">框架为我们提供了处理这些依赖关系的生命周期的现成功能。您可以请求一个<strong class="ky je">单例</strong>、<strong class="ky je">瞬态</strong>或<strong class="ky je">作用域</strong>实例，这种配置对象生命周期的能力使我们能够更好地控制我们的需求，并有助于节省内存使用(通过不在每次请求时创建新对象)。创建对象的开销可能很大，对于数百万个请求，一个对象对一百万个对象会对内存消耗产生重大影响。</p><p id="579d" class="pw-post-body-paragraph kv kw jd ky b kz la ke lb lc ld kh le ls lg lh li lt lk ll lm lu lo lp lq lr ig bi translated">当您使用<em class="kx"> new </em>操作符实例化一个依赖项时，您就立刻失去了这种优势。</p><h1 id="bf96" class="lv lw jd bd lx ly lz ma mb mc md me mf kj mg kk mh km mi kn mj kp mk kq ml mm bi translated">结论</h1><p id="7047" class="pw-post-body-paragraph kv kw jd ky b kz mn ke lb lc mo kh le ls mp lh li lt mq ll lm lu mr lp lq lr ig bi translated">依赖注入背后的意图是实现对象构造和使用的<a class="ae ja" href="https://en.wikipedia.org/wiki/Separation_of_concerns" rel="noopener ugc nofollow" target="_blank">关注点分离</a>。这是一个简单却难以置信的概念，它提高了可测试性、可读性和可重用性。</p><h1 id="b20e" class="lv lw jd bd lx ly lz ma mb mc md me mf kj mg kk mh km mi kn mj kp mk kq ml mm bi translated">参考</h1><ul class=""><li id="96d4" class="ms mt jd ky b kz mn lc mo ls mu lt mv lu mw lr mx my mz na bi translated"><a class="ae ja" href="https://en.wikipedia.org/wiki/Dependency_injection#Advantages" rel="noopener ugc nofollow" target="_blank">依赖注入—维基百科</a></li><li id="e6d8" class="ms mt jd ky b kz nb lc nc ls nd lt ne lu nf lr mx my mz na bi translated"><a class="ae ja" href="https://stackify.com/dependency-injection/" rel="noopener ugc nofollow" target="_blank">解释设计模式——代码示例依赖注入</a></li></ul></div></div>    
</body>
</html>