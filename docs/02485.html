<html>
<head>
<title>Road to Genius: superior #51</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">天才之路:优越#51</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/road-to-genius-superior-51-4ffddae38127?source=collection_archive---------18-----------------------#2020-08-06">https://blog.devgenius.io/road-to-genius-superior-51-4ffddae38127?source=collection_archive---------18-----------------------#2020-08-06</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/813d3812b45661433b0268075903f500.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*PAZU2yGX4cl596rM.png"/></div></div></figure><p id="1218" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">每天我都要解决几个Codr分级模式的编码挑战和难题。目标是达到天才的等级，在这个过程中我解释了我是如何解决这些问题的。你不需要任何编程背景就可以开始，而且你会学到很多新的有趣的东西。</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="2af8" class="lc ld in ky b gy le lf l lg lh">function backtrack(list, tempList, nums, start) {<br/>    list.push([...tempList]);<br/>    for(let i = start; i &lt; nums.length; i++) {<br/>        tempList.push(nums[i]);<br/>        backtrack(list, tempList, nums, i + 1);<br/>        tempList.pop();<br/>    }<br/>}</span><span id="1933" class="lc ld in ky b gy li lf l lg lh">function subsets(nums) {<br/>    const list = [];<br/>    backtrack(list, [], nums, 0);<br/>    return list;<br/>}</span><span id="43a0" class="lc ld in ky b gy li lf l lg lh">let A = subsets([1, 2, 1]);<br/>A = A.length</span><span id="fca1" class="lc ld in ky b gy li lf l lg lh">// A = ? (number)</span></pre><p id="bd8c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在今天的挑战中，我们必须处理递归回溯。调用函数<code class="fe lj lk ll ky b">subsets</code>揭示了代码的本质，它将从给定的输入中创建不同子集的列表。在这种情况下，子集类似于唯一组合，只是它们不需要唯一。</p><figure class="kt ku kv kw gt jo gh gi paragraph-image"><div class="gh gi lm"><img src="../Images/c5cbf27c663a4a0b21e6e1253be20349.png" data-original-src="https://miro.medium.com/v2/resize:fit:410/format:webp/0*o3fJD4K8to1vwBQ8.png"/></div></figure><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="fdc1" class="lc ld in ky b gy le lf l lg lh">For input: [1, 2, 1]<br/>We expect the following subsets:<br/>1<br/>1 2<br/>1 2 1<br/>1 1<br/>2<br/>2 1<br/>1</span></pre><p id="0008" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">可能有8个子集，因此答案应该是这样的:</p><figure class="kt ku kv kw gt jo gh gi paragraph-image"><div class="gh gi ln"><img src="../Images/14ca78f76d0a933cf4edeea08bff881f.png" data-original-src="https://miro.medium.com/v2/resize:fit:456/format:webp/0*fQJFOGJ4He_pI98k.png"/></div></figure><p id="05ac" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你在纸上算出这个问题，你会找到这些精确的子集。</p><p id="050a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">通过解决这些挑战，你可以训练自己成为一名更好的程序员。您将学到更新更好的分析、调试和改进代码的方法。因此，你在商业上会更有效率和价值。今天就在<a class="ae lo" href="https://nevolin.be/codr/" rel="noopener ugc nofollow" target="_blank">https://nevolin.be/codr/</a>开始行动并成为认证Codr</p></div></div>    
</body>
</html>