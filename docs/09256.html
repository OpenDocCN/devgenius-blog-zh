<html>
<head>
<title>Garbage Collection: The Unsung Hero Of Modern Programming Languages</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">垃圾收集:现代编程语言的无名英雄</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/garbage-collection-the-unsung-hero-of-modern-programming-languages-496f79574ea8?source=collection_archive---------12-----------------------#2022-08-09">https://blog.devgenius.io/garbage-collection-the-unsung-hero-of-modern-programming-languages-496f79574ea8?source=collection_archive---------12-----------------------#2022-08-09</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/cb976e6d3ed2d2ac4e61cd9df98ee1f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xavCG4ojF2xVl93B"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">照片由<a class="ae jz" href="https://unsplash.com/@gary_at_unsplash?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">陈嘉里</a>在<a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="6024" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在许多编程语言中，垃圾收集是一个极其重要的部分(并且经常被低估)。它处理对象的空间分配和释放的基本问题，以前这些都是由 dev(咳咳 C)显式完成的。</p><p id="7c98" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在本文中，我们将回顾垃圾识别和删除中使用的一种常见算法，并且我们将讨论垃圾收集过程中的一些关键部分。</p><p id="0b28" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">垃圾收集可以被认为是两个组件，<strong class="kc io">识别</strong>和<strong class="kc io">压缩</strong>，我们可以通过启发式和并发性来优化这两个组件。</p><h2 id="b0d6" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">识别</h2><p id="4db7" class="pw-post-body-paragraph ka kb in kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">大多数垃圾收集识别算法都是基于一种称为三色标记的 DFS 图遍历方式。该算法确定从根节点开始的路径不能到达哪些节点。同时，该算法有一个有用的特性，即如果进程暂停，并且在暂停期间添加了新节点，该算法也可以运行(这允许该算法并发运行，因此在 GC 执行其工作时，您的应用程序不需要暂停)。</p><p id="3108" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">算法</strong></p><ol class=""><li id="252a" class="lw lx in kc b kd ke kh ki kl ly kp lz kt ma kx mb mc md me bi translated">将根节点变为灰色，并将其添加到堆栈中</li><li id="cf86" class="lw lx in kc b kd mf kh mg kl mh kp mi kt mj kx mb mc md me bi translated">从堆栈中弹出顶部节点</li><li id="7187" class="lw lx in kc b kd mf kh mg kl mh kp mi kt mj kx mb mc md me bi translated">将与当前节点直接相邻的所有白色节点添加到队列中，并将它们涂成灰色</li><li id="aa39" class="lw lx in kc b kd mf kh mg kl mh kp mi kt mj kx mb mc md me bi translated">将节点涂成黑色。如果堆栈不为空，转到步骤 2，否则转到步骤 5</li><li id="120e" class="lw lx in kc b kd mf kh mg kl mh kp mi kt mj kx mb mc md me bi translated">移除所有白色节点</li></ol><figure class="ml mm mn mo gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mk"><img src="../Images/b1dad4b7290cd17d61bb3c060538e712.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v8KLTRr8rAFye3chkNE24Q.jpeg"/></div></div></figure><p id="9205" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个垃圾收集算法将对连接到根节点的节点进行 DFS，以获得所有连接的节点(也称为活动对象)。但是我们为什么要给它们上色呢？这就是并发性出现的地方。假设我们已经完全处理了 A，它现在是黑色的，意味着我们将不再处理它，但是如果我们随后从 A 中添加一个新节点(A 有一个对新节点的引用)，那么新节点将被丢弃，因为它将是白色的，没有机会变成灰色。该算法有一个特殊的警告，即你不能从黑色到白色，中间必须总是有灰色。因此，当我们添加这个新节点时，我们会注意到它的父节点是黑色的，并将其颜色设置为灰色(防止删除)。</p><p id="a284" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">下面是一个关于识别和删除如何工作的玩具示例，通过连接、节点数量以及算法的停止和开始来更好地理解这个过程。</p><figure class="ml mm mn mo gt jo"><div class="bz fp l di"><div class="mp mq l"/></div></figure><h2 id="fc72" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">压紧</h2><p id="b572" class="pw-post-body-paragraph ka kb in kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">既然我们已经识别并清除了一些垃圾，我们就需要谈谈压缩。我们需要压缩对象的原因是因为对象在计算机中的存储方式(连续的内存块)。当我们在垃圾收集期间移除未使用的内存时，我们可能会释放空间，但是活动对象的定位不会是最佳的。</p><figure class="ml mm mn mo gt jo gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/6718fb7b7a01b2ab34f309bd068dd13a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1160/format:webp/1*O7iKfGAppNklZoRM4Pvltw.png"/></div></figure><p id="a6eb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">例如，假设我们有 1GB 的内存，我们将 4 张照片加载到内存中(每张 250MB)。</p><ul class=""><li id="08de" class="lw lx in kc b kd ke kh ki kl ly kp lz kt ma kx ms mc md me bi translated">0–250 MB 的照片 1</li><li id="2ad6" class="lw lx in kc b kd mf kh mg kl mh kp mi kt mj kx ms mc md me bi translated">250–500 MB 的照片 2</li><li id="b851" class="lw lx in kc b kd mf kh mg kl mh kp mi kt mj kx ms mc md me bi translated">500–750 MB 的照片 3</li><li id="88b4" class="lw lx in kc b kd mf kh mg kl mh kp mi kt mj kx ms mc md me bi translated">750–1GB 的照片 4</li></ul><p id="3d0d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在假设照片 2 和 4 被标记为垃圾收集，那么我们有 500MB 的空闲存储空间。我们现在有另一张 500MB 的照片，但是我们不能把它放在内存中，因为我们没有 500MB 的连续部分。这就是为什么我们的垃圾收集算法必须在清理后重新组织对象(通常将相似的老化对象分组在一起)。</p><h2 id="40c5" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">最优化:世代假说</h2><p id="1461" class="pw-post-body-paragraph ka kb in kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">垃圾收集最好的启发之一是世代假设(对象的生命周期是双模式的，要么很长，要么很短)。</p><figure class="ml mm mn mo gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mt"><img src="../Images/1aab8daaca18af93867ecfd81134b522.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SqN4TVD1Tcscc3tgvK-ffg.png"/></div></div></figure><p id="6322" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">从直觉上讲，大多数对象要么是长期存在的实例状态变量，要么是在 for 循环或 helper 函数中使用的临时变量。分代假设告诉 use，这些较新的对象具有非常高的死亡率，因此应该更频繁地监视垃圾清理，而较旧的对象可以更偶尔地监视。这样我们可以避免在垃圾识别阶段迭代整个对象图。这也是为什么当我们压缩内存时，对象通常是根据活动时间来分组的。</p><p id="8af9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是许多现代编程语言中垃圾收集工作方式的简要概述。如果你喜欢我的内容，请务必关注我的最新帖子，并查看我的一些旧作品。</p></div></div>    
</body>
</html>