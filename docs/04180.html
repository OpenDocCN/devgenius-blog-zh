<html>
<head>
<title>3 Instances when Java and Python were the same.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">3 个 Java 和 Python 相同的例子。</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/3-instances-when-java-and-python-were-the-same-a504e9e3ca22?source=collection_archive---------5-----------------------#2021-02-05">https://blog.devgenius.io/3-instances-when-java-and-python-were-the-same-a504e9e3ca22?source=collection_archive---------5-----------------------#2021-02-05</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><blockquote class="jk jl jm"><p id="46f1" class="jn jo jp jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ig bi translated"><strong class="jq io"> <em class="in">先说 Java 和 Python 不可区分的 3 个实例和完全不同的 2 个实例。</em>T3】</strong></p></blockquote><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/33fc35dc56343fcaa7c69ebfdb4e3814.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xcQzPXjhOH3NLOVlATuF6Q.png"/></div></div></figure><blockquote class="jk jl jm"><p id="06ed" class="jn jo jp jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ig bi translated"><strong class="jq io"> <em class="in"> 1。</em> </strong>加入方法(相同)</p></blockquote><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi ky"><img src="../Images/c7c4c694ca752a0b368bed5a5837c73b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e6duMiHiJlOxVg8y-DgCcg.png"/></div></div></figure><p id="3206" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kz ka kb kc la ke kf kg lb ki kj kk kl ig bi translated">如果一个线程调用任何其他线程的 join 方法，那么调用方线程必须等待被调用线程完成其执行并终止。例如，这里主线程调用了线程 t1 的 join 方法，然后主线程等待线程 t1 完成它(t1 的)执行。并且在主线程的执行恢复之前，主线程等待 t1 线程被终止和杀死。这个 join 属性在 Java 和 Python 中是相同的。</p><blockquote class="jk jl jm"><p id="c7ba" class="jn jo jp jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ig bi translated"><strong class="jq io"> <em class="in"> 2。本我/自我在继承中的作用(相同)</em> </strong></p></blockquote><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi lc"><img src="../Images/95016e5c7b6e61f7bed7cee43c8e7968.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ouu7Ez0uCmuF9YlYR6eBcQ.png"/></div></div></figure><p id="8ea3" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kz ka kb kc la ke kf kg lb ki kj kk kl ig bi translated">当我们用 Java / Python 中的<strong class="jq io">方法</strong>打印这个/ self 时。打印对象的名称，在其上调用<strong class="jq io">方法</strong>。例如，这里的方法 showName()属于 Zeus 类，但是当我们在方法 showName 中打印 this / self 时。赫拉克勒斯级的名字印出来了。因为方法 showName 由类 Hercules 继承，并在类 Hercules 的对象上调用。这个/自我的这个角色在两种语言中都是一样的。</p><blockquote class="jk jl jm"><p id="ef0b" class="jn jo jp jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ig bi translated"><strong class="jq io"> <em class="in"> 3。每个子类实例变量的唯一副本(相同)</em> </strong></p></blockquote><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi ld"><img src="../Images/8d0999d4cc69a621a04df030d5fcaeaa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-wn4aSWouLq6uvKGWXof0w.png"/></div></div></figure><p id="7397" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kz ka kb kc la ke kf kg lb ki kj kk kl ig bi translated">如果存在超类的子类。以及该子类是否有各种对象。那么子类的所有对象都将得到其父类(超类)实例变量的唯一且独立的副本。例如，这里的父类宙斯有实例变量神话。并且有两个子类 Hercules 的对象 h1 和 h2。所以如果 h1 改变 parent(Zeus’)实例变量神话。这种变化不会反映在 h2 中。因为 h1 和 h2 有不同的继承实例变量神话副本。该属性在两种语言中保持不变。</p></div><div class="ab cl le lf hr lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="ig ih ii ij ik"><blockquote class="jk jl jm"><p id="3ba6" class="jn jo jp jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ig bi translated"><strong class="jq io"> <em class="in"> 1。调用超类构造函数(不同)</em> </strong></p></blockquote><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi ll"><img src="../Images/dc92e246419e603a33fa85dab8e545eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i_k-0GxlUFs12x75GhP3eA.png"/></div></div></figure><p id="5872" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kz ka kb kc la ke kf kg lb ki kj kk kl ig bi translated">在 Java 中，每当我们在任何类中编写构造函数时。默认情况下，构造函数的第一行是对超类的构造函数的调用。这是隐性的，而且一直都在发生。但是在 Python 中，当我们在任何类中编写 init 时，默认情况下不会调用超类的 init。</p><blockquote class="jk jl jm"><p id="f7a3" class="jn jo jp jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ig bi translated"><strong class="jq io">2<em class="in">2。</em>多重继承(不同)</strong></p></blockquote><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi lm"><img src="../Images/013a0cc47d11f2ab7626855a159c42f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ONrxTxlplO4UnEuIweKZeA.png"/></div></div></figure><p id="387c" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kz ka kb kc la ke kf kg lb ki kj kk kl ig bi translated">在 Java 中，不能创建从多个类继承的类。换句话说，java 不支持多重继承。但是 Python 有。在 Java 中要实现多重继承，只有求助于接口。但是在 Python 中，我们可以直接用类实现多重继承。</p></div><div class="ab cl le lf hr lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="ig ih ii ij ik"><blockquote class="jk jl jm"><p id="72db" class="jn jo jp jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ig bi translated"><strong class="jq io"> <em class="in">加成:堆栈溢出(类似)</em> </strong></p></blockquote><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi ln"><img src="../Images/80675a419740cc762d4af56acea96c77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JVDaRr4fyFC4M17HTOmKvw.png"/></div></div></figure><p id="0f22" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kz ka kb kc la ke kf kg lb ki kj kk kl ig bi translated">在 java 中，当我们堆栈的时候，框架会不断地被推到 Java 堆栈上，而不会弹出。换句话说，如果我们不停地调用方法，就会导致堆栈溢出错误。我们可以试着抓住它。类似的事情在 Python 中也会发生，但这被称为递归错误。我们可以试着处理，除了</p></div></div>    
</body>
</html>