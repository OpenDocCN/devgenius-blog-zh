<html>
<head>
<title/>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1/>
<blockquote>原文：<a href="https://blog.devgenius.io/python-customize-sorting-in-several-ways-3961b648d31f?source=collection_archive---------7-----------------------#2020-06-17">https://blog.devgenius.io/python-customize-sorting-in-several-ways-3961b648d31f?source=collection_archive---------7-----------------------#2020-06-17</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div class="gh gi il"><img src="../Images/c4e8959474f30cd3809dd0defe2bc050.png" data-original-src="https://miro.medium.com/v2/resize:fit:1096/format:webp/1*iVX7e1iY5JoTuubkVNIvLA.png"/></div></figure><p id="4d6c" class="pw-post-body-paragraph is it iu iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ig bi translated">今天我要谈谈Python中的排序。像普通的高级语言一样，Python封装了复杂的排序函数。我们可以通过调用“排序”函数对各种数据进行排序。</p><p id="ba05" class="pw-post-body-paragraph is it iu iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ig bi translated">但是在实际场景中，排序往往更加复杂，比如对象类型中的元素，或者我们要按多个关键字排序，这个时候我们几乎无法通过简单的函数调用来解决。</p><h2 id="6912" class="jr js iu bd jt ju jv dn jw jx jy dp jz je ka kb kc ji kd ke kf jm kg kh ki kj bi translated">字典排序</h2><p id="1d11" class="pw-post-body-paragraph is it iu iv b iw kk iy iz ja kl jc jd je km jg jh ji kn jk jl jm ko jo jp jq ig bi translated">让我们首先看看最常见的排序场景。假设我们有一个包含多个字段的字典数组。我们希望按照字典中的特定字段对它们进行排序。让我们举个例子:</p><pre class="kp kq kr ks gt kt ku kv kw aw kx bi"><span id="88b5" class="jr js iu ku b gy ky kz l la lb">kids = [<br/>    {'name': 'Bob', 'score': 99, 'age': 12},<br/>    {'name': 'Jack', 'score': 75, 'age': 13},<br/>    {'name': 'Joe', 'score': 88, 'age': 15}<br/>]</span></pre><p id="ed35" class="pw-post-body-paragraph is it iu iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ig bi translated">这里，我们有一个名为kids的数组，其中包含姓名、分数和年龄。假设我们要按分数排序，应该怎么做？</p><p id="0632" class="pw-post-body-paragraph is it iu iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ig bi translated">这里有几种解决方案，一种常见的方法是使用匿名函数。“排序”函数有一个名为“关键字”的参数，我们可以向它传递一个函数来指定排序的字段。</p><pre class="kp kq kr ks gt kt ku kv kw aw kx bi"><span id="aabb" class="jr js iu ku b gy ky kz l la lb">sorted(kids, key=lambda x: x['score'])</span></pre><p id="e183" class="pw-post-body-paragraph is it iu iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ig bi translated">在匿名函数中，x代表数组中的元素，在这个问题中，它是一个字典。所以我们可以使用dict访问元素的方法，也就是用括号来查找对应字段的值。</p><p id="e620" class="pw-post-body-paragraph is it iu iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ig bi translated">如果我们想按多个字段对它们进行排序呢？</p><p id="111f" class="pw-post-body-paragraph is it iu iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ig bi translated">首先，让我简单介绍一下多关键字排序。再次，我们用上面的数据做类比。在这个例子中，孩子们的分数各不相同，所以排名的结果是确定的。但是如果有两个人分数相同，我们希望年轻的先来呢？</p><p id="8b76" class="pw-post-body-paragraph is it iu iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ig bi translated">所以我们需要比较两个字段的字典，如果两个字典有相同的分数，那么我们比较它们的年龄。换句话说，我们要同时按两个字段对数组进行排序，一个是分数，另一个是年龄。</p><p id="4f02" class="pw-post-body-paragraph is it iu iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ig bi translated">在Python中，我们可以直接按字典顺序比较两个列表/元组。解释器将从第一个元素开始比较数组，如果相等，它将继续比较下一个，直到不相等或结束。</p><p id="8afc" class="pw-post-body-paragraph is it iu iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ig bi translated">如果你理解其中的机制，这并不难，只需要在匿名函数的结果中增加一个参数。</p><pre class="kp kq kr ks gt kt ku kv kw aw kx bi"><span id="5baf" class="jr js iu ku b gy ky kz l la lb">sorted(kids, key=lambda x: (x['score'], x['age']))</span></pre><h2 id="e45f" class="jr js iu bd jt ju jv dn jw jx jy dp jz je ka kb kc ji kd ke kf jm kg kh ki kj bi translated">itemgetter</h2><p id="21ea" class="pw-post-body-paragraph is it iu iv b iw kk iy iz ja kl jc jd je km jg jh ji kn jk jl jm ko jo jp jq ig bi translated">除了匿名函数，Python也有自己的库来解决这个问题。用法与匿名函数非常相似，并且更容易使用。</p><p id="1143" class="pw-post-body-paragraph is it iu iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ig bi translated">是运算符库中的itemgetter函数，我们直接看代码。</p><pre class="kp kq kr ks gt kt ku kv kw aw kx bi"><span id="046b" class="jr js iu ku b gy ky kz l la lb">from operator import itemgetter<br/><br/>sorted(kids, key=itemgetter('score'))</span></pre><p id="fcbc" class="pw-post-body-paragraph is it iu iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ig bi translated">可以传递多个字段:</p><pre class="kp kq kr ks gt kt ku kv kw aw kx bi"><span id="cab5" class="jr js iu ku b gy ky kz l la lb">sorted(kids, key=itemgetter('score', 'age'))</span></pre><h2 id="0291" class="jr js iu bd jt ju jv dn jw jx jy dp jz je ka kb kc ji kd ke kf jm kg kh ki kj bi translated">对象分类</h2><p id="e7fa" class="pw-post-body-paragraph is it iu iv b iw kk iy iz ja kl jc jd je km jg jh ji kn jk jl jm ko jo jp jq ig bi translated">我们接下来看对象的定制排序，我们首先将字典转换成对象。</p><pre class="kp kq kr ks gt kt ku kv kw aw kx bi"><span id="6127" class="jr js iu ku b gy ky kz l la lb">class Kid:<br/>    def __init__(self, name, score, age):<br/>        self.name = name<br/>        self.score = score<br/>        self.age = age<br/><br/>    def __repr__(self):<br/>        return 'Kid, name: {}, score: {}, age:{}'.format(self.name, self.score, self.age)</span></pre><p id="c929" class="pw-post-body-paragraph is it iu iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ig bi translated">“__repr__”方法已被覆盖，以便于观察打印输出。在Java中，它可以简单地被当作一个toString方法，所以我们可以在打印它时指定输出。</p><p id="64a6" class="pw-post-body-paragraph is it iu iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ig bi translated">同样，操作符库也为对象提供了一个排序因子函数，它与“itemgetter”相同，但名称不同。它叫做“attrgetter”。</p><pre class="kp kq kr ks gt kt ku kv kw aw kx bi"><span id="221b" class="jr js iu ku b gy ky kz l la lb">from operator import attrgetter<br/><br/>kids = [Kid('Bob', 99, 12), Kid('Joe', 75, 13), Kid('Lee', 88, 15)]<br/><br/>sorted(kids, key=attrgetter('score'))</span></pre><p id="4336" class="pw-post-body-paragraph is it iu iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ig bi translated">我们也可以使用匿名函数来实现它:</p><pre class="kp kq kr ks gt kt ku kv kw aw kx bi"><span id="8a88" class="jr js iu ku b gy ky kz l la lb">sorted(kids, key=lambda x: x.score)</span></pre><h2 id="d416" class="jr js iu bd jt ju jv dn jw jx jy dp jz je ka kb kc ji kd ke kf jm kg kh ki kj bi translated">自定义排序</h2><p id="bb5c" class="pw-post-body-paragraph is it iu iv b iw kk iy iz ja kl jc jd je km jg jh ji kn jk jl jm ko jo jp jq ig bi translated">这还不是故事的结尾，虽然我们实现了多关键字排序，但是还有一个问题无法解决，那就是排序的顺序。</p><p id="a186" class="pw-post-body-paragraph is it iu iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ig bi translated">我们可以在排序函数的参数中传递“reverse=True”来控制它是正常顺序还是反向顺序。但是如果我有多个关键字，想按一个关键字上升，按另一个关键字下降怎么办？假设我们想按分数降序排列，当分数相等时，我希望可以按年龄升序排列。仅仅用‘逆向’论证是没有办法解决的。</p><p id="f4bb" class="pw-post-body-paragraph is it iu iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ig bi translated">为了解决这个问题，我们需要自定义排序。也就是我们实现一个定义元素顺序的比较函数，然后让' sorted '函数调用它来完成排序。这也是C++和Java的用法。</p><p id="8258" class="pw-post-body-paragraph is it iu iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ig bi translated">比较函数的逻辑非常简单。</p><pre class="kp kq kr ks gt kt ku kv kw aw kx bi"><span id="849a" class="jr js iu ku b gy ky kz l la lb">def cmp(kid1, kid2):<br/>    return kid1.age &lt; kid2.age if kid1.score == kid2.score else kid1.score &gt; kid2.score</span></pre><p id="5d6a" class="pw-post-body-paragraph is it iu iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ig bi translated">如果你对上面的代码感到困惑，我展开这段代码使它更容易理解。</p><pre class="kp kq kr ks gt kt ku kv kw aw kx bi"><span id="9ca4" class="jr js iu ku b gy ky kz l la lb">def cmp(kid1, kid2):<br/>    if kid1.score == kid2.score:<br/>        return kid1.age &lt; kid2.age<br/>    else:<br/>        return kid1.score &gt; kid2.score</span></pre><p id="7bb6" class="pw-post-body-paragraph is it iu iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ig bi translated">还没完，这个功能不能直接投入使用，和我们之前实现的匿名功能不一样。我们需要包装函数，使其适合传递给“排序”函数。包装逻辑由名为“functools”的库中的函数“cmp_to_key”完成:</p><pre class="kp kq kr ks gt kt ku kv kw aw kx bi"><span id="c8d5" class="jr js iu ku b gy ky kz l la lb">from functools import cmp_to_key<br/><br/>sorted(kids, key=cmp_to_key(cmp))</span></pre><p id="23e3" class="pw-post-body-paragraph is it iu iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ig bi translated">如果你对其中的逻辑感兴趣，我在下面展示了源代码。</p><pre class="kp kq kr ks gt kt ku kv kw aw kx bi"><span id="4942" class="jr js iu ku b gy ky kz l la lb">def cmp_to_key(mycmp):<br/>    """Convert a cmp= function into a key= function"""<br/>    class K(object):<br/>        __slots__ = ['obj']<br/>        def __init__(self, obj):<br/>            self.obj = obj<br/>        def __lt__(self, other):<br/>            return mycmp(self.obj, other.obj) &lt; 0<br/>        def __gt__(self, other):<br/>            return mycmp(self.obj, other.obj) &gt; 0<br/>        def __eq__(self, other):<br/>            return mycmp(self.obj, other.obj) == 0<br/>        def __le__(self, other):<br/>            return mycmp(self.obj, other.obj) &lt;= 0<br/>        def __ge__(self, other):<br/>            return mycmp(self.obj, other.obj) &gt;= 0<br/>        __hash__ = None<br/>    return K</span></pre><p id="3ca9" class="pw-post-body-paragraph is it iu iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ig bi translated">我们可以发现它在函数中定义了一个类，并在其中覆盖了比较函数。函数返回的结果是新的对象。这些“__lt__”、“__gt__”函数是在类中重载的比较函数。例如，“__lt__”是小于的判断函数，“__eq__”是等于的函数。那么我们能不能只覆盖Kid类中的比较函数？</p><p id="b98a" class="pw-post-body-paragraph is it iu iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ig bi translated">答案是肯定的，事实上我在面向对象编程当中很常见。我们更喜欢在类内部定义优先级，而不是使用比较函数。我们可以重写' __lt__ '函数，因为这意味着我们重新定义了对象之间的小于关系，Python将根据我们的定义对所有对象从小到大进行排序。</p><p id="5a14" class="pw-post-body-paragraph is it iu iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ig bi translated">让我们看看模式细节的代码。</p><pre class="kp kq kr ks gt kt ku kv kw aw kx bi"><span id="fa8c" class="jr js iu ku b gy ky kz l la lb">class Kid:<br/>    def __init__(self, name, score, age):<br/>        self.name = name<br/>        self.score = score<br/>        self.age = age<br/><br/>    def __repr__(self):<br/>        return 'Kid, name: {}, score: {}, age:{}'.format(self.name, self.score, self.age)<br/><br/>    def __lt__(self, other):<br/>        # return True means self &lt; other otherwise means self &gt;= other<br/>        return self.score &gt; other.score or (self.score == other.score and self.age &lt; other.age)</span></pre><p id="c127" class="pw-post-body-paragraph is it iu iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ig bi translated">在我们实现了比较函数之后，我们可以调用' sorted '函数来直接对它们进行排序，而不需要传递任何参数。</p><p id="e036" class="pw-post-body-paragraph is it iu iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ig bi translated">这篇文章的内容很简单，但是在日常工作中，当我们需要用复杂的逻辑对具有许多字段的对象进行排序时，它非常有用。所以我希望你们所有人都能理解这个机制并擅长它。</p><p id="2d82" class="pw-post-body-paragraph is it iu iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ig bi translated">本文到此结束，祝大家Python之旅愉快。</p></div></div>    
</body>
</html>