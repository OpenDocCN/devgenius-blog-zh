# F1 统计和 Python 入门

> 原文：<https://blog.devgenius.io/getting-started-with-ergast-f1-statistics-and-python-5112279d743a?source=collection_archive---------6----------------------->

Python 中的数据准备，用于使用 Ergast 数据集分析 F1 统计数据。

![](img/c8d2f1442db1428c3023edd78988a41a.png)

作者照片

本教程介绍了如何使用历史一级方程式数据进行分析。它涵盖了获取数据、清理数据和对这些数据进行的两次初步分析(更多内容将在后面介绍！).本文的主要焦点是这个数据集的数据准备，以便进行分析。这可能感觉像是脏活，但是良好的数据准备会有回报。简单。

数据是从 [Ergast 开发人员 API 中检索的。](http://ergast.com/mrd/)这是一个提供 F1 比赛历史数据的 API，从 1950 年开始，尽管并非所有数据都是完整的。数据可用于当前赛季，包含所有计划的比赛和所有已完成比赛的结果。

可用数据包含下表:

*   驱动因素—所有当前和以前驱动因素的信息
*   构造函数—所有当前和以前的构造函数的信息
*   制造商和车手的比赛结果
*   资格审查结果—所有资格审查会议的结果，包括单独的 Q1、A2 和 Q3 会议。
*   圈速——所有赛事中所有车手完成的所有圈速
*   进站—所有进站，时间和持续时间(进站—出站)
*   每场比赛后的积分榜，包括制造商和车手

有两种方法可以访问数据。首先，有一个 REST API 从数据集中检索信息。使用特定的 URL GET-request，例如`[http://ergast.com/api/f1/2008/](http://ergast.com/api/f1/2008/)8/results`返回 2008 赛季第 8 场比赛的结果。

第二，可以直接下载包含所有信息的 MySQL 数据库。它以数据库转储和一组 [CSV 文件](http://ergast.com/mrd/db/#csv)的形式提供。我们将在本教程中使用 CSV 文件。它将展示如何下载一个 ZIP 文件并从这个 ZIP 文件中导入所有 CSV 文件。由于我们将在所有可用的数据上构建数据集，这比数百个单独的 API 调用来收集整个数据集更容易、更快。在此之后，进行我们的分析不需要额外的 web 调用，因此我们可以随时随地执行我们的研究，并且我们可以缓存我们的数据准备。

## 输入数据

如上所述，我们将从 Ergast 网站下载一个 ZIP 文件，并从中导入 CSV 文件。

温蒂

这个类创建了一个对象 F1Stats，该对象导入比赛数据并将其存储在本地缓存中(稍后将清楚为什么)。在后面的阶段，方法将被添加到这个类中，以准备好的格式检索数据。

在初始化过程中，指定了存储原始下载文件的目录和文件名，以及包含缓存数据的 pickle 的名称。

核心就是`download_data()`法。该方法从网站下载 ZIP 文件，将其存储在本地磁盘上，并将所有 CSV 文件读取到每个 CSV 文件的 Panda 数据帧中。数据帧存储在字典中。

第 18 到 20 行下载 zip 文件并存储在磁盘上。第 22 行打开这个 zip 文件进行访问，第 25 到 27 行执行导入魔术。它创建一个数据帧字典，字典中的键等于 CSV 文件的名称，没有扩展名(第 25 行)。第 26 行使用`pandas.read_csv`方法将 CSV 文件读取到 Panda 数据帧中。`zipfile.open`方法打开一个 zip 文件并返回结果。导入后，序列`\n`从数据帧中删除。CSV 中的空字段用该代码填充，但是空的 dataframe 单元格更容易处理。

组合键和数据帧是为以'结尾的 ZIP 文件中的每个文件创建的。csv '(第 27 行)。这个 for 循环遍历存储在 zipfile ( `.infolist`)中的文件列表。如果文件以'结尾。执行“csv”的第 25 行和第 26 行来为该文件创建一个条目。例如，zipfile 包含一个名为“race_results.csv”的 CSV。CSV 的内容以数据帧的形式存储在字典中的“race_results”项下

`save_date`方法将字典(`dfs`)存储为 pickle 文件。load_date 从文件中读取字典。`initialize()`方法初始化该类，由此参数`download`确定是从网站下载 zip 文件(并存储在缓存中)还是将缓存用于初始化。后者更快。

在后面的阶段，将向该类添加方便的方法，用于获取数据集的视图。例如，比赛结果只包含车手和车队的 ID。将添加一个方法，在返回之前将驱动程序和构造函数的信息添加到比赛结果表中。根据经验，如果一个视图预计会被多次使用，那么它会被添加到类中。

初始化方法已经提示了下一步。清理数据。

## 数据清理

与大多数数据集一样，需要对数据进行一些清理。不同的表格包含字符串、整数、浮点数、日期和时间。对于每个类别，都需要一些操作。对于每个数据类型，都编写了一个方法来执行转换和清理。这些方法以下划线开始，使它们成为私有的。

对于字符串，使用清理方法(第 1–3 行)从字符串中删除空格。数据集中的一些列用空格左对齐或右对齐。此方法从指定的列中移除这些。第一个参数`dfname`指定了`self.dfs`字典中标识我们想要更新的数据帧的键。

具有整数的列作为字符串导入，因为数据集包含空值。方法(第 5–7 行)在用“0”(零)替换空单元格后，将列内容转换为整数类型。对于我们的分析，这意味着“0”等于缺失、不可用或无效的数据。在第 9–11 行中，创建了一个 equal 方法来将列转换为浮点数。

第 13 到 26 行将数据转换成一个`datetime`对象。datetime 字符串值可以在一列中，也可以分在两列中。在后一种情况下，`timecolumn`可用于指定包含时间部分的列。在这种情况下，首先通过简单地连接两个字符串，用时间扩展日期列(第 16–18 行)。时间列将从数据帧中删除。

该方法提供了用`datetime`对象值创建新列的可能性。如果使用此选项，原始日期和时间列(如果使用)将从数据帧中删除。最后一个参数`onerror`指定出错时采取的动作。默认参数值`ignore`忽略格式错误并返回原始值。当它被赋予值`coerce`时，无效的格式字符串将导致`NaT`，而不是时间。

最后，有两种方法可以转换为仅日期型和仅时间型。这些方法只保留由前面的方法创建的`datetime` 对象的相关部分。例如，laptimes 没有日期部分。

因此，这允许我们清理从数据集导入的所有不同的数据帧:

也强调几个动作，首先让我们看第 3 行。此行调用名为“races”的数据帧和该数据帧的列“name”的字符串的 cleanup 方法。

第 4 行从“日期”和“时间”列为同一个数据帧创建了一个日期时间对象。未指定目标列，因此结果日期时间对象将在“日期”列中。“时间”列将从数据框架中删除。

接下来的 5 行为这个事件的不同会话创建了一个 datetime 对象。对于这些，将创建一个新列，并将删除单独的日期和时间列。

导入和清理数据需要很长时间。但是每一分钟都是值得的。我们对数据集清理得越好，它就变得越容易使用。例如，不正确地转换整数值将意味着在每次分析期间都必须实现这种转换。通过第一次就做对，我们可以在后面的阶段节省时间。

正如第一个代码片段已经显示的，这种数据清理是在从 Ergast 下载数据之后、保存到缓存之前执行的。当使用数据的缓存版本时，这会节省大量时间。

## 我们的第一项分析——职业生涯中获胜次数最多的 F1 车手

终于到了我们第一次数据分析的时候了。从一个相对简单的问题开始，让我们找出赢得大奖赛最多的前 10 名 F1 车手。相对简单，因为它需要组合几个数据帧。

正如在开始时提到的，F1Stats 类将通过返回数据集的方便视图的方法进行扩展。对于此分析，需要一个关于比赛及其获胜者的视图。基本数据框架是'`results`'数据框架，包含所有比赛的所有车手成绩:

![](img/63926bb4151132b5038cda9852a6e0d6.png)

结果数据框架(作者截图)

dataframe 有 18 列，包括对驱动程序、构造函数和事件的引用。对于大多数关于比赛结果的分析，我们不需要这里列出的所有列，但我们希望手头有车手、构造者和事件信息。

添加了一个`get_race_results()`方法来过滤`results`的列，并将其与驱动程序、构造函数和事件信息连接起来。第 6–9 行通过选择要保留的列来过滤结果数据帧，并将其与比赛事件信息合并。事件的列`name`被重命名，以防止与驱动程序和构造函数的同名列冲突。此后，结果与驱动程序数据帧合并，最后与构造器数据帧合并。`pd.merge`自动检测同名的列，并对这些列执行连接。

产生的数据帧如下所示

![](img/248de9e8a73efaeb8f5a092fe7df4ae1.png)

比赛结果数据框(作者截图)

数据帧仍然包含对驱动程序、构造函数和事件的引用，但最重要的信息在数据帧本身。

第 24 行将这个数据帧存储在变量`winners`中，但是它仍然包含所有赛车的所有车手。第 25 行通过保留结束位置(列'`position`')等于' 1 '的行来过滤出获胜者。它包含了 1073 名 GP 冠军，而不是超过 250，000 的最终名次。

我们的目标是找到获胜次数最多的车手，所以我们需要计算每个车手出现在这个列表中的次数。为此，使用数据帧的`groupby`功能。dataframe 根据作为参数传递的列进行分组。然后可以对这些组调用函数，例如查找最大值/最小值、计算组中的项目数等。这些函数应用于不用于分组的列。因此

`winners[[‘driverId’, ‘driver’, ‘race’]].groupby([‘driverId’, ‘driver’]).count()`

从数据帧`winners`中选择`driverId`、`driver`和`race`列，并按`driverId`和`driver`分组。两列中具有相同值的所有行都放在一个组中。方法`count`然后计算每组中的项目数(对于列'【T9])。得到的数据帧将分组所依据的列作为索引，将计数结果作为列(以被计数的列命名)。通过调用`reset_index()`，索引被转换为“列”。第 27 行最后按照“比赛”(包含获胜次数)以降序对此数据帧进行排序:

![](img/bf92f99c7013036a99e070bad342968d.png)

获胜次数最多的 F1 车手(图片由作者提供)

这就是…赢得最多胜利的 10 位车手。

请注意，我们在`driverID`和`driver`列上对数据帧进行了分组。驱动程序列包含驱动程序的名称，这是最终表所必需的。但是名称不是唯一的，所以对于每个驱动程序来说，这个列可能不是唯一的。`driverId`是唯一的，所以最好将其用作分组变量。通过将`driver`列添加到组中，我们在最终的数据帧中有了驱动程序名称。如果仅使用`driverId`，则需要添加名称，并与驱动表合并。这里使用的解决方案更容易理解。

表格是表示这些信息的好方法，但是图表更好地突出了种族数量之间的差异。

![](img/4e6dc12566879eced0296df5889a71c7.png)

获胜次数最多的 F1 车手(图片由作者提供)

介绍了一种制作水平条形图的方法(期望更多用例:-)):

`horizontal_barplot()`获取数据帧`df`，在列`sort_value`上对其进行排序，并获取结果数据帧的第一个`rowcount`元素(第 6 行)。这些行被绘制成水平条，其中来自列`xcolumn` 的值被用于识别行和列，来自列`ycolumn`的值确定条的长度。

每个矩形(图中的条形)都有一个绘制在条形右侧的标签。标签是由横条(`str(get_width(`))`)表示的值。如果指定(`invert__yaxis`)，y 轴上的值将被反转。条形图从底部开始绘制，因为车手在比赛中获胜是降序排列的，在我们的例子中，轴必须反转，否则获胜最多的车手将绘制在底部。第 15 行到第 17 行将标题 ans 轴标签添加到绘图中。

第 19–22 行显示了前面显示的图表是如何生成的。

## 分析 2 -年度冠军排名

我们的第二项分析是对一段时间内车手排名的概述。哪位车手在积分榜上获得了名次，哪位车手失去了名次？这个季节什么时候？该图实现了:

![](img/f5080cfc25215e548fff779b4030ad9b.png)

冠军排名(图片由作者提供)

首先，我们需要收集数据来绘制这个图表。对于给定的一年，我们需要在每场比赛后在车手世界锦标赛中的位置。

一个方法被添加到`F1Stats`类中，该方法在每场比赛后返回 WDC(世界车手锦标赛)排名。可以选择特定的年份来过滤数据。

Ergast 数据集包含一个表`driver_standings`,其中包含大部分所需信息，但与比赛结果一样，还添加了一些关于比赛和车手的额外数据。两个连续的合并增加了这个信息(第 6-10 行)。

![](img/0acf6c58881d6591e05114a31593352f.png)

排行榜数据框(图片由作者提供)

对于 2022 年的所有比赛(第`round`栏)，车手排名显示在该数据框中。“位置”一栏给出了在积分榜上的位置，驾驶员由 ID、名称和代码指定。

要获得特定回合后的排名，可以在列'`round`'上过滤数据框。要了解特定车手在每轮比赛后的位置，可以对他的`name`、`code`或`driverId` 进行过滤。当数据包含多个年份时，在`driverId`上过滤是最安全的。随着时间的推移，车手的`code`肯定不是唯一的(例如，扬·马格努森使用的是 MAG，凯文·马格努森也在使用)，他的`name`可能不是。

该方法为数据帧`df`中的每个驱动器绘制一条线。预计数据帧包含一个名为“`code`”的列，包含三个字母的驱动程序代码。为每个驱动器绘制一条线(第 6-8 行)，指定 x 轴的`xcolumn`和 y 轴的`ycolumn`。在本分析中，这些是'`round`'和'`position`'。

线条的颜色是特定于驱动程序的，从 F1Stats 类中检索，其中一个表为每个驱动程序指定了在图表上表示他的颜色。如果一个驱动程序是未知的，它返回黑色。

第 9–21 行执行一些布局功能，如标题、刻度和轴标签。第 22–26 行在行的右侧添加一个带有驾驶员代码的标签。这一切导致:

![](img/837d856fff9bbcd1309364155d0f754d.png)

2022 赛季车手积分榜(图片由作者提供)

## 结论

Ergast 数据集包含大量关于 f1 历史比赛的信息。本文重点介绍如何开始使用这个数据集，比如导入数据和清理数据。给出了两个示例，显示了要执行的可能分析的一瞥。

花时间清理数据集。这有助于数据的使用，投入的时间将很快收回。在进行分析时，后退一步，想一想所需数据集合的哪一部分可能对未来有用。将这些添加到泛型类中。

更多分析可在[分析 F1 统计—第一部分](/analyzing-f1-statistics-part-i-a526d15b6fc8)中找到。

这篇文章的代码可以在名为 [Ergast-analysis.ipynb](https://github.com/lmeulen/F1Analysis/blob/master/Eregast-analysis.ipynb) 的 Jupyter 笔记本的 [github](https://github.com/lmeulen/F1Analysis) 中找到(包括下一篇文章的代码)

## 最后的话

我希望你喜欢这篇文章。要获得更多灵感，请查看我的其他文章:

*   [F1 匈牙利:一些观察](https://leo-vander-meulen.medium.com/f1-hungary-2022-some-observations-7d1e80d3831)
*   [使用 Python 和“scikit-learn”进行燃油价格预测](https://betterprogramming.pub/how-to-predict-fuel-prices-609f7ec417fb)
*   [太阳能电池板发电分析](https://towardsdatascience.com/solar-panel-power-generation-analysis-7011cc078900)
*   [对 CSV 文件中的列执行功能](https://towardsdev.com/perform-a-function-on-columns-in-a-csv-file-a889ef02ca03)
*   [根据你的活动跟踪器的日志创建热图](https://towardsdatascience.com/create-a-heatmap-from-the-logs-of-your-activity-tracker-c9fc7ace1657)
*   [使用 Python 的并行 web 请求](https://towardsdatascience.com/parallel-web-requests-in-python-4d30cc7b8989)

如果你喜欢这个故事，请点击关注按钮！

*免责声明:本文包含的观点和看法仅归作者所有。*