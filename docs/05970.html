<html>
<head>
<title>How to Remove Duplicate Records from 1 Billion records without any Index in MySQL?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何从MySQL中没有任何索引的10亿条记录中删除重复记录？</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-to-remove-duplicate-records-from-1-billion-records-without-any-index-in-mysql-44b15b2d0ec1?source=collection_archive---------2-----------------------#2021-11-29">https://blog.devgenius.io/how-to-remove-duplicate-records-from-1-billion-records-without-any-index-in-mysql-44b15b2d0ec1?source=collection_archive---------2-----------------------#2021-11-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="00f3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在设计应用程序、数据库和其他组件时，我们根据需求设计系统，几乎不考虑未来需求。但是，当您的应用程序增长时，有时您会吃掉健康空间，并重构内容以满足新的业务用例。</p><p id="7130" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">问题陈述/所需状态:</strong>在“TableY”的“ColumnX”上添加“唯一索引”，该“columnx”有<strong class="jp ir">~ 10亿条</strong>记录。</p><p id="c9ac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">当前状态:</strong>“columnx”包含重复记录，目前没有索引。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/42be5653e593b146402897814b3742aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cxB26Ps0iNvU1WuixdBfew.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">删除重复项</figcaption></figure><p id="a2a0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以下几个步骤有助于从<strong class="jp ir">当前状态</strong>达到<strong class="jp ir">所需状态</strong>:</p><h1 id="3e01" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">第一步:寻找重复</h1><p id="4cdc" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">如果您认为运行下面的查询可以得到重复记录的列表，那么您首先需要后退一步，考虑记录和非索引列的数量。最好不要在生产数据库中运行此查询；这可能会影响现有数据库查询的性能。</p><pre class="km kn ko kp gt me mf mg mh aw mi bi"><span id="92a8" class="mj lc iq mf b gy mk ml l mm mn">SELECT count(*) AS Total, ColumnX FROM TableY GROUP BY ColumnX HAVING Total &gt;= 2;</span></pre><p id="95ee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">注</strong>:带着单子过了几天才回来。</p><p id="fc66" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您考虑过上面的查询，您现在就会理解，对于现有的设置，获取重复记录的列表并不容易。我们可能需要多次运行相同的查询，以了解它包含哪些重复的记录，并且该表也是活动的，即每秒钟插入许多记录。</p><p id="e8b6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是我们的第一步，即<strong class="jp ir">添加常规索引</strong>。是的，这不需要花太多时间来完成。花了<strong class="jp ir">30-60分钟</strong>才完成。</p><pre class="km kn ko kp gt me mf mg mh aw mi bi"><span id="40d3" class="mj lc iq mf b gy mk ml l mm mn">CREATE INDEX `idx_ColumnX` ON TableY(ColumnX);</span></pre><p id="07dd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们已经在ColumnX上添加了常规索引，是时候重新运行上面的查询来获得重复记录的列表了。这次需要<strong class="jp ir"> &lt; 30分钟</strong>。</p><h1 id="668f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">第二步:删除重复项</h1><p id="f862" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">与删除重复记录相比，查找重复记录很容易。这里涉及到很多因素关于删除哪个重复记录？诸如“LastUpdated”、“CreatedDate”、其他列上的重要信息等因素。，可能会影响对要删除的正确记录的决定。</p><p id="a21e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">去掉记录后你可能还是不自信，可能会有很多你以后可能需要的有价值的信息。</p><p id="6b03" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">考虑到上述挑战，您有两个选择:</p><ol class=""><li id="8940" class="mo mp iq jp b jq jr ju jv jy mq kc mr kg ms kk mt mu mv mw bi translated"><strong class="jp ir">删除记录</strong>；其他记录或它们的列不包含任何有价值的信息。</li><li id="14e5" class="mo mp iq jp b jq mx ju my jy mz kc na kg nb kk mt mu mv mw bi translated">或者<strong class="jp ir">为重复的记录创建一个备份表</strong>，这样你可以在将来使用它。</li></ol><p id="e2b5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这样，下面是创建一个简单备份表的查询:</p><pre class="km kn ko kp gt me mf mg mh aw mi bi"><span id="ec92" class="mj lc iq mf b gy mk ml l mm mn">CREATE TABLE IF NOT EXISTS `BackUpTableY` (<br/>  `ID` varchar(255) NOT NULL,<br/>  `ColumnA` varchar(255) NOT NULL,<br/>  `ColumnB` varchar(255) NOT NULL,<br/>  `ColumnC` tinyint(1) NOT NULL,<br/>  `ColumnX` varchar(255) DEFAULT NULL,<br/>  `CreatedDate` datetime(3) NOT NULL,<br/>  `LastUpdated` datetime(3) NOT NULL,<br/>  PRIMARY KEY (`ID`),<br/>  KEY `idx_ColumnX` (`ColumnX`) USING BTREE,<br/>  KEY `idx_ColumnA` (`ColumnA`)<br/>);</span></pre><p id="03fd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，将所有重复的记录插入上表:</p><pre class="km kn ko kp gt me mf mg mh aw mi bi"><span id="2cc6" class="mj lc iq mf b gy mk ml l mm mn">INSERT INTO BackUpTableY<br/>SELECT TY.*<br/>FROM TableY AS TY<br/>INNER JOIN<br/>(<br/>  SELECT<br/>  max(LastUpdated) AS LatestUpdated,<br/>  count(*) AS Total,<br/>  ColumnX<br/>  FROM TableY<br/>  GROUP BY ColumnX<br/>  HAVING Total &gt;= 2<br/>)<br/>AS Tbl ON TY.ColumnX = Tbl.ColumnX<br/>AND TY.LastUpdated != Tbl.LatestUpdated;</span></pre><p id="b050" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">注意</strong>:我已经决定使用INSERT with SELECT查询中的‘last updated’列。</p><p id="94c6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，最后一个子步骤—删除重复记录。同样，在选择其中一种方法时，您需要小心一点:</p><ol class=""><li id="160c" class="mo mp iq jp b jq jr ju jv jy mq kc mr kg ms kk mt mu mv mw bi translated">用一个DELETE命令删除所有重复的记录:这将在那些记录范围上添加一个锁，并且可能会影响数据库的整体性能。</li><li id="8055" class="mo mp iq jp b jq mx ju my jy mz kc na kg nb kk mt mu mv mw bi translated">为每个记录创建单独的DELETE语句，并批量运行它们:这种方法可能需要额外的工作，但是不会影响数据库的整体性能。</li></ol><p id="cbe2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这两种方法各有利弊；根据您的数据集选择最适合您的方法。</p><h1 id="726d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">步骤3:添加唯一索引</h1><p id="a086" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">一旦添加了常规索引并删除了重复记录，我们就需要最后一击来防止更多的重复记录，即添加唯一索引。</p><pre class="km kn ko kp gt me mf mg mh aw mi bi"><span id="aad6" class="mj lc iq mf b gy mk ml l mm mn">CREATE UNIQUE INDEX `idx_Unique_ColumnX` ON `TableY`(`ColumnX`);</span></pre><p id="64dd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为ColumnX已经有了一个常规索引，所以添加一个惟一索引不会花费太多时间，例如大约5分钟。</p><p id="81ec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就这样，我结束了这次学习；我希望你今天学到了一些新东西。请与更多的同事或朋友分享。最后，考虑成为<a class="ae nc" href="https://zonito.medium.com/membership" rel="noopener">中等会员</a>。谢谢大家！</p></div></div>    
</body>
</html>