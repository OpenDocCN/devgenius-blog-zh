<html>
<head>
<title>When to use Test Doubles</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">何时使用测试替身</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/when-to-use-test-doubles-dba905a9069f?source=collection_archive---------3-----------------------#2022-11-12">https://blog.devgenius.io/when-to-use-test-doubles-dba905a9069f?source=collection_archive---------3-----------------------#2022-11-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="338b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">测试双打是工具，以简化我们的测试，他们也可以用来设计代码还没有写。定义或多或少独立于其他单元的粒度单元。但它们不是生产代码，它们是双精度的。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/f79a646310e71939f9aadbe7d48bc913.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V7T8uLt-Nt3cR88CZUZ6Hg.jpeg"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated"><a class="ae lb" href="https://pixabay.com/es/photos/br%c3%bajula-mapa-direcci%c3%b3n-grados-2946959/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></figcaption></figure><p id="3bdc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">测试替身是简化我们测试的工具，通常使用它们你需要修改你的代码。您需要引入合作者来帮助您提取一些逻辑，您想要独立测试的逻辑，以便为使用您的合作者的上层逻辑引入一个替身。</p><p id="07ba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一些定义摘自<a class="ae lb" href="https://martinfowler.com/bliki/TestDouble.html" rel="noopener ugc nofollow" target="_blank">马丁的福勒博客</a>:</p><ul class=""><li id="21be" class="lc ld iq jp b jq jr ju jv jy le kc lf kg lg kk lh li lj lk bi translated"><strong class="jp ir">虚拟物品被传来传去，但从未真正使用过。通常它们只是用来填充参数表。</strong></li><li id="d0df" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated"><strong class="jp ir">假的</strong>对象实际上有工作的实现，但是通常采取一些捷径，这使得它们不适合生产(一个<a class="ae lb" href="https://martinfowler.com/bliki/InMemoryTestDatabase.html" rel="noopener ugc nofollow" target="_blank"> InMemoryTestDatabase </a>就是一个很好的例子)。</li><li id="6d23" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">存根为测试期间的呼叫提供固定的答案，通常对测试程序之外的任何事情都不作出回应。</li><li id="fef7" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated"><strong class="jp ir">间谍</strong>是存根，也根据他们被调用的方式记录一些信息。其中一种形式可能是记录发送了多少条消息的电子邮件服务。</li><li id="0f0a" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated"><strong class="jp ir">模拟</strong>是预编程的预期，形成了它们预期接收的呼叫的规范。如果他们收到一个他们不期望的调用，他们可以抛出一个异常，并在验证过程中进行检查，以确保他们得到了他们期望的所有调用。</li></ul><p id="c0df" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如我们之前所说的，我们必须修改代码来使用它们。我的测试服务(SUT)将会做更少的事情，承担更少的责任。我将一些职责委托给我的测试所代表的生产实现。如果我的代码基本上是在玩第三方库、框架或任何我不能轻易改变的东西，以产生任何副作用，我真正想检查的是我的代码使用那个库有多好。<br/>在这种情况下，我的代码与库耦合得如此紧密，以至于实际上我只是在使用它，在这种情况下，我不认为将库改变两倍是个好主意。</p><blockquote class="lq lr ls"><p id="3563" class="jn jo lt jp b jq jr js jt ju jv jw jx lu jz ka kb lv kd ke kf lw kh ki kj kk ij bi translated">只嘲笑你所拥有的，因为嘲笑别人是粗鲁的。<br/><a class="ae lb" href="https://twitter.com/hynek/status/1478384282766913548" rel="noopener ugc nofollow" target="_blank">https://twitter.com/hynek/status/1478384282766913548</a></p></blockquote><p id="24fa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我想说的是，作为一个通用规则，不要通过任何类型的测试来改变库或框架。</p><p id="2132" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们想象一下，我想在我的组织之外调用一个 rest 端点，并且我想为正在做最后工作的那个薄层创建一个测试。<br/>我知道我不能在测试中调用真正的 rest 端点，所以我需要在某个点使用某种 double。<br/>按照上面描述的规则，我需要使用真实的库来调用 rest 端点，所以我唯一能做的就是伪造服务器。这很好，因为我将测试我是否真的正确使用了该库，我是否真的调用了正确的终结点，以便在任何情况下都能管理来自该库的错误。基本上，我正在测试与该库的集成。<br/>那个假服务器只是一组预定义的 rest json 对一组请求的答案，但会强制我们的代码与库以及我们想要测试的所有情况正确交互。</p><p id="bc4d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些假设只是合约的一部分，是的，test-doubles 定义了客户端、被测服务(SUT)和我们的服务器(在本例中是假服务器)之间的合约。</p><h2 id="d98e" class="lx ly iq bd lz ma mb dn mc md me dp mf jy mg mh mi kc mj mk ml kg mm mn mo mp bi translated">服务器端合约</h2><p id="3cf8" class="pw-post-body-paragraph jn jo iq jp b jq mq js jt ju mr jw jx jy ms ka kb kc mt ke kf kg mu ki kj kk ij bi translated">可以这样说，如果服务器发生更改，则合约将被破坏，这里有两种情况:</p><ul class=""><li id="e0b4" class="lc ld iq jp b jq jr ju jv jy le kc lf kg lg kk lh li lj lk bi translated">如果示例中的服务器由组织中的其他团队开发，并且团队之间有良好的沟通，则由您控制服务器。在这种情况下，可以使用合约测试来检查服务器是否不能破坏合约(例如，使用<a class="ae lb" href="https://docs.pact.io/" rel="noopener ugc nofollow" target="_blank"> Pact </a>)。</li><li id="f287" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">如果不控制服务器，则只能确定监视服务器的情况正在发生变化。如果可以访问登台环境，则可以监视该环境以确保情况不会发生变化(基于您的集成需要)，如果不能，则可以在生产环境中监视服务器，以便获得有关正在发生的情况的早期反馈并尽快做出反应。</li></ul><p id="7426" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果不控制服务器，则通过在管道中执行的 e2e 测试来检查客户端和服务器之间的集成没有多大价值。e2e 测试往往测试很多不同的方面:</p><ul class=""><li id="7bb6" class="lc ld iq jp b jq jr ju jv jy le kc lf kg lg kk lh li lj lk bi translated">应用程序的前端部分。</li><li id="1c2d" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">数据库中的数据。</li><li id="751c" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">与服务器的集成。</li><li id="a3f1" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">整个应用程序的逻辑。</li></ul><p id="7b1d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果一个测试失败了，而它的大范围又无法告诉你失败的地方，那就很难验证了，devs 不喜欢一次又一次地重复调查。<br/>监控两个系统集成过程中发生的事情要容易得多，也有效得多。</p><h2 id="2af0" class="lx ly iq bd lz ma mb dn mc md me dp mf jy mg mh mi kc mj mk ml kg mm mn mo mp bi translated">投入和产出</h2><p id="9192" class="pw-post-body-paragraph jn jo iq jp b jq mq js jt ju mr jw jx jy ms ka kb kc mt ke kf kg mu ki kj kk ij bi translated">请不要在一般情况下对输入数据和输出结果使用 doubles(假人除外)。如果您正在创建它们，这尤其糟糕，因为这些输入和输出很难创建。这就是为什么<a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/why-i-dont-like-the-builder-pattern-e05423698a9a?sk=ab3e214029e33109be6c2157f66b5dfa">我不喜欢构建器模式</a>的相同症状，它通常意味着我们没有遵守实体的<a class="ae lb" href="https://en.wikipedia.org/wiki/Interface_segregation_principle" rel="noopener ugc nofollow" target="_blank">界面分离原则。<br/>那些值可能不是我们感兴趣的东西，我们只是在使用它们，因为它们已经在过去被创造了，我们也懒得创造新的抽象。</a></p><h2 id="57ef" class="lx ly iq bd lz ma mb dn mc md me dp mf jy mg mh mi kc mj mk ml kg mm mn mo mp bi translated">双倍的风险</h2><p id="79e6" class="pw-post-body-paragraph jn jo iq jp b jq mq js jt ju mr jw jx jy ms ka kb kc mt ke kf kg mu ki kj kk ij bi translated">测试替身伴随着风险(在软件中，一切都是交易)。当您在测试中引入测试 double 时，您是在假设产品代码将如何运行。<br/>正如我所说的，如果您在创建生产代码时通过测试 double 来控制您正在更改的生产代码，您必须强制生产代码的行为与使用 double 的测试中描述的输入的 double 相同。<br/>风险是在未来改变产品代码而不改变你的 double，那么我们的测试将通过，但是我们的代码将在产品中被破坏。我通常会考虑到这种风险，所以为了最小化它，我会尝试在布局之间的边界使用 doubless，在特殊情况下，如果它们支付账单的话，我会在布局内部使用 double(逻辑非常复杂，所以我降低了测试的复杂性)。仅在布局之间的边界使用它们帮助我识别它们，在某种意义上定义布局，进行设计。<br/>如前所述，还有可能使用<a class="ae lb" href="https://blog.thecodewhisperer.com/permalink/getting-started-with-contract-tests" rel="noopener ugc nofollow" target="_blank">契约测试</a>来验证契约在双精度和您的生产代码之间没有丢失。</p><h2 id="f34f" class="lx ly iq bd lz ma mb dn mc md me dp mf jy mg mh mi kc mj mk ml kg mm mn mo mp bi translated">何时使用它们</h2><p id="ea82" class="pw-post-body-paragraph jn jo iq jp b jq mq js jt ju mr jw jx jy ms ka kb kc mt ke kf kg mu ki kj kk ij bi translated">如果您还不知道使用什么 db 或者最终的 rest-endpoint 是什么，那么可以使用 test doubles 来委托将来的决策。Doubles 将帮助您创建这些概念的包装器，这些概念将您(在一定程度上)与所有对构建您的业务逻辑不重要的特定决策隔离开来。</p><p id="e351" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用 doubles 来降低生产代码的复杂性，从而减少您必须在 SUT 中创建的测试数量。</p><p id="d745" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有些开发者试图避免使用测试替身，他们试图用真正的库和基础设施来测试一切。我不喜欢这种方法，因为大量集成或 e2e 测试的结果是低反馈环路(非常慢的管道)。当测试反馈循环缓慢时，人们倾向于制造大批量的<a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/batching-1e23cc939710?sk=e4244dcaaa7cdd2ea676f07c6f0314d3"/>。</p></div></div>    
</body>
</html>