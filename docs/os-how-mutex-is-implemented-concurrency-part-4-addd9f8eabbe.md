# [OS]互斥是如何实现的——并发性第 4 部分

> 原文：<https://blog.devgenius.io/os-how-mutex-is-implemented-concurrency-part-4-addd9f8eabbe?source=collection_archive---------8----------------------->

![](img/f493caf8d466d9799da6b9e1496ee913.png)

互斥是什么？

我们讨论了什么是互斥体，以及我们应该如何使用它。今天，我们要讨论互斥体是如何实现的。这看起来很神奇，它只是提供了一个“原子”锁定和解锁…对不对？

## 定时器中断

上次我们简要地讨论了中断，但现在让我们深入探讨一下。定时器中断是操作系统用来切换到另一个线程的机制。如果在运行线程“A”时从硬件触发了中断，则 CPU 调用相应的“中断处理程序”，该程序保存线程 A 的进程并切换到下一个线程。操作系统有权启用或禁用中断。但是，禁用中断时，我们应该非常小心。为什么？定时器中断是让所有线程都有机会运行的好方法。如果我们没有“中断”会发生什么？CPU 很可能会卡在一个线程上，直到用户的代码主动放弃 CPU。

## 如果一个线程永远在 CPU 上运行…

这是一个巨大的问题！假设用户正在运行一个计算圆周率最后一位数的线程。如果这个线程占用了 CPU，还不放弃 CPU，那么你的电脑就永远做不了别的事情了。因此，就暂停问题和资源分配而言，我们总是必须确保在运行用户程序时启用“中断”。

## **线程的同步**

如果一个中断一直被启用，那么我们应该如何在线程之间强制排序呢？我们不知道中断是何时触发的，这将打乱我们试图强制执行的任何线程序列。

假设我们通过简单地使用 while 循环来实现一个互斥体。

```
class Mutex{
  ...
  bool locked;
  void lock(){
    while(locked){
      // wait until lock is free... 
    }
    // Line A
    locked = true;
  } 
  void unlock(){
    locked = false; 
  }
  ...
};
```

假设 locked == false，线程 A 调用 lock()，中断在行 A 处被激发，然后，线程 B 也调用 lock()，检查 locked 变量，因为它是 false，所以它设置 locked = true。然后，中断再次被触发，并返回到线程 A。由于我们在 A 行被阻塞，它从 A 行恢复，并设置 locked = true。这是一个问题。由于线程 B 持有锁，线程 A 应该等待。现在，我们有两个线程持有一个锁！

此外，另一个问题是 while 循环的繁忙等待。正如我们上次讨论线程的生命周期一样，当线程等待锁被释放时，我们应该将它放在等待队列中，以避免繁忙的等待。

## 中断启用/禁用和等待队列

为了控制这一点，我们在线程库中使用中断启用和禁用。线程库被认为是一个 OS 代码，所以它有使用中断禁用和启用的特权。现在，我们可以使用这个很酷的工具来实现互斥。

```
class Mutex{
...
  void lock(){
    interrupt_disable();
    if(locked){
      // put current thread to wait queue. 
    }else{
      locked = true;
    }
    interrupt_enable();
  }
  void unlock(){
    interrupt_disable();
    if(/* the owner of the lock is current thread*/){
      locked = free;
    }
    // pull some threads from wait queue and put it into ready queue
    // so that that thread which was waiting for this mutex can start working
    interrupt_enable();
  }
}
```

在 lock()中，我们应该首先禁用中断，这样任何线程都不能修改“锁定”状态。如果互斥体已经被锁定，我们应该将当前线程放入等待队列，如果锁是空闲的，我们将 locked 设置为 true，启用中断并返回。这有点类似于使用锁定和解锁来保护用户代码中的共享状态。我们可以把中断看作是阻止共享状态“锁定”的低级机制当我们解锁()它时，我们应该根据调度器的优先级从等待队列中取出一些东西，并将该线程放入就绪队列，以便等待互斥体的线程可以获得锁并执行工作。

## **不变量**

我们应该小心的一件事是，我们应该在返回用户代码之前启用中断。一个基本原则是“我们不能相信用户的代码。”正如我上面提到的，用户的线程可能会计算圆周率的最后一位数，这是不可能的。**因此，我们应该确保在返回之前启用中断。**这是一个**不变量**我们应该继续写线程库。当我们实际切换线程时，情况变得复杂，因为我们不能在切换到另一个线程之前启用中断，因为我们应该确保我们存储了正确的线程 TCB。然而，如果我们在切换后启用中断，这就变得很奇怪，因为我们不知道这个线程什么时候会再次恢复，我们也不知道我们会在刚刚切换到的线程中做什么。答案是，我们只需在切换到另一个线程后启用中断。简而言之，所有线程总是从切换部分恢复，所以只要我们确保在切换后启用中断，我们就可以推断我们的不变量是全局保持的。这被称为**开关不变**。我会写一个关于这个转换过程的单独的帖子，因为它相当复杂。

此外，我们可以应用上次学习的 RAII 模式来保持这种不变量不受早期返回和错误的影响。

## 多核？

可悲的是，中断是一个**每核心操作**。它只能强制单个内核不要切换到另一个线程。因此，如果我们有多个内核，那么另一个内核可能会运行另一个触及互斥体的线程，我们为强制执行一个序列所做的所有努力都将付诸东流。

## 我们如何防止另一个**内核**访问我们的互斥体？

我们应该使用原子的读-修改-写。存储值(将值写入内存)是原子性的。利用这一点，我们可以实现一个守卫。

我们有一个像这样的交换函数。

```
int exchange(int *guard, int value){
  int result = *guard; // read the current value of that memory address
  *guard = value; // store the value to that memory address
  return result; // return the old value
}
```

我们只需获取守卫的旧值，并为守卫分配一个新值。现在，当我们调用 lock()时，我们可以做的是，

```
void lock(){
  interrupt_disable();
  while(exchange(&guard, 1)) {
    // wait until guard gives 0.
  }
  ...
  locked = true;
  guard = 0;
  ... 
}
```

我们不断调用 exchange 来获取警卫的旧值。如果 guard“was”1，这意味着另一个内核正在处理它。如果 guard“是”0，那么我们将它设置为 1，以防止另一个内核处理同一个互斥体。最后，在我们完成对它的处理后，我们将它设置为 0。

可能会有一个关于我们在哪里忙着等待的问题。防止其他内核访问互斥体是不可避免的。

实现一个线程库要比这复杂得多，但是我们至少了解了它是如何工作的基本结构！下一次，我们将看看线程库的另一个功能，即 CV(条件变量)。