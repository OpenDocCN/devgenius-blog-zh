<html>
<head>
<title>JavaScript. Linked Lists. Circular List.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript。链接列表。循环列表。</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/javascript-linked-lists-circular-list-f3edc4d65338?source=collection_archive---------1-----------------------#2020-08-26">https://blog.devgenius.io/javascript-linked-lists-circular-list-f3edc4d65338?source=collection_archive---------1-----------------------#2020-08-26</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/5ab6c623a8759bb5d8912af2ba4a6a81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*opjIfsBez1Z5Pe2z.png"/></div></div></figure><p id="002d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">大家好，谁是阅读这个博客。我很高兴继续使用链表来讨论更多的问题，并找到更多解决这些问题的方法。今天，我们将把一个叫做循环列表的新章节分成几个小部分。那是什么？所以基本上我们有一个链表，这个链表的节点指向我们传递的元素。结果，我们收到一个无限循环，破坏了我们的代码。我们必须确保我们列表避免无限循环。让我们创建一个方法，它将帮助我们检查它是真还是假。</p><p id="1e38" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你刚刚开始使用链表，我强烈推荐你浏览一些博客:</p><div class="kt ku gp gr kv kw"><a href="https://medium.com/dev-genius/javascript-linked-lists-what-is-linked-lists-create-a-node-class-api-9aa0fa460075" rel="noopener follow" target="_blank"><div class="kx ab fo"><div class="ky ab kz cl cj la"><h2 class="bd io gy z fp lb fr fs lc fu fw im bi translated">JavaScript。链接列表。什么是“链表”？创建节点类API</h2><div class="ld l"><h3 class="bd b gy z fp lb fr fs lc fu fw dk translated">新读者们你们好，欢迎回到我身边。只是想提一下，我已经不再写关于…</h3></div><div class="le l"><p class="bd b dl z fp lb fr fs lc fu fw dk translated">medium.com</p></div></div><div class="lf l"><div class="lg l lh li lj lf lk jt kw"/></div></div></a></div><h1 id="9c9b" class="ll lm in bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">检查列表是否是循环的</h1><h1 id="d656" class="ll lm in bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">方向</h1><p id="720d" class="pw-post-body-paragraph jv jw in jx b jy mj ka kb kc mk ke kf kg ml ki kj kk mm km kn ko mn kq kr ks ig bi translated">给定一个链表，如果链表是循环的，返回true，否则返回false。</p><h1 id="797b" class="ll lm in bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">例子</h1><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="1ec0" class="mx lm in mt b gy my mz l na nb">const l = new LinkedList();<br/>const a = new Node('a')<br/>const b = new Node('b')<br/>const c = new Node('c')<br/>l.head = a <br/>a.next = b<br/>b.next = c<br/>c.next = b<br/>circular(l)</span></pre></div><div class="ab cl nc nd hr ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="ig ih ii ij ik"><p id="21e1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们从5个节点的列表开始。正如你所看到的，我们有一个循环列表，紫色封闭了“红色”元素的列表。这个算法的思想是创建两个变量“慢”和“快”。其中“慢”会有一步，“快”会有两步。当慢速和快速拥有相同的节点时，它将返回true。否则，它将返回false。</p><figure class="mo mp mq mr gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nj"><img src="../Images/71ef698a03c8bbf802af0c01db614f34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NVEjIqvSwkQcO01ufRZ9tQ.png"/></div></div></figure><p id="a59e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们创造变数，一步一步慢慢前进。</p><figure class="mo mp mq mr gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nk"><img src="../Images/084c40a51df86a2cd4bdd84ba29a55a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TgKK4v35pvvPP6nCpVzXeQ.png"/></div></div></figure><p id="4e0a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">可以看到“慢”女仆走了一步，“快”走了两步。</p><figure class="mo mp mq mr gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nl"><img src="../Images/30b2b4b17318056c20dc319a85e9fd64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yloH9snkXXSBdL_biopo1Q.png"/></div></div></figure><p id="9675" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后我们再次向前移动并检查是否(" slow" === "fast ")</p><figure class="mo mp mq mr gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nm"><img src="../Images/613be96dee119195f327ffe27fcb6ad3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sZvIqxtmRHv7LYW4Y6c_eQ.png"/></div></div></figure><p id="09ca" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在最后一次，我们可以看到“慢”和“快”找到了对方，我们将返回true，因为它是内存中的同一个节点。</p><figure class="mo mp mq mr gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nn"><img src="../Images/e0186486ed4de34076388f53c8ed7f38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ONbtdFuzqXBc6q8Wy228MQ.png"/></div></div></figure></div><div class="ab cl nc nd hr ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="ig ih ii ij ik"><p id="5f5d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这里，我们可以看到JS代码，并完全描述了上述所有算法。</p><p id="4760" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们创建了变量“slow”和“fast ”,并指向列表的头部。当我们有next和next.next元素时，我们就在循环。此外，如果“慢速”与“快速”是同一个节点，则检查条件。如果它在while循环中没有找到任何东西，那么我们返回false。</p><figure class="mo mp mq mr gt jo gh gi paragraph-image"><div class="gh gi no"><img src="../Images/7bb0d42427d8e2c1988aff818c948905.png" data-original-src="https://miro.medium.com/v2/resize:fit:1304/format:webp/1*jgKHwsoWBN-UYpR1ebeK4Q.png"/></div></figure><figure class="mo mp mq mr gt jo gh gi paragraph-image"><div class="gh gi np"><img src="../Images/3dd02c5d1df290aba28edf5016daa009.png" data-original-src="https://miro.medium.com/v2/resize:fit:1056/format:webp/1*CdSEkWPKolR_R0JUutzRpg.png"/></div></figure><figure class="mo mp mq mr gt jo gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/a56abd6b8ec3a7fe49d667087a9601cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:196/format:webp/1*qJolIsI1KE0hb_pde93Muw.png"/></div></figure><p id="5778" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">完整代码:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="b230" class="mx lm in mt b gy my mz l na nb">class Node {<br/> constructor(data, next = null) {<br/> this.data = data;<br/> this.next = next;<br/> }<br/>}class LinkedList {<br/> constructor() {<br/> this.head = null;<br/> }insertFirst(data) {<br/> const node = new Node(data, this.head);<br/> this.head = node;<br/> }<br/> <br/> size() {<br/> let counter = 0;<br/> let node = this.head;<br/> while (node) {<br/> counter++;<br/> node = node.next;<br/> }<br/> return counter;<br/> }<br/> <br/> getFirst() {<br/> return this.head.data;<br/> }<br/> <br/> getLast() {<br/> if (!this.head) {<br/> return null;<br/> }<br/> let node = this.head;<br/> while (node) {<br/> if (!node.next) {<br/> return node;<br/> }<br/> node = node.next;<br/> }<br/> }<br/> <br/> clear() {<br/> this.head = null;<br/> } <br/> <br/> removeFirst() { <br/> if (!this.head) {<br/> return;<br/> }<br/> this.head = this.head.next;<br/> }removeLast() {<br/> if (!this.head) {<br/> return;<br/> }<br/> <br/> if (!this.head.next) {<br/> this.head = null;<br/> }<br/> <br/> let previous = this.head;<br/> let node = this.head.next;<br/> <br/> while (node.next) {<br/> previous = node;<br/> node = node.next;<br/> }<br/> <br/> previous.next = null;<br/> } insertLast(data) {<br/> const last = this.getLast();<br/> if (last) {<br/> last.next = new Node(data);<br/> } else {<br/> this.head = new Node(data);<br/> }<br/> }<br/> <br/> getAt(index) {<br/> let counter = 0;<br/> let node = this.head;<br/> while (node) {<br/> if (counter === index) {<br/> return node;<br/> }<br/> counter++;<br/> node = node.next;<br/> }<br/> return null;<br/> } removeAt(index) {<br/> if (!this.head) {<br/> return;<br/> } if (index === 0) {<br/> this.head = this.head.next;<br/> return;<br/> }<br/> <br/> const previous = this.getAt(index — 1);<br/> if (!previous || !previous.next) {<br/> return;<br/> }<br/> previous.next = previous.next.next;<br/> } insertAt(data, index) {<br/> if (!this.head) {<br/> this.head = new Node(data);<br/> return;<br/> }<br/> if (index === 0) {<br/> this.head = new Node(data, this.head);<br/> return;<br/> }<br/> const previous = this.getAt(index — 1) || this.getLast();<br/> const node = new Node(data, previous.next);<br/> previous.next = node; <br/> }<br/>}</span><span id="8537" class="mx lm in mt b gy nr mz l na nb">function circular(list) {<br/>  let slow = list.head;<br/>  let fast = list.head;<br/>  while (fast.next &amp;&amp; fast.next.next) {<br/>    slow = slow.next;<br/>    fast = fast.next.next;<br/>    if (slow === fast) {<br/>      return true;<br/>    }<br/>   }<br/>  return false;<br/>}</span><span id="1e27" class="mx lm in mt b gy nr mz l na nb">const l = new LinkedList();<br/>const a = new Node("a");<br/>const b = new Node("b");<br/>const c = new Node("c");<br/>l.head = a;<br/>a.next = b;<br/>b.next = c;<br/>c.next = b;<br/>console.log(circular(l)); //true</span></pre></div></div>    
</body>
</html>