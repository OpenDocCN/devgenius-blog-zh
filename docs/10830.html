<html>
<head>
<title>Introduction to Rocketry</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">火箭学导论</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/introduction-to-rocketry-7650e2bb38be?source=collection_archive---------2-----------------------#2022-12-03">https://blog.devgenius.io/introduction-to-rocketry-7650e2bb38be?source=collection_archive---------2-----------------------#2022-12-03</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/b88b6028672ef815d624dc4f94d487dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tbM9ieIZmUoidgNYmKMMVw.png"/></div></div></figure><p id="6275" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">rockerry 是一个基于语句的 Python 调度引擎。它有数百个调度选项，可以用简单的逻辑根据自定义条件任意扩展。Rocketry 适用于小型或大型自动化项目。它可以与现有的应用程序集成，也可以作为大型系统的自动化后端。</p><p id="12cd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">去年夏天我最初写了<a class="ae kt" href="https://medium.com/itnext/red-engine-insanely-powerful-scheduler-7d9d8e84b58b" rel="noopener">一篇展示火箭技术的文章</a>(当时被称为红色引擎)，后来<a class="ae kt" href="https://medium.com/itnext/new-paradigm-on-scheduling-cf2e55950a0d" rel="noopener">在有了更多进展后重写了这篇文章</a>。现在这个库的特性更加稳定了，我想也许是时候为这个框架提供合适的教程了，所以我决定从这个介绍开始。</p><p id="b3ad" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是让我们开始吧。通常，调度框架需要三个组件:</p><ul class=""><li id="5432" class="ku kv in jx b jy jz kc kd kg kw kk kx ko ky ks kz la lb lc bi translated">调度:任务何时运行，</li><li id="5449" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks kz la lb lc bi translated">执行:您的任务将如何运行，</li><li id="3ae0" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks kz la lb lc bi translated">日志记录:持久性</li></ul><p id="c913" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在本教程中，我们将逐一介绍这些方面以及它们在火箭学中的工作原理。我们从一个最小的工作示例开始，浏览 Rocketry 的基本调度，然后讨论任务执行和日志记录。</p><h1 id="2209" class="li lj in bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">创建调度程序</h1><p id="547b" class="pw-post-body-paragraph jv jw in jx b jy mg ka kb kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated">下面是一个简单调度程序的示例:</p><pre class="ml mm mn mo gt mp mq mr bn ms mt bi"><span id="17f4" class="mu lj in mq b be mv mw l mx my">from rocketry import Rocketry<br/>from rocketry.conds import daily<br/><br/>app = Rocketry()<br/><br/>@app.task(daily)<br/>def do_things():<br/>    ... # Put your code here<br/><br/>if __name__ == "__main__":<br/>    app.run()</span></pre><p id="181c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里发生了什么？</p><ul class=""><li id="0366" class="ku kv in jx b jy jz kc kd kg kw kk kx ko ky ks kz la lb lc bi translated">首先，我们进口我们需要的东西，</li><li id="57b2" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks kz la lb lc bi translated">启动了火箭应用程序，</li><li id="31ff" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks kz la lb lc bi translated">创建了一个每天执行一次的函数任务<em class="mz"> do_things </em></li><li id="cff5" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks kz la lb lc bi translated">在脚本的主块中启动应用程序</li></ul><p id="1963" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您可以在函数中执行您的任务需要执行的任何操作。接下来我们将讨论调度是如何工作的。</p><h1 id="7cac" class="li lj in bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">任务调度</h1><p id="99b1" class="pw-post-body-paragraph jv jw in jx b jy mg ka kb kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated">如前所述，Rocketry 是一个基于语句的调度程序。每个任务都是使用语句或条件开始的。如果任务的启动条件为真，任务将启动；如果启动条件为假，任务将等待。这些条件也可以使用基本逻辑(AND、OR、NOT)任意组合。</p><p id="3307" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Rocketry 有大量用于各种目的的内置调度条件。这些选项可以分为几类:</p><ul class=""><li id="90a5" class="ku kv in jx b jy jz kc kd kg kw kk kx ko ky ks kz la lb lc bi translated">基于时间:每小时、每天、每周等运行一次。</li><li id="a08a" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks kz la lb lc bi translated">任务相关:在另一个任务之后运行</li><li id="f4f3" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks kz la lb lc bi translated">自定义:基于纯自定义逻辑运行</li><li id="1f2f" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks kz la lb lc bi translated">以上的组合</li></ul><p id="5c83" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个话题非常广泛，我们不会在本文中深入探讨。接下来我将展示这些选项。在本文中，我将只向您展示一些示例，但是您可以从文档中阅读更多内容。</p><p id="d624" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我会给你一些例子，你可以试试:</p><pre class="ml mm mn mo gt mp mq mr bn ms mt bi"><span id="0d15" class="mu lj in mq b be mv mw l mx my">from rocketry.conds import hourly, daily, every, after_success<br/><br/>@app.task(hourly)<br/>def do_hourly():<br/>    ...<br/><br/>@app.task(daily.at("10:00"))<br/>def do_daily_at_ten():<br/>    ...<br/><br/>@app.task(every("2 hours"))<br/>def do_after_every_two_hours():<br/>    ...<br/><br/>@app.task(after_success(do_hourly))<br/>def do_after_another():<br/>    ...</span></pre><p id="49a1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您还可以创建自定义条件(并将它们与其他条件组合在一起):</p><pre class="ml mm mn mo gt mp mq mr bn ms mt bi"><span id="3304" class="mu lj in mq b be mv mw l mx my">from rocketry.conds import daily<br/>from pathlib import Path<br/><br/>@app.cond()<br/>def path_exists(file):<br/>    return Path(file).exists()<br/><br/>@app.task(daily &amp; path_exists("myfile.csv"))<br/>def do_daily():<br/>    ...</span></pre><p id="a493" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当<em class="mz"> myfile.csv </em>存在时，上述任务每天运行一次。你可以在<a class="ae kt" rel="noopener ugc nofollow" target="_blank" href="/scheduling-with-rocketry-5aa5b1bed520">的下一篇教程</a>中读到更多关于排班的内容。</p><h1 id="3c05" class="li lj in bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">任务执行</h1><p id="9fd2" class="pw-post-body-paragraph jv jw in jx b jy mg ka kb kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated">调度框架的另一个基本特征是任务执行；任务如何运行。在这种情况下，我们主要讨论并行性。一个简单的调度器可能只允许一个任务在一个给定的时间运行，而更复杂的框架允许一次运行多个任务，称为并行执行。火箭技术让你决定方法。</p><p id="3d85" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">运行任务有三种执行选项:</p><ul class=""><li id="4800" class="ku kv in jx b jy jz kc kd kg kw kk kx ko ky ks kz la lb lc bi translated"><strong class="jx io">主</strong>:同步磨合</li><li id="eed1" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks kz la lb lc bi translated"><strong class="jx io">异步</strong>:异步运行</li><li id="d038" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks kz la lb lc bi translated"><strong class="jx io">线程</strong>:在单独的线程中运行</li><li id="0b75" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks kz la lb lc bi translated"><strong class="jx io">进程</strong>:在单独的进程中运行</li></ul><p id="ba52" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您可以自由地尝试适合您情况的最佳选项。执行很容易设置:</p><pre class="ml mm mn mo gt mp mq mr bn ms mt bi"><span id="3b68" class="mu lj in mq b be mv mw l mx my">@app.task(execution="main")<br/>def do_sync():<br/>    ...<br/><br/>@app.task(execution="async")<br/>async def do_async():<br/>    ... # This runs using async<br/><br/>@app.task(execution="thread")<br/>def do_thread():<br/>    ... # This runs in a thread process<br/><br/>@app.task(execution="process")<br/>def do_process():<br/>    ... # This runs in a separate process</span></pre><p id="461c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果异步、线程和多处理对你来说是新的，<a class="ae kt" href="https://medium.com/itnext/practical-guide-to-async-threading-multiprocessing-958e57d7bbb8" rel="noopener">我写了一个实用的介绍来解释这些</a>。下面总结了每种方法的有用之处:</p><ul class=""><li id="855b" class="ku kv in jx b jy jz kc kd kg kw kk kx ko ky ks kz la lb lc bi translated">main:对维护任务有用</li><li id="4d12" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks kz la lb lc bi translated">async:如果库支持，对 IO 绑定的任务有用</li><li id="18d8" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks kz la lb lc bi translated">线程:对于 IO 绑定的任务很有用</li><li id="cb84" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks kz la lb lc bi translated">进程:对于 CPU 受限的任务很有用</li></ul><p id="9693" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">此外，如果使用异步任务，任务函数应该定义为<em class="mz"> async </em>，并且还应该在任务中使用 await。线程和异步任务并发运行，但不是并行的(除了一些 IO 绑定的操作)，而流程任务可以真正并行运行。这听起来似乎流程执行是最好的选择，但是您也应该注意到，从资源角度来说，它是最昂贵的。</p><p id="4317" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您还可以设置默认执行，这样就不需要在每个任务中都指定它:</p><pre class="ml mm mn mo gt mp mq mr bn ms mt bi"><span id="6af2" class="mu lj in mq b be mv mw l mx my">from rocketry import Rocketry<br/><br/>app = Rocketry(execution="main")<br/><br/>@app.task()<br/>def do_things():<br/>    ... # This uses default execution</span></pre><h1 id="8ec6" class="li lj in bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">任务日志记录</h1><p id="7871" class="pw-post-body-paragraph jv jw in jx b jy mg ka kb kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated">为了在系统中保持持久性，任务日志记录在调度程序中是必不可少的。如果调度程序崩溃或重启，系统应该能够从它之前离开的地方恢复。如果没有可靠的日志记录，调度程序可能会过于频繁地运行一些任务。</p><p id="0506" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Rocketry 的任务日志是建立在日志库(Python 的标准库)之上的。它还使用 Red Bird 的存储库模式使日志可读，并在同一 API 下统一不同类型的数据存储，如 CSV 文件、SQL 数据库或 MongoDB。</p><p id="c0d1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">默认情况下，Rocketry 使用内存中的列表作为日志记录存储。这对于测试很有用，但不建议用于生产，因为日志会在重启时被清除，并且日志会累积内存。</p><p id="d58d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">设置存储库的推荐方法是使用应用程序设置装饰器:</p><pre class="ml mm mn mo gt mp mq mr bn ms mt bi"><span id="2f66" class="mu lj in mq b be mv mw l mx my">from rocketry import Rocketry<br/>from rocketry.args import TaskLogger<br/>from rocketry.log import MinimalRecord<br/><br/>from redbird.repos import MemoryRepo<br/><br/>app = Rocketry()<br/><br/>@app.setup()<br/>def setup_app(task_logger=TaskLogger()):<br/>    repo = MemoryRepo(model=MinimalRecord)<br/>    task_logger.set_repo(repo)<br/><br/>...</span></pre><p id="2ddf" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下面是<em class="mz"> setup_app </em>中发生的事情:</p><ul class=""><li id="e883" class="ku kv in jx b jy jz kc kd kg kw kk kx ko ky ks kz la lb lc bi translated">我们使用 Rocketry 的动态参数来获取任务日志</li><li id="6ffb" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks kz la lb lc bi translated">我们使用<em class="mz"> MinimalRecord </em>作为存储日志的模型，创建一个内存存储库(数据存储)</li><li id="5545" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks kz la lb lc bi translated">我们将这个存储库设置为任务记录器中的主存储库</li></ul><p id="2e87" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们不会深入讨论 Rocketry 的参数机制，但是<em class="mz"> task_logger </em>将获得一个日志适配器作为值。这个适配器是日志库的 logger 的包装器，具有一些额外的功能，比如从日志中读取，以及为日志记录添加数据存储的一种方便的方法。该功能在调度应用程序的启动序列中运行。</p><p id="3681" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">数据存储还有其他选项，如 CSV、MongoDB 和 SQL:</p><pre class="ml mm mn mo gt mp mq mr bn ms mt bi"><span id="6b42" class="mu lj in mq b be mv mw l mx my"># CSV<br/>from redbird.repos import CSVFileRepo<br/><br/>@app.setup()<br/>def setup_app(task_logger=TaskLogger()):<br/>    repo = CSVFileRepo(filename="logs.csv", model=MinimalRecord)<br/>    task_logger.set_repo(repo)</span></pre><pre class="na mp mq mr bn ms mt bi"><span id="0184" class="mu lj in mq b be mv mw l mx my"># SQL<br/>from redbird.repos import SQLRepo<br/><br/>@app.setup()<br/>def setup_app(task_logger=TaskLogger()):<br/>    repo = SQLRepo(conn_string="sqlite://", table="mylogs", if_missing="create", model=MinimalRecord, id_field="created")<br/>    task_logger.set_repo(repo)</span></pre><pre class="na mp mq mr bn ms mt bi"><span id="60f6" class="mu lj in mq b be mv mw l mx my"># MongoDB<br/>from redbird.repos import MongoRepo<br/><br/>@app.setup()<br/>def setup_app(task_logger=TaskLogger()):<br/>    repo = MongoRepo(uri="mongodb://localhost:27017", database="rocketry", collection="mylog", model=MinimalRecord)<br/>    task_logger.set_repo(repo)</span></pre><p id="3c39" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">选择你需要的那个。注意，我们必须用 SQLRepo 传递<em class="mz"> id_field </em>，因为它被用作主键，并且 SQLAlchemy 在反射中需要它。</p><h1 id="eacb" class="li lj in bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">结论</h1><p id="b9ae" class="pw-post-body-paragraph jv jw in jx b jy mg ka kb kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated">在本系列的下一部分中，我们将更深入地研究 Rocketry 中的调度。<a class="ae kt" rel="noopener ugc nofollow" target="_blank" href="/scheduling-with-rocketry-5aa5b1bed520">你可以在这里找到下一个教程</a>。</p><p id="ce8e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我希望这篇介绍能帮助你开始使用火箭学。将来我可能会为这个框架的各个方面再做几个教程。我也很想知道人们用它创造了什么，人们对它有什么想法，所以请随意在 Rocketry 的 Github 页面上发表讨论。</p><p id="0af2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">火箭学的链接:</p><ul class=""><li id="1dd9" class="ku kv in jx b jy jz kc kd kg kw kk kx ko ky ks kz la lb lc bi translated">文件:<a class="ae kt" href="https://rocketry.readthedocs.io/" rel="noopener ugc nofollow" target="_blank">https://rocketry.readthedocs.io/</a></li><li id="14ee" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks kz la lb lc bi translated">源代码:<a class="ae kt" href="https://github.com/Miksus/rocketry" rel="noopener ugc nofollow" target="_blank">https://github.com/Miksus/rocketry</a></li></ul><p id="9a0c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你喜欢火箭技术，你可以在 Github 上给我买一杯咖啡来资助我的开发:<a class="ae kt" href="https://github.com/sponsors/Miksus" rel="noopener ugc nofollow" target="_blank">https://github.com/sponsors/Miksus</a></p></div></div>    
</body>
</html>