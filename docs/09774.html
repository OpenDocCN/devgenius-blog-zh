<html>
<head>
<title>S3, S4, RC, R6. Object oriented in R — Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">S3，S4，RC，R6。R 中的面向对象—第一部分</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/s3-s4-rc-r6-object-oriented-in-r-part-1-4e6cb6a79003?source=collection_archive---------4-----------------------#2022-09-12">https://blog.devgenius.io/s3-s4-rc-r6-object-oriented-in-r-part-1-4e6cb6a79003?source=collection_archive---------4-----------------------#2022-09-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="2bd7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">介绍面向对象的 R，S3 和 S4 对象。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/434ac3ea3bba8372e1cc180a03d5c312.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dgTXJ8LWjnof_tqL6NU6vw.png"/></div></div></figure><h1 id="45e2" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">第 1 部分的主题</h1><ul class=""><li id="8681" class="lv lw iq jp b jq lx ju ly jy lz kc ma kg mb kk mc md me mf bi translated">什么是面向对象(OO)？</li><li id="cd69" class="lv lw iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated">R 是如何实现 OO 的？</li><li id="a7e8" class="lv lw iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated">案例研究。</li><li id="2a05" class="lv lw iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated">S3 反对。</li><li id="d01c" class="lv lw iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated">S4 物体</li></ul><h1 id="7a71" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">什么是面向对象编程？</h1><p id="2abe" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">面向对象(OO)是程序设计的三个主要范例之一。它革新了编程，还有结构化编程和函数式编程。面向对象非常流行，尤其是 Python、Java、C#等语言。但是什么是面向对象编程呢？OO 通常由封装、多态和继承等特性来定义。我更喜欢用马丁的定义:</p><blockquote class="mo"><p id="94e7" class="mp mq iq bd mr ms mt mu mv mw mx kk dk translated">OO 语言对所有源代码的方向有绝对的控制权。</p></blockquote><p id="b13c" class="pw-post-body-paragraph jn jo iq jp b jq my js jt ju mz jw jx jy na ka kb kc nb ke kf kg nc ki kj kk ij bi translated">换句话说，OO 可以非常精确地控制依赖关系。</p><p id="486a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们如何在休息中驾驭这种力量？</p><h1 id="98b1" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">R 中的 OOP</h1><p id="7439" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">从设计上来说，r 是一种函数式语言。你分解一个问题，用函数解决它，而不是用对象。然而，R 支持 OO。事实上，在 R 中你一直在使用对象和方法，即使你没有意识到。像<code class="fe nd ne nf ng b">data.frame</code>、<code class="fe nd ne nf ng b">list</code>和<code class="fe nd ne nf ng b">vectors</code>这样的实体就是类。他们都有自己的方法，如<code class="fe nd ne nf ng b">print</code>或<code class="fe nd ne nf ng b">summary</code>。这些方法根据您使用它们的类而有不同的行为。</p><p id="5978" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">r 支持两种类型的 OO 编程:</p><ul class=""><li id="2ca9" class="lv lw iq jp b jq jr ju jv jy nh kc ni kg nj kk mc md me mf bi translated"><strong class="jp ir">功能性 OO 编程</strong>。在函数式 OO 编程中，方法属于泛型函数。函数式 OO 编程类似于标准的函数式编程，至少从外部来看是这样。R 中的函数对象是 S3 和 S4 对象。</li></ul><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nk nl l"/></div></figure><ul class=""><li id="e91f" class="lv lw iq jp b jq jr ju jv jy nh kc ni kg nj kk mc md me mf bi translated"><strong class="jp ir">封装的 OO 编程</strong>。在封装的 OO 编程中，方法属于类:它们是封装的。如果你熟悉 Python 或者 Java OO 编程，这也是同样的原理。R 中封装的对象是 R6 和 RC 对象。</li></ul><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="1132" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个小系列中，我们将首先看看 R 对 OO 的实现，以及不同解决方案的优缺点。</p><h1 id="5911" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">这个例子</h1><p id="5f32" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">在本系列中，我们将使用一个常见的例子来描述我们将要探索的所有对象。我们将用一些属性和方法定义一个类<code class="fe nd ne nf ng b">Animals</code>。然后我们将定义<code class="fe nd ne nf ng b">Animals</code>的子类:<code class="fe nd ne nf ng b">Dog</code>。我们会用<code class="fe nd ne nf ng b">Dog</code>来表示继承。</p><p id="7161" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一些属性和操作应该是公共的(+)，而其他的应该是私有的(-)。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/64cdababea6e07ea8934c9948ffe7d60.png" data-original-src="https://miro.medium.com/v2/resize:fit:990/format:webp/1*gmjK3h_Lg7-ZkHqs9I2qFQ.png"/></div><figcaption class="nn no gj gh gi np nq bd b be z dk translated">本系列中使用的类。</figcaption></figure><p id="d373" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一如既往，我想给你你需要的知识来设计基于良好决策的解决方案。我不打算给你 OO 实现的每一个可能的细节。如果你想知道所有的细节，哈德利·威克姆有一本很棒的书:高级 R(<a class="ae nr" href="https://adv-r.hadley.nz/index.html" rel="noopener ugc nofollow" target="_blank">https://adv-r.hadley.nz/index.html</a>)。</p><h1 id="6330" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">S3</h1><p id="7537" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">S3 是 r 中最简单也是最常见的面向对象编程形式。它的实现非常简单，尤其是与传统的面向对象语言相比。然而，它是非常多才多艺的，其简化的方法也有优点。</p><p id="8bba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了理解我的意思，让我们开始研究我们的示例类:<code class="fe nd ne nf ng b">Animals</code>。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="1557" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是非常不正式的。我们创建了一个列表，并将其属性从<code class="fe nd ne nf ng b">list</code>更改为<code class="fe nd ne nf ng b">Animals</code>。</p><p id="5600" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一般来说，每当我们创建一个 S3 对象时，我们都希望创建三个函数:</p><ul class=""><li id="2cb0" class="lv lw iq jp b jq jr ju jv jy nh kc ni kg nj kk mc md me mf bi translated"><strong class="jp ir"> <em class="ns">内部构造函数</em> </strong>。这将创建列表并将类更改为<code class="fe nd ne nf ng b">Animals</code>。这不会暴露给用户。这是一个开发者功能。构造函数名要以<code class="fe nd ne nf ng b">new_</code>开头。</li><li id="93f9" class="lv lw iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated"><strong class="jp ir"> <em class="ns">验证器</em> </strong>用于验证用户提供的创建类的输入。</li><li id="fa35" class="lv lw iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated"><strong class="jp ir"> <em class="ns">一个用户友好的</em> </strong>类生成器导出给用户。用户将调用它来构建一个对象。构建器将调用验证器和内部构造函数。</li></ul><p id="997e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是我们如何为我们的类编写这三个函数。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="6017" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们打开行李。</p><p id="6546" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe nd ne nf ng b">new_Animals</code>是内部构造函数。这不会向用户公开，但这是一种在内部构建对象的快速方法，即从包中构建。</p><p id="a3a1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe nd ne nf ng b">validate_Animals</code>是对象验证器。它检查我们有一个正确的类和正确的属性的对象。请注意，您可以在内部构造函数中包含这些简单的检查。根据经验，在验证器中包含昂贵的检查，在内部构造函数中包含廉价的检查。通过这种方式，您可以仅在需要时运行昂贵的检查。然而，我更喜欢更严格的责任划分。我将所有检查放在验证器中，而不是构造函数中。</p><p id="2972" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe nd ne nf ng b">Animals</code>是建设者暴露给用户。这个函数构建对象，然后验证它。</p><h1 id="4748" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">泛型和方法</h1><p id="67e8" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">我们现在需要创建我们的两个方法:<code class="fe nd ne nf ng b">print</code>和<code class="fe nd ne nf ng b">formatSpecies</code>。<code class="fe nd ne nf ng b">print</code>将打印我们对象的用户友好摘要，而不是我们默认得到的摘要。<code class="fe nd ne nf ng b">formatSpecies</code>将格式化物种字符串。</p><p id="88c7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在 S3，我们不能创建私有方法。我们所有的方法都会公开。</p><p id="18f7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">先从<code class="fe nd ne nf ng b">print</code>法说起吧。r 中已经存在一个泛型<code class="fe nd ne nf ng b">print</code>。您可以在任何变量上调用它，以查看它打印到控制台的值。事实上，<code class="fe nd ne nf ng b">print</code>是 S3 的通用名。我们可以使用它并为类<code class="fe nd ne nf ng b">Animals</code>创建一个新方法。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="887f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意方法<code class="fe nd ne nf ng b">print.Animal</code>的约定。调用方法为<code class="fe nd ne nf ng b">generic.class</code>非常重要。这是让调度机制工作所需的内部 R 约定。</p><p id="04b3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们创建<code class="fe nd ne nf ng b">formatSpecies</code>。这个方法没有泛型，所以我们需要创建它。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="7fdc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">泛型<code class="fe nd ne nf ng b">formatSpecies</code>会将适当的方法匹配到对象。然后，它将调用这个方法:<code class="fe nd ne nf ng b">formatSpecies.Animals</code>。</p><h1 id="3b14" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">遗产</h1><p id="a8a3" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">S3 的继承围绕着一个概念，即类可以是长度大于 1 的向量。也就是说，一个对象可以有两个或更多的类。您可以在<code class="fe nd ne nf ng b">tibble</code>包中找到这种行为的示例。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="2719" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一个<code class="fe nd ne nf ng b">tibble</code>对象有三个类:<code class="fe nd ne nf ng b">tbl_df</code>、<code class="fe nd ne nf ng b">tbl</code>和<code class="fe nd ne nf ng b">data.frame</code>。这体现了继承的顺序:<code class="fe nd ne nf ng b">tbl_df</code>是<code class="fe nd ne nf ng b">tbl</code>的子类，而<code class="fe nd ne nf ng b">tbl</code>又是<code class="fe nd ne nf ng b">data.frame</code>的子类。</p><p id="0165" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我们在一个像这样的对象上使用泛型时，R 会尝试按照指定的顺序分派给一个方法。如果没有找到<code class="fe nd ne nf ng b">tbl_df</code>的方法，那么 R 将寻找类<code class="fe nd ne nf ng b">tbl</code>的方法，最后是类<code class="fe nd ne nf ng b">data.frame</code>的方法。</p><p id="6b78" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们看看如何在我们的例子中使用它。在我们创建子类之前，我们需要改变超类。这是因为在 S3，继承不是自动的:我们需要将它添加到超类中。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="66d7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们做了三点改变:</p><ul class=""><li id="89fa" class="lv lw iq jp b jq jr ju jv jy nh kc ni kg nj kk mc md me mf bi translated">我们添加了参数<code class="fe nd ne nf ng b">...</code>。这允许我们向超类传递构造函数所需的任何额外参数。</li><li id="cc5b" class="lv lw iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated">我们添加了<code class="fe nd ne nf ng b">class=character()</code>这个参数。这允许我们指定子类并创建类向量，正如我们在 tibble 示例中看到的。</li><li id="2b6f" class="lv lw iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated">我们将这个类定义为<code class="fe nd ne nf ng b">c(class, "Animals")</code>，而不仅仅是<code class="fe nd ne nf ng b">"Animals"</code>。同样，这允许我们创建长度大于 1 的类向量。</li></ul><p id="c490" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">既然超类可以接受子类，让我们创建<code class="fe nd ne nf ng b">Dog</code>子类。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="e4b9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在第 3 行，我们调用了<code class="fe nd ne nf ng b">Animals</code>超类构造函数，但是我们指定我们想要使用类<code class="fe nd ne nf ng b">Dog</code>。在第 14 行中，我们看到<code class="fe nd ne nf ng b">myDog</code>的类是一个包含两个元素的向量:<code class="fe nd ne nf ng b">Dog</code>(子类)和<code class="fe nd ne nf ng b">Animals</code>(超类)。如果我们尝试使用 print 方法，R 将使用为类<code class="fe nd ne nf ng b">Animals</code>定义的 print 方法。这是因为我们没有为<code class="fe nd ne nf ng b">Dog</code>定义打印方法。就这么办吧。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="b01c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们有了<code class="fe nd ne nf ng b">Dog</code>的打印方法，R 将使用它，而不再使用<code class="fe nd ne nf ng b">Animals</code>的方法。我们不需要定义泛型 print，因为它已经在 base R 中定义了。我们只为子类创建方法。</p><p id="4a84" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我们可以使用相同的语法来创建新方法<code class="fe nd ne nf ng b">humanAge</code>。这种方法将计算狗的年龄在“人类”年。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="9cc9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里没有我们没有见过的东西:我们定义了泛型(<code class="fe nd ne nf ng b">humanAge</code>)，然后定义了与泛型和类关联的方法(<code class="fe nd ne nf ng b">Dog</code>)。</p><h1 id="787e" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">S3 不是可变的</h1><p id="a5b7" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">考虑一下这个场景。今天是你狗的生日。你想要一个新的方法，可以更新你的狗的年龄。它应该返回以前的年龄并更新内部年龄。S3 对象不能做到这一点。S3 对象不是可变的。他们不能修改输入参数，因为他们基于函数。</p><p id="0487" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们想要更新一个对象并从同一个调用返回一个结果，我们必须使用一个变通方法。我们需要创建一个功能:</p><ul class=""><li id="cc16" class="lv lw iq jp b jq jr ju jv jy nh kc ni kg nj kk mc md me mf bi translated">修改输入对象以更新年龄。</li><li id="4028" class="lv lw iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated">在列表中返回修改后的对象。</li><li id="c345" class="lv lw iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated">将前一个年龄添加到列表中。</li><li id="267a" class="lv lw iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated">在主环境中，用赋值语句解包列表。</li></ul><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="d2df" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">方法<code class="fe nd ne nf ng b">updateAge.Dog</code>返回一个包含先前年龄和修改对象的列表。</p><p id="c3f9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这很尴尬，比传统的封装面向对象要差很多，因为在传统的封装面向对象中，对象是可变的。当我们探索 R6 天体时，我们将会看到不同之处。</p><h1 id="9856" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">S3 总结</h1><p id="3041" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">S3 是简单的物体。他们的定义是非正式和宽松的。您甚至可以在创建后更改它们的结构。没有正式的验证器。S3 没有“私人”的概念，一切都是“公共”的。此外，S3 不是可变的。他们以功能为导向的行为可能会让非 R 人群感到不快。本质上，S3 对象不仅仅是美化了的列表。</p><p id="e383" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是不要太快就放弃它们。S3 的简朴中蕴含着美和意义。例如，将新类的新方法插入到现有的泛型中是非常容易的。</p><p id="dace" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您需要封装的可变方法或可靠的继承机制，S3 不是最佳选择。此外，在相同代码基础上开发的大型团队可能会因为界面缺乏结构而陷入困境。</p><p id="a882" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，在大多数情况下，S3 应该是第一选择。毕竟，如果它们是最常见的类型或 R 对象，肯定是有原因的。通过简化您的代码，使其适用于 S3，会有很多好处。</p><h1 id="053e" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">S4 物体</h1><p id="bdd8" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">S4 是 S3 的更严格的执行。S4 仍然是功能性的 OO，但是类是正式定义的。创建对象后，您不能再更改其结构。S4 支持更复杂的继承和分派机制。</p><p id="e828" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们看看如何在 S4 创建我们的<code class="fe nd ne nf ng b">Animals</code>类。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="837c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以看到一些与 S3 不同的地方。我们需要使用<code class="fe nd ne nf ng b">representation</code>来定义类内容(<code class="fe nd ne nf ng b">slots</code>)。如果我们试图在对象创建后给它添加另一个槽，或者给<code class="fe nd ne nf ng b">species</code>分配一个字符以外的东西，我们会得到一个错误。我们还注意到，要访问一个槽，我们使用<code class="fe nd ne nf ng b">@</code>而不是<code class="fe nd ne nf ng b">$</code>，或者我们可以使用 S4 函数<code class="fe nd ne nf ng b">slot()</code>。</p><p id="95d9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们现在有了基本的对象，让我们添加一个验证器。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="f22c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的验证器<code class="fe nd ne nf ng b">validate_Animals</code>基于我们用于 S3 的验证器，但是它更加轻量级。我们没有测试<code class="fe nd ne nf ng b">species</code>是字符还是空。这是因为在我们将<code class="fe nd ne nf ng b">species</code>定义为构造函数中的一个字符后，这些检查是免费的。我们只需要检查<code class="fe nd ne nf ng b">species</code>是否是我们想要的形式。</p><p id="92e9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们定义了验证函数<code class="fe nd ne nf ng b">validate_Animals</code>之后，我们使用<code class="fe nd ne nf ng b">setValidity</code>将它添加到构造函数中。通过这样做，每次创建对象时都会自动调用验证函数。</p><h1 id="f683" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">泛型和方法</h1><p id="a68f" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">如果我们不能对它做任何事情，我们的新 S4 对象就没有什么特别的帮助。让我们从创建一个显示其内容的方法开始。在 S4 你通常不用<code class="fe nd ne nf ng b">print</code>，而是用<code class="fe nd ne nf ng b">show</code>。如果你为<code class="fe nd ne nf ng b">print</code>创建一个类属，这将覆盖基本 R <code class="fe nd ne nf ng b">print</code>，然后它将停止工作。</p><p id="5904" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe nd ne nf ng b">show</code>是一个 S4 内置泛型，所以我们不需要定义它。我们只需要为我们的类定义方法。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="78d5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您还记得我们 S3 的例子，这看起来很熟悉。我们首先用<code class="fe nd ne nf ng b">setGeneric</code>定义一个泛型，然后用<code class="fe nd ne nf ng b">setMethod</code>定义一个方法。</p><p id="6ec5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用相同的语法，让我们实现<code class="fe nd ne nf ng b">formatSpecies</code>方法。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="73a8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">至于 S3，S4 没有私有方法的概念，所以两种方法都是公有的。</p><h1 id="5872" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">遗产</h1><p id="46f0" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">让我们创建一个继承自<code class="fe nd ne nf ng b">Animals</code>的 S4 类<code class="fe nd ne nf ng b">Dog</code>。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="db95" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过使用在<code class="fe nd ne nf ng b">Dog</code>的定义中使用的参数<code class="fe nd ne nf ng b">contains</code>，继承变得显式。你会注意到<code class="fe nd ne nf ng b">Dog</code>继承了<code class="fe nd ne nf ng b">Animals</code>的<code class="fe nd ne nf ng b">show</code>方法。我们可以创建一个专用的<code class="fe nd ne nf ng b">show</code>方法。同时，我们也可以创建<code class="fe nd ne nf ng b">humanAge</code>方法。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nk nl l"/></div></figure><h1 id="3715" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">S4 不是可变的</h1><p id="d47f" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">至于 S3 对象，S4 不是可变的。我们不能同时修改一个对象并返回一个结果。我们需要实现与 S3 对象相同的解决方法。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="6c43" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上面的代码片段中，我们创建了一个名为<code class="fe nd ne nf ng b">updateAge</code>的方法。在该方法中，我们更新槽位<code class="fe nd ne nf ng b">age</code>，且我们还返回旧年龄。为了能够一次完成这两个操作，我们必须从方法中返回一个列表。该列表将包含修改后的对象和期望的返回。最后，在主环境中，我们需要用更多的赋值来打开列表。</p><h1 id="bcbd" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">S4 总结</h1><p id="2594" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">S4 和 S3 基于同样的想法。它们都是功能性的 OO 系统，并且都是不可变的。S4 有更严格的定义。我们需要在我们的类中精确地指定我们想要的东西，并且一旦创建了一个对象的结构就不能被修改。这可以帮助更大的团队，因为界面更清晰。</p><p id="3e5b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">S4 补充道，拘泥形式听起来可能很棒，但你应该仔细评估这是否值得。通常最好使用更简单、更 R 友好的 S3。这是因为传统 R 开发人员改进了文档和代码可读性。</p><p id="137f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请关注我并订阅，以便在本系列的第 2 部分发布时获得通知，并获得关于 R 编程的其他技巧。</p></div></div>    
</body>
</html>