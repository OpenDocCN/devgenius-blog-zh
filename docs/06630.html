<html>
<head>
<title>Database with Prisma ORM, Docker and Postgres — NestJs with Passport #02</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有Prisma ORM、Docker和Postgres的数据库—带有Passport #02的NestJs</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/database-with-prisma-orm-docker-and-postgres-nestjs-with-passport-02-773092e382c?source=collection_archive---------0-----------------------#2022-01-21">https://blog.devgenius.io/database-with-prisma-orm-docker-and-postgres-nestjs-with-passport-02-773092e382c?source=collection_archive---------0-----------------------#2022-01-21</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/a58f4a875bf1e32888b663494e88b6c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sV4eoX6dfzRXvhwBvB7SVw.png"/></div></div></figure><div class=""/><p id="ed21" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在上一篇文章中，从一个空白的配置开始，理解NestJs如何处理路由、控制器和服务。看到了设置Fastify来优化我们的应用程序是多么容易。</p><p id="c03a" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，将建立数据库和ORM来交互和存储我们的数据。我们将PostgreSQL用于数据库，使用docker创建应用程序的默认容器，将Prisma用于ORM，因为这是目前与数据库交互的最佳Orm。</p></div><div class="ab cl kt ku hr kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ig ih ii ij ik"><p id="e278" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们有了自己的应用程序，让我们把它容器化。</p><p id="1a29" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先，在项目的根目录中创建以下文件:</p><ul class=""><li id="bb1d" class="la lb iy jx b jy jz kc kd kg lc kk ld ko le ks lf lg lh li bi translated">这个文件将负责导入Docker映像，将它们分成开发和生产环境，复制我们所有的文件，并安装依赖项。</li><li id="6385" class="la lb iy jx b jy ln kc lo kg lp kk lq ko lr ks lf lg lh li bi translated"><code class="fe lj lk ll lm b">docker-compose.yml</code> -该文件将负责定义我们的容器、应用程序其他服务所需的图像、存储卷、环境变量等。</li></ul><p id="2a96" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">打开<code class="fe lj lk ll lm b">Dockerfile</code>并添加</p><pre class="ls lt lu lv gt lw lm lx ly aw lz bi"><span id="d19e" class="ma mb iy lm b gy mc md l me mf"># Dockerfile</span><span id="e285" class="ma mb iy lm b gy mg md l me mf">FROM node:alpine As development</span><span id="0f90" class="ma mb iy lm b gy mg md l me mf">WORKDIR /usr/src/app</span><span id="3450" class="ma mb iy lm b gy mg md l me mf">COPY package*.json ./<br/>COPY prisma ./prisma/</span><span id="f055" class="ma mb iy lm b gy mg md l me mf">RUN yarn add glob rimraf</span><span id="66dd" class="ma mb iy lm b gy mg md l me mf">RUN yarn — only=development</span><span id="f9d3" class="ma mb iy lm b gy mg md l me mf">COPY . .</span><span id="bcfb" class="ma mb iy lm b gy mg md l me mf">RUN yarn build</span><span id="d80d" class="ma mb iy lm b gy mg md l me mf">FROM node:alpine as production</span><span id="a04d" class="ma mb iy lm b gy mg md l me mf">ARG NODE_ENV=production<br/>ENV NODE_ENV=${NODE_ENV}</span><span id="71a9" class="ma mb iy lm b gy mg md l me mf">WORKDIR /usr/src/app</span><span id="0270" class="ma mb iy lm b gy mg md l me mf">COPY package*.json ./<br/>COPY prisma ./prisma/</span><span id="15bb" class="ma mb iy lm b gy mg md l me mf">RUN yarn add glob rimraf</span><span id="c434" class="ma mb iy lm b gy mg md l me mf">RUN yarn — only=production</span><span id="245f" class="ma mb iy lm b gy mg md l me mf">COPY . .</span><span id="5882" class="ma mb iy lm b gy mg md l me mf">COPY — from=development /usr/src/app/dist ./dist</span><span id="7b22" class="ma mb iy lm b gy mg md l me mf">CMD [“node”, “dist/main”]</span></pre><p id="c06a" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">打开“docker-compose.yml”文件并添加以下代码</p><pre class="ls lt lu lv gt lw lm lx ly aw lz bi"><span id="1bd0" class="ma mb iy lm b gy mc md l me mf"># docker-compose.yml</span><span id="b20c" class="ma mb iy lm b gy mg md l me mf">version: “3.7”</span><span id="9eb5" class="ma mb iy lm b gy mg md l me mf">services:</span><span id="d58a" class="ma mb iy lm b gy mg md l me mf"> main:<br/>  container_name: main<br/>  build:<br/>   context: .<br/>   target: development<br/>  volumes:<br/>   — .:/usr/src/app<br/>   — /usr/src/app/node_modules<br/>  ports:<br/>   — 3000:3000<br/>  command: yarn start:dev<br/>  env_file:<br/>   — .env<br/>  networks:<br/>   — api<br/>  depends_on:<br/>   — postgres</span><span id="6756" class="ma mb iy lm b gy mg md l me mf">  postgres:<br/>   image: postgres:13<br/>   container_name: postgres<br/>   networks:<br/>    — api<br/>   env_file:<br/>    — .env<br/>   ports:<br/>    — 5432:5432<br/>   volumes:<br/>    — pgdata:/var/lib/postgresql/data<br/>networks:<br/> api:<br/>volumes:<br/> pgdata:</span></pre><p id="4068" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">创建一个` . env '文件并添加PostgreSQL凭据</p><pre class="ls lt lu lv gt lw lm lx ly aw lz bi"><span id="eada" class="ma mb iy lm b gy mc md l me mf">// .env</span><span id="8f20" class="ma mb iy lm b gy mg md l me mf"># PostgreSQL<br/>POSTGRES_USER=nestAuth<br/>POSTGRES_PASSWORD=nestAuth<br/>POSTGRES_DB=nestAuth</span></pre><p id="6a7a" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">默认情况下，Fastify只监听“localhost 127.0.0.1”接口。为了从其他主机访问我们的应用程序，我们需要在“main.ts”中添加“0.0.0.0”</p><pre class="ls lt lu lv gt lw lm lx ly aw lz bi"><span id="a049" class="ma mb iy lm b gy mc md l me mf">// src/main.ts</span><span id="f291" class="ma mb iy lm b gy mg md l me mf">await app.listen(3000, "0.0.0.0");</span></pre><p id="984e" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">太棒了，我们已经把我们的文件归档了，然后我们去测试吧。在终端中运行进行开发</p><pre class="ls lt lu lv gt lw lm lx ly aw lz bi"><span id="1d24" class="ma mb iy lm b gy mc md l me mf">docker-compose up</span></pre><figure class="ls lt lu lv gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi mh"><img src="../Images/1fe0e3e6a756be81cac4e1363d948516.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OIP2uy_JtYaTyCMdlCYKfA.png"/></div></div></figure><p id="b439" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们的应用程序正在运行</p></div><div class="ab cl kt ku hr kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ig ih ii ij ik"><h1 id="197e" class="mi mb iy bd mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne bi translated">棱柱形</h1><p id="48f1" class="pw-post-body-paragraph jv jw iy jx b jy nf ka kb kc ng ke kf kg nh ki kj kk ni km kn ko nj kq kr ks ig bi translated"><a class="ae nk" href="https://prisma.io" rel="noopener ugc nofollow" target="_blank"> Prisma </a>是一个开源ORM，它被用作编写普通SQL的替代方案，或者使用另一个数据库访问工具，如SQL查询构建器(如knex.js)或ORMs(如TypeORM和Sequelize)。</p><p id="dcff" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">开始安装Prisma CLI作为开发</p><pre class="ls lt lu lv gt lw lm lx ly aw lz bi"><span id="f161" class="ma mb iy lm b gy mc md l me mf">yarn add Prisma -D</span></pre><p id="979e" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">作为最佳实践，通过在CLI前面加上“npx”来本地调用CLI，使用“init”命令创建您的初始Prisma设置</p><pre class="ls lt lu lv gt lw lm lx ly aw lz bi"><span id="1550" class="ma mb iy lm b gy mc md l me mf">npx prisma init</span></pre><p id="e3d1" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">该命令使用以下内容创建一个新的Prisma目录</p><p id="fd4a" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">- `schema.prisma `:指定您的数据库连接并包含数据库模式<br/> - `.env `:一个dotenv文件，通常用于在一组环境变量中存储您的数据库凭证</p><p id="fcff" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">默认情况下，您的数据库连接设置为“postgresql”</p><pre class="ls lt lu lv gt lw lm lx ly aw lz bi"><span id="a163" class="ma mb iy lm b gy mc md l me mf">// prisma/schema.prisma</span><span id="3331" class="ma mb iy lm b gy mg md l me mf">generator client {<br/>  provider = "prisma-client-js"<br/>}</span><span id="99b8" class="ma mb iy lm b gy mg md l me mf">datasource db {<br/>  provider = "postgresql"<br/>  url      = env("DATABASE_URL")<br/>}</span></pre><p id="a519" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们的连接类型如何正确，我们将在`. env `中设置` DATABASE_URL '</p><pre class="ls lt lu lv gt lw lm lx ly aw lz bi"><span id="872f" class="ma mb iy lm b gy mc md l me mf"># .env</span><span id="95c9" class="ma mb iy lm b gy mg md l me mf">DATABASE_URL="postgresql://nestAuth:nestAuth@postgres:5432/nestAuth"</span></pre><p id="361c" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">记得在Github中创建资源库之前，在` . gitignore '中添加` . env '并创建` . env.example '</p><p id="c9f8" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">生成Prisma客户端需要“schema.prisma”文件。“复制prisma。/prisma/`复制整个prisma目录，以防您也需要迁移。</p><pre class="ls lt lu lv gt lw lm lx ly aw lz bi"><span id="caad" class="ma mb iy lm b gy mc md l me mf"># Dockerfile</span><span id="c901" class="ma mb iy lm b gy mg md l me mf">FROM node:alpine As development</span><span id="62fb" class="ma mb iy lm b gy mg md l me mf">WORKDIR /usr/src/app</span><span id="6a3e" class="ma mb iy lm b gy mg md l me mf">COPY package*.json ./</span><span id="2951" class="ma mb iy lm b gy mg md l me mf"># Here Prisma folder to the container<br/>COPY prisma ./prisma/</span><span id="9a73" class="ma mb iy lm b gy mg md l me mf">RUN yarn add glob rimraf</span><span id="e3f4" class="ma mb iy lm b gy mg md l me mf">RUN yarn --only=development</span><span id="f5eb" class="ma mb iy lm b gy mg md l me mf">COPY . .</span><span id="5d4e" class="ma mb iy lm b gy mg md l me mf">RUN yarn build</span><span id="6ead" class="ma mb iy lm b gy mg md l me mf">FROM node:alpine as production</span><span id="65a7" class="ma mb iy lm b gy mg md l me mf">ARG NODE_ENV=production<br/>ENV NODE_ENV=${NODE_ENV}</span><span id="cd1e" class="ma mb iy lm b gy mg md l me mf">WORKDIR /usr/src/app</span><span id="7536" class="ma mb iy lm b gy mg md l me mf">COPY package*.json ./</span><span id="8371" class="ma mb iy lm b gy mg md l me mf"># Here Prisma folder to the container<br/>COPY prisma ./prisma/</span><span id="72d7" class="ma mb iy lm b gy mg md l me mf">RUN yarn add glob rimraf</span><span id="f1b0" class="ma mb iy lm b gy mg md l me mf">RUN yarn --only=production</span><span id="c306" class="ma mb iy lm b gy mg md l me mf">COPY . .</span><span id="cc18" class="ma mb iy lm b gy mg md l me mf">COPY --from=development /usr/src/app/dist ./dist</span><span id="68ca" class="ma mb iy lm b gy mg md l me mf">CMD ["node", "dist/main"]</span></pre></div><div class="ab cl kt ku hr kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ig ih ii ij ik"><h1 id="f2cb" class="mi mb iy bd mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne bi translated">第一个模型</h1><p id="8fe2" class="pw-post-body-paragraph jv jw iy jx b jy nf ka kb kc ng ke kf kg nh ki kj kk ni km kn ko nj kq kr ks ig bi translated">现在，为了测试连接，我们将在“schema . prisma”insert中创建一个“用户”模型</p><pre class="ls lt lu lv gt lw lm lx ly aw lz bi"><span id="8d8f" class="ma mb iy lm b gy mc md l me mf">// prisma/schema.prisma</span><span id="70a7" class="ma mb iy lm b gy mg md l me mf">model User {<br/>  id        Int            <a class="ae nk" href="http://twitter.com/id" rel="noopener ugc nofollow" target="_blank">@id</a> <a class="ae nk" href="http://twitter.com/default" rel="noopener ugc nofollow" target="_blank">@default</a>(autoincrement())<br/>  email     String         <a class="ae nk" href="http://twitter.com/unique" rel="noopener ugc nofollow" target="_blank">@unique</a><br/>  name      String<br/>  password  String<br/>  createdAt DateTime       <a class="ae nk" href="http://twitter.com/default" rel="noopener ugc nofollow" target="_blank">@default</a>(now())<br/>  updatedAt DateTime       <a class="ae nk" href="http://twitter.com/updatedAt" rel="noopener ugc nofollow" target="_blank">@updatedAt</a><br/>}</span></pre><p id="1b18" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">有了模型，就可以生成SQL迁移文件，并对数据库运行它们。在这里，我使用“migrate dev”在开发模式下运行，并为迁移设置“init”名称</p><pre class="ls lt lu lv gt lw lm lx ly aw lz bi"><span id="1d8a" class="ma mb iy lm b gy mc md l me mf">npx prisma migrate dev --name init</span></pre><figure class="ls lt lu lv gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi nl"><img src="../Images/a99fe7a39855d1151bdfb6cadff47330.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MZBKCpddHVrRRZhm_Xm6SQ.png"/></div></div></figure><p id="8ce2" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">好消息是，我们的配置正在工作，现在我们的数据库与我们的应用程序同步👏</p></div><div class="ab cl kt ku hr kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ig ih ii ij ik"><h1 id="afaa" class="mi mb iy bd mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne bi translated">设置Prisma</h1><p id="98db" class="pw-post-body-paragraph jv jw iy jx b jy nf ka kb kc ng ke kf kg nh ki kj kk ni km kn ko nj kq kr ks ig bi translated">我们希望抽象出Prisma客户端API用于服务中的数据库查询。因此，让我们创建一个新的“PrismaService ”,它负责实例化和“PrismaClient”连接到您的数据库。</p><p id="32f7" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在“src”文件夹中创建一个“prisma.service.ts”</p><pre class="ls lt lu lv gt lw lm lx ly aw lz bi"><span id="e386" class="ma mb iy lm b gy mc md l me mf">// src/prisma.service.ts</span><span id="0bd2" class="ma mb iy lm b gy mg md l me mf">import { INestApplication, Injectable, OnModuleInit } from "<a class="ae nk" href="http://twitter.com/nestjs/common" rel="noopener ugc nofollow" target="_blank">@nestjs/common</a>";<br/>import { PrismaClient } from "<a class="ae nk" href="http://twitter.com/prisma/client" rel="noopener ugc nofollow" target="_blank">@prisma/client</a>";</span><span id="475b" class="ma mb iy lm b gy mg md l me mf"><a class="ae nk" href="http://twitter.com/Injectable" rel="noopener ugc nofollow" target="_blank">@Injectable</a>()<br/>export class PrismaService extends PrismaClient implements OnModuleInit {<br/>  async onModuleInit() {<br/>    await this.$connect();<br/>  }</span><span id="c121" class="ma mb iy lm b gy mg md l me mf">async enableShutdownHooks(app: INestApplication) {<br/>    this.$on("beforeExit", async () =&gt; {<br/>      await app.close();<br/>    });<br/>  }<br/>}</span></pre></div><div class="ab cl kt ku hr kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ig ih ii ij ik"><h1 id="6aa3" class="mi mb iy bd mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne bi translated">初制动</h1><p id="c96b" class="pw-post-body-paragraph jv jw iy jx b jy nf ka kb kc ng ke kf kg nh ki kj kk ni km kn ko nj kq kr ks ig bi translated">现在我们可以编写一个用户服务来进行数据库调用。因此，NestJs CLI有一个命令‘nest g’来生成服务、控制器、策略和其他结构。现在，我们跑</p><pre class="ls lt lu lv gt lw lm lx ly aw lz bi"><span id="92ec" class="ma mb iy lm b gy mc md l me mf">nest g service users</span></pre><p id="8b1b" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在开始创建服务之前，我们需要生成Prisma模型类型，我们可以用这个来生成</p><pre class="ls lt lu lv gt lw lm lx ly aw lz bi"><span id="a016" class="ma mb iy lm b gy mc md l me mf">npx prisma generate</span></pre><p id="5631" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在“src”文件夹中，该命令创建了一个包含“users.service.ts”和文件test“users . service . spec . ts”的“users”文件夹</p><p id="0ac0" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">- `user `:使用Prisma接口` Prisma . user where unique input ` forget user by unique columns<br/>-` create user `:使用接口` Prisma.userCreateInput `中的数据创建新用户，该接口在模型需要创建新寄存器时自动获取字段</p><p id="e284" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在“createUser”中，我们需要加密用户密码，因此让我们为此创建一个提供程序，在“src”文件夹中创建一个“providers”文件夹，并创建一个“password.ts”文件</p><pre class="ls lt lu lv gt lw lm lx ly aw lz bi"><span id="8581" class="ma mb iy lm b gy mc md l me mf">// src/providers/password.ts</span><span id="1aa7" class="ma mb iy lm b gy mg md l me mf">import { Injectable } from "<a class="ae nk" href="http://twitter.com/nestjs/common" rel="noopener ugc nofollow" target="_blank">@nestjs/common</a>";<br/>import * as bcrypt from "bcrypt";</span><span id="f174" class="ma mb iy lm b gy mg md l me mf">const SALT_OR_ROUNDS = 10;</span><span id="11a0" class="ma mb iy lm b gy mg md l me mf"><a class="ae nk" href="http://twitter.com/Injectable" rel="noopener ugc nofollow" target="_blank">@Injectable</a>()<br/>export class PasswordProvider {<br/>  async hashPassword(password: string): Promise&lt;string&gt; {<br/>    return bcrypt.hashSync(password, SALT_OR_ROUNDS);<br/>  }</span><span id="a44c" class="ma mb iy lm b gy mg md l me mf">async comparePassword(password: string, hash: string): Promise&lt;boolean&gt; {<br/>    return bcrypt.compareSync(password, hash);<br/>  }<br/>}</span></pre><p id="cbf3" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">该类有两个方法，“hashPassword”和“comparePassword ”,用于使用brcypt加密和比较密码。在“UsersService”类中，我们需要在构造函数中添加提供程序“PasswordProvider ”,以便在方法中使用。</p><pre class="ls lt lu lv gt lw lm lx ly aw lz bi"><span id="b1ea" class="ma mb iy lm b gy mc md l me mf">// src/users/users.service.ts</span><span id="aae6" class="ma mb iy lm b gy mg md l me mf">import { HttpException, HttpStatus, Injectable } from "<a class="ae nk" href="http://twitter.com/nestjs/common" rel="noopener ugc nofollow" target="_blank">@nestjs/common</a>";<br/>import { PrismaService } from "../prisma.service";<br/>import { User, Prisma } from "<a class="ae nk" href="http://twitter.com/prisma/client" rel="noopener ugc nofollow" target="_blank">@prisma/client</a>";<br/>import { PasswordProvider } from "src/providers/password";</span><span id="9d23" class="ma mb iy lm b gy mg md l me mf"><a class="ae nk" href="http://twitter.com/Injectable" rel="noopener ugc nofollow" target="_blank">@Injectable</a>()<br/>export class UsersService {<br/>  constructor(<br/>    private prisma: PrismaService,<br/>    private passwordProvider: PasswordProvider<br/>  ) {}</span><span id="a529" class="ma mb iy lm b gy mg md l me mf">async user(<br/>    userWhereUniqueInput: Prisma.UserWhereUniqueInput<br/>  ): Promise&lt;User | null&gt; {<br/>    const user = await this.prisma.user.findUnique({<br/>      where: userWhereUniqueInput,<br/>    });</span><span id="3ced" class="ma mb iy lm b gy mg md l me mf">delete user.password;</span><span id="63b9" class="ma mb iy lm b gy mg md l me mf">return user;<br/>  }</span><span id="fcf1" class="ma mb iy lm b gy mg md l me mf">async createUser(data: Prisma.UserCreateInput): Promise&lt;User&gt; {<br/>    const userExists = await this.prisma.user.findUnique({<br/>      where: { email: data.email },<br/>    });</span><span id="b9af" class="ma mb iy lm b gy mg md l me mf">if (userExists) {<br/>      throw new HttpException("User already exists", HttpStatus.CONFLICT);<br/>    }</span><span id="b0d7" class="ma mb iy lm b gy mg md l me mf">const passwordHashed = await this.passwordProvider.hashPassword(<br/>      data.password<br/>    );</span><span id="75d7" class="ma mb iy lm b gy mg md l me mf">const user = await this.prisma.user.create({<br/>      data: {<br/>        ...data,<br/>        password: passwordHashed,<br/>      },<br/>    });</span><span id="aa5a" class="ma mb iy lm b gy mg md l me mf">delete user.password;</span><span id="9835" class="ma mb iy lm b gy mg md l me mf">return user;<br/>  }<br/>}</span></pre><p id="82fc" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">创建服务后，让我们创建一个用于路由的控制器</p><pre class="ls lt lu lv gt lw lm lx ly aw lz bi"><span id="a612" class="ma mb iy lm b gy mc md l me mf">nest g controller users</span></pre><p id="a578" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个命令创建了“users.controller.ts”和“src/users”中的测试文件，所以让我们在控制器中创建两个函数</p><ul class=""><li id="091d" class="la lb iy jx b jy jz kc kd kg lc kk ld ko le ks lf lg lh li bi translated">` signUpUser `:运行` createUser `服务并从其返回数据<br/> - `getUserProfile `:获取路由发送的用户id并运行` User `服务来查找他们</li></ul><pre class="ls lt lu lv gt lw lm lx ly aw lz bi"><span id="d9a3" class="ma mb iy lm b gy mc md l me mf">// src/users/users.controller.ts</span><span id="8a2e" class="ma mb iy lm b gy mg md l me mf">import { Body, Controller, Get, Param, Post } from "<a class="ae nk" href="http://twitter.com/nestjs/common" rel="noopener ugc nofollow" target="_blank">@nestjs/common</a>";<br/>import { User } from "<a class="ae nk" href="http://twitter.com/prisma/client" rel="noopener ugc nofollow" target="_blank">@prisma/client</a>";<br/>import { UsersService } from "./users.service";</span><span id="4442" class="ma mb iy lm b gy mg md l me mf">// Set prefix route for this group. Ex.: for get profile /users/8126321<br/><a class="ae nk" href="http://twitter.com/Controller" rel="noopener ugc nofollow" target="_blank">@Controller</a>("users")<br/>export class UsersController {<br/>  constructor(private readonly usersService: UsersService) {}<br/>  // Create user -&gt; POST /users<br/>  <a class="ae nk" href="http://twitter.com/Post" rel="noopener ugc nofollow" target="_blank">@Post</a>()<br/>  async signupUser(<br/>    <a class="ae nk" href="http://twitter.com/Body" rel="noopener ugc nofollow" target="_blank">@Body</a>() userData: { name: string; email: string; password: string }<br/>  ): Promise&lt;User&gt; {<br/>    return this.usersService.createUser(userData);<br/>  }</span><span id="4da2" class="ma mb iy lm b gy mg md l me mf">// Get user Profile -&gt; GET /users/:id<br/>  <a class="ae nk" href="http://twitter.com/Get" rel="noopener ugc nofollow" target="_blank">@Get</a>("/:id")<br/>  async profile(<a class="ae nk" href="http://twitter.com/Param" rel="noopener ugc nofollow" target="_blank">@Param</a>("id") id: number): Promise&lt;User&gt; {<br/>    return this.usersService.user({ id: Number(id) });<br/>  }<br/>}</span></pre><p id="d494" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在“users.module.ts”文件中，我们需要添加提供者、导出和控制器数组。</p><pre class="ls lt lu lv gt lw lm lx ly aw lz bi"><span id="3278" class="ma mb iy lm b gy mc md l me mf">// src/users/users.module.ts</span><span id="f1be" class="ma mb iy lm b gy mg md l me mf">import { Module } from "<a class="ae nk" href="http://twitter.com/nestjs/common" rel="noopener ugc nofollow" target="_blank">@nestjs/common</a>";<br/>import { PrismaService } from "src/prisma.service";<br/>import { PasswordProvider } from "src/providers/password";<br/>import { UsersController } from "./users.controller";<br/>import { UsersService } from "./users.service";</span><span id="cf33" class="ma mb iy lm b gy mg md l me mf"><a class="ae nk" href="http://twitter.com/Module" rel="noopener ugc nofollow" target="_blank">@Module</a>({<br/>  providers: [PasswordProvider, UsersService, PrismaService],<br/>  exports: [UsersService],<br/>  controllers: [UsersController],<br/>})<br/>export class UsersModule {}</span></pre><p id="668b" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">并将“UsersModule”传递给“AppModule”以供使用。</p><pre class="ls lt lu lv gt lw lm lx ly aw lz bi"><span id="e2d6" class="ma mb iy lm b gy mc md l me mf">//src/app.module.ts</span><span id="12fb" class="ma mb iy lm b gy mg md l me mf">import { Module } from "<a class="ae nk" href="http://twitter.com/nestjs/common" rel="noopener ugc nofollow" target="_blank">@nestjs/common</a>";<br/>import { AppController } from "./app.controller";<br/>import { PrismaService } from "./prisma.service";<br/>import { UsersModule } from "./users/users.module";<br/>import { UsersService } from "./users/users.service";<br/>import { PasswordProvider } from "./providers/password";</span><span id="efc5" class="ma mb iy lm b gy mg md l me mf"><a class="ae nk" href="http://twitter.com/Module" rel="noopener ugc nofollow" target="_blank">@Module</a>({<br/>  imports: [UsersModule],<br/>  controllers: [AppController],<br/>  providers: [PrismaService, UsersService, PasswordProvider],<br/>})<br/>export class AppModule {}</span></pre></div><div class="ab cl kt ku hr kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ig ih ii ij ik"><h1 id="b338" class="mi mb iy bd mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne bi translated">让我们测试一下</h1><p id="cac3" class="pw-post-body-paragraph jv jw iy jx b jy nf ka kb kc ng ke kf kg nh ki kj kk ni km kn ko nj kq kr ks ig bi translated">现在让我们的码头集装箱</p><pre class="ls lt lu lv gt lw lm lx ly aw lz bi"><span id="5ffb" class="ma mb iy lm b gy mc md l me mf">docker-compose up</span></pre><figure class="ls lt lu lv gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi mh"><img src="../Images/1fe0e3e6a756be81cac4e1363d948516.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OIP2uy_JtYaTyCMdlCYKfA.png"/></div></div></figure><p id="339f" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">就是这样！应用程序正在运行👏</p><p id="a3df" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，在Postman中，让我们尝试使用“创建用户”和“获取配置文件”路径</p><pre class="ls lt lu lv gt lw lm lx ly aw lz bi"><span id="2647" class="ma mb iy lm b gy mc md l me mf">curl --location --request POST '<a class="ae nk" href="http://0.0.0.0:3000/users'" rel="noopener ugc nofollow" target="_blank">http://0.0.0.0:3000/users'</a> \<br/>--header 'Content-Type: application/json' \<br/>--data-raw '{<br/>    "email": "<a class="ae nk" href="mailto:test@e3x.com" rel="noopener ugc nofollow" target="_blank">test@e3x.com</a>",<br/>    "name": "Gabriel Menezes",<br/>    "password": "123123"<br/>}'</span></pre><figure class="ls lt lu lv gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi nm"><img src="../Images/0e43eedecff3e2da4082f1b7c774d79c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AmDYtUWerkbd8HSHZYG6uQ.png"/></div></div></figure><pre class="ls lt lu lv gt lw lm lx ly aw lz bi"><span id="7bef" class="ma mb iy lm b gy mc md l me mf">curl --location --request GET '<a class="ae nk" href="http://0.0.0.0:3000/users/37'" rel="noopener ugc nofollow" target="_blank">http://0.0.0.0:3000/users/37'</a></span></pre><figure class="ls lt lu lv gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi nm"><img src="../Images/56fab9335b33424e944c6856a152e738.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mLrR-QXH429m8bol-gP7tA.png"/></div></div></figure></div><div class="ab cl kt ku hr kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ig ih ii ij ik"><h1 id="9025" class="mi mb iy bd mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne bi translated">直到下次</h1><p id="7cab" class="pw-post-body-paragraph jv jw iy jx b jy nf ka kb kc ng ke kf kg nh ki kj kk ni km kn ko nj kq kr ks ig bi translated">这就是我们在本文中要讨论的全部内容，我们对应用程序进行dockerize，设置Prisma，并创建两条路线。在本系列的下一篇文章中，我们将创建和定义我们的身份验证提供者，以便在我们的应用程序中进行身份验证。</p><p id="3c7b" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">感谢您的阅读！</p></div><div class="ab cl kt ku hr kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ig ih ii ij ik"><p id="e376" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">https://github.com/mnzsss/nest-auth-explained<a class="ae nk" href="https://github.com/mnzsss/nest-auth-explained" rel="noopener ugc nofollow" target="_blank"/></p></div><div class="ab cl kt ku hr kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ig ih ii ij ik"><h1 id="53d3" class="mi mb iy bd mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne bi translated">参考</h1><p id="5c15" class="pw-post-body-paragraph jv jw iy jx b jy nf ka kb kc ng ke kf kg nh ki kj kk ni km kn ko nj kq kr ks ig bi translated">- <a class="ae nk" href="https://dev.to/erezhod/setting-up-a-nestjs-project-with-docker-for-back-end-development-30lg" rel="noopener ugc nofollow" target="_blank">用Docker为后端开发建立一个NestJS项目</a> <br/> - <a class="ae nk" href="https://notiz.dev/blog/dockerizing-nestjs-with-prisma-and-postgresql" rel="noopener ugc nofollow" target="_blank">用Prisma和PostgreSQL对一个NestJS应用进行Docker化</a></p></div></div>    
</body>
</html>