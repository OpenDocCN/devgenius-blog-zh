<html>
<head>
<title>Ruby on Rails — Best Practices Every Developer Should Know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ruby on Rails——每个开发人员都应该知道的最佳实践</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/ruby-on-rails-best-practices-every-developer-should-know-ebff44e87da2?source=collection_archive---------0-----------------------#2022-09-20">https://blog.devgenius.io/ruby-on-rails-best-practices-every-developer-should-know-ebff44e87da2?source=collection_archive---------0-----------------------#2022-09-20</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/cd34e2f887e4a823865e30ab44bff129.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gRMhl3EXnQDsxChmMp8v9g.png"/></div></div></figure><p id="ba2e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">本文用真实的例子解释了使用 Ruby on Rails 开发应用程序时应该遵循的最佳实践！</p><p id="d8b6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这些是我们通过阅读这篇文章所要达到的目标，并希望最终作为一名开发人员达到内心平静的最高境界:)</p><ol class=""><li id="d575" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated">代码可重用性</li><li id="d5a8" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">高速度</li><li id="55d6" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">表演</li><li id="a64f" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">可维护性</li></ol><h1 id="7926" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">内容</h1><ol class=""><li id="5b49" class="kt ku in jx b jy mf kc mg kg mh kk mi ko mj ks ky kz la lb bi translated">Ruby on Rails 的哲学</li><li id="4523" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">胖模特瘦控制器</li><li id="2a0f" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">模块利用率</li><li id="d5e3" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">N+1 查询问题</li><li id="938e" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">预加载数据</li><li id="987d" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">自定义控制器操作</li><li id="db3f" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">参数验证</li><li id="c121" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">路线约定</li><li id="380a" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">必备宝石</li><li id="62ae" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">结论</li></ol><h1 id="b853" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">Ruby on Rails 的哲学</h1><p id="f76e" class="pw-post-body-paragraph jv jw in jx b jy mf ka kb kc mg ke kf kg mk ki kj kk ml km kn ko mm kq kr ks ig bi translated">在我们进入 Ruby on Rails 的最佳实践之前，我们需要理解它试图暗示给开发者的理念。</p><h2 id="5b81" class="mn li in bd lj mo mp dn ln mq mr dp lr kg ms mt lv kk mu mv lz ko mw mx md my bi translated">约定胜于配置</h2><p id="b52d" class="pw-post-body-paragraph jv jw in jx b jy mf ka kb kc mg ke kf kg mk ki kj kk ml km kn ko mm kq kr ks ig bi translated">这是在开发 Ruby on Rails 时被牢记的一个设计范例。由于这种理念，应用程序的开发时间大大减少了，因为 Rails 提供了方法、函数、面向对象的原则以及更多现成的东西，这使得使用它的开发人员的生活更加简单。</p><h2 id="3888" class="mn li in bd lj mo mp dn ln mq mr dp lr kg ms mt lv kk mu mv lz ko mw mx md my bi translated">不要重复自己的话</h2><p id="083f" class="pw-post-body-paragraph jv jw in jx b jy mf ka kb kc mg ke kf kg mk ki kj kk ml km kn ko mm kq kr ks ig bi translated">Ruby on Rails 提供了各种特性(其中一些我们将在本文中介绍),使开发人员不必重复代码和重用现有代码，从而减少开发时间，提高可读性，并轻松维护应用程序。</p></div><div class="ab cl mz na hr nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ig ih ii ij ik"><p id="6118" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下面是我在解释最佳实践时将参考的 DB 模式。这是一个非常基本的网站实现，允许用户在出版物下写博客和发布博客。</p><figure class="nh ni nj nk gt jo gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/362c66a050e8cdbcd53f3917d1c12ad8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1228/format:webp/1*gGBKFO-AHwuw5Nt620ruqQ.png"/></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated">本文遵循的数据库模式</figcaption></figure><p id="27bc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">博客表中的<code class="fe np nq nr ns b">content</code>是一个<code class="fe np nq nr ns b">jsonb</code>格式类型，存储博客的<code class="fe np nq nr ns b">keywords</code> &amp; <code class="fe np nq nr ns b">body</code>。</p><p id="6ca3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们跳到使用 Ruby on Rails 创建健壮的、可伸缩的后端应用程序时要遵循的最佳实践！</p><h1 id="8ea4" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">胖模特瘦控制器</h1><p id="dd73" class="pw-post-body-paragraph jv jw in jx b jy mf ka kb kc mg ke kf kg mk ki kj kk ml km kn ko mm kq kr ks ig bi translated">在创建新的 API 时，我们总是希望记住的一件主要事情是，API 应该尽可能简单，最简单的 API 不处理任何业务逻辑，只处理请求和响应。实现这一点的一种方法是将一些业务逻辑外包给模型本身，这些逻辑用于业务逻辑。</p><p id="75f0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们考虑一下，我们想要获取出现在博客正文中的关键字的<strong class="jx io">频率。</strong></p><figure class="nh ni nj nk gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nt"><img src="../Images/99a19249e67725c625550ddf0a16fefd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oCfWwCeE9Esk9u1JFexFAw.jpeg"/></div></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated">获取博客模型中关键词的频率</figcaption></figure><p id="30c9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是控制器的样子。</p><figure class="nh ni nj nk gt jo gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/5abba5d23b452420fc86853a50266d6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1234/format:webp/1*Ieoqbil__7SJAptxjrhyqQ.jpeg"/></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated">获取关键字控制器的频率</figcaption></figure><p id="973e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">获取关键字频率的整个逻辑也可以很容易地写在控制器中，API 响应不会有任何变化。但是如果你仔细想想，这不仅使你的控制器可读性更好，而且这个函数在其他 API 中也很有用，从而使它成为一段潜在的可重用代码！</p><blockquote class="nv"><p id="3f46" class="nw nx in bd ny nz oa ob oc od oe ks dk translated">如果您认为一段代码以后可能会被重用，那么将来很可能会是这样。</p></blockquote><h1 id="ab93" class="lh li in bd lj lk ll lm ln lo lp lq lr ls of lu lv lw og ly lz ma oh mc md me bi translated">模块利用率</h1><p id="5dfe" class="pw-post-body-paragraph jv jw in jx b jy mf ka kb kc mg ke kf kg mk ki kj kk ml km kn ko mm kq kr ks ig bi translated">现在，让我们说有不能卸载到模型的需求，然后<strong class="jx io">模块</strong>是你最好的朋友，为了保持你的控制器干净。</p><p id="dd42" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一个例子是，您想要获取特定用户的博客，那么获取用户数据并将其映射到散列的代码可以编写在一个模块中。姑且称之为<code class="fe np nq nr ns b">BlogHelper</code>，可以在 Rails 已经提供的<code class="fe np nq nr ns b">helpers</code>文件夹下创建。</p><figure class="nh ni nj nk gt jo gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/86f796f6baa085439561f1c96cb0e112.png" data-original-src="https://miro.medium.com/v2/resize:fit:1074/format:webp/1*O950jfnYoYipo_F6VT2i_g.jpeg"/></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated">使用助手功能获取用户博客</figcaption></figure><p id="35ba" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是控制器的样子:</p><figure class="nh ni nj nk gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi oj"><img src="../Images/f99194671e4fe9f7d268dfb83ee4b7b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OL8kch5rW25nAI40rO7VjQ.jpeg"/></div></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated">获取用户博客控制器</figcaption></figure><p id="9794" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">注意我们的示例 DB 模式中模块和模型的区别？</p><blockquote class="nv"><p id="1883" class="nw nx in bd ny nz oa ob oc od oe ks dk translated">当我们处理一个实体时，我们应该创建一个模型函数，当我们处理 N 个实体时，我们应该创建一个模块函数。</p></blockquote><p id="ef6e" class="pw-post-body-paragraph jv jw in jx b jy ok ka kb kc ol ke kf kg om ki kj kk on km kn ko oo kq kr ks ig bi translated">这不是模块函数的唯一用途，它还可以用于创建其他类型的可重用函数。一个例子是，如果您必须进行与时间相关的计算或实现任何自定义算法。</p><h1 id="4d45" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">N+1 查询问题</h1><p id="ac71" class="pw-post-body-paragraph jv jw in jx b jy mf ka kb kc mg ke kf kg mk ki kj kk ml km kn ko mm kq kr ks ig bi translated">这是一个非常常见的对象关系映射问题，忽略这个问题很容易，因为 Rails 借助 ActiveRecord &amp; Models 抽象出了数据库查询。</p><blockquote class="nv"><p id="5970" class="nw nx in bd ny nz oa ob oc od oe ks dk translated">当您运行数据库查询来获取父表的 id，并使用这些 id 在子表上逐个进行 N 次查询时，问题就出现了，这就形成了 N+1 查询问题。</p></blockquote><p id="e8d1" class="pw-post-body-paragraph jv jw in jx b jy ok ka kb kc ol ke kf kg om ki kj kk on km kn ko oo kq kr ks ig bi translated">这个问题的解决方案是运行恒定数量的查询。</p><p id="66ba" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在牢记 DB 模式的同时，我能想到的一个例子是，如果我们想创建一个 API，在数据库中存储 N 个博客。</p><p id="5499" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">天真的做法是:</p><figure class="nh ni nj nk gt jo gh gi paragraph-image"><div class="gh gi op"><img src="../Images/68440516fc705df6f63f3b16a934823e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1314/format:webp/1*j_6rzulXhE91ohbb0MeHJg.jpeg"/></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated">保存博客— N+1 查询问题</figcaption></figure><p id="eac8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">第一个查询用于获取使用电子邮件创建博客的用户。接下来的 N 个查询在<code class="fe np nq nr ns b">blogs.each</code>循环中执行，其中<strong class="jx io">博客一次保存一个</strong>。</p><p id="3b56" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">达到相同结果的更好方法:</p><figure class="nh ni nj nk gt jo gh gi paragraph-image"><div class="gh gi op"><img src="../Images/6bd1e016000c54271393eb40ca0c9c07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1314/format:webp/1*i1b1i-YZu5Gykmkg2Zgw8g.jpeg"/></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated">批量保存博客— N+1 查询解决方案</figcaption></figure><p id="d01f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">第一个查询按原样执行。但是在循环中，我们只创建博客对象并将它们添加到一个数组中。一旦循环完成，我们使用一个查询保存所有的 Blog 对象。总之，这个函数只需要 2 次数据库查询！</p><p id="1ae8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe np nq nr ns b">Model.import!</code>不是 Rails 开箱即用的特性，但是我们可以这样做，因为有一个神奇的 Gem 叫做<a class="ae oq" href="https://github.com/zdennis/activerecord-import" rel="noopener ugc nofollow" target="_blank"> activerecord-import </a>！</p><h1 id="c75c" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">预加载数据</h1><p id="bcc0" class="pw-post-body-paragraph jv jw in jx b jy mf ka kb kc mg ke kf kg mk ki kj kk ml km kn ko mm kq kr ks ig bi translated">预加载数据意味着从数据库预取数据，以减少后端应用程序的查询次数。</p><p id="7470" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">假设我们想要获取某个出版物下的某个用户的博客。</p><figure class="nh ni nj nk gt jo gh gi paragraph-image"><div class="gh gi or"><img src="../Images/5eb7a71155059675b41e12a14ad37def.png" data-original-src="https://miro.medium.com/v2/resize:fit:1386/format:webp/1*a_YxK-2Ib2UY7fIDetSkmw.jpeg"/></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated">获取用户博客—不预加载数据</figcaption></figure><p id="4c49" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">第一个查询是获取用户的发布-博客映射。然后，我们遍历该数组，使用<code class="fe np nq nr ns b">publication.blog</code>在第 7 行找到博客。这是可能的，因为我们已经创建了一个 ActiveRecord 关联。很棒吧？不完全是。</p><blockquote class="nv"><p id="ba6c" class="nw nx in bd ny nz oa ob oc od oe ks dk translated">这是 N+1 查询问题的另一种情况。</p></blockquote><p id="f960" class="pw-post-body-paragraph jv jw in jx b jy ok ka kb kc ol ke kf kg om ki kj kk on km kn ko oo kq kr ks ig bi translated">为了更好地理解这一点，让我们深入一点。</p><p id="4132" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在我的本地数据库中，我已经创建了 3 个 Publication-Blog 映射，一旦我运行了上面的代码，Rails 就会进行 3 次数据库查询，每次获取一个 Blog。</p><figure class="nh ni nj nk gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi os"><img src="../Images/54203d533c49823ba4a58554a796cc42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NC8T8NZxNoDcVb3U1DtI4g.png"/></div></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated">预加载前查询日志</figcaption></figure><p id="8266" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了解决这个问题，我们不需要做太多。我们只需要改变我们最初的查询。</p><figure class="nh ni nj nk gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ot"><img src="../Images/e1482c856de74f75b4a4b25126d6447e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dUEtzVE54_f-tbnnY9y7zg.jpeg"/></div></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated">获取用户博客—预加载数据</figcaption></figure><p id="c738" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe np nq nr ns b">includes</code>是一种预加载数据的方式，您可以提供相关的模型来获取数据并将其存储在 RAM 中。这是 Rails 服务器日志上的输出:</p><figure class="nh ni nj nk gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ou"><img src="../Images/5dec0cc42d08697b43243f5347d07235.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0Mniu02SyLSmkShGA3Xp1w.png"/></div></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated">预加载后查询日志</figcaption></figure><p id="df68" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">瞧啊。预加载后，只使用一组 id 进行了一次查询，从数据库中获取所有博客。这就是 Ruby on Rails 的魅力所在，只需做一个简单的改变，我们就能以更好的性能达到同样的效果！</p><p id="3279" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们可以更进一步。注意另外两个数据库调用<code class="fe np nq nr ns b">User</code> &amp; <code class="fe np nq nr ns b">PublicationBlogMapping</code>模型？</p><figure class="nh ni nj nk gt jo gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/369ce5d35c5d3ebd4685709be2baf28b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1114/format:webp/1*QHtU8SHOoFjwmYVQdz21xw.jpeg"/></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated">获取用户博客——急切地加载数据</figcaption></figure><p id="8fbf" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">急切加载基本上试图在一个数据库查询中获取所有内容。</p><figure class="nh ni nj nk gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ca"><img src="../Images/5e219240cf3a0314726dcaa3bd95f196.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-0ippqQi8Rf4cjt4hUC-EA.png"/></div></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated">急切加载后查询日志</figcaption></figure><p id="cd93" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">正如我们所看到的，对整个 API 进行了一次查询。但是我们也可以看到数据库查询是多么的庞大和复杂。这种方法不应该用于所有情况，它只在某些情况下有用，所以要谨慎使用。有时运行 3 个小查询比运行一个复杂的查询更好。在我们的例子中，<code class="fe np nq nr ns b">includes</code>方法更好。我们可以通过查看服务器日志中执行的查询来决定是使用<code class="fe np nq nr ns b">includes</code>还是<code class="fe np nq nr ns b">eager_load</code>。</p><h1 id="b6b4" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">自定义控制器操作</h1><p id="9c06" class="pw-post-body-paragraph jv jw in jx b jy mf ka kb kc mg ke kf kg mk ki kj kk ml km kn ko mm kq kr ks ig bi translated">如果我们想用一个或多个 API 来处理数据，我们应该考虑使用定制的控制器动作。</p><p id="c05a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们为我们的一个示例模型考虑以下 3 个 API:</p><ol class=""><li id="2259" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated">通过 ID 获取博客</li><li id="9915" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">按 ID 更新博客</li><li id="12b2" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">按 ID 删除博客</li></ol><p id="5044" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你注意到，有一个共同点。<strong class="jx io">博客 ID </strong>。</p><p id="8308" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们首先要做的一件显而易见的事情是，借助 ID 来验证博客是否存在。</p><figure class="nh ni nj nk gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ow"><img src="../Images/db0ddecc52c6c782b65cc8319f6279e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lRdaoevQnAH5l17UR5gBHg.jpeg"/></div></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated">自定义控制器操作</figcaption></figure><p id="97e2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">是不是很神奇？我们可以使用这个内置的 Rails 特性，在实际的 API 之前执行给定的函数，而不是在每个控制器中添加这 4 行代码。</p><p id="5fd0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这不仅使我们的代码可重用，而且如果你注意到的话，它还实现了一种基本形式的<strong class="jx io">访问控制</strong>。在第 6 行，用户也被添加到数据库查询中，这确保用户只能获得他们写的博客。</p><h1 id="9c2e" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">参数验证</h1><p id="a6c5" class="pw-post-body-paragraph jv jw in jx b jy mf ka kb kc mg ke kf kg mk ki kj kk ml km kn ko mm kq kr ks ig bi translated">这是一个需要在编写 API 时进行一些初始工作的步骤，但这是一个很好的实践，在以下方面很有用:</p><ol class=""><li id="5712" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated">帮助其他开发人员在开发过程中不犯错误，不破坏代码。</li><li id="041e" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">防止恶意用户发送损坏的数据。</li></ol><p id="8e90" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">有一个 gem 使我们能够轻松地向我们的路线添加参数验证— <a class="ae oq" href="https://github.com/nicolasblanco/rails_param" rel="noopener ugc nofollow" target="_blank"> rails-param </a>！</p><p id="7c6a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下面是一个示例，说明如果 API 需要这些数据，参数验证会是什么样子:</p><pre class="nh ni nj nk gt ox ns oy oz aw pa bi"><span id="0c6e" class="mn li in ns b gy pb pc l pd pe">{<br/>  "name": "Blog 1",<br/>  "content": {<br/>    "keywords": ["keyword 1", "keyword 2"],<br/>    "body": "This is dummy text."<br/>  }<br/>}</span></pre><figure class="nh ni nj nk gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi pf"><img src="../Images/2c4b8dbc953e1e449afac4a9fdeca941.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J_X8UMeB5K7E4hrUrNR0Ow.jpeg"/></div></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated">参数验证</figcaption></figure><h1 id="63a0" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">路线约定</h1><p id="55d2" class="pw-post-body-paragraph jv jw in jx b jy mf ka kb kc mg ke kf kg mk ki kj kk ml km kn ko mm kq kr ks ig bi translated">每个人都有自己构造 API 路由、API 函数名和 HTTP 方法的方式。不管你用什么方法，只要确保保持一致。</p><p id="1efa" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是，Rails 向其开发人员暗示了一种常见的方式，记住约定胜于配置！如果我们记住我们的例子，前 5 个 API 是根据 Rails 编写 API 的理想方式。</p><figure class="nh ni nj nk gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi pg"><img src="../Images/da04e7fdadc98cbb967090732bee562f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3PV-lLxasBgiyBLkc_8VVg.jpeg"/></div></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated">路线约定</figcaption></figure><blockquote class="ph pi pj"><p id="e7e9" class="jv jw pk jx b jy jz ka kb kc kd ke kf pl kh ki kj pm kl km kn pn kp kq kr ks ig bi translated">获取—索引-&gt;获取所有博客</p><p id="c343" class="jv jw pk jx b jy jz ka kb kc kd ke kf pl kh ki kj pm kl km kn pn kp kq kr ks ig bi translated">发布—创建-&gt;创建博客</p><p id="3d72" class="jv jw pk jx b jy jz ka kb kc kd ke kf pl kh ki kj pm kl km kn pn kp kq kr ks ig bi translated">GET /:blog_id — show -&gt;按 id 获取博客</p><p id="cc22" class="jv jw pk jx b jy jz ka kb kc kd ke kf pl kh ki kj pm kl km kn pn kp kq kr ks ig bi translated">PATCH /:blog_id — update -&gt;按 id 更新博客</p><p id="c742" class="jv jw pk jx b jy jz ka kb kc kd ke kf pl kh ki kj pm kl km kn pn kp kq kr ks ig bi translated">DELETE /:blog_id —删除-&gt;按 id 删除博客</p></blockquote><p id="423d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">以上路线我们甚至不需要写。Ruby on Rails 为我们提供了一种更简单的方法来达到同样的效果！</p><figure class="nh ni nj nk gt jo gh gi paragraph-image"><div class="gh gi po"><img src="../Images/814623ec0e55dbe9be4a1de6e4f44c9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1282/format:webp/1*Bl3U7HK22knU4eEOSf3FIg.jpeg"/></div><figcaption class="nl nm gj gh gi nn no bd b be z dk translated">Rails 隐含的路由约定</figcaption></figure><p id="ca42" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe np nq nr ns b">routes.rb</code>中的<code class="fe np nq nr ns b">resources</code>表示前面提到的所有路线。</p><p id="1251" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这些只是惯例，但是请记住，你可以用自己的方式做事。这个想法是，如果每个开发人员都遵循相同的约定，那么代码库就会自动变得更具可读性和可维护性。</p><h1 id="a658" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">必备宝石</h1><h2 id="ade0" class="mn li in bd lj mo mp dn ln mq mr dp lr kg ms mt lv kk mu mv lz ko mw mx md my bi translated">参数验证:<a class="ae oq" href="https://github.com/nicolasblanco/rails_param" rel="noopener ugc nofollow" target="_blank"> rails-param </a></h2><p id="1d2d" class="pw-post-body-paragraph jv jw in jx b jy mf ka kb kc mg ke kf kg mk ki kj kk ml km kn ko mm kq kr ks ig bi translated">正如已经讨论过的，这个 Gem 帮助我们轻松地向我们的 API 添加健壮的参数验证。</p><h2 id="2169" class="mn li in bd lj mo mp dn ln mq mr dp lr kg ms mt lv kk mu mv lz ko mw mx md my bi translated">案例转换:<a class="ae oq" href="https://github.com/ohler55/oj" rel="noopener ugc nofollow" target="_blank"> oj </a></h2><p id="0a27" class="pw-post-body-paragraph jv jw in jx b jy mf ka kb kc mg ke kf kg mk ki kj kk ml km kn ko mm kq kr ks ig bi translated">这是一个解决前端和后端开发者之间永无休止的战争的宝石:)通常，前端遵循的用例约定是<code class="fe np nq nr ns b">camelCase</code>，后端遵循的用例约定是<code class="fe np nq nr ns b">snake_case</code>。</p><p id="5d45" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一旦<code class="fe np nq nr ns b">oj</code>被配置，它就充当一个拦截器，可以改变<strong class="jx io">传入请求</strong>中每个键的大小写，也可以改变作为<strong class="jx io">传出响应</strong>发送的每个键的大小写。</p><h2 id="c30a" class="mn li in bd lj mo mp dn ln mq mr dp lr kg ms mt lv kk mu mv lz ko mw mx md my bi translated">实施最佳编码实践:<a class="ae oq" href="https://github.com/rubocop/rubocop-rails" rel="noopener ugc nofollow" target="_blank"> rubocop </a></h2><p id="f572" class="pw-post-body-paragraph jv jw in jx b jy mf ka kb kc mg ke kf kg mk ki kj kk ml km kn ko mm kq kr ks ig bi translated">顾名思义，Rubocop 是一块宝石，可用于在项目中实施最佳编码实践。它还提供了配置实施和不实施哪些实践的能力。</p><h2 id="ffe0" class="mn li in bd lj mo mp dn ln mq mr dp lr kg ms mt lv kk mu mv lz ko mw mx md my bi translated">认证:<a class="ae oq" href="https://github.com/jinzhu/devise" rel="noopener ugc nofollow" target="_blank">设计</a> &amp; <a class="ae oq" href="https://github.com/waiting-for-dev/devise-jwt" rel="noopener ugc nofollow" target="_blank">设计-jwt </a></h2><p id="fe72" class="pw-post-body-paragraph jv jw in jx b jy mf ka kb kc mg ke kf kg mk ki kj kk ml km kn ko mm kq kr ks ig bi translated">这些宝石帮助我们不必担心处理用户认证、令牌到期逻辑、电子邮件验证等等！</p><h2 id="58b8" class="mn li in bd lj mo mp dn ln mq mr dp lr kg ms mt lv kk mu mv lz ko mw mx md my bi translated">调试器:<a class="ae oq" href="https://github.com/pry/pry" rel="noopener ugc nofollow" target="_blank">撬</a></h2><p id="c9a7" class="pw-post-body-paragraph jv jw in jx b jy mf ka kb kc mg ke kf kg mk ki kj kk ml km kn ko mm kq kr ks ig bi translated">伟大的宝石实时调试 API，并找到那些棘手的错误！</p><h2 id="c4c5" class="mn li in bd lj mo mp dn ln mq mr dp lr kg ms mt lv kk mu mv lz ko mw mx md my bi translated">N+1 查询查找器:<a class="ae oq" href="https://github.com/flyerhzm/bullet" rel="noopener ugc nofollow" target="_blank">项目符号</a></h2><p id="6373" class="pw-post-body-paragraph jv jw in jx b jy mf ka kb kc mg ke kf kg mk ki kj kk ml km kn ko mm kq kr ks ig bi translated">这是一个在 API 中发现 N+1 个查询并推荐我们如何解决问题的 Gem。</p><h1 id="79fc" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">结论</h1><p id="72d1" class="pw-post-body-paragraph jv jw in jx b jy mf ka kb kc mg ke kf kg mk ki kj kk ml km kn ko mm kq kr ks ig bi translated">归根结底，开发产品时速度是最重要的，可能是任何框架或工具。但与此同时，我们不应该忽视我们编写的代码的质量。我知道在某些情况下，我们不能遵循所有的最佳实践，但是我们应该尝试实现尽可能多的实践，或者至少在解决方案中添加 TODO 语句，以便以后可以解决它。</p><figure class="nh ni nj nk gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi pp"><img src="../Images/7105401ed53601131f0e910f557c2705.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*74U2vigBYfgtO4SW54L4NA.jpeg"/></div></div></figure><p id="69cb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">谢谢你能走到这一步！希望你在读完这篇文章后学到了一些东西。我也希望你尽快找到你的代码库，并尝试实现这些最佳实践，找到内心的平静。</p></div><div class="ab cl mz na hr nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ig ih ii ij ik"><p id="d183" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果您想参考本文中示例所用的代码库，这里有 GitHub 库。</p><div class="pq pr gp gr ps pt"><a href="https://github.com/interviewstreet/rails-boilerplate-2022" rel="noopener  ugc nofollow" target="_blank"><div class="pu ab fo"><div class="pv ab pw cl cj px"><h2 class="bd io gy z fp py fr fs pz fu fw im bi translated">GitHub-interview street/rails-样板文件-2022</h2><div class="qa l"><h3 class="bd b gy z fp py fr fs pz fu fw dk translated">这是一个预配置的 Rails 样板文件，包含截至 9 月的最新 Ruby (v3.1.3)和 Rails(v7.0.2)版本…</h3></div><div class="qb l"><p class="bd b dl z fp py fr fs pz fu fw dk translated">github.com</p></div></div><div class="qc l"><div class="qd l qe qf qg qc qh jt pt"/></div></div></a></div></div></div>    
</body>
</html>