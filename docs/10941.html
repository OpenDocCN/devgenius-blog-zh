<html>
<head>
<title>Making realistic Christmas ball animation in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在 React 中制作逼真的圣诞球动画</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/making-realistic-christmas-ball-animation-in-react-6f28ee54cbf4?source=collection_archive---------10-----------------------#2022-12-08">https://blog.devgenius.io/making-realistic-christmas-ball-animation-in-react-6f28ee54cbf4?source=collection_archive---------10-----------------------#2022-12-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="bc64" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">很快就要过圣诞节和除夕了。所以是时候做一些能让你保持好心情的可爱效果了。为此，我将制作一个圣诞球摆动的动画。</p><h2 id="122f" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated"><strong class="ak">什么是“写实”？</strong></h2><p id="b229" class="pw-post-body-paragraph jk jl in jm b jn lb jp jq jr lc jt ju jv ld jx jy jz le kb kc kd lf kf kg kh ig bi translated">动画要对应一些物理规律，好像球要在我们的世界里摆动。在现实世界中，球不会无休止地摆动，它会因为轴和绳子之间的摩擦而停止摆动。我对这个课题做了一些研究，找到了有摩擦力的摆的数学公式:</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi lg"><img src="../Images/241c1a1d47b6113a206d81d94a785016.png" data-original-src="https://miro.medium.com/v2/resize:fit:644/format:webp/1*A2BABzooSuThFrDuG4UYqQ.png"/></div></figure><p id="05a3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">(此公式来源于带摩擦的摆运动微分方程，可在此处找到:<a class="ae lo" href="https://physics.stackexchange.com/questions/243143/how-does-friction-affect-the-motion-of-a-pendulum" rel="noopener ugc nofollow" target="_blank">https://physics . stack exchange . com/questions/243143/how-friction-affect-of-a-motion of-a-pendulum</a>)</p><p id="adc4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在代码中应用该公式会产生这个小函数:</p><pre class="lh li lj lk gt lp lq lr bn ls lt bi"><span id="c3da" class="lu kj in lq b be lv lw l lx ly">const GRAVITY = 9.80665;<br/>const pendWithFricAngle = (<br/>  time: number,<br/>  initAngle: number,<br/>  fricCoeff: number,<br/>  mass: number,<br/>  length: number<br/>) =&gt; {<br/>  const expCoeff = Math.exp((((-1 / 2) * fricCoeff) / mass) * time);<br/>  const sqrtCoeff = Math.sqrt(<br/>    GRAVITY / length - Math.pow(fricCoeff, 2) / (4 * Math.pow(mass, 2))<br/>  );<br/>  return initAngle * expCoeff * Math.cos(sqrtCoeff * time);<br/>};</span></pre><p id="b61b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果钟摆在没有初速度的情况下，从指定的角度开始摆动，这个公式就成立。但是我们的钟摆应该从底部开始，初始踢水/速度:</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi lz"><img src="../Images/2a94a4bf3f0220d5ed38cddbde9f8cc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:916/format:webp/1*6p1Vtbnr39RkLdRet_4LCA.png"/></div></figure><p id="a31c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后我们还需要从一开始就计算这一刻经过的时间，并将其作为“时间填充”应用于前面的公式。假设<code class="fe ma mb mc lq b">angle = 0</code>(如上图所示)我们得到:</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi md"><img src="../Images/2243086d6d8143f882b302a86545b9ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:538/format:webp/1*Vr6rX71N5a2I6qhmmXfpPA.png"/></div></figure><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi me"><img src="../Images/f355ffcaf8c7ce51e00e29cf1f8f5229.png" data-original-src="https://miro.medium.com/v2/resize:fit:724/format:webp/1*LAzK84M8M4Lcq0uWnBdskA.png"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">(参见<a class="ae lo" href="https://www.wolframalpha.com/input/?i=+a*e%5E%28-1%2F2*b%2Fm*t%29*cos%28sqrt%28g%2Fl-b%5E2%2F%284*m%5E2%29%29*t%29%3D0" rel="noopener ugc nofollow" target="_blank">https://www.wolframalpha.com/input/?I =+a * e % 5E % 28-1% 2 F2 * b % 2Fm * t % 29 * cos % 28 sqrt % 28g % 2Fl-b % 5E 2% 2F % 284 * m % 5E 2% 29% 29 * t % 29% 3d 0</a></figcaption></figure><p id="b8e9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ma mb mc lq b">n</code>是当前摆的周期数，看起来像这样:</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi mj"><img src="../Images/c2f166c195df1e4c2fb02587ce4b71c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wUZij875NCz5YcLMMNmVtg.png"/></div></div></figure><p id="1486" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们假设只有第一个时期所以<code class="fe ma mb mc lq b">n = 0</code>。我们只留下了正确的总结部分。它是这样写在代码里的:</p><pre class="lh li lj lk gt lp lq lr bn ls lt bi"><span id="48c1" class="lu kj in lq b be lv lw l lx ly">const timePaddingForZeroAngle = (<br/>  fricCoeff: number,<br/>  mass: number,<br/>  length: number<br/>) =&gt; {<br/>  const a = Math.PI * Math.sqrt(length) * mass;<br/>  const b = Math.sqrt(<br/>    4 * GRAVITY * Math.pow(mass, 2) - Math.pow(fricCoeff, 2) * length<br/>  );<br/><br/>  return a / b;<br/>};</span></pre><h2 id="0a0d" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">以及如何将这些公式应用到圣诞球的动画中？</h2><p id="0e7d" class="pw-post-body-paragraph jk jl in jm b jn lb jp jq jr lc jt ju jv ld jx jy jz le kb kc kd lf kf kg kh ig bi translated">首先，我们需要一种方法来测量从开始到当前时刻的时间。第二，我们需要在人眼无法捕捉到运动中的微小差异时停止动画。为了结束动画，我们需要做最后一件事:因为现在我们可以再次触发动画。在我们的代码中，它反映如下动画循环:</p><pre class="lh li lj lk gt lp lq lr bn ls lt bi"><span id="28a1" class="lu kj in lq b be lv lw l lx ly">const animationFrame = (timestamp: number) =&gt; {<br/>    if (!boxRef.current) return;<br/>    const isBegin = !stateRef.current.initTimestamp;<br/>    if (isBegin) {<br/>      stateRef.current.initTimestamp = performance.now();<br/>    }<br/><br/>    const time = timestamp - stateRef.current.initTimestamp;<br/>    const timePadding = timePaddingForZeroAngle(fricCoeff, mass, length);<br/><br/>    let angle = pendWithFricAngle(<br/>      time / 1000 + timePadding,<br/>      initAngle,<br/>      fricCoeff,<br/>      mass,<br/>      length<br/>    );<br/>    const prevAngle = stateRef.current.angle;<br/>    if (Math.abs(angle - prevAngle) &lt;= EPSILON) {<br/>      frameRef.current = null;<br/>      stateRef.current.initTimestamp = 0;<br/>      angle = 0;<br/>    } else {<br/>      frameRef.current = requestAnimationFrame(animationFrame);<br/>    }<br/><br/>    stateRef.current.angle = angle;<br/>    boxRef.current.style.transform = `rotate(${angle}rad)`;<br/>  };</span></pre><p id="1deb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">“math . ABS(angle—pre angle)&lt; = EPSILON”作为动画的停止条件；</p><p id="7506" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为什么我要在 React refs 中存储初始时间戳和角度？因为我不需要那个状态在 React 组件生命周期方面是被动的:我的动画应该用最小的计算开销来更新。所以状态需要直接控制。这就是利用回调的 React 组件的样子:</p><pre class="lh li lj lk gt lp lq lr bn ls lt bi"><span id="971e" class="lu kj in lq b be lv lw l lx ly">const ChristmasBall = ({<br/>  className,<br/>  fricCoeff,<br/>  mass,<br/>  length,<br/>  initAngle<br/>}: Props) =&gt; {<br/>  const boxRef = useRef&lt;HTMLElement&gt;(null);<br/>  const frameRef = useRef&lt;null | number&gt;(null);<br/>  const stateRef = useRef({<br/>    initTimestamp: 0,<br/>    angle: 0<br/>  });<br/><br/>  const animationFrame = (timestamp: number) =&gt; {<br/>    if (!boxRef.current) return;<br/>    const isBegin = !stateRef.current.initTimestamp;<br/>    if (isBegin) {<br/>      stateRef.current.initTimestamp = performance.now();<br/>    }<br/><br/>    const time = timestamp - stateRef.current.initTimestamp;<br/>    const timePadding = timePaddingForZeroAngle(fricCoeff, mass, length);<br/><br/>    let angle = pendWithFricAngle(<br/>      time / 1000 + timePadding,<br/>      initAngle,<br/>      fricCoeff,<br/>      mass,<br/>      length<br/>    );<br/>    const prevAngle = stateRef.current.angle;<br/>    if (Math.abs(angle - prevAngle) &lt;= EPSILON) {<br/>      frameRef.current = null;<br/>      stateRef.current.initTimestamp = 0;<br/>      angle = 0;<br/>    } else {<br/>      frameRef.current = requestAnimationFrame(animationFrame);<br/>    }<br/><br/>    stateRef.current.angle = angle;<br/>    boxRef.current.style.transform = `rotate(${angle}rad)`;<br/>  };<br/><br/>  const handleHover = () =&gt; {<br/>    if (!frameRef.current) {<br/>      frameRef.current = requestAnimationFrame(animationFrame);<br/>    }<br/>  };<br/><br/>  useEffect(() =&gt; {<br/>    return () =&gt; {<br/>      const taskDesc = frameRef.current;<br/>      if (taskDesc) {<br/>        cancelAnimationFrame(taskDesc);<br/>      }<br/>    };<br/>  }, []);<br/><br/>  return (<br/>    &lt;Wrapper ref={boxRef} className={className} onMouseEnter={handleHover}&gt;<br/>      &lt;Img src={ball} /&gt;<br/>    &lt;/Wrapper&gt;<br/>  );<br/>};</span></pre><p id="3e26" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所有这些看起来就像这个简洁的动作:</p><figure class="lh li lj lk gt ll"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="385f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所有的源代码都在这里:<a class="ae lo" href="https://codesandbox.io/s/pendulum-christmas-ball-xnsd8?file=/src/ChristmasBall.tsx:1526-3083" rel="noopener ugc nofollow" target="_blank">https://codesandbox.io/s/pendulum-christmas-ball-xnsd8</a></p><p id="2c6f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="mq">请随意留下你的经验等任何建议。我感谢任何有益的反馈；)</em></p><p id="4d2b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">【我的 git lab:<a class="ae lo" href="https://gitlab.com/john-byte" rel="noopener ugc nofollow" target="_blank"><em class="mq">https://gitlab.com/jbyte</em></a><em class="mq">777</em></p></div></div>    
</body>
</html>