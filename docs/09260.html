<html>
<head>
<title>LeetCode 101: Symmetric Tree (solution with images)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">LeetCode 101:对称树(图像解决方案)</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/leetcode-101-symmetric-tree-87383ec51401?source=collection_archive---------2-----------------------#2022-08-10">https://blog.devgenius.io/leetcode-101-symmetric-tree-87383ec51401?source=collection_archive---------2-----------------------#2022-08-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="fd90" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">链接:→<a class="ae kl" href="https://leetcode.com/problems/symmetric-tree/" rel="noopener ugc nofollow" target="_blank">https://leetcode.com/problems/symmetric-tree/</a></p><h1 id="dea0" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">问题:→</h1><p id="4726" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">给定一棵二叉树的<code class="fe lp lq lr ls b">root</code>，<em class="lt">检查它是否是自身的镜像</em>(即围绕其中心对称)。</p><p id="e4cc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">例 1: </strong></p><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div class="gh gi lu"><img src="../Images/9d3b10718f8b5fc0ad72e42972f113a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:708/format:webp/0*HI25F-JzzY-S6m87.jpg"/></div></figure><pre class="lv lw lx ly gt mc ls md me aw mf bi"><span id="3572" class="mg kn iq ls b gy mh mi l mj mk"><strong class="ls ir">Input:</strong> root = [1,2,2,3,4,4,3]<br/><strong class="ls ir">Output:</strong> true</span></pre><p id="8e76" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">例 2: </strong></p><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/bea2266ef7d85f44ba1ee8367778874e.png" data-original-src="https://miro.medium.com/v2/resize:fit:616/format:webp/0*O1V2trabCjikyhft.jpg"/></div></figure><pre class="lv lw lx ly gt mc ls md me aw mf bi"><span id="50c9" class="mg kn iq ls b gy mh mi l mj mk"><strong class="ls ir">Input:</strong> root = [1,2,2,null,3,null,3]<br/><strong class="ls ir">Output:</strong> false</span></pre><p id="b804" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">约束:</strong></p><ul class=""><li id="0d58" class="mm mn iq jp b jq jr ju jv jy mo kc mp kg mq kk mr ms mt mu bi translated">树中的节点数量在范围<code class="fe lp lq lr ls b">[1, 1000]</code>内。</li><li id="395d" class="mm mn iq jp b jq mv ju mw jy mx kc my kg mz kk mr ms mt mu bi translated"><code class="fe lp lq lr ls b">-100 &lt;= Node.val &lt;= 100</code></li></ul><p id="e219" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">跟进:</strong>你能递归和迭代地解决它吗？</p><h1 id="eb12" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">解决方案:→</h1><p id="3222" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">这里，我们需要双向求解，<strong class="jp ir">递归</strong>以及<strong class="jp ir">迭代</strong>。</p><p id="300f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将树分成两部分，检查右边部分是否是左边部分的镜像？。</p><p id="8664" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下图显示了我们如何比较每个节点的值。</p><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div class="gh gi na"><img src="../Images/b1ff961f7cc508919b27db25f02c6f55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1198/1*MMMFief7pQEyb2wXxU4jkw.gif"/></div></figure><p id="b0ef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们将检查<strong class="jp ir">根节点</strong>，如果它是<strong class="jp ir"> null </strong>那么我们不需要遍历任何东西，我们可以简单地返回<strong class="jp ir"> true </strong>。</p><p id="32c2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">假设我们有下面这棵树，</p><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/3a7c305f2eb809e98f8dbde6acf222c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1390/format:webp/1*1_U6UUdTlCeS5Svegp-rYw.png"/></div></figure><p id="fa82" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">假设，这棵树被分成两部分(左部和右部)</p><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/81a7fc33f760d64549318d3d95db8a0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/format:webp/1*wY1uHjsZY7haZPfDPLNsIg.png"/></div></figure><p id="cd2e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们需要检查<strong class="jp ir">右侧部分</strong>是否是<strong class="jp ir">左侧部分</strong>的<strong class="jp ir">镜像</strong>或者相反。</p><p id="d23c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，我们将<strong class="jp ir">比较</strong>，每个<strong class="jp ir">左侧节点的值</strong>与<strong class="jp ir">右侧节点的值</strong>，首先我们将<strong class="jp ir">取一个堆栈</strong>并尝试将这些<strong class="jp ir">值</strong>相加，首先从<strong class="jp ir">左侧</strong>开始，第二个从<strong class="jp ir">右侧</strong>开始。</p><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi nd"><img src="../Images/4d3a732fc9e631c81ce7d0c6067a830c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5rWRlJYFichKVVVS"/></div></div></figure><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi ni"><img src="../Images/98c1eec0b839e45c6cb3324cb504f409.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZuERz5yUnjIWUViz_ZUa5Q.png"/></div></div></figure><p id="01d5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，在<strong class="jp ir"> while 循环</strong>中，我们将遍历直到<strong class="jp ir">堆栈不为空</strong>。</p><p id="42a4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在 while 循环中，首先我们将从堆栈中取出前两个值，</p><ol class=""><li id="7a89" class="mm mn iq jp b jq jr ju jv jy mo kc mp kg mq kk nj ms mt mu bi translated">检查一下，如果<strong class="jp ir">和</strong>都是空的，那就意味着我们在那一边是树的末端，所以简单地我们将移动到<strong class="jp ir">另一个节点。</strong></li><li id="83ae" class="mm mn iq jp b jq mv ju mw jy mx kc my kg mz kk nj ms mt mu bi translated">如果任一侧的<strong class="jp ir">为空</strong>而另一侧的<strong class="jp ir">不为空</strong>、<strong class="jp ir">或</strong>则两侧的<strong class="jp ir">值不相同</strong>，这意味着<strong class="jp ir">镜侧不相同</strong>，所以我们将返回<strong class="jp ir">假</strong>。</li></ol><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi nk"><img src="../Images/ea85a4a8ca23cb4b1e1b381669b0f276.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mP6U0ikrDb6PcJDxhH-EKA.png"/></div></div></figure><p id="0f71" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">3.如果上述<strong class="jp ir">两个条件都不满足</strong>，则意味着两侧的<strong class="jp ir">值相同</strong>，因此，我们需要检查<strong class="jp ir">的其他值</strong>，为此我们将转到<strong class="jp ir">的下一个节点</strong>的左侧和<strong class="jp ir">的右侧</strong>。</p><p id="604f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">→ <strong class="jp ir">左侧的左节点</strong>值<strong class="jp ir">比较</strong>和<strong class="jp ir">右侧的右节点</strong> <strong class="jp ir">值</strong>。</p><p id="464b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">→ <strong class="jp ir">左侧的右节点</strong>值<strong class="jp ir">比较</strong>和<strong class="jp ir">右侧的左节点</strong> <strong class="jp ir">值</strong>。</p><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/e7f8f406fe0d72185ec849a1d4037869.png" data-original-src="https://miro.medium.com/v2/resize:fit:1052/format:webp/1*SUKTkK0odoKUEviJHVTDNg.png"/></div></figure><p id="c498" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了实现这一目标，我们首先添加</p><p id="05ad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">左侧的左节点</strong>和<strong class="jp ir">右侧的右节点</strong>然后</p><p id="bd79" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">左侧的右节点</strong>和<strong class="jp ir">右侧的左节点</strong></p><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi nm"><img src="../Images/39304cd676fb9e72453311eb492cebdf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6mig2qpwDmoQS0776lVppQ.png"/></div></div></figure><p id="197a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，在下一个 while 循环的<strong class="jp ir">迭代</strong>中，我们将移动到<strong class="jp ir">步骤 2。</strong></p><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi nn"><img src="../Images/b94b938fe7fba0b0e002d85261d35de4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zW_tm-lW5d4FjtVvRR1DfA.png"/></div></div></figure><p id="6b6e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，与步骤 3 相同，<strong class="jp ir">两个条件都不满足</strong>，这意味着<strong class="jp ir">值在两侧都相同</strong>，因此，我们需要检查<strong class="jp ir">的其他值</strong>，为此我们将转到<strong class="jp ir">下一个节点</strong>的左侧和<strong class="jp ir">右侧</strong>。</p><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi no"><img src="../Images/409562e526736109e2126f7a3995cf2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QLx7-Xkpu72WRlXHOt-wgw.png"/></div></div></figure><p id="cc1b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，在堆栈中，我们将添加:</p><p id="df74" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">左侧的左节点</strong>和<strong class="jp ir">右侧的右节点</strong>然后之后</p><p id="5e32" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">左侧的右节点</strong>和<strong class="jp ir">右侧的左节点</strong></p><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi np"><img src="../Images/da76b3f8e4deb180f54c99a3c9856448.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tsP1lUFaLKPYDHFAxRKY6Q.png"/></div></div></figure><p id="f749" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，在下一个 while 循环的<strong class="jp ir">迭代</strong>中，我们将移动到<strong class="jp ir">步骤 2。</strong></p><p id="c168" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里，因为<strong class="jp ir">两者都是空的</strong>，我们移动到<strong class="jp ir">下一次迭代</strong>。</p><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi nq"><img src="../Images/e8ec6eb66ff5570abba5538cc0253f12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3o38ZbAqTrr9Atb5ZXQ80Q.png"/></div></div></figure><p id="3d60" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，同样像<strong class="jp ir">上一个</strong>，<strong class="jp ir">都是空的</strong>，我们移动到<strong class="jp ir">下一次迭代</strong></p><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi nk"><img src="../Images/bbd98398e824ec7dd805fb4fc9090137.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GbniUnp3VzKLtDJBYVd25w.png"/></div></div></figure><p id="ba70" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在下一次迭代中，我们从堆栈<strong class="jp ir">中找到了<strong class="jp ir">非空值</strong>。</strong></p><p id="1356" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里两个值相同，所以条件不满足。</p><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi nr"><img src="../Images/c7bda01dcb6f287767de2d4700714b35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uW94sHppYAa65hHPnWoe0A.png"/></div></div></figure><p id="1e9a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以，我们正在移动到<strong class="jp ir">的下一个节点</strong>，但是我们发现全部为空。</p><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi ns"><img src="../Images/3ce926aa54404ffb2a67dce4dcf999e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7vsn2TbWTA2sRx5_7RbQBg.png"/></div></div></figure><p id="d738" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，在下一个 while 循环的<strong class="jp ir">迭代</strong>中，</p><p id="3ed9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这里，由于<strong class="jp ir">和</strong>都是空的，我们转移到<strong class="jp ir">的下一次迭代</strong>。</p><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/318e09a06afab89ecbaa4591d727f5d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1386/format:webp/1*6ALGKmL6AIGqppr9ZzF5tA.png"/></div></figure><p id="15ff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，在下一个 while 循环的<strong class="jp ir">迭代</strong>中，</p><p id="59cd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这里，由于<strong class="jp ir">和</strong>都是空的，我们转移到<strong class="jp ir">的下一次迭代</strong>。</p><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/438957d3611a424669ba7be645fa6a1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1310/format:webp/1*eFfR4w7wr2jHNhIr3yp8vQ.png"/></div></figure><p id="d178" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这里，随着<strong class="jp ir">栈变空</strong>。因此<strong class="jp ir">而</strong>条件变为<strong class="jp ir">假</strong>。</p><p id="c0df" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">代码结束时，我们简单地返回<strong class="jp ir"> true </strong>，因为<strong class="jp ir">的所有值都是相同的</strong>。</p><p id="e6ea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们发现任何<strong class="jp ir">不同的值</strong>，那么它将返回<strong class="jp ir"> false </strong>。</p><p id="3299" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，让我们看看<strong class="jp ir">迭代</strong>的完整源代码。</p><h1 id="08bc" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">代码(Java): →</h1><figure class="lv lw lx ly gt lz"><div class="bz fp l di"><div class="nv nw l"/></div></figure><h1 id="3b5f" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">代码(Python): →</h1><figure class="lv lw lx ly gt lz"><div class="bz fp l di"><div class="nv nw l"/></div></figure><h1 id="8c16" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">时间复杂度</h1><p id="5546" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">在这里，我们遍历树的所有节点一次，所以总时间复杂度是<strong class="jp ir"> O(n) </strong>。</p><h1 id="d5c1" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">空间复杂性</h1><p id="5c87" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">由于我们使用了一个额外的堆栈，所以，空间复杂度将是 O(n)  。</p><h1 id="50bd" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">递归代码(Java): →</h1><figure class="lv lw lx ly gt lz"><div class="bz fp l di"><div class="nv nw l"/></div></figure><h1 id="4e35" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">递归代码(Python): →</h1><figure class="lv lw lx ly gt lz"><div class="bz fp l di"><div class="nv nw l"/></div></figure><h1 id="8d77" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">时间复杂度</h1><p id="d9ad" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">这里，我们遍历树的所有节点一次，所以总时间复杂度是<strong class="jp ir"> O(n) </strong>。</p><h1 id="ea4b" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">空间复杂性</h1><p id="53cc" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">同样在递归调用中，栈是托管的，栈的大小是基于输入的大小(<strong class="jp ir"> n) </strong>，所以空间复杂度会是<strong class="jp ir"> <em class="lt"> O(n) </em> </strong>。</p><p id="b220" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">感谢你阅读这篇文章，❤</p><p id="c391" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我做错了什么？让我在评论中。我很想进步。</p><p id="e05f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">拍手声👏如果这篇文章对你有帮助。</p></div></div>    
</body>
</html>