<html>
<head>
<title>[Golang] Let’s talk about methods in Golang</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">[Golang]我们来谈谈 Golang 中的方法</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/lets-talk-about-methods-in-golang-a22dbaf028f1?source=collection_archive---------6-----------------------#2022-03-15">https://blog.devgenius.io/lets-talk-about-methods-in-golang-a22dbaf028f1?source=collection_archive---------6-----------------------#2022-03-15</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="332b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们来谈谈<strong class="jm io"> Golang </strong>中的<code class="fe ki kj kk kl b"><strong class="jm io"><em class="km">methods</em></strong></code>，我们为什么要使用它们，它们在<strong class="jm io"> Golang 中的意义是什么。</strong></p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi kn"><img src="../Images/fc93d7efd48e3b599b4e4a3da2ec14c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*DWuaFZuGhnXDKCds.png"/></div></div></figure><p id="2140" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Go 不是一种纯面向对象的编程语言，它不支持类。因此，类型上的方法是实现类似于类的行为的一种方式。方法允许对与类似于类的类型相关的行为进行逻辑分组。</p><p id="4574" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一个<em class="km">方法</em>声明类似于一个<strong class="jm io"> <em class="km">函数声明</em> </strong>，但是它有一个额外的参数声明部分。额外参数部分可以包含且只能包含<em class="km">方法</em>的接收器类型的一个参数。唯一的一个参数叫做<em class="km">方法</em>声明的接收器参数。接收器参数必须包含在<code class="fe ki kj kk kl b">()</code>中，并在<code class="fe ki kj kk kl b">func</code>关键字和<em class="km">方法</em>名称之间声明。</p><p id="58c8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">例如:</strong></p><p id="0cf0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下面我将<strong class="jm io">自定义</strong>类型<strong class="jm io">定义为</strong>员工。我也有<em class="km">方法</em>调用<code class="fe ki kj kk kl b">accountDetails()</code>，接收者类型<code class="fe ki kj kk kl b">a</code>作为账号</p><pre class="ko kp kq kr gt la kl lb lc aw ld bi"><span id="ad3d" class="le lf in kl b gy lg lh l li lj">package main</span><span id="856d" class="le lf in kl b gy lk lh l li lj">import "fmt"</span><span id="6390" class="le lf in kl b gy lk lh l li lj">type account struct {<br/>    accountName   string<br/>    accountType   string<br/>    accountValue  int<br/>}</span><span id="882d" class="le lf in kl b gy lk lh l li lj">func (a account) accountDetails() {<br/>    fmt.Printf("Account Name: %s\n", a.accountName)<br/>    fmt.Printf("Account Type: %s\n", a.accountType)}</span><span id="4743" class="le lf in kl b gy lk lh l li lj">func (a account) getAccountValue() int {<br/>    return a.accountValue<br/>}<br/><br/>func main() {<br/>    acc := account{accountName: "Chase Account", accountType: "saving", accountValue: 21000}<br/>    acc.accountDetails()<br/>    fmt.Printf("Account Value Updated after calling by reference: %d\n", acc.getAccountValue())<br/>}</span></pre><p id="1a55" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">方法<code class="fe ki kj kk kl b">accountDetails()</code>附加到接收器类型<code class="fe ki kj kk kl b">account</code>上，并提供访问字段<code class="fe ki kj kk kl b">accountName</code>和<code class="fe ki kj kk kl b">accountType</code>的方法。类似地,<code class="fe ki kj kk kl b">getAccountValue()</code>方法返回接收者<code class="fe ki kj kk kl b">account</code>类型的<code class="fe ki kj kk kl b">accountValue</code>。</p><p id="2b95" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在假设您试图在一个<em class="km">方法</em>中修改接收器的字段值。假设您想用一个名为<code class="fe ki kj kk kl b">updateAccountValue()</code>的额外的<em class="km">方法</em>来更改银行账户的<code class="fe ki kj kk kl b">accountValue</code></p><pre class="ko kp kq kr gt la kl lb lc aw ld bi"><span id="81ca" class="le lf in kl b gy lg lh l li lj">package main</span><span id="103b" class="le lf in kl b gy lk lh l li lj">import "fmt"</span><span id="5d8d" class="le lf in kl b gy lk lh l li lj">type account struct {<br/>    accountName   string<br/>    accountType   string<br/>    accountValue  int<br/>}</span><span id="69fc" class="le lf in kl b gy lk lh l li lj">func (a account) accountDetails() {<br/>    fmt.Printf("Account Name: %s\n", a.accountName)<br/>    fmt.Printf("Account Type: %s\n", a.accountType)<br/>    fmt.Printf("Account Value: %d\n", a.accountValue)<br/>}</span><span id="530d" class="le lf in kl b gy lk lh l li lj">func (a account) getAccountValue() int {<br/>    return a.accountValue<br/>}</span><span id="0f74" class="le lf in kl b gy lk lh l li lj">func (a account) updateAccountValue(updatedAccountValue int) int {<br/>    a.accountValue = updatedAccountValue<br/>    return a.accountValue<br/>}</span><span id="b08f" class="le lf in kl b gy lk lh l li lj">func main() {<br/>    acc := account{accountName: "Chase Account", accountType: "saving", accountValue: 21000}<br/>    acc.accountDetails()<br/>    acc.updateAccountValue(22000)<br/>    if acc.getAccountValue() == 21000 {<br/>        fmt.Printf("Did Account value updated after calling acc.updateAccountValue method: [%d] - No\n", acc.getAccountValue())<br/>    } else if acc.getAccountValue() == 22000 {<br/>        fmt.Printf("Did Account value updated after calling acc.updateAccountValue method: [%d] - Yes\n", acc.getAccountValue())<br/>    }<br/>}</span></pre><p id="d5de" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">输出:</strong></p><pre class="ko kp kq kr gt la kl lb lc aw ld bi"><span id="a0dc" class="le lf in kl b gy lg lh l li lj">Account Name: Chase Account<br/>Account Type: saving<br/>Account Value: 21000<br/>Did Account value updated after calling acc.updateAccountValue method: [21000] - No</span></pre><p id="ba55" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里发生了什么，当方法<code class="fe ki kj kk kl b">updateAccountValue()</code>被调用时，接收器的副本被制作，并且接收器的副本在方法内部是可用的。因为它是一个副本，所以对值接收者的任何更改对调用者都是不可见的。为了完成这项工作，我们需要为<em class="km">方法使用一个<strong class="jm io"> <em class="km">指针接收器</em> </strong> <em class="km"> </em>。对指针接收器所做的任何更改都将被调用者看到。</em></p><pre class="ko kp kq kr gt la kl lb lc aw ld bi"><span id="e327" class="le lf in kl b gy lg lh l li lj">package main</span><span id="a0a1" class="le lf in kl b gy lk lh l li lj">import "fmt"</span><span id="216b" class="le lf in kl b gy lk lh l li lj">type account struct {<br/>    accountName   string<br/>    accountType   string<br/>    accountValue  int<br/>}</span><span id="80a6" class="le lf in kl b gy lk lh l li lj">func (a account) accountDetails() {<br/>    fmt.Printf("Account Name: %s\n", a.accountName)<br/>    fmt.Printf("Account Type: %s\n", a.accountType)<br/>    fmt.Printf("Account Value: %d\n", a.accountValue)<br/>}</span><span id="110f" class="le lf in kl b gy lk lh l li lj">func (a account) getAccountValue() int {<br/>    return a.accountValue<br/>}</span><span id="8d43" class="le lf in kl b gy lk lh l li lj"><strong class="kl io">func (a *account) updateAccountValue(updatedAccountValue int) int {<br/>    a.accountValue = updatedAccountValue<br/>    return a.accountValue<br/>}</strong></span><span id="460f" class="le lf in kl b gy lk lh l li lj">func main() {<br/>    acc := account{accountName: "Chase Account", accountType: "saving", accountValue: 21000}<br/>    acc.accountDetails()<br/>    acc.updateAccountValue(22000)<br/>    if acc.getAccountValue() == 21000 {<br/>        fmt.Printf("Did Account value updated after calling acc.updateAccountValue method: [%d] - No\n", acc.getAccountValue())<br/>    } else if acc.getAccountValue() == 22000 {<br/>        fmt.Printf("Did Account value updated after calling acc.updateAccountValue method: [%d] - Yes\n", acc.getAccountValue())<br/>    }<br/>}</span></pre><p id="78e9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">输出:</strong></p><pre class="ko kp kq kr gt la kl lb lc aw ld bi"><span id="9d59" class="le lf in kl b gy lg lh l li lj">Account Name: Chase Account<br/>Account Type: saving<br/>Account Value: 21000<br/>Did Account value updated after calling acc.updateAccountValue method: [22000] - Yes</span></pre><p id="baa0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以有必要为方法定义<strong class="jm io"> <em class="km">指针接收器</em> </strong>来修改原始的调用方字段<strong class="jm io">……不，不一定。</strong>我们可以很好的调用实际的<strong class="jm io"> </strong> <code class="fe ki kj kk kl b">acc</code> <strong class="jm io"> </strong>实例中的方法并修改字段。为此我们不得不像这样使用<code class="fe ki kj kk kl b">&amp;acc</code></p><pre class="ko kp kq kr gt la kl lb lc aw ld bi"><span id="9b07" class="le lf in kl b gy lg lh l li lj">(&amp;acc).updateAccountValue(22000)</span></pre><p id="e184" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">方法</strong>和<strong class="jm io">接收器</strong>都需要在同一个包中定义，否则无效。方法可以通过将<strong class="jm io">大写</strong>而在包之间共享，也称为<strong class="jm io">导出</strong>，即</p><pre class="ko kp kq kr gt la kl lb lc aw ld bi"><span id="efb6" class="le lf in kl b gy lg lh l li lj"><strong class="kl io"><em class="km">💡 Will only be available within the package</em></strong><br/> <br/>func (a *account) <strong class="kl io">updateAccountValue</strong>(updatedAccountValue int) int {<br/>    a.accountValue = updatedAccountValue<br/>    return a.accountValue<br/>}</span><span id="67ad" class="le lf in kl b gy lk lh l li lj"><strong class="kl io"><em class="km">💡 Will be available outside of the package</em></strong></span><span id="2a71" class="le lf in kl b gy lk lh l li lj">func (a *account) <strong class="kl io">UpdateAccountValue</strong>(updatedAccountValue int) int {<br/>    a.accountValue = updatedAccountValue<br/>    return a.accountValue<br/>}</span></pre><p id="c786" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ki kj kk kl b">updateAccountValue</code>只能在定义的包内访问，在我们的例子中是<code class="fe ki kj kk kl b"><strong class="jm io">main</strong></code>，但是<code class="fe ki kj kk kl b">UpdateAccountValue</code> <strong class="jm io"> </strong>可以在包外访问，因为<code class="fe ki kj kk kl b">Go</code>会将它们导出到模块。</p><p id="1f13" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ki kj kk kl b"><strong class="jm io">structs</strong></code>和<code class="fe ki kj kk kl b"><strong class="jm io">struct fields</strong></code>也是如此</p><p id="5086" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">例如:</strong> <code class="fe ki kj kk kl b">account</code>结构不是<strong class="jm io">导出的</strong>，但是<code class="fe ki kj kk kl b">AccountValue</code>字段中的<code class="fe ki kj kk kl b">account</code>结构是<strong class="jm io">导出的，</strong>表示<code class="fe ki kj kk kl b">account</code>结构在包外不可访问，但是<code class="fe ki kj kk kl b">AccountValue</code>字段将被导出并且在包外可用。</p><p id="f620" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ki kj kk kl b"><strong class="jm io">AccountValue</strong></code> <strong class="jm io"> </strong>结构为<strong class="jm io">大写</strong>，因此将被导出并在包外提供</p><pre class="ko kp kq kr gt la kl lb lc aw ld bi"><span id="77f3" class="le lf in kl b gy lg lh l li lj">type account struct {<br/>    accountName   string<br/>    accountType   string<br/>    AccountValue  int<br/>}</span><span id="eaeb" class="le lf in kl b gy lk lh l li lj">type Money struct {<br/>    available   int<br/>    interest    int<br/>    percentage  int<br/>}</span></pre><p id="bc7b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">到目前为止，我们已经了解到:</p><ul class=""><li id="29f4" class="ll lm in jm b jn jo jr js jv ln jz lo kd lp kh lq lr ls lt bi translated"><em class="km">方法</em>是在<code class="fe ki kj kk kl b">Golang</code>中表现为 OOPs 的方式</li><li id="1de3" class="ll lm in jm b jn lu jr lv jv lw jz lx kd ly kh lq lr ls lt bi translated"><em class="km">方法</em>需附式</li><li id="c61f" class="ll lm in jm b jn lu jr lv jv lw jz lx kd ly kh lq lr ls lt bi translated"><em class="km">方法</em> <strong class="jm io"> <em class="km"> </em> </strong>可以通过指针和数值两种方式访问接收方字段</li><li id="1de8" class="ll lm in jm b jn lu jr lv jv lw jz lx kd ly kh lq lr ls lt bi translated"><em class="km">方法</em>需与受体同包定义</li><li id="4771" class="ll lm in jm b jn lu jr lv jv lw jz lx kd ly kh lq lr ls lt bi translated"><em class="km">方法通过<strong class="jm io">大写</strong>可以将</em>导出到包装外使用</li></ul><p id="fb32" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">还有一些类似<em class="km">方法链接</em>等的东西，我会在以后尝试覆盖…希望这会有所帮助！！</p><h1 id="fe8c" class="lz lf in bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">快乐编码！！</h1></div></div>    
</body>
</html>