<html>
<head>
<title>Understanding Message Durability in Kafka</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解卡夫卡作品中的信息持久性</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/understanding-message-durability-in-kafka-8f6e7006aea8?source=collection_archive---------9-----------------------#2022-04-06">https://blog.devgenius.io/understanding-message-durability-in-kafka-8f6e7006aea8?source=collection_archive---------9-----------------------#2022-04-06</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="3f41" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在分布式系统中，持久性通常来自复制，数据的多个副本会独立地失败。在任何分布式系统中，完全的持久性几乎是不可能的。复制是在分布式系统中实现持久性的一种方式，虽然有些人选择从不丢失写入磁盘的数据，因此要求每次写入时同步，但其他人在他们的设计中处理这种情况，如 Kafka。</p><p id="3c74" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Kafka 提供了以下不同的方法来实现数据的高持久性和可用性-</p><p id="f283" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">1- <strong class="jm io">使用复制</strong> — Kafka 提供了一种复制数据的方法，并将这些复制的数据放在不同的分区上，以便在任何代理数据丢失的情况下，我们仍有副本可用于此目的。</p><p id="0dbe" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这可以处理代理故障。</p><p id="98f2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Kafka 中添加复制的目的是为了更强的持久性和更高的可用性。我们希望保证任何成功发布的消息都不会丢失，并且可以被使用，即使在服务器出现故障时也是如此。</p><p id="6039" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">考虑我们没有配置复制因子的情况。我们可以看到，如果代理关闭，Partition-0 中的可用数据将被擦除，我们将无法恢复这些数据。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/dc0d137172509aafb7955636af3c4486.png" data-original-src="https://miro.medium.com/v2/resize:fit:1158/format:webp/1*um2D7H-oNJKA8KwpuU54CQ.png"/></div></figure><p id="a8f4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在考虑下面的场景，我们将复制因子设为 3，即使一两个代理宕机，我们仍将拥有数据。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi kq"><img src="../Images/6b6933df76c26b64d231edda66722009.png" data-original-src="https://miro.medium.com/v2/resize:fit:1292/format:webp/1*UhkdRAovvtEglmyg5ML76w.png"/></div></figure><p id="8bb1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">正如我之前提到的，Kafka 在其设计中处理副本同步保证。人们可以在耐久性保证和吞吐量之间进行选择。生产者可以选择使用<strong class="jm io"> <em class="kr">确认</em> </strong>配置来获得最大吞吐量或更高的数据持久性。<strong class="jm io"> <em class="kr">确认</em> </strong>设置是生产者配置。它表示在我们认为写入成功之前必须收到记录的代理数量。它支持三个值— 0、1 和全部或-1。</p><p id="7b4e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">a.<strong class="jm io">ack = 0</strong>—值为 0 时，生产者甚至不会等待代理的响应。记录发出后，它立即认为写入成功。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi ks"><img src="../Images/20cdf74ab6583fa9742d3b423ad4ba8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EbP6W5WfX35tNjeIQ6R_2w.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">制片人甚至不等待回应。该消息已被确认。</figcaption></figure><p id="f0bc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">b-<strong class="jm io">ack = 1</strong>—设置为 1 时，生产者将在领导者收到记录时认为写入成功。主经纪人将知道在接收到记录时立即响应，而不再等待。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi lb"><img src="../Images/833dd7db3c2da44b28dde4c5286f3af9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j1U9Hgj3dzWSwIaxO4uyvA.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">一旦收到记录，代理立即响应，跟随者异步复制记录。</figcaption></figure><p id="1dbc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">c-<strong class="jm io">ack = all</strong>—设置为 all 时，当所有 i <strong class="jm io"> n-sync 副本</strong>接收到记录时，生产者将认为写入成功。这是通过主代理智能地响应请求来实现的——一旦所有同步副本自己接收到记录，它将发送回一个响应。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi lc"><img src="../Images/fae607a0070590eafb6261368ef18adc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FXqNHQ69bZrr7FD0QcCpPA.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">经纪人 3 尚未收到记录，因此不会确认制作人。</figcaption></figure><p id="3d32" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">2- <strong class="jm io">使用机架感知</strong> —通过复制，我们可以确保即使代理宕机，我们也可以确保主题的所有分区保持可用，而不会牺牲一致性。我们仍然需要担心整个数据中心/可用性区域中断的可能性。<br/> Kafka 使用一种称为机架感知的功能，轻松处理数据中心停机。机架可以代表可用性区域、数据中心或数据中心中的实际机架。<a class="ae ld" href="https://issues.apache.org/jira/browse/KAFKA-1215" rel="noopener ugc nofollow" target="_blank"> KAFKA-1215 </a>向 KAFKA 配置添加了一个机架 id。</p><p id="9603" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这可以处理数据中心和可用性区域级别的故障。</p><p id="136e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">3- <strong class="jm io">灾难恢复</strong> —精心制定灾难恢复计划，以最大限度地减少自然和人为灾难(如停电、灾难性软件故障和网络中断)对业务的影响。我们采用多区域策略，在地理上分散的数据中心中，服务与备份一起部署。</p><p id="55e3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">灾难恢复本身是一个大话题，超出了本次讨论的范围，但有了它，我们可以处理地理上分布的区域级故障。一本关于卡夫卡灾难恢复的好书。</p><p id="553a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">结论</strong> —消息队列临时存储消息，直到它们被消费者成功接收和处理。持久性意味着即使在消息的一个/一些副本失败后，消息仍然可用。Kafka 提供了复制、在生产者端使用 ack 设置的数据一致性以及机架感知等功能，以使消息持久并承受一定程度的故障。</p></div></div>    
</body>
</html>