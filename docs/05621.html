<html>
<head>
<title>Supporting User-selected Themes with Jetpack Compose</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Jetpack Compose 支持用户选择的主题</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/supporting-user-selected-themes-with-jetpack-compose-6446080ec234?source=collection_archive---------0-----------------------#2021-09-19">https://blog.devgenius.io/supporting-user-selected-themes-with-jetpack-compose-6446080ec234?source=collection_archive---------0-----------------------#2021-09-19</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/707a2843d2f3be1f678b0c3685c1eb60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i6M60QUGltMZMwJN2QHVwg.png"/></div></div></figure><p id="0914" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Jetpack Compose 为明暗主题之间的切换提供了出色的支持。如果您使用 Android Studio 对话框添加一个空的编写活动，它将免费出现在 IDE 为您添加的样板代码中。在<code class="fe kt ku kv kw b">ui/Theme.kt</code>中，您将会看到一个与此类似的函数:</p><pre class="kx ky kz la gt lb kw lc ld aw le bi"><span id="ebcb" class="lf lg in kw b gy lh li l lj lk">@Composable<br/>fun MyTheme(darkTheme: Boolean = isSystemInDarkTheme(), ...) {}</span></pre><p id="cf23" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">由于<code class="fe kt ku kv kw b">darkTheme</code>的默认值，你不必担心用户在系统设置中的明暗主题之间切换——你的应用程序会自动响应这一变化。然后，您将使用这个函数作为您的编写 UI 顶层的一种包装器，只需从函数调用中省略掉<code class="fe kt ku kv kw b">darkTheme</code>参数。</p><pre class="kx ky kz la gt lb kw lc ld aw le bi"><span id="0ace" class="lf lg in kw b gy lh li l lj lk">MyTheme {<br/>    Screen()<br/>}</span></pre><p id="a5ba" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是如果你的应用允许你的用户从应用的偏好中选择一个主题呢？应用程序让用户在亮主题、暗主题或匹配系统主题之间进行选择是非常常见的。应用程序也提供其他主题并不罕见——既有深色主题，也有黑色主题，或者更奢侈的主题。</p><p id="b113" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">那么我们如何在 Compose 中做到这一点呢？如果你仔细想想，在这种情况下，我们真的没有做任何根本不同的事情——我们只是观察和响应应用程序级别的偏好，而不是系统级别的偏好。因此，让我们看看样本黑暗主题支持是如何工作的，以了解从哪里开始。</p><p id="00b9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先注意，当我们调用<code class="fe kt ku kv kw b">MyTheme</code>函数时，我们只是省略了<code class="fe kt ku kv kw b">darkTheme</code>参数。我们可以这样调用这个函数:</p><pre class="kx ky kz la gt lb kw lc ld aw le bi"><span id="2309" class="lf lg in kw b gy lh li l lj lk">MyTheme(darkTheme = false) {<br/>    Screen()<br/>}</span></pre><p id="1b05" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">相反，我们将该值委托给函数<code class="fe kt ku kv kw b">isSystemInDarkTheme()</code>。如果我们检查<code class="fe kt ku kv kw b">isSystemInDarkTheme()</code>，我们看到它是一个返回布尔值的可组合函数。因为当用户改变他们的系统设置时，它能够强制<a class="ae ll" href="https://developer.android.com/jetpack/compose/mental-model#recomposition" rel="noopener ugc nofollow" target="_blank">重组</a>，我们知道它一定是在观察一个可变的状态。从概念上讲，大概是这样的:</p><pre class="kx ky kz la gt lb kw lc ld aw le bi"><span id="e020" class="lf lg in kw b gy lh li l lj lk">@Composable<br/>fun isSystemInDarkTheme(): Boolean {<br/>    val darkTheme by remember { mutableStateOf(false) }<br/>    return darkTheme<br/>}</span></pre><p id="d3fd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当然，在现实中，这个函数不是一个布尔文字<code class="fe kt ku kv kw b">false</code>而是观察系统的黑暗主题设置。但从概念上讲，这是幕后发生的事情。更改状态的值将强制重组，这将在整个可见的 UI 中级联为应用程序主题的更改。</p><p id="0f7a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，为了支持用户选择的主题，我们需要调整我们的“MyTheme”函数，以接受一个枚举主题参数而不是一个布尔值，并将其默认值设置为一个类似于“isSystemInDarkTheme”的可组合函数，该函数观察当前的应用程序主题。让我们打开包装。</p><p id="de07" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">假设我们的应用程序主题有一个如下所示的枚举:</p><pre class="kx ky kz la gt lb kw lc ld aw le bi"><span id="52c6" class="lf lg in kw b gy lh li l lj lk">enum class Theme {<br/>    Light,<br/>    Dark,<br/>    Auto<br/>}</span></pre><p id="b0a2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们不是将<code class="fe kt ku kv kw b">isSystemInDarkTheme()</code>作为参数传递给主题，而是传递一个观察当前主题的函数，如下所示:</p><pre class="kx ky kz la gt lb kw lc ld aw le bi"><span id="7b70" class="lf lg in kw b gy lh li l lj lk">@Composable<br/>fun MyTheme(theme: Theme = currentAppTheme(), ...) {}</span><span id="9a95" class="lf lg in kw b gy lm li l lj lk"><br/>@Composable<br/>fun currentAppTheme(): Theme {<br/>    val theme by themeFlow.collectAsState()<br/>    return theme<br/>}</span></pre><p id="7193" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe kt ku kv kw b">themeFlow</code>这里有一个代表当前应用主题的<code class="fe kt ku kv kw b">StateFlow</code>。它可能来自视图模型、数据存储或其他一些抽象的数据源。关键的部分是它是可观察的——每当用户在你的应用中改变他们的主题偏好，新的价值必须由这个可观察的来源发出。</p><p id="7430" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="ln">注意，如果它是一个纯粹的</em> <code class="fe kt ku kv kw b"><em class="ln">Flow</em></code> <em class="ln">(比如来自数据存储库)，那么调用将需要一个初始值，如</em> <code class="fe kt ku kv kw b"><em class="ln">themeFlow.collectAsState(initial = Theme.Auto).</em></code> <em class="ln">它也可以是一个</em> <code class="fe kt ku kv kw b"><em class="ln">LiveData</em></code> <em class="ln">，在这种情况下，您将调用</em> <code class="fe kt ku kv kw b"><em class="ln">themeLiveData.observeAsState().</em></code></p><p id="453c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这就是全部了！每当用户改变他们的主题偏好时，你的撰写 UI 将自动改变主题。</p></div><div class="ab cl lo lp hr lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ig ih ii ij ik"><p id="3598" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在上面的实现中，您可以拥有任意多的主题——红色主题、蓝色主题等等。但是请注意，在这个特定的例子中，我们仅有的主题是亮、暗和自动，我们可以很容易地将其与自动主题的<code class="fe kt ku kv kw b">isSystemInDarkTheme()</code>结合起来。</p><pre class="kx ky kz la gt lb kw lc ld aw le bi"><span id="0527" class="lf lg in kw b gy lh li l lj lk">@Composable<br/>fun isAppDarkTheme(): Boolean {<br/>    val theme by themeFlow.collectAsState()<br/><br/>    return when (theme) {<br/>        Light -&gt; false<br/>        Dark -&gt; true<br/>        Auto -&gt; isSystemInDarkTheme()<br/>    }<br/>}</span></pre><p id="10e5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当然，我们也可以将它与一个额外的自定义主题相结合:</p><pre class="kx ky kz la gt lb kw lc ld aw le bi"><span id="a28b" class="lf lg in kw b gy lh li l lj lk">enum class Theme {<br/>    Light,<br/>    Dark,<br/>    Auto,<br/>    Rainbow<br/>}</span><span id="8d7f" class="lf lg in kw b gy lm li l lj lk">@Composable<br/>fun currentAppTheme(): Theme {<br/>    val theme by themeFlow.collectAsState()<br/><br/>    return when (theme) {<br/>        Auto -&gt; {<br/>            if (isSystemInDarkTheme()) {<br/>                Dark<br/>            } else {<br/>                Light<br/>            }<br/>        }<br/>        else -&gt; theme<br/>    }<br/>}</span></pre><p id="8b72" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="ln">关注更多关于 Kotlin 和 Android 开发的最佳实践。</em></p></div></div>    
</body>
</html>