<html>
<head>
<title>Understanding Apache ShardingSphere’s SPI, and why it’s simpler than Dubbo’s</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解 Apache ShardingSphere 的 SPI，以及为什么它比 Dubbo 的简单</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/understanding-apache-shardingspheres-spi-and-why-it-s-simpler-than-dubbo-s-dac57b0cf98a?source=collection_archive---------15-----------------------#2022-06-15">https://blog.devgenius.io/understanding-apache-shardingspheres-spi-and-why-it-s-simpler-than-dubbo-s-dac57b0cf98a?source=collection_archive---------15-----------------------#2022-06-15</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jn jo jp jq gh gi paragraph-image"><div class="gh gi jm"><img src="../Images/eb751b1d519f9d64a330a8cef037ab9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1356/format:webp/1*7h3ue5yLGKwKqIYVF3Qe7w.png"/></div></figure><h2 id="856e" class="jt ju in bd jv jw jx dn jy jz ka dp kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated"><strong class="ak">为什么要学习</strong><a class="ae kp" href="https://shardingsphere.apache.org" rel="noopener ugc nofollow" target="_blank"><strong class="ak"/></a><strong class="ak">的 SPI？</strong></h2><p id="1e1e" class="pw-post-body-paragraph kq kr in ks b kt ku kv kw kx ky kz la kc lb lc ld kg le lf lg kk lh li lj lk ig bi translated">你可能已经熟悉了<a class="ae kp" href="https://www.java.com/en/" rel="noopener ugc nofollow" target="_blank"> Java </a>和<a class="ae kp" href="https://dubbo.apache.org/en/" rel="noopener ugc nofollow" target="_blank"> Dubbo </a>的<a class="ae kp" href="https://en.wikipedia.org/wiki/Service_provider_interface" rel="noopener ugc nofollow" target="_blank"> SPI(服务提供者接口)</a>机制，所以你可能会问“为什么我要学习<a class="ae kp" href="https://shardingsphere.apache.org" rel="noopener ugc nofollow" target="_blank"> ShardingSphere </a>的 SPI 机制？“原因很简单:</p><ol class=""><li id="3bd9" class="ll lm in ks b kt ln kx lo kc lp kg lq kk lr lk ls lt lu lv bi translated">ShardingSphere 的源代码更简单，也更容易适应。</li><li id="6079" class="ll lm in ks b kt lw kx lx kc ly kg lz kk ma lk ls lt lu lv bi translated">ShardingSphere 的 SPI 机制的执行相当流畅，日常操作所需的代码较少。与 Dubbo 的 SPI 机制及其与<a class="ae kp" href="https://medium.com/@amitkma/understanding-inversion-of-control-ioc-principle-163b1dc97454" rel="noopener"> IoC </a>相关的附加功能不同，ShardingSphere 中的机制只保留了基本结构，使用起来毫不费力。</li></ol><h2 id="779e" class="jt ju in bd jv jw jx dn jy jz ka dp kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated"><strong class="ak">了解 ShardingSphere 的 SPI </strong></h2><p id="18d5" class="pw-post-body-paragraph kq kr in ks b kt ku kv kw kx ky kz la kc lb lc ld kg le lf lg kk lh li lj lk ig bi translated">我们还必须提到在<a class="ae kp" href="https://docs.oracle.com/javase/tutorial/sound/SPI-intro.html" rel="noopener ugc nofollow" target="_blank"> Java SPI </a>机制中发现的一些缺点:</p><ol class=""><li id="f474" class="ll lm in ks b kt ln kx lo kc lp kg lq kk lr lk ls lt lu lv bi translated">使用具有多个并发线程的<a class="ae kp" href="https://docs.oracle.com/javase/8/docs/api/java/util/ServiceLoader.html" rel="noopener ugc nofollow" target="_blank"> ServiceLoader </a>类的实例是不安全的。</li><li id="e1a8" class="ll lm in ks b kt lw kx lx kc ly kg lz kk ma lk ls lt lu lv bi translated">每次获取一个元素，都需要迭代所有元素，不能按需加载。</li><li id="8cb7" class="ll lm in ks b kt lw kx lx kc ly kg lz kk ma lk ls lt lu lv bi translated">当实现类加载失败时，会提示一个异常，但没有指出真正的原因，这使得错误很难定位。</li><li id="0ec5" class="ll lm in ks b kt lw kx lx kc ly kg lz kk ma lk ls lt lu lv bi translated">获取实现类的方式不够灵活。只能通过<a class="ae kp" href="https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html" rel="noopener ugc nofollow" target="_blank">迭代器</a>形式获得，而不是基于一个参数获得对应的实现类。</li></ol><p id="ab13" class="pw-post-body-paragraph kq kr in ks b kt ln kv kw kx lo kz la kc mb lc ld kg mc lf lg kk md li lj lk ig bi translated">有鉴于此，让我们看看<a class="ae kp" href="https://shardingsphere.apache.org" rel="noopener ugc nofollow" target="_blank"> ShardingSphere </a>如何以一种简单的方式解决这些问题。</p><h2 id="c75f" class="jt ju in bd jv jw jx dn jy jz ka dp kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated"><strong class="ak">加载 SPI 类</strong></h2><p id="fe65" class="pw-post-body-paragraph kq kr in ks b kt ku kv kw kx ky kz la kc lb lc ld kg le lf lg kk lh li lj lk ig bi translated">Dubbo 是直接重写自己的 SPI，包括 SPI 文件名和文件配置方式，与<a class="ae kp" href="https://www.oracle.com/java/technologies/downloads/" rel="noopener ugc nofollow" target="_blank"> JDK </a>形成鲜明对比。下面我们简单比较一下这两者的用法区别:</p><p id="015b" class="pw-post-body-paragraph kq kr in ks b kt ln kv kw kx lo kz la kc mb lc ld kg mc lf lg kk md li lj lk ig bi translated"><strong class="ks io"> Java SPI </strong></p><p id="c0cb" class="pw-post-body-paragraph kq kr in ks b kt ln kv kw kx lo kz la kc mb lc ld kg mc lf lg kk md li lj lk ig bi translated">在<code class="fe me mf mg mh b">META-INF/services</code>文件夹下添加接口实现类</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="a783" class="jt ju in mh b gy mq mr l ms mt">optimusPrime = org.apache.spi.OptimusPrime<br/>bumblebee = org.apache.spi.Bumblebee</span></pre><p id="0df5" class="pw-post-body-paragraph kq kr in ks b kt ln kv kw kx lo kz la kc mb lc ld kg mc lf lg kk md li lj lk ig bi translated"><strong class="ks io">杜博 SPI </strong></p><p id="4334" class="pw-post-body-paragraph kq kr in ks b kt ln kv kw kx lo kz la kc mb lc ld kg mc lf lg kk md li lj lk ig bi translated">将接口的实现类添加到文件夹<code class="fe me mf mg mh b">META-INF/services</code>中，通过<code class="fe me mf mg mh b">key</code>、<code class="fe me mf mg mh b">value</code>进行配置，如下例:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="5c5f" class="jt ju in mh b gy mq mr l ms mt">optimusPrime = org.apache.spi.OptimusPrime<br/>bumblebee = org.apache.spi.Bumblebee</span></pre><p id="1dc8" class="pw-post-body-paragraph kq kr in ks b kt ln kv kw kx lo kz la kc mb lc ld kg mc lf lg kk md li lj lk ig bi translated">我们现在可以看到，Dubbo 的 Java SPI 与 JDK 的 SPI 完全不同。</p><h2 id="2367" class="jt ju in bd jv jw jx dn jy jz ka dp kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">【ShardingSphere 如何轻松扩展 JDK SPI？</h2><p id="2b16" class="pw-post-body-paragraph kq kr in ks b kt ku kv kw kx ky kz la kc lb lc ld kg le lf lg kk lh li lj lk ig bi translated">与 Dubbo 实现概念不同，ShardingSphere 用更少的代码扩展了 JDK SPI。</p><ol class=""><li id="ddc5" class="ll lm in ks b kt ln kx lo kc lp kg lq kk lr lk ls lt lu lv bi translated">该配置与 Java SPI 中的配置完全相同。</li></ol><p id="0413" class="pw-post-body-paragraph kq kr in ks b kt ln kv kw kx lo kz la kc mb lc ld kg mc lf lg kk md li lj lk ig bi translated">让我们以<code class="fe me mf mg mh b">DialectTableMetaDataLoader</code>接口实现类为例:</p><ul class=""><li id="43a3" class="ll lm in ks b kt ln kx lo kc lp kg lq kk lr lk mu lt lu lv bi translated"><code class="fe me mf mg mh b">DialectTableMetaDataLoader.class</code></li></ul><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="7293" class="jt ju in mh b gy mq mr l ms mt">public interface DialectTableMetaDataLoader extends StatelessTypedSPI {</span><span id="78a1" class="jt ju in mh b gy mv mr l ms mt">    /**<br/>     * Load table meta data.<br/>     *<br/>     * @param dataSource data source<br/>     * @param tables tables<br/>     * @return table meta data map<br/>     * @throws SQLException SQL exception<br/>     */<br/>    Map&lt;String, TableMetaData&gt; load(DataSource dataSource, Collection&lt;String&gt; tables) throws SQLException;<br/>}</span><span id="9fd0" class="jt ju in mh b gy mv mr l ms mt">public interface TypedSPI {</span><span id="2685" class="jt ju in mh b gy mv mr l ms mt">    /**<br/>     * Get type.<br/>     * <br/>     * @return type<br/>     */<br/>    String getType();</span><span id="2355" class="jt ju in mh b gy mv mr l ms mt">    /**<br/>     * Get type aliases.<br/>     *<br/>     * @return type aliases<br/>     */<br/>    default Collection&lt;String&gt; getTypeAliases() {<br/>        return Collections.emptyList();<br/>    }<br/>}</span></pre><p id="8886" class="pw-post-body-paragraph kq kr in ks b kt ln kv kw kx lo kz la kc mb lc ld kg mc lf lg kk md li lj lk ig bi translated"><code class="fe me mf mg mh b">StatelessTypedSPI</code>接口取自<code class="fe me mf mg mh b">TypedSPI</code>，使用多个接口以满足单一接口负责的原则。<code class="fe me mf mg mh b">TypedSPI</code>是<code class="fe me mf mg mh b">Map</code>的键，其中子类需要指定自己的 SPI。</p><p id="b57e" class="pw-post-body-paragraph kq kr in ks b kt ln kv kw kx lo kz la kc mb lc ld kg mc lf lg kk md li lj lk ig bi translated">这里你不需要关心什么方法是由<code class="fe me mf mg mh b">DialectTableMetaDataLoader </code>接口定义的，你只需要关注子类是如何被 SPI 加载的。如果是 Java SPI，要加载子类，只需在<code class="fe me mf mg mh b">META-INF/services</code>中用完整的类名定义它。</p><figure class="mi mj mk ml gt jq gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi mw"><img src="../Images/ba201d4da0da2ffa00595c99c833858f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*nkXeenlarccXgyGB"/></div></div></figure><p id="9a82" class="pw-post-body-paragraph kq kr in ks b kt ln kv kw kx lo kz la kc mb lc ld kg mc lf lg kk md li lj lk ig bi translated">如您所见，它与原生 java SPI 配置完全相同。那么它的缺点怎么样呢？</p><h2 id="fd5b" class="jt ju in bd jv jw jx dn jy jz ka dp kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated"><strong class="ak">使用工厂方法模式</strong></h2><p id="ca6a" class="pw-post-body-paragraph kq kr in ks b kt ku kv kw kx ky kz la kc lb lc ld kg le lf lg kk lh li lj lk ig bi translated">对于每个需要由 SPI 扩展和创建的接口，通常都有一个类似的<code class="fe me mf mg mh b">xxDataLoaderFactory</code>来创建和获取指定的 SPI 扩展类。</p><p id="3014" class="pw-post-body-paragraph kq kr in ks b kt ln kv kw kx lo kz la kc mb lc ld kg mc lf lg kk md li lj lk ig bi translated"><code class="fe me mf mg mh b"><strong class="ks io">DialectTableMetaDataLoaderFactory</strong></code></p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="3b41" class="jt ju in mh b gy mq mr l ms mt">@NoArgsConstructor(access = AccessLevel.PRIVATE)<br/>public final class DialectTableMetaDataLoaderFactory {</span><span id="a80e" class="jt ju in mh b gy mv mr l ms mt">    static {<br/>        ShardingSphereServiceLoader.register(DialectTableMetaDataLoader.class);<br/>    }</span><span id="194d" class="jt ju in mh b gy mv mr l ms mt">    /**<br/>     * Create new instance of dialect table meta data loader.<br/>     * <br/>     * @param databaseType database type<br/>     * @return new instance of dialect table meta data loader<br/>     */<br/>    public static Optional&lt;DialectTableMetaDataLoader&gt; newInstance(final DatabaseType databaseType) {<br/>        return TypedSPIRegistry.findRegisteredService(DialectTableMetaDataLoader.class, databaseType.getName());<br/>    }<br/>}</span></pre><p id="80c0" class="pw-post-body-paragraph kq kr in ks b kt ln kv kw kx lo kz la kc mb lc ld kg mc lf lg kk md li lj lk ig bi translated">这里你可以看到使用了一个静态块，所有的<code class="fe me mf mg mh b">DialectTableMetaDataLoader </code>实现类都是在类加载过程中通过<code class="fe me mf mg mh b">ShardingSphereServiceLoader.register </code>注册的。通过使用<code class="fe me mf mg mh b">TypedSPIRegistry.findRegisteredService</code>，我们可以得到我们指定的 spi 扩展类。</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="a355" class="jt ju in mh b gy mq mr l ms mt">TypedSPIRegistry.findRegisteredService(final Class&lt;T&gt; spiClass, final String type)</span></pre><p id="6e6c" class="pw-post-body-paragraph kq kr in ks b kt ln kv kw kx lo kz la kc mb lc ld kg mc lf lg kk md li lj lk ig bi translated">所以我们只需关注<code class="fe me mf mg mh b">ShardingSphereServiceLoader.register``</code>和<code class="fe me mf mg mh b">ypedSPIRegistry.findRegisteredService</code>途径。</p><p id="a969" class="pw-post-body-paragraph kq kr in ks b kt ln kv kw kx lo kz la kc mb lc ld kg mc lf lg kk md li lj lk ig bi translated"><code class="fe me mf mg mh b"><strong class="ks io">ShardingSphereServiceLoader</strong></code></p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="f1d2" class="jt ju in mh b gy mq mr l ms mt">@NoArgsConstructor(access =AccessLevel.PRIVATE)<br/>public final class ShardingSphereServiceLoader {</span><span id="5448" class="jt ju in mh b gy mv mr l ms mt">    private static final Map&lt;Class&lt;?&gt;, Collection&lt;object&gt;&gt; SERVICES = new ConcurrentHashMap&lt;&gt;();</span><span id="6414" class="jt ju in mh b gy mv mr l ms mt">    /**<br/>     *Register service.<br/>     *<br/>     *@param serviceInterface service interface<br/>     */<br/>    public static void register(final Class&lt;?&gt; serviceInterface){<br/>        if (!SERVICES.containsKey(serviceInterface)) {<br/>            SERVICES.put(serviceInterface, load(serviceInterface) ) ;<br/>        }<br/>    }<br/>   <br/>    private static &lt;T&gt; Collection&lt;Object&gt; load(final Class&lt;T&gt; serviceInterface) {<br/>        Collection&lt;Object&gt; result = new LinkedList&lt;&gt;();<br/>        for (T each: ServiceLoader. load(serviceInterface)) {<br/>        result.add(each);<br/>        }<br/>        return result;<br/>    }<br/>    <br/>    /**<br/>     *Get singleton service instances.<br/>     *<br/>     *@param service service class<br/>     * @param &lt;T&gt; type of service<br/>     *@return service instances<br/>     */<br/>    @SuppressWarnings("unchecked")<br/>    public static &lt;T&gt; Collection&lt;T&gt; getSingletonServiceInstances(final Class&lt;T&gt; service) {<br/>        return (Collection&lt;T&gt;) SERVICES.getorDefault(service,Collections.emptyList());<br/>    }<br/>    <br/>    /**<br/>     *New service instances.<br/>     *<br/>     * eparam service service class<br/>     *@param &lt;T&gt; type of service<br/>     *@return service instances<br/>     */<br/>    @SuppressWarnings ("unchecked" )<br/>    public static &lt;T&gt; Collection&lt;T&gt; newserviceInstances(final Class&lt;T&gt; service){<br/>        if(!SERVICES.containskey(service)) {<br/>           return Collections.emptyList();<br/>        }<br/>        Collection&lt;object&gt; services = SERVICES.get(service);<br/>        if (services.isEmpty()){<br/>            return Collections.emptyList();<br/>        }<br/>        Collection&lt;T&gt; result = new ArrayList&lt;&gt;(services.size());<br/>        for (Object each: services) {<br/>            result.add((T) newServiceInstance(each.getClass()));<br/>        }<br/>        return result;<br/>    }<br/>    <br/>    private static Object newServiceInstance(final Class&lt;?&gt; clazz) {<br/>        try{<br/>           return clazz.getDeclaredConstructor( ) . newInstance( ) ;<br/>        } catch (final ReflectiveOperationException ex) {<br/>            throw new ServiceLoaderInstantiationException(clazz, ex);<br/>        }<br/>    }<br/>}</span></pre><p id="24c2" class="pw-post-body-paragraph kq kr in ks b kt ln kv kw kx lo kz la kc mb lc ld kg mc lf lg kk md li lj lk ig bi translated">我们可以看到所有的 SPI 类都放在这个<code class="fe me mf mg mh b">SERVICES</code>属性中。</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="06e2" class="jt ju in mh b gy mq mr l ms mt">private static final Map&lt;Class&lt;?&gt;, Collection&lt;Object&gt;&gt; SERVICES = new ConcurrentHashMap&lt;&gt;();</span></pre><p id="9eb9" class="pw-post-body-paragraph kq kr in ks b kt ln kv kw kx lo kz la kc mb lc ld kg mc lf lg kk md li lj lk ig bi translated">注册也很简单，只需使用嵌入在 java 中的 SPI api。</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="0782" class="jt ju in mh b gy mq mr l ms mt">public static void register(final Class&lt;?&gt; serviceInterface) {<br/>        if (!SERVICES.containsKey(serviceInterface)) {<br/>            SERVICES.put(serviceInterface, load(serviceInterface));<br/>        }<br/>    }</span><span id="15b8" class="jt ju in mh b gy mv mr l ms mt">private static &lt;T&gt; Collection&lt;Object&gt; load(final Class&lt;T&gt; serviceInterface) {<br/>        Collection&lt;Object&gt; result = new LinkedList&lt;&gt;();<br/>        for (T each : ServiceLoader.load(serviceInterface)) {<br/>            result.add(each);<br/>        }<br/>        return result;<br/>    }</span></pre><p id="f80c" class="pw-post-body-paragraph kq kr in ks b kt ln kv kw kx lo kz la kc mb lc ld kg mc lf lg kk md li lj lk ig bi translated"><code class="fe me mf mg mh b"><strong class="ks io">TypedSPIRegistry</strong></code></p><p id="db68" class="pw-post-body-paragraph kq kr in ks b kt ln kv kw kx lo kz la kc mb lc ld kg mc lf lg kk md li lj lk ig bi translated"><code class="fe me mf mg mh b">TypedSPIRegistry</code>中的<code class="fe me mf mg mh b">findRegisteredService</code>方法本质上是对<code class="fe me mf mg mh b">ShardingSphereServiceLoader</code>的<code class="fe me mf mg mh b">getSingletonServiceInstances</code>方法的调用。</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="a4e0" class="jt ju in mh b gy mq mr l ms mt">public static &lt;T extends StatelessTypedSPI&gt; Optional&lt;T&gt; findRegisteredService(final Class&lt;T&gt; spiClass, final String type) {<br/>        for (T each : ShardingSphereServiceLoader.getSingletonServiceInstances(spiClass)) {<br/>            if (matchesType(type, each)) {<br/>                return Optional.of(each);<br/>            }<br/>        }<br/>        return Optional.empty();<br/>    }</span><span id="2891" class="jt ju in mh b gy mv mr l ms mt">private static boolean matchesType(final String type, final TypedSPI typedSPI) {<br/>        return typedSPI.getType().equalsIgnoreCase(type) || typedSPI.getTypeAliases().contains(type);<br/>    }</span></pre><p id="3db2" class="pw-post-body-paragraph kq kr in ks b kt ln kv kw kx lo kz la kc mb lc ld kg mc lf lg kk md li lj lk ig bi translated">这里你可以看到类扩展正在使用<code class="fe me mf mg mh b">TypedSPI</code>中的<code class="fe me mf mg mh b">getType</code>或<code class="fe me mf mg mh b">getTypeAliases</code>来获得匹配，这就是为什么每个 SPI 都需要实现<code class="fe me mf mg mh b">TypedSPI</code>接口。</p><p id="99fe" class="pw-post-body-paragraph kq kr in ks b kt ln kv kw kx lo kz la kc mb lc ld kg mc lf lg kk md li lj lk ig bi translated">现在让我们看看<code class="fe me mf mg mh b">ShardingSphereServiceLoader</code>中的<code class="fe me mf mg mh b">newServiceInstances</code>方法</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="3bd6" class="jt ju in mh b gy mq mr l ms mt">public static &lt;T&gt; Collection&lt;T&gt; newServiceInstances(final Class&lt;T&gt; service) {<br/>        if (!SERVICES.containsKey(service)) {<br/>            return Collections.emptyList();<br/>        }<br/>        Collection&lt;Object&gt; services = SERVICES.get(service);<br/>        if (services.isEmpty()) {<br/>            return Collections.emptyList();<br/>        }<br/>        Collection&lt;T&gt; result = new ArrayList&lt;&gt;(services.size());<br/>        for (Object each : services) {<br/>            result.add((T) newServiceInstance(each.getClass()));<br/>        }<br/>        return result;<br/>    }</span></pre><p id="49fd" class="pw-post-body-paragraph kq kr in ks b kt ln kv kw kx lo kz la kc mb lc ld kg mc lf lg kk md li lj lk ig bi translated">你可以看到，在通过静态代码块注册的<code class="fe me mf mg mh b">SERVICES</code>中直接找到接口的所有实现类返回也非常简单。</p><p id="a775" class="pw-post-body-paragraph kq kr in ks b kt ln kv kw kx lo kz la kc mb lc ld kg mc lf lg kk md li lj lk ig bi translated">虽然很短，但这个简短的演练基本上介绍了 ShardingSphere 的 SPI 源代码。我们确信你已经注意到使用 ShardingSphere 的 SPI 比 Dubbo 的 SPI 机制要容易和简单得多。</p><h2 id="0d93" class="jt ju in bd jv jw jx dn jy jz ka dp kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated"><strong class="ak">总结</strong></h2><p id="a6e4" class="pw-post-body-paragraph kq kr in ks b kt ku kv kw kx ky kz la kc lb lc ld kg le lf lg kk lh li lj lk ig bi translated">ShardingSphere 和 Dubbo 的 SPI 都满足了按键查找指定实现类的要求，不用每次使用都重新加载所有实现类，解决了并发加载问题。然而，与 Dubbo 相比，ShardingSphere SPI 更精简，更易于使用。</p><p id="19ba" class="pw-post-body-paragraph kq kr in ks b kt ln kv kw kx lo kz la kc mb lc ld kg mc lf lg kk md li lj lk ig bi translated">您可以在以后编写自己的 SPI 扩展时参考 ShardingSphere 实现，因为它实现起来更简单，使用起来也很优雅。您可以基于 SPI 编写一个可扩展的配置文件解析器，这样我们就可以了解 SPI 的能力及其应用场景。</p><h1 id="55e0" class="nb ju in bd jv nc nd ne jy nf ng nh kb ni nj nk kf nl nm nn kj no np nq kn nr bi translated">Apache ShardingSphere 项目链接:</h1><p id="e781" class="pw-post-body-paragraph kq kr in ks b kt ku kv kw kx ky kz la kc lb lc ld kg le lf lg kk lh li lj lk ig bi translated"><a class="ae kp" href="https://github.com/apache/shardingsphere/issues?page=1&amp;q=is%3Aopen+is%3Aissue+label%3A%22project%3A+OpenForce+2022%22" rel="noopener ugc nofollow" target="_blank"> ShardingSphere Github </a></p><p id="2fa1" class="pw-post-body-paragraph kq kr in ks b kt ln kv kw kx lo kz la kc mb lc ld kg mc lf lg kk md li lj lk ig bi translated">推特</p><p id="3a08" class="pw-post-body-paragraph kq kr in ks b kt ln kv kw kx lo kz la kc mb lc ld kg mc lf lg kk md li lj lk ig bi translated"><a class="ae kp" href="https://join.slack.com/t/apacheshardingsphere/shared_invite/zt-sbdde7ie-SjDqo9~I4rYcR18bq0SYTg" rel="noopener ugc nofollow" target="_blank">切割球松弛度</a></p><p id="79e0" class="pw-post-body-paragraph kq kr in ks b kt ln kv kw kx lo kz la kc mb lc ld kg mc lf lg kk md li lj lk ig bi translated"><a class="ae kp" href="https://shardingsphere.apache.org/community/cn/contribute/" rel="noopener ugc nofollow" target="_blank">投稿指南</a></p></div></div>    
</body>
</html>