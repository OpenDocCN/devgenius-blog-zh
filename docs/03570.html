<html>
<head>
<title>Object-Oriented JavaScript — Multiple Inheritance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向对象的 JavaScript —多重继承</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/object-oriented-javascript-multiple-inheritance-ca07df32d137?source=collection_archive---------3-----------------------#2020-11-19">https://blog.devgenius.io/object-oriented-javascript-multiple-inheritance-ca07df32d137?source=collection_archive---------3-----------------------#2020-11-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/6594c8b117c97add155b7393fe5ad9c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CDlk29GSUoTE_doV"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@eprouzet?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Eric Prouzet </a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="2bad" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JavaScript 部分是面向对象的语言。</p><p id="7b04" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要学习 JavaScript，我们必须学习 JavaScript 的面向对象部分。</p><p id="6eb1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究多重继承。</p><h1 id="cd42" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">多重遗传</h1><p id="ba52" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">通过将不同属性的属性合并到一个对象中，然后返回该对象，我们可以很容易地实现多重继承。</p><p id="d5e3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="7826" class="mn lc iq mj b gy mo mp l mq mr">function multi(...args) {<br/>  let obj = {};<br/>  for (const arg of args) {<br/>    obj = {<br/>      ...obj,<br/>      ...arg<br/>    };<br/>  }<br/>  return obj;<br/>}</span></pre><p id="0262" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以通过写来使用它:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="c7e7" class="mn lc iq mj b gy mo mp l mq mr">const obj = multi({<br/>  foo: 1<br/>}, {<br/>  bar: 2<br/>}, {<br/>  baz: 3<br/>});</span></pre><p id="89b3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">obj</code>接着是:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="9a4b" class="mn lc iq mj b gy mo mp l mq mr">{foo: 1, bar: 2, baz: 3}</span></pre><p id="d3b6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们传入多个对象，然后用 spread 操作符复制属性。</p><h1 id="2efc" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">混合蛋白</h1><p id="16d9" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">Mixins 是一个可以合并到另一个对象中的对象。</p><p id="bade" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们创建一个对象时，我们可以选择将哪个混音合并到最终的对象中。</p><h1 id="7dd4" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">寄生遗传</h1><p id="0680" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">寄生继承是指我们将另一个对象的所有功能移植到一个新的对象中。</p><p id="ea33" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个图案是道格拉斯·克洛克福特创造的。</p><p id="51df" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="f919" class="mn lc iq mj b gy mo mp l mq mr">function object(proto) {<br/>  function F() {}<br/>  F.prototype = proto;<br/>  return new F();<br/>}</span><span id="28e1" class="mn lc iq mj b gy mv mp l mq mr">const baseObj = {<br/>  name: '2D shape',<br/>  dimensions: 2<br/>};</span><span id="51c3" class="mn lc iq mj b gy mv mp l mq mr">function rectangle(baseObj, width, height) {<br/>  const obj = object(baseObj);<br/>  obj.name = 'rectangle';<br/>  obj.getArea = function() {<br/>    return this.width * this.height;<br/>  };<br/>  obj.width = width;<br/>  obj.height = height;<br/>  return obj;<br/>}</span><span id="38f8" class="mn lc iq mj b gy mv mp l mq mr">const rect = rectangle(baseObj, 2, 3);<br/>console.log(rect);<br/>console.log(rect.getArea());</span></pre><p id="267a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有返回一个<code class="fe ms mt mu mj b">F</code>实例的<code class="fe ms mt mu mj b">object</code>函数。</p><p id="b34d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们创建了包含了<code class="fe ms mt mu mj b">baseOf</code>、<code class="fe ms mt mu mj b">width</code>和<code class="fe ms mt mu mj b">height</code>的<code class="fe ms mt mu mj b">rectangle</code>函数，并将其合并到由<code class="fe ms mt mu mj b">object</code>返回的对象中。</p><p id="0d5c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">object</code>将<code class="fe ms mt mu mj b">baseObj</code>变为<code class="fe ms mt mu mj b">F</code>的原型。</p><p id="cee5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将自己的属性添加到<code class="fe ms mt mu mj b">obj</code>，我们返回它来添加更多的属性。</p><p id="cd16" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样，如果我们记录<code class="fe ms mt mu mj b">rect</code>的值，我们会得到:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="5ffb" class="mn lc iq mj b gy mo mp l mq mr">{name: "rectangle", width: 2, height: 3, getArea: ƒ</span></pre><p id="818c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">rect</code>的<code class="fe ms mt mu mj b">__proto__</code>有:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="173c" class="mn lc iq mj b gy mo mp l mq mr">dimensions: 2<br/>name: "2D shape"</span></pre><p id="23c8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也可以像在上一个控制台日志中那样调用<code class="fe ms mt mu mj b">getArea</code>，我们得到 6。</p><p id="76ec" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们知道<code class="fe ms mt mu mj b">this</code>指的是返回的对象。</p><h1 id="06bf" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">借用构造函数</h1><p id="97a4" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以从子构造函数调用父构造函数。</p><p id="1693" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="4faf" class="mn lc iq mj b gy mo mp l mq mr">function Shape(id) {<br/>  this.id = id;<br/>}</span><span id="3a7a" class="mn lc iq mj b gy mv mp l mq mr">Shape.prototype.name = 'Shape';<br/>Shape.prototype.toString = function() {<br/>  return this.name;<br/>};</span><span id="cb38" class="mn lc iq mj b gy mv mp l mq mr">function Square(id, name, length) {<br/>  Shape.apply(this, [id]);<br/>  this.name = name;<br/>  this.length = length;<br/>}</span><span id="c9a8" class="mn lc iq mj b gy mv mp l mq mr">Square.prototype = new Shape();<br/>Square.prototype.name = 'Square';</span></pre><p id="1ced" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有<code class="fe ms mt mu mj b">Shape</code>构造函数，它接受<code class="fe ms mt mu mj b">id</code>参数。</p><p id="eca2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用<code class="fe ms mt mu mj b">apply</code>调用<code class="fe ms mt mu mj b">Shape</code>构造函数，这样我们<code class="fe ms mt mu mj b">this</code>就被设置为<code class="fe ms mt mu mj b">Shape</code>构造函数。</p><p id="3cab" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这将从<code class="fe ms mt mu mj b">Square</code>设置<code class="fe ms mt mu mj b">this.id</code>。</p><p id="16fe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以填充我们自己的属性。</p><p id="53b8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们用<code class="fe ms mt mu mj b">Shape</code>实例创建<code class="fe ms mt mu mj b">Square</code>的<code class="fe ms mt mu mj b">prototype</code>。</p><p id="3ec9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们将<code class="fe ms mt mu mj b">name</code>设置为<code class="fe ms mt mu mj b">'Square'</code>，因为这是因为所有的<code class="fe ms mt mu mj b">Square</code>实例而共享的。</p><p id="34c9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另外，我们通过设置<code class="fe ms mt mu mj b">Square</code>的<code class="fe ms mt mu mj b">prototype</code>属性将属性从<code class="fe ms mt mu mj b">Shape</code>复制到<code class="fe ms mt mu mj b">Square</code>。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/cf83bd02c9a0051c2a94d1ff51c93bcf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*AK_vdm_DJf5JhiH7"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">Eric Prouzet 在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="f863" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="bb30" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用不同的继承方式创建对象。</p><p id="325e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以调用父类的构造函数，合并不同对象的不同属性。</p></div></div>    
</body>
</html>