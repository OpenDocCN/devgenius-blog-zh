<html>
<head>
<title>Using std::map Wisely With Modern C++</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在现代 C++中明智地使用 std::map</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/using-std-map-wisely-with-modern-c-cdc7c2c81b52?source=collection_archive---------5-----------------------#2020-08-03">https://blog.devgenius.io/using-std-map-wisely-with-modern-c-cdc7c2c81b52?source=collection_archive---------5-----------------------#2020-08-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/ee79925cc68dcce2433dadf2e39948ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VOuva8BAxnRzEzld0xK0Ow.png"/></div></div></figure><p id="38f6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" href="https://en.cppreference.com/w/cpp/container/map" rel="noopener ugc nofollow" target="_blank"> std::map </a>和它的兄弟(<a class="ae kw" href="https://en.cppreference.com/w/cpp/container/multimap" rel="noopener ugc nofollow" target="_blank"> std::multimap </a>，<a class="ae kw" href="https://en.cppreference.com/w/cpp/container/unordered_map" rel="noopener ugc nofollow" target="_blank">STD::unordered _ map</a>/<a class="ae kw" href="https://en.cppreference.com/w/cpp/container/unordered_multimap" rel="noopener ugc nofollow" target="_blank">multimap</a>)曾经是我做竞技编程时最喜欢的容器。事实上，我仍然喜欢它们(尽管现在用得不那么频繁了)。而有了<a class="ae kw" href="http://www.vishalchovatiya.com/21-new-features-of-modern-cpp-to-use-in-your-project/" rel="noopener ugc nofollow" target="_blank">现代 C++ </a>，我们现在有了更多使用 std::map 的理由。这就是为什么我决定写一篇总结这些新特性的文章来讨论这个话题。所以，废话不多说，让我们直接开始吧。</p><blockquote class="kx ky kz"><p id="ef9d" class="jy jz la ka b kb kc kd ke kf kg kh ki lb kk kl km lc ko kp kq ld ks kt ku kv ij bi translated"><em class="iq"> /！\:本文最初发表于我的</em> <a class="ae kw" href="http://www.vishalchovatiya.com/using-std-map-wisely-with-modern-cpp/" rel="noopener ugc nofollow" target="_blank"> <em class="iq">博客</em> </a> <em class="iq">。如果你有兴趣接收我的最新文章，</em> <a class="ae kw" href="http://eepurl.com/gDNybv" rel="noopener ugc nofollow" target="_blank"> <em class="iq">请报名参加我的简讯</em> </a> <em class="iq">。</em></p></blockquote><h1 id="7f5c" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated"><a class="ae kw" href="https://en.cppreference.com/w/cpp/container/map/contains" rel="noopener ugc nofollow" target="_blank"> std::map::包含</a> (C++20)</h1><ul class=""><li id="3638" class="mc md iq ka b kb me kf mf kj mg kn mh kr mi kv mj mk ml mm bi translated">成员函数是迈向代码表现力的良好一步。我也厌倦了写作:</li></ul><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="2a48" class="mz lf iq mq b gy na nb l nc nd">if (auto search = freq_of.find(2); search != freq_of.end()) {<br/>    cout &lt;&lt; "Found" &lt;&lt; endl;<br/>}<br/>// Where assume, freq_of = map&lt;uint32_t, uint32_t&gt;{{3, 1}, {1, 1}, {2, 1}};</span></pre><ul class=""><li id="fa28" class="mc md iq ka b kb kc kf kg kj ne kn nf kr ng kv mj mk ml mm bi translated">相反，从 C++20 开始，您可以编写:</li></ul><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="64fb" class="mz lf iq mq b gy na nb l nc nd">if (freq_of.contains(2)) {<br/>    cout &lt;&lt; "Found" &lt;&lt; endl;<br/>}</span></pre><blockquote class="kx ky kz"><p id="68dc" class="jy jz la ka b kb kc kd ke kf kg kh ki lb kk kl km lc ko kp kq ld ks kt ku kv ij bi translated">我们写的代码首先是供人使用的，其次才是供计算机理解的。</p><p id="6aa6" class="jy jz la ka b kb kc kd ke kf kg kh ki lb kk kl km lc ko kp kq ld ks kt ku kv ij bi translated"><strong class="ka ir"><em class="iq">——约翰·桑梅兹</em> </strong></p></blockquote><h1 id="4ef5" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated"><a class="ae kw" href="https://en.cppreference.com/w/cpp/container/map/try_emplace" rel="noopener ugc nofollow" target="_blank">STD::map::try _ location</a>(c++ 17)</h1><ul class=""><li id="5fbe" class="mc md iq ka b kb me kf mf kj mg kn mh kr mi kv mj mk ml mm bi translated">在插入地图时，我们有两种不同的可能性:</li></ul><ol class=""><li id="842b" class="mc md iq ka b kb kc kf kg kj ne kn nf kr ng kv nh mk ml mm bi translated">密钥还不存在。创建一个新的键值对。</li><li id="f8a0" class="mc md iq ka b kb ni kf nj kj nk kn nl kr nm kv nh mk ml mm bi translated">该密钥已经存在。获取现有项目并对其进行修改。</li></ol><ul class=""><li id="2097" class="mc md iq ka b kb kc kf kg kj ne kn nf kr ng kv mj mk ml mm bi translated">在<code class="fe mn mo mp mq b">std::map</code>中插入元素的典型方法是使用<code class="fe mn mo mp mq b">operator[ ]</code>、<code class="fe mn mo mp mq b">std::map::insert</code>或<code class="fe mn mo mp mq b">std::map::emplace</code>。但是，在所有这些情况下，我们必须承担默认/专用构造函数或赋值调用的成本。最糟糕的是，如果一个项目已经存在，我们必须删除新创建的项目。</li></ul><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="754d" class="mz lf iq mq b gy na nb l nc nd">int main() {<br/>    vector v{3, 4, 5, 8, 7, 3, 5, 2, 4};<br/>    map&lt;uint32_t, uint32_t&gt; freq_of;</span><span id="5819" class="mz lf iq mq b gy nn nb l nc nd">    for (const auto &amp;n : v) {<br/>        if (const auto &amp;[it, inserted] = freq_of.emplace(n, 1); !inserted) {<br/>            it-&gt;second++;  // Exists already<br/>        }<br/>    }</span><span id="1aff" class="mz lf iq mq b gy nn nb l nc nd">    assert(freq_of[3] == 2);</span><span id="d2c2" class="mz lf iq mq b gy nn nb l nc nd">    return EXIT_SUCCESS;<br/>}</span></pre><ul class=""><li id="95bb" class="mc md iq ka b kb kc kf kg kj ne kn nf kr ng kv mj mk ml mm bi translated">相反:</li></ul><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="af34" class="mz lf iq mq b gy na nb l nc nd">if (const auto &amp;[it, inserted] = freq_of.try_emplace(n, 1); !inserted) {<br/>    it-&gt;second++;<br/>}</span></pre><ul class=""><li id="90d7" class="mc md iq ka b kb kc kf kg kj ne kn nf kr ng kv mj mk ml mm bi translated">但是，从 C++17 开始，有了这个<strong class="ka ir"><em class="la">STD::map::try _ location 方法，只在 key 还不存在的情况下创建条目</em> </strong>。如果创建这种类型的对象成本很高，这将提高性能。</li><li id="f251" class="mc md iq ka b kb ni kf nj kj nk kn nl kr nm kv mj mk ml mm bi translated">虽然上面的例子没有展示昂贵的创建项目。但是，是的！每当你遇到这样的情况，一定要知道如何用<code class="fe mn mo mp mq b">std::map::try_emplace</code>来处理。</li></ul><h1 id="2f41" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated"><a class="ae kw" href="https://en.cppreference.com/w/cpp/container/map/insert_or_assign" rel="noopener ugc nofollow" target="_blank">STD::map::insert _ or _ assign</a>(c++ 17)</h1><ul class=""><li id="5617" class="mc md iq ka b kb me kf mf kj mg kn mh kr mi kv mj mk ml mm bi translated">无论如何都要插入元素。为了方便起见，你用<a class="ae kw" href="https://en.cppreference.com/w/cpp/container/map/operator_at" rel="noopener ugc nofollow" target="_blank"> std::map::operator[ ] </a>。哪个好(还有<a class="ae kw" href="https://devblogs.microsoft.com/oldnewthing/20190227-00/?p=101072" rel="noopener ugc nofollow" target="_blank">危险</a>)！除非您对插入或赋值有任何限制。</li><li id="ce38" class="mc md iq ka b kb ni kf nj kj nk kn nl kr nm kv mj mk ml mm bi translated">例如，在计算元素的频率时，增加了一个约束，即当一个元素重复(即分配)时，您必须删除小于当前元素的所有元素。</li><li id="589b" class="mc md iq ka b kb ni kf nj kj nk kn nl kr nm kv mj mk ml mm bi translated">在这样的情况下，<code class="fe mn mo mp mq b">std::map::operator[ ]</code>是不可行的。相反，<code class="fe mn mo mp mq b"><strong class="ka ir"><em class="la">std::map::insert_or_assign</em></strong></code> <strong class="ka ir"> <em class="la">比</em> </strong> <code class="fe mn mo mp mq b"><a class="ae kw" href="https://dev.tostd::map::operator%5B%20%5D" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir"><em class="la">std::map::operator[ ]</em></strong></a></code>更合适，返回的信息更多。它也不要求映射类型的默认构造性。考虑以下同样的例子。</li></ul><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="61fe" class="mz lf iq mq b gy na nb l nc nd">int main() {<br/>    vector v{8, 3, 9, 5, 8};<br/>    map&lt;uint32_t, uint32_t&gt; freq_of;</span><span id="99b7" class="mz lf iq mq b gy nn nb l nc nd">    for (auto &amp;&amp;n : v) {<br/>        const auto &amp;[it, is_inserted] = freq_of.insert_or_assign(n, 1);</span><span id="a456" class="mz lf iq mq b gy nn nb l nc nd">        if (!is_inserted) { // remove all lesser element then current one if repeated<br/>            freq_of.erase(begin(freq_of), it);<br/>        }<br/>    }</span><span id="81c0" class="mz lf iq mq b gy nn nb l nc nd">    assert((freq_of == decltype(freq_of){<br/>                           {8, 1},<br/>                           {9, 1},<br/>                       }));</span><span id="b50d" class="mz lf iq mq b gy nn nb l nc nd">    return EXIT_SUCCESS;<br/>}</span></pre><h1 id="7674" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated"><a class="ae kw" href="https://en.cppreference.com/w/cpp/container/map/insert" rel="noopener ugc nofollow" target="_blank"> std::map::insert </a>带提示(C++11/17)</h1><ul class=""><li id="fed8" class="mc md iq ka b kb me kf mf kj mg kn mh kr mi kv mj mk ml mm bi translated">在<code class="fe mn mo mp mq b">std::map</code>中查找项目需要<code class="fe mn mo mp mq b">O(log(n))</code>时间。插入新项目也是如此。因为必须查找插入它们的位置。因此，简单地插入<code class="fe mn mo mp mq b">M</code>新项目会花费<code class="fe mn mo mp mq b">O(M * log(n))</code>时间。</li><li id="a7c8" class="mc md iq ka b kb ni kf nj kj nk kn nl kr nm kv mj mk ml mm bi translated">为了提高效率，<code class="fe mn mo mp mq b">std::map</code>插入函数接受一个可选的插入提示参数。插入提示基本上是一个迭代器，它指向将要插入的项的未来位置附近。如果提示是正确的，那么我们得到摊销的<code class="fe mn mo mp mq b">O(1)</code>插入时间。</li><li id="7906" class="mc md iq ka b kb ni kf nj kj nk kn nl kr nm kv mj mk ml mm bi translated">从性能的角度来看，当项目的插入顺序在某种程度上是可预测的时，这是非常有用的。例如:</li></ul><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="aa14" class="mz lf iq mq b gy na nb l nc nd">int main() {<br/>    map&lt;uint32_t, string&gt; m{{2, ""}, {3, ""}};<br/>    auto where(end(m));</span><span id="1600" class="mz lf iq mq b gy nn nb l nc nd">    for (const auto &amp;n : {8, 7, 6, 5, 4, 3, 2, 1}) { // Items in non-incremental order<br/>        where = m.insert(where, {n, ""});<br/>    }</span><span id="8792" class="mz lf iq mq b gy nn nb l nc nd">    // How it is not done!<br/>    // m.insert(end(m), {0, ""});</span><span id="0b8f" class="mz lf iq mq b gy nn nb l nc nd">    for (const auto &amp;[key, value] : m) {<br/>        cout &lt;&lt; key &lt;&lt; " : " &lt;&lt; value &lt;&lt; endl;<br/>    }</span><span id="98d5" class="mz lf iq mq b gy nn nb l nc nd">    return EXIT_SUCCESS;<br/>}</span></pre><ul class=""><li id="a383" class="mc md iq ka b kb kc kf kg kj ne kn nf kr ng kv mj mk ml mm bi translated">一个<strong class="ka ir"> <em class="la">正确的提示将指向一个现有的元素，该元素大于要插入的元素</em> </strong>，这样新插入的键将正好在提示之前。如果这不适用于用户在插入过程中提供的提示，插入函数将退回到非优化插入，再次产生<code class="fe mn mo mp mq b">O(log(n))</code>性能。</li><li id="75f1" class="mc md iq ka b kb ni kf nj kj nk kn nl kr nm kv mj mk ml mm bi translated">对于上面的例子，第一次插入，我们得到了 map 的结束迭代器，因为我们没有更好的提示来开始。在树中安装了 8 之后，我们知道安装 7 会在 8 的前面插入一个新的条目，这证明它是一个正确的提示。这也适用于 6，如果在插入 7 之后放入树中，依此类推。这就是为什么可以使用迭代器的原因，迭代器在上一次插入中被返回用于下一次插入。</li><li id="5dd9" class="mc md iq ka b kb ni kf nj kj nk kn nl kr nm kv mj mk ml mm bi translated">您可以利用上面的例子来证明使用<a class="ae kw" href="https://quick-bench.com/q/gF1CXbPkzjOzLxKfRG7X-Uv8lfw" rel="noopener ugc nofollow" target="_blank">快速基准</a>获得的性能提升。</li></ul><p id="b6c3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="la">*注:</em> *要知道在 C++11 之前，插入提示在指向新插入的项的位置之前时被认为是正确的。</p><h1 id="72a3" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated"><a class="ae kw" href="https://en.cppreference.com/w/cpp/container/map/merge" rel="noopener ugc nofollow" target="_blank"> std::map::merge </a> (C++17)</h1><ul class=""><li id="e76d" class="mc md iq ka b kb me kf mf kj mg kn mh kr mi kv mj mk ml mm bi translated">同<a class="ae kw" href="https://en.cppreference.com/w/cpp/container/list/splice" rel="noopener ugc nofollow" target="_blank"> std::list:splice </a>，将元素从一个列表转移到另一个列表。我们有<code class="fe mn mo mp mq b">std::map::merge</code>，可以合并两个同类型的<code class="fe mn mo mp mq b">std::map</code>。</li></ul><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="398b" class="mz lf iq mq b gy na nb l nc nd">int main() {<br/>    map&lt;uint32_t, string&gt; fruits{{5, "grapes"}, {2, "tomoto"}};<br/>    map&lt;uint32_t, string&gt; person{{2, "mickel"}, {10, "shree"}};<br/>    map&lt;uint32_t, string&gt; fruits_and_persons;</span><span id="6243" class="mz lf iq mq b gy nn nb l nc nd">    fruits_and_persons.merge(fruits);<br/>    assert(fruits.size() == 0);</span><span id="e34c" class="mz lf iq mq b gy nn nb l nc nd">    fruits_and_persons.merge(person);<br/>    assert(person.size() == 1);<br/>    assert(person.at(2) == "mickel"); // Won't overwrite value at 2 i.e.`mickel`</span><span id="de13" class="mz lf iq mq b gy nn nb l nc nd">    assert((fruits_and_persons == decltype(fruits){<br/>                                      {2, "tomoto"},<br/>                                      {5, "grapes"},<br/>                                      {10, "shree"},<br/>                                  }));</span><span id="c355" class="mz lf iq mq b gy nn nb l nc nd">    return EXIT_SUCCESS;<br/>}</span></pre><ul class=""><li id="367a" class="mc md iq ka b kb kc kf kg kj ne kn nf kr ng kv mj mk ml mm bi translated">这里要注意的是当有重复时会发生什么！<strong class="ka ir"> <em class="la">复制的元素不会被转移。他们在右手边的地图</em> </strong>中落在了后面。</li></ul><h1 id="0adf" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated"><a class="ae kw" href="https://en.cppreference.com/w/cpp/container/map/extract" rel="noopener ugc nofollow" target="_blank">STD::map::extract</a>(c++ 17</h1><ul class=""><li id="9497" class="mc md iq ka b kb me kf mf kj mg kn mh kr mi kv mj mk ml mm bi translated">与<code class="fe mn mo mp mq b">std::map::merge</code>批量传输元素不同，<code class="fe mn mo mp mq b"><strong class="ka ir"><em class="la">std::map::extract</em></strong></code> <strong class="ka ir"> <em class="la">连同</em> </strong> <code class="fe mn mo mp mq b"><strong class="ka ir"><em class="la">std::map::insert</em></strong></code> <strong class="ka ir"> <em class="la">分段传输元素</em> </strong>。但是<code class="fe mn mo mp mq b">std::map::extract</code>更引人注目的应用是修改按键。</li><li id="91e0" class="mc md iq ka b kb ni kf nj kj nk kn nl kr nm kv mj mk ml mm bi translated">正如我们所知，for <code class="fe mn mo mp mq b">std::map</code>键总是唯一的，并且是有序的。因此，用户不能修改已经插入的地图节点的键是至关重要的。为了防止用户修改完全排序的地图节点的键项，在键类型中添加了<a class="ae kw" href="http://www.vishalchovatiya.com/when-to-use-const-vs-constexpr-in-cpp/" rel="noopener ugc nofollow" target="_blank"> const </a>限定符。</li><li id="3635" class="mc md iq ka b kb ni kf nj kj nk kn nl kr nm kv mj mk ml mm bi translated">这种限制是完全有效的，因为它使得用户更难以错误的方式使用<code class="fe mn mo mp mq b">std::map</code>。但是如果我们真的需要改变一些地图项目的键呢？</li><li id="4870" class="mc md iq ka b kb ni kf nj kj nk kn nl kr nm kv mj mk ml mm bi translated">在 C++17 之前，为了更改密钥，我们必须移除并重新插入项目。这种方法的缺点是内存分配和释放，从性能的角度来看，这听起来很糟糕。但是，从 C++17 开始，我们可以删除&amp;重新插入 std::map 节点，而无需重新分配内存。</li></ul><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="4bee" class="mz lf iq mq b gy na nb l nc nd">int main() {<br/>    map&lt;int, string&gt; race_scoreboard{{1, "Mickel"}, {2, "Shree"}, {3, "Jenti"}};<br/>    using Pair = map&lt;int, string&gt;::value_type;</span><span id="3ed2" class="mz lf iq mq b gy nn nb l nc nd">    {<br/>        auto Jenti(race_scoreboard.extract(3));<br/>        auto Mickel(race_scoreboard.extract(1));</span><span id="5664" class="mz lf iq mq b gy nn nb l nc nd">        swap(Jenti.key(), Mickel.key());</span><span id="22aa" class="mz lf iq mq b gy nn nb l nc nd">        auto [it, is_inserted, nh] = race_scoreboard.insert(move(Jenti)); // nh = node handle<br/>        assert(*it == Pair(1, "Jenti") &amp;&amp; is_inserted == true &amp;&amp; nh.empty());</span><span id="c39c" class="mz lf iq mq b gy nn nb l nc nd">        race_scoreboard.insert(move(Mickel));<br/>    }</span><span id="20e9" class="mz lf iq mq b gy nn nb l nc nd">    assert((race_scoreboard == decltype(race_scoreboard){<br/>                                   {1, "Jenti"},<br/>                                   {2, "Shree"},<br/>                                   {3, "Mickel"},<br/>                               }));</span><span id="0b15" class="mz lf iq mq b gy nn nb l nc nd">    return EXIT_SUCCESS;<br/>}</span></pre><ul class=""><li id="b5c7" class="mc md iq ka b kb kc kf kg kj ne kn nf kr ng kv mj mk ml mm bi translated">考虑上面的赛车记分牌的例子，你用<code class="fe mn mo mp mq b">std::map</code>来模仿赛车的位置。过了一会儿，Jenti 领先了，Mickel 落后了。在这种情况下，我们如何切换这些球员的关键(在赛道上的位置)。</li><li id="e960" class="mc md iq ka b kb ni kf nj kj nk kn nl kr nm kv mj mk ml mm bi translated"><code class="fe mn mo mp mq b">std::map::extract</code>有两种口味:</li></ul><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="e598" class="mz lf iq mq b gy na nb l nc nd">node_type extract(const_iterator position);<br/>node_type extract(const key_type&amp; x);</span></pre><ul class=""><li id="e90d" class="mc md iq ka b kb kc kf kg kj ne kn nf kr ng kv mj mk ml mm bi translated">在上面的例子中，我们使用了第二个方法，它接受一个键，然后查找并提取与键参数匹配的 map 节点。第一个接受迭代器，这意味着它更快，因为它不需要搜索条目。</li></ul><h1 id="f974" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">如果具有特定键的节点不存在怎么办？</h1><ul class=""><li id="ab8d" class="mc md iq ka b kb me kf mf kj mg kn mh kr mi kv mj mk ml mm bi translated">如果我们试图用第二种方法提取一个不存在的项目(使用键搜索的方法)，它<strong class="ka ir"> <em class="la">返回一个空的</em> </strong> <code class="fe mn mo mp mq b"><strong class="ka ir"><em class="la">node_type</em></strong></code> <strong class="ka ir"> <em class="la">实例，即节点句柄</em> </strong>。<code class="fe mn mo mp mq b">empty()</code>成员方法或重载的 bool 操作符告诉我们一个<code class="fe mn mo mp mq b">node_type</code>实例是否为空。</li></ul><h1 id="c117" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">好吧！那我怎么修改 std::map 键？</h1><ul class=""><li id="8521" class="mc md iq ka b kb me kf mf kj mg kn mh kr mi kv mj mk ml mm bi translated">提取节点后，我们能够使用  <code class="fe mn mo mp mq b"><strong class="ka ir"><em class="la">key()</em></strong></code> <strong class="ka ir"> <em class="la">方法</em> </strong>修改它们的键<strong class="ka ir"> <em class="la">，这给了我们对键的非常数访问，尽管键通常是常量<a class="ae kw" href="http://www.vishalchovatiya.com/when-to-use-const-vs-constexpr-in-cpp/" rel="noopener ugc nofollow" target="_blank"/>。</em></strong></li><li id="0149" class="mc md iq ka b kb ni kf nj kj nk kn nl kr nm kv mj mk ml mm bi translated">注意，为了再次将节点重新插入到地图中，我们必须将它们移动到 insert 函数中。这是有意义的，因为摘录完全是为了避免不必要的复制和分配。此外，当我们移动一个<code class="fe mn mo mp mq b">node_type</code>实例时，这不会导致任何容器值的实际移动。</li></ul><h1 id="6296" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">我还可以修改 std::map 中的关联值吗？</h1><ul class=""><li id="c240" class="mc md iq ka b kb me kf mf kj mg kn mh kr mi kv mj mk ml mm bi translated">是啊！您可以<strong class="ka ir"> <em class="la">使用访问器方法</em> </strong> <code class="fe mn mo mp mq b"><strong class="ka ir"><em class="la">nh.mapped()</em></strong></code>(而不是<code class="fe mn mo mp mq b">nh.key()</code>)来操作<code class="fe mn mo mp mq b">std::map</code>中的条目片段(或<code class="fe mn mo mp mq b">std::set</code>元素中的单个数据片段的<code class="fe mn mo mp mq b">nh.value()</code>)。因此，您可以提取、操作和重新插入密钥，而无需复制或移动其实际数据。</li></ul><h1 id="8801" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">但是安全呢？</h1><ul class=""><li id="934b" class="mc md iq ka b kb me kf mf kj mg kn mh kr mi kv mj mk ml mm bi translated">如果您从地图中提取一个节点，然后在将它重新插入目标地图之前抛出一个<a class="ae kw" href="http://www.vishalchovatiya.com/7-best-practices-for-exception-handling-in-cpp-with-example/" rel="noopener ugc nofollow" target="_blank">异常</a>。</li><li id="8748" class="mc md iq ka b kb ni kf nj kj nk kn nl kr nm kv mj mk ml mm bi translated">调用节点句柄的析构函数，它将正确地清理与节点相关的内存。所以，技术上来说<code class="fe mn mo mp mq b"><strong class="ka ir"><em class="la">std::map::extract</em></strong></code> <strong class="ka ir"> <em class="la">默认情况下(没有插入)会充当</em></strong><a class="ae kw" href="https://en.cppreference.com/w/cpp/container/map/erase" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir"><em class="la">STD::map::erase</em></strong></a>！</li></ul><h1 id="0af9" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">还有呢！互用性</h1><ul class=""><li id="90f1" class="mc md iq ka b kb me kf mf kj mg kn mh kr mi kv mj mk ml mm bi translated">使用<code class="fe mn mo mp mq b">std::map::extract</code>提取的地图节点实际上非常通用。<strong class="ka ir"> <em class="la">我们可以从一个地图实例中提取节点，并将其插入到任何其他地图甚至 multimap 实例中</em> </strong>。</li><li id="8719" class="mc md iq ka b kb ni kf nj kj nk kn nl kr nm kv mj mk ml mm bi translated">在<a class="ae kw" href="https://en.cppreference.com/w/cpp/container/unordered_map" rel="noopener ugc nofollow" target="_blank"> unordered_map </a>和<a class="ae kw" href="https://en.cppreference.com/w/cpp/container/unordered_multimap" rel="noopener ugc nofollow" target="_blank"> unordered_multimap </a>实例之间，以及与<a class="ae kw" href="https://en.cppreference.com/w/cpp/container/set" rel="noopener ugc nofollow" target="_blank"> set </a> / <a class="ae kw" href="https://en.cppreference.com/w/cpp/container/multiset" rel="noopener ugc nofollow" target="_blank"> multiset </a>和各自的<a class="ae kw" href="https://en.cppreference.com/w/cpp/container/unordered_set" rel="noopener ugc nofollow" target="_blank">unordered _ set</a>/<a class="ae kw" href="https://en.cppreference.com/w/cpp/container/unordered_multiset" rel="noopener ugc nofollow" target="_blank">unordered _ multiset</a>之间，它也可以工作。</li><li id="d8e2" class="mc md iq ka b kb ni kf nj kj nk kn nl kr nm kv mj mk ml mm bi translated">为了在不同的映射/集合结构之间移动项目，键、值和分配器的类型需要相同。</li></ul><h1 id="4ca9" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">运算符[ ]与 insert()和 at()之间的差异</h1><p id="a2b9" class="pw-post-body-paragraph jy jz iq ka b kb me kd ke kf mf kh ki kj no kl km kn np kp kq kr nq kt ku kv ij bi translated">这对于有经验的开发人员来说是微不足道的，但我仍然想快速浏览一遍。</p><h1 id="39c7" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated"><a class="ae kw" href="https://en.cppreference.com/w/cpp/container/map/operator_at" rel="noopener ugc nofollow" target="_blank"> std::map::operator[ ] </a></h1><ul class=""><li id="a4dc" class="mc md iq ka b kb me kf mf kj mg kn mh kr mi kv mj mk ml mm bi translated"><strong class="ka ir">操作</strong>:查找或添加；尝试在 map 中查找具有给定键的元素，如果存在，它将返回对存储值的引用。如果没有，它将使用默认初始化创建一个插入的新元素，并返回对它的引用。</li><li id="3759" class="mc md iq ka b kb ni kf nj kj nk kn nl kr nm kv mj mk ml mm bi translated"><strong class="ka ir">适用性</strong>:</li><li id="0e29" class="mc md iq ka b kb ni kf nj kj nk kn nl kr nm kv mj mk ml mm bi translated">对<code class="fe mn mo mp mq b">const std::map</code>不可用，因为它会创建一个不存在的元素。</li><li id="171a" class="mc md iq ka b kb ni kf nj kj nk kn nl kr nm kv mj mk ml mm bi translated">不适用于没有默认可构造和可赋值的值类型(通俗地说，没有默认构造函数&amp;复制/移动构造函数)。</li><li id="3d0e" class="mc md iq ka b kb ni kf nj kj nk kn nl kr nm kv mj mk ml mm bi translated"><strong class="ka ir">当密钥存在时</strong>:覆盖它。</li></ul><h1 id="407d" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated"><a class="ae kw" href="https://en.cppreference.com/w/cpp/container/map/insert" rel="noopener ugc nofollow" target="_blank"> std::map::insert </a></h1><ul class=""><li id="acc3" class="mc md iq ka b kb me kf mf kj mg kn mh kr mi kv mj mk ml mm bi translated"><strong class="ka ir">操作</strong>:insert-or-nop；接受 value_type ( <code class="fe mn mo mp mq b">std::pair</code>)并使用键(第一个成员)和来插入它。由于<code class="fe mn mo mp mq b">std::map</code>不允许重复，如果有一个现有的元素，它不会插入任何东西。</li><li id="9a59" class="mc md iq ka b kb ni kf nj kj nk kn nl kr nm kv mj mk ml mm bi translated"><strong class="ka ir">适用性</strong>:</li><li id="03a7" class="mc md iq ka b kb ni kf nj kj nk kn nl kr nm kv mj mk ml mm bi translated">调用中的自由插入需要在外部创建 value_type 并将该对象复制到容器中的不同方式。</li><li id="439a" class="mc md iq ka b kb ni kf nj kj nk kn nl kr nm kv mj mk ml mm bi translated">当项目插入顺序在某种程度上可预测以获得性能时，非常适用。</li><li id="b849" class="mc md iq ka b kb ni kf nj kj nk kn nl kr nm kv mj mk ml mm bi translated"><strong class="ka ir">当键存在时</strong>:不修改映射的状态，而是返回一个迭代器到阻止插入的元素。</li></ul><h1 id="9cfc" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated"><a class="ae kw" href="https://en.cppreference.com/w/cpp/container/map/at" rel="noopener ugc nofollow" target="_blank"> std::map::at </a></h1><ul class=""><li id="9abf" class="mc md iq ka b kb me kf mf kj mg kn mh kr mi kv mj mk ml mm bi translated"><strong class="ka ir">操作</strong>:找或扔；返回对键与输入键等效的元素的映射值的引用。如果不存在这样的元素，则抛出类型为<a class="ae kw" href="https://en.cppreference.com/w/cpp/error/out_of_range" rel="noopener ugc nofollow" target="_blank"> std::out_of_range </a>的<a class="ae kw" href="http://www.vishalchovatiya.com/7-best-practices-for-exception-handling-in-cpp-with-example/" rel="noopener ugc nofollow" target="_blank">异常</a>。</li><li id="efe4" class="mc md iq ka b kb ni kf nj kj nk kn nl kr nm kv mj mk ml mm bi translated"><strong class="ka ir">适用性</strong>:</li><li id="44d3" class="mc md iq ka b kb ni kf nj kj nk kn nl kr nm kv mj mk ml mm bi translated">当访问常量映射和元素缺失是逻辑错误时，不推荐使用<code class="fe mn mo mp mq b">at()</code>。</li><li id="9f5a" class="mc md iq ka b kb ni kf nj kj nk kn nl kr nm kv mj mk ml mm bi translated">是的，当你不确定元素是否存在时，最好使用<code class="fe mn mo mp mq b">std::map::find()</code>。因为，抛出并捕捉<a class="ae kw" href="https://en.cppreference.com/w/cpp/error/logic_error" rel="noopener ugc nofollow" target="_blank"> std::logic_error </a>异常不会是一种非常优雅的编程方式，即使我们不考虑性能。</li><li id="18b3" class="mc md iq ka b kb ni kf nj kj nk kn nl kr nm kv mj mk ml mm bi translated"><strong class="ka ir">当 key 存在时</strong>:返回映射值的引用。</li></ul><h1 id="642f" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">离别赠言</h1><p id="e104" class="pw-post-body-paragraph jy jz iq ka b kb me kd ke kf mf kh ki kj no kl km kn np kp kq kr nq kt ku kv ij bi translated">如果您看到了上面这篇文章的目录，就会发现超过一半的成员函数都是关于将元素插入到地图中的。对于新手来说，这是焦虑的原因(或者标准委员会会说现代)。但是如果你考虑到语言的新特性和复杂性，这些都是合理的。顺便说一句，这种现代感并没有到此为止，我们确实有其他的专门化也可以用于 map，比如<a class="ae kw" href="https://en.cppreference.com/w/cpp/container/map/swap2" rel="noopener ugc nofollow" target="_blank">STD::swap</a>(c++ 17)<a class="ae kw" href="https://en.cppreference.com/w/cpp/container/map/erase_if" rel="noopener ugc nofollow" target="_blank">STD::erase _ if</a>(c++ 20)&amp;一堆比较运算符。</p></div></div>    
</body>
</html>