# PHP 中松散耦合的微服务

> 原文：<https://blog.devgenius.io/loosely-coupled-microservices-in-php-130699e80344?source=collection_archive---------0----------------------->

![](img/ed7f1372c4eaf839454be888bb6bc465.png)

在本文中，我们将深入探讨在 PHP 中集成*微服务*并保持它们松散耦合的主题。
我们将关注通过`messaging`的集成，因为通过 [HTTP 集成微服务有很多缺点](/how-to-integrate-microservices-a506fe2d1a48)，需要单独的文章来解决。

除了如何实现的细节和理论，我们将学习如何在 PHP 中用[生态区框架](https://github.com/ecotoneframework/ecotone)实现它(与`Symfony`和`Laravel`一起工作)。

# 共享邮件类别

因此，PHP 中最常用的解决方案之一是在单独的包中共享类，或者只是在每个服务中复制它们。
这暗示了我们正在处理什么，并有助于反序列化。

然而，我们分享的课程越多，我们需要做的改变就越多。
然后是螺旋式下降，在这种情况下，当我们进行更改时，不是发布单个服务，而是发布几个服务，因为我们需要保持它们同步。

# 路由消息，而不是类

按类路由消息的工作原理是将类名保存在消息头中。这个头文件稍后会用到，以便知道我们应该反序列化到哪个类。

当我们期望其他服务理解我们的类时，就会产生这样的情况，即其他服务需要有一个名称完全相同的类。
我们很容易想象这样一种情况，我们忘记更改其中一个服务的名称，或者延迟发布另一个服务，这会产生`failure due to mismatch in class names`。

> 实际上，如果我们在单一服务中处理消息，仍然会产生问题。
> 如果消息在队列中，我们将`change class name or namespace`，将无法反序列化它。

那么，消息应该如何路由呢？
在大多数情况下，我们已经使用了该解决方案，但是我们没有将其提升到应用程序级别，该解决方案是`routing keys`。

> 路由关键字可以被视为事件和命令的应用程序级名称。
> 它们在服务之间创建契约和共享命名，因此我们可以理解消息背后的意图。

当消息由路由关键字路由时，我们可以将给定的路由关键字映射到类名。
结果，一个服务中的重构类名不需要在另一个服务中进行更改。

> 有了生态交错区，你实际上不需要构建任何类型的`routing-key -> class-name`地图。
> 消息被路由到基于`routing key`的给定处理器，然后消息的`payload`被反序列化`based on first method parameter`。

# 明确你的公共 API

每当给定的事件或命令向其他服务公开时，它就成为公共 API 的一部分。
如果你向外界发布每一个事件，当你想改变它的时候就成了一个问题，因为不容易清楚它是否会影响外部服务。

> 服务之间的契约是应用层的一部分，它们应该是显式的，而不是隐藏在 Message Broker 实现中。

生态区为发布消息的服务提供*分布式总线*。
这样，如果事件要被其他服务消费，而我们需要成为`aware, if we want to change it`，我们就可以成为`explicit on the application level`。

在消费者方面，我们明确表示我们订阅的消息来自外部服务。

如果我们不将`Distributed`添加到`Event Handler`中，此事件将被视为本地(私人)事件。
同样适用于`Distributed Command Handler`，如果没有明确的`distributed`，没有一个服务能够执行我们的`Command Handler`。

这对新加入者和项目的长期来说都很清楚，哪些处理程序由`external services`执行，哪些由`local ones`执行。

> 为了推进这一点，您可以使用[契约](https://docs.pact.io/)添加消费者驱动的契约。这将允许你知道你的消息中的哪些字段被其他服务使用，因此你可以容易地修改那些没有被使用的字段。

# 公共和私人活动

甚至，如果我们明确地发布分布式事件并限制它们的数量，我们仍然可能被其他服务阻止进行内部更改。如果我们将修改`payload`或者我们将想要放弃或替换该事件，那么我们可能最终会影响其他方。

这就是区分`public`和`private`事件的原因。通过使用`DistributedBus`,我们已经向前迈进了一步，明确了我们要向外部发送什么事件，然而这样做还有一个好处。

> 在发布事件之前，我们现在可以将其转换为不同的事件。这个事件将成为我们的公共 API，另一个将在发布服务中保持私有。

这给了我们很多动力。只要我们能够交付这个`public event`，我们就可以以我们想要的方式修改我们的内部服务，而不会影响其他方。

> 我们可以用额外的细节来丰富公共事件，所以`need for consumption of other events or calling our HTTP Api will decrease`。

# 知道你送什么

`Command`和`Events`都是`Messages`，但是它们在语义上是有区别的。

*命令* `targets specific handler`，这意味着只有一个端点处理这个消息。
*事件*则相反，不针对任何东西。它已经出版了，感兴趣的团体可以。这意味着可能有 20 个用户，但也可能没有。

那么在分布式环境下如何处理这个呢？
当我们`send`命令的时候，我们应该针对特定的服务和这个服务中给定的处理程序。这标识了目标服务，并确保没有其他服务将处理该命令。

> 服务名，就像路由键一样，是应用层的一部分。我们需要知道，我们在和谁交流，为什么交流。

第一个参数是目标服务名，命令将去往何处，第二个参数是处理程序的路由键。

> 如果目标服务中有`no given handler`或`Handler`不是`distributed`，消息将失败，并可能根据配置到达`DLQ`。

在事件的情况下，每个服务也明确地声明它想要订阅什么事件。

> 只订阅和接收给定服务感兴趣的事件，有助于保持消息流的性能。

# 消息负载可以是任何东西

PHP 中当前的框架已经建立了`PHP Message implementation`等于`Class`或`payload`等于`Class`的心理模型。
消息传递原则从来不是这样，消息的有效载荷可以是任何东西，如`json/xml`、`array`、`class`，甚至是`int`或`simple text string`。

> 消息和消息的负载都不能是类。消息有可以反序列化到`Class`的有效载荷，但是同时我们应该能够反序列化到`array`或者甚至保持为`json`，如果我们希望这样处理的话。

如果你只需要意图呢？例如，知道发票已生成，向客户发送 sms 就足够了。你根本不需要知道细节。以这种方式查看消息会创建更加松散耦合的接口。

让我们以发布事件`Order Was Placed`为例。

我们可能真的不想创建类，因为我们唯一需要它来检索`userId`发送的电子邮件。
其他场景可能是，我们只想将消息有效负载直接存储在`json`中，以便以后进行审计。

> 在 Ecotone 中，无论消息的内容类型是什么(xml、json、avro、protobuf 等),只要你已经为它注册了转换器，你就可以将它反序列化为类。

一般来说，如果需要，我们甚至可以使用空方法声明。

> 这就把权力还给开发者了。当我们觉得有必要时，我们创建类，而不是因为我们需要。

# 元数据的东西

如果我们想提供细节，比如谁是给定操作的执行者，或者发生的时间地点，或者一些基础设施信息，比如给定的订单是从哪个域发出的？

这可能会在加浓`public event`的步骤中添加到`payload`中。然而，这可能会模糊事件的图像，而且一般来说可能与它根本没有关系。

假设我们有多个客户下订单的站点，我们想用下订单的域来丰富事件的元数据。

> 生态区提供了一种简单的方法来处理元数据，它会通过消息代理来传递它，并允许你在另一端使用它。

# 摘要

随着时间的推移和项目的成熟，我们需要更可靠和长期的集成解决方案。那些解决方案在其他被认为更成熟的语言中使用过，现在`Ecotone`将它们引入 PHP，所以我们都可以从中受益并建立在坚实的基础上。

松散耦合是一种艺术。它通过将隐藏的东西显化来揭示它们。以前看起来很难的事情，变得很顺利，做起来感觉很好。
这是我们的目标，给我们良好的体验和共同的理解，因此我们可以面带微笑地改变服务。

如果你想就`Ecotone`或`Messaging`提出问题或进行一般性讨论，请加入[生态脆弱区的社区频道](https://discord.gg/CctGMcrYnV)。让我们一起围绕 PHP 中的消息传递建立社区，并进一步推动我们的语言:)