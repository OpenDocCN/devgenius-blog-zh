<html>
<head>
<title>Golang: Implementing the Official MongoDB Driver</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Golang:实现官方的 MongoDB 驱动程序</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/golang-implementing-the-official-mongodb-driver-93f3c658171a?source=collection_archive---------2-----------------------#2021-08-25">https://blog.devgenius.io/golang-implementing-the-official-mongodb-driver-93f3c658171a?source=collection_archive---------2-----------------------#2021-08-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="fc7a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本文中，我将指导您如何通过代码片段和函数实现官方的 mongo 驱动程序，这些代码片段和函数帮助我以更快、更简单的方式交付服务。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/fddc8493a5a82c7b395dbeae9266ba1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ax7-XeL-Gg9GvcdvE_lbEA.png"/></div></div></figure></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="9ee8" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated"><strong class="ak">先决条件</strong></h1><p id="9417" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">本文既不关注 GoLang 的基础知识，也不关注如何设置 MongoDB 实例，建议您具备该语言的基本-中等水平，并运行一个 MongoDB 数据库。</p><ul class=""><li id="f47f" class="mh mi iq jp b jq jr ju jv jy mj kc mk kg ml kk mm mn mo mp bi translated">GoLang 版本 1.16.6(带 go 模块)</li><li id="207d" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated">MongoDB golang 驱动版本 1 . 7 . 1(<a class="ae mv" href="https://github.com/mongodb/mongo-go-driver" rel="noopener ugc nofollow" target="_blank">https://github.com/mongodb/mongo-go-driver</a>)</li></ul><h1 id="be53" class="le lf iq bd lg lh mw lj lk ll mx ln lo lp my lr ls lt mz lv lw lx na lz ma mb bi translated"><strong class="ak">启动前</strong></h1><p id="e06e" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">作为在整个服务中可重用的功能/流程的经验法则，我创建了一个独立的包。我建议你也这样做，因为这将有助于保持你的代码不变，因为我们将为函数创建包装器。</p><p id="1acb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先要做的是获得我们最新版本的 mongo:</p><p id="1e5b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe nb nc nd ne b">go get go.mongodb.org/mongo-driver/mongo</code></p><h2 id="00ae" class="nf lf iq bd lg ng nh dn lk ni nj dp lo jy nk nl ls kc nm nn lw kg no np ma nq bi translated">创建我们的对象</h2><p id="a263" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">因为我们将创建我们的包装器函数来使用接口(更好的测试方法),所以我们需要 mongo 客户机的包装器对象和作为接口的基本函数。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="f484" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们设置函数的方式帮助我们变得灵活，有一个可重用的代码库，并且由于我们的接口，它可以被测试。如果 mongo 驱动程序中有任何变化(在更高版本或代码重构中)，我们的包装函数将促进这种转变，因为我们只需要编辑函数的内部。</p><h2 id="9a47" class="nf lf iq bd lg ng nh dn lk ni nj dp lo jy nk nl ls kc nm nn lw kg no np ma nq bi translated">客户端构造函数和助手</h2><p id="0c60" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">下面的代码片段展示了我们准备好并连接基本客户机所需的功能。你可以随意修改客户端选项，就个人而言，当使用只读 API 时，我们将读取首选项作为次要首选项。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="adaa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如何使用这个函数的一个例子是下面的代码片段，让我们的客户端随时可以使用。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="d29c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="nt">信息</em> </strong></p><p id="8026" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如您将在本文的其余部分看到的，我们的大多数函数都包含<code class="fe nb nc nd ne b">interface{}</code>作为我们接收文档或向数据库插入文档的方式。这很有帮助，因为该函数将接收一个<code class="fe nb nc nd ne b">bson.D</code>、<code class="fe nb nc nd ne b">map[string]interface</code>或带有 bson 标签的自定义结构，例如</p><pre class="km kn ko kp gt nu ne nv nw aw nx bi"><span id="3815" class="nf lf iq ne b gy ny nz l oa ob">type Example struct {</span><span id="0b82" class="nf lf iq ne b gy oc nz l oa ob">      Field string `bson:"field,omitempty"`</span><span id="c2cd" class="nf lf iq ne b gy oc nz l oa ob">}</span></pre><p id="e6ce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">解码功能将自动解析对应于标签名称的字段。我强烈建议为您的模型使用 structs，这样您就有一个包含一致字段的文档。</p><p id="9028" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在文章的最后，你会发现你的对象有一个很好的结构来创建<code class="fe nb nc nd ne b">bson.D.</code>中的查询</p><h2 id="46ae" class="nf lf iq bd lg ng nh dn lk ni nj dp lo jy nk nl ls kc nm nn lw kg no np ma nq bi translated">c 函数(创建)</h2><p id="362e" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">对于我们的 create 类型的函数，我们将把重点放在插入上。与插入多个和插入一个的唯一区别是我们传递插入文档的方式。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="6066" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">插页的选项并不像我们的发现和更新那样起着重要的作用，因此它们将不被包括在内。</p><p id="73d1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">插入函数的示例:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nr ns l"/></div></figure><h2 id="0ee3" class="nf lf iq bd lg ng nh dn lk ni nj dp lo jy nk nl ls kc nm nn lw kg no np ma nq bi translated">r 函数(读取)</h2><p id="aa89" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">我们的 read 函数包含两种类型，Find Many 和 Find One。我发现在开发我们的 API 时，Find 选项是最有用的。我将解释最重要的。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="eef4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">两者都很简单，区别在于我们作为输出传递的对象。这些是一些包含和解释了几个选项的示例。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nr ns l"/></div></figure><h2 id="3398" class="nf lf iq bd lg ng nh dn lk ni nj dp lo jy nk nl ls kc nm nn lw kg no np ma nq bi translated">u 函数(更新)</h2><p id="5d17" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">我们的下一组功能将是更新。基本的两个更新包装器:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="a119" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有一个选项很重要，那就是 Upsert 选项。这将导致创建一个新文档，以防没有要更新的现有文档。</p><h2 id="4285" class="nf lf iq bd lg ng nh dn lk ni nj dp lo jy nk nl ls kc nm nn lw kg no np ma nq bi translated">d 函数(删除)</h2><p id="36ff" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">我们的最后一组函数是针对删除类型的。与更新类似，它是来自驱动程序的删除函数的两个包装器。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nr ns l"/></div></figure><h1 id="b50d" class="le lf iq bd lg lh mw lj lk ll mx ln lo lp my lr ls lt mz lv lw lx na lz ma mb bi translated">构建您的 BSON 查询</h1><p id="a0d2" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">最重要的部分是创建您的选择器或查询，除了 insert 之外，所有的函数都使用它。正如我之前所说的，我为我的大多数模型使用结构来保持它的一致性和类型安全。然后我们将它们转换成一个<code class="fe nb nc nd ne b">map[string]interface{}</code>并通过我的自定义函数运行它。</p><p id="134e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这将说明您将在查询中使用的大多数类型，但是日期范围查询也是不同的，因为它必须使用关键字<code class="fe nb nc nd ne b">$gte</code>和<code class="fe nb nc nd ne b">$lte</code>，所以必须使用特殊类型的结构。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="b2b0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意，这个函数对数组和单个字段的<code class="fe nb nc nd ne b">$and</code>和<code class="fe nb nc nd ne b">$in</code>操作符有特定的用法。如果你觉得有必要，可以修改它。</p><p id="8700" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个包是开源的，您可以派生、修改或克隆它。github 的网址在文章的开头。</p><p id="0b12" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">谢谢你的时间，我希望你喜欢它。任何反馈都很感谢</p></div></div>    
</body>
</html>