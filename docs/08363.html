<html>
<head>
<title>The optimal way to include dates in JSON</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在 JSON 中包含日期的最佳方式</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/the-optimal-way-to-include-dates-in-json-2220c2a355a8?source=collection_archive---------1-----------------------#2022-06-09">https://blog.devgenius.io/the-optimal-way-to-include-dates-in-json-2220c2a355a8?source=collection_archive---------1-----------------------#2022-06-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="6b39" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">杰克逊和 GSON 哪个更快</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/4fd2cceb5e7c7122b62bc765059a9590.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LwW83hLcjz8er4c-3G6PyA.png"/></div></div></figure><p id="f2b6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">web 应用程序后端的主要目的是在数据库和客户端浏览器之间传递数据。为了将数据传递给浏览器，后端通常会将数据转换成 JSON 格式。JSON 格式没有特殊的日期类型。所以日期必须在 JSONs 中表示为毫秒数或字符串。如果日期被格式化为字符串，开发人员可以读取它们。另一方面，这可能是双重浪费时间。服务器端代码必须花时间格式化日期，JavaScript 代码可能需要解析接收到的字符串，以便在计算中使用它们。当然，如果序列化数据很小，只有几个日期，性能损失可以忽略不计。</p><p id="77c2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这篇文章中，我想找出创建带日期的 JSONs 的最佳方式。</p><h2 id="5baa" class="ln lo iq bd lp lq lr dn ls lt lu dp lv la lw lx ly le lz ma mb li mc md me mf bi translated">数据库驱动程序不使用现代的<strong class="ak">日期和时间 API </strong></h2><p id="d3cc" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">不管使用 JPA 或 Spring Data 这样的库，数据库驱动程序总是将数据库中的日期作为<code class="fe ml mm mn mo b">java.sql.Timestamp</code>或<code class="fe ml mm mn mo b">java.sql.Date</code>返回。在<code class="fe ml mm mn mo b">ResultSet</code>没有其他现代类型的吸气剂，比如<code class="fe ml mm mn mo b">LocalDateTime</code>。两种 JDBC 日期类型都是<code class="fe ml mm mn mo b">java.util.Date</code>的子类型。<code class="fe ml mm mn mo b">java.sql.Date</code>是一个<code class="fe ml mm mn mo b">java.util.Date</code>，由数据库驱动程序将小时、分钟和秒归零。</p><p id="4ef4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用<code class="fe ml mm mn mo b">rs.getDate()</code>或<code class="fe ml mm mn mo b">rs.getTimestamp()</code>可以检索相同的表列。实际上，使用<code class="fe ml mm mn mo b">java.sql.Date</code>没有任何意义。作为<code class="fe ml mm mn mo b">java.sql.Timestamp</code>加载的相同列值将具有<code class="fe ml mm mn mo b">java.sql.Date</code>的所有信息，并且不需要驱动程序花费时间来调整时间成分。所以为了简洁起见，我在这篇文章中忽略了<code class="fe ml mm mn mo b">java.util.Date</code>这个并不普遍有用的子类型。</p><h2 id="aa51" class="ln lo iq bd lp lq lr dn ls lt lu dp lv la lw lx ly le lz ma mb li mc md me mf bi translated">杰克逊和 GSON 的不同违约</h2><p id="71aa" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">要传输到浏览器，日期必须序列化为 JSON 字符串。使用将 Java 对象转换成 JSONs 的库来序列化数据通常更容易。最受欢迎的图书馆是杰克逊和 GSON。</p><p id="121e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">关于日期，它们的默认值是不同的。默认情况下，Jackson 将日期转换为毫秒，而 GSON 转换为字符串。例如，一个示例<code class="fe ml mm mn mo b">ObjectWithDates</code>类:</p><pre class="kg kh ki kj gt mp mo mq mr aw ms bi"><span id="deac" class="ln lo iq mo b gy mt mu l mv mw">public class ObjectWithDates {<br/>    Timestamp ts = new Timestamp(1654416749456L);<br/>}</span></pre><p id="5d60" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">被杰克逊转换成<code class="fe ml mm mn mo b">{"ts":1654416749456}</code>，被 GSON 转换成<code class="fe ml mm mn mo b">{"ts":"Jun 5, 2022, 10:12:29 AM"}</code>。</p><p id="e2cd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在 Jackson 中，可以用语句<code class="fe ml mm mn mo b">disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS)</code>禁用到数字的默认转换。然后 Jackson 将样本对象转换成<code class="fe ml mm mn mo b">{"ts":"2022–06–05T10:12:29.456+02:00"}</code>。因此，Jackson 和 GSON 中的默认日期格式不同，而且都太长了，没有用。为了比较两个库的性能，我认为最公平的方法是将两个库中的日期格式都改成同样的更简洁的格式。</p><p id="7ab1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">顺便说一下，在 GSON 中更改日期模式更容易。在 GSON 方法中<code class="fe ml mm mn mo b">setDateFormat(String pattern)</code>接受一个模式字符串。在 Jackson 中<code class="fe ml mm mn mo b">setDateFormat(DateFormat dateFormat)</code>需要一个<code class="fe ml mm mn mo b">DateFormat</code>的实例，通常是<code class="fe ml mm mn mo b">SimpleDateFormat</code>的实例。根据 Jackson 的文档，如果调用了<code class="fe ml mm mn mo b">setDateFormat()</code>，那么<code class="fe ml mm mn mo b">ObjectMapper</code>就不是线程安全的了。这意味着如果并发线程访问同一个<code class="fe ml mm mn mo b">ObjectMapper</code>实例，它会产生异常的日期。我使用这样配置的<code class="fe ml mm mn mo b">ObjectMapper</code>进行比较，但是在 web 应用程序中使用这样的<code class="fe ml mm mn mo b">ObjectMapper</code>是复杂的或者不是最佳的。</p><h2 id="d06f" class="ln lo iq bd lp lq lr dn ls lt lu dp lv la lw lx ly le lz ma mb li mc md me mf bi translated">杰克逊和 GSON 的表现</h2><p id="7eac" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">为了比较 Jackson 和 GSON 的性能，也为了证明将日期转换为字符串是一种相对较慢的日期序列化方式，我使用了 Jackson 和 GSON 的默认实例和几个定制实例。实例被分配给静态字段。这些字段的名称用作下表中基准测试结果的列名。</p><p id="71a9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">前三个实例将日期转换为毫秒。它们都将样本<code class="fe ml mm mn mo b">ObjectWithDates</code>转换成<code class="fe ml mm mn mo b">{"ts":1654416749456}</code>字符串。</p><p id="5e9b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">默认杰克逊</strong></p><pre class="kg kh ki kj gt mp mo mq mr aw ms bi"><span id="6a0c" class="ln lo iq mo b gy mt mu l mv mw">static ObjectMapper <strong class="mo ir">jackson</strong> = new ObjectMapper();</span></pre><p id="2ca1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> Jackson 使用自定义日期序列化程序返回 getTime() </strong></p><pre class="kg kh ki kj gt mp mo mq mr aw ms bi"><span id="357f" class="ln lo iq mo b gy mt mu l mv mw">static ObjectMapper <strong class="mo ir">jacksonCustMs</strong> = new ObjectMapper()<br/> .registerModule(new SimpleModule() {<br/>     {<br/>         addSerializer(<!-- -->Date.class<!-- -->, new JacksonDateToMsSerializer());<br/>     }<br/> });</span><span id="ca84" class="ln lo iq mo b gy mx mu l mv mw">class JacksonDateToMsSerializer extends StdSerializer&lt;Date&gt; {</span><span id="d23d" class="ln lo iq mo b gy mx mu l mv mw">public JacksonDateToMsSerializer() {<br/>        super(Date.class);<br/>    }</span><span id="3a46" class="ln lo iq mo b gy mx mu l mv mw">public void serialize(Date value, JsonGenerator gen, SerializerProvider provider) throws IOException {<br/>        if (value != null) {<br/>            gen.writeNumber(value.getTime());<br/>        } else {<br/>            gen.writeNull();<br/>        }<br/>    }<br/>}</span></pre><p id="1989" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">带有自定义日期序列化程序的 GSON 返回 getTime() </strong></p><pre class="kg kh ki kj gt mp mo mq mr aw ms bi"><span id="fc21" class="ln lo iq mo b gy mt mu l mv mw">static Gson <strong class="mo ir">gsonCustMs</strong> = new GsonBuilder()<br/> .registerTypeAdapter(Date.class, new DateSerializerToMs())<br/> .create();</span><span id="16e3" class="ln lo iq mo b gy mx mu l mv mw">class DateSerializerToMs implements JsonSerializer&lt;Date&gt; {</span><span id="2ebd" class="ln lo iq mo b gy mx mu l mv mw">public JsonElement serialize(<!-- -->Date date<!-- -->, Type typeOfSrc, JsonSerializationContext context) {<br/>        return date == null?null:new JsonPrimitive(<!-- -->date.getTime()<!-- -->);<br/>    }<br/>}</span></pre><p id="1f86" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">另外四个实例使用 format 将日期格式化为字符串</p><pre class="kg kh ki kj gt mp mo mq mr aw ms bi"><span id="8753" class="ln lo iq mo b gy mt mu l mv mw">static String DATE_PATTERN = "dd.MM.yyyy HH:mm:ss";</span></pre><p id="c555" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">所以样本<code class="fe ml mm mn mo b">ObjectWithDates</code>对象被它们中的任何一个转换成<code class="fe ml mm mn mo b">{"ts":"05.06.2022 10:12:29"}</code>。</p><p id="3ca7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">杰克森用 setDateFormat()调用</strong></p><pre class="kg kh ki kj gt mp mo mq mr aw ms bi"><span id="7378" class="ln lo iq mo b gy mt mu l mv mw">static ObjectMapper <strong class="mo ir">jacksonStr</strong> = new ObjectMapper()<br/> .setDateFormat(new SimpleDateFormat(DATE_PATTERN));</span></pre><p id="7c5d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> Jackson 用一个定制的日期序列化器使用 modern DateTimeFormatter 来格式化日期</strong></p><pre class="kg kh ki kj gt mp mo mq mr aw ms bi"><span id="f701" class="ln lo iq mo b gy mt mu l mv mw">static ObjectMapper <strong class="mo ir">jacksonCustStr</strong> = new ObjectMapper()<br/> .registerModule(new SimpleModule() {<br/>     {<br/>         addSerializer(Date.class, new JacksonDateToStringSerializer());<br/>     }<br/> });</span><span id="e3c0" class="ln lo iq mo b gy mx mu l mv mw">class JacksonDateToStringSerializer extends StdSerializer&lt;Date&gt; {</span><span id="9687" class="ln lo iq mo b gy mx mu l mv mw">static DateTimeFormatter format = DateTimeFormatter.ofPattern(DATE_PATTERN);</span><span id="96c6" class="ln lo iq mo b gy mx mu l mv mw">public JacksonDateToStringSerializer() {<br/>        super(Date.class);<br/>    }<br/> <br/>    public void serialize(Date value, JsonGenerator gen, SerializerProvider provider) throws IOException {<br/>        if (value != null) {<br/>            gen.writeString(LocalDateTime.ofInstant(value.toInstant(), ZoneId.systemDefault()).format(format));<br/>        } else {<br/>            gen.writeNull();<br/>        }<br/>    }<br/>}</span></pre><p id="df09" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">使用 setDateFormat()设置日期模式的 GSON</strong></p><pre class="kg kh ki kj gt mp mo mq mr aw ms bi"><span id="3c7e" class="ln lo iq mo b gy mt mu l mv mw">static Gson <strong class="mo ir">gsonStr</strong> = new GsonBuilder()<br/> .setDateFormat(DATE_PATTERN)<br/> .create();</span></pre><p id="a5b0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">带自定义日期序列化程序的 GSON，使用 DateTimeFormatter 将日期转换为字符串</strong></p><pre class="kg kh ki kj gt mp mo mq mr aw ms bi"><span id="bbfb" class="ln lo iq mo b gy mt mu l mv mw">static Gson <strong class="mo ir">gsonCustStr</strong> = new GsonBuilder()<br/> .registerTypeAdapter(Date.class, new DateSerializerToString())<br/> .create();</span><span id="3533" class="ln lo iq mo b gy mx mu l mv mw">class DateSerializerToString implements JsonSerializer&lt;Date&gt; {</span><span id="c277" class="ln lo iq mo b gy mx mu l mv mw">static DateTimeFormatter format = DateTimeFormatter.ofPattern(DATE_PATTERN);</span><span id="41aa" class="ln lo iq mo b gy mx mu l mv mw">public JsonElement serialize(Date value, Type typeOfSrc, JsonSerializationContext context) {</span><span id="4d5d" class="ln lo iq mo b gy mx mu l mv mw">return value == null?null:new JsonPrimitive(LocalDateTime.ofInstant(value.toInstant(), ZoneId.systemDefault()).format(format));<br/>    }<br/>}</span></pre><p id="ac23" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Java API 有两个内置的格式化程序——传统的<code class="fe ml mm mn mo b">SimpleDateFormat</code>和现代的<code class="fe ml mm mn mo b">DateTimeFormatter</code>。它们之间的区别对于 web 应用程序来说非常重要。Java 应用服务器是多线程的。当并发线程访问一个<code class="fe ml mm mn mo b">SimpleDateFormat</code>实例时，没有错误，但是返回的格式化日期与输入不匹配。所以<code class="fe ml mm mn mo b">SimpleDateFormat</code>实例应该被同步，为每个新的调用重新创建或者存储在一个线程本地字段中。相比之下，<code class="fe ml mm mn mo b">DateTimeFormatter</code>是线程安全的——多线程可以使用<code class="fe ml mm mn mo b">DateTimeFormatter</code>的一个实例。现代也应该更有表演性。</p><p id="ce6c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我测量了序列化包含 50000 行、每行包含 10 个日期的同一个 2D 数组所需的时间。每个测量重复 10 次。我没有计算平均值，因为差异是显而易见的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi my"><img src="../Images/a1a1a34e5d86e1495f9c49fa8883b696.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gbfUSIboW7pGXYBW"/></div></div></figure><p id="a2d4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在转换到毫秒类别的赢家是默认的未配置的杰克逊。</p><p id="026b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在字符串类别中，获胜者是 Jackson，它被配置为使用基于定制的<code class="fe ml mm mn mo b">DateTimeFormatter</code>的序列化程序。</p><p id="af76" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">测量结果表明:</p><ul class=""><li id="4ed9" class="mz na iq kt b ku kv kx ky la nb le nc li nd lm ne nf ng nh bi translated">格式化日期比仅仅使用以毫秒表示的同等信息需要多 10 倍的时间</li><li id="564d" class="mz na iq kt b ku ni kx nj la nk le nl li nm lm ne nf ng nh bi translated">GSON 比 Jackson 慢。我不知道为什么，但当 GSON 用于将日期序列化为毫秒时，这种差异就特别明显了。</li><li id="08bc" class="mz na iq kt b ku ni kx nj la nk le nl li nm lm ne nf ng nh bi translated">杰克逊和 GSON 使用的比现代的慢两倍</li></ul><p id="c78b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在生成上表的代码中，许多代码都用来打印一些东西。与测量相关的代码以粗体显示。</p><pre class="kg kh ki kj gt mp mo mq mr aw ms bi"><span id="39a8" class="ln lo iq mo b gy mt mu l mv mw">public class MeasureMappers {</span><span id="6b8f" class="ln lo iq mo b gy mx mu l mv mw">static String PAD = "%-15s";<br/>    <strong class="mo ir">static Date[][] array2d;</strong></span><span id="a05a" class="ln lo iq mo b gy mx mu l mv mw">public static void main(String[] args) throws JsonProcessingException, Exception {</span><span id="c8cf" class="ln lo iq mo b gy mx mu l mv mw"><strong class="mo ir">array2d = new Date[50_000][10];<br/>        Arrays.stream(array2d).forEach(row<br/>                -&gt; Arrays.setAll(row, i -&gt; new Timestamp(System.currentTimeMillis())));</strong></span><span id="bcab" class="ln lo iq mo b gy mx mu l mv mw"><strong class="mo ir">Map&lt;String, ThrowingFunction&gt; approaches = new LinkedHashMap&lt;&gt;() {<br/>            {<br/>                put("jackson", jackson::writeValueAsString );<br/>                put("jacksonCustMs", jacksonCustMs::writeValueAsString );<br/>                put("gsonCustMs", gsonCustMs::toJson );<br/>                put("jacksonStr",  jacksonStr::writeValueAsString );<br/>                put("jacksonCustStr",  jacksonCustStr::writeValueAsString );<br/>                put("gsonStr",  gsonStr::toJson );<br/>                put("gsonCustStr", gsonCustStr::toJson );<br/>                put("gsonCustStr", gsonCustStr::toJson );<br/>            }<br/>        };</strong></span><span id="f69a" class="ln lo iq mo b gy mx mu l mv mw">// make sure the mappers use the expected date format<br/>        ObjectWithDates obj = new ObjectWithDates();</span><span id="6ac9" class="ln lo iq mo b gy mx mu l mv mw">for (Entry&lt;String, ThrowingFunction&gt; e : approaches.entrySet()) {<br/>            System.out.println(String.format(PAD, e.getKey()) + " "<br/>                    + e.getValue().apply(obj));<br/>        }</span><span id="2d96" class="ln lo iq mo b gy mx mu l mv mw">// print headers <br/>        System.out.println();<br/>        System.out.println(approaches.keySet().stream()<br/>                .map(s -&gt; String.format(PAD, s)).collect(Collectors.joining("")));<br/>        <br/>        // print measurements repeated 10 times<br/><strong class="mo ir">        for (int repeat = 0; repeat &lt; 10; repeat++) {<br/>            for (ThrowingFunction f : approaches.values()) {<br/>                measure(f);<br/>            }<br/>            System.out.println();<br/>        }</strong><br/>    }</span><span id="aeea" class="ln lo iq mo b gy mx mu l mv mw"><strong class="mo ir">static void measure(ThrowingFunction f) throws Exception {<br/>        long s = System.currentTimeMillis();<br/>        f.apply(array2d);<br/>        System.out.format(PAD, (System.currentTimeMillis() - s));<br/>    }</strong><br/>}</span></pre><h1 id="3644" class="nn lo iq bd lp no np nq ls nr ns nt lv jw nu jx ly jz nv ka mb kc nw kd me nx bi translated">结论</h1><p id="f3d3" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">假设我们有一个在数据库和客户端浏览器之间传递数据的 web 应用程序。数据包含日期。</p><p id="10ad" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">不考虑 JSON 中的日期表示，Jackson 的表现优于 GSON。</p><p id="2c79" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">将日期序列化为字符串需要时间。即使性能不是问题，我认为浪费用户的时间也必须有一个合理的理由，即使是以毫秒来衡量。此外，为了以防万一，卸载后端更明智，这样它就不会在可以在客户端浏览器中执行的操作上花费时间。最糟糕的情况是服务器将日期转换成字符串，然后浏览器将它们转换回毫秒，这样日期就可以用于计算、过滤或排序。</p><p id="ca9d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果真的需要将日期序列化为易读的字符串，例如为了便于开发，最好使用 Jackson 和一个定制的序列化器类来处理<code class="fe ml mm mn mo b">Date</code>。如果 Jackson 被分配了一个<code class="fe ml mm mn mo b">SimpleDateFormat</code>的实例，那么代码必须稍微复杂一些，以避免对<code class="fe ml mm mn mo b">SimpleDateFormat</code>的并发访问。</p></div><div class="ab cl ny nz hu oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="ij ik il im in"><p id="f5d5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">代码可以从<a class="ae of" href="https://github.com/marianc000/datesInJson" rel="noopener ugc nofollow" target="_blank">https://github.com/marianc000/datesInJson</a>下载</p></div></div>    
</body>
</html>