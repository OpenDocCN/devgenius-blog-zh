<html>
<head>
<title>Develop locally containers for Kubernetes with K3s Rancher</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">与K3s Rancher一起为Kubernetes开发本地容器</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/develop-locally-containers-for-kubernetes-with-k3s-rancher-219d5d0ba34a?source=collection_archive---------4-----------------------#2021-12-23">https://blog.devgenius.io/develop-locally-containers-for-kubernetes-with-k3s-rancher-219d5d0ba34a?source=collection_archive---------4-----------------------#2021-12-23</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="fa6d" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">用牧场主取代码头工人，促进地方发展</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/eb294dc5384b21be85974ff2587aeb08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cB_tPBaOiNw_-w5h8Rqo-w.jpeg"/></div></div></figure><h1 id="7243" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">介绍</h1><p id="e636" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">在本地建立Kubernetes很困难，这使得很难在本地开发和快速试用。K3s Rancher 是K8s (Kubernetes)的轻量级版本，甚至可以在树莓Pi上运行。对于任何学习K8s部署的人来说，这也是一个很好的起点。</p><p id="23ac" class="pw-post-body-paragraph lg lh in li b lj md jo ll lm me jr lo lp mf lr ls lt mg lv lw lx mh lz ma mb ig bi translated">使用K3s的优点是:</p><ul class=""><li id="ea0e" class="mi mj in li b lj md lm me lp mk lt ml lx mm mb mn mo mp mq bi translated">在本地开发和测试(Docker)容器，而不会通过安装许多额外的包来污染本地机器。</li><li id="1d75" class="mi mj in li b lj mr lm ms lp mt lt mu lx mv mb mn mo mp mq bi translated">用类似Kubernetes的API在本地编排几个容器既快又容易</li><li id="f5bc" class="mi mj in li b lj mr lm ms lp mt lt mu lx mv mb mn mo mp mq bi translated">一旦您对本地部署感到满意，所有的YAML配置都可以部署到Kubernetes，而无需任何(重大)更改。</li><li id="2b89" class="mi mj in li b lj mr lm ms lp mt lt mu lx mv mb mn mo mp mq bi translated">没有什么比试图找出为什么容器A不与容器B对话或者为什么容器C拒绝启动更烦人的了。能够接触到当地的东西可以节省你很多时间。</li></ul><p id="1f16" class="pw-post-body-paragraph lg lh in li b lj md jo ll lm me jr lo lp mf lr ls lt mg lv lw lx mh lz ma mb ig bi translated">作为比较，以下是使用<a class="ae mc" href="https://minikube.sigs.k8s.io/docs/" rel="noopener ugc nofollow" target="_blank">Minikube</a>(2021年)的系统要求，它是Kubernetes的本地部署:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mw"><img src="../Images/2660f5e409d224bc130d6fed6b324617.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3j71uhcF9prMj5eIlypDWA.png"/></div></div></figure><p id="4096" class="pw-post-body-paragraph lg lh in li b lj md jo ll lm me jr lo lp mf lr ls lt mg lv lw lx mh lz ma mb ig bi translated"><em class="mx">它不是什么都没有，这是在你开始在它上面运行任何容器之前。</em></p><h1 id="8c6d" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">第1部分:在本地设置K3s</h1><p id="62c7" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated"><strong class="li io">！！本教程假设一个Linux开发环境！！</strong></p><p id="2b9d" class="pw-post-body-paragraph lg lh in li b lj md jo ll lm me jr lo lp mf lr ls lt mg lv lw lx mh lz ma mb ig bi translated">K3s的好处在于它是一个单独的二进制文件，<code class="fe my mz na nb b">k3s</code>，可以配置成将所有数据保存在一个文件夹中，如下所示:</p><pre class="kd ke kf kg gt nc nb nd ne aw nf bi"><span id="aa5a" class="ng kp in nb b gy nh ni l nj nk">sudo ./k3s-system/k3s server  \<br/>  --data-dir  ./k3s-system \<br/>  --config ./config.yaml \<br/>  --write-kubeconfig ./k3s.yaml</span></pre><p id="7181" class="pw-post-body-paragraph lg lh in li b lj md jo ll lm me jr lo lp mf lr ls lt mg lv lw lx mh lz ma mb ig bi translated">它所有的内部数据都在这个文件夹<code class="fe my mz na nb b">./k3-system</code>下。<code class="fe my mz na nb b">config.yaml</code>的配置文件可以简单到:</p><pre class="kd ke kf kg gt nc nb nd ne aw nf bi"><span id="9823" class="ng kp in nb b gy nh ni l nj nk">write-kubeconfig-mode: "0644"<br/>tls-san:<br/>  - "foo.local"<br/>node-label:<br/>  - "foo=bar"<br/>  - "something=amazing"</span></pre><p id="c60b" class="pw-post-body-paragraph lg lh in li b lj md jo ll lm me jr lo lp mf lr ls lt mg lv lw lx mh lz ma mb ig bi translated">启动K3s服务器会生成一个配置文件，<code class="fe my mz na nb b">k3s.yaml</code>:</p><pre class="kd ke kf kg gt nc nb nd ne aw nf bi"><span id="c7f0" class="ng kp in nb b gy nh ni l nj nk">apiVersion: v1<br/>clusters:<br/>- cluster:<br/>    certificate-authority-data: ...<br/>    server: <a class="ae mc" href="https://127.0.0.1:6443" rel="noopener ugc nofollow" target="_blank">https://127.0.0.1:6443</a><br/>  name: default<br/>contexts:<br/>- context:<br/>    cluster: default<br/>    user: default<br/>  name: default<br/>current-context: default<br/>kind: Config<br/>preferences: {}<br/>users:<br/>- name: default<br/>  user:<br/>    client-certificate-data: ...<br/>    client-key-data: ...</span></pre><p id="a219" class="pw-post-body-paragraph lg lh in li b lj md jo ll lm me jr lo lp mf lr ls lt mg lv lw lx mh lz ma mb ig bi translated">它可以与标准的Kubernetes CLI <code class="fe my mz na nb b">kubectl</code>一起使用。</p><h1 id="99fe" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">第2部分:PostgreSQL在K3s上本地运行的例子</h1><p id="0d86" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">能够在本地测试是一种享受。这样做也很好，不会让你的机器一直塞满垃圾。因此，将PostgreSQL作为可在本地主机上访问的容器运行是有意义的。<code class="fe my mz na nb b">docker-compose</code>可以这样做，但是配置文件是没有用的，除非你在生产中运行<a class="ae mc" href="https://docs.docker.com/engine/swarm/" rel="noopener ugc nofollow" target="_blank"> Docker Swarm </a>。在实践中，许多人使用Kubernetes进行容器编排。</p><p id="500b" class="pw-post-body-paragraph lg lh in li b lj md jo ll lm me jr lo lp mf lr ls lt mg lv lw lx mh lz ma mb ig bi translated">这是一个在K8s/K3s上部署PostgreSQL的简单图表</p><pre class="kd ke kf kg gt nc nb nd ne aw nf bi"><span id="704f" class="ng kp in nb b gy nh ni l nj nk">---<br/># Source: postgresql/templates/serviceaccount.yaml<br/>apiVersion: v1<br/>kind: ServiceAccount<br/>metadata:<br/>  name: k3s-env-postgresql<br/>  labels:<br/>    helm.sh/chart: postgresql-0.1.0<br/>    app.kubernetes.io/name: postgresql<br/>    app.kubernetes.io/instance: k3s-env<br/>    app.kubernetes.io/version: "14.1-bullseye"<br/>    app.kubernetes.io/managed-by: Helm<br/>---<br/># Source: postgresql/templates/service.yaml<br/>apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: k3s-env-postgresql<br/>  labels:<br/>    helm.sh/chart: postgresql-0.1.0<br/>    app.kubernetes.io/name: postgresql<br/>    app.kubernetes.io/instance: k3s-env<br/>    app.kubernetes.io/version: "14.1-bullseye"<br/>    app.kubernetes.io/managed-by: Helm<br/>spec:<br/>  type: NodePort<br/>  ports:<br/>    - port: 5432<br/>      nodePort: 30001<br/>      targetPort: http<br/>      protocol: TCP<br/>      name: http<br/>  selector:<br/>    app.kubernetes.io/name: postgresql<br/>    app.kubernetes.io/instance: k3s-env<br/>---<br/># Source: postgresql/templates/deployment.yaml<br/>apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: k3s-env-postgresql<br/>  labels:<br/>    helm.sh/chart: postgresql-0.1.0<br/>    app.kubernetes.io/name: postgresql<br/>    app.kubernetes.io/instance: k3s-env<br/>    app.kubernetes.io/version: "14.1-bullseye"<br/>    app.kubernetes.io/managed-by: Helm<br/>spec:<br/>  replicas: 1<br/>  selector:<br/>    matchLabels:<br/>      app.kubernetes.io/name: postgresql<br/>      app.kubernetes.io/instance: k3s-env<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app.kubernetes.io/name: postgresql<br/>        app.kubernetes.io/instance: k3s-env<br/>    spec:<br/>      serviceAccountName: k3s-env-postgresql<br/>      securityContext:<br/>        {}<br/>      containers:<br/>        - name: postgresql<br/>          securityContext:<br/>            {}<br/>          image: "postgres:14.1-bullseye"<br/>          imagePullPolicy: IfNotPresent<br/>          env:<br/>            - name: POSTGRES_PASSWORD<br/>              value: "password"<br/>          ports:<br/>            - name: http<br/>              containerPort: 5432<br/>              protocol: TCP</span></pre><p id="1256" class="pw-post-body-paragraph lg lh in li b lj md jo ll lm me jr lo lp mf lr ls lt mg lv lw lx mh lz ma mb ig bi translated">它包含PostgreSQL部署使用的服务帐户(很高兴拥有)。然后，它创建一个节点端口服务，允许访问<code class="fe my mz na nb b">localhost:30001</code>上的数据库，最后，它定义了一个PostgreSQL实例的基本部署，只有一个服务器(<code class="fe my mz na nb b">replicas: 1</code>)</p><p id="7450" class="pw-post-body-paragraph lg lh in li b lj md jo ll lm me jr lo lp mf lr ls lt mg lv lw lx mh lz ma mb ig bi translated">就是这样！可以使用用户名<code class="fe my mz na nb b">root</code>和密码<code class="fe my mz na nb b">password</code>在<code class="fe my mz na nb b">localhost:30001</code>上使用<a class="ae mc" href="https://www.pgadmin.org/download/" rel="noopener ugc nofollow" target="_blank"> pgAdmin III </a>或类似的东西来访问数据库。</p><h1 id="be23" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">摘要</h1><p id="76d4" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">PostgreSQL的例子很好，因为它展示了如何在本地进行设置，但它还可以更进一步。例如，DB可以与同样运行在容器中的<a class="ae mc" href="https://superset.apache.org/" rel="noopener ugc nofollow" target="_blank"> Apache超集</a>相结合，在本地创建一个良好的数据分析环境。</p><p id="a2cf" class="pw-post-body-paragraph lg lh in li b lj md jo ll lm me jr lo lp mf lr ls lt mg lv lw lx mh lz ma mb ig bi translated">然而，在数据变得对本地机器来说太大之前，本地能做的就这么多了。下一步是在云中的托管Kubernetes中部署容器，并使用<a class="ae mc" href="https://skaffold.dev/" rel="noopener ugc nofollow" target="_blank"> <strong class="li io"> skafold </strong> </a>继续开发工作，这允许文件在本地机器和远程容器之间同步。例如，这对于开发启用了热重载的Node.js服务器非常有用。</p><p id="8fe0" class="pw-post-body-paragraph lg lh in li b lj md jo ll lm me jr lo lp mf lr ls lt mg lv lw lx mh lz ma mb ig bi translated"><a class="ae mc" href="https://k8slens.dev/" rel="noopener ugc nofollow" target="_blank"><strong class="li io">K8s lens</strong></a><strong class="li io"/>是一个独立的UI，可用于监控K3s/K8s部署。它执行与kubectl相同的任务，但是它以可视化的方式呈现信息，并提供了一个很好的UI。</p><p id="161d" class="pw-post-body-paragraph lg lh in li b lj md jo ll lm me jr lo lp mf lr ls lt mg lv lw lx mh lz ma mb ig bi translated">简而言之，K3s可以用于本地开发和测试部署。它还可以用于将不同的服务编排到本地环境中，用于数据分析、ML等。</p><h1 id="5f77" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">我们如何来到这里的简史？</h1><p id="3bec" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo lp lq lr ls lt lu lv lw lx ly lz ma mb ig bi translated">五年前Docker还很受欢迎。应用程序的容器化仍然是相对较新的事物，在<code class="fe my mz na nb b">docker-compose</code>上运行容器才是正确的方向。我甚至在docker-compose上运行了我的第一个网站，用的是数字海洋的“水滴T21”。(他们当时没有托管的Kubernetes产品。Docker-compose 笨重且功能有限。</p><p id="0085" class="pw-post-body-paragraph lg lh in li b lj md jo ll lm me jr lo lp mf lr ls lt mg lv lw lx mh lz ma mb ig bi translated">因此，我开始学习Kubernetes容器编排平台。它来自谷歌，据说相当灵活和可伸缩。我可以证明它绝对是功能齐全，而且每天都在变得更好。习惯它需要一点时间(很多时间)，但这是值得的。很快，我很高兴在谷歌GKE上运行容器，这是一个在谷歌云上的托管Kubernetes部署。</p><p id="455d" class="pw-post-body-paragraph lg lh in li b lj md jo ll lm me jr lo lp mf lr ls lt mg lv lw lx mh lz ma mb ig bi translated">我在Kubernetes上遇到的唯一困难是缺少按照预定义的顺序部署容器的选项，比如启动数据库，然后才启动主服务器应用程序。这更像是微服务架构的一个特性，因为任何服务/容器都应该能够独立运行。微服务之间的紧密耦合通常不被鼓励，这是有原因的；<strong class="li io">相互依赖阻碍扩展</strong>。</p><p id="d457" class="pw-post-body-paragraph lg lh in li b lj md jo ll lm me jr lo lp mf lr ls lt mg lv lw lx mh lz ma mb ig bi translated"><em class="mx">我的名字是</em> <a class="ae mc" href="https://de.linkedin.com/in/nikolay-vaklev-b0582b4a" rel="noopener ugc nofollow" target="_blank"> <em class="mx">尼克·瓦克莱夫</em> </a> <em class="mx">，我是</em><a class="ae mc" href="https://techccino.com/?utm_source=medium.com&amp;utm_medium=tech-blog&amp;utm_content=dev-locally-rancher" rel="noopener ugc nofollow" target="_blank"><em class="mx">Techccino Ltd</em></a><em class="mx">的创始人。如果你有兴趣打造自己的应用和产品</em> <a class="ae mc" href="https://techccino.com/contact-us/?utm_source=medium.com&amp;utm_medium=tech-blog&amp;utm_content=dev-locally-rancher" rel="noopener ugc nofollow" target="_blank"> <em class="mx">联系</em> </a> <em class="mx">。</em></p></div></div>    
</body>
</html>