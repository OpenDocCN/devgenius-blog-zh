# 不要贪多嚼不烂

> 原文：<https://blog.devgenius.io/dont-bite-off-more-than-you-can-chew-261b8bd36af8?source=collection_archive---------6----------------------->

复杂系统中的多任务处理通常意味着增加交付周期。

![](img/8d6be68ce2f4b92e06b73c56a164c139.png)

[https://pix abay . com/illustrations/angry-business woman-conflict-3233158/](https://pixabay.com/illustrations/angry-businesswoman-conflict-3233158/)

软件组织倾向于认为更多的人在一个特性中工作会使这个特性更快地准备好。在那个句子中有两个错误的部分:

*   组织的工作单元不是人，工作单元是团队(至少在那些具有一定复杂程度的组织中)。
*   团队的优先级不一样，因为他们没有相同的利益相关者。

## 团队作为工作单位

在我工作过的所有组织中，创建一个负责某种业务需求的团队是很自然的事情。有不同的方法，但是团队从事软件工作的想法到处传播。
我喜欢看到多核处理器，只有一个处理器拥有多个内核，允许处理器同时做不同的事情。

在团队的情况下，团队是处理器，团队中的人是处理器的核心。
一个内核在特定时刻只能做一件事情，当内核不做任何事情时，处理器会向每个内核发送要完成的任务。例如，当内核正在等待 IO 操作时，就会发生这种情况，这时它需要更改上下文并启动另一个任务。为了控制 IO 操作完成的时间，创建了中断。因此，当一个中断被发送时，处理器对它作出响应，继续被中断的进程。这通常意味着任务之间的上下文切换。

对于真实世界的例子，一个过程中有许多步骤，每个步骤都需要时间。每个步骤的时间是停留时间，由一些等待时间和一些服务时间组成。

开发人员通常以同样的方式工作，但是当被另一个团队阻塞的任务被解除阻塞时，我们的反应能力比处理器差。还有，我们很不好切换上下文。这两个问题让我们很难做多任务处理，我们通常以这种方式工作会产生大量的等待时间(甚至顺序工作更快)。过多的等待时间会让我们花很长时间去理解在那个任务中做了什么，所以我们很难切换上下文。

我们比处理多任务的处理器更糟糕，但事实上处理器也有这样工作的限制，它们有约束，任何系统都有约束。如果你想了解更多，看看[的约束理论](https://en.wikipedia.org/wiki/Theory_of_constraints)。

在团队内部，过多工作的影响表现在每个核心的任务数量上(开发人员，成对)。如果我们有大量的任务在进行中(WIP ),按照之前解释的想法，我们将持续很多时间来完成整个功能，我们将有很长的交付周期。实际上:

提前期=在制品/生产量([详细说明](https://medium.com/dev-genius/one-developer-one-task-b9bd52af925c?sk=6fb3ee21d0f2a8000f17c2a9bdeec019)

减少交付周期最简单的方法是减少团队内部的 WIP。这就是看板所建议的，在你的 WIP 中设置一个限制，并专注于完成正在进行的故事。

# 吞吐量

另一个缩短交付周期的方法是增加生产量。

吞吐量=平均离职率，例如每周的故事数量。

提高吞吐量更加困难，因为这与您的约束条件有关。你可能认为通过增加更多的人员就可以提高吞吐量，[但那不是真的。](https://medium.com/dev-genius/one-developer-one-task-b9bd52af925c?sk=6fb3ee21d0f2a8000f17c2a9bdeec019)这些约束条件可以是:

*   迫使我们以某种方式工作的过程，因为我们想增加产品的质量，但我们没有意识到它们是系统的约束。
*   因为我们的文化，迫使我们协调团队的架构。
*   文化:如果我们更喜欢维持现状，而不是需要改进来避免约束。
*   团队之间的互动。

有一些工作方法可以减少浪费的时间。[例如，CI/CD](https://javi-kata.medium.com/ci-cd-for-dummies-b45ed917f9dc?sk=28eede1d5fec71121eea4954583130e9) 最大限度地减少了将产品投入生产的浪费时间。

## 团队协调

根据我们的架构，一个特性可能意味着要协调几个团队才能让它工作。如果我们没有自治的团队(我们的架构允许我们拥有他们吗？)，如果我们的团队负责完成工作的一部分，而不是我们需要的全部工作。有很多例子:

*   前端团队
*   后端团队
*   运营团队
*   数据库团队

在这种情况下，如果一个特性意味着改变系统的几个部分，而这些部分由不同的团队负责，那么将会有一种从一个团队到另一个团队的请求。例如在上面的例子中:

*   前端团队将等待后端团队获得 API
*   后端团队将等待数据库团队获得模式
*   所有这些都将等待运营部的基础设施投入使用

因此，我们的工作方式迫使我们在试图解决问题的团队之间进行协调。如前所述，这意味着增加第一个团队的在制品数量，从而延长交付周期。除了之前解释的当一个开发人员需要等待另一个团队完成工作时的问题之外，等待的时间也可能更长，因为不同的团队会有不同的优先级。这是正常的，因为不是所有的团队都有相同的利益相关者，相同的路线图等，这又意味着很长的准备时间。

我们采取的自然方法是尝试用不同的 PO 安排任务，以便在所需任务完成时开始一项任务的工作。这是一个非常糟糕的方法，一般来说[调度问题是 NP 完全的](https://www.sciencedirect.com/science/article/pii/S0022000075800080)。与完成任务相比，你需要更多的时间来找到所有重要功能的正确时间表，以减少所有功能的交付周期(浪费时间，不要尝试这样做)。

想象同样的但是在一个自治的团队内部，那么只有一个 PO。PO 需要决定整个特性与其他特性相比有多重要，并让整个团队参与其中。问题已经最小化，现在取决于一个团队，以及这个团队合作的效率。更详细的解释请看“[这是协调愚蠢的](https://medium.com/dev-genius/its-the-coordination-stupid-f3581bbf25cd?sk=644c395aad2747e8409c2f81d5917897)”。

因此，如果我们改进我们的流程，如果我们减少团队之间的协调，吞吐量只能提高，[如果我们改变我们的架构，所以我们改变我们的文化](https://mamaqueesscrum.com/2020/11/23/una-pincelada-de-arquitectura-de-software/)。总的来说，如果我们努力消除我们的约束(我们的局限)。