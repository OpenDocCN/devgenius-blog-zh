<html>
<head>
<title>Angular — Micro-Frontend</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">角度—微前端</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/angular-micro-frontend-4dad619c4277?source=collection_archive---------0-----------------------#2021-12-20">https://blog.devgenius.io/angular-micro-frontend-4dad619c4277?source=collection_archive---------0-----------------------#2021-12-20</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="858e" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">从初级到高级，您需要了解的关于面向微服务的前端架构的一切</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/c77d0b98c4cf32320e50de168ab32a81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hGIjW5P8yCsCxwXw5QcCdA.jpeg"/></div></div></figure></div><div class="ab cl ko kp hr kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="ig ih ii ij ik"><p id="9053" class="pw-post-body-paragraph kv kw in kx b ky kz jo la lb lc jr ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">现代web应用程序变得越来越大、越来越复杂，有时由不同的团队管理。您的应用程序可能具有由不同团队开发的特性，并且您希望在交付整个应用程序之前只将某些特性发布到产品中。如果你有一个回购，你如何管理不同的团队，不同的发布时间表？</p><p id="f31d" class="pw-post-body-paragraph kv kw in kx b ky kz jo la lb lc jr ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">大多数复杂的应用程序都存在于客户端，这使得维护变得更加困难。这个庞大的应用程序还有其他一些问题。在这篇文章中，我将讨论优点，缺点，实现和许多其他东西。</p><ul class=""><li id="372f" class="lr ls in kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated"><strong class="kx io"> <em class="ma">简介</em> </strong></li><li id="9120" class="lr ls in kx b ky mb lb mc le md li me lm mf lq lw lx ly lz bi translated"><strong class="kx io">T5【微前端之旅】T6</strong></li><li id="fa43" class="lr ls in kx b ky mb lb mc le md li me lm mf lq lw lx ly lz bi translated"><strong class="kx io"> <em class="ma">微前端的优势</em> </strong></li><li id="13c8" class="lr ls in kx b ky mb lb mc le md li me lm mf lq lw lx ly lz bi translated"><strong class="kx io"> <em class="ma">微前端的特性</em> </strong></li><li id="d109" class="lr ls in kx b ky mb lb mc le md li me lm mf lq lw lx ly lz bi translated"><strong class="kx io"> <em class="ma">我们如何拆分应用</em> </strong></li><li id="dd53" class="lr ls in kx b ky mb lb mc le md li me lm mf lq lw lx ly lz bi translated"><strong class="kx io"> <em class="ma">微前端的不同做法</em> </strong></li><li id="1db5" class="lr ls in kx b ky mb lb mc le md li me lm mf lq lw lx ly lz bi translated"><strong class="kx io"> <em class="ma">微前端框架</em> </strong></li><li id="bacf" class="lr ls in kx b ky mb lb mc le md li me lm mf lq lw lx ly lz bi translated"><strong class="kx io"> <em class="ma">示例微前端项目带角</em> </strong></li><li id="f3a8" class="lr ls in kx b ky mb lb mc le md li me lm mf lq lw lx ly lz bi translated"><strong class="kx io"> <em class="ma">汇总</em> </strong></li><li id="5b53" class="lr ls in kx b ky mb lb mc le md li me lm mf lq lw lx ly lz bi translated"><strong class="kx io"> <em class="ma">结论</em> </strong></li></ul></div><div class="ab cl ko kp hr kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="ig ih ii ij ik"><h1 id="40f1" class="mg mh in bd mi mj mk ml mm mn mo mp mq jt mr ju ms jw mt jx mu jz mv ka mw mx bi translated">介绍</h1><p id="7c9a" class="pw-post-body-paragraph kv kw in kx b ky my jo la lb mz jr ld le na lg lh li nb lk ll lm nc lo lp lq ig bi translated">微前端是小的应用程序，通常按子域或功能划分，它们一起工作来交付更大的应用程序。在深入研究微前端之前，我们将了解什么是微前端，以及我们为什么要讨论它们。</p><p id="92fe" class="pw-post-body-paragraph kv kw in kx b ky kz jo la lb lc jr ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">通常，项目有不同的规模和不同的需求。如果你的项目简单到只有两三页，可以由一个团队维护，那就不用考虑这些微前端了。你可以用任何你选择的框架来实现，比如Angular、React或Vuejs。</p><p id="c7b0" class="pw-post-body-paragraph kv kw in kx b ky kz jo la lb lc jr ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">但是，情况并非总是如此。有时候，你的前端应用可能是另一个大应用的一小部分，或者你的应用由不同团队开发的许多部分和功能组成，或者你的应用由不同团队开发的一个功能一个功能地发布到生产中。如果你处于其中一种情况，那么你需要考虑一下微前端。让我们看看下图。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nd"><img src="../Images/a8bd726ea2a7f02ad2cc57ca5e2ce0eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ufkT0RsmjJPHww4KP_wcOg.png"/></div></div><figcaption class="ne nf gj gh gi ng nh bd b be z dk translated"><em class="ni">微前端架构</em></figcaption></figure><p id="b6a8" class="pw-post-body-paragraph kv kw in kx b ky kz jo la lb lc jr ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">如上图所示，我们有6个前端应用程序协同工作来交付大型应用程序。这些应用程序之间的通信可以通过事件总线、窗口对象或发布/订阅方法来完成。每个应用程序都可以由单独的团队和任何框架来实现。每个应用程序都可以单独与其后端或端点对话。有一个bootstrap/launch应用程序可以加载所有的应用程序，并根据用户交互或路由在DOM中挂载和卸载。</p><p id="3ed0" class="pw-post-body-paragraph kv kw in kx b ky kz jo la lb lc jr ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated"><strong class="kx io">微前端之旅:</strong>我们首先会明白，为什么我们首先需要这个。让我们来看看目前我们用于面向用户的web应用程序的技术。</p><p id="0a53" class="pw-post-body-paragraph kv kw in kx b ky kz jo la lb lc jr ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated"><strong class="kx io">微前端的优势:</strong>下面是这种架构的优势。</p><p id="b043" class="pw-post-body-paragraph kv kw in kx b ky kz jo la lb lc jr ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated"><strong class="kx io">应用程序很小:</strong>显然，当我们把大的应用程序按章节、页面或功能分割时，应用程序就变小了。</p><p id="f1c1" class="pw-post-body-paragraph kv kw in kx b ky kz jo la lb lc jr ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated"><strong class="kx io">应用程序是独立的:</strong>因为所有的应用程序都是分开开发的，所以它们是相互独立的</p><p id="37a7" class="pw-post-body-paragraph kv kw in kx b ky kz jo la lb lc jr ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated"><strong class="kx io">app更容易理解:</strong>app更容易理解，因为它们很小，由单个团队开发。</p><p id="0537" class="pw-post-body-paragraph kv kw in kx b ky kz jo la lb lc jr ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated"><strong class="kx io">应用程序更容易开发和部署:</strong>由于这些应用程序本质上很小，并且由一个团队开发，因此开发和部署非常容易。我们甚至可以独立部署。</p><p id="c2d2" class="pw-post-body-paragraph kv kw in kx b ky kz jo la lb lc jr ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated"><strong class="kx io">应用程序更容易测试:</strong>我们必须为更大的应用程序编写成千上万的单元测试，并且永远都要运行。这使得部署过程更慢。说到微前端，每个应用都有一些单元测试，并执行自己的单元测试，可以独立运行。</p><p id="95a7" class="pw-post-body-paragraph kv kw in kx b ky kz jo la lb lc jr ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated"><strong class="kx io">应用开发变得更快:</strong>由于有了独立的团队，整个开发变得更快更容易。</p><p id="086c" class="pw-post-body-paragraph kv kw in kx b ky kz jo la lb lc jr ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated"><strong class="kx io"> CI/CD变得更加简单</strong>:每个应用程序都可以单独集成和部署，这使得CI/CD流程变得更加简单。当我们修复应用程序或引入新功能时，我们不必担心整个应用程序，因为所有功能都是独立的。</p><p id="2e8c" class="pw-post-body-paragraph kv kw in kx b ky kz jo la lb lc jr ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated"><strong class="kx io">独立的堆栈和版本:</strong>我们可以为每个应用选择自己的堆栈，但这并不经常发生，但我们可以拥有同一堆栈的不同版本。例如，一些团队有时间和灵活性来引入和测试相同堆栈的新版本。</p><p id="f113" class="pw-post-body-paragraph kv kw in kx b ky kz jo la lb lc jr ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated"><strong class="kx io">没有共享代码:</strong>在大型应用程序中，我们倾向于跨功能共享代码，但是，随着应用程序变得越来越大，这并不能很好地扩展，并且会引入很多错误和相互依赖。这不适用于微前端，因为我们不共享代码，除非它是一个哑组件。</p><p id="8446" class="pw-post-body-paragraph kv kw in kx b ky kz jo la lb lc jr ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated"><strong class="kx io">可以轻松地改变架构，而无需触及旧架构:</strong>有时我们必须扩展旧架构，但我们可能没有开发人员来实现或扩展架构。借助微前端方法，我们可以使用最新的堆栈开发新功能，并独立交付。</p><h1 id="804b" class="mg mh in bd mi mj nj ml mm mn nk mp mq jt nl ju ms jw nm jx mu jz nn ka mw mx bi translated">微前端的特点</h1><ul class=""><li id="c21d" class="lr ls in kx b ky my lb mz le no li np lm nq lq lw lx ly lz bi translated">每个前端代表整个应用程序的特定功能或子域</li><li id="73a3" class="lr ls in kx b ky mb lb mc le md li me lm mf lq lw lx ly lz bi translated">每个前端都可以由单独的团队来实现。</li><li id="dcf1" class="lr ls in kx b ky mb lb mc le md li me lm mf lq lw lx ly lz bi translated">每个前端可以用不同的技术实现。</li><li id="8fd2" class="lr ls in kx b ky mb lb mc le md li me lm mf lq lw lx ly lz bi translated">它们不能共享彼此独立的逻辑及其。</li><li id="fae2" class="lr ls in kx b ky mb lb mc le md li me lm mf lq lw lx ly lz bi translated">每个前端可以归一个团队所有。</li></ul><h1 id="4ac5" class="mg mh in bd mi mj nj ml mm mn nk mp mq jt nl ju ms jw nm jx mu jz nn ka mw mx bi translated">我们如何拆分应用</h1><p id="aade" class="pw-post-body-paragraph kv kw in kx b ky my jo la lb mz jr ld le na lg lh li nb lk ll lm nc lo lp lq ig bi translated">让我们看看如何将大型应用程序拆分成微型前端。划分应用程序没有特定的标准，我们可以根据自己的需求以多种方式进行划分。我们将会看到所有可能的应用划分方式。</p><p id="7a05" class="pw-post-body-paragraph kv kw in kx b ky kz jo la lb lc jr ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated"><strong class="kx io">按功能</strong></p><p id="0804" class="pw-post-body-paragraph kv kw in kx b ky kz jo la lb lc jr ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">这是最常见的方法，因为我们可以很容易地划分应用程序的功能。例如，如果应用仪表板、个人资料和视图有三个功能，我们可以将每个功能作为单独的应用，并在<strong class="kx io"> <em class="ma"> Launch.js </em> </strong> <em class="ma">的帮助下在DOM中挂载和卸载。这个Launch.js可以是一个单独的app，也可以只是一个简单的javascript app。</em></p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nr"><img src="../Images/15e04265e216b95bff58b90b948fd2b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nlZ4IyEhmgLZyaW3TLuCWw.png"/></div></div></figure><p id="94b6" class="pw-post-body-paragraph kv kw in kx b ky kz jo la lb lc jr ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated"><strong class="kx io">按章节</strong></p><p id="3e62" class="pw-post-body-paragraph kv kw in kx b ky kz jo la lb lc jr ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">有些应用程序的每个部分都有很多功能，例如coinbase、Gmail等。在这种情况下，我们可以将每个部分实现为一个新的应用程序。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ns"><img src="../Images/eb3748765f10ccaa288a6c674224282e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gr5mkcHxmZyi7YBR9Ny8rw.png"/></div></div></figure><p id="565a" class="pw-post-body-paragraph kv kw in kx b ky kz jo la lb lc jr ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated"><strong class="kx io">逐页</strong></p><p id="d3ef" class="pw-post-body-paragraph kv kw in kx b ky kz jo la lb lc jr ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">有些应用的功能是按页面划分的。每个页面都有一些独立的功能。我们可以按页面划分这些应用程序，在下图中我们有四个页面。我们可以用这个做四个应用程序。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nt"><img src="../Images/c5d4454be9681976d8accdbb7d189058.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TiKCPp3TdNxIMOALkOU0XQ.png"/></div></div></figure><p id="4307" class="pw-post-body-paragraph kv kw in kx b ky kz jo la lb lc jr ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated"><strong class="kx io">按域</strong></p><p id="7cb1" class="pw-post-body-paragraph kv kw in kx b ky kz jo la lb lc jr ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">基于域拆分应用也是最常见的方法之一。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nt"><img src="../Images/1462f46fd515992000d2c9c323d69b10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iqaGqCnCIG2pv1Kk_G9DTQ.png"/></div></div><figcaption class="ne nf gj gh gi ng nh bd b be z dk translated">按域</figcaption></figure></div><div class="ab cl ko kp hr kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="ig ih ii ij ik"><h1 id="8a29" class="mg mh in bd mi mj mk ml mm mn mo mp mq jt mr ju ms jw mt jx mu jz mv ka mw mx bi translated">微前端的不同方法</h1><p id="39fc" class="pw-post-body-paragraph kv kw in kx b ky my jo la lb mz jr ld le na lg lh li nb lk ll lm nc lo lp lq ig bi translated">有许多方法可以实现微前端。但是我找到了6种方法来实现。</p><ul class=""><li id="f84e" class="lr ls in kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated"><strong class="kx io"> <em class="ma"> Iframes </em> </strong></li><li id="4f29" class="lr ls in kx b ky mb lb mc le md li me lm mf lq lw lx ly lz bi translated"><strong class="kx io"> <em class="ma">通过NGINX </em> </strong></li><li id="b2ac" class="lr ls in kx b ky mb lb mc le md li me lm mf lq lw lx ly lz bi translated"><strong class="kx io"> <em class="ma">腹板构件/角形构件</em> </strong></li><li id="cc4f" class="lr ls in kx b ky mb lb mc le md li me lm mf lq lw lx ly lz bi translated"><strong class="kx io"> <em class="ma">角形库</em> </strong></li><li id="9341" class="lr ls in kx b ky mb lb mc le md li me lm mf lq lw lx ly lz bi translated"><strong class="kx io"><em class="ma"/></strong></li><li id="b1b9" class="lr ls in kx b ky mb lb mc le md li me lm mf lq lw lx ly lz bi translated"><strong class="kx io"> <em class="ma">定制的管弦乐</em> </strong></li></ul></div><div class="ab cl ko kp hr kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="ig ih ii ij ik"><h1 id="467f" class="mg mh in bd mi mj mk ml mm mn mo mp mq jt mr ju ms jw mt jx mu jz mv ka mw mx bi translated">微前端框架</h1><p id="6d89" class="pw-post-body-paragraph kv kw in kx b ky my jo la lb mz jr ld le na lg lh li nb lk ll lm nc lo lp lq ig bi translated">微前端已经实现了至少两年，它仍然是一个绿色领域。你有没有想过有没有什么框架或库来实现这些，让我们的工作变得更容易。答案是肯定的，有几个库或框架</p><ul class=""><li id="4515" class="lr ls in kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated"><a class="ae nu" href="https://single-spa.js.org/" rel="noopener ugc nofollow" target="_blank">单温泉</a></li><li id="844c" class="lr ls in kx b ky mb lb mc le md li me lm mf lq lw lx ly lz bi translated"><a class="ae nu" href="https://frint.js.org/" rel="noopener ugc nofollow" target="_blank"> frint.js </a></li></ul><h1 id="9946" class="mg mh in bd mi mj nj ml mm mn nk mp mq jt nl ju ms jw nm jx mu jz nn ka mw mx bi translated">单温泉</h1><p id="09e8" class="pw-post-body-paragraph kv kw in kx b ky my jo la lb mz jr ld le na lg lh li nb lk ll lm nc lo lp lq ig bi translated">single-spa是一个用于前端微服务的javascript框架，可以通过Angular、React和Vue.js等所有三种流行的框架/库来实现。它可以根据需要延迟加载应用程序，您可以查看他们的网站了解更多信息。</p><h1 id="8bc1" class="mg mh in bd mi mj nj ml mm mn nk mp mq jt nl ju ms jw nm jx mu jz nn ka mw mx bi translated">福临门</h1><p id="5e1d" class="pw-post-body-paragraph kv kw in kx b ky my jo la lb mz jr ld le na lg lh li nb lk ll lm nc lo lp lq ig bi translated">js是一个模块化的JavaScript框架，用于构建可伸缩的反应式应用程序。它还不支持Angular，但它支持React。如果您正在从头开始构建一个反应式应用程序，并且刚刚起步，那么这就是适合您的框架。你可以去他们的网站了解更多信息。</p></div><div class="ab cl ko kp hr kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="ig ih ii ij ik"><h1 id="ca8d" class="mg mh in bd mi mj mk ml mm mn mo mp mq jt mr ju ms jw mt jx mu jz mv ka mw mx bi translated">具有角度的示例微前端项目</h1><p id="caf8" class="pw-post-body-paragraph kv kw in kx b ky my jo la lb mz jr ld le na lg lh li nb lk ll lm nc lo lp lq ig bi translated">有了这些信息，让我们在一个<a class="ae nu" href="https://single-spa.js.org/" rel="noopener ugc nofollow" target="_blank">单spa </a>框架的帮助下构建一个示例Angular项目。我想为演示建立一个简单的应用程序，我会在另一篇文章中用所有的功能做完整的例子。</p><p id="bd1f" class="pw-post-body-paragraph kv kw in kx b ky kz jo la lb lc jr ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">如下图所示，我们将按部分分割此应用程序。我们将总共实现<strong class="kx io"> 4个</strong>应用:HeaderApp、DashboardApp、FooterApp和root应用。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nv"><img src="../Images/207b780971d10970c2e9433e7790a61d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CcqSHet1yrXiuMo73UVuMw.png"/></div></div></figure><p id="38b2" class="pw-post-body-paragraph kv kw in kx b ky kz jo la lb lc jr ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">这是四个应用程序的四个存储库。您可以克隆它们并在您的机器上单独运行它们。</p><pre class="kd ke kf kg gt nw nx ny nz aw oa bi"><span id="0878" class="ob mh in nx b gy oc od l oe of">// root app runs on port 4200<br/>git clone https://github.com/ahmedbhl/micro-root.git<br/>npm install<br/>npm start<br/><br/>// micro header runs on port 4300<br/>git clone https://github.com/ahmedbhl/micro-header.git<br/>npm install<br/>npm start<br/><br/>// micro dashboard runs on port 4202<br/>git clone https://github.com/ahmedbhl/micro-dashboard.git<br/>npm install<br/>npm start<br/><br/>// micro footer runs on port 4201<br/>git clone https://github.com/ahmedbhl/micro-footer.git<br/>npm install<br/>npm start</span></pre><p id="a66a" class="pw-post-body-paragraph kv kw in kx b ky kz jo la lb lc jr ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">您可以在<strong class="kx io"/><a class="ae nu" href="https://morioh.com/redirect?id=5e2516a9c67a8f7752ae7b27&amp;own=5ce3b24117a839790b133129&amp;l=http%3A%2F%2Flocalhost%3A4200%2F" rel="noopener ugc nofollow" target="_blank"><strong class="kx io"><em class="ma">http://localhost:4200/</em></strong></a>上访问整个应用程序</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi og"><img src="../Images/f57f0f6a3a4c3a7b835828ab44686095.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*yDqB5ehQYRe7O40JvZ_-2A.gif"/></div></div><figcaption class="ne nf gj gh gi ng nh bd b be z dk translated"><em class="ni">一起运行所有四个应用程序，使其成为一个应用程序</em></figcaption></figure><p id="da36" class="pw-post-body-paragraph kv kw in kx b ky kz jo la lb lc jr ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">下面是微根app索引HTML文件。我们在第10行导入所有三个应用程序，并用适当的名称和位置注册这些应用程序。因为我们在页面加载时加载所有的应用程序，所以我们没有定义任何特定的上下文路径。</p><pre class="kd ke kf kg gt nw nx ny nz aw oa bi"><span id="a95a" class="ob mh in nx b gy oc od l oe of">&lt;!DOCTYPE html&gt;<br/>&lt;html&gt;<br/>  &lt;head&gt;<br/>    &lt;meta http-equiv="Content-Security-Policy" content="default-src *  data: blob: 'unsafe-inline' 'unsafe-eval'; script-src * 'unsafe-inline' 'unsafe-eval'; connect-src * 'unsafe-inline'; img-src * data: blob: 'unsafe-inline'; frame-src *; style-src * data: blob: 'unsafe-inline'; font-src * data: blob: 'unsafe-inline';"&gt;<br/>    &lt;meta charset="utf-8"&gt;<br/>    &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;<br/>    &lt;title&gt;Your application&lt;/title&gt;<br/>    &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;<br/>    &lt;meta name="importmap-type" content="systemjs-importmap"&gt;<br/>    &lt;script type="systemjs-importmap"&gt;<br/>      {<br/>        "imports": {<br/>          "footer": "http://localhost:4201/main.js",<br/>          "dashboard": "http://localhost:4202/main.js",<br/>          "header": "http://localhost:4300/main.js",<br/>          "single-spa": "https://cdnjs.cloudflare.com/ajax/libs/single-spa/4.3.5/system/single-spa.min.js"<br/>        }<br/>      }<br/>    &lt;/script&gt;<br/>    &lt;link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/single-spa/4.3.5/system/single-spa.min.js" as="script" crossorigin="anonymous" /&gt;<br/>    &lt;script src='https://unpkg.com/core-js-bundle@3.1.4/minified.js'&gt;&lt;/script&gt;<br/>    &lt;script src="https://unpkg.com/zone.js"&gt;&lt;/script&gt;<br/>    &lt;script src="https://unpkg.com/import-map-overrides@1.6.0/dist/import-map-overrides.js"&gt;&lt;/script&gt;<br/>    &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/systemjs/4.0.0/system.min.js"&gt;&lt;/script&gt;<br/>    &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/systemjs/4.0.0/extras/amd.min.js"&gt;&lt;/script&gt;<br/>    &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/systemjs/4.0.0/extras/named-exports.js"&gt;&lt;/script&gt;<br/>    &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/systemjs/4.0.0/extras/named-register.min.js"&gt;&lt;/script&gt;<br/>    &lt;style&gt;<br/>    &lt;/style&gt;<br/>  &lt;/head&gt;<br/>  &lt;body&gt;<br/>    &lt;script&gt;<br/>      System.import('single-spa').then(function (singleSpa) {<br/>        singleSpa.registerApplication(<br/>          'header',<br/>          function () {<br/>            return System.import('header');<br/>          },<br/>          function (location) {<br/>            return true;<br/>          }<br/>        )<br/><br/>        singleSpa.registerApplication(<br/>          'dashboard',<br/>          function () {<br/>            return System.import('dashboard');<br/>          },<br/>          function (location) {<br/>            // return location.pathname.startsWith('/app2');<br/>            return true;<br/>          }<br/>        )<br/><br/>        singleSpa.registerApplication(<br/>          'footer',<br/>          function () {<br/>            return System.import('footer');<br/>          },<br/>          function (location) {<br/>            // return location.pathname.startsWith('/app1');<br/>            return true;<br/>          }<br/>        );<br/>        <br/>        singleSpa.start();<br/>      })<br/>    &lt;/script&gt;<br/>    &lt;import-map-overrides-full&gt;&lt;/import-map-overrides-full&gt;<br/>  &lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="8a5e" class="pw-post-body-paragraph kv kw in kx b ky kz jo la lb lc jr ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated"><em class="ma">根app index.html</em></p><p id="4f8e" class="pw-post-body-paragraph kv kw in kx b ky kz jo la lb lc jr ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">您可以给定/header位置路径，以便在浏览器URL导航到/header时加载标头。让我们来测试一下。</p><pre class="kd ke kf kg gt nw nx ny nz aw oa bi"><span id="2923" class="ob mh in nx b gy oc od l oe of">&lt;script&gt;<br/>      System.import('single-spa').then(function (singleSpa) {<br/>        singleSpa.registerApplication(<br/>          'header',<br/>          function () {<br/>            return System.import('header');<br/>          },<br/>          function (location) {<br/>            return location.pathname.startsWith('/header');<br/>            // return true;<br/>          }<br/>        )</span></pre><p id="d7b0" class="pw-post-body-paragraph kv kw in kx b ky kz jo la lb lc jr ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated"><em class="ma">带/头</em></p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi og"><img src="../Images/f57f0f6a3a4c3a7b835828ab44686095.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*yDqB5ehQYRe7O40JvZ_-2A.gif"/></div></div></figure><h1 id="6c33" class="mg mh in bd mi mj nj ml mm mn nk mp mq jt nl ju ms jw nm jx mu jz nn ka mw mx bi translated">结论</h1><p id="9224" class="pw-post-body-paragraph kv kw in kx b ky my jo la lb mz jr ld le na lg lh li nb lk ll lm nc lo lp lq ig bi translated">我知道Microfrontends是如此时髦的东西，但你不应该在每个应用程序上都使用它。如果你的程序很小，不要使用它，也不要把它复杂化。这种方法应该使我们的整个过程天衣无缝，而不是过于复杂。因此，在使用这种方法之前，请做出最佳判断。</p><p id="a90c" class="pw-post-body-paragraph kv kw in kx b ky kz jo la lb lc jr ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">感谢阅读，继续访问！</p></div></div>    
</body>
</html>