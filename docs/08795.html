<html>
<head>
<title>Creating a curd application in rust using MongoDb rust driver and actix-web</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 MongoDb rust 驱动程序和 actix-web 在 rust 中创建一个凝乳应用程序</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/creating-a-curd-application-in-rust-using-mongodb-rust-driver-and-actix-web-139137615159?source=collection_archive---------10-----------------------#2022-07-11">https://blog.devgenius.io/creating-a-curd-application-in-rust-using-mongodb-rust-driver-and-actix-web-139137615159?source=collection_archive---------10-----------------------#2022-07-11</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="7786" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">CRUD 是来自计算机编程领域的首字母缩写词，指的是实现持久存储应用程序所必需的四个功能:<strong class="jm io">创建、读取、更新和删除</strong>。</p><p id="70d5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在本教程中，我们将在 Actix Web 上创建 rest apis 来对数据库执行凝乳操作。我们将简单地创建一个操作，其中用户可以张贴电影及其细节，并可以删除，更新或观看电影。为了使这个 API 尽可能简单，我们将不使用任何认证或授权技术。只是一些简单的 API 来发布电影，更新电影和删除电影等。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/d0903eabe90f0938d686b7e25216c0a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/1*ZxLJozvWC8uQtYa87K3ZLg.gif"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">可爱的 Ferris 祝你学习愉快</figcaption></figure></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><p id="60de" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> <em class="lb">不好意思，我把流派打错了 genere，忽略。</em> </strong></p><p id="95ca" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">确保你已经安装了最新版本的 rust 工具链，并且你在 Mongodb 上有一个帐户，我们将使用简单的云托管 Mongodb 数据库。</p><p id="67e6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">终端类型上</p><pre class="kj kk kl km gt lc ld le lf aw lg bi"><span id="0b1f" class="lh li in ld b gy lj lk l ll lm">cargo version</span></pre><p id="aad0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你可能会得到一些与你的货物版本相关的输出，如果你的终端不能识别这个命令，你需要重新安装 rust。</p><p id="4dde" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">再次前往终端，创建一个新项目</p><pre class="kj kk kl km gt lc ld le lf aw lg bi"><span id="184e" class="lh li in ld b gy lj lk l ll lm">cargo new rustCurd</span></pre><p id="df24" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你可以给你的项目取任何你想要的名字，只是我不擅长取名字。</p><p id="7972" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们的 MVC 架构看起来会像这样</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="gh gi ln"><img src="../Images/f39374e93ce188f6d6109c37a0cff583.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*daBqhRo9hiESn0SdTQ_oHA.png"/></div></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">忽略我的铁锈分析仪。有时它会指出不必要的错误。</figcaption></figure><ul class=""><li id="1c97" class="ls lt in jm b jn jo jr js jv lu jz lv kd lw kh lx ly lz ma bi translated">在模型文件夹中，我们将创建我们的数据库模式</li><li id="6de3" class="ls lt in jm b jn mb jr mc jv md jz me kd mf kh lx ly lz ma bi translated">在控制器文件夹中，我们将拥有获取和更新数据库的逻辑</li><li id="6314" class="ls lt in jm b jn mb jr mc jv md jz me kd mf kh lx ly lz ma bi translated">在 routes 文件夹中，我们将有处理程序</li><li id="f76a" class="ls lt in jm b jn mb jr mc jv md jz me kd mf kh lx ly lz ma bi translated">startServer.rs 将创建一个 Server 实例</li><li id="7822" class="ls lt in jm b jn mb jr mc jv md jz me kd mf kh lx ly lz ma bi translated">我们项目的二进制入口点中的 Main.rs</li></ul><p id="355d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们开始我们的代码吧。</p><p id="2273" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">转到 cargo.toml 并添加这些依赖项</p><pre class="kj kk kl km gt lc ld le lf aw lg bi"><span id="f052" class="lh li in ld b gy lj lk l ll lm">//cargo.toml</span><span id="81ad" class="lh li in ld b gy mg lk l ll lm">[dependencies]<br/>actix-web = "4.0.1"<br/>tokio = { version = "1", features = ["macros", "rt-multi-thread"] }<br/>serde = "1.0.115"<br/>dotenv = "0.15.0"<br/>bson = "2.3.0"</span><span id="efbc" class="lh li in ld b gy mg lk l ll lm">[dependencies.mongodb]<br/>version = "2.2.0"<br/>default-features = false<br/>features = ["async-std-runtime"]<br/>tokio = { version = "1", features = ["full"] }</span></pre><p id="3591" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">嗯，有很多要理解的，对吧？当我们将在代码中使用它们时，我们将遍历所有这些依赖项。</p><p id="35ea" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在转到 main.rs 并键入以下代码</p><pre class="kj kk kl km gt lc ld le lf aw lg bi"><span id="313c" class="lh li in ld b gy lj lk l ll lm">use mylib::*;</span><span id="2b8f" class="lh li in ld b gy mg lk l ll lm">use dotenv;</span><span id="dd27" class="lh li in ld b gy mg lk l ll lm">#[tokio::main]</span><span id="5e10" class="lh li in ld b gy mg lk l ll lm">async fn main() -&gt; std::io::Result&lt;()&gt; {</span><span id="3e6d" class="lh li in ld b gy mg lk l ll lm">let address = dotenv::var("address").unwrap();</span><span id="2892" class="lh li in ld b gy mg lk l ll lm">let db_url = dotenv::var("db_url").unwrap();</span><span id="0797" class="lh li in ld b gy mg lk l ll lm">let listener = TcpListener::bind(address.clone()).expect("fail to bind to the listner");</span><span id="b38b" class="lh li in ld b gy mg lk l ll lm">let mut client_options = ClientOptions::parse(db_url).await.expect("fail to connect to the server");</span><span id="fe6e" class="lh li in ld b gy mg lk l ll lm">client_options.app_name = Some("App".to_string());</span><span id="bfed" class="lh li in ld b gy mg lk l ll lm">let client = Client::with_options(client_options).expect(" ");</span><span id="d649" class="lh li in ld b gy mg lk l ll lm">let db = client.database("RUSTcurd");</span><span id="f305" class="lh li in ld b gy mg lk l ll lm">println!("server is running at {}",address);</span><span id="e995" class="lh li in ld b gy mg lk l ll lm">run(listener,db)?.await<br/>}</span></pre><p id="f9f7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这可能会让你很难接受，但请耐心等待</p><p id="6958" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Tokio 运行时<strong class="jm io">提供了运行异步任务</strong>所必需的 I/O 驱动程序、任务调度程序、定时器和阻塞池。因为 Actix-web 服务器的每个工作线程都使用单线程运行时。<em class="lb">请注意，服务器实例的数量取决于您的 cpu 拥有的核心数量。</em></p><p id="f824" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">通过将 TcpListner 绑定到套接字地址来创建 TcpListner 之后，它会侦听传入的 TCP 连接。<em class="lb">注意当值下降时，套接字将关闭。</em></p><p id="9f88" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在我们的例子中，您将在. env 文件中存储您的本地主机地址，即 127.0.0.1:80 和 mongodb 应用程序连接 url。头，创建自己的文件。</p><p id="2d87" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你的。env 文件应该如下所示</p><pre class="kj kk kl km gt lc ld le lf aw lg bi"><span id="e012" class="lh li in ld b gy lj lk l ll lm">address=127.0.0.1:80</span><span id="099b" class="lh li in ld b gy mg lk l ll lm">db_url=mongodb+srv://&lt;your database url&gt;</span></pre><p id="6c14" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">ClientOptions 它是一个结构，当连接到我们的数据库实例时将被传递，这个结构有许多属性，你可以在 mongodb rust drive 文档中找到它。连接到数据库后，我们创建自己的名为“RUSTcurd”的数据库，并将 Db connected 实例和 TcpListner 传递给我们的 run 函数，我们现在将定义这个函数。</p><p id="13db" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们的 startServer 文件将托管我们的 Http 服务器，所有的路由将只在这个文件中提供服务。基本上，它将创建一个 actix web http 服务器实例。</p><p id="04dc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，在 startServer.rs 文件中粘贴以下代码</p><pre class="kj kk kl km gt lc ld le lf aw lg bi"><span id="e1ab" class="lh li in ld b gy lj lk l ll lm">use actix_web:: {web, App, HttpServer};<br/>use mongodb::{Database};<br/>use std::net::TcpListener;<br/>use actix_web::dev:: Server;<br/>use routes::*;</span><span id="0c77" class="lh li in ld b gy mg lk l ll lm">pub fn run(listener:TcpListener,db:Database)-&gt;Result&lt;Server, std::io:: Error&gt; {</span><span id="01e7" class="lh li in ld b gy mg lk l ll lm">let db = web::Data::new(db);</span><span id="d7a3" class="lh li in ld b gy mg lk l ll lm">let _server = HttpServer::new(move|| {</span><span id="b9d2" class="lh li in ld b gy mg lk l ll lm">App:: new()</span><span id="f90a" class="lh li in ld b gy mg lk l ll lm">.route("/postMovie", web::post().to(postMovie))</span><span id="9b0f" class="lh li in ld b gy mg lk l ll lm">.route("/updateMovie", web::get().to(updateMovie))<br/>//you could use patch method also</span><span id="4242" class="lh li in ld b gy mg lk l ll lm">.route("/deleteMovie", web::delete().to(deleteMovie))</span><span id="a37d" class="lh li in ld b gy mg lk l ll lm">.route("/showMovie", web::get().to(getMovie))</span><span id="3d7d" class="lh li in ld b gy mg lk l ll lm">.app_data(db.clone())</span><span id="441d" class="lh li in ld b gy mg lk l ll lm">}).listen(listener).expect(" ")</span><span id="ad2b" class="lh li in ld b gy mg lk l ll lm">.run();</span><span id="7adf" class="lh li in ld b gy mg lk l ll lm">Ok(_server)</span><span id="99b6" class="lh li in ld b gy mg lk l ll lm">}</span></pre><p id="2b03" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们使用 HttpServer::new 创建了一个 Http server 实例，有 4 个 api 端点，像 javascript ie 链接类上的函数调用，也可以在 rust struct 上完成，App::new 创建了一个新的 App 实例。那我们就打电话。route 方法来创建 API 的路由。这些路径的名称是“后期电影”、“更新电影”、“删除电影”、“放映电影”。我们还将我们的数据库状态(db handler)传递给每个路由，并且可以从 actixWeb 提取器中提取。请记住，我们传递的是 db.clone，因为 actix web 会产生多个线程，每个线程都需要自己的 db handler 实例。</p><p id="8f82" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">。route 有两个参数，第一个是定义 api 端点的字符串，第二个是带有 Https 方法和处理函数的 web struct。</p><p id="9bce" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在转到 routes 之前，我们将首先定义电影集合的模式。</p><p id="d8e4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">转到 models 文件夹，创建一个文件名为 movieSchema.rs 的文件，然后粘贴这段代码</p><pre class="kj kk kl km gt lc ld le lf aw lg bi"><span id="ae2e" class="lh li in ld b gy lj lk l ll lm">use serde::{Deserialize,Serialize};<br/>use mongodb::options::{IndexOptions};<br/>use mongodb::IndexModel;<br/>use mongodb::Client;<br/>use bson::doc;</span><span id="c32e" class="lh li in ld b gy mg lk l ll lm">#[derive(Deserialize,Serialize)]<br/>pub struct Movie {<br/>pub name:String,<br/>pub relese_data:String,<br/>pub genere:String,<br/>pub rating:i32<br/>}</span><span id="8b4c" class="lh li in ld b gy mg lk l ll lm">pub async fn create_name_unique(client: &amp;Client) {<br/>let options = IndexOptions::builder().unique(true).build();<br/>let model = IndexModel::builder()<br/>.keys(doc!{"name":1})<br/>.options(options)<br/>.build();</span><span id="8f77" class="lh li in ld b gy mg lk l ll lm">client<br/>.database("RUSTcurd")  //name of our database<br/>.collection::&lt;Movie&gt;("Movies") //name of our collection<br/>.create_index(model, None)<br/>.await<br/>.expect("error creating index!");<br/>}</span></pre><p id="5e1a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们的结构需要被序列化和反序列化，以便它可以作为 bson 数据放入 mongodb，当从 mongo db 提取时，它可以被解析回 rust 原生结构类型。</p><p id="87ef" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们的电影名称必须是唯一的，我们在这里使用 mongodb 索引来指定 name 字段的属性。我们将不讨论 mongodb 索引，因为它们超出了当前议程的范围。注意，我们只需在向数据库中插入任何内容之前运行一次此函数“create_name_unique”。但是在运行这个函数之前，我们需要在数据库中创建一个名为“Movies”的集合，我们将在 main.rs 上完成所有这些工作。</p><p id="b657" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在 main.rs 糊上</p><pre class="kj kk kl km gt lc ld le lf aw lg bi"><span id="0d5e" class="lh li in ld b gy lj lk l ll lm">use mylib::*;</span><span id="9ca4" class="lh li in ld b gy mg lk l ll lm">#[tokio::main]</span><span id="0d34" class="lh li in ld b gy mg lk l ll lm">async fn main() -&gt; std::io::Result&lt;()&gt; {</span><span id="a171" class="lh li in ld b gy mg lk l ll lm">let address = dotenv::var("address").unwrap();</span><span id="dd37" class="lh li in ld b gy mg lk l ll lm">let db_url = dotenv::var("db_url").unwrap();</span><span id="c2a8" class="lh li in ld b gy mg lk l ll lm">let listener = TcpListener::bind(address.clone()).expect("fail to bind to the listner");</span><span id="656f" class="lh li in ld b gy mg lk l ll lm">let mut client_options = ClientOptions::parse(db_url).await.expect("fail to connect to the server");</span><span id="0f47" class="lh li in ld b gy mg lk l ll lm">client_options.app_name = Some("App".to_string());</span><span id="0e3b" class="lh li in ld b gy mg lk l ll lm">let client = Client::with_options(client_options).expect(" ");</span><span id="6496" class="lh li in ld b gy mg lk l ll lm">let db = client.database("RUSTcurd");</span><span id="6ca9" class="lh li in ld b gy mg lk l ll lm">//we create a collection with movies struct defined in models as schema and named it 'Movies'</span><span id="6b25" class="lh li in ld b gy mg lk l ll lm">_c = db.collection::&lt;Movie&gt;("Movies");</span><span id="b710" class="lh li in ld b gy mg lk l ll lm">//we need to run this function to create name field as unique</span><span id="36a5" class="lh li in ld b gy mg lk l ll lm">create_name_unique(&amp;client);</span><span id="8e33" class="lh li in ld b gy mg lk l ll lm">println!("server is running at {}",address);</span><span id="50fe" class="lh li in ld b gy mg lk l ll lm">run(listener,db)?.await</span><span id="9fe5" class="lh li in ld b gy mg lk l ll lm">}</span></pre><p id="65b7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">请注意，所需的文件是在 lib.rs 中导入的，我们只能从 lib.rs 中访问它们，在 main.rs 的第一行，我们有“use lib::*”将导入 lib 中定义或导入的所有函数和结构。应该记住，lib.rs 中导入的所有结构都必须是公共的。</p><p id="6404" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下面是我的 lib.rs 的样子</p><pre class="kj kk kl km gt lc ld le lf aw lg bi"><span id="9d99" class="lh li in ld b gy lj lk l ll lm">pub use mongodb::{Client};</span><span id="6f48" class="lh li in ld b gy mg lk l ll lm">pub use mongodb::options::ClientOptions;</span><span id="9149" class="lh li in ld b gy mg lk l ll lm">pub use std::net::TcpListener;</span><span id="6c80" class="lh li in ld b gy mg lk l ll lm">pub mod models;</span><span id="dda1" class="lh li in ld b gy mg lk l ll lm">pub use models::{Movie,create_name_unique};</span><span id="36a0" class="lh li in ld b gy mg lk l ll lm">pub use dotenv;</span><span id="05fa" class="lh li in ld b gy mg lk l ll lm">mod startServer;</span><span id="d506" class="lh li in ld b gy mg lk l ll lm">pub use startServer::run;</span><span id="1bc8" class="lh li in ld b gy mg lk l ll lm">mod routes;</span><span id="24d9" class="lh li in ld b gy mg lk l ll lm">pub use routes::*;</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/a5ed4705549d2abf4a0569571cd1f5c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*vkNIbH535tKUECdBqWDSxw.gif"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">如果事情对你没有多大意义，不要惊慌。</figcaption></figure><p id="dbb8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在让我们为 api 端点创建处理程序，进入 routes 文件夹并创建 4 个名为</p><ul class=""><li id="dc5a" class="ls lt in jm b jn jo jr js jv lu jz lv kd lw kh lx ly lz ma bi translated">电影后期</li><li id="f52a" class="ls lt in jm b jn mb jr mc jv md jz me kd mf kh lx ly lz ma bi translated">更新电影. rs</li><li id="a24a" class="ls lt in jm b jn mb jr mc jv md jz me kd mf kh lx ly lz ma bi translated">放映电影. rs</li><li id="22fa" class="ls lt in jm b jn mb jr mc jv md jz me kd mf kh lx ly lz ma bi translated">删除电影</li></ul><p id="867c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在许多情况下，人们更喜欢在同一个文件中创建与单个对象相关的处理程序。对我们来说，是电影。事实上，当你在大型项目中工作时，你有管理路径，用户路径等等。一个好的开发人员总是喜欢在同一个文件中保存具有相似对象的路线。但是由于我们只有四条路线，我们可以将它们保存在单独的文件中。</p><p id="65f5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们来创建后期处理程序并粘贴它</p><pre class="kj kk kl km gt lc ld le lf aw lg bi"><span id="8054" class="lh li in ld b gy lj lk l ll lm">#![allow(non_snake_case)]</span><span id="5d24" class="lh li in ld b gy mg lk l ll lm">use actix_web::{web,Responder,HttpResponse};<br/>use serde::{Deserialize};<br/>use mongodb::Database;<br/>pub use mongodb::bson::{doc, Document};<br/>use actix_web::http::header::ContentType;<br/>use actix_web::http::StatusCode;<br/>use crate::models::{Movie};</span><span id="a59a" class="lh li in ld b gy mg lk l ll lm">#[derive(Deserialize)]<br/>pub struct userData{<br/>pub name:String,<br/>pub relese_data:String,<br/>pub genere:String,<br/>pub rating:i32</span><span id="bb8c" class="lh li in ld b gy mg lk l ll lm">}</span><span id="18d0" class="lh li in ld b gy mg lk l ll lm">pub async fn postMovie(db:web::Data&lt;Database&gt;,Info: web::Json&lt;userData&gt;)-&gt;impl Responder{</span><span id="8e35" class="lh li in ld b gy mg lk l ll lm">let data = Movie{<br/>name:Info.name.clone(),<br/>relese_data:Info.relese_data.clone(),<br/>genere:Info.genere.clone(),<br/>rating:Info.rating.clone()</span><span id="0680" class="lh li in ld b gy mg lk l ll lm">};<br/></span><span id="d276" class="lh li in ld b gy mg lk l ll lm">let  collection = db.collection::&lt;Movie&gt;("Movies");</span><span id="6785" class="lh li in ld b gy mg lk l ll lm">match collection.insert_one(data,None).await {<br/>Ok(_ok)=&gt; {</span><span id="6c78" class="lh li in ld b gy mg lk l ll lm">     HttpResponse::Ok()<br/>    .content_type(ContentType::json())<br/>    .insert_header(("X-Hdr", "sample"))<br/>    .status(StatusCode::from_u16(200).unwrap())<br/>    .body(format!("data posted")) </span><span id="9880" class="lh li in ld b gy mg lk l ll lm">          },</span><span id="481a" class="lh li in ld b gy mg lk l ll lm">Err(err)=&gt; {</span><span id="78ba" class="lh li in ld b gy mg lk l ll lm">      HttpResponse::Ok()<br/>     .content_type(ContentType::json())<br/>     .insert_header(("X-Hdr", "sample"))<br/>     .status(StatusCode::from_u16(501).unwrap())<br/>     .body(format!("could not post data, reason : {}",err))</span><span id="a6c3" class="lh li in ld b gy mg lk l ll lm">           }</span><span id="2073" class="lh li in ld b gy mg lk l ll lm">    } // end of match statement</span><span id="ca4c" class="lh li in ld b gy mg lk l ll lm">} // end of handler</span></pre><p id="b45d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在编辑器中应该是这样的</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/6a3ee8152cf1629e5a354b103a3b59a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1228/format:webp/1*nzwU46WZ9uxWLDNYotrnlA.png"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="gh gi mj"><img src="../Images/dd941d0636d0bdb2568cb76b0437f3ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mHD1_lNbjhl6QvmvIbLF9g.png"/></div></div></figure><p id="80f8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">那里发生了很多事情。别担心，我会解释每一件事，这样你就能理解了。</p><p id="c373" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">首先，我们需要导入将在处理程序中使用的结构。</p><p id="e5db" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">之后，我们需要创建一个名为“userData”的序列化结构。我们将从用户那里收到的内容是一个原始的 json 主体。我们需要提取 json 数据用于 rust 代码。这里 actix 提取器开始发挥作用。Actix 网页提取器提供了很多。我们可以提取查询、参数、表单数据等等。您可以参考 Actix web 文档了解更多信息。在我们的例子中，我们将使用' web::Json <userdata>'，注意 userData 结构已经被传递给 web::Json 提取器，以便提取器知道我们需要如何将数据解析到 rust native 结构中。</userdata></p><p id="cd0d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在 mongodb rust 驱动程序中，可以使用 doc 方法或 struct 插入数据。我们将使用 struct 方法，因为我们的集合模式仅基于 struct。首先，我们将创建一个电影类型的结构，并在 init 上传递相关参数。web 提取器结构不实现复制特征，由于生命周期的限制，我们不能传递它的引用，我们每次都必须使用克隆方法。</p><p id="35a7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">之后，我们可以在数据库中创建一个名为“Movie”的集合的句柄，并使用 insert_one 方法，它有两个参数，第一个是您要插入的数据，第二个是 Option <:options>，因为我们没有任何 options 参数，所以我们不会向它传递任何参数。</:options></p><p id="6fcb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">insert_one 方法返回一个未来，就像 javascript 中的承诺一样，我们需要等待它。我不确定你是否熟悉异步编程，但是我们所有的处理函数本质上都是异步的，我们不想在 mongodb 操作完成之前发送响应。</p><pre class="kj kk kl km gt lc ld le lf aw lg bi"><span id="814f" class="lh li in ld b gy lj lk l ll lm">collection.insert_one(data,None).await</span></pre><p id="df2d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">该语句将返回一个结果枚举，我们使用 match 关键字来处理错误。Ok (_ok)变量将包含与成功插入相关的数据，Err()变量将包含与插入时发生的错误相关的数据。http response 结构用于创建实现 Responder 特征 http 响应，我们可以向和添加其他数据，但是现在我们只保留 json 内容类型和 HttpResponse 结构的默认头。</p><p id="d5b8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们几乎完成了 80%的代码和理解，现在我们只剩下三条路线。</p><p id="62d6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们现在将创建 getMovie route，它将有一个单一的变量，其中电影的名称将从 url 的查询中提取，当然，您可以创建其他路由，这些路由采用数据或其他东西来查找电影名称，但我们将使用 query。</p><p id="2568" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在 getMovie.rs 粘贴上</p><pre class="kj kk kl km gt lc ld le lf aw lg bi"><span id="506c" class="lh li in ld b gy lj lk l ll lm">#![allow(non_snake_case)]</span><span id="d67e" class="lh li in ld b gy mg lk l ll lm">use actix_web::{web,Responder,HttpResponse};<br/>use serde::{Deserialize};<br/>use mongodb::Database;<br/>pub use mongodb::bson::{doc, Document};<br/>use actix_web::http::header::ContentType;<br/>use actix_web::http::StatusCode;<br/>use crate::models::{Movie};</span><span id="d268" class="lh li in ld b gy mg lk l ll lm">#[derive(Deserialize)]<br/>pub struct userQuery{<br/>pub name:String,<br/>}</span><span id="d15f" class="lh li in ld b gy mg lk l ll lm">pub async fn getMovie(db:web::Data&lt;Database&gt;,Info: web::Query&lt;userQuery&gt;)-&gt;impl Responder{</span><span id="b8c5" class="lh li in ld b gy mg lk l ll lm">let  collection = db.collection::&lt;Movie&gt;("Movies");<br/>let filter = doc!{"name":Info.name.clone()};<br/>let data = match collection.find_one(filter,None).await {<br/>Ok(data)=&gt; {<br/>data<br/>}<br/>,<br/>Err(err)=&gt; {</span><span id="2360" class="lh li in ld b gy mg lk l ll lm">return  HttpResponse::Ok()<br/>.content_type(ContentType::json())<br/>.insert_header(("X-Hdr", "sample"))<br/>.status(StatusCode::from_u16(501).unwrap())<br/>.body(format!("could not post data, reason : {}",err))</span><span id="31f4" class="lh li in ld b gy mg lk l ll lm">}</span><span id="ca57" class="lh li in ld b gy mg lk l ll lm">};//end of match statement</span><span id="4c68" class="lh li in ld b gy mg lk l ll lm">match data {</span><span id="23d6" class="lh li in ld b gy mg lk l ll lm">Some(data)=&gt;{</span><span id="24f6" class="lh li in ld b gy mg lk l ll lm">return HttpResponse::Ok()<br/>.content_type(ContentType::json())<br/>.insert_header(("X-Hdr", "sample"))<br/>.status(StatusCode::from_u16(200).unwrap())<br/>.body(format!("Tital : {}  \n  Release data : {}  \n ratings : {} ",data.name,data.relese_data,data.rating))</span><span id="c4cf" class="lh li in ld b gy mg lk l ll lm">},</span><span id="c57b" class="lh li in ld b gy mg lk l ll lm">None=&gt;{</span><span id="894e" class="lh li in ld b gy mg lk l ll lm">return  HttpResponse::Ok()<br/>.content_type(ContentType::json())<br/>.insert_header(("X-Hdr", "sample"))<br/>.status(StatusCode::from_u16(404).unwrap())</span><span id="1c7b" class="lh li in ld b gy mg lk l ll lm">.body(format!("No movie with name {} exist in the database",Info.name))<br/>   }</span><span id="2bb6" class="lh li in ld b gy mg lk l ll lm"> }//end of match statment</span><span id="b151" class="lh li in ld b gy mg lk l ll lm">}//end of handler</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="gh gi mk"><img src="../Images/3f3c416969871668085b09caeac7fcf4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7eej_fLh5Wtm8gA8ZUsJ5A.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="gh gi ml"><img src="../Images/062b8abd02642e4441e8aaef6182e650.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iXNl63vA8ZTpVsHOgn3ebA.png"/></div></div></figure><p id="77ed" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Web::Query <userquery>是另一个 actixweb 提取器，它从 url 中提取查询，同样，我们需要使用 serde 将其表示为 rust 原生数据类型。</userquery></p><p id="87f2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里需要注意的一点是，在 match arm 中，如果我们在表达式前使用“return”关键字，arm 会将表达式输出返回到基本函数，即定义 match 语句的函数，但如果我们在 match arm 中返回没有 return 关键字的内容，它会省略分号，match 语句将返回到变量表达式。</p><p id="b8ae" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里有一个快速提示，因为我们广泛使用 Http::Response，所以我们唯一要改变的是响应体和状态代码。我们可以创建一个函数，通过这两个参数构建一个响应结构。这将节省大量的复制和粘贴的东西。</p><p id="3d3a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们不会实现上面的，因为这会在 mvc 中添加更多的模块，即“utils”文件夹。但是写简短的代码总是一个很好的练习。</p><p id="8b16" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">collection.find_one 将返回一个 Result <ok>)、Err(err)&gt; enum，Ok 变量本身包含另一个 Option enum，如果电影存在它将拥有电影的 struct 变量，否则将是 None。</ok></p><p id="ed82" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我假设您熟悉 Rust 的模块系统，以及如何从一个文件向另一个文件导入和使用函数和结构。</p><p id="8a5d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们创建更新电影，这将是最大的代码</p><p id="a1f9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在您的 updateMovie.rs 中粘贴以下代码</p><pre class="kj kk kl km gt lc ld le lf aw lg bi"><span id="a9f0" class="lh li in ld b gy lj lk l ll lm">#![allow(non_snake_case)]</span><span id="98f3" class="lh li in ld b gy mg lk l ll lm">use actix_web::{web,Responder,HttpResponse};<br/>use serde::{Deserialize};<br/>use mongodb::Database;<br/>pub use mongodb::bson::{doc, Document};<br/>use actix_web::http::header::ContentType;<br/>use actix_web::http::StatusCode;<br/>use crate::models::{Movie};</span><span id="c513" class="lh li in ld b gy mg lk l ll lm">#[derive(Deserialize)]<br/>pub struct userData{<br/>pub name:String,<br/>pub relese_date:Option&lt;String&gt;,<br/>pub genere:Option&lt;String&gt;,<br/>pub rating:Option&lt;i32&gt;</span><span id="1cc2" class="lh li in ld b gy mg lk l ll lm">}</span><span id="b2d3" class="lh li in ld b gy mg lk l ll lm">pub async fn updateMovie(db:web::Data&lt;Database&gt;,Info: web::Json&lt;userData&gt;)-&gt;impl Responder{</span><span id="cf4e" class="lh li in ld b gy mg lk l ll lm">let  collection = db.collection::&lt;Movie&gt;("Movies");</span><span id="e1ec" class="lh li in ld b gy mg lk l ll lm">let Movie = collection.find_one(doc!{"name":Info.name.clone()},None).await;</span><span id="5e54" class="lh li in ld b gy mg lk l ll lm">let Movie  = match Movie {</span><span id="fa32" class="lh li in ld b gy mg lk l ll lm">Ok(movie)=&gt;movie,</span><span id="5fd1" class="lh li in ld b gy mg lk l ll lm">Err(_err)=&gt;  {<br/> return HttpResponse::Ok()<br/>.content_type(ContentType::json())<br/>.insert_header(("X-Hdr", "sample"))<br/>.status(StatusCode::from_u16(501).unwrap())<br/>.body(format!("internal server error"))</span><span id="3e9a" class="lh li in ld b gy mg lk l ll lm">}</span><span id="9d9f" class="lh li in ld b gy mg lk l ll lm">};//end of match</span><span id="e2b3" class="lh li in ld b gy mg lk l ll lm">let Movie = match Movie{</span><span id="2037" class="lh li in ld b gy mg lk l ll lm">Some(Movie)=&gt; Movie,</span><span id="9c4e" class="lh li in ld b gy mg lk l ll lm">None=&gt;{<br/>return HttpResponse::Ok()<br/>.content_type(ContentType::json())<br/>.insert_header(("X-Hdr", "sample"))<br/>.status(StatusCode::from_u16(401).unwrap())<br/>.body(format!("no movie with name {} exist",Info.name))</span><span id="fe37" class="lh li in ld b gy mg lk l ll lm">}</span><span id="5bad" class="lh li in ld b gy mg lk l ll lm">};//end of match statement</span><span id="9fe8" class="lh li in ld b gy mg lk l ll lm">let releasedate = if Info.relese_date == None{ Movie.relese_data} else { Info.relese_date.clone().unwrap()};</span><span id="c7af" class="lh li in ld b gy mg lk l ll lm">let genere = if Info.genere == None{ Movie.genere} else { Info.genere.clone().unwrap()};</span><span id="9c90" class="lh li in ld b gy mg lk l ll lm">let rating = if Info.rating == None{ Movie.rating} else { Info.rating.unwrap()};</span><span id="e4ea" class="lh li in ld b gy mg lk l ll lm">let filter = doc!{"name":Info.name.clone()};<br/>let update = doc!{"$set":{"relese_data":releasedate,"genere":genere,"rating":rating}};</span><span id="eaef" class="lh li in ld b gy mg lk l ll lm">match collection.update_one(filter,update,None).await{</span><span id="04dd" class="lh li in ld b gy mg lk l ll lm">Err(_err)=&gt;{</span><span id="cb11" class="lh li in ld b gy mg lk l ll lm">return HttpResponse::Ok()<br/>.content_type(ContentType::json())<br/>.insert_header(("X-Hdr", "sample"))<br/>.status(StatusCode::from_u16(501).unwrap())<br/>.body(format!("internal server error {} ",_err))</span><span id="2921" class="lh li in ld b gy mg lk l ll lm">    },</span><span id="8c30" class="lh li in ld b gy mg lk l ll lm">Ok(_ok)=&gt;{</span><span id="17f4" class="lh li in ld b gy mg lk l ll lm">return HttpResponse::Ok()<br/>.content_type(ContentType::json())<br/>.insert_header(("X-Hdr", "sample"))<br/>.status(StatusCode::from_u16(201).unwrap())<br/>.body(format!("update finished"))</span><span id="51f7" class="lh li in ld b gy mg lk l ll lm">    }<br/>  }//end of match arm<br/>}//end of handler</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="gh gi mm"><img src="../Images/a3a9abe7704bd81100bf94eccd131029.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E69SCEHTMQTXBpupETn4iQ.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="gh gi mm"><img src="../Images/bde11696be57624340c64ba92046f7ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vndhOJnsK7FAEKHoU8HFeA.png"/></div></div></figure><p id="31fc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我坚信，在这一点上，你必须熟悉这里发生的一切。该路线采用一个原始的 JSON 主体。“名称”字段是更新文档所必需的。其他都是可选的。例如，如果我们只在 json 主体中传递 genere，其余的字段将保持不变，genere 将被更新。</p><p id="9bde" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，您应该能够创建自己的删除电影路线了，如果您这样做，我将不胜感激。如果没有，那么看看下面的代码</p><pre class="kj kk kl km gt lc ld le lf aw lg bi"><span id="787b" class="lh li in ld b gy lj lk l ll lm">#![allow(non_snake_case)]</span><span id="94e7" class="lh li in ld b gy mg lk l ll lm">use actix_web::{web,Responder,HttpResponse};<br/>use serde::{Deserialize};<br/>use mongodb::Database;<br/>pub use mongodb::bson::{doc, Document};<br/>use actix_web::http::header::ContentType;<br/>use actix_web::http::StatusCode;<br/>use crate::models::{Movie};</span><span id="eb04" class="lh li in ld b gy mg lk l ll lm">#[derive(Deserialize)]<br/>pub struct userQuery{<br/>pub name:String,</span><span id="5149" class="lh li in ld b gy mg lk l ll lm">}</span><span id="841e" class="lh li in ld b gy mg lk l ll lm">pub async fn deleteMovie(db:web::Data&lt;Database&gt;,Info: web::Query&lt;userQuery&gt;)-&gt;impl Responder{</span><span id="75f0" class="lh li in ld b gy mg lk l ll lm">let  collection = db.collection::&lt;Movie&gt;("Movies");</span><span id="4d4b" class="lh li in ld b gy mg lk l ll lm">let filter = doc!{"name":Info.name.clone()};</span><span id="7746" class="lh li in ld b gy mg lk l ll lm">let data = match collection.delete_one(filter,None).await {</span><span id="7090" class="lh li in ld b gy mg lk l ll lm">Ok(data)=&gt; {</span><span id="5e3c" class="lh li in ld b gy mg lk l ll lm">return  HttpResponse::Ok()<br/>.content_type(ContentType::json())<br/>.insert_header(("X-Hdr", "sample"))<br/>.status(StatusCode::from_u16(201).unwrap())<br/>.body(format!("movie deleted"))</span><span id="7b34" class="lh li in ld b gy mg lk l ll lm">},</span><span id="d3c9" class="lh li in ld b gy mg lk l ll lm">Err(err)=&gt; {<br/>return  HttpResponse::Ok()<br/>.content_type(ContentType::json())<br/>.insert_header(("X-Hdr", "sample"))<br/>.status(StatusCode::from_u16(501).unwrap())<br/>.body(format!("internal server error : {}",err))</span><span id="6f6d" class="lh li in ld b gy mg lk l ll lm">}</span><span id="5a7e" class="lh li in ld b gy mg lk l ll lm">};//end of match statement</span><span id="e7ed" class="lh li in ld b gy mg lk l ll lm">}//end of handler</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="gh gi mn"><img src="../Images/77cfd655d5218f235148fe062100cac0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5rxHhcLtkSikuRcx1cac0A.png"/></div></div></figure><p id="2d45" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">就这样，你的应用程序现在已经准备好了。你可以用 postman 测试它。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/acfef0c0b641220a1c4a4145c8176040.png" data-original-src="https://miro.medium.com/v2/resize:fit:1196/0*-17KPpx3GYBfggpG.gif"/></div></figure><p id="fda4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这就对了，你用 rust 创建了你的第一个后端，这看起来很难，但是随着你理解的越来越多，它会变得越来越容易。</p></div></div>    
</body>
</html>