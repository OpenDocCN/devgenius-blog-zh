<html>
<head>
<title>Using MongoDB with Mongoose — Discriminators</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用MongoDB和mongose-discriminator</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/using-mongodb-with-mongoose-discriminators-d3d2d3fee77f?source=collection_archive---------6-----------------------#2021-01-28">https://blog.devgenius.io/using-mongodb-with-mongoose-discriminators-d3d2d3fee77f?source=collection_archive---------6-----------------------#2021-01-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/6ca4c979332ef4e99b84abf2730456e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ioT5TxjKY3br4r-b"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@matteason?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">马特·伊森</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="b37f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了简化MongoDB数据库操作，我们可以使用mongose NPM包来简化MongoDB数据库的操作。</p><p id="0b19" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将了解如何使用Mongoose来操作我们的MongoDB数据库。</p><h1 id="325d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">鉴别器</h1><p id="e18e" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">鉴别器是一种模式继承机制。</p><p id="816f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们让我们能够让多个模型在同一个MongoDB集合上拥有重叠的模式。</p><p id="2ce2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以如下使用它们:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="7c6b" class="mn lc iq mj b gy mo mp l mq mr">async function run() {<br/>  const { createConnection, Types, Schema } = require('mongoose');<br/>  const db = createConnection('mongodb://localhost:27017/test');<br/>  const options = { discriminatorKey: 'kind' };</span><span id="26cc" class="mn lc iq mj b gy ms mp l mq mr">  const eventSchema = new Schema({ time: Date }, options);<br/>  const Event = db.model('Event', eventSchema);<br/>  const ClickedLinkEvent = Event.discriminator('ClickedLink',<br/>    new Schema({ url: String }, options));<br/>  const genericEvent = new Event({ time: Date.now(), url: 'mongodb.com' });<br/>  console.log(genericEvent)</span><span id="5e3c" class="mn lc iq mj b gy ms mp l mq mr">  const clickedEvent =<br/>    new ClickedLinkEvent({ time: Date.now(), url: 'mongodb.com' });<br/>  console.log(clickedEvent)<br/>}<br/>run();</span></pre><p id="bd7e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们从<code class="fe mt mu mv mj b">eventSchema</code>创建了一个<code class="fe mt mu mv mj b">Event</code>模型。</p><p id="f3a7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它有<code class="fe mt mu mv mj b">discriminatorKey</code>,这样我们就可以区分后来创建的两个文档。</p><p id="aee3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了创建<code class="fe mt mu mv mj b">ClickedLinkEvent</code>模型，我们调用<code class="fe mt mu mv mj b">Event.discriminator</code>通过继承<code class="fe mt mu mv mj b">Event</code>模式来创建模型。</p><p id="44b6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将<code class="fe mt mu mv mj b">url</code>字段添加到<code class="fe mt mu mv mj b">ClickedLinkEvent</code>模型中。</p><p id="e7d7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后当我们将<code class="fe mt mu mv mj b">url</code>添加到<code class="fe mt mu mv mj b">Event</code>文档和<code class="fe mt mu mv mj b">ClickedLinkEvent</code>文档时，只有<code class="fe mt mu mv mj b">clickedEvent</code>对象具有<code class="fe mt mu mv mj b">url</code>属性。</p><p id="3697" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们得到:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="bd6b" class="mn lc iq mj b gy mo mp l mq mr">{ _id: 5f6f78f17f83ca22408eb627, time: 2020-09-26T17:22:57.690Z }</span></pre><p id="be4e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">作为<code class="fe mt mu mv mj b">genericEvent</code>的值，并且:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="2e4d" class="mn lc iq mj b gy mo mp l mq mr">{<br/>  _id: 5f6f78f17f83ca22408eb628,<br/>  kind: 'ClickedLink',<br/>  time: 2020-09-26T17:22:57.697Z,<br/>  url: 'mongodb.com'<br/>}</span></pre><p id="35e1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">作为<code class="fe mt mu mv mj b">clickedEvent</code>的值。</p><h1 id="411a" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">鉴别器保存到模型的集合中</h1><p id="a85c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以一次保存不同种类的事件。</p><p id="b688" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="9cad" class="mn lc iq mj b gy mo mp l mq mr">async function run() {<br/>  const { createConnection, Types, Schema } = require('mongoose');<br/>  const db = createConnection('mongodb://localhost:27017/test');<br/>  const options = { discriminatorKey: 'kind' };</span><span id="d010" class="mn lc iq mj b gy ms mp l mq mr">  const eventSchema = new Schema({ time: Date }, options);<br/>  const Event = db.model('Event', eventSchema);</span><span id="4b22" class="mn lc iq mj b gy ms mp l mq mr">  const ClickedLinkEvent = Event.discriminator('ClickedLink',<br/>    new Schema({ url: String }, options));</span><span id="50ef" class="mn lc iq mj b gy ms mp l mq mr">  const SignedUpEvent = Event.discriminator('SignedUp',<br/>    new Schema({ user: String }, options));</span><span id="8b0c" class="mn lc iq mj b gy ms mp l mq mr">  const event1 = new Event({ time: Date.now() });<br/>  const event2 = new ClickedLinkEvent({ time: Date.now(), url: 'mongodb.com' });<br/>  const event3 = new SignedUpEvent({ time: Date.now(), user: 'mongodbuser' });<br/>  await Promise.all([event1.save(), event2.save(), event3.save()]);<br/>  const count = await Event.countDocuments();<br/>  console.log(count);<br/>}<br/>run();</span></pre><p id="6669" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们创建了一个普通的模式<code class="fe mt mu mv mj b">eventSchema</code>。</p><p id="bd1c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">其余的模型由<code class="fe mt mu mv mj b">Event.discriminator</code>方法创建。</p><p id="6ceb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们创建模型并保存它们。</p><p id="a8de" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们调用<code class="fe mt mu mv mj b">Event.countDocuments</code>来获取在<code class="fe mt mu mv mj b">Event</code>模型下保存的项目数量。</p><p id="ad26" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么<code class="fe mt mu mv mj b">count</code>应该是3，因为<code class="fe mt mu mv mj b">ClickedLinkEvent</code>和<code class="fe mt mu mv mj b">SignedUpEvent</code>都继承自<code class="fe mt mu mv mj b">Event</code>本身。</p><h1 id="8e1d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">鉴别键</h1><p id="84ac" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">默认情况下，我们可以用<code class="fe mt mu mv mj b">__t</code>属性来区分每种类型的模型。</p><p id="b691" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="6f71" class="mn lc iq mj b gy mo mp l mq mr">async function run() {<br/>  const { createConnection, Types, Schema } = require('mongoose');<br/>  const db = createConnection('mongodb://localhost:27017/test');</span><span id="8e43" class="mn lc iq mj b gy ms mp l mq mr">  const eventSchema = new Schema({ time: Date });<br/>  const Event = db.model('Event', eventSchema);</span><span id="c16e" class="mn lc iq mj b gy ms mp l mq mr">  const ClickedLinkEvent = Event.discriminator('ClickedLink',<br/>    new Schema({ url: String }));</span><span id="1e43" class="mn lc iq mj b gy ms mp l mq mr">  const SignedUpEvent = Event.discriminator('SignedUp',<br/>    new Schema({ user: String }));</span><span id="1b79" class="mn lc iq mj b gy ms mp l mq mr">  const event1 = new Event({ time: Date.now() });<br/>  const event2 = new ClickedLinkEvent({ time: Date.now(), url: 'mongodb.com' });<br/>  const event3 = new SignedUpEvent({ time: Date.now(), user: 'mongodbuser' });<br/>  await Promise.all([event1.save(), event2.save(), event3.save()]);<br/>  console.log(event1.__t);<br/>  console.log(event2.__t);<br/>  console.log(event3.__t);<br/>}<br/>run();</span></pre><p id="5697" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">获取控制台日志中保存的数据类型。我们应该得到:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="acc3" class="mn lc iq mj b gy mo mp l mq mr">undefined<br/>ClickedLink<br/>SignedUp</span></pre><p id="4df4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">记录在案。</p><p id="0d7e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以在选项中添加<code class="fe mt mu mv mj b">discriminatorKey</code>来改变鉴别器密钥。</p><p id="e2b4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="ebae" class="mn lc iq mj b gy mo mp l mq mr">async function run() {<br/>  const { createConnection, Types, Schema } = require('mongoose');<br/>  const db = createConnection('mongodb://localhost:27017/test');<br/>  const options = { discriminatorKey: 'kind' };<br/>  const eventSchema = new Schema({ time: Date }, options);<br/>  const Event = db.model('Event', eventSchema);</span><span id="53f4" class="mn lc iq mj b gy ms mp l mq mr">const ClickedLinkEvent = Event.discriminator('ClickedLink',<br/>    new Schema({ url: String }, options));</span><span id="4eb2" class="mn lc iq mj b gy ms mp l mq mr">const SignedUpEvent = Event.discriminator('SignedUp',<br/>    new Schema({ user: String }, options));</span><span id="03bf" class="mn lc iq mj b gy ms mp l mq mr">const event1 = new Event({ time: Date.now() });<br/>  const event2 = new ClickedLinkEvent({ time: Date.now(), url: 'mongodb.com' });<br/>  const event3 = new SignedUpEvent({ time: Date.now(), user: 'mongodbuser' });<br/>  await Promise.all([event1.save(), event2.save(), event3.save()]);<br/>  console.log(event1.kind);<br/>  console.log(event2.kind);<br/>  console.log(event3.kind);<br/>}<br/>run();</span></pre><p id="69f9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为每个模型设置<code class="fe mt mu mv mj b">options</code>,然后访问<code class="fe mt mu mv mj b">kind</code>属性而不是<code class="fe mt mu mv mj b">__t</code>,得到与之前相同的结果。</p><h1 id="f593" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="f022" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用鉴别器通过从一个模型继承另一个模型来创建新的模型。</p></div></div>    
</body>
</html>