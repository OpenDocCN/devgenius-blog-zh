<html>
<head>
<title>Scaling high throughput Writes and Reads</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">扩展高吞吐量读写</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/scaling-high-throughput-writes-and-reads-5599236644bf?source=collection_archive---------20-----------------------#2020-06-24">https://blog.devgenius.io/scaling-high-throughput-writes-and-reads-5599236644bf?source=collection_archive---------20-----------------------#2020-06-24</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="ad1b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">考虑一个系统，其中有一组从系统中读取数据的用户和一组向数据集写入数据的用户。理想情况下，读写扩展在运行时采用不同的配置。</p><p id="ce53" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">扩展通常需要根据用户群的性质对系统进行划分，同时两种性质的系统进行通信，以在可接受的速率下保持实时一致性，同时保持最短的停机时间。</p><p id="7a8c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这篇博文中，我想谈谈有助于解决上述问题的架构概念。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/064be673cc775082c22b1f8b2fd68f72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_MI88npj4jRkAgO1Ndsnnw.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">解决方案:架构图</figcaption></figure><p id="2655" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> GatewayR </strong> -通过读取进行消费的用户的入口点。</p><p id="0a4e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">gateway w</strong>——交易用户的入口点。</p><p id="54bd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> Twemproxy </strong> -每个API虚拟机上的守护进程，帮助将输入数据映射到各自的redis分片。</p><p id="f4d2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> LB- </strong>负载平衡器有助于在多个虚拟机之间分配负载。</p><p id="cf89" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> VMi </strong> —通过在一个负载均衡器下添加多个虚拟机来水平调用API。</p><p id="7315" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">订户</strong> - <em class="ky">纵向和横向扩展</em> <strong class="jm io"> <em class="ky">无状态</em> </strong>虚拟机，这些虚拟机监听来自<em class="ky"> IPC机制</em>的推送事件。它们在保持上述系统的两个部分或一个n分区系统的所有部分的数据<em class="ky">一致</em>方面起着至关重要的作用。</p><h2 id="c14a" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">了解用户的本质——用户可能是多种多样的</h2><p id="ebd6" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated"><strong class="jm io">事务性用户(高吞吐量写入)</strong></p><ul class=""><li id="4b53" class="lx ly in jm b jn jo jr js jv lz jz ma kd mb kh mc md me mf bi translated">这些用户在持久性存储上运行DML和DDL qieries，如PostgresSQL或MySQL</li><li id="7afe" class="lx ly in jm b jn mg jr mh jv mi jz mj kd mk kh mc md me mf bi translated">高吞吐量写入将需要在整个系统中传播更新。单个更新可以触发系统多个部分的更新。</li><li id="b6e1" class="lx ly in jm b jn mg jr mh jv mi jz mj kd mk kh mc md me mf bi translated">这些更新需要接近实时地到达通过阅读消费的用户。</li></ul><p id="7770" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">通过读取进行消费的用户(高吞吐量读取)</strong></p><ul class=""><li id="3b04" class="lx ly in jm b jn jo jr js jv lz jz ma kd mb kh mc md me mf bi translated">需要低延迟高可用性API</li><li id="0074" class="lx ly in jm b jn mg jr mh jv mi jz mj kd mk kh mc md me mf bi translated">近乎实时的读取</li></ul><p id="4a8e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在上图中，这些用户通过架构互不相同的不同区域访问系统资源，分别用蓝色(右上)和粉色(左下)区域表示。</p><p id="09df" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">注意点</strong></p><ul class=""><li id="9488" class="lx ly in jm b jn jo jr js jv lz jz ma kd mb kh mc md me mf bi translated">虽然用户的性质不同，但系统也以类似的方式不同。这保证了需要一个用于生成数据的<strong class="jm io"> <em class="ky">单一真实源</em> </strong>，这也被消耗</li><li id="6ead" class="lx ly in jm b jn mg jr mh jv mi jz mj kd mk kh mc md me mf bi translated">PostegreSQL和MySQL被用作持久性存储，尽管其中一个被配置用于大量的写操作，而另一个被配置用于读操作。</li><li id="bb92" class="lx ly in jm b jn mg jr mh jv mi jz mj kd mk kh mc md me mf bi translated">随着单一来源的真实性而来的是可伸缩性的问题，可用性和分区容忍度会降低。下面解释了为什么MySQL和PostgreSQL被分开使用，并分别为读取和写入形成持久存储。</li></ul><h1 id="ba8c" class="ml la in bd lb mm mn mo le mp mq mr lh ms mt mu lk mv mw mx ln my mz na lq nb bi translated"><strong class="ak">一致性对可用性对分区容忍度</strong></h1><p id="ebb6" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated"><strong class="jm io">一致性</strong></p><ul class=""><li id="dd4e" class="lx ly in jm b jn jo jr js jv lz jz ma kd mb kh mc md me mf bi translated">确保一致性意味着系统中的所有节点同时看到相同的数据。</li></ul><p id="219f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">供货情况</strong></p><ul class=""><li id="cb13" class="lx ly in jm b jn jo jr js jv lz jz ma kd mb kh mc md me mf bi translated">可用性意味着系统响应速度快，正常运行时间长</li></ul><p id="376a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">分区公差</strong></p><ul class=""><li id="045f" class="lx ly in jm b jn jo jr js jv lz jz ma kd mb kh mc md me mf bi translated">虽然这些系统使用IPC进行通信，但是尽管任意的消息丢失或系统的一部分出现故障，系统仍能继续运行。</li><li id="7405" class="lx ly in jm b jn mg jr mh jv mi jz mj kd mk kh mc md me mf bi translated">上述系统具有固有的分区容错能力，因为读取和写入是在两个不同的系统中进行的，并且是单独扩展的。</li></ul><p id="fdce" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">高一致性</strong> —在上述系统中，低延迟内存redis发布/订阅通道，同步更新REDIS集群和MySQL。</p><ul class=""><li id="ff8c" class="lx ly in jm b jn jo jr js jv lz jz ma kd mb kh mc md me mf bi translated">Redis集群有主集群和从集群，这带来了最终的一致性，其中更新通过从集群传播。从模块之间的更新传播时间与从模块的数量、更新吞吐量和处理的数据量成正比。</li><li id="f790" class="lx ly in jm b jn mg jr mh jv mi jz mj kd mk kh mc md me mf bi translated">主redis和从redis的分片将提供可用性和一致性的完美结合</li><li id="0783" class="lx ly in jm b jn mg jr mh jv mi jz mj kd mk kh mc md me mf bi translated">分片可确保数据分布在灵活的集群中，这些集群的单个吞吐量较小，因此需要同步的从机数量较少。从而确保更快的最终一致性</li></ul><p id="b2d0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">高可用性</strong></p><ul class=""><li id="6ae1" class="lx ly in jm b jn jo jr js jv lz jz ma kd mb kh mc md me mf bi translated">从设备之间的复制确保了每个分片redis主设备读取的高可用性。</li></ul><p id="5505" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">高分区容忍度</strong></p><p id="1342" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">高速缓存集群</strong></p><p id="e5cc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">由右下角的棕色圆圈表示</p><ul class=""><li id="e6d7" class="lx ly in jm b jn jo jr js jv lz jz ma kd mb kh mc md me mf bi translated">高速缓存集群包含带从设备的分片主设备，从设备可以在出现故障时重新选择新的主设备，而不会丢失数据。</li><li id="bacb" class="lx ly in jm b jn mg jr mh jv mi jz mj kd mk kh mc md me mf bi translated">分片有助于提高系统的弹性，因为读取和权限分散在多个分片上，系统承受的压力较小</li><li id="7975" class="lx ly in jm b jn mg jr mh jv mi jz mj kd mk kh mc md me mf bi translated">在由于网络故障的情况下，如果一个碎片的更新失败，一个或多个碎片将以陈旧数据结束。使用<a class="ae nc" href="https://medium.com/@kssreesha/debouncing-cache-updates-7c6043864538" rel="noopener"> mutext锁</a>可以处理GatewayR和GatewayW下的多个虚拟机对陈旧数据的更新，而无需冗余更新。</li></ul><p id="f1bb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">PostgreSQL和MySQL之间的数据流</strong></p><ul class=""><li id="6c69" class="lx ly in jm b jn jo jr js jv lz jz ma kd mb kh mc md me mf bi translated">当系统在灾难性故障后恢复时，IPC方法可以包含retrys来帮助更新立即通过系统传播。上面使用的RabbitMQ是一个高度可用的队列，它缓冲来自write APIs的更新，并在网络故障或订户宕机的情况下为重试提供持久性。</li><li id="bd05" class="lx ly in jm b jn mg jr mh jv mi jz mj kd mk kh mc md me mf bi translated">保持<strong class="jm io"> MySQL与PostgreSQL </strong>同步是非常必要的，PostgreSQL是事实的来源，任何网络故障/节点故障都可能导致在<strong class="jm io">网关</strong>消耗的数据与在<strong class="jm io">网关</strong>生成的数据不一致</li></ul><p id="1113" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">实时更新</strong></p><ul class=""><li id="ae6a" class="lx ly in jm b jn jo jr js jv lz jz ma kd mb kh mc md me mf bi translated">随着系统被分成两部分并独立扩展，实时更新需要他们自己的一套系统和扩展程序。在上面的示例中，<strong class="jm io"> <em class="ky">高度可用的内存redis发布-订阅通道</em> </strong>用于将更新近乎实时地传播到缓存集群，而GatwayW的DDL和DML APIs最终将数据更新到PostgreSQL和MySQL。</li><li id="81c5" class="lx ly in jm b jn mg jr mh jv mi jz mj kd mk kh mc md me mf bi translated">进一步<strong class="jm io"> <em class="ky">分割这些通道</em> </strong>，例如按照  <em class="ky"> </em> <strong class="jm io"> <em class="ky">区域</em> </strong>对<strong class="jm io"> <em class="ky">进行分割，可以帮助更好地扩展系统，甚至进一步降低延迟。</em></strong></li><li id="a505" class="lx ly in jm b jn mg jr mh jv mi jz mj kd mk kh mc md me mf bi translated">在GatewayW对PostgreSQL的传入写入将触发通过<strong class="jm io"> <em class="ky"> redis实时内存发布订阅通道的推送，该通道由订阅者使用，订阅者进而近实时更新缓存集群。用户可以在网页刷新时通过GatewayR或通过socket-io事件立即获得此更新。</em></strong></li><li id="796c" class="lx ly in jm b jn mg jr mh jv mi jz mj kd mk kh mc md me mf bi translated">对PostgreSQL的写操作和对Rabbit MQ的数据推送，以及随后对MySQL的写操作最终会通过系统完成，从而确保PostgreSQL和MySQL同步。</li><li id="6f05" class="lx ly in jm b jn mg jr mh jv mi jz mj kd mk kh mc md me mf bi translated">请注意，与RabbitMQ相比，<strong class="jm io"> redis内存发布-订阅事件以<em class="ky">低延迟</em>传播。</strong></li></ul><p id="af06" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">刷新数据</strong></p><p id="a513" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">CRONs】定期运行，保持<em class="ky">两个持久存储同步</em>和<em class="ky">缓存用最新数据更新</em>，是上述系统的关键部分，以防连续网络故障阻止更新从一端传播到另一端。</p></div><div class="ab cl nd ne hr nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ig ih ii ij ik"><p id="de67" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">请关注此空间，了解有关扩展单个器件和所用技术更新的更深入的文章。</p><p id="5857" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我为物联网中的一个用例设计了一个类似的系统——请到https://github.com/SreeshaKS/IOT-Platform<a class="ae nc" href="https://github.com/SreeshaKS/IOT-Platform" rel="noopener ugc nofollow" target="_blank">查看</a></p><p id="e207" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">请在下面的评论中或通过电子邮件向我提出建议和替代方案，并详细说明以上流程。</p><p id="0eac" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">谢谢！</p></div></div>    
</body>
</html>