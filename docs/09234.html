<html>
<head>
<title>Reading and Writing Different Files in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在 Go 中读写不同的文件</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/reading-and-writing-different-files-in-go-9c119edec51a?source=collection_archive---------6-----------------------#2022-08-08">https://blog.devgenius.io/reading-and-writing-different-files-in-go-9c119edec51a?source=collection_archive---------6-----------------------#2022-08-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="9f93" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">读写文件是程序的一个重要特性。并非所有的数据都存储在与程序相同的内存空间中，有时您需要与其他程序共享数据，或者以后用不同的程序查看数据。将数据存储在文件中是实现这些目标的好方法。今天，我们将看看如何读写常用的文件类型。</p><h1 id="19e7" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">io。读者，木卫一。作者</h1><p id="88e2" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">你有没有想过围棋怎么会读写这么多不同的东西？这都要归功于这些强大的接口。<code class="fe ll lm ln lo b">io.Reader</code>描述的是<code class="fe ll lm ln lo b">Read</code>的任何东西，<code class="fe ll lm ln lo b">io.Writer</code>描述的是<code class="fe ll lm ln lo b">Write</code>的任何东西。因为这种行为很容易复制，所以任何实现了<code class="fe ll lm ln lo b">io.Reader</code>和<code class="fe ll lm ln lo b">io.Writer</code>接口的东西都可以用于 I/O 操作。这意味着您可以即插即用不同的输入和输出。您可以从 CSV 文件读取并将其输出到 JSON，或者您可以从<code class="fe ll lm ln lo b">stdin</code>读取并写入 CSV。</p><h1 id="317d" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">战斗支援车</h1><p id="347d" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">CSV 文件由数据行组成，其中每个值由逗号分隔(因此得名逗号分隔值)。CSV 不是读写速度最快的格式，但是它非常通用，可以被许多其他工具理解。</p><h2 id="eaf7" class="lp kj in bd kk lq lr dn ko ls lt dp ks jv lu lv kw jz lw lx la kd ly lz le ma bi translated">阅读</h2><pre class="mb mc md me gt mf lo mg mh aw mi bi"><span id="168a" class="lp kj in lo b gy mj mk l ml mm">package main</span><span id="6590" class="lp kj in lo b gy mn mk l ml mm">import (<br/>    "encoding/csv"<br/>    "fmt"<br/>    "os"<br/>)</span><span id="79fa" class="lp kj in lo b gy mn mk l ml mm">func main() {<br/>    f, err := os.Open("see-es-vee.csv")<br/>    if err != nil {<br/>        fmt.Println(err)<br/>    }<br/>    defer f.Close()</span><span id="50ef" class="lp kj in lo b gy mn mk l ml mm">    r := csv.NewReader(f)</span><span id="05ac" class="lp kj in lo b gy mn mk l ml mm">    records, err := r.ReadAll()<br/>    if err != nil {<br/>        fmt.Println(err)<br/>    }</span><span id="73a9" class="lp kj in lo b gy mn mk l ml mm">    fmt.Println(records)<br/>}</span><span id="98c5" class="lp kj in lo b gy mn mk l ml mm">[[id fruit color taste] [0 apple red sweet] [1 banana yellow sweet] [2 lemon yellow sour] [3 grapefruit red sour]]</span></pre><p id="22fd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里有一个从 CSV 文件中读取数据的非常简单的方法。</p><ul class=""><li id="bab1" class="mo mp in jm b jn jo jr js jv mq jz mr kd ms kh mt mu mv mw bi translated">我们首先打开我们的文件<code class="fe ll lm ln lo b">see-es-vee.csv</code>，并将实例保存为<code class="fe ll lm ln lo b">f</code>。</li><li id="226c" class="mo mp in jm b jn mx jr my jv mz jz na kd nb kh mt mu mv mw bi translated">我们想在完成后关闭<code class="fe ll lm ln lo b">f</code>。这是节省内存的好方法。虽然这是一个很短的程序，而且关闭并不是必须的，但是养成这样做的习惯是有好处的。</li><li id="f286" class="mo mp in jm b jn mx jr my jv mz jz na kd nb kh mt mu mv mw bi translated"><code class="fe ll lm ln lo b">f</code>属于<code class="fe ll lm ln lo b">*os.File</code>类型，它实现了<code class="fe ll lm ln lo b">io.Reader</code>接口。所以我们可以通过<code class="fe ll lm ln lo b">f</code>到<code class="fe ll lm ln lo b">csv.NewReader</code>。</li><li id="d948" class="mo mp in jm b jn mx jr my jv mz jz na kd nb kh mt mu mv mw bi translated">这会返回一个<code class="fe ll lm ln lo b">csv.Reader</code>对象<code class="fe ll lm ln lo b">r</code>。<code class="fe ll lm ln lo b">csv.Reader</code>是<code class="fe ll lm ln lo b">io.Reader</code>的一种，专门读取 CSV 文件。</li><li id="291e" class="mo mp in jm b jn mx jr my jv mz jz na kd nb kh mt mu mv mw bi translated">CSV 文件的每一行被称为一个<em class="nc">记录</em>。因此，我们可以把 CSV 文件看作是记录的切片。<code class="fe ll lm ln lo b">r.ReadAll</code>返回这段记录。</li><li id="27f4" class="mo mp in jm b jn mx jr my jv mz jz na kd nb kh mt mu mv mw bi translated">如果我们打印<code class="fe ll lm ln lo b">records</code>，我们可以看到 2D 切片的行。</li></ul><p id="f19e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这很好，但是如果我们想在阅读时对每个记录应用一些操作呢？幸运的是，我们可以采用更细粒度的方法。</p><pre class="mb mc md me gt mf lo mg mh aw mi bi"><span id="e630" class="lp kj in lo b gy mj mk l ml mm">func main() {<br/>    f, err := os.Open("see-es-vee.csv")<br/>    if err != nil {<br/>        fmt.Println(err)<br/>    }<br/>    defer f.Close()</span><span id="e4e2" class="lp kj in lo b gy mn mk l ml mm">    r := csv.NewReader(f)</span><span id="059b" class="lp kj in lo b gy mn mk l ml mm">    for {<br/>        record, err := r.Read()<br/>        if err != io.EOF {<br/>            break<br/>        }<br/>        if err != nil {<br/>            fmt.Println(err)<br/>        }</span><span id="ff98" class="lp kj in lo b gy mn mk l ml mm">        fmt.Println(record)<br/>    }<br/>}</span></pre><p id="ce5d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">看起来和上面差不多吧？直到创建<code class="fe ll lm ln lo b">r</code>的部分是相同的。让我们看看接下来会发生什么。</p><ul class=""><li id="1009" class="mo mp in jm b jn jo jr js jv mq jz mr kd ms kh mt mu mv mw bi translated">我们进入一个无限 for 循环，因为我们要逐行读取文件，而 Go 不知道文件有多长。</li><li id="c49e" class="mo mp in jm b jn mx jr my jv mz jz na kd nb kh mt mu mv mw bi translated">我们使用<code class="fe ll lm ln lo b">r.Read</code>读取每条记录。</li><li id="ba58" class="mo mp in jm b jn mx jr my jv mz jz na kd nb kh mt mu mv mw bi translated">我们如何知道我们是否到达了文件的末尾？<code class="fe ll lm ln lo b">r.Read</code>返回一个名为<code class="fe ll lm ln lo b">io.EOF</code>的特殊错误。EOF 代表<em class="nc">文件结束</em>。我们首先捕获这个错误，并告诉我们的程序一旦到达末尾就退出 for 循环。</li><li id="2a17" class="mo mp in jm b jn mx jr my jv mz jz na kd nb kh mt mu mv mw bi translated">对于任何其他错误，您可以像平常一样处理它们。</li><li id="473f" class="mo mp in jm b jn mx jr my jv mz jz na kd nb kh mt mu mv mw bi translated">在我们处理错误之后，我们可以对提取的记录做任何我们想做的事情。我能想到的一些想法是大写，舍入，将其与任意值进行比较等。</li></ul><p id="1cc2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在让我们看看如何写入 CSV 文件。</p><pre class="mb mc md me gt mf lo mg mh aw mi bi"><span id="17fc" class="lp kj in lo b gy mj mk l ml mm">package main</span><span id="ebaf" class="lp kj in lo b gy mn mk l ml mm">import (<br/>    "encoding/csv"<br/>    "os"<br/>)</span><span id="81c2" class="lp kj in lo b gy mn mk l ml mm">func main() {<br/>    f, err := os.Create("output.csv")<br/>    if err != nil {<br/>        panic(err)<br/>    }<br/>    defer f.Close()</span><span id="95c9" class="lp kj in lo b gy mn mk l ml mm">    w := csv.NewWriter(f)</span><span id="3d93" class="lp kj in lo b gy mn mk l ml mm">    records := [][]string{<br/>        {"id", "fruit", "color", "taste"},<br/>        {"0", "apple", "red", "sweet"},<br/>        {"1", "banana", "yellow", "sweet"},<br/>        {"2", "lemon", "yellow", "sour"},<br/>        {"3", "grapefruit", "red", "sour"},<br/>    }</span><span id="d5fc" class="lp kj in lo b gy mn mk l ml mm">    w.WriteAll(records)<br/>}</span><span id="d81a" class="lp kj in lo b gy mn mk l ml mm">id,fruit,color,taste<br/>0,apple,red,sweet<br/>1,banana,yellow,sweet<br/>2,lemon,yellow,sour<br/>3,grapefruit,red,sour</span></pre><p id="05ce" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">非常简单明了。</p><ul class=""><li id="6bd6" class="mo mp in jm b jn jo jr js jv mq jz mr kd ms kh mt mu mv mw bi translated">我们首先需要创建一个可以将数据转储到其中的文件。我们将称之为<code class="fe ll lm ln lo b">output.csv</code>。我们只是调用<code class="fe ll lm ln lo b">os.Create</code>，并将它的一个实例保存为<code class="fe ll lm ln lo b">f</code>。</li><li id="9938" class="mo mp in jm b jn mx jr my jv mz jz na kd nb kh mt mu mv mw bi translated">还记得我们之前是如何创建一个<code class="fe ll lm ln lo b">csv.Reader</code>的吗？这里我们正在创建一个<code class="fe ll lm ln lo b">csv.Writer</code>对象<code class="fe ll lm ln lo b">w</code>。<code class="fe ll lm ln lo b">csv.NewWriter</code>接受<code class="fe ll lm ln lo b">io.Writer</code>接口，由<code class="fe ll lm ln lo b">f</code>实现。</li><li id="91c0" class="mo mp in jm b jn mx jr my jv mz jz na kd nb kh mt mu mv mw bi translated">我们把数据准备成字符串的 2D 片段。我们称之为<code class="fe ll lm ln lo b">records</code>。</li><li id="d552" class="mo mp in jm b jn mx jr my jv mz jz na kd nb kh mt mu mv mw bi translated">最后我们只是用<code class="fe ll lm ln lo b">w.WriteAll</code>写<code class="fe ll lm ln lo b">records</code>到<code class="fe ll lm ln lo b">output.csv</code>。</li></ul><h1 id="cc90" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">JSON</h1><p id="b503" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">因为 Go 在 web 服务中被广泛使用，所以它对 JSON 有强大的支持。我写了一整篇关于阅读和编写 JSON 文件的文章，所以请查看这篇文章以获得更深入的指导！</p><h2 id="c029" class="lp kj in bd kk lq lr dn ko ls lt dp ks jv lu lv kw jz lw lx la kd ly lz le ma bi translated">阅读</h2><pre class="mb mc md me gt mf lo mg mh aw mi bi"><span id="a2fb" class="lp kj in lo b gy mj mk l ml mm">package main</span><span id="b601" class="lp kj in lo b gy mn mk l ml mm">import (<br/>    "encoding/json"<br/>    "fmt"<br/>    "os"<br/>)</span><span id="fc1d" class="lp kj in lo b gy mn mk l ml mm">type fruit struct {<br/>    Id    int    `json:"id"`<br/>    Fruit string `json:"fruit"`<br/>    Color string `json:"color"`<br/>    Taste string `json:"taste"`<br/>}</span><span id="0bd8" class="lp kj in lo b gy mn mk l ml mm">func main() {<br/>    f, err := os.Open("jay-son.json")<br/>    if err != nil {<br/>        fmt.Println(err)<br/>    }<br/>    defer f.Close()</span><span id="859a" class="lp kj in lo b gy mn mk l ml mm">    dec := json.NewDecoder(f)</span><span id="f175" class="lp kj in lo b gy mn mk l ml mm">    // read opening bracket<br/>    _, err = dec.Token()<br/>    if err != nil {<br/>        fmt.Println(err)<br/>    }</span><span id="6f0a" class="lp kj in lo b gy mn mk l ml mm">    for dec.More() {<br/>        var fr fruit<br/>        err := dec.Decode(&amp;fr)<br/>        if err != nil {<br/>            fmt.Println(err)<br/>        }</span><span id="a61c" class="lp kj in lo b gy mn mk l ml mm">        fmt.Println(fr)<br/>    }</span><span id="9500" class="lp kj in lo b gy mn mk l ml mm">    // read closing bracket<br/>    _, err = dec.Token()<br/>    if err != nil {<br/>        fmt.Println(err)<br/>    }<br/>}</span><span id="9e6f" class="lp kj in lo b gy mn mk l ml mm">{0 apple red sweet}<br/>{1 banana yellow sweet}<br/>{2 lemon yellow sour}<br/>{3 grapefruit red sour}</span><span id="05f4" class="lp kj in lo b gy mn mk l ml mm">// jay-son.json<br/>[<br/>    {"id": 0, "fruit": "apple", "color": "red", "taste": "sweet"},<br/>    {"id": 1, "fruit": "banana", "color": "yellow", "taste": "sweet"},<br/>    {"id": 2, "fruit": "lemon", "color": "yellow", "taste": "sour"},<br/>    {"id": 3, "fruit": "grapefruit", "color": "red", "taste": "sour"}<br/>]</span></pre><p id="6cc9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里有一个读取 JSON 文件的简单方法。通常，JSONs 是以流的形式出现的。也就是说，它们出现在对象列表中。Go 通过解码器处理数据流。</p><p id="f87d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们先来看看这个:</p><pre class="mb mc md me gt mf lo mg mh aw mi bi"><span id="1345" class="lp kj in lo b gy mj mk l ml mm">type fruit struct {<br/>    Id    int    `json:"id"`<br/>    Fruit string `json:"fruit"`<br/>    Color string `json:"color"`<br/>    Taste string `json:"taste"`<br/>}</span></pre><p id="3f44" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个结构作为一个模型。因为 JSON 可以有各种形状和大小，所以理想情况下，您希望有一个反映 JSON 结构的模型。struct 字段需要是公共的，并且应该在右边有一个标记，表示它所引用的键。如果你事先不知道 JSON 会是什么样子，Go 只会用一个<code class="fe ll lm ln lo b">map[string]interface{}</code>。</p><ul class=""><li id="5157" class="mo mp in jm b jn jo jr js jv mq jz mr kd ms kh mt mu mv mw bi translated">首先，我们打开文件并将它的实例保存到<code class="fe ll lm ln lo b">f</code>。不要忘记推迟来电，以便稍后关闭<code class="fe ll lm ln lo b">f</code>！</li><li id="e72f" class="mo mp in jm b jn mx jr my jv mz jz na kd nb kh mt mu mv mw bi translated">我们使用<code class="fe ll lm ln lo b">json.NewDecoder</code>创建我们的解码器对象<code class="fe ll lm ln lo b">dec</code>。就像<code class="fe ll lm ln lo b">csv.NewReader</code>一样，它接受一个<code class="fe ll lm ln lo b">io.Reader</code>。您可以开始看到接口的力量——读取的细节被抽象出来，并且读取的工作流在如此多的不同文件类型中是一致的。</li><li id="d352" class="mo mp in jm b jn mx jr my jv mz jz na kd nb kh mt mu mv mw bi translated">一旦<code class="fe ll lm ln lo b">dec</code>被创建，我们就可以读取我们的 JSON 了。不过，只有一个问题。我们需要确保使用<code class="fe ll lm ln lo b">dec.Token</code>来捕捉开括号和闭括号。不这样做就像试图吃一个包装纸还在的赛百味三明治。糟糕。</li><li id="45ee" class="mo mp in jm b jn mx jr my jv mz jz na kd nb kh mt mu mv mw bi translated">就像我们一行一行地读取 CSV 文件一样，我们一个对象一个对象地读取 JSON 流。我们循环遍历<code class="fe ll lm ln lo b">dec.More</code>，只要还有对象需要读取，就会返回<code class="fe ll lm ln lo b">true</code>。</li><li id="3311" class="mo mp in jm b jn mx jr my jv mz jz na kd nb kh mt mu mv mw bi translated">我们创建了一个<code class="fe ll lm ln lo b">fruit</code>的实例来存储我们对象的数据。使用<code class="fe ll lm ln lo b">dec.Decode</code>将对象数据转储到<code class="fe ll lm ln lo b">f</code>。你现在可以做你想做的事了。</li><li id="63d0" class="mo mp in jm b jn mx jr my jv mz jz na kd nb kh mt mu mv mw bi translated">读完之后，一定要抓住右括号。</li></ul><h2 id="ebfa" class="lp kj in bd kk lq lr dn ko ls lt dp ks jv lu lv kw jz lw lx la kd ly lz le ma bi translated">写作</h2><p id="8366" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">写入 JSON 文件也很简单。我们称之为<em class="nc">编码</em>。</p><pre class="mb mc md me gt mf lo mg mh aw mi bi"><span id="87ba" class="lp kj in lo b gy mj mk l ml mm">package main</span><span id="2cd7" class="lp kj in lo b gy mn mk l ml mm">import (<br/>    "encoding/json"<br/>    "fmt"<br/>    "os"<br/>)</span><span id="1bb0" class="lp kj in lo b gy mn mk l ml mm">type Fruit struct {<br/>    Id    int    `json:"id"`<br/>    Fruit string `json:"fruit"`<br/>    Color string `json:"color"`<br/>    Taste string `json:"taste"`<br/>}</span><span id="e1bc" class="lp kj in lo b gy mn mk l ml mm">func main() {<br/>    f, err := os.Create("output.json")<br/>    if err != nil {<br/>        panic(err)<br/>    }<br/>    defer f.Close()</span><span id="1c7c" class="lp kj in lo b gy mn mk l ml mm">    enc := json.NewEncoder(f)</span><span id="7bf0" class="lp kj in lo b gy mn mk l ml mm">    apple := Fruit{Id: 0, Fruit: "apple", Color: "red", Taste: "sweet"}<br/>    banana := Fruit{Id: 1, Fruit: "banana", Color: "yellow", Taste: "sweet"}<br/>    lemon := Fruit{Id: 2, Fruit: "lemon", Color: "yellow", Taste: "sour"}<br/>    grapefruit := Fruit{Id: 3, Fruit: "grapefruit", Color: "red", Taste: "sour"}</span><span id="b5ef" class="lp kj in lo b gy mn mk l ml mm">    fruits := []Fruit{apple, banana, lemon, grapefruit}</span><span id="824c" class="lp kj in lo b gy mn mk l ml mm">    err = enc.Encode(fruits)<br/>    if err != nil {<br/>        fmt.Println(err)<br/>    }<br/>}</span><span id="0b08" class="lp kj in lo b gy mn mk l ml mm">[{"id":0,"fruit":"apple","color":"red","taste":"sweet"},{"id":1,"fruit":"banana","color":"yellow","taste":"sweet"},{"id":2,"fruit":"lemon","color":"yellow","taste":"sour"},{"id":3,"fruit":"grapefruit","color":"red","taste":"sour"}]</span></pre><p id="fd58" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个也很简单。</p><ul class=""><li id="13b7" class="mo mp in jm b jn jo jr js jv mq jz mr kd ms kh mt mu mv mw bi translated">我们创建一个名为<code class="fe ll lm ln lo b">output.json</code>的文件，将数据转储到其中。</li><li id="a4b5" class="mo mp in jm b jn mx jr my jv mz jz na kd nb kh mt mu mv mw bi translated">我们通过使用<code class="fe ll lm ln lo b">json.NewEncoder</code>创建一个新的编码器<code class="fe ll lm ln lo b">enc</code>。</li><li id="15f2" class="mo mp in jm b jn mx jr my jv mz jz na kd nb kh mt mu mv mw bi translated">我们准备我们的数据，它是<code class="fe ll lm ln lo b">Fruit</code>对象的一部分。</li><li id="0e04" class="mo mp in jm b jn mx jr my jv mz jz na kd nb kh mt mu mv mw bi translated">最后，我们使用<code class="fe ll lm ln lo b">enc.Encode</code>对这个切片进行编码。</li></ul><h1 id="3831" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">擅长</h1><p id="bc97" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">Go 默认不支持读写 Excel 文件。然而，有一个叫做<code class="fe ll lm ln lo b">qax-os/excelize</code>的流行库可以帮助你做到这一点。如果把源代码拆开，可以看到这个包大量使用了<code class="fe ll lm ln lo b">*os.File</code>，也是一个<code class="fe ll lm ln lo b">io.Reader</code>和<code class="fe ll lm ln lo b">io.Writer</code>。我认为这展示了<code class="fe ll lm ln lo b">io.Reader</code>和<code class="fe ll lm ln lo b">io.Writer</code>接口的美妙之处，因为稍加调整，你就可以定制实现这些接口的阅读器和编写器，允许你支持更多的文件类型。</p><h1 id="8302" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">结论</h1><p id="c340" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">希望这篇文章可以快速介绍在 Go 中读写文件，以及<code class="fe ll lm ln lo b">io.Reader</code>和<code class="fe ll lm ln lo b">io.Writer</code>接口有多强大。我认为这是 Go 的魅力之一——界面允许非常灵活和可重用的代码。当然，还有更多文件我们没有在这篇文章中讨论，但是总的要点是一样的:打开文件，创建一个阅读器或写入器，并从中读/写。谢谢大家！</p><p id="e8c3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你也可以在<a class="ae nd" href="https://dev.to/jpoly1219/reading-and-writing-different-files-in-go-4m3i" rel="noopener ugc nofollow" target="_blank"> Dev.to </a>和<a class="ae nd" href="https://jpoly1219.github.io" rel="noopener ugc nofollow" target="_blank">我的个人网站</a>上阅读这篇文章。</p></div></div>    
</body>
</html>