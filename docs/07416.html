<html>
<head>
<title>Apache ShardingSphere-Proxy Performance with PostgreSQL is Improved 26.8% with Version 5.1.0</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Apache sharding sphere-PostgreSQL 的代理性能在版本 5.1.0 中提高了 26.8%</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/shardingsphere-proxy-performance-with-postgresql-is-improved-26-8-with-version-5-1-0-432f6bf9e077?source=collection_archive---------5-----------------------#2022-03-23">https://blog.devgenius.io/shardingsphere-proxy-performance-with-postgresql-is-improved-26-8-with-version-5-1-0-432f6bf9e077?source=collection_archive---------5-----------------------#2022-03-23</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="27e8" class="pw-post-body-paragraph jm jn in jo b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj ig bi translated">各行各业对 Apache ShardingSphere 的采用越来越多，这使得我们的社区能够收到对我们最新版本的宝贵反馈。</p><p id="8bdb" class="pw-post-body-paragraph jm jn in jo b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj ig bi translated">我们的团队对 ShardingSphere 内核、接口等进行了大量的性能优化。自从 5.0.0 版本发布以来。本文介绍了一些代码级的性能优化，并展示了 ShardingSphere-Proxy TPC-C 基准测试的优化结果。</p><h1 id="b25e" class="kk kl in bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">最佳化</h1><h2 id="4a15" class="li kl in bd km lj lk dn kq ll lm dp ku jx ln lo ky kb lp lq lc kf lr ls lg lt bi translated">纠正可选的使用</h2><p id="a2ab" class="pw-post-body-paragraph jm jn in jo b jp lu jr js jt lv jv jw jx lw jz ka kb lx kd ke kf ly kh ki kj ig bi translated"><code class="fe lz ma mb mc b">java.util.Optional</code>，由 Java 8 引入，它使代码更干净。例如，它可以避免方法返回<code class="fe lz ma mb mc b">null</code>值。<code class="fe lz ma mb mc b">Optional</code>常用于两种情况:</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="756c" class="li kl in mc b gy ml mm l mn mo">public T orElse(T other) {</span><span id="3540" class="li kl in mc b gy mp mm l mn mo">return value != null ? value : other;</span><span id="b045" class="li kl in mc b gy mp mm l mn mo">}<br/></span><span id="d701" class="li kl in mc b gy mp mm l mn mo">public T orElseGet(Supplier&lt;? extends T&gt; other) {</span><span id="95af" class="li kl in mc b gy mp mm l mn mo">return value != null ? value : other.get();</span><span id="6946" class="li kl in mc b gy mp mm l mn mo">}</span></pre><p id="e085" class="pw-post-body-paragraph jm jn in jo b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj ig bi translated">在 ShardingSphere 项目<code class="fe lz ma mb mc b">org.apache.shardingsphere.infra.binder.segment.select.orderby.engine.OrderByContextEngine</code>中，一个<code class="fe lz ma mb mc b">Optional</code>代码被用作:</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="58c5" class="li kl in mc b gy ml mm l mn mo">Optional&lt;OrderByContext&gt; result = // Omit codes...</span><span id="fa1d" class="li kl in mc b gy mp mm l mn mo">return result.orElse(getDefaultOrderByContextWithoutOrderBy(groupByContext));</span></pre><p id="c431" class="pw-post-body-paragraph jm jn in jo b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj ig bi translated">在上面的<code class="fe lz ma mb mc b">orElse</code>语句中，即使结果不为空，也会调用<code class="fe lz ma mb mc b">orElse</code>方法。如果<code class="fe lz ma mb mc b">orElse</code>方法涉及修改操作，可能会发生事故。在方法调用的情况下，应该相应地调整语句:</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="2559" class="li kl in mc b gy ml mm l mn mo">Optional&lt;OrderByContext&gt; result = // Omit codes...</span><span id="f407" class="li kl in mc b gy mp mm l mn mo">return result.orElseGet(() -&gt; getDefaultOrderByContextWithoutOrderBy(groupByContext));</span></pre><p id="16f0" class="pw-post-body-paragraph jm jn in jo b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj ig bi translated">λ用于提供一个<code class="fe lz ma mb mc b">Supplier</code>到<code class="fe lz ma mb mc b">orElseGet</code>。这样，只有当结果为空时，才会调用<code class="fe lz ma mb mc b">orElseGet</code>方法。</p><blockquote class="mq mr ms"><p id="48a7" class="jm jn mt jo b jp jq jr js jt ju jv jw mu jy jz ka mv kc kd ke mw kg kh ki kj ig bi translated"><strong class="jo io">相关公关:</strong>【https://github.com/apache/shardingsphere/pull/11459/files】T21</p></blockquote><h2 id="73d2" class="li kl in bd km lj lk dn kq ll lm dp ku jx ln lo ky kb lp lq lc kf lr ls lg lt bi translated">避免频繁并发调用 Java 8 ConcurrentHashMap 的 computeIfAbsent</h2><p id="f54b" class="pw-post-body-paragraph jm jn in jo b jp lu jr js jt lv jv jw jx lw jz ka kb lx kd ke kf ly kh ki kj ig bi translated"><code class="fe lz ma mb mc b">java.util.concurrent.ConcurrentHashMap</code>常用于并发情况。与用<code class="fe lz ma mb mc b">synchronized</code>修改所有操作的<code class="fe lz ma mb mc b">java.util.Hashtable</code>相比，<code class="fe lz ma mb mc b">ConcurrentHashMap</code>可以在保证线程安全的同时提供更好的性能。</p><p id="366a" class="pw-post-body-paragraph jm jn in jo b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj ig bi translated">然而，在 Java 8 实现中，即使键存在，<code class="fe lz ma mb mc b">ConcurrentHashMap </code>的方法<code class="fe lz ma mb mc b">computeIfAbsent</code>仍然检索<code class="fe lz ma mb mc b">synchronized</code>代码片段中的值。同一个键频繁调用<code class="fe lz ma mb mc b">computeIfAbsent</code>会极大地损害并发性能。</p><blockquote class="mq mr ms"><p id="c729" class="jm jn mt jo b jp jq jr js jt ju jv jw mu jy jz ka mv kc kd ke mw kg kh ki kj ig bi translated"><strong class="jo io">参考:</strong>T17】https://bugs.openjdk.java.net/browse/JDK-8161372</p></blockquote><p id="a23e" class="pw-post-body-paragraph jm jn in jo b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj ig bi translated">这个问题在 Java 9 中已经解决了。然而，为了避免这个问题并确保 Java 8 中的并发性能，我们调整了 ShardingSphere 代码中的语法。</p><p id="61e4" class="pw-post-body-paragraph jm jn in jo b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj ig bi translated">以一个经常被调用的 ShardingSphere 类<code class="fe lz ma mb mc b">org.apache.shardingsphere.infra.executor.sql.prepare.driver.DriverExecutionPrepareEngine</code>为例:</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="e4a1" class="li kl in mc b gy ml mm l mn mo">// Omit some codes...</span><span id="53c5" class="li kl in mc b gy mp mm l mn mo">private static final Map&lt;String, SQLExecutionUnitBuilder&gt; TYPE_TO_BUILDER_MAP = new ConcurrentHashMap&lt;&gt;(8, 1);</span><span id="44bc" class="li kl in mc b gy mp mm l mn mo">// Omit some codes...</span><span id="a40e" class="li kl in mc b gy mp mm l mn mo">public DriverExecutionPrepareEngine(final String type, final int maxConnectionsSizePerQuery, final ExecutorDriverManager&lt;C, ?, ?&gt; executorDriverManager,</span><span id="51ec" class="li kl in mc b gy mp mm l mn mo">final StorageResourceOption option, final Collection&lt;ShardingSphereRule&gt; rules) {</span><span id="e077" class="li kl in mc b gy mp mm l mn mo">super(maxConnectionsSizePerQuery, rules);</span><span id="3dfc" class="li kl in mc b gy mp mm l mn mo">this.executorDriverManager = executorDriverManager;</span><span id="b38f" class="li kl in mc b gy mp mm l mn mo">this.option = option;</span><span id="5020" class="li kl in mc b gy mp mm l mn mo">sqlExecutionUnitBuilder = TYPE_TO_BUILDER_MAP.computeIfAbsent(type,</span><span id="5778" class="li kl in mc b gy mp mm l mn mo">key -&gt; TypedSPIRegistry.getRegisteredService(SQLExecutionUnitBuilder.class, key, new Properties()));</span><span id="3bd1" class="li kl in mc b gy mp mm l mn mo">}</span></pre><p id="fcc6" class="pw-post-body-paragraph jm jn in jo b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj ig bi translated">在上面的代码中，只有两个<code class="fe lz ma mb mc b">type</code>会被传入<code class="fe lz ma mb mc b">computeIfAbsent</code>，大多数 SQL 执行都必须采用这个代码。这样一来，就会出现同一个键频繁并发调用<code class="fe lz ma mb mc b">computeIfAbsent</code>的情况，阻碍并发性能。采用以下方法来避免这个问题:</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="3a01" class="li kl in mc b gy ml mm l mn mo">SQLExecutionUnitBuilder result;</span><span id="c4e9" class="li kl in mc b gy mp mm l mn mo">if (null == (result = TYPE_TO_BUILDER_MAP.get(type))) {</span><span id="9d63" class="li kl in mc b gy mp mm l mn mo">result = TYPE_TO_BUILDER_MAP.computeIfAbsent(type, key -&gt; TypedSPIRegistry.getRegisteredService(SQLExecutionUnitBuilder.class, key, new Properties()));</span><span id="7575" class="li kl in mc b gy mp mm l mn mo">}</span><span id="d2ff" class="li kl in mc b gy mp mm l mn mo">return result;</span></pre><blockquote class="mq mr ms"><p id="6d50" class="jm jn mt jo b jp jq jr js jt ju jv jw mu jy jz ka mv kc kd ke mw kg kh ki kj ig bi translated"><strong class="jo io">相关公关:</strong>【https://github.com/apache/shardingsphere/pull/13275/files】T21</p></blockquote><h2 id="62de" class="li kl in bd km lj lk dn kq ll lm dp ku jx ln lo ky kb lp lq lc kf lr ls lg lt bi translated">避免频繁调用 java.util.Properties</h2><p id="ab97" class="pw-post-body-paragraph jm jn in jo b jp lu jr js jt lv jv jw jx lw jz ka kb lx kd ke kf ly kh ki kj ig bi translated"><code class="fe lz ma mb mc b">java.util.Properties</code>是一个常用的 ShardingSphere 配置类。<code class="fe lz ma mb mc b">Properties</code>继承了<code class="fe lz ma mb mc b">java.util.Hashtable</code>，因此需要避免在并发情况下频繁调用<code class="fe lz ma mb mc b">Properties</code>。</p><p id="727e" class="pw-post-body-paragraph jm jn in jo b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj ig bi translated">我们发现<code class="fe lz ma mb mc b">org.apache.shardingsphere.sharding.algorithm.sharding.inline.InlineShardingAlgorithm</code>中有一个逻辑频繁调用<code class="fe lz ma mb mc b">getProperty</code>，一个 ShardingSphere 数据分片类，导致并发性能受限。为了解决这个问题，我们把调用<code class="fe lz ma mb mc b">Properties</code>的逻辑放在了<code class="fe lz ma mb mc b">InlineShardingAlgorithm</code>的<code class="fe lz ma mb mc b">init</code>下面，避免了分片算法中并发性能的计算。</p><blockquote class="mq mr ms"><p id="640c" class="jm jn mt jo b jp jq jr js jt ju jv jw mu jy jz ka mv kc kd ke mw kg kh ki kj ig bi translated"><strong class="jo io">相关公关:</strong><a class="ae mx" href="https://github.com/apache/shardingsphere/pull/13282/files" rel="noopener ugc nofollow" target="_blank">https://github.com/apache/shardingsphere/pull/13282/files</a></p></blockquote><h2 id="0b18" class="li kl in bd km lj lk dn kq ll lm dp ku jx ln lo ky kb lp lq lc kf lr ls lg lt bi translated">避免使用集合。synchronizedMap</h2><p id="a8c9" class="pw-post-body-paragraph jm jn in jo b jp lu jr js jt lv jv jw jx lw jz ka kb lx kd ke kf ly kh ki kj ig bi translated">在检查 ShardingSphere 的监视器阻塞时，我们在<code class="fe lz ma mb mc b">org.apache.shardingsphere.infra.metadata.schema.model.TableMetaData</code>中发现了一个被频繁调用的 Map，它被<code class="fe lz ma mb mc b">Collections.synchronizedMap</code>修改。</p><p id="21a8" class="pw-post-body-paragraph jm jn in jo b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj ig bi translated">这会影响并发性能。修改操作只存在于修改地图的初始阶段，其余都是读取操作，因此，<code class="fe lz ma mb mc b">Collections.synchronizedMap</code>修改方法可以直接删除。</p><blockquote class="mq mr ms"><p id="d99a" class="jm jn mt jo b jp jq jr js jt ju jv jw mu jy jz ka mv kc kd ke mw kg kh ki kj ig bi translated"><strong class="jo io">相关公关:</strong><a class="ae mx" href="https://github.com/apache/shardingsphere/pull/13264/files" rel="noopener ugc nofollow" target="_blank">https://github.com/apache/shardingsphere/pull/13264/files</a></p></blockquote><h2 id="23a5" class="li kl in bd km lj lk dn kq ll lm dp ku jx ln lo ky kb lp lq lc kf lr ls lg lt bi translated">用字符串串联替换不必要的 String.format</h2><p id="3ce3" class="pw-post-body-paragraph jm jn in jo b jp lu jr js jt lv jv jw jx lw jz ka kb lx kd ke kf ly kh ki kj ig bi translated">那里的 ShardingSphere 项目<code class="fe lz ma mb mc b">org.apache.shardingsphere.sql.parser.sql.common.constant.QuoteCharacter </code>有如下逻辑:</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="1340" class="li kl in mc b gy ml mm l mn mo">public String wrap(final String value) {</span><span id="70ec" class="li kl in mc b gy mp mm l mn mo">return String.format("%s%s%s", startDelimiter, value, endDelimiter);</span><span id="1361" class="li kl in mc b gy mp mm l mn mo">}</span></pre><p id="9bcf" class="pw-post-body-paragraph jm jn in jo b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj ig bi translated">上面的逻辑显然是一个字符串连接，但是使用<code class="fe lz ma mb mc b">String.format</code>意味着它比直接的字符串连接花费更多。调整如下:</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="571d" class="li kl in mc b gy ml mm l mn mo">public String wrap(final String value) {</span><span id="9d44" class="li kl in mc b gy mp mm l mn mo">return startDelimiter + value + endDelimiter;</span><span id="707a" class="li kl in mc b gy mp mm l mn mo">}</span></pre><p id="0294" class="pw-post-body-paragraph jm jn in jo b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj ig bi translated">我们用 JMH 做一个简单的测试。以下是测试结果:</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="521b" class="li kl in mc b gy ml mm l mn mo"># JMH version: 1.33</span><span id="97f6" class="li kl in mc b gy mp mm l mn mo"># VM version: JDK 17.0.1, Java HotSpot(TM) 64-Bit Server VM, 17.0.1+12-LTS-39</span><span id="00c1" class="li kl in mc b gy mp mm l mn mo"># Blackhole mode: full + dont-inline hint (default, use -Djmh.blackhole.autoDetect=true to auto-detect)</span><span id="0744" class="li kl in mc b gy mp mm l mn mo"># Warmup: 3 iterations, 5 s each</span><span id="c48e" class="li kl in mc b gy mp mm l mn mo"># Measurement: 3 iterations, 5 s each</span><span id="f469" class="li kl in mc b gy mp mm l mn mo"># Timeout: 10 min per iteration</span><span id="ac20" class="li kl in mc b gy mp mm l mn mo"># Threads: 16 threads, will synchronize iterations</span><span id="9969" class="li kl in mc b gy mp mm l mn mo"># Benchmark mode: Throughput, ops/time</span><span id="7cc1" class="li kl in mc b gy mp mm l mn mo">Benchmark                           Mode  Cnt          Score         Error  Units</span><span id="3186" class="li kl in mc b gy mp mm l mn mo">StringConcatBenchmark.benchFormat  thrpt    9   28490416.644 ± 1377409.528  ops/s</span><span id="066e" class="li kl in mc b gy mp mm l mn mo">StringConcatBenchmark.benchPlus    thrpt    9  163475708.153 ± 1748461.858  ops/s</span></pre><p id="24fc" class="pw-post-body-paragraph jm jn in jo b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj ig bi translated">很明显，<code class="fe lz ma mb mc b">String.format</code>比<code class="fe lz ma mb mc b">+</code>字符串连接的成本更高，而且自 Java 9 以来，直接字符串连接的性能已经得到了优化。这显示了选择正确的字符串连接方法的重要性。</p><blockquote class="mq mr ms"><p id="1d65" class="jm jn mt jo b jp jq jr js jt ju jv jw mu jy jz ka mv kc kd ke mw kg kh ki kj ig bi translated"><strong class="jo io">相关公关:</strong><a class="ae mx" href="https://github.com/apache/shardingsphere/pull/11291/files" rel="noopener ugc nofollow" target="_blank">https://github.com/apache/shardingsphere/pull/11291/files</a></p></blockquote><h2 id="fb66" class="li kl in bd km lj lk dn kq ll lm dp ku jx ln lo ky kb lp lq lc kf lr ls lg lt bi translated">用 For-each 替换频繁流</h2><p id="f872" class="pw-post-body-paragraph jm jn in jo b jp lu jr js jt lv jv jw jx lw jz ka kb lx kd ke kf ly kh ki kj ig bi translated"><code class="fe lz ma mb mc b">java.util.stream.Stream</code>频繁出现在 ShardingSphere 5 中。x 的代码。</p><p id="2e14" class="pw-post-body-paragraph jm jn in jo b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj ig bi translated">在之前的 benchmark SQL(TPC-C test for Java implementation)压力测试— ShardingSphere-JDBC + openGauss 性能测试中，我们发现当所有的频繁流都被替换为<code class="fe lz ma mb mc b">for-each</code>时，ShardingSphere-JDBC 的性能有了显著的提升。</p><figure class="md me mf mg gt mz gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi my"><img src="../Images/49e851f3022af028643155340f210407.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*N-ZZqFzdEiYrwwfK"/></div></div></figure><blockquote class="mq mr ms"><p id="ae25" class="jm jn mt jo b jp jq jr js jt ju jv jw mu jy jz ka mv kc kd ke mw kg kh ki kj ig bi translated"><strong class="jo io">注</strong> :ShardingSphere-JDBC 和 openGauss 在两台独立的 128 核 aarch64 机器上，使用毕昇 JDK 8。</p></blockquote><p id="f509" class="pw-post-body-paragraph jm jn in jo b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj ig bi translated">上面的测试结果可能与 aarch64 和 JDK 有关，但流本身确实会带来一些开销，并且在不同的场景下，性能会有很大的差异。我们推荐<code class="fe lz ma mb mc b">for-each</code>用于那些被频繁调用且不确定其性能是否可以通过 steam 进行优化的逻辑。</p><blockquote class="mq mr ms"><p id="8b4c" class="jm jn mt jo b jp jq jr js jt ju jv jw mu jy jz ka mv kc kd ke mw kg kh ki kj ig bi translated"><strong class="jo io">相关公关:</strong><a class="ae mx" href="https://github.com/apache/shardingsphere/pull/13845/files" rel="noopener ugc nofollow" target="_blank">https://github.com/apache/shardingsphere/pull/13845/files</a></p></blockquote><h2 id="5450" class="li kl in bd km lj lk dn kq ll lm dp ku jx ln lo ky kb lp lq lc kf lr ls lg lt bi translated">避免不必要的逻辑(重复)调用</h2><p id="c26a" class="pw-post-body-paragraph jm jn in jo b jp lu jr js jt lv jv jw jx lw jz ka kb lx kd ke kf ly kh ki kj ig bi translated">在许多情况下，避免不必要的逻辑重复调用:</p><blockquote class="mq mr ms"><p id="6c97" class="jm jn mt jo b jp jq jr js jt ju jv jw mu jy jz ka mv kc kd ke mw kg kh ki kj ig bi translated"><em class="in">哈希码计算</em></p></blockquote><p id="1e3e" class="pw-post-body-paragraph jm jn in jo b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj ig bi translated">ShardingSphere 类<code class="fe lz ma mb mc b">org.apache.shardingsphere.sharding.route.engine.condition.Column</code>实现了<code class="fe lz ma mb mc b">equals</code>和<code class="fe lz ma mb mc b">hashCode</code>方法:</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="2f96" class="li kl in mc b gy ml mm l mn mo">@RequiredArgsConstructor</span><span id="dba6" class="li kl in mc b gy mp mm l mn mo">@Getter</span><span id="e65c" class="li kl in mc b gy mp mm l mn mo">@ToString</span><span id="e728" class="li kl in mc b gy mp mm l mn mo">public final class Column {</span><span id="0038" class="li kl in mc b gy mp mm l mn mo">private final String name;</span><span id="d5d6" class="li kl in mc b gy mp mm l mn mo">private final String tableName;</span><span id="cf06" class="li kl in mc b gy mp mm l mn mo">@Override</span><span id="01ca" class="li kl in mc b gy mp mm l mn mo">public boolean equals(final Object obj) {...}</span><span id="7f83" class="li kl in mc b gy mp mm l mn mo">@Override</span><span id="c293" class="li kl in mc b gy mp mm l mn mo">public int hashCode() {</span><span id="4d08" class="li kl in mc b gy mp mm l mn mo">return Objects.hashCode(name.toUpperCase(), tableName.toUpperCase());</span><span id="c5ed" class="li kl in mc b gy mp mm l mn mo">}</span><span id="9248" class="li kl in mc b gy mp mm l mn mo">}</span></pre><p id="69e1" class="pw-post-body-paragraph jm jn in jo b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj ig bi translated">显然，上面的类是不可更改的，但它在<code class="fe lz ma mb mc b">hashCode</code>实现中每次都计算<code class="fe lz ma mb mc b">hashCode</code>。如果实例频繁放入或退出<code class="fe lz ma mb mc b">Map</code>或<code class="fe lz ma mb mc b">Set</code>，会造成很多不必要的计算开销。</p><p id="f8f8" class="pw-post-body-paragraph jm jn in jo b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj ig bi translated">调整后:</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="14e7" class="li kl in mc b gy ml mm l mn mo">@Getter</span><span id="2a81" class="li kl in mc b gy mp mm l mn mo">@ToString</span><span id="ffdc" class="li kl in mc b gy mp mm l mn mo">public final class Column {</span><span id="8c99" class="li kl in mc b gy mp mm l mn mo">private final String name;</span><span id="1587" class="li kl in mc b gy mp mm l mn mo">private final String tableName;</span><span id="9379" class="li kl in mc b gy mp mm l mn mo">private final int hashCode;</span><span id="05f1" class="li kl in mc b gy mp mm l mn mo">public Column(final String name, final String tableName) {</span><span id="facc" class="li kl in mc b gy mp mm l mn mo">this.name = name;</span><span id="c2d0" class="li kl in mc b gy mp mm l mn mo">this.tableName = tableName;</span><span id="3c30" class="li kl in mc b gy mp mm l mn mo">hashCode = Objects.hash(name.toUpperCase(), tableName.toUpperCase());</span><span id="19b4" class="li kl in mc b gy mp mm l mn mo">}</span><span id="1681" class="li kl in mc b gy mp mm l mn mo">@Override</span><span id="94b9" class="li kl in mc b gy mp mm l mn mo">public boolean equals(final Object obj) {...}</span><span id="0c1a" class="li kl in mc b gy mp mm l mn mo">@Override</span><span id="01c8" class="li kl in mc b gy mp mm l mn mo">public int hashCode() {</span><span id="b59d" class="li kl in mc b gy mp mm l mn mo">return hashCode;</span><span id="b63a" class="li kl in mc b gy mp mm l mn mo">}</span><span id="28a3" class="li kl in mc b gy mp mm l mn mo">}</span></pre><blockquote class="mq mr ms"><p id="0342" class="jm jn mt jo b jp jq jr js jt ju jv jw mu jy jz ka mv kc kd ke mw kg kh ki kj ig bi translated"><strong class="jo io">相关公关:</strong><a class="ae mx" href="https://github.com/apache/shardingsphere/pull/11760/files" rel="noopener ugc nofollow" target="_blank">https://github.com/apache/shardingsphere/pull/11760/files</a></p></blockquote><h2 id="d1f4" class="li kl in bd km lj lk dn kq ll lm dp ku jx ln lo ky kb lp lq lc kf lr ls lg lt bi translated">用 Lambda 替换反射调用</h2><p id="2bef" class="pw-post-body-paragraph jm jn in jo b jp lu jr js jt lv jv jw jx lw jz ka kb lx kd ke kf ly kh ki kj ig bi translated">在 ShardingSphere 的源代码中，以下场景要求您记录方法和参数调用，并在需要时重放对目标的方法调用。</p><ol class=""><li id="0283" class="ng nh in jo b jp jq jt ju jx ni kb nj kf nk kj nl nm nn no bi translated">向 ShardingSphere-Proxy 发送<code class="fe lz ma mb mc b">begin</code>和其他语法。</li><li id="7f57" class="ng nh in jo b jp np jt nq jx nr kb ns kf nt kj nl nm nn no bi translated">使用<code class="fe lz ma mb mc b">ShardingSpherePreparedStatement</code>为特定位置设置占位符参数。</li></ol><p id="6e2a" class="pw-post-body-paragraph jm jn in jo b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj ig bi translated">以下面的代码为例。在重构之前，它使用反射来记录方法调用和重放。反射调用方法需要一些开销，并且代码缺乏可读性。</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="ac91" class="li kl in mc b gy ml mm l mn mo">@Override</span><span id="99d9" class="li kl in mc b gy mp mm l mn mo">public void begin() {</span><span id="036f" class="li kl in mc b gy mp mm l mn mo">recordMethodInvocation(Connection.class, "setAutoCommit", new Class[]{boolean.class}, new Object[]{false});</span><span id="f7cb" class="li kl in mc b gy mp mm l mn mo">}</span></pre><p id="f156" class="pw-post-body-paragraph jm jn in jo b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj ig bi translated">在重构之后，反射调用方法的开销被避免了:</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="6d77" class="li kl in mc b gy ml mm l mn mo">@Override</span><span id="a979" class="li kl in mc b gy mp mm l mn mo">public void begin() {</span><span id="b4ff" class="li kl in mc b gy mp mm l mn mo">connection.getConnectionPostProcessors().add(target -&gt; {</span><span id="0444" class="li kl in mc b gy mp mm l mn mo">try {</span><span id="1055" class="li kl in mc b gy mp mm l mn mo">target.setAutoCommit(false);</span><span id="1812" class="li kl in mc b gy mp mm l mn mo">} catch (final SQLException ex) {</span><span id="2a57" class="li kl in mc b gy mp mm l mn mo">throw new RuntimeException(ex);</span><span id="e1ae" class="li kl in mc b gy mp mm l mn mo">}</span><span id="d2f6" class="li kl in mc b gy mp mm l mn mo">});</span><span id="0ea7" class="li kl in mc b gy mp mm l mn mo">}</span></pre><blockquote class="mq mr ms"><p id="2eee" class="jm jn mt jo b jp jq jr js jt ju jv jw mu jy jz ka mv kc kd ke mw kg kh ki kj ig bi translated"><strong class="jo io">相关公关:</strong></p><p id="36b5" class="jm jn mt jo b jp jq jr js jt ju jv jw mu jy jz ka mv kc kd ke mw kg kh ki kj ig bi translated"><a class="ae mx" href="https://github.com/apache/shardingsphere/pull/10466/files" rel="noopener ugc nofollow" target="_blank">https://github.com/apache/shardingsphere/pull/10466/files</a></p><p id="3767" class="jm jn mt jo b jp jq jr js jt ju jv jw mu jy jz ka mv kc kd ke mw kg kh ki kj ig bi translated"><a class="ae mx" href="https://github.com/apache/shardingsphere/pull/11415/files" rel="noopener ugc nofollow" target="_blank">https://github.com/apache/shardingsphere/pull/11415/files</a></p></blockquote><h2 id="c87c" class="li kl in bd km lj lk dn kq ll lm dp ku jx ln lo ky kb lp lq lc kf lr ls lg lt bi translated">Netty Epoll 对 aarch64 的支持</h2><p id="e2b9" class="pw-post-body-paragraph jm jn in jo b jp lu jr js jt lv jv jw jx lw jz ka kb lx kd ke kf ly kh ki kj ig bi translated">从<code class="fe lz ma mb mc b">4.1.50.Final</code>，<a class="ae mx" href="https://netty.io/wiki/native-transports.html" rel="noopener ugc nofollow" target="_blank"> Netty 的 Epoll </a>已经可以在 aarch64 架构的 Linux 环境下使用。在一个<a class="ae mx" href="https://en.wikipedia.org/wiki/AArch64" rel="noopener ugc nofollow" target="_blank"> aarch64 </a> Linux 环境下，与<a class="ae mx" href="https://netty.io" rel="noopener ugc nofollow" target="_blank"> Netty NIO </a> API 相比，使用 Netty Epoll API 可以大大提高性能。</p><blockquote class="mq mr ms"><p id="0620" class="jm jn mt jo b jp jq jr js jt ju jv jw mu jy jz ka mv kc kd ke mw kg kh ki kj ig bi translated"><strong class="jo io">参考:</strong>T28】https://stackoverflow.com/a/23465481/7913731</p></blockquote><h2 id="63c5" class="li kl in bd km lj lk dn kq ll lm dp ku jx ln lo ky kb lp lq lc kf lr ls lg lt bi translated">5.1.0 和 5.0.0 版本之间的 ShardingSphere-Proxy TPC-C 性能测试比较</h2><p id="75e8" class="pw-post-body-paragraph jm jn in jo b jp lu jr js jt lv jv jw jx lw jz ka kb lx kd ke kf ly kh ki kj ig bi translated">我们使用 TPC-C 进行了 ShardingSphere-Proxy 基准测试，以验证性能优化结果。由于早期版本的 ShardingSphere-Proxy 对<a class="ae mx" href="https://www.postgresql.org" rel="noopener ugc nofollow" target="_blank"> PostgreSQL </a>的支持有限，无法执行 TPC-C 测试，因此在版本 5.0.0 和 5.0.1 之间进行比较。</p><p id="7043" class="pw-post-body-paragraph jm jn in jo b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj ig bi translated">为了突出 ShardingSphere-Proxy 本身的性能损失，这个测试将针对 PostgreSQL 14.2 使用带有分片数据(1 个分片)的 ShardingSphere-Proxy。</p><p id="a845" class="pw-post-body-paragraph jm jn in jo b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj ig bi translated">测试遵循官方文件<a class="ae mx" href="https://shardingsphere.apache.org/document/current/cn/reference/test/performance-test/benchmarksql-test/" rel="noopener ugc nofollow" target="_blank"><em class="mt">benchmarks SQL 性能测试</em> </a>进行，配置从 4 分片减少到 1 分片。</p><h2 id="5db6" class="li kl in bd km lj lk dn kq ll lm dp ku jx ln lo ky kb lp lq lc kf lr ls lg lt bi translated"><em class="nu">测试环境</em></h2><figure class="md me mf mg gt mz gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi nv"><img src="../Images/fc5da9563f76265c0720a1f2089f3144.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n-AxSDqJHaCD_gBS15LEWg.png"/></div></div></figure><h2 id="a2db" class="li kl in bd km lj lk dn kq ll lm dp ku jx ln lo ky kb lp lq lc kf lr ls lg lt bi translated"><em class="nu">测试参数</em></h2><p id="c782" class="pw-post-body-paragraph jm jn in jo b jp lu jr js jt lv jv jw jx lw jz ka kb lx kd ke kf ly kh ki kj ig bi translated"><strong class="jo io">基准 SQL 参数</strong></p><ul class=""><li id="d64e" class="ng nh in jo b jp jq jt ju jx ni kb nj kf nk kj nw nm nn no bi translated">仓库=192(数据量)</li><li id="89ca" class="ng nh in jo b jp np jt nq jx nr kb ns kf nt kj nw nm nn no bi translated">终端数=192(并发数)</li><li id="6e24" class="ng nh in jo b jp np jt nq jx nr kb ns kf nt kj nw nm nn no bi translated">terminalWarehouseFixed=false</li><li id="0638" class="ng nh in jo b jp np jt nq jx nr kb ns kf nt kj nw nm nn no bi translated">操作时间 30 分钟</li></ul><p id="a8fc" class="pw-post-body-paragraph jm jn in jo b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj ig bi translated"><strong class="jo io"> PostgreSQL JDBC 参数</strong></p><ul class=""><li id="2598" class="ng nh in jo b jp jq jt ju jx ni kb nj kf nk kj nw nm nn no bi translated">defaultRowFetchSize=50</li><li id="e496" class="ng nh in jo b jp np jt nq jx nr kb ns kf nt kj nw nm nn no bi translated">reWriteBatchedInserts=true</li></ul><p id="0fba" class="pw-post-body-paragraph jm jn in jo b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj ig bi translated"><strong class="jo io"> ShardingSphere-Proxy JVM 部分参数</strong></p><ul class=""><li id="e0e1" class="ng nh in jo b jp jq jt ju jx ni kb nj kf nk kj nw nm nn no bi translated">-Xmx16g</li><li id="17fc" class="ng nh in jo b jp np jt nq jx nr kb ns kf nt kj nw nm nn no bi translated">-Xms16g</li><li id="269c" class="ng nh in jo b jp np jt nq jx nr kb ns kf nt kj nw nm nn no bi translated">-Xmn12g</li><li id="7cbb" class="ng nh in jo b jp np jt nq jx nr kb ns kf nt kj nw nm nn no bi translated">-XX:AutoBoxCacheMax=4096</li><li id="f9dc" class="ng nh in jo b jp np jt nq jx nr kb ns kf nt kj nw nm nn no bi translated">-XX:+UseNUMA</li><li id="ec59" class="ng nh in jo b jp np jt nq jx nr kb ns kf nt kj nw nm nn no bi translated">-XX:+DisableExplicitGC</li><li id="b406" class="ng nh in jo b jp np jt nq jx nr kb ns kf nt kj nw nm nn no bi translated">-XX:LargePageSizeInBytes=128m</li><li id="1191" class="ng nh in jo b jp np jt nq jx nr kb ns kf nt kj nw nm nn no bi translated">-XX:+SegmentedCodeCache</li><li id="4b61" class="ng nh in jo b jp np jt nq jx nr kb ns kf nt kj nw nm nn no bi translated">-XX:+侵略性</li></ul><h2 id="f90d" class="li kl in bd km lj lk dn kq ll lm dp ku jx ln lo ky kb lp lq lc kf lr ls lg lt bi translated"><strong class="ak"> <em class="nu">检测结果</em> </strong></h2><figure class="md me mf mg gt mz gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi nx"><img src="../Images/7d6bad157bf375ad606b0095abad230b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JV-K_RRKL4JuPUiu772Mnw.png"/></div></div></figure><figure class="md me mf mg gt mz gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi ny"><img src="../Images/770d2317b903f2c055863be82d1d148d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WL7SBOvGlC_0BKwm"/></div></div></figure><p id="2e63" class="pw-post-body-paragraph jm jn in jo b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj ig bi translated">从本文的上下文和环境中得出的结果是:</p><ul class=""><li id="a592" class="ng nh in jo b jp jq jt ju jx ni kb nj kf nk kj nw nm nn no bi translated">以 sharding sphere-Proxy 5 . 0 . 0+PostgreSQL 为基准，Apache sharding sphere 5 . 1 . 0 版性能提升 26.8%。</li><li id="a4a7" class="ng nh in jo b jp np jt nq jx nr kb ns kf nt kj nw nm nn no bi translated">基于与 PostgreSQL 的直接连接，与版本 5.0.0 相比，ShardingSphere-Proxy 5.1.0 减少了 15%的损失，从 42.7%减少到 27.4%。</li></ul><p id="6dfa" class="pw-post-body-paragraph jm jn in jo b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj ig bi translated">上面的测试结果没有涵盖所有的优化点，因为详细的代码优化已经在整个 ShardingSphere 模块中完成。</p><h2 id="c3ce" class="li kl in bd km lj lk dn kq ll lm dp ku jx ln lo ky kb lp lq lc kf lr ls lg lt bi translated">如何看待业绩问题</h2><p id="83d4" class="pw-post-body-paragraph jm jn in jo b jp lu jr js jt lv jv jw jx lw jz ka kb lx kd ke kf ly kh ki kj ig bi translated">人们不时会问，“ShardingSphere 的表现如何？损失多少？”</p><p id="291f" class="pw-post-body-paragraph jm jn in jo b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj ig bi translated">我相信，只要满足需求，性能就是好的。性能是一个复杂的问题，受许多因素的影响。没有适用于所有情况的灵丹妙药。根据不同的环境和场景，ShardingSphere 的性能损失可以小于 1%，也可以高达 50%。</p><p id="a37e" class="pw-post-body-paragraph jm jn in jo b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj ig bi translated">此外，ShardingSphere 作为一种基础设施，其性能是 R&amp;D 进程中的关键考虑因素之一。sharing sphere 社区中的团队和个人将加倍努力将 sharing sphere 的性能推向极限。</p><h2 id="8f8d" class="li kl in bd km lj lk dn kq ll lm dp ku jx ln lo ky kb lp lq lc kf lr ls lg lt bi translated">Apache ShardingSphere 开源项目链接:</h2><p id="4d0d" class="pw-post-body-paragraph jm jn in jo b jp lu jr js jt lv jv jw jx lw jz ka kb lx kd ke kf ly kh ki kj ig bi translated">ShardingSphere Github </p><p id="6dc7" class="pw-post-body-paragraph jm jn in jo b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj ig bi translated"><a class="ae mx" href="https://twitter.com/ShardingSphere" rel="noopener ugc nofollow" target="_blank"> ShardingSphere Twitter </a></p><p id="aff2" class="pw-post-body-paragraph jm jn in jo b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj ig bi translated"><a class="ae mx" href="https://join.slack.com/t/apacheshardingsphere/shared_invite/zt-sbdde7ie-SjDqo9~I4rYcR18bq0SYTg" rel="noopener ugc nofollow" target="_blank"> ShardingSphere 松弛通道</a></p><p id="036d" class="pw-post-body-paragraph jm jn in jo b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj ig bi translated"><a class="ae mx" href="https://shardingsphere.apache.org/community/cn/contribute/" rel="noopener ugc nofollow" target="_blank">投稿指南</a></p><h2 id="9522" class="li kl in bd km lj lk dn kq ll lm dp ku jx ln lo ky kb lp lq lc kf lr ls lg lt bi translated">作者</h2><p id="549b" class="pw-post-body-paragraph jm jn in jo b jp lu jr js jt lv jv jw jx lw jz ka kb lx kd ke kf ly kh ki kj ig bi translated"><strong class="jo io">吴伟杰</strong></p><blockquote class="mq mr ms"><p id="ae9e" class="jm jn mt jo b jp jq jr js jt ju jv jw mu jy jz ka mv kc kd ke mw kg kh ki kj ig bi translated">SphereEx 基础设施 R&amp;D 工程师和 Apache ShardingSphere 委员会委员</p></blockquote><p id="5fd6" class="pw-post-body-paragraph jm jn in jo b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj ig bi translated">吴现在专注于 Apache ShardingSphere 及其子项目 ElasticJob 的研发。</p><figure class="md me mf mg gt mz gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi nz"><img src="../Images/aecb21791bdc8f0e9861cf9d1b156b95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bSc9S3Y34VMcDTCNCg6OPw.png"/></div></div></figure></div></div>    
</body>
</html>