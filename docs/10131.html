<html>
<head>
<title>Learning Go, A Journey: Creating Server with HTTP Package #9</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习 Go，一个旅程:用 HTTP 包创建服务器#9</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/learning-go-a-journey-creating-server-with-http-package-9-18a00b7d47b?source=collection_archive---------21-----------------------#2022-10-08">https://blog.devgenius.io/learning-go-a-journey-creating-server-with-http-package-9-18a00b7d47b?source=collection_archive---------21-----------------------#2022-10-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="685e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">上周，我发表了一篇关于用 net 包创建服务器的文章。在本文中，我将介绍如何用 HTTP 包创建一个服务器。HTTP 包提供了一种更简单的创建服务器的方法，它是建立在 net 包之上的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d8836bac6e25e43bd7d4404ec2423e4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FHIbyvLfn_n3MckQQAuEfA.png"/></div></div></figure><h1 id="48e4" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">ListenAndServe 和类型处理程序</h1><p id="88ca" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">要创建一个带有 HTTP 包的服务器，我们必须调用函数 ListenAndServe，它接收两个参数一个地址和一个类型处理程序。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lx"><img src="../Images/ba0b19726fcb9c5bd40ee2b36b45a0b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8jOen2eHYw-Sj2P0"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lx"><img src="../Images/cd856401bf33b921be6e07e534535e39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*eYpp8jtgxOHit_q4"/></div></div></figure><p id="6b3f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">ListenAndServe 监听 TCP 网络地址 addr，然后用一个处理程序调用 Serve 来处理传入连接上的请求(<a class="ae ly" href="https://pkg.go.dev/net/http#ListenAndServe" rel="noopener ugc nofollow" target="_blank"> Go doc </a>)。类型处理程序是一个具有 ServeHTTP 方法的接口，这意味着任何具有 ServeHTTP 方法的类型都会实现处理程序接口。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lx"><img src="../Images/1a0a6a99c3c2d5ce651d51348b85769a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qr93PwlmIUFzW_LE"/></div></div></figure><p id="049f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">正如我们从上图中看到的，我们有一个 clientHandler，它是一个具有 ServeHTTP 方法的结构。创建一个 clientHandler 类型的值，然后将该值传递给 ListenAndServe 函数。然后我们可以运行程序，在浏览器上打开地址。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lz"><img src="../Images/af93690390e67e506c59d92306f2930e.png" data-original-src="https://miro.medium.com/v2/resize:fit:480/0*O5VDxOrgNriBwPJW"/></div></figure><h1 id="5987" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">HTTP ServeMux</h1><p id="52b4" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">从前面的例子中，我们已经成功地创建了我们自己的带有一个处理程序的服务器。现在，如果我们有多条路线要处理呢？我们使用 ServeMux 来完成这项工作。</p><p id="db52" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">ServeMux 是一个 HTTP 请求复用器。它将每个传入请求的 URL 与注册模式列表进行匹配，并调用与 URL 最匹配的模式的处理程序(<a class="ae ly" href="https://pkg.go.dev/net/http#ServeMux" rel="noopener ugc nofollow" target="_blank"> Go doc </a>)。ServeMux 有多种方法</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ma"><img src="../Images/a0295e2315a4a8a2a7540ca70225b9c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1358/0*v93MoeVBhMij3fe_"/></div></figure><p id="eddd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">要用 ServeMux 创建服务器，我们必须调用 NewServeMux()，然后用 handle 方法处理多个路由，该方法接收两个参数、一个模式和一个类型处理程序。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lx"><img src="../Images/06ad7e629e8553e7deb8c1217010f0d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*SeDWbcWBrT0ksf4m"/></div></div></figure><p id="866b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在我们有多条路由，用不同的处理程序来处理请求。如果我们在浏览器上打开地址并访问路由，输出将是</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lz"><img src="../Images/e246ef904ec256e468bdb682f3b2a675.png" data-original-src="https://miro.medium.com/v2/resize:fit:480/0*mP2jLB-c0SEUK6VN"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/ec2544f0656555e78be9c284a42c3e25.png" data-original-src="https://miro.medium.com/v2/resize:fit:548/0*_xCEwz2S5WtKEFlL"/></div></figure><h1 id="31a9" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">HTTP HandleFunc 和 DefaultServeMux</h1><p id="3b56" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">在前面的例子中，我们使用了一个 ServeMux 和一个 Handle 函数来处理我们的请求。但这似乎太复杂了，因为我们必须创建多个类型才能实现处理程序接口。这就是为什么我们要使用 HandleFunc，它接收两个参数，一个模式和一个带有 ResponseWriter 和指针请求参数的函数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lx"><img src="../Images/066d405cb37d2dbcd59e769498b3814d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bFchEyd9Cu9FNIEc"/></div></div></figure><p id="143d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，我们如何在不向 ListenAndServe 函数传递任何处理程序的情况下创建服务器？我们可以传递一个 nil 值作为参数，这样它将使用 DefaultServeMux。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mc"><img src="../Images/ce64ef9fc34cf87168b3bcebc8f69ab2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HUBaQw-oN3LOf5BM"/></div></div></figure><p id="3821" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，现在我们可以创建我们的服务器并拥有多条路径。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lx"><img src="../Images/097e52c2328fd4cbdcb20950c9406c47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OgBPz-AuHz8V9h6k"/></div></div></figure><p id="640c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">运行程序并访问 URL，输出将是</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lz"><img src="../Images/17148dc5bb39980dc66a4d24b3608b23.png" data-original-src="https://miro.medium.com/v2/resize:fit:480/0*BVBG5m_NbFdjCp-V"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/7f603f4dd930675073d3abaec04f64fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:548/0*HIZ1yjfQ2RW4snBM"/></div></figure></div><div class="ab cl md me hr mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ig ih ii ij ik"><p id="63bd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">本文到此为止，别忘了留下一个赞，分享给别人。如果您有任何反馈，请在下面留下您的评论。感谢你阅读这篇文章，祝你有美好的一天👋。</p><p id="607a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">资源</p><ul class=""><li id="f70e" class="mk ml in jm b jn jo jr js jv mm jz mn kd mo kh mp mq mr ms bi translated"><a class="ae ly" href="https://www.udemy.com/course/learn-how-to-code/" rel="noopener ugc nofollow" target="_blank">学习如何编码:谷歌的 Go (golang)编程语言</a></li><li id="cdbe" class="mk ml in jm b jn mt jr mu jv mv jz mw kd mx kh mp mq mr ms bi translated"><a class="ae ly" href="https://go.dev/ref/spec" rel="noopener ugc nofollow" target="_blank">围棋编程语言规范</a></li><li id="cb8e" class="mk ml in jm b jn mt jr mu jv mv jz mw kd mx kh mp mq mr ms bi translated"><a class="ae ly" href="https://pkg.go.dev/net/http" rel="noopener ugc nofollow" target="_blank"> HTTP 包</a></li></ul></div></div>    
</body>
</html>