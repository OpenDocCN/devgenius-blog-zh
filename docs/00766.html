<html>
<head>
<title>Building a “Powerful” and “Generic” Repository in .NET</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">中构建一个“强大的”和“通用的”存储库。网</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/building-a-powerful-and-generic-repository-in-net-667edea193f6?source=collection_archive---------5-----------------------#2020-06-16">https://blog.devgenius.io/building-a-powerful-and-generic-repository-in-net-667edea193f6?source=collection_archive---------5-----------------------#2020-06-16</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="7f78" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">哎呀！又来了！？您可能会发现这篇文章并不有趣，因为您可能已经开发了几个“很棒”的库。然而，在设计一个强大的通用存储库时，本文指的是“一个特殊的东西”。所以，请不要错过这颗宝石！💎💎💎</p><p id="4e98" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">是的，我们正在谈论“强大的”和“通用的”存储库。它是一种可移植的存储库，可以处理数百万行而不影响服务器性能。它正在生产环境中得到使用、验证和测试。</p><p id="3d25" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">TL；DR: </strong>一种实现非常强大和通用的基于实体的存储库的新技术。它非常容易，干净/可维护和优越！👌🏻👦🏼</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1269ff9c8296016ec36f52685cfff67d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HhT0IllJCcexXgrn"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">托马斯·尼格伦·汉森报道</figcaption></figure><blockquote class="ky kz la"><p id="9229" class="jk jl lb jm b jn jo jp jq jr js jt ju lc jw jx jy ld ka kb kc le ke kf kg kh ig bi translated">现在，在开发应用程序时，总是使用存储库模式已经成为一种行业标准(专门针对数据库连接)。这是一个广为人知的模式，强烈推荐给每个人和/或任何形式的软件开发。</p></blockquote><p id="7f61" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">您可以下载下面的源代码，用于个人或商业用途。</strong> 🖐🏻🍻</p><p id="e270" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对于那些仍然不知道什么是存储库的人。“存储库”是一种软件设计模式和实践，它被实现为应用程序和数据库之间的附加层。通过 repository，您可以管理如何从/向数据库操作数据。</p><p id="4ce6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">为了让您从高层次了解什么是存储库，</strong>下面是高层次的图表。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lf"><img src="../Images/aa6dc75fe5f63f416a87b6b0fdf0ffe5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bsnRfIYmDDLxHyYPkXzUzA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">存储库图表——迈克尔·彭登</figcaption></figure><p id="2b12" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">应用程序与数据库的交互由存储库控制。按照设计，数据库中的所有表必须在应用程序中有相应的模型/实体。此外，表中的所有列都必须在模型/实体中具有相应的属性。存储库将使用给定的操作(即:插入、删除、合并、更新和查询)自动映射客户机和数据库之间的对象。</p><h1 id="8b52" class="lg lh in bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">强大的知识库💪🏻</h1><p id="9ed0" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">这是一种可以帮助您的应用程序发挥最大性能的存储库(在任何情况下)。它应该是线程安全、智能、高效和高性能的。此外，所有操作必须公开/符合<a class="ae mj" href="https://en.wikipedia.org/wiki/ACID" rel="noopener ugc nofollow" target="_blank"> ACID </a>原则。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mk"><img src="../Images/c9371303cd7e1cd8ee57ff343837d7fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aXUnPN_DwOPE2RBtRmMHlA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">强大的知识库——迈克尔·彭登</figcaption></figure><p id="a8a0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一个常见的用例是允许您的存储库在对数据库执行活动时使用正确的操作。通过成为智能存储库…</p><blockquote class="ky kz la"><p id="aad9" class="jk jl lb jm b jn jo jp jq jr js jt ju lc jw jx jy ld ka kb kc le ke kf kg kh ig bi translated">“原子”操作最有可能在处理少量行时执行。而对于几百行执行“批处理”操作。除此之外，强制使用“批量”操作。</p></blockquote><p id="6f24" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">就健壮性而言，您最有可能设计一个具有线程安全、高效和高性能操作的存储库。确保应用程序在生产环境中部署和运行后不会影响服务器资源。</p><h1 id="a7a6" class="lg lh in bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">通用信息库♻️</h1><p id="1d60" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">这是一种允许您使用多个数据库、表和/或模型的存储库。它通常被称为所有其他基于实体的存储库的“基础”存储库。它应该可以被任何形式的具有特定目的的存储库扩展。另外，要尽量简单(<a class="ae mj" href="https://en.wikipedia.org/wiki/KISS_principle" rel="noopener ugc nofollow" target="_blank">吻</a>原理)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ml"><img src="../Images/6042403b6eb4b2d34695f75eb8eedda4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_nJwoOYA0pL1BBgs7X71SA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">通用知识库——迈克尔·彭登</figcaption></figure><p id="2311" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这种情况下，假设您正在一个电子商务网站上工作，其中的数据库驻留在不同的服务器上，并由不同的 RDBMS 提供者(即:SQL Server、MySQL 和 PostgreSQL)提供服务。您希望将数据整合到一个应用程序中。</p><p id="71f0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">另一方面，假设数据库中有您想要使用的预定义表；您希望为应用程序中的所有表提供必要的(相等的)操作。您希望确保在操作实现中应用<a class="ae mj" href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself" rel="noopener ugc nofollow" target="_blank"> DRY </a>原则(即:保存、获取、合并、更新等)。</p><h1 id="683b" class="lg lh in bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">识别数据访问框架🤔</h1><p id="97b8" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">默认情况下，当连接到数据库时，ADO.NET 被用作数据访问技术。然而，这种低级技术要求我们实现存储库工作所需的每一段代码。因此，使用各种数据访问框架是非常明智的。</p><p id="9bc9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">强烈建议使用 micro-ORM 来实现。使用 micro-ORM，您可以完全控制所有必要的操作。</p><p id="bc82" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在本教程中，我将主要使用<a class="ae mj" href="https://repodb.net/" rel="noopener ugc nofollow" target="_blank"> RepoDb </a>，它是为迎合这些独特的场景而设计和开发的。从某种意义上说，它是“最快”和“最高效”的 ORM，从某种意义上说，它是. NET 的“混合设计”。</p><blockquote class="ky kz la"><p id="ef2f" class="jk jl lb jm b jn jo jp jq jr js jt ju lc jw jx jy ld ka kb kc le ke kf kg kh ig bi translated">老实说，如果你使用微软的实体框架，实现这种存储库是相当困难的。默认情况下，它不支持“批处理”和“批量”操作。您可能最终会因为大量定制的实现而污染您的存储库。如果您喜欢 raw-SQL 实现，并且希望用 raw 实现所有东西，那么使用<a class="ae mj" href="https://dapper-tutorial.net/dapper" rel="noopener ugc nofollow" target="_blank"> Dapper </a>。你总是可以用你喜欢的 ORM 来实现这样的库设计。</p></blockquote><p id="0494" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">免责声明:</strong>选择哪个 ORM 框架由你决定。试着看看<a class="ae mj" href="https://grauenwolf.github.io/DotNet-ORM-Cookbook/ORMs.htm" rel="noopener ugc nofollow" target="_blank"> ORM 食谱</a>来选择你认为最适合你情况的 ORM。</p><h1 id="e5e5" class="lg lh in bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">实际的存储库实现🔨</h1><p id="d8a5" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">要实现，基本存储库必须保存连接字符串的信息，并且必须接受“数据实体”和“数据库提供者”类型作为泛型类型。请参见下面的示例代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="9b3c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">它还必须实现所有需要的通用操作(即:插入、删除、获取、更新和合并)以达到重用的目的。</p><p id="f31b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">请参见下面的代码片段作为裸实现。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mm mn l"/></div></figure><blockquote class="ky kz la"><p id="9ae0" class="jk jl lb jm b jn jo jp jq jr js jt ju lc jw jx jy ld ka kb kc le ke kf kg kh ig bi translated">类必须是“抽象的”,方法必须是“虚拟的”,以确保存储库是可扩展的，并且在继承后遵循“打开-关闭”原则。</p></blockquote><p id="e2e8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在每个方法中，必须打开和关闭一个新的连接对象。参见下面的“SaveAll”批处理操作示例代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="d193" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">而下面是对" MergeAll "的批量操作。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="4b88" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">必须在上述所有给定操作中实施相同的方法。</p><h2 id="af70" class="mo lh in bd li mp mq dn lm mr ms dp lq jv mt mu lu jz mv mw ly kd mx my mc mz bi translated">批量考虑</h2><p id="2047" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">在批处理操作的情况下，表示批号的数字必须作为属性实现。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="47c2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后，添加一个逻辑，在执行操作时总是检查这一点。参见下面的“SaveAll”批处理操作的示例代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="d64b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">还必须为其他批处理操作(即:InsertAll、DeleteAll、UpdateAll 和 MergeAll)实现它。</p><p id="1cbc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">为什么需要这样做？</strong>原子操作在处理少量行时更快更有效，而批量操作在处理大量行时更好。</p><blockquote class="ky kz la"><p id="f406" class="jk jl lb jm b jn jo jp jq jr js jt ju lc jw jx jy ld ka kb kc le ke kf kg kh ig bi translated">请访问此<a class="ae mj" href="https://medium.com/dev-genius/why-choose-repodb-orm-over-dapper-da87432c7830#38cb" rel="noopener">链接</a>以进一步了解原子、批处理和批量操作之间的区别。</p></blockquote><h1 id="5bfc" class="lg lh in bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">如何使用存储库✍️</h1><p id="451f" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">到这个时候，我们可以预期“EntityRepository”实现已经完成。为了利用存储库，您必须实现一个基于实体的存储库，它继承了基本的“EntityRepository”类。</p><p id="fef5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">比方说，您有一个来自 SQL Server 数据库的“客户”表。然后，必须实现下面的存储库。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="9b5d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">通过实现这样的存储库，来自底层存储库的所有方法都被继承。</p><h2 id="093c" class="mo lh in bd li mp mq dn lm mr ms dp lq jv mt mu lu jz mv mw ly kd mx my mc mz bi translated">调用存储库方法</h2><p id="fdf2" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">下面是从存储库中调用方法的示例代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="af37" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">而下面是为“删除”准备的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="3c55" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最好的方法是通过依赖注射。</p><p id="a8c9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">为其他数据库提供商提供服务</strong></p><p id="592b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">同上，通用存储库能够连接到其他 RDBMS 提供者。</p><p id="aed7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在我们的图表中，订单必须能够连接到 MySQL RDBMS。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="27eb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">OrderItem 也是如此。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="6a4a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最后，该产品必须连接到 PostgreSQL RDBMS。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="b8f5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">也就是说，您已经将存储库实现为“通用的”,从可重用性的角度来看，它是非常混合和动态的。</p><p id="aa07" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">以下是一些优势:</strong></p><ul class=""><li id="c4fa" class="na nb in jm b jn jo jr js jv nc jz nd kd ne kh nf ng nh ni bi translated">代码简洁明了，易于维护和操作</li><li id="4257" class="na nb in jm b jn nj jr nk jv nl jz nm kd nn kh nf ng nh ni bi translated">必须更快更高效</li><li id="a09f" class="na nb in jm b jn nj jr nk jv nl jz nm kd nn kh nf ng nh ni bi translated">封装，易于采用</li></ul><h1 id="7c8b" class="lg lh in bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated"><strong class="ak">专门的存储库(</strong> SQL Server)🔥</h1><p id="33de" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">这是为特定 RDBMS 提供者使用专门方法的存储库(即:批量操作)。请注意，并非一个提供商的所有功能对其他 RDBMS 提供商也是存在的。这只是在一个场景的基础上，所以很重要的是要注意，并不总是如此。</p><p id="cd4e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在本教程中，我们将介绍与 SQL Server 的“批量”操作相关的场景。</p><p id="9d55" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">首先，创建一个继承“EntityRepository”的类，该类也接受“数据实体”的泛型类型，并显式地将 DB provider 设置为“SqlConnection”。请参见下面的示例代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="7f88" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后，实现表示批量操作触发器的 number 属性。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="bf71" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后，为批量操作实现必要的方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mm mn l"/></div></figure><blockquote class="ky kz la"><p id="d827" class="jk jl lb jm b jn jo jp jq jr js jt ju lc jw jx jy ld ka kb kc le ke kf kg kh ig bi translated">在上面的代码第 5 行中，请注意，我们将新创建的“DbConnection”对象强制转换为“SqlConnection”类型。这是因为第 7 行中的“BulkMergeAsync”就是这种类型的扩展方法。</p></blockquote><p id="b081" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">要实现的所有其他批量操作(即:DeleteAll、InsertAll 和 UpdateAll)必须使用上述相同的技术。</p><h1 id="18e6" class="lg lh in bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">实际源代码 Implementation✂️</h1><p id="9dc8" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">你可以从我的 Github 账户下载下面的库作为 gists。</p><ul class=""><li id="1c45" class="na nb in jm b jn jo jr js jv nc jz nd kd ne kh nf ng nh ni bi translated"><a class="ae mj" href="https://gist.github.com/mikependon/b409cc549052e2b5d77574e2b0948c3b" rel="noopener ugc nofollow" target="_blank"> EntityRepository </a> —基本通用存储库(任何 RDBMS)。</li><li id="76aa" class="na nb in jm b jn nj jr nk jv nl jz nm kd nn kh nf ng nh ni bi translated"><a class="ae mj" href="https://gist.github.com/mikependon/d61928bd1230a41c249b72d24a24ab21" rel="noopener ugc nofollow" target="_blank">SqlConnectionEntityRepository</a>—基于 SQL Server 的实体的基本存储库。</li></ul><p id="3b8b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">事务/工作单元实现不是存储库的一部分。您可以扩展存储库来包含这样的实现供您使用。我们建议您在调用操作之前，只需在存储库中公开一个属性并设置它。然后，在每个存储库操作中，只需传递“Transaction”属性。</p><h1 id="9558" class="lg lh in bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">运行给定的存储库🚀</h1><p id="6efa" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">首先，您需要下载上一节中提到的存储库，并将其放在您的解决方案/项目中。我们建议您创建一个“存储库”文件夹并放在那里。</p><h2 id="622d" class="mo lh in bd li mp mq dn lm mr ms dp lq jv mt mu lu jz mv mw ly kd mx my mc mz bi translated">安装库</h2><p id="b7d8" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">在您的软件包管理器控制台中，只需键入以下代码。</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="a9d2" class="mo lh in np b gy nt nu l nv nw">&gt; Install-Package RepoDb.SqlServer</span></pre><p id="088c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果您要使用“SqlConnectionEntityRepository”，请使用下面的命令。</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="1089" class="mo lh in np b gy nt nu l nv nw">&gt; Install-Package RepoDb.SqlServer.BulkOperations</span></pre><p id="99d9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">安装完成后，只需从代码的任何地方调用引导程序。</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="a9f1" class="mo lh in np b gy nt nu l nv nw">RepoDb.SqlServerBootstrap.Initialize();</span></pre><p id="cb08" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">也可以访问官方<a class="ae mj" href="https://repodb.net/tutorial/get-started-sqlserver" rel="noopener ugc nofollow" target="_blank">教程</a>页面了解更多参考。</p><p id="ad1e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如有任何问题，请在此处<a class="ae mj" href="https://github.com/mikependon/RepoDb/issues/new" rel="noopener ugc nofollow" target="_blank">报告。</a></p><p id="481e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">~感谢你阅读这篇文章。~ </strong></p></div></div>    
</body>
</html>