<html>
<head>
<title>Docker — Data Volume</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Docker —数据量</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/docker-data-volume-af83671e25af?source=collection_archive---------7-----------------------#2022-02-21">https://blog.devgenius.io/docker-data-volume-af83671e25af?source=collection_archive---------7-----------------------#2022-02-21</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><div class=""><h2 id="27b7" class="pw-subtitle-paragraph jo iq ir bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated">每天一点集装箱知识！</h2></div><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div class="gi gj kg"><img src="../Images/e3d393e0e045cfce2e209eec20b2acb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*upK97P1n3cgU20Gk.png"/></div></figure><p id="3fcc" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">存储驱动和数据卷是容器存储数据的两种方式。我上一篇文章讲了“<a class="ae lk" href="https://medium.com/geekculture/docker-storage-driver-667c57169379" rel="noopener"> Docker —存储驱动</a>”，今天这一篇就讲讲数据量。</p><h1 id="fafb" class="ll lm ir bd ln lo lp lq lr ls lt lu lv jx lw jy lx ka ly kb lz kd ma ke mb mc bi translated">容器数据量</h1><p id="984c" class="pw-post-body-paragraph ko kp ir kq b kr md js kt ku me jv kw kx mf kz la lb mg ld le lf mh lh li lj ik bi translated">数据卷是保存 Docker 容器生成和使用的数据的首选机制。数据卷本质上是 Docker 主机文件系统中的目录或文件，可以直接挂载到容器的文件系统中。数据卷具有以下特征:</p><ol class=""><li id="357e" class="mi mj ir kq b kr ks ku kv kx mk lb ml lf mm lj mn mo mp mq bi translated">数据卷是目录或文件，而不是未格式化的磁盘(块设备)。</li><li id="165b" class="mi mj ir kq b kr mr ku ms kx mt lb mu lf mv lj mn mo mp mq bi translated">容器可以读写卷中的数据。</li><li id="d47c" class="mi mj ir kq b kr mr ku ms kx mt lb mu lf mv lj mn mo mp mq bi translated">即使使用卷数据的容器已被销毁，卷数据也可以持久保存。</li></ol><p id="7722" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">好了，现在我们有了一个可以用来存储数据的数据层(图像层和容器层)和卷。如何选择何时使用？考虑以下场景:</p><ol class=""><li id="a265" class="mi mj ir kq b kr ks ku kv kx mk lb ml lf mm lj mn mo mp mq bi translated">数据库实例<code class="fe mw mx my mz b">vs</code>数据库数据</li><li id="30e8" class="mi mj ir kq b kr mr ku ms kx mt lb mu lf mv lj mn mo mp mq bi translated">Web 应用程序<code class="fe mw mx my mz b">vs</code>应用程序日志</li><li id="ec34" class="mi mj ir kq b kr mr ku ms kx mt lb mu lf mv lj mn mo mp mq bi translated">数据分析软件<code class="fe mw mx my mz b">vs</code>输入/输出数据</li><li id="e50b" class="mi mj ir kq b kr mr ku ms kx mt lb mu lf mv lj mn mo mp mq bi translated">Apache 服务器<code class="fe mw mx my mz b">vs</code>静态 HTML 文件</li></ol><p id="f873" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">相信大家都会做出以下选择:</p><ol class=""><li id="4a33" class="mi mj ir kq b kr ks ku kv kx mk lb ml lf mm lj mn mo mp mq bi translated">应用程序部分可以放在数据层。因为这部分内容是无状态的，所以应该是镜像的一部分。</li><li id="3f78" class="mi mj ir kq b kr mr ku ms kx mt lb mu lf mv lj mn mo mp mq bi translated">数据部分可以放置在数据卷中。这是需要持久化的数据，应该与图像分开保存。</li></ol><p id="454a" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">还有一个大家可能关心的问题:音量的容量如何设置？</p><p id="40d8" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">因为卷实际上是 docker 主机文件系统的一部分，所以卷的容量取决于文件系统当前未使用的空间，并且当前没有办法设置卷的容量。</p><h2 id="8072" class="na lm ir bd ln nb nc dn lr nd ne dp lv kx nf ng lx lb nh ni lz lf nj nk mb nl bi translated">绑定装载与 Docker 管理的卷</h2><p id="d733" class="pw-post-body-paragraph ko kp ir kq b kr md js kt ku me jv kw kx mf kz la lb mg ld le lf mh lh li lj ik bi translated">在具体使用中，docker 提供了两种类型的卷:绑定挂载和 docker 管理的卷。</p><h2 id="2deb" class="na lm ir bd ln nb nc dn lr nd ne dp lv kx nf ng lx lb nh ni lz lf nj nk mb nl bi translated">绑定安装</h2><p id="ca7c" class="pw-post-body-paragraph ko kp ir kq b kr md js kt ku me jv kw kx mf kz la lb mg ld le lf mh lh li lj ik bi translated">绑定装载是将主机上的现有目录或文件装载到容器。例如:</p><p id="1dd3" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">例如，docker 主机上有一个目录$HOME/htdocs:</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div class="gi gj nm"><img src="../Images/736fc0ba042c4226c676530e1b876c0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/0*j6WZau9k-Cgpn8aU"/></div></figure><p id="65ec" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">通过<code class="fe mw mx my mz b">-v</code>将其安装到 httpd 容器:</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="no np di nq bf nr"><div class="gi gj nn"><img src="../Images/43cf9e5e9767cd6e8b93e9cb64d7dcd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qt_N9Bj_pLTzMOWAJYsE3Q.png"/></div></div></figure><p id="a593" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated"><code class="fe mw mx my mz b">/usr/local/apache2/htdocs</code>是 httpd 服务器存储静态文件的地方。由于该控制器已经存在于容器中，因此原始数据将被隐藏并替换为<code class="fe mw mx my mz b">~/htdocs</code>中的数据，该数据由于位于主机上而具有持久性。</p><p id="9dc7" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">此外，还可以在绑定挂载时指定数据的读写权限。默认值为可读和可写，也可以指定为只读:</p><pre class="kh ki kj kk gu ns mz nt nu aw nv bi"><span id="8172" class="na lm ir mz b gz nw nx l ny nz">$ docker run -d -p 80:80 -v ~/htdocs:/usr/local/apache2/htdocts:ro httpd </span></pre><p id="3610" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated"><code class="fe mw mx my mz b">ro</code>代表只读权限，一旦设置了绑定挂载数据就不能在容器中修改。只有主机有权修改数据，提高了安全性。</p><p id="55b9" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">除了绑定挂载目录之外，您还可以指定一个单独的文件:</p><pre class="kh ki kj kk gu ns mz nt nu aw nv bi"><span id="24db" class="na lm ir mz b gz nw nx l ny nz">$ docker run -d -p 80:80 -v ~/htdocs/index.html:/usr/local/apache2/htdocts/new_index.html:ro httpd</span></pre><p id="f164" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">挂载点有许多应用场景。例如，我们可以将源代码目录挂载到容器中，并在主机中修改代码，以查看应用程序的实时效果。另一个例子是将 mysql 容器的数据放在 bind mount 中，以便主机可以轻松地备份和迁移数据。</p><h2 id="614d" class="na lm ir bd ln nb nc dn lr nd ne dp lv kx nf ng lx lb nh ni lz lf nj nk mb nl bi translated">docker 管理卷</h2><p id="e591" class="pw-post-body-paragraph ko kp ir kq b kr md js kt ku me jv kw kx mf kz la lb mg ld le lf mh lh li lj ik bi translated">与绑定装载相比，托管卷有几个优势:</p><ul class=""><li id="7876" class="mi mj ir kq b kr ks ku kv kx mk lb ml lf mm lj oa mo mp mq bi translated">卷比绑定装载更容易备份或迁移。</li><li id="ec26" class="mi mj ir kq b kr mr ku ms kx mt lb mu lf mv lj oa mo mp mq bi translated">您可以使用 Docker CLI 命令或 Docker API 来管理卷。</li><li id="9c03" class="mi mj ir kq b kr mr ku ms kx mt lb mu lf mv lj oa mo mp mq bi translated">卷在 Linux 和 Windows 容器上都可以工作。</li><li id="4c9a" class="mi mj ir kq b kr mr ku ms kx mt lb mu lf mv lj oa mo mp mq bi translated">可以在多个容器之间更安全地共享卷。</li><li id="47a9" class="mi mj ir kq b kr mr ku ms kx mt lb mu lf mv lj oa mo mp mq bi translated">卷驱动程序允许您将卷存储在远程主机或云提供商上，以加密卷的内容或添加其他功能。</li><li id="5dd4" class="mi mj ir kq b kr mr ku ms kx mt lb mu lf mv lj oa mo mp mq bi translated">新卷的内容可以由容器预先填充。</li><li id="2e8e" class="mi mj ir kq b kr mr ku ms kx mt lb mu lf mv lj oa mo mp mq bi translated">Docker 桌面上的卷比 Mac 和 Windows 主机上的绑定装载具有更高的性能。</li></ul><p id="5a9d" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">此外，卷通常是比在容器的可写层中保存数据更好的选择，因为卷不会增加使用它的容器的大小，并且卷的内容存在于给定容器的生命周期之外。</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div class="gi gj ob"><img src="../Images/d50c4fdb06103ddee2b881631e0f5be7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/0*r-8cYeZsUASTA0Ac.png"/></div><figcaption class="oc od gk gi gj oe of bd b be z dk translated">图片来自 docker.com</figcaption></figure><p id="efcc" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">docker 管理的卷和 bind 挂载最大的区别是不需要指定挂载源，只需要指定挂载点。还是以 httpd 容器为例:</p><pre class="kh ki kj kk gu ns mz nt nu aw nv bi"><span id="8693" class="na lm ir mz b gz nw nx l ny nz"> $ docker run -d -p 80:80 -v /usr/local/apache2/htdocs httpd</span></pre><p id="9cc0" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">为此，我们告诉 docker 我们需要一个数据卷，并将其挂载到/usr/local/apache2/htdocs。那么这个数据量到底在哪里呢？</p><p id="3398" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">这个答案可以在容器的配置信息中找到，执行命令:<code class="fe mw mx my mz b">docker inspect</code>。</p><pre class="kh ki kj kk gu ns mz nt nu aw nv bi"><span id="72dd" class="na lm ir mz b gz nw nx l ny nz">$ docker inspect dafbfa86b404</span><span id="665f" class="na lm ir mz b gz og nx l ny nz">......<br/>"Mounts": [<br/>{<br/>  "Name": "fe43eaa90cfc3773ef535ec9e0a094d0ab0477ceb74ddebd57d3620ab50e85b1",<br/>  "Source": "<strong class="mz is">/var/lib/docker/volumes/fe43eaa90cfc3773ef535ec9e0a094d0ab0477ceb74ddebd57d3620ab50e85b1/_data</strong>",<br/>  "Destination": "/usr/local/apache2/htdocs",<br/>  "Driver": "local",<br/>  "Mode": "",<br/>  "RW": true,<br/>  "Propagation": ""<br/>}],<br/>......</span></pre><p id="2b1a" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">我们只对上面输出中突出显示的数据量部分感兴趣。“源”是主机上卷的控制器，在我们的例子中，路径是"<strong class="kq is">/var/lib/docker/volumes/f 4a 0a 1018968 f 47960 EFE 760829 E3 c 5738 c 702533d 29911 b 01 df 9 f 18 babf 3340/_ data "</strong>。</p><p id="8ae9" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">让我们来看一下<strong class="kq is"> </strong>这条路径:</p><pre class="kh ki kj kk gu ns mz nt nu aw nv bi"><span id="c594" class="na lm ir mz b gz nw nx l ny nz">$ # ls -l /var/lib/docker/volumes/fe43eaa90cfc3773ef535ec9e0a094d0ab0477ceb74ddebd57d3620ab50e85b1/_data<br/>total 4<br/>-rw-r--r-- 1 504 ftp 45 Jun 11  2007 index.html</span></pre><p id="84fc" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">从上面的输出中，您可以看到该卷的内容与容器的原始<code class="fe mw mx my mz b">/usr/local/apache2/htdocs</code>完全相同。此时，我们可以直接操作数据，因为<code class="fe mw mx my mz b">/usr/local/apache2/htdocs</code>不再是容器数据层。例如:</p><pre class="kh ki kj kk gu ns mz nt nu aw nv bi"><span id="842f" class="na lm ir mz b gz nw nx l ny nz">$ curl <a class="ae lk" href="http://127.0.0.1" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1</a><br/>&lt;html&gt;&lt;body&gt;&lt;h1&gt;It works!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;</span><span id="7821" class="na lm ir mz b gz og nx l ny nz">$ echo "New index file" &gt; /var/lib/docker/volumes/fe43eaa90cfc3773ef535ec9e0a094d0ab0477ceb74ddebd57d3620ab50e85b1/_data/index.html</span><span id="51e6" class="na lm ir mz b gz og nx l ny nz">$ curl <a class="ae lk" href="http://127.0.0.1" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1</a><br/>New index file</span></pre><p id="b76b" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">让我们简单回顾一下 docker 管理卷的创建过程:</p><ol class=""><li id="4190" class="mi mj ir kq b kr ks ku kv kx mk lb ml lf mm lj mn mo mp mq bi translated">当容器启动时，只需告诉 docker“我需要一个卷来存储数据，帮我把它挂载到目录<code class="fe mw mx my mz b">/abc</code>”。</li><li id="c93f" class="mi mj ir kq b kr mr ku ms kx mt lb mu lf mv lj mn mo mp mq bi translated">docker 在<code class="fe mw mx my mz b">/var/lib/docker/volumes</code>中生成一个随机目录作为挂载源。</li><li id="3296" class="mi mj ir kq b kr mr ku ms kx mt lb mu lf mv lj mn mo mp mq bi translated">如果<code class="fe mw mx my mz b">/abc</code>已经存在，将数据复制到挂载源，</li><li id="6197" class="mi mj ir kq b kr mr ku ms kx mt lb mu lf mv lj mn mo mp mq bi translated">将卷安装到<code class="fe mw mx my mz b">/abc</code></li></ol><p id="05cc" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">除了查看体积，我们还可以使用命令:<code class="fe mw mx my mz b">docker volume ls</code>和<code class="fe mw mx my mz b">docker volume inspect</code>。</p><pre class="kh ki kj kk gu ns mz nt nu aw nv bi"><span id="fccf" class="na lm ir mz b gz nw nx l ny nz">$ docker volume ls<br/>DRIVER    VOLUME NAME<br/>local     3fa47c2ae7a292a922b2233dc348f36fca679e601d65268d893e393d47a61537<br/>local     cd4fbf9aa8ef44c57717f361c85b1b62a1707898e3a19a79d5f073fe84f303e4<br/>local     fe43eaa90cfc3773ef535ec9e0a094d0ab0477ceb74ddebd57d3620ab50e85b1</span><span id="7ab5" class="na lm ir mz b gz og nx l ny nz">$ docker volume inspect fe43eaa90cfc3773ef535ec9e0a094d0ab0477ceb74ddebd57d3620ab50e85b1<br/>[<br/>    {<br/>        "CreatedAt": "2022-02-21T14:24:44Z",<br/>        "Driver": "local",<br/>        "Labels": null,<br/>        "Mountpoint": "/var/lib/docker/volumes/fe43eaa90cfc3773ef535ec9e0a094d0ab0477ceb74ddebd57d3620ab50e85b1/_data",<br/>        "Name": "fe43eaa90cfc3773ef535ec9e0a094d0ab0477ceb74ddebd57d3620ab50e85b1",<br/>        "Options": null,<br/>        "Scope": "local"<br/>    }<br/>]</span></pre><h1 id="e2bc" class="ll lm ir bd ln lo lp lq lr ls lt lu lv jx lw jy lx ka ly kb lz kd ma ke mb mc bi translated">结论</h1><p id="b559" class="pw-post-body-paragraph ko kp ir kq b kr md js kt ku me jv kw kx mf kz la lb mg ld le lf mh lh li lj ik bi translated">我们已经学习了两种数据量的原理和基本用法:<code class="fe mw mx my mz b">bind mount</code>和<code class="fe mw mx my mz b">docker managed volume</code>，我整理了一个表格，以便快速比较:</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="no np di nq bf nr"><div class="gi gj oh"><img src="../Images/da4df2ab33794fda95b8cd3d0e855bad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S7RemmkqBSGub6mDKtpyRw.png"/></div></div></figure></div></div>    
</body>
</html>