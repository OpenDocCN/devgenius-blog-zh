<html>
<head>
<title>Best of Modern JavaScript — Symbols API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">现代 JavaScript 的精华——符号 API</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/best-of-modern-javascript-symbols-api-e840bcadaef?source=collection_archive---------4-----------------------#2020-09-17">https://blog.devgenius.io/best-of-modern-javascript-symbols-api-e840bcadaef?source=collection_archive---------4-----------------------#2020-09-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/9116b8a558736b4bad20ac4aa3d40c38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Jjne1kwLo3w_iI2I"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">托马斯·塔克在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="ba95" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">自 2015 年以来，JavaScript 有了巨大的进步。</p><p id="c894" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在用起来比以前舒服多了。</p><p id="193a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究 JavaScript 符号。</p><h1 id="98c1" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">用符号穿越领域</h1><p id="f222" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">符号不能很好地跨领域传播。</p><p id="dd3c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于不同的帧中有不同的全局对象，我们不能跨帧使用它们。</p><p id="c1fd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像<code class="fe me mf mg mh b">Symbol.iterator</code>这样的特殊符号应该可以跨不同的领域使用。</p><p id="3909" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了获得跨不同领域的符号，我们可以使用<code class="fe me mf mg mh b">Symbol.for</code>方法获得带有字符串的符号。</p><p id="3684" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="2935" class="mq lc iq mh b gy mr ms l mt mu">const sym = Symbol.for('foo');</span></pre><p id="22f0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以调用<code class="fe me mf mg mh b">Symbol.keyFor</code>来获取我们传递给<code class="fe me mf mg mh b">Symbol</code>的字符串，以创建符号:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="9f29" class="mq lc iq mh b gy mr ms l mt mu">Symbol.keyFor(sym)</span></pre><p id="0ac9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像<code class="fe me mf mg mh b">Symbol.iterator</code>这样的特殊符号，如果我们用<code class="fe me mf mg mh b">Symbol.keyFor</code>调用它，就会返回<code class="fe me mf mg mh b">undefined</code>:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="5019" class="mq lc iq mh b gy mr ms l mt mu">Symbol.keyFor(Symbol.iterator)</span></pre><h1 id="0864" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">符号是原语还是对象？</h1><p id="f2d3" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">符号是原始值。</p><p id="4635" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">符号类似于字符串，因为它们可以用作属性键。</p><p id="0c5b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但它们就像物品一样，每个符号都有自己的身份。</p><p id="527a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们是不可变的，可以用作属性键。</p><p id="288b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，它没有像原型和包装器这样的对象的许多属性。</p><p id="e07b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">符号也不能被像<code class="fe me mf mg mh b">instance</code>或<code class="fe me mf mg mh b">Object.keys</code>这样的操作符和方法检查。</p><h1 id="efef" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">符号为什么有用？</h1><p id="66b9" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">符号有助于避免标识符冲突。</p><p id="8bf1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这很简单，因为我们不能创建同一个符号两次。</p><h1 id="3009" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">JavaScript 符号像 Ruby 的符号吗？</h1><p id="e2eb" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">JavaScript 和 Ruby 符号不一样。</p><p id="82f2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Ruby 符号是用于创建值的文字。</p><p id="d0bf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="7da7" class="mq lc iq mh b gy mr ms l mt mu">:foo<!-- --> <!-- -->==<!-- --> <!-- -->:foo</span></pre><p id="133b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后表达式返回<code class="fe me mf mg mh b">true</code>。</p><p id="a267" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">Symbol(‘foo’) !== Symbol(‘foo’)</code>返回<code class="fe me mf mg mh b">true</code>。</p><p id="d018" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以没有两个符号是相同的，即使我们传入了同一个参数。</p><h1 id="bd05" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">著名符号的拼写</h1><p id="8b1b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">众所周知的符号以这种方式拼写，因为它们被用作普通的属性键。</p><h1 id="a0e7" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">符号 API</h1><p id="4eec" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe me mf mg mh b">Symbol</code>是一个以字符串为描述的函数。</p><p id="38d4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们可以通过写来使用它:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="be9a" class="mq lc iq mh b gy mr ms l mt mu">const sym = Symbol('foo');</span></pre><p id="6e72" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">得到一个新的符号。</p><h1 id="3e14" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">符号方法</h1><p id="55b6" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">符号中唯一有用的方法是<code class="fe me mf mg mh b">toString</code>方法。</p><h1 id="b268" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">著名的符号</h1><p id="b045" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">有几个众所周知的可能对我们有用。</p><p id="901b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">Symbol.hasInstance</code>方法让一个对象定制<code class="fe me mf mg mh b">instanceof</code>操作符的行为。</p><p id="98b3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">Symbol.toPrimitive</code>是一种让我们自定义如何将其转换为原始值的方法。</p><p id="fd63" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是第一次陡降，每当某物被强制转换为原始值时。</p><p id="9d5d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">Symbol.toStringTag</code>是由<code class="fe me mf mg mh b">Object.prototype.toString</code>调用的方法，返回对象的字符串描述。</p><p id="c3c6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们可以覆盖它来提供我们自己的字符串描述。</p><p id="5768" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">Symbol.unscopables</code>是一个用<code class="fe me mf mg mh b">with</code>语句隐藏一些属性的方法。</p><p id="70ca" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">Symbol.iterator</code>是一个让我们定义自己的 iterable 来创建 iterable 对象的方法。</p><p id="5e7e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦我们添加了这个方法，我们就可以用 for-of 操作符迭代它。</p><h1 id="9865" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">字符串方法</h1><p id="ab1e" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">字符串方法被转发给具有给定符号的方法。</p><p id="3990" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们的转发方式如下:</p><ul class=""><li id="c76e" class="mv mw iq kf b kg kh kk kl ko mx ks my kw mz la na nb nc nd bi translated"><code class="fe me mf mg mh b">String.prototype.match(str, ...)</code>被转发给<code class="fe me mf mg mh b">str[Symbol.match]()</code>。</li><li id="d211" class="mv mw iq kf b kg ne kk nf ko ng ks nh kw ni la na nb nc nd bi translated"><code class="fe me mf mg mh b">String.prototype.replace(str, ...)</code>转发至<code class="fe me mf mg mh b">str[Symbol.replace]()</code>。</li><li id="5eab" class="mv mw iq kf b kg ne kk nf ko ng ks nh kw ni la na nb nc nd bi translated"><code class="fe me mf mg mh b">String.prototype.search(str, ...)</code>转发至<code class="fe me mf mg mh b">str[Symbol.search](···)</code>。</li><li id="71b9" class="mv mw iq kf b kg ne kk nf ko ng ks nh kw ni la na nb nc nd bi translated"><code class="fe me mf mg mh b">String.prototype.split(str, ...)</code>转发至<code class="fe me mf mg mh b">str[Symbol.split]()</code>。</li></ul><h1 id="32ee" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">其他特殊符号</h1><p id="f163" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe me mf mg mh b">Symbol.species</code>是配置内置方法来创建类似<code class="fe me mf mg mh b">this</code>的对象的方法。</p><p id="9c60" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">Symbol.isConcatSpreadable</code>是一个布尔值，用于配置<code class="fe me mf mg mh b">Array.prototype.concat</code>是否添加索引元素作为结果。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nj"><img src="../Images/87d3af73c1d1cbed3fc430a99e8326b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*v-2hYwnP6PzsD5Gl"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">梅丽莎·沃克·霍恩在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="d87c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="64a4" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用许多特殊符号来覆盖对象的行为。</p></div></div>    
</body>
</html>