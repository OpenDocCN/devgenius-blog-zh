<html>
<head>
<title>Reduce the size of your Node.js docker image by up to 90%</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将 Node.js docker 图像的大小缩小 90%</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/reduce-the-size-of-your-node-js-docker-image-by-up-to-90-53aad23890e2?source=collection_archive---------0-----------------------#2022-11-01">https://blog.devgenius.io/reduce-the-size-of-your-node-js-docker-image-by-up-to-90-53aad23890e2?source=collection_archive---------0-----------------------#2022-11-01</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="5e16" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">对你的下一个 Node.js docker 图像做一些简单的调整，这将大大减小图像的大小。</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/676022f2f7889cd3d816094ebca29e89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*luTuhYvnbScnF6-a"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@siora18?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Siora 摄影</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="a816" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">典型的 Node.js 映像的大小大约为 350MB。加上您的<em class="kz"> node_modules </em>和<em class="kz"> src </em>，这通常会超过 1 GB。有很多方法可以缩小你的图片</p><ul class=""><li id="afdd" class="la lb in jm b jn jo jr js jv lc jz ld kd le kh lf lg lh li bi translated">选择正确的基础图像</li><li id="c4d1" class="la lb in jm b jn lj jr lk jv ll jz lm kd ln kh lf lg lh li bi translated">仅安装生产依赖项</li><li id="8232" class="la lb in jm b jn lj jr lk jv ll jz lm kd ln kh lf lg lh li bi translated">使用多阶段构建</li><li id="1b92" class="la lb in jm b jn lj jr lk jv ll jz lm kd ln kh lf lg lh li bi translated">仅复制所需文件</li><li id="a62f" class="la lb in jm b jn lj jr lk jv ll jz lm kd ln kh lf lg lh li bi translated">修剪节点模块</li></ul><h1 id="4922" class="lo lp in bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">示例应用程序</h1><p id="a935" class="pw-post-body-paragraph jk jl in jm b jn mm jp jq jr mn jt ju jv mo jx jy jz mp kb kc kd mq kf kg kh ig bi translated">我们的示例应用程序是由<code class="fe mr ms mt mu b">npx create-react-app</code>创建的默认 react 应用程序，它通过 express 提供服务。我还添加了 eslint 作为开发依赖项。应用程序的代码可以在这里找到:<a class="ae ky" href="https://github.com/christopherscholz/reduce_node_docker_image_size/tree/main/context" rel="noopener ugc nofollow" target="_blank">https://github . com/Christopher scholz/reduce _ node _ docker _ image _ size/tree/main/context</a></p><p id="5d7b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在下面的内容中，我将不会更改应用程序代码，而只更改 Dockerfile 代码。</p><h1 id="c2df" class="lo lp in bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">选择正确的基础图像</h1><p id="77d7" class="pw-post-body-paragraph jk jl in jm b jn mm jp jq jr mn jt ju jv mo jx jy jz mp kb kc kd mq kf kg kh ig bi translated">首先，在创建 docker 文件时，我们可以从不同的节点 docker 映像中进行选择。最常见的标签是<em class="kz">最新</em>，是<em class="kz">当前</em>的别名，是<em class="kz">当前-靶心</em>的别名，是<em class="kz">靶心</em>的别名，是<a class="ae ky" href="https://hub.docker.com/layers/library/node/19.0.0-bullseye/images/sha256-2b00d259f3b07d8aa694b298a7dcf4655571aea2ab91375b5adb8e5a905d3ee2?context=explore" rel="noopener ugc nofollow" target="_blank"><em class="kz">19 . 0 . 0-靶心</em> </a>的别名，写这个故事的时候。对于我们所有的 docker 文件，我们将复制应用程序，安装 react 包，构建 react 并安装 express 包。对于牛眼文件来说，看起来是这样的</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">使用牛眼基础图像提供 express react 应用</figcaption></figure><p id="f8dd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在 amd64 上，此图像的大小为 1.4 GB，这将是我们的起始大小。</p><p id="aec5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">除了<em class="kz">牛眼</em>，我们还有<em class="kz">牛眼细长</em>和<em class="kz">高山</em>两种选择。如果我们仅将 Dockerfile 的<code class="fe mr ms mt mu b">FROM node:19.0.0-bullseye</code>语句更改为<code class="fe mr ms mt mu b">FROM <a class="ae ky" href="https://hub.docker.com/layers/library/node/19.0.0-bullseye-slim/images/sha256-978417e9dd45a1b7f673077d56fc54cb7bab98f6592f12fe7861d80a4669ad4a?context=explore" rel="noopener ugc nofollow" target="_blank">19.0.0-bullseye-slim</a></code>或<code class="fe mr ms mt mu b">FROM <a class="ae ky" href="https://hub.docker.com/layers/library/node/19.0.0-alpine3.16/images/sha256-e74f32d2a985f4d7d3ced0754bb1c40c68b6c0431043b154cb44127546e94f11?context=explore" rel="noopener ugc nofollow" target="_blank">19.0.0-alpine3.16</a></code>，我们会将图像分别缩小到 652.75 MB(整体缩小 53.4%)或 576.89 MB(整体缩小 58.8%，与之前相比缩小 11.6%)。</p><p id="7fab" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是最大也是最容易的尺寸缩减，但这还不是我们能做的全部。</p><h1 id="68bc" class="lo lp in bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">仅安装生产依赖项</h1><p id="0aa0" class="pw-post-body-paragraph jk jl in jm b jn mm jp jq jr mn jt ju jv mo jx jy jz mp kb kc kd mq kf kg kh ig bi translated">在下一步中，我们可以确保在构建 docker 映像时不添加开发依赖项。有多种方法可以做到这一点。我认为最简单的方法是将环境变量<em class="kz"> NODE_ENV </em>设置为<em class="kz"> production </em>。我们可以通过在<code class="fe mr ms mt mu b">FROM 19.0.0-alpine3.16</code>语句后添加行<code class="fe mr ms mt mu b">ENV NODE_ENV=production</code>来做到这一点。</p><p id="85a5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">通过这样做，我们有效地移除了<em class="kz"> eslint </em>包。这将图像缩小到 566.73 MB(整体缩小了 59.5%，与之前的优化相比缩小了 1.8%)</p><h1 id="1ffc" class="lo lp in bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">使用多阶段构建</h1><p id="40e7" class="pw-post-body-paragraph jk jl in jm b jn mm jp jq jr mn jt ju jv mo jx jy jz mp kb kc kd mq kf kg kh ig bi translated">另一种减少图像尺寸的方法是使用多阶段构建。想法是使用<em class="kz">构建器</em>映像构建应用程序，然后只将运行应用程序所需的文件复制到运行器<em class="kz">映像</em>中。</p><p id="b3b9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在我们的阿尔卑斯山图像的情况下，这可能看起来像这样</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">使用多阶段构建提供 express react 应用程序</figcaption></figure><p id="3b2a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这将 docker 映像的大小缩小到了 178.04 MB(总体减少了 87.3%，与之前的优化相比减少了 68.6%)。</p><p id="1e75" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="kz"> Alpine </em>不是我们能用的最小基础图像。一个真正的捆绑了<em class="kz"> Node.js </em>运行时的最小 Linux 是<a class="ae ky" href="https://github.com/GoogleContainerTools/distroless/blob/main/nodejs/README.md" rel="noopener ugc nofollow" target="_blank">distro less/nodejs 18-debian 11</a>。使用它的唯一方法是使用多阶段构建，因为我们只能<code class="fe mr ms mt mu b">COPY</code>文件到映像，而不能<code class="fe mr ms mt mu b">RUN</code>任何应用程序，因为没有安装 shell。<em class="kz"> Node.js </em>运行时也被最小化，因为它甚至删除了<em class="kz"> npm </em>和<em class="kz"> npx </em>。使用 distroless 映像的 docker 文件如下所示</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">使用多阶段构建和无发行版运行程序提供 express react 应用程序</figcaption></figure><p id="ef32" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这将 docker 映像的大小缩小到了 162.53 MB(总体减少了 88.4%，与之前的优化相比减少了 8.7%)。</p><h1 id="a5cd" class="lo lp in bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">仅复制所需文件</h1><p id="391d" class="pw-post-body-paragraph jk jl in jm b jn mm jp jq jr mn jt ju jv mo jx jy jz mp kb kc kd mq kf kg kh ig bi translated">我们可以通过确保只保存<code class="fe mr ms mt mu b">COPY</code>相关文件来进一步减小图像的大小。在最终的 docker 映像中构建相关文件也是一个常见的安全问题。</p><p id="0f6e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对于我们的应用程序，这意味着用</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">仅复制相关文件</figcaption></figure><p id="6d10" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在我们的例子中，这只删除了两个文件(。gitignore 和 package.json)，所以大小影响最小。新的大小为 162.41 MB(整体减少了 88.4%，比之前的优化减少了 0.1%)。</p><h1 id="2d3a" class="lo lp in bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">修剪节点模块</h1><p id="d554" class="pw-post-body-paragraph jk jl in jm b jn mm jp jq jr mn jt ju jv mo jx jy jz mp kb kc kd mq kf kg kh ig bi translated">我们可以自动化的另一个步骤是进一步删减 node_modules。https://github.com/tj/node-prune 工具<a class="ae ky" href="https://github.com/tj/node-prune" rel="noopener ugc nofollow" target="_blank">是一种简单的方法。我们只需要下载二进制文件并在 npom 包中运行它。根。我们可以用一个简单的语句来实现</a></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">使用 wget 下载，安装并运行节点清理</figcaption></figure><p id="3e60" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">或者如果我们使用带有卷曲的基本图像而不是 wget</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">使用 curl 下载，安装并运行节点修剪</figcaption></figure><p id="4ac7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是我们缩小图像尺寸的最后一步。最终大小为 161.44 MB(整体减少了 88.5%，比之前的优化减少了 0.6%)。最终的 docker 文件如下所示</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">为 te express react 应用程序提供优化的 Dockerfile 文件</figcaption></figure><p id="da6b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们可以通过手动检查我们可以删除的文件来更深入地了解这一点。分析图像的一个好方法是使用<a class="ae ky" href="https://github.com/wagoodman/dive" rel="noopener ugc nofollow" target="_blank">潜水</a>工具。</p><h1 id="0bd4" class="lo lp in bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">额外:通过选择更好的构建顺序显著加快构建速度</h1><p id="c0c2" class="pw-post-body-paragraph jk jl in jm b jn mm jp jq jr mn jt ju jv mo jx jy jz mp kb kc kd mq kf kg kh ig bi translated">docker 文件中的每条语句都会创建一个新层。图层被缓存。如果一个层发生变化，所有下游层也必须重建。因此，以这样一种方式构建 docker 文件是非常重要的，即经常更新的层在 docker 文件的末尾，而几乎静态的层在 docker 文件的开头。如果你聪明地使用这个原则，你可以显著地减少你的构建时间。</p><h1 id="9517" class="lo lp in bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">结论</h1><p id="7f01" class="pw-post-body-paragraph jk jl in jm b jn mm jp jq jr mn jt ju jv mo jx jy jz mp kb kc kd mq kf kg kh ig bi translated">我们将 docker 映像从 1.4 GB 降至 161.44 MB，降幅为 88.5%。</p><p id="7323" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了减小节点 docker 映像的大小并加快构建时间，您可以做很多事情。这些想法通常也适用于其他应用程序。例如，使用一个无发行版的映像可能会大大减少你的下一个 Rust 应用程序。</p><p id="40e5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我希望你发现这些想法很有趣，并能够将它们应用到你的下一个或当前项目中。</p><p id="f8b2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">也非常感谢以下故事的作者，他们帮助我学习了很多关于优化 docker 构建的知识</p><ul class=""><li id="6178" class="la lb in jm b jn jo jr js jv lc jz ld kd le kh lf lg lh li bi translated"><a class="ae ky" href="https://blog.tarkalabs.com/how-to-reduce-nodejs-docker-image-by-70-e799b3d3396a" rel="noopener ugc nofollow" target="_blank">如何将你的 Node.js docker 图片大小缩小 70% </a>作者<a class="mx my ep" href="https://medium.com/u/5c0d85235c3b?source=post_page-----53aad23890e2--------------------------------" rel="noopener" target="_blank">马达瓦雷迪 SV </a></li><li id="05f0" class="la lb in jm b jn lj jr lk jv ll jz lm kd ln kh lf lg lh li bi translated"><a class="ae ky" href="https://medium.com/trendyol-tech/how-we-reduce-node-docker-image-size-in-3-steps-ff2762b51d5a" rel="noopener">我们如何通过<a class="mx my ep" href="https://medium.com/u/18b9b9a2b09e?source=post_page-----53aad23890e2--------------------------------" rel="noopener" target="_blank">Soner kmen</a>分三步</a>缩小节点 Docker 图像大小</li><li id="ba14" class="la lb in jm b jn lj jr lk jv ll jz lm kd ln kh lf lg lh li bi translated"><a class="ae ky" href="https://medium.com/inside-sumup/stop-using-alpine-docker-images-fbf122c63010" rel="noopener">停止使用阿尔卑斯码头工人图片</a>由<a class="mx my ep" href="https://medium.com/u/e8ced5abda1?source=post_page-----53aad23890e2--------------------------------" rel="noopener" target="_blank">熊伟法尔考</a></li><li id="d44d" class="la lb in jm b jn lj jr lk jv ll jz lm kd ln kh lf lg lh li bi translated"><a class="ae ky" href="https://tsh.io/blog/reduce-node-modules-for-better-performance/" rel="noopener ugc nofollow" target="_blank">亲爱的，我把 node_modules 缩小了！…并提高了应用程序在此过程中的性能。关于节点模块大小</a></li><li id="3e23" class="la lb in jm b jn lj jr lk jv ll jz lm kd ln kh lf lg lh li bi translated"><a class="ae ky" href="https://tier.engineering/Tips-for-optimising-docker-build" rel="noopener ugc nofollow" target="_blank">优化 Docker 构建的技巧</a>作者<a class="ae ky" href="https://www.linkedin.com/in/abiodunjames/" rel="noopener ugc nofollow" target="_blank">詹姆斯·塞缪尔</a></li></ul></div></div>    
</body>
</html>