<html>
<head>
<title>IndexedDB Manipulation with Dexie — Sorting, Iteration, and Keys</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Dexie的IndexedDB操作—排序、迭代和键</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/indexeddb-manipulation-with-dexie-sorting-iteration-and-keys-cbafc314a1b5?source=collection_archive---------3-----------------------#2021-02-28">https://blog.devgenius.io/indexeddb-manipulation-with-dexie-sorting-iteration-and-keys-cbafc314a1b5?source=collection_archive---------3-----------------------#2021-02-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/158e380492f188cb018849c28cf96e11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-0_KzcngTk8wL1a2"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">弗洛里安·伯杰在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><p id="faa2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">IndexedDB是在浏览器中存储数据的一种方式。</p><p id="f967" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它允许我们以异步方式存储比本地存储更多的数据。</p><p id="d713" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Dexie使得使用IndexedDB更加容易。</p><p id="bfd0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将了解如何使用Dexie开始使用IndexedDB。</p><h1 id="3582" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">反转收集结果的顺序</h1><p id="b4fc" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用<code class="fe me mf mg mh b">reverse</code>方法颠倒收集结果的顺序。</p><p id="30af" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="318c" class="mq lc iq mh b gy mr ms l mt mu">const db = new Dexie("friends");<br/>db.version(1).stores({<br/>  friends: "id, name, age"<br/>});<br/>(async () =&gt; {<br/>  await db.friends.put({<br/>    id: 1,<br/>    name: "jane",<br/>    age: 78<br/>  });<br/>  await db.friends.put({<br/>    id: 2,<br/>    name: "mary",<br/>    age: 76<br/>  });<br/>  const friends = await db.friends<br/>    .toCollection()<br/>    .reverse()<br/>    .toArray()<br/>  console.log(friends)<br/>})()</span></pre><p id="4b8a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">获取所有项目，然后颠倒返回的顺序。</p><h1 id="d98b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">按给定字段排序</h1><p id="9ba5" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以调用<code class="fe me mf mg mh b">sortBy</code>方法按照给定的字段进行排序。</p><p id="d59c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="d5b4" class="mq lc iq mh b gy mr ms l mt mu">const db = new Dexie("friends");<br/>db.version(1).stores({<br/>  friends: "id, name, age"<br/>});<br/>(async () =&gt; {<br/>  await db.friends.put({<br/>    id: 1,<br/>    name: "jane",<br/>    age: 78<br/>  });<br/>  await db.friends.put({<br/>    id: 2,<br/>    name: "mary",<br/>    age: 76<br/>  });<br/>  const friends = await db.friends<br/>    .where('age')<br/>    .above(25)    <br/>    .sortBy('age');<br/>  console.log(friends)<br/>})()</span></pre><p id="c236" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用<code class="fe me mf mg mh b">sortBy</code>方法通过<code class="fe me mf mg mh b">age</code>对结果进行排序。</p><h1 id="7a6e" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">将集合转换为数组</h1><p id="68fe" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用<code class="fe me mf mg mh b">toArray</code>方法将集合转换成数组。</p><p id="a8c3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="e1cc" class="mq lc iq mh b gy mr ms l mt mu">const db = new Dexie("friends");<br/>db.version(1).stores({<br/>  friends: "id, name, age"<br/>});<br/>(async () =&gt; {<br/>  await db.friends.put({<br/>    id: 1,<br/>    name: "jane",<br/>    age: 78<br/>  });<br/>  await db.friends.put({<br/>    id: 2,<br/>    name: "mary",<br/>    age: 76<br/>  });<br/>  const friends = await db.friends<br/>    .where('age')<br/>    .above(25)    <br/>    .toArray();<br/>  console.log(friends)<br/>})()</span></pre><p id="cebb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们使用<code class="fe me mf mg mh b">toArray</code>方法将查询方法返回的集合转换为带有数组的承诺。</p><h1 id="ae82" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">获取唯一键</h1><p id="99ba" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用<code class="fe me mf mg mh b">uniqueKeys</code>方法从一个集合中获得唯一的键。</p><p id="7b1b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="8e41" class="mq lc iq mh b gy mr ms l mt mu">const db = new Dexie("friends");<br/>db.version(1).stores({<br/>  friends: "id, name, age"<br/>});<br/>(async () =&gt; {<br/>  await db.friends.put({<br/>    id: 1,<br/>    name: "jane",<br/>    age: 78<br/>  });<br/>  await db.friends.put({<br/>    id: 2,<br/>    name: "mary",<br/>    age: 76<br/>  });<br/>  const keys = await db.friends<br/>    .toCollection()<br/>    .uniqueKeys()<br/>  console.log(keys)<br/>})()</span></pre><p id="4fc5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们调用<code class="fe me mf mg mh b">uniqueKeys</code>从集合中获取唯一的键。</p><p id="e553" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们从集合中获取<code class="fe me mf mg mh b">id</code>值。</p><p id="22d1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们得到:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="9dbc" class="mq lc iq mh b gy mr ms l mt mu">[1, 2]</span></pre><p id="d6cf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从控制台日志中。</p><h1 id="2c2c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">一旦给定的过滤器返回true，停止迭代集合</h1><p id="5d2c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">一旦给定的过滤器是<code class="fe me mf mg mh b">true</code>，我们可以调用<code class="fe me mf mg mh b">until</code>方法来停止迭代集合。</p><p id="de7e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以这样使用它:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="3ef4" class="mq lc iq mh b gy mr ms l mt mu">const db = new Dexie("friends");<br/>let cancelled = false;</span><span id="969c" class="mq lc iq mh b gy mv ms l mt mu">db.version(1).stores({<br/>  friends: "id, name, age"<br/>});<br/>(async () =&gt; {<br/>  await db.friends.put({<br/>    id: 1,<br/>    name: "jane",<br/>    age: 78<br/>  });<br/>  await db.friends.put({<br/>    id: 2,<br/>    name: "mary",<br/>    age: 76<br/>  });<br/>  await db.friends<br/>    .toCollection()<br/>    .until(() =&gt; cancelled)<br/>    .each(friend =&gt; {<br/>      console.log(friend)<br/>      cancelled = true;<br/>    });<br/>})()</span></pre><p id="cca7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用一个回调函数调用<code class="fe me mf mg mh b">until</code>，该回调函数返回<code class="fe me mf mg mh b">cancelled</code>的值。</p><p id="287f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们调用<code class="fe me mf mg mh b">each</code>并记录<code class="fe me mf mg mh b">friend</code>的值，然后我们从<code class="fe me mf mg mh b">cancelled</code>到<code class="fe me mf mg mh b">true</code>。</p><p id="fd52" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以在第一次迭代<code class="fe me mf mg mh b">each</code>之后，它将停止遍历集合的其余部分。</p><h1 id="d81b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="6490" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以对项目进行排序，将项目转换为数组，获得唯一的键，并使用Dexie停止给定条件下的迭代。</p></div></div>    
</body>
</html>