<html>
<head>
<title>Angular dependency injection into the constructor</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构造函数中的角度依赖注入</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/angular-dependency-injection-de5ce8ec0961?source=collection_archive---------5-----------------------#2022-08-08">https://blog.devgenius.io/angular-dependency-injection-de5ce8ec0961?source=collection_archive---------5-----------------------#2022-08-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="ffcf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">重构总比不重构好。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7b1639fd3f1d92f59ffce01fb84802ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rQb8_bCaWx25TdYhQIF34A.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">华金·索罗拉，印象派，1908 年，“巴伦西亚海滩的下午”</figcaption></figure><p id="0ced" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有时这是一个选择什么的问题:每次我们调用方法时创建一个类的实例。或者在构造函数中声明一次。</p><p id="af0e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">一些实用的理论迪。</strong></p><p id="f56e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果我们将类的实例传递给构造函数，就可以减少代码字符串的数量和维护工作。<strong class="jm io">构造函数</strong>是类被实例化时执行的类的默认方法。构造函数基本上确保所有的类变量都被正确初始化。它也用于<strong class="jm io">依赖注入</strong>，以我的<strong class="jm io"> </strong> <code class="fe ky kz la lb b">CurrencyChangeService </code>为例如下:</p><pre class="kj kk kl km gt lc lb ld le aw lf bi"><span id="9353" class="lg lh in lb b gy li lj l lk ll">private readonly destroy$: Subject&lt;void&gt; = new Subject();<br/>private currencyResult: CalculationResult;</span><span id="bbb2" class="lg lh in lb b gy lm lj l lk ll">constructor(private readonly currencyServ: CurrencyChangeService) {}</span><span id="c6bc" class="lg lh in lb b gy lm lj l lk ll">ngOnInit() { // lifecycle first hook called right after constructor</span><span id="851f" class="lg lh in lb b gy lm lj l lk ll">  //and use it in the code just like this:<br/>  this.currencyServ.convert()<br/>    <!-- -->.takeUntil(this.destroy$)<br/>    .subscribe(response =&gt; this.<!-- -->currencyResult = response<!-- -->);<br/>}</span></pre><p id="d7a7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">依赖注入(DI)是根据依赖关系自动创建对象。这是坚实原则的支柱之一。</p><pre class="kj kk kl km gt lc lb ld le aw lf bi"><span id="6a49" class="lg lh in lb b gy li lj l lk ll">private result: MyModelResult;<br/>constructor(myService: MyService) {<br/>   this.result = myService.calculateResult(); <br/>}</span></pre><p id="2656" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">每次调用当前类时，Angular injector 都会注入一个 MyService 实例。Angular 观察构造函数参数，它通过调用 new MyService()创建一个新的实例。他寻找与构造函数参数的类型相匹配的提供者，解析它们并将它们传递给构造函数，如 new MyService(param)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ln"><img src="../Images/aee45b15018983ff8d00c88dd6b1b315.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*TWXUh1XYsENZwhdY-3xqiw.png"/></div></figure><p id="678e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">现在是时候观察一些实际的重构任务了。</strong></p><p id="d124" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">假设我们有一个方法 calculateMyCharges，它通过每次调用函数来创建自己的 ChargeCalculation 类实例。</p><p id="af66" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这不是一个最佳的解决方案:我们不应该在每次调用方法时都创建一个新的服务实例。让我们调整一下，calculateMyCharges 函数将汇率作为参数。以此类推其他参数。只使用 DI 来注入服务和类似的类。</p><p id="81b8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">重构前的代码:</p><pre class="kj kk kl km gt lc lb ld le aw lf bi"><span id="81da" class="lg lh in lb b gy li lj l lk ll">export interface CalculationResult {<br/>  calculatedCharges: CalcOutput[];<br/>}<br/>@Injectable({<br/>  providedIn: "root"<br/>})<br/>export class ChargeService {<br/>  constructor(private readonly logger: LoggerService) {}</span><span id="9987" class="lg lh in lb b gy lm lj l lk ll">  calculateMyCharges(myCharge: Charge,<br/>    <!-- -->exchangeRates: ExchangeRate[]<!-- -->): <!-- -->CalculationResult<!-- --> {</span><span id="9e11" class="lg lh in lb b gy lm lj l lk ll"><strong class="lb io">    // created each time<br/>    const calculator = new ChargeCalculator(<br/>      new CurrencyChangeService(this.logger));</strong></span><span id="4f34" class="lg lh in lb b gy lm lj l lk ll">    return calculator.calculate(myCharge, exchangeRates);<br/>  }<br/>}</span></pre><p id="d3a0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">解决方案是移走类的实例创建:</p><pre class="kj kk kl km gt lc lb ld le aw lf bi"><span id="0281" class="lg lh in lb b gy li lj l lk ll">const calculator = new ChargeCalculator(<br/>  new CurrencyChangeService(this.logger));</span></pre><p id="b141" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">重构后，我们会得到这样的结果:</p><pre class="kj kk kl km gt lc lb ld le aw lf bi"><span id="ae7b" class="lg lh in lb b gy li lj l lk ll">@Injectable({<br/>  providedIn: "root"<br/>})<br/>export class ChargeService {<br/>  constructor(private readonly logger: LoggerService,<br/>    private readonly chargeCalculation: ChargeCalculator) {}</span><span id="2c93" class="lg lh in lb b gy lm lj l lk ll">    calculateMyCharges(myCharge: Charge,<br/>      <!-- -->exchangeRates: ExchangeRate[]<!-- -->): <!-- -->CalculationResult<!-- --> {<br/>    <br/>    return this.chargeCalculator.calculate(myCharge, exchangeRates);<br/>  }<br/>}</span></pre><p id="aa2a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们的类将从映射器中这样调用:</p><pre class="kj kk kl km gt lc lb ld le aw lf bi"><span id="0f66" class="lg lh in lb b gy li lj l lk ll">export class MainMapperAssembler {<br/>  private readonly chargeService =<br/>    new ChargeService(this.logger, this.chargeCalculator);</span><span id="0770" class="lg lh in lb b gy lm lj l lk ll">  constructor(private readonly chargeCalculator: ChargeCalculator) {}</span><span id="4c05" class="lg lh in lb b gy lm lj l lk ll">  callMyCalculateMethod() {  <br/>    this.chargeService.calculateMyCharges(<br/>      selectedCharge, exchangeRates);</span><span id="25de" class="lg lh in lb b gy lm lj l lk ll">    ...<br/>  }<br/>}</span></pre><p id="9c6d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了避免"<code class="fe ky kz la lb b">NullInjectorError: No provider for ChargeCalculator!</code>"的问题，我们必须在 ChargeCalculator 类的顶部添加@ Injectable:</p><pre class="kj kk kl km gt lc lb ld le aw lf bi"><span id="e22d" class="lg lh in lb b gy li lj l lk ll">@Injectable({<br/>  providedIn: "root"<br/>})</span></pre><p id="a9e3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Angular 不是向导:我们必须手动将值写入“providedIn”属性。因此，用@ Injectable 修饰的 ChargeCalculator 的一个简单变体意味着我们在应用程序中注册服务。</p><pre class="kj kk kl km gt lc lb ld le aw lf bi"><span id="43b1" class="lg lh in lb b gy li lj l lk ll">@Injectable({<br/>  providedIn: "root"<br/>})<br/>export class ChargeCalculator {<br/>  exchangeRates: ExchangeRate[];<br/><br/>  constructor(private readonly currencyChangeService: CurrencyChangeService) {}<br/><br/>  calculate(exchangeRate: ExchangeRate[]): CalculationResult {</span><span id="a15d" class="lg lh in lb b gy lm lj l lk ll">    const chargePrice = this.currencyChangeService<br/>      .convertPrice(this.exchangeRates);</span><span id="d762" class="lg lh in lb b gy lm lj l lk ll">    ...<br/>  }<br/>}</span></pre><p id="c103" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Angular 中所有注册的依赖项都可以被限定范围。他们分成三组:</p><ol class=""><li id="0981" class="lo lp in jm b jn jo jr js jv lq jz lr kd ls kh lt lu lv lw bi translated">根级别的范围是整个项目。实例在所有模块和组件之间共享。向您计划提供或注入的任何东西添加一个@ Injectable 装饰器。</li></ol><pre class="kj kk kl km gt lc lb ld le aw lf bi"><span id="0644" class="lg lh in lb b gy li lj l lk ll">@Injectable({<br/>  providedIn: 'root'<br/>})</span></pre><p id="5e41" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">2.模块——延迟加载模块中提供的实例在模块的组件之间共享。这里的“Logger”是一个注入令牌，注入器用它来标识类。</p><pre class="kj kk kl km gt lc lb ld le aw lf bi"><span id="3a48" class="lg lh in lb b gy li lj l lk ll">@NgModule({<br/>  declarations: [AppComponent],<br/>  imports: [ApiModule],<br/>  providers: [{ provide: Logger, useClass: Logger }]<br/>})</span></pre><p id="a5e7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">3.组件-注入到组件中的实例在组件的生命周期中存在。UseValue 属性用于设置特定值:</p><pre class="kj kk kl km gt lc lb ld le aw lf bi"><span id="33a9" class="lg lh in lb b gy li lj l lk ll">@Component({<br/>  providers: [<br/>    { provide: MyService, useValue: { request: 'test' } },<br/>    <!-- -->{ provide: MyService2, useValue: () =&gt; { <strong class="lb io">return</strong> 'test' } },<br/>    { provide: 'array', useValue: [10, 20] } }<br/>  ]<br/>})</span></pre><p id="dc87" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">结论</strong></p><p id="5b9d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Angular 中内置的依赖注入是一种非常简单明了的方法。本文只是描述了一些实践经验，并不是整个 DI 概念。</p><p id="c94e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">链接</strong></p><div class="lx ly gp gr lz ma"><a href="https://indepth.dev/posts/1148/how-to-avoid-angular-injectable-instances-duplication" rel="noopener  ugc nofollow" target="_blank"><div class="mb ab fo"><div class="mc ab md cl cj me"><h2 class="bd io gy z fp mf fr fs mg fu fw im bi translated">如何避免角注射实例重复-角深度</h2><div class="mh l"><h3 class="bd b gy z fp mf fr fs mg fu fw dk translated">这个主题在其他文章和文档中被反复描述过，但是当我面对这个问题时，我仍然…</h3></div><div class="mi l"><p class="bd b dl z fp mf fr fs mg fu fw dk translated">深度开发</p></div></div><div class="mj l"><div class="mk l ml mm mn mj mo ks ma"/></div></div></a></div><div class="lx ly gp gr lz ma"><a href="https://angular.io/guide/dependency-injection-providers" rel="noopener  ugc nofollow" target="_blank"><div class="mb ab fo"><div class="mc ab md cl cj me"><h2 class="bd io gy z fp mf fr fs mg fu fw im bi translated">有角的</h2><div class="mh l"><h3 class="bd b gy z fp mf fr fs mg fu fw dk translated">Angular 是一个构建移动和桌面 web 应用程序的平台。加入数百万开发者的社区…</h3></div><div class="mi l"><p class="bd b dl z fp mf fr fs mg fu fw dk translated">angular.io</p></div></div></div></a></div></div></div>    
</body>
</html>