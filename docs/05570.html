<html>
<head>
<title>Go tutorial: Build a card game with Golang</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">围棋教程:用Golang构建一个卡牌游戏</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/go-tutorial-build-a-card-game-with-golang-111cee17ed2?source=collection_archive---------3-----------------------#2021-09-10">https://blog.devgenius.io/go-tutorial-build-a-card-game-with-golang-111cee17ed2?source=collection_archive---------3-----------------------#2021-09-10</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/23ce603e3a146e9d98c8540a04f45695.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rmQDMHYo5VXDmKmFN4i4KA.png"/></div></div></figure><p id="6576" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Golang，或Go，是许多顶级科技公司使用的流行编程语言。如果你梦想为这些顶级公司之一工作，对他们使用的编程语言有经验是很重要的。学习任何编程语言的最好方法是一头扎进去，获得真实的实践经验。一个可靠的编码项目组合可以帮助展示你在编程语言方面的技能和经验。今天，我们将带您了解一个真实的围棋组合项目。</p><p id="7ced" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们开始吧！</p><p id="9f04" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">我们将讲述</strong>:</p><ul class=""><li id="6caa" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated">项目描述</li><li id="ffcc" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">建筑特色1</li><li id="2a3d" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">建筑特色2</li><li id="6691" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">项目总结和相关面试问题</li><li id="bfb7" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">后续步骤</li></ul><h1 id="1519" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">项目描述</h1><p id="7b3c" class="pw-post-body-paragraph jv jw in jx b jy mf ka kb kc mg ke kf kg mh ki kj kk mi km kn ko mj kq kr ks ig bi translated">纸牌游戏在全世界都很流行，不同年龄的人都玩不同的纸牌游戏。比方说，你为一家初创公司工作，该公司希望创建一个web应用程序来玩不同的纸牌游戏。他们想设计常见的游戏，如扑克和纸牌，也想创造自己独特的游戏。所有的游戏都可以在单人或多人模式下进行。由于会有单人选项，所以你的团队需要创造一个“对手”来对抗用户。</p><p id="cfaf" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">该项目的第一部分包括实现一个功能，帮助用户<strong class="jx io">玩一种扑克</strong>。你将不得不设计的功能，以便它可以确定是否一个给定的手牌是一手顺子或不是。项目的第二部分包括为一款名为<em class="mk"> Fizzle </em>的<strong class="jx io">定制卡牌游戏</strong>创建一个功能。你将不得不设计的功能，使用户可以找到最大的点，可以通过挑选出一套10张随机卡卡。</p><h1 id="5e90" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">特征</h1><ul class=""><li id="534a" class="kt ku in jx b jy mf kc mg kg ml kk mm ko mn ks ky kz la lb bi translated"><strong class="jx io">功能1 </strong>:判断是否可以拿到一手顺子。</li><li id="3664" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated"><strong class="jx io">特点2 </strong>:从一组十张随机牌中找出可以获得的最大点数。现在你知道了背景，让我们开始制作第一个特性吧！</li></ul><h1 id="61c0" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">建筑特色1</h1><p id="f059" class="pw-post-body-paragraph jv jw in jx b jy mf ka kb kc mg ke kf kg mh ki kj kk mi km kn ko mj kq kr ks ig bi translated">对于功能#1，我们正在开发一个与一手顺子有关的扑克游戏变体。在传统扑克中，玩家有五张牌(称为<strong class="jx io"> <em class="mk">手牌</em> </strong>)。通常，一手顺子牌由五张顺序排列的牌组成，如<em class="mk"> 9 </em>、<em class="mk"> 8 </em>、<em class="mk"> 7 </em>、<em class="mk"> 6 </em>和<em class="mk"> 5 </em>。</p><p id="5198" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在我们新推出的扑克游戏中，数字k将由掷骰子决定。如果骰子掷出1，应该再掷一次。这样，<em class="mk"> k </em>将始终在2–6的范围内。只有在使用给定手牌中的所有牌可以组成<em class="mk"> k </em>套牌的情况下，<strong class="jx io">手顺子</strong>才有可能。</p><h1 id="bd89" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">例子</h1><figure class="mp mq mr ms gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mo"><img src="../Images/8b1f6ecb8ef553ce9bd0e136a805351f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UygNszGR8pIXH5JHYGeJ3Q.png"/></div></div></figure><p id="c1aa" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在上面的例子中，我们可以看到我们拿到了一手九张牌。骰子掷出一个3，那么<em class="mk"> k </em>就是<strong class="jx io"> 3 </strong>。然后，卡片被分成三组。每组包含三张按顺序排列的卡片。在实现过程中，我们将在一个数组中接收这些卡片，就像<code class="fe mt mu mv mw b">{10, 3, 6, 2, 13, 12, 5, 4, 7}</code>一样。杰克牌、国王牌和王后牌分别用11、12和13表示。掷骰子后的数字是整数。如果能形成一手直道，模块应返回<code class="fe mt mu mv mw b">true</code>。如果不能形成一手顺子，就应该返回<code class="fe mt mu mv mw b">false</code>。</p><h1 id="396b" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">解决办法</h1><p id="0d00" class="pw-post-body-paragraph jv jw in jx b jy mf ka kb kc mg ke kf kg mh ki kj kk mi km kn ko mj kq kr ks ig bi translated">解决方案背后的共同直觉是尝试和<strong class="jx io">形成大小为*k </strong> <em class="mk">的组，从最低的牌开始。一旦确定了最低的牌，只有最低的牌在*k大小的</em>组的底端，才有可能拿到一手顺子。例如，如果<em class="mk"> k </em>是<em class="mk"> 4 </em>，最低的牌是<em class="mk"> 2 </em>，我们知道该组将是<em class="mk"> 2、3、4、5 </em>。如果我们找不到这一组，这手牌就不是顺子牌。</p><p id="a6ed" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们开始编写特性代码吧！我们将把解决方案分成几个步骤。在我们开始之前，我们需要导入适当的包，这样我们可以在最后测试我们的代码。</p><pre class="mp mq mr ms gt mx mw my mz aw na bi"><span id="aadb" class="nb li in mw b gy nc nd l ne nf">package main<br/>import (<br/>  "fmt"<br/>  "sort"<br/>)</span></pre><p id="62d4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">第一步</strong>:设置功能。</p><pre class="mp mq mr ms gt mx mw my mz aw na bi"><span id="f19d" class="nb li in mw b gy nc nd l ne nf">func isHandOfStraights(hand []int, k int) bool{</span></pre><p id="01e7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">第二步</strong>:检查手中的牌数是否能被<em class="mk"> k </em>整除。如果没有，我们就不能创建组，所以返回<code class="fe mt mu mv mw b">false</code>。</p><pre class="mp mq mr ms gt mx mw my mz aw na bi"><span id="04cd" class="nb li in mw b gy nc nd l ne nf"> if len(hand) % k != 0{<br/>    return false<br/> }</span></pre><p id="3805" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">第三步</strong>:统计给定手牌中每张牌的出现次数。</p><pre class="mp mq mr ms gt mx mw my mz aw na bi"><span id="cb5a" class="nb li in mw b gy nc nd l ne nf"> count := make(map[int]int)<br/> for _, i := range hand{<br/>   count[i] = count[i] + 1<br/> }</span></pre><p id="3045" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">第四步</strong>:对列表进行排序，从排名最低的卡片开始遍历。我们可以使用哈希映射，将卡号存储为键，将出现次数存储为值。</p><pre class="mp mq mr ms gt mx mw my mz aw na bi"><span id="ed92" class="nb li in mw b gy nc nd l ne nf"> sort.Ints(hand)<br/> i := 0<br/> n := len(hand)</span></pre><p id="5ab7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">步骤5 </strong>:使用运行<em class="mk"> k </em>次的嵌套循环。</p><pre class="mp mq mr ms gt mx mw my mz aw na bi"><span id="b067" class="nb li in mw b gy nc nd l ne nf">   for i &lt; n {<br/>       current := hand[i]<br/>       for j := 0; j &lt; k; j++ {</span></pre><p id="77bc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">步骤5.1 </strong>:检查当前卡片和下一张<em class="mk"> k-1 </em>卡片(按升序排列)是否在<code class="fe mt mu mv mw b">count</code>地图中。如果不存在，返回<code class="fe mt mu mv mw b">false</code>。</p><pre class="mp mq mr ms gt mx mw my mz aw na bi"><span id="5898" class="nb li in mw b gy nc nd l ne nf">    if _, ok := count[current + j]; !ok || count[current + j] == 0 {<br/>       return false<br/>}</span></pre><p id="ca70" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">步骤5.2 </strong>:当找到每张需要的卡片时，减少其在<code class="fe mt mu mv mw b">count</code>中的出现次数。</p><pre class="mp mq mr ms gt mx mw my mz aw na bi"><span id="b857" class="nb li in mw b gy nc nd l ne nf">       count[current + j]--<br/>    }</span></pre><p id="7f78" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">步骤5.3 </strong>:找到一个完整的组后，使用while循环找到下一个组的最小卡片，并确定<code class="fe mt mu mv mw b">count</code>中的下一张卡片的出现次数是否超过零。</p><pre class="mp mq mr ms gt mx mw my mz aw na bi"><span id="b80f" class="nb li in mw b gy nc nd l ne nf">      for i &lt; n &amp;&amp; count[hand[i]] == 0{<br/>          i++<br/>       }<br/>    }</span></pre><p id="1612" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">第6步</strong>:如果所有卡片都被分类成组，返回<code class="fe mt mu mv mw b">true</code>。</p><pre class="mp mq mr ms gt mx mw my mz aw na bi"><span id="8634" class="nb li in mw b gy nc nd l ne nf">  return true<br/>}</span></pre><p id="2688" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，让我们用两只手来测试我们的功能。</p><pre class="mp mq mr ms gt mx mw my mz aw na bi"><span id="c3e0" class="nb li in mw b gy nc nd l ne nf">package main<br/>import (<br/>  "fmt"<br/>  "sort"<br/>)<br/>func isHandOfStraights(hand []int, k int) bool{<br/>    if len(hand) % k != 0{<br/>        return false<br/>    }<br/><br/>    count := make(map[int]int)<br/>    for _, i := range hand{<br/>        count[i] = count[i] + 1<br/>    }<br/><br/>    sort.Ints(hand)<br/>    i := 0<br/>    n := len(hand)<br/><br/>    for i &lt; n {<br/>        current := hand[i]<br/>        for j := 0; j &lt; k; j++ {<br/>            if _, ok := count[current + j]; !ok || count[current + j] == 0 {<br/>                return false<br/>            }<br/>            count[current + j]--<br/>        }<br/>        for i &lt; n &amp;&amp; count[hand[i]] == 0{<br/>            i++<br/>        }<br/>    }<br/>    return true<br/>}<br/><br/>func main() {<br/>    hand := []int{5,2,4,4,1,3,5,6,3}<br/>    k := 3<br/>    fmt.Println(isHandOfStraights(hand, k))<br/><br/>    hand2 := []int{1,9,3,5,7,4,2,9,11}<br/>    k = 2<br/>    fmt.Println(isHandOfStraights(hand2, k))<br/>}<br/><br/>=&gt; true<br/>=&gt; false</span></pre><h1 id="7196" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">建筑特色2</h1><p id="b974" class="pw-post-body-paragraph jv jw in jx b jy mf ka kb kc mg ke kf kg mh ki kj kk mi km kn ko mj kq kr ks ig bi translated">对于第二个功能，我们正在开发一款名为<em class="mk"> Fizzle </em>的定制卡牌游戏。在这个游戏中，庄家洗一副牌，然后将所有面朝上的牌展开。然后，玩家轮流掷骰子。摇出来的数字是<em class="mk"> k </em>。然后玩家将轮流从这副牌中<strong class="jx io">取出<em class="mk"> k </em>张</strong>牌，但他们只能从牌的左侧<strong class="jx io">或右侧</strong>中选择牌。目标是选出分数最高的牌。每张牌都有与其号码相对应的分值，正面牌:杰克、皇后、国王和王牌分别有11、12、13和14分。</p><p id="2424" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们想为<em class="mk"> Fizzle </em>玩家创建一个功能，该功能分析该副牌的当前状态和玩家掷出的数字，并且<strong class="jx io">决定玩家在该回合可以获得的最高分数</strong>。</p><h1 id="db0c" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">例子</h1><figure class="mp mq mr ms gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ng"><img src="../Images/8c83af4711d8bb508efab00eb233ad2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vJf-Eg6eKRqRWfX2s4f6Cg.png"/></div></div></figure><p id="0451" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在上面的例子中，玩家选择卡<code class="fe mt mu mv mw b">5</code>、<code class="fe mt mu mv mw b">3</code>、<code class="fe mt mu mv mw b">6</code>和<code class="fe mt mu mv mw b">3</code>来获得可能的最大点数。在实现过程中，我们会得到一副数组形式的卡片，就像<code class="fe mt mu mv mw b">{5, 3, 4, 4, 2, 3, 4, 6, 3}</code>。我们掷骰子后得到的数字将作为整数给出。该模块应该返回整数形式的最大点数。</p><h1 id="68d4" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">解决办法</h1><p id="100c" class="pw-post-body-paragraph jv jw in jx b jy mf ka kb kc mg ke kf kg mh ki kj kk mi km kn ko mj kq kr ks ig bi translated">为了实现这一功能，我们需要测试<strong class="jx io">每一种可能的组合</strong>，在这些组合中<em class="mk"> k </em>张牌可以从左侧或右侧从这副牌中取出。我们不能从右边(或左边)挑第<em class="mk">n *张牌，除非从右边(或左边)挑第(*n </em> — 1)张牌。如果我们从右边选了1张k  — 1张，那么从左边选1张，以此类推。我们可以通过<strong class="jx io">找到所有可能的组合，假设滑动窗口</strong>的大小为<em class="mk"> k </em>从右向左环绕。输出将是通过尝试所有可能的组合找到的最大和。</p><p id="1d06" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们开始编码这个特性吧！我们将把它分成几个步骤。在我们开始之前，我们需要导入适当的包，这样我们可以在最后测试我们的代码。</p><pre class="mp mq mr ms gt mx mw my mz aw na bi"><span id="4419" class="nb li in mw b gy nc nd l ne nf">package main<br/>import (<br/>  "fmt"<br/>  "math"<br/>)</span></pre><p id="da8f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">第一步</strong>:设置功能。</p><pre class="mp mq mr ms gt mx mw my mz aw na bi"><span id="24c6" class="nb li in mw b gy nc nd l ne nf">func maxPoints(deck []int, k int) int{<br/>    left := 0;<br/>    right := len(deck) - k<br/>    var total, best int<br/>    total = 0</span></pre><p id="2226" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">第二步</strong>:假设右边的<em class="mk"> k </em>牌给我们最大点数。</p><pre class="mp mq mr ms gt mx mw my mz aw na bi"><span id="e99b" class="nb li in mw b gy nc nd l ne nf">for i := right; i &lt; len(deck); i++ {<br/>        total += deck[i]<br/>    }<br/>    best = total</span></pre><p id="6913" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">步骤3 </strong>:使用运行<em class="mk"> k </em>次的循环，测试所有组合。</p><pre class="mp mq mr ms gt mx mw my mz aw na bi"><span id="0bb6" class="nb li in mw b gy nc nd l ne nf">    for i := 0; i &lt; k; i++ {</span></pre><p id="e4b1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">第四步</strong>:去掉右边卡片的点，加上左边的点。</p><pre class="mp mq mr ms gt mx mw my mz aw na bi"><span id="48c4" class="nb li in mw b gy nc nd l ne nf">        total += deck[left] - deck[right]</span></pre><p id="3429" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">第五步</strong>:将<code class="fe mt mu mv mw b">total</code>点与当前<code class="fe mt mu mv mw b">best</code>点进行比较，保留最大值。</p><pre class="mp mq mr ms gt mx mw my mz aw na bi"><span id="251c" class="nb li in mw b gy nc nd l ne nf">        best = int(math.Max(float64(best), float64(total)))<br/>        left++<br/>        right++<br/>    }<br/>    return best<br/>}</span></pre><p id="c87b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，让我们用一副样板来测试我们的功能。</p><pre class="mp mq mr ms gt mx mw my mz aw na bi"><span id="4417" class="nb li in mw b gy nc nd l ne nf">package main<br/>import (<br/>  "fmt"<br/>  "math"<br/>)<br/>func maxPoints(deck []int, k int) int{<br/>    left := 0;<br/>    right := len(deck) - k<br/>    var total, best int<br/>    total = 0<br/>    for i := right; i &lt; len(deck); i++ {<br/>        total += deck[i]<br/>    }<br/>    best = total<br/>    for i := 0; i &lt; k; i++ {<br/>        total += deck[left] - deck[right]<br/>        best = int(math.Max(float64(best), float64(total)))<br/>        left++<br/>        right++<br/>    }<br/>    return best<br/>}<br/><br/>func main() {<br/>    deck := []int{5,3,4,4,2,3,2,6,3}<br/>    k := 4<br/>    fmt.Println(maxPoints(deck, k))<br/>}<br/><br/>=&gt; 17</span></pre><h1 id="d69c" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">项目总结和相关面试问题</h1><p id="371d" class="pw-post-body-paragraph jv jw in jx b jy mf ka kb kc mg ke kf kg mh ki kj kk mi km kn ko mj kq kr ks ig bi translated">恭喜你。你坚持到了项目结束。在整个项目中，我们学习了如何:</p><ul class=""><li id="697b" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated">通过按<strong class="jx io">连续顺序</strong>对牌进行分组，建立一个可以识别一手顺子的功能</li><li id="365a" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">使用<strong class="jx io">滑动窗口技术</strong>构建一个功能来查找具有最大分值的牌</li></ul><p id="273b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们今天解决的问题也是顶级科技公司面试中常见的问题。在我们有了构建项目的经验之后，您现在可以识别具有相同模式的问题，并使用我们今天实现的技术来解决这些问题。让我们来看看几个与<strong class="jx io">相关的面试问题</strong>，我们可以用类似的方法来解决:</p><ul class=""><li id="d244" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated">将数组分成K个连续数字的集合</li><li id="d100" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">从数组的任意一端找出最大和</li></ul><h1 id="83bd" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">后续步骤</h1><p id="12bf" class="pw-post-body-paragraph jv jw in jx b jy mf ka kb kc mg ke kf kg mh ki kj kk mi km kn ko mj kq kr ks ig bi translated">构建一个强大的编码组合可以让你亲身实践真实世界的软件开发问题。作为一名Go开发者，强大的产品组合是让你在竞争中脱颖而出的好方法。我们今天只完成了一个项目，但是还有更多真实世界的项目，你可以继续工作，以了解更多关于软件开发世界的知识，并帮助你更好地准备你的Go面试。一些更多的项目想法包括:</p><ul class=""><li id="9a28" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated">改善用户在网飞上查找观看内容的体验</li><li id="c776" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">为Google日历实现生产力增强功能</li><li id="cfcb" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">优化亚马逊上面向客户的功能</li></ul><p id="fda8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="mk">快乐学习！</em></p></div></div>    
</body>
</html>