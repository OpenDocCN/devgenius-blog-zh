<html>
<head>
<title>Producer — Consumer Problem with Threads (Explained with Code breakdown)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">线程的生产者-消费者问题(用代码分解解释)</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/producer-consumer-problem-with-threads-explained-with-code-breakdown-626aaf0c0011?source=collection_archive---------4-----------------------#2022-10-23">https://blog.devgenius.io/producer-consumer-problem-with-threads-explained-with-code-breakdown-626aaf0c0011?source=collection_archive---------4-----------------------#2022-10-23</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/29e1f15377b5c81008264057d16c046c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Gpp9Mj9f7Ld8--s-nN3ujg.png"/></div></div></figure><p id="b40e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">生产者-消费者问题是学习多线程时要解决的一个非常常见的问题。特别是 Java。我写这篇小文章的原因是因为我注意到很多人对补丁的实现以及<code class="fe kt ku kv kw b">wait();</code>、<code class="fe kt ku kv kw b">notify();</code>和<code class="fe kt ku kv kw b">notifyAll();</code>的作用感到困惑。所以，我们用一种简化的方式来看这个:)</p><h1 id="a5a6" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">什么是生产者——消费者问题？</h1><p id="5d1c" class="pw-post-body-paragraph jv jw in jx b jy lv ka kb kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ig bi translated">这无疑是你进入多线程时要解决的第一个问题。</p><ul class=""><li id="7d05" class="ma mb in jx b jy jz kc kd kg mc kk md ko me ks mf mg mh mi bi translated">我们让“生产者”和“消费者”共享数据的“公共缓冲区”。</li><li id="7e5a" class="ma mb in jx b jy mj kc mk kg ml kk mm ko mn ks mf mg mh mi bi translated">当从一个<strong class="jx io">公共/共享</strong>缓冲区插入或提取数据时，所有的生产者和消费者都将在他们各自的线程上运行。</li><li id="412e" class="ma mb in jx b jy mj kc mk kg ml kk mm ko mn ks mf mg mh mi bi translated">缓冲区将有一个最大值。(它可以存储的最大数据量)</li></ul><p id="e0f2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了解决这个问题，我们需要<strong class="jx io">同步</strong>。我们将使用同步来同步共享资源。在我们的例子中是公共缓冲区。但是现在，让我们先不要考虑同步，看看会发生什么。我们将创建 4 个类。“主要”、“缓冲”、“生产者”和“消费者”。</p><h1 id="cf0c" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">生产者——没有同步或条件的消费者代码</h1><blockquote class="mo mp mq"><p id="a038" class="jv jw mr jx b jy jz ka kb kc kd ke kf ms kh ki kj mt kl km kn mu kp kq kr ks ig bi translated">缓冲等级</p></blockquote><figure class="mv mw mx my gt jo"><div class="bz fp l di"><div class="mz na l"/></div></figure><blockquote class="mo mp mq"><p id="52d4" class="jv jw mr jx b jy jz ka kb kc kd ke kf ms kh ki kj mt kl km kn mu kp kq kr ks ig bi translated">生产者阶层</p></blockquote><figure class="mv mw mx my gt jo"><div class="bz fp l di"><div class="mz na l"/></div></figure><blockquote class="mo mp mq"><p id="3251" class="jv jw mr jx b jy jz ka kb kc kd ke kf ms kh ki kj mt kl km kn mu kp kq kr ks ig bi translated">消费者阶层</p></blockquote><figure class="mv mw mx my gt jo"><div class="bz fp l di"><div class="mz na l"/></div></figure><blockquote class="mo mp mq"><p id="f91c" class="jv jw mr jx b jy jz ka kb kc kd ke kf ms kh ki kj mt kl km kn mu kp kq kr ks ig bi translated">主类</p></blockquote><figure class="mv mw mx my gt jo"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="1af6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">好了，现在我们有 2 个生产者和 2 个消费者，缓冲区大小为 3。让我们看看它的输出是什么。</p><figure class="mv mw mx my gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nb"><img src="../Images/809be56a2d25aba316fe137ed191e919.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N8gCS7XeddtXAy5INBA0JA.png"/></div></div></figure><p id="b803" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们这里有两个问题。</p><ul class=""><li id="eaea" class="ma mb in jx b jy jz kc kd kg mc kk md ko me ks mf mg mh mi bi translated">索引越界错误，因为使用者试图从空缓冲区提取数据。</li><li id="4c92" class="ma mb in jx b jy mj kc mk kg ml kk mm ko mn ks mf mg mh mi bi translated">生产者不断添加数据，即使在最大数量之后。(见图中第 5 项)。</li></ul><p id="5c77" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">解决这个问题很简单。我们需要为提取和插入方法添加条件。</p><ul class=""><li id="9edb" class="ma mb in jx b jy jz kc kd kg mc kk md ko me ks mf mg mh mi bi translated">仅当缓冲区不为空时提取数据。</li><li id="642a" class="ma mb in jx b jy mj kc mk kg ml kk mm ko mn ks mf mg mh mi bi translated">仅当缓冲区未满时插入数据。</li></ul><p id="ee2c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们看看如果我们在这些的<code class="fe kt ku kv kw b">extract</code>和<code class="fe kt ku kv kw b">insert</code>方法中添加<code class="fe kt ku kv kw b">if</code>条件会发生什么。</p><figure class="mv mw mx my gt jo"><div class="bz fp l di"><div class="mz na l"/></div></figure><figure class="mv mw mx my gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nc"><img src="../Images/3b6479cc137ed240c8f8a73894810d7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bw_gg7vQiyzzzclud2Xjfw.png"/></div></div></figure><p id="2497" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里的条件已经发挥作用，我们没有任何错误。但是输出都混在一起了，这不是我们想要的。如果我们加一个<code class="fe kt ku kv kw b">while </code>而不是<code class="fe kt ku kv kw b">if</code>会怎么样？这能解决问题吗？让我们看看。</p><figure class="mv mw mx my gt jo"><div class="bz fp l di"><div class="mz na l"/></div></figure><figure class="mv mw mx my gt jo gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/2e45bd9ab7f4d62346beb732140e697a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_Inm48VGGmBsQsIdxWcnUg.png"/></div></figure><p id="6c49" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">哇哦。。物品数量刚刚破了记录。缓冲区一开始就没有满，而<code class="fe kt ku kv kw b">insert </code>方法中的 while 循环不断地向缓冲区添加数据，给我们提供了这个输出。显然不是解决办法。让我们将同步添加到 mix 中，看看我们是否能以这种方式修复它。</p><h1 id="f10d" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">生产者——带有同步和条件的消费者代码</h1><p id="88b6" class="pw-post-body-paragraph jv jw in jx b jy lv ka kb kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ig bi translated">有两种使用同步的方法。它可以是一个同步函数或同步代码块。<strong class="jx io">在同步函数或代码块中，我们可以使用几个特殊的关键字</strong>。也就是说，他们将是<code class="fe kt ku kv kw b">wait();</code>、<code class="fe kt ku kv kw b">notify();</code>和<code class="fe kt ku kv kw b">notifyAll();</code></p><p id="c17b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以让我们在<code class="fe kt ku kv kw b">extract</code>和<code class="fe kt ku kv kw b">insert</code>函数中添加<code class="fe kt ku kv kw b">synchronized </code>关键字。然后<code class="fe kt ku kv kw b">wait();</code>给定前面的条件。</p><figure class="mv mw mx my gt jo"><div class="bz fp l di"><div class="mz na l"/></div></figure><figure class="mv mw mx my gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ne"><img src="../Images/2abac0434b304d73a25b1b9cd925eb9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bN6IIXEb27NGlLAi52RJVQ.png"/></div></div></figure><p id="1184" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">好了，现在我们有进展了。我们有一个部分工作的代码，其输出符合我们的预期。还记得我们开始生产者和消费者线程的顺序吗？</p><pre class="mv mw mx my gt nf kw ng nh aw ni bi"><span id="aa8f" class="nj ky in kw b gy nk nl l nm nn">Consumer c1 = new Consumer(buffer, 1);<br/>Consumer c2 = new Consumer(buffer, 2);<br/>Producer p1 = new Producer(buffer, 1);<br/>Producer p2 = new Producer(buffer, 2);</span></pre><p id="a387" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">第一个“缓冲区为空”消息由消费者 1 打印，下一个消息来自消费者 2，因为缓冲区一开始就是空的。在执行<code class="fe kt ku kv kw b">wait();</code>方法之前，两个消费者线程都打印了该输出。当最后两行的缓冲区已满时，2 个生产者或多或少会发生同样的事情。</p><p id="af5e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果我们观察 java 线程的生命周期，这是意料之中的。所有线程都从主类<strong class="jx io">开始</strong>进入“运行”状态。然后根据缓冲区中的项目，生产者和消费者要么完成他们的工作，要么在 while 循环中进入“等待”状态。</p><figure class="mv mw mx my gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi no"><img src="../Images/fb93de927668bd87ae04f6b99f991787.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*AJYOC5BmN5bMm16C.jpg"/></div></div></figure><p id="2d81" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们要做的就是让“等待”线程在相同的条件下再次运行。消费者进入“等待”状态，因为缓冲区一开始就是空的。但是一旦缓冲区有了一些数据，它们就应该开始消耗。对于生产者来说，反之亦然。因此..我们需要一种方法将线程的“等待”状态改回“运行”状态。这就是<code class="fe kt ku kv kw b">notify();</code>和<code class="fe kt ku kv kw b">notifyAll();</code>的用武之地。</p><blockquote class="mo mp mq"><p id="5efe" class="jv jw mr jx b jy jz ka kb kc kd ke kf ms kh ki kj mt kl km kn mu kp kq kr ks ig bi translated"><code class="fe kt ku kv kw b">notifyAll();</code>将信号通知所有等待的线程回到运行状态。<code class="fe kt ku kv kw b">notify();</code>另一方面会发信号让单个等待线程回到它的运行状态。但是哪一个完全取决于操作系统。</p><p id="24d4" class="jv jw mr jx b jy jz ka kb kc kd ke kf ms kh ki kj mt kl km kn mu kp kq kr ks ig bi translated">尝试移除 wait()；并查看输出。它将在 while 循环中无限地打印“缓冲区满”或“缓冲区空”。</p></blockquote><h1 id="e015" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">带有同步<code class="fe kt ku kv kw b">wait </code>和 notifyAll 的生产者-消费者代码。</h1><figure class="mv mw mx my gt jo"><div class="bz fp l di"><div class="mz na l"/></div></figure><figure class="mv mw mx my gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi np"><img src="../Images/3bc756b1a80649622a23e730486d30ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N4AZcyrCXjDQ_2E21VL7cA.png"/></div></div></figure><p id="605e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后。成功。我们期望从代码中得到的输出和功能。使用<code class="fe kt ku kv kw b">wait();</code>和<code class="fe kt ku kv kw b">notifyAll();</code>实现同步</p><h1 id="aace" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">结论</h1><p id="fd0a" class="pw-post-body-paragraph jv jw in jx b jy lv ka kb kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ig bi translated">对于 java 中的生产者-消费者问题，这是一个循序渐进的方法和代码分解。尽管这是一个小的修正，但代码经常会让 java 并发初学者感到困惑。需要记住的 5 件重要事情。</p><ol class=""><li id="487f" class="ma mb in jx b jy jz kc kd kg mc kk md ko me ks nq mg mh mi bi translated"><strong class="jx io">处理共享资源时使用同步</strong>。例如生产者消费者问题中的共享缓冲区。</li><li id="a0bb" class="ma mb in jx b jy mj kc mk kg ml kk mm ko mn ks nq mg mh mi bi translated"><code class="fe kt ku kv kw b">wait();</code>函数也可以带一个参数，表示它可以等待多长时间(<code class="fe kt ku kv kw b">wait(duration in millis);</code>)。这在某些不同的问题上很方便。</li><li id="be14" class="ma mb in jx b jy mj kc mk kg ml kk mm ko mn ks nq mg mh mi bi translated"><code class="fe kt ku kv kw b">notifyAll();</code>将向所有等待共享对象的线程发出信号，而<code class="fe kt ku kv kw b">notify();</code>只向被操作系统选中的单个线程发出信号。</li><li id="b738" class="ma mb in jx b jy mj kc mk kg ml kk mm ko mn ks nq mg mh mi bi translated">如果仔细观察提取和插入逻辑…<strong class="jx io">notifyAll()；提取函数</strong> <strong class="jx io">内部的方法用于通知等待的生产者</strong>开始插入，而<strong class="jx io">则是 notifyAll()；插入函数</strong> <strong class="jx io">内部的方法用于通知等待的消费者</strong>开始消费。</li><li id="49d2" class="ma mb in jx b jy mj kc mk kg ml kk mm ko mn ks nq mg mh mi bi translated"><code class="fe kt ku kv kw b">wait();</code>、<code class="fe kt ku kv kw b">notifyAll();</code>和<code class="fe kt ku kv kw b"> notify();</code> <strong class="jx io">都必须从同步函数或同步代码块</strong>中调用。</li></ol><p id="0e9b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我希望这消除了你们在这个问题上的大部分困惑或疑虑。干杯，快乐编码🍺。直到下次:)</p><p id="aa20" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">由，<strong class="jx io">鹤山威客</strong></p></div></div>    
</body>
</html>