<html>
<head>
<title>A quick guide to bit manipulation in Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java 位操作快速指南</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/a-quick-guide-to-bit-manipulation-in-java-4559839653f5?source=collection_archive---------1-----------------------#2021-03-13">https://blog.devgenius.io/a-quick-guide-to-bit-manipulation-in-java-4559839653f5?source=collection_archive---------1-----------------------#2021-03-13</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/161159c2501f8fe04e92fb0cb5876c79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j5qf5utvbkzXrzoM5ZARhA.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">图片来源:作者</figcaption></figure><p id="8067" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">位操作是直接操作数据位来执行操作，是 FAANG 招聘人员现在测试的一个重要的优化技能。然而，这个主题是高度数学化的，在非大学计算机科学环境中很少涉及。</p><p id="8949" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">今天，我们将为您提供一个关于位操作的教程，并探索一些常见面试问题的实践。</p><p id="2eab" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">下面是我们今天要讲的内容:</strong></p><ul class=""><li id="bb89" class="kx ky in kb b kc kd kg kh kk kz ko la ks lb kw lc ld le lf bi translated">什么是比特操作？</li><li id="0c16" class="kx ky in kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">按位运算符</li><li id="78ac" class="kx ky in kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">逐位技巧</li><li id="dec8" class="kx ky in kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">按位运算符的实践操作</li><li id="b62f" class="kx ky in kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">接下来学什么</li></ul><h1 id="dba3" class="ll lm in bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">什么是比特操作？</h1><p id="8796" class="pw-post-body-paragraph jz ka in kb b kc mj ke kf kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw ig bi translated">位操作是对位序列(计算机中最小的数据形式)应用逻辑运算以达到所需结果的过程。位操作具有恒定的时间复杂度和并行处理，这意味着它在所有系统上都非常有效。</p><p id="2519" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">大多数编程语言会让你处理抽象概念，比如对象或变量，而不是它们所代表的位。但是，在某些情况下，需要直接位操作来提高性能和减少错误。</p><p id="5c1d" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">位操作需要很强的二进制和二进制转换知识。</p><p id="defc" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">这里有一些需要位操作的任务的例子:</strong></p><ul class=""><li id="b03f" class="kx ky in kb b kc kd kg kh kk kz ko la ks lb kw lc ld le lf bi translated">低级设备控制</li><li id="8063" class="kx ky in kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">错误检测和纠正算法</li><li id="7556" class="kx ky in kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">数据压缩</li><li id="403d" class="kx ky in kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">加密算法</li><li id="5146" class="kx ky in kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">最佳化</li></ul><p id="9132" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">例如，看看算术和位操作方法在寻找 RGB 值的绿色部分时的区别:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="a0a2" class="mx lm in mt b gy my mz l na nb">// arithmetic<br/>(rgb / 256) % 256</span><span id="f6f1" class="mx lm in mt b gy nc mz l na nb">// bit<br/>(rgb &gt;&gt; 8) &amp; 0xFF</span></pre><p id="1723" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">虽然两者做的是同样的事情，但第二个选项要快得多，因为它直接在内存中工作，而不是通过抽象层。</p><p id="ff5a" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们将在本文的后面探讨这些操作符的作用(<code class="fe nd ne nf mt b">&gt;&gt;</code>和<code class="fe nd ne nf mt b">&amp;</code>)。</p><h1 id="8342" class="ll lm in bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">按位操作和编码采访</h1><p id="6e88" class="pw-post-body-paragraph jz ka in kb b kc mj ke kf kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw ig bi translated">比特操纵也是编码面试的常见话题，尤其是和 FAANG 公司。这些面试官希望你对比特有一个基本的了解，基本的比特操作符，并大致了解比特操作背后的思维过程。</p><blockquote class="ng nh ni"><p id="a821" class="jz ka nj kb b kc kd ke kf kg kh ki kj nk kl km kn nl kp kq kr nm kt ku kv kw ig bi translated">拥有这些知识表明你是一个全面发展的开发人员，既了解特定的工具，又了解计算机科学的基础。</p></blockquote><p id="d3df" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">如果你申请的是一个与嵌入式系统或其他低级系统一起工作的职位，你会遇到更多的 bit 问题。简而言之，你的角色越接近机器级别，你遇到的位操作问题就越多。</p><p id="6eb4" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">准备位操作问题的最好方法是练习使用每个位运算符，并复习二进制到十进制的转换。</p><h1 id="98c9" class="ll lm in bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">按位运算符</h1><p id="2bb8" class="pw-post-body-paragraph jz ka in kb b kc mj ke kf kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw ig bi translated">逐位运算接受一个或多个位模式或二进制数，然后<strong class="kb io">在比特级处理它们</strong>。它们本质上是我们操纵比特来完成操作的工具。</p><p id="3271" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">算术运算对人类可读的值(<code class="fe nd ne nf mt b">1+2</code>)执行运算，而按位运算符直接操作低级数据。</p><figure class="mo mp mq mr gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nn"><img src="../Images/1dc0f1472bdcbb15bb6ef258cb1ec97c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fw9wJQc8zU0CHUy6.PNG"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">图片来源:作者</figcaption></figure><p id="a1de" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">优点</strong></p><ul class=""><li id="57b1" class="kx ky in kb b kc kd kg kh kk kz ko la ks lb kw lc ld le lf bi translated">它们是快速而简单的动作。</li><li id="f7fb" class="kx ky in kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">它们由处理器直接支持。</li><li id="c08a" class="kx ky in kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">它们用于操作值以进行比较和计算。</li><li id="e871" class="kx ky in kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">位运算非常简单，而且比算术运算更快。</li></ul><p id="778f" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">让我们快速看一下每个主要的按位运算符及其用法。</p><h1 id="6789" class="ll lm in bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">逻辑积算符</h1><p id="d78b" class="pw-post-body-paragraph jz ka in kb b kc mj ke kf kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw ig bi translated">AND ( <code class="fe nd ne nf mt b">&amp;</code>)是比较两个长度相等的操作数的二元运算符。操作数从它们的可读形式转换成二进制表示。对于每个位，该操作检查两个操作数的两位是否都是<code class="fe nd ne nf mt b">1</code>。如果是，则在答案中将该位设置为<code class="fe nd ne nf mt b">1</code>。否则，相应的结果位被设置为<code class="fe nd ne nf mt b">0.</code></p><p id="3467" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">它实际上将每个位乘以另一个操作数中的相应位。由于将任何东西乘以<code class="fe nd ne nf mt b">0</code>得到<code class="fe nd ne nf mt b">0</code>，与任何<code class="fe nd ne nf mt b">0</code>位的 AND 比较将得到<code class="fe nd ne nf mt b">0</code>。</p><ul class=""><li id="0401" class="kx ky in kb b kc kd kg kh kk kz ko la ks lb kw lc ld le lf bi translated">如果两个输入位为 1，则输出为 1。</li><li id="bd3d" class="kx ky in kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">在所有其他情况下，它为 0，例如:</li><li id="eb87" class="kx ky in kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated"><code class="fe nd ne nf mt b">1 &amp; 0</code> = &gt;收益率为 0。</li><li id="0afa" class="kx ky in kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated"><code class="fe nd ne nf mt b">0 &amp; 1</code> = &gt;收益率为 0。</li><li id="9b0a" class="kx ky in kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated"><code class="fe nd ne nf mt b">0 &amp; 0</code> = &gt;收益率为 0。</li></ul><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="9aef" class="mx lm in mt b gy my mz l na nb">0101 (decimal 5)<br/>AND 0011 (decimal 3)</span></pre><p id="4e97" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><code class="fe nd ne nf mt b">0 * 0 = 0</code></p><p id="b867" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><code class="fe nd ne nf mt b">1 * 0 = 0</code></p><p id="19a9" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><code class="fe nd ne nf mt b">0 * 1 = 0</code></p><p id="9ef9" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><code class="fe nd ne nf mt b">1 * 1 = 1</code></p><p id="af59" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">因此:</p><p id="c4bc" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><code class="fe nd ne nf mt b">= 0001 (decimal 1)</code></p><p id="90fc" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">该操作可用于确定特定位是置位(1)还是清零(0)。它还用于清除寄存器中的选定位，其中每个位代表一个单独的布尔状态。</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="d6a4" class="mx lm in mt b gy my mz l na nb">class AndOperation {<br/>    public static void main( String args[] ) {<br/>        int x = 12;<br/>        int y = 10;<br/>        System.out.println("Bitwise AND of (" + x + " , " + y + ") is: " + (x &amp; y)); // yields to 8<br/>    }<br/>}</span></pre><h1 id="2331" class="ll lm in bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">OR 运算符</h1><p id="9957" class="pw-post-body-paragraph jz ka in kb b kc mj ke kf kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw ig bi translated">OR 运算符(<code class="fe nd ne nf mt b">|</code>)是一个二元运算符，接受两个等长的操作数，但<strong class="kb io">以与 AND 相反的方式对它们</strong>进行比较；如果任一对应位为<code class="fe nd ne nf mt b">1</code>，则答案为<code class="fe nd ne nf mt b">1</code>。否则答案就是<code class="fe nd ne nf mt b">0</code>。换句话说，如果给定的输入之一是<code class="fe nd ne nf mt b">1</code>，按位“或”将返回‘1’。</p><ul class=""><li id="082c" class="kx ky in kb b kc kd kg kh kk kz ko la ks lb kw lc ld le lf bi translated">如果两个输入位为<code class="fe nd ne nf mt b">0</code>，则输出为<code class="fe nd ne nf mt b">0</code>。</li><li id="2fee" class="kx ky in kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">其他情况都是<code class="fe nd ne nf mt b">1</code>。例如:</li><li id="97d5" class="kx ky in kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">收益率为 1。</li><li id="23b2" class="kx ky in kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">收益率为 1。</li><li id="5bf9" class="kx ky in kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">收益率为 1。</li></ul><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="c906" class="mx lm in mt b gy my mz l na nb">a = 12<br/>b = 10<br/>---------------------------------<br/>a in Binary : 0000 0000 0000 1100<br/>b in Binary : 0000 0000 0000 1010<br/>---------------------------------<br/>a | b           : 0000 0000 0000 1110<br/>--------------------------------------</span></pre><p id="44a0" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这通常用作解决其他问题的临时逻辑步骤。</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="7eb9" class="mx lm in mt b gy my mz l na nb">class OROperation {<br/>    private static int helper(int x, int y) {<br/>        return x | y;<br/>    }<br/>    public static void main(String[] args) {<br/>        int x = 12;<br/>        int y = 10;<br/>        System.out.println("Bitwise OR of " + x + ", " + y + " is: " + helper(x, y)); // yields to 14<br/>    }<br/>}</span></pre><h1 id="7ae2" class="ll lm in bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">“非”算符</h1><p id="c779" class="pw-post-body-paragraph jz ka in kb b kc mj ke kf kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw ig bi translated">NOT ( <code class="fe nd ne nf mt b">~</code>)或有时称为按位补码运算符，是一种一元运算，它接受单个输入，<strong class="kb io">将二进制表示中的每个位</strong>交换为相反的值。</p><p id="fce4" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">所有的<code class="fe nd ne nf mt b">0</code>实例都变成了<code class="fe nd ne nf mt b">1</code>，所有的<code class="fe nd ne nf mt b">1</code>实例都变成了<code class="fe nd ne nf mt b">0</code>。换句话说，NOT 反转每个输入位。这个反转的序列被称为位序列的<strong class="kb io">补码</strong>。</p><blockquote class="ng nh ni"><p id="f0eb" class="jz ka nj kb b kc kd ke kf kg kh ki kj nk kl km kn nl kp kq kr nm kt ku kv kw ig bi translated"><em class="in">比如考虑</em>T5】</p><p id="9240" class="jz ka nj kb b kc kd ke kf kg kh ki kj nk kl km kn nl kp kq kr nm kt ku kv kw ig bi translated"><em class="in"/><code class="fe nd ne nf mt b"><em class="in">x</em></code><em class="in">的二进制数表示为:</em></p><p id="46e2" class="jz ka nj kb b kc kd ke kf kg kh ki kj nk kl km kn nl kp kq kr nm kt ku kv kw ig bi translated"><code class="fe nd ne nf mt b"><em class="in">x = 00000000 00000000 00000000 00000001</em></code></p><p id="26ce" class="jz ka nj kb b kc kd ke kf kg kh ki kj nk kl km kn nl kp kq kr nm kt ku kv kw ig bi translated"><em class="in">现在，</em> <code class="fe nd ne nf mt b"><em class="in">x</em></code> <em class="in">的按位非将是:</em></p><p id="8a88" class="jz ka nj kb b kc kd ke kf kg kh ki kj nk kl km kn nl kp kq kr nm kt ku kv kw ig bi translated"><code class="fe nd ne nf mt b"><em class="in">~x = 11111111 11111111 11111111 11111110</em></code></p><p id="c294" class="jz ka nj kb b kc kd ke kf kg kh ki kj nk kl km kn nl kp kq kr nm kt ku kv kw ig bi translated"><em class="in">所以:</em></p><p id="aac2" class="jz ka nj kb b kc kd ke kf kg kh ki kj nk kl km kn nl kp kq kr nm kt ku kv kw ig bi translated"><code class="fe nd ne nf mt b"><em class="in">x</em></code> <em class="in">包含 31 个 0 和 1 个 1 </em></p><p id="f91e" class="jz ka nj kb b kc kd ke kf kg kh ki kj nk kl km kn nl kp kq kr nm kt ku kv kw ig bi translated"><code class="fe nd ne nf mt b"><em class="in">~x</em></code> <em class="in">包含 31 个 1 和一个 0</em></p></blockquote><p id="cd76" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这使得数字为负，因为任何以<code class="fe nd ne nf mt b">1</code>开始的位集合都是负的。</p><p id="55bb" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">NOT 对于将无符号数翻转为中点对面的镜像值非常有用。</p><p id="ebac" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">对于 8 位无符号整数，<code class="fe nd ne nf mt b">NOT x = 255 - x</code>。</p><figure class="mo mp mq mr gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nn"><img src="../Images/c0eba24e162904acd45a9babcf783711.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2dwe82LB3BpboRh-.PNG"/></div></div></figure><p id="dd92" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">公式:<code class="fe nd ne nf mt b">~x = 2^{32} - x</code></p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="887b" class="mx lm in mt b gy my mz l na nb">class NOTOperation {<br/>    public static void main( String args[] ) {<br/>        int a = 1;<br/>        System.out.println("Bitwise NOT of a is : " + ~a);<br/>    }<br/>}</span></pre><h1 id="445c" class="ll lm in bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">异或运算符</h1><p id="55d9" class="pw-post-body-paragraph jz ka in kb b kc mj ke kf kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw ig bi translated">按位 XOR 运算(<code class="fe nd ne nf mt b">^</code>)，“异或”的缩写)是一个二元运算符，接受两个输入参数，<strong class="kb io">比较每个相应的位。</strong>如果两位相反，结果在该位位置有一个<code class="fe nd ne nf mt b">1</code>。如果它们匹配，则返回一个<code class="fe nd ne nf mt b">0</code>。</p><ul class=""><li id="2c29" class="kx ky in kb b kc kd kg kh kk kz ko la ks lb kw lc ld le lf bi translated"><code class="fe nd ne nf mt b">1 ^ 1</code> = &gt;收益率为 0。</li><li id="cae7" class="kx ky in kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated"><code class="fe nd ne nf mt b">0 ^ 0</code> = &gt;收益率为零。</li><li id="9187" class="kx ky in kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated"><code class="fe nd ne nf mt b">1 ^ 0</code> = &gt;收益率为 1。</li><li id="422e" class="kx ky in kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated"><code class="fe nd ne nf mt b">0 ^ 1</code> = &gt;收益率为 1。</li></ul><p id="3854" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">例如:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="8519" class="mx lm in mt b gy my mz l na nb">a = 12<br/>b = 10<br/>--------------------------------------<br/>a in binary : 0000 0000 0000 1100<br/>b in binary : 0000 0000 0000 1010<br/>--------------------------------------<br/>a ^ b       : 0000 0000 0000 0110<br/>--------------------------------------</span></pre><p id="11b6" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">XOR 用于反转寄存器中选定的单个位，或操作表示布尔状态的位模式。</p><p id="93e6" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">XOR 有时也用于将注册表的值设置为零，因为两个相同输入的 XOR 将总是导致<code class="fe nd ne nf mt b">0</code>。</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="2091" class="mx lm in mt b gy my mz l na nb">class XOROperation {<br/>    public static void main( String args[] ) {<br/>        int x = 12;<br/>        int y = 10;<br/>        System.out.println("Bitwise XOR of (x , y) is : " + (x ^ y)); // yields to 6<br/>    }<br/>}</span></pre><h1 id="d284" class="ll lm in bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">左右移位运算符</h1><p id="f24f" class="pw-post-body-paragraph jz ka in kb b kc mj ke kf kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw ig bi translated"><br/>移位是一种逐位运算，其中一系列比特的顺序被移动以有效地执行数学运算。移位是将一个数的二进制表示中的每一位向左或向右移动第二个操作数指定的空格数。</p><p id="fcb6" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这些运算符可以应用于整数类型，如<code class="fe nd ne nf mt b">int</code>、<code class="fe nd ne nf mt b">long</code>、<code class="fe nd ne nf mt b">short</code>、<code class="fe nd ne nf mt b">byte</code>或<code class="fe nd ne nf mt b">char</code>。</p><p id="5a3c" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">换档有三种类型:</strong></p><ul class=""><li id="219d" class="kx ky in kb b kc kd kg kh kk kz ko la ks lb kw lc ld le lf bi translated"><strong class="kb io">左移:</strong> <code class="fe nd ne nf mt b">&lt;&lt;</code>是左移运算符，同时满足逻辑和算术移位的需要。</li><li id="9ff0" class="kx ky in kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated"><strong class="kb io">算术/有符号右移:</strong> <code class="fe nd ne nf mt b">&gt;&gt;</code>是算术(或有符号)右移运算符。</li><li id="d2ec" class="kx ky in kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated"><strong class="kb io">逻辑/无符号右移:</strong> <code class="fe nd ne nf mt b">&gt;&gt;&gt;</code>是逻辑(或无符号)右移运算符。</li></ul><blockquote class="ng nh ni"><p id="edd8" class="jz ka nj kb b kc kd ke kf kg kh ki kj nk kl km kn nl kp kq kr nm kt ku kv kw ig bi translated"><em class="in">在 Java 中，所有的整数数据类型都是有符号的，而</em> <code class="fe nd ne nf mt b"><em class="in">&lt;&lt;</em></code> <em class="in">和</em> <code class="fe nd ne nf mt b"><em class="in">&gt;&gt;</em></code> <em class="in">只是算术移位。</em></p></blockquote><p id="4233" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这是一个左移的例子:</p><p id="f5ac" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><code class="fe nd ne nf mt b">6 = 00000000 00000000 00000000 00000110</code></p><p id="ab4a" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">将该位模式左移一位(<code class="fe nd ne nf mt b">6 &lt;&lt; 1</code>)得到数字 12:</p><p id="ce10" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><code class="fe nd ne nf mt b">6 &lt;&lt; 1 = 00000000 00000000 00000000 00001100</code></p><p id="977c" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">如您所见，数字向左移动了一个位置，右边的最后一个数字用零填充。注意，左移等效于乘以 2 的幂。</p><p id="8bbc" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><code class="fe nd ne nf mt b">6 &lt;&lt; 1 → 6 * 2^1 → 6 * 2</code></p><p id="4c35" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><code class="fe nd ne nf mt b">6 &lt;&lt; 3 → 6 * 2^3 → 6 * 8</code></p><p id="3993" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">优化良好的编译器会尽可能用移位来代替乘法，因为移位更快。</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="4734" class="mx lm in mt b gy my mz l na nb">class LeftShift {<br/>    private static int helper(int number, int i) {<br/>        return number &lt;&lt; i;// multiplies `number` with 2^i times.<br/>    }<br/>    public static void main(String[] args) {<br/>        int number = 100;<br/>        System.out.println(number + " shifted 1 position left, yields to " + helper(number, 1));<br/>        System.out.println(number + " shifted 2 positions left, yields to " + helper(number, 2));<br/>        System.out.println(number + " shifted 3 positions left, yields to " + helper(number, 3));<br/>        System.out.println(number + " shifted 4 positions left, yields to " + helper(number, 4));<br/>    }<br/>}</span></pre><p id="0d38" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">使用右移位，您可以进行算术(<code class="fe nd ne nf mt b">&gt;&gt;</code>)或逻辑(<code class="fe nd ne nf mt b">&gt;&gt;</code>)移位。</p><p id="7b25" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">不同之处在于算术移位保持相同的最高有效位(MSB)或<strong class="kb io">符号位</strong>，最左边的位决定一个数是正还是负。</p><p id="889d" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><code class="fe nd ne nf mt b">1011 0101 &gt;&gt; 1 = **1**101 1010</code></p><p id="4592" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">公式:<code class="fe nd ne nf mt b">x &gt;&gt; y = x/(2^y)</code></p><p id="1c6b" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">另一方面，逻辑移位只是将所有内容向右移动，并用<code class="fe nd ne nf mt b">0</code>替换 MSB。</p><p id="733b" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><code class="fe nd ne nf mt b">1011 0101 &gt;&gt;&gt; 1 = 0101 1010</code></p><p id="31e2" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">公式:<code class="fe nd ne nf mt b">a &gt;&gt;&gt; b = a/(2^b)</code></p><h1 id="3ed2" class="ll lm in bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">逐位技巧</h1><p id="ccf4" class="pw-post-body-paragraph jz ka in kb b kc mj ke kf kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw ig bi translated">现在，让我们来看看使用按位运算符可以做到的一些技巧。</p><p id="e258" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这些通常用作面试问题，以检查您是否已经复习了基本的位操作，并能够将其应用到日常的编码任务中。</p><h1 id="fbe1" class="ll lm in bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">检查一个数字是否是偶数</h1><p id="f83a" class="pw-post-body-paragraph jz ka in kb b kc mj ke kf kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw ig bi translated">这一题测试你对 AND 如何工作以及偶数/奇数在二进制中如何不同的知识。您可以简单地使用:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="4e31" class="mx lm in mt b gy my mz l na nb">(x &amp; 1 ) == 0<br/>  0110 (6)<br/>&amp; 0001<br/>= 0000 TRUE</span></pre><p id="5ecf" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这个解决方案依赖于两件事:</p><ul class=""><li id="2ece" class="kx ky in kb b kc kd kg kh kk kz ko la ks lb kw lc ld le lf bi translated"><code class="fe nd ne nf mt b">2</code>等同于<code class="fe nd ne nf mt b">0001</code></li><li id="cf89" class="kx ky in kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">所有大于 2 的奇数最右边的数字是<code class="fe nd ne nf mt b">1</code></li></ul><p id="c0c9" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">任何时候最后一位的值为<code class="fe nd ne nf mt b">1</code>，你就知道它匹配，因此是一个奇数。如果取而代之的是<code class="fe nd ne nf mt b">0</code>，你知道没有匹配的数字，因此它是偶数。</p><h1 id="4eb2" class="ll lm in bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">将字符转换为大写或小写</h1><p id="cc93" class="pw-post-body-paragraph jz ka in kb b kc mj ke kf kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw ig bi translated">这个技巧测试你对二进制中大写和小写字符的知识。您可以使用<code class="fe nd ne nf mt b">ch ^= 32</code>将任意字符<code class="fe nd ne nf mt b">ch</code>转换成相反的大小写。</p><p id="e344" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这是因为小写和大写字母的二进制表示几乎相同，只有 1 位的差异。</p><p id="e1cb" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">使用 XOR 运算，我们可以切换单个位，并将其交换为相反的值，从而将小写字符转换为大写字符，反之亦然。</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="97c1" class="mx lm in mt b gy my mz l na nb">public class Test <br/>{ </span><span id="c638" class="mx lm in mt b gy nc mz l na nb">    static int x=32; </span><span id="0a63" class="mx lm in mt b gy nc mz l na nb">    // tOGGLE cASE = swaps CAPS to lower <br/>    // case and lower case to CAPS <br/>    static String toggleCase(char[] a) <br/>    { <br/>        for (int i=0; i&lt;a.length; i++) { </span><span id="19e0" class="mx lm in mt b gy nc mz l na nb">            // Bitwise XOR with 32 <br/>            a[i]^=32; <br/>        } <br/>        return new String(a); <br/>    } </span><span id="a260" class="mx lm in mt b gy nc mz l na nb">    /* Driver program */<br/>    public static void main(String[] args)  <br/>    { <br/>        String str = "CheRrY"; <br/>        System.out.print("Toggle case: "); <br/>        str = toggleCase(str.toCharArray()); <br/>        System.out.println(str); </span><span id="a742" class="mx lm in mt b gy nc mz l na nb">        System.out.print("Original string: "); <br/>        str = toggleCase(str.toCharArray()); <br/>        System.out.println(str);     <br/>    } <br/>}</span></pre><h1 id="5e3f" class="ll lm in bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">按位运算符的实践操作</h1><p id="9309" class="pw-post-body-paragraph jz ka in kb b kc mj ke kf kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw ig bi translated"><br/>现在，让我们对这些操作员进行一些实际操作。</p><h1 id="4e45" class="ll lm in bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">和挑战:计数设置位</h1><p id="8ed4" class="pw-post-body-paragraph jz ka in kb b kc mj ke kf kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw ig bi translated">写一个 Java 程序，计算设置为 1(设置位)的整数的位数。</p><p id="ec3a" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">解决方案和解释</strong></p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="9e17" class="mx lm in mt b gy my mz l na nb">class CountSetBit {<br/>    private static int helper(int n) {<br/>        int count = 0;<br/>        while (n &gt; 0) {<br/>            n &amp;= (n - 1);<br/>            count++;<br/>        }<br/>        return count;<br/>    }</span><span id="a532" class="mx lm in mt b gy nc mz l na nb">    public static void main(String[] args) {<br/>        int number = 125;<br/>        System.out.println("SetBit Count is : " + helper(number));<br/>    }<br/>}</span></pre><p id="88aa" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在这种方法中，我们只对设置的位进行计数。所以，</p><ul class=""><li id="f80b" class="kx ky in kb b kc kd kg kh kk kz ko la ks lb kw lc ld le lf bi translated">如果一个数有 2 个设置位，那么 while 循环运行两次。</li><li id="7181" class="kx ky in kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">如果一个数有 4 个设置位，那么 while 循环运行四次。</li></ul><p id="7789" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们的 while 循环迭代到<code class="fe nd ne nf mt b">n = 0</code>，每次通过 AND 操作符除以 2。在通道 1 中，<code class="fe nd ne nf mt b">125</code>变为<code class="fe nd ne nf mt b">62</code>，并且<code class="fe nd ne nf mt b">count</code>增加 1。第二遍时，<code class="fe nd ne nf mt b">62</code>变为<code class="fe nd ne nf mt b">31</code>，计数增加到 2。这一直持续到<code class="fe nd ne nf mt b">n</code>变为 0，然后计数被返回。</p><h1 id="6d85" class="ll lm in bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">按位 OR:翻转次数</h1><p id="d565" class="pw-post-body-paragraph jz ka in kb b kc mj ke kf kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw ig bi translated">写一个程序，取 3 个整数，用最少的翻转次数使前两个数之和等于第三个数。该程序将返回所需的翻转次数。</p><blockquote class="ng nh ni"><p id="aca1" class="jz ka nj kb b kc kd ke kf kg kh ki kj nk kl km kn nl kp kq kr nm kt ku kv kw ig bi translated">翻转是将一个比特改变为相反的值，即。 <code class="fe nd ne nf mt b"><em class="in">1 --&gt; 0</em></code> <em class="in">或</em> <code class="fe nd ne nf mt b"><em class="in">0 --&gt; 1</em></code> <em class="in">。</em></p></blockquote><p id="7ee3" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">输入:<code class="fe nd ne nf mt b">a = 2</code>、<code class="fe nd ne nf mt b">b = 6</code>、<code class="fe nd ne nf mt b">c = 5</code></p><p id="3fef" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">输出:<code class="fe nd ne nf mt b">3</code></p><p id="a183" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">解决方案和解释</strong></p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="e535" class="mx lm in mt b gy my mz l na nb">class MinFlips {<br/>    private static int helper(int a, int b, int c) {<br/>        int ans = 0;<br/>        for (int i = 0; i &lt; 32; i++) {<br/>            int bitC = ((c &gt;&gt; i) &amp; 1);<br/>            int bitA = ((a &gt;&gt; i) &amp; 1);<br/>            int bitB = ((b &gt;&gt; i) &amp; 1);</span><span id="d712" class="mx lm in mt b gy nc mz l na nb">            if ((bitA | bitB) != bitC) {<br/>                ans += (bitC == 0) ? (bitA == 1 &amp;&amp; bitB == 1) ? 2 : 1 : 1;<br/>            }<br/>        }<br/>        return ans;<br/>    }</span><span id="6565" class="mx lm in mt b gy nc mz l na nb">    public static void main(String[] args) {<br/>        int a = 2;<br/>        int b = 6;<br/>        int c = 5;<br/>        System.out.println("Min Flips required to make two numbers equal to third is : " + helper(a, b, c));<br/>    }<br/>}</span></pre><p id="3d67" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">首先，我们将<code class="fe nd ne nf mt b">ans</code>初始化为<code class="fe nd ne nf mt b">0</code>。然后我们从 0 - 31 的范围内循环。我们将<code class="fe nd ne nf mt b">bitA</code>、<code class="fe nd ne nf mt b">bitB</code>和<code class="fe nd ne nf mt b">bitC</code>初始化为等于我们的右移公式，并与 1:</p><p id="eda9" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><code class="fe nd ne nf mt b">(a/(2^i) &amp; 1</code></p><p id="11a8" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">然后，我们检查<code class="fe nd ne nf mt b">bitA | bitB</code>是否等于<code class="fe nd ne nf mt b">bitC</code>。如果是，我们继续检查<code class="fe nd ne nf mt b">bitC = 0</code>。从那里，如果<code class="fe nd ne nf mt b">bitA = 1</code>和<code class="fe nd ne nf mt b">bitB = 1</code>那么我们将<code class="fe nd ne nf mt b">ans</code>增加 2。否则，我们将<code class="fe nd ne nf mt b">ans</code>加 1。</p><p id="d5d1" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">最后我们返回<code class="fe nd ne nf mt b">ans</code>，每操作一次就加一。</p><h1 id="f8cd" class="ll lm in bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">按位异或:单个数字</h1><p id="a8e0" class="pw-post-body-paragraph jz ka in kb b kc mj ke kf kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw ig bi translated">查找数组中不重复的元素。</p><p id="ad21" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">输入:<code class="fe nd ne nf mt b">nums = { 4, 1, 2, 9, 1, 4, 2 }</code></p><p id="922a" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">输出:<code class="fe nd ne nf mt b">9</code></p><p id="1e9f" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">解决方案和解释</strong></p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="f83b" class="mx lm in mt b gy my mz l na nb">class SingleNumber {<br/>    private static int singleNumber(int[] nums) {<br/>        int xor = 0;<br/>        for (int num : nums) {<br/>            xor ^= num;<br/>        }<br/>        return xor;<br/>    }</span><span id="b40b" class="mx lm in mt b gy nc mz l na nb">    public static void main(String[] args) {<br/>        int[] nums = {4, 1, 2, 9, 1, 4, 2};<br/>        System.out.println("Element appearing one time is " + singleNumber(nums));<br/>    }<br/>}</span></pre><p id="164e" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">该解决方案依赖于以下逻辑:</p><ul class=""><li id="614d" class="kx ky in kb b kc kd kg kh kk kz ko la ks lb kw lc ld le lf bi translated">如果我们对零和某个位进行异或运算，它将返回该位:<code class="fe nd ne nf mt b">a ^ 0 = a</code></li><li id="b44a" class="kx ky in kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">如果我们对两个相同的位进行异或运算，它将返回 0: <code class="fe nd ne nf mt b">a ^ a = 0</code></li><li id="433f" class="kx ky in kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">对于 n 个数字，可以应用下面的数学公式:<code class="fe nd ne nf mt b">a ^ b ^ a = (a ^ a) ^ b = 0 ^ b = b</code></li></ul><p id="764a" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">举个例子，</p><p id="b098" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><code class="fe nd ne nf mt b">1 ^ 5 ^ 1 =</code></p><p id="e1ae" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><code class="fe nd ne nf mt b">(1 ^ 1) ^ 5 =</code></p><p id="48a0" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><code class="fe nd ne nf mt b">0 ^ 5 = 5</code></p><p id="61b7" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">因此，我们可以将所有位一起进行 XOR 运算，以找到唯一的数字。</p><h1 id="a624" class="ll lm in bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">按位左移:获取第一个设置位</h1><p id="edff" class="pw-post-body-paragraph jz ka in kb b kc mj ke kf kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw ig bi translated">给定一个整数，找出从右数第一个设置位(<code class="fe nd ne nf mt b">1</code>)的位置。</p><p id="4543" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">输入:<code class="fe nd ne nf mt b">n = 18</code></p><p id="8f44" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">18 进制= <code class="fe nd ne nf mt b">0b10010</code></p><p id="6ec6" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">输出:<code class="fe nd ne nf mt b">2</code></p><p id="db60" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">解决方案和解释</strong></p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="6af6" class="mx lm in mt b gy my mz l na nb">class FirstSetBitPosition {<br/>    private static int helper(int n) {<br/>        if (n == 0) {<br/>            return 0;<br/>        }</span><span id="1169" class="mx lm in mt b gy nc mz l na nb">        int k = 1;</span><span id="4453" class="mx lm in mt b gy nc mz l na nb">        while (true) {<br/>            if ((n &amp; (1 &lt;&lt; (k - 1))) == 0) {<br/>                k++;<br/>            } else {<br/>                return k;<br/>            }<br/>        }<br/>    }</span><span id="aefb" class="mx lm in mt b gy nc mz l na nb">    public static void main(String[] args) {<br/>        System.out.println("First setbit position for number: 18 is -&gt; " + helper(18));<br/>        System.out.println("First setbit position for number: 5 is -&gt; " + helper(5));<br/>        System.out.println("First setbit position for number: 32 is -&gt; " + helper(32));<br/>    }<br/>}</span></pre><p id="a8bf" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">该解决方案的逻辑依赖于左移和 and 运算的组合。</p><p id="e96c" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">本质上，我们首先使用<code class="fe nd ne nf mt b">bit &amp; 1</code>检查最右边的有效位是否是 set bet。如果没有，我们继续左移并检查，直到我们找到使我们的 and 运算产生的位<code class="fe nd ne nf mt b">1</code>。</p><p id="6a24" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">轮班次数由我们的指针<code class="fe nd ne nf mt b">k</code>跟踪。一旦我们找到设置位，我们返回<code class="fe nd ne nf mt b">k</code>作为我们的答案。</p><h1 id="1955" class="ll lm in bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">接下来学什么</h1><p id="8ef0" class="pw-post-body-paragraph jz ka in kb b kc mj ke kf kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw ig bi translated">祝贺您完成我们的钻头操作快速指南！钻头操作可能是一个很难学的话题，但是实践是提高的最好方法。</p><p id="cdde" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">当你寻找更多的练习时，看看这些练习题:</p><ul class=""><li id="4601" class="kx ky in kb b kc kd kg kh kk kz ko la ks lb kw lc ld le lf bi translated">找到丢失的数字</li><li id="7e53" class="kx ky in kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">使用右移找到第一个设置位</li><li id="5773" class="kx ky in kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">计算整数的位数</li><li id="5ad0" class="kx ky in kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">检查一个数是否是 2 的幂</li></ul><p id="cf79" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><em class="nj">快乐学习！</em></p></div></div>    
</body>
</html>