<html>
<head>
<title>Docker: A Beginners Introduction</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Docker:初学者入门</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/docker-a-beginners-introduction-556d2583da36?source=collection_archive---------7-----------------------#2020-09-07">https://blog.devgenius.io/docker-a-beginners-introduction-556d2583da36?source=collection_archive---------7-----------------------#2020-09-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/3dfeafd50f6dec0f8f258f1823e02a74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GU8Zdm-oyCWhxSmDNguxbA.jpeg"/></div></div></figure><p id="9f03" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个时代，公司比以往任何时候都更加依赖软件来保持竞争力。此外，软件开发领域最大的创新之一是<strong class="ka ir">容器</strong>的发明。</p><p id="1fb5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">容器的引入极大地改变了软件构建和运输的方式。由于docker的惊人功能，采用容器化的公司和团队使其开发人员无忧。</p><p id="910d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">今天，我们将讨论Docker的基本原理。</p><h1 id="6ce5" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">码头集装箱</h1><p id="95c5" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">让我们从以下几个问题开始:</p><ul class=""><li id="6467" class="lz ma iq ka b kb kc kf kg kj mb kn mc kr md kv me mf mg mh bi translated">我们为什么需要Docker？</li><li id="23a1" class="lz ma iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated">Docker能为我们做什么？</li></ul><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/770f96f76f52179c6a1a448630475bf6.png" data-original-src="https://miro.medium.com/v2/resize:fit:450/format:webp/1*io_ztNIhCNrIwT3SvsckYQ.png"/></div></figure><p id="4e5c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这些问题最好用一个不使用Docker的开发人员面临的场景来解释:</p><p id="66c6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">假设一个团队希望建立一个包含各种技术的全栈应用程序，比如使用Flask的web服务器、Postgres之类的数据库、Redis之类的消息传递系统以及Ansible之类的编排工具。</p><p id="186c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在开发这样一个项目时，可能会出现一些问题:</p><p id="c6a9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">底层操作系统的兼容性问题</strong>:开发者必须确保不同的服务与他们使用的操作系统版本兼容。</p><p id="058b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">依赖项和应用服务之间的兼容性问题</strong>:可能一个服务需要一个版本的库，而另一个服务需要另一个版本。每次依赖关系改变时，开发人员都必须检查这些不同组件和底层基础设施之间的兼容性。</p><p id="dae1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这种兼容性矩阵问题通常被称为“来自地狱的矩阵”。</p><p id="630d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为新开发人员建立一个环境是困难的:每当一个新开发人员加入团队，他将不得不遵循一大套指令并运行数百个命令来最终建立他们的环境。这当然是耗时且低效的。</p><p id="3b6c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">鉴于前面的困难，我们需要一些东西来帮助我们解决这些兼容性问题，允许我们独立地修改或更改应用程序的组件，甚至根据需要修改底层操作系统。</p><p id="16d8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这时Docker就开始发挥作用了。</p><p id="16b2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有了Docker，开发人员就能够在容器中运行应用程序组件，并拥有自己的库和依赖项，从而解决了之前的所有问题。</p><p id="2a20" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于许多开发人员来说，要运行一个应用程序的实例，必须构建一个docker配置，以后所有开发人员都可以使用一个简单的Docker run命令来运行该配置，而不考虑底层的操作系统。唯一的要求就是让Docker安装开发者的机器。</p><h1 id="c850" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">什么是容器？</h1><p id="9e8e" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">容器是完全隔离的环境。它们可以拥有自己的进程或服务、自己的网络接口、自己的虚拟机挂载，只是它们都共享相同的操作系统内核。我们稍后将讨论这一点的含义。</p><p id="c223" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">设置这些容器环境很难，因为它们需要低级的计算机操作系统知识。这就是Docker提供了一个具有几个强大功能的高级工具的地方，让像我们这样的最终用户真的很容易。</p><h1 id="3c61" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">Docker是如何工作的？</h1><p id="3f0f" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">要了解Docker的工作原理，我们必须了解一些基本的操作系统概念。</p><p id="6ef7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你看看像Ubuntu，Fedora，CentOS等操作系统。它们都由两部分组成:</p><ol class=""><li id="1743" class="lz ma iq ka b kb kc kf kg kj mb kn mc kr md kv ms mf mg mh bi translated">一个操作系统内核。</li><li id="8890" class="lz ma iq ka b kb mi kf mj kj mk kn ml kr mm kv ms mf mg mh bi translated">一套软件。</li></ol><p id="3094" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">操作系统内核负责与底层硬件交互。</p><p id="8288" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">OS内核，在本例中是Linux，保持不变。是它上面的软件让这些操作系统与众不同。</p><p id="8a57" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，你有一个所有操作系统共享的通用Linux内核和一些自定义软件来区分不同的操作系统。</p><p id="638a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">先前我们提到Docker容器共享底层内核。这意味着什么？</p><p id="1679" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这意味着任何使用相同内核的操作系统都可以运行相同风格的docker，而不管操作系统中使用的是什么软件。</p><p id="da02" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果底层操作系统是Ubuntu，Docker可以运行基于另一个发行版的容器，如Debian、Fedora、SUSE或CentOS。</p><p id="51da" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Docker不在主机上运行单独的内核。提醒一下，docker共享计算机的内核。</p><p id="8c6e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可能会问:那这难道不是一个缺点吗？不能在操作系统上运行另一个内核？答案是<strong class="ka ir">没有</strong>。Docker并不意味着在同一个硬件上虚拟化和运行不同的操作系统和内核。Docker的主要目的是将应用程序容器化，并运送和运行它们。</p><h1 id="6946" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">虚拟机和容器之间的区别</h1><p id="1a9e" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">在Docker(容器)的情况下，架构是用以下层结构构建的:</p><p id="06dc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在底部，我们有底层的硬件基础设施，然后是操作系统和安装在操作系统上的Docker。Docker随后可以单独管理与库和依赖项一起运行的容器。</p><p id="5f96" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在虚拟机的情况下:我们在底层硬件上有操作系统，然后是管理程序(这可以是任何类型)，在这之上是虚拟机。虚拟机的每个实例都有一个操作系统。最后，在操作系统之上是应用程序。可以想象，由于有多个虚拟操作系统和内核在运行，这种额外的开销会导致更多的资源使用。</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mt"><img src="../Images/c18b7180ddda79f61b12c100a57d3577.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*66cp6uoqv-q2clolRgSRJg.png"/></div></div></figure><p id="ce21" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">虚拟机还会消耗更多的磁盘空间，因为每个虚拟机都很“重”，通常以千兆字节为单位，而Docker容器是轻量级的，通常以兆字节为单位。</p><p id="3d38" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这使得Docker容器可以在几秒钟内更快地启动，而虚拟机可能需要几分钟才能启动。</p><p id="7cfb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">还需要注意的是，Docker的隔离性较低，因为更多的资源在容器(如内核)之间共享，而虚拟机彼此之间完全隔离。</p><p id="5c45" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为VMs不依赖底层操作系统或内核。您可以拥有不同类型的操作系统，例如基于Linux或基于Windows的相同虚拟机管理程序。这在单个Docker主机上是不可能的。</p><h1 id="d4cb" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">关于Docker和Docker存储库的更多信息</h1><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/41ea40c52d7369365ab69c0b164ad1ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:580/format:webp/1*yWEZ54ctXpyYnDPNFveoQg.png"/></div></figure><p id="76e2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">到目前为止，已经有很多应用程序的容器化版本。因此，大多数组织将他们的产品打包，并在一个名为Docker Hub或Docker store的公共Docker注册表中提供。</p><p id="1986" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，您可以找到最常见的操作系统、数据库以及其他服务和工具的映像。一旦您确定了您需要的映像，并且在您的主机上安装了Docker。启动应用程序堆栈就像运行以下程序一样简单:</p><pre class="mo mp mq mr gt mv mw mx my aw mz bi"><span id="2953" class="na kx iq mw b gy nb nc l nd ne">docker run [image name]</span></pre><p id="3b67" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您需要运行一个应用程序/服务的多个实例，只需根据需要添加尽可能多的实例，并在前端配置某种负载平衡器。</p><p id="cc2e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果其中一个实例希望失败，只需销毁该实例并启动一个新实例。</p><p id="28d6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如你所看到的，一旦你精通Docker，你就可以轻松地扩展一个非常强大的应用程序。</p><h1 id="7e10" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">图像与容器</h1><p id="88d2" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">映像是一个包或模板，就像虚拟机模板一样。它用于创建一个或多个容器。容器是独立运行的映像实例，它们有自己的环境和一组进程。</p><p id="8d31" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们从编程的角度考虑图像和容器:你可以认为图像是一个类定义，而容器是该类的一个实例。</p><p id="727c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如我们之前看到的，许多产品已经被“归档”。万一你找不到你要找的东西，你可以自己创建一个图像，并把它推送到Docker Hub库，让公众可以使用。</p><p id="27c6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有了Docker，建立基础设施所涉及的大部分工作现在以Docker文件的形式掌握在开发人员手中。开发人员以前为设置基础设施而构建的指南现在可以很容易地放入docker文件中，为应用程序创建映像。</p><p id="f733" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个映像现在可以在任何容器平台上运行，并且保证在任何地方都能以相同的方式运行。因此，运营团队现在可以简单地使用映像来部署应用程序。因为当开发人员构建映像时，它已经在工作，并且操作人员没有修改它，所以当部署到生产中时，它继续以相同的方式工作。</p></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><p id="587a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="nm">原载于</em><a class="ae nn" href="https://luispreciado.blog/posts/kubernetes/core-concepts/docker" rel="noopener ugc nofollow" target="_blank"><em class="nm">https://luispreciado . blog</em></a><em class="nm">。</em></p></div></div>    
</body>
</html>