<html>
<head>
<title>C++ Type Casting With Example for C Developers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向C开发人员的C++类型转换及示例</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/c-type-casting-with-an-example-for-c-developers-9ff5769e26b8?source=collection_archive---------2-----------------------#2019-10-13">https://blog.devgenius.io/c-type-casting-with-an-example-for-c-developers-9ff5769e26b8?source=collection_archive---------2-----------------------#2019-10-13</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/8701e23ec5d6f81baf4a44e60c695cb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GN3MWwIDDBRdOFEpCX-Byw.png"/></div></div></figure><p id="298a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这里，我们不仅会看到C++类型转换的例子，而且我还会介绍为什么我们需要它&amp;欺骗代码，让C开发人员容易记住它。虽然我不是专家，但这是我从各种来源和行业经验中学到的。</p><p id="4d49" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在C++中，有5种不同类型的类型转换:C风格转换、<code class="fe kt ku kv kw b">static_cast</code>、<code class="fe kt ku kv kw b">const_cast</code>、<code class="fe kt ku kv kw b">dynamic_cast</code>和<code class="fe kt ku kv kw b">reinterpret_cast</code>。</p><p id="fab0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是我的博客的交叉帖子。</p><p id="f9b5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我通常以“我们为什么需要它”开始，但这次我们首先快速浏览一些术语。</p><h1 id="5a38" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">你需要面对的术语</h1><ol class=""><li id="3247" class="lw lx in jx b jy ly kc lz kg ma kk mb ko mc ks md me mf mg bi translated"><strong class="jx io">隐式转换:</strong>编译器自动进行类型转换。和<code class="fe kt ku kv kw b">float f = 3;</code>一样，这里编译器不会抱怨，而是直接把整型的<code class="fe kt ku kv kw b">3</code>转换成<code class="fe kt ku kv kw b">float</code> &amp;赋值给<code class="fe kt ku kv kw b">f</code>。</li><li id="22db" class="lw lx in jx b jy mh kc mi kg mj kk mk ko ml ks md me mf mg bi translated"><strong class="jx io">显式转换</strong>:开发者使用一个造型操作符来指导转换。所有类型的手动强制转换都属于显式类型转换类别。和<code class="fe kt ku kv kw b">int * p = (int*)malloc(10);</code>一样，这里我们显式地将<code class="fe kt ku kv kw b">void*</code>造型为<code class="fe kt ku kv kw b">int*</code>。</li><li id="bdb9" class="lw lx in jx b jy mh kc mi kg mj kk mk ko ml ks md me mf mg bi translated"><code class="fe kt ku kv kw b"><strong class="jx io">l-value</strong></code>:代表存储位置的标识符。比如变量名，<code class="fe kt ku kv kw b">*ptr</code>其中<code class="fe kt ku kv kw b">ptr</code>指向一个内存位置等。</li><li id="17fe" class="lw lx in jx b jy mh kc mi kg mj kk mk ko ml ks md me mf mg bi translated"><code class="fe kt ku kv kw b"><strong class="jx io">r-value</strong></code>:赋值(<code class="fe kt ku kv kw b">=</code>)运算符右侧出现非<code class="fe kt ku kv kw b">l-value</code>、<code class="fe kt ku kv kw b">r-value</code>的值。喜欢</li></ol><pre class="mm mn mo mp gt mq kw mr ms aw mt bi"><span id="5cf9" class="mu kz in kw b gy mv mw l mx my">int a = 5; // 5 = r-value, <br/>q = p + 5; // p + 5 is r-value</span></pre><p id="9928" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">注意:虽然有一些例外&amp;关于<code class="fe kt ku kv kw b">l-value</code> &amp; <code class="fe kt ku kv kw b">r-value</code>还有更多要学的，我已经在这里讨论过<a class="ae kx" href="http://www.vishalchovatiya.com/lvalue-rvalue-and-their-references-with-example-in-cpp/" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="0dfc" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">为什么我们需要类型转换？</h1><ul class=""><li id="0f93" class="lw lx in jx b jy ly kc lz kg ma kk mb ko mc ks mz me mf mg bi translated">数据是内存中位(<code class="fe kt ku kv kw b">0</code>s&amp;s<code class="fe kt ku kv kw b">1</code>s)的表示。</li><li id="bf98" class="lw lx in jx b jy mh kc mi kg mj kk mk ko ml ks mz me mf mg bi translated">数据类型是编译器指令，它告诉编译器如何存储和处理特定的数据。</li><li id="099b" class="lw lx in jx b jy mh kc mi kg mj kk mk ko ml ks mz me mf mg bi translated"><code class="fe kt ku kv kw b">unsigned int a = 5;</code>通过该语句，您可以假设4个字节将被保留在您的存储器&amp;中。在执行时，它将在该存储器位置存储<code class="fe kt ku kv kw b">0000 0000 0000 0000 0000 0000 0000 0101</code>个数据位。这很简单。</li><li id="70cb" class="lw lx in jx b jy mh kc mi kg mj kk mk ko ml ks mz me mf mg bi translated">让我们再进一步，<code class="fe kt ku kv kw b">float f = 3.0;</code>这条语句还会在内存中保留4个字节&amp;以1的形式存储数据位)。符号位，2)。指数&amp; 3)。尾数。回想一下<a class="ae kx" href="http://www.vishalchovatiya.com/how-floating-point-no-is-stored-memory/" rel="noopener ugc nofollow" target="_blank">浮点数如何存储在内存中</a>。</li><li id="e2f6" class="lw lx in jx b jy mh kc mi kg mj kk mk ko ml ks mz me mf mg bi translated">但是当你像<code class="fe kt ku kv kw b">float f = 3;</code>那样写的时候，编译器会很困惑，如何在float类型的内存中存储一个整数值。</li><li id="c2ff" class="lw lx in jx b jy mh kc mi kg mj kk mk ko ml ks mz me mf mg bi translated">所以它会自动假定(这里是隐式转换)你想要存储<code class="fe kt ku kv kw b">3.0</code>而不是<code class="fe kt ku kv kw b">3</code>，从人类的角度来看这在技术上是相同的，但是从<a class="ae kx" href="http://www.vishalchovatiya.com/memory-layout-of-cpp-object/" rel="noopener ugc nofollow" target="_blank">计算机内存的角度来看</a>就不同了，因为它们存储的方式不同。</li><li id="64df" class="lw lx in jx b jy mh kc mi kg mj kk mk ko ml ks mz me mf mg bi translated">有很多这样的场景，你提供数据存储在内存中，用来表示不同的数据类型。</li><li id="1712" class="lw lx in jx b jy mh kc mi kg mj kk mk ko ml ks mz me mf mg bi translated">例如，在下面的例子中，您试图将类型为<code class="fe kt ku kv kw b">B</code>的对象分配给类型为<code class="fe kt ku kv kw b">A</code>的对象</li></ul><pre class="mm mn mo mp gt mq kw mr ms aw mt bi"><span id="733e" class="mu kz in kw b gy mv mw l mx my">class A{};<br/>class B{};</span><span id="95c0" class="mu kz in kw b gy na mw l mx my">int main ()<br/>{<br/>  B b;<br/>  A a = b; <br/>  return 0;<br/>}</span></pre><ul class=""><li id="6c10" class="lw lx in jx b jy jz kc kd kg nb kk nc ko nd ks mz me mf mg bi translated">在这种情况下，编译器不能做出任何假设&amp;只是抛出一个编译错误:</li></ul><pre class="mm mn mo mp gt mq kw mr ms aw mt bi"><span id="1e36" class="mu kz in kw b gy mv mw l mx my">exit status 1<br/>error: no viable conversion from 'B' to 'A'<br/>  A a = b;<br/>    ^   ~<br/>note: candidate constructor (the implicit copy constructor) not viable: no known conversion from 'B' to 'const A &amp;' for 1st argument<br/>class A{};<br/>      ^<br/>note: candidate constructor (the implicit move constructor) not viable: no known conversion from 'B' to 'A &amp;&amp;' for 1st argument<br/>class A{};<br/>      ^<br/>1 error generated.</span></pre><ul class=""><li id="d841" class="lw lx in jx b jy jz kc kd kg nb kk nc ko nd ks mz me mf mg bi translated">但是当您按如下方式定义转换运算符时:</li></ul><pre class="mm mn mo mp gt mq kw mr ms aw mt bi"><span id="4830" class="mu kz in kw b gy mv mw l mx my">class B {<br/>public:<br/>  operator A(){<br/>    cout&lt;&lt;"CONVERSION OPERATOR\n";<br/>    return A();<br/>  } <br/>};</span></pre><ul class=""><li id="1080" class="lw lx in jx b jy jz kc kd kg nb kk nc ko nd ks mz me mf mg bi translated">编译器将简单地调用这个成员函数&amp;不会抛出任何错误，因为程序员明确地提到这是他/她想要的转换方式。</li></ul><h1 id="4886" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">为c开发人员提供了一个5️⃣ C++类型转换的例子</h1><h1 id="ad9e" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated"><code class="fe kt ku kv kw b">C-style casts</code></h1><pre class="mm mn mo mp gt mq kw mr ms aw mt bi"><span id="b76c" class="mu kz in kw b gy mv mw l mx my">int main() { <br/>    float res = 10 / 4;<br/>    cout&lt;&lt;res&lt;&lt;endl;<br/>    return 0; <br/>}</span></pre><ul class=""><li id="a153" class="lw lx in jx b jy jz kc kd kg nb kk nc ko nd ks mz me mf mg bi translated">当您试图运行上面的代码时，您将得到我们没有预料到的输出<code class="fe kt ku kv kw b">2</code>。为了正确初始化<code class="fe kt ku kv kw b">res</code>变量，我们需要使用float进行如下类型转换:</li></ul><pre class="mm mn mo mp gt mq kw mr ms aw mt bi"><span id="1a55" class="mu kz in kw b gy mv mw l mx my">float res = (float)10 / 4;</span></pre><ul class=""><li id="7b3f" class="lw lx in jx b jy jz kc kd kg nb kk nc ko nd ks mz me mf mg bi translated">现在你的答案会是<code class="fe kt ku kv kw b">2.5</code>。这种类型的铸造是非常简单的&amp;直截了当，因为它出现。</li><li id="57b4" class="lw lx in jx b jy mh kc mi kg mj kk mk ko ml ks mz me mf mg bi translated">您也可以用C++将上述转换写成:</li></ul><pre class="mm mn mo mp gt mq kw mr ms aw mt bi"><span id="5dc9" class="mu kz in kw b gy mv mw l mx my">float res = float(10) / 4;</span></pre><ul class=""><li id="e53a" class="lw lx in jx b jy jz kc kd kg nb kk nc ko nd ks mz me mf mg bi translated">c风格的强制转换可以在不改变底层内存表示的情况下改变数据类型，这可能会导致垃圾结果。</li></ul><h1 id="f09a" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated"><code class="fe kt ku kv kw b">static_cast</code></h1><ul class=""><li id="6296" class="lw lx in jx b jy ly kc lz kg ma kk mb ko mc ks mz me mf mg bi translated">如果你像我一样是C开发人员，那么这将是你最好的goto C++ cast，它符合大多数例子，比如:</li></ul><pre class="mm mn mo mp gt mq kw mr ms aw mt bi"><span id="b3f1" class="mu kz in kw b gy mv mw l mx my">int * p = malloc(10);</span></pre><ul class=""><li id="83e4" class="lw lx in jx b jy jz kc kd kg nb kk nc ko nd ks mz me mf mg bi translated">当你试图用C编译器编译上述代码时，它工作得很好。但是C++编译器不够善良。它将抛出如下错误:</li></ul><pre class="mm mn mo mp gt mq kw mr ms aw mt bi"><span id="beac" class="mu kz in kw b gy mv mw l mx my">exit status 1<br/>error: cannot initialize a variable of type 'int *' with an rvalue of type 'void *'<br/>  int * p = malloc(10);<br/>        ^   ~~~~~~~~~~<br/>1 error generated.</span></pre><ul class=""><li id="04aa" class="lw lx in jx b jy jz kc kd kg nb kk nc ko nd ks mz me mf mg bi translated">你首先想到的是C风格的演员阵容:</li></ul><pre class="mm mn mo mp gt mq kw mr ms aw mt bi"><span id="d721" class="mu kz in kw b gy mv mw l mx my">int * p = (int*)malloc(10);</span></pre><ul class=""><li id="7e2b" class="lw lx in jx b jy jz kc kd kg nb kk nc ko nd ks mz me mf mg bi translated">这是可行的，但是在C++中不推荐这种类型的造型。像这样处理隐式转换。我们将主要在隐式转换失败的地方使用它进行转换，比如malloc。</li></ul><pre class="mm mn mo mp gt mq kw mr ms aw mt bi"><span id="590e" class="mu kz in kw b gy mv mw l mx my">int * p = static_cast&lt;int*&gt;(malloc(10));</span></pre><ul class=""><li id="9efc" class="lw lx in jx b jy jz kc kd kg nb kk nc ko nd ks mz me mf mg bi translated"><code class="fe kt ku kv kw b">static_cast</code>的主要优点是它提供了编译时类型检查，使得无意中出错变得更加困难。让我们用C++例子来理解这一点:</li></ul><pre class="mm mn mo mp gt mq kw mr ms aw mt bi"><span id="be98" class="mu kz in kw b gy mv mw l mx my">class B {};<br/>class D : public B {};<br/>class X {};</span><span id="274c" class="mu kz in kw b gy na mw l mx my">int main()<br/>{<br/>  D* d = new D;<br/>  B* b = static_cast&lt;B*&gt;(d); // this works<br/>  X* x = static_cast&lt;X*&gt;(d); // ERROR - Won't compile<br/>  return 0;<br/>}</span></pre><ul class=""><li id="c785" class="lw lx in jx b jy jz kc kd kg nb kk nc ko nd ks mz me mf mg bi translated">正如您所看到的，如果不了解所涉及的所有类，很难区分这两种情况。</li><li id="9a48" class="lw lx in jx b jy mh kc mi kg mj kk mk ko ml ks mz me mf mg bi translated">C风格造型的另一个问题是太难定位了。在复杂的表达式中，很难看到C风格的类型转换，例如<code class="fe kt ku kv kw b">T(something)</code>语法等同于<code class="fe kt ku kv kw b">(T)something</code>。</li></ul><h1 id="29f0" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated"><code class="fe kt ku kv kw b">const_cast</code></h1><ul class=""><li id="297a" class="lw lx in jx b jy ly kc lz kg ma kk mb ko mc ks mz me mf mg bi translated">现在我们将直接跳到例子。没有任何理论能比实例更好地解释这一点。</li></ul><p id="6d62" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> 1。忽略常量</strong></p><pre class="mm mn mo mp gt mq kw mr ms aw mt bi"><span id="2b4a" class="mu kz in kw b gy mv mw l mx my">int i = 0;<br/>const int&amp; ref = i;<br/>const int* ptr = &amp;i;</span><span id="db60" class="mu kz in kw b gy na mw l mx my">*ptr = 3; // Not OK<br/>const_cast&lt;int&amp;&gt;(ref) = 3;  //OK<br/>*const_cast&lt;int*&gt;(ptr) = 3; //OK</span></pre><ul class=""><li id="ba4b" class="lw lx in jx b jy jz kc kd kg nb kk nc ko nd ks mz me mf mg bi translated">您可以修改<code class="fe kt ku kv kw b">i</code>，因为被赋值的对象(此处为<code class="fe kt ku kv kw b">i</code>)不是<code class="fe kt ku kv kw b">const</code>。如果将const限定符添加到<code class="fe kt ku kv kw b">i</code>，代码将会编译，但是它的行为将是未定义的(这可能意味着从“它工作得很好”到“程序将崩溃&gt;”。)</li></ul><p id="18c2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> 2。使用</strong> <code class="fe kt ku kv kw b"><strong class="jx io">const</strong></code> <strong class="jx io"> </strong> <code class="fe kt ku kv kw b"><strong class="jx io">this</strong></code> <strong class="jx io">指针</strong>修改数据成员</p><ul class=""><li id="7fa2" class="lw lx in jx b jy jz kc kd kg nb kk nc ko nd ks mz me mf mg bi translated"><code class="fe kt ku kv kw b">const_cast</code>可用于通过一个方法改变非常数类成员，在该方法中该指针被声明为常量。-这在基于<code class="fe kt ku kv kw b">const</code>重载成员函数时也很有用，例如:</li></ul><pre class="mm mn mo mp gt mq kw mr ms aw mt bi"><span id="4cfa" class="mu kz in kw b gy mv mw l mx my">class X<br/>{<br/>public:<br/>    int var;<br/>    void changeAndPrint(int temp) const<br/>    {<br/>        this-&gt;var = temp;                    // Throw compilation error<br/>        (const_cast&lt;X *&gt;(this))-&gt;var = temp; // Works fine<br/>    }<br/>    void changeAndPrint(int *temp)<br/>    {<br/>        // Do some stuff<br/>    }<br/>};<br/>int main()<br/>{<br/>    int a = 4;<br/>    X x;<br/>    x.changeAndPrint(&amp;a);<br/>    x.changeAndPrint(5);<br/>    cout &lt;&lt; x.var &lt;&lt; endl;<br/>    return 0;<br/>}</span></pre><p id="5be0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> 3。将</strong> <code class="fe kt ku kv kw b"><strong class="jx io">const</strong></code> <strong class="jx io">参数传递给只接受非常数参数</strong>的函数</p><ul class=""><li id="6af0" class="lw lx in jx b jy jz kc kd kg nb kk nc ko nd ks mz me mf mg bi translated"><code class="fe kt ku kv kw b">const_cast</code>也可用于将常量数据传递给不接收常量参数的函数。请参见以下代码:</li></ul><pre class="mm mn mo mp gt mq kw mr ms aw mt bi"><span id="f20d" class="mu kz in kw b gy mv mw l mx my">int fun(int* ptr) <br/>{ <br/>    return (*ptr + 10); <br/>} </span><span id="3bfd" class="mu kz in kw b gy na mw l mx my">int main(void) <br/>{ <br/>    const int val = 10; <br/>    cout &lt;&lt; fun(const_cast &lt;int *&gt;(&amp;val)); <br/>    return 0; <br/>}</span></pre><p id="9d3d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> 4。漂流者</strong> <code class="fe kt ku kv kw b"><strong class="jx io">volatile</strong></code> <strong class="jx io">属性</strong></p><ul class=""><li id="ba91" class="lw lx in jx b jy jz kc kd kg nb kk nc ko nd ks mz me mf mg bi translated"><code class="fe kt ku kv kw b">const_cast</code>也可以用来丢弃<code class="fe kt ku kv kw b">volatile</code>属性。我们在上面的<code class="fe kt ku kv kw b">const_cast</code>中讨论的内容对于<code class="fe kt ku kv kw b">volatile</code>关键字也是有效的。</li></ul><h1 id="804b" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated"><code class="fe kt ku kv kw b">dynamic_cast</code></h1><ul class=""><li id="03a2" class="lw lx in jx b jy ly kc lz kg ma kk mb ko mc ks mz me mf mg bi translated"><code class="fe kt ku kv kw b">dynamic_cast</code>在运行时使用类型检查，而<code class="fe kt ku kv kw b">static_cast</code>在编译时使用类型检查。<code class="fe kt ku kv kw b">dynamic_cast</code>在你不知道它所代表的输入类型时更有用。让我们假设:</li></ul><pre class="mm mn mo mp gt mq kw mr ms aw mt bi"><span id="0ee4" class="mu kz in kw b gy mv mw l mx my">Base* CreateRandom()<br/>{<br/>    if( (rand()%2) == 0 )<br/>        return new Derived1;<br/>    else<br/>        return new Derived2;<br/>}</span><span id="33d1" class="mu kz in kw b gy na mw l mx my">Base* base = CreateRandom();</span></pre><ul class=""><li id="ce17" class="lw lx in jx b jy jz kc kd kg nb kk nc ko nd ks mz me mf mg bi translated">如你所见，我们不知道运行时<code class="fe kt ku kv kw b">CreateRandom()</code>将返回哪个对象，但是如果它返回<code class="fe kt ku kv kw b">Derived1</code>，你想执行<code class="fe kt ku kv kw b">Derived1</code>的<code class="fe kt ku kv kw b">Method1()</code>。所以在这个场景中，您可以如下使用<code class="fe kt ku kv kw b">dynamic_cast</code></li></ul><pre class="mm mn mo mp gt mq kw mr ms aw mt bi"><span id="62c2" class="mu kz in kw b gy mv mw l mx my">Derived1 *pD1 = dynamic_cast&lt;Derived1 *&gt;(base);<br/>if (pD1){<br/>    pD1-&gt;Method1();<br/>}</span></pre><ul class=""><li id="f126" class="lw lx in jx b jy jz kc kd kg nb kk nc ko nd ks mz me mf mg bi translated">如果<code class="fe kt ku kv kw b">dynamic_cast</code>的输入没有指向有效数据，它将返回<code class="fe kt ku kv kw b">nullptr</code>作为指针或者抛出<code class="fe kt ku kv kw b">std::bad_cast</code>异常作为引用。为了使用<code class="fe kt ku kv kw b">dynamic_cast</code>，你的类必须是多态类型，也就是说必须包含至少一个虚拟方法。</li><li id="1c06" class="lw lx in jx b jy mh kc mi kg mj kk mk ko ml ks mz me mf mg bi translated"><code class="fe kt ku kv kw b">dynamic_cast</code>利用<code class="fe kt ku kv kw b">RTTI</code> ( <a class="ae kx" href="https://en.wikipedia.org/wiki/Run-time_type_information" rel="noopener ugc nofollow" target="_blank">运行时类型识别</a>)机制。</li></ul><h1 id="5662" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated"><code class="fe kt ku kv kw b">reinterpret_cast</code></h1><ul class=""><li id="4397" class="lw lx in jx b jy ly kc lz kg ma kk mb ko mc ks mz me mf mg bi translated"><code class="fe kt ku kv kw b">reinterpret_cast</code>是一个编译器指令，它告诉编译器将当前类型视为新类型。</li><li id="8b3a" class="lw lx in jx b jy mh kc mi kg mj kk mk ko ml ks mz me mf mg bi translated">您可以使用<code class="fe kt ku kv kw b">reinterpret_cast</code>将任何指针或整型转换为任何其他指针或整型。</li><li id="91a7" class="lw lx in jx b jy mh kc mi kg mj kk mk ko ml ks mz me mf mg bi translated">这会导致危险的情况:没有什么能阻止你将<code class="fe kt ku kv kw b">int</code>转换成<code class="fe kt ku kv kw b">std::string*</code>。</li><li id="4b62" class="lw lx in jx b jy mh kc mi kg mj kk mk ko ml ks mz me mf mg bi translated">您将在您的嵌入式系统中使用<code class="fe kt ku kv kw b">reinterpret_cast</code>。<code class="fe kt ku kv kw b">reinterpret_cast</code>适用的一个常见场景是在<code class="fe kt ku kv kw b">uintptr_t</code>和实际指针之间进行转换，或者在:</li></ul><pre class="mm mn mo mp gt mq kw mr ms aw mt bi"><span id="afe2" class="mu kz in kw b gy mv mw l mx my">error: static_cast from 'int *' to 'uintptr_t'<br/>      (aka 'unsigned long') is not allowed<br/>        uintptr_t ptr = static_cast&lt;uintptr_t&gt;(p);<br/>                        ^~~~~~~~~~~~~~~~~~~~~~~~~<br/>1 error generated.</span></pre><ul class=""><li id="719c" class="lw lx in jx b jy jz kc kd kg nb kk nc ko nd ks mz me mf mg bi translated">相反，使用这个:</li></ul><pre class="mm mn mo mp gt mq kw mr ms aw mt bi"><span id="11e0" class="mu kz in kw b gy mv mw l mx my">uintptr_t ptr = reinterpret_cast&lt;uintptr_t&gt;(p);</span></pre><p id="e71a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我试图涵盖大部分的复杂性，以理清不同类型转换背后的主要概念，但仍然有可能会错过一些。所以，这是C++类型转换的一个例子，供C开发人员使用。让我们快速回顾一下:</p><h1 id="ff17" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">C开发人员在类型转换上转向C++的欺骗代码</h1><p id="e3f9" class="pw-post-body-paragraph jv jw in jx b jy ly ka kb kc lz ke kf kg ne ki kj kk nf km kn ko ng kq kr ks ig bi translated">读完这些后，你可能会搞不清楚什么时候用什么！这就是为什么我创造了这个作弊代码</p><ul class=""><li id="a3e8" class="lw lx in jx b jy jz kc kd kg nb kk nc ko nd ks mz me mf mg bi translated">避免C风格的造型。选角的时候要确定自己想要什么。</li><li id="d2a4" class="lw lx in jx b jy mh kc mi kg mj kk mk ko ml ks mz me mf mg bi translated">在使用C型铸造的地方使用<code class="fe kt ku kv kw b">static_cast</code>。</li><li id="d4a2" class="lw lx in jx b jy mh kc mi kg mj kk mk ko ml ks mz me mf mg bi translated">对多态类使用<code class="fe kt ku kv kw b">dynamic_cast</code>。请记住，只在继承层次结构中至少有一个虚拟成员的类上使用<code class="fe kt ku kv kw b">dynamic_cast</code>。</li><li id="0282" class="lw lx in jx b jy mh kc mi kg mj kk mk ko ml ks mz me mf mg bi translated">当您需要移除<code class="fe kt ku kv kw b">const</code>或<code class="fe kt ku kv kw b">volatile</code>限定符时，请使用<code class="fe kt ku kv kw b">const_cast</code>。</li><li id="261c" class="lw lx in jx b jy mh kc mi kg mj kk mk ko ml ks mz me mf mg bi translated">当你没有选择时，使用<code class="fe kt ku kv kw b">reinterpret_cast</code>。</li></ul><p id="e74b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">注意:<code class="fe kt ku kv kw b">const_cast</code>和<code class="fe kt ku kv kw b">reinterpret_cast</code>通常应该避免使用，因为如果使用不当，它们可能是有害的。除非你有充分的理由使用它们，否则不要使用它。</p></div></div>    
</body>
</html>