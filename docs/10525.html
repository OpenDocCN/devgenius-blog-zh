<html>
<head>
<title>Optimize S3 API cost for Data Lake</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">优化数据湖的 S3 API 成本</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/optimize-s3-api-cost-for-data-lake-3d14b9a0c130?source=collection_archive---------3-----------------------#2022-11-08">https://blog.devgenius.io/optimize-s3-api-cost-for-data-lake-3d14b9a0c130?source=collection_archive---------3-----------------------#2022-11-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="c2c6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在之前的<a class="ae ki" href="https://medium.com/@faisal-22508/analysis-of-s3-api-cost-for-data-lake-3b0fc4b7c19c" rel="noopener">文章</a>中，我们讨论了如何识别导致高 S3 API 成本的 S3 数据集。一旦我们有了表的列表，下一步就是看看我们是否可以降低与这些表相关的成本。</p><h2 id="0c8c" class="kj kk in bd kl km kn dn ko kp kq dp kr jv ks kt ku jz kv kw kx kd ky kz la lb bi translated">如何计算 S3 API 成本</h2><p id="56e4" class="pw-post-body-paragraph jk jl in jm b jn lc jp jq jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh ig bi translated">在讨论 API 成本时，要记住的最重要的事情是<em class="lh"> API 调用依赖于添加或检索的对象数量，而与对象大小无关。</em>这意味着大量的小对象会增加 Get 和 Put API 调用的成本。</p><p id="868a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了降低成本，我们需要减少使用 Athena 或任何其他查询引擎从数据湖中读取表时要扫描的对象数量。可以通过两种方式完成:<em class="lh">分区</em>和<em class="lh">分桶。</em>我们将讨论这两个问题，但是<strong class="jm io"><em class="lh"/>是对我很有效的技巧。</strong></p><h2 id="5a32" class="kj kk in bd kl km kn dn ko kp kq dp kr jv ks kt ku jz kv kw kx kd ky kz la lb bi translated">分割</h2><p id="5a14" class="pw-post-body-paragraph jk jl in jm b jn lc jp jq jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh ig bi translated">分区是一个众所周知的话题——对这个话题的详细讨论超出了本文的范围。您可以在此阅读如何为数据湖对 S3 数据进行分区— <a class="ae ki" href="https://docs.aws.amazon.com/athena/latest/ug/partitions.html" rel="noopener ugc nofollow" target="_blank"> AWS 文档</a></p><p id="3d87" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">要对现有的未分区表进行分区，可以使用 Athena 的<em class="lh"> CTAS </em>命令— <a class="ae ki" href="https://docs.aws.amazon.com/athena/latest/ug/ctas-examples.html#ctas-example-partitioned" rel="noopener ugc nofollow" target="_blank"> AWS doc </a></p><p id="0b20" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果表有超过 100 个分区，您可以使用<em class="lh">INSERT INTO—</em><a class="ae ki" href="https://docs.aws.amazon.com/athena/latest/ug/ctas-insert-into.html" rel="noopener ugc nofollow" target="_blank">AWS doc</a></p><h2 id="c83d" class="kj kk in bd kl km kn dn ko kp kq dp kr jv ks kt ku jz kv kw kx kd ky kz la lb bi translated">确认查询中使用了分区</h2><p id="6a7a" class="pw-post-body-paragraph jk jl in jm b jn lc jp jq jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh ig bi translated">如果分区表的 API 开销很高，首先要做的是确保查询中实际使用了分区:</p><ul class=""><li id="5a07" class="li lj in jm b jn jo jr js jv lk jz ll kd lm kh ln lo lp lq bi translated">使用<em class="lh"> SHOW PARTITIONS table_name 确认分区元数据已更新。它显示所有列出的分区</em></li><li id="e0e0" class="li lj in jm b jn lr jr ls jv lt jz lu kd lv kh ln lo lp lq bi translated">确保扫描数据时使用分区键。这一点非常重要，因为在很多边缘情况下，分区键会被忽略。例如，如果分区名在<strong class="jm io">子查询</strong>的<code class="fe lw lx ly lz b">WHERE</code>子句中，Athena 当前不会过滤分区。Athena 中的 EXPLAIN 命令可用于确认分区键的使用</li></ul><pre class="ma mb mc md gt me lz mf mg aw mh bi"><span id="a4a8" class="kj kk in lz b gy mi mj l mk ml">-- Table is partitioned by (year,month,day,hour)<br/>explain select device_id from ticket <br/>where year = '2022' and month ='11' and day = '6' and hour = '13'</span><span id="3056" class="kj kk in lz b gy mm mj l mk ml">-- Result<br/>Query Plan<br/>Fragment 0 [SOURCE]<br/>    Output layout: [device_id]<br/>    Output partitioning: SINGLE []<br/>    Output[columnNames = [device_id]]<br/>    │   Layout: [device_id:varchar]<br/>    │   Estimates: <br/>    └─ TableScan[table = awsdatacatalog:&lt;athena_db_name&gt;:ticket]<br/>           Layout: [device_id:varchar]<br/>           Estimates: <br/>           device_id := device_id:string:REGULAR<br/>           year:string:PARTITION_KEY<br/>               :: [[2022]]<br/>           day:string:PARTITION_KEY<br/>               :: [[6]]<br/>           month:string:PARTITION_KEY<br/>               :: [[11]]<br/>           hour:string:PARTITION_KEY<br/>               :: [[13]]</span></pre><p id="5345" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">命令输出将清楚地显示查询执行中将使用哪些分区键和值。这可以用于 Athena 上的任何 SQL，如果没有如上所示的分区键，或者如果键具有所有可能的值，这意味着没有使用键，将发生全表扫描。</p><p id="77e4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果在执行查询时没有使用分区键，如果可能的话尝试改变 SQL，或者也许<em class="lh">分桶</em>是最好的解决方案，这是下一个主题。</p><h2 id="bdac" class="kj kk in bd kl km kn dn ko kp kq dp kr jv ks kt ku jz kv kw kx kd ky kz la lb bi translated">存储基础知识</h2><p id="1b7f" class="pw-post-body-paragraph jk jl in jm b jn lc jp jq jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh ig bi translated">分桶是一种将基于特定列的数据分组到单个分区中的技术。这些列被称为<em class="lh">桶键</em>。创建表格时，我们可以指定表格在 S3 路径中应该包含的文件数量。随着文件数量的急剧减少，S3 API 的成本也以同样的比例减少。这是解决巨额 API 成本的最有效方法。</p><p id="9432" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Athena 支持 CTAS 命令来创建分桶表。您可以使用基数高的列作为<em class="lh">桶键</em></p><pre class="ma mb mc md gt me lz mf mg aw mh bi"><span id="ff2e" class="kj kk in lz b gy mi mj l mk ml">CREATE TABLE merged_tables.ticket<br/>WITH (<br/>format = 'PARQUET',<br/>external_location = 's3://de-experements/databases/merged_tables/ticket',<br/>bucketed_by = ARRAY['device_id'],<br/>bucket_count = 10)<br/>AS SELECT *<br/>FROM raw_tables.ticket;<br/>-- target table will have exactly 10 files in S3. If source table has 10K files and did full table scan, we will see API count reduction of ~1000X for this data set</span></pre><h2 id="6917" class="kj kk in bd kl km kn dn ko kp kq dp kr jv ks kt ku jz kv kw kx kd ky kz la lb bi translated">确认分桶表更划算</h2><p id="3eb8" class="pw-post-body-paragraph jk jl in jm b jn lc jp jq jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh ig bi translated">现在我们知道了如何使用 SQL 创建分桶表。确保分桶表更具成本效益的最佳方法是在 SQL 的回填中使用分桶表。</p><p id="269b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">假设您从分析师那里获得了新的 SQL。他们希望回填最近三年的目标表，这意味着您必须运行 SQL 数百次(如果 SQL 是针对一天的，并且要追加结果)</p><ul class=""><li id="26c1" class="li lj in jm b jn jo jr js jv lk jz ll kd lm kh ln lo lp lq bi translated">为每个源表创建分桶表。对分时段表位置使用单独的 S3 时段。</li><li id="6215" class="li lj in jm b jn lr jr ls jv lt jz lu kd lv kh ln lo lp lq bi translated">将 SQL 指向分桶表，并从调度器运行回填 SQL(我们使用气流)</li><li id="1cf6" class="li lj in jm b jn lr jr ls jv lt jz lu kd lv kh ln lo lp lq bi translated">回填完成后，检查 S3 桶中用于分桶表的 S3 API 的成本是多少。</li></ul><p id="33ae" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果没有回填，您可以创建分桶表，并在这些表上重复运行一些日常 SQL，比较 API 成本。</p><h2 id="7e56" class="kj kk in bd kl km kn dn ko kp kq dp kr jv ks kt ku jz kv kw kx kd ky kz la lb bi translated">如何存储现有表</h2><p id="a238" class="pw-post-body-paragraph jk jl in jm b jn lc jp jq jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh ig bi translated">在大多数情况下，数据作为单个文件从批处理或流管道写入 S3，不可能在每次写入 S3 时重新创建分桶表。</p><p id="3aa8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里有一个简单的使用策略。这里我们有一个<code class="fe lw lx ly lz b"><em class="lh">raw_table</em></code>和一个对应的<code class="fe lw lx ly lz b"><em class="lh">bucketed_table</em></code> <em class="lh">(从<em class="lh"> </em> <code class="fe lw lx ly lz b"><em class="lh">raw_table</em></code> <em class="lh"> ) </em>创建的</em></p><ul class=""><li id="1b82" class="li lj in jm b jn jo jr js jv lk jz ll kd lm kh ln lo lp lq bi translated">我们将保持<code class="fe lw lx ly lz b"><em class="lh">raw_table</em></code><em class="lh"/><em class="lh">完好无损。写至<code class="fe lw lx ly lz b">raw_table</code>的 S3 位置将照常发生。</em></li><li id="a892" class="li lj in jm b jn lr jr ls jv lt jz lu kd lv kh ln lo lp lq bi translated"><code class="fe lw lx ly lz b"><em class="lh">bucketed_table</em></code> <em class="lh"> </em>每周(或者你决定的任何频率)从<em class="lh"> raw_table </em>中创建。该表创建后，任何写入<code class="fe lw lx ly lz b"><em class="lh">raw_table’s</em></code> <em class="lh"> </em> S3 位置<em class="lh"> </em>的文件也会被复制到<code class="fe lw lx ly lz b"><em class="lh">bucketed_table’s</em></code> <em class="lh"> </em> S3 位置<em class="lh">。</em></li><li id="45be" class="li lj in jm b jn lr jr ls jv lt jz lu kd lv kh ln lo lp lq bi translated">因此<code class="fe lw lx ly lz b"><em class="lh">bucketed_table</em></code> <em class="lh">将在最近 N 天内拥有分桶文件和附加文件。</em></li><li id="6925" class="li lj in jm b jn lr jr ls jv lt jz lu kd lv kh ln lo lp lq bi translated">下周，我们将删除<code class="fe lw lx ly lz b"> <em class="lh">bucketed_table</em> </code>，清理 S3 位置，并从<code class="fe lw lx ly lz b"><em class="lh">raw_table</em></code>T7 重新创建它。— N 现在<em class="lh">分桶 _ 表</em>只有分桶文件。</li><li id="6149" class="li lj in jm b jn lr jr ls jv lt jz lu kd lv kh ln lo lp lq bi translated">如果<code class="fe lw lx ly lz b"><em class="lh">raw_table</em></code> <em class="lh"> </em>被分区，则表中会有额外的列可用。因此，当在<em class="lh"> bucketed_table </em>中写入单个文件时，请确保将这些列添加到文件中</li></ul><p id="7dca" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让所有的 SQL 都在<code class="fe lw lx ly lz b"><em class="lh">bucketed_table</em></code> <em class="lh"> </em>和<em class="lh"> </em>上运行，你会看到 S3 API 成本的大幅降低，而且大部分查询都会快得多。</p><h2 id="fc06" class="kj kk in bd kl km kn dn ko kp kq dp kr jv ks kt ku jz kv kw kx kd ky kz la lb bi translated">结论</h2><p id="8727" class="pw-post-body-paragraph jk jl in jm b jn lc jp jq jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh ig bi translated">表格分桶是降低 S3 API 成本的一项非常有用的技术，无需太多努力即可在生产管道中实施。</p></div></div>    
</body>
</html>