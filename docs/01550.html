<html>
<head>
<title>Builder Design Pattern in Modern C++</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">现代C++中的生成器设计模式</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/builder-design-pattern-in-modern-c-7ca0e259e1b4?source=collection_archive---------11-----------------------#2020-07-06">https://blog.devgenius.io/builder-design-pattern-in-modern-c-7ca0e259e1b4?source=collection_archive---------11-----------------------#2020-07-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/c77d9887234379f0373529f0acd74219.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Pp2y5VBnp_JiLT7xwcf4YA.png"/></div></div></figure><p id="c232" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在软件工程中，创造性的设计模式处理对象创建机制，试图以适合情况的方式创建对象。对象创建的基本或普通形式会导致设计问题或增加设计的复杂性。C++中的Builder设计模式通过<strong class="ka ir"> <em class="kw">将复杂对象的构造与其表示</em> </strong>分离来解决这个具体问题。</p><blockquote class="kx ky kz"><p id="7286" class="jy jz kw ka b kb kc kd ke kf kg kh ki la kk kl km lb ko kp kq lc ks kt ku kv ij bi translated"><em class="iq"> /！\:这篇文章最初发表在我的博客上。如果你有兴趣接收我的最新文章，</em> <a class="ae ld" href="http://eepurl.com/gDNybv" rel="noopener ugc nofollow" target="_blank"> <em class="iq">请报名参加我的简讯</em> </a> <em class="iq">。</em></p></blockquote><p id="2855" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">顺便说一句，如果你还没有看过我关于创造性设计模式的其他文章，那么下面是列表:</p><ol class=""><li id="fc96" class="le lf iq ka b kb kc kf kg kj lg kn lh kr li kv lj lk ll lm bi translated"><a class="ae ld" href="http://www.vishalchovatiya.com/factory-design-pattern-in-modern-cpp/" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">工厂</strong> </a></li><li id="b841" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated"><a class="ae ld" href="http://www.vishalchovatiya.com/builder-design-pattern-in-modern-cpp/" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">建造者</strong> </a></li><li id="2149" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated"><a class="ae ld" href="http://www.vishalchovatiya.com/prototype-design-pattern-in-modern-cpp/" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">原型</strong> </a></li><li id="ea18" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated"><a class="ae ld" href="http://www.vishalchovatiya.com/singleton-design-pattern-in-modern-cpp/" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">单胎</strong> </a></li></ol><p id="e8b1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您在这一系列文章中看到的代码片段是简化的，而不是复杂的。所以你经常看到我不使用像<code class="fe ls lt lu lv b">override</code>、<code class="fe ls lt lu lv b">final</code>、<code class="fe ls lt lu lv b">public</code>(同时继承)这样的关键字，只是为了让代码紧凑&amp;可消耗(大部分时间)在单一标准屏幕尺寸。我也更喜欢<code class="fe ls lt lu lv b">struct</code>而不是<code class="fe ls lt lu lv b">class</code>，只是为了节省代码行，有时不写<code class="fe ls lt lu lv b">public:</code>，也故意忽略<a class="ae ld" href="http://www.vishalchovatiya.com/part-3-all-about-virtual-keyword-in-c-how-virtual-destructor-works/" rel="noopener ugc nofollow" target="_blank">虚析构函数</a>，构造函数<a class="ae ld" href="http://www.vishalchovatiya.com/all-about-copy-constructor-in-cpp-with-example/" rel="noopener ugc nofollow" target="_blank">，复制构造函数</a>，前缀<code class="fe ls lt lu lv b">std::</code>，删除动态内存。我也认为自己是一个务实的人，希望用尽可能简单的方式，而不是标准的方式或使用术语来传达一个想法。</p><p id="1a1d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> <em class="kw">注:</em>T42】</strong></p><ul class=""><li id="9018" class="le lf iq ka b kb kc kf kg kj lg kn lh kr li kv lw lk ll lm bi translated">如果你直接来到这里，那么我建议你浏览一下<a class="ae ld" href="http://www.vishalchovatiya.com/what-is-design-pattern/" rel="noopener ugc nofollow" target="_blank">什么是设计模式？</a>第一，哪怕是微不足道的小事。相信会鼓励你对这个话题进行更多的探索。</li><li id="9562" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lw lk ll lm bi translated">您在本系列文章中遇到的所有这些代码都是使用C++20编译的(尽管我在大多数情况下使用了C++17的<a class="ae ld" href="http://www.vishalchovatiya.com/21-new-features-of-modern-cpp-to-use-in-your-project/" rel="noopener ugc nofollow" target="_blank">现代C++ </a>特性)。所以如果你没有最新的编译器，你可以使用已经预装了boost库的https://wandbox.org/。</li></ul><h1 id="44ca" class="lx ly iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">目的</h1><blockquote class="kx ky kz"><p id="374b" class="jy jz kw ka b kb kc kd ke kf kg kh ki la kk kl km lb ko kp kq lc ks kt ku kv ij bi translated"><strong class="ka ir">通过在单独的实体中提供API，简洁地创建/实例化复杂的&amp;复杂的对象分段&amp;。</strong></p></blockquote><ul class=""><li id="26d5" class="le lf iq ka b kb kc kf kg kj lg kn lh kr li kv lw lk ll lm bi translated">当我们想要构造一个复杂的对象时，使用构建器设计模式。然而，我们不希望有一个复杂的构造函数成员或者一个需要很多参数的成员。</li><li id="b2c7" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lw lk ll lm bi translated">构建器设计模式逐步构建一个复杂的对象&amp;最后一步将返回该对象。构造一个对象的过程应该是通用的，这样它就可以在各种方法的帮助下创建同一对象的不同表示。</li></ul><h1 id="9832" class="lx ly iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">没有建设者的生活</h1><ul class=""><li id="77fc" class="le lf iq ka b kb mv kf mw kj mx kn my kr mz kv lw lk ll lm bi translated">假设您必须使用C++创建HTML生成器，那么非常简单的方法就是:</li></ul><pre class="na nb nc nd gt ne lv nf ng aw nh bi"><span id="ac66" class="ni ly iq lv b gy nj nk l nl nm">// &lt;p&gt;hello&lt;/p&gt;<br/>auto text = "hello";<br/>string output;<br/>output += "&lt;p&gt;";<br/>output += text;<br/>output += "&lt;/p&gt;";<br/>printf("&lt;p&gt;%s&lt;/p&gt;", text);</span><span id="80ab" class="ni ly iq lv b gy nn nk l nl nm">// &lt;ul&gt;&lt;li&gt;hello&lt;/li&gt;&lt;li&gt;world&lt;/li&gt;&lt;/ul&gt;<br/>string words[] = {"hello", "world"};<br/>ostringstream oss;<br/>oss &lt; "&lt;ul&gt;";<br/>for (auto w : words)<br/>    oss &lt; "  &lt;li&gt;" &lt; w &lt; "&lt;/li&gt;";<br/>oss &lt; "&lt;/ul&gt;";<br/>printf(oss.str().c_str());</span></pre><ul class=""><li id="89c1" class="le lf iq ka b kb kc kf kg kj lg kn lh kr li kv lw lk ll lm bi translated">一个成熟的开发人员会创建一个带有一堆构造函数参数和方法的类来添加一个子节点。这是一个很好的方法，但是它可能会使对象表示复杂化。</li><li id="0300" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lw lk ll lm bi translated">一般来说，有些对象很简单&amp;可以在一次构造函数调用中创建，而其他对象则需要大量的创建过程。</li><li id="3f41" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lw lk ll lm bi translated">拥有一个有10个构造函数参数的对象是没有效率的。相反，我们应该选择分段施工。</li><li id="a363" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lw lk ll lm bi translated">Builder提供了一个API，用于一步一步地构造对象，而不显示实际的对象表示。</li></ul><h1 id="283f" class="lx ly iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">现代C++中的生成器设计模式示例</h1><pre class="na nb nc nd gt ne lv nf ng aw nh bi"><span id="ce4a" class="ni ly iq lv b gy nj nk l nl nm">class HtmlBuilder;</span><span id="b8b0" class="ni ly iq lv b gy nn nk l nl nm">class HtmlElement {<br/>    string                      m_name;<br/>    string                      m_text;<br/>    vector&lt;HtmlElement&gt;         m_childs;<br/>    constexpr static size_t     m_indent_size = 4;</span><span id="a6f7" class="ni ly iq lv b gy nn nk l nl nm">    HtmlElement() = default;<br/>    HtmlElement(const string &amp;name, const string &amp;text) : m_name(name), m_text(text) {}<br/>    friend class HtmlBuilder;</span><span id="bbb5" class="ni ly iq lv b gy nn nk l nl nm">public:<br/>    string str(int32_t indent = 0) {<br/>        ostringstream oss;<br/>        oss &lt;&lt; string(m_indent_size * indent, ' ') &lt;&lt; "&lt;" &lt;&lt; m_name &lt;&lt; "&gt;" &lt;&lt; endl;</span><span id="2c9d" class="ni ly iq lv b gy nn nk l nl nm">        if (m_text.size()) oss &lt;&lt; string(m_indent_size * (indent + 1), ' ') &lt;&lt; m_text &lt;&lt; endl;</span><span id="51dd" class="ni ly iq lv b gy nn nk l nl nm">        for (auto &amp;element : m_childs)<br/>            oss &lt;&lt; element.str(indent + 1);</span><span id="7f3a" class="ni ly iq lv b gy nn nk l nl nm">        oss &lt;&lt; string(m_indent_size * indent, ' ') &lt;&lt; "&lt;/" &lt;&lt; m_name &lt;&lt; "&gt;" &lt;&lt; endl;<br/>        return oss.str();<br/>    }<br/>    static unique_ptr&lt;HtmlBuilder&gt; build(string root_name) { return make_unique&lt;HtmlBuilder&gt;(root_name); }<br/>};</span><span id="295f" class="ni ly iq lv b gy nn nk l nl nm">class HtmlBuilder {<br/>    HtmlElement     m_root;</span><span id="8899" class="ni ly iq lv b gy nn nk l nl nm">public:<br/>    HtmlBuilder(string root_name) { m_root.m_name = root_name; }<br/>    HtmlBuilder *add_child(string child_name, string child_text) {<br/>        m_root.m_childs.emplace_back(HtmlElement{child_name, child_text});<br/>        return this;<br/>    }<br/>    string str() { return m_root.str(); }<br/>    operator HtmlElement() { return m_root; }<br/>};</span><span id="3302" class="ni ly iq lv b gy nn nk l nl nm">int main() {<br/>    auto builder = HtmlElement::build("ul");<br/>    builder-&gt;add_child("li", "hello")-&gt;add_child("li", "world");</span><span id="b25e" class="ni ly iq lv b gy nn nk l nl nm">    cout &lt;&lt; builder-&gt;str() &lt;&lt; endl;<br/>    return EXIT_SUCCESS;<br/>}<br/>/*<br/>&lt;ul&gt;<br/>    &lt;li&gt;<br/>        hello<br/>    &lt;/li&gt;<br/>    &lt;li&gt;<br/>        world<br/>    &lt;/li&gt;<br/>&lt;/ul&gt;<br/>*/</span></pre><ul class=""><li id="66ba" class="le lf iq ka b kb kc kf kg kj lg kn lh kr li kv lw lk ll lm bi translated">我们通过将<code class="fe ls lt lu lv b">HtmlElements</code>的数据成员设为私有来强制用户使用builder。</li><li id="4d44" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lw lk ll lm bi translated">正如你所看到的，我们已经在同一个文件&amp;中声明了<code class="fe ls lt lu lv b">HtmlBuilder</code> &amp; <code class="fe ls lt lu lv b">HtmlElement</code>这样做，我们需要向前声明，即<code class="fe ls lt lu lv b">class HtmlBuilder;</code>，因为它是一个<a class="ae ld" href="https://docs.microsoft.com/en-us/cpp/c-language/incomplete-types" rel="noopener ugc nofollow" target="_blank">不完整类型</a>。在编译器解析它的实际声明之前，我们不能创建不完整类型的对象。原因很简单，编译器需要一个对象的大小来为它分配内存。因此指针是唯一的方法，所以我们采取了<code class="fe ls lt lu lv b"><a class="ae ld" href="http://www.vishalchovatiya.com/understanding-unique-ptr-with-example-in-cpp11/" rel="noopener ugc nofollow" target="_blank">unique_ptr</a>.</code></li></ul><h1 id="4781" class="lx ly iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">复杂而流畅的构建器设计模式示例</h1><ul class=""><li id="d9e8" class="le lf iq ka b kb mv kf mw kj mx kn my kr mz kv lw lk ll lm bi translated">下面是构建器设计模式的更复杂的例子，它被组织在四个不同的文件中(即<code class="fe ls lt lu lv b">Person.h</code>、<code class="fe ls lt lu lv b">Person.cpp</code>、<code class="fe ls lt lu lv b">PersonBuilder.h</code>、<code class="fe ls lt lu lv b">PersonBuilder.cpp</code>)。</li></ul><p id="cbf2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe ls lt lu lv b"><strong class="ka ir">Person.h</strong></code></p><pre class="na nb nc nd gt ne lv nf ng aw nh bi"><span id="d5c7" class="ni ly iq lv b gy nj nk l nl nm">#pragma once<br/>#include &lt;iostream&gt;<br/>using namespace std;</span><span id="4c77" class="ni ly iq lv b gy nn nk l nl nm">class PersonBuilder;</span><span id="c4f8" class="ni ly iq lv b gy nn nk l nl nm">class Person<br/>{<br/>    std::string m_name, m_street_address, m_post_code, m_city;  // Personal Detail<br/>    std::string m_company_name, m_position, m_annual_income;    // Employment Detail</span><span id="ee5e" class="ni ly iq lv b gy nn nk l nl nm">    Person(std::string name) : m_name(name) {}</span><span id="45e5" class="ni ly iq lv b gy nn nk l nl nm">public:<br/>    friend class PersonBuilder;<br/>    friend ostream&amp; operator&lt;&lt;(ostream&amp;  os, const Person&amp; obj);<br/>    static PersonBuilder create(std::string name);<br/>};</span></pre><p id="40b4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe ls lt lu lv b"><strong class="ka ir">Person.cpp</strong></code></p><pre class="na nb nc nd gt ne lv nf ng aw nh bi"><span id="a6f4" class="ni ly iq lv b gy nj nk l nl nm">#include &lt;iostream&gt;<br/>#include "Person.h"<br/>#include "PersonBuilder.h"</span><span id="350d" class="ni ly iq lv b gy nn nk l nl nm">PersonBuilder Person::create(string name) { return PersonBuilder{name}; }</span><span id="c7ba" class="ni ly iq lv b gy nn nk l nl nm">ostream&amp; operator&lt;&lt;(ostream&amp; os, const Person&amp; obj)<br/>{<br/>    return os &lt;&lt; obj.m_name<br/>              &lt;&lt; std::endl<br/>              &lt;&lt; "lives : " &lt;&lt; std::endl<br/>              &lt;&lt; "at " &lt;&lt; obj.m_street_address<br/>              &lt;&lt; " with postcode " &lt;&lt; obj.m_post_code<br/>              &lt;&lt; " in " &lt;&lt; obj.m_city<br/>              &lt;&lt; std::endl<br/>              &lt;&lt; "works : " &lt;&lt; std::endl<br/>              &lt;&lt; "with " &lt;&lt; obj.m_company_name<br/>              &lt;&lt; " as a " &lt;&lt; obj.m_position<br/>              &lt;&lt; " earning " &lt;&lt; obj.m_annual_income;<br/>}</span></pre><ul class=""><li id="5030" class="le lf iq ka b kb kc kf kg kj lg kn lh kr li kv lw lk ll lm bi translated">从上面的例子可以看出<code class="fe ls lt lu lv b">Person</code>可能有很多类似个人&amp;的专业细节。数据成员的计数也是如此。</li><li id="0794" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lw lk ll lm bi translated">在我们的例子中，有7个数据成员。为通过构造函数创建一个人所需的所有操作创建一个类可能会使我们的类变得臃肿&amp;失去它最初的目的。此外，库用户需要注意所有那些构造函数参数序列。</li></ul><p id="26c2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe ls lt lu lv b"><strong class="ka ir">PersonBuilder.h</strong></code></p><pre class="na nb nc nd gt ne lv nf ng aw nh bi"><span id="79ed" class="ni ly iq lv b gy nj nk l nl nm">#pragma once<br/>#include "Person.h"</span><span id="5c64" class="ni ly iq lv b gy nn nk l nl nm">class PersonBuilder<br/>{<br/>    Person person;</span><span id="49aa" class="ni ly iq lv b gy nn nk l nl nm">public:<br/>    PersonBuilder(string name) : person(name) {}</span><span id="83b2" class="ni ly iq lv b gy nn nk l nl nm">    operator Person() const { return move(person); }</span><span id="bf2a" class="ni ly iq lv b gy nn nk l nl nm">    PersonBuilder&amp;  lives();<br/>    PersonBuilder&amp;  at(std::string street_address);<br/>    PersonBuilder&amp;  with_postcode(std::string post_code);<br/>    PersonBuilder&amp;  in(std::string city);<br/>    PersonBuilder&amp;  works();<br/>    PersonBuilder&amp;  with(string company_name);<br/>    PersonBuilder&amp;  as_a(string position);<br/>    PersonBuilder&amp;  earning(string annual_income);<br/>};</span></pre><p id="9f2b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe ls lt lu lv b"><strong class="ka ir">PersonBuilder.cpp</strong></code></p><pre class="na nb nc nd gt ne lv nf ng aw nh bi"><span id="e162" class="ni ly iq lv b gy nj nk l nl nm">#include "PersonBuilder.h"</span><span id="7e9f" class="ni ly iq lv b gy nn nk l nl nm">PersonBuilder&amp;  PersonBuilder::lives() { return *this; }</span><span id="f0c8" class="ni ly iq lv b gy nn nk l nl nm">PersonBuilder&amp;  PersonBuilder::works() { return *this; }</span><span id="6a9a" class="ni ly iq lv b gy nn nk l nl nm">PersonBuilder&amp;  PersonBuilder::with(string company_name) {<br/>    person.m_company_name = company_name; <br/>    return *this;<br/>}</span><span id="c375" class="ni ly iq lv b gy nn nk l nl nm">PersonBuilder&amp;  PersonBuilder::as_a(string position) {<br/>    person.m_position = position; <br/>    return *this;<br/>}</span><span id="65ea" class="ni ly iq lv b gy nn nk l nl nm">PersonBuilder&amp;  PersonBuilder::earning(string annual_income) {<br/>    person.m_annual_income = annual_income; <br/>    return *this;<br/>}</span><span id="6197" class="ni ly iq lv b gy nn nk l nl nm">PersonBuilder&amp;  PersonBuilder::at(std::string street_address) {<br/>    person.m_street_address = street_address; <br/>    return *this;<br/>}</span><span id="c8c5" class="ni ly iq lv b gy nn nk l nl nm">PersonBuilder&amp;  PersonBuilder::with_postcode(std::string post_code) {<br/>    person.m_post_code = post_code; <br/>    return *this;<br/>}</span><span id="2164" class="ni ly iq lv b gy nn nk l nl nm">PersonBuilder&amp;  PersonBuilder::in(std::string city) {<br/>    person.m_city = city; <br/>    return *this;<br/>}</span></pre><ul class=""><li id="d745" class="le lf iq ka b kb kc kf kg kj lg kn lh kr li kv lw lk ll lm bi translated">我们可以将所有这些与构造相关的API塞进<code class="fe ls lt lu lv b">Person</code>，将任务委托给单独的实体，即<code class="fe ls lt lu lv b">PersonBuilder</code>。</li></ul><p id="c41d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe ls lt lu lv b"><strong class="ka ir">Main.cpp</strong></code></p><pre class="na nb nc nd gt ne lv nf ng aw nh bi"><span id="3bf8" class="ni ly iq lv b gy nj nk l nl nm">#include &lt;iostream&gt;<br/>#include "Person.h"<br/>#include "PersonBuilder.h"<br/>using namespace std;</span><span id="4afc" class="ni ly iq lv b gy nn nk l nl nm">int main()<br/>{<br/>    Person p = Person::create("John")<br/>                                .lives()<br/>                                    .at("123 London Road")<br/>                                    .with_postcode("SW1 1GB")<br/>                                    .in("London")<br/>                                .works()<br/>                                    .with("PragmaSoft")<br/>                                    .as_a("Consultant")<br/>                                    .earning("10e6");</span><span id="6b1f" class="ni ly iq lv b gy nn nk l nl nm">    cout &lt;&lt; p &lt;&lt; endl;<br/>    return EXIT_SUCCESS;<br/>}</span></pre><ul class=""><li id="6547" class="le lf iq ka b kb kc kf kg kj lg kn lh kr li kv lw lk ll lm bi translated">上面的结构看起来不是更直观、自然&amp;简单明了吗？</li><li id="249f" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lw lk ll lm bi translated">如果你关注的是<code class="fe ls lt lu lv b">lives()</code> &amp; <code class="fe ls lt lu lv b">works()</code>这样的空白方法，那么不用担心，它会在优化中被淘汰。</li><li id="89a3" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lw lk ll lm bi translated">你还可以观察到，我们通过将构造函数私有&amp;只暴露<code class="fe ls lt lu lv b">create<strong class="ka ir">(</strong>std::string name<strong class="ka ir">)</strong></code> API，迫使用户使用构建器而不是构造函数。</li><li id="cf8c" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lw lk ll lm bi translated">除非需要，否则不要通过设计接口或抽象类来使事情过于复杂。我在网上的许多构建器设计模式例子中看到过这一点。</li></ul><h1 id="5d72" class="lx ly iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">生成器设计模式的好处</h1><ul class=""><li id="fbf8" class="le lf iq ka b kb mv kf mw kj mx kn my kr mz kv lw lk ll lm bi translated">在构建器模式中，代码行数至少增加了一倍。但是这种努力在设计灵活性、构造函数的参数更少或没有参数以及可读性更高的代码方面得到了回报。</li><li id="57d2" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lw lk ll lm bi translated">构建器设计模式还有助于最小化构造器中的参数数量&amp;因此不需要为构造器的可选参数传递空值。</li><li id="dce6" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lw lk ll lm bi translated">在对象构建过程中，不可变对象的构建不需要太多复杂的逻辑。</li><li id="e41b" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lw lk ll lm bi translated">将构造与<a class="ae ld" href="http://www.vishalchovatiya.com/memory-layout-of-cpp-object/" rel="noopener ugc nofollow" target="_blank">对象表示</a>分离使得对象表示切片&amp;精确。拥有一个独立的构建器实体提供了创建实例化不同对象表示的灵活性。</li></ul><h1 id="59fa" class="lx ly iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">常见问题汇总</h1><p id="4d50" class="pw-post-body-paragraph jy jz iq ka b kb mv kd ke kf mw kh ki kj no kl km kn np kp kq kr nq kt ku kv ij bi translated"><strong class="ka ir">什么时候应该使用构建器设计模式？</strong></p><p id="cf52" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">每当创建新对象时，需要设置许多参数，其中一些(或全部)是可选的。</p><p id="7796" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">为什么我们在实现构建器设计模式时需要一个构建器类？</strong></p><p id="edac" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这不是必须的，但是这样做有一些好处:<br/> -根据<a class="ae ld" href="http://www.vishalchovatiya.com/single-responsibility-principle-in-cpp-solid-as-a-rock/" rel="noopener ugc nofollow" target="_blank"> SRP </a>，构建对象的关注点应该在单独的实体中。<br/> -原物不会臃肿。<br/> -易维护代码&amp;。<br/> -测试&amp;理解一个有许多输入参数的构造函数变得更加复杂。</p><p id="d528" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">建筑设计模式的最大优势！</strong></p><p id="83c3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">更有表现力的代码。<br/><code class="fe ls lt lu lv b">MyClass o = new MyClass(5, 5.5, 'A', var, 1000, obj9, "hello");</code><br/>——改为<br/><code class="fe ls lt lu lv b">MyClass o = MyClass.builder().a(5).b(5.5).c('A').d(var).e(1000).f(obj9).g("hello");</code><br/>——你可以看到哪个数据成员正在被什么&amp;赋值甚至改变赋值的顺序。</p><p id="0393" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae ld" href="http://www.vishalchovatiya.com/contact-2/" rel="noopener ugc nofollow" target="_blank">有什么建议、疑问或者想说</a> <code class="fe ls lt lu lv b"><a class="ae ld" href="http://www.vishalchovatiya.com/contact-2/" rel="noopener ugc nofollow" target="_blank">Hi</a></code> <a class="ae ld" href="http://www.vishalchovatiya.com/contact-2/" rel="noopener ugc nofollow" target="_blank">？减轻压力，只需点击一下鼠标。</a> 🖱️</p></div></div>    
</body>
</html>