<html>
<head>
<title>How to set up a usable distributed sqlite DB using a microk8 multi-architecture cluster</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用microk8多架构集群建立一个可用的分布式sqlite数据库</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-to-setup-a-usable-rqlite-cluster-with-3-node-microk8-multi-architecture-cluster-7c27c1c1edf7?source=collection_archive---------6-----------------------#2022-01-13">https://blog.devgenius.io/how-to-setup-a-usable-rqlite-cluster-with-3-node-microk8-multi-architecture-cluster-7c27c1c1edf7?source=collection_archive---------6-----------------------#2022-01-13</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/6f1b4aee70232de8e4aa79a13b0e140a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OustaqGM34naIRgSOY3Z5w.jpeg"/></div></div></figure><div class=""/><p id="aa07" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我已经建立了一个3节点的microk8集群，两个arm64 (raspberry's)和一个amd64。正如所料，由于大量映像不是为多架构集群构建的，因此发现了许多问题。无论如何，我想这是另一篇未来文章的主题:)</p><p id="3e51" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以我决定使用<a class="ae kt" href="https://github.com/rqlite/rqlite" rel="noopener ugc nofollow" target="_blank"> rqlite </a>作为我的家庭集群中的分布式数据库，来存储我定制的物联网应用程序。我选择rqlite的原因是我基本上想要像sqlite一样轻量级的东西，并且是分布式的(主要是由于可用性，因为我的raspberry pi有时会在运行几天后变得无法访问)。所以rqlite看起来和其他的一样好:)</p><p id="a931" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我发现rqlite的问题是它没有准备好在kubernetes集群中运行。所以像pod调度这样的事情实际上是一个问题。幸运的是，在Philip O'Toole(感谢队友:)的帮助下，他能够拥有正确的机制来克服这一点(你可以在这里跟随讨论<a class="ae kt" href="https://github.com/rqlite/rqlite/issues/818#issuecomment-920446136" rel="noopener ugc nofollow" target="_blank">)。我遇到的第二个问题是当我想使用microk8存储插件时。为此，我需要某种方法在不同节点之间同步我的statefulset文件，这样，如果pod1从node1更改为node2，所有数据在新节点上仍然可用。</a></p><p id="805b" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以我首先为rqlite映像和有状态集配置创建了一个docker配置文件。随后构建了一个存储同步应用程序，作为一个守护程序集运行，它基本上会与所有节点的状态全集(标有<em class="ku">synchronize-nodes</em>标签)卷进行同步。最后，我们需要构建一个能够更新peers.json文件的recover rqlite应用程序，以便在大多数rqlite pods关闭或重新安排时，consensus cluster能够恢复。</p></div><div class="ab cl kv kw hr kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="ig ih ii ij ik"><h1 id="01b4" class="lc ld iy bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">Docker和有状态集配置</h1><p id="52a9" class="pw-post-body-paragraph jv jw iy jx b jy ma ka kb kc mb ke kf kg mc ki kj kk md km kn ko me kq kr ks ig bi translated">虽然这里有一个docker图片<a class="ae kt" href="https://hub.docker.com/r/rqlite/rqlite" rel="noopener ugc nofollow" target="_blank">可用</a>，但它不符合我的要求。基本上是因为所提供的映像不支持多架构(只有amd64 ),并且集群机制不会很好地工作，因为作为领导者或加入者开始是有区别的。</p><p id="71a0" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">总之，我创建的docker文件如下:</p><figure class="mf mg mh mi gt ip"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="4364" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">docker本身没有什么特别的，基本上是从rqlite github获取源代码并构建它。主要区别在于入口点文件:</p><figure class="mf mg mh mi gt ip"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="541c" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">基本上，考虑到我们将作为一个有状态集运行，我们检查它是否是第一个被启动的pod(以0结束),并且没有其他pod运行就绪，然后我们作为领导者启动，否则它作为现有运行pod的加入者启动。</p><p id="23b5" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了构建支持多架构的docker映像，我使用了buildx。所以我们只需要运行:</p><pre class="mf mg mh mi gt ml mm mn mo aw mp bi"><span id="d71c" class="mq ld iy mm b gy mr ms l mt mu">docker buildx build --platform linux/arm64/v8,linux/amd64 --tag  whatever-repo-you-want:and-version --push .</span></pre><p id="cb36" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个映像可以在两种架构上工作。</p><p id="a0e5" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下一步是构建服务和有状态集配置:</p><figure class="mf mg mh mi gt ip"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="2e84" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我想配置是不言自明的，没有任何特别之处。要强调的要点是在volumeClaimTemplates上，我在那里添加了synchronize-nodes:true标签，以便将其标记为需要同步。下一节中描述的存储同步守护进程集将基本上过滤所有包含带有synchronize标签的卷的有状态集，并将这些卷同步到k8集群的所有节点中。</p></div><div class="ab cl kv kw hr kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="ig ih ii ij ik"><h1 id="a82d" class="lc ld iy bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">存储同步守护程序集</h1><p id="5324" class="pw-post-body-paragraph jv jw iy jx b jy ma ka kb kc mb ke kf kg mc ki kj kk md km kn ko me kq kr ks ig bi translated">如上所述，守护程序集的主要目标是将包含标签synchronize-nodes的所有有状态集卷与k8集群的每个节点同步，以便允许有状态集被重新调度到维护其卷中数据的不同节点。</p><p id="8b89" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以我构建了一个存储同步服务，它主要通过轮询k8的API来获取所有的卷声明，包括标签和各自的有界有状态集以及rsync各自的卷。为此，我在指向microk8默认存储主机的守护进程集的每个pod中挂载了一个卷。就我而言:</p><blockquote class="mv mw mx"><p id="8348" class="jv jw ku jx b jy jz ka kb kc kd ke kf my kh ki kj mz kl km kn na kp kq kr ks ig bi translated">/var/snap/micro k8s/common/default-storage/</p></blockquote><p id="c133" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在与绑定到具有同步标签的卷声明的运行状态集相同的k8节点中运行的守护程序集将负责运行rsync命令(在可配置的短时间间隔内),与在其他节点上运行的其他守护程序集一起向它们提供最新的存储副本。代码可以在<a class="ae kt" href="https://github.com/paulosotu/local-storage-sync" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><figure class="mf mg mh mi gt ip"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="e0aa" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">守护进程集的配置也很简单，除了我在下一小节提到的服务帐户。您可能还注意到，需要添加两个证书作为rsync使用的秘密。</p><h2 id="0ed7" class="mq ld iy bd le nb nc dn li nd ne dp lm kg nf ng lq kk nh ni lu ko nj nk ly nl bi translated">设置服务帐户</h2><p id="ff9c" class="pw-post-body-paragraph jv jw iy jx b jy ma ka kb kc mb ke kf kg mc ki kj kk md km kn ko me kq kr ks ig bi translated">有趣的是，为了能够访问不同名称空间上的pod，我们实际上需要为我们的守护程序设置pod设置一个服务帐户。如果我们不这样做，我们的pods将被提供默认的服务帐户，该帐户只能访问我们的默认名称空间上的pods。要查看分配给pod的服务帐户，只需运行以下命令即可:</p><pre class="mf mg mh mi gt ml mm mn mo aw mp bi"><span id="b90a" class="mq ld iy mm b gy mr ms l mt mu">kubectl get pods &lt;POD_NAME&gt; -n &lt;POD_NAMESPACE&gt; -o yaml</span></pre><p id="6136" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后我们会在spec.serviceAccountName下的spec中找到对它的描述。</p><p id="b7e8" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在我们的例子中，因为我们的守护进程集pods运行在kube-system名称空间中，而我们的statefulset pods运行在默认名称空间中，所以我们至少需要添加对这两个名称空间的访问。虽然在我的例子中可以限制为两个名称空间，但我希望这可以在任何名称空间中与statefulsets一起工作(尽管我们可以在这里找到一个很好的教程来说明如何做)。所以我们的yaml看起来应该是这样的:</p><figure class="mf mg mh mi gt ip"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="7a69" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这允许我们的守护程序设置pods来获取/观察/列表pods和持久的音量声明。</p></div><div class="ab cl kv kw hr kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="ig ih ii ij ik"><h1 id="3c54" class="lc ld iy bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">恢复RQLite守护程序集</h1><p id="5a7e" class="pw-post-body-paragraph jv jw iy jx b jy ma ka kb kc mb ke kf kg mc ki kj kk md km kn ko me kq kr ks ig bi translated">恢复rqlite守护程序的目标是在每次重新调度rqlite集群的一个节点并更改其IP时构建peers.json文件。这样，即使大多数节点被重新调度，rqlite也可以恢复。还希望在生成新的peers.json后立即重新启动节点，而不更改它的IP。为此，添加了一个基于文件活性探测器。</p><p id="053c" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以基本上我重用了为存储同步守护进程构建的存储位置服务来获取有状态集和存储位置，以便生成json文件。为了找出是否有任何rqlite节点更改了IP，应用程序主要查看peers.info，如果有任何节点的IP不同于指定的IP，就会生成文件。如上所述，活跃度和就绪性探测由两个不同的文件管理，通过使用rqlite API和/或文件生成来删除或创建这两个文件，以便强制有状态集重启。代码可以在<a class="ae kt" href="https://github.com/paulosotu/rqlite-recover" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><figure class="mf mg mh mi gt ip"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="5f78" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">与中一样，存储同步守护程序的配置非常简单和相似。</p></div><div class="ab cl kv kw hr kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="ig ih ii ij ik"><p id="16da" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个设置已经运行了两个星期了，一切都像预期的那样正常。要有一个轻量级的分布式sqlite还需要一点工作，但这是一个很好的学习途径:)</p><p id="f6d4" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下一步将描述我在同一个microk8集群中的设置或vernemq。</p></div></div>    
</body>
</html>