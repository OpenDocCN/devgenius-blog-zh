<html>
<head>
<title>10 Daily Practice Problems ~ Day 9</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">10 个日常练习题~第 9 天</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/10-daily-practice-problems-day-9-ba8906cbf09e?source=collection_archive---------9-----------------------#2022-10-09">https://blog.devgenius.io/10-daily-practice-problems-day-9-ba8906cbf09e?source=collection_archive---------9-----------------------#2022-10-09</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/dbfa9faabc9ad94f5676bbf2d0a0ce33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*SgTnGLMOofzcLuqq.png"/></div></div></figure><h1 id="404e" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated"><a class="ae kt" href="https://leetcode.com/problems/kth-smallest-element-in-a-bst/" rel="noopener ugc nofollow" target="_blank"> 1。BST 中的第 k 个最小元素</a></h1><p id="1a40" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">给定一个二叉查找树的<code class="fe ls lt lu lv b">root</code>和一个整数<code class="fe ls lt lu lv b">k</code>，返回<em class="lw"/><code class="fe ls lt lu lv b">kth</code><em class="lw">的最小值(</em><strong class="kw io"><em class="lw">1-索引</em> </strong> <em class="lw">)树</em>中所有节点的值。</p><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div class="gh gi lx"><img src="../Images/3f80e07571c57f3b251521c02a42e3bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:424/format:webp/0*-SoBdofvG_Av7xtD.jpg"/></div></figure><pre class="ly lz ma mb gt mc lv md me aw mf bi"><span id="e9a0" class="mg jw in lv b gy mh mi l mj mk"><strong class="lv io">Input:</strong> root = [3,1,4,null,2], k = 1<br/><strong class="lv io">Output:</strong> 1</span></pre><p id="edd8" class="pw-post-body-paragraph ku kv in kw b kx ml kz la lb mm ld le lf mn lh li lj mo ll lm ln mp lp lq lr ig bi translated">解决方案:</p><p id="bd44" class="pw-post-body-paragraph ku kv in kw b kx ml kz la lb mm ld le lf mn lh li lj mo ll lm ln mp lp lq lr ig bi translated">M1</p><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mq"><img src="../Images/e00d2453869688004beb2d106183e906.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BJAAmaUaH6gJk164igaTwg.png"/></div></div></figure><p id="cc80" class="pw-post-body-paragraph ku kv in kw b kx ml kz la lb mm ld le lf mn lh li lj mo ll lm ln mp lp lq lr ig bi translated">货币供应量之二</p><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mr"><img src="../Images/bf9c26812d0121c84a35c47bc1dfe603.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V721GB4FYZMke_XH2au0cw.png"/></div></div></figure><blockquote class="ms mt mu"><p id="eddf" class="ku kv lw kw b kx ml kz la lb mm ld le mv mn lh li mw mo ll lm mx mp lp lq lr ig bi translated">注意:</p><p id="3219" class="ku kv lw kw b kx ml kz la lb mm ld le mv mn lh li mw mo ll lm mx mp lp lq lr ig bi translated"><code class="fe ls lt lu lv b">nonlocal</code>关键字用于处理嵌套函数中的变量，其中变量不应属于内部函数。使用关键字<code class="fe ls lt lu lv b">nonlocal</code>声明该变量不是局部变量。</p><p id="9523" class="ku kv lw kw b kx ml kz la lb mm ld le mv mn lh li mw mo ll lm mx mp lp lq lr ig bi translated"><a class="ae kt" href="https://www.w3schools.com/python/ref_keyword_nonlocal.asp#:~:text=The%20nonlocal%20keyword%20is%20used,the%20variable%20is%20not%20local." rel="noopener ugc nofollow" target="_blank">来源</a></p></blockquote><h1 id="9e20" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated"><a class="ae kt" href="https://practice.geeksforgeeks.org/problems/kth-largest-element-in-bst/1" rel="noopener ugc nofollow" target="_blank"> 2。<strong class="ak">BST 中第 k 个最大元素</strong> </a></h1><p id="1d08" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">给定一个二叉查找树。你的任务是完成返回第 k 个最大元素的函数，而不用在二叉查找树做任何修改。</p><pre class="ly lz ma mb gt mc lv md me aw mf bi"><span id="a7fc" class="mg jw in lv b gy mh mi l mj mk"><strong class="lv io">Input:<br/>      4</strong><br/>    /   \<br/><strong class="lv io">   </strong>2     9<br/>k = 2<strong class="lv io"> <br/>Output: </strong>4</span></pre><p id="f13a" class="pw-post-body-paragraph ku kv in kw b kx ml kz la lb mm ld le lf mn lh li lj mo ll lm ln mp lp lq lr ig bi translated">解决方案:</p><p id="1858" class="pw-post-body-paragraph ku kv in kw b kx ml kz la lb mm ld le lf mn lh li lj mo ll lm ln mp lp lq lr ig bi translated">M1。</p><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mq"><img src="../Images/72dd83c9ebc57b0e277bace5e68fc28c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D1qjIpuwaDpYT2G-oOVZRg.png"/></div></div></figure><p id="c34c" class="pw-post-body-paragraph ku kv in kw b kx ml kz la lb mm ld le lf mn lh li lj mo ll lm ln mp lp lq lr ig bi translated">M2。</p><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mr"><img src="../Images/c27d84c5183cbbb37ae0a790823fd346.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X6uLI1Cm78wAZ-yPX_D8tQ.png"/></div></div></figure><h1 id="7d0e" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated"><a class="ae kt" href="https://leetcode.com/problems/kth-largest-element-in-an-array/" rel="noopener ugc nofollow" target="_blank"> 3。未排序数组中的第 k 个最大元素</a></h1><p id="ba83" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">给定一个整数数组<code class="fe ls lt lu lv b">nums</code>和一个整数<code class="fe ls lt lu lv b">k</code>，返回数组中 <code class="fe ls lt lu lv b">kth</code> <em class="lw">最大的元素<em class="lw">。</em></em></p><p id="3bfb" class="pw-post-body-paragraph ku kv in kw b kx ml kz la lb mm ld le lf mn lh li lj mo ll lm ln mp lp lq lr ig bi translated">请注意，它是排序顺序中最大的<code class="fe ls lt lu lv b">kth</code>元素，而不是<code class="fe ls lt lu lv b">kth</code> distinct 元素。你必须在<code class="fe ls lt lu lv b">O(n)</code>时间复杂度内解决。</p><pre class="ly lz ma mb gt mc lv md me aw mf bi"><span id="3017" class="mg jw in lv b gy mh mi l mj mk"><strong class="lv io">Input:</strong> nums = [3,2,1,5,6,4], k = 2<br/><strong class="lv io">Output:</strong> 5</span></pre><p id="7945" class="pw-post-body-paragraph ku kv in kw b kx ml kz la lb mm ld le lf mn lh li lj mo ll lm ln mp lp lq lr ig bi translated">解决方案:</p><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi my"><img src="../Images/90c2f321db3ec361ea80698c3c0d9b56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Lfcp3nYAr41997j_nVcyPw.png"/></div></div></figure><h1 id="a354" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated"><a class="ae kt" href="https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/" rel="noopener ugc nofollow" target="_blank"> 4。将排序列表转换为二叉查找树</a></h1><p id="0245" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">给定一个单链表的<code class="fe ls lt lu lv b">head</code>，其中元素按照升序<strong class="kw io">排序</strong>，将其转换为高度平衡的 BST。对于这个问题，高度平衡的二叉树被定义为每个节点的<em class="lw">的两个子树的深度相差不超过 1 的二叉树。</em></p><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mz"><img src="../Images/f03417ad9795d7b5b957db6e3a276c3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*fASpywBkfkTOvcdR.jpg"/></div></div></figure><pre class="ly lz ma mb gt mc lv md me aw mf bi"><span id="f0d3" class="mg jw in lv b gy mh mi l mj mk"><strong class="lv io">Input:</strong> head = [-10,-3,0,5,9]<br/><strong class="lv io">Output:</strong> [0,-3,9,-10,null,5]<br/><strong class="lv io">Explanation:</strong> One possible answer is [0,-3,9,-10,null,5], which represents the shown height balanced BST.</span></pre><p id="e5de" class="pw-post-body-paragraph ku kv in kw b kx ml kz la lb mm ld le lf mn lh li lj mo ll lm ln mp lp lq lr ig bi translated">解决方案:</p><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi na"><img src="../Images/ccc56b2e1cfafcc3680accd33be5c3e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mMeush61ARacAmUIKr6chQ.png"/></div></div></figure><h1 id="ebde" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated"><a class="ae kt" href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/" rel="noopener ugc nofollow" target="_blank"> 5。二叉查找树的最低共同祖先</a></h1><p id="8b5f" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">给定一个二叉查找树(BST)，找出 BST 中两个给定节点的最低共同祖先(LCA)节点。根据维基百科上的<a class="ae kt" href="https://en.wikipedia.org/wiki/Lowest_common_ancestor" rel="noopener ugc nofollow" target="_blank">对 LCA 的定义:“最低的共同祖先被定义在两个节点<code class="fe ls lt lu lv b">p</code>和<code class="fe ls lt lu lv b">q</code>之间，作为<code class="fe ls lt lu lv b">T</code>中同时拥有<code class="fe ls lt lu lv b">p</code>和<code class="fe ls lt lu lv b">q</code>作为后代的最低节点(这里我们允许<strong class="kw io">节点是自身</strong>的后代)。”</a></p><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/44800871ea8f181ca44ecd3bf349b6d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/format:webp/0*JrYzYhUbvgfo0qNP.png"/></div></figure><pre class="ly lz ma mb gt mc lv md me aw mf bi"><span id="1893" class="mg jw in lv b gy mh mi l mj mk"><strong class="lv io">Input:</strong> root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8<br/><strong class="lv io">Output:</strong> 6<br/><strong class="lv io">Explanation:</strong> The LCA of nodes 2 and 8 is 6.</span></pre><p id="a956" class="pw-post-body-paragraph ku kv in kw b kx ml kz la lb mm ld le lf mn lh li lj mo ll lm ln mp lp lq lr ig bi translated">解决方案:</p><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nc"><img src="../Images/57b111998bfe9556aa4c3400d63ec72a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A10faxw8HpcQ8t6rRwzC9A.png"/></div></div></figure><h1 id="6183" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated"><a class="ae kt" href="https://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/" rel="noopener ugc nofollow" target="_blank"> 6。从前序遍历构建二叉查找树</a></h1><p id="9827" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">给定一个整数前序数组，表示 BST 的<strong class="kw io">前序遍历</strong>(即<strong class="kw io">二叉查找树</strong>)，构造树并返回<em class="lw">它的根</em>。保证总有可能为给定的测试用例找到具有给定需求的二叉查找树。</p><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/63daaad6759327731e45d0a2aec2bd64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/0*keP8yz32KgnEX2Nq.png"/></div></figure><pre class="ly lz ma mb gt mc lv md me aw mf bi"><span id="bb06" class="mg jw in lv b gy mh mi l mj mk"><strong class="lv io">Input:</strong> preorder = [8,5,1,7,10,12]<br/><strong class="lv io">Output:</strong> [8,5,10,1,7,null,12]</span></pre><p id="82aa" class="pw-post-body-paragraph ku kv in kw b kx ml kz la lb mm ld le lf mn lh li lj mo ll lm ln mp lp lq lr ig bi translated">解决方案:</p><p id="aaf1" class="pw-post-body-paragraph ku kv in kw b kx ml kz la lb mm ld le lf mn lh li lj mo ll lm ln mp lp lq lr ig bi translated">M1。最佳方式</p><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ne"><img src="../Images/4ca3d7103a48b8562fcb68169d877f35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*INjdOFdsV_uUF9BRpGB4Rw.png"/></div></div></figure><p id="8c23" class="pw-post-body-paragraph ku kv in kw b kx ml kz la lb mm ld le lf mn lh li lj mo ll lm ln mp lp lq lr ig bi translated"><strong class="kw io"> <em class="lw">来源:</em></strong><a class="ae kt" href="https://www.youtube.com/watch?v=UmJT3j26t1I" rel="noopener ugc nofollow" target="_blank"><strong class="kw io"><em class="lw">1</em></strong></a><strong class="kw io"><em class="lw">和</em></strong><a class="ae kt" href="https://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/discuss/252232/JavaC%2B%2BPython-O(N)-Solution" rel="noopener ugc nofollow" target="_blank"><strong class="kw io"><em class="lw">2</em></strong></a></p><p id="ba92" class="pw-post-body-paragraph ku kv in kw b kx ml kz la lb mm ld le lf mn lh li lj mo ll lm ln mp lp lq lr ig bi translated">货币供应量之二</p><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ne"><img src="../Images/467756dae19d48788f477f91d16d1f1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CNFEuLXrA3WiwVKzUBK1oA.png"/></div></div></figure><blockquote class="ms mt mu"><p id="b070" class="ku kv lw kw b kx ml kz la lb mm ld le mv mn lh li mw mo ll lm mx mp lp lq lr ig bi translated"><a class="ae kt" href="https://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/discuss/252722/Python-stack-solution-beats-100-on-runtime-and-memory" rel="noopener ugc nofollow" target="_blank">来源:</a></p></blockquote><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nf"><img src="../Images/554d736556ac7b3358bbea5703ace6e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vudbGeRX55aeKzjutRYH1A.png"/></div></div></figure><p id="4004" class="pw-post-body-paragraph ku kv in kw b kx ml kz la lb mm ld le lf mn lh li lj mo ll lm ln mp lp lq lr ig bi translated">M3:</p><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ne"><img src="../Images/5060d60d863ce1fdab2f671312dbb95c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TjtVWjNMi_RrCs96ZBTViA.png"/></div></div></figure><blockquote class="ms mt mu"><p id="d0de" class="ku kv lw kw b kx ml kz la lb mm ld le mv mn lh li mw mo ll lm mx mp lp lq lr ig bi translated"><a class="ae kt" href="https://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/discuss/589389/Python-Concise-Solution" rel="noopener ugc nofollow" target="_blank"> <strong class="kw io"> <em class="in">来源:</em> </strong> </a></p><p id="eb73" class="ku kv lw kw b kx ml kz la lb mm ld le mv mn lh li mw mo ll lm mx mp lp lq lr ig bi translated">弹出列表中的第一个值，并使其成为节点。接下来，将值列表拆分为小于节点左侧的值和大于节点右侧的值。继续下去，直到没有可用的数字。<strong class="kw io">注意</strong>，如果没有大于节点的数字，你必须将<code class="fe ls lt lu lv b">index</code>变量设置为列表的长度。</p></blockquote><h1 id="9e9b" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated"><a class="ae kt" href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node/" rel="noopener ugc nofollow" target="_blank"> 7。在每个节点中填充右下指针</a></h1><p id="b275" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">给你一棵<strong class="kw io">完美的二叉树</strong>，其中所有的叶子都在同一层，每个父母都有两个孩子。二叉树具有以下定义:</p><pre class="ly lz ma mb gt mc lv md me aw mf bi"><span id="b182" class="mg jw in lv b gy mh mi l mj mk">struct Node {<br/>  int val;<br/>  Node *left;<br/>  Node *right;<br/>  Node *next;<br/>}</span></pre><p id="ffc4" class="pw-post-body-paragraph ku kv in kw b kx ml kz la lb mm ld le lf mn lh li lj mo ll lm ln mp lp lq lr ig bi translated">填充每个下一个指针以指向它的下一个右节点。如果没有下一个右节点，下一个指针应该设置为<code class="fe ls lt lu lv b">NULL</code>。</p><p id="de0e" class="pw-post-body-paragraph ku kv in kw b kx ml kz la lb mm ld le lf mn lh li lj mo ll lm ln mp lp lq lr ig bi translated">最初，所有后续指针都被设置为<code class="fe ls lt lu lv b">NULL</code>。</p><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ng"><img src="../Images/5cd74144ae7a00455e2df923b8d0f794.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*eVc9XS6O6-hFbW90.png"/></div></div></figure><pre class="ly lz ma mb gt mc lv md me aw mf bi"><span id="964b" class="mg jw in lv b gy mh mi l mj mk"><strong class="lv io">Input:</strong> root = [1,2,3,4,5,6,7]<br/><strong class="lv io">Output:</strong> [1,#,2,3,#,4,5,6,7,#]<br/><strong class="lv io">Explanation: </strong>Given the above perfect binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with '#' signifying the end of each level.</span></pre><p id="38f4" class="pw-post-body-paragraph ku kv in kw b kx ml kz la lb mm ld le lf mn lh li lj mo ll lm ln mp lp lq lr ig bi translated">解决方案:</p><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ne"><img src="../Images/7ed8116b6f61ace6cef4c7c8f3ecf3c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vICrbGjzQ-Oslps3wcdvAg.png"/></div></div></figure><h1 id="e78b" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated"><a class="ae kt" href="https://leetcode.com/problems/search-in-a-binary-search-tree/" rel="noopener ugc nofollow" target="_blank"> 8。在二叉查找树搜索</a></h1><p id="ea46" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">给你一个二叉查找树(BST)的<code class="fe ls lt lu lv b">root</code>和一个整数<code class="fe ls lt lu lv b">val</code>。</p><p id="b4b8" class="pw-post-body-paragraph ku kv in kw b kx ml kz la lb mm ld le lf mn lh li lj mo ll lm ln mp lp lq lr ig bi translated">在 BST 中找到值等于<code class="fe ls lt lu lv b">val</code>的节点，并返回以该节点为根的子树。如果这样的节点不存在，返回<code class="fe ls lt lu lv b">null</code>。</p><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/d8eee3c2fcd797bcf45f5057e76ed414.png" data-original-src="https://miro.medium.com/v2/resize:fit:844/format:webp/0*3Eg2orKuAgp-OBz9.jpg"/></div></figure><pre class="ly lz ma mb gt mc lv md me aw mf bi"><span id="8fbd" class="mg jw in lv b gy mh mi l mj mk"><strong class="lv io">Input:</strong> root = [4,2,7,1,3], val = 2<br/><strong class="lv io">Output:</strong> [2,1,3]</span></pre><p id="7cc0" class="pw-post-body-paragraph ku kv in kw b kx ml kz la lb mm ld le lf mn lh li lj mo ll lm ln mp lp lq lr ig bi translated">解决方案:</p><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ni"><img src="../Images/e90c29686d1ad75141094dd99f1b7e23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mFtM2QggWfSER_GekNgIRA.png"/></div></div></figure><h1 id="2a44" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated"><a class="ae kt" href="https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/" rel="noopener ugc nofollow" target="_blank"> 9。将排序后的数组转换为二叉查找树</a></h1><p id="7dd6" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">给定一个整数数组<code class="fe ls lt lu lv b">nums</code>，其中的元素按照<strong class="kw io">升序</strong>排序，将<em class="lw">转换成一个</em><strong class="kw io"><em class="lw"/></strong><em class="lw">二叉查找树</em>。</p><p id="57de" class="pw-post-body-paragraph ku kv in kw b kx ml kz la lb mm ld le lf mn lh li lj mo ll lm ln mp lp lq lr ig bi translated">高度平衡的二叉树是这样的二叉树，其中每个节点的两个子树的深度相差不超过 1。</p><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/4a9df8f5a58f6fdc5743b0eb08ef8347.png" data-original-src="https://miro.medium.com/v2/resize:fit:604/format:webp/0*no3PoS7qojqxDj9q.jpg"/></div></figure><pre class="ly lz ma mb gt mc lv md me aw mf bi"><span id="514b" class="mg jw in lv b gy mh mi l mj mk"><strong class="lv io">Input:</strong> nums = [-10,-3,0,5,9]<br/><strong class="lv io">Output:</strong> [0,-3,9,-10,null,5]<br/><strong class="lv io">Explanation:</strong> [0,-10,5,null,-3,null,9] is also accepted:</span></pre><p id="c76f" class="pw-post-body-paragraph ku kv in kw b kx ml kz la lb mm ld le lf mn lh li lj mo ll lm ln mp lp lq lr ig bi translated">解决方案:</p><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ni"><img src="../Images/9c167597739097d11d0528053fea13c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kqv_vTvxwBeGJ8iUMZryOQ.png"/></div></div></figure><h1 id="a487" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">10。验证二叉查找树</h1><p id="d1de" class="pw-post-body-paragraph ku kv in kw b kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">给定二叉树的<code class="fe ls lt lu lv b">root</code>，<em class="lw">确定它是否是有效的二叉查找树(BST) </em>。</p><p id="0787" class="pw-post-body-paragraph ku kv in kw b kx ml kz la lb mm ld le lf mn lh li lj mo ll lm ln mp lp lq lr ig bi translated">一个<strong class="kw io">有效 BST </strong>定义如下:</p><ul class=""><li id="72ee" class="nk nl in kw b kx ml lb mm lf nm lj nn ln no lr np nq nr ns bi translated">节点的左子树只包含键<strong class="kw io">小于节点键</strong>的节点。</li><li id="f069" class="nk nl in kw b kx nt lb nu lf nv lj nw ln nx lr np nq nr ns bi translated">节点的右边子树只包含键<strong class="kw io">大于节点键</strong>的节点。</li><li id="41a7" class="nk nl in kw b kx nt lb nu lf nv lj nw ln nx lr np nq nr ns bi translated">左右子树也必须是二分搜索法树。</li></ul><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/553f67a8c13b1977a05645d1b7a8e3e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:604/format:webp/0*gpnient33D_CcuBL.jpg"/></div></figure><pre class="ly lz ma mb gt mc lv md me aw mf bi"><span id="b3ba" class="mg jw in lv b gy mh mi l mj mk"><strong class="lv io">Input:</strong> root = [2,1,3]<br/><strong class="lv io">Output:</strong> true</span></pre><p id="3824" class="pw-post-body-paragraph ku kv in kw b kx ml kz la lb mm ld le lf mn lh li lj mo ll lm ln mp lp lq lr ig bi translated">解决方案:</p><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ny"><img src="../Images/d1186fbaff778c56810e9fa14935dbea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P3DRraNOUJqrJaVguM57Ug.png"/></div></div></figure></div></div>    
</body>
</html>