<html>
<head>
<title>Concurrent Programming In Golang</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Golang 中的并发编程</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/concurrent-programming-with-golang-2a4edb2552b1?source=collection_archive---------2-----------------------#2022-09-29">https://blog.devgenius.io/concurrent-programming-with-golang-2a4edb2552b1?source=collection_archive---------2-----------------------#2022-09-29</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="31d1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">大家好！在这篇文章中，我将讨论我们需要知道的基本结构，以便在 Go 语言中实现同步，也就是说，在同一时间完成多个任务。首先让我们简单了解一下并发和并行的区别。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2023c6d6a235ddb5380d7ba4f8c30e7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OOCsWxmdJIQEZelF1sp4WA.png"/></div></div></figure><p id="c40c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们通过上面的例子来看看并发性和并行性是如何工作的。我们可以看到，有两个核心和两个任务。在并发方法中，每个内核通过随时间切换来执行两个任务。相比之下，并行方法不在任务之间切换，而是随着时间的推移并行执行它们。</p></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><h1 id="4412" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">戈鲁廷斯</h1><p id="519d" class="pw-post-body-paragraph jk jl in jm b jn lz jp jq jr ma jt ju jv mb jx jy jz mc kb kc kd md kf kg kh ig bi translated">多亏了 goroutines，我们可以在 go 程序中同时完成多项任务。换句话说，goroutine 的概念可以概括为同时完成的每项工作。</p><p id="d077" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">每个 go 程序基本上都有一个主 goroutine，它与 main 函数一起形成。然而，在某些情况下，仅靠主要的 goroutine 可能是不够的。例如，假设我们有<em class="me"> save() </em>和<em class="me"> calculate() </em>函数，它们将花费很长时间。如果这些函数没有自己的 goroutine，它们会使用主 goroutine，并让其他使用相同 goroutine 的进程等待。这种情况会降低程序的运行速度，并产生性能问题。为了防止这种情况，我们可以通过创建它们自己的 goroutines 来并发运行作业。</p><p id="fbde" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">首先，我们借助一个例子来考察问题；</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mf mg l"/></div></figure><pre class="kj kk kl km gt mh mi mj mk aw ml bi"><span id="7de3" class="mm lc in mi b gy mn mo l mp mq">----------------Output----------------:</span><span id="48ff" class="mm lc in mi b gy mr mo l mp mq">Saving... <br/>The record has been saved - It took 5.0018482 <br/>Calculating... <br/>The calculation result:8 - It took 2.0019639 Total time: 7.0038452</span></pre><p id="fc19" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">从上面的输出中可以看出，save 函数在 5 秒钟后开始工作并完成。之后，计算功能开始工作，并在 2 秒内完成。但是我们看一下，calculate 函数等待 save 函数 5 秒，工作 2 秒，所以总共用了 7 秒。</p><p id="ff5d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">go 编程语言使用 go 关键字创建一个 goroutine，并使用 Go 关键字为每个作业创建一个单独的 goroutine。</p><p id="1ed0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们试一试。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mf mg l"/></div></figure><pre class="kj kk kl km gt mh mi mj mk aw ml bi"><span id="74d7" class="mm lc in mi b gy mn mo l mp mq">----------------Output----------------:</span><span id="2854" class="mm lc in mi b gy mr mo l mp mq">Total time: 0</span></pre><p id="dd66" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一个令人惊讶的结果是，总时间为 0。这是因为我们的 go 程序为 save 和 calculate 函数创建了不同的 goroutines，但是没有等待它们完成就直接终止了程序。</p><p id="1d4e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果我们将主函数的执行延迟到其他例程完成之后；</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mf mg l"/></div></figure><pre class="kj kk kl km gt mh mi mj mk aw ml bi"><span id="ce3f" class="mm lc in mi b gy mn mo l mp mq">----------------Output 1----------------:</span><span id="5e0b" class="mm lc in mi b gy mr mo l mp mq">AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA<br/>Saving...<br/>Calculating...<br/>The calculation result:8 - It took 2.0119652<br/>The record has been saved - It took 5.0112932<br/>Total time: 5.0112932</span><span id="e2b0" class="mm lc in mi b gy mr mo l mp mq">----------------Output 2----------------:</span><span id="8c1c" class="mm lc in mi b gy mr mo l mp mq">AAAASaving...<br/>AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA<br/>Calculating...<br/>The calculation result:8 - It took 2.017128<br/>The record has been saved - It took 5.0123579<br/>Total time: 5.0123579</span></pre><p id="5d07" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> <em class="me">在输出 1 中，</em> </strong>首先 printA 功能工作并完成。然后保存和计算功能同时工作。calculate 函数在 2 秒内完成了它的工作，save 函数在 3 秒后完成了它的工作。</p><p id="eb05" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> <em class="me">在输出 2 中，</em> </strong>首先 printA 功能工作，但尚未完成。然后保存功能同时工作。然后 printA 函数完成，calculate 函数开始工作。</p><p id="8cfd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> <em class="me">我们程序的总运行时间等于运行时间最长的 goroutine 的时间。</em>T15】</strong></p><p id="1d46" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果我们仔细检查输出，会发现两个不同的问题。</p><p id="37bd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">产出是不同的，因为我们不知道事情将按什么顺序完成。所以我们无法控制不同程序之间的转换。</p><p id="64c5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们怎么知道哪个过程需要多长时间？我们如何确保工作完成？</p><p id="c602" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">由于上述问题，单独使用 goroutines 是不够的。</p><p id="9f71" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">我将解释解决这些问题所需的等待组和通道的概念。</strong></p></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><h1 id="7505" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">等待组:</h1><p id="9012" class="pw-post-body-paragraph jk jl in jm b jn lz jp jq jr ma jt ju jv mb jx jy jz mc kb kc kd md kf kg kh ig bi translated">它的主要用途是确保一个 goroutine 已经完成了它的工作。等待组有 3 个基本功能，如 Add()、Done()、Wait()</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mf mg l"/></div></figure></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><h1 id="f150" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">频道:</h1><p id="854c" class="pw-post-body-paragraph jk jl in jm b jn lz jp jq jr ma jt ju jv mb jx jy jz mc kb kc kd md kf kg kh ig bi translated">通道是一种结构，我们可以放入任何类型的数据并同时读取这些数据。那么我们为什么要使用它呢？我们用它在两个不同的 goroutines 之间移动数据。同时，<strong class="jm io">通道还保证一个例程发送给另一个例程的值在被使用之前可用</strong>。</p><p id="a1e2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">例如，我们不允许在 goroutine 函数中放置 return 关键字。我们永远不能将程序在主 goroutine 上的进度绑定到另一个 goroutine 的值上。因为我们得到了一个错误，因为使用它可能没有返回值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="392f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">这就是我们使用渠道的原因。我们传递该值，并在另一个 goroutine 中读取该值。</strong></p><pre class="kj kk kl km gt mh mi mj mk aw ml bi"><span id="6d60" class="mm lc in mi b gy mn mo l mp mq">//to write a value into channel</span><span id="7941" class="mm lc in mi b gy mr mo l mp mq">channel &lt;- value</span><span id="3249" class="mm lc in mi b gy mr mo l mp mq">//to read a value from the channel</span><span id="f362" class="mm lc in mi b gy mr mo l mp mq">value &lt;- channel</span></pre><p id="34b1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">用法示例</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="eb47" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">需要注意的是，您只能读取由其他 goroutines 编写的通道中的值。所以你不能同时在一个通道里写和读。因为通道使用锁定机制。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="38d5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">关于这个主题，我其实有很多要说的，但我认为这是一篇足够长的文章。谢谢你给我时间。我希望我是有帮助的。下一篇文章再见:)</p></div></div>    
</body>
</html>