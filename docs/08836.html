<html>
<head>
<title>Why NoSQL Scales better than SQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么 NoSQL 比 SQL 的伸缩性更好</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/why-nosql-scales-better-than-sql-eb0b46b4aac5?source=collection_archive---------0-----------------------#2022-07-14">https://blog.devgenius.io/why-nosql-scales-better-than-sql-eb0b46b4aac5?source=collection_archive---------0-----------------------#2022-07-14</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/ef000fd7b20bf0a27945019660e3f723.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-NkoRHjCQwh_Frua"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">Pawel Czerwinski 在<a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="c788" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为架构做出选择总是最乏味的工作，也是最重要的工作之一。对于应用程序来说，可伸缩性变得越来越重要，因此选择可轻松高效伸缩的数据存储也变得同样重要。</p><p id="f31e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">周围有这么多数据库，选择一个变得相当混乱。这场大辩论是关于<a class="ae jz" href="https://en.wikipedia.org/wiki/SQL" rel="noopener ugc nofollow" target="_blank"> SQL </a> vs <a class="ae jz" href="https://en.wikipedia.org/wiki/NoSQL" rel="noopener ugc nofollow" target="_blank"> NoSQL </a>。NoSQL 以其易扩展性而闻名。</p><p id="2029" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">SQL 数据库已经使用了很长时间。这些成为几十年来任何数据存储需求的事实上的选择。这些都是相当成熟的，经过良好测试的，可靠的，尤其是由于<a class="ae jz" href="https://en.wikipedia.org/wiki/ACID" rel="noopener ugc nofollow" target="_blank">酸</a>的支持。SQL 数据库为我们服务了很长时间。</p><p id="29bf" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为什么 SQL 数据存储的可扩展性不如 NoSQL？我们现在需要“NoSQL”的原因是什么？</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h1 id="dd6f" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">数据在增加</h1><p id="608c" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">越来越多的运营和用户以超乎我们想象的速度加入进来。我们从 GB/TB 的数据曾经是大数据的时代转移到 Twitter 每天处理 PB 数据的时代。这意味着我们需要能够轻松高效地扩展的数据存储。</p><h1 id="60e9" class="lf lg in bd lh li mi lk ll lm mj lo lp lq mk ls lt lu ml lw lx ly mm ma mb mc bi translated">为什么 SQL 不可伸缩？</h1><p id="e684" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">SQL 数据存储无疑是为了通过高效、准确的查询和连接操作来处理 TB 的数据而设计的。但是大得多的数据是个问题。这是由于固有的数据结构和架构假设，这些假设基于 SQL 数据库要服务的用例。</p><p id="66b9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对于任何 SQL 操作，SQL 引擎都需要获取内存中所有需要的数据，以便对其执行 SQL 操作，进行过滤、聚合、连接等。更大的数据意味着内存中更多的数据和更多的 CPU 周期。当数据量超过 TB 时，单台机器几乎不可能高效处理这么多数据。</p><p id="c2cf" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">索引是优化操作的第一道防线。然而，即使应用了索引，B 树仍然需要在内存中加载和操作大量数据来进行搜索和更新。只要数据存储在同一台机器上，由于 CPU 的自然限制，它就有其规模限制。此外，如果多个查询并行运行，会进一步降低性能，因为它会消耗相同的 CPU 能力。</p><p id="9c75" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">下一个挑战是‘Join’操作，这是 SQL 最强大的特性之一。数据以规范化的形式存储，然后通过连接多个表中的数据来获取。这是最强大的功能之一。然而，它也是最慢的之一。Join 需要从内存中的多个表获取数据，然后通过应用 join 逻辑连接这些数据。数据越多，速度就越慢。</p><p id="3f06" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">SQL 世界中应用的解决方案是使用分区方案跨表划分数据。这减少了一个表中的数据量，并使查询变得更简单。但是，这些数据仍然保留在同一台机器上。因此，总体机器容量仍然是一个关键的决定因素。纵向扩展机器有其自身的局限性，或者购买超级强大的服务器非常昂贵。</p><p id="8064" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这就是我们在 SQL 世界中碰壁的方式，并且可以达到扩展的极限。</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h1 id="37e9" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">NoSQL 如何应对这一挑战</h1><p id="0ec0" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">NoSQL 天生就是为大数据(和规模)而设计的。</p><p id="33b6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一个关键的架构假设是数据将分布在多台机器上。由于数据存储在多台机器上，因此即使在功能较弱的机器上处理数据操作也非常高效。</p><blockquote class="mn mo mp"><p id="61a5" class="ka kb mq kc b kd ke kf kg kh ki kj kk mr km kn ko ms kq kr ks mt ku kv kw kx ig bi translated">分片的概念带来了最重要的不同，这是 NoSQL 数据库在设计本身中假定的。<a class="ae jz" href="https://en.wikipedia.org/wiki/Shard_(database_architecture)" rel="noopener ugc nofollow" target="_blank">分片</a>是对一个表(实体)的数据进行水平分区，并根据某个唯一的标识符将它分布在数据存储节点(也包括机器)上，该标识符可以在以后的所有数据操作中帮助识别该节点。</p></blockquote><p id="fba8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">NoSQL 数据库在所有操作中固有地假设分片。对于每个数据操作，数据库都需要一个限定符，它可以标识数据所在的节点。</p><p id="089e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，任何数据操作只命中特定的节点。由于数据分布在各个节点上，每个节点只能处理有限的一组数据，因此非常高效和快速。通过控制机器上的数据量，即使是简单的商用机器也可以用来为整个生态系统增加更多的 CPU 和内存。</p><p id="bbbb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这就解决了 SQL 数据库纠结的同一台机器上的大数据问题。这使得 NoSQL 的商店很容易使用简单的商品机器来扩大规模。</p><figure class="mv mw mx my gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mu"><img src="../Images/e81b8c26311afddeb4ddf3506965102f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yxeIoU3107dGtQzuksoqJQ.jpeg"/></div></div></figure><h2 id="918f" class="mz lg in bd lh na nb dn ll nc nd dp lp kl ne nf lt kp ng nh lx kt ni nj mb nk bi translated">但是，NoSQL 如何解决“加入”带来的缓慢挑战呢</h2><p id="f8cf" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">NoSQL 假设用户会预先计划和组织数据，以便可以从同一个节点一次性获取特定操作所需的所有数据。这也可能意味着跨节点去规范化数据(预先准备好的操作数据)。</p><p id="d853" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">有许多分布式处理概念/框架可以帮助提前有效地处理和预处理数据。</p><p id="61d4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果仍然需要合并来自不止一个源的数据，那么应用程序层总是可以选择进行管理。在大多数情况下，这样的数据是预先计划好的，预先烹制好的。</p><h2 id="e99d" class="mz lg in bd lh na nb dn ll nc nd dp lp kl ne nf lt kp ng nh lx kt ni nj mb nk bi translated">这种方法的好处:</h2><ul class=""><li id="758a" class="nl nm in kc b kd md kh me kl nn kp no kt np kx nq nr ns nt bi translated">数据分布在多台机器上，因此，简单的商用机器也可以有效地增加 CPU 的能力。不需要超级昂贵的机器。没有垂直缩放限制。因此，NoSql 变得高度可伸缩(高效)。</li><li id="41a1" class="nl nm in kc b kd nu kh nv kl nw kp nx kt ny kx nq nr ns nt bi translated">更快地处理任何数据操作，因为机器不需要处理大量数据或多个并行数据操作。</li></ul><p id="fa6e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">缺点是数据不能连接，就像在 SQL 中一样。然而，这是故意的。</p><h2 id="1361" class="mz lg in bd lh na nb dn ll nc nd dp lp kl ne nf lt kp ng nh lx kt ni nj mb nk bi translated">这是否意味着连接根本不可能？</h2><p id="e980" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">这是可能的。例如，MongoDB 聚合、查找操作有助于连接数据。类似地，可以在一个配置单元中提取数据，等等，并执行连接操作。嵌套文档是连接数据的另一种选择。</p><p id="74f4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是，这些操作可能不如 SQL 连接优化，并且成本较高。</p><p id="570a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">联接总是从多个来源检索数据，将这些数据集合在一起，对这些数据执行查找和联合操作，最后返回数据集。</p><p id="228d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让数据存在于同一个节点上为 SQL 引擎提供了使用索引和其他预填充数据结构优化连接策略的优势。它使 SQL 引擎能够拥有多种细化的连接策略。</p><p id="42e5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">而 NoSQL 引擎的优化选项有限，因为数据需要从分布式节点获取，因此可能无法优化超过某个点的连接操作。</p><p id="4fc8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">简而言之，在 NoSQL 连接数据是可能的，但是，不要期望 SQL 类型的特性丰富和优化的连接。了解 NoSQL 生态系统及其优势和局限性，并据此设计数据和应用程序非常重要。</p><p id="46a5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">到目前为止，一切听起来都不错。</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h2 id="c771" class="mz lg in bd lh na nb dn ll nc nd dp lp kl ne nf lt kp ng nh lx kt ni nj mb nk bi translated">但是数据完整性检查、数据一致性呢</h2><p id="db59" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">数据分布在许多节点上。在完成数据操作(事务)之前确保每个节点都用最新数据更新是没有效率的。否则，它会变得非常慢。</p><p id="0bc2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">答案是，NoSQL 在一致性和可用性之间做了权衡(参见<a class="ae jz" href="https://en.wikipedia.org/wiki/CAP_theorem" rel="noopener ugc nofollow" target="_blank"> CAP </a>)。如果数据的高可用性是关键用例，则系统会损害一致性。在这种情况下，应用程序假设在给定的时间点，节点之间可能存在不一致的数据。但是，这将被同步，最终为系统带来一致性。</p><p id="779e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果一致性很重要，许多 NoSQL 系统也提供开关来调整一致性。显然，它伴随着处理时间的高成本和缓慢的性能。系统需要确保在向客户端返回任何数据操作的确认之前，所有节点上的数据都已正确更新。</p><p id="09be" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在 NoSQL 的实际世界中，应用程序假设数据最终将是一致的。因此，相应地设计操作。</p><p id="e865" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这种情况下，如果需要高一致性和 ACID，总是可以选择使用 SQL 数据存储进行这种操作，并在非 SQL 上卸载其余操作。</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><p id="a567" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这也引出了重要的一点。即使 SQL 数据存储在扩展时有一些限制，但它们仍然有自己的空间。当涉及到 ACID 至关重要的系统时，SQL 具有优势。比如银行系统。</p><p id="5ade" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">像任何架构决策一样，一个重要的方面是评估用例并相应地选择正确的数据存储；考虑一致性、性能和扩展需求。</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h1 id="cc66" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">概述</h1><p id="2b95" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">NoSQL 是可扩展的，因为</p><ul class=""><li id="7616" class="nl nm in kc b kd ke kh ki kl nz kp oa kt ob kx nq nr ns nt bi translated">它被设计成跨许多节点/机器分布数据，因此能够有效地利用许多较小机器的 CPU 能力，而不是只依赖于一台超级强大的机器。</li><li id="2fc8" class="nl nm in kc b kd nu kh nv kl nw kp nx kt ny kx nq nr ns nt bi translated">它不允许像 SQL 连接这样的高成本操作，一些 NoSQL 解决方案也限制了每次提取操作的记录数。</li><li id="74c0" class="nl nm in kc b kd nu kh nv kl nw kp nx kt ny kx nq nr ns nt bi translated">它基于最终一致性假设，这使得使用多台机器进行扩展变得可行。</li></ul></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h1 id="1f21" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">参考</h1><p id="8ced" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">这里的是一篇非常好的文章，解释了 DynamoDB 如何伸缩，同时触及了 SQL 和 NoSQL 的区别。</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><p id="88df" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="mq">如果你喜欢读这篇文章，请分享，鼓掌并关注更多的故事。</em></p><p id="bb55" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="mq">如果你有什么建议，随时联系我</em><strong class="kc io"><em class="mq">Linkedin</em></strong><em class="mq">:</em><a class="ae jz" href="https://www.linkedin.com/in/mohitkgupta/" rel="noopener ugc nofollow" target="_blank"><em class="mq">Mohit Gupta</em></a></p></div></div>    
</body>
</html>