<html>
<head>
<title>Implementing Authentication And Authorization using Spring Security, Kotlin and JWT | An easy and straightforward way</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Spring Security、Kotlin 和 JWT 实现身份验证和授权|一种简单明了的方法</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/implementing-authentication-and-authorization-using-spring-security-kotlin-and-jwt-an-easy-and-cc82a1f20567?source=collection_archive---------0-----------------------#2022-12-20">https://blog.devgenius.io/implementing-authentication-and-authorization-using-spring-security-kotlin-and-jwt-an-easy-and-cc82a1f20567?source=collection_archive---------0-----------------------#2022-12-20</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/60b948a904595c873594f7a82215e544.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9YY-kfkvac_rJUNyoYJOHA.png"/></div></div></figure><h1 id="ed6b" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">介绍</h1><p id="ff72" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">自从我进入 Java 和 Spring 世界以来，我一直听说 Spring 安全是多么复杂和难以学习和理解。我个人非常同意那句话:互联网上缺乏现代材料，只有一堆过时和被否决的实现。</p><p id="b276" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">仅有的几次我不得不在我的个人项目上实现 Spring Security，这更像是从我在互联网或课程上找到的源代码中复制和粘贴代码。</p><h1 id="8774" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">让我们来看看代码</h1><p id="06db" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">如果你只需要代码，这是一个我根本不会判断的行为(<em class="lw">我会对同一个</em>)你可以向下滚动到下面，复制并粘贴代码。</p><p id="522b" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">我认为您已经有了一个 spring boot 应用程序，并且可以在没有 auth 的情况下运行</p><h2 id="e634" class="lx jw in bd jx ly lz dn kb ma mb dp kf le mc md kj li me mf kn lm mg mh kr mi bi translated">属国</h2><pre class="mj mk ml mm gt mn mo mp bn mq mr bi"><span id="a5f9" class="ms jw in mo b be mt mu l mv mw">&lt;dependency&gt;<br/>    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br/>    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;<br/>&lt;/dependency&gt;<br/>&lt;dependency&gt;<br/>    &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;<br/>    &lt;artifactId&gt;jjwt&lt;/artifactId&gt;<br/>    &lt;version&gt;0.9.1&lt;/version&gt;<br/>&lt;/dependency&gt;</span></pre><h2 id="e4a6" class="lx jw in bd jx ly lz dn kb ma mb dp kf le mc md kj li me mf kn lm mg mh kr mi bi translated">模型</h2><p id="a3cd" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">首先，创建一个数据类来存储请求凭证，稍后您必须将它映射到一个对象</p><pre class="mj mk ml mm gt mn mo mp bn mq mr bi"><span id="8524" class="ms jw in mo b be mt mu l mv mw">import java.beans.ConstructorProperties<br/><br/>data class LoginDto<br/>@ConstructorProperties("email", "password")<br/>constructor(val email: String, val password: String)</span></pre><p id="3778" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">第二步，创建一个继承<em class="lw"> </em> <strong class="kv io"> <em class="lw">用户详细信息</em> </strong>的类</p><pre class="mj mk ml mm gt mn mo mp bn mq mr bi"><span id="df92" class="ms jw in mo b be mt mu l mv mw">import org.springframework.security.core.GrantedAuthority<br/>import org.springframework.security.core.userdetails.UserDetails<br/><br/>class UserSecurity<br/>    (<br/>    val id: String,<br/>    val email: String,<br/>    private val uPassword: String,<br/>    private val uAuthorities: MutableCollection&lt;GrantedAuthority&gt;<br/>) : UserDetails {<br/>    override fun getAuthorities() = uAuthorities<br/>    override fun getPassword() = uPassword<br/>    override fun getUsername() = email<br/>    override fun isAccountNonExpired() = true<br/>    override fun isAccountNonLocked() = true<br/>    override fun isCredentialsNonExpired()= true<br/>    override fun isEnabled() = true<br/>}</span></pre><h2 id="b9fd" class="lx jw in bd jx ly lz dn kb ma mb dp kf le mc md kj li me mf kn lm mg mh kr mi bi translated">服务</h2><p id="4632" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">创建一个继承自<strong class="kv io"><em class="lw">UserDetailsService</em></strong>的类，并实现其成员</p><pre class="mj mk ml mm gt mn mo mp bn mq mr bi"><span id="8fd0" class="ms jw in mo b be mt mu l mv mw"><br/>import com.ufc.backend.backend.security.model.UserSecurity<br/>import org.springframework.security.core.authority.SimpleGrantedAuthority<br/>import org.springframework.security.core.userdetails.UserDetails<br/>import org.springframework.security.core.userdetails.UserDetailsService<br/>import org.springframework.security.core.userdetails.UsernameNotFoundException<br/>import org.springframework.stereotype.Service<br/>import java.util.*<br/><br/><br/>@Service<br/>class UserDetailsService(<br/>    private val repository: UserRepository<br/>) : UserDetailsService {<br/>    override fun loadUserByUsername(username: String): UserDetails {<br/>       // Create a method in your repo to find a user by its username<br/>        val user = repository.findByPersonEmail(username) ?: throw UsernameNotFoundException("$username not found")<br/>        return UserSecurity(<br/>            user.id,<br/>            user.person.email,<br/>            user.password,<br/>            Collections.singleton(SimpleGrantedAuthority("user"))<br/>        )<br/>    }<br/>}</span></pre><h2 id="c3d7" class="lx jw in bd jx ly lz dn kb ma mb dp kf le mc md kj li me mf kn lm mg mh kr mi bi translated">JWT</h2><p id="d85d" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">让我们开始编写著名的、花哨的样板类:<strong class="kv io"> <em class="lw"> JwtUtils。</em>T15】</strong></p><p id="f5bc" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">你可以在网上找到很多不同的实现，我写了一个我认为最容易理解的实现。</p><pre class="mj mk ml mm gt mn mo mp bn mq mr bi"><span id="267b" class="ms jw in mo b be mt mu l mv mw">import io.jsonwebtoken.Jwts<br/>import io.jsonwebtoken.SignatureAlgorithm<br/>import org.springframework.stereotype.Component<br/>import java.util.*<br/><br/>@Component<br/>class JwtTokenUtil {<br/><br/>    private val secret = "YOUR_SECRET"<br/>    private val expiration = 6000000<br/><br/>    fun generateToken(username: String): String =<br/>        Jwts.builder().setSubject(username).setExpiration(Date(System.currentTimeMillis() + expiration))<br/>            .signWith(SignatureAlgorithm.HS512, secret.toByteArray()).compact()<br/>    <br/>    private fun getClaims(token: String) =<br/>        Jwts.parser().setSigningKey(secret.toByteArray()).parseClaimsJws(token).body<br/><br/>    fun getEmail(token: String): String = getClaims(token).subject<br/><br/>    fun isTokenValid(token: String): Boolean {<br/>        val claims = getClaims(token)<br/>        val expirationDate = claims.expiration<br/>        val now = Date(System.currentTimeMillis())<br/>        return now.before(expirationDate)<br/>    }<br/>}</span></pre><p id="dccb" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">这是很多样板代码。我只根据令牌的到期时间来检查它是否有效，你可能会觉得奇怪和不同，但实际上验证是自动完成的，方法是<strong class="kv io"><em class="lw">get claims(token)</em></strong>，如果令牌是错误的，那么将会抛出一个异常</p><h2 id="73dc" class="lx jw in bd jx ly lz dn kb ma mb dp kf le mc md kj li me mf kn lm mg mh kr mi bi translated">过滤</h2><h2 id="373b" class="lx jw in bd jx ly lz dn kb ma mb dp kf le mc md kj li me mf kn lm mg mh kr mi bi translated">认证过滤器</h2><p id="8222" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">创建一个从 usernamepasswordtauthenticationfilter 继承的类</p><pre class="mj mk ml mm gt mn mo mp bn mq mr bi"><span id="04ca" class="ms jw in mo b be mt mu l mv mw"><br/><br/>import com.fasterxml.jackson.databind.ObjectMapper<br/>import org.springframework.security.authentication.AuthenticationManager<br/>import org.springframework.security.authentication.UsernamePasswordAuthenticationToken<br/>import org.springframework.security.core.Authentication<br/>import org.springframework.security.core.AuthenticationException<br/>import org.springframework.security.core.authority.SimpleGrantedAuthority<br/>import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter<br/>import java.util.*<br/>import javax.servlet.FilterChain<br/>import javax.servlet.http.HttpServletRequest<br/>import javax.servlet.http.HttpServletResponse<br/><br/>class JwtAuthenticationFilter(<br/>    private val jwtTokenUtil: JwtTokenUtil,<br/>    private val authenticationManager: AuthenticationManager<br/>) :<br/>    UsernamePasswordAuthenticationFilter() {<br/><br/>    override fun attemptAuthentication(req: HttpServletRequest, response: HttpServletResponse): Authentication {<br/>        val credentials = ObjectMapper().readValue(req.inputStream, LoginDto::class.java)<br/>        val auth = UsernamePasswordAuthenticationToken(<br/>            credentials.email,<br/>            credentials.password,<br/>            Collections.singleton(SimpleGrantedAuthority("user"))<br/>        )<br/>        return authenticationManager.authenticate(auth)<br/>    }<br/><br/>    override fun successfulAuthentication(<br/>        req: HttpServletRequest?, res: HttpServletResponse, chain: FilterChain?,<br/>        auth: Authentication<br/>    ) {<br/>        val username = (auth.principal as UserSecurity).username<br/>        val token: String = jwtTokenUtil.generateToken(username)<br/>        res.addHeader("Authorization", token)<br/>        res.addHeader("Access-Control-Expose-Headers", "Authorization")<br/>    }<br/><br/>    override fun unsuccessfulAuthentication(<br/>        request: HttpServletRequest,<br/>        response: HttpServletResponse,<br/>        failed: AuthenticationException<br/>    ) {<br/>        val error = BadCredentialsError()<br/>        response.status = error.status<br/>        response.contentType = "application/json"<br/>        response.writer.append(error.toString())<br/>    }<br/><br/>}<br/><br/>private data class BadCredentialsError(<br/>    val timestamp: Long = Date().time,<br/>    val status: Int = 401,<br/>    val message: String = "Email or password incorrect",<br/>) {<br/>    override fun toString(): String {<br/>        return ObjectMapper().writeValueAsString(this)<br/>    }<br/>}</span></pre><p id="fed2" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">这个类的解释非常简短和直接，它负责在您成功登录时生成一个令牌，在您执行错误的凭证时抛出一个异常</p><pre class="mj mk ml mm gt mn mo mp bn mq mr bi"><span id="a84e" class="ms jw in mo b be mt mu l mv mw"><br/>import com.ufc.backend.backend.security.services.UserDetailsService<br/>import org.springframework.http.HttpHeaders.AUTHORIZATION<br/>import org.springframework.security.authentication.AuthenticationManager<br/>import org.springframework.security.authentication.UsernamePasswordAuthenticationToken<br/>import org.springframework.security.core.context.SecurityContextHolder<br/>import org.springframework.security.web.authentication.www.BasicAuthenticationFilter<br/>import java.io.IOException<br/>import javax.servlet.FilterChain<br/>import javax.servlet.ServletException<br/>import javax.servlet.http.HttpServletRequest<br/>import javax.servlet.http.HttpServletResponse<br/><br/>class JwtAuthorizationFilter(<br/>    private val jwtTokenUtil: JwtTokenUtil,<br/>    private val service: UserDetailsService,<br/>    authManager: AuthenticationManager,<br/><br/>    ) : BasicAuthenticationFilter(authManager) {<br/><br/>    @Throws(IOException::class, ServletException::class)<br/>    override fun doFilterInternal(<br/>        req: HttpServletRequest,<br/>        res: HttpServletResponse,<br/>        chain: FilterChain<br/>    ) {<br/>        val header = req.getHeader(AUTHORIZATION)<br/>        if (header == null || !header.startsWith("Bearer ")) {<br/>            chain.doFilter(req, res)<br/>            return<br/>        }<br/>        getAuthentication(header.substring(7))?.also {<br/>            SecurityContextHolder.getContext().authentication = it<br/>        }<br/>        chain.doFilter(req, res)<br/>    }<br/><br/>    private fun getAuthentication(token: String): UsernamePasswordAuthenticationToken? {<br/>        if (!jwtTokenUtil.isTokenValid(token)) return null<br/>        val email = jwtTokenUtil.getEmail(token)<br/>        val user = service.loadUserByUsername(email)<br/>        return UsernamePasswordAuthenticationToken(user, null, user.authorities)<br/>    }<br/>}</span></pre><p id="8b2c" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">该类负责验证令牌并在 SecurityContext 上设置经过身份验证的用户</p><h1 id="3e78" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">配置</h1><p id="56e5" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">我们已经具备了开始配置和告诉 spring 使用我们的方法进行认证和授权所需的一切</p><pre class="mj mk ml mm gt mn mo mp bn mq mr bi"><span id="7f47" class="ms jw in mo b be mt mu l mv mw">import org.springframework.context.annotation.Bean<br/>import org.springframework.context.annotation.Configuration<br/>import org.springframework.security.authentication.AuthenticationManager<br/>import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder<br/>import org.springframework.security.config.annotation.web.builders.HttpSecurity<br/>import org.springframework.security.config.http.SessionCreationPolicy<br/>import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder<br/>import org.springframework.security.web.SecurityFilterChain<br/><br/>@Configuration<br/>open class SecurityConfig(<br/>    private val userDetailsService: UserDetailsService,<br/>) {<br/>    private val jwtToken = JwtTokenUtil()<br/><br/>    private fun authManager(http: HttpSecurity): AuthenticationManager {<br/>        val authenticationManagerBuilder = http.getSharedObject(<br/>            AuthenticationManagerBuilder::class.java<br/>        )<br/>        authenticationManagerBuilder.userDetailsService(userDetailsService)<br/>        return authenticationManagerBuilder.build()<br/>    }<br/><br/>    @Bean<br/>    open fun filterChain(http: HttpSecurity): SecurityFilterChain {<br/>        val authenticationManager = authManager(http)<br/>        // Put your endpoint to create/sign, otherwise spring will secure it as<br/>        // well you won't be able to do any request<br/>        http.authorizeRequests().antMatchers("/users")<br/>            .permitAll().anyRequest().authenticated().and().csrf().disable()<br/>            .authenticationManager(authenticationManager)<br/>            .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS).and()<br/>            .addFilter(JwtAuthenticationFilter(jwtToken, authenticationManager))<br/>            .addFilter(JwtAuthorizationFilter(jwtToken, userDetailsService, authenticationManager))<br/><br/>        return http.build()<br/>    }<br/><br/>    @Bean<br/>    open fun bCryptPasswordEncoder(): BCryptPasswordEncoder {<br/>        return BCryptPasswordEncoder()<br/>    }<br/>}</span></pre><h1 id="e4a0" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">保护密码</h1><p id="d534" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">我保证，这是您的服务中拯救用户的最后一件事:注入以下依赖项</p><pre class="mj mk ml mm gt mn mo mp bn mq mr bi"><span id="117f" class="ms jw in mo b be mt mu l mv mw">@Service<br/>class UserService(<br/>    private val passwordEncoder: BCryptPasswordEncoder<br/>)</span></pre><p id="01fd" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">然后，用你的方法保存你的用户，加密密码</p><pre class="mj mk ml mm gt mn mo mp bn mq mr bi"><span id="bb8b" class="ms jw in mo b be mt mu l mv mw"><br/>user.password = passwordEncoder.encode(user.password)</span></pre></div><div class="ab cl mx my hr mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="ig ih ii ij ik"><h1 id="9700" class="jv jw in bd jx jy ne ka kb kc nf ke kf kg ng ki kj kk nh km kn ko ni kq kr ks bi translated">让我们测试一下</h1><p id="ed6f" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">首先，进入您暴露为不受保护的端点和配置文件，并为您创建一个用户。</p><p id="e989" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">有了这些，拿起电子邮件和密码，让我们在以下端点上执行 POST:</p><pre class="mj mk ml mm gt mn mo mp bn mq mr bi"><span id="0219" class="ms jw in mo b be mt mu l nj mw">POST YOUR_API_URL:YOUR_PORT/login</span></pre><p id="d5fb" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">默认情况下，Spring Security 会为您创建一个/login，所以让我们来试试</p><h1 id="335a" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">证明</h1><h2 id="96d2" class="lx jw in bd jx ly lz dn kb ma mb dp kf le mc md kj li me mf kn lm mg mh kr mi bi translated">错误登录</h2><figure class="mj mk ml mm gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nk"><img src="../Images/91d6c9d6ef064f6eb9d150d541522d8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ps1RtzWY52qH-UFZms8lIA.png"/></div></div></figure><h2 id="bfc8" class="lx jw in bd jx ly lz dn kb ma mb dp kf le mc md kj li me mf kn lm mg mh kr mi bi translated">成功登录</h2><figure class="mj mk ml mm gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nl"><img src="../Images/3219f6c7b703d1274233f11d8317499c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AVDYcUWb7Ye0OrGgXHNvTw.png"/></div></div></figure><p id="50b8" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated"><strong class="kv io"> 200 </strong>如您所见，它在响应上生成了一个令牌，这是我们的 JWT 令牌</p><h1 id="87e3" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">批准</h1><p id="161c" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">让我们尝试运行一个没有令牌的受保护端点:</p><figure class="mj mk ml mm gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nm"><img src="../Images/c2417ae5c7def06caeebe83032c818a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nqWcdWsKH09weBuUr_b4UA.png"/></div></div></figure><p id="30c3" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">它给我们 4003 禁止，基本上说，我们没有登录</p><p id="b6fd" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">现在，令牌在手，让我们再表演一次:</p><figure class="mj mk ml mm gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nn"><img src="../Images/db10208d1b3818a44d162c415297af17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zL9qfc6pmwGhxx4wQqmoZA.png"/></div></div></figure><p id="9835" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">它返回 200，<strong class="kv io">我们通过认证了！</strong></p><h1 id="439b" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">让用户登录您的应用程序</h1><p id="8720" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">我们被记录了，那又怎样？我们要怎么利用这些信息？这很简单，在你的服务器上，或者在你想检索这些信息的任何地方</p><pre class="mj mk ml mm gt mn mo mp bn mq mr bi"><span id="25d8" class="ms jw in mo b be mt mu l mv mw">val userLoggedId = (SecurityContextHolder.getContext().authentication.principal as UserSecurity).id<br/>val userLogged = yourUserService.findById(userLoggedId)</span></pre><h1 id="e5af" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">支持</h1><p id="87d7" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">就是这样的家伙，如果你觉得这很有用，或者它包含一些错误或失误，请随时告诉我。实际上，我可能会在将来发现这篇文章完全错误，我不知道，我们会看到，我这样做是为了帮助社区和帮助自己，无论何时我想使用这个堆栈再次实现 auth。</p><p id="7097" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">我有空，并且洗耳恭听我的<a class="ae no" href="https://www.linkedin.com/in/ren%C3%AA-j%C3%BAnior-55901b198/" rel="noopener ugc nofollow" target="_blank"> Linkedin </a></p></div></div>    
</body>
</html>