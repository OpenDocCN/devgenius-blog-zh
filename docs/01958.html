<html>
<head>
<title>Pointers, Marshalling, and Unmarshalling Data in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Go 中的指针、编组和解组数据</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/pointers-marshalling-and-unmarshalling-data-in-go-34029f1cdc03?source=collection_archive---------9-----------------------#2020-07-15">https://blog.devgenius.io/pointers-marshalling-and-unmarshalling-data-in-go-34029f1cdc03?source=collection_archive---------9-----------------------#2020-07-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/060f34f82a6874f6eea128d9fafccc32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p9VtDOaFcY0WgLOV6QsiVQ.jpeg"/></div></div></figure><p id="ec5b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是我每周系列<em class="kw">学习围棋</em>的第九篇。上周我讲述了如何在 Go  中编写递归函数。本周我将讨论指针、JSON 编组和解组。</p><h1 id="7792" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">两颗北极指极星</h1><p id="ead9" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">虽然我过去听说过<em class="kw">指针</em>，但由于来自 JavaScript，这对我来说是一个全新的领域。尽可能简单地定义一个<em class="kw">指针</em>，一个<em class="kw">指针</em>:</p><blockquote class="mb mc md"><p id="f95a" class="jy jz kw ka b kb kc kd ke kf kg kh ki me kk kl km mf ko kp kq mg ks kt ku kv ij bi translated">“指向”内存中存储值的位置</p></blockquote><p id="3981" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">听起来很有语义，对吧？我有一种感觉，大多数人会从这个词本身推断出这一点；然而，<em class="kw">指针</em>有更多的含义。在我开始在 Go 中使用<em class="kw">指针</em>之前，让我解释一下 Go 中<em class="kw">指针</em>语法的几个重要部分。</p><p id="865c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在 Go 中，使用<em class="kw">指针</em>时需要记住两个运算符:</p><p id="53b5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mh mi mj mk b">&amp;</code>←——该操作符生成该值在内存中的地址(生成一个<em class="kw">指针</em>)</p><p id="cbb9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mh mi mj mk b">*</code>←——该操作符允许您检索<em class="kw">指针</em>的底层值</p><blockquote class="mb mc md"><p id="dc41" class="jy jz kw ka b kb kc kd ke kf kg kh ki me kk kl km mf ko kp kq mg ks kt ku kv ij bi translated">注意:这通常被称为“解引用”</p></blockquote><p id="9a09" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们看一个这两个操作符的例子，我们从<code class="fe mh mi mj mk b">&amp;</code>操作符开始:</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="776b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们已经创建了第一个<em class="kw">指针</em>！</p><p id="fbe2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们一步一步地看看这里发生了什么:</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="1ff9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<code class="fe mh mi mj mk b">func</code> <code class="fe mh mi mj mk b">main</code>内部，我们声明了一个标识符为<code class="fe mh mi mj mk b">name</code>的变量，其值为<code class="fe mh mi mj mk b">martin</code>类型的<code class="fe mh mi mj mk b">string</code></p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="9df0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，使用<code class="fe mh mi mj mk b">fmt</code>包，我们打印出<code class="fe mh mi mj mk b">name</code>的内存值的<em class="kw">地址</em></p><p id="db9d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这将输出以下地址:<code class="fe mh mi mj mk b">0xc000010200</code></p><p id="082f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这可能现在看起来不是非常有用，但是让我向您展示如何使用这个地址来检索一个值:</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="4567" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我一行一行地介绍一下这里发生的事情:</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="e69c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，我们声明一个标识符为<code class="fe mh mi mj mk b">name</code>的新变量，其值为<code class="fe mh mi mj mk b">martin</code>，类型为<code class="fe mh mi mj mk b">string</code></p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="7c4d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我们声明一个标识符为<code class="fe mh mi mj mk b">namePointer</code>的新变量，其值为指向<code class="fe mh mi mj mk b">name</code>变量的<em class="kw">指针</em></p><p id="e258" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我们在下一行打印出<code class="fe mh mi mj mk b">namePointer</code>的值时，我们接收到这个地址<code class="fe mh mi mj mk b">0xc000010200</code></p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="7e6b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我们声明一个标识符为<code class="fe mh mi mj mk b">underlyingValue</code>的新变量，注意我们使用了<code class="fe mh mi mj mk b">*</code>操作符，这允许我们获得一个<em class="kw">指针</em>值的<em class="kw">底层值</em>；因此，<code class="fe mh mi mj mk b">underlyingValue</code>的值就是<code class="fe mh mi mj mk b">namePointer</code>的<em class="kw">基础值</em></p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="08d0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们在下一行打印出<code class="fe mh mi mj mk b">underlyingValue</code>的值，我们看到它的值是<code class="fe mh mi mj mk b">martin</code></p><p id="3c59" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">很酷吧。</p><p id="27fa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kw">指针</em>允许我们在底层存储对数据的引用，它们在内存中的地址。</p><h1 id="1743" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">JSON</h1><p id="bafb" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">JSON ( <em class="kw"> JavaScript 对象符号</em>)是一种广泛使用的格式，用于在各种应用程序中发送和接收数据。在 Go 中，发送 JSON 和接收 JSON 时通常使用两种方法，<code class="fe mh mi mj mk b">Marshal</code>和<code class="fe mh mi mj mk b">Unmarshal</code>。</p><p id="f1f7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">像 Go 生态系统中的大多数东西一样，这些函数的命名非常语义化。我们来看看<code class="fe mh mi mj mk b">Marshal</code>和<code class="fe mh mi mj mk b">Unmarshal</code>的定义。</p><blockquote class="mb mc md"><p id="e412" class="jy jz kw ka b kb kc kd ke kf kg kh ki me kk kl km mf ko kp kq mg ks kt ku kv ij bi translated">编组—将对象的内存表示转换为用于存储或传输的数据格式的过程。当数据必须在应用程序的不同部分之间移动时，通常使用这种方法。</p></blockquote><p id="4a55" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">本质上，当您对数据使用<code class="fe mh mi mj mk b">Marshal</code>函数(通常称为<em class="kw">编组</em>)时，您正在将数据转换为更适合存储或传输到应用程序中其他地方的格式。</p><blockquote class="mb mc md"><p id="7cb7" class="jy jz kw ka b kb kc kd ke kf kg kh ki me kk kl km mf ko kp kq mg ks kt ku kv ij bi translated">解组—将用于存储或传输的对象表示转换为可执行的对象表示的过程</p></blockquote><p id="4bb8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为对 JSON 数据进行<code class="fe mh mi mj mk b">Marshal</code>是一种常见的做法，所以可以使用<code class="fe mh mi mj mk b">Unmarshal</code>函数将这些数据转换成可执行的格式(可以在应用程序中使用的格式)。</p><p id="f901" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可以在这里阅读更多关于编组和解组<a class="ae kx" href="https://en.wikipedia.org/wiki/Marshalling_(computer_science)" rel="noopener ugc nofollow" target="_blank">的内容。</a></p><p id="a9f0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我给你看几个使用<code class="fe mh mi mj mk b">Marshal</code>和<code class="fe mh mi mj mk b">Unmarshal</code>的例子。</p><p id="b252" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mh mi mj mk b">Marshal</code></p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="5b5c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我带你看看这里发生了什么:</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="3392" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<code class="fe mh mi mj mk b">package</code> <code class="fe mh mi mj mk b">main</code>中，我们现在正在导入<code class="fe mh mi mj mk b">encoding/json</code>包，这允许我们使用<code class="fe mh mi mj mk b">json</code>包</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="7a4f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我们用类型<code class="fe mh mi mj mk b">struct</code>的标识符<code class="fe mh mi mj mk b">person</code>创建自己的类型</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="52c3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们给我们的<code class="fe mh mi mj mk b">person</code>类型三个字段:<code class="fe mh mi mj mk b">string</code>类型的<code class="fe mh mi mj mk b">First</code>、<code class="fe mh mi mj mk b">String</code>类型的<code class="fe mh mi mj mk b">Last</code>和<code class="fe mh mi mj mk b">int</code>类型的<code class="fe mh mi mj mk b">Age</code></p><p id="962a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们的<code class="fe mh mi mj mk b">func</code> <code class="fe mh mi mj mk b">main</code>中，使用短声明操作符，我们用标识符<code class="fe mh mi mj mk b">me</code>创建了一个新变量</p><p id="e979" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了给<code class="fe mh mi mj mk b">me</code>赋值，我们使用了一个<code class="fe mh mi mj mk b">person</code>类型的<em class="kw">复合文字</em></p><p id="a76a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们的<em class="kw">复合文本中，</em>我们为<code class="fe mh mi mj mk b">person</code><code class="fe mh mi mj mk b">type</code>:<code class="fe mh mi mj mk b">First</code>-&gt;-<code class="fe mh mi mj mk b">martin</code>、<code class="fe mh mi mj mk b">Last</code>-&gt;-<code class="fe mh mi mj mk b">cartledge</code>和<code class="fe mh mi mj mk b">Age</code>-&gt;-<code class="fe mh mi mj mk b">29</code>中的每个字段赋值</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="377b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我们使用标识符为<code class="fe mh mi mj mk b">bff</code>的短声明操作符创建另一个变量</p><p id="0698" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mh mi mj mk b">bff</code>的值也属于<code class="fe mh mi mj mk b">person</code>类型</p><p id="87c4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个<em class="kw">复合文字</em>中，为我们的<code class="fe mh mi mj mk b">person</code>类型的每个字段分配的值是:<code class="fe mh mi mj mk b">First</code> - &gt; <code class="fe mh mi mj mk b">mikel</code>、<code class="fe mh mi mj mk b">Last</code> - &gt; <code class="fe mh mi mj mk b">howarth</code>和<code class="fe mh mi mj mk b">Age</code> - &gt; <code class="fe mh mi mj mk b">29</code></p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="ab36" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我们使用标识符为<code class="fe mh mi mj mk b">friends</code>的短声明操作符创建一个新变量</p><p id="6df0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mh mi mj mk b">friends</code>的值将是<code class="fe mh mi mj mk b">person</code>类型的<code class="fe mh mi mj mk b">slice</code>，我们将<code class="fe mh mi mj mk b">me</code>和<code class="fe mh mi mj mk b">bff</code>的值传递给我们的<em class="kw">复合文字</em></p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="a818" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用<code class="fe mh mi mj mk b">fmt</code>包，我们打印<code class="fe mh mi mj mk b">friends</code>的值</p><blockquote class="mb mc md"><p id="ab29" class="jy jz kw ka b kb kc kd ke kf kg kh ki me kk kl km mf ko kp kq mg ks kt ku kv ij bi translated">快速提示:调用<code class="fe mh mi mj mk b">json.Marshal</code>时有两个返回值:<br/> <br/> 1)一个结果<br/> <br/> 2)一个错误<br/> <br/> <strong class="ka ir">结果</strong>是一个<code class="fe mh mi mj mk b">byte</code> ( <code class="fe mh mi mj mk b">[]byte</code> ) <br/> <br/> <strong class="ka ir">类型的<code class="fe mh mi mj mk b">slice</code>错误</strong>是一个<code class="fe mh mi mj mk b">error</code></p></blockquote><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="b1a6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于这个例子，我给<em class="kw">结果</em>标识符<code class="fe mh mi mj mk b">res</code>，给<em class="kw">错误</em>标识符<code class="fe mh mi mj mk b">err</code></p><p id="a37c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我将<code class="fe mh mi mj mk b">friends</code>作为单个参数传递给<code class="fe mh mi mj mk b">json.Marshal()</code>，记住<code class="fe mh mi mj mk b">friends</code>是类型<code class="fe mh mi mj mk b">person</code>的<code class="fe mh mi mj mk b">slice</code></p><blockquote class="mb mc md"><p id="f399" class="jy jz kw ka b kb kc kd ke kf kg kh ki me kk kl km mf ko kp kq mg ks kt ku kv ij bi translated">快速注意:在使用封送或取消封送后立即检查错误被认为是最佳实践，这可以防止数据中的任何错误或不一致渗透到代码中</p></blockquote><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="2d45" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我们检查<code class="fe mh mi mj mk b">err</code> <em class="kw">的值是否不是</em> <code class="fe mh mi mj mk b">nil</code>，如果这个值等于<code class="fe mh mi mj mk b">true</code>，我们就进入这个 if 语句并运行我们的错误处理代码</p><p id="a331" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于这个例子，我们没有错误，所以我们的代码继续执行</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="18ce" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mh mi mj mk b">func</code> <code class="fe mh mi mj mk b">main</code>中的最后一行使用了<code class="fe mh mi mj mk b">fmt</code>包并记录了<code class="fe mh mi mj mk b">res</code>的值，这是我们新整理的数据</p><p id="c895" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就是<code class="fe mh mi mj mk b">res</code>后整理的价值:</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="0367" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如你所见，我们有一个<code class="fe mh mi mj mk b">byte</code>类型的<code class="fe mh mi mj mk b">slice</code>值，非常酷！</p><p id="162f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mh mi mj mk b">Unmarshal</code></p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="b99d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我带你看看这里发生了什么:</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="9fe4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你会注意到我们正在导入<code class="fe mh mi mj mk b">encoding/json</code>包，就像我们在前面的例子中做的一样，我们需要<code class="fe mh mi mj mk b">json</code>包来使用<code class="fe mh mi mj mk b">Marshal</code>和<code class="fe mh mi mj mk b">Unmarshal</code></p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="8ef8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们还创建了一个新的带有标识符<code class="fe mh mi mj mk b">person</code>的定制类型，它有三个字段:<code class="fe mh mi mj mk b">string</code>类型的<code class="fe mh mi mj mk b">First</code>、<code class="fe mh mi mj mk b">string</code>类型的<code class="fe mh mi mj mk b">Last</code>和<code class="fe mh mi mj mk b">int</code>类型的<code class="fe mh mi mj mk b">Age</code></p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="5013" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用短声明操作符，我创建了一个标识符为<code class="fe mh mi mj mk b">rawData</code>的新变量，并将其赋给 JSON 字符串中表示的<code class="fe mh mi mj mk b">person</code>值的<code class="fe mh mi mj mk b">slice</code></p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="2e0d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在下一行，使用<code class="fe mh mi mj mk b">fmt</code>包，我们打印出<code class="fe mh mi mj mk b">rawData</code>的值</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="43a4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，使用短声明操作符，我们用标识符<code class="fe mh mi mj mk b">byteString</code>声明一个新变量，知道我们下一步要做什么吗？</p><p id="27cf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">没错，我们将<code class="fe mh mi mj mk b">byteString</code>的值设置为<code class="fe mh mi mj mk b">byte</code>类型值的<code class="fe mh mi mj mk b">slice</code>。一旦我们将<code class="fe mh mi mj mk b">rawData</code>值传递到我们的<em class="kw">复合文字</em>中，这一行就完成了</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="5654" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用<code class="fe mh mi mj mk b">fmt</code>包，我们打印出<code class="fe mh mi mj mk b">byteString</code>的值</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="1939" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用<code class="fe mh mi mj mk b">var</code>关键字，我们创建一个标识符为<code class="fe mh mi mj mk b">people</code>的新变量，它将是类型<code class="fe mh mi mj mk b">person</code>(我们创建的自定义类型)的值的<code class="fe mh mi mj mk b">slice</code></p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="6ca5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就是有趣的地方。注意我们只分配了一个返回值。这是因为<code class="fe mh mi mj mk b">json.Unmarshal()</code>有两个参数，您希望<em class="kw">解组</em>或<em class="kw">解码</em>的<em class="kw">值，以及您希望将<em class="kw">解组的</em>数据分配给的变量的<em class="kw">指针</em>(内存中的地址)。</em></p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="68fa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">按照惯例，接下来，我们立即检查错误，如果我们有一个错误，我们打印出来</p><blockquote class="mb mc md"><p id="a9b1" class="jy jz kw ka b kb kc kd ke kf kg kh ki me kk kl km mf ko kp kq mg ks kt ku kv ij bi translated">注意:根据您的应用程序和您在解组后采取的操作，您可能希望停止所有的执行。我将在以后的帖子中谈到这一点</p></blockquote><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="963e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用<code class="fe mh mi mj mk b">fmt</code>包，我们打印出<code class="fe mh mi mj mk b">people</code>的值。看那个！我们的数据和我们开始时一样，非常酷。</p><p id="797a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了最大限度地使用我们的自定义类型<code class="fe mh mi mj mk b">person</code>，我想迭代我们新的<em class="kw">解组的</em>数据并打印出它们的值</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="e0be" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面，我们使用了<code class="fe mh mi mj mk b">for</code>关键字来创建一个<code class="fe mh mi mj mk b">for</code>语句</p><p id="2887" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个<code class="fe mh mi mj mk b">for</code>循环将为每次迭代返回两个值，一个<code class="fe mh mi mj mk b">index</code>和一个<code class="fe mh mi mj mk b">value</code>，我们将这些值分别赋给变量<code class="fe mh mi mj mk b">i</code>和<code class="fe mh mi mj mk b">v</code></p><p id="ccf0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<code class="fe mh mi mj mk b">for</code>循环内部，使用<code class="fe mh mi mj mk b">fmt</code>包，我们打印出<code class="fe mh mi mj mk b">i</code> ( <code class="fe mh mi mj mk b">index</code>)的值，在下一行我们打印出<code class="fe mh mi mj mk b">person</code>类型中每个字段的值:<code class="fe mh mi mj mk b">First</code>、<code class="fe mh mi mj mk b">Last</code>和<code class="fe mh mi mj mk b">Age</code></p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="f8c3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">以上是我们的结果，很酷吧？</p><h1 id="8467" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">概括起来</h1><p id="0830" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">Go 使得创建和读取内存地址(<code class="fe mh mi mj mk b">Pointers</code>)、编码数据(<code class="fe mh mi mj mk b">json.Marshal</code>)和解码数据(<code class="fe mh mi mj mk b">json.Unmarshal</code>)变得轻而易举。借助 Go 编程语言的这些特性，在整个应用程序中传递数据变得更加容易和高效。我希望您喜欢学习这些特性，如果您已经熟悉它们，我希望您离开时能够学到一些新的东西。下周我将讨论在 Go 中对数据进行排序。再见，感谢您的阅读！</p></div></div>    
</body>
</html>