<html>
<head>
<title>Best solutions for Microsoft interview tasks. Concatenated String Length with unique Characters.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">微软面试任务的最佳解决方案。具有唯一字符的串联字符串长度。</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/best-solutions-for-microsoft-interview-tasks-concatenated-string-length-with-unique-characters-bc1f4c5726c3?source=collection_archive---------5-----------------------#2020-07-05">https://blog.devgenius.io/best-solutions-for-microsoft-interview-tasks-concatenated-string-length-with-unique-characters-bc1f4c5726c3?source=collection_archive---------5-----------------------#2020-07-05</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div class="gh gi il"><img src="../Images/bf5875794727fcdf7e3f0a290ac4769d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UVek2pjvzHTm_I7dq-HRCA.jpeg"/></div></figure><div class=""/><h1 id="cfa9" class="jr js iu bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">描述:</h1><ul class=""><li id="f843" class="kp kq iu kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated"><a class="ae lh" href="https://leetcode.com/problems/maximum-length-of-a-concatenated-string-with-unique-characters/" rel="noopener ugc nofollow" target="_blank">https://leet code . com/problems/maximum-length-of-a-concatenated-string-with-unique-characters/</a></li></ul><h1 id="f536" class="jr js iu bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">解决方案:</h1><p id="7b8e" class="pw-post-body-paragraph li lj iu kr b ks kt lk ll ku kv lm ln kw lo lp lq ky lr ls lt la lu lv lw lc ig bi translated">我们有一组给定的字符串。我们必须找到这些字符串的所有可能的组合。我们有一个限制—我们不能组合具有相同字母的字符串，换句话说，我们只能组合具有唯一字母的字符串。很容易看出，如果两个字符串有相同的字母，我们需要发明一些快速检查的方法。很容易看出，任何结果字符串的长度都不能超过字母表的长度，在我们的例子中是26个字母。</p><p id="8997" class="pw-post-body-paragraph li lj iu kr b ks lx lk ll ku ly lm ln kw lz lp lq ky ma ls lt la mb lv lw lc ig bi translated">我们可以制作一个映射，其中给定的字符串将是值，每个字符串将有一个排序的字母数组，该数组在该字符串中用作键。</p><p id="faa4" class="pw-post-body-paragraph li lj iu kr b ks lx lk ll ku ly lm ln kw lz lp lq ky ma ls lt la mb lv lw lc ig bi translated">例如，字符串“coco”、“dodo”、“interactive”的数组将具有如下映射外观:</p><figure class="md me mf mg gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi mc"><img src="../Images/7a0ee3406a072ea14f25cf4102e8ab01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gT6aHcmPqlX81lGz"/></div></div></figure><p id="c35f" class="pw-post-body-paragraph li lj iu kr b ks lx lk ll ku ly lm ln kw lz lp lq ky ma ls lt la mb lv lw lc ig bi translated">比较排序后的字母并找出两个字符串中是否有共同的字母是很容易的。</p><p id="cbbe" class="pw-post-body-paragraph li lj iu kr b ks lx lk ll ku ly lm ln kw lz lp lq ky ma ls lt la mb lv lw lc ig bi translated">但是也许有一种方法可以加速这种比较？</p><p id="4b94" class="pw-post-body-paragraph li lj iu kr b ks lx lk ll ku ly lm ln kw lz lp lq ky ma ls lt la mb lv lw lc ig bi translated">如果每个字母在结果字符串中只能出现一次，则最大结果字符串是字母表，长度为26个字母。我们可以将字母表反映到位集中。如果字符串中出现一个字母，则相应的位被设置为1。</p><p id="5403" class="pw-post-body-paragraph li lj iu kr b ks lx lk ll ku ly lm ln kw lz lp lq ky ma ls lt la mb lv lw lc ig bi translated">单词“interactive”作为一个比特集将看起来像这样:</p><figure class="md me mf mg gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi ml"><img src="../Images/874cd76a82af40ca8ee18fe6695d78e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-1J8cegPAxd_Gg5K"/></div></div></figure><p id="dc3c" class="pw-post-body-paragraph li lj iu kr b ks lx lk ll ku ly lm ln kw lz lp lq ky ma ls lt la mb lv lw lc ig bi translated">26位小于CPU的一个寄存器，所以在理想情况下，我们可以在一个CPU命令中比较两个位集。没有比这更快的了。</p><p id="2c12" class="pw-post-body-paragraph li lj iu kr b ks lx lk ll ku ly lm ln kw lz lp lq ky ma ls lt la mb lv lw lc ig bi translated">因此最终的算法应该是这样的:</p><ol class=""><li id="cd7a" class="kp kq iu kr b ks lx ku ly kw mm ky mn la mo lc mp le lf lg bi translated">迭代输入字符串，跳过有重复字符的字符串。</li><li id="da40" class="kp kq iu kr b ks mq ku mr kw ms ky mt la mu lc mp le lf lg bi translated">对于每个具有唯一字符的字符串，检查它是否与结果字符串具有相同的字符。</li><li id="7202" class="kp kq iu kr b ks mq ku mr kw ms ky mt la mu lc mp le lf lg bi translated">如果它们有交叉字符，我们跳过它。</li><li id="5d6d" class="kp kq iu kr b ks mq ku mr kw ms ky mt la mu lc mp le lf lg bi translated">如果没有，我们将这个新的组合追加到结果中。</li><li id="fb6e" class="kp kq iu kr b ks mq ku mr kw ms ky mt la mu lc mp le lf lg bi translated">返回结果字符串的长度。</li></ol><p id="4a85" class="pw-post-body-paragraph li lj iu kr b ks lx lk ll ku ly lm ln kw lz lp lq ky ma ls lt la mb lv lw lc ig bi translated">我们不应该直接处理琴弦。我们可以将它们转换成位集，并且只处理这些位。它大大减少了内存消耗，提高了程序的速度。</p><p id="b446" class="pw-post-body-paragraph li lj iu kr b ks lx lk ll ku ly lm ln kw lz lp lq ky ma ls lt la mb lv lw lc ig bi translated">C++代码:</p><pre class="md me mf mg gt mv mw mx my aw mz bi"><span id="5032" class="na js iu mw b gy nb nc l nd ne">int solution(const vector&lt;string&gt;&amp; v) {</span><span id="b770" class="na js iu mw b gy nf nc l nd ne">    // We will keep in this vector bitmaps of used letters <br/>    // for the processed strings.<br/>    // Add one empty bitset for comparison with the first <br/>    // processed string. It makes the algorithm a bit shorter<br/>    vector&lt;bitset&lt;26&gt;&gt; char_bits_vector = {bitset&lt;26&gt;()};<br/>    int result = 0;</span><span id="1b2e" class="na js iu mw b gy nf nc l nd ne">    // for each string in the vector make a bitset where all <br/>    // bits corresponding to characters in alphabet are set.<br/>    for (auto&amp; str : v) {<br/>        bitset&lt;26&gt; char_bits;</span><span id="5cda" class="na js iu mw b gy nf nc l nd ne">        // set bits corresponding to chars in the string.<br/>        for (char c : str) { char_bits.set(c - 'a'); }</span><span id="bee6" class="na js iu mw b gy nf nc l nd ne">        // How many bits were set.<br/>        int bit_num = char_bits.count();</span><span id="913c" class="na js iu mw b gy nf nc l nd ne">        // the string contains duplicate characters so <br/>        // don't process it<br/>        if (bit_num &lt; str.size()) continue; </span><span id="7df1" class="na js iu mw b gy nf nc l nd ne">        // Check if current word has common letters with <br/>        // already processed strings<br/>        for (int i = char_bits_vector.size() - 1; i &gt;= 0; --i) {<br/>            auto&amp; c_b = char_bits_vector[i];</span><span id="8a9a" class="na js iu mw b gy nf nc l nd ne">            // if two bitsets have common 1 bits i.e. <br/>            // if two strings have common letters don't <br/>            // process current string<br/>            if ((c_b &amp; char_bits).any()) continue;</span><span id="b6a7" class="na js iu mw b gy nf nc l nd ne">            // if current string has unique letters add <br/>            // to the vector a bitset where <br/>            // all bits corresponding to letters of the current <br/>            // string are set to 1.<br/>            char_bits_vector.push_back(c_b | char_bits);</span><span id="05e1" class="na js iu mw b gy nf nc l nd ne">            // add length of the current string to the result<br/>            result = max&lt;int&gt;(result, c_b.count() + bit_num); <br/>        }<br/>    }<br/>    return result;<br/>}</span></pre><p id="3e36" class="pw-post-body-paragraph li lj iu kr b ks lx lk ll ku ly lm ln kw lz lp lq ky ma ls lt la mb lv lw lc ig bi translated">你可以在这里找到包含完整项目的资源库:<a class="ae lh" href="https://github.com/jolly-fellow/microsoft/tree/master/concatenated_string_length_with_unique_characters" rel="noopener ugc nofollow" target="_blank">https://github . com/jolly-fellow/Microsoft/tree/master/concatenated _ string _ length _ with _ unique _ characters</a></p><p id="7d26" class="pw-post-body-paragraph li lj iu kr b ks lx lk ll ku ly lm ln kw lz lp lq ky ma ls lt la mb lv lw lc ig bi translated">返回到<a class="ae lh" href="https://medium.com/@molchevsky/best-solutions-for-microsoft-interview-tasks-cae6b0f3ff86" rel="noopener">目录。</a></p></div></div>    
</body>
</html>