<html>
<head>
<title>Python — Read File Contents</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 读取文件内容</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/python-read-file-contents-567fbcd64532?source=collection_archive---------2-----------------------#2022-09-20">https://blog.devgenius.io/python-read-file-contents-567fbcd64532?source=collection_archive---------2-----------------------#2022-09-20</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><div class=""><h2 id="b5a1" class="pw-subtitle-paragraph jo iq ir bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated">如何在 Python 中读取普通和大文件</h2></div><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj kg"><img src="../Images/cbf54496e2c448d6bd9c8f8e6c3b94d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WqI2_fhPCCLtGRtG0frFMQ.png"/></div></div></figure><p id="a462" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">在日常 Python 开发工作中，最常见的任务之一可能是读取文件。当您打开文件进行阅读时，有三个常用的功能:</p><ul class=""><li id="9b68" class="lo lp ir ku b kv kw ky kz lb lq lf lr lj ls ln lt lu lv lw bi translated"><code class="fe lx ly lz ma b">read()</code>:一次性读取文本的全部内容，并以字符串形式返回结果</li><li id="25bf" class="lo lp ir ku b kv mb ky mc lb md lf me lj mf ln lt lu lv lw bi translated"><code class="fe lx ly lz ma b">readline()</code>:只读取一行文本，并以字符串形式返回结果</li><li id="0976" class="lo lp ir ku b kv mb ky mc lb md lf me lj mf ln lt lu lv lw bi translated"><code class="fe lx ly lz ma b">readlines()</code>:读取文本的所有内容，并以一个<code class="fe lx ly lz ma b">list</code>的格式返回结果</li></ul><p id="255d" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">例如，假设我们有一个文本文件，包含:</p><pre class="kh ki kj kk gu mg ma mh mi aw mj bi"><span id="d3df" class="mk ml ir ma b gz mm mn l mo mp">yellow<br/>pink<br/>black</span></pre><p id="f32a" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">以上三个函数的行为看起来会像</p><h2 id="24b8" class="mk ml ir bd mq mr ms dn mt mu mv dp mw lb mx my mz lf na nb nc lj nd ne nf ng bi translated">阅读()</h2><pre class="kh ki kj kk gu mg ma mh mi aw mj bi"><span id="299d" class="mk ml ir ma b gz mm mn l mo mp">with open("test.txt", "r") as f_in:<br/>    data = f_in.read()<br/>print(data)</span><span id="b538" class="mk ml ir ma b gz nh mn l mo mp"># Output:<br/>yellow<br/>pink<br/>black</span></pre><h2 id="a9d7" class="mk ml ir bd mq mr ms dn mt mu mv dp mw lb mx my mz lf na nb nc lj nd ne nf ng bi translated">读取线()</h2><pre class="kh ki kj kk gu mg ma mh mi aw mj bi"><span id="ec72" class="mk ml ir ma b gz mm mn l mo mp">with open("test.txt", "r") as f_in:<br/>    data = f_in.readline()<br/>print(data)</span><span id="594b" class="mk ml ir ma b gz nh mn l mo mp"># Output:<br/>yellow</span></pre><h2 id="fb78" class="mk ml ir bd mq mr ms dn mt mu mv dp mw lb mx my mz lf na nb nc lj nd ne nf ng bi translated">读取行()</h2><pre class="kh ki kj kk gu mg ma mh mi aw mj bi"><span id="1248" class="mk ml ir ma b gz mm mn l mo mp">with open("test.txt", "r") as f_in:<br/>    data = f_in.readlines()<br/>print(data)</span><span id="0893" class="mk ml ir ma b gz nh mn l mo mp"># Output:<br/>['yellow\n', 'pink\n', 'black\n']</span></pre><p id="394a" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">我很确定你已经使用了上面所有的函数，但是你有没有想过 Python 文件读取背后的原理？什么时候使用<code class="fe lx ly lz ma b">read()</code>功能最好，什么时候使用<code class="fe lx ly lz ma b">readlines()</code>最好？如果你有<strong class="ku is"> 1TB </strong>大小的文件，还能用这些函数读取吗？你会遇到什么问题吗？</p><p id="b63a" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">在我们深入研究如何在 Python 中处理文件之前，理解文件到底是什么以及现代操作系统如何处理它们的某些方面是很重要的。</p><h1 id="c123" class="ni ml ir bd mq nj nk nl mt nm nn no mw jx np jy mz ka nq kb nc kd nr ke nf ns bi translated">什么是文件？</h1><p id="ff98" class="pw-post-body-paragraph ks kt ir ku b kv nt js kx ky nu jv la lb nv ld le lf nw lh li lj nx ll lm ln ik bi translated">文件的核心是一组连续的字节，用于存储数据。这些数据以特定的格式组织，可以是简单的文本文件，也可以是复杂的二进制文件。在大多数文件系统中，文件由三个主要部分组成:</p><ul class=""><li id="5794" class="lo lp ir ku b kv kw ky kz lb lq lf lr lj ls ln lt lu lv lw bi translated"><strong class="ku is">文件头</strong>:关于文件内容的元数据</li><li id="1491" class="lo lp ir ku b kv mb ky mc lb md lf me lj mf ln lt lu lv lw bi translated"><strong class="ku is">数据:</strong>文件内容</li><li id="0522" class="lo lp ir ku b kv mb ky mc lb md lf me lj mf ln lt lu lv lw bi translated"><strong class="ku is">文件结束(EOF): </strong>表示文件结束的特殊字符<br/>该数据表示的内容取决于所使用的格式规范，通常由扩展名表示。比如 text.csv，test.txt 或者 test.txt</li></ul><p id="64bb" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">注意 Windows 和 Linux 系统使用字符作为行尾。以“test.txt”为例，如果它是在 Windows 系统上创建的，它看起来会像:</p><pre class="kh ki kj kk gu mg ma mh mi aw mj bi"><span id="cedd" class="mk ml ir ma b gz mm mn l mo mp">yellow\r\n<br/>pink\r\n<br/>black\r\n</span><span id="7178" class="mk ml ir ma b gz nh mn l mo mp">or <br/>yellow^M<br/>pink^M<br/>black^M</span></pre><p id="1c65" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">在 Linux 系统上:</p><pre class="kh ki kj kk gu mg ma mh mi aw mj bi"><span id="29d1" class="mk ml ir ma b gz mm mn l mo mp">yellow\n<br/>pink\n<br/>black\n</span></pre><h1 id="8bf7" class="ni ml ir bd mq nj nk nl mt nm nn no mw jx np jy mz ka nq kb nc kd nr ke nf ns bi translated">读取小文件</h1><p id="b6c3" class="pw-post-body-paragraph ks kt ir ku b kv nt js kx ky nu jv la lb nv ld le lf nw lh li lj nx ll lm ln ik bi translated">读取小文件(&lt; 500MB) is pretty straightforward, below are the implementation of three methods:</p><h2 id="93be" class="mk ml ir bd mq mr ms dn mt mu mv dp mw lb mx my mz lf na nb nc lj nd ne nf ng bi translated">read()</h2><pre class="kh ki kj kk gu mg ma mh mi aw mj bi"><span id="7fd4" class="mk ml ir ma b gz mm mn l mo mp">try:<br/>    with open("big_file.txt", "r") as f_in:<br/>        data = f_in.read()<br/>except IOError as e:<br/>    print(f"Error open files, {e}")</span></pre><h2 id="f576" class="mk ml ir bd mq mr ms dn mt mu mv dp mw lb mx my mz lf na nb nc lj nd ne nf ng bi translated">readline()</h2><pre class="kh ki kj kk gu mg ma mh mi aw mj bi"><span id="c739" class="mk ml ir ma b gz mm mn l mo mp">try:<br/>    data = ""<br/>    with open("big_file.txt", "r") as f_in:<br/>        while True:<br/>            temp_data = f_in.readline()<br/>            if not temp_data:<br/>                break<br/>            data += temp_data<br/>except IOError as e:<br/>    print(f"Error open files, {e}")</span></pre><h2 id="fa82" class="mk ml ir bd mq mr ms dn mt mu mv dp mw lb mx my mz lf na nb nc lj nd ne nf ng bi translated">readlines()</h2><pre class="kh ki kj kk gu mg ma mh mi aw mj bi"><span id="5d88" class="mk ml ir ma b gz mm mn l mo mp">try:<br/>    with open("big_file.txt", "r") as f_in:<br/>        data = f_in.readlines()<br/>except IOError as e:<br/>    print(f"Error open files, {e}")</span></pre><h1 id="f6fb" class="ni ml ir bd mq nj nk nl mt nm nn no mw jx np jy mz ka nq kb nc kd nr ke nf ns bi translated">Read Large Size File</h1><p id="643a" class="pw-post-body-paragraph ks kt ir ku b kv nt js kx ky nu jv la lb nv ld le lf nw lh li lj nx ll lm ln ik bi translated">Things start getting interesting when reading large files (&gt; 500MB)。在调用<code class="fe lx ly lz ma b">read()</code>或<code class="fe lx ly lz ma b">readlines()</code>函数时，你需要格外小心，因为它们会将整个文件加载到内存中，如果你不小心，你的程序就会耗尽内存。</p><p id="aaff" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated"><code class="fe lx ly lz ma b">readline()</code>函数没问题，因为它每次只读取文件的一行。您可以按如下方式轻松实现它:</p><pre class="kh ki kj kk gu mg ma mh mi aw mj bi"><span id="2aa1" class="mk ml ir ma b gz mm mn l mo mp">try:<br/>    with open("read_large_files/bigfile.txt", "r") as f_in:<br/>        while True:<br/>            temp_data = f_in.readline()<br/>            if "testing" in temp_data:<br/>                print("Find word testing", temp_data)<br/>                # Process this line<br/>            if not temp_data:<br/>                break<br/>except IOError as e:<br/>    print(f"Error open files, {e}")</span></pre><p id="8f35" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">然而，在极端的用例中，<strong class="ku is">如果整个文件只有一行</strong>呢？即使在这种情况下使用<code class="fe lx ly lz ma b">readline()</code>,您仍然会遇到内存问题。</p><pre class="kh ki kj kk gu mg ma mh mi aw mj bi"><span id="a7e6" class="mk ml ir ma b gz mm mn l mo mp">Aug 31 15:29:22 ctcloud-ide kernel: Out of memory: Kill process 11463 (python) score 536 or sacrifice child<br/>Aug 31 15:29:22 ctcloud-ide kernel: Killed process 11463 (python) total-vm:4474120kB, anon-rss:4317876kB, file-rss:716kB, shmem-rss:0kB</span></pre><p id="c32b" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">为了安全地读取大文件，我们仍然可以使用<code class="fe lx ly lz ma b">read()</code>函数，但是有一个名为 size(字符数)的参数:</p><pre class="kh ki kj kk gu mg ma mh mi aw mj bi"><span id="1826" class="mk ml ir ma b gz mm mn l mo mp">try:<br/>    with open("read_large_files/bigfile.txt", "r") as f_in:<br/>        while True:<br/>            temp_data = f_in.read(4096)<br/>            if "testing" in temp_data:<br/>                print("Find word testing", temp_data)<br/>                # Process this line<br/>            if not temp_data:<br/>                break<br/>except IOError as e:<br/>    print(f"Error open files, {e}")</span></pre><p id="363e" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">在上面的代码片段中，我们将整数 4096 (4k)作为<code class="fe lx ly lz ma b">read()</code>函数的参数传递，这意味着一次读取 4k 个字符，直到不再有数据为止。这样，即使整个文件内容只包含一行，您也不会遇到内存问题。</p><h1 id="4f26" class="ni ml ir bd mq nj nk nl mt nm nn no mw jx np jy mz ka nq kb nc kd nr ke nf ns bi translated">一个完整的例子</h1><pre class="kh ki kj kk gu mg ma mh mi aw mj bi"><span id="2eb1" class="mk ml ir ma b gz mm mn l mo mp">def read_in_chunks(file_object, chunk_size=1024):<br/>    """Generator to read a file piece by piece.<br/>    Default chunk size: 1k<br/>    """<br/>    try:<br/>        while True:<br/>            data = file_object.read(chunk_size)<br/>            if not data:<br/>                break<br/>            yield data<br/>    except IOError as e:<br/>        print(f"Error open file, {e}")</span><span id="3669" class="mk ml ir ma b gz nh mn l mo mp">with open('test_file.txt') as f_in:<br/>    for piece in read_in_chunks(f_in):</span></pre><p id="c388" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">或带分隔符:</p><pre class="kh ki kj kk gu mg ma mh mi aw mj bi"><span id="74f8" class="mk ml ir ma b gz mm mn l mo mp">def read_in_chunks(file_handler, spilt: str):<br/>    temp = ""<br/>    while True:<br/>        chunk = file_handler.read(200)  # Read 200 chars per time<br/>        if not chunk:  # If no more dazta<br/>            yield temp  # Last piece of data<br/>            break</span><span id="9393" class="mk ml ir ma b gz nh mn l mo mp">        # Remain characters + new chunk values<br/>        temp += chunk<br/>        while True:<br/>            if spilt in temp:  # Check if there is a line break<br/>                pos = temp.index(spilt)  # Get line break index<br/>                yield temp[:pos] # Get line break left side data<br/>                temp = temp[pos + len(spilt):]  # Get right data<br/>            else:<br/>                break</span><span id="0826" class="mk ml ir ma b gz nh mn l mo mp">with open("test_file.txt", "r") as f_in:<br/>    for line in read_in_chunks(f_in, spilt="following"):<br/>        print(line)</span></pre><p id="dfa4" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">或者用一种更 pythonic 化的方式</p><pre class="kh ki kj kk gu mg ma mh mi aw mj bi"><span id="5038" class="mk ml ir ma b gz mm mn l mo mp">from functools import partial</span><span id="f293" class="mk ml ir ma b gz nh mn l mo mp">with open('test_file.txt', 'r') as f_in:<br/>    block_read = partial(f_in.read, 1024 * 1024)<br/>    block_iterator = iter(block_read, '')</span><span id="0c7d" class="mk ml ir ma b gz nh mn l mo mp">    for index, block in enumerate(block_iterator, start=1):<br/>        block = process_block(block)  # process your block data</span><span id="a175" class="mk ml ir ma b gz nh mn l mo mp">        with open(f'{index}.txt', 'w') as f_out:<br/>            f_out.write(block)</span></pre></div></div>    
</body>
</html>