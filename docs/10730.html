<html>
<head>
<title>Two sum leetcode problem solution 1000X Faster</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">两个总和 leetcode 问题解决方案快 1000 倍</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/two-sum-leetcode-problem-solution-1000x-faster-cdb8332dcc34?source=collection_archive---------8-----------------------#2022-11-25">https://blog.devgenius.io/two-sum-leetcode-problem-solution-1000x-faster-cdb8332dcc34?source=collection_archive---------8-----------------------#2022-11-25</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/e9af9f2bdc7bc2b40a96fb18adf357a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kvLs8vTHxj06-o8ePmUYqA.png"/></div></div></figure><p id="5b53" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这篇文章中，你将学习解决两个和的 leetcode 问题的方法，在这篇文章中，我们将看到两个和的 leetcode 问题的多种解决方案，你也可以根据你的要求更新下面的代码。</p><h1 id="e46f" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">两个总和 leetcode 问题陈述:</h1><p id="e0ab" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">给定一个整数数组<em class="lx"> nums </em>和一个整数<em class="lx"> target </em>，返回这两个数字的索引<em class="lx">，这样它们加起来就是 target </em>。</p><p id="bf91" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你可以假设每个输入都有<em class="lx">恰好</em>一个解，并且你不能使用<em class="lx">相同的</em>元素两次。</p><p id="8173" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">可以任意顺序返回答案。</p><p id="c1ad" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">示例 1:</p><pre class="ly lz ma mb gt mc md me bn mf mg bi"><span id="55d3" class="mh kv in md b be mi mj l mk ml">Input: nums = [2,7,11,15], target = 9<br/>Output: [0,1]<br/>Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].</span></pre><p id="6621" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">示例 2:</p><pre class="ly lz ma mb gt mc md me bn mf mg bi"><span id="b2f1" class="mh kv in md b be mi mj l mk ml">Input: nums = [3,2,4], target = 6<br/>Output: [1,2]</span></pre><p id="ff67" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">示例 3:</p><pre class="ly lz ma mb gt mc md me bn mf mg bi"><span id="f8ce" class="mh kv in md b be mi mj l mk ml">Input: nums = [3,3], target = 6<br/>Output: [0,1]</span></pre><p id="36d1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我想你们现在已经明白我们要做什么了，如果你还不明白，我在这里，让我为你解释一下。</p><p id="9ce6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">假设我们有一个名为<em class="lx">arr =【2，7，11，15】</em>的未排序数组和一个目标值<em class="lx"> target=9 </em>，如果你将索引<em class="lx"> 0 </em>值(即<em class="lx"> 2 </em>和索引<em class="lx"> 1 </em>值(即 arr 的<em class="lx"> 7 </em>)相加，你将得到答案<em class="lx"> 9 </em>，它与<em class="lx">目标</em>完全相同 因为我们不需要两个和的所有可能对，我们可以返回我们得到的索引，即<em class="lx"> [0，1] </em>，所以这将是我们根据给定问题的答案。索引的顺序可以从<em class="lx"> [0，1] </em>改变为<em class="lx"> [1，0] </em>，这在两个和的 leetcode 问题中是可以接受的。</p><pre class="ly lz ma mb gt mc md me bn mf mg bi"><span id="0133" class="mh kv in md b be mi mj l mk ml">Runtime: 2 ms, faster than 99.24% of Go online submissions for Two Sum.<br/>Memory Usage: 4.3 MB, less than 54.46% of Go online submissions for Two Sum.</span></pre><h1 id="f0f4" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">解决两个和问题的方法；</h1><p id="493d" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">下面是解决围棋中两个和问题的所有可能的方法</p><ul class=""><li id="919f" class="mm mn in jx b jy jz kc kd kg mo kk mp ko mq ks mr ms mt mu bi translated">强力(使用两个循环)</li><li id="ced2" class="mm mn in jx b jy mv kc mw kg mx kk my ko mz ks mr ms mt mu bi translated">使用 Go 地图</li><li id="e162" class="mm mn in jx b jy mv kc mw kg mx kk my ko mz ks mr ms mt mu bi translated">使用左右指针</li><li id="8ae9" class="mm mn in jx b jy mv kc mw kg mx kk my ko mz ks mr ms mt mu bi translated">所有可能的配对</li></ul><p id="3328" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这些是您将在下面的操作中看到的所有可能的实现，所以不用花费任何额外的时间，让我们一个接一个地看这些实现。</p><h1 id="21d2" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">1.蛮力或天真的方法</h1><p id="c24a" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">蛮力或天真的方法是得到结果的最简单的方法，我们要做的是，在这个方法中我们需要两个循环，这样我们可以依次迭代每个索引，以检查总和是否等于给定的目标值，如果匹配，那么我们将立即返回两个元素的索引，正如我之前提到的，返回的索引的顺序在这里并不重要。</p><h2 id="83c1" class="na kv in bd kw nb nc dn la nd ne dp le kg nf ng li kk nh ni lm ko nj nk lq nl bi translated">算法:</h2><ul class=""><li id="7c66" class="mm mn in jx b jy ls kc lt kg nm kk nn ko no ks mr ms mt mu bi translated">步骤 1:创建一个函数，该函数将有两个参数:第一个<em class="lx">未排序数组</em>，第二个参数将是<em class="lx">目标</em>值，该函数还将返回索引的数组/切片。</li><li id="15b2" class="mm mn in jx b jy mv kc mw kg mx kk my ko mz ks mr ms mt mu bi translated">步骤 2:创建一个循环<em class="lx"> i=0 </em>并遍历未排序的数组长度</li><li id="65c2" class="mm mn in jx b jy mv kc mw kg mx kk my ko mz ks mr ms mt mu bi translated">步骤 3:创建第二个循环，从<em class="lx"> j = i+1 </em>开始迭代到未排序数组的长度。</li><li id="7c1a" class="mm mn in jx b jy mv kc mw kg mx kk my ko mz ks mr ms mt mu bi translated">第四步:在第二个循环中，对每次迭代的<em class="lx"> arr[i] </em>和<em class="lx"> arr[j] </em>的值求和，并存储在一个名为<em class="lx"> sum = arr[i] + arr[j] </em>的变量中。</li><li id="c41c" class="mm mn in jx b jy mv kc mw kg mx kk my ko mz ks mr ms mt mu bi translated">第五步:在得到每个指标的总和后的第二次循环中，写一个 if 条件并检查，<em class="lx"> sum == target </em>。</li><li id="74b2" class="mm mn in jx b jy mv kc mw kg mx kk my ko mz ks mr ms mt mu bi translated">步骤 6:如果步骤 5 为真，则返回索引<em class="lx"> return []int{i，j} </em>，您可以更改<em class="lx"> i，j </em>的位置。</li></ul><p id="043c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们有了一个算法。下面就按照顺序来实现吧。</p><h2 id="270f" class="na kv in bd kw nb nc dn la nd ne dp le kg nf ng li kk nh ni lm ko nj nk lq nl bi translated">代码:</h2><p id="f8fb" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">下面是简单方法的代码</p><pre class="ly lz ma mb gt mc md me bn mf mg bi"><span id="c164" class="mh kv in md b be mi mj l mk ml">package main<br/>import (<br/>    "fmt"<br/>)<br/>func TwoSumNaive(slice []int, target int) []int { // step 1<br/>    for i := 0; i &lt; len(slice)-1; i++ { // step 2<br/>        for j := i + 1; j &lt; len(slice); j++ { // step 3<br/>            sum := slice[i] + slice[j] // step 4<br/>            if sum == target { // step 5<br/>                return []int{i, j} // step 6<br/>            }<br/>            continue<br/>        }<br/>    }<br/>    return []int{}<br/>}<br/>func main() {<br/>    slice := []int{2, 7, 2, 11, 15, 6}<br/>    target := 9<br/>    sum := TwoSumNaive(slice, target)<br/>    fmt.Println(sum)<br/>}</span></pre><h2 id="8f13" class="na kv in bd kw nb nc dn la nd ne dp le kg nf ng li kk nh ni lm ko nj nk lq nl bi translated">解释:</h2><p id="0294" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">正如你在代码中看到的，我们有一个未排序的数组/切片<em class="lx"> slice := []int{2，7，2，11，15，6} </em>和一个目标值<em class="lx"> target := 9 </em>，然后我们调用<em class="lx"> TwoSumNaive() </em>函数，并将<em class="lx"> slice </em>和<em class="lx"> target </em>变量作为参数传递给该函数。在<em class="lx"> TwoSumNaive() </em>内部，我们首先在未排序的数组/片上开始从<em class="lx"> 0 到 len(arr)-1 </em>的循环，并且在第一次循环之后，我们开始从 i+1 到未排序数组的最后一个元素的另一次循环，因此执行将像这样发生，例如<em class="lx"> i=0 </em>和<em class="lx"> j=0+1 </em>即<em class="lx"> 1 </em>，以及索引值<em class="lx"> 0 </em> 对于索引<em class="lx"> 1 </em>它是<em class="lx"> 7 </em>，那么和值将是<em class="lx"> 2 + 7 = 9 </em>，<em class="lx"> sum = 9 </em>，接下来我们将比较 sum 和 target，因为我们有 sum <em class="lx"> 9 </em>并且 target 也是<em class="lx"> 9 </em>，然后它将返回索引<em class="lx"> i </em>和<em class="lx"> j </em>，所以我们的答案将是<em class="lx"/></p><p id="b431" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下面是 leetcode 和本地系统执行结果:</p><pre class="ly lz ma mb gt mc md me bn mf mg bi"><span id="73e0" class="mh kv in md b be mi mj l mk ml">$ go run .\main.go<br/>[0 1]</span></pre><pre class="np mc md me bn mf mg bi"><span id="12c4" class="mh kv in md b be mi mj l nq ml">Runtime: 46 ms, faster than 22.60% of Go online submissions for Two Sum.<br/>Memory Usage: 3.6 MB, less than 74.60% of Go online submissions for Two Sum.</span></pre><p id="5866" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Leetcode 的结果看起来不太好，因为这比我在文章中提到的要花更多的时间。</p><h1 id="dc24" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">2.使用散列表</h1><p id="6b1e" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">天真的方法是程序员能想到的最简单的方法，但对于大长度数组，天真的方法并没有像我们需要的那样快，因为你可以为这个数组<em class="lx"> {2，7，2，11，15，6} </em>花费几乎<em class="lx"> 46 ms </em>这并不是很快，所以，为了使它更快，我们首先需要消除我们的第二个循环，我们还需要新的数据结构 HashMap， 在 Go 中，这是一个<em class="lx">映射</em>，所以我们要做的不是将我们的值相加，而是检查<em class="lx">diff = target–arr[index]</em>，例如<em class="lx">diff =</em><em class="lx">9–2</em>和<em class="lx"> diff </em>将是<em class="lx"> 7 </em>，因为我们有剩余值，所以我们将查看<em class="lx"> 7 的映射</em></p><h2 id="1607" class="na kv in bd kw nb nc dn la nd ne dp le kg nf ng li kk nh ni lm ko nj nk lq nl bi translated">算法</h2><ul class=""><li id="3c8c" class="mm mn in jx b jy ls kc lt kg nm kk nn ko no ks mr ms mt mu bi translated">步骤 1:创建一个函数，该函数将有两个参数:第一个<em class="lx">未排序数组</em>，第二个参数将是<em class="lx">目标</em>值，该函数还将返回数组/索引片。</li><li id="fc56" class="mm mn in jx b jy mv kc mw kg mx kk my ko mz ks mr ms mt mu bi translated">步骤 2:声明一个 map 类型的变量，这样我们就可以查找剩余的值。</li><li id="2330" class="mm mn in jx b jy mv kc mw kg mx kk my ko mz ks mr ms mt mu bi translated">步骤 3:创建一个循环，遍历未排序的数组/切片。</li><li id="f821" class="mm mn in jx b jy mv kc mw kg mx kk my ko mz ks mr ms mt mu bi translated">第四步。从数组/切片中减去<em class="lx">索引</em>的<em class="lx">目标</em>值，例如<em class="lx">diff = target–slice[idx]</em>。</li><li id="1f38" class="mm mn in jx b jy mv kc mw kg mx kk my ko mz ks mr ms mt mu bi translated">步骤 5:将差值作为键传递给 map，检查这个键是否存在于我们的 hashmap 中。</li><li id="92c6" class="mm mn in jx b jy mv kc mw kg mx kk my ko mz ks mr ms mt mu bi translated">步骤 6:如果键存在于我们的 hashmap 中，提取键的值并返回当前的索引和值。</li><li id="d07f" class="mm mn in jx b jy mv kc mw kg mx kk my ko mz ks mr ms mt mu bi translated">步骤 7:如果键不存在，那么将当前索引的值作为键和值添加到我们的 HashMap 中。</li></ul><p id="3b1c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们有我们的算法，让我们实现它，看看它的结果，下面是算法的实现:</p><h2 id="4a92" class="na kv in bd kw nb nc dn la nd ne dp le kg nf ng li kk nh ni lm ko nj nk lq nl bi translated">密码</h2><pre class="ly lz ma mb gt mc md me bn mf mg bi"><span id="8ccc" class="mh kv in md b be mi mj l mk ml">package main<br/><br/>import (<br/>    "fmt"<br/>)<br/><br/>// using HashMap<br/>func TwoSumHashmap(slice []int, target int) []int {<br/>    hashMap := map[int]int{}<br/>    for idx := 0; idx &lt; len(slice); idx++ {<br/>        pmatch := target - slice[idx]<br/>        if v, exists := hashMap[pmatch]; exists {<br/>            return []int{idx, v}<br/>        }<br/>        hashMap[slice[idx]] = idx<br/>    }<br/>    return nil<br/>}<br/><br/>func main() {<br/>    slice := []int{2, 7, 2, 11, 15, 6}<br/>    target := 9<br/>    sum := TwoSumHashmap(slice, target)<br/>    fmt.Println(sum)<br/>}</span></pre><h2 id="0d3f" class="na kv in bd kw nb nc dn la nd ne dp le kg nf ng li kk nh ni lm ko nj nk lq nl bi translated">解释:</h2><p id="154e" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">我们在这个代码示例中使用 map，你可以看到我们有一个名为<em class="lx"> TwoSumHashmap </em>的函数，它有两个参数:第一个是未排序的数组，第二个是我们的目标值，它也返回<em class="lx"> []int </em>。</p><p id="3be1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在我们的函数中，我们已经声明了一个名为<em class="lx"> hashMap </em>的映射，因为我们都知道 Go 的映射保存了键和值对信息，所以我们最好使用它，而不是像在<em class="lx">方法 1 </em>中那样使用另一个循环来迭代所有值。</p><p id="d60c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在声明一个映射之后，我们在给定的片/数组上运行我们的循环，直到数组的最后一个元素。在循环中，我们在每次迭代中减去 target-slice[idx ],在下一步中，我们直接将差值作为映射的键传递。在 Go 中，你可以像这样检查所传递的键是否存在于映射中，因为第二个返回值返回一个<em class="lx"> Boolean </em>值，如果所提供的键存在于键中，则该值为真，否则它将返回一个假值，因此如果我们的键存在于映射中，则我们将直接返回数组的当前索引和从键中获得的值，该键也是一个索引， 如果为假，那么我们将进入下一步，我们将添加当前索引数组/片值作为键，添加当前索引作为它的值，这样它将一直工作，直到找到键，并将返回索引，如果没有找到，函数将返回<em class="lx"> nil </em>。</p><p id="8371" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下面是 Leetcode 和本地系统的代码输出:</p><pre class="ly lz ma mb gt mc md me bn mf mg bi"><span id="58a5" class="mh kv in md b be mi mj l mk ml">$ go run .\main.go<br/>[1 0]</span></pre><pre class="np mc md me bn mf mg bi"><span id="228c" class="mh kv in md b be mi mj l nq ml">Runtime: 2 ms, faster than 99.24% of Go online submissions for Two Sum.<br/>Memory Usage: 4.3 MB, less than 54.46% of Go online submissions for Two Sum.</span></pre><p id="f290" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">与强力方法相比，HashMap 要好得多。Hashmap 几乎比暴力破解快 2300%。</p><p id="8257" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下面是得到一对两个和的另一种方法，让我们看看</p><h1 id="1531" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">3.左右指针</h1><p id="56f7" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated"><em class="lx">免责声明:</em>这种方法可能在 leetcode 中不起作用，因为这种方法只对排序数组起作用，而且通过排序索引可能会改变，所以你的答案。</p><p id="d116" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这种方法中，我们将首先对数组进行排序，然后我们将创建一个 for 循环(无限),并添加一些条件，基于这些条件，我们的左右指针将向前和向后移动。让我们来看看这个算法:</p><h2 id="eece" class="na kv in bd kw nb nc dn la nd ne dp le kg nf ng li kk nh ni lm ko nj nk lq nl bi translated">算法</h2><ul class=""><li id="7350" class="mm mn in jx b jy ls kc lt kg nm kk nn ko no ks mr ms mt mu bi translated">步骤 1:创建一个函数，该函数将有两个参数:第一个<em class="lx">未排序数组</em>，第二个参数将是<em class="lx">目标</em>值，该函数还将返回数组/索引片。</li><li id="dd99" class="mm mn in jx b jy mv kc mw kg mx kk my ko mz ks mr ms mt mu bi translated">第二步:声明两个变量 left pointer 和 right pointer，并初始化它们的值<em class="lx"> left = 0 </em>，<em class="lx"> right=len(arr) </em>。</li><li id="67e3" class="mm mn in jx b jy mv kc mw kg mx kk my ko mz ks mr ms mt mu bi translated">第 3 步:首先对你的数组进行排序，在 go 中你可以使用<em class="lx"> Sort </em>包进行这个<em class="lx">排序。Ints() </em>。</li><li id="7364" class="mm mn in jx b jy mv kc mw kg mx kk my ko mz ks mr ms mt mu bi translated">第四步。创建一个<em class="lx"> for ever 循环</em>for start！=结束。</li><li id="7ae4" class="mm mn in jx b jy mv kc mw kg mx kk my ko mz ks mr ms mt mu bi translated">步骤 5:对左右数组索引值求和。</li><li id="70d8" class="mm mn in jx b jy mv kc mw kg mx kk my ko mz ks mr ms mt mu bi translated">步骤 6:如果 sum &gt; target，则添加条件:如果为真，则<em class="lx">right = right–1</em>向后移动指针。</li><li id="a79a" class="mm mn in jx b jy mv kc mw kg mx kk my ko mz ks mr ms mt mu bi translated">步骤 7:else if sum&lt; target: if true then left = left + 1, move pointer forward.</li><li id="164a" class="mm mn in jx b jy mv kc mw kg mx kk my ko mz ks mr ms mt mu bi translated">Step 8: else: return []int{left, right}.</li></ul><h2 id="c6b4" class="na kv in bd kw nb nc dn la nd ne dp le kg nf ng li kk nh ni lm ko nj nk lq nl bi translated">Code</h2><pre class="ly lz ma mb gt mc md me bn mf mg bi"><span id="09dd" class="mh kv in md b be mi mj l mk ml">package main<br/><br/>import (<br/>    "fmt"<br/>    "sort"<br/>)<br/><br/>func TwoSumSortedArray(slice []int, target int) []int {<br/>    if len(slice) &lt; 2 {<br/>        fmt.Println("can't process")<br/>        return nil<br/>    }<br/>    sort.Ints(slice)<br/>    start := 0<br/>    end := len(slice) - 1<br/>    fmt.Println("After Sorting:", slice)<br/><br/>    for start != end {<br/>        sum := slice[start] + slice[end]<br/>        if sum &gt; target {<br/>            end = end - 1<br/>        } else if sum &lt; target {<br/>            start = start + 1<br/>        } else {<br/>            return []int{start, end}<br/>        }<br/>    }<br/>    return nil<br/>}<br/><br/>func main() {<br/>    slice := []int{2, 7, 2, 11, 15, 6}<br/>    target := 9<br/>    fmt.Println("Before Sorting:", slice)<br/>    sum := TwoSumSortedArray(slice, target)<br/>    fmt.Println(sum)<br/>}</span></pre><h2 id="d946" class="na kv in bd kw nb nc dn la nd ne dp le kg nf ng li kk nh ni lm ko nj nk lq nl bi translated">Explanation</h2><p id="9608" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">As you can see in the <em class="lx">TwoSumSortedArray</em>函数首先，我们添加了一个条件来检查数组/片是否有足够的数据长度，因为我们不想让我们的程序崩溃:)，然后我们对数组/片进行了排序，现在数组的顺序已经改变，所以现在的结果不会像前面的例子那样。接下来我们声明了我们的指针并赋值。</p><p id="754f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们开始了循环，并添加了一个条件，所以只要我们的指针值相等，循环就会结束。</p><p id="2dd0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在循环中，我们添加左和右索引值，并将其传递给我们所拥有的条件，并根据总和和目标值将指针向左和向右移动。如果目标值大于左和右指针数组索引值的联合值，那么我们将把结束指针向后移动一步，对于其他条件，我们将把<em class="lx">开始(左)</em>指针向前移动，如果两个条件都不满足，那么我们将返回开始(左)和结束(右)值。</p><pre class="ly lz ma mb gt mc md me bn mf mg bi"><span id="835e" class="mh kv in md b be mi mj l mk ml">$ go run .\main.go<br/>Before Sorting: [2 7 2 11 15 6]<br/>After Sorting: [2 2 6 7 11 15]<br/>[0 3]</span></pre><h1 id="a56c" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">4.所有可能的配对程序</h1><p id="317b" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">如果我们想要所有可能的两个和对，是的，你可以在修改一点代码后，用上面的两种方法得到所有可能的和对。</p><p id="4497" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下面是所有可能的两个和对的代码:</p><h2 id="2587" class="na kv in bd kw nb nc dn la nd ne dp le kg nf ng li kk nh ni lm ko nj nk lq nl bi translated">蛮力:</h2><pre class="ly lz ma mb gt mc md me bn mf mg bi"><span id="03e0" class="mh kv in md b be mi mj l mk ml">func TwoSumNaive(slice []int, target int) [][]int {<br/>    s := [][]int{}<br/>    for i := 0; i &lt; len(slice)-1; i++ {<br/>        for j := i + 1; j &lt; len(slice); j++ {<br/>            sum := slice[i] + slice[j]<br/>            if sum == target {<br/>                s = append(s, []int{i, j})<br/>            }<br/>            continue<br/>        }<br/>    }<br/>    return s<br/>}</span></pre><h2 id="4a9a" class="na kv in bd kw nb nc dn la nd ne dp le kg nf ng li kk nh ni lm ko nj nk lq nl bi translated">散列表:</h2><pre class="ly lz ma mb gt mc md me bn mf mg bi"><span id="edc2" class="mh kv in md b be mi mj l mk ml">func TwoSumHashmap(slice []int, target int) [][]int {<br/>    s := [][]int{}<br/>    hashMap := map[int]int{}<br/>    for idx := 0; idx &lt; len(slice)-1; idx++ {<br/>        pmatch := target - slice[idx]<br/>        if v, exists := hashMap[pmatch]; exists {<br/>            s = append(s, []int{idx, v})<br/>            delete(hashMap, pmatch)<br/>        }<br/>        hashMap[slice[idx]] = idx<br/>    }<br/>    return s<br/>}</span></pre><p id="f33f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="lx">本文原贴于</em><a class="ae kt" href="https://programmingeeksclub.com/two-sum-leetcode-1000x-faster/" rel="noopener ugc nofollow" target="_blank"><em class="lx">programmingeeksclub.com</em></a></p><p id="c8c2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="lx">我的个人博客网站:</em> <a class="ae kt" href="https://programmingeeksclub.com/" rel="noopener ugc nofollow" target="_blank"> <em class="lx">编程极客俱乐部</em> </a> <br/> <em class="lx">我的脸书页面:</em> <a class="ae kt" href="https://www.facebook.com/profile.php?id=100086258693659" rel="noopener ugc nofollow" target="_blank"> <em class="lx">编程极客俱乐部</em> </a> <br/> <em class="lx">我的电报频道:</em> <a class="ae kt" href="https://t.me/dpgcl" rel="noopener ugc nofollow" target="_blank"> <em class="lx">编程极客俱乐部</em> </a> <br/> <em class="lx">我的推特账号:</em> <a class="ae kt" href="https://twitter.com/kusinghofficial" rel="noopener ugc nofollow" target="_blank"> <em class="lx">库尔迪普辛格</em> </a> <br/> <em class="lx">我的 Youtube 频道:【T28</em></p></div></div>    
</body>
</html>