<html>
<head>
<title>Introduction to Unit Testing in MUnit</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">MUnit 中的单元测试介绍</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/introduction-to-unit-testing-in-munit-4ce7e24ff3f4?source=collection_archive---------6-----------------------#2022-12-09">https://blog.devgenius.io/introduction-to-unit-testing-in-munit-4ce7e24ff3f4?source=collection_archive---------6-----------------------#2022-12-09</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="ec83" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">低级代码不一定是未经测试的代码</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><a href="https://github.com/daminals/Unit_Testing_with_MUnit"><div class="gh gi ki"><img src="../Images/00e0dbe1164d6ebd88c1308420442c4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xGaSWaMkMcySOhu6auTzRA.png"/></div></a><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">查看该项目的 GitHub</figcaption></figure><h1 id="b986" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">什么是单元测试？</h1><p id="6bb8" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">单元测试是软件开发中的一个过程，它需要创建测试用例来评估单个代码单元的功能和行为。这是软件开发过程中至关重要的一步，通常由开发人员作为日常任务的一部分来执行。</p><p id="b859" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">单元测试的主要优势之一是它有助于在开发过程的早期发现缺陷和错误，在它们可能导致更大的问题之前。通过为代码编写单元测试，您可以确保代码按预期运行，并且您所做的任何更改都不会破坏现有的功能。</p><p id="13c4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">用汇编语言编写代码通常会涉及到令人头疼的繁琐过程，调试这些代码可能会花费数小时的时间。这就是为什么在编写这种类型的代码时，应用单元测试尤为必要。</p><p id="94b5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">本文将介绍如何用 MUnit 编写测试，这是一个基于 JUnit 的汇编语言 mips 测试框架。</p><p id="be91" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">需要注意的是，单元测试的过程包括编写离散函数的测试，在函数测试之前或之后存储在变量/寄存器中的值不能保证在不同的测试中保持不变。</p><p id="7a4e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">本文中使用的所有代码都可以在<a class="ae ly" href="https://github.com/daminals/Unit_Testing_with_MUnit" rel="noopener ugc nofollow" target="_blank">的 github 链接</a>上获得。</p><h1 id="853b" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">启动测试文件</h1><p id="ce88" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">在开始之前，我们需要清除许多样板代码，所以我现在提供一个样本测试文件:</p><pre class="kj kk kl km gt lz ma mb bn mc md bi"><span id="ac6d" class="me kv in ma b be mf mg l mh mi">import org.junit.*;<br/>import org.junit.rules.Timeout;<br/><br/>import java.util.*;<br/>import java.io.*;<br/>import java.util.concurrent.TimeUnit;<br/><br/>import static edu.gvsu.mipsunit.munit.MUnit.Register.*;<br/>import static edu.gvsu.mipsunit.munit.MUnit.*;<br/>import static edu.gvsu.mipsunit.munit.MARSSimulator.*;<br/><br/>import org.junit.rules.Timeout;<br/>import java.util.concurrent.TimeUnit;<br/><br/>public class TestName {<br/><br/>  int sp = 0;<br/>  int s0 = 0;<br/>  int s1 = 0;<br/>  int s2 = 0;<br/>  int s3 = 0;<br/>  int s4 = 0;<br/>  int s5 = 0;<br/>  int s6 = 0;<br/>  int s7 = 0;<br/>  int gp = 0;<br/><br/><br/>  @Before<br/>  public void preTest() {<br/>    s0 = get(s0);<br/>    s1 = get(s1);<br/>    s2 = get(s2);<br/>    s3 = get(s3);<br/>    s4 = get(s4);<br/>    s5 = get(s5);<br/>    s6 = get(s6);<br/>    s7 = get(s7);<br/>    sp = get(sp);<br/>    gp = get(gp);<br/>  }<br/><br/>  @After<br/>  public void postTest() {<br/>    Assert.assertEquals("Register convention violated $s0", s0, get(s0));<br/>    Assert.assertEquals("Register convention violated $s1", s1, get(s1));<br/>    Assert.assertEquals("Register convention violated $s2", s2, get(s2));<br/>    Assert.assertEquals("Register convention violated $s3", s3, get(s3));<br/>    Assert.assertEquals("Register convention violated $s4", s4, get(s4));<br/>    Assert.assertEquals("Register convention violated $s5", s5, get(s5));<br/>    Assert.assertEquals("Register convention violated $s6", s6, get(s6));<br/>    Assert.assertEquals("Register convention violated $s7", s7, get(s7));<br/>    Assert.assertEquals("Register convention violated $sp", sp, get(sp));<br/>    Assert.assertEquals("Register convention violated $gp", gp, get(gp));<br/>  }<br/><br/>  @Rule<br/>  public Timeout timeout = new Timeout(30000, TimeUnit.MILLISECONDS);<br/><br/>}</span></pre><p id="2928" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是我们基本的 java 单元测试文件，稍后我们将基于我们的程序添加测试。您将能够使用函数来编译它</p><pre class="kj kk kl km gt lz ma mb bn mc md bi"><span id="23f3" class="me kv in ma b be mf mg l mh mi">javac -cp munit.jar path/to/test/file.java                <br/>java -jar munit.jar path/to/test/file.class path/to/mips/file.asm</span></pre><h1 id="b4ff" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">要测试的 Mips 代码</h1><p id="f85e" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">我将为您提供一个递归斐波那契函数在 mips。下面的代码有一个 bug，我们将通过单元测试来找到它。</p><pre class="kj kk kl km gt lz ma mb bn mc md bi"><span id="a6bb" class="me kv in ma b be mf mg l mh mi"># Compute the nth fibonacci number<br/>#<br/># n: the index of the fibonacci number to compute<br/>#<br/># return: the nth fibonacci number<br/><br/>.globl fibonacci<br/>fibonacci:<br/>  <br/>    # Check if n is 0 or 1<br/>    li $t0, 1<br/>    beqz $a0, return_0<br/>    beq $a0, $t0, return_1<br/><br/>    # Compute the (n-1)th and (n-2)th fibonacci numbers<br/>    addi $sp, $sp, -8    # allocate space on the stack<br/>    sw $ra, 4($sp)       # save return address<br/>    sw $a0, 0($sp)       # save n<br/>    addi $a0, $a0, -1    # n-1<br/>    jal fibonacci        # call fibonacci(n-1)<br/>    lw $a0, 0($sp)       # restore n<br/>    addi $a0, $a0, -2    # n-2<br/>    jal fibonacci        # call fibonacci(n-2)<br/>    lw $ra, 4($sp)       # restore return address<br/>    addi $sp, $sp, 8     # deallocate space on the stack<br/><br/>    # Return the sum of the (n-1)th and (n-2)th fibonacci numbers<br/>    add $v0, $v0, $t0<br/>    jr $ra<br/><br/>return_0:<br/>    li $v0, 0    # return 0<br/>    jr $ra<br/><br/>return_1:<br/>    li $v0, 1    # return 1<br/>    jr $ra</span></pre><p id="c03f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们的斐波那契函数遵循标准的递归算法:</p><pre class="kj kk kl km gt lz ma mb bn mc md bi"><span id="a898" class="me kv in ma b be mf mg l mh mi">function fibonacci(n): // this example is written in psuedocode<br/>  if n == 0 or n == 1:<br/>    return 1<br/>  else:<br/>    return fibonacci(n-1) + fibonacci(n-2)</span></pre><h1 id="c9b9" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">测试案例</h1><p id="5bbb" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">好的，为了开始编写测试用例，我们必须首先考虑要测试的边缘用例。我会列一个清单</p><ul class=""><li id="8259" class="mj mk in jm b jn jo jr js jv ml jz mm kd mn kh mo mp mq mr bi translated">纤维(0)</li><li id="35b1" class="mj mk in jm b jn ms jr mt jv mu jz mv kd mw kh mo mp mq mr bi translated">纤维(1)</li><li id="9adc" class="mj mk in jm b jn ms jr mt jv mu jz mv kd mw kh mo mp mq mr bi translated">纤维</li></ul><p id="1b16" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这为斐波那契函数提供了一个合适的范围，因为我们的边缘情况最有可能位于我们的基础情况(0，1)上，然后我们可以测试其他一切(n)。</p><p id="171b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下面是我们开始编写测试用例的方法:</p><pre class="kj kk kl km gt lz ma mb bn mc md bi"><span id="d9ae" class="me kv in ma b be mf mg l mh mi">  @Test<br/>  public void test_zero() {<br/>    run("fibonacci", 0); # run the mips function we defined, with a0=0<br/>    Assert.assertEquals(0, get(v0)); # assert that it is the correct answer, 0<br/>  }<br/><br/>  @Test<br/>  public void test_one() {<br/>    run("fibonacci", 1); # run the mips function we defined, with a0=1<br/>    Assert.assertEquals(1, get(v0)); # assert that it is the correct answer, 1<br/>  }</span></pre><p id="f0ec" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这为 MUnit 中的测试用例提供了一个标准模板。为了测试 n，我们需要一种方法来计算任何给定的 fibonacci n 的正确答案，因此让我们用 java 编写一个 fibonacci 函数来测试我们的 mips 代码:</p><pre class="kj kk kl km gt lz ma mb bn mc md bi"><span id="2229" class="me kv in ma b be mf mg l mh mi">  public int fibonacci(int n) {<br/>    if (n &lt;= 1) return n;<br/>    return fibonacci(n-1) + fibonacci(n-2);<br/>  }</span></pre><p id="cdbe" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们也写出测试用例:</p><pre class="kj kk kl km gt lz ma mb bn mc md bi"><span id="9486" class="me kv in ma b be mf mg l mh mi">  @Test<br/>  public void fib() {<br/>    for (int n=2; n&lt;25; n++){ # test n up to 25, starting from where we stopped at 1<br/>      run("fibonacci", n); # run the mips function we defined, with a0=n<br/>      # test mips function against java function<br/>      Assert.assertEquals("fibonacci failed at n=" + n,fibonacci(n), get(v0));<br/>    }<br/>  }</span></pre><p id="3348" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们使用下面的函数编译并运行我们的测试用例</p><pre class="kj kk kl km gt lz ma mb bn mc md bi"><span id="f863" class="me kv in ma b be mf mg l mh mi">javac -cp munit.jar path/to/test/file.java                <br/>java -jar munit.jar path/to/test/file.class path/to/mips/file.asm</span></pre><h2 id="c645" class="mx kv in bd kw my mz dn la na nb dp le jv nc nd li jz ne nf lm kd ng nh lq ni bi translated">结果</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi nj"><img src="../Images/a6958e8623467c7e2859e2475747a630.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_K9fcvsH3t4RMpPUHRQ6cQ.png"/></div></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">斐波那契函数失败:预期 3 找到 2</figcaption></figure><p id="40b3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">运行测试用例后，我们发现了问题所在。我们毫无问题地完成了前两个测试用例，但是我们的 fib(n)单元测试失败了。我们还知道函数在 n=4 时失败，这给了我们一个很好的调试起点。</p><p id="fa89" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因为我们知道我们的代码在哪里失败了，我们可以调查函数是否正确地添加，因为它使我们所有的基本情况都正确，甚至有一些超过了它们。</p><p id="fbee" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">经过进一步调查，证明这是正确的。让我们看看第 28 行</p><pre class="kj kk kl km gt lz ma mb bn mc md bi"><span id="7b34" class="me kv in ma b be mf mg l mh mi"># Return the sum of the (n-1)th and (n-2)th fibonacci numbers<br/>add $v0, $v0, $t0</span></pre><p id="e90b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们加上$t0，并声称它是第 n-2 个 fib 数，但我们从未将其设置为该数。让我们通过将 fib 结果存储在堆栈中，然后在需要使用它们时恢复它们来解决这个问题！</p><pre class="kj kk kl km gt lz ma mb bn mc md bi"><span id="3678" class="me kv in ma b be mf mg l mh mi"># Compute the nth fibonacci number<br/>#<br/># n: the index of the fibonacci number to compute<br/>#<br/># return: the nth fibonacci number<br/><br/>.globl fibonacci<br/>fibonacci:<br/>  <br/>    # Check if n is 0 or 1<br/>    li $t0, 1<br/>    beqz $a0, return_0<br/>    beq $a0, $t0, return_1<br/><br/>    # Compute the (n-1)th and (n-2)th fibonacci numbers<br/>    addi $sp, $sp, -16    # allocate space on the stack<br/>    sw $ra, 4($sp)       # save return address<br/>    sw $a0, 0($sp)       # save n<br/>    addi $a0, $a0, -1    # n-1<br/>    jal fibonacci        # call fibonacci(n-1)<br/>    sw $v0, 8($sp)       # store fib(n-1) in the stack<br/>    lw $a0, 0($sp)       # restore n<br/>    addi $a0, $a0, -2    # n-2<br/>    jal fibonacci        # call fibonacci(n-2)<br/>    sw $v0, 12($sp)      # store fib(n-2) in the stack<br/>    lw $ra, 4($sp)       # restore return address<br/>    # Return the sum of the (n-1)th and (n-2)th fibonacci numbers<br/>    lw $v0, 8($sp)       # load fib(n-1)<br/>    lw $v1, 12($sp)      # load fib(n-2)<br/>    add $v0, $v0, $v1<br/>    <br/>    addi $sp, $sp, 16     # deallocate space on the stack<br/>    jr $ra<br/><br/>return_0:<br/>    li $v0, 0    # return 0<br/>    jr $ra<br/><br/>return_1:<br/>    li $v0, 1    # return 1<br/>    jr $ra</span></pre><p id="f998" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">好了，这应该能解决问题。让我们重新运行我们的单元测试！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nk nl di nm bf nn"><div class="gh gi no"><img src="../Images/ae58437daf4b996e7600357f928b745a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XgB8dx71wY1ZjejwhrG3oA.png"/></div></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">100%测试通过</figcaption></figure><p id="f014" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">完美，我们所有的测试都通过了！多刺激啊！</p><h1 id="e492" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">结论</h1><p id="10fa" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">尽管可能不会立即显现出来，但是创建这些测试用例节省了大量调试时间。我们没有在 mips 中手动输入测试，也没有偶然发现这个错误，而是能够以编程方式找到代码中的问题，然后使用这个程序缩小代码中出错的地方。</p><p id="d01a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">即使知道代码被破坏了，测试用例也给了我们优势，让我们知道在哪里寻找 bug。如果我们知道哪些案例失败了，它可以给我们一个很好的原因。</p><p id="f373" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你想了解更多关于 mips 中单元测试的知识，请查看我对这篇关于用 MUnit 测试 mips 中缓冲区的文章的后续文章:</p><div class="np nq gp gr nr ns"><a rel="noopener  ugc nofollow" target="_blank" href="/learning-to-test-buffers-in-mips-a43f10393f86"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd io gy z fp nx fr fs ny fu fw im bi translated">学习测试 MIPS 中的缓冲器</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">有时你的 MIPS 程序会将缓冲区作为输入，但是我们如何利用 MUnit 来测试这些功能呢？</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">blog.devgenius.io</p></div></div><div class="ob l"><div class="oc l od oe of ob og ko ns"/></div></div></a></div><p id="3506" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">本文中使用的所有代码都可以在下面链接的 github 资源库中找到。</p><div class="np nq gp gr nr ns"><a href="https://github.com/daminals/Unit_Testing_with_MUnit" rel="noopener  ugc nofollow" target="_blank"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd io gy z fp nx fr fs ny fu fw im bi translated">GitHub-da minals/Unit _ Testing _ with _ MUnit</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">低级代码不一定是未经测试的代码</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">github.com</p></div></div><div class="ob l"><div class="oh l od oe of ob og ko ns"/></div></div></a></div></div></div>    
</body>
</html>