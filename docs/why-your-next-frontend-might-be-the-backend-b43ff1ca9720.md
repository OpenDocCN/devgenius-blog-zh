# 为什么你的下一个 Web 应用前端可能是后端

> 原文：<https://blog.devgenius.io/why-your-next-frontend-might-be-the-backend-b43ff1ca9720?source=collection_archive---------2----------------------->

## LiveView 和其他实时服务器端渲染 HTML 技术如何改变前端的编写方式

![](img/773d620cf3499511056ced5f4b51747f.png)

大毒蛇——头吃尾(技术上来说，前端吃后端，但你明白了)

如果你在 2022 年开发一个丰富的、高度互动的 web 应用，你很可能会使用某种前端 JavaScript 框架，如 [React](https://reactjs.org) 、 [Angular](http://Angular) 或 [Vue](https://vuejs.org) ，它们通过某种 API 与后端服务器对话，可能基于 REST 或 GraphQL。

虽然这种大量使用 JavaScript 的方法很强大，但它也有一些缺点。最近，一种构建这类应用的不同方法越来越受欢迎，它带来了一些有趣的好处。新方法完全从后端服务器驱动前端，不需要编写任何 JavaScript 代码。在本文中，我们将探索这种新技术是如何工作的，并考虑与更常见的单页面应用程序(SPA)方法的一些权衡。

# Web 架构简史

纵观计算的历史，甚至在 web 出现之前，钟摆就在面向服务器和面向客户机的方法之间来回摆动。

![](img/ed2bc0ec351acc9c82881bfdd79d4d36.png)

DEC VT100 —早期的“服务器端渲染”客户端？

让我们回顾一下 web 架构的历史，看看我们从哪里开始，以及我们现在在哪里。

## 服务器呈现的，大部分是静态 HTML

曾几何时，网页是用纯 HTML 编写的，直接从后端提供。一旦交付，页面就不会在客户端进行有意义的更新。也许有一些小的 JavaScript UI，但总的来说，浏览应用程序需要往返服务器以获取新的静态 HTML 页面。

![](img/e65a1d87a27185a79c84813c7cf21a62.png)

Ruby on Rails 引领了一个更加动态的 web 应用时代

像 [PHP](https://www.php.net) 这样的语言和像 [Ruby on Rails](http://rubyonrails.org) 这样的框架(以及许多其他的)，通过为每个请求动态生成 HTML，帮助扩展了 web 应用的功能。虽然这种方法极大地增强了 web 应用程序的功能，但是对于大多数页面来说，内容到达浏览器后仍然是静态的。

## JavaScript &丰富的实时单页面应用程序(spa)

在 21 世纪初的某个时候，网页开始变得更加…动态。新的 JavaScript 工具(例如，用于 DOM 操作的[jQuery](https://jquery.com))&技术(例如，用于从服务器获取数据的 [AJAX](https://www.w3schools.com/js/js_ajax_intro.asp) )突然出现，使得页面能够在初始 HTML 加载后在浏览器中动态更新。这些更新起初很小，可能是切换内容标签，或显示简单的用户界面反馈，但随着时间的推移，JavaScript 承担了越来越多的呈现责任。

![](img/af023d5bee2e4ba4d7c8f674eb6cc449.png)

react——单页应用程序世界的冠军之一

不久，一些应用程序完全消除了服务器渲染的 HTML *，*依赖 JavaScript 来完成所有渲染页面的繁重工作(通常在 JS 中嵌入一些 HTML 模板)。这种方法演变成了我们今天所知的现代单页面应用程序，由流行的框架驱动，如 [React](http://reactjs.org) 、 [Ember](https://emberjs.com) 、 [Angular](http://angular.io) 和许多其他框架。

## **服务器端渲染&同构渲染(SSR)**

虽然 SPAs 在交互性方面表现出色，并且能够构建新类型的应用程序，但是它们在渲染时间、前端性能和 SEO 方面确实有一些缺点。呈现 SPA 通常需要多次往返于服务器，因为内容是用 JS 在客户端呈现的，所以这个过程通常比静态 HTML 慢得多。此外，一些搜索引擎不容易获得内容(下面将详细介绍)。

为了解决这个问题，一些框架开始引入[同构呈现](https://prerender.io/isomorphic-rendering/):在服务器上呈现页面的初始版本，然后让客户端 SPA 接管应用程序生命周期的剩余部分。因为初始页面内容完全加载到 HTTP 请求中，所以这种技术提高了初始加载时间& SEO 可发现性。

现在有各种各样的框架提供同构呈现功能。事实上，它内置于一些流行的前端框架，如 Vue 和 React，尽管设置和维护会带来一些开销——isoporhic 渲染可能会引入新的后端依赖关系，以便在请求时执行渲染。

## 服务器端渲染“增强”

具有同构渲染的 SSR 有助于解决 spa 的一系列常见问题，但新一代技术将这一想法推向了更远:如果你在后端完成了所有的渲染，并且有效地消除了前端应用程序的 T2 会怎么样？

**这就是 LiveView 和其他新工具正在实现的**:完全从后端驱动的丰富的&高度互动的网络应用。在本文的其余部分，我将把这种方法称为 **SSR+** 。这不是这些下一代 SSR 项目的标准术语，但我将使用它来区别于其他非交互式 SSR 解决方案。

# SSR+: LiveView & Friends

[LiveView](https://github.com/phoenixframework/phoenix_live_view) 是用奇妙的 [Elixir](https://elixir-lang.org) 语言编写的 [Phoenix Framework](http://phoenixframework.org) 的服务器渲染库。当页面被请求时，它会返回完全呈现的内容，就像一个老派的 web 应用程序一样。但是在呈现页面之后，会在后台维护一个持久的 Websocket 连接，以便根据服务器的应用程序状态动态更新页面。

![](img/a96fc6bf6d403d44a6b839c247e7b7fb.png)

Phoenix 框架，以 LiveView 为特色

> 如果您熟悉 React 组件是如何使用声明性模板呈现的，这些模板会在状态改变时自动更新，那么 LiveView 的工作方式基本相同。

如果您熟悉 React 组件是如何使用声明性模板呈现的，这些模板会在状态改变时自动更新，那么 LiveView 的工作方式基本相同。不同之处在于，LiveView 完全在服务器端运行，我们所指的“状态”不是某个本地浏览器数据存储(例如像 [Redux](https://redux.js.org) )，而是源自实际的后端服务器状态。

这意味着，随着后端数据的变化，视图可以自动重新呈现并交付给前端，而无需开发人员处理 API 调用、轮询、同步等。就像前端框架使用 DOM-diffing 只重新呈现必要的内容一样，LiveView 只推出页面中在状态改变时更新的部分。

对于绝对必要的场景，LiveView 确实通过*钩子*提供了 JavaScript 互操作性。通常，这些钩子用于有针对性的、隔离良好的交互，不会从根本上破坏面向服务器的范例。例如，它们可能用于实现动画和其他 UI 交互，但不会用于显著改变页面内容。

虽然我在这里使用 LiveView 作为例子，但是 SSR+项目在许多其他流行的语言中也是可用的。这个服务器渲染的 HTML 项目列表显示了多种语言的选项。事实上，甚至还有针对 JavaScript 的 SSR+框架。您可以在后端使用 JS 来驱动整个应用程序，而不是在浏览器中运行 JS 框架——如果您愿意，您仍然可以编写 JavaScript，但是可以获得 SSR+的所有好处。

# 服务器呈现 HTML 的优势

SSR+方法有许多优点，当然也有一些缺点。下面我们来探究几个。

## 简化的状态管理—没有客户端/服务器同步问题

编写前端应用程序的一个挑战是*状态管理，*意味着我们如何存储、访问&更新应用程序中的数据。在 JavaScript SPA 中，这很复杂，因为您实际上是在处理两个状态*和*:客户机&和服务器。保持这些状态同步需要 API 调用或客户端&服务器之间的其他通信来发送或接收数据，以响应用户交互和其他状态变化——包括在某些应用程序(如社交媒体、聊天等)中发生在*其他*客户端上的交互。

使用 SSR+，应用程序状态只有一个来源:服务器。服务器上发生的任何变化都会立即透明地推送到客户端。同样，客户机交互在服务器上立即作为事件处理。然后，服务器简单地呈现客户端的状态，更新会自动同步到浏览器。

## 不仅仅是单一的语言，而是单一的应用程序

一些开发人员喜欢使用 Node.js，因为他们看到了在前端和后端使用单一语言的好处。有时甚至有某种程度的代码重用。这在理论上很棒，但现实是您仍然在处理两个逻辑上独立的“应用程序”:通过 API 通信的前端和后端。根据我的经验，两个应用程序之间的代码共享是真实的，但通常并不显著。

使用服务器呈现的方法，您实际上是在为您的前端和后端处理单个应用程序，通常使用的代码比单独构建它们所需的代码要少得多。这对开发生命周期有巨大的好处。没有时间和精力花费在构建和维护 API 上，也没有时间和精力在 API 改变时处理前端的同步问题，更不用说维护两个项目和一个项目的一般开销了。

## 逃离 JavaScript 生态系统

我不会对 JavaScript 生态系统的状态发表太多评论，只是说使用一个丰富的现代 JavaScript 应用程序在维护、配置、依赖性管理等方面会带来很大的开销。

使用服务器渲染技术几乎可以完全消除这一痛点。即使您选择在您的服务器呈现的应用程序中包含一点 JavaScript(我在本文的其他地方推荐它来解决一些特定的问题)，您也可以通过坚持使用简单的 JS，没有重量级的应用程序框架(Vue、React 等)和最小的依赖性，来在很大程度上避免开销。

## **更快的加载时间&更好的 SEO**

如前所述，JavaScript 单页应用程序在加载时间和 SEO 方面有一些缺点。因为它们依赖客户端在页面之后呈现内容，并且所有依赖项都被加载，需要多次服务器往返才能完全呈现。在实践中，这意味着加载时间的延迟，这本身就会对网站的 SEO 产生负面影响。

此外，搜索引擎对执行 JavaScript 作为其索引的一部分的支持程度各不相同。例如，Google 确实执行 JavaScript，但是是在一个单独的第二阶段，这个阶段可能发生在初始索引之后的几个小时或几个星期。如果您生成了新内容或者您的内容频繁更改，它将不会被及时编入索引。

使用 SSR+，页面完全在后端呈现，只需一个 HTTP 请求，无需执行 JavaScript。这对用户体验和 SEO 都有很大的好处。尽管许多 JavaScript 框架确实支持同构渲染作为一种解决方案，但 SSR+根本不存在这个问题，因为所有的渲染都是从后端开箱即用完成的。

# SSR+的挑战

尽管有这些好处，服务器渲染的应用并不适合每一种使用情况。以下是你在用 SSR+方法开发应用时可能会面临的一些挑战。

## 没有脱机功能

一些 JavaScript 应用程序被设计为支持用户可能长时间无法访问互联网的情况。例如，这些应用程序使用 localStorage 来允许用户在没有网络连接的情况下访问/编辑数据。

不言而喻，服务器呈现的 HTML 不适合这类应用程序。然而，具有强大离线支持的应用程序是例外，而不是规则:*大多数*传统的 JavaScript 前端无论如何都不支持离线访问，所以一般来说，这不是问题。

## 网络连接性差和延迟问题

这与前一点有关，但代表了一个更常见的场景:当网络连接不良时，SSR+应用程序的性能会受到影响，因为服务器无法及时向客户端推送更新。

更糟糕的是，如果网络连接暂时中断，应用程序可能会完全没有反应。这听起来令人担忧，但不一定比典型的 JavaScript 驱动的前端差很多:如果后端不可用，大多数单页 JS 应用程序也不会正常工作。然而，一个典型的单页 JS 应用程序可能*会*做得更好的是，在网络不可用时显示更好的消息和 UI。类似 spinners 和错误消息这样的东西对改善用户体验大有帮助，即使什么都不工作。

减轻服务器呈现的 HTML 的这个问题的一个方法是使用前面提到的 JavaScript 钩子来处理这些离线场景。在 SSR+应用程序中，显示连接状态指示器或警告对话框是处理网络连接边缘情况的有效方式。

## 实时互动和动画

尽管服务器渲染 HTML 的性能令人印象深刻，但对于繁重的交互和动画(例如，每秒 30+帧的视觉更新)来说，它不是最佳选择。幸运的是，CSS 动画与服务器呈现的 HTML 方法配合得非常好——通过操纵元素上的类名，您可以为大多数交互触发 CSS 动画。对于那些无法用 CSS 实现的动画，您可以使用有针对性的 JavaScript 挂钩——只要能够实现想要的效果，同时保持核心应用程序逻辑在服务器端。

## 前端集成和浏览器 API

如果您的应用程序需要直接访问浏览器 API，您只需使用前端 JavaScript。在大多数情况下，SSR+框架的 JavaScript 互操作性将使您能够访问您需要的功能。但是如果您大量使用这些 API，在某种程度上，您可能会发现自己在与服务器呈现的范式作斗争，并且使用完全基于客户端的 JS 方法可能会更好。

## 服务器负载和可扩展性

传统客户机/服务器方法的一个好处是，您可以有效地将大量的处理任务卸载给客户机。对于服务器呈现的 HTML，这个成本是由服务器支付的——页面上每一个有意义的 DOM 更新都需要服务器将更新推送到客户端。随着客户端数量的增加，负载也会增加。

这是一个多大的问题将完全取决于您的应用程序的复杂性。不要想当然地认为性能会比 API 驱动的方法差很多:毕竟，处理 API 请求、呈现为 XML 或 JSON，然后在客户机上格式化都是开销很大的操作，所以跳过几个步骤，在服务器上直接呈现为 HTML 不一定会更差。请注意负载增加的可能性，并进行相应的监控。

# 你的下一个项目应该使用哪种方法？

不要带着 SSR+服务器呈现的 HTML 是每个项目的最佳选择的印象离开本文——事实并非如此。我仍然每天使用 JavaScript，最近选择 React 作为一个项目的前端，因为我认为它比 LiveView 更适合。与每个工程决策一样，在使用 SSR+和传统的 JavaScript 驱动的前端之间的选择伴随着许多权衡。在设计你的应用程序时，考虑这些权衡——考虑你希望你的应用程序如何运行，以及你想在哪里投入时间。

即使 SSR+对你现在正在做的项目来说不是正确的方法，我也会鼓励你留意尝试的机会，只是为了更多地了解它是如何工作的，并获得权衡的直觉。无论现在是否最终使用 SSR+,这都是 web 架构发展中一个非常有趣的发展，值得关注。

*原载于* [*Blixtdev*](https://blixtdev.com/why-your-next-frontend-might-be-the-backend/) *。*

*Jonathan 在大型和小型创业公司中拥有超过 20 年的工程领导经验。*