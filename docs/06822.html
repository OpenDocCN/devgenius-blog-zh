<html>
<head>
<title>A Curious Tale of Late Initialisation Options — Part II</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一个关于后期初始化选项的奇怪故事——第二部分</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/a-curious-tale-of-late-initialisation-options-part-ii-339a85e08961?source=collection_archive---------16-----------------------#2022-02-05">https://blog.devgenius.io/a-curious-tale-of-late-initialisation-options-part-ii-339a85e08961?source=collection_archive---------16-----------------------#2022-02-05</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="8fa5" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">使用 Kotlin 的后期初始化选项导航内存泄漏和线程安全</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/85f730856adf9ea5b811e32dfc274cdd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DqWj88I1k5wP2cqS"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated"><a class="ae ks" href="https://unsplash.com/@jeremybezanger?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">杰里米·贝赞格</a>在<a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="fc53" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在<a class="ae ks" href="https://bendaniel10.medium.com/a-curious-tale-of-late-initialisation-options-part-i-44da6ca94068" rel="noopener">第一部分</a>中，我们在使用完一个<code class="fe lp lq lr ls b">Behaviour</code>之后成功地清理了我们的资源。</p><p id="0ca5" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">选择的解决方案使我使一个属性可空，即使我觉得它不应该是空的。</p><blockquote class="lt lu lv"><p id="7fdd" class="kt ku lw kv b kw kx jo ky kz la jr lb lx ld le lf ly lh li lj lz ll lm ln lo ig bi translated">我想知道为什么我需要这样做，当我确信只要我调用了<code class="fe lp lq lr ls b">onAttach(Item)</code>，那么<code class="fe lp lq lr ls b">item</code>的值就永远不会是<code class="fe lp lq lr ls b">null</code>。</p></blockquote><p id="cf0f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">但是这总是真的吗🤔？</p><h2 id="c03a" class="ma mb in bd mc md me dn mf mg mh dp mi lc mj mk ml lg mm mn mo lk mp mq mr ms bi translated">捕捉:多线程</h2><p id="c78c" class="pw-post-body-paragraph kt ku in kv b kw mt jo ky kz mu jr lb lc mv le lf lg mw li lj lk mx lm ln lo ig bi translated">多线程使事情变得复杂。大多数被认为写得很好的代码，一旦被放到多线程环境中，就会暴露出它们的弱点。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="my mz l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">我完全同意</figcaption></figure><p id="d663" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们把我的代码放到一个多线程环境中，看看它的表现如何。</p><p id="f65e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我已经更新了下面的代码片段。我假设必须在<code class="fe lp lq lr ls b">onAttach(item)</code>方法中进行异步 API 调用。这个 API 调用完成后，将调用<code class="fe lp lq lr ls b">echo()</code>方法。以下是更新后的代码:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="na mz l"/></div></figure><p id="b142" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这里，我使用了 Kotlin 提供的<code class="fe lp lq lr ls b">thread { }</code> util 函数。它也会自动启动<code class="fe lp lq lr ls b">Thread</code>。为了简洁起见，我使用了线程。还有其他推荐的方法，比如使用<a class="ae ks" href="https://kotlinlang.org/docs/coroutines-overview.html" rel="noopener ugc nofollow" target="_blank"> Kotlin 协程</a>、<a class="ae ks" href="https://github.com/ReactiveX/RxJava" rel="noopener ugc nofollow" target="_blank"> RxJava </a>等。</p><p id="ca28" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">使用与第一部分相同的参数运行更新后的代码，结果如下:</p><pre class="kd ke kf kg gt nb ls nc nd aw ne bi"><span id="62a9" class="ma mb in ls b gy nf ng l nh ni">Detaching null<br/>Attaching, null</span></pre><p id="69a3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们看一下与最近的代码更新相关的产生这个输出的代码，以便我们能够理解发生了什么。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="na mz l"/></div></figure><p id="21c6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果你按照代码的逻辑流程。您将看到为什么在<code class="fe lp lq lr ls b">echo()</code>方法调用期间<code class="fe lp lq lr ls b">item.name</code>的值是<code class="fe lp lq lr ls b">null</code>。<code class="fe lp lq lr ls b">behaviour.onAttach(item)</code>方法调用立即返回，不久之后<code class="fe lp lq lr ls b">behaviour.onDetach()</code>方法调用被执行。</p><p id="b79e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这是可能的，因为<code class="fe lp lq lr ls b">apiCall(then)</code>方法以异步方式运行。此外，由于该方法上发生的长时间操作，<code class="fe lp lq lr ls b">onDetach()</code>能够在执行<code class="fe lp lq lr ls b">echo()</code>函数之前完成并清理资源。</p><p id="f83d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在我们已经看到了<code class="fe lp lq lr ls b">item</code>属性如何可能处于空状态。我们如何解决这个问题？</p><h2 id="6eb8" class="ma mb in bd mc md me dn mf mg mh dp mi lc mj mk ml lg mm mn mo lk mp mq mr ms bi translated">解决方案三:抱歉打扰了</h2><p id="910e" class="pw-post-body-paragraph kt ku in kv b kw mt jo ky kz mu jr lb lc mv le lf lg mw li lj lk mx lm ln lo ig bi translated">一种简单的方法是将创建的线程保存在一个可空属性中，然后在调用<code class="fe lp lq lr ls b">onDetach()</code>方法时中断它。这样，在调用了<code class="fe lp lq lr ls b">onDetach()</code>之后，将不会执行<code class="fe lp lq lr ls b">echo()</code>方法。让我们检查一下更新后的代码:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="na mz l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">apiCall(then)现在必须捕获“InterruptedExecption ”,因为它的线程在第 12 行被中断。</figcaption></figure><p id="1ee8" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">运行它的输出变成:</p><pre class="kd ke kf kg gt nb ls nc nd aw ne bi"><span id="7a18" class="ma mb in ls b gy nf ng l nh ni">Detaching null<br/>interrupted. fun ...echo()... not called.</span></pre><p id="71ea" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这么🎉。这个解决方案工作得很好，因为在调用了<code class="fe lp lq lr ls b">onDetach()</code>方法之后，我们不再关心<code class="fe lp lq lr ls b">apiCall(then)</code>方法调用的结果。</p><h2 id="d83e" class="ma mb in bd mc md me dn mf mg mh dp mi lc mj mk ml lg mm mn mo lk mp mq mr ms bi translated">捕捉:线程安全、可重用性和 API 设计</h2><p id="b264" class="pw-post-body-paragraph kt ku in kv b kw mt jo ky kz mu jr lb lc mv le lf lg mw li lj lk mx lm ln lo ig bi translated">不幸的是，我们的解决方案仍然不能很好地工作。其他开发人员抱怨说，即使在发生了<code class="fe lp lq lr ls b">onDetach()</code>之后，仍在调用<code class="fe lp lq lr ls b">echo()</code>方法。他们还说，没有办法将<code class="fe lp lq lr ls b">Behaviour</code>从单个项目上拆下来。</p><p id="7ce1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们更新我们的<code class="fe lp lq lr ls b">main</code>函数来理解他们的请求。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="na mz l"/></div></figure><p id="5845" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">你可以很快发现第二个请求是有意义的。我们需要一种方法将<code class="fe lp lq lr ls b">Behaviour</code>从单个项目中分离出来。然而，我不认为他们对第一种选择是正确的。让我们运行代码，看看会发生什么。</p><pre class="kd ke kf kg gt nb ls nc nd aw ne bi"><span id="259f" class="ma mb in ls b gy nf ng l nh ni">Detaching null<br/>Interrupted, fun ...echo()... not called.<br/>Attaching, null</span></pre><p id="436f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">呃，什么？为什么会这样？我可以发誓<code class="fe lp lq lr ls b">onDetach()</code>方法会恰当地处理这种情况。也许我们应该仔细看看。让我们用更多的日志来丰富代码，以了解正在发生的事情。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="na mz l"/></div></figure><p id="d9db" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在我们将能够看到哪个线程正在运行<code class="fe lp lq lr ls b">onDetach()</code>、<code class="fe lp lq lr ls b">echo()</code>和<code class="fe lp lq lr ls b">apiCall(then)</code>方法中的不同操作。这是显示新日志的输出:</p><pre class="kd ke kf kg gt nb ls nc nd aw ne bi"><span id="9833" class="ma mb in ls b gy nf ng l nh ni">Detaching null from main, interrupted Thread-1<br/>Calling API for null from Thread-0<br/>Calling API for null from Thread-1<br/>Interrupted, fun ...echo()... not called from Thread-1<br/>Attaching, null from Thread-0</span></pre><p id="5944" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">啊哈！问题就在这里。你能看见它吗？<code class="fe lp lq lr ls b">Thread-0</code>没有线程中断。你可以看到，每当执行<code class="fe lp lq lr ls b">apiCall(then)</code>时，<code class="fe lp lq lr ls b">apiCallThread</code>总是会被覆盖。因此，<code class="fe lp lq lr ls b">onDetach()</code>方法只会中断最后一次存储的<code class="fe lp lq lr ls b">apiCallThread</code>。</p><p id="1430" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">另外，请注意，输出的第 2 行和第 3 行不再记得<code class="fe lp lq lr ls b">item</code>，因为它们已经被分离。当然，接口及其实现并不像我们希望的那样好。</p><pre class="kd ke kf kg gt nb ls nc nd aw ne bi"><span id="d1e3" class="ma mb in ls b gy nf ng l nh ni">...<br/>Calling API for null from Thread-0<br/>Calling API for null from Thread-1<br/>...</span></pre><p id="0ff3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这是一个问题。</p><p id="29b2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们进入<a class="ae ks" href="https://bendaniel10.medium.com/a-curious-tale-of-late-initialisation-options-part-iii-e92d9f2abd79" rel="noopener">的最后一部分</a>，看看最新的解决方案。</p></div></div>    
</body>
</html>