<html>
<head>
<title>Road to Genius: advanced #33</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">天才之路:进阶#33</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/road-to-genius-advanced-33-6b520eac8c48?source=collection_archive---------37-----------------------#2020-07-15">https://blog.devgenius.io/road-to-genius-advanced-33-6b520eac8c48?source=collection_archive---------37-----------------------#2020-07-15</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/0679b6e04d1f8c1a02481fae5a7cdf83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*9SdHGQ_4FzZ7Lc-k.png"/></div></div></figure><p id="8c5d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">每天我都要解决几个Codr分级模式的编码挑战和难题。目标是达到天才的等级，在这个过程中我解释了我是如何解决这些问题的。你不需要任何编程背景就可以开始，而且你会学到很多新的有趣的东西。</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="1cdc" class="lc ld in ky b gy le lf l lg lh">function LRU(capacity) {<br/>  this.cache = {};<br/>  this.capacity = capacity;<br/>  this.size = 0;<br/>  this.queue = [];<br/>}<br/>;<br/>LRU.prototype.get = function (key) {<br/>  const hit = this.cache[key];<br/>  if (hit !== undefined) {<br/>    this.queue = this.queue.filter(q =&gt; 🐼 !== key);<br/>    this.queue.push(key);<br/>    return hit;<br/>  }<br/>  return -1;<br/>};<br/>LRU.prototype.put = function (key, value) {<br/>  const hit = this.cache[key];<br/>  this.cache[key] = value;<br/>  if (!hit) {<br/>    if (this.size === this.capacity) {<br/>      const key = this.queue.shift();<br/>      this.cache[key] = undefined;<br/>    } else {<br/>      this.size = this.size + 1;<br/>    }<br/>    this.queue.push(😈);<br/>  } else {<br/>    this.queue = this.queue.filter(q =&gt; q !== key);<br/>    this.queue.push(key);<br/>  }<br/>};<br/>let cache = new LRU(7);<br/>for (let i = 0; i &lt; 4; i++)<br/>  cache.put(i, i);<br/>let A = cache.queue.length;</span><span id="bc07" class="lc ld in ky b gy li lf l lg lh">// 🐼 = ? (identifier)<br/>// 😈 = ? (identifier)<br/>// such that A = 4 (number)</span></pre><p id="641d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在今天的挑战中，我们需要修复一个相对较大的代码库中的两个bug。简单看一下这两个bug之后，这将是一个简单的任务，所以让我们开始吧。</p><p id="e2a3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">第一个bug出现在下面一行:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="78fc" class="lc ld in ky b gy le lf l lg lh">this.queue = this.queue.filter(q =&gt; 🐼 !== key);</span></pre><p id="221c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一个过滤箭头函数被应用于<code class="fe lj lk ll ky b">queue</code>数组。它基本上通过过滤掉满足arrow-function定义的标准的所有项目来改变<code class="fe lj lk ll ky b">queue</code>的值。这一行代码可以总结为伪代码:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="1c57" class="lc ld in ky b gy le lf l lg lh">queue = queue.filter(<br/>  for each item "q" in "queue":<br/>     if 🐼 !== key:<br/>       return true<br/>     else:<br/>       return false<br/>)</span></pre><p id="34ee" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这段代码所做的就是从队列中移除所有等于<code class="fe lj lk ll ky b">key</code>的项目；换句话说，保留所有不等于<code class="fe lj lk ll ky b">key</code>的项目。<br/>如你所见，这个bug🐼必须是<code class="fe lj lk ll ky b">q</code>。</p><p id="2d95" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">修复第二个也是最后一个错误😈我们需要分析更多的代码:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="2caa" class="lc ld in ky b gy le lf l lg lh">if (!hit) {<br/>  if (this.size === this.capacity) {<br/>    const key = this.queue.shift();<br/>    this.cache[key] = undefined;<br/>  } else {<br/>    this.size = this.size + 1;<br/>  }<br/>  this.queue.push(😈);<br/>} else {<br/>  this.queue = this.queue.filter(q =&gt; q !== key);<br/>  this.queue.push(key);<br/>}</span></pre><p id="66d2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">虫子😈必须是一个变量名，也就是被推送到<code class="fe lj lk ll ky b">queue</code>数组的东西。else子句已经揭示了这将是什么:<code class="fe lj lk ll ky b">key</code>。</p><figure class="kt ku kv kw gt jo gh gi paragraph-image"><div class="gh gi lm"><img src="../Images/2974d38523f21034358837df5f1ce3c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:462/format:webp/0*yoVRN7dsMRJX19c1.png"/></div></figure><p id="5ed3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果您对更大的图片感兴趣，这段代码是一个LRU缓存系统的简单实现(最近最少使用)。</p><p id="296d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">通过解决这些挑战，你可以训练自己成为一名更好的程序员。您将学到更新更好的分析、调试和改进代码的方法。因此，你在商业上会更有效率和价值。在<a class="ae ln" href="https://nevolin.be/codr/" rel="noopener ugc nofollow" target="_blank">https://nevolin.be/codr/</a>加入我的天才之路，提升你的编程技能</p></div></div>    
</body>
</html>