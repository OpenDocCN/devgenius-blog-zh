<html>
<head>
<title>LeetCode 108. Convert Sorted Array to Binary Search Tree (solution with images)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">LeetCode 108。将排序后的数组转换为二叉查找树(带图像的解决方案)</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/leetcode-108-convert-sorted-array-to-binary-search-tree-solution-with-images-f34354fe6299?source=collection_archive---------5-----------------------#2022-08-17">https://blog.devgenius.io/leetcode-108-convert-sorted-array-to-binary-search-tree-solution-with-images-f34354fe6299?source=collection_archive---------5-----------------------#2022-08-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><h1 id="d4de" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">问题:→</h1><p id="9214" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">给定一个整数数组<code class="fe lj lk ll lm b">nums</code>，其中的元素按<strong class="kn ir">升序</strong>排序，将<em class="ln">转换成一个</em> <strong class="kn ir"> <em class="ln">高度平衡的</em> </strong> <em class="ln">二叉查找树</em>。</p><p id="4804" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">高度平衡的二叉树是这样一种二叉树，其中每个节点的两个子树的深度相差不超过 1。</p><p id="46dd" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated"><strong class="kn ir">例 1: </strong></p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/96814b6faa667ee58791f563bd73e4cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:604/format:webp/0*-ilpyFtnGGqi1faP.jpg"/></div></figure><pre class="lu lv lw lx gt mb lm mc md aw me bi"><span id="4e90" class="mf jo iq lm b gy mg mh l mi mj"><strong class="lm ir">Input:</strong> nums = [-10,-3,0,5,9]<br/><strong class="lm ir">Output:</strong> [0,-3,9,-10,null,5]<br/><strong class="lm ir">Explanation:</strong> [0,-10,5,null,-3,null,9] is also accepted:</span></pre><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/749bd50be7c60a22ac3b9b418f53664b.png" data-original-src="https://miro.medium.com/v2/resize:fit:604/format:webp/0*FtKEGqykCaTyOnds.jpg"/></div></figure><p id="1cee" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated"><strong class="kn ir">例 2: </strong></p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/7b6cbf492b095d09736e4f2e6db22a51.png" data-original-src="https://miro.medium.com/v2/resize:fit:684/format:webp/0*ZquvU19vxLATIa9W.jpg"/></div></figure><pre class="lu lv lw lx gt mb lm mc md aw me bi"><span id="0277" class="mf jo iq lm b gy mg mh l mi mj"><strong class="lm ir">Input:</strong> nums = [1,3]<br/><strong class="lm ir">Output:</strong> [3,1]<br/><strong class="lm ir">Explanation:</strong> [1,null,3] and [3,1] are both height-balanced BSTs.</span></pre><p id="03ea" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated"><strong class="kn ir">约束:</strong></p><ul class=""><li id="2adc" class="ml mm iq kn b ko lo ks lp kw mn la mo le mp li mq mr ms mt bi translated"><code class="fe lj lk ll lm b">1 &lt;= nums.length &lt;= 104</code></li><li id="a438" class="ml mm iq kn b ko mu ks mv kw mw la mx le my li mq mr ms mt bi translated"><code class="fe lj lk ll lm b">-104 &lt;= nums[i] &lt;= 104</code></li><li id="4e64" class="ml mm iq kn b ko mu ks mv kw mw la mx le my li mq mr ms mt bi translated"><code class="fe lj lk ll lm b">nums</code>按照<strong class="kn ir">严格递增</strong>的顺序排序。</li></ul><h1 id="14e8" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">解决方案:→</h1><p id="71fb" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">让我们先了解一下什么是<strong class="kn ir">身高平衡二叉查找树？</strong></p><p id="3dab" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">→没有<strong class="kn ir">叶的树</strong>比其他任何<strong class="kn ir">叶</strong>离<strong class="kn ir">根</strong>远得多。</p><p id="dc45" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">下图显示了两棵树，一棵是高度平衡的，另一棵不是。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi mz"><img src="../Images/3f3d81b685a58062075263e345cee8d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dOyQITQG-w55Yb3I2ztvTQ.png"/></div></div></figure><p id="4ff0" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated"><strong class="kn ir">第一棵树</strong>被认为是<strong class="kn ir">高度平衡树</strong>，因为左子树只比<strong class="kn ir">右子树的<strong class="kn ir">高度</strong>多<strong class="kn ir"> 1。</strong></strong></p><p id="7b4f" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated"><strong class="kn ir">第二棵树</strong>没有<strong class="kn ir">高度平衡</strong>因为左子树<strong class="kn ir"> 2 </strong>的高度比<strong class="kn ir">右子树</strong>的<strong class="kn ir">高。</strong></p><p id="8536" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">在理解了高度平衡树之后，让我们来理解如何将数组转换成高度平衡树。</p><h1 id="50da" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">解决方案:→</h1><p id="9166" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">一般来说，我们可以通过以下方式将给定的排序后的整数数组转换成高度平衡的<strong class="kn ir"><em class="ln"/></strong><em class="ln">二叉查找树</em>。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi ne"><img src="../Images/edb0a538e3dae865ae94db9f7f107cf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LCcJCldsqi1XuPrqGOT6CQ.png"/></div></div></figure><p id="7380" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">现在，让我们用代码来理解，</p><p id="7b00" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">我们将继续用<strong class="kn ir">二分搜索法</strong>中的<strong class="kn ir">递归方式</strong>，就在这里，排序后的数组被给出。</p><p id="27ec" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">首先，我们需要找到<strong class="kn ir">根节点</strong>，根节点将是<strong class="kn ir">中间元素</strong>，其中作为其值的<strong class="kn ir">左节点</strong>将比中间节点低<strong class="kn ir">，而<strong class="kn ir">右节点</strong>的值将比根节点</strong>大<strong class="kn ir">。</strong></p><p id="0f87" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">为了找到中间值，我们将使用下面公式:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/671341a47e567cfc325d55aecc503881.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*DK_I7-6iPZaRRCx_AGHxmQ.png"/></div></figure><p id="3736" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">如果你想明白为什么我们<strong class="kn ir">不应该</strong>使用<strong class="kn ir"> mid = (start+ end)/2 </strong>，你应该<a class="ae ng" rel="noopener ugc nofollow" target="_blank" href="/avoid-this-thing-while-calculating-mid-value-in-data-structures-73d834ed5fb8">点击这里</a>。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi nh"><img src="../Images/4d03d6162f4761ad7d3160cbfcfdb2a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D5L0rUUwN05ti60u8WsCQg.png"/></div></div></figure><p id="e5b1" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">现在，我们将创建新的<strong class="kn ir"> TreeNode </strong>，在这里我们将为一个<strong class="kn ir">节点赋值 5 </strong>。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/bab212411e53a6327e139f5df3cf6add.png" data-original-src="https://miro.medium.com/v2/resize:fit:636/format:webp/1*Yjj2XnfXkPadlI112cVg7g.png"/></div></figure><p id="0b08" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">现在，我们用数组的左边部分调用<strong class="kn ir"> createBST </strong>。</p><p id="513a" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">这里<strong class="kn ir"> start = 0，end =(mid—1)=(3–1)= 2</strong></p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi nj"><img src="../Images/8e16995d9755836d5d672fe7fb419183.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jeZH6vrv_ZEwyW3qv9kc4A.png"/></div></div></figure><p id="c91f" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">这里，对于每个递归调用，将为下面的<strong class="kn ir">右节点</strong>创建堆栈，它存储值，如下所示。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/a20610d81395b52044f77a01876c4052.png" data-original-src="https://miro.medium.com/v2/resize:fit:1140/format:webp/1*LapMuosfGcqLfTr_BG_WfQ.png"/></div></figure><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/698c0c35e5df9f96349f5262028c386e.png" data-original-src="https://miro.medium.com/v2/resize:fit:514/format:webp/1*IX1TIcaJ942s7A65G1jkGg.png"/></div></figure><p id="774c" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">同样，我们将计算中间值并创建新的<strong class="kn ir"> TreeNode </strong>，</p><p id="1869" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">这里<strong class="kn ir">mid =(start+(end-start)/2)=(0+(2–0)/2)=(0+1)= 1。</strong></p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi nm"><img src="../Images/438bf370ab2c6480155911ff08e3ace8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zNkAbOoTdGtE-ra4hygIKA.png"/></div></div></figure><p id="1ff5" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">新创建的节点将被分配到树的左侧节点。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/e5917fb55d604cd633a3b9aa8cdc4605.png" data-original-src="https://miro.medium.com/v2/resize:fit:888/format:webp/1*NAzRHvV1tzpeRaSwIFU8dA.png"/></div></figure><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi no"><img src="../Images/324b9a7f6c7e4d7e2550ad51f17c62ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:588/format:webp/1*dkHJ7t3GQq2fKTSsDxPH6A.png"/></div></figure><p id="e87e" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">现在，对于第二次递归调用，再次将值追加到堆栈中。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/a20610d81395b52044f77a01876c4052.png" data-original-src="https://miro.medium.com/v2/resize:fit:1140/format:webp/1*LapMuosfGcqLfTr_BG_WfQ.png"/></div></figure><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi np"><img src="../Images/238781cbcaf5abed60cfb00807c14835.png" data-original-src="https://miro.medium.com/v2/resize:fit:446/format:webp/1*rAvSt1Ylfwfhp3-DbikTgw.png"/></div></figure><p id="30ac" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">同样，我们用数组的左边部分做递归调用，</p><p id="966d" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">这里<strong class="kn ir"> start = 0 </strong>，<strong class="kn ir">end =(mid—1)=(2–1)= 1</strong></p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi nq"><img src="../Images/7b0a6adf8a1b83f095ae8e13e404fcf8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B4kXRWGy2T6uU49lSk3sCA.png"/></div></div></figure><p id="82c2" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">同样，我们将计算中间值并创建新的<strong class="kn ir"> TreeNode </strong>，</p><p id="4f24" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">这里<strong class="kn ir">mid =(start+(end-start)/2)=(0+(1–0)/2)=(0+0)= 0。</strong></p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi nr"><img src="../Images/535406afaab8197c5085196e0ba63c46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u0QS0NIk5kQ5zLYHHEgePQ.png"/></div></div></figure><p id="5d3c" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">新创建的<strong class="kn ir">节点</strong>，将被分配到树的<strong class="kn ir">左侧节点</strong>。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/e5917fb55d604cd633a3b9aa8cdc4605.png" data-original-src="https://miro.medium.com/v2/resize:fit:888/format:webp/1*NAzRHvV1tzpeRaSwIFU8dA.png"/></div></figure><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/dbb2dd17f0a61d39a8c875d3f4666e95.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/format:webp/1*vJqXeSfXs2984NtmT78RMQ.png"/></div></figure><p id="662e" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">对于第三次递归调用，该值也被追加到堆栈中。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/a20610d81395b52044f77a01876c4052.png" data-original-src="https://miro.medium.com/v2/resize:fit:1140/format:webp/1*LapMuosfGcqLfTr_BG_WfQ.png"/></div></figure><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/b22ee73c1862beba7e84f125b97c6d48.png" data-original-src="https://miro.medium.com/v2/resize:fit:416/format:webp/1*AnUnFdlkCWiYP83V6HhhuQ.png"/></div></figure><p id="64eb" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">这里<strong class="kn ir"> start = 0 </strong>但是现在，<strong class="kn ir"> end = &gt; mid -1 = &gt; -1。</strong></p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/eb1a3b6fd5ef20d8d4a43598de09c511.png" data-original-src="https://miro.medium.com/v2/resize:fit:632/format:webp/1*tRQot54lLmp3LMhTR4crxw.png"/></div></figure><p id="fb05" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">因此，最后，<strong class="kn ir">左节点</strong>将为<strong class="kn ir">空，</strong>因此<strong class="kn ir">递归堆栈</strong>将不会被<strong class="kn ir">追加</strong>。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/d5f0fd77616e005967a0681385e79e89.png" data-original-src="https://miro.medium.com/v2/resize:fit:626/format:webp/1*Os-rX1rIsjhdGazZLXlx5g.png"/></div></figure><p id="c478" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">现在，<strong class="kn ir">反向过程</strong>将开始，并且<strong class="kn ir">值</strong>将从<strong class="kn ir">递归堆栈中<strong class="kn ir">移除</strong>。</strong></p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/5586a2fb60483ad260f81afc2120e158.png" data-original-src="https://miro.medium.com/v2/resize:fit:912/format:webp/1*jIpqTb-YpBEnYwVlu9rERw.png"/></div></figure><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/a20610d81395b52044f77a01876c4052.png" data-original-src="https://miro.medium.com/v2/resize:fit:1140/format:webp/1*LapMuosfGcqLfTr_BG_WfQ.png"/></div></figure><p id="d464" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">这里，<strong class="kn ir"> start = (mid + 1) = (0+1) = 1。</strong>和<strong class="kn ir"> end = 0。</strong></p><p id="864c" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">再次低于条件将返回<strong class="kn ir"> null。</strong></p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/eb1a3b6fd5ef20d8d4a43598de09c511.png" data-original-src="https://miro.medium.com/v2/resize:fit:632/format:webp/1*tRQot54lLmp3LMhTR4crxw.png"/></div></figure><p id="75bf" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">所以，最后，<strong class="kn ir">右节点</strong>将为<strong class="kn ir">空</strong>。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/680b5d574815ed051ef5d13c1fffb8f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:742/format:webp/1*SHj9A3NN6PoUnfKhul2HVQ.png"/></div></figure><p id="335f" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">在下一个<strong class="kn ir">右侧<strong class="kn ir">的反向过程</strong>中，</strong>再次<strong class="kn ir">值</strong>将从<strong class="kn ir">递归堆栈中<strong class="kn ir">移除</strong>。</strong></p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/5968b2b43f0471cc5f63c9709e40bc21.png" data-original-src="https://miro.medium.com/v2/resize:fit:902/format:webp/1*_7BYlSh26vtWh4jVzI3ryw.png"/></div></figure><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/a20610d81395b52044f77a01876c4052.png" data-original-src="https://miro.medium.com/v2/resize:fit:1140/format:webp/1*LapMuosfGcqLfTr_BG_WfQ.png"/></div></figure><p id="825f" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">现在，再次递归调用右侧的<strong class="kn ir">。</strong></p><p id="e7d8" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">这里，<strong class="kn ir"> start = (1+ 1) = (1+1) = 2。</strong>和<strong class="kn ir"> end = 2。</strong></p><p id="664b" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">所以，下面的条件将变成<strong class="kn ir">假</strong>。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/eb1a3b6fd5ef20d8d4a43598de09c511.png" data-original-src="https://miro.medium.com/v2/resize:fit:632/format:webp/1*tRQot54lLmp3LMhTR4crxw.png"/></div></figure><p id="582e" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">但是，在下一行，</p><p id="e638" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated"><strong class="kn ir">mid =(2+(2–2))/2 = 2/2 = 1</strong></p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/8f23f6b97fed4e58d4323638af0e1611.png" data-original-src="https://miro.medium.com/v2/resize:fit:1048/format:webp/1*nAFEO_A7z8EzHvdj7GbVeA.png"/></div></figure><p id="9fb0" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">在一个<strong class="kn ir">栈</strong>中，它被追加，</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/efafa61816548c97690c9997d29036dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:458/format:webp/1*RUdTFbJBzHlSWu-PU_Nv-g.png"/></div></figure><p id="b6ff" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">而对于下一行，对于<strong class="kn ir"> TreeNode (1)，</strong>它的<strong class="kn ir">右节点</strong>的值将是，</p><p id="f4e4" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated"><strong class="kn ir">mid = start+(end-start)/2 =&gt;2+(2–2)/2 =&gt;2</strong></p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi ob"><img src="../Images/4f0762bb27f08aedca15fb49fb253603.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DF9jyvCKxZrSqGvgfCriDQ.png"/></div></div></figure><p id="9143" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">并且结果<strong class="kn ir"> Treenode </strong>将是，</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/26a96b450a31d8a49f0355e2b7c7f9a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:714/format:webp/1*yqGRTV21--8K7pjHblt5FQ.png"/></div></figure><p id="1915" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">现在，再次调用函数<strong class="kn ir"> createBST </strong>，该值将被添加到堆栈中。</p><p id="0557" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated"><strong class="kn ir">开始= (mid + 1) = (2+1) = 3，结束= 2 </strong></p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi od"><img src="../Images/06c7a9f1004935e5e05a805378a9270a.png" data-original-src="https://miro.medium.com/v2/resize:fit:468/format:webp/1*raxRvFmrwJl7TYDYQ9_BIA.png"/></div></figure><p id="c0e7" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">现在，对于相反的过程，</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/53427e68e2b4d4dd4357926bfe73bdb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:842/format:webp/1*6bHCeab23enZduHZGQ2Jwg.png"/></div></figure><p id="cb55" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">这里，<strong class="kn ir"> start = 3。</strong>和<strong class="kn ir"> end = 2。</strong>以下条件将返回<strong class="kn ir">空值。</strong></p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/eb1a3b6fd5ef20d8d4a43598de09c511.png" data-original-src="https://miro.medium.com/v2/resize:fit:632/format:webp/1*tRQot54lLmp3LMhTR4crxw.png"/></div></figure><p id="2ab9" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">所以，对于<strong class="kn ir"> TreeNode (1) </strong>右节点将为<strong class="kn ir"> NULL </strong></p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/a1cbd2db0380fee68f0269e67536b5ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:888/format:webp/1*aQc5SieypJpBjkbYgG9mfQ.png"/></div></figure><p id="e9ec" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">同样，对于相反的过程，</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi of"><img src="../Images/f19dc58e26cb7e6a42d9e4a93764155d.png" data-original-src="https://miro.medium.com/v2/resize:fit:934/format:webp/1*uVtxU_bMO_5mcuaOjpT8pQ.png"/></div></figure><p id="f86a" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">现在，对于<strong class="kn ir"> TreeNode (1) </strong>左节点将为<strong class="kn ir"> NULL </strong></p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi og"><img src="../Images/43fd7166b07cf9b02fcfe4feb84ad9e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:880/format:webp/1*ESNXy9a99xWuak5Pmd276g.png"/></div></figure><p id="bf30" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">现在，左边部分完成了，我们可以用右边部分理解同样的事情。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/f4ed6d196f5b900e55aa0687a261dacc.png" data-original-src="https://miro.medium.com/v2/resize:fit:742/format:webp/1*vyKWcIFwzg6t2oFqFjPlDw.png"/></div></figure><p id="99a0" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">现在，让我们看看完整的源代码。</p><h1 id="322e" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">代码(Java): →</h1><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="oh oi l"/></div></figure><h1 id="47d2" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">代码(Python): →</h1><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="oh oi l"/></div></figure><h1 id="ce01" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">时间复杂度</h1><p id="e743" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">这里，递归发生了两次，但是一次是针对左半部分的，另一次是针对右半部分的，所以总时间复杂度是<strong class="kn ir"> O(n) </strong>。</p><h1 id="45a9" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">空间复杂性</h1><p id="2a1a" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">既然我们使用了一个额外的队列，那么，空间复杂度将是 O(n)<strong class="kn ir">。</strong></p><p id="4c10" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">感谢你阅读这篇文章，❤</p><p id="2571" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">如果这篇文章对你有帮助，请鼓掌👏这篇文章。</p><p id="2fb9" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">请在<a class="ae ng" href="https://medium.com/@alexmurphyas8" rel="noopener">媒体</a>上关注我，我会像上面一样发布有用的信息。</p><p id="fbde" class="pw-post-body-paragraph kl km iq kn b ko lo kq kr ks lp ku kv kw lq ky kz la lr lc ld le ls lg lh li ij bi translated">如果我做错了什么？让我在评论中。我很想进步。</p></div></div>    
</body>
</html>