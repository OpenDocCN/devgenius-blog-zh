<html>
<head>
<title>Fundamental of Python Decorators and Importance of *args &amp; **kwargs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python Decorators 的基础和*args &amp; **kwargs 的重要性</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/fundamental-of-python-decorators-and-importance-of-args-kwargs-d36288c2058?source=collection_archive---------2-----------------------#2021-03-25">https://blog.devgenius.io/fundamental-of-python-decorators-and-importance-of-args-kwargs-d36288c2058?source=collection_archive---------2-----------------------#2021-03-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7aad" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">了解 Python decorators 的基础知识，并学习如何使用*args &amp; **kwargs 创建通用的 decorator。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/5fcca0c66c768c03e1c48bd39242851f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I1niUsn9uULABX169foX-A.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</figcaption></figure><p id="122a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">装饰器允许我们在 Python 函数中添加更多的功能。它被称为<strong class="kx ir">元编程</strong>，因为程序的一部分在编译时向程序的另一部分添加了一些东西。</p><blockquote class="lr ls lt"><p id="d470" class="kv kw lu kx b ky kz jr la lb lc ju ld lv lf lg lh lw lj lk ll lx ln lo lp lq ij bi translated">装饰器是 Python 中的一种设计模式，它允许用户向现有对象添加新功能，而无需修改其结构。装饰器通常在你想要装饰的函数定义之前被调用。</p><p id="1db8" class="kv kw lu kx b ky kz jr la lb lc ju ld lv lf lg lh lw lj lk ll lx ln lo lp lq ij bi translated">— <a class="ae ly" href="https://www.datacamp.com/community/tutorials/decorators-python" rel="noopener ugc nofollow" target="_blank"> Datacamp 对装饰者的</a>定义。</p></blockquote><p id="3f2b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">装饰器用在函数的顶部，以@符号开始。下面是使用装饰器的基本结构:</p><pre class="kg kh ki kj gt lz ma mb mc aw md bi"><span id="9d55" class="me mf iq ma b gy mg mh l mi mj">@decorator_name<br/>def function_name():<br/>    ...</span></pre><p id="b2c8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对 decorators 的理解很大程度上依赖于 python 中函数的一些特性。Python 中的函数是<strong class="kx ir">一等公民</strong>。这意味着…</p><ul class=""><li id="f700" class="mk ml iq kx b ky kz lb lc le mm li mn lm mo lq mp mq mr ms bi translated">我们可以传递一个函数作为另一个函数的参数。</li><li id="7bbf" class="mk ml iq kx b ky mt lb mu le mv li mw lm mx lq mp mq mr ms bi translated">将函数赋给变量。</li><li id="e38e" class="mk ml iq kx b ky mt lb mu le mv li mw lm mx lq mp mq mr ms bi translated">从另一个函数返回一个函数。换句话说，函数是<strong class="kx ir">的高阶</strong>。</li></ul><p id="1870" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这些是在深入装饰者之前需要理解的基本概念。先说说他们吧。</p></div><div class="ab cl my mz hu na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ij ik il im in"><h1 id="e91b" class="nf mf iq bd ng nh ni nj nk nl nm nn no jw np jx nq jz nr ka ns kc nt kd nu nv bi translated">作为另一个函数的参数的函数</h1><p id="6456" class="pw-post-body-paragraph kv kw iq kx b ky nw jr la lb nx ju ld le ny lg lh li nz lk ll lm oa lo lp lq ij bi translated">让我们创建一个函数，并将其作为另一个函数的参数传递。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="0840" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">输出:</strong></p><pre class="kg kh ki kj gt lz ma mb mc aw md bi"><span id="24a0" class="me mf iq ma b gy mg mh l mi mj">False</span></pre><p id="b241" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe od oe of ma b">even_or_odd()</code>函数检查一个数字是偶数还是奇数。我们将这个函数作为函数<code class="fe od oe of ma b">call_function()</code>的参数传递。</p></div><div class="ab cl my mz hu na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ij ik il im in"><h1 id="d400" class="nf mf iq bd ng nh ni nj nk nl nm nn no jw np jx nq jz nr ka ns kc nt kd nu nv bi translated">将函数赋给变量</h1><p id="c773" class="pw-post-body-paragraph kv kw iq kx b ky nw jr la lb nx ju ld le ny lg lh li nz lk ll lm oa lo lp lq ij bi translated">让我们像这样稍微修改一下代码…</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="fb57" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">输出:</p><pre class="kg kh ki kj gt lz ma mb mc aw md bi"><span id="0be4" class="me mf iq ma b gy mg mh l mi mj">False</span></pre><p id="673d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里我们将<code class="fe od oe of ma b">call_function()</code>赋给了变量<code class="fe od oe of ma b">result</code>。</p></div><div class="ab cl my mz hu na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ij ik il im in"><h1 id="78bf" class="nf mf iq bd ng nh ni nj nk nl nm nn no jw np jx nq jz nr ka ns kc nt kd nu nv bi translated">高阶函数</h1><p id="ee99" class="pw-post-body-paragraph kv kw iq kx b ky nw jr la lb nx ju ld le ny lg lh li nz lk ll lm oa lo lp lq ij bi translated">当一个函数可以返回另一个函数或者可以从另一个函数返回时，我们称这个函数为高阶函数。让我们来看一个例子。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="7ef3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这段代码将在控制台中打印<code class="fe od oe of ma b">Hello everyone!</code>。这里函数<code class="fe od oe of ma b">say_hello()</code>返回函数<code class="fe od oe of ma b">hello()</code>，从<code class="fe od oe of ma b">say_hello()</code>返回<code class="fe od oe of ma b">hello()</code>。所以都是高阶函数。</p></div><div class="ab cl my mz hu na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ij ik il im in"><h1 id="98b3" class="nf mf iq bd ng nh ni nj nk nl nm nn no jw np jx nq jz nr ka ns kc nt kd nu nv bi translated">创建装饰器</h1><p id="1cdc" class="pw-post-body-paragraph kv kw iq kx b ky nw jr la lb nx ju ld le ny lg lh li nz lk ll lm oa lo lp lq ij bi translated">现在我们已经理解了所有的先决条件，让我们创建我们自己的装饰器。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="d3d3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">输出:</p><pre class="kg kh ki kj gt lz ma mb mc aw md bi"><span id="585b" class="me mf iq ma b gy mg mh l mi mj">***************<br/>Hello everyone!<br/>***************</span></pre><p id="24c1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">看看<code class="fe od oe of ma b"> hello_decorator()</code>是如何改变<code class="fe od oe of ma b">hello()</code>功能的。只需将<code class="fe od oe of ma b">@hello_decorator</code>放在<code class="fe od oe of ma b">hello()</code>函数之前，我们就可以向该函数添加额外的功能。</p><p id="2706" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们也可以这样写:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="149e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这也会给我们同样的结果。所以我们可以看到，decorators 主要是在利用我们之前讨论过的函数的特性。功能是一等公民，它们是更高级的。</p><p id="87bc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在我们有了一个装饰器，可以根据需要在任意多的函数中使用。假设我们有另一个功能<code class="fe od oe of ma b">bye()</code>，我们想像以前一样装饰。我们只需要这样做:</p><pre class="kg kh ki kj gt lz ma mb mc aw md bi"><span id="6465" class="me mf iq ma b gy mg mh l mi mj">@hello_decorator<br/>def bye()"<br/>    print("Bye everyone!")</span></pre></div><div class="ab cl my mz hu na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ij ik il im in"><h1 id="a0ce" class="nf mf iq bd ng nh ni nj nk nl nm nn no jw np jx nq jz nr ka ns kc nt kd nu nv bi translated">用参数修饰函数</h1><p id="a567" class="pw-post-body-paragraph kv kw iq kx b ky nw jr la lb nx ju ld le ny lg lh li nz lk ll lm oa lo lp lq ij bi translated">如果我们想给一个带参数的函数添加一些功能，我们必须创建可以用参数装饰函数的装饰器。假设我们有一个函数，它把一个数作为参数，然后把它乘以 2。我们想要创建一个装饰器来告诉我们这个数字是奇数还是偶数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="a734" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">输出:</strong></p><pre class="kg kh ki kj gt lz ma mb mc aw md bi"><span id="e28f" class="me mf iq ma b gy mg mh l mi mj">The number was even<br/>20</span></pre><p id="49e1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了修饰接收参数的<code class="fe od oe of ma b">multiply_by_two()</code>，我们必须将参数传递给<code class="fe od oe of ma b">wrapper_func()</code>函数。</p></div><div class="ab cl my mz hu na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ij ik il im in"><h1 id="8948" class="nf mf iq bd ng nh ni nj nk nl nm nn no jw np jx nq jz nr ka ns kc nt kd nu nv bi translated">用多个参数装饰函数</h1><p id="4f2b" class="pw-post-body-paragraph kv kw iq kx b ky nw jr la lb nx ju ld le ny lg lh li nz lk ll lm oa lo lp lq ij bi translated">现在问题来了，如果一个函数接受不止一个参数，我们必须把它们一个接一个地传递给包装函数吗？还是有更高效的方法？这个问题会把我们引向<strong class="kx ir">通用装饰者</strong>的概念。我们也会明白<code class="fe od oe of ma b">*args</code> &amp; <code class="fe od oe of ma b">*kwargs</code>能为我们做什么。</p><h1 id="7574" class="nf mf iq bd ng nh og nj nk nl oh nn no jw oi jx nq jz oj ka ns kc ok kd nu nv bi translated">通用装饰器—使用*args &amp; **kwargs</h1><p id="b8fa" class="pw-post-body-paragraph kv kw iq kx b ky nw jr la lb nx ju ld le ny lg lh li nz lk ll lm oa lo lp lq ij bi translated">我们将编写一个接受三个数字作为参数的函数，并打印它们的和值。我们还将创建一个装饰器来显示数字。我们可以这样写代码。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="6267" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">输出:</p><pre class="kg kh ki kj gt lz ma mb mc aw md bi"><span id="afc7" class="me mf iq ma b gy mg mh l mi mj">The numbers were 1, 2 and 3<br/>Sum: 6</span></pre><p id="ddf2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是有更好的方法。让我想想…</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="507d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这也会给我们同样的结果。如果我们有另一个函数来打印 5 个数的和，<code class="fe od oe of ma b">@display_decorator</code>也将会处理这个函数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="d507" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">输出:</p><pre class="kg kh ki kj gt lz ma mb mc aw md bi"><span id="d033" class="me mf iq ma b gy mg mh l mi mj">The numbers were (1, 2, 3, 4, 5)<br/>Sum: 15</span></pre><p id="952c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">所以，使用<code class="fe od oe of ma b">*args</code> &amp; <code class="fe od oe of ma b">**kwargs</code>使<code class="fe od oe of ma b">displey_decorator()</code>成为一个通用的装饰器。</p><p id="3faf" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在 Python 中，我们有两种类型的参数，<strong class="kx ir">位置参数，</strong>和<strong class="kx ir">关键字参数</strong>。<code class="fe od oe of ma b">*args</code>和<code class="fe od oe of ma b">**kwargs</code>分别从我们的函数中收集所有的位置参数和关键字参数，并将它们存储在<code class="fe od oe of ma b">args</code>和<code class="fe od oe of ma b">kwargs</code>变量中。<code class="fe od oe of ma b">add_five_numbers()</code>函数有五个位置参数。<code class="fe od oe of ma b">*args</code>将它们存储在一个名为<code class="fe od oe of ma b">args</code>的变量中。这就是为什么我们能够通过写<code class="fe od oe of ma b">print(f’The numbers were {args}’)</code>来打印它们。</p><p id="e21a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在让我们看一个带有关键字参数的例子。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="71bc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">输出:</p><pre class="kg kh ki kj gt lz ma mb mc aw md bi"><span id="0ee1" class="me mf iq ma b gy mg mh l mi mj">Keyword arguments are: {‘n1’: ‘100’, ‘n2’: ‘200’}<br/>This function has two numbers as keyword arguments.</span></pre><p id="d1a2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">注意，如果我们在定义<code class="fe od oe of ma b">num()</code>时传递了关键字参数，那么它们将不会被存储，我们也不能打印它们。</p></div><div class="ab cl my mz hu na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ij ik il im in"><h1 id="93c0" class="nf mf iq bd ng nh ni nj nk nl nm nn no jw np jx nq jz nr ka ns kc nt kd nu nv bi translated">总结</h1><p id="0a93" class="pw-post-body-paragraph kv kw iq kx b ky nw jr la lb nx ju ld le ny lg lh li nz lk ll lm oa lo lp lq ij bi translated">借助<code class="fe od oe of ma b">*args</code> &amp; <code class="fe od oe of ma b">**kwargs</code>装修工成为通用目的。这样，如果我们在不同的函数中需要相同类型的装饰器，我们可以只写一个装饰器。所以我们可以这样概括装饰者的结构—</p><pre class="kg kh ki kj gt lz ma mb mc aw md bi"><span id="fcdd" class="me mf iq ma b gy mg mh l mi mj">def decorator_name(function):<br/>    def wrapper_function(*args, **kwargs):<br/>        # Put what the decorator will do here.......<br/>        function(*args, **kwargs)<br/>    return wrapper_function</span><span id="1e84" class="me mf iq ma b gy ol mh l mi mj">@decorator_name<br/>def function_name(arg1, arg2, arg3……)</span></pre><p id="101f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在 Python 中，创建我们自己的装饰器是一个非常强大的概念。也有许多内置的装饰器。像<code class="fe od oe of ma b">@classmethod</code>、<code class="fe od oe of ma b">@staticmethod</code>、<code class="fe od oe of ma b">@property</code>、<code class="fe od oe of ma b">@login_required</code>等等很多。这些内置的装饰器是 Python 语言的一部分。因此，我们可以使用它们在代码中添加许多重要的特性，而无需从头开始实现它们。</p><p id="ed17" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">希望这对你有帮助。感谢阅读。</p></div><div class="ab cl my mz hu na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ij ik il im in"><h1 id="c0a5" class="nf mf iq bd ng nh ni nj nk nl nm nn no jw np jx nq jz nr ka ns kc nt kd nu nv bi translated">一些有用的资源</h1><ul class=""><li id="5008" class="mk ml iq kx b ky nw lb nx le om li on lm oo lq mp mq mr ms bi translated"><a class="ae ly" href="https://python101.pythonlibrary.org/chapter25_decorators.html" rel="noopener ugc nofollow" target="_blank">装饰者——Python 101</a></li><li id="c74b" class="mk ml iq kx b ky mt lb mu le mv li mw lm mx lq mp mq mr ms bi translated"><a class="ae ly" href="https://www.datacamp.com/community/tutorials/decorators-python" rel="noopener ugc nofollow" target="_blank">Python-data camp 中的装饰者</a></li><li id="7c4b" class="mk ml iq kx b ky mt lb mu le mv li mw lm mx lq mp mq mr ms bi translated"><a class="ae ly" href="https://stackabuse.com/pythons-classmethod-and-staticmethod-explained/" rel="noopener ugc nofollow" target="_blank"> @classmethod 和@staticmethod —堆栈滥用</a></li><li id="0770" class="mk ml iq kx b ky mt lb mu le mv li mw lm mx lq mp mq mr ms bi translated"><a class="ae ly" href="https://realpython.com/primer-on-python-decorators/" rel="noopener ugc nofollow" target="_blank">Python 装饰者入门——真正的 Python </a></li></ul></div><div class="ab cl my mz hu na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ij ik il im in"><p id="cd14" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果你喜欢阅读这样的文章，考虑成为一个媒体成员。这样你就可以无限制地访问媒体上的所有故事。如果你使用我下面的推荐链接注册，我将从你每月 5 美元的费用中赚取一小笔佣金。这样你就可以支持我这个作家了。</p><div class="op oq gp gr or os"><a href="https://fahadulshadhin.medium.com/membership" rel="noopener follow" target="_blank"><div class="ot ab fo"><div class="ou ab ov cl cj ow"><h2 class="bd ir gy z fp ox fr fs oy fu fw ip bi translated">通过我的推荐链接加入 Medium-Fahadul shad hin</h2><div class="oz l"><h3 class="bd b gy z fp ox fr fs oy fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="pa l"><p class="bd b dl z fp ox fr fs oy fu fw dk translated">fahadulshadhin.medium.com</p></div></div><div class="pb l"><div class="pc l pd pe pf pb pg kp os"/></div></div></a></div></div></div>    
</body>
</html>