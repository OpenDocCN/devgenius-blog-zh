<html>
<head>
<title>Regex Parentheses: Examples of Every Type</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">正则表达式括号:每种类型的例子</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/regex-parentheses-examples-of-every-type-aba8441be761?source=collection_archive---------2-----------------------#2020-10-19">https://blog.devgenius.io/regex-parentheses-examples-of-every-type-aba8441be761?source=collection_archive---------2-----------------------#2020-10-19</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/81fc2f2490ea642be355920693b79bf5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sxmGRH8XfojgFjoXoRgJzA.png"/></div></div></figure><p id="2eae" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我最近遇到了一个编码问题，这个问题包括字符串中的括号，我的目标是替换括号和括号内的所有内容。我的第一个想法是——想办法使用正则表达式！</p><p id="8bf9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我很快意识到，我对 regex 中的括号并没有自己想象的那么了解。所以，我想分享一下我在正则表达式中括号的不同用法中的发现会很不错。原来，有三种不同的类型！</p><p id="9899" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先，3 种不同类型的括号是<strong class="jx io">文字型</strong>、<strong class="jx io">捕捉型</strong>和<strong class="jx io">非捕捉型</strong>。</p><p id="7e78" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果您以前使用过正则表达式，您很可能至少熟悉文字括号，甚至可能熟悉捕获括号。但是，如果你和我一样，你可能没有听说过正则表达式中的非捕捉括号。这篇短文将讨论每一种括号，并将分解例子来加深我们的理解。</p><h1 id="0d23" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">逐字的</h1><p id="19a7" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">这个听起来有点像，我们想要字面上匹配字符串中使用的括号。由于括号也用于捕获和非捕获组，我们必须用反斜杠来转义左括号。</p><p id="c34d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">假设给我们一本书的文本，我们想找到作者每次在括号里放东西的地方，包括括号本身。正则表达式可能类似于:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="190c" class="mf ku in mb b gy mg mh l mi mj">const literalRegex = /\([^()]+\)/g</span></pre><p id="6083" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后使用 Lorem Ipsum 的摘录，在 3 个地方插入括号，我们可以用<code class="fe mk ml mm mb b">.match()</code>方法测试我们的正则表达式，并检索所有使用的括号测试短语:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="c201" class="mf ku in mb b gy mg mh l mi mj">const book = "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nam ac purus dignissim, imperdiet dui sed, dignissim nunc. Sed faucibus turpis nec ultricies tempus. Integer scelerisque neque nisi (test1), at volutpat augue malesuada ut. Nam id venenatis urna. Suspendisse potenti. Aliquam id sem sem. Suspendisse mollis nulla eu ex tempor, et tincidunt risus condimentum. In non felis est. In ut tortor eget elit faucibus volutpat eget (test2) vulputate quam. Sed erat ex, consequat sed sapien vitae, porta pellentesque nulla. Etiam molestie libero sed lacus (test3) feugiat, hendrerit tempus eros interdum. Ut efficitur feugiat nunc, nec mattis risus ornare eget. Phasellus quis malesuada diam. Quisque."</span><span id="efbd" class="mf ku in mb b gy mn mh l mi mj">const allMatches = book.match(literalRegex)</span><span id="3af4" class="mf ku in mb b gy mn mh l mi mj">console.log(allMatches) //["(test1)", "(test2)", "(test3)"]</span></pre><p id="8802" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">关于<code class="fe mk ml mm mb b">literalRegex</code>如何工作的解释:</p><blockquote class="mo mp mq"><p id="5414" class="jv jw mr jx b jy jz ka kb kc kd ke kf ms kh ki kj mt kl km kn mu kp kq kr ks ig bi translated"><code class="fe mk ml mm mb b">/</code> —打开或开始正则表达式。<br/> <code class="fe mk ml mm mb b">\(</code> —转义单个左括号文字。<br/><code class="fe mk ml mm mb b">[^()]</code>—任何不是 ( <code class="fe mk ml mm mb b">^</code>)左括号或右括号(<code class="fe mk ml mm mb b">(</code>或<code class="fe mk ml mm mb b">)</code>)的字符。括号代表一个字符类，当它与左括号(<code class="fe mk ml mm mb b">[^</code>)后面的脱字符结合时，它对里面的字符求反——更多信息见<a class="ae mv" href="https://www.regular-expressions.info/charclass.html" rel="noopener ugc nofollow" target="_blank">此处</a>。<br/> + —直接出现在它前面的一个或多个字符(在这种情况下是上面的整个字符类)<br/> <code class="fe mk ml mm mb b">\)</code> —转义一个右括号文字。<br/> <code class="fe mk ml mm mb b">/</code> —关闭正则表达式。<br/> <code class="fe mk ml mm mb b">g</code> —全局标志允许我们返回数组中的每一个匹配，而不仅仅是数组中的第一个匹配。</p></blockquote><h1 id="5925" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">占领</h1><p id="dae9" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">这些括号用于将字符组合在一起，从而“捕获”这些组，以便它们可以通过反向引用重用，或者被赋予一个量词，如<code class="fe mk ml mm mb b">+</code>或<code class="fe mk ml mm mb b">*</code>。它们不与括号字面匹配，只与括号内的字符匹配，所以这些字符不需要用反斜杠进行转义，相反，我们将把它作为一个“元字符”来使用。</p><h2 id="8a42" class="mf ku in bd kv mw mx dn kz my mz dp ld kg na nb lh kk nc nd ll ko ne nf lp ng bi translated">捕捉和使用量词</h2><p id="68a0" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">这里有一个例子，我们想在由所有的 A，T，C 和 G 组成的 DNA 序列中重复使用相同的模式。我们的目标是在每次使用“CAT”模式时返回一个数组。如果模式后面紧跟着完全相同的模式，它将延长放入数组的字符串:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="ee37" class="mf ku in mb b gy mg mh l mi mj">const capturingRegex = /(CAT)+/g</span></pre><p id="8ee8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">再次使用<code class="fe mk ml mm mb b">.match()</code>方法将返回一个数组，其中包含在字符串中找到的每个实例:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="98cb" class="mf ku in mb b gy mg mh l mi mj">const dnaSequence = "GATCGATCATCATCATGGTATAGATGCTGATATGATCGCATCATTCGTAGTCGTGACCATCATCATCATCATCATGATGCGGATGTTATAGTAGTAGTCGGCGATGTAGCTGGATCGACATCATCATCATTGCTAGTCGTCATCATGCTAGTCGTAGCTGCATCATCTAGCATATACTTCGCCGCGTAATTATCGCCCATTT"</span><span id="acfb" class="mf ku in mb b gy mn mh l mi mj">const catMatches = dnaSequence.match(capturingRegex)</span><span id="07df" class="mf ku in mb b gy mn mh l mi mj">console.log(catMatches) // ["CATCATCAT", "CATCAT", "CATCATCATCATCATCAT", "CATCATCATCAT", "CATCAT", "CATCAT", "CAT", "CAT"]</span></pre><p id="8cc9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我不确定这个人的高“猫”数是怎么回事，但希望它证明了括号中模式的可重复性。</p><p id="e79f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe mk ml mm mb b">capturingRegex</code>故障:</p><blockquote class="mo mp mq"><p id="6919" class="jv jw mr jx b jy jz ka kb kc kd ke kf ms kh ki kj mt kl km kn mu kp kq kr ks ig bi translated"><code class="fe mk ml mm mb b">/</code> —打开或开始正则表达式。<br/> <code class="fe mk ml mm mb b">(CAT) </code> —图案为“猫”的捕捉组。<br/> <code class="fe mk ml mm mb b">+</code> —一个或多个直接出现在它前面的任何东西，在这种情况下，它是捕获组而不是单个字符。<br/> <code class="fe mk ml mm mb b">/ </code> —关闭正则表达式。<br/>g—全局标志允许我们返回数组中的每一个匹配项，而不仅仅是数组中的第一个匹配项。</p></blockquote><h2 id="35ff" class="mf ku in bd kv mw mx dn kz my mz dp ld kg na nb lh kk nc nd ll ko ne nf lp ng bi translated">捕获和使用反向引用</h2><p id="c1ac" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">如果我们需要稍后在正则表达式中重用一个捕获组，而不是像上一个例子那样紧挨着原始模式，我们也可以使用反向引用。</p><p id="2a67" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这里，我们将使用它来查找初始模式“TAG”或“TAT ”,然后，在“G”之后，再次查找在初始捕获组中找到的任何模式。换句话说，我们要寻找的模式要么是“TAGGTAG”，要么是“TATGTAT”:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="4353" class="mf ku in mb b gy mg mh l mi mj">const newCapturingRegex = /(TAG|TAT)G\1/g</span><span id="4564" class="mf ku in mb b gy mn mh l mi mj">const newSequence = "TAGGTAGCCCCCCCCCTATGTATCCCCCCCCCCCTAGGTAGCCCCTAGGTAGTAGGTAGTATGTATTATGTATCCCCCCCCCCCCCCTATGTATTATGTATTATGTATCCCCCCCCCTAGGTAGTAGGTAGCCC"</span><span id="cbaa" class="mf ku in mb b gy mn mh l mi mj">const dnaMatches = newSequence.match(newCapturingRegex)</span><span id="01f5" class="mf ku in mb b gy mn mh l mi mj">console.log(dnaMatches) //["TAGGTAG", "TATGTAT", "TAGGTAG", "TAGGTAG", "TAGGTAG", "TATGTAT", "TATGTAT", "TATGTAT", "TATGTAT", "TATGTAT", "TAGGTAG", "TAGGTAG"]</span></pre><p id="f8c7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe mk ml mm mb b">newCapturingRegex</code>故障:</p><blockquote class="mo mp mq"><p id="e26a" class="jv jw mr jx b jy jz ka kb kc kd ke kf ms kh ki kj mt kl km kn mu kp kq kr ks ig bi translated"><code class="fe mk ml mm mb b">/</code> —打开或开始正则表达式。<br/> <code class="fe mk ml mm mb b">(TAG|TAT)</code> —与“TAG”或“TAT”匹配的捕获组。<br/> <code class="fe mk ml mm mb b">G</code> —字母“G”的字符串文字匹配。<br/> <code class="fe mk ml mm mb b">\1</code> —反向引用，引用第一个捕获组(本例中唯一的捕获组)。如果正则表达式中使用了另一个捕获组，那么可以使用递增的反向引用来重用它，就像这样— <code class="fe mk ml mm mb b">\2</code>。<br/> <code class="fe mk ml mm mb b">/</code> —关闭正则表达式。<br/> <code class="fe mk ml mm mb b">g</code> —全局标志允许我们返回数组中的每个匹配项，而不仅仅是数组中的第一个匹配项。</p></blockquote><h2 id="704c" class="mf ku in bd kv mw mx dn kz my mz dp ld kg na nb lh kk nc nd ll ko ne nf lp ng bi translated">从正则表达式中移除了 G 标志的匹配方法</h2><p id="2a0e" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">如果我们从正则表达式的末尾移除<code class="fe mk ml mm mb b">g</code>标志，我们得到的不是数组中的每一个匹配，而是一个不同类型的数组。正则表达式找到的第一个匹配是新数组中的索引<code class="fe mk ml mm mb b">[0]</code>,之后的每个索引将是在捕获组中捕获的内容，这些捕获组按照在正则表达式中找到它们的顺序使用。</p><p id="d206" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们还可以使用点符号来查找匹配中第一个字符的索引(<code class="fe mk ml mm mb b">.index</code>)，也可以查找初始字符串本身(<code class="fe mk ml mm mb b">.input</code>)。让我们看一个例子:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="2396" class="mf ku in mb b gy mg mh l mi mj">const noFlagRegex = /(foo).*(bar)/</span><span id="3209" class="mf ku in mb b gy mn mh l mi mj">const fooBarString = "A foo walked into a bar..."</span><span id="c793" class="mf ku in mb b gy mn mh l mi mj">const fooBarMatch = fooBarString.match(noFlagRegex)</span><span id="c605" class="mf ku in mb b gy mn mh l mi mj">console.log(fooBarMatch[0]) // "foo walked into a bar"<br/>console.log(fooBarMatch[1]) // "foo"<br/>console.log(fooBarMatch[2]) // "bar"<br/>console.log(fooBarMatch.index) // 2<br/>console.log(fooBarMatch.input) // "A foo walked into a bar..."</span></pre><p id="35ef" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe mk ml mm mb b">noFlagRegex</code>的细目供感兴趣者参考:</p><blockquote class="mo mp mq"><p id="e3f0" class="jv jw mr jx b jy jz ka kb kc kd ke kf ms kh ki kj mt kl km kn mu kp kq kr ks ig bi translated"><code class="fe mk ml mm mb b">/</code> —打开或开始正则表达式。<br/> <code class="fe mk ml mm mb b">(foo)</code> —包含模式“foo”的捕获组。<br/> <code class="fe mk ml mm mb b">.</code> —代表通配符的元字符，任何字符都可以。<br/> <code class="fe mk ml mm mb b">*</code> —之前的 0 个或更多(在本例中为<code class="fe mk ml mm mb b">.</code>)。<br/> <code class="fe mk ml mm mb b">(bar)</code> —包含模式“foo”的捕获组。<br/> <code class="fe mk ml mm mb b">/</code> —关闭正则表达式。</p></blockquote><h1 id="cb7e" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">非捕获</h1><p id="de3d" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">这是我个人在研究它们之前一无所知的括号类型，我认为对于像我一样的其他正则表达式初学者来说也是如此。非捕获组本质上与捕获组做同样的事情，除了，听起来，我们不“捕获”括号之间的模式。</p><p id="d9e1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果我们不添加<code class="fe mk ml mm mb b">g</code>标志，而使用<code class="fe mk ml mm mb b">.match</code>方法，我们将得到一个类似上面例子中的数组，但是我们没有得到索引<code class="fe mk ml mm mb b">[1]</code>处的捕获组，等等，只是得到索引<code class="fe mk ml mm mb b">[0]</code>处的完全匹配，并且我们仍然能够使用类似上面例子中的<code class="fe mk ml mm mb b">.index</code>和<code class="fe mk ml mm mb b">.input</code>。</p><p id="85c1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">非捕获组以<code class="fe mk ml mm mb b">(?:</code>开始，右括号之前的冒号后面的内容被分组，但不会被捕获并存储在相应的数组中。让我们来看一个例子，在这个例子中，我们检查以确保电话联系人是这样的形式:mr/ms/mrs first last(XXX)XXX-xxxx，我们希望电话号码的区号是唯一的捕获组(在索引<code class="fe mk ml mm mb b">[1]</code>中找到)，但是我们还需要将 Mr/ms/Mrs 分组在一起。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="b645" class="mf ku in mb b gy mg mh l mi mj">const contactRegex = /(?:mr|ms|mrs) \w+ \w+ \((\d{3})\) \d{3}-\d{4}/</span><span id="67d5" class="mf ku in mb b gy mn mh l mi mj">const contactInfo = "mr Tyler Funk (555) 888-7777"</span><span id="d765" class="mf ku in mb b gy mn mh l mi mj">const contactMatch = contactInfo.match(contactRegex)</span><span id="df29" class="mf ku in mb b gy mn mh l mi mj">console.log(contactMatch[0]) // "mr Tyler Funk (555) 888-7777"<br/>console.log(contactMatch[1]) // 555<br/>console.log(contactMatch.index) // 0 <br/>console.log(contactMatch.input) // "mr Tyler Funk (555) 888-7777"</span></pre><p id="9db8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个例子中的索引<code class="fe mk ml mm mb b">[0]</code>和<code class="fe mk ml mm mb b">.index</code>在这里并不那么有用，因为在这种情况下，完全匹配是整个字符串本身，这自然会成为匹配的第一个索引<code class="fe mk ml mm mb b">0</code>。然而，我们没有捕获用于 mr/ms/mrs 的第一个组，而是捕获了索引<code class="fe mk ml mm mb b">[1]</code>中电话号码的区号。</p><p id="4ba9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe mk ml mm mb b">contactRegex</code>的细目:</p><blockquote class="mo mp mq"><p id="fa82" class="jv jw mr jx b jy jz ka kb kc kd ke kf ms kh ki kj mt kl km kn mu kp kq kr ks ig bi translated"><code class="fe mk ml mm mb b"><em class="in">/</em></code> —打开或开始正则表达式。<br/> <code class="fe mk ml mm mb b">(?:mr|ms|mrs)</code> —非捕获组，查找模式“mr”或“ms”或“mrs”，后跟一个空格。<br/> <code class="fe mk ml mm mb b">\w+</code> —查找任何“单词”字符的元字符(<code class="fe mk ml mm mb b">\w</code> —字母)，后跟查找其前面一个或多个任意字符的量词(<code class="fe mk ml mm mb b">+</code>，以及一个空格。(名字和姓氏都用了两次)<br/> <code class="fe mk ml mm mb b">\(</code> —左括号文字。<br/> <code class="fe mk ml mm mb b">(\d{3})</code> —精确查找 3 ( <code class="fe mk ml mm mb b">{3}</code>)个数字(<code class="fe mk ml mm mb b">\d</code>)的捕获组。<br/> <code class="fe mk ml mm mb b">\)</code> —右括号文字，后跟一个空格。<br/> <code class="fe mk ml mm mb b">\d{3}</code> —同样，正好是 3 个数字(也称为数字字符)。<br/> <code class="fe mk ml mm mb b">-</code> —连字符。<br/> <code class="fe mk ml mm mb b">\d{}</code> —正好 4 个数字。<br/> <code class="fe mk ml mm mb b">/</code> —关闭正则表达式。</p></blockquote><h1 id="335a" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">结论</h1><p id="0677" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">这就是正则表达式括号的主旨！我希望这在某种程度上对你有所启发，值得你花时间。以下是我用来研究这个话题的一些资源:</p><p id="e7fe" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">—一篇非常棒的文章，它帮助我理解了有 3 种不同的括号— <a class="ae mv" href="https://unbounded.systems/blog/3-kinds-of-parentheses-are-you-a-regex-master/" rel="noopener ugc nofollow" target="_blank">这里是</a>。阅读“但是等等，还有更多！”底部部分！</p><p id="d373" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">—一个优秀的常规正则表达式资源，但我发现一个特定的页面对于更好地理解特殊字符/元字符很有用— <a class="ae mv" href="https://www.regular-expressions.info/characters.html" rel="noopener ugc nofollow" target="_blank">这里是</a>。</p><p id="8bdb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">祝大家黑客快乐！</p></div></div>    
</body>
</html>