# Java 中的线程第 2 部分

> 原文：<https://blog.devgenius.io/threads-in-java-part-2-e0e0b667c514?source=collection_archive---------6----------------------->

## 了解创建和预防

![](img/9094891cbede3cead38bc6b084c1478c.png)

照片由[在](https://unsplash.com/@thecreative_exchange?utm_source=medium&utm_medium=referral) [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的创意交流

继我上一篇关于 java 中线程的博客之后，让我们通过理解更多的线程概念来继续更深入地探索线程。

# **如何防止线程执行**

我们可以通过使用以下三种方法来阻止线程执行

1.  产量()
2.  加入()
3.  睡眠()

## 1) **yield()** :-

yield()出现在具有以下声明的线程类中

```
Public static native void yield()
```

如果一个线程想要将改变给予另一个具有相同优先级的等待线程，

如果一个线程正在执行，并且一个更高优先级的线程到来，那么这个正在执行的线程将被停止，并且一个更高优先级的线程将立即获得一个机会。

**第 20 行说明:**

如果我们不删除第 20 行，那么子线程第一次复杂化的可能性很高，因为每次主线程都在内部调用 yield 方法。

## 2) **join()** :-

如果一个线程想要等待其他线程完成，那么这个线程可以调用 join()。

必须等待的线程负责调用 join()

线程类定义了以下连接方法:

1.  公共最终无效联接()
2.  公共最终无效联接(长毫秒)
3.  公共最终无效连接(长毫秒，整数)

## 3) **睡眠()** :-

如果我们想暂停当前的活动线程，那么我们调用 sleep()。

线程类中存在 Sleep 方法，声明如下:

1.  公共静态本机无效睡眠(长毫秒)
2.  公共静态无效睡眠(长毫秒，整数)

# **如何中断一个线程**

一个线程可以通过调用 Thread 类中的 interrupt()来中断另一个线程。

```
Public void interrupt();
```

## **守护线程:-**

在后台执行的线程被称为守护线程。

守护线程最好的例子是垃圾收集器线程。

每当 java 编程出现问题或任何内存问题时，垃圾收集器线程总是在后台执行，垃圾收集器线程会销毁无用的对象。

它的主要目的是为非守护线程提供支持。

我们可以通过使用 thread 类的以下方法来检查和设置线程的守护进程性质:

1.  public boolean isDaemon()
2.  public void setDaemon()

## **同步:-**

如果多个线程对一个 java 对象进行操作，那么就会出现数据不一致的问题，这也被称为竞争条件。

通过使用同步修饰符，我们可以消除这个数据不一致的问题。

Synchronized 修饰符只适用于方法和块。

如果一个方法或块被声明为 synchronized，那么一次只允许一个线程对给定对象上的该方法或块进行操作，因此不会有数据不一致的问题。

如果一个线程想要执行任何需要锁定该对象的同步线程，一旦该线程获得了该对象的锁定，那么该线程就可以对该对象执行 synchronized()。

锁的获取和释放都在 JVM 的控制之下，作为一个程序员，我们不需要关心它。

## 感谢阅读