<html>
<head>
<title>Avoid calling expressions in template of Angular</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">避免调用Angular模板中的表达式</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/avoid-calling-expressions-in-template-of-angular-39439c547653?source=collection_archive---------0-----------------------#2021-10-15">https://blog.devgenius.io/avoid-calling-expressions-in-template-of-angular-39439c547653?source=collection_archive---------0-----------------------#2021-10-15</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="a44e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">代码中有很多乱七八糟、多余的调用。让我们重构它们。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ea79f29c6c4dcc7d7bd65372543b21e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*myMT5ItFmgsPyOLbJmJ9vQ.jpeg"/></div></div></figure><p id="ed3c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这只是编写Angular应用程序的HTML模板的实用方面。</p><p id="a2dc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">首先，我们需要运行Lint工具来发现可能的错误或警告。只需在Angular项目中打开IntelliJ IDEA终端并运行命令:</p><pre class="kj kk kl km gt ku kv kw kx aw ky bi"><span id="e607" class="kz la in kv b gy lb lc l ld le">ng lint<br/>// or for all files in project<br/>npm run ng lint --files=src/app/**/*.ts</span><span id="4900" class="kz la in kv b gy lf lc l ld le">// or try to run lint with 1 specific typescript file<br/>npm run ng run projectName:lint ./src/my.component.ts</span></pre><p id="7dca" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你会在你的角组件上看到很多警告。</p><p id="a281" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们设想我们有这样一个简单的方法作为对象的属性:</p><pre class="kj kk kl km gt ku kv kw kx aw ky bi"><span id="9686" class="kz la in kv b gy lb lc l ld le">&lt;input value="{{ getName() }}" /&gt;<br/>or<br/>&lt;div [termsOfName]=”getName()”&gt; test &lt;/div&gt;</span></pre><p id="98f3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是一种低效的方法，会降低应用程序的性能。只需将<code class="fe lg lh li kv b">console.log("name")</code>添加到方法<code class="fe lg lh li kv b">getName()</code>中，你就会在浏览器的开发者工具中看到很多类似的调用。</p><p id="ebf5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">生命周期挂钩</p><p id="ef01" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="lj"> Angular在每个DOM事件之后运行的</em> <a class="ae lk" href="https://angular.io/guide/glossary#change-detection" rel="noopener ugc nofollow" target="_blank"> <em class="lj">变化检测</em> </a> <em class="lj">过程中查找数据绑定值的变化:每次击键、鼠标移动、计时器滴答和服务器响应。</em></p><p id="38d2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当我们的函数在嵌套组件中调用时，生命周期更新，并且我们有许多类似的函数调用和任何DOM事件。</p><p id="1a31" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此Lint认为这是一种无效的编程方式，并迫使我们重构代码。()括号用于当用户手动调用该方法时。[]括号只是向/从其他组件传递参数。</p><p id="9944" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">只是两种不同实践的一个例子:它们都工作得很好，但是…</p><pre class="kj kk kl km gt ku kv kw kx aw ky bi"><span id="bf77" class="kz la in kv b gy lb lc l ld le">&lt;button value="Click"<br/>  [termsDisabled]=”atLeastOneAdded()” /&gt;     // bad practice</span><span id="f371" class="kz la in kv b gy lf lc l ld le">  // rather better<br/>  [termsDisabled]=”terms | validateAtLeastOneAddedWithPipe”&gt;<br/>&lt;/button&gt;</span></pre><p id="8f7c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们不应该在模板中计算繁重的操作，我们应该只执行立即结束的方法。</p><p id="5a84" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有一些方法可以让我们的代码变得更好。</p><ol class=""><li id="f366" class="ll lm in jm b jn jo jr js jv ln jz lo kd lp kh lq lr ls lt bi translated"><strong class="jm io"> ngOnit() </strong> -使用字段变量调用它们一次</li></ol><p id="8567" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">通过每次触发<code class="fe lg lh li kv b">getName()</code>，我们只是减慢我们的应用程序。在具有大量元件的大部件的情况下，这成为一个问题。</p><p id="0a87" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在使用ngOnInit的方式中，<code class="fe lg lh li kv b">getName()</code>方法只会被调用一次，用户名的字符串表示会被赋给<code class="fe lg lh li kv b">name</code>变量。</p><pre class="kj kk kl km gt ku kv kw kx aw ky bi"><span id="67d9" class="kz la in kv b gy lb lc l ld le">name: string = "";<br/>ngOnInit() {<br/>  this.name = this.getName();<br/>}<br/>private getName(): string { return "data from other source"; }</span><span id="dd79" class="kz la in kv b gy lf lc l ld le">&lt;input id="name" value="{{ name }}" /&gt;</span></pre><p id="ac26" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> 2。ngOnChanges() </strong> —角度的有用标准接口</p><p id="3e42" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们可以把我们的逻辑移到接口方法ngOnChanges，如果输入对象的1得到一个新值，它就会触发。它将计算模板变量，并只提供结果，而不是许多多余的调用。</p><pre class="kj kk kl km gt ku kv kw kx aw ky bi"><span id="baf2" class="kz la in kv b gy lb lc l ld le"><a class="ae lk" href="http://twitter.com/Component" rel="noopener ugc nofollow" target="_blank">@Component</a>({<br/> template: `&lt;div *ngIf="personIsAuthorized"&gt;&lt;/div&gt;`<br/>})<br/>export class PersonComponent implements ngOnChanges {<br/>  personIsAuthorized: boolean = false;<br/><br/>  @Input()<br/>  isAuthorized?: boolean;<br/><br/>  ngOnChanges(changes: SimpleChanges) {<br/>    if (changes.isAuthorized) {<br/>      this.personIsAuthorized = this.isAuthorized;<br/>    }<br/>  }<br/>}</span></pre><p id="3de1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在模板{{ personName }}中写入字段可能是一种简单的方法。当组件的输入参数获得新值时，我们只需用新的计算结果替换personName。</p><pre class="kj kk kl km gt ku kv kw kx aw ky bi"><span id="cbda" class="kz la in kv b gy lb lc l ld le"><a class="ae lk" href="http://twitter.com/Component" rel="noopener ugc nofollow" target="_blank">@Component</a>({<br/> template: `<br/> &lt;b&gt;Morning, {{ personName }}&lt;/b&gt;<br/> `<br/>})<br/>export class PersonComponent implements OnChanges {<br/> <a class="ae lk" href="http://twitter.com/Input" rel="noopener ugc nofollow" target="_blank">@Input</a>() person: { firstName: string, lastName: string };<br/> personName: string = "";<br/><br/> ngOnChanges(changes: SimpleChanges) {<br/>   if (changes.person) {<br/>     this.personName = this.getPersonName();<br/>   }<br/> }<br/> getPersonName() { <br/>   return this.person.firstName + " " + this.person.lastName;<br/> }<br/>}</span></pre><p id="390e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> 3。管道</strong> —它们允许我们缓存某个输入的结果。这确实减少了调用次数，因为只有当参数改变时才会调用管道。</p><p id="494b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">通过告诉Angular管道是纯的，Angular知道如果管道的输入不变，管道的返回值也不变。</p><p id="3339" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Angular仅在检测到输入值的纯变化时执行纯管道。纯粹的更改要么是对原始输入值(字符串、数字、布尔值、符号)的更改，要么是对对象引用(日期、数组、函数、对象)的更改。</p><p id="a461" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们创建一个管道，并将一些逻辑移入其中。例如，我们有一个随时变化的电荷对象。该更改将调用一个管道并返回影响按钮属性的布尔结果。</p><pre class="kj kk kl km gt ku kv kw kx aw ky bi"><span id="9c8c" class="kz la in kv b gy lb lc l ld le">import { Pipe, PipeTransform } from "<a class="ae lk" href="http://twitter.com/angular/core" rel="noopener ugc nofollow" target="_blank">@angular/core</a>";</span><span id="e98f" class="kz la in kv b gy lf lc l ld le"><a class="ae lk" href="http://twitter.com/Pipe" rel="noopener ugc nofollow" target="_blank">@Pipe</a>({<br/>  name: "validateSelectedCharge",<br/>  pure: true<br/>})<br/>export class ValidateSelectedChargePipe implements PipeTransform {<br/>  transform(charges: Charges[]): boolean {<br/>    return charges?.some(item =&gt; item?.selectedCharge?.tariffId);<br/>  }<br/>}</span><span id="fb51" class="kz la in kv b gy lf lc l ld le">and call it from html: send object 'charges' to the pipe<br/>&lt;button value="Click"<br/>  [chargeDisabled]="charges | validateSelectedCharge" /&gt;</span><span id="9af0" class="kz la in kv b gy lf lc l ld le">now variable 'chargeDisabled' in other component has new value that calculated only once.</span></pre><p id="6d51" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是，在经常改变变量值的情况下…管道不是很好，因为管道在大多数情况下运行一次。如果您需要在同一个web页面上的组件之间发生变化时触发该值，最好使用常用的变量<code class="fe lg lh li kv b">{{ charges }}</code>。您将在Typescript级别分配一个新值，它将立即更新html模板级别的变量。</p><p id="d8a7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> 4。异步管道</strong></p><p id="e1d5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们可以使用异步管道只订阅一次可观察对象。而且会自动退订，不需要在ngOnDestroy()里写退订方法。</p><pre class="kj kk kl km gt ku kv kw kx aw ky bi"><span id="b991" class="kz la in kv b gy lb lc l ld le">@Component({<br/>  selector: 'app-root',<br/>  template: `&lt;div [list]="postObservable | async"&gt;&lt;/div&gt;`<br/>})<br/>export class PostComponent implements OnInit {<br/>  postObservable: Observable&lt;Post&gt;;<br/>  constructor(private postService: PostService) { }</span><span id="d9e3" class="kz la in kv b gy lf lc l ld le">  ngOnInit() {<br/>    this.postObservable = this.postService.loadPost(0);<br/>  }<br/>}</span><span id="8664" class="kz la in kv b gy lf lc l ld le"><a class="ae lk" href="http://twitter.com/Injectable" rel="noopener ugc nofollow" target="_blank">@Injectable</a>()<br/>export class PostService{<br/>  constructor(private http: HttpClient) { }<br/>    <br/>  loadPost(id:number) {<br/>    return this.http.get&lt;Post&gt;("/api/post/${id}");<br/>  }<br/>}</span></pre><p id="8f9a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">通过将附加参数追加到模板中并使用<code class="fe lg lh li kv b">:</code>作为分隔符，可以将附加参数传递给pipe方法。<br/>举例:<code class="fe lg lh li kv b">{{ param1 | pipeName : param2 : param3 }}</code></p><pre class="kj kk kl km gt ku kv kw kx aw ky bi"><span id="a306" class="kz la in kv b gy lb lc l ld le">export class PersonNamePipe implements PipeTransform {<br/>  transform(person: any, args ? : any): string {<br/>    return person?.firstName + " " + person?.lastName;<br/>  }<br/>}</span></pre><p id="f975" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">结论</strong></p><p id="234d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">可以采用不同的策略来避免HTML级别上不必要的函数调用，并提高应用程序的性能。<strong class="jm io"> Lint </strong>完美显示错误和警告。在使用Git之前，用它来改进您的代码。</p><div class="lu lv gp gr lw lx"><a href="https://blog.angular-university.io/angular-reactive-templates/" rel="noopener  ugc nofollow" target="_blank"><div class="ly ab fo"><div class="lz ab ma cl cj mb"><h2 class="bd io gy z fp mc fr fs md fu fw im bi translated">具有ngIf和异步管道的角反应模板</h2><div class="me l"><h3 class="bd b gy z fp mc fr fs md fu fw dk translated">详细了解Angular ngIf else语法，包括它如何与异步管道集成以实现改进的…</h3></div><div class="mf l"><p class="bd b dl z fp mc fr fs md fu fw dk translated">blog.angular-university.io</p></div></div><div class="mg l"><div class="mh l mi mj mk mg ml ks lx"/></div></div></a></div></div></div>    
</body>
</html>