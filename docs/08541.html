<html>
<head>
<title>K8s — YAML Format</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">K8s — YAML 格式</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/k8s-yaml-format-93a6ccbc691e?source=collection_archive---------2-----------------------#2022-06-23">https://blog.devgenius.io/k8s-yaml-format-93a6ccbc691e?source=collection_archive---------2-----------------------#2022-06-23</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><div class=""><h2 id="b76c" class="pw-subtitle-paragraph jo iq ir bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated">每天一点 K8s 知识！</h2></div><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div class="gi gj kg"><img src="../Images/eba69a59b64bf519edacc7cfbb664fcc.png" data-original-src="https://miro.medium.com/v2/resize:fit:918/format:webp/0*-ILTdq9MquFHSRQc.png"/></div></figure><p id="eb39" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">要在 K8s 中处理对象，你需要很好地理解 YAML，无论是创建/更新/删除对象，你都需要编写一些 YAML 文件，而当你尝试使用<code class="fe lk ll lm ln b">HELM</code>部署你的应用时，你还需要编写 YAML 文件，说实话，一个 K8s 工程师就是一个“YAML”工程师:)。</p><p id="92a0" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">我们先简单了解一下 YAML 文件在 K8s 中的工作原理，然后使用 YAML 文件定义一个 K8s Pod 作为演示。</p><h1 id="3270" class="lo lp ir bd lq lr ls lt lu lv lw lx ly jx lz jy ma ka mb kb mc kd md ke me mf bi translated">YAML 基础知识</h1><p id="f1cc" class="pw-post-body-paragraph ko kp ir kq b kr mg js kt ku mh jv kw kx mi kz la lb mj ld le lf mk lh li lj ik bi translated">它的基本语法规则如下:</p><ul class=""><li id="2b35" class="ml mm ir kq b kr ks ku kv kx mn lb mo lf mp lj mq mr ms mt bi translated">区分大小写</li><li id="b90c" class="ml mm ir kq b kr mu ku mv kx mw lb mx lf my lj mq mr ms mt bi translated">使用缩进来表示层次</li><li id="37d8" class="ml mm ir kq b kr mu ku mv kx mw lb mx lf my lj mq mr ms mt bi translated">缩进时不允许使用 Tab 键，只允许使用空格。</li><li id="5544" class="ml mm ir kq b kr mu ku mv kx mw lb mx lf my lj mq mr ms mt bi translated">只要同一级别的元素左对齐，缩进的空格数并不重要</li><li id="9c6d" class="ml mm ir kq b kr mu ku mv kx mw lb mx lf my lj mq mr ms mt bi translated"><code class="fe lk ll lm ln b">#</code>表示注释，解析器从该字符开始忽略该注释，直到行尾。</li></ul><p id="e61d" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">在 K8s 上下文中，您只需要两种结构类型:</p><ul class=""><li id="4616" class="ml mm ir kq b kr ks ku kv kx mn lb mo lf mp lj mq mr ms mt bi translated"><strong class="kq is">列表</strong></li><li id="64ea" class="ml mm ir kq b kr mu ku mv kx mw lb mx lf my lj mq mr ms mt bi translated"><strong class="kq is">地图</strong></li></ul><p id="dcb9" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">也就是说，你可能会遇到<strong class="kq is">地图列表</strong>和<strong class="kq is">地图列表</strong>等等。不过不用担心，只要你掌握了这两个结构，其他更复杂的我们就不讨论了。</p><h1 id="9c59" class="lo lp ir bd lq lr ls lt lu lv lw lx ly jx lz jy ma ka mb kb mc kd md ke me mf bi translated">地图</h1><p id="e131" class="pw-post-body-paragraph ko kp ir kq b kr mg js kt ku mh jv kw kx mi kz la lb mj ld le lf mk lh li lj ik bi translated">首先，让我们来看看地图。我们都知道地图是一本字典，是一对<code class="fe lk ll lm ln b">key:value</code>。地图可以让我们更容易地编写配置信息，例如:</p><pre class="kh ki kj kk gu mz ln na nb aw nc bi"><span id="1fba" class="nd lp ir ln b gz ne nf l ng nh">---<br/>apiVersion: v1<br/>kind: Pod</span></pre><p id="768a" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">第一行<code class="fe lk ll lm ln b">---</code>是分隔符，可选。在单个文件中，可以用三个连续的连字符<code class="fe lk ll lm ln b">---</code>来区分多个文件。这里可以看到我们有两个键:<code class="fe lk ll lm ln b">kind</code>和<code class="fe lk ll lm ln b">apiVersion</code>，它们对应的值是:v1 和 Pod。如果上面的 YAML 文件被转换成 JSON 格式，它将看起来像:</p><pre class="kh ki kj kk gu mz ln na nb aw nc bi"><span id="30a5" class="nd lp ir ln b gz ne nf l ng nh">{<br/>    "apiVersion": "v1",<br/>    "kind": "pod"<br/>}</span></pre><p id="2c4e" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">让我们创建一个相对复杂的 YAML 文件，创建一个对应于一个值的键不是一个字符串而是一个映射:</p><pre class="kh ki kj kk gu mz ln na nb aw nc bi"><span id="a236" class="nd lp ir ln b gz ne nf l ng nh">---<br/>apiVersion: v1<br/>kind: Pod<br/>metadata:<br/>  name: kube100-site<br/>  labels:<br/>    app: web</span></pre><p id="667f" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">在上面的 YAML 文件中，<code class="fe lk ll lm ln b">metadata</code>键对应的值是一个 Map，嵌套标签的键的值是一个 Map，你可以根据自己的情况进行多次嵌套。</p><p id="7792" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">我们在上面也提到了 YAML 文件的语法规则。YAML 处理器根据行缩进知道内容之间的关系。</p><p id="2f60" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">例如，在我们上面的 YAML 文件中，<strong class="kq is">我使用了两个空格来缩进。空格数无所谓，但是你得一致，要求至少一个空格</strong>(有些行不缩进两个空格，那就换成 4 个空格)。</p><p id="ed41" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">我们可以看到名字和标签是同一级别的缩进，所以 YAML 处理器知道它们属于同一个地图，app 是标签的值因为 app 更缩进。</p><blockquote class="ni nj nk"><p id="af07" class="ko kp nl kq b kr ks js kt ku kv jv kw nm ky kz la nn lc ld le no lg lh li lj ik bi translated"><em class="ir">注意:不要在 YAML 文件中使用 tab 键。</em></p></blockquote><p id="7e7d" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">同样，我们可以将上面的 YAML 文件转换成一个 JSON 文件:</p><pre class="kh ki kj kk gu mz ln na nb aw nc bi"><span id="8ab4" class="nd lp ir ln b gz ne nf l ng nh">{<br/>  "apiVersion": "v1",<br/>  "kind": "Pod",<br/>  "metadata": {<br/>    "name": "kube100-site",<br/>    "labels": {<br/>      "app": "web"<br/>    }<br/>  }<br/>}</span></pre><p id="4bd4" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">也许你更熟悉上面的 JSON 文件，但你不得不承认 YAML 文件更有语义性？</p><h1 id="8c03" class="lo lp ir bd lq lr ls lt lu lv lw lx ly jx lz jy ma ka mb kb mc kd md ke me mf bi translated">列表</h1><p id="ed72" class="pw-post-body-paragraph ko kp ir kq b kr mg js kt ku mh jv kw kx mi kz la lb mj ld le lf mk lh li lj ik bi translated">列表是一个列表，换句话说，是一个数组。在 YAML 文件中，我们可以这样定义它:</p><pre class="kh ki kj kk gu mz ln na nb aw nc bi"><span id="5c2e" class="nd lp ir ln b gz ne nf l ng nh">args<br/>  - Cat<br/>  - Dog<br/>  - Fish</span></pre><p id="a8a5" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">列表中可以有任意数量的项目，每个项目的定义都以破折号(-)开头，父元素可以直接缩进一个空格。对应的 JSON 格式如下:</p><pre class="kh ki kj kk gu mz ln na nb aw nc bi"><span id="0a73" class="nd lp ir ln b gz ne nf l ng nh">{<br/>    "args": ["Cat", "Dog", "Fish"]<br/>}</span></pre><p id="dd29" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">当然 list 的孩子也可以是 map，map 的孩子也可以是 list，如下:</p><pre class="kh ki kj kk gu mz ln na nb aw nc bi"><span id="9ce6" class="nd lp ir ln b gz ne nf l ng nh">---<br/>apiVersion: v1<br/>kind: Pod<br/>metadata:<br/>  name: kube100-site<br/>  labels:<br/>    app: web<br/>spec:<br/>  containers:<br/>    - name: front-end<br/>      image: nginx<br/>      ports:<br/>        - containerPort: 80<br/>    - name: flaskapp-demo<br/>      image: jcdemo/flaskapp<br/>      ports:<br/>        - containerPort: 5000</span></pre><p id="b151" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">例如，在这个 YAML 文件中，我们定义了一个名为容器的列表对象。每个子项由名称、图像和端口组成。每个端口都有一个映射，其关键字是 containerPort。同样，我们可以将其转换成以下 JSON 格式的文档:</p><pre class="kh ki kj kk gu mz ln na nb aw nc bi"><span id="eaa4" class="nd lp ir ln b gz ne nf l ng nh">{<br/>    "apiVersion": "v1",<br/>    "kind": "Pod",<br/>    "metadata": {<br/>        "name": "kube100-site",<br/>        "labels": {<br/>            "app": "web"<br/>        }<br/>    },<br/>    "spec": {<br/>        "containers": [{<br/>            "name": "front-end",<br/>            "image": "nginx",<br/>            "ports": [{<br/>                "containerPort": 80<br/>            }]<br/>        }, {<br/>            "name": "flaskapp-demo",<br/>            "image": "jcdemo/flaskapp",<br/>            "ports": [{<br/>                "containerPort": 5000<br/>            }]<br/>        }]<br/>    }<br/>}</span></pre><h1 id="96e8" class="lo lp ir bd lq lr ls lt lu lv lw lx ly jx lz jy ma ka mb kb mc kd md ke me mf bi translated">演示</h1><p id="2ffb" class="pw-post-body-paragraph ko kp ir kq b kr mg js kt ku mh jv kw kx mi kz la lb mj ld le lf mk lh li lj ik bi translated">现在我们对 YAML 档案有了一个大致的了解，相信你应该不会像以前那样迷茫了吧？让我们使用 YAML 文件创建一个部署。</p><h2 id="c832" class="nd lp ir bd lq np nq dn lu nr ns dp ly kx nt nu ma lb nv nw mc lf nx ny me nz bi translated">创建 Pod</h2><pre class="kh ki kj kk gu mz ln na nb aw nc bi"><span id="8127" class="nd lp ir ln b gz ne nf l ng nh">---<br/>apiVersion: v1<br/>kind: Pod<br/>metadata:<br/>  name: kube100-site<br/>  labels:<br/>    app: web<br/>spec:<br/>  containers:<br/>    - name: front-end<br/>      image: nginx<br/>      ports:<br/>        - containerPort: 80<br/>    - name: flaskapp-demo<br/>      image: jcdemo/flaskapp<br/>      ports:<br/>        - containerPort: 5000</span></pre><p id="001b" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">这是我们上面定义的一个普通的 POD 文件。让我们简单分析一下文件的内容:</p><ul class=""><li id="c766" class="ml mm ir kq b kr ks ku kv kx mn lb mo lf mp lj mq mr ms mt bi translated"><strong class="kq is"> apiVersion: </strong>其中它的值是 v1，这个版本号需要根据我们安装的 K8s 版本和资源类型进行更改，记住不是硬编码的</li><li id="5780" class="ml mm ir kq b kr mu ku mv kx mw lb mx lf my lj mq mr ms mt bi translated"><strong class="kq is">种类:</strong>我们在这里创建一个 Pod。当然，根据你的实际情况，这里的资源类型可以是部署、作业、入口、服务等待。</li><li id="0c5f" class="ml mm ir kq b kr mu ku mv kx mw lb mx lf my lj mq mr ms mt bi translated"><strong class="kq is">元数据:</strong>包含我们定义的 Pod 的一些元信息，比如名称、命名空间、标签等等。</li><li id="6227" class="ml mm ir kq b kr mu ku mv kx mw lb mx lf my lj mq mr ms mt bi translated"><strong class="kq is"> spec: </strong>包括一些容器、存储、卷，或者 K8s 需要知道的其他参数，以及容器失效时是否重启容器等属性。您可以在特定的 Kubernetes API 中找到完整的 Kubernetes Pod 属性。</li></ul><p id="8fd6" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">在理解了 pod 的定义之后，我们将上面创建的 POD 的 YAML 文件保存为 pod.yaml，然后使用 to <code class="fe lk ll lm ln b">kubectl</code>来创建 POD:</p><pre class="kh ki kj kk gu mz ln na nb aw nc bi"><span id="b8f8" class="nd lp ir ln b gz ne nf l ng nh">$ kubectl create -f pod.yaml<br/>pod "kube100-site" created</span></pre><p id="fc50" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">然后我们可以使用我们更熟悉的 kubectl 命令来查看 POD 的状态:</p><pre class="kh ki kj kk gu mz ln na nb aw nc bi"><span id="15cb" class="nd lp ir ln b gz ne nf l ng nh">$ kubectl get pods<br/>NAME           READY     STATUS    RESTARTS   AGE<br/>kube100-site   2/2       Running   0          1m</span></pre><p id="8eab" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">至此，我们的 POD 已经成功创建。</p><p id="9432" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">至此，我们已经完成了使用 YAML 文件创建 K8s Pod 的过程。理解了 YAML 文件的基础之后，定义 YAML 文件实际上非常简单。最重要的是根据实际情况定义 YAML 文件，所以查一下 Kubernetes 文档。非常重要。</p><blockquote class="ni nj nk"><p id="a3b0" class="ko kp nl kq b kr ks js kt ku kv jv kw nm ky kz la nn lc ld le no lg lh li lj ik bi translated">你可以用<a class="ae oa" href="http://www.yamllint.com/" rel="noopener ugc nofollow" target="_blank">http://www.yamllint.com/</a>来验证 YAML 文件的合法性。</p></blockquote></div></div>    
</body>
</html>