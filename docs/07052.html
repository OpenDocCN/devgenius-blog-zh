<html>
<head>
<title>JS Series #11: Scope in JS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JS 系列# 11:JS 中的范围</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/scope-in-js-4f8ba09f5128?source=collection_archive---------13-----------------------#2022-02-21">https://blog.devgenius.io/scope-in-js-4f8ba09f5128?source=collection_archive---------13-----------------------#2022-02-21</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="ed7f" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">了解可见性</h2></div><p id="cf9e" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi ky translated"><span class="l kz la lb bm lc ld le lf lg di"> S </span> cope 指定代码中可以访问特定变量的部分。定义变量的位置决定了我们可以访问该变量的位置。</p><figure class="li lj lk ll gt lm gh gi paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="gh gi lh"><img src="../Images/b68ae3f5898f129d02dcb38d6170324c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*L6wz-KQZigHq6-_k"/></div></div><figcaption class="lt lu gj gh gi lv lw bd b be z dk translated">照片由<a class="ae lx" href="https://unsplash.com/@ecbinoya?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Edryc James P. Binoya </a>在<a class="ae lx" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="d942" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">JavaScript 变量可以在 3 种类型的作用域中定义…</p><ol class=""><li id="9d9e" class="ly lz in ke b kf kg ki kj kl ma kp mb kt mc kx md me mf mg bi translated">功能范围</li><li id="9f37" class="ly lz in ke b kf mh ki mi kl mj kp mk kt ml kx md me mf mg bi translated">块范围</li><li id="026d" class="ly lz in ke b kf mh ki mi kl mj kp mk kt ml kx md me mf mg bi translated">词汇范围</li></ol><p id="0fdc" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果您不了解此范围，请不要担心。我们将对这 3 个示波器逐一进行更详细的讨论。</p></div><div class="ab cl mm mn hr mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ig ih ii ij ik"><h1 id="cf49" class="mt mu in bd mv mw mx my mz na nb nc nd jt ne ju nf jw ng jx nh jz ni ka nj nk bi translated">1.功能范围</h1><p id="d338" class="pw-post-body-paragraph kc kd in ke b kf nl jo kh ki nm jr kk kl nn kn ko kp no kr ks kt np kv kw kx ig bi translated"><code class="fe nq nr ns nt b">Function scope</code>规定<code class="fe nq nr ns nt b">function</code>内定义的<code class="fe nq nr ns nt b">variables</code>只能在<code class="fe nq nr ns nt b">function</code>内访问，这些类型的变量被称为<code class="fe nq nr ns nt b">local variable</code>。如果我们试图接近<code class="fe nq nr ns nt b">function</code>之外的<code class="fe nq nr ns nt b">local variable</code>，它会产生一个<code class="fe nq nr ns nt b">Reference error — "variable is not defined”</code>。</p><p id="c90d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">请看一些有助于您理解<code class="fe nq nr ns nt b">functional scope</code>的例子。</p><h2 id="7854" class="nu mu in bd mv nv nw dn mz nx ny dp nd kl nz oa nf kp ob oc nh kt od oe nj of bi translated">示例-1:</h2><pre class="li lj lk ll gt og nt oh oi aw oj bi"><span id="231a" class="nu mu in nt b gy ok ol l om on">function helpMe() {<br/>    const msg = "Hey!!! Please help me";<br/>    console.log(msg);<br/>}</span><span id="6bc5" class="nu mu in nt b gy oo ol l om on">console.log(msg); // ReferenceError: msg is not defined</span><span id="37b6" class="nu mu in nt b gy oo ol l om on">helpMe(); // Hey!!! Please help me</span></pre><h2 id="5051" class="nu mu in bd mv nv nw dn mz nx ny dp nd kl nz oa nf kp ob oc nh kt od oe nj of bi translated">示例-2:</h2><pre class="li lj lk ll gt og nt oh oi aw oj bi"><span id="b4bb" class="nu mu in nt b gy ok ol l om on">function knowMe() {<br/>    let name = 'Alex';<br/>    const age = 25;<br/>    var hobby = 'Football';<br/>    <br/>    console.log(name,age,hobby);<br/>}</span><span id="7c35" class="nu mu in nt b gy oo ol l om on">knowMe() // Alex 25 Football</span><span id="16fe" class="nu mu in nt b gy oo ol l om on">console.log(name) // ReferenceError: name is not defined<br/>console.log(age) // ReferenceError: age is not defined<br/>console.log(hobby) // ReferenceError: hobby is not defined</span></pre><p id="ed22" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如上例所示，分别用<code class="fe nq nr ns nt b">let</code>、<code class="fe nq nr ns nt b">const</code>和<code class="fe nq nr ns nt b">var</code>定义的所有 3 个变量<code class="fe nq nr ns nt b">name</code>、<code class="fe nq nr ns nt b">age</code>和<code class="fe nq nr ns nt b">hobby</code>在<code class="fe nq nr ns nt b">function</code>内部可以访问，但在<code class="fe nq nr ns nt b">function</code>外部不能访问，因为它们都有<code class="fe nq nr ns nt b">functional reference</code>。</p><h2 id="50cb" class="nu mu in bd mv nv nw dn mz nx ny dp nd kl nz oa nf kp ob oc nh kt od oe nj of bi translated">示例-3:</h2><pre class="li lj lk ll gt og nt oh oi aw oj bi"><span id="43a0" class="nu mu in nt b gy ok ol l om on">function knowMe() {<br/>    let name = 'Alex';<br/>    const age = 25;<br/>    var hobby = 'Football';<br/>    <br/>    console.log(name,age,hobby);<br/>}</span><span id="59f0" class="nu mu in nt b gy oo ol l om on">function updateHobby() {<br/>    let name = 'Alex';<br/>    const age = 25;<br/>    var hobby = 'Cricket';</span><span id="d75a" class="nu mu in nt b gy oo ol l om on">    console.log(name,age,hobby)<br/>}</span><span id="44b9" class="nu mu in nt b gy oo ol l om on">knowMe() // Alex 25 Football<br/>updateHobby() // Alex 25 Cricket</span></pre><p id="3318" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">根据<code class="fe nq nr ns nt b">functional scope</code>的约定，各<code class="fe nq nr ns nt b">function</code>可以有不同的<code class="fe nq nr ns nt b">local variables</code>组，但不相互干扰。</p><p id="d7c6" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">正如你在上面的例子中看到的——两个函数<code class="fe nq nr ns nt b">knowMe()</code>和<code class="fe nq nr ns nt b">updateHobby()</code>用相同的名字定义变量，但是我们没有得到任何<code class="fe nq nr ns nt b">error</code>，因为它们都是<code class="fe nq nr ns nt b">local variables</code>。</p></div><div class="ab cl mm mn hr mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ig ih ii ij ik"><h1 id="a91a" class="mt mu in bd mv mw mx my mz na nb nc nd jt ne ju nf jw ng jx nh jz ni ka nj nk bi translated">2.块范围</h1><p id="a1de" class="pw-post-body-paragraph kc kd in ke b kf nl jo kh ki nm jr kk kl nn kn ko kp no kr ks kt np kv kw kx ig bi translated">如果 JS 中的<code class="fe nq nr ns nt b">variables</code>在<code class="fe nq nr ns nt b">code block</code>中定义，那么它们有<code class="fe nq nr ns nt b">block scope</code>，并且只能在<code class="fe nq nr ns nt b">block </code>中访问，每个<code class="fe nq nr ns nt b">block</code>也可以有一组独立的变量。</p><p id="eb6a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">请看下面的例子来消化一下<code class="fe nq nr ns nt b">block level scope</code>。</p><pre class="li lj lk ll gt og nt oh oi aw oj bi"><span id="6495" class="nu mu in nt b gy ok ol l om on">let radius = 10;<br/>if(radius &gt; 0) {<br/>   const PI = 3.14;<br/>   let area = PI * radius * radius;<br/>   console.log(area); // 314<br/>}</span><span id="b25b" class="nu mu in nt b gy oo ol l om on">console.log(radius) // 10<br/>console.log(PI) // ReferenceError: PI is not defined<br/>console.log(area) // ReferenceError: area is not defined</span></pre><p id="61e7" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">上面的例子解释了如何通过将变量放入<code class="fe nq nr ns nt b">code blocks</code>来创建变量的<code class="fe nq nr ns nt b">block level</code>范围。在上面的例子中，<code class="fe nq nr ns nt b">PI</code>和<code class="fe nq nr ns nt b">area</code>是在<code class="fe nq nr ns nt b">code block</code>中定义的两个变量，所以只能在该块中访问，而<code class="fe nq nr ns nt b">radius</code>是在<code class="fe nq nr ns nt b">global</code>访问中定义的，所以可以在块外访问。</p><blockquote class="op oq or"><p id="0fa4" class="kc kd os ke b kf kg jo kh ki kj jr kk ot km kn ko ou kq kr ks ov ku kv kw kx ig bi translated">让我们看更多关于数据块范围的示例，这些示例向您解释了下面列出的一些要点...</p></blockquote><ol class=""><li id="934c" class="ly lz in ke b kf kg ki kj kl ma kp mb kt mc kx md me mf mg bi translated">如何用<code class="fe nq nr ns nt b">conditional blocks</code>创建<code class="fe nq nr ns nt b">block level scope</code>？</li><li id="070d" class="ly lz in ke b kf mh ki mi kl mj kp mk kt ml kx md me mf mg bi translated">就作用域而言，<code class="fe nq nr ns nt b">let</code>和<code class="fe nq nr ns nt b">const</code>的行为与<code class="fe nq nr ns nt b">var</code>有何不同？</li></ol><pre class="li lj lk ll gt og nt oh oi aw oj bi"><span id="1eaa" class="nu mu in nt b gy ok ol l om on"><strong class="nt io">Example-1:<br/></strong>if(true) {<br/>   let name = 'Alia'<br/>   console.log(name) // Alia<br/>}<br/>console.log(name) // ReferenceError: name is not defined</span><span id="4ec1" class="nu mu in nt b gy oo ol l om on"><strong class="nt io">Example-2:<br/></strong>if(true) {<br/>   const name = 'Alia'<br/>   console.log(name) // Alia<br/>}<br/>console.log(name) // ReferenceError: name is not defined</span></pre><p id="037f" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你可以从上面的例子中学到两件事…</p><ol class=""><li id="bef5" class="ly lz in ke b kf kg ki kj kl ma kp mb kt mc kx md me mf mg bi translated">看看我们如何通过编写带有真条件 if 块的语句来创建条件块。</li><li id="9645" class="ly lz in ke b kf mh ki mi kl mj kp mk kt ml kx md me mf mg bi translated">就块而言，scope let 和 const 的工作原理是一样的，它们只能在块内被访问，不能在块外被访问。</li></ol><blockquote class="op oq or"><p id="9505" class="kc kd os ke b kf kg jo kh ki kj jr kk ot km kn ko ou kq kr ks ov ku kv kw kx ig bi translated">让我们用 var 修改上面的例子，看看会发生什么…</p></blockquote><pre class="li lj lk ll gt og nt oh oi aw oj bi"><span id="e57d" class="nu mu in nt b gy ok ol l om on">if(true) {<br/>   var name = 'Alia'<br/>   console.log(name) // Alia<br/>}<br/>console.log(name) // Alia</span></pre><p id="dc47" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你可以很容易地观察到，如果我们在一个<code class="fe nq nr ns nt b">block scope</code>中创建一个带有<code class="fe nq nr ns nt b">var</code>的变量，它不起作用。</p><p id="dd9e" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">事实上<code class="fe nq nr ns nt b">var</code>只能创造<code class="fe nq nr ns nt b">functional scope</code>，不能创造<code class="fe nq nr ns nt b">block level scope</code>。因此，如果用<code class="fe nq nr ns nt b">var</code>定义一个变量，那么可以看到各种副作用，所以对于大多数可预测的编程方法，都引入了<code class="fe nq nr ns nt b">let</code>和<code class="fe nq nr ns nt b">const</code>。</p><p id="675b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们来看一些例子，这些例子表明<code class="fe nq nr ns nt b">var</code>的副作用可以被<code class="fe nq nr ns nt b">let</code>或<code class="fe nq nr ns nt b">const</code>克服。</p><pre class="li lj lk ll gt og nt oh oi aw oj bi"><span id="f319" class="nu mu in nt b gy ok ol l om on"><strong class="nt io">Example-1:</strong><br/>let cars = ['VW','OODI','BMW'];</span><span id="0186" class="nu mu in nt b gy oo ol l om on">for(var i = 0; i &lt; cars.length; i++) {<br/>    console.log(i,cars[i]);<br/>}<br/>console.log("Loop Ends...",i);</span><span id="d1d6" class="nu mu in nt b gy oo ol l om on"><strong class="nt io">Output:<br/></strong>0 'VW'<br/>1 'OODI'<br/>2 'BMW'<br/>Loop Ends... 3</span></pre><p id="344e" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">和上面的例子一样，为了遍历<code class="fe nq nr ns nt b">array</code>，我们在一个使用<code class="fe nq nr ns nt b">var</code>的循环中创建了一个变量<code class="fe nq nr ns nt b">i</code>，但是在循环之外<code class="fe nq nr ns nt b">i</code>仍然有效并输出 3。这通常是不可预测的。</p><p id="0ee3" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一般的预测是，在循环之外，<code class="fe nq nr ns nt b">i</code>不应该被访问。所以可以通过使用<code class="fe nq nr ns nt b">let</code>关键字来改善行为。请参见下面的示例…</p><pre class="li lj lk ll gt og nt oh oi aw oj bi"><span id="b653" class="nu mu in nt b gy ok ol l om on"><strong class="nt io">Example-1:</strong><br/>let cars = ['VW','OODI','BMW'];</span><span id="cfc7" class="nu mu in nt b gy oo ol l om on">for(let i = 0; i &lt; cars.length; i++) {<br/>    console.log(i,cars[i]);<br/>}<br/>console.log("Loop Ends...",i);</span><span id="c985" class="nu mu in nt b gy oo ol l om on"><strong class="nt io">Output:<br/></strong>0 'VW'<br/>1 'OODI'<br/>2 'BMW'<br/>ReferenceError: i is not defined</span></pre><p id="5453" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">第二个副作用是用<code class="fe nq nr ns nt b">var</code>关键字定义的变量可能会意外地在<code class="fe nq nr ns nt b">loop</code>或其他地方被重新初始化，因为用<code class="fe nq nr ns nt b">var</code>关键字重新声明变量时不会提示任何<code class="fe nq nr ns nt b">error</code>。请参见下面的示例…</p><pre class="li lj lk ll gt og nt oh oi aw oj bi"><span id="8c2c" class="nu mu in nt b gy ok ol l om on">let cars = ['VW','OODI','BMW'];<br/>var i = 10;</span><span id="9ad0" class="nu mu in nt b gy oo ol l om on">for(var i = 0; i &lt; cars.length; i++) {<br/>    console.log(i,cars[i]);<br/>}<br/></span><span id="610c" class="nu mu in nt b gy oo ol l om on"><strong class="nt io">Output:<br/></strong>0 'VW'<br/>1 'OODI'<br/>2 'BMW'</span></pre><p id="404b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是如果我们用<code class="fe nq nr ns nt b">let</code>关键字重新创建上面的例子，它会提示一个<code class="fe nq nr ns nt b">error</code>，因为同一个<code class="fe nq nr ns nt b">function scope</code>中的多个变量不能用<code class="fe nq nr ns nt b">let</code>创建。</p><pre class="li lj lk ll gt og nt oh oi aw oj bi"><span id="39c4" class="nu mu in nt b gy ok ol l om on">let cars = ['VW','OODI','BMW'];<br/>let i = 10;</span><span id="385d" class="nu mu in nt b gy oo ol l om on">for(let i = 0; i &lt; cars.length; i++) {<br/>    console.log(i,cars[i]);<br/>}<br/></span><span id="662f" class="nu mu in nt b gy oo ol l om on"><strong class="nt io">Output:<br/></strong>SyntaxError: Identifier 'i' has already been declared</span></pre></div><div class="ab cl mm mn hr mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ig ih ii ij ik"><h1 id="3354" class="mt mu in bd mv mw mx my mz na nb nc nd jt ne ju nf jw ng jx nh jz ni ka nj nk bi translated">3.词汇范围</h1><p id="0d9a" class="pw-post-body-paragraph kc kd in ke b kf nl jo kh ki nm jr kk kl nn kn ko kp no kr ks kt np kv kw kx ig bi translated">JS 允许函数嵌套。在这种情况下，可以在<code class="fe nq nr ns nt b">inner function</code>中访问<code class="fe nq nr ns nt b">outer function</code>中定义的变量，但不允许反过来。要了解事实，请看下面的例子…</p><pre class="li lj lk ll gt og nt oh oi aw oj bi"><span id="1d52" class="nu mu in nt b gy ok ol l om on">function person() { // outer function<br/>    let name = 'Alex';<br/>    function showName() { // inner function<br/>       let nickName = 'Al';<br/>       console.log(name); // Alex<br/>    }<br/>    showName();<br/>    console.log(nickName); // ReferenceError: nickname not defined<br/>}<br/>person() // call person function</span></pre><p id="3d2b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">上述类型的示波器称为<code class="fe nq nr ns nt b"><strong class="ke io">lexical scope</strong></code>。</p><p id="e3b3" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">JS 的高级用例像<code class="fe nq nr ns nt b">React JS</code>就是用上面的模式来创建<code class="fe nq nr ns nt b">functional components</code>。请参见下面的示例…</p><pre class="li lj lk ll gt og nt oh oi aw oj bi"><span id="406e" class="nu mu in nt b gy ok ol l om on">function TodoList() {<br/>    let todos = [];</span><span id="5a2a" class="nu mu in nt b gy oo ol l om on">    function addTodo() {<br/>      <br/>    }</span><span id="e756" class="nu mu in nt b gy oo ol l om on">    function removeTodo() {<br/>        <br/>    }<br/>}</span></pre><p id="66e6" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在上面的例子中，外部函数<code class="fe nq nr ns nt b">TodoList</code>定义了可以在内部函数<code class="fe nq nr ns nt b">addTodo()</code>和<code class="fe nq nr ns nt b">removeTodo()</code>中访问的<code class="fe nq nr ns nt b">todos</code>变量。</p></div><div class="ab cl mm mn hr mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ig ih ii ij ik"><p id="da02" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果你喜欢这篇文章，请关注我:</p><p id="48cf" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">中:</strong>https://medium.com/@maheshshittlani<br/><strong class="ke io">Github:</strong><a class="ae lx" href="https://github.com/maheshshittlani" rel="noopener ugc nofollow" target="_blank">https://github.com/maheshshittlani</a><br/><strong class="ke io">LinkedIn:</strong><a class="ae lx" href="https://in.linkedin.com/in/mahesh-shittlani-638b7429" rel="noopener ugc nofollow" target="_blank">https://in.linkedin.com/in/mahesh-shittlani-638b7429</a></p></div></div>    
</body>
</html>