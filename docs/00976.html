<html>
<head>
<title>Performance optimization with React Hooks — useCallback &amp; useMemo</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React 挂钩的性能优化—使用回调和使用备忘录</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/performance-optimization-with-react-hooks-usecallback-usememo-f2e527651b79?source=collection_archive---------8-----------------------#2020-06-21">https://blog.devgenius.io/performance-optimization-with-react-hooks-usecallback-usememo-f2e527651b79?source=collection_archive---------8-----------------------#2020-06-21</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="b030" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">使用 useCallback &amp; useMemo 钩子优化 web 应用程序性能的介绍。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/66355b9d1b87965a99668e120b18958c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uKAcWPM8CgLhuw1H"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">Artem Sapegin 在<a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="39dd" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">本文是“React Hooks 简介”系列的第 3 部分。到目前为止，我讨论了基本钩子和附加钩子中的<em class="lp">钩子。</em></p><p id="4e48" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">第一部分:<a class="ae ks" href="https://medium.com/@dkwathsala/introduction-to-react-hooks-e49738432f54" rel="noopener">React 钩子介绍—基础钩子</a> <br/>第二部分:<a class="ae ks" href="https://medium.com/dev-genius/introduction-to-react-hooks-usereducer-7b87a6cb4289" rel="noopener">React 钩子介绍— useReducer </a></p><p id="8b47" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在这篇文章中，我将讨论<em class="lp">use callback</em>&amp;<em class="lp">use memo</em>钩子，以及如何使用它们来优化 web 应用程序的性能，并给出例子</p><p id="027a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> 1。<em class="lp">使用回调</em> </strong></p><p id="86c1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">什么是<em class="lp"> useCallback？</em> </strong></p><blockquote class="lq lr ls"><p id="c7ca" class="kt ku lp kv b kw kx jo ky kz la jr lb lt ld le lf lu lh li lj lv ll lm ln lo ig bi translated">返回一个<a class="ae ks" href="https://en.wikipedia.org/wiki/Memoization" rel="noopener ugc nofollow" target="_blank">内存化的</a>回调。</p></blockquote><p id="1ae5" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="lp"> useCallback </em>是 React 中内置的钩子，用于返回回调函数的内存化版本。记忆就是记住或缓存函数的结果。只有当其中一个依赖关系发生变化时，回调的内存化版本才会发生变化。当再次调用相同的输入时，返回转换后的结果。<strong class="kv io">函数</strong>和<strong class="kv io">依赖列表</strong>是<em class="lp">使用回调</em>的输入参数。当其中一个依赖关系改变时，返回 memoized。</p><pre class="kd ke kf kg gt lw lx ly lz aw ma bi"><span id="b0ee" class="mb mc in lx b gy md me l mf mg"><strong class="lx io">React</strong>.<strong class="lx io">useCallback</strong>(<em class="lp">function</em>, <em class="lp">dependencies</em>)</span></pre><p id="017d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">举个例子，</p><pre class="kd ke kf kg gt lw lx ly lz aw ma bi"><span id="3bbd" class="mb mc in lx b gy md me l mf mg"><strong class="lx io">const </strong>memoizedCallback = <strong class="lx io"><em class="lp">useCallback</em></strong>(<br/> () =&gt; {<br/>  setValue(value);<br/> },<br/> [value],<br/>);</span></pre><p id="971f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">为什么使用<em class="lp"> useCallback？</em> </strong></p><p id="73a1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="lp"> useCallback </em>用于在向子组件传递回调时，防止父组件中不必要的重新渲染。</p><p id="efeb" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> 2。<em class="lp">使用备忘录</em>T42】</strong></p><p id="5427" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">什么是<em class="lp">用途备忘录？</em>T46】</strong></p><blockquote class="lq lr ls"><p id="cbfe" class="kt ku lp kv b kw kx jo ky kz la jr lb lt ld le lf lu lh li lj lv ll lm ln lo ig bi translated">返回一个记忆值。</p></blockquote><p id="c99b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="lp"> useMemo </em>是一个<em class="lp"> </em>内置在 Hook 中的 React 传递一个创建函数和数组的依赖关系。这有助于避免复杂的计算。</p><p id="f62c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"><em class="lp">使用回调</em>和<em class="lp">使用备忘录</em> </strong>的区别</p><ul class=""><li id="2bb4" class="mh mi in kv b kw kx kz la lc mj lg mk lk ml lo mm mn mo mp bi translated"><strong class="kv io"> <em class="lp"> useCallback </em> </strong>是在渲染之间记忆一个回调本身(引用相等)</li><li id="abee" class="mh mi in kv b kw mq kz mr lc ms lg mt lk mu lo mm mn mo mp bi translated"><em class="lp">用途记忆</em>是记忆函数调用之间和渲染之间的计算结果</li></ul><p id="3f5b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">当 useCallback 存储函数时，useMemo 存储任何值。</p><pre class="kd ke kf kg gt lw lx ly lz aw ma bi"><span id="b09c" class="mb mc in lx b gy md me l mf mg"><strong class="lx io">const </strong>memoizedValue = <strong class="lx io"><em class="lp">useMemo</em></strong>(() =&gt; computeExpensiveValue(a), [a]);</span></pre><p id="c83b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="lp"> useCallback </em> ( <em class="lp"> fn </em>、<em class="lp"> deps </em>)相当于<em class="lp">use memo</em>(()=&gt;<em class="lp">fn</em>、<em class="lp"> deps </em>)。</p><p id="3d9c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在，我将实现一个简单的 web 应用程序，带有增量计数器和乘法计数器。这里，我使用<strong class="kv io">计数器</strong>功能和<strong class="kv io"> App </strong>功能组件。在 App 函数组件中，包含增量计数器、乘法计数器组件及其值。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/411ab4e28b31ff1dc3430d0e48e29055.png" data-original-src="https://miro.medium.com/v2/resize:fit:1334/format:webp/1*lxW1Rdf90zb1Ic0CBT-dZA.jpeg"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">图 1 (web 应用程序视图)</figcaption></figure><p id="67f1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> Counter.js </strong></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">图 2(计数器. js)</figcaption></figure><p id="fc17" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这里<em class="lp">计数器</em>功能组件被扭曲<em class="lp"> React.memo </em>并且当状态改变时它将被重新渲染。<em class="lp"> React.memo </em>是一个高阶组件，如果 props 或 state 没有改变，它会阻止函数组件被重新渲染。</p><p id="6491" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> App.js 不使用<em class="lp"> useCallback() </em> </strong></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">图 3 (Counter.js —没有 useCallback())</figcaption></figure><p id="dd1e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">当点击<strong class="kv io">增量</strong>按钮时，仅改变<strong class="kv io"> <em class="lp">增量值、</em> </strong>的值，因此<strong class="kv io">计数器增量</strong>被重新渲染。但是，在这里，<strong class="kv io">计数器乘</strong>也被重新渲染，虽然<strong class="kv io"><em class="lp">mulValue</em></strong><em class="lp"/>没有改变(mul value 的初始值为 2)。如果应用程序容器中有 10 个组件，所有组件都将重新呈现。因此<em class="lp"> useCallback </em>有助于优化应用程序的性能。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi my"><img src="../Images/c2629752637a40dedf210e0019b8b42d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RM55vBNJoEFETnWXz1kHqA.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">图 4(当点击增量时，增量计数器和乘法计数器都被重新呈现)</figcaption></figure><p id="8592" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> App.js 使用<em class="lp"> useCallback() </em> </strong></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">图 5 (App.js —使用 useCallback())</figcaption></figure><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mz"><img src="../Images/67f3786fac1aa600a62a4cd0a1426114.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Usqj4mRO3rn-RmowA6VAYA.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">图 4(当单击增量时，仅重新呈现增量计数器)</figcaption></figure><p id="f757" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这里，<em class="lp"> useCallback </em>阻止乘法计数器的重新渲染。</p></div><div class="ab cl na nb hr nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ig ih ii ij ik"><p id="d17a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">参考</strong></p><div class="nh ni gp gr nj nk"><a href="https://reactjs.org/docs/hooks-reference.html" rel="noopener  ugc nofollow" target="_blank"><div class="nl ab fo"><div class="nm ab nn cl cj no"><h2 class="bd io gy z fp np fr fs nq fu fw im bi translated">钩子 API 参考-反应</h2><div class="nr l"><h3 class="bd b gy z fp np fr fs nq fu fw dk translated">钩子是 React 16.8 中的新增功能。它们允许您使用状态和其他 React 特性，而无需编写类。这个…</h3></div><div class="ns l"><p class="bd b dl z fp np fr fs nq fu fw dk translated">reactjs.org</p></div></div><div class="nt l"><div class="nu l nv nw nx nt ny km nk"/></div></div></a></div></div></div>    
</body>
</html>