<html>
<head>
<title>JavaScript.Linked Lists. Find middle node.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript。链接列表。查找中间节点。</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/javascript-linked-lists-find-middle-node-6b1fa73b20fb?source=collection_archive---------0-----------------------#2020-08-20">https://blog.devgenius.io/javascript-linked-lists-find-middle-node-6b1fa73b20fb?source=collection_archive---------0-----------------------#2020-08-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/5d04c6d1c86c0d1bb31870528cac0039.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/0*mpo4imGzcgpXOu5w.png"/></div></figure><p id="9dd7" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">大家好！今天，我们有很好的机会深入研究链表及其功能。我希望你已经知道链表和它的方法的基础知识。今天，我们将讨论面试中可能会被问到的重要方法，我很乐意与你分享。另外，如果您刚刚开始学习链表，我建议您从这里开始学习:</p><div class="ks kt gp gr ku kv"><a href="https://medium.com/dev-genius/javascript-linked-lists-what-is-linked-lists-create-a-node-class-api-9aa0fa460075" rel="noopener follow" target="_blank"><div class="kw ab fo"><div class="kx ab ky cl cj kz"><h2 class="bd ir gy z fp la fr fs lb fu fw ip bi translated">JavaScript。链接列表。什么是“链表”？创建节点类 API</h2><div class="lc l"><h3 class="bd b gy z fp la fr fs lb fu fw dk translated">新读者们你们好，欢迎回到我身边。只是想提一下，我已经不再写关于…</h3></div><div class="ld l"><p class="bd b dl z fp la fr fs lb fu fw dk translated">medium.com</p></div></div><div class="le l"><div class="lf l lg lh li le lj js kv"/></div></div></a></div><h1 id="9b03" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">查找中间节点</h1><h2 id="cbf8" class="mi ll iq bd lm mj mk dn lq ml mm dp lu kf mn mo ly kj mp mq mc kn mr ms mg mt bi translated">方向</h2><p id="7500" class="pw-post-body-paragraph ju jv iq jw b jx mu jz ka kb mv kd ke kf mw kh ki kj mx kl km kn my kp kq kr ij bi translated">返回链表的中间节点。如果列表有偶数个元素，则返回列表前半部分末尾的节点。不使用计数器变量，不检索列表的大小，只遍历列表一次。</p><h2 id="a259" class="mi ll iq bd lm mj mk dn lq ml mm dp lu kf mn mo ly kj mp mq mc kn mr ms mg mt bi translated">例子</h2><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="b094" class="mi ll iq ne b gy ni nj l nk nl">const l = new LinkedList();<br/>l.insertLast('a')<br/>l.insertLast('b')<br/>l.insertLast('c')<br/>l.insertLast('d');<br/>l.insertLast('e');</span><span id="e34b" class="mi ll iq ne b gy nm nj l nk nl">midpoint(l); // returns {data: 'c'}</span></pre></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><p id="579a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们开始吧。我想从 5 个节点开始(这是我们目前的例子)。</p><figure class="mz na nb nc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nv nw di nx bf ny"><div class="gh gi nu"><img src="../Images/655c34896e999e3e55aa0f4b829aa2d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YqkP2YZLTD6_mETb6eFfNQ.png"/></div></div></figure><p id="2e82" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们还创建了两个变量来帮助我们遍历所有列表。一个变量叫做慢速，另一个叫做快速，我们指向两个变量的第一个节点。为什么会是那样？</p><figure class="mz na nb nc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nv nw di nx bf ny"><div class="gh gi nz"><img src="../Images/189f82ac52da50fb8e7f576c64adf987.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g9kzL64-MFR1pzubaAEo_w.png"/></div></div></figure><p id="004c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">原因是“快”变量比“慢”变量快两倍，因为“慢”将在“快”变量的中途，它将是我们的列表的中间(“慢”将在迭代结束时在列表的中间)。</p><figure class="mz na nb nc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nv nw di nx bf ny"><div class="gh gi nz"><img src="../Images/16c18b410b86217ff32c3e435fd846de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kplmB1Iu8CD9DdQAiuHBWg.png"/></div></div></figure><p id="aca7" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">总是“快速”检查条件:“如果接下来的两个元素不为空”。如果为空—停止迭代。如果不为空，继续迭代。</p><figure class="mz na nb nc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nv nw di nx bf ny"><div class="gh gi oa"><img src="../Images/7494fe13eec94d1a83e9815fbfed1d36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D0vhyW74kyIou_KtBmWifQ.png"/></div></div></figure><p id="42a7" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在这种情况下，它将返回“slow”和{data: 'red'}。</p></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><p id="e32a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们创建了“中点”函数。“慢”和“快”指向列表中的第一个元素。而“fast”元素具有在我们迭代之前不为空的数据。最后返回慢，这表明我们的中间元素。</p><figure class="mz na nb nc gt jr gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/bf2a977195760e8fcf40954db3d1eeff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1212/format:webp/1*8YzBvtaavhcrMMm2ip_zfw.png"/></div></figure><figure class="mz na nb nc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nv nw di nx bf ny"><div class="gh gi oc"><img src="../Images/18993a7dd6a0280b36103446fde4601c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3vW9zSNjg3_5-eUWgfBo6Q.png"/></div></div></figure><figure class="mz na nb nc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="nv nw di nx bf ny"><div class="gh gi od"><img src="../Images/d938401ea1a12465e861e15628d64273.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JGr3IkbnVx2iar-d-WOJtQ.png"/></div></div></figure><p id="e477" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">完整代码:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="c329" class="mi ll iq ne b gy ni nj l nk nl">class Node {<br/>  constructor(data, next = null) {<br/>   this.data = data;<br/>   this.next = next;<br/>  }<br/>}class LinkedList {<br/>  constructor() {<br/>    this.head = null;<br/>  }insertFirst(data) {<br/>    const node = new Node(data, this.head);<br/>    this.head = node;<br/>  }<br/>  <br/>  size() {<br/>    let counter = 0;<br/>    let node = this.head;<br/>    while (node) {<br/>     counter++;<br/>     node = node.next;<br/>    }<br/>    return counter;<br/>  }<br/>  <br/>  getFirst() {<br/>    return this.head.data;<br/>  }<br/>  <br/>  getLast() {<br/>    if (!this.head) {<br/>      return null;<br/>    }<br/>    let node = this.head;<br/>    while (node) {<br/>     if (!node.next) {<br/>      return node;<br/>     }<br/>     node = node.next;<br/>    }<br/>  }<br/>  <br/>  clear() {<br/>    this.head = null;<br/>  } <br/>  <br/>  removeFirst() { <br/>    if (!this.head) {<br/>     return;<br/>    }<br/>    this.head = this.head.next;<br/>   }removeLast() {<br/>    if (!this.head) {<br/>      return;<br/>    }<br/>   <br/>    if (!this.head.next) {<br/>     this.head = null;<br/>    }<br/>   <br/>    let previous = this.head;<br/>    let node = this.head.next;<br/>   <br/>    while (node.next) {<br/>      previous = node;<br/>      node = node.next;<br/>    }<br/>    <br/>    previous.next = null;<br/>   }   insertLast(data) {<br/>    const last = this.getLast();<br/>    if (last) {<br/>     last.next = new Node(data);<br/>    } else {<br/>      this.head = new Node(data);<br/>    }<br/>   }<br/>  <br/>   getAt(index) {<br/>    let counter = 0;<br/>    let node = this.head;<br/>    while (node) {<br/>     if (counter === index) {<br/>      return node;<br/>     }<br/>     counter++;<br/>     node = node.next;<br/>    }<br/>   return null;<br/>  } removeAt(index) {<br/>  if (!this.head) {<br/>    return;<br/>  }  if (index === 0) {<br/>    this.head = this.head.next;<br/>    return;<br/>  }<br/>  <br/>  const previous = this.getAt(index - 1);<br/>  if (!previous || !previous.next) {<br/>    return;<br/>  }<br/>  previous.next = previous.next.next;<br/> } insertAt(data, index) {<br/>   if (!this.head) {<br/>    this.head = new Node(data);<br/>    return;<br/>   }<br/>   if (index === 0) {<br/>    this.head = new Node(data, this.head);<br/>    return;<br/>   }<br/>  const previous = this.getAt(index - 1) || this.getLast();<br/>  const node = new Node(data, previous.next);<br/>  previous.next = node; <br/> }<br/>}</span><span id="08ab" class="mi ll iq ne b gy nm nj l nk nl">function midpoint(list) {<br/>  let slow = list.head;<br/>  let fast = list.head;<br/>  while (fast.next &amp;&amp; fast.next.next) {<br/>   slow = slow.next;<br/>   fast = fast.next.next;<br/>  }<br/>  <br/>  return slow;<br/> }</span><span id="5425" class="mi ll iq ne b gy nm nj l nk nl">const l = new LinkedList();<br/>l.insertLast("a");<br/>l.insertLast("b");<br/>l.insertLast("c");<br/>l.insertLast("d");<br/>l.insertLast("e");</span><span id="d94d" class="mi ll iq ne b gy nm nj l nk nl">console.log(midpoint(l)); // returns {data: 'c'}</span></pre></div></div>    
</body>
</html>