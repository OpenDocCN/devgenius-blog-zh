<html>
<head>
<title>MUST know algorithms for coding interviews</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">必须知道编码采访的算法</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/must-know-algorithms-for-coding-interviews-4e327bca59fd?source=collection_archive---------8-----------------------#2022-10-31">https://blog.devgenius.io/must-know-algorithms-for-coding-interviews-4e327bca59fd?source=collection_archive---------8-----------------------#2022-10-31</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/7b326370b7ff877a73f176cc99839043.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2iUjNTTF3ARsip9j"/></div></div></figure><p id="445c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在开始这篇文章之前，有一件事我想告诉你，这并不是什么新的编码问题，每个问题都可以通过你所研究的算法来解决，问题是你必须识别出这个问题的模式。这里我列出了一些在编码面试中经常被问到的重要算法。</p><p id="0c33" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">附:不能保证你学会这些算法后能找到工作，但是 80%的情况下你会找到与这些算法相关的问题。</p><p id="9877" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在本文中，您可以找到算法:-</p><ul class=""><li id="a4ca" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated">两点</li><li id="1498" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">推拉窗</li><li id="54c9" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">BFS</li><li id="2ca3" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">深度优先搜索</li><li id="0f73" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">拓扑排序</li><li id="a851" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">Dijkstra 算法</li><li id="ba73" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">二进位检索</li></ul><h1 id="b501" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">两点</h1><blockquote class="mf mg mh"><p id="92d3" class="jv jw mi jx b jy jz ka kb kc kd ke kf mj kh ki kj mk kl km kn ml kp kq kr ks ig bi translated">两个指针确实是一个简单有效的技巧，通常用在问题中</p></blockquote><ul class=""><li id="56c3" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated">这些问题你必须指出两点。一个指针移动得慢，而另一个指针移动得快。</li><li id="68d0" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">这些问题你必须指出两点。一个指针将从起点开始，而另一个指针将从终点开始。他们相向而行，直到相遇。</li></ul><p id="4b5f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">示例:- <strong class="jx io">有效回文</strong></p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="31a7" class="mv li in mr b gy mw mx l my mz">int main()<br/>{<br/>   <br/>   string str;<br/>   cin&gt;&gt;str;<br/>   int i=0;<br/>   int j=str.length()-1;<br/>   <br/>   while(i&lt;j){<br/>       if(str[i]!=str[j]) cout&lt;&lt;false;<br/>       <br/>       i++;<br/>       j--;<br/>   }<br/>   <br/>   cout&lt;&lt;true;<br/>   <br/>}</span></pre><p id="41b4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里我们使用两个指针的方法来检查给定的字符串是否是回文。我们从起始位置开始一个指针，从末端开始第二个指针。他们相向而行，直到相遇。</p><p id="a07a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">多一些问题两个指针练习:- </strong></p><div class="na nb gp gr nc nd"><a href="https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/" rel="noopener  ugc nofollow" target="_blank"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd io gy z fp ni fr fs nj fu fw im bi translated">两个和 II -输入数组排序- LeetCode</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">给定一个已按非降序排序的 1 索引整数数组，找出两个数字，使得…</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">leetcode.com</p></div></div><div class="nm l"><div class="nn l no np nq nm nr jt nd"/></div></div></a></div><div class="na nb gp gr nc nd"><a href="https://leetcode.com/problems/3sum/" rel="noopener  ugc nofollow" target="_blank"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd io gy z fp ni fr fs nj fu fw im bi translated">3 求和- LeetCode</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">提高你的编码技能，迅速找到工作。这是扩展你的知识和做好准备的最好地方…</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">leetcode.com</p></div></div><div class="nm l"><div class="ns l no np nq nm nr jt nd"/></div></div></a></div><div class="na nb gp gr nc nd"><a href="https://leetcode.com/problems/container-with-most-water/" rel="noopener  ugc nofollow" target="_blank"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd io gy z fp ni fr fs nj fu fw im bi translated">装水最多的容器</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">给你一个长度为 n 的整数数组高度，画了 n 条垂直线，使得数组的两个端点…</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">leetcode.com</p></div></div><div class="nm l"><div class="nt l no np nq nm nr jt nd"/></div></div></a></div><div class="na nb gp gr nc nd"><a href="https://leetcode.com/problems/trapping-rain-water/" rel="noopener  ugc nofollow" target="_blank"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd io gy z fp ni fr fs nj fu fw im bi translated">收集雨水- LeetCode</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">提高你的编码技能，迅速找到工作。这是扩展你的知识和做好准备的最好地方…</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">leetcode.com</p></div></div><div class="nm l"><div class="nu l no np nq nm nr jt nd"/></div></div></a></div><h1 id="9bbd" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">推拉窗</h1><blockquote class="mf mg mh"><p id="1b89" class="jv jw mi jx b jy jz ka kb kc kd ke kf mj kh ki kj mk kl km kn ml kp kq kr ks ig bi translated">滑动窗口技术背后的基本思想是将两个嵌套循环转换成一个循环。</p></blockquote><ul class=""><li id="9bed" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated">问题将基于数组、列表或字符串类型的数据结构。</li><li id="1f62" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">它将要求在数组或字符串中查找子范围，必须给出最长、最短或目标值。</li><li id="c1c6" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">它的概念主要基于这样的想法，比如完美地满足给定条件的事物的最长序列或最短序列。</li><li id="4aba" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">假设我们有数组</li></ul><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="0b2b" class="mv li in mr b gy mw mx l my mz">[ 5, 7, 1, 4, 3, 6, 2,]</span></pre><p id="f7ba" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">大小为 3 的滑动窗口看起来像:-</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="9be8" class="mv li in mr b gy mw mx l my mz">[5,7,1]<br/>[7,1,4]<br/>[1,4,3]<br/>[4,3,6]<br/>[3,6,2]<br/></span></pre><p id="d4c2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">解决滑动窗口问题的一些基本步骤</p><ul class=""><li id="6bde" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated">使用 HashMap 或 dictionary 来计算特定的数组输入，并坚持使用外部循环向右增加窗口。</li><li id="7f63" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">将一个放入循环中，通过向右滑动来减少窗口边。这个循环会很短。</li><li id="b5cd" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">根据问题陈述存储当前最大或最小窗口大小或计数。</li></ul><p id="4483" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">示例:- <strong class="jx io">具有总和 k 的最长子阵列</strong></p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="8e98" class="mv li in mr b gy mw mx l my mz">int lenOfLongSubarr(int A[], int N, int K)<br/>{<br/> <br/>    int i = 0, j = 0, sum = 0;<br/>    int maxLen = INT_MIN;<br/>   <br/>    while (j &lt; N) {<br/>        sum += A[j];<br/>        if (sum &lt; K) {<br/>            j++;<br/>        }<br/>        else if (sum == K) {<br/>            maxLen = max(maxLen, j-i+1);<br/>            j++;<br/>        }<br/>        else if (sum &gt; K) {<br/>            while (sum &gt; K) {<br/>                sum -= A[i];<br/>                 i++;<br/>            }<br/>              if(sum == K){<br/>              maxLen = max(maxLen, j-i+1);<br/>            }<br/>            j++;<br/>        }<br/>    }<br/>    return maxLen;<br/>}</span></pre><p id="ff32" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里，我们必须找到总和为 k 的最长子数组。我们使用滑动窗口方法，取两个指针 I 和 j。我们递增 j 指针，并将元素添加到总和变量。一旦总和等于 k，我们将数组大小存储在 maxLen 变量中。如果 sum 超过 k，我们开始减少 sum 变量，同时增加 I 指针。</p><p id="4125" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">更多问题滑动窗口练习:- </strong></p><div class="na nb gp gr nc nd"><a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/" rel="noopener  ugc nofollow" target="_blank"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd io gy z fp ni fr fs nj fu fw im bi translated">没有重复字符的最长子串- LeetCode</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">提高你的编码技能，迅速找到工作。这是扩展你的知识和做好准备的最好地方…</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">leetcode.com</p></div></div><div class="nm l"><div class="nv l no np nq nm nr jt nd"/></div></div></a></div><div class="na nb gp gr nc nd"><a href="https://leetcode.com/problems/minimum-window-substring/" rel="noopener  ugc nofollow" target="_blank"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd io gy z fp ni fr fs nj fu fw im bi translated">最小窗口子串- LeetCode</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">给定长度分别为 m 和 n 的两个字符串 s 和 t，返回 s 的最小窗口子串，使得每个…</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">leetcode.com</p></div></div><div class="nm l"><div class="nw l no np nq nm nr jt nd"/></div></div></a></div><div class="na nb gp gr nc nd"><a href="https://leetcode.com/problems/sliding-window-maximum/" rel="noopener  ugc nofollow" target="_blank"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd io gy z fp ni fr fs nj fu fw im bi translated">滑动窗口最大- LeetCode</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">给你一个整数数组 nums，有一个大小为 k 的滑动窗口，它从数组的最左边移动…</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">leetcode.com</p></div></div><div class="nm l"><div class="nx l no np nq nm nr jt nd"/></div></div></a></div><div class="na nb gp gr nc nd"><a href="https://leetcode.com/problems/permutation-in-string/" rel="noopener  ugc nofollow" target="_blank"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd io gy z fp ni fr fs nj fu fw im bi translated">字符串中的置换- LeetCode</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">提高你的编码技能，迅速找到工作。这是扩展你的知识和做好准备的最好地方…</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">leetcode.com</p></div></div><div class="nm l"><div class="ny l no np nq nm nr jt nd"/></div></div></a></div><h1 id="b828" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">广度优先搜索(BFS)</h1><blockquote class="mf mg mh"><p id="596d" class="jv jw mi jx b jy jz ka kb kc kd ke kf mj kh ki kj mk kl km kn ml kp kq kr ks ig bi translated">BFS 是一种遍历算法，您应该从选定的节点(源节点或起始节点)开始遍历，并逐层遍历图，从而探索相邻节点(直接连接到源节点的节点)。然后，您必须向下一级邻居节点移动。</p></blockquote><p id="9dc8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">正如 BFS 的名字所暗示的，你需要横向遍历这个图，如下所示:</p><ul class=""><li id="4b64" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated">首先水平移动并访问当前层的所有节点</li><li id="4142" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">移动到下一层</li></ul><figure class="mm mn mo mp gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nz"><img src="../Images/20d66d5bccd0632cddc56d8c35fedae1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kbM2EgVhapqRnfaCrIJyXQ.png"/></div></div></figure><p id="c9e8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">解决 BFS 问题的一些基本步骤</p><ul class=""><li id="2e99" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated">排队</li><li id="825e" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">在队列中添加根节点</li><li id="c2d3" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">对队列中的所有元素运行循环。弹出该元素并将其子节点推入队列。</li></ul><p id="2dfd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">示例:-二叉树的层次顺序遍历</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="4879" class="mv li in mr b gy mw mx l my mz">void LevelOrder(Node * root) {<br/>    <br/>  if (root == NULL) return;<br/>  <br/>  queue&lt;Node*&gt; q;<br/>  q.push(root);</span><span id="c0c1" class="mv li in mr b gy oa mx l my mz">while (q.empty() == false) {<br/>    Node * node = q.front();<br/>    cout &lt;&lt; node -&gt; data &lt;&lt; " ";<br/>    q.pop();<br/>    if (node -&gt; left != NULL)<br/>      q.push(node -&gt; left);<br/>    if (node -&gt; right != NULL)<br/>      q.push(node -&gt; right);<br/>  }<br/>}</span></pre><p id="4f7b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里我们打印二叉树的节点。因此，我们采用队列推送根元素，并对队列中元素运行循环，将根元素的两个子元素添加到队列中，并弹出根节点。</p><p id="4fb3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">多一些 BFS 练习题:- </strong></p><div class="na nb gp gr nc nd"><a href="https://leetcode.com/problems/cousins-in-binary-tree/" rel="noopener  ugc nofollow" target="_blank"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd io gy z fp ni fr fs nj fu fw im bi translated">二叉树中的表亲- LeetCode</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">给定具有唯一值的二叉树的根以及树的两个不同节点 x 和 y 的值，返回…</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">leetcode.com</p></div></div><div class="nm l"><div class="ob l no np nq nm nr jt nd"/></div></div></a></div><div class="na nb gp gr nc nd"><a href="https://leetcode.com/problems/find-if-path-exists-in-graph/" rel="noopener  ugc nofollow" target="_blank"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd io gy z fp ni fr fs nj fu fw im bi translated">查找图形中是否存在路径- LeetCode</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">有一个有 n 个顶点的双向图，其中每个顶点被标记为从 0 到 n - 1(包括 0 和 n-1)。边缘…</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">leetcode.com</p></div></div><div class="nm l"><div class="oc l no np nq nm nr jt nd"/></div></div></a></div><div class="na nb gp gr nc nd"><a href="https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/" rel="noopener  ugc nofollow" target="_blank"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd io gy z fp ni fr fs nj fu fw im bi translated">二叉树曲折层次顺序遍历- LeetCode</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">给定二叉树的根，返回其节点值的 z 字形层次顺序遍历。(即从左到…</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">leetcode.com</p></div></div><div class="nm l"><div class="od l no np nq nm nr jt nd"/></div></div></a></div><div class="na nb gp gr nc nd"><a href="https://leetcode.com/problems/binary-tree-right-side-view/" rel="noopener  ugc nofollow" target="_blank"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd io gy z fp ni fr fs nj fu fw im bi translated">二叉树右侧视图- LeetCode</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">给定一棵二叉树的根，想象你站在它的右边，返回你…</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">leetcode.com</p></div></div><div class="nm l"><div class="oe l no np nq nm nr jt nd"/></div></div></a></div><h1 id="3e94" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">深度优先搜索</h1><blockquote class="mf mg mh"><p id="49d5" class="jv jw mi jx b jy jz ka kb kc kd ke kf mj kh ki kj mk kl km kn ml kp kq kr ks ig bi translated">深度优先搜索或深度优先遍历是一种递归算法，用于搜索图形或树数据结构的所有顶点</p></blockquote><p id="a949" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">DFS 算法的工作原理如下</p><ul class=""><li id="749a" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated">首先将图形的任意一个顶点放在堆栈的顶部。</li><li id="50f6" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">取出堆栈的顶部项目，并将其添加到已访问列表中</li><li id="d2ef" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">创建该顶点相邻音符的列表。将不在已访问列表中的添加到堆栈的顶部。</li><li id="a490" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">重复步骤 2 和 3，直到堆栈为空</li></ul><p id="de2b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">图的一般 dfs 看起来是这样的</strong></p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="bf24" class="mv li in mr b gy mw mx l my mz">void dfs(int i, vector&lt;int&gt;&amp; vis, vector&lt;int&gt; adj[], vector&lt;int&gt;&amp; res){<br/>        res.push_back(i);<br/>        vis[i] = 1;<br/>        for(auto it : adj[i]){<br/>            if(!vis[it]){<br/>               dfs(it,vis,adj,res);<br/>            }<br/>        }<br/>        return;<br/>    }<br/>    <br/>    vector&lt;int&gt; dfsOfGraph(int V, vector&lt;int&gt; adj[]) {<br/>        // Code here<br/>         vector&lt;int&gt;res;<br/>       vector&lt;int&gt;vis(V,0);<br/>       for(int i=0;i&lt;V;i++)<br/>       {<br/>           if(!vis[i])<br/>           dfs(i,vis,adj,res);<br/>       }<br/>       return res;<br/>    }</span></pre><p id="120f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">还有一些问题需要练习:- </strong></p><div class="na nb gp gr nc nd"><a href="https://leetcode.com/problems/number-of-islands/" rel="noopener  ugc nofollow" target="_blank"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd io gy z fp ni fr fs nj fu fw im bi translated">岛屿数量- LeetCode</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">提高你的编码技能，迅速找到工作。这是扩展你的知识和做好准备的最好地方…</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">leetcode.com</p></div></div><div class="nm l"><div class="of l no np nq nm nr jt nd"/></div></div></a></div><div class="na nb gp gr nc nd"><a href="https://leetcode.com/problems/redundant-connection/" rel="noopener  ugc nofollow" target="_blank"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd io gy z fp ni fr fs nj fu fw im bi translated">冗余连接- LeetCode</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">在这个问题中，树是一个无向图，它是连通的，没有圈。给你一张图表，开始…</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">leetcode.com</p></div></div><div class="nm l"><div class="og l no np nq nm nr jt nd"/></div></div></a></div><div class="na nb gp gr nc nd"><a href="https://leetcode.com/problems/flood-fill/" rel="noopener  ugc nofollow" target="_blank"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd io gy z fp ni fr fs nj fu fw im bi translated">洪水填充-洪水代码</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">图像由 m×n 整数网格图像表示，其中 image[i][j]表示图像的像素值。你…</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">leetcode.com</p></div></div><div class="nm l"><div class="oh l no np nq nm nr jt nd"/></div></div></a></div><div class="na nb gp gr nc nd"><a href="https://www.techiedelight.com/replace-occurrences-of-0-surrounded-by-1-matrix/" rel="noopener  ugc nofollow" target="_blank"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd io gy z fp ni fr fs nj fu fw im bi translated">替换二进制矩阵中所有被 1 包围的 0</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">给定一个 M × N 二进制矩阵，用 1 替换所有出现的 0，它们完全被所有的 1 包围…</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">www.techiedelight.com</p></div></div><div class="nm l"><div class="oi l no np nq nm nr jt nd"/></div></div></a></div><h1 id="c50c" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">拓扑排序</h1><blockquote class="mf mg mh"><p id="cdf7" class="jv jw mi jx b jy jz ka kb kc kd ke kf mj kh ki kj mk kl km kn ml kp kq kr ks ig bi translated">DAG(有向无环图)的拓扑排序是顶点的线性排序，使得对于每个有向边 u v，顶点 u 在排序中位于 v 之前。</p></blockquote><ul class=""><li id="d79d" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated">我们使用临时堆栈。</li><li id="396e" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">我们不立即打印顶点，</li><li id="237f" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">我们首先递归调用所有相邻顶点的拓扑排序，然后将其推入堆栈。</li><li id="f698" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">最后，打印堆栈的内容。</li></ul><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="eaf6" class="mv li in mr b gy mw mx l my mz">void dfs(int node , vector&lt;int&gt; adj[] , vector&lt;int&gt; &amp;vis , stack&lt;int&gt; &amp;st){<br/>     <br/>     <br/>     vis[node] =1;<br/>     for(auto x : adj[node]){<br/>         if(!vis[x]){<br/>             dfs(x , adj , vis , st);<br/>         }<br/>     }<br/>     <br/>     st.push(node);<br/>     <br/>     <br/> }<br/> <br/> vector&lt;int&gt; topoSort(int V, vector&lt;int&gt; adj[]) <br/> {<br/>     // code here<br/>     vector&lt;int&gt; vis(V);<br/>     stack&lt;int&gt; st;<br/>     vector&lt;int&gt; ans;<br/>     <br/>     for(int i=0;i&lt;V;i++){<br/>         if(!vis[i]){<br/>             dfs(i,adj,vis,st);<br/>         }<br/>     }<br/> <br/> <br/>     while(!st.empty()){<br/>         ans.push_back(st.top());<br/>         st.pop();<br/>     }<br/>     <br/>     return ans;<br/> }</span></pre><p id="38dd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">关于拓扑排序练习的一些问题:- </strong></p><div class="na nb gp gr nc nd"><a href="https://leetcode.com/problems/course-schedule/" rel="noopener  ugc nofollow" target="_blank"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd io gy z fp ni fr fs nj fu fw im bi translated">课程表- LeetCode</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">你总共有 numCourses 门课程要上，从 0 到 numCourses - 1。给你一个数组…</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">leetcode.com</p></div></div><div class="nm l"><div class="oj l no np nq nm nr jt nd"/></div></div></a></div><div class="na nb gp gr nc nd"><a href="https://leetcode.com/problems/longest-increasing-path-in-a-matrix/" rel="noopener  ugc nofollow" target="_blank"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd io gy z fp ni fr fs nj fu fw im bi translated">矩阵中最长增长路径- LeetCode</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">给定一个 m x n 整数矩阵，返回矩阵中最长增长路径的长度。从每个单元格中，您可以…</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">leetcode.com</p></div></div><div class="nm l"><div class="ok l no np nq nm nr jt nd"/></div></div></a></div><div class="na nb gp gr nc nd"><a href="https://leetcode.com/problems/longest-cycle-in-a-graph/" rel="noopener  ugc nofollow" target="_blank"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd io gy z fp ni fr fs nj fu fw im bi translated">图中最长的循环- LeetCode</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">给你一个从 0 到 n - 1 的 n 个节点的有向图，其中每个节点最多有一条向外的边。的…</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">leetcode.com</p></div></div><div class="nm l"><div class="ol l no np nq nm nr jt nd"/></div></div></a></div><h1 id="dca4" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">Dijkstra 算法</h1><blockquote class="mf mg mh"><p id="89cc" class="jv jw mi jx b jy jz ka kb kc kd ke kf mj kh ki kj mk kl km kn ml kp kq kr ks ig bi translated">Dijkstra 的算法允许我们找到一个图的任意两个顶点之间的最短路径。</p></blockquote><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="935f" class="mv li in mr b gy mw mx l my mz">vector &lt;int&gt; dijkstra(int V, vector&lt;vector&lt;int&gt;&gt; adj[], int S)<br/>    {<br/>        // Code here<br/>        priority_queue&lt;pair&lt;int,int&gt; , vector&lt;pair&lt;int,int&gt;&gt; , greater&lt;pair&lt;int,int&gt;&gt;&gt;pq;<br/>        <br/>        <br/>        vector&lt;int&gt; vis(V , 1e9);<br/>        <br/>   <br/>        <br/>        vis[S] = 0;<br/>        pq.push({0 , S});<br/>        <br/>        while(!pq.empty()){<br/>            int dist = pq.top().first;<br/>            int node = pq.top().second;<br/>            <br/>            pq.pop();<br/>            <br/>            <br/>            for(auto it : adj[node]){<br/>                int adjNode = it[0];<br/>                int wt = it[1];<br/>                // cout&lt;&lt;wt&lt;&lt;" "&lt;&lt;dist&lt;&lt;" "&lt;&lt;vis[adjNode]&lt;&lt;endl;<br/>                <br/>                if(dist + wt &lt; vis[adjNode]){<br/>                    vis[adjNode] = dist + wt;<br/>                    <br/>                    pq.push({dist + wt , adjNode});<br/>                }<br/>            }<br/>        }<br/>        <br/>        return vis;<br/>         <br/>    }</span></pre><p id="386c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了获得最小距离，我们在算法中使用了 min_heap 数据结构。只有该算法的实现对于编码轮和技术面试轮都是重要的。</p><h1 id="b262" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">二进位检索</h1><blockquote class="mf mg mh"><p id="169d" class="jv jw mi jx b jy jz ka kb kc kd ke kf mj kh ki kj mk kl km kn ml kp kq kr ks ig bi translated">二分搜索法是一种应用于排序数组的排序算法，通过重复地将搜索区间分成两半</p></blockquote><p id="6319" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">基本步骤是:-</p><ul class=""><li id="f5f6" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated">从整个数组的中间元素开始作为搜索关键字。</li><li id="1188" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">如果搜索关键字的值等于该项，则返回搜索关键字的索引。</li><li id="570c" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">或者，如果搜索关键字的值小于间隔中间的项目，则将间隔缩小到下半部分。</li><li id="b18c" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">否则，缩小到上半部分。</li><li id="2cb7" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">从第二点开始重复检查，直到找到值或间隔为空。</li></ul><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="ad39" class="mv li in mr b gy mw mx l my mz">int binarysearch(int arr[], int n, int k) {</span><span id="f78b" class="mv li in mr b gy oa mx l my mz">int start = 0;<br/>        int end = n-1;</span><span id="d8ff" class="mv li in mr b gy oa mx l my mz">while(s&lt;=e){<br/>            <br/>    int mid = s + (e-s)/2;<br/>            <br/>    if(arr[mid]== k){<br/>           return mid;<br/>      }<br/>    else if (k &lt; arr[mid]){<br/>        e =  mid - 1;<br/>      }<br/>     else{<br/>         s = mid + 1;<br/>      }<br/> }</span><span id="6295" class="mv li in mr b gy oa mx l my mz">   return -1;<br/> }</span></pre><p id="5882" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">用二分搜索法搜索一个元素时间复杂度为 O(logn)，而线性搜索的时间复杂度为 O(N)。</p><p id="f0a3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对于面试来说，这个算法非常重要。</p><p id="58a5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">关于二分搜索法练习的一些问题:- </strong></p><div class="na nb gp gr nc nd"><a href="https://leetcode.com/problems/search-in-rotated-sorted-array/" rel="noopener  ugc nofollow" target="_blank"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd io gy z fp ni fr fs nj fu fw im bi translated">在旋转排序数组中搜索- LeetCode</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">有一个整数数组 nums 按升序排序(具有不同的值)。在传递给你之前…</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">leetcode.com</p></div></div><div class="nm l"><div class="om l no np nq nm nr jt nd"/></div></div></a></div><div class="na nb gp gr nc nd"><a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/" rel="noopener  ugc nofollow" target="_blank"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd io gy z fp ni fr fs nj fu fw im bi translated">在旋转排序数组中查找最小值- LeetCode</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">假设按升序排序的长度为 n 的数组被旋转 1 到 n 次。例如，数组 nums =…</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">leetcode.com</p></div></div><div class="nm l"><div class="on l no np nq nm nr jt nd"/></div></div></a></div><div class="na nb gp gr nc nd"><a href="https://leetcode.com/problems/search-a-2d-matrix/" rel="noopener  ugc nofollow" target="_blank"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd io gy z fp ni fr fs nj fu fw im bi translated">搜索 2D 矩阵- LeetCode</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">写一个有效的算法，在一个 m×n 的整数矩阵中搜索一个值目标。这个矩阵有…</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">leetcode.com</p></div></div><div class="nm l"><div class="oo l no np nq nm nr jt nd"/></div></div></a></div><div class="na nb gp gr nc nd"><a href="https://leetcode.com/problems/median-of-two-sorted-arrays/" rel="noopener  ugc nofollow" target="_blank"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd io gy z fp ni fr fs nj fu fw im bi translated">两个排序数组的中值- LeetCode</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">提高你的编码技能，迅速找到工作。这是扩展你的知识和做好准备的最好地方…</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">leetcode.com</p></div></div><div class="nm l"><div class="op l no np nq nm nr jt nd"/></div></div></a></div><p id="d37a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">排序算法对面试也很重要。如果你想通过这篇博客了解所有的排序算法，我解释了每个排序算法的细节和代码。</p><div class="na nb gp gr nc nd"><a href="https://medium.com/@mgarg6858/sorting-algorithms-asked-in-interviews-2df23be8b348" rel="noopener follow" target="_blank"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd io gy z fp ni fr fs nj fu fw im bi translated">面试中问到的排序算法</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">整理</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">算法在采访中问 Sortingmedium.com</p></div></div><div class="nm l"><div class="oq l no np nq nm nr jt nd"/></div></div></a></div></div></div>    
</body>
</html>