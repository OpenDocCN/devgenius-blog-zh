<html>
<head>
<title>Node JS : Modeling Relationalship between connected data mongoDB</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node JS:建模连接数据之间的关系 mongoDB</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/node-js-modeling-relationalship-between-connected-data-mongodb-9dc208a950e6?source=collection_archive---------2-----------------------#2022-03-12">https://blog.devgenius.io/node-js-modeling-relationalship-between-connected-data-mongodb-9dc208a950e6?source=collection_archive---------2-----------------------#2022-03-12</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><h1 id="5988" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">建模关系</h1><p id="688d" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">数据建模的主要挑战是平衡应用程序的需求、数据库引擎的性能特征和数据检索模式。在设计数据模型时，始终要考虑数据的应用程序用法(即数据的查询、更新和处理)以及数据本身的固有结构。</p><p id="f91f" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">为 MongoDB 应用程序设计数据模型的关键决策围绕着文档的结构以及应用程序如何表示数据之间的关系。MongoDB 允许将相关数据嵌入到单个文档中。</p><h1 id="0af3" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">参考文件</h1><p id="f58f" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">引用通过包含从一个文档到另一个文档的链接或<em class="ll">引用</em>来存储数据之间的关系。应用程序可以解析这些<a class="ae lm" href="https://docs.mongodb.com/manual/reference/database-references/" rel="noopener ugc nofollow" target="_blank">引用</a>来访问相关数据。概括地说，这些是<em class="ll">标准化的</em>数据模型。</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi ln"><img src="../Images/ef5896c9bda7efc7f937e7ee5b50e9a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hdJGqstfh6sOCIkhyaeY9Q.png"/></div></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk translated">参考文件</figcaption></figure><pre class="lo lp lq lr gt md me mf mg aw mh bi"><span id="64cf" class="mi jl in me b gy mj mk l ml mm">//MODEL AUTHOR</span><span id="62ac" class="mi jl in me b gy mn mk l ml mm">const Author = mongoose.model('Author', new mongoose.Schema({</span><span id="92d7" class="mi jl in me b gy mn mk l ml mm">name: String,</span><span id="75ca" class="mi jl in me b gy mn mk l ml mm">bio: String,</span><span id="4535" class="mi jl in me b gy mn mk l ml mm">website: String</span><span id="cde0" class="mi jl in me b gy mn mk l ml mm">}));</span><span id="e33c" class="mi jl in me b gy mn mk l ml mm"><br/>//MODEL COURSE was relationalship with Author model<br/></span><span id="93ef" class="mi jl in me b gy mn mk l ml mm">const Course = mongoose.model('Course', new mongoose.Schema({</span><span id="3382" class="mi jl in me b gy mn mk l ml mm">name: String,</span><span id="f854" class="mi jl in me b gy mn mk l ml mm">authorId:{</span><span id="95da" class="mi jl in me b gy mn mk l ml mm">type: mongoose.Schema.Types.ObjectId,</span><span id="3e6d" class="mi jl in me b gy mn mk l ml mm">ref:'Author'</span><span id="d18a" class="mi jl in me b gy mn mk l ml mm">}</span><span id="08bc" class="mi jl in me b gy mn mk l ml mm">}));</span></pre><p id="12ad" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">创建作者模型</p><pre class="lo lp lq lr gt md me mf mg aw mh bi"><span id="9931" class="mi jl in me b gy mj mk l ml mm">async function createAuthor(name, bio, website) {</span><span id="0621" class="mi jl in me b gy mn mk l ml mm">     const author = new Author({name, bio, website });</span><span id="717c" class="mi jl in me b gy mn mk l ml mm">     const result = await author.save();</span><span id="fde9" class="mi jl in me b gy mn mk l ml mm">console.log(result);</span><span id="116c" class="mi jl in me b gy mn mk l ml mm">}</span><span id="2821" class="mi jl in me b gy mn mk l ml mm">createAuthor('Ika', 'My bio', 'My Website');</span></pre><p id="5519" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">创建课程模型</p><pre class="lo lp lq lr gt md me mf mg aw mh bi"><span id="b36c" class="mi jl in me b gy mj mk l ml mm">async function createCourse(name, authorId) {</span><span id="77b6" class="mi jl in me b gy mn mk l ml mm">   const course = new Course({name, authorId});</span><span id="6f61" class="mi jl in me b gy mn mk l ml mm">   const result = await course.save();</span><span id="d839" class="mi jl in me b gy mn mk l ml mm">console.log(result);</span><span id="0bbe" class="mi jl in me b gy mn mk l ml mm">}</span><span id="6431" class="mi jl in me b gy mn mk l ml mm">createCourse('Node Course', '622b551b1b348da807f723c0')//(nameCourse , authorId)</span></pre><p id="fdc0" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">列出课程</p><pre class="lo lp lq lr gt md me mf mg aw mh bi"><span id="2315" class="mi jl in me b gy mj mk l ml mm">async function listCourses() {</span><span id="0e50" class="mi jl in me b gy mn mk l ml mm">const courses = await Course</span><span id="a889" class="mi jl in me b gy mn mk l ml mm">.find()</span><span id="dcde" class="mi jl in me b gy mn mk l ml mm">.populate('authorId')// find all populate in author model</span><span id="2141" class="mi jl in me b gy mn mk l ml mm">.select('name');</span><span id="0b2c" class="mi jl in me b gy mn mk l ml mm">console.log(courses);</span><span id="1ead" class="mi jl in me b gy mn mk l ml mm">}</span><span id="065c" class="mi jl in me b gy mn mk l ml mm">listCourses();</span></pre><p id="6f59" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">。populate()用于显示关系表中的所有人口。在中，将按关系 authorId 显示表 author 的所有内容。</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi mo"><img src="../Images/7e09178f0e34b4adfbffc915726f7ee9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YgqKms8M72-4M4yDUn6Q3Q.png"/></div></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk translated">结果。填充()</figcaption></figure><h1 id="3b0e" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">嵌入文档</h1><p id="23a6" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">为了对连接的数据之间的关系进行建模，我们可以引用一个文档或者将它嵌入到另一个文档中。当引用一个文档时，这两个文档之间确实没有关系。因此，引用不存在的文档是可能的。当您想要实施数据一致性时，引用文档(规范化)是一个好方法。因为数据库中只有一个对象实例。但是这种方法对查询性能有负面影响，因为在 MongoDB 中，我们不能像在关系数据库中那样连接文档。因此，为了获得一个文档及其相关文档的完整表示，我们需要向数据库发送多个查询。嵌入文档(反规范化)解决了这个问题。我们可以通过一个查询读取文档的完整表示。所有必要的数据都嵌入在一个文档及其子文档中。但这也意味着我们将在不同的地方有多个数据拷贝。虽然目前存储不是问题，但拥有多个副本意味着对原始文档所做的更改可能不会传播到所有副本。如果数据库服务器在更新过程中死机，一些文档将会不一致。对于每一项业务，对于每一个问题，你都需要问这样一个问题:“我们能容忍数据在短时间内不一致吗？”如果没有，你必须使用参考。但同样，这意味着您的查询会更慢。</p><p id="b7f4" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated"><strong class="kk io">引用单据</strong></p><pre class="lo lp lq lr gt md me mf mg aw mh bi"><span id="07ec" class="mi jl in me b gy mj mk l ml mm">async function listCourses() {</span><span id="ea4d" class="mi jl in me b gy mn mk l ml mm">const courseSchema = new mongoose.Schema({ author: { type: mongoose.Schema.Types.ObjectId, ref: ‘Author’ } })</span></pre><p id="6505" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated"><strong class="kk io">引用文档</strong></p><pre class="lo lp lq lr gt md me mf mg aw mh bi"><span id="3e43" class="mi jl in me b gy mj mk l ml mm">const courseSchema = new mongoose.Schema({ <br/>author: {   <br/>       type: new mongoose.Schema({             <br/>       name: String,              <br/>       bio: String         <br/>      })   <br/>    } <br/>}) </span><span id="2551" class="mi jl in me b gy mn mk l ml mm">const Course =</span></pre><p id="cf64" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">嵌入的文档没有保存方法。它们只能保存在其父对象的上下文中。</p><p id="d117" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated"><strong class="kk io">更新嵌入文档</strong></p><pre class="lo lp lq lr gt md me mf mg aw mh bi"><span id="0c7d" class="mi jl in me b gy mj mk l ml mm">const course = await Course.findById(courseId);<br/>course.author.name = ‘New Name’; <br/>course.save();</span></pre><p id="c3f4" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">embedding.js 的所有代码</p><pre class="lo lp lq lr gt md me mf mg aw mh bi"><span id="1552" class="mi jl in me b gy mj mk l ml mm">const mongoose = require('mongoose');</span><span id="155f" class="mi jl in me b gy mn mk l ml mm">//CONNECTION DATABASE</span><span id="ec97" class="mi jl in me b gy mn mk l ml mm">mongoose.connect('mongodb://localhost/playground')</span><span id="bda7" class="mi jl in me b gy mn mk l ml mm">.then(() =&gt; console.log('Connected to MongoDB...'))</span><span id="f472" class="mi jl in me b gy mn mk l ml mm">.catch(err =&gt; console.error('Could not connect to MongoDB...', err));</span><span id="841e" class="mi jl in me b gy mn mk l ml mm">//MODEL AUTHOR</span><span id="b34b" class="mi jl in me b gy mn mk l ml mm">const authorSchema = new mongoose.Schema({</span><span id="373a" class="mi jl in me b gy mn mk l ml mm">       name: String,</span><span id="1de4" class="mi jl in me b gy mn mk l ml mm">       bio: String,</span><span id="4a24" class="mi jl in me b gy mn mk l ml mm">       website: String  });</span><span id="5b47" class="mi jl in me b gy mn mk l ml mm">const Author = mongoose.model('Author', authorSchema);</span><span id="bc30" class="mi jl in me b gy mn mk l ml mm">//MODEL COURSE</span><span id="7ac8" class="mi jl in me b gy mn mk l ml mm">const Course = mongoose.model('Course', new mongoose.Schema({</span><span id="b625" class="mi jl in me b gy mn mk l ml mm">         name: String,</span><span id="c85e" class="mi jl in me b gy mn mk l ml mm">         authors:[authorSchema]}));</span><span id="967b" class="mi jl in me b gy mn mk l ml mm">                            //CRUD</span><span id="b657" class="mi jl in me b gy mn mk l ml mm">//CREATE COURSE</span><span id="144e" class="mi jl in me b gy mn mk l ml mm">async function createCourse(name, authors) {</span><span id="b2f3" class="mi jl in me b gy mn mk l ml mm">const course = new Course({ name, authors });</span><span id="b0bd" class="mi jl in me b gy mn mk l ml mm">const result = await course.save();</span><span id="8c5f" class="mi jl in me b gy mn mk l ml mm">console.log(result);</span><span id="aa12" class="mi jl in me b gy mn mk l ml mm">}</span><span id="e072" class="mi jl in me b gy mn mk l ml mm">//READ COURSES</span><span id="9818" class="mi jl in me b gy mn mk l ml mm">async function listCourses() {</span><span id="7d48" class="mi jl in me b gy mn mk l ml mm">const courses = await Course.find();<br/>console.log(courses);</span><span id="6905" class="mi jl in me b gy mn mk l ml mm">}</span><span id="ca94" class="mi jl in me b gy mn mk l ml mm">//UPDATE COURSE</span><span id="c5b9" class="mi jl in me b gy mn mk l ml mm">async function update(courseId) {</span><span id="97d1" class="mi jl in me b gy mn mk l ml mm">const course = await Course.findById(courseId);</span><span id="dfdb" class="mi jl in me b gy mn mk l ml mm">course.author.name="Ika sari apriliyani";</span><span id="7d81" class="mi jl in me b gy mn mk l ml mm">course.save()</span><span id="4bfa" class="mi jl in me b gy mn mk l ml mm">console.log(course);</span><span id="22be" class="mi jl in me b gy mn mk l ml mm">}</span><span id="ddd6" class="mi jl in me b gy mn mk l ml mm">async function addAuthor(courseId,author) {</span><span id="b195" class="mi jl in me b gy mn mk l ml mm">const course=await Course.findById(courseId);</span><span id="5ceb" class="mi jl in me b gy mn mk l ml mm">course.authors.push(author)</span><span id="5e3c" class="mi jl in me b gy mn mk l ml mm">course.save()</span><span id="719f" class="mi jl in me b gy mn mk l ml mm">}</span><span id="e68b" class="mi jl in me b gy mn mk l ml mm">//DELETE COURSE</span><span id="2712" class="mi jl in me b gy mn mk l ml mm">async function removeAuthor(courseId,authorId) {</span><span id="e414" class="mi jl in me b gy mn mk l ml mm">const course=await Course.findById(courseId);</span><span id="df45" class="mi jl in me b gy mn mk l ml mm">const author = await course.authors.id(authorId)</span><span id="73e6" class="mi jl in me b gy mn mk l ml mm">author.remove()</span><span id="bcd8" class="mi jl in me b gy mn mk l ml mm">course.save()</span><span id="3e1e" class="mi jl in me b gy mn mk l ml mm">}</span><span id="ba82" class="mi jl in me b gy mn mk l ml mm">//createCourse(name, authors)</span><span id="bdf5" class="mi jl in me b gy mn mk l ml mm">//listCourses()</span><span id="5755" class="mi jl in me b gy mn mk l ml mm">// update('622cc20af81c5e7c38e80a3a')</span><span id="7ad6" class="mi jl in me b gy mn mk l ml mm">// createCourse('Node Course', [new Author({ name: 'Ika' })]);</span><span id="2928" class="mi jl in me b gy mn mk l ml mm">// addAuthor('622ccaa98004b2252cee4310', new Author({ name: 'Amy' }));</span><span id="1db5" class="mi jl in me b gy mn mk l ml mm">// removeAuthor('622ccaa98004b2252cee4310','622ccb54ec686c07c6038c18')</span></pre><h1 id="00f7" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">处理</h1><p id="a4a7" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">我们在 MongoDB 中没有交易。为了实现事务，我们使用一种称为“两阶段提交”的模式。如果你不想手动实现这个模式，使用福恩·NPM 包:</p><p id="0496" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">使用 Fawn 实现事务</p><pre class="lo lp lq lr gt md me mf mg aw mh bi"><span id="c011" class="mi jl in me b gy mj mk l ml mm"> try {    <br/>         await new Fawn.Task()        <br/>         .save(‘rentals’, newRental)       <br/>         .update(‘movies’, { _id: movie._id }, <br/>{ $inc:numberInStock: -1 }})                                              .run(); } <br/>catch (ex) {     // At this point, all operations are automatically rolled back}</span></pre><h1 id="c923" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">对象 ID</h1><p id="95fe" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">ObjectIDs 几乎是唯一的。理论上，两个 ObjectIDs 有可能相等，但对于大多数现实应用程序来说，这种可能性非常低(1/16，000，000)。</p><p id="3c52" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">ObjectIDs 由 MongoDB 驱动程序生成，用于唯一地标识文档。它们由 12 个字节组成:</p><ul class=""><li id="1e38" class="mp mq in kk b kl lg kp lh kt mr kx ms lb mt lf mu mv mw mx bi translated">4 字节:时间戳</li><li id="f810" class="mp mq in kk b kl my kp mz kt na kx nb lb nc lf mu mv mw mx bi translated">3 字节:机器标识符</li><li id="34ff" class="mp mq in kk b kl my kp mz kt na kx nb lb nc lf mu mv mw mx bi translated">2 字节:进程标识符</li><li id="4472" class="mp mq in kk b kl my kp mz kt na kx nb lb nc lf mu mv mw mx bi translated">3 个是:柜台</li></ul><p id="ce62" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">验证 ObjectIDs</p><pre class="lo lp lq lr gt md me mf mg aw mh bi"><span id="e449" class="mi jl in me b gy mj mk l ml mm">mongoose.Types.ObjectID.isValid(id);</span></pre><p id="c17f" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">要使用 joi 验证 objectid，请使用 joi-objectid NPM 包。</p><p id="72ef" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated"><em class="ll">主 Reff 从节点 JS 航向代码带 Mosh </em></p></div></div>    
</body>
</html>