# Swift 中的固体原理——界面分离原理

> 原文：<https://blog.devgenius.io/solid-principles-in-swift-interface-segregation-principle-d15a4804b4ae?source=collection_archive---------10----------------------->

![](img/f0edd07fafdd279795e302625129db26.png)

克里斯里德在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的照片

# 背景

在这一系列的帖子中，我们将涉及软件开发的坚实原则。这些是一组原则/指导方针，当开发软件系统时遵循这些原则/指导方针，使得系统随着时间的推移更容易扩展和维护。让我们来看看他们寻求解决的问题:

*   脆弱性:一个变化可能会破坏意想不到的部分，如果你没有一个好的测试覆盖率，这是很难检测到的
*   不可移动性:一个组件很难在另一个项目或同一个项目的多个地方重用，因为它有太多耦合的依赖关系
*   刚性:变更需要大量的努力，因为它影响到项目的几个部分

那么坚实的原则是什么呢？

*   单一责任原则——一个类应该只有一个责任/只有一个改变的理由
*   开闭原则——软件应该对扩展开放，但对修改关闭
*   Liskov 替换原则——程序中的对象应该可以用其子类型的实例替换，而不会改变程序的正确性
*   接口分离原则——许多特定于客户端的接口比一个通用接口要好
*   依赖倒置原则——高级模块不应该依赖低级模块。两者都应该依赖于抽象

在本文中，我们将关注接口分离原则。

# 这是什么意思？

该原理的概要如下:

> *许多客户端专用接口比一个通用接口更好*

在 Swift 中，我们使用[协议](https://docs.swift.org/swift-book/LanguageGuide/Protocols.html)而不是 Java 等语言中的接口，因此从现在开始我们将把接口称为协议。

这条规则的目的，与《坚实原理》中的其他一些规则相比，是非常直接的。这意味着创建较小的协议比创建一个定义了许多方法的大协议要好。

# 有什么问题吗

那么，为什么拥有一个大型协议会带来问题呢？让我们检查一个经典的 Cocoa Touch 协议，看看为什么这是一个问题。

我确信你们中的许多人在过去的某个时候已经实现了这个协议；)我稍微修改了源代码，使其更容易阅读和理解，那么我们为什么要看这个呢？

1.  在前两个方法中，您只需要实现两个方法。
2.  其余的方法都是可选的，您可以实现您想使用的任何方法。

现在，这个协议已经植根于[目标 C](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/Introduction/Introduction.html) 帮助它在某种程度上掩盖了这个问题。在 Objective C 中，你可以在上面的代码中看到，可以将某些函数标记为可选的。这意味着你可以实现它们，如果你想的话，但不是必须的，这允许这个协议声明包含太多的方法，而不会给实现类带来问题。

在 Swift 中，不可能将功能标记为可选，所有功能都需要实施。让我们把上面的协议更新得更快一些，看看会给我们带来什么问题。

现在我们已经将我们的协议转换得更快了，当我们试图使一个类符合这个协议时，这会导致什么问题呢？让我们看一个例子。

我们上面的类现在必须实现每一个协议方法。即使我们不打算使用它。在协议的 objective c 实现中，我们可以选择只实现我们需要的方法，而现在我们必须实现每一个方法。想象一下，为了符合这个协议，世界上所有的视图控制器都充满了空方法！

该协议打破了接口隔离原则。

# 更好的解决方案

为了改进解决方案，我们可以将一个大的接口分解成更小的协议。这样，我们可以只遵循我们感兴趣的协议来实现我们的功能。这可能看起来像:

1.  UITableViewDataSource —对于我们熟悉的两个强制方法
2.  uitableviewssectionsdatasource—用于与多节方法相关的方法
3.  UITableViewSectionTitles —用于与节中的页眉和页脚相关的方法
4.  UITableViewEditable —用于与编辑和移动单元格相关的方法

通过这种方式，我们可以选择我们想要的方法，而不是一个大的接口，我们可能只想要方法的一个小的子集。

# 一个好例子

iOS SDK 中接口分离的一个很好的例子是 Codable。可编码的定义如下:

基本上，Codable 是另外两个协议的组合:可解码和可编码。这是如何进行接口分离的一个很好的例子。如果您正在构建一个 JSON 解析结构，您可能希望只遵循 Decodable，这样您就可以解码 JSON。如果将来您想要序列化数据存储之类的结构，您可以在以后需要时遵循编码。

# 摘要

在我看来，接口分离原则是最容易理解的原则。基本上，这意味着不要创建一个包含许多方法的大协议，这些方法并不总是需要根据实现需求来实现。

取而代之的是，将协议分成更小的协议，只包含单个功能工作所需的方法。这不仅避免了许多冗余的方法，而且通过允许将功能分解到不同的类中，有助于简化单一责任原则。例如，您可以用不同的类来处理不同的活动，而不是用一个包含所有功能的大类。

*原载于 2022 年 5 月 3 日*[*https://pyartez . github . io*](https://pyartez.github.io/architecture/solid-principles-in-swift-interface-segragation-principle.html)*。*