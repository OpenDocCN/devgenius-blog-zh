<html>
<head>
<title>How to Create an Apple Card Payment Dial — Part 3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何创建Apple Card支付拨号——第3部分</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/constraint-the-thumbs-center-to-it-s-super-view-how-to-create-an-apple-card-payment-dial-part-3-eb1e670ec49c?source=collection_archive---------20-----------------------#2020-06-19">https://blog.devgenius.io/constraint-the-thumbs-center-to-it-s-super-view-how-to-create-an-apple-card-payment-dial-part-3-eb1e670ec49c?source=collection_archive---------20-----------------------#2020-06-19</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="4469" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">用户交互和事件处理。</strong></p><p id="46cf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在<a class="ae ki" href="https://medium.com/@hayder_41070/how-to-create-an-apple-card-payment-dial-bdbae4017c21" rel="noopener">第一部分</a>中，我们设计了基本接口。在《T21》第二部分中，我们开发了一种弯曲文本的方法。在这一部分中，我们将了解如何与表盘互动。</p><p id="1b60" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们从在表盘上添加一个拇指开始。打开<strong class="jm io"> PaymentDialView.xib </strong>在顶层添加一个子视图，使其成为最前面的视图，称之为<em class="kj">缩略图视图</em>。</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi kk"><img src="../Images/3004f653677904071e5529ee716d8203.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L-uCk4Ze0-qzICryuHFfRQ.jpeg"/></div></div></figure><p id="529a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">添加宽度和高度约束，将其值设置为56。</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi kk"><img src="../Images/ece70c8223478ef676f5fc9a3f17c075.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CHvmLycgDAk7TzsvrRo-dQ.jpeg"/></div></div></figure><p id="f280" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">将拇指的中心约束到它的超级视图。</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi kk"><img src="../Images/0834bb1e48d7e6b721c12003f04034a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8DCwYRxG8WOuY8ypwQ83RQ.png"/></div></div></figure><p id="c39d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">回到<code class="fe kw kx ky kz b">PaymentDialView</code>，添加下面的<code class="fe kw kx ky kz b">IBOutlet</code>并连接。</p><figure class="kl km kn ko gt kp"><div class="bz fp l di"><div class="la lb l"/></div></figure><p id="5389" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">将<code class="fe kw kx ky kz b">thumbCenterXConstraint</code>连接到<em class="kj">界面生成器</em>中标有“Thumb View.centerX = centerX”的顶视图约束，如下所示:</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi lc"><img src="../Images/729e1ff9fce984800fee89e8c2511324.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d8DtcMkm67VfhhWoifknWQ.jpeg"/></div></div></figure><p id="fdf4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">以类似的方式将<code class="fe kw kx ky kz b">thumbCenterYConstraint</code>连接到“Thumb View.centerY = centerY”。</p><p id="3b72" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在<code class="fe kw kx ky kz b">commonInit()</code>中添加一个名为<code class="fe kw kx ky kz b">setupThumb()</code>的新功能，我们将设置拇指的圆角半径、边框并给它添加阴影。</p><figure class="kl km kn ko gt kp"><div class="bz fp l di"><div class="la lb l"/></div></figure><p id="c4b3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当我们打开<strong class="jm io"> Main.storyboard </strong>时，我们可以直接在<em class="kj">界面构建器</em>中看到更改的结果。我们应该看到我们的拇指在表盘中间。我们需要它在边缘，让我们现在修复它。</p><p id="2944" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们希望刻度盘位于由<code class="fe kw kx ky kz b">dialBody</code>和<code class="fe kw kx ky kz b">textView</code>形成的边框的中心。我们不需要每次都计算这个距离，只需要在视图的约束更新的时候。我们将把这个值存储在一个新变量中，这个变量只在<code class="fe kw kx ky kz b">updateConstraints()</code>中更新。</p><figure class="kl km kn ko gt kp"><div class="bz fp l di"><div class="la lb l"/></div></figure><p id="56ec" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe kw kx ky kz b">distanceFromCenter</code>是<code class="fe kw kx ky kz b">textView</code>的半径和<code class="fe kw kx ky kz b">thumbView</code>的半径之和减去拇指的边框宽度。<br/>将<code class="fe kw kx ky kz b">thumbCenterXConstraint</code>设置为<code class="fe kw kx ky kz b">distanceFromCenter</code>将产生以下结果:</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi kk"><img src="../Images/890efb3306aca6bf6217d3e8b8b86642.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zkEaiqCLavJaEoEAzE-MNQ.jpeg"/></div></div></figure><p id="a014" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你会注意到我们把它移到了一个新的函数中，这个函数在<code class="fe kw kx ky kz b">updateConstraints</code>中被调用，我们很快就会在其他地方使用它。让我们也将<code class="fe kw kx ky kz b">thumbCenterYConstraint</code>设置为<code class="fe kw kx ky kz b">distanceFromCenter</code>，我们最终得到:</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi kk"><img src="../Images/3fd7e1ca09ab23541c057cdb3dc83849.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BJ9KD3aWMxHMJcWtyH0yGQ.jpeg"/></div></div></figure><p id="cc8c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">不是我们想要的地方！为了解决这个问题，我们需要使用一些基本的三角学来寻找圆上的点。</p><p id="c758" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们声明一个新的变量<code class="fe kw kx ky kz b">angle</code>,它将保存从我们拇指中心到刻度盘中心的线的角度。</p><figure class="kl km kn ko gt kp"><div class="bz fp l di"><div class="la lb l"/></div></figure><p id="4378" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们现在可以像这样更新拇指中心约束:</p><figure class="kl km kn ko gt kp"><div class="bz fp l di"><div class="la lb l"/></div></figure><p id="df47" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果我们设定角度= -。pi/4.0，我们可以在下图中看到，拇指停留在由<code class="fe kw kx ky kz b">dialBody</code>和<code class="fe kw kx ky kz b">textView</code>形成的边界构成的圆内。</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi kk"><img src="../Images/14103678e4856cb58ed454486eabee3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*umyByq1B4N_s-6ntKlWBkw.jpeg"/></div></div></figure><h1 id="3f1f" class="ld le in bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">与拇指互动</h1><p id="510e" class="pw-post-body-paragraph jk jl in jm b jn mb jp jq jr mc jt ju jv md jx jy jz me kb kc kd mf kf kg kh ig bi translated">为了与我们的拇指互动，我们将添加一个平移手势。转到<em class="kj"> PaymentDialView.xib </em>并将<strong class="jm io"> UIPanGestureRecognizer </strong>拖动到左侧的<strong class="jm io">文档轮廓</strong>窗格。<br/>右键单击<em class="kj">缩略图</em>，拖动<strong class="jm io">手势识别器</strong>出口到<strong class="jm io">平移手势识别器</strong>对象，如下图所示。</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi lc"><img src="../Images/17ddb092f2d3d78ea3302f920e9e4200.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*egQoNbs-iw9rvOfGZL7Btw.jpeg"/></div></div></figure><p id="5d0b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在<strong class="jm io"> PaymentDialView.swift </strong>中为我们的平移手势添加一个<code class="fe kw kx ky kz b">@IBAction</code>。</p><figure class="kl km kn ko gt kp"><div class="bz fp l di"><div class="la lb l"/></div></figure><p id="641f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在<strong class="jm io"> PaymentDialView.xib </strong>中将手势识别器的<strong class="jm io">发送动作</strong>连接到<strong class="jm io">文件的所有者</strong> <code class="fe kw kx ky kz b">thumbViewPanned()</code></p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi lc"><img src="../Images/b066d69ee3a132ddac0b4131ac56151c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mHGnlqtN2m6_XL_NuHdK1Q.jpeg"/></div></div></figure><p id="725b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在<strong class="jm io"> PaymentDialView.swift </strong>中，将以下内容添加到<code class="fe kw kx ky kz b">thumbViewPanned</code>:</p><figure class="kl km kn ko gt kp"><div class="bz fp l di"><div class="la lb l"/></div></figure><p id="d002" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">上面的函数，是平移相对于表盘中心的位置，这样我们就可以找到生命点和圆心之间的直线。然后，我们使用<a class="ae ki" href="https://en.wikipedia.org/wiki/Atan2" rel="noopener ugc nofollow" target="_blank"> atan2 </a>找到直线与x轴的夹角，以更新我们的<code class="fe kw kx ky kz b">angle</code>变量。一旦我们有了角度，我们可以更新我们的拇指约束。</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi mg"><img src="../Images/ae952301e8db10ea6ab8fe837f89caed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*0sMceVmCuOo9s0gL7laAPQ.gif"/></div></div></figure><h1 id="45b0" class="ld le in bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">楔子</h1><p id="aff6" class="pw-post-body-paragraph jk jl in jm b jn mb jp jq jr mc jt ju jv md jx jy jz me kb kc kd mf kf kg kh ig bi translated">在苹果牌表盘上，12点钟的位置，有一个半圆，姑且称之为楔形。它限制了拇指的活动，所以它不能通过它。让我们将它添加到我们的视图中。</p><p id="ba98" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">转到<em class="kj"> PaymentDialView.xib </em>，在<em class="kj">表盘主体</em>和<em class="kj">文本视图</em>之间添加一个视图。给它起个名字<strong class="jm io">楔形容器</strong>。<br/>选择<strong class="jm io">楔形容器</strong>和<strong class="jm io">缩略图</strong>并将其约束设置为<em class="kj">等宽</em>和<em class="kj">等高</em>。</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi kk"><img src="../Images/3c29ae03e37422a35df4d7c953097f75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8hzj_50T5L_WtrCBQvY2Bg.jpeg"/></div></div></figure><p id="1780" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">取消选择<strong class="jm io">缩略图视图</strong>并打开右侧<strong class="jm io">检查器</strong>窗格中的<strong class="jm io">尺寸</strong>检查器。在<em class="kj">水平</em>约束部分的“等宽:缩略图”上点击<strong class="jm io">编辑</strong>。将<strong class="jm io">乘数</strong>设置为2。这将使<strong class="jm io">楔形容器</strong>的宽度为<strong class="jm io">缩略图</strong>宽度的一半。</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi kk"><img src="../Images/6850a6557fdb955bbb2f8ea0cb4d5539.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qBT5tZB_tEVgFhlvNpAEBA.jpeg"/></div></div></figure><p id="dafe" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">向<strong class="jm io">楔形容器</strong>添加与其超级视图相关的顶部和前导约束。</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi kk"><img src="../Images/3b90704b8906bf7e6a89e61fde9e4dc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dcNz_QSjJFk7OeUzX48lDA.jpeg"/></div></div></figure><p id="ba31" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">回到右侧<strong class="jm io">检查器</strong>窗格中的<strong class="jm io">尺寸</strong>检查器，双击<em class="kj">水平</em>约束部分中的“行距为:超级视图”。在<em class="kj">领先对正约束</em>部分，将<em class="kj">第二项</em>改为<strong class="jm io">超级视图。将X </strong>居中，并将<strong class="jm io">常量</strong>值更改为0。</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi kk"><img src="../Images/c9cf519c3f9da18e880b017477988aee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eoeW1JXsEsJNDhdQuLamug.jpeg"/></div></div></figure><p id="918b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在<strong class="jm io">属性</strong>检查器中，将<strong class="jm io">楔形体容器</strong>的背景色设置为<strong class="jm io">透明色</strong>并选择<strong class="jm io">剪辑到边界</strong>。</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi kk"><img src="../Images/2ab564dfdd74331a038e1d7beed89089.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D4NWbBgWg39h-FjKEzXYgQ.jpeg"/></div></div></figure><p id="f22e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在<strong class="jm io">楔形容器</strong>内添加一个子视图，命名为<strong class="jm io">楔形视图</strong>。选择<strong class="jm io">楔形容器</strong>和<strong class="jm io">缩略图</strong>以及<em class="kj">等宽</em>和<em class="kj">等高</em>的约束。</p><p id="fcc8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">取消选择<strong class="jm io">缩略图视图</strong>，在<strong class="jm io">楔形视图</strong>仍被选中的情况下，添加值为0的顶部和尾部约束。将其背景颜色设置为与<strong class="jm io">表盘主体</strong>相同的颜色。</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi kk"><img src="../Images/f8c39763b4289b689d5ec19c252c71b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7xUYW2T6dE80qSnAWpu0kw.jpeg"/></div></div></figure><p id="4372" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在<strong class="jm io"> PaymentDialView </strong>中为<strong class="jm io">楔形视图</strong>创建一个<code class="fe kw kx ky kz b">IBOutlet</code>并连接。</p><figure class="kl km kn ko gt kp"><div class="bz fp l di"><div class="la lb l"/></div></figure><p id="1841" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们现在需要设置<strong class="jm io">楔形视图</strong>的图层边框颜色、宽度和圆角半径属性，我们将在代码中完成，并将该函数添加到我们的<code class="fe kw kx ky kz b">commonInit()</code>方法中。</p><figure class="kl km kn ko gt kp"><div class="bz fp l di"><div class="la lb l"/></div></figure><p id="7a4a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">由于<strong class="jm io">楔形视图</strong>的超级视图是<strong class="jm io">楔形视图</strong>的一半宽度，它将为我们裁剪视图，只渲染半个圆，给我们我们想要的效果。</p><p id="8f4c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">要查看结果，只需打开<strong class="jm io"> Main.storyboard </strong>并在<em class="kj">界面构建器</em>中实时查看。</p><p id="116b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我想借此机会说<em class="kj">我真的很喜欢界面构建器</em>。</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi kk"><img src="../Images/a43a0e72c407995155d159bdf4303447.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h00VB0xc3mQ_kU2Gt8HRmw.jpeg"/></div></div></figure><h1 id="f533" class="ld le in bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">表盘的标记</h1><p id="fdd0" class="pw-post-body-paragraph jk jl in jm b jn mb jp jq jr mc jt ju jv md jx jy jz me kb kc kd mf kf kg kh ig bi translated">Apple Card表盘上有4个标记，当用户到达一个标记时，表盘的边框会改变颜色。我们稍后会谈到颜色变化，但是现在，让我们添加标记。我们在这里要发疯了，在代码中添加标记，而不是界面构建器，更准确的位置，我们可以通过它们循环。<br/>我创建了一个名为MarkerView的简单视图，它看起来是这样的:</p><figure class="kl km kn ko gt kp"><div class="bz fp l di"><div class="la lb l"/></div></figure><p id="af46" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在<strong class="jm io"> PaymentDialView.swift </strong>中像这样声明一个名为<code class="fe kw kx ky kz b">markers</code>的变量:</p><figure class="kl km kn ko gt kp"><div class="bz fp l di"><div class="la lb l"/></div></figure><p id="82ef" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">创建一个名为<code class="fe kw kx ky kz b">addMarkers()</code>的函数:</p><figure class="kl km kn ko gt kp"><div class="bz fp l di"><div class="la lb l"/></div></figure><p id="1c0b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">从<code class="fe kw kx ky kz b">commonInit()</code>内部调用它，然后创建另一个名为<code class="fe kw kx ky kz b">updateMarkers()</code>的函数:</p><figure class="kl km kn ko gt kp"><div class="bz fp l di"><div class="la lb l"/></div></figure><p id="4e48" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">从<code class="fe kw kx ky kz b">updateConstraints()</code>内部调用这个函数。<br/>检查<strong class="jm io"> Main.storyboard </strong>，表盘视图现在应该是这样的:</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi kk"><img src="../Images/6854aefbcaf4f72db27ce0dec1bfab46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Edt3Qy6RN6Fl1eH0feJ1MQ.jpeg"/></div></div></figure><p id="4f4a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在我们有了一个视觉指示器来指示拇指应该停在哪里，还有标记，让我们让它实际停在那里。</p><h1 id="59d1" class="ld le in bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">起点</h1><p id="a943" class="pw-post-body-paragraph jk jl in jm b jn mb jp jq jr mc jt ju jv md jx jy jz me kb kc kd mf kf kg kh ig bi translated">拇指应该从第一个标记开始。让我们覆盖<code class="fe kw kx ky kz b">didMoveToSuperview()</code>来设置第一次启动时的拇指位置。</p><figure class="kl km kn ko gt kp"><div class="bz fp l di"><div class="la lb l"/></div></figure><p id="f23b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">添加上述方法将产生以下效果:</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi kk"><img src="../Images/5becf235b5133bedcc1e8c60f4de296a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AqnzXx4uBzPOPt9C_vehAg.jpeg"/></div></div></figure><h1 id="a388" class="ld le in bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">限制运动</h1><p id="6061" class="pw-post-body-paragraph jk jl in jm b jn mb jp jq jr mc jt ju jv md jx jy jz me kb kc kd mf kf kg kh ig bi translated">为了限制拇指的移动，我们需要跟踪拇指最后在哪个象限。为了找到拇指所在的象限，我们需要找到平移视图时产生的<code class="fe kw kx ky kz b">angle</code>的余弦和正弦三角函数的符号。<br/>添加一个变量<code class="fe kw kx ky kz b">currentQuadrant</code>到<code class="fe kw kx ky kz b">PaymentDialView</code>类:</p><figure class="kl km kn ko gt kp"><div class="bz fp l di"><div class="la lb l"/></div></figure><p id="51f8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们去<code class="fe kw kx ky kz b">thumbViewPanned()</code>更新一下:</p><figure class="kl km kn ko gt kp"><div class="bz fp l di"><div class="la lb l"/></div></figure><p id="3aba" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">运行应用程序，拇指的活动范围会受到限制。</p><h1 id="3fff" class="ld le in bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">对齐标记</h1><p id="c869" class="pw-post-body-paragraph jk jl in jm b jn mb jp jq jr mc jt ju jv md jx jy jz me kb kc kd mf kf kg kh ig bi translated">当拇指靠近一个标记时，让它捕捉到位置。我们通过检查生成的角度是否接近其中一个标记来做到这一点。如果是，我们将它设置为标记的角度，在代码中看起来像这样:</p><figure class="kl km kn ko gt kp"><div class="bz fp l di"><div class="la lb l"/></div></figure><h1 id="c24c" class="ld le in bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">触觉反馈</h1><p id="b80e" class="pw-post-body-paragraph jk jl in jm b jn mb jp jq jr mc jt ju jv md jx jy jz me kb kc kd mf kf kg kh ig bi translated">最后，让我们在用户捕捉到标记时添加一些反馈。<br/>将以下两个变量添加到类中:</p><figure class="kl km kn ko gt kp"><div class="bz fp l di"><div class="la lb l"/></div></figure><p id="7007" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在<code class="fe kw kx ky kz b">thumbViewPanned()</code>中，将以下内容添加到函数顶部:</p><figure class="kl km kn ko gt kp"><div class="bz fp l di"><div class="la lb l"/></div></figure><p id="de35" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最后，我们的捕捉代码将如下所示:</p><figure class="kl km kn ko gt kp"><div class="bz fp l di"><div class="la lb l"/></div></figure><p id="4d81" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe kw kx ky kz b">didSnap</code>和<code class="fe kw kx ky kz b">shouldTriggerImapct</code>将确保我们每个快照仅获得一次反馈。</p><p id="65ee" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在下一部分中，我们将基于拇指的移动来更新表盘的UI元素。</p></div></div>    
</body>
</html>