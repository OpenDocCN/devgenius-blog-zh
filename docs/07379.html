<html>
<head>
<title>Command Pattern for encapsulated invocation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">封装调用的命令模式</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/command-pattern-for-encapsulated-invocation-kotlin-4338eb23d2ca?source=collection_archive---------5-----------------------#2022-03-20">https://blog.devgenius.io/command-pattern-for-encapsulated-invocation-kotlin-4338eb23d2ca?source=collection_archive---------5-----------------------#2022-03-20</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="bbb8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi ki translated">再次见到你，花样学习者！😁这是我发布的一系列帖子，告诉世界关于设计模式以及它们如何帮助你开发 software🧑‍💻</p><p id="5e32" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我强烈推荐看一下我以前的文章，因为它们不仅教授了很多关于<strong class="jm io">模式</strong>的知识，还教授了相关的<strong class="jm io"> OOP 原则</strong>🙌：</p><ul class=""><li id="0e42" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh kw kx ky kz bi translated">策略模式:<a class="ae la" href="/towardsdev/strategy-pattern-for-independent-algorithms-kotlin-70ed24c7bd8b" rel="noopener ugc nofollow" target="_blank">https://medium . com/toward sdev/strategy-pattern-for-independent-algorithms-kot Lin-70 ed 24 c 7 BD 8 b</a></li><li id="3ede" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">观察者模式:<a class="ae la" href="/towardsdev/observer-pattern-for-loose-coupling-kotlin-f5ab804609bb" rel="noopener ugc nofollow" target="_blank">https://medium . com/toward sdev/observer-pattern-for-loose-coupling-kot Lin-f5ab 804609 bb</a></li><li id="e510" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">装饰模式:<a class="ae la" href="/towardsdev/decorator-decorator-pattern-for-object-composition-kotlin-7cec92cbaf7b" rel="noopener ugc nofollow" target="_blank">https://medium . com/toward sdev/decorator-decorator-pattern-for-object-composition-kot Lin-7 CEC 92 cbaf 7b</a></li><li id="7271" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">工厂模式:<a class="ae la" href="/dev-genius/factory-patterns-to-hide-instantiation-kotlin-d5f01cf01921" rel="noopener ugc nofollow" target="_blank">https://medium . com/dev-genius/factory-patternS-to-hide-instantiation-kot Lin-D5 f 01 cf 01921</a></li><li id="db22" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">单例模式:<a class="ae la" href="https://medium.com/dev-genius/singleton-pattern-for-one-of-a-kind-objects-java-a63c774d9d4" rel="noopener">https://medium . com/dev-genius/singleton-pattern-for-one-of-a-class-objects-Java-a63c 774 d9d 4</a></li></ul><p id="9f08" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">和往常一样，我建议买一本奥莱利媒体的书来充分利用这些模式:<a class="ae la" href="https://www.oreilly.com/library/view/head-first-design/9781492077992/" rel="noopener ugc nofollow" target="_blank">https://www . oreilly . com/library/view/head-first-design/9781492077992/</a></p><p id="ae0e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">结构:</p><ul class=""><li id="7752" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh kw kx ky kz bi translated">介绍</li><li id="b5f5" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">问题</li><li id="34f8" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">离题部分</li><li id="962b" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">设计遵循的原则:<code class="fe li lj lk ll b">null</code>本文中的<strong class="jm io"/></li><li id="0df3" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">最终解决方案代码</li><li id="d590" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">图画</li></ul><p id="37ae" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">《❗️Before 深度 dive❗️》,我会多次重复某些事情，这样你就能理解了。我对这种模式很困惑，我不想让你像我一样挣扎💪</p></div><div class="ab cl lm ln hr lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="ig ih ii ij ik"><h1 id="9c1c" class="lt lu in bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">命令模式</h1><h2 id="e9f9" class="mr lu in bd lv ms mt dn lz mu mv dp md jv mw mx mh jz my mz ml kd na nb mp nc bi translated">介绍</h2><p id="1811" class="pw-post-body-paragraph jk jl in jm b jn nd jp jq jr ne jt ju jv nf jx jy jz ng kb kc kd nh kf kg kh ig bi translated">正如有人所说:“编写软件类似于艺术🎎".这是真的。如果你回头看看以前的文章，仔细思考一下特定逻辑的实现方式——很明显，有无数种方式可以重塑这个问题，并以这样或那样的方式书写它。当方法上的差异并不意味着低劣，而是纯粹的艺术🎨</p><p id="7e0b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有时一种模式可能会违反另一种模式所宣扬的原则，就像<strong class="jm io"> Singleton </strong>一样，但这是特定情况下需要的题外话，而不是 flaw✨</p><h2 id="44de" class="mr lu in bd lv ms mt dn lz mu mv dp md jv mw mx mh jz my mz ml kd na nb mp nc bi translated">问题</h2><p id="0bae" class="pw-post-body-paragraph jk jl in jm b jn nd jp jq jr ne jt ju jv nf jx jy jz ng kb kc kd nh kf kg kh ig bi translated">想象你有一个物体，像<em class="ni">遥控器</em>。它有多个按钮，可以指定触发某些行动。你可能会有一个明显的问题:“嗯，按钮可以被重新分配，这意味着我们<strong class="jm io">不能将</strong>对象硬编码到按钮上”。然后你可以继续说:“这意味着，我们要有某种类型的<strong class="jm io">接口或抽象事物</strong>，它将允许我们把动作转储到那里，并且它将解开它并做出所需的动作”。</p><p id="176a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你的思考过程是正确的👍🏼此外，想象那些动作将在客户提供给我们的类上完成。</p><p id="ba8a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Sooo:</p><pre class="nj nk nl nm gt nn ll no np aw nq bi"><span id="91cb" class="mr lu in ll b gy nr ns l nt nu">            Remote Control Device<br/>              * button1<br/>              * button2<br/>              * next buttons...<br/>           <br/> 'provided class1'  'provided class2'  'provided class n'           </span></pre><p id="424d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们需要创建一个将按钮上的调用传输到类并执行 action⚙️的设计</p><p id="6612" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">立即抛弃坏想法:</p><ul class=""><li id="121a" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh kw kx ky kz bi translated">这些类的方法<strong class="jm io">命名不同</strong> - &gt;没有直接调用</li><li id="2fa7" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">班级可以增删-&gt;没有<code class="fe li lj lk ll b">if/else</code>乱</li></ul><p id="ea33" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">显然，我们将利用<strong class="jm io">命令模式</strong>来解决这个问题。</p><blockquote class="nv nw nx"><p id="2c02" class="jk jl ni jm b jn jo jp jq jr js jt ju ny jw jx jy nz ka kb kc oa ke kf kg kh ig bi translated">模式的要点:<strong class="jm io">将动作的请求从执行动作的对象中分离出来</strong></p></blockquote><p id="c3d1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">其中:</p><ul class=""><li id="025b" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh kw kx ky kz bi translated"><strong class="jm io">请求</strong>:来自远程设备上的按钮</li><li id="e439" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated"><strong class="jm io">对象</strong>:客户提供给我们的类</li></ul><p id="01d3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我知道这听起来很模糊，让我更详细地解释一下🤚🏼：</p><ol class=""><li id="f7ff" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh ob kx ky kz bi translated">我们有可以被认为是 API 的设备</li><li id="9d21" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh ob kx ky kz bi translated">它已经加载了<strong class="jm io">命令</strong>(内部按钮)</li><li id="2d9e" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh ob kx ky kz bi translated">那些<strong class="jm io">命令</strong>封装了<br/> -任务<br/>的工作方式(也就是做事情的方式)——将完成任务的对象</li></ol><h2 id="ea90" class="mr lu in bd lv ms mt dn lz mu mv dp md jv mw mx mh jz my mz ml kd na nb mp nc bi translated">离题部分</h2><p id="ee41" class="pw-post-body-paragraph jk jl in jm b jn nd jp jq jr ne jt ju jv nf jx jy jz ng kb kc kd nh kf kg kh ig bi translated">我知道乍一看这听起来很奇怪，至少对我来说是这样。让我们分解一个更现实的例子来理解具体细节。想象我们有一家餐馆:</p><ol class=""><li id="e8a3" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh ob kx ky kz bi translated">客户发出<strong class="jm io">请求</strong>:我们按下<strong class="jm io">设备</strong>上的按钮</li><li id="69de" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh ob kx ky kz bi translated">服务员以<strong class="jm io">命令</strong>的形式接受<strong class="jm io">请求</strong>:<strong class="jm io">调用者</strong>接受信号</li><li id="2c86" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh ob kx ky kz bi translated">命令<strong class="jm io">封装了</strong>对象要做的动作和做动作的方法:<strong class="jm io">命令</strong>有<strong class="jm io">对象</strong>可以使用，并且知道<strong class="jm io">如何做</strong>上面的东西</li><li id="ea8d" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh ob kx ky kz bi translated">服务员“触发”<strong class="jm io">命令</strong>告诉厨师去做工作:<strong class="jm io">命令</strong>利用对象上的<strong class="jm io">方法使它们工作</strong></li></ol><p id="ff1c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe li lj lk ll b">=&gt;</code>女服务员(命令)是<strong class="jm io">与厨师(提供的类)分离的</strong></p><p id="a95b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在让我们来观察这个图表:</p><pre class="nj nk nl nm gt nn ll no np aw nq bi"><span id="0e6f" class="mr lu in ll b gy nr ns l nt nu">1. Client creates the Command <br/>2. Client sets the Command in the Invoker object<br/>   (not simply in the Invoker!!)</span><span id="50d7" class="mr lu in ll b gy oc ns l nt nu">3. Client triggers the Invoker<br/>4. Invoker triggers Command method<br/>5. Method leverages receiver and calls methods belonged to it</span></pre><p id="c457" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">接收者</strong>——由客户端(在我们的例子中)提供的对象/类，我们将其封装在命令中。</p><p id="47c4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">命令</strong>——由<strong class="jm io">接收器</strong>和应用于<strong class="jm io">接收器</strong>的一组动作组成的东西。为了<strong class="jm io">解耦</strong>一切，我们有相同的方法，通常命名为<code class="fe li lj lk ll b">execute()</code>，从 API 触发命令。</p><p id="c77f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">调用者</strong>——简单触发<strong class="jm io">命令</strong>的东西。在我们的例子中，它是一个按钮。</p><p id="5559" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以，回到我们咖啡馆的例子:</p><ul class=""><li id="cbea" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh kw kx ky kz bi translated">客户端是<strong class="jm io">客户端</strong>(抱歉同义反复)</li><li id="82a2" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">女服务员是一个<strong class="jm io">调用者</strong></li><li id="2903" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">命令是一个<strong class="jm io">命令</strong></li><li id="ac5a" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">库克是一个<strong class="jm io">接收器</strong></li></ul><p id="babf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">‼️Don't haste‼️又从头开始重读了这一节的所有内容。我花了几个小时反复思考这个问题(希望你能更快理解)💨</p><ul class=""><li id="0543" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh kw kx ky kz bi translated">接下来，每个<strong class="jm io">命令</strong>本身不是一个命令，但是<em class="ni">实现了</em>特定的<strong class="jm io">接口</strong>。我们称之为<strong class="jm io">具体命令</strong>。</li><li id="13f3" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">这个<strong class="jm io">具体命令</strong>通过暴露<code class="fe li lj lk ll b">execute()</code>—like 方法绑定接收器和其上的一组动作。</li></ul><blockquote class="nv nw nx"><p id="0569" class="jk jl ni jm b jn jo jp jq jr js jt ju ny jw jx jy nz ka kb kc oa ke kf kg kh ig bi translated">所以，<strong class="jm io">请求</strong>本身不是一个东西，它是一个概念，意味着<strong class="jm io">客户端</strong>调用将触发<strong class="jm io">调用者</strong>，调用者从<strong class="jm io">调用者对象</strong>使用<strong class="jm io">命令</strong>。而这个<strong class="jm io">命令</strong>确实有<strong class="jm io">接收器</strong>和一组动作(其中<strong class="jm io">动作</strong>隐藏在<code class="fe li lj lk ll b">execute()</code>后面)。<br/>这就是为什么它被称为<strong class="jm io">请求的接收者</strong></p></blockquote><p id="67e4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">可能会有更多的讨论和例子，但我认为我已经很好地涵盖了所有内容。在代码中更容易做进一步的解释。这就是为什么我想邀请你参加下一部分🤝</p><blockquote class="nv nw nx"><p id="575f" class="jk jl ni jm b jn jo jp jq jr js jt ju ny jw jx jy nz ka kb kc oa ke kf kg kh ig bi translated">我试图尽可能详细地描述，但如果你没有得到什么，不要羞于发表评论。我会来救你的💁🏻‍♂️</p></blockquote><h2 id="61c5" class="mr lu in bd lv ms mt dn lz mu mv dp md jv mw mx mh jz my mz ml kd na nb mp nc bi translated">最终解决方案代码</h2><p id="8173" class="pw-post-body-paragraph jk jl in jm b jn nd jp jq jr ne jt ju jv nf jx jy jz ng kb kc kd nh kf kg kh ig bi translated">在下面的链接中，你可以找到我用 Kotlin 编写的模式的完整代码</p><div class="od oe gp gr of og"><a href="https://github.com/SleeplessChallenger/KotlinDesignPatterns/tree/main/src/main/kotlin/6_CommandPattern" rel="noopener  ugc nofollow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd io gy z fp ol fr fs om fu fw im bi translated">KotlinDesignPatterns/src/main/kotlin/6 _ command pattern at main…</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">O'Reilly 设计模式在 Kotlin 的实现。为 sleep less challenger/KotlinDesignPatterns 开发做出贡献…</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">github.com</p></div></div><div class="op l"><div class="oq l or os ot op ou ov og"/></div></div></a></div><p id="a8df" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在我想展示一下命令模式在代码中的样子，并把我上面的解释和代码匹配起来🤙</p><p id="0570" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">退一步讲讲<strong class="jm io">宏命令</strong>和<strong class="jm io">撤销</strong>:</p><ol class=""><li id="870b" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh ob kx ky kz bi translated"><strong class="jm io">宏命令</strong>是一个通用命令，内部包含多个命令。因此，我们像往常一样将其分配给按钮，但是<code class="fe li lj lk ll b">execute()</code>将通过遍历我们放入其中的<strong class="jm io">命令</strong>的列表/数组来触发多个<strong class="jm io">接收器</strong>上的动作</li><li id="2496" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh ob kx ky kz bi translated"><strong class="jm io">撤销</strong>是将动作回滚到以前的状态。它<em class="ni">实现了</em>同样的<strong class="jm io">命令</strong>接口，但是我们不需要从外部分配它。为什么？🧐，我以后会说的，请耐心点🙏</li></ol><p id="a2f2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">代码本身:</strong></p><ol class=""><li id="2cce" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh ob kx ky kz bi translated"><code class="fe li lj lk ll b">RemoteLoader.kt</code>是一个文件，它创建我们的命令并实例化遥控器设备<br/> - <code class="fe li lj lk ll b">Command.kt</code>是我们将使用的所有命令的接口(记得我如何强调<strong class="jm io">相同接口</strong>对所有按钮的重要性)。它有两个方法:<code class="fe li lj lk ll b">execute() &amp; undo()</code><br/>——在<code class="fe li lj lk ll b">init {}</code>块<code class="fe li lj lk ll b">setCommand()</code>中，我们将特定的命令分配给<strong class="jm io">调用程序对象</strong>(回想一下解释中的这个术语)</li><li id="c425" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh ob kx ky kz bi translated"><code class="fe li lj lk ll b">RemoteControl.kt</code>是我们的遥控装置。<br/> -它有 2 个对象，我们在其中存储了&amp; Off 命令。我们可以称它们为<strong class="jm io">调用者对象</strong>(再次从上面回忆)<br/> - <code class="fe li lj lk ll b">onButtonPush()</code> &amp; <code class="fe li lj lk ll b">offButtonPush()</code>就是我们的<strong class="jm io">调用者</strong>。我们提供要使用的插槽号，它从中获取命令并触发<code class="fe li lj lk ll b">execute()</code> <br/> - <strong class="jm io">还有:</strong>我们有<strong class="jm io">撤销</strong>命令。再晚一点😩</li><li id="bac7" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh ob kx ky kz bi translated"><code class="fe li lj lk ll b">Light.kt</code>、<code class="fe li lj lk ll b">CeilingFan.kt</code>是我们的客户端类。他们是<strong class="jm io">接收者</strong></li><li id="1b95" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh ob kx ky kz bi translated"><code class="fe li lj lk ll b">LightOffCommand.kt</code>、<code class="fe li lj lk ll b">LightOnCommand.kt</code>是我们的<strong class="jm io">命令</strong>，实现<strong class="jm io">命令</strong>接口<br/>——我们在每个命令<br/>里面都有<strong class="jm io">接收器</strong>实例——心爱的<code class="fe li lj lk ll b">execute()</code>触发<strong class="jm io">接收器</strong>上的方法<br/> - <code class="fe li lj lk ll b">undo()</code> ( <strong class="jm io">最后</strong>)使用<strong class="jm io">命令</strong>的相反动作。就像<code class="fe li lj lk ll b">LightOnCommand</code>在<code class="fe li lj lk ll b">execute()</code>中触发<code class="fe li lj lk ll b">light.on()</code>，但是在<code class="fe li lj lk ll b">undo()</code>中我们有<code class="fe li lj lk ll b">light.off()</code></li></ol><p id="1957" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下面我再做一些评论:</p><ul class=""><li id="6334" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh kw kx ky kz bi translated">在<code class="fe li lj lk ll b">RemoteControl.kt</code>中，我们有<code class="fe li lj lk ll b">undoCommandPush()</code>，它将最后分配的命令传递给<code class="fe li lj lk ll b">undoCommand</code>并利用它。也就是说，我们最后执行<code class="fe li lj lk ll b">LightOnCommand</code>，因此我们将其分配给<code class="fe li lj lk ll b">undoCommand</code>并且该<strong class="jm io">命令的<code class="fe li lj lk ll b">undo()</code>将触发<code class="fe li lj lk ll b">light.off()</code></strong></li><li id="ba15" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated"><code class="fe li lj lk ll b">NoCommand.kt</code>是一种简单的方法，可以将模仿对象放到<strong class="jm io">调用对象</strong>中，调用对象在方法中什么也不做(是的，为了兼容，它们<em class="ni">实现了</em> <strong class="jm io">命令</strong>接口)，但是确保我们有办法防止系统在按钮被调用但没有被赋值时崩溃。</li></ul><p id="5c21" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了便于练习，试着用相关的<strong class="jm io">命令解开<strong class="jm io">调用者</strong> <code class="fe li lj lk ll b">CeilingFan.kt</code>。</strong>如果觉得难，就留下评论吧！😇</p><blockquote class="nv nw nx"><p id="0fab" class="jk jl ni jm b jn jo jp jq jr js jt ju ny jw jx jy nz ka kb kc oa ke kf kg kh ig bi translated">*命令模式<strong class="jm io">将发出请求的对象与知道如何执行请求的对象解耦</strong></p></blockquote><h2 id="f936" class="mr lu in bd lv ms mt dn lz mu mv dp md jv mw mx mh jz my mz ml kd na nb mp nc bi translated">图画</h2><figure class="nj nk nl nm gt ox gh gi paragraph-image"><div role="button" tabindex="0" class="oy oz di pa bf pb"><div class="gh gi ow"><img src="../Images/7dfdded83d17e474d3981abfbf64917d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EVqcnHVeQIxj52T5d8ENYQ.jpeg"/></div></div></figure><p id="69f0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这张图片上，您可以观察到两个部分:</p><ul class=""><li id="6529" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh kw kx ky kz bi translated">左边一个致力于模式的流动</li><li id="3a20" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">右边的是图案本身</li></ul><p id="6cfc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你想让我一步一步地看完它，请在评论中留下一条消息<strong class="jm io">👣</strong></p><h2 id="128f" class="mr lu in bd lv ms mt dn lz mu mv dp md jv mw mx mh jz my mz ml kd na nb mp nc bi translated">结尾部分👋</h2><blockquote class="nv nw nx"><p id="7c3e" class="jk jl ni jm b jn jo jp jq jr js jt ju ny jw jx jy nz ka kb kc oa ke kf kg kh ig bi translated"><strong class="jm io">命令模式</strong>的学术定义:它将请求封装为一个对象(命令)，这允许你用不同的请求参数化其他对象。</p></blockquote><p id="15de" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这个时候，我不离开吓人😱学术定义，因为它将涵盖它更详细:<br/> 1。命令<strong class="jm io">封装了</strong>的请求，如何？它有一个<strong class="jm io">接收器</strong>并在其上施加动作。<strong class="jm io">请求</strong>是一个概念，意味着我们利用来自<strong class="jm io">调用者</strong>对象<br/> 2 的<strong class="jm io">命令</strong>。命令将类似的方法暴露给外部世界，触发将导致那些动作被激活。<br/> 3。外界不知道哪个<strong class="jm io">接收器</strong>被触发。他们只知道，如果他们触发<code class="fe li lj lk ll b">execute()</code> - &gt;，一切都会变得神奇。<br/> 4。什么是“参数化”的东西？我们可以在<strong class="jm io">调用者</strong>对象中加载<strong class="jm io">任何</strong> <em class="ni">命令</em>(还是那句话，不是简单的<strong class="jm io">调用者</strong>，而是它的对象)，直到这个命令实现了命令的接口。</p><p id="a870" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一些最后的 thought☝️:</p><ul class=""><li id="645e" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh kw kx ky kz bi translated"><strong class="jm io">命令模式</strong>可用于请求排队，即我们将<strong class="jm io">命令</strong>放入队列，<em class="ni">线程</em>弹出它并触发<code class="fe li lj lk ll b">execute()</code>like 方法。所以，我们不需要在这里发明一辆自行车，完全不同的操作可以用这个接口<strong class="jm io">封装</strong></li></ul><p id="f250" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">是的，很艰难😪如果需要的话，多读几遍，如果仍然是 unclear✌️的话，在评论中留言</p><p id="1b9a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你可以找到我:</p><ul class=""><li id="0fc9" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh kw kx ky kz bi translated">领英:<a class="ae la" href="http://www.linkedin.com/in/sleeplesschallenger" rel="noopener ugc nofollow" target="_blank">www.linkedin.com/in/sleeplesschallenger</a></li><li id="1cd7" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">GitHub:<a class="ae la" href="https://github.com/SleeplessChallenger" rel="noopener ugc nofollow" target="_blank">https://github.com/SleeplessChallenger</a></li><li id="023b" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">leet code:<a class="ae la" href="https://leetcode.com/SleeplessChallenger/" rel="noopener ugc nofollow" target="_blank">https://leetcode.com/SleeplessChallenger/</a></li><li id="606c" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">电报:@无眠挑战者</li></ul></div></div>    
</body>
</html>