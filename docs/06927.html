<html>
<head>
<title>Apollo Federation: How do Request Travel Through a Federated Architecture?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Apollo 联邦:请求如何通过联邦架构？</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/apollo-federation-how-do-request-travel-through-a-federated-architecture-e4a4da54f46d?source=collection_archive---------6-----------------------#2022-02-12">https://blog.devgenius.io/apollo-federation-how-do-request-travel-through-a-federated-architecture-e4a4da54f46d?source=collection_archive---------6-----------------------#2022-02-12</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="4d8a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">大家好，感谢您的加入！</p><p id="88ac" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">今天，我将带您踏上一次旅程——有些人可能会说是一次开发之旅……通过联合 Apollo API 的架构来处理网络请求！</p><p id="86fa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是一次有趣的冒险，从客户端开始，穿过一个网关(这是本文开始的地方)，到达一个子图，并以解析器结束。有许多事情需要发生，以使这个棘手的旅程成为可能，我们可以确保我们的请求成功，而其余的请求则失败。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2946d7371e4931b3828b3b3ce979c249.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W62Z3oi4bKkgoND_IaILiQ.jpeg"/></div></div></figure><h1 id="34eb" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">开始—一些助手</h1><p id="9c41" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">为此，我们将使用<code class="fe lx ly lz ma b">@the-devoyage/micro-auth-helpers</code>包，它为 auth context 和 Apollo 联邦架构中的更多内容提供了帮助函数。它在 GitHub npm 注册表中，所以一定要登录到 GitHub 注册表并将<code class="fe lx ly lz ma b">@the-devoyage</code>范围添加到您的。首先是 npmrc。</p><pre class="kj kk kl km gt mb ma mc md aw me bi"><span id="895e" class="mf kv in ma b gy mg mh l mi mj">npm login --registry=https://npm.pkg.github.com </span><span id="e8ea" class="mf kv in ma b gy mk mh l mi mj">echo @the-devoyage:--registry=https://npm.pkg.github.com &gt;&gt; .npmrc</span><span id="8e6f" class="mf kv in ma b gy mk mh l mi mj">npm i @the-devoyage/micro-auth-helpers</span></pre><p id="9529" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我会把我们的请求分成三个部分！</p><ol class=""><li id="7279" class="ml mm in jm b jn jo jr js jv mn jz mo kd mp kh mq mr ms mt bi translated">网关</li><li id="5feb" class="ml mm in jm b jn mu jr mv jv mw jz mx kd my kh mq mr ms mt bi translated">子图(外部微服务)</li><li id="9572" class="ml mm in jm b jn mu jr mv jv mw jz mx kd my kh mq mr ms mt bi translated">解析器</li></ol><p id="b470" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在故事开始了——我们的请求即将离开客户机，向网关前进。</p><p id="b203" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">PS:像这样的包我一般都是收费的，但是这次是免费的！如果你喜欢使用它，我还有一个快速的方法让你贡献一小笔钱，来表达你的爱！谢谢！— <a class="ae mz" href="https://basetools.io/checkout/mEiqLNPM" rel="noopener ugc nofollow" target="_blank">我喜欢这个想法，我愿意为此出一份力！</a> &lt; &lt;点击此处</p><h1 id="bab7" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">网关</h1><p id="decf" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">当请求进入网关时，我们需要从<strong class="jm io"> <em class="na">头</em> </strong>中提取对我们的服务<strong class="jm io"> <em class="na">重要的数据。</em> </strong>有大量有价值的信息在头中发送，比如令牌、内容类型，甚至自定义数据。</p><p id="6def" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这些数据中的一些可能需要被验证和/或解码，以便在服务中使用。</p><h2 id="e8c0" class="mf kv in bd kw nb nc dn la nd ne dp le jv nf ng li jz nh ni lm kd nj nk lq nl bi translated">生成网关上下文</h2><p id="d5c3" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated"><code class="fe lx ly lz ma b">@the-devoyage/micro-auth-helpers</code>包提供了一个函数来帮助从头部提取信息和创建上下文。</p><p id="a4f0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">从<code class="fe lx ly lz ma b">@the-devoyage/micro-auth-helpers</code>包中导入<code class="fe lx ly lz ma b">Helpers</code>，并使用网关模块中的<code class="fe lx ly lz ma b">GenerateContext</code>，从请求头中创建<code class="fe lx ly lz ma b">Context</code>。在创建 Apollo 服务器时，将这个函数应用于<code class="fe lx ly lz ma b">context</code>属性，如下所示:</p><pre class="kj kk kl km gt mb ma mc md aw me bi"><span id="bb8f" class="mf kv in ma b gy mg mh l mi mj">// Gateway<br/>import { Helpers } from '@the-devoyage/micro-auth-helpers';</span><span id="b0ed" class="mf kv in ma b gy mk mh l mi mj">const apolloServer = new ApolloServer({<br/>    gateway,<br/>    context: ({ req }) =&gt; {<br/>      return Helpers.Gateway.GenerateContext({<br/>        req,<br/>        secretOrPublicKey: process.env.JWT_ENCRYPTION_KEY,<br/>        headers: ["Authorization", "Content-Type", "Custom_Header"],<br/>      });<br/>    },<br/>  });</span></pre><p id="0eb8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">简单。简单。完成了。</p><p id="588d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">该函数处理所有繁重的工作！让我解释一下这种甜甜的糖。</p><ol class=""><li id="4f24" class="ml mm in jm b jn jo jr js jv mn jz mo kd mp kh mq mr ms mt bi translated">默认情况下，<code class="fe lx ly lz ma b">GenerateContext</code>函数不会向<code class="fe lx ly lz ma b">Context</code>对象添加任何请求头，所以我们必须告诉它要包含哪些头。将<code class="fe lx ly lz ma b">headers</code>数组中的标题键作为字符串传递，以将它们包含在<code class="fe lx ly lz ma b">Context</code>对象中。</li><li id="6e43" class="ml mm in jm b jn mu jr mv jv mw jz mx kd my kh mq mr ms mt bi translated">如果包含了<code class="fe lx ly lz ma b">Authorization</code>报头，并且它是一个<code class="fe lx ly lz ma b">Bearer</code>令牌，它将自动解码有效载荷并将其添加到上下文中！只需确保传递密钥来解码令牌。我们将在下面讨论更多关于生成令牌的内容，因为这个包有一个生成类型化令牌的功能！</li></ol><p id="9dd8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当所有这些都完成后，它生成一个<em class="na">漂亮的</em>上下文，可以传递给联邦子图！</p><pre class="kj kk kl km gt mb ma mc md aw me bi"><span id="9542" class="mf kv in ma b gy mg mh l mi mj">export interface Context extends Record&lt;string, any&gt; {<br/>  auth: AuthContext;<br/>  //...all other generated context <br/>}</span><span id="ae14" class="mf kv in ma b gy mk mh l mi mj">export interface AuthContext {<br/>  payload?: Payload;<br/>  isAuth: boolean;<br/>  error?: string;<br/>}</span><span id="6a37" class="mf kv in ma b gy mk mh l mi mj">export interface Payload extends jwt.JwtPayload {<br/>  account: { _id: string; email: string } | null;<br/>  user: { _id: string; role: number; email: string } | null;<br/>}</span></pre><h2 id="bf85" class="mf kv in bd kw nb nc dn la nd ne dp le jv nf ng li jz nh ni lm kd nj nk lq nl bi translated">在走出大门的路上</h2><p id="d85d" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">既然请求已经被转换成了<code class="fe lx ly lz ma b">Context</code>，我们需要确保它能够到达联合子图。</p><p id="8074" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如下所示，<code class="fe lx ly lz ma b">ContextDataSource</code>类扩展了 Apollo 提供的<code class="fe lx ly lz ma b">RemoteGraphQLDataSource</code>类，将请求和新生成的<code class="fe lx ly lz ma b">Context.</code>一起发送到子图</p><p id="72bc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">简单来说——这个 lil' guy 将生成的<code class="fe lx ly lz ma b">Context</code>作为字符串化的 JSON 添加到发出的请求中，放在一个名为<code class="fe lx ly lz ma b">context</code>的头中。稍后，子图将能够接收<code class="fe lx ly lz ma b">context</code>头，以用作它自己的<code class="fe lx ly lz ma b">Context</code>。</p><pre class="kj kk kl km gt mb ma mc md aw me bi"><span id="d674" class="mf kv in ma b gy mg mh l mi mj">import { Helpers } from '@the-devoyage/micro-auth-helpers';</span><span id="b3a3" class="mf kv in ma b gy mk mh l mi mj">const gateway = new ApolloGateway({<br/>  supergraphSdl,<br/>  buildService({ url }) {<br/>    const dataSource = new Helpers.Gateway.ContextDataSource({ url });<br/>    return dataSource;<br/>  },<br/>});</span></pre><p id="252b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">一些额外的魔法</strong></p><p id="8505" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">除了扩展<code class="fe lx ly lz ma b">RemoteGraphQLDataSource</code>，它还扩展了<code class="fe lx ly lz ma b">@profusion/apollo-federation-upload</code>包的文件上传类以允许文件上传。</p><h2 id="4854" class="mf kv in bd kw nb nc dn la nd ne dp le jv nf ng li jz nh ni lm kd nj nk lq nl bi translated">对网关的快速回顾</h2><p id="7b1a" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">好吧！我们在一个好地方！让我们快速回顾一下。</p><ol class=""><li id="396e" class="ml mm in jm b jn jo jr js jv mn jz mo kd mp kh mq mr ms mt bi translated">请求已经到达网关。</li><li id="d39d" class="ml mm in jm b jn mu jr mv jv mw jz mx kd my kh mq mr ms mt bi translated">网关将选择的报头转换成<code class="fe lx ly lz ma b">Context</code>并自动解码 JWT。</li><li id="5133" class="ml mm in jm b jn mu jr mv jv mw jz mx kd my kh mq mr ms mt bi translated">最后，一个<code class="fe lx ly lz ma b">context</code>头被附加到每个传出的请求上。</li></ol><h1 id="06eb" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">子图助手</h1><h2 id="23d1" class="mf kv in bd kw nb nc dn la nd ne dp le jv nf ng li jz nh ni lm kd nj nk lq nl bi translated">生成子图上下文帮助器</h2><p id="079d" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">一旦请求离开网关，它将到达子图。它还需要被解析并添加到子图的上下文中，就像请求到达网关时一样。</p><p id="1758" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">像上面一样，使用<code class="fe lx ly lz ma b">GenerateContext</code>函数，这次来自<code class="fe lx ly lz ma b">Subgraph</code>模块，为服务生成<code class="fe lx ly lz ma b">Context</code>。</p><pre class="kj kk kl km gt mb ma mc md aw me bi"><span id="4783" class="mf kv in ma b gy mg mh l mi mj">// Subgraph<br/>import { Helpers } from '@the-devoyage/micro-auth-helpers';</span><span id="d636" class="mf kv in ma b gy mk mh l mi mj">const apolloServer = new ApolloServer({<br/>  schema: schema,<br/>  context: ({ req }) =&gt;<br/>    Helpers.Subgraph.GenerateContext({<br/>      req,<br/>      inject: { dogName: "Bongo", catName: "Oakley" },<br/>    }),<br/>});</span></pre><p id="a475" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">子图可能需要特定于服务的附加上下文。上面的例子演示了如何“注入”这样的额外数据。额外的数据被简单地添加到子图服务中的一个对象中。</p><p id="fcfe" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">此时，子图中的解析器现在可以访问<code class="fe lx ly lz ma b">Context</code>对象了！</p><pre class="kj kk kl km gt mb ma mc md aw me bi"><span id="135e" class="mf kv in ma b gy mg mh l mi mj">const resolvers = {<br/>  getPetsString: (parent, args, context) =&gt; {<br/>    const isAuthenticated = context.auth.isAuth;<br/>    const { dogName, catName } = context;</span><span id="51c8" class="mf kv in ma b gy mk mh l mi mj">    const petString = `My dog's name is ${dogName}. He does not like my cat, ${catName}.`;</span><span id="dc90" class="mf kv in ma b gy mk mh l mi mj">    return petString;<br/>  },<br/>};</span></pre><h1 id="29cc" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">解析器</h1><p id="8b7c" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">通过将上下文传递给联邦子图中的解析器，您允许每个解析器单独处理授权。基本上，子图现在可以包含解析器，它可能需要也可能不需要认证。</p><p id="64e4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe lx ly lz ma b">@the-devoyage/micro-auth-helpers</code>包提供了一些有助于解析器授权、代码生成和令牌生成的功能。</p><h2 id="b870" class="mf kv in bd kw nb nc dn la nd ne dp le jv nf ng li jz nh ni lm kd nj nk lq nl bi translated">生成令牌</h2><p id="610c" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">如果您使用的是 JWT 认证方法，那么您可以使用<code class="fe lx ly lz ma b">GenerateToken</code>助手来创建一个具有类型化有效负载的令牌。默认情况下，这个令牌将与这个包一起使用。</p><pre class="kj kk kl km gt mb ma mc md aw me bi"><span id="70f3" class="mf kv in ma b gy mg mh l mi mj">export interface Payload extends jwt.JwtPayload {<br/>  account?: { _id: string; email: string };<br/>  user?: { _id: string; role: number; email: string };<br/>}</span></pre><p id="b4f2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">调用负责处理“登录”的解析器中的函数除了必需的<code class="fe lx ly lz ma b">user</code>和<code class="fe lx ly lz ma b">account</code>属性(可能为空)之外，向有效负载传递您需要的任何附加信息。</p><pre class="kj kk kl km gt mb ma mc md aw me bi"><span id="2d52" class="mf kv in ma b gy mg mh l mi mj">import { Helpers } from '@the-devoyage/micro-auth-helpers';</span><span id="42f0" class="mf kv in ma b gy mk mh l mi mj">const resolvers = {<br/>  login: () =&gt; {<br/>    const token = Helpers.Resolver.GenerateToken({<br/>      secretOrPublicKey: process.env.JWT_ENCRYPTION_KEY,<br/>      payload: {<br/>        account: { _id: account._id, email: account.email },<br/>        user: null,<br/>        myCustomKey: {any: "Custom", content: allowed},<br/>      },<br/>      options: { expiresIn: "10h" },<br/>    });<br/>  }<br/>}</span></pre><h2 id="b636" class="mf kv in bd kw nb nc dn la nd ne dp le jv nf ng li jz nh ni lm kd nj nk lq nl bi translated">检查身份验证</h2><p id="ee6f" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">如您所料，使用<code class="fe lx ly lz ma b">CheckAuth</code>函数检查请求是否已经在解析器级别得到授权。</p><pre class="kj kk kl km gt mb ma mc md aw me bi"><span id="07e6" class="mf kv in ma b gy mg mh l mi mj">import { Helpers } from "<a class="ae mz" href="http://twitter.com/the" rel="noopener ugc nofollow" target="_blank">@the</a>-devoyage/micro-auth-helpers";</span><span id="f62e" class="mf kv in ma b gy mk mh l mi mj">const resolvers = {<br/>  getDogs: async (parent, args, context) =&gt; {<br/>    Helpers.Resolver.CheckAuth({ context });</span><span id="c0ab" class="mf kv in ma b gy mk mh l mi mj">    // If auth fails, an auth error is thrown and the rest of the code will not be executed.<br/>    <br/>    const dogs = [{name: "Bongo", age: 9}, {name: "Oakley", age: 3}];</span><span id="e8c1" class="mf kv in ma b gy mk mh l mi mj">    return dogs;<br/>  },<br/>};</span></pre><p id="99dc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">更进一步，在上下文中需要一个<code class="fe lx ly lz ma b">user</code>或<code class="fe lx ly lz ma b">account</code>属性！</p><pre class="kj kk kl km gt mb ma mc md aw me bi"><span id="008b" class="mf kv in ma b gy mg mh l mi mj">import { Helpers } from "<a class="ae mz" href="http://twitter.com/the" rel="noopener ugc nofollow" target="_blank">@the</a>-devoyage/micro-auth-helpers";</span><span id="90d7" class="mf kv in ma b gy mk mh l mi mj">const resolvers = {<br/>  getDogs: async (parent, args, context) =&gt; {<br/>    Helpers.Resolver.CheckAuth({ <br/>      context, <br/>      requireUser: true, <br/>      requireAccount: true <br/>    });</span><span id="f959" class="mf kv in ma b gy mk mh l mi mj">    // If context.auth.user or context.auth.account is undefined, an auth error is thrown and the rest of the code will not be executed.<br/>    <br/>    const dogs = [{name: "Bongo", age: 9}, {name: "Oakley", age: 3}];</span><span id="0c51" class="mf kv in ma b gy mk mh l mi mj">return dogs;<br/>  },<br/>};</span></pre><h2 id="2b64" class="mf kv in bd kw nb nc dn la nd ne dp le jv nf ng li jz nh ni lm kd nj nk lq nl bi translated"><strong class="ak">限制作用</strong></h2><p id="8092" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">如果您需要用户属性，那么在使用<code class="fe lx ly lz ma b">GenerateToken</code>助手创建令牌时，默认类型包括一个<code class="fe lx ly lz ma b">role</code>。这意味着我们现在可以进一步限制解析器了！</p><pre class="kj kk kl km gt mb ma mc md aw me bi"><span id="26b1" class="mf kv in ma b gy mg mh l mi mj">import { Helpers } from "<a class="ae mz" href="http://twitter.com/the" rel="noopener ugc nofollow" target="_blank">@the</a>-devoyage/micro-auth-helpers";</span><span id="6421" class="mf kv in ma b gy mk mh l mi mj">const resolvers = {<br/>  getDogs: async (parent, args, context) =&gt; {<br/>    Helpers.Resolver.CheckAuth({ <br/>      context, <br/>      requireUser: true, <br/>      requireAccount: true <br/>    });</span><span id="acaa" class="mf kv in ma b gy mk mh l mi mj">    Helpers.Resolver.LimitRole({<br/>      userRole: context.auth.user.role,<br/>      roleLimit: 1,<br/>      errorMessage:<br/>        "Only users with a role of 1 or lower may get dogs.",<br/>    });</span><span id="56e6" class="mf kv in ma b gy mk mh l mi mj">    // If limit role fails, an auth error is thrown and the rest of the code will not be executed.<br/>    <br/>    const dogs = [{name: "Bongo", age: 9}, {name: "Oakley", age: 3}];</span><span id="0c40" class="mf kv in ma b gy mk mh l mi mj">return dogs;<br/>  },<br/>};</span></pre><h1 id="1b30" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">就是这样！</h1><p id="66d9" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">虽然网络请求的整个“旅程”缺少一些超出本文范围的部分，但我希望这可能有助于您理解来自联邦架构内的请求之旅！</p><p id="2421" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有很多关于如何自己编写所有代码的教程——但是我发现，当有多个服务共享几乎相同的代码时，拥有这样一个包可以很好地帮助保持一切最新并协同工作。再一次，我真的希望这个免费的包对我有用！如果你愿意出一点钱，我会非常高兴的！<a class="ae mz" href="https://basetools.io/checkout/mEiqLNPM" rel="noopener ugc nofollow" target="_blank">贡献 Basetools，一个为你的 git repos/npm 包付费的墙！</a></p></div><div class="ab cl nm nn hr no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="ig ih ii ij ik"><p id="e344" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">嘿——我叫尼克！非常感谢您花几分钟时间阅读这篇快速文章。希望你觉得有趣，可以帮我分享一下。最简单的方法就是点击<strong class="jm io"> <em class="na">中的</em> </strong>按钮，非常感谢！</p><p id="7d82" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">谢谢！</p></div></div>    
</body>
</html>