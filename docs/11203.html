<html>
<head>
<title>Searching Algorithm In A Binary Search Tree: Breadth-First Search (BFS) vs Depth-First Search (DFS)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">二叉查找树中的搜索算法:广度优先搜索(BFS)与深度优先搜索(DFS)</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/searching-algorithm-in-a-binary-search-tree-breadth-first-search-bfs-vs-depth-first-search-dfs-6ea18bf92bee?source=collection_archive---------13-----------------------#2022-12-24">https://blog.devgenius.io/searching-algorithm-in-a-binary-search-tree-breadth-first-search-bfs-vs-depth-first-search-dfs-6ea18bf92bee?source=collection_archive---------13-----------------------#2022-12-24</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="49ea" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在本文中，我将讨论二叉查找树中的搜索算法，它们的区别，以及如何在二叉查找树中实现它们。让我们开始吧！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5d1d3d7d212b964dff3f391a37f9ce2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FaY09voD_fhDGNgfmwXXKQ.png"/></div></div></figure><h1 id="4c48" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">广度优先搜索</h1><p id="dd4d" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">广度优先搜索(BFS)是一种从左到右遍历每层树的算法。BFS 用于查找最短路径，最著名的研究案例是使用谷歌地图查找到达目的地的最快路线。如果我们要找的节点接近上层，BFS 真的很快。缺点是 BFS 需要更多的内存，因为我们必须存储每一层的每个节点。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lx"><img src="../Images/5c0e93865f3837061c9de41ac34375b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*nINpHqHOaWREYta1.gif"/></div></div></figure><h2 id="871a" class="ly kv in bd kw lz ma dn la mb mc dp le jv md me li jz mf mg lm kd mh mi lq mj bi translated">履行</h2><p id="d7a2" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">现在，我将使用 Go 编程语言和下面的树来实现 BFS。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/89b9be70c732e81523ddd7544898fd06.png" data-original-src="https://miro.medium.com/v2/resize:fit:486/0*ZEVJRKGHTa6KaIW5"/></div></figure><p id="f34e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了使用 BFS，我将使用一个队列来存储我们在每个节点中找到的孩子。逻辑是，我们希望存储队列中每个节点的每个孩子。由此，我们得到队列中的第一个节点来检查子节点。重复这个过程，直到我们的队列中没有节点。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ml"><img src="../Images/ec049c89dcdf12e2f47812765f884371.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Fp8YVe2dUoXIS_j4"/></div></div></figure><p id="89f8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果我们在代码中实现它，上面的树的输出是</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ml"><img src="../Images/70fbcac73c2d429b21216d4925aff35b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*s3qh71GYPMOCRaZZ"/></div></div></figure><h1 id="aaa2" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">深度优先搜索</h1><p id="28c6" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">深度优先搜索是一种算法，它沿着树的一个分支向下搜索尽可能多的层，直到找到目标节点或到达终点。这需要较低的内存需求，因为我们不必将节点存储在数组中。当我们想要检查两个节点之间的路径是否存在时，使用该算法。DFS 的缺点是它会变得很慢，尤其是当我们有一个嵌套很深的树时。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/5ec2644eccfde7b9b062c6efd2d33fe0.png" data-original-src="https://miro.medium.com/v2/resize:fit:828/0*nqjNtl144Uo4v6dC.gif"/></div></figure><h2 id="96ab" class="ly kv in bd kw lz ma dn la mb mc dp le jv md me li jz mf mg lm kd mh mi lq mj bi translated">履行</h2><p id="21ad" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">现在，我将使用 Go 编程语言和下面的树来实现 DFS。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/faadda9046bda7122bbcf4b3d7bc842b.png" data-original-src="https://miro.medium.com/v2/resize:fit:486/0*4RzZ6c7DUtJ4pQDD"/></div></figure><p id="896a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有三种类型的 DFS:</p><ul class=""><li id="65b0" class="mn mo in jm b jn jo jr js jv mp jz mq kd mr kh ms mt mu mv bi translated">按顺序:[1，4，5，6，9，10，20，170](一切正常)</li><li id="33d7" class="mn mo in jm b jn mw jr mx jv my jz mz kd na kh ms mt mu mv bi translated">预订:[9，4，1，6，5，20，10，170](当我们想要重新创建我们的树时很好)</li><li id="38a3" class="mn mo in jm b jn mw jr mx jv my jz mz kd na kh ms mt mu mv bi translated">后序:[1，6，4，5，10，170，20，9]</li></ul><p id="d9a3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">DFS 用于递归遍历每个节点。根据我们使用的 DFS 的类型(下面的情况是一个预排序)，我们想要调用相同的函数并传递子函数。下面的代码可能有点难以理解，但是当你把它和上面的动画结合起来，你就会很容易理解了。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ml"><img src="../Images/e20fd9b95c85188a8b4ae56a7daab535.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CCzzRKk603itBY-V"/></div></div></figure><p id="2dcf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果我们在代码中实现它，上面的树的输出是。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ml"><img src="../Images/80accc5cd498fcc734047fa16eb6cdc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6wqVMdsE6PU-rBlO"/></div></div></figure><h1 id="b783" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">结论</h1><p id="ee75" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">广度优先搜索和深度优先搜索是作为软件工程师需要学习的一个重要主题，因为我们通常会在实际项目或技术面试中遇到它们。两种算法各有优缺点，但都具有 O(n)时间复杂度。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nb"><img src="../Images/95bf85e2679d33c4b09a4aa9fca0f5a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FlceKbQxt4Smah23I10wNA.png"/></div></div></figure></div></div>    
</body>
</html>