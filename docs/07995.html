<html>
<head>
<title>Create a data visualization app for the K-pop TV show ‘Queendom2’ with React+Flask+PostgreSQL+Bootstrap</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 React+Flask+PostgreSQL+Bootstrap 为韩国流行电视节目“Queendom2”创建一个数据可视化应用程序</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/create-a-data-visualization-web-page-with-react-flask-postgresql-bootstrap-4ec4f080309e?source=collection_archive---------10-----------------------#2022-05-09">https://blog.devgenius.io/create-a-data-visualization-web-page-with-react-flask-postgresql-bootstrap-4ec4f080309e?source=collection_archive---------10-----------------------#2022-05-09</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/></div><div class="ab cl jk jl hr jm" role="separator"><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp"/></div><div class="ig ih ii ij ik"><p id="adc1" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io"> Web App 链接:</strong>【https://queendom2.herokuapp.com/】<br/><strong class="jt io">GitHub 回购:</strong><a class="ae kp" href="https://github.com/monkeyapple/queendom2data" rel="noopener ugc nofollow" target="_blank">https://github.com/monkeyapple/queendom2data</a></p></div><div class="ab cl jk jl hr jm" role="separator"><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp"/></div><div class="ig ih ii ij ik"><h1 id="0b74" class="kq kr in bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated"><strong class="ak">简介</strong></h1><p id="4bac" class="pw-post-body-paragraph jr js in jt b ju lo jw jx jy lp ka kb kc lq ke kf kg lr ki kj kk ls km kn ko ig bi translated">这个数据可视化应用程序显示了正在进行的韩国流行真人秀《女王 2》的 YouTube 浏览量。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi lt"><img src="../Images/266c8f57132438ef3e37ab4ffe04973e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D0E2T0XCD-yvJNIXz4xhUw.png"/></div></div></figure><h1 id="6841" class="kq kr in bd ks kt mf kv kw kx mg kz la lb mh ld le lf mi lh li lj mj ll lm ln bi translated">应用堆栈和工作流</h1><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi mk"><img src="../Images/ac4785d4b0fbe045f7cb64073508de03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QPmrm_F7gII589_ea5_4YQ.png"/></div></div></figure><h1 id="8f9e" class="kq kr in bd ks kt mf kv kw kx mg kz la lb mh ld le lf mi lh li lj mj ll lm ln bi translated">技术堆栈</h1><ul class=""><li id="750a" class="ml mm in jt b ju lo jy lp kc mn kg mo kk mp ko mq mr ms mt bi translated"><strong class="jt io">编程语言:</strong> Python，Javascript，SQL，CSS，HTML</li><li id="11f4" class="ml mm in jt b ju mu jy mv kc mw kg mx kk my ko mq mr ms mt bi translated"><strong class="jt io">框架:</strong> React(前端)、Flask(后端)、Bootstrap(CSS)</li><li id="8b77" class="ml mm in jt b ju mu jy mv kc mw kg mx kk my ko mq mr ms mt bi translated"><strong class="jt io">数据库:</strong> PostgreSQL</li></ul><h1 id="ba52" class="kq kr in bd ks kt mf kv kw kx mg kz la lb mh ld le lf mi lh li lj mj ll lm ln bi translated">我们应用程序的预览</h1><ul class=""><li id="db22" class="ml mm in jt b ju lo jy lp kc mn kg mo kk mp ko mq mr ms mt bi translated">这是一个单页 web 应用程序:</li></ul><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi mz"><img src="../Images/7fc0420bfa77afa1ed97906b7db5bd3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cmG4rlGJWNPxZlr6UwJF-Q.png"/></div></div></figure><h1 id="8b3a" class="kq kr in bd ks kt mf kv kw kx mg kz la lb mh ld le lf mi lh li lj mj ll lm ln bi translated">项目目录结构预览</h1><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi na"><img src="../Images/b1e7c65a5135fe6d1e289852821484f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Uye3vPitipFUVv7cXRpbrw.jpeg"/></div></div></figure><h1 id="7319" class="kq kr in bd ks kt mf kv kw kx mg kz la lb mh ld le lf mi lh li lj mj ll lm ln bi translated">准备</h1><ol class=""><li id="a5ce" class="ml mm in jt b ju lo jy lp kc mn kg mo kk mp ko nb mr ms mt bi translated">首先，关于<strong class="jt io"> </strong>这个项目使用的<strong class="jt io">数据刮刀</strong>，请看我写的另一篇文章:<a class="ae kp" href="https://medium.com/@effylh/create-a-data-scraper-for-the-ongoing-k-pop-tv-program-queendom2-with-python-youtube-data-d74103a3d074" rel="noopener">用 Python+YouTube 数据 API+PostgreSQL+HerokuScheduler</a>创建一个数据刮刀</li><li id="ae8d" class="ml mm in jt b ju mu jy mv kc mw kg mx kk my ko nb mr ms mt bi translated">(在 Mac 上)创建并激活虚拟环境<strong class="jt io"> <em class="nc"> queendom </em> </strong>并激活它:</li></ol><pre class="lu lv lw lx gt nd ne nf ng aw nh bi"><span id="1571" class="ni kr in ne b gy nj nk l nl nm">python3 -m venv <strong class="ne io"><em class="nc">queendom</em></strong></span></pre><p id="8ccf" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">然后，激活我们刚刚创建的虚拟环境:</p><pre class="lu lv lw lx gt nd ne nf ng aw nh bi"><span id="e020" class="ni kr in ne b gy nj nk l nl nm">source <strong class="ne io"><em class="nc">queendom</em></strong>/bin/activate</span></pre><p id="e287" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">2.安装所需的软件包:</p><pre class="lu lv lw lx gt nd ne nf ng aw nh bi"><span id="ce9a" class="ni kr in ne b gy nj nk l nl nm">pip install Flask,Flask-Cors,flask-talisman,gunicorn,psycopg2,python-dotenv</span></pre><p id="953b" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">3.创建一个名为<strong class="jt io"> queendom2data </strong>的项目文件夹，然后将<strong class="jt io"> <em class="nc"> cd </em> </strong>放到根目录下:</p><pre class="lu lv lw lx gt nd ne nf ng aw nh bi"><span id="0371" class="ni kr in ne b gy nj nk l nl nm">(queendom) effylh@192 <strong class="ne io">queendom2data</strong> %</span></pre><p id="d20b" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">4.在名为<strong class="jt io"> <em class="nc">【前端】</em> </strong>:(参考:<a class="ae kp" href="https://github.com/facebook/create-react-app" rel="noopener ugc nofollow" target="_blank">https://github.com/facebook/create-react-app</a>)的文件夹中初始化一个新的 React app</p><pre class="lu lv lw lx gt nd ne nf ng aw nh bi"><span id="6710" class="ni kr in ne b gy nj nk l nl nm">(queendom) effylh@192 <strong class="ne io">queendom2data</strong> % npx create-react-app front-end</span></pre><h1 id="92f6" class="kq kr in bd ks kt mf kv kw kx mg kz la lb mh ld le lf mi lh li lj mj ll lm ln bi translated">我们开始吧</h1><p id="c845" class="pw-post-body-paragraph jr js in jt b ju lo jw jx jy lp ka kb kc lq ke kf kg lr ki kj kk ls km kn ko ig bi translated">在本文中本地设置了我们的数据库(包含两个表)之后(<a class="ae kp" href="https://medium.com/@effylh/create-a-data-scraper-for-the-ongoing-k-pop-tv-program-queendom2-with-python-youtube-data-d74103a3d074" rel="noopener">链接</a>，我们现在可以开始构建后端框架了。</p><h2 id="dd5d" class="ni kr in bd ks nn no dn kw np nq dp la kc nr ns le kg nt nu li kk nv nw lm nx bi translated">创建用于执行数据库操作的类</h2><ol class=""><li id="96f0" class="ml mm in jt b ju lo jy lp kc mn kg mo kk mp ko nb mr ms mt bi translated">创建一个名为<strong class="jt io"> dboperations.py </strong>的文件</li><li id="d65b" class="ml mm in jt b ju mu jy mv kc mw kg mx kk my ko nb mr ms mt bi translated">定义一个名为<strong class="jt io"> DatabaseOperate </strong>的类，然后<strong class="jt io"> </strong>定义实例方法<strong class="jt io"> query_table1() </strong>和<strong class="jt io"> query_table2() </strong>，这两个方法用于从数据库已有的两个表(<strong class="jt io">qdscraper _ 1</strong>&amp;<strong class="jt io">qdscraper _ 2</strong>中取出所有数据。</li></ol><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="ny nz l"/></div></figure><h2 id="1b96" class="ni kr in bd ks nn no dn kw np nq dp la kc nr ns le kg nt nu li kk nv nw lm nx bi translated">建立一条烧瓶路线</h2><ol class=""><li id="8de9" class="ml mm in jt b ju lo jy lp kc mn kg mo kk mp ko nb mr ms mt bi translated">创建一个名为<strong class="jt io"> server.py </strong>的文件</li><li id="5006" class="ml mm in jt b ju mu jy mv kc mw kg mx kk my ko nb mr ms mt bi translated">定义一个路由告诉 Flask 使用 URL <strong class="jt io"> <em class="nc"> '/fetch' </em> </strong>来触发函数<strong class="jt io"><em class="nc">fetch _ all _ groups()</em></strong></li><li id="9d98" class="ml mm in jt b ju mu jy mv kc mw kg mx kk my ko nb mr ms mt bi translated">在<strong class="jt io"><em class="nc">fetch _ all _ groups():</em></strong>内部首先导入<strong class="jt io"> <em class="nc"> dboperations </em> </strong>模块，初始化<strong class="jt io"><em class="nc">database operate</em></strong>类。然后我们使用两个变量<strong class="jt io"><em class="nc">table 1 rows&amp;table 2 rows</em></strong>来保存从表<strong class="jt io"> <em class="nc"> qdscraper_1 </em> </strong>和<strong class="jt io"> <em class="nc"> qdscraper_2 </em> </strong>中获取的所有行数据。</li><li id="3fbb" class="ml mm in jt b ju mu jy mv kc mw kg mx kk my ko nb mr ms mt bi translated"><strong class="jt io"> jsonify() </strong>方法以<em class="nc">application/JSON</em>mime type 的格式返回一个<strong class="jt io"> Response </strong>对象。</li><li id="32d7" class="ml mm in jt b ju mu jy mv kc mw kg mx kk my ko nb mr ms mt bi translated">最后，因为我们想在 React app 中调用 Flask route，我们需要导入扩展<strong class="jt io"> flask-cors，</strong>，然后用默认参数<strong class="jt io"> ' <em class="nc"> app '，cors(app)，</em> </strong>初始化该扩展，这允许所有路由上的所有域使用 CORS。</li></ol><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="ny nz l"/></div></figure><h2 id="156f" class="ni kr in bd ks nn no dn kw np nq dp la kc nr ns le kg nt nu li kk nv nw lm nx bi translated">在 React 应用程序中调用 Flask 路线</h2><ul class=""><li id="1a3b" class="ml mm in jt b ju lo jy lp kc mn kg mo kk mp ko mq mr ms mt bi translated">导入并使用<strong class="jt io"> axios </strong>发送 GET 请求到 Flask route<strong class="jt io"><em class="nc">“http://localhost:5000/fetch”，</em> </strong>我们添加一行<strong class="jt io"><em class="nc">console . log(rawdata)</em></strong>来检查我们是否成功检索到我们需要的数据。</li></ul><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="290a" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">输出:我们成功地从数据库的两个表中获取了所有数据！</p><blockquote class="oa ob oc"><p id="a8b1" class="jr js nc jt b ju jv jw jx jy jz ka kb od kd ke kf oe kh ki kj of kl km kn ko ig bi translated">注意:因为在我写这篇文章的时候，我的项目的 scraper 一直在通过 YouTube API 向数据库中插入新数据，所以在本文的其余部分，我们在截图中获得的数据长度可能会有所不同。</p></blockquote><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi og"><img src="../Images/5391d3e8d6fd6731cb6feb825b958eb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k0aSDDNieUnIoye7aiHhgA.png"/></div></div></figure><h2 id="12ba" class="ni kr in bd ks nn no dn kw np nq dp la kc nr ns le kg nt nu li kk nv nw lm nx bi translated">原始数据处理</h2><ol class=""><li id="2806" class="ml mm in jt b ju lo jy lp kc mn kg mo kk mp ko nb mr ms mt bi translated">创建一个名为<strong class="jt io"> DataFactory.js、</strong>的文件，然后定义一个名为<strong class="jt io"> DataFactory 的函数。</strong></li></ol><p id="70e2" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io">数据工厂</strong>返回一个包含已清理数据集的对象:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi oh"><img src="../Images/3cd913629ce9a0fd10bb477de4cfc1b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0HDKiDlUMv3wiSIEbJpJwA.png"/></div></div></figure><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="9382" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">2.调用<strong class="jt io"> App.js </strong>中的<strong class="jt io"> DataFactory </strong>函数，然后(<strong class="jt io"><em class="nc">line 18&amp;19</em></strong>)我们设置状态并(<strong class="jt io"><em class="nc">line 28&amp;29)</em></strong>调用<strong class="jt io"><em class="nc">console . log()</em></strong>函数进行检查</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="af9a" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io">输出:</strong></p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi oi"><img src="../Images/b131255c83359bec3cd576a0f86f7e6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BqtOztKFogOp6URKTotraQ.png"/></div></div></figure><h2 id="e2ea" class="ni kr in bd ks nn no dn kw np nq dp la kc nr ns le kg nt nu li kk nv nw lm nx bi translated">用 Chart.js 创建折线图</h2><ul class=""><li id="21d6" class="ml mm in jt b ju lo jy lp kc mn kg mo kk mp ko mq mr ms mt bi translated">创建名为<strong class="jt io"> LineChart.js </strong>的文件</li><li id="b54d" class="ml mm in jt b ju mu jy mv kc mw kg mx kk my ko mq mr ms mt bi translated">安装模块<strong class="jt io">“react-chart js-2”</strong>:(官方文件:【https://react-chartjs-2.js.org/】T2</li></ul><pre class="lu lv lw lx gt nd ne nf ng aw nh bi"><span id="dad1" class="ni kr in ne b gy nj nk l nl nm">npm install --save chart.js react-chartjs-2</span></pre><ul class=""><li id="47c1" class="ml mm in jt b ju jv jy jz kc oj kg ok kk ol ko mq mr ms mt bi translated">因为我们需要一个折线图，所以从" react-chartjs-2 "中导入<strong class="jt io">【折线图】</strong>模块，</li><li id="7ab2" class="ml mm in jt b ju mu jy mv kc mw kg mx kk my ko mq mr ms mt bi translated">自定义 x 轴刻度的想法是:</li></ul><p id="c607" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">(当数据点数&gt; 100 时:次要刻度以<strong class="jt io"><em class="nc">12 小时制【上午/下午】</em> </strong>的格式显示时间)，主要刻度显示日期</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi om"><img src="../Images/f7f577aeae569670d8efd29bc8d67e13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cfQNPUgStMarDWgd7-JVRg.png"/></div></div></figure><p id="2ca6" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">(当数据点数&gt; 1000 时:x 轴仅显示日期)</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi on"><img src="../Images/aef18221cda6617602018a1f16cb31eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NBHUlaB1TV9DBhF7npgEcg.png"/></div></div></figure><p id="b566" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">为了实现这个目标，我们需要使用适配器(我们在这个项目中使用的是<a class="ae kp" href="https://github.com/chartjs/chartjs-adapter-date-fns" rel="noopener ugc nofollow" target="_blank"><strong class="jt io"><em class="nc">【chart js】-adapter-date-fns</em></strong></a><strong class="jt io"><em class="nc"/></strong>):</p><blockquote class="oa ob oc"><p id="af1b" class="jr js nc jt b ju jv jw jx jy jz ka kb od kd ke kf oe kh ki kj of kl km kn ko ig bi translated">时间刻度需要一个日期库和一个相应的适配器。请从<a class="ae kp" href="https://github.com/chartjs/awesome#adapters" rel="noopener ugc nofollow" target="_blank">可用的适配器</a>中选择。</p></blockquote><p id="eaf4" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">现在，让我们解释一下<strong class="jt io"> LineCharts.js: </strong>中的脚本</p><ul class=""><li id="bce2" class="ml mm in jt b ju jv jy jz kc oj kg ok kk ol ko mq mr ms mt bi translated">箭头功能<strong class="jt io"> <em class="nc">线图包含 2 个对象:</em> </strong></li></ul><ol class=""><li id="850d" class="ml mm in jt b ju jv jy jz kc oj kg ok kk ol ko nb mr ms mt bi translated"><strong class="jt io">选项</strong>:自定义图表属性，如样式、字体、图例等。(如果你不知道如何选择那些属性，请查看官方文档:<a class="ae kp" href="https://www.chartjs.org/docs/latest/" rel="noopener ugc nofollow" target="_blank">链接</a>)</li><li id="6760" class="ml mm in jt b ju mu jy mv kc mw kg mx kk my ko nb mr ms mt bi translated"><strong class="jt io">数据:</strong>定义折线图的数据结构</li></ol><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="ny nz l"/></div></figure><h2 id="4498" class="ni kr in bd ks nn no dn kw np nq dp la kc nr ns le kg nt nu li kk nv nw lm nx bi translated">为 LineChart.js 创建父组件</h2><ol class=""><li id="79d2" class="ml mm in jt b ju lo jy lp kc mn kg mo kk mp ko nb mr ms mt bi translated">创建一个名为<strong class="jt io"> ViewCharts.js </strong>的文件</li><li id="e740" class="ml mm in jt b ju mu jy mv kc mw kg mx kk my ko nb mr ms mt bi translated"><em class="nc">因为</em> <strong class="jt io"> <em class="nc">点赞数</em> </strong> <em class="nc">要到电视剧结束才会公布，所以我们只提取</em> <strong class="jt io"> <em class="nc">点击数</em> </strong> <em class="nc">数据</em>作为图表的源数据集</li><li id="4600" class="ml mm in jt b ju mu jy mv kc mw kg mx kk my ko nb mr ms mt bi translated">为数据库中的每一列定义数组。然后我们使用<strong class="jt io"><em class="nc">array . foreach()</em></strong>函数迭代我们从 scaper 获得的所有数据:将时间值追加到<strong class="jt io"> <em class="nc">标签</em> </strong>数组中，然后将<strong class="jt io"> <em class="nc">视图计数</em> </strong>值追加到数组中。</li><li id="85dd" class="ml mm in jt b ju mu jy mv kc mw kg mx kk my ko nb mr ms mt bi translated">返回并在屏幕上呈现这两个图表</li></ol><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="29d3" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io">结果:</strong></p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi oo"><img src="../Images/8b22a09061a5b2c8fe46d27f1280dad3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yMZeq1TSEAXTLSRtg9ssSA.jpeg"/></div></div></figure><h2 id="1c23" class="ni kr in bd ks nn no dn kw np nq dp la kc nr ns le kg nt nu li kk nv nw lm nx bi translated">用 Bootstrap 设计页面样式</h2><ol class=""><li id="462b" class="ml mm in jt b ju lo jy lp kc mn kg mo kk mp ko nb mr ms mt bi translated">将<strong class="jt io"> <em class="nc"> Bootstrap </em> </strong>安装在 React app 文件夹内:</li></ol><pre class="lu lv lw lx gt nd ne nf ng aw nh bi"><span id="3d53" class="ni kr in ne b gy nj nk l nl nm">npm i -save bootstrap@latest</span></pre><p id="5ffd" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">2.将<strong class="jt io"> <em class="nc"> Bootstrap </em> </strong>导入到<strong class="jt io"> index.js </strong>文件中:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi op"><img src="../Images/4a5a375af49098f9e5574d7dc98ff5b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rkeqcy-KNFOtQcSX21tBtA.png"/></div></div></figure><p id="6eca" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">3.让我们更新<strong class="jt io"> ViewChart.js </strong>中的脚本</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="b9f6" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io">结果:</strong></p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi mz"><img src="../Images/7fc0420bfa77afa1ed97906b7db5bd3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cmG4rlGJWNPxZlr6UwJF-Q.png"/></div></div></figure><h1 id="37f1" class="kq kr in bd ks kt mf kv kw kx mg kz la lb mh ld le lf mi lh li lj mj ll lm ln bi translated">部署</h1><p id="42d3" class="pw-post-body-paragraph jr js in jt b ju lo jw jx jy lp ka kb kc lq ke kf kg lr ki kj kk ls km kn ko ig bi translated">1.准备</p><ul class=""><li id="f042" class="ml mm in jt b ju jv jy jz kc oj kg ok kk ol ko mq mr ms mt bi translated">确保您的计算机上已经安装了 git。</li><li id="1800" class="ml mm in jt b ju mu jy mv kc mw kg mx kk my ko mq mr ms mt bi translated">安装 Heroku CLI:【https://devcenter.heroku.com/articles/heroku-cli T2】</li><li id="e9af" class="ml mm in jt b ju mu jy mv kc mw kg mx kk my ko mq mr ms mt bi translated">(终端)激活项目的虚拟环境。</li><li id="3e85" class="ml mm in jt b ju mu jy mv kc mw kg mx kk my ko mq mr ms mt bi translated">(终端)登录 Heroku:</li></ul><pre class="lu lv lw lx gt nd ne nf ng aw nh bi"><span id="bc95" class="ni kr in ne b gy nj nk l nl nm">heroku login -i</span></pre><ul class=""><li id="c5dd" class="ml mm in jt b ju jv jy jz kc oj kg ok kk ol ko mq mr ms mt bi translated">(终端)自动生成<strong class="jt io">需求。</strong> <strong class="jt io"> txt，</strong>这是一个文件，用来存储项目所有依赖关系的信息:</li></ul><pre class="lu lv lw lx gt nd ne nf ng aw nh bi"><span id="0e3f" class="ni kr in ne b gy nj nk l nl nm">pip freeze &gt; requirements.txt</span></pre><ul class=""><li id="34c3" class="ml mm in jt b ju jv jy jz kc oj kg ok kk ol ko mq mr ms mt bi translated">为了让 Heroku 知道如何启动我们的应用程序，我们需要创建一个名为“Profile”的文件，然后在其中添加一行:</li></ul><pre class="lu lv lw lx gt nd ne nf ng aw nh bi"><span id="7b3b" class="ni kr in ne b gy nj nk l nl nm">web: gunicorn server:app</span></pre><p id="4c97" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io"> <em class="nc"> server </em> </strong>:表示运行我们的应用程序的 python 文件(<strong class="jt io"> server.py </strong>)的名称</p><p id="ae5b" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io"> <em class="nc"> app </em> </strong>:代表 app 名称，可以在<strong class="jt io"> server.py </strong>中找到:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi oq"><img src="../Images/3b6b3977c16b6ae44b8ac8aff07e48d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yW7-SOKzFUBDVuD8ljv3pg.png"/></div></div></figure><p id="2e3c" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">2.在<strong class="jt io"> server.py: </strong>中设置<strong class="jt io"> <em class="nc">静态 _ 文件夹</em> </strong>路径</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi or"><img src="../Images/207f7000725a963457dfdf86fd941adb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k9YTZ3nSXVgW3SbogO07bA.png"/></div></div></figure><p id="5ff2" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">3.不要忘记在<strong class="jt io"> App.js </strong>中将 get 请求 URL 从本地地址改为 Heroku app 地址:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi os"><img src="../Images/71b3e8b736abadf2c1adf9c78f7b9eae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IP9_h-FgLBZILcO_HQBomg.png"/></div></div></figure><p id="6335" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">4.另外，不要忘记在<strong class="jt io"> package.json </strong>中添加一个属性</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi ot"><img src="../Images/af749dcc60b781624f730b2b283d55a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4gusS75h81nii9CXLP_SzQ.png"/></div></div></figure><p id="44dc" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">5.创建应用程序的生产版本<strong class="jt io">，运行:</strong></p><pre class="lu lv lw lx gt nd ne nf ng aw nh bi"><span id="bef7" class="ni kr in ne b gy nj nk l nl nm">npm run <strong class="ne io">build</strong></span></pre><p id="528c" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">6.将更改提交到本地存储库，并将更改部署到 Heroku</p><pre class="lu lv lw lx gt nd ne nf ng aw nh bi"><span id="792d" class="ni kr in ne b gy nj nk l nl nm">git push Heroku main</span></pre><p id="60ed" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io">添加:</strong>如果你想强制 Flask 为 App 使用自己的域而不是 Heroku 生成的域，你需要安装名为<strong class="jt io"> Talisman 的模块，</strong>我们需要在<strong class="jt io"> server.py </strong>中添加一行:</p><pre class="lu lv lw lx gt nd ne nf ng aw nh bi"><span id="e7cd" class="ni kr in ne b gy nj nk l nl nm">Talisman(app, content_security_policy=None)</span></pre></div><div class="ab cl jk jl hr jm" role="separator"><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp"/></div><div class="ig ih ii ij ik"><p id="42fa" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io">本教程到此为止。谢谢！</strong></p><p id="3b81" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">如果你有任何问题，请随时评论。</p></div></div>    
</body>
</html>