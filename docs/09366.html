<html>
<head>
<title>Stop using “static” in PHP</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">停止在 PHP 中使用“静态”</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/stop-using-static-in-php-b150527819b2?source=collection_archive---------2-----------------------#2022-08-17">https://blog.devgenius.io/stop-using-static-in-php-b150527819b2?source=collection_archive---------2-----------------------#2022-08-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a54b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">让我试着说服你为什么共享状态是错误的，以及如何避免它以成为一个更好的开发者</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/83ddee61b4aeacdd136f485d89ffc3ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0vPTnNWr93yQOkbx"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">安瓦尔·阿里在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="157e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我之前的文章中，我试图说服您停止在 PHP 中使用“extends”关键字。今天我有一些关于使用“静态”时共享状态的提示给你。<strong class="ky ir">记住</strong> : <em class="ls">仅仅因为你能，并不意味着你应该。</em></p><p id="f935" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">TL；没有优点，只有缺点。正确设计的代码不需要任何静态方法或静态属性。静态闭包和静态工厂方法非常好。</strong></p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><div class="kg kh ki kj gt ma"><a rel="noopener  ugc nofollow" target="_blank" href="/stop-using-extends-in-php-37c9da1cce83"><div class="mb ab fo"><div class="mc ab md cl cj me"><h2 class="bd ir gy z fp mf fr fs mg fu fw ip bi translated">停止在 PHP 中使用“扩展”</h2><div class="mh l"><h3 class="bd b gy z fp mf fr fs mg fu fw dk translated">你在你的域代码中使用抽象类还是扩展类？希望从今天起，你会停止这样做…</h3></div><div class="mi l"><p class="bd b dl z fp mf fr fs mg fu fw dk translated">blog.devgenius.io</p></div></div><div class="mj l"><div class="mk l ml mm mn mj mo kp ma"/></div></div></a></div></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><p id="eb4d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当参考<strong class="ky ir">静态</strong>时，在写入时有三种可能性。我们将逐一讨论这些问题，并讨论为什么经常使用它们以及如何避免它们。</p><h1 id="69b8" class="mp mq iq bd mr ms mt mu mv mw mx my mz jw na jx nb jz nc ka nd kc ne kd nf ng bi translated">静态类方法</h1><p id="d0bb" class="pw-post-body-paragraph kw kx iq ky b kz nh jr lb lc ni ju le lf nj lh li lj nk ll lm ln nl lp lq lr ij bi translated">静态类方法主要用于轻松地从一个类调用另一个类。一开始这样做可能很诱人，但最终会导致不稳定的决策，比如从用户对象发送电子邮件。最后的结果总是一样:一塌糊涂。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nm"><img src="../Images/22ca1e37303c81950b8a6cdafc072f05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*KtXstEv5E8R2t0-_"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">拉尔夫(拉维)凯登在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="8842" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">缺点</strong>:</p><ul class=""><li id="fb25" class="nn no iq ky b kz la lc ld lf np lj nq ln nr lr ns nt nu nv bi translated">助长了跨越不应该混合的层之间的边界的坏习惯(领域层中的基础设施层)</li><li id="a5e0" class="nn no iq ky b kz nw lc nx lf ny lj nz ln oa lr ns nt nu nv bi translated">单元测试是困难或乏味的(依赖性不容易被模仿)</li></ul><p id="fc55" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">拥抱依赖注入，而不是使用静态方法。实际上，每个现代框架都提供了开箱即用的依赖注入特性。从方法中移除 static 关键字，并在构造函数中注入该类。</p><h1 id="e142" class="mp mq iq bd mr ms mt mu mv mw mx my mz jw na jx nb jz nc ka nd kc ne kd nf ng bi translated">静态类属性</h1><p id="eed0" class="pw-post-body-paragraph kw kx iq ky b kz nh jr lb lc ni ju le lf nj lh li lj nk ll lm ln nl lp lq lr ij bi translated">静态类属性主要用于应用内存化模式来应用微优化。这种简单的缓存技术可以通过将频繁访问的数据保存在实现附近来提高性能。这种方法在 PHP 中不会适得其反，因为该进程只在 HTTP 请求期间是活动的，然后内容被快速释放。</p><p id="2310" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它们还被用于应用单例模式，这是业内流传的最糟糕的模式之一，原因如上所述<em class="ls">静态类方法</em>。</p><p id="a4b6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们开始将代码转移到像 cron 命令、队列工作器这样的长时间运行的进程时，或者当切换到像<a class="ae kv" href="https://www.php.net/manual/en/intro.swoole.php" rel="noopener ugc nofollow" target="_blank"> Swoole </a>这样的异步 PHP 时，事情就变得复杂了。如果数据没有被正确释放，你可能会遇到内存泄漏，内存使用增加，应用程序死于内存不足的错误。</p><p id="160e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">缺点</strong>:</p><ul class=""><li id="c606" class="nn no iq ky b kz la lc ld lf np lj nq ln nr lr ns nt nu nv bi translated">如果不小心处理，可能会导致代码泄漏(在长时间运行流程的情况下)</li><li id="aa8c" class="nn no iq ky b kz nw lc nx lf ny lj nz ln oa lr ns nt nu nv bi translated">单元测试是乏味的(程序员必须在运行之间清除静态属性的内容，以避免由于测试中的数据重叠而导致的错误)</li><li id="3938" class="nn no iq ky b kz nw lc nx lf ny lj nz ln oa lr ns nt nu nv bi translated">在并行处理的情况下，缓存用于每个进程，这不必要地增加了 RAM 的使用</li></ul><p id="a41b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">相反，您应该使用框架的依赖注入特性注入一个缓存适配器，并确保为每个项目设置生存时间，以允许缓存最终被清除。</p><h1 id="8b0c" class="mp mq iq bd mr ms mt mu mv mw mx my mz jw na jx nb jz nc ka nd kc ne kd nf ng bi translated">静态变量</h1><p id="d63a" class="pw-post-body-paragraph kw kx iq ky b kz nh jr lb lc ni ju le lf nj lh li lj nk ll lm ln nl lp lq lr ij bi translated">我从未使用过它们，但我见过它们被用来缓存数据或通过保持可重用的服务(如 HTTP 客户端)来减少内存使用。</p><p id="5f02" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用静态变量的缺点和静态类属性完全一样，同样没有优点。</p><p id="bf16" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您应该在构造函数中注入依赖项，而不是保留静态属性。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="d4ef" class="mp mq iq bd mr ms ob mu mv mw oc my mz jw od jx nb jz oe ka nd kc of kd nf ng bi translated">静态代码的有效方案</h1><p id="e3b9" class="pw-post-body-paragraph kw kx iq ky b kz nh jr lb lc ni ju le lf nj lh li lj nk ll lm ln nl lp lq lr ij bi translated">静态代码有一些完美的场景。这些包括:</p><h2 id="9f47" class="og mq iq bd mr oh oi dn mv oj ok dp mz lf ol om nb lj on oo nd ln op oq nf or bi translated">不可变闭包</h2><pre class="kg kh ki kj gt os ot ou ov aw ow bi"><span id="bb24" class="og mq iq ot b gy ox oy l oz pa">$userList = $collection-&gt;map(static function(User $user): array {<br/>    return [<br/>        'id'       =&gt; $user-&gt;getId(),<br/>        'username' =&gt; $user-&gt;getUsername(),<br/>    ];<br/>});</span></pre><h2 id="d244" class="og mq iq bd mr oh oi dn mv oj ok dp mz lf ol om nb lj on oo nd ln op oq nf or bi translated">不可变工厂方法</h2><pre class="kg kh ki kj gt os ot ou ov aw ow bi"><span id="e6fd" class="og mq iq ot b gy ox oy l oz pa">final class UserNotFoundException extends \DomainException<br/>{<br/>    public static function byId(int $id): self {<br/>        return new self(\sprintf('User by id %d not found', $id));<br/>    }<br/>}</span></pre><h2 id="0f2f" class="og mq iq bd mr oh oi dn mv oj ok dp mz lf ol om nb lj on oo nd ln op oq nf or bi translated">私有不可变方法</h2><pre class="kg kh ki kj gt os ot ou ov aw ow bi"><span id="6c7f" class="og mq iq ot b gy ox oy l oz pa">public function getPrintableName(): string<br/>{<br/>    return \sprintf(<br/>        '%s: %s',<br/>        self::cleanEmoji($this-&gt;title),<br/>        self::cleanEmoji($this-&gt;subtitle),<br/>    );<br/>}</span><span id="f97a" class="og mq iq ot b gy pb oy l oz pa">private static function cleanEmoji(string $input): string<br/>{<br/>    // do the work<br/>}</span></pre></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><p id="6e3b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦脱离了共享状态，在云中部署代码就容易多了。避免静态方法会促进良好的习惯，并使您的代码不那么混乱，更容易测试。</p><p id="61c6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我专业工作中必须维护的成千上万行代码中，我找不到使用静态代码的理由，你也没有理由这么做。问问你自己，你准备好成为一名更好的开发者了吗？从今天起停止使用静态代码，拥抱依赖注入和不变性。<strong class="ky ir">你以后会感谢我的。</strong></p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><p id="3e5d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有疑问吗？想法？请给我留下你的看法。让我们一起让我们的代码变得美丽。订阅我的出版物，获取更多类似的文章，成为更好的开发人员。</p><p id="38ea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个故事对你有价值吗？请留言支持我的工作👏鼓掌表示感谢你知道你可以不止一次鼓掌吗？🥰 <em class="ls">谢谢你。</em></p></div></div>    
</body>
</html>