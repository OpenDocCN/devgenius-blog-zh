<html>
<head>
<title>Beginner’s guide to proxy design pattern in Spring</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Spring 代理设计模式初学者指南</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/demystifying-proxy-in-spring-3ab536046b11?source=collection_archive---------2-----------------------#2022-02-28">https://blog.devgenius.io/demystifying-proxy-in-spring-3ab536046b11?source=collection_archive---------2-----------------------#2022-02-28</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="a44c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在本文中，我们将发现什么是代理，以及 Spring 如何使用代理来抽象复杂性并使开发人员的生活变得更容易。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3237baf7f4dcaa18619267b75453035b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Y_qgVLcXak1jzhnK"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">马库斯·斯皮斯克在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="3902" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">定义</h1><p id="a47c" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated"><code class="fe mc md me mf b">define: proxy</code></p><blockquote class="mg mh mi"><p id="f602" class="jk jl mj jm b jn jo jp jq jr js jt ju mk jw jx jy ml ka kb kc mm ke kf kg kh ig bi translated">如果你自己不能做某事，你授权某人代你做</p></blockquote><p id="fbfd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在软件开发术语中，您可以将代理定义为</p><blockquote class="mg mh mi"><p id="8c3e" class="jk jl mj jm b jn jo jp jq jr js jt ju mk jw jx jy ml ka kb kc mm ke kf kg kh ig bi translated">一个对象，充当另一个对象的占位符，以控制它所代表的真实对象的创建和访问</p></blockquote><h1 id="659e" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">代理设计模式</h1><p id="0e84" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">它是处理类和对象组合的结构设计模式的一部分。</p><h2 id="913a" class="mn la in bd lb mo mp dn lf mq mr dp lj jv ms mt ln jz mu mv lr kd mw mx lv my bi translated">使用这种模式，我们试图解决什么问题？</h2><ul class=""><li id="9eb6" class="mz na in jm b jn lx jr ly jv nb jz nc kd nd kh ne nf ng nh bi translated">控制对象的访问。</li><li id="ed8a" class="mz na in jm b jn ni jr nj jv nk jz nl kd nm kh ne nf ng nh bi translated">在访问对象时提供附加功能。</li></ul><h2 id="ad7d" class="mn la in bd lb mo mp dn lf mq mr dp lj jv ms mt ln jz mu mv lr kd mw mx lv my bi translated"><strong class="ak">与 adaptor 和 decorator 有什么不同？</strong></h2><ul class=""><li id="120a" class="mz na in jm b jn lx jr ly jv nb jz nc kd nd kh ne nf ng nh bi translated">它提供与它所引用的对象相同的接口，并且不以任何方式修改数据。</li><li id="afcc" class="mz na in jm b jn ni jr nj jv nk jz nl kd nm kh ne nf ng nh bi translated">它有关于编译时真实主题的信息。</li></ul><p id="6220" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这个 UML 类图和序列图中，你可以看到代理作为客户端和真实主体之间的接口。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/0fa9df4582ecd0bdc265a91af8b6e97a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/1*rKCOCyxJHYjkfo_2iDhQKg.jpeg"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">作者范德乔——自己的作品，CC BY-SA 4.0，<a class="ae ky" href="https://commons.wikimedia.org/w/index.php?curid=62347717" rel="noopener ugc nofollow" target="_blank">https://commons.wikimedia.org/w/index.php?curid=62347717</a></figcaption></figure><h1 id="c1d1" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">Spring AOP 及其代理机制</h1><p id="c82e" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated"><em class="mj"> AOP(面向方面编程)是一种编程范式，旨在增加方面的模块化。方面支持关注点的模块化，比如跨越多种类型和对象的事务管理。</em></p><h2 id="f8cf" class="mn la in bd lb mo mp dn lf mq mr dp lj jv ms mt ln jz mu mv lr kd mw mx lv my bi translated"><strong class="ak">春天有什么帮助？</strong></h2><ul class=""><li id="41e8" class="mz na in jm b jn lx jr ly jv nb jz nc kd nd kh ne nf ng nh bi translated">它提供声明式企业服务，特别是作为 EJB 声明式服务的替代。最重要的服务是<em class="mj">声明式事务管理</em>。</li><li id="ae0f" class="mz na in jm b jn ni jr nj jv nk jz nl kd nm kh ne nf ng nh bi translated">它允许用户实现定制的方面，用 AOP 补充他们对 OOP 的使用。</li></ul><h2 id="d66e" class="mn la in bd lb mo mp dn lf mq mr dp lj jv ms mt ln jz mu mv lr kd mw mx lv my bi translated"><strong class="ak">代理机构</strong></h2><p id="9ec0" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">Spring AOP 是一个基于代理的 AOP 框架。这意味着为了实现目标对象的方面，它将创建该对象的代理。这可以通过以下两种方式实现:</p><ol class=""><li id="c56c" class="mz na in jm b jn jo jr js jv no jz np kd nq kh nr nf ng nh bi translated"><strong class="jm io"> JDK 动态代理:</strong>Spring AOP 的首选方式。只要目标对象实现了一个接口，就会使用 JDK 动态代理</li><li id="276c" class="mz na in jm b jn ni jr nj jv nk jz nl kd nm kh nr nf ng nh bi translated"><strong class="jm io"> CGLIB 代理:</strong>如果目标对象没有实现接口，那么可以使用 CGLIB 代理</li></ol><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/1ec91a5ee84e74ee2f0730492555f50c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3AlJP4bvBWAfGD-XNrtzpw.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">JDK 和 CGLIB 代理的黑白差异</figcaption></figure><h2 id="8d6d" class="mn la in bd lb mo mp dn lf mq mr dp lj jv ms mt ln jz mu mv lr kd mw mx lv my bi translated"><strong class="ak">通过示例理解代理机制</strong></h2><p id="b9ec" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated"><strong class="jm io">案例一:无代理</strong></p><pre class="kj kk kl km gt nt mf nu nv aw nw bi"><span id="14c6" class="mn la in mf b gy nx ny l nz oa"><strong class="mf io">public</strong> <strong class="mf io">class</strong> EmployeeServiceImpl <strong class="mf io">implements</strong> EmployeeService {<br/><br/>   <strong class="mf io">public</strong> <strong class="mf io">void</strong> method1() {<br/>      <strong class="mf io">this</strong>.method2();<br/>   }<br/>   <br/>   <strong class="mf io">public</strong> <strong class="mf io">void</strong> method2() {<br/>      log.info("understanding self invocation")<br/>   }<br/>}</span><span id="8623" class="mn la in mf b gy ob ny l nz oa">// This is Main class where we will invoke method1 of <br/>// EmployeeService object<br/><strong class="mf io">public</strong> <strong class="mf io">class</strong> Main {<br/><br/>   <strong class="mf io">public</strong> <strong class="mf io">static</strong> <strong class="mf io">void</strong> main(String[] args) {<br/>      EmployeeService employeeService = <strong class="mf io">new</strong> EmployeeServiceImpl();<br/>      employeeService.method1();<br/>   }<br/>}</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/0e9aa12e859d650fb0e6a098202d0466.png" data-original-src="https://miro.medium.com/v2/resize:fit:466/format:webp/1*G_90CxxQzwmZJPAj5a78Lg.jpeg"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">这里客户端对象直接调用实际的方法(非代理的情况)</figcaption></figure><p id="adc5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这个例子中没有代理，方法是直接在对象引用上调用的。</p><p id="e56b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">案例二:带代理</strong></p><pre class="kj kk kl km gt nt mf nu nv aw nw bi"><span id="e100" class="mn la in mf b gy nx ny l nz oa"><strong class="mf io">public</strong> <strong class="mf io">class</strong> EmployeeServiceImpl <strong class="mf io">implements</strong> EmployeeService {<br/><br/>   <strong class="mf io">public</strong> <strong class="mf io">void</strong> method1() {<br/>      <strong class="mf io">this</strong>.method2();<br/>   }<br/>   <br/>   <strong class="mf io">public</strong> <strong class="mf io">void</strong> method2() {<br/>      log.info("understanding proxy")<br/>   }<br/>}</span><span id="7e97" class="mn la in mf b gy ob ny l nz oa">// This is Main class where we will invoke method1 of <br/>// EmployeeService object behind a proxy<br/><strong class="mf io">public</strong> <strong class="mf io">class</strong> Main {<br/><br/>   <strong class="mf io">public</strong> <strong class="mf io">static</strong> <strong class="mf io">void</strong> main(String[] args) {<br/>      ProxyFactory factory = <strong class="mf io">new</strong> ProxyFactory(<br/>          <strong class="mf io">new</strong> EmployeeServiceImpl()<br/>      );<br/>      factory.addInterface(EmployeeService.<strong class="mf io">class</strong>);<br/>      factory.addAdvice(<strong class="mf io">new</strong> RetryAdvice());<br/><br/>      EmployeeService employeeProxyService = (EmployeeService)<br/>          factory.getProxy();    <br/>      employeeProxyService.method1();<br/>   }<br/>}</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi od"><img src="../Images/29a7db37b3dc42694056c02948c76091.png" data-original-src="https://miro.medium.com/v2/resize:fit:646/format:webp/1*7TeRzMuxxRp1rZNb0qf6qw.jpeg"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">在这里，客户端对象与代理和实际方法的代理委托进行交互(被代理的情况)</figcaption></figure><p id="c9d3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这个例子中，客户端代码引用了代理，而不是实际的方法。然后代理委托给实际的方法。</p><p id="68aa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这就是为什么我们在使用@Async、@Cacheable、@Transactional 等装饰器时应该避免犯这种<a class="ae ky" href="https://pratiyush.medium.com/one-common-mistake-which-we-should-avoid-while-using-async-and-cacheable-in-spring-boot-a967cea27d55" rel="noopener">错误</a>。</p><h1 id="c379" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">替代代理</h1><p id="38e3" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">替代代理的方法是字节码编织。当使用字节码编织机制时，永远不会有第二个对象(也就是代理)。相反，如果需要应用行为(如事务管理或安全性)，它会被“编入”现有代码，而不是“围绕它”。</p><p id="2334" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一般来说，字节码编织方法需要更多的时间来设置，这取决于您的环境。在某些情况下，您需要设置一个 java 代理，在其他情况下，您可能需要修改您的编译过程，其他框架可能需要使用不同的类加载器。换句话说，字节码编织有点难以设置。</p><h1 id="cd0e" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">代理的经验法则</h1><ul class=""><li id="8969" class="mz na in jm b jn lx jr ly jv nb jz nc kd nd kh ne nf ng nh bi translated">代理增加了开销，如果应用于被代理的对象的行为与长时间运行的操作有关，则这种开销可以忽略不计。</li><li id="20a6" class="mz na in jm b jn ni jr nj jv nk jz nl kd nm kh ne nf ng nh bi translated">如果您需要非常细粒度的行为，并希望将其应用于一大组对象，那么使用字节码编织方法可能更安全，比如 AspectJ。</li><li id="7cf5" class="mz na in jm b jn ni jr nj jv nk jz nl kd nm kh ne nf ng nh bi translated">使用基于代理的系统可能可以解决 80%的需求。对于最后一英里，或者剩下的 20%，选择字节码编织方法可能是一个好的选择。</li></ul></div><div class="ab cl oe of hr og" role="separator"><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj"/></div><div class="ig ih ii ij ik"><p id="bae0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在研究这个话题的时候，我读了很多文章，这是我所学到的最重要的东西。如果你想深入挖掘，你可以浏览这些博客</p><ul class=""><li id="4316" class="mz na in jm b jn jo jr js jv no jz np kd nq kh ne nf ng nh bi translated"><a class="ae ky" href="https://www.baeldung.com/java-proxy-pattern" rel="noopener ugc nofollow" target="_blank">https://www.baeldung.com/java-proxy-pattern</a></li><li id="5058" class="mz na in jm b jn ni jr nj jv nk jz nl kd nm kh ne nf ng nh bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Design_Patterns" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Design_Patterns</a></li><li id="52c0" class="mz na in jm b jn ni jr nj jv nk jz nl kd nm kh ne nf ng nh bi translated"><a class="ae ky" href="https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html#aop-proxying" rel="noopener ugc nofollow" target="_blank">https://docs . spring . io/spring-framework/docs/3.2 . x/spring-framework-reference/html/AOP . html # AOP-proxing</a></li><li id="8dd9" class="mz na in jm b jn ni jr nj jv nk jz nl kd nm kh ne nf ng nh bi translated"><a class="ae ky" href="https://www.baeldung.com/spring-aop" rel="noopener ugc nofollow" target="_blank">https://www.baeldung.com/spring-aop</a></li><li id="9c82" class="mz na in jm b jn ni jr nj jv nk jz nl kd nm kh ne nf ng nh bi translated"><a class="ae ky" href="https://spring.io/blog/2007/07/19/debunking-myths-proxies-impact-performance/" rel="noopener ugc nofollow" target="_blank">https://spring . io/blog/2007/07/19/揭穿-神话-代理-影响-性能/ </a></li><li id="a668" class="mz na in jm b jn ni jr nj jv nk jz nl kd nm kh ne nf ng nh bi translated"><a class="ae ky" href="https://www.baeldung.com/java-structural-design-patterns#:~:text=Decorator%20Pattern&amp;text=Although%20Proxy%20and%20Decorator%20patterns,reference%20to%20the%20original%20object" rel="noopener ugc nofollow" target="_blank">https://www . bael dung . com/Java-structural-design-patterns #:~:text = Decorator % 20 pattern&amp;text = which % 20 proxy % 20 and % 20 Decorator % 20 patterns，reference % 20 to % 20 the % 20 original % 20 object</a></li><li id="3cfa" class="mz na in jm b jn ni jr nj jv nk jz nl kd nm kh ne nf ng nh bi translated"><a class="ae ky" href="https://spring.io/blog/2012/05/23/transactions-caching-and-aop-understanding-proxy-usage-in-spring" rel="noopener ugc nofollow" target="_blank">https://spring . io/blog/2012/05/23/transactions-caching-and-AOP-understanding-proxy-usage-in-spring</a></li></ul></div></div>    
</body>
</html>