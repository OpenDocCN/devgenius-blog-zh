<html>
<head>
<title>Generate boring code using ChatGPT</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 ChatGPT 生成无聊的代码</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/an-ai-generated-code-on-todo-service-using-spring-boot-graphql-aeb4b741d4a7?source=collection_archive---------4-----------------------#2022-12-07">https://blog.devgenius.io/an-ai-generated-code-on-todo-service-using-spring-boot-graphql-aeb4b741d4a7?source=collection_archive---------4-----------------------#2022-12-07</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/8e4dae5663af4e6e124d31607e9ebbd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Z-Ob2LvQzfu5HkJR"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">杰克逊·索法特在<a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="076a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我在探索 ChatGPT。我将和大家分享我的一个经历。</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><p id="46cf" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我在系统中提出的第一个问题是</p><blockquote class="lf"><p id="41f8" class="lg lh in bd li lj lk ll lm ln lo kx dk translated">你能用 spring boot GraphQL 写一篇关于 todo 服务的文章吗？</p></blockquote><p id="8fc7" class="pw-post-body-paragraph ka kb in kc b kd lp kf kg kh lq kj kk kl lr kn ko kp ls kr ks kt lt kv kw kx ig bi translated">我立即得到的回复就贴在下面</p><p id="5dda" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">GraphQL 是一种用于 API 的查询语言，它允许客户端准确地请求他们需要的数据，使得在单个请求中获得所有需要的数据成为可能。这使得它成为传统 REST APIss 的一种高效而强大的替代方法，传统 REST API 通常需要多次往返来获取所有必要的数据。</p><p id="e469" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在本文中，我们将学习如何使用 Spring Boot 和 GraphQL 创建一个 GraphQL 服务。我们将从建立项目开始，然后我们将定义模式，创建数据模型，最后，我们将实现 GraphQL 查询和变异解析器。</p><h1 id="a443" class="lu lv in bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">设置项目</h1><p id="f94e" class="pw-post-body-paragraph ka kb in kc b kd ms kf kg kh mt kj kk kl mu kn ko kp mv kr ks kt mw kv kw kx ig bi translated">首先，我们需要使用 Spring Initializr 创建一个新的 Spring Boot 项目。我们将选择以下依赖项:</p><ul class=""><li id="6a4f" class="mx my in kc b kd ke kh ki kl mz kp na kt nb kx nc nd ne nf bi translated">网</li><li id="8836" class="mx my in kc b kd ng kh nh kl ni kp nj kt nk kx nc nd ne nf bi translated">GraphQL</li><li id="182e" class="mx my in kc b kd ng kh nh kl ni kp nj kt nk kx nc nd ne nf bi translated">Lombok(用于简化数据模型)</li></ul><p id="6d9c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一旦创建了项目，我们需要将<code class="fe nl nm nn no b">graphql-java-tools</code>依赖项添加到<code class="fe nl nm nn no b">pom.xml</code>文件中:</p><pre class="np nq nr ns gt nt no nu bn nv nw bi"><span id="0d6d" class="nx lv in no b be ny nz l oa ob">&lt;dependency&gt;<br/>    &lt;groupId&gt;com.graphql-java&lt;/groupId&gt;<br/>    &lt;artifactId&gt;graphql-java-tools&lt;/artifactId&gt;<br/>    &lt;version&gt;5.7.0&lt;/version&gt;<br/>&lt;/dependency&gt;</span></pre><p id="5a89" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这种依赖性允许我们使用<code class="fe nl nm nn no b">@GraphQLQuery</code>和<code class="fe nl nm nn no b">@GraphQLMutation</code>注释来定义查询和变异解析器。</p><h1 id="945e" class="lu lv in bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">定义模式</h1><p id="4478" class="pw-post-body-paragraph ka kb in kc b kd ms kf kg kh mt kj kk kl mu kn ko kp mv kr ks kt mw kv kw kx ig bi translated">下一步是为我们的服务定义 GraphQL 模式。该模式定义了可以查询的数据类型以及可以执行的操作(查询和变异)。</p><p id="2fa0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在我们的例子中，我们将为待办事项列表应用程序创建一个简单的模式。该模式将定义以下类型:</p><ul class=""><li id="e6fa" class="mx my in kc b kd ke kh ki kl mz kp na kt nb kx nc nd ne nf bi translated"><code class="fe nl nm nn no b">Todo</code>:表示状态为<code class="fe nl nm nn no b">id</code>、<code class="fe nl nm nn no b">title</code>、<code class="fe nl nm nn no b">completed</code>的待办事项。</li><li id="0657" class="mx my in kc b kd ng kh nh kl ni kp nj kt nk kx nc nd ne nf bi translated"><code class="fe nl nm nn no b">Query</code>:定义可以对数据进行的查询。</li><li id="0f56" class="mx my in kc b kd ng kh nh kl ni kp nj kt nk kx nc nd ne nf bi translated"><code class="fe nl nm nn no b">Mutation</code>:定义可以对数据执行的突变(创建、更新和删除操作)。</li></ul><p id="dcdd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">下面是模式定义:</p><pre class="np nq nr ns gt nt no nu bn nv nw bi"><span id="e234" class="nx lv in no b be ny nz l oa ob">type Todo {<br/>    id: ID!<br/>    title: String!<br/>    completed: Boolean!<br/>}<br/><br/>type Query {<br/>    todos: [Todo]<br/>    todo(id: ID!): Todo<br/>}<br/><br/>type Mutation {<br/>    addTodo(title: String!, completed: Boolean!): Todo<br/>    updateTodo(id: ID!, title: String, completed: Boolean): Todo<br/>    deleteTodo(id: ID!): Todo<br/>}</span></pre><p id="14c0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">注意，我们使用 GraphQL 提供的<code class="fe nl nm nn no b">ID</code>和<code class="fe nl nm nn no b">String</code>类型，以及<code class="fe nl nm nn no b">!</code>和<code class="fe nl nm nn no b">[]</code>符号来分别表示不可空类型和列表类型。</p><h1 id="3f35" class="lu lv in bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">创建数据模型</h1><p id="1943" class="pw-post-body-paragraph ka kb in kc b kd ms kf kg kh mt kj kk kl mu kn ko kp mv kr ks kt mw kv kw kx ig bi translated">接下来，我们需要为我们的服务创建数据模型。我们将使用<code class="fe nl nm nn no b">Todo</code>类来表示一个待办事项。该类将具有以下属性:</p><ul class=""><li id="c97f" class="mx my in kc b kd ke kh ki kl mz kp na kt nb kx nc nd ne nf bi translated"><code class="fe nl nm nn no b">id</code>:待办事项的唯一标识。</li><li id="e900" class="mx my in kc b kd ng kh nh kl ni kp nj kt nk kx nc nd ne nf bi translated"><code class="fe nl nm nn no b">title</code>:待办事项的标题。</li><li id="3781" class="mx my in kc b kd ng kh nh kl ni kp nj kt nk kx nc nd ne nf bi translated"><code class="fe nl nm nn no b">completed</code>:表示待办事项是否完成的标志。</li></ul><blockquote class="lf"><p id="19f7" class="lg lh in bd li lj oc od oe of og kx dk translated">问 AI 系统的后续问题是“可以创建数据模型类和解析器服务吗？”</p></blockquote><p id="d72f" class="pw-post-body-paragraph ka kb in kc b kd lp kf kg kh lq kj kk kl lr kn ko kp ls kr ks kt lt kv kw kx ig bi translated">确切答复-</p><p id="8991" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当然，这里是<code class="fe nl nm nn no b">Todo</code>类以及查询和变异解析器:</p><pre class="np nq nr ns gt nt no nu bn nv nw bi"><span id="f839" class="nx lv in no b be ny nz l oa ob">import lombok.AllArgsConstructor;<br/>import lombok.Data;<br/>import lombok.NoArgsConstructor;<br/><br/>@Data<br/>@AllArgsConstructor<br/>@NoArgsConstructor<br/>public class Todo {<br/>    private String id;<br/>    private String title;<br/>    private boolean completed;<br/>}</span></pre><pre class="oh nt no nu bn nv nw bi"><span id="5bd5" class="nx lv in no b be ny nz l oa ob">import java.util.ArrayList;<br/>import java.util.HashMap;<br/>import java.util.List;<br/>import java.util.Map;<br/>import java.util.UUID;<br/><br/>import org.springframework.stereotype.Service;<br/><br/>import com.coxautodev.graphql.tools.GraphQLMutationResolver;<br/>import com.coxautodev.graphql.tools.GraphQLQueryResolver;<br/><br/>@Service<br/>public class TodoResolver implements GraphQLQueryResolver, GraphQLMutationResolver {<br/><br/>    private final Map&lt;String, Todo&gt; todos = new HashMap&lt;&gt;();<br/><br/>    @GraphQLQuery(name = "todos")<br/>    public List&lt;Todo&gt; getTodos() {<br/>        return new ArrayList&lt;&gt;(todos.values());<br/>    }<br/><br/>    @GraphQLQuery(name = "todo")<br/>    public Todo getTodo(@GraphQLArgument(name = "id") String id) {<br/>        return todos.get(id);<br/>    }<br/><br/>    @GraphQLMutation(name = "addTodo")<br/>    public Todo addTodo(@GraphQLArgument(name = "title") String title, @GraphQLArgument(name = "completed") boolean completed) {<br/>        Todo todo = new Todo(UUID.randomUUID().toString(), title, completed);<br/>        todos.put(todo.getId(), todo);<br/>        return todo;<br/>    }<br/><br/>    @GraphQLMutation(name = "updateTodo")<br/>    public Todo updateTodo(@GraphQLArgument(name = "id") String id, @GraphQLArgument(name = "title") String title, @GraphQLArgument(name = "completed") boolean completed) {<br/>        Todo todo = todos.get(id);<br/>        if (todo == null) {<br/>            return null;<br/>        }<br/>        todo.setTitle(title);<br/>        todo.setCompleted(completed);<br/>        return todo;<br/>    }<br/><br/>    @GraphQLMutation(name = "deleteTodo")<br/>    public Todo deleteTodo(@GraphQLArgument(name = "id") String id) {<br/>        return todos.remove(id);<br/>    }<br/><br/>}</span></pre><p id="d53a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">到目前为止一切顺利　‘😎，然后我问了下面的跟进问题</p><blockquote class="lf"><p id="2df2" class="lg lh in bd li lj lk ll lm ln lo kx dk translated">"你能在这里使用 mongo db 吗？"</p></blockquote><pre class="oi oj ok ol om nt no nu bn nv nw bi"><span id="f104" class="nx lv in no b be ny nz l oa ob">import java.util.List;<br/>import java.util.Optional;<br/>import java.util.UUID;<br/><br/>import org.springframework.stereotype.Service;<br/><br/>import com.coxautodev.graphql.tools.GraphQLMutationResolver;<br/>import com.coxautodev.graphql.tools.GraphQLQueryResolver;<br/><br/>@Service<br/>public class TodoResolver implements GraphQLQueryResolver, GraphQLMutationResolver {<br/><br/>    private final TodoRepository todoRepository;<br/><br/>    public TodoResolver(TodoRepository todoRepository) {<br/>        this.todoRepository = todoRepository;<br/>    }<br/><br/>    @GraphQLQuery(name = "todos")<br/>    public List&lt;Todo&gt; getTodos() {<br/>        return todoRepository.findAll();<br/>    }<br/><br/>    @GraphQLQuery(name = "todo")<br/>    public Optional&lt;Todo&gt; getTodo(@GraphQLArgument(name = "id") String id) {<br/>        return todoRepository.findById(id);<br/>    }<br/><br/>    @GraphQLMutation(name = "addTodo")<br/>    public Todo addTodo(@GraphQLArgument(name = "title") String title, @GraphQLArgument(name = "completed") boolean completed) {<br/>        Todo todo = new Todo(UUID.randomUUID().toString(), title, completed);<br/>        return todoRepository.save(todo);<br/>    }<br/><br/>    @GraphQLMutation(name = "updateTodo")<br/>    public Optional&lt;Todo&gt; updateTodo(@GraphQLArgument(name = "id") String id, @GraphQLArgument(name = "title") String title, @GraphQLArgument(name = "completed") boolean completed) {<br/>        Optional&lt;Todo&gt; optionalTodo = todoRepository.findById(id);<br/>        if (optionalTodo.isEmpty()) {<br/>            return Optional.empty();<br/>        }<br/>        Todo todo = optionalTodo.get();<br/>        todo.setTitle(title);<br/>        todo.setCompleted(completed);<br/>        return Optional.of(todoRepository.save(todo));<br/>    }<br/><br/>    @GraphQLMutation(name = "deleteTodo")<br/>    public Optional&lt;Todo&gt; deleteTodo(@GraphQLArgument(name = "id") String id) {<br/>        Optional&lt;Todo&gt; optionalTodo = todoRepository.findById(id);<br/>        if (optionalTodo.isEmpty()) {<br/>            return Optional.empty();<br/>        }<br/>        todoRepository.deleteById(id);<br/>        return optionalTodo;<br/>    }<br/><br/>}</span></pre><p id="355b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这个实现中，我们将一个<code class="fe nl nm nn no b">TodoRepository</code>实例注入 resolver 类。这个存储库用于访问 MongoDB 数据库中的待办事项。</p><p id="d9cd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">查询和变异解析器方法被更新为使用存储库而不是内存存储。例如，<code class="fe nl nm nn no b">getTodos()</code>方法现在使用存储库的<code class="fe nl nm nn no b">findAll()</code>方法从数据库中获取所有待办事项。</p><p id="1dbd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">可怕的🔥！！。下一个跟进问题</p><blockquote class="lf"><p id="608e" class="lg lh in bd li lj lk ll lm ln lo kx dk translated">我如何从操场上测试它？</p></blockquote><p id="6af6" class="pw-post-body-paragraph ka kb in kc b kd lp kf kg kh lq kj kk kl lr kn ko kp ls kr ks kt lt kv kw kx ig bi translated">要从操场上测试 todo GraphQL 服务，请遵循以下步骤:</p><ol class=""><li id="9b82" class="mx my in kc b kd ke kh ki kl mz kp na kt nb kx on nd ne nf bi translated">通过运行主类来启动 Spring Boot 应用程序。</li><li id="0829" class="mx my in kc b kd ng kh nh kl ni kp nj kt nk kx on nd ne nf bi translated">在您的网络浏览器中访问<a class="ae jz" href="http://localhost:8080/graphql" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/GraphQL</a>，打开 graph QL 游乐场。</li><li id="fbbc" class="mx my in kc b kd ng kh nh kl ni kp nj kt nk kx on nd ne nf bi translated">在 playground 中，您可以编写和执行 GraphQL 查询和变异来对 todo 项执行各种操作。例如，您可以使用以下查询来查询所有待办事项:</li></ol><pre class="np nq nr ns gt nt no nu bn nv nw bi"><span id="aa36" class="nx lv in no b be ny nz l oa ob">query {<br/>  todos {<br/>    id<br/>    title<br/>    completed<br/>  }<br/>}</span></pre><p id="c5c8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">4.您还可以使用以下变体创建一个新的 todo 项</p><pre class="np nq nr ns gt nt no nu bn nv nw bi"><span id="d0b5" class="nx lv in no b be ny nz l oa ob">mutation {<br/>  addTodo(title: "Write an article", completed: false) {<br/>    id<br/>    title<br/>  }<br/>}</span></pre><p id="ce33" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">5.类似地，您可以使用适当的变化来更新和删除 todo 项。</p><p id="6fd7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">kudos ChatGPT👏</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h1 id="2789" class="lu lv in bd lw lx oo lz ma mb op md me mf oq mh mi mj or ml mm mn os mp mq mr bi translated">结论</h1><p id="6fc1" class="pw-post-body-paragraph ka kb in kc b kd ms kf kg kh mt kj kk kl mu kn ko kp mv kr ks kt mw kv kw kx ig bi translated">人工智能系统很快就生成了内容和代码。但是这里需要强调一点，要在实际项目中使用人工智能生成的代码，开发人员应该对该技术有基本的了解，因为它需要修改。</p><p id="cbc6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你有什么看法，我来评论一下！</p></div></div>    
</body>
</html>