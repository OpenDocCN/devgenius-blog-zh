<html>
<head>
<title>Implementing Pinterest-like layout using compositional layout</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用复合布局实现类似 Pinterest 的布局</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/implementing-pinterest-like-layout-using-compositional-layout-a21d8ae49d18?source=collection_archive---------1-----------------------#2022-12-01">https://blog.devgenius.io/implementing-pinterest-like-layout-using-compositional-layout-a21d8ae49d18?source=collection_archive---------1-----------------------#2022-12-01</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/baa0ae1822c0a8d2e5f2b541ff8f5063.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*I0_MWAXElTHvDvECzvGlJg.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">截图取自 Pinterest app</figcaption></figure><p id="eed9" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">类似 Pinterest 的布局并不是一个尚未解决或有争议解决方案的新问题。互联网上有很多库允许你以马赛克的方式显示单元格——例如<a class="ae kx" href="https://github.com/sgr-ksmt/WaterfallLayout" rel="noopener ugc nofollow" target="_blank">这个</a>。</p><p id="cb2c" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">然而，大多数都依赖于实现一个定制的<strong class="kb io"> UICollectionViewLayout </strong>子类，尽管我们已经有一段时间有了一个新的组合布局 API——<a class="ae kx" href="https://developer.apple.com/documentation/uikit/uicollectionviewcompositionallayout" rel="noopener ugc nofollow" target="_blank">uicollectionviewscompositionallayout</a></p><p id="a2b0" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">使用自定义 UICollectionViewLayout 会限制您在收藏视图中拥有不同的布局部分，因为您只能拥有一个收藏视图的布局实例:</p><pre class="ky kz la lb gt lc ld le bn lf lg bi"><span id="87a5" class="lh li in ld b be lj lk l ll lm">let layout = WaterfallLayout() <br/>collectionView.collectionViewLayout = layout</span></pre><h1 id="3a47" class="ln li in bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">通过组合布局构建马赛克布局的可能方式</h1><p id="f7e4" class="pw-post-body-paragraph jz ka in kb b kc mk ke kf kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw ig bi translated">当我在寻找使用组合方式引入瀑布布局的库时，我发现了在一个垂直组中组合不同高度的项目来构建 secion 的解决方案。</p><p id="3369" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">让我们看看实现这种方法的库。它有<strong class="kb io">瀑布布局</strong>，将三个不同高度的项目组合在一个垂直组中。</p><pre class="ky kz la lb gt lc ld le bn lf lg bi"><span id="09d0" class="lh li in ld b be lj lk l ll lm">let leadingItemSize = NSCollectionLayoutSize(widthDimension: .fractionalWidth(0.5), heightDimension: .fractionalHeight(1.0)) <br/>let leadingItem = NSCollectionLayoutItem(layoutSize: leadingItemSize) <br/>leadingItem.contentInsets = NSDirectionalEdgeInsets(top: 8, leading: 8, bottom: 8, trailing: 8)<br/>let trailingItemSize = NSCollectionLayoutSize(widthDimension: .fractionalWidth(1.0), heightDimension: .fractionalHeight(0.3)) <br/>let trailingItem = NSCollectionLayoutItem(layoutSize: trailingItemSize) <br/>trailingItem.contentInsets = NSDirectionalEdgeInsets(top: 8, leading: 8, bottom: 8, trailing: 8) <br/>let trailingLeftGroup = NSCollectionLayoutGroup.vertical(<br/>  layoutSize: NSCollectionLayoutSize(<br/>    widthDimension: .fractionalWidth(0.25), <br/>    heightDimension: .fractionalHeight(1.0)<br/>  ), <br/>  subitem: trailingItem, <br/>  count: 2) <br/>let trailingRightGroup = NSCollectionLayoutGroup.vertical(<br/>  layoutSize: NSCollectionLayoutSize(<br/>    widthDimension: .fractionalWidth(0.25), <br/>    heightDimension: .fractionalHeight(1.0)<br/>  ), <br/>  subitem: trailingItem, <br/>  count: 2<br/>) <br/>...</span></pre><p id="f3a6" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在屏幕上看起来是这样的:</p><figure class="ky kz la lb gt jo gh gi paragraph-image"><div class="gh gi jk"><img src="../Images/30c4acca592bd608cedd96e29fb0cacc.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*ElFTE-nBrMzguiYRZcxV9g.jpeg"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">来自 cmpositional-layout-kit-repo 的屏幕截图</figcaption></figure><p id="d81e" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">它有几个缺点，例如:</p><ul class=""><li id="684e" class="mp mq in kb b kc kd kg kh kk mr ko ms ks mt kw mu mv mw mx bi translated">这种模式是重复的——每三个项目都有相同的结构高度</li><li id="28ac" class="mp mq in kb b kc my kg mz kk na ko nb ks nc kw mu mv mw mx bi translated">它使用分数高度-依赖于集合视图框架高度，而不是单独项目所需的高度</li></ul><p id="573e" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在某个时候，我偶然发现了一个有趣的 API uicollectionview compositionallayout has—<a class="ae kx" href="https://developer.apple.com/documentation/uikit/nscollectionlayoutgroup/3213853-custom" rel="noopener ugc nofollow" target="_blank">自定义组创建</a>。我还发现<a class="ae kx" href="https://github.com/lucamegh/Niagara" rel="noopener ugc nofollow" target="_blank">有一个库</a>实现了这种方法。大家妥妥的看一下，试着自己去实现。</p><h1 id="6f38" class="ln li in bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">履行</h1><h2 id="657e" class="nd li in bd lo ne nf dn ls ng nh dp lw kk ni nj ma ko nk nl me ks nm nn mi no bi translated">自定义组 API</h2><p id="0bbf" class="pw-post-body-paragraph jz ka in kb b kc mk ke kf kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw ig bi translated">创建自定义 NSCollectionLayoutGroup 如下所示:</p><pre class="ky kz la lb gt lc ld le bn lf lg bi"><span id="4a5f" class="lh li in ld b be lj lk l ll lm">public typealias NSCollectionLayoutGroupCustomItemProvider = (NSCollectionLayoutEnvironment) -&gt; [NSCollectionLayoutGroupCustomItem] <br/>class func custom(<br/>  layoutSize: NSCollectionLayoutSize, <br/>  itemProvider: @escaping NSCollectionLayoutGroupCustomItemProvider<br/>) -&gt; Self</span></pre><p id="7782" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">对于每一个<strong class="kb io">NSCollectionLayoutGroupCustomItem</strong>，我们可以根据自己的需要在集合视图中设置唯一的框架。</p><p id="4c54" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">因此，我们可以按照自己的意愿对齐元素——任意列数，任意高度，任意顺序。</p><h2 id="66ce" class="nd li in bd lo ne nf dn ls ng nh dp lw kk ni nj ma ko nk nl me ks nm nn mi no bi translated">布局参数</h2><p id="7835" class="pw-post-body-paragraph jz ka in kb b kc mk ke kf kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw ig bi translated">假设您希望列数、每个项目的高度和项目间距都可以配置。我们布局的配置结构可以是这样的:</p><pre class="ky kz la lb gt lc ld le bn lf lg bi"><span id="0ca2" class="lh li in ld b be lj lk l ll lm">typealias ItemHeightProvider = (_ index: Int, _ itemWidth: CGFloat) -&gt; CGFloat<br/>typealias ItemCountProvider = () -&gt; Int<br/><br/>struct Configuration {<br/>    public let columnCount: Int<br/>    public let interItemSpacing: CGFloat<br/>    public let contentInsetsReference: UIContentInsetsReference<br/>    public let itemHeightProvider: ItemHeightProvider<br/>    public let itemCountProvider: ItemCountProvider<br/>    <br/>    /// Initialization for configuration of waterfall compositional layout section<br/>    /// - Parameters:<br/>    ///   - columnCount: a number of columns<br/>    ///   - interItemSpacing: a spacing between columns and rows<br/>    ///   - contentInsetsReference: a reference point for content insets for a section<br/>    ///   - itemCountProvider: closure providing a number of items in a section<br/>    ///   - itemHeightProvider: closure for providing an item height at a specific index<br/>    public init(<br/>        columnCount: Int = 2,<br/>        interItemSpacing: CGFloat = 8,<br/>        contentInsetsReference: UIContentInsetsReference = .automatic,<br/>        itemCountProvider: @escaping ItemCountProvider,<br/>        itemHeightProvider: @escaping ItemHeightProvider<br/>    ) {<br/>        self.columnCount = columnCount<br/>        self.interItemSpacing = interItemSpacing<br/>        self.contentInsetsReference = contentInsetsReference<br/>        self.itemCountProvider = itemCountProvider<br/>        self.itemHeightProvider = itemHeightProvider<br/>    }<br/>}</span></pre><h2 id="2c35" class="nd li in bd lo ne nf dn ls ng nh dp lw kk ni nj ma ko nk nl me ks nm nn mi no bi translated">总体步骤</h2><p id="a872" class="pw-post-body-paragraph jz ka in kb b kc mk ke kf kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw ig bi translated">这些参数足以构建可定制的瀑布布局。实施步骤如下:</p><ul class=""><li id="e335" class="mp mq in kb b kc kd kg kh kk mr ko ms ks mt kw mu mv mw mx bi translated">计算列宽</li><li id="4daf" class="mp mq in kb b kc my kg mz kk na ko nb ks nc kw mu mv mw mx bi translated">创建一个数组来存储列高度</li><li id="68c4" class="mp mq in kb b kc my kg mz kk na ko nb ks nc kw mu mv mw mx bi translated">计算项目框架</li><li id="c1bf" class="mp mq in kb b kc my kg mz kk na ko nb ks nc kw mu mv mw mx bi translated">为集合视图中的每个索引创建<strong class="kb io">NSCollectionLayoutGroupCustomItem</strong>实例</li><li id="21ef" class="mp mq in kb b kc my kg mz kk na ko nb ks nc kw mu mv mw mx bi translated">返回<strong class="kb io">NSCollectionLayoutGroupCustomItemProvider</strong>中的自定义项数组</li><li id="7066" class="mp mq in kb b kc my kg mz kk na ko nb ks nc kw mu mv mw mx bi translated">计算组高度</li></ul><figure class="ky kz la lb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi np"><img src="../Images/f11e8ccfa1396ecf49e0c3cefdbc0170.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R5Kiibx82JDOY1fPi6wGpQ.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">它应该是什么样子的一个方案</figcaption></figure><h2 id="66cb" class="nd li in bd lo ne nf dn ls ng nh dp lw kk ni nj ma ko nk nl me ks nm nn mi no bi translated">布局生成器</h2><p id="ec03" class="pw-post-body-paragraph jz ka in kb b kc mk ke kf kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw ig bi translated">让我们用为索引创建<strong class="kb io">NSCollectionLayoutGroupCustomItem</strong>项的方法来创建<strong class="kb io"> LayoutBuilder </strong>:</p><pre class="ky kz la lb gt lc ld le bn lf lg bi"><span id="8429" class="lh li in ld b be lj lk l ll lm">func makeLayoutItem(for row: Int) -&gt; NSCollectionLayoutGroupCustomItem</span></pre><p id="0457" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">为了让生成器工作，我们需要上面描述的配置以及集合宽度:</p><pre class="ky kz la lb gt lc ld le bn lf lg bi"><span id="bafe" class="lh li in ld b be lj lk l ll lm">final class LayoutBuilder {<br/>private var columnHeights: [CGFloat]<br/>private let columnCount: CGFloat<br/>private let itemHeightProvider: ItemHeightProvider<br/>private let interItemSpacing: CGFloat<br/>private let collectionWidth: CGFloat<br/><br/>init(<br/>    configuration: Configuration,<br/>    collectionWidth: CGFloat<br/>) {<br/>    self.columnHeights = [CGFloat](repeating: 0, count: configuration.columnCount)<br/>    self.columnCount = CGFloat(configuration.columnCount)<br/>    self.itemHeightProvider = configuration.itemHeightProvider<br/>    self.interItemSpacing = configuration.interItemSpacing<br/>    self.collectionWidth = collectionWidth<br/>}<br/><br/>func makeLayoutItem(for row: Int) -&gt; NSCollectionLayoutGroupCustomItem {<br/>    // TODO:<br/>}</span></pre><h2 id="3fd9" class="nd li in bd lo ne nf dn ls ng nh dp lw kk ni nj ma ko nk nl me ks nm nn mi no bi translated">计算列宽</h2><p id="f0e3" class="pw-post-body-paragraph jz ka in kb b kc mk ke kf kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw ig bi translated">我们需要从集合宽度中减去间距，然后除以列数:</p><pre class="ky kz la lb gt lc ld le bn lf lg bi"><span id="6268" class="lh li in ld b be lj lk l ll lm">private var columnWidth: CGFloat { let spacing = (columnCount - 1) * interItemSpacing return (collectionWidth - spacing) / columnCount }</span></pre><h2 id="65f2" class="nd li in bd lo ne nf dn ls ng nh dp lw kk ni nj ma ko nk nl me ks nm nn mi no bi translated">列高数组</h2><p id="2dce" class="pw-post-body-paragraph jz ka in kb b kc mk ke kf kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw ig bi translated">存储列高度，以便我们可以决定每个项目的正确放置位置，保存项目从左到右的顺序:</p><pre class="ky kz la lb gt lc ld le bn lf lg bi"><span id="3881" class="lh li in ld b be lj lk l ll lm">/// In init function:<br/>self.columnHeights = [CGFloat](repeating: 0, count: configuration.columnCount)</span></pre><h2 id="e7d2" class="nd li in bd lo ne nf dn ls ng nh dp lw kk ni nj ma ko nk nl me ks nm nn mi no bi translated">计算项目的框架</h2><p id="c0ca" class="pw-post-body-paragraph jz ka in kb b kc mk ke kf kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw ig bi translated">首先，我们需要一个正确的原点来放置物品。当我们保存每一列的总高度时，我们可以找到最低的列和它的最大 Y 值(所以它会到它的底部), X 是它的列的偏移量。让我们开始吧:</p><pre class="ky kz la lb gt lc ld le bn lf lg bi"><span id="fa24" class="lh li in ld b be lj lk l ll lm">private func itemOrigin(width: CGFloat) -&gt; CGPoint {<br/>    let y = columnHeights[columnIndex()].rounded()<br/>    let x = (width + interItemSpacing) * CGFloat(columnIndex())<br/>    return CGPoint(x: x, y: y)<br/>}<br/><br/>private func columnIndex() -&gt; Int {<br/>    columnHeights<br/>        .enumerated()<br/>        .min(by: { $0.element &lt; $1.element })?<br/>        .offset ?? 0<br/>}</span></pre><p id="4d47" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">有了项的原点、列宽和闭包来检索特定索引项的高度和宽度，我们可以确定一个框架:</p><pre class="ky kz la lb gt lc ld le bn lf lg bi"><span id="60c0" class="lh li in ld b be lj lk l ll lm">func frame(for row: Int) -&gt; CGRect {<br/>    let width = columnWidth<br/>    let height = itemHeightProvider(row, width)<br/>    let size = CGSize(width: width, height: height)<br/>    let origin = itemOrigin(width: size.width)<br/>    return CGRect(origin: origin, size: size)<br/>}</span></pre><h2 id="9c72" class="nd li in bd lo ne nf dn ls ng nh dp lw kk ni nj ma ko nk nl me ks nm nn mi no bi translated">创建 NSCollectionLayoutGroupCustomItem 数组</h2><p id="b3c6" class="pw-post-body-paragraph jz ka in kb b kc mk ke kf kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw ig bi translated">因为我们有了一个项目的框架，所以我们现在可以实现我们的方法来创建<strong class="kb io">NSCollectionLayoutGroupCustomItem</strong>实例。也不应该忘记在放置项目的地方增加相应的 columnHeight:</p><pre class="ky kz la lb gt lc ld le bn lf lg bi"><span id="722b" class="lh li in ld b be lj lk l ll lm">func makeLayoutItem(for row: Int) -&gt; NSCollectionLayoutGroupCustomItem {<br/>    let frame = frame(for: row)<br/>    columnHeights[columnIndex()] = frame.maxY + interItemSpacing<br/>    return NSCollectionLayoutGroupCustomItem(frame: frame)<br/>}</span></pre><p id="74e2" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">使用上面的方法，我们可以为我们的部分中的所有项目创建数组:</p><pre class="ky kz la lb gt lc ld le bn lf lg bi"><span id="10b2" class="lh li in ld b be lj lk l ll lm">var items = [NSCollectionLayoutGroupCustomItem]()<br/>let itemProvider = LayoutBuilder(<br/>    configuration: config,<br/>    collectionWidth: enviroment.container.contentSize.width<br/>)<br/><br/>for i in 0..&lt;config.itemCountProvider() {<br/>    let item = itemProvider.makeLayoutItem(for: i)<br/>    items.append(item)<br/>}</span></pre><p id="40ce" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们应该告诉小组创造方法我们有什么高度。使用<strong class="kb io">NSCollectionLayoutDimension</strong>API，我们可以估算<strong class="kb io">。estimated() </strong>值，它会按照我们指定的所有项目框架来计算，对吗？可惜不是。</p><p id="b291" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">当我尝试上面提到的瀑布库<a class="ae kx" href="https://github.com/lucamegh/Niagara" rel="noopener ugc nofollow" target="_blank">时，收集单元格具有垂直约束并自行确定其高度，我发现布局引擎进入递归，因为内在垂直约束与我们设置的框架冲突:</a></p><figure class="ky kz la lb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nq"><img src="../Images/72c523732ad8851ef67873ee3cfde08e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U_5omDoEE6Ya3rqgXlbJVA.png"/></div></div></figure><p id="484c" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">然而，我们有另一个选项来设置组的高度——绝对值。因此，由于我们已经完成了所有帧的计算，我们可以将组的高度设置为最高的<strong class="kb io"> columnHeight </strong>属性:</p><pre class="ky kz la lb gt lc ld le bn lf lg bi"><span id="771b" class="lh li in ld b be lj lk l ll lm">let groupLayoutSize = NSCollectionLayoutSize(<br/>    widthDimension: .fractionalWidth(1),<br/>    heightDimension: .absolute(itemProvider.maxColumnHeight())<br/>)</span></pre><h2 id="150e" class="nd li in bd lo ne nf dn ls ng nh dp lw kk ni nj ma ko nk nl me ks nm nn mi no bi translated">创建 NSCollectionLayoutSection</h2><p id="d01e" class="pw-post-body-paragraph jz ka in kb b kc mk ke kf kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw ig bi translated">最后，我们可以创建完整描述的 NSCollectionLayoutSection，用于显示类似 pinterest(瀑布，等等)的布局:</p><pre class="ky kz la lb gt lc ld le bn lf lg bi"><span id="4c22" class="lh li in ld b be lj lk l ll lm">let group = NSCollectionLayoutGroup.custom(layoutSize: groupLayoutSize) { _ in<br/>    return items<br/>}<br/><br/>let section = NSCollectionLayoutSection(group: group)<br/>section.contentInsetsReference = config.contentInsetsReference</span></pre><figure class="ky kz la lb gt jo gh gi paragraph-image"><div class="gh gi jk"><img src="../Images/58aafdf5d09f887a2168d5a73a84dcaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/1*i30D3lZ-CV7ZHeZ8xQuuug.gif"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">使用我们的布局的收藏视图</figcaption></figure></div><div class="ab cl nr ns hr nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="ig ih ii ij ik"><p id="0c7b" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">尽管组合布局 API 对于这样的事情来说似乎有些笨拙，但是我们仍然有一些空间来做我们想做的事情，保持这种布局的所有优点。</p><p id="24be" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">对于所描述的布局，我创建了<a class="ae kx" href="https://github.com/eeshishko/WaterfallTrueCompositionalLayout" rel="noopener ugc nofollow" target="_blank">存储库</a>和 NPM 包，这样每个人都可以检查该方法的完整实现，或者只是添加一个项目并使用它。也可以随意提出任何问题和相应的请求！🤩</p></div></div>    
</body>
</html>