<html>
<head>
<title>Using the libadwaita Leaflet widget for a responsive GTK4 UI in Rust</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在 Rust 中使用 libadwaita 传单小部件来响应 GTK4 用户界面</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/using-the-libadwaita-leaflet-widget-for-a-responsive-gtk4-ui-in-rust-73bbc2f4025?source=collection_archive---------1-----------------------#2022-03-23">https://blog.devgenius.io/using-the-libadwaita-leaflet-widget-for-a-responsive-gtk4-ui-in-rust-73bbc2f4025?source=collection_archive---------1-----------------------#2022-03-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/03d7ace823cdf33b3d4eeb1c02d72ae2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QeXTVrTknwQPXJdr"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">卢克·波特在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="4d41" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们正在使用 libadwaita 和 Rust 创建一个 GTK4 RSS 阅读器，使用 VSCode 编写所有内容。上次我们学习了如何使用<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/using-template-files-in-rust-for-a-gtk4-libadwaita-ui-8322694cbc3c">模板</a>，然后我们使用<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/bundling-templates-into-resources-in-rust-for-the-gtk4-ui-eb387a7918bf">资源</a>将所有东西捆绑在最终的可执行文件中。这一切都很好，只是缺少了一点:我们实际上从来没有为我们的 RSS 阅读器编写 UI。我们所做的一切都是在一个空的窗口上。这篇文章将改变这种情况，因为今天我们将最终构建我们的应用程序的 UI。</p><p id="42ff" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这也可能是引入一个小免责声明的最佳时机:这只是一个教程。是的，我们将阅读实际的 RSS 文件。是的，我们将把我们的按钮和小部件链接到实际代码。但是，这个应用程序不会是一个日常可用的 RSS 阅读器的完美的最终版本。我们将使用预定义的 RSS 源，我们不会标记阅读的文章。这只是一个教程，帮助你站稳脚跟，用 Rust 编写现代的 GTK4 应用程序。一如既往，代码可在<a class="ae kc" href="https://github.com/raduzaharia-medium/gtk-rss-reader-mock-ui" rel="noopener ugc nofollow" target="_blank"> github </a>上获得。</p><h2 id="733c" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">应用程序窗口</h2><figure class="lv lw lx ly gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lu"><img src="../Images/169bc516ac08167a588c4aaf6d90d52e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ajEHYqtYJ38l6-9Byy-h5A.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">应用程序窗口的初始外观</figcaption></figure><p id="158a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的截图是我们想要实现的，它只是一个框架。我们还不会加载实际的文章，我们只是想有一个可用的模拟来帮助我们理解我们想从应用程序中得到什么。</p><p id="c759" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为此，我们将使用一些 libadwaita 和 GTK4 小部件。首先，UI 的主要布局将是一个 libadwaita 传单小部件。上次我们的<code class="fe lz ma mb mc b">main-window.ui</code>是这样的:</p><pre class="lv lw lx ly gt md mc me mf aw mg bi"><span id="9275" class="lb lc iq mc b gy mh mi l mj mk">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br/>&lt;interface&gt;<br/>  &lt;template class="MainWindow" parent="AdwApplicationWindow"<br/>    &lt;property name="width-request"&gt;500&lt;/property&gt;<br/>    &lt;property name="title" translatable="yes"&gt;<br/>      My GTK4 RSS Reader<br/>    &lt;/property&gt;</span><span id="d247" class="lb lc iq mc b gy ml mi l mj mk">    &lt;child&gt;<br/>      &lt;object class="GtkBox"&gt;<br/>        &lt;property name="orientation"&gt;vertical&lt;/property&gt;<br/>        &lt;property name="hexpand"&gt;True&lt;/property&gt;<br/>        &lt;child&gt;<br/>          &lt;object class="AdwHeaderBar"&gt;&lt;/object&gt;<br/>        &lt;/child&gt;<br/>        &lt;child&gt;<br/>          &lt;object class="GtkButton" id="button"&gt;<br/>            &lt;property name="label"&gt;Press me!&lt;/property&gt;<br/>            &lt;property name="margin-top"&gt;12&lt;/property&gt;<br/>            &lt;property name="margin-bottom"&gt;12&lt;/property&gt;<br/>            &lt;property name="margin-start"&gt;12&lt;/property&gt;<br/>            &lt;property name="margin-end"&gt;12&lt;/property&gt;<br/>          &lt;/object&gt;<br/>        &lt;/child&gt;<br/>      &lt;/object&gt;<br/>    &lt;/child&gt;<br/>  &lt;/template&gt;<br/>&lt;/interface&gt;</span></pre><p id="2662" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一扇空窗。让我们移除子组件并添加传单小部件:</p><pre class="lv lw lx ly gt md mc me mf aw mg bi"><span id="da58" class="lb lc iq mc b gy mh mi l mj mk">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br/>&lt;interface&gt;<br/>  &lt;template class="MainWindow" parent="AdwApplicationWindow"<br/>    &lt;property name="width-request"&gt;800&lt;/property&gt;<br/>    &lt;property name="height-request"&gt;500&lt;/property&gt;<br/>    &lt;property name="title" translatable="yes"&gt;<br/>      My GTK4 RSS Reader<br/>    &lt;/property&gt;</span><span id="18cf" class="lb lc iq mc b gy ml mi l mj mk">    &lt;child&gt;<br/>      &lt;object class="AdwLeaflet" id="leaflet"&gt;<br/>        &lt;property name="can-swipe-back"&gt;True&lt;/property&gt;<br/>        &lt;property name="hexpand"&gt;True&lt;/property&gt;</span><span id="7e52" class="lb lc iq mc b gy ml mi l mj mk">        &lt;child&gt;&lt;/child&gt;<br/>        &lt;child&gt;&lt;/child&gt;<br/>        &lt;child&gt;&lt;/child&gt;<br/>      &lt;/object&gt;<br/>    &lt;/child&gt;<br/>  &lt;/template&gt;<br/>&lt;/interface&gt;</span></pre><p id="0bbd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意，我还更改了<code class="fe lz ma mb mc b">width-request</code>并添加了一个<code class="fe lz ma mb mc b">height-request</code>来给我们的应用程序一个更好的初始大小。我们添加了带有一个<code class="fe lz ma mb mc b">id</code>、三个空的子部件和两个属性的<code class="fe lz ma mb mc b">AdwLeaflet</code>小部件。</p><p id="4c7d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">传单部件有三个部分:左窗格、分隔符和右窗格。它也是有求必应。如果窗口变得太窄，它将隐藏右窗格，直到用户选择左窗格中的内容。当发生这种情况时，如果<code class="fe lz ma mb mc b">can-swipe-back</code>属性是<code class="fe lz ma mb mc b">True</code>，它会自动在标题中显示一个后退按钮，这样用户就可以返回到左侧窗格。像这样:</p><figure class="lv lw lx ly gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mm"><img src="../Images/c3d10c780c8a1a5c65f70f3bb73a4321.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*43okRHpenLi2qLr4-Rj2mA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">显示两个窗格和一个分隔符的宽传单</figcaption></figure><figure class="lv lw lx ly gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mn"><img src="../Images/f2ed83a6422391885d57922d679a3c8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BXG65PT0254kvWe0sCVoOA.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">一次显示一个窗格的窄页</figcaption></figure><p id="c08a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在 libadwaita 的最新版本中，<code class="fe lz ma mb mc b">can-swipe-back</code>被重新命名为<code class="fe lz ma mb mc b">can-navigate-back</code>。不幸的是，在我的设置中，虽然这个属性的 Rust 绑定名为<code class="fe lz ma mb mc b">can-navigate-back</code>，但是<code class="fe lz ma mb mc b">main-window.ui</code>文件并不识别它，所以现在我们只能在模板中使用<code class="fe lz ma mb mc b">can-swipe-back</code>。但是在未来的 libadwaita 版本中，必须使用<code class="fe lz ma mb mc b">can-navigate-back</code>。</p><p id="8e47" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的传单小部件也有一个设置为<code class="fe lz ma mb mc b">True</code>的<code class="fe lz ma mb mc b">hexpand</code>属性。这使它扩大到填满整个窗口宽度。好了，让我们将这三个孩子添加到我们的传单部件中。</p><h2 id="2de0" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">第一个孩子:左窗格</h2><figure class="lv lw lx ly gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lu"><img src="../Images/cd5b24d4fca14b16503120fc70ca01cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wd9NwBzEoXNJtPcgrURiVw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">我们的 RSS 阅读器应用程序的左窗格</figcaption></figure><p id="c91b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">左窗格应该包含一个带有一些 RSS 源的垂直列表。它还应该有一个很好的周围填充，所以它不会看起来拥挤。它应该有一个标题说“饲料”。列出的 RSS 源应该是可点击的。简而言之，我们的窗格将有两个子元素:标题和列表框。让我们看看:</p><pre class="lv lw lx ly gt md mc me mf aw mg bi"><span id="428f" class="lb lc iq mc b gy mh mi l mj mk">&lt;child&gt;<br/>  &lt;object class="GtkBox"&gt;<br/>    &lt;property name="orientation"&gt;vertical&lt;/property&gt;<br/>  <br/>    &lt;child&gt;<br/>      &lt;object class="AdwHeaderBar"&gt;<br/>        &lt;binding name="show-end-title-buttons"&gt;<br/>          &lt;lookup name="folded"&gt;leaflet&lt;/lookup&gt;<br/>        &lt;/binding&gt;</span><span id="cdb3" class="lb lc iq mc b gy ml mi l mj mk">        &lt;property name="title-widget"&gt;<br/>          &lt;object class="AdwWindowTitle"&gt;<br/>            &lt;property name="title"&gt;Feeds&lt;/property<br/>          &lt;/object&gt;<br/>        &lt;/property&gt;<br/>      &lt;/object&gt;<br/>    &lt;/child&gt;</span><span id="69ea" class="lb lc iq mc b gy ml mi l mj mk">    &lt;child&gt;<br/>      &lt;object class="GtkListBox"&gt;<br/>      &lt;/object&gt;<br/>    &lt;/child&gt;<br/>  &lt;/object&gt;<br/>&lt;/child&gt;</span></pre><p id="3a70" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">左窗格子包含一个<code class="fe lz ma mb mc b">GtkBox</code>。这是一个布局小部件，它只是为内容设置一个流。流向由我们在这里设置为<code class="fe lz ma mb mc b">vertical</code>的<code class="fe lz ma mb mc b">orientation</code>属性给出。所以这个<code class="fe lz ma mb mc b">GtkBox</code>的所有子代都会从上到下流动。</p><p id="9fe0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第一个也是最顶端的子元素将是标题栏:<code class="fe lz ma mb mc b">AdwHeaderBar</code>。如果窗口足够小，标题栏必须显示正常 Gnome 窗口<em class="mo">的关闭、最小化和最大化按钮。记住传单部件的响应行为。如果窗口太小，它将一次只显示一个窗格。因此，如果我们的 id 为<code class="fe lz ma mb mc b">leaflet</code>的传单是<code class="fe lz ma mb mc b">folded</code>，如我们在<code class="fe lz ma mb mc b">binding</code>中看到的，我们设置它显示带有<code class="fe lz ma mb mc b">show-end-title-buttons</code>的窗口按钮。接下来，我们通过将一个<code class="fe lz ma mb mc b">AdwWindowTitle</code>小部件设置到它的<code class="fe lz ma mb mc b">title-widget</code>属性来给它一个标题。</em></p><p id="adaa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下一个子控件将是一个<code class="fe lz ma mb mc b">GtkListBox</code>小部件:</p><pre class="lv lw lx ly gt md mc me mf aw mg bi"><span id="e58b" class="lb lc iq mc b gy mh mi l mj mk">&lt;object class="GtkListBox"&gt;<br/>  &lt;property name="selection-mode"&gt;single&lt;/property&gt;<br/>  &lt;property name="hexpand"&gt;True&lt;/property&gt;&gt;<br/><br/>  &lt;property name="margin-top"&gt;24&lt;/property&gt;<br/>  &lt;property name="margin-bottom"&gt;24&lt;/property&gt;<br/>  &lt;property name="margin-start"&gt;12&lt;/property&gt;<br/>  &lt;property name="margin-end"&gt;12&lt;/property&gt;</span><span id="224b" class="lb lc iq mc b gy ml mi l mj mk">  &lt;style&gt;<br/>    &lt;class name="boxed-list"/&gt;<br/>  &lt;/style&gt;</span><span id="512f" class="lb lc iq mc b gy ml mi l mj mk">  &lt;child&gt;<br/>    &lt;object class="AdwActionRow"&gt;<br/>      &lt;property name="title"&gt;The Verge&lt;/property&gt;<br/>    &lt;/object&gt;<br/>  &lt;/child&gt;<br/>  &lt;child&gt;<br/>    &lt;object class="AdwActionRow"&gt;<br/>      &lt;property name="title"&gt;Ars Technica&lt;/property&gt;<br/>    &lt;/object&gt;<br/>  &lt;/child&gt;<br/>&lt;/object&gt;</span></pre><p id="5974" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们通过添加<code class="fe lz ma mb mc b">margin</code>属性来填充它。我们还设置了<code class="fe lz ma mb mc b">hexpand</code>属性，将其拉伸到可用的最大宽度。我们还将其配置为允许使用<code class="fe lz ma mb mc b">selection-mode</code>属性选择<code class="fe lz ma mb mc b">single</code>项。接下来我们给它一个 libadwaita <code class="fe lz ma mb mc b">boxed-list</code>风格。这将使它看起来像一个适当的 libadwaita 列表。然后我们添加孩子:列表中的每个条目都是一个包含<code class="fe lz ma mb mc b">AdwActionRow</code>的<code class="fe lz ma mb mc b">child</code>对象。如果我们有更多的孩子，我们简单地添加更多的<code class="fe lz ma mb mc b">child</code>项目。左窗格到此为止。</p><h2 id="ae08" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">第二个孩子:分离器</h2><figure class="lv lw lx ly gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lu"><img src="../Images/ee303935a0cb6cb575d8fe97fa911a8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*15SEqlP4QQnL_5TfI1Uguw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">我们的 RSS 阅读器应用程序的分隔符</figcaption></figure><p id="444b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们希望在窗格之间添加一个漂亮的分隔符，因此对于中间的传单子代，我们只需添加:</p><pre class="lv lw lx ly gt md mc me mf aw mg bi"><span id="2eb3" class="lb lc iq mc b gy mh mi l mj mk">&lt;child&gt;<br/>  &lt;object class="AdwLeafletPage"&gt;<br/>    &lt;property name="navigatable"&gt;False&lt;/property&gt;<br/>    &lt;property name="child"&gt;<br/>      &lt;object class="GtkSeparator" /&gt;<br/>    &lt;/property&gt;<br/>  &lt;/object&gt;<br/>&lt;/child&gt;</span></pre><p id="9ee4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们简单的把一个<code class="fe lz ma mb mc b">AdwLeafletPage</code>加一个<code class="fe lz ma mb mc b">GtkSeparator</code>作为孩子。传单页面是一个特殊的传单内容小部件，通过将<code class="fe lz ma mb mc b">navigatable</code>属性设置为<code class="fe lz ma mb mc b">False</code>，当窗口太窄时，它会自动隐藏。</p><h2 id="4716" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">第三个孩子:文章列表</h2><figure class="lv lw lx ly gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lu"><img src="../Images/099df487709f5ba6d8826e5b523189d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dzcKvFh4YiNTpFSW5M1jig.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">应用程序的最终用户界面部分</figcaption></figure><p id="dfe2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于第三个孩子，我们有与第一个孩子相同的情况:一个垂直方向的 GtkBox，它显示一个<code class="fe lz ma mb mc b">AdwHeaderBar</code>小部件和一个<code class="fe lz ma mb mc b">GtkListBox</code>与我们之前做的一样。这次标题栏有点不同:</p><pre class="lv lw lx ly gt md mc me mf aw mg bi"><span id="180e" class="lb lc iq mc b gy mh mi l mj mk">&lt;object class="AdwHeaderBar"&gt;<br/>  &lt;binding name="show-start-title-buttons"&gt;<br/>    &lt;lookup name="folded"&gt;leaflet&lt;/lookup&gt;<br/>  &lt;/binding&gt;</span><span id="965b" class="lb lc iq mc b gy ml mi l mj mk">  &lt;child&gt;<br/>    &lt;object class="GtkButton"&gt;<br/>      &lt;binding name="visible"&gt;<br/>        &lt;lookup name="folded"&gt;leaflet&lt;/lookup&gt;<br/>      &lt;/binding&gt;</span><span id="86ae" class="lb lc iq mc b gy ml mi l mj mk">      &lt;property name="icon-name"&gt;go-previous-symbolic&lt;/property&gt;<br/>    &lt;/object&gt;<br/>  &lt;/child&gt;</span><span id="db51" class="lb lc iq mc b gy ml mi l mj mk">  &lt;property name="title-widget"&gt;<br/>    &lt;object class="AdwWindowTitle"&gt;<br/>      &lt;property name="title"&gt;Content&lt;/property&gt;<br/>    &lt;/object&gt;<br/>  &lt;/property&gt;<br/>&lt;/object&gt;</span></pre><p id="f2d7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这一次，标题包含一个带有<code class="fe lz ma mb mc b">go-previous-symbolic</code>图标的额外后退按钮。只有当我们的<code class="fe lz ma mb mc b">leaflet</code>是<code class="fe lz ma mb mc b">folded</code>时，这个按钮才会是<code class="fe lz ma mb mc b">visible</code>。</p></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><p id="9311" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">RSS 阅读器应用程序的框架构建到此结束。同样，你可以在这里找到代码<a class="ae kc" href="https://github.com/raduzaharia-medium/gtk-rss-reader-mock-ui" rel="noopener ugc nofollow" target="_blank"/>。我希望这篇文章能对一些标准的 libadwaita 小部件有所启发，也希望你在实现这个项目的时候会有乐趣。</p><p id="7d44" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你看看我们的模板文件，你会发现它开始变得冗长、复杂和难以阅读。<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/refactoring-gtk4-ui-templates-in-rust-68cbef1a1778">下一次</a>我们将看到一些重构选项，我们必须提高可读性，并重用模板的某些部分。如有任何问题，请在评论区提问，希望能在下一篇文章中见到你！</p></div></div>    
</body>
</html>