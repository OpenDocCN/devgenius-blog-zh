<html>
<head>
<title>Assembly by example: Compute string hash. Part 2: loops</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">按示例汇编:计算字符串哈希。第 2 部分:循环</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/assembly-by-example-compute-string-hash-part-2-loops-ba39de0ff6d6?source=collection_archive---------6-----------------------#2022-05-19">https://blog.devgenius.io/assembly-by-example-compute-string-hash-part-2-loops-ba39de0ff6d6?source=collection_archive---------6-----------------------#2022-05-19</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="030c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你还没有读过第一部分，我强烈建议你去读一读，因为在第二部分中，假设你已经知道那里解释了什么。</p><p id="767b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">请记住，我们的目标是计算由以下等式给出的字符串散列。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi kj"><img src="../Images/6c7b7a260fd6d6c12ebed9b5089ef1ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:754/format:webp/0*ORGZ7Ohuhh2rtvq-.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">字符串哈希的定义</figcaption></figure><p id="c43e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您可能还记得第 1 部分中的内容，我们需要编写两个助手函数:strlen 和 pow31。第一个非常简单，而第二个更复杂，但正如我们稍后将看到的，实际上根本不需要它。这两个函数都需要循环，所以我们将从理解汇编中的循环开始。</p><p id="a7c0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们还没有看到如何读取 cli 参数或将数字输出到 stdout，因此我将通过做两件事来尽可能保持示例的简单性:</p><ol class=""><li id="1e7e" class="kv kw in jm b jn jo jr js jv kx jz ky kd kz kh la lb lc ld bi translated">因为对于大多数例子来说，结果是一个无符号整数，所以输出结果作为程序的退出状态代码似乎很方便。当然，这不是一个好的做法，而且存在的问题是，退出状态代码由一个字节表示，所以我们不能输出大于 255 的数字。</li><li id="4a8b" class="kv kw in jm b jn le jr lf jv lg jz lh kd li kh la lb lc ld bi translated">我们将使用硬编码的测试用例。同样，这不是一个好的实践，但是为了简单起见，让我们保持这种方式。</li></ol><p id="6942" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">请记住，您可以通过使用<code class="fe lj lk ll lm b">echo $?</code>打印可执行文件的状态代码来检查结果</p><h1 id="fe82" class="ln lo in bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">装配循环</h1><p id="4b54" class="pw-post-body-paragraph jk jl in jm b jn ml jp jq jr mm jt ju jv mn jx jy jz mo kb kc kd mp kf kg kh ig bi translated">与结构化语言相反，汇编语言没有控制结构，比如 for、while、do-while 循环。我们有的是跳跃。</p><p id="6289" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在看一些例子之前，重要的是要知道<code class="fe lj lk ll lm b">for</code>和<code class="fe lj lk ll lm b">for-each</code>循环只是 while 循环的<a class="ae ki" href="https://en.wikipedia.org/wiki/Syntactic_sugar" rel="noopener ugc nofollow" target="_blank">语法糖</a>，所有你可以用<code class="fe lj lk ll lm b">for</code>循环做的事情都可以用<code class="fe lj lk ll lm b">while</code>循环来完成。这对于理解汇编中的循环是必不可少的，所以在继续之前你真的需要理解我的意思。</p><h2 id="33b4" class="mq lo in bd lp mr ms dn lt mt mu dp lx jv mv mw mb jz mx my mf kd mz na mj nb bi translated">n 以内的自然数之和</h2><p id="11b8" class="pw-post-body-paragraph jk jl in jm b jn ml jp jq jr mm jt ju jv mn jx jy jz mo kb kc kd mp kf kg kh ig bi translated">为了计算 n 以内的自然数之和，我们可以使用高斯公式</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/903afd366301eac578dcdf07bccbb6d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:586/format:webp/0*v2UzrOzMPtSJGIs8.png"/></div></figure><p id="a3b6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是，因为我们想了解循环在汇编中是如何工作的，所以我们不打算使用它。相反，我们将使用一个“while”循环。</p><p id="e7a8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们通过检查下面的例子来学习。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="1614" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我认为理解这个程序是如何工作的有点简单。不过，让我解释一些我们在第 1 部分中没有看到的东西。</p><p id="0e40" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe lj lk ll lm b">loop:</code>是循环中第一条指令的标签。</p><p id="48ba" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe lj lk ll lm b">cmp eax, ebx</code>通过减法比较两个寄存器，然后修改标志寄存器。我们感兴趣的标志注册表是 ZF(零标志)注册表，如果两个寄存器相等(a-b = 0 当且仅当 a = b)，则该注册表被设置为 1。</p><p id="1319" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe lj lk ll lm b">je end</code> (je: jump if equal)是一个<em class="nf">条件跳转</em>，如果 ZF = 1(由前面的操作设置，在这种情况下是比较)，则跳转到<code class="fe lj lk ll lm b">end</code>标签。<code class="fe lj lk ll lm b">jz end</code>(零跳)也可以。</p><p id="ca06" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe lj lk ll lm b">jmp loop</code>是一个<em class="nf">无条件跳转</em>，跳转到<code class="fe lj lk ll lm b">loop</code>标签。</p><p id="72b6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">回想一下<em class="nf">跳转</em>意味着将一个地址加载到 IP(指令指针)中，这样它就会在下一个被执行。</p><h1 id="5854" class="ln lo in bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">字符长度（stringlength）</h1><p id="dca2" class="pw-post-body-paragraph jk jl in jm b jn ml jp jq jr mm jt ju jv mn jx jy jz mo kb kc kd mp kf kg kh ig bi translated">假设一个字符串是空终止的(以 0x0 结束)，我们可以用下面的代码得到它的长度</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="3992" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">代码非常简单。可能需要解释的唯一一行是这一行<code class="fe lj lk ll lm b">cmp BYTE [string + eax], 0x0</code>。</p><p id="ae81" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">首先，<code class="fe lj lk ll lm b">string</code>是指向字符串第一个字符的指针。这和你在 c 中声明一个<code class="fe lj lk ll lm b">char*</code>很像，让我们在 gdb 中看看。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi ng"><img src="../Images/94b4b857c78d3f117d417f309a3d4f1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RmlhYxtV_koxAgnw-8kYmg.png"/></div></div></figure><p id="837b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果我们讨论的是 ASCII 编码(每个字符 1 个字节)，那么<code class="fe lj lk ll lm b">[string + i]</code>处的字节(其中<code class="fe lj lk ll lm b">i</code>是一个整数)就是字符串中的第 I 个字符。当然，如果我们采用其他编码方式，每个字符超过 1 个字节，代码就会失败。例如:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi nl"><img src="../Images/2d5c7e6e5890ec9baa591cfd4c00cb94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CgyYNEoSSH-fMAlB-C6orA.png"/></div></div></figure><p id="f7e0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">实际的字符串长度是 21，但是我们的程序说字符串长度是 23，因为🥰是以 4 个字节存储的。修复这个“bug”需要比实际计算字符串长度多得多的代码行，所以我们不会深入讨论。</p><p id="64dd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，应该很清楚<code class="fe lj lk ll lm b">cmp BYTE [string + eax], 0x0</code>检查字符串中的第 I 个字节(字符)是否是空字符。指定操作大小很重要，否则我们会得到一个错误<code class="fe lj lk ll lm b">operation size not specified</code>,因为想想看，编译器怎么知道你想要比较一个字节？</p><p id="862a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果我们不指定操作的大小，操作是相当不明确的，因为比较多于 1 个字节是完全合理的。例如，如果我们想比较 UTF-8 字符。</p><p id="6815" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">假设我们在寻找这个角色🤘也存储在 4 个字节中，然后用<code class="fe lj lk ll lm b">cmp DWORD [string], "</code> ✌️ <code class="fe lj lk ll lm b">"</code>或<code class="fe lj lk ll lm b">cmp DWORD [string], 0x98a49ff0</code>进行比较。你可能认为十六进制值<code class="fe lj lk ll lm b">0x98a49ff0</code>，给了编译器一个关于操作大小的提示，但这并不完全正确。然而，如果我们将立即值<code class="fe lj lk ll lm b">0x98a49ff0</code>移动到一个注册表中，比如说<code class="fe lj lk ll lm b">eax</code>，我们不再需要指定大小操作，因为编译器已经知道<code class="fe lj lk ll lm b">eax</code>是一个 32 位注册表，因此这意味着操作大小是<code class="fe lj lk ll lm b">DWORD</code>。</p><p id="759e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果您仍然有疑问，下面的 C 代码是汇编代码的翻译，可能会有所帮助。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nd ne l"/></div></figure><h1 id="dca7" class="ln lo in bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">pow31</h1><p id="947b" class="pw-post-body-paragraph jk jl in jm b jn ml jp jq jr mm jt ju jv mn jx jy jz mo kb kc kd mp kf kg kh ig bi translated">Java 工程师在选择散列函数时非常聪明，因为它有以下优化:</p><ul class=""><li id="c281" class="kv kw in jm b jn jo jr js jv kx jz ky kd kz kh nm lb lc ld bi translated">助手功能<code class="fe lj lk ll lm b">pow31</code>其实不需要。对长度为 4 的字符串进行以下扩展:</li></ul><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi nn"><img src="../Images/7d5b4501c747ce9bbb455413e04c8f50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Mypu0VP7QU18mB2B.png"/></div></div></figure><p id="573c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一般情况可以定义如下</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi no"><img src="../Images/b6ca93a14b7fc685f01d60ad397d17d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1122/format:webp/0*LShobkQTRBmy-nOC.png"/></div></figure><p id="77a3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">其中 h sub j 是从索引 0 处的 char 到索引 j 处的 char(包括 0 和 j)的字符串的哈希。</p><p id="7c55" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">更清楚地说，我们可以用下面的伪代码计算字符串的散列。</p><pre class="kk kl km kn gt np lm nq nr aw ns bi"><span id="11df" class="mq lo in lm b gy nt nu l nv nw">h := 0<br/>for i = 0; i &lt; |s|; i++ {<br/>  h = 31 * h + s[i]<br/>}</span></pre><ul class=""><li id="3335" class="kv kw in jm b jn jo jr js jv kx jz ky kd kz kh nm lb lc ld bi translated">31 真的是个不错的选择。这就是为什么。</li></ul><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi nx"><img src="../Images/1e5fc53b2044b40c97fd9980c71cac5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*V5aizzr8rmzDZV1C.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">将整数<em class="ny"> a 乘以 31 </em>的优化</figcaption></figure><p id="c450" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们将在第 3 部分中使用这些优化，所以请去看看吧。</p><p id="5c7f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">尽管我们已经看到<code class="fe lj lk ll lm b">pow31</code>函数实际上是不需要的，但我现在将忽略这些数学技巧并编写代码。毕竟这一系列帖子的目的是通过实例来学习汇编。</p><h2 id="7a7a" class="mq lo in bd lp mr ms dn lt mt mu dp lx jv mv mw mb jz mx my mf kd mz na mj nb bi translated">天真的实现</h2><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="b4bc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如你所见，代码非常简单。我觉得不需要解释。翻译成 C 代码将非常类似于以下内容</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="7afd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果您运行该程序，它可能会说退出状态代码是 193，因为请记住，退出状态代码仅限于一个字节，961 = 0b1111000001 的最后一个字节是 0b11000001 = 193。</p><h2 id="7ece" class="mq lo in bd lp mr ms dn lt mt mu dp lx jv mv mw mb jz mx my mf kd mz na mj nb bi translated">高效实现 O(log(n))</h2><p id="8779" class="pw-post-body-paragraph jk jl in jm b jn ml jp jq jr mm jt ju jv mn jx jy jz mo kb kc kd mp kf kg kh ig bi translated">现在让我们为非负整数指数实现<a class="ae ki" href="https://cp-algorithms.com/algebra/binary-exp.html" rel="noopener ugc nofollow" target="_blank">二进制取幂算法</a>。它基本上陈述了以下内容</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/9cd4387d8a5ac4aa98ca825bfdbdd94d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1156/format:webp/0*WQLgsOJa363gwzsv.png"/></div></figure><p id="cf63" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你首先想到的可能是递归。但是，正如您可能已经知道的那样，这不如迭代解决方案有效。我推荐你阅读<a class="ae ki" href="https://cp-algorithms.com/algebra/binary-exp.html" rel="noopener ugc nofollow" target="_blank">这一</a>页面中披露的迭代解决方案。这里我来解释一下，翻译成汇编语言。</p><p id="eba8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">解释</strong></p><p id="12d7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我将通过一个例子来解释这个算法。假设我们要计算 31。11 = 0b1011 的二进制表示告诉了我们一切。</p><p id="65ba" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">迭代 1 </strong>。假设<code class="fe lj lk ll lm b">result = 1</code>、<code class="fe lj lk ll lm b">b = 11 = 0b1011</code>、<code class="fe lj lk ll lm b">a = 31</code></p><ol class=""><li id="bf3f" class="kv kw in jm b jn jo jr js jv kx jz ky kd kz kh la lb lc ld bi translated">31 = 31⁸ 31 31 = <code class="fe lj lk ll lm b">a^8 * a^2 * a</code>(这些因子来自 b 的二进制表示，11 = 8 + 2 + 1)。我们还没有计算 31⁸ 31 = 31 ⁰，所以让我们把那个操作留为<em class="nf">挂起</em>并设置<code class="fe lj lk ll lm b">result *= a</code>。换句话说，如果<code class="fe lj lk ll lm b">b</code>的 LSB 开启，我们将总结果乘以<code class="fe lj lk ll lm b">a</code>，并将剩余的操作作为<em class="nf">挂起</em>。</li><li id="2db4" class="kv kw in jm b jn le jr lf jv lg jz lh kd li kh la lb lc ld bi translated">将辅助变量<code class="fe lj lk ll lm b">a = a * a</code>平方。该辅助变量将存储上一步<em class="nf">待处理操作</em>的部分结果。我们需要平方这个变量，因为在接下来的步骤中，我们将指数除以 2，我们需要对此进行补偿。为了更清楚地理解这一点，分析一下如果我们跳过这一步会发生什么。</li><li id="8527" class="kv kw in jm b jn le jr lf jv lg jz lh kd li kh la lb lc ld bi translated">将<code class="fe lj lk ll lm b">b = 11</code>向右移动一位。<code class="fe lj lk ll lm b">b &gt;&gt; 1 = 0b1011 &gt;&gt; 1 = 0b0101 = 5</code>。我们现在可以用<code class="fe lj lk ll lm b">b</code>、<code class="fe lj lk ll lm b">result</code>和<code class="fe lj lk ll lm b">a</code>来写我们的总结果，因为 31 =(31)<strong class="jm io"><em class="nf">(31)⁵</em></strong><em class="nf">)。</em>未决操作通知为<em class="nf">斜体</em>粗体<strong class="jm io">粗体</strong>。</li></ol><p id="3316" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">迭代 2 </strong>。至此<code class="fe lj lk ll lm b">result = 31</code>、<code class="fe lj lk ll lm b">b = 5 = 0b0101</code>、<code class="fe lj lk ll lm b">a = 31^2</code></p><ol class=""><li id="4d97" class="kv kw in jm b jn jo jr js jv kx jz ky kd kz kh la lb lc ld bi translated">待定运算是(31 )⁵ = (31 )⁴ (31 ) = <code class="fe lj lk ll lm b">a^4 * a</code>。因为<code class="fe lj lk ll lm b">b = 5</code>是奇数，我们设置<code class="fe lj lk ll lm b">result *= a</code>并离开(31 )⁴为<em class="nf">待定</em>)。</li><li id="67e0" class="kv kw in jm b jn le jr lf jv lg jz lh kd li kh la lb lc ld bi translated">方形辅助变量<code class="fe lj lk ll lm b">a = a * a = (31*31) * (31*31)</code>。</li><li id="8d85" class="kv kw in jm b jn le jr lf jv lg jz lh kd li kh la lb lc ld bi translated">将<code class="fe lj lk ll lm b">b = 5</code>向右移动一位。<code class="fe lj lk ll lm b">b &gt;&gt; 1 = 0b0101 &gt;&gt; 1 = 0b0010 = 2</code>。现在 31 =(31)<strong class="jm io"><em class="nf">(31)⁵</em></strong>=(31)[(31)<strong class="jm io"><em class="nf">(31)⁴</em></strong>)。</li></ol><p id="0282" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">迭代 3 </strong>。到现在为止<code class="fe lj lk ll lm b">result = 31*31*31</code>、<code class="fe lj lk ll lm b">b = 2 = 0b0010</code>、<code class="fe lj lk ll lm b">a = 31^4</code></p><ol class=""><li id="cad2" class="kv kw in jm b jn jo jr js jv kx jz ky kd kz kh la lb lc ld bi translated">待定操作为(31 )⁴ = (31⁴) = <code class="fe lj lk ll lm b">a^2</code>。因为<code class="fe lj lk ll lm b">b = 2</code>是偶数，我们对<code class="fe lj lk ll lm b">result</code>什么都不做，而把(31⁴)留为<em class="nf">待定</em>。</li><li id="b5f4" class="kv kw in jm b jn le jr lf jv lg jz lh kd li kh la lb lc ld bi translated">方形辅助变量<code class="fe lj lk ll lm b">a = a * a = [(31*31) * (31*31)] * [(31*31) * (31*31)]</code>。</li><li id="152c" class="kv kw in jm b jn le jr lf jv lg jz lh kd li kh la lb lc ld bi translated">将<code class="fe lj lk ll lm b">b = 2</code>向右移动一位。<code class="fe lj lk ll lm b">b &gt;&gt; 1 = 0b0010 &gt;&gt; 1 = 0b0001 = 1</code>。现在 31 =(31)<strong class="jm io"><em class="nf">(31)⁵</em></strong>=(31)[(31)<strong class="jm io"><em class="nf">(31)⁴</em></strong>]=(31)[(31)<strong class="jm io"><em class="nf">(31⁴)</em></strong>。</li></ol><p id="e0fe" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">迭代 4 </strong>。至此<code class="fe lj lk ll lm b">result = 31*31*31</code>、<code class="fe lj lk ll lm b">b = 1 = 0b0001</code>、<code class="fe lj lk ll lm b">a = 31^8</code></p><ol class=""><li id="85e8" class="kv kw in jm b jn jo jr js jv kx jz ky kd kz kh la lb lc ld bi translated">待定操作是(31⁴) = <code class="fe lj lk ll lm b">a</code>。因为<code class="fe lj lk ll lm b">b = 1</code>是奇数，我们设置<code class="fe lj lk ll lm b">result *= a</code>并且不进行操作，作为<em class="nf">等待</em>。</li><li id="83a8" class="kv kw in jm b jn le jr lf jv lg jz lh kd li kh la lb lc ld bi translated">方形辅助变量<code class="fe lj lk ll lm b">a = a * a</code>(这样做没有用，因为没有未完成的操作)</li><li id="9511" class="kv kw in jm b jn le jr lf jv lg jz lh kd li kh la lb lc ld bi translated">将<code class="fe lj lk ll lm b">b = 1</code>向右移动一位。<code class="fe lj lk ll lm b">b &gt;&gt; 1 = 0b0001 &gt;&gt; 1 = 0b0000 = 0</code>。现在 31 =(31)(31)⁵=(31)[(31)(31)⁴]=(31)[(31)(31⁴)]。</li></ol><p id="001d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">到目前为止，没有未完成的操作，<code class="fe lj lk ll lm b">result = 31^11</code>和<code class="fe lj lk ll lm b">b = 0</code>，所以我们完成了👏。</p><p id="bef0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在我们已经理解了算法，让我们看看汇编代码。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="ba37" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我认为代码很简单，可能看起来复杂的是算法，但我希望前面的解释能帮助你清楚地理解它。尽管如此，我还是要解释一下这段代码的一些特殊之处。</p><ul class=""><li id="ba44" class="kv kw in jm b jn jo jr js jv kx jz ky kd kz kh nm lb lc ld bi translated">如果运算结果为<code class="fe lj lk ll lm b">0</code>，则<code class="fe lj lk ll lm b">and</code>和<code class="fe lj lk ll lm b">shr</code>(右移)都设置 ZF(零标志)。这就是为什么我们可以在执行完那些操作后立即使用<code class="fe lj lk ll lm b">jz</code>(如果为零则跳转)和<code class="fe lj lk ll lm b">jnz</code>(如果不为零则跳转)。</li><li id="c0aa" class="kv kw in jm b jn le jr lf jv lg jz lh kd li kh nm lb lc ld bi translated">堆栈内存用于存储一个临时变量(第 19 行和第 22 行)。</li><li id="a0c3" class="kv kw in jm b jn le jr lf jv lg jz lh kd li kh nm lb lc ld bi translated">现在不要担心<code class="fe lj lk ll lm b">printf</code>和<code class="fe lj lk ll lm b">fflush</code>函数，我们将在<a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/assembly-by-example-compute-string-hash-part-3-cli-args-and-external-functions-c3b533e99cdd">第三部分</a>中学习如何使用它们。使用它们是因为结果是一个很大的数字，不能用一个字节来表示，所以使用退出状态代码作为输出不是很有用。</li></ul><p id="05e4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">等效的 C 代码应该是</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nd ne l"/></div></figure></div><div class="ab cl oa ob hr oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="ig ih ii ij ik"><h1 id="a0f5" class="ln lo in bd lp lq oh ls lt lu oi lw lx ly oj ma mb mc ok me mf mg ol mi mj mk bi translated">结论</h1><p id="c85f" class="pw-post-body-paragraph jk jl in jm b jn ml jp jq jr mm jt ju jv mn jx jy jz mo kb kc kd mp kf kg kh ig bi translated">第二部分到此结束。我们已经讲述了循环在汇编中是如何工作的，现在我们已经准备好学习 cli 参数和外部函数，这也是我们将在<a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/assembly-by-example-compute-string-hash-part-3-cli-args-and-external-functions-c3b533e99cdd">第三部分</a>中检查的内容。</p><p id="95cb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一如既往，如果你认为有什么地方错了或者有什么地方可以改进，请告诉我。</p></div><div class="ab cl oa ob hr oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="ig ih ii ij ik"><h1 id="751f" class="ln lo in bd lp lq oh ls lt lu oi lw lx ly oj ma mb mc ok me mf mg ol mi mj mk bi translated">附录 A</h1><p id="1572" class="pw-post-body-paragraph jk jl in jm b jn ml jp jq jr mm jt ju jv mn jx jy jz mo kb kc kd mp kf kg kh ig bi translated">对于那些好奇的人，这是 pow 算法的递归版本。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nd ne l"/></div></figure></div></div>    
</body>
</html>