<html>
<head>
<title>The Algorithmic Approach in Life</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">生活中的算法方法</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/the-algorithmic-approach-in-life-de0b2ecbff23?source=collection_archive---------8-----------------------#2020-05-26">https://blog.devgenius.io/the-algorithmic-approach-in-life-de0b2ecbff23?source=collection_archive---------8-----------------------#2020-05-26</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><h2 id="03f0" class="il im in bd b dl io ip iq ir is it dk iu translated" aria-label="kicker paragraph">算法</h2><div class=""/><figure class="gl gn ju jv jw jx gh gi paragraph-image"><div role="button" tabindex="0" class="jy jz di ka bf kb"><div class="gh gi jt"><img src="../Images/a3ea62796678fa5f4abf9cadc5d45ebb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ATK-AQ6S7ImVxHgw5iF_kQ.jpeg"/></div></div></figure><p id="3174" class="pw-post-body-paragraph ke kf in kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ig bi translated">你过去一定解决过很多算法问题，但是你有没有想过这些算法是如何在我们的日常生活中发挥重要作用的？我也一直很好奇。这就是为什么我想出了这个系列，它将通过考虑现实生活中的例子来建立你对算法的实际知识。</p><p id="81c1" class="pw-post-body-paragraph ke kf in kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ig bi translated"><strong class="kg ix">今天我们要讨论一个这样的例子——</strong></p><p id="ea9c" class="pw-post-body-paragraph ke kf in kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ig bi translated">假设有一天天气很好，在开发一个产品时，你在一个现有的特性中发现了一个错误。经过详细的分析，您意识到这个 bug 是由本周的一些提交引起的，因为您在本周早些时候测试了这个特性，它工作得很好。现在您需要找到导致这个问题的提交，并恢复它所做的更改。最大挑战是如何找到错误的提交。</p><h1 id="4294" class="lc ld in bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated"><strong class="ak">让我们试着先把这个问题形象化</strong></h1><figure class="mb mc md me gt jx gh gi paragraph-image"><div role="button" tabindex="0" class="jy jz di ka bf kb"><div class="gh gi ma"><img src="../Images/6d8c217e378bcab7b96cdf97d1328649.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WpLPO1j6pK46QYOy"/></div></div></figure><p id="f04e" class="pw-post-body-paragraph ke kf in kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ig bi translated">从图中我们可以清楚地看到，一旦引入了一个错误，随后的提交也会有同样的错误，并且是糟糕的提交。<strong class="kg ix">在第一次错误提交之前的提交将是好的。</strong></p></div><div class="ab cl mf mg hr mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ig ih ii ij ik"><h1 id="7f69" class="lc ld in bd le lf mm lh li lj mn ll lm ln mo lp lq lr mp lt lu lv mq lx ly lz bi translated">天真的方法</h1><p id="8329" class="pw-post-body-paragraph ke kf in kg b kh mr kj kk kl ms kn ko kp mt kr ks kt mu kv kw kx mv kz la lb ig bi translated">找到错误提交的一种方法是从最近一次开始扫描当前一周内完成的所有提交，并返回直到找到一个好的提交。之后的提交将是第一个错误的提交。</p><p id="ea0f" class="pw-post-body-paragraph ke kf in kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ig bi translated">下面是同样的例子(G =好的提交，B =坏的提交)</p><figure class="mb mc md me gt jx gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/eff0248edb18ea0b7c03a303fe802de1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/0*a2f9VqK3Lfn7zXrE"/></div></figure><p id="fcb4" class="pw-post-body-paragraph ke kf in kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ig bi translated">这种方法看起来很简单，但是它的缺点是什么呢？想象一个大项目和多个团队参与其中。如果我们的代码库中本周有<strong class="kg ix"> 1000 </strong>个提交会怎么样？使用上述方法扫描这些提交并找出第一个错误的提交需要大量的尝试。</p><p id="4c46" class="pw-post-body-paragraph ke kf in kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ig bi translated">我们可以很容易地发现，在最坏的情况下，尝试的次数将接近于 1000 次</p><p id="d6f2" class="pw-post-body-paragraph ke kf in kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ig bi translated">我们能减少尝试的次数吗？</p><p id="20b0" class="pw-post-body-paragraph ke kf in kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ig bi translated">答案是<strong class="kg ix">是的。</strong></p><p id="6edd" class="pw-post-body-paragraph ke kf in kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ig bi translated">在上面的方法中，我们按顺序扫描每个提交，直到找到一个好的提交。我们在这里忽略了一个重要的事实，即<strong class="kg ix">提交</strong>中有一个模式。如果好的提交由 G 表示，坏的提交由 B 表示，则提交历史类似于 GGGGGGGG……bbbbbbbbbbbbbbbbbb。</p><p id="8240" class="pw-post-body-paragraph ke kf in kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ig bi translated">基于这个事实，我们可以找到中间提交，并检查它是好还是坏。如果中间提交是好的，那么我们的下一个搜索空间将包含中间提交之后的提交。类似地，如果中间提交是错误的，那么我们的下一个搜索空间将只包含中间提交之前的提交。通过这种方式，我们优化了我们的方法。<strong class="kg ix">我们在这里应用了<em class="mx"> </em> </strong> <a class="ae my" href="https://en.wikipedia.org/wiki/Divide-and-conquer_algorithm" rel="noopener ugc nofollow" target="_blank"> <strong class="kg ix">分而治之的策略</strong> </a> <strong class="kg ix">。</strong></p><h1 id="0071" class="lc ld in bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">详细优化方法</h1><p id="a116" class="pw-post-body-paragraph ke kf in kg b kh mr kj kk kl ms kn ko kp mt kr ks kt mu kv kw kx mv kz la lb ig bi translated">我们可以将初始搜索空间分为两部分，并检查两种情况下的中间提交:</p><ul class=""><li id="6ed4" class="mz na in kg b kh ki kl km kp nb kt nc kx nd lb ne nf ng nh bi translated">第一种情况是中间提交是一个错误的提交。</li></ul><p id="847b" class="pw-post-body-paragraph ke kf in kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ig bi translated">现在有两种可能性:</p><ol class=""><li id="00ae" class="mz na in kg b kh ki kl km kp nb kt nc kx nd lb ni nf ng nh bi translated">中间提交之前的提交是好的，那么中间提交是第一个坏的提交</li><li id="e3ba" class="mz na in kg b kh nj kl nk kp nl kt nm kx nn lb ni nf ng nh bi translated">如果之前的提交也是一个错误的提交，那么我们的搜索空间将减少到这个中间提交之前的所有提交</li></ol><ul class=""><li id="49b5" class="mz na in kg b kh ki kl km kp nb kt nc kx nd lb ne nf ng nh bi translated"><strong class="kg ix">第二种情况是中间提交是否是一个好的提交。</strong></li></ul><p id="f8e2" class="pw-post-body-paragraph ke kf in kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ig bi translated">现在我们只需要考虑中间提交之后的提交，因为之前的提交都是好的提交。上述过程可以递归地应用于查找第一个错误提交。</p><p id="be2c" class="pw-post-body-paragraph ke kf in kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ig bi translated">为了更好地理解，下面是演示</p><figure class="mb mc md me gt jx gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/1c944f4b6c65152a659d424c96a7c6a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/0*yqCFg8P9IFVElVqe"/></div></figure><h1 id="d979" class="lc ld in bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated"><strong class="ak">分析</strong></h1><p id="fade" class="pw-post-body-paragraph ke kf in kg b kh mr kj kk kl ms kn ko kp mt kr ks kt mu kv kw kx mv kz la lb ig bi translated">在上述过程中，每次我们都将搜索空间减半，直到找到第一个错误提交，因此让我们计算尝试次数</p><p id="0459" class="pw-post-body-paragraph ke kf in kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ig bi translated">每次我们将搜索空间减少一半，在最坏的情况下，我们将继续，直到我们在搜索空间中剩下 1 个提交，所以我们可以说</p><figure class="mb mc md me gt jx gh gi paragraph-image"><div role="button" tabindex="0" class="jy jz di ka bf kb"><div class="gh gi no"><img src="../Images/6e1ee490ffd5329a8ddeaf4aee2a6a0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1320/format:webp/1*hEJYiS115gDndFG9ydmQjw.png"/></div></div></figure><p id="15f0" class="pw-post-body-paragraph ke kf in kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ig bi translated">这种方法比前一种方法快得多，因为尝试次数从 1000 次减少到 10 次。</p><h1 id="088d" class="lc ld in bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated"><strong class="ak">结论</strong></h1><p id="1372" class="pw-post-body-paragraph ke kf in kg b kh mr kj kk kl ms kn ko kp mt kr ks kt mu kv kw kx mv kz la lb ig bi translated">我也可以讨论问题的工作解决方案，但这不是这篇博客的目的。我只是想让大家了解，每当我们陷入现实生活中的问题时，我们如何应用我们的算法知识。</p><p id="1416" class="pw-post-body-paragraph ke kf in kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ig bi translated">这只是个开始，请继续关注更多这样的内容😊</p><p id="fbc2" class="pw-post-body-paragraph ke kf in kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ig bi translated">有关分治算法的更多信息，请查看以下链接-</p><ul class=""><li id="dd02" class="mz na in kg b kh ki kl km kp nb kt nc kx nd lb ne nf ng nh bi translated"><a class="ae my" href="https://en.wikipedia.org/wiki/Divide-and-conquer_algorithm" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Divide-and-conquer_algorithm</a></li><li id="c3db" class="mz na in kg b kh nj kl nk kp nl kt nm kx nn lb ne nf ng nh bi translated"><a class="ae my" href="https://www.geeksforgeeks.org/divide-and-conquer-algorithm-introduction/" rel="noopener ugc nofollow" target="_blank">https://www . geeks forgeeks . org/divide-and-conquer-algorithm-introduction/</a></li></ul></div></div>    
</body>
</html>