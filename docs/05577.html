<html>
<head>
<title>How To Test Spring Boot Microservice Independently Using WireMock?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用WireMock独立测试Spring Boot微服务？</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-to-test-spring-boot-microservice-independently-using-wiremock-d269d20fa626?source=collection_archive---------2-----------------------#2021-09-12">https://blog.devgenius.io/how-to-test-spring-boot-microservice-independently-using-wiremock-d269d20fa626?source=collection_archive---------2-----------------------#2021-09-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="62e8" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">让我们看看如何使用WireMock实现单元测试和组件测试</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/530602c692daceedb7dfef08b1e3dec5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_GaMi6fpDPa6pi3y7Os5Fg.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@girlwithredhat?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">戴红帽的女孩</a>在<a class="ae kv" href="https://unsplash.com/t/technology?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="fdbf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如今，从全球银行、保险公司到中小型创业公司，许多企业都广泛采用微服务架构。不可否认，这种架构方法通过将复杂的系统分解成单独的服务，实现了快速的开发和部署过程。然而，传统的方法不再适用于质量保证。</p><p id="bfe2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">单独的微服务是不可操作的。对于负责编排其他服务来执行业务功能的服务来说尤其如此。</p><p id="16d5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们来看一个保险产品报价服务的例子。业务逻辑编码在报价服务中，它使用客户服务和产品服务的API端点，以便根据客户资料和产品规格确定价格。显然，如果客户服务或产品服务不可用，报价服务就不能制定任何报价。同样的情况也适用于测试，报价服务不能单独测试。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ls"><img src="../Images/2eddfad918dd00fd5124b19326db32a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1148/format:webp/1*ByJp8_DA0uNnRzHWB862Wg.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">报价服务</figcaption></figure><p id="20fb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">也许，客户和产品的服务仍在开发中，不可用于测试。我们应该推迟测试过程直到所有外部服务都准备好了吗？您可以这样做，但是延迟特性交付绝对不是一个好的选择。</p><h1 id="5f1a" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">使用WireMock加速开发</h1><p id="5ee2" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">在没有依赖服务的情况下，我们如何独立地开发和测试服务？设置测试存根是一个聪明的变通方法，这样报价服务就可以像真正的服务一样使用模拟API。</p><p id="a866" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">WireMock 是最流行的HTTP模拟服务器之一，你可以通过设置模拟响应轻松地为客户和产品服务创建存根。它可以作为应用程序的一部分运行，也可以作为独立的进程运行。在本文中，我将以报价服务为例，向您展示如何为Java Spring Boot应用程序实现单元测试和组件测试。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/86fc5ac5357fd409c430b646da0aca97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1192/format:webp/1*O5-Wc9QrXiG332N4DcsxfA.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">使用WireMock进行微服务测试</figcaption></figure></div><div class="ab cl mr ms hu mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ij ik il im in"><h1 id="c125" class="lt lu iq bd lv lw my ly lz ma mz mc md jw na jx mf jz nb ka mh kc nc kd mj mk bi translated">单元测试</h1><p id="c4c0" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">对于API客户端的单元测试，目的是验证一个API客户端对于客户检索服务的逻辑。测试场景首先为客户检索API <code class="fe nd ne nf ng b">/customers/12</code>设置一个模拟响应。当API客户机向模拟API提交请求时，WireMock将查找相应的响应并将其返回给API客户机。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/79f2a7c96eec33c673b4b33b8c883c5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/1*_2HIQfT4jrx2q6KxDd-aMw.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">单元测试</figcaption></figure><h2 id="2901" class="ni lu iq bd lv nj nk dn lz nl nm dp md lf nn no mf lj np nq mh ln nr ns mj nt bi translated">将WireMock添加到Maven依赖项</h2><p id="9ee7" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">将WireMock库包含在测试用例执行的应用程序中。您需要将这个依赖项添加到Maven pom.xml中。</p><pre class="kg kh ki kj gt nu ng nv nw aw nx bi"><span id="c135" class="ni lu iq ng b gy ny nz l oa ob">&lt;dependency&gt;<br/>  &lt;groupId&gt;com.github.tomakehurst&lt;/groupId&gt;<br/>  &lt;artifactId&gt;wiremock-jre8&lt;/artifactId&gt;<br/>  &lt;version&gt;2.30.1&lt;/version&gt;<br/>  &lt;scope&gt;test&lt;/scope&gt;<br/>&lt;/dependency&gt;</span></pre><p id="6703" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面的示例代码演示了如何为单元测试初始化WireMock。WireMock服务器是用动态端口号初始化的。它是一个静态类成员，所以所有的单元测试用例共享同一个WireMock实例。带注释的方法<code class="fe nd ne nf ng b">@AfterAll </code>和<code class="fe nd ne nf ng b">@BeforeAll</code>允许JUnit分别在测试执行开始之前和测试完成之后启动和停止WireMock服务器。还有另一个带注释<code class="fe nd ne nf ng b">@AfterEach</code>的方法，在每个测试场景结束时清理所有的存根。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="d18d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">测试场景以<code class="fe nd ne nf ng b">Given — When — Then</code>的格式排列，使得测试流程易于阅读；</p><ul class=""><li id="11e9" class="oe of iq ky b kz la lc ld lf og lj oh ln oi lr oj ok ol om bi translated"><strong class="ky ir">步骤1 </strong> — <strong class="ky ir">给定</strong> —为客户API设置WireMock存根。该方法调用存根创建是很容易理解的。</li><li id="1a50" class="oe of iq ky b kz on lc oo lf op lj oq ln or lr oj ok ol om bi translated"><strong class="ky ir">步骤2 </strong> — <strong class="ky ir">当</strong>时—调用客户API客户端获取客户记录</li><li id="aa1b" class="oe of iq ky b kz on lc oo lf op lj oq ln or lr oj ok ol om bi translated"><strong class="ky ir">步骤3 </strong> — <strong class="ky ir">然后</strong> —验证检索到的客户记录。此外，这个示例演示了如何使用verify()方法来检查WireMock服务器是否收到了客户检索请求。</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oc od l"/></div></figure></div><div class="ab cl mr ms hu mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ij ik il im in"><h1 id="33dc" class="lt lu iq bd lv lw my ly lz ma mz mc md jw na jx mf jz nb ka mh kc nc kd mj mk bi translated">组件测试</h1><p id="44a3" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">接下来，让我们演练如何将WireMock应用于组件测试。我们将保险报价服务视为组件测试中的黑盒，这意味着我们通过向服务API提交请求并检查输出来运行测试，而不知道服务的内部逻辑。MongoDB等基础设施组件将在Testcontainers上运行，WireMock将为外部API服务提供存根。</p><p id="2201" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与单元测试类似，第一步是为客户和产品API设置存根。接下来，提交一个API请求来生成报价。然后，验证生成的报价以及数据库中插入的记录。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi os"><img src="../Images/acf6ccbb4f8becbf427458c235cf5d65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y5IU9XGC13qSzW87dLPstw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">部件试验</figcaption></figure><p id="6402" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">组件测试是使用Cucumber构建的。如果你是黄瓜测试的新手，请阅读这篇文章。</p><div class="ot ou gp gr ov ow"><a rel="noopener  ugc nofollow" target="_blank" href="/start-behavior-driven-development-bdd-for-java-springboot-rest-api-using-cucumber-f6b1754d93b1"><div class="ox ab fo"><div class="oy ab oz cl cj pa"><h2 class="bd ir gy z fp pb fr fs pc fu fw ip bi translated">使用Cucumber开始Java SpringBoot REST API的行为驱动开发(BDD)</h2><div class="pd l"><h3 class="bd b gy z fp pb fr fs pc fu fw dk translated">为自动化的端到端测试创建人类可读的测试用例</h3></div><div class="pe l"><p class="bd b dl z fp pb fr fs pc fu fw dk translated">blog.devgenius.io</p></div></div><div class="pf l"><div class="pg l ph pi pj pf pk kp ow"/></div></div></a></div><h2 id="2f39" class="ni lu iq bd lv nj nk dn lz nl nm dp md lf nn no mf lj np nq mh ln nr ns mj nt bi translated"><strong class="ak"> Git存储库</strong></h2><p id="5d5a" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">提供了组件测试的示例实现，可以随意克隆这个库:<a class="ae kv" href="https://github.com/gavinklfong/spring-wiremock-demo" rel="noopener ugc nofollow" target="_blank">https://github.com/gavinklfong/spring-wiremock-demo</a></p><h2 id="a54f" class="ni lu iq bd lv nj nk dn lz nl nm dp md lf nn no mf lj np nq mh ln nr ns mj nt bi translated">应用程序上下文初始化</h2><p id="cfdb" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">在测试执行之前，WireMock和其他模拟工具(如测试容器)将被初始化并注入到Spring上下文中。</p><p id="495e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下图从较高的层面说明了初始化过程的顺序。一旦Cucumber test runner被触发，上下文配置将启动一个初始化器，这个初始化器启动WireMock和MongoDB。连接信息，例如WireMock和MongoDB的端口号，将被注入到Spring Boot上下文中，以便报价服务可以与WireMock和MongoDB连接。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pl"><img src="../Images/df37f59bfccad36de53f32309b33d9f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*agMsAM_7T9XtyMkasQmFIQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">组件测试初始化</figcaption></figure><h1 id="feb6" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">测试场景</h1><p id="55a4" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">参考下面的黄瓜测试场景特性，测试场景首先定义了家庭保险产品规范。在后台，根据特性文件中列出的产品属性创建一个产品WireMock存根。接下来，根据示例表中列出的客户年龄和邮政编码的不同组合，执行几轮测试。</p><p id="f50f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在每一轮测试执行中，都会创建客户WireMock存根，以便客户API返回给定时间的客户记录。然后，使用提供的地址邮政编码向报价服务提交请求。最后，验证返回的价格和数据库中生成的报价记录。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pm"><img src="../Images/61b0b226d29221e240736a25411f5376.png" data-original-src="https://miro.medium.com/v2/resize:fit:1348/format:webp/1*KTj4JoLq8aZ695VtB5F8CA.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">组件测试特征文件</figcaption></figure><p id="4c82" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们一步一步地完成实现。</p><h2 id="97e0" class="ni lu iq bd lv nj nk dn lz nl nm dp md lf nn no mf lj np nq mh ln nr ns mj nt bi translated">步骤1 —设置产品API WireMock存根</h2><p id="cbcf" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">给定数据表中定义的产品属性列表，此步骤将构造一个产品对象。然后，创建一个产品API存根，这样对/products/的带有默认产品代码的GET请求将返回指定的产品对象。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oc od l"/></div></figure><h2 id="40ab" class="ni lu iq bd lv nj nk dn lz nl nm dp md lf nn no mf lj np nq mh ln nr ns mj nt bi translated">步骤2 —设置客户API WireMock存根</h2><p id="e388" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">根据提供的客户年龄，这一步创建一个客户API存根。因此，对具有默认客户id的/customers/的GET请求将返回指定年龄的客户记录。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oc od l"/></div></figure><h2 id="6dc6" class="ni lu iq bd lv nj nk dn lz nl nm dp md lf nn no mf lj np nq mh ln nr ns mj nt bi translated">第3步—提交报价请求</h2><p id="f4e8" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">准备好API存根后，是时候测试报价服务了。要求报价与提供的地址邮政编码，并找出多少钱的家庭保险政策。报价服务将从存根API中获取客户和产品。让我们将生成的报价放入测试上下文中，以便在下一步中进行验证。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oc od l"/></div></figure><h2 id="7610" class="ni lu iq bd lv nj nk dn lz nl nm dp md lf nn no mf lj np nq mh ln nr ns mj nt bi translated">步骤4 —验证生成的价格</h2><p id="7c1d" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">重要的是，生成的价格应该是正确的，并且与示例表中提供的预期价格相同。这一步非常简单，因为你可以比较价格。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oc od l"/></div></figure><h2 id="ee48" class="ni lu iq bd lv nj nk dn lz nl nm dp md lf nn no mf lj np nq mh ln nr ns mj nt bi translated">步骤5 —验证数据库中的记录</h2><p id="cbc0" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">因为报价服务的输出不仅仅是API响应，还包括插入数据库的新记录，所以这一步是查看数据库并验证报价记录是否被正确保存。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oc od l"/></div></figure></div><div class="ab cl mr ms hu mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ij ik il im in"><h1 id="0f03" class="lt lu iq bd lv lw my ly lz ma mz mc md jw na jx mf jz nb ka mh kc nc kd mj mk bi translated">最后的想法</h1><p id="702d" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">模仿已经成为现代软件开发中的一项基本技能。除了为单元测试模仿内部服务组件之外，为外部API设置存根对于组件测试是至关重要的，尤其是对于基于服务的系统的开发。如果您需要独立测试您的服务，WireMock是一个有用的工具。它与JUnit和Cucumber配合得非常好，因此您可以轻松地为单元测试和组件测试构建API存根。</p><p id="3b44" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，为了正确初始化WireMock以创建存根，需要样板代码。请随意使用本文中的<a class="ae kv" href="https://github.com/gavinklfong/spring-wiremock-demo" rel="noopener ugc nofollow" target="_blank">示例实现</a>作为模板，这样它当然可以帮助您快速构建自己的测试，而无需从头开始建立整个框架。</p></div></div>    
</body>
</html>