<html>
<head>
<title>Logging With Serilog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 Serilog 记录</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/logging-with-serilog-f6903b0c176?source=collection_archive---------0-----------------------#2021-07-11">https://blog.devgenius.io/logging-with-serilog-f6903b0c176?source=collection_archive---------0-----------------------#2021-07-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f457" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何配置 Serilog 并将日志分割成不同的文件</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/7139fcd4e3937a2feb3d45104076ecab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VFjyQqzvYrv714PB73m20w.png"/></div></div></figure><p id="05c5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这篇文章中，我将首先向你展示一些配置 Serilog 登录的基础知识。NET/ASP。NET 应用程序。然后转到如何拆分或隐藏日志的主题。源代码可以在<a class="ae ln" href="https://github.com/dotnet-labs/SerilogFilterDemo" rel="noopener ugc nofollow" target="_blank">我的 GitHub 库</a>找到。</p><h1 id="fbb8" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">系列配置基础</h1><p id="a0aa" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">Serilog 是一种著名的测井工具。NET 和 ASP.NET 应用程序。我们可以使用下面一行代码轻松创建一个全局共享的日志记录器。</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="07aa" class="mq lp iq mm b gy mr ms l mt mu">Log.Logger = new LoggerConfiguration().CreateLogger();</span></pre><p id="daa6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">以这种方式创建的记录器将与我们的应用程序具有相同的生命周期。您还可以使用一个<code class="fe mv mw mx mm b">using</code>语句来创建一个短期日志记录器，但是这种用例很少。</p><p id="efe0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Serilog 可以使用简单的 C# API 直接在代码中配置记录器，也可以从设置文件中加载外部配置。对于最低配置，我们需要将日志接收器连接到全局静态日志记录器，以便可以将消息写入某个位置。例如，我们可以添加一个控制台接收器来记录日志事件，如下所示。</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="26ea" class="mq lp iq mm b gy mr ms l mt mu">Log.Logger = new LoggerConfiguration()<br/>    .WriteTo.Console()<br/>    .CreateLogger();</span></pre><p id="dfe5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在创建了全局记录器之后，我们需要告诉。NET 或 ASP.NET 的日志，以便。NET 或 ASP.NET 可以通过管道将消息发送给 Serilog。否则，如果不向主机分配日志提供者，那么由<code class="fe mv mw mx mm b">ILogger&lt;T&gt;</code>记录的消息就没有出口。要将 Serilog 注册为日志提供者，我们可以如下调用<code class="fe mv mw mx mm b">IHostBuilder</code>上的<code class="fe mv mw mx mm b">UseSerilog()</code>方法。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="19e8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">此后，我们可以使用中的日志系统将消息记录到所需的接收器中。我们也可以在任何地方直接使用全局记录器。下面一行显示了全局记录器的示例用法。</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="0d44" class="mq lp iq mm b gy mr ms l mt mu">Log.Information("Application Starts");</span></pre><p id="972f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Serilog 提供了多种汇(<a class="ae ln" href="https://github.com/serilog/serilog/wiki/Provided-Sinks" rel="noopener ugc nofollow" target="_blank">链接</a>)。我们可以根据需要添加它们。例如，要将日志保存到文件中，我们可以如下所示将文件接收器附加到日志记录器。</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="717a" class="mq lp iq mm b gy mr ms l mt mu">Log.Logger = new LoggerConfiguration()<br/>    .WriteTo.Console()<br/>    .WriteTo.File("log.txt", rollingInterval: RollingInterval.Day)<br/>    .CreateLogger();</span></pre><h1 id="5047" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">拆分或隐藏日志</h1><p id="02bf" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">有时，我们可能希望对每个接收器的日志消息类别进行更细粒度的控制。例如，我们希望将具有不同日志级别的消息记录到不同的文件中，以便将错误和警告从低重要性消息中突出出来。另一个例子，我们希望将后台作业的消息记录到一个不同于记录常规例程的文件中。或者我们希望抑制一部分消息以降低噪声水平。对于这些用例，Serilog 允许我们使用过滤器来设置日志管道，以包含或排除某些日志事件，从而将日志划分到不同的接收器中。例如，以下配置创建了一个控制台记录器，它将输出所有消息，以及一个子记录器，它根据行<code class="fe mv mw mx mm b">Filter.ByIncludingOnly(...)</code>中定义的标准只将某些事件写入<code class="fe mv mw mx mm b">log.txt</code>文件。</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="37c7" class="mq lp iq mm b gy mr ms l mt mu">Log.Logger = new LoggerConfiguration()<br/>    .WriteTo.Console()<br/>    .WriteTo.Logger(lc =&gt; lc<br/>        .Filter.ByIncludingOnly(...)<br/>        .WriteTo.File("log.txt"))<br/>    .CreateLogger();</span></pre><p id="c786" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">大多数关于使用<code class="fe mv mw mx mm b">Filter</code>的例子都集中在介绍使用强大的 SQL 式语法的过滤表达式。<a class="ae ln" href="https://github.com/serilog/serilog-expressions" rel="noopener ugc nofollow" target="_blank">过滤器表达式文档</a>给出了全部细节。我喜欢过滤器表达式，因为它在 XML 或 JSON 文件的配置中提供了很大的灵活性。</p><p id="90cb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里我想介绍另一种过滤日志事件的便捷方式:通过在<code class="fe mv mw mx mm b">LogContext</code>中包含/排除属性。</p><p id="0800" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">例如，一个方法有两个依赖项<code class="fe mv mw mx mm b">_myService1</code>和<code class="fe mv mw mx mm b">_myService2</code>。</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="59c5" class="mq lp iq mm b gy mr ms l mt mu">public async Task MyMethod()<br/>{<br/>    _logger.LogInformation("foo bar start");<br/>    await _myService1.Foo();<br/>    await _myService2.Bar();<br/>    _logger.LogInformation("foo bar end");<br/>}</span></pre><p id="56ba" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在我们想把这个方法下的所有执行消息写到一个名为<code class="fe mv mw mx mm b">foobar.txt</code>的单独文件中。我们可以使用 filter express 通过类名计算出 LogContext。然而，如果我们在方法中引入另一个依赖项，这将是不可伸缩的。一种更简单的方法是按属性名和/或属性值进行过滤。</p><p id="4fc3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">出于演示的目的，我们可以将一个属性推入日志上下文，以便该方法执行路径中的所有日志事件都将继承该属性的键和值。下面的代码片段显示了一个示例。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="9f6e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe mv mw mx mm b">using</code>语句创建一个作用域，并确保所需的属性不会泄露给其他方法。在该范围内，所有日志事件都将包含属性。因此，我们可以根据键值对过滤这些日志事件。请注意，您可以为所有属性键值对创建一个类，以避免神奇的字符串/值。</p><p id="7ec1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">下面的代码片段显示了一个过滤示例。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="my mz l"/></div><figcaption class="na nb gj gh gi nc nd bd b be z dk translated"><a class="ae ln" href="https://gist.github.com/changhuixu/826642193dd7dc23080ea7274d9515c3" rel="noopener ugc nofollow" target="_blank">要点链接</a></figcaption></figure><p id="0b56" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">通过上面的配置，普通日志(日志事件中没有属性<code class="fe mv mw mx mm b">foobar</code>)将被保存到<code class="fe mv mw mx mm b">log.txt</code>文件中，而具有属性<code class="fe mv mw mx mm b">foobar</code>的日志将被保存到<code class="fe mv mw mx mm b">foobar.txt</code>文件中。您还可以基于键和值编写更复杂的过滤器。</p></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><p id="6694" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">今天到此为止。我们已经讲述了 Serilog 配置的一些基础知识，并且学习了一些过滤日志的技巧。同样，你可以在<a class="ae ln" href="https://github.com/dotnet-labs/SerilogFilterDemo" rel="noopener ugc nofollow" target="_blank">我的 GitHub 库</a>中找到源代码。</p><p id="1622" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">希望有帮助。感谢阅读。</p></div></div>    
</body>
</html>