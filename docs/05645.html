<html>
<head>
<title>Writing an X86–64 Assembly Language Program</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编写X86–64汇编语言程序</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/writing-an-x86-64-assembly-language-program-648b6005e8e?source=collection_archive---------0-----------------------#2021-09-25">https://blog.devgenius.io/writing-an-x86-64-assembly-language-program-648b6005e8e?source=collection_archive---------0-----------------------#2021-09-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1d80" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">第三部分:打印命令行参数</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/d75c190dee26ae1438b6185872728ab0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*AFkuI23SigwG9Uxc"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@ffstop?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">福蒂斯·福托普洛斯</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="f9cd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们已经建立了一个高效的开发环境，是时候写一些实际的汇编语言代码了。在本指南中，我将分享我构建一个简单的汇编语言程序的资源和过程。</p><h1 id="fb39" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">打印命令行参数</h1><p id="7060" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">为了演示这些概念，让我们编写一个汇编程序，计算一个文本文件中唯一单词的数量，该文件的名称作为参数提供。</p><p id="3364" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">作为实现这一目标的第一步，程序需要访问命令行参数。第一个程序是关于理解如何使用x86_64 Linux assembly访问命令行参数。</p><p id="977b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你是汇编编程的新手，我建议从本指南开始学习一些基础知识。我在这里引用了一些概念，没有进一步的解释。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mp"><img src="../Images/5f77d3cd169abf16187fd72d5db44843.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*drTBlV7vWju_Vfzp"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">加布里埃尔·海因策在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="cd38" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">什么是命令行参数</h1><p id="a991" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">命令行参数是程序用户在执行程序时包含在命令行中的文本输入。例如，如果有一个名为<code class="fe mq mr ms mt b">a.out</code>的可执行程序，它可以在Linux系统上从命令行用命令运行</p><pre class="kg kh ki kj gt mu mt mv mw aw mx bi"><span id="f5e6" class="my lt iq mt b gy mz na l nb nc">$ ./a.out</span></pre><p id="416a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除此之外，“命令行参数”可以包含在可执行文件名称之后。举个例子，</p><pre class="kg kh ki kj gt mu mt mv mw aw mx bi"><span id="0d77" class="my lt iq mt b gy mz na l nb nc">$ ./a.out 1 2 3</span></pre><p id="019b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种情况下，有三个参数:1、2和3。</p><h1 id="9398" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">调用堆栈</h1><p id="65a4" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">这将有助于理解调用堆栈，因为这是程序开始执行时命令行参数存储的地方。</p><p id="948f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您不熟悉，<a class="ae kv" href="https://en.wikipedia.org/wiki/Call_stack" rel="noopener ugc nofollow" target="_blank">堆栈</a>是驻留在计算机RAM中的后进先出(LIFO)数据结构。堆栈指针跟踪堆栈的“顶部”。在x86_64中，堆栈指针是寄存器<code class="fe mq mr ms mt b">$rpi</code>。<code class="fe mq mr ms mt b">$rpi</code>是指向堆栈的“最后一个”内存地址的指针。可以使用堆栈指针来访问堆栈，也可以使用两个汇编语言命令:<code class="fe mq mr ms mt b">push</code>和<code class="fe mq mr ms mt b">pop</code>。<code class="fe mq mr ms mt b">push</code>可用于向堆栈添加一个值，并更新<code class="fe mq mr ms mt b">$rpi</code>以指向这个新添加的值。<code class="fe mq mr ms mt b">pop</code>可用于从堆栈中获取“最后一个”值，并更新<code class="fe mq mr ms mt b">$rpi</code>以指向堆栈中的下一个值。这些命令的格式是(注意，在汇编语言中分号用于表示注释，因此编译器会忽略<code class="fe mq mr ms mt b">;</code>之后的任何内容):</p><pre class="kg kh ki kj gt mu mt mv mw aw mx bi"><span id="a8b3" class="my lt iq mt b gy mz na l nb nc">; add the value of $rcx to the stack<br/><strong class="mt ir">push rcx</strong></span><span id="6c25" class="my lt iq mt b gy nd na l nb nc">; pop the "Last In" stack value into $rbx. <br/>; In this case, the value of $rcx<br/><strong class="mt ir">pop rbx</strong></span></pre><h1 id="9778" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">在X86–64汇编语言中访问命令行参数</h1><p id="dd9b" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">当程序开始执行时，任何命令行参数都存储在堆栈中。堆栈的顶部将保存参数的数量。如果您已经在<code class="fe mq mr ms mt b">c</code>或<code class="fe mq mr ms mt b">c++</code>中编程，这在<code class="fe mq mr ms mt b">main()</code>中被称为<code class="fe mq mr ms mt b">argc</code>，意思是参数计数。</p><p id="59da" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">堆栈上的第二个值是函数名。这被视为第一个参数，并包括在参数总数中。因此，如果在执行程序时不提供参数,<code class="fe mq mr ms mt b">argc</code>将等于1。</p><p id="177e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">提供的任何参数都将是堆栈中的下一个值。例如，如果您用命令执行了一个程序</p><pre class="kg kh ki kj gt mu mt mv mw aw mx bi"><span id="9f91" class="my lt iq mt b gy mz na l nb nc">./a.out arg1 arg2 arg3</span></pre><p id="3824" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该堆栈将如下所示</p><h2 id="22e2" class="my lt iq bd lu ne nf dn ly ng nh dp mc lf ni nj me lj nk nl mg ln nm nn mi no bi translated">堆栈</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="9cf2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">堆栈指针($rpi)将指向堆栈的顶部，即<code class="fe mq mr ms mt b">argc</code>值4的存储地址。当然，这些值都是用二进制编码的。</p><p id="7f39" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该程序打印出<code class="fe mq mr ms mt b">argc</code>和程序名，中间有换行符:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="2430" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意使用push和pop从堆栈中取出<code class="fe mq mr ms mt b">argc</code>和程序名。</p><p id="05dd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">同样重要的是使用<code class="fe mq mr ms mt b">call</code>命令。这就是如何在程序集中调用一个函数，同时保存调用该函数的行后面的行的地址。然后可以使用<code class="fe mq mr ms mt b">ret</code>命令返回到该行。指向返回位置的内存位置的指针存储在堆栈上。注意，这个值被从堆栈中移除，以便能够访问“隐藏”的值，然后它被推回到堆栈中，因为那是<code class="fe mq mr ms mt b">ret</code>命令期望的内存地址。</p><p id="35eb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢阅读！查看本系列的下一部分，获得一些关于编写你的第一个汇编语言程序的提示<a class="ae kv" href="https://tony-oreglia.medium.com/writing-an-x86-64-assembly-language-program-function-arguments-and-result-dfff25970dee" rel="noopener">这里</a>！</p></div><div class="ab cl nr ns hu nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="ij ik il im in"><h2 id="76b2" class="my lt iq bd lu ne nf dn ly ng nh dp mc lf ni nj me lj nk nl mg ln nm nn mi no bi translated">本指南是系列文章的第三部分</h2><pre class="kg kh ki kj gt mu mt mv mw aw mx bi"><span id="d000" class="my lt iq mt b gy mz na l nb nc">Part one: <a class="ae kv" href="https://medium.com/@tony.oreglia/getting-started-writing-assembly-language-8ecc116f3627" rel="noopener">Getting Started Writing Assembly Language</a><br/>Part two: <a class="ae kv" href="https://medium.com/@tony.oreglia/finding-an-efficient-development-cycle-for-writing-assembly-language-be2092e6db6a" rel="noopener">Finding an Efficient Development Cycle for writing</a></span><span id="7e6a" class="my lt iq mt b gy nd na l nb nc">Part four: <a class="ae kv" href="https://medium.com/@tony.oreglia/writing-an-x86-64-assembly-language-program-function-arguments-and-result-dfff25970dee" rel="noopener">Sending Function Arguments and Receiving a Return Value</a><br/>Part five: <a class="ae kv" href="https://tony-oreglia.medium.com/writing-an-x86-64-assembly-language-program-1aade03f3b9b" rel="noopener">Conditionals, Jumping, and Looping</a><br/>Part six: <a class="ae kv" href="https://tony-oreglia.medium.com/writing-an-x86-64-assembly-language-program-84e2432cf16b" rel="noopener">How to Determine String Length</a><br/>Part seven: <a class="ae kv" href="https://tony-oreglia.medium.com/writing-an-x86-64-assembly-language-program-84e2432cf16b" rel="noopener">Quick Reference</a></span></pre></div></div>    
</body>
</html>