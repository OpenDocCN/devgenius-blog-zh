<html>
<head>
<title>Application Containers for Absolute Beginners</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">绝对初学者的应用程序容器</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/application-containers-for-absolute-beginners-253a61bb6e39?source=collection_archive---------10-----------------------#2020-07-03">https://blog.devgenius.io/application-containers-for-absolute-beginners-253a61bb6e39?source=collection_archive---------10-----------------------#2020-07-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8a52" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">为真实世界准备您的应用程序</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/bd03e87fd1671b579c4b3defa9962d73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a0Ve4jk_XRvWkC_SS1S79w.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">Avel Chuklanov 在<a class="ae kv" href="/s/photos/laptop?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="e24f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我之前的帖子<a class="ae kv" href="https://medium.com/dev-genius/application-programming-for-absolute-beginners-bf2a035efdf6" rel="noopener">绝对初学者的应用程序编程</a>中，我谈了很多关于编程的过程，而不是实际的编程。你可以找到很多你想用哪种语言编写的教程，它们会告诉你如何在屏幕上放置小部件并把它们附加到数据上。我想展示的是如何从存储库中获取代码，如何在不熟悉的代码库中找到自己的路，以及如何跟踪并最终共享您的更改。这些是程序员每天都要做的事情，你越早适应这些过程，你就越早能够在专业的协作环境中工作。</p><p id="8e51" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是在你分享你的改变之后会发生什么呢？你的改变是如何通过系统出现在你公司的网站上的？糟糕的程序员不在乎，他们只是修改，推动，交叉手指。其他的都是别人的工作。我和很多这样的程序员一起工作过，他们非常讨厌。如果你想让自己在工作中变得不可或缺，那就要知道从开始到结束的所有流程，并确保你的改变通过每一步，而不必让你的老板告诉你一切都坏了，都是你的错。</p><p id="62c9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这篇文章不是关于如何把你的程序放在某个应用商店里，甚至也不是关于如何打包它以便在你朋友的电脑上安装和运行。它是关于如何将你的应用程序部署到网络上，以便它可以在浏览器中运行。虽然我们不会一路走到互联网，但我们将创造一个与云提供商提供的环境足够相似的环境，这将使最后一步相对简单。如果您读完这篇文章，并想知道如何利用现有资源实现向云提供商的飞跃，请参阅我的文章拥抱云。</p><p id="a516" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">今天，在容器中运行的图像是用于在互联网上运行的 web 应用程序和 API 的打包系统。正如我们有 Git 和 GitHub 来社会化我们的源代码一样，我们有 Docker 和 DockerHub 来社会化我们的图像。虽然运行容器化应用程序有很多选择，但 Kubernetes 在企业中非常受欢迎，可以在最新的 macOS Docker 桌面上使用。Kubernetes 也可以通过大多数大型云提供商获得。</p><p id="9763" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了阅读本文，您应该已经阅读了针对绝对初学者的应用程序编程。如果你的笔记本电脑真的很低端，你可能要有一些耐心，因为事情可能会运行得有点慢。我写这篇文章的笔记本电脑有 16g 的内存，但你也可以用 8g，甚至 4gb。您还应该了解互联网的基础知识，如 URL 中的元素、基本协议(如 HTTP)和 IP 端口/地址系统。了解诸如<code class="fe ls lt lu lv b">json</code>和<code class="fe ls lt lu lv b">yaml</code>这样的文件格式会有所帮助，但不是绝对必要的。在本文中，我们将在您的计算机上安装的唯一软件是 Docker，所以现在就开始吧。</p><p id="e421" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以在<a class="ae kv" href="https://docs.docker.com/get-docker/" rel="noopener ugc nofollow" target="_blank">https://docs.docker.com/get-docker/</a>找到安装程序和说明。点击“Mac 版 Docker 桌面”,你会发现很多说明和“自述文件”,如果你愿意，你可以通读。准备好后，点击“从 Docker Hub 下载”按钮，在下一页点击“获取 Docker”。这会将 Docker.dmg 下载到您的下载文件夹中。使用 Finder 找到它并连按它。它应该会弹出一个窗口，允许您将应用程序拖动到您的应用程序文件夹。现在，它将从启动板可用，你可以点击它开始运行。启动可能需要一段时间。一旦启动，它会在右上角的工具栏中显示一个图标</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lw"><img src="../Images/c0bc7cd006985241c0863c104ffcf58e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hm4nJ1LoEsYIt3D9Ix5ehQ.png"/></div></div></figure><p id="b197" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">左边的那个，我想应该是一条鲸鱼，上面有一堆货物集装箱。当它加载时，它会激活，一旦它停止激活，它就准备好了。点击它会弹出一个下拉菜单</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi lx"><img src="../Images/97ae39c6d4fdec2f25c5f9ec755d630e.png" data-original-src="https://miro.medium.com/v2/resize:fit:984/format:webp/1*EOAKiFzPxr7gpTq7dajhDw.png"/></div></figure><p id="2b00" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">点击“登录/创建 Docker ID”为 DockerHub 创建一个登录名，您将在此处存储您的图像。按照 DockerHub 页面上的说明注册，并记住您的用户名/密码以备后用。</p><p id="8678" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你跟随绝对初学者的应用程序编程，你将已经有一个<code class="fe ls lt lu lv b">~/src/GitHub/myfirstrepository</code>目录(记住<code class="fe ls lt lu lv b">~</code>是你的主目录的简写)。如果没有，你可以从这里克隆/下载:<a class="ae kv" href="https://github.com/rlkamradt/myfirstrepository" rel="noopener ugc nofollow" target="_blank">https://github.com/rlkamradt/myfirstrepository</a>。您还应该安装了 Atom 编辑器。打开 Atom 编辑器，如果<code class="fe ls lt lu lv b">myfirstrepository</code>项目还没有打开，你可以从“添加项目文件夹”下的“文件”菜单中打开它。您的屏幕应该是这样的:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ly"><img src="../Images/19e13c36fdc7fb492cb7430566410b7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r9xXVMIq2bn227oYuL0PZA.png"/></div></div></figure><p id="8e44" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，右击<code class="fe ls lt lu lv b">myfirstrepository</code>文件夹，选择‘新建文件’，在提示中键入 Dockerfile。您的屏幕现在应该看起来像这样:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ly"><img src="../Images/eb8af7d339b403d61a1e6171d8dd17ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FJtTt-c_alXwJFwK62Jduw.png"/></div></div></figure><p id="ebca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">Dockerfile</code>文件是 Docker 寻找的从应用程序构建图像的指令。粘贴以下内容:</p><pre class="kg kh ki kj gt lz lv ma mb aw mc bi"><span id="2af8" class="md me iq lv b gy mf mg l mh mi">FROM node:10.15.3-alpine</span><span id="fd56" class="md me iq lv b gy mj mg l mh mi"># Create app directory<br/>WORKDIR /usr/src/app</span><span id="ef5f" class="md me iq lv b gy mj mg l mh mi">COPY package*.json ./</span><span id="6a52" class="md me iq lv b gy mj mg l mh mi">RUN npm install</span><span id="d62b" class="md me iq lv b gy mj mg l mh mi"># Bundle app source<br/>COPY . .</span><span id="520a" class="md me iq lv b gy mj mg l mh mi">CMD [ "node", "bin/www" ]</span></pre><p id="9c3b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">按 Control-s 保存。我们需要创建的另一个文件是<code class="fe ls lt lu lv b">.dockerignore</code>,以确保 Docker 只选取我们需要的文件来保持图像较小。右键单击<code class="fe ls lt lu lv b">myfirstrepository</code>文件夹，选择“新建文件”，在提示符下输入<code class="fe ls lt lu lv b">.dockerignore</code>。现在将以下内容添加到该文件中:</p><pre class="kg kh ki kj gt lz lv ma mb aw mc bi"><span id="9126" class="md me iq lv b gy mf mg l mh mi">node_modules<br/>npm-debug.log</span><span id="3ff3" class="md me iq lv b gy mj mg l mh mi">.DS_Store</span></pre><p id="67e7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">再次按下 Control-s 进行保存。Atom 编辑器不会自动保存，所以每当我在最近的更改中遇到问题时，我会立即返回 Atom 以确保我保存了所有内容。如果你在菜单中挖得足够深，你可能会发现一些设置来定期自动保存。</p><p id="fda1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们准备创建我们的第一个图像。打开终端，确保你在<code class="fe ls lt lu lv b">~/src/GitHub/myfirstrepository</code>目录中。您可以使用<code class="fe ls lt lu lv b">ls</code>命令列出文件，以确保您位于正确的位置，并且所有内容都已保存:</p><pre class="kg kh ki kj gt lz lv ma mb aw mc bi"><span id="cf2f" class="md me iq lv b gy mf mg l mh mi">Fuji:myfirstrepository randalkamradt$ ls -l<br/>total 96<br/>-rw-r--r--   1 randalkamradt  staff    162 Jun 27 08:14 Dockerfile<br/>-rw-r--r--   1 randalkamradt  staff   1066 Jun 21 10:50 LICENSE<br/>-rw-r--r--   1 randalkamradt  staff     72 Jun 21 10:55 README.md<br/>-rw-r--r--   1 randalkamradt  staff   1075 Jun 21 12:22 app.js<br/>drwxr-xr-x   3 randalkamradt  staff     96 Jun 21 12:22 bin<br/>drwxr-xr-x  94 randalkamradt  staff   3008 Jun 21 12:27 node_modules<br/>-rw-r--r--   1 randalkamradt  staff  26702 Jun 21 12:27 package-lock.json<br/>-rw-r--r--   1 randalkamradt  staff    305 Jun 21 12:22 package.json<br/>drwxr-xr-x   5 randalkamradt  staff    160 Jun 21 12:22 public<br/>drwxr-xr-x   4 randalkamradt  staff    128 Jun 21 12:22 routes<br/>drwxr-xr-x   5 randalkamradt  staff    160 Jun 21 12:22 views</span></pre><p id="9344" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为文件名以点开始，所以<code class="fe ls lt lu lv b">.dockerignore</code>没有显示。在 Unix/Linux 世界中(macOS 的基础),以点开头的文件名是一个隐藏文件。您可以在<code class="fe ls lt lu lv b">ls</code>命令中添加<code class="fe ls lt lu lv b">-a</code>选项来查看隐藏文件。</p><p id="6672" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，您可以构建图像了。回想一下您在注册 DockerHub 时使用的用户名，运行以下命令，用您的 DockerHub 用户名替换<code class="fe ls lt lu lv b">&lt;dhusername&gt;</code>。</p><pre class="kg kh ki kj gt lz lv ma mb aw mc bi"><span id="484e" class="md me iq lv b gy mf mg l mh mi">docker build --tag &lt;dhusername&gt;/myfirstrepository .</span></pre><p id="c7f1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不要忘记命令末尾的点。<code class="fe ls lt lu lv b">.</code>字符是当前目录的简写。您应该会看到类似这样的内容:</p><pre class="kg kh ki kj gt lz lv ma mb aw mc bi"><span id="6862" class="md me iq lv b gy mf mg l mh mi">Fuji:myfirstrepository randalkamradt$ docker build --tag rlkamradt/myfirstrepository .<br/>Sending build context to Docker daemon  7.037MB<br/>Step 1/6 : FROM node:10.15.3-alpine<br/> ---&gt; 56bc3a1ed035<br/>Step 2/6 : WORKDIR /usr/src/app<br/> ---&gt; Using cache<br/> ---&gt; 3b21d13ce8b8<br/>Step 3/6 : COPY package*.json ./<br/> ---&gt; 076b958e8e3e<br/>Step 4/6 : RUN npm install<br/> ---&gt; Running in 636193ab1213<br/>added 100 packages from 139 contributors and audited 101 packages in 2.651s<br/>found 4 vulnerabilities (3 low, 1 critical)<br/>  run `npm audit fix` to fix them, or `npm audit` for details<br/>Removing intermediate container 636193ab1213<br/> ---&gt; b8715884601e<br/>Step 5/6 : COPY . .<br/> ---&gt; e07942d2fee9<br/>Step 6/6 : CMD [ "node", "bin/www" ]<br/> ---&gt; Running in 16164d30e424<br/>Removing intermediate container 16164d30e424<br/> ---&gt; dff8469752f0<br/>Successfully built dff8469752f0<br/>Successfully tagged rlkamradt/myfirstrepository:latest</span></pre><p id="124d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Docker 逐步构建图像，在本例中，有六个步骤。如果一个步骤中的值保持不变，则可以通过跳过该步骤来节省时间和空间。这应该会在您的本地机器上创建一个映像。要运行您的新映像，请使用 docker run 命令:</p><pre class="kg kh ki kj gt lz lv ma mb aw mc bi"><span id="41e3" class="md me iq lv b gy mf mg l mh mi">docker run -p 3000:3000 &lt;dhusername&gt;/myfirstrepository</span></pre><p id="f013" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在打开你的浏览器到<a class="ae kv" href="http://localhost:3000." rel="noopener ugc nofollow" target="_blank"> http://localhost:3000 </a>。您应该会看到与我们在应用程序编程中为绝对初学者提供的屏幕相同的屏幕。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mk"><img src="../Images/2b462033b0a31d69b388c45fd99572df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aPqdgP6_YAq9Q1ekYqxKIQ.png"/></div></div></figure><p id="05fb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们知道它可以工作了，我们可以用这个命令把它推送到 DockerHub:</p><pre class="kg kh ki kj gt lz lv ma mb aw mc bi"><span id="af6c" class="md me iq lv b gy mf mg l mh mi">docker push &lt;dhusername&gt;/myfirstrepository</span></pre><p id="1cd2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可能需要首先使用<code class="fe ls lt lu lv b">docker login</code>命令登录。现在，你在世界任何地方的任何朋友都可以运行你的程序，只要他们安装了 Docker，只需使用上面的<code class="fe ls lt lu lv b">docker run</code>命令。</p><p id="9ae6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们变得更复杂一点。如果应用程序没有一些变化，特别是持续的变化，它们就不会很令人兴奋。很久以前，当每个人都想建立一个网站，但它只是所有的静态 HTML，可能还有一些 JavaScript，人们能做的最好的事情就是一个访问计数器。它会显示人们访问该网站的次数。</p><p id="78d4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将做得更好一点，将每次访问的信息存储到数据库中。当我们构建的服务器收到请求时，它会获得请求者的一定数量的信息。我们可以将它存储在数据库中，然后在主屏幕上，我们将它显示为一行文本。我们将使用的数据库是 MongoDB。我不想把它安装在我的笔记本电脑上，因为我使用许多不同的数据库，我不想把它们都安装好，所以我将使用一个预构建的映像，在一个名为 Kubernetes 的容器编排服务中运行 MongoDB 和我们的应用程序。</p><h2 id="cd4e" class="md me iq bd ml mm mn dn mo mp mq dp mr lf ms mt mu lj mv mw mx ln my mz na nb bi translated">设置 Kubernetes</h2><p id="fbd1" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">为了在我们的笔记本电脑上运行 Kubernetes，我们必须启用它。再次右键单击 Docker 图标并选择“首选项”。首先，让我们给 Docker 多一点内存，在“资源”选项卡上，将内存提升到 4g(除非您的机器只有 4g，在这种情况下，请保持为 2，并期待最好的结果)。如果你的电脑有 16 千兆字节的内存，你甚至可以把它提升到 6 千兆字节。记忆是机器中的润滑油；它的内存越大，性能就越好。如果您进行了更改，请单击“应用并重新启动”。</p><p id="cc9a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦 Docker 图标停止活动，右键单击并再次选择“首选项”。这次选择 Kubernetes 选项卡，选择“启用 Kubernetes”复选框，并再次单击“应用并重启”。它会在页面上停留一段时间，直到 Kubernetes 启动并运行。</p><p id="8b6d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦 Kubernetes 启动，回到您的终端，您将有一个新的命令可用。这几乎是 Kubernetes 使用的唯一命令，但是它的子命令比您想知道的还要多。但是我们先从一个很常见的开始:</p><pre class="kg kh ki kj gt lz lv ma mb aw mc bi"><span id="afe4" class="md me iq lv b gy mf mg l mh mi">Fuji:myfirstrepository randalkamradt$ kubectl get all<br/>NAME                 TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE<br/>service/kubernetes   ClusterIP   10.96.0.1    &lt;none&gt;        443/TCP   4m17s</span></pre><p id="881c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">kubectl get all</code>命令将返回 Kubernetes 集群中运行的所有非系统内容。现在，所有正在运行的都是<code class="fe ls lt lu lv b">kubectl</code>命令用来访问 Kubernetes 的服务。</p><p id="af06" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我将创建一个描述文件，Kubernetes 将使用它来启动应用程序。我通常不会在代码所在的位置创建描述文件，但是在这种情况下，我会保持简单。回到 Atom 编辑器，右键单击<code class="fe ls lt lu lv b">myfirstrepository</code>文件夹并选择“添加文件”。将文件命名为<code class="fe ls lt lu lv b">myfirstrepository.yaml</code>。一个<code class="fe ls lt lu lv b">yaml</code>文件是对文件格式的最新狂热，类似于<code class="fe ls lt lu lv b">json</code>，但是没有花括号。它依靠缩进来跟踪块，所以要密切注意每一行的缩进。您可以将以下内容添加到我们刚刚创建的<code class="fe ls lt lu lv b">myfirstrepository.yaml</code>中，用您的 DockerHub 用户名替换<code class="fe ls lt lu lv b">&lt;dhusername&gt;</code>。</p><pre class="kg kh ki kj gt lz lv ma mb aw mc bi"><span id="5a53" class="md me iq lv b gy mf mg l mh mi">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: myfirstrepository-deployment<br/>  labels:<br/>    app: myfirstrepository<br/>spec:<br/>  selector:<br/>    matchLabels:<br/>      app: myfirstrepository<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: myfirstrepository<br/>    spec:<br/>      containers:<br/>      - name: myfirstrepository<br/>        image: docker.io/&lt;dhusername&gt;/myfirstrepository:latest<br/>        ports:<br/>        - containerPort: 3000<br/>---<br/>apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: myfirstrepository-service<br/>spec:<br/>  type: LoadBalancer<br/>  selector:<br/>    app: myfirstrepository<br/>  ports:<br/>  - port: 80<br/>    targetPort: 3000</span></pre><p id="a4cb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是很多！但基本上它说，‘创建我的应用程序的一个实例，并在端口 80 上公开它(确保你的计算机没有在端口 80 上提供其他服务)。现在，我们可以使用以下命令启动它:</p><p id="0efa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">kubectl apply -f myfirstrepository.yaml</code></p><p id="de70" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，如果我们运行<code class="fe ls lt lu lv b">kubectl get all</code>，我们应该会看到更多的东西:</p><pre class="kg kh ki kj gt lz lv ma mb aw mc bi"><span id="0522" class="md me iq lv b gy mf mg l mh mi">Fuji:myfirstrepository randalkamradt$ kubectl get all<br/>NAME                                               READY   STATUS    RESTARTS   AGE<br/>pod/myfirstrepository-deployment-8f4579fc6-wczt6   1/1     Running   0          6m40s</span><span id="0a28" class="md me iq lv b gy mj mg l mh mi">NAME                                TYPE           CLUSTER-IP      EXTERNAL-IP   PORT(S)        AGE<br/>service/kubernetes                  ClusterIP      10.96.0.1       &lt;none&gt;        443/TCP        27m<br/>service/myfirstrepository-service   LoadBalancer   10.103.94.152   localhost     80:30609/TCP   6m40s</span><span id="402e" class="md me iq lv b gy mj mg l mh mi">NAME                                           READY   UP-TO-DATE   AVAILABLE   AGE<br/>deployment.apps/myfirstrepository-deployment   1/1     1            1           6m40s</span><span id="8567" class="md me iq lv b gy mj mg l mh mi">NAME                                                     DESIRED   CURRENT   READY   AGE<br/>replicaset.apps/myfirstrepository-deployment-8f4579fc6   1         1         1       6m40s</span></pre><p id="1f46" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们真正感兴趣的是<code class="fe ls lt lu lv b">service/myfirstrepository-service</code>系列。<code class="fe ls lt lu lv b">EXTERNAL-IP</code>应该是<code class="fe ls lt lu lv b">localhost</code>是这台电脑的简写。如果这个 Kubernetes 集群来自云提供商，它会给你一个真实的 IP 地址，世界上任何人都可以访问。要了解更多信息，请参阅我的文章“拥抱云”，因为现在只有你能看到它，但它离在互联网上公开只有一步之遥。要访问您的新服务，请浏览到<a class="ae kv" href="http://localhost" rel="noopener ugc nofollow" target="_blank"> http://localhost </a>(注意，因为它是 http 协议的默认端口 80，所以不需要在主机名后面添加端口号)。该网站应该看起来一样。</p><h2 id="05a8" class="md me iq bd ml mm mn dn mo mp mq dp mr lf ms mt mu lj mv mw mx ln my mz na nb bi translated">使用 MongoDB</h2><p id="4677" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">我答应了数据库，所以现在我要交付。将所有请求参数插入数据库并在主屏幕上列出它们需要对代码进行一些更改。但是首先，让我们添加对 MongoDB 驱动程序的依赖。</p><pre class="kg kh ki kj gt lz lv ma mb aw mc bi"><span id="ec21" class="md me iq lv b gy mf mg l mh mi">npm install mongodb</span></pre><p id="790a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这将 MongoDB 驱动程序添加到该应用程序所需的依赖项列表中。现在让我们添加一个新文件来设置 MongoDB，并公开一些简单的方法。回到 Atom 编辑器，右键单击<code class="fe ls lt lu lv b">myfirstrepository</code>文件夹，选择“新建文件”，并将文件命名为<code class="fe ls lt lu lv b">mongoservice.js</code>。我会一点一点地检查这份文件。第一部分是设置常量值的部分:</p><pre class="kg kh ki kj gt lz lv ma mb aw mc bi"><span id="3233" class="md me iq lv b gy mf mg l mh mi">const MongoClient = require('mongodb').MongoClient</span><span id="e30e" class="md me iq lv b gy mj mg l mh mi">const MONGO_USER = process.env.MONGO_USER<br/>const MONGO_PASS = process.env.MONGO_PASS<br/>const MONGO_SERVER = process.env.MONGO_SERVER || 'mongodb'<br/>const MONGO_PORT = process.env.MONGO_PORT || 27017</span><span id="1fda" class="md me iq lv b gy mj mg l mh mi">const dbName = 'requests'</span><span id="8c59" class="md me iq lv b gy mj mg l mh mi">const mongourl = `mongodb://${MONGO_USER}:${MONGO_PASS}@${MONGO_SERVER}:${MONGO_PORT}`;<br/>const client = new MongoClient(mongourl, {<br/>  useUnifiedTopology: true<br/>})</span></pre><p id="7715" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个部分导入<code class="fe ls lt lu lv b">mongodb</code>驱动程序并将其分配给<code class="fe ls lt lu lv b">MongoClient</code>。然后，它从环境中设置一些常量，如用户名和密码。MongoDB 主机和端口被默认为合理的值，但是它们也可以被环境覆盖。<code class="fe ls lt lu lv b">mongourl</code>构建了访问 MongoDB 的 URL，最后，我们创建了一个<code class="fe ls lt lu lv b">client</code>，稍后我们将连接到它。</p><p id="3edb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来是一个初始化方法，我们将向外部模块公开它:</p><pre class="kg kh ki kj gt lz lv ma mb aw mc bi"><span id="b126" class="md me iq lv b gy mf mg l mh mi">module.exports.initialize = async () =&gt; {<br/>  try {<br/>    await client.connect()<br/>    console.log('Connected correctly to server')<br/>  } catch (err) {<br/>    console.log(err.stack);<br/>  }<br/>}</span></pre><p id="68e4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">module.exports.initialize</code>常量意味着我们可以从其他 JavaScript 文件中访问这个方法。这就是 Node.js 允许我们构建模块化应用程序的方式。<code class="fe ls lt lu lv b">initialize</code>方法是一个<code class="fe ls lt lu lv b">async</code>方法，这意味着我们可以使用<code class="fe ls lt lu lv b">await</code>关键字来消除回调。如果你以前从未用 JavaScript 或 Node.js 编程，你可以认为自己是幸运的，回调是开发人员存在的祸根，现在几乎完全消除了。<code class="fe ls lt lu lv b">await</code>关键字允许我们以更自然的“先做这个再做那个”的风格编写代码，但仍然受益于 Node.js 的非阻塞、单线程方法。在<code class="fe ls lt lu lv b">initialize</code>方法中，我们简单地连接到 MongoDB 客户端。</p><p id="5da1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来的两个部分称为中间件，它们是 Express.js 库能够被轻松扩展的原因。第一种中间件方法将拦截所有请求，并将关于请求的数据插入数据库:</p><pre class="kg kh ki kj gt lz lv ma mb aw mc bi"><span id="718e" class="md me iq lv b gy mf mg l mh mi">module.exports.saveRequestAsync = async (req, res, next) =&gt; {<br/>  try {<br/>    const db = client.db(dbName)</span><span id="4713" class="md me iq lv b gy mj mg l mh mi">    const r = await db.collection('inserts').insertOne({<br/>        'verb': req.method,<br/>        'host': req.host,<br/>        'path': req.path<br/>      }, {<br/>        w: 'majority',<br/>        wtimeout: 10000,<br/>        serializeFunctions: true,<br/>        forceServerObjectId: true<br/>      }<br/>    )<br/>    console.log('Inserted')<br/>  } catch (err) {<br/>    console.log(err.stack)<br/>  }</span><span id="7c20" class="md me iq lv b gy mj mg l mh mi">  next()<br/>}</span></pre><p id="f37f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">同样，我们使用<code class="fe ls lt lu lv b">module.exports.saveRequestAsync</code>来允许其他文件访问这个方法。在其中，我们收集请求方法(通常是 GET)、请求主机和请求路径，并将它们存储在数据库中。中间件总是要求你在最后调用传入的<code class="fe ls lt lu lv b">next</code>方法来继续请求处理链。</p><p id="2da3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们有一个中间件，它将读取数据库，并将所有请求列表添加到一个名为<code class="fe ls lt lu lv b">list</code>的新请求字段中，稍后可以访问这个字段:</p><pre class="kg kh ki kj gt lz lv ma mb aw mc bi"><span id="3ab6" class="md me iq lv b gy mf mg l mh mi">module.exports.addListToRequest = async (req,res,next) =&gt; {<br/>  try {<br/>    const db = client.db(dbName)</span><span id="62e1" class="md me iq lv b gy mj mg l mh mi">    req.list = await db.collection('inserts').find({}).toArray();<br/>  } catch (err) {<br/>    console.log(err.stack)<br/>  }<br/>  next()<br/>}</span></pre><p id="dad8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以现在，我们有三个可以被其他模块访问的方法。我们把它们都放在哪里？前两个，<code class="fe ls lt lu lv b">initialize</code>和<code class="fe ls lt lu lv b">saveRequestAsync</code>将被添加到<code class="fe ls lt lu lv b">app.js</code>文件中:</p><pre class="kg kh ki kj gt lz lv ma mb aw mc bi"><span id="7b1a" class="md me iq lv b gy mf mg l mh mi">var createError = require('http-errors');<br/>var express = require('express');<br/>var path = require('path');<br/>var cookieParser = require('cookie-parser');<br/>var logger = require('morgan');<br/>var mongoservice = require('./mongoservice')</span><span id="3258" class="md me iq lv b gy mj mg l mh mi">var indexRouter = require('./routes/index');<br/>var usersRouter = require('./routes/users');</span><span id="3274" class="md me iq lv b gy mj mg l mh mi">mongoservice.initialize();</span><span id="be1d" class="md me iq lv b gy mj mg l mh mi">var app = express();</span><span id="bf3f" class="md me iq lv b gy mj mg l mh mi">// view engine setup<br/>app.set('views', path.join(__dirname, 'views'));<br/>app.set('view engine', 'jade');</span><span id="7e06" class="md me iq lv b gy mj mg l mh mi">app.use(logger('dev'));<br/>app.use(express.json());<br/>app.use(express.urlencoded({ extended: false }));<br/>app.use(cookieParser());<br/>app.use(mongoservice.saveRequestAsync);<br/>app.use(express.static(path.join(__dirname, 'public')));</span><span id="666d" class="md me iq lv b gy mj mg l mh mi">app.use('/', indexRouter);<br/>app.use('/users', usersRouter);</span><span id="b2ed" class="md me iq lv b gy mj mg l mh mi">// catch 404 and forward to error handler<br/>app.use(function(req, res, next) {<br/>  next(createError(404));<br/>});</span><span id="fc93" class="md me iq lv b gy mj mg l mh mi">// error handler<br/>app.use(function(err, req, res, next) {<br/>  // set locals, only providing error in development<br/>  res.locals.message = err.message;<br/>  res.locals.error = req.app.get('env') === 'development' ? err : {};</span><span id="451f" class="md me iq lv b gy mj mg l mh mi">// render the error page<br/>  res.status(err.status || 500);<br/>  res.render('error');<br/>});</span><span id="c8cf" class="md me iq lv b gy mj mg l mh mi">module.exports = app;</span></pre><p id="efef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">还有三行:</p><pre class="kg kh ki kj gt lz lv ma mb aw mc bi"><span id="088f" class="md me iq lv b gy mf mg l mh mi">var mongoservice = require('./mongoservice')</span></pre><p id="0236" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这用于加载 mongoservices.js 并将模块导出分配给变量<code class="fe ls lt lu lv b">mongoservice</code>，我们稍后可以使用该变量:</p><pre class="kg kh ki kj gt lz lv ma mb aw mc bi"><span id="abbe" class="md me iq lv b gy mf mg l mh mi">mongoservice.initialize();</span></pre><p id="d4b3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这将在早期显式调用<code class="fe ls lt lu lv b">initialize</code>方法，以确保我们可以连接到 MongoDB 数据库。请注意，我们从不断开连接，因为服务器是长期运行的程序，不会被有意停止。可能有一种方法可以很好地关闭所有的东西，但是对于我们的目的来说，让它正常关闭似乎效果很好。</p><p id="60da" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们将把方法<code class="fe ls lt lu lv b">saveRequestAsync</code>插入到处理链中，就在 cookie 处理之后:</p><pre class="kg kh ki kj gt lz lv ma mb aw mc bi"><span id="88c8" class="md me iq lv b gy mf mg l mh mi">app.use(mongoservice.saveRequestAsync);</span></pre><p id="85e9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这告诉 express 无论何时我们得到一个请求，调用这个方法。</p><p id="45ed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">公开的最后一个方法是<code class="fe ls lt lu lv b">addListToRequest</code>，它将用于在主页的浏览器中呈现列表。为此，我们需要两个文件之间的协调，<code class="fe ls lt lu lv b">routes/index.js</code>和<code class="fe ls lt lu lv b">views/index.jade</code>。在<code class="fe ls lt lu lv b">routes/index.js</code>中，我们将插入<code class="fe ls lt lu lv b">addListToRequest</code>作为请求中间件:</p><pre class="kg kh ki kj gt lz lv ma mb aw mc bi"><span id="e071" class="md me iq lv b gy mf mg l mh mi">var express = require('express');<br/>var router = express.Router();<br/>var mongoservice = require('../mongoservice')</span><span id="c2b8" class="md me iq lv b gy mj mg l mh mi">/* GET home page. */<br/>router.get('/', mongoservice.addListToRequest, (req,res) =&gt; {<br/>  res.render('index', {<br/>    title: 'My awesome server!',<br/>    list: req.list<br/>  });<br/>});</span><span id="96a2" class="md me iq lv b gy mj mg l mh mi">module.exports = router;</span></pre><p id="b72c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将它添加为<code class="fe ls lt lu lv b">router.get</code>方法的第二个参数。这意味着它将在实际处理作为最后一个参数的请求之前被调用。我们还需要将<code class="fe ls lt lu lv b">list</code>字段添加到传递给渲染引擎的对象中，在这里<code class="fe ls lt lu lv b">views/index.jade</code>文件可以看到它:</p><pre class="kg kh ki kj gt lz lv ma mb aw mc bi"><span id="0156" class="md me iq lv b gy mf mg l mh mi">extends layout</span><span id="ea46" class="md me iq lv b gy mj mg l mh mi">block content<br/>  h1= title<br/>  p Welcome to #{title}<br/>  ul<br/>    each val in list<br/>      li= JSON.stringify(val)</span></pre><p id="f68e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后三行创建一个无序列表<code class="fe ls lt lu lv b">&lt;ul&gt;</code>，然后将我们通过<code class="fe ls lt lu lv b">routes/index.js</code>传入的列表中的每个值放入一个列表项标签<code class="fe ls lt lu lv b">&lt;li&gt;</code>。这些就是我们需要做的所有代码更改。</p><h2 id="c5da" class="md me iq bd ml mm mn dn mo mp mq dp mr lf ms mt mu lj mv mw mx ln my mz na nb bi translated">一起运行它</h2><p id="6cc8" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">为了一起运行所有的东西，必须进行一些协调。我们需要保留一个<code class="fe ls lt lu lv b">secret</code>来保存 MongoDB 数据库的凭证。然后我们可以在 MongoDB 服务和应用程序服务的描述中使用这个秘密。它看起来是这样的:</p><pre class="kg kh ki kj gt lz lv ma mb aw mc bi"><span id="6213" class="md me iq lv b gy mf mg l mh mi">kubectl create secret generic mongo-secret \<br/>    --from-literal=username=mongo \<br/>    --from-literal=password=ognom</span></pre><p id="8f4e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">显然，选择一个更好的密码。</p><p id="ab13" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们需要为 MongoDB 服务创建一个描述。这将看起来非常类似于我们为我们的应用程序想出的描述。在名为<code class="fe ls lt lu lv b">mongodb.yaml</code>的<code class="fe ls lt lu lv b">myfirstrepository</code>文件夹中创建一个新文件，并添加以下内容:</p><pre class="kg kh ki kj gt lz lv ma mb aw mc bi"><span id="9eb6" class="md me iq lv b gy mf mg l mh mi">apiVersion: apps/v1<br/>kind: StatefulSet<br/>metadata:<br/>  name: mongodb<br/>spec:<br/>  serviceName: "mongodb"<br/>  replicas: 1<br/>  selector:<br/>    matchLabels:<br/>      app: mongodb<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: mongodb<br/>        selector: mongodb<br/>    spec:<br/>      containers:<br/>      - name: mongodb<br/>        image: mongo:4.0.8<br/>        env:<br/>          - name: MONGO_INITDB_ROOT_USERNAME<br/>            valueFrom:<br/>              secretKeyRef:<br/>                name: mongo-secret<br/>                key: username<br/>          - name: MONGO_INITDB_ROOT_PASSWORD<br/>            valueFrom:<br/>              secretKeyRef:<br/>                name: mongo-secret<br/>                key: password<br/>---<br/>apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: mongodb<br/>  labels:<br/>    name: mongodb<br/>spec:<br/>  ports:<br/>  - port: 27017<br/>    targetPort: 27017<br/>  clusterIP: None<br/>  selector:<br/>    app: mongodb</span></pre><p id="967e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意我们是如何根据刚刚创建的密码为用户名和密码设置环境变量的。现在，我们可以使用以下命令启动它:</p><pre class="kg kh ki kj gt lz lv ma mb aw mc bi"><span id="8ccb" class="md me iq lv b gy mf mg l mh mi">kubectl apply -f mongodb.yaml</span></pre><p id="708f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">运行<code class="fe ls lt lu lv b">kubectl get all</code>命令，直到<code class="fe ls lt lu lv b">mongodb-0</code> pod 启动并运行。</p><p id="61be" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">关于故障排除的快速说明。如果您发现事情没有按预期进行，您可以使用两个命令<code class="fe ls lt lu lv b">kubectl describe pod &lt;pod-name&gt;</code>和<code class="fe ls lt lu lv b">kubectl logs &lt;pod-name&gt;</code>,这些命令是您将在大多数时间使用的，以查看 pod 出现了什么问题。您可以使用<code class="fe ls lt lu lv b">kubectl get pods</code>命令找到 pod 名称，正常的 pod 会附加两个随机字符串。MongoDB pod 不正常，所以它被附加了一个<code class="fe ls lt lu lv b">-0</code>。习惯在终端中使用剪切和粘贴是一个好主意，这样您就不必键入 log pod 名称。</p><p id="3b87" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们还需要添加从应用程序访问 MongoDB 的环境变量。修改你的<code class="fe ls lt lu lv b">myfirstrepository.yaml</code>,使它看起来像这样:</p><pre class="kg kh ki kj gt lz lv ma mb aw mc bi"><span id="09fe" class="md me iq lv b gy mf mg l mh mi">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: myfirstrepository-deployment<br/>  labels:<br/>    app: myfirstrepository<br/>spec:<br/>  selector:<br/>    matchLabels:<br/>      app: myfirstrepository<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: myfirstrepository<br/>    spec:<br/>      containers:<br/>      - name: myfirstrepository<br/>        image: docker.io/&lt;dhusername&gt;/myfirstrepository:latest<br/>        ports:<br/>        - containerPort: 3000<br/>        env:<br/>          - name: MONGO_USER<br/>            valueFrom:<br/>              secretKeyRef:<br/>                name: mongo-secret<br/>                key: username<br/>          - name: MONGO_PASS<br/>            valueFrom:<br/>              secretKeyRef:<br/>                name: mongo-secret<br/>                key: password<br/>---<br/>apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: myfirstrepository-service<br/>spec:<br/>  type: LoadBalancer<br/>  selector:<br/>    app: myfirstrepository<br/>  ports:<br/>  - port: 80<br/>    targetPort: 3000</span></pre><p id="976a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在用<code class="fe ls lt lu lv b">kubectl apply -f myfirstrepository.yaml</code>启动它。现在您可以浏览到<a class="ae kv" href="http://local" rel="noopener ugc nofollow" target="_blank"> http://local </a> host，您应该会看到类似这样的内容:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nh"><img src="../Images/6fe8cf4b2dfdea4b1daf3ae3b38ade06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MNu3gLLOnAh-f5DQbIH3SA.png"/></div></div></figure><p id="5e59" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">“_id”是 MongoDB 为您添加的一个值，如果您没有标识一个键值的话。点击刷新按钮，您应该会得到几行:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ni"><img src="../Images/e3fd19d1609a5f303d8a3585818e43b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y9z9s3eaEova6Mj4u8rq7w.png"/></div></div></figure><p id="cdf0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意，除了对<code class="fe ls lt lu lv b">/</code>的请求之外，还有对<code class="fe ls lt lu lv b">/stylesheets/style.css</code>的请求。浏览器会要求这样做，因为它在返回的 HTML 中被引用。但是它没有出现在第一个屏幕上，因为在呈现 HTML 之前没有请求它。</p><p id="0ab1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是一次非常漫长的旅程。如果你设法坚持到了最后，祝贺你自己；你刚刚跳过了许多还没有学会使用容器的有经验的开发人员。诚然，它非常复杂，在我们所处的阶段回报很少，但它为我们打开了一个新的世界。</p><p id="2a7a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">和我的上一篇文章《绝对初学者的应用程序编程》一样，这篇文章中没有太多的代码。任何像样的应用程序，90%的代码都应该在别人写的库中。尽管你可能擅长编程，但编写你所听说的流行库的人可能是更好的开发人员。您应该做的就是添加业务逻辑或任何其他使您的应用程序独一无二的魔法。对于您使用的任何语言和您需要的任何业务逻辑，您可能会找到一个不错的例子，您可以从互联网上的某个地方开始。</p><p id="df22" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本系列的下一篇文章中，我将介绍使用 Jenkins 的管道，它们都运行在 Kubernetes 上。在这个过程中，我还将讨论测试和分阶段部署。我希望你也加入进来，因为不管你用什么语言写作，也不管你从事什么行业，这些都将是你作为软件开发人员的整体工具箱的一部分。</p><p id="b480" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以在这里找到本文的所有代码:</p><div class="nj nk gp gr nl nm"><a href="https://github.com/rkamradt/myfirstrepository/tree/v0.0" rel="noopener  ugc nofollow" target="_blank"><div class="nn ab fo"><div class="no ab np cl cj nq"><h2 class="bd ir gy z fp nr fr fs ns fu fw ip bi translated">rkamradt/myfirstrepository</h2><div class="nt l"><h3 class="bd b gy z fp nr fr fs ns fu fw dk translated">我的第一个仓库。通过在 GitHub 上创建一个帐户，为 rkamradt/myfirstrepository 开发做出贡献。</h3></div><div class="nu l"><p class="bd b dl z fp nr fr fs ns fu fw dk translated">github.com</p></div></div><div class="nv l"><div class="nw l nx ny nz nv oa kp nm"/></div></div></a></div><p id="2700" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意，在最初的文章中，代码库位于我专门为那篇文章创建的用户名下，以便更好地描述如何自己设置 GitHub。从那以后，我把它“分”到了我常用的 GitHub 账户上，并将继续在此基础上进行开发。</p><p id="7129" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是本系列的前一篇文章</p><div class="nj nk gp gr nl nm"><a href="https://medium.com/dev-genius/application-programming-for-absolute-beginners-bf2a035efdf6" rel="noopener follow" target="_blank"><div class="nn ab fo"><div class="no ab np cl cj nq"><h2 class="bd ir gy z fp nr fr fs ns fu fw ip bi translated">绝对初学者的应用程序设计</h2><div class="nt l"><h3 class="bd b gy z fp nr fr fs ns fu fw dk translated">如何将您的普通 Mac 笔记本电脑变成一个疯狂的开发怪物</h3></div><div class="nu l"><p class="bd b dl z fp nr fr fs ns fu fw dk translated">medium.com</p></div></div><div class="nv l"><div class="ob l nx ny nz nv oa kp nm"/></div></div></a></div><p id="cfcb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里有一些文章可能会对你继续学习有用。</p><div class="nj nk gp gr nl nm"><a href="https://levelup.gitconnected.com/how-to-use-kubernetes-cron-jobs-to-periodically-read-the-news-8b3b4513f8b7" rel="noopener  ugc nofollow" target="_blank"><div class="nn ab fo"><div class="no ab np cl cj nq"><h2 class="bd ir gy z fp nr fr fs ns fu fw ip bi translated">如何使用 Kubernetes Cron Jobs 定期阅读新闻</h2><div class="nt l"><h3 class="bd b gy z fp nr fr fs ns fu fw dk translated">阅读新闻的微服务。</h3></div><div class="nu l"><p class="bd b dl z fp nr fr fs ns fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="nv l"><div class="oc l nx ny nz nv oa kp nm"/></div></div></a></div><div class="nj nk gp gr nl nm"><a href="https://levelup.gitconnected.com/making-golang-go-43c800b4b754" rel="noopener  ugc nofollow" target="_blank"><div class="nn ab fo"><div class="no ab np cl cj nq"><h2 class="bd ir gy z fp nr fr fs ns fu fw ip bi translated">让 Golang 前进</h2><div class="nt l"><h3 class="bd b gy z fp nr fr fs ns fu fw dk translated">学习新语言的冒险经历</h3></div><div class="nu l"><p class="bd b dl z fp nr fr fs ns fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="nv l"><div class="od l nx ny nz nv oa kp nm"/></div></div></a></div></div></div>    
</body>
</html>