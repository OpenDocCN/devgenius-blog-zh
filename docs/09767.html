<html>
<head>
<title>Python Up Your Code: Enumerations</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python Up 您的代码:枚举</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/python-up-your-code-enumerations-94eb79641d7e?source=collection_archive---------5-----------------------#2022-09-11">https://blog.devgenius.io/python-up-your-code-enumerations-94eb79641d7e?source=collection_archive---------5-----------------------#2022-09-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="75eb" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">枚举 Python 模块的简要概述</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/09c7f42934f39c3114547de6f8851835.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3L5LpzbcmJX4a8Hw6tYlzg.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@pietrozj?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">皮埃特罗·詹</a>在<a class="ae kv" href="https://unsplash.com/@pietrozj?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h2 id="9257" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">什么是编程中的枚举？</h2><p id="eac1" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">枚举只表示具有关联的唯一常数值的成员的集合。</p><h2 id="f741" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">我们为什么要使用枚举呢？</h2><p id="9d69" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">枚举是非常有用的，并且被用于将有限的和固定的状态或实体集合在一起，例如彩虹的颜色，或者一周中的几天，一年中的几个月，http 响应代码，以及可以继续列举的例子。总的来说，它极大地提高了我们代码的可读性和组织性，我们稍后会学到这一点。</p><h2 id="6a10" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">它是如何工作的？</h2><p id="f2b1" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">枚举是存在的，在很多编程语言中都可以找到:C、Java、JavaScript、TypeScript……Python 不会代表一个例外。由于它们的通用性，Python 为我们提供了<code class="fe ml mm mn mo b">enum</code>模块:</p><pre class="kg kh ki kj gt mp mo mq mr aw ms bi"><span id="c218" class="kw kx iq mo b gy mt mu l mv mw"><em class="mx"># import the module</em><strong class="mo ir"><br/>from </strong>enum<strong class="mo ir"> import</strong> Enum</span><span id="d57a" class="kw kx iq mo b gy my mu l mv mw"><em class="mx"><br/># define our enumeration<br/></em><strong class="mo ir">class</strong> Weekdays(Enum):<br/>    SUNDAY = 1<br/>    MONDAY = 2<br/>    TUESDAY = 3<br/>    WEDNESDAY = 4<br/>    THURSDAY = 5<br/>    FRIDAY = 6<br/>    SATURDAY = 7</span></pre><p id="197b" class="pw-post-body-paragraph ls lt iq lu b lv mz jr lx ly na ju ma lf nb mc md lj nc mf mg ln nd mi mj mk ij bi translated">这就是我们如何创建自己的枚举。我们所做的是创建了一个自己的类，它继承自<code class="fe ml mm mn mo b">Enum</code>。我们将我们的类命名为<code class="fe ml mm mn mo b">Weekdays</code>,以真正反映我们的枚举的全部内容。下一步是通过给每个成员分配一个常数来定义我们的成员。</p><p id="ec62" class="pw-post-body-paragraph ls lt iq lu b lv mz jr lx ly na ju ma lf nb mc md lj nc mf mg ln nd mi mj mk ij bi translated">说到这里，我想简单地与您分享一个细节:请注意定义这些成员的大写样式:因为它们是常量——就我而言，我不认为我们所知道的典型的 7 天工作周会有任何变化——我们的工作日应该使用大写命名样式命名。然而，必须指出的是，仅仅因为我们创建了一个大写的变量，并不意味着我们已经有效地把它变成了一个常量，就像我们在 C ( <code class="fe ml mm mn mo b">const int a = 2;</code>)中所做的那样。在 Python 中可以很容易地更改它的值:</p><pre class="kg kh ki kj gt mp mo mq mr aw ms bi"><span id="43cc" class="kw kx iq mo b gy mt mu l mv mw">MY_CONSTANT = 5<br/><strong class="mo ir">print</strong>(MY_CONSTANT)<br/>MY_CONSTANT = 10<br/><strong class="mo ir">print</strong>(MY_CONSTANT)</span><span id="8eed" class="kw kx iq mo b gy my mu l mv mw">Output:<br/>5<br/>10</span></pre><p id="8f18" class="pw-post-body-paragraph ls lt iq lu b lv mz jr lx ly na ju ma lf nb mc md lj nc mf mg ln nd mi mj mk ij bi translated">那是因为 Python 的<strong class="lu ir">没有</strong>有常量。只有一个变量的<strong class="lu ir">约定</strong>被认为是常量，这表明我们应该通过使用 UPPER_CASE 命名方式来标记我们认为<strong class="lu ir">是常量</strong>的变量。你可以在网上了解更多，这里是一个好的起点<a class="ae kv" href="https://peps.python.org/pep-0008/#constants" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="4c11" class="pw-post-body-paragraph ls lt iq lu b lv mz jr lx ly na ju ma lf nb mc md lj nc mf mg ln nd mi mj mk ij bi translated">相反，Python 所拥有的是由对象的可变/不可变属性来表示的(我们是否可以在不改变对象本身的情况下改变对象的值？).</p><p id="2590" class="pw-post-body-paragraph ls lt iq lu b lv mz jr lx ly na ju ma lf nb mc md lj nc mf mg ln nd mi mj mk ij bi translated">但是，无论如何，回到我们最初的范围，我们已经成功地定义了我们自己的枚举，表示一周中的每一天，每一天都有一个固定的数值分配给它。由于我的<em class="mx">Python 中的常量</em>离题，我将再次展示代码，以避免您不必要地来回滚动。所以，正如我所说的:</p><pre class="kg kh ki kj gt mp mo mq mr aw ms bi"><span id="a394" class="kw kx iq mo b gy mt mu l mv mw"><em class="mx"># import the module</em><strong class="mo ir"><br/>from </strong>enum<strong class="mo ir"> import</strong> Enum</span><span id="25c5" class="kw kx iq mo b gy my mu l mv mw"><em class="mx"><br/># define our enumeration<br/></em><strong class="mo ir">class</strong> Weekdays(Enum):<br/>    SUNDAY = 1<br/>    MONDAY = 2<br/>    TUESDAY = 3<br/>    WEDNESDAY = 4<br/>    THURSDAY = 5<br/>    FRIDAY = 6<br/>    SATURDAY = 7</span></pre><p id="c6f2" class="pw-post-body-paragraph ls lt iq lu b lv mz jr lx ly na ju ma lf nb mc md lj nc mf mg ln nd mi mj mk ij bi translated">现在，让我们看看访问该枚举成员的几种方法:</p><pre class="kg kh ki kj gt mp mo mq mr aw ms bi"><span id="f321" class="kw kx iq mo b gy mt mu l mv mw"><em class="mx"># set a variable to an enum member</em><br/>my_day = Days.MONDAY</span><span id="49eb" class="kw kx iq mo b gy my mu l mv mw"><em class="mx"># the type of the enum member</em><strong class="mo ir"><br/>print</strong>(<strong class="mo ir">type</strong>(my_day))</span><span id="28bf" class="kw kx iq mo b gy my mu l mv mw"><em class="mx"># the enum member as string</em><strong class="mo ir"><br/>print</strong>(my_day)</span><span id="0291" class="kw kx iq mo b gy my mu l mv mw"><em class="mx"># the "name" attribute of the enum member</em><strong class="mo ir"><br/>print</strong>(my_day.<strong class="mo ir">name</strong>)</span><span id="ba66" class="kw kx iq mo b gy my mu l mv mw"><em class="mx"># the "value" attribute of the enum member</em><strong class="mo ir"><br/>print</strong>(my_day.<strong class="mo ir">value</strong>)</span><span id="c183" class="kw kx iq mo b gy my mu l mv mw"><em class="mx"># the representational string of the enum member</em><strong class="mo ir"><br/>print</strong>(<strong class="mo ir">repr</strong>(my_day))</span><span id="d7a6" class="kw kx iq mo b gy my mu l mv mw">Output:<br/>&lt;enum 'Days'&gt;<br/>Days.MONDAY<br/>MONDAY<br/>2<br/>&lt;Days.MONDAY: 2&gt;</span></pre><p id="c2b1" class="pw-post-body-paragraph ls lt iq lu b lv mz jr lx ly na ju ma lf nb mc md lj nc mf mg ln nd mi mj mk ij bi translated">我们可以在比较和标识测试表达式中使用枚举成员，分别使用相等和标识运算符:</p><pre class="kg kh ki kj gt mp mo mq mr aw ms bi"><span id="17ed" class="kw kx iq mo b gy mt mu l mv mw"><em class="mx"># import the module</em><strong class="mo ir"><br/>from </strong>enum<strong class="mo ir"> import</strong> Enum</span><span id="48a9" class="kw kx iq mo b gy my mu l mv mw"><em class="mx"># define our enumeration<br/></em><strong class="mo ir">class</strong> Weekdays(Enum):<br/>    SUNDAY = 1<br/>    MONDAY = 2<br/>    TUESDAY = 3<br/>    WEDNESDAY = 4<br/>    THURSDAY = 5<br/>    FRIDAY = 6<br/>    SATURDAY = 7</span><span id="41bf" class="kw kx iq mo b gy my mu l mv mw"><strong class="mo ir">if</strong> Weekdays.SUNDAY != Weekdays.TUESDAY:<br/>    <strong class="mo ir">print</strong>("Sunday and Tuesday are two different days.")<br/><strong class="mo ir">else</strong>:<br/>    <strong class="mo ir">print</strong>("Sunday and Tuesday are all the same to me.")</span><span id="478e" class="kw kx iq mo b gy my mu l mv mw"><strong class="mo ir">if</strong> Weekdays.SUNDAY <strong class="mo ir">is</strong> <strong class="mo ir">not</strong> Weekdays.TUESDAY:<br/>    <strong class="mo ir">print</strong>("Sunday and Tuesday are two different days.")<br/><strong class="mo ir">else</strong>:<br/>    <strong class="mo ir">print</strong>("Sunday is Tuesday. Don't ask me why.")</span><span id="53bf" class="kw kx iq mo b gy my mu l mv mw"><strong class="mo ir">if</strong> Weekdays.THURSDAY <strong class="mo ir">is</strong> Weekdays(5):<br/>    <strong class="mo ir">print</strong>("Thursday's assigned number is indeed 5.")<br/><strong class="mo ir">else</strong>:<br/>    <strong class="mo ir">print</strong>("Wrong number :)")</span><span id="aa4d" class="kw kx iq mo b gy my mu l mv mw"><strong class="mo ir">if</strong> Weekdays(5) == Weekdays(5):<br/>    <strong class="mo ir">print</strong>("Thursday's assigned number is indeed 5.")<br/><strong class="mo ir">else</strong>:<br/>    <strong class="mo ir">print</strong>("Wrong number :)")</span><span id="ea66" class="kw kx iq mo b gy my mu l mv mw">Output:<br/>Sunday and Tuesday are two different days.<br/>Sunday and Tuesday are two different days.<br/>Thursday's assigned number is indeed 5.<br/>Thursday's assigned number is indeed 5.</span></pre><h2 id="762d" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">枚举是不可变的</h2><p id="b3e9" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">在 Python 中我们不能对枚举做的事情之一是:我们不能改变它的成员或它们的值。我们也不能在枚举中添加或删除成员。让我们看一些基于我们已经存在的<code class="fe ml mm mn mo b">Weekdays</code>枚举的例子:</p><ul class=""><li id="49b8" class="ne nf iq lu b lv mz ly na lf ng lj nh ln ni mk nj nk nl nm bi translated">试图通过访问其名称(<code class="fe ml mm mn mo b">FRIDAY</code>)来改变成员的值是不会成功的。一个<code class="fe ml mm mn mo b">TypeError</code>异常被抛出:</li></ul><pre class="kg kh ki kj gt mp mo mq mr aw ms bi"><span id="a67a" class="kw kx iq mo b gy mt mu l mv mw"><em class="mx"># import the module<br/></em><strong class="mo ir">from</strong> enum <strong class="mo ir">import</strong> Enum</span><span id="f46b" class="kw kx iq mo b gy my mu l mv mw"><em class="mx"># define our enumeration<br/></em><strong class="mo ir">class</strong> Weekdays(Enum):<br/>    SUNDAY = 1<br/>    MONDAY = 2<br/>    TUESDAY = 3<br/>    WEDNESDAY = 4<br/>    THURSDAY = 5<br/>    FRIDAY = 6<br/>    SATURDAY = 7</span><span id="c1a5" class="kw kx iq mo b gy my mu l mv mw"><em class="mx"># try to alter Friday's assigned number</em><br/>Weekdays["FRIDAY"] = -3</span><span id="263a" class="kw kx iq mo b gy my mu l mv mw">Output:<br/>Traceback (most recent call last):<br/>  ...<br/>    Weekdays["FRIDAY"] = -3<br/>TypeError: 'EnumMeta' object does not support item assignment</span></pre><ul class=""><li id="2ac1" class="ne nf iq lu b lv mz ly na lf ng lj nh ln ni mk nj nk nl nm bi translated">试图直接改变成员的值将导致抛出<code class="fe ml mm mn mo b">AttributeError</code>异常:</li></ul><pre class="kg kh ki kj gt mp mo mq mr aw ms bi"><span id="1242" class="kw kx iq mo b gy mt mu l mv mw"><em class="mx"># import the module<br/></em><strong class="mo ir">from</strong> enum <strong class="mo ir">import</strong> Enum</span><span id="2d8f" class="kw kx iq mo b gy my mu l mv mw"><em class="mx"># define our enumeration<br/></em><strong class="mo ir">class</strong> Weekdays(Enum):<br/>    SUNDAY = 1<br/>    MONDAY = 2<br/>    TUESDAY = 3<br/>    WEDNESDAY = 4<br/>    THURSDAY = 5<br/>    FRIDAY = 6<br/>    SATURDAY = 7</span><span id="237e" class="kw kx iq mo b gy my mu l mv mw"><em class="mx"># try to alter Saturday's assigned number</em><br/>Weekdays.SATURDAY.value = 8</span><span id="0ee4" class="kw kx iq mo b gy my mu l mv mw">Output:<br/>Traceback (most recent call last):<br/>  ...<br/>    Weekdays.SATURDAY.value = 8<br/>  ...<br/>    raise AttributeError("can't set attribute")<br/>AttributeError: can't set attribute</span></pre><ul class=""><li id="a7c8" class="ne nf iq lu b lv mz ly na lf ng lj nh ln ni mk nj nk nl nm bi translated">试图从枚举中删除一个元素会导致另一个<code class="fe ml mm mn mo b">TypeError</code>异常:</li></ul><pre class="kg kh ki kj gt mp mo mq mr aw ms bi"><span id="1194" class="kw kx iq mo b gy mt mu l mv mw"><em class="mx"># import the module<br/></em><strong class="mo ir">from</strong> enum <strong class="mo ir">import</strong> Enum</span><span id="82ca" class="kw kx iq mo b gy my mu l mv mw"><em class="mx"># define our enumeration<br/></em><strong class="mo ir">class</strong> Weekdays(Enum):<br/>    SUNDAY = 1<br/>    MONDAY = 2<br/>    TUESDAY = 3<br/>    WEDNESDAY = 4<br/>    THURSDAY = 5<br/>    FRIDAY = 6<br/>    SATURDAY = 7</span><span id="d92f" class="kw kx iq mo b gy my mu l mv mw"><em class="mx"># try to delete MONDAY<br/></em><strong class="mo ir">del</strong> Weekdays["MONDAY"]</span><span id="bdeb" class="kw kx iq mo b gy my mu l mv mw">Output:<br/>Traceback (most recent call last):<br/>  ...<br/>    del Weekdays["SATURDAY"]<br/>TypeError: 'EnumMeta' object does not support item deletion</span></pre><ul class=""><li id="5ac3" class="ne nf iq lu b lv mz ly na lf ng lj nh ln ni mk nj nk nl nm bi translated">尝试将成员添加到枚举中(这将引发与我们尝试改变现有成员时相同的错误):</li></ul><pre class="kg kh ki kj gt mp mo mq mr aw ms bi"><span id="31f4" class="kw kx iq mo b gy mt mu l mv mw"><em class="mx"># import the module<br/></em><strong class="mo ir">from</strong> enum <strong class="mo ir">import</strong> Enum</span><span id="7e23" class="kw kx iq mo b gy my mu l mv mw"><em class="mx"># define our enumeration<br/></em><strong class="mo ir">class</strong> Weekdays(Enum):<br/>    SUNDAY = 1<br/>    MONDAY = 2<br/>    TUESDAY = 3<br/>    WEDNESDAY = 4<br/>    THURSDAY = 5<br/>    FRIDAY = 6<br/>    SATURDAY = 7</span><span id="7306" class="kw kx iq mo b gy my mu l mv mw"><em class="mx"># try to add a member<br/></em>Weekdays["TEST"] = 16</span><span id="182c" class="kw kx iq mo b gy my mu l mv mw">Output:<br/>Traceback (most recent call last):<br/>  ...<br/>    Weekdays["TEST"] = 16<br/>TypeError: 'EnumMeta' object does not support item assignment</span></pre><h2 id="093e" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">枚举是可哈希的</h2><p id="fad4" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">这对我们来说意味着我们可以使用枚举——以及枚举成员——作为字典中的键，甚至是集合中的元素:</p><pre class="kg kh ki kj gt mp mo mq mr aw ms bi"><span id="b590" class="kw kx iq mo b gy mt mu l mv mw"><em class="mx"># import the module</em><br/><strong class="mo ir">from</strong> enum <strong class="mo ir">import</strong> Enum</span><span id="50e9" class="kw kx iq mo b gy my mu l mv mw"><strong class="mo ir">class</strong> Days(Enum):<br/>    SUNDAY = 1<br/>    MONDAY = 2<br/>    TUESDAY = 3<br/>    WEDNESDAY = 4<br/>    THURSDAY = 5<br/>    FRIDAY = 6<br/>    SATURDAY = 7</span><span id="3198" class="kw kx iq mo b gy my mu l mv mw">my_dict = {Days: "123", Days(4): "456"}<br/><strong class="mo ir">print</strong>(my_dict)</span><span id="d002" class="kw kx iq mo b gy my mu l mv mw">my_set = {Days, 5, Days(2)}<br/><strong class="mo ir">print</strong>(my_set)</span><span id="b82c" class="kw kx iq mo b gy my mu l mv mw">Output:<br/>{&lt;enum 'Days'&gt;: '123', &lt;Days.WEDNESDAY: 4&gt;: 'test_value'}<br/>{&lt;Days.MONDAY: 2&gt;, &lt;enum 'Days'&gt;, 5}</span></pre><p id="ebdc" class="pw-post-body-paragraph ls lt iq lu b lv mz jr lx ly na ju ma lf nb mc md lj nc mf mg ln nd mi mj mk ij bi translated">可以看出，Python 可以轻松地将枚举成员甚至整个枚举作为集合元素或字典键来处理。</p><h2 id="ec2e" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">填充的枚举是不可继承的</h2><p id="112a" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">枚举类还有一个特别的地方。我们不能从包含成员的枚举类继承:</p><pre class="kg kh ki kj gt mp mo mq mr aw ms bi"><span id="9ea7" class="kw kx iq mo b gy mt mu l mv mw"><em class="mx"># import the module<br/></em><strong class="mo ir">from</strong> enum <strong class="mo ir">import</strong> Enum</span><span id="dd33" class="kw kx iq mo b gy my mu l mv mw"><em class="mx"># define our working days enumeration<br/></em><strong class="mo ir">class</strong> WorkWeek(Enum):<br/>    MONDAY = 2<br/>    TUESDAY = 3<br/>    WEDNESDAY = 4<br/>    THURSDAY = 5</span><span id="748c" class="kw kx iq mo b gy my mu l mv mw"><em class="mx"># now build a full week class from it<br/></em><strong class="mo ir">class</strong> FullWeek(WorkWeek):<br/>    FRIDAY = 6<br/>    SATURDAY = 7<br/>    SUNDAY = 1</span><span id="c658" class="kw kx iq mo b gy my mu l mv mw">Output:<br/>Traceback (most recent call last):<br/>  ...<br/>    class FullWeek(WorkWeek):<br/>  ...<br/>    metacls._check_for_existing_members(cls, bases)<br/>  ...<br/>    raise TypeError(<br/>TypeError: FullWeek: cannot extend enumeration 'WorkWeek'</span></pre><p id="e4a9" class="pw-post-body-paragraph ls lt iq lu b lv mz jr lx ly na ju ma lf nb mc md lj nc mf mg ln nd mi mj mk ij bi translated">但是我们可以从枚举类继承，唯一的条件是它们不包含任何成员:</p><pre class="kg kh ki kj gt mp mo mq mr aw ms bi"><span id="4f90" class="kw kx iq mo b gy mt mu l mv mw"><em class="mx"># import the module<br/></em><strong class="mo ir">from</strong> enum <strong class="mo ir">import</strong> Enum</span><span id="bda7" class="kw kx iq mo b gy my mu l mv mw"><em class="mx"># define our enumeration<br/></em><strong class="mo ir">class</strong> Days(Enum):<br/>    <strong class="mo ir">pass</strong></span><span id="7461" class="kw kx iq mo b gy my mu l mv mw"><em class="mx"># extend the Days class with some weekend days<br/></em><strong class="mo ir">class</strong> Weekend(Days):<br/>    FRIDAY = 6<br/>    SATURDAY = 7<br/>    SUNDAY = 1</span><span id="7307" class="kw kx iq mo b gy my mu l mv mw"><strong class="mo ir">for</strong> item <strong class="mo ir">in</strong> Weekend:<br/>    <strong class="mo ir">print</strong>(item)</span><span id="7c7d" class="kw kx iq mo b gy my mu l mv mw">Output:<br/>Weekend.FRIDAY<br/>Weekend.SATURDAY<br/>Weekend.SUNDAY</span></pre><p id="ed9a" class="pw-post-body-paragraph ls lt iq lu b lv mz jr lx ly na ju ma lf nb mc md lj nc mf mg ln nd mi mj mk ij bi translated">这就是今天关于 Python 枚举的简短文章的内容。你可以在网上找到更多关于它们的信息，还有什么比官方的<a class="ae kv" href="https://docs.python.org/3/library/enum.html" rel="noopener ugc nofollow" target="_blank">文档</a>更好的起点呢？</p><p id="e415" class="pw-post-body-paragraph ls lt iq lu b lv mz jr lx ly na ju ma lf nb mc md lj nc mf mg ln nd mi mj mk ij bi translated">保重，身体健康，编码快乐！直到<a class="ae kv" href="https://medium.com/@deck451/python-up-your-code-hashing-b486adc4bf9" rel="noopener">下一次</a>！</p></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><p id="b474" class="pw-post-body-paragraph ls lt iq lu b lv mz jr lx ly na ju ma lf nb mc md lj nc mf mg ln nd mi mj mk ij bi translated"><em class="mx"> Deck 是软件工程师、导师、作家，有时甚至是老师。他拥有 12 年以上的软件工程经验，现在是 Python 编程语言的真正倡导者，同时他的热情是帮助人们提高他们的 Python(以及一般的编程)技能。你可以在</em> <a class="ae kv" href="https://www.linkedin.com/in/deck451/" rel="noopener ugc nofollow" target="_blank"> <em class="mx">【领英】</em></a><em class="mx"/><a class="ae kv" href="https://www.facebook.com/deck451/" rel="noopener ugc nofollow" target="_blank"><em class="mx">【脸书】</em></a><em class="mx"/><a class="ae kv" href="https://twitter.com/Deck45100" rel="noopener ugc nofollow" target="_blank"><em class="mx">推特</em></a><em class="mx"/><a class="ae kv" href="https://discord.com" rel="noopener ugc nofollow" target="_blank"><em class="mx">不和谐</em> </a> <em class="mx"> : Deck451#6188，以及跟随他写在这里的</em> <a class="ae kv" href="https://medium.com/@deck451" rel="noopener"> <em class="mx">中</em> </a> <em class="mx"/></p></div></div>    
</body>
</html>