<html>
<head>
<title>JavaScript Best Practices — React Components and Promises</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript 最佳实践—反应组件和承诺</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/javascript-best-practices-react-components-and-promises-6baad54a50d7?source=collection_archive---------3-----------------------#2020-08-18">https://blog.devgenius.io/javascript-best-practices-react-components-and-promises-6baad54a50d7?source=collection_archive---------3-----------------------#2020-08-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/42c0934a2d4729843a68840e4b3602e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lfg15z7j6lZSqFcN"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@todoranb_26?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">波格丹一世·托多兰</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="a516" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了使代码易于阅读和维护，我们应该遵循一些最佳实践。</p><p id="0f90" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这篇文章中，我们将看看我们应该遵循的一些最佳实践，以使每个人的生活更轻松。</p><h1 id="97d7" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">读取承诺值时，首选<code class="fe lz ma mb mc b">await</code>而非<code class="fe lz ma mb mc b">then()</code></h1><p id="78d4" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lz ma mb mc b">async</code>和<code class="fe lz ma mb mc b">await</code>比回调模式短，所以我们可以转而起诉那个。</p><p id="0cc8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="e292" class="mq lc iq mc b gy mr ms l mt mu">myPromise<br/>  .then((val) =&gt; {<br/>    return foo();<br/>  })<br/>  .then((val) =&gt; {<br/>    return bar();<br/>  })<br/>  .then((val) =&gt; {<br/>    return val;<br/>  })</span></pre><p id="365b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="5cf8" class="mq lc iq mc b gy mr ms l mt mu">const foo = async () =&gt; {<br/>  const val1 = await myPromise;<br/>  const val2 = await foo();<br/>  const val3 = await bar();<br/>  return va3;<br/>}</span></pre><p id="6f0e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们没有更多的回调。</p><h1 id="57dc" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">确保将适当数量的参数传递给 Promise 函数</h1><p id="43d3" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">我们应该将适当的参数传递给 promise 方法。</p><p id="89fc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lz ma mb mc b">Promise.all</code>被称为满口答应。</p><p id="dec3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">与<code class="fe lz ma mb mc b">Promise.race</code>相同。</p><p id="cc72" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">用解析的值调用<code class="fe lz ma mb mc b">Promise.resolve</code>。</p><p id="0f1f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lz ma mb mc b">Promise.reject</code>以拒绝的理由被调用。</p><p id="d554" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lz ma mb mc b">then</code>被称为成功和可选地和失败回调。</p><p id="d420" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lz ma mb mc b">catch</code>用回调调用。</p><p id="c1cb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lz ma mb mc b">finally</code>与<code class="fe lz ma mb mc b">catch</code>相同。</p><h1 id="4ab7" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">对象文字属性名的引号</h1><p id="5448" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">如果一个属性名不是一个有效的标识符，那么我们需要用引号括起来。</p><p id="14a0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们写道:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="93bf" class="mq lc iq mc b gy mr ms l mt mu">const obj = {<br/>  "foo bar": true<br/>};</span></pre><p id="538f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">否则，我们不需要引号:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="379f" class="mq lc iq mc b gy mr ms l mt mu">const obj = {<br/>  foo: true<br/>};</span></pre><h1 id="f3e0" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">一致使用反斜线、双引号或单引号</h1><p id="2806" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">如果我们选择一个在任何地方都使用的字符串分隔符，它将是反勾号。</p><p id="1304" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">无论是否需要插值表达式，我们都可以使用模板字符串。</p><p id="5683" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="31f7" class="mq lc iq mc b gy mr ms l mt mu">const backtick = `backtick`;</span></pre><p id="668a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="084d" class="mq lc iq mc b gy mr ms l mt mu">const greet = `hello ${name}`;</span></pre><p id="60d2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们甚至可以用它们编写多行字符串:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="ca8e" class="mq lc iq mc b gy mr ms l mt mu">const backtick = `foo<br/>bar`;</span></pre><p id="7b12" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果字符串中有一个换行符，那么它将被这样显示。</p><h1 id="67a7" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">需要基数参数</h1><p id="d191" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">我们应该在<code class="fe lz ma mb mc b">parseInt</code>方法调用中输入基数参数，以确保我们用正确的基数解析数字。</p><p id="b273" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，以下内容:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="6ac3" class="mq lc iq mc b gy mr ms l mt mu">const num = parseInt("091");</span></pre><p id="50cc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">可以解释为八进制数。</p><p id="5e64" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，我们应该写:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="5fdf" class="mq lc iq mc b gy mr ms l mt mu">const num = parseInt("091", 10);</span></pre><p id="f255" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">将其转换为十进制数。</p><h1 id="495c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">对布尔属性实施一致的命名</h1><p id="4dfa" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">在 React 中，我们应该确保布尔属性有一致的命名方案，以减少混淆。</p><p id="0270" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="de56" class="mq lc iq mc b gy mr ms l mt mu">import PropTypes from 'prop-types';</span><span id="840e" class="mq lc iq mc b gy mv ms l mt mu">class Heading extends React.Component {<br/>  render() {<br/>    return (<br/>      &lt;h1&gt;{this.props.enabled}&lt;/h1&gt;<br/>    );<br/>  }<br/>}</span><span id="0ad1" class="mq lc iq mc b gy mv ms l mt mu">Heading.propTypes = {<br/>  enabled: PropTypes.boolean<br/>};</span></pre><p id="c963" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="7339" class="mq lc iq mc b gy mr ms l mt mu">import PropTypes from 'prop-types';</span><span id="0acd" class="mq lc iq mc b gy mv ms l mt mu">class Heading extends React.Component {<br/>  render() {<br/>    return (<br/>      &lt;h1&gt;{this.props.enabled}&lt;/h1&gt;<br/>    );<br/>  }<br/>}</span><span id="7392" class="mq lc iq mc b gy mv ms l mt mu">Heading.propTypes = {<br/>  isEnabled: PropTypes.boolean<br/>};</span></pre><p id="d116" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">前缀<code class="fe lz ma mb mc b">is</code>很容易告诉我们这是一个布尔属性。</p><h1 id="0c91" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">不要使用没有显式 T <code class="fe lz ma mb mc b">ype</code>属性的<code class="fe lz ma mb mc b">button</code>元素</h1><p id="da80" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">我们不应该使用没有显式类型属性的按钮元素。</p><p id="7e4e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">否则，我们可能会得到意想不到的结果。</p><p id="31d0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="8609" class="mq lc iq mc b gy mr ms l mt mu">const Foo = &lt;button&gt;Foo&lt;/button&gt;</span></pre><p id="03aa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="1cee" class="mq lc iq mc b gy mr ms l mt mu">const Foo = &lt;button type='button'&gt;Foo&lt;/button&gt;</span></pre><h1 id="43c7" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">默认属性应该有相应的非必需属性类型</h1><p id="df3a" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">对于非必需的属性类型，我们应该有一个默认的属性。</p><p id="f704" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样的话，道具永远都不是<code class="fe lz ma mb mc b">undefined</code>。</p><p id="224e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，代替写作:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="3c48" class="mq lc iq mc b gy mr ms l mt mu">function FooBar({ foo, bar }) {<br/>  return &lt;div&gt;{foo}{bar}&lt;/div&gt;;<br/>}</span><span id="2f86" class="mq lc iq mc b gy mv ms l mt mu">FooBar.propTypes = {<br/>  foo: React.PropTypes.string.isRequired,<br/>  bar: React.PropTypes.string<br/>};</span><span id="dd1e" class="mq lc iq mc b gy mv ms l mt mu">FooBar.defaultProps = {<br/>  foo: "foo"<br/>};</span></pre><p id="adde" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="8d4b" class="mq lc iq mc b gy mr ms l mt mu">function FooBar({ foo, bar }) {<br/>  return &lt;div&gt;{foo}{bar}&lt;/div&gt;;<br/>}</span><span id="7db5" class="mq lc iq mc b gy mv ms l mt mu">FooBar.propTypes = {<br/>  foo: React.PropTypes.string.isRequired,<br/>  bar: React.PropTypes.string<br/>};</span><span id="daff" class="mq lc iq mc b gy mv ms l mt mu">FooBar.defaultProps = {<br/>  bar: "bar"<br/>};</span></pre><h1 id="8bfa" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">在属性、状态和上下文的赋值过程中，强制使用一致的析构</h1><p id="84a5" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">我们应该使用属性、状态和上下文一致的析构赋值。</p><p id="b179" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们应该写:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="5097" class="mq lc iq mc b gy mr ms l mt mu">const IdComponent = ({id}) =&gt; {<br/>  return (&lt;div id={id} /&gt;)<br/>};</span></pre><p id="d428" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="42b9" class="mq lc iq mc b gy mr ms l mt mu">const Foo = class extends React.PureComponent {<br/>  render() {<br/>    const { name } = this.state;<br/>    return &lt;div&gt;{name}&lt;/div&gt;;<br/>  }<br/>};</span></pre><h1 id="5781" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">在 React 组件定义中添加显示名称</h1><p id="20a2" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">我们应该设置<code class="fe lz ma mb mc b">displayNamne</code>属性，这样当我们用 React dev 工具调试时就可以看到这个名称。</p><p id="feae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们写道:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="5a9b" class="mq lc iq mc b gy mr ms l mt mu">export default function Greet({ name }) {<br/>  return &lt;div&gt;hello {name}&lt;/div&gt;;<br/>}<br/>Greet.displayName = 'Greet';</span></pre><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/96f7b4c2263115e91ecfcf96b90e91bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9sFJh5mnvuZ5SeIp"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://unsplash.com/@brindo_?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">杰克·布林德</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><h1 id="f609" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="0655" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">我们一定要确保正确定义和使用承诺。</p><p id="f9e8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，当我们创建 React 组件时，我们应该为可选组件提供一些属性验证和默认属性。</p><p id="fbb1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另外，<code class="fe lz ma mb mc b">displayName</code>对于调试很有用。</p></div></div>    
</body>
</html>