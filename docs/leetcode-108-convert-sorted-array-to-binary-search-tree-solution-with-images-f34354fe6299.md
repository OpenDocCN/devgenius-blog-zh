# LeetCode 108。将排序后的数组转换为二叉查找树(带图像的解决方案)

> 原文：<https://blog.devgenius.io/leetcode-108-convert-sorted-array-to-binary-search-tree-solution-with-images-f34354fe6299?source=collection_archive---------5----------------------->

# 问题:→

给定一个整数数组`nums`，其中的元素按**升序**排序，将*转换成一个* ***高度平衡的*** *二叉查找树*。

高度平衡的二叉树是这样一种二叉树，其中每个节点的两个子树的深度相差不超过 1。

**例 1:**

![](img/96814b6faa667ee58791f563bd73e4cb.png)

```
**Input:** nums = [-10,-3,0,5,9]
**Output:** [0,-3,9,-10,null,5]
**Explanation:** [0,-10,5,null,-3,null,9] is also accepted:
```

![](img/749bd50be7c60a22ac3b9b418f53664b.png)

**例 2:**

![](img/7b6cbf492b095d09736e4f2e6db22a51.png)

```
**Input:** nums = [1,3]
**Output:** [3,1]
**Explanation:** [1,null,3] and [3,1] are both height-balanced BSTs.
```

**约束:**

*   `1 <= nums.length <= 104`
*   `-104 <= nums[i] <= 104`
*   `nums`按照**严格递增**的顺序排序。

# 解决方案:→

让我们先了解一下什么是**身高平衡二叉查找树？**

→没有**叶的树**比其他任何**叶**离**根**远得多。

下图显示了两棵树，一棵是高度平衡的，另一棵不是。

![](img/3f3d81b685a58062075263e345cee8d9.png)

**第一棵树**被认为是**高度平衡树**，因为左子树只比**右子树的**高度**多 **1。****

**第二棵树**没有**高度平衡**因为左子树 **2** 的高度比**右子树**的**高。**

在理解了高度平衡树之后，让我们来理解如何将数组转换成高度平衡树。

# 解决方案:→

一般来说，我们可以通过以下方式将给定的排序后的整数数组转换成高度平衡的**二叉查找树*。*

*![](img/edb0a538e3dae865ae94db9f7f107cf1.png)*

*现在，让我们用代码来理解，*

*我们将继续用**二分搜索法**中的**递归方式**，就在这里，排序后的数组被给出。*

*首先，我们需要找到**根节点**，根节点将是**中间元素**，其中作为其值的**左节点**将比中间节点低**，而**右节点**的值将比根节点**大**。***

*为了找到中间值，我们将使用下面公式:*

*![](img/671341a47e567cfc325d55aecc503881.png)*

*如果你想明白为什么我们**不应该**使用 **mid = (start+ end)/2** ，你应该[点击这里](/avoid-this-thing-while-calculating-mid-value-in-data-structures-73d834ed5fb8)。*

*![](img/4d03d6162f4761ad7d3160cbfcfdb2a1.png)*

*现在，我们将创建新的 **TreeNode** ，在这里我们将为一个**节点赋值 5** 。*

*![](img/bab212411e53a6327e139f5df3cf6add.png)*

*现在，我们用数组的左边部分调用 **createBST** 。*

*这里 **start = 0，end =(mid—1)=(3–1)= 2***

*![](img/8e16995d9755836d5d672fe7fb419183.png)*

*这里，对于每个递归调用，将为下面的**右节点**创建堆栈，它存储值，如下所示。*

*![](img/a20610d81395b52044f77a01876c4052.png)**![](img/698c0c35e5df9f96349f5262028c386e.png)*

*同样，我们将计算中间值并创建新的 **TreeNode** ，*

*这里**mid =(start+(end-start)/2)=(0+(2–0)/2)=(0+1)= 1。***

*![](img/438bf370ab2c6480155911ff08e3ace8.png)*

*新创建的节点将被分配到树的左侧节点。*

*![](img/e5917fb55d604cd633a3b9aa8cdc4605.png)**![](img/324b9a7f6c7e4d7e2550ad51f17c62ea.png)*

*现在，对于第二次递归调用，再次将值追加到堆栈中。*

*![](img/a20610d81395b52044f77a01876c4052.png)**![](img/238781cbcaf5abed60cfb00807c14835.png)*

*同样，我们用数组的左边部分做递归调用，*

*这里 **start = 0** ，**end =(mid—1)=(2–1)= 1***

*![](img/7b0a6adf8a1b83f095ae8e13e404fcf8.png)*

*同样，我们将计算中间值并创建新的 **TreeNode** ，*

*这里**mid =(start+(end-start)/2)=(0+(1–0)/2)=(0+0)= 0。***

*![](img/535406afaab8197c5085196e0ba63c46.png)*

*新创建的**节点**，将被分配到树的**左侧节点**。*

*![](img/e5917fb55d604cd633a3b9aa8cdc4605.png)**![](img/dbb2dd17f0a61d39a8c875d3f4666e95.png)*

*对于第三次递归调用，该值也被追加到堆栈中。*

*![](img/a20610d81395b52044f77a01876c4052.png)**![](img/b22ee73c1862beba7e84f125b97c6d48.png)*

*这里 **start = 0** 但是现在， **end = > mid -1 = > -1。***

*![](img/eb1a3b6fd5ef20d8d4a43598de09c511.png)*

*因此，最后，**左节点**将为**空，**因此**递归堆栈**将不会被**追加**。*

*![](img/d5f0fd77616e005967a0681385e79e89.png)*

*现在，**反向过程**将开始，并且**值**将从**递归堆栈中**移除**。***

*![](img/5586a2fb60483ad260f81afc2120e158.png)**![](img/a20610d81395b52044f77a01876c4052.png)*

*这里， **start = (mid + 1) = (0+1) = 1。**和 **end = 0。***

*再次低于条件将返回 **null。***

*![](img/eb1a3b6fd5ef20d8d4a43598de09c511.png)*

*所以，最后，**右节点**将为**空**。*

*![](img/680b5d574815ed051ef5d13c1fffb8f9.png)*

*在下一个**右侧**的反向过程**中，**再次**值**将从**递归堆栈中**移除**。***

*![](img/5968b2b43f0471cc5f63c9709e40bc21.png)**![](img/a20610d81395b52044f77a01876c4052.png)*

*现在，再次递归调用右侧的**。***

*这里， **start = (1+ 1) = (1+1) = 2。**和 **end = 2。***

*所以，下面的条件将变成**假**。*

*![](img/eb1a3b6fd5ef20d8d4a43598de09c511.png)*

*但是，在下一行，*

***mid =(2+(2–2))/2 = 2/2 = 1***

*![](img/8f23f6b97fed4e58d4323638af0e1611.png)*

*在一个**栈**中，它被追加，*

*![](img/efafa61816548c97690c9997d29036dd.png)*

*而对于下一行，对于 **TreeNode (1)，**它的**右节点**的值将是，*

***mid = start+(end-start)/2 =>2+(2–2)/2 =>2***

*![](img/4f0762bb27f08aedca15fb49fb253603.png)*

*并且结果 **Treenode** 将是，*

*![](img/26a96b450a31d8a49f0355e2b7c7f9a1.png)*

*现在，再次调用函数 **createBST** ，该值将被添加到堆栈中。*

***开始= (mid + 1) = (2+1) = 3，结束= 2***

*![](img/06c7a9f1004935e5e05a805378a9270a.png)*

*现在，对于相反的过程，*

*![](img/53427e68e2b4d4dd4357926bfe73bdb7.png)*

*这里， **start = 3。**和 **end = 2。**以下条件将返回**空值。***

*![](img/eb1a3b6fd5ef20d8d4a43598de09c511.png)*

*所以，对于 **TreeNode (1)** 右节点将为 **NULL***

*![](img/a1cbd2db0380fee68f0269e67536b5ea.png)*

*同样，对于相反的过程，*

*![](img/f19dc58e26cb7e6a42d9e4a93764155d.png)*

*现在，对于 **TreeNode (1)** 左节点将为 **NULL***

*![](img/43fd7166b07cf9b02fcfe4feb84ad9e0.png)*

*现在，左边部分完成了，我们可以用右边部分理解同样的事情。*

*![](img/f4ed6d196f5b900e55aa0687a261dacc.png)*

*现在，让我们看看完整的源代码。*

# *代码(Java): →*

# *代码(Python): →*

# *时间复杂度*

*这里，递归发生了两次，但是一次是针对左半部分的，另一次是针对右半部分的，所以总时间复杂度是 **O(n)** 。*

# *空间复杂性*

*既然我们使用了一个额外的队列，那么，空间复杂度将是 O(n)**。***

*感谢你阅读这篇文章，❤*

*如果这篇文章对你有帮助，请鼓掌👏这篇文章。*

*请在[媒体](https://medium.com/@alexmurphyas8)上关注我，我会像上面一样发布有用的信息。*

*如果我做错了什么？让我在评论中。我很想进步。*