<html>
<head>
<title>Go : Introduction to Context Package</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Go:上下文包介绍</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/go-introduction-to-context-package-2e5c844e1ae3?source=collection_archive---------5-----------------------#2022-03-14">https://blog.devgenius.io/go-introduction-to-context-package-2e5c844e1ae3?source=collection_archive---------5-----------------------#2022-03-14</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="c374" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">来自 GO 的强大软件包</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f30c7609d48bc7499bd833ba88641b93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*bdf9TEK7Yu1z6hOX.jpg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">来源:freecodecamp</figcaption></figure><h1 id="8ae3" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated"><strong class="ak">什么是语境？</strong></h1><p id="34ac" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">Context 是携带<strong class="jm io">值</strong>、<strong class="jm io">取消信号</strong>、<strong class="jm io">超时信号</strong>、&amp; <strong class="jm io">截止信号</strong>的数据。有了上下文，我们就更容易在过程之间传递价值或信号。</p><h1 id="a729" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">为什么语境很重要？</h1><p id="0a82" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">有了上下文，当我们想要取消所有的进程时，我们只需要向上下文发送一个信号。因此，所有进程将自动取消。GO-lang 几乎每个部分都在使用数据库、http 服务器、http 客户端等上下文。即使在 Google 中，当使用 Go 进行开发时，上下文也是必需的，并且总是发送给每个函数。</p><h1 id="d10f" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">上下文是如何工作的？</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/61f3446fa87a2744f7a34d8514ac664a.png" data-original-src="https://miro.medium.com/v2/resize:fit:628/format:webp/1*pQQQDfIx4o0w4XWxa7sO7Q.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">上下文工作的示例</figcaption></figure><p id="3839" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">例如，如果你想从进程 A 中取消某个进程，并将其发送到另一个进程，所有的另一个进程将检测到从进程 A 发出的信号并取消该进程。</p></div><div class="ab cl mc md hr me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ig ih ii ij ik"><h1 id="1176" class="ky kz in bd la lb mj ld le lf mk lh li lj ml ll lm ln mm lp lq lr mn lt lu lv bi translated">如何营造语境？</h1><p id="8f86" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">因为上下文是一个接口，所以要创建一个上下文，我们需要一个适合契约接口的结构。但是在上下文包中，我们可以使用任何函数来创建上下文，而不是手动创建上下文。</p><p id="fe2e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">创建上下文有两个功能:</strong></p><ol class=""><li id="585a" class="mo mp in jm b jn jo jr js jv mq jz mr kd ms kh mt mu mv mw bi translated"><strong class="jm io">语境。</strong>后台()<br/>创建空上下文，永不取消，永不超时，并且没有任何值。</li><li id="a5de" class="mo mp in jm b jn mx jr my jv mz jz na kd nb kh mt mu mv mw bi translated"><strong class="jm io">语境。TODO() </strong> <br/>创建类似 Background()的空上下文，但通常在我们不清楚要使用的上下文时使用。</li></ol><h1 id="a2c5" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">创建空上下文</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="5c7b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是在 go 中初始化空上下文的例子。请查看控制台中打印的内容。上面的代码将打印<strong class="jm io">上下文。背景</strong> &amp; <strong class="jm io">上下文。TODO </strong>在你的控制台上。</p></div><div class="ab cl mc md hr me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ig ih ii ij ik"><h1 id="8cf5" class="ky kz in bd la lb mj ld le lf mk lh li lj ml ll lm ln mm lp lq lr mn lt lu lv bi translated">父子上下文</h1><p id="23d4" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">上下文采用了<strong class="jm io">父子</strong>概念。这意味着，当您创建一个上下文时，您可以从现有上下文创建一个子上下文。父上下文可能有许多子上下文，但子上下文只允许有一个父上下文。这个概念类似于面向对象编程中的继承概念。</p><h1 id="94c9" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">父子上下文之间的关系</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/35075d527b56fa9ae7f6b44855712fe5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1116/format:webp/1*Ubudb3zcvAgg93fIHHUqqA.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">父上下文和子上下文概念示例</figcaption></figure><p id="3bee" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">父上下文和子上下文将始终相互连接。当你对上下文 A 做了什么，上下文 A 的所有子元素和子元素都会受到影响，但是不会影响到不同继承路径的上下文 B。您可以从父上下文的子上下文和子上下文中访问父上下文中的数据。但是不允许从另一个继承路径上下文中访问数据。</p><h1 id="4030" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">上下文是不可变的</h1><p id="82f3" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">上下文是不可变的对象，这意味着在上下文被创建后，你不能再改变上下文。如果你给上下文添加值，并设置一个新的超时或其他任何东西。将自动创建一个新的子上下文，更改将应用于新的子上下文，而不会影响现有上下文。</p></div><div class="ab cl mc md hr me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ig ih ii ij ik"><h1 id="04d3" class="ky kz in bd la lb mj ld le lf mk lh li lj ml ll lm ln mm lp lq lr mn lt lu lv bi translated">有价值的上下文</h1><p id="34f6" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">默认情况下，上下文没有值。您可以向上下文添加一个值对(key-value)。当您向上下文添加新值时，将自动创建一个新的子上下文。这意味着原始的上下文没有改变。为了给上下文添加值，可以使用 function。</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="ffd0" class="nk kz in ng b gy nl nm l nn no"><strong class="ng io">context.WithValue(parent, key, value)</strong></span></pre><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">具有值的上下文示例</figcaption></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi np"><img src="../Images/8948dccfaeceb4a1db420c8999793fe5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1114/format:webp/1*GMZmU-Q7llbj1Z4PpOteOg.png"/></div></figure><p id="1c5a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">尝试运行上面的示例代码并查看结果，您将在控制台中看到每个子上下文都将连接到它自己的父上下文。</p><h1 id="4805" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">访问父上下文值</h1><p id="74e0" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">子上下文可以访问自己父上下文的值，不能从不同的继承路径访问。请查看并尝试下面的代码。</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="6a4a" class="nk kz in ng b gy nl nm l nn no">fmt.Println(contextF.Value("f"))<br/>fmt.Println(contextF.Value("c"))<br/>fmt.Println(contextF.Value("b"))<br/>fmt.Println(contextA.Value("b"))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/f8c2d2d8d467792b3fc9732a221a0827.png" data-original-src="https://miro.medium.com/v2/resize:fit:456/format:webp/1*_6_-l4n2GQUCqS7uzZzw9Q.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">上述代码的结果</figcaption></figure><p id="2b6a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你试过密码了吗？请看代码的结果。</p><ul class=""><li id="3c47" class="mo mp in jm b jn jo jr js jv mq jz mr kd ms kh nr mu mv mw bi translated">第一行代码试图访问它自己值，确切地说，你可以从它自己的上下文中访问值。</li><li id="b399" class="mo mp in jm b jn mx jr my jv mz jz na kd nb kh nr mu mv mw bi translated">第二行代码试图访问它自己的父上下文，这个方法仍然是允许的，你可以访问它自己的父值。</li><li id="b87c" class="mo mp in jm b jn mx jr my jv mz jz na kd nb kh nr mu mv mw bi translated">第三行代码试图用不同的父上下文访问上下文，你不能从不同的父上下文访问值。</li><li id="fab2" class="mo mp in jm b jn mx jr my jv mz jz na kd nb kh nr mu mv mw bi translated">第四行代码试图访问它自己子值，父上下文不能从它自己的子上下文中访问值。</li></ul></div><div class="ab cl mc md hr me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ig ih ii ij ik"><h1 id="e0f1" class="ky kz in bd la lb mj ld le lf mk lh li lj ml ll lm ln mm lp lq lr mn lt lu lv bi translated">带取消的上下文</h1><p id="e4ee" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">您也可以将<strong class="jm io">取消信号</strong>添加到上下文中。Cancel 信号通常在你想取消 goroutine 的执行时使用，你可以发送 cancel 信号到你想取消的 goroutine 的上下文中。要使用取消信号创建上下文，您可以使用此函数。</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="75a2" class="nk kz in ng b gy nl nm l nn no">context.WithCancel(parent)</span></pre><h1 id="1e3b" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">超时的上下文</h1><p id="c9e7" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">除了让代码手动取消 goroutine 之外，您还可以为取消信号设置超时。当程序时间超时时，goroutine 将自动取消。当您想要查询数据库或 API 时，上下文超时是合适的，但是您需要设置最大超时。要创建超时上下文，您可以使用此函数。</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="5018" class="nk kz in ng b gy nl nm l nn no">context.WithTimeout(parent, duration)</span></pre><h1 id="03ff" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">有截止日期的上下文</h1><p id="8898" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">除了为取消某个 goroutine 设置超时之外，您还可以为上下文设置截止时间。使用截止日期，您可以设置截止日期的时间，而不是设置超时之类的持续时间，例如今天中午 12:00。要创建带截止日期的上下文，您可以使用此功能。</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="7736" class="nk kz in ng b gy nl nm l nn no">context.WithDeadline(parent, time)</span></pre><p id="3fcd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">带有<strong class="jm io">取消的<strong class="jm io">上下文</strong>，超时，&amp;截止时间</strong>将返回<strong class="jm io"> 2 值</strong>，还有<strong class="jm io">一个新的子上下文</strong>和<strong class="jm io">取消功能</strong>。要取消上下文或流程，您只需添加下面的代码，cancel 函数将在上下文或流程完成后调用。</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="d269" class="nk kz in ng b gy nl nm l nn no">defer cancel()</span></pre></div><div class="ab cl mc md hr me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ig ih ii ij ik"><blockquote class="ns nt nu"><p id="f763" class="jk jl nv jm b jn jo jp jq jr js jt ju nw jw jx jy nx ka kb kc ny ke kf kg kh ig bi translated">参考:<br/> <a class="ae nz" href="https://www.youtube.com/watch?v=8S5cWNrMNNY&amp;t=736s" rel="noopener ugc nofollow" target="_blank"> Golang 上下文由程序员扎曼现</a></p></blockquote></div></div>    
</body>
</html>