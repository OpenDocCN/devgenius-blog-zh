# 请停止 Java 可选乱七八糟！

> 原文：<https://blog.devgenius.io/please-stop-the-java-optional-mess-2889dc4f5f27?source=collection_archive---------6----------------------->

![](img/ba00c142903059d40c86ebe9370116c8.png)

在我最近几年参与的许多项目中，我发现很难找到开发人员以正确的方式使用 Java 选项，所以我认为展示一下我认为正确的方法是很好的。

# 背景

首先，让我们澄清一下在 Java 中拥有可选的类的最初目的是什么。

正如你们中的许多人可能知道的，选修课最初是在番石榴图书馆推出的，并广泛使用了许多年，但它不是 JDK 的一部分，直到 JDK 8 发布。
这个可选类的主要目的是在编写 Java 代码时避免一些重要的问题；然而，所有邪恶的根源是 [NullPointerException](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/NullPointerException.html) 。Java 中 **null** 的存在给我们带来的一些问题有:

*   如何避免 NullPointerException？
*   我应该对每个方法进行空检查吗？
*   如何避免在方法中返回 null？
*   我应该把空值传递给构造函数吗？

让我们简单回顾一下这些细节，看看在可选性进入我们的生活之前我们能做些什么。

![](img/a702556474b2cf79298eb72a26eaacc8.png)

# 避免 NullPointerException

在大多数情况下，我们对此无能为力，但是有一些技巧，比如使用空安全的方法来代替空不安全的方法，或者改变一些操作的顺序来避免空。

例如，在比较字符串时，我们可以:

这个初始版本是不安全的，如果 **color** 变量为空，该方法会引发一个 **NullPointerException** 。在这种情况下，我们可以做的是重新安排订单，使其为零安全。

在这种情况下，NullPointerException 永远不会独立于客户端传入的值而引发。

除此之外，在大多数情况下，除了到处放置 null check 之外，我们真的没有什么可以避免 NullPointerException，这是一件乏味而又丑陋的事情。

# 避免返回空支票

在我们的方法中返回 null 是非常糟糕的事情，因为当响应被读取时，客户端通常应该期望它是安全的；然而，那总是可能的吗？

对于返回集合的方法来说，这很容易，作为经验法则，我们只需**返回一个空集合**，但是其他 Java 对象呢？
过去鼓励的方法之一是**使用空对象模式**来避免进行空检查。
基本上，假设你有一个返回 **Person** 对象的方法，这个想法是在 Person 实例为空的情况下发送一个 **NullPerson** 对象。这可能是一个解决方案，但就我个人而言，我不太相信这种方法。

# 向构造函数传递空值

就我个人而言，我认为这样做很讨厌，不管有没有可选的，都没有理由将 null 传递给构造函数。对于客户来说，还有其他更直观的解决方案。
**我认为使用多个构造器或者使用构造器模式是一个更好的解决方案**；使用一个还是另一个将取决于在大多数情况下类中可选参数的数量。我们现在不讨论它们，因为我们将在本文后面看到它们。

# 救援可选

在简单了解了 Optional 存在之前的情况之后，现在我们可以看看 Optional 在 JDK 8 中发布后的情况。

人们可能普遍认为 Optional 对 Java 开发人员来说是一件好事，因为它提供了更多的灵活性，并提供了编写更具表现力和灵活性的代码的能力；然而，事情并没有想象中的那么好。在 Optional 的使用中有一些不好的模式，我认为应该澄清并忽略。

# 可选做得不好

近年来，有两种模式最让我恼火。

*   在我们的类的 Java 字段中使用可选的
*   使用[可选](https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html)在构造函数中表示值的可选性

使用可选字段的一个问题是[可选](https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html)不可序列化。Optional 并不意味着被序列化，它的意思是作为可空字段的包装器，使客户端更容易处理它们。将 Optional 视为数据的持有者显然是错误的。

使用 Optional 作为 Java 字段通常会导致在我们的构造函数值中使用 Optional，而这正是事情变得混乱的时候。到处都有可选选项迫使开发人员在实例化类或者为我们的单元测试设置数据时初始化可选选项。没有必要这样做，代码变得比实际需要的更加混乱和冗长。

![](img/1f1dff54c22789b2a6a25e01d974cfc5.png)

让我们来看一些代码，让它变得更有趣！假设我们有这个类，它以我们上面描述的方式使用了 Optional。

如您所见，编写这个类的人的意图是表达只有名字和姓氏是必填字段，所以其他字段都是可选的。
现在让我们想象一下，我们希望声明一个只填写必填字段的客户实例。

那不理想，对吧？为什么我们必须设置所有那些可选的来实例化我们的类？即使我们想设置所有这些值，把它们都放在可选的。

为什么我必须为我的实例设置所有这些可选的？用一个可选的初始化一个实例甚至令人困惑，因为我知道在我的实例中那些值是存在的。

此外，更糟糕的是，我甚至可以向任何可选字段传递 null。这可能会使整个解决方案无效，因为客户端仍然会得到一个 NullPointerException！

如果我们运行这段代码，我们可以看到当我们试图访问客户的地址时，**我们引发了一个 NullPointerException！所以很明显这种方法也不安全。**

所以我们来看看应该怎么做！

# 可选完成正确

那么在这些情况下，我认为我们应该做些什么呢？如果这个类有更少的字段，我可能会创建不同的构造函数。至少，通过查看可用的构造函数，客户会清楚哪些字段是强制的，并且他们不必填充实例中没有使用的任何字段。然而，在我们有大量参数的情况下，我会选择一个构造器模式，这比有太多构造器更干净。

那么它会是什么样子呢？

我们的 **Customer** 类不会在 Java 字段或构造函数参数中使用可选性，相反，我们将通过在访问这些字段时返回 Optional(getters)来向客户端表达这些字段的可选性。此外，如果客户端必须构建一个实例，它将很容易知道哪些字段是强制的，并且能够通过使用 **withXXX** 访问器来设置任何其他可选字段。

当客户必须构建和访问我们的客户类时，情况会是怎样的？

看起来挺简单的吧？构造一个实例现在不会被那些不必要的可选实例所污染，并且使用 [Optional](https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html) 类本身提供的方法，以一种安全的方式访问一个可选字段是非常容易和干净的。

![](img/bb22ba63a24ec9c34ff94c0804765d8a.png)

对于那些不喜欢在类中实现一个构建器的人来说，使用 [Lombok](https://projectlombok.org/) 使类不那么冗长是一个选择。

最后值得一提的是，一些序列化库已经发布了工作区来序列化可选的，但我认为他们对那些错误使用它的开发者没有任何好处。正如我之前所说的，Optional 并不意味着被序列化，并且把工作区放在适当的位置而不是强迫开发者正确地使用它是没有帮助的。

原来如此！这就是我要向你展示的我认为在 Java 中很好地使用选项的所有内容，我真的希望你喜欢这篇文章，如果你有兴趣阅读更多，请订阅我的文章！

感谢您的阅读！

*原载于 2020 年 6 月 9 日 http://theboreddev.com*[](https://theboreddev.com/2020/06/09/please-stop-the-java-optional-mess/)**。**