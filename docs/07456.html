<html>
<head>
<title>Android 103 : How is constructor injection different from provides method in Dagger?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android 103:构造函数注入和 Dagger 中的 provides 方法有什么不同？</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/android-103-how-is-constructor-injection-different-from-provides-method-in-dagger-66ff0209ebb3?source=collection_archive---------9-----------------------#2022-03-26">https://blog.devgenius.io/android-103-how-is-constructor-injection-different-from-provides-method-in-dagger-66ff0209ebb3?source=collection_archive---------9-----------------------#2022-03-26</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="d145" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在第一篇<a class="ae ki" href="https://saurabhofficial.medium.com/android-101-what-does-dagger-really-generate-behind-the-scenes-db1300f9ce82" rel="noopener"> <strong class="jm io">文章</strong> </a>中，我们探讨了 dagger 如何为注入的构造函数依赖关系生成工厂，在这篇文章中，我们将探讨更多关于当我们使用<strong class="jm io"> @Provides </strong>方法代替构造函数注入来定义依赖关系或绑定时 dagger 生成的代码。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/27f46f3dd74151b0675287cb3787dea0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0kTgHd0BXZTlYQR5C02x0Q.jpeg"/></div></div></figure><p id="8617" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">正如在上一篇文章中提到的，Dagger 为每个构造函数注入的依赖项生成一个工厂，在生成的组件类中使用这个工厂来创建声明的依赖项的实例。</p><blockquote class="kv kw kx"><p id="2c23" class="jk jl ky jm b jn jo jp jq jr js jt ju kz jw jx jy la ka kb kc lb ke kf kg kh ig bi translated">但是我们为什么需要@provides 注释呢？什么时候我们可以使用构造函数注入来定义绑定，甚至不需要创建 dagger 模块？ <br/>只要我们可以注释任何类的构造函数，我们就应该这样做，而不是创建一个模块并定义@provides 方法，但在某些情况下，我们会被模块卡住，例如，当我们无法访问我们希望作为应用程序中注入依赖项的类的构造函数时，就像 Android 中的 Activity 类</p></blockquote><p id="6c9c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们将通过定义一个依赖于 DummyModule 的 DummyComponent 来研究生成的代码，并看看 Dagger 生成了哪些类。</p><pre class="kk kl km kn gt lc ld le lf aw lg bi"><span id="00f4" class="lh li in ld b gy lj lk l ll lm"><strong class="ld io">@Module<br/>object DummyModule {<br/></strong>    <br/>    @Singleton<br/>    @Provides<br/>    fun provideDummy(): Dummy {<br/>        return Dummy()<br/>    }<br/><strong class="ld io">}</strong></span></pre><p id="be2a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是我写的<strong class="jm io"> DummyModule </strong>，也是这里的<strong class="jm io"> DummyComponent </strong></p><pre class="kk kl km kn gt lc ld le lf aw lg bi"><span id="4442" class="lh li in ld b gy lj lk l ll lm"><strong class="ld io">@Component(modules = [DummyModule::class])<br/>@Singleton<br/>interface DummyComponent {<br/></strong>    fun getDummy(): Dummy<br/><strong class="ld io">}</strong></span></pre><p id="4e2b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当我们使用 provides annotated 方法时，dagger 会为 DummyModule 中声明的每个绑定/依赖项生成一个工厂。即<strong class="jm io">dummy module _ providedummy factory</strong></p><pre class="kk kl km kn gt lc ld le lf aw lg bi"><span id="015b" class="lh li in ld b gy lj lk l ll lm"><strong class="ld io">// One such factory is generated for each binding in Module</strong></span><span id="eacc" class="lh li in ld b gy ln lk l ll lm"><strong class="ld io">public final class DummyModule_ProvideDummyFactory implements Factory&lt;Dummy&gt;</strong> {</span><span id="1b6c" class="lh li in ld b gy ln lk l ll lm">  @Override<br/>  public Dummy get() {<br/>    return <em class="ky">provideDummy</em>();<br/>  }<br/><br/>  public static DummyModule_ProvideDummyFactory create() {<br/>    return InstanceHolder.<em class="ky">INSTANCE</em>;<br/>  }<br/><br/>  public static Dummy provideDummy() {<br/>    return Preconditions.<em class="ky">checkNotNullFromProvides</em>(DummyModule.<em class="ky">INSTANCE</em>.provideDummy());<br/>  }<br/><br/>  private static final class InstanceHolder {<br/>    private static final DummyModule_ProvideDummyFactory <em class="ky">INSTANCE </em>= new DummyModule_ProvideDummyFactory();<br/>  }<br/><strong class="ld io">}</strong></span></pre><p id="b11d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个生成的工厂几乎类似于我们使用构造函数注入而不是 provides 方法时生成的工厂，只是名称发生了变化，以反映我们使用的是 provides 方法，而不是从构造函数注入生成的工厂。</p><p id="aca7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个生成的工厂在生成的 Dagger 组件中被使用，以获得 Dummy 类的实例，这与上一篇文章非常相似，除了一个不同之处是<strong class="jm io">组件构建器</strong>。</p><pre class="kk kl km kn gt lc ld le lf aw lg bi"><span id="57f2" class="lh li in ld b gy lj lk l ll lm"><strong class="ld io">public final class DaggerDummyComponent implements DummyComponent {<br/></strong>  private final DaggerDummyComponent dummyComponent = this;<br/><br/>  private Provider&lt;Dummy&gt; provideDummyProvider;<br/><br/>  private DaggerDummyComponent() {<br/>    initialize();<br/>  }<br/><br/>  public static Builder builder() {<br/>    return new Builder();<br/>  }<br/><br/>  public static DummyComponent create() {<br/>    return new Builder().build();<br/>  }<br/><br/>  @SuppressWarnings("unchecked")<br/>  private void initialize() {<br/>    this.provideDummyProvider = DoubleCheck.<em class="ky">provider</em>(DummyModule_ProvideDummyFactory.<em class="ky">create</em>());<br/>  }<br/><br/>  @Override<br/>  public Dummy getDummy() {<br/>    return provideDummyProvider.get();<br/>  }<br/><br/><strong class="ld io">  public static final class Builder {<br/></strong>    <strong class="ld io">private Builder() {<br/>    }</strong><br/><br/>    <em class="ky">/**<br/>     * @deprecated This module is declared, but an instance is not used in the component. This method is a no-op. For more, see https://dagger.dev/unused-modules.<br/>     */<br/>    </em><strong class="ld io">@Deprecated<br/>    public Builder dummyModule(DummyModule dummyModule) {<br/>      Preconditions.<em class="ky">checkNotNull</em>(dummyModule);<br/>      return this;<br/>    }<br/><br/>    public DummyComponent build() {<br/>      return new DaggerDummyComponent();<br/>    }<br/>  }</strong><br/>}</span></pre><p id="3207" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">由于这个组件依赖于一个模块来获得它的依赖项，Dagger 生成了一个构建器，这样我们就可以用所有需要的模块来初始化我们的组件。</p><p id="d45c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">需要注意的细节！</strong></p><ol class=""><li id="9d1c" class="lo lp in jm b jn jo jr js jv lq jz lr kd ls kh lt lu lv lw bi translated"><strong class="jm io">生成的代码中那个大的弃用警告是什么？</strong> <br/>弃用说明告诉我们，组件不需要模块的任何实例来调用内部的 provides 方法，因为所有方法都是可访问的，甚至不需要创建模块的任何实例，因为它被声明为<a class="ae ki" href="https://play.kotlinlang.org/byExample/03_special_classes/04_Object" rel="noopener ugc nofollow" target="_blank">对象</a>，这使得生成的代码更有效，因为组件不需要实例化模块。理想情况下，当我们写模块的时候，我们应该试着让它里面的所有方法都是静态的(或者在 kotlin 中作为一个对象类)。</li><li id="5d00" class="lo lp in jm b jn lx jr ly jv lz jz ma kd mb kh lt lu lv lw bi translated">我们为什么需要模块类的实例呢？为什么我们不能总是把它声明为一个对象？有时我们希望我们的模块类是有状态的，也就是说，我们希望在模块内部声明一些变量，以供 provides 方法使用，在这种情况下，我们将把它声明为一个适当的类。在这种情况下，组件将需要模块的一个实例来调用模块中声明的 provides 方法。这个<a class="ae ki" href="https://codinginflow.com/tutorials/android/dagger-2/part-7-stateful-modules" rel="noopener ugc nofollow" target="_blank">教程</a>涵盖了完全相同的场景。<br/>你可以试着在<strong class="jm io"> DummyModule </strong>声明中用一个简单的<strong class="jm io">类</strong>替换<strong class="jm io">对象</strong>，看看生成的代码有何不同！</li></ol><p id="7442" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我会试着在这个系列中写更多关于 Dagger 的内容，并在这里更新相关文章/**WIP*/</p><p id="1d83" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你觉得这篇文章很有见地，请给我一个掌声😄，快乐阅读！</p></div></div>    
</body>
</html>