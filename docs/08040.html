<html>
<head>
<title>[ES6] let keyword — real life</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">[ES6] let 关键字—真实生活</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/es6-let-keyword-real-life-cb8291b4f395?source=collection_archive---------12-----------------------#2022-05-12">https://blog.devgenius.io/es6-let-keyword-real-life-cb8291b4f395?source=collection_archive---------12-----------------------#2022-05-12</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="8aea" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">本文通过 ES6 <code class="fe ki kj kk kl b"><strong class="jm io">let</strong></code>关键字，结合现实生活中的例子和解释。</p><p id="148f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ki kj kk kl b"><strong class="jm io">let</strong></code>关键字的特征:</p><ul class=""><li id="f547" class="km kn in jm b jn jo jr js jv ko jz kp kd kq kh kr ks kt ku bi translated">引入块范围。</li><li id="d04f" class="km kn in jm b jn kv jr kw jv kx jz ky kd kz kh kr ks kt ku bi translated">无法重新声明。</li><li id="c7d2" class="km kn in jm b jn kv jr kw jv kx jz ky kd kz kh kr ks kt ku bi translated">必须在使用前声明。</li></ul><h1 id="6bb3" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">引入块范围</h1><p id="b9ad" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">在 ES6 之前，没有所谓的<strong class="jm io">块范围</strong>。只有:</p><ul class=""><li id="fdf2" class="km kn in jm b jn jo jr js jv ko jz kp kd kq kh kr ks kt ku bi translated">功能范围。</li><li id="8b33" class="km kn in jm b jn kv jr kw jv kx jz ky kd kz kh kr ks kt ku bi translated">全球范围。</li></ul><p id="a8cb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">块作用域防止从块外部访问变量(在块内部声明)。这只能通过使用<code class="fe ki kj kk kl b"><strong class="jm io">let</strong></code>关键字(或者，<code class="fe ki kj kk kl b"><strong class="jm io">const</strong></code>)来完成。并且，<code class="fe ki kj kk kl b"><strong class="jm io">ReferenceError</strong></code>是你将得到的。</p><pre class="md me mf mg gt mh kl mi mj aw mk bi"><span id="bc98" class="ml lb in kl b gy mm mn l mo mp">{<br/>  <strong class="kl io">let</strong> count = 1;<br/>}<br/>console.log(count); // &lt;= outside access, ReferenceError</span></pre><figure class="md me mf mg gt mr gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/260c0b8d568f62dec6b9480455fc04be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/format:webp/1*io1g83oRkpDWtQtzm75jpQ.png"/></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk translated">访问块范围变量时出现 ReferenceError</figcaption></figure><p id="6c80" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">与<code class="fe ki kj kk kl b"><strong class="jm io">var</strong></code>关键字相比，你可以自由地从一个块中访问任何变量，没有任何例外，因为一旦使用<code class="fe ki kj kk kl b"><strong class="jm io">var</strong></code>声明，变量就在函数作用域下(或者在另一种情况下在全局作用域下)。</p><h1 id="4450" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">无法重新申报</h1><p id="aee8" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">当你试图重新声明一个已经使用<code class="fe ki kj kk kl b"><strong class="jm io">let</strong></code>关键字声明的变量时，会抛出一个<code class="fe ki kj kk kl b"><strong class="jm io">SyntaxError</strong></code>(重新声明一个变量意味着使用已经声明的变量的相同名称)。</p><pre class="md me mf mg gt mh kl mi mj aw mk bi"><span id="5690" class="ml lb in kl b gy mm mn l mo mp"><strong class="kl io">let</strong> name;<br/><strong class="kl io">let</strong> name; // &lt;= SyntaxError</span></pre><figure class="md me mf mg gt mr gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi my"><img src="../Images/68cf6f9a37b04a3f0f5e7d39950a4bce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6Fg0fJRhIQA7mX8YEx8D0Q.png"/></div></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk translated">使用 let 关键字重新声明变量时出现语法错误</figcaption></figure><p id="2cd7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">与<code class="fe ki kj kk kl b"><strong class="jm io">var</strong></code>关键字相比，你可以随时自由地重新声明变量，没有任何例外。</p><h1 id="4289" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">必须在使用前声明</h1><p id="c558" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">当试图使用一个没有使用<code class="fe ki kj kk kl b"><strong class="jm io">let</strong></code>关键字声明的变量时，您将收到一个<code class="fe ki kj kk kl b"><strong class="jm io">ReferenceError</strong></code>。</p><pre class="md me mf mg gt mh kl mi mj aw mk bi"><span id="3d66" class="ml lb in kl b gy mm mn l mo mp"><strong class="kl io">function</strong> sayHello() {<br/>    console.log(myName);<br/>    <strong class="kl io">let</strong> myName = "Mike";<br/>    console.log("Hello", myName);<br/>}<br/>sayHello(); // &lt;= ReferenceError</span></pre><figure class="md me mf mg gt mr gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi nd"><img src="../Images/53c6abdc1d029104562d0ac730e22483.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ENlWLZG_gN5242A_isQ8QA.png"/></div></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk translated">在声明之前尝试访问变量时出现 ReferenceError</figcaption></figure><p id="40cc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">与<code class="fe ki kj kk kl b"><strong class="jm io">var</strong></code>关键字相比，你可以自由地对此。</p><pre class="md me mf mg gt mh kl mi mj aw mk bi"><span id="4276" class="ml lb in kl b gy mm mn l mo mp"><strong class="kl io">function</strong> sayHello() {<br/>    console.log(myName);<br/>    <strong class="kl io">var</strong> myName = "Mike";<br/>    console.log("Hello", myName);<br/>}<br/>sayHello(); // There is no exception here<br/>// The output on the console:<br/>// undefined<br/>// Hello Mike</span></pre><p id="5045" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在 JS 中，有一个提升术语，可以将上述功能解释为:</p><pre class="md me mf mg gt mh kl mi mj aw mk bi"><span id="7461" class="ml lb in kl b gy mm mn l mo mp"><strong class="kl io">function</strong> sayHello() {<br/>    <strong class="kl io">var</strong> myName; // Declare the variable without initialization<br/>    console.log(myName);<br/>    myName = "Mike";<br/>    console.log("Hello", myName);<br/>}<br/>sayHello(); // There is no exception here<br/>// The output on the console:<br/>// undefined<br/>// Hello Mike</span></pre><p id="a580" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这就是为什么你会在输出的第一行看到<code class="fe ki kj kk kl b">undefined</code>，因为<code class="fe ki kj kk kl b">myName</code>没有初始化就被声明了。</p></div><div class="ab cl ne nf hr ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ig ih ii ij ik"><h1 id="5f6f" class="la lb in bd lc ld nl lf lg lh nm lj lk ll nn ln lo lp no lr ls lt np lv lw lx bi translated">容易出错的问题可以通过 let 关键字解决</h1><pre class="md me mf mg gt mh kl mi mj aw mk bi"><span id="836f" class="ml lb in kl b gy mm mn l mo mp"><strong class="kl io">function</strong> print() {<br/>    <strong class="kl io">for</strong> (<strong class="kl io">var</strong> i = 0; i &lt; 10; i++) {<br/>        // This is the block        <br/>        setTimeout(function () {<br/>            console.log(i);<br/>        }, 0);<br/>    }<br/>}<br/>print(); // Ten times with the same value of 10</span></pre><p id="7b0b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">变量<code class="fe ki kj kk kl b">i</code>不在块作用域(改为函数作用域)是可以理解的。结果，<code class="fe ki kj kk kl b">i</code>一直增加，直到中断循环，该循环为 10，并绑定到在<code class="fe ki kj kk kl b">setTimeout</code>中传递的回调函数。</p><p id="7b9a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在<code class="fe ki kj kk kl b"><strong class="jm io">let</strong></code>之前，我们可以使用 JS 闭包和 life(<strong class="jm io">I</strong>immediately<strong class="jm io">I</strong>nvoked<strong class="jm io">F</strong>function<strong class="jm io">E</strong>expression)来处理这个问题。</p><pre class="md me mf mg gt mh kl mi mj aw mk bi"><span id="3535" class="ml lb in kl b gy mm mn l mo mp"><strong class="kl io">function</strong> print() {<br/>    <strong class="kl io">for</strong> (<strong class="kl io">var</strong> i = 0; i &lt; 10; i++) {<br/>        setTimeout((<strong class="kl io">function</strong> (val) {<br/>            <strong class="kl io">return</strong> function () {<br/>                console.log(val);<br/>            };<br/>        })(i), 0);<br/>    }<br/>}</span></pre><p id="7d01" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">解释:</p><ul class=""><li id="9f82" class="km kn in jm b jn jo jr js jv ko jz kp kd kq kh kr ks kt ku bi translated"><code class="fe ki kj kk kl b">setTimeout</code>中传递的表情就是生活。</li><li id="a170" class="km kn in jm b jn kv jr kw jv kx jz ky kd kz kh kr ks kt ku bi translated">循环的每一次迭代都将创建一个全新的函数(由 life 返回),该函数在 life 调用时绑定到<code class="fe ki kj kk kl b">i</code>的值(依次从 0 到 9)。</li></ul><p id="0b38" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，使用<code class="fe ki kj kk kl b"><strong class="jm io">let</strong></code>关键字很容易达到预期的输出。</p><pre class="md me mf mg gt mh kl mi mj aw mk bi"><span id="de70" class="ml lb in kl b gy mm mn l mo mp"><strong class="kl io">function</strong> print() {<br/>    <strong class="kl io">for</strong> (<strong class="kl io">let</strong> i = 0; i &lt; 10; i++) {<br/>        setTimeout(<strong class="kl io">function</strong> () {<br/>            console.log(i);<br/>        }, 0);<br/>    }<br/>}</span></pre><p id="4b2f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">关注:</p><ul class=""><li id="05ff" class="km kn in jm b jn jo jr js jv ko jz kp kd kq kh kr ks kt ku bi translated">循环语法的第一部分只执行一次。</li><li id="6cf3" class="km kn in jm b jn kv jr kw jv kx jz ky kd kz kh kr ks kt ku bi translated">引入块范围<code class="fe ki kj kk kl b">i</code>应该在循环的每一次迭代中重新声明，这是<code class="fe ki kj kk kl b"><strong class="jm io">let</strong></code>关键字不允许的。</li></ul><p id="feae" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">遵循<a class="ae nq" href="https://262.ecma-international.org/6.0/#sec-createperiterationenvironment" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io">运行时语义:CreatePerIterationEnvironment(perIterationBindings)</strong></a>，这个可以这样理解:</p><pre class="md me mf mg gt mh kl mi mj aw mk bi"><span id="1312" class="ml lb in kl b gy mm mn l mo mp"><strong class="kl io">function</strong> print() {<br/>    <strong class="kl io">for</strong> (<strong class="kl io">var</strong> i = 0; i &lt; 10; i++) {<br/>        {<br/>            <strong class="kl io">let</strong> val = i;<br/>            setTimeout(<strong class="kl io">function</strong> () {<br/>                console.log(val);<br/>            }, 0);<br/>        }<br/>    }<br/>}</span></pre><p id="b6a4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">解释:</p><ul class=""><li id="f4d2" class="km kn in jm b jn jo jr js jv ko jz kp kd kq kh kr ks kt ku bi translated">当在循环语法的第一部分使用<code class="fe ki kj kk kl b"><strong class="jm io">let</strong></code>时，JS 将改为使用<code class="fe ki kj kk kl b"><strong class="jm io">var</strong></code>并将循环体包装在一个范围内。</li><li id="e2be" class="km kn in jm b jn kv jr kw jv kx jz ky kd kz kh kr ks kt ku bi translated">在块内部，JS 将使用<code class="fe ki kj kk kl b"><strong class="jm io">let</strong></code>引入一个块作用域，这个作用域将由<code class="fe ki kj kk kl b">setTimeout</code>中传递的回调函数使用。</li><li id="9a74" class="km kn in jm b jn kv jr kw jv kx jz ky kd kz kh kr ks kt ku bi translated">这意味着，回调函数的每次迭代将被绑定到不同的<code class="fe ki kj kk kl b">val</code>和不同的值(与使用 IIFE 时相同——如上所述)。</li></ul><p id="0c79" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">【问题】:</strong>我能试试吗:</p><pre class="md me mf mg gt mh kl mi mj aw mk bi"><span id="6556" class="ml lb in kl b gy mm mn l mo mp"><strong class="kl io">function</strong> print() {<br/>    <strong class="kl io">for</strong> (<strong class="kl io">var</strong> i = 0; i &lt; 10; i++) {<br/>        {<br/>            <strong class="kl io">var</strong> val = i;<br/>            setTimeout(<strong class="kl io">function</strong> () {<br/>                console.log(val);<br/>            }, 0);<br/>        }<br/>    }<br/>}</span></pre><p id="df13" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">【答案】</strong>，对，可以。但是你会得到一个 10 次 10 次的结果，因为在一个函数作用域下，直到循环结束之前<code class="fe ki kj kk kl b">val</code>仍然会引用<code class="fe ki kj kk kl b">i</code>，这意味着每次迭代回调函数都会引用同一个值，并且值会增加。</p></div><div class="ab cl ne nf hr ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ig ih ii ij ik"><h1 id="c229" class="la lb in bd lc ld nl lf lg lh nm lj lk ll nn ln lo lp no lr ls lt np lv lw lx bi translated">警告</h1><p id="25ab" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">以上仅是我对<code class="fe ki kj kk kl b">let</code>关键字及其工作原理的理解。我尊重并愿意和热切地接受任何评论和反馈，以更深入地理解这一点。</p></div><div class="ab cl ne nf hr ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ig ih ii ij ik"><p id="9af3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最后，我非常感谢您花时间阅读这篇文章。</p><p id="de56" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">回头见。</p><p id="818a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">真诚，</p></div></div>    
</body>
</html>