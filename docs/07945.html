<html>
<head>
<title>Reactive Timer Microservice with Java Quartz, DynamoDB and Quarkus.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java Quartz、DynamoDB 和 Quarkus 的反应式定时器微服务。</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/reactive-timer-microservice-with-java-quartz-dynamodb-and-quarkus-bb4cf6e0dc23?source=collection_archive---------6-----------------------#2022-05-05">https://blog.devgenius.io/reactive-timer-microservice-with-java-quartz-dynamodb-and-quarkus-bb4cf6e0dc23?source=collection_archive---------6-----------------------#2022-05-05</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/aa129c8ca82fb5eb30be78276febd2ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k5uTdvHH2E3B0ZCLYU927A.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">Java，Quarkus，Quartz 和 DynamoDB。</figcaption></figure><p id="34e9" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在继续我们的前端对应物之前，让我们谈谈 AWS 上的后端微服务。正如我在过去的文章中提到的，我一直在为智能城市的物联网平台进行个人倡议。我想分享一个令人兴奋的服务，它允许我们使用 Java Quartz 以编程方式创建预定任务。考虑到这个服务，假设您想要创建一个定时任务，在一天中的特定时间和一周中的特定日期打开垃圾收集器机器人。有趣吧？！让我们从用提到的技术创建微服务开始这篇文章。然后，在接下来的文章中，我们将使用 ECS Fargate 和本地 Docker 映像在 AWS 上部署这个微服务。</p><p id="8d09" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">要完成本指南，您需要:</p><ul class=""><li id="21d5" class="kx ky in kb b kc kd kg kh kk kz ko la ks lb kw lc ld le lf bi translated">使用 Java 17 的 GraalVM，以及相应的适当配置的<code class="fe lg lh li lj b">JAVA_HOME</code>和<code class="fe lg lh li lj b">GRAALVM_HOME </code>。</li><li id="d1d8" class="kx ky in kb b kc lk kg ll kk lm ko ln ks lo kw lc ld le lf bi translated">Apache Maven 3.8.1 或更高版本。</li><li id="8ea0" class="kx ky in kb b kc lk kg ll kk lm ko ln ks lo kw lc ld le lf bi translated">像 IntelliJ 或 Eclipse 这样的 IDE。</li><li id="a3ae" class="kx ky in kb b kc lk kg ll kk lm ko ln ks lo kw lc ld le lf bi translated">访问 DynamoDB 服务的 AWS 帐户。</li></ul><p id="2560" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">注</strong>:您可以按照下面的说明从我的 GitHub 账号下载<a class="ae lp" href="https://github.com/aosolorzano/java-timer-service-quarkus" rel="noopener ugc nofollow" target="_blank"> <strong class="kb io"> <em class="lq">项目库</em> </strong> </a>。</p><p id="bc6b" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">以下命令在您配置的 DynamoDB 帐户上创建任务表:</p><pre class="lr ls lt lu gt lv lj lw lx aw ly bi"><span id="3cbe" class="lz ma in lj b gy mb mc l md me"># aws dynamodb create-table --table-name Task \<br/>    --attribute-definitions AttributeName=id,AttributeType=S \<br/>    --key-schema AttributeName=id,KeyType=HASH \<br/>    --billing-mode PAY_PER_REQUEST</span></pre><p id="ca27" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">然后，是时候用下面的 maven 命令创建我们的新 CRUD 项目，并用我们最喜欢的 IDE 打开它:</p><figure class="lr ls lt lu gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mf"><img src="../Images/58ea4ccfe05a275c2101f9d921c6d721.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sFS5_h-zr1fTIQKrV74G8A.png"/></div></div></figure><p id="c132" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">首先，创建我们的任务实体:</p><pre class="lr ls lt lu gt lv lj lw lx aw ly bi"><span id="83ca" class="lz ma in lj b gy mb mc l md me">@RegisterForReflection<br/><strong class="lj io">public class </strong>Task {<br/><br/>    <strong class="lj io">private </strong>String id;<br/>    <strong class="lj io">private </strong>String name;<br/>    <strong class="lj io">private </strong>Integer hour;<br/>    <strong class="lj io">private </strong>Integer minute;<br/>    <strong class="lj io">private </strong>List&lt;String&gt; daysOfWeek;<br/>    <strong class="lj io">private </strong>String executionCommand;<br/>    <strong class="lj io">private </strong>ZonedDateTime executeUntil;<br/>    <strong class="lj io">private </strong>String description;<br/>    <strong class="lj io">private </strong>ZonedDateTime createdAt;<br/>    <strong class="lj io">private </strong>ZonedDateTime updatedAt;<br/>    ...<br/>}</span></pre><p id="f150" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">注意</strong>:注释“<em class="lq">@ RegisterForReflection”</em>指示 Quarkus 在原生编译期间保留类及其成员。</p><p id="be0a" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">创建一个包含帮助器方法的抽象任务服务，这些方法为任务表上的 CRUD 操作构建 DynamoDB 请求:</p><pre class="lr ls lt lu gt lv lj lw lx aw ly bi"><span id="520f" class="lz ma in lj b gy mb mc l md me"><strong class="lj io">public abstract class </strong>AbstractTaskService {<br/><br/>    <strong class="lj io">protected </strong>ScanRequest scanRequest() {<br/>      ...<br/>    }</span><span id="a213" class="lz ma in lj b gy mg mc l md me"><strong class="lj io">    protected </strong>GetItemRequest getItemRequest(String id) {<br/>      ...<br/>    }</span><span id="3752" class="lz ma in lj b gy mg mc l md me"><strong class="lj io">    protected </strong>PutItemRequest getPutItemRequest(Task task) {<br/>      ...<br/>    }</span><span id="a8ef" class="lz ma in lj b gy mg mc l md me"><strong class="lj io">    protected </strong>UpdateItemRequest getUpdateItemRequest(<br/>      Task actualTask, Task updatedTask) {<br/>      ...<br/>    }</span><span id="5bf9" class="lz ma in lj b gy mg mc l md me"><strong class="lj io">    protected </strong>DeleteItemRequest getDeleteItemRequest(Task task) {<br/>      ...<br/>    }<br/>}</span></pre><p id="0ca7" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们可以结合使用 AWS SDK 版本 2 中当前支持的异步编程模型和<a class="ae lp" href="https://smallrye.io/smallrye-mutiny/index.html" rel="noopener ugc nofollow" target="_blank"> <strong class="kb io">哗变库</strong> </a>以反应方式与我们的任务表进行交互:</p><figure class="lr ls lt lu gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mh"><img src="../Images/73ef83a9ee3db36bfdd4bcd5b97f035f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hE1hgokd1app8MhqbzG-xQ.png"/></div></div></figure><p id="ffbe" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">所有这些操作还必须创建 Quartz 作业，这些作业必须在任务对象中指定的特定日期和时间自动执行:</p><figure class="lr ls lt lu gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mi"><img src="../Images/bfb431edd416bdbcc3903defd316b3d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*juUA92d0snL39TTujOJ6yA.png"/></div></div></figure><p id="a24c" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">现在是时候创建我们的异步 REST 资源组件了，它以异步方式使用 CRUD 服务方法:</p><figure class="lr ls lt lu gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mj"><img src="../Images/8ec8d818399a087efb54b19c0dd3bfc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hnraD1F2mJgpuIrWsOBaPw.png"/></div></div></figure><p id="9e65" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">请注意，我在前面的图片中省略了很多代码。您可以找到更多代码，如验证、异常处理、实用程序类等。，在我的<a class="ae lp" href="https://github.com/aosolorzano/java-timer-service-quarkus" rel="noopener ugc nofollow" target="_blank"> <em class="lq">项目资源库</em></a>GitHub 上。</p><p id="f707" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">为了使用异步 HTTP 调用与 DynamoDB 进行交互，我们需要 Maven POM 中的 NIO 客户端依赖:</p><pre class="lr ls lt lu gt lv lj lw lx aw ly bi"><span id="1a35" class="lz ma in lj b gy mb mc l md me">&lt;dependency&gt;<br/>    &lt;groupId&gt;software.amazon.awssdk&lt;/groupId&gt;<br/>    &lt;artifactId&gt;netty-nio-client&lt;/artifactId&gt;<br/>&lt;/dependency&gt;</span></pre><p id="5e87" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">为了结束这一部分，我想向您展示的最后一个组件是执行作业操作的类。该类必须包含作业执行期间执行的业务逻辑。在这里，您可以与您的架构中的其他微服务进行交互，或者与 AWS SQS 等预定义服务进行交互，以发送其他软件组件必须以事件驱动的架构方式使用的消息:</p><pre class="lr ls lt lu gt lv lj lw lx aw ly bi"><span id="3f42" class="lz ma in lj b gy mb mc l md me"><strong class="lj io">public class </strong>TaskJob <strong class="lj io">implements </strong>Job {<br/><br/>    @Override<br/>    <strong class="lj io">public void </strong>execute(JobExecutionContext executionContext) {<br/>        <em class="lq">LOGGER</em>.debug("execute() - START");<br/>        /* Your business logic */<br/>        <em class="lq">LOGGER</em>.debug("execute() - END");<br/>    }<br/>}</span></pre><p id="8b46" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">是时候在本地部署我们的微服务了；您只需要执行以下命令来启动我们的 Quarkus 应用程序:</p><pre class="lr ls lt lu gt lv lj lw lx aw ly bi"><span id="96c6" class="lz ma in lj b gy mb mc l md me"># mvn clean package<br/># java -jar target/quarkus-app/quarkus-run.jar</span></pre><figure class="lr ls lt lu gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mk"><img src="../Images/b021f8d79234cffb607cb0925677e627.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jiQpgCU7xDeb-SPb7BeT8A.png"/></div></div></figure><p id="0292" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我用邮差工具消费了微服务的 REST 方法。让我们从最简单的 POST 方法开始:</p><figure class="lr ls lt lu gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ml"><img src="../Images/2274c7f0e0b2c85e91c3e0f0b23bfde9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*os5NEwa8ddrlAJAmchDb8w.png"/></div></div></figure><p id="3b1e" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我创建了一个任务，必须在周一、周三和周六的 21:15 执行。该任务完成后，必须运行“<em class="lq"> executionCommand </em>”字段中指示的命令。正如我在本文开头提到的，这个任务模拟由我在 AWS 上构建的物联网平台管理的垃圾收集器机器人的激活。然后，我们下面的消费方法是一个 GET 操作:</p><figure class="lr ls lt lu gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mm"><img src="../Images/58732636ccd570e1b3403fe4e04e149e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4E2UfBzRPiQOYuRGcuFQ6A.png"/></div></div></figure><p id="86b0" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这里你可以看到我已经创建了两个任务。最后一个必须在周三周五 20:00 执行。当我写这几行字的时候，是星期三晚上。当完成此任务的时间到来时，我们的终端将打印以下行:</p><figure class="lr ls lt lu gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mk"><img src="../Images/bffd845ce1974e0b8a335a63ee55c33a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-m3rngI2nwDdnw77c3Utjw.png"/></div></div></figure><p id="9101" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在上图中，您可以看到我之前描述的“TaskJob”类的“execute”方法。请注意，图中显示的日期时间是 20:00 小时。让我们更新配置为在 21:15 执行的任务，以便它更早执行。</p><figure class="lr ls lt lu gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mm"><img src="../Images/dc4e3449d3ae0d3e42be7b9569bb6c9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7WafJKdwvM8DVN4Xca-kCw.png"/></div></div></figure><p id="7d61" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我更新了“daysOfWeek”字段以及“小时”和“分钟”，所以现在我们的任务将在 20:05 运行。如果我们再次执行 GET 方法，我们将看到更新后的任务:</p><figure class="lr ls lt lu gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mm"><img src="../Images/4db7df12fa8eefc4c0ca60477f3d9f9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yc9bWSOtMkUk_oYPchX3Ng.png"/></div></div></figure><p id="a290" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这个更新包括与任务相关的 Quartz 作业的修改。我们需要与 Quartz 上下文进行交互，以更新与实际作业相关的触发器对象。因此，我们的任务现在在编辑的时间执行。您可以在项目的源代码中看到更多的细节。</p><figure class="lr ls lt lu gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mk"><img src="../Images/d009a10b2db046f60b0d57d7205500e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*szlQrMXtkz5yivE13_uM0Q.png"/></div></div></figure><p id="771e" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">如果我们转到 DynamoDB 控制台，我们将看到我们的 2 个任务；其中一个更新了字段:</p><figure class="lr ls lt lu gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mn"><img src="../Images/949ab2a5ba67d286a0cc0cc0e542bf99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TV85jywTFJkDwc8lVXad8g.png"/></div></div></figure><p id="c7b1" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">最后，是时候展示 DELETE 方法操作了。现在我想删除其中一个任务，结果是这样的:</p><figure class="lr ls lt lu gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mm"><img src="../Images/28d9751cd7638822332090ca1f1ee79e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B0hpyUvr5zUsP3AI6Bt1Xg.png"/></div></div></figure><figure class="lr ls lt lu gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mo"><img src="../Images/c36d227405e723405d76320940411d83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EiCrFWQfDn9jh_IVDYvnpQ.png"/></div></div></figure><p id="a7f1" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">如我们所见，只有一个任务。如果我们转到 DynamoDB 控制台，我们必须看到剩下的任务:</p><figure class="lr ls lt lu gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mp"><img src="../Images/4b1059c57f959ec2d21e2df69484486c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EoQqLgBffSyP9kePEDnVKg.png"/></div></div></figure><p id="c5e4" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">就是这样！！我创建了一个 bash 文件来编译和打包整个项目。我还创建了一个在 DynamoDB 上创建任务表的脚本。您只需在项目的根文件夹中运行以下命令:</p><pre class="lr ls lt lu gt lv lj lw lx aw ly bi"><span id="4929" class="lz ma in lj b gy mb mc l md me"># ./run-scripts.sh</span></pre><p id="9825" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">下面的文章将向您展示如何使用 Fargate(无服务器风格)在 AWS ECS 上部署这个微服务。为此，我们将使用 Docker 为这个微服务创建容器映像，但是在 Quarkus 技术的帮助下使用相同的本地映像。</p><p id="983a" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">感谢您的阅读，我将在下一篇文章中与您见面。</p></div></div>    
</body>
</html>