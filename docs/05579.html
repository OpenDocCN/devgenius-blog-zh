<html>
<head>
<title>Writing an X86–64 Assembly Language Program</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编写 X86–64 汇编语言程序</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/getting-started-writing-assembly-language-8ecc116f3627?source=collection_archive---------4-----------------------#2021-09-12">https://blog.devgenius.io/getting-started-writing-assembly-language-8ecc116f3627?source=collection_archive---------4-----------------------#2021-09-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div class="gh gi io"><img src="../Images/f648b52b42197ba8be20c8c1d0fb0948.png" data-original-src="https://miro.medium.com/v2/resize:fit:1390/format:webp/1*qs1FHKxtq2shjhhOrjHWlQ.jpeg"/></div></figure><div class=""/><div class=""><h2 id="f49b" class="pw-subtitle-paragraph ju iw ix bd b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl dk translated">第一部分:开始编写汇编语言</h2></div><h2 id="96b7" class="km kn ix bd ko kp kq dn kr ks kt dp ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">本指南是系列的第一部分</h2><ul class=""><li id="c252" class="li lj ix lk b ll lm ln lo kv lp kz lq ld lr ls lt lu lv lw bi translated">第二部分:<a class="ae lx" href="https://tony-oreglia.medium.com/finding-an-efficient-development-cycle-for-writing-assembly-language-be2092e6db6a" rel="noopener">开始编写汇编语言</a></li><li id="98a3" class="li lj ix lk b ll ly ln lz kv ma kz mb ld mc ls lt lu lv lw bi translated">第三部分:<a class="ae lx" href="https://medium.com/@tony.oreglia/writing-an-x86-64-assembly-language-program-648b6005e8e" rel="noopener">打印命令行参数</a></li><li id="7286" class="li lj ix lk b ll ly ln lz kv ma kz mb ld mc ls lt lu lv lw bi translated">第四部分:<a class="ae lx" href="https://medium.com/@tony.oreglia/writing-an-x86-64-assembly-language-program-function-arguments-and-result-dfff25970dee" rel="noopener">发送函数参数并接收返回值</a></li><li id="6f54" class="li lj ix lk b ll ly ln lz kv ma kz mb ld mc ls lt lu lv lw bi translated">第五部分:<a class="ae lx" href="https://tony-oreglia.medium.com/writing-an-x86-64-assembly-language-program-1aade03f3b9b" rel="noopener">条件句，跳转，循环</a></li><li id="d95f" class="li lj ix lk b ll ly ln lz kv ma kz mb ld mc ls lt lu lv lw bi translated">第六部分:<a class="ae lx" href="https://tony-oreglia.medium.com/writing-an-x86-64-assembly-language-program-84e2432cf16b" rel="noopener">如何确定字符串长度</a></li><li id="0b47" class="li lj ix lk b ll ly ln lz kv ma kz mb ld mc ls lt lu lv lw bi translated">第七部分:<a class="ae lx" href="https://tony-oreglia.medium.com/writing-an-x86-64-assembly-language-program-f847d4edf577" rel="noopener">快速参考</a></li></ul></div><div class="ab cl md me hu mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ij ik il im in"><p id="ae0e" class="pw-post-body-paragraph mk ml ix lk b ll mm jy mn ln mo kb mp kv mq mr ms kz mt mu mv ld mw mx my ls ij bi translated">这是一个建立低摩擦开发环境的指南，以简化汇编语言程序的编写和调试。</p><h1 id="fad7" class="mz kn ix bd ko na nb nc kr nd ne nf ku kd ng ke ky kg nh kh lc kj ni kk lg nj bi translated">为什么要学习汇编语言</h1><blockquote class="nk nl nm"><p id="cd2c" class="mk ml nn lk b ll mm jy mn ln mo kb mp no mq mr ms np mt mu mv nq mw mx my ls ij bi translated">年轻时没黑过汇编语言的人是没有心的</p></blockquote><p id="c401" class="pw-post-body-paragraph mk ml ix lk b ll mm jy mn ln mo kb mp kv mq mr ms kz mt mu mv ld mw mx my ls ij bi translated">学习汇编语言可以提高一个人对软件的基本理解。随着基础知识的提高，你可以更准确地判断即将到来的技术的效用，我认为这是一个非常重要的技能。对哪些技术将占据主导地位下正确的赌注意味着你可以更好地投资你的时间甚至金钱。例如，众所周知，那些对加密货币领域有基本了解的人立即理解了区块链的价值，几乎没有额外的努力就赚了数百万美元。</p><p id="7ad3" class="pw-post-body-paragraph mk ml ix lk b ll mm jy mn ln mo kb mp kv mq mr ms kz mt mu mv ld mw mx my ls ij bi translated">另外，汇编语言很接近硬件，这很有趣。</p><figure class="ns nt nu nv gt is gh gi paragraph-image"><div role="button" tabindex="0" class="nw nx di ny bf nz"><div class="gh gi nr"><img src="../Images/999f16aa4fbf5f860c480c4c76be55b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ERBNdVjXjgnhYsf0OZd5_w.png"/></div></div></figure><h1 id="2cae" class="mz kn ix bd ko na nb nc kr nd ne nf ku kd ng ke ky kg nh kh lc kj ni kk lg nj bi translated">一些背景</h1><p id="b05b" class="pw-post-body-paragraph mk ml ix lk b ll lm jy mn ln lo kb mp kv oa mr ms kz ob mu mv ld oc mx my ls ij bi translated">为了运行汇编语言程序，首先，编译器创建一个目标代码文件(<strong class="lk iy">)。obj </strong>。接下来，必须将目标代码文件链接到可执行文件中。链接可以通过编译器或单独的链接器进程来完成。</p><h1 id="0a49" class="mz kn ix bd ko na nb nc kr nd ne nf ku kd ng ke ky kg nh kh lc kj ni kk lg nj bi translated">准备</h1><p id="b95c" class="pw-post-body-paragraph mk ml ix lk b ll lm jy mn ln lo kb mp kv oa mr ms kz ob mu mv ld oc mx my ls ij bi translated">准备编写汇编语言可能有点令人困惑。有许多工具可以编译和链接汇编。哪些工具在给定的操作系统上工作可能并不明显，该操作系统支持编译成与给定处理器兼容并且与调试软件兼容的机器二进制代码。在找到一个运行良好的解决方案之前，我尝试了许多关于编译、链接和调试的选项。我试验的一些工具是</p><ul class=""><li id="b56b" class="li lj ix lk b ll mm ln mo kv od kz oe ld of ls lt lu lv lw bi translated">GNU 编译器集合 (GCC):几种主要编程语言的编译器的集成发行版。</li><li id="6c3a" class="li lj ix lk b ll ly ln lz kv ma kz mb ld mc ls lt lu lv lw bi translated"><a class="ae lx" href="https://linux.die.net/man/1/g++" rel="noopener ugc nofollow" target="_blank"> g++ </a> : GNU project C 和 C++编译器</li><li id="03f4" class="li lj ix lk b ll ly ln lz kv ma kz mb ld mc ls lt lu lv lw bi translated">全网汇编器 (NASM):为可移植性和模块化而设计的汇编器。支持<a class="ae lx" href="https://en.wikipedia.org/wiki/X86" rel="noopener ugc nofollow" target="_blank"> 80x86 </a>和<a class="ae lx" href="https://en.wikipedia.org/wiki/X86-64" rel="noopener ugc nofollow" target="_blank">x86–64</a>(支持特定指令集的处理器系列)</li><li id="741a" class="li lj ix lk b ll ly ln lz kv ma kz mb ld mc ls lt lu lv lw bi translated"><a class="ae lx" href="http://yasm.tortall.net/releases/Release1.3.0.html" rel="noopener ugc nofollow" target="_blank"> yasm </a>:设计用于支持多种汇编语法的汇编程序。</li><li id="9e97" class="li lj ix lk b ll ly ln lz kv ma kz mb ld mc ls lt lu lv lw bi translated"><a class="ae lx" href="https://ftp.gnu.org/old-gnu/Manuals/ld-2.9.1/html_node/ld_3.html" rel="noopener ugc nofollow" target="_blank"> ld </a>:合并多个目标文件和档案文件，重新定位它们的数据并绑定符号引用。通常，编译程序的最后一步是运行 ld。</li><li id="fb55" class="li lj ix lk b ll ly ln lz kv ma kz mb ld mc ls lt lu lv lw bi translated">GNU 项目调试器 (gdb):允许你看到另一个程序执行时“内部”发生了什么</li><li id="3722" class="li lj ix lk b ll ly ln lz kv ma kz mb ld mc ls lt lu lv lw bi translated"><a class="ae lx" href="https://clang.llvm.org/get_started.html" rel="noopener ugc nofollow" target="_blank">铿锵</a>:兼容 GCC 的编译器驱动程序</li></ul><figure class="ns nt nu nv gt is gh gi paragraph-image"><div role="button" tabindex="0" class="nw nx di ny bf nz"><div class="gh gi nr"><img src="../Images/e10c8a53d2ebd9f70f58d9c3b8506ce4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yw6-eTE6rxhYGewHJwMTMg.png"/></div></div></figure><p id="9229" class="pw-post-body-paragraph mk ml ix lk b ll mm jy mn ln mo kb mp kv mq mr ms kz mt mu mv ld mw mx my ls ij bi translated">我从 clang 开始，但是很难运行链接的可执行文件。</p><p id="d7c5" class="pw-post-body-paragraph mk ml ix lk b ll mm jy mn ln mo kb mp kv mq mr ms kz mt mu mv ld mw mx my ls ij bi translated">接下来，我尝试了用<code class="fe og oh oi oj b">NASM</code>编译和<code class="fe og oh oi oj b">ld</code>链接目标文件的组合。举个例子，</p><pre class="ns nt nu nv gt ok oj ol om aw on bi"><span id="9a66" class="km kn ix oj b gy oo op l oq or">$ nasm -f macho64 -o hello_world.o hello_world.asm<br/>$ ld hello_world.o -o hw<br/>$ ./hw</span></pre><p id="c26f" class="pw-post-body-paragraph mk ml ix lk b ll mm jy mn ln mo kb mp kv mq mr ms kz mt mu mv ld mw mx my ls ij bi translated">这在 Mac 上运行良好，直到你需要调试。<code class="fe og oh oi oj b">gdb</code>无法浏览从 macho64 目标文件链接的文件。这篇博客详细描述了一个类似的经历。不幸的是，<code class="fe og oh oi oj b">NASM</code>还不支持所需的 macho 调试格式。</p><p id="1b67" class="pw-post-body-paragraph mk ml ix lk b ll mm jy mn ln mo kb mp kv mq mr ms kz mt mu mv ld mw mx my ls ij bi translated">上面链接的博客建议使用虚拟机来运行 Linux，其支持的汇编语言格式支持通过<code class="fe og oh oi oj b">NASM.</code>进行调试。然而，运行虚拟机是相当繁重的，一个简单的 docker 容器应该可以完成这项工作。</p><h1 id="4951" class="mz kn ix bd ko na nb nc kr nd ne nf ku kd ng ke ky kg nh kh lc kj ni kk lg nj bi translated">TLDR；如何在 Docker 容器中使用 GDB</h1><p id="d153" class="pw-post-body-paragraph mk ml ix lk b ll lm jy mn ln lo kb mp kv oa mr ms kz ob mu mv ld oc mx my ls ij bi translated">该<a class="ae lx" href="https://github.com/tonyOreglia/unique-word-counter/blob/master/Dockerfile" rel="noopener ugc nofollow" target="_blank"> Dockerfile </a>支持使用<code class="fe og oh oi oj b">NASM</code>编译 x86–64 汇编代码，与<code class="fe og oh oi oj b">gcc</code>(或<code class="fe og oh oi oj b">ld</code>链接，用<code class="fe og oh oi oj b">gdb.</code>调试</p><p id="fa39" class="pw-post-body-paragraph mk ml ix lk b ll mm jy mn ln mo kb mp kv mq mr ms kz mt mu mv ld mw mx my ls ij bi translated">Docker 容器必须使用选项<code class="fe og oh oi oj b">--cap-add=SYS_PTRACE</code>和<code class="fe og oh oi oj b">--security-opt seccomp=unconfined</code>运行，以便<code class="fe og oh oi oj b">gdb</code>完全发挥作用:</p><pre class="ns nt nu nv gt ok oj ol om aw on bi"><span id="8fc0" class="km kn ix oj b gy oo op l oq or">$ docker run --rm -it --cap-add=SYS_PTRACE --security-opt seccomp=unconfined -v "$(current_dir)":/app -w /app &lt;DOCKER-IMAGE-NAME&gt;</span></pre><figure class="ns nt nu nv gt is gh gi paragraph-image"><div role="button" tabindex="0" class="nw nx di ny bf nz"><div class="gh gi os"><img src="../Images/03ce85a583ca9023bfe7678212e73afc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z9B13VC-sJLpeHY-YAVULw.jpeg"/></div></div></figure><h1 id="7281" class="mz kn ix bd ko na nb nc kr nd ne nf ku kd ng ke ky kg nh kh lc kj ni kk lg nj bi translated">获取上面的命令</h1><p id="afc1" class="pw-post-body-paragraph mk ml ix lk b ll lm jy mn ln lo kb mp kv oa mr ms kz ob mu mv ld oc mx my ls ij bi translated">我最初决定在 Linux docker 容器中编译、链接和调试汇编代码程序，以启用 Mac OS 上不支持的调试选项。</p><p id="cc85" class="pw-post-body-paragraph mk ml ix lk b ll mm jy mn ln mo kb mp kv mq mr ms kz mt mu mv ld mw mx my ls ij bi translated">然而，尽管得到了所有这些设置，<code class="fe og oh oi oj b">gdb</code>仍然无法在执行过程中中断。它报告了以下错误:</p><pre class="ns nt nu nv gt ok oj ol om aw on bi"><span id="fb0e" class="km kn ix oj b gy oo op l oq or">warning: Error disabling address space randomization: Operation not permitted</span></pre><p id="afbc" class="pw-post-body-paragraph mk ml ix lk b ll mm jy mn ln mo kb mp kv mq mr ms kz mt mu mv ld mw mx my ls ij bi translated">听起来像是<code class="fe og oh oi oj b">gdb</code>需要控制寻址空间，但是 Docker 不允许这种控制。</p><h1 id="feaa" class="mz kn ix bd ko na nb nc kr nd ne nf ku kd ng ke ky kg nh kh lc kj ni kk lg nj bi translated">如何解决这个问题</h1><p id="9374" class="pw-post-body-paragraph mk ml ix lk b ll lm jy mn ln lo kb mp kv oa mr ms kz ob mu mv ld oc mx my ls ij bi translated">在<a class="ae lx" href="https://stackoverflow.com/questions/35860527/warning-error-disabling-address-space-randomization-operation-not-permitted" rel="noopener ugc nofollow" target="_blank">堆栈溢出</a>中发现的建议是使用以下选项运行 Docker:</p><pre class="ns nt nu nv gt ok oj ol om aw on bi"><span id="ea40" class="km kn ix oj b gy oo op l oq or">docker run --cap-add=SYS_PTRACE --security-opt seccomp=unconfined</span></pre><p id="f6af" class="pw-post-body-paragraph mk ml ix lk b ll mm jy mn ln mo kb mp kv mq mr ms kz mt mu mv ld mw mx my ls ij bi translated">果然，包括这些选项似乎都整理出来了<code class="fe og oh oi oj b">gdb</code>。使用这些命令运行 Docker 容器外壳，然后使用<code class="fe og oh oi oj b">gdb</code>使<code class="fe og oh oi oj b">gdb breakpoints</code>工作:</p><pre class="ns nt nu nv gt ok oj ol om aw on bi"><span id="5814" class="km kn ix oj b gy oo op l oq or">(gdb) disass _start<br/>Dump of assembler code for function _start:<br/>   0x00000000004000b0 &lt;+0&gt;:     mov    $0x1,%eax<br/>   0x00000000004000b5 &lt;+5&gt;:     mov    $0x1,%edi<br/>   0x00000000004000ba &lt;+10&gt;:    movabs $0x6000d8,%rsi<br/>   0x00000000004000c4 &lt;+20&gt;:    mov    $0xe,%edx<br/>   0x00000000004000c9 &lt;+25&gt;:    syscall<br/>   0x00000000004000cb &lt;+27&gt;:    mov    $0x3c,%eax<br/>   0x00000000004000d0 &lt;+32&gt;:    xor    %rdi,%rdi<br/>   0x00000000004000d3 &lt;+35&gt;:    syscall<br/>End of assembler dump.<br/>(gdb) break *0x4000b0<br/>Breakpoint 1 at 0x4000b0: file hellow.asm, line 8.<br/>(gdb) run<br/>Starting program: /app/hw<br/>Breakpoint 1, _start () at hellow.asm:8<br/>8         mov rax, 1<br/>(gdb)</span></pre><p id="a2c3" class="pw-post-body-paragraph mk ml ix lk b ll mm jy mn ln mo kb mp kv mq mr ms kz mt mu mv ld mw mx my ls ij bi translated">不幸的是，似乎还有一个问题。当我试图单步执行一个程序时，我得到了奇怪的行为:</p><pre class="ns nt nu nv gt ok oj ol om aw on bi"><span id="0d0e" class="km kn ix oj b gy oo op l oq or">Breakpoint 1, 0x0000000000400110 in _start ()<br/>(gdb) s<br/>Single stepping until exit from function _start,<br/>which has no line number information.</span></pre><p id="65d1" class="pw-post-body-paragraph mk ml ix lk b ll mm jy mn ln mo kb mp kv mq mr ms kz mt mu mv ld mw mx my ls ij bi translated">我无法单步执行函数 start。</p><p id="75be" class="pw-post-body-paragraph mk ml ix lk b ll mm jy mn ln mo kb mp kv mq mr ms kz mt mu mv ld mw mx my ls ij bi translated">经过一番挖掘，我找到了这种奇怪行为的原因。这里说<a class="ae lx" href="https://docs.docker.com/engine/security/seccomp/" rel="noopener ugc nofollow" target="_blank">这里说</a>的<code class="fe og oh oi oj b">seccomp</code>配置文件需要<code class="fe og oh oi oj b">seccomp 2.2.1</code>，这在 Ubuntu 14.04、Debian Wheezy 或 Debian Jessie 上都没有。因为最初使用的 Docker 基础映像是<a class="ae lx" href="https://github.com/tonyOreglia/unique-word-counter/blob/master/Dockerfile#L1" rel="noopener ugc nofollow" target="_blank"> Debian Jessie </a>，所以<code class="fe og oh oi oj b">seccomp</code>选项没有效果。</p><p id="6dc0" class="pw-post-body-paragraph mk ml ix lk b ll mm jy mn ln mo kb mp kv mq mr ms kz mt mu mv ld mw mx my ls ij bi translated">为了解决这个问题，<a class="ae lx" href="https://github.com/tonyOreglia/unique-word-counter/blob/master/Dockerfile" rel="noopener ugc nofollow" target="_blank">基础映像</a>被切换到支持 seccomp 2.2.1 的 Alpine Linux。这很有效。关于如何在这种 Docker 容器中构建、运行和调试，参见 Makefile <a class="ae lx" href="https://github.com/tonyOreglia/unique-word-counter/blob/master/Makefile" rel="noopener ugc nofollow" target="_blank">这里的</a>。</p><h1 id="dd48" class="mz kn ix bd ko na nb nc kr nd ne nf ku kd ng ke ky kg nh kh lc kj ni kk lg nj bi translated">让我们深入挖掘</h1><h2 id="0432" class="km kn ix bd ko kp kq dn kr ks kt dp ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">论点解释</h2><pre class="ns nt nu nv gt ok oj ol om aw on bi"><span id="96b5" class="km kn ix oj b gy oo op l oq or">docker run --cap-add=SYS_PTRACE --security-opt seccomp=unconfined</span></pre><p id="4c0f" class="pw-post-body-paragraph mk ml ix lk b ll mm jy mn ln mo kb mp kv mq mr ms kz mt mu mv ld mw mx my ls ij bi translated">……实际上<code class="fe og oh oi oj b">cap-add</code>和<code class="fe og oh oi oj b">security-opt</code>在做什么？</p><h1 id="a0df" class="mz kn ix bd ko na nb nc kr nd ne nf ku kd ng ke ky kg nh kh lc kj ni kk lg nj bi translated">cap-add</h1><p id="683c" class="pw-post-body-paragraph mk ml ix lk b ll lm jy mn ln lo kb mp kv oa mr ms kz ob mu mv ld oc mx my ls ij bi translated">从<a class="ae lx" href="https://docs.docker.com/engine/reference/run/#operator-exclusive-options" rel="noopener ugc nofollow" target="_blank"> Docker 参考</a>，<code class="fe og oh oi oj b">--cap-add</code>选项允许用户添加 Linux 功能。选项<code class="fe og oh oi oj b">SYS_PTRACE</code>支持使用 ptrace(2)跟踪任意进程。</p><p id="6ad8" class="pw-post-body-paragraph mk ml ix lk b ll mm jy mn ln mo kb mp kv mq mr ms kz mt mu mv ld mw mx my ls ij bi translated">最后，从 ptrace 的<a class="ae lx" href="https://www.systutorials.com/docs/linux/man/2-ptrace/" rel="noopener ugc nofollow" target="_blank"> Linux 手册页:</a></p><pre class="ns nt nu nv gt ok oj ol om aw on bi"><span id="7f4f" class="km kn ix oj b gy oo op l oq or">The ptrace() system call provides a means by which one process (the "tracer") may observe and control the execution of another process (the "tracee"), and examine and change the tracee's memory and registers. It is primarily used to implement breakpoint debugging and system call tracing.</span></pre><p id="2884" class="pw-post-body-paragraph mk ml ix lk b ll mm jy mn ln mo kb mp kv mq mr ms kz mt mu mv ld mw mx my ls ij bi translated">好的。这是有道理的。GDB 需要使用 ptrace 来设置断点，但是默认情况下，Docker 不允许该功能。</p><h1 id="fad0" class="mz kn ix bd ko na nb nc kr nd ne nf ku kd ng ke ky kg nh kh lc kj ni kk lg nj bi translated">安全性-opt seccomp=unconfined</h1><p id="9580" class="pw-post-body-paragraph mk ml ix lk b ll lm jy mn ln lo kb mp kv oa mr ms kz ob mu mv ld oc mx my ls ij bi translated">关于另一个推荐选项(<code class="fe og oh oi oj b">--security-opt seccomp=unconfined</code>)，经过一番挖掘，我发现可以通过指定<code class="fe og oh oi oj b">--security-opt</code>标志来覆盖每个容器的默认标签方案。见<a class="ae lx" href="https://docs.docker.com/engine/reference/run/#security-configuration" rel="noopener ugc nofollow" target="_blank">此处</a></p><p id="08c2" class="pw-post-body-paragraph mk ml ix lk b ll mm jy mn ln mo kb mp kv mq mr ms kz mt mu mv ld mw mx my ls ij bi translated">Docker 中的标签方案是什么？</p><p id="ab73" class="pw-post-body-paragraph mk ml ix lk b ll mm jy mn ln mo kb mp kv mq mr ms kz mt mu mv ld mw mx my ls ij bi translated">Docker 标签是一种将元数据应用于 Docker 对象的机制，包括:</p><ul class=""><li id="887f" class="li lj ix lk b ll mm ln mo kv od kz oe ld of ls lt lu lv lw bi translated">形象</li><li id="0c4a" class="li lj ix lk b ll ly ln lz kv ma kz mb ld mc ls lt lu lv lw bi translated">容器</li><li id="0f73" class="li lj ix lk b ll ly ln lz kv ma kz mb ld mc ls lt lu lv lw bi translated">本地守护程序</li><li id="855d" class="li lj ix lk b ll ly ln lz kv ma kz mb ld mc ls lt lu lv lw bi translated">卷</li><li id="a00c" class="li lj ix lk b ll ly ln lz kv ma kz mb ld mc ls lt lu lv lw bi translated">网络</li><li id="33cc" class="li lj ix lk b ll ly ln lz kv ma kz mb ld mc ls lt lu lv lw bi translated">群集节点</li><li id="682d" class="li lj ix lk b ll ly ln lz kv ma kz mb ld mc ls lt lu lv lw bi translated">群体服务</li></ul><p id="977d" class="pw-post-body-paragraph mk ml ix lk b ll mm jy mn ln mo kb mp kv mq mr ms kz mt mu mv ld mw mx my ls ij bi translated">有关使用 GDB 调试汇编代码的更多信息，请参见此处的<a class="ae lx" href="http://web.cecs.pdx.edu/~apt/cs491/gdb.pdf" rel="noopener ugc nofollow" target="_blank">和此处的</a>和<a class="ae lx" href="https://www.cs.swarthmore.edu/~newhall/cs31/resources/ia32_gdb.php" rel="noopener ugc nofollow" target="_blank"/>。这里还有<a class="ae lx" href="https://www.cs.umb.edu/~cheungr/cs341/Using_gdb_for_Assembly.pdf" rel="noopener ugc nofollow" target="_blank">的</a></p><h1 id="f962" class="mz kn ix bd ko na nb nc kr nd ne nf ku kd ng ke ky kg nh kh lc kj ni kk lg nj bi translated">使用 Docker 编译、链接、运行和调试汇编语言代码</h1><p id="34b3" class="pw-post-body-paragraph mk ml ix lk b ll lm jy mn ln lo kb mp kv oa mr ms kz ob mu mv ld oc mx my ls ij bi translated">关于在 Docker 容器上编译、链接、运行和调试汇编代码的命令，参见<a class="ae lx" href="https://github.com/tonyOreglia/unique-word-counter/blob/master/Makefile" rel="noopener ugc nofollow" target="_blank"> Makefile </a>。为方便起见，复制如下:</p><p id="d8c9" class="pw-post-body-paragraph mk ml ix lk b ll mm jy mn ln mo kb mp kv mq mr ms kz mt mu mv ld mw mx my ls ij bi translated"><strong class="lk iy">构建和链接装配</strong></p><p id="f3c3" class="pw-post-body-paragraph mk ml ix lk b ll mm jy mn ln mo kb mp kv mq mr ms kz mt mu mv ld mw mx my ls ij bi translated"><code class="fe og oh oi oj b">docker run --rm -v $(current_dir):/app -w /app linux-assembly sh -c "nasm -f elf64 -F dwarf -g $(asm).asm &amp;&amp; ld -m elf_x86_64 $(asm).o"</code></p><p id="e38c" class="pw-post-body-paragraph mk ml ix lk b ll mm jy mn ln mo kb mp kv mq mr ms kz mt mu mv ld mw mx my ls ij bi translated"><strong class="lk iy">运行可执行文件</strong></p><p id="1b86" class="pw-post-body-paragraph mk ml ix lk b ll mm jy mn ln mo kb mp kv mq mr ms kz mt mu mv ld mw mx my ls ij bi translated"><code class="fe og oh oi oj b">docker run --rm -v "$(current_dir)":/app -w /app linux-assembly sh -c "./a.out"</code></p><p id="ebb9" class="pw-post-body-paragraph mk ml ix lk b ll mm jy mn ln mo kb mp kv mq mr ms kz mt mu mv ld mw mx my ls ij bi translated"><strong class="lk iy">调试</strong></p><p id="a67e" class="pw-post-body-paragraph mk ml ix lk b ll mm jy mn ln mo kb mp kv mq mr ms kz mt mu mv ld mw mx my ls ij bi translated"><code class="fe og oh oi oj b">docker run --rm -it --cap-add=SYS_PTRACE --security-opt seccomp=unconfined -v "$(current_dir)":/app -w /app linux-assembly sh -c "gdb a.out"</code></p><h1 id="336c" class="mz kn ix bd ko na nb nc kr nd ne nf ku kd ng ke ky kg nh kh lc kj ni kk lg nj bi translated">找出有效的开发周期</h1><p id="37e7" class="pw-post-body-paragraph mk ml ix lk b ll lm jy mn ln lo kb mp kv oa mr ms kz ob mu mv ld oc mx my ls ij bi translated">既然我已经想出了如何让 GDB 在 Docker 中正常工作，下一步就是找到一个高效的开发周期。</p><p id="309a" class="pw-post-body-paragraph mk ml ix lk b ll mm jy mn ln mo kb mp kv mq mr ms kz mt mu mv ld mw mx my ls ij bi translated">当连接到 Docker 容器时，我更喜欢使用<a class="ae lx" href="https://code.visualstudio.com/" rel="noopener ugc nofollow" target="_blank"> VS 代码</a>而不是类似<code class="fe og oh oi oj b">vim</code>的东西进行开发。问题是如何在 VS 代码上进行本地开发，然后快速编译、链接和运行(在调试模式下)现在设置好的 docker 容器上的代码？</p><p id="66ca" class="pw-post-body-paragraph mk ml ix lk b ll mm jy mn ln mo kb mp kv mq mr ms kz mt mu mv ld mw mx my ls ij bi translated">点击这里查看下一篇帖子，了解如何准确设置这个工作流<a class="ae lx" href="https://medium.com/@tony.oreglia/finding-an-efficient-development-cycle-for-writing-assembly-language-be2092e6db6a" rel="noopener">。</a></p></div></div>    
</body>
</html>