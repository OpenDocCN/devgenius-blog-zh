<html>
<head>
<title>(Swift) Unleash Protocol-Oriented Programming</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">(Swift)释放面向协议的编程</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/swift-unleash-protocol-oriented-programming-ac09ca636fda?source=collection_archive---------20-----------------------#2020-07-08">https://blog.devgenius.io/swift-unleash-protocol-oriented-programming-ac09ca636fda?source=collection_archive---------20-----------------------#2020-07-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div class="gh gi jk"><img src="../Images/d4dcf8025a34259afe8f0460c4573e1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1366/format:webp/1*wae2IRpy36mERZboDecuWg.jpeg"/></div></figure><h1 id="0344" class="jr js in bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">首先，什么是面向协议的编程？</h1><p id="f75f" class="pw-post-body-paragraph kp kq in kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">如果你已经知道了，让我们继续如果没有，你应该去读一读这篇来自<a class="ln lo ep" href="https://medium.com/u/4054fbebc193?source=post_page-----ac09ca636fda--------------------------------" rel="noopener" target="_blank">剑田儿岛</a> <br/> <a class="ae lp" href="https://medium.com/@KentaKodashima/swift-understanding-protocol-oriented-programming-bbef282ae922" rel="noopener"> (Swift)理解面向协议编程</a>的好文章</p><h1 id="f15e" class="jr js in bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">为什么我们需要释放它？有皮带吗？</h1><p id="8379" class="pw-post-body-paragraph kp kq in kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">是的，一个主要的问题，不幸的是，Swift不允许我们在扩展中存储属性，编译器对我们咆哮。</p><blockquote class="lq"><p id="b981" class="lr ls in bd lt lu lv lw lx ly lz lm dk translated">"扩展不能包含存储属性"。</p></blockquote><p id="084f" class="pw-post-body-paragraph kp kq in kr b ks ma ku kv kw mb ky kz la mc lc ld le md lg lh li me lk ll lm ig bi translated">多痛苦啊，所以我们不能将现有的类扩展到需要存储属性的协议？这是否意味着我们不能在这些情况下使用面向协议的方法，我们必须继续使用继承？<br/>首先，有一个使用<strong class="kr io"> Obj-C </strong>运行时 <a class="ae lp" href="https://nshipster.com/associated-objects/" rel="noopener ugc nofollow" target="_blank"> <strong class="kr io">关联对象</strong> </a>的<a class="ae lp" href="https://pedrommcarrasco.github.io/posts/how-to-be-lazy-in-extensions/" rel="noopener ugc nofollow" target="_blank">解决方案，但它不是一个纯粹的快速解决方案，使用起来看起来确实不安全，就像Mattt Thompson <em class="mf">的<a class="ae lp" href="https://nshipster.com/associated-objects/" rel="noopener ugc nofollow" target="_blank">这篇链接</a>文章中解释的那样，“它应该被视为最后的手段”。但是一个纯粹的swift解决方案呢？这在swift是不可能实现的？</em></a></p></div><div class="ab cl mg mh hr mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ig ih ii ij ik"><h1 id="0a41" class="jr js in bd jt ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk mr km kn ko bi translated">没有雨燕是真的厉害！总是有解决办法的！</h1><p id="5bf1" class="pw-post-body-paragraph kp kq in kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">在向我的朋友谷歌寻求帮助后，我找到了这篇来自<a class="ln lo ep" href="https://medium.com/u/c980828c9632?source=post_page-----ac09ca636fda--------------------------------" rel="noopener" target="_blank">科斯坦蒂诺·皮斯塔尼亚</a> <br/> <a class="ae lp" href="https://medium.com/@valv0/computed-properties-and-extensions-a-pure-swift-approach-64733768112c" rel="noopener">存储属性和扩展的好文章:一种纯粹快捷的方法</a> <br/>他最后一次尝试提供了一个解决方案，让我们在这里:</p><figure class="ms mt mu mv gt jo"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="7267" class="pw-post-body-paragraph kp kq in kr b ks my ku kv kw mz ky kz la na lc ld le nb lg lh li nc lk ll lm ig bi translated">这是一个非常有趣的方法，但是有一个限制(不能真正重用，必须为每个存储的属性重写这个模式)和一个主要问题(内存泄漏，因为这个静态数组从不清空任何值)</p></div><div class="ab cl mg mh hr mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ig ih ii ij ik"><h1 id="8658" class="jr js in bd jt ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk mr km kn ko bi translated">可重复使用且无泄漏的解决方案！</h1><p id="3a87" class="pw-post-body-paragraph kp kq in kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">因此，对于之前来自<a class="ln lo ep" href="https://medium.com/u/c980828c9632?source=post_page-----ac09ca636fda--------------------------------" rel="noopener" target="_blank">科斯坦蒂诺·皮斯塔尼亚</a>的解决方案，他使用基于字符串密钥的地图得出了一个解决方案，他留下了这样的评论:</p><blockquote class="nd ne nf"><p id="1750" class="kp kq mf kr b ks my ku kv kw mz ky kz ng na lc ld nh nb lg lh ni nc lk ll lm ig bi translated">"此外，我想通过使用类似指针的内存地址来改进散列表键机制."</p></blockquote><h2 id="f37b" class="nj js in bd jt nk nl dn jx nm nn dp kb la no np kf le nq nr kj li ns nt kn nu bi translated">使用弱引用作为键怎么样？</h2><p id="0837" class="pw-post-body-paragraph kp kq in kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">通过创建一个<strong class="kr io">弱</strong>容器(<strong class="kr io"> @PropertyWrapper </strong>)，我们可以在序列上存储弱值</p><figure class="ms mt mu mv gt jo"><div class="bz fp l di"><div class="mw mx l"/></div></figure><h2 id="7243" class="nj js in bd jt nk nl dn jx nm nn dp kb la no np kf le nq nr kj li ns nt kn nu bi translated">好吧，但是怎么做呢，既然虚弱的<anyobject>这不是hashable吗？</anyobject></h2><p id="dfc7" class="pw-post-body-paragraph kp kq in kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">让我们把我的<strong class="kr io">弱</strong>容器<strong class="kr io">做成可哈的</strong>。</p><h2 id="cc36" class="nj js in bd jt nk nl dn jx nm nn dp kb la no np kf le nq nr kj li ns nt kn nu bi translated">但是既然v <strong class="ak">值</strong>是类型化的<strong class="ak"> AnyObject </strong>又如何呢？</h2><p id="1d33" class="pw-post-body-paragraph kp kq in kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated"><strong class="kr io"> AnyObject </strong> <strong class="kr io">表示</strong>的任何引用类型，并且所有引用类型化的实例都有一个唯一的标识符，它们的<strong class="kr io">内存地址</strong>，所以<strong class="kr io">让</strong> <strong class="kr io">用</strong>这个<strong class="kr io">到</strong> <strong class="kr io">构建</strong>我们的<strong class="kr io"> hash。</strong></p><figure class="ms mt mu mv gt jo"><div class="bz fp l di"><div class="mw mx l"/></div></figure><h2 id="9d87" class="nj js in bd jt nk nl dn jx nm nn dp kb la no np kf le nq nr kj li ns nt kn nu bi translated">弱引用作为一个键将如何解决这些问题？</h2><p id="4726" class="pw-post-body-paragraph kp kq in kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">使用弱引用作为键将为我们提供一个指示器，以知道何时可以释放与对象实例相关联的属性。<br/> <strong class="kr io">当</strong><strong class="kr io">弱</strong>映射<strong class="kr io">键</strong>将为零时，我们可以简单地<strong class="kr io">将</strong>这个条目<strong class="kr io">从</strong>散列表<strong class="kr io">中移除。</strong></p><h2 id="1f1e" class="nj js in bd jt nk nl dn jx nm nn dp kb la no np kf le nq nr kj li ns nt kn nu bi translated">现在让我们创建静态hashmap容器！</h2><p id="9d01" class="pw-post-body-paragraph kp kq in kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">好的，我们知道我们将使用<strong class="kr io">弱&lt; AnyObject &gt; </strong>作为键，但是值呢？<br/>为了可重用，我们希望能够存储任何类型的值，并且不止一个，所以让我们使用<strong class="kr io">【Any】。</strong></p><p id="84f8" class="pw-post-body-paragraph kp kq in kr b ks my ku kv kw mz ky kz la na lc ld le nb lg lh li nc lk ll lm ig bi translated">由于键是基于弱引用的，我们无法控制该引用何时包含nil，从而导致key = "hash(nil)"(弱<nil>)。<br/>因此，如果在我的映射中的两次读取或写入之间，两个或更多的键对象被释放(因此弱引用变成零)，这可能导致在我的hashmap中有两个或更多相同的hashkey，从而导致崩溃。</nil></p><h2 id="41db" class="nj js in bd jt nk nl dn jx nm nn dp kb la no np kf le nq nr kj li ns nt kn nu bi translated">怎样才能避免这种因为重复密钥而导致的崩溃呢？</h2><p id="f320" class="pw-post-body-paragraph kp kq in kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">在hashmap中访问或设置值之前，我们可以删除所有对应于弱<nil>的键。</nil></p><h2 id="cf09" class="nj js in bd jt nk nl dn jx nm nn dp kb la no np kf le nq nr kj li ns nt kn nu bi translated">线程安全呢？</h2><p id="f4e2" class="pw-post-body-paragraph kp kq in kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">我们可以使用并发调度队列来确保线程安全！</p><p id="368b" class="pw-post-body-paragraph kp kq in kr b ks my ku kv kw mz ky kz la na lc ld le nb lg lh li nc lk ll lm ig bi translated"><strong class="kr io">如何在我的任意数组中找到对象？</strong></p><p id="356a" class="pw-post-body-paragraph kp kq in kr b ks my ku kv kw mz ky kz la na lc ld le nb lg lh li nc lk ll lm ig bi translated">我决定在我的实现中让getter基于值的类型，这样它将返回第一个类型为wanted的元素。不幸的是，这限制了我们在一个对象的每个实例中只能存储一个特定类型的值。</p><p id="c915" class="pw-post-body-paragraph kp kq in kr b ks my ku kv kw mz ky kz la na lc ld le nb lg lh li nc lk ll lm ig bi translated">为了得到一个值，我们可以通过类型来选择它。</p><figure class="ms mt mu mv gt jo"><div class="bz fp l di"><div class="mw mx l"/></div></figure><h2 id="507c" class="nj js in bd jt nk nl dn jx nm nn dp kb la no np kf le nq nr kj li ns nt kn nu bi translated">然后让我们创建一个访问器来访问这个PropertyData</h2><p id="49fe" class="pw-post-body-paragraph kp kq in kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">我的第一个想法是，让我们使用一个属性包装器来隐藏容器！不幸的是，Swift不允许你在非静态扩展属性上添加包装器，编译器又对我咆哮了。</p><blockquote class="lq"><p id="e108" class="lr ls in bd lt lu lv lw lx ly lz lm dk translated">在扩展内部声明的非静态属性“…”不能有包装</p></blockquote><p id="fb4f" class="pw-post-body-paragraph kp kq in kr b ks ma ku kv kw mb ky kz la mc lc ld le md lg lh li me lk ll lm ig bi translated">没关系，我们会挺过这种缺乏句法的困境。但是我决定仍然使用propertyWrapper，因为它完美地描述了我在做什么。</p><figure class="ms mt mu mv gt jo"><div class="bz fp l di"><div class="mw mx l"/></div></figure><h1 id="6932" class="jr js in bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">干得好！现在是点心时间(奖励)！</h1><p id="ec98" class="pw-post-body-paragraph kp kq in kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">经过这一漫长的旅程后，是时候体会这一解决方案的好处了！我们现在可以将一个现有的类扩展到需要存储属性的协议，而不必对它们进行子类化。</p><figure class="ms mt mu mv gt jo"><div class="bz fp l di"><div class="mw mx l"/></div></figure><h1 id="fa11" class="jr js in bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">结论</h1><p id="20cc" class="pw-post-body-paragraph kp kq in kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">这种解决方案有效，但是有一些限制，仍然可以改进。使用这种模式，我们可以重构很多代码，从面向对象转向面向协议，我们可以摆脱很多丑陋的继承；和特殊化来实现我们代码库的最佳性能。</p><p id="3a07" class="pw-post-body-paragraph kp kq in kr b ks my ku kv kw mz ky kz la na lc ld le nb lg lh li nc lk ll lm ig bi translated">局限性:</p><ul class=""><li id="bd83" class="nv nw in kr b ks my kw mz la nx le ny li nz lm oa ob oc od bi translated">只有当我们访问PropertyData时，内存清理才会发生。并且如果不进一步接近，将永远不会发生(因此仍然不是完全无泄漏的)</li><li id="1794" class="nv nw in kr b ks oe kw of la og le oh li oi lm oa ob oc od bi translated">我们不能在一个对象实例的PropertyData上存储同一类型的两个不同对象。</li></ul><p id="eedc" class="pw-post-body-paragraph kp kq in kr b ks my ku kv kw mz ky kz la na lc ld le nb lg lh li nc lk ll lm ig bi translated">解决方法:</p><ul class=""><li id="7cc0" class="nv nw in kr b ks my kw mz la nx le ny li nz lm oa ob oc od bi translated">我们可以存储数组或对象映射来存储多个对象。</li><li id="af61" class="nv nw in kr b ks oe kw of la og le oh li oi lm oa ob oc od bi translated">我们可以对StoredObject进行强子类化，使其唯一。</li></ul><p id="f168" class="pw-post-body-paragraph kp kq in kr b ks my ku kv kw mz ky kz la na lc ld le nb lg lh li nc lk ll lm ig bi translated">改进的空间和潜在的摆脱限制:</p><ul class=""><li id="5bb6" class="nv nw in kr b ks my kw mz la nx le ny li nz lm oa ob oc od bi translated">观察弱实例以“实时释放”它们的属性数据，并成为真正的无泄漏解决方案，而不必在每个set/get中过滤nil元素？(导致将PropertyData访问时间复杂度提高到实际O(N)之前的O(1))</li><li id="e8a9" class="nv nw in kr b ks oe kw of la og le oh li oi lm oa ob oc od bi translated">用字典替换地图上的对象数组，并更改getter值，以便能够在PropertyData上存储许多相同类型的对象？如果是这样，我们将需要一个子密钥，但如何尽可能无缝地做到这一点呢？使用选择器作为子项？将这个新子密钥与当前的密钥散列结合起来并保持一个数组怎么样？我看到了许多解决这个限制的方法，但是我不知道哪一个是最好的。</li></ul><p id="30a1" class="pw-post-body-paragraph kp kq in kr b ks my ku kv kw mz ky kz la na lc ld le nb lg lh li nc lk ll lm ig bi translated">希望你们中的一些人能提供建议来摆脱这些限制并改进这个解决方案！</p><h2 id="9a99" class="nj js in bd jt nk nl dn jx nm nn dp kb la no np kf le nq nr kj li ns nt kn nu bi translated">现成的解决方案:SwiftAssociatedObject</h2><p id="148f" class="pw-post-body-paragraph kp kq in kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">编辑09/07/2020:这让我在一个框架上发布了一个完整的关联对象的纯Swift实现，随时可用，开源并解决了这个解决方案的限制，而没有干扰ObjcRuntime！</p><div class="oj ok gp gr ol om"><a href="https://github.com/inso-/SwiftAssociatedObject" rel="noopener  ugc nofollow" target="_blank"><div class="on ab fo"><div class="oo ab op cl cj oq"><h2 class="bd io gy z fp or fr fs os fu fw im bi translated">inso-/SwiftAssociatedObject</h2><div class="ot l"><h3 class="bd b gy z fp or fr fs os fu fw dk translated">关联对象的纯快速实现。通过创建一个…</h3></div><div class="ou l"><p class="bd b dl z fp or fr fs os fu fw dk translated">github.com</p></div></div><div class="ov l"><div class="ow l ox oy oz ov pa jp om"/></div></div></a></div><p id="eccf" class="pw-post-body-paragraph kp kq in kr b ks my ku kv kw mz ky kz la na lc ld le nb lg lh li nc lk ll lm ig bi translated">使用SwiftPackageManager/CocoaPod或Carthage将它添加到您的项目中，并释放面向协议的编程！</p><h1 id="f2eb" class="jr js in bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">参考</h1><p id="31cf" class="pw-post-body-paragraph kp kq in kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated"><a class="ln lo ep" href="https://medium.com/u/4054fbebc193?source=post_page-----ac09ca636fda--------------------------------" rel="noopener" target="_blank">岸田文雄</a> : <a class="ae lp" href="https://medium.com/@KentaKodashima/swift-understanding-protocol-oriented-programming-bbef282ae922" rel="noopener"> (Swift)理解面向协议的编程</a></p><p id="8d55" class="pw-post-body-paragraph kp kq in kr b ks my ku kv kw mz ky kz la na lc ld le nb lg lh li nc lk ll lm ig bi translated"><a class="ln lo ep" href="https://medium.com/u/c980828c9632?source=post_page-----ac09ca636fda--------------------------------" rel="noopener" target="_blank">科斯坦蒂诺·皮斯塔格纳</a> : <a class="ae lp" href="https://medium.com/@valv0/computed-properties-and-extensions-a-pure-swift-approach-64733768112c" rel="noopener">存储属性和扩展:一种纯粹快捷的方法</a></p><p id="fef5" class="pw-post-body-paragraph kp kq in kr b ks my ku kv kw mz ky kz la na lc ld le nb lg lh li nc lk ll lm ig bi translated"><a class="ae lp" href="https://nshipster.com/authors/mattt/" rel="noopener ugc nofollow" target="_blank">马特·汤普森@NSHipster </a> : <a class="ae lp" href="https://nshipster.com/associated-objects/" rel="noopener ugc nofollow" target="_blank">关联对象</a></p><p id="a9d4" class="pw-post-body-paragraph kp kq in kr b ks my ku kv kw mz ky kz la na lc ld le nb lg lh li nc lk ll lm ig bi translated"><a class="ln lo ep" href="https://medium.com/u/36ca53e721a?source=post_page-----ac09ca636fda--------------------------------" rel="noopener" target="_blank">佩德罗·卡拉斯科</a> : <a class="ae lp" href="https://pedrommcarrasco.github.io/posts/how-to-be-lazy-in-extensions/" rel="noopener ugc nofollow" target="_blank">如何在扩展中偷懒？</a></p></div></div>    
</body>
</html>