<html>
<head>
<title>Testing Asynchronous Message Driven Architecture</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">测试异步消息驱动架构</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/testing-asynchronous-message-driven-architecture-1e8a107d7029?source=collection_archive---------3-----------------------#2022-12-17">https://blog.devgenius.io/testing-asynchronous-message-driven-architecture-1e8a107d7029?source=collection_archive---------3-----------------------#2022-12-17</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/9cb1f82e79f56bbbd12cf18def2efd12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sH0KdRd-082SrzTcp8toRg.jpeg"/></div></div></figure><p id="1f23" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">测试是我们系统的重要组成部分。易于理解和修改的测试将有助于我们长期保持项目的良好状态。<br/>首先，我们可以从同步代码开始，但是迟早我们需要开始异步处理我们的部分流程，这就是消息驱动架构变得方便的时候。</p><p id="b3d6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">使用<code class="fe kt ku kv kw b">Message Driven Architecture</code>时，我们的主要目标是组件的松耦合、从问题中快速恢复以及处理高负载的可能性。<br/>然而，由于解耦和异步的处理方式，测试变得更具挑战性。</p><p id="9551" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">从这种测试的速度和维护的角度来看，测试这种架构很容易成为噩梦。<br/>在本文中，我们将致力于使用<a class="ae kx" href="https://blog.ecotone.tech/" rel="noopener ugc nofollow" target="_blank">生态交错带框架</a>中的示例，使这些测试快速、易于理解和编写。</p><h1 id="c352" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">异步执行</h1><p id="f417" class="pw-post-body-paragraph jv jw in jx b jy lw ka kb kc lx ke kf kg ly ki kj kk lz km kn ko ma kq kr ks ig bi translated">当我们处理同步代码时，编写测试非常简单。<br/>我们设立<code class="fe kt ku kv kw b">state</code>，我们称一些<code class="fe kt ku kv kw b">Class</code>或<code class="fe kt ku kv kw b">API</code>，我们<code class="fe kt ku kv kw b">assert</code>我们的期望。</p><p id="2497" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对于异步代码，我们有<code class="fe kt ku kv kw b">publisher of a message</code>(例如命令/事件)和<code class="fe kt ku kv kw b">message consumer</code>，它们在不同的进程中运行。如果我们想要测试完整场景，这使得测试变得更加棘手，因为它需要两个进程进行通信。</p><p id="7e10" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们的测试场景是下订单并向客户发送异步确认通知。</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><blockquote class="mh mi mj"><p id="07e7" class="jv jw mk jx b jy jz ka kb kc kd ke kf ml kh ki kj mm kl km kn mn kp kq kr ks ig bi translated"><em class="in"/><code class="fe kt ku kv kw b"><em class="in">asynchronous</em></code><em class="in">属性与通道(队列/传输)相关。<br/>可以运行与通道同名的消费者(</em> <code class="fe kt ku kv kw b"><em class="in">notifications</em></code> <em class="in">)来开始消费消息和执行我们的事件处理程序。</em></p></blockquote><h1 id="1a62" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">在不同的进程中运行发布者和消费者</h1><p id="51c6" class="pw-post-body-paragraph jv jw in jx b jy lw ka kb kc lx ke kf kg ly ki kj kk lz km kn ko ma kq kr ks ig bi translated">我们可以运行发布给定消息的测试用例(发布者端)，并在后台运行消费者。然后我们会循环等待我们的期望被实现。</p><p id="0f5c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然而，这种解决方案有一些缺点:</p><ul class=""><li id="f32f" class="mo mp in jx b jy jz kc kd kg mq kk mr ko ms ks mt mu mv mw bi translated">它增加了测试运行时间，因为现在我们引导新的过程</li><li id="d8c1" class="mo mp in jx b jy mx kc my kg mz kk na ko nb ks mt mu mv mw bi translated">调试变得很困难，因为它在后台运行，我们不能完全控制执行</li><li id="7dbb" class="mo mp in jx b jy mx kc my kg mz kk na ko nb ks mt mu mv mw bi translated">我们不能使用<code class="fe kt ku kv kw b">in memory</code> / <code class="fe kt ku kv kw b">dummy</code>实现，因为一个过程中的变化在第二个过程中是不可见的</li></ul><p id="b8c9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">有很多这样的测试会大大降低测试套件的速度。<br/>当测试套件失败时，可能很难调试原因，因为消费者进程是后台进程。<br/>除了由于缺乏共享内存堆栈，我们还需要构建一些工具来支持这一点(例如，在我们考虑测试失败之前，继续检查数据库中的状态是否已经改变了 X 秒)。</p><blockquote class="mh mi mj"><p id="0aab" class="jv jw mk jx b jy jz ka kb kc kd ke kf ml kh ki kj mm kl km kn mn kp kq kr ks ig bi translated">在单独的进程中运行 publisher 和 consumer 的最大优点是，这是最接近产品运行方式的方式。<br/>然而，这带来了巨大的成本，因为这些类型的测试很慢，很难调试，并且由于需要支持工具，经常开始偏离生产。</p></blockquote><p id="318e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当我们将运行消费者进程时，它将阻塞我们的测试套件，因为消费者在处理完给定的消息后将等待下一个消息。<br/>但是<code class="fe kt ku kv kw b">Consumers</code>可以实现，有可能拦截执行。<br/>拦截主要用于启动事务、记录日志和错误处理，但也可用于测试目的。使用这种技术，我们可以实现<code class="fe kt ku kv kw b">limit of handled messages</code>和<code class="fe kt ku kv kw b">execution time limit</code>。<br/> <code class="fe kt ku kv kw b">Handled message limit</code>将确保我们完成测试的速度与消息处理的速度一样快，<code class="fe kt ku kv kw b">execution time limit</code>另一方面在失败的情况下保护测试的完成。</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><blockquote class="mh mi mj"><p id="a2e1" class="jv jw mk jx b jy jz ka kb kc kd ke kf ml kh ki kj mm kl km kn mn kp kq kr ks ig bi translated">在测试中运行消费者时，一定要截取它。<br/>这将减少测试套件时间，并确保没有僵尸进程在后台运行。</p></blockquote><h1 id="f4ac" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">将异步代码作为同步代码运行</h1><p id="5aa4" class="pw-post-body-paragraph jv jw in jx b jy lw ka kb kc lx ke kf kg ly ki kj kk lz km kn ko ma kq kr ks ig bi translated">在大多数情况下，<code class="fe kt ku kv kw b">consuming process</code>实际上是同一个应用程序，这意味着我们实际上也可以从<code class="fe kt ku kv kw b">publishing process</code>运行它。</p><p id="6802" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在与我们的测试场景相同的流程中运行 consumer，将减少我们的测试套件时间，并使调试更加容易。<br/>它还将允许我们在内存实现中使用，因为更改将在同一流程中发生。这是一个巨大的优势，因为我们可以轻松地模拟特定场景。</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><blockquote class="mh mi mj"><p id="1842" class="jv jw mk jx b jy jz ka kb kc kd ke kf ml kh ki kj mm kl km kn mn kp kq kr ks ig bi translated"><em class="in">在同一个流程(测试场景)中运行发布者和消费者，仍然很像生产运行，因为执行的代码是相同的。</em></p></blockquote><h1 id="59b4" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">在内存通道中运行消费者</h1><p id="0a20" class="pw-post-body-paragraph jv jw in jx b jy lw ka kb kc lx ke kf kg ly ki kj kk lz km kn ko ma kq kr ks ig bi translated">在大多数情况下，当我们在幕后使用 real Message Broker 运行测试时，我们不能并行运行我们的测试。<br/>此外，当我们与 Message Broker 交互时，我们的测试场景比在内存实现中花费的时间要长得多。</p><p id="86f5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">被消费者消费的<code class="fe kt ku kv kw b">Message Queue</code>只是一个<code class="fe kt ku kv kw b">Message Channel</code>。如果我们的消费者实现是从特定的代理实现中抽象出来的，那么我们可以用<code class="fe kt ku kv kw b">In Memory Message Channel</code>来代替它。<br/>这正是 econtero 的情况，您可以根据自己的情况切换消息通道实现。</p><blockquote class="mh mi mj"><p id="0894" class="jv jw mk jx b jy jz ka kb kc kd ke kf ml kh ki kj mm kl km kn mn kp kq kr ks ig bi translated">使用消息通道的内存实现，可以加速测试并允许并行运行它们。</p></blockquote><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><h1 id="e696" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">从轮询切换到事件驱动</h1><p id="727c" class="pw-post-body-paragraph jv jw in jx b jy lw ka kb kc lx ke kf kg ly ki kj kk lz km kn ko ma kq kr ks ig bi translated"><code class="fe kt ku kv kw b">Pollable channels (Queues)</code>创建<code class="fe kt ku kv kw b"><a class="ae kx" href="https://blog.ecotone.tech/messaging/messaging-concepts/consumer#polling-consumer" rel="noopener ugc nofollow" target="_blank">Pollable consumers</a></code>，这意味着代码将被异步执行。<br/>第二个选项被称为<code class="fe kt ku kv kw b"><a class="ae kx" href="https://blog.ecotone.tech/messaging/messaging-concepts/consumer#event-driven-consumer" rel="noopener ugc nofollow" target="_blank">Event-Driven consumer</a></code>，这意味着代码被同步触发(想象同步事件/命令处理程序)。</p><p id="5726" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">生态区框架支持消息通道和不同的消费者实现，因此我们能够将代码从异步运行切换到同步运行，反之亦然。</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><blockquote class="mh mi mj"><p id="67a7" class="jv jw mk jx b jy jz ka kb kc kd ke kf ml kh ki kj mm kl km kn mn kp kq kr ks ig bi translated">有了好的消息传递框架，异步性就被抽象掉了，我们可以编写不知道消费过程的代码。这允许我们编写更简单的测试和切换 Message Broker 实现，而不会影响我们的产品代码。</p></blockquote><h1 id="ed2f" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">限制你的测试范围</h1><p id="f98c" class="pw-post-body-paragraph jv jw in jx b jy lw ka kb kc lx ke kf kg ly ki kj kk lz km kn ko ma kq kr ks ig bi translated">在消息传递体系结构中，给定的消息被多个处理程序使用的情况经常发生。然而，在给定的测试场景中，我们可能只对流程的一小部分感兴趣，我们希望跳过其余部分。</p><p id="4cac" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在生态交错带测试支持下，我们提供了给定测试场景下应解决的类别列表。这样，我们可以在给定的测试场景中轻松地测试我们代码库的一小部分。</p><pre class="mb mc md me gt nc kw nd bn ne nf bi"><span id="dd46" class="ng kz in kw b be nh ni l nj nk">$ecotoneTestSupport = EcotoneLite::bootstrapForTesting(<br/>	// pass list of classes that should be included in this test<br/>    [OrderService::class, OrderNotifier::class,<br/>    $dependencyContainer<br/>);</span></pre><h1 id="8071" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">摘要</h1><p id="3d7f" class="pw-post-body-paragraph jv jw in jx b jy lw ka kb kc lx ke kf kg ly ki kj kk lz km kn ko ma kq kr ks ig bi translated">由于解耦的本质和异步性，测试消息驱动架构可能具有挑战性。然而，它有很多优点，尤其是当系统增长时，这在某个时候成为一种需要。</p><p id="8223" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们可以用消息框架提供的良好支持工具来降低门槛。<br/>所以最终我们可以获得所有消息传递的好处，并且仍然能够编写简单而有效的测试。</p></div></div>    
</body>
</html>