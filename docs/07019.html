<html>
<head>
<title>Part #2: Memory Management in WASM</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">第 2 部分:WASM 的内存管理</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/part-2-memory-management-in-wasm-b4e8fc151c73?source=collection_archive---------11-----------------------#2022-02-19">https://blog.devgenius.io/part-2-memory-management-in-wasm-b4e8fc151c73?source=collection_archive---------11-----------------------#2022-02-19</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="4e6f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是我关于 WebAssembly 系列的第五篇文章。虽然我打算独立阅读本系列的每篇文章，但这篇文章借鉴了我们在内存管理文章  <em class="ki">的第一部分</em> <a class="ae kj" rel="noopener ugc nofollow" target="_blank" href="/part-1-memory-management-in-wasm-52195f9b707f"> <em class="ki">中的讨论。您可以查看参考资料部分链接的以前的帖子。</em></a></p><h2 id="5173" class="kk kl in bd km kn ko dn kp kq kr dp ks jv kt ku kv jz kw kx ky kd kz la lb lc bi translated">在开始之前</h2><p id="3bce" class="pw-post-body-paragraph jk jl in jm b jn ld jp jq jr le jt ju jv lf jx jy jz lg kb kc kd lh kf kg kh ig bi translated">这篇文章将<strong class="jm io">很大程度上</strong>依赖于对<a class="ae kj" href="https://www.typescriptlang.org/" rel="noopener ugc nofollow" target="_blank"> TypeScript </a>的熟悉，TypeScript 是 JavaScript 的强类型版本。语言的选择背后有两个主要原因。首先，TypeScript 与 JavaScript 非常相似。由于 JavaScript 无处不在，对于具有中等 JavaScript 知识水平的人来说，上面提到的例子很容易理解。下一个原因是<a class="ae kj" href="https://www.assemblyscript.org/compiler.html" rel="noopener ugc nofollow" target="_blank"> AssemblyScript 编译器</a>，它可以用来将 TypeScript 编译成 WASM。然后可以在我们的 JS + HTML 文件中调用它，以便在浏览器上查看。</p><p id="1416" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">也就是说，对于那些不熟悉的人来说，当我们远离传统的 JS 或链接到文档时，我将尝试解释使用特定代码片段背后的基本原理。</p><p id="56bd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但首先，在我们开始之前，我们需要概述一下我们将如何进行这个练习。</p><p id="1683" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">步骤#1: </strong>用 TypeScript 写代码。由于语法与 JavaScript 略有相似，这将大大降低入门门槛。</p><p id="57d5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">步骤#2: </strong>使用<a class="ae kj" href="https://www.assemblyscript.org/compiler.html" rel="noopener ugc nofollow" target="_blank">汇编脚本编译器</a>编译到 WASM。</p><p id="e87b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">步骤#3: </strong>加载&amp;在一个. js 文件中实例化 WASM 模块</p><p id="bf69" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">步骤#4: </strong>导入。js 文件转换成 HTML(这样我们就可以在浏览器上查看它)</p><p id="29d4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">步骤 5: 在浏览器上实际查看我们的代码</p><p id="66ea" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">通过这五个步骤，我们将创建两个简单的 web 应用程序&amp;演示</p><ul class=""><li id="f96d" class="li lj in jm b jn jo jr js jv lk jz ll kd lm kh ln lo lp lq bi translated">JavaScript 和 WASM 模块之间的值传递</li><li id="6dde" class="li lj in jm b jn lr jr ls jv lt jz lu kd lv kh ln lo lp lq bi translated">我们如何通过分配和释放来手动管理内存。</li></ul><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi lw"><img src="../Images/5656a95f9807dae1b334786ee02d867e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cwiwri-3GlEbvFM0Qnrt9w.png"/></div></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk translated">流动</figcaption></figure><p id="90ca" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下面的所有代码片段都可以在<a class="ae kj" href="https://github.com/divya-mohan0209/webassembly-blog-examples" rel="noopener ugc nofollow" target="_blank"> this </a> GitHub 仓库中找到。我们将通过重复上面提到的过程来看两个例子。在第一个例子中，我们将看看如何在 JavaScript 和用 TypeScript 编写的 WASM 模块之间传递数字。在这个例子结束的时候，我们将会对这是如何实现的有一个清晰的概念，在我们的下一篇文章中，我们将会讨论一个更复杂的关于数组如何传递的例子。</p><h1 id="138b" class="mm kl in bd km mn mo mp kp mq mr ms ks mt mu mv kv mw mx my ky mz na nb lb nc bi translated">示例 1:在 JavaScript 和用 TypeScript 编写的 WASM 模块之间传递数字</h1><h2 id="8a80" class="kk kl in bd km kn ko dn kp kq kr dp ks jv kt ku kv jz kw kx ky kd kz la lb lc bi translated">步骤 1:用 TypeScript 编写代码</h2><p id="7f81" class="pw-post-body-paragraph jk jl in jm b jn ld jp jq jr le jt ju jv lf jx jy jz lg kb kc kd lh kf kg kh ig bi translated">首先创建 addition.ts 文件，如下所示。</p><pre class="lx ly lz ma gt nd ne nf ng aw nh bi"><span id="f4c6" class="kk kl in ne b gy ni nj l nk nl"><strong class="ne io">//Sample code for addition</strong></span><span id="8e2e" class="kk kl in ne b gy nm nj l nk nl"><strong class="ne io">//Takes in two i32 values</strong></span><span id="e6b6" class="kk kl in ne b gy nm nj l nk nl"><strong class="ne io">//Returns their sum</strong></span><span id="3fb7" class="kk kl in ne b gy nm nj l nk nl"><strong class="ne io">export function add(a: i32, b: i32): i32 {</strong></span><span id="d7db" class="kk kl in ne b gy nm nj l nk nl"><strong class="ne io">return a + b;</strong></span><span id="98f4" class="kk kl in ne b gy nm nj l nk nl"><strong class="ne io">}</strong></span></pre><h2 id="7fcf" class="kk kl in bd km kn ko dn kp kq kr dp ks jv kt ku kv jz kw kx ky kd kz la lb lc bi translated">第二步:使用 AssemblyScript 编译器将它编译成 WASM</h2><p id="48bf" class="pw-post-body-paragraph jk jl in jm b jn ld jp jq jr le jt ju jv lf jx jy jz lg kb kc kd lh kf kg kh ig bi translated">为此，我们首先需要<a class="ae kj" href="https://nodejs.org/en/download/" rel="noopener ugc nofollow" target="_blank">和 npm </a>一起设置一个节点环境。完成后，执行以下命令来安装 AssemblyScript 编译器。</p><pre class="lx ly lz ma gt nd ne nf ng aw nh bi"><span id="75ba" class="kk kl in ne b gy ni nj l nk nl"><strong class="ne io">npm install -g assemblyscript</strong></span></pre><p id="4d9b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一旦上面的命令执行完毕，我们将把。ts 文件转换成 WASM 文件</p><pre class="lx ly lz ma gt nd ne nf ng aw nh bi"><span id="0b54" class="kk kl in ne b gy ni nj l nk nl"><strong class="ne io">asc addition.ts -b addition.wasm -t addition.wat</strong></span></pre><p id="72e8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">上面的命令产生二进制和文本格式的文件。</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi nn"><img src="../Images/ccefdb11fafe916aeab894614a5bf95e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U5rnD4KsU3iGveOdTtnOTA.png"/></div></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk translated">由此产生。wat 文件</figcaption></figure><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div class="gh gi no"><img src="../Images/9fc33be7c126f020e4df757e81024c9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1184/format:webp/1*mpRtBrvxFIJhHWucsF1W4g.png"/></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk translated">在 Windows 上使用<a class="ae kj" href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/format-hex?view=powershell-7.2" rel="noopener ugc nofollow" target="_blank">格式-十六进制实用程序的二进制表示</a></figcaption></figure><h2 id="4538" class="kk kl in bd km kn ko dn kp kq kr dp ks jv kt ku kv jz kw kx ky kd kz la lb lc bi translated"><strong class="ak">步骤#3:加载&amp;实例化. js 文件中的 WASM 模块</strong></h2><p id="b7e3" class="pw-post-body-paragraph jk jl in jm b jn ld jp jq jr le jt ju jv lf jx jy jz lg kb kc kd lh kf kg kh ig bi translated">我们通过调用<a class="ae kj" href="https://developer.mozilla.org/en-US/docs/WebAssembly" rel="noopener ugc nofollow" target="_blank">web assembly API</a>将 WASM 模块加载到我们的 JS 文件中。下面是整个 addition.js 文件的一个片段。</p><pre class="lx ly lz ma gt nd ne nf ng aw nh bi"><span id="7d64" class="kk kl in ne b gy ni nj l nk nl"><strong class="ne io">export const wasmBrowserInstantiate = async (wasmModuleUrl, importObject) =&gt; {</strong></span><span id="029a" class="kk kl in ne b gy nm nj l nk nl"><strong class="ne io">let response = undefined;</strong></span><span id="cdeb" class="kk kl in ne b gy nm nj l nk nl"><strong class="ne io">if (!importObject) {</strong></span><span id="a7fb" class="kk kl in ne b gy nm nj l nk nl"><strong class="ne io">importObject = {</strong></span><span id="66c0" class="kk kl in ne b gy nm nj l nk nl"><strong class="ne io">env: {</strong></span><span id="9d3c" class="kk kl in ne b gy nm nj l nk nl"><strong class="ne io">abort: () =&gt; console.log("Abort!")</strong></span><span id="909f" class="kk kl in ne b gy nm nj l nk nl"><strong class="ne io">}</strong></span><span id="145b" class="kk kl in ne b gy nm nj l nk nl"><strong class="ne io">};</strong></span><span id="c0e2" class="kk kl in ne b gy nm nj l nk nl"><strong class="ne io">}</strong></span><span id="2965" class="kk kl in ne b gy nm nj l nk nl"><strong class="ne io">const instantiateModule = async() =&gt; {</strong></span><span id="cea2" class="kk kl in ne b gy nm nj l nk nl"><strong class="ne io">const response = await fetch ("./addition.wasm");</strong></span><span id="cf20" class="kk kl in ne b gy nm nj l nk nl"><strong class="ne io">const buffer = await response.arrayBuffer();</strong></span><span id="daa7" class="kk kl in ne b gy nm nj l nk nl"><strong class="ne io">const obj = await WebAssembly.instantiate (buffer, importObject);</strong></span><span id="5ef3" class="kk kl in ne b gy nm nj l nk nl"><strong class="ne io">return obj;</strong></span><span id="a3ac" class="kk kl in ne b gy nm nj l nk nl"><strong class="ne io">};</strong></span><span id="dfbf" class="kk kl in ne b gy nm nj l nk nl"><strong class="ne io">response = await instantiateModule();</strong></span><span id="ad74" class="kk kl in ne b gy nm nj l nk nl"><strong class="ne io">return response;</strong></span><span id="abf4" class="kk kl in ne b gy nm nj l nk nl"><strong class="ne io">};</strong></span></pre><p id="090b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在上面，我们没有使用/检查<a class="ae kj" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/instantiateStreaming" rel="noopener ugc nofollow" target="_blank">流实例化</a>。这是可以做到的，在这篇博文中有更好的解释。这里，我们使用<a class="ae kj" href="https://www.geeksforgeeks.org/javascript-fetch-method/" rel="noopener ugc nofollow" target="_blank"> fetch </a>方法来下载整个 WASM 模块。Post 它，我们实例化它并返回它。</p><p id="f698" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">此后，我们还将调用在<strong class="jm io">步骤#1 </strong>中描述的导出的 add()函数。</p><pre class="lx ly lz ma gt nd ne nf ng aw nh bi"><span id="8b9d" class="kk kl in ne b gy ni nj l nk nl"><strong class="ne io">const runWasmAdd = async () =&gt; {</strong></span><span id="ebdd" class="kk kl in ne b gy nm nj l nk nl"><strong class="ne io">// Instantiate WASM module</strong></span><span id="41b5" class="kk kl in ne b gy nm nj l nk nl"><strong class="ne io">const wasmModule = await wasmBrowserInstantiate("./addition.wasm");</strong></span><span id="fe9b" class="kk kl in ne b gy nm nj l nk nl"><strong class="ne io">// Call the exported add function from wasm and save the result</strong></span><span id="f262" class="kk kl in ne b gy nm nj l nk nl"><strong class="ne io">const addResult = wasmModule.instance.exports.add(42, 42);</strong></span><span id="64b0" class="kk kl in ne b gy nm nj l nk nl"><strong class="ne io">// Set the result</strong></span><span id="8eee" class="kk kl in ne b gy nm nj l nk nl"><strong class="ne io">document.body.textContent = `The result of the addition: ${addResult}`;</strong></span><span id="3e4b" class="kk kl in ne b gy nm nj l nk nl"><strong class="ne io">};</strong></span><span id="b358" class="kk kl in ne b gy nm nj l nk nl"><strong class="ne io">runWasmAdd();</strong></span></pre><h2 id="2041" class="kk kl in bd km kn ko dn kp kq kr dp ks jv kt ku kv jz kw kx ky kd kz la lb lc bi translated"><strong class="ak">第 4 步:导入。js 文件转换成 HTML </strong></h2><p id="ac50" class="pw-post-body-paragraph jk jl in jm b jn ld jp jq jr le jt ju jv lf jx jy jz lg kb kc kd lh kf kg kh ig bi translated">我们现在将使用下面的代码片段将我们的 addition.js 作为 ES6 模块加载到 HTML 文件中:</p><pre class="lx ly lz ma gt nd ne nf ng aw nh bi"><span id="37a0" class="kk kl in ne b gy ni nj l nk nl"><strong class="ne io">&lt;!DOCTYPE html&gt;</strong></span><span id="3256" class="kk kl in ne b gy nm nj l nk nl"><strong class="ne io">&lt;html&gt;</strong></span><span id="d418" class="kk kl in ne b gy nm nj l nk nl"><strong class="ne io">&lt;head&gt;</strong></span><span id="7744" class="kk kl in ne b gy nm nj l nk nl"><strong class="ne io">&lt;meta charset="UTF-8" /&gt;</strong></span><span id="23d9" class="kk kl in ne b gy nm nj l nk nl"><strong class="ne io">&lt;title&gt;Add me!&lt;/title&gt;</strong></span><span id="75ec" class="kk kl in ne b gy nm nj l nk nl"><strong class="ne io">&lt;script type="module" src="./addition.js"&gt;&lt;/script&gt;</strong></span><span id="79a7" class="kk kl in ne b gy nm nj l nk nl"><strong class="ne io">&lt;/head&gt;</strong></span><span id="2769" class="kk kl in ne b gy nm nj l nk nl"><strong class="ne io">&lt;body&gt;&lt;/body&gt;</strong></span><span id="cb6e" class="kk kl in ne b gy nm nj l nk nl"><strong class="ne io">&lt;/html&gt;</strong></span></pre><h2 id="97f0" class="kk kl in bd km kn ko dn kp kq kr dp ks jv kt ku kv jz kw kx ky kd kz la lb lc bi translated">步骤 5:在浏览器上实际查看我们的代码</h2><p id="30ff" class="pw-post-body-paragraph jk jl in jm b jn ld jp jq jr le jt ju jv lf jx jy jz lg kb kc kd lh kf kg kh ig bi translated">您不能直接在浏览器上查看 index.html，即使您看到了，它也可能会弹出一个空白页面。</p><p id="d5cf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">通过开发工具进一步挖掘，您会发现这是一个错误</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi np"><img src="../Images/bccf35d04ad0e4e92c23d2f0546e06d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jmetreMSK6xD3-0fFH9BMQ.png"/></div></div></figure><p id="2ad7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这意味着我们将不得不在网络服务器的帮助下提供我们的包裹。有多种方法可以做到这一点，但是，最简单的方法是通过 npm 执行下面的命令来安装 http-server 包。</p><pre class="lx ly lz ma gt nd ne nf ng aw nh bi"><span id="ec07" class="kk kl in ne b gy ni nj l nk nl"><strong class="ne io">npm i -g http-server</strong></span></pre><p id="33d1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一旦安装了 http-server，您将能够通过执行以下命令在您想要的任何端口上启动它</p><pre class="lx ly lz ma gt nd ne nf ng aw nh bi"><span id="df95" class="kk kl in ne b gy ni nj l nk nl"><strong class="ne io">http-server -p &lt;port_number&gt;</strong></span></pre><p id="fe94" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一旦它启动并运行，您将能够查看如下页面。</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/52ff4b1903349b803e810a9e8575346c.png" data-original-src="https://miro.medium.com/v2/resize:fit:752/format:webp/1*6JAnCqFpBBq83C8DLMwOJQ.png"/></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk translated">景色</figcaption></figure><p id="eafa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">概括地说，我们已经在上面看到了如何传递两个 i32 数字并在浏览器上返回它们的和。尽管用 TypeScript 编写的代码只有 3 行，但通过 WASM Web API 调用，用 JavaScript 调用 WASM 编译的版本变得更加容易。这实质上意味着，我们最终做的是这个(当然，在 WASM Web API 的帮助下)，</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/da3a9ba96262a49a83540718fb6ce609.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/1*uWw15EoFZnvhBfWwRQlSnw.png"/></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk translated">在 JavaScript 和 WASM 模块之间传递值(用 TypeScript 编写)</figcaption></figure><p id="8068" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你还记得我们之前的帖子，这正是我们已经达成的各种工具的用例，比如<a class="ae kj" href="https://github.com/rustwasm/wasm-bindgen" rel="noopener ugc nofollow" target="_blank">wasm-bindgen</a>/<a class="ae kj" href="https://github.com/AssemblyScript/assemblyscript/tree/caa58015062dbccba7de9133c3d09138eec93e85/lib/loader" rel="noopener ugc nofollow" target="_blank">assembly script loader</a>。作为参考，下面是图片描述。</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi ns"><img src="../Images/01da643884cf5f39f53e64538fa5b083.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qCkSzlWtJxQl2InyIZYW7w.png"/></div></div></figure><p id="9663" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以这个帖子到此为止！希望我能够简化如何在 JavaScript 和用 TypeScript 编写的 WASM 模块之间传递数值。这种理解将是下一篇博文的关键，我们将尝试将这种知识扩展到在两者之间传递整个数组。</p><p id="2127" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">资源:</strong></p><p id="0b02" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae kj" rel="noopener ugc nofollow" target="_blank" href="/a-primer-on-webassembly-834150fdd7ae">网络组件上的底漆</a>，</p><p id="56d7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae kj" rel="noopener ugc nofollow" target="_blank" href="/part-1-how-to-read-wasm-b29de01d39e7">如何阅读《WASM》——第一部分</a></p><p id="ad31" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae kj" rel="noopener ugc nofollow" target="_blank" href="/part-2-how-to-read-wasm-1f7e34e70f59">如何阅读 WASM 第二部</a></p><p id="05d3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae kj" rel="noopener ugc nofollow" target="_blank" href="/part-1-memory-management-in-wasm-52195f9b707f">第 1 部分:WASM 的内存管理</a></p><p id="eb8a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae kj" href="https://hacks.mozilla.org/tag/webassembly/" rel="noopener ugc nofollow" target="_blank"> Mozilla 在 WebAssembly 上黑掉了林·克拉克的博客</a></p><p id="de25" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ki">附注:要了解我最新的科技恶作剧，请关注我的</em> <a class="ae kj" href="https://twitter.com/Divya_Mohan02" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> <em class="ki">推特</em></strong></a><strong class="jm io"><em class="ki"/></strong><em class="ki">和</em><a class="ae kj" href="https://www.linkedin.com/in/divya-mohan0209/" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="ki">LinkedIn</em></strong></a><em class="ki">。</em></p><p id="2067" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">P.P.S .公司。我的内容创作之旅始于一个个人责任工具，是一项热爱的工作。除了这个博客，我还出版了一个名为 <a class="ae kj" href="https://www.getrevue.co/profile/divyamohan" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> <em class="ki">的每周时事通讯，在那里我报道了科技世界里所有有趣的事情，作为一个亮点卷轴..随着时事通讯和博客社区的不断发展，你可以通过选择</em> <a class="ae kj" href="https://ko-fi.com/divyamohan?utm_campaign=friday%20four&amp;utm_medium=email&amp;utm_source=Revue%20newsletter" rel="noopener ugc nofollow" target="_blank"> <em class="ki">给我买杯咖啡(一次性投资)或加入每月会员计划</em> </a> <em class="ki">来继续支持我的工作。请注意，这不会影响你当前的时事通讯/博客订阅，因为我的目标是让它们都免费。</em> </strong></a></p></div></div>    
</body>
</html>