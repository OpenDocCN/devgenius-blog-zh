<html>
<head>
<title>AWH Xamarin Flow — An MVVM Setup for Xamarin.Forms</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">AWH Xamarin流——xa marin的MVVM设置。形式</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/awh-xamarin-flow-an-mvvm-setup-for-xamarin-forms-d620318b3423?source=collection_archive---------2-----------------------#2021-04-29">https://blog.devgenius.io/awh-xamarin-flow-an-mvvm-setup-for-xamarin-forms-d620318b3423?source=collection_archive---------2-----------------------#2021-04-29</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/8646ad3f0c0ea74780d75aa6149d1e5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*pHWQY5hyWoA52FUl.jpg"/></div></div></figure><p id="fe7c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Xamarin。Forms是一个强大的工具包，可以在。网络生态系统。它快速、稳定，并且依赖于成熟的开发栈。不幸的是，它只是一个工具包，而不是一个全功能的框架。这使得启动新的应用程序或保持现有应用程序的可维护性变得困难，因为没有“正确”的方法来组织代码。</p><p id="f666" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">幸好使用了一些常见的。NET包和技术，很容易在Xamarin.Forms中构建一个简单的、可扩展的、可单元测试的MVVM设置。<a class="ae kt" href="http://awh.net" rel="noopener ugc nofollow" target="_blank"> AWH </a> Xamarin Flow是我们在<a class="ae kt" href="http://awh.net" rel="noopener ugc nofollow" target="_blank"> AWH </a>开发的设置，使从头构建一个应用程序变得容易，并保持它的可维护性。</p><h1 id="3fe5" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">示例应用程序</h1><p id="502d" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">我已经创建了一个<a class="ae kt" href="https://bitbucket.org/awhcode/awh-xamarin-flow" rel="noopener ugc nofollow" target="_blank">样本Xamarin。Forms app </a>使用<a class="ae kt" href="http://awh.net" rel="noopener ugc nofollow" target="_blank"> AWH </a> Xamarin流设置，并已将代码放入公共回购中，因此您可以关注这篇文章。我建议真正深入研究代码，因为我不会涵盖流程的每个方面。相反，我将提请注意一些关键部分，看看它们为什么重要，以及您可能希望如何调整流程以满足您的应用程序的需求。</p><h1 id="54b9" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">启动和主机构建器</h1><p id="ddc2" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">流程的核心是启动类。通常情况下，在Xamarin中。每个平台都会初始化app类的一个新实例。在Android上，这是在MainActivity.cs中完成的，而在iOS上，这是在AppDelegate.cs中完成的。此方法将创建一个新的HostBuilder(从Microsoft。Extensions.Hosting NuGet package)，它将完成注册服务和配置之类的工作，然后返回App类的一个实例。然后，我们可以在每个平台的项目中调用这个方法，而不是直接创建App实例。</p><p id="f07f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">使用HostBuilder可以让我们利用其他。NET应用程序，如依赖注入。它还接受一个Action参数，该参数将让每个特定于平台的项目注册可以使用本机平台API的服务。如果您的应用程序不需要本机服务，那么您可以简单地从Initialize中移除参数，并移除。使用该参数的ConfigureServices()行。</p><p id="5671" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们看看使用HostBuilder的两个主要优点:配置和依赖注入。</p><p id="8d42" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">配置</strong></p><p id="0a77" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在流中使用HostBuilder的主要优势之一是能够使用熟悉的appsettings。*.用于配置的json文件。我们可以加载嵌入在共享项目中的JSON文件，并将它们注册为配置值的来源。然后可以使用IConfiguration实例将这些值注入到任何需要它们的类中(尽管您可能希望创建一个包装器服务来使您的值具有强类型)。</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="a166" class="mg kv in mc b gy mh mi l mj mk">// The GetManifestResourceStream functions cannot be executed from within the<br/>// ConfigureHostConfiguration's configureDelegate because that causes a "Stream<br/>// was not readable" ArgumentException.<br/>var assembly = Assembly.GetExecutingAssembly();<br/>var environment = Constants.Environment.Current;<br/>using var appSettingsStream = assembly.GetManifestResourceStream("XamSample.appsettings.json");<br/>using var appSettingsEnvironmentStream = assembly.GetManifestResourceStream($"XamSample.appsettings.{environment}.json");<br/>​<br/>var host = new HostBuilder()<br/>    // (Removed some code for brevity)<br/>    .ConfigureHostConfiguration(config =&gt;<br/>    {<br/>        config.AddJsonStream(appSettingsStream);<br/>        config.AddJsonStream(appSettingsEnvironmentStream);<br/>    })<br/>    // (Removed some code for brevity)</span></pre><p id="b2d6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">使用常量。环境类允许根据项目的当前构建配置更改包含的文件。例如，在一个API驱动的应用程序中，我们可能有不同的URL用于开发、测试、UAT和生产API。将每一个都作为不同的构建配置，将使我们能够构建应用程序，以便它可以引入正确的设置来连接到正确的API。</p><p id="fe0b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您的应用程序可能不需要这样的配置文件，或者它可能不需要特定于环境的文件。您可以自定义加载什么文件，甚至如何加载。有许多选项可用于加载配置，但我们更喜欢使用appsettings.json，因为它是最常见的模式。</p><p id="5b87" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">依赖注入</strong></p><p id="cac9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在流程中使用HostBuilder的另一个主要优点是，我们可以使用依赖注入。ASP.NET核心推广了一种构造函数注入风格，任何有经验的人都应该非常熟悉。NET开发者。通过在HostBuilder实例上使用ConfigureServices方法，我们可以注册我们的应用程序的所有服务、视图和视图模型，以便它们可以接收依赖项，因此它们可以是依赖项。我们甚至注册了我们的App类，这样它就可以接收NavigatorService的一个实例(稍后将详细介绍)。</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="ecde" class="mg kv in mc b gy mh mi l mj mk">public static App Initialize(Action&lt;HostBuilderContext, IServiceCollection&gt; configureNativeServices)<br/>{<br/>    // (Removed some code for brevity)<br/>    var host = new HostBuilder()<br/>        // (Removed some code for brevity)<br/>        .ConfigureServices(configureNativeServices)<br/>        .ConfigureServices(ConfigureServices)<br/>        // (Removed some code for brevity)<br/>        .Build();<br/>​<br/>    App.ServiceProvider = host.Services;<br/>​<br/>    return App.ServiceProvider.GetService&lt;App&gt;()<br/>        ?? throw new Exception("The App service provider isn't set up properly.");<br/>}<br/>​<br/>private static void ConfigureServices(HostBuilderContext context, IServiceCollection services)<br/>{<br/>    // Custom services for this app. Each service should have a matching<br/>    // interface so it can be mocked for unit tests.<br/>    services.AddSingleton&lt;IPageService, PageService&gt;();<br/>    services.AddSingleton&lt;INavigatorService, NavigatorService&gt;();<br/>​<br/>    // Add Pages and their ViewModels as transients so they can be retrieved using DI<br/>    services.AddTransient&lt;ItemListPage&gt;();<br/>    services.AddTransient&lt;ItemListViewModel&gt;();<br/>    services.AddTransient&lt;ItemDetailPage&gt;();<br/>    services.AddTransient&lt;ItemDetailViewModel&gt;();<br/>​<br/>    // Finally register the App so it can access the NavigatorService<br/>    services.AddSingleton&lt;App&gt;();<br/>}</span></pre><p id="c5a9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们做的一件值得注意的事情是将App类的静态ServiceProvider属性设置为已注册服务的完整集合。当我们需要在PageService中动态地拉取页面和查看模型时，以及在我们无法访问普通构造函数注入的罕见情况下，这是非常有用的。我们还使用它来检索我们注册的App类的singleton实例，该实例将被返回到平台项目，以便在应用程序启动时加载。</p><p id="d825" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">关于服务生存期的一个注意事项:通常，我们有<a class="ae kt" href="https://docs.microsoft.com/en-us/dotnet/core/extensions/dependency-injection#service-lifetimes" rel="noopener ugc nofollow" target="_blank">三种注册类型</a>可供选择(单例、作用域和瞬态)，但是因为我们不在请求/响应环境中(像web应用程序或API)，我们不能使用作用域服务，所以只应该注册单例或瞬态。</p><p id="eefe" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在<a class="ae kt" href="http://awh.net" rel="noopener ugc nofollow" target="_blank"> AWH </a> Xamarin Flow中有一个坚实的依赖注入设置，有助于保持我们的服务、视图模型和其他类的松散耦合。这反过来又使单元测试变得容易得多，因为我们可以更容易地模拟依赖关系。作为奖励，您可以包括<a class="ae kt" href="https://www.nuget.org/packages/Xamarin.Essentials.Interfaces" rel="noopener ugc nofollow" target="_blank"> Xamarin。Essentials.Interfaces </a>包，其中包括Xamarin中包含的设备功能的已生成接口。必需品包。这个包使得代码的可测试性变得更加容易。</p><h1 id="930e" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">视图-视图模型关系</h1><p id="cbe8" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">任何MVVM设置的关键方面之一是视图与视图模型之间的关系。你需要确保他们是正确配对和正确的分离他们之间。这通常使用“视图模型定位器”类来完成，该类将视图映射到视图模型。在<a class="ae kt" href="http://awh.net" rel="noopener ugc nofollow" target="_blank"> AWH </a> Xamarin Flow中，我们使用PageService(在下一节中详细介绍)来加载页面并找到正确的视图模型。但服务只接收页面类型，而不接收视图模型类型。为了保持它们之间的链接，我们使用了一个名为IPageWithViewModel的接口，每个页面都应该实现这个接口:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="fc35" class="mg kv in mc b gy mh mi l mj mk">public interface IPageWithViewModel<br/>{<br/>    Type ViewModelType { get; }<br/>}</span></pre><p id="5be4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后，每个页面都在代码隐藏类中实现接口，并设置它所需的视图模型:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="728b" class="mg kv in mc b gy mh mi l mj mk">public partial class ItemDetailPage : ContentPage, IPageWithViewModel<br/>{<br/>    public Type ViewModelType =&gt; typeof(ItemDetailViewModel);<br/>​<br/>    public ItemDetailPage() =&gt; InitializeComponent();<br/>}</span></pre><p id="af96" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这可以确保我们可以轻松地为页面获得正确的视图模型，同时保持视图和视图模型松散耦合。我们希望视图不直接处理视图模型，而只知道它需要什么视图模型。对于视图模型，它应该对使用它的视图一无所知。</p><p id="3ac6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">基础视图模型</strong></p><p id="b73c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果深入挖掘代码，您可能会在ViewModels文件夹中注意到一些奇怪的东西:有两个基本视图模型。我们已经把BaseViewModel和BasePageViewModel分开了。BaseViewModel类包含我们对INotifyPropertyChanged的实现，这是我们在XAML的绑定工作所必需的。BasePageViewModel类包含一个NavigatorService实例和两个生命周期方法:InitializeAsync和RefreshAsync。当视图模型表示比整个页面更小的可视数据对象时，分离这些对象的好处就来了。这可能是一个视图模型，它表示ListView中的一个项目，您仍然需要INotifyPropertyChanged goodness，但不需要NavigatorService。</p><p id="c491" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当加载(或返回)页时，生命周期方法对于正确调用异步方法非常有用。不需要使用任何欺骗从构造函数调用异步方法，也永远不需要使用异步void方法。这是一个特别困难的问题，特别是对于新的Xamarin开发人员来说，这些方法是Flow的一个非常有价值的方面。</p><p id="977b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">同样值得注意的是我们是如何实现INotifyPropertyChanged的。SetProperty方法是处理带有支持字段的属性的最干净、最简单的方法，同时还可以根据需要调用PropertyChanged事件。对于视图模型上的任何给定属性，这种实现需要最少的样板代码:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="31bd" class="mg kv in mc b gy mh mi l mj mk">private string _title = string.Empty;<br/>public string Title<br/>{<br/>    get =&gt; _title;<br/>    set =&gt; SetProperty(ref _title, value);<br/>}</span></pre><h1 id="e286" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">页面和导航服务</h1><p id="79be" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">前面提到的页面服务在<a class="ae kt" href="http://awh.net" rel="noopener ugc nofollow" target="_blank"> AWH </a>主流中扮演“视图模型定位器”的角色。它负责按类型获取页面的实例，获取页面视图模型的实例，并将视图模型设置为页面的绑定上下文。它使用App类的ServiceProvider属性完成所有这些工作，因此它依赖于我们在Startup.cs中设置的依赖注入。</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="72f5" class="mg kv in mc b gy mh mi l mj mk">public Page GetPage&lt;PageType&gt;()<br/>{<br/>    if (App.ServiceProvider == null)<br/>        throw new InvalidOperationException("App.ServiceProvider is null and has not been set up correctly");<br/>​<br/>    var page = App.ServiceProvider.GetService&lt;PageType&gt;() as Page;<br/>​<br/>    if (page == null)<br/>        throw new ArgumentException("Unable to locate page in ServiceProvider", nameof(PageType));<br/>​<br/>    if (page is IPageWithViewModel pageWithViewModel)<br/>    {<br/>        var viewModel = App.ServiceProvider.GetService(pageWithViewModel.ViewModelType) as BasePageViewModel;<br/>​<br/>        if (viewModel == null)<br/>            throw new ArgumentException("Unable to locate page view model in ServiceProvider", pageWithViewModel.ViewModelType.Name);<br/>​<br/>        page.BindingContext = viewModel;<br/>    }<br/>​<br/>    return page;<br/>}</span></pre><p id="7f34" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">大多数时候，你的应用程序不会(也不应该)直接处理页面服务，而是与导航服务交互。</p><p id="5d43" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">NavigatorService在很大程度上依赖于PageService，并充当Xamarin的包装器。窗体NavigationPage实例。它提供了基本应用程序导航所需的方法，如在导航堆栈中推送和弹出页面，以及模式页面的类似方法。不过，根据你的应用程序的用户界面，导航服务可能并不完美。您可能需要一个不同的服务来充当类似的角色，但包装了一个TabbedPage或一个弹出页面。在<a class="ae kt" href="http://awh.net" rel="noopener ugc nofollow" target="_blank"> AWH </a> Xamarin流程的所有部分中，这一部分可能需要对任何特定的应用程序进行最多的更改。</p><p id="bcd5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae kt" href="http://awh.net" rel="noopener ugc nofollow" target="_blank"> AWH </a> Xamarin流使得构建和维护Xamarin变得容易。表单应用程序使用类似的技术。NET应用程序。还有其他框架，但是这种设置实现了大部分相同的功能，同时减少了您必须处理的“黑盒”库的数量。通过使用一些标准的软件包，我们已经拼凑出了一个我们自己的可靠的、可扩展的框架。</p><p id="9c47" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个设置是由汤米·埃利奥特创建的，他是AWH<a class="ae kt" href="http://awh.net" rel="noopener ugc nofollow" target="_blank">的软件开发团队负责人。非常感谢他将设置放在一起，帮助我创建示例项目，并帮助我理解Xamarin。他还创造了这个名字，这比一直称它为“我们的设置”要好得多。</a></p><h2 id="57c5" class="mg kv in bd kw ml mm dn la mn mo dp le kg mp mq li kk mr ms lm ko mt mu lq mv bi translated">——安德鲁·莫斯卡迪诺，AWH<a class="ae kt" href="http://awh.net" rel="noopener ugc nofollow" target="_blank">公司的软件开发人员。我们正在帮助企业通过技术推动增长。</a></h2></div></div>    
</body>
</html>