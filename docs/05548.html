<html>
<head>
<title>Concurrency, Multi-threading, Multi-processing, Asynchronous Programming and Event Loop</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">并发、多线程、多处理、异步编程和事件循环</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/concurrency-multi-threading-multi-processing-asynchronous-programming-and-event-loop-1b8df9fa6c20?source=collection_archive---------1-----------------------#2021-09-06">https://blog.devgenius.io/concurrency-multi-threading-multi-processing-asynchronous-programming-and-event-loop-1b8df9fa6c20?source=collection_archive---------1-----------------------#2021-09-06</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/4505e530165b6326ad4463f107a1ce5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fwtaFBZ2kP7lEdfIOpH3uA.jpeg"/></div></div></figure><p id="cdaa" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">像<code class="fe kt ku kv kw b">concurrency</code>、<code class="fe kt ku kv kw b">multi-threading</code>、<code class="fe kt ku kv kw b">multi-processing</code>、<code class="fe kt ku kv kw b">asynchronous programming</code>和<code class="fe kt ku kv kw b">event loop</code>这样的概念之间的关系可能会混淆。尤其是哪些技法可以达到<code class="fe kt ku kv kw b">concurrency</code>。这篇文章试图用简单直观的方式来解释它们。</p><p id="61b5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先，<code class="fe kt ku kv kw b">concurrency</code>是一个人有能力处理多项任务<code class="fe kt ku kv kw b">out-of-order</code>的概念。这里<code class="fe kt ku kv kw b">out-of-order</code>是关键，不代表它们同时处理，也不代表它们同时开始或结束。这捕获了可以实现<code class="fe kt ku kv kw b">concurrency</code>的各种各样的技术，包括<code class="fe kt ku kv kw b">multi-threading</code>、<code class="fe kt ku kv kw b">multi-processing</code>和<code class="fe kt ku kv kw b">asynchronous programming</code>。</p><p id="10c7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们来看看什么是<code class="fe kt ku kv kw b">multi-threading</code>和<code class="fe kt ku kv kw b">multi-processing</code>。我将它们分组是因为它们与<code class="fe kt ku kv kw b">asynchronous programming</code>和<code class="fe kt ku kv kw b">event loop</code>相似。从文字中可以很清楚地看出，它们允许同时使用多个<code class="fe kt ku kv kw b">threads</code>或<code class="fe kt ku kv kw b">processes</code>来执行任务。它们是实现<code class="fe kt ku kv kw b">concurrency</code>的不同技术，区别不在本文讨论范围之内。你可以参考参考书来了解详情。</p><p id="d413" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe kt ku kv kw b">Asynchronous programming</code>是一种将某些任务推迟到以后，并允许主线程处理其他任务的技术。最常见的例子是<code class="fe kt ku kv kw b">node.js</code>使用的异步 I/O。在<code class="fe kt ku kv kw b">node.js</code>中，它将 I/O 操作交给 OS 内核，并将 I/O 操作的回调推迟到以后。这允许<code class="fe kt ku kv kw b">node.js</code>在 I/O 操作移交给操作系统后立即处理其他任务，而不需要等到操作系统完成 I/O 任务。这是<code class="fe kt ku kv kw b">node.js</code>的<code class="fe kt ku kv kw b">concurrency</code>的核心部分。你可能知道，<code class="fe kt ku kv kw b">Javascript</code>和<code class="fe kt ku kv kw b">node.js</code>是单线程的。这向您展示了即使是单线程系统也可以有<code class="fe kt ku kv kw b">concurrency</code>。有些人可能会说<code class="fe kt ku kv kw b">asynchronous programming</code>没有提供<code class="fe kt ku kv kw b">concurrency</code>，这取决于<code class="fe kt ku kv kw b">task</code>的定义是什么。如果人们把<code class="fe kt ku kv kw b">callbacks</code>定义为独立的<code class="fe kt ku kv kw b">tasks</code>，那么他们是正确的。因为正如您将在后面的图表中看到的，当我们讨论<code class="fe kt ku kv kw b">event loop</code>时，<code class="fe kt ku kv kw b">callbacks</code>只不过是被推到事件队列中的任务。在这个定义中，<code class="fe kt ku kv kw b">tasks</code>没有被执行<code class="fe kt ku kv kw b">out-of-order</code>。按照惯例，大多数人将<code class="fe kt ku kv kw b">callbacks</code>视为推迟到以后完成的原始任务的一部分。所以他们考虑将这个任务分成几个部分，在其他任务中执行<code class="fe kt ku kv kw b">out-of-order</code>，这就形成了这样的系统<code class="fe kt ku kv kw b">concurrent</code>。我同意<code class="fe kt ku kv kw b">asynchronous programming</code>提供<code class="fe kt ku kv kw b">concurrency</code>的说法。</p><p id="de9d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后我们来看<code class="fe kt ku kv kw b">event loop</code>。<code class="fe kt ku kv kw b">Event loop</code>是一种在系统中等待和调度事件的设计模式。当它与<code class="fe kt ku kv kw b">Asynchronous programming</code>和<code class="fe kt ku kv kw b">multi-processing</code>等技术一起使用时，它也为系统提供了<code class="fe kt ku kv kw b">concurrency</code>。而<code class="fe kt ku kv kw b">event loop</code>通常由一个队列(例如 FIFO 队列)、一个循环和工人构成。让我们看一个简单的<code class="fe kt ku kv kw b">event loop</code>，图中只显示了一个工人。事件被推送到事件队列中，<code class="fe kt ku kv kw b">event loop</code>从事件队列中取出事件，并将它们分派给 worker。在这种情况下，让我们假设队列是 FIFO 队列，在这样的系统中，事件是逐个处理的，没有<code class="fe kt ku kv kw b">concurrency</code>。如果我们将<code class="fe kt ku kv kw b">Asynchronous programming</code>添加到图片中，正如您可以在底部看到的行，worker 将<code class="fe kt ku kv kw b">callback</code>事件添加回事件队列。这提供了<code class="fe kt ku kv kw b">concurrency</code>，即使只有一个工作者或线程。这就是你调用<code class="fe kt ku kv kw b">setTimeout(myCallback, 100)</code>时的情况。在场景后面，工作人员在 100ms 后将<code class="fe kt ku kv kw b">myCallback</code>推到事件队列中。现在你明白为什么传递给<code class="fe kt ku kv kw b">setTimeout()</code>的<code class="fe kt ku kv kw b">myCallback</code>不会正好在 100ms 后被调用了吧？这是因为在<code class="fe kt ku kv kw b">myCallback</code>之前，队列中可能还有其他事件需要处理。100ms 是<code class="fe kt ku kv kw b">myCallback</code>执行前需要等待的最短时间。现在你也明白人们为什么用<code class="fe kt ku kv kw b">setTimeout(myCallback, 0)</code>了吧。这并不意味着 0ms 后会立即调用<code class="fe kt ku kv kw b">myCallback</code>的意思。这是一种释放主工作者(线程)来处理队列中的其他事件并将<code class="fe kt ku kv kw b">myCallback</code>推迟到以后的技术。</p><figure class="ky kz la lb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi kx"><img src="../Images/fcd76bd16a81121d6809ed9b31249ee2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g4YiYKbMXR_LFgncNBg9OA.png"/></div></div></figure><p id="2fff" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe kt ku kv kw b">Event loop</code>也可以用<code class="fe kt ku kv kw b">multi-threading</code>。用户可以简单地在系统中添加更多的工人和线程轮询，如下图所示。唯一的区别是，现在可以从事件队列中取出多个事件，并由不同线程中的不同工作者同时处理。</p><figure class="ky kz la lb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lc"><img src="../Images/b586d87a9454ef05ce452be831c0eebf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QStKeds_azbIyyj_Nj4cOA.png"/></div></div></figure><p id="064d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一个人可以很有创造力，在他们认为合适的时候扩展<code class="fe kt ku kv kw b">event loop</code>。以<code class="fe kt ku kv kw b">node.js</code>为例，它将整个<code class="fe kt ku kv kw b">event loop</code>分为多个阶段，每个阶段本身就像一个更小的<code class="fe kt ku kv kw b">event loop</code>。如果想了解更多，可以参考最后的参考。</p></div></div>    
</body>
</html>