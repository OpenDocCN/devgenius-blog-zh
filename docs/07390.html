<html>
<head>
<title>Automated DNS/TLS with External DNS &amp; LetsEncrypt on Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes 上带有外部 DNS 和 LetsEncrypt 的自动化 DNS/TLS</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/automated-dns-tls-with-external-dns-letsencrypt-on-kubernetes-6f4f41827df9?source=collection_archive---------8-----------------------#2022-03-21">https://blog.devgenius.io/automated-dns-tls-with-external-dns-letsencrypt-on-kubernetes-6f4f41827df9?source=collection_archive---------8-----------------------#2022-03-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/16149f83738eb993cb30689f4d344aaa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Fv0gpi06cPB03ffo"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">西蒙·卡杜拉在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="c535" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Kubernetes 已经成为维护和部署容器的事实方式。然而，我们的应用程序仍然有一些部分是手工管理的。我注意到的两个是维护 DNS 记录和 TLS 证书。</p><p id="20a3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">难道我们不应该能够定义我们想要的 DNS 和 TLS 以及我们的应用程序清单吗？事实上我们可以！</p><p id="0bef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">两个开源的 Kubernetes 插件实现了这一点。我们有外部 dns，允许在您的清单中进行 DNS 管理，还有 cert-manager 处理证书管理。</p><p id="51ae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这篇博文将指导您完成这两个插件的安装和配置。</p><p id="227c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里有一个你需要的快速概述。</p><ul class=""><li id="c616" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">云提供商:对于本指南，我将使用<a class="ae kc" href="https://www.vultr.com" rel="noopener ugc nofollow" target="_blank"> Vultr </a>。</li><li id="ce11" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">Kubernetes 集群:我将使用 VKE ( <a class="ae kc" href="https://www.vultr.com/kubernetes/" rel="noopener ugc nofollow" target="_blank"> Vultr Kubernetes 引擎</a>)。</li><li id="4d1d" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">域:这个域应该预先配置为查看您的云提供商的名称服务器。</li><li id="5508" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">APIKey:这个 API key 将被提供给某些资源，以便他们能够代表 Kubernetes 与您的云提供商进行通信。</li></ul><p id="e80f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">根据您使用的云提供商，您可能需要添加您的域条目。</p><p id="c62d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为我使用 Vultr，所以我将使用 vultr-cli 来创建和验证我的域。</p><figure class="lp lq lr ls gt jr"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="3c6d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Cert-manager 是一个定制的 Kubernetes 资源，允许在 Kubernetes 中进行本地证书管理。下面是来自<a class="ae kc" href="https://cert-manager.io" rel="noopener ugc nofollow" target="_blank"> https://cert-manager.io </a>登陆页面的更全面的解释。</p><blockquote class="lv lw lx"><p id="d0dc" class="kd ke ly kf b kg kh ki kj kk kl km kn lz kp kq kr ma kt ku kv mb kx ky kz la ij bi translated"><em class="iq"> Cert-manager 将证书和证书颁发者作为资源类型添加到 Kubernetes 集群中，并简化了获取、更新和使用这些证书的过程。它可以从各种受支持的来源颁发证书，包括 Let's Encrypt、HashiCorp Vault 和 Venafi 以及私有 PKI。它将确保证书是有效的和最新的，并尝试在到期前的配置时间续订证书。</em></p></blockquote><figure class="lp lq lr ls gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mc"><img src="../Images/a949a2583a884d26515f1e27a02f842b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BojnYMkTm8wd-5GKSlO6OQ.png"/></div></div></figure><p id="60da" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有了 Cert-manager，云提供商可以提供定制的 webhooks，这样用户就可以轻松地以 yaml 清单的形式发布证书。在本指南的具体用例中，我们将使用<a class="ae kc" href="https://github.com/vultr/cert-manager-webhook-vultr" rel="noopener ugc nofollow" target="_blank"> Vultrs cert-manager-webhook 插件</a>，它将处理我们域的 TLS 证书。</p><p id="f181" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">注意:根据您使用的云提供商，您可能需要参考特定提供商的说明</strong></p><h1 id="97cb" class="md me iq bd mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na bi translated">基本证书管理器安装</h1><p id="ea5b" class="pw-post-body-paragraph kd ke iq kf b kg nb ki kj kk nc km kn ko nd kq kr ks ne ku kv kw nf ky kz la ij bi translated">要安装基础证书管理器，我们可以运行他们的文档中提供的 kubectl apply 命令。<a class="ae kc" href="https://cert-manager.io/docs/" rel="noopener ugc nofollow" target="_blank">https://cert-manager.io/docs/</a>。在本指南发布时，安装命令如下</p><figure class="lp lq lr ls gt jr"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="9ab9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您应该能够检查<code class="fe ng nh ni nj b">cert-manager</code>名称空间中所有相关的 cert-manager 资源。</p><h1 id="06eb" class="md me iq bd mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na bi translated">Vultr 证书管理器安装</h1><p id="0406" class="pw-post-body-paragraph kd ke iq kf b kg nb ki kj kk nc km kn ko nd kq kr ks ne ku kv kw nf ky kz la ij bi translated">现在我们必须安装 Vultr 特有的<code class="fe ng nh ni nj b">cert-manager-webhook</code>。要做到这一点，你需要从<a class="ae kc" href="https://github.com/vultr/cert-manager-webhook-vultr" rel="noopener ugc nofollow" target="_blank">https://github.com/vultr/cert-manager-webhook-vultr</a>下载代码</p><p id="43ae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要开始安装 Vultr cert-manager webhook，我们必须创建一个<code class="fe ng nh ni nj b">secret</code>。这将包含您的 Vultr API 密钥，证书管理器将使用它来创建验证所需的 DNS 条目。</p><figure class="lp lq lr ls gt jr"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="1cb1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">随着秘密的部署，我们可以安装 vultr 证书管理器。</p><figure class="lp lq lr ls gt jr"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="d2cc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">与基本 cert-manager 安装相同，您可以通过检查<code class="fe ng nh ni nj b">cert-manager</code>名称空间来验证 vultr webhook 是否正在运行。</p><h1 id="5c83" class="md me iq bd mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na bi translated">颁发 TLS 证书</h1><p id="0c60" class="pw-post-body-paragraph kd ke iq kf b kg nb ki kj kk nc km kn ko nd kq kr ks ne ku kv kw nf ky kz la ij bi translated">部署了 cert-manager 之后，让我们看看我们的 yaml 定义在发布证书时会是什么样子。</p><p id="7583" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将从部署 ClusterIssuer 开始。这将代表用于创建签名证书的证书颁发机构(CA)。在下面的 yaml 中，我们正在创建我们的<code class="fe ng nh ni nj b">ClusterIssuer</code> to LetsEncrypt 登台环境。对于生产使用，您需要将其更改为<code class="fe ng nh ni nj b"><a class="ae kc" href="https://acme-v02.api.letsencrypt.org/directory." rel="noopener ugc nofollow" target="_blank">https://acme-v02.api.letsencrypt.org/directory</a></code> <a class="ae kc" href="https://acme-v02.api.letsencrypt.org/directory." rel="noopener ugc nofollow" target="_blank">。</a></p><figure class="lp lq lr ls gt jr"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="bcd0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还需要授予服务帐户获取秘密的权限</p><figure class="lp lq lr ls gt jr"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="11c0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">部署了 ClusterIssuer 和 RBAC。对于 Vultr 上托管的域，我们将无法从 LetsEncrypt 请求 TLS 证书。</p><h1 id="923d" class="md me iq bd mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na bi translated">申请证书</h1><p id="876c" class="pw-post-body-paragraph kd ke iq kf b kg nb ki kj kk nc km kn ko nd kq kr ks ne ku kv kw nf ky kz la ij bi translated">证书资源表示证书请求的人类可读定义，该定义将由发行者兑现并保持最新。</p><figure class="lp lq lr ls gt jr"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="f69a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在你应用它之前，让我们回顾一下我们在这里定义的东西</p><ul class=""><li id="99a6" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">commonName:这是您的基本域。</li><li id="2edd" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">dnsNames:这些是我正在请求的证书。对于通配符(*)证书，您必须将它们用“”括起来</li><li id="fe95" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">issuerRef:它引用 clusterIssuer 的名称。如果您有一个用于生产 LetEncrypt 的 ClusterIssuer，您将希望在此处匹配这些名称。</li><li id="3a7f" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">sercretName:这是您将存储 TLS 证书的机密的名称。</li></ul><p id="8916" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦创建了<code class="fe ng nh ni nj b">Certificate</code>类，就会创建一些资源。它们如下:</p><ul class=""><li id="3d91" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">certificate requests:cert-manager 中用于向颁发者请求 X.509 证书的命名空间资源。</li><li id="6b71" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">订单:ACME 发行者使用资源来管理 ACME“订单”的生命周期，以获得已签名的 TLS 证书。</li><li id="96e8" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">质询:ACME 发行者使用资源来管理 ACME“质询”的生命周期，必须完成该“质询”才能完成对单个 DNS 名称/标识符的“授权”。</li></ul><figure class="lp lq lr ls gt jr"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="2a44" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">关于这些资源的更多信息可以在这里找到:<a class="ae kc" href="https://cert-manager.io/docs/concepts/" rel="noopener ugc nofollow" target="_blank">https://cert-manager.io/docs/concepts/</a></p><p id="d91a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这可能需要几分钟时间，但您可以检查您的证书资源并查看“就绪”状态。</p><p id="3137" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">证书请求的验证可能需要几分钟时间。您可以通过查看证书的<code class="fe ng nh ni nj b">Ready</code>状态来检查状态。</p><figure class="lp lq lr ls gt jr"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="342b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">完成所有这些之后，您现在将拥有一个来自 LetsEncrypt 的有效 TLS 证书，它将存储在证书 yaml 中定义的秘密名称中。</p><figure class="lp lq lr ls gt jr"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="951b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请记住，创建我们的 ClusterIssuer 是为了指向 LetsEncrypt 登台环境。生产使用请使用<code class="fe ng nh ni nj b"><a class="ae kc" href="https://acme-v02.api.letsencrypt.org/directory." rel="noopener ugc nofollow" target="_blank">https://acme-v02.api.letsencrypt.org/directory</a></code> <a class="ae kc" href="https://acme-v02.api.letsencrypt.org/directory." rel="noopener ugc nofollow" target="_blank">。</a></p><p id="068c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在 Kubernetes 上，你已经为你的域名实现了自动 TLS！</p><h1 id="10f7" class="md me iq bd mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na bi translated"><strong class="ak">外部 DNS </strong></h1><p id="fa54" class="pw-post-body-paragraph kd ke iq kf b kg nb ki kj kk nc km kn ko nd kq kr ks ne ku kv kw nf ky kz la ij bi translated">让我们转到 DNS。无论你是使用 Kubernetes 中的<code class="fe ng nh ni nj b">ingress</code>还是<code class="fe ng nh ni nj b">loadbalancer</code>服务，你都不希望手动配置 IP 地址。这是我们将使用 ExternalDNS 的地方，它将自动为我们的域创建 DNS 条目，并将其与服务 IP 相关联。</p><p id="497e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">ExternalDNS 的安装非常简单。如果您使用的是 vultr 以外的云提供商，请查看该提供商的特定安装说明<a class="ae kc" href="https://github.com/kubernetes-sigs/external-dns#deploying-to-a-cluster" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="e69e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于 Vultr，我们可以用下面的 yaml 清单安装 ExternalDNS。</p><figure class="lp lq lr ls gt jr"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="2578" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在应用这个 yaml 之前，让我们看一下部署规范参数部分中的一些字段。</p><ul class=""><li id="3c67" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">—来源:我们会用<code class="fe ng nh ni nj b">ingress</code>。但是，您也可以将外部 DNS 与类型为<code class="fe ng nh ni nj b">loadbalancer</code>的常规服务配对</li><li id="9aeb" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">— domain-filter:此定义将外部 DNS 限制为仅过滤所提供的域。</li><li id="2f20" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">—提供商:如果您使用 vultr 以外的提供商，请相应更新。</li><li id="8ae6" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">— registry:我们在这里使用<code class="fe ng nh ni nj b">txt</code>,因此外部 dns 创建的每个记录都伴随着 TXT 记录。</li><li id="987e" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">— txt-owner-id:一个惟一的值，在集群的生命周期内不会改变。</li></ul><p id="a006" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦应用了外部 dns yaml，就可以通过检查 pod 来确保它正确运行。</p><figure class="lp lq lr ls gt jr"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="0488" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">随着 ExternalDNS 的运行，我们现在将能够为 DNS 条目向我们的服务清单添加注释。</p><h1 id="172d" class="md me iq bd mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na bi translated"><strong class="ak">绑在一起</strong></h1><h2 id="2ab3" class="nk me iq bd mf nl nm dn mj nn no dp mn ko np nq mr ks nr ns mv kw nt nu mz nv bi translated">部署和服务</h2><p id="f0e5" class="pw-post-body-paragraph kd ke iq kf b kg nb ki kj kk nc km kn ko nd kq kr ks ne ku kv kw nf ky kz la ij bi translated">现在，外部 dns 正在运行，证书管理器负责确保我们始终拥有有效的 TLS 证书。让我们部署一个简单的应用程序，并在 HTTPS 的公共互联网上公开它。</p><p id="1b8e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将部署 nginx 的一个副本部署，以及一个将路由到该部署的 cluserIP 服务。</p><figure class="lp lq lr ls gt jr"><div class="bz fp l di"><div class="lt lu l"/></div></figure><h2 id="e8e9" class="nk me iq bd mf nl nm dn mj nn no dp mn ko np nq mr ks nr ns mv kw nt nu mz nv bi translated">进入</h2><p id="fa69" class="pw-post-body-paragraph kd ke iq kf b kg nb ki kj kk nc km kn ko nd kq kr ks ne ku kv kw nf ky kz la ij bi translated">为了向互联网公开这一点，我们将使用 Kubernetes ingress-nginx。您也可以使用服务类型<code class="fe ng nh ni nj b">loadbalancer</code>来代替入口。如果您决定使用<code class="fe ng nh ni nj b">loadbalancer</code>，请确保在您的外部 dns yaml 中将类型从<code class="fe ng nh ni nj b">ingress</code>更改为<code class="fe ng nh ni nj b"> service</code>。</p><p id="49bd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了开始使用 Kubernetes nginx ingress，我们将应用他们在<a class="ae kc" href="https://kubernetes.github.io/ingress-nginx/deploy/#quick-start" rel="noopener ugc nofollow" target="_blank">快速入门指南</a>上发布的准备好的清单。</p><pre class="lp lq lr ls gt nw nj nx ny aw nz bi"><span id="d6be" class="nk me iq nj b gy oa ob l oc od"><br/>kubectl apply -f <a class="ae kc" href="https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.1.1/deploy/static/provider/cloud/deploy.yaml" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.1.1/deploy/static/provider/cloud/deploy.yaml</a></span></pre><p id="f1eb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这将创建一个名为<code class="fe ng nh ni nj b">ingress-nginx</code>的新名称空间，入口的所有资源都将驻留在其中。</p><p id="6d9d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们通过入口来展示我们的 nginx 应用程序。</p><figure class="lp lq lr ls gt jr"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="8e2e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个注释<code class="fe ng nh ni nj b">external-dns.alpha.kubernetes.io/hostname: www.devbytes.sh</code>定义了外部 dns 应该创建什么条目。在这种情况下，它将为 www 创建一个 A 记录，指向入口部署的负载平衡器。</p><p id="71d8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">tls.hosts 部分定义了 IP 地址应该将哪个域视为 HTTPS。secretName 是拥有我们在<code class="fe ng nh ni nj b">issuing a TLS certificate</code>期间创建的 TLS 证书的秘密。</p><p id="bd50" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">rules.host 部分定义了应该将哪个 URL 路由到哪个服务。所以在上面定义的 yaml 中<code class="fe ng nh ni nj b">www.devbytes.sh/</code>应该转到我们的 nginx 服务/部署。</p><p id="d6a2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">部署后，您可以通过运行以下命令来检查这个入口。</p><figure class="lp lq lr ls gt jr"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="99ae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">给 Kubernetes/DNS 几分钟的时间来传播所有的请求和域名记录，但几分钟之内，你应该有一个 HTTPS 支持的域名。</p><h1 id="4cc6" class="md me iq bd mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na bi translated">包扎</h1><p id="c87a" class="pw-post-body-paragraph kd ke iq kf b kg nb ki kj kk nc km kn ko nd kq kr ks ne ku kv kw nf ky kz la ij bi translated">我们已经到了结尾，让我们回顾一下。现在，您可以使用 cert-manager 为您的应用程序创建 TLS 证书。创建 DNS 条目和更新这些记录是应用程序清单的一部分，不需要手动调整记录。最后，为了公开这些应用程序，我们可以创建一个入口资源，将它们联系在一起。有了这三个工具，现在只需用 yaml 清单就可以定义应用程序的整个状态，剩下的就交给 Kubernetes 处理了。</p><p id="cfa4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有用的链接。</p><ul class=""><li id="ee75" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated"><a class="ae kc" href="https://kubernetes.github.io/ingress-nginx/" rel="noopener ugc nofollow" target="_blank">https://kubernetes.github.io/ingress-nginx/</a></li><li id="efea" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">【https://github.com/kubernetes-sigs/external-dns T2】号</li><li id="2552" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">【https://cert-manager.io/ T4】</li><li id="ff4c" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><a class="ae kc" href="https://github.com/vultr/cert-manager-webhook-vultr" rel="noopener ugc nofollow" target="_blank">https://github.com/vultr/cert-manager-webhook-vultr</a></li><li id="f862" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><a class="ae kc" href="https://github.com/vultr/vultr-cli/" rel="noopener ugc nofollow" target="_blank">https://github.com/vultr/vultr-cli/</a></li><li id="1308" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><a class="ae kc" href="https://www.vultr.com/kubernetes/" rel="noopener ugc nofollow" target="_blank">https://www.vultr.com/kubernetes/</a></li></ul></div></div>    
</body>
</html>