<html>
<head>
<title>Spread operator (…) in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript 中的扩展运算符(…)</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/what-is-spread-operator-in-javascript-87233cd85bff?source=collection_archive---------32-----------------------#2020-06-11">https://blog.devgenius.io/what-is-spread-operator-in-javascript-87233cd85bff?source=collection_archive---------32-----------------------#2020-06-11</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="f3e0" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">在 JavaScript 中使用 spread 运算符的快速指南。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/ba517e064f41c12f691f5b5c886c1ef4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*F61cuA-3fsvCe0zS"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">Emile Perron 在<a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="4a36" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">当我们遵循 JavaScript 代码时，我们可以看到有时有 3 个点(…)。这三个点是什么(…)。它是 Java Script 中的 spread 运算符。在本文中，我将讨论 JavaScript 中的 spread 操作符。</p><p id="f311" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">随着 ES6 的新功能，传播运营商是其中之一。让我们讨论它是什么？，为什么呢？、用例等等相关的例子。</p><p id="cf04" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">根据 MDN</p><blockquote class="lp lq lr"><p id="c779" class="kt ku ls kv b kw kx jo ky kz la jr lb lt ld le lf lu lh li lj lv ll lm ln lo ig bi translated">Spread 语法允许在需要零个或多个参数(对于函数调用)或元素(对于数组文本)的地方扩展可迭代对象，例如数组表达式或字符串，或者在需要零个或多个键值对(对于对象文本)的地方扩展对象表达式。<a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax" rel="noopener ugc nofollow" target="_blank">来源</a></p></blockquote><p id="a7bc" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">传播算子是做什么的？</strong></p><p id="5770" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">它可以将数组或字符串中的项作为单独的参数或元素展开，并在对象中展开键值对。让我们用例子来讨论。</p><p id="3616" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">我们在哪里使用它？</strong></p><p id="9d43" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">扩展运算符用于</p><ol class=""><li id="6434" class="lw lx in kv b kw kx kz la lc ly lg lz lk ma lo mb mc md me bi translated">函数调用</li><li id="e0a9" class="lw lx in kv b kw mf kz mg lc mh lg mi lk mj lo mb mc md me bi translated">数组文字或字符串</li><li id="a3f3" class="lw lx in kv b kw mf kz mg lc mh lg mi lk mj lo mb mc md me bi translated">对象文字</li></ol><p id="27d5" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> 1 .函数调用</strong></p><p id="08ca" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">首先我们写一个函数来求两个数的和。</p><pre class="kd ke kf kg gt mk ml mm mn aw mo bi"><span id="66d5" class="mp mq in ml b gy mr ms l mt mu">const numbers = [6,8];</span><span id="8371" class="mp mq in ml b gy mv ms l mt mu">function findSum(num1, num2){<br/>  console.log(num1+num2);  //14<br/>}</span><span id="ffda" class="mp mq in ml b gy mv ms l mt mu">findSum(numbers[0], numbers[1]);</span></pre><p id="baa7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">上面代码的输出是 14 <strong class="kv io">。</strong>现在添加传播算子。我们可以添加 spread 运算符来传递<strong class="kv io"> <em class="ls">数字</em> </strong>，而不使用<em class="ls">数字[0]，数字[1]。</em></p><pre class="kd ke kf kg gt mk ml mm mn aw mo bi"><span id="0a2a" class="mp mq in ml b gy mr ms l mt mu">const numbers = [6,8];</span><span id="9d98" class="mp mq in ml b gy mv ms l mt mu">function findSum(num1, num2){<br/> console.log(num1+num2);  //14<br/>}</span><span id="1982" class="mp mq in ml b gy mv ms l mt mu">findSum(…numbers);</span></pre><p id="fb01" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">输出，</p><pre class="kd ke kf kg gt mk ml mm mn aw mo bi"><span id="7d19" class="mp mq in ml b gy mr ms l mt mu">14</span></pre><p id="6087" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> <em class="ls"> …numbers </em> </strong>将数组的元素传递给函数。在这里，<em class="ls"> findSum() </em>只接受数组的第一个和第二个元素。让我们尝试改进代码。</p><pre class="kd ke kf kg gt mk ml mm mn aw mo bi"><span id="20a2" class="mp mq in ml b gy mr ms l mt mu">const numbers = [6,8,3];</span><span id="9817" class="mp mq in ml b gy mv ms l mt mu">function findSum(...arg){<br/>  console.log(arg);              //[ 6, 8, 3 ]               <br/>  console.log(arg[0] + arg[1]);  //14<br/>}</span><span id="3c4e" class="mp mq in ml b gy mv ms l mt mu">findSum(...numbers);</span></pre><p id="a540" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">输出，</p><pre class="kd ke kf kg gt mk ml mm mn aw mo bi"><span id="35fb" class="mp mq in ml b gy mr ms l mt mu">[ 6, 8, 3 ]<br/>14</span></pre><p id="b5a9" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这里，<em class="ls"> findSum() </em>也在<strong class="kv io">函数参数</strong>中加入了扩展运算符。</p><p id="e2c5" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> 2 .数组文字或字符串</strong></p><p id="caf0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这里我有奇数和偶数。我想把它们加到一个数组里。尝试..</p><pre class="kd ke kf kg gt mk ml mm mn aw mo bi"><span id="cc83" class="mp mq in ml b gy mr ms l mt mu">const odds = [1,3,5];<br/>const even = [2,4,6];</span><span id="e5a7" class="mp mq in ml b gy mv ms l mt mu">const numbers = [odds, even]</span><span id="1d84" class="mp mq in ml b gy mv ms l mt mu">console.log(numbers);  //[ [ 1, 3, 5 ], [ 2, 4, 6 ] ]</span></pre><p id="120a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">输出，</p><pre class="kd ke kf kg gt mk ml mm mn aw mo bi"><span id="339e" class="mp mq in ml b gy mr ms l mt mu">[ [ 1, 3, 5 ], [ 2, 4, 6 ] ]</span></pre><p id="15b7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">但是这里我不能得到预期的输出，这里没有一个没有嵌套数组的数组。但是在 Array.prototype.concat 中使用 concat intor<em class="ls">()</em>…</p><pre class="kd ke kf kg gt mk ml mm mn aw mo bi"><span id="910f" class="mp mq in ml b gy mr ms l mt mu">const odds = [1,3,5];<br/>const even = [2,4,6];</span><span id="a9b9" class="mp mq in ml b gy mv ms l mt mu">const numbers = odds.concat(even)</span><span id="fa44" class="mp mq in ml b gy mv ms l mt mu">console.log(numbers);     //[ 1, 3, 5, 2, 4, 6 ]</span></pre><p id="ed33" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">输出，</p><pre class="kd ke kf kg gt mk ml mm mn aw mo bi"><span id="c34f" class="mp mq in ml b gy mr ms l mt mu">[ 1, 3, 5, 2, 4, 6 ]</span></pre><p id="1ecb" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在尝试添加扩展运算符。</p><pre class="kd ke kf kg gt mk ml mm mn aw mo bi"><span id="da0f" class="mp mq in ml b gy mr ms l mt mu">const odds = [1,3,5];<br/>const even = [2,4,6];</span><span id="22c6" class="mp mq in ml b gy mv ms l mt mu">const numbers = […odds, …even]</span><span id="0945" class="mp mq in ml b gy mv ms l mt mu">console.log(numbers);</span></pre><p id="359c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">输出，</p><pre class="kd ke kf kg gt mk ml mm mn aw mo bi"><span id="70de" class="mp mq in ml b gy mr ms l mt mu">[ 1, 3, 5, 2, 4, 6 ]</span></pre><p id="0e2b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这里我们有一个数组，包含所有奇数和偶数元素。<strong class="kv io"><em class="ls">concat()</em></strong><em class="ls"/>和<strong class="kv io">展开运算符</strong>都成功。</p><p id="c68f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在对比一下<strong class="kv io"> <em class="ls">推()</em> </strong> vs <strong class="kv io"> <em class="ls">传播算子</em> </strong></p><pre class="kd ke kf kg gt mk ml mm mn aw mo bi"><span id="2ae2" class="mp mq in ml b gy mr ms l mt mu">let odds = [1,3,5];<br/>let updatedOdd = odds        <br/>updatedOdd.push(7)</span><span id="c8f5" class="mp mq in ml b gy mv ms l mt mu">console.log(updatedOdd);        //[1,3,5,7]<br/>console.log(odds);              //[1,3,5,7]</span><span id="eda5" class="mp mq in ml b gy mv ms l mt mu">/* using spread syntax */</span><span id="2c12" class="mp mq in ml b gy mv ms l mt mu">let even = [2,4,6];<br/>let updatedEven = even<br/>updatedEven = […even, 8];</span><span id="6d48" class="mp mq in ml b gy mv ms l mt mu">console.log(updatedEven);       //[2,4,6]<br/>console.log(even);              //[2,4,6,8]</span></pre><p id="f0e7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">根据上面的代码，那当我们尝试给<strong class="kv io"> <em class="ls">加 7 的时候【updatedOdd】</em></strong><em class="ls">，</em>原数组(<strong class="kv io"><em class="ls"/></strong>)也被改变了。但是当我们尝试给<strong class="kv io"> <em class="ls"> updatedEven </em> </strong>加 8 时，spread 运算符并不会影响到原来的数组(<strong class="kv io"><em class="ls"/></strong>)。</p><p id="b5cc" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">3 .对象文字</p><blockquote class="lp lq lr"><p id="4821" class="kt ku ls kv b kw kx jo ky kz la jr lb lt ld le lf lu lh li lj lv ll lm ln lo ig bi translated">ECMAScript 提案(ES2018)的 Rest/Spread 属性向对象文字添加了 Spread 属性。它将自己的可枚举属性从一个提供的对象复制到一个新对象上。<a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax" rel="noopener ugc nofollow" target="_blank">来源</a></p></blockquote><p id="6ae2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">带有扩展运算符的对象文字用于用新对象扩展现有对象。</p><pre class="kd ke kf kg gt mk ml mm mn aw mo bi"><span id="5252" class="mp mq in ml b gy mr ms l mt mu">studentBio={<br/> name: “Jenny”,<br/> age: “20”<br/>}</span><span id="5a3a" class="mp mq in ml b gy mv ms l mt mu">studentCollege={<br/> collegeName: “x”,<br/> collegeLevel: 4<br/>}</span><span id="5b56" class="mp mq in ml b gy mv ms l mt mu">const studentDetails = {…studentBio, …studentCollege};<br/>console.log(studentDetails)</span></pre><p id="d529" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">输出，</p><pre class="kd ke kf kg gt mk ml mm mn aw mo bi"><span id="c606" class="mp mq in ml b gy mr ms l mt mu">{ name: ‘Jenny’, age: ‘20’, collegeName: ‘x’, collegeLevel: 4 }</span></pre><p id="93e3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这里所有可枚举的细节都被复制到合并的对象中。<strong class="kv io"><em class="ls">student details</em></strong>是<strong class="kv io"> <em class="ls"> studentBio </em> </strong>和<strong class="kv io"><em class="ls">student college</em></strong>的副本。</p></div><div class="ab cl mw mx hr my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ig ih ii ij ik"><p id="e233" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">结论</strong></p><p id="dfb6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">本文涵盖了 JavaScript 中 spread 操作符背后的一个基本主题。这里讨论了什么是扩展运算符，它用在什么地方。然后讨论带有实现代码片段的扩展操作符的行为。</p><div class="nd ne gp gr nf ng"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax" rel="noopener  ugc nofollow" target="_blank"><div class="nh ab fo"><div class="ni ab nj cl cj nk"><h2 class="bd io gy z fp nl fr fs nm fu fw im bi translated">扩展语法</h2><div class="nn l"><h3 class="bd b gy z fp nl fr fs nm fu fw dk translated">Spread 语法允许在零个或多个…</h3></div><div class="no l"><p class="bd b dl z fp nl fr fs nm fu fw dk translated">developer.mozilla.org</p></div></div><div class="np l"><div class="nq l nr ns nt np nu km ng"/></div></div></a></div></div></div>    
</body>
</html>