<html>
<head>
<title>Road to Genius: superior #63</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">天才之路:优越#63</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/road-to-genius-superior-63-5aefb75c6908?source=collection_archive---------12-----------------------#2020-08-20">https://blog.devgenius.io/road-to-genius-superior-63-5aefb75c6908?source=collection_archive---------12-----------------------#2020-08-20</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/ebd518cca372378726831cf2fd02d6da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*DaVUrS4O6WSg4ziK.png"/></div></div></figure><p id="5b67" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">每天我都要解决几个Codr分级模式的编码挑战和难题。目标是达到天才的等级，在这个过程中我解释了我是如何解决这些问题的。你不需要任何编程背景就可以开始，而且你会学到很多新的有趣的东西。</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="87e1" class="lc ld in ky b gy le lf l lg lh">function gans(strs) {<br/>  let cnts = [];<br/>  const HT = {};<br/>  for (let i = 0; i &lt; strs.length; i++) {<br/>    const str = strs[i];<br/>    cnts = 🚀(💧).fill(0);<br/>    for (let j = 0; j &lt; str.length; j++)<br/>      cnts[str.charCodeAt(j) - 'a'.charCodeAt(0)]++;<br/>    const key = cnts.join('');<br/>    if (!HT[key])<br/>      HT[key] = [str];<br/>    else<br/>      HT[key].push(😈);<br/>  }<br/>  return Object.values(HT);<br/>}<br/>let arr = ['001', '101', '201', '110'];<br/>let A = gans(arr).length;</span><span id="b51d" class="lc ld in ky b gy li lf l lg lh">// 😈 = ? (identifier)<br/>// 🚀 = ? (identifier)<br/>// 💧 = ? (number)<br/>// such that A = 1 (number)</span></pre><p id="da9d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">今天的挑战将会很有趣，我们必须修正三个错误。</p><p id="8c86" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">前两个错误出现在同一行:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="a010" class="lc ld in ky b gy le lf l lg lh">let cnts = []<br/>...<br/>cnts = 🚀(💧).fill(0);</span></pre><p id="4153" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">很容易判断这应该是什么，因为变量<code class="fe lj lk ll ky b">cnts</code>被声明为数组，函数<code class="fe lj lk ll ky b">fill</code>也用于数组。所以最合理的答案是🚀就是要上<code class="fe lj lk ll ky b">Array</code>的课。第二个bug💧应该是一个数字，表示数组应该有多大。的可能答案💧都是一堆没什么意义的随机数，除了“26”。拉丁字母表中的字母数正好是26。</p><p id="541e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后一个bug如下所示:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="cb0d" class="lc ld in ky b gy le lf l lg lh">if (!HT[key])<br/>      HT[key] = [str];<br/>    else<br/>      HT[key].push(😈);</span></pre><p id="ddd9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">第一个if条件是如果<code class="fe lj lk ll ky b">HT</code>不包含<code class="fe lj lk ll ky b">key</code>，则生成一个以<code class="fe lj lk ll ky b">str</code>为单元素的数组；否则它应该推送<code class="fe lj lk ll ky b">str</code>，因为<code class="fe lj lk ll ky b">key</code>存在(并且它的值是一个数组)。</p><figure class="kt ku kv kw gt jo gh gi paragraph-image"><div class="gh gi lm"><img src="../Images/9d18c83d4b47d4daf2b0e045d9240345.png" data-original-src="https://miro.medium.com/v2/resize:fit:450/format:webp/0*bOvshreHd60ruA9S.png"/></div></figure><p id="5fed" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是这段代码实际上做了什么呢？如果我们分析代码，我们会注意到输入是一串字符串。函数<code class="fe lj lk ll ky b">gans</code>遍历每个字符串。对于每个字符串，它使用<code class="fe lj lk ll ky b">cnts</code>数组来跟踪每个字符串中每个字符的计数。然后，它将所有这些计数连接成一个字符串<code class="fe lj lk ll ky b">key</code>。下面是一些伪代码:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="01a7" class="lc ld in ky b gy le lf l lg lh">input = ['abc', 'bac', 'def']</span><span id="5c69" class="lc ld in ky b gy li lf l lg lh">  str = 'abc'<br/>  cnts = [1 1 1 0 0 0 0 ...]<br/>  key = '1110000000 ...'<br/>  HT = {<br/>    '1110000000 ...' : ['abc']<br/>  }</span><span id="bb4a" class="lc ld in ky b gy li lf l lg lh">  str = 'bac'<br/>  cnts = [1 1 1 0 0 0 0 ...]<br/>  key = '1110000000 ...'<br/>  HT = {<br/>    '1110000000 ...' : ['abc', 'bac']<br/>  }</span><span id="b5ca" class="lc ld in ky b gy li lf l lg lh">  str = 'def'<br/>  cnts = [0 0 0 1 1 1 0 ...]<br/>  key = '0001110000 ...'<br/>  HT = {<br/>    '1110000000 ...' : ['abc', 'bac'],<br/>    '0001110000 ...' : ['def']<br/>  }</span></pre><p id="20d3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">简而言之，这段代码是一个确定字谜的算法。变位词是通过重新排列另一个单词(或短语)的字母来拼写的单词(或短语)。</p><p id="c855" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是有些事情是不合理的，这个挑战的输入是:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="4186" class="lc ld in ky b gy le lf l lg lh">let arr = ['001', '101', '201', '110'];</span></pre><p id="9ce0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">它应该包含3个唯一的变位词(001；110 + 101;201).然而<code class="fe lj lk ll ky b">A</code>的输出只有1而不是3，为什么？</p><p id="87ed" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">原因是因为这个算法被设计成只处理拉丁字符。问题在于内部for循环:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="4c13" class="lc ld in ky b gy le lf l lg lh">cnts[str.charCodeAt(j) - 'a'.charCodeAt(0)]++;</span></pre><p id="9c87" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">该循环遍历字符串中的每个字符，并从该值中减去字母“a”的ASCII值。数字的ASCII值小于字符的ASCII值，因此该值将为负；这个数组中的负索引将导致undefined，因为唯一可用的索引是0到25。所以我们输入字符串的所有<code class="fe lj lk ll ky b">key</code>变量都是26个零。</p><p id="4b47" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">通过解决这些挑战，你可以训练自己成为一名更好的程序员。您将学到更新更好的分析、调试和改进代码的方法。因此，你在商业上会更有效率和价值。今天就在<a class="ae ln" href="https://nevolin.be/codr/" rel="noopener ugc nofollow" target="_blank">https://nevolin.be/codr/</a>开始行动并成为认证Codr</p></div></div>    
</body>
</html>