<html>
<head>
<title>Memory management and Garbage collection in Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java 中的内存管理和垃圾收集</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/memory-management-and-garbage-collection-in-java-44074d9c0e6d?source=collection_archive---------3-----------------------#2022-04-24">https://blog.devgenius.io/memory-management-and-garbage-collection-in-java-44074d9c0e6d?source=collection_archive---------3-----------------------#2022-04-24</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><h1 id="d3d0" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">Java 如何工作 works(一次编写，随处运行)</h1><p id="2bed" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">在 Java 中，源代码包含在。java 文件被编译成字节码或扩展名为. class 的文件，然后从字节码转换成机器码。字节码是代码的中间表示。然后，这些代码被传递给 JVM，JVM 将字节码转换成机器码。因此，在一种架构上生成的字节码可以在另一种架构上运行。JVM 及其组件是特定于机器的，因此它能够为 Java 提供独立于平台的特性，这与 C++等语言相反，在 c++等语言中，可执行文件或机器代码是直接从。c++文件。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi lg"><img src="../Images/62626296dca60d7766affd805a738f50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1132/format:webp/1*FTGk0JyvW5HdcKH-211Brw.png"/></div></figure><h1 id="7b71" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">存储器分配</h1><p id="4a13" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">在 Java 中，有原始数据类型和引用类型。<br/>有 8 种原始数据类型，即:</p><pre class="lh li lj lk gt lo lp lq lr aw ls bi"><span id="e7f8" class="lt jl in lp b gy lu lv l lw lx">boolean<br/>char<br/>short<br/>byte<br/>int<br/>long<br/>float<br/>double</span></pre><p id="ba6c" class="pw-post-body-paragraph ki kj in kk b kl ly kn ko kp lz kr ks kt ma kv kw kx mb kz la lb mc ld le lf ig bi translated">引用类型变量存储对象的地址或位置。Java 基于面向对象的范例，因此广泛使用类和对象，尽管也支持过程化范例。与原语相比，对象在内存中的存储方式是不同的。</p><p id="381d" class="pw-post-body-paragraph ki kj in kk b kl ly kn ko kp lz kr ks kt ma kv kw kx mb kz la lb mc ld le lf ig bi translated">这是一个示例类<code class="fe md me mf lp b">Person</code></p><pre class="lh li lj lk gt lo lp lq lr aw ls bi"><span id="bb79" class="lt jl in lp b gy lu lv l lw lx">public class Person {<br/>    private int age;<br/>    private String name;<br/><br/>    Person(int age, String name){<br/>        this.age = age;<br/>        this.name = name;<br/>    }<br/><br/>    void getDetails(){<br/>        System.<em class="mg">out</em>.println(this.name + " is " + this.age + " years old ");<br/>    }<br/><br/>    public static void main(String[] args){<br/>        int primitiveOne = 1;<br/>        float primitiveTwo = 2.0F;<br/><br/>        Person person = new Person(20, "sam");<br/>        person.getDetails();<br/>         <br/>        int[] ages = {1, 2, 3, 4};</span><span id="02d6" class="lt jl in lp b gy mh lv l lw lx">    }<br/>}</span></pre><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/f57d3ac9b4bd1f66cba4e7745003ea08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1020/format:webp/1*5aLQIOAuMJMnOndOn2FhMA.png"/></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk translated">内存分配表示</figcaption></figure><h1 id="e2c0" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">碎片帐集</h1><p id="1ea8" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">在 JVM 中，垃圾收集进程总是作为守护线程运行。它是一个总是在后台运行的低优先级进程。堆包含对象，而栈包含对象名/引用。原语存储在堆栈中，并根据 LIFO 机制清除。垃圾收集负责自动管理内存，它在堆中运行。没有像 C++中那样显式的内存分配和释放(使用 malloc，free)。当一个对象没有引用或者没有指向它的东西时，它就变得无用。本质上，当一个对象不可达时，它可以被移除或者释放内存。</p><p id="1875" class="pw-post-body-paragraph ki kj in kk b kl ly kn ko kp lz kr ks kt ma kv kw kx mb kz la lb mc ld le lf ig bi translated">垃圾收集或 GC 的主要步骤包括:</p><blockquote class="mn mo mp"><p id="5cd5" class="ki kj mg kk b kl ly kn ko kp lz kr ks mq ma kv kw mr mb kz la ms mc ld le lf ig bi translated">标记</p></blockquote><p id="8c14" class="pw-post-body-paragraph ki kj in kk b kl ly kn ko kp lz kr ks kt ma kv kw kx mb kz la lb mc ld le lf ig bi translated">这是使用类似图形的数据结构在内部实现的。可到达的对象被识别和标记。</p><blockquote class="mn mo mp"><p id="3b92" class="ki kj mg kk b kl ly kn ko kp lz kr ks mq ma kv kw mr mb kz la ms mc ld le lf ig bi translated">删除</p></blockquote><p id="380c" class="pw-post-body-paragraph ki kj in kk b kl ly kn ko kp lz kr ks kt ma kv kw kx mb kz la lb mc ld le lf ig bi translated">无法访问或不再引用的对象将被删除</p><blockquote class="mn mo mp"><p id="3eb3" class="ki kj mg kk b kl ly kn ko kp lz kr ks mq ma kv kw mr mb kz la ms mc ld le lf ig bi translated">压紧</p></blockquote><p id="3a03" class="pw-post-body-paragraph ki kj in kk b kl ly kn ko kp lz kr ks kt ma kv kw kx mb kz la lb mc ld le lf ig bi translated">已经被释放的内存将被组装在一起，以避免外部碎片，这种情况下，有足够的内存完全分配给一个对象，但它不在一起)</p><p id="5c2e" class="pw-post-body-paragraph ki kj in kk b kl ly kn ko kp lz kr ks kt ma kv kw kx mb kz la lb mc ld le lf ig bi translated">这是堆内存的结构</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/20c2e80b0b716487c264476c48424202.png" data-original-src="https://miro.medium.com/v2/resize:fit:1192/format:webp/1*wLyY8mNfuIquVr2v86GR_A.png"/></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk translated">将堆分成年轻和年老的世代</figcaption></figure><p id="5837" class="pw-post-body-paragraph ki kj in kk b kl ly kn ko kp lz kr ks kt ma kv kw kx mb kz la lb mc ld le lf ig bi translated">由于垃圾收集是一个开销很大的过程，它有两种运行方式:</p><ul class=""><li id="929b" class="mu mv in kk b kl ly kp lz kt mw kx mx lb my lf mz na nb nc bi translated">次要垃圾收集</li><li id="bfe7" class="mu mv in kk b kl nd kp ne kt nf kx ng lb nh lf mz na nb nc bi translated">主要垃圾收集</li></ul><p id="e1d7" class="pw-post-body-paragraph ki kj in kk b kl ly kn ko kp lz kr ks kt ma kv kw kx mb kz la lb mc ld le lf ig bi translated">新创建的对象存储在伊甸区，<strong class="kk io">一旦伊甸区接近满</strong>，<strong class="kk io">小 GC 运行</strong>，不可达的对象仅从<strong class="kk io">伊甸区中移除</strong>，而存活下来的对象移动到存活区。有 2 个幸存区域来启用压缩，创建的对象尽可能保持紧凑。一旦对象在年轻一代区域中存活超过阈值数量的垃圾收集周期，它们就移动到老一代</p><p id="41b7" class="pw-post-body-paragraph ki kj in kk b kl ly kn ko kp lz kr ks kt ma kv kw kx mb kz la lb mc ld le lf ig bi translated">这里使用了<strong class="kk io">世代假设</strong>的思想，也就是说，如果对象的寿命超过了垃圾收集周期的阈值数，那么它们将停留更长时间，因此驻留在更老的世代中。换句话说，大多数物体在年轻的时候就死去了，但是那些幸存下来的，在记忆中存在了很长时间</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="nj nk di nl bf nm"><div class="gh gi ni"><img src="../Images/6cdd2d9ca34e2af8e8a4e85b0fabc9af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*umvGOmMlsrUGYTg4pXa2vA.png"/></div></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk translated">图片来源:<a class="ae nn" href="http://abiasforaction.net/understanding-jvm-garbage-collection-part-3/" rel="noopener ugc nofollow" target="_blank">http://abiasforaction . net/understanding-JVM-garbage-collection-part-3/</a></figcaption></figure><p id="a0f7" class="pw-post-body-paragraph ki kj in kk b kl ly kn ko kp lz kr ks kt ma kv kw kx mb kz la lb mc ld le lf ig bi translated">因此，年轻区域中的垃圾收集比老区域中的垃圾收集更频繁。</p><p id="4e82" class="pw-post-body-paragraph ki kj in kk b kl ly kn ko kp lz kr ks kt ma kv kw kx mb kz la lb mc ld le lf ig bi translated">当旧区域快满时，<strong class="kk io">主 GC 运行。</strong>这个<strong class="kk io"> </strong>在整个堆内存上运行，释放未被引用的对象。</p><p id="4906" class="pw-post-body-paragraph ki kj in kk b kl ly kn ko kp lz kr ks kt ma kv kw kx mb kz la lb mc ld le lf ig bi translated">资源链接:</p><ul class=""><li id="307d" class="mu mv in kk b kl ly kp lz kt mw kx mx lb my lf mz na nb nc bi translated"><a class="ae nn" href="https://www.javatpoint.com/difference-between-jdk-jre-and-jvm" rel="noopener ugc nofollow" target="_blank">https://www . Java point . com/difference-between-JDK-JRE-and-JVM</a></li><li id="4d79" class="mu mv in kk b kl nd kp ne kt nf kx ng lb nh lf mz na nb nc bi translated"><a class="ae nn" href="https://www.javatpoint.com/difference-between-jdk-jre-and-jvm" rel="noopener ugc nofollow" target="_blank">https://www . Java point . com/difference-between-JDK-JRE-and-JVM</a></li><li id="1952" class="mu mv in kk b kl nd kp ne kt nf kx ng lb nh lf mz na nb nc bi translated"><a class="ae nn" href="https://www.youtube.com/watch?v=UnaNQgzw4zY" rel="noopener ugc nofollow" target="_blank">ttps://www . YouTube . com/watch？v = unanqgzw 4 zyh</a>(Java 中的垃圾收集)</li><li id="5798" class="mu mv in kk b kl nd kp ne kt nf kx ng lb nh lf mz na nb nc bi translated"><a class="ae nn" href="https://www.tutorialspoint.com/difference-between-internal-fragmentation-and-external-fragmentation" rel="noopener ugc nofollow" target="_blank">https://www . tutorialspoint . com/difference-between-internal-fragmentation-and-external-fragmentation</a></li><li id="1405" class="mu mv in kk b kl nd kp ne kt nf kx ng lb nh lf mz na nb nc bi translated"><a class="ae nn" href="https://www.youtube.com/watch?v=ZhbIReLe-r8" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=ZhbIReLe-r8</a></li><li id="f6bc" class="mu mv in kk b kl nd kp ne kt nf kx ng lb nh lf mz na nb nc bi translated"><a class="ae nn" href="https://www.ibm.com/cloud/blog/jvm-vs-jre-vs-jdk" rel="noopener ugc nofollow" target="_blank">https://www.ibm.com/cloud/blog/jvm-vs-jre-vs-jdk</a></li><li id="d172" class="mu mv in kk b kl nd kp ne kt nf kx ng lb nh lf mz na nb nc bi translated"><a class="ae nn" href="https://www.youtube.com/watch?v=LTnp79Ke8FI" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=LTnp79Ke8FI</a></li><li id="07cf" class="mu mv in kk b kl nd kp ne kt nf kx ng lb nh lf mz na nb nc bi translated"><a class="ae nn" href="https://www.youtube.com/watch?v=UDZX4UGj9_Y" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=UDZX4UGj9_Y</a></li></ul></div></div>    
</body>
</html>