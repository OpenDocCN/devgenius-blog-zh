<html>
<head>
<title>Basics of Container Isolation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">容器隔离的基础</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/basics-of-container-isolation-5eabdb258409?source=collection_archive---------4-----------------------#2022-04-01">https://blog.devgenius.io/basics-of-container-isolation-5eabdb258409?source=collection_archive---------4-----------------------#2022-04-01</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="505e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在过去的 5 年里，我一直在工作中使用容器，但我从来没有费心去检查引擎盖下面。对我来说,<code class="fe ki kj kk kl b">docker</code>二进制文件是一个神奇的工具，它让我可以创建 docker 映像并快速旋转完全隔离的容器，没有任何麻烦。</p><p id="a044" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最近我开始读一本关于集装箱安全的书，作者是利兹·赖斯。书中有一章专门讨论容器隔离，它将带您深入了解不同的基本 linux 结构，如<code class="fe ki kj kk kl b">cgroups</code>、<code class="fe ki kj kk kl b">namespaces</code>和<code class="fe ki kj kk kl b">chroot</code>，它们是如何被一起用来将容器相互隔离的。</p><p id="314c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这篇文章中，我将尝试提炼出一些概念，我们将看到一个小的演示，展示如何使用基本的 linux 构造来实现一个看起来像容器的过程。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi kn"><img src="../Images/e1d37843d734974d2e6782a6d1fa213c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Eu2zB3v0KpD8CZb27R0eHg.png"/></div></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">来源:<a class="ae km" href="https://financialtribune.com/articles/domestic-economy/109723/qom-exports-reach-57m-in-four-months" rel="noopener ugc nofollow" target="_blank">https://financial tribune . com/articles/domestic-economy/109723/Qom-exports-reach-5700 万四个月</a></figcaption></figure><h1 id="d4aa" class="ld le in bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">目录</h1><ol class=""><li id="29ff" class="mb mc in jm b jn md jr me jv mf jz mg kd mh kh mi mj mk ml bi translated">资源隔离使用<code class="fe ki kj kk kl b">cgroups</code></li><li id="8d71" class="mb mc in jm b jn mm jr mn jv mo jz mp kd mq kh mi mj mk ml bi translated">用名称空间进行资源分区</li><li id="de79" class="mb mc in jm b jn mm jr mn jv mo jz mp kd mq kh mi mj mk ml bi translated">组合名称空间和 chroot</li><li id="cbaf" class="mb mc in jm b jn mm jr mn jv mo jz mp kd mq kh mi mj mk ml bi translated">结论</li></ol><h1 id="1b4c" class="ld le in bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">1.使用 cgroups 的资源隔离</h1><p id="b195" class="pw-post-body-paragraph jk jl in jm b jn md jp jq jr me jt ju jv mr jx jy jz ms kb kc kd mt kf kg kh ig bi translated">在 Linux 中，控制组(cgroups)是一个内核特性，它允许为一组进程隔离 CPU、内存、磁盘 IO、网络等资源的使用。</p><p id="4099" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Linux 中每种类型的资源都有一个 cgroup 层次结构。这些层次在<code class="fe ki kj kk kl b">/sys/fs/cgroup</code>被表示为伪文件系统。</p><p id="e3a3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您可以使用以下命令查看系统中存在的各种 cgroups。</p><pre class="ko kp kq kr gt mu kl mv mw aw mx bi"><span id="868a" class="my le in kl b gy mz na l nb nc">sushil11gcp@isolation-demo:/sys/fs/cgroup$ ls</span><span id="011f" class="my le in kl b gy nd na l nb nc">blkio  cpu  cpu,cpuacct  cpuacct  cpuset  devices  freezer  hugetlb  memory  net_cls  net_cls,net_prio  net_prio  perf_event  pids  rdma  systemd  unified</span></pre><p id="98d8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">正如文件夹名称所固有的，每个条目负责一种类型的资源。如果您进一步查看其中一个文件夹，您会看到可以控制的不同属性。例如，让我们看看<code class="fe ki kj kk kl b">memory</code> cgroup。</p><pre class="ko kp kq kr gt mu kl mv mw aw mx bi"><span id="c1e9" class="my le in kl b gy mz na l nb nc">sushil11gcp@isolation-demo:/sys/fs/cgroup$ ls memory</span><span id="fbcd" class="my le in kl b gy nd na l nb nc">cgroup.procs  memory.soft_limit_in_bytes<br/>memory.limit_in_bytes  memory.max_usage_in_bytes                       memory.usage_in_bytes      </span></pre><p id="b64e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我截取了这个命令的输出，只向您展示了一些文件。每个文件控制一个特定的属性。例如<code class="fe ki kj kk kl b">memory.limit_in_bytes</code>控制这个 cgroup 中的一个进程可以使用的最大内存。另一个名为<code class="fe ki kj kk kl b">cgroup.procs</code>的文件列出了属于这个 cgroup 的所有进程。您可以操作这些文件中的一些来改变 cgroup 的行为，并且这些文件中的一些由内核编写来维护 cgroup 的当前状态。</p><h2 id="66a1" class="my le in bd lf ne nf dn lj ng nh dp ln jv ni nj lr jz nk nl lv kd nm nn lz no bi translated">创建群组</h2><p id="340d" class="pw-post-body-paragraph jk jl in jm b jn md jp jq jr me jt ju jv mr jx jy jz ms kb kc kd mt kf kg kh ig bi translated">通过在 cgroup 目录下为特定资源创建一个目录，您可以为该资源创建自己的 cgroup。</p><pre class="ko kp kq kr gt mu kl mv mw aw mx bi"><span id="4137" class="my le in kl b gy mz na l nb nc">root@isolation-demo:~# mkdir /sys/fs/cgroup/memory/sushil</span></pre><p id="d808" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">内核将在这个目录中为属性和状态创建所有必要的文件。</p><pre class="ko kp kq kr gt mu kl mv mw aw mx bi"><span id="880d" class="my le in kl b gy mz na l nb nc">root@isolation-demo:~# ls /sys/fs/cgroup/memory/sushil</span><span id="87e4" class="my le in kl b gy nd na l nb nc">cgroup.clone_children  memory.kmem.failcnt             memory.kmem.tcp.limit_in_bytes      memory.max_usage_in_bytes        memory.move_charge_at_immigrate  memory.stat            tasks<br/>cgroup.event_control   memory.kmem.limit_in_bytes      memory.kmem.tcp.max_usage_in_bytes  memory.memsw.failcnt             memory.numa_stat                 memory.swappiness<br/>cgroup.procs           memory.kmem.max_usage_in_bytes  memory.kmem.tcp.usage_in_bytes      memory.memsw.limit_in_bytes      memory.oom_control               memory.usage_in_bytes<br/>memory.failcnt         memory.kmem.slabinfo            memory.kmem.usage_in_bytes          memory.memsw.max_usage_in_bytes  memory.pressure_level            memory.use_hierarchy<br/>memory.force_empty     memory.kmem.tcp.failcnt         memory.limit_in_bytes               memory.memsw.usage_in_bytes      memory.soft_limit_in_bytes       notify_on_release</span></pre><h2 id="dded" class="my le in bd lf ne nf dn lj ng nh dp ln jv ni nj lr jz nk nl lv kd nm nn lz no bi translated">为进程设置内存限制</h2><p id="488a" class="pw-post-body-paragraph jk jl in jm b jn md jp jq jr me jt ju jv mr jx jy jz ms kb kc kd mt kf kg kh ig bi translated">现在让我们编辑<code class="fe ki kj kk kl b">memory.limit_in_bytes</code>文件，并将最大内存设置为<code class="fe ki kj kk kl b">100 kbs</code>。</p><pre class="ko kp kq kr gt mu kl mv mw aw mx bi"><span id="f98a" class="my le in kl b gy mz na l nb nc">echo 100000 &gt; /sys/fs/cgroup/memory/sushil/m<!-- -->emory.<!-- -->limit_in_bytes</span></pre><p id="184d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">通过将 shell 的<code class="fe ki kj kk kl b">PID</code>写入<code class="fe ki kj kk kl b">/sys/fs/cgroup/memory/sushil/cgroup.procs</code>，将当前 shell 添加到这个 cgroup 中。</p><pre class="ko kp kq kr gt mu kl mv mw aw mx bi"><span id="1085" class="my le in kl b gy mz na l nb nc">root@isolation-demo:/sys/fs/cgroup# ps<br/>    PID TTY          TIME CMD<br/>   1973 pts/1    00:00:00 sudo<br/>   1974 pts/1    00:00:00 su<br/>   <strong class="kl io">1975 pts/1    00:00:00 bash</strong><br/>   1983 pts/1    00:00:00 ps</span><span id="9022" class="my le in kl b gy nd na l nb nc">root@isolation-demo:/sys/fs/cgroup# echo 1975 &gt; /sys/fs/cgroup/memory/sushil/cgroup.procs</span></pre><p id="b81c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">接下来尝试任何命令，这将杀死外壳，因为 100kb 是非常少的内存工作。</p><pre class="ko kp kq kr gt mu kl mv mw aw mx bi"><span id="c932" class="my le in kl b gy mz na l nb nc">root@isolation-demo:/sys/fs/cgroup# ls<br/>Killed</span></pre><p id="944c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用 cgroups 容器运行时会限制每个容器的资源使用。当您启动一个容器时，运行时会创建一个单独的 cgroup 来放置资源限制。</p><h2 id="1b7c" class="my le in bd lf ne nf dn lj ng nh dp ln jv ni nj lr jz nk nl lv kd nm nn lz no bi translated">Docker cgroup 演示</h2><p id="02c2" class="pw-post-body-paragraph jk jl in jm b jn md jp jq jr me jt ju jv mr jx jy jz ms kb kc kd mt kf kg kh ig bi translated">让我们为此做一个小演示。让我们启动一个 docker 容器，看看它是否会创建一个单独的 cgroup。</p><pre class="ko kp kq kr gt mu kl mv mw aw mx bi"><span id="f988" class="my le in kl b gy mz na l nb nc">sushil11gcp@isolation-demo:~$ <strong class="kl io">sudo docker run -d -m 100m nginx</strong><br/>Unable to find image 'nginx:latest' locally<br/>latest: Pulling from library/nginx<br/>c229119241af: Pull complete <br/>2215908dc0a2: Pull complete <br/>08c3cb2073f1: Pull complete <br/>18f38162c0ce: Pull complete <br/>10e2168f148a: Pull complete <br/>c4ffe9532b5f: Pull complete <br/>Digest: sha256:2275af0f20d71b293916f1958f8497f987b8d8fd8113df54635f2a5915002bf1<br/>Status: Downloaded newer image for nginx:latest<br/>17fa32e039f2dcd8ad7dfbb0a9eb192ff01f38f47a8befd7cbf3040ef5a4d20a</span></pre><p id="b453" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里我们启动一个 nginx 容器，内存限制为<code class="fe ki kj kk kl b">100 MB</code>。接下来，我们将检查这个容器是否有内存组。将使用容器 ID 创建 cgroup。</p><pre class="ko kp kq kr gt mu kl mv mw aw mx bi"><span id="6fe8" class="my le in kl b gy mz na l nb nc">sushil11gcp@isolation-demo:~$ lscgroup memory:/ | grep 17fa32e039f2dcd8ad7dfbb0a9eb192ff01f38f47a8befd7cbf3040ef5a4d20a</span><span id="b204" class="my le in kl b gy nd na l nb nc"><strong class="kl io">memory:/docker/17fa32e039f2dcd8ad7dfbb0a9eb192ff01f38f47a8befd7cbf3040ef5a4d20a</strong></span></pre><p id="18c9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">确实有一个内存 cgroup。现在让我们检查一下<code class="fe ki kj kk kl b">memory.limit_in_bytes</code>文件，看看是否传播了正确的限制。</p><pre class="ko kp kq kr gt mu kl mv mw aw mx bi"><span id="e0d2" class="my le in kl b gy mz na l nb nc">sushil11gcp@isolation-demo:~$ cat /sys/fs/cgroup/memory/docker/17fa32e039f2dcd8ad7dfbb0a9eb192ff01f38f47a8befd7cbf3040ef5a4d20a/memory.limit_in_bytes <br/><strong class="kl io">104857600</strong></span></pre><p id="648f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">通过将 100MB 四舍五入到最接近的 KB 来设置该值。任何违反 cgroup 限制的情况都将由内核通过杀死容器来处理，在这种情况下，容器运行时将抛出 OOM。</p><p id="1790" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">接下来让我们理解 Linux 名称空间的用法。</p><h1 id="2e3e" class="ld le in bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">2.用名称空间进行资源分区</h1><p id="0bdd" class="pw-post-body-paragraph jk jl in jm b jn md jp jq jr me jt ju jv mr jx jy jz ms kb kc kd mt kf kg kh ig bi translated">名称空间是 Linux 内核的一个特性，它允许为一组进程划分资源。简单地说，如果 cgroups 限制了资源的使用，那么名称空间就限制了进程可以看到的资源。通过将一个进程放在一个名称空间中，可以限制它可以看到的资源。</p><p id="19b1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">支持几种不同类型名称空间:</p><ol class=""><li id="e043" class="mb mc in jm b jn jo jr js jv np jz nq kd nr kh mi mj mk ml bi translated">挂载(<code class="fe ki kj kk kl b">mount</code>)</li><li id="1635" class="mb mc in jm b jn mm jr mn jv mo jz mp kd mq kh mi mj mk ml bi translated">进程 ID ( <code class="fe ki kj kk kl b">pid</code>)</li><li id="cc08" class="mb mc in jm b jn mm jr mn jv mo jz mp kd mq kh mi mj mk ml bi translated">网络(<code class="fe ki kj kk kl b">net</code>)</li><li id="97d9" class="mb mc in jm b jn mm jr mn jv mo jz mp kd mq kh mi mj mk ml bi translated">进程间通信(<code class="fe ki kj kk kl b">ipc</code>)</li><li id="b575" class="mb mc in jm b jn mm jr mn jv mo jz mp kd mq kh mi mj mk ml bi translated">Unix 分时系统(<code class="fe ki kj kk kl b">uts</code>)</li><li id="96df" class="mb mc in jm b jn mm jr mn jv mo jz mp kd mq kh mi mj mk ml bi translated">用户 ID ( <code class="fe ki kj kk kl b">user</code>)</li><li id="7b69" class="mb mc in jm b jn mm jr mn jv mo jz mp kd mq kh mi mj mk ml bi translated">对照组(<code class="fe ki kj kk kl b">cgroup</code>)</li></ol><p id="26c7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">新的名称空间可以在 Linux 内核的未来版本中引入。</p><p id="f993" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">每个进程只能是特定类型的单个命名空间的一部分。子进程也继承父进程的名称空间。</p><p id="aae6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用<code class="fe ki kj kk kl b">lsns</code>命令可以看到系统上不同的名称空间。当您启动系统时，每种类型只有一个名称空间。</p><pre class="ko kp kq kr gt mu kl mv mw aw mx bi"><span id="5565" class="my le in kl b gy mz na l nb nc">sushil11gcp@isolation-demo:~$ lsns<br/>        <br/>        <strong class="kl io">NS TYPE   NPROCS   PID USER        COMMAND</strong><br/>4026531835 cgroup      3  1588 sushil11gcp /lib/systemd/systemd --user<br/>4026531836 pid         3  1588 sushil11gcp /lib/systemd/systemd --user<br/>4026531837 user        3  1588 sushil11gcp /lib/systemd/systemd --user<br/>4026531838 uts         3  1588 sushil11gcp /lib/systemd/systemd --user<br/>4026531839 ipc         3  1588 sushil11gcp /lib/systemd/systemd --user<br/>4026531840 mnt         3  1588 sushil11gcp /lib/systemd/systemd --user<br/>4026531992 net         3  1588 sushil11gcp /lib/systemd/systemd --user</span></pre><p id="8ed3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">容器使用名称空间来划分不同的资源。例如，每个容器都有自己的主机名、自己的网络堆栈、自己的一组 cgroups，并且只能看到在其中运行的进程。这是通过使每个容器成为单独名称空间的一部分来实现的。在这一节中，我们将看到如何做到这一点。</p><p id="c61f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">首先让我们理解问题陈述。从您的 shell 启动另一个 shell，它将是当前 shell 的子进程，并将继承它的名称空间。在启动新的 shell 之前，发出一个<code class="fe ki kj kk kl b">ps</code>命令来获取当前 shell 进程可以看到的进程列表。接下来使用<code class="fe ki kj kk kl b">sh</code>命令启动一个新的 shell 进程，并列出这个子 shell 可见的进程。</p><pre class="ko kp kq kr gt mu kl mv mw aw mx bi"><span id="5d9b" class="my le in kl b gy mz na l nb nc"><strong class="kl io">sushil11gcp@isolation-demo:~$ ps</strong><br/>    PID TTY          TIME CMD<br/>   <strong class="kl io">1815 pts/1    00:00:00 bash</strong><br/>  16787 pts/1    00:00:00 ps<br/><strong class="kl io">sushil11gcp@isolation-demo:~$ sh</strong><br/>$ ps<br/>    PID TTY          TIME CMD<br/>   <strong class="kl io">1815 pts/1    00:00:00 bash</strong><br/>  16788 pts/1    00:00:00 sh<br/>  16789 pts/1    00:00:00 ps</span></pre><p id="0de5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您可以验证子 shell 进程可以看到父进程可以看到的所有进程。说到容器，这是不可接受的。每个容器应该只能看到自己的子进程，仅此而已。</p><p id="cd58" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在让我们来解决这个问题。</p><p id="5fa4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们使用<code class="fe ki kj kk kl b">unshare</code>命令在新的<code class="fe ki kj kk kl b">pid</code>名称空间中启动子流程。创建一个新的名称空间需要提升权限，因此我们将使用<code class="fe ki kj kk kl b">sudo</code>来完成。</p><pre class="ko kp kq kr gt mu kl mv mw aw mx bi"><span id="ec8a" class="my le in kl b gy mz na l nb nc">sushil11gcp@isolation-demo:~$ <strong class="kl io">sudo unshare --pid --fork sh</strong><br/># ps<br/>    PID TTY          TIME CMD<br/>  26168 pts/1    00:00:00 sudo<br/>  26169 pts/1    00:00:00 unshare<br/>  26170 pts/1    00:00:00 sh<br/>  26171 pts/1    00:00:00 ps</span></pre><blockquote class="ns nt nu"><p id="92c2" class="jk jl nv jm b jn jo jp jq jr js jt ju nw jw jx jy nx ka kb kc ny ke kf kg kh ig bi translated">注意:<code class="fe ki kj kk kl b">--fork</code>标志是为了确保新的<code class="fe ki kj kk kl b">sh</code>进程被正确附加为<code class="fe ki kj kk kl b">unshare</code>的子进程，而不是<code class="fe ki kj kk kl b">sudo</code>的子进程</p></blockquote><p id="8431" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您可以通过再次以 sudo 身份运行<code class="fe ki kj kk kl b">lsns</code>命令来验证<code class="fe ki kj kk kl b">sh</code>进程是否在新的<code class="fe ki kj kk kl b">PID</code>名称空间中运行。</p><pre class="ko kp kq kr gt mu kl mv mw aw mx bi"><span id="acb9" class="my le in kl b gy mz na l nb nc">sushil11gcp@isolation-demo:~$ sudo lsns<br/>        NS TYPE   NPROCS   PID USER            COMMAND<br/>4026531835 cgroup    119     1 root            /sbin/init<br/>4026531836 pid       115     1 root            /sbin/init<br/>4026531837 user      119     1 root            /sbin/init<br/>4026531838 uts       114     1 root            /sbin/init<br/>4026531839 ipc       116     1 root            /sbin/init<br/>4026531840 mnt       109     1 root            /sbin/init<br/>4026531860 mnt         1    23 root            kdevtmpfs<br/>4026531992 net       116     1 root            /sbin/init<br/>4026532203 mnt         1   200 root            /lib/systemd/systemd-udevd<br/>4026532204 uts         1   200 root            /lib/systemd/systemd-udevd<br/>4026532251 mnt         1   427 systemd-network /lib/systemd/systemd-networkd<br/>4026532252 mnt         1   432 systemd-resolve /lib/systemd/systemd-resolved<br/>4026532253 mnt         2  1245 _chrony         /usr/sbin/chronyd -F -1<br/><strong class="kl io">4026532260 mnt         3 16228 root            nginx: master process nginx -g daemon off;<br/>4026532261 uts         3 16228 root            nginx: master process nginx -g daemon off;<br/>4026532262 ipc         3 16228 root            nginx: master process nginx -g daemon off;<br/>4026532263 pid         3 16228 root            nginx: master process nginx -g daemon off;<br/>4026532265 net         3 16228 root            nginx: master process nginx -g daemon off;</strong><br/>4026532314 mnt         1   916 root            /lib/systemd/systemd-logind<br/>4026532315 uts         1   916 root            /lib/systemd/systemd-logind<br/><strong class="kl io">4026532326 pid         1 26465 root            sh</strong></span></pre><p id="d4ea" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">另外，您可以看到由我们在上一节中开始的<code class="fe ki kj kk kl b">nginx</code>容器创建的不同名称空间。</p><p id="60ff" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们继续。如果您现在发出一个<code class="fe ki kj kk kl b">ps</code>命令，您将看到新的 shell 进程仍然可以看到系统范围内的所有进程。这意味着在单独的<code class="fe ki kj kk kl b">PID</code>名称空间中拥有一个进程是不够的。</p><p id="19ea" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">答案在于<code class="fe ki kj kk kl b">ps</code>命令如何获取进程信息。如果您阅读<a class="ae km" href="https://man7.org/linux/man-pages/man1/ps.1.html" rel="noopener ugc nofollow" target="_blank">手册页</a>，您会看到它读取了<code class="fe ki kj kk kl b">/proc</code>目录中的虚拟文件。如果您从子 shell 进程中列出<code class="fe ki kj kk kl b">proc</code>目录，您将会看到它包含主机可用的所有信息。</p><pre class="ko kp kq kr gt mu kl mv mw aw mx bi"><span id="7f2e" class="my le in kl b gy mz na l nb nc">sushil11gcp@isolation-demo:~$ sudo unshare --pid --fork sh<br/><strong class="kl io"># ls /proc<br/></strong>1    115   128   16190  17     20     25     26286  3     321  4    579  79  87   941         buddyinfo  diskstats      interrupts  kmsg         misc          schedstat  sysrq-trigger      vmallocinfo</span></pre><p id="b816" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这意味着一个单独的<code class="fe ki kj kk kl b">PID</code>名称空间是不够的，我们需要为我们的 shell 进程有一个单独的根目录，因为<code class="fe ki kj kk kl b">/proc</code>文件在根目录中。就像一个容器看不到整个主机文件系统一样，我们必须为我们的进程创建一个新的根，以限制它读取主机的<code class="fe ki kj kk kl b">/proc</code>文件或任何文件。</p><p id="17a1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这就是<code class="fe ki kj kk kl b">chroot</code>效用发挥作用的时候。<code class="fe ki kj kk kl b">chroot</code>允许改变任何进程的根目录，一旦完成，这个进程就失去了对新根目录之上的任何东西的访问，因为根目录是任何进程的最顶层目录。</p><pre class="ko kp kq kr gt mu kl mv mw aw mx bi"><span id="8433" class="my le in kl b gy mz na l nb nc">sudo chroot NEW_ROOT_DIR RUN_COMMAND</span></pre><p id="ce5a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ki kj kk kl b">chroot</code>运行 root 设置为新 root 的命令。如果未给出<code class="fe ki kj kk kl b">RUN_COMMAND</code>，则默认为<code class="fe ki kj kk kl b">${SHELL}</code>。</p><p id="54c0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们试着看一个例子。</p><pre class="ko kp kq kr gt mu kl mv mw aw mx bi"><span id="168f" class="my le in kl b gy mz na l nb nc">sushil11gcp@isolation-demo:~$ echo $SHELL<br/>/bin/bash<br/>sushil11gcp@isolation-demo:~$ mkdir new_root<br/>sushil11gcp@isolation-demo:~$ <strong class="kl io">sudo chroot new_root</strong><br/><strong class="kl io">chroot: failed to run command ‘/bin/bash’: No such file or directory</strong></span></pre><p id="b7ad" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">显然，当<code class="fe ki kj kk kl b">new_root</code>目录为空并且没有<code class="fe ki kj kk kl b">/bin/bash</code>文件时，您会得到这个错误。新根目录中没有命令/文件。</p><p id="c058" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">容器中也会发生这种情况。当您运行一个容器时，新的进程获得一个新的根目录，新的根目录由 docker 映像的内容填充，docker 映像成为容器的根文件系统。</p><p id="f4ae" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们努力效仿这一点。下载 alpine linux inside <code class="fe ki kj kk kl b">new_root</code>目录，看看我们的新进程能否使用它。</p><pre class="ko kp kq kr gt mu kl mv mw aw mx bi"><span id="7936" class="my le in kl b gy mz na l nb nc">mkdir alpine<br/>cd alpine<br/>curl -o alpine.tar.gz <a class="ae km" href="http://dl-cdn.alpinelinux.org/alpine/v3.10/releases/x86_64/alpine-minirootfs-3.10.0-x86_64.tar.gz" rel="noopener ugc nofollow" target="_blank">http://dl-cdn.alpinelinux.org/alpine/v3.10/releases/x86_64/alpine-minirootfs-3.10.0-x86_64.tar.gz</a><br/>tar xvf alpine.tar.gz<br/>rm alpine.tar.gz<br/>cd ..</span></pre><p id="3e3d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在让我们再次启动一个新的进程，但是以<code class="fe ki kj kk kl b">alpine</code>目录作为根目录。</p><pre class="ko kp kq kr gt mu kl mv mw aw mx bi"><span id="9c98" class="my le in kl b gy mz na l nb nc">sushil11gcp@isolation-demo:~$ <strong class="kl io">sudo chroot alpine ls</strong><br/>bin    dev    etc    home   lib    media  mnt    opt    proc   root   run    sbin   srv    sys    tmp    usr    var</span></pre><p id="a748" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">新进程现在可以看到由 alpine linux 实例化的根文件系统。用这个新根缝一个壳，然后修补一下。</p><pre class="ko kp kq kr gt mu kl mv mw aw mx bi"><span id="4831" class="my le in kl b gy mz na l nb nc">sushil11gcp@isolation-demo:~$ <strong class="kl io">sudo chroot alpine sh</strong><br/>/ # ps<br/>PID   USER     TIME  COMMAND<br/>/ #</span></pre><p id="35f4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">发出一个<code class="fe ki kj kk kl b">ps</code>命令，它将返回一个空列表。您可以通过列出同样为空的<code class="fe ki kj kk kl b">/proc</code>目录来验证这一点。现在我们的新进程有了一个独立于主机的<code class="fe ki kj kk kl b">/proc</code>目录。这个目录现在可以被单独的<code class="fe ki kj kk kl b">PID</code>命名空间中的新进程用来写入进程信息。</p><h1 id="7267" class="ld le in bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">3.组合名称空间和 chroot</h1><p id="8093" class="pw-post-body-paragraph jk jl in jm b jn md jp jq jr me jt ju jv mr jx jy jz ms kb kc kd mt kf kg kh ig bi translated">现在让我们将<code class="fe ki kj kk kl b">unshare</code>和<code class="fe ki kj kk kl b">chroot</code>结合起来，给这个过程一个单独的<code class="fe ki kj kk kl b">/proc</code>目录。</p><pre class="ko kp kq kr gt mu kl mv mw aw mx bi"><span id="b395" class="my le in kl b gy mz na l nb nc">sushil11gcp@isolation-demo:~$ <strong class="kl io">sudo unshare --pid --fork chroot alpine sh</strong><br/>/ # ls<br/>bin    dev    etc    home   lib    media  mnt    opt    proc   root   run    sbin   srv    sys    tmp    usr    var<br/>/ # ps<br/>PID   USER     TIME  COMMAND<br/>/ #</span></pre><p id="b718" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">结果仍然看不到任何进程信息。这是因为您需要将<code class="fe ki kj kk kl b">/proc</code>目录挂载为<code class="fe ki kj kk kl b">proc</code>类型的伪文件系统。</p><pre class="ko kp kq kr gt mu kl mv mw aw mx bi"><span id="15ff" class="my le in kl b gy mz na l nb nc">mount -t proc proc proc</span></pre><p id="438a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个命令告诉将<code class="fe ki kj kk kl b">/proc</code>目录挂载到类型为<code class="fe ki kj kk kl b">proc</code>的<code class="fe ki kj kk kl b">/proc</code>中。我知道这有点令人困惑。请参考 mount 命令的<a class="ae km" href="https://man7.org/linux/man-pages/man8/mount.8.html" rel="noopener ugc nofollow" target="_blank">手册页以更好地理解它。一旦完成，再次发出<code class="fe ki kj kk kl b">ps</code>命令，您将开始看到进程信息。</a></p><pre class="ko kp kq kr gt mu kl mv mw aw mx bi"><span id="3dea" class="my le in kl b gy mz na l nb nc">/ # <strong class="kl io">mount -t proc proc proc</strong><br/><strong class="kl io">/ # ps</strong><br/>PID   USER     TIME  COMMAND<br/>    1 root      0:00 sh<br/>    5 root      0:00 ps</span></pre><p id="b71b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您还可以看到,<code class="fe ki kj kk kl b">PID</code>已经在这个 shell 中重启，这也巩固了对这个进程确实在一个单独的<code class="fe ki kj kk kl b">PID</code>名称空间中的理解。</p><h1 id="c516" class="ld le in bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">4.结论</h1><p id="4991" class="pw-post-body-paragraph jk jl in jm b jn md jp jq jr me jt ju jv mr jx jy jz ms kb kc kd mt kf kg kh ig bi translated">在这篇文章中，我们看到了容器如何使用基本的 Linux 概念，比如 cgroups、namespaces 和 chroot 来实现隔离。除了本文中提到的名称空间，容器还可以使用更多的名称空间，比如<code class="fe ki kj kk kl b">UTS</code>使用单独的主机名、<code class="fe ki kj kk kl b">mount</code>使用卷挂载、<code class="fe ki kj kk kl b">user</code>使用单独的用户列表、<code class="fe ki kj kk kl b">net</code>使用单独的网络堆栈、<code class="fe ki kj kk kl b">ipc</code>使用单独的通道进行进程间通信、<code class="fe ki kj kk kl b">cgroup</code>名称空间在容器内部使用单独的 cgroups。</p><p id="615a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">涵盖所有这些名称空间超出了本博客的范围，我强烈建议您研究更多的名称空间，并在互联网上阅读更多关于它们的内容。</p><h1 id="90ab" class="ld le in bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">参考</h1><ol class=""><li id="57eb" class="mb mc in jm b jn md jr me jv mf jz mg kd mh kh mi mj mk ml bi translated"><a class="ae km" href="https://www.nginx.com/blog/what-are-namespaces-cgroups-how-do-they-work/" rel="noopener ugc nofollow" target="_blank">https://www . nginx . com/blog/what-are-namespaces-cgroups-how-do-they-work/</a></li><li id="57a3" class="mb mc in jm b jn mm jr mn jv mo jz mp kd mq kh mi mj mk ml bi translated"><a class="ae km" href="https://en.wikipedia.org/wiki/Linux_namespaces" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Linux_namespaces</a></li></ol></div></div>    
</body>
</html>