<html>
<head>
<title>Writing an X86–64 Assembly Language Program</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编写X86–64汇编语言程序</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/finding-an-efficient-development-cycle-for-writing-assembly-language-be2092e6db6a?source=collection_archive---------4-----------------------#2021-09-17">https://blog.devgenius.io/finding-an-efficient-development-cycle-for-writing-assembly-language-be2092e6db6a?source=collection_archive---------4-----------------------#2021-09-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/03ce85a583ca9023bfe7678212e73afc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z9B13VC-sJLpeHY-YAVULw.jpeg"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">使用Docker简化汇编开发</figcaption></figure><div class=""/><div class=""><h2 id="9579" class="pw-subtitle-paragraph kc je jf bd b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dk translated">第二部分:寻找编写汇编语言的有效开发周期</h2></div><h2 id="bbc1" class="ku kv jf bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">本指南是系列的第二部分</h2><ul class=""><li id="d3c7" class="lq lr jf ls b lt lu lv lw ld lx lh ly ll lz ma mb mc md me bi translated">第一部分:<a class="ae mf" href="https://medium.com/@tony.oreglia/getting-started-writing-assembly-language-8ecc116f3627" rel="noopener">开始编写汇编语言</a></li></ul><h2 id="c1f5" class="ku kv jf bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">本指南后面是</h2><ul class=""><li id="eaef" class="lq lr jf ls b lt lu lv lw ld lx lh ly ll lz ma mb mc md me bi translated">第三部分:<a class="ae mf" href="https://medium.com/@tony.oreglia/writing-an-x86-64-assembly-language-program-648b6005e8e" rel="noopener">打印命令行参数</a></li><li id="cac0" class="lq lr jf ls b lt mg lv mh ld mi lh mj ll mk ma mb mc md me bi translated">第四部分:<a class="ae mf" href="https://medium.com/@tony.oreglia/writing-an-x86-64-assembly-language-program-function-arguments-and-result-dfff25970dee" rel="noopener">发送函数参数并接收返回值</a></li><li id="3266" class="lq lr jf ls b lt mg lv mh ld mi lh mj ll mk ma mb mc md me bi translated">第五部分:<a class="ae mf" href="https://tony-oreglia.medium.com/writing-an-x86-64-assembly-language-program-1aade03f3b9b" rel="noopener">条件句，跳转，循环</a></li><li id="7cf6" class="lq lr jf ls b lt mg lv mh ld mi lh mj ll mk ma mb mc md me bi translated">第六部分:<a class="ae mf" href="https://tony-oreglia.medium.com/writing-an-x86-64-assembly-language-program-84e2432cf16b" rel="noopener">如何确定字符串长度</a></li><li id="050f" class="lq lr jf ls b lt mg lv mh ld mi lh mj ll mk ma mb mc md me bi translated">第七部分:<a class="ae mf" href="https://tony-oreglia.medium.com/writing-an-x86-64-assembly-language-program-f847d4edf577" rel="noopener">快速参考</a></li></ul></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><p id="555e" class="pw-post-body-paragraph ms mt jf ls b lt mu kg mv lv mw kj mx ld my mz na lh nb nc nd ll ne nf ng ma ij bi translated">现在，GDB与Docker合作得很好，下一步是找到一个开发周期，使您能够快速运行代码，并在需要时进行调试。</p><p id="9eff" class="pw-post-body-paragraph ms mt jf ls b lt mu kg mv lv mw kj mx ld my mz na lh nb nc nd ll ne nf ng ma ij bi translated">我更喜欢在<a class="ae mf" href="https://code.visualstudio.com/" rel="noopener ugc nofollow" target="_blank"> VS代码</a>中开发，而不是用<code class="fe nh ni nj nk b">vim</code>直接在Docker容器上开发。问题是如何在VS代码上开发，然后在现在设置好的docker容器上快速编译、链接、运行、调试代码？</p><figure class="nm nn no np gt is gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/1139d841d4cf436fe0b5a6f3bb730d15.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*MGcLJS1ZvMFcBA94PXn16Q.png"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">用VS代码开发汇编语言</figcaption></figure><p id="cb0c" class="pw-post-body-paragraph ms mt jf ls b lt mu kg mv lv mw kj mx ld my mz na lh nb nc nd ll ne nf ng ma ij bi translated">答案来自这篇有帮助的<a class="ae mf" href="https://medium.com/travis-on-docker/why-and-how-to-use-docker-for-development-a156c1de3b24" rel="noopener">博客文章</a>。这篇博文提供了一个有用的起点，介绍了如何利用映像来构建可执行文件，然后运行另一个容器来运行该可执行文件。虽然它没有涵盖汇编语言，但它正是我们需要使用的那种工作流。</p><p id="f8cb" class="pw-post-body-paragraph ms mt jf ls b lt mu kg mv lv mw kj mx ld my mz na lh nb nc nd ll ne nf ng ma ij bi translated">这篇博文建议使用这样的命令来处理构建或编译步骤。</p><pre class="nm nn no np gt nq nk nr ns aw nt bi"><span id="b0b9" class="ku kv jf nk b gy nu nv l nw nx">docker run --rm -v "$(pwd)":/app -w /app iron/node:dev sh -c 'npm install'</span></pre><p id="c88c" class="pw-post-body-paragraph ms mt jf ls b lt mu kg mv lv mw kj mx ld my mz na lh nb nc nd ll ne nf ng ma ij bi translated">但是这篇文章并没有描述这些选项的作用，所以让我们为那些不熟悉Docker的用户分解一下。注意，这只是一个示例命令，演示如何使用Docker来运行构建步骤。</p><h1 id="c39c" class="ny kv jf bd kw nz oa ob kz oc od oe lc kl of km lg ko og kp lk kr oh ks lo oi bi translated">Docker命令行参数的分解</h1><h2 id="76a6" class="ku kv jf bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">打扫</h2><pre class="nm nn no np gt nq nk nr ns aw nt bi"><span id="5331" class="ku kv jf nk b gy nu nv l nw nx">--rm</span></pre><p id="0ecc" class="pw-post-body-paragraph ms mt jf ls b lt mu kg mv lv mw kj mx ld my mz na lh nb nc nd ll ne nf ng ma ij bi translated">这只是一个构建步骤。一旦容器用于准备可执行文件，它就不需要启动和运行。这个标志告诉码头工人一旦完成就拆掉集装箱。参见Docker的文档<a class="ae mf" href="https://docs.docker.com/engine/reference/run/#clean-up---rm" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><h2 id="cb0f" class="ku kv jf bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">卷(共享文件系统)</h2><pre class="nm nn no np gt nq nk nr ns aw nt bi"><span id="ee0f" class="ku kv jf nk b gy nu nv l nw nx">-v “$(pwd)”:/app</span></pre><p id="210d" class="pw-post-body-paragraph ms mt jf ls b lt mu kg mv lv mw kj mx ld my mz na lh nb nc nd ll ne nf ng ma ij bi translated">构建步骤中的工件应该被保存。该选项创建一个Docker卷，该卷在Docker容器被拆除后保留在本地目录中。看Docker的文档<a class="ae mf" href="https://docs.docker.com/engine/reference/run/#volume-shared-filesystems" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><h2 id="0c36" class="ku kv jf bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">工作方向</h2><pre class="nm nn no np gt nq nk nr ns aw nt bi"><span id="d5b7" class="ku kv jf nk b gy nu nv l nw nx">-w /app</span></pre><p id="061b" class="pw-post-body-paragraph ms mt jf ls b lt mu kg mv lv mw kj mx ld my mz na lh nb nc nd ll ne nf ng ma ij bi translated">覆盖在基本映像中定义的工作目录。见Docker的文档<a class="ae mf" href="https://docs.docker.com/engine/reference/run/#workdir" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><h2 id="5091" class="ku kv jf bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">基本Docker图像</h2><pre class="nm nn no np gt nq nk nr ns aw nt bi"><span id="45ce" class="ku kv jf nk b gy nu nv l nw nx">iron/node:dev </span></pre><p id="2834" class="pw-post-body-paragraph ms mt jf ls b lt mu kg mv lv mw kj mx ld my mz na lh nb nc nd ll ne nf ng ma ij bi translated">用于生成的基本Docker图像。在这里找到铁/节点图像<a class="ae mf" href="https://hub.docker.com/r/iron/node" rel="noopener ugc nofollow" target="_blank">。这个映像是由</a><a class="ae mf" href="https://www.iron.io/" rel="noopener ugc nofollow" target="_blank"> iron.io </a>创建的，本质上是一个安装了node的小映像。</p><h2 id="a8fa" class="ku kv jf bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">在Docker中运行的命令</h2><pre class="nm nn no np gt nq nk nr ns aw nt bi"><span id="24f1" class="ku kv jf nk b gy nu nv l nw nx">sh -c ‘npm install’ </span></pre><p id="ea4a" class="pw-post-body-paragraph ms mt jf ls b lt mu kg mv lv mw kj mx ld my mz na lh nb nc nd ll ne nf ng ma ij bi translated">覆盖来自Docker映像的命令。这是我们想要运行的构建步骤。</p><h1 id="eef0" class="ny kv jf bd kw nz oa ob kz oc od oe lc kl of km lg ko og kp lk kr oh ks lo oi bi translated">在Docker上编译、链接和调试</h1><p id="dbe1" class="pw-post-body-paragraph ms mt jf ls b lt lu kg mv lv lw kj mx ld oj mz na lh ok nc nd ll ol nf ng ma ij bi translated">现在我们理解了这些部分，让我们把它应用到我们的汇编语言程序中。在从包含<a class="ae mf" href="https://github.com/tonyOreglia/unique-word-counter/blob/master/Dockerfile" rel="noopener ugc nofollow" target="_blank"> Dockerfile </a>的目录中运行以下命令构建名为<code class="fe nh ni nj nk b">linux-assembly</code>的映像后:</p><pre class="nm nn no np gt nq nk nr ns aw nt bi"><span id="aa4c" class="ku kv jf nk b gy nu nv l nw nx">docker build -t linux-assembly .</span></pre><p id="2253" class="pw-post-body-paragraph ms mt jf ls b lt mu kg mv lv mw kj mx ld my mz na lh nb nc nd ll ne nf ng ma ij bi translated">汇编代码可以用下面的命令进行编译和链接，使用上面列出的相同参数。</p><pre class="nm nn no np gt nq nk nr ns aw nt bi"><span id="ec13" class="ku kv jf nk b gy nu nv l nw nx">docker run --rm -v "$(pwd)":/app -w /app linux-assembly sh -c "nasm -f elf64 -F dwarf -g hellow.asm &amp;&amp; ld -m elf_x86_64 -o hw hellow.o"</span></pre><p id="6c2d" class="pw-post-body-paragraph ms mt jf ls b lt mu kg mv lv mw kj mx ld my mz na lh nb nc nd ll ne nf ng ma ij bi translated">这将在本地目录中生成一个可执行文件(<code class="fe nh ni nj nk b">hw</code>)。注意，这个可执行文件是elf64格式的，不能在Mac操作系统上运行。但是，可以使用以下命令在同一个Docker映像上运行它:</p><pre class="nm nn no np gt nq nk nr ns aw nt bi"><span id="a208" class="ku kv jf nk b gy nu nv l nw nx">docker run --rm -v "$(pwd)":/app -w /app linux-assembly sh -c "./hw"</span></pre><p id="71a8" class="pw-post-body-paragraph ms mt jf ls b lt mu kg mv lv mw kj mx ld my mz na lh nb nc nd ll ne nf ng ma ij bi translated">最后，可以使用以下命令直接在Docker容器上进行调试:</p><pre class="nm nn no np gt nq nk nr ns aw nt bi"><span id="306b" class="ku kv jf nk b gy nu nv l nw nx">docker run --rm -it --cap-add=SYS_PTRACE -v "$(pwd)":/app -w /app linux-assembly sh -c "gdb hw"</span></pre><figure class="nm nn no np gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi om"><img src="../Images/e298a78129a87413419ca670cd8eeba6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*NIXzv2PxNbT7vQTcgICn-Q.gif"/></div></div></figure><p id="fb5d" class="pw-post-body-paragraph ms mt jf ls b lt mu kg mv lv mw kj mx ld my mz na lh nb nc nd ll ne nf ng ma ij bi translated">现在，您可以使用VSCode进行本地开发，并在Docker容器上快速运行程序，或者在需要时使用Docker上的GDB进行调试。</p><p id="9d91" class="pw-post-body-paragraph ms mt jf ls b lt mu kg mv lv mw kj mx ld my mz na lh nb nc nd ll ne nf ng ma ij bi translated">感谢阅读！点击这里查看下一篇帖子，获取设置此工作流程的指导。</p></div></div>    
</body>
</html>