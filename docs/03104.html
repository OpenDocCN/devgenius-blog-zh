<html>
<head>
<title>Integrating GraphQL with GoLang: The Right Way</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将GraphQL与GoLang集成:正确的方法</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/intergrating-graphql-with-golang-the-right-way-d6a27bf4cbf7?source=collection_archive---------2-----------------------#2020-09-30">https://blog.devgenius.io/intergrating-graphql-with-golang-the-right-way-d6a27bf4cbf7?source=collection_archive---------2-----------------------#2020-09-30</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="6cd0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们将构建一个由Go-Chi和GqlGen包驱动的GoLang服务器</p></div><div class="ab cl ki kj hr kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="ig ih ii ij ik"><p id="8eb4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi kp translated"><span class="l kq kr ks bm kt ku kv kw kx di">在</span>这样一个世界里，技术和框架开始覆盖更多的编程语言，因此用户群可能更加重要，在今天的故事中，我们将使用来自99designs的完整<a class="ae ky" href="https://github.com/99designs/gqlgen" rel="noopener ugc nofollow" target="_blank"> gqlgen </a>包来集成GraphQL和GoLang。</p><p id="c50f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们将介绍如何使用这个包，包括go init和generate命令、突变和查询，以及如何使用go-chi的处理程序作为我们的HTTP go包。</p><h1 id="ac2c" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">要求</h1><ul class=""><li id="207e" class="lx ly in jm b jn lz jr ma jv mb jz mc kd md kh me mf mg mh bi translated">我们将使用GoLang，所以最好有一个语言的基础知识，因为基础知识不会一步一步地覆盖。</li><li id="34ca" class="lx ly in jm b jn mi jr mj jv mk jz ml kd mm kh me mf mg mh bi translated">它不会涵盖GraphQL的原子信息，推荐使用基本概念的知识</li><li id="522e" class="lx ly in jm b jn mi jr mj jv mk jz ml kd mm kh me mf mg mh bi translated">GoLang版本1.12或更高版本，Go模块已激活</li></ul><h1 id="da3f" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">装置</h1><p id="ca5e" class="pw-post-body-paragraph jk jl in jm b jn lz jp jq jr ma jt ju jv mn jx jy jz mo kb kc kd mp kf kg kh ig bi translated">首先，我们将继续在我们的系统中下载gqlgen和go-chi包</p><h1 id="17d2" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">项目结构</h1><p id="5071" class="pw-post-body-paragraph jk jl in jm b jn lz jp jq jr ma jt ju jv mn jx jy jz mo kb kc kd mp kf kg kh ig bi translated">我们将为GoLang使用“非官方的”标准项目<a class="ae ky" href="https://github.com/golang-standards/project-layout" rel="noopener ugc nofollow" target="_blank">布局</a>，它指明了我们项目中组织包和文件的方式。这个链接是项目的GitHub <a class="ae ky" href="https://github.com/javiersoto15/GoGraph1" rel="noopener ugc nofollow" target="_blank">库</a>,如果你想用指南编码的话</p><p id="2256" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">继续创建cmd/gograph (gograph是您的应用程序的名称，根据您的需要修改它)，并为我们的入口点添加main.go文件。</p><p id="3bdc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对于我们的API文件(路由器和处理程序)，我们将添加以下文件夹、API/路由器和API/处理程序。这些文件夹将存放我们的API相关文件；这将有助于我们保持组织性。这应该是您现在的项目结构:</p><figure class="mr ms mt mu gt mv gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/09e2db6194fdb84fefce36031e2452a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:570/format:webp/1*m4dIgq_Vwn-JRpeU0BwRpA.png"/></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">项目框架</figcaption></figure><p id="3367" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在下一节中，所有其他内容都将从我们的GQLGen包中生成。</p><h1 id="9e96" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">开始我们的图表</h1><p id="276e" class="pw-post-body-paragraph jk jl in jm b jn lz jp jq jr ma jt ju jv mn jx jy jz mo kb kc kd mp kf kg kh ig bi translated">在我们的根文件夹(我的例子是GQL-Tut)中，我们将在终端中运行以下命令来初始化我们的Go模块和GQLGen包:</p><pre class="mr ms mt mu gt nc nd ne nf aw ng bi"><span id="7afb" class="nh la in nd b gy ni nj l nk nl">go mod init<br/>go run github.com/99designs/gqlgen init</span></pre><p id="88ff" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">继续删除server.go，因为我们将使用Go-Chi创建我们的服务器文件。生成的文件如下</p><ul class=""><li id="d03a" class="lx ly in jm b jn jo jr js jv nm jz nn kd no kh me mf mg mh bi translated">gqlgen.yml:表示grapqhQL将采用的配置，例如文件、标量等的位置。</li><li id="043b" class="lx ly in jm b jn mi jr mj jv mk jz ml kd mm kh me mf mg mh bi translated">graph文件夹包含schema.graphqls(这里我们声明我们的GraphQL schemas)，模型的文件包含go translated struct。我们的解析器(查询和突变)将在schema.resolvers.go中声明，其中将包含我们的逻辑。resolver.go文件包含我们需要在解析器中实现的任何依赖项(如任何授权或数据库)</li></ul><p id="7856" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">每次编辑GraphQL模式文件时，我们都需要在我们的根文件夹中运行这个命令:</p><pre class="mr ms mt mu gt nc nd ne nf aw ng bi"><span id="c88c" class="nh la in nd b gy ni nj l nk nl">go run github.com/99designs/gqlgen generate</span></pre><p id="1e15" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，我们将让模式初始化我们的路由器和处理程序。</p><h1 id="cf13" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">实现Go-Chi路由器和处理程序</h1><p id="d4cf" class="pw-post-body-paragraph jk jl in jm b jn lz jp jq jr ma jt ju jv mn jx jy jz mo kb kc kd mp kf kg kh ig bi translated">现在，我们将创建处理程序和路由器文件，它们将为GraphQL服务器的HTTP端点提供服务。</p><p id="40a3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">首先，我们将创建我们的处理程序。我们将有两个端点，一个用于我们的POST GraphQL查询，另一个用于我们的操场。在<a class="ae ky" href="https://github.com/javiersoto15/GoGraph1/tree/master/api/handler" rel="noopener ugc nofollow" target="_blank"> api/handler </a>下创建一个handler.go文件，并编写如下代码:</p><figure class="mr ms mt mu gt mv"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="8008" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">实现非常简单。我们将创建一个Routes函数，该函数初始化我们的端点并返回一个Chi Mux对象，我们将在路由器包中使用该对象。</p><p id="c343" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">内部函数(“graphQLHandler”)是任何GraphQL查询都会触发的函数。Go-Chi使用Post和Get函数通过各自的方法设置我们的端点。第一个论点是我们的模式；第二个是http。HandlerFunc，换句话说，任何返回ResponseWriter和请求的函数。</p><p id="d2f1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们的playground函数将采用graphql处理程序端点(一旦我们到达代码的路由器部分，模式中的“v1”前缀就有意义了)来进行相应的调用。</p><p id="e372" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">确保您为我们的图形代码导入了各自的包。这将是我的路(对你来说可能不一样)</p><pre class="mr ms mt mu gt nc nd ne nf aw ng bi"><span id="a1c7" class="nh la in nd b gy ni nj l nk nl">"github.com/temp/GQL-Tut/graph"</span><span id="faf0" class="nh la in nd b gy nr nj l nk nl">"github.com/temp/GQL-Tut/graph/generated"</span></pre><p id="6c01" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，我们将在路由器文件夹下创建router.go文件，并复制以下代码:</p><figure class="mr ms mt mu gt mv"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="31c8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">从上到下，我们的initialize函数将用我们给出的特定配置(中间件和处理程序)实例化我们的Chi路由器。出于本教程的目的，我将使用最小的中间件。没有必要使用中间件，但是我推荐使用这个必备的中间件功能。</p><p id="271a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Chi赋予我们的能力是能够使用标准化的前缀模式安装不同的端点。在这种情况下，它是“/v1”。这是我用来版本化我的API的惯例，我建议你也使用它。</p><p id="10af" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们的Route函数中的第二个参数，是我们实现我们创建的处理函数“Routes”的地方。然后我们的ServeRouter函数将在我们的主文件中使用。</p><p id="e97d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这就是我们的服务器！</p><h1 id="a7fb" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">编辑我们的模式</h1><p id="1064" class="pw-post-body-paragraph jk jl in jm b jn lz jp jq jr ma jt ju jv mn jx jy jz mo kb kc kd mp kf kg kh ig bi translated">作为一个火影忍者迷，这个教程的主题将是关于它的(不需要任何关于它的知识！).对于我们的第一个GraphQL代码，我们将关注我们的模式。我们将继续前进，转到位于graph文件夹中的schema.graphqls。</p><p id="88ac" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们将首先为我们的响应定义模型，该模型将被称为Ninja，它包含以下字段。我们将对我们的两个查询(以及我们的变异)保持相同的响应</p><figure class="mr ms mt mu gt mv"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="a105" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在我们将开始创建两个名为findGenin的查询，它将返回我们正在寻找的基本级别ninja，第二个查询将返回所有的图像，顾名思义，它将返回API知道的所有图像。</p><figure class="mr ms mt mu gt mv"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="6aec" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">查询findGenin接收一个名称作为参数，并返回ninja对象。请注意，该名称包含一个“！”紧挨着他们。这意味着它不可为空，不能为空。对于忍者对象的数组，使用“！”意味着它将总是返回一个包含零个或多个元素的数组。</p><p id="03c0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们的最后一步是创建突变，通过我们的API来修改/创建数据。很简单，我们称它为registerNewNinja，它接受一个Ninja输入类型并返回一个响应。</p><figure class="mr ms mt mu gt mv"><div class="bz fp l di"><div class="np nq l"/></div></figure><h1 id="dac7" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">锅炉板代码的生成</h1><p id="b2e7" class="pw-post-body-paragraph jk jl in jm b jn lz jp jq jr ma jt ju jv mn jx jy jz mo kb kc kd mp kf kg kh ig bi translated">gqlgen的神奇之处就在这里。运行一个简单的命令，它将我们的解析器和模型生成到Go语言中。在我们的根文件夹中，运行以下命令:</p><pre class="mr ms mt mu gt nc nd ne nf aw ng bi"><span id="b9d3" class="nh la in nd b gy ni nj l nk nl">go run github.com/99designs/gqlgen</span></pre><p id="ce0f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">检查您的models_gen.go是否包含新生成的以及schema.resolvers.go是否包含我们的查询和变异。</p><h1 id="0876" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">实施我们的解决方案</h1><p id="d68f" class="pw-post-body-paragraph jk jl in jm b jn lz jp jq jr ma jt ju jv mn jx jy jz mo kb kc kd mp kf kg kh ig bi translated">现在我们转向解析器来实现我们的逻辑。我们将从在resolver.go中的resolver对象中添加一个数组开始(这将作为我们对“数据库”的抽象)</p><figure class="mr ms mt mu gt mv"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="0c08" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">接下来，我们转向我们的突变registerNewNinja。这是不言自明的</p><figure class="mr ms mt mu gt mv"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="47a5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们的两个查询在语法上相似。两者都使用过滤器来操作数据，并根据查询返回一个对象或数组。</p><figure class="mr ms mt mu gt mv"><div class="bz fp l di"><div class="np nq l"/></div></figure><figure class="mr ms mt mu gt mv"><div class="bz fp l di"><div class="np nq l"/></div></figure><h1 id="41d6" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">我们来试试吧！</h1><p id="c708" class="pw-post-body-paragraph jk jl in jm b jn lz jp jq jr ma jt ju jv mn jx jy jz mo kb kc kd mp kf kg kh ig bi translated">为了完成我们的代码，我们需要在main.go中实现ServeRouter函数。</p><figure class="mr ms mt mu gt mv"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="e57b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们用下面的命令运行应用程序(如果您遵循项目结构，您可以复制和粘贴)</p><pre class="mr ms mt mu gt nc nd ne nf aw ng bi"><span id="81d8" class="nh la in nd b gy ni nj l nk nl">go run cmd/gograph/main.go</span></pre><p id="e0fa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在我们在浏览器中去操场</p><pre class="mr ms mt mu gt nc nd ne nf aw ng bi"><span id="97d3" class="nh la in nd b gy ni nj l nk nl">localhost:8080/v1/playground</span></pre><p id="d0d8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这些是变异的例子:</p><figure class="mr ms mt mu gt mv gh gi paragraph-image"><div role="button" tabindex="0" class="nt nu di nv bf nw"><div class="gh gi ns"><img src="../Images/883cd1e0dee4014e9d809acfb1285802.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yA13NyDY1siTderoAvRK8A.png"/></div></div></figure><p id="d0fd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在您用更多的突变填充了我们的“数据库”之后，您可以使用我们的两个查询:</p><figure class="mr ms mt mu gt mv gh gi paragraph-image"><div role="button" tabindex="0" class="nt nu di nv bf nw"><div class="gh gi nx"><img src="../Images/36060584218dd44deba2fce93a5da0b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f7S81UM7NKXXywR_AXID3w.png"/></div></div></figure><figure class="mr ms mt mu gt mv gh gi paragraph-image"><div role="button" tabindex="0" class="nt nu di nv bf nw"><div class="gh gi nx"><img src="../Images/72af0fd3542ebb973fa3e740d61e6ac2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FIIEZYJP1tPB3KGtTLo1Mg.png"/></div></div></figure><h1 id="9669" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">结论</h1><p id="b03e" class="pw-post-body-paragraph jk jl in jm b jn lz jp jq jr ma jt ju jv mn jx jy jz mo kb kc kd mp kf kg kh ig bi translated">如您所见，将graphQL与golang集成一点也不困难。这是一个强大的组合，在我们的微服务时代，效果非常完美。希望所有的细节都能帮助你实现自己的想法。很快我们将使用Docker和Kubernetes部署！</p><p id="8fb0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">感谢您的宝贵时间，记得查看git回购</p></div></div>    
</body>
</html>