<html>
<head>
<title>Object Oriented Programing In 5 Minutes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向对象编程 5 分钟</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/object-oriented-programing-in-5-minutes-421993786719?source=collection_archive---------0-----------------------#2021-08-05">https://blog.devgenius.io/object-oriented-programing-in-5-minutes-421993786719?source=collection_archive---------0-----------------------#2021-08-05</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/f75764540c34eb5ecaf22a6d5cbe90de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lfRg3gB8G-Q_9eJn"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">拉格斯技术人员在<a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="b090" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi ky translated">当谈到面向对象编程时，我发现许多教程使这个概念的理解变得复杂。要想很好的理解它，先来理解它解决的问题。</p><p id="cd91" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在过去，我们有程序设计，它将一个程序分成一组函数，这些函数对数据进行操作。</p><p id="1fc5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是随着程序的增长，我们得到了许多相互关联的功能。</p><p id="5f20" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当我们对一个功能进行更改时，这可能会破坏其他功能，这是有问题的。</p><p id="5f10" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，面向对象编程(OOP)来解决这个问题。它有 4 个小概念:封装、抽象、继承和多态。</p><h1 id="f3d2" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">1-封装</h1><p id="19fa" class="pw-post-body-paragraph ka kb in kc b kd mf kf kg kh mg kj kk kl mh kn ko kp mi kr ks kt mj kv kw kx ig bi translated">这意味着将一组相关的字段和函数创建到一个称为对象的单元中。</p><p id="b4eb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们将这些字段称为属性，将这些函数称为方法。</p><p id="7c6f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">举例:</strong></p><p id="97ae" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">教师有一些属性，例如基本工资、加班时间、工资率；有一些方法，例如 get wage()；还有一些设置器，用于更新属性值；还有一些获取器，用于获取属性值。</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="8842" class="mt li in mp b gy mu mv l mw mx">package com.selcote.abstraction;</span><span id="365f" class="mt li in mp b gy my mv l mw mx">public class Employee{<br/>    private float baseSalary;<br/>    private float rate;<br/>    private float overtime;<br/>    <br/>    public float getWage(){<br/>        return this.baseSalary + (rate * overtime);<br/>    }<br/><br/>    public float getBaseSalary() {<br/>        return baseSalary;<br/>    }<br/><br/>    public void setBaseSalary(float baseSalary) {<br/>        this.baseSalary = baseSalary;<br/>    }<br/><br/>    public float getRate() {<br/>        return rate;<br/>    }<br/><br/>    public void setRate(float rate) {<br/>        this.rate = rate;<br/>    }<br/><br/>    public float getOvertime() {<br/>        return overtime;<br/>    }<br/><br/>    public void setOvertime(float overtime) {<br/>        this.overtime = overtime;<br/>    }<br/>      <br/>}</span></pre><p id="4e71" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">正如您所看到的，getWage()方法没有参数，它访问对象属性并对它们进行操作，而不需要向它传递参数。这是最佳实践之一，拥有不带参数的方法。</p><blockquote class="mz"><p id="f0af" class="na nb in bd nc nd ne nf ng nh ni kx dk translated">参数数量越少，该功能越容易使用和维护。</p></blockquote><p id="c490" class="pw-post-body-paragraph ka kb in kc b kd nj kf kg kh nk kj kk kl nl kn ko kp nm kr ks kt nn kv kw kx ig bi translated">除此之外，我们将属性设为私有，我们可以通过传递 setters 和 getters 来访问它们，这<strong class="kc io">隐藏了类中结构化数据对象</strong>的值或状态，并防止未授权方直接访问它们。</p><h1 id="0762" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">2-抽象</h1><p id="439d" class="pw-post-body-paragraph ka kb in kc b kd mf kf kg kh mg kj kk kl mh kn ko kp mi kr ks kt mj kv kw kx ig bi translated">这种技术是对外界隐藏细节，这给了我们很多好处。</p><p id="369f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们可以通过使对象方法私有来隐藏它们，并暴露更少的公共方法。</p><p id="369c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，通过这样做，我们使我们的对象接口更简单。</p><blockquote class="mz"><p id="5aac" class="na nb in bd nc nd ne nf ng nh ni kx dk translated">使用和理解具有较少方法和属性的对象比具有许多方法和属性的对象要好。</p></blockquote><p id="a0c6" class="pw-post-body-paragraph ka kb in kc b kd nj kf kg kh nk kj kk kl nl kn ko kp nm kr ks kt nn kv kw kx ig bi translated">此外，这个概念减少了变更的影响，这意味着如果您更改任何私有或内部方法，这将不会泄漏到外部。因为这些方法或属性都不为该包含对象的外部所知。</p><p id="0d0e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">此外，我们可以只向外部公开一个接口，实现将在运行时定义。</p><p id="7f7f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">示例:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="d57c" class="mt li in mp b gy mu mv l mw mx">package com.selcote.abstraction;  </span><span id="49c6" class="mt li in mp b gy my mv l mw mx">public interface Car {  <br/> void turnOn();   <br/> void turnOff();   <br/>}<br/></span><span id="44b1" class="mt li in mp b gy my mv l mw mx">package com.selcote.abstraction;</span><span id="438c" class="mt li in mp b gy my mv l mw mx">public class ManualCar implements Car {   </span><span id="41e8" class="mt li in mp b gy my mv l mw mx">   @Override  <br/>   public void turnOn() {  <br/>     System.out.println("turn on the manual car");  <br/>   }   </span><span id="ea66" class="mt li in mp b gy my mv l mw mx">   @Override  <br/>   public void turnOff() {   <br/>     System.out.println("turn off the manual car");  <br/>   }  <br/> <br/>}</span><span id="0215" class="mt li in mp b gy my mv l mw mx">package com.selcote.abstraction;</span><span id="8c27" class="mt li in mp b gy my mv l mw mx">public class AutomaticCar implements Car { <br/>  <br/>    @Override  <br/>    public void turnOnCar() {   <br/>       System.out.println("turn on the automatic car");  <br/>    }   <br/>    @Override  <br/>    public void turnOffCar() {    <br/>      System.out.println("turn off the automatic car");   <br/>    }  <br/>}</span></pre><p id="0480" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们测试一下汽车的功能:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="7394" class="mt li in mp b gy mu mv l mw mx">package com.selcote.abstraction;</span><span id="40a7" class="mt li in mp b gy my mv l mw mx">public class CarTest {  <br/> public static void main(String[] args) {   </span><span id="d6b1" class="mt li in mp b gy my mv l mw mx">       Car car1 = new ManualCar();   <br/>       Car car2 = new AutomaticCar();    <br/>       car1.turnOnCar();   <br/>       car1.turnOffCar();     <br/>       car2.turnOnCar();   <br/>       car2.turnOffCar();  <br/>       <br/> }  <br/>}</span></pre><p id="ae68" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">输出:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="eef3" class="mt li in mp b gy mu mv l mw mx">turn on the manual car<br/>turn off the manual car<br/>turn on the automatic car<br/>turn off the automatic car</span></pre><p id="c36a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> <em class="no">客户端程序只知道汽车和汽车提供的功能。</em>T13】</strong></p><p id="6392" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> <em class="no">内部实现细节对客户端程序隐藏。</em>T3】</strong></p><h1 id="520e" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">3-继承</h1><p id="fb82" class="pw-post-body-paragraph ka kb in kc b kd mf kf kg kh mg kj kk kl mh kn ko kp mi kr ks kt mj kv kw kx ig bi translated">这种机制允许我们消除冗余代码。</p><p id="083f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们考虑一下 html 元素，比如文本框、选择框、复选框等等。这些元素有一些共同点，如 hidden，innerHtml 属性和方法，如 click()和 focus()。</p><p id="aeb9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们可以在一个名为 Html element 的通用对象中定义这些属性和方法，并让其他对象继承它，而不是为每种类型的 Html 元素重新定义这些属性和方法。</p><h1 id="d6bb" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">4-多形性</h1><p id="6f57" class="pw-post-body-paragraph ka kb in kc b kd mf kf kg kh mg kj kk kl mh kn ko kp mi kr ks kt mj kv kw kx ig bi translated">如果我们试图理解这个构成名称，Poly 表示许多，morphism 表示形式，所以:</p><blockquote class="mz"><p id="0a04" class="na nb in bd nc nd ne nf ng nh ni kx dk translated">多形=多种形式</p></blockquote><p id="ce80" class="pw-post-body-paragraph ka kb in kc b kd nj kf kg kh nk kj kk kl nl kn ko kp nm kr ks kt nn kv kw kx ig bi translated">这是一种允许去掉<strong class="kc io"> i <em class="no"> f 和 else 或者转换语句的技术。</em> </strong></p><p id="db47" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，多态性是一个方法根据它所作用的对象做不同事情的能力。换句话说，多态性允许您定义一个接口并拥有多个实现。</p><p id="a6a9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">示例:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="fd2a" class="mt li in mp b gy mu mv l mw mx">public class Animal{<br/>   public void sound(){<br/>      System.out.println("Animal is making a sound");   <br/>   }<br/>}</span><span id="a0f8" class="mt li in mp b gy my mv l mw mx">class Dog extends Animal{<br/>    @Override<br/>    public void sound(){<br/>        System.out.println("Barking");<br/>    }<br/>    public static void main(String args[]){<br/>    	Animal obj = new Dog();<br/>    	obj.sound();<br/>    }<br/>}</span></pre><p id="651e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">输出:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="bc52" class="mt li in mp b gy mu mv l mw mx">Barking</span><span id="9d83" class="mt li in mp b gy my mv l mw mx">class Cat extends Animal{<br/>    @Override<br/>    public void sound(){<br/>        System.out.println("Meow");<br/>    }<br/>    public static void main(String args[]){<br/>    	Animal obj = new Cat();<br/>    	obj.sound();<br/>    }<br/>}</span></pre><p id="18e8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">输出:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="ca6b" class="mt li in mp b gy mu mv l mw mx">Meow</span></pre><h1 id="d2bb" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">结论:</h1><p id="d381" class="pw-post-body-paragraph ka kb in kc b kd mf kf kg kh mg kj kk kl mh kn ko kp mi kr ks kt mj kv kw kx ig bi translated">OOP 通过解决许多问题简化了编程领域:</p><p id="53e6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">封装= &gt;降低复杂性+提高可重用性</p><p id="843c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">抽象= &gt;降低复杂性+降低代码变化的影响</p><p id="3662" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">继承= &gt;消除冗余代码</p><p id="3f8b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">多态= &gt;重构 if/switch case 语句</p></div><div class="ab cl np nq hr nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="ig ih ii ij ik"><p id="d6db" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">请在评论中与我分享您的想法，并为之鼓掌:-)</p><p id="8506" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">另外，考虑在 medium 上关注我，订阅我的频道:<a class="ae jz" href="https://www.youtube.com/channel/UCAHhPG4g-alLRGFjk8rXyIA" rel="noopener ugc nofollow" target="_blank"> Selcote(问题解决社区)</a>获取更多精彩内容。</p></div><div class="ab cl np nq hr nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="ig ih ii ij ik"><h1 id="e51b" class="lh li in bd lj lk nw lm ln lo nx lq lr ls ny lu lv lw nz ly lz ma oa mc md me bi translated">推荐书籍</h1><h2 id="ba7e" class="mt li in bd lj ob oc dn ln od oe dp lr kl of og lv kp oh oi lz kt oj ok md ol bi translated"><a class="ae jz" href="https://amzn.to/3j1lNWx" rel="noopener ugc nofollow" target="_blank">干净的代码:敏捷软件技术手册</a></h2><h2 id="3557" class="mt li in bd lj ob oc dn ln od oe dp lr kl of og lv kp oh oi lz kt oj ok md ol bi translated"><a class="ae jz" href="https://amzn.to/3vG0Zbl" rel="noopener ugc nofollow" target="_blank">头脑优先设计模式:一个对大脑友好的指南</a></h2><h2 id="cac7" class="mt li in bd lj ob oc dn ln od oe dp lr kl of og lv kp oh oi lz kt oj ok md ol bi translated"><a class="ae jz" href="https://amzn.to/3cVvkfy" rel="noopener ugc nofollow" target="_blank">干净的建筑</a></h2><h1 id="b495" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">计算机和显示器</h1><h2 id="3760" class="mt li in bd lj ob oc dn ln od oe dp lr kl of og lv kp oh oi lz kt oj ok md ol bi translated"><a class="ae jz" href="https://amzn.to/3wOP10M" rel="noopener ugc nofollow" target="_blank">新款苹果 MacBook Pro </a></h2><h2 id="fba1" class="mt li in bd lj ob oc dn ln od oe dp lr kl of og lv kp oh oi lz kt oj ok md ol bi translated"><a class="ae jz" href="https://amzn.to/3zIcT7M" rel="noopener ugc nofollow" target="_blank">戴尔 27 英寸 Ultrasharp U2719D 显示器</a></h2><h2 id="baf4" class="mt li in bd lj ob oc dn ln od oe dp lr kl of og lv kp oh oi lz kt oj ok md ol bi translated"><a class="ae jz" href="https://amzn.to/2SNdHI3" rel="noopener ugc nofollow" target="_blank">双臂支架桌面支架</a></h2><h2 id="49a2" class="mt li in bd lj ob oc dn ln od oe dp lr kl of og lv kp oh oi lz kt oj ok md ol bi translated"><a class="ae jz" href="https://amzn.to/2VfxiS6" rel="noopener ugc nofollow" target="_blank"> USB C Hub 多端口适配器</a></h2><h2 id="0caa" class="mt li in bd lj ob oc dn ln od oe dp lr kl of og lv kp oh oi lz kt oj ok md ol bi translated">我用于编码的 IDE:</h2><p id="335d" class="pw-post-body-paragraph ka kb in kc b kd mf kf kg kh mg kj kk kl mh kn ko kp mi kr ks kt mj kv kw kx ig bi translated">- IntelliJ <br/> - Vscode</p></div></div>    
</body>
</html>