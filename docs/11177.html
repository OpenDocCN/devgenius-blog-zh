<html>
<head>
<title>Golang Unit Testing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Golang 单元测试</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/golang-unit-testing-dd5c2de2c8a5?source=collection_archive---------3-----------------------#2022-12-23">https://blog.devgenius.io/golang-unit-testing-dd5c2de2c8a5?source=collection_archive---------3-----------------------#2022-12-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="6a79" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">有用的建议</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/ecb9c733e7a78eb75fc5448e5467e76e.png" data-original-src="https://miro.medium.com/v2/resize:fit:890/format:webp/1*YsvRK6Pkp1sgqQutXsPoLA.png"/></div></figure><p id="f339" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在这篇文章中，我将讨论如何使用单元测试来测试我们的 Golang 代码，我将向您展示一些测试代码的建议和最佳实践。</p><h2 id="8e84" class="lj lk iq bd ll lm ln dn lo lp lq dp lr kw ls lt lu la lv lw lx le ly lz ma mb bi translated">什么是单元测试？</h2><p id="1837" class="pw-post-body-paragraph kn ko iq kp b kq mc jr ks kt md ju kv kw me ky kz la mf lc ld le mg lg lh li ij bi translated">简言之，单元测试是测试可以从逻辑中分离出来的小段代码的方法。源代码片段可以是函数、方法、子程序等。我们希望确保正确的功能性，涵盖好的途径和可能的失败途径。</p><p id="3847" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">每个单元测试都被管理来实现测试用例，在这些测试用例中，我们将定义与要测试的代码片段相关的所有可能的场景。</p><p id="3a54" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">实现单元测试在我们的开发过程中非常有帮助，因为我们可以:</p><ul class=""><li id="ad4d" class="mh mi iq kp b kq kr kt ku kw mj la mk le ml li mm mn mo mp bi translated">识别缺陷和错误。</li><li id="06b4" class="mh mi iq kp b kq mq kt mr kw ms la mt le mu li mm mn mo mp bi translated">提高质量。</li><li id="c51a" class="mh mi iq kp b kq mq kt mr kw ms la mt le mu li mm mn mo mp bi translated">减少组件行为中的缺陷。</li><li id="635c" class="mh mi iq kp b kq mq kt mr kw ms la mt le mu li mm mn mo mp bi translated">检测性能问题。</li><li id="2ae1" class="mh mi iq kp b kq mq kt mr kw ms la mt le mu li mm mn mo mp bi translated">验证输入和/或输出是否按预期工作。</li><li id="61d6" class="mh mi iq kp b kq mq kt mr kw ms la mt le mu li mm mn mo mp bi translated">等等。</li></ul><p id="6bea" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">正如你从上面的例子中看到的，测试你的代码为我们正在开发的软件带来了很多好处，减少了在交付和准备使用之前在我们的应用程序中发现错误的可能性。</p><p id="9f69" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">有一些测试方法，比如 TDD(测试驱动设计),在编写代码时非常有用，因为我们将从测试开始开发代码，只编写几行代码来满足单元测试，但是我们可以在单独的文章中讨论。这次我将向你展示如何为 golang 代码编写一个单元测试。</p><h2 id="f03e" class="lj lk iq bd ll lm ln dn lo lp lq dp lr kw ls lt lu la lv lw lx le ly lz ma mb bi translated">单元测试最佳实践</h2><ul class=""><li id="dd24" class="mh mi iq kp b kq mc kt md kw mv la mw le mx li mm mn mo mp bi translated">养成测试代码的习惯</li><li id="d98f" class="mh mi iq kp b kq mq kt mr kw ms la mt le mu li mm mn mo mp bi translated">测试用例应该是独立的。</li><li id="5eb8" class="mh mi iq kp b kq mq kt mr kw ms la mt le mu li mm mn mo mp bi translated">定义测试用例，尝试覆盖代码单元几乎所有可能的输出，包括成功结果和预期错误。</li><li id="6ed8" class="mh mi iq kp b kq mq kt mr kw ms la mt le mu li mm mn mo mp bi translated">如果您在运行单元测试的逻辑中发现了一个 bug，您应该在继续开发之前修复它</li><li id="afda" class="mh mi iq kp b kq mq kt mr kw ms la mt le mu li mm mn mo mp bi translated">先测试。</li><li id="d19b" class="mh mi iq kp b kq mq kt mr kw ms la mt le mu li mm mn mo mp bi translated">只为重要的事情添加单元测试。</li><li id="339d" class="mh mi iq kp b kq mq kt mr kw ms la mt le mu li mm mn mo mp bi translated">遵循当时的命名约定来定义测试函数。</li><li id="fb05" class="mh mi iq kp b kq mq kt mr kw ms la mt le mu li mm mn mo mp bi translated">在你的测试用例中要描述清楚。</li><li id="1e2e" class="mh mi iq kp b kq mq kt mr kw ms la mt le mu li mm mn mo mp bi translated">如果源代码改变，确保所有相应的测试覆盖新的逻辑。</li><li id="bf51" class="mh mi iq kp b kq mq kt mr kw ms la mt le mu li mm mn mo mp bi translated">保持测试更新。</li><li id="0699" class="mh mi iq kp b kq mq kt mr kw ms la mt le mu li mm mn mo mp bi translated">一次只测试一段代码。</li></ul><h2 id="fe64" class="lj lk iq bd ll lm ln dn lo lp lq dp lr kw ls lt lu la lv lw lx le ly lz ma mb bi translated">如何测试我的 golang 代码？</h2><p id="f327" class="pw-post-body-paragraph kn ko iq kp b kq mc jr ks kt md ju kv kw me ky kz la mf lc ld le mg lg lh li ij bi translated">让我从一个简单的例子开始，我们将定义一个简单的函数来对数组中的所有元素求和，这个函数是从 main 函数调用的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi my"><img src="../Images/c61d21e24252b00cc2ad5502ca6ae08d.png" data-original-src="https://miro.medium.com/v2/resize:fit:604/format:webp/1*PMKd5Rvml50ke7XK9F6L-A.png"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/622ef712eba321097ad20bf22d82cc3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1330/format:webp/1*Om-Klw-23PEP8_RX6LPcZA.png"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi na"><img src="../Images/312fb515f6c8c0b7258c51b997840fcc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5hMU3d94lqQ2aJt4wI1-Bg.png"/></div></div></figure><p id="5b3c" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我们将要实现的测试是针对<code class="fe nf ng nh ni b">SumArrayElements</code>函数的。</p><p id="c9fe" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我们需要做的第一件事是创建一个与源代码文件同名的新文件，但是我们要在名称中包含后缀<code class="fe nf ng nh ni b">_test</code>(这是我们在运行时命名测试文件的方式)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/3c93941d45190182fe3c68fb063ce4bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:648/format:webp/1*8NQnISbhGJtSSRTWqtHhmw.png"/></div></figure><p id="e723" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在该文件中，我们将包括我们的测试函数，让我们开始:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/48e894ecd89afcf7b7f4341165f4ec36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1342/format:webp/1*NwgmINxbGektkTI9Q9gv1g.png"/></div></figure><p id="f156" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">如你所见，为了定义测试，我们声明了一个带有前缀<code class="fe nf ng nh ni b">Test</code>的函数，它将一个指向<code class="fe nf ng nh ni b">testing.T</code>的变量作为参数。目前，定义测试函数的工作已经完成，现在让我们来编写测试逻辑。</p><p id="2f86" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">所需的测试逻辑可能如下:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi nl"><img src="../Images/a793bb66b2750c10bbe0f90bb517137b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dOW7vD3zdUbu5PfVdQ9E4g.png"/></div></div></figure><p id="9eb1" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我们需要定义函数输入和预期结果，然后调用函数并用预期结果验证结果，如果值不同，测试失败。</p><p id="9614" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">现在同样的例子，但是现在使用<code class="fe nf ng nh ni b">assertions</code>实现<code class="fe nf ng nh ni b">https://github.com/stretchr/testify</code>:</p><p id="2cd2" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">您可以使用<code class="fe nf ng nh ni b">go get github.com/stretchr/testify</code>来安装依赖项。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi nm"><img src="../Images/7e889c966ed203206792531d344d38f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tMOi7JlWvvgqgWyESICDIA.png"/></div></div></figure><p id="922b" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">那里有什么不同？因此，现在我们使用比较值的<code class="fe nf ng nh ni b">assert.Equal</code>，而不是使用<code class="fe nf ng nh ni b">if</code>进行验证。</p><p id="8556" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">要运行我们的测试，我们只需要在终端上执行以下命令:</p><p id="fff4" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><code class="fe nf ng nh ni b">go test -cover ./...</code></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi nn"><img src="../Images/f97f3c51278eb5c6d0629b735deb3d2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u5HW4gu6PYQilDihkIn9DQ.png"/></div></div></figure><p id="2094" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">现在，我们需要为这个简单的函数创建测试。</p><h2 id="6e7d" class="lj lk iq bd ll lm ln dn lo lp lq dp lr kw ls lt lu la lv lw lx le ly lz ma mb bi translated">嘲弄的</h2><p id="8970" class="pw-post-body-paragraph kn ko iq kp b kq mc jr ks kt md ju kv kw me ky kz la mf lc ld le mg lg lh li ij bi translated">在这一节，我们将看到如何模拟更复杂的函数，这些函数通常是通过使用接口来实现的。</p><p id="a496" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">假设我们有以下源代码:</p><ul class=""><li id="2481" class="mh mi iq kp b kq kr kt ku kw mj la mk le ml li mm mn mo mp bi translated">与外部服务的连接</li><li id="cf28" class="mh mi iq kp b kq mq kt mr kw ms la mt le mu li mm mn mo mp bi translated">一个使用服务的层</li><li id="885f" class="mh mi iq kp b kq mq kt mr kw ms la mt le mu li mm mn mo mp bi translated">简单来说，main 函数将执行代码</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi no"><img src="../Images/3ef9c810d67737d3e2fdfce61ec0765b.png" data-original-src="https://miro.medium.com/v2/resize:fit:630/format:webp/1*RAzafhIJ1pnXouxlT4V-sA.png"/></div></figure><p id="ca28" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><code class="fe nf ng nh ni b">main.go</code></p><pre class="kg kh ki kj gt np ni nq bn nr ns bi"><span id="7752" class="nt lk iq ni b be nu nv l nw nx">package main<br/><br/>import (<br/> "github.com/josue/golang_testing/connection"<br/> "github.com/josue/golang_testing/consumer"<br/>)<br/><br/>func main() {<br/> consumerService := consumer.NewService(connection.NewService())<br/> consumerService.GetData()<br/><br/> consumerService.SendData(connection.Data{<br/>  FieldOne: "value1",<br/>  FieldTwo: "value2",<br/> })<br/>}</span></pre><p id="c377" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><code class="fe nf ng nh ni b">service_consumer.go</code></p><p id="b933" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">这个文件将实现对外部服务的所有调用，正如您所看到的，所有调用都是通过使用接口和依赖注入来完成的。</p><pre class="kg kh ki kj gt np ni nq bn nr ns bi"><span id="96a9" class="nt lk iq ni b be nu nv l nw nx">package consumer<br/><br/>import (<br/> "fmt"<br/> "time"<br/><br/> "github.com/josue/golang_testing/connection"<br/>)<br/><br/>type serviceConsumer struct {<br/> // more properties<br/> Srv connection.Service<br/>}<br/><br/>type ServiceConsumer interface {<br/> SendData(data connection.Data) error<br/> GetData() (*connection.Data, error)<br/>}<br/><br/>func NewService(svc connection.Service) ServiceConsumer {<br/> return serviceConsumer{<br/>  Srv: svc,<br/> }<br/>}<br/><br/>func (s serviceConsumer) SendData(data connection.Data) error {<br/> fmt.Println("completed on SendData")<br/><br/> err := s.Srv.SendData(data)<br/> if err != nil {<br/>  fmt.Println("error sending data: ", err.Error())<br/>  return err<br/> }<br/><br/> return nil<br/>}<br/>func (s serviceConsumer) GetData() (*connection.Data, error) {<br/> fmt.Println("on GetData")<br/> time.Sleep(1 * time.Second)<br/><br/> data, err := s.Srv.GetData()<br/> if err != nil {<br/>  fmt.Println("error getting data: ", err.Error())<br/>  return nil, err<br/> }<br/><br/> fmt.Println("completed on GetData")<br/> return &amp;data, nil<br/>}</span></pre><p id="e4bc" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">和服务连接<code class="fe nf ng nh ni b">service.go</code></p><p id="5dd5" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">这个文件是一个外部连接的伪表示，在那里定义的方法将被服务消费者使用。</p><pre class="kg kh ki kj gt np ni nq bn nr ns bi"><span id="eb4a" class="nt lk iq ni b be nu nv l nw nx">package connection<br/><br/>import (<br/> "errors"<br/> "fmt"<br/> "time"<br/>)<br/><br/>type Data struct {<br/> FieldOne string<br/> FieldTwo string<br/>}<br/><br/>type service struct {<br/> // more properties<br/>}<br/><br/>type Service interface {<br/> SendData(data Data) error<br/> GetData() (Data, error)<br/>}<br/><br/>func NewService() Service {<br/> return &amp;service{<br/>  //set more properties<br/> }<br/>}<br/><br/>func (s *service) SendData(data Data) error {<br/> fmt.Println("on SendData")<br/> time.Sleep(1 * time.Second)<br/><br/> if data.FieldOne == "" {<br/>  return errors.New("FieldOne can not be a empty string")<br/> }<br/> if data.FieldOne == "" {<br/>  return errors.New("FieldTwo can not be a empty string")<br/> }<br/><br/> fmt.Println("completed on SendData")<br/><br/> return nil<br/>}<br/><br/>func (s *service) GetData() (Data, error) {<br/> fmt.Println("on GetData")<br/> time.Sleep(1 * time.Second)<br/> fmt.Println("completed on GetData")<br/> return Data{<br/>  FieldOne: "exmple",<br/>  FieldTwo: "example two",<br/> }, nil<br/>}</span></pre><p id="3ae9" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">不要想象你不想在测试中遇到真正的服务，以避免请求饱和，将测试数据推送到可能的数据库，避免数据损坏，等等。，那么我们需要实现模拟，这就是<code class="fe nf ng nh ni b">mockgen</code>框架帮助我们的地方。</p><p id="9a12" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">Mockgen 将帮助我们生成模拟我们的方法所需的所有 ew，这样做对使用接口非常重要，因为框架将带它们生成 mock。</p><p id="d858" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">首先，我们需要使用以下方法获得依赖框架:</p><pre class="kg kh ki kj gt np ni nq bn nr ns bi"><span id="44bd" class="nt lk iq ni b be nu nv l nw nx">go install github.com/golang/mock/mockgen@v1.6.0</span></pre><p id="6c76" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在定位到服务包之后，我们需要生成模拟文件:</p><pre class="kg kh ki kj gt np ni nq bn nr ns bi"><span id="2802" class="nt lk iq ni b be nu nv l nw nx">mockgen -source=service.go -destination=mock/service_mock.go</span></pre><p id="c8cf" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">这将在模拟文件夹中自动生成一个文件。该文件将包含与被模仿的服务一起工作所需的所有内容。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/888ce4a568eca07541df139482412b9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:582/format:webp/1*ERfwB_o5aTs3kEm1QnmnfA.png"/></div></figure><p id="baaa" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">一旦我们都生成了，是时候在我们的测试中实现模拟了。</p><p id="bc5d" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在这个小例子中，您可以看到我们如何使用 mocks 并模拟到我们服务的连接。</p><p id="6fef" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">如果你有兴趣了解更多关于 mockgen 的信息，你可以使用官方页面:https://github.com/golang/mock<a class="ae oa" href="https://github.com/golang/mock" rel="noopener ugc nofollow" target="_blank">T3】</a></p><pre class="kg kh ki kj gt np ni nq bn nr ns bi"><span id="87c8" class="nt lk iq ni b be nu nv l nw nx">package consumer<br/><br/>import (<br/> "testing"<br/><br/> "github.com/golang/mock/gomock"<br/> "github.com/josue/golang_testing/connection"<br/> mock_service "github.com/josue/golang_testing/connection/mock"<br/> "github.com/stretchr/testify/assert"<br/>)<br/><br/>func TestGetData(t *testing.T) {<br/><br/> ctrl := gomock.NewController(t)<br/> defer ctrl.Finish()<br/><br/> mockSvcConn := mock_service.NewMockService(ctrl)<br/> svcConsumer := NewService(mockSvcConn)<br/><br/> testData := connection.Data{<br/>  FieldOne: "test value 1",<br/>  FieldTwo: "test value 2",<br/> }<br/><br/> mockSvcConn.EXPECT().<br/>  GetData().<br/>  Times(1).<br/>  Return(testData, nil)<br/><br/> result, err := svcConsumer.GetData()<br/><br/> assert.Nil(t, err)<br/> assert.Equal(t, result.FieldOne, testData.FieldOne)<br/> assert.Equal(t, result.FieldTwo, testData.FieldTwo)<br/>}<br/><br/>func TestSendData(t *testing.T) {<br/><br/> ctrl := gomock.NewController(t)<br/> defer ctrl.Finish()<br/><br/> mockSvcConn := mock_service.NewMockService(ctrl)<br/> svcConsumer := NewService(mockSvcConn)<br/><br/> testData := connection.Data{<br/>  FieldOne: "test value 1",<br/>  FieldTwo: "test value 2",<br/> }<br/><br/> mockSvcConn.EXPECT().<br/>  SendData(gomock.Any()).<br/>  Times(1).<br/>  Return(nil)<br/><br/> err := svcConsumer.SendData(testData)<br/><br/> assert.Nil(t, err)<br/>}</span></pre><p id="2457" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">现在我们只需要使用 golang 工具运行测试。</p><h2 id="c58f" class="lj lk iq bd ll lm ln dn lo lp lq dp lr kw ls lt lu la lv lw lx le ly lz ma mb bi translated">实施测试表方法</h2><p id="e050" class="pw-post-body-paragraph kn ko iq kp b kq mc jr ks kt md ju kv kw me ky kz la mf lc ld le mg lg lh li ij bi translated">当我们进行测试时，我们通常定义测试用例来覆盖代码逻辑中所有可能的流程，这些测试用例可以定义为 golang 测试函数，每个测试用例一个。现在想象一下，我们有很多测试用例，我们必须为每个重复公共代码的测试用例定义一个测试函数，这里是测试表来帮助我们减少测试，只定义一个测试函数来覆盖所有可能的场景。</p><p id="063b" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">让我们看一个小例子:</p><p id="98a0" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">考虑一个函数来验证学生是否同意基于以下内容的课程:</p><ul class=""><li id="4f74" class="mh mi iq kp b kq kr kt ku kw mj la mk le ml li mm mn mo mp bi translated">学生一年应该有将近 5 节课。</li><li id="71c0" class="mh mi iq kp b kq mq kt mr kw ms la mt le mu li mm mn mo mp bi translated">所有课程的分数至少要达到 80 分。</li><li id="f3d2" class="mh mi iq kp b kq mq kt mr kw ms la mt le mu li mm mn mo mp bi translated">班级成绩总分应该在 400 到 500 分之间。</li></ul><p id="7ce5" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">函数进行测试，这里定义的逻辑涵盖了上面所有的点:</p><pre class="kg kh ki kj gt np ni nq bn nr ns bi"><span id="5d8c" class="nt lk iq ni b be nu nv l nw nx">package course<br/><br/>import (<br/> "errors"<br/>)<br/><br/>type class struct {<br/> Name  string<br/> Score int<br/>}<br/><br/>func IsStudentCourseApproved(classes []class) error {<br/><br/> var total int<br/><br/> if len(classes) &lt; 5 {<br/>  return errors.New("Invalid number or classes")<br/> }<br/><br/> for _, c := range classes {<br/>  total += c.Score<br/>  if c.Score &lt; 80 {<br/>   return errors.New("the class score should be more than 80 points")<br/>  }<br/> }<br/><br/> if total &lt; 400 {<br/>  return errors.New("the sum of all classes score should be more than 400 points")<br/> }<br/><br/> return nil<br/>}</span></pre><p id="2a08" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">现在我们需要定义我们的测试文件和测试函数，在那里我们将实现测试表。为了简单起见，我将为函数定义两个测试用例，一个用于快乐之路，另一个用于学生没有完成所有必修课的情况。</p><pre class="kg kh ki kj gt np ni nq bn nr ns bi"><span id="b120" class="nt lk iq ni b be nu nv l nw nx">package course<br/><br/>import (<br/> "github.com/stretchr/testify/assert"<br/> "testing"<br/>)<br/><br/>func TestIsStudentCourseApproved(t *testing.T) {<br/><br/> tt := []struct {<br/>  name       string<br/>  data       []class<br/>  hasFailure bool<br/>  errMsg     string<br/> }{<br/>  {<br/>   name: "happy path",<br/>   data: []class{<br/>    {<br/>     Name:  "math",<br/>     Score: 100,<br/>    },<br/>    {<br/>     Name:  "histoty",<br/>     Score: 100,<br/>    },<br/>    {<br/>     Name:  "art",<br/>     Score: 100,<br/>    },<br/>    {<br/>     Name:  "sport",<br/>     Score: 100,<br/>    },<br/>    {<br/>     Name:  "sciences",<br/>     Score: 100,<br/>    },<br/>   },<br/>   hasFailure: false,<br/>   errMsg:     "",<br/>  },<br/>  {<br/>   name: "Invalid number or classes",<br/>   data: []class{<br/>    {<br/>     Name:  "math",<br/>     Score: 100,<br/>    },<br/>    {<br/>     Name:  "histoty",<br/>     Score: 100,<br/>    },<br/>    {<br/>     Name:  "art",<br/>     Score: 100,<br/>    },<br/>   },<br/>   hasFailure: true,<br/>   errMsg:     "Invalid number or classes",<br/>  },<br/> }<br/><br/> for _, tc := range tt {<br/>  t.Run(tc.name, func(t *testing.T) {<br/>   err := IsStudentCourseApproved(tc.data)<br/><br/>   if tc.hasFailure {<br/>    assert.NotNil(t, err)<br/>    assert.Equal(t, err.Error(), tc.errMsg)<br/>   } else {<br/>    assert.Nil(t, err)<br/>   }<br/>  })<br/> }<br/>}</span></pre><p id="c20c" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">正如你所看到的，我们使用了一个 struct 类型的数组，它定义了我们的测试用例所需的所有字段，在这个例子中，我们有测试名称，当测试用例需要一个错误时预期的错误消息，以及测试数据。</p><p id="3865" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">然后我们将迭代测试用例，并使用当前信息执行测试。</p><p id="b00c" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">简单对吗？，…现在你有了开始在你的 golang 代码中应用测试的基础。</p><p id="6b28" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">额外奖励:</p><ul class=""><li id="0f86" class="mh mi iq kp b kq kr kt ku kw mj la mk le ml li mm mn mo mp bi translated">总是测试你的代码</li><li id="adf6" class="mh mi iq kp b kq mq kt mr kw ms la mt le mu li mm mn mo mp bi translated">试着学习 TDD，这会帮助你变得更好。</li><li id="cf8a" class="mh mi iq kp b kq mq kt mr kw ms la mt le mu li mm mn mo mp bi translated">记住只测试需要测试的东西。</li><li id="50c3" class="mh mi iq kp b kq mq kt mr kw ms la mt le mu li mm mn mo mp bi translated">不断学习。</li></ul><p id="5d15" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">希望这篇文章对你有帮助！！…感谢您的阅读！</p></div></div>    
</body>
</html>