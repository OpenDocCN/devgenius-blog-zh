<html>
<head>
<title>Testing that no exception was thrown in Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">测试Java中没有抛出异常</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/testing-that-no-exception-was-thrown-in-java-ae9895f35d5?source=collection_archive---------0-----------------------#2021-10-16">https://blog.devgenius.io/testing-that-no-exception-was-thrown-in-java-ae9895f35d5?source=collection_archive---------0-----------------------#2021-10-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/98c10f0ef6a91335f1937f5eb1b75528.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fs6GHNiA9Vqv9PcA"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">乔恩·埃克特在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="e6d8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在单元测试中，测试特定单元在特定条件下抛出异常是相当常见的。</p><p id="b311" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是，偶尔您会希望确保根本没有异常发生，并且您对在测试驱动开发(TDD)周期的早期阶段可能会发生什么异常有所了解。</p><p id="2334" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，假设作为一个练习，您正在创建一个list类，它的工作方式很像来自<code class="fe lb lc ld le b">java.util</code>的<code class="fe lb lc ld le b">ArrayList&lt;E&gt;</code>。呼叫者可以指定初始容量或使用默认初始容量。</p><p id="9a4d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦达到初始容量，仍然可以添加更多的元素，因为列表会以某种方式自我扩展。或者至少是这样，一旦你找到了正确的测试，看到测试失败，然后让它通过。</p><p id="0935" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设到目前为止，您已经能够让您的列表将元素添加到初始容量。可能要编写的下一个测试是将一个列表填充到初始容量，然后尝试向该列表中再添加一个元素。</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="6e3d" class="ln lo iq le b gy lp lq l lr ls">    @Test<br/>    public void testListCanExpandCapacity() {<br/>        int initCap = 20;<br/>        ArrayBackedList&lt;String&gt; list <br/>                = new ArrayBackedList&lt;&gt;(initCap);<br/>        for (int i = 0; i &lt; initCap; i++) {<br/>            String element = "Element " + i;<br/>            list.add(element);<br/>        }<br/>        String extra = "Just one more element";<br/>        list.add(extra);<br/>        System.out.println("Successfully added one more");<br/>    }</span></pre><p id="6ce7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在你已经知道这个测试不会通过，因为它会触发一个越界数组索引的异常。但是…这个测试真的会失败吗？</p><p id="bfa0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里有不同的意见。有些人认为没有通过总是失败。但是这太宽泛了，似乎包括了被跳过的测试以及由于配置问题根本没有运行的测试。</p><p id="ac54" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我相信对于JUnit的作者来说，“没有通过”并不总是等同于“失败”。至少不像JUnit在NetBeans中报告的那样。</p><figure class="lf lg lh li gt jr gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/b2daa58ab4cad642599ad54f3f3ed253.png" data-original-src="https://miro.medium.com/v2/resize:fit:678/format:webp/1*XczDhV5y7u2VClr97W-cZQ.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">Apache NetBeans中的测试结果窗格示例</figcaption></figure><p id="2a50" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">触发意外异常的测试的红色八角形清楚地表明，该异常是一个意外，应该将我们从正常的TDD周期中唤醒。</p><p id="f115" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">测试失败通常意味着我们可以继续我们计划下一步要做的事情。但是一个测试错误可能意味着我们需要重新考虑我们的测试，甚至是被测试的类。</p><p id="949a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，假设我们正在测试一个连接到在线API并处理响应的函数。您编写测试并运行它。</p><p id="3402" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是你的网络连接中断了，你得到了一个<code class="fe lb lc ld le b">IOException</code>。如果你的网络连接没有中断，你的测试会通过还是失败？我们无法确定。</p><p id="73ea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">似乎更确定的是，我们已经过早地进入了集成测试，我们需要模拟API响应，这样我们的测试就可以只是关于响应是否被正确处理。</p><p id="ccb6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样的场景可能意味着暂停TDD循环，重新思考我们如何将多态性和封装的原则应用到手头的项目中。</p><p id="1d00" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是，当我们知道在TDD周期的失败部分应该发生某个异常，但是我们没有写任何东西让JUnit知道这可能发生时，情况就不是这样了。</p><p id="ff9e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JUnit不是唯一可用于Java的单元测试框架。TestNG对意外异常采取了不同的策略。如果出现意外异常，测试就会失败，就像断言失败一样。</p><figure class="lf lg lh li gt jr gh gi paragraph-image"><div class="gh gi lu"><img src="../Images/edfd63d6b4d3458900999a0c489f00c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:674/format:webp/1*5UImXKxH6nblG9df0KmteQ.png"/></div></figure><p id="60fa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">IntelliJ IDEA在JUnit测试意外导致异常时使用圆形而不是八边形，但其图示本质上与NetBeans中的相同，明确区分了通过、失败、跳过和导致错误。</p><figure class="lf lg lh li gt jr gh gi paragraph-image"><div class="gh gi lv"><img src="../Images/4f20bc775a170ac80e9882413e08dcca.png" data-original-src="https://miro.medium.com/v2/resize:fit:578/format:webp/1*XxYGUcvBKCnxT3fZ0PL1uA.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">IntelliJ IDEA中的测试结果窗格示例</figcaption></figure><p id="fa9c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是，另一方面，如果您单击重新运行失败的测试按钮，任何导致错误的测试将与被认为实际失败的测试一起运行。</p><p id="fe38" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">即便如此，JUnit显然将<code class="fe lb lc ld le b">ArrayIndexOutOfBoundsException</code>视为一个惊喜。如果我们在这个时候把这个交给另一个团队，可能会让他们大吃一惊。</p><p id="f822" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">显然<code class="fe lb lc ld le b">ArrayIndexOutOfBoundsException</code>对我们来说并不意外。我们知道，如果我们的列表在达到初始容量后忽视扩展，就会出现这种情况。也许我们应该把它放在我们的测试里。</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="be5f" class="ln lo iq le b gy lp lq l lr ls">    @Test<br/>    public void testListCanExpandCapacity() {<br/>        int initCap = 20;<br/>        ArrayBackedList&lt;String&gt; list <br/>                = new ArrayBackedList&lt;&gt;(initCap);<br/>        for (int i = 0; i &lt; initCap; i++) {<br/>            String element = "Element " + i;<br/>            list.add(element);<br/>        }<br/>        String extra = "Just one more element";<br/>        <strong class="le ir">try {</strong><br/>            list.add(extra);<br/>            System.out.println("Successfully added one more");<br/>        <strong class="le ir">} catch (ArrayIndexOutOfBoundsException aioobe) {<br/>            String msg = "List failed to expand after " + initCap <br/>                    + " elements";<br/>            fail(msg);<br/>        } catch (RuntimeException re) {<br/>            String msg = re.getClass().getName() <br/>                    + " should not have occurred";<br/>            fail(msg);<br/>        }</strong><br/>    }</span></pre><p id="d205" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不过，这似乎有点冗长。二十多行，确实冗长。但是据我所知，这是在JUnit 4中最直接的方法，不需要添加其他测试依赖项，如AssertJ或Mockito。</p><p id="a156" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JUnit 5用<code class="fe lb lc ld le b">assertDoesNotThrow()</code>提供了一种更直接的方式来编写这个，它采用了一个“抛出供应商”(本质上是一个过程lambda)和一个<code class="fe lb lc ld le b">String</code>中的选项消息。</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="a444" class="ln lo iq le b gy lp lq l lr ls">    @Test<br/>    public void testListCanExpandCapacity() {<br/>        int initCap = 20;<br/>        ArrayBackedList&lt;String&gt; list<br/>                = new ArrayBackedList&lt;&gt;(initCap);<br/>        for (int i = 0; i &lt; initCap; i++) {<br/>            String element = "Element " + i;<br/>            list.add(element);<br/>        }<br/>        String extra = "Just one more element";<br/>        <strong class="le ir">String msg = "Filled list of " + initCap<br/>                + " elements should expand for one more";<br/>        assertDoesNotThrow(() -&gt; {</strong><br/>            list.add(extra);<br/>            System.out.println("Successfully added one more");<br/>        <strong class="le ir">}, msg);</strong><br/>    }</span></pre><p id="803d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这应该给我们以下真正的测试失败:</p><blockquote class="lw lx ly"><p id="ffff" class="kd ke lz kf b kg kh ki kj kk kl km kn ma kp kq kr mb kt ku kv mc kx ky kz la ij bi translated">org . opentest 4j . assertionfailedererror:20个元素的填充列表应再扩展一个== &gt;引发意外异常:Java . lang . arrayindexoutofboundsexception:20</p></blockquote><p id="46a2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样，我们就可以继续实际计算如何将列表容量扩展到初始容量之外。</p><p id="3c3e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">据我所知，TestNG没有<code class="fe lb lc ld le b">assertDoesNotThrow()</code>或类似的东西。鉴于TestNG认为意外异常是测试失败而不是测试错误，我认为<code class="fe lb lc ld le b">assertDoesNotThrow()</code>或类似的东西不太可能被添加到以后的版本中。</p><p id="f19b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你一定要有<code class="fe lb lc ld le b">assertDoesNotThrow()</code>,但是你正在使用的单元测试框架没有它，你可以自己做。这需要一些开销，可能感觉像一个神奇的咒语。</p><p id="8d2b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以下内容将使我们能够将过程lambda作为参数传递给我们的<code class="fe lb lc ld le b">assertDoesNotThrow()</code>，并且它将允许在lambda中出现已检查和未检查的异常:</p><figure class="lf lg lh li gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="4e5c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我不确定这能满足我们所有的需求，但至少它让你知道什么样的提升是必要的。</p><p id="ae71" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">考虑到这一点，我们可以编写我们的<code class="fe lb lc ld le b">assertDoesNotThrow()</code>版本，它本质上封装了Try-Catch，因此我们不必在每次想要断言没有抛出异常时都重写它。</p><figure class="lf lg lh li gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="0d6f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以像在JUnit 5中使用<code class="fe lb lc ld le b">assertDoesNotThrow()</code>一样使用它，但是我不能保证这一点。</p><p id="7776" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可能会发现有必要重载<code class="fe lb lc ld le b">assertDoesNotThrow()</code>,以便它可以接受函数lambda和过程lambda。在尝试创建自己的函数之前，查看一下<code class="fe lb lc ld le b">java.util.function</code>包中是否有现成的lambda类型的函数。</p><p id="b625" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好了，现在你知道了如何断言没有抛出异常。在这件事上有一些不同的意见，我想知道你在评论中的想法。</p></div></div>    
</body>
</html>