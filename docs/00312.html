<html>
<head>
<title>Introduction to Docker</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Docker简介</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/introduction-to-docker-ef7b00da40ed?source=collection_archive---------3-----------------------#2020-06-01">https://blog.devgenius.io/introduction-to-docker-ef7b00da40ed?source=collection_archive---------3-----------------------#2020-06-01</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/bc898e5633cc76e4f4f46593884d7718.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k45EA003byHmhhQnqPv1Pw.jpeg"/></div></div></figure><p id="fbb7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Docker是一个围绕创建和运行<strong class="jx io">容器的平台或生态系统。</strong>为了更好地理解docker，让我们首先试着理解什么是容器。</p><p id="9994" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">什么是容器？</strong></p><p id="f1c0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">容器是一个进程或一组进程，有一组专门分配给它的资源。与虚拟机不同，容器与主机共享相同的操作系统。它们提供了一种逻辑打包机制，应用程序可以从它们实际运行的环境中抽象出来。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi kt"><img src="../Images/5dd8b81fcc51c42c0f246f14738407f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6uVii6-Dz4M_OHXc3e2qsw.png"/></div></div></figure><p id="3b7a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">深入钻研Docker </strong></p><p id="293c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们了解一下docker的积木。</p><ul class=""><li id="0508" class="ky kz in jx b jy jz kc kd kg la kk lb ko lc ks ld le lf lg bi translated"><strong class="jx io"> Docker Hub </strong>:是Docker Hub提供的上传分享Docker图片的服务。</li><li id="bef8" class="ky kz in jx b jy lh kc li kg lj kk lk ko ll ks ld le lf lg bi translated"><strong class="jx io"> Docker守护进程:它</strong>检查客户端请求，并与其他<strong class="jx io"> Docker </strong>组件通信，以便执行服务。</li><li id="60d1" class="ky kz in jx b jy lh kc li kg lj kk lk ko ll ks ld le lf lg bi translated"><strong class="jx io"> Docker Rest API: </strong>一个Rest API，程序可以使用它与守护进程对话，并指示它做什么。</li><li id="07a9" class="ky kz in jx b jy lh kc li kg lj kk lk ko ll ks ld le lf lg bi translated"><strong class="jx io">Docker CLI:</strong>CLI使用Docker REST API通过脚本或直接CLI命令来控制Docker守护进程或与之交互。</li></ul><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lm"><img src="../Images/39108f889dcf433825ae401542849b02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CiY7knOthLzJCilm-pyk7Q.png"/></div></div></figure><p id="3ffa" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">既然我们熟悉了Docker的基本组件，那么让我们来理解如何启动Docker容器。</p><p id="d414" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">启动一个码头集装箱</strong></p><p id="d7f9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">要启动docker容器，您需要创建一个<strong class="jx io"> docker映像</strong>，它由执行容器中的命令所需的一组二进制文件和一个启动命令(可选)组成。</p><pre class="ku kv kw kx gt ln lo lp lq aw lr bi"><span id="5ac4" class="ls lt in lo b gy lu lv l lw lx">docker run &lt;image_name&gt;</span></pre><p id="d160" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">docker run命令是两个命令的合并。</p><pre class="ku kv kw kx gt ln lo lp lq aw lr bi"><span id="42a9" class="ls lt in lo b gy lu lv l lw lx">docker create &lt;image_name&gt; + docker start &lt;container_id&gt;</span></pre><p id="3a96" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe ly lz ma lo b">docker create</code>命令在指定映像上创建一个可写容器层，并为运行启动命令做准备</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mb"><img src="../Images/9f1a70c267087c9ed821e75c5f738826.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DnH88m5oB1k5ENEl1-ReZA.png"/></div></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">Start命令复制二进制文件</figcaption></figure><p id="7129" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后，您可以使用<code class="fe ly lz ma lo b">docker start &lt;container_id&gt;</code>命令在任何点启动容器，该容器执行docker映像中指定的启动命令。</p><p id="cbc2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">到目前为止，我们已经知道如何使用给定的docker映像启动容器，但是我们如何创建自己的docker映像呢？</p><p id="4d2a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">创建docker图像</strong></p><ul class=""><li id="f165" class="ky kz in jx b jy jz kc kd kg la kk lb ko lc ks ld le lf lg bi translated">在项目文件夹中创建一个docker文件</li><li id="7caa" class="ky kz in jx b jy lh kc li kg lj kk lk ko ll ks ld le lf lg bi translated">指定要使用的基础图像</li><li id="4f52" class="ky kz in jx b jy lh kc li kg lj kk lk ko ll ks ld le lf lg bi translated">指定创建映像时要执行的一组命令</li><li id="2f67" class="ky kz in jx b jy lh kc li kg lj kk lk ko ll ks ld le lf lg bi translated">指定启动容器时调用的启动命令(可选)</li><li id="8964" class="ky kz in jx b jy lh kc li kg lj kk lk ko ll ks ld le lf lg bi translated">使用Dockerfile建立你的形象。</li></ul><pre class="ku kv kw kx gt ln lo lp lq aw lr bi"><span id="e18e" class="ls lt in lo b gy lu lv l lw lx">docker build -t &lt;imag_name&gt; .</span></pre><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mg"><img src="../Images/0baabe6e379b3c82ffe1c81ca338caf3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CQ3Ei3sve8C-hRvOhsTPMA.png"/></div></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated">样本文档</figcaption></figure><p id="5b6e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">常用的Docker命令</strong></p><pre class="ku kv kw kx gt ln lo lp lq aw lr bi"><span id="3bf1" class="ls lt in lo b gy lu lv l lw lx">docker logs [OPTIONS] CONTAINER</span></pre><p id="7198" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">它获取给定docker容器的日志。</p><pre class="ku kv kw kx gt ln lo lp lq aw lr bi"><span id="22dc" class="ls lt in lo b gy lu lv l lw lx">docker ps</span></pre><p id="a2c1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">默认情况下，它只显示正在运行的容器。您可以添加<code class="fe ly lz ma lo b">-a</code>标志来查看所有容器。</p><pre class="ku kv kw kx gt ln lo lp lq aw lr bi"><span id="4468" class="ls lt in lo b gy lu lv l lw lx">docker kill [OPTIONS] CONTAINER</span></pre><p id="ff0b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">它立即杀死一个或多个正在运行的容器<em class="mh"> ( </em> <strong class="jx io"> <em class="mh">发送SIGKILL或指定信号</em> </strong> <em class="mh">)。容器内的主进程将被发送SIGKILL，或任何由option-signal</em>指定的信号</p><pre class="ku kv kw kx gt ln lo lp lq aw lr bi"><span id="f97c" class="ls lt in lo b gy lu lv l lw lx">docker stop [OPTIONS] CONTAINER</span></pre><p id="e571" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">它停止一个或多个正在运行的容器<em class="mh"> ( </em> <strong class="jx io"> <em class="mh">发送SIGTERM，然后在宽限期过后SIGKILL</em></strong><em class="mh">)。容器内的主进程将接收SIGTERM，在一段宽限期后，SIGKILL </em></p><p id="fd17" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您可以查看docker <a class="ae mi" href="https://docs.docker.com/engine/reference/commandline/docker/" rel="noopener ugc nofollow" target="_blank">文档</a>来了解其他docker命令。这里提到的几个就足够让你入门了。</p><p id="5db1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你喜欢读这篇文章，别忘了鼓掌。👏👏</p><p id="0906" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你也可以在twitter <a class="ae mi" href="https://twitter.com/Akash940" rel="noopener ugc nofollow" target="_blank"> @Akash940 </a>上关注我的JavaScript或React更新。</p><p id="3e4f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">谢谢你！</p></div></div>    
</body>
</html>