<html>
<head>
<title>[Golang] Garbage Collection in General</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">[Golang]垃圾收集</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/golang-garbage-collection-in-general-c28ae82558c4?source=collection_archive---------2-----------------------#2022-08-16">https://blog.devgenius.io/golang-garbage-collection-in-general-c28ae82558c4?source=collection_archive---------2-----------------------#2022-08-16</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="e9f9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">众所周知<code class="fe ki kj kk kl b">golang</code>是一种<strong class="jm io">垃圾收集</strong>语言，其他语言如<code class="fe ki kj kk kl b"><strong class="jm io">java</strong></code><strong class="jm io"/><code class="fe ki kj kk kl b"><strong class="jm io">python</strong></code><strong class="jm io"/><code class="fe ki kj kk kl b"><strong class="jm io">C#</strong></code><strong class="jm io"/>等。<code class="fe ki kj kk kl b"><strong class="jm io">Golang</strong></code> <strong class="jm io"> </strong>是静态类型化的<strong class="jm io"> <em class="km">垃圾收集语言。</em>T24】</strong></p><h2 id="5a4f" class="kn ko in bd kp kq kr dn ks kt ku dp kv jv kw kx ky jz kz la lb kd lc ld le lf bi translated">什么是垃圾收集，为什么需要垃圾收集</h2><p id="428c" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">很多文章都写了这个主题。因此，我将保持这个小范围，并尝试获得一些关于这个概念的更深入的见解。</p><blockquote class="ll lm ln"><p id="08fd" class="jk jl km jm b jn jo jp jq jr js jt ju lo jw jx jy lp ka kb kc lq ke kf kg kh ig bi translated">在 SML 程序中(以及大多数其他编程语言中)，有可能产生<strong class="jm io">垃圾</strong>:程序不再可用的已分配空间。</p></blockquote><p id="9998" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当软件在您的计算机上执行时，它使用两个重要的内存位置部分:<strong class="jm io">堆栈</strong>和<strong class="jm io">堆</strong>。</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi lr"><img src="../Images/9f5cb4d38a414ea5ae2434ce90b7ff34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Syd2Yqro1VGKZq78MlofPg.jpeg"/></div></div></figure><p id="e67c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在<code class="fe ki kj kk kl b">code</code>之上有一个<code class="fe ki kj kk kl b">RandomBox</code> <strong class="jm io">类型</strong>，<code class="fe ki kj kk kl b">GenerateRandomBox()</code>是一个<strong class="jm io">函数</strong>，它返回<code class="fe ki kj kk kl b">RandomBox</code> <strong class="jm io">类型。</strong><code class="fe ki kj kk kl b">ref</code>已经在<strong class="jm io">堆栈</strong>中赋值，结构数据在<strong class="jm io">堆中。</strong> <code class="fe ki kj kk kl b">Golang</code>采用<a class="ae md" href="https://en.wikipedia.org/wiki/Escape_analysis" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io">逸出分析</strong> </a>来确定。</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi me"><img src="../Images/ed8db94b613e8e4b40ebb819ee17b5fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P9AvzNM4SNLwc3h_zazgPw.jpeg"/></div></div></figure><p id="0cad" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当引用消失时，我们以<strong class="jm io">垃圾结束。</strong>这就是我们得到<strong class="jm io">垃圾</strong>的原因，这些垃圾需要经常清理。</p><blockquote class="ll lm ln"><p id="cacc" class="jk jl km jm b jn jo jp jq jr js jt ju lo jw jx jy lp ka kb kc lq ke kf kg kh ig bi translated">当程序的内存占用达到一定的阈值时，整个应用程序将被暂停，<strong class="jm io">垃圾</strong>垃圾<strong class="jm io">收集器</strong>扫描所有被分配内存空间并回收不再使用的对象，这个过程结束后，用户程序可以继续运行，早期的语言也使用这种策略实现垃圾收集，但今天的实现要复杂得多</p></blockquote><p id="a0a7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">垃圾收集</strong>可以手动启动，也可以自动启动，这取决于你使用的编程语言。每个程序编译器或解释器都使用特定的算法来执行<strong class="jm io">垃圾收集。编译语言中的垃圾收集</strong>与解释语言中的工作方式相同。</p><p id="cab8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ki kj kk kl b">Golang</code>使用<a class="ae md" href="https://en.wikipedia.org/wiki/Tracing_garbage_collection" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io">追踪垃圾</strong> </a> <strong class="jm io">收集器</strong>即使他们的代码通常会提前编译成机器码。Go 使用一个并发标记和清扫垃圾收集器算法。</p></div><div class="ab cl mf mg hr mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ig ih ii ij ik"><h2 id="24c6" class="kn ko in bd kp kq kr dn ks kt ku dp kv jv kw kx ky jz kz la lb kd lc ld le lf bi translated">垃圾收集过程中会发生什么</h2><p id="3a77" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated"><code class="fe ki kj kk kl b">Go</code>的<strong class="jm io">垃圾收集器</strong>之所以叫<strong class="jm io"> <em class="km">并发</em> </strong>是因为它可以安全地与主程序并行运行。</p><p id="7783" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当编译器基于某种条件(下面讨论)决定是时候运行<strong class="jm io">垃圾收集</strong>时，它会执行以下操作</p><p id="b3da" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">标记设置</strong></p><ul class=""><li id="3ef0" class="mm mn in jm b jn jo jr js jv mo jz mp kd mq kh mr ms mt mu bi translated">这意味着编译器试图停止一切，字面上称为<strong class="jm io">停止世界</strong>步骤。此时，您的应用程序中不会做任何事情。</li><li id="ecd9" class="mm mn in jm b jn mv jr mw jv mx jz my kd mz kh mr ms mt mu bi translated">首先，它会启用<strong class="jm io">写屏障</strong>，这意味着当此屏障处于<em class="km">(停止所有 go-routines) </em>状态时，不会在内存中写入任何内容。编译器必须执行此操作，以确保您的应用程序不会丢失任何数据。</li></ul><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi na"><img src="../Images/a033e81cc20f2c31d09d47ec891abbba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AiyLDQoZaseBwqV9nrHBqw.jpeg"/></div></div></figure><ul class=""><li id="3b6f" class="mm mn in jm b jn jo jr js jv mo jz mp kd mq kh mr ms mt mu bi translated">一旦执行了<strong class="jm io"> STW </strong>并且<strong class="jm io">写屏障</strong>打开，收集器就进入下一阶段。</li></ul><p id="e81d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">标记</strong></p><p id="3b54" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这一阶段，会发生以下情况</p><ul class=""><li id="13c0" class="mm mn in jm b jn jo jr js jv mo jz mp kd mq kh mr ms mt mu bi translated">检查<strong class="jm io">堆栈</strong>以找到<strong class="jm io">堆</strong>中的根指针</li><li id="dfb8" class="mm mn in jm b jn mv jr mw jv mx jz my kd mz kh mr ms mt mu bi translated">遍历<strong class="jm io">堆</strong>并查看它们是否仍在使用</li></ul><p id="3954" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">收集器</strong>也像我们一样使用<strong class="jm io">围棋程序</strong>，它从你可用的<strong class="jm io">围棋程序</strong>中抽取<strong class="jm io"> 25% </strong>并分配给自己。意味着根据我们之前的例子，1 个线程将专用于<strong class="jm io">收集器。</strong></p><blockquote class="ll lm ln"><p id="8490" class="jk jl km jm b jn jo jp jq jr js jt ju lo jw jx jy lp ka kb kc lq ke kf kg kh ig bi translated">现在，如果 collect 发现它在执行这个任务时可能会耗尽内存，因为其他一些 go-routine 分配了比它可以标记的更多的内存。因此它将选择 go-routine 并请求它帮助标记。这个过程叫做 M <strong class="jm io">方舟辅助</strong></p></blockquote><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi nb"><img src="../Images/f67b33693025f720a9fe3e6f42a9c113.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AlbHpdk-aEtZXozJNGE8jQ.jpeg"/></div></div></figure><p id="c010" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">标记终止</strong></p><p id="4a09" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里<strong class="jm io">收集器</strong>将再次执行<strong class="jm io"> STW </strong>，关闭<strong class="jm io">写屏障</strong>，执行一些清理并计算下一个<strong class="jm io">垃圾收集</strong>时间表</p><blockquote class="ll lm ln"><p id="1b40" class="jk jl km jm b jn jo jp jq jr js jt ju lo jw jx jy lp ka kb kc lq ke kf kg kh ig bi translated"><strong class="jm io">注:</strong>目标是在需要执行的每次采集中，保持<strong class="jm io"> STW </strong>下降或在<strong class="jm io">100 毫秒</strong>内</p></blockquote><p id="d70f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一旦<strong class="jm io">标记终止</strong>过程完成<em class="km"> (STW 和写屏障关闭)，</em>应用<em class="km"> </em>再次开始工作，所有<strong class="jm io"> OS 线程</strong>可用。</p></div><div class="ab cl mf mg hr mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ig ih ii ij ik"><p id="e572" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这就是每次收集发生的情况，你可能会问，是的，它通过识别悬空值做了标记，但是，它没有清理它们。那部分叫做<strong class="jm io">扫</strong></p><blockquote class="ll lm ln"><p id="905c" class="jk jl km jm b jn jo jp jq jr js jt ju lo jw jx jy lp ka kb kc lq ke kf kg kh ig bi translated"><strong class="jm io">流言终结者</strong> : <strong class="jm io">清扫</strong>不是<strong class="jm io">垃圾收集</strong>的一部分，它发生在收集过程之外的<strong class="jm io">。</strong></p></blockquote><h2 id="11a1" class="kn ko in bd kp kq kr dn ks kt ku dp kv jv kw kx ky jz kz la lb kd lc ld le lf bi translated">扫除</h2><p id="777f" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">这是一个我们要求非标记内存分配的过程。我们需要把它们找回来，这就是垃圾收集的全部目的。</p><ul class=""><li id="5c2e" class="mm mn in jm b jn jo jr js jv mo jz mp kd mq kh mr ms mt mu bi translated">当新的分配发生时，要求未使用的位置发生。因此，从技术上来说，<strong class="jm io">清扫</strong>的等待时间不会添加到<strong class="jm io">垃圾收集中。</strong></li></ul><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi nc"><img src="../Images/d117ea7a3dfa67ceed6f6f81f6db6caa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WfghuQnSLdwgKuek.gif"/></div></div></figure><h2 id="c45a" class="kn ko in bd kp kq kr dn ks kt ku dp kv jv kw kx ky jz kz la lb kd lc ld le lf bi translated">垃圾收集触发器</h2><ul class=""><li id="b28f" class="mm mn in jm b jn lg jr lh jv nd jz ne kd nf kh mr ms mt mu bi translated">垃圾收集器将观察的第一个指标是堆的增长。默认情况下，当<strong class="jm io"> <em class="km">堆的大小是</em> </strong>的两倍时，它就会运行。(<a class="ae md" href="https://github.com/golang/go/blob/master/src/runtime/mgc.go#L529" rel="noopener ugc nofollow" target="_blank">代码</a>)</li><li id="ce88" class="mm mn in jm b jn mv jr mw jv mx jz my kd mz kh mr ms mt mu bi translated">垃圾收集器关注的第二个指标是两个垃圾收集器之间的延迟。如果<strong class="jm io"> <em class="km">超过两分钟</em> </strong>未被触发，将强制一个循环。(<a class="ae md" href="https://github.com/golang/go/blob/master/src/runtime/mgc.go#L560" rel="noopener ugc nofollow" target="_blank">代码</a>)</li><li id="d4be" class="mm mn in jm b jn mv jr mw jv mx jz my kd mz kh mr ms mt mu bi translated">应用内存也可以触发<strong class="jm io">垃圾收集</strong>是<a class="ae md" href="https://github.com/golang/go/blob/master/src/runtime/malloc.go#L842" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="km">runtime . mallocgc</em></strong></a>函数，它在运行时将堆上的对象按大小分为微对象、小对象和大对象。这三个对象中的每一个的创建都可以触发新的垃圾收集周期。</li><li id="beaa" class="mm mn in jm b jn mv jr mw jv mx jz my kd mz kh mr ms mt mu bi translated"><strong class="jm io"> <em class="km">手动</em> </strong>调用<code class="fe ki kj kk kl b"><a class="ae md" href="https://github.com/golang/go/blob/master/src/runtime/mgc.go#L412" rel="noopener ugc nofollow" target="_blank"><strong class="jm io">gc()</strong></a></code>触发。</li></ul><h2 id="0e89" class="kn ko in bd kp kq kr dn ks kt ku dp kv jv kw kx ky jz kz la lb kd lc ld le lf bi translated">GC 收集器旋钮</h2><p id="5250" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">与<code class="fe ki kj kk kl b">java</code>不同的是<strong class="jm io"> </strong>决定<code class="fe ki kj kk kl b">golang</code>开发者不应该在他们转移到不同的硬件时调整他们的<strong class="jm io">垃圾收集器</strong>。所以他们只提供了一个调优配置，叫做<a class="ae md" href="https://pkg.go.dev/runtime/debug#SetGCPercent" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="km">SetGCPercentage</em></strong></a>或者<a class="ae md" href="https://pkg.go.dev/runtime#hdr-Environment_Variables" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="km">GOGC</em></strong></a>环境变量。默认为<a class="ae md" href="https://pkg.go.dev/runtime#hdr-Environment_Variables" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="km"/></strong></a><strong class="jm io"><em class="km"/></strong>为<strong class="jm io"/>的 100%</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi ng"><img src="../Images/1be207f5b723cfd7c1f1665eb8b8ef0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9FclolAl14faUYKSQBWC2Q.jpeg"/></div></div></figure><h2 id="a3c1" class="kn ko in bd kp kq kr dn ks kt ku dp kv jv kw kx ky jz kz la lb kd lc ld le lf bi translated">GC 起搏器</h2><p id="c6a6" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">有<strong class="jm io">调步算法</strong>试图计算出何时开始新的<strong class="jm io">收集。</strong>我们知道，计算发生在<strong class="jm io">标记终止<strong class="jm io">垃圾收集的</strong>阶段时。</strong><strong class="jm io">调步器</strong>算法试图对此进行计算，如果它发现甚至在条件适用之前就开始收集可以获得更多好处，它就会这样做。因此，如果<strong class="jm io">步行者</strong>认为它可以获得更多利益，那么收集甚至可以在计算的时间之前开始。</p><p id="bcf6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">希望这篇博客能够提供更多关于<strong class="jm io">垃圾收集</strong>过程和它是如何在<code class="fe ki kj kk kl b">Golang</code>中实现的</p><h1 id="92be" class="nh ko in bd kp ni nj nk ks nl nm nn kv no np nq ky nr ns nt lb nu nv nw le nx bi translated">快乐学习！！</h1></div></div>    
</body>
</html>