<html>
<head>
<title>Inheritance and Polymorphism in Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java 中的继承和多态</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/inheritance-and-polymorphism-in-java-7b3c42235aae?source=collection_archive---------3-----------------------#2022-02-22">https://blog.devgenius.io/inheritance-and-polymorphism-in-java-7b3c42235aae?source=collection_archive---------3-----------------------#2022-02-22</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/3ee095a1acbcd811f5f92de22cf5a596.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*PCrObyBu1ektfPWd.png"/></div></div></figure><p id="6c83" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">子类和超类(父类和子类)</strong></p><p id="ffa8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果我们有几个类，比如狗类、猫类、狼类、牛类和狮子类，我们可以看到所有这些类都有共同的行为和特征。所有这些类都应该有一个 eat 方法、sleep 方法、move 方法和 makenoise 方法。以及食物等共同特征。</p><p id="b5b7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，我们可以利用所有这些共同特征，创建一个名为 animal 的超类，并将所有这些共同特征包含在这个类中。因此，动物类将被称为超类，动物所属的类(例如，狗类、猫类)将被称为子类。</p><p id="a0b7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">动物类看起来像这样，</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div class="gh gi kt"><img src="../Images/841b3dfe478125956b6cf39b489bcc3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:380/format:webp/1*cUf3l_6xrVps5Zgx77brzQ.png"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">动物类的高级视图</figcaption></figure><p id="aecf" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">既然我们创建了这个 Animal 类，我们就不需要在每个子类中都有这些公共方法。我们可以从子类中移除所有这些公共方法。现在，我们可以<strong class="jx io">从超类继承</strong>这些方法，而不是在子类中拥有所有的公共方法。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div class="gh gi lc"><img src="../Images/8a03a27394c5eedf9de1cb2b28799ac2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1262/format:webp/1*NYwRQH83sEL-4nDzg98sZA.png"/></div></figure><p id="502a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们可以看到，cow 类必须实现的方法数量减少了。使用继承的一个原因是为了避免重复，我们可以减少编写相同方法的次数。如果我们没有使用继承，我们将不得不用完全相同的代码写 5 次 move 方法，但是现在我们有了一个可以被所有 5 个子类使用的方法。</p><p id="25e9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">继承类的实现如下所示。</p><pre class="ku kv kw kx gt ld le lf lg aw lh bi"><span id="18b4" class="li lj in le b gy lk ll l lm ln">public class Dog extends Animal{</span></pre><p id="e6dc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们使用 extends 关键字从超类继承。在这种情况下，Dog 类继承了 Animal 类</p><p id="bc89" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">尽管如此，在 cow 类中还是有一些方法，尽管它们对所有动物都是通用的。</p><p id="cc9b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们假设这个例子中的所有动物都以同样的方式进食和睡觉。但是动物有一些不同的方法。例如，一头牛和一只狗吃的方式不同，发出的声音也不同。尽管 eat 方法对所有动物来说都是通用的，但有时您可能需要自己的实现，而不是采用超类中给出的方法。因此我们必须<strong class="jx io">覆盖</strong>超类中给定的方法。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lo"><img src="../Images/e971fae15a60644ed2d4790b3bfa10b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gIR3s4GbP2cBy52XOKCDiA.png"/></div></div></figure><p id="ed5a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们假设动物而不是牛吃同样的东西，因此我们可以在超类(Animal)中有一个公共的吃的方法，并且我们可以在 cow 类中覆盖 eat 方法。其他类可以从 Animal 类继承 eat 方法，因为所有其他类的功能都是相同的。即使我们可以覆盖超类中的方法，我们也不能覆盖其中的实例变量。</p><p id="df5b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">重写一个方法看起来像这样。</p><pre class="ku kv kw kx gt ld le lf lg aw lh bi"><span id="5f97" class="li lj in le b gy lk ll l lm ln">@Override<br/>public void eat() {<br/>    // eat method specific to the subclass<br/>}</span></pre><p id="6d34" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们可以使用@Override 关键字来覆盖超类的一个方法。</p><p id="fc77" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当我们查看类时，我们可以看到类的层次结构，我们可以进一步发现一些类中的共同行为，因此我们将这些类分组在一起，例如，狗和狼可以被分组为犬科动物，而猫和狮子可以被分组为猫科动物。</p><p id="3a52" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们认为猫科动物和犬科动物的运动方式彼此不同。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div class="gh gi lp"><img src="../Images/4a044a9a70d4a43a512b77f74c9f8a27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1320/format:webp/1*aXA1TdOhxjf_EKIjt9LHpg.png"/></div></figure><p id="daa2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当你调用一个类中的方法时，继承树中最慢的方法会被调用，比如说你调用 dog 类中的 makenoise 方法，那么 dog 类中的方法会被调用，因为它是继承树中最慢的方法。</p><p id="1c37" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你需要超类方法(例如 roam)并且你需要你自己的超类方法，我们可以像下面这样做。</p><pre class="ku kv kw kx gt ld le lf lg aw lh bi"><span id="9140" class="li lj in le b gy lk ll l lm ln">public void roam() {<br/>    super.roam();<br/>    // continue with my method<br/>}</span></pre><p id="7d67" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们可以使用 super 关键字来调用超类的方法，然后继续我们的方法</p><p id="4e89" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">是/有关系</strong></p><p id="5b47" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们可以知道一个类是否应该通过使用 IS A 方法来继承，例如我们可以说狗是一种动物，我们可以通过使用这个方法来判断我们的设计是否正确。</p><p id="51cc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当一个类有一个关系，例如，浴室有一个水槽。这意味着水槽应该是浴室的实例变量。</p><p id="a4c4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">即使我们可以从超类继承方法和变量，如果它们被标记为私有，那么我们不能继承那些变量或方法。</p><p id="29ef" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当我们使用继承时，我们应该确保我们使用它是出于正确的原因。<br/>我们不应该仅仅为了重用代码而使用继承。假设我们在 alarm 类中有一个特殊的 print 方法，现在你需要在 calculator 类中有一个 print 方法，我们不能只是从 Alarm 类中继承它，因为 calculator 不是 Alarm 的一个特定版本，你可以使用 IS A 方法(Alarm is a calculator 听起来不太合适)，作为一个解决方案，我们可以有一个单独的 print 类和 print 方法。</p><p id="3df4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果继承没有通过测试，我们就不应该使用它。</p><p id="322a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">使用继承的好处是你可以重用代码，如果我们需要添加一个新的类(比如 Tiger 类)，你可以添加这个类而不影响其他类和其他代码。</p><p id="6ece" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">它保证所有子类都由超类的方法组成，这就像是通过继承相关的类的一个公共协议。</p><p id="d845" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在一般实践中，当我们创建一个继承树的时候，这个继承树是浅而宽的。</p><p id="b417" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">通常创建一只狗的新对象时，我们会使用</p><pre class="ku kv kw kx gt ld le lf lg aw lh bi"><span id="6d73" class="li lj in le b gy lk ll l lm ln">Dog dog = new Dog();</span></pre><p id="cb5e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是如果 Dog 类继承了 Animal 类，我们也可以用这种方式创建 Dog 对象</p><pre class="ku kv kw kx gt ld le lf lg aw lh bi"><span id="b0be" class="li lj in le b gy lk ll l lm ln">Animal dog = new Dog();</span></pre><p id="9ee0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">通过这样做，我们在堆中创建了一个新的 Dog 对象，但是引用对象的类型是 Animal。由于多态性，这是可以做到的</p><p id="b7dc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">多态</strong>的意思是多种形式，它的意思是一个对象具有多种形式的能力。<br/>在这种情况下，狗对象可以采取动物的形式。</p><p id="68a6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这样做的好处是，假设我们有一个函数需要动物的 makenoise 方法。</p><pre class="ku kv kw kx gt ld le lf lg aw lh bi"><span id="2420" class="li lj in le b gy lk ll l lm ln">public void talkingAnimal (Animal a){<br/>    a.makenoise();<br/>}</span></pre><p id="44f0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">假设我们有一个如上所示的方法，如果我们需要对每个动物都使用这个方法，我们就必须为每个动物分别编写这个函数。但是现在我们可以使用多态，我们可以把狗作为动物来传递。然后方法 a.makenoise 将调用传递给函数的特定动物的方法</p><p id="78c3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果一个狗对象被传递给函数，那么狗的 makenoise 方法将被调用，如果一个猫对象被传递，那么猫的 makenoise 方法将被调用。</p><p id="01b1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果代码使用多态参数，将方法参数声明为超类类型，则可以在运行时传入任何子类对象。</p><p id="103e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当使用继承时，有些情况下你不能从一个类继承。</p><ul class=""><li id="25ae" class="lq lr in jx b jy jz kc kd kg ls kk lt ko lu ks lv lw lx ly bi translated">当类被标记为 final 时，不能从该类继承。</li><li id="3565" class="lq lr in jx b jy lz kc ma kg mb kk mc ko md ks lv lw lx ly bi translated">如果类只有私有构造函数，则不能从该类继承</li></ul><p id="22ea" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果一个类不是公共的，那么可以从该类继承的类是有限的。非公共类只能由同一个包中的子类继承。</p><p id="12ab" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们不能将类标记为私有。</p><p id="64d7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果您不希望类中的方法被覆盖，那么将类设为 final 的原因可能是出于隐私考虑。<br/>如果你不想只覆盖一个特定的方法，你可以让这个特定的方法成为最终方法。</p><p id="167d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当覆盖一个方法时，你必须确保遵循以下规则</p><ul class=""><li id="55a9" class="lq lr in jx b jy jz kc kd kg ls kk lt ko lu ks lv lw lx ly bi translated">确保方法的参数必须完全相同，不能更改类的参数，</li><li id="bc38" class="lq lr in jx b jy lz kc ma kg mb kk mc ko md ks lv lw lx ly bi translated">方法的返回类型应该是相同的，或者是原始方法的返回类型的子类。</li><li id="cdaf" class="lq lr in jx b jy lz kc ma kg mb kk mc ko md ks lv lw lx ly bi translated">您不能降低方法的访问级别(例如，不能从 public 更改为 private)。</li></ul><p id="0251" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">重载一个方法<br/> </strong>重载一个方法与继承或多态无关。方法重载意味着我们和另一个方法有相同的方法名，但是我们有不同的参数。</p><pre class="ku kv kw kx gt ld le lf lg aw lh bi"><span id="4a65" class="li lj in le b gy lk ll l lm ln">//Perimeter of a square<br/>public int perimeter(int a) {<br/>    return a*4;<br/>}<br/>//Perimeter of a rectangle<br/>public double perimeter(double a, double b) {<br/>    return (2 * a) + (2 * b);<br/>}</span></pre><p id="77de" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">In 方法重载</p><ul class=""><li id="5fbe" class="lq lr in jx b jy jz kc kd kg ls kk lt ko lu ks lv lw lx ly bi translated">我们可以改变方法的返回类型，但不能只改变返回类型而不改变参数。</li><li id="37f4" class="lq lr in jx b jy lz kc ma kg mb kk mc ko md ks lv lw lx ly bi translated">我们还可以改变方法的访问级别</li></ul><p id="189b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你可以通过查看我的 Java 入门列表，点击<a class="ae me" href="https://medium.com/@shashane.ranasinghe/list/introduction-to-java-9eb6c894d19c" rel="noopener">这里</a>来了解更多关于 Java 的知识</p><p id="08ea" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">参考文献</strong></p><ol class=""><li id="5831" class="lq lr in jx b jy jz kc kd kg ls kk lt ko lu ks mf lw lx ly bi translated">凯西·塞拉和伯特·贝茨。2005.第一版 Java，第二版。美国奥赖利&amp;联合公司。</li></ol></div></div>    
</body>
</html>