<html>
<head>
<title>Of Classes and Constructor Functions: How JavaScript is Different from Other OOP Languages</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">类和构造函数:JavaScript 与其他 OOP 语言有何不同</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/of-classes-and-constructor-functions-how-javascript-is-different-from-other-oop-languages-4e3d57628751?source=collection_archive---------11-----------------------#2020-06-19">https://blog.devgenius.io/of-classes-and-constructor-functions-how-javascript-is-different-from-other-oop-languages-4e3d57628751?source=collection_archive---------11-----------------------#2020-06-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/f1aa16f6e968b3a6c8d454bae70a0eac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*ZDcIPYINqtkiM68KCty97w.gif"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">由<a class="ae kc" href="https://dribbble.com/shots/6998335-Robot-animation#shot-description" rel="noopener ugc nofollow" target="_blank">海洋运球创造</a></figcaption></figure><p id="1a39" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae kc" href="https://dev.to/gnio/eli5-functions-vs-class-constructor-in-javascript-nki" rel="noopener ugc nofollow" target="_blank">有人提出了一个关于 JavaScript 中函数和构造函数的区别的问题。这个问题源于 JavaScript 臭名昭著的名声，即<em class="lb">不是</em>真正的面向对象语言。</a></p><p id="dd7f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">虽然这是真的(我们将在后面讨论)，但与传统的 OOP 语言(如 C++、Java 或 Python)相比，流行的文献大多解释了这一点。这不仅没有帮助，而且对那些不熟悉这些语言的人来说也很困惑。</p><p id="73fe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以在这篇文章中，我将试图弄清楚 JavaScript 类与传统 OOP 类的区别。我将使用 Python 作为这些语言的代表，因为它易于理解，并且相对接近 JavaScript。</p><h1 id="219a" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">传统面向对象语言</h1><p id="7865" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">一个<code class="fe mf mg mh mi b">class</code>通常被定义为对象的蓝图。它有两个实际用途:</p><ul class=""><li id="0516" class="mj mk iq kf b kg kh kk kl ko ml ks mm kw mn la mo mp mq mr bi translated">抽象:哪些信息是相关的？这无关紧要。</li><li id="54ad" class="mj mk iq kf b kg ms kk mt ko mu ks mv kw mw la mo mp mq mr bi translated">封装:如何显示或隐藏相关或不相关的内容？</li></ul><p id="cb2c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在它的核心，一个<code class="fe mf mg mh mi b">class</code>有两种类型的属性:<code class="fe mf mg mh mi b">members</code>和<code class="fe mf mg mh mi b">methods</code>。这些属性定义了存储在<code class="fe mf mg mh mi b">class</code>中的数据以及<code class="fe mf mg mh mi b">class</code>可以对这些数据做什么操作。</p><p id="8797" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了利用一个<code class="fe mf mg mh mi b">class</code>，我们通过一个叫做实例化的过程来创建这个类的<code class="fe mf mg mh mi b">instances</code>。每个<code class="fe mf mg mh mi b">instance</code>得到<code class="fe mf mg mh mi b">class</code>的<code class="fe mf mg mh mi b">members</code>和<code class="fe mf mg mh mi b">methods</code>的<em class="lb">隔离</em>副本。让我们看看这在 Python 中是如何工作的:</p><figure class="mx my mz na gt jr"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="0393" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本例中，<code class="fe mf mg mh mi b">person_a</code>和<code class="fe mf mg mh mi b">person_b</code>是<code class="fe mf mg mh mi b">Person</code>的<code class="fe mf mg mh mi b">instances</code>。他们每个人都有自己的<code class="fe mf mg mh mi b">first_name</code>和<code class="fe mf mg mh mi b">last_name</code>成员，以及自己的<code class="fe mf mg mh mi b">print_full_name</code>方法。</p><p id="ed6e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在在 Python 中，你只需直接调用<code class="fe mf mg mh mi b">class</code>就可以执行实例化(就像我们如何创建<code class="fe mf mg mh mi b">person_a</code>和<code class="fe mf mg mh mi b">person_b</code>)。然而，传统上并不总是这样。例如，在 C++和 Java 中，您需要添加关键字<code class="fe mf mg mh mi b">new</code>，以便能够实例化<code class="fe mf mg mh mi b">class</code>。我认为这是混乱的开始。</p><h1 id="0bd9" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">Java Script 语言</h1><p id="89e5" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">在 JavaScript 中，我们用关键字<code class="fe mf mg mh mi b">new</code>调用了一个叫做<strong class="kf ir">的构造函数</strong>。这些构造函数是类的 JavaScript 模拟。现在，虽然看起来这和我们提到的其他语言是一样的，但是每当我们使用这些构造函数时，JavaScript 的行为就不同了。看，每当我们使用<code class="fe mf mg mh mi b">new</code>关键字来执行一个构造函数时，我们实际上是告诉 JavaScript 正常运行该函数，但是在幕后有两个额外的步骤:</p><ol class=""><li id="f200" class="mj mk iq kf b kg kh kk kl ko ml ks mm kw mn la nd mp mq mr bi translated">在函数的开头创建了一个隐式对象，我们可以用<code class="fe mf mg mh mi b">this</code>引用它。</li><li id="2c88" class="mj mk iq kf b kg ms kk mt ko mu ks mv kw mw la nd mp mq mr bi translated">结果实例在其自己的原型中有一个构造函数的原型属性的副本。</li></ol><p id="86b2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在不要担心细节，因为我们以后会谈到这些。让我们先看看如何在没有任何奇特构造函数的情况下创建一个 JavaScript 对象:</p><figure class="mx my mz na gt jr"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="bac3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这工作得非常好！为什么不到此为止，结束这一切呢？</p><p id="9d1c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好吧，残酷而诚实的事实是，我们<em class="lb">可以</em>。通过这种方式简单地创建对象，我们可以完成很多事情。但是这样做，我们就忽略了 JavaScript 作为一种基于原型的语言的全部意义。这是它区别于传统 OOP 语言的独特之处(不一定更好也不一定更差)。</p><p id="eb43" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们看看如何用另一种方式实现它。当您阅读下面的代码片段时，请记住当使用<code class="fe mf mg mh mi b">new</code>调用构造函数时，在幕后发生的额外两个步骤。</p><figure class="mx my mz na gt jr"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="371c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这就是奇迹发生的地方。如您所见，当我们创建<code class="fe mf mg mh mi b">Person</code>类时，我们将定义成员的地方(<code class="fe mf mg mh mi b">firstName</code>和<code class="fe mf mg mh mi b">lastName</code>)和定义方法的地方(<code class="fe mf mg mh mi b">fullName</code>)分开。<code class="fe mf mg mh mi b">firstName</code>和<code class="fe mf mg mh mi b">lastName</code>就在你期望的地方:在构造函数定义里面。但是有趣的部分是我们定义<code class="fe mf mg mh mi b">fullName</code>的地方，那是在构造函数的<code class="fe mf mg mh mi b">prototype</code>里。</p><p id="c6e7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为什么这很重要？这很重要，因为每当我们通过 <code class="fe mf mg mh mi b"><strong class="kf ir">new</strong></code> <strong class="kf ir">关键字创建一个新的</strong><code class="fe mf mg mh mi b"><strong class="kf ir">instance</strong></code><strong class="kf ir"/><code class="fe mf mg mh mi b"><strong class="kf ir">Person</strong></code><strong class="kf ir">构造函数时，一个引用了</strong> <code class="fe mf mg mh mi b"><strong class="kf ir">prototype</strong></code> <strong class="kf ir">属性的构造函数就会被添加到</strong> <code class="fe mf mg mh mi b"><strong class="kf ir">__proto__</strong></code> <strong class="kf ir">对象的属性中。再读一遍。之后，再读一遍。确保你拿到了。</strong></p><figure class="mx my mz na gt jr"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="ba23" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">与传统的 OOP 语言相反，方法不会被复制到构造函数(或类)的每个实例中。当我们调用<code class="fe mf mg mh mi b">personA.fullName()</code>时，JavaScript 不是在实例本身中查找方法，而是查看<code class="fe mf mg mh mi b">personA</code>的<code class="fe mf mg mh mi b">__proto__</code>属性，然后<em class="lb">沿着</em>向上爬，直到找到<code class="fe mf mg mh mi b">fullName</code>。由于我们在<code class="fe mf mg mh mi b">Person.prototype</code>中定义了<code class="fe mf mg mh mi b">fullName</code>，并且<code class="fe mf mg mh mi b">Person.prototype</code>与<code class="fe mf mg mh mi b">personA.__proto__</code>相同，所以当我们调用<code class="fe mf mg mh mi b">personA.fullName()</code>时，我们调用的是一个不存在于实例中，而是存在于构造函数本身中的方法！这提供了性能优势，因为这些方法只需定义一次(在构造函数的原型上)。也就是说:</p><figure class="mx my mz na gt jr"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="82fc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这意味着我们在<code class="fe mf mg mh mi b">Person.prototype</code>上定义的任何东西都可以用于<code class="fe mf mg mh mi b">Person</code>的所有实例。实际上，我们可以做一些奇怪的事情(从传统 OOP 的角度来看),比如:</p><figure class="mx my mz na gt jr"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="7b9b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以你有它。总结一下:</p><ul class=""><li id="fb19" class="mj mk iq kf b kg kh kk kl ko ml ks mm kw mn la mo mp mq mr bi translated">每当用<code class="fe mf mg mh mi b">new</code>调用构造函数时，它们都在后台做两件事:创建一个可以用<code class="fe mf mg mh mi b">this</code>引用的隐式对象，并将每个实例的<code class="fe mf mg mh mi b">__proto__</code>属性赋给构造函数的<code class="fe mf mg mh mi b">prototype</code>属性</li><li id="d027" class="mj mk iq kf b kg ms kk mt ko mu ks mv kw mw la mo mp mq mr bi translated">当在实例上调用一个函数时，<code class="fe mf mg mh mi b">__proto__</code>属性会一直攀升，直到找到对被调用函数的引用。这意味着每个实例都没有对方法的引用，但是所有实例都共享在构造函数上定义的同一个方法。</li><li id="d3dd" class="mj mk iq kf b kg ms kk mt ko mu ks mv kw mw la mo mp mq mr bi translated">在传统的 OOP 中，每个方法的所有实例都有一个副本。没有原型的概念。</li></ul><h1 id="5656" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">ES6“类”是什么</h1><p id="e0a3" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">ES6“类”并没有真正引入我们传统上所知道的类。这使得编写构造函数变得更加容易，因为你不必为每个你想在实例间共享的方法编写<code class="fe mf mg mh mi b">prototype</code>。ES6 类语法是一种更简单的方法，可以将一个构造函数的所有成员和方法都存储在一个地方，同时还可以抽象出<code class="fe mf mg mh mi b">prototype</code>和它带来的所有混乱。</p><p id="fdfa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">作为一个例子，我们可以用下面的方式编写<code class="fe mf mg mh mi b">Person</code>构造函数:</p><figure class="mx my mz na gt jr"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="b099" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以看到它看起来非常类似于我们的 python 示例(但是您和我都知道它们是不一样的！).尝试创建<code class="fe mf mg mh mi b">Person</code>的实例，并亲自查看<code class="fe mf mg mh mi b">prototype</code>属性！😉</p></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><p id="554b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">原发布于</em><a class="ae kc" href="https://www.adrianperea.dev/of-classes-and-constructor-functions-how-javascript-is-different-from-other-oop-languages/" rel="noopener ugc nofollow" target="_blank"><em class="lb">https://www . Adrian perea . dev</em></a><em class="lb">。</em></p></div></div>    
</body>
</html>