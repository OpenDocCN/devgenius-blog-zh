<html>
<head>
<title>[KEDA] — Implement Serverless on Kubernetes using KEDA | Deploy Java Quarkus Application on K8S and Scale to 0 to N using events</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">[KEDA] —使用 KEDA 在 Kubernetes 上实现无服务器|在 K8S 上部署 Java Quarkus 应用程序，并使用事件扩展到 0 到 N</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/keda-implement-serverless-on-kubernetes-using-keda-deploy-java-quarkus-application-on-k8s-dcbabad71684?source=collection_archive---------6-----------------------#2022-06-05">https://blog.devgenius.io/keda-implement-serverless-on-kubernetes-using-keda-deploy-java-quarkus-application-on-k8s-dcbabad71684?source=collection_archive---------6-----------------------#2022-06-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/baa15666128506de501dfc817df609d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*02kuLLHEgzOyl-i6tcqgaw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">kubernetes KEDA Java quar kus AWS SQS 活动标志</figcaption></figure><h1 id="df9a" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">什么是无服务器？</h1><p id="f993" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">无服务器基本上是一种执行模型，通过动态分配资源，您可以执行任何代码，而无需考虑服务器。比如 AWS 有 Lambda，Azure 有 Azure 功能，GCP 有云功能。在这些云提供商中，如果我们使用他们的无服务器功能，我们就不需要照顾服务器。我们只上传我们的构建并基于任何事件执行它。</p><p id="d38c" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">简而言之，我们可以说，无服务器意味着服务器端逻辑仍由应用程序开发人员编写的应用程序，但与传统架构不同，它运行在无状态计算容器中，这些容器是事件触发的、短暂的(可能只持续一次调用)，并且完全由第三方管理。</p><p id="f5e2" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">Kubernetes ，也称为 K8s，是一个用于自动化部署、扩展和管理容器化应用程序的开源系统。</p><h2 id="fffd" class="md kd iq bd ke me mf dn ki mg mh dp km ll mi mj kq lp mk ml ku lt mm mn ky mo bi translated">HPA—Kubernetes 中的缩放</h2><p id="3bc2" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">我们知道 Kuberneter 在豆荚里运行容器。我们通常使用水平机架自动扩展(HPA)来横向扩展和扩展机架数量。然而，HPA 有一个小限制，当我们将“minReplicas”值保持为 0 时，它会抛出错误，指出它必须大于或等于 1。</p><h1 id="b1fb" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">KEDA — Kubernetes 事件驱动的自动缩放</h1><p id="09bc" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">KEDA 是一个基于 Kubernetes 的事件驱动自动缩放器。使用 KEDA，您可以根据需要处理的事件数量来扩展 Kubernetes 中的任何容器。</p><p id="8b3d" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">KEDA 是一个单一用途的轻量级组件，可以添加到任何 Kubernetes 集群中。KEDA 使用水平 Pod 自动缩放器来扩展功能，无需覆盖或复制。<a class="ae mp" href="https://keda.sh/docs/2.6/concepts/" rel="noopener ugc nofollow" target="_blank">点击这里进入官方文档页面。</a></p><h1 id="a6ea" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">使用 KEDA 的 Kubernetes 上的无服务器</h1><p id="9513" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">嗯，不完全是无服务器的。它更像是在不使用时将 pod 缩放到 0，并基于事件向外扩展。我们可以根据事件数量扩展到“n”个单元。</p><figure class="mr ms mt mu gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mq"><img src="../Images/b94525e2c59539cd29958b5c9e43fa33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WzU7jyFzxk6bKbQaLzu1Dg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">KEDA 定标器</figcaption></figure><h1 id="edb8" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">这个故事的用例</h1><p id="757b" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">我们将创建一个简单的 quarkus 应用程序，它将无限循环地读取来自 SQS 的消息。我们将处理该消息(只需将其记录在控制台中)。<br/>当队列中没有消息时，我们的 pod 应该伸缩到 0，当队列中有消息时，应该伸缩到 0。<br/>我们在这里使用夸库，因为它的开始时间真的很快，正如我们在这里的上一个故事中看到的<a class="ae mp" href="https://towardsdev.com/quarkus-develop-and-deploy-cloud-native-java-applications-at-supersonic-speed-be6c28dd4243" rel="noopener ugc nofollow" target="_blank">。</a></p><h2 id="c8bf" class="md kd iq bd ke me mf dn ki mg mh dp km ll mi mj kq lp mk ml ku lt mm mn ky mo bi translated">先决条件</h2><ol class=""><li id="e6cf" class="mv mw iq lc b ld le lh li ll mx lp my lt mz lx na nb nc nd bi translated">Java 11+版本</li><li id="862b" class="mv mw iq lc b ld ne lh nf ll ng lp nh lt ni lx na nb nc nd bi translated">格雷尔还是梅文</li><li id="bb20" class="mv mw iq lc b ld ne lh nf ll ng lp nh lt ni lx na nb nc nd bi translated">码头工人</li><li id="3dcc" class="mv mw iq lc b ld ne lh nf ll ng lp nh lt ni lx na nb nc nd bi translated">库伯内特斯</li><li id="3312" class="mv mw iq lc b ld ne lh nf ll ng lp nh lt ni lx na nb nc nd bi translated">头盔(可选)</li><li id="7850" class="mv mw iq lc b ld ne lh nf ll ng lp nh lt ni lx na nb nc nd bi translated">消息队列(在本文中，我们将使用 AWS SQS)</li></ol><h2 id="1b9c" class="md kd iq bd ke me mf dn ki mg mh dp km ll mi mj kq lp mk ml ku lt mm mn ky mo bi translated">安装 KEDA</h2><p id="b3d0" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">我们将使用 Helm 在我们的 Kuberneter 集群上安装 KEDA。如果你愿意，你也可以使用其他方法，更多细节请点击这里的<a class="ae mp" href="https://keda.sh/docs/2.6/deploy/" rel="noopener ugc nofollow" target="_blank">官方文档</a>。</p><ol class=""><li id="bfd6" class="mv mw iq lc b ld ly lh lz ll nj lp nk lt nl lx na nb nc nd bi translated">添加舵 Repo</li></ol><blockquote class="nm nn no"><p id="e53d" class="la lb np lc b ld ly lf lg lh lz lj lk nq ma ln lo nr mb lr ls ns mc lv lw lx ij bi translated">赫尔姆回购加科达科尔【https://kedacore.github.io/charts T2】号</p></blockquote><p id="0c74" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">2.更新 Helm 报告</p><blockquote class="nm nn no"><p id="3be3" class="la lb np lc b ld ly lf lg lh lz lj lk nq ma ln lo nr mb lr ls ns mc lv lw lx ij bi translated">helm repo 更新</p></blockquote><p id="d97d" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">3.使用舵图安装 KEDA</p><blockquote class="nm nn no"><p id="1b34" class="la lb np lc b ld ly lf lg lh lz lj lk nq ma ln lo nr mb lr ls ns mc lv lw lx ij bi translated">kubectl 创建名称空间 keda <br/> helm 安装 keda kedacore/keda —名称空间 keda</p></blockquote><p id="32f6" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">现在让我们运行以下命令来查看 keda 部署:</p><blockquote class="nm nn no"><p id="6eb6" class="la lb np lc b ld ly lf lg lh lz lj lk nq ma ln lo nr mb lr ls ns mc lv lw lx ij bi translated">kubectl get all -n keda</p></blockquote><p id="b0ee" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">我们应该得到这样的结果:</p><figure class="mr ms mt mu gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nt"><img src="../Images/bcd9149729f82c6cadf1b5fbc7a42ace.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oLQ2O85Lmiz7jjI0qDjvvA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">KEDA 在库伯内特斯的部署</figcaption></figure><h2 id="4ab4" class="md kd iq bd ke me mf dn ki mg mh dp km ll mi mj kq lp mk ml ku lt mm mn ky mo bi translated">配置 AWS CLI 和创建 SQS 队列</h2><p id="869c" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">我们也可以在这个过程中使用 AWS 控制台，只需登录 AWS 帐户，转到 SQS 并创建一个新的标准队列。</p><p id="519c" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">首先，我们将按照这里的官方文档<a class="ae mp" href="https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html" rel="noopener ugc nofollow" target="_blank">在我们的机器上安装 AWS CLI</a>。</p><p id="4976" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">安装后使用'<em class="np"> aws configure </em>'命令配置您的凭证。</p><p id="d746" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">现在让我们使用下面的命令创建一个队列:</p><pre class="mr ms mt mu gt nu nv nw nx aw ny bi"><span id="4dd8" class="md kd iq nv b gy nz oa l ob oc">QUEUE_URL=`aws2 sqs create-queue --queue-name=ColliderQueue`<br/>echo $QUEUE_URL</span></pre><p id="4ddc" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">这将在您的控制台上打印队列 url。</p><h2 id="9b56" class="md kd iq bd ke me mf dn ki mg mh dp km ll mi mj kq lp mk ml ku lt mm mn ky mo bi translated">用于读取来自 SQS 的消息的 Quarkus 应用程序代码</h2><p id="1b79" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">让我们创建一个简单的 Quarkus 应用程序，并编写从 SQS 读取的基本代码。关于如何开始使用 Quarkus 的更多细节，请阅读这篇文章。</p><p id="1b86" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">我们将创建一个简单的项目<a class="ae mp" href="https://code.quarkus.io/?g=com.keda.example&amp;a=keda-sqs-example&amp;b=GRADLE&amp;nc=true&amp;e=io.quarkiverse.amazonservices%3Aquarkus-amazon-sqs&amp;e=resteasy-jackson" rel="noopener ugc nofollow" target="_blank">,依赖于 jackson 和 sqs </a>。还要加上'<em class="np">实现' software . Amazon . AWS SDK:URL-connection-client '</em>'依赖。依赖关系列表应该如下所示:</p><pre class="mr ms mt mu gt nu nv nw nx aw ny bi"><span id="0a66" class="md kd iq nv b gy nz oa l ob oc">dependencies <strong class="nv ir">{<br/>    </strong>implementation enforcedPlatform("$<strong class="nv ir">{</strong>quarkusPlatformGroupId<strong class="nv ir">}</strong>:$<strong class="nv ir">{</strong>quarkusPlatformArtifactId<strong class="nv ir">}</strong>:$<strong class="nv ir">{</strong>quarkusPlatformVersion<strong class="nv ir">}</strong>")<br/>    implementation enforcedPlatform("$<strong class="nv ir">{</strong>quarkusPlatformGroupId<strong class="nv ir">}</strong>:quarkus-amazon-services-bom:$<strong class="nv ir">{</strong>quarkusPlatformVersion<strong class="nv ir">}</strong>")<br/>    implementation 'io.quarkus:quarkus-resteasy-jackson'<br/>    implementation 'io.quarkiverse.amazonservices:quarkus-amazon-sqs'<br/>    implementation 'software.amazon.awssdk:url-connection-client'<br/>    implementation 'io.quarkus:quarkus-arc'<br/>    testImplementation 'io.quarkus:quarkus-junit5'<br/><strong class="nv ir">}</strong></span></pre><p id="5f11" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">我们将创建一个示例消息模型类:</p><pre class="mr ms mt mu gt nu nv nw nx aw ny bi"><span id="3817" class="md kd iq nv b gy nz oa l ob oc">public class MessageModel {<br/><br/>    private int messageId;<br/>    private String messageText;<br/><br/>    public int getMessageId() {<br/>        return messageId;<br/>    }<br/><br/>    public void setMessageId(int messageId) {<br/>        this.messageId = messageId;<br/>    }<br/><br/>    public String getMessageText() {<br/>        return messageText;<br/>    }<br/><br/>    public void setMessageText(String messageText) {<br/>        this.messageText = messageText;<br/>    }<br/>}</span></pre><p id="56fc" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">以及一个简单的代码，用于连续轮询队列中的消息:</p><pre class="mr ms mt mu gt nu nv nw nx aw ny bi"><span id="949d" class="md kd iq nv b gy nz oa l ob oc">@ApplicationScoped<br/>public class SqsSampleMessageReceiver implements Runnable {<br/><br/>    Logger log = Logger.<em class="np">getLogger</em>(SqsSampleMessageReceiver.class);<br/><br/>    static ObjectReader <em class="np">MESSAGE_READER </em>= new ObjectMapper().readerFor(MessageModel.class);<br/><br/>    private final ExecutorService scheduler = Executors.<em class="np">newSingleThreadExecutor</em>();<br/><br/>    @Inject<br/>    private SqsClient sqsClient;<br/><br/>    @ConfigProperty(name = "queue.url")<br/>    private String queueUrl;<br/><br/>    void onStart(@Observes StartupEvent ev) {<br/>        log.info("onStart : "+ev);<br/>        scheduler.submit(this);<br/>    }<br/><br/>    void onStop(@Observes ShutdownEvent ev) {<br/>        log.info("onStop : "+ev);<br/>        scheduler.shutdown();<br/>    }<br/><br/>    @Override<br/>    public void run() {<br/>        log.info("running listener");<br/>        while(true) {<br/>            List&lt;Message&gt; messages = sqsClient.receiveMessage(m -&gt; m.maxNumberOfMessages(1).queueUrl(queueUrl)).messages();<br/>            messages.stream().map(s -&gt; {<br/>                try {<br/>                    String messageBody = s.body();<br/>                    MessageModel m = toModel(messageBody);<br/>                    sqsClient.deleteMessage(d -&gt; d.queueUrl(queueUrl).receiptHandle(s.receiptHandle()));<br/>                    return m;<br/>                } catch (JsonProcessingException e) {<br/>                    e.printStackTrace();<br/>                    return null;<br/>                }<br/>            }).collect(Collectors.<em class="np">toList</em>());<br/>        }<br/>    }<br/><br/>    private MessageModel toModel(String s) throws JsonProcessingException {<br/>        log.info("message to be parsed : "+s);<br/>        MessageModel  m = <em class="np">MESSAGE_READER</em>.readValue(s);<br/>        return m;<br/>    }<br/>}</span></pre><p id="5f14" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated"><em class="np">理想情况下，我们不应该使用无限循环，但为了简单起见，我们将在这里使用它。</em></p><p id="d6be" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">我们应该在我们的<em class="np"> application.properties </em>文件中添加以下配置:</p><pre class="mr ms mt mu gt nu nv nw nx aw ny bi"><span id="f97f" class="md kd iq nv b gy nz oa l ob oc">quarkus.sqs.aws.region=us-east-1<br/>quarkus.sqs.aws.credentials.type=static<br/>quarkus.sqs.aws.credentials.static-provider.access-key-id=${ACCESSKEYID}<br/>quarkus.sqs.aws.credentials.static-provider.secret-access-key=${ACCESSKEY}<br/><br/>queue.url=${QUEUE}</span></pre><p id="ea87" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">现在，让我们创建一个本地映像。</p><p id="1bc0" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">使用以下命令创建本机版本</p><pre class="mr ms mt mu gt nu nv nw nx aw ny bi"><span id="b1d3" class="md kd iq nv b gy nz oa l ob oc">./gradlew build -Dquarkus.package.type=native -Dquarkus.native.container-build=true</span></pre><p id="2e69" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">使用以下命令创建 docker 映像(用您的映像名称替换 Docker 映像名称)</p><pre class="mr ms mt mu gt nu nv nw nx aw ny bi"><span id="622e" class="md kd iq nv b gy nz oa l ob oc">docker build -f src/main/docker/Dockerfile.native -t &lt;&lt;docker_image_name&gt;&gt; .</span></pre><p id="36e1" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">我们可以在 docker 容器上部署此映像，并使用以下命令验证一次(根据您的帐户详细信息更新值):</p><pre class="mr ms mt mu gt nu nv nw nx aw ny bi"><span id="72a7" class="md kd iq nv b gy nz oa l ob oc">docker run -i --rm -p 8080:8080 -e ACCESSKEYID=&lt;&lt;AWS_ACCESS_KEY_ID&gt;&gt; -e ACCESSKEY=&lt;&lt;AWS_ACCESS_KEY&gt;&gt; -e QUEUE=&lt;&lt;QUEUE_URL&gt;&gt; &lt;&lt;docker_image_name&gt;&gt;</span></pre><p id="902b" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">现在使用下面的命令将消息发送到您的队列，然后它将由您的应用程序自动处理:</p><pre class="mr ms mt mu gt nu nv nw nx aw ny bi"><span id="501c" class="md kd iq nv b gy nz oa l ob oc">aws2 sqs send-message --queue-url &lt;&lt;QUEUE_URL&gt;&gt; --message-body '{"messageId":4,"messageText":"Hello From CLI - 4"}'</span></pre><p id="53e1" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">您的应用程序应该生成如下所示的日志:</p><figure class="mr ms mt mu gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi od"><img src="../Images/b6d0ef0acb8ada2f3a3d02bb75b37f8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_irpQHtDF7Z_f19jvjilBw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">Docker 容器应用程序日志</figcaption></figure><p id="715d" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">我们可以看到，应用程序启动只花了 65 毫秒，它还记录了我们使用 aws cli 命令发送到队列的消息。</p><p id="5201" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">我们应该使用以下命令将该图像推送到我们的 docker 存储库:</p><pre class="mr ms mt mu gt nu nv nw nx aw ny bi"><span id="7d7e" class="md kd iq nv b gy nz oa l ob oc">docker login<br/>docker push &lt;&lt;docker_image_name&gt;&gt;</span></pre><h2 id="501d" class="md kd iq bd ke me mf dn ki mg mh dp km ll mi mj kq lp mk ml ku lt mm mn ky mo bi translated">Kubernetes 上的部署</h2><p id="d37b" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">现在让我们在 Kubernetes 集群上添加部署我们的应用程序。为了在 Kubernetes 上部署我们的应用程序，我们现在将创建以下文件:</p><p id="bb88" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">1.)deployment.yaml:这个文件将帮助我们创建应用程序的部署。</p><pre class="mr ms mt mu gt nu nv nw nx aw ny bi"><span id="7161" class="md kd iq nv b gy nz oa l ob oc">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  creationTimestamp: null<br/>  labels:<br/>    app: keda-sqs-example<br/>  name: keda-sqs-example<br/>spec:<br/>  replicas: 1<br/>  selector:<br/>    matchLabels:<br/>      app: keda-sqs-example<br/>  strategy: {}<br/>  template:<br/>    metadata:<br/>      creationTimestamp: null<br/>      labels:<br/>        app: keda-sqs-example<br/>    spec:<br/>      containers:<br/>      - image: nik0112/keda-sqs-example<br/>        name: keda-sqs-example-jvm<br/>        resources: {}<br/>        env:<br/>        - name: QUEUE<br/>          value: &lt;&lt;QUEUE_NAME&gt;&gt;<br/>        - name: QUEUEHOST<br/>          value: https://queue.amazonaws.com<br/>        - name: ACCESSKEYID<br/>          value: &lt;&lt;AWS_ACCESS_KEY_ID&gt;&gt;<br/>        - name: ACCESSKEY<br/>          value: &lt;&lt;AWS_ACCESS_KEY&gt;&gt;<br/>status: {}</span></pre><p id="1371" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">2.)service.yaml:这个文件将用于在 K8s 中创建服务层，在这个例子中我们将使用 NodePort。</p><pre class="mr ms mt mu gt nu nv nw nx aw ny bi"><span id="e2ae" class="md kd iq nv b gy nz oa l ob oc">apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  creationTimestamp: null<br/>  labels:<br/>    app: keda-sqs-example<br/>  name: keda-sqs-example<br/>spec:<br/>  ports:<br/>  - name: 8080-8080<br/>    port: 8080<br/>    protocol: TCP<br/>    targetPort: 8080<br/>  selector:<br/>    app: keda-sqs-example<br/>  type: NodePort<br/>status:<br/>  loadBalancer: {}</span></pre><p id="4deb" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">3.)secrets.yaml:我们将使用这个文件来存储我们的应用程序机密(在本例中是 aws 凭证)</p><pre class="mr ms mt mu gt nu nv nw nx aw ny bi"><span id="b585" class="md kd iq nv b gy nz oa l ob oc">apiVersion: v1<br/>kind: Secret<br/>metadata:<br/>  name: aws-localstack-secrets<br/>  namespace: default<br/>data:<br/>  AWS_ACCESS_KEY_ID: &lt;&lt;BASE64_ENCODED_AWS_ACCESS_KEY_ID&gt;&gt;<br/>  AWS_SECRET_ACCESS_KEY: &lt;&lt;BASE64_ENCODED_AWS_ACCESS_KEY&gt;&gt;</span></pre><p id="d8e3" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">4.)auth.yaml:这是 KEDA 特有的 CRD。我们将使用这个文件在 aws 上使用我们的秘密进行身份验证。</p><pre class="mr ms mt mu gt nu nv nw nx aw ny bi"><span id="4935" class="md kd iq nv b gy nz oa l ob oc">apiVersion: keda.sh/v1alpha1<br/>kind: TriggerAuthentication<br/>metadata:<br/>  name: localstack-auth<br/>  namespace: default<br/>spec:<br/>  secretTargetRef:<br/>    - parameter: awsAccessKeyID<em class="np"><br/>      </em>name: aws-localstack-secrets<em class="np"><br/>      </em>key: AWS_ACCESS_KEY_ID<em class="np"><br/>    </em>- parameter: awsSecretAccessKey<em class="np"><br/>      </em>name: aws-localstack-secrets<em class="np"><br/>      </em>key: AWS_SECRET_ACCESS_KEY</span></pre><p id="e50d" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">5.)scaler.yaml:这也是 KEDA 特有的 CRD。这将用于扩展我们的应用程序。</p><pre class="mr ms mt mu gt nu nv nw nx aw ny bi"><span id="0a6b" class="md kd iq nv b gy nz oa l ob oc">apiVersion: keda.sh/v1alpha1<br/>kind: ScaledObject<br/>metadata:<br/>  name: keda-sqs-example-scaler<br/>  namespace: default<br/>spec:<br/>  scaleTargetRef:<br/>    name: keda-sqs-example<br/>    envSourceContainerName: keda-sqs-example-jvm<br/>  pollingInterval: 30<br/>  cooldownPeriod:  30  <em class="np"># Default: 300 seconds<br/>  </em>minReplicaCount: 0<br/>  maxReplicaCount: 2<br/>  triggers:<br/>    - type: aws-sqs-queue<br/>      metadata:<br/>        queueURL: &lt;&lt;QUEUE_URL&gt;&gt;<br/>        queueLength: "1"  <em class="np"># Default: "5"<br/>        </em>awsRegion: "us-east-1"<br/>        identityOwner: pod<br/>      authenticationRef:<br/>        name: localstack-auth<br/>        kind: TriggerAuthentication</span></pre><p id="0ca6" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">我们现在应该使用以下命令在 Kubernetes 集群上部署我们的应用程序(我使用我的本地机器集群，您也可以使用相同的命令):</p><pre class="mr ms mt mu gt nu nv nw nx aw ny bi"><span id="565b" class="md kd iq nv b gy nz oa l ob oc">kubectl apply -f deploy/deployment.yaml</span><span id="7c5a" class="md kd iq nv b gy oe oa l ob oc">kubectl apply -f deploy/service.yaml</span><span id="2dd3" class="md kd iq nv b gy oe oa l ob oc">kubectl apply -f deploy/secrets.yaml</span><span id="8c75" class="md kd iq nv b gy oe oa l ob oc">kubectl apply -f deploy/auth.yaml</span><span id="443d" class="md kd iq nv b gy oe oa l ob oc">kubectl apply -f deploy/scaler.yaml</span></pre><p id="80b9" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">请以同样的顺序执行上述命令。现在，让我们使用以下命令来验证我们的部署:</p><pre class="mr ms mt mu gt nu nv nw nx aw ny bi"><span id="c05b" class="md kd iq nv b gy nz oa l ob oc">kubectl get all</span></pre><p id="a3b5" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">您应该得到类似的输出，如下所示:</p><figure class="mr ms mt mu gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi of"><img src="../Images/8fe93c34b65811e5a04a1f8598daf2f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sEqOyDUwo7gio6FT8Dl7hg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">kubectl 获取全部输出</figcaption></figure><p id="1bf7" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">我们可以看到，我们没有为我们的应用程序运行任何 pods，这是因为我们的队列中没有任何消息，所以它被缩放为 0。<br/>现在，让我们使用之前使用的相同 aws cli 命令发送几条消息:</p><pre class="mr ms mt mu gt nu nv nw nx aw ny bi"><span id="9f80" class="md kd iq nv b gy nz oa l ob oc">aws2 sqs send-message --queue-url &lt;&lt;QUEUE_URL&gt;&gt; --message-body '{"messageId":1,"messageText":"Hello From CLI - 1"}'</span><span id="b75c" class="md kd iq nv b gy oe oa l ob oc">aws2 sqs send-message --queue-url &lt;&lt;QUEUE_URL&gt;&gt; --message-body '{"messageId":2,"messageText":"Hello From CLI - 2"}'</span><span id="2524" class="md kd iq nv b gy oe oa l ob oc">aws2 sqs send-message --queue-url &lt;&lt;QUEUE_URL&gt;&gt; --message-body '{"messageId":3,"messageText":"Hello From CLI - 3"}'</span><span id="27dc" class="md kd iq nv b gy oe oa l ob oc">aws2 sqs send-message --queue-url &lt;&lt;QUEUE_URL&gt;&gt; --message-body '{"messageId":4,"messageText":"Hello From CLI - 4"}'</span></pre><p id="82bc" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">现在，当我们运行相同的命令来获取群集的所有详细信息时，我们可以看到应用程序的 1 个 pod 正在运行。一旦消息被处理，它将自动缩放到 0。</p><figure class="mr ms mt mu gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi og"><img src="../Images/92fd46a13ac4d37ecf9abd3788ae9ccb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FKcIQTx62qtWrGUfubZKeA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">kubectl get all —用一个应用程序单元</figcaption></figure><p id="9dcb" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">我们可以使用下面的命令来查看 pod 日志，我们应该验证消息是否被处理。</p><pre class="mr ms mt mu gt nu nv nw nx aw ny bi"><span id="e179" class="md kd iq nv b gy nz oa l ob oc">kubectl logs &lt;&lt;pod_name&gt;&gt;</span></pre><p id="3de5" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">它应该看起来像这样:</p><figure class="mr ms mt mu gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oh"><img src="../Images/390919efa5fcf2842f5887c0394ffa18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PZBdBUZV3tI5jGAJ8IxDTA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">应用程序日志— kubectl 日志输出</figcaption></figure><p id="ce15" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">我们可以看到，所有四条消息都已处理，之后窗格自动调整为 0。</p><p id="c705" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">我们应该使用以下命令从 Kubernetes 集群中清除部署:</p><pre class="mr ms mt mu gt nu nv nw nx aw ny bi"><span id="b491" class="md kd iq nv b gy nz oa l ob oc">kubectl delete -f deploy/scaler.yaml</span><span id="db7a" class="md kd iq nv b gy oe oa l ob oc">kubectl delete -f deploy/auth.yaml</span><span id="a5e5" class="md kd iq nv b gy oe oa l ob oc">kubectl delete -f deploy/secrets.yaml</span><span id="f5f5" class="md kd iq nv b gy oe oa l ob oc">kubectl delete -f deploy/service.yaml</span><span id="6903" class="md kd iq nv b gy oe oa l ob oc">kubectl delete -f deploy/deployment.yaml</span></pre><p id="be87" class="pw-post-body-paragraph la lb iq lc b ld ly lf lg lh lz lj lk ll ma ln lo lp mb lr ls lt mc lv lw lx ij bi translated">它将删除我们在本例中创建的所有资源。我们还可以删除 docker 图像和 SQS 队列，我会把这个留给你。</p><h1 id="4299" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">结论</h1><p id="2b2e" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">我们刚刚在 Kubernetes 上完成了一个 Quarkus 本地应用程序的端到端开发和部署，并使用 KEDA 来根据事件扩展我们的应用程序。此外，当我们不使用应用程序时，我们将其缩放至 0。在我们的软件工程和架构中，这是一个非常有用的特性。我们可以利用这一点，只使用我们实际使用的资源，并根据事件进行扩展/缩小。在某种程度上，我们可以说，我们不需要管理我们的应用程序的基础设施，它是由 KEDA 和 Kubernetes 管理。<br/>我们还可以看到，应用启动时间以毫秒计，因此它对于低延迟系统也很有用。<br/>你可以在这里的<a class="ae mp" href="https://github.com/kumarprabhashanand/keda-sqs-example" rel="noopener ugc nofollow" target="_blank">这个 github 仓库里找到这个例子的代码。</a></p></div></div>    
</body>
</html>