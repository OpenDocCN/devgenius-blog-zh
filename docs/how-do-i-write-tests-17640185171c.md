# 我如何编写测试？

> 原文：<https://blog.devgenius.io/how-do-i-write-tests-17640185171c?source=collection_archive---------8----------------------->

学会编码后开始写测试。如何向从未编写过测试的人解释如何去做？。我将尝试解释我的方法。

![](img/5b5abb7d3a9e95534ff88aa91932ad63.png)

首先，也许我必须解释为什么我要写测试。原因有很多，但最简单的一个是确保我的代码做我们想要的。
基于这个原因，我将重点测试公众行为，而不是内部的事情。
因此，我必须测试我的公共 API，根据测试的级别，这可能意味着我的类中的公共方法、我的模块或层中公开的代码、我的服务的端点、我的 UI 中的组件等。

## 机械师

我做 TDD，TDD 的第一阶段是思考。所以我开始思考我想要达到的目标，阅读用户故事，接受标准，和其他人交流。一旦这一点或多或少清楚了，我通常会尝试破解我当前的代码库(如果我清楚如何解决问题，这个阶段并不总是需要的)。
在这个阶段只有一个规则“**我不能提交任何代码”**，我只是在玩它，没有别的。这一阶段的目标是试图理解我应该在哪里、在什么级别引入我的变更，并对这样做的后果有一个概念。我想知道这两个问题的答案:

*   我应该在哪里介绍我的变化？
*   添加更改会有多困难？

我更喜欢在开发过程中发现解决方案，所以黑客阶段应该不会很耗时(几分钟，也许不到半小时)。正是我需要对这两个问题有一个初步答案的时候。有时候，当我破解代码库时，我发现自己陷入了一个兔子洞，所以我通常会放弃这种方法，尝试另一种方法。这只是对要做什么有一个高层次的想法。

## 命名您的行为

然后，我开始思考我要创建的第一个行为，以及该行为的更简单的情况。考虑到这一点，我创建了为该行为编写测试所需的内容(测试类，或者测试文件)，然后我为该测试编写了一个名称。测试的**名称很重要，因为它将用于理解代码在特定情况下做什么。
在 Java 中，由于语言的特性，我看到很多人都遵循这种格式:**

*   shouldDoXXXWhenYYY

当我们需要在 Java 等语言中测试同一个类的几个公共方法时，我们通常会这样做，因为我们使用同一个类文件。我倾向于避免这种情况，除非有必要，如果我在测试一个行为，我并不真的需要 shouldDoXXXWhen 部分，只需要 YYY(场景)，因为其余的在测试或设置中有解释。

## 测试机构

为了解释场景和测试本身，我喜欢在测试中有三个不同的部分，明确定义，这是因为我遵循了[安排行为断言模式](https://www.thoughtworks.com/en-gb/insights/blog/write-better-tests-5-steps)。

*   安排—设置测试对象并为测试准备先决条件。
*   act——执行测试的实际工作，使用在“安排”阶段设置的正确参数调用行为。
*   断言—验证结果。

但是我通常是自下而上开始的。

## 维护

从“断言”开始的原因之一是因为它迫使我思考场景的结果，这是测试最重要的部分，**在我的测试**中描述的特定场景中，我们想要实现什么**。**

似乎我们正在做与我们应该做的相反的事情，我们已经学会了编写一直编译的代码，所以我们很难在我们的 IDE 中看到红色类或对尚未创建的变量的引用。
但是现在 IDE 可以帮助我们创建很多东西，而不是手工创建一个类，你可以发明一个名字，并向你的编辑器寻求帮助来创建所需的样板文件。快捷方式是至关重要的，用它们来创建你的类，函数，变量，你会获得很大的速度。这样，写代码的速度会提高很多。

## 行动

在这个阶段，我可以决定如何成为我行为的公共接口，我正在用我的代码设计我的客户的体验。
与断言阶段一样，设置我的对象、参数或事物所需的一切都将被延迟到下一个阶段，即“安排”。
**一个测试应该只有一个失败的原因，**这就是只有一个动作的原因，在测试中只执行一次函数或方法。有时候这是不可能的，但是我会强迫自己在一次考试中只有一个失败的原因。

## 安排

这是为了创建执行行为的上下文，如果我有对象，如何实例化我的对象，或者哪些将是我的参数值。在这一阶段，我们将集中精力正确设置“shouldDoXXXWhenYYY”中的 YYY 场景。

## 测试反馈

有时当我编写测试时，我会在现有的类或函数中添加行为。在这些情况下，也许我没有意识到我的代码中存在的问题，因为它不是那么明显，但是我试图倾听我的测试的反馈，以[触发对我的代码](/things-to-trigger-a-change-in-your-software-design-36a2f04953bd?sk=b58ee28a1041c81ca7b2cda866647baf)的重构。

我的测试反馈的一些例子:

*   为了创建一个测试场景，我必须创建几个复杂的类以及它们之间的交互。也许这种设置需要在被测试的类/模块内部完成，也许我可以简化这种体验。
*   在我的测试中有多个断言，通常意味着我在测试的行为中有太多的责任。也许我不得不拆分所有被测试行为所做的事情。
*   大的[数据块](https://martinfowler.com/bliki/DataClump.html)有许多要创建的空值。对我来说，这意味着我没有遵守接口分离原则。[也许这个数据块与许多其他行为紧密相关，也许我没有遵循德米特里定律。](https://technology.lastminute.com/interface-segregation/)
*   测试的爆炸，如果我正在测试一个方法或者一个功能，并且我需要很多测试，其中一些测试关注方法的不同方面，那么我的方法可能没有遵守单一责任原则。合作者可以帮助(另一个负责产生测试爆炸的子行为的实体)，独立地测试它，并在第一个中使用测试替身，这将解决测试爆炸。
*   构造函数中的空值，如果我需要创建一个有空值的类，因为一些合作者没有被使用，也许你的类内聚性很低，这是需要创建一个新类的另一个症状。这就是为什么我喜欢在测试中使用空值作为虚拟值，用于不使用的东西(来标记测试所需的真实数据)。

## 测试双打

我使用测试替身来降低我的测试的复杂性，它们在编写测试时帮助我识别我的主类(包含被测试行为的那个)的合作者。

就像在电影中，在危险的场景中寻找主角的替身一样，当我们编写测试来消除不想要的效果时，就会使用替身。
测试替身将会表现出真实实体应该表现出的行为，但是仅仅是我们正在测试的行为。其他一切对我们来说都不重要。测试替身可以在任何种类的自动测试中使用(它们不仅仅用于[单元测试](/unit-tests-c70618dc1e25?sk=de16c7a7bec6fa068728441e55365c97))。

当我理解一个功能超出了我正在构建的实体的限制(例如，它与我正在创建的层无关)时，我使用双重测试，我创建一个接口并为它生成一个双重测试。

测试替身的类型:

*   Dummy:这些用于实现方法的签名，但实际上我们的功能并不依赖于它们，它们没有被使用，或者它们被用于检索它们包含的一些属性。最简单的例子是，当我们在一个特定的场景中测试一个功能时，如果我们的语言允许，我们可以在那里传递空值(https://blog.thecodewhisperer.com/permalink/null-design-工具)
*   Fakes:它们是真实对象的更简单的替代实现，但是它们还没有准备好投入生产，因为它们不满足我们系统的一些非功能性需求，例如内存数据库。Fakes 对于测试基础设施非常有趣，控制器需要一个 http 服务来验证它是否真的在监听，但它不一定是一个完整的服务器。
*   存根:它们是对某些问题有预编程答案的实体。
*   spyes:spyes 是真实实体或存根上的代理，允许验证它们是用一些参数调用的。当不容易覆盖一个真正的实现时，Spyes 会很有用，但是我们希望检查它是否以某种方式被调用。
*   模拟:它们类似于存根，但是它们允许您验证它们在测试中是用正确的参数调用的。在某种程度上，模拟验证了要测试的服务相对于其合作者的行为。模拟允许我们严格控制我们期望发生的关于测试替身的行为，它们将如何被调用以及使用什么参数。我发现它们对于检查命令执行非常有用，因为我不关心返回的响应，void 方法。

[https://martinfowler.com/bliki/TestDouble.html](https://martinfowler.com/bliki/TestDouble.html)

**最后要做的事情是重复整个过程，我们应该对每个案例重复我们脑海中的每个行为。**