# 时间复杂性、空间复杂性和大 O 符号

> 原文：<https://blog.devgenius.io/time-complexity-space-complexity-and-big-o-notation-500d6104f727?source=collection_archive---------4----------------------->

![](img/28a553aa6c5fb6e3665ac42062ca9123.png)

这是我的数据结构和算法系列的第一篇文章。作为一名新兵训练营的毕业生，我发现一旦我开始了软件开发的职业生涯，我的基础知识就会出现缺口。虽然我不是日复一日地颠倒二叉树，但我确实认为学习这些基础知识很重要，因为知道它们的存在，你将成为更好的开发人员。本周，我首先讨论时间和空间的复杂性，以及如何使用大 O 符号来确定这些度量。

# 时间复杂度

> 算法完成所需的计算时间的度量单位

是什么导致了时间复杂性？

*   操作(`+`、`-`、`*`、`/`)
*   比较(`>`、`<`、`==`)
*   循环(`for`，`while`)
*   外部函数调用(`function()`)

# 大 O 符号

> 我们用来谈论算法运行所需时间的语言和度量

## O(1)常数时间

> 不受输入大小的限制，只执行一次操作

*   直接查询您正在寻找的数据
*   不涉及迭代(循环)

如果您知道想要从对象`{}`或数组`[]`中提取的数据的精确位置，您可以查询该项，而不必迭代或执行任何额外的计算。

大多数时候，如果你使用*常数时间*，从性能的角度来看，你处于良好的状态。

让我给你看一个例子，在这个例子中，我执行的任务评估为*常数时间*:

首先，我使用`const`关键字声明一个带有标识符`jedi`的新变量，并给这个变量一个`string`值的集合

接下来，我使用关键字`function`创建一个新函数，并给它一个标识符`findAJedi`。该函数将有一个标识符为`jediList`的参数

使用括号符号`[]`我取出索引位置`1`中的条目

因为我们已经知道我们想要的数据在哪里，并且我们不必循环到达那里，这个操作是`O(1)`或*常数时间*

我们用变量`jediList`作为单个参数调用`findAJedi`函数，我们的`findAJedi`函数打印`anakin`。他是被选中的人，对吗？

## O(n)线性时间

> 受输入的约束，时间随着输入的增加而线性增加

*   涉及到寻找一个值的迭代(`for`或`while`循环)

让我给你看一个运算结果为`O(n)`或*线性时间*的例子:

首先，我们使用`const`关键字创建一个标识符为`jedi`的新变量，该变量被赋予一个`Array`的值。我们使用`fill()`方法用类型为`string`的五个`luke`值填充这个`Array`

接下来，我们使用关键字`function`创建一个带有标识符`findLuke`的新函数。该函数将有一个标识符为`jediList`的参数

在我们的`findLuke`函数中，使用`for`关键字创建一个`for`循环。我们遍历我们的`jediList`并使用括号符号`[]`来比较每个条目和`luke`，当我们找到一个匹配时，我们`console.log`它

因为我们正在遍历整个`Array`，所以我们的大 O 应该是`O(n)`。现在我们的`jediList`只有五个条目，但是如果我们有 10，000 个，或者 10 亿个条目呢？当您编写代码时，这些都是很好的考虑因素。

我们调用带有单个参数的函数`findLuke``jedi`,因为我们所有的条目都是`luke`,所以我们调用了`console.log` `luke`五次

## O(n)次时间

> 经常被认为是“最坏的情况”,会发生多次嵌套迭代

*   涉及两个嵌套循环
*   两个集合中的每一项都需要相互比较

我肯定你以前来过这里，我知道我肯定来过。嵌套循环从来都不是一个好主意，这是有充分理由的。就大 O 而言，当你迭代一个集合，然后在第一次迭代中再次迭代，这将产生一个大 O 的`O(n²)`

让我给你看一个产生一个大 O 的函数的例子:

首先，我们使用`const`关键字创建一个新变量，它的标识符`jedi`被分配给一个包含三个`string`值的`Array`

接下来，我们使用`function`关键字创建一个标识符为`logJediDuos`的新函数。该功能只有一个参数`jediList`

在`logJediDuos`内部，我们使用`for`关键字来创建我们的第一个`for`循环。在我们的`for statement`中，我们声明我们想要遍历`jediList`的长度，直到该长度大于`i`的值。我们在每次迭代后增加`i`的值

在前一个`for`循环中，我们创建了另一个`for`循环。在我们的`for`语句中，我们确保给索引变量一个标识符`j`，以确保我们不会改变`i`变量的状态。

使用括号符号`[]`我们使用索引变量`i`和`j`到`console.log`中的每一对

当我们调用我们的`logJediDuos`函数时，我们得到这个结果:

在这篇文章中，我只涉及了少数常见的大 O 时代。如果您想了解更多关于高级 Big O times 的信息，您可以通过下面提供的链接进行了解:

## O(n！)阶乘时间

> 为每个循环添加一个嵌套循环

[在这里阅读更多内容](https://en.wikipedia.org/wiki/Time_complexity#Factorial_time)

## O(log N)对数

> 涉及搜索算法(如果已排序)

[在这里阅读更多内容](https://en.wikipedia.org/wiki/Time_complexity#Logarithmic_time)

## O(2^N)指数

> 解决大小为 N 的问题的递归算法

[在这里阅读更多](https://en.wikipedia.org/wiki/Time_complexity#Exponential_time)

# 简化大 O

*   总是假设最坏的情况
*   移除常数
*   输入的不同术语
*   丢弃非支配者

## 总是假设最坏的情况

在程序中迭代数据列表是一种非常常见的做法，列表的大小可能会有很大的不同。当我对*说总是假设最坏的情况*时，我指的是在几个不同的方面。

*   如果查询数据，假设它是列表中的最后一项
*   假设你迭代的列表会变大
*   假设一些机器运行你的算法比你的机器慢

## 移除常数

当我们确定一个算法的大 O 时，它有助于去除重复的测量(常数)。这允许我们通过移除不必要的计算来更清楚地读取算法的速度。

让我给你看一个移除常数的例子:

首先，我们用标识符`printJedi`创建一个新的`function`，这个函数只有一个参数(`jediList`

在我们的`printJedi`函数中，我们在`jediList`调用了两次`forEach()`方法

因为我们正在遍历整个`jediList`数组，所以每个操作都是`O(n)`。在函数的最后，我们将大 O ( `O(n) + O(n)`)相加，得到`O(2n)`。我们可以通过*移除常量*来简化这一点，在本例中常量为`2`。这之后就剩下`O(n)`的大 O 了。

## 输入的不同术语

在迭代不同数据的情况下，大 O 计算将反映这一点。由于每个数据集合很可能大小不同，因此需要考虑其时间复杂性。

让我向您展示一个在使用多个数据集合时计算大 O 的示例:

上面，我们用标识符`printJediAndSith`创建了一个新的`function`，这个函数有两个参数:`jediList`和`sithList`

在`printJediAndSith`内部，我们在`jediList`数组和`sithList`数组上调用`forEach()`方法

现在，你认为大 O 的功能是什么？因为我们迭代一个数据集合，它应该是`O(n)`，对吗？在这种情况下不行。

请记住，这些参数可能有不同的长度。正因为如此，我们将【T2 大 O】确定为`O(a + b)`。

## 丢弃非支配者

在函数内部，会发生很多不同的事情。这也包括时间复杂度的范围。在确定算法的大 O 时，为了简化起见，通常的做法是*丢弃非支配*。简而言之，这意味着从您的大 O 计算中移除或*删除*任何更小的时间复杂度项目。

让我给你看一个*丢弃非支配者*的例子:

首先，我们用标识符`printAndSumJediAttendance`创建一个新的`function`，这个函数有一个参数`jediList`

在`printAndSumJediAttendance`内部，我们对`jediList`参数调用`forEach()`方法。因为我们正在迭代一个数据集合，这个大 O 评估为`O(n)`。

在下一行，我们在`jediList`参数上调用`forEach()`方法。在这个`forEach`块里面，我们又在`jediList`上调用`forEach`。因为我们是在嵌套循环中迭代，所以我们的大 O 评估为`O(n²)`

让我把这个大 O 的计算分解一下:

如您所见，如果我们将该函数的大 O 计算相加，得到的结果为`O(n + n²)`。

如果我们对此进行分析，我们会发现我们计算中最大大 O 的部分是`n²`——正因为如此，我们放弃了`n`。我们这样做是因为`n²`比`n`更*_ 优势 _* 。一旦我们重构了我们的计算，我们会得到这个结果:`O(n²)`。

# 空间复杂性

> 与时间复杂度平行，空间复杂度是对算法所需内存(空间)的度量

## 什么导致了空间的复杂性？

*   变量
*   数据结构
*   函数调用
*   分配

让我向您展示一个计算空间复杂性的示例:

首先，我们用标识符`buildALightsaber`创建一个新的`function`，它只有一个参数`pieces`

在`buildALightsaber`内部，我们使用`let`关键字创建一个新变量，它的标识符`totalPieces`被赋给值`0`。在下面一行，我们将变量`totalPieces`重新赋值给`4`的值

创建并赋值给变量是`O(n)`(常数时间)；因此，这两步都是`O(1)`

接下来，我们创建一个`for`循环并遍历`pieces`

因为我们将遍历一个数据集合，所以这个操作的大 O 将计算为`O(n)`

在我们的`for`循环内部，我们调用一个带有标识符`addCrystals()`的函数。接下来，我们使用`const`关键字创建一个标识符为`hasTheForce`的变量，并给它赋值`true`。最后，我们将`totalPieces`加 1。

当在一次迭代(`for`或`while`循环)中调用函数、创建变量和更新变量值时，就评估空间复杂性而言，您必须注意这些操作将在每次迭代中发生。正因为如此，*提到的所有*动作都将是`O(n)`

在我们完成对`pieces`的迭代后，我们返回`totalPieces`的值

由于这是单个动作，大 O 被评估为`O(1)`或*常量时间*

如果我们计算这个函数的大 O，我们最初得到`(3 + 4n)`。在我们应用简化大 O 的原则后，我们知道我们可以*移除常数*，这将得到我们的最终结果`O(n)`

# 概括起来

我希望读完这篇文章后，你对时间和空间的复杂性是如何工作的，它们在我们编写的函数/算法中的重要性，以及我们如何使用大 O 符号计算这些复杂性有一个固定的想法。

下周，我将开始深入探讨 JavaScript 开发人员使用的最流行的数据结构——数组。到时候见！