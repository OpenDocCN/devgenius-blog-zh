<html>
<head>
<title>How to Add Authentication to a React App</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何向 React 应用程序添加身份验证</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-to-add-authentication-to-a-react-app-26865ecaca4b?source=collection_archive---------0-----------------------#2022-05-03">https://blog.devgenius.io/how-to-add-authentication-to-a-react-app-26865ecaca4b?source=collection_archive---------0-----------------------#2022-05-03</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="98a0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">了解 React 应用程序中身份验证的工作方式</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c0b5aa85b59a235e4dfb91021c0063ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*odRvt0lHkkjr0_oB"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@flyd2069?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">飞:D </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></figcaption></figure><p id="91ad" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">安全性是应用程序的重要组成部分。当开发一个应用程序时，你不希望未经授权/未经认证的人访问你的网站页面。在本文中，我们将讨论如何在 React 应用程序中实现身份验证(登录、注册和注销)</p><h1 id="1010" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">了解 JWT</h1><p id="995d" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">在开始前端部分之前，让我们了解当用户提交登录/注册表单时，后端发生了什么。</p><p id="43c7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在登录请求发送到后端 API 后，我们的凭据得到验证，在成功登录后，我们会收到一个带有用户 ID 和加密令牌的响应，这个令牌就是我们所说的 JSON Web 令牌，通过它我们可以向后端 API 发送请求以访问受保护的路由，然后服务器解密令牌，比较用户 ID 是否有效，并发送一个响应。</p><blockquote class="mc md me"><p id="00bb" class="jk jl mf jm b jn jo jp jq jr js jt ju mg jw jx jy mh ka kb kc mi ke kf kg kh ig bi translated">JWT 中的信息是使用秘密或公共/私人密钥对进行数字签名的。</p></blockquote><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mj"><img src="../Images/52bd7a406df2a4e1d6e94530ba043d9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*90KVN8S9_xbvBuFcrTHBLA.png"/></div></div></figure><p id="63cd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你可以在 https://jwt.io/<a class="ae ky" href="https://jwt.io/" rel="noopener ugc nofollow" target="_blank">的</a>阅读更多关于 JWT 的信息</p><h1 id="c69e" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">基本授权功能</h1><p id="87b2" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">让我们创建一个自定义挂钩，为我们提供用户详细信息和身份验证方法——登录、注册和注销</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="4f8f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">成功登录和注册后，我们会收到一个令牌，然后将它存储在用户对象中。这个令牌稍后将用于头中受保护的 API 请求。</p><p id="92f3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对于数据持久性，添加一个本地存储自定义挂钩</p><pre class="kj kk kl km gt mm mn mo mp aw mq bi"><span id="7ad5" class="mr la in mn b gy ms mt l mu mv">const [user, setUser] = useLocalStorage("user", null);</span></pre><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mk ml l"/></div></figure><h1 id="3da9" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">授权上下文</h1><p id="eff8" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">要使用户在应用程序中全局可用，请添加上下文。我们创建了一个上下文，它使用了上面的定制钩子，并将它包装在根组件周围，以使所有的方法和状态对应用程序全局可用</p><p id="3a94" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果您不知道如何设置上下文，请阅读我以前关于上下文的文章，这篇文章提供了设置上下文的一步一步的方法</p><div class="mw mx gp gr my mz"><a href="https://ashutosh-kumar.medium.com/understand-react-context-with-examples-b66b9161d9de" rel="noopener follow" target="_blank"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd io gy z fp ne fr fs nf fu fw im bi translated">通过例子理解反应上下文</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">使用 React 中的上下文创建地址管理 React 应用程序</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">ashutosh-kumar.medium.com</p></div></div><div class="ni l"><div class="nj l nk nl nm ni nn ks mz"/></div></div></a></div><p id="c797" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">步骤 1: </strong>创建授权上下文</p><pre class="kj kk kl km gt mm mn mo mp aw mq bi"><span id="76ba" class="mr la in mn b gy ms mt l mu mv">const AuthContext = createContext()</span></pre><p id="df5e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">步骤 2: </strong>通过抽象 useContext 钩子来设置消费者</p><pre class="kj kk kl km gt mm mn mo mp aw mq bi"><span id="0af3" class="mr la in mn b gy ms mt l mu mv">const useAuthContext = () =&gt; useContext(AuthContext)</span></pre><p id="61e4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">步骤 3: </strong>使用高阶组件设置提供程序，现在我们使用我们创建的自定义钩子，并将其添加到提供程序中，如下所示</p><pre class="kj kk kl km gt mm mn mo mp aw mq bi"><span id="b508" class="mr la in mn b gy ms mt l mu mv">const AuthProvider = ({children}) =&gt; {</span><span id="b4fc" class="mr la in mn b gy no mt l mu mv">  const auth = useAuth()</span><span id="6c62" class="mr la in mn b gy no mt l mu mv">  return &lt;AuthContext.Provider value={auth}&gt;</span><span id="50e6" class="mr la in mn b gy no mt l mu mv">         {children}</span><span id="4bb8" class="mr la in mn b gy no mt l mu mv">  &lt;/AuthContext.Provider&gt;</span><span id="0a06" class="mr la in mn b gy no mt l mu mv">}</span></pre><p id="6bfc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">步骤 4: </strong>将提供者包装在根组件周围，使其对所有组件都是全局可用的</p><pre class="kj kk kl km gt mm mn mo mp aw mq bi"><span id="531e" class="mr la in mn b gy ms mt l mu mv">&lt;Authprovider&gt;<br/>  &lt;App /&gt;<br/>&lt;/AuthProvider&gt;</span></pre><p id="43ed" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最终的代码将如下所示</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mk ml l"/></div></figure><h1 id="4bd7" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">需要授权组件来保护路由</h1><p id="de56" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">在 Web 应用程序中，路由可以分为两种类型:公共路由和受保护路由，受保护路由需要对用户进行身份验证才能访问，而公共路由不具备任何此类条件</p><p id="1b7d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们如何设置一个条件来检查一个用户是否被认证？</p><p id="fc03" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">它就像放置一个 if 条件并返回组件或重定向到登录一样简单，如下所示</p><pre class="kj kk kl km gt mm mn mo mp aw mq bi"><span id="6acc" class="mr la in mn b gy ms mt l mu mv">const user = AuthContext()</span><span id="bf26" class="mr la in mn b gy no mt l mu mv">if(user){<br/>// Return Component<br/>}<br/>else{<br/>// Navigate to Login<br/>}</span></pre><p id="2bd3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是我不希望将这个条件写在每个需要认证的组件中，因此我使用了一个更高阶的组件——require auth，它将一个组件作为输入，并返回一个受保护的组件</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="0d6e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">例如，有一个用户配置文件组件需要对用户进行身份验证，然后我们如下所示包装该组件:</p><pre class="kj kk kl km gt mm mn mo mp aw mq bi"><span id="ed39" class="mr la in mn b gy ms mt l mu mv">&lt;Route path='/profile' element={&lt;RequireAuth&gt;&lt;UserProfile /&gt;&lt;/RequireAuth&gt;} /&gt;</span></pre><h1 id="cb89" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">登录后重定向</h1><p id="71d1" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">登录后如何重定向用户？在许多网站上，我们看到当一个未经认证的用户试图登录时，我们将他们重定向到登录页面，但是在登录完成后，我们如何重定向回同一页面呢？</p><p id="92ff" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在我们的应用程序中，到目前为止，当一个未经验证的用户试图访问一个受保护的页面时，我们会将他们重定向到登录页面，但在他/她成功登录后，接下来会发生什么呢？</p><p id="6fac" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">还记得我们让 AuthContext 环绕根组件，这使得 AuthContext 中的任何状态更改都会重新呈现整个应用程序组件，因此当用户登录时，用户状态会发生更改，所以我们只需在登录功能中的状态发生更改后将用户导航回来。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mk ml l"/></div></figure><blockquote class="np"><p id="c360" class="nq nr in bd ns nt nu nv nw nx ny kh dk translated">“但是，如果我告诉你我有更好的解决方案，而不是导航到该页面，会怎么样呢”</p></blockquote><p id="0032" class="pw-post-body-paragraph jk jl in jm b jn nz jp jq jr oa jt ju jv ob jx jy jz oc kb kc kd od kf kg kh ig bi translated">首先，我们更新 Require Auth 来存储导航状态下的当前路径，如下所示</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="1bb8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在我们需要一种方法来获取包含路径的状态，这是 react-router-dom 在 useLocation 函数的帮助下完成的。</p><blockquote class="mc md me"><p id="2d62" class="jk jl mf jm b jn jo jp jq jr js jt ju mg jw jx jy mh ka kb kc mi ke kf kg kh ig bi translated">当组件使用更新的用户值重新呈现时，我们使用 Navigate 组件将用户从登录页面重定向到使用 react-router-dom 中的 useLocation 挂钩存储在状态中的路径，如下所示</p></blockquote><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mk ml l"/></div></figure></div><div class="ab cl oe of hr og" role="separator"><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj"/></div><div class="ig ih ii ij ik"><p id="9d7a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> <em class="mf">这就完成了我们 Web App 的认证特性。谢谢你一直读到最后，我希望这篇文章是有帮助的。请关注我，获取更多此类文章！</em> </strong></p><h1 id="2ce0" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">参考</h1><div class="mw mx gp gr my mz"><a href="https://jwt.io/introduction#:~:text=This%20information%20can%20be%20verified,will%20focus%20on%20signed%20tokens" rel="noopener  ugc nofollow" target="_blank"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd io gy z fp ne fr fs nf fu fw im bi translated">JWT。IO - JSON Web 令牌简介</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">新:免费获得 JWT 手册，深入学习 jwt！JSON Web Token (JWT)是一个开放标准(RFC 7519 ),它…</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">jwt.io</p></div></div><div class="ni l"><div class="ol l nk nl nm ni nn ks mz"/></div></div></a></div><div class="mw mx gp gr my mz"><a href="https://usehooks.com/useLocalStorage/" rel="noopener  ugc nofollow" target="_blank"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd io gy z fp ne fr fs nf fu fw im bi translated">使用位置存储</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">将状态同步到本地存储，以便在页面刷新过程中保持状态。用法类似于 useState，除了我们传入…</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">usehooks.com</p></div></div><div class="ni l"><div class="om l nk nl nm ni nn ks mz"/></div></div></a></div></div></div>    
</body>
</html>