<html>
<head>
<title>Memory Management Part 1: Regions, Types and Leaks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">内存管理第1部分:区域、类型和泄漏</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/memory-management-part-1-regions-types-and-leaks-884c231f5135?source=collection_archive---------2-----------------------#2021-06-25">https://blog.devgenius.io/memory-management-part-1-regions-types-and-leaks-884c231f5135?source=collection_archive---------2-----------------------#2021-06-25</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><blockquote class="jk jl jm"><p id="e709" class="jn jo jp jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ig bi translated">这篇文章基于我在柏林和T2的演讲。</p></blockquote><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi kn"><img src="../Images/f06ae3b0fb71f17116e856294f5c900c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*th7UcepA1hcPWlaYKJnjxQ.jpeg"/></div></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">我的儿子“优素福”曾经告诉我，大象能够记住水源几十年。由<a class="ae km" href="https://unsplash.com/@photosbybeks?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">拍摄的照片由<a class="ae km" href="https://unsplash.com/s/photos/elephant?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的Beks </a>拍摄。</figcaption></figure><p id="eb54" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">作为一名移动软件工程师，你应该意识到你的应用程序的内存占用。建议在为您的应用或框架提供修复或新功能之前，检查您的应用内存使用情况。</p><p id="4b9e" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">您应该有意识地避免保留周期和内存泄漏，这是与内存相关的主要问题，会导致不必要的副作用、糟糕的用户体验和崩溃。</p><p id="b979" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">本文将让您了解Swift语言在内存管理方面发生了什么，以及如何调试内存问题，特别是泄漏和保留周期。</p><p id="db2e" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">在本文中，您将了解到:</p><ul class=""><li id="ccae" class="lg lh in jq b jr js jv jw ld li le lj lf lk kl ll lm ln lo bi translated">记忆和为什么它的管理是重要的</li><li id="2b98" class="lg lh in jq b jr lp jv lq ld lr le ls lf lt kl ll lm ln lo bi translated">堆栈和堆内存区域之间的差异</li><li id="9466" class="lg lh in jq b jr lp jv lq ld lr le ls lf lt kl ll lm ln lo bi translated">类和结构生命周期</li><li id="8a84" class="lg lh in jq b jr lp jv lq ld lr le ls lf lt kl ll lm ln lo bi translated">引用计数</li><li id="925e" class="lg lh in jq b jr lp jv lq ld lr le ls lf lt kl ll lm ln lo bi translated">自动引用计数与垃圾收集</li><li id="0a4a" class="lg lh in jq b jr lp jv lq ld lr le ls lf lt kl ll lm ln lo bi translated">商业周期</li><li id="1afe" class="lg lh in jq b jr lp jv lq ld lr le ls lf lt kl ll lm ln lo bi translated">内存泄漏</li></ul><h1 id="00b1" class="lu lv in bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated"><strong class="ak">为什么内存管理很重要？</strong></h1><p id="0be7" class="pw-post-body-paragraph jn jo in jq b jr ms jt ju jv mt jx jy ld mu kb kc le mv kf kg lf mw kj kk kl ig bi translated"><strong class="jq io">软件需要内存访问:</strong> <br/> 1。加载软件的字节码<br/> 2。存储软件的数据值和结构<br/> 3。加载任何软件所需的运行时系统</p><p id="4ca6" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">与硬盘驱动器不同，RAM不是无限的。如果一个程序继续消耗内存而不释放它，最终它会耗尽内存并使自己崩溃，甚至更糟的是使操作系统崩溃。</p><p id="9238" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">因此，大多数编程语言都提供了自动内存管理的方法，而不是让软件开发人员来解决这个问题。</p><h1 id="bd31" class="lu lv in bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated"><strong class="ak">堆栈对堆</strong></h1><p id="505b" class="pw-post-body-paragraph jn jo in jq b jr ms jt ju jv mt jx jy ld mu kb kc le mv kf kg lf mw kj kk kl ig bi translated">任何软件程序都使用两个内存区域，即堆栈和堆。栈和堆在任何程序的执行中都有重要的作用。</p><p id="fd30" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">对它们是什么以及它们如何工作的总体理解将帮助您形象化类和结构之间的功能差异(换句话说，引用语义和值语义)以及您应该如何利用内存使用。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/b5302a3dc162c29483089a43879f096f.png" data-original-src="https://miro.medium.com/v2/resize:fit:520/format:webp/1*-oTwbOMIYEYkGaBWQSMlKw.png"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">堆栈</figcaption></figure><p id="a4d9" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated"><strong class="jq io">堆栈</strong>由CPU组织管理。它用于<strong class="jq io">静态内存分配</strong>，顾名思义，它是一个后进先出堆栈(把它想象成一个煎饼堆栈🥞).</p><p id="cd5d" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">由于这种性质，从堆栈中存储和检索数据的过程非常快<strong class="jq io">因为不需要查找，你只需要从最顶层的块中存储和检索数据。</strong></p><p id="a414" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">多线程应用程序通常每个线程都有一个堆栈。</p><p id="e664" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated"><strong class="jq io">局部变量</strong>(值类型，原始常量)和<strong class="jq io">指针</strong>是系统存储在堆栈上的典型数据。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div class="gh gi my"><img src="../Images/8de2f0615cfd43110b6c0612a0575db1.png" data-original-src="https://miro.medium.com/v2/resize:fit:768/format:webp/1*xfk0p1CK4ko82noo8HQ_lg.png"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">垃圾堆</figcaption></figure><p id="da5e" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">另一方面，堆不组织数据。它只留下四处散落的一切(像一堆红砖🧱).</p><p id="bced" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">堆是一个很大的内存池，系统可以从中请求和动态分配内存块。系统使用<strong class="jq io">堆</strong>来存储引用类型的实例，比如Swift 5.5中的<strong class="jq io">类</strong>、<strong class="jq io">闭包</strong>以及现在的<strong class="jq io">角色</strong>。</p><p id="0bf4" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">堆不会像栈那样自动销毁它的数据；编程语言需要做额外的工作来做到这一点。与在堆栈上相比，这使得在堆上创建和移除数据的过程更慢。</p><p id="939b" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">当我们谈论内存管理时，我们主要谈论的是管理堆内存。</p><p id="d3a7" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">记忆，因为每个人都有良好的关系🥞。</p><h1 id="0292" class="lu lv in bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">类与结构</h1><p id="0b96" class="pw-post-body-paragraph jn jo in jq b jr ms jt ju jv mt jx jy ld mu kb kc le mv kf kg lf mw kj kk kl ig bi translated">在Swift中，class是一个引用类型。一个类类型的变量并不存储一个实际的实例——它使用<strong class="jq io"><em class="jp">assign-by-reference</em></strong>将一个<strong class="jq io">引用</strong>存储到内存中存储实例的位置。</p><p id="eef5" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">而struct是一种值类型，它使用<strong class="jq io"> <em class="jp">通过复制</em> </strong>来存储实际值，并提供对它的直接访问。</p><p id="fc9c" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">让我们使用一个作者类和一个person结构来分解它。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/7a4844f6c8389e66a56f64672cac894f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/1*jj86OYuLnXoL6xBkk21PZw.png"/></div></figure><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi na"><img src="../Images/80f43338db8f8cf87cf4d87c788ce82b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_XS1qfYquRzeq1sn8wqOeQ.png"/></div></div></figure><ol class=""><li id="dd27" class="lg lh in jq b jr js jv jw ld li le lj lf lk kl nb lm ln lo bi translated">一个<strong class="jq io"> person </strong>实例不会引用内存中的某个位置，但其值将只属于person。</li><li id="028d" class="lg lh in jq b jr lp jv lq ld lr le ls lf lt kl nb lm ln lo bi translated">同一个<strong class="jq io">人</strong>的新<strong class="jq io">父</strong>实例将成为<strong class="jq io">副本分配</strong>，并在堆栈中占据一个新位置。</li><li id="7895" class="lg lh in jq b jr lp jv lq ld lr le ls lf lt kl nb lm ln lo bi translated"><strong class="jq io"> author </strong>类的一个实例将在堆中创建一个对象，并将它的地址存储在堆栈中。</li><li id="d822" class="lg lh in jq b jr lp jv lq ld lr le ls lf lt kl nb lm ln lo bi translated">相同auhor实例的新常量<strong class="jq io"> awesomeAuthor </strong>将通过保存相同的地址并指向内存中相同的位置而被<strong class="jq io">按引用分配</strong>。</li></ol><p id="c67b" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated"><strong class="jq io">注意:</strong>值类型不是必需的值语义，那是另一篇文章的另一个主题。但是记住这一点很重要🤔。</p><h1 id="44a6" class="lu lv in bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">引用计数</h1><p id="9daa" class="pw-post-body-paragraph jn jo in jq b jr ms jt ju jv mt jx jy ld mu kb kc le mv kf kg lf mw kj kk kl ig bi translated">到目前为止，我们知道引用类型对象存储在堆中。堆上的对象<em class="jp">不会</em>自动销毁，因为堆有一个动态的本质，更难管理。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi nc"><img src="../Images/a9a22f0dece55124c5e76965d75f23e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KnMR2vBxoiLJJ5O8vT8X_A.png"/></div></div></figure><p id="a940" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">如果没有调用堆栈的作用，进程就无法自动知道一块内存将不再被使用。</p><p id="fed9" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">在Swift中，决定何时清理堆上未使用的对象的机制被称为<strong class="jq io">引用计数</strong>。</p><p id="f311" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">简而言之，<strong class="jq io">引用计数</strong>给<strong class="jq io"> </strong>每个对象一个引用计数，该计数随着引用该对象的每个常量或变量而递增，并随着引用的每次移除而递减。</p><p id="22ad" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">当引用计数达到零时，该对象被放弃，因为系统中没有保存对它的引用。当这种情况发生时，Swift将清理该对象并将该内存标记为空闲。</p><p id="311f" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">让我们使用上面使用的同一个author类来演示这一点:</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi nd"><img src="../Images/12e5461330c6024b885bb2f3c49e9cd6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yBMOXUS_vL3D0V5Uvh8DFA.png"/></div></div></figure><p id="35dc" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">创建<strong class="jq io"> author </strong>的实例会在堆中创建一个引用计数为1的对象，并将其地址保存在堆栈中。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi ne"><img src="../Images/58653077023e896dbd557e6a1ebd7fb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TAC5xoJZO1VPdiciN3uRBw.png"/></div></div></figure><p id="506d" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">为同一个<strong class="jq io"> author </strong>实例创建<strong class="jq io"> anotherAuthor </strong>会将其引用计数增加到2。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi nf"><img src="../Images/b033cd82264962d3a7261526a296fe76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vwEr3rg6Bd0PNOQdGFl2YQ.png"/></div></div></figure><p id="190f" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">创建相同的<strong class="jq io">作者</strong>和<strong class="jq io">另一个作者</strong>实例的<strong class="jq io"> lotsOfAuthor </strong>数组，使其递增到5。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi ng"><img src="../Images/0da834b536f39143da5ee2a2edb883d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JSJkNI-MoN0OYPisi6u3ZA.png"/></div></div></figure><p id="1850" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">丢弃<strong class="jq io">另一个作者</strong>将作者的引用计数减为4。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi nh"><img src="../Images/9e98725f60bb142594e8020fc08fb4a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xXngdhAl2gKPiqWT6Ym7vg.png"/></div></div></figure><p id="3ca7" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">丢弃<strong class="jq io"> lotsOfAuthor </strong>元素，将其递减为1</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi ni"><img src="../Images/ff8189af3854032af2082ef483346d13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yjjCNDo72VM7nXrNPi7KTg.png"/></div></div></figure><p id="f8c8" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">现在！将一个新的<strong class="jq io">作者</strong>对象分配给原始作者变量:</p><ol class=""><li id="70c4" class="lg lh in jq b jr js jv jw ld li le lj lf lk kl nb lm ln lo bi translated">将原始作者对象递减为零</li><li id="14e1" class="lg lh in jq b jr lp jv lq ld lr le ls lf lt kl nb lm ln lo bi translated">将旧的废弃对象的内存块标记为空闲</li><li id="ab17" class="lg lh in jq b jr lp jv lq ld lr le ls lf lt kl nb lm ln lo bi translated">创建引用计数= 1的新author对象</li></ol><p id="db4c" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">在上面的例子中，您不必做任何工作来增加或减少对象的引用计数。那是因为Swift有一个功能叫做<strong class="jq io">自动参考计数</strong>或<strong class="jq io">圆弧</strong>。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi nj"><img src="../Images/462a226a8f797fc8556fa0faa368786d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9M9uRDulliBxwfqFpXnBMw.png"/></div></div></figure><p id="c941" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">虽然一些较老的语言要求您手动增加和减少<em class="jp"> </em>代码中的引用计数，但Swift编译器会在编译时自动添加这些调用。</p><p id="48d6" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated"><strong class="jq io">注</strong>:这种引用计数的原理大多适用于类。因为，当你在代码中传递一个类的实例时，你传递的是一个内存引用，这意味着多个对象指向同一个内存地址。</p><p id="24a7" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">当你传递值类型时，值被复制。这意味着值类型的保留计数通常总是1；永远不会有一个以上的对象指向值类型的内存地址。</p><h1 id="fbad" class="lu lv in bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">ARC与垃圾收集</h1><p id="efb0" class="pw-post-body-paragraph jn jo in jq b jr ms jt ju jv mt jx jy ld mu kb kc le mv kf kg lf mw kj kk kl ig bi translated">如果你使用像C这样的低级语言，你需要手动释放你不再使用的内存。</p><p id="1b4c" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">像Java和C#这样的高级语言使用一种叫做<strong class="jq io">垃圾收集</strong>的东西。在这种情况下，该语言的运行时将在您的进程中搜索对对象的引用，然后清除那些不再使用的对象。</p><p id="5857" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">与GC不同，ARC支持<strong class="jq io">确定性终结</strong>，但不能处理<strong class="jq io">引用周期</strong>。在我看来，一旦你理解了弱引用以及它们是如何打破<strong class="jq io">引用周期</strong>的，ARC就会成为<strong class="jq io">性能</strong>、<strong class="jq io">可预测性</strong>和<strong class="jq io">减少竞争条件</strong>的最佳选择。</p><h2 id="ec1a" class="nk lv in bd lw nl nm dn ma nn no dp me ld np nq mi le nr ns mm lf nt nu mq nv bi translated"><em class="nw">确定性终结</em></h2><ul class=""><li id="5d78" class="lg lh in jq b jr ms jv mt ld nx le ny lf nz kl ll lm ln lo bi translated">在ARC中，当一个对象的引用计数达到零时，Swift在从内存中移除一个对象之前调用<strong class="jq io"> deinitializer。</strong></li><li id="a152" class="lg lh in jq b jr lp jv lq ld lr le ls lf lt kl ll lm ln lo bi translated">就像init是类初始化中的一个特殊方法一样，deinit是处理取消初始化的一个特殊方法。</li><li id="7b83" class="lg lh in jq b jr lp jv lq ld lr le ls lf lt kl ll lm ln lo bi translated">你在反初始化器中做什么取决于你，一个实例直到它的反初始化器被调用后才会被释放。</li></ul><h1 id="d9b2" class="lu lv in bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">商业周期</h1><p id="b3ba" class="pw-post-body-paragraph jn jo in jq b jr ms jt ju jv mt jx jy ld mu kb kc le mv kf kg lf mw kj kk kl ig bi translated">所有这些关于堆、栈、GC、ARC的讨论都是好的，但是现在，您将看到ARC和引用循环在起作用。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi oa"><img src="../Images/41ba15ce892ccd979b126afb59513c9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4vLKC3OZdRiEO-ceRZWG9A.png"/></div></div></figure><p id="e0df" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">我将使用<strong class="jq io">作者</strong>、<strong class="jq io"> b <em class="jp"> ook </em> </strong>和<strong class="jq io">编辑</strong>类来演示一个引用循环。作者和编辑都有他们的书单。并且<strong class="jq io">书</strong>链接到<strong class="jq io">作者</strong>和<strong class="jq io">编辑</strong>。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi ob"><img src="../Images/b0ddb7f059851592d97bbb1cba5bec1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cs2VIXlNUooba73_8dm5dQ.png"/></div></div></figure><p id="44f8" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">创建一个<strong class="jq io">作者</strong>实例<strong class="jq io"> </strong> <em class="jp">穆斯塔法·马哈茂德(</em>一位伟大的埃及医生、哲学家和作家)</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi oc"><img src="../Images/ead7c912c0b9114cab62c5aba5315923.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PxYM0eIX3zFAsdwnzaz1yA.png"/></div></div></figure><p id="f52f" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">一本<strong class="jq io">的书</strong>实例<strong class="jq io"> </strong> <em class="jp">与一位无神论者的对话</em>为<strong class="jq io">作者</strong>(顺便说一句，这本书读起来不错)</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi od"><img src="../Images/4cf085c05cd34c80d3ce7a10429e8370.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k9aPxa8JqbZaBGh5FiJZyA.png"/></div></div></figure><p id="3708" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">一个<strong class="jq io">编辑</strong>实例<strong class="jq io"> </strong> <em class="jp">吴昊。</em></p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi oe"><img src="../Images/90eea70f32e34aaf86857816c680d094.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sDs9khSFe-Org1T6ck5qlg.png"/></div></div></figure><p id="0080" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">将<strong class="jq io">编辑器</strong>分配给<strong class="jq io">书。</strong></p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi ob"><img src="../Images/b9235e3facafae9f393f49a263052a4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JyCoPA64ElL8phsLRc0nig.png"/></div></div></figure><p id="2ea8" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">将<strong class="jq io">图书</strong>添加到<strong class="jq io">编辑的</strong>图书列表中。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi of"><img src="../Images/18f72f870c8e78d78d6ced7fc0eea6a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PL8prcINmHZH8x4GkEpxEQ.png"/></div></div></figure><p id="7019" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">并将<strong class="jq io">书</strong>也添加到<strong class="jq io">作者的</strong>书单中。</p><p id="3391" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">这是典型的出版社数据模型。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi og"><img src="../Images/650ccbb8f6d1df6d39254c41f9b75a69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RxXIjqNI1n-5jzHOZ3JQPA.png"/></div></div></figure><p id="1137" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">然后，让我们把它们都放在范围内，这样一旦它们超出范围，对<strong class="jq io">书</strong>、<strong class="jq io">编辑</strong>和<strong class="jq io">作者</strong>的引用应该降到零并解除分配。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi oh"><img src="../Images/71a495e6eab96b7be3b4a256c7544e8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6bcq6xef5ri8c0Mp-4J-kg.png"/></div></div></figure><p id="c0bd" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">这里的问题是，在范围的末端，<strong class="jq io">书</strong>、<strong class="jq io">编辑</strong>和<strong class="jq io">作者</strong>的引用从未下降并达到零。</p><p id="ee52" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">🤔为什么？！因为书和作者相互引用，每个实例都使另一个实例保持活力，对于书和编辑器也是如此。</p><p id="6173" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">我们通过结束作用域使事情变得更糟，堆栈列表项将被释放，不再有对初始对象的引用。</p><p id="544a" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">这是一个典型的引用周期案例，它导致了一个被称为<strong class="jq io">内存泄漏</strong>的软件错误。由于内存泄漏，即使内存的实际生命周期已经结束，内存也不会被释放。</p><p id="f425" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">引用周期是内存泄漏的最常见原因。</p><p id="21f7" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated"><strong class="jq io">注意:</strong> ARC会自动为您处理参考计数，但注意参考周期很重要。</p><p id="95c2" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated"><strong class="jq io">注:</strong>参考循环在一些书籍和网络资源中被称为“保留循环”。两者指的是同一个东西！</p><h1 id="2e08" class="lu lv in bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">内存泄漏</h1><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/86905d345843ee25fc2c31bd7fb742f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:696/format:webp/1*DN4Vo3uW8uHfkuIgZNNNWw.png"/></div></figure><h2 id="6d3d" class="nk lv in bd lw nl nm dn ma nn no dp me ld np nq mi le nr ns mm lf nt nu mq nv bi translated">内存泄漏是不好的！</h2><p id="c626" class="pw-post-body-paragraph jn jo in jq b jr ms jt ju jv mt jx jy ld mu kb kc le mv kf kg lf mw kj kk kl ig bi translated">内存泄漏是指在某个时间点分配了内存，但从未释放，并且您的应用程序不再引用该内存。因为没有对它的引用，所以没有办法释放它，并且那个内存位置不能再次使用。</p><p id="841b" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">从新手到高级工程师，我们都会在某个时候制造漏洞。不管我们有多有经验。</p><p id="9318" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">最重要的是消除它们，以获得干净和无崩溃的应用程序。</p><p id="6a50" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">在应用程序运行很长时间之前，内存泄漏可能不会出现。(内存泄漏通常就像汽车轮胎慢慢漏气一样。几个小时后就没有问题了。放一周你的车就停飞了)。</p><h2 id="6777" class="nk lv in bd lw nl nm dn ma nn no dp me ld np nq mi le nr ns mm lf nt nu mq nv bi translated"><strong class="ak">增加应用的内存占用量</strong></h2><p id="dcbe" class="pw-post-body-paragraph jn jo in jq b jr ms jt ju jv mt jx jy ld mu kb kc le mv kf kg lf mw kj kk kl ig bi translated">内存泄漏通过不释放被放弃的对象来增加内存占用。那些东西是垃圾。随着创建这些对象的操作的重复，占用的内存将会增加。</p><h2 id="c4b4" class="nk lv in bd lw nl nm dn ma nn no dp me ld np nq mi le nr ns mm lf nt nu mq nv bi translated"><strong class="ak">引入不必要的副作用</strong></h2><p id="0678" class="pw-post-body-paragraph jn jo in jq b jr ms jt ju jv mt jx jy ld mu kb kc le mv kf kg lf mw kj kk kl ig bi translated">想象一个对象，当它被创建时，在它的初始化器中开始监听一个通知。它对此做出反应，改变数据库，播放视频，或将事件发布到分析引擎。由于对象需要被平衡，我们让它在被释放时停止监听通知，在deinit内部。</p><p id="dc3a" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">如果这个对象泄漏了，就不会调用反初始化器:它永远不会死，也永远不会停止监听通知。每次发布通知时，对象都会对其做出反应。如果用户重复创建相关对象的操作，将会有多个实例处于活动状态。所有这些实例对通知做出响应并相互进入。</p><p id="66b4" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">在这些情况下，你会希望崩溃！</p><h2 id="ceaa" class="nk lv in bd lw nl nm dn ma nn no dp me ld np nq mi le nr ns mm lf nt nu mq nv bi translated">泄露从何而来？</h2><p id="16d5" class="pw-post-body-paragraph jn jo in jq b jr ms jt ju jv mt jx jy ld mu kb kc le mv kf kg lf mw kj kk kl ig bi translated">泄漏可能来自第三方SDK或框架。甚至来自苹果公司创建的类，如CALayer或UILabel。在这种情况下，除了等待更新或丢弃SDK，我们无能为力。</p><p id="ae1f" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">但是更有可能的是，我们在代码中引入了漏洞😅。</p><h1 id="d30a" class="lu lv in bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">从这里去哪里？</h1><p id="9aff" class="pw-post-body-paragraph jn jo in jq b jr ms jt ju jv mt jx jy ld mu kb kc le mv kf kg lf mw kj kk kl ig bi translated">在本文中，您已经了解了内存区域、数据类型、类中的引用周期和内存泄漏。</p><p id="6c98" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">在本系列的下一部分<a class="ae km" rel="noopener ugc nofollow" target="_blank" href="/memory-management-part-2-reference-cycles-closures-and-debugging-59b917dc064b#ce92-869979fd6b4b"> <strong class="jq io">第2部分:引用周期、闭包和调试</strong> </a>中，您将学习在类和闭包中打破引用周期、Xcode内存调试器以及如何使用苹果的Malloc库定位漏洞。</p><p id="cce9" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">我希望你喜欢这篇文章。如果你有任何问题或意见，不要犹豫，就把它们写在这里🤗。</p></div></div>    
</body>
</html>