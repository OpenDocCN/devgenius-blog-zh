<html>
<head>
<title>Go &amp; Docker Hello World!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Go &amp; Docker Hello World！</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/go-docker-hello-world-f092ecf7cead?source=collection_archive---------0-----------------------#2022-01-31">https://blog.devgenius.io/go-docker-hello-world-f092ecf7cead?source=collection_archive---------0-----------------------#2022-01-31</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/26b740b6272b7648f773d4435089e3a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*axRRjJrxsDGDwHJa"/></div></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk translated">由<a class="ae ja" href="https://unsplash.com/@z734923105?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Jerry Zhang </a>在<a class="ae ja" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><div class=""/><p id="d667" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一个简单的使用 Go 和 Docker 的 HTTP 服务器。</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><p id="dadb" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在本指南中，我将介绍如何从头开始创建您的第一个 Go 项目，并介绍如何使用 Docker 构建和运行一个 HTTP 服务器示例。</p><p id="1995" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="lf">注意:请确保您已经在系统上安装了</em> <a class="ae ja" href="https://go.dev/" rel="noopener ugc nofollow" target="_blank"> <em class="lf"> Go </em> </a> <em class="lf">和</em><a class="ae ja" href="https://www.docker.com/" rel="noopener ugc nofollow" target="_blank"><em class="lf">Docker</em></a><em class="lf">后再继续。任何文本编辑器将工作，否则！(我用的是</em><a class="ae ja" href="https://code.visualstudio.com/" rel="noopener ugc nofollow" target="_blank"><em class="lf">vs code</em></a><em class="lf">)。</em></p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h1 id="606f" class="lg lh jd bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">创建项目</h1><p id="c001" class="pw-post-body-paragraph ka kb jd kc b kd me kf kg kh mf kj kk kl mg kn ko kp mh kr ks kt mi kv kw kx ig bi translated">让我们继续创建一个名为<code class="fe mj mk ml mm b">hello_go_http</code>的新项目:</p><pre class="mn mo mp mq gt mr mm ms mt aw mu bi"><span id="1edc" class="mv lh jd mm b gy mw mx l my mz">$ mkdir hello_go_http &amp;&amp; cd hello_go_http</span></pre><p id="677f" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">使用 go，我们可以创建一个<code class="fe mj mk ml mm b">go.mod</code>文件(它将我们的项目表示为一个模块，并帮助我们定义任何未来的依赖关系)。这可以通过以下方式创建:</p><pre class="mn mo mp mq gt mr mm ms mt aw mu bi"><span id="e871" class="mv lh jd mm b gy mw mx l my mz">$ go mod init hellogohttp/m/v2</span></pre><p id="9d31" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后，让我们添加一个<code class="fe mj mk ml mm b">main.go</code>文件，这将是我们的应用程序入口点，我们将在这里添加我们的服务器逻辑。</p><p id="7350" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">首先创建文件:</p><pre class="mn mo mp mq gt mr mm ms mt aw mu bi"><span id="e428" class="mv lh jd mm b gy mw mx l my mz">$ touch main.go</span></pre><p id="e001" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后修改内容，如下所示:</p><pre class="mn mo mp mq gt mr mm ms mt aw mu bi"><span id="e2c0" class="mv lh jd mm b gy mw mx l my mz">package main;</span><span id="7c74" class="mv lh jd mm b gy na mx l my mz">import (<br/>    "fmt"<br/>    "log"<br/>    "net/http"<br/>)</span><span id="54da" class="mv lh jd mm b gy na mx l my mz">func main() {<br/>    http.HandleFunc("/helloworld", func(w http.ResponseWriter, r *http.Request){<br/>        fmt.Fprintf(w, "Hello, World!")<br/>    })<br/>    fmt.Printf("Server running (port=8080), route: <a class="ae ja" href="http://localhost:8080/helloworld\n" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/helloworld\n</a>")<br/>    if err := http.ListenAndServe(":8080", nil); err != nil {<br/>        log.Fatal(err)<br/>    }<br/>}</span></pre><p id="8585" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这将在端口<code class="fe mj mk ml mm b">8080</code>启动一个 HTTP 服务器，并暴露单一路由<code class="fe mj mk ml mm b">helloworld</code>。我们可以使用以下工具在本地构建和运行它:</p><pre class="mn mo mp mq gt mr mm ms mt aw mu bi"><span id="ed46" class="mv lh jd mm b gy mw mx l my mz">$ go run main.go</span></pre><p id="71ba" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">并通过导航到<a class="ae ja" href="http://localhost:8080/helloworld" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/hello world</a>，使用 curl 或浏览器测试它的工作情况。</p><pre class="mn mo mp mq gt mr mm ms mt aw mu bi"><span id="3507" class="mv lh jd mm b gy mw mx l my mz">$ curl <a class="ae ja" href="http://localhost:8080/helloworld" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/helloworld</a><br/>Hello, World!</span></pre><p id="887b" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">太好了！在 Go 中，您现在已经有了一个简单的本地运行的 HTTP 服务器。</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h1 id="8531" class="lg lh jd bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">用 Docker 构建</h1><p id="2733" class="pw-post-body-paragraph ka kb jd kc b kd me kf kg kh mf kj kk kl mg kn ko kp mh kr ks kt mi kv kw kx ig bi translated">让我们通过在 Docker 中实现构建过程来更进一步，这将有助于<a class="ae ja" href="https://docs.aws.amazon.com/AmazonECS/latest/userguide/docker-basics.html" rel="noopener ugc nofollow" target="_blank">将应用部署到云</a>。</p><p id="9f9f" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在项目的根目录下，创建一个名为<code class="fe mj mk ml mm b">Dockerfile</code>的新文件:</p><pre class="mn mo mp mq gt mr mm ms mt aw mu bi"><span id="5726" class="mv lh jd mm b gy mw mx l my mz">$ touch Dockerfile</span></pre><p id="c0a4" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后修改内容，使其看起来像:</p><pre class="mn mo mp mq gt mr mm ms mt aw mu bi"><span id="59a0" class="mv lh jd mm b gy mw mx l my mz"># Create build stage based on buster image<br/>FROM golang:1.16-buster AS builder</span><span id="6cc6" class="mv lh jd mm b gy na mx l my mz"># Create working directory under /app<br/>WORKDIR /app</span><span id="1ec4" class="mv lh jd mm b gy na mx l my mz"># Copy over all go config (go.mod, go.sum etc.)<br/>COPY go.* ./</span><span id="7c9f" class="mv lh jd mm b gy na mx l my mz"># Install any required modules<br/>RUN go mod download</span><span id="935a" class="mv lh jd mm b gy na mx l my mz"># Copy over Go source code<br/>COPY *.go ./</span><span id="e150" class="mv lh jd mm b gy na mx l my mz"># Run the Go build and output binary under hello_go_http<br/>RUN go build -o /hello_go_http</span><span id="2541" class="mv lh jd mm b gy na mx l my mz"># Make sure to expose the port the HTTP server is using<br/>EXPOSE 8080</span><span id="f41f" class="mv lh jd mm b gy na mx l my mz"># Run the app binary when we run the container<br/>ENTRYPOINT ["/hello_go_http"]</span></pre><p id="8ef1" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后，您可以使用 Docker 构建并运行这个容器:</p><pre class="mn mo mp mq gt mr mm ms mt aw mu bi"><span id="8a27" class="mv lh jd mm b gy mw mx l my mz">$ docker built -t hello_go_http .<br/>$ docker run -p 8080:8080 -t hello_go_http</span></pre><p id="617a" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="lf">注意:需要</em> <code class="fe mj mk ml mm b"><em class="lf">-p </em></code> <em class="lf">标志来让运行时知道要发布这个端口，它会将所有流量转发到 HTTP 服务器端口。</em></p><p id="13e8" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">并且可以使用 curl 测试一切是否正常。</p><pre class="mn mo mp mq gt mr mm ms mt aw mu bi"><span id="a0d2" class="mv lh jd mm b gy mw mx l my mz">$ curl <a class="ae ja" href="http://localhost:8080/helloworld" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/helloworld</a><br/>Hello, World!</span></pre></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h1 id="b265" class="lg lh jd bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">改进构建</h1><p id="e476" class="pw-post-body-paragraph ka kb jd kc b kd me kf kg kh mf kj kk kl mg kn ko kp mh kr ks kt mi kv kw kx ig bi translated">虽然这是一个很大的进步，但我们可以更进一步，使用 Docker 的多阶段构建过程来改进容器的大小。</p><p id="3679" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，我们已经将所有的 Go 源代码复制到了我们的容器中，并且将不必要的工具作为<code class="fe mj mk ml mm b">buster</code>基础映像的一部分。实际上，我们只需要构建的二进制文件来运行应用程序。</p><p id="26c8" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了去掉不必要的项目，让我们添加一个额外的构建阶段，这样<code class="fe mj mk ml mm b">Dockerfile</code>现在看起来就像:</p><pre class="mn mo mp mq gt mr mm ms mt aw mu bi"><span id="8db0" class="mv lh jd mm b gy mw mx l my mz">FROM golang:1.16-buster AS builder</span><span id="d417" class="mv lh jd mm b gy na mx l my mz">WORKDIR /app</span><span id="35cb" class="mv lh jd mm b gy na mx l my mz">COPY go.* ./<br/>RUN go mod download</span><span id="f949" class="mv lh jd mm b gy na mx l my mz">COPY *.go ./<br/>RUN go build -o /hello_go_http</span><span id="1fa4" class="mv lh jd mm b gy na mx l my mz"># Create a new release build stage<br/>FROM gcr.io/distroless/base-debian10</span><span id="47a3" class="mv lh jd mm b gy na mx l my mz"># Set the working directory to the root directory path<br/>WORKDIR /</span><span id="da98" class="mv lh jd mm b gy na mx l my mz"># Copy over the binary built from the previous stage<br/>COPY --from=builder /hello_go_http /hello_go_http</span><span id="437a" class="mv lh jd mm b gy na mx l my mz">EXPOSE 8080</span><span id="c3f2" class="mv lh jd mm b gy na mx l my mz">ENTRYPOINT ["/hello_go_http"]</span></pre><p id="1b5f" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在我们有了一个额外的阶段，它使用一个不同的基础映像来运行二进制文件，从我们之前定义的<code class="fe mj mk ml mm b">builder</code>阶段复制二进制文件。</p><p id="bdcd" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">同样，让我们使用 Docker 来构建和运行它:</p><pre class="mn mo mp mq gt mr mm ms mt aw mu bi"><span id="b584" class="mv lh jd mm b gy mw mx l my mz">$ docker build -t hello_go_http_multistage .<br/>$ docker run -p 8080:8080 -t hello_go_http_multistage .</span></pre><p id="cbdd" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最后，检查我们的应用程序是否仍按预期工作:</p><pre class="mn mo mp mq gt mr mm ms mt aw mu bi"><span id="0ff0" class="mv lh jd mm b gy mw mx l my mz">$ curl <a class="ae ja" href="http://localhost:8080/helloworld" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/helloworld</a><br/>Hello, World!</span></pre><p id="02a6" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">太好了！现在我们可以看到我们的应用程序成功运行了，有了我们的多级 Docker 构建。</p><p id="f585" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在你可能会问，我如何才能看到增加额外阶段的好处？好吧，让我们来看看我们现在构建的两个图像的大小(<code class="fe mj mk ml mm b">hello_go_http</code> &amp; <code class="fe mj mk ml mm b">hello_go_http_multistage</code>):</p><pre class="mn mo mp mq gt mr mm ms mt aw mu bi"><span id="64dc" class="mv lh jd mm b gy mw mx l my mz">$ docker images<br/>REPOSITORY                        TAG           IMAGE ID       CREATED          SIZE<br/>hello_go_http_multistage          latest        bd6daad47845   10 seconds ago   25.4MB<br/>hello_go_http                     latest        a31792310b10   3 minutes ago    868MB</span></pre><p id="427a" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所以可以看到我们<strong class="kc je">把有效大小从 868MB 降到了 25.4MB </strong>！</p><p id="4f81" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="lf">注意:这个灵感来自于</em> <a class="ae ja" href="https://docs.docker.com/language/golang/build-images/" rel="noopener ugc nofollow" target="_blank"> <em class="lf"> Docker 的官方文档，查看更多关于 Docker 和多级构建的信息</em> </a> <em class="lf">！</em></p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><p id="e735" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，您已经完成了所有步骤，让我们来看看我们取得了什么成果:</p><ul class=""><li id="f629" class="nb nc jd kc b kd ke kh ki kl nd kp ne kt nf kx ng nh ni nj bi translated">创建了一个基本的 Go 应用程序，它通过 HTTP 提供内容。</li><li id="f9e9" class="nb nc jd kc b kd nk kh nl kl nm kp nn kt no kx ng nh ni nj bi translated">配置 Docker 构建并向 Go HTTP 服务器公开流量。</li><li id="2c1e" class="nb nc jd kc b kd nk kh nl kl nm kp nn kt no kx ng nh ni nj bi translated">使用多阶段方法改进了 Docker 构建图像的大小。</li></ul></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h1 id="6931" class="lg lh jd bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">下一步是什么？</h1><p id="3f7b" class="pw-post-body-paragraph ka kb jd kc b kd me kf kg kh mf kj kk kl mg kn ko kp mh kr ks kt mi kv kw kx ig bi translated">这是准备用 Go 开发应用程序的一个很好的开始，而且从本指南中可以找到许多很好的后续步骤和项目。首先，这里有一些建议:</p><ul class=""><li id="6da5" class="nb nc jd kc b kd ke kh ki kl nd kp ne kt nf kx ng nh ni nj bi translated"><a class="ae ja" href="https://docs.aws.amazon.com/AmazonECS/latest/userguide/docker-basics.html" rel="noopener ugc nofollow" target="_blank">通过构建的容器映像将您的 HTTP 服务器部署到 AWS 上</a>。</li><li id="1f4d" class="nb nc jd kc b kd nk kh nl kl nm kp nn kt no kx ng nh ni nj bi translated">扩展您的路由以构建一个后端服务来满足您的需求。</li><li id="ac4f" class="nb nc jd kc b kd nk kh nl kl nm kp nn kt no kx ng nh ni nj bi translated">用<a class="ae ja" href="https://github.com/gorilla/websocket" rel="noopener ugc nofollow" target="_blank"> Gorilla </a>添加 WebSocket 服务器支持。</li></ul></div></div>    
</body>
</html>