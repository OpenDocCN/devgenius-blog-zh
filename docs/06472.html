<html>
<head>
<title>How does hoisting in JavaScript works</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的提升是如何工作的</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-does-hoisting-in-javascript-works-80614300cb98?source=collection_archive---------14-----------------------#2022-01-10">https://blog.devgenius.io/how-does-hoisting-in-javascript-works-80614300cb98?source=collection_archive---------14-----------------------#2022-01-10</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="d600" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这篇文章中，我将解释JavaScript中的提升是如何工作的，以及函数和变量是如何被它影响的。</p><p id="cfb2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">提升是一种JavaScript机制，在解析器执行代码之前，变量和函数声明被移动到它们作用域的顶部，解析器在JavaScript解释器开始实际执行之前将源代码读入中间表示。因此，变量或函数在哪里声明并不重要，不管它们的作用域是全局的还是局部的，它们都将被移动到作用域的顶部。</p><p id="f043" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这意味着</p><pre class="kj kk kl km gt kn ko kp kq aw kr bi"><span id="46fc" class="ks kt in ko b gy ku kv l kw kx">console.log (hi);     <br/>var hi = "say hi";</span></pre><p id="c4c1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">实际上是这样解释的</p><pre class="kj kk kl km gt kn ko kp kq aw kr bi"><span id="4318" class="ks kt in ko b gy ku kv l kw kx">var hi = undefined;<br/>console.log (hi);<br/>hi = "say hi";</span></pre><p id="4fbf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，正如我们刚才看到的，<code class="fe ky kz la ko b">var</code>变量被提升到其作用域的顶部，并用值<code class="fe ky kz la ko b">undefined</code>进行初始化，这意味着我们可以在代码中实际声明它们之前实际赋值，如下所示:</p><pre class="kj kk kl km gt kn ko kp kq aw kr bi"><span id="7108" class="ks kt in ko b gy ku kv l kw kx">hi = “say hi”<br/>console.log (hi); // say hi<br/>var hi;</span></pre><p id="62f8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">那么，函数呢？</p><p id="9db3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果我们在讨论函数声明，我们可以在实际声明之前调用它们，就像这样:</p><pre class="kj kk kl km gt kn ko kp kq aw kr bi"><span id="3f69" class="ks kt in ko b gy ku kv l kw kx">sayHi(); // Hi<br/><br/>function sayHi() {<br/>  console.log('Hi');<br/>};</span></pre><p id="c41b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">另一方面，函数表达式没有被提升，所以我们会得到下面的错误:</p><pre class="kj kk kl km gt kn ko kp kq aw kr bi"><span id="b3e0" class="ks kt in ko b gy ku kv l kw kx">sayHi(); //Output: "TypeError: sayHi is not a function<br/><br/>var sayHi = function() {<br/>  console.log('Hi');<br/>};</span></pre><p id="4fc9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">ES6向JavaScript开发者介绍了<code class="fe ky kz la ko b">let</code>和<code class="fe ky kz la ko b">const</code>关键字。虽然<code class="fe ky kz la ko b">let</code>和<code class="fe ky kz la ko b">const</code>是块作用域的，而不是像<code class="fe ky kz la ko b">var</code>那样是函数作用域的，但是在讨论它们的提升行为时应该没有什么不同。我们从最后开始，JavaScript吊起<code class="fe ky kz la ko b">let</code>和<code class="fe ky kz la ko b">const</code>(:</p><p id="d893" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们先来探究一下<code class="fe ky kz la ko b">let</code>关键词行为。</p><pre class="kj kk kl km gt kn ko kp kq aw kr bi"><span id="35f2" class="ks kt in ko b gy ku kv l kw kx">console.log(hi); // Output: <!-- -->Cannot access 'hi' before initialization<!-- --> <br/>let hi = 'Hi';</span></pre><p id="3d64" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">正如我们在上面看到的，<code class="fe ky kz la ko b">let</code>不允许我们使用未声明的变量，因此解释器显式输出一个<code class="fe ky kz la ko b">Reference</code>错误，表明在初始化之前不能访问hi变量。</p><p id="ae68" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果我们将上述<code class="fe ky kz la ko b">let</code>改为<code class="fe ky kz la ko b">const</code>，也会出现同样的错误</p><pre class="kj kk kl km gt kn ko kp kq aw kr bi"><span id="b8ec" class="ks kt in ko b gy ku kv l kw kx">console.log(hi); // <!-- -->Output: <!-- -->Cannot access 'hi' before initialization<br/>const hi = 'Hi';</span></pre><p id="218a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">总而言之，JavaScript解析器搜索变量声明和函数，在代码执行之前将它们提升到作用域的顶部，并在内存中为它们赋值，这样万一解释器在执行代码时遇到它们，它将识别它们，并能够使用它们的赋值来执行代码。<br/>用<code class="fe ky kz la ko b">let</code>或<code class="fe ky kz la ko b">const</code>声明的变量在执行开始时保持未初始化，而用<code class="fe ky kz la ko b">var</code>声明的变量用<strong class="jm io">未定义的</strong>值初始化。</p><p id="5366" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">通过下图，我们可以更好地理解它:</p><figure class="kj kk kl km gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi lb"><img src="../Images/a697857262b8379cd4526240e49f35d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ua69sXQPDS34EhQN89fb9g.png"/></div></div></figure><p id="6952" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我希望你喜欢这篇文章，它在提升如何在幕后工作和行动方面有一些意义。如果你喜欢它，欢迎你在下面为它鼓掌。</p><p id="de9a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您也可以关注我以获得更多类似的文章(:</p></div></div>    
</body>
</html>