<html>
<head>
<title>Where is the object in JAVA? what is Garbage Collector, Stack, Heap in JAVA?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JAVA 中的对象在哪里？JAVA 中的垃圾收集器、栈、堆是什么？</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/what-is-garbage-collector-stack-heap-in-java-80c33c2a0234?source=collection_archive---------4-----------------------#2022-01-08">https://blog.devgenius.io/what-is-garbage-collector-stack-heap-in-java-80c33c2a0234?source=collection_archive---------4-----------------------#2022-01-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/05abce0418ccdfc0b692a0158e20c3ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CuZtwu4B_k6T8gKY2vZmMA.jpeg"/></div></div></figure></div><div class="ab cl jv jw hr jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="ig ih ii ij ik"><h2 id="291a" class="kc kd in bd ke kf kg dn kh ki kj dp kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated"><strong class="ak">简介:</strong></h2><p id="1ba5" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li kl lj lk ll kp lm ln lo kt lp lq lr ls ig bi translated">在这篇文章中，我将解释堆和栈以及 java 如何使用它们，Java 中的垃圾收集器是什么，在应用程序中将做什么，以及我们的应用程序中对象的生命周期是什么。</p><h2 id="cb19" class="kc kd in bd ke kf kg dn kh ki kj dp kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">Java 中的堆栈和堆:</h2><p id="14bc" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li kl lj lk ll kp lm ln lo kt lp lq lr ls ig bi translated">JVM (Java 虚拟机)将内存分为两部分:堆栈内存和堆内存。</p><p id="ebf3" class="pw-post-body-paragraph ky kz in la b lb lt ld le lf lu lh li kl lv lk ll kp lw ln lo kt lx lq lr ls ig bi translated">栈和堆是 Java 中方法、对象和变量的生命所在</p><p id="0b77" class="pw-post-body-paragraph ky kz in la b lb lt ld le lf lu lh li kl lv lk ll kp lw ln lo kt lx lq lr ls ig bi translated">当运行你的 Java 应用程序时，JVM (Java 虚拟机)会检查你操作系统中的内存，并使用它来运行 Java 应用程序。</p><p id="60c0" class="pw-post-body-paragraph ky kz in la b lb lt ld le lf lu lh li kl lv lk ll kp lw ln lo kt lx lq lr ls ig bi translated">所有将在 java 应用程序中初始化的对象都在堆中，但是变量在堆栈中，方法在堆栈中，</p><p id="4975" class="pw-post-body-paragraph ky kz in la b lb lt ld le lf lu lh li kl lv lk ll kp lw ln lo kt lx lq lr ls ig bi translated">但并不是所有的变量都像集合一样存在于堆栈中，字符串变量存在于堆中。</p><p id="a910" class="pw-post-body-paragraph ky kz in la b lb lt ld le lf lu lh li kl lv lk ll kp lw ln lo kt lx lq lr ls ig bi translated">请看下图，它代表了 java 应用程序中的堆和栈。</p><figure class="lz ma mb mc gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ly"><img src="../Images/d4c1ab3f186c05438cd3e9673b041cce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xI3Mq3PaAGcw0unMUKdqBw.png"/></div></div></figure><p id="875d" class="pw-post-body-paragraph ky kz in la b lb lt ld le lf lu lh li kl lv lk ll kp lw ln lo kt lx lq lr ls ig bi translated">好，现在我们有了变量类型，我们关心它们</p><ul class=""><li id="a177" class="md me in la b lb lt lf lu kl mf kp mg kt mh ls mi mj mk ml bi translated">实例变量</li><li id="750c" class="md me in la b lb mm lf mn kl mo kp mp kt mq ls mi mj mk ml bi translated">局部变量</li></ul><blockquote class="mr ms mt"><p id="5ced" class="ky kz mu la b lb lt ld le lf lu lh li mv lv lk ll mw lw ln lo mx lx lq lr ls ig bi translated"><em class="in">现在我们来谈谈上述类型的变量</em></p></blockquote><h2 id="f84f" class="kc kd in bd ke kf kg dn kh ki kj dp kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">实例变量:</h2><figure class="lz ma mb mc gt jo gh gi paragraph-image"><div class="gh gi my"><img src="../Images/dd8794b8fc0ecd7511489d4f5d448b0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1088/format:webp/1*UtrqDdiMWMYMetBw6bKCnQ.png"/></div></figure><p id="d43a" class="pw-post-body-paragraph ky kz in la b lb lt ld le lf lu lh li kl lv lk ll kp lw ln lo kt lx lq lr ls ig bi translated">我们将在类中而不是在方法中声明一个实例。</p><p id="cc2a" class="pw-post-body-paragraph ky kz in la b lb lt ld le lf lu lh li kl lv lk ll kp lw ln lo kt lx lq lr ls ig bi translated">关于这个证明，实例变量属于对象，因此将存在于堆中。</p><h2 id="7bc4" class="kc kd in bd ke kf kg dn kh ki kj dp kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">局部变量:</h2><figure class="lz ma mb mc gt jo gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/c86be3e1251ab46fec7f297d479c48d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1134/format:webp/1*_b7NGIJ3o1uVzdzViNgiFg.png"/></div></figure><p id="bf40" class="pw-post-body-paragraph ky kz in la b lb lt ld le lf lu lh li kl lv lk ll kp lw ln lo kt lx lq lr ls ig bi translated">局部变量在方法内部声明，方法内部的参数是局部变量，如果方法死了，局部变量也会死，因为局部变量依赖于方法，在这种情况下，如果方法从堆栈中删除，局部变量也会被删除。</p><blockquote class="mr ms mt"><p id="0dc5" class="ky kz mu la b lb lt ld le lf lu lh li mv lv lk ll mw lw ln lo mx lx lq lr ls ig bi translated"><em class="in">好了，现在我们知道方法在哪里，对象在哪里了</em></p></blockquote><h2 id="90f7" class="kc kd in bd ke kf kg dn kh ki kj dp kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">栈是什么？堆栈是如何工作的？</h2><figure class="lz ma mb mc gt jo gh gi paragraph-image"><div class="gh gi na"><img src="../Images/d2a5ba8888c918bdab8451611a37a450.png" data-original-src="https://miro.medium.com/v2/resize:fit:1060/format:webp/1*mtasOBrgM550y7JgiVWszA.png"/></div></figure><p id="6113" class="pw-post-body-paragraph ky kz in la b lb lt ld le lf lu lh li kl lv lk ll kp lw ln lo kt lx lq lr ls ig bi translated">堆栈是一种线性数据结构，用于存储对象集合。</p><p id="100c" class="pw-post-body-paragraph ky kz in la b lb lt ld le lf lu lh li kl lv lk ll kp lw ln lo kt lx lq lr ls ig bi translated">堆栈遵循 LIFO(后进先出)原则，即最后插入的元素是第一个出来的元素。</p><p id="b627" class="pw-post-body-paragraph ky kz in la b lb lt ld le lf lu lh li kl lv lk ll kp lw ln lo kt lx lq lr ls ig bi translated">请看下图，了解它们是如何堆叠工作的。</p><p id="7f88" class="pw-post-body-paragraph ky kz in la b lb lt ld le lf lu lh li kl lv lk ll kp lw ln lo kt lx lq lr ls ig bi translated"><strong class="la io">举例:</strong></p><figure class="lz ma mb mc gt jo gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/e3162879ea2dd2c0eeb8f4214e842120.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S4S48kHvK_STnjB_19wL7Q.png"/></div></figure><p id="0119" class="pw-post-body-paragraph ky kz in la b lb lt ld le lf lu lh li kl lv lk ll kp lw ln lo kt lx lq lr ls ig bi translated">在上图中，我们在堆栈中有两个方法<strong class="la io"> bar() </strong>和<strong class="la io"> foo() </strong></p><p id="d0a5" class="pw-post-body-paragraph ky kz in la b lb lt ld le lf lu lh li kl lv lk ll kp lw ln lo kt lx lq lr ls ig bi translated">bar 上有一个名为<strong class="la io"> S </strong>的局部变量，而<strong class="la io"> foo() </strong>则有三个局部变量<strong class="la io"> x，I，b </strong></p><p id="6a34" class="pw-post-body-paragraph ky kz in la b lb lt ld le lf lu lh li kl lv lk ll kp lw ln lo kt lx lq lr ls ig bi translated">在图像的情况下，堆栈将执行<strong class="la io"> bar() </strong>方法，因为它是顶部的，当完成时，堆栈将使用局部变量<strong class="la io"> S </strong>弹出 <strong class="la io"> bar( </strong>)方法。</p><blockquote class="mr ms mt"><p id="98a5" class="ky kz mu la b lb lt ld le lf lu lh li mv lv lk ll mw lw ln lo mx lx lq lr ls ig bi translated"><em class="in">例如，我们将 object 作为局部变量，在方法</em>中定义的这种情况下会发生什么</p></blockquote><h2 id="9f73" class="kc kd in bd ke kf kg dn kh ki kj dp kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">对象作为局部变量:</h2><p id="aaca" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li kl lj lk ll kp lm ln lo kt lp lq lr ls ig bi translated">在这种情况下，该方法将初始化一个非原始变量，它将指向堆内的对象。</p><p id="ac3d" class="pw-post-body-paragraph ky kz in la b lb lt ld le lf lu lh li kl lv lk ll kp lw ln lo kt lx lq lr ls ig bi translated">方法不能从堆中看到原始对象，但非基元值可以。</p><p id="6707" class="pw-post-body-paragraph ky kz in la b lb lt ld le lf lu lh li kl lv lk ll kp lw ln lo kt lx lq lr ls ig bi translated">非原始值具有对堆中原始对象的引用。并且具有相同的值。</p><p id="3830" class="pw-post-body-paragraph ky kz in la b lb lt ld le lf lu lh li kl lv lk ll kp lw ln lo kt lx lq lr ls ig bi translated"><strong class="la io">举例:</strong></p><p id="adab" class="pw-post-body-paragraph ky kz in la b lb lt ld le lf lu lh li kl lv lk ll kp lw ln lo kt lx lq lr ls ig bi translated">请看下图，以便更好地理解。</p><figure class="lz ma mb mc gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nc"><img src="../Images/16668b4f77255e5e048e825c5bccb1b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MoAV-zEqVgrIY1DkLXMKdA.png"/></div></div></figure><p id="3448" class="pw-post-body-paragraph ky kz in la b lb lt ld le lf lu lh li kl lv lk ll kp lw ln lo kt lx lq lr ls ig bi translated">在上图中，我们有堆栈和堆，堆栈有方法<strong class="la io"> barf() </strong>有<strong class="la io">非原语</strong>变量，因为它是来自<strong class="la io"> Duck 类</strong>的<strong class="la io">对象</strong>的引用，而<strong class="la io"> foof() </strong>没有任何局部变量。</p><blockquote class="mr ms mt"><p id="bcce" class="ky kz mu la b lb lt ld le lf lu lh li mv lv lk ll mw lw ln lo mx lx lq lr ls ig bi translated"><em class="in">我们来谈谈实例变量</em></p></blockquote><h2 id="19f1" class="kc kd in bd ke kf kg dn kh ki kj dp kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">实例变量在哪里？</h2><p id="7468" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li kl lj lk ll kp lm ln lo kt lp lq lr ls ig bi translated">当创建对象时，java 会调用这个类的构造函数，如果这个类没有，任何构造函数都会创建一个默认的构造函数并执行它，在构造函数中我们可以为一个类的变量设置一个值，这些变量在对象实例中是活的，如果对象死了，这个变量也会死。</p><p id="cb3d" class="pw-post-body-paragraph ky kz in la b lb lt ld le lf lu lh li kl lv lk ll kp lw ln lo kt lx lq lr ls ig bi translated">如果变量是基元的，java 将根据基元类型为实例变量腾出空间。<strong class="la io"> int </strong>需要<strong class="la io"> (32 位)</strong> <strong class="la io"> long </strong>需要<strong class="la io"> (64 位)</strong>等等。</p><p id="d62e" class="pw-post-body-paragraph ky kz in la b lb lt ld le lf lu lh li kl lv lk ll kp lw ln lo kt lx lq lr ls ig bi translated">java 不关心<strong class="la io">原语</strong>中的值是什么，只关心用于创建空格的原语的类型。</p><blockquote class="mr ms mt"><p id="f497" class="ky kz mu la b lb lt ld le lf lu lh li mv lv lk ll mw lw ln lo mx lx lq lr ls ig bi translated"><em class="in">构造器将执行每个新的关键字</em></p><p id="6d98" class="ky kz mu la b lb lt ld le lf lu lh li mv lv lk ll mw lw ln lo mx lx lq lr ls ig bi translated">你创建的每个类都有一个构造函数，即使你不是自己写的。</p></blockquote><p id="c5f9" class="pw-post-body-paragraph ky kz in la b lb lt ld le lf lu lh li kl lv lk ll kp lw ln lo kt lx lq lr ls ig bi translated">就像我最后说的，创建对象后将默认执行该类的构造函数，在这一步中<strong class="la io"> JVM </strong> ( <strong class="la io"> Java 虚拟机</strong>)将设置值，在完成进程之前，我们的对象将在堆中注册。</p><h2 id="9fcf" class="kc kd in bd ke kf kg dn kh ki kj dp kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">一个物体能活多久？</h2><p id="9d49" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li kl lj lk ll kp lm ln lo kt lp lq lr ls ig bi translated">对象的生命依赖于引用它的引用，如果引用死了，那么对象也会死。</p><h2 id="9b88" class="kc kd in bd ke kf kg dn kh ki kj dp kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">垃圾收集(GC)的任务是什么？</h2><p id="0617" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li kl lj lk ll kp lm ln lo kt lp lq lr ls ig bi translated">这是 Java 虚拟机(JVM)中垃圾收集(GC)的任务，用于自动确定 Java 应用程序不再使用哪些内存，并回收这些内存用于其他用途。</p><h2 id="7089" class="kc kd in bd ke kf kg dn kh ki kj dp kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">总结:</h2><p id="b175" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li kl lj lk ll kp lm ln lo kt lp lq lr ls ig bi translated">在这篇文章中，我解释了垃圾收集(GC)和变量的类型，什么是堆和栈，变量在哪里，对象在哪里，我们知道一个对象有多长的寿命，垃圾收集会自动运行，我对此没有任何控制。</p></div></div>    
</body>
</html>