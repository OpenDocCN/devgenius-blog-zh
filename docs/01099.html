<html>
<head>
<title>Rxswift MVVM- Understand your ViewModel</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Rxswift MVVM-了解您的视图模型</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/rxswift-mvvm-understand-your-viewmodel-50e8fe12436b?source=collection_archive---------10-----------------------#2020-06-24">https://blog.devgenius.io/rxswift-mvvm-understand-your-viewmodel-50e8fe12436b?source=collection_archive---------10-----------------------#2020-06-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="b595" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">仅仅将逻辑代码移出ViewController是不够的</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/d3835a88a253d92ed44b956f58dbccc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ogQlFzpFO4A6EJb5"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">法比安·格罗斯在<a class="ae lb" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="881f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可能已经知道MVVM建筑公司，它在视图模型中有所有的逻辑。因此，您可以从视图和其他服务中分离出来，更加专注。结构如下:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi lc"><img src="../Images/95053315350085f9c95ffec8a66788b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:882/format:webp/1*6WlrEpcDHv-tD_pBloZUkg.png"/></div></figure><p id="184f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本文中，我将重点关注ViewModel。是的，我们有所有的逻辑，但这就是我们所需要的吗？显然，答案是否定的。我们必须做大量的工作来使代码简单、易读和可测试。</p><p id="e35a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了使代码可读和可测试，我们必须清楚地确认输入和输出。然后我们可以模拟输入并断言输出。基本上是这样的:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi ld"><img src="../Images/b47e8245e27ab6bd6ecc88e3e8a27e6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1296/format:webp/1*zAfS97cqUb3Yy5LEEogW3A.png"/></div></figure><ul class=""><li id="f531" class="le lf iq jp b jq jr ju jv jy lg kc lh kg li kk lj lk ll lm bi translated"><strong class="jp ir">输入</strong>主要指用户的交互或者视图初始化时发生的一些自动输入(网络调用)等。</li><li id="6b28" class="le lf iq jp b jq ln ju lo jy lp kc lq kg lr kk lj lk ll lm bi translated"><strong class="jp ir">输出</strong>是视图中绑定的值或函数。每当Viewmodel中的值发生变化时，视图层也会发生一些变化</li><li id="869b" class="le lf iq jp b jq ln ju lo jy lp kc lq kg lr kk lj lk ll lm bi translated">初始化是一种特殊的输入，叫做依赖注入。ViewModel必须进行初始化，以便进一步使用。通过这样做，ViewModel告诉视图:“嘿，如果你想使用我，给我我需要的东西！”</li></ul><p id="a531" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们看看Rxswift的“实时”代码是如何构建的:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="73c3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我相信这段代码清楚地表达了这三个部分:</p><ul class=""><li id="f05e" class="le lf iq jp b jq jr ju jv jy lg kc lh kg li kk lj lk ll lm bi translated">我们有ViewModelType协议来实现输入和输出</li><li id="de90" class="le lf iq jp b jq ln ju lo jy lp kc lq kg lr kk lj lk ll lm bi translated">我们用API管理器的init()方法来调用API数据</li><li id="512c" class="le lf iq jp b jq ln ju lo jy lp kc lq kg lr kk lj lk ll lm bi translated">在输入中:重载可以是视图通过调用API管理器中的requestData来刷新的一个特性</li><li id="a3a3" class="le lf iq jp b jq ln ju lo jy lp kc lq kg lr kk lj lk ll lm bi translated">在输出中:我们有View需要的所有可观察数据——文章、错误</li></ul><p id="6003" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以下是视图层中的代码:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ls lt l"/></div></figure><ul class=""><li id="2499" class="le lf iq jp b jq jr ju jv jy lg kc lh kg li kk lj lk ll lm bi translated">1:我们有依赖注入来初始化视图模型</li><li id="9dd8" class="le lf iq jp b jq ln ju lo jy lp kc lq kg lr kk lj lk ll lm bi translated">2:设置与商品数据的绑定</li><li id="51f3" class="le lf iq jp b jq ln ju lo jy lp kc lq kg lr kk lj lk ll lm bi translated">3:设置有错误的绑定</li><li id="e2e9" class="le lf iq jp b jq ln ju lo jy lp kc lq kg lr kk lj lk ll lm bi translated">4:触发输入—重新加载以启动API调用</li></ul><blockquote class="lu lv lw"><p id="3c67" class="jn jo lx jp b jq jr js jt ju jv jw jx ly jz ka kb lz kd ke kf ma kh ki kj kk ij bi translated">请注意:在Rxswift中，驱动程序和观察程序是懒惰的，它们在被订阅之前什么也不做。</p></blockquote><p id="22d8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在所有代码都工作之后，我们如何测试它呢？有了Rxswift的这种结构和测试时间表，测试变得更加容易。</p><p id="4387" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以让调度程序创建到输出的观察者绑定和到输入的可观察绑定。然后，我们模拟网络服务失败或成功，以测试断言的值。欲了解更多信息，请咨询:</p><div class="mb mc gp gr md me"><a href="https://benoitpasquier.com/how-to-use-rxtests-to-test-mvvm/" rel="noopener  ugc nofollow" target="_blank"><div class="mf ab fo"><div class="mg ab mh cl cj mi"><h2 class="bd ir gy z fp mj fr fs mk fu fw ip bi translated">rx swift &amp; MVVM——如何使用RxTests测试你的视图模型</h2><div class="ml l"><h3 class="bd b gy z fp mj fr fs mk fu fw dk translated">不久前，我在一个iOS项目中写了如何将RxSwift与MVVM架构配对。即使我重构了我的代码…</h3></div><div class="mm l"><p class="bd b dl z fp mj fr fs mk fu fw dk translated">benoitpasquier.com</p></div></div><div class="mn l"><div class="mo l mp mq mr mn ms kv me"/></div></div></a></div><h2 id="2ac3" class="mt mu iq bd mv mw mx dn my mz na dp nb jy nc nd ne kc nf ng nh kg ni nj nk nl bi translated">结论:</h2><p id="eb7f" class="pw-post-body-paragraph jn jo iq jp b jq nm js jt ju nn jw jx jy no ka kb kc np ke kf kg nq ki kj kk ij bi translated">总的来说，当我们起草视图模型时，最好明确指出输入和输出函数/变量。我们可以把它放在命名或使用协议中。</p><p id="b367" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">用于输出/输入。它应该是我们的公共/内部函数或可观察变量，因为它必须与其他对象交互。然后，我们有所有的私有函数或其他处理器类/结构来处理大部分内部逻辑。</p><p id="c003" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">感谢阅读！你可以在这里找到完整的演示<a class="ae lb" href="https://github.com/lee197/NYT-Articles/tree/master" rel="noopener ugc nofollow" target="_blank">,并随时留下任何评论！</a></p></div></div>    
</body>
</html>