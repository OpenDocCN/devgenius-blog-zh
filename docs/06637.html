<html>
<head>
<title>Linux CPU Context Switch Troubleshooting</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Linux CPU 上下文切换故障排除</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/linux-cpu-context-switch-troubleshooting-bda45883e59e?source=collection_archive---------0-----------------------#2022-01-22">https://blog.devgenius.io/linux-cpu-context-switch-troubleshooting-bda45883e59e?source=collection_archive---------0-----------------------#2022-01-22</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><div class=""><h2 id="74c3" class="pw-subtitle-paragraph jo iq ir bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated">如何排除 CPU 上下文切换故障</h2></div><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj kg"><img src="../Images/be33c9fc82a8ac3c32c958dc6e0995e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PB84JiibdCEhY6gmFTJLIQ.png"/></div></div></figure><p id="8c86" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">在我的上一篇文章:<a class="ae lo" href="https://medium.com/geekculture/linux-cpu-context-switch-deep-dive-764bfdae4f01" rel="noopener"> Linux CPU 上下文切换深度探讨</a>中，我谈到了 CPU 上下文切换是如何工作的。快速回顾一下，CPU 上下文切换是保证 Linux 系统正常运行的核心功能。分为<strong class="ku is">【进程上下文切换】</strong><strong class="ku is">【线程上下文切换】</strong><strong class="ku is">【中断上下文切换】</strong>。</p><p id="1bba" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">在这篇文章中，我将讨论如何分析 CPU 上下文切换问题。</p><h1 id="7e91" class="lp lq ir bd lr ls lt lu lv lw lx ly lz jx ma jy mb ka mc kb md kd me ke mf mg bi translated">检查 CPU 上下文切换</h1><p id="033c" class="pw-post-body-paragraph ks kt ir ku b kv mh js kx ky mi jv la lb mj ld le lf mk lh li lj ml ll lm ln ik bi translated">我们知道，过多的上下文切换会消耗 CPU 时间来保存和恢复数据，如寄存器、程序计数器、内核堆栈和虚拟内存等，这会导致系统性能显著下降。</p><p id="e280" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">既然上下文切换对系统性能有如此大的影响，我们如何检查上下文切换呢？嗯，你可以用<code class="fe mm mn mo mp b">vmstat</code>工具查询你系统的上下文切换。</p><h2 id="7243" class="mq lq ir bd lr mr ms dn lv mt mu dp lz lb mv mw mb lf mx my md lj mz na mf nb bi translated">vmstat</h2><p id="3226" class="pw-post-body-paragraph ks kt ir ku b kv mh js kx ky mi jv la lb mj ld le lf mk lh li lj ml ll lm ln ik bi translated"><code class="fe mm mn mo mp b">vmstat</code>是一种常用的系统性能分析工具。它主要用于分析内存使用情况，也常用于分析 CPU 上下文切换和中断的数量。</p><p id="b611" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">例如，<code class="fe mm mn mo mp b">vmstat 5</code> (5 秒输出间隔):</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div class="gi gj nc"><img src="../Images/301e0043b64bd735653ec0ce8f23724d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1136/format:webp/1*DJ0bKUGxns7S4YjwFos4_w.png"/></div><figcaption class="nd ne gk gi gj nf ng bd b be z dk translated">vmstat 示例</figcaption></figure><p id="d587" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">让我们来看看输出:</p><ul class=""><li id="efe4" class="nh ni ir ku b kv kw ky kz lb nj lf nk lj nl ln nm nn no np bi translated"><code class="fe mm mn mo mp b">cs</code>(上下文切换):每秒的上下文切换次数。</li><li id="9837" class="nh ni ir ku b kv nq ky nr lb ns lf nt lj nu ln nm nn no np bi translated"><code class="fe mm mn mo mp b">in</code>(中断):每秒中断的次数。</li><li id="2b06" class="nh ni ir ku b kv nq ky nr lb ns lf nt lj nu ln nm nn no np bi translated"><code class="fe mm mn mo mp b">r</code>(正在运行或可运行):就绪队列长度，即正在运行并等待 CPU 的进程数。</li><li id="d8a8" class="nh ni ir ku b kv nq ky nr lb ns lf nt lj nu ln nm nn no np bi translated"><code class="fe mm mn mo mp b">b</code>(阻塞):处于不可中断睡眠状态的进程数量。</li></ul><p id="eb4b" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">在上面的例子中，我们可以看到上下文切换次数为<code class="fe mm mn mo mp b">33</code>次，系统中断次数为<code class="fe mm mn mo mp b">25</code>次，就绪队列长度、不可中断状态进程数均为 0。</p><h2 id="026d" class="mq lq ir bd lr mr ms dn lv mt mu dp lz lb mv mw mb lf mx my md lj mz na mf nb bi translated">pidstat</h2><p id="a82b" class="pw-post-body-paragraph ks kt ir ku b kv mh js kx ky mi jv la lb mj ld le lf mk lh li lj ml ll lm ln ik bi translated">然而，<code class="fe mm mn mo mp b">vmstat</code>只给出了系统的整体上下文切换。要查看每个过程的详细信息，您需要使用<code class="fe mm mn mo mp b">pidstat</code>。添加<code class="fe mm mn mo mp b">-w</code>选项，您可以看到每个流程的上下文切换:</p><p id="8604" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">例如:</p><pre class="kh ki kj kk gu nv mp nw nx aw ny bi"><span id="5c51" class="mq lq ir mp b gz nz oa l ob oc"># Output interval is 5<br/>$ pidstat -w 5<br/>Linux 4.15.0 (ubuntu)  09/23/18  _x86_64_  (2 CPU)</span><span id="2b70" class="mq lq ir mp b gz od oa l ob oc">08:18:26      UID       PID   cswch/s nvcswch/s  Command<br/>08:18:31        0         1      0.20      0.00  systemd<br/>08:18:31        0         8      5.40      0.00  rcu_sched<br/>...</span></pre><p id="7a43" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">这个结果中有两列需要我们注意:<code class="fe mm mn mo mp b">cswch</code>和<code class="fe mm mn mo mp b">nvcswch</code>。</p><p id="0588" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated"><code class="fe mm mn mo mp b">cswch</code>表示每秒自愿上下文切换的次数，<code class="fe mm mn mo mp b">nvcswch</code>表示每秒非自愿上下文切换的次数。</p><ul class=""><li id="aaed" class="nh ni ir ku b kv kw ky kz lb nj lf nk lj nl ln nm nn no np bi translated"><strong class="ku is">自愿上下文切换是指进程无法获得所需资源而导致的上下文切换。</strong>例如，当 I/O 和内存等系统资源不足时，会发生自愿上下文切换。</li><li id="a4a4" class="nh ni ir ku b kv nq ky nr lb ns lf nt lj nu ln nm nn no np bi translated"><strong class="ku is">非自愿上下文切换是指由于时间片过期，流程被系统强制重新调度时发生的上下文切换。</strong>比如大量进程争用 CPU 时，容易出现不自觉的上下文切换。</li></ul><p id="ab93" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">您必须记住这两个概念，因为它们意味着不同的性能问题。</p><h1 id="29bf" class="lp lq ir bd lr ls lt lu lv lw lx ly lz jx ma jy mb ka mc kb md kd me ke mf mg bi translated">个案分析</h1><p id="cf31" class="pw-post-body-paragraph ks kt ir ku b kv mh js kx ky mi jv la lb mj ld le lf mk lh li lj ml ll lm ln ik bi translated">现在您已经知道如何查看这些指标，另一个问题出现了。上下文切换频率多久被认为是正常的？让我们来看一个案例。</p><p id="da39" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">我们将使用【https://github.com/akopytov/sysbenc】(<a class="ae lo" href="https://github.com/akopytov/sysbench" rel="noopener ugc nofollow" target="_blank">)</a>，一个多线程的基准测试工具来生成负载，以模拟上下文切换过多的问题。假设您已经在 Linux 系统上安装了<code class="fe mm mn mo mp b">sysbench</code>和<code class="fe mm mn mo mp b">sysstat</code>。</p><p id="df9a" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">在我们模拟负载之前，让我们在一个终端中运行<code class="fe mm mn mo mp b">vmstat</code>:</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div class="gi gj nc"><img src="../Images/7c0775efb574132394eb571c11e5c75b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1136/format:webp/1*kaQo_h9ajVKgr9bUTye9xA.png"/></div></figure><p id="8b1b" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">这里可以看到当前的上下文切换数<code class="fe mm mn mo mp b">cs</code>是 35，中断数<code class="fe mm mn mo mp b">in</code>是 19，<code class="fe mm mn mo mp b">r</code>和<code class="fe mm mn mo mp b">b</code>都是 0。因为此刻我没有其他任务在运行，所以它们是空闲系统的上下文切换次数。</p><p id="4cf5" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">让我们运行<code class="fe mm mn mo mp b">sysbench</code>来模拟多线程调度系统的瓶颈:</p><pre class="kh ki kj kk gu nv mp nw nx aw ny bi"><span id="51d7" class="mq lq ir mp b gz nz oa l ob oc">$ sysbench --threads=10 --max-time=300 threads run</span></pre><p id="e9a4" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">现在，您应该会看到<code class="fe mm mn mo mp b">vmstat</code>的不同输出:</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div class="gi gj oe"><img src="../Images/ed8f70a6017da4659bdac6e500e89e70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1142/format:webp/1*EhV23EXuoemoYsZc83yqcA.png"/></div></figure><p id="e6c0" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">你应该能发现<code class="fe mm mn mo mp b">cs</code>列的上下文切换次数从之前的<code class="fe mm mn mo mp b">35</code>急剧上升到<code class="fe mm mn mo mp b">1.39</code>百万。同时，注意观察其他几个指标:</p><ul class=""><li id="b8d3" class="nh ni ir ku b kv kw ky kz lb nj lf nk lj nl ln nm nn no np bi translated"><code class="fe mm mn mo mp b">r</code>:就绪队列长度已达到 8</li><li id="dbe2" class="nh ni ir ku b kv nq ky nr lb ns lf nt lj nu ln nm nn no np bi translated"><code class="fe mm mn mo mp b">us</code>和<code class="fe mm mn mo mp b">sy</code>:<code class="fe mm mn mo mp b">us</code>和<code class="fe mm mn mo mp b">sy</code>的 CPU 使用率加起来是 100%，系统 CPU 使用率是 85%，说明 CPU 主要被内核占用。</li><li id="08d6" class="nh ni ir ku b kv nq ky nr lb ns lf nt lj nu ln nm nn no np bi translated"><code class="fe mm mn mo mp b">in</code>:中断的数量也上升到了 10000，说明中断处理也是一个潜在的问题。</li></ul><p id="552c" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">结合这些指标，我们可以知道系统的就绪队列过长，也就是有太多的进程在运行，等待 CPU，导致大量的上下文切换，上下文切换导致系统 CPU 使用率增加。</p><p id="7bb4" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">那么是什么过程导致了这些问题呢？</p><p id="926d" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">我们继续分析使用第三终端中的<code class="fe mm mn mo mp b">pidstat</code>来看看 CPU 和进程上下文切换的情况:</p><pre class="kh ki kj kk gu nv mp nw nx aw ny bi"><span id="e557" class="mq lq ir mp b gz nz oa l ob oc"># 1 means output interval is 1 second<br/># -w: output process switching index，<br/># -u: output CPU usage index<br/>$ pidstat -w -u 1<br/>08:06:33      UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command<br/>08:06:34        0     10488   30.00  <strong class="mp is">100.00</strong>    0.00    0.00  100.00     0  <strong class="mp is">sysbench</strong><br/>08:06:34        0     26326    0.00    1.00    0.00    0.00    1.00     0  kworker/u4:2</span><span id="d15b" class="mq lq ir mp b gz od oa l ob oc">08:06:33      UID       PID   cswch/s nvcswch/s  Command<br/>08:06:34        0         8     11.00      0.00  rcu_sched<br/>08:06:34        0        16      1.00      0.00  ksoftirqd/1<br/>08:06:34        0       471      1.00      0.00  hv_balloon<br/>08:06:34        0      1230      1.00      0.00  iscsid<br/>08:06:34        0      4089      1.00      0.00  kworker/1:5<br/>08:06:34        0      4333      1.00      0.00  kworker/0:3<br/>08:06:34        0     10499      1.00    224.00  pidstat<br/>08:06:34        0     26326    236.00      0.00  kworker/u4:2<br/>08:06:34     1000     26784    223.00      0.00  sshd</span></pre><p id="0911" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">从<code class="fe mm mn mo mp b">pidstat</code>的输出可以发现，CPU 使用率的增加确实是由<code class="fe mm mn mo mp b">sysbench</code>引起的，它的 CPU 使用率已经达到了 100%。但是上下文切换来自其他进程，包括<strong class="ku is">非自愿</strong>上下文切换频率最高的<code class="fe mm mn mo mp b">pidstat</code>，以及<strong class="ku is">自愿</strong>上下文切换频率最高的内核线程<code class="fe mm mn mo mp b">kworker</code>和<code class="fe mm mn mo mp b">sshd</code>。</p><p id="684f" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">注意:默认情况下<code class="fe mm mn mo mp b">pidstat</code>只显示进程上下文切换，如果你想看到实际的线程上下文切换，添加<code class="fe mm mn mo mp b">-t</code>参数。</p><h2 id="977f" class="mq lq ir bd lr mr ms dn lv mt mu dp lz lb mv mw mb lf mx my md lj mz na mf nb bi translated">中断</h2><p id="4329" class="pw-post-body-paragraph ks kt ir ku b kv mh js kx ky mi jv la lb mj ld le lf mk lh li lj ml ll lm ln ik bi translated">要找出中断数量也很高的原因，您可以检查<code class="fe mm mn mo mp b">/proc/interrupts</code>文件。该文件提供了只读中断用法。</p><pre class="kh ki kj kk gu nv mp nw nx aw ny bi"><span id="26c2" class="mq lq ir mp b gz nz oa l ob oc"># -d: Highlight the change area<br/>$ watch -d cat /proc/interrupts<br/>           CPU0       CPU1<br/>...<br/>RES:    2450431    5279697   Rescheduling interrupts<br/>...</span></pre><p id="64ce" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">观察一段时间后，可以发现变化最快的是重调度中断(RES)。这种中断类型表示处于空闲状态的 CPU 被唤醒以调度新任务运行。所以这里中断的增加是因为任务太多的调度问题，这和前面上下文切换次数的分析结果是一致的。</p><p id="0ea2" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">现在回到最初的问题，每秒多少次上下文切换是正常的？</p><p id="3c0e" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">这个值其实取决于系统本身的 CPU 性能。在我看来，如果系统的上下文切换次数比较稳定的话，几百到一万次应该是正常的。但是，当上下文切换次数超过 10，000 次，或者切换次数快速增加时，很可能出现了性能问题。</p><h1 id="1d69" class="lp lq ir bd lr ls lt lu lv lw lx ly lz jx ma jy mb ka mc kb md kd me ke mf mg bi translated">结论</h1><p id="a2ba" class="pw-post-body-paragraph ks kt ir ku b kv mh js kx ky mi jv la lb mj ld le lf mk lh li lj ml ll lm ln ik bi translated">此时，你应该可以根据上下文切换的类型做一些具体的分析了。</p><ul class=""><li id="890c" class="nh ni ir ku b kv kw ky kz lb nj lf nk lj nl ln nm nn no np bi translated">有更多的自愿上下文切换，表明进程正在等待资源，并且可能出现其他问题，如 I/O 饱和</li><li id="0042" class="nh ni ir ku b kv nq ky nr lb ns lf nt lj nu ln nm nn no np bi translated">非自愿的上下文切换比较多，说明进程是被强制调度的，也就是都在争 CPU，说明 CPU 确实成了瓶颈</li><li id="393f" class="nh ni ir ku b kv nq ky nr lb ns lf nt lj nu ln nm nn no np bi translated">中断次数增加，说明 CPU 被中断处理程序占用，你需要通过查看<code class="fe mm mn mo mp b">/proc/interrupts</code>文件来分析具体的中断类型。</li></ul></div></div>    
</body>
</html>