<html>
<head>
<title>K8s — Container Network Namespace</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">K8s —容器网络命名空间</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/k8s-container-network-df1a6c23c0c3?source=collection_archive---------2-----------------------#2022-12-15">https://blog.devgenius.io/k8s-container-network-df1a6c23c0c3?source=collection_archive---------2-----------------------#2022-12-15</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><div class=""><h2 id="38d2" class="pw-subtitle-paragraph jo iq ir bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated">容器网络名称空间深入探讨</h2></div><figure class="kg kh ki kj gu kk gi gj paragraph-image"><div class="ab gv cl kl"><img src="../Images/c25c7843907745d564abf8e4d43659e4.png" data-original-src="https://miro.medium.com/v2/format:webp/0*kElNJxeOHApCzL8b.png"/></div></figure><h1 id="630b" class="ko kp ir bd kq kr ks kt ku kv kw kx ky jx kz jy la ka lb kb lc kd ld ke le lf bi translated">了解容器网络名称空间</h1><p id="66d2" class="pw-post-body-paragraph lg lh ir li b lj lk js ll lm ln jv lo lp lq lr ls lt lu lv lw lx ly lz ma mb ik bi translated">关于网络命名空间，如果从字面上理解，我们知道它是网络在一个 Linux 节点上的隔离，但是它具体隔离了网络资源的哪一部分呢？</p><p id="f1c1" class="pw-post-body-paragraph lg lh ir li b lj mc js ll lm md jv lo lp me lr ls lt mf lv lw lx mg lz ma mb ik bi translated">先说<code class="fe mh mi mj mk b">Linux Programmer's Manual</code>。在本手册中，它有一个简短的描述，并列出了网络名称空间的一些主要资源。</p><figure class="kg kh ki kj gu kk gi gj paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gi gj ml"><img src="../Images/ec720e6c79eba1add57b54fcaf774467.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*0MUshHjVAXviwihb.png"/></div></div></figure><h1 id="f645" class="ko kp ir bd kq kr ks kt ku kv kw kx ky jx kz jy la ka lb kb lc kd ld ke le lf bi translated">网络命名空间资源</h1><ul class=""><li id="b838" class="mq mr ir li b lj lk lm ln lp ms lt mt lx mu mb mv mw mx my bi translated"><strong class="li is">网络设备:</strong> <em class="mz">指</em> <code class="fe mh mi mj mk b"><em class="mz">lo</em></code> <em class="mz">、</em> <code class="fe mh mi mj mk b"><em class="mz">eth0</em></code> <em class="mz">等网络设备。你可以通过</em> <code class="fe mh mi mj mk b"><em class="mz">ip link</em></code> <em class="mz">命令看到它们。</em></li><li id="d06e" class="mq mr ir li b lj na lm nb lp nc lt nd lx ne mb mv mw mx my bi translated"><strong class="li is"> IPv4 和 IPv6 协议栈:</strong> <em class="mz">从协议栈我们知道，上面的 IP 层和 TCP、UDP 协议栈也是为每个命名空间独立工作的。因此，对于 IP、TCP 和 UDP 等许多协议，它们的相关参数也独立于每个名称空间。这些参数大多在</em> <code class="fe mh mi mj mk b"><em class="mz">/proc/sys/net/</em></code> <em class="mz">目录下，也包括 TCP 和 UDP 端口资源。</em></li><li id="37a7" class="mq mr ir li b lj na lm nb lp nc lt nd lx ne mb mv mw mx my bi translated"><strong class="li is"> IP 路由表:</strong> <em class="mz">这个资源也比较好理解。可以在不同的网络命名空间运行</em> <code class="fe mh mi mj mk b"><em class="mz">ip route</em></code> <em class="mz">命令，查看不同的路由表。</em></li><li id="9a1a" class="mq mr ir li b lj na lm nb lp nc lt nd lx ne mb mv mw mx my bi translated"><strong class="li is">防火墙规则:</strong> <em class="mz">其实我说的是</em> <code class="fe mh mi mj mk b"><em class="mz">iptables</em></code> <em class="mz">规则，</em> <code class="fe mh mi mj mk b"><em class="mz">iptables</em></code> <em class="mz">规则可以在各个命名空间独立配置。</em></li><li id="2c3c" class="mq mr ir li b lj na lm nb lp nc lt nd lx ne mb mv mw mx my bi translated"><strong class="li is">网络状态信息:</strong> <em class="mz">您可以从</em> <code class="fe mh mi mj mk b"><em class="mz">/proc/net</em></code> <em class="mz">和</em> <code class="fe mh mi mj mk b"><em class="mz">/sys/class/net</em></code> <em class="mz">中获得这些信息。这里的状态基本包括前面四种资源的状态信息。</em></li></ul><h1 id="105d" class="ko kp ir bd kq kr ks kt ku kv kw kx ky jx kz jy la ka lb kb lc kd ld ke le lf bi translated">如何创建网络命名空间？</h1><p id="d7fb" class="pw-post-body-paragraph lg lh ir li b lj lk js ll lm ln jv lo lp lq lr ls lt lu lv lw lx ly lz ma mb ik bi translated">我们可以通过调用<code class="fe mh mi mj mk b">clone()</code>或<code class="fe mh mi mj mk b">unshare()</code>函数来创建一个新的网络名称空间。</p><h2 id="ed7f" class="nf kp ir bd kq ng nh dn ku ni nj dp ky lp nk nl la lt nm nn lc lx no np le nq bi translated">clone()函数</h2><p id="3fcb" class="pw-post-body-paragraph lg lh ir li b lj lk js ll lm ln jv lo lp lq lr ls lt lu lv lw lx ly lz ma mb ik bi translated">当创建新进程时，随着新进程的创建，也创建了新的网络名称空间。这个方法实际上是通过将<code class="fe mh mi mj mk b">CLONE_NEWNET</code>标志附加到<code class="fe mh mi mj mk b">clone()</code>系统调用上来实现的。以防您对源代码感兴趣:</p><pre class="kg kh ki kj gu nr mk ns bn nt nu bi"><span id="116c" class="nv kp ir mk b be nw nx l ny nz">int new_netns(void *para)<br/>{<br/>            printf("New Namespace Devices:\n");<br/>            system("ip link");<br/>            printf("\n\n");<br/> <br/>            sleep(100);<br/>            return 0;<br/>}<br/> <br/>int main(void)<br/>{<br/>            pid_t pid;<br/> <br/>            printf("Host Namespace Devices:\n");<br/>            system("ip link");<br/>            printf("\n\n");<br/> <br/>            pid =<br/>                clone(new_netns, stack + STACK_SIZE, CLONE_NEWNET | SIGCHLD, NULL);<br/>            if (pid == -1)<br/>                        errExit("clone");<br/> <br/>            if (waitpid(pid, NULL, 0) == -1)<br/>                        errExit("waitpid");<br/> <br/>            return 0;<br/>}</span></pre><h2 id="7b83" class="nf kp ir bd kq ng nh dn ku ni nj dp ky lp nk nl la lt nm nn lc lx no np le nq bi translated">unshare()函数</h2><p id="fdb8" class="pw-post-body-paragraph lg lh ir li b lj lk js ll lm ln jv lo lp lq lr ls lt lu lv lw lx ly lz ma mb ik bi translated">我们可以调用<code class="fe mh mi mj mk b">unshare()</code>系统调用来直接改变当前进程的网络名称空间。同样，我贴出了您感兴趣的源代码:</p><pre class="kg kh ki kj gu nr mk ns bn nt nu bi"><span id="cbc9" class="nv kp ir mk b be nw nx l ny nz">int main(void)<br/>{<br/>            pid_t pid;<br/> <br/>            printf("Host Namespace Devices:\n");<br/>            system("ip link");<br/>            printf("\n\n");<br/> <br/>            if (unshare(CLONE_NEWNET) == -1)<br/>                        errExit("unshare");<br/> <br/>            printf("New Namespace Devices:\n");<br/>            system("ip link");<br/>            printf("\n\n");<br/> <br/>            return 0;<br/>}</span></pre><p id="681c" class="pw-post-body-paragraph lg lh ir li b lj mc js ll lm md jv lo lp me lr ls lt mf lv lw lx mg lz ma mb ik bi translated"><strong class="li is">注意:</strong>不仅是网络命名空间，其他命名空间也是通过<code class="fe mh mi mj mk b">clone()</code>或<code class="fe mh mi mj mk b">unshare()</code>函数调用建立的。甚至容器创建程序，比如<code class="fe mh mi mj mk b">runC</code>，也使用<code class="fe mh mi mj mk b">unshare()</code>为新创建的容器创建名称空间。<code class="fe mh mi mj mk b">runC</code>是一个 CLI 工具，用于根据 OCI 规范(<a class="ae oa" href="https://github.com/opencontainers/runc" rel="noopener ugc nofollow" target="_blank">https://github.com/opencontainers/runc</a>)在 Linux 上生成和运行容器。</p><p id="4949" class="pw-post-body-paragraph lg lh ir li b lj mc js ll lm md jv lo lp me lr ls lt mf lv lw lx mg lz ma mb ik bi translated">创建网络名称空间后，我们可以在主机上运行命令<code class="fe mh mi mj mk b">lsns -t net</code>来查看系统中现有的网络名称空间。当然，<code class="fe mh mi mj mk b">lsns</code>也可以用来查看其他名称空间。</p><p id="1e3a" class="pw-post-body-paragraph lg lh ir li b lj mc js ll lm md jv lo lp me lr ls lt mf lv lw lx mg lz ma mb ik bi translated">让我们快速运行一个示例:</p><pre class="kg kh ki kj gu nr mk ns bn nt nu bi"><span id="9225" class="nv kp ir mk b be nw nx l ny nz">$ gcc -o clone-ns clone-ns.c<br/>$ ls<br/>clone-ns.c clone-ns<br/>$ ./clone-ns<br/>Host Namespace Devices:<br/>1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000<br/>    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00<br/>2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 9001 qdisc mq state UP mode DEFAULT group default qlen 1000<br/>    link/ether 0a:e7:39:38:d4:5b brd ff:ff:ff:ff:ff:ffclone: Operation not permitted<br/>[ec2-user@devops101 namespace]$ sudo ./clone-ns<br/>Host Namespace Devices:<br/>1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000<br/>    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00<br/>2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 9001 qdisc mq state UP mode DEFAULT group default qlen 1000<br/>    link/ether 0a:e7:39:38:d4:5b brd ff:ff:ff:ff:ff:ffNew Namespace Devices:<br/>1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN mode DEFAULT group default qlen 1000<br/>    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span></pre><p id="0a7b" class="pw-post-body-paragraph lg lh ir li b lj mc js ll lm md jv lo lp me lr ls lt mf lv lw lx mg lz ma mb ik bi translated">截图:</p><figure class="kg kh ki kj gu kk gi gj paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gi gj ob"><img src="../Images/30bea6ba03c33240ada012e2c2dc05f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*RdRfTe68ewXE7-5p.png"/></div></div></figure><figure class="kg kh ki kj gu kk gi gj paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gi gj oc"><img src="../Images/a4f316be764e2f2e1c9434a5dc3a8172.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Xdsj7fIGHvHZ2vi2.png"/></div></div></figure><h1 id="d17a" class="ko kp ir bd kq kr ks kt ku kv kw kx ky jx kz jy la ka lb kb lc kd ld ke le lf bi translated">如何设置集装箱网络参数？</h1><p id="d41a" class="pw-post-body-paragraph lg lh ir li b lj lk js ll lm ln jv lo lp lq lr ls lt lu lv lw lx ly lz ma mb ik bi translated">现在我们对<code class="fe mh mi mj mk b">Network Namespace</code>有了更多的了解，让我们看看如何设置容器网络参数。</p><p id="c824" class="pw-post-body-paragraph lg lh ir li b lj mc js ll lm md jv lo lp me lr ls lt mf lv lw lx mg lz ma mb ik bi translated">但首先你需要明白，容器中的<code class="fe mh mi mj mk b">Network Namespace</code>的网络参数并不是完全继承自主机的主机命名空间，也不是在建立新的<code class="fe mh mi mj mk b">Network Namespace</code>时完全重新初始化。</p><p id="4f89" class="pw-post-body-paragraph lg lh ir li b lj mc js ll lm md jv lo lp me lr ls lt mf lv lw lx mg lz ma mb ik bi translated">让我们以<code class="fe mh mi mj mk b">httpd</code>容器为例，尝试更新这个容器中的网络设置，看看会发生什么:</p><figure class="kg kh ki kj gu kk gi gj paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gi gj od"><img src="../Images/d9b0895dd5d28673900e9633cc0fa2a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*X_PtpGjqaXvoxFiF.png"/></div></div></figure><p id="9fd8" class="pw-post-body-paragraph lg lh ir li b lj mc js ll lm md jv lo lp me lr ls lt mf lv lw lx mg lz ma mb ik bi translated">啊哈，我们做不到，因为<code class="fe mh mi mj mk b">/proc/sys</code>被安装为<code class="fe mh mi mj mk b">read-only</code>。我们可以通过运行以下命令进行验证:</p><pre class="kg kh ki kj gu nr mk ns bn nt nu bi"><span id="28fb" class="nv kp ir mk b be nw nx l ny nz">[root@b4e702116ae5 /]# cat /proc/mounts | grep "proc/sys"<br/>proc /proc/sys proc ro,nosuid,nodev,noexec,relatime 0 0<br/>proc /proc/sysrq-trigger proc ro,nosuid,nodev,noexec,relatime 0 0</span></pre><p id="b4c1" class="pw-post-body-paragraph lg lh ir li b lj mc js ll lm md jv lo lp me lr ls lt mf lv lw lx mg lz ma mb ik bi translated">为什么<code class="fe mh mi mj mk b">/proc/sys</code>在容器中是只读挂载？出于安全考虑，<code class="fe mh mi mj mk b">runC</code>默认情况下将容器中所有与/proc 和/sys 相关的目录作为只读挂载来处理。</p><p id="8d2e" class="pw-post-body-paragraph lg lh ir li b lj mc js ll lm md jv lo lp me lr ls lt mf lv lw lx mg lz ma mb ik bi translated">那我们怎么做？如果您在主机上拥有 root 权限。最简单粗暴的方法就是使用我们前面提到的<code class="fe mh mi mj mk b">nsenter</code>命令来修改容器中的网络参数。但是，<strong class="li is">这种方法在</strong>生产环境中显然是不允许的，因为我们不会允许用户拥有主机的登录权限。</p><p id="88a7" class="pw-post-body-paragraph lg lh ir li b lj mc js ll lm md jv lo lp me lr ls lt mf lv lw lx mg lz ma mb ik bi translated">一般来说，这样的更改应该只在容器中的应用程序启动之前进行。否则许多 tcp 链接将已经建立，所以即使新的参数被改变，已建立的链接也不会生效。这需要重新启动应用程序。我们都知道在生产环境中通常会避免应用程序重启，这显然是不合适的。</p><p id="95f3" class="pw-post-body-paragraph lg lh ir li b lj mc js ll lm md jv lo lp me lr ls lt mf lv lw lx mg lz ma mb ik bi translated">所以改变网络参数的最佳时机显然是刚启动的容器，而容器中的应用程序还没有启动的时候。</p><h1 id="1ef8" class="ko kp ir bd kq kr ks kt ku kv kw kx ky jx kz jy la ka lb kb lc kd ld ke le lf bi translated">码头系统</h1><p id="f713" class="pw-post-body-paragraph lg lh ir li b lj lk js ll lm ln jv lo lp lq lr ls lt lu lv lw lx ly lz ma mb ik bi translated">其实<code class="fe mh mi mj mk b">runC</code>在对<code class="fe mh mi mj mk b">/proc/sys</code>目录做只读挂载之前也预留了一个修改接口，用来修改容器中“/proc/sys”下的参数，也是<code class="fe mh mi mj mk b">sysctl</code>的参数。</p><p id="b27b" class="pw-post-body-paragraph lg lh ir li b lj mc js ll lm md jv lo lp me lr ls lt mf lv lw lx mg lz ma mb ik bi translated">例如:</p><pre class="kg kh ki kj gu nr mk ns bn nt nu bi"><span id="a180" class="nv kp ir mk b be nw nx l ny nz">[root@devops101 ~]# docker run -d --name httpd --sysctl net.ipv4.tcp_keepalive_time=600 registry/httpd:v1<br/>bbba53b0deb4ca3c4221fbf6e8bd82aee4678da2c80844f5260a4c427e441ce9<br/>[root@devops101 ~]# docker exec httpd cat /proc/sys/net/ipv4/tcp_keepalive_time<br/>600</span></pre><h1 id="539d" class="ko kp ir bd kq kr ks kt ku kv kw kx ky jx kz jy la ka lb kb lc kd ld ke le lf bi translated">结论</h1><p id="011b" class="pw-post-body-paragraph lg lh ir li b lj lk js ll lm ln jv lo lp lq lr ls lt lu lv lw lx ly lz ma mb ik bi translated">我在下图中总结了用于网络命名空间参数更新的工具/命令:</p><figure class="kg kh ki kj gu kk gi gj paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gi gj oe"><img src="../Images/ffa06fdc3bd6c84a2f965e9293285525.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*RZslyjwuNPthZdFm.png"/></div></div></figure></div></div>    
</body>
</html>