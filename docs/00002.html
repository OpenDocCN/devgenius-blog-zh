<html>
<head>
<title>Docking A Docker Container — Part 2 : Namespace, cgroup</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">停靠 Docker 容器—第 2 部分:名称空间，cgroup</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/docking-a-docker-container-part-2-c1206e7c6677?source=collection_archive---------1-----------------------#2016-10-31">https://blog.devgenius.io/docking-a-docker-container-part-2-c1206e7c6677?source=collection_archive---------1-----------------------#2016-10-31</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="e469" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae ki" href="https://medium.com/@tomdeore/docking-a-docker-container-part-1-6d67d51543c3#.gqlb01rmm" rel="noopener">本系列的上一篇</a>博客。</p></div><div class="ab cl kj kk hr kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="ig ih ii ij ik"><blockquote class="kq kr ks"><p id="f483" class="jk jl kt jm b jn jo jp jq jr js jt ju ku jw jx jy kv ka kb kc kw ke kf kg kh ig bi translated">帮助弱者！打击网络犯罪<a class="ae ki" href="https://forms.gle/JWAPHzf2gd7jGq2YA" rel="noopener ugc nofollow" target="_blank">了解如何</a>。</p></blockquote></div><div class="ab cl kj kk hr kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="ig ih ii ij ik"><p id="b5ce" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi kx translated"><span class="l ky kz la bm lb lc ld le lf di">在我的上一篇文章中，我总结说 docker 是一个平台，所以让我们理解一下，以及如何在设计中使用 docker。但是，在我们进入 docker 的使用部分之前，有必要看看它的内部，因为这使我们能够更好地讨论任何应用程序的设计。</span></p><p id="3b01" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Docker 是一个轻量级软件，它为应用程序创建了一个隔离的执行环境，其中没有两个应用程序可以相互干扰，但每个应用程序都认为它们是单独运行在整个系统上的。Docker 不是一个虚拟机，而是一堆具有特殊属性的进程，运行在普通的 linux 内核上，比虚拟机更透明。Docker 并不驻留在内核中，但是“namespace”和“cgroups”驻留在内核中，docker 使用它们创建了一个叫做 container 的舒适的小环境。听起来是不是很有趣？所以让我们进入内部，它利用现有 linux 资源的方式，特别是<strong class="jm io"> <em class="kt">名称空间</em> </strong>。这篇文章讨论了如何在 Linux 上创建这样一个环境。</p><h1 id="9b0b" class="lg lh in bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">Linux 名称空间和 Docker 隔离</h1><p id="aefd" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">为什么需要隔离？简而言之:安全性、高可用性、避免依赖性、可测试性、部署等。该需求还要求对应用程序进行更好的控制，这是通过将应用程序分解成小的逻辑子系统(在每个容器中)来实现的，这样就可以独立、方便地对它们进行监控。但是不要因为把应用程序分解得太小而忘乎所以，这样会增加容器本身的延迟和开销。顺便说一下，这样将一个大的应用程序分解成小的逻辑部分叫做<a class="ae ki" href="https://en.wikipedia.org/wiki/Microservices" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> <em class="kt">微服务</em> </strong> </a>。</p><p id="ffae" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在真正重要的是如何隔离容器？这是通过在“容器”中运行流程来实现的。“没错！”在 docker 容器中运行 UNIX 进程就像在虚拟机中运行它们一样。虚拟机(VM)通常通过在主机操作系统上运行来宾操作系统来模拟硬件，以创建进程隔离，因此 VM 非常重。而 Docker 容器使用很少的操作系统特性(包括名称空间)并创建轻量级隔离。</p><h2 id="e7d5" class="mj lh in bd li mk ml dn lm mm mn dp lq jv mo mp lu jz mq mr ly kd ms mt mc mu bi translated">Linux 名称空间</h2><p id="615b" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">随着 Linux <a class="ae ki" href="https://en.wikipedia.org/wiki/Linux_namespaces" rel="noopener ugc nofollow" target="_blank">名称空间</a>的引入，“嵌套”进程树成为可能，这意味着每个进程都可以拥有自己独立的进程树以及系统资源，如(进程 id、主机名、用户 id、网络访问、<a class="ae ki" href="https://en.wikipedia.org/wiki/Interprocess_communication" rel="noopener ugc nofollow" target="_blank">进程间通信</a>和<a class="ae ki" href="https://en.wikipedia.org/wiki/Filesystem" rel="noopener ugc nofollow" target="_blank">文件系统</a>)。现在，来自不同进程树的进程不能检查/终止另一个进程树中的进程。</p><figure class="mw mx my mz gt na gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi mv"><img src="../Images/fe1e49a83969c7214276d8ae018b3b43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6DTQyWKaLfIs4zmi_ykSMw.png"/></div></div></figure><p id="9411" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">每次系统启动时，PID1(也称为“init”或 root)进程都会启动，树中该进程下的所有其他进程都会启动。使用 PID 命名空间隔离，子命名空间中的进程无法知道父进程的存在。但是，父命名空间中的进程拥有子命名空间中进程的完整视图，就像它们是父命名空间中的任何其他进程一样。</p><ul class=""><li id="cc36" class="nh ni in jm b jn jo jr js jv nj jz nk kd nl kh nm nn no np bi translated">为容器创建一个新的命名空间，并在 for <a class="ae ki" href="https://linux.die.net/man/2/clone" rel="noopener ugc nofollow" target="_blank"> clone </a>()系统调用中定义特定的标志。</li></ul><pre class="mw mx my mz gt nq nr ns nt aw nu bi"><span id="7722" class="mj lh in nr b gy nv nw l nx ny">/* <strong class="nr io">CLONE_NEWPID</strong> would create new PID namespace */<br/>clone(cb, *stack, <strong class="nr io">CLONE_NEWPID</strong> | SIGCLD, NULL); </span></pre><ul class=""><li id="08b6" class="nh ni in jm b jn jo jr js jv nj jz nk kd nl kh nm nn no np bi translated">同样，每个容器可以有自己的网络名称空间。这实质上意味着每个容器都有自己的网络堆栈(设备接口、TCP/IP 协议栈、IP 表、防火墙规则、目录树等)</li></ul><pre class="mw mx my mz gt nq nr ns nt aw nu bi"><span id="b767" class="mj lh in nr b gy nv nw l nx ny">/* <strong class="nr io">CLONE_NEWNET</strong> would create new network namespace */<br/>clone(cb, *stack, CLONE_NEWPID | <strong class="nr io">CLONE_NEWNET</strong> | SIGCLD, NULL);</span></pre><ul class=""><li id="336f" class="nh ni in jm b jn jo jr js jv nj jz nk kd nl kh nm nn no np bi translated">所有进程都存在于挂载命名空间中，启用该特性的标志是 CLONE_NEWNS</li></ul><pre class="mw mx my mz gt nq nr ns nt aw nu bi"><span id="2c65" class="mj lh in nr b gy nv nw l nx ny">/* <strong class="nr io">CLONE_NEWNS</strong> would create new mount namespace */<br/>clone(cb, *stack, CLONE_NEWPID | CLONE_NEWNET | <strong class="nr io">CLONE_NEWNS </strong>| SIGCLD, NULL);</span></pre><ul class=""><li id="3e1c" class="nh ni in jm b jn jo jr js jv nj jz nk kd nl kh nm nn no np bi translated">进程间通信(<strong class="jm io"> IPC </strong>)，UNIX 分时系统(<strong class="jm io"> UTS </strong>)，用户 ID:</li></ul><pre class="mw mx my mz gt nq nr ns nt aw nu bi"><span id="bbd9" class="mj lh in nr b gy nv nw l nx ny">/* <strong class="nr io">CLONE_NEWUTS | CLONE_NEWIPC</strong> would create new PID namespace */<br/>clone(cb, *stack, CLONE_NEWPID | CLONE_NEWNET | CLONE_NEWNS | <strong class="nr io">CLONE_UTS | CLONE_NEWIPC</strong> | SIGCLD, NULL);</span></pre><p id="ab6e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">到目前为止，我们已经了解了如何在一个系统中隔离容器，为它们提供运行所需的所有流程级基础设施。现在，问题来了，如果这些容器的管理是为了忠实的系统利用率，或者某种方式来控制基于容器的系统以获得更好的系统资源利用率，会怎么样呢？幸运的是，这个谜团可以通过另一个名为<a class="ae ki" href="https://wiki.archlinux.org/index.php/Cgroups" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> cgroups </strong> </a> <strong class="jm io">(控制组)的 linux 特性来解决。</strong></p><h1 id="ec5c" class="lg lh in bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">控制组:组</h1><p id="72ac" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">cgroups 本质上是资源管理器，可以控制系统中每个进程组的下列物理资源:</p><p id="07bf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">配置资源分配:</strong></p><ul class=""><li id="b677" class="nh ni in jm b jn jo jr js jv nj jz nk kd nl kh nm nn no np bi translated">CPU 消耗</li><li id="0b9a" class="nh ni in jm b jn nz jr oa jv ob jz oc kd od kh nm nn no np bi translated">内存消耗</li><li id="6e03" class="nh ni in jm b jn nz jr oa jv ob jz oc kd od kh nm nn no np bi translated">桌面 I/O 消耗</li><li id="2990" class="nh ni in jm b jn nz jr oa jv ob jz oc kd od kh nm nn no np bi translated">网络消费</li><li id="f779" class="nh ni in jm b jn nz jr oa jv ob jz oc kd od kh nm nn no np bi translated">设备限制</li></ul><p id="7666" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">聚会:</strong></p><ul class=""><li id="4eb2" class="nh ni in jm b jn jo jr js jv nj jz nk kd nl kh nm nn no np bi translated">资源会计。</li></ul><p id="c7e2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有两种不同的控制参数/规则可以应用于一个组:</p><ol class=""><li id="0356" class="nh ni in jm b jn jo jr js jv nj jz nk kd nl kh oe nn no np bi translated">极限:就像绝对值，就像一个进程可以消耗多少字节的内存。</li><li id="75a9" class="nh ni in jm b jn nz jr oa jv ob jz oc kd od kh oe nn no np bi translated">优先级:进程从给定资源的桶中获得的份额。默认情况下，所有优先级开关都设置为平衡，即系统中的所有资源都平均分配给组中的所有进程，包括 CPU 和磁盘 IO。但是，根据应用程序的要求，有时某些组的资源分配需要改变。</li></ol><p id="9b71" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">限制内存</strong></p><p id="84ed" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">与限制 CPU 相比，限制内存很容易。限制可以有两种类型:硬限制和软限制。<strong class="jm io">硬</strong> <strong class="jm io">限制</strong> —如果系统超过硬限制，随机进程将被终止。但是如果 docker 容器超出了硬限制，那么容器进程就会被终止，而不是任何随机容器。这是每个容器有一个服务的另一个原因。<strong class="jm io">软</strong>事实上，现在有了<a class="ae ki" href="http://tree.celinuxforum.org/CelfPubWiki/ELC2009Presentations?action=AttachFile&amp;do=get&amp;target=celf_mem_notify.pdf" rel="noopener ugc nofollow" target="_blank"> oom-notifier </a>(避免 oom 杀手)，我们可以在达到限制时在 cgroup 中设置通知:冻结组中的所有进程，通知用户空间，取消/提高限制/迁移容器，当系统的内存限制清除时，解冻组中的所有进程。</p><pre class="mw mx my mz gt nq nr ns nt aw nu bi"><span id="582a" class="mj lh in nr b gy nv nw l nx ny"><strong class="nr io">Brief summary of control files (</strong><a class="ae ki" href="https://www.kernel.org/doc/Documentation/cgroup-v1/memory.txt" rel="noopener ugc nofollow" target="_blank"><strong class="nr io">details</strong></a><strong class="nr io">).<br/></strong><br/> <strong class="nr io">tasks</strong>				 # attach a task(thread) and show     list of threads<br/><strong class="nr io"> cgroup.procs</strong>			 # show list of processes<br/> <strong class="nr io">cgroup.event_control</strong>		 # an interface for event_fd()<br/> <strong class="nr io">memory.usage_in_bytes</strong>		 # show current usage for memory<br/> <strong class="nr io">memory.memsw.usage_in_bytes</strong>	 # show current usage for memory+Swap<br/> <strong class="nr io">memory.limit_in_bytes</strong>		 # set/show limit of memory usage<br/> <strong class="nr io">memory.memsw.limit_in_bytes</strong>	 # set/show limit of memory+Swap usage<br/> <strong class="nr io">memory.failcnt	</strong>		 # show the number of memory usage hits limits<br/> <strong class="nr io">memory.memsw.failcnt</strong>		 # show the number of memory+Swap hits limits<br/> <strong class="nr io">memory.max_usage_in_bytes</strong>	 # show max memory usage recorded<br/> <strong class="nr io">memory.memsw.max_usage_in_bytes</strong> # show max memory+Swap usage recorded<br/> <strong class="nr io">memory.soft_limit_in_bytes</strong>	 # set/show soft limit of memory usage<br/> <strong class="nr io">memory.stat</strong>			 # show various statistics<br/> <strong class="nr io">memory.use_hierarchy</strong>		 # set/show hierarchical account enabled<br/> <strong class="nr io">memory.force_empty</strong>		 # trigger forced move charge to parent<br/> <strong class="nr io">memory.pressure_level</strong>		 # set memory pressure notifications<br/> <strong class="nr io">memory.swappiness</strong>		 # set/show swappiness parameter of vmscan<br/> <strong class="nr io">memory.move_charge_at_immigrate</strong> # set/show controls of moving charges<br/> <strong class="nr io">memory.oom_control</strong>		 # set/show oom controls.<br/> <strong class="nr io">memory.numa_stat</strong>		 # show the number of memory usage per numa node<br/> <strong class="nr io">memory.kmem.limit_in_bytes</strong>      # set/show hard limit for kernel memory<br/> <strong class="nr io">memory.kmem.usage_in_bytes</strong>      # show current kernel memory allocation<br/> <strong class="nr io">memory.kmem.failcnt</strong>             # show the number of kernel memory usage hits limits<br/> <strong class="nr io">memory.kmem.max_usage_in_bytes</strong>  # show max kernel memory usage recorded<br/><br/> <strong class="nr io">memory.kmem.tcp.limit_in_bytes</strong>  # set/show hard limit for tcp buf memory<br/> <strong class="nr io">memory.kmem.tcp.usage_in_bytes</strong>  # show current tcp buf memory allocation<br/> <strong class="nr io">memory.kmem.tcp.failcnt</strong>            # show the number of tcp buf memory usage hits limits<br/> <strong class="nr io">memory.kmem.tcp.max_usage_in_bytes</strong> # show max tcp buf memory usage recorded</span></pre><p id="8eb7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">限制 CPU </strong></p><p id="6de7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这将在整个 cgroup 的粒度上检查 CPU 的使用情况。它跟踪以下内容:</p><ul class=""><li id="f55e" class="nh ni in jm b jn jo jr js jv nj jz nk kd nl kh nm nn no np bi translated">跟踪用户/系统 CPU 时间。</li><li id="3da9" class="nh ni in jm b jn nz jr oa jv ob jz oc kd od kh nm nn no np bi translated">跟踪每个 CPU 的使用情况。</li><li id="de0a" class="nh ni in jm b jn nz jr oa jv ob jz oc kd od kh nm nn no np bi translated">允许设置权重(CPU 的份额)。</li><li id="c4ae" class="nh ni in jm b jn nz jr oa jv ob jz oc kd od kh nm nn no np bi translated">不能设限:这里有个取舍！比方说，如果您设置了少量的 CPU 百分比，并且有大量的 CPU 周期可用，那么大多数现代 CPU 将降低时钟速度，然后降低常规速度，这会降低所有速度，但现在您的应用程序需要更多的 CPU 百分比，同样，这也成为了一个第 22 条军规的情况。因此，我们可以尝试给定 CPU 周期，但同样，处理器是 RISC 而不是 CISC，很难知道您的应用程序将在这些 CPU 上进行的优化类型，因此计算指令数量也没有意义。在这种情况下，您可以设置 CPU 的百分比更好。这就是 cgroup 引入“权重”或“CPU 份额”的原因。这是一篇关于 cgroup 用法的非常好的文章。</li></ul><p id="d73b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">CPU 限制有两种类型:</p><p id="3ba4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">1.特定 CPU 内核上的 cgroups:有时应用程序需要一组任务在特定的 CPU 内核上运行。</p><p id="e6d7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">2.限制实际使用:当一个特定的任务需要更多的 CPU 份额来执行时。</p><pre class="mw mx my mz gt nq nr ns nt aw nu bi"><span id="5b4b" class="mj lh in nr b gy nv nw l nx ny"><strong class="nr io">Brief summary of control files (</strong><a class="ae ki" href="https://docs.fedoraproject.org/en-US/Fedora/17/html-single/Resource_Management_Guide/index.html#ch-Subsystems_and_Tunable_Parameters" rel="noopener ugc nofollow" target="_blank"><strong class="nr io">details</strong></a><strong class="nr io">):</strong></span><span id="d4ff" class="mj lh in nr b gy of nw l nx ny"><strong class="nr io">cpu.shares</strong>                       # Specify a relative share of CPU time available to the tasks in a cgroup.<br/><strong class="nr io">cpuset.cpus</strong>                      # list of CPUs in that cpuset<br/><strong class="nr io">cpuset.mems</strong>                      # list of Memory Nodes in that cpuset <br/><strong class="nr io">cpuset.memory_migrate</strong>            # if set, move pages to cpusets nodes<br/><strong class="nr io">cpuset.cpu_exclusive </strong>            # is cpu placement exclusive?<br/><strong class="nr io">cpuset.mem_exclusive</strong>             # is memory placement exclusive?<br/><strong class="nr io">cpuset.mem_hardwall</strong>              # is memory allocation hardwalled<br/><strong class="nr io">cpuset.memory_pressure</strong>              # measure of how much paging pressure in cpuset<br/><strong class="nr io">cpuset.memory_spread_page</strong>        # if set, spread page cache evenly on allowed nodes<br/><strong class="nr io">cpuset.memory_spread_slab</strong>        # if set, spread slab cache evenly on allowed nodes<br/><strong class="nr io">cpuset.sched_load_balance</strong>        # if set, load balance within CPUs on that cpuset<br/><strong class="nr io">cpuset.sched_relax_domain_level</strong>  # the searching range when migrating tasks<br/><strong class="nr io">cpuset.memory_pressure_enabled</strong>   # compute memory_pressure?</span></pre><p id="99a0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">限位块 IO </strong></p><p id="c02e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">也有一些用于控制块 IO 的开关，但是它们类似于 CPU 参数，因此将不涉及它们，而是留给您这个<a class="ae ki" href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Resource_Management_Guide/ch-Subsystems_and_Tunable_Parameters.html#sec-blkio" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><h1 id="af9d" class="lg lh in bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated"><strong class="ak">下一步</strong></h1><p id="9178" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">docker 容器到容器的联网是如何发生的，<a class="ae ki" href="https://medium.com/@tomdeore/docking-a-docker-container-part-3-networking-edd779f068cb#.ak1agqiz0" rel="noopener">接下来</a>...</p><p id="5c66" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">你可以在|</strong><a class="ae ki" href="https://www.linkedin.com/in/mdeore/" rel="noopener ugc nofollow" target="_blank"><strong class="jm io">LinkedIn</strong></a><strong class="jm io">|</strong><a class="ae ki" href="https://tomdeore.wixsite.com/epoch" rel="noopener ugc nofollow" target="_blank"><strong class="jm io">网站</strong></a><strong class="jm io">|</strong><a class="ae ki" href="https://github.com/milinddeore" rel="noopener ugc nofollow" target="_blank"><strong class="jm io">Github</strong></a><strong class="jm io">|</strong></p></div></div>    
</body>
</html>