<html>
<head>
<title>Flask: How to Create Authentication System Without Flask-Login</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Flask:如何在没有 Flask-Login 的情况下创建认证系统</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/flask-how-to-create-authentication-system-without-flask-login-cf804c8152a8?source=collection_archive---------6-----------------------#2022-01-17">https://blog.devgenius.io/flask-how-to-create-authentication-system-without-flask-login-cf804c8152a8?source=collection_archive---------6-----------------------#2022-01-17</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="a8c8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是我通过发现如何在不使用<em class="ki"> Flask-Login </em>的情况下创建一个体面的认证系统的经验？</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/8f5635092614be5387a79a533c71b041.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LYjxjmh-LvFQcdwcKJpXEg.png"/></div></div></figure><p id="96bd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当我使用<em class="ki">烧瓶</em>后端<em class="ki">T5】和<em class="ki">反应</em>前端创建一个应用程序时，我遇到了这个问题。我似乎无法让<em class="ki"> Flask-Login </em>很好地与<em class="ki"> React </em>前端一起工作，因此最终我实现了一种不同的方式来完成这项任务。</em></p><p id="a2ec" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这篇文章中，我将带你了解我实现认证系统的方法，使用<em class="ki"> JSON Web 令牌</em>而不是<em class="ki"> Flask-Login 完全模块化。</em></p><p id="c87c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你可以在我的<a class="ae kv" href="https://github.com/Kwsswart/flask_jwt_authentication_blueprint" rel="noopener ugc nofollow" target="_blank"> Github </a>里找到源代码。</p><h1 id="9d97" class="kw kx in bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated"><strong class="ak">问题</strong></h1><p id="7db9" class="pw-post-body-paragraph jk jl in jm b jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh ig bi translated">我在<em class="ki"> Flask </em>和<em class="ki">React</em>中构建了一个应用程序，其中我使用<em class="ki"> Flask </em>作为一个完全独立的<em class="ki"> API </em>，而<em class="ki"> React </em>服务于前端。</p><p id="5c8d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然而，我没有预见到当前端不是由<em class="ki"> Flask 服务器服务时，将认证系统与<em class="ki"> Flask-Login </em>集成是多么困难。</em></p><p id="c661" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">虽然对于任何普通的<em class="ki"> Flask </em>应用程序来说，<em class="ki"> Flask-Login </em>都是一个惊人的扩展，但是在<em class="ki"> Flask </em>后端中似乎没有一个简单的方法来利用它，这个后端不提供它的模板，而是被称为<em class="ki"> API </em>。</p><p id="c304" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在做了大量的研究和绞尽脑汁之后，我找不到一个令我满意的解决方案，最后，我决定放弃集成这个令人惊奇的扩展的想法，而是想办法在没有它的情况下重新创建这种类型的身份验证。</p><h2 id="50ef" class="lz kx in bd ky ma mb dn lc mc md dp lg jv me mf lk jz mg mh lo kd mi mj ls mk bi translated">这意味着什么</h2><p id="0231" class="pw-post-body-paragraph jk jl in jm b jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh ig bi translated">简而言之，我需要找到一种方法来重现<em class="ki"> Flask-Login </em>的共同特征，主要是:</p><ol class=""><li id="dba3" class="ml mm in jm b jn jo jr js jv mn jz mo kd mp kh mq mr ms mt bi translated">找到让用户登录的方法。</li><li id="0194" class="ml mm in jm b jn mu jr mv jv mw jz mx kd my kh mq mr ms mt bi translated">找到让用户注销的方法。</li><li id="b77c" class="ml mm in jm b jn mu jr mv jv mw jz mx kd my kh mq mr ms mt bi translated">找到创建用户会话的方法。</li><li id="9bb5" class="ml mm in jm b jn mu jr mv jv mw jz mx kd my kh mq mr ms mt bi translated">找到一种方法来检查用户会话，以便在未经身份验证的情况下关闭某些路由。</li></ol><h1 id="4d08" class="kw kx in bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">解决方案</h1><p id="8216" class="pw-post-body-paragraph jk jl in jm b jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh ig bi translated">当我开始试图弄清楚我将如何做这件事时，我决定最好从简单地建立一个标准的<em class="ki">应用程序工厂</em>开始，并以蓝图的形式创建解决方案，这样它可以完全模块化和可重用。</p><p id="69bb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我已经做了一些研究，并决定最好使用<em class="ki"> JSON Web 令牌</em>来实现这个结果，因为<em class="ki"> API </em>将通过<em class="ki"> JSON </em>和<em class="ki"> Flask </em>返回所有信息，并对这种形式的认证进行了很大的扩展。</p><p id="c3b7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我遵循的过程如下，但是如果你不熟悉<a class="ae kv" href="https://flask.palletsprojects.com/en/2.0.x/blueprints/" rel="noopener ugc nofollow" target="_blank"> <em class="ki">烧瓶蓝图</em> </a>我建议你在继续之前看一下<a class="ae kv" href="https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-xv-a-better-application-structure" rel="noopener ugc nofollow" target="_blank">这个教程</a>。</p><h2 id="feac" class="lz kx in bd ky ma mb dn lc mc md dp lg jv me mf lk jz mg mh lo kd mi mj ls mk bi translated">设置基础应用程序工厂</h2><p id="2ff0" class="pw-post-body-paragraph jk jl in jm b jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh ig bi translated">我要做的第一件事是设置应用程序的文件结构。</p><p id="13c7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是使用蓝图的 flask 应用程序的基本文件结构。整个<em class="ki"> auth/ </em>目录将包含蓝图组件。</p><pre class="kk kl km kn gt mz na nb nc aw nd bi"><span id="61b2" class="lz kx in na b gy ne nf l ng nh">authentication_example/<br/>    app/<br/>        auth/<br/>            __init__.py<br/>            helpers.py<br/>            routes.py<br/>            models.py<br/>        __init__.py<br/>    api.py<br/>    config.py</span></pre><p id="3726" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">设置好文件结构后，我需要创建一个虚拟环境并激活该虚拟环境。</strong></p><pre class="kk kl km kn gt mz na nb nc aw nd bi"><span id="0b63" class="lz kx in na b gy ne nf l ng nh">python -m venv venv<br/>source venv/bin/activate <br/>venv/Scripts/activate // Windows command prompt</span></pre><p id="4dbe" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">进入环境后，我需要安装依赖项和包。</strong></p><pre class="kk kl km kn gt mz na nb nc aw nd bi"><span id="ecbe" class="lz kx in na b gy ne nf l ng nh">pip install flask flask-sqlalchemy flask-cors flask-migrate flask-jwt-extended python-dotenv bcrypt</span></pre><p id="06a9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用这些不同依赖关系的原因是:</p><p id="cd97" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> Flask-SQLAlchemy </strong> —这是一个扩展，允许我们将 SQLAlchemy 用作我们的<em class="ki"> ORM。</em></p><p id="3407" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> Flask-Migrate </strong> —这是处理所有数据库迁移的扩展。为了了解更多，这个扩展的创建者有这个<a class="ae kv" href="https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-iv-database" rel="noopener ugc nofollow" target="_blank">教程</a>。</p><p id="d06a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是处理<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS" rel="noopener ugc nofollow" target="_blank">跨来源资源共享</a>的扩展，这是使跨来源<em class="ki"> AJAX </em>成为可能的简单方法。</p><p id="dfda" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是一个扩展，它将在我们的 Flask 应用程序中添加处理 JSON Web 令牌的支持。</p><p id="a7d7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> Python-dotenv </strong> —这是一个包，它允许我们将所有敏感信息保存在一个单独的。env 文件并将它们导入到应用程序中。</p><p id="a2fe" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> bcrypt </strong> —这是处理密码安全的包</p><p id="bf41" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在我已经安装了所有的依赖项，我可以开始设置应用程序了。</p><p id="cd7a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我想做的第一件事是在 config.py 中创建一个 Config 对象，它可以将所有需要的变量导入到应用程序中。</p><pre class="kk kl km kn gt mz na nb nc aw nd bi"><span id="f8aa" class="lz kx in na b gy ne nf l ng nh"><strong class="na io"><em class="ki">authentication_example/config.py<br/></em></strong></span><span id="5857" class="lz kx in na b gy ni nf l ng nh">import os</span><span id="9878" class="lz kx in na b gy ni nf l ng nh">from dotenv import load_dotenv<br/></span><span id="15a8" class="lz kx in na b gy ni nf l ng nh">basedir = os.path.abspath(os.path.dirname(__file__))</span><span id="c5da" class="lz kx in na b gy ni nf l ng nh">load_dotenv(os.path.join(basedir, '.env'))</span><span id="ea4d" class="lz kx in na b gy ni nf l ng nh">class Config(object):</span><span id="a21d" class="lz kx in na b gy ni nf l ng nh">    SECRET_KEY = os.environ.get('SECRET_KEY') or 'you-will-never-guess'</span><span id="4d7f" class="lz kx in na b gy ni nf l ng nh">    SQLALCHEMY_DATABASE_URI = os.environ.get('DATABASE_URL') or \</span><span id="ae55" class="lz kx in na b gy ni nf l ng nh">        "sqlite:///" + os.path.join(basedir, "app_database.db")</span><span id="7143" class="lz kx in na b gy ni nf l ng nh">    JWT_SECRET_KEY = os.environ.get('JWT_SECRET_KEY') or "super-secret-key"</span><span id="1baa" class="lz kx in na b gy ni nf l ng nh">    JWT_BLACKLIST_ENABLED = True</span><span id="e202" class="lz kx in na b gy ni nf l ng nh">    JWT_BLACKLIST_TOKEN_CHECKS = ["access", "refresh"]</span></pre><p id="8347" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有了这个我决定成立 <a class="ae kv" href="https://flask.palletsprojects.com/en/2.0.x/patterns/appfactories/" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io">应用工厂</strong> </a> <strong class="jm io">。</strong></p><p id="77b3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我在三个单独的文件中做到了这一点:<em class="ki"> api.py，app/__init__。py、</em>和<em class="ki"> app/auth/models.py </em></p><pre class="kk kl km kn gt mz na nb nc aw nd bi"><span id="fdb3" class="lz kx in na b gy ne nf l ng nh"><strong class="na io"><em class="ki">authentication_example/app/__init__.py<br/></em></strong></span><span id="3182" class="lz kx in na b gy ni nf l ng nh">import os</span><span id="063a" class="lz kx in na b gy ni nf l ng nh">from flask import Flask</span><span id="b72e" class="lz kx in na b gy ni nf l ng nh">from flask_cors import CORS</span><span id="f708" class="lz kx in na b gy ni nf l ng nh">from flask_migrate import Migrate</span><span id="291e" class="lz kx in na b gy ni nf l ng nh">from flask_jwt_extended import JWTManager</span><span id="1eef" class="lz kx in na b gy ni nf l ng nh">from flask_sqlalchemy import SQLAlchemy</span><span id="9477" class="lz kx in na b gy ni nf l ng nh">from config import Config</span><span id="16b9" class="lz kx in na b gy ni nf l ng nh">cors = CORS()</span><span id="b0bb" class="lz kx in na b gy ni nf l ng nh">db = SQLAlchemy()</span><span id="2225" class="lz kx in na b gy ni nf l ng nh">migrate = Migrate()</span><span id="5c7b" class="lz kx in na b gy ni nf l ng nh">jwt = JWTManager()</span><span id="034e" class="lz kx in na b gy ni nf l ng nh">def create_app(config_class=Config):</span><span id="d6e1" class="lz kx in na b gy ni nf l ng nh">    app = Flask(__name__)</span><span id="7339" class="lz kx in na b gy ni nf l ng nh">    app.config.from_object(Config)</span><span id="ed71" class="lz kx in na b gy ni nf l ng nh">    db.init_app(app)</span><span id="df0c" class="lz kx in na b gy ni nf l ng nh">    cors.init_app(app)</span><span id="5e00" class="lz kx in na b gy ni nf l ng nh">    migrate.init_app(app, db)</span><span id="2539" class="lz kx in na b gy ni nf l ng nh">    jwt.init_app(app)<br/></span><span id="1cdb" class="lz kx in na b gy ni nf l ng nh">    return app</span><span id="74f5" class="lz kx in na b gy ni nf l ng nh">from app.auth import models</span></pre><p id="ddcd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ki"> create_app() </em>函数是一个工厂函数，当被调用时，它会创建一个<em class="ki"> Flask </em>实例，并使用之前的配置初始化所有的<em class="ki"> flask 扩展</em>，然后返回应用程序。</p><p id="e69b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ki">模型</em>被导入到文件的底部，以防止循环依赖。</p><pre class="kk kl km kn gt mz na nb nc aw nd bi"><span id="a030" class="lz kx in na b gy ne nf l ng nh"><strong class="na io"><em class="ki"><br/>authentication_example/api.py<br/></em></strong></span><span id="fac8" class="lz kx in na b gy ni nf l ng nh">from app import create_app, db</span><span id="fabc" class="lz kx in na b gy ni nf l ng nh">from app.auth.models import *</span><span id="17af" class="lz kx in na b gy ni nf l ng nh">from flask import Flask</span><span id="0066" class="lz kx in na b gy ni nf l ng nh">app = create_app()</span><span id="22df" class="lz kx in na b gy ni nf l ng nh">@app.shell_context_processor</span><span id="acc6" class="lz kx in na b gy ni nf l ng nh">def make_shell_context():</span><span id="bf06" class="lz kx in na b gy ni nf l ng nh">    return {</span><span id="f888" class="lz kx in na b gy ni nf l ng nh">        'db': db,</span><span id="a178" class="lz kx in na b gy ni nf l ng nh">        'Users': Users,</span><span id="9fa9" class="lz kx in na b gy ni nf l ng nh">    }</span><span id="9bb3" class="lz kx in na b gy ni nf l ng nh">if __name__ == '__main__':</span><span id="fb27" class="lz kx in na b gy ni nf l ng nh">    app.run(debug=True)</span></pre><p id="c77e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这个文件中，我调用了<em class="ki"> create_app() </em>函数，但我也设置了 shell 上下文，这非常有用，因为它允许您在测试期间只需运行以下命令就可以与数据库和应用程序进行交互:</p><pre class="kk kl km kn gt mz na nb nc aw nd bi"><span id="df01" class="lz kx in na b gy ne nf l ng nh">flask shell</span></pre><p id="f43e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">该模型是数据库中表格的表示，以便<em class="ki"> ORM </em>可以在<em class="ki"> Flask 中轻松使用它。</em></p><pre class="kk kl km kn gt mz na nb nc aw nd bi"><span id="d132" class="lz kx in na b gy ne nf l ng nh"><strong class="na io"><em class="ki">authentication_example/app/auth/models.py<br/></em></strong></span><span id="1029" class="lz kx in na b gy ni nf l ng nh">import os</span><span id="1778" class="lz kx in na b gy ni nf l ng nh">from app import db</span><span id="ce8e" class="lz kx in na b gy ni nf l ng nh">class Users(db.Model):</span><span id="5668" class="lz kx in na b gy ni nf l ng nh">    id = db.Column('user_id', db.Integer, primary_key=True)</span><span id="02a0" class="lz kx in na b gy ni nf l ng nh">    username = db.Column(db.String(24))</span><span id="3ca6" class="lz kx in na b gy ni nf l ng nh">    pwd = db.Column(db.String(64))<br/></span><span id="e5a5" class="lz kx in na b gy ni nf l ng nh">    def save(self):<br/>        db.session.add(self)</span><span id="a079" class="lz kx in na b gy ni nf l ng nh">        db.session.commit()</span><span id="134f" class="lz kx in na b gy ni nf l ng nh">    def __init__(self, username, pwd):</span><span id="ff6a" class="lz kx in na b gy ni nf l ng nh">        self.username = username</span><span id="d341" class="lz kx in na b gy ni nf l ng nh">        self.pwd = pwd</span><span id="2885" class="lz kx in na b gy ni nf l ng nh">    def __repr__(self):</span><span id="d3fc" class="lz kx in na b gy ni nf l ng nh">        return "&lt;User: Username - {}; password - {};&gt;".format(self.username, self.pwd)</span></pre><p id="6f6a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这一部分，我只是简单地建立了一个认证系统需要的基本的<em class="ki">用户</em>模型。记住，一旦完成，您将需要像在<a class="ae kv" href="https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-iv-database" rel="noopener ugc nofollow" target="_blank">教程</a>中所做的那样处理数据库迁移。</p><pre class="kk kl km kn gt mz na nb nc aw nd bi"><span id="7f70" class="lz kx in na b gy ne nf l ng nh">flask db init<br/>flask db migrate -m "Users table"<br/>flask db upgrade</span></pre><h2 id="84b2" class="lz kx in bd ky ma mb dn lc mc md dp lg jv me mf lk jz mg mh lo kd mi mj ls mk bi translated">创建身份验证蓝图</h2><p id="25de" class="pw-post-body-paragraph jk jl in jm b jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh ig bi translated">既然我已经设置好了应用程序并准备好工作，我必须注册蓝图，以便应用程序可以导入它和我需要实现的所有组件。</p><p id="36df" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个蓝图基本上由路线、模型和助手功能组成。</p><p id="5007" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是我更喜欢使用蓝图的方式，这样我就可以分离路由逻辑、数据库逻辑和我认为需要的任何其他逻辑。</p><p id="fa13" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我要做的第一件事是登记蓝图。</p><p id="3314" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是我在两个<em class="ki"> __init__ 里做的。py </em>文件。</p><pre class="kk kl km kn gt mz na nb nc aw nd bi"><span id="eb05" class="lz kx in na b gy ne nf l ng nh"><strong class="na io"><em class="ki">authentication_example/app/auth/__init__.py<br/></em></strong></span><span id="f2ef" class="lz kx in na b gy ni nf l ng nh">from flask import Blueprint<br/></span><span id="173a" class="lz kx in na b gy ni nf l ng nh">bp = Blueprint('auth', __name__)<br/></span><span id="cc01" class="lz kx in na b gy ni nf l ng nh">from app.auth import routes</span></pre><p id="d333" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这个文件中，我简单地创建了一个标签为<em class="ki"> auth 的<em class="ki">蓝图</em>的实例。</em></p><pre class="kk kl km kn gt mz na nb nc aw nd bi"><span id="85f2" class="lz kx in na b gy ne nf l ng nh"><strong class="na io"><em class="ki">authentication_example/app/__init__.py</em></strong></span><span id="b7d6" class="lz kx in na b gy ni nf l ng nh">import os</span><span id="13ef" class="lz kx in na b gy ni nf l ng nh">from flask import Flask</span><span id="0288" class="lz kx in na b gy ni nf l ng nh">from flask_cors import CORS</span><span id="de5a" class="lz kx in na b gy ni nf l ng nh">from flask_migrate import Migrate</span><span id="142f" class="lz kx in na b gy ni nf l ng nh">from flask_jwt_extended import JWTManager</span><span id="3c35" class="lz kx in na b gy ni nf l ng nh">from flask_sqlalchemy import SQLAlchemy</span><span id="9555" class="lz kx in na b gy ni nf l ng nh">from config import Config</span><span id="7b79" class="lz kx in na b gy ni nf l ng nh">cors = CORS()</span><span id="90e0" class="lz kx in na b gy ni nf l ng nh">db = SQLAlchemy()</span><span id="db58" class="lz kx in na b gy ni nf l ng nh">migrate = Migrate()</span><span id="2888" class="lz kx in na b gy ni nf l ng nh">jwt = JWTManager()</span><span id="4665" class="lz kx in na b gy ni nf l ng nh">def create_app(config_class=Config):</span><span id="6c02" class="lz kx in na b gy ni nf l ng nh">    app = Flask(__name__)</span><span id="5f3d" class="lz kx in na b gy ni nf l ng nh">    app.config.from_object(Config)</span><span id="d0c0" class="lz kx in na b gy ni nf l ng nh">    db.init_app(app)</span><span id="284a" class="lz kx in na b gy ni nf l ng nh">    cors.init_app(app)</span><span id="46c2" class="lz kx in na b gy ni nf l ng nh">    migrate.init_app(app, db)</span><span id="6b9f" class="lz kx in na b gy ni nf l ng nh">    jwt.init_app(app)</span><span id="f3f8" class="lz kx in na b gy ni nf l ng nh"><strong class="na io">    from app.auth import bp as auth_bp</strong></span><span id="b194" class="lz kx in na b gy ni nf l ng nh"><strong class="na io">    app.register_blueprint(auth_bp)</strong></span><span id="a1c1" class="lz kx in na b gy ni nf l ng nh">    return app</span><span id="70ae" class="lz kx in na b gy ni nf l ng nh">from app.auth import models</span></pre><p id="334e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">添加的两行以粗体显示，我正在注册蓝图，因为应用程序是在应用程序工厂中创建的。</p><p id="ff7e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一旦我注册了蓝图，我就可以自由地开始认证系统的工作了。</p><p id="9cb5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">要在我们的应用程序中实现<a class="ae kv" href="https://jwt.io/introduction" rel="noopener ugc nofollow" target="_blank"> JSON Web 令牌</a>我需要做的第一件事是在我们的数据库中创建一个表来存储列入黑名单的令牌。</p><pre class="kk kl km kn gt mz na nb nc aw nd bi"><span id="f1e2" class="lz kx in na b gy ne nf l ng nh"><strong class="na io"><em class="ki">authentication_example/app/auth/models.py</em></strong></span><span id="fe9e" class="lz kx in na b gy ni nf l ng nh">...</span><span id="3cca" class="lz kx in na b gy ni nf l ng nh">class InvalidToken(db.Model):</span><span id="316f" class="lz kx in na b gy ni nf l ng nh">    __tablename__ = "invalid_tokens"</span><span id="e778" class="lz kx in na b gy ni nf l ng nh">    id = db.Column(db.Integer, primary_key=True)</span><span id="7131" class="lz kx in na b gy ni nf l ng nh">    jti = db.Column(db.String)</span><span id="e365" class="lz kx in na b gy ni nf l ng nh">    def save(self):</span><span id="8a77" class="lz kx in na b gy ni nf l ng nh">        db.session.add(self)</span><span id="a764" class="lz kx in na b gy ni nf l ng nh">        db.session.commit()</span><span id="d851" class="lz kx in na b gy ni nf l ng nh">    @classmethod</span><span id="b204" class="lz kx in na b gy ni nf l ng nh">    def is_invalid(cls, jti):</span><span id="2e79" class="lz kx in na b gy ni nf l ng nh">        """ Determine whether the jti key is on the blocklist return bool"""</span><span id="283f" class="lz kx in na b gy ni nf l ng nh">    query = cls.query.filter_by(jti=jti).first()</span><span id="199a" class="lz kx in na b gy ni nf l ng nh">    return bool(query)</span></pre><p id="25ba" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">完成后，我必须记得再次迁移数据库:</p><pre class="kk kl km kn gt mz na nb nc aw nd bi"><span id="7b3a" class="lz kx in na b gy ne nf l ng nh">flask db init<br/>flask db migrate -m "Invalid Tokens table"<br/>flask db upgrade</span></pre><p id="cf53" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在数据库已经准备好了，我可以创建助手函数了。</p><p id="f0a1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所有这些本质上都是为了将每个功能的路径与逻辑分开，这也有助于避免通过单独的路径重复代码。</p><pre class="kk kl km kn gt mz na nb nc aw nd bi"><span id="c6f3" class="lz kx in na b gy ne nf l ng nh"><strong class="na io"><em class="ki">authentication_example/app/auth/helpers.py</em></strong></span><span id="9be1" class="lz kx in na b gy ni nf l ng nh">from app import db</span><span id="b842" class="lz kx in na b gy ni nf l ng nh">from app.auth.models import Users</span><span id="c912" class="lz kx in na b gy ni nf l ng nh">from bcrypt import hashpw, gensalt, checkpw</span><span id="9f4c" class="lz kx in na b gy ni nf l ng nh">from base64 import b64encode</span><span id="f7b9" class="lz kx in na b gy ni nf l ng nh">from hashlib import sha256</span><span id="ab4b" class="lz kx in na b gy ni nf l ng nh">def get_users():</span><span id="4698" class="lz kx in na b gy ni nf l ng nh">    users = Users.query.all()</span><span id="1a15" class="lz kx in na b gy ni nf l ng nh">    return [{"id": i.id, "username": i.username, "pwd": i.pwd} for i in users]</span><span id="be02" class="lz kx in na b gy ni nf l ng nh">def get_user(user_id):</span><span id="505e" class="lz kx in na b gy ni nf l ng nh">    users = Users.query.all()</span><span id="6c99" class="lz kx in na b gy ni nf l ng nh">    user = list(filter(lambda x: x.id == user_id, users))[0]</span><span id="f1a5" class="lz kx in na b gy ni nf l ng nh">    return {"id": user.id, "username": user.username, "pwd": user.pwd}</span><span id="d164" class="lz kx in na b gy ni nf l ng nh">def add_user(username, pwd):</span><span id="6c9a" class="lz kx in na b gy ni nf l ng nh">    if username and pwd :</span><span id="1b63" class="lz kx in na b gy ni nf l ng nh">        try:</span><span id="d671" class="lz kx in na b gy ni nf l ng nh">            user = Users(username, pwd)</span><span id="ccb9" class="lz kx in na b gy ni nf l ng nh">            user.save()</span><span id="c078" class="lz kx in na b gy ni nf l ng nh">            return True</span><span id="31de" class="lz kx in na b gy ni nf l ng nh">        except Exception as e:</span><span id="93eb" class="lz kx in na b gy ni nf l ng nh">            print(e)</span><span id="3754" class="lz kx in na b gy ni nf l ng nh">            return False</span><span id="e655" class="lz kx in na b gy ni nf l ng nh">    else:</span><span id="f764" class="lz kx in na b gy ni nf l ng nh">        return False</span><span id="74b1" class="lz kx in na b gy ni nf l ng nh">def remove_user(user_id):</span><span id="6a16" class="lz kx in na b gy ni nf l ng nh">    if user_id:</span><span id="1aa7" class="lz kx in na b gy ni nf l ng nh">        try:</span><span id="0450" class="lz kx in na b gy ni nf l ng nh">            user = Users.query.get(user_id)</span><span id="a243" class="lz kx in na b gy ni nf l ng nh">            db.session.delete(user)</span><span id="5eeb" class="lz kx in na b gy ni nf l ng nh">            db.session.commit()</span><span id="0309" class="lz kx in na b gy ni nf l ng nh">            return True</span><span id="648a" class="lz kx in na b gy ni nf l ng nh">        except Exception as e:</span><span id="582b" class="lz kx in na b gy ni nf l ng nh">            print(e)</span><span id="a86c" class="lz kx in na b gy ni nf l ng nh">            return False</span><span id="e0c1" class="lz kx in na b gy ni nf l ng nh">    else:</span><span id="3ebd" class="lz kx in na b gy ni nf l ng nh">        return False</span><span id="5e0e" class="lz kx in na b gy ni nf l ng nh">def encrypt_pwd(pwd):</span><span id="cda3" class="lz kx in na b gy ni nf l ng nh">    return hashpw(b64encode(sha256(pwd.encode()).digest()), gensalt()).decode()</span><span id="0887" class="lz kx in na b gy ni nf l ng nh">def check_pwd(x, y):</span><span id="196b" class="lz kx in na b gy ni nf l ng nh">    """</span><span id="3b73" class="lz kx in na b gy ni nf l ng nh">    Check whether password hashed matches:</span><span id="ac13" class="lz kx in na b gy ni nf l ng nh">    * arg x** password to check</span><span id="e2e6" class="lz kx in na b gy ni nf l ng nh">    * arg y** original hashed password</span><span id="067f" class="lz kx in na b gy ni nf l ng nh">    """</span><span id="0a31" class="lz kx in na b gy ni nf l ng nh">    return checkpw(b64encode(sha256(x.encode()).digest()), y.encode())</span></pre><p id="b057" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这些功能中的每一个只是执行它们的功能或者返回<em class="ki">假</em>。整个想法是根据需要从每个路径调用所述函数，从而将动作的逻辑与路径分离。</p><p id="0a9d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，我终于可以浏览路线本身的设置了。</p><p id="1102" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">以下全部在<em class="ki"> routes.py </em>实现</p><pre class="kk kl km kn gt mz na nb nc aw nd bi"><span id="170e" class="lz kx in na b gy ne nf l ng nh"><strong class="na io"><em class="ki">authentication_example/app/auth/routes.py<br/></em></strong></span><span id="5a99" class="lz kx in na b gy ni nf l ng nh">from app import jwt</span><span id="fd4d" class="lz kx in na b gy ni nf l ng nh">from app.auth import bp</span><span id="49ff" class="lz kx in na b gy ni nf l ng nh">from app.auth.helpers import *</span><span id="dd2e" class="lz kx in na b gy ni nf l ng nh">from app.auth.models import Users, InvalidToken</span><span id="2aee" class="lz kx in na b gy ni nf l ng nh">from flask import request, jsonify</span><span id="d46c" class="lz kx in na b gy ni nf l ng nh">from flask_jwt_extended import create_access_token,       create_refresh_token, get_jwt_identity, get_jwt, jwt_required</span><span id="af51" class="lz kx in na b gy ni nf l ng nh">@jwt.token_in_blocklist_loader</span><span id="5936" class="lz kx in na b gy ni nf l ng nh">def check_if_blacklisted_token(data, decrypted):</span><span id="b900" class="lz kx in na b gy ni nf l ng nh">    """</span><span id="0c51" class="lz kx in na b gy ni nf l ng nh">    Decorator designed to check for blacklisted tokens</span><span id="b999" class="lz kx in na b gy ni nf l ng nh">    """</span><span id="c604" class="lz kx in na b gy ni nf l ng nh">    jti = decrypted['jti']</span><span id="e1b7" class="lz kx in na b gy ni nf l ng nh">    return InvalidToken.is_invalid(jti)</span></pre><p id="e96b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">首先需要一个装饰器，用于确定令牌是否有效。完成后，我想创建<em class="ki">注册和登录路径:</em></p><pre class="kk kl km kn gt mz na nb nc aw nd bi"><span id="5be7" class="lz kx in na b gy ne nf l ng nh">@bp.route("/api/login", methods=["POST"])</span><span id="6c6a" class="lz kx in na b gy ni nf l ng nh">def login():</span><span id="6be8" class="lz kx in na b gy ni nf l ng nh">    try:</span><span id="8e19" class="lz kx in na b gy ni nf l ng nh">        username = request.json["username"]</span><span id="a99c" class="lz kx in na b gy ni nf l ng nh">        pwd = request.json["pwd"]</span><span id="aaf2" class="lz kx in na b gy ni nf l ng nh">        if username and pwd:</span><span id="5a34" class="lz kx in na b gy ni nf l ng nh">            user = list(filter(lambda x: x["username"] == username and check_pwd(pwd, x["pwd"]), get_users()))</span><span id="89ff" class="lz kx in na b gy ni nf l ng nh">            if len(user) == 1:</span><span id="7004" class="lz kx in na b gy ni nf l ng nh">                token = create_access_token(identity=user[0]["id"])</span><span id="99bd" class="lz kx in na b gy ni nf l ng nh">                refresh_token = create_refresh_token(identity=user[0]["id"])</span><span id="e687" class="lz kx in na b gy ni nf l ng nh">                return jsonify({"token": token, "refreshToken": refresh_token})</span><span id="6a30" class="lz kx in na b gy ni nf l ng nh">            else:</span><span id="1332" class="lz kx in na b gy ni nf l ng nh">                return jsonify({"error": "Invalid credentials"})</span><span id="0d78" class="lz kx in na b gy ni nf l ng nh">        else:</span><span id="183f" class="lz kx in na b gy ni nf l ng nh">            return jsonify({"error":"Invalid Form"})</span><span id="24e7" class="lz kx in na b gy ni nf l ng nh">    except:</span><span id="a4b9" class="lz kx in na b gy ni nf l ng nh">        return jsonify({"error": "Invalid Form"})</span><span id="36a7" class="lz kx in na b gy ni nf l ng nh">@bp.route("/api/register", methods=["POST"])</span><span id="c02a" class="lz kx in na b gy ni nf l ng nh">def register():</span><span id="3451" class="lz kx in na b gy ni nf l ng nh">    try:</span><span id="aaf5" class="lz kx in na b gy ni nf l ng nh">        pwd = encrypt_pwd(request.json['pwd'])</span><span id="8cee" class="lz kx in na b gy ni nf l ng nh">        username = request.json['username']</span><span id="9fc1" class="lz kx in na b gy ni nf l ng nh">        users = get_users()</span><span id="8413" class="lz kx in na b gy ni nf l ng nh">        if len(list(filter(lambda x: x["username"] == username, users))) == 1:</span><span id="4fb5" class="lz kx in na b gy ni nf l ng nh">            return jsonify({"error": "Invalid Form"})</span><span id="42dc" class="lz kx in na b gy ni nf l ng nh">        add_user(username, pwd)</span><span id="31d4" class="lz kx in na b gy ni nf l ng nh">        return jsonify({"success": True})</span><span id="095b" class="lz kx in na b gy ni nf l ng nh">    except Exception as e:<br/>        return jsonify({"error": str(e)})</span></pre><p id="9f1a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里有两个非常简单的端点。</p><p id="b6b2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ki">登录</em>端点获取<em class="ki">用户名</em>和<em class="ki">密码</em>并使用助手函数验证它们，如果凭证正确，它将返回一个<em class="ki"> JWT 令牌</em>供它们在创建的会话中使用。</p><p id="2f3e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ki">寄存器</em>端点简单地检查以确保<em class="ki">用户名</em>尚未被使用，然后将用户添加到数据库中。</p><p id="8dd1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">一旦我有了这些端点，我还需要实现一些功能:</strong></p><ol class=""><li id="a05d" class="ml mm in jm b jn jo jr js jv mn jz mo kd mp kh mq mr ms mt bi translated">前端检查令牌是否过期的方法</li><li id="3005" class="ml mm in jm b jn mu jr mv jv mw jz mx kd my kh mq mr ms mt bi translated">一种前端在令牌过期时刷新令牌的方法。</li><li id="c1df" class="ml mm in jm b jn mu jr mv jv mw jz mx kd my kh mq mr ms mt bi translated">前端检查当前用户的方式，由<em class="ki"> Flask-Login 提供。</em></li><li id="f95c" class="ml mm in jm b jn mu jr mv jv mw jz mx kd my kh mq mr ms mt bi translated">一种使令牌无效的方法，从而模拟一个注销系统。</li></ol><p id="81f7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">既然我已经有了<em class="ki">登录</em>系统和对黑名单令牌的检查，我可以使用<em class="ki"> @jwt_required() </em>装饰器来确保我只想允许授权用户访问的任何路由都受到保护。</p><p id="2804" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有了它，就很容易在四条不同的路线上实现这四个要求:</p><pre class="kk kl km kn gt mz na nb nc aw nd bi"><span id="0e53" class="lz kx in na b gy ne nf l ng nh">@bp.route("/api/checkiftokenexpire", methods=["POST"])</span><span id="4ba9" class="lz kx in na b gy ni nf l ng nh">@jwt_required()</span><span id="de68" class="lz kx in na b gy ni nf l ng nh">def check_if_token_expire():</span><span id="5209" class="lz kx in na b gy ni nf l ng nh">    return jsonify({"success": True})</span><span id="36d1" class="lz kx in na b gy ni nf l ng nh">@bp.route("/api/refreshtoken", methods=["POST"])</span><span id="5e24" class="lz kx in na b gy ni nf l ng nh">@jwt_required(refresh=True)</span><span id="8bcb" class="lz kx in na b gy ni nf l ng nh">def refresh():</span><span id="96b2" class="lz kx in na b gy ni nf l ng nh">    identity = get_jwt_identity()</span><span id="69ca" class="lz kx in na b gy ni nf l ng nh">    token = create_access_token(identity=identity)</span><span id="d4dc" class="lz kx in na b gy ni nf l ng nh">    return jsonify({"token": token})</span><span id="268a" class="lz kx in na b gy ni nf l ng nh">@bp.route("/api/getcurrentuser")</span><span id="73f8" class="lz kx in na b gy ni nf l ng nh">@jwt_required()</span><span id="cb50" class="lz kx in na b gy ni nf l ng nh">def current_user():</span><span id="b56c" class="lz kx in na b gy ni nf l ng nh">    uid = get_jwt_identity()</span><span id="2177" class="lz kx in na b gy ni nf l ng nh">    return jsonify(get_user(uid))</span><span id="4b1a" class="lz kx in na b gy ni nf l ng nh">@bp.route("/api/logout/refresh", methods=["POST"])</span><span id="734a" class="lz kx in na b gy ni nf l ng nh">@jwt_required()</span><span id="4273" class="lz kx in na b gy ni nf l ng nh">def logout():</span><span id="e797" class="lz kx in na b gy ni nf l ng nh">    """</span><span id="5dc4" class="lz kx in na b gy ni nf l ng nh">    End-point to invalidate the token.</span><span id="9273" class="lz kx in na b gy ni nf l ng nh">    Can be used with both log the user out or for the frontend to call after refreshing the token.</span><span id="2b0d" class="lz kx in na b gy ni nf l ng nh">    """</span><span id="5b6f" class="lz kx in na b gy ni nf l ng nh">    jti = get_jwt()["jti"]</span><span id="53a4" class="lz kx in na b gy ni nf l ng nh">    try:</span><span id="7c08" class="lz kx in na b gy ni nf l ng nh">        invalid_token = InvalidToken(jti=jti)</span><span id="e8ec" class="lz kx in na b gy ni nf l ng nh">        invalid_token.save()</span><span id="b618" class="lz kx in na b gy ni nf l ng nh">        return jsonify({"success": True})</span><span id="a9fe" class="lz kx in na b gy ni nf l ng nh">    except Exception as e:</span><span id="6809" class="lz kx in na b gy ni nf l ng nh">        print(e)</span><span id="489f" class="lz kx in na b gy ni nf l ng nh">        return jsonify({"error": str(e)})</span></pre><p id="7c04" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">实现了这四个端点之后，我还剩下最后一件认证系统需要完成的事情:删除旧用户。</p><p id="6691" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">幸运的是，我已经掌握了阿哈所需的所有逻辑，我需要做的就是创建一个单一的路由来处理这个问题。</p><pre class="kk kl km kn gt mz na nb nc aw nd bi"><span id="871e" class="lz kx in na b gy ne nf l ng nh">@bp.route("/api/deleteaccount", methods=["DELETE"])</span><span id="bdff" class="lz kx in na b gy ni nf l ng nh">@jwt_required()</span><span id="cce8" class="lz kx in na b gy ni nf l ng nh">def delete_account():</span><span id="37d2" class="lz kx in na b gy ni nf l ng nh">    try:</span><span id="efe5" class="lz kx in na b gy ni nf l ng nh">        user = get_user(get_jwt_identity())</span><span id="2b60" class="lz kx in na b gy ni nf l ng nh">        remove_user(user.id)</span><span id="663d" class="lz kx in na b gy ni nf l ng nh">        return jsonify({"success": True})</span><span id="b3c2" class="lz kx in na b gy ni nf l ng nh">    except Exception as e:</span><span id="a52c" class="lz kx in na b gy ni nf l ng nh">        return jsonify({"error": str(e)})</span></pre></div><div class="ab cl nj nk hr nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="ig ih ii ij ik"><h2 id="d43d" class="lz kx in bd ky ma mb dn lc mc md dp lg jv me mf lk jz mg mh lo kd mi mj ls mk bi translated">就这样，我有了整个认证系统，准备好使用任何我可能在<em class="nq"> Flask </em>中使用<em class="nq"> JSON Web Token </em>认证构建的<em class="nq"> API </em>。</h2><p id="9133" class="pw-post-body-paragraph jk jl in jm b jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh ig bi translated">以蓝图的形式设置它的美妙之处在于，每当想要使用类似的认证系统设置新的<em class="ki"> API </em>时，您可以简单地将<em class="ki"> auth/ </em>目录引入应用程序，注册蓝图，然后迁移数据库，一切准备就绪。</p><p id="6d0e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">蓝图在我的<a class="ae kv" href="https://github.com/Kwsswart/flask_jwt_authentication_blueprint" rel="noopener ugc nofollow" target="_blank"> Github </a>中，如果你想使用它，请随意克隆这个库。</p><p id="28ec" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在计算机科学中有很多方法可以做同样的事情，我喜欢尝试寻找新的不同的方法，这些方法可能比我以前做过的更好。</p><p id="26da" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你有没有找到另一种方法来实现类似的东西？</p><p id="1313" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果是这样，请留下评论解释如何，我很想看看你是如何做到的！</p></div></div>    
</body>
</html>