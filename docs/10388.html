<html>
<head>
<title>DMOPC ’19 Contest 2 P2 — Squares</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">DM OPC’19 竞赛 2 P2 —广场</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/dmopc-19-contest-2-p2-squares-3869cf158ff1?source=collection_archive---------7-----------------------#2022-10-29">https://blog.devgenius.io/dmopc-19-contest-2-p2-squares-3869cf158ff1?source=collection_archive---------7-----------------------#2022-10-29</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="1670" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">今天早上早些时候，我遇到了这个问题。问题陈述如下:</p><pre class="kj kk kl km gt kn ko kp kq aw kr bi"><span id="f4d7" class="ks kt in ko b gy ku kv l kw kx">You are given an N×M grid of squares. Each square contains a number ai, 1≤i≤N×M, the cost to travel through that square. You are starting at the most top-left square. At each turn you may choose to move down or right but not both. Find the minimum cost it would take you to travel to the most bottom-right square.</span></pre><p id="e0ac" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是示例输入:</p><pre class="kj kk kl km gt kn ko kp kq aw kr bi"><span id="3501" class="ks kt in ko b gy ku kv l kw kx">3 4<br/>3 1 2 4<br/>9 8 7 6<br/>2 8 9 2</span></pre><p id="b251" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">以及相应的输出:</p><pre class="kj kk kl km gt kn ko kp kq aw kr bi"><span id="cbcb" class="ks kt in ko b gy ku kv l kw kx">18</span></pre><p id="bb0b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">要获得相应的输出，您将遵循路径 3-&gt;1-&gt;2-&gt;4-&gt;6-&gt;2。</p><p id="2b7a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们运用一些解决问题的技巧。让我们看看是否有一个更简单的问题来尝试和解决，看看我们是否能回到原点。一个更简单的问题是问自己“在一个网格中有多少条从(0，0)到(n，m)的路径。我们将首先回答/编写那个问题的解决方案，然后我们将尝试解决这个问题。假设给你一个未加权的 n*m 矩阵，你需要找出从(0，0)到(n，m)的路径数。这是一个琐碎的动态编程问题。如果你学过数据管理，你就会知道如何解决这样的问题。无论如何，我会经历解决它的过程。在尝试解决这个问题时，你可以问自己一些好问题:</p><ol class=""><li id="161e" class="ky kz in jm b jn jo jr js jv la jz lb kd lc kh ld le lf lg bi translated">在 1*x 网格中，从(0，0)到(n，m)有多少种方法？ie 1*1，1*5，1*10？</li><li id="60af" class="ky kz in jm b jn lh jr li jv lj jz lk kd ll kh ld le lf lg bi translated">在一个 x*1 的网格中，从(0，0)到(n，m)有多少种方法？ie 1*1，5*1，10*1？</li></ol><p id="5b40" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">3.在一个 2*3 的网格中，从(0，0)到(n，m)有多少种方法？好吧，我在下面概述了一下。</p><pre class="kj kk kl km gt kn ko kp kq aw kr bi"><span id="3658" class="ks kt in ko b gy ku kv l kw kx">1 2 3 <br/>4 5 6</span></pre><p id="06af" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi">1-&gt;2-&gt;3-&gt;6</p><p id="4631" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi">1-&gt;2-&gt;5-&gt;6</p><p id="d0f4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi">1-&gt;4-&gt;5-&gt;6</p><p id="a03e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有三种这样的方法。那么如何解决这个问题呢？到达位置 P sub i，j 的方法数是 P sub i-1，j 和 P sub i，j-1 的和。因此，在上面的矩阵中，它看起来像这样:</p><pre class="kj kk kl km gt kn ko kp kq aw kr bi"><span id="634f" class="ks kt in ko b gy ku kv l kw kx">1 1 1<br/>1 2 3</span></pre><p id="a77a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">那么答案在 P sub n，m 处，正如你看到的位置(2，2)是位置(1，0)和(0，1)的和。位置(2，3)也是如此。下面是用 C++解决这类问题的代码。</p><figure class="kj kk kl km gt lm"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="2afd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">既然我们已经解决了较简单的问题，我们应该着手解决难题了。回想一下，这次我们有一个加权图，这意味着每个位置都有一个相关的“成本”,我们希望最小化所述成本。这是给定的样本输入:</p><pre class="kj kk kl km gt kn ko kp kq aw kr bi"><span id="2957" class="ks kt in ko b gy ku kv l kw kx">3 4<br/>3 1 2 4<br/>9 8 7 6<br/>2 8 9 2</span></pre><p id="67d1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，我们如何将之前使用的算法转换成这个问题呢？好吧，因为我们试图最小化位置(N，M)的最终价格，我们应该在这个过程中做一些最小化。然而，在这个算法中我们不能贪婪，因为在高基础成本之后，可能有更好的路径未被探索。我们应该做的是，不要盲目地把 P sub i-1，j 和 P sub i，j-1 相加，我们应该把其中的最小值相加，因为这将给出最小成本路径。以给定样本输入中的(2，2)为例。去那里最便宜的方法是什么？是 3-&gt;1-&gt;8 还是 3-&gt;9-&gt;8？使用上面给出的直觉，位置(1，2)的数字变成 4，同样位置(2，1)的数字变成 12。那么，得到(2，2)的最小成本就是(2，2)的成本，以及(2，1)和(1，2)的最小成本。让我们稍微修改一下代码，让它工作起来。回想一下这个例子，我们也不能盲目地初始化矩阵，我们必须接收它作为输入。</p><figure class="kj kk kl km gt lm"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="5b70" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果这有助于您理解 DP 问题的这一分支，请留下赞，如果您希望我解释/解决任何编码问题，请留下评论。</p></div></div>    
</body>
</html>