<html>
<head>
<title>Building a Secure WebSocket Server using Rust &amp; Warp with Docker</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Rust &amp; Warp 和 Docker 构建安全的 WebSocket 服务器</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/building-a-secure-websocket-server-with-rust-warp-in-docker-20e842d143af?source=collection_archive---------1-----------------------#2022-01-25">https://blog.devgenius.io/building-a-secure-websocket-server-with-rust-warp-in-docker-20e842d143af?source=collection_archive---------1-----------------------#2022-01-25</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/8617700f95913e49236c3a5bcb33aa24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BP0v6HEJDgjPzpEG"/></div></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk translated">照片由<a class="ae ja" href="https://unsplash.com/@tvick?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">泰勒维克</a>在<a class="ae ja" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><div class=""/><p id="32d1" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">WebSocket 服务器 TLS 入门，使用 Rust 在云中部署安全的应用程序。</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><p id="999e" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">那么，您现在有了一个基于 Rust 的 API /低延迟后端，并希望连接到您的前端客户端？本指南将从头到尾介绍如何使用 TLS 设置 HTTP/WebSocket 服务器，并在您自己的云应用程序的容器中运行它。</p><p id="c3e6" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="lf">注意:在继续之前，请确保您已经安装了最新版本的 Rust </em>  <em class="lf">和</em><a class="ae ja" href="https://docs.docker.com/get-docker/" rel="noopener ugc nofollow" target="_blank"><em class="lf">Docker</em></a><em class="lf">。</em></p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h1 id="3f40" class="lg lh jd bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">设置 Rust 项目</h1><p id="b513" class="pw-post-body-paragraph ka kb jd kc b kd me kf kg kh mf kj kk kl mg kn ko kp mh kr ks kt mi kv kw kx ig bi translated">让我们从建立 Rust 项目开始，使用 Cargo。在这种情况下，创建我们的新项目<em class="lf"> hello_rs_wss: </em></p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="1e0f" class="ms lh jd mo b gy mt mu l mv mw">$ cargo new hello_rs_wss</span></pre><p id="97a9" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们应该会看到这样的目录结构:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="9bfe" class="ms lh jd mo b gy mt mu l mv mw">|-Cargo.toml <br/>|-.gitignore <br/>|-src<br/>| |-main.rs</span></pre><p id="5d62" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在继续之前，我们需要设置使用 Warp 的依赖关系。为此，修改<code class="fe mx my mz mo b">Cargo.toml</code>文件，如下所示:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="9ea9" class="ms lh jd mo b gy mt mu l mv mw">[package]<br/>name = "hello_rs_wss"<br/>version = "0.1.0"<br/>edition = "2022"</span><span id="0b0d" class="ms lh jd mo b gy na mu l mv mw">[dependencies]<br/>tokio = {version = "1.4.0", features = ["rt", "rt-multi-thread", "macros"]}<br/>warp = {version="*", features = ["tls"]}<br/>futures = "*"</span></pre><p id="d31c" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后，您可以构建项目来安装依赖项:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="a92c" class="ms lh jd mo b gy mt mu l mv mw">$ cargo build</span></pre></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h1 id="32a3" class="lg lh jd bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">从简单的 HTTP 服务器开始</h1><p id="ff01" class="pw-post-body-paragraph ka kb jd kc b kd me kf kg kh mf kj kk kl mg kn ko kp mh kr ks kt mi kv kw kx ig bi translated">首先，让我们先用<a class="ae ja" href="https://github.com/seanmonstar/warp" rel="noopener ugc nofollow" target="_blank"> Warp </a>设置 HTTP 服务器。</p><p id="6739" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这将在用户请求时返回一个简单的<code class="fe mx my mz mo b">index.html</code>页面。首先，在 Rust 项目所在的根目录下创建<code class="fe mx my mz mo b">index.html</code>,并将其修改如下:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="d5f5" class="ms lh jd mo b gy mt mu l mv mw">&lt;!DOCTYPE html&gt;<br/>&lt;html&gt;<br/>    &lt;body&gt;<br/>        &lt;script&gt;<br/>            window.onload = () =&gt; {<br/>                const BACKEND_URL = "wss://" + window.location.hostname + ":9231/echo"<br/>                const socket = new WebSocket(BACKEND_URL)<br/>                socket.onopen = () =&gt;  { <br/>                    console.log("Socket Opened")<br/>                    setInterval(_ =&gt; socket.send("Hello rust!"), 3000)<br/>                }<br/>                socket.onmessage = (msg) =&gt; alert(msg.data)<br/>                socket.onerror = (err) =&gt; console.error(err)<br/>                socket.onclose = () =&gt; console.log("Socket Closed")<br/>            }<br/>        &lt;/script&gt;<br/>    &lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="b77a" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这就建立了一个基本的 WebSocket 客户端，它将发送“Hello rust！”每 3 秒钟从客户端的浏览器发送到我们的 WebSocket 服务器。</p><p id="6691" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">接下来，我们需要生成一个公钥-私钥对，Warp 将使用它来安全地提供内容。在这种情况下，我们可以使用(在项目的根目录中)进行设置:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="4c59" class="ms lh jd mo b gy mt mu l mv mw">$ openssl req -newkey rsa:2048 -new -nodes -x509 -days 3650 -keyout key.rsa -out cert.pem</span></pre><p id="cbc3" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，在<code class="fe mx my mz mo b">main.rs</code>文件中，我们可以设置 HTTP 服务器，它将返回我们刚刚创建的 HTML，使用一个简单的 Warp 路由:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="1579" class="ms lh jd mo b gy mt mu l mv mw">use warp::Filter;</span><span id="1432" class="ms lh jd mo b gy na mu l mv mw">#[tokio::main]<br/>async fn main() {    <br/>    let current_dir = std::env::current_dir().expect("failed to read current directory");<br/>    let routes = warp::get().and(warp::fs::dir(current_dir));</span><span id="9270" class="ms lh jd mo b gy na mu l mv mw">warp::serve(routes)<br/>        .tls()<br/>        .cert_path("cert.pem")<br/>        .key_path("key.rsa")<br/>        .run(([0, 0, 0, 0], 9231)).await;<br/>}</span></pre><p id="26da" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，您可以使用以下命令再次运行:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="b63d" class="ms lh jd mo b gy mt mu l mv mw">$ cargo run</span></pre><p id="a55b" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这将在<a class="ae ja" href="https://0.0.0.0:9231/index.html" rel="noopener ugc nofollow" target="_blank">https://0 . 0 . 0 . 0:9231/index . html</a>显示一个空网页，并要求您在浏览器上导航到该站点时接受证书警告。</p><p id="135a" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，该页面将尝试连接到尚不存在的 WebSocket 服务器。</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h1 id="acf2" class="lg lh jd bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">实现 WebSocket 服务器</h1><p id="08d0" class="pw-post-body-paragraph ka kb jd kc b kd me kf kg kh mf kj kk kl mg kn ko kp mh kr ks kt mi kv kw kx ig bi translated">然后我们可以设置 WebSocket 服务器，作为 Warp 服务器上的附加路由。您可以修改<code class="fe mx my mz mo b">main.rs</code>文件，使其看起来像这样:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="c735" class="ms lh jd mo b gy mt mu l mv mw">use futures::StreamExt;<br/>use futures::FutureExt;<br/>use warp::Filter;</span><span id="d015" class="ms lh jd mo b gy na mu l mv mw">#[tokio::main]<br/>async fn main() {</span><span id="4f28" class="ms lh jd mo b gy na mu l mv mw">let echo = warp::path("echo")<br/>        .and(warp::ws())<br/>        .map(|ws: warp::ws::Ws| {<br/>            ws.on_upgrade(|websocket| {<br/>                let (tx, rx) = websocket.split();<br/>                rx.forward(tx).map(|result| {<br/>                    if let Err(e) = result {<br/>                        eprintln!("websocket error: {:?}", e);<br/>                    }<br/>                })<br/>            })<br/>        });<br/>    <br/>    let current_dir = std::env::current_dir().expect("failed to read current directory");<br/>    let routes = warp::get().and(echo.or(warp::fs::dir(current_dir)));</span><span id="46e1" class="ms lh jd mo b gy na mu l mv mw">warp::serve(routes)<br/>        .tls()<br/>        .cert_path("cert.pem")<br/>        .key_path("key.rsa")<br/>        .run(([0, 0, 0, 0], 9231)).await;<br/>}</span></pre><p id="73e4" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这现在创建了一个名为<code class="fe mx my mz mo b">echo</code>的附加路由，它公开了一个 WebSocket 端点。上面的实现只是将 WebSocket 上接收到的内容发送回相应的客户端。</p><p id="0176" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，如果您使用<code class="fe mx my mz mo b">cargo run</code>运行这个程序，并导航到与之前相同的站点(<a class="ae ja" href="https://0.0.0.0:9231/index.html" rel="noopener ugc nofollow" target="_blank">https://0 . 0 . 0 . 0:9231/index . html</a>)，它将加载 JavaScript(来自之前创建的<code class="fe mx my mz mo b">index.html </code>)，该 JavaScript 将尝试连接到<code class="fe mx my mz mo b">echo</code> WebSocket 端点并每 3 秒发送一条消息。</p><p id="921d" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您将能够看到客户端通过浏览器内置的<code class="fe mx my mz mo b">alert(...)</code>机制接收到来自服务器的响应。</p><p id="05f8" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="lf">注意:这个例子是使用</em><a class="ae ja" href="https://docs.rs/warp/latest/warp/" rel="noopener ugc nofollow" target="_blank"><em class="lf">Warp docs</em></a><em class="lf">和它们的例子的组合构建的——看看</em> <a class="ae ja" href="https://github.com/seanmonstar/warp/blob/master/examples/tls.rs" rel="noopener ugc nofollow" target="_blank"> <em class="lf">基本 TLS </em> </a> <em class="lf">和</em> <a class="ae ja" href="https://github.com/seanmonstar/warp/blob/master/examples/websockets.rs" rel="noopener ugc nofollow" target="_blank"> <em class="lf">基本 WebSocket </em> </a> <em class="lf">的例子。</em></p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h1 id="49f4" class="lg lh jd bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">使用 Docker 构建和运行</h1><p id="5ec9" class="pw-post-body-paragraph ka kb jd kc b kd me kf kg kh mf kj kk kl mg kn ko kp mh kr ks kt mi kv kw kx ig bi translated">现在我们有了一个正在运行的、安全的 HTTP 和 WebSocket 服务器，让我们创建一个容器，我们可以在其中构建和运行我们的应用程序，以便以后进行部署。</p><p id="5f6f" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">首先，在 Rust 项目的根目录下创建一个名为<code class="fe mx my mz mo b">Dockerfile</code>的文件，并向其中添加以下内容:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="3327" class="ms lh jd mo b gy mt mu l mv mw"># Tells docker to use the latest Rust official image<br/>FROM rust:latest</span><span id="db20" class="ms lh jd mo b gy na mu l mv mw"># Copy our current working directory into the container<br/>COPY ./ ./</span><span id="8a00" class="ms lh jd mo b gy na mu l mv mw"># Create the release build<br/>RUN cargo build --release</span><span id="88f8" class="ms lh jd mo b gy na mu l mv mw"># Generate our self signed certs (change these parameters accordingly!)<br/>RUN openssl req -newkey rsa:2048 -new -nodes -x509 -days 3650 -keyout key.rsa -out cert.pem \<br/>    -subj "/C=GB/ST=London/L=London/O=Global Security/OU=IT Department/CN=example.com"</span><span id="524c" class="ms lh jd mo b gy na mu l mv mw"># Expose the port our app is running on<br/>EXPOSE 9231</span><span id="36bd" class="ms lh jd mo b gy na mu l mv mw"># Run the application!<br/>CMD ["./target/release/hello_rs_wss"]</span></pre><p id="48ec" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是一个非常基本的例子，说明我们如何在容器中构建 Rust 应用程序，在构建过程中生成自签名证书——您需要根据您的证书信息相应地更改参数。</p><p id="0bed" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后，我们可以使用以下命令构建并运行容器:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="cba9" class="ms lh jd mo b gy mt mu l mv mw">$ docker build -t hello_rs_wss .<br/>$ docker run -p 9231:9231 -t hello_rs_wss</span></pre><p id="973d" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">上面将构建一个名为<em class="lf"> hello_rs_wss </em>的容器，然后运行该容器，并公开 9231 端口，以便与我们的应用程序进行通信。</p><p id="1eb5" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">与之前类似，当容器运行时，您可以在本地再次导航到与之前相同的 URL，以访问应用程序并测试它是否工作正常—<a class="ae ja" href="https://0.0.0.0:9231/index.html" rel="noopener ugc nofollow" target="_blank">https://0 . 0 . 0 . 0:9231/index . html</a>(记住接受自签名证书的风险)。</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><p id="8f02" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">就是这样！您现在已经:</p><ul class=""><li id="d91b" class="nb nc jd kc b kd ke kh ki kl nd kp ne kt nf kx ng nh ni nj bi translated">设置一个带有货物管理依赖项的 Rust 应用程序。</li><li id="d883" class="nb nc jd kc b kd nk kh nl kl nm kp nn kt no kx ng nh ni nj bi translated">为 HTTP 和 WebSocket 通信的 TLS 加密生成您自己的证书。</li><li id="6930" class="nb nc jd kc b kd nk kh nl kl nm kp nn kt no kx ng nh ni nj bi translated">构建并公开 HTTP 和 WebSocket 端点。</li><li id="53cd" class="nb nc jd kc b kd nk kh nl kl nm kp nn kt no kx ng nh ni nj bi translated">演示了一个安全连接到后端 API 的前端客户端。</li><li id="025d" class="nb nc jd kc b kd nk kh nl kl nm kp nn kt no kx ng nh ni nj bi translated">在 Docker 中构建并运行整个应用程序，为快速云部署做好准备。</li></ul></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h1 id="c834" class="lg lh jd bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">下一步是什么？</h1><p id="32c1" class="pw-post-body-paragraph ka kb jd kc b kd me kf kg kh mf kj kk kl mg kn ko kp mh kr ks kt mi kv kw kx ig bi translated">现在您已经有了一个可以工作的应用程序，这里有一些可以继续改进您的项目的地方:</p><ul class=""><li id="677b" class="nb nc jd kc b kd ke kh ki kl nd kp ne kt nf kx ng nh ni nj bi translated">设置浏览器通过 CA 识别证书(例如<a class="ae ja" href="https://letsencrypt.org/getting-started/" rel="noopener ugc nofollow" target="_blank">让我们加密</a>)</li><li id="060d" class="nb nc jd kc b kd nk kh nl kl nm kp nn kt no kx ng nh ni nj bi translated">通过多个阶段提高您的 Docker 构建规模</li><li id="e575" class="nb nc jd kc b kd nk kh nl kl nm kp nn kt no kx ng nh ni nj bi translated">将您的应用部署到云提供商(例如<a class="ae ja" href="https://docs.aws.amazon.com/AmazonECS/latest/userguide/docker-basics.html" rel="noopener ugc nofollow" target="_blank"> AWS </a></li></ul><p id="ba86" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果你也有兴趣在 Rust &amp; Docker 中用<a class="ae ja" href="https://actix.rs/" rel="noopener ugc nofollow" target="_blank"> actix-web </a>构建一个 HTTP 服务器，那么看看我的另一个指南:</p><div class="im in gp gr io np"><a href="https://awstip.com/rust-docker-helloworld-c38070c0dd9c" rel="noopener  ugc nofollow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd je gy z fp nu fr fs nv fu fw jc bi translated">Rust &amp; Docker HelloWorld！</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">Rust 和 Docker 中的 HTTP 服务器入门。</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">awstip.com</p></div></div><div class="ny l"><div class="nz l oa ob oc ny od iu np"/></div></div></a></div></div></div>    
</body>
</html>