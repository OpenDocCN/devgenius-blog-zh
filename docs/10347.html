<html>
<head>
<title>What’s new in Swift 5.7?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift 5.7 有什么新功能？</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/whats-new-in-swift-5-7-8e3f06e93e30?source=collection_archive---------1-----------------------#2022-10-26">https://blog.devgenius.io/whats-new-in-swift-5-7-8e3f06e93e30?source=collection_archive---------1-----------------------#2022-10-26</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="7de7" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">新功能、增强和改进</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/c42c6e7e24e8f7e6330e74d314911155.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FrMBxl67GKpKleWez188eA.png"/></div></div></figure><p id="54c6" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">Swift 5.7 提供了语言和标准库增强功能、可用性改进，并实施了一种新的通用技术，可提升性能并消除长期存在的缺陷。这一增强包括标准样板代码的一种新的速记语法，包括<strong class="kq io"> if let </strong>语句和多语句、闭包类型的注释。</p><p id="9290" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">Swift 5.7 新的 generics 实现修复了许多 bug，比如处理复杂的同类型需求，比如集合子序列关联类型，以及使用 CaseIterable 协议的代码，该协议定义了条件 Self。元素==自身。<br/> <br/>下面我们将通过动手的例子看到一些变化。</p><p id="899b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io"> 1。Swift 包管理器改进<br/> </strong> <a class="ae lk" href="https://www.swift.org/package-manager/" rel="noopener ugc nofollow" target="_blank"> Swift 包管理器</a>是 Swift 项目的依赖管理器，包括可以为 macOS 和 Linux 构建的构建系统。Swift 5.7，Swift 包管理器获得了令人兴奋的改进，这将帮助我们避免在项目中使用多个同名包的问题。它现在允许我们从定义模块的包外部命名模块，并添加模块别名。</p><p id="2dbd" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io"> 2。代码完成<br/> </strong>函数调用参数、变量和全局函数的代码完成现已紧密集成到 Swift 的类型检查器中。这允许代码完成在不明确的代码或有错误的代码中提供更准确的结果。</p><p id="35b9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果在下面的例子中的<code class="fe ll lm ln lo b">+</code>之后完成，代码完成现在报告<strong class="kq io"> int </strong>和<strong class="kq io"> string </strong>匹配周围的上下文，允许编辑器将这些结果排在比<strong class="kq io">数组</strong>更高的位置。</p><pre class="kd ke kf kg gt lp lo lq lr aw ls bi"><span id="ee70" class="lt lu in lo b gy lv lw l lx ly">func makeIntOrString() <strong class="lo io">-&gt;</strong> Int {}<br/>func makeIntOrString() <strong class="lo io">-&gt;</strong> String {}<br/><br/>let array <strong class="lo io">=</strong> [4, 2]<br/>let int <strong class="lo io">=</strong> 42<br/>let string <strong class="lo io">=</strong> "Hello World!"<br/>makeIntOrString() <strong class="lo io">+</strong></span></pre><p id="9053" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果在下面的示例中完成缺少的参数，代码完成现在只建议 secondInt 参数标签并省略 secondString。</p><pre class="kd ke kf kg gt lp lo lq lr aw ls bi"><span id="5903" class="lt lu in lo b gy lv lw l lx ly">func add(_ firstInt: Int, secondInt: Int) {}<br/>func add(_ firstString: String, secondString: String) {}<br/>add(1, )</span></pre><p id="a29f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io"> 3。展开可选选项的简写</strong>(<a class="ae lk" href="https://github.com/apple/swift-evolution/blob/main/proposals/0345-if-let-shorthand.md" rel="noopener ugc nofollow" target="_blank">SE-0345</a>)<strong class="kq io"/><br/>Swift 5.7 引入了新的简写语法，使用<strong class="kq io"> if let </strong>和<strong class="kq io"> guard let 将可选选项展开到同名的隐藏变量中。</strong></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="ea22" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这种变化不会扩展到对象内部的属性，这意味着这样的代码将无法工作。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="ddd7" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io"> 4。从默认表达式进行类型推断</strong>(<a class="ae lk" href="https://github.com/apple/swift-evolution/blob/main/proposals/0347-type-inference-from-default-exprs.md" rel="noopener ugc nofollow" target="_blank">SE-0347</a>)<strong class="kq io"><br/></strong>Swift 扩展了使用带有通用参数类型的默认值的能力。如果我们有一个通用类型或函数，我们现在可以为默认表达式提供一个具体类型，而在以前 Swift 会抛出一个编译器错误。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="7966" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们也可以使用自定义序列调用该函数，或者使用默认序列。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="7b18" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io"> 5。多语句闭包类型推理</strong>(<a class="ae lk" href="https://github.com/apple/swift-evolution/blob/main/proposals/0326-extending-multi-statement-closure-inference.md" rel="noopener ugc nofollow" target="_blank">SE-0326</a>)<strong class="kq io"><br/></strong>Swift 通过启用来自闭包体的参数和结果类型推理，改进了多语句闭包的推理行为。这将使类型推断对开发人员来说不那么令人惊讶，并消除了现有的行为悬崖，即在闭包中再添加一个表达式或语句可能会导致编译失败。</p><pre class="kd ke kf kg gt lp lo lq lr aw ls bi"><span id="de2e" class="lt lu in lo b gy lv lw l lx ly"><strong class="lo io">let</strong> scores = [100, 80, 85]<br/><br/><strong class="lo io">let</strong> results = scores.map { score <strong class="lo io">in</strong><br/>    <strong class="lo io">if</strong> score &gt;= 85 {<br/>        <strong class="lo io">return</strong> "Student score is \(score)%: Pass"<br/>    } <strong class="lo io">else</strong> {<br/>        <strong class="lo io">return</strong> "Student score is \(score)%: Fail"<br/>    }<br/>}</span></pre><p id="4853" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在 Swift 5.7 之前，我们需要明确指定返回类型:</p><pre class="kd ke kf kg gt lp lo lq lr aw ls bi"><span id="d8be" class="lt lu in lo b gy lv lw l lx ly"><strong class="lo io">// </strong>Prior to Swift 5.7<strong class="lo io"><br/>let</strong> results = scores.map { score -&gt; String <strong class="lo io">in</strong><br/>    <strong class="lo io">if</strong> score &gt;= 85 {<br/>        <strong class="lo io">return</strong> "Student score is \(score)%: Pass"<br/>    } <strong class="lo io">else</strong> {<br/>        <strong class="lo io">return</strong> "Student score is \(score)%: Fail"<br/>    }</span></pre><p id="cfb8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io"> 6。解锁所有协议的存在性</strong>(<a class="ae lk" href="https://github.com/apple/swift-evolution/blob/main/proposals/0309-unlock-existential-types-for-all-protocols.md" rel="noopener ugc nofollow" target="_blank">SE-0309</a>)<strong class="kq io"><br/></strong>Swift 5.7 大幅放宽了当协议有关联的类型需求时将协议作为类型使用的禁令。简单来说，这意味着下面的代码。</p><pre class="kd ke kf kg gt lp lo lq lr aw ls bi"><span id="ba9b" class="lt lu in lo b gy lv lw l lx ly"><strong class="lo io">let</strong> firstName: any Equatable = "iOS"<br/><strong class="lo io">let</strong> lastName: any Equatable = 16</span></pre><p id="2f85" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">Equatable 是一个带有<strong class="kq io"> Self </strong>的协议，它提供了引用采用它的特定类型的功能。<strong class="kq io">等价</strong>协议有一个要求是这样的:<strong class="kq io"> func ==(lhs: Self，rhs: Self) - &gt; Bool </strong>。这意味着它将能够接受相同类型的两个实例，并告诉我们它们是否相同。实例可能是两个整数、两个字符串、两个布尔值，或者两个符合<strong class="kq io">等价</strong>的任何其他类型。</p><p id="a5ad" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在 Swift 5.7 之前，编译器不允许我们在这样的代码中使用它。</p><pre class="kd ke kf kg gt lp lo lq lr aw ls bi"><span id="a2f6" class="lt lu in lo b gy lv lw l lx ly"><strong class="lo io">let</strong> <!-- -->spaceflight<!-- -->: [any Equatable] = ["<!-- -->Apollo<!-- -->", 11]</span></pre><p id="38b1" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">从 Swift 5.7 开始，这个代码<em class="mb">是允许的</em>，我们已经获得了对我们的数据进行运行时检查的能力，以准确识别我们正在处理的内容。</p><pre class="kd ke kf kg gt lp lo lq lr aw ls bi"><span id="b173" class="lt lu in lo b gy lv lw l lx ly"><strong class="lo io">for</strong> item <strong class="lo io">in</strong> <!-- -->spaceflight<!-- --> {<br/>    <strong class="lo io">if</strong> <strong class="lo io">let</strong> item = item <strong class="lo io">as</strong>? String {<br/>        print("Found string: \(item)")<br/>    } <strong class="lo io">else</strong> <strong class="lo io">if</strong> <strong class="lo io">let</strong> item = item <strong class="lo io">as</strong>? Int {<br/>        print("Found integer: \(item)")<br/>    }<br/>}</span></pre><p id="4651" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io"> 7。结构不透明的结果类型</strong>(<a class="ae lk" href="https://github.com/apple/swift-evolution/blob/main/proposals/0328-structural-opaque-result-types.md" rel="noopener ugc nofollow" target="_blank">SE-0328</a>)<strong class="kq io"><br/></strong>不透明的返回类型意味着，调用者不需要指定底层的返回类型或参数类型，调用者必须确定得到一个具体的类型。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="8440" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">SwiftUI 中的 HStack、ZStack、Group 和 List 包含了创建复杂类型结构的其他视图。不透明的结果类型对调用者非常有帮助，调用者只知道这个结构是<strong class="kq io">一些视图</strong>。不透明的结果类型使代码在运行时更具性能。</p><pre class="kd ke kf kg gt lp lo lq lr aw ls bi"><span id="824e" class="lt lu in lo b gy lv lw l lx ly"><strong class="lo io">func</strong> makeFooterView(isIpad: Bool) -&gt; <strong class="lo io">some</strong> View {<br/>    <strong class="lo io">return</strong> VStack { <br/>      <strong class="lo io">if</strong> isIpad { <br/>         Text("Hi It is iPad device!") <br/>      } <strong class="lo io">else</strong> { <br/>        Text("Hi It is not iPad device?") <br/>        Button("Check device details", action: {})<br/>    }<br/>  }<br/>}</span></pre><p id="e39f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在我们也可以一次返回多个不透明类型</p><pre class="kd ke kf kg gt lp lo lq lr aw ls bi"><span id="133c" class="lt lu in lo b gy lv lw l lx ly"><strong class="lo io">func</strong> makeHeaderView() -&gt; (<strong class="lo io">some</strong> Equatable, <strong class="lo io">some</strong> Equatable)  {<br/>     (Text("Title Text"), Text("Text"))<br/>}</span></pre><p id="24fd" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io"> 8。不透明的参数声明</strong>(<a class="ae lk" href="https://github.com/apple/swift-evolution/blob/main/proposals/0341-opaque-parameters.md" rel="noopener ugc nofollow" target="_blank">SE-0341</a>)<strong class="kq io"><br/></strong>不透明的结果类型<code class="fe ll lm ln lo b">some P</code>表示一个未命名的类型，只有通过它的约束才能知道:它符合协议<code class="fe ll lm ln lo b">P</code>。当参数类型中出现不透明类型时，它会被(未命名的)泛型参数替换。</p><pre class="kd ke kf kg gt lp lo lq lr aw ls bi"><span id="0ae1" class="lt lu in lo b gy lv lw l lx ly"><strong class="lo io">func</strong> isSorted(array: [<strong class="lo io">some</strong> Comparable]) -&gt; Bool {<br/>    array == array.sorted()<br/>}</span></pre><p id="9ff3" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe ll lm ln lo b"><strong class="kq io">[some Comparable]</strong></code>参数类型意味着该函数使用一个数组，该数组包含一种符合<code class="fe ll lm ln lo b"><strong class="kq io">Comparable</strong></code>协议的类型的元素，这相当于下面的通用代码:</p><pre class="kd ke kf kg gt lp lo lq lr aw ls bi"><span id="d272" class="lt lu in lo b gy lv lw l lx ly"><strong class="lo io">func</strong> isSorted&lt;T: Comparable&gt;(array: [T]) -&gt; Bool {<br/>    array == array.sorted()<br/>}</span></pre><p id="87ce" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io"> 9。扩展绑定泛型类型</strong><a class="ae lk" href="https://github.com/apple/swift-evolution/blob/main/proposals/0361-bound-generic-extensions.md" rel="noopener ugc nofollow" target="_blank"><strong class="kq io">SE-0361</strong></a><strong class="kq io"><br/></strong>扩展绑定泛型类型使用尖括号作为绑定类型参数，或者使用加糖类型，如【字符串】和<code class="fe ll lm ln lo b">Int?</code>。</p><pre class="kd ke kf kg gt lp lo lq lr aw ls bi"><span id="5cb8" class="lt lu in lo b gy lv lw l lx ly"><strong class="lo io">extension</strong> Array where Element == String { … } <br/><strong class="lo io">extension</strong> Array&lt;String&gt; { … } <br/><strong class="lo io">extension</strong> [String] { … }</span></pre><p id="68bb" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">Swift 5.7 之前的编译器产生如下错误。</p><pre class="kd ke kf kg gt lp lo lq lr aw ls bi"><span id="3fce" class="lt lu in lo b gy lv lw l lx ly">extension Array&lt;String&gt; { ... } <strong class="lo io">// error: Constrained extension must be declared on the unspecialized generic type 'Array' with constraints specified by a 'where' clause</strong></span></pre><p id="8a62" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io"> 10。Swift 中隐式打开的存在性</strong>(<a class="ae lk" href="https://github.com/apple/swift-evolution/blob/main/proposals/0352-implicit-open-existentials.md" rel="noopener ugc nofollow" target="_blank">SE-0352</a>)<strong class="kq io"><br/></strong>存在性类型允许存储一个值，该值的具体类型未知，并且可能在运行时改变。那个存储值的动态类型，我们称之为存在的底层类型，只有它所符合的协议集以及它的超类才知道。虽然存在类型对于表达动态类型的值是有用的，但是由于它们的动态性质，它们必然受到限制。</p><pre class="kd ke kf kg gt lp lo lq lr aw ls bi"><span id="e50b" class="lt lu in lo b gy lv lw l lx ly"><strong class="lo io">func</strong> square&lt;T: Numeric&gt;(<strong class="lo io">_</strong> number: T) -&gt; T {<br/>    number * number<br/>}</span></pre><p id="d280" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">当我们的数据符合协议时，隐式开放的存在允许函数可调用。</p><pre class="kd ke kf kg gt lp lo lq lr aw ls bi"><span id="205c" class="lt lu in lo b gy lv lw l lx ly"><strong class="lo io">let</strong> firstItem = 5<br/><strong class="lo io">let</strong> secondItem = 7.0<br/><br/><strong class="lo io">let</strong> numbers: [any Numeric] = [firstItem, secondItem]<br/><br/><strong class="lo io">for</strong> number <strong class="lo io">in</strong> numbers {<br/>    print(double(number))<br/>}</span></pre><p id="c2ac" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">若要打开存在，实参必须是存在类型<code class="fe ll lm ln lo b">any P</code>或存在元类型<code class="fe ll lm ln lo b"><strong class="kq io">any P.Type</strong></code>，并且必须提供给一个类型为泛型形参的形参，该形参可以直接绑定到存在的基础类型。</p><p id="f0b7" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io"> 11。正则表达式文字</strong>(<a class="ae lk" href="https://github.com/apple/swift-evolution/blob/main/proposals/0354-regex-literals.md" rel="noopener ugc nofollow" target="_blank">SE-0354</a>)<strong class="kq io"><br/></strong>正则表达式文字可以使用<code class="fe ll lm ln lo b">/.../</code>分隔符来编写。编译器将解析 regex 文本的内容，在编译时诊断任何错误。捕获类型和标签是根据正则表达式中存在的捕获组自动推断出来的。</p><pre class="kd ke kf kg gt lp lo lq lr aw ls bi"><span id="27b4" class="lt lu in lo b gy lv lw l lx ly">func matchHexAssignment(_ input: String) -&gt; (String, Int)? {<br/>  let regex = /(?&lt;identifier&gt;[[:alpha:]]\w*) = (?&lt;hex&gt;[0-9A-F]+)/<br/>  // regex: Regex&lt;(Substring, identifier: Substring, hex: Substring)&gt;<br/>  <br/>  guard let match = input.wholeMatch(of: regex), <br/>        let hex = Int(match.hex, radix: 16) <br/>  else { return nil }<br/>  <br/>  return (String(match.identifier), hex)<br/>}</span></pre><p id="e763" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io"> 12。regex builder</strong>(<a class="ae lk" href="https://github.com/apple/swift-evolution/blob/main/proposals/0351-regex-builder.md" rel="noopener ugc nofollow" target="_blank">SE-0351</a>)<br/>Swift 5.7 对字符串处理进行了重大更新，引入了 regex 文字和<a class="ae lk" href="https://developer.apple.com/documentation/RegexBuilder" rel="noopener ugc nofollow" target="_blank"> RegexBuilder </a>库，并配有匹配方法和强类型捕获。</p><pre class="kd ke kf kg gt lp lo lq lr aw ls bi"><span id="d3f5" class="lt lu in lo b gy lv lw l lx ly"><strong class="lo io">let</strong> text = "I like Swift and SwiftUI"<br/><strong class="lo io">let</strong> regex = /I like (?&lt;text1&gt;.+?) and (?&lt;text2&gt;.+?)/<br/><strong class="lo io">if</strong> <strong class="lo io">let</strong> likes = <strong class="lo io">try</strong>? regex.wholeMatch(<strong class="lo io">in</strong>: text) {<br/>    print("Your first choice is \(likes.text1)")<br/>    print("Your second choice is \(likes.text2)")<br/>}</span></pre><p id="df4c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">使用 RegexBuilder，我们可以用 SwiftUI 风格的语言构建我们的 regex 搜索，这可以使它更具可读性，并释放更强大的功能。</p><pre class="kd ke kf kg gt lp lo lq lr aw ls bi"><span id="20ca" class="lt lu in lo b gy lv lw l lx ly"><strong class="lo io">import</strong> RegexBuilder</span><span id="61f8" class="lt lu in lo b gy mc lw l lx ly"><strong class="lo io">let</strong> text = "I like Swift and SwiftUI"<br/><strong class="lo io">let</strong> word = OneOrMore(.word)<br/><strong class="lo io">let</strong> regex = Regex {<br/>    "I like "<br/>    Capture { word }<br/>    " and "<br/>    Capture { word }<br/>}</span><span id="1796" class="lt lu in lo b gy mc lw l lx ly"><strong class="lo io">if</strong> <strong class="lo io">let</strong> votes = <strong class="lo io">try</strong>? regex.wholeMatch(<strong class="lo io">in</strong>: text) {<br/>  <strong class="lo io">let</strong> (_, bird1, bird2) = votes.output<br/>  print("Your first choice is \(bird1)") <br/>  print("Your second choice is \(bird2)")<br/>}</span></pre><p id="d1ed" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io"> 13。顶层代码中的并发</strong>(<a class="ae lk" href="https://github.com/apple/swift-evolution/blob/main/proposals/0343-top-level-concurrency.md" rel="noopener ugc nofollow" target="_blank">SE-0343</a>)<strong class="kq io"><br/></strong>在一个 macOS 命令行工具项目中，你可以将下面的代码直接写入 main.swift 文件中。之前，我们必须创建一个新的<strong class="kq io"> @main </strong>结构，它有一个异步的<strong class="kq io"> main() </strong>方法。</p><pre class="kd ke kf kg gt lp lo lq lr aw ls bi"><span id="fd71" class="lt lu in lo b gy lv lw l lx ly"><strong class="lo io">import</strong> Foundation</span><span id="d5db" class="lt lu in lo b gy mc lw l lx ly"><strong class="lo io">let</strong> url = URL(string: "<a class="ae lk" href="https://api.chucknorris.io/jokes/random" rel="noopener ugc nofollow" target="_blank">https://api.chucknorris.io/jokes/random</a>")!<br/><strong class="lo io">let</strong> (data, <strong class="lo io">_</strong>) = <strong class="lo io">try</strong> <strong class="lo io">await</strong> URLSession.shared.data(from: url)<br/><strong class="lo io">let</strong> jokes= <strong class="lo io">try</strong> JSONDecoder().decode(Jokes.<strong class="lo io">self</strong>, from: data)<br/>print("Found random jokes")</span></pre><p id="2e93" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">14。从异步属性(<a class="ae lk" href="https://github.com/apple/swift-evolution/blob/main/proposals/0340-swift-noasync.md" rel="noopener ugc nofollow" target="_blank">SE-0340</a>)<strong class="kq io"><br/></strong>不可用 Swift 并发模型允许任务在不同线程上暂停和恢复。虽然这种行为允许更高的计算资源利用率，但是对于毫无防备的程序员来说，还是有一些令人讨厌的陷阱。</p><p id="f212" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">扩展<strong class="kq io"> @available </strong>来接受一个<strong class="kq io"> noasync </strong>可用性种类。<strong class="kq io"> noasync </strong>可用性类型适用于大多数声明，但不允许在析构函数上使用，因为这些析构函数没有被显式调用，必须可以从任何地方调用。</p><pre class="kd ke kf kg gt lp lo lq lr aw ls bi"><span id="2e41" class="lt lu in lo b gy lv lw l lx ly"><strong class="lo io">@available(</strong>*<strong class="lo io">, noasync)</strong><br/>func doSomethingNefariousWithNoOtherOptions() { }<br/><br/><strong class="lo io">@available(*, noasync, message</strong>: "use our other shnazzy API instead!"<strong class="lo io">)</strong><br/>func doSomethingNefariousWithLocks() { }<br/><br/><strong class="lo io">func</strong> asyncFun() <strong class="lo io">async</strong> {<br/>  // Error: doSomethingNefariousWithNoOtherOptions is unavailable from<br/>  //        asynchronous contexts<br/>  doSomethingNefariousWithNoOtherOptions()<br/><br/>  // Error: doSomethingNefariousWithLocks is unavailable from asynchronous<br/>  //        contexts; use our other shanzzy API instead!<br/>  doSomethingNefariousWithLocks()<br/>}</span></pre><p id="92fb" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe ll lm ln lo b">noasync</code>可用性属性仅阻止 API 在即时异步上下文中使用；在同步上下文中包装对不可用 API 的调用并调用包装器不会发出错误。这允许在异步上下文中以特定的方式安全地使用 API。</p></div><div class="ab cl md me hr mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ig ih ii ij ik"><p id="afa4" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">感谢阅读。如果您有任何意见、问题或建议，请在下面的评论区发表！👇请<strong class="kq io">分享</strong>并给予<strong class="kq io">掌声</strong>👏👏如果你喜欢这篇文章。</p></div></div>    
</body>
</html>