<html>
<head>
<title>PHP — P67: Parent Constructor</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">PHP — P67:父构造函数</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/php-p67-parent-constructor-ec8e41b9a6a9?source=collection_archive---------8-----------------------#2022-07-05">https://blog.devgenius.io/php-p67-parent-constructor-ec8e41b9a6a9?source=collection_archive---------8-----------------------#2022-07-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/b1742b664e443bd1037dbad0dc72c9da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CngHsSOTBpfmu67LBXeeMA.jpeg"/></div></div></figure><p id="f1b3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在过去的几篇文章中，我们已经调用了父构造函数，但并没有深入讨论它的细节。如果子类没有定义构造函数，它就像任何其他方法一样继承父构造函数。如果子类定义了自己的构造函数，父构造函数将被重写。要调用父构造函数，必须从子构造函数调用<em class="kw"> parent::__construct() </em>。</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><p id="6a1e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kw">回顾</em>:回顾之前的文章和代码。</p><div class="le lf gp gr lg lh"><a rel="noopener  ugc nofollow" target="_blank" href="/php-p66-object-comparison-a2e84a8e3e13"><div class="li ab fo"><div class="lj ab lk cl cj ll"><h2 class="bd ir gy z fp lm fr fs ln fu fw ip bi translated">PHP — P66:对象比较</h2><div class="lo l"><h3 class="bd b gy z fp lm fr fs ln fu fw dk translated">PHP 允许你用比较和标识操作符来比较对象。使用比较运算符时…</h3></div><div class="lp l"><p class="bd b dl z fp lm fr fs ln fu fw dk translated">blog.devgenius.io</p></div></div><div class="lq l"><div class="lr l ls lt lu lq lv jw lh"/></div></div></a></div><div class="le lf gp gr lg lh"><a href="https://github.com/dinocajic/php-7-youtube-tutorials/tree/master/66%20Object%20Comparison" rel="noopener  ugc nofollow" target="_blank"><div class="li ab fo"><div class="lj ab lk cl cj ll"><h2 class="bd ir gy z fp lm fr fs ln fu fw ip bi translated">PHP-YouTube-教程/66 对象比较</h2><div class="lo l"><h3 class="bd b gy z fp lm fr fs ln fu fw dk translated">PHP YouTube 教程的代码。为 dinocajic/PHP-YouTube-tutorials 开发做贡献，创建一个…</h3></div><div class="lp l"><p class="bd b dl z fp lm fr fs ln fu fw dk translated">github.com</p></div></div><div class="lq l"><div class="lw l ls lt lu lq lv jw lh"/></div></div></a></div></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><p id="e61c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">看看兰博基尼类，它只是一个扩展 Car 的空类。Car 类包含一个构造函数。</p><figure class="lx ly lz ma gt jr"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="9f89" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以实例化该类并使用父构造函数，而无需在兰博基尼类中指定构造函数。</p><figure class="lx ly lz ma gt jr"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="c50c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">调用<em class="kw">get _ year _ make _ and _ model()</em>方法得到<em class="kw"> 1999 款兰博基尼 Diablo SV </em>。这意味着父构造函数实际上被调用了，它设置了<em class="kw"> $year，$make，</em>和<em class="kw"> $model </em>属性。</p><p id="065e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果兰博基尼类有一个构造函数会怎么样？兰博基尼构造函数也将接受 3 个参数:品牌、型号和颜色。这次我们过不了这一年了。</p><figure class="lx ly lz ma gt jr"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="bc74" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们现在可以尝试一些测试代码，看看它是否有效。</p><figure class="lx ly lz ma gt jr"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="8ec7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">果不其然，确实如此。你可能会认为这不应该考虑到我们从来没有将年份传递给父构造函数。因为我们调用的是兰博基尼构造函数，所以父构造函数永远不会被调用。</p><p id="cabc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是，如果我们确实想调用父构造函数并在使用兰博基尼构造函数时设置年份呢？</p><p id="ba0a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这次我们将修改构造函数以接受 4 个参数:<em class="kw"> $year，$make，$model，</em>和<em class="kw"> $secret_code </em>。为什么<em class="kw"> $secret_code </em>？因为它不存在于汽车类内部。该属性将存在于兰博基尼类中。这将使代码更容易理解。</p><pre class="lx ly lz ma gt md me mf mg aw mh bi"><span id="6788" class="mi mj iq me b gy mk ml l mm mn">public function construct($year, $make, $model, $secret_code) { }</span></pre><p id="5dda" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以使用<em class="kw"> $this </em>关键字设置<em class="kw"> $year、$make </em>和<em class="kw"> $model </em>属性，或者我们可以使用父构造函数。我们如何从子构造函数内部调用父构造函数？</p><pre class="lx ly lz ma gt md me mf mg aw mh bi"><span id="7750" class="mi mj iq me b gy mk ml l mm mn">parent::__construct()</span></pre><figure class="lx ly lz ma gt jr"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="5887" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，它在兰博基尼类中设置了<em class="kw"> $secret_code </em>，并调用汽车构造函数来设置其他三个属性。</p><p id="3cc9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们为<em class="kw"> $secret_code </em>属性添加 getter/setter 方法，这样我们可以做一些额外的测试。</p><figure class="lx ly lz ma gt jr"><div class="bz fp l di"><div class="mb mc l"/></div></figure><figure class="lx ly lz ma gt jr"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="73be" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">运行代码给了我们想要的结果:<em class="kw"> 1999 兰博基尼 Diablo SV 0x4225sdf4。</em></p><p id="2e55" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后要注意的是调用父构造函数的位置。虽然其他面向对象的编程语言要求您首先调用父构造函数，但在 PHP 中，您可以在构造函数中随时调用它。下面的代码也可以。</p><figure class="lx ly lz ma gt jr"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="aec5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我仍然喜欢立即调用父构造函数，然后在子类构造函数中执行任何额外的代码，以防 PHP 将来改变主意。</p><figure class="lx ly lz ma gt jr"><div class="bz fp l di"><div class="mo mc l"/></div></figure></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><div class="lx ly lz ma gt lh"><a href="https://github.com/dinocajic/php-7-youtube-tutorials" rel="noopener  ugc nofollow" target="_blank"><div class="li ab fo"><div class="lj ab lk cl cj ll"><h2 class="bd ir gy z fp lm fr fs ln fu fw ip bi translated">dinocajic/PHP-7-YouTube-教程</h2><div class="lo l"><h3 class="bd b gy z fp lm fr fs ln fu fw dk translated">PHP 7.x YouTube 教程的代码。</h3></div><div class="lp l"><p class="bd b dl z fp lm fr fs ln fu fw dk translated">github.com</p></div></div><div class="lq l"><div class="mp l ls lt lu lq lv jw lh"/></div></div></a></div></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><figure class="lx ly lz ma gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/13c037b8c41f96613a044ccb55349a5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*UW9CShTprbW0u8-7.jpeg"/></div></div></figure><p id="5e2a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">迪诺·卡伊奇目前是<a class="ae mq" href="https://www.lsbio.com/" rel="noopener ugc nofollow" target="_blank"> LSBio(生命周期生物科学公司)</a>、<a class="ae mq" href="https://absoluteantibody.com/" rel="noopener ugc nofollow" target="_blank">绝对抗体</a>、<a class="ae mq" href="https://www.kerafast.com/" rel="noopener ugc nofollow" target="_blank"> Kerafast </a>、<a class="ae mq" href="https://everestbiotech.com/" rel="noopener ugc nofollow" target="_blank">珠穆朗玛生物</a>、<a class="ae mq" href="https://www.nordicmubio.com/" rel="noopener ugc nofollow" target="_blank">北欧 MUbio </a>和<a class="ae mq" href="https://www.exalpha.com/" rel="noopener ugc nofollow" target="_blank"> Exalpha </a>的 IT 主管。他还担任我的自动系统的首席执行官。他有十多年的软件工程经验。他拥有计算机科学学士学位，辅修生物学。他的背景包括创建企业级电子商务应用程序、执行基于研究的软件开发，以及通过写作促进知识的传播。</p><p id="ad7d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可以在<a class="ae mq" href="https://www.linkedin.com/in/dinocajic/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上联系他，在<a class="ae mq" href="https://instagram.com/think.dino" rel="noopener ugc nofollow" target="_blank"> Instagram </a>上关注他，<a class="ae mq" href="https://www.dinocajic.com/" rel="noopener ugc nofollow" target="_blank">订阅他的博客</a>，或者<a class="ae mq" href="https://dinocajic.medium.com/subscribe" rel="noopener">订阅他的媒体出版物</a>。</p><p id="0be8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">阅读 Dino Cajic(以及 Medium 上成千上万的其他作家)的每一个故事。你的会员费直接支持迪诺·卡吉克和你阅读的其他作家。你也可以在媒体上看到所有的故事。T25】</p></div></div>    
</body>
</html>