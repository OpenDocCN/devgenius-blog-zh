<html>
<head>
<title>Panorama FM, or How to See all FM Stations Using SDR</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">全景调频，或如何使用SDR查看所有调频电台</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/panorama-fm-or-how-to-see-all-fm-stations-using-sdr-b18b88210a09?source=collection_archive---------3-----------------------#2020-07-29">https://blog.devgenius.io/panorama-fm-or-how-to-see-all-fm-stations-using-sdr-b18b88210a09?source=collection_archive---------3-----------------------#2020-07-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="900f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">可能每个对无线电和通信有点兴趣的人都知道，使用SDR接收机可以同时接收和处理宽带无线电频谱。在HDSDR或SDR#这样的程序中显示瀑布并不奇怪。我将展示如何使用RTL-SDR、GNU Radio和大约100行Python代码构建FM频段的伪3D频谱。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/c56d2c14ccfe956724b1769a135f6905.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*OnYpIGMbOTQTr4s1.png"/></div></div></figure><p id="21a3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还将采用一个功率更大的接收机，研究整个FM波段88–108 MHz。</p><p id="ed0a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从技术上讲，这项任务相当简单。SDR接收器使用速度相当快的ADC对输入的无线电信号进行数字化处理。在输出端，我们得到一个宽带IQ信号，它是来自ADC的一组数字，带宽对应于ADC的采样速率。ADC频率决定可以使用的最大带宽。这与PC声卡中的过程相同，只是我们每秒不是22.050，而是2.000.000，甚至10.000.000个样本。为了在屏幕上显示无线电频谱，我们必须对数据阵列执行快速傅立叶变换，它将数据从所谓的时域转换到频域。然后我们把数据显示在屏幕上，问题就解决了。我也会尽量使用最少的代码，这样GNU Radio就可以帮助我们进行数据处理。</p><p id="2f9c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了测试，我们首先需要一个RTL-SDR接收机，价格大约是35美元。它允许我们在70年代接收无线电信号..使用高达2 MHz带宽的1700 MHz频率范围:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi kx"><img src="../Images/967652e8db94efddf8a87f691636a0d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/0*hzodWFlcXCP8vy0T.png"/></div></figure><p id="3266" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果有人想使用RTL-SDR进行测试，建议使用照片上的接收器。有更便宜的仿制品，但质量较差。</p><p id="543f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好吧，我们开始吧。</p><h1 id="426f" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">GNU无线电处理</h1><p id="34e0" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">首先，我们需要从接收器获取并处理数据。GNU无线电连接图如图所示:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mb"><img src="../Images/9bfd9adbb6e2181899d272642ef14ee0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*5oHT7LARUkXLI21O.png"/></div></div></figure><p id="5aa8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如我们所看到的，我们从接收器获取数据，将连续的数据流转换为一组1024个值大小的“向量”，对这些向量执行FFT，将值从复数转换为实数，最后通过UDP发送数据。当然，所有这些都可以使用<em class="mc"> SoapySDR </em>和<em class="mc"> numpy </em>库在纯Python中完成，但是代码量会更大一些。</p><p id="93fb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> QT GUI频率接收器</strong>模块仅在调试时需要，使用该模块，我们可以确保无线电台可见，并在必要时调整接收器增益。当应用程序运行时，图片应该如下所示:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi md"><img src="../Images/743f65da0969142a542a841dcef11992.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*dUOiedqr8-IOUiHD.png"/></div></div></figure><p id="fa4e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果一切正常，可以禁用频率接收块，同样在GNU Radio项目设置中，我们可以选择不指定GUI模式，这样就不会浪费UI资源。原则上，这个程序可以在没有任何UI的情况下作为服务运行。</p><h1 id="3e99" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">翻译</h1><p id="7a70" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">因为我们通过UDP传输数据，所以我们可以用任何客户端接收它，甚至在另一台PC上。我会用Python，对于原型来说已经相当够用了。</p><p id="1845" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，让我们获取UDP数据:</p><pre class="km kn ko kp gt me mf mg mh aw mi bi"><span id="5b0a" class="mj kz iq mf b gy mk ml l mm mn">fft_size = 1024<br/>udp_data = None<br/>UDP_IP = "127.0.0.1"<br/>UDP_PORT = 40868</span><span id="cfc8" class="mj kz iq mf b gy mo ml l mm mn">sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)  <em class="mc"># UDP</em><br/>sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)<br/>sock.bind((UDP_IP, UDP_PORT))<br/>sock.settimeout(0.5)</span><span id="f569" class="mj kz iq mf b gy mo ml l mm mn">try:<br/>    data, addr = sock.recvfrom(fft_size * 4)<br/>    if len(data) == 4096:<br/>        udp_data = np.frombuffer(data, dtype=np.float32)<br/>        return True<br/>except socket.timeout:<br/>    pass</span></pre><p id="6f09" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为我们处理图形，所以使用<strong class="jp ir"> pygame </strong>库很方便。绘制3D光谱很简单，我们将数据存储在一个数组中，从上到下，从旧到新绘制线条。</p><pre class="km kn ko kp gt me mf mg mh aw mi bi"><span id="662b" class="mj kz iq mf b gy mk ml l mm mn">fft_size = 1024<br/>depth = 255<br/>fft_data = np.zeros([depth, fft_size])</span><span id="1c2c" class="mj kz iq mf b gy mo ml l mm mn">def draw_image(screen, font):<br/>    x_left, x_right, y_bottom = 0, img_size[0],  img_size[1] - 5<br/>    <em class="mc"># Draw spectrum in pseudo-3d</em><br/>    for d in reversed(range(depth)):<br/>        for x in range(fft_size - 1):<br/>            d_x1, d_x2, d_y1, d_y2 = x + d, x + d + 1, y_bottom - int(y_ampl*fft_data[d][x]) - y_shift - d, y_bottom - int(y_ampl*fft_data[d][x+1]) - y_shift - d<br/>            if d_y1 &gt; y_bottom - 34: d_y1 = y_bottom - 34<br/>            if d_y2 &gt; y_bottom - 34: d_y2 = y_bottom - 34<br/>            dim = 1 - 0.8*(d/depth)<br/>            color = int(dim*data_2_color(fft_data[d][x]))<br/>            pygame.draw.line(screen, (color//2,color,0) if d &gt; 0 else (0, 250, 0), (d_x1, d_y1), (d_x2, d_y2), (2 if d == 0 else 1))</span></pre><p id="4105" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还可以在屏幕上显示频率和电台名称。傅立叶变换算法给出对应于接收器带宽的1024点的输出。我们知道中心频率，所以计算像素位置可以使用小学公式。</p><pre class="km kn ko kp gt me mf mg mh aw mi bi"><span id="07d1" class="mj kz iq mf b gy mk ml l mm mn">stations = [("101.8 FM", 101.8), ("Rock FM", 102.4), ...]<br/>for st_name, freq in stations:<br/>    x_pos = fft_size*(freq - center_freq)*1000000//sample_rate<br/>    textsurface = font.render(st_name, False, (255, 255, 0))<br/>    screen.blit(textsurface, (img_size[0]//2 + x_pos - textsurface.get_width()//2, y_bottom - 22))</span></pre><p id="8116" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">实际上就是这样，我们可以同时运行两个程序，在屏幕上，我们会看到一个全景，实时显示当前工作的调频电台:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mp"><img src="../Images/fdb20412c09321c25ec0686fb637e7d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qf0Bi31wO-z1Gp8M.gif"/></div></div></figure><p id="bfb6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">很容易看出，不同的电台有不同的信号水平，我们甚至可以区分单声道和立体声广播。</p><p id="01be" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好了，现在我将展示整个调频波段的全景。为此，我们必须将RTL-SDR放在一边，使用更好的无线电。例如，像这样:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mq"><img src="../Images/947ab916039ebb86e638514a5f36ce20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*8dE3xSNNoFWoLiz6.png"/></div></div></figure><p id="acd3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我用的是专业级的Ettus Research SDR，但是从代码角度来看，一切都是一样的，只是需要在GNU Radio中把一个块换成另一个块。因此，它在接收带宽为24 MHz的频谱上寻找:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mp"><img src="../Images/44ae6928b88b61df3ee7cf8e4d5b18d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ziG8S0kocmn0a1dJ.gif"/></div></div></figure><p id="7e6e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有趣的是，不同调频电台的信号强度各不相同。</p><p id="744b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当然，不仅可以接收FM电台，还可以接收SDR工作频率范围内的任何其他电台。例如，这是<a class="ae mr" href="https://en.wikipedia.org/wiki/Airband" rel="noopener ugc nofollow" target="_blank">气垫</a>的样子:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mp"><img src="../Images/c07864e0d008663860a1b1291a0dee09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*EdB_9icYVR4_YsGG.gif"/></div></div></figure><p id="1aa8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以看到一些永久运行的频率(可能是ATIS气象局)和地面与飞行员之间断断续续的无线电通信。这是GSM频段频谱的样子(GSM信号比24 MHz更宽，不完全符合):</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ms"><img src="../Images/173b555065317195d1cd0ac3d67dc5d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*pzuiOqEzPM6eJid9.png"/></div></div></figure><h1 id="3dac" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">结论</h1><p id="6b71" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">正如我们所见，无线电频谱的研究相当令人兴奋，尤其是在3D方面。当然，这里没有制造另一个频谱分析仪的目的，这只是一个好玩的原型。唉，渲染很慢，Python不是在屏幕上显示几千个图元的最佳选择。线条着色算法也可以改进。</p><p id="70c2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">像往常一样，祝所有读者实验成功。</p><p id="63a6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">完整的渲染源代码附后。</p><pre class="km kn ko kp gt me mf mg mh aw mi bi"><span id="bd2c" class="mj kz iq mf b gy mk ml l mm mn">import numpy as np <br/>from matplotlib import pyplot as plt <br/>from PIL import Image, ImageDraw <br/>import sys <br/>import pygame <br/>from pygame.locals import * <br/>from threading import Thread <br/>import io <br/>import cv2 <br/>import time <br/>import socket</span><span id="1736" class="mj kz iq mf b gy mo ml l mm mn"># FFT<br/>receiver_name = "RTL-SDR"<br/>center_freq = 102.5<br/>sample_rate = 1800000</span><span id="5fef" class="mj kz iq mf b gy mo ml l mm mn">stations = [("101.8", 101.8), ("102.1", 102.1), ("102.4", 102.4), ("102.7", 102.7), ("103.0", 103.0), ("103.2", 103.2)]</span><span id="1ab4" class="mj kz iq mf b gy mo ml l mm mn"># Load data from UDP<br/>UDP_IP = "127.0.0.1"<br/>UDP_PORT = 40868<br/>udp_data = None<br/>sock = None</span><span id="c1a6" class="mj kz iq mf b gy mo ml l mm mn"># Panorama history<br/>fft_size = 1024<br/>depth = 255<br/>fft_data = np.zeros([depth, fft_size])</span><span id="4ef4" class="mj kz iq mf b gy mo ml l mm mn"># Canvas and draw<br/>img_size = (fft_size, fft_size*9//16)<br/>y_ampl = 90<br/>color_ampl = 70<br/>y_shift = 250</span><span id="943f" class="mj kz iq mf b gy mo ml l mm mn"><br/>def udp_prepare():<br/>    global sock<br/>    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)  # UDP<br/>    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)<br/>    sock.bind((UDP_IP, UDP_PORT))<br/>    sock.settimeout(0.5)</span><span id="25a6" class="mj kz iq mf b gy mo ml l mm mn">def udp_getdata():<br/>    global sock, udp_data<br/>    try:<br/>        data, addr = sock.recvfrom(fft_size * 4)<br/>        if len(data) == 4096:<br/>           udp_data = np.frombuffer(data, dtype=np.float32)<br/>           return True<br/>    except socket.timeout:<br/>        pass<br/>    return False</span><span id="3410" class="mj kz iq mf b gy mo ml l mm mn">def clear_data():<br/>    for y in range(depth):<br/>        fft_data[y, :] = np.full((fft_size,), -1024)</span><span id="efd8" class="mj kz iq mf b gy mo ml l mm mn">def add_new_line():<br/>    global udp_data, fft_data<br/>    # Shift old data up<br/>    for y in reversed(range(depth - 1)):<br/>        fft_data[y + 1, :] = fft_data[y, :]<br/>    # Put new data at the bottom line<br/>    if udp_data is not None:<br/>        fft_data[0, :] = udp_data</span><span id="3afb" class="mj kz iq mf b gy mo ml l mm mn">def data_2_color(data):<br/>    c = -data + 2  # TODO: detect noise floor of the spectrum<br/>    color = 150 - int(color_ampl * c)<br/>    if color &lt; 20:<br/>        color = 20<br/>    if color &gt; 150:<br/>       color = 150<br/>    return color</span><span id="df79" class="mj kz iq mf b gy mo ml l mm mn">def draw_image(screen, font):<br/>    x_left, x_right, y_bottom = 0, img_size[0], img_size[1] - 5<br/>    # Draw spectrum in pseudo-3d<br/>    for d in reversed(range(depth)):<br/>      for x in range(fft_size - 1):<br/>         d_x1, d_x2, d_y1, d_y2 = x + d, x + d + 1, y_bottom - int(y_ampl*fft_data[d][x]) - y_shift - d, y_bottom - int(y_ampl*fft_data[d][x+1]) - y_shift - d<br/>         if d_y1 &gt; y_bottom - 34: d_y1 = y_bottom - 34<br/>         if d_y2 &gt; y_bottom - 34: d_y2 = y_bottom - 34<br/>         dim = 1 - 0.8*(d/depth)<br/>         color = int(dim*data_2_color(fft_data[d][x]))<br/>         pygame.draw.line(screen, (color//2,color,0) if d &gt; 0 else (0, 250, 0), (d_x1, d_y1), (d_x2, d_y2), (2 if d == 0 else 1))</span><span id="1782" class="mj kz iq mf b gy mo ml l mm mn">    # Bottom line<br/>    pygame.draw.line(screen, (0,100,0), (x_left, y_bottom - 30), (x_right, y_bottom - 30), 2)</span><span id="d8c3" class="mj kz iq mf b gy mo ml l mm mn">    # Station names<br/>    for st_name, freq in stations:<br/>        x_pos = fft_size*(freq - center_freq)*1000000//sample_rate<br/>        textsurface = font.render(st_name, False, (255, 255, 0))<br/>        screen.blit(textsurface, (img_size[0]//2 + x_pos - textsurface.get_width()//2, y_bottom - 22))</span><span id="3c15" class="mj kz iq mf b gy mo ml l mm mn">    text_mhz = font.render("MHz", False, (255, 255, 0))<br/>    screen.blit(text_mhz, (img_size[0] - 5 - text_mhz.get_width(), y_bottom - 22))</span><span id="59a5" class="mj kz iq mf b gy mo ml l mm mn"><br/>if __name__ == "__main__":<br/>    # UI init<br/>    screen = pygame.display.set_mode(img_size)<br/>    pygame.display.set_caption(receiver_name)<br/>    pygame.font.init()<br/>    font = pygame.font.SysFont('Arial Bold', 30)</span><span id="47b7" class="mj kz iq mf b gy mo ml l mm mn">    # Subscribe to UDP<br/>    clear_data()<br/>    udp_prepare()</span><span id="83bd" class="mj kz iq mf b gy mo ml l mm mn">    # Main loop<br/>    is_active = True<br/>    while is_active:<br/>        # Get new data<br/>        if udp_getdata():<br/>            add_new_line()</span><span id="d2a8" class="mj kz iq mf b gy mo ml l mm mn">            # Update screen<br/>            screen.fill((0, 0, 0))<br/>            draw_image(screen, font)<br/>            pygame.display.flip()</span><span id="9fa5" class="mj kz iq mf b gy mo ml l mm mn">        # Check sys events<br/>        for events in pygame.event.get():<br/>            if events.type == QUIT:<br/>                is_active = False</span></pre></div></div>    
</body>
</html>