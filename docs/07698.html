<html>
<head>
<title>Spiral Traverse Algorithm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">螺旋遍历算法</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/spiral-traverse-algorithm-6cf19073783b?source=collection_archive---------5-----------------------#2022-04-16">https://blog.devgenius.io/spiral-traverse-algorithm-6cf19073783b?source=collection_archive---------5-----------------------#2022-04-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="848c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl"> Swift 算法&amp;计算机科学中的数据结构</em></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/f737296cb6496863a60df5359ff7681d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P9dG1cyxGm1Ygf2oINxNMQ.jpeg"/></div></div></figure><blockquote class="ky kz la"><p id="718d" class="jn jo kl jp b jq jr js jt ju jv jw jx lb jz ka kb lc kd ke kf ld kh ki kj kk ij bi translated">算法和数据结构常用于网站和移动应用。今天，我们将讨论计算机科学理论中使用的标准算法。螺旋遍历算法通过遍历二维数组来工作。我们将分解这个算法，并讨论其工作的关键组成部分。</p></blockquote><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="le lf l"/></div><figcaption class="lg lh gj gh gi li lj bd b be z dk translated">上面列出的是我们算法的开始。我们首先创建一个接受名为“集合”的参数的函数以及返回整数数组的二维整数数组。接下来，我们声明一个包含空数组的变量。</figcaption></figure><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi lk"><img src="../Images/cdfbf3b1fe581ac32c74e0aeb3d13eea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iBWsICCPUwf-BuBL3IcJag.jpeg"/></div></div><figcaption class="lg lh gj gh gi li lj bd b be z dk translated">上面列出的是我们的图表；我们有显示二维数组的每个区域的键。</figcaption></figure><blockquote class="ky kz la"><p id="9a78" class="jn jo kl jp b jq jr js jt ju jv jw jx lb jz ka kb lc kd ke kf ld kh ki kj kk ij bi translated">这将是我们的算法如何工作的图表；请做好笔记，注意它是如何遍历一组数字的。我们的算法将以 O(N)复杂度和 O(N)空间运行，因为我们将遍历一个二维数组并将每个整数添加到一个空数组中。列出的是我们的二维数组中的起始行和结束列。</p></blockquote><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="le lf l"/></div><figcaption class="lg lh gj gh gi li lj bd b be z dk translated">我们首先开始初始化我们的行和列变量，允许我们遍历二维数组的不同部分。</figcaption></figure><blockquote class="ky kz la"><p id="94a4" class="jn jo kl jp b jq jr js jt ju jv jw jx lb jz ka kb lc kd ke kf ld kh ki kj kk ij bi translated">正如我们所看到的，当我们准备遍历二维数组的外侧时，我们为二维数组的每个点创建单独的变量。</p></blockquote><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi lk"><img src="../Images/aba4608b802426eb20d5ac3c156d4eca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r-SuNGBQxPgRzV9ROFHcVg.jpeg"/></div></div><figcaption class="lg lh gj gh gi li lj bd b be z dk translated">我们首先开始遍历二维数组的右侧。</figcaption></figure><blockquote class="ky kz la"><p id="0a1d" class="jn jo kl jp b jq jr js jt ju jv jw jx lb jz ka kb lc kd ke kf ld kh ki kj kk ij bi translated">我们首先在代码中声明一个 while 循环，它将允许我们遍历二维数组的顶部。整数 13、15、17 和 19 将被添加到我们的空集合中。stride 方法将允许我们遍历每个顶部整数一次。接下来，我们利用 append 方法将每个整数添加到数组中，如下所示。</p></blockquote><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="le lf l"/></div><figcaption class="lg lh gj gh gi li lj bd b be z dk translated">注意，我们使用&lt; =操作符来决定是否可以迭代和执行上面列出的 rest 代码。我们从 startFlag_Col 开始，一直到 Finish_Col，一个一个地将每个整数添加到我们的空数组中。</figcaption></figure><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi lk"><img src="../Images/e74119bbe2741a7861be57c5eaf2d8dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9dqBJ12YlDDeG05XDC5HIQ.jpeg"/></div></div><figcaption class="lg lh gj gh gi li lj bd b be z dk translated">接下来，我们继续处理二维数组的下一个外侧。仔细看。由于我们不会在 startingFlag_Row 中使用+ 1 再次计数到 19，因此我们将跳过 19，继续到 23、24 和 25。</figcaption></figure><blockquote class="ky kz la"><p id="18ee" class="jn jo kl jp b jq jr js jt ju jv jw jx lb jz ka kb lc kd ke kf ld kh ki kj kk ij bi translated">接下来，我们开始遍历二维数组的下一边。startFlag_Row 处的+1 将允许我们跳过 19，因为它已经被添加到我们的集合中。我们仍然使用 stride 方法来遍历二维数组的这一侧。</p></blockquote><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="le lf l"/></div><figcaption class="lg lh gj gh gi li lj bd b be z dk translated">我们现在声明一个 For-In 循环，它遍历二维数组的下一面。</figcaption></figure><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi lk"><img src="../Images/85deb3c0ba2ee60f443f8716ded9dd03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*33uxpIs3r9gM6pmBfVe0ww.jpeg"/></div></div><figcaption class="lg lh gj gh gi li lj bd b be z dk translated">接下来我们移动到二维数组的下一边。我们将遍历到二维数组外侧的左侧。</figcaption></figure><blockquote class="ky kz la"><p id="4567" class="jn jo kl jp b jq jr js jt ju jv jw jx lb jz ka kb lc kd ke kf ld kh ki kj kk ij bi translated">接下来，我们从 Finish_Col 开始遍历，并穿过 Finish_Row 的左侧。我们向左递增-1。如上所示，我们从-1 开始，避免重复到 25。整数 27、29 和 31 将被添加到我们的数组中。</p></blockquote><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="le lf l"/></div><figcaption class="lg lh gj gh gi li lj bd b be z dk translated">上面列出的是我们的代码。注意 if 语句，这将有助于避免数组中出现任何相同的数字。如果我们找到相同的数字，并且它已经被添加到我们的集合中，它将自动中断代码的执行。</figcaption></figure><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi lk"><img src="../Images/33bcafadbd08288b21599cfbf7fece4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IWQg0wYpzduPPu0Y3qC4Vw.jpeg"/></div></div><figcaption class="lg lh gj gh gi li lj bd b be z dk translated">我们接下来遍历二维数组的最后一个外侧。查看上面列出的示例，我们将从 Finish_Row 和 startFlag_Row 开始。参考上面的例子。</figcaption></figure><blockquote class="ky kz la"><p id="9229" class="jn jo kl jp b jq jr js jt ju jv jw jx lb jz ka kb lc kd ke kf ld kh ki kj kk ij bi translated">在这之后，最后一步是遍历二维数组的内部。我们将通过在 startFlag_Col 和 startFlag_Row、Finish_Row、Finish_Col 处使用+=和-=操作符来推进我们的内部集合。</p></blockquote><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="le lf l"/></div></figure><h1 id="e416" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">螺旋遍历算法</h1><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="le lf l"/></div><figcaption class="lg lh gj gh gi li lj bd b be z dk translated">螺旋遍历算法</figcaption></figure><h1 id="c3eb" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">结论</h1><p id="4d1c" class="pw-post-body-paragraph jn jo iq jp b jq mj js jt ju mk jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">今天，我们讲述了一个使用 Swift 编程语言的非常复杂而美丽的算法。理解算法需要很多时间，但在用编程语言编写算法之前，要完全掌握算法的运行方式。编程并不容易，需要牺牲时间和耐心；通过每天花时间学习新的算法或数据结构，你已经为未来的成功做好了充分的准备。编码快乐！</p><div class="mo mp gp gr mq mr"><a href="https://www.linkedin.com/in/michael-balsa-9474431b0/" rel="noopener  ugc nofollow" target="_blank"><div class="ms ab fo"><div class="mt ab mu cl cj mv"><h2 class="bd ir gy z fp mw fr fs mx fu fw ip bi translated">Michael Balsa -系统管理员-美国海军陆战队| LinkedIn</h2><div class="my l"><h3 class="bd b gy z fp mw fr fs mx fu fw dk translated">经验丰富的数据专家和系统管理员，监督维护飞机数据和信息管理…</h3></div><div class="mz l"><p class="bd b dl z fp mw fr fs mx fu fw dk translated">www.linkedin.com</p></div></div><div class="na l"><div class="nb l nc nd ne na nf kw mr"/></div></div></a></div></div></div>    
</body>
</html>