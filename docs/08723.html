<html>
<head>
<title>[Rust] Basics and Concepts, Step by Step — 2nd Iteration</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">[Rust]基础和概念，循序渐进—第二次迭代</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/rust-basics-and-concepts-step-by-step-2nd-iteration-5ba45c44f986?source=collection_archive---------9-----------------------#2022-07-05">https://blog.devgenius.io/rust-basics-and-concepts-step-by-step-2nd-iteration-5ba45c44f986?source=collection_archive---------9-----------------------#2022-07-05</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="dc2d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这篇博客中，我将试着专注于<code class="fe ki kj kk kl b">Rust</code>的一些基本但非常重要的概念。这将是我第二个关于 T1 的博客，你可以在这里找到第一个 T8。我将在这个博客中尝试讨论所有权、所有权转移、借用、堆、栈</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi kn"><img src="../Images/71aaac7382d9bd1b9a91124106da4867.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p6hxdYUESibvHG5oG7WA2Q.png"/></div></div></figure><h2 id="5fe3" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">那么，Rust 中的所有权是什么</h2><p id="736d" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated"><code class="fe ki kj kk kl b">Rust</code>没有垃圾收集器，需要显式分配和释放内存空间。当涉及到大型代码库时，这很快就会变得乏味和具有挑战性。</p><p id="e366" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">传统上，有两种管理记忆的基本方法。第一个是垃圾收集器；它主要用于从程序员那里抽象出内存管理概念的高级语言中。</p><p id="edcb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">第二种是<strong class="jm io">手动</strong>内存管理，程序员明确定义内存使用。虽然它提供了控制，但也留下了很多空间搬起石头砸自己的脚。</p><p id="b3ed" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Rust 采用了另一种方法，叫做<strong class="jm io">所有权</strong>和<strong class="jm io">借贷</strong>。所有权是一个新的<strong class="jm io">构造</strong>，它定义一个值有它的所有者。</p><p id="ad07" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们看看下面的代码和它的输出</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi lx"><img src="../Images/7bf4def1c95d72fcc70a077356d52cb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dhSBAyvmdQVWRQyS1Lc7Cg.png"/></div></div></figure><pre class="ko kp kq kr gt ly kl lz ma aw mb bi"><span id="25ae" class="kz la in kl b gy mc md l me mf">change the value of i=11<br/>print the value of i=10, after let_change_the_value_by_one call</span></pre><p id="9f38" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当我们将<strong class="jm io"> i </strong>传递给函数<code class="fe ki kj kk kl b">let_change_the_value_by_one</code>时，将值增加<strong class="jm io"> 1 </strong>，打印它，当控制返回到<code class="fe ki kj kk kl b"><strong class="jm io">main()</strong></code> <strong class="jm io"> </strong>函数并打印它时，我们得到与之前相同的值。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi mg"><img src="../Images/bb2e0ca2dfcc9f09a53f390fb16e7374.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IFvfxOHPPUsoFFmv7ZNCnQ.jpeg"/></div></div></figure><p id="15ca" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">与<strong class="jm io">字符串不同，</strong> <strong class="jm io">整数</strong>存储在<strong class="jm io">堆栈</strong>中，而不是<strong class="jm io">堆</strong>中，并且在将<strong class="jm io"> i </strong>传递给函数<code class="fe ki kj kk kl b">let_change_the_value_by_one</code>时，编译器会复制该值并将其传递给函数，实际值保持不变。根据<strong class="jm io">所有权</strong>变量<strong class="jm io"> i </strong>是<strong class="jm io">堆栈</strong>中值的所有者，直到它的作用域保持活动。</p><p id="d923" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，我们把变量从<code class="fe ki kj kk kl b">i8</code>改成<code class="fe ki kj kk kl b">string</code>怎么样</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi mh"><img src="../Images/3af48ef8aaa33cf15ff8d93445d542bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iJ6qVK8H9Kwarm5K9oTX_Q.png"/></div></div></figure><pre class="ko kp kq kr gt ly kl lz ma aw mb bi"><span id="9d38" class="kz la in kl b gy mc md l me mf">18 |     let value_for_i = String::from("Rust");<br/><strong class="kl io">   |----------- move occurs because `value_for_i` has type `String`, which does not implement the `Copy` trait</strong><br/>19 |     lets_change_the_value_of_string(value_for_i);<br/>  <strong class="kl io"> |----------- value moved here</strong><br/>20 |     println!("print the value of value_for_i={}, after lets_change_the_value_of_string call", value_for_i)<br/>   |                                                                                               ^^^^^^^^^^^ value borrowed here after move</span></pre><p id="8913" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在涉及到<strong class="jm io">堆</strong>的时候，<strong class="jm io">所有权</strong>的概念会更加透明。当变量<code class="fe ki kj kk kl b">value_for_i</code>传递给函数<code class="fe ki kj kk kl b">lets_change_the_value_of_string</code>时，编译器会在<strong class="jm io">堆栈</strong>中创建该变量引用的副本，并将<strong class="jm io">所有权</strong>移至其中。<strong class="jm io">堆中的值不会发生任何变化。</strong>一旦控制返回到<code class="fe ki kj kk kl b"><strong class="jm io">main()</strong></code> <strong class="jm io"> </strong>变量<strong class="jm io"> </strong> <code class="fe ki kj kk kl b">value_for_i</code>的引用不再存在，这就是编译器试图告诉我们<strong class="jm io">移动</strong>已经发生的原因</p><pre class="ko kp kq kr gt ly kl lz ma aw mb bi"><span id="5c6f" class="kz la in kl b gy mc md l me mf"><strong class="kl io">|----------- move occurs because `value_for_i` has type `String`, which does not implement the `Copy` trait</strong><br/>|     lets_change_the_value_of_string(value_for_i);<br/><strong class="kl io">|----------- value moved here</strong></span></pre><p id="5552" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是同样的例子</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi mi"><img src="../Images/85cbb64154959f73abb5970e9110b854.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8zgLFLFAELzmQAsQgJx4iQ.jpeg"/></div></div></figure><blockquote class="mj mk ml"><p id="9b7d" class="jk jl mm jm b jn jo jp jq jr js jt ju mn jw jx jy mo ka kb kc mp ke kf kg kh ig bi translated">简单地说，在<code class="fe ki kj kk kl b">Rust</code>范围内的任何变量都是值的所有者，在它的所有权之外它不能被改变。所有权需要由程序员自己手动管理。</p></blockquote><p id="67fe" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了让这段代码工作，我们可以将这个<code class="fe ki kj kk kl b">value_for_i.clone()</code>传递给函数，这将创建一个引用和值的克隆</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi mq"><img src="../Images/288f021f92e525611c8c96c94aee8cfe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yvC6N7giP_om-AlrCdke-w.jpeg"/></div></div></figure><p id="d852" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是，如果我们不想转移所有权，而是想修改相同的值，该怎么办呢？如何通过使用<strong class="jm io">借用</strong>的概念来实现这一点</p><h2 id="7bf6" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">什么是<strong class="ak">借用</strong>中的铁锈</h2><p id="6ea3" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">在<code class="fe ki kj kk kl b">Rust</code>中，我们可以<strong class="jm io">从<strong class="jm io">堆栈</strong>中借用</strong>变量的引用，然后使用<strong class="jm io">借用的</strong>引用对<strong class="jm io">堆</strong>中的值执行操作。这样我们就根本不用处理所有权转移的问题了。为了<strong class="jm io">借用<code class="fe ki kj kk kl b">value_for_i</code>的引用</strong>，我们使用<strong class="jm io">借用</strong>操作符<code class="fe ki kj kk kl b">&amp;</code>，类似这样的东西<code class="fe ki kj kk kl b">&amp;value_for_i</code>并将其传递给函数。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi mr"><img src="../Images/f28d7240f016cde5a0fd311dd26b6001.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r-UcSLxYtyTvmEGRRH_e6A.png"/></div></div></figure><pre class="ko kp kq kr gt ly kl lz ma aw mb bi"><span id="a001" class="kz la in kl b gy mc md l me mf">print the value of value_for_i=<strong class="kl io">Rust</strong>, before lets_change_the_value_of_string call<br/>The value of variable value_for_i=<strong class="kl io">Rust is awesome</strong><br/>print the value of value_for_i=<strong class="kl io">Rust is awesome</strong>, after lets_change_the_value_of_string call</span></pre><p id="91a6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">上面的例子我们正在做多件事情</p><ol class=""><li id="3a5c" class="ms mt in jm b jn jo jr js jv mu jz mv kd mw kh mx my mz na bi translated">将局部变量<code class="fe ki kj kk kl b">value_for_i</code>改为可变的</li><li id="3041" class="ms mt in jm b jn nb jr nc jv nd jz ne kd nf kh mx my mz na bi translated">将函数的参数更改为<code class="fe ki kj kk kl b">&amp;mut value_for_i</code>，因此引用可以被传递，并且使其可变</li><li id="1e3a" class="ms mt in jm b jn nb jr nc jv nd jz ne kd nf kh mx my mz na bi translated">使用<code class="fe ki kj kk kl b">push_str()</code>和<code class="fe ki kj kk kl b">value_for_i</code>扩展字符串值。</li><li id="3415" class="ms mt in jm b jn nb jr nc jv nd jz ne kd nf kh mx my mz na bi translated">现在，当控制返回到<code class="fe ki kj kk kl b">main()</code>并执行<code class="fe ki kj kk kl b">println!</code>时，我们得到修改后的字符串。</li></ol><p id="312b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这解释了在我们不想转移所有权的情况下，我们如何使用借贷来处理价值。尽管借款有一些限制。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi ng"><img src="../Images/9bf87edb5c7ad771c84e7dc70c45066d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zr1784-VR-i2GFfMxRSycw.jpeg"/></div></div></figure><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi nh"><img src="../Images/9e5d21810572c6d389c287e3a691dbe4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0NCZJ2bqrwuN-cx3KsZlwQ.png"/></div></div></figure><p id="24c5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在变量的作用域内，我们只能为变量创建一次可变引用。不可变引用没有限制。此外，如果编译器发现<strong class="jm io">悬空引用</strong>，它也会抱怨，这意味着编译器会在引用 之前确保<strong class="jm io"> <em class="mm">数据不会超出范围。</em></strong></p><p id="1256" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">希望这有助于理解<code class="fe ki kj kk kl b">Rust</code>的一些非常有用的关键概念。随着我了解的越来越多，我会继续写关于<code class="fe ki kj kk kl b">Rust</code>的文章。</p><h1 id="8f0e" class="ni la in bd lb nj nk nl le nm nn no lh np nq nr lk ns nt nu ln nv nw nx lq ny bi translated">编码快乐！！</h1></div></div>    
</body>
</html>