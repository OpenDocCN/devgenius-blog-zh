<html>
<head>
<title>Seamless FastAPI Configuration with ConfZ</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用ConfZ的无缝FastAPI配置</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/seamless-fastapi-configuration-with-confz-90949c14ea12?source=collection_archive---------0-----------------------#2021-12-09">https://blog.devgenius.io/seamless-fastapi-configuration-with-confz-90949c14ea12?source=collection_archive---------0-----------------------#2021-12-09</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/d456828ce42f67eff7c58b89ba06ac27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z9cH1VNuQD4SFCGtxCpZQg.png"/></div></div></figure><div class=""/><p id="d35b" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">FastAPI、SQLModel和ConfZ的现成模板，轻松构建高度可配置的强大API。</p><p id="e04f" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae kt" href="https://github.com/Zuehlke/ConfZ" rel="noopener ugc nofollow" target="_blank"> ConfZ </a>是Python新的<strong class="jx iz">配置管理库</strong>。它基于<a class="ae kt" href="https://pydantic-docs.helpmanual.io/" rel="noopener ugc nofollow" target="_blank"> pydantic </a>，这使得它可以完美地与FastAPI一起使用。结合新的<a class="ae kt" href="https://sqlmodel.tiangolo.com/" rel="noopener ugc nofollow" target="_blank"> SQLModel </a> ORM，它也使用pydantic，您得到了API 的完美三重奏。</p><p id="0a72" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在下文中，我们首先展示一个由FastAPI和SQLModel组成的示例项目。然后，我们添加ConfZ并展示我们可以多么轻松地:</p><ul class=""><li id="3eda" class="ku kv iy jx b jy jz kc kd kg kw kk kx ko ky ks kz la lb lc bi translated"><strong class="jx iz">配置</strong> API细节，无需硬编码</li><li id="5a28" class="ku kv iy jx b jy ld kc le kg lf kk lg ko lh ks kz la lb lc bi translated">管理所有<strong class="jx iz">环境</strong>(开发、测试、生产……)的数据库</li><li id="91ec" class="ku kv iy jx b jy ld kc le kg lf kk lg ko lh ks kz la lb lc bi translated">编写<strong class="jx iz">测试</strong>而无需注入任何代码</li></ul><p id="b700" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所有代码都可以在<a class="ae kt" href="https://github.com/silvanmelchior/FastAPI_ConfZ_Demo" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获得。</p><h1 id="256d" class="li lj iy bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">示例项目</h1><p id="0c8f" class="pw-post-body-paragraph jv jw iy jx b jy mg ka kb kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated">让我们从一个基于FastAPI和SQLModel的样例项目开始，它的灵感来自于SQLModel的文档。这是一个允许<strong class="jx iz">管理用户</strong>的API。目前，用户仅由一个<code class="fe ml mm mn mo b">id</code>和一个<code class="fe ml mm mn mo b">name</code>组成。按照文档中的建议，我们创建一个包含所有公共字段的<code class="fe ml mm mn mo b">UserBase</code>类，然后添加表、读取和创建场景的细节<em class="mp">(更新目前被忽略)</em>。</p><figure class="mq mr ms mt gt ip"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="88fd" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们还需要一些逻辑来创建引擎和管理会话:</p><figure class="mq mr ms mt gt ip"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="e254" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当然，我们需要我们的API:</p><figure class="mq mr ms mt gt ip"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="7a3d" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们有了创建我们的<strong class="jx iz">路线</strong>的所有材料:</p><figure class="mq mr ms mt gt ip"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="b92e" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">就是这样。由于FastAPI和SQLModel 的巧妙集成，我们只需要这几行代码就可以实现一个(基本的)用户管理API。为了简单起见，我们忽略了这个例子中的更新和删除<em class="mp">(但是它们也非常简单)</em>。</p><h1 id="dbbd" class="li lj iy bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">配置我们的API</h1><p id="6efe" class="pw-post-body-paragraph jv jw iy jx b jy mg ka kb kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated">在我们的API文件中，我们有<strong class="jx iz">硬编码的</strong>特定配置，如API标题或CORS起源。这当然不是好的做法。例如，将它们放在yaml <strong class="jx iz">配置文件</strong>中会更好:</p><figure class="mq mr ms mt gt ip"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="01d1" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">多亏了ConfZ，现在加载这个文件、验证它的内容，然后在我们的应用程序中使用它变得很简单。我们只需要定义<strong class="jx iz">配置方案</strong>(与我们定义API方案或DB方案的方式相同)并指定配置文件的位置:</p><figure class="mq mr ms mt gt ip"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="714c" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们现在可以直接使用这个配置，<strong class="jx iz">而不需要任何额外的步骤</strong>:</p><figure class="mq mr ms mt gt ip"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="2c00" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">ConfZ <strong class="jx iz">在我们第一次访问config </strong>时自动加载它，使用pydantic验证它给定的配置模式，然后为以后的每次访问提供一个缓存副本。</p><h1 id="93cb" class="li lj iy bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">配置我们的数据库</h1><p id="cef3" class="pw-post-body-paragraph jv jw iy jx b jy mg ka kb kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated">虽然我们的API配置仍然是相对静态的，但是DB配置依赖于<strong class="jx iz">环境</strong>:</p><ul class=""><li id="930f" class="ku kv iy jx b jy jz kc kd kg kw kk kx ko ky ks kz la lb lc bi translated">在开发过程中，为了方便起见，我们使用本地SQLite数据库</li><li id="9509" class="ku kv iy jx b jy ld kc le kg lf kk lg ko lh ks kz la lb lc bi translated">在生产中，我们使用外部PostgreSQL数据库</li><li id="7e32" class="ku kv iy jx b jy ld kc le kg lf kk lg ko lh ks kz la lb lc bi translated">对于测试，我们使用内存中的SQLite DB</li></ul><p id="394e" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了尽可能灵活，我们希望每个环境都有一个<strong class="jx iz">配置文件(测试除外，我们将在后面介绍)。为了区分不同的环境，我们想读取一个相应的<strong class="jx iz">环境变量</strong>。任何DB <strong class="jx iz">凭证</strong>也应该从环境中读取，因为我们不想将它们直接放在配置文件中。</strong></p><p id="8091" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">虽然这些需求一开始可能听起来很复杂，但实际上使用ConfZ非常简单。首先，我们定义我们的<strong class="jx iz">配置类和源</strong>:</p><figure class="mq mr ms mt gt ip"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="9721" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们的数据库配置<code class="fe ml mm mn mo b">DBConfig</code>包含echo-setting和两种类型的数据库。根据<code class="fe ml mm mn mo b">type</code>字段的不同，它可以是SQLite DB(内存中或指定位置)或PostgreSQL DB。<code class="fe ml mm mn mo b">CONFIG_SOURCES</code>定义了ConfZ应该检查config-folder并使用在环境变量<code class="fe ml mm mn mo b">DB_ENV</code>中指定的文件。我们可以用文件将这个变量设置为<em class="mp"> db_dev.yml </em>:</p><figure class="mq mr ms mt gt ip"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="50fb" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">或者用文件<em class="mp"> db_prod.yml </em>:</p><figure class="mq mr ms mt gt ip"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="0102" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在后一种情况下，我们还需要设置环境变量<code class="fe ml mm mn mo b">DB.USER</code>和<code class="fe ml mm mn mo b">DB.PASSWORD</code>。</p><p id="b7e4" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，我们可以使用这个配置来创建我们的数据库:</p><figure class="mq mr ms mt gt ip"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="791e" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">就这样，我们已经用这几行代码涵盖了上面的所有需求。</p><h1 id="b18b" class="li lj iy bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">测试</h1><p id="9a62" class="pw-post-body-paragraph jv jw iy jx b jy mg ka kb kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated">FastAPI有一个丰富的<strong class="jx iz">依赖注入系统</strong>来简化测试。然而，在本教程中，我们不需要它，因为我们的数据库类已经支持内存数据库，我们只需要<strong class="jx iz">修改配置</strong>并将<code class="fe ml mm mn mo b">db.path</code>设置为<code class="fe ml mm mn mo b">None</code>。ConfZ中的每个config类都支持这种开箱即用，并有一个专用的<strong class="jx iz">上下文管理器</strong>:</p><figure class="mq mr ms mt gt ip"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="b61b" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们在这里定义的是一个具有<code class="fe ml mm mn mo b">autouse=True</code>的数据库夹具，所以我们不会意外地访问开发<em class="mp">(或者更糟:生产)</em>数据库。我们直接在代码中定义测试配置，并用新的配置覆盖现有的配置源。</p><p id="31ea" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里缺少了一部分:我们已经在模块级定义了<code class="fe ml mm mn mo b">engine</code>，所以改变配置不会有直接帮助，因为<strong class="jx iz">引擎已经在那个时间点创建了</strong>。为了防止这种情况，我们用一个getter函数代替了直接创建:</p><figure class="mq mr ms mt gt ip"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="c94c" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">来自ConfZ的<code class="fe ml mm mn mo b">depends_on</code>装饰器确保我们在第一次调用<em class="mp">后得到一个<strong class="jx iz">缓存副本</strong>(单例机制，就像以前一样在模块级)</em>。它还确保当我们用上下文管理器更改<code class="fe ml mm mn mo b">DBConfig</code>时，我们<strong class="jx iz">重新创建引擎</strong>。</p><p id="f183" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们现在可以用<code class="fe ml mm mn mo b">get_engine()</code>替换对<code class="fe ml mm mn mo b">engine</code>的所有访问，ConfZ将确保所有FastAPI路由都使用新的引擎。</p><p id="6cfb" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们现在已经准备好编写我们的单元测试了，再也不用担心任何依赖性了:</p><figure class="mq mr ms mt gt ip"><div class="bz fp l di"><div class="mu mv l"/></div></figure><h1 id="6ff0" class="li lj iy bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">早期验证</h1><p id="64c1" class="pw-post-body-paragraph jv jw iy jx b jy mg ka kb kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated">仍然缺少一个小细节:在启动时，加载我们的API配置并创建API。然而，只有在我们第一次访问时，即第一次调用用户路线时，才会加载数据库配置并创建引擎<strong class="jx iz">。</strong></p><p id="163e" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果在那个时间点上我们的配置没有被正确地指定(例如没有设置<code class="fe ml mm mn mo b">DB_ENV</code>变量)，ConfZ将抛出一个错误。这可能很晚了，最好在启动时检查所有的<strong class="jx iz">。幸运的是，ConfZ也提供了一个答案。我们只需要调整我们的<code class="fe ml mm mn mo b">on_startup</code>方法:</strong></p><figure class="mq mr ms mt gt ip"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="aef6" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">ConfZ的<code class="fe ml mm mn mo b">validate_all_configs</code>将检查所有的配置类，加载它们的源代码，并且<strong class="jx iz">已经验证了内容</strong>。因此，数据库配置中的错误将在该时间点被发现。标志<code class="fe ml mm mn mo b">include_listeners</code>确保<code class="fe ml mm mn mo b">get_engine</code>也已经被执行，所以配置不仅有正确的模式，而且我们实际上也可以连接到我们的数据库。</p><h1 id="c4bb" class="li lj iy bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">结论</h1><p id="3edf" class="pw-post-body-paragraph jv jw iy jx b jy mg ka kb kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated">正如我们所见，ConfZ <strong class="jx iz">自然地将</strong>与FastAPI和SQLModel集成在一起。它们共同组成了一个三人组，可以用来轻松构建高度可配置且功能强大的API。</p><p id="43fd" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae kt" href="https://github.com/Zuehlke/ConfZ" rel="noopener ugc nofollow" target="_blank"> ConfZ在GitHub上</a>。如果你喜欢它，尝试一下，看看它是否也适合你！</p></div><div class="ab cl mw mx hr my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ig ih ii ij ik"><p id="a9e8" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="mp">更多内容尽在</em><a class="ae kt" href="http://blog.devgenius.io" rel="noopener ugc nofollow" target="_blank"><em class="mp">blog . dev genius . io</em></a><em class="mp">。</em></p></div></div>    
</body>
</html>