<html>
<head>
<title>Change rest_framework’s request parameter validation failure response</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">更改 rest_framework 的请求参数验证失败响应</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/change-rest-frameworks-request-parameter-validation-failure-response-e1c7030945ca?source=collection_archive---------5-----------------------#2022-04-10">https://blog.devgenius.io/change-rest-frameworks-request-parameter-validation-failure-response-e1c7030945ca?source=collection_archive---------5-----------------------#2022-04-10</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><h1 id="231a" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">Django 和 rest_framework</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2ce9e5f2287cf4e9f4a07ec81af84c6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*nwlv3a-UYGlLPFZd"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@faisaldada?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Faisal </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="1738" class="pw-post-body-paragraph kz la in lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">Django 是 web 应用程序开发的流行框架之一。</p><p id="1428" class="pw-post-body-paragraph kz la in lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">rest_framework 包允许开发人员更容易、更快速地构建 REST API 服务。因为它为我们提供了各种内置特性，比如序列化器、过滤器、验证等等。</p><h1 id="dee5" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">django-过滤包</h1><p id="729d" class="pw-post-body-paragraph kz la in lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw ig bi translated">Django rest-framework 的一个流行包是 django-filter。我们可以用 django-filter 包轻松开发搜索特性。</p><p id="adc7" class="pw-post-body-paragraph kz la in lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">假设我们需要从数据库中的<code class="fe mc md me mf b">note</code>表中进行搜索。可搜索的字段有<code class="fe mc md me mf b">title</code>、<code class="fe mc md me mf b">rank</code>和<code class="fe mc md me mf b">content</code>。模型定义如下所示:</p><pre class="kj kk kl km gt mg mf mh mi aw mj bi"><span id="23b8" class="mk jl in mf b gy ml mm l mn mo">class Note(models.Model):<br/>    title = models.CharField(max_length=20, blank=False, null=False)<br/>    rank = models.IntegerField(blank=False, null=False, default=10)<br/>    content = models.CharField(max_length=100, blank=False, null=False)<br/>    created_datetime = models.DateTimeField(auto_now_add=True)<br/>    modified_datetime = models.DateTimeField(auto_now=True)</span></pre><p id="1257" class="pw-post-body-paragraph kz la in lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">在没有任何软件包帮助的情况下，我们需要实现以下部分来达到目的。</p><ol class=""><li id="52b7" class="mp mq in lb b lc ld lg lh lk mr lo ms ls mt lw mu mv mw mx bi translated">从请求中检索<code class="fe mc md me mf b">title</code>、<code class="fe mc md me mf b">rank</code>和<code class="fe mc md me mf b">created_datetime</code>参数值。类似<code class="fe mc md me mf b">request.query_params.get("title")</code>的东西</li><li id="8805" class="mp mq in lb b lc my lg mz lk na lo nb ls nc lw mu mv mw mx bi translated">验证 get 请求参数。</li><li id="daf9" class="mp mq in lb b lc my lg mz lk na lo nb ls nc lw mu mv mw mx bi translated">使用过滤器参数从数据库中提取记录。这可以通过使用模型对象查询或直接 SQL 查询构建来实现。</li></ol><pre class="kj kk kl km gt mg mf mh mi aw mj bi"><span id="0ff0" class="mk jl in mf b gy ml mm l mn mo"># search by title could be like<br/>notes: [Notes] = Note.objects.filter(title__in=title)</span></pre><h2 id="9874" class="mk jl in bd jm nd ne dn jq nf ng dp ju lk nh ni jy lo nj nk kc ls nl nm kg nn bi translated">使用 django 过滤器</h2><p id="074c" class="pw-post-body-paragraph kz la in lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw ig bi translated">另一方面，如果我们使用 django-filter 包，这将变得非常容易实现。首先，我们需要像这样定义过滤器类:</p><pre class="kj kk kl km gt mg mf mh mi aw mj bi"><span id="57b0" class="mk jl in mf b gy ml mm l mn mo">class NoteFilters(rest_framework.FilterSet):<br/>    title = rest_framework.CharFilter(<br/>        field_name="title",<br/>        lookup_expr="contains"<br/>    )<br/><br/>    rank = rest_framework.NumberFilter(<br/>        field_name="rank",<br/>        lookup_expr="gte"<br/>    )<br/><br/>    date_from = rest_framework.IsoDateTimeFilter(<br/>        field_name="created_datetime",<br/>        input_formats=DATE_INPUT_FORMATS,<br/>        lookup_expr="gte",<br/>    )<br/><br/>    class Meta:<br/>        model = Note<br/>        fields = ["title", "modified_datetime"]</span></pre><p id="c60f" class="pw-post-body-paragraph kz la in lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">这些表达式在 filter 类中相当简单。例如，返回标题包含参数<code class="fe mc md me mf b">title</code>值的注释的第一个表达式。</p><p id="ba12" class="pw-post-body-paragraph kz la in lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">然后，您需要做的就是创建如下所示的视图:</p><pre class="kj kk kl km gt mg mf mh mi aw mj bi"><span id="85bb" class="mk jl in mf b gy ml mm l mn mo">class NoteList(ListCreateAPIView):<br/>    serializer_class = NoteSerializer<br/>    queryset = Note.objects.all()<br/>    filter_backends = (rest_framework.DjangoFilterBackend,)<br/>    filterset_class = NoteFilters</span></pre><p id="fcfd" class="pw-post-body-paragraph kz la in lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">这里我们可以将我们已经创建的<code class="fe mc md me mf b">NoteFilters</code>定义为<code class="fe mc md me mf b">filterset_class</code>。<br/>现在可以进行测试了。</p><p id="7a03" class="pw-post-body-paragraph kz la in lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">样本请求:<br/>搜索任何在<code class="fe mc md me mf b">title</code>中带有<code class="fe mc md me mf b">3</code>且在<code class="fe mc md me mf b">2022/03/13</code>之后创建的笔记。</p><pre class="kj kk kl km gt mg mf mh mi aw mj bi"><span id="bd8e" class="mk jl in mf b gy ml mm l mn mo">GET http://localhost:8000/api/note/?date_from=2022/03/13 19:51:00&amp;title=3</span></pre><p id="34cd" class="pw-post-body-paragraph kz la in lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">如果数据库中存在这样的注释，这将返回 JSON 结果。</p><p id="7ba6" class="pw-post-body-paragraph kz la in lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">完整的源代码在我的 GitHub 库<a class="ae ky" href="https://github.com/huchka/djangorestframeworkexception" rel="noopener ugc nofollow" target="_blank">这里</a>。<br/><a class="ae ky" href="https://github.com/huchka/djangorestframeworkexception" rel="noopener ugc nofollow" target="_blank">https://github.com/huchka/djangorestframeworkexception</a></p><h1 id="7dc7" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">更改 django 的响应-过滤器验证错误</h1><p id="4ec6" class="pw-post-body-paragraph kz la in lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw ig bi translated">django-filter 还验证请求参数。在示例中，我们将<code class="fe mc md me mf b">rank</code>定义为一个整数变量。让我们看看当我们将<code class="fe mc md me mf b">rank</code>参数作为字符串发送时会发生什么。</p><pre class="kj kk kl km gt mg mf mh mi aw mj bi"><span id="7f30" class="mk jl in mf b gy ml mm l mn mo">GET http://localhost:8000/api/note/?rank=asdf</span></pre><p id="4cbb" class="pw-post-body-paragraph kz la in lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">它返回核心代码中预定义的错误消息:</p><pre class="kj kk kl km gt mg mf mh mi aw mj bi"><span id="be54" class="mk jl in mf b gy ml mm l mn mo">{<br/>    "rank": [<br/>        "Enter a number."<br/>    ]<br/>}</span></pre><p id="b6da" class="pw-post-body-paragraph kz la in lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">然而，一些项目/作品需要它们自己特定的错误结构。例如，我们希望参数验证错误如下:</p><pre class="kj kk kl km gt mg mf mh mi aw mj bi"><span id="0178" class="mk jl in mf b gy ml mm l mn mo">[<br/>    {<br/>        "error_field_name": "rank",<br/>        "error_validation_message": [<br/>            "Enter a number."<br/>        ]<br/>    }<br/>]</span></pre><h1 id="fe72" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">解决办法</h1><p id="8759" class="pw-post-body-paragraph kz la in lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw ig bi translated">错误结果来自属于 django rest 框架的 ValidationError 异常类。要更改 ValidationError 类的响应，我们需要覆盖这个类。为此，我创建了扩展<code class="fe mc md me mf b">ValidationError</code>的<code class="fe mc md me mf b">CustomValidationError</code>类。</p><pre class="kj kk kl km gt mg mf mh mi aw mj bi"><span id="45b1" class="mk jl in mf b gy ml mm l mn mo">class CustomValidationError(ValidationError):<br/>    def __init__(self, detail=None, code=None):<br/>        logger.error(f"{detail=}")<br/>        self.detail = [{"error_field_name": k, "error_validation_message": v} for k, v in detail.items()]</span></pre><p id="a1c7" class="pw-post-body-paragraph kz la in lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">对于错误异常，返回这个<code class="fe mc md me mf b">self.detail</code>字段。我们可以把它变成我们需要的任何东西。</p><p id="554e" class="pw-post-body-paragraph kz la in lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">之后，当<code class="fe mc md me mf b">ValidationError</code>异常发生时，我们需要引发我们的<code class="fe mc md me mf b">CustomVvalidationError</code>异常类。</p><pre class="kj kk kl km gt mg mf mh mi aw mj bi"><span id="3f48" class="mk jl in mf b gy ml mm l mn mo">class CustomListCreateAPIView(ListCreateAPIView):<br/>    def get(self, request, *args, **kwargs):<br/>        try:<br/>            return super().get(request)<br/>        except ValidationError as e:<br/>            raise CustomValidationError(e.detail, e.status_code)</span></pre><h1 id="ccd7" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">摘要</h1><p id="1cb1" class="pw-post-body-paragraph kz la in lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw ig bi translated">我在这里展示了一种可能的方法来为搜索特性更改 REST API 的参数验证。通常，一个项目需要以相同的格式改变所有的 API 错误响应。所以，我们需要改变所有的 API 视图类。但是，这是一种非常低效的方式。相反，我建议创建一个像上面这样的自定义视图类，然后我们可以使用该类作为视图的父类。</p></div></div>    
</body>
</html>