<html>
<head>
<title>Part #1: Memory management in WASM</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">第 1 部分:WASM 的内存管理</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/part-1-memory-management-in-wasm-52195f9b707f?source=collection_archive---------8-----------------------#2022-02-14">https://blog.devgenius.io/part-1-memory-management-in-wasm-52195f9b707f?source=collection_archive---------8-----------------------#2022-02-14</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="7057" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是我关于 WebAssembly 系列的第四篇文章，也可以独立阅读。这篇文章旨在成为 WASM 内存管理的理论入门。但是，如果您想查看本系列以前的文章，我已经将它们放在了下面的参考资料部分。</p><h2 id="23db" class="kj kk in bd kl km kn dn ko kp kq dp kr jv ks kt ku jz kv kw kx kd ky kz la lb bi translated">探索记忆管理背后的动机</h2><p id="e54d" class="pw-post-body-paragraph jk jl in jm b jn lc jp jq jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh ig bi translated">当您现有的参考框架包括具有<a class="ae lh" href="https://www.memorymanagement.org/mmref/lang.html" rel="noopener ugc nofollow" target="_blank">内存管理特性</a>的编程语言时，WebAssembly 中的内存是一个具有挑战性的话题。通过直接访问原始字节和手动内存管理，对于那些一直使用上述语言的人来说，使用起来感觉很陌生。</p><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="gh gi li"><img src="../Images/79b55e976817c79de9c7729e94a1ff6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CrlOcNbJC9hYTBcswwYqoA.jpeg"/></div></div></figure><h2 id="1ecc" class="kj kk in bd kl km kn dn ko kp kq dp kr jv ks kt ku jz kv kw kx kd ky kz la lb bi translated">在开始之前，我需要知道些什么？</h2><p id="2116" class="pw-post-body-paragraph jk jl in jm b jn lc jp jq jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh ig bi translated">没什么。即使你对 WebAssembly(和内存管理)完全陌生，这篇文章也将以对比的方式解释基础知识，这样一个对生态系统完全陌生的人可以理解硬币的两面。</p><h2 id="3c59" class="kj kk in bd kl km kn dn ko kp kq dp kr jv ks kt ku jz kv kw kx kd ky kz la lb bi translated">什么是内存管理？</h2><p id="bef6" class="pw-post-body-paragraph jk jl in jm b jn lc jp jq jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh ig bi translated">简而言之，它是控制和协调应用程序(即以任何编程语言编写的代码)访问 CPU 内存的过程。现在你可能会问，为什么我的应用程序需要内存？当您的代码在任何操作系统上运行时，它需要访问<strong class="jm io"> RAM </strong>，原因如下:</p><ul class=""><li id="cd75" class="lu lv in jm b jn jo jr js jv lw jz lx kd ly kh lz ma mb mc bi translated">加载它自己的<a class="ae lh" href="https://en.wikipedia.org/wiki/Bytecode" rel="noopener ugc nofollow" target="_blank">字节码</a>，然后将被执行</li><li id="07aa" class="lu lv in jm b jn md jr me jv mf jz mg kd mh kh lz ma mb mc bi translated">存储将在执行过程中使用的结构和数据</li><li id="faa3" class="lu lv in jm b jn md jr me jv mf jz mg kd mh kh lz ma mb mc bi translated">加载程序执行所需的任何运行时系统</li></ul><p id="e1fd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">除了加载字节码所需的空间之外，软件程序还利用了两个称为堆的特殊区域&amp;堆栈内存。你可以参考<a class="ae lh" href="https://deepu.tech/memory-management-in-programming/" rel="noopener ugc nofollow" target="_blank">这个链接</a>来深入了解栈 v/s 堆。</p><blockquote class="mi"><p id="7b78" class="mj mk in bd ml mm mn mo mp mq mr kh dk translated"><strong class="ak">TL；DR 如果你没看上面的链接</strong> : Stack v/s 堆内存分类是在内存分配的基础上完成的。在访问这些区域的方式、访问速度、每个区域中可以存储的内容、它们可以增长到的大小以及如果这些区域管理不当会遇到的错误方面也有所不同。</p></blockquote><p id="347e" class="pw-post-body-paragraph jk jl in jm b jn ms jp jq jr mt jt ju jv mu jx jy jz mv kb kc kd mw kf kg kh ig bi translated">根据 v1 <a class="ae lh" href="https://webassembly.org/docs/security/" rel="noopener ugc nofollow" target="_blank">规范</a>，WASM 模块在沙盒环境中执行，该环境将它们与主机/操作系统运行时相分离。这实际上意味着，除非明确允许，否则他们不能从主机或其他 WebAssembly 来宾访问数据。鉴于上述情况，WebAssembly 内存到底是什么样子的呢？</p><h2 id="a4e1" class="kj kk in bd kl km kn dn ko kp kq dp kr jv ks kt ku jz kv kw kx kd ky kz la lb bi translated">内存和 web 程序集</h2><p id="e73a" class="pw-post-body-paragraph jk jl in jm b jn lc jp jq jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh ig bi translated">WebAssembly 模块<a class="ae lh" href="https://github.com/WebAssembly/design/issues/306" rel="noopener ugc nofollow" target="_blank">被设计</a>为不控制整个进程地址空间，不像 C/C++这样的语言。它们确实通过导入/导出与其他实例共享内存，但每个模块只能分配到一小部分连续的<a class="ae lh" href="https://github.com/sunfishcode/wasm-reference-manual/blob/master/WebAssembly.md#linear-memories" rel="noopener ugc nofollow" target="_blank">虚拟内存，并带有一个偏移量</a>，也称为其<a class="ae lh" href="https://en.wikipedia.org/wiki/Flat_memory_model#:~:text=Flat%20memory%20model%20or%20linear,memory%20segmentation%20or%20paging%20schemes." rel="noopener ugc nofollow" target="_blank">线性内存</a>。简单地说，这就是线性内存分配的样子，</p><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/bd76a8dd68161bc5fe30bfa80b86cdc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*PUaw4C_pqtIK4_LUVM6Bgg.png"/></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">线性内存:虚拟内存的一个小的连续部分</figcaption></figure><p id="f941" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">该内存以初始大小创建，并以<a class="ae lh" href="https://webassembly.github.io/spec/core/exec/runtime.html#page-size" rel="noopener ugc nofollow" target="_blank">页</a>进行测量。根据 WebAssembly v1 规范，这可以使用<a class="ae lh" href="https://dl.acm.org/doi/epdf/10.1145/3062341.3062363" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> grow_memory </strong> </a>指令动态增长到最大 65536 页，总共 2^32 字节(4 <a class="ae lh" href="https://en.wikipedia.org/wiki/Gibibyte" rel="noopener ugc nofollow" target="_blank"> gibibytes </a>)。</p><h2 id="4f19" class="kj kk in bd kl km kn dn ko kp kq dp kr jv ks kt ku jz kv kw kx kd ky kz la lb bi translated">这些有什么关系呢？</h2><p id="a5a6" class="pw-post-body-paragraph jk jl in jm b jn lc jp jq jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh ig bi translated">该规范通过考虑以下因素来确保内存安全，</p><ul class=""><li id="d83a" class="lu lv in jm b jn jo jr js jv lw jz lx kd ly kh lz ma mb mc bi translated">潜在的恶意模块无法访问线性内存之外的数据</li><li id="191f" class="lu lv in jm b jn md jr me jv mf jz mg kd mh kh lz ma mb mc bi translated">由于内存大小总是已知的，运行时总是能够检查模块是否在指定的边界内访问内存</li><li id="d647" class="lu lv in jm b jn md jr me jv mf jz mg kd mh kh lz ma mb mc bi translated">除非给出显式访问，否则模块不能访问任何其他存储器。</li></ul><p id="c9e3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是 WASM 模块可以用不同的编程语言编写和编译，它们有自己的内存管理模型。这个规范如何在这些语言中保持一致？简单。通过理解当试图从主机运行时写入/读取时如何实现分配和解除分配，以及通过考虑和如何简化不同复杂数据类型之间的交换。</p><p id="8a37" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">鉴于上述情况，在 WASM 有两种管理内存的方法，</p><ul class=""><li id="15a4" class="lu lv in jm b jn jo jr js jv lw jz lx kd ly kh lz ma mb mc bi translated">您的模块拥有数据并负责管理其生命周期</li><li id="0564" class="lu lv in jm b jn md jr me jv mf jz mg kd mh kh lz ma mb mc bi translated">将数据从主机复制到模块</li></ul><p id="1004" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">虽然您可以通过编写自己的代码来手动完成这些工作，但对于第二个选项，您可以让像<a class="ae lh" href="https://github.com/rustwasm/wasm-bindgen" rel="noopener ugc nofollow" target="_blank"> wasm-bindgen </a>或<a class="ae lh" href="https://github.com/AssemblyScript/assemblyscript/tree/caa58015062dbccba7de9133c3d09138eec93e85/lib/loader" rel="noopener ugc nofollow" target="_blank"> AssemblyScript loader </a>这样的工具来代替。</p><p id="3810" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">wasm-bindgen 所做的是将 WebAssembly 模块包装在一个 JavaScript 包装器中，这样 JavaScript 和 wasm 就可以以双方都能理解的方式从同一个线性内存中读取数据或向其中写入数据。有点像这样。</p><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="gh gi nc"><img src="../Images/026a58186fbb5697f0f4dbb6470c7148.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T7kEj2gLvWDzupkj-8oviw.png"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">鸣谢:<a class="ae lh" href="https://hacks.mozilla.org/2018/06/babys-first-rustwebassembly-module-say-hi-to-jsconf-eu/" rel="noopener ugc nofollow" target="_blank">https://hacks . Mozilla . org/2018/06/babys-first-rustwebassembly-module-say-hi-to-jsconf-eu/</a></figcaption></figure><p id="9ddd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">类似地，加载 Wasm 模块并通过 WebAssembly API 公开它们，AssemblyScript 加载器还提供了分配和读取字符串、数组和类的实用程序。通过提供粘合代码，它完成了大部分繁重的工作，并允许您使用线性内存。</p><p id="b009" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">上述实用程序的作用范围是各自的语言。因此，这一领域无疑有着更大的发展空间。在写这篇文章的时候，有一些提议正在进行中，即<a class="ae lh" href="https://github.com/WebAssembly/interface-types/blob/main/proposals/interface-types/Explainer.md#integers" rel="noopener ugc nofollow" target="_blank">接口类型</a>、<a class="ae lh" href="https://github.com/WebAssembly/multi-value" rel="noopener ugc nofollow" target="_blank">多值 Wasm </a>、<a class="ae lh" href="https://github.com/WebAssembly/gc/blob/master/proposals/gc/Overview.md" rel="noopener ugc nofollow" target="_blank">垃圾收集</a>，它们可能会简化 WebAssembly 中复杂数据类型的内存管理和交换。</p><p id="835a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以，这个帖子到此为止！在下一篇文章中，我们将研究一个简单的程序，以及如何利用 WASM 的内存管理功能来开发一个用 TypeScript 编写的简单 Web 应用程序。</p><p id="c9cd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">资源:</strong></p><p id="175f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/a-primer-on-webassembly-834150fdd7ae">网络组装入门</a>，</p><p id="6591" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/part-1-how-to-read-wasm-b29de01d39e7">如何阅读《WASM》第一部</a></p><p id="136e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/part-2-how-to-read-wasm-1f7e34e70f59">如何阅读 WASM 第二部</a></p><p id="03a2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">林·克拉克的博客被 Mozilla 黑客攻击</p><p id="7b91" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个 GitHub 回购真棒<a class="ae lh" href="https://github.com/mbasso/awesome-wasm" rel="noopener ugc nofollow" target="_blank"> WASM 资源</a>。</p><p id="ee1f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ki">要了解我最新的科技恶作剧，请关注我的</em> <a class="ae lh" href="https://twitter.com/Divya_Mohan02" rel="noopener ugc nofollow" target="_blank"> <em class="ki">推特</em> </a> <em class="ki">和</em><a class="ae lh" href="https://www.linkedin.com/in/divya-mohan0209/" rel="noopener ugc nofollow" target="_blank"><em class="ki">LinkedIn</em></a><em class="ki">。</em></p></div></div>    
</body>
</html>