<html>
<head>
<title>A week of Leetcode (day 4/7)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一周的Leetcode(第4/7天)</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/ace-that-coding-interview-day-4-15-binary-search-bsgs-pie-fc5fb0a8a37e?source=collection_archive---------1-----------------------#2021-05-16">https://blog.devgenius.io/ace-that-coding-interview-day-4-15-binary-search-bsgs-pie-fc5fb0a8a37e?source=collection_archive---------1-----------------------#2021-05-16</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/c68b57584b9d35044737fd3269531a1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fE3Rjizgw-770cXk"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">克里斯托夫·高尔在<a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="1243" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi ky translated">欢迎来到我们技术面试准备系列的第四集。我们的目标是通过为您提供涵盖许多主题的真正的解决问题的技能，为您轻松获得梦想中的工作铺平道路。</p></div><div class="ab cl lh li hr lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ig ih ii ij ik"><p id="53ab" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">不要忘记查看该系列的其他内容:</p><ul class=""><li id="3c55" class="lo lp in kc b kd ke kh ki kl lq kp lr kt ls kx lt lu lv lw bi translated"><a class="ae jz" rel="noopener ugc nofollow" target="_blank" href="/15-days-of-leetcode-ace-that-coding-interview-day-1-15-9e2a76f5a62e">日(1/15):基本算术</a></li><li id="95b5" class="lo lp in kc b kd lx kh ly kl lz kp ma kt mb kx lt lu lv lw bi translated"><a class="ae jz" rel="noopener ugc nofollow" target="_blank" href="/15-days-of-leetcode-ace-that-coding-interview-day-2-15-fc47b4c8996">天(2/15):两点技术</a></li><li id="9bc8" class="lo lp in kc b kd lx kh ly kl lz kp ma kt mb kx lt lu lv lw bi translated"><a class="ae jz" rel="noopener ugc nofollow" target="_blank" href="/15-days-of-leetcode-ace-that-coding-interview-day-3-15-86cd0c1939f5">日(3/15):贪婪的思维</a></li><li id="83d9" class="lo lp in kc b kd lx kh ly kl lz kp ma kt mb kx lt lu lv lw bi translated"><strong class="kc io"> <em class="mc">天(4/15):二分搜索法+ BSGS +馅饼</em> </strong></li></ul></div><div class="ab cl lh li hr lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ig ih ii ij ik"><p id="57bd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们不要浪费时间，直接开始吧！</p></div><div class="ab cl lh li hr lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ig ih ii ij ik"><p id="b593" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">第四天:<a class="ae jz" href="https://leetcode.com/problems/ugly-number-iii/" rel="noopener ugc nofollow" target="_blank">丑号三</a></p><p id="cc78" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我假设你没有阅读任务描述，所以这里有一个摘要:</p><blockquote class="md me mf"><p id="0bc2" class="ka kb mc kc b kd ke kf kg kh ki kj kk mg km kn ko mh kq kr ks mi ku kv kw kx ig bi translated">给出四个数字<strong class="kc io"> <em class="in"> n </em> </strong>，<strong class="kc io"> <em class="in"> a </em> </strong>，<strong class="kc io"> <em class="in"> b </em> </strong>，<strong class="kc io"> <em class="in"> c </em> </strong>。</p><p id="61a3" class="ka kb mc kc b kd ke kf kg kh ki kj kk mg km kn ko mh kq kr ks mi ku kv kw kx ig bi translated">打印能被<strong class="kc io"> <em class="in">整除的第n个数a </em> </strong>，<strong class="kc io"> <em class="in"> b </em> </strong>或<strong class="kc io"> <em class="in"> c </em> </strong>。</p></blockquote></div><div class="ab cl lh li hr lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ig ih ii ij ik"><blockquote class="mj"><p id="9a80" class="mk ml in bd mm mn mo mp mq mr ms kx dk translated">声明:不要被简短的声明和简单的提示所迷惑。这个问题是冒名顶替。</p></blockquote><p id="3709" class="pw-post-body-paragraph ka kb in kc b kd mt kf kg kh mu kj kk kl mv kn ko kp mw kr ks kt mx kv kw kx ig bi translated"><strong class="kc io">第一次尝试:暴力破解</strong></p><p id="48c3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">从1开始循环数，数出能被<strong class="kc io"> <em class="mc"> a </em> </strong>、<strong class="kc io"> <em class="mc"> b </em> </strong>或<strong class="kc io"> c </strong>整除的数字，当你的计数器达到n时停止。</p><p id="ca8e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是绝对正确的，但它有效率吗？</p><p id="c07f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是一个O( <strong class="kc io"> <em class="mc"> N </em> </strong>)解但是作为<strong class="kc io"> n </strong>可以上升到<strong class="kc io"><em class="mc"/></strong>这需要很多时间来运行。在这篇文章的最后，我们将找到一个解决方案，运行在<strong class="kc io"> <em class="mc"> 50 </em> </strong>毫秒之内！</p><p id="308b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们设定一些衡量标准，根据以下方面向我们提供关于我们解决方案的<strong class="kc io">优点</strong>的反馈:</p><ul class=""><li id="d4f8" class="lo lp in kc b kd ke kh ki kl lq kp lr kt ls kx lt lu lv lw bi translated">正确性(那个解决方案给了我一个正确的答案吗？)</li><li id="011e" class="lo lp in kc b kd lx kh ly kl lz kp ma kt mb kx lt lu lv lw bi translated">效率(要等多久才能得到答案？)</li></ul><p id="eed9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这些标准足以决定我们是否在做正确的事情，或者我们放弃并考虑一种不同的方法。</p></div><div class="ab cl lh li hr lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ig ih ii ij ik"><p id="36f8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们评价一下我们的<strong class="kc io">暴力男</strong>的善良:</p><p id="5a85" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">正确性</strong> : 10/10</p><p id="5878" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">效率</strong> : 2/10，对于小输入来说运行很快，但在其他情况下却慢得令人难以置信。</p><p id="4e7b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">总体</strong> : 6/10，不是很大:(</p><p id="b307" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们需要做得更好，不是吗？</p></div><div class="ab cl lh li hr lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ig ih ii ij ik"><p id="e992" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">像往常一样，我们试图将问题分解成更小的子问题。</p><p id="defa" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">更小的子问题:</strong></p><p id="4fb7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们试着用<strong class="kc io"> a = b = c </strong>的条件来解决同样的问题。</p><p id="08cb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">原来我们有一个封闭形式的公式来计算那种情况下的答案(作为练习想出来的)，但是我们假装不知道。</p><p id="1046" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们还定义了一个<strong class="kc io">助手函数</strong>(一个做一些辅助工作来帮助我们完成任务的函数)。请耐心听我说，你很快就会知道我们为什么这么做。</p><p id="d64f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们定义了辅助函数“<strong class="kc io"> Count_Ugly </strong>”，它以<strong class="kc io"> <em class="mc"> X </em> </strong>为输入，返回小于或等于<strong class="kc io"> <em class="mc"> X </em> </strong>的丑数的计数。</p><p id="d3e6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在我们想知道最小的数m，s . t Count _ Ugly(<strong class="kc io"><em class="mc">m</em></strong>)=<strong class="kc io"><em class="mc">n</em></strong>，我们最终的答案是m，这就是通常所说的<strong class="kc io">下界</strong>查询。</p></div><div class="ab cl lh li hr lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ig ih ii ij ik"><blockquote class="md me mf"><p id="1c13" class="ka kb mc kc b kd ke kf kg kh ki kj kk mg km kn ko mh kq kr ks mi ku kv kw kx ig bi translated">事实:Count_Ugly不减，那就是Count _ Ugly(<strong class="kc io">x+1</strong>)≥Count _ Ugly(<strong class="kc io">x</strong>)，能看出为什么吗？</p></blockquote><p id="ab49" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">每当你遇到函数递增的情况时，选择二分搜索法是一个可以考虑的选择，但是二分搜索法是什么呢？！</p></div><div class="ab cl lh li hr lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ig ih ii ij ik"><p id="8c7e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是二分搜索法的样子:)</p><figure class="mz na nb nc gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi my"><img src="../Images/036ed1d0d6e1c87cee1a6c5e624ff76a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kPa6tC-KGqhuL4XZkcGXEw.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">“搜索”这个词用二进制写成</figcaption></figure><p id="8128" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">二分搜索法简介:</strong></p><p id="eb7a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">二分搜索法很聪明，它不做不必要的计算，而是利用函数不减的事实，以天文数字的方式减少迭代次数，让我们仔细看看，了解这是怎么回事。</p><p id="b4cd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">二分搜索法在行动:</strong></p><p id="0250" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">1-定义你要检查的范围[ <strong class="kc io"> <em class="mc"> L </em> </strong>，<strong class="kc io"> <em class="mc"> R </em> </strong> ]，简单来说就是你在告诉算法“嘿二分搜索法，我想让你帮我查一下答案，它在<strong class="kc io"> <em class="mc"> L </em> </strong>和<strong class="kc io"> <em class="mc"> R </em> </strong>之间的某个地方，但是我不知道确切的位置”。</p><p id="0e97" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">2-在范围[ <strong class="kc io"> <em class="mc"> L </em> </strong>，<strong class="kc io"> <em class="mc"> R </em> </strong> ]中寻找中间数，一个标准的办法是用公式<strong class="kc io"><em class="mc">M</em></strong>=<strong class="kc io">(L+R)/2</strong>(四舍五入)。</p><p id="b066" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">3-现在到了关键部分:算法仔细检查了<strong class="kc io"> <em class="mc"> M </em> </strong>，并在此基础上决定下一步做什么。</p><p id="baf6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">——第一个场景是Count_Ugly(<strong class="kc io"><em class="mc">M</em></strong>)&lt;<strong class="kc io"><em class="mc">n</em></strong>，暗示[ <strong class="kc io"> <em class="mc"> L </em> </strong>，<strong class="kc io"> <em class="mc"> M </em> </strong> ]中任意一个家伙的Count _ Ugly小于n，暗示我们的答案在[ <strong class="kc io"> <em class="mc"> M + 1 </em> </strong>，<strong class="kc io"> <em class="mc"> R中的某处</em></strong></p><p id="092e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">-第二种场景是Count _ Ugly(<strong class="kc io"><em class="mc">M</em></strong>)≥<strong class="kc io"><em class="mc">n</em></strong>)，暗示M是候选答案，但我们不能确定它是否是最小的可能答案，我们知道的是我们应该忽略范围[ <strong class="kc io"> <em class="mc"> M + 1 </em> </strong>内的任何数字， <strong class="kc io"> <em class="mc"> R </em> </strong> ]因为<strong class="kc io"> <em class="mc"> M </em> </strong>是比他们所有人都更好的候选人(记住我们在寻找最小的答案)，现在调整你的范围[ <strong class="kc io"> <em class="mc"> L </em> </strong>，<strong class="kc io"> <em class="mc"> R </em> </strong> ]成为[ <strong class="kc io"> <em class="mc"> L </em> </strong>，<strong class="kc io"/></p><p id="3013" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">4-最终你会得到<strong class="kc io"> <em class="mc"> L = R = M </em> </strong>，这是算法的最终迭代，查M就足以知道最终答案，如果Count _ Ugly(<strong class="kc io"><em class="mc">M</em></strong>)&lt;<strong class="kc io"><em class="mc">n</em></strong>，则返回<strong class="kc io"> <em class="mc"> M + 1 </em> </strong>，否则返回<strong class="kc io"/></p></div><div class="ab cl lh li hr lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ig ih ii ij ik"><p id="a6d7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">迷茫？让我们试一个例子。</p><p id="ff2e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">N = 5，a = b = c = 3</p><p id="34ed" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">定义一个足够大的范围，这样你才有信心在里面找到答案。为了便于说明，我们将[ <strong class="kc io"> <em class="mc"> L </em> </strong>，<strong class="kc io"> <em class="mc"> R </em> </strong> ]设置为[ <strong class="kc io"> <em class="mc"> 1 </em> </strong>，<strong class="kc io"> <em class="mc"> 20 </em> </strong> ]，但在实际操作中，范围会大得多<strong class="kc io"/>。</p><p id="987a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">迭代1:</p><p id="d4f6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">L = 1，R = 20，M = 10</p><p id="1d57" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">count _ Ugly(<strong class="kc io">10</strong>)=<strong class="kc io">3</strong>，即小于n所以我们需要右转因为range [ <strong class="kc io"> <em class="mc"> L </em> </strong>，<strong class="kc io"> <em class="mc"> M </em> </strong> ]正好没用。</p></div><div class="ab cl lh li hr lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ig ih ii ij ik"><p id="3b6b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">迭代2:</p><p id="95a0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">L = 11，R = 20，M = 15</p><p id="a19c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">count _ Ugly(<strong class="kc io">15</strong>)=<strong class="kc io">5</strong>)，这很好，我们能够在仅仅两次迭代中找到答案，这是谁梦寐以求的，但我们应该持怀疑态度，不要忽略范围[L，M-1]，因为里面可能有一个<strong class="kc io">更小的</strong>答案，所以让我们调整我们的范围，看看会发生什么。</p></div><div class="ab cl lh li hr lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ig ih ii ij ik"><p id="8f0a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">迭代3:</p><p id="cd9c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">L = 11，R = 14，M = 12</p><p id="a79a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">count _ Ugly(<strong class="kc io">12</strong>)=<strong class="kc io">4</strong>&lt;<strong class="kc io">n</strong>，右转<strong class="kc io"/>。</p></div><div class="ab cl lh li hr lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ig ih ii ij ik"><p id="ad94" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">迭代4:</p><p id="cbf5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">L = 13，R = 14，M = 13</p><p id="e8ea" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">count _ Ugly(<strong class="kc io"><em class="mc">13</em></strong>)=<strong class="kc io">4</strong>&lt;<strong class="kc io">n</strong>，右转<strong class="kc io"/>。</p></div><div class="ab cl lh li hr lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ig ih ii ij ik"><p id="e530" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">迭代5:</p><p id="9e60" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">L = R = M = 14</p><p id="a540" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">count _ Ugly(<strong class="kc io"><em class="mc">14</em></strong>)=<strong class="kc io"><em class="mc">4</em>&lt;<strong class="kc io"><em class="mc">n</em></strong>，那就足以肯定地说<strong class="kc io"> 14 + 1 = 15 </strong>是现存的<strong class="kc io">最小的</strong>答案。</strong></p><p id="2e64" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果我们运行<strong class="kc io">线性搜索</strong>(又名蛮力)，我们在<strong class="kc io"> <em class="mc"> 5 </em> </strong>迭代中得到我们的答案，而不是<strong class="kc io"> <em class="mc"> 15 </em> </strong>。</p></div><div class="ab cl lh li hr lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ig ih ii ij ik"><p id="f3d4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">二分搜索法有多快？现在，我将省略任何数学术语，以尽可能让本教程对初学者友好。</p><p id="32f0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">相反，我会试着让你相信这真的很快，即使范围很大。</p></div><div class="ab cl lh li hr lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ig ih ii ij ik"><p id="357d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">二分搜索法的时间分析:</strong></p><p id="541a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们从范围内的S个数字开始(<strong class="kc io"><em class="mc">S</em></strong>=<strong class="kc io"><em class="mc">R</em></strong>-<strong class="kc io"><em class="mc">L</em></strong>+<strong class="kc io"><em class="mc">1</em></strong>)。</p><p id="c453" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">每次迭代后，我们忽略几乎一半的范围。我们来做个模拟，让你更信服。</p><p id="1aaa" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">T99】ST101】= 1024&gt;512&gt;256&gt;128&gt;64&gt;32&gt;16&gt;8&gt;4&gt;2&gt;1</strong></p><p id="041c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">看看我们如何仅使用<strong class="kc io"> <em class="mc"> 10 </em> </strong>次迭代来检查超过一千个元素的范围。事实上，在许多情况下，二分搜索法是最快的搜索算法之一。其时间复杂度为(log <strong class="kc io"> <em class="mc"> N </em> </strong>)。</p></div><div class="ab cl lh li hr lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ig ih ii ij ik"><p id="80e0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们评价一下我们的<strong class="kc io">二分搜索法</strong>家伙的善良:</p><p id="8bb8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">正确性</strong> : 10/10，爽！</p><p id="02da" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">效率</strong> : 10/10，对于小输入和大输入，算法运行相当快。</p><p id="78be" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">总体</strong> : 10/10，那就是你需要的家伙:)</p></div><div class="ab cl lh li hr lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ig ih ii ij ik"><p id="9247" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们可以尝试许多方法来回答下限查询:</p><p id="8557" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">梅塔二分搜索法:</strong></p><p id="1fd1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这与我们刚刚所做的略有不同，它基于答案的<strong class="kc io">二进制表示</strong>。</p><p id="0d97" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">元二分搜索法用Count _ Ugly(<strong class="kc io"><em class="mc">L</em></strong>)&lt;<strong class="kc io"><em class="mc">n</em></strong>找出最大的数<strong class="kc io"> <em class="mc"> L </em> </strong>，然后给L加1说就是答案。</p><p id="7c89" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">它从最大到最小对2的幂进行迭代，并尝试将其添加到答案中，并检查Count _ Ugly(<strong class="kc io">current _ answer</strong>)是否为&lt; <strong class="kc io"> <em class="mc"> n </em> </strong>，如果是这样，它什么也不做，否则它撤消该步骤，并继续下一个2的幂。</p><p id="d433" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">伪代码:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="50ec" class="ni nj in ne b gy nk nl l nm nn">LowerBound(n)<br/>   <br/>   big_power = a big enough power of two <br/>   answer = 0</span><span id="4b46" class="ni nj in ne b gy no nl l nm nn">   for i from big_power to 0<br/>      add 2^i to answer<br/>      if Count_Ugly(answer) &gt;= n<br/>         substract 2^i from answer<br/>   return answer + 1</span></pre><p id="4e19" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这只是二分搜索法的另一个视角，它有固定的迭代次数。</p><p id="9ebe" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们通常从<strong class="kc io"><em class="mc">【2⁶】</em></strong>开始，这在几乎所有情况下都绰绰有余，但是你可以根据最终答案的大小，设置一个较小的2的幂作为起点。</p></div><div class="ab cl lh li hr lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ig ih ii ij ik"><p id="66ab" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">婴儿步/巨人步(平方根分解):</strong></p><p id="0384" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是您可以尝试的另一种方法，让我们从一个场景开始:</p><p id="e7fb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你想从你在城市<strong class="kc io"> <em class="mc"> X </em> </strong>的大学宿舍，到你在城市<strong class="kc io"><em class="mc"/></strong>的家，你乘坐公共汽车，它会带你到想要的目的地<strong class="kc io"> <em class="mc"> Y </em> </strong>，你下车，沿着街道走，直到你到达你的家，恭喜你刚刚应用了小步/大步(<strong class="kc io"> BSGS </strong>)算法。</p><p id="019d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">BSGS很简单。它说“如果你想从点<strong class="kc io"> <em class="mc"> A </em> </strong>，到点<strong class="kc io"> <em class="mc"> B </em> </strong>，开始大步前进，直到你足够接近B，然后你减速并开始小步前进，直到你碰到<strong class="kc io"> <em class="mc"> B </em> </strong>。</p><p id="74be" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在上面的场景中，你乘公共汽车(这说明了巨大的步伐)，也就是说每一步都带你去一个不同的城市，当你下车时，你开始醒来(这代表了微小的步伐)。</p><p id="c47c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个算法的运行时间取决于你的大步长<strong class="kc io"> <em class="mc"> S </em> </strong>的大小。</p><p id="825a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果距离是<strong class="kc io"> <em class="mc"> N </em> </strong>，那么选择<strong class="kc io"> <em class="mc"> S </em> </strong>会产生以下结果:</p><ul class=""><li id="d468" class="lo lp in kc b kd ke kh ki kl lq kp lr kt ls kx lt lu lv lw bi translated">我们使<strong class="kc io"> <em class="mc"> N / S </em> </strong>大步长(向下舍入)，如果你做得比那个多，你将超过目标。</li><li id="611a" class="lo lp in kc b kd lx kh ly kl lz kp ma kt mb kx lt lu lv lw bi translated">我们最多使<strong class="kc io"> <em class="mc"> S </em> </strong>小步前进，如果你使<strong class="kc io"> <em class="mc"> S </em> </strong>小步前进，那么你为什么不反而使一大步前进呢？！</li></ul><p id="81e0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">即(<strong class="kc io"> <em class="mc"> S + N / S </em> </strong>)之和，当<strong class="kc io"> <em class="mc"> S </em> </strong>约为<strong class="kc io"><em class="mc"/></strong>N的平方根时，这个和是最小的可能，就变成了(sqrt(<strong class="kc io"><em class="mc">N</em>【T39)+<strong class="kc io"><em class="mc">N</em></strong>/sqrt(<strong class="kc io"><em class="mc">N</em></strong></strong></p><p id="5dcb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">也就是O( sqrt( <strong class="kc io"> <em class="mc"> N </em> </strong>))，这在很多情况下已经足够快了。</p><p id="95cb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">伪代码:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="6429" class="ni nj in ne b gy nk nl l nm nn">LowerBound(n)<br/>   <br/>   big = squart_root(n)<br/>   small = 1<br/>   answer = 0</span><span id="fc06" class="ni nj in ne b gy no nl l nm nn">   while Count_Ugly( answer + big) &lt; n<br/>      answer += big</span><span id="df25" class="ni nj in ne b gy no nl l nm nn">   while (count_Ugly + small ) &lt; n<br/>      answer += small</span><span id="e4da" class="ni nj in ne b gy no nl l nm nn">   return answer + 1</span></pre></div><div class="ab cl lh li hr lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ig ih ii ij ik"><blockquote class="mj"><p id="e672" class="mk ml in bd mm mn mo mp mq mr ms kx dk translated">记住，这不是实际问题，但解决它是解决大事的一个伟大里程碑。</p></blockquote></div><div class="ab cl lh li hr lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ig ih ii ij ik"><p id="dcc7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">一般情况:</strong></p><p id="20c0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是我们现在不能庆祝，因为我们只解决了一般问题的一个特例。我们做了一个a = b = c的约束，但一般情况下不是这样。</p><p id="9f36" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">原来我们只需要快速找到<strong class="kc io"> Count_Ugly </strong>就可以了。我们能做的最好的事情是找到一个O(1)公式，但是它不是特别明显。</p></div><div class="ab cl lh li hr lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ig ih ii ij ik"><p id="1f9b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是我们在<strong class="kc io"><em class="mc">a</em></strong>=<strong class="kc io">b</strong>=<strong class="kc io"><em class="mc">c</em></strong>的时候怎么算<strong class="kc io"> Count_Ugly </strong>？</p><p id="43d0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是一个简单的问题。这只是一个简单的除法。</p><blockquote class="md me mf"><p id="4c17" class="ka kb mc kc b kd ke kf kg kh ki kj kk mg km kn ko mh kq kr ks mi ku kv kw kx ig bi translated">事实:区间[ <strong class="kc io"> <em class="in"> 1 </em> </strong>，<strong class="kc io"> <em class="in"> N </em> </strong> ]中可被<strong class="kc io"> <em class="in"> X </em> </strong>整除的数的个数为<strong class="kc io">/N</strong>(四舍五入)。</p></blockquote></div><div class="ab cl lh li hr lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ig ih ii ij ik"><p id="96a9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了概括这个观点，让我们回忆一下<a class="ae jz" href="https://en.wikipedia.org/wiki/Inclusion%E2%80%93exclusion_principle" rel="noopener ugc nofollow" target="_blank">包含-排斥原理</a></p><figure class="mz na nb nc gt jo gh gi paragraph-image"><div class="gh gi np"><img src="../Images/4038c75eea3d13ed55d65ba35d763fa3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1154/format:webp/1*nV0QwXCd8PcryDegj4Xgeg.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">图片摘自<a class="ae jz" href="https://commons.wikimedia.org/wiki/File:Inclusion-exclusion.png" rel="noopener ugc nofollow" target="_blank">维基百科</a></figcaption></figure><p id="d891" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">简而言之，这个原则是，如果你想列举满足两个条件之一的东西，你可以这样做:</p><p id="9569" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">设<strong class="kc io"> S1 </strong>是满足第一个条件的东西的数量，同样将<strong class="kc io"> S2 </strong>定义为满足第二个条件的东西的数量。</p><p id="9ae4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">定义<strong class="kc io"> S12 </strong>为同时满足<strong class="kc io">和</strong>两个条件的事物的计数。</p><p id="f320" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你的答案是<strong class="kc io"> <em class="mc"> S1+S2 -S12 </em> </strong></p><p id="4eee" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">请注意，我们减去了<strong class="kc io"> S12 </strong>，因为它们被加了两次，因为它们在<strong class="kc io"> S1 </strong>和<strong class="kc io"> S2 </strong>中被重复计算，所以我们应该减去数量。</p></div><div class="ab cl lh li hr lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ig ih ii ij ik"><p id="64db" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">示例:</p><p id="2b26" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">假设我们感兴趣的是在[1，20]范围内被3或5整除的数的计数</p><p id="ea2b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">馅饼话不多，但让你看一看，亲眼看看内心的盘算(多么善良！).</p><p id="a920" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"><em class="mc"/></strong>= 1<strong class="kc io"><em class="mc">20</em></strong>中有多少个数能被<strong class="kc io"><em class="mc"/></strong>整除，那就是<strong class="kc io"> <em class="mc"> 20 / 3 </em> </strong>向下舍入= <strong class="kc io"> <em class="mc"> 6 </em> </strong></p><p id="c38a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"><em class="mc">【S2】</em></strong>= 1，<strong class="kc io"> <em class="mc"> 20 </em> </strong>中有多少个数能被<strong class="kc io"><em class="mc"/></strong>整除，即<strong class="kc io"> <em class="mc"> 20 / 5 </em> </strong>向下舍入= <strong class="kc io"> <em class="mc"> 4 </em> </strong></p><p id="184b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"><em class="mc">S12</em></strong>= 1，<strong class="kc io"> <em class="mc"> 20 </em> </strong>中有多少个数能被<strong class="kc io"> <em class="mc"> 3 </em> </strong>和<strong class="kc io"> <em class="mc"> 5 </em> </strong>整除，这就比较难计算了，但还是可控的，只要回想一下这样一个事实，如果<strong class="kc io"> <em class="mc"> Z </em> </strong>除以<strong class="kc io"> <em class="mc"> A </em> 而<strong class="kc io"> <em class="mc"> B </em> </strong>然后<strong class="kc io"><em class="mc">Z</em><strong class="kc io">LCM</strong><strong class="kc io"><em class="mc">A</em></strong>和<strong class="kc io"> <em class="mc"> B </em> </strong>的最小公倍数)，LCM(<strong class="kc io"><em class="mc">3</em></strong>，<strong class="kc io"><em class="mc">5</em>)=<strong class="kc io"/></strong></strong></strong></p><p id="8da8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">S1+S2-S12</strong>=<strong class="kc io">6</strong>+<strong class="kc io">4</strong>–<strong class="kc io">1</strong>= 9，于是馅饼大喊“<strong class="kc io"> <em class="mc"> 9 </em> </strong>就是答案”。</p><p id="9611" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果这是你第一次处理馅饼，你可能会持怀疑态度(这是一件好事)，所以让我们仔细检查一下我们已经得到了什么。</p><p id="7666" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">1，2，<strong class="kc io"> <em class="mc"> 3 </em> </strong>，4，<strong class="kc io"> <em class="mc"> 5 </em> </strong>，<strong class="kc io"> <em class="mc"> 6 </em> </strong>，7，8，<strong class="kc io"> <em class="mc"> 9 </em> </strong>，<strong class="kc io"> <em class="mc"> 10 </em> </strong>，11，<strong class="kc io"> <em class="mc"> 12 </em> </strong>，13，14</p><p id="58ca" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">粗体的数字就是答案，而我们有其中的<strong class="kc io"> <em class="mc"> 9 </em> </strong>，所以你至少应该对馅饼的力量有点信心。</p></div><div class="ab cl lh li hr lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ig ih ii ij ik"><p id="8f8c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为什么把自己限制在两个条件下，其实派并不在乎它们的数量。</p><p id="53e1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在我们的例子中，我们有三个条件。</p><ul class=""><li id="b396" class="lo lp in kc b kd ke kh ki kl lq kp lr kt ls kx lt lu lv lw bi translated"><strong class="kc io"> Sxyz </strong>是同时满足第x个<strong class="kc io"><em class="mc"/></strong>，<strong class="kc io"> <em class="mc">第y个</em> </strong>和<strong class="kc io"> <em class="mc">第z个</em> </strong>条件的事物的计数。</li><li id="b269" class="lo lp in kc b kd lx kh ly kl lz kp ma kt mb kx lt lu lv lw bi translated"><strong class="kc io"> Sxy </strong>是同时满足第x个<strong class="kc io"><em class="mc"/></strong>和第y个<strong class="kc io"><em class="mc"/></strong>条件的事物的计数。</li><li id="6b55" class="lo lp in kc b kd lx kh ly kl lz kp ma kt mb kx lt lu lv lw bi translated"><strong class="kc io"> Sz </strong>是满足条件<strong class="kc io">T3】zT5】的事物的计数。</strong></li></ul><p id="8eb9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在派的工作更加复杂了:</p><p id="6d21" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">它计算<strong class="kc io"> S1 </strong>，<strong class="kc io"> S2 </strong>，<strong class="kc io"> S3 </strong>，<strong class="kc io"> S12 </strong>，<strong class="kc io"> S13 </strong>，<strong class="kc io"> S23 </strong>，<strong class="kc io"> S123 </strong></p><p id="0590" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">而最终的答案是<strong class="kc io">S1</strong>+<strong class="kc io">S2</strong>+<strong class="kc io">S3</strong>-<strong class="kc io">S12</strong>-<strong class="kc io">S23</strong>-<strong class="kc io">S13</strong>+<strong class="kc io">S123。说服你自己，我们没有重复计算任何东西。</strong></p><p id="8424" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这就是我们所需要的，让我们写一些代码:</p></div><div class="ab cl lh li hr lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ig ih ii ij ik"><p id="eaae" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我的C++实现</p><figure class="mz na nb nc gt jo"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="6883" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我的Python实现</p><figure class="mz na nb nc gt jo"><div class="bz fp l di"><div class="nq nr l"/></div></figure></div><div class="ab cl lh li hr lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ig ih ii ij ik"><p id="1c19" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们如何完成今天的任务，以及如何应对其他挑战？</p><ul class=""><li id="1e0d" class="lo lp in kc b kd ke kh ki kl lq kp lr kt ls kx lt lu lv lw bi translated">将你手中的问题分解成更小的子问题:这种技术非常有用，因为更小的问题往往有更简单、有时是众所周知的解决方案。</li><li id="ba1c" class="lo lp in kc b kd lx kh ly kl lz kp ma kt mb kx lt lu lv lw bi translated">思考如何高效地解决更小的子问题，并将其组合成一个最终的快乐解决方案。</li><li id="7bc1" class="lo lp in kc b kd lx kh ly kl lz kp ma kt mb kx lt lu lv lw bi translated">改变问题的设定，做出有助于你更好地解读眼前问题的假设:注意我们假设了a = b = c，后来我们找到了一般解。</li><li id="1e00" class="lo lp in kc b kd lx kh ly kl lz kp ma kt mb kx lt lu lv lw bi translated">重读这篇文章很多次，直到你完全理解它，尤其是如果你是第一次看到二分搜索法或包含-排除原理的应用。</li></ul><h1 id="dc71" class="ns nj in bd nt nu nv nw nx ny nz oa ob oc od oe of og oh oi oj ok ol om on oo bi translated">轮到你了:</h1><p id="cf89" class="pw-post-body-paragraph ka kb in kc b kd op kf kg kh oq kj kk kl or kn ko kp os kr ks kt ot kv kw kx ig bi translated">恭喜你！如果你一口气做到了，我知道你能做到。</p><p id="49ce" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">既然你有希望获得一些新技能，不要止步于此，将它们付诸实践。</p><p id="636a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">去玩代码，自己从头开始写，挑战自己，想出可以用二分搜索法解决的问题的例子。</p><p id="cfac" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">通过发明你自己的解决下限查询的方法来进行下一步，祝你好运；)</p><p id="1a27" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">练习附加题:</strong></p><p id="409c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><a class="ae jz" href="https://leetcode.com/problems/guess-number-higher-or-lower/" rel="noopener ugc nofollow" target="_blank">猜测数字变高还是变低</a></p><p id="ff02" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><a class="ae jz" href="https://leetcode.com/problems/online-election/" rel="noopener ugc nofollow" target="_blank">网上选举</a></p><p id="f7e1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><a class="ae jz" href="https://leetcode.com/problems/swim-in-rising-water/" rel="noopener ugc nofollow" target="_blank">在上涨的水中游泳</a></p><p id="0472" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><a class="ae jz" href="https://leetcode.com/problems/k-th-smallest-prime-fraction/" rel="noopener ugc nofollow" target="_blank">第K个最小素数分数</a></p><p id="a183" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><a class="ae jz" href="https://leetcode.com/problems/shortest-subarray-to-be-removed-to-make-array-sorted/" rel="noopener ugc nofollow" target="_blank">要移除的最短子阵列，使阵列排序</a></p></div><div class="ab cl lh li hr lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ig ih ii ij ik"><p id="bc3b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果你有问题想问我，可以在<a class="ae jz" href="https://www.linkedin.com/in/mohamed-sobhy-12181b165/" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io"> LinkedIn </strong> </a>联系我，在<a class="ae jz" href="https://medium.com/@mohamedsobhi777" rel="noopener"> <strong class="kc io"> Medium </strong> </a>关注我，获取更多有趣的文章。</p><p id="6d91" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">今天到此为止。感谢阅读！</p></div></div>    
</body>
</html>