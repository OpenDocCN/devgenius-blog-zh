<html>
<head>
<title>Best of Modern JavaScript — Prototypes and Calls</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">现代JavaScript精华——原型和调用</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/best-of-modern-javascript-prototypes-and-calls-a17b2631d083?source=collection_archive---------5-----------------------#2020-09-12">https://blog.devgenius.io/best-of-modern-javascript-prototypes-and-calls-a17b2631d083?source=collection_archive---------5-----------------------#2020-09-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/973b1c43fc5e6ea93a3ff5b6d03268e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fD2ErqIDi9yGGP9t"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">乔·什切潘斯卡在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="6ee4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">自2015年以来，JavaScript有了巨大的进步。</p><p id="c894" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在用起来比以前舒服多了。</p><p id="193a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究JavaScript中的原型和方法调用。</p><h1 id="3e3b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">原型链</h1><p id="9c5b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">JavaScript对象是一个或多个对象的链。</p><p id="da37" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第一个对象从后面的对象继承属性。</p><p id="eb8b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，数组的原型链有一个包含数组元素的实例。</p><p id="ead6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">Array.prototytpe</code>具有由<code class="fe me mf mg mh b">Array</code>构造函数提供的属性。</p><p id="17da" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">Object.prototype</code>具有<code class="fe me mf mg mh b">Object</code>构造器提供的属性。</p><p id="f07c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而<code class="fe me mf mg mh b">null</code>是链条的末端。</p><p id="a20a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以使用方法的<code class="fe me mf mg mh b">Object.getPrototype</code>来得到数组的原型。</p><p id="7011" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="d69a" class="mq lc iq mh b gy mr ms l mt mu">const arr = ['a', 'b'];<br/>const proto = Object.getPrototypeOf(arr);</span></pre><p id="31b2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们在<code class="fe me mf mg mh b">proto</code>变量中看到数组原型的内容。</p><p id="86fe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以看到各种方法、迭代器等等。</p><p id="648c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也可以使用<code class="fe me mf mg mh b">getOwnPropertyNames</code>方法来获取原型成员的名字。</p><p id="d679" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="c33e" class="mq lc iq mh b gy mr ms l mt mu">const arr = ['a', 'b'];<br/>const p = Object.getOwnPropertyNames(arr);</span></pre><p id="f650" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们得到<code class="fe me mf mg mh b">[“0”, “1”, “length”]</code>作为<code class="fe me mf mg mh b">p</code>的值。</p><p id="4e08" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些是可以列举的属性。</p><h1 id="849f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">分派的方法调用</h1><p id="c659" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果我们调用一个实例，JavaScript解释器执行2个步骤。</p><p id="2650" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它从原型链中获取方法。</p><p id="b76c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后它调用带有值<code class="fe me mf mg mh b">this</code>和参数的方法。</p><p id="6e02" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以将这两个步骤写成:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="5369" class="mq lc iq mh b gy mr ms l mt mu">const func = arr.toString;<br/>func.call(arr);</span></pre><h1 id="b8fd" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">直接方法调用的用例</h1><p id="ad7a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">直接方法调用在ES5中很有用，因为没有spread操作符来调用以数组spread作为参数的函数。</p><p id="d330" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要调用带有一组项目作为参数的方法，我们可以编写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="14fe" class="mq lc iq mh b gy mr ms l mt mu">const arr = [1, 2];<br/>Array.prototype.push.apply(arr, [3, 4])</span></pre><p id="7b27" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用<code class="fe me mf mg mh b">apply</code>方法调用<code class="fe me mf mg mh b">push</code>。</p><p id="6d41" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">arr</code>是<code class="fe me mf mg mh b">this</code>的值，是数组实例。</p><p id="567c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第二个参数是我们要传递给<code class="fe me mf mg mh b">push</code>的参数数组。</p><p id="51ab" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么<code class="fe me mf mg mh b">arr</code>就是<code class="fe me mf mg mh b">[1, 2, 3, 4]</code>。</p><p id="da1a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">扩展运算符取代了<code class="fe me mf mg mh b">apply</code>的使用。</p><p id="c350" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="6a92" class="mq lc iq mh b gy mr ms l mt mu">const arr = [1, 2];<br/>arr.push(...[3, 4]);</span></pre><p id="425c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这就简单多了，我们也不用担心<code class="fe me mf mg mh b">this</code>的值。</p><p id="6d59" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">他们做同样的事情。</p><p id="a032" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也可以使用spread操作符和<code class="fe me mf mg mh b">new</code>操作符。</p><p id="9ddc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="69f2" class="mq lc iq mh b gy mr ms l mt mu">new Date(...[2020, 11, 25])</span></pre><p id="c2d0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">apply</code>不能和<code class="fe me mf mg mh b">new</code>一起使用，因为我们还没有创建构造函数的实例。</p><p id="5f08" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在ES5中，没有简单的方法将类似数组的对象转换成数组。</p><p id="6e57" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们想将<code class="fe me mf mg mh b">arguments</code>对象转换成一个数组，我们必须使用<code class="fe me mf mg mh b">Array.prototype.slice</code>方法来完成。</p><p id="0787" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="86f3" class="mq lc iq mh b gy mr ms l mt mu">function foo(a, b, c) {<br/>  var args = Array.prototype.slice.call(arguments);<br/>  console.log(args);<br/>}</span></pre><p id="a5fa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们称之为<code class="fe me mf mg mh b">Array.prototype.slice.call</code>，它接受一个可迭代的对象。</p><p id="e39b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它返回一个数组，所以我们可以对它使用数组操作和方法。</p><p id="f02a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，我们可以将它用于到<code class="fe me mf mg mh b">document.querySelectorAll</code>返回的节点列表，</p><p id="0c3e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="ff98" class="mq lc iq mh b gy mr ms l mt mu">var divs = document.querySelectorAll('div');<br/>var arr = Array.prototype.slice.call(divs);</span></pre><p id="b789" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将作为节点列表的<code class="fe me mf mg mh b">divs</code>传递给<code class="fe me mf mg mh b">slice.call</code>方法，将其转换为数组。</p><p id="dd54" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在ES6中，这些都被spread和rest运算符所取代:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="1b61" class="mq lc iq mh b gy mr ms l mt mu">function foo(...args) {<br/>  console.log(args);<br/>}</span></pre><p id="6ef0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">和</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="f5a5" class="mq lc iq mh b gy mr ms l mt mu">const divs = document.querySelectorAll('div');<br/>const arr = [...divs];</span></pre><p id="92da" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们使用rest操作符和<code class="fe me mf mg mh b">foo</code>来获取数组形式的参数。</p><p id="fcbc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们使用spread操作符将div扩展到一个数组中。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/da3cb0bef05adcb10e65ac014ad201ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RQAoI4KmxK-pII1Y"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@berkeleycommunications?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">伯克利通信</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="e176" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="7571" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">有几种方法可以调用方法。</p><p id="3094" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以从实例中调用它们，也可以用<code class="fe me mf mg mh b">call</code>和<code class="fe me mf mg mh b">apply</code>调用它们。</p></div></div>    
</body>
</html>