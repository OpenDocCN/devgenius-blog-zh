<html>
<head>
<title>Using API Gateway Web Socket API with React, Redux and “Serverless” :: Part 01</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过 React、Redux 和“无服务器”使用 API 网关 Web Socket API:第 1 部分</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/using-api-gateway-web-socket-api-with-react-redux-and-serverless-part-01-2a9ec01c8a40?source=collection_archive---------6-----------------------#2022-04-11">https://blog.devgenius.io/using-api-gateway-web-socket-api-with-react-redux-and-serverless-part-01-2a9ec01c8a40?source=collection_archive---------6-----------------------#2022-04-11</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/9b2a11e1a3ddfb232cbdd1ccf4225266.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Knemj33bK0vwCrxDRInn_g.png"/></div></div></figure><p id="a2c6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">API gateway 无疑是 AWS 提供的使用最多的服务之一。但是，Web socket APIs 与通常的 REST APIss 有很大的不同，REST API 接收并响应客户端发送的请求。相反，Web Socket API 将创建一个由客户端建立的双向连接<strong class="jx io">。</strong></p><blockquote class="kt ku kv"><p id="b3c7" class="jv jw kw jx b jy jz ka kb kc kd ke kf kx kh ki kj ky kl km kn kz kp kq kr ks ig bi translated"><strong class="jx io">由客户端建立</strong>这里指的是双向连接的开始。因为客户端必须通过 Web 套接字服务 URL 触发连接。</p></blockquote><p id="0efb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里有很多例子展示了如何使用 Web 套接字创建一个聊天应用程序。所以，让我们来看看有些不同的东西。我们将使用 web 套接字创建一个 Web 推送通知功能。</p><h2 id="1f2f" class="la lb in bd lc ld le dn lf lg lh dp li kg lj lk ll kk lm ln lo ko lp lq lr ls bi translated">需要网页推送通知吗？</h2><p id="1564" class="pw-post-body-paragraph jv jw in jx b jy lt ka kb kc lu ke kf kg lv ki kj kk lw km kn ko lx kq kr ks ig bi translated">简而言之，它可以用于应用程序中的任何东西。一个例子是当后台任务完成时发出通知。在<a class="ae ly" href="https://medium.com/@iwiick/create-a-background-job-service-with-dynamodb-streams-and-lambda-functions-with-serverless-60b7bc49fd48" rel="noopener">的上一篇文章</a>中，我解释了如何用无服务器、DynamoDB 流和 Lambdas 创建你自己的后台“作业服务”。在这个场景中，我们可以使用推送通知来通知作业何时完成。Ant design <a class="ae ly" href="https://ant.design/components/notification/" rel="noopener ugc nofollow" target="_blank"> Notification </a>是一个可定制的组件，我们可以轻松地将其用于 react 应用程序。</p><h2 id="91fb" class="la lb in bd lc ld le dn lf lg lh dp li kg lj lk ll kk lm ln lo ko lp lq lr ls bi translated">路线</h2><p id="bb55" class="pw-post-body-paragraph jv jw in jx b jy lt ka kb kc lu ke kf kg lv ki kj kk lw km kn ko lx kq kr ks ig bi translated">正如我前面提到的，Web Socket APIs 的工作方式不同于 REST APIs。“路线”是这里的主要区别之一。<strong class="jx io"> $connect </strong>客户端与后端建立稳定连接后，进入路由。<strong class="jx io"> $disconnect </strong>客户端断开连接时访问路由。建立连接后，使用任何未指定的路由时，将访问<strong class="jx io"> $default </strong>路由。</p><p id="d375" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了澄清一些事情，这篇文章将分为两部分，第一部分将解释如何设置无服务器后端。下一部分将集中于用<strong class="jx io"> redux </strong>和 react <strong class="jx io">钩子</strong>:)灵活地设置前端代码</p><h1 id="62b4" class="lz lb in bd lc ma mb mc lf md me mf li mg mh mi ll mj mk ml lo mm mn mo lr mp bi translated">为 API 网关 Web 套接字设置无服务器后端。</h1><p id="5523" class="pw-post-body-paragraph jv jw in jx b jy lt ka kb kc lu ke kf kg lv ki kj kk lw km kn ko lx kq kr ks ig bi translated"><a class="ae ly" href="https://www.serverless.com/framework/docs/providers/aws/events/websocket" rel="noopener ugc nofollow" target="_blank">无服务器文档</a>提供了后端所需的设置代码。不过，我们将使用一个 lambda 函数(在下面的代码片段中是 createSocket lambda ),它与所有三个$connect、$disconnect 和$default 路由集成在一起:)</p><p id="bdeb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们还需要如下设置 IAM 权限。</p><figure class="mq mr ms mt gt jo"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="9e97" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，让我们看看“createSocket”处理程序。:)</p><figure class="mq mr ms mt gt jo"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="0cdb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这个代码片段中有一些事情需要注意。</p><blockquote class="kt ku kv"><p id="f48d" class="jv jw kw jx b jy jz ka kb kc kd ke kf kx kh ki kj ky kl km kn kz kp kq kr ks ig bi translated">这里我们不使用 return 语句。相反，我们使用回调</p></blockquote><p id="3caf" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是因为我们将为来自同一个 lambda 的所有路由保持套接字连接，直到断开路由被访问。如果我们在代码末尾返回，我们将会遇到一个严重的错误。所以，<strong class="jx io">改用回调:)</strong></p><blockquote class="kt ku kv"><p id="e7e8" class="jv jw kw jx b jy jz ka kb kc kd ke kf kx kh ki kj ky kl km kn kz kp kq kr ks ig bi translated"><strong class="jx io">switch 语句处理路由。</strong></p></blockquote><p id="d260" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是因为我们使用与所有 3 条路线集成的 lambda Lambda。我们从 switch 访问<strong class="jx io"> routeKey </strong>，并基于此执行逻辑。如果需要的话，你也可以为每一条路由设置单独的 Lambda 处理程序。</p><blockquote class="kt ku kv"><p id="d3fa" class="jv jw kw jx b jy jz ka kb kc kd ke kf kx kh ki kj ky kl km kn kz kp kq kr ks ig bi translated"><strong class="jx io">不要从 connect 路由向客户端发送消息</strong></p></blockquote><p id="e8d7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你这样做，它会给你一个错误。这是因为此时尚未建立连接。这就是为什么我们与客户沟通，如果<strong class="jx io"> $default </strong>路线。</p><blockquote class="kt ku kv"><p id="9cb0" class="jv jw kw jx b jy jz ka kb kc kd ke kf kx kh ki kj ky kl km kn kz kp kq kr ks ig bi translated"><strong class="jx io">“连接 Id”、“域名”和“阶段”取自 requestContext。</strong></p></blockquote><p id="a4d1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们需要“connectionId”将消息发送回客户端。“域名”和“阶段”也需要用于此目的，因为 URL 必须以特定的方式格式化。当然，我们可以使用 HTTP Url，而不用从“域名”和“stage”创建 Url，但是这样就忽略了使用无服务器方法的主要目的。让我们看一下消息传递给套接字客户端的代码片段，以及所有这些是如何连接的:)</p><figure class="mq mr ms mt gt jo"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="5242" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在使用<strong class="jx io"> API 网关管理 API </strong>时，我们需要遵循一些特定的代码语法。如您所见，这个函数有 3 个参数。</p><p id="6a19" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">“<strong class="jx io"> url </strong>”是我们需要从“域名”和“stage”中获取格式化后的 url 的地方。"<strong class="jx io"> ConnectionId </strong>"是通过该套接字连接的客户端的唯一 Id。“有效负载”是我们将发送回客户端的数据对象。它可以是任何东西，只要我们把它串起来(T21)</p><p id="6359" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，所有这些都已经过去了，让我们来看看完整的 Lambda 函数。</p><figure class="mq mr ms mt gt jo"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="38fd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们在第 22 行格式化 URL。我还将传递回<strong class="jx io"> connectionId </strong>和<strong class="jx io"> CallbackUrl </strong>作为有效负载。部署这个服务，您将获得一个 Web Socket 服务 URL。我们需要这个来建立与客户端的连接。</p><p id="b861" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这基本上就是设置后端的工作。使用 connectionId 和 callbackUrl 的内容和方式完全由您决定。只要您能够访问它们，就可以使用它们从应用程序的后端向客户端发送消息。在我的例子中，当使用我的自定义“<a class="ae ly" href="https://medium.com/@iwiick/create-a-background-job-service-with-dynamodb-streams-and-lambda-functions-with-serverless-60b7bc49fd48" rel="noopener">作业服务</a>”实现完成一个后台作业时，我用它来创建一个推送通知特性:)</p><p id="b977" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">文章的第二部分是<a class="ae ly" href="https://medium.com/@iwiick/using-api-gateway-web-socket-api-with-react-redux-and-serverless-part-02-da407a47d070" rel="noopener">这里</a>:)</p><p id="a6f7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="kw">经</em> <strong class="jx io"> <em class="kw">鹤山</em> </strong></p></div></div>    
</body>
</html>