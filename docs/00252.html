<html>
<head>
<title>Trie (Keyword Tree) Prefix Tree</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Trie(关键字树)前缀树</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/trie-keyword-tree-prefix-tree-5d59cdf895ea?source=collection_archive---------5-----------------------#2020-05-27">https://blog.devgenius.io/trie-keyword-tree-prefix-tree-5d59cdf895ea?source=collection_archive---------5-----------------------#2020-05-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="e14b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">字符串本质上可以被视为各种编程问题中最重要和最常见的主题。字符串处理在现实世界中也有多种应用，例如:</p><ul class=""><li id="605a" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated">搜索引擎</li><li id="6be5" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">染色体组分析</li><li id="26f5" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">数据分析</li></ul><p id="9cc3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以文本形式呈现给我们的所有内容都可以被可视化为字符串。</p><p id="95ef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">尝试:</p><p id="9c28" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">尝试是一种非常特殊和有用的数据结构，它基于字符串的前缀<em class="kz">。它们用于表示数据的“检索”,因此称为 Trie。</em></p><p id="bb4c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">前缀:前缀是什么:</p><p id="d3ed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">字符串的前缀只不过是任意 n 个字母 n≤|S|,可以严格地从字符串的开始处开始。例如，“阿巴卡巴”一词有以下前缀:</p><p id="d85f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一个<br/>ab<br/>ABA<br/>ABAC<br/>abaca<br/>abacab</p><p id="eb56" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Trie 是一种特殊的数据结构，用于存储可以像图形一样可视化的字符串。它由节点和边组成。每个节点最多由 26 个子节点组成，边将每个父节点连接到其子节点。这 26 个指针只不过是针对英语字母表的 26 个字母中的每一个的指针。</p><p id="5c9e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">字符串根据它们在 trie 中的前缀以自顶向下的方式存储。所有长度为 1 的前缀被存储到第 1 级，所有长度为 2 的前缀被排序到第 2 级，依此类推。</p><p id="21a9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，考虑下图:</p><figure class="lb lc ld le gt lf gh gi paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="gh gi la"><img src="../Images/0845b9987674656d1eaa931fae31c5fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*HaV77pZ3zlsk1aAe.png"/></div></div></figure><h1 id="699e" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">应用程序</h1><h1 id="569b" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">作为其他数据结构的替代</h1><p id="bccd" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">如下所述，trie 比二分搜索法树有许多优点。</p><p id="795b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">trie 也可以用来代替<a class="ae mp" href="https://en.wikipedia.org/wiki/Hash_table" rel="noopener ugc nofollow" target="_blank">哈希表</a>，相比之下有以下优点:</p><ul class=""><li id="ec6c" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated">与不完美的哈希表相比，在 trie 中查找数据在最坏的情况下更快，时间为 O(m )(其中 m 是搜索字符串的长度)。不完善的哈希表可能会发生键冲突。键冲突是不同键到哈希表中相同位置的哈希函数映射。在一个不完美的散列表中，最坏情况下的查找速度是 O(N) 时间，但是更典型的是 O(1)时间，其中 O(m)时间花费在评估散列上。</li><li id="b051" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">在一个 trie 中不同的键没有冲突。</li><li id="74e2" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">trie 中的桶类似于存储键冲突的散列表桶，只有当单个键与多个值相关联时才有必要。</li><li id="2937" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">当更多的关键字被添加到 trie 时，不需要提供散列函数或改变散列函数。</li><li id="a295" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">trie 可以通过关键字提供条目的字母顺序。</li></ul><p id="f6c7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，与哈希表相比，trie 也有一些缺点:</p><ul class=""><li id="bc68" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated">Trie 查找可能比哈希表查找慢，尤其是在硬盘驱动器或其他辅助存储设备上直接访问数据时，与主存储器相比，这些设备的随机访问时间较长。</li><li id="0a26" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">有些键，比如浮点数，会导致没有特别意义的长链和前缀。然而，按位 trie 可以处理标准的 IEEE 单精度和双精度浮点数。</li><li id="602b" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">有些尝试可能需要比哈希表更多的空间，因为可能会为搜索字符串中的每个字符分配内存，而不是像大多数哈希表那样为整个条目分配一块内存。</li></ul><h1 id="3232" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">字典表示法</h1><p id="79e0" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">trie 的一个常见应用是存储<a class="ae mp" href="https://en.wikipedia.org/wiki/Predictive_text" rel="noopener ugc nofollow" target="_blank">预测文本</a>或<a class="ae mp" href="https://en.wikipedia.org/wiki/Autocomplete" rel="noopener ugc nofollow" target="_blank">自动完成</a>字典，例如在<a class="ae mp" href="https://en.wikipedia.org/wiki/Mobile_telephone" rel="noopener ugc nofollow" target="_blank">移动电话</a>上找到的。这种应用程序利用了 trie 快速搜索、插入和删除条目的能力；然而，如果只需要存储字典单词(即，不需要存储每个单词的辅助信息)，则最小<a class="ae mp" href="https://en.wikipedia.org/wiki/Deterministic_acyclic_finite_state_automaton" rel="noopener ugc nofollow" target="_blank">确定性非循环有限状态自动机</a> (DAFSA)将比 trie 使用更少的空间。这是因为 DAFSA 可以压缩来自 trie 的相同分支，这些分支对应于被存储的不同单词的相同后缀(或部分)。</p><p id="a83a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">尝试也非常适合实现近似匹配算法，包括那些在<a class="ae mp" href="https://en.wikipedia.org/wiki/Spell_checking" rel="noopener ugc nofollow" target="_blank">拼写检查</a>和<a class="ae mp" href="https://en.wikipedia.org/wiki/Hyphenation_algorithm" rel="noopener ugc nofollow" target="_blank">断字</a>软件中使用的算法。</p><h1 id="c93e" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">术语索引</h1><p id="917f" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated"><a class="ae mp" href="https://en.wikipedia.org/w/index.php?title=Discrimination_tree&amp;action=edit&amp;redlink=1" rel="noopener ugc nofollow" target="_blank">判别树</a> <a class="ae mp" href="https://en.wikipedia.org/wiki/Term_indexing" rel="noopener ugc nofollow" target="_blank">术语索引</a>将其信息存储在 trie 数据结构中。</p><h1 id="565c" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">算法</h1><p id="fad6" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">trie 是支持查找和插入操作的节点树。Find 返回键字符串的值，Insert 将字符串(键)和值插入到 trie 中。插入和查找都在 O( <em class="kz"> m </em>)时间内运行，其中 m 是密钥的长度。</p><p id="569e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">可以使用一个简单的节点类来表示 trie 中的节点:</p><pre class="lb lc ld le gt mq mr ms mt aw mu bi"><span id="3192" class="mv ln iq mr b gy mw mx l my mz"><strong class="mr ir">class</strong> <strong class="mr ir">Node</strong>:<br/>   <strong class="mr ir">def</strong> __init__(self) -&gt; <strong class="mr ir">None</strong>:<br/>       <em class="kz"># Note that using dictionary for children (as in this implementation)</em><br/>       <em class="kz"># would not allow lexicographic sorting mentioned in the next section</em><br/>       <em class="kz"># (Sorting), because an ordinary dictionary would not preserve the</em><br/>       <em class="kz"># order of the keys</em><br/>       self.children: Dict[str, Node] = {}  <em class="kz"># mapping from character ==&gt; Node</em><br/>       self.value: Any = <strong class="mr ir">None</strong></span></pre><p id="3718" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意<code class="fe na nb nc mr b">children</code>是一个节点的子节点的字符字典；据说“终端”节点是表示完整字符串的节点。<br/>可以按如下方式查找 trie 的值:</p><pre class="lb lc ld le gt mq mr ms mt aw mu bi"><span id="a72d" class="mv ln iq mr b gy mw mx l my mz"><strong class="mr ir">def</strong> find(node: Node, key: str) -&gt; Any:<br/>    <em class="kz">"""Find value by key in node."""</em><br/>    <strong class="mr ir">for</strong> char <strong class="mr ir">in</strong> key:<br/>        <strong class="mr ir">if</strong> char <strong class="mr ir">in</strong> node.children:<br/>            node = node.children[char]<br/>        <strong class="mr ir">else</strong>:<br/>            <strong class="mr ir">return</strong> <strong class="mr ir">None</strong><br/>    <strong class="mr ir">return</strong> node.value</span></pre><p id="c650" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">可以对这个程序稍加修改</p><ul class=""><li id="9bed" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated">检查 trie 中是否有以给定前缀开头的单词，以及</li><li id="9b93" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">返回对应于给定字符串的某个前缀的最深节点。</li></ul><p id="0345" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">插入通过根据要插入的字符串遍历 trie，然后为 trie 中不包含的字符串的后缀附加新节点来进行:</p><pre class="lb lc ld le gt mq mr ms mt aw mu bi"><span id="2f72" class="mv ln iq mr b gy mw mx l my mz"><strong class="mr ir">def</strong> insert(node: Node, key: str, value: Any) -&gt; <strong class="mr ir">None</strong>:<br/>    <em class="kz">"""Insert key/value pair into node."""</em><br/>    <strong class="mr ir">for</strong> char <strong class="mr ir">in</strong> key:<br/>        <strong class="mr ir">if</strong> char <strong class="mr ir">not</strong> <strong class="mr ir">in</strong> node.children:<br/>            node.children[char] = Node()<br/>        node = node.children[char]<br/>    node.value = value</span></pre><p id="2cc9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">Trie 的 Kotlin 实现:</strong></p><p id="8571" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Trie 的基本概念是每个节点最多可以有 26 个子节点，因为我们有 26 个字母[a-z]。</p><p id="de6a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以我们必须使用带有 HashMap 的 Node，它将字符存储为键，将值存储为节点。</p><p id="fdad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">插入 Trie : </strong></p><p id="443e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以我们将在 Trie 中一个字符一个字符地添加，如果我们当前节点的地图包含相同的字符，那么我们可以向前移动，否则我们将创建一个节点。</p><p id="36cb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果所有字符都已插入，则将该节点标记为<em class="kz"> isWorldend。</em></p><p id="5602" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">在 Trie 中搜索:</strong></p><p id="ab82" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以像在 insert 中一样搜索，在 Trie 中逐个字符地搜索，直到我们的字符完成，然后检查<em class="kz"> isWorldEnd </em>是否为真，然后返回 true，否则返回 false。</p><p id="7c46" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">在 Trie 中搜索前缀:</strong></p><p id="9864" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">搜索前缀与搜索关键字是一样的，唯一的区别是我们可以忽略<em class="kz"> isWorldEnd </em>值，就好像所有字符匹配返回 true 一样。</p><p id="8e09" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是 Trie 的代码:</p><pre class="lb lc ld le gt mq mr ms mt aw mu bi"><span id="53fd" class="mv ln iq mr b gy mw mx l my mz"><strong class="mr ir">class </strong>Trie {<br/><br/>    <strong class="mr ir">private val root </strong>= Node(0.toChar())<br/><br/>    <strong class="mr ir">inner class </strong>Node(<strong class="mr ir">val char</strong>: Char) {<br/>        <strong class="mr ir">val map </strong>= HashMap&lt;Char, Node&gt;()<br/>        <strong class="mr ir">var isWorldEnd </strong>= <strong class="mr ir">false<br/>    </strong>}<br/><br/><br/>    <strong class="mr ir">fun </strong>insert(word: String) {<br/>        <strong class="mr ir">if </strong>(word.<em class="kz">isNotEmpty</em>()) {<br/>          insertNode(<strong class="mr ir">root</strong>,word,0)<br/>        }<br/>    }<br/><br/>    <strong class="mr ir">private fun </strong>insertNode(node: Node, word: String, i: Int) {<br/>        <strong class="mr ir">val </strong>index = i<br/>        <strong class="mr ir">if </strong>(index &lt; word.<strong class="mr ir">length</strong>) {<br/>            <strong class="mr ir">val </strong>char =  word.<em class="kz">elementAt</em>(i)<br/>            <strong class="mr ir">if </strong>(node.<strong class="mr ir">map</strong>.containsKey(char)) {<br/>                <strong class="mr ir">val </strong>child = node.<strong class="mr ir">map</strong>[char]<br/>                insertNode(child!!,word,index+1)<br/>            } <strong class="mr ir">else </strong>{<br/>                node.<strong class="mr ir">map</strong>[char] = Node(char)<br/>                insertNode(node.<strong class="mr ir">map</strong>[char]!!,word,index+1)<br/>            }<br/>        }<br/>        <strong class="mr ir">else</strong>{<br/>            node.<strong class="mr ir">isWorldEnd </strong>= <strong class="mr ir">true<br/>        </strong>}<br/>    }<br/><br/>    <em class="kz">/** Returns if the word is in the trie. */<br/>    </em><strong class="mr ir">fun </strong>search(word: String): Boolean {<br/>        <strong class="mr ir">if</strong>(word.<em class="kz">isNotEmpty</em>()){<br/>            <strong class="mr ir">var </strong>index = 0<br/>            <strong class="mr ir">var </strong>node  = <strong class="mr ir">root<br/>            while </strong>(index &lt; word.<strong class="mr ir">length</strong>){<br/>                <strong class="mr ir">val </strong>char = word.<em class="kz">elementAt</em>(index)<br/>                <strong class="mr ir">if</strong>(node.<strong class="mr ir">map</strong>.containsKey(char)){<br/>                    node = node.<strong class="mr ir">map</strong>[char]!!<br/>                    index++<br/>                }<br/>                <strong class="mr ir">else</strong>{<br/>                    <strong class="mr ir">return false<br/>                </strong>}<br/>            }<br/><br/>            <strong class="mr ir">if</strong>(node.<strong class="mr ir">isWorldEnd</strong>){<br/>                <strong class="mr ir">return true<br/>            </strong>}<br/>        }<br/>        <strong class="mr ir">return false<br/>    </strong>}<br/><br/>    <strong class="mr ir">private fun </strong>searchPrefix(word: String) : Boolean{<br/>        <strong class="mr ir">if</strong>(word.<em class="kz">isNotEmpty</em>()){<br/>            <strong class="mr ir">var </strong>index = 0<br/>            <strong class="mr ir">var </strong>node  = <strong class="mr ir">root<br/>            while </strong>(index &lt; word.<strong class="mr ir">length</strong>){<br/>                <strong class="mr ir">val </strong>char = word.<em class="kz">elementAt</em>(index)<br/>                <strong class="mr ir">if</strong>(node.<strong class="mr ir">map</strong>.containsKey(char)){<br/>                    node = node.<strong class="mr ir">map</strong>[char]!!<br/>                    index++<br/>                }<br/>                <strong class="mr ir">else</strong>{<br/>                    <strong class="mr ir">return false<br/>                </strong>}<br/>            }<br/>        }<br/>        <strong class="mr ir">return true<br/>    </strong>}<br/><br/>    <em class="kz">/** Returns if there is any word in the trie that starts with the given prefix. */<br/>    </em><strong class="mr ir">fun </strong>startsWith(prefix: String): Boolean {<br/>        <strong class="mr ir">return </strong>searchPrefix(prefix)<br/>    }<br/><br/>  }</span></pre><p id="fbfb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">感谢你阅读这篇文章。</p></div></div>    
</body>
</html>