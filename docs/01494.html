<html>
<head>
<title>JavaScript Tips — Parsing URLs, Reading Files, and More</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript技巧—解析URL、读取文件等等</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/javascript-tips-parsing-urls-reading-files-and-more-ee9f70b14e25?source=collection_archive---------28-----------------------#2020-07-04">https://blog.devgenius.io/javascript-tips-parsing-urls-reading-files-and-more-ee9f70b14e25?source=collection_archive---------28-----------------------#2020-07-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/500c1e1e18cf933ca4f91101af98652e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Gu5CzHYi5zBx9Opt"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@dhillssr?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">德韦恩·希尔斯</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="9bbc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像任何类型的应用程序一样，当我们编写JavaScript应用程序时，有一些困难的问题需要解决。</p><p id="96a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究一些常见JavaScript问题的解决方案。</p><h1 id="ed28" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">将URL解析为主机名和路径</h1><p id="f14b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">为了将URL字符串解析成它的主机名和路径，我们可以使用<code class="fe me mf mg mh b">URL</code>构造函数。</p><p id="03f4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="3709" class="mq lc iq mh b gy mr ms l mt mu">new URL("http://example.com/foo/bar")</span></pre><p id="4265" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后返回一个具有<code class="fe me mf mg mh b">hostname</code>和<code class="fe me mf mg mh b">pathname</code>属性的对象。</p><p id="e6f8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">hostname</code>是主机名。</p><p id="311a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">pathname</code>是路径名。</p><h1 id="ef49" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">将JavaScript日期格式化为yyyy-mm-dd</h1><p id="039d" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用一些日期方法将日期格式化为yyyy-mm-dd格式的字符串。</p><p id="59d6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="2aae" class="mq lc iq mh b gy mr ms l mt mu">const d = new Date(date);<br/>let month = (d.getMonth() + 1).toString();<br/>let day = (d.getDate()).toString();<br/>const year = d.getFullYear();</span><span id="4b6a" class="mq lc iq mh b gy mv ms l mt mu">if (month.length &lt; 2) {<br/>  month = `0${month}`;<br/>}</span><span id="c29a" class="mq lc iq mh b gy mv ms l mt mu">if (day.length &lt; 2)  {<br/>  day = `0${day}`;<br/>}</span><span id="8f08" class="mq lc iq mh b gy mv ms l mt mu">const formattedDate = [year, month, day].join('-');</span></pre><p id="f8ce" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们从<code class="fe me mf mg mh b">Date</code>构造函数中创建一个日期对象。</p><p id="cb77" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们调用<code class="fe me mf mg mh b">getMonth</code>来获取月份。</p><p id="1bde" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们必须加1，因为月份是从零开始的。</p><p id="94a4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用<code class="fe me mf mg mh b">getDate</code>得到一个月中的某一天。</p><p id="af9b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，我们用<code class="fe me mf mg mh b">getFullTear</code>得到4位数的年份。</p><p id="2cc6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果月或日是一位数，那么我们在它前面加一个零。</p><p id="67b5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们用<code class="fe me mf mg mh b">'-'</code>把年、月、日连在一起。</p><p id="2871" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一个更简单的解决方案是使用<code class="fe me mf mg mh b">toISOString</code>方法。</p><p id="60fd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="28fe" class="mq lc iq mh b gy mr ms l mt mu">const formattedDate = new Date().toISOString().slice(0, 10);</span></pre><p id="9ff9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将日期转换为字符串，并提取年、月和日部分。</p><h1 id="ba0b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">检查元素在DOM中是否可见</h1><p id="d7ab" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用几种方法检查一个元素在DOM中是否可见。</p><p id="788b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一种方法是使用<code class="fe me mf mg mh b">offsetParent</code>属性来检查可见性。</p><p id="8672" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">每当通过display style属性隐藏该属性或其父属性时，该属性将返回<code class="fe me mf mg mh b">null</code>。</p><p id="0c2f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果页面上没有固定元素，就会出现这种情况。</p><p id="1b98" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果页面上没有固定的元素，那么我们写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="9bcf" class="mq lc iq mh b gy mr ms l mt mu">el.offsetParent === null</span></pre><p id="162c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">其中<code class="fe me mf mg mh b">el</code>是要检查可见性的元素，用于检查可见性。</p><p id="328e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也可以用一个元素作为它的参数来调用<code class="fe me mf mg mh b">getComputedStyle</code>以获得它计算的<code class="fe me mf mg mh b">display</code>样式。</p><p id="ee23" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="991c" class="mq lc iq mh b gy mr ms l mt mu">cpnst style = window.getComputedStyle(el);<br/>const isInvisibie = style.display === 'none';</span></pre><p id="4f97" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们检查<code class="fe me mf mg mh b">style.display</code>属性是否为<code class="fe me mf mg mh b">'none'</code>。</p><h1 id="bf63" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">将字符串转换为字符数组</h1><p id="c6c8" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用<code class="fe me mf mg mh b">split</code>方法将一个字符串分割成一个字符数组。</p><p id="4da1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="1c18" class="mq lc iq mh b gy mr ms l mt mu">const output = "foo bar".split('');</span></pre><p id="805e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="62a4" class="mq lc iq mh b gy mr ms l mt mu">["f", "o", "o", " ", "b", "a", "r"]</span></pre><p id="cd67" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">作为<code class="fe me mf mg mh b">output</code>的值。</p><h1 id="0766" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">获取对象键的数组</h1><p id="fba7" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">要获得一个对象键的数组，我们可以使用<code class="fe me mf mg mh b">Object.keys</code>方法。</p><p id="5679" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="6f16" class="mq lc iq mh b gy mr ms l mt mu">const obj = {<br/>  foo: 1,<br/>  bar: 2<br/>};</span><span id="21d1" class="mq lc iq mh b gy mv ms l mt mu">const keys = Object.keys(obj);</span></pre><p id="a336" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么我们<code class="fe me mf mg mh b">keys</code>就是<code class="fe me mf mg mh b">['foo', 'bar']</code>。</p><h1 id="5267" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">用{}或新对象()创建一个空对象</h1><p id="d4bd" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">使用<code class="fe me mf mg mh b">new Object()</code>没有任何好处。</p><p id="67e4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并且使用<code class="fe me mf mg mh b">{}</code>更加简洁易读。</p><p id="d868" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们应该使用object literal语法而不是<code class="fe me mf mg mh b">Object</code>构造函数。</p><h1 id="41ae" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">读取本地文本文件</h1><p id="1fa5" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用客户端JavaScript读取本地文本文件。</p><p id="d5a6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为此，我们可以使用<code class="fe me mf mg mh b">FileReader</code>构造函数来完成。</p><p id="a62f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以让用户选择一个文件并阅读所选的文本文件。</p><p id="425f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以添加一个文件输入:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="1df7" class="mq lc iq mh b gy mr ms l mt mu">&lt;input type='file' accept='text/plain' onchange='openFile(event)'&gt;</span></pre><p id="4412" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="b4bd" class="mq lc iq mh b gy mr ms l mt mu">const openFile = (event) =&gt; {<br/>  const input = event.target;<br/>  const reader = new FileReader();<br/>  reader.onload = () =&gt; {<br/>    const text = reader.result;<br/>    consr node = document.getElementById('output');<br/>    node.innerText = text;<br/>    console.log(reader.result);<br/>  };<br/>  reader.readAsText(input.files[0]);<br/>};</span></pre><p id="559d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们创建了接受一个<code class="fe me mf mg mh b">event</code>参数的<code class="fe me mf mg mh b">openFile</code>函数。</p><p id="e679" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用<code class="fe me mf mg mh b">event.target</code>得到输入元素。</p><p id="eba1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们用<code class="fe me mf mg mh b">files[0]</code>得到选中的文件。</p><p id="32e0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们创建一个<code class="fe me mf mg mh b">FileReader</code>实例，并使用文件作为参数对其调用<code class="fe me mf mg mh b">readAsText</code>。</p><p id="ce4c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后<code class="fe me mf mg mh b">onload</code>回调将运行，我们用<code class="fe me mf mg mh b">reader.result</code>得到结果。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/b10c6a0f7adde4c1767c2cc3f4983651.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dMbV4ssQoHlbxB1E"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@darvalife?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">达里奥·巴伦苏埃拉</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><h1 id="7d7f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="30b5" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用<code class="fe me mf mg mh b">URL</code>构造函数将URL解析成各个部分。</p><p id="dfcb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">FileReader</code>让我们读取文本文件。</p><p id="d711" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要在没有库的情况下格式化日期，我们可以使用<code class="fe me mf mg mh b">toISOString</code>或方法来获取日期部分。</p><p id="8e0d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有几种方法可以检查元素是否可见。</p></div></div>    
</body>
</html>