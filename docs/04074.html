<html>
<head>
<title>How to Save Hundreds of Hours on Lambda Debugging?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在 Lambda 调试上节省几百个小时？</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-to-save-hundreds-of-hours-on-lambda-debugging-13edf5b2535?source=collection_archive---------3-----------------------#2021-01-22">https://blog.devgenius.io/how-to-save-hundreds-of-hours-on-lambda-debugging-13edf5b2535?source=collection_archive---------3-----------------------#2021-01-22</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="db35" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">尽管从基础设施的角度来看，AWS Lambda 是一个福音，但是在使用它的时候，我们仍然不得不面对软件开发中最不想要的部分:调试。为了解决问题，我们需要知道导致问题的原因。在 AWS Lambda 中，这可能是一个诅咒。但是我们有一个解决方案可以为您节省几十个小时的时间。</p><p id="8e32" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">TL；DR: Dashbird 提供了一个快捷方式来实现本文中的所有内容。点击此处<a class="ae ki" href="https://dashbird.io/docs/application-guide/lambda-functions/" rel="noopener ugc nofollow" target="_blank">了解更多</a>或<a class="ae ki" href="https://dashbird.io/register" rel="noopener ugc nofollow" target="_blank">立即免费注册</a>，在几秒钟内开始调试您的 Lambdas，而不是几个小时。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/d6fba1d25de7d3acfe596240d6a3905b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*wANc_WTIRBIWMZpK.png"/></div></div></figure><h1 id="6672" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">AWS Lambda 和 CloudWatch 日志剖析</h1><p id="0612" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">AWS Lambda 本质上是一个托管的容器服务。所有工作都在后台进行——我们不需要配置或管理容器本身，甚至不需要它们背后的基础设施。但在现实中，有无数的微容器运行在传统服务器之上。</p><p id="7e2d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">每当有人请求一个 Lambda 函数时，AWS 将使用一个微容器来运行我们的代码，获得响应并将其发送回请求者。在此过程中，我们的应用程序(或我们使用的任何第三方库)可以记录任何内容，从信息性消息到反对警告，再到错误和异常堆栈跟踪。这些木头都放在哪里？</p><p id="d69a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在他们推出 Lambda 的时候，AWS 已经有了日志服务，我们称之为 CloudWatch。因此，他们所做的是将所有这些文本数据(日志)从我们在 Lambda 中运行的应用程序传输到 CloudWatch。每个 Lambda 函数都有其专用的“日志组”。可以把它看作是 Lambda 日志的“存储库”。</p><p id="1918" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在一个“日志组”(或单个 Lambda 的日志报告)中，CloudWatch 创建多个“日志流”。可以把它想象成一个实际写入日志的文本文件。Lambda 每次创建一个新的微容器，CloudWatch 中也会创建一个新的日志流。不管该容器服务 1 个还是 100 个请求，都只有一个日志流，这意味着:一个流可能包含来自多个调用的日志。</p><p id="0087" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果多个请求同时到来(也称为并发)，AWS 将旋转多个容器，为同一个 Lambda 创建多个日志流。最重要的是，每个容器可能会存在几分钟，甚至几个小时，而且它可能会为成千上万个请求提供服务，这取决于 Lambda 函数的使用频率。</p><h1 id="c4c9" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">调试的挑战</h1><p id="cd6b" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">现在假设您注意到您的应用程序失败了，您需要知道是什么导致了这个问题，以便计划一个修复方案。当然，首先要看的是日志。但是现在你去 AWS CloudWatch，你知道错误发生在今天，在早上 8:00 到 8:05 之间的某个时间。很简单，对吧？只需要 5 分钟的时间去寻找。好吧，这里有一些问题可能会让你浪费很多非生产性的时间。</p><p id="f935" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">首先，同一时间段可能有多个日志流，因此您需要浏览所有日志流以找到特定的失败请求。似乎这还不够麻烦，在每个日志流中，您可能需要浏览数十、数百甚至数千个日志才能找到您要找的日志。</p><p id="7527" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">请记住，日志流不一定是在请求到来时创建的。包含失败请求日志的流可能是在几个小时前创建的，并且它将包含上午 8:00 之前的日志。</p><p id="8f87" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">光是在 CloudWatch 中查找日志就可能会花费你很多时间。你甚至还没有开始解决问题本身！想象一下，你的团队中有人问你修复 bug 的进展如何，你花了 30 分钟，也许一个小时，仍然不知道是什么导致了这个问题？有人可能会说这对于专业开发人员来说是不可接受的。</p><h1 id="a6c5" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">解决办法</h1><p id="a52a" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">如上所述，有一种方法可以解决所有这些问题，并让您的日志更快。</p><p id="c1c0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Lambda 函数的每次新调用都会产生一个初始对数线。这是默认记录的，你不能控制它。无论您的运行时是什么(Python、Node、Java 等)，日志看起来都是一样的。方便的是，这个初始对数线看起来总是这样:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi ly"><img src="../Images/b42866346345ea368d7c293a8ec76e1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/0*KFrlwDCprc3ihT6m.png"/></div></figure><p id="c5ee" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">“START RequestId”总是相同的，每次调用后都有不同的散列。当调用终止时，不管调用是成功还是出错，都会生成另一个默认的日志行，如下所示:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi lz"><img src="../Images/daff8232d53c55b534df76e76212a9bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:730/format:webp/0*dFva9frT5MpvzrQL.png"/></div></figure><p id="ae3a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，现在我们有办法扫描任意数量的 CloudWatch 日志，并确定调用的开始和结束位置。酷毙了。</p><p id="21bc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，另一个有用的知识是:CloudWatch 日志<a class="ae ki" href="https://aws.amazon.com/pt/about-aws/whats-new/2015/06/amazon-cloudwatch-logs-subscriptions/" rel="noopener ugc nofollow" target="_blank">支持订阅</a>。这意味着你可以给你的日志订阅<a class="ae ki" href="https://aws.amazon.com/kinesis/" rel="noopener ugc nofollow" target="_blank"> AWS Kinesis </a>，这样它就可以一直监听你的 Lambdas 输出的所有内容。然后你可以配置一个特殊的 Lambda(称之为“日志解析器”)，当 Kinesis 接收到新的日志数据时，它会被自动调用。Log Parser 将获取日志并将它们分成调用(使用上面的开始/结束符号来识别断点)。最后，与一个且仅一个调用相关的每条日志都可以单独保存在数据库中(例如<a class="ae ki" href="https://aws.amazon.com/cloudsearch/" rel="noopener ugc nofollow" target="_blank"> CloudSearch </a>),以供以后搜索和调试。</p><p id="9a6b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">嘭！</strong>现在您已经通过调用个性化了您的日志。再也不用为了得到一个调用数据而在成千上万的日志中进行无效的筛选。下面是这种概述实现的示意图:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi ma"><img src="../Images/b9d62afc5106b2636790675b27ec6920.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yobdYsAKFHSTglp_xhR_sQ.png"/></div></div></figure></div><div class="ab cl mb mc hr md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ig ih ii ij ik"><h1 id="7a45" class="kv kw in bd kx ky mi la lb lc mj le lf lg mk li lj lk ml lm ln lo mm lq lr ls bi translated">在一分钟内实施该解决方案</h1><p id="1957" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">我知道，设置并运行该解决方案可能需要几个小时(也许几天)，并且需要一段时间来维护并确保其平稳运行。</p><p id="08a8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因为我们知道您还有许多其他更重要的事情要做，所以我们将该解决方案作为托管服务来实施，并增加了从异常检测到事件管理和警报等一系列功能。我们称它为 Dashbird，成千上万的开发人员已经在使用并喜欢上了它。</p><p id="6780" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">欢迎您免费使用<a class="ae ki" href="https://dashbird.io/features" rel="noopener ugc nofollow" target="_blank"/>，想用多久就用多久🙂</p><ul class=""><li id="3153" class="mn mo in jm b jn jo jr js jv mp jz mq kd mr kh ms mt mu mv bi translated">没有代码更改</li><li id="87f5" class="mn mo in jm b jn mw jr mx jv my jz mz kd na kh ms mt mu mv bi translated">不需要信用卡</li><li id="9299" class="mn mo in jm b jn mw jr mx jv my jz mz kd na kh ms mt mu mv bi translated">简单的两分钟设置</li><li id="b4ba" class="mn mo in jm b jn mw jr mx jv my jz mz kd na kh ms mt mu mv bi translated">获得所有高级功能</li><li id="c899" class="mn mo in jm b jn mw jr mx jv my jz mz kd na kh ms mt mu mv bi translated">开始调试，接收自动警报，并立即处理您的数据</li></ul></div></div>    
</body>
</html>