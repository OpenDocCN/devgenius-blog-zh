<html>
<head>
<title>Draw the Labeled Range Slider</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">绘制带标签的范围滑块</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/draw-the-labeled-range-slider-3eb96e748e88?source=collection_archive---------7-----------------------#2022-08-08">https://blog.devgenius.io/draw-the-labeled-range-slider-3eb96e748e88?source=collection_archive---------7-----------------------#2022-08-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/6b226df9a019a5febd060040645dcec0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*TLmLbwAbfBgoF9gM"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">萨姆·哈达德在<a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="a257" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在本系列的第 4 部分中，让我们开始把我们到目前为止学到的所有东西和更多的东西放在一起，创建我们的标签范围滑块。</p><figure class="kz la lb lc gt jo gh gi paragraph-image"><div class="gh gi ky"><img src="../Images/57eab66f72a19ae2da5e8894c7aff9f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/0*72oxyYTNY9Uvgoh3.gif"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">最终结果应该是什么样子</figcaption></figure><h1 id="857e" class="ld le in bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">绘制用户界面</h1><p id="303f" class="pw-post-body-paragraph ka kb in kc b kd mb kf kg kh mc kj kk kl md kn ko kp me kr ks kt mf kv kw kx ig bi translated">开始之前，我们首先需要分解我们的 Composable 中涉及的不同元素，以及如何绘制它们。</p><p id="dc87" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">正如我们在下图中看到的，我们可以将带标签的范围滑块分解为 5 个元素。</p><figure class="kz la lb lc gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mg"><img src="../Images/510f24e1ebd383af6c11bb970457c18f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ISfjZja8dCUItV7f.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">单个元素的分解</figcaption></figure><p id="62b6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们有</p><ul class=""><li id="0343" class="mh mi in kc b kd ke kh ki kl mj kp mk kt ml kx mm mn mo mp bi translated">滑动条上方的标签，指示可用和选定的值。颜色和字体风格应反映我们选择的范围(<em class="mq">红色</em>)</li><li id="d51b" class="mh mi in kc b kd mr kh ms kl mt kp mu kt mv kx mm mn mo mp bi translated">背景中的圆形条，引导我们的滑块(<em class="mq">紫色</em>)</li><li id="f0f5" class="mh mi in kc b kd mr kh ms kl mt kp mu kt mv kx mm mn mo mp bi translated">步进标记，指示我们的条上所有可用的值(<em class="mq">绿色</em>)</li><li id="e193" class="mh mi in kc b kd mr kh ms kl mt kp mu kt mv kx mm mn mo mp bi translated">在我们的条形图上显示我们选择的范围(<em class="mq">蓝色</em>)</li><li id="30ab" class="mh mi in kc b kd mr kh ms kl mt kp mu kt mv kx mm mn mo mp bi translated">最后是我们的滑块手柄，我们希望拖动它穿过滚动条来选择我们的范围(<em class="mq">橙色</em>)</li></ul><h1 id="f813" class="ld le in bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">圆形背景条(紫色)</h1><p id="d918" class="pw-post-body-paragraph ka kb in kc b kd mb kf kg kh mc kj kk kl md kn ko kp me kr ks kt mf kv kw kx ig bi translated">开始和设置我们的可组合组件的最简单的元素是背景中引导我们的滑块的灰色条。在开始绘制条形图之前，我们首先需要做一些准备工作，比如计算宽度和高度。</p><p id="5e37" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对于宽度，我们希望我们的栏填充可用空间的整个宽度，并为滑块添加一些填充，但我们将在稍后讨论。<br/>为了获得我们的可组合的大小，我们可以使用<strong class="kc io"> Modifier.onSizeChanged </strong>并将该值存储在一个状态中。根据该值，我们可以确定矩形的宽度。对于高度，我们保持简单，让调用者配置，但提供一个合理的默认值 12 Dp。<br/>我们还为条形颜色和圆角大小添加了一个参数。</p><pre class="kz la lb lc gt mw mx my mz aw na bi"><span id="d45f" class="nb le in mx b gy nc nd l ne nf">@Composable<br/>fun LabeledRangeSlider(<br/>    modifier: Modifier = Modifier,<br/>    barHeight: Dp = 12.dp,<br/>    barColor: Color = Color.LightGray,<br/>    barCornerRadius: Dp = 6.dp<br/>) {</span><span id="308c" class="nb le in mx b gy ng nd l ne nf">    var composableSize by remember { mutableStateOf(IntSize(0, 0)) }<br/>    val height = barHeight<br/>    val barWidth = remember(key1 = composableSize) { composableSize.width.toFloat() }<br/>    val barXStart = 0f<br/>    val barYStart = 0f</span><span id="93a9" class="nb le in mx b gy ng nd l ne nf">    Canvas(<br/>        modifier = modifier<br/>            .height(height)<br/>            .onSizeChanged {<br/>                composableSize = it<br/>            }<br/>    ) {<br/>        drawRoundRect(<br/>            color = barColor,<br/>            topLeft = Offset(barXStart, barYStart),<br/>            size = Size(barWidth, barHeight.toPx()),<br/>            cornerRadius = CornerRadius(barCornerRadius.toPx(), barCornerRadius.toPx())<br/>        )<br/>    }<br/>}</span></pre><p id="fa09" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们已经准备了一些变量，如<strong class="kc io">高度</strong>、<strong class="kc io">条宽</strong>、<strong class="kc io">条宽</strong>和<strong class="kc io">重心</strong>。我们稍后将需要它们来计算更好的定位。我们将<strong class="kc io">高度</strong>放入画布的<strong class="kc io">修饰符.高度</strong>中，我们使用允许传递一个<strong class="kc io">修饰符</strong>的最佳实践，因此宽度可以由调用者决定。</p><blockquote class="nh ni nj"><p id="09dd" class="ka kb mq kc b kd ke kf kg kh ki kj kk nk km kn ko nl kq kr ks nm ku kv kw kx ig bi translated"><em class="in">有趣的是:我们让</em> <strong class="kc io"> <em class="in">条宽</em> </strong> <em class="in">重算依赖于可组合的大小。既然只要可组合的大小不变我们就可以只记</em><strong class="kc io"><em class="in"/></strong><em class="in"/><strong class="kc io"><em class="in">bar width</em></strong><em class="in">。</em></p></blockquote><p id="44f6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">到目前为止，结果如下所示</p><figure class="kz la lb lc gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mg"><img src="../Images/b748fa727c4b39baa2f36aa2fae371e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*uZPrmBx3JKq_0k9G.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">滑块的背景条</figcaption></figure><p id="9bbb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们还可以从这个小片段中看到，我们已经需要一些配置，并且需要使用<strong class="kc io"> toPx </strong>将 Dp 转换为像素进行绘制。</p><p id="e752" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们可以做的是，像我们在<a class="ae jz" href="https://dev.to/lex_fury/context-receivers-39p5" rel="noopener ugc nofollow" target="_blank">第 3 部分</a>中看到的那样，引入一个配置数据类。</p><pre class="kz la lb lc gt mw mx my mz aw na bi"><span id="e4ec" class="nb le in mx b gy nc nd l ne nf">data class SliderConfig(<br/>    val barHeight: Dp = 12.dp,<br/>    val barColor: Color = Color.LightGray,<br/>    val barCornerRadius: Dp = 6.dp<br/>) {<br/>    context(Density)<br/>    val barHeightPx: Float<br/>        get() = barHeight.toPx()</span><span id="f969" class="nb le in mx b gy ng nd l ne nf">    context(Density)<br/>    val barCornerRadiusPx<br/>        get() = barCornerRadius.toPx()<br/>}</span></pre><p id="a980" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们将配置移到了<strong class="kc io"> SliderConfig </strong>中，这样我们就可以使用上下文接收器将像素转换直接封装到这个类中。这次我们使用<strong class="kc io">密度</strong>作为<strong class="kc io">上下文</strong>，因为它是由<strong class="kc io">绘图范围</strong>实现的，但是可以更通用。为什么？我们一会儿就会看到:-)。</p><h1 id="5357" class="ld le in bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">滑块手柄(橙色)</h1><p id="989b" class="pw-post-body-paragraph ka kb in kc b kd mb kf kg kh mc kj kk kl md kn ko kp me kr ks kt mf kv kw kx ig bi translated">接下来让我们添加滑块手柄。正如我们在上面的 GIF 中看到的，手柄周围有一个阴影，它也对触摸做出反应，增加阴影的大小。没有阴影，我们可以简单地调用<strong class="kc io"> drawCircle </strong>就完成了。不幸的是，我们无法用画布的常规<strong class="kc io"> drawCircle </strong>功能轻松应用阴影效果。但幸运的是，我们可以使用<strong class="kc io"> drawIntoCanvas </strong>及其<strong class="kc io"> drawCircle </strong>功能。它允许我们提供一个<strong class="kc io">绘制</strong>参数，用它我们可以实现我们的阴影。</p><pre class="kz la lb lc gt mw mx my mz aw na bi"><span id="8b58" class="nb le in mx b gy nc nd l ne nf">private fun DrawScope.drawCircleWithShadow(<br/>    position: Offset,<br/>    touched: Boolean,<br/>    sliderConfig: SliderConfig<br/>) {<br/>    val touchAddition = if (touched) {<br/>        sliderConfig.touchCircleShadowTouchedSizeAdditionPx<br/>    } else {<br/>        0f<br/>    }</span><span id="94a8" class="nb le in mx b gy ng nd l ne nf">    drawIntoCanvas {<br/>        val paint = androidx.compose.ui.graphics.Paint()<br/>        val frameworkPaint = paint.asFrameworkPaint()<br/>        frameworkPaint.color = sliderConfig.touchCircleColor.toArgb()<br/>        frameworkPaint.setShadowLayer(<br/>            sliderConfig.touchCircleShadowSizePx + touchAddition,<br/>            0f,<br/>            0f,<br/>            Color.DarkGray.toArgb()<br/>        )<br/>        it.drawCircle(<br/>            position,<br/>            sliderConfig.touchCircleRadiusPx,<br/>            paint<br/>        )<br/>    }<br/>}</span></pre><p id="b5ae" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">正如我们所见，我们创建了一个<strong class="kc io"> Paint </strong>对象，并将其转换为<strong class="kc io"> NativePaint </strong>。这给了我们访问<strong class="kc io"> setShadowLayer </strong>的权限。我们给阴影一个尺寸，根据这个尺寸，圆圈是否被触摸，然后用这个尺寸画出我们的圆圈。<br/>我们还在我们的<strong class="kc io"> SliderConfig </strong>类中增加了一点配置。</p><p id="0032" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">准备好 circle 函数后，我们需要更新棒线的计算。当句柄被添加到栏的末端时，我们不希望它与我们的可组合对象重叠，或者更糟的是脱离屏幕。因此，我们需要添加一些填充到我们的酒吧。</p><p id="7494" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为此，我们现在需要访问我们配置的像素值，正如我们在上面看到的，我们需要在<strong class="kc io">密度</strong>对象的<strong class="kc io">范围</strong>内。解决这个问题的一个方法是将计算移到我们画布的<strong class="kc io"> onDraw </strong> lambda 中。这将意味着我们每次绘制时都要重新计算这些值，但是它们只需要在<strong class="kc io">密度</strong>或我们的可组合大小发生变化时更新。<br/>我们能做的是在尺寸和<strong class="kc io">密度</strong>上创建一个小的扩展函数。</p><pre class="kz la lb lc gt mw mx my mz aw na bi"><span id="5699" class="nb le in mx b gy nc nd l ne nf">@Composable<br/>private fun &lt;T&gt; Pair&lt;IntSize, Density&gt;.derive(additionalKey: Any? = null, block: Density.() -&gt; T): T =<br/>    remember(key1 = first, key2 = additionalKey) {<br/>        second.block()<br/>    }</span></pre><p id="871d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">有了它，我们可以这样写我们的尺寸计算:</p><pre class="kz la lb lc gt mw mx my mz aw na bi"><span id="b7eb" class="nb le in mx b gy nc nd l ne nf">val currentDensity = LocalDensity.current<br/>val sizeAndDensity = composableSize to currentDensity</span><span id="d4d3" class="nb le in mx b gy ng nd l ne nf">val barYCenter = sizeAndDensity.derive { (height / 2).toPx() }<br/>val barXStart = sizeAndDensity.derive { sliderConfig.touchCircleRadiusPx }<br/>val barYStart = sizeAndDensity.derive { barYCenter - sliderConfig.barHeightPx / 2f }<br/>val barWidth = sizeAndDensity.derive { composableSize.width - 2 * barXStart }</span></pre><p id="259a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里重要的一点是，我们总是可以在一个可组合的对象中用<strong class="kc io"> LocalDensity.current </strong>获得当前的<strong class="kc io">密度</strong>。</p><p id="ab5d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在让我们把手柄放在酒吧的起点和终点，然后画出来。</p><pre class="kz la lb lc gt mw mx my mz aw na bi"><span id="2089" class="nb le in mx b gy nc nd l ne nf">val leftCirclePosition = remember(key1 = composableSize) {<br/>    Offset(barXStart, barYCenter)<br/>}<br/>val rightCirclePosition = remember(key1 = composableSize) {<br/>    Offset(barXStart + barWidth, barYCenter)<br/>}</span><span id="d6a6" class="nb le in mx b gy ng nd l ne nf">...<br/>// in our Canvas<br/>        drawCircleWithShadow(<br/>            leftCirclePosition,<br/>            false,<br/>            sliderConfig<br/>        )</span><span id="a931" class="nb le in mx b gy ng nd l ne nf">        drawCircleWithShadow(<br/>            rightCirclePosition,<br/>            false,<br/>            sliderConfig<br/>        )</span></pre><p id="1f51" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">到目前为止的结果如下:</p><figure class="kz la lb lc gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mg"><img src="../Images/f01ce0261faa2d6cbeed20991ed9a6ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*6xgCM0SFx_grDOgt.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">背景条和触摸手柄</figcaption></figure><h1 id="bb2f" class="ld le in bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">标签和步骤标记(红色和绿色)</h1><p id="094a" class="pw-post-body-paragraph ka kb in kc b kd mb kf kg kh mc kj kk kl md kn ko kp me kr ks kt mf kv kw kx ig bi translated">接下来，我们要在条形上方绘制标签以及步骤标记。将它们放在一起看是有意义的，因为标签及其步骤标记应该正确对齐。我们已经知道在 y 轴上定位我们的标签和步骤标记。标签应该在我们的可组合组件的顶部，步骤标记应该与我们的栏的中间对齐。我们仍然需要的是单步在 x 轴上的定位。为此，我们首先允许将步骤传递到我们的 Composable 中，并创建一个小函数来计算 x 坐标。</p><pre class="kz la lb lc gt mw mx my mz aw na bi"><span id="a146" class="nb le in mx b gy nc nd l ne nf">private fun calculateStepCoordinatesAndSpacing(<br/>    numberOfSteps: Int,<br/>    barXStart: Float,<br/>    barWidth: Float,<br/>    stepMarkerRadius: Float,<br/>): Pair&lt;FloatArray, Float&gt; {<br/>    val stepOffset = barXStart + stepMarkerRadius<br/>    val stepSpacing = (barWidth - 2 * stepMarkerRadius) / (numberOfSteps - 1)</span><span id="35b6" class="nb le in mx b gy ng nd l ne nf">    val stepXCoordinates = generateSequence(stepOffset) { it + stepSpacing }<br/>        .take(numberOfSteps)<br/>        .toList()</span><span id="6e47" class="nb le in mx b gy ng nd l ne nf">    return stepXCoordinates.toFloatArray() to stepSpacing<br/>}</span></pre><p id="b887" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们计算开始与我们的酒吧的开始对齐，并且根据我们有多少步骤，我们计算他们之间的间距。</p><p id="051d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因为这个计算不仅依赖于可组合的大小和<strong class="kc io">密度</strong>，而且依赖于步骤的数量，我们使用我们的<strong class="kc io">派生</strong>函数来执行它。</p><pre class="kz la lb lc gt mw mx my mz aw na bi"><span id="cbf1" class="nb le in mx b gy nc nd l ne nf">val (stepXCoordinates, stepSpacing) = sizeAndDensity.derive(steps) {<br/>        calculateStepCoordinatesAndSpacing(<br/>            numberOfSteps = steps.size,<br/>            barXStart = barXStart,<br/>            barWidth = barWidth,<br/>            stepMarkerRadius = sliderConfig.stepMarkerRadiusPx<br/>        )<br/>    }</span></pre><p id="a36d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">此外，我们提供这些步骤作为<strong class="kc io">记住</strong>功能的第二把钥匙。这样，我们可以确保如果步骤发生了变化，我们可以更新我们的 Composable。</p><p id="a72b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">计算完位置后，我们可以画出标签和步标。</p><pre class="kz la lb lc gt mw mx my mz aw na bi"><span id="a397" class="nb le in mx b gy nc nd l ne nf">private fun &lt;T&gt; DrawScope.drawStepMarkersAndLabels(<br/>    steps: List&lt;T&gt;,<br/>    stepXCoordinates: FloatArray,<br/>    leftCirclePosition: Offset,<br/>    rightCirclePosition: Offset,<br/>    barYCenter: Float,<br/>    sliderConfig: SliderConfig<br/>) {<br/>    assert(steps.size == stepXCoordinates.size) { "Step value size and step coordinate size do not match. Value size: ${steps.size}, Coordinate size: ${stepXCoordinates.size}" }</span><span id="5660" class="nb le in mx b gy ng nd l ne nf">    steps.forEachIndexed { index, step -&gt;<br/>        val stepMarkerCenter = Offset(stepXCoordinates[index], barYCenter)</span><span id="0426" class="nb le in mx b gy ng nd l ne nf">        val isCurrentlySelectedByLeftCircle =<br/>            (leftCirclePosition.x &gt; (stepMarkerCenter.x - sliderConfig.stepMarkerRadiusPx / 2)) &amp;&amp;<br/>                    (leftCirclePosition.x &lt; (stepMarkerCenter.x + sliderConfig.stepMarkerRadiusPx / 2))<br/>        val isCurrentlySelectedByRightCircle =<br/>            (rightCirclePosition.x &gt; (stepMarkerCenter.x - sliderConfig.stepMarkerRadiusPx / 2)) &amp;&amp;<br/>                    (rightCirclePosition.x &lt; (stepMarkerCenter.x + sliderConfig.stepMarkerRadiusPx / 2))</span><span id="d8d1" class="nb le in mx b gy ng nd l ne nf">        val paint = when {<br/>            isCurrentlySelectedByLeftCircle || isCurrentlySelectedByRightCircle                     -&gt; sliderConfig.textSelectedPaint<br/>            stepMarkerCenter.x &lt; leftCirclePosition.x || stepMarkerCenter.x &gt; rightCirclePosition.x -&gt; sliderConfig.textOutOfRangePaint<br/>            else                                                                                    -&gt; sliderConfig.textInRangePaint<br/>        }</span><span id="b313" class="nb le in mx b gy ng nd l ne nf">        drawCircle(<br/>            color = sliderConfig.stepMarkerColor,<br/>            radius = sliderConfig.stepMarkerRadiusPx,<br/>            alpha = .1f,<br/>            center = stepMarkerCenter<br/>        )</span><span id="480c" class="nb le in mx b gy ng nd l ne nf">        drawIntoCanvas {<br/>            val stepText = step.toString().let { text -&gt;<br/>                if (text.length &gt; 3) {<br/>                    text.substring(0, 2)<br/>                } else {<br/>                    text<br/>                }<br/>            }<br/>            it.nativeCanvas.drawText(<br/>                stepText,<br/>                stepMarkerCenter.x - (stepText.length * sliderConfig.textSizePx) / 3,<br/>                sliderConfig.textSizePx,<br/>                paint<br/>            )<br/>        }<br/>    }<br/>}</span></pre><p id="b293" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们传入计算出的 x 轴位置和步骤来迭代它们，并相应地定位步骤标记和标签。正如你在<strong class="kc io"> drawIntoCanvas </strong>函数中看到的，我们正在访问本地画布来绘制我们的标签，因为正常的画布没有绘制文本的功能。<br/>根据两个手柄的位置，我们选择不同的颜料，这样标签也能反映滑块中所选的范围。</p><p id="b150" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们在我们的<strong class="kc io"> SliderConfig </strong>中添加了更多的属性来控制颜色、文本大小、文本偏移量和步骤标记的颜色。有了这些额外的尺寸，我们就可以更新我们的组件的高度计算。</p><pre class="kz la lb lc gt mw mx my mz aw na bi"><span id="862b" class="nb le in mx b gy nc nd l ne nf">val height = remember(key1 = sliderConfig) { sliderConfig.touchCircleRadius * 2 + sliderConfig.textSize.value.dp + sliderConfig.textOffset }</span></pre><p id="fbfa" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">以及我们定位变量的计算。</p><pre class="kz la lb lc gt mw mx my mz aw na bi"><span id="0cda" class="nb le in mx b gy nc nd l ne nf">val barYCenter = sizeAndDensity.derive { composableSize.height - sliderConfig.touchCircleRadiusPx }<br/>val barXStart = sizeAndDensity.derive { sliderConfig.touchCircleRadiusPx - sliderConfig.stepMarkerRadiusPx }<br/>val barYStart = sizeAndDensity.derive { barYCenter - sliderConfig.barHeightPx / 2 }<br/>val barWidth = sizeAndDensity.derive { composableSize.width - 2 * barXStart }<br/>val barCornerRadius = sizeAndDensity.derive { CornerRadius(sliderConfig.barCornerRadiusPx, sliderConfig.barCornerRadiusPx) }</span></pre><p id="3b52" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们将<strong class="kc io">drawtepmarkersandlabels</strong>放在画布中的<strong class="kc io"> drawRoundRect </strong>下方，但是在绘制标记的函数上方。结果看起来像这样:</p><figure class="kz la lb lc gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mg"><img src="../Images/233d235319977a1bc384183ca4dbb4ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Y6nIRwgWL7mPFrDW.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">添加了步骤标记和标签</figcaption></figure><h1 id="b921" class="ld le in bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">最终确定用户界面(蓝色)</h1><p id="9fac" class="pw-post-body-paragraph ka kb in kc b kd mb kf kg kh mc kj kk kl md kn ko kp me kr ks kt mf kv kw kx ig bi translated">正如我们所看到的，我们几乎完成了用户界面的绘制。仍然缺少的是在条上显示选定的范围，以及将我们的手柄正确地定位到当前选定的值。</p><p id="04dc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">首先我们定位把手。为此，我们希望我们的可组合组件能够从调用者那里接收这些值，因为我们不想管理这种状态。</p><pre class="kz la lb lc gt mw mx my mz aw na bi"><span id="72a3" class="nb le in mx b gy nc nd l ne nf">@Composable<br/>fun &lt;T : Number&gt; LabeledRangeSlider(<br/>    selectedLowerBound: T,<br/>    selectedUpperBound: T,<br/>    steps: List&lt;T&gt;,<br/>    modifier: Modifier = Modifier,<br/>    sliderConfig: SliderConfig = SliderConfig()<br/>) {<br/>...<br/>}</span></pre><p id="a833" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">有了这两个值，我们可以更新句柄的位置</p><pre class="kz la lb lc gt mw mx my mz aw na bi"><span id="e478" class="nb le in mx b gy nc nd l ne nf">var leftCirclePosition by remember(key1 = composableSize) {<br/>    val lowerBoundIdx = steps.indexOf(selectedLowerBound)<br/>    mutableStateOf(Offset(stepXCoordinates[lowerBoundIdx], barYCenter))<br/>}<br/>var rightCirclePosition by remember(key1 = composableSize) {<br/>    val upperBoundIdx = steps.indexOf(selectedUpperBound)<br/>    mutableStateOf(Offset(stepXCoordinates[upperBoundIdx], barYCenter))<br/>}</span></pre><figure class="kz la lb lc gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mg"><img src="../Images/07a10d5c4062f30500149ac1d5a0bea1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Zy0-pZFS_I5nMH5s.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">与步骤标记和标签对齐的触摸手柄</figcaption></figure><p id="48ed" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，所选步骤的标签以粗体字体正确绘制。</p><p id="d10d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">完成 UI 绘制的最后一步，就是在用<strong class="kc io"> drawRoundRect </strong>绘制条形背景的下方添加一个<strong class="kc io"> drawRect </strong>函数。</p><pre class="kz la lb lc gt mw mx my mz aw na bi"><span id="59a8" class="nb le in mx b gy nc nd l ne nf">drawRect(<br/>    color = sliderConfig.barColorInRange,<br/>    topLeft = Offset(leftCirclePosition.x, barYStart),<br/>    size = Size(rightCirclePosition.x - leftCirclePosition.x, sliderConfig.barHeightPx)<br/>)</span></pre><p id="89fb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了更好地查看结果，我们将<strong class="kc io"> selectedLowerBound </strong>和<strong class="kc io"> selectedUpperBound </strong>分别设置为 10 和 90。</p><figure class="kz la lb lc gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mg"><img src="../Images/80b27c49cb19e07cabebafcc3f090b4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ujfnUb_eXE9ds77g.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">添加了范围指示器的最终用户界面</figcaption></figure><p id="d7fe" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">看起来我们已经完成了标签范围滑块的绘制部分:-)。</p><h1 id="33f6" class="ld le in bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">让它互动</h1><p id="771a" class="pw-post-body-paragraph ka kb in kc b kd mb kf kg kh mc kj kk kl md kn ko kp me kr ks kt mf kv kw kx ig bi translated">我们正在绘制标签范围滑块所需的所有内容。现在我们需要让它互动。在写这篇文章的时候，我意识到它已经很长了，这就是为什么我决定把这部分分成另一篇文章。</p><p id="4f19" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><a class="ae jz" href="https://medium.com/@alex.frank84/make-the-labeled-range-slider-interactive-516bdf6e5c25" rel="noopener">让我们直接进入</a>或者访问<a class="ae jz" href="https://github.com/a-frank/labeled-range-slider" rel="noopener ugc nofollow" target="_blank"> GitHub </a>来探索完整的源代码。</p></div></div>    
</body>
</html>