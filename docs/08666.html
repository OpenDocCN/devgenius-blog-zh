<html>
<head>
<title>Infinite Data Structures: Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">无限数据结构:第 2 部分</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/infinite-data-structures-part-2-6662f143e3b9?source=collection_archive---------8-----------------------#2022-07-01">https://blog.devgenius.io/infinite-data-structures-part-2-6662f143e3b9?source=collection_archive---------8-----------------------#2022-07-01</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="7ddc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">scheme 中的更多无限列表</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/39b6dad0254c501734e782766ecb10d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/0*V4AF5ojpXI6gmqkh.gif"/></div></figure><p id="6991" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是我之前故事的延续，可以在这里找到<a class="ae kq" href="https://eric-breyer.medium.com/infinite-data-structures-9c193789dae6" rel="noopener"/>。</p><h1 id="b76c" class="kr ks in bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">流式联合收割机</h1><p id="212d" class="pw-post-body-paragraph jk jl in jm b jn lp jp jq jr lq jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh ig bi translated"><a class="ae kq" href="https://eric-breyer.medium.com/infinite-data-structures-9c193789dae6" rel="noopener">上次</a>我们用<code class="fe lu lv lw lx b">stream-add</code>做了几个有趣的流。我现在想介绍一个更通用的函数，它将让我们创建一些更有趣的流。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="3299" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个函数和<code class="fe lu lv lw lx b">stream-add</code>几乎完全一样，除了我们可以传递任何操作给它，而不仅仅是<code class="fe lu lv lw lx b">+</code>。<code class="fe lu lv lw lx b">stream-add</code>和<code class="fe lu lv lw lx b">(stream-combine +)</code>是等价的。</p><h2 id="8d9d" class="ma ks in bd kt mb mc dn kx md me dp lb jv mf mg lf jz mh mi lj kd mj mk ln ml bi translated">新力量</h2><p id="66ce" class="pw-post-body-paragraph jk jl in jm b jn lp jp jq jr lq jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh ig bi translated">我们可以用这种新的组合方式创造出一些有趣的新流。我们通过将两个流相加来创建自然数，因此我们可以通过将两个流相乘来创建 2 的幂。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="d02a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">就像自然数一样，让我们假设 2 的幂流<code class="fe lu lv lw lx b">powsOf2</code>存在。这个流是<code class="fe lu lv lw lx b">'(1 2 4 8 16 32 ...)</code>，当我们把这个流和<code class="fe lu lv lw lx b">'(2 2 2 2 2 2 ...)</code>相乘得到<code class="fe lu lv lw lx b">'(2 4 6 8 16 32 64 ...)</code>。所以像以前一样，<code class="fe lu lv lw lx b">((stream-combine *) twos powsOf2))</code>是我们列表的尾部，我们只需要用<code class="fe lu lv lw lx b">1</code>开始。</p><p id="0563" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">另一个现在很容易构建的流是正方形序列。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="913d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">阶乘呢</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="def7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">再次注意阶乘:<code class="fe lu lv lw lx b">'(1 2 6 24 120 720 …)</code>乘以自然数:<code class="fe lu lv lw lx b">'(1 2 3 4 5 6)</code>，等于阶乘:<code class="fe lu lv lw lx b">'(2 6 24 120 720 5040 …)</code>的<code class="fe lu lv lw lx b">cdr</code>。因为我们已经有了阶乘的<code class="fe lu lv lw lx b">cdr</code>,我们只需要显式地从第一个阶乘开始，然后将两个阶乘组合起来。</p><p id="b967" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果这仍然有点令人困惑，我强烈建议你按照我在上一篇文章中展示的那样，完成工作中的基本流程。</p><h1 id="bbc6" class="kr ks in bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">走向质数</h1><p id="d706" class="pw-post-body-paragraph jk jl in jm b jn lp jp jq jr lq jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh ig bi translated">无限列表的一个最经典和优雅的例子是构造素数列表。用我们唯一的工具<code class="fe lu lv lw lx b">stream-combine</code>这显然是不可能的，所以让我们介绍最后一个函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="946e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe lu lv lw lx b">stream-filter</code>带一个谓词和一个流。然后，它沿着列表向下，只保留满足谓词的项目，如果一个项目评估为 false，则跳过它。由于这些都是延迟评估的，<code class="fe lu lv lw lx b">stream-filter</code>按需工作:只执行我们请求的必要内容。</p><h2 id="d7f6" class="ma ks in bd kt mb mc dn kx md me dp lb jv mf mg lf jz mh mi lj kd mj mk ln ml bi translated">简单用途</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="a2c2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">构造奇数的(许多)方法之一是从自然数中过滤出所有的偶数。</p><h2 id="e2d4" class="ma ks in bd kt mb mc dn kx md me dp lb jv mf mg lf jz mh mi lj kd mj mk ln ml bi translated">厄拉多塞的筛子</h2><p id="0927" class="pw-post-body-paragraph jk jl in jm b jn lp jp jq jr lq jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh ig bi translated">厄拉多塞筛是一种寻找质数的古老算法。本质上，您从 2(第一个质数)开始获取自然数列表。根据定义，任何二的倍数都不是质数，所以把它们从列表中删除。现在移动到下一个质数，从列表中删除它的所有倍数，依此类推。此过程将删除除 1 或自身之外的所有系数。(<a class="ae kq" href="https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes" rel="noopener ugc nofollow" target="_blank">延伸阅读</a>)通常这个过程需要一个上界，但是我们已经找到了一种玩转无穷的方法。懒惰评估再次通过仅在我们需要时过滤来挽救局面。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/bd2772a8d0d48d6e27392a85c3fdf5c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:890/0*A-yqRmRgD6iEm7is.gif"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">筛网可视化</figcaption></figure><h2 id="db8a" class="ma ks in bd kt mb mc dn kx md me dp lb jv mf mg lf jz mh mi lj kd mj mk ln ml bi translated">质数达到无穷大</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="9413" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">sieve 函数简单地实现了上面描述的算法。它将流的第一个元素作为素数，过滤掉它的所有因子，并对下一个(素数)数重复这个过程。传递从 2 开始的自然数流会产生素数。</p></div><div class="ab cl mr ms hr mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ig ih ii ij ik"><p id="8d6d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">令人惊讶的是，我们可以在有限的内存空间内有效地创建无限的数据结构。它展示了懒评的一些威力和妙处。至于这些列表的实际使用，我不会在这里深入讨论，但是我发现这个<a class="ae kq" href="https://stackoverflow.com/questions/5284458/what-are-some-compelling-use-cases-of-infinite-data-structures" rel="noopener ugc nofollow" target="_blank">堆栈溢出线程</a>有一些有趣的地方。有些语言，比如 Haskell，内置了无限列表，所以这个概念不仅仅是理论上的。</p></div><div class="ab cl mr ms hr mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ig ih ii ij ik"><h1 id="4a65" class="kr ks in bd kt ku my kw kx ky mz la lb lc na le lf lg nb li lj lk nc lm ln lo bi translated">关于作者</h1><p id="13d8" class="pw-post-body-paragraph jk jl in jm b jn lp jp jq jr lq jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh ig bi translated">Eric Breyer 是莱斯大学的计算机科学本科生。你可以在他的<a class="ae kq" href="http://www.ericbreyer.com/" rel="noopener ugc nofollow" target="_blank">网站</a>以及<a class="ae kq" href="https://github.com/ericbreyer" rel="noopener ugc nofollow" target="_blank"> GitHub </a>和<a class="ae kq" href="https://www.linkedin.com/in/eric-breyer/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上找到他。</p></div></div>    
</body>
</html>