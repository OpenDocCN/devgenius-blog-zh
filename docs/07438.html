<html>
<head>
<title>Taints, Tolerations and Node affinity in Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">库伯内特家族的污点、容忍和节点亲和力</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/taints-tolerations-and-node-affinity-in-kubernetes-41d063157852?source=collection_archive---------5-----------------------#2022-03-25">https://blog.devgenius.io/taints-tolerations-and-node-affinity-in-kubernetes-41d063157852?source=collection_archive---------5-----------------------#2022-03-25</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/9936b52b979a42546bbf8057566d8bac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-uXyTZpZdqn0Ab-zBsFE8w.png"/></div></div></figure><p id="b76f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">可能会有这样的用例，我们需要将某些 pod 仅放置在某些节点上。</p><p id="20a5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">举个例子，</p><ul class=""><li id="078b" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated">有 3 个节点(2 个低资源节点和 1 个高资源节点)。</li><li id="b871" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">我们希望将运行高处理应用程序的 pod 放在具有更高资源的节点中。</li></ul><p id="ad5c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">默认设置基于负载平衡和资源可用性策略将 pod 放置在节点中。</p><p id="2e62" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">此外，通过污染和容忍，我们可以保证节点接受某些 pod，但不能保证将 pod 放在某些节点上。</p><p id="251f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> <em class="lh">节点选择器</em> </strong></p><p id="c7bb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">实现这一点的简单方法是使用<strong class="jx io">节点选择器</strong>。</p><p id="dffc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">使用节点选择器的 Pod 配置示例</p><pre class="li lj lk ll gt lm ln lo lp aw lq bi"><span id="16ba" class="lr ls in ln b gy lt lu l lv lw">apiVersion: v1<br/>kind: Pod<br/>metadata:<br/>    name: myapp-pod<br/>spec:<br/>    containers:<br/>        - name: data-processor<br/>          image: data-processor<br/>    nodeSelector:<br/>        size: Large</span></pre><p id="1e74" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">键值对(size: Large)实际上是分配给节点的标签。调度程序使用这些来将 pod 分配给特定的节点。</p><p id="a4ad" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">标记节点的命令:</p><pre class="li lj lk ll gt lm ln lo lp aw lq bi"><span id="d3f5" class="lr ls in ln b gy lt lu l lv lw">kubectl label nodes &lt;node-name&gt; &lt;key&gt;:&lt;value&gt;</span></pre><p id="66f5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">节点选择器</strong>的局限性是不能满足复杂的需求。例如:</p><ul class=""><li id="8879" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated">如果我们想将 pod 放在一个大的或中等的标记节点上。</li><li id="9348" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">或者如果我们不想将 pod 放在小标签节点中。</li></ul><p id="efb3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> <em class="lh">节点亲缘</em> </strong></p><p id="5d35" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">复杂的需求可以在节点关联中执行。</p><p id="0192" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">节点选择器中使用的示例可以重新定义如下:</p><pre class="li lj lk ll gt lm ln lo lp aw lq bi"><span id="1397" class="lr ls in ln b gy lt lu l lv lw">apiVersion: v1<br/>kind: Pod<br/>metadata:<br/>    name: myapp-pod<br/>spec:<br/>    containers:<br/>        - name: data-processor<br/>          image: data-processor<br/>    affinity:<br/>        nodeAffinity:<br/>            requiredDuringSchedulingIgnoredDuringExecution:<br/>                nodeSelectorsTerms:<br/>                - matchExpressions:<br/>                  - key: size<br/>                    operator: In #NotIn, Exists,...<br/>                    values:<br/>                    - Large</span></pre><p id="340f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们看一下<strong class="jx io">节点亲缘关系类型</strong>:</p><ol class=""><li id="8e18" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks lx kz la lb bi translated"><strong class="jx io">requiredduringschedulingignoredduringeexecution</strong>:如果规则不匹配，将不会调度 Pod(Pod 仍处于待定状态)，但已运行的 Pod 将被忽略(与规则无关)。</li><li id="7823" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks lx kz la lb bi translated"><strong class="jx io">preferred during schedulingignoredduringeexecution</strong>:如果规则不匹配，Pod 将在可用节点中调度，并且忽略已经运行的 Pod(与规则无关)。</li><li id="3eaa" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks lx kz la lb bi translated"><strong class="jx io">requiredduringschedulingrequiredduringeexecution</strong>:如果规则不匹配，则 Pod 不会被调度(Pod 保持挂起状态)，如果规则不匹配，则已经运行的 Pod 会被驱逐。</li></ol><p id="3902" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> <em class="lh">结缘 vs 玷污与宽容</em> </strong></p><figure class="li lj lk ll gt jo gh gi paragraph-image"><div class="gh gi ly"><img src="../Images/4185e2820708a25eaaa06a27fa3f6bb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1282/format:webp/1*7e0BwxxNBMrx2J4TQGMjuA.png"/></div></figure><p id="92b7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们来看一个用例</p><ol class=""><li id="88b8" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks lx kz la lb bi translated">有 3 个节点:红色、蓝色和绿色。还有其他节点。</li><li id="18fd" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks lx kz la lb bi translated">有 3 个豆荚:红色，蓝色和绿色。还有其他的豆荚。</li><li id="2188" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks lx kz la lb bi translated">我们的目的是把红 pod 放在红节点，绿 pod 放在绿节点，蓝 pod 放在蓝节点。</li><li id="d111" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks lx kz la lb bi translated">我们也不希望任何其他豆荚被放置在我们的(红色、绿色和蓝色)节点中。</li><li id="7337" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks lx kz la lb bi translated">我们也不希望我们的吊舱被放置在其他节点上。</li></ol><p id="75a9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们先试试<strong class="jx io">污点和容忍</strong>:</p><ol class=""><li id="42d8" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks lx kz la lb bi translated">我们将红色、蓝色和绿色的污点应用于节点。</li><li id="0b28" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks lx kz la lb bi translated">然后我们对豆荚应用红色、蓝色和绿色的容忍。</li><li id="a17e" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks lx kz la lb bi translated">这将有助于将具有适当容差的 pod 放置在相应的污染节点中，但是这不能保证 pod 在没有污染的节点中结束。</li></ol><p id="02a1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在让我们试试<strong class="jx io">节点关联</strong>:</p><ol class=""><li id="3f7f" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks lx kz la lb bi translated">我们在节点上应用键值对标签。</li><li id="94e6" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks lx kz la lb bi translated">然后，我们用适当的亲缘关系配置节点。</li><li id="94b9" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks lx kz la lb bi translated">这将有助于我们在适当的节点放置豆荚，但其他豆荚也可能在我们的节点结束。</li></ol><p id="6e05" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此使用了污染、容忍和节点亲和性的组合。</p><ol class=""><li id="eff1" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks lx kz la lb bi translated">我们将红色、蓝色和绿色的污点应用于节点，以防止不需要的 pod 被放置在被污染的节点中。</li><li id="6b03" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks lx kz la lb bi translated">我们在节点上应用键-值对标签，然后用适当的亲和力配置节点，这将让 pod 选择节点。</li></ol></div></div>    
</body>
</html>