<html>
<head>
<title>Best of Modern JavaScript — Proxies</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">现代 JavaScript 的精华—代理</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/best-of-modern-javascript-proxies-7efd45309b24?source=collection_archive---------8-----------------------#2020-11-09">https://blog.devgenius.io/best-of-modern-javascript-proxies-7efd45309b24?source=collection_archive---------8-----------------------#2020-11-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/2b02106a84500daa5c43ca9a995effa9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*sIbSGHCZfRsZfVqY"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@asury?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Aryo Kadiono </a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="0e51" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">自 2015 年以来，JavaScript 有了巨大的进步。</p><p id="c894" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在用起来比以前舒服多了。</p><p id="193a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究使用 JavaScript 代理的元编程。</p><h1 id="62e8" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">元编程</h1><p id="48ad" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">元编程是编写代码来处理我们的应用程序级代码。</p><p id="70ee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">应用程序级代码是接受用户输入并为用户返回输出的代码。</p><p id="3c65" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有各种各样的元编程。</p><p id="f37f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一种是自省。这是我们只读访问程序结构的地方。</p><p id="229d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">自我修改是我们改变程序结构的地方。</p><p id="0eb9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">调解是我们重新定义一些语言操作的语义的地方。</p><p id="df96" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Javascript 中自省的一个例子是使用<code class="fe me mf mg mh b">Object.keys()</code>来获取对象的键。</p><p id="c762" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">自我修改的一个例子是将属性从一个地方移动到另一个地方。</p><p id="2070" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="c926" class="mq lc iq mh b gy mr ms l mt mu">function moveProperty(source, prop, target) {<br/>  target[prop] = source[prop];<br/>  delete source[prop];<br/>}</span></pre><p id="2537" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">将<code class="fe me mf mg mh b">prop</code>属性从<code class="fe me mf mg mh b">source</code>对象移动到<code class="fe me mf mg mh b">target</code>对象。</p><p id="5233" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们删除<code class="fe me mf mg mh b">source</code>对象的<code class="fe me mf mg mh b">prop</code>属性。</p><p id="0558" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">代理让我们与 JavaScript 应用程序进行调解。</p><p id="9a66" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以用它来改变对象操作的方式。</p><h1 id="2e61" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">委托书</h1><p id="3e20" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">代理为 JavaScript 带来了调解。</p><p id="2d11" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以对一个对象进行许多操作。</p><p id="633f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以得到属性值，也可以设置它。</p><p id="c844" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们可以检查属性是否在对象中。</p><p id="233b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以用代理定制这些操作。</p><p id="9282" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="186d" class="mq lc iq mh b gy mr ms l mt mu">const target = {};<br/>const handler = {<br/>  get(target, propKey, receiver) {<br/>    console.log(target, propKey, receiver);<br/>    return 'foo';<br/>  }<br/>};<br/>const proxy = new Proxy(target, handler);</span><span id="ce77" class="mq lc iq mh b gy mv ms l mt mu">console.log(proxy.bar)</span></pre><p id="7322" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们创建一个用于代理的空的<code class="fe me mf mg mh b">target</code>对象。</p><p id="cc9a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而<code class="fe me mf mg mh b">handler</code>对象有一个<code class="fe me mf mg mh b">get</code>方法，让我们为给定的属性返回值。</p><p id="4f50" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">target</code>是我们传递给<code class="fe me mf mg mh b">Proxy</code>构造函数第一个参数的对象。</p><p id="45cb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">propKey</code>是属性名。</p><p id="28bd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，如果我们获得<code class="fe me mf mg mh b">proxy.bar</code>的值或<code class="fe me mf mg mh b">proxy</code>的任何其他属性，我们将返回<code class="fe me mf mg mh b">'foo'</code>。</p><p id="26b6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还可以改变检查对象中是否存在属性的方式。</p><p id="5247" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="2d47" class="mq lc iq mh b gy mr ms l mt mu">const target = {};<br/>const handler = {<br/>  has(target, propKey) {<br/>    console.log(propKey);<br/>    return true;<br/>  }<br/>};<br/>const proxy = new Proxy(target, handler);</span><span id="b2fb" class="mq lc iq mh b gy mv ms l mt mu">console.log('bar' in proxy);<br/>console.log('foo' in proxy);</span></pre><p id="2385" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到<code class="fe me mf mg mh b">target</code>和<code class="fe me mf mg mh b">propKey</code>参数，它们的值与<code class="fe me mf mg mh b">get</code>中的值相同。</p><p id="eb31" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们返回了<code class="fe me mf mg mh b">true</code>，所以每当我们对它使用<code class="fe me mf mg mh b">in</code>操作符时，它都会返回<code class="fe me mf mg mh b">true</code>。</p><p id="5943" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">set</code>方法可以让我们改变对象的设置方式。</p><h1 id="b968" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">拦截方法调用</h1><p id="6b5a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过调用对象属性中的方法来拦截方法调用。</p><p id="2365" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="9bd7" class="mq lc iq mh b gy mr ms l mt mu">const target = {<br/>  foo(text) {<br/>    return `text ${text}`;<br/>  }<br/>};</span><span id="a227" class="mq lc iq mh b gy mv ms l mt mu">const handler = {<br/>  get(target, propKey, receiver) {<br/>    const origMethod = target[propKey];<br/>    return function(...args) {<br/>      const result = origMethod.apply(this, args);<br/>      console.log(JSON.stringify(args), JSON.stringify(result));<br/>      return result;<br/>    };<br/>  }<br/>};<br/>const proxy = new Proxy(target, handler);</span><span id="e714" class="mq lc iq mh b gy mv ms l mt mu">console.log(proxy.foo('baz'));</span></pre><p id="da84" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们把<code class="fe me mf mg mh b">handler</code>方法中的<code class="fe me mf mg mh b">get</code>方法称为<code class="fe me mf mg mh b">target.foo</code>方法。</p><p id="0ac1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe me mf mg mh b">get</code>方法内部，我们调用带有参数的方法，但是使用<code class="fe me mf mg mh b">this</code>作为代理，而不是<code class="fe me mf mg mh b">target</code>对象。</p><p id="f4d1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样，我们可以改变方法调用的行为。</p><p id="ee4b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们记录了争论及其结果。</p><p id="5df4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这对于记录方法调用很方便。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/873813b31a0b1a24ed921d520f1455b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5IScEuR_A0lkBSJv"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">由<a class="ae kc" href="https://unsplash.com/@zamax?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Gustavo Zambelli </a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="41f7" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="2465" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">代理让我们控制如何获取和设置对象属性。</p><p id="50b5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也可以改变检查属性的方式。</p></div></div>    
</body>
</html>