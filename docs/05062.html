<html>
<head>
<title>Data Structure in Swift: Tree</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift中的数据结构:树</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/data-structure-in-swift-tree-192612915d33?source=collection_archive---------3-----------------------#2021-06-10">https://blog.devgenius.io/data-structure-in-swift-tree-192612915d33?source=collection_archive---------3-----------------------#2021-06-10</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="41c3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">真的吗？又是数据结构？让我告诉你关于树的事情:]</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/96fa70c36952f8687aec6d92fb188d8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IQMn6xgoo-MpffiV"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae ky" href="https://unsplash.com/@fabulu75?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Fabrice Villard </a>拍摄的照片</figcaption></figure><p id="2c83" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在软件工程领域，树是一种重要的数据结构，在某些情况下使用:</p><ul class=""><li id="3b3c" class="kz la in jm b jn jo jr js jv lb jz lc kd ld kh le lf lg lh bi translated">表示分层数据关系</li><li id="d0ae" class="kz la in jm b jn li jr lj jv lk jz ll kd lm kh le lf lg lh bi translated">管理排序数据</li><li id="c6e8" class="kz la in jm b jn li jr lj jv lk jz ll kd lm kh le lf lg lh bi translated">提供快速搜索操作</li></ul><p id="62fe" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">树型数据结构根据所要解决的问题有不同的变体。在本文中，我们将尝试使用swift实现规则的树数据结构。</p><h2 id="cd06" class="ln lo in bd lp lq lr dn ls lt lu dp lv jv lw lx ly jz lz ma mb kd mc md me mf bi translated">术语</h2><ul class=""><li id="38cc" class="kz la in jm b jn mg jr mh jv mi jz mj kd mk kh le lf lg lh bi translated">节点<br/>类似于链表，树也由几个节点组成。节点具有类似数据及其子节点属性。</li><li id="82fb" class="kz la in jm b jn li jr lj jv lk jz ll kd lm kh le lf lg lh bi translated">父子<br/>树数据结构是自上而下的，代表现实世界中的一棵树。除了最顶端的节点之外，所有节点都连接到其上的一个节点，该节点称为父节点。然后，节点可以连接到下面的一个或两个节点，这些节点称为子节点。在树形数据结构中，子节点只有一个父节点。</li><li id="5770" class="kz la in jm b jn li jr lj jv lk jz ll kd lm kh le lf lg lh bi translated">Root <br/> Root是层次结构中最顶层的节点，没有父节点。</li><li id="3738" class="kz la in jm b jn li jr lj jv lk jz ll kd lm kh le lf lg lh bi translated">叶子是一个没有子节点的节点</li></ul><h2 id="d264" class="ln lo in bd lp lq lr dn ls lt lu dp lv jv lw lx ly jz lz ma mb kd mc md me mf bi translated">履行</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="45f2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">每个树节点保存一个值或数据，以及子节点。例如，我们有一个表示饮料数据的树。饮料有茶和咖啡之分，它代表了这样的等级:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/686e0de6bbe251c92ad0c0e04a29664f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1082/format:webp/1*KHay0GHZ9sGQ-7_NKDFMkg.png"/></div></figure><h2 id="24ab" class="ln lo in bd lp lq lr dn ls lt lu dp lv jv lw lx ly jz lz ma mb kd mc md me mf bi translated">横越</h2><p id="79ec" class="pw-post-body-paragraph jk jl in jm b jn mg jp jq jr mh jt ju jv mo jx jy jz mp kb kc kd mq kf kg kh ig bi translated">为了遍历一个线性数据结构中的所有数据，可以很容易地用数组或链表来实现。但是在树形数据结构中，遍历有点复杂。有一些遍历算法可以在树数据结构中实现，这取决于我们试图解决的问题。在实现一些遍历算法之前，让我们先创建树。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="c132" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">从上面的树中，这里是分层数据表示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mr"><img src="../Images/59385f3dbf196d7155a431d74541a963.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w0VC-2Me_-ndkb6l4yydrQ.png"/></div></div></figure><p id="3b76" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">深度优先遍历</strong> <br/>遍历技术，即从树根开始，直到探索到尽可能深的地方才回溯。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="e106" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">深度优先遍历可以使用递归实现。我创建的函数是接收闭包，我们以后可以根据需要使用它，在这个示例中，我们只需要分配闭包来打印节点值。遍历的结果如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="92c3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">层次顺序遍历<br/> </strong>这种遍历技术是基于深度层次访问树中的每个节点。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="5007" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了进行层次顺序遍历，我使用了队列来使我们的工作变得更加容易。让我们看看它的结果如何:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="fb73" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">搜索</strong> <br/>我们现在有两种遍历算法，所以做搜索操作不再困难:]</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="c671" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">搜索操作非常简单，只需使用深度优先遍历，就可以得到闭包中的节点。如果节点值与函数参数相同，则只需保存到结果变量并返回:】。</p><h2 id="ccfe" class="ln lo in bd lp lq lr dn ls lt lu dp lv jv lw lx ly jz lz ma mb kd mc md me mf bi translated">要点</h2><ul class=""><li id="8e4f" class="kz la in jm b jn mg jr mh jv mi jz mj kd mk kh le lf lg lh bi translated">树和链表有一些相似之处，它们之间的区别是链表只有一个对下一个节点的引用，而树数据结构有多个子节点。</li><li id="5027" class="kz la in jm b jn li jr lj jv lk jz ll kd lm kh le lf lg lh bi translated">除了根节点，每个树节点只有一个父节点</li><li id="d5a4" class="kz la in jm b jn li jr lj jv lk jz ll kd lm kh le lf lg lh bi translated">诸如深度优先和级别顺序的遍历算法可以在各种树上实现，并且实现可以根据我们如何创建树而不同。</li></ul></div></div>    
</body>
</html>