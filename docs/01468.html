<html>
<head>
<title>What Is Unsafe Swift Code?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是不安全的 Swift 代码？</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/what-is-unsafe-swift-code-aa7d1a94c57a?source=collection_archive---------2-----------------------#2020-07-04">https://blog.devgenius.io/what-is-unsafe-swift-code-aa7d1a94c57a?source=collection_archive---------2-----------------------#2020-07-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="0129" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">崩溃你的应用是安全的路线</h2><div class=""/><div class=""><h2 id="c5f7" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">强制解包是安全的！</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/e6da0cfe46f80af6a8b184236852612e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dltmdBTQqOFnl_1-D3j0Fg.jpeg"/></div></div></figure><h2 id="e1b0" class="la lb iq bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu iw bi translated">强制解包可选的是安全的代码！</h2><p id="4168" class="pw-post-body-paragraph lv lw iq lx b ly lz ka ma mb mc kd md lj me mf mg ln mh mi mj lr mk ml mm mn ij bi translated">你可能会认为，当你强行打开一个可选的。你告诉编译器，“我知道我在做什么，这个值不是零。<strong class="lx ja">我保证。”</strong>如果为零，你的应用就会崩溃。你可能不知道的是<em class="mo">实际上是</em>一种打开期权的安全方式。</p><p id="b383" class="pw-post-body-paragraph lv lw iq lx b ly mp ka ma mb mq kd md lj mr mf mg ln ms mi mj lr mt ml mm mn ij bi translated">但是，Kenny，如果我强行打开一个可选的，并且它包含一个空值，我的应用程序就会崩溃。这意味着它不安全！”</p><p id="166d" class="pw-post-body-paragraph lv lw iq lx b ly mp ka ma mb mq kd md lj mr mf mg ln ms mi mj lr mt ml mm mn ij bi translated">嗯，你是对的，但你也错了</p><p id="ed8c" class="pw-post-body-paragraph lv lw iq lx b ly mp ka ma mb mq kd md lj mr mf mg ln ms mi mj lr mt ml mm mn ij bi translated">根据 Swift 标准图书管理员 Karoy Lorentey 在他的 WWDC 2020 演讲<a class="ae mu" href="https://developer.apple.com/videos/play/wwdc2020/10648/" rel="noopener ugc nofollow" target="_blank">不安全 Swift </a>中的说法，当执行不安全代码并遇到意外值(例如意外的零值)时，不能保证您的应用会崩溃。</p><p id="b59d" class="pw-post-body-paragraph lv lw iq lx b ly mp ka ma mb mq kd md lj mr mf mg ln ms mi mj lr mt ml mm mn ij bi translated">不安全代码在运行时会发生什么是不可预测的。你可能有 99%的机会崩溃，但在某些情况下，垃圾可能会被解释，允许你的应用程序继续运行，但在你背后做着谁知道的事情。混乱的内存产生<em class="mo">奇怪的</em>结果。</p><p id="781f" class="pw-post-body-paragraph lv lw iq lx b ly mp ka ma mb mq kd md lj mr mf mg ln ms mi mj lr mt ml mm mn ij bi translated"><strong class="lx ja">相反，安全代码并不意味着你的应用不会崩溃</strong></p><p id="6832" class="pw-post-body-paragraph lv lw iq lx b ly mp ka ma mb mq kd md lj mr mf mg ln ms mi mj lr mt ml mm mn ij bi translated">Lorentey 继续说，“安全 API 的目标不是防止崩溃——恰恰相反。”如果一个安全的 API 从它设计接收的指令之外接收指令，<em class="mo">那么</em>你的应用就会崩溃。</p><blockquote class="mv"><p id="1c47" class="mw mx iq bd my mz na nb nc nd ne mn dk translated">这是因为“我们的代码破坏了一个关键的契约，我们需要去修复它。继续执行死刑是不负责任的。”—罗伦泰</p></blockquote><figure class="ng nh ni nj nk kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nf"><img src="../Images/3d84a82433f250495edd4274b4e1e262.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Q2CPq45LlM3srVqN.png"/></div></div></figure><p id="91d1" class="pw-post-body-paragraph lv lw iq lx b ly mp ka ma mb mq kd md lj mr mf mg ln ms mi mj lr mt ml mm mn ij bi translated"><strong class="lx ja">为什么我们有时不得不编写不安全的代码</strong></p><p id="2c02" class="pw-post-body-paragraph lv lw iq lx b ly mp ka ma mb mq kd md lj mr mf mg ln ms mi mj lr mt ml mm mn ij bi translated">由于系统不必管理内存空间，不安全的代码通常性能更高。不过，很多时候，我们只需要与使用指针的 C 或 Objective-C API 进行互操作。</p><p id="1cf6" class="pw-post-body-paragraph lv lw iq lx b ly mp ka ma mb mq kd md lj mr mf mg ln ms mi mj lr mt ml mm mn ij bi translated"><strong class="lx ja">性能</strong></p><p id="2f6f" class="pw-post-body-paragraph lv lw iq lx b ly mp ka ma mb mq kd md lj mr mf mg ln ms mi mj lr mt ml mm mn ij bi translated">有时候，对于我们试图执行的操作来说，对一个空值执行检查太耗时了，导致 UI 的响应速度变慢或者其他意外的行为。</p><p id="fbd5" class="pw-post-body-paragraph lv lw iq lx b ly mp ka ma mb mq kd md lj mr mf mg ln ms mi mj lr mt ml mm mn ij bi translated">在这些情况下，我们可能会指定<code class="fe nl nm nn no b">.unsafelyUnwrapped</code>过度小心地展开(guard-let，if-let，！= nil)，甚至强制展开。强制解包<em class="mo">是否</em>提供检查以查看值是否为零。但是它是安全的<em class="mo">，因为</em>它在<em class="mo">的时候会让你的应用崩溃。这让你确切地知道你的应用程序在哪个点崩溃，而不是你的应用程序稍后崩溃，或者一些意想不到的事情发生。</em></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nf"><img src="../Images/379d2c6f505bbc92187e49a4bc08f7c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*rV8OfrOHglaEC43O.png"/></div></div></figure><p id="521d" class="pw-post-body-paragraph lv lw iq lx b ly mp ka ma mb mq kd md lj mr mf mg ln ms mi mj lr mt ml mm mn ij bi translated"><code class="fe nl nm nn no b">!</code>操作符不仅仅是<code class="fe nl nm nn no b">.unsafelyUnwrapped</code>的简称。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi np"><img src="../Images/8c6d85d04aafb3102514977343f1ce6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:926/format:webp/1*J4EjE63fWPyAZRlMNqnMqQ.png"/></div></figure><p id="ea0d" class="pw-post-body-paragraph lv lw iq lx b ly mp ka ma mb mq kd md lj mr mf mg ln ms mi mj lr mt ml mm mn ij bi translated">这两个例子几乎相同，但是！是安全的选择。。当遇到意外的零值时，unsafelyUnwrapped 不一定会导致崩溃。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/bd37a168b6cb49aedca13b46544179ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:958/format:webp/1*rauf_TjJoZWyqBZNoH6pLg.png"/></div></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/d611edc4c0a0caceb2fd41640a6947c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:646/format:webp/1*A8zVDg_Z-VXRqeLvVazeig.png"/></div></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nf"><img src="../Images/379d2c6f505bbc92187e49a4bc08f7c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*rV8OfrOHglaEC43O.png"/></div></div></figure><h2 id="1305" class="la lb iq bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu iw bi translated">如何区分安全 API 和不安全 API</h2><p id="7119" class="pw-post-body-paragraph lv lw iq lx b ly lz ka ma mb mc kd md lj me mf mg ln mh mi mj lr mk ml mm mn ij bi translated">不安全的 API 是不安全的，因为 Swift 不管理它们所在的内存空间。相反，我们作为开发人员必须手动管理内存。API 给了我们需要的工具，但是信任是留给我们在任何给定的时间做正确的事情——这本质上是不安全的。但是我们如何识别这种不安全的代码呢？</p><p id="bf49" class="pw-post-body-paragraph lv lw iq lx b ly mp ka ma mb mq kd md lj mr mf mg ln ms mi mj lr mt ml mm mn ij bi translated"><strong class="lx ja">值得庆幸的是，不安全的原料药被明确标注出来</strong></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ns"><img src="../Images/d449104aaafe6cd3c80a935d9bb6d13f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NvB7OWd9j8MsfSIiLtReUA.png"/></div></div><figcaption class="nt nu gj gh gi nv nw bd b be z dk translated">Swift 不知道 ptr 已经被解除分配——它看起来和有效指针一样</figcaption></figure><p id="fd1d" class="pw-post-body-paragraph lv lw iq lx b ly mp ka ma mb mq kd md lj mr mf mg ln ms mi mj lr mt ml mm mn ij bi translated">当你“在野外”遇到一个不安全的 API 时，你会知道，因为它会被标记为<code class="fe nl nm nn no b"><strong class="lx ja">Unsafe</strong></code>。</p><p id="9955" class="pw-post-body-paragraph lv lw iq lx b ly mp ka ma mb mq kd md lj mr mf mg ln ms mi mj lr mt ml mm mn ij bi translated">在上面的例子中，我们为一个整数分配内存空间，初始化它，释放它，然后尝试设置一个新值。当我们试图改变它时,<code class="fe nl nm nn no b">ptr</code>被释放，但这并不意味着应用程序会崩溃。一旦内存被释放，其他东西可以使用它的空间。所以你现在要做的是在内存中设置一些空间值为 23。这对你的应用会有什么影响？谁知道呢。也许它是一个不同的整数，你只是改变了它的值。也许它是一个复杂操作的一部分，你只是插入了一些奇怪的指令，过一段时间后会突然出现，看起来是由其他原因引起的。</p><h1 id="ac5a" class="nx lb iq bd lc ny nz oa lf ob oc od li kf oe kg lm ki of kj lq kl og km lu oh bi translated">包裹</h1><p id="7739" class="pw-post-body-paragraph lv lw iq lx b ly lz ka ma mb mc kd md lj me mf mg ln mh mi mj lr mk ml mm mn ij bi translated">总之，当我们编写导致应用程序崩溃的代码时，我们通常是在编写安全的代码——我们只需要修复它。当我们的应用程序在做我们不理解或没有预料到的事情时，我们可能遇到了不安全的 API。这就是为什么我只在绝对必要的时候才使用不安全的 API。</p><p id="37fe" class="pw-post-body-paragraph lv lw iq lx b ly mp ka ma mb mq kd md lj mr mf mg ln ms mi mj lr mt ml mm mn ij bi translated">我们中的许多人已经花费了比调试代码更多的时间。我总是很乐意让内存为我管理！</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nf"><img src="../Images/379d2c6f505bbc92187e49a4bc08f7c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*rV8OfrOHglaEC43O.png"/></div></div></figure><p id="7ec9" class="pw-post-body-paragraph lv lw iq lx b ly mp ka ma mb mq kd md lj mr mf mg ln ms mi mj lr mt ml mm mn ij bi translated">附言</p><p id="a906" class="pw-post-body-paragraph lv lw iq lx b ly mp ka ma mb mq kd md lj mr mf mg ln ms mi mj lr mt ml mm mn ij bi translated">不要误解我——我并不提倡在你的应用中使用强制解包选项。我很少在产品代码中强制展开选项。也就是说，我<em class="mo">确实</em>在早期开发(pre-PR)中强制展开选项。如果我忘记设置一个值，我希望应用程序崩溃，这样我就知道我需要修复一些东西。</p><p id="aacc" class="pw-post-body-paragraph lv lw iq lx b ly mp ka ma mb mq kd md lj mr mf mg ln ms mi mj lr mt ml mm mn ij bi translated">我们都同意崩溃不是一个好的用户体验。我想我们都同意，看不到任何东西，或者一些占位符值代替重要数据，也不是一个好的用户体验。小心翼翼地打开选项不应该成为一个占位符，用来小心翼翼地确保您已经考虑了值可能为零的边缘情况。在开发中也不应该避免强制展开。</p></div></div>    
</body>
</html>