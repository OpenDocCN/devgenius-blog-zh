<html>
<head>
<title>Node.js Best Practices — Config and Errors</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js最佳实践—配置和错误</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/node-js-best-practices-config-and-errors-759618309fff?source=collection_archive---------7-----------------------#2020-08-06">https://blog.devgenius.io/node-js-best-practices-config-and-errors-759618309fff?source=collection_archive---------7-----------------------#2020-08-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/126007b03423ae64f1b7b6231f124ee3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pbkQr-bsjkMXKTiH"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">由<a class="ae kc" href="https://unsplash.com/@sanateddy?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">奥莎娜·利亚申科</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="17b3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像任何类型的应用程序一样，JavaScript应用程序也必须写得很好。</p><p id="9a1d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">否则，我们以后会遇到各种各样的问题。</p><p id="96a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将看看在编写节点应用程序时应该遵循的一些最佳实践。</p><h1 id="6812" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用环境感知、安全和分层的配置</h1><p id="a10a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们应该让我们的应用程序可配置。</p><p id="a7ad" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为此，我们可以从环境变量中读取设置。</p><p id="74ce" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以使用dotenv库从一个<code class="fe me mf mg mh b">.env</code>文件和其他来源读取环境变量。</p><p id="449a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这将使我们的应用程序在任何地方都能正常运行。</p><h1 id="6cb6" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用Async-Await或Promises进行异步错误处理</h1><p id="2a5d" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">异步代码应该用于任何长时间运行的操作。</p><p id="11c3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">链接异步代码的最糟糕的方式是拥有多层嵌套的异步回调。</p><p id="4965" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们很难阅读和调试。</p><p id="7c4e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最好的办法就是利用承诺，并把承诺链起来。</p><p id="fd6b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了使它们更短，我们可以使用async和await。</p><p id="af25" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以要么，我们写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="8f5a" class="mq lc iq mh b gy mr ms l mt mu">return functionA()<br/>  .then(functionB)<br/>  .then(functionC)<br/>  .then(functionD)<br/>  .catch((err) =&gt; console.error(err))<br/>  .then(alwaysRunThisFunction)</span></pre><p id="c9d5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="c236" class="mq lc iq mh b gy mr ms l mt mu">async function executeAsyncTask () {<br/>  try {<br/>    const valueA = await functionA();<br/>    const valueB = await functionB(valueA);<br/>    const valueC = await functionC(valueB);<br/>    return await functionD(valueC);<br/>  }<br/>  catch (err) {<br/>    console.error(err);<br/>  } <br/>  finally {<br/>    await alwaysRunThisFunction();<br/>  }<br/>}</span></pre><p id="348b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">他们做同样的事情。</p><p id="a1c4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">回调都返回承诺，因此我们可以将它们链接起来。</p><h1 id="0c99" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">仅使用内置的错误对象</h1><p id="9bee" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">当我们抛出错误时，我们应该使用内置的错误类型。</p><p id="347d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们应该写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="caea" class="mq lc iq mh b gy mr ms l mt mu">new Error('whoops!')</span></pre><p id="c3bb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而不是:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="9a7c" class="mq lc iq mh b gy mr ms l mt mu">throw ('whoops!');</span></pre><p id="dff8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">Error</code>实例拥有堆栈跟踪等其他地方没有的信息。</p><h1 id="c3a2" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">区分操作错误和程序员错误</h1><p id="91f4" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们应该区分像API错误这样的操作错误，它们可以被正确地处理。</p><p id="aa24" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">程序员错误是我们没有考虑到的错误，比如未定义的错误。</p><p id="5354" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">程序员的错误应该得到修复，以便我们的应用程序将运行更顺畅。</p><p id="941f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">操作错误应该由我们的代码来处理。</p><h1 id="7607" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">集中处理错误，而不是在Express中间件中</h1><p id="35e0" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">错误应该集中处理，而不是使用快速中间件。</p><p id="c420" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">否则，我们将在多个地方得到重复的代码来处理相同的错误。</p><p id="7587" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不要写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="97c0" class="mq lc iq mh b gy mr ms l mt mu">app.use((err, req, res, next) =&gt; {<br/>  logger.logError(err);<br/>  if (err.severity == errors.high) {<br/>    mailer.sendMail(configuration.adminMail, 'error occured', err);<br/>  }<br/>  next(err);  <br/>});</span></pre><p id="bb7b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="d7af" class="mq lc iq mh b gy mr ms l mt mu">module.exports.handler = new ErrorHandler();</span><span id="523f" class="mq lc iq mh b gy mv ms l mt mu">function ErrorHandler() {<br/>  this.handleError = async (err) =&gt; {<br/>    await logger.logError(err);<br/>    await sendEmail;<br/>    await saveInOpsQueueIfCritical;<br/>    await determineIfOperationalError;<br/>  };<br/>}</span></pre><p id="edf0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有一个中央错误处理器，可以导入到其他模块中。</p><h1 id="fbd9" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用Swagger或GraphQL记录API错误</h1><p id="6195" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们应该用Swagger或GraphQL记录REST APIs可能出现的错误。</p><p id="a661" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样，我们可以使用API并处理记录的错误。</p><p id="551e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们处理遇到的错误，那么它就不会崩溃。</p><h1 id="184f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">优雅地退出流程</h1><p id="9f12" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果遇到未知错误，我们应该使用流程管理器优雅地退出流程。</p><p id="8dd6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这可以通过永久或PM2的流程管理器来完成。</p><p id="5541" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果出现任何错误，这些工具可以重新启动我们的应用程序。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/d043b7d392d5491b4e2f0eac7485a7b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8rAw0T5mWqkE3Udp"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">Hassan OUAJBIR 在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="3808" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="9eb8" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们应该记录API可能抛出的任何错误，以便可以处理它们。</p><p id="1545" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">异步代码和使我们的应用程序可配置也是好主意。</p></div></div>    
</body>
</html>