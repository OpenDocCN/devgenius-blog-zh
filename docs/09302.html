<html>
<head>
<title>Implementing the autocomplete feature for a search engine</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为搜索引擎实现自动完成功能</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/implementing-the-autocomplete-feature-for-a-search-engine-6327a562b1cd?source=collection_archive---------7-----------------------#2022-08-13">https://blog.devgenius.io/implementing-the-autocomplete-feature-for-a-search-engine-6327a562b1cd?source=collection_archive---------7-----------------------#2022-08-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="5fd3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">第 1 部分:自动补全背后的结构</strong></p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/97f56adf45edb084b0e41aeff6dbd2ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Adu6Sk8oCF2I18OCXibOkQ.jpeg"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">来源:unsplash.com—<a class="ae lb" href="https://unsplash.com/@olloweb" rel="noopener ugc nofollow" target="_blank">@ alloweb</a></figcaption></figure><h1 id="4f56" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated"><strong class="ak"> TLDR: </strong></h1><p id="5b1c" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">你有没有想过，谷歌、亚马逊和互联网上的其他行为者如何能够立即预测你在他们的<strong class="jp ir">搜索框</strong>中键入的<strong class="jp ir">查询，并给出示例来完成它。如果是这样的话，本文将向您概述自动完成特性背后的基本算法。该算法可用于在用户</strong>进行的<strong class="jp ir">数百万次历史查询中检索不相关的<strong class="jp ir">建议</strong>。</strong></p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mf"><img src="../Images/53a167fc7452b7494ae5ddaec97cf23c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*3b6sfG7e0Z3pCqpTphUb3A.gif"/></div></div></figure><h1 id="d357" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated"><strong class="ak">简介:</strong></h1><p id="7e04" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">我最近读了一篇谷歌的文章，描述了他们搜索引擎中的自动完成功能。当我开始在搜索栏中输入几个字母时，我很想知道在幕后发生了什么，以获得建议列表。</p><p id="d3fd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">后来，我发现一个<strong class="jp ir">特定的</strong> <strong class="jp ir">数据结构</strong>是任何自动完成功能的第一个<strong class="jp ir">构件</strong>，无论是搜索引擎中的查询完成模块还是手机上的关键字建议模块...这个结构存储了<strong class="jp ir">历史查询</strong>，并使<strong class="jp ir">在实时环境中轻松快速地检索</strong>它们。因此，在几毫秒内，当有人开始输入时，<strong class="jp ir">信息被检索</strong>并且建议被显示在 UI 上。</p><p id="e686" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">显然，我认为谷歌和其他主要参与者正在他们的自动完成功能中投入越来越多的智能，以应对他们可能面临的搜索引擎使用越来越多的挑战。因此，他们不会只依赖这种技术，而是会利用一些人工智能模型，一旦收集到用户的数据，就可以获得更有针对性的建议。</p><p id="9e5d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第一篇文章的目标是探索这种数据结构，理解其背后的逻辑。第二篇文章随后是一个实际的用例，我们构建了一个 API，模拟了一个自动完成系统，有一百万个搜索查询历史数据库。</p><h1 id="c3e9" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated"><strong class="ak"> 1。它是如何工作的？</strong></h1><p id="ac22" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">作为一个搜索引擎用户，只要我们开始输入几个字符，自动完成功能就会给出一组建议，我们输入的字符越多，建议列表就越有针对性。所有这些都在几毫秒内发生，以保证流畅的用户体验。</p><p id="32ed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种特性背后的基本逻辑是向用户显示以键入的字符开始的前 N 个查询。基于<strong class="jp ir">的历史搜索数据</strong>，查询可以按照它们的<strong class="jp ir">频率</strong>进行排序，这样频繁的查询将首先出现。这是合理的，因为频率可以代表人们的兴趣。</p><p id="1128" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如前所述，我们认为，在当今的行业中，该功能可以利用除历史搜索数据之外的<strong class="jp ir">众多其他参数</strong>，例如，它可以使用当前趋势、用户兴趣、地理位置，并从人工智能研究的进步中获得优势，以个性化结果。</p><p id="452f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">也就是说，构建这样一个自动完成功能需要使用一个高效的数据结构来存储大量的历史数据，这样所需的信息很快就能被检索到。</p><h1 id="891c" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated"><strong class="ak"> 2。数据是如何存储的？</strong></h1><p id="c6cd" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">用于构建<strong class="jp ir">自动完成功能</strong>的最先进的结构是<strong class="jp ir"> trie </strong>(也称为<strong class="jp ir">前缀树</strong>)，这是一个 k 数组搜索树，意味着在每一层我们可以存储 k 个节点。</p><p id="ac7f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">历史查询字符以优化的方式存储，便于搜索。实际上，正如我们将在下面的章节中看到的，字符的存储方式和它们之间的链接允许快速找到共享相同前缀的查询<strong class="jp ir">。然而，由于我们存储节点和边的事实，它在<strong class="jp ir">内存消耗</strong>方面通常不如数组这样的经典结构有效(除非许多查询共享相同的前缀)。</strong></p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mg"><img src="../Images/3863b94702f79b84548506f4262d2dc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Kn4zNcMpxOrHXnZMiMuR_Q.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">一般的 trie 结构</figcaption></figure><p id="e34d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> 2.1 在 Trie 中存储历史数据</strong></p><p id="388c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">trie 结构要求共享相同前缀的所有查询<strong class="jp ir">都存储在子层中。</strong></p><p id="5e59" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是一个例子:假设我们在历史中有 6 个查询(帮助、隐藏、地狱、游戏、好、嗨),并希望将它们存储在一个 trie 中。</p><p id="600e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个过程包括遍历查询列表，一个字符一个字符地给每个字符分配正确的位置，如下图所示。请注意，前缀<strong class="jp ir"> he- </strong>在查询<strong class="jp ir"> help </strong>和<strong class="jp ir"> hell </strong>之间共享，因此这两者共享树的前三层(层 0 是根，在该结构中保持为空)。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/4e659c5d9ff7245009bf9c3d07ec67bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1222/format:webp/1*dbWrtEkaBlvCYz7qpaj11A.png"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">使用查询历史构建的前缀树结构</figcaption></figure><p id="abcf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可能会注意到，有些查询只是其他查询的子字符串。例如“hi”是“hide”的子串。我们应该在结构中考虑到这一点，添加一个查询结束标志。在我们的例子中，这个标志将是计数本身，它在查询的终端节点将是非空的。</p><p id="0c40" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> 2.2 包括查询频率</strong></p><p id="8f6b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以考虑两种逻辑，将来自历史数据的<strong class="jp ir">查询频率包含在真实世界的应用程序</strong>中，以便在执行搜索时，根据查询的出现次数对返回的查询进行排序。第一个将在建筑层面。事实上，我们可以考虑使用一种能够保持顺序的结构，而不是简单地遍历历史并将它存储在 trie 中。这样，我们可以确保在遍历 trie 进行搜索时，只需要返回前 N 个分支。</p><p id="d3b9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第二种方法将在<strong class="jp ir">中使用，我们在下面的文章</strong>中的实现将在每个查询的终端节点中存储频率。这些信息将帮助搜索算法<strong class="jp ir">检测查询的结尾</strong>和<strong class="jp ir">在历史数据中一次性获得它的出现</strong>。</p><p id="d4ca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们回到前面的例子，包括频率参数:(帮助:15，隐藏:20，地狱:10，游戏:1，好:1，嗨:10)</p><p id="7e56" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">新的 trie 如下所示:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/4dec4306f9391e7e0e208e9543e50c5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*_OmdKFGyXUcGCdBn70Z_rA.png"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">具有出现计数的 Trie 结构</figcaption></figure><p id="5344" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> 2.3 检索搜索结果</strong></p><p id="c193" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将对这一部分感兴趣，因为<strong class="jp ir">搜索算法</strong>返回与给定前缀匹配的<strong class="jp ir">查询。</strong></p><p id="a243" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们的例子中，输入“h”应该会返回(help，hell，hi，hide)。这包括循环输入查询(1 个字符)并在 trie 中找到构成前缀的路径。一旦找到，子树被递归地遍历<strong class="jp ir"/>，结果由所有的<strong class="jp ir">下游分支</strong>形成。可以通过检查非空的计数参数来检测分支(完整查询)的结束。</p><p id="97a8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们举第二个例子，用户输入前缀“he”，在这种情况下，子树根将是“e”，通过遍历它的分支，我们最终得到(help，hell)。一旦检索到，结果可以按频率排序<strong class="jp ir">，并且用户显示对应于前缀的前 N 个查询。</strong></p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mj"><img src="../Images/47eae277e14b1e9c13aca94db06cf596.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e3DVF97omW1_8crzfahrFw.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">遍历 trie 以检索共享相同前缀的查询</figcaption></figure><h1 id="1a0b" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated"><strong class="ak"> 3。这种结构效率有多高？</strong></h1><p id="3303" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">让我们试着分析一下这项技术的复杂性。我们用 n 表示查询的平均长度，用 M 表示查询历史的长度。</p><p id="d464" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> 3.1 插入过程</strong></p><p id="ae37" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了将一个新的字符串插入到 trie 中，我们需要遍历它并逐个字符地存储它。这是一个 O(n)操作，我们需要执行 M 次才能在第一次构建完整的树。</p><p id="a18e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> 3.1 搜索过程</strong></p><p id="1730" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了在 trie 中找到一个查询，我们需要深入它。时间复杂度也是 O(n)。正是在这里，所有的奇迹发生了，因为搜索是<strong class="jp ir">独立于历史数据集</strong> <strong class="jp ir">或特里树的大小。</strong>影响<strong class="jp ir">执行时间的唯一参数将是查询长度本身</strong>，它永远不会太大<strong class="jp ir">。</strong></p><h1 id="b1ed" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated"><strong class="ak">结论:</strong></h1><p id="02a5" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">在这篇文章中，我们看到了一个有趣的数据结构，它可以在我们的日常生活中得到应用，并且可以成为我们经常使用的自动补全功能的核心，无论是在搜索引擎、移动消息…</p><p id="5a33" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我们应该注意到，在搜索时间方面，trie 结构是有效的。然而，在存储和内存消耗方面，它可以使用其他结构<strong class="jp ir">三叉搜索树</strong>进一步优化<strong class="jp ir">。</strong></p><p id="4e4b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae lb" href="https://medium.com/@kaislar17/implementing-the-autocomplete-feature-for-a-search-engine-fe17cd4f9aa" rel="noopener">在下一篇文章</a>中，我们将提出这个结构和搜索算法的 python 实现。此外，我们将构建一个 API 来对 1M 真实查询历史样本执行自动补全。</p></div></div>    
</body>
</html>