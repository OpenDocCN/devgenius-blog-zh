# 设计模式—简介

> 原文：<https://blog.devgenius.io/design-patterns-introduction-6f12fd2c7c92?source=collection_archive---------7----------------------->

## GoF 设计模式综述

![](img/23597f03379626012f7ee5ee96ffd775.png)

封面艺术 1994 年 M·C·埃舍尔/荷兰波恩艺术区。保留所有权利。

在我开始谈论什么是设计模式之前，我想对这张图片说几句话，你可以在**设计模式的官方封面上看到——可重用面向对象软件的元素。**

如果你不知道谁是**莫里茨·科内利斯·埃舍尔**的话，他是二十世纪最伟大的艺术家之一，他创作了受数学启发的木刻、石版画和梅佐汀版画。

> 他的工作以数学对象和运算为特色，包括不可能的对象、对无限的探索、反射、对称、透视、截角和星形多面体、双曲几何和镶嵌。

开玩笑，上面的描述和你初学设计模式时的想法非常一致。我可以花几个小时来谈论我对这部杰作的看法，但最好是转向具体的，或者更确切地说是抽象的…

# 内容

*   什么是设计模式？
*   **描述设计模式**
*   **设计模式目录**
*   **组织目录**
*   **设计模式如何解决设计问题**

# 什么是设计模式？

克里斯托弗·亚历山大说，

> “每个模式描述了一个在我们的环境中反复出现的问题，然后描述了该问题解决方案的核心，这样你就可以使用这个解决方案一百万次，而不必以同样的方式做两次”[AIS+77，第 x 页]

对设计模式进行分类的最好方法可能是谈论它们的四个主要元素:

1.  **模式名称**只是描述模式的名称。通常是一两个字关系到他们的**解决**和**后果。**赋予一个**模式名称**我们可以用它来和我们的同事交谈，写文档和许多其他事情，而不会产生歧义。
2.  问题描述了我们何时应用模式。它可能是一种表示，例如如何将算法或数据结构实现为一个对象。
3.  **解决方案**描述了我们应该用来实现设计模式的元素。这些元素可以相互关联，协作和责任更重要。
4.  **后果**是设计模式应该回归的结果和权衡。

# 描述设计模式

D **设计模式——可重用面向对象软件的元素**这本书使用一致的格式描述设计模式。根据以下模板，每个图案被分成几个部分。

## 模式名称和分类

一个好名字是至关重要的，因为它将成为你设计词汇的一部分。模式的分类反映了我在第**节组织目录**中介绍的方案。

## 目的

以下问题:设计模式是做什么的？它的基本原理和意图是什么？解决了什么特殊的设计问题？

## 也被称为

该模式的其他众所周知的名称，如果有的话。

## 动机

说明设计问题以及模式中的类和对象结构如何解决问题的场景。

## 适应性

有哪些可以应用设计模式的情况？这种模式可以解决哪些糟糕的设计？你如何识别这些情况？

## 结构

模式中类的图形化表示，使用基于对象建模技术(OMT) [RBP+91]的符号。我还使用交互图来说明对象之间请求和协作的顺序。

## 参与者

参与设计模式的类和/或对象及其职责。

## 协作

参与者如何合作履行他们的职责。

## 结果

模式如何支持其目标？使用模式的权衡和结果是什么？

## 履行

在实现模式时，应该注意哪些陷阱、提示或技术？

## 示例代码

说明如何在 C++或 Smalltalk 中实现该模式的代码片段。

## 已知用途

真实系统中的模式示例。

## 相关模式

当设计模式与此密切相关时。

# 设计模式目录

*   **抽象工厂** — 提供一个接口，用于创建相关或依赖对象的系列，而无需指定它们的具体类。
*   **适配器** —将一个类的接口转换成客户期望的另一个接口。适配器允许类一起工作，否则由于不兼容的接口而无法工作。
*   **桥接**——将抽象从实现中分离出来，这样两者可以非常独立。
*   **构建器**—将复杂对象的构建与其表示分离，以便相同的构建过程可以创建不同的表示。
*   **责任链** —通过给多个对象一个处理请求的机会来避免请求的发送者和接收者之间的耦合。链接接收对象，并沿着链传递请求，直到有对象处理它。
*   **命令** — 将一个请求封装成一个对象，从而让你参数化不同请求的客户端，队列或日志请求，并支持可撤销操作。
*   **复合** —将对象组合成树形结构来表示部分-整体层次结构。Composite 允许客户端统一处理单个对象和对象的组合
*   装饰者(Decorator)—动态地给一个对象附加额外的责任。Decorators 为扩展功能提供了子类化的灵活替代方案。
*   **Facade** —为子系统中的一组接口提供统一的接口。Facade 定义了一个更高级的接口，使得子系统更容易使用。
*   **工厂方法** —定义创建对象的接口，但让子类决定实例化哪个类。工厂方法让一个类将实例化推迟到子类。
*   **Flyweight** — 利用共享高效支持大量细粒度对象。
*   **解释器** —给定一种语言，定义其语法的表示以及使用该表示来解释该语言中的句子的解释器。
*   **迭代器** —提供一种方法来顺序访问聚合对象的元素，而不暴露其底层表示。
*   **中介** — 定义一个对象，封装一组对象如何交互。Mediator 通过防止对象显式地相互引用来促进松散耦合，并允许您独立地改变它们的交互。
*   **Memento** —在不违反封装的情况下，捕获并具体化一个对象的内部状态，以便该对象可以在以后恢复到这个状态。
*   **观察者** —定义对象之间的一对多依赖关系，这样当一个对象改变状态时，它的所有依赖对象都会得到通知并自动更新。
*   **原型** —使用原型实例指定要创建的对象种类，并通过复制该原型创建新对象。
*   **代理** —为另一个对象提供代理或占位符，以控制对它的访问。
*   **Singleton** —确保一个类只有一个实例，并提供对它的全局访问点。
*   **状态** —允许对象在其内部状态改变时改变其行为。该对象看起来会改变它的类。
*   **策略** —定义一系列算法，封装每一个算法，并使它们可以互换。策略让算法独立于使用它的客户端而变化。
*   **模板方法** —在操作中定义算法的框架，将一些步骤推迟到子类。模板方法允许子类在不改变算法结构的情况下重新定义算法的某些步骤。
*   **访问者**——表示要在对象结构的元素上执行的操作。Visitor 允许您定义一个新的操作，而不改变它所操作的元素的类。

# 组织目录

![](img/b462602837f31d18e18c5722ae9c9571.png)

表 1.1:设计模式空间

设计模式在粒度和抽象层次上各不相同。分类有助于您更快地学习目录中的模式。

该书根据两个标准对设计模式进行了分类(表 1.1)。第一个标准叫做**目的**反映了模式的作用。模式可以有**创造**、**结构**或**行为**目的。创造模式关注对象创造的过程。结构模式处理类或对象的组成。行为模式描述了类或对象交互和分配责任的方式。

第二个标准称为**范围，**指定模式主要应用于类还是对象。类模式处理类和它们的子类之间的关系。对象模式处理对象关系，这种关系可以在运行时改变，并且更加动态。

# **设计模式如何解决设计问题**

![](img/b7469c69fd43841fc6df87a510bfa17e.png)

图 1.1:设计模式关系

## 寻找合适的对象

面向对象的编程是由对象组成的。一个**对象**打包了数据和操作这些数据的过程。这些程序通常被称为**方法**或**操作。**当一个对象从**客户端**接收到**请求**时，该对象执行一个操作。

面向对象设计最困难部分是将系统分解成对象，因为有许多因素在起作用:封装、粒度、依赖性、灵活性、性能、进化、可重用性等等。

面向对象的设计方法支持许多不同的方法。你可以写一个问题陈述，创建类和操作。或者你可以关注你系统中的协作。或者，您可以模拟真实世界，并将分析过程中发现的对象转化为设计。

设计模式帮助您识别不太明显的抽象以及能够捕捉它们的对象。例如，代表过程或算法的对象在自然界中并不存在。**策略**模式描述了如何实现可互换的算法家族。**状态**模式将一个实体每个状态表示为一个对象。

## 确定对象粒度

O 物体的大小和数量可以变化。它们可以代表从硬件到整个软件的一切。

设计模式也解决了这个问题。 **facade** 模式描述了如何将整个子系统表示为对象，而 **flyweight** 模式描述了如何以最细粒度支持大量对象

## 指定对象接口

由一个对象声明的每个操作都指定了操作的名称、作为参数的对象以及操作的返回值。这被称为操作的**签名**。由对象操作定义的所有签名的集合被称为对象的**接口**。

**类型**是用于表示特定接口的名称。如果一个对象接受在名为“Window”的接口中定义的所有操作请求，我们就说它具有“Window”类型相同类型的两个对象只需要共享它们接口的一部分。接口可以包含其他接口作为子集。我们说一个类型是另一个类型的**子类型**，如果它的接口包含它的**超类型**的接口。

当一个请求被发送给一个对象时，执行的特定操作依赖于*请求*和*接收对象。对一个对象的请求和它的操作之一的运行时关联被称为**动态绑定**。*

此外，动态绑定允许您在运行时替换具有相同接口的对象。这种可替代性被称为**多态性**，它是面向对象系统中的一个关键概念。

设计模式通过识别接口的关键元素和通过接口发送的数据类型来帮助您定义接口。

例如，Memento 模式描述了如何封装和保存对象的内部状态，以便稍后可以将对象恢复到该状态。

## 指定对象实现

一个对象的实现由其**类定义。**

![](img/538750e9df8ad22289378abc6e4c2af5.png)

通过**实例化**一个类来创建对象。据说该对象是该类的一个**实例**。实例化一个类的过程为对象的内部数据(由**实例变量**组成)分配存储空间，并将操作与这些数据相关联。

![](img/e5bf4e1b902a26bc6b5d1960912f88b1.png)

可以使用**类继承**根据现有类定义新类。当**子类**从**父类**继承时，它包含了父类定义的所有数据和操作的定义。

![](img/1625a40b86f89d9f4d6cf25c311f05c9.png)

抽象类**的主要目的是为它的子类定义一个公共接口。抽象类会将其部分或全部实现委托给子类中定义的操作；因此抽象类不能被实例化。一个**具体类**可能**覆盖**一个由其父类定义的操作。重写使子类有机会代替它们的父类处理请求。**

![](img/bef9042e548b6316c935b9fa9ab7a2c3.png)

一个 **mixin 类**是一个旨在为其他类提供可选接口或功能的类。它类似于一个抽象类，因为它不打算被实例化。Mixin 类需要多重继承:

![](img/224ec1c70450c145b9277cde6cc966ff.png)

## 类与接口继承

我理解对象的*类*和*类型*之间的区别很重要。

对象的类定义了对象是如何实现的。该类定义了对象的内部状态及其操作的实现。相比之下，对象的类型仅指其接口——它可以响应的请求集。一个对象可以有许多类型，不同类的对象可以有相同的类型。

理解类继承和接口继承(或子类型)之间的区别也很重要。类继承根据另一个对象的实现来定义一个对象的实现。简而言之，它是一种代码和表示共享的机制。相反，接口继承(或子类型)描述了什么时候一个对象可以用来代替另一个对象。

许多设计模式都依赖于这种区别。例如，在复合模式中，组件定义一个公共接口，但是复合通常定义一个公共实现。观察者、状态和策略通常用抽象类来实现。

## 让重用机制发挥作用

> **遗传与组合**

在面向对象系统中重用功能的两种最常见的技术是类继承和**对象组合**。正如我所解释的，类继承允许你根据一个类的实现来定义另一个类的实现。通过子类化的重用通常被称为**白盒重用。**

对象组合是类继承的替代方法。这里，新的功能是通过组装或*组合*对象来获得更复杂的功能。对象组合要求被组合的对象具有定义良好的接口。这种重用方式被称为**黑盒重用**，因为看不到对象的内部细节。

继承和合成各有利弊。类继承是在编译时静态定义的。这也使得修改被重用的实现变得更加容易。但是你不能在运行时改变从父类继承的实现，因为继承是在编译时定义的。子类的实现与其父类的实现如此紧密地联系在一起，以至于父类实现的任何变化都会迫使子类发生变化。

对象组合是在运行时通过对象获取对其他对象的引用来动态定义的。组合要求对象尊重彼此的接口。对象只能通过它们的接口来访问，我们不会破坏封装。任何对象都可以在运行时被另一个对象替换，只要它具有相同的类型。

优先使用对象组合而不是类继承有助于保持每个类都被封装并专注于一项任务。您的类和类层次结构将保持较小。另一方面，基于对象组合的设计会有更多的对象。

> **代表团**

D **elegation** 是一种让复合像继承一样强大的重用方式[Lie86，JZ91]。在委托中，*两个*对象参与处理一个请求:一个接收对象将操作委托给它的**委托人。**

不同于继承，因为它不再通过*这个*或*自我来访问。*例如，不是让类 Window 成为 Rectangle 的子类，Window 类可能通过保留一个 Rectangle 实例变量和*委托* Rectangle 特定的行为给它来重用 Rectangle 的行为。

![](img/399feb3557f6c7a20ceb8ed00687cd40.png)

委托的主要优点是它使得在运行时组合行为和改变它们的组合方式变得容易。如果我们愿意，我们的窗口可以在运行时变成圆形，假设矩形和圆形具有相同的类型。

委托与其他通过对象组合使软件更加灵活的技术有一个共同的缺点:动态的、高度参数化的软件比静态的软件更难理解。

几种设计模式使用委托。状态、策略和访问者模式都依赖于它。

> 继承与参数化类型

另一种(并非严格面向对象的)重用功能的技术是通过**参数化类型**，也称为**泛型**和**模板。**这种技术允许你定义一个类型，而不需要指定它使用的所有其他类型。

参数化类型给了我们第三种方式(除了类继承和对象组合)来组合面向对象系统中的行为。使用这三种技术中的任何一种都可以实现许多设计。

这些技术之间有重要的区别。对象组合允许你在运行时改变被组合的行为，但是它也需要间接性，并且效率较低。继承允许您为操作提供默认实现，并允许子类覆盖它们。参数化类型允许您更改类可以使用的类型。但是继承和参数化类型都不能在运行时改变。

## 关联运行时和编译时结构

考虑对象**聚集**和**相识**之间的区别，以及它们在编译和运行时表现出的不同。聚合意味着一个对象拥有或负责另一个对象。通常我们说一个物体拥有另一个物体或者是另一个物体的一部分。

相识意味着一个对象仅仅知道另一个对象。有时熟人被称为“协会”或“使用”关系。熟悉的对象可以请求彼此的操作，但是它们对彼此不负责。

在这些图中，一条普通的箭头线表示相识。底部带菱形的箭头线表示聚合:

![](img/57e7ad0d915abd61b4318e2c845576d1.png)

## 为改变而设计

最大化重用的关键在于预测新的需求和对现有需求的改变，并且设计你的系统，使它们能够相应地发展。

设计模式通过确保系统能够以特定的方式改变来帮助您避免这种情况。

有一些重新设计的常见原因以及解决这些原因的设计模式:

*   *通过明确指定类来创建对象。*当你创建一个对象时，指定一个类名会给你一个特定的实现，而不是一个特定的接口。设计模式:抽象工厂、工厂方法、原型。
*   *对特定操作的依赖。当你指定一个特定的操作时，你承诺用一种方式来满足一个请求。通过避免硬编码的请求，您可以更容易地改变在编译时和运行时满足请求的方式。设计模式:责任链，命令。*
*   *算法依赖。*在开发和重用过程中，算法经常被扩展、优化和替换。当算法改变时，依赖于算法的对象也必须改变。因此，可能改变的算法应该被隔离。设计模式:构建器，迭代器，策略，模板方法，访问者。
*   *紧耦合。紧密耦合会导致整体系统，在这种系统中，如果不理解和更改许多其他类，就不能更改或删除一个类。这个系统变成了一个难以学习、移植和维护的密集体。设计模式使用抽象耦合和分层等技术来促进松散耦合的系统。设计模式:抽象工厂、桥梁、责任链、命令、门面、中介、观察者。*
*   通过子类化扩展功能。通过子类化来定制一个对象通常并不容易。每个新类都有固定的实现开销。定义子类还需要对父类有深入的理解。一般来说，对象组合，特别是委托，为组合行为提供了继承的灵活替代方案。通过以新的方式组合现有对象，而不是通过定义现有类的新子类，可以将新功能添加到应用程序中。设计模式:桥梁、责任链、复合、装饰、观察者、策略。