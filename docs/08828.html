<html>
<head>
<title>A Case About Java Static Keyword During My Job</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">工作中遇到的一个关于 Java 静态关键字的案例</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/a-case-about-java-static-keyword-during-my-job-53cebb6af597?source=collection_archive---------1-----------------------#2022-07-13">https://blog.devgenius.io/a-case-about-java-static-keyword-during-my-job-53cebb6af597?source=collection_archive---------1-----------------------#2022-07-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="bd05" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi kl translated">本周二，在工作中，我遇到了一个关于静态关键字用法的案例，我认为这是一个有趣的分享。</p><h2 id="3814" class="ku kv iq bd kw kx ky dn kz la lb dp lc jy ld le lf kc lg lh li kg lj lk ll lm bi translated">方案</h2><p id="00c6" class="pw-post-body-paragraph jn jo iq jp b jq ln js jt ju lo jw jx jy lp ka kb kc lq ke kf kg lr ki kj kk ij bi translated">在一个<em class="ls">orderservice</em>类中，我们有一个包含订单项目<em class="ls">T5】信息的散列表。在同一个类中，我们有一个<em class="ls"> put() </em>方法来接受一个<em class="ls"> Order </em>对象，并将其放入提到的 map 中。为了便于说明，我们使用<em class="ls"> orderId </em>作为键，使用<em class="ls"> itemId </em>作为下面的值。</em></p><p id="f99d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">订单服务类</strong></p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="51f9" class="ku kv iq ly b gy mc md l me mf">public class OrderService {</span><span id="87ce" class="ku kv iq ly b gy mg md l me mf">    private final Map&lt;String, String&gt; orderItemMap = new HashMap&lt;&gt;();</span><span id="2553" class="ku kv iq ly b gy mg md l me mf">    //class constructor</span><span id="c580" class="ku kv iq ly b gy mg md l me mf">    public void put(Order order){<br/>        orderItemMap.put(order.getOrderId(), order.getItemId());<br/>    }<br/>}</span></pre><p id="46b7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">订单类别</strong></p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="32a5" class="ku kv iq ly b gy mc md l me mf">private class Order{<br/>    String orderId;<br/>    String itemId;<br/><br/>// getters and setters<br/>}</span></pre><p id="00be" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下午，我的同事提交了一个新代码，在<em class="ls"> OrderService </em>类中有一个<em class="ls"> load() </em>方法。这个<em class="ls"> load() </em>方法接受一列<em class="ls"> Order </em>对象，并遍历所有对象以调用<em class="ls"> put() </em>方法，并将<em class="ls"> orderId-itemId </em>作为键-值对存储在映射中。</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="f9fa" class="ku kv iq ly b gy mc md l me mf">public void load(List&lt;Order&gt; orders){<br/>    orders.forEach(OrderService::put);<br/>}</span></pre><p id="6b8d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">看起来没错吧？</p><p id="9005" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">顺便说一下，这里我的同事使用 Java 函数式编程技术使代码更简洁，而不是使用一个笨拙的 while 循环进行列表迭代。如果您想使用函数式编程来提高您的编码技能，请在这里阅读我的文章。</p><div class="mh mi gp gr mj mk"><a href="https://medium.com/geekculture/java-coding-tip-functional-programming-1b6278e48efa" rel="noopener follow" target="_blank"><div class="ml ab fo"><div class="mm ab mn cl cj mo"><h2 class="bd ir gy z fp mp fr fs mq fu fw ip bi translated">Java 编码技巧—函数式编程</h2><div class="mr l"><h3 class="bd b gy z fp mp fr fs mq fu fw dk translated">方案</h3></div><div class="ms l"><p class="bd b dl z fp mp fr fs mq fu fw dk translated">medium.com</p></div></div><div class="mt l"><div class="mu l mv mw mx mt my mz mk"/></div></div></a></div><p id="da47" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">回到故事，在同一个提交中，新的 put 方法添加了'<em class="ls"> static </em>'关键字，对于 map 对象也是如此。</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="29c7" class="ku kv iq ly b gy mc md l me mf">private static final Map&lt;String, String&gt; <em class="ls">orderItemMap </em>= new HashMap&lt;&gt;();</span><span id="9566" class="ku kv iq ly b gy mg md l me mf">public static void put(Order order){<br/>    <em class="ls">orderItemMap</em>.put(order.getOrderId(), order.getItemId());<br/>}</span></pre><p id="c87f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在看新代码的时候，我想知道为什么它们被添加了静态关键字。一个<em class="ls"> orderItemMap </em>应该特定于一个<em class="ls"> OrderService </em>实例类。如果它变成静态的，那么每个<em class="ls"> OrderService </em>实例将共享地图的相同副本。</p><figure class="lt lu lv lw gt nb gh gi paragraph-image"><div class="gh gi na"><img src="../Images/cea05eacabd3e792ca3cb81011d5328b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1288/format:webp/1*Z6zK2eQtKJYRhZHEQfQAlg.png"/></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk translated">使用静态关键字</figcaption></figure><figure class="lt lu lv lw gt nb gh gi paragraph-image"><div class="gh gi na"><img src="../Images/e89380dd4f08993fecb4df0bce2aa8d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1288/format:webp/1*c5vEPlWnSkuf9yOLsNw0bA.png"/></div><figcaption class="nd ne gj gh gi nf ng bd b be z dk translated">没有静态关键字</figcaption></figure><p id="77e0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，我试图删除<em class="ls"> orderItemMap </em>字段和<em class="ls"> put </em>方法的静态关键字。以下错误显示:</p><figure class="lt lu lv lw gt nb gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/02c26b0eb0178d0f59f5c316b518351f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1124/format:webp/1*RE8aflvptsvtPDOBxMgXew.png"/></div></figure><figure class="lt lu lv lw gt nb gh gi paragraph-image"><div role="button" tabindex="0" class="nj nk di nl bf nm"><div class="gh gi ni"><img src="../Images/2ca40ac21d55c9377f0a96c65cfe6bf2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-Lm-hOWqvN-f-lsl83CidA.png"/></div></div></figure><p id="d567" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">forEach 方法中出现“不能从静态上下文引用非静态方法”错误。</p><h2 id="b804" class="ku kv iq bd kw kx ky dn kz la lb dp lc jy ld le lf kc lg lh li kg lj lk ll lm bi translated">为什么会这样呢？</h2><p id="77f7" class="pw-post-body-paragraph jn jo iq jp b jq ln js jt ju lo jw jx jy lp ka kb kc lq ke kf kg lr ki kj kk ij bi translated">在我同事的 commit 中，在对订单列表进行迭代时，给出了<em class="ls"> OrderService </em>类中<em class="ls"> put() </em>的方法引用。这个 OrderService 类是类路径中的“主”类，而不是实例类。因此，方法引用期望即使没有创建<em class="ls"> OrderService </em>类的实例，也可以调用<em class="ls"> put() </em>方法。如果在 IntelliJ IDE 中按<strong class="jp ir"> Alt + Enter </strong>，建议的解决方案是在<em class="ls"> put </em>方法和 map 字段中添加<em class="ls"> static </em>关键字，这就是为什么我们看到上面添加了<em class="ls"> static </em>关键字。</p><h2 id="8c9e" class="ku kv iq bd kw kx ky dn kz la lb dp lc jy ld le lf kc lg lh li kg lj lk ll lm bi translated">如何化解？</h2><p id="1e3d" class="pw-post-body-paragraph jn jo iq jp b jq ln js jt ju lo jw jx jy lp ka kb kc lq ke kf kg lr ki kj kk ij bi translated">知道 map 字段和 put 方法都是特定于实例的，我们只需要从一个实例类调用，而不是从主<em class="ls"> OrderService </em>类调用。我们所要做的就是将方法引用类从<em class="ls"> OrderService </em>改为<em class="ls"> this </em>关键字:</p><figure class="lt lu lv lw gt nb gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/7ab631c558207313d86c5680ff09669d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1118/format:webp/1*3OkM6FzJIpOb83jCvroeRg.png"/></div></figure><p id="2116" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">"<em class="ls">这个</em>关键字指的是当前的实例类。因此，这里的<em class="ls"> put </em>方法不再来自于<em class="ls"> OrderService </em>主类。这有助于我们避免在其他地方添加静态关键字。</p></div><div class="ab cl no np hu nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="ij ik il im in"><p id="0fc4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我希望这篇文章对你有所帮助。如果你像我一样，渴望学习 Java 和更多关于后端工程的知识，或者定期反思工作和生活，请关注我的频道，了解我在日常工作和生活中获得的灵感。</p><blockquote class="nv nw nx"><p id="c03c" class="jn jo ls jp b jq jr js jt ju jv jw jx ny jz ka kb nz kd ke kf oa kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="iq">阅读更多:</em></strong><em class="iq"><br/></em><a class="ae ob" href="https://medium.com/geekculture/a-glance-on-conversion-from-bytecode-to-class-objects-in-jvm-e828559984d9" rel="noopener"><em class="iq">JVM 中字节码到类对象转换一瞥</em></a><em class="iq"><br/></em><a class="ae ob" href="https://medium.com/geekculture/how-to-auto-generate-repetitive-java-code-to-save-your-time-c89a57652e90" rel="noopener"><em class="iq">如何自动生成重复的 Java 代码以节省时间</em> </a></p></blockquote></div></div>    
</body>
</html>