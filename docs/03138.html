<html>
<head>
<title>Object-Oriented JavaScript — Aggregation, and Inheritance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向对象的 JavaScript——聚合和继承</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/object-oriented-javascript-aggregation-and-inheritance-1e140bb3adc0?source=collection_archive---------1-----------------------#2020-10-04">https://blog.devgenius.io/object-oriented-javascript-aggregation-and-inheritance-1e140bb3adc0?source=collection_archive---------1-----------------------#2020-10-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/7e45c99575345a97378f75dc0ab47691.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*svLtHrl6UrrvxPzD"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@kimtheris?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Sereja Ris </a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="f0e9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JavaScript 部分是面向对象的语言。</p><p id="7b04" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要学习 JavaScript，我们必须学习 JavaScript 的面向对象部分。</p><p id="6eb1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将介绍 JavaScript 的面向对象部分。</p><h1 id="2c60" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">聚合</h1><p id="65f6" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">将几个对象组合成一个新对象的能力称为聚合或合成。</p><p id="d272" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">多个小对象比一个大对象更容易管理。</p><p id="2653" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用 JavaScript 有几种方法。</p><p id="ff03" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以使用扩展操作符或<code class="fe me mf mg mh b">Object.assign</code>方法将多个对象合并成一个。</p><p id="eaec" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要使用<code class="fe me mf mg mh b">Object.assign</code>方法，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="4ccd" class="mq lc iq mh b gy mr ms l mt mu">const obj1 = {<br/>  foo: 1<br/>}<br/>const obj2 = {<br/>  bar: 2<br/>}<br/>const obj3 = {<br/>  bax: 3<br/>}</span><span id="9478" class="mq lc iq mh b gy mv ms l mt mu">const merged = Object.assign({}, obj1, obj2, obj3);</span></pre><p id="6463" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有 3 个对象，我们把它们都传递给了<code class="fe me mf mg mh b">Object.assign</code>，这样我们就可以把它们合并在一起，并返回一个包含所有这些属性的新对象。</p><p id="8be5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们可以通过编写以下内容来使用 spread 运算符:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="6c71" class="mq lc iq mh b gy mr ms l mt mu">const obj1 = {<br/>  foo: 1<br/>}<br/>const obj2 = {<br/>  bar: 2<br/>}<br/>const obj3 = {<br/>  bax: 3<br/>}</span><span id="375b" class="mq lc iq mh b gy mv ms l mt mu">const merged = {<br/>  ...obj1,<br/>  ...obj2,<br/>  ...obj3<br/>};</span></pre><p id="9b58" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这也将把三个物体结合在一起。</p><p id="2fd2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">聚合对象的另一种方法是通过将作为另一个对象的属性来拥有子对象。</p><p id="5231" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，<code class="fe me mf mg mh b">Book</code>对象可以有多个<code class="fe me mf mg mh b">Author</code>对象、<code class="fe me mf mg mh b">Publisher</code>对象、<code class="fe me mf mg mh b">Chapter</code>对象等等。</p><h1 id="89ff" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">遗产</h1><p id="21fe" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">继承是让重用现有代码的一种优雅方式。</p><p id="527f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以创建对象并直接继承。</p><p id="8e49" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以用子类创建 JavaScript 类。</p><p id="a040" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">类和子类是父构造函数和子构造函数的语法糖。</p><p id="8971" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要创建一个使用另一个对象作为原型的对象，我们可以使用<code class="fe me mf mg mh b">Object.create</code>方法。</p><p id="37d4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="35d7" class="mq lc iq mh b gy mr ms l mt mu">const obj = {<br/>  foo: 1<br/>}</span><span id="3476" class="mq lc iq mh b gy mv ms l mt mu">const child = Object.create(obj);</span></pre><p id="47f2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后<code class="fe me mf mg mh b">child</code>从<code class="fe me mf mg mh b">obj</code>的<code class="fe me mf mg mh b">foo</code>属性中继承。</p><p id="43dc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果没有明确继承任何东西，大多数对象都以<code class="fe me mf mg mh b">Object.prototype</code>为原型。</p><p id="acfe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以用关键字<code class="fe me mf mg mh b">extends</code>创建子类。</p><p id="02e7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="2eee" class="mq lc iq mh b gy mr ms l mt mu">class Person {<br/>  constructor(name) {<br/>    this.name = name;<br/>  }</span><span id="b23c" class="mq lc iq mh b gy mv ms l mt mu">  eat() {<br/>    //...  <br/>  }<br/>}</span><span id="08a2" class="mq lc iq mh b gy mv ms l mt mu">class Author extends Person {<br/>  constructor(name, genre) {<br/>    super(name);<br/>    this.genre = genre;<br/>  }<br/>}</span></pre><p id="76f5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有<code class="fe me mf mg mh b">Person</code>类，它是父类。</p><p id="de73" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并且<code class="fe me mf mg mh b">Author</code>类继承自<code class="fe me mf mg mh b">Person</code>类。</p><p id="ca95" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所有的实例变量和方法都是继承的。</p><p id="ebd1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们可以获取<code class="fe me mf mg mh b">name</code>属性，并使用<code class="fe me mf mg mh b">Author</code>实例调用<code class="fe me mf mg mh b">eat</code>方法。</p><p id="f322" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用<code class="fe me mf mg mh b">super</code>调用父构造函数。</p><p id="9186" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也可以用它来访问父类的属性和方法。</p><p id="a1e3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="271e" class="mq lc iq mh b gy mr ms l mt mu">class Person {<br/>  constructor(name) {<br/>    this.name = name;<br/>  }</span><span id="a380" class="mq lc iq mh b gy mv ms l mt mu">  eat() {<br/>    //...  <br/>  }<br/>}</span><span id="7ba7" class="mq lc iq mh b gy mv ms l mt mu">class Author extends Person {<br/>  constructor(name, genre) {<br/>    super(name);<br/>    this.genre = genre;<br/>  }</span><span id="0f16" class="mq lc iq mh b gy mv ms l mt mu">  eat() {<br/>    super.eat();<br/>  }</span><span id="d9f2" class="mq lc iq mh b gy mv ms l mt mu">  write() {<br/>    console.log(`${super.name} is writing`)<br/>  }<br/>}</span></pre><p id="4b0f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们称之为<code class="fe me mf mg mh b">Person</code>的<code class="fe me mf mg mh b">eat</code>方法。</p><p id="b53f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用<code class="fe me mf mg mh b">super.name</code>得到了<code class="fe me mf mg mh b">Person</code>实例的<code class="fe me mf mg mh b">name</code>。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/ff1ccd54de55fdd9b284cb0a0b22d15c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*C0ONrCzREY4isthJ"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@niuhang?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">挂牛</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上</figcaption></figure><h1 id="b482" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="7b56" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以以多种形式聚集对象。</p><p id="ed8c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对象和构造函数/类可以分别从其他对象和构造函数/类继承。</p></div></div>    
</body>
</html>