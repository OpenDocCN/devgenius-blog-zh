<html>
<head>
<title>Concurrent file download with Go.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Go 并发文件下载。</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/concurrent-file-download-with-go-495d7b946492?source=collection_archive---------2-----------------------#2022-08-22">https://blog.devgenius.io/concurrent-file-download-with-go-495d7b946492?source=collection_archive---------2-----------------------#2022-08-22</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="fff2" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">我下载数据并合并的方法。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/4b335855f085d75ee2c61f48f56b89d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dAECVC1W77yKneLc"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">图片由<a class="ae ks" href="https://unsplash.com/@shuaibk" rel="noopener ugc nofollow" target="_blank"> Shuaib Khokhar </a>通过 unsplash 提供。</figcaption></figure><p id="11c2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">独立的下载管理器在 21 世纪初很流行。这是由于缓慢和不稳定的互联网。一般来说，下载管理器允许用户暂停下载。一个内置浏览器下载选项后来被采用。独立的下载管理器也更擅长处理网络错误，因为你可以从下载停止的地方继续下载。近年来，浏览器开始内置下载管理器，导致独立的下载管理器不再流行。在这篇文章中，我将尝试构建一个并发文件下载程序。目的是创建一个下载工具，它可以处理错误，而无需重新启动整个下载。这将通过分块下载文件来实现。因为我是成块下载的，所以让它并发是很自然的。</p><h1 id="f855" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">这个想法</h1><p id="14d4" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">我的想法是从用动词<code class="fe mm mn mo mp b">HEAD</code>向下载 URL 发出 HTTP 请求开始的。在某些服务器上，返回的头之一是<code class="fe mm mn mo mp b">Content-Length</code>。这个文件头以字节为单位指定了文件的大小。一旦知道了文件大小，我将分派多个 Goroutines，每个 Goroutines 都分配有一个要下载的数据范围。Goroutine 将使用动词<code class="fe mm mn mo mp b">GET</code>对 URL 执行 HTTP 请求，以执行下载。该请求将具有报头<code class="fe mm mn mo mp b">Range</code>。这个头将告诉服务器要返回多少文件。在 Goroutine 完成下载后，数据将通过 channel 发送回来。一旦所有的 Goroutines 都完成了，我将连接数据并写出文件。下图说明了下载是如何分派的:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mq"><img src="../Images/58614ae2576fe3ebbc65e9b0bf2b93a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l7ZN2cQu5PxFSyW0ylPDNQ.png"/></div></div></figure><h1 id="9d68" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">代码</h1><p id="6fc2" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">首先，我将为工具定义常量变量。以下是我的常数:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="031a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">接下来，我将定义一个结构类型。我将使用这个结构作为通道类型。该结构将有两个字段。一个用于存放数据，另一个指定其在最终文件中的位置。这种类型的定义如下:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="7777" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我将继续定义一个“字节数组”的数组。这个数组将存放我的文件的不同部分。我用固定长度来定义它。接下来，我将导入<code class="fe mm mn mo mp b">net/http</code>来执行初始请求。该请求将有动词<code class="fe mm mn mo mp b">HEAD</code>，因为我只是试图获取文件的信息。一旦请求完成，我将检查名为<code class="fe mm mn mo mp b">Content-Length</code>的头，如果头不存在，程序将出错退出。如果头文件存在，我将用文件大小除以工作线程数。得到的数字将是一个块的大小。下面是执行此操作的代码:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="0a32" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">为了执行实际的下载，我将添加一个名为<code class="fe mm mn mo mp b">download</code>的函数。该函数将有 3 个参数:</p><ul class=""><li id="187d" class="mt mu in kv b kw kx kz la lc mv lg mw lk mx lo my mz na nb bi translated"><code class="fe mm mn mo mp b">index int</code>:指定该函数将下载文件的哪一部分。</li><li id="2ce5" class="mt mu in kv b kw nc kz nd lc ne lg nf lk ng lo my mz na nb bi translated"><code class="fe mm mn mo mp b">size int</code>:文件块的大小。</li><li id="3414" class="mt mu in kv b kw nc kz nd lc ne lg nf lk ng lo my mz na nb bi translated"><code class="fe mm mn mo mp b">c chan Part</code>:用于将数据返回给调用 Goroutine 的线程的通道。</li></ul><p id="9ac4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">该函数将在下载请求中添加标题<code class="fe mm mn mo mp b">Range</code>。这个头文件将指定获取文件的哪些部分。一旦 HTTP 请求完成，数据就被写入通过函数调用传递的通道。下面是功能<code class="fe mm mn mo mp b">download</code>的代码:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="5ac9" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">回到主线程，我将用一个循环启动 workers。发送后，我会读取发送到频道的数据。返回的数据将有字段<code class="fe mm mn mo mp b">Index</code>。该字段将指定数据在最终文件中的位置。在通道写入数等于工作线程数后，我将停止读取数据。以下是执行这些任务的代码:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="5086" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">循环结束后我会收集数据。我将通过初始化一个字节数组来做到这一点。这个数组将作为一个缓冲器。为了写入这个缓冲区，我将遍历数组<code class="fe mm mn mo mp b">parts</code>。我将使用内置函数<code class="fe mm mn mo mp b">append</code>将数据写入“缓冲区”一旦合并完成，我将把缓冲区的字节写入一个文件。下面是执行此操作的代码:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="c871" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">为了测试是否有数据丢失，我会将这个程序生成的文件与用 chrome 下载的相同文件进行比较。如果文件不同，该命令将输出一条消息说明这一点。下面是实际运行的代码:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nh"><img src="../Images/270c7c3f4f3360c8640440b8df0f4527.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-coilFnVijFHa_eu.gif"/></div></div></figure><h1 id="c5e2" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">好处</h1><p id="2ef5" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">并发下载的好处之一是提高了容错能力。它通过增加多个故障点来提高容错能力。对于遇到的每个错误，下载不需要从头开始。需要注意的一点是，这个解决方案并不是一直都有效。您下载的服务器必须提供头文件<code class="fe mm mn mo mp b">Content-Length</code>。服务器还必须能够解析请求头<code class="fe mm mn mo mp b">Range</code>。提供的 URL 也必须是指向该文件的直接链接。你可以在下面找到这篇文章中使用的代码。</p><h1 id="86ac" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">附加链接</h1><div class="ni nj gp gr nk nl"><a href="https://github.com/cheikhshift/medium_examples/tree/main/concurrent-download" rel="noopener  ugc nofollow" target="_blank"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd io gy z fp nq fr fs nr fu fw im bi translated">medium _ examples/concurrent-在 main cheikh shift/medium _ examples 下载</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">中型文章的代码示例。在 GitHub 上创建一个帐户，为 cheikhshift/medium_examples 开发做贡献。</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">github.com</p></div></div><div class="nu l"><div class="nv l nw nx ny nu nz km nl"/></div></div></a></div></div></div>    
</body>
</html>