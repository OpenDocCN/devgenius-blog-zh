<html>
<head>
<title>How to Analyze TCP dump for SLOW backends (Demo Using Wireshark)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何分析慢速后端的 TCP 转储(使用 Wireshark 演示)</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-to-analyze-tcp-dump-for-slow-backends-demo-using-wireshark-1a350379115f?source=collection_archive---------6-----------------------#2022-07-05">https://blog.devgenius.io/how-to-analyze-tcp-dump-for-slow-backends-demo-using-wireshark-1a350379115f?source=collection_archive---------6-----------------------#2022-07-05</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="b4d3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">读者们好，</p><p id="7997" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">大多数遇到问题的开发人员都说系统很慢，或者有时很慢。但是开发商并不是唯一对这个问题负责的人。网络参与、机器参与、基础设施参与和许多其他因素都涉及到这里。但是开发人员承担了责任，因为我们是开发这些系统的人。</p><p id="8335" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这个演示中，我使用了我在以前的文章中包含的代码片段(<a class="ae ki" rel="noopener ugc nofollow" target="_blank" href="/software-engineer-must-know-about-http-keep-alive-demo-using-wireshark-8bb2803eecf3">https://blog . dev genius . io/software-engineer-must-know-about-http-keep-alive-demo-using-wireshark-8bb 2803 eecf 3</a>)。我对代码做了小的修改。以下快照如下。我在这里使用了 post 而不是 get。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/dd692d1577e004c43950d48024a7f8db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zwjjJQqhdfMpgSszEUPgng.png"/></div></div></figure><p id="08d1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在下面的快照中，我使用名为失眠症的应用程序向后端发送大文件和小文本。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kv"><img src="../Images/2937d1da50751170a30d1339ad57ef2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uhjJrPVX2pYG-trjuhIlhw.png"/></div></div></figure><p id="f739" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一旦您运行服务器，并从失眠发送初始交易，让我们检查 Wireshark。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kw"><img src="../Images/a19029ae72af58b3c5b5af0bb2116455.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iDNjzfuhN9MDHw15Y2qOxA.png"/></div></div></figure><p id="712a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这里，我们可以看到最初的连接已经完成，如前 3 行所示。通常的 TCP 三次握手。此外，我还添加了两个额外的列，称为<strong class="jm io">、</strong>和<strong class="jm io">、【计算窗口大小】。</strong></p><p id="91bd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在上面的第 3 行快照中，有一个叫做窗口大小的东西。在这里是<strong class="jm io"><em class="kx">‘Win = 2619648’。</em> </strong>初始<strong class="jm io"> <em class="kx"> </em> </strong>初始要求<strong class="jm io"> <em class="kx"> </em>窗口大小为 65535。</strong>简单来说，窗口大小意味着我们得到的最大接收缓冲区大小。<strong class="jm io"> </strong>如果是客户端则客户端接收缓冲区，如果是服务器则服务器接收缓冲区大小。</p><p id="e7c0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果我们选择 7 号线。如果我们仔细观察，</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi ky"><img src="../Images/7ccdd54a5ba744f4a8f8bcdd0e866766.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d3cz06F89kKSNM6h3WnrSQ.png"/></div></div></figure><p id="299c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">从客户端到服务器。显示窗口是 10233。如果我们得到最初的一个窗口大小，它表示 65535。这 65535 字节意味着一个巨大的数字。如果我们上传或下载 2gb 的文件，想象一下，我们发送 65535 字节，然后确认，我们再次发送 65535 字节，然后确认，一次又一次，它将永远需要下载。因为它非常慢。</p><p id="2db4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">随着协议或网络的发展，当我们试图处理大文件时，我们希望有更多的空间。所以他们所做的是</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kz"><img src="../Images/68deb420fdb77a1a0e6a083d43cf04b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hH4i-gn-2cyHNGhmVda7DA.png"/></div></div></figure><p id="bee7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当我们转到选项时，有一个名为窗口缩放的标志。窗口缩放意味着 8，这是 2⁸，是 256。这意味着虽然我们的谈判是 65535，但我可以接受 256 倍。</p><p id="2e01" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果您在 Wireshark snap 中检查一些数据包，如第 7 行。我们看不到窗口缩放选项。因为这只发生在握手过程中。如果分析我们的缓慢，我们需要确保我们捕获同步同步 ACK ACK 数据包。因为我们需要确保带宽得到充分利用。</p><p id="4e44" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们上传一个大文件，看看发生了什么</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi la"><img src="../Images/f51e36743353e0958eb46264eab13649.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YsX43nCE9kPnw-8GUA4cDw.png"/></div></div></figure><p id="ba9d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此上传文件大小为 458kb。点击发送上传文件后</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi lb"><img src="../Images/e1bbb96447c61cef2ef62c469da76099.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fLK-kl1AglFPnhYI3k7nFQ.png"/></div></div></figure><p id="9046" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">正常的 3 次握手连接发生在前 3 行。如果我们仔细观察第 333 到 343 行，窗口大小 2619648 逐渐下降。同样，344 行得出的值是 2619648，这非常重要。</p><p id="c3b0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当我们处理计算出的缓冲窗口大小时，这意味着服务器会打开一定大小的窗口。</p><p id="364e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">例如，服务器说我的尺寸是 100，所以客户端向服务器发送 100 尺寸的数据。现在服务器有 100 个。但是这里的服务器有一些其他的应用程序在运行。因为服务器只是第 7 层中的一个协议和应用程序，所以应用程序向客户端发送信息，客户端将信息发送给服务器。因此服务器上的应用程序从缓冲区中获取它。当客户端向服务器发送 100，服务器向客户端返回 ACK 时。同时，运行在服务器上的应用程序消耗了缓冲区中的 90%。还剩 10 个。再一次，服务器会要求客户机为 90 以保持缓冲区大小。<br/>现在客户端发送 90，服务器应用消费 70。服务器再次向客户端询问 70。所以我们可以看到这一直在下降。</p><blockquote class="lc ld le"><p id="ab7e" class="jk jl kx jm b jn jo jp jq jr js jt ju lf jw jx jy lg ka kb kc lh ke kf kg kh ig bi translated">下一次接受=全尺寸(-)保留在缓冲区中</p></blockquote><p id="40bf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以这个问题的出现是由于持续下降和它的命中率为零。这是我们需要小心的事情。因为虽然我们在高速服务器应用程序中传输数据，但是在第 7 层的应用程序并不以同样的速度消耗数据。</p><p id="f120" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">由于某种原因，如果它达到零，现在它被称为零窗口情况。因此，服务器告诉客户端，缓冲区中的所有空间都已满，客户端需要等待。假设 1 秒钟后，服务器说窗口更新 30 大小，服务器要求客户端发送 30。我们可以看到有一个滞后，因为零乘零窗口有一个滞后。<br/>如果你发现你的系统很慢，你看到零窗口包，那么你需要解决这个问题。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi lb"><img src="../Images/e1bbb96447c61cef2ef62c469da76099.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fLK-kl1AglFPnhYI3k7nFQ.png"/></div></div></figure><p id="6fd3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果我们仔细检查前 3 行中的 3 次握手，如果我们查看 Delta 时间列响应或 RTT 在毫秒内出现。如果这里有延迟，我们必须查看。因为将数据包发送到服务器，然后从服务器返回，我们需要这么多时间。所以每次握手花的时间。</p><p id="1086" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">问题是，如果服务器发送 100 个字节，其中 SYN 为 1。客户端必须确认 101 字节，这是服务器清空发送缓冲区直到数据进入服务器发送缓冲区的时间。如果服务器需要时间来响应，这意味着服务器 ACK 变慢，意味着服务器需要在发送缓冲区中保存更多的数据而不清除，即使它发送了它。由于服务器发送缓冲区已满，下一个到达服务器的数据无法放入。所以现在传输很慢。</p><p id="8618" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有一种东西叫 TCP 重传。让我们以前一个案例为例。服务器发送 100 字节，但是客户端没有向服务器确认。所以服务器在等待。当服务器超时触发但客户端向服务器发送 ACK 时，服务器再次向客户端发送相同的 SEQ 和 ACK。如果你看到连接很慢，你可以看到服务器向客户端发送多次重新传输。</p><p id="c9c8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">参考:</p><p id="309b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae ki" href="https://youtu.be/Ca9ZRyzeauo" rel="noopener ugc nofollow" target="_blank">https://youtu.be/Ca9ZRyzeauo</a></p></div></div>    
</body>
</html>