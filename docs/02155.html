<html>
<head>
<title>Build a performant autocomplete using Phoenix LiveView and Alpine.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Phoenix LiveView 和 Alpine.js 构建高性能的自动完成功能</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/build-a-performat-autocomplete-using-phoenix-liveview-and-alpine-js-8bcbbed17ba7?source=collection_archive---------1-----------------------#2020-07-21">https://blog.devgenius.io/build-a-performat-autocomplete-using-phoenix-liveview-and-alpine-js-8bcbbed17ba7?source=collection_archive---------1-----------------------#2020-07-21</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/5f23280ddda2bdb2d05d8181857edb39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tyykujINe54FE09E"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">照片由<a class="ae jz" href="https://unsplash.com/@nateggrant?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">内特·格兰特</a>在<a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="a381" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">人们可能会认为创建一个自动完成(或提前键入)字段已经解决了无数次了。是的，有很多关于 React、Vue、Angular 或其他现代前端框架的教程。此外，在 Phoenix LiveView 中也有一些这样的处理方法:</p><ul class=""><li id="54f7" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx ld le lf lg bi translated"><a class="ae jz" href="https://medium.com/qixxit-development/swapping-react-for-phoenix-liveview-db6581f27a14" rel="noopener">将 React 换成 Phoenix LiveView </a></li><li id="a791" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated">凤凰号的创造者克里斯·麦考德亲自开发的交互式实时应用。</li><li id="0029" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated">甚至在官方<a class="ae jz" href="https://github.com/chrismccord/phoenix_live_view_example/blob/master/lib/demo_web/live/search_live.ex" rel="noopener ugc nofollow" target="_blank">凤凰 _ 直播 _ 查看 _ 实例回购</a>。</li></ul><p id="496d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">可能还有更多，但是我到目前为止发现的所有例子都使用了 HTML <code class="fe lm ln lo lp b">datalist</code>元素。它得到了广泛的支持，对于简单的用例来说很好，但是一旦你想以某种方式设计它来显示额外的上下文数据(例如图像)，你将会遇到困难。</p><p id="0109" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，我们现在要构建自己的自动完成功能。我们的自动完成功能将从某种游戏物品数据库中搜索物品。我们使用 Phonix LiveView 和 Alpine.js 来避免不必要的服务器往返。这将提供一个更好的整体 UX，并使自动完成更快。</p><p id="df72" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这就是最终的结果。最好的事情是，整个解决方案仅在<strong class="kc io"> 140 LOC </strong>左右(这很好，不是吗？).</p><figure class="lr ls lt lu gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lq"><img src="../Images/49400d8f3fbaa898b7087fce871c0e73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*1EyTrnJYky0P0aqpUNXCqg.gif"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">我们惊人的自动完成🎉</figcaption></figure><p id="b342" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果你很急，也可以直接从 GitHub 抓取<a class="ae jz" href="https://github.com/benvp/liveview_autocomplete" rel="noopener ugc nofollow" target="_blank">完整代码。</a></p><h1 id="d66f" class="lv lw in bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">让我们(最终)建造它。</h1><p id="3a68" class="pw-post-body-paragraph ka kb in kc b kd mt kf kg kh mu kj kk kl mv kn ko kp mw kr ks kt mx kv kw kx ig bi translated">我希望你知道如何设置一个新的 Phoenix LiveView 项目，所以我不会指导你。但是在我们真正开始黑客之前，我们必须做一些漂亮的设置。</p><p id="72cd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><a class="ae jz" href="https://github.com/alpinejs/alpine" rel="noopener ugc nofollow" target="_blank"> Alpine.js </a>是一个 JavaScript 依赖，我们将需要它来处理一些客户端的东西，而不需要服务器往返。所以让我们先安装它。</p><figure class="lr ls lt lu gt jo"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="1047" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">要让 Phoenix 与 Alpine.js 很好地协同工作，还需要做一件事。导入 Alpine.js 并确保它可以跟踪 DOM 元素，即使 Phoenix LiveView 确实移动了它们。转到您的<code class="fe lm ln lo lp b">assets/js/app.js</code>并添加以下内容:</p><figure class="lr ls lt lu gt jo"><div class="bz fp l di"><div class="my mz l"/></div></figure><h1 id="619a" class="lv lw in bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">创造一些有用的东西。</h1><p id="4408" class="pw-post-body-paragraph ka kb in kc b kd mt kf kg kh mu kj kk kl mv kn ko kp mw kr ks kt mx kv kw kx ig bi translated">既然我们已经想好了设置的东西，让我们创建一个模块作为我们的小物品数据库。把这个放进<code class="fe lm ln lo lp b">lib/autocomplete/items.ex</code></p><figure class="lr ls lt lu gt jo"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="61f4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在我们有了一个小小的物品数据库，我们可以获取所有物品或单个物品。</p><p id="feda" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为实际的自动完成创建一个 LiveView 模块和一个<code class="fe lm ln lo lp b">leex</code>模板。我喜欢在这里将模板与实际的业务逻辑分开，但是您当然可以将 HTML 添加到 LiveView 模块内的<code class="fe lm ln lo lp b">render</code>函数中。</p><p id="ec8d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe lm ln lo lp b">lib/autocomplete_web/live/item_search_live.ex</code>和<code class="fe lm ln lo lp b">lib/autocomplete_web/live_item_search_live.html.leex</code></p><p id="fcd1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在向这些模块添加代码之前，将路由器指向它。</p><figure class="lr ls lt lu gt jo"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="d53b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们用它的初始状态来设置 LiveView 模块。</p><figure class="lr ls lt lu gt jo"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="260a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这将确保我们用一些初始数据初始化我们的页面。在生产应用程序中，在初始渲染时只获取一小部分项目，或者推迟到用户聚焦该字段时，这可能是有意义的。但是让我们大胆一点，把所有的物品都拿来<em class="na">。</em></p><p id="a7c6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">仍然缺少<code class="fe lm ln lo lp b">leex</code>模板。我们在<code class="fe lm ln lo lp b">form</code>标签中使用了一个基本的<code class="fe lm ln lo lp b">input</code>字段。建议将显示在一个无序列表<code class="fe lm ln lo lp b">ul</code>中，每个条目由一个<code class="fe lm ln lo lp b">li</code>元素表示(我知道，条目可能应该是一个可访问性按钮，但是我们不这样做😜).</p><p id="8baa" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">建议列表应该只在用户聚焦字段时显示，并且如果我们有任何基于搜索词的结果。</p><p id="d9f2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我将省略这篇文章中的 CSS，因为它只是样板文件。你可以在这里查找 CSS 类<a class="ae jz" href="https://github.com/benvp/liveview_autocomplete/blob/master/assets/css/autocomplete.scss" rel="noopener ugc nofollow" target="_blank">。</a></p><figure class="lr ls lt lu gt jo"><div class="bz fp l di"><div class="my mz l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">遗憾的是 GitHub Gist 不支持 LEEx ️😢</figcaption></figure><p id="eb1c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">该模板混合了 Alpine.js 代码和嵌入的 Elixir。我们不想跟踪服务器上弹出建议的打开/关闭状态。这由 alpine 使用<code class="fe lm ln lo lp b">autocomplete</code>函数来处理。我们使用 autocomplete 容器上的<code class="fe lm ln lo lp b">x-data="autocomplete()"</code>属性来绑定它。我们希望当用户点击我们的自动完成字段之外的任何地方时关闭弹出窗口——这就是<code class="fe lm ln lo lp b">@click.away="close"</code>所做的。</p><p id="4d6a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">进一步向下移动，当有任何建议可用时，<code class="fe lm ln lo lp b">suggestions</code>容器将被呈现(我们之前在<code class="fe lm ln lo lp b">mount</code>中设置了这个)。它还通过<code class="fe lm ln lo lp b">x-show="isOpen"</code>控制能见度。</p><p id="8695" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后，我们使用<code class="fe lm ln lo lp b">for</code>理解来迭代所有建议，以显示列表中的所有建议。LiveView 要求我们给每个元素分配一个<code class="fe lm ln lo lp b">id</code>，这样它就可以根据服务器所做的更改来引用它。</p><p id="96ff" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了使项目可选，我们需要添加一些 LiveView 事件属性。那就是<code class="fe lm ln lo lp b">phx-change="suggest"</code>和<code class="fe lm ln lo lp b">phx-click="select"</code>了。为了防止表单提交(例如，当用户点击回车键时)，我们还需要通过添加<code class="fe lm ln lo lp b">phx-submit="submit"</code>来处理提交事件。</p><p id="d2cb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">容器的第二部分显示所有选中的项目，应该是不言自明的。</p><p id="4689" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了处理服务器上的事件，我们在<code class="fe lm ln lo lp b">AutocompleteLive</code>模块中添加了相应的<code class="fe lm ln lo lp b">handle_event</code>函数。</p><figure class="lr ls lt lu gt jo"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="aefe" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe lm ln lo lp b">handle_event</code>函数模式匹配搜索字符串，该字符串是通过我们之前添加的<code class="fe lm ln lo lp b">phx_change</code>事件发送的。然后，它从<code class="fe lm ln lo lp b">Items</code>模块获取所有项目，并使用<code class="fe lm ln lo lp b">suggest</code>函数过滤结果。<code class="fe lm ln lo lp b">suggest</code>函数执行简单的不区分大小写的搜索。</p><p id="1fb7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">接下来，我们应该处理<code class="fe lm ln lo lp b">select</code>事件。</p><figure class="lr ls lt lu gt jo"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="1266" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">同样，我们对参数进行模式匹配(在本例中为<code class="fe lm ln lo lp b">id</code>)并从<code class="fe lm ln lo lp b">Items</code>模块中获取所选的项目。为了填充所有选定项目的列表，我们将新项目重新扩展到现有选定项目的列表中。此外，我们通过调用<code class="fe lm ln lo lp b">Enum.uniq_by</code>来确保没有添加重复项。</p><p id="1b49" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们不希望<code class="fe lm ln lo lp b">suggestions</code>包含任何选定的项目。因此，我们创建了一个<code class="fe lm ln lo lp b">filter_selected/2</code>函数，它从第二个参数中包含的给定的<code class="fe lm ln lo lp b">items</code>中删除任何现有的项目——基于它的<code class="fe lm ln lo lp b">id</code>。</p><p id="fba1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如前所述，需要处理<code class="fe lm ln lo lp b">submit</code>事件，以防止用户点击<em class="na"> Enter </em>键时的默认提交行为。这就像添加一个<code class="fe lm ln lo lp b">handle_event</code>回调并简单地返回套接字一样简单。</p><figure class="lr ls lt lu gt jo"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="d2d4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">就是这样。我们现在应该有一个工作原型，允许我们搜索项目并通过单击选择它们。厉害！🎉</p><figure class="lr ls lt lu gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lq"><img src="../Images/033a3f7515030e45ce5f06605d62911e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*ZDsO4r95lLcSZL0cGQx23g.gif"/></div></div></figure><p id="1d68" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">…但是它还不是很漂亮，不是吗？我们仍有可以改进的地方:</p><ul class=""><li id="35cb" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx ld le lf lg bi translated">当用户用鼠标悬停时显示适当的突出显示</li><li id="0cd3" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated">通过<em class="na">向上- </em>和<em class="na">向下箭头</em>键导航</li><li id="1c5c" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated">点击<em class="na">输入</em>键选择一个项目</li></ul><p id="29ee" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这就是我们接下来要做的。</p><h1 id="bbc2" class="lv lw in bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">美化环境—改善 UX。</h1><p id="e695" class="pw-post-body-paragraph ka kb in kc b kd mt kf kg kh mu kj kk kl mv kn ko kp mw kr ks kt mx kv kw kx ig bi translated">让我们先从最简单的事情开始:当用户将鼠标悬停在上面时，显示一个适当的<em class="na">高亮。</em></p><p id="2f0c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们希望在客户端直接处理选择，而不是在服务器上，因为这是一个纯粹的客户端的事情。为了在以后实现键盘导航，我们不能依赖 CSS 类，必须管理我们自己的悬停/焦点状态。</p><p id="73e3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">添加鼠标悬停焦点非常简单:</p><figure class="lr ls lt lu gt jo"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="03c3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">通过在我们的<code class="fe lm ln lo lp b">autocomplete</code>函数上添加一个<code class="fe lm ln lo lp b">focus</code>属性，我们可以依靠它将相应的类应用到建议项。一旦鼠标移动到建议上，<code class="fe lm ln lo lp b">@mouseenter</code>属性将负责设置正确的焦点。</p><p id="f1d2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">很好。现在我们要添加键盘支持。</p><figure class="lr ls lt lu gt jo"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="250c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">添加键盘支持是通过向<code class="fe lm ln lo lp b">autocomplete</code>函数添加三个用于管理焦点状态的新函数来实现的。</p><p id="ccd1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> scrollTo(idx) </strong>:使用 Alpin.js <code class="fe lm ln lo lp b">$refs</code>对象滚动到给定的索引。如果 ref 确实存在，它将调用元素上的<code class="fe lm ln lo lp b">scrollIntoView(false)</code>。这将把聚焦的项目滚动到视图中，而没有任何动画。</p><p id="b603" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> focusNext(): </strong>如果建议框可见且下一个元素索引小于建议总数，则将焦点设置到下一个元素，并将其滚动到视图中。</p><p id="da11" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> focusPrev(): </strong>如果前一个索引不小于 0，则将焦点设置到前一个元素，并将其滚动到视图中。</p><p id="7298" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后我们用两个事件属性<code class="fe lm ln lo lp b">arrow-up</code>和<code class="fe lm ln lo lp b">arrow-down</code>连接自动完成容器<code class="fe lm ln lo lp b">div</code>。</p><p id="b893" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">接下来:点击<em class="na">选择当前建议，输入</em>:</p><figure class="lr ls lt lu gt jo"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="9244" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">那也简单。我唯一不百分之百满意的是，我们需要依赖一个<code class="fe lm ln lo lp b">$ref</code>并手动触发建议的点击事件。我还没找到任何官方 api。它目前只在一个<a class="ae jz" href="https://hexdocs.pm/phoenix_live_view/js-interop.html#client-hooks" rel="noopener ugc nofollow" target="_blank">钩子</a>的范围内被支持，但是这似乎让事情变得更复杂了。也许会有一个公共 api 把事件推到 hook 范围之外的服务器上。目前，这是一个可以接受的变通办法。</p><p id="5493" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果你有更好的想法，我会很高兴你能在 twitter <a class="ae jz" href="https://twitter.com/benvp_" rel="noopener ugc nofollow" target="_blank"> @benvp_ </a>上发表评论或给我发消息。</p><p id="b665" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">就这样。我们成功了！我们设法在大约<em class="na"> 140 LOC </em>中创建了一个带有自定义建议列表的全功能自动完成功能，包括服务器端代码。</strong></p><p id="17f6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">老实说，我认为这是一个很大的成就，如果你将它与使用客户端框架(如 React)和单独的 API 来实现它的努力相比较的话。如果您进一步考虑验证，这将节省大量时间。我对 LiveView 和 Elixir 的未来感到兴奋。</p><p id="b1d4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">干杯，本。</p></div></div>    
</body>
</html>