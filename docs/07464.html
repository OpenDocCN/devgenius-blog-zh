<html>
<head>
<title>Refactoring GTK4 UI templates in Rust</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在 Rust 中重构 GTK4 UI 模板</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/refactoring-gtk4-ui-templates-in-rust-68cbef1a1778?source=collection_archive---------5-----------------------#2022-03-27">https://blog.devgenius.io/refactoring-gtk4-ui-templates-in-rust-68cbef1a1778?source=collection_archive---------5-----------------------#2022-03-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/c02d9eca14524e0d0c6691babcb7b679.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*D710a-aUzU4NabCV"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">梅尔·普尔在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="426a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上次我们为我们的<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/initial-setup-for-a-gtk4-app-with-libadwaita-in-rust-using-vscode-b6f8c127a75e"> GTK RSS 阅读器</a>应用<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/using-the-libadwaita-leaflet-widget-for-a-responsive-gtk4-ui-in-rust-73bbc2f4025">构建了一个响应 UI，但是我们把整个 UI 描述塞进了一个文件中。在本文中，我们将学习通过创建我们自己的 GTK 小部件来拆分单个 UI 文件。</a></p><p id="73ba" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过从<code class="fe lb lc ld le b">main-window.ui</code>中提取两个窗口小部件，我们也将失去描述三个属性绑定的能力，因为它们现在将跨越主窗口和窗口小部件之间的边界。首先，我们将研究用代码重新建立这些属性绑定，在下一篇文章<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/adding-properties-to-custom-gtk4-widgets-in-rust-67d4bbed8b08">中，我们将看到如何在 XML 模板中为支持绑定的小部件创建属性。和往常一样，你可以在</a><a class="ae kc" href="https://github.com/raduzaharia-medium/gtk-rss-reader-widgets" rel="noopener ugc nofollow" target="_blank"> github </a>找到代码。</p><h2 id="f8d6" class="lf lg iq bd lh li lj dn lk ll lm dp ln ko lo lp lq ks lr ls lt kw lu lv lw lx bi translated">FeedList 小部件</h2><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ly"><img src="../Images/169bc516ac08167a588c4aaf6d90d52e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ajEHYqtYJ38l6-9Byy-h5A.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">RSS 阅读器 GTK4 应用程序</figcaption></figure><p id="dfb2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第一个组件是左边的提要列表。先添加它的模板描述，<code class="fe lb lc ld le b">feed-list.ui</code>:</p><pre class="lz ma mb mc gt md le me mf aw mg bi"><span id="d5a3" class="lf lg iq le b gy mh mi l mj mk">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br/>&lt;interface&gt;<br/>  &lt;template class="FeedList" parent="GtkBox"&gt;<br/>    &lt;child&gt;<br/>      &lt;object class="GtkBox"&gt;<br/>        &lt;property name="orientation"&gt;vertical&lt;/property&gt;<br/>        <br/>        &lt;child&gt;<br/>          &lt;object class="AdwHeaderBar" id="header_bar"&gt;<br/>            &lt;property name="title-widget"&gt;<br/>              &lt;object class="AdwWindowTitle"&gt;<br/>                &lt;property name="title"&gt;Feeds&lt;/property&gt;<br/>              &lt;/object&gt;<br/>            &lt;/property&gt;<br/>          &lt;/object&gt;<br/>        &lt;/child&gt;<br/>        &lt;child&gt;<br/>          &lt;object class="GtkListBox"&gt;<br/>            &lt;property name="selection-mode"&gt;single&lt;/property<br/>            &lt;property name="hexpand"&gt;True&lt;/property&gt;&gt;</span><span id="f2e9" class="lf lg iq le b gy ml mi l mj mk">            &lt;property name="margin-top"&gt;24&lt;/property&gt;<br/>            &lt;property name="margin-bottom"&gt;24&lt;/property&gt;<br/>            &lt;property name="margin-start"&gt;12&lt;/property&gt;<br/>            &lt;property name="margin-end"&gt;12&lt;/property&gt;</span><span id="0795" class="lf lg iq le b gy ml mi l mj mk">            &lt;style&gt;<br/>              &lt;class name="boxed-list"/&gt;<br/>            &lt;/style&gt;<br/>              <br/>            &lt;child&gt;<br/>              &lt;object class="AdwActionRow"&gt;<br/>                &lt;property name="title"&gt;The Verge&lt;/property<br/>              &lt;/object&gt;<br/>            &lt;/child&gt;<br/>            &lt;child&gt;<br/>              &lt;object class="AdwActionRow"&gt;<br/>                &lt;property name="title"&gt;Ars Technica&lt;/property<br/>              &lt;/object&gt;<br/>            &lt;/child&gt;<br/>          &lt;/object&gt;<br/>        &lt;/child&gt;<br/>      &lt;/object&gt;<br/>    &lt;/child&gt;<br/>  &lt;/template&gt;<br/>&lt;/interface&gt;</span></pre><p id="e171" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就像我们上次创建的<code class="fe lb lc ld le b">MainWindow</code>一样，<code class="fe lb lc ld le b">FeedList</code>模板有一个<code class="fe lb lc ld le b">class</code>和一个<code class="fe lb lc ld le b">parent</code>。<code class="fe lb lc ld le b">class</code>是我们新部件的名称:<code class="fe lb lc ld le b">FeedList</code>并且它的<code class="fe lb lc ld le b">parent</code>类应该是一个<code class="fe lb lc ld le b">GtkBox</code>。虽然不强制使用<code class="fe lb lc ld le b">parent</code>类型，但是 ide 更应该知道如何更好地处理小部件。</p><p id="6322" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们简单地复制窗口的左窗格:一个带有一个<code class="fe lb lc ld le b">HeaderBar</code>和一个<code class="fe lb lc ld le b">ListBox</code>的<code class="fe lb lc ld le b">Box</code>。但是还缺少一些东西:<code class="fe lb lc ld le b">Leaflet</code>和<code class="fe lb lc ld le b">HeaderBar</code>之间的<code class="fe lb lc ld le b">folded</code>属性绑定。如果窗口很窄，我们应该显示关闭窗口按钮。缺少绑定，因为我们的<code class="fe lb lc ld le b">FeedList</code>小部件没有定义属性。我们将在下一篇文章中看到如何做到这一点。现在，我们将移动代码中的绑定，稍后我们会看到。</p><p id="4088" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如我们在之前的文章中为<code class="fe lb lc ld le b">MainWindow</code>所做的那样，模板必须加载到 Rust 模块中。所以我们创建了一个<code class="fe lb lc ld le b">feed_list</code>文件夹，就像我们在 src 中有一个<code class="fe lb lc ld le b">main_window</code>文件夹一样，在那里我们为<code class="fe lb lc ld le b">FeedList</code>小部件放置了<code class="fe lb lc ld le b">mod.rs</code>和<code class="fe lb lc ld le b">template.rs</code>。在<code class="fe lb lc ld le b">mod.rs</code>中，我们简单地定义了小部件:</p><pre class="lz ma mb mc gt md le me mf aw mg bi"><span id="deed" class="lf lg iq le b gy mh mi l mj mk">use self::template::FeedListTemplate;<br/>use glib::wrapper;<br/>use gtk4::{Accessible, Box, Buildable, ConstraintTarget, Orientable, Widget};</span><span id="edc9" class="lf lg iq le b gy ml mi l mj mk">wrapper! {<br/>  pub struct FeedList(ObjectSubclass&lt;FeedListTemplate&gt;)<br/>    @extends Widget, Box,<br/>    @implements Accessible, Buildable, ConstraintTarget, Orientable;<br/>}</span><span id="2cc6" class="lf lg iq le b gy ml mi l mj mk">impl Default for FeedList {<br/>  fn default() -&gt; Self {<br/>    Self::new()<br/>  }<br/>}</span><span id="b83c" class="lf lg iq le b gy ml mi l mj mk">impl FeedList {<br/>  pub fn new() -&gt; Self {<br/>    glib::Object::new(&amp;[])<br/>      .expect("Failed to create an instance of FeedList")<br/>  }<br/>}</span></pre><p id="7c71" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe lb lc ld le b">template.rs</code>中，我们将小部件链接到<code class="fe lb lc ld le b">feed-list.ui</code>:</p><pre class="lz ma mb mc gt md le me mf aw mg bi"><span id="f03c" class="lf lg iq le b gy mh mi l mj mk">use super::FeedList;<br/>use glib::{<br/>  object_subclass,<br/>  subclass::{<br/>    object::{ObjectImpl, ObjectImplExt},<br/>    types::ObjectSubclass, InitializingObject,<br/>  },<br/>};<br/>use gtk4::{<br/>  prelude::InitializingWidgetExt,<br/>  subclass::{<br/>    prelude::{BoxImpl, TemplateChild, WidgetImpl},<br/>    widget::{CompositeTemplate, WidgetClassSubclassExt},<br/>  },<br/>  Box, CompositeTemplate,<br/>};<br/>use libadwaita::HeaderBar;</span><span id="8d47" class="lf lg iq le b gy ml mi l mj mk">#[derive(CompositeTemplate, Default)]<br/>#[template(resource = "/feed-list.ui")]<br/>pub struct FeedListTemplate {<br/>  #[template_child]<br/>  pub header_bar: TemplateChild&lt;HeaderBar&gt;,<br/>}</span><span id="9d8c" class="lf lg iq le b gy ml mi l mj mk">#[object_subclass]<br/>impl ObjectSubclass for FeedListTemplate {<br/>  const NAME: &amp;'static str = "FeedList";<br/>  type Type = FeedList;<br/>  type ParentType = Box;<br/>  <br/>  fn class_init(my_class: &amp;mut Self::Class) {<br/>    Self::bind_template(my_class);<br/>  }</span><span id="bbcb" class="lf lg iq le b gy ml mi l mj mk">  fn instance_init(obj: &amp;InitializingObject&lt;Self&gt;) {<br/>    obj.init_template();<br/>  }<br/>}</span><span id="321d" class="lf lg iq le b gy ml mi l mj mk">impl ObjectImpl for FeedListTemplate {<br/>  fn constructed(&amp;self, obj: &amp;Self::Type) {<br/>    self.parent_constructed(obj);<br/>  }<br/>}</span><span id="9659" class="lf lg iq le b gy ml mi l mj mk">impl WidgetImpl for FeedListTemplate {}<br/>impl BoxImpl for FeedListTemplate {}</span></pre><p id="ebb6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我总是坚持<code class="fe lb lc ld le b">use</code>部分，因为把事情弄糟会让你陷入无休止的“我做错了什么？”会话。为右侧窗格编写小部件时使用了完全相同的代码，我们称之为<code class="fe lb lc ld le b">ArticleList</code>。代码在<a class="ae kc" href="https://github.com/raduzaharia-medium/gtk-rss-reader-widgets" rel="noopener ugc nofollow" target="_blank"> github </a>上，我不会在这里复制它，因为它是完全相同的东西。注意我们是如何在<code class="fe lb lc ld le b">FeedListTemplate</code>结构中导出<code class="fe lb lc ld le b">header_bar</code>的。这将允许我们稍后在代码中设置属性绑定时与它进行交互。</p><h2 id="087c" class="lf lg iq bd lh li lj dn lk ll lm dp ln ko lo lp lq ks lr ls lt kw lu lv lw lx bi translated">更新的代码结构</h2><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mm"><img src="../Images/338e8f5e4ac78b54c2a0e16fee98bb73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2HghiGJR62_dZo0XESGrhw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">显示更新的代码文件夹的 VSCode 屏幕截图</figcaption></figure><p id="8e53" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你想自己写代码而不是从<a class="ae kc" href="https://github.com/raduzaharia-medium/gtk-rss-reader-widgets" rel="noopener ugc nofollow" target="_blank"> github </a>克隆，你可以在上面的截图中看到最终结果应该是什么样子。因为现在我们有三个小部件，你将有三个<code class="fe lb lc ld le b">ui</code>模板文件和三个 Rust 模块在它们各自的文件夹中:<code class="fe lb lc ld le b">article_list</code>、<code class="fe lb lc ld le b">feed_list</code>和<code class="fe lb lc ld le b">main_window</code>，我们之前有过。主窗口模板，<code class="fe lb lc ld le b">main-window.ui</code>会简单很多:</p><pre class="lz ma mb mc gt md le me mf aw mg bi"><span id="5753" class="lf lg iq le b gy mh mi l mj mk">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br/>&lt;interface&gt;<br/>  &lt;template class="MainWindow" parent="AdwApplicationWindow"<br/>    &lt;property name="width-request"&gt;800&lt;/property&gt;<br/>    &lt;property name="height-request"&gt;500&lt;/property&gt;<br/>    &lt;property name="title" translatable="yes"&gt;<br/>      My GTK4 RSS Reader<br/>    &lt;/property&gt;</span><span id="c8c0" class="lf lg iq le b gy ml mi l mj mk">    &lt;child&gt;<br/>      &lt;object class="AdwLeaflet" id="leaflet"&gt;<br/>        &lt;property name="can-swipe-back"&gt;True&lt;/property&gt;<br/>        &lt;child&gt;<br/>          &lt;object class="FeedList" id="feed_list" /&gt;<br/>        &lt;/child&gt;<br/>        &lt;child&gt;<br/>          &lt;object class="AdwLeafletPage"&gt;<br/>            &lt;property name="navigatable"&gt;False&lt;/property&gt;<br/>            &lt;property name="child"&gt;<br/>              &lt;object class="GtkSeparator"/&gt;<br/>            &lt;/property&gt;<br/>          &lt;/object&gt;<br/>        &lt;/child&gt;<br/>        &lt;child&gt;<br/>          &lt;object class="ArticleList" id="article_list" /&gt;<br/>        &lt;/child&gt;<br/>      &lt;/object&gt;<br/>    &lt;/child&gt;<br/>  &lt;/template&gt;<br/>&lt;/interface&gt;</span></pre><p id="44f9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的<code class="fe lb lc ld le b">Leaflet</code>小部件将<code class="fe lb lc ld le b">FeedList</code>作为第一个子部件，将<code class="fe lb lc ld le b">ArticleList</code>作为最后一个子部件，而不是将所有内容都放在一个文件中。简单多了。分隔符代码太小，不值得为它创建一个小部件。由于我们现在有了更多的模板，资源定义文件<code class="fe lb lc ld le b">app.gresource.xml</code>也发生了变化:</p><pre class="lz ma mb mc gt md le me mf aw mg bi"><span id="c0a2" class="lf lg iq le b gy mh mi l mj mk">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;<br/>&lt;gresources&gt;<br/>  &lt;gresource&gt;<br/>    &lt;file compressed="true"&gt;main-window.ui&lt;/file&gt;<br/>    &lt;file compressed="true"&gt;feed-list.ui&lt;/file&gt;<br/>    &lt;file compressed="true"&gt;article-list.ui&lt;/file&gt;<br/>  &lt;/gresource&gt;<br/>&lt;/gresources&gt;</span></pre><p id="041f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">还缺少一样东西。属性绑定。</p><h2 id="a4f6" class="lf lg iq bd lh li lj dn lk ll lm dp ln ko lo lp lq ks lr ls lt kw lu lv lw lx bi translated">代码中的属性绑定</h2><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/68b325d2b432a286f8eb34f3aacae787.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4XZytKqPcQJYigzG"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">由<a class="ae kc" href="https://unsplash.com/@maxsaeling?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Max Saeling </a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="955c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">自从我们将 ui 代码从<code class="fe lb lc ld le b">main-window.ui</code>转移到<code class="fe lb lc ld le b">feed-list.ui</code>和<code class="fe lb lc ld le b">article-list.ui</code>后，我们遇到了一个小问题。主窗口无法知道子窗口<code class="fe lb lc ld le b">FeedList</code>和<code class="fe lb lc ld le b">ArticleList</code>的内部。以前，当所有代码都在<code class="fe lb lc ld le b">MainWindow</code>中时，这很容易:它知道正在发生的一切。但是现在<code class="fe lb lc ld le b">FeedList</code>隐藏了<code class="fe lb lc ld le b">MainWindow</code>需要知道的重要实现细节。</p><p id="cd7f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有三样东西<code class="fe lb lc ld le b">MainWindow</code>需要访问。当<code class="fe lb lc ld le b">Leaflet</code>被折叠时，来自<code class="fe lb lc ld le b">ArticleList</code>标题的返回按钮切换其可见性，以及来自<code class="fe lb lc ld le b">FeedList</code>和<code class="fe lb lc ld le b">ArticleList</code>的<code class="fe lb lc ld le b">HeaderBar</code>对象，因此当<code class="fe lb lc ld le b">Leaflet</code>再次被折叠时，它可以触发它们显示或隐藏窗口按钮。我们的<code class="fe lb lc ld le b">Leaflet</code>小部件的<code class="fe lb lc ld le b">folded</code>属性控制 UI 上的所有这三件事情。不幸的是，当我们在<code class="fe lb lc ld le b">FeedList</code>和<code class="fe lb lc ld le b">ArticleList</code>中隐藏了<code class="fe lb lc ld le b">HeaderBar</code>时，我们就失去了对它们的控制。那么我们如何恢复属性绑定呢？</p><p id="095a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们将通过代码来解决这个问题。在下一篇文章中，我们将看到如何在模板 XML 文件中处理它，但是我觉得了解代码中绑定的工作方式是有好处的。首先，请记住我们是如何在小部件模板代码中发布我们需要使用的位的:</p><pre class="lz ma mb mc gt md le me mf aw mg bi"><span id="e1f0" class="lf lg iq le b gy mh mi l mj mk">#[derive(CompositeTemplate, Default)]<br/>#[template(resource = "/feed-list.ui")]<br/>pub struct FeedListTemplate {<br/>  #[template_child]<br/>  pub header_bar: TemplateChild&lt;HeaderBar&gt;,<br/>}</span></pre><p id="e3e7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">FeedList</code>小部件有一个<code class="fe lb lc ld le b">HeaderBar</code>，所以我们在<code class="fe lb lc ld le b">FeedListTemplate</code>的模板代码中发布了它。这允许我们在代码中进一步使用它。由于我们的应用程序中只有一个小部件知道所有其他的小部件，所以我们将属性绑定放在那里。这个小部件是什么？<code class="fe lb lc ld le b">MainWindow</code>:</p><pre class="lz ma mb mc gt md le me mf aw mg bi"><span id="17ca" class="lf lg iq le b gy mh mi l mj mk">#[derive(CompositeTemplate, Default)]<br/>#[template(resource = "/main-window.ui")]<br/>pub struct MainWindowTemplate {<br/>  #[template_child]<br/>  pub leaflet: TemplateChild&lt;Leaflet&gt;,</span><span id="f70b" class="lf lg iq le b gy ml mi l mj mk">  #[template_child]<br/>  pub feed_list: TemplateChild&lt;FeedList&gt;,</span><span id="7458" class="lf lg iq le b gy ml mi l mj mk">  #[template_child]<br/>  pub article_list: TemplateChild&lt;ArticleList&gt;,<br/>}</span></pre><p id="ecaa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，我们在<code class="fe lb lc ld le b">MainWindowTemplate</code>中添加一个对所有重要小部件的引用，就像我们上面做的那样。我们需要<code class="fe lb lc ld le b">Leaflet</code>、<code class="fe lb lc ld le b">FeedList</code>和<code class="fe lb lc ld le b">ArticleList</code>。还要记住，在<code class="fe lb lc ld le b">FeedListTemplate</code>和<code class="fe lb lc ld le b">ArticleListTemplate</code>中，我们对<code class="fe lb lc ld le b">HeaderBar</code>做了同样的事情。作为<code class="fe lb lc ld le b">ArticleListTemplate</code>的附加，我们也在那里发布了后退按钮。这为我们创建绑定做好了一切准备:</p><pre class="lz ma mb mc gt md le me mf aw mg bi"><span id="b1e2" class="lf lg iq le b gy mh mi l mj mk">impl ObjectImpl for MainWindowTemplate {<br/>  fn constructed(&amp;self, obj: &amp;Self::Type) {<br/>    self.parent_constructed(obj);</span><span id="680b" class="lf lg iq le b gy ml mi l mj mk">    let feed_list = self.feed_list.get();<br/>    let feed_list_template = <br/>      FeedListTemplate::from_instance(&amp;feed_list);</span><span id="0b07" class="lf lg iq le b gy ml mi l mj mk">    let article_list = self.article_list.get();<br/>    let article_list_template = <br/>      ArticleListTemplate::from_instance(&amp;article_list);</span><span id="7f06" class="lf lg iq le b gy ml mi l mj mk">    self.leaflet.property_expression("folded")<br/>      .bind(&amp;feed_list_template.header_bar.get(),<br/>        "show-end-title-buttons", Widget::NONE);</span><span id="b847" class="lf lg iq le b gy ml mi l mj mk">    self.leaflet.property_expression("folded")<br/>      .bind(&amp;article_list_template.header_bar.get(),<br/>        "show-start-title-buttons", Widget::NONE);</span><span id="9f3f" class="lf lg iq le b gy ml mi l mj mk">    self.leaflet.property_expression("folded")<br/>      .bind(&amp;article_list_template.back_button.get(),<br/>        "visible", Widget::NONE);<br/>  }<br/>}</span></pre><p id="3a06" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，首先我们得到了我们需要的所有东西:<code class="fe lb lc ld le b">feed_list_template</code>和<code class="fe lb lc ld le b">article_list_template</code>。我们通过在它们的实例上调用<code class="fe lb lc ld le b">from_instance</code>来获得它们。注意<code class="fe lb lc ld le b">self.article_list.get()</code>中的<code class="fe lb lc ld le b">get()</code>。那是因为<code class="fe lb lc ld le b">self.article_list</code>是<code class="fe lb lc ld le b">ArticleList</code>类型的<code class="fe lb lc ld le b">TemplateChild</code>，而不是<code class="fe lb lc ld le b">ArticleList</code>本身，所以我们需要用<code class="fe lb lc ld le b">get()</code>来抓取它。</p><p id="3933" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们准备创建绑定。这是通过使用 GTK4 属性表达式完成的，我现在不会写它。它们是 GTK3 属性绑定的升级，现在知道这些就足够了。我们获取<code class="fe lb lc ld le b">Leaflet</code>，引用它的属性<code class="fe lb lc ld le b">folded</code>，并将其绑定到三个对象:来自<code class="fe lb lc ld le b">FeedList</code>和<code class="fe lb lc ld le b">ArticleList</code>的<code class="fe lb lc ld le b">HeaderBar</code>，然后绑定到<code class="fe lb lc ld le b">ArticleList</code>中的后退按钮。完成了。</p></div><div class="ab cl mn mo hu mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ij ik il im in"><p id="68cb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们今天所做的在很多方面简化了应用程序代码。我们的主窗口代码要小得多，因为我们把它大部分移到了小部件中。我们创建了两个隐藏其实现的小部件，但我们仍然能够挽救属性绑定，并允许<code class="fe lb lc ld le b">Leaflet</code>小部件以响应的方式工作。</p><p id="33bb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">尽管如此，我们不能掩盖这样一个事实:代码中的绑定有点奇怪。我们如何将它们移回 XML 模板呢？我们将在下一次中看到<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/adding-properties-to-custom-gtk4-widgets-in-rust-67d4bbed8b08">,届时我们将为新的小部件添加属性。到时候见，也在评论里！</a></p></div></div>    
</body>
</html>