<html>
<head>
<title>3 Easy Steps To Access Individual Spring Beans</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">访问单个 Spring Beans 的 3 个简单步骤</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/3-easy-steps-to-access-individual-spring-beans-783ff6d5fe36?source=collection_archive---------5-----------------------#2022-07-26">https://blog.devgenius.io/3-easy-steps-to-access-individual-spring-beans-783ff6d5fe36?source=collection_archive---------5-----------------------#2022-07-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/b71f664219956eaedf529c0616323703.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x9lPq9nhJRrLO7pzRY44Ew.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://spring.io/" rel="noopener ugc nofollow" target="_blank">https://spring.io/</a></figcaption></figure><p id="925f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于我的工作项目，我们使用公司内部的 Java 框架来开发我们的应用程序。尽管这个框架有其独特的特性，但它不如 Spring 强大，Spring 提供了数据库访问、缓存连接和其他外部特性。</p><p id="f82a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们的团队决定率先尝试公司框架和 Spring 框架的混合。</p><p id="0879" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，由于来自两个不同框架的注释和包的混合，我们必须分离两个框架，并对它们进行不同的配置来访问 Spring beans。</p><h2 id="b5f1" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">第一步。配置 Spring 上下文。</h2><p id="3701" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">我们将首先创建 Spring 配置类。</p><p id="da53" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">@ <strong class="kf ir">配置</strong>告诉 Spring 容器生成 bean 定义和服务请求。@ <strong class="kf ir"> ComponentScan </strong>将与@ <strong class="kf ir"> Configuration </strong>一起使用，告诉 Spring 容器查找组件类，比如我们稍后在步骤 2 中定义的组件类。这里我们声明了<em class="lz"> basePackages </em>，这样 Spring 容器将在包路径中找到组件类。</p><p id="e2c7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在该类中，我们有一个静态方法来创建一个<em class="lz">ConfigurableApplicationContext</em>——它将当前的<em class="lz">配置</em>类作为输入，并将 Spring 上下文返回给我们供以后使用。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="7cf9" class="lb lc iq mf b gy mj mk l ml mm">@Configuration<br/>@ComponentScan(basePackages = {"com.dntech.demo"})<br/>public class SpringContextConfiguration {<br/><br/>    public static ConfigurableApplicationContext configure(){<br/>        ConfigurableApplicationContext context = new AnnotationConfigApplicationContext(SpringContextConfiguration.class);<br/>        return context;<br/>    }<br/>}</span></pre><p id="f899" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意<em class="lz">ConfigurableApplicationContext</em>是一个接口。为了创建上下文对象，我们需要一个具体的实现类—<em class="lz">AnnotationConfigApplicationContext</em>。您可以在这里找到其他可用的实现类<a class="ae kc" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/ConfigurableApplicationContext.html" rel="noopener ugc nofollow" target="_blank">。</a></p><h2 id="2413" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">第二步。在必要的类中获取上下文。</h2><p id="64d5" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">我们拥有的组件类之一是<em class="lz"> SomeServiceDao </em>。为简单起见，我们模拟一个方法，通过返回一个字符串“Some DB Data”从 DB 获取数据。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="0c86" class="lb lc iq mf b gy mj mk l ml mm">@Component<br/>public class SomeServiceDao {<br/><br/>    public String getSomeDbData(){<br/>        return "Some DB data";<br/>    }<br/>}</span></pre><p id="d181" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们如何利用上面的 Spring 上下文来访问这个方法呢？</p><p id="edab" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面的<em class="lz"> SomeService </em>类包含了主要的业务逻辑。这里我们可以初始化默认构造函数中的<em class="lz"> SomeServiceDao </em>和<em class="lz">ConfigurableApplicationContext</em>。</p><p id="6490" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将首先通过调用静态方法<em class="lz"> configure </em>()来获取 spring 上下文。之后，我们利用<em class="lz"> getBean </em>方法来分配<em class="lz"> serviceDao </em>字段。</p><p id="7ef1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们可以把重点放在我们的业务逻辑下面。这里我们有一个简单的方法从<em class="lz"> serviceDao </em>类调用方法。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="16f8" class="lb lc iq mf b gy mj mk l ml mm">public class SomeService {<br/><br/>    final SomeServiceDao serviceDao;<br/>    final ConfigurableApplicationContext context;<br/><br/>    public SomeService() {<br/>        this.context = SpringContextConfiguration.<em class="lz">configure</em>();<br/>        this.serviceDao = this.context.getBean(SomeServiceDao.class);<br/>    }<br/><br/>    public String getData(){<br/>        return this.serviceDao.getSomeDbData();<br/>    }<br/>}</span></pre><h2 id="6ba4" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">第三步。访问方法。</h2><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="2faf" class="lb lc iq mf b gy mj mk l ml mm">public class Application {<br/><br/>    public static void main(String[] args) {<br/>        final SomeService someService = new SomeService();<br/>        System.<em class="lz">out</em>.println(someService.getData());<br/>    }<br/>}</span></pre><p id="215a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在主应用程序类中，我们可以只构造我们的服务类并调用方法:</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/b371799266f8346362aa37d08b3d7872.png" data-original-src="https://miro.medium.com/v2/resize:fit:1060/format:webp/1*TkN6S4nbcjtRhoKM4csfiA.png"/></div></figure><p id="618f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的程序输出正确的字符串。</p></div><div class="ab cl mo mp hu mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ij ik il im in"><p id="9bc6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将看到<em class="lz">ConfigurableApplicationContext</em>如何帮助我们访问定制 beans。我希望这篇文章对你有所帮助。</p><p id="4d20" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你像我一样，渴望学习 Java 和更多关于后端工程的知识，请关注我的频道，了解我在日常工作和生活中获得的灵感。</p><blockquote class="mv mw mx"><p id="e723" class="kd ke lz kf b kg kh ki kj kk kl km kn my kp kq kr mz kt ku kv na kx ky kz la ij bi translated"><strong class="kf ir"> <em class="iq">阅读更多:</em> </strong> <em class="iq"> <br/> </em> <a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/a-case-about-java-static-keyword-during-my-job-53cebb6af597"> <em class="iq">一个关于 Java 静态关键字在职期间的案例</em></a><em class="iq"><br/></em><a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/how-can-you-solve-this-java-multithreading-interview-problem-8e6ec53fab27"><em class="iq">如何解决这个 Java 多线程面试问题？</em>T19】</a></p></blockquote></div></div>    
</body>
</html>