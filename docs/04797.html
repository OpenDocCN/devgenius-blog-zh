<html>
<head>
<title>Codetree ! Or why i create a new Codepen.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">代码树！或者为什么我要创建一个新的密码笔。</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/codetree-or-why-i-create-a-new-codepen-5596bd52f96a?source=collection_archive---------8-----------------------#2021-05-07">https://blog.devgenius.io/codetree-or-why-i-create-a-new-codepen-5596bd52f96a?source=collection_archive---------8-----------------------#2021-05-07</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/dc9c1f0e6c4537a7f5e6003f5a1d8bc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z4U9ij8kxudDa-7jOzsw0A.png"/></div></div></figure><p id="f9f6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi kt translated">odepen和codesandbox都很棒，但老实说，它们很慢，如果你的互联网连接很弱，速度会更慢，所以我创建了Codetree，这是一个超快、高性能的在线游戏平台，具有自动npm模块检测功能。</p><h2 id="1314" class="lc ld in bd le lf lg dn lh li lj dp lk kg ll lm ln kk lo lp lq ko lr ls lt lu bi translated">为了能够理解为什么<a class="ae lv" href="https://codetree.vercel.app/" rel="noopener ugc nofollow" target="_blank">代码树</a>是一个强大的在线编辑器，我们将:</h2><ul class=""><li id="4907" class="lw lx in jx b jy ly kc lz kg ma kk mb ko mc ks md me mf mg bi translated">了解codepen的工作原理。</li><li id="372c" class="lw lx in jx b jy mh kc mi kg mj kk mk ko ml ks md me mf mg bi translated">找到一个可以在我们的浏览器中执行的捆绑器。</li><li id="de10" class="lw lx in jx b jy mh kc mi kg mj kk mk ko ml ks md me mf mg bi translated">构建一个简单的react app transpiler。</li></ul><h1 id="fff7" class="mm ld in bd le mn mo mp lh mq mr ms lk mt mu mv ln mw mx my lq mz na nb lt nc bi translated">一、Codepen/Codesandbox是如何工作的？</h1><p id="0a17" class="pw-post-body-paragraph jv jw in jx b jy ly ka kb kc lz ke kf kg nd ki kj kk ne km kn ko nf kq kr ks ig bi translated">感谢伟大的导师<a class="ng nh ep" href="https://medium.com/u/d058882d8cd2?source=post_page-----5596bd52f96a--------------------------------" rel="noopener" target="_blank">斯蒂芬·格里德</a>，我在其中一个视频中找到了关于<a class="ae lv" href="https://codepen.io/" rel="noopener ugc nofollow" target="_blank"> Codepen </a>如何工作的相当详细的解释。为了简化，他们检索原始用户代码，并将其发送到Api后端服务器，服务器将运行Babel或任何其他transpiler，并将结果发送回应用程序，由用户的web浏览器执行。</p><figure class="nj nk nl nm gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ni"><img src="../Images/0e6263bcfb3eba98f8ef5243c29e5289.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*B1vUS8owwELpX9XS"/></div></div></figure><p id="0cd5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这种方法的问题是，每次用户在编辑器中编写代码时都必须发出请求(即使有去抖器)，这需要更多的时间来接收、处理和转换代码，然后才能在应用程序中显示代码。所以对于<a class="ae lv" href="https://codetree.vercel.app/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> Codetree </strong> </a>，我需要直接在浏览器中完成所有这些编译任务。</p></div><div class="ab cl nn no hr np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ig ih ii ij ik"><h1 id="cded" class="mm ld in bd le mn nu mp lh mq nv ms lk mt nw mv ln mw nx my lq mz ny nb lt nc bi translated">下一步:找到一个在浏览器中工作的transpiler和bundler。</h1><blockquote class="nz oa ob"><p id="295d" class="jv jw oc jx b jy jz ka kb kc kd ke kf od kh ki kj oe kl km kn of kp kq kr ks ig bi translated"><strong class="jx io"> transpiler，</strong>是一个获取一种编程语言的源代码并将其编译成另一种编程语言的程序。</p></blockquote><p id="582d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对于<a class="ae lv" href="https://github.com/philippetedajo/codetree" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="oc">code tree</em></strong></a>，我选择了<strong class="jx io"> <em class="oc"> Babel </em> </strong>，它将JavaScript(es 2015或更高版本)转换，并将typeScript转换成兼容的代码，并可由新旧浏览器直接执行。</p><p id="5950" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">捆绑器</strong>用于将多个模块组合成一个模块，更具体地说，它:<br/> 1-解析入口点，例如index.js、main.css <br/> 2-查找导入/导出/要求语句，<br/> 3-在硬盘上搜索这些模块<br/> 4-将所有这些文件链接成一个文件</p><p id="7433" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对于bundler的选择更复杂，因为<strong class="jx io"> Webpack </strong>捆绑过程在浏览器中不工作，作为<a class="ae lv" href="https://webassembly.org/" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="oc">web assembly</em></strong></a><strong class="jx io">，</strong>的忠实粉丝，我查看了<a class="ae lv" href="https://esbuild.github.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="oc">es build</em></strong></a>。</p><p id="a363" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae lv" href="https://webassembly.org/" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="oc">web assembly</em></strong></a><strong class="jx io"/>是一种低级的、类似汇编语言的语言，在web上运行时可以达到接近原生应用程序(例如用C/C++编写)的性能，而<a class="ae lv" href="https://esbuild.github.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="oc">es build</em></strong></a>如文档所说是<em class="oc">一种使用Go和<strong class="jx io"> WebAssembly </strong>构建的速度极快的JavaScript bundler </em>。</p></div><div class="ab cl nn no hr np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ig ih ii ij ik"><h1 id="2940" class="mm ld in bd le mn nu mp lh mq nv ms lk mt nw mv ln mw nx my lq mz ny nb lt nc bi translated">最后代码树是如何工作的？</h1><p id="1731" class="pw-post-body-paragraph jv jw in jx b jy ly ka kb kc lz ke kf kg nd ki kj kk ne km kn ko nf kq kr ks ig bi kt translated"><span class="l ku kv kw bm kx ky kz la lb di">到</span>理解了这一切，我们将使用react创建一个简单的应用程序，它允许我们将typescript编译成可由浏览器直接执行的代码。</p><p id="947e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先，让我们进入终端或命令提示符，运行以下命令:</p><pre class="nj nk nl nm gt og oh oi oj aw ok bi"><span id="a33c" class="lc ld in oh b gy ol om l on oo"> yarn create react-app my-app --template typescript</span></pre><p id="e6b4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果您不熟悉typescript，您可以忽略模板，然后像这样清理您的app.ts文件:</p><pre class="nj nk nl nm gt og oh oi oj aw ok bi"><span id="535c" class="lc ld in oh b gy ol om l on oo">import <em class="oc">React </em>from 'react';</span></pre><figure class="nj nk nl nm gt jo"><div class="bz fp l di"><div class="op oq l"/></div></figure><p id="bc6f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们需要添加一个<strong class="jx io">文本区域</strong>，我们将在其中键入我们的类型脚本代码，一个<strong class="jx io">按钮</strong>来启动<strong class="jx io">传输</strong>，以及一个<strong class="jx io">“pre”</strong>标签来显示<strong class="jx io">传输的代码</strong>:</p><figure class="nj nk nl nm gt jo"><div class="bz fp l di"><div class="op oq l"/></div></figure><p id="638e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们添加状态来存储用户输入代码和输出转换代码:</p><figure class="nj nk nl nm gt jo"><div class="bz fp l di"><div class="op oq l"/></div></figure><p id="23ad" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">我们现在可以将Esbuild集成到我们的项目中:</strong></p><p id="cb53" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Esbuild将允许我们直接在浏览器中传输代码。它附带了一个javascript包装器，用于定义发送到GoLang bundler的命令，以及一个webassembly binary (wasm)包装器，允许我们运行低级语言(如C、Rust、Go..)直接在浏览器里面。</p><ul class=""><li id="e346" class="lw lx in jx b jy jz kc kd kg or kk os ko ot ks md me mf mg bi translated">首先，我们需要安装esbuild-wasm npm模块:</li></ul><pre class="nj nk nl nm gt og oh oi oj aw ok bi"><span id="8a4e" class="lc ld in oh b gy ol om l on oo">yarn add esbuild-wasm@0.8.57</span></pre><p id="b96a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后我们添加以下代码:</p><figure class="nj nk nl nm gt jo"><div class="bz fp l di"><div class="op oq l"/></div></figure><p id="b87b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在让我们快速浏览一下上面写的内容</p><ul class=""><li id="a42b" class="lw lx in jx b jy jz kc kd kg or kk os ko ot ks md me mf mg bi translated">我们在应用程序的主体中为esbuild添加了一个异步初始化函数。</li><li id="2c7a" class="lw lx in jx b jy mh kc mi kg mj kk mk ko ml ks md me mf mg bi translated">我们添加了。wasm文件:<strong class="jx io">" https://UNP kg . com/es build-wasm @ 0 . 8 . 57/es build . wasm "</strong>在wasm参数中。</li><li id="3742" class="lw lx in jx b jy mh kc mi kg mj kk mk ko ml ks md me mf mg bi translated">当第一次使用一个<strong class="jx io"> useEffect钩子</strong>和一个空数组<strong class="jx io">挂载组件时，我们启动服务函数。</strong></li><li id="f3b3" class="lw lx in jx b jy mh kc mi kg mj kk mk ko ml ks md me mf mg bi translated">esbuild的服务函数带有一些内置函数(build:\，serve:\，transform:\，stop: f)</li></ul><p id="f500" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">现在我们的应用程序中的Esbuild设置已经就绪，我们可以尝试编译一些类型脚本代码:</strong></p><figure class="nj nk nl nm gt jo"><div class="bz fp l di"><div class="op oq l"/></div></figure><p id="0610" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">再一次让我们仔细看看发生了什么:</strong></p><ul class=""><li id="5e16" class="lw lx in jx b jy jz kc kd kg or kk os ko ot ks md me mf mg bi translated">首先，我们设置initialize()函数之外可用的服务函数的范围，以便能够在onClick()函数中使用它，我们通过使用<strong class="jx io"> useRef </strong>钩子来引用我们的Esbuild服务<strong class="jx io">来做到这一点。</strong></li><li id="1ad7" class="lw lx in jx b jy mh kc mi kg mj kk mk ko ml ks md me mf mg bi translated">然后，如果Esbuild没有完成初始化，我们会阻止用户执行传输文件。</li><li id="fa43" class="lw lx in jx b jy mh kc mi kg mj kk mk ko ml ks md me mf mg bi translated">我们使用transform函数通过传递一些参数来传输我们的代码:<br/> *The <strong class="jx io"> userInputCode </strong>:我们放在文本区域的代码。<br/>*加载器<strong class="jx io"/>:指定我们提供的代码类型。<br/>*目标<strong class="jx io"/>:要在哪个js环境下生成代码。</li><li id="e759" class="lw lx in jx b jy mh kc mi kg mj kk mk ko ml ks md me mf mg bi translated">最后，我们从transform函数中获取代码结果，并用它来更新transpiledCode状态。</li></ul><p id="abd5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">瞧啊。您已经构建了一个<strong class="jx io"> <em class="oc">的浏览器内打字稿传输器</em> </strong>，现在您可以添加任何打字稿代码并显示结果🥳🥳🥳.</p><figure class="nj nk nl nm gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ou"><img src="../Images/7b7fb85f50d452890b6f8bb691d09264.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C1sQwxHpx6EWMPvw-mVtww.png"/></div></div></figure><p id="d797" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你觉得这个项目有趣，请在<a class="ae lv" href="https://github.com/philippetedajo/Codetree" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> Github </strong> </a>上留个星支持我们，你可以在这里找到完整的开源项目<a class="ae lv" href="https://github.com/philippetedajo/codetree" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="oc">code tree</em></strong></a><em class="oc">。✨ </em></p></div></div>    
</body>
</html>