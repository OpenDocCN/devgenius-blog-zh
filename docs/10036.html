<html>
<head>
<title>Understanding Git Merge and Git Rebase</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解 Git 合并和 Git Rebase</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/understanding-git-merge-and-git-rebase-ae8bccf50829?source=collection_archive---------2-----------------------#2022-10-02">https://blog.devgenius.io/understanding-git-merge-and-git-rebase-ae8bccf50829?source=collection_archive---------2-----------------------#2022-10-02</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div class="gh gi il"><img src="../Images/82a3613fd0af00e3d2103aee5fcb23f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S5h7HHJIOcHQ1ih3p8u1vQ.png"/></div><figcaption class="is it gj gh gi iu iv bd b be z dk translated">Git Rebase 和 Git Merge</figcaption></figure><div class=""/><p id="ea8c" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">作为一名开发人员，我们中的许多人不得不在<strong class="jx iz"> git merge </strong>和<strong class="jx iz"> git rebase 之间做出选择。</strong>在这篇博客中，我将让你清楚这两个命令的一切，然后你将能够自己决定何时使用和使用哪个命令。</p><p id="5bfc" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先要理解的是，命令<strong class="jx iz"> git rebase </strong>和<strong class="jx iz"> git merge </strong>的目的是一样的。这两个命令都旨在将一个分支的变更集成到另一个分支中——它们只是以非常不同的方式完成。</p><p id="689d" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">假设你正在一个专门的分支上从事<strong class="jx iz">特性</strong>的工作。与此同时，有人提交了对主<strong class="jx iz">分支</strong>的一些更改，这导致了分叉的历史，这对于使用过 Git 作为协作工具的人来说应该很熟悉。</p><figure class="ku kv kw kx gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi kt"><img src="../Images/0e31933b85fc4edd71167af7d6a157cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_L9yu9ihA0XExvZoJPKHXw.png"/></div></div></figure><p id="4ec2" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在让我们假设新的提交在某种程度上与您正在处理的特性相关。您有两种选择来将新的提交合并到您的特性分支中:合并或重新定基。</p><h2 id="2a7b" class="lc ld iy bd le lf lg dn lh li lj dp lk kg ll lm ln kk lo lp lq ko lr ls lt lu bi translated"><strong class="ak"> Git 合并</strong></h2><figure class="ku kv kw kx gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi lv"><img src="../Images/2e2be83c882c58502eac09e6dad0aaa3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rIf5sdB4N40q7CggBsj2lA.jpeg"/></div></div><figcaption class="is it gj gh gi iu iv bd b be z dk translated">git 合并</figcaption></figure><p id="5862" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对于使用版本控制系统的开发人员来说，合并是一种常见的做法。无论分支是为了测试、错误修复还是其他原因而创建的，合并都会将更改提交到另一个位置。更具体地说，合并获取源分支的内容，并将它们与目标分支集成在一起。在这个过程中，只有目标分支被改变。源分支历史保持不变。</p><h2 id="833a" class="lc ld iy bd le lf lg dn lh li lj dp lk kg ll lm ln kk lo lp lq ko lr ls lt lu bi translated"><strong class="ak">怎么做？</strong></h2><pre class="ku kv kw kx gt lw lx ly lz aw ma bi"><span id="607e" class="lc ld iy lx b gy mb mc l md me"><strong class="lx iz">$ git checkout feature</strong></span><span id="60ba" class="lc ld iy lx b gy mf mc l md me"><strong class="lx iz">$ git merge master</strong></span></pre><p id="1a0e" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">或者在一条线上你可以做</p><pre class="ku kv kw kx gt lw lx ly lz aw ma bi"><span id="9a9f" class="lc ld iy lx b gy mb mc l md me"><strong class="lx iz">$ git merge master feature</strong></span></pre><p id="b75e" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">使用 git merge 的利弊？</strong></p><p id="c985" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">优点:</strong></p><ul class=""><li id="a68f" class="mg mh iy jx b jy jz kc kd kg mi kk mj ko mk ks ml mm mn mo bi translated">合并很好，因为这是一种非破坏性的 T21 操作。</li><li id="0b3a" class="mg mh iy jx b jy mq kc mr kg ms kk mt ko mu ks ml mm mn mo bi translated">现有的分支不会以任何方式改变。这避免了重定基数的所有潜在缺陷(下面讨论的<strong class="jx iz"/>)。</li><li id="bd91" class="mg mh iy jx b jy mq kc mr kg ms kk mt ko mu ks ml mm mn mo bi translated">保存完整的历史和时间顺序。</li></ul><p id="ebb5" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">缺点:</strong></p><ul class=""><li id="f0c9" class="mg mh iy jx b jy jz kc kd kg mi kk mj ko mk ks ml mm mn mo bi translated">如果<strong class="jx iz">主分支</strong>非常活跃，这可能会对你的特征分支的历史造成相当大的影响。虽然有可能通过高级的 git log 选项来缓解这个问题，但是这会让其他开发人员很难理解项目的历史。</li></ul><h2 id="05e7" class="lc ld iy bd le lf lg dn lh li lj dp lk kg ll lm ln kk lo lp lq ko lr ls lt lu bi translated"><strong class="ak"> Git Rebase </strong></h2><figure class="ku kv kw kx gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi mv"><img src="../Images/d5a34b432e805e40fde3d8ac528e7e5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NpEOBwe5k7wUuVQZa4hLuw.jpeg"/></div></div><figcaption class="is it gj gh gi iu iv bd b be z dk translated">git rebase</figcaption></figure><p id="8841" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Rebase 是将变更从一个分支整合到另一个分支的另一种方式。Rebase 将所有更改压缩到一个“补丁”中然后，它将补丁集成到目标分支上。与合并不同，重定基础使历史变平，因为它将完成的工作从一个分支转移到另一个分支。在这个过程中，不需要的历史被删除。</p><p id="e340" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">怎么做？</strong></p><pre class="ku kv kw kx gt lw lx ly lz aw ma bi"><span id="5f8e" class="lc ld iy lx b gy mb mc l md me"><strong class="lx iz">$ git checkout feature</strong></span><span id="daa2" class="lc ld iy lx b gy mf mc l md me"><strong class="lx iz">$ git rebase master</strong></span></pre><p id="7220" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">使用 git rebase 的利弊？</strong></p><p id="bf61" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">优点:</strong></p><ul class=""><li id="eb24" class="mg mh iy jx b jy jz kc kd kg mi kk mj ko mk ks ml mm mn mo bi translated">重定基础的主要好处是你可以得到一个更加清晰的项目历史。</li><li id="6d8c" class="mg mh iy jx b jy mq kc mr kg ms kk mt ko mu ks ml mm mn mo bi translated">在具有繁忙分支的繁忙存储库中避免<strong class="jx iz">合并</strong>提交“噪音”。</li><li id="e7ad" class="mg mh iy jx b jy mq kc mr kg ms kk mt ko mu ks ml mm mn mo bi translated">操作单个提交很容易(例如，恢复它们)。</li><li id="0c80" class="mg mh iy jx b jy mq kc mr kg ms kk mt ko mu ks ml mm mn mo bi translated">重定基础还会产生一个完美的线性项目历史——你可以跟随<strong class="jx iz">特性</strong>的提示一直到项目的开始，而不需要任何分叉。</li></ul><p id="14e4" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">缺点:</strong></p><ul class=""><li id="bb2b" class="mg mh iy jx b jy jz kc kd kg mi kk mj ko mk ks ml mm mn mo bi translated">将该特性压缩为少量的提交可以隐藏上下文。</li><li id="0238" class="mg mh iy jx b jy mq kc mr kg ms kk mt ko mu ks ml mm mn mo bi translated">在团队工作时，改变公共存储库的基础是很危险的</li><li id="3ee9" class="mg mh iy jx b jy mq kc mr kg ms kk mt ko mu ks ml mm mn mo bi translated">这需要更多的工作:使用 rebase 来保持你的特性分支总是更新的。</li><li id="d68f" class="mg mh iy jx b jy mq kc mr kg ms kk mt ko mu ks ml mm mn mo bi translated">你不正确地改变了基础，无意中改写了历史，这可能会导致严重的问题，所以请确保你知道你在做什么！</li></ul><h2 id="9c76" class="lc ld iy bd le lf lg dn lh li lj dp lk kg ll lm ln kk lo lp lq ko lr ls lt lu bi translated"><strong class="ak">用哪个？</strong></h2><p id="8cea" class="pw-post-body-paragraph jv jw iy jx b jy mw ka kb kc mx ke kf kg my ki kj kk mz km kn ko na kq kr ks ig bi translated">在将 Git 设置为 rebase vs. merge 策略时，需要考虑几个问题。因为事实证明，一种工作流策略并不比另一种更好。这取决于你和你的团队。</p><p id="4c4c" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">根据我的个人经验，我建议在团队工作时避免使用 git rebase。</p><h2 id="108c" class="lc ld iy bd le lf lg dn lh li lj dp lk kg ll lm ln kk lo lp lq ko lr ls lt lu bi translated"><strong class="ak">结论</strong></h2><p id="4ced" class="pw-post-body-paragraph jv jw iy jx b jy mw ka kb kc mx ke kf kg my ki kj kk mz km kn ko na kq kr ks ig bi translated">我希望这篇博客对<strong class="jx iz"> git merge </strong>和<strong class="jx iz"> git rebase 给出了一些见解。</strong>了解<strong class="jx iz"> </strong>更多关于 git 命令请查看此<a class="ae nb" rel="noopener ugc nofollow" target="_blank" href="/basic-git-commands-every-developer-should-know-9b947d56bd37"> <strong class="jx iz">文章</strong> </a> <strong class="jx iz">。</strong></p><p id="b7fd" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你有任何问题或反馈，请在下面的评论区告诉我。我们还可以通过<strong class="jx iz"/><a class="ae nb" href="https://twitter.com/ApoorvD72358398" rel="noopener ugc nofollow" target="_blank"><strong class="jx iz">Twitter</strong></a>和<a class="ae nb" href="https://www.linkedin.com/in/apoorv-dubey-8a3a31191/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx iz"> LinkedIn </strong> </a>了解更多我的科技之旅。</p></div></div>    
</body>
</html>