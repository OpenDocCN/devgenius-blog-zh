<html>
<head>
<title>S3, S4, RC, R6. Object oriented in R — Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">S3，S4，RC，R6。R 语言中的面向对象—第二部分</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/s3-s4-rc-r6-object-oriented-in-r-part-2-109b3d82046e?source=collection_archive---------4-----------------------#2022-09-20">https://blog.devgenius.io/s3-s4-rc-r6-object-oriented-in-r-part-2-109b3d82046e?source=collection_archive---------4-----------------------#2022-09-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="4818" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">RC 和 R6 对象。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/48600e30f16a5ae08ca7a4488449031d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VcZWAQ-cBABKgubOWxxBPA.png"/></div></div></figure><p id="5afc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本文基于我在第 1 部分中介绍的概念。</p><h1 id="b564" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">第 2 部分的主题</h1><ul class=""><li id="8681" class="lw lx iq jp b jq ly ju lz jy ma kc mb kg mc kk md me mf mg bi translated">RC 对象。</li><li id="335a" class="lw lx iq jp b jq mh ju mi jy mj kc mk kg ml kk md me mf mg bi translated">R6 反对。</li><li id="caa3" class="lw lx iq jp b jq mh ju mi jy mj kc mk kg ml kk md me mf mg bi translated">最终考虑</li></ul><h1 id="053e" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">RC 对象</h1><p id="bdd8" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">引用类(RC)是 base R 的一部分，与 S3 或 S4 相比，它是 R 中一个非常不同的 OO 实现。S3 和 S4 代表功能性的面向对象，而 RC 是封装的面向对象。在 RC 中，方法属于类，而不属于函数。</p><p id="be36" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">传统的 OO 开发人员对 RC 会很熟悉。传统的面向对象被正式定义并被封装。然而，RC 语法和行为对纯 R 开发人员来说并不友好。稍后我们会看到一些这样的例子。</p><p id="47ed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们看一下<code class="fe mp mq mr ms b">Animals</code>例子的 RC 实现。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="0d17" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们创建了具有以下属性的类<code class="fe mp mq mr ms b">Animals</code>:</p><ul class=""><li id="29c7" class="lw lx iq jp b jq jr ju jv jy mv kc mw kg mx kk md me mf mg bi translated"><code class="fe mp mq mr ms b">fields</code>:这是对象内部的变量列表。</li><li id="ecfb" class="lw lx iq jp b jq mh ju mi jy mj kc mk kg ml kk md me mf mg bi translated"><code class="fe mp mq mr ms b">methods</code>:属于类的方法。</li></ul><p id="b0f5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mp mq mr ms b">initialize</code>方法首先验证输入，然后格式化<code class="fe mp mq mr ms b">species</code>字符串，最后初始化对象。</p><p id="d9c3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在实际应用中，我们可以考虑上面一个低级构造函数的例子。您可能希望为用户提供一个用户友好的构造函数来创建对象。昂贵的验证检查可以保留给用户公开的构造函数。</p><p id="7324" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果类定义变得太长，建议将其分成小块。我们可以通过使用<code class="fe mp mq mr ms b">&lt;class_name&gt;$methods(&lt;method_name&gt; = function(){})</code>语法将方法附加到类定义上。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mt mu l"/></div></figure><h1 id="9d2f" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">遗产</h1><p id="0f73" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">RC 通过构造函数的<code class="fe mp mq mr ms b">contains</code>参数支持继承。让我们考虑一下我们的<code class="fe mp mq mr ms b">Dog</code>子类。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="6b60" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们定义类及其方法的方式与我们定义<code class="fe mp mq mr ms b">Animals</code>的方式相同。但是，既然我们用了<code class="fe mp mq mr ms b">contains</code>，那么<code class="fe mp mq mr ms b">Dog</code>就是<code class="fe mp mq mr ms b">Animals</code>的子类。我们可以从现场<code class="fe mp mq mr ms b">species</code>看到这一点。我们没有在<code class="fe mp mq mr ms b">fields</code>中定义<code class="fe mp mq mr ms b">species</code>，但是我们从<code class="fe mp mq mr ms b">Animals</code>中继承了它。</p><p id="6d5b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们需要从超类中调用一个方法并解决名称冲突，我们可以使用<code class="fe mp mq mr ms b">callSuper</code>方法。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="cf0a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意<code class="fe mp mq mr ms b">show</code>方法是如何从<code class="fe mp mq mr ms b">Animals</code>继承的，我们使用<code class="fe mp mq mr ms b">superClass</code>函数从<code class="fe mp mq mr ms b">Dog</code>调用它。</p><h1 id="3200" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">RC 是可变的</h1><p id="94c8" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">RC 对象是可变的。也就是说，我们可以在修改对象的同时返回值。在狗的例子中，我们在方法<code class="fe mp mq mr ms b">updateAge</code>中演示了这一点。此方法修改对象以更新年龄字段。同时返回之前的年龄。这是一个强大的功能，但我们需要小心。可变性不是 R 中的自然行为:它会让开发人员措手不及。这也使得推理对象的效果和行为变得更加困难。尽可能地限制可变性，并始终将副作用(修改对象)与直接回报分开。</p><h1 id="8740" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">内置方法</h1><p id="f942" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">RC 有几个内置的方法。我们已经看到了其中的一些，比如访问字段的<code class="fe mp mq mr ms b">field</code>，或者为对象创建新方法的<code class="fe mp mq mr ms b">methods</code>。</p><p id="0fd0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mp mq mr ms b">copy</code>是一个重要的内置方法。它强调了“标准”R 行为和 RC 行为之间的根本区别。正如名字<em class="my">引用</em>所暗示的，当我们创建一个<em class="my"> ReferenceClass </em>对象的副本时，我们不是创建一个独立的副本，而是一个被引用的副本。这意味着如果我们修改了对象的一个版本，我们也修改了它的副本。为了进行独立复制，我们需要使用<code class="fe mp mq mr ms b">copy</code>方法，将<code class="fe mp mq mr ms b">shallow</code>参数设置为<code class="fe mp mq mr ms b">FALSE</code>。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="c33e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于一个 R 开发人员来说，这看起来非常奇怪和出乎意料。如果不小心使用的话，你可以预见它会产生一些问题。</p><p id="4d0d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">其他内置方法有:</p><ul class=""><li id="217f" class="lw lx iq jp b jq jr ju jv jy mv kc mw kg mx kk md me mf mg bi translated"><code class="fe mp mq mr ms b">new</code>:用于初始化对象。<code class="fe mp mq mr ms b">newAnimal &lt;- Animals$new()</code>等于<code class="fe mp mq mr ms b">newAnimal &lt;- Animals()</code>。</li><li id="fcec" class="lw lx iq jp b jq mh ju mi jy mj kc mk kg ml kk md me mf mg bi translated"><code class="fe mp mq mr ms b">help</code>:提供帮助文档。</li><li id="1523" class="lw lx iq jp b jq mh ju mi jy mj kc mk kg ml kk md me mf mg bi translated"><code class="fe mp mq mr ms b">methods</code>:创建新方法。</li></ul><p id="4eeb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">完整的列表可以在<a class="ae kx" href="https://www.rdocumentation.org/packages/methods/versions/3.6.2/topics/ReferenceClasses" rel="noopener ugc nofollow" target="_blank"> RC 文档页面</a>上找到。</p><h1 id="2e1d" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">包裹</h1><p id="d5f3" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">RC 对象对熟悉其他语言 OO 的开发人员很有吸引力。RC 支持熟悉的模式和概念，例如封装。然而，它使用了 R 语言不熟悉的机制，比如可变性。这些机制使得 R 开发人员更难阅读和维护代码。</p><p id="b331" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，RC 的文档记录很差:它的所有文档都在<a class="ae kx" href="https://www.rdocumentation.org/packages/methods/versions/3.6.2/topics/ReferenceClasses" rel="noopener ugc nofollow" target="_blank">这一页</a>。RC 也比 R6 慢，后者基于相同的原理。</p><p id="f5e9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后一点是关于私有方法的。在 RC 中，没有(简单的)方法来创建私有方法或字段。如果你足够努力地搜索 stackoverflow，你会发现一些变通办法，但它们仅仅是:变通办法。</p><p id="d3be" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于所有这些原因，在任何情况下都很难推荐 RC。如果您需要增加 RC 可变性和封装的复杂性，请使用 R6。唯一需要考虑 RC 的情况是当你处理遗留代码并且 RC 已经被使用的时候。</p><h1 id="4a0e" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">R6</h1><p id="4790" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">R6 是封装面向对象的另一个实现。它不是 base R 的一部分，你需要安装<code class="fe mp mq mr ms b">R6</code>包。R6 与 RC 共享许多功能，但它基于 S3，而不是 S4。</p><p id="62e5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们来看看如何编写<code class="fe mp mq mr ms b">Animals</code>类。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="bd3c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">R6 通过<code class="fe mp mq mr ms b">private</code>支持私有方法和字段。您可以使用<code class="fe mp mq mr ms b">private$</code>符号从公共方法中访问私有方法和字段，如上面的<code class="fe mp mq mr ms b">initialize</code>方法所示。</p><p id="aeeb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">R6 也支持管道。如果你熟悉 Python，你会知道你可以使用<code class="fe mp mq mr ms b">.</code>符号来链接命令:<code class="fe mp mq mr ms b">method1().method2().method3()</code>。在 R6，我们可以使用<code class="fe mp mq mr ms b">$</code>操作符做同样的事情，如上面例子的最后一行所示。</p><h1 id="6cd8" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">遗产</h1><p id="4b76" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">R6 继承要求在类定义中使用<code class="fe mp mq mr ms b">inherit</code>参数。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="d8a8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以使用<code class="fe mp mq mr ms b">super</code>访问超类的公共和私有属性，如下例所示。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mt mu l"/></div></figure><h1 id="874b" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">R6 是可变的</h1><p id="a9d7" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">R6 对象是可变的，至于 RC，我们用<code class="fe mp mq mr ms b">updateAge</code>方法演示了这一点。</p><p id="6413" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">同样，可变性不是一种正常的 R 行为:尽量少用它。</p><h1 id="8191" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">内置方法</h1><p id="71d6" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">R6 对象有内置的方法。最值得注意的是<code class="fe mp mq mr ms b">clone</code>。<code class="fe mp mq mr ms b">clone</code>允许您创建对象的深层副本。如果你经常在 RC 和 R6 之间切换，只要记住 RC 的<code class="fe mp mq mr ms b">copy</code>与 R6 的<code class="fe mp mq mr ms b">clone</code>工作原理相反:<code class="fe mp mq mr ms b">copy(shallow=FALSE)</code>等同于<code class="fe mp mq mr ms b">clone(deep=TRUE)</code>。</p><h1 id="d8e5" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">包裹</h1><p id="cd88" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">RC 和 R6 都是传统 OO 开发者所熟悉的。RC 和 R6 的语法和功能集是相似的。一个关键的区别是 R6 有对私有方法的本地支持。</p><p id="bac1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">RC 和 R6 有两个主要区别:性能和文档。R6 的表现比 RC 好，这也是 Shiny 从 RC 转投 R6 的原因之一。至于文档，R6 比 RC 有更好的文档。</p><h1 id="3432" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">R 中的面向对象:最终总结</h1><p id="e7b4" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">r 是一种函数式语言。然而，R 支持面向对象的编程。面向原生 R 对象属于函数类型。在这个实现中，方法属于一个函数(泛型)，而不是属于一个类。不同的类可以在现有的泛型中插入新的方法。这种类型的类没有正式定义，对于非 R 开发人员来说可能看起来很奇怪。</p><p id="f64a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">r 有两种类型的功能性面向对象:S3 和 S4。S3 被很好地记录并嵌入在 base R 中。像<code class="fe mp mq mr ms b">print</code>或<code class="fe mp mq mr ms b">summary</code>这样的函数实际上是 S3 泛型。我们可以创建新的 S3 类，并利用这些现有的泛型。我们要做的就是编写新的方法。这对 R 开发人员来说是非常自然的。此外，生成的语法将使用常见的 R 动词。</p><p id="a912" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">S4 比 S3 更复杂。它们是正式定义的，这种增加的刚性可以简化大型团队的工作。这是 S4 成为生物导体项目骨干的主要原因之一。</p><p id="2df6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你需要“传统的”面向对象封装，那么你可以使用 RC 或 R6。R6 甚至支持私有属性。RC 和 R6 的缺点是它们有一些非 R 标准的属性，比如可变性和浅拷贝。这些特性可能会给不熟悉它们的其他团队成员造成混淆。请记住，你是在一个团队中工作，你必须致力于提供最好的解决方案。这是每个人都能理解和维护的解决方案，但不是技术上最先进的。</p><p id="0b62" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我处理物体时，我倾向于处理 S3、S4 的组合，只有一小部分是 R6。对于向用户公开的类，我使用 S4 或 R6，对于内部方法，我使用 S3。这样，我可以在应用程序的外层利用接口的正式定义。同时，当我不必担心外部输入时，我可以使用 S3 的灵活性。只有当我不得不与熟悉 OO 的非 R 开发人员一起工作时，我才使用 R6。他们倾向于发现在 R6 工作很舒服，同时他们也开始理解 S3 和 S4 的概念。</p><p id="2baa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是一个快速参考表，帮助你定义你的 R 的 OO 策略。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mz"><img src="../Images/afdc7e4247719cdef1513289856d608a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4k2FzXClXRIRzc5qTgDbTA.png"/></div></div></figure><p id="74d0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我希望这篇面向对象的快速指南对你有用。如果您想获得更多关于如何改进编码的技巧，请订阅并关注。</p></div></div>    
</body>
</html>