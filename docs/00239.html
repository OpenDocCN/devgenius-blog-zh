<html>
<head>
<title>Performance Monitoring with Spring Boot</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Spring Boot进行性能监控</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/performance-monitoring-with-spring-boot-721fdf837ebd?source=collection_archive---------6-----------------------#2020-05-26">https://blog.devgenius.io/performance-monitoring-with-spring-boot-721fdf837ebd?source=collection_archive---------6-----------------------#2020-05-26</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/030600fb56f80a9598e4b86ad2dd7335.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*oHHKjRn201hgW9Zw"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">里卡多·罗查在<a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="f119" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这篇文章中，我想展示Spring Boot为性能监控提供的一些有趣的特性。</p><p id="0f53" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一旦应用程序开始扩展，性能就成了重中之重。我们过度优化应用程序，失去了简单性。这就是软件开发的工作方式。在生产场景中，我们监控应用程序的性能。随着大多数应用程序向云迁移，监控应用程序并不断提高性能至关重要。</p><p id="769f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果您使用了弹簧执行器，它会提供大量的统计数据进行监控。以前，我讨论过这个主题<a class="ae jz" href="https://betterjavacode.com/2018/09/14/spring-boot-actuator/" rel="noopener ugc nofollow" target="_blank">弹簧执行器。</a></p><p id="3c66" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">随后，我们将涵盖Spring Boot的一些不同的功能。我们将讨论<strong class="kc io">customizabletraceconnector</strong>、<strong class="kc io">performance monitor interceptor</strong>和<strong class="kc io">CommonsRequestLoggingFilter</strong>。</p><h1 id="34f1" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">使用CustomizableTraceInterceptor</h1><p id="5f67" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">您可以添加CustomizableTraceInterceptor作为一个<code class="fe mb mc md me b">Bean</code>并使用该Bean作为您想要拦截的表达式的顾问。这个拦截器允许我们拦截方法调用并添加定制的日志消息。</p><p id="9af5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了在工作示例中展示这一点，我们将跟踪存储库计时。首先，创建一个扩展<code class="fe mb mc md me b">CustomizableTraceInterceptor</code>的类，如下所示:</p><pre class="mf mg mh mi gt mj me mk ml aw mm bi"><span id="fc60" class="mn kz in me b gy mo mp l mq mr">package com.abccompany.home.performance;</span><span id="20df" class="mn kz in me b gy ms mp l mq mr">import org.aopalliance.intercept.MethodInvocation;<br/>import org.apache.commons.logging.Log;<br/>import org.springframework.aop.framework.AopProxyUtils;<br/>import org.springframework.aop.interceptor.CustomizableTraceInterceptor;<br/>import org.springframework.data.jpa.repository.support.SimpleJpaRepository;</span><span id="7a5a" class="mn kz in me b gy ms mp l mq mr">public class RepositoryMethodInterceptor extends CustomizableTraceInterceptor<br/>{<br/>    @Override<br/>    protected Class&lt;?&gt; getClassForLogging(Object target)<br/>    {<br/>        Class&lt;?&gt; classForLogging = super.getClassForLogging(target);<br/>        if (SimpleJpaRepository.class.equals(classForLogging))<br/>        {<br/>            Class&lt;?&gt;[] interfaces = AopProxyUtils.proxiedUserInterfaces(target);<br/>            if (interfaces.length &gt; 0)<br/>            {<br/>                return interfaces[0];<br/>            }<br/>        }<br/>        return classForLogging;<br/>    }<br/></span><span id="99d3" class="mn kz in me b gy ms mp l mq mr">    protected void writeToLog(Log logger, String message, Throwable ex)<br/>    {<br/>        if (ex != null)<br/>        {<br/>            logger.info(message, ex);<br/>        }<br/>        else<br/>        {<br/>            logger.info(message);<br/>        }<br/>    }</span><span id="2271" class="mn kz in me b gy ms mp l mq mr">    protected boolean isInterceptorEnabled(MethodInvocation invocation, Log logger)<br/>    {<br/>        return true;<br/>    }<br/></span><span id="1b77" class="mn kz in me b gy ms mp l mq mr">}</span></pre><p id="5118" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我一会儿会解释这个类在做什么。我们需要一个<code class="fe mb mc md me b">@Bean</code>，它将使用这个拦截器来拦截存储库方法。这方面的代码如下所示:</p><pre class="mf mg mh mi gt mj me mk ml aw mm bi"><span id="c3c5" class="mn kz in me b gy mo mp l mq mr">package com.abccompany.home.performance;</span><span id="2fc7" class="mn kz in me b gy ms mp l mq mr">import org.springframework.aop.Advisor;<br/>import org.springframework.aop.aspectj.AspectJExpressionPointcut;<br/>import org.springframework.aop.support.DefaultPointcutAdvisor;<br/>import org.springframework.context.annotation.Bean;<br/>import org.springframework.context.annotation.Configuration;<br/>import org.springframework.context.annotation.EnableAspectJAutoProxy;</span><span id="d3bd" class="mn kz in me b gy ms mp l mq mr">@Configuration<br/>@EnableAspectJAutoProxy(proxyTargetClass = true)<br/>public class TraceLoggerConfig<br/>{<br/>    @Bean<br/>    public RepositoryMethodInterceptor repositoryMethodInterceptor()<br/>    {<br/>        RepositoryMethodInterceptor repositoryMethodInterceptor = new RepositoryMethodInterceptor();<br/>        repositoryMethodInterceptor.setHideProxyClassNames(true);<br/>        repositoryMethodInterceptor.setUseDynamicLogger(false);<br/>        repositoryMethodInterceptor.setExitMessage("Executed $[methodName] in $[invocationTime] " +<br/>                "ms");<br/>        return repositoryMethodInterceptor;<br/>    }</span><span id="1cec" class="mn kz in me b gy ms mp l mq mr">    @Bean<br/>    public Advisor advisor()<br/>    {<br/>        AspectJExpressionPointcut aspectJExpressionPointcut = new AspectJExpressionPointcut();<br/>        aspectJExpressionPointcut.setExpression("execution(public * com.abccompany.home" +<br/>                ".repositories.*Repository+.*(..))");<br/>        return new DefaultPointcutAdvisor(aspectJExpressionPointcut, repositoryMethodInterceptor());<br/>    }<br/>}</span></pre><p id="cfeb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，如果我们看看这个配置，这是创建一个使用<code class="fe mb mc md me b">RepositoryMethodInterceptor</code>的bean，它是<code class="fe mb mc md me b">CustomizableTraceInterceptor</code>的子类。您可以看到，我们使用了一个退出消息来记录存储库方法在这个bean中使用的时间。</p><pre class="mf mg mh mi gt mj me mk ml aw mm bi"><span id="24a2" class="mn kz in me b gy mo mp l mq mr">repositoryMethodInterceptor.setExitMessage("Executed $[methodName] in $[invocationTime] " +<br/>        "ms");</span></pre><p id="a7ea" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">AspectJExpression创建一个表达式，应该对其进行包拦截。这个类<code class="fe mb mc md me b">RepositoryMethodInterceptor</code>做了一些有用的事情。首先，它帮助我们<strong class="kc io">跟踪<code class="fe mb mc md me b">Repository</code>类的类信息</strong>。其次，它<strong class="kc io">将消息</strong>记录在我们的日志文件中。运行该应用程序后，您将看到如下日志消息:</p><pre class="mf mg mh mi gt mj me mk ml aw mm bi"><span id="f14f" class="mn kz in me b gy mo mp l mq mr">2020-05-24 19:08:04.870  INFO 14724 --- [nio-8443-exec-9] c.r.h.p.RepositoryMethodInterceptor      : Entering method 'findUserByEmail' of class [com.abccompany.home.repositories.UserdataRepository]<br/>Hibernate: select userdata0_.id as id1_4_, userdata0_.email as email2_4_, userdata0_.firstname as firstnam3_4_, userdata0_.guid as guid4_4_, userdata0_.lastname as lastname5_4_, userdata0_.middlename as middlena6_4_, userdata0_.confirmpassword as confirmp7_4_, userdata0_.passwordtxt as password8_4_, userdata0_.phonenumber as phonenum9_4_, userdata0_.role as role10_4_ from userdata userdata0_ where userdata0_.email=?<br/>2020-05-24 19:08:04.872  INFO 14724 --- [nio-8443-exec-9] c.r.h.p.RepositoryMethodInterceptor      : Executed findUserByEmail in 2 ms<br/>2020-05-24 19:08:04.872  INFO 14724 --- [nio-8443-exec-9] c.r.h.p.RepositoryMethodInterceptor      : Entering method 'findAll' of class [com.abccompany.home.repositories.FeedbackRepository]<br/>Hibernate: select feedback0_.id as id1_1_, feedback0_.createdon as createdo2_1_, feedback0_.fromdate as fromdate3_1_, feedback0_.guid as guid4_1_, feedback0_.rating as rating5_1_, feedback0_.rentalpropertyid as rentalpr8_1_, feedback0_.review as review6_1_, feedback0_.todate as todate7_1_, feedback0_.userid as userid9_1_ from feedback feedback0_<br/>2020-05-24 19:08:04.876  INFO 14724 --- [nio-8443-exec-9] c.r.h.p.RepositoryMethodInterceptor      : Executed findAll in 4 ms</span></pre><h1 id="4a97" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">使用PerformanceMonitorInterceptor</h1><p id="005e" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">为了使用<code class="fe mb mc md me b">PerformanceMonitorInterceptor</code>，我们将创建一个配置类，并添加一个将创建<code class="fe mb mc md me b">PerformanceMonitorInterceptor</code>的bean。<code class="fe mb mc md me b">AspectJExpressionPointcut</code>将指向评估我们的控制器类的表达式。</p><p id="3e6c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">像<code class="fe mb mc md me b">CustomizableTraceInterceptor</code>一样，我们将<strong class="kc io">有一个子类，它将扩展</strong> <code class="fe mb mc md me b">PerformanceMonitoringInterceptor</code>，这样我们可以在Spring Boot日志中记录我们的消息。这将如下所示:</p><pre class="mf mg mh mi gt mj me mk ml aw mm bi"><span id="cb83" class="mn kz in me b gy mo mp l mq mr">package com.abccompany.home.performance;</span><span id="9e8c" class="mn kz in me b gy ms mp l mq mr">import org.aopalliance.intercept.MethodInvocation;<br/>import org.apache.commons.logging.Log;<br/>import org.springframework.aop.interceptor.PerformanceMonitorInterceptor;<br/></span><span id="4640" class="mn kz in me b gy ms mp l mq mr">public class ControllerMonitoringInterceptor extends PerformanceMonitorInterceptor<br/>{<br/>    protected void writeToLog(Log logger, String message, Throwable ex)<br/>    {<br/>        if (ex != null)<br/>        {<br/>            logger.info(message, ex);<br/>        }<br/>        else<br/>        {<br/>            logger.info(message);<br/>        }<br/>    }</span><span id="5fa3" class="mn kz in me b gy ms mp l mq mr">    protected boolean isInterceptorEnabled(MethodInvocation invocation, Log logger)<br/>    {<br/>        return true;<br/>    }<br/>}</span></pre><p id="5c40" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们将为<code class="fe mb mc md me b">ControllerMonitoringInterceptor</code>创建一个bean。这个bean将是我们的日志配置的一部分，它也将评估控制器类的<code class="fe mb mc md me b">AspectJExpression</code>。因此，它将如下所示:</p><pre class="mf mg mh mi gt mj me mk ml aw mm bi"><span id="b52b" class="mn kz in me b gy mo mp l mq mr">package com.abccompany.home.performance;</span><span id="0845" class="mn kz in me b gy ms mp l mq mr">import org.aspectj.lang.annotation.Aspect;<br/>import org.aspectj.lang.annotation.Pointcut;<br/>import org.springframework.aop.Advisor;<br/>import org.springframework.aop.aspectj.AspectJExpressionPointcut;<br/>import org.springframework.aop.interceptor.PerformanceMonitorInterceptor;<br/>import org.springframework.aop.support.DefaultPointcutAdvisor;<br/>import org.springframework.context.annotation.Bean;<br/>import org.springframework.context.annotation.Configuration;<br/>import org.springframework.context.annotation.EnableAspectJAutoProxy;</span><span id="0b4e" class="mn kz in me b gy ms mp l mq mr">@Configuration<br/>@EnableAspectJAutoProxy<br/>@Aspect<br/>public class ControllerLoggerConfig<br/>{<br/>    @Pointcut("execution(* com.abccompany.home.controllers.*Controller+.*(..))")<br/>    public void monitor()<br/>    {</span><span id="c086" class="mn kz in me b gy ms mp l mq mr">    }</span><span id="f1b0" class="mn kz in me b gy ms mp l mq mr">    @Bean<br/>    public ControllerMonitoringInterceptor controllerMonitoringInterceptor()<br/>    {<br/>        return new ControllerMonitoringInterceptor();<br/>    }</span><span id="1234" class="mn kz in me b gy ms mp l mq mr">    @Bean<br/>    public Advisor advisorPerformance()<br/>    {<br/>        AspectJExpressionPointcut aspectJExpressionPointcut = new AspectJExpressionPointcut();<br/>        aspectJExpressionPointcut.setExpression("com.abccompany.home.performance" +<br/>                ".ControllerLoggerConfig.monitor()");<br/>        return new DefaultPointcutAdvisor(aspectJExpressionPointcut,<br/>                controllerMonitoringInterceptor());<br/>    }<br/>}</span></pre><p id="8abb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，如果我们执行应用程序，日志消息将显示控制器类的延迟。</p><pre class="mf mg mh mi gt mj me mk ml aw mm bi"><span id="7484" class="mn kz in me b gy mo mp l mq mr">2020-05-24 20:12:09.237  INFO 9280 --- [nio-8443-exec-6] c.r.h.p.ControllerMonitoringInterceptor  : StopWatch 'com.abccompany.home.controllers.LoginController.signin': running time (millis) = 0<br/>2020-05-24 20:12:18.263  INFO 9280 --- [nio-8443-exec-2] c.r.h.p.ControllerMonitoringInterceptor  : StopWatch 'com.abccompany.home.controllers.MainController.home': running time (millis) = 43<br/>2020-05-24 20:12:20.025  INFO 9280 --- [nio-8443-exec-9] c.r.h.p.ControllerMonitoringInterceptor  : StopWatch 'com.abccompany.home.controllers.MainController.logout': running time (millis) = 12<br/>2020-05-24 20:12:20.042  INFO 9280 --- [nio-8443-exec-5] c.r.h.p.ControllerMonitoringInterceptor  : StopWatch 'com.abccompany.home.controllers.LoginController.login': running time (millis) = 0</span></pre><h1 id="a6b9" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">如何使用CommonsRequestLoggingFilter</h1><p id="53e1" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">此外，Spring Boot还提供了一个记录传入请求的有用特性。这有助于监控应用程序并了解请求是如何发出的。为了使用这个特性，我们将创建一个<code class="fe mb mc md me b">@Configuration</code>类RequestLoggingFilter，如下所示:</p><pre class="mf mg mh mi gt mj me mk ml aw mm bi"><span id="b608" class="mn kz in me b gy mo mp l mq mr">package com.abccompany.home.performance;<br/></span><span id="205a" class="mn kz in me b gy ms mp l mq mr">import org.springframework.context.annotation.Bean;<br/>import org.springframework.context.annotation.Configuration;<br/>import org.springframework.web.filter.AbstractRequestLoggingFilter;<br/>import org.springframework.web.filter.CommonsRequestLoggingFilter;</span><span id="7c52" class="mn kz in me b gy ms mp l mq mr">import javax.servlet.http.HttpServletRequest;</span><span id="4c05" class="mn kz in me b gy ms mp l mq mr">@Configuration<br/>public class RequestLoggingFilter extends AbstractRequestLoggingFilter<br/>{<br/>    @Bean<br/>    public CommonsRequestLoggingFilter requestLoggingFilterConfig()<br/>    {<br/>        CommonsRequestLoggingFilter commonsRequestLoggingFilter = new CommonsRequestLoggingFilter();<br/>        commonsRequestLoggingFilter.setIncludeClientInfo(true);<br/>        commonsRequestLoggingFilter.setIncludeQueryString(true);<br/>        commonsRequestLoggingFilter.setIncludePayload(true);<br/>        return commonsRequestLoggingFilter;<br/>    }</span><span id="0836" class="mn kz in me b gy ms mp l mq mr">    @Override<br/>    protected void beforeRequest (HttpServletRequest request, String message)<br/>    {<br/>        logger.info(message);<br/>    }</span><span id="7476" class="mn kz in me b gy ms mp l mq mr">    @Override<br/>    protected void afterRequest (HttpServletRequest request, String message)<br/>    {<br/>        logger.info(message);<br/>    }<br/>}</span></pre><p id="bd27" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一旦我们添加了这个，我们将在日志中看到如下的<code class="fe mb mc md me b">beforeRequest</code>和<code class="fe mb mc md me b">afterRequest</code>消息:</p><pre class="mf mg mh mi gt mj me mk ml aw mm bi"><span id="0ce9" class="mn kz in me b gy mo mp l mq mr">2020-05-24 21:07:15.161  INFO 11984 --- [nio-8443-exec-1] gFilter$$EnhancerBySpringCGLIB$$cb4fdaab : Before request [uri=/css/bootstrap.min.css]<br/>2020-05-24 21:07:15.171  INFO 11984 --- [nio-8443-exec-2] gFilter$$EnhancerBySpringCGLIB$$cb4fdaab : Before request [uri=/js/jquery.min.js]<br/>2020-05-24 21:07:15.203  INFO 11984 --- [nio-8443-exec-7] gFilter$$EnhancerBySpringCGLIB$$cb4fdaab : Before request [uri=/js/bootstrap.min.js]<br/>2020-05-24 21:07:15.290  INFO 11984 --- [nio-8443-exec-7] gFilter$$EnhancerBySpringCGLIB$$cb4fdaab : After request [uri=/js/bootstrap.min.js]<br/>2020-05-24 21:07:15.306  INFO 11984 --- [nio-8443-exec-2] gFilter$$EnhancerBySpringCGLIB$$cb4fdaab : After request [uri=/js/jquery.min.js]<br/>2020-05-24 21:07:15.318  INFO 11984 --- [nio-8443-exec-1] gFilter$$EnhancerBySpringCGLIB$$cb4fdaab : After request [uri=/css/bootstrap.min.css]</span></pre><h1 id="6780" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">结论</h1><p id="6dfe" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">总之，我展示了三个特性<strong class="kc io">customizabletrace interceptor</strong>、<strong class="kc io">performance monitor interceptor</strong>和<strong class="kc io">CommonsRequestLoggingFilter</strong>来记录有用的性能指标。</p><p id="d426" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果你喜欢这篇文章，请在你的博客上分享。如果您有任何问题，也可以通过twitter上的@betterjavacode联系我。原文章发表在我的博客<a class="ae jz" href="https://betterjavacode.com/2020/05/25/performance-monitoring-with-spring-boot/" rel="noopener ugc nofollow" target="_blank">https://betterjavacode . com/2020/05/25/performance-monitoring-with-spring-boot/</a></p><h1 id="ee79" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">参考</h1><ol class=""><li id="bd4d" class="mt mu in kc b kd lw kh lx kl mv kp mw kt mx kx my mz na nb bi translated"><a class="ae jz" href="https://mdeinum.wordpress.com/2015/07/01/spring-framework-hidden-gems/" rel="noopener ugc nofollow" target="_blank">弹簧框架特征</a></li><li id="78d8" class="mt mu in kc b kd nc kh nd kl ne kp nf kt ng kx my mz na nb bi translated"><a class="ae jz" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/filter/CommonsRequestLoggingFilter.html" rel="noopener ugc nofollow" target="_blank">CommonsRequestLoggingFilter</a></li></ol></div></div>    
</body>
</html>