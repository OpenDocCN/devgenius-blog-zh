<html>
<head>
<title>Best of Modern JavaScript — Promises</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">最佳现代JavaScript——承诺</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/best-of-modern-javascript-promises-b85eb7698b66?source=collection_archive---------3-----------------------#2020-11-11">https://blog.devgenius.io/best-of-modern-javascript-promises-b85eb7698b66?source=collection_archive---------3-----------------------#2020-11-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/92a2789c9502e4e07b7a4dfa4f86814b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Xsvqwpp-exSZ4iQO"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@sharonmccutcheon?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">莎伦·麦卡琴</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="28e8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">自2015年以来，JavaScript有了巨大的进步。</p><p id="c894" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在用起来比以前舒服多了。</p><p id="193a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究JavaScript承诺。</p><h1 id="1d3d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">承诺的好处</h1><p id="351e" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">承诺是连锁的。</p><p id="e927" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们看起来类似于同步代码。</p><p id="7254" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="f1dd" class="mn lc iq mj b gy mo mp l mq mr">asyncFunction(arg)<br/>  .then(result1 =&gt; {<br/>    console.log(result1);<br/>    return asyncFunction2(x, y);<br/>  })<br/>  .then(result2 =&gt; {<br/>    console.log(result2);<br/>  });</span></pre><p id="9963" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们在<code class="fe ms mt mu mj b">then</code>回调中返回一个承诺，让我们再次调用<code class="fe ms mt mu mj b">then</code>。</p><p id="d98c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">链接也很简单，因为我们只需要打电话给<code class="fe ms mt mu mj b">then</code>，直到我们完成了我们想要的承诺。</p><p id="b4dc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">编写异步调用更容易，因为我们可以做链接。</p><p id="fe98" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">可以使用<code class="fe ms mt mu mj b">catch</code>方法进行错误处理。</p><p id="b775" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="13de" class="mn lc iq mj b gy mo mp l mq mr">asyncFunction(arg)<br/>  .then(result1 =&gt; {<br/>    console.log(result1);<br/>    return asyncFunction2(x, y);<br/>  })<br/>  .then(result2 =&gt; {<br/>    console.log(result2);<br/>  })<br/>  .catch(error =&gt; {<br/>    console.log(error);<br/>  })</span></pre><p id="cf74" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">catch</code>方法接受一个带有<code class="fe ms mt mu mj b">error</code>参数的回调。</p><p id="7d54" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们可以在回调的时候做任何我们想做的事情。</p><p id="0a65" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">函数签名很清楚，我们可以很容易地看到参数。</p><p id="4264" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Promises也是编写异步代码的标准方式。</p><p id="563e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在promises作为原生特性引入ES6之前，有许多库实现了同样的功能。</p><p id="a2c1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但现在，ES6使承诺成为标准，所以我们可以在任何地方使用它。</p><h1 id="e337" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">创造承诺</h1><p id="a533" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">为了创建一个承诺，我们可以使用<code class="fe ms mt mu mj b">Promise</code>构造函数。</p><p id="bba7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="e7d5" class="mn lc iq mj b gy mo mp l mq mr">new Promise((resolve, reject) =&gt; {<br/>  setTimeout(() =&gt; resolve('DONE'), 100);<br/>});</span></pre><p id="ce02" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们使用带有带参数<code class="fe ms mt mu mj b">resolve</code>和<code class="fe ms mt mu mj b">reject</code>的函数的构造函数。</p><p id="6c62" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">resolve</code>是一个函数，当它成功时被调用来返回值。</p><p id="c428" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">reject</code>是一个被调用来返回承诺失败原因的函数。</p><p id="c271" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">承诺是价值的容器和事件的发射器。</p><p id="ef80" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Promises看起来像同步代码，但它们是非阻塞的。</p><p id="3297" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">他们不能同步返回任何东西。</p><p id="d78b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">ES6为我们引入了一种用生成器挂起和恢复代码的方法。</p><p id="f677" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，这被用作JavaScript中承诺和异步函数的基础。</p><p id="daba" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:"</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="cb2c" class="mn lc iq mj b gy mo mp l mq mr">async function main() {<br/>  const x = await asyncFunc();<br/>  console.log(x);<br/>  //...<br/>}<br/>main();</span></pre><p id="714c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">asyncFunc</code>函数调用后返回一个承诺并运行控制台日志。</p><p id="d274" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">await</code>就像JavaScript生成器函数中的<code class="fe ms mt mu mj b">yield</code>。</p><p id="c9ec" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它做同样的事情。它暂停代码，然后在检索结果时继续运行。</p><h1 id="bcba" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">利用承诺</h1><p id="0f2f" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">承诺有三种状态。</p><p id="4b8a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们可以是待定、已实现或已拒绝。</p><p id="23fd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">待定意味着结果还没有计算出来。</p><p id="928f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">已实现表示结果计算成功。</p><p id="d2de" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">拒绝表示计算过程中出现故障。</p><p id="100e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们传递给<code class="fe ms mt mu mj b">Promise</code>构造函数的参数称为执行器。</p><p id="e1f2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">除了调用<code class="fe ms mt mu mj b">reject</code>使一个承诺失败，我们还可以用异常拒绝一个承诺。</p><h1 id="c4a6" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">履行诺言</h1><p id="d491" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">为了消费一个承诺，我们可以调用<code class="fe ms mt mu mj b">then</code>来从一个承诺中获得解决的结果。</p><p id="301f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们传递给<code class="fe ms mt mu mj b">then</code>的回调接受一个承诺的解析结果。</p><p id="1a1a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">catch</code>接受一个回调，该回调接受我们传递给<code class="fe ms mt mu mj b">reject</code>的参数。</p><p id="cfc3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="724c" class="mn lc iq mj b gy mo mp l mq mr">promise<br/>  .then(value =&gt; {<br/>    //...<br/>  })<br/>  .catch(error =&gt; {<br/>    //...<br/>  });</span></pre><p id="d611" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">value</code>具有<code class="fe ms mt mu mj b">promise</code>的解析值。</p><p id="a088" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">error</code>具有被拒绝的值。</p><p id="e993" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">then</code>也可以带2个参数。</p><p id="811b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一个是已解决的回调，第二个参数是被拒绝的回调。</p><p id="998e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们也可以通过写来捕捉错误:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="8cdb" class="mn lc iq mj b gy mo mp l mq mr">promise.then(<br/>  null,<br/>  error =&gt; {<br/>    //...<br/>  });</span></pre><p id="72fe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第二个参数与<code class="fe ms mt mu mj b">catch</code>回调相同，捕捉<code class="fe ms mt mu mj b">promise</code>的错误。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/8469d95c3b9f32a688160e38444a3381.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*l18Q2XX3xWWGF21s"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@timmossholder?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">蒂姆·莫斯霍尔德</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="e1d0" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="1d89" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">承诺有很多好处，我们可以用标准的方式创造和消费它们。</p></div></div>    
</body>
</html>