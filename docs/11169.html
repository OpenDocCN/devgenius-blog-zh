<html>
<head>
<title>Decorators in Typescript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">打字稿中的装饰者</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/decorators-in-typescript-8cdabbf4bd9d?source=collection_archive---------4-----------------------#2022-12-22">https://blog.devgenius.io/decorators-in-typescript-8cdabbf4bd9d?source=collection_archive---------4-----------------------#2022-12-22</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/ae3860fdfc57163553fe76bc6ca5e7d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*aMXJ0TJN4rDhPHOk"/></div></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk translated">在<a class="ae ja" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae ja" href="https://unsplash.com/@spacejoy?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Spacejoy </a>拍摄的照片</figcaption></figure><div class=""/><p id="86be" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">装饰器类似于 JAVA 中的注释或 C#中的属性。它们为类、属性或函数提供定义。装饰器是 ECMAScript 7 的一部分。装饰器有助于在现有定义中注入额外的功能，而无需重写或复制现有代码。</p><p id="d580" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">要使用 decorator，我们需要将 tsconfig.json.  中的<strong class="kc je"> <em class="ky">【实验解码器】设为 true，否则，在编译 typescript TSC&lt;filename . ts&gt;时，我们将被提示以下编译时错误</em></strong></p><blockquote class="kz la lb"><p id="9d90" class="ka kb ky kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated">错误 TS1219:对 decorators 的实验性支持是一项在未来版本中可能会发生变化的功能。请在“tsconfig”或“jsconfig”中设置“experimentalDecorators”选项以删除此警告。</p></blockquote><p id="7a62" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我在使用 Nest js 开发微服务时遇到了这一点，理解它们变得非常重要，因为它在 Nest js 生态系统中被广泛使用。例如 Nest js 中的@UseGuards 就是一个方法修饰器的例子。</p><p id="6259" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Decorators 可以被视为带有输入参数的简单函数，在运行时提供类、属性或函数的定义。注意@ <decorator>的用法。</decorator></p><p id="052c" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">装饰器是在定义阶段调用的，而不是在实例创建阶段。为了更好地理解，让我们看看这个例子</p><pre class="lf lg lh li gt lj lk ll bn lm ln bi"><span id="1ca0" class="lo lp jd lk b be lq lr l ls lt">function simpleDecorator(target:Function)<br/>{<br/>   console.log("I am from simple decorator");<br/>}<br/><br/>@simpleDecorator<br/>export class ClassType<br/>{<br/>  constructor()<br/>  {<br/>    console.log("I am from ctor");<br/>  }<br/>}<br/>let instance = new ClassType();</span></pre><pre class="lu lj lk ll bn lm ln bi"><span id="24f6" class="lo lp jd lk b be lq lr l ls lt">output: <br/>I am from simple decorator<br/>I am from ctor        </span></pre><p id="b48e" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">“我来自 simple decorator”在“我来自 ctor”之前打印在控制台中。我们可以看到，decorator 是在实例创建之前调用的。事实上，如果我们创建了多个 classType 实例，我们将会看到 decorators 在定义 classType 时只被调用一次。</p><p id="ef12" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">好的，但是为什么我们把 decorator 作为一个函数，而不是上面例子中的另一个类型呢？这是因为 TS 中的类基本上是 Javascript 中的一个函数。如果我们没有将类型作为函数，而是将它作为字符串类型，那么我们将得到一个错误“类型' type ClassType '的参数不可赋给类型' string '的参数。”</p><p id="38a3" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们可以将多个 decorators 应用到一个类、属性或函数中吗？是的。</p><p id="1180" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果我们必须将参数传递给装饰者呢？为此，我们必须使用装饰工厂。装饰工厂返回一个装饰函数</p><pre class="lf lg lh li gt lj lk ll bn lm ln bi"><span id="c4e5" class="lo lp jd lk b be lq lr l ls lt">//Decorator factory return a decoratory function <br/>function decoratorFactory(paramters: any[])<br/>{<br/>  return function(ctor:Function)<br/>  {<br/>  console.log(`Data passed onto decorator:${paramters}`);<br/>  }<br/>}<br/><br/>@decoratorFactory(["param 1", "param 2", "param n"])<br/>export class TargetClass{<br/>}</span></pre><p id="47db" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc je"> <em class="ky">装修工类型</em> </strong></p><ol class=""><li id="e65a" class="lv lw jd kc b kd ke kh ki kl lx kp ly kt lz kx ma mb mc md bi translated">班级装修工。</li><li id="91d0" class="lv lw jd kc b kd me kh mf kl mg kp mh kt mi kx ma mb mc md bi translated">方法装饰者。</li><li id="1589" class="lv lw jd kc b kd me kh mf kl mg kp mh kt mi kx ma mb mc md bi translated">房产装修工。</li><li id="1952" class="lv lw jd kc b kd me kh mf kl mg kp mh kt mi kx ma mb mc md bi translated">参数装饰器。</li></ol><p id="13cf" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc je"> <em class="ky">类装饰者</em> </strong></p><p id="f2f3" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">到目前为止，我们看到的所有上面的例子都是关于类装饰者的。使用类级装饰器，我们可以通过原型注入属性</p><pre class="lf lg lh li gt lj lk ll bn lm ln bi"><span id="4c0e" class="lo lp jd lk b be lq lr l ls lt">function Component(targetClass:Function)<br/>{<br/>  //Injecting porperty via decorator.<br/>  targetClass.prototype.FrmDecoraator = "prototype property set by decorator";<br/>  console.log(targetClass.name);<br/><br/>  //Accessing the name property of the target class Function.<br/>  console.log((&lt;any&gt;targetClass).StaticProperty); <br/>}<br/><br/>//class decorator<br/>@Component<br/>export class TargetClass<br/>{ <br/>  static StaticProperty:string ="static property";<br/>  constructor()<br/>  {<br/>    console.log("I am from ctor");<br/>  }<br/><br/>}<br/>let instanceOfTargetClass= new TargetClass();<br/>//Injected prototype from decorator function into TargetClass<br/>console.log((&lt;any&gt;instanceOfTargetClass).FrmDecoraator); </span></pre><p id="1357" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc je"> <em class="ky">物业装修工:</em> </strong></p><p id="5331" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">属性装饰器应用于类中的属性。它是一个接受类的原型和属性键作为输入参数的函数。例如，在下面的例子中，我们可以访问静态属性值，但是不能访问实例属性值，因为 decorators 是在实例创建之前创建的。</p><pre class="lf lg lh li gt lj lk ll bn lm ln bi"><span id="65ad" class="lo lp jd lk b be lq lr l ls lt">function propetryDecorators(target:any,propertyKey:string)<br/>{<br/>    console.log(target.constructor.name);<br/>    console.log(`property Key name :${propertyKey}`);<br/>    /*Property value is undefined for non staic property<br/>     as it is not yet initialized, but we can access the value of static property here. */<br/>    console.log(`property value :${target[propertyKey]}`);<br/>}<br/><br/>export class propetryDecoratorExample<br/>{<br/> @propetryDecorators<br/>  name:string  = "property inside class"<br/><br/>  @propetryDecorators<br/>  static staticProperty:string ="Static property";<br/>}<br/>let instance = new propetryDecoratorExample();</span></pre><p id="0baf" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc je"> <em class="ky">法装饰者:</em> </strong></p><p id="3bfc" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">顾名思义，这些装饰器应用于类中的方法。方法装饰器是带有三个参数的函数(类原型、方法名和关于方法的可选参数描述符)。例如 Nest 中的 AuthGaurd()就是一个方法修饰器的例子。AuthGaurd 在方法调用之前首先被触发。</p><p id="44bb" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc je"> <em class="ky">参数装饰器</em> </strong></p><p id="bd0d" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">修饰方法的参数。例如:嵌套 js 路径中的<a class="ae ja" href="https://hashnode.com/@Body" rel="noopener ugc nofollow" target="_blank"> @Body </a>()、<a class="ae ja" href="https://hashnode.com/@Param" rel="noopener ugc nofollow" target="_blank"> @Param </a>()都是参数修饰类型。参数装饰器可以用来检查参数是否是方法的一部分。要进一步探究参数，比如说参数的类型，我们需要安装一个第三方工具 NPM install reflect-metadata—save-dev，并在 tsconfig.json 文件中启用“emideoratormetadata”:true。</p><pre class="lf lg lh li gt lj lk ll bn lm ln bi"><span id="e7fb" class="lo lp jd lk b be lq lr l ls lt">import 'reflect-metadata';<br/><br/>function paramDecorator(target:any,methodName:string, parameterIndex:number)<br/>{<br/>console.log(`target: ${target.constructor.name}`);<br/>console.log(`methodName : ${methodName}`);<br/>console.log(`parameterIndex : ${parameterIndex}`);<br/>//using reflection to probe more on the parameter.<br/>let designType = Reflect.getMetadata(<br/>    "design:type", target, methodName);<br/>    console.log(`designType: ${designType}`);<br/>    let designParamTypes = Reflect.getMetadata(<br/>    "design:paramtypes", target, methodName);<br/>    console.log(`paramtypes : ${designParamTypes}`);<br/>    if(designParamTypes !== String)<br/>    {<br/>       console.log("not string");<br/>    }<br/>}<br/>class ClassType<br/>{<br/> Method(@paramDecorator param:number ,   nonParameterDecorator:string)<br/> {}<br/>}</span></pre><pre class="lu lj lk mj mk aw ml bi"><span id="87ae" class="mm lp jd lk b gy mn mo l mp lt">After enabling the “emitDecoratorMetadata”: true, Generated .js file will have info about the __decorate __metadata.</span></pre><pre class="lu lj lk ll bn lm ln bi"><span id="4435" class="lo lp jd lk b be lq lr l ls lt">__decorate([<br/>    __param(0, paramDecorator),<br/>    __metadata("design:type", Function),<br/>    __metadata("design:paramtypes", [Number, String]),<br/>    __metadata("design:returntype", void 0)<br/>], ClassType.prototype, "Method", null);</span></pre><p id="88bc" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ky">进一步阅读本主题的参考资料</em></p><p id="a3bc" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">由 Nathan Rozentals 先生编写的 Packt Mastering Type script 第二版</p><p id="c9d4" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><a class="ae ja" href="https://docs.nestjs.com/custom-decorators" rel="noopener ugc nofollow" target="_blank">https://docs.nestjs.com/custom-decorators</a></p><p id="422c" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><a class="ae ja" href="https://javascript.plainenglish.io/master-the-typescript-keyof-type-operator-bf7f18865a8b" rel="noopener ugc nofollow" target="_blank">https://JavaScript . plain English . io/master-the-typescript-key of-type-operator-bf7f 18865 a8b</a></p><p id="86ff" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">感谢您的阅读。直到我们再次见面，我祝你一切顺利:)</p></div></div>    
</body>
</html>