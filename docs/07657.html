<html>
<head>
<title>Understand Node.JS Event Loop in 5 minutes (or less…)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解节点。JS 事件循环在 5 分钟内(或更短时间内…)</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/understand-node-js-event-loop-in-5-minutes-or-less-f76b2b0115f1?source=collection_archive---------5-----------------------#2022-04-13">https://blog.devgenius.io/understand-node-js-event-loop-in-5-minutes-or-less-f76b2b0115f1?source=collection_archive---------5-----------------------#2022-04-13</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="437a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">大家都知道 Node。JS 应用程序是一个单线程的应用程序，这意味着你在任何时候都只能执行一个“命令”。<br/>那么<strong class="jm io">怎么可能</strong>使用一个<strong class="jm io">单线程</strong>还能提供如此高的性能呢？</p><p id="c380" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们试着从一个不同的角度，一个简单得多的角度，来弄清楚 HTTP 服务器是如何工作的，以及它们是如何参与的，直到发明了点<strong class="jm io">事件循环</strong>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/44a5da711a1e64e863fdf78d1c415bb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1344/format:webp/1*SNu8b0NKs9cBB9JsvNXKcA.png"/></div></figure></div><div class="ab cl kq kr hr ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="ig ih ii ij ik"><blockquote class="kx ky kz"><p id="a3ab" class="jk jl la jm b jn jo jp jq jr js jt ju lb jw jx jy lc ka kb kc ld ke kf kg kh ig bi translated">一个<strong class="jm io"> HTTP 服务器</strong>是一个<a class="ae le" href="https://en.wikipedia.org/wiki/Computer" rel="noopener ugc nofollow" target="_blank">计算机</a> ( <a class="ae le" href="https://en.wikipedia.org/wiki/Software" rel="noopener ugc nofollow" target="_blank">软件</a> ) <a class="ae le" href="https://en.wikipedia.org/wiki/Computer_program" rel="noopener ugc nofollow" target="_blank">程序</a>(甚至是一个<a class="ae le" href="https://en.wikipedia.org/wiki/Software_component" rel="noopener ugc nofollow" target="_blank">软件组件</a>包含在另一个程序中)，它通过实现<a class="ae le" href="https://en.wikipedia.org/wiki/HTTP" rel="noopener ugc nofollow" target="_blank"> HTTP </a>和/或<a class="ae le" href="https://en.wikipedia.org/wiki/HTTPS" rel="noopener ugc nofollow" target="_blank">HTTPS</a><a class="ae le" href="https://en.wikipedia.org/wiki/HTTPS" rel="noopener ugc nofollow" target="_blank">的<em class="in">服务器部分</em>，在</a><a class="ae le" href="https://en.wikipedia.org/wiki/Client%E2%80%93server_model" rel="noopener ugc nofollow" target="_blank">客户机-服务器模型</a>中扮演<a class="ae le" href="https://en.wikipedia.org/wiki/Server_(computing)" rel="noopener ugc nofollow" target="_blank">服务器</a>的角色</p><p id="fcf8" class="jk jl la jm b jn jo jp jq jr js jt ju lb jw jx jy lc ka kb kc ld ke kf kg kh ig bi translated">HTTP 服务器等待传入的客户端请求(由<a class="ae le" href="https://en.wikipedia.org/wiki/User_agent" rel="noopener ugc nofollow" target="_blank">用户代理</a>发送，如<a class="ae le" href="https://en.wikipedia.org/wiki/Web_browser" rel="noopener ugc nofollow" target="_blank">浏览器</a>、<a class="ae le" href="https://en.wikipedia.org/wiki/Web_crawler" rel="noopener ugc nofollow" target="_blank">网络爬虫</a>等)。)并且对于每一个请求，它通过回复所请求的信息来回答，包括发送所请求的<a class="ae le" href="https://en.wikipedia.org/wiki/Web_resource" rel="noopener ugc nofollow" target="_blank"> web 资源</a>，或者回复<a class="ae le" href="https://en.wikipedia.org/wiki/List_of_HTTP_status_codes" rel="noopener ugc nofollow" target="_blank"> HTTP 错误消息</a>。</p></blockquote><h1 id="41f6" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">基本 HTTP 服务器:</h1><p id="0a8b" class="pw-post-body-paragraph jk jl in jm b jn md jp jq jr me jt ju jv mf jx jy jz mg kb kc kd mh kf kg kh ig bi translated">考虑下面一个 HTTP 服务器的简单实现，它是一个没有事件循环的<em class="la">单线程</em> <strong class="jm io">。</strong></p><pre class="kj kk kl km gt mi mj mk ml aw mm bi"><span id="9352" class="mn lg in mj b gy mo mp l mq mr">while(true){<br/>   socket_connection = listen to the next TCP connection<br/>   http_request =      read from socket<br/>   web_page =          read from Disk<br/>   ...<br/>                       set response_headers<br/>                       stream the response to client<br/>                       close the socket connection<br/>}</span></pre><p id="44c9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这种方法的问题是，我们要等到<strong class="jm io">每个</strong>变量赋值都<strong class="jm io">完成</strong>后，才能移动到下一个变量，所以如果<strong class="jm io">需要一段时间</strong>来读取 HTTP 请求或从磁盘获取 web_page，主线程就会<strong class="jm io">被卡住</strong>。</p><h1 id="99b4" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">高级 HTTP 服务器:</h1><p id="5db1" class="pw-post-body-paragraph jk jl in jm b jn md jp jq jr me jt ju jv mf jx jy jz mg kb kc kd mh kf kg kh ig bi translated">同上，但是现在我们为每个 HTTP 请求生成一个新线程。</p><pre class="kj kk kl km gt mi mj mk ml aw mm bi"><span id="4587" class="mn lg in mj b gy mo mp l mq mr">function process_request(socket){<br/>     socket_connection = listen to the next TCP connection<br/>     http_request =      read from socket<br/>     web_page =          read from Disk<br/>     ...<br/>                         set response_headers<br/>                         stream the response to client<br/>                         close the socket connection<br/>}</span><span id="af8e" class="mn lg in mj b gy ms mp l mq mr">while(true){<br/>   socket_connection =   listen to the next TCP connection<br/>   spawn a new background thread using 'process_request' logic<br/>}</span></pre><p id="aa26" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">那么，你觉得这个解决方案怎么样？听起来不错，对吧？让我们试着理解我们在这里有什么。由于这种编程模式，主线程可以自由地处理任何新的请求，我们的客户端可以快速获得 http 响应。</p><blockquote class="kx ky kz"><p id="4dce" class="jk jl la jm b jn jo jp jq jr js jt ju lb jw jx jy lc ka kb kc ld ke kf kg kh ig bi translated">大多数网络服务器都是这样工作的(IIS、Apache 等)</p></blockquote><p id="5083" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是现在让我们来评价这个解决方案，如果它远非完美，它只有一个缺点，那就是一个大缺点。<br/>因为我们产生了如此多的线程，对于有大量连接的工作负载，每个连接只需要偶尔关注一次，所以这种多线程模式的性能不会很好。<br/>那么我们能做什么呢？让我们使用事件循环！</p><h1 id="d8ca" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">事件驱动与轮询<strong class="ak">编程</strong></h1><blockquote class="kx ky kz"><p id="8529" class="jk jl la jm b jn jo jp jq jr js jt ju lb jw jx jy lc ka kb kc ld ke kf kg kh ig bi translated"><strong class="jm io">事件驱动编程</strong>是一种编程范式，其中程序的<a class="ae le" href="https://en.wikipedia.org/wiki/Control_flow" rel="noopener ugc nofollow" target="_blank">流程由</a><a class="ae le" href="https://en.wikipedia.org/wiki/Event_(computing)" rel="noopener ugc nofollow" target="_blank">事件</a>决定，例如用户动作(<a class="ae le" href="https://en.wikipedia.org/wiki/Computer_mouse" rel="noopener ugc nofollow" target="_blank">鼠标</a>点击、按键)<a class="ae le" href="https://en.wikipedia.org/wiki/Sensor" rel="noopener ugc nofollow" target="_blank">传感器</a>输出，或者来自其他程序或<a class="ae le" href="https://en.wikipedia.org/wiki/Thread_(computer_science)" rel="noopener ugc nofollow" target="_blank">线程</a>的<a class="ae le" href="https://en.wikipedia.org/wiki/Message_passing" rel="noopener ugc nofollow" target="_blank">消息传递</a>。事件驱动编程是在<a class="ae le" href="https://en.wikipedia.org/wiki/Graphical_user_interface" rel="noopener ugc nofollow" target="_blank">图形用户界面</a>和其他应用程序(例如，JavaScript <a class="ae le" href="https://en.wikipedia.org/wiki/Web_application" rel="noopener ugc nofollow" target="_blank"> web 应用程序</a>)中使用的主要范例，这些应用程序集中于响应<a class="ae le" href="https://en.wikipedia.org/wiki/Input/output" rel="noopener ugc nofollow" target="_blank">用户输入</a>而执行某些动作。对于<a class="ae le" href="https://en.wikipedia.org/wiki/Device_driver" rel="noopener ugc nofollow" target="_blank">设备驱动</a>的编程也是如此(例如 USB 设备驱动栈<a class="ae le" href="https://en.wikipedia.org/wiki/Event-driven_programming#cite_note-1" rel="noopener ugc nofollow" target="_blank">【1】</a>中的<a class="ae le" href="https://en.wikipedia.org/wiki/P_(programming_language)" rel="noopener ugc nofollow" target="_blank"> P </a>)。</p><p id="03a0" class="jk jl la jm b jn jo jp jq jr js jt ju lb jw jx jy lc ka kb kc ld ke kf kg kh ig bi translated">在事件驱动的应用中，通常有一个<a class="ae le" href="https://en.wikipedia.org/wiki/Event_loop" rel="noopener ugc nofollow" target="_blank">主循环</a>监听事件，然后在检测到其中一个事件时触发一个<a class="ae le" href="https://en.wikipedia.org/wiki/Callback_(computer_programming)" rel="noopener ugc nofollow" target="_blank">回调函数</a>。事件驱动的程序可以用任何一种<a class="ae le" href="https://en.wikipedia.org/wiki/Programming_language" rel="noopener ugc nofollow" target="_blank">编程语言</a>编写，尽管在提供<a class="ae le" href="https://en.wikipedia.org/wiki/Abstraction_(computer_science)" rel="noopener ugc nofollow" target="_blank">高级抽象</a>的语言中任务更容易，比如<a class="ae le" href="https://en.wikipedia.org/wiki/Async/await" rel="noopener ugc nofollow" target="_blank">等待</a>和<a class="ae le" href="https://en.wikipedia.org/wiki/Closure_(computer_programming)" rel="noopener ugc nofollow" target="_blank">关闭</a>。</p><p id="cce2" class="jk jl la jm b jn jo jp jq jr js jt ju lb jw jx jy lc ka kb kc ld ke kf kg kh ig bi translated"><strong class="jm io">轮询编程</strong>是一种编程范例，其中程序的<a class="ae le" href="https://en.wikipedia.org/wiki/Control_flow" rel="noopener ugc nofollow" target="_blank">流程通过不断检查变量赋值的准备状态或状态来确定。<strong class="jm io"> <br/>轮询，或轮询操作</strong>，在计算机科学中，指的是客户端程序主动采样外部设备的状态，作为一个<strong class="jm io">同步</strong>活动<br/>这样想:你的代码<strong class="jm io">等待</strong>一个同步代码块(网络请求、从磁盘获取文件等……)，以检查其就绪或状态。</a></p></blockquote><pre class="kj kk kl km gt mi mj mk ml aw mm bi"><span id="9417" class="mn lg in mj b gy mo mp l mq mr">while(true){<br/>   sync_operation = //some <strong class="mj io">synchronous</strong> activity<br/>   if(sync_operation)<br/>     ...</span></pre><blockquote class="kx ky kz"><p id="a40c" class="jk jl la jm b jn jo jp jq jr js jt ju lb jw jx jy lc ka kb kc ld ke kf kg kh ig bi translated">例如，想象一个代码块，它有一个 while(true)循环，就像上面的例子一样，我们不断地检查一个动作(sync_operation)的状态，看它是否完成。</p></blockquote><h1 id="2d16" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">事件比投票好吗？</h1><p id="4f17" class="pw-post-body-paragraph jk jl in jm b jn md jp jq jr me jt ju jv mf jx jy jz mg kb kc kd mh kf kg kh ig bi translated">一般来说，轮询架构比事件驱动架构更容易实现。然而，尽管复杂，LabVIEW 中的事件驱动程序，加上状态机架构，提供了更好的性能。</p><h1 id="d8b1" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">处理输入的轮询和基于事件的模型之间有什么区别？</h1><p id="ad4e" class="pw-post-body-paragraph jk jl in jm b jn md jp jq jr me jt ju jv mf jx jy jz mg kb kc kd mh kf kg kh ig bi translated">在事件驱动的情况下，当用户在某物上点击鼠标或键入一个键时，一个方法被调用来处理事件。在轮询驱动的情况下，为了响应用户操作，程序员将 if 语句放入一个更新方法中，该方法在每一帧被调用以轮询输入。</p><h1 id="0b0f" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">事件驱动和轮询架构的主要区别是什么？</h1><p id="70d0" class="pw-post-body-paragraph jk jl in jm b jn md jp jq jr me jt ju jv mf jx jy jz mg kb kc kd mh kf kg kh ig bi translated">中断驱动代码和事件驱动代码都在运行代码之前等待事件，而轮询将试图查询事件是否实际存在。</p><h1 id="1268" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">基于事件循环的 HTTP 服务器:</h1><pre class="kj kk kl km gt mi mj mk ml aw mm bi"><span id="5262" class="mn lg in mj b gy mo mp l mq mr">while(true){<br/>   event = listen to the next event to happen<br/>   switch(event){</span><span id="2ff8" class="mn lg in mj b gy ms mp l mq mr">       case NEW_TCP_CONNECTION:<br/>           //handle new connection</span><span id="6637" class="mn lg in mj b gy ms mp l mq mr">       case FINISHED_READING_FROM_SOCKET:<br/>           //start fetching web_page content from disk</span><span id="b5bf" class="mn lg in mj b gy ms mp l mq mr">       case FINISHED_READING_FROM_DISK:<br/>           //start streaming the web_page</span><span id="2533" class="mn lg in mj b gy ms mp l mq mr">       case FINISHED_WRITING_TO_SOCKET:<br/>           //close the socket connection</span><span id="7274" class="mn lg in mj b gy ms mp l mq mr">   }</span><span id="d412" class="mn lg in mj b gy ms mp l mq mr">}</span></pre><p id="2eda" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">希望我的伪代码是可理解的。事情是这样的:我们等待事情发生。每当一个新的连接被创建或者一个现有的连接需要我们注意时，我们就去处理它，然后回去等待。这样，当有许多联系，而每一个都很少需要注意时，我们表现得很好。</p><h1 id="de59" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">示例:我们的浏览器事件循环看起来怎么样？</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/86fc1b998f7f5edff67a497cd617500c.png" data-original-src="https://miro.medium.com/v2/resize:fit:948/format:webp/1*GvyvfT2rtkM3z_fE-pCHng.png"/></div></figure><pre class="kj kk kl km gt mi mj mk ml aw mm bi"><span id="ca3e" class="mn lg in mj b gy mo mp l mq mr">while(true){<br/>   ui_event = listen to the next ui event to happen<br/>   switch(ui_event){</span><span id="aa13" class="mn lg in mj b gy ms mp l mq mr">   case onclick:<br/>           //handle mouse click on an element</span><span id="14a6" class="mn lg in mj b gy ms mp l mq mr">   case onfocus:<br/>           //handle element gets focus event</span><span id="ab07" class="mn lg in mj b gy ms mp l mq mr">   case onkeypress:<br/>           //handle when user presses a key</span><span id="b50f" class="mn lg in mj b gy ms mp l mq mr">   case onload:<br/>           //handle when page has been loaded</span><span id="8ac3" class="mn lg in mj b gy ms mp l mq mr">}</span></pre><h1 id="9ef0" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">奖金:节点。JS 事件循环的操作顺序。</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/675244471df653849082428d881d6e34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1006/format:webp/1*hhN8mb6Vk5q-7w9zN2eS1g.png"/></div></figure><h1 id="afff" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">阶段概述</h1><ul class=""><li id="9ca4" class="mv mw in jm b jn md jr me jv mx jz my kd mz kh na nb nc nd bi translated"><strong class="jm io">定时器</strong>:该阶段执行<code class="fe ne nf ng mj b">setTimeout()</code>和<code class="fe ne nf ng mj b">setInterval()</code>安排的回调。</li><li id="288c" class="mv mw in jm b jn nh jr ni jv nj jz nk kd nl kh na nb nc nd bi translated"><strong class="jm io">待定回调</strong>:执行推迟到下一次循环迭代的 I/O 回调。</li><li id="6e3c" class="mv mw in jm b jn nh jr ni jv nj jz nk kd nl kh na nb nc nd bi translated"><strong class="jm io">闲置</strong>、<strong class="jm io">准备</strong>:仅供内部使用。</li><li id="0f8a" class="mv mw in jm b jn nh jr ni jv nj jz nk kd nl kh na nb nc nd bi translated"><strong class="jm io">轮询</strong>:检索新的 I/O 事件；执行与 I/O 相关的回调(除了关闭回调、计时器调度的回调和<code class="fe ne nf ng mj b">setImmediate()</code>之外的几乎所有回调)；节点将在适当的时候阻塞这里。</li><li id="bbcd" class="mv mw in jm b jn nh jr ni jv nj jz nk kd nl kh na nb nc nd bi translated"><strong class="jm io">检查</strong> : <code class="fe ne nf ng mj b">setImmediate()</code>这里调用了回调。</li><li id="e1a7" class="mv mw in jm b jn nh jr ni jv nj jz nk kd nl kh na nb nc nd bi translated"><strong class="jm io">关闭回调</strong>:一些关闭回调，如<code class="fe ne nf ng mj b">socket.on('close', ...)</code>。</li></ul></div><div class="ab cl kq kr hr ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="ig ih ii ij ik"><h1 id="791f" class="lf lg in bd lh li nm lk ll lm nn lo lp lq no ls lt lu np lw lx ly nq ma mb mc bi translated">事件循环按以下顺序执行:</h1><ul class=""><li id="fe72" class="mv mw in jm b jn md jr me jv mx jz my kd mz kh na nb nc nd bi translated">JS 引擎中有两个任务队列:宏任务队列和微任务队列</li><li id="5e48" class="mv mw in jm b jn nh jr ni jv nj jz nk kd nl kh na nb nc nd bi translated">整个脚本最初作为宏任务执行</li><li id="25ee" class="mv mw in jm b jn nh jr ni jv nj jz nk kd nl kh na nb nc nd bi translated">执行过程中，同步代码直接执行，宏任务进入宏任务队列，微任务进入微任务队列</li><li id="6ffc" class="mv mw in jm b jn nh jr ni jv nj jz nk kd nl kh na nb nc nd bi translated">当当前宏任务完成时，检查微任务队列，并依次执行所有的微任务</li><li id="ef12" class="mv mw in jm b jn nh jr ni jv nj jz nk kd nl kh na nb nc nd bi translated">执行浏览器 UI 线程的呈现(在本文中可以忽略这一点)</li><li id="6444" class="mv mw in jm b jn nh jr ni jv nj jz nk kd nl kh na nb nc nd bi translated">如果存在任何 Web Worker 任务，就执行它(在本文中可以忽略这一点)</li><li id="e804" class="mv mw in jm b jn nh jr ni jv nj jz nk kd nl kh na nb nc nd bi translated">检查宏任务队列，如果它不为空，返回到步骤 2 并执行下一个宏任务。</li></ul><p id="bf77" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">值得注意的是，第四步:当一个宏任务完成后，先依次执行其他所有的微任务，然后执行下一个宏任务。</p><p id="19e7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">微任务包括:<code class="fe ne nf ng mj b">MutationObserver</code>、<code class="fe ne nf ng mj b">Promise.then()</code>和<code class="fe ne nf ng mj b">Promise.catch()</code>，其他基于 Promise 的技术如 fetch API、V8 垃圾收集过程、节点环境中的<code class="fe ne nf ng mj b">process.nextTick()</code>。</p><p id="7399" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">宏任务包括:初始脚本、<code class="fe ne nf ng mj b">setTimeout</code>、<code class="fe ne nf ng mj b">setInterval</code>、<code class="fe ne nf ng mj b">setImmediate</code>、I/O、UI 渲染。</p><h1 id="0085" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">包裹</h1><p id="5164" class="pw-post-body-paragraph jk jl in jm b jn md jp jq jr me jt ju jv mf jx jy jz mg kb kc kd mh kf kg kh ig bi translated">感谢阅读这篇文章，如果你有所收获，不要忘记鼓掌！</p><p id="2b23" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你对这篇文章有任何问题或者有什么改进的想法，请不要犹豫，尽管来找我。</p><p id="f0d4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">谢谢你。</p><h1 id="aaac" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">伊兰·佩莱德写的《✍️》👨🏻‍💻 🤓 🏋️‍🏸 🚀 🚲<a class="ae le" href="https://emojipedia.org/guitar/" rel="noopener ugc nofollow" target="_blank">🎸</a></h1><p id="50f0" class="pw-post-body-paragraph jk jl in jm b jn md jp jq jr me jt ju jv mf jx jy jz mg kb kc kd mh kf kg kh ig bi translated">https://www.linkedin.com/in/eran-peled/<a class="ae le" href="https://www.linkedin.com/in/eran-peled/" rel="noopener ugc nofollow" target="_blank"/></p></div></div>    
</body>
</html>