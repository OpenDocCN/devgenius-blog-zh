<html>
<head>
<title>Introduction to Java Programming</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java编程简介</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/introduction-to-java-programming-e8b9e217228d?source=collection_archive---------12-----------------------#2020-06-26">https://blog.devgenius.io/introduction-to-java-programming-e8b9e217228d?source=collection_archive---------12-----------------------#2020-06-26</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div class="gh gi jk"><img src="../Images/1ea74069817ebf4441f246c6f303984d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/0*Su4jq_GM5ICsU_wV"/></div></figure><p id="b483" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">本博客向您简要介绍了Java编程语言。</p><p id="eef9" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">如果你没有Java的先验知识，那你就来对地方了。如果你是一个有经验的java开发人员，这个博客将作为你的复习工具。</p><p id="f00d" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">所以让我们开始吧！</p></div><div class="ab cl kp kq hr kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="ig ih ii ij ik"><h1 id="ac2e" class="kw kx in bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">什么是Java编程语言？</h1><p id="0443" class="pw-post-body-paragraph jr js in jt b ju lu jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ly km kn ko ig bi translated"><strong class="jt io"> <em class="lz"> Java </em> </strong>编程语言是一种基于类和面向对象的高级语言。但是，它支持原始数据类型int、char、double和float。因此，它不被认为是一种纯粹的面向对象编程语言。Java有一个独特的功能，让应用程序开发人员<strong class="jt io">编写一次，在任何地方运行</strong> (WORA)，这意味着编译后的Java代码可以在所有支持Java的平台上运行，而无需重新编译。</p></div><div class="ab cl kp kq hr kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="ig ih ii ij ik"><h1 id="8d27" class="kw kx in bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">Java魔力——JVM！</h1><figure class="mb mc md me gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi ma"><img src="../Images/a18d50ae34036570819ea47704053142.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fh7hJ-dzqblSSamb"/></div></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk translated">JVM内部结构</figcaption></figure><p id="08d5" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io"> <em class="lz"> Java虚拟机(JVM) </em> </strong>是提供运行时环境来驱动Java代码或应用程序的引擎。它将Java字节码转换成机器语言。JVM是Java运行环境(JRE)的一部分。JVM被称为Java魔术，因为它允许WORA特性。</p><p id="a53b" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">在Java编程语言中，所有的源代码首先都是用以<strong class="jt io"> <em class="lz">结尾的纯文本文件编写的。java </em> </strong>扩展。那些源文件然后被编译成<strong class="jt io"> <em class="lz">。类</em> </strong>文件由java编译器-javac生成。一个<strong class="jt io"> <em class="lz">。</em> </strong>类文件不包含处理器本地的代码；相反，它包含字节码JVM的机器语言。然后，java启动器工具用一个JVM实例运行应用程序。</p><p id="9c36" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">因为JVM可以在许多不同的操作系统上使用，同样的<strong class="jt io"> <em class="lz">。class </em> </strong>文件能够在Microsoft Windows、Solaris OS、Linux或Mac OS上运行。</p></div><div class="ab cl kp kq hr kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="ig ih ii ij ik"><h1 id="11ab" class="kw kx in bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">Java运行时环境</h1><figure class="mb mc md me gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi mn"><img src="../Images/8eb83bd785b5722f0bed63fea9abf056.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Yn4XQsUkkKiC-5WW.jpg"/></div></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk translated">JRE内部结构</figcaption></figure><p id="297a" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io"> <em class="lz"> Java运行时环境(JRE) </em> </strong>也可以写成<strong class="jt io"> Java RTE，</strong>提供了执行Java应用的最低要求；它由Java虚拟机(JVM)、核心类和支持文件(Util、Lang、Math等)组成。</p></div><div class="ab cl kp kq hr kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="ig ih ii ij ik"><h1 id="bc7c" class="kw kx in bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">Java开发工具包(JDK)</h1><figure class="mb mc md me gt jo gh gi paragraph-image"><div class="gh gi jk"><img src="../Images/2c2b745173f164de06029e2a4cfd4da8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/0*grDrmkKFYzDbhriX"/></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk translated">JDK内部结构</figcaption></figure><p id="86db" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io"> <em class="lz"> Java开发套件(JDK) </em> </strong>是用于开发Java应用和小程序的软件开发环境。它包括Java运行时环境(JRE)和开发工具，如解释器/加载器(Java)、编译器(javac)、归档器(jar)等。</p></div><div class="ab cl kp kq hr kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="ig ih ii ij ik"><h1 id="fb2a" class="kw kx in bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">Java包</h1><figure class="mb mc md me gt jo gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/6fd3566241611552270202ea31d7e0f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1118/format:webp/0*sJsbRi38MgfRzIJu.png"/></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk translated">Java包</figcaption></figure><p id="02d0" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io"><em class="lz">Java中的包</em> </strong>是封装一组类、子包、接口的机制。</p><p id="2ab7" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">java中的包可以分为两种形式，内置包和用户自定义包。</p><p id="d2dc" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">有很多内置的包比如java，lang，awt，javax，swing，net，util，sql等等。</p></div><div class="ab cl kp kq hr kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="ig ih ii ij ik"><h1 id="5bb7" class="kw kx in bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">Java中的自动内存管理</h1><p id="9b13" class="pw-post-body-paragraph jr js in jt b ju lu jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ly km kn ko ig bi translated">Java使用一个自动的<strong class="jt io"> <em class="lz">垃圾收集器</em></strong><em class="lz"/><strong class="jt io"><em class="lz">【GC】</em></strong>来管理对象生命周期中的内存。程序员决定何时创建对象，一旦不再使用对象，Java运行时负责回收内存。一旦没有对对象的引用，不可到达的内存就有资格被垃圾收集器自动释放。</p><p id="99a0" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">Java的自动内存管理模型背后的一个想法是，程序员可以免除必须执行手动内存管理的负担。但是垃圾收集不能防止逻辑内存泄漏，即内存仍然被引用但从未被使用的情况。</p><figure class="mb mc md me gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi mp"><img src="../Images/951a13e1be60b7c637326ba1e0bd40f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*RRmMkQmWfZQnEQ6H.jpg"/></div></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk translated">垃圾收集者</figcaption></figure><p id="0de2" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">垃圾收集可能随时发生。理想情况下，它会在程序空闲时发生。如果堆上没有足够的空闲内存来分配一个新的对象，它肯定会被触发；这可能会导致程序暂时停止。在Java中，显式内存管理是不可能的。</p></div><div class="ab cl kp kq hr kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="ig ih ii ij ik"><h1 id="3a07" class="kw kx in bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">Java中的异常处理</h1><p id="d2ae" class="pw-post-body-paragraph jr js in jt b ju lu jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ly km kn ko ig bi translated"><strong class="jt io"> <em class="lz">异常处理</em></strong><em class="lz"/>Java中的异常处理是处理运行时错误的强大机制之一，以便维持应用的正常流程。异常处理是指处理运行时错误的机制，如ClassNotFoundException、IOException、SQLException、RemoteException等。</p><figure class="mb mc md me gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi mq"><img src="../Images/416d7410bbe00ae9fffb0fdeb247135f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*4xJYEnYvfNb9ebT1.png"/></div></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk translated">Java中的异常处理</figcaption></figure><h2 id="a1d8" class="mr kx in bd ky ms mt dn lc mu mv dp lg kc mw mx lk kg my mz lo kk na nb ls nc bi translated">Java异常的类型</h2><p id="432c" class="pw-post-body-paragraph jr js in jt b ju lu jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ly km kn ko ig bi translated">异常主要有两种类型:<strong class="jt io"> <em class="lz">选中</em> </strong>和<strong class="jt io"> <em class="lz">未选中</em> </strong>。这里，一个<strong class="jt io"> <em class="lz">错误</em> </strong>被认为是未检查的异常。根据Oracle的规定，有三种例外情况:</p><ol class=""><li id="eb51" class="nd ne in jt b ju jv jy jz kc nf kg ng kk nh ko ni nj nk nl bi translated">检查异常</li><li id="f6c3" class="nd ne in jt b ju nm jy nn kc no kg np kk nq ko ni nj nk nl bi translated">未检查的异常</li><li id="0255" class="nd ne in jt b ju nm jy nn kc no kg np kk nq ko ni nj nk nl bi translated">错误</li></ol></div><div class="ab cl kp kq hr kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="ig ih ii ij ik"><h1 id="cd8e" class="kw kx in bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">抽象类和接口</h1><h2 id="49ec" class="mr kx in bd ky ms mt dn lc mu mv dp lg kc mw mx lk kg my mz lo kk na nb ls nc bi translated">抽象类</h2><p id="7995" class="pw-post-body-paragraph jr js in jt b ju lu jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ly km kn ko ig bi translated">一个<strong class="jt io"> <em class="lz">抽象类</em> </strong>是一个声明为<code class="fe nr ns nt nu b">abstract</code>的类——它可能包含也可能不包含抽象方法。一个<strong class="jt io"> <em class="lz">抽象方法</em> </strong>是一个没有实现声明的方法(没有大括号，后面跟一个分号)，就像这样:</p><pre class="mb mc md me gt nv nu nw nx aw ny bi"><span id="0268" class="mr kx in nu b gy nz oa l ob oc">abstract void moveTo(double deltaX, double deltaY);</span></pre><p id="86e8" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">抽象类不能实例化，但可以子类化。</p><h2 id="8bdf" class="mr kx in bd ky ms mt dn lc mu mv dp lg kc mw mx lk kg my mz lo kk na nb ls nc bi translated">连接</h2><p id="baa5" class="pw-post-body-paragraph jr js in jt b ju lu jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ly km kn ko ig bi translated">Java中的一个<strong class="jt io"> <em class="lz">接口</em> </strong>就是一个类的蓝图。它有静态常数和抽象方法。该接口没有实现代码，所有方法都是抽象的，即所有方法都是声明的，没有定义任何方法。接口是一种在Java中实现抽象和多重继承的机制。Java接口也<strong class="jt io">代表了IS-A关系</strong>。它不能像抽象类一样被实例化。</p></div><div class="ab cl kp kq hr kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="ig ih ii ij ik"><h1 id="3fac" class="kw kx in bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">Java集合框架</h1><p id="1c1e" class="pw-post-body-paragraph jr js in jt b ju lu jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ly km kn ko ig bi translated">Java中的<strong class="jt io"> <em class="lz">集合</em> </strong>是一个框架，提供了存储和操作对象组的架构。Java集合可以实现您对数据执行的所有操作，比如搜索、排序、插入、操作和删除。</p><p id="8b11" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">Java集合意味着单一的对象单元。集合接口(<strong class="jt io"> java.util.Collection </strong>)和映射接口(<strong class="jt io"> java.util.Map </strong>)是java集合类的两个主要的“根”接口。</p><figure class="mb mc md me gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi od"><img src="../Images/de3a3936f9fd3412e320d111d8f5cfb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Go1k_iTREYDAnOS8"/></div></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk translated">集合框架</figcaption></figure><p id="e7a0" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">Java集合框架提供了很多接口(Set、List、Queue、Deque)和类(ArrayList、Vector、LinkedList、PriorityQueue、HashSet、LinkedHashSet、TreeSet)。</p></div><div class="ab cl kp kq hr kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="ig ih ii ij ik"><h1 id="2100" class="kw kx in bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">OOPS——封装、继承、多态和抽象</h1><figure class="mb mc md me gt jo gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/8e05110260c2cf5a20cf42b3e2578cc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:700/format:webp/1*f_ChiDTWYyESFbFB3VTEug.png"/></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk translated">面向对象编程</figcaption></figure><p id="0950" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io"> <em class="lz">面向对象编程(OOP) </em> </strong>是一种计算机编程模型，它围绕数据，或对象，而不是功能和逻辑来组织软件设计。对象可以定义为具有唯一属性和行为的数据字段。</p><p id="aecd" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">面向对象编程(OOP)是一个编程概念，它关注4个原则——封装(T18)、<strong class="jt io">继承(T21)、多态(T22)</strong>和抽象(T24)</p><h2 id="7776" class="mr kx in bd ky ms mt dn lc mu mv dp lg kc mw mx lk kg my mz lo kk na nb ls nc bi translated">1.包装</h2><p id="810f" class="pw-post-body-paragraph jr js in jt b ju lu jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ly km kn ko ig bi translated"><strong class="jt io"> <em class="lz">封装</em> </strong>是将数据(变量)和功能(方法)包装在一起作为一个单一的单元。功能意味着“方法”，数据意味着“变量”。这一切都包在“类”里它是一个蓝图或一套指令。</p><p id="5109" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">类:类是定义变量和方法的蓝图或原型。例如:</p><p id="9570" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><em class="lz">类:汽车<br/>数据成员或对象:颜色、类型、型号等。<br/>方法:停车、加速、巡航。</em></p><p id="6916" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">对象:现在，一个对象是一个类的样本。就像上面的例子一样，我的汽车是汽车类的对象。</p><p id="c61c" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io">变量</strong>:可以是局部的、实例的、静态的。局部变量是在方法体内声明的。实例变量在方法外部声明。它们是特定于对象的。<strong class="jt io">静态变量</strong>仅在程序执行开始时初始化一次。静态变量首先被初始化，我们将在后面详细讨论静态。</p><p id="df2d" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io">方法</strong>:方法是各种各样的功能，它只不过是一组代码，通过名字来引用，可以在程序中的任何一点被调用。您可以将多个值传递给一个方法，它会返回一个值。</p><h2 id="2cf8" class="mr kx in bd ky ms mt dn lc mu mv dp lg kc mw mx lk kg my mz lo kk na nb ls nc bi translated">2.抽象</h2><p id="7314" class="pw-post-body-paragraph jr js in jt b ju lu jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ly km kn ko ig bi translated"><strong class="jt io"> <em class="lz">抽象</em> </strong>是从更大的池中选择数据，只显示与对象相关的细节。下面的图表显示了不同的访问修饰符以及它是如何限制一个类中的数据的。</p><figure class="mb mc md me gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi of"><img src="../Images/f68f954527832fc888154f2dfd889439.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*NJNv9EfdgTlBjq3d.png"/></div></div></figure><h2 id="2f46" class="mr kx in bd ky ms mt dn lc mu mv dp lg kc mw mx lk kg my mz lo kk na nb ls nc bi translated">3.遗产</h2><p id="5966" class="pw-post-body-paragraph jr js in jt b ju lu jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ly km kn ko ig bi translated"><strong class="jt io"> <em class="lz">继承</em> </strong>是一个类获取另一个类的属性的机制。例如，一个孩子继承了他/她父母的特征。</p><pre class="mb mc md me gt nv nu nw nx aw ny bi"><span id="ecd3" class="mr kx in nu b gy nz oa l ob oc">class Developer{<br/>  public void writeCode(){<br/>  // writeCode method<br/>  <br/>}<br/>class BackendDeveloper extends Developer{<br/>  public void writeCode(){<br/>  // writeCode method<br/>  }<br/>}<br/>Class run{<br/>  public static void main (String args[]){<br/>    Developer developerObject = new Developer()<br/>	// writeCode method in class Developer will be executed<br/>    developerObject.writeCode();<br/>   <br/>    BackendDeveloper backendDeveloperObj = new BackendDeveloper();<br/>    // writeCodemethod in class BackendDeveloper will be executed<br/>    backendDeveloperObj.writeCode();<br/>  }<br/>}</span></pre><h2 id="bb85" class="mr kx in bd ky ms mt dn lc mu mv dp lg kc mw mx lk kg my mz lo kk na nb ls nc bi translated">4.多态性</h2><p id="cac8" class="pw-post-body-paragraph jr js in jt b ju lu jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ly km kn ko ig bi translated">多态性是一个糟糕的概念，一个名字可以有多种形式，也称为重载。动态多态性是一种机制，通过这种机制，可以在超类和子类中用相同的名称和签名定义多个方法，也称为覆盖。</p><ul class=""><li id="df04" class="nd ne in jt b ju jv jy jz kc nf kg ng kk nh ko og nj nk nl bi translated">重载是同一个类中有多个同名但方法签名不同的方法。</li><li id="52ac" class="nd ne in jt b ju nm jy nn kc no kg np kk nq ko og nj nk nl bi translated">重写处理两个方法，一个在父类中，一个在子类中，并且两者具有相同的名称和签名。</li><li id="5969" class="nd ne in jt b ju nm jy nn kc no kg np kk nq ko og nj nk nl bi translated">子类方法覆盖了超类的方法。</li><li id="829a" class="nd ne in jt b ju nm jy nn kc no kg np kk nq ko og nj nk nl bi translated">在覆盖中，子类访问修饰符必须大于父类，例如，如果我们在父类中使用<em class="lz"> public abc() </em>而在子类中使用<em class="lz"> private abc() </em>，将抛出异常。</li></ul></div><div class="ab cl kp kq hr kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="ig ih ii ij ik"><h1 id="e7eb" class="kw kx in bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">Java中的多线程</h1><p id="1e7b" class="pw-post-body-paragraph jr js in jt b ju lu jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ly km kn ko ig bi translated"><strong class="jt io"> <em class="lz">多线程</em> </strong>是Java的一个特性，它允许同时执行一个程序的两个或多个部分，以最大限度地利用CPU。这样一个程序的每个部分被称为一个线程。一个<strong class="jt io"> <em class="lz">线程</em> </strong>是轻量级子进程，最小的处理单位。</p><figure class="mb mc md me gt jo gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/052f685ab9914bc315a4ddebf24400f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1396/0*aOWWVGKHaF39iMQb.gif"/></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk translated">Java中的多线程</figcaption></figure><p id="07c8" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">线程可以通过两种机制创建:<br/> 1 .<strong class="jt io">扩展螺纹类</strong> <br/> 2。<strong class="jt io">实现可运行接口</strong></p></div><div class="ab cl kp kq hr kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="ig ih ii ij ik"><h1 id="715e" class="kw kx in bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">感谢您的阅读！我希望你喜欢它，如果你喜欢，请分享。</h1></div></div>    
</body>
</html>