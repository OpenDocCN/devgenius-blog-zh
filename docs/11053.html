<html>
<head>
<title>Flatten JSON Data in Snowflake</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在雪花中展平 JSON 数据</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/flatten-json-data-in-snowflake-e42fd128d328?source=collection_archive---------1-----------------------#2022-12-15">https://blog.devgenius.io/flatten-json-data-in-snowflake-e42fd128d328?source=collection_archive---------1-----------------------#2022-12-15</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><figure class="gm go jp jq jr js gi gj paragraph-image"><div role="button" tabindex="0" class="jt ju di jv bf jw"><div class="gi gj jo"><img src="../Images/1ecc4ba96b4e57744b45247d547a56f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6lJcqp5NJb51igqZsVXg2w.png"/></div></div><figcaption class="jz ka gk gi gj kb kc bd b be z dk translated">2022 年 12 月 11 日，安大略省皮克林市西顿远足径</figcaption></figure><p id="8baf" class="pw-post-body-paragraph kd ke ir kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ik bi translated">半结构化数据(通常像 JSON 和 XML)可以在 Snowflake 中轻松处理。这里的“容易处理”是指数据中的“名称”和“值”对可以直接通过使用 SQL 语句来检索。snow flat table 函数将用于这样做，尤其是对于“嵌套”半结构。</p><p id="4693" class="pw-post-body-paragraph kd ke ir kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ik bi translated">所以我们有一个 JSON 示例文件“book.json”如下——文件简化自<a class="ae lb" href="https://learn.snowflake.com/courses/course-v1:snowflake+ESS_DWW_101+2021/course/" rel="noopener ugc nofollow" target="_blank">雪花数据仓库工作坊</a>。它在一个 JSON 数组中有两个 book 记录。每本书都有书名、出版年份和作者。第一本书有两个作者包含在一个数组中，而第二本书只有一个作者。</p><p id="3e02" class="pw-post-body-paragraph kd ke ir kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ik bi translated">注意，作者位于嵌套在外部顶级数组中的数组中，因此他们将数据文件称为嵌套 JSON 文件。</p><pre class="lc ld le lf gu lg lh li bn lj lk bi"><span id="71a1" class="ll lm ir lh b be ln lo l lp lq">[{<br/>  "book_title":"Food",<br/>  "year_published":2001,<br/>  "authors": [<br/> {<br/>     "first_name":"Fiona",<br/>     "middle_name":null,<br/>     "last_name":"Macdonald"<br/>   },<br/>  {<br/>     "first_name":"Gian",<br/>     "middle_name":"Paulo",<br/>     "last_name":"Faleschini"<br/>   }<br/> ]<br/> },<br/>{<br/>  "book_title":"Food",<br/>  "year_published":2006,<br/>  "authors": <br/> [{<br/>     "first_name":"Laura",<br/>     "middle_name":"K",<br/>     "last_name":"Egendorf"<br/>   }<br/> ]<br/> }]</span></pre><p id="c323" class="pw-post-body-paragraph kd ke ir kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ik bi translated">我们已经将它保存在笔记本电脑上，所以首先我们可以在雪花中创建一个内部命名阶段，并在笔记本电脑上使用 SnowSQL CLI 工具将文件上传到那里。</p><p id="a4ac" class="pw-post-body-paragraph kd ke ir kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ik bi translated">在雪花中创建内部命名阶段“xml_json_stage”</p><pre class="lc ld le lf gu lg lh li bn lj lk bi"><span id="fbe8" class="ll lm ir lh b be ln lo l lp lq">// Create Snowflake internal named stage<br/>create or replace stage xml_json_stage;<br/>list @xml_json_stage;</span></pre><p id="8cc1" class="pw-post-body-paragraph kd ke ir kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ik bi translated">使用 SnowSQL 将文件“book.json”放入内部命名阶段“xml_json_stage”</p><pre class="lc ld le lf gu lg lh li bn lj lk bi"><span id="914b" class="ll lm ir lh b be ln lo l lp lq">C:\snowflake\badge1&gt;snowsql -a ABC12345.us-east-1 -u fengliplatform<br/>Password:<br/>* SnowSQL * v1.2.24<br/>Type SQL statements or !help<br/>fengliplatform#(no warehouse)@(no database).(no schema)&gt;put file://book.json @feng_database.feng_schema.xml_json_stage;<br/>+-----------+--------------+-------------+-------------+--------------------+--------------------+----------+---------+<br/>| source    | target       | source_size | target_size | source_compression | target_compression | status   | message |<br/>|-----------+--------------+-------------+-------------+--------------------+--------------------+----------+---------|<br/>| book.json | book.json.gz |         440 |         224 | NONE               | GZIP              | UPLOADED |         |<br/>+-----------+--------------+-------------+-------------+--------------------+--------------------+----------+---------+<br/>1 Row(s) produced. Time Elapsed: 1.204s</span></pre><p id="e00e" class="pw-post-body-paragraph kd ke ir kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ik bi translated">回到雪花，在工作表中运行下面的 SQL 来加载 JSON book 数据。</p><pre class="lc ld le lf gu lg lh li bn lj lk bi"><span id="79ee" class="ll lm ir lh b be ln lo l lp lq">// Create table for JSON book data<br/>create or replace table book_json_table <br/>(<br/>  raw_book variant<br/>);<br/><br/>// Create JSON file format telling Snowflake how to understand the data file<br/>create or replace file format json_file_format<br/>    type='json'<br/>    strip_outer_array = true;<br/><br/>// Copy JSON data file to internal named stage<br/>copy into book_json_table<br/>    from @xml_json_stage<br/>    files = ('book.json.gz')<br/>    file_format=(format_name = 'json_file_format');<br/><br/>// See what we have in the table<br/>select * from author_json_table;</span></pre><p id="00c9" class="pw-post-body-paragraph kd ke ir kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ik bi translated">正如所料，Snowflake 使用一个变量列将每个 book 记录作为对象保存——尽管它们不是字符串或文本。</p><figure class="lc ld le lf gu js gi gj paragraph-image"><div role="button" tabindex="0" class="jt ju di jv bf jw"><div class="gi gj lr"><img src="../Images/de972043c3ba1e9d1cedf9f6715fd10e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BTWh-fxvInkQ1GZvwtkVbQ.png"/></div></div><figcaption class="jz ka gk gi gj kb kc bd b be z dk translated">雪花使用一个变量列来保存每个图书记录</figcaption></figure><p id="9939" class="pw-post-body-paragraph kd ke ir kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ik bi translated">我们如何检索有用的书名、出版年份和作者信息，并更好地组织它们以供进一步分析？</p><p id="0ea3" class="pw-post-body-paragraph kd ke ir kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ik bi translated">我们可以在“select”中使用“raw_book:book_title”、“raw_book:year_published”来获取书名和出版年份。我们可以使用“raw_book:authors”来获得 authors 数组，甚至可以使用“raw_book:authors[0]”。first_name "来获取第一作者的名字…但是对于“[0]”或“[1]”，您必须指定它不可编程。</p><p id="5403" class="pw-post-body-paragraph kd ke ir kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ik bi translated">所以对于 JSON 文件中的嵌套数据，我们将使用雪花展平函数。Flatten 函数检索数组中的每个元素，并将它们变成一行。所以它返回一个包含这些行的“表”结果。</p><p id="1a89" class="pw-post-body-paragraph kd ke ir kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ik bi translated">“表格”结果中有哪些列？它们是 SEQ、键、路径、索引、THIS 和值。如果我们对嵌套数组“raw_book:authors”运行 flatten 函数，我们将看到…</p><pre class="lc ld le lf gu lg lh li bn lj lk bi"><span id="d568" class="ll lm ir lh b be ln lo l lp lq">SELECT * FROM book_json_table, LATERAL FLATTEN(input =&gt; raw_book:authors);</span></pre><figure class="lc ld le lf gu js gi gj paragraph-image"><div role="button" tabindex="0" class="jt ju di jv bf jw"><div class="gi gj ls"><img src="../Images/1ca55778e22ad5dee0d3a586e7dec07e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_QItvHU02KZq2Rpj1n_z5g.png"/></div></div><figcaption class="jz ka gk gi gj kb kc bd b be z dk translated">flatten 函数返回嵌套数据元素“raw_book:authors”</figcaption></figure><p id="b966" class="pw-post-body-paragraph kd ke ir kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ik bi translated">现在，我们只关心“值”列，这是另一个“变量”数据，我们可以使用正常的“:”来检索信息，如“值:名字”。</p><p id="e0e1" class="pw-post-body-paragraph kd ke ir kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ik bi translated">让我们运行另一个 SQL，如下所示</p><pre class="lc ld le lf gu lg lh li bn lj lk bi"><span id="dce5" class="ll lm ir lh b be ln lo l lp lq">SELECT raw_book:book_title::VARCHAR AS TITLE, <br/>       raw_book:year_published::VARCHAR AS YEAR_PUBLISHED, <br/>     value:first_name::VARCHAR AS FIRST_NM, <br/>     value:last_name::VARCHAR AS LAST_NM<br/>FROM book_json_table<br/>,LATERAL FLATTEN(input =&gt; raw_book:authors);</span></pre><figure class="lc ld le lf gu js gi gj paragraph-image"><div class="gi gj lt"><img src="../Images/3a5a8d2c1e405993e25574e39467cc65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1130/format:webp/1*I8mKpIdp81W1vvFM1qdSPw.png"/></div><figcaption class="jz ka gk gi gj kb kc bd b be z dk translated">从关系的角度看图书信息</figcaption></figure><p id="d82d" class="pw-post-body-paragraph kd ke ir kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ik bi translated">你可能已经注意到，第一本书的标题和出版年份在作者的每一行都是重复的。这是展平功能所期望的。</p><p id="3c1b" class="pw-post-body-paragraph kd ke ir kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ik bi translated">最后，我们将创建一个雪花视图来进一步分析数据。对于半结构化数据，这是在表的顶部创建视图的最佳实践。</p><pre class="lc ld le lf gu lg lh li bn lj lk bi"><span id="c931" class="ll lm ir lh b be ln lo l lp lq">create or replace view book_view as<br/>  SELECT raw_book:book_title::VARCHAR AS TITLE, <br/>         raw_book:year_published::VARCHAR AS YEAR_PUBLISHED, <br/>     value:first_name::VARCHAR AS FIRST_NM, <br/>     value:last_name::VARCHAR AS LAST_NM<br/>  FROM book_json_table<br/>  ,LATERAL FLATTEN(input =&gt; raw_book:authors);</span></pre><p id="5ea4" class="pw-post-body-paragraph kd ke ir kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ik bi translated">快乐阅读！</p><div class="lu lv gq gs lw lx"><a href="https://medium.com/@fengliplatform/membership" rel="noopener follow" target="_blank"><div class="ly ab fp"><div class="lz ab ma cl cj mb"><h2 class="bd is gz z fq mc fs ft md fv fx iq bi translated">通过我的推荐链接-李冯加入媒体</h2><div class="me l"><h3 class="bd b gz z fq mc fs ft md fv fx dk translated">写作帮助我们自己，分享帮助很多人。从我自己的学习笔记开始，没有要求完美的压力…</h3></div><div class="mf l"><p class="bd b dl z fq mc fs ft md fv fx dk translated">medium.com</p></div></div><div class="mg l"><div class="mh l mi mj mk mg ml jx lx"/></div></div></a></div></div></div>    
</body>
</html>