<html>
<head>
<title>Rolling updates &amp; rollbacks in Deployments (Kubernetes)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">部署中的滚动更新和回滚(Kubernetes)</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/rolling-updates-rollbacks-in-deployments-kubernetes-7764c93efb79?source=collection_archive---------6-----------------------#2022-04-14">https://blog.devgenius.io/rolling-updates-rollbacks-in-deployments-kubernetes-7764c93efb79?source=collection_archive---------6-----------------------#2022-04-14</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jm jn jo jp gh gi paragraph-image"><div class="gh gi jl"><img src="../Images/c8b942b96c15a389df623d8db3b0c049.png" data-original-src="https://miro.medium.com/v2/resize:fit:638/format:webp/1*3Ya6R7g73zv_kf7YlyP6hQ.png"/></div><figcaption class="js jt gj gh gi ju jv bd b be z dk translated">演职员表:<a class="ae jw" href="https://congdonglinux.com/" rel="noopener ugc nofollow" target="_blank">https://congdonglinux.com/</a></figcaption></figure><p id="87b2" class="pw-post-body-paragraph jx jy in jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku ig bi translated">部署的重要方面是:升级、部署、回滚。</p><p id="2dcd" class="pw-post-body-paragraph jx jy in jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku ig bi translated"><strong class="jz io">升级</strong>:部署最新主要版本和关闭旧版本的能力。</p><p id="0fe0" class="pw-post-body-paragraph jx jy in jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku ig bi translated"><strong class="jz io">首次展示</strong>:能够在不停机的情况下部署最新的次要版本(bugfix、hotfix、次要特性、增强)。</p><p id="e9f6" class="pw-post-body-paragraph jx jy in jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku ig bi translated">回滚(roll back):在出现问题的情况下，能够恢复到旧的工作版本。</p><blockquote class="kv kw kx"><p id="9b00" class="jx jy ky jz b ka kb kc kd ke kf kg kh kz kj kk kl la kn ko kp lb kr ks kt ku ig bi translated">以下是 K8s 世界里发生的事情:</p></blockquote><ol class=""><li id="d51e" class="lc ld in jz b ka kb ke kf ki le km lf kq lg ku lh li lj lk bi translated">当我们第一次创建部署时，它会创建一个展示。</li><li id="0f60" class="lc ld in jz b ka ll ke lm ki ln km lo kq lp ku lh li lj lk bi translated">新的卷展栏会创建新的修订。</li><li id="a07e" class="lc ld in jz b ka ll ke lm ki ln km lo kq lp ku lh li lj lk bi translated">将来，当触发一个新的部署(同名)时，会创建一个新的部署，并增加版本。</li><li id="4b65" class="lc ld in jz b ka ll ke lm ki ln km lo kq lp ku lh li lj lk bi translated">这有助于我们跟踪所做的更改，并使我们能够回滚到以前的版本部署。</li><li id="982f" class="lc ld in jz b ka ll ke lm ki ln km lo kq lp ku lh li lj lk bi translated">检查首次展示状态:` kubectl 首次展示状态部署<deployment-name>'</deployment-name></li><li id="f0e4" class="lc ld in jz b ka ll ke lm ki ln km lo kq lp ku lh li lj lk bi translated">要检查历史、修订和首次展示的变更原因:` kubectl 首次展示历史部署<deployment name="">`请执行以下操作</deployment></li></ol><blockquote class="kv kw kx"><p id="b215" class="jx jy ky jz b ka kb kc kd ke kf kg kh kz kj kk kl la kn ko kp lb kr ks kt ku ig bi translated"><strong class="jz io">部署策略#1 - &gt;重新创建:</strong></p></blockquote><ol class=""><li id="eeeb" class="lc ld in jz b ka kb ke kf ki le km lf kq lg ku lh li lj lk bi translated">假设您的应用程序有 5 个实例在运行</li><li id="f14d" class="lc ld in jz b ka ll ke lm ki ln km lo kq lp ku lh li lj lk bi translated">部署新版本时，我们可以销毁旧版本的 5 个实例，然后部署新版本的 5 个实例。</li><li id="a7fd" class="lc ld in jz b ka ll ke lm ki ln km lo kq lp ku lh li lj lk bi translated">问题是会有停机时间。</li><li id="db78" class="lc ld in jz b ka ll ke lm ki ln km lo kq lp ku lh li lj lk bi translated">这主要是在重大变更、中断变更或向后兼容不可能时完成的。</li><li id="c1fb" class="lc ld in jz b ka ll ke lm ki ln km lo kq lp ku lh li lj lk bi translated">这不是 K8s 中的默认策略。</li></ol><blockquote class="kv kw kx"><p id="68cf" class="jx jy ky jz b ka kb kc kd ke kf kg kh kz kj kk kl la kn ko kp lb kr ks kt ku ig bi translated"><strong class="jz io">部署策略#2 - &gt;滚动更新:</strong></p></blockquote><ol class=""><li id="955f" class="lc ld in jz b ka kb ke kf ki le km lf kq lg ku lh li lj lk bi translated">在这种策略中，我们不会删除所有已经运行的实例。</li><li id="904b" class="lc ld in jz b ka ll ke lm ki ln km lo kq lp ku lh li lj lk bi translated">我们一次删除一定比例的实例，同时生成相同比例的新版本。</li><li id="2882" class="lc ld in jz b ka ll ke lm ki ln km lo kq lp ku lh li lj lk bi translated">这个升级是 K8s 中的默认策略。</li><li id="ae19" class="lc ld in jz b ka ll ke lm ki ln km lo kq lp ku lh li lj lk bi translated">这没有停机时间。</li></ol><blockquote class="kv kw kx"><p id="ea9e" class="jx jy ky jz b ka kb kc kd ke kf kg kh kz kj kk kl la kn ko kp lb kr ks kt ku ig bi translated">让我们用一个例子来理解:</p></blockquote><ol class=""><li id="d232" class="lc ld in jz b ka kb ke kf ki le km lf kq lg ku lh li lj lk bi translated">假设已经有一个部署运行一个 pod 的 3 个副本，映像为 nginx:1.7.0。</li><li id="52fc" class="lc ld in jz b ka ll ke lm ki ln km lo kq lp ku lh li lj lk bi translated">现在，您希望更改图像的版本。</li><li id="2342" class="lc ld in jz b ka ll ke lm ki ln km lo kq lp ku lh li lj lk bi translated">这可以通过更改部署文件中的映像版本并运行命令来完成:` kubectl apply -f <deployment file="" path="">`来完成</deployment></li><li id="75eb" class="lc ld in jz b ka ll ke lm ki ln km lo kq lp ku lh li lj lk bi translated">以上也可以通过:` ku bectl set image deployment myapp-deployment nginx = nginx . 1 . 7 . 1`。</li><li id="0e80" class="lc ld in jz b ka ll ke lm ki ln km lo kq lp ku lh li lj lk bi translated">请记住，如果我们执行第 4 步，那么集群中的实际文件和部署定义将会不一致</li><li id="338c" class="lc ld in jz b ka ll ke lm ki ln km lo kq lp ku lh li lj lk bi translated">运行命令:` kubectl describe deployment <deployment name="">`查看部署的细节，并注意两种策略的区别。</deployment></li></ol><blockquote class="kv kw kx"><p id="c6fb" class="jx jy ky jz b ka kb kc kd ke kf kg kh kz kj kk kl la kn ko kp lb kr ks kt ku ig bi translated">升级如何在引擎盖下工作:</p></blockquote><ol class=""><li id="3bdd" class="lc ld in jz b ka kb ke kf ki le km lf kq lg ku lh li lj lk bi translated">当一个部署被应用时，它创建一个副本集，并使用部署配置中提到的实例数量旋转 pod。</li><li id="452d" class="lc ld in jz b ka ll ke lm ki ln km lo kq lp ku lh li lj lk bi translated">然后，当使用更改重新应用部署时，它会创建一个新的副本集，并启动部署配置中提到的实例数量的 pod，同时从较旧的副本集中删除 pod。</li><li id="bc50" class="lc ld in jz b ka ll ke lm ki ln km lo kq lp ku lh li lj lk bi translated">但是需要注意的是，旧的副本集仍然存在，如果需要，将用于回滚。</li><li id="b57a" class="lc ld in jz b ka ll ke lm ki ln km lo kq lp ku lh li lj lk bi translated">要回滚部署:` kube CLT rollout undo deployment<deployment name="">`—这也将按照升级时发生的类似顺序运行。</deployment></li><li id="7aef" class="lc ld in jz b ka ll ke lm ki ln km lo kq lp ku lh li lj lk bi translated">回滚后，新的副本集仍然存在。</li><li id="ec00" class="lc ld in jz b ka ll ke lm ki ln km lo kq lp ku lh li lj lk bi translated">请记住，为了查看历史修订的变更原因，我们需要在编辑/应用部署时添加—记录标志(每个部署需要设置一次)</li><li id="e22d" class="lc ld in jz b ka ll ke lm ki ln km lo kq lp ku lh li lj lk bi translated">当我们执行回滚时，发生回滚的修订将从历史记录中删除，并在历史记录中创建一个新条目。</li><li id="bfea" class="lc ld in jz b ka ll ke lm ki ln km lo kq lp ku lh li lj lk bi translated">如果在升级过程中出现任何错误，kubernetes 将主动停止升级，并停止删除以前运行的实例</li></ol></div></div>    
</body>
</html>