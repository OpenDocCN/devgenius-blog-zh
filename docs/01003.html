<html>
<head>
<title>What is JavaScript all about : Closure</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript 到底是什么:闭包</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/what-is-closure-all-about-bc530dafc205?source=collection_archive---------35-----------------------#2020-06-21">https://blog.devgenius.io/what-is-closure-all-about-bc530dafc205?source=collection_archive---------35-----------------------#2020-06-21</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/65ab833661e08be8d4b0f0896d05b93d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5i5s_XL6FKXD5x9V"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">由<a class="ae jz" href="https://unsplash.com/@sakethgaruda?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">萨克斯哥鲁达</a>在<a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><p id="bdb4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当我第一次开始使用 Javascript 时，我并没有真正理解 Javascript 的主要概念。我简单地了解到 Javascript 是一种脚本语言，通过使用它，你可以创建一个动态网站，并对用户在浏览器上发生的任何事件做出反应。</p><p id="4599" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">老实说，有一段时间我在基础知识方面做得非常好。我曾与使用普通 Javascript(和 jQuery)的公司合作，能够毫无问题地创建很酷的动态网站或运行脚本。</p><p id="46f2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当我开始从事一些更复杂和更大的项目时，一切都变了。添加简单的功能开始变得困难和耗时，调查错误变得令人沮丧，构建程序基础设施几乎是不可能的。</p><p id="f76f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">缺乏理解打击了我。我决定学习更多，更好地理解。我阅读了<code class="fe ky kz la lb b"><a class="ae jz" href="https://www.amazon.com/JavaScript-Good-Parts-Douglas-Crockford/dp/0596517742/ref=sr_1_2?crid=29MP0THWDR3B8&amp;dchild=1&amp;keywords=javascript+the+weird+parts&amp;qid=1592709861&amp;sprefix=javascript+the+wei%2Caps%2C243&amp;sr=8-2" rel="noopener ugc nofollow" target="_blank">Javascript: the weird parts.</a></code>然后我开始学习和阅读更多关于 Javascript 中的作用域以及什么是闭包。</p><h2 id="85a7" class="lc ld in bd le lf lg dn lh li lj dp lk kl ll lm ln kp lo lp lq kt lr ls lt lu bi translated">JavaScript 完全是关于范围的</h2><p id="6d38" class="pw-post-body-paragraph ka kb in kc b kd lv kf kg kh lw kj kk kl lx kn ko kp ly kr ks kt lz kv kw kx ig bi translated">JavaScript 中的作用域定义了你可以访问哪些变量。</p><p id="ba4f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">JavaScript 有两个作用域——<strong class="kc io">全局</strong>和<strong class="kc io">局部</strong>。任何在函数外部声明的变量都属于<strong class="kc io">全局范围</strong>，因此可以从代码中的任何地方访问。每个函数都有自己的<strong class="kc io">局部</strong> <strong class="kc io">作用域</strong>，在该函数中声明的任何变量都只能从该函数和任何嵌套函数中访问。</p><p id="0fb1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">每次我们运行脚本(源代码)时，Javascript 引擎都会创建一个全局作用域，从代码中的任何地方都可以访问该作用域，并且每次我们创建函数时，基本上都是创建一个属于新创建函数的局部作用域。</p><figure class="ma mb mc md gt jo"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="be83" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在上面的代码片段中，我们有 3 个不同的范围。<br/> 1。<strong class="kc io">全局作用域</strong> — <em class="mg">可以访问其嵌套作用域(</em> <code class="fe ky kz la lb b"><em class="mg">outerFunc()</em></code> <em class="mg">和</em> <code class="fe ky kz la lb b"><em class="mg">innerFunc()</em></code> <em class="mg">作用域)。</em> <br/> 2。<strong class="kc io">outer func 作用域</strong> — <em class="mg">可以访问其嵌套作用域(</em> <code class="fe ky kz la lb b"><em class="mg">innerFunc()</em></code> <em class="mg">作用域)。</em> <br/> 3。<strong class="kc io">inner func 作用域</strong></p><p id="f3e5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="mg">要阅读更多关于 scope 的内容，请查看我的其他</em> <a class="ae jz" href="https://medium.com/@mayasavir/what-is-scope-all-about-1764642a2c4c" rel="noopener"> <em class="mg">帖子</em> </a></p><h2 id="c247" class="lc ld in bd le lf lg dn lh li lj dp lk kl ll lm ln kp lo lp lq kt lr ls lt lu bi translated">什么是终结？</h2><p id="a9ed" class="pw-post-body-paragraph ka kb in kc b kd lv kf kg kh lw kj kk kl lx kn ko kp ly kr ks kt lz kv kw kx ig bi translated">注意我们在其词法范围内调用<code class="fe ky kz la lb b">innerFunc()</code><em class="mg"/>(<code class="fe ky kz la lb b">outerFunc()</code><em class="mg">s</em>cope<em class="mg">)。</em> <br/>让我们看看如果我们改变它并在其词法范围之外调用<code class="fe ky kz la lb b">innerFunc()</code>会发生什么。<br/> <em class="mg"> *我稍微清理了一下代码，这样我们就可以继续看重要的东西了。</em></p><figure class="ma mb mc md gt jo"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="17fa" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，我们在它的作用域(<code class="fe ky kz la lb b">outerFunc()</code>作用域)之外调用了<code class="fe ky kz la lb b">innerFunc()</code>,但它仍然可以访问声明和创建它的作用域。</p><p id="9b60" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这意味着，<code class="fe ky kz la lb b">innerFunc()</code> <em class="mg">在其词法范围内关闭</em>(捕获、记忆)变量<code class="fe ky kz la lb b">outerF</code>。<br/>换句话说，<code class="fe ky kz la lb b">innerFunc()</code>是一个<em class="mg">闭包</em>，因为它在其词法范围内封闭了变量<code class="fe ky kz la lb b">outerF</code>。</p><blockquote class="mh"><p id="b24b" class="mi mj in bd mk ml mm mn mo mp mq kx dk translated">闭包是一个函数，它从定义它的地方记住变量，不管它以后在哪里执行。</p></blockquote><p id="1c1c" class="pw-post-body-paragraph ka kb in kc b kd mr kf kg kh ms kj kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated"><strong class="kc io">我们来看另一个例子</strong></p><figure class="ma mb mc md gt jo"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="e1c6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这一次，我创建了一个<strong class="kc io"> name </strong>变量和一个<strong class="kc io"> callMe() </strong>函数。正如我们已经知道的，<strong class="kc io"> callMe() </strong>函数在它自己的作用域中创建一个闭包，并记住它可以访问的变量——变量<strong class="kc io"> name </strong>(由于作用域的概念)。</p><p id="667b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">请注意，虽然<strong class="kc io"> callMe() </strong>函数内部的代码在 1500 毫秒后运行，但它仍然可以在脚本运行并完成后访问该变量，因为在创建<strong class="kc io"> callMe() </strong>函数时，它的环境包含了<strong class="kc io"> name </strong>变量。</p><p id="5284" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">那么预期输出是多少呢？<br/> </strong>如果我们将运行这个脚本，我们将看到<strong class="kc io">“Savir”</strong>作为输出。</p><p id="eb35" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">惊讶？</strong> <br/>闭包捕获/记忆变量<strong class="kc io">名称</strong>而不是变量<strong class="kc io">值</strong>。<br/>一旦一个闭包函数<strong class="kc io">被创建</strong>，它就存储了它可以访问的<strong class="kc io">变量</strong>，但是<strong class="kc io">值</strong>将等于该函数被<strong class="kc io">执行时的变量值</strong>。</p><p id="d9fd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">也就是说，一旦脚本运行，它将创建一个值为<strong class="kc io"/><strong class="kc io">【Maya】</strong>的变量，然后调用函数，但该函数将在 1500 毫秒(1.5 秒)后运行。在执行该函数时，<strong class="kc io">名称变量</strong>已经将<strong class="kc io">“Savir”</strong>作为一个值。</p><blockquote class="mh"><p id="397f" class="mi mj in bd mk ml mm mn mo mp mq kx dk translated">闭包捕获/记忆变量<strong class="ak">名称</strong>而不是变量<strong class="ak">值</strong>。</p></blockquote><h2 id="e095" class="lc ld in bd le lf mw dn lh li mx dp lk kl my lm ln kp mz lp lq kt na ls lt lu bi translated">闭包的使用</h2><p id="3adb" class="pw-post-body-paragraph ka kb in kc b kd lv kf kg kh lw kj kk kl lx kn ko kp ly kr ks kt lz kv kw kx ig bi translated">每次创建函数时都会创建闭包。为了使用它，我们在另一个函数内部定义一个函数，并公开它(返回它或将其传递给另一个函数)。</p><p id="37c5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">数据隐私</strong> <br/>闭包通常用于给对象/变量提供数据隐私，在 Javascript 中这是主要的机制。在许多面向对象的语言中，我们可以将函数设置为私有或公共的。Javascript 没有这种能力，但是我们可以通过使用闭包来实现。</p><figure class="ma mb mc md gt jo"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="e5c2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在上面的例子中，<code class="fe ky kz la lb b">increaseSalary() and salary</code>只在<code class="fe ky kz la lb b">employer()</code>函数中可见，从函数返回的内容(<code class="fe ky kz la lb b">setPromotion()</code>和<code class="fe ky kz la lb b">getSalary()</code>)向我们公开(在外部作用域)。</p><p id="3153" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">穿针引线</strong>。<br/>闭包保留已经执行的函数状态的能力，给了我们创建 Currying 的能力。Currying 是函数式编程中的一种流行技术。它有助于局部应用。</p><pre class="ma mb mc md gt nb lb nc nd aw ne bi"><span id="7269" class="lc ld in lb b gy nf ng l nh ni">function add(number){<br/> <br/> return function(anotherNumber){<br/> <br/>   return number + anotherNumber;<br/>  <br/> }<br/>  <br/>}</span><span id="15c9" class="lc ld in lb b gy nj ng l nh ni">let add10 = add(10);<br/>let result = add10(10);<br/>console.log(result); // 20</span></pre><p id="ddaf" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当我们第一次声明<code class="fe ky kz la lb b">let add10 = add(10);</code>时，<code class="fe ky kz la lb b">add10</code>关闭/记忆/捕获我们刚刚传递给它的参数(10)，当我们再次调用<code class="fe ky kz la lb b">add10</code>时，它会将新传递的参数添加到它已经拥有的参数中。</p></div></div>    
</body>
</html>