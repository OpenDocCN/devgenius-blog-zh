<html>
<head>
<title>Secure your BigQuery data pipeline using AEAD functions and Tink</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 AEAD 函数和 Tink 保护您的 BigQuery 数据管道</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/use-bigquery-aead-functions-and-tink-to-secure-your-data-pipeline-f5cc60f9caf5?source=collection_archive---------4-----------------------#2022-12-12">https://blog.devgenius.io/use-bigquery-aead-functions-and-tink-to-secure-your-data-pipeline-f5cc60f9caf5?source=collection_archive---------4-----------------------#2022-12-12</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="af97" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">在应用程序端加密数据，并在查询时按需解密</h2></div><p id="4afc" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><a class="ae ky" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/aead_encryption_functions" rel="noopener ugc nofollow" target="_blank"> BigQuery AEAD(带关联数据的认证加密)函数</a>提供了一种在 BigQuery 中加密和解密列级数据的方法。这允许您加密敏感数据的各个列，同时还允许您查询表中的其余数据。</p><p id="059b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在本文中，您将看到如何在应用程序端加密敏感数据，并在查询时使用<a class="ae ky" href="https://developers.google.com/tink" rel="noopener ugc nofollow" target="_blank"> Tink </a>库、BigQuery AEAD 函数和 Google KMS 在 BigQuery 中解密，从而保护您的数据管道。</p><p id="28e4" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们将使用确定性加密，但是您可以用等效的非确定性函数替换每个函数。</p></div><div class="ab cl kz la hr lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="ig ih ii ij ik"><h1 id="5842" class="lg lh in bd li lj lk ll lm ln lo lp lq jt lr ju ls jw lt jx lu jz lv ka lw lx bi translated">创建数据加密密钥包装</h1><p id="e493" class="pw-post-body-paragraph kc kd in ke b kf ly jo kh ki lz jr kk kl ma kn ko kp mb kr ks kt mc kv kw kx ig bi translated">为了加密您的数据，您首先需要创建一个数据加密密钥(DEK)。您的 DEK 被认为是最高机密，因为如果密钥被透露给未经授权的个人，他们将能够访问您的数据。</p><p id="8f69" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">要为 DEK 添加额外的安全层，您可以使用存储在外部加密服务中的密钥加密密钥(KEK)对其进行加密。谷歌云 KMS(密钥管理服务)支持这种类型的密钥加密，允许您安全地存储和管理您的 KEK。</p><p id="89b0" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">被加密的 DEK 被加密的 KEK 将被称为包装器。包装器不是秘密的，因为没有使用 KEK 的许可，你不能解密它。</p><p id="ff67" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">包装器生成过程将如下所示:</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi md"><img src="../Images/3e993b0b003eb7ff07292fe59e33b46d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*10jUUzT8sZxsmRNt4H8Nfw.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">使用 KMS 创建包装</figcaption></figure><p id="6071" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">总而言之，</p><p id="9e55" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">DEK(数据加密密钥)—是一种用于加密和解密数据的密钥。它是用于实际加密和解密数据本身的密钥，并且是保密和受保护的密钥。</p><p id="940b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">KEK(密钥加密密钥)—是用于加密和解密 DEK 的密钥。它不用于加密和解密数据本身，而是用于保护 DEK，确保只有授权用户才能访问它。</p><p id="3c96" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">包装器—是由 KEK 加密的 DEK。这不是一个秘密，你不需要保护它，因为它只有在你能访问 KEK 的情况下才能被解密。</p><h1 id="c63f" class="lg lh in bd li lj mt ll lm ln mu lp lq jt mv ju ls jw mw jx lu jz mx ka lw lx bi translated">创造一个 KEK</h1><p id="7564" class="pw-post-body-paragraph kc kd in ke b kf ly jo kh ki lz jr kk kl ma kn ko kp mb kr ks kt mc kv kw kx ig bi translated">要使用<a class="ae ky" href="https://cloud.google.com/sdk/gcloud/reference/kms" rel="noopener ugc nofollow" target="_blank">谷歌 KMS </a>中的 KEK 加密你的 DEK，你首先需要创建一个密匙环和密匙环中的一个密钥(这个密钥将是 KEK)。您可以使用 KMS 控制台，或者通过执行以下命令行来实现:</p><pre class="me mf mg mh gt my mz na bn nb nc bi"><span id="bbee" class="nd lh in mz b be ne nf l ng nh">$ gcloud kms keyrings create poc-keyring \<br/>    --location us-central1<br/><br/>$ gcloud kms keys create kek \<br/>    --keyring poc-keyring \<br/>    --location us-central1 \<br/>    --purpose "encryption"</span></pre><p id="2de2" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您应该拥有<a class="ae ky" href="https://cloud.google.com/kms/docs/reference/permissions-and-roles#cloudkms.admin" rel="noopener ugc nofollow" target="_blank">云 KMS 管理员</a>角色才能执行这些命令。</p><p id="c959" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">密钥环是密钥的逻辑容器，而密钥是与特定加密密钥相关联的唯一标识符。</p><p id="a506" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一旦你创建了密匙环和密匙，你就可以使用 KMS API 来生成一个新的 KEK，并用它来加密你的 DEK。这将为您的 DEK 提供额外的安全保护，并帮助防止未经授权的访问。</p><h1 id="d18e" class="lg lh in bd li lj mt ll lm ln mu lp lq jt mv ju ls jw mw jx lu jz mx ka lw lx bi translated">安装 Tinkey</h1><p id="9654" class="pw-post-body-paragraph kc kd in ke b kf ly jo kh ki lz jr kk kl ma kn ko kp mb kr ks kt mc kv kw kx ig bi translated"><a class="ae ky" href="https://developers.google.com/tink" rel="noopener ugc nofollow" target="_blank"> Tink </a>是由谷歌的密码学家和安全工程师编写的开源密码库。它还提供了一个名为<a class="ae ky" href="https://github.com/google/tink/blob/master/docs/TINKEY.md" rel="noopener ugc nofollow" target="_blank"> Tinkey </a>的 CLI 工具，允许生成和操作 Tink 键集。</p><p id="f8b8" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们将使用 Tink 库来加密数据，并用 Tinkey 来生成密钥。</p><p id="6710" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">首先，我们应该安装 Tinkey，如果要使用 brew 安装它，请执行以下命令:</p><pre class="me mf mg mh gt my mz na bn nb nc bi"><span id="9fd7" class="nd lh in mz b be ne nf l ng nh">$ brew tap google/tink https://github.com/google/tink<br/>$ brew install tinkey</span></pre><p id="3481" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">否则，您可以遵循此处的安装说明<a class="ae ky" href="https://github.com/google/tink/blob/master/docs/TINKEY.md#tinkey" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="2801" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Tinkey 需要 Java 8 或更高版本才能运行。</p><h1 id="540e" class="lg lh in bd li lj mt ll lm ln mu lp lq jt mv ju ls jw mw jx lu jz mx ka lw lx bi translated">创建包装的键集(包装器)</h1><p id="34f1" class="pw-post-body-paragraph kc kd in ke b kf ly jo kh ki lz jr kk kl ma kn ko kp mb kr ks kt mc kv kw kx ig bi translated">使用 Tinkey，您可以创建包装器。以下命令将生成一个新的 DEK，并使用谷歌 KMS 对 KEK 进行加密。</p><p id="ff96" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">确保用 KMS 的 KEK uri 更新主密钥 uri。</p><p id="ae47" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您应该将<a class="ae ky" href="https://cloud.google.com/kms/docs/reference/permissions-and-roles#cloudkms.cryptoKeyDecrypterViaDelegation" rel="noopener ugc nofollow" target="_blank"> <em class="ni">云 KMS 密钥加密器</em> </a>角色分配给相关的 KEK，以便执行这些命令。</p><pre class="me mf mg mh gt my mz na bn nb nc bi"><span id="6b86" class="nd lh in mz b be ne nf l ng nh">$  tinkey create-keyset \<br/>--key-template AES256_SIV \<br/>--out-format json \<br/>–out keyset.json \<br/>--master-key-uri<br/>'gcp-kms://projects/aead-poc/locations/us-central1/keyRings/poc-keyring/cryptoKeys/kek’</span></pre><p id="7c9e" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">它将创建一个如下所示的 JSON 文件，包装器是<em class="ni"> encryptedKeyset </em>属性的值:</p><pre class="me mf mg mh gt my mz na bn nb nc bi"><span id="bfeb" class="nd lh in mz b be ne nf l ng nh">{<br/> "encryptedKeyset": "CiQA14LEnuISWuJQKSETKUD1vgBxhLqJd91FO0YxjjWjN3fvC4MStwEA0pJ5OArBrNvseG/EuJ4rcxbFVpOnCHOsnAbcz0ZlaHeOFKiFHovta2sk/jsPf4iHXEHjO1oL2D2v/5oXQNMd1vzCtSAsGL0P1ZQhr7ZIu4ZOCYalviUqupBSQp/B83ddamxctCXV5ZaWPCuSwUNxtRtsz+xRCYc8tYIozADt4PBmVgCn63sG7WzMrkEmo4cfoAI2hzhSt8I7+MM8xHzo1OppIKgMFi3zrWu8fNBOki2brY9fZ3U=",<br/> "keysetInfo": {<br/>   "primaryKeyId": 1996068671,<br/>   "keyInfo": [<br/>     {<br/>       "typeUrl": "type.googleapis.com/google.crypto.tink.AesSivKey",<br/>       "status": "ENABLED",<br/>       "keyId": 1996068671,<br/>       "outputPrefixType": "TINK"<br/>     }<br/>   ]<br/> }<br/>}</span></pre><p id="c4d0" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您还可以使用内置的 BigQuery AEAD 函数、<a class="ae ky" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/aead_encryption_functions#keysnew_wrapped_keyset" rel="noopener ugc nofollow" target="_blank"> KEYS 来生成一个包装器。NEW_WRAPPED_KEYSET </a>。</p></div><div class="ab cl kz la hr lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="ig ih ii ij ik"><h1 id="4128" class="lg lh in bd li lj lk ll lm ln lo lp lq jt lr ju ls jw lt jx lu jz lv ka lw lx bi translated">在应用程序端加密您的数据</h1><p id="8cf0" class="pw-post-body-paragraph kc kd in ke b kf ly jo kh ki lz jr kk kl ma kn ko kp mb kr ks kt mc kv kw kx ig bi translated">现在我们有了包装器，我们终于可以加密我们的数据了。</p><p id="65a7" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们的应用程序应该要求谷歌 KMS 解密包装。为此，它将向 KEK 提供 URI。如果应用程序有正确的许可，谷歌 KMS 将返回 DEK。一旦应用程序在内存中有了 DEK，它就可以使用相关的加密算法来加密/解密数据。</p><p id="f67c" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">注意:数据本身不使用谷歌 KMS 加密/解密，只使用包装器。</strong></p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi nj"><img src="../Images/b34f13a5ab9a3812b814dfd2b7da121e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kzliG8vcupxnrco3mQQJgA.png"/></div></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">使用包装器和谷歌 KMS 的应用程序加密/解密过程</figcaption></figure><h1 id="9c44" class="lg lh in bd li lj mt ll lm ln mu lp lq jt mv ju ls jw mw jx lu jz mx ka lw lx bi translated">让我们看看一些代码</h1><p id="8bb6" class="pw-post-body-paragraph kc kd in ke b kf ly jo kh ki lz jr kk kl ma kn ko kp mb kr ks kt mc kv kw kx ig bi translated">为此我们将使用 Tink 库，我在示例中使用了 python，但它在<a class="ae ky" href="https://developers.google.com/tink/install-tink#java" rel="noopener ugc nofollow" target="_blank"> Java </a>中也受支持。</p><p id="6a6f" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">首先，安装下面的<a class="ae ky" href="https://pypi.org/project/tink/" rel="noopener ugc nofollow" target="_blank"> pip 依赖</a>:</p><pre class="me mf mg mh gt my mz na bn nb nc bi"><span id="24d2" class="nd lh in mz b be ne nf l ng nh">$  pip install tink</span></pre><p id="6e28" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在我们将读取包装器并创建一个密码对象</p><pre class="me mf mg mh gt my mz na bn nb nc bi"><span id="fd88" class="nd lh in mz b be ne nf l ng nh">import tink<br/>from tink import daead<br/>from tink.integration import gcpkms<br/><br/>KEK_URI = ‘gcp-kms://projects/aead-poc/locations/us-central1/keyRings/poc-keyring/cryptoKeys/kek’<br/>KEYSET_WRAPPER_JSON_PATH = './keyset.json'<br/>GCP_CREDENTIAL_PATH = '' # empty string for default or service account json path<br/><br/>with open(keyset_wrapper_json_path, 'rt') as keyset_file:<br/>        keyset_wrapper_json = keyset_file.read()<br/>        daead.register()<br/><br/>        keyset_handle = tink.KeysetHandle.read(<br/>            tink.JsonKeysetReader(KEYSET_WRAPPER_JSON_PATH), gcpkms.GcpKmsClient('', GCP_CREDENTIAL_PATH).get_aead(KEK_URI))<br/>        cipher = keyset_handle.primitive(daead.DeterministicAead)</span></pre><p id="7ed2" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一旦我们有了可以用来加密数据的密码，如果我们愿意，我们也可以用它来解密。</p><pre class="me mf mg mh gt my mz na bn nb nc bi"><span id="2970" class="nd lh in mz b be ne nf l ng nh">import base64<br/>ciphertext = cipher.encrypt_deterministically(b'example_plaintext', b'')<br/>print(base64.b64encode(ciphertext))<br/>print(cipher.decrypt_deterministically(ciphertext, b''))</span></pre><p id="14b5" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">它将打印以下结果:</p><pre class="me mf mg mh gt my mz na bn nb nc bi"><span id="60ec" class="nd lh in mz b be ne nf l ng nh">b'BXKNZ9WWfl0iGwvrmxcRLH9VBQ1wpYo7+MCcho08qxtAyVb7jDz='<br/>b'example_plaintext'</span></pre><p id="1e3b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">万一你得到错误:<br/> ti <em class="ni"> nk.core._tink_error。tinker error:INVALID _ ARGUMENT:GCP KMS 加密失败:空更新<br/> </em>遵循<a class="ae ky" href="https://github.com/google/tink/issues/399#issuecomment-1173914470" rel="noopener ugc nofollow" target="_blank">这些指令</a>以便解决它。</p><h1 id="452f" class="lg lh in bd li lj mt ll lm ln mu lp lq jt mv ju ls jw mw jx lu jz mx ka lw lx bi translated">将加密数据插入 BigQuery</h1><p id="7ee9" class="pw-post-body-paragraph kc kd in ke b kf ly jo kh ki lz jr kk kl ma kn ko kp mb kr ks kt mc kv kw kx ig bi translated">现在，让我们一起总结一下，创建一个代码，在 BigQuery 中创建一个表，表中的数据使用我们的 DEK 加密。</p><p id="4f6d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">确保安装以下依赖项:</p><pre class="me mf mg mh gt my mz na bn nb nc bi"><span id="0c00" class="nd lh in mz b be ne nf l ng nh">$  pip install tink<br/>$  pip install pandas<br/>$  pip install pandas-gbq</span></pre><p id="c5a6" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这段代码在 BigQuery 中创建了带有两个字段(` id`、` email `)的<em class="ni"> users </em>表，其中` id '不加密，而` email '加密。</p><p id="eb37" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">实际上，您的数据管道可能看起来不同，但是我为了这个例子简化了它。</p><pre class="me mf mg mh gt my mz na bn nb nc bi"><span id="89cf" class="nd lh in mz b be ne nf l ng nh">import tink<br/>from tink import daead<br/>from tink.integration import gcpkms<br/>import pandas as pd<br/><br/>KEK_URI = ‘gcp-kms://projects/aead-poc/locations/us-central1/keyRings/poc-keyring/cryptoKeys/kek’<br/>KEYSET_WRAPPER_JSON_PATH = '../keyset.json'<br/>GCP_CREDENTIAL_PATH = ''  # empty string for default or service account json path<br/>PROJECT_ID=’aead-poc’<br/>TABLE_NAME=’poc.users’<br/><br/>def encrypt_and_insert_to_bigquery():<br/>    data = [<br/>        [1, 'ran@example.com'],<br/>        [2, 'fox@example.com'],<br/>        [3, 'rose@example.com'],<br/>        [4, 'pilot@example.com'],<br/>    ]<br/><br/>    # Create the pandas DataFrame<br/>    df = pd.DataFrame(data, columns=['id', 'email'])<br/><br/>    with open(KEYSET_WRAPPER_JSON_PATH, 'rt') as keyset_file:<br/>        # Read the wrapper<br/>        keyset_wrapper_json = keyset_file.read()<br/>        daead.register()<br/><br/>        # Decrypt the wrapper and create cipher<br/>        keyset_handle = tink.KeysetHandle.read(<br/>            tink.JsonKeysetReader(keyset_wrapper_json), gcpkms.GcpKmsClient('', GCP_CREDENTIAL_PATH).get_aead(KEK_URI))<br/>        cipher = keyset_handle.primitive(daead.DeterministicAead)<br/><br/>        # Encrypt the email column using the DEK<br/>        df['email'] = df['email'].apply(lambda email: cipher.encrypt_deterministically(email.encode(), b''))<br/><br/>        # Save to BigQuery<br/>        df.to_gbq(<br/>                  destination_table=TABLE_NAME,<br/>                  project_id=PROJECT_ID,<br/>                  table_schema=[{'name': 'id', 'type': 'INTEGER'},<br/>                                {'name': 'email', 'type': 'BYTES'}],<br/>                  chunksize=10000,<br/>                  if_exists='replace'<br/>                  )<br/><br/>if __name__ == '__main__':<br/>    encrypt_and_insert_to_bigquery()</span></pre><p id="5abf" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">由于这段代码解密了包装器，您应该将一个<a class="ae ky" href="https://cloud.google.com/kms/docs/reference/permissions-and-roles#cloudkms.cryptoKeyDecrypter" rel="noopener ugc nofollow" target="_blank"> <em class="ni">云 KMS 密钥解密器</em> </a>角色分配给相关的 KEK。</p></div><div class="ab cl kz la hr lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="ig ih ii ij ik"><h1 id="6fc2" class="lg lh in bd li lj lk ll lm ln lo lp lq jt lr ju ls jw lt jx lu jz lv ka lw lx bi translated">使用 AEAD 函数在查询时解密数据</h1><p id="125a" class="pw-post-body-paragraph kc kd in ke b kf ly jo kh ki lz jr kk kl ma kn ko kp mb kr ks kt mc kv kw kx ig bi translated">现在，当我们有一个包含加密数据的表时，我们可以使用<em class="ni">DETERMINISTIC _ DECRYPT _ STRING</em>函数来解密数据。</p><pre class="me mf mg mh gt my mz na bn nb nc bi"><span id="d8a1" class="nd lh in mz b be ne nf l ng nh">DECLARE KMS_RESOURCE_NAME STRING;<br/>DECLARE WRAPPER BYTES;<br/>SET KMS_RESOURCE_NAME = ‘gcp-kms://projects/aead-poc/locations/us-central1/keyRings/poc-keyring/cryptoKeys/kek’;<br/>SET WRAPPER = FROM_BASE64("CiQA….Z3U="); #replace it with your wrapper - taken from `encryptedKeyset` in keyset.json<br/>SELECT<br/>  id,<br/>  email,<br/>  DETERMINISTIC_DECRYPT_STRING( KEYS.KEYSET_CHAIN(KMS_RESOURCE_NAME,<br/>      WRAPPER),<br/>    email,<br/>    "") decrypted_email<br/>FROM `aead-poc.poc.users`</span></pre><p id="186a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">它将返回以下结果:</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi nk"><img src="../Images/f39b4fd5616d3235322c8ca5cecbe3c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*virpOqwglx8w0PTe_0V1Fw.jpeg"/></div></div></figure><h1 id="d1bb" class="lg lh in bd li lj mt ll lm ln mu lp lq jt mv ju ls jw mw jx lu jz mx ka lw lx bi translated">许可</h1><p id="a754" class="pw-post-body-paragraph kc kd in ke b kf ly jo kh ki lz jr kk kl ma kn ko kp mb kr ks kt mc kv kw kx ig bi translated">如果一个用户拥有<em class="ni"> </em> <a class="ae ky" href="https://cloud.google.com/kms/docs/reference/permissions-and-roles#cloudkms.cryptoKeyDecrypter" rel="noopener ugc nofollow" target="_blank"> <em class="ni">云 KMS 密钥解密器</em> </a>的角色，这实际上意味着他可以解密包装器并得到绝密的 DEK。因此，我们不应该将这种能力给予需要访问来解密数据的用户。</p><p id="f19d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">GCP 专门为这个案例创造了一个神奇的角色，<a class="ae ky" href="https://cloud.google.com/kms/docs/reference/permissions-and-roles#cloudkms.cryptoKeyDecrypterViaDelegation" rel="noopener ugc nofollow" target="_blank"> <em class="ni">云 KMS 密钥解密器通过</em> </a>委托。它支持通过其他 Google 云服务进行解密操作，这意味着它将解密包装器的权限委托给 BigQuery，但用户自己无法做到这一点。</p><h1 id="1227" class="lg lh in bd li lj mt ll lm ln mu lp lq jt mv ju ls jw mw jx lu jz mx ka lw lx bi translated">让使用 UDF 更容易</h1><p id="0573" class="pw-post-body-paragraph kc kd in ke b kf ly jo kh ki lz jr kk kl ma kn ko kp mb kr ks kt mc kv kw kx ig bi translated">如果你觉得写这么多 SQL 代码来解密你的数据很烦人或者很麻烦，你可以通过创建下面的 UDF 来简化它</p><pre class="me mf mg mh gt my mz na bn nb nc bi"><span id="55b1" class="nd lh in mz b be ne nf l ng nh">CREATE OR REPLACE FUNCTION `aead-poc.poc.decrypt`(encodedText bytes) RETURNS STRING AS (<br/>   DETERMINISTIC_DECRYPT_STRING(<br/>KEYS.KEYSET_CHAIN('gcp-kms://projects/aead-poc/locations/us-central1/keyRings/poc-keyring/cryptoKeys/kek',<br/>           b'\004\324........\003'), <br/>     encodedText, "")<br/>);</span></pre><p id="662f" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你必须将你的包装转换成八进制转义序列。您可以使用以下 python 命令来实现:</p><pre class="me mf mg mh gt my mz na bn nb nc bi"><span id="ea66" class="nd lh in mz b be ne nf l ng nh">wrapper = ‘CiQA….Z3U=’<br/>print("b'" + ''.join(f'\\{n:03o}' for n in base64.b64encode(wrapper.encode())) + "'")</span></pre><p id="76aa" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后，您只需执行以下查询，它将返回相同的结果:</p><pre class="me mf mg mh gt my mz na bn nb nc bi"><span id="3ccd" class="nd lh in mz b be ne nf l ng nh">SELECT <br/>  id,<br/>  email, <br/> `aead-poc.poc.decrypt`(email) decrypted_email<br/>FROM `poc.users`</span></pre><p id="28e2" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这种情况下，用户必须拥有“<em class="ni"> aead-poc.poc.decrypt </em>”功能的权限，并且还必须拥有通过委托到 KEK 的<em class="ni">云 KMS 密钥解密器的权限。</em></p></div><div class="ab cl kz la hr lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="ig ih ii ij ik"><p id="0af1" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">希望它能帮助你保护你的数据管道。请记住，只加密敏感数据，否则，使用您的表会很麻烦。</p><p id="9f62" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">享受加密！</p></div></div>    
</body>
</html>