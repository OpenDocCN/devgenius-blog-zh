<html>
<head>
<title>Can Python do typed JSON serialization?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 可以做类型化 JSON 序列化吗？</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/can-python-do-type-safe-json-serialization-77e4d73ccd08?source=collection_archive---------2-----------------------#2022-08-21">https://blog.devgenius.io/can-python-do-type-safe-json-serialization-77e4d73ccd08?source=collection_archive---------2-----------------------#2022-08-21</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="6ccd" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">创建 Python 类型的 JSON 序列化库</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi kc"><img src="../Images/acb54150f7934830a6fc206106a3564b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1302/format:webp/0*8mI5tK8PVrcqktC1.jpg"/></div></figure><h2 id="52f8" class="kk kl in bd km kn ko dn kp kq kr dp ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">序</h2><p id="5823" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo kt lp lq lr kx ls lt lu lb lv lw lx ly ig bi translated">大约两年前，我的朋友让我帮助他们建立一个平台，简化个人之间的二手物品捐赠过程，同时允许每个人匿名。听起来是很高尚的事业，所以我当然乐意帮忙。</p><p id="233d" class="pw-post-body-paragraph lg lh in li b lj lz jo ll lm ma jr lo kt mb lq lr kx mc lt lu lb md lw lx ly ig bi translated">他们让我帮助他们开始这个项目，构建数据层和 REST API。我推荐使用 Python 作为编程语言，因为他们没有太多的编程经验，我认为这会让他们很快上手。</p><p id="ea29" class="pw-post-body-paragraph lg lh in li b lj lz jo ll lm ma jr lo kt mb lq lr kx mc lt lu lb md lw lx ly ig bi translated">我不是 python 开发人员，也没有多少使用 python 的经验。<br/>实际上这些年来我的主要编程语言是 Java，<br/>所以动态类型语言并不是我习惯使用的语言。</p><p id="e49a" class="pw-post-body-paragraph lg lh in li b lj lz jo ll lm ma jr lo kt mb lq lr kx mc lt lu lb md lw lx ly ig bi translated">当我开始编写数据模型和 DB CRUD 操作时，我希望找到一个众所周知的解决方案，将类实例序列化到 JSON 并返回，同时保持反序列化对象的运行时类型，类似于 Java 中的<em class="me"> Gson </em>或<em class="me"> Jackson </em>。我惊讶地发现，我在努力寻找这个问题的综合解决方案。</p><p id="477f" class="pw-post-body-paragraph lg lh in li b lj lz jo ll lm ma jr lo kt mb lq lr kx mc lt lu lb md lw lx ly ig bi translated">我决定将此作为一个挑战，创建一个 Python JSON 类型化序列化库— <strong class="li io"> Jsonic </strong>(参见<a class="ae mf" href="https://github.com/OrrBin/Jsonic" rel="noopener ugc nofollow" target="_blank"> Jsonic Github 库</a>)</p><p id="36b4" class="pw-post-body-paragraph lg lh in li b lj lz jo ll lm ma jr lo kt mb lq lr kx mc lt lu lb md lw lx ly ig bi translated">在本文中，我将介绍我在 Python 中使用类型化序列化过程所做的一些初步尝试，由此创建了<em class="me"> Jsonic </em>。</p><h2 id="5799" class="kk kl in bd km kn ko dn kp kq kr dp ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">问题定义</h2><p id="b3f8" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo kt lp lq lr kx ls lt lu lb lv lw lx ly ig bi translated">创建一个 Python JSON 序列化库，支持将类<em class="me"> C </em>的具体对象<em class="me"> O1 </em>序列化为 JSON 字典表示<em class="me"> J </em>，并将<em class="me"> J </em>反序列化回类<em class="me"> C </em>的具体对象<em class="me"> O2 </em>，使得<em class="me"> O1 === O2 </em>，<br/>其中<em class="me"> O1 === O2 </em>定义为:</p><p id="3bc3" class="pw-post-body-paragraph lg lh in li b lj lz jo ll lm ma jr lo kt mb lq lr kx mc lt lu lb md lw lx ly ig bi translated">对于<em class="me"> O1 </em>的每个实例属性<em class="me"> F1 </em>，在<em class="me"> O2 </em>中有一个与<em class="me"> F1 </em>同名的实例属性<em class="me"> F2 </em>，它支持:</p><ol class=""><li id="eec8" class="mg mh in li b lj lz lm ma kt mi kx mj lb mk ly ml mm mn mo bi translated">如果<em class="me"> F1 </em>的类型为<em class="me"> int </em>或<em class="me"> str </em>，则<em class="me"> F1 == F2 </em></li><li id="5540" class="mg mh in li b lj mp lm mq kt mr kx ms lb mt ly ml mm mn mo bi translated">如果<em class="me"> F1 </em>是一个类实例，那么<em class="me"> F1=== F2 </em></li></ol><p id="40f2" class="pw-post-body-paragraph lg lh in li b lj lz jo ll lm ma jr lo kt mb lq lr kx mc lt lu lb md lw lx ly ig bi translated">为了简单起见，我们将忽略 F1 是<em class="me">字典、列表、元组、集合、复杂</em> <br/>或除<em class="me"> int、str </em>之外的任何其他类型的情况(我们将支持嵌套类)。</p><h2 id="8335" class="kk kl in bd km kn ko dn kp kq kr dp ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">第一次尝试——幼稚的方法</h2><p id="0e62" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo kt lp lq lr kx ls lt lu lb lv lw lx ly ig bi translated">首先，让我们定义一个简单的类，我们将用它来测试我们的序列化和反序列化逻辑:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mu mv l"/></div><figcaption class="mw mx gj gh gi my mz bd b be z dk translated">图 1</figcaption></figure><p id="5cb4" class="pw-post-body-paragraph lg lh in li b lj lz jo ll lm ma jr lo kt mb lq lr kx mc lt lu lb md lw lx ly ig bi translated">我们的<em class="me">用户</em>类有 3 个字段:<em class="me">姓名、id </em>和<em class="me">年龄</em>，还有一个名为<em class="me">描述</em>的方法，该方法以字符串形式返回用户的描述。<br/>让我们尝试序列化和反序列化<em class="me">用户</em>实例的简单方法:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="fa86" class="pw-post-body-paragraph lg lh in li b lj lz jo ll lm ma jr lo kt mb lq lr kx mc lt lu lb md lw lx ly ig bi translated">在这个解决方案中，我们使用 Python 的<a class="ae mf" href="https://docs.python.org/3/library/json.html" rel="noopener ugc nofollow" target="_blank"><em class="me">json</em></a><em class="me">dumps</em>函数将<em class="me">用户</em>实例序列化为 JSON 字符串表示，<em class="me">加载</em>函数将 JSON 字符串反序列化回<em class="me">用户</em>实例<em class="me">。</em></p><ul class=""><li id="388a" class="mg mh in li b lj lz lm ma kt mi kx mj lb mk ly na mm mn mo bi translated">看起来<em class="me"> json.dumps </em>对我们的用例非常适用，因为它的输出是格式良好的 json(第 11 行)，但是我们的目标是将<em class="me">用户</em>实例序列化为 JSON <em class="me"> dict </em>表示，而不是 JSON 字符串。你可以在第 8 行看到<em class="me">转储</em>给我们一个<em class="me">字符串</em>输出。</li><li id="089a" class="mg mh in li b lj mp lm mq kt mr kx ms lb mt ly na mm mn mo bi translated">json.loads 返回类<em class="me"> User，</em>的类型<em class="me"> dict(第 17 行)</em>的一个实例，这是我们的目标所要求的。</li><li id="a341" class="mg mh in li b lj mp lm mq kt mr kx ms lb mt ly na mm mn mo bi translated">当试图调用<em class="me">deserialized _ User . describe</em>时，我们得到一个异常，因为<em class="me"> deserialized_user </em>是<em class="me"> dict </em>而不是类<em class="me"> User </em>的实例，并且它没有名为<em class="me"> describe 的实例方法。</em></li><li id="a69c" class="mg mh in li b lj mp lm mq kt mr kx ms lb mt ly na mm mn mo bi translated"><em class="me"> json.dumps(self，</em><strong class="li io"><em class="me">default = lambda o:o . _ _ dict _ _</em></strong><em class="me">)</em><a class="ae mf" href="https://docs.python.org/3/library/json.html#json.dumps" rel="noopener ugc nofollow" target="_blank"><em class="me">default</em>argument</a>定义遇到无法序列化的对象时要调用的函数。我们传递<strong class="li io"> <em class="me"> lambda o: o.__dict__，</em> </strong>为这些情况返回对象的 __dict__ 属性。我们稍后将回到这个论点。</li></ul><p id="2d3e" class="pw-post-body-paragraph lg lh in li b lj lz jo ll lm ma jr lo kt mb lq lr kx mc lt lu lb md lw lx ly ig bi translated">我们的第一种方法失败了，但是我们可以尝试利用 Python 内置的<a class="ae mf" href="https://docs.python.org/3/library/json.html" rel="noopener ugc nofollow" target="_blank"><em class="me">JSON</em></a><em class="me"/>序列化来完成我们的目标。</p><h2 id="c93e" class="kk kl in bd km kn ko dn kp kq kr dp ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">第二次尝试—反序列化类方法</h2><p id="4d06" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo kt lp lq lr kx ls lt lu lb lv lw lx ly ig bi translated">我们可以利用 python<a class="ae mf" href="https://book.pythontips.com/en/latest/args_and_kwargs.html" rel="noopener ugc nofollow" target="_blank"><em class="me">* * kwargs</em></a><em class="me"/>功能，这允许您的函数接受任意数量的关键字参数，<br/>与<a class="ae mf" href="https://python-reference.readthedocs.io/en/latest/docs/operators/dict_unpack.html" rel="noopener ugc nofollow" target="_blank"> <em class="me"> **字典解包</em> </a> <em class="me"> </em>相结合，从<em class="me"> json.loads </em>调用返回的<em class="me">字典</em>中创建一个<em class="me">用户</em>实例</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mu mv l"/></div><figcaption class="mw mx gj gh gi my mz bd b be z dk translated">图 4</figcaption></figure><p id="bf24" class="pw-post-body-paragraph lg lh in li b lj lz jo ll lm ma jr lo kt mb lq lr kx mc lt lu lb md lw lx ly ig bi translated">我们向我们的用户类添加了两个方法:</p><ul class=""><li id="24ed" class="mg mh in li b lj lz lm ma kt mi kx mj lb mk ly na mm mn mo bi translated"><em class="me">序列化— </em>我们使用<em class="me"> json.dumps </em>将<em class="me">用户</em>实例序列化为 json 字符串，然后使用<em class="me"> json.loads </em>将其反序列化为 JSON 字典。这种序列化逻辑非常适合我们的用例</li><li id="8eed" class="mg mh in li b lj mp lm mq kt mr kx ms lb mt ly na mm mn mo bi translated"><em class="me">反序列化</em> —这是一个类方法，它获取<em class="me">用户</em>实例的<em class="me"> dict </em> JSON 表示，并使用<em class="me">用户</em>类构造函数构造新的<em class="me">用户</em>实例，该构造函数现在接受任意数量的命名参数。它将作为参数得到的解压后的 dict 传递给构造函数。<br/>对于具有值{"name": "Bob "，" id": 1，" age": 18}的字典，类似的<em class="me">用户</em>实例启动调用将是:</li></ul><pre class="kd ke kf kg gt nb nc nd ne aw nf bi"><span id="f978" class="kk kl in nc b gy ng nh l ni nj">User(name: Bob, id: 1, age: 18)</span></pre><p id="31ad" class="pw-post-body-paragraph lg lh in li b lj lz jo ll lm ma jr lo kt mb lq lr kx mc lt lu lb md lw lx ly ig bi translated">让我们测试我们的代码:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mu mv l"/></div></figure><ul class=""><li id="eed5" class="mg mh in li b lj lz lm ma kt mi kx mj lb mk ly na mm mn mo bi translated">我们创建<em class="me">用户</em>实例，然后我们将其序列化为 JSON(第 5 行)，我们确实得到了 JSON <em class="me"> dict </em>表示，而不是我们的目标所要求的<em class="me"> str </em>(第 8 行)</li><li id="baa6" class="mg mh in li b lj mp lm mq kt mr kx ms lb mt ly na mm mn mo bi translated">然后我们使用反序列化方法将 JSON <em class="me"> dict </em>反序列化回<em class="me">用户</em>实例<em class="me"> </em>(第 13 行)，我们确实得到了<em class="me">用户</em>类的实例(第 17 行)。<br/>我们调用 describe 方法，这次它像预期的那样工作(第 19-20 行)</li></ul><p id="1a0f" class="pw-post-body-paragraph lg lh in li b lj lz jo ll lm ma jr lo kt mb lq lr kx mc lt lu lb md lw lx ly ig bi translated">我们的解决方案适用于我们的用例，但是让我们测试另一个用例，在我们的<em class="me">用户</em>类中嵌套<em class="me">地址</em>类:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mu mv l"/></div><figcaption class="mw mx gj gh gi my mz bd b be z dk translated">图 7</figcaption></figure><p id="a68c" class="pw-post-body-paragraph lg lh in li b lj lz jo ll lm ma jr lo kt mb lq lr kx mc lt lu lb md lw lx ly ig bi translated">让我们测试一下本课程的解决方案</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mu mv l"/></div></figure><ul class=""><li id="b064" class="mg mh in li b lj lz lm ma kt mi kx mj lb mk ly na mm mn mo bi translated"><em class="me"> deserialized_user </em>确实是用户类实例(第 22 行)</li><li id="0d5d" class="mg mh in li b lj mp lm mq kt mr kx ms lb mt ly na mm mn mo bi translated">但是<em class="me">deserialized _ user</em>Address 属性是 dict 而不是<em class="me"> Address </em>实例(第 25 行)，因此我们不能调用<em class="me">deserialized _ user . Address . describe()</em>(第 27–28 行)</li><li id="3e6f" class="mg mh in li b lj mp lm mq kt mr kx ms lb mt ly na mm mn mo bi translated">我们的解决方案不适用于嵌套类。让我们试着解决这个问题</li></ul><p id="cb03" class="pw-post-body-paragraph lg lh in li b lj lz jo ll lm ma jr lo kt mb lq lr kx mc lt lu lb md lw lx ly ig bi translated">当反序列化用户实例时，我们首先将地址实例显式反序列化为变量，并将其传递给用户类构造函数，以及:<em class="me"> name，id，age </em>参数</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mu mv l"/></div><figcaption class="mw mx gj gh gi my mz bd b be z dk translated">图 10</figcaption></figure><p id="3182" class="pw-post-body-paragraph lg lh in li b lj lz jo ll lm ma jr lo kt mb lq lr kx mc lt lu lb md lw lx ly ig bi translated">让我们测试新的反序列化方法</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mu mv l"/></div></figure><ul class=""><li id="3bf9" class="mg mh in li b lj lz lm ma kt mi kx mj lb mk ly na mm mn mo bi translated"><em class="me"> deserialized_user </em>和之前一样是类<em class="me"> User </em>的实例(第 8 行)</li><li id="16dc" class="mg mh in li b lj mp lm mq kt mr kx ms lb mt ly na mm mn mo bi translated">但是现在<em class="me">deserialized _ user . Address</em>也确实是所需的<em class="me"> Address </em>类的实例(第 11 行)，因此我们可以调用<em class="me">deserialized _ user . Address . describe()(第 16–17 行)</em></li></ul><p id="4b06" class="pw-post-body-paragraph lg lh in li b lj lz jo ll lm ma jr lo kt mb lq lr kx mc lt lu lb md lw lx ly ig bi translated">serialize 方法实际上不需要类实例的任何状态，可以很容易地从实例方法转换为接收对象并将其序列化的函数。但是当有嵌套类时，<em class="me">反序列化</em>方法确实需要每个类的显式实现。</p><p id="735d" class="pw-post-body-paragraph lg lh in li b lj lz jo ll lm ma jr lo kt mb lq lr kx mc lt lu lb md lw lx ly ig bi translated">虽然这种方法可行，但很容易看出它不可伸缩。<br/>我们将需要为我们希望能够反序列化的每个类实现<em class="me">反序列化</em>方法。</p><p id="ea59" class="pw-post-body-paragraph lg lh in li b lj lz jo ll lm ma jr lo kt mb lq lr kx mc lt lu lb md lw lx ly ig bi translated">让我们尝试收集我们所学的知识，并尝试最后第三次尝试来支持嵌套类的序列化和反序列化，而不需要每个类中的 boiler plate 代码。</p><h2 id="43a8" class="kk kl in bd km kn ko dn kp kq kr dp ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">第三次尝试—在递归中序列化类型名和反序列化</h2><p id="79b9" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo kt lp lq lr kx ls lt lu lb lv lw lx ly ig bi translated">先从序列化说起。我们的序列化基于<a class="ae mf" href="https://docs.python.org/3/library/json.html#json.dumps" rel="noopener ugc nofollow" target="_blank"> <em class="me"> json.dumps </em> </a>。<br/> <em class="me"> json.dumps </em>有一个名为 default 的重要参数，在官方文档中描述如下:</p><blockquote class="nk nl nm"><p id="6dd8" class="lg lh me li b lj lz jo ll lm ma jr lo nn mb lq lr no mc lt lu np md lw lx ly ig bi translated">如果指定，<strong class="li io"> <em class="in">默认的</em> </strong>应该是一个函数，为那些不能被序列化的对象调用。它应该返回该对象的 JSON 可编码版本，或者引发一个<code class="fe nq nr ns nc b"><a class="ae mf" href="https://docs.python.org/3/library/exceptions.html#TypeError" rel="noopener ugc nofollow" target="_blank">TypeError</a></code>。如果未指定，则引发<code class="fe nq nr ns nc b"><a class="ae mf" href="https://docs.python.org/3/library/exceptions.html#TypeError" rel="noopener ugc nofollow" target="_blank">TypeError</a></code>。</p></blockquote><p id="23dd" class="pw-post-body-paragraph lg lh in li b lj lz jo ll lm ma jr lo kt mb lq lr kx mc lt lu lb md lw lx ly ig bi translated">到目前为止，我们传递了一个简单地返回 object <em class="me"> __dict__ </em>属性的函数。我们可以更好地利用默认参数，并传递一个自定义函数来处理序列化类实例。<br/>让我们尝试创建<em class="me"> serialize </em>函数，该函数获取对象并将其序列化为一个<em class="me"> dict </em>，就像我们之前所做的那样，但是使用完全限定的类名为每个序列化的类实例添加了一个属性，因此我们可以在反序列化时初始化相关类的实例</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mu mv l"/></div></figure><ul class=""><li id="18ae" class="mg mh in li b lj lz lm ma kt mi kx mj lb mk ly na mm mn mo bi translated"><em class="me">serialize</em>function<em class="me">:</em>我们的<em class="me"> serialize </em> function 与我们之前所做的非常相似，但是我们不传递只将 o.__dict__ 返回给<em class="me"> json.dumps </em>缺省参数的函数，该函数将被调用，否则无法被序列化。相反，我们传递我们的<em class="me"> _serialize_object </em>函数</li><li id="1a7b" class="mg mh in li b lj mp lm mq kt mr kx ms lb mt ly na mm mn mo bi translated"><em class="me"> _serialize_object </em>函数:该函数返回填充了对象属性的<em class="me">字典</em>，但是它添加了一个重要的属性，即 Objects 类的完全限定名(<em class="me"> type_name)。</em>这将允许我们在反序列化这个 JSON 时理解它应该被反序列化成什么类。</li><li id="d775" class="mg mh in li b lj mp lm mq kt mr kx ms lb mt ly na mm mn mo bi translated"><em class="me"> _full_type_name </em>函数:从对象中提取其完全限定的类型名，包括其模块和类名。我们将使用这个限定符来获取相关的类，并在反序列化时创建它的实例</li></ul><p id="8236" class="pw-post-body-paragraph lg lh in li b lj lz jo ll lm ma jr lo kt mb lq lr kx mc lt lu lb md lw lx ly ig bi translated">让我们看看当使用新的<em class="me"> serialize </em>函数序列化用户实例时，我们得到了什么输出</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="7d7c" class="pw-post-body-paragraph lg lh in li b lj lz jo ll lm ma jr lo kt mb lq lr kx mc lt lu lb md lw lx ly ig bi translated">我们可以看到，除了针对用户<em class="me">及其嵌套的<em class="me">地址</em>的<em class="me"> _serialized_type </em>之外，我们还获得了 JSON 中所有期望的字段。<br/> <em class="me"> __main__ </em>是模块的名称，<em class="me">是地址，用户</em>是类名。</em></p><p id="8776" class="pw-post-body-paragraph lg lh in li b lj lz jo ll lm ma jr lo kt mb lq lr kx mc lt lu lb md lw lx ly ig bi translated">让我们试着创建<em class="me">反序列化</em>函数，它将接受由<em class="me">序列化</em>函数创建的 JSON <em class="me">字典</em>，并将其反序列化回类实例</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mu mv l"/></div></figure><ol class=""><li id="a04e" class="mg mh in li b lj lz lm ma kt mi kx mj lb mk ly ml mm mn mo bi translated">首先，我们验证名为<em class="me"> _serialized_type </em>的属性是否存在，否则我们不知道要反序列化到哪个类中。如果它丢失了，我们将引发类型错误。</li><li id="a0b9" class="mg mh in li b lj mp lm mq kt mr kx ms lb mt ly ml mm mn mo bi translated">在第 6–7 行中，我们获得了完全限定的类型名，然后使用<em class="me"> _get_type_by_name </em>函数提取类对象本身(我不会详细介绍这个函数的实现)</li><li id="57c4" class="mg mh in li b lj mp lm mq kt mr kx ms lb mt ly ml mm mn mo bi translated">在第 9–17 行，我们用所有的对象项创建了<em class="me"> deserialized_dict </em>，将键映射到反序列化的值。我们跳过了<em class="me"> _serialized_type </em>项，对于 dict 类型的项，我们进行递归调用来反序列化它们的值。对于其他类型，我们只使用实际值(记住，为了简单起见，我们只处理 int 和 str 项类型)</li><li id="3745" class="mg mh in li b lj mp lm mq kt mr kx ms lb mt ly ml mm mn mo bi translated">第 20 行检索我们的类构造函数的签名。在第 19–31 行，我们创建了初始化字典，将每个类构造函数参数映射到它的反序列化值。我们将跳过<em class="me"> self </em>参数(第 23–24 行)，以及<em class="me"> args </em>和<em class="me"> kwargs </em>参数(第 25–27 行)。<br/>如果反序列化值 dict 缺少某个构造函数参数的值，我们将引发<em class="me"> AttributeError </em>(第 29–30 行)</li><li id="f1af" class="mg mh in li b lj mp lm mq kt mr kx ms lb mt ly ml mm mn mo bi translated">最后，在第 33–35 行，我们使用我们的<em class="me"> cls </em> initiator 初始化并返回类实例，传递初始化<em class="me"> dict，</em>将构造函数参数名映射到相应的反序列化值</li></ol><p id="a019" class="pw-post-body-paragraph lg lh in li b lj lz jo ll lm ma jr lo kt mb lq lr kx mc lt lu lb md lw lx ly ig bi translated">让我们测试一下我们的反序列化方法</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="97d2" class="pw-post-body-paragraph lg lh in li b lj lz jo ll lm ma jr lo kt mb lq lr kx mc lt lu lb md lw lx ly ig bi translated">它正如我们所希望的那样工作！<br/> <em class="me"> deserialized_user </em>是类 user(第 5 行)的实例<em class="me">deserialized _ User . Address</em>是类<em class="me"> Address </em>(第 8 行)<br/>的实例在第 10–11 行我们可以看到<em class="me">deserialized _ User . describe</em>的输出与我们预期的一样，在第 13–14 行我们可以看到<em class="me">deserialized _ User . Address . describe</em>也与预期的一样！</p><h1 id="132d" class="nt kl in bd km nu nv nw kp nx ny nz ks jt oa ju kw jw ob jx la jz oc ka le od bi translated">结论</h1><p id="5456" class="pw-post-body-paragraph lg lh in li b lj lk jo ll lm ln jr lo kt lp lq lr kx ls lt lu lb lv lw lx ly ig bi translated">我们已经成功地解决了我们为自己定义的问题。<br/>对于具有<em class="me"> str </em>和<em class="me"> int </em>属性的嵌套类，我们的<em class="me"> serialize </em>和<em class="me"> deserialize </em>函数支持将类实例序列化为 JSON 并返回到同一类的新创建的实例。<br/>不像我们第二次尝试的那样，每个等级都需要锅炉钢板代码。</p><p id="6ae6" class="pw-post-body-paragraph lg lh in li b lj lz jo ll lm ma jr lo kt mb lq lr kx mc lt lu lb md lw lx ly ig bi translated">这个问题被高度简化了。如果您想了解我是如何处理其他需求的，请访问 Jsonic Github 库:</p><ul class=""><li id="7fbf" class="mg mh in li b lj lz lm ma kt mi kx mj lb mk ly na mm mn mo bi translated">更多内置类型，如<em class="me"> list </em>、<em class="me"> dict </em>等等</li><li id="0c0c" class="mg mh in li b lj mp lm mq kt mr kx ms lb mt ly na mm mn mo bi translated">允许为特定类型注册自定义序列化程序，比如<em class="me"> datetime </em></li><li id="89ae" class="mg mh in li b lj mp lm mq kt mr kx ms lb mt ly na mm mn mo bi translated">支持与 Java <em class="me">瞬态</em>字段类似的功能，该字段不应该是序列化的一部分</li><li id="1830" class="mg mh in li b lj mp lm mq kt mr kx ms lb mt ly na mm mn mo bi translated">运行类型反序列化类型验证(反序列化类实例时，传递反序列化实例的预期类型，如果它与反序列化结果类型不匹配，则引发错误)</li><li id="c3a7" class="mg mh in li b lj mp lm mq kt mr kx ms lb mt ly na mm mn mo bi translated">JSON 字符串而不是 JSON 字典表示的序列化/反序列化过程</li><li id="e47f" class="mg mh in li b lj mp lm mq kt mr kx ms lb mt ly na mm mn mo bi translated">支持序列化未传递给构造函数但仍应序列化的属性，自定义构造函数参数名称映射到相应的类属性和</li></ul><p id="24ff" class="pw-post-body-paragraph lg lh in li b lj lz jo ll lm ma jr lo kt mb lq lr kx mc lt lu lb md lw lx ly ig bi translated">要在您自己的项目中使用 Jsonic:</p><pre class="kd ke kf kg gt nb nc nd ne aw nf bi"><span id="3225" class="kk kl in nc b gy ng nh l ni nj">pip install py-jsonic</span></pre><p id="4f71" class="pw-post-body-paragraph lg lh in li b lj lz jo ll lm ma jr lo kt mb lq lr kx mc lt lu lb md lw lx ly ig bi translated">请随意通读<a class="ae mf" href="https://github.com/OrrBin/Jsonic" rel="noopener ugc nofollow" target="_blank"> Jsonic Github 库</a>，如果您对如何改进 Jsonic 有好的想法，请贡献代码。</p><p id="ef52" class="pw-post-body-paragraph lg lh in li b lj lz jo ll lm ma jr lo kt mb lq lr kx mc lt lu lb md lw lx ly ig bi translated">感谢阅读，下期再见！</p></div></div>    
</body>
</html>