<html>
<head>
<title>Best of Modern JavaScript — Typed Arrays and Map/Set Issues</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">现代 JavaScript 的精华——类型化数组和映射/集合问题</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/best-of-modern-javascript-typed-arrays-and-map-set-issues-56c41d940748?source=collection_archive---------6-----------------------#2020-10-28">https://blog.devgenius.io/best-of-modern-javascript-typed-arrays-and-map-set-issues-56c41d940748?source=collection_archive---------6-----------------------#2020-10-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/51d284efe86e00e42940f7497c0eeed0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*g57q8cAEiLpiic1v"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">格伦·卡斯滕斯-彼得斯在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="a531" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">自 2015 年以来，JavaScript 有了巨大的进步。</p><p id="c894" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在用起来比以前舒服多了。</p><p id="193a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究映射、集合和类型化数组的问题。</p><h1 id="1a87" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">为什么地图和集合具有大小属性？</h1><p id="e141" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">映射和集合具有<code class="fe me mf mg mh b">size</code>属性而不是<code class="fe me mf mg mh b">length</code>，因为它们不是顺序数据结构，不像数组。</p><p id="1906" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">length</code>是指像数组这样的顺序数据结构。</p><h1 id="16cf" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">配置贴图和集比较关键点和值的方式</h1><p id="46a4" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">没有办法配置贴图和集合如何比较它们的键和值。</p><p id="486b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个特性很难有效且正确地实现。</p><h1 id="e8b2" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">从地图中获取东西时指定默认值</h1><p id="7675" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">当我们从地图中获取某些东西时，没有什么比指定默认值更简单的了。</p><p id="e725" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">地图不让我们直接设置默认值。</p><p id="39f4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是我们可以使用<code class="fe me mf mg mh b">||</code>操作符来实现，因为当条目不存在时<code class="fe me mf mg mh b">get</code>会返回<code class="fe me mf mg mh b">undefined</code>。</p><p id="4584" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们可以这样写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="ed67" class="mq lc iq mh b gy mr ms l mt mu">const map = new Map();<br/>//...<br/>const prevCount = map.get('foo') || 0;</span></pre><p id="3a07" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用键<code class="fe me mf mg mh b">'foo'</code>得到这个值。</p><p id="f794" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果是<code class="fe me mf mg mh b">undefined</code>，我们返回 0。</p><h1 id="84c5" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">贴图与对象</h1><p id="3125" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">地图适合保存字符串键以外的键。</p><p id="1c05" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">否则，对象可以给我们同等的功能。</p><p id="a3c5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们要映射任意数据，那么地图可能是更好的选择。</p><p id="d2a7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果有一组固定的键，那么对象是一个不错的选择。</p><p id="a302" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果键改变了，那么地图会更好。</p><h1 id="f7e9" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">何时使用对象作为映射键？</h1><p id="c143" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果我们在外部将数据附加到对象，我们可以将对象用作映射键。</p><p id="4d45" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但这用 WeakMaps 更好，因为如果我们删除对 key 对象的引用，就会发生垃圾收集。</p><h1 id="1b95" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">类型化数组</h1><p id="1018" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">类型化数组是一种特殊的数组，它允许我们保存二进制数据。</p><p id="d857" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们让我们操作图像数据、画布元素、处理二进制文件等。</p><p id="3d75" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们可以使用它们与 WebGL 等本地 API 进行交互，以进行图形操作。</p><p id="8ad5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果没有新的数据类型，就无法操作这些 API 中的二进制数据。</p><p id="0bb2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">两种对象与类型化数组一起工作。</p><p id="5997" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们包括缓冲区和视图。</p><p id="8118" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">缓冲区是<code class="fe me mf mg mh b">ArrayBuffer</code>的实例，保存二进制数据。</p><p id="8c9a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">视图提供了访问二进制数据的方法。</p><p id="bc46" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有两种观点。</p><p id="14b9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一种是类型化数组构造函数的实例，如<code class="fe me mf mg mh b">Uint8Array</code>、<code class="fe me mf mg mh b">Floar64Array</code>等。</p><p id="f4c5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些工作起来像异常数组，但只允许一种类型的元素，没有漏洞。</p><p id="481c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一个是<code class="fe me mf mg mh b">DataVBiew</code>的实例，它允许我们访问缓冲区中的字节偏移量。</p><h1 id="bd53" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">处理溢出和下溢</h1><p id="6d23" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">当值超出范围时，使用模运算将其转换为范围内的值。</p><p id="46ce" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这意味着最高值加 1 转换为最低值。</p><p id="38f1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并且最小值减 1 被转换成最大值。</p><p id="67f8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">类型化数组就是这种情况。</p><p id="db9c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="9918" class="mq lc iq mh b gy mr ms l mt mu">const uint8 = new Uint8Array(1);<br/>uint8[0] = 255;</span></pre><p id="c26f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">uint8[0]</code>是 255。</p><p id="2115" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一方面，如果我们有:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="0f2b" class="mq lc iq mh b gy mr ms l mt mu">const uint8 = new Uint8Array(1);<br/>uint8[0] = 256;</span></pre><p id="a768" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">uint8[0]</code>为 0。</p><p id="f046" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们有:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="9aad" class="mq lc iq mh b gy mr ms l mt mu">const uint8 = new Uint8Array(1);<br/>uint8[0] = -1;</span></pre><p id="b0ed" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">uint8[0]</code>是 255。</p><p id="bdd5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这适用于所有类型的类型化数组。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/d5df19807710c2caead7fc72d4fc2b26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3AsXuivppuQ6bwfR"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@dead____artist?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">捕捉人心。</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></figcaption></figure><h1 id="5468" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="de75" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">地图和集合有其局限性。它们也适用于某些应用。</p><p id="29c8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">类型化数组用于存储二进制数据。</p></div></div>    
</body>
</html>