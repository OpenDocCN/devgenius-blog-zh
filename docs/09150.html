<html>
<head>
<title>Scalable Error Handling in Node Using the Decorator Pattern.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用装饰模式在节点中进行可伸缩的错误处理。</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/scalable-error-handling-in-node-using-the-decorator-pattern-c475d7c99ce5?source=collection_archive---------6-----------------------#2022-08-02">https://blog.devgenius.io/scalable-error-handling-in-node-using-the-decorator-pattern-c475d7c99ce5?source=collection_archive---------6-----------------------#2022-08-02</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/d5489ac4d93c4ddc87dba764abd7b771.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3-focLvEFi3U0uCGJ4lQhA.png"/></div></div></figure><div class=""/><p id="be50" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">使用不同类型的 API、服务、数据库、其他服务器等。使得在服务器上以可伸缩的方式处理响应和错误变得复杂，因为每个消耗品都有自己的签名、响应和错误结构。</p><h1 id="00df" class="kt ku iy bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">TL；速度三角形定位法(dead reckoning)</h1><p id="1591" class="pw-post-body-paragraph jv jw iy jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">你可以跳过一切，直接进入我在这篇文章末尾添加的代码沙箱。</p><h1 id="550e" class="kt ku iy bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">背景</h1><p id="fe4d" class="pw-post-body-paragraph jv jw iy jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">在<a class="ae lw" href="https://pgarciacamou.medium.com/modern-javascript-decorator-pattern-1b440500b38e" rel="noopener">现代 JavaScript 装饰模式</a>中，我提到过:</p><blockquote class="lx ly lz"><p id="fd38" class="jv jw ma jx b jy jz ka kb kc kd ke kf mb kh ki kj mc kl km kn md kp kq kr ks ig bi translated">在迁移我们的一个 GraphQL 端点时，我注意到错误结构略有变化。这通常不是问题，但是每个使用数据的控制器都有不同的客户端错误映射(statusCode、name、Code 等等),这使得迁移非常困难。此外，一些控制器暴露了可能成为潜在安全风险的数据。</p></blockquote><p id="ff03" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这篇文章中，我将向你展示我是如何重用我实现的<a class="ae lw" href="https://pgarciacamou.medium.com/modern-javascript-decorator-pattern-1b440500b38e" rel="noopener">装饰模式</a>并使其适应<code class="fe me mf mg mh b">ExpressJS</code>的错误处理的，如果你对理解实现细节和结论感兴趣，请随意阅读这篇文章。</p><p id="fa7d" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里我们有<a class="ae lw" href="https://pgarciacamou.medium.com/modern-javascript-decorator-pattern-1b440500b38e" rel="noopener">装饰模式</a>的实现:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="be56" class="mq ku iy mh b gy mr ms l mt mu">export class DecoratedError extends Error {<br/>  constructor(error, ...decorators) {<br/>    if (typeof error === "string" || error instanceof String) {<br/>      error = new Error(error);<br/>    }<br/>    let previouslyParsedData = {};<br/>    if (error instanceof DecoratedError) {<br/>      previouslyParsedData = error;<br/>      error = error.cause;<br/>    }<br/>    super(error?.message, { cause: error });<br/>    this.decorate(previouslyParsedData, decorators);<br/>  }<br/>  decorate(...decorators) {<br/>    const rawError = this.cause || {};<br/>    while (decorators.length &gt; 0) {<br/>      const decorator = decorators.shift();<br/>      if (decorator instanceof Function) {<br/>        decorators.unshift(decorator(rawError, { ...this }));<br/>        continue;<br/>      } else if (Array.isArray(decorator)) {<br/>        decorators = decorator.concat(decorators); // flatten<br/>        continue;<br/>      } else if (decorator === Object(decorator)) {<br/>        for (const key in decorator) {<br/>          if (decorator[key] !== undefined &amp;&amp; key !== "cause") {<br/>            Object.defineProperty(this, key, {<br/>              value: decorator[key],<br/>              writable: true,<br/>              enumerable: true,<br/>              configurable: true<br/>            });<br/>          }<br/>        }<br/>      }<br/>    }<br/>    return this;<br/>  }<br/>}</span></pre><p id="1e14" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">上面的<a class="ae lw" href="https://gist.github.com/pgarciacamou/88d03714b3c4deccec3396bf43956263#file-decoratederror-js" rel="noopener ugc nofollow" target="_blank">装饰类</a>继承自<code class="fe me mf mg mh b">Error</code>用于堆栈跟踪，它使用<code class="fe me mf mg mh b">decorate</code>解析错误并增强实例。我们的想法是利用动态类型，允许传递<code class="fe me mf mg mh b">Array</code>、<code class="fe me mf mg mh b">Function</code>和<code class="fe me mf mg mh b">Object</code>以可伸缩和可重用的方式修饰实例。</p><p id="d5a1" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是一个非常简约的预览:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="aa42" class="mq ku iy mh b gy mr ms l mt mu">// signature<br/>new DecoratedError(Error|String, ...(Object|() =&gt; Object|Array))</span><span id="e372" class="mq ku iy mh b gy mv ms l mt mu">// manual errors with an object decorator<br/>new DecoratedError('Oops!', { status: 500 })</span><span id="dec0" class="mq ku iy mh b gy mv ms l mt mu">// catching errors<br/>try { ... } catch (error) {<br/>  new DecoratedError(error, (error, parsed) =&gt; ({<br/>    status: error.status || 500 // defaults to 500<br/>  })<br/>}</span><span id="e350" class="mq ku iy mh b gy mv ms l mt mu">// using N decorators<br/>new DecoratedError('error', () =&gt; ({}), {}, [{}, {}], ...)</span><span id="b71e" class="mq ku iy mh b gy mv ms l mt mu">// API responses<br/>const response = API.doSomething() // raw<br/>const decorator1 = (response, parsedData) =&gt; ({ ... })<br/>const decorator2 = (response, parsedData) =&gt; ({ ... })<br/>new DecoratedError(response, decorator1, decorator2, ...)</span></pre><h1 id="a7b5" class="kt ku iy bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">解决办法</h1><p id="4932" class="pw-post-body-paragraph jv jw iy jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">为了让<code class="fe me mf mg mh b">DecoratedError</code>准备好处理服务器错误，我们必须做一些事情:通过继承进行一些增强，创建错误类型，使用组合来处理错误映射，并能够为客户端将<em class="ma">特定错误</em>转换为<em class="ma">非敏感错误</em>。</p><h2 id="beaf" class="mq ku iy bd kv mw mx dn kz my mz dp ld kg na nb lh kk nc nd ll ko ne nf lp ng bi translated">继承性增强</h2><p id="eae6" class="pw-post-body-paragraph jv jw iy jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">我在<code class="fe me mf mg mh b">ServerError</code> : <code class="fe me mf mg mh b">getClientError</code>中引入了两个新方法来清理响应，这样我们就不会将<strong class="jx iz">敏感的</strong>数据暴露给客户端；然后<code class="fe me mf mg mh b">send</code>形成一个适当的客户端响应，并以某种预期的方式发送出去。</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="720c" class="mq ku iy mh b gy mr ms l mt mu">class ServerError extends DecoratedError {<br/>  /**<br/>   * This method cleans the error for the client.<br/>   */<br/>  getClientError() {<br/>    // Clean non-enumerable Error props like 'name'<br/>    const enumerableProps = { ...this };<br/> <br/>    const {<br/>      status,<br/>      code,<br/>      name,<br/>      redirectUrl,<br/>      clientData = {}<br/>    } = enumerableProps;<br/> <br/>    const {<br/>      status,<br/>      code,<br/>      name,<br/>      redirectUrl,<br/>      clientData = {}<br/>    } = enumerableProps;<br/> <br/>    return {<br/>      // required<br/>      status: status || 500,<br/>      name: name || "INTERNAL_SERVER_ERROR",<br/>      // optional<br/>      ...(code &amp;&amp; { code }),<br/>      ...(redirectUrl &amp;&amp; { redirectUrl }),<br/>      // Explicitly mention what props to pass to the client.<br/>      // This is required to avoid security issues.<br/>      ...clientData<br/>    };<br/>  }<br/>  /**<br/>   * This method takes care of sending the response<br/>   */<br/>  send(req, res, next) {<br/>    const response = this.getClientError()<br/>    let { status, redirectUrl } = response<br/>    status = status || 500 // default to 500<br/> <br/>    // Anything &lt;300 should not be treated as an error<br/>    if(status &lt; 300) {<br/>      status = 400<br/>    }<br/> <br/>    const redirect = status &gt;= 300 &amp;&amp; status &lt; 400 &amp;&amp; !!redirectUrl<br/>    // Redirect unless AJAX.<br/>    if (redirect &amp;&amp; !isAjaxRequest(req)) {<br/>      return res.status(status).redirect(redirectUrl)<br/>    }<br/> <br/>    // Gracefully default to JSON:<br/>    return res.status(status).json(response)<br/>  }<br/>}</span></pre><p id="7149" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">上面的代码需要这个小工具:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="349b" class="mq ku iy mh b gy mr ms l mt mu">// Checks if an HTTP request is to be considered an AJAX request.<br/>export function isAjaxRequest(req) {<br/>  const isXhr = req.xhr<br/>  const isJsonRequest = req.headers?.accept?.includes?.('json')<br/>  const isApiCall = /^\/api\//.test(req.url || '')<br/>  return isXhr || isApiCall || isJsonRequest<br/>}</span></pre><h2 id="18b3" class="mq ku iy bd kv mw mx dn kz my mz dp ld kg na nb lh kk nc nd ll ko ne nf lp ng bi translated">装饰者——实现错误类型</h2><p id="302d" class="pw-post-body-paragraph jv jw iy jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">能够通过装饰创建错误类型是重用这种装饰器模式最重要的好处。</p><p id="a2eb" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们可以通过指定错误的类型来消费错误:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="c6fa" class="mq ku iy mh b gy mr ms l mt mu">// server/errors/types/generic.js<br/>// This is just a plain decorator that parses the service response.<br/>export function GENERIC_SERVICE_ERROR(response, parsed) {<br/>  const { statusCode, body = {} } = response || {};<br/>  return {<br/>    status: statusCode &gt;= 300 ? statusCode : 500,<br/>    issue: body?.error?.issue<br/>  };<br/>}</span><span id="9af8" class="mq ku iy mh b gy mv ms l mt mu">// Usage:<br/>// new ServerError(cause, GENERIC_SERVICE_ERROR)</span></pre><p id="6f5d" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果这还不够，我们还可以使用<a class="ae lw" href="https://en.wikipedia.org/wiki/Encapsulation_(computer_programming)" rel="noopener ugc nofollow" target="_blank">封装</a>和<a class="ae lw" href="https://en.wikipedia.org/wiki/Composition_over_inheritance" rel="noopener ugc nofollow" target="_blank">组合</a>来创建错误的“类”(即不是实际的类):</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="c57e" class="mq ku iy mh b gy mr ms l mt mu">export function GenericServiceError(raw, ...decorators) {<br/>  return new ServerError(raw, GENERIC_SERVICE_ERROR, ...decorators)<br/>}<br/> <br/>export function GenericServiceErrorV2(raw, ...) {<br/>  return new GenericServiceError(raw, GENERIC_SERVICE_ERROR_V2, ...)<br/>}</span></pre><h2 id="c5b4" class="mq ku iy bd kv mw mx dn kz my mz dp ld kg na nb lh kk nc nd ll ko ne nf lp ng bi translated">合成—实现错误映射</h2><p id="704b" class="pw-post-body-paragraph jv jw iy jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">当我说“映射”时，我指的不是<code class="fe me mf mg mh b">new Map()</code>，我指的是 1:1 的<code class="fe me mf mg mh b">Object</code>，它将特定的服务响应转换或翻译成更通用的、客户端就绪的响应。</p><p id="9cfd" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">例如，<em class="ma">假设</em>用例将接收<code class="fe me mf mg mh b">error.issue="USER_BANNED"</code>，当然我们不能将此发送给客户端，因为攻击者可能会利用它来收集信息，所以我们将其转换为客户端错误:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="54dd" class="mq ku iy mh b gy mr ms l mt mu">USER_BANNED<!-- -->: {<br/>  status: 422,<br/>  issue: 'UNPROCESSABLE_ENTITY',<br/>  code: 'SEND_INVITE' <br/>}</span></pre><p id="37a2" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们可以通过创建一种叫做<strong class="jx iz"> <em class="ma">高阶装饰器</em> </strong>的新型装饰器来解决这个问题。高阶装饰器是一种可以返回其他装饰器的特殊类型的装饰器，它使用部分解析的数据将映射到<strong class="jx iz"> </strong>实际的装饰器。</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="49e9" class="mq ku iy mh b gy mr ms l mt mu">// server/errors/utils/createServerErrorMap.js<br/>export function createServerErrorMap(errorMap) {<br/>  return function higherOrderDecorator(raw, parsed) {<br/>    const { issue, name, code } = parsed;<br/>    const decorator =<br/>      errorMap[issue] ||<br/>      errorMap[name] ||<br/>      errorMap[code] ||<br/>      errorMap._default; // allow defaults<br/>    return decorator<br/>  };<br/>}</span></pre><p id="b22c" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">注意，<strong class="jx iz">错误类型是负责解析原始数据的类型，而错误映射在解析(易于阅读)的数据之上充当过滤器</strong>。</p><blockquote class="lx ly lz"><p id="4662" class="jv jw ma jx b jy jz ka kb kc kd ke kf mb kh ki kj mc kl km kn md kp kq kr ks ig bi translated">旁注:你可以把它作为一个<code class="fe me mf mg mh b"><em class="iy">static</em></code>方法移动到<code class="fe me mf mg mh b">ServerError</code>里面。</p></blockquote><p id="f3fa" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下面是一个示例地图:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="87eb" class="mq ku iy mh b gy mr ms l mt mu">// server/errors/maps/posts.js<br/>export const POSTS_ERROR_MAP = createServerErrorMap({<br/>  POST_CREATION_RESTRICTED: (raw, parsed) =&gt; ({<br/>    code: "UNPROCESSABLE_ENTITY",<br/>    status: 422 // Unprocessable Entity<br/>  }),<br/>  _default: {<br/>    status: 400,<br/>    code: "UNEXPECTED_RESPONSE",<br/>    clientData: { ... }<br/>  }<br/>});</span></pre><h1 id="fbed" class="kt ku iy bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">使用</h1><p id="6708" class="pw-post-body-paragraph jv jw iy jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">在我们的数据访问层中，我们将有一个调用服务并获得响应的方法，包括捕捉/抛出错误的逻辑，但不包括如何处理响应:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="e08e" class="mq ku iy mh b gy mr ms l mt mu">// server/models/posts.js<br/>export async function createPost(...) {<br/>  try {<br/>    const response = await api.request(...)</span><span id="a7d1" class="mq ku iy mh b gy mv ms l mt mu">    if (response.body.error || response.statusCode &gt;= 400) {<br/>      throw response;<br/>    }<br/>  } catch (error) {<br/>    throw new ServerError(error, GENERIC_SERVICE_ERROR);<br/>  }<br/>}</span></pre><p id="7a57" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如您所见，数据层知道可以抛出的错误的类型。这很重要，因为我们现在有了一种方法来解析这些错误，并把它们扔给控制器。然后，控制器可以将这些误差映射成客户端定相误差:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="1be4" class="mq ku iy mh b gy mr ms l mt mu">// -&gt; server/controllers/posts.js<br/>// :: [POST] /posts/create<br/>export async function createPost(req, res, next) {<br/>  try {<br/>    await postsModel.createPost();<br/>  } catch (cause) {<br/>    const error = new ServerError(cause, POSTS_ERROR_MAP);<br/>    return error.send(req, res, next);<br/>  }<br/>}</span></pre><p id="6e3e" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">或者，如果您使用<a class="ae lw" href="https://expressjs.com/en/guide/error-handling.html#writing-error-handlers" rel="noopener ugc nofollow" target="_blank"> ExpressJS 默认错误处理程序</a>，您可以:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="8570" class="mq ku iy mh b gy mr ms l mt mu">// -&gt; server/controllers/posts.js<br/>// :: [POST] /posts/create<br/>export async function createPost(req, res, next) {<br/>  try {<br/>    await postsModel.createPost();<br/>  } catch (cause) {<br/>    next(new ServerError(cause, POSTS_ERROR_MAP));<br/>  }<br/>}</span></pre></div><div class="ab cl nh ni hr nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ig ih ii ij ik"><p id="57b1" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这方面，我们可以看出我们的解决方案已经可以扩展到一个新的水平。拥有<strong class="jx iz">类型的</strong>错误和<strong class="jx iz">错误映射</strong>允许组合错误，并拥有一个可以不断增加的结构系统，其中模型和控制器不需要有特定的错误实现，只需要重用它。</p><p id="75c6" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">更具体地说，这种实现减少了组件的<a class="ae lw" href="https://en.wikipedia.org/wiki/Loose_coupling" rel="noopener ugc nofollow" target="_blank">耦合</a>，因为我们可以很容易地增强和替换装饰器，同时增加了其<a class="ae lw" href="https://techterms.com/definition/plugandplay" rel="noopener ugc nofollow" target="_blank"> <em class="ma">即插即用</em> </a> <em class="ma"> </em>的能力，因为您可以将问题映射到客户端理解的代码或动作，并且可以将其挂钩到流中。</p><p id="88ea" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">例如:<code class="fe me mf mg mh b">USER_NOT_FOUND</code>和<code class="fe me mf mg mh b">USER_NOT_SEARCHABLE</code>都可以映射/翻译成相同的代码<code class="fe me mf mg mh b">SEND_INVITE</code>，客户端理解该代码并为两者显示相同的用户体验，无论是否收到新的错误，我们都可以在服务器级别进行连接。</p><p id="0b04" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这就是装饰模式的力量。</p><h1 id="9e67" class="kt ku iy bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">操场</h1><figure class="mi mj mk ml gt ip"><div class="bz fp l di"><div class="no np l"/></div></figure></div></div>    
</body>
</html>