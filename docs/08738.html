<html>
<head>
<title>Linked List Cycle Problems</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">链表循环问题</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/linked-list-cycle-problems-73853a2e365c?source=collection_archive---------9-----------------------#2022-07-06">https://blog.devgenius.io/linked-list-cycle-problems-73853a2e365c?source=collection_archive---------9-----------------------#2022-07-06</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div class="gh gi jk"><img src="../Images/38261abd4581c93477fb8a3cdc418554.png" data-original-src="https://miro.medium.com/v2/resize:fit:1062/format:webp/0*gf7uNCts1yBk0SOO.jpg"/></div></figure><p id="2a7e" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">什么是链表中的循环？ <br/>如果链表中有某个节点可以通过继续跟随下一个指针再次到达，则链表中存在循环。</p><p id="2da4" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">定义单链接列表:</p><pre class="kp kq kr ks gt kt ku kv kw aw kx bi"><span id="093d" class="ky kz in ku b gy la lb l lc ld">class ListNode {<br/>   int val;<br/>   ListNode next;<br/>   ListNode(int x) {<br/>       val = x;<br/>       next = null;<br/>     }<br/> }</span></pre><p id="3106" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">本文分为两部分:</p><p id="d5c4" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">1.检测链接表中是否有循环</p><p id="5bcf" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">2.如果存在循环，则返回循环开始的节点。</p><p id="cd76" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io">第一部分:检测链接列表中的循环/循环</strong></p><p id="21e1" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">在 LinkedList 中有多种方法来检测一个循环，但是这里我们将使用龟兔赛跑方法。</p><h2 id="0a03" class="ky kz in bd le lf lg dn lh li lj dp lk kc ll lm ln kg lo lp lq kk lr ls lt lu bi translated">龟兔赛跑法:</h2><p id="c155" class="pw-post-body-paragraph jr js in jt b ju lv jw jx jy lw ka kb kc lx ke kf kg ly ki kj kk lz km kn ko ig bi translated">在这个方法中，我们将使用两个指针，一个慢速指针一次只移动一步，另一个快速指针一次移动两步。</p><p id="46ca" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">如果 LinkedList 中存在循环，那么这些指针将在一个点相遇，否则当慢速指针位于 LinkedList 的中间时，快速指针将为空。</p><p id="0920" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">请查找下面的代码，以检测单链接列表中的循环/循环:</p><pre class="kp kq kr ks gt kt ku kv kw aw kx bi"><span id="1370" class="ky kz in ku b gy la lb l lc ld">public class Solution {<br/>    public boolean hasCycle(ListNode head) {<br/>        if(head==null) return false;<br/>        ListNode h1=head,h2=head;<br/>        while(h1.next!=null &amp;&amp; h2.next!=null){<br/>            h1 = h1.next;<br/>            h2 = h2.next.next;<br/>            if(h1==h2) return true;<br/>            if(h1==null || h2==null) return false;<br/>        }<br/>        return false;<br/>    }<br/>}</span></pre><p id="b499" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">如果存在循环，则返回 TRUE，否则返回 FALSE。<br/>我们可以修改这段代码来返回两个指针相遇的节点，如下所示:</p><pre class="kp kq kr ks gt kt ku kv kw aw kx bi"><span id="e88f" class="ky kz in ku b gy la lb l lc ld">public class Solution {<br/>    public ListNode hasCycle(ListNode head) {<br/>        if(head==null) return null;<br/>        ListNode h1=head,h2=head;<br/>        while(h1.next!=null &amp;&amp; h2.next!=null){<br/>            h1 = h1.next;<br/>            h2 = h2.next.next;<br/>            if(h1==h2) return h1;<br/>            if(h1==null || h2==null) return null;<br/>        }<br/>        return false;<br/>    }<br/>}</span></pre><p id="16cd" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">如果存在循环，这将返回 not null ListNode，否则返回 null。</p><p id="5193" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">Leetcode 问题:<a class="ae ma" href="https://leetcode.com/explore/learn/card/linked-list/214/two-pointer-technique/1212/" rel="noopener ugc nofollow" target="_blank">链表循环</a></p><p id="93fd" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io">第二部分:返回循环开始的节点</strong></p><p id="e7fc" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">因此，如果 LinkedList 中有一个循环，那么我们知道快指针和慢指针在一个点(节点)相遇，我们可以使用上面的代码得到它们相遇的那个节点。</p><p id="efb9" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">现在我们的主要任务是寻找循环的开始节点，为此我们将使用<a class="ae ma" href="https://www.geeksforgeeks.org/floyds-cycle-finding-algorithm/" rel="noopener ugc nofollow" target="_blank">弗洛伊德循环寻找算法</a>。</p><p id="d1a8" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">假设:<br/>链表头到循环起点的距离为‘a’<br/>循环起点到两个指针交汇点的距离为‘b’<br/>两个指针交汇点到循环起点的距离为‘c’。</p><p id="a671" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">如下图所示:</p><figure class="kp kq kr ks gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi mb"><img src="../Images/0b4b42e72ee50bbbb9599bbe9e106853.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pVSA91FYmCa1TEhhNCrsdw.png"/></div></div></figure><p id="3ff2" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">因此，慢速指针移动的距离是= a+b <br/>,然而，快速指针移动的距离是= a+K(b+c)+b</p><p id="9455" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">其中的“K”是一个整数，表示快速指针在遇到慢速指针之前必须运行的整圈数。</p><p id="c176" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">当周期很小时，K 可以大于 1。</p><p id="3e47" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io">询问</strong>——为什么慢指针永远不会为了满足快指针而运行另一个周期？<br/><strong class="jt io">Ans</strong>——慢指针到达周期时，快指针已经在里面了。从快指针到慢指针的距离严格小于周期的长度，快指针移动的速度是慢指针的两倍。<br/>因此慢速指针不能超过循环的一半。</p><p id="05ea" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">我们知道，快速指针的移动速度是慢速指针的两倍，因此等式变为:</p><p id="3ecf" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">快速指针覆盖的距离== 2*(慢速指针覆盖的距离)</p><p id="21e3" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">a+K(b+c)+b = 2(a+b)<br/>K(b+c)= a+b<br/>a = K(b+c)-b<br/>a =(K—1)* b+K * c</p><p id="f315" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">如果我们要求 N = (K — 1)，那么 N 也是整数，那么<br/> a = N * b + (N + 1)* c <br/>或者<br/> a = c + N (b + c)</p><p id="d28d" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">其中 N(b+c)的有效位移始终为零，因为(b+c)代表循环，这意味着 0 位移。</p><p id="4fcf" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">这使得<strong class="jt io"> a=c </strong>。</p><p id="152f" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">因此，这意味着如果启动另外两个指针，一个从头开始，另一个从快指针和慢指针相遇的点开始，那么这两个指针相遇的节点将是循环的开始节点。</p><p id="dacc" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">示例:</p><figure class="kp kq kr ks gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi mg"><img src="../Images/d739a98f162808a6f7d674e7e5085647.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M99jc_1FHauffsLXMISB3A.jpeg"/></div></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk translated">例子</figcaption></figure><p id="4197" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">请在下面找到相同的代码:</p><pre class="kp kq kr ks gt kt ku kv kw aw kx bi"><span id="52b9" class="ky kz in ku b gy la lb l lc ld">public class Solution {<br/>    public ListNode detectCycle(ListNode head) {<br/>        if(head==null||head.next == null) return null;<br/>        ListNode h1=head,h2=head;<br/>        while(h1.next!=null &amp;&amp; h2.next!=null){<br/>            h1 = h1.next;<br/>            h2 = h2.next.next;<br/>            if(h1==h2) { //node where both pointers meet<br/>                h1 = head;<br/>                while (h1 !=h2) {<br/>                    h1 = h1.next;<br/>                    h2 = h2.next;<br/>                }<br/>                return h1;<br/>            }<br/>            if(h1==null || h2==null) return null;<br/>        }<br/>        return null;<br/>    }<br/>}</span></pre><p id="d771" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">Leetcode 问题:<a class="ae ma" href="https://leetcode.com/explore/learn/card/linked-list/214/two-pointer-technique/1214/" rel="noopener ugc nofollow" target="_blank">链表循环二</a></p><p id="c709" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io">参考文献</strong> : <br/> 1。<a class="ae ma" href="https://leetcode.com/explore/learn/card/linked-list/214/two-pointer-technique/1214/discuss/44774/Java-O(1)-space-solution-with-detailed-explanation." rel="noopener ugc nofollow" target="_blank"> Leetcode 讨论</a>解说-1 <br/> 2。<a class="ae ma" href="https://leetcode.com/problems/linked-list-cycle-ii/discuss/1701057/Do-note-that-some-answers-in-comment-section-is-actually-wrong" rel="noopener ugc nofollow" target="_blank"> Leetcode 讨论</a>解释-2 <br/> 3。<a class="ae ma" href="https://dev.to/alisabaj/floyd-s-tortoise-and-hare-algorithm-finding-a-cycle-in-a-linked-list-39af" rel="noopener ugc nofollow" target="_blank">龟兔算法</a></p><figure class="kp kq kr ks gt jo gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/7b7219562aee439ea1771f31cd27f406.png" data-original-src="https://miro.medium.com/v2/resize:fit:1034/format:webp/0*k0uToNmHZaqHMCQN.png"/></div></figure><p id="22d3" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">编码快乐！！！如果你喜欢这篇文章，请鼓掌。有任何疑问或建议吗？当然可以！！Ping 我:<br/>*<a class="ae ma" href="https://www.linkedin.com/in/rohitm17/" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>*<a class="ae ma" href="https://twitter.com/rohit_mittal17" rel="noopener ugc nofollow" target="_blank">Twitter</a><br/>*<a class="ae ma" href="https://github.com/rohitm17" rel="noopener ugc nofollow" target="_blank">GitHub</a><br/>*<a class="ae ma" href="https://medium.com/@rohitm17" rel="noopener">Medium</a></p></div></div>    
</body>
</html>