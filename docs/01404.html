<html>
<head>
<title>Intro to Swift Visual Formatting Language — The Good, The Bad, and The VFL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift可视化格式化语言简介——好的、坏的和VFL</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/intro-to-swift-vfl-the-good-the-bad-and-the-vfl-6e59abbe410d?source=collection_archive---------23-----------------------#2020-07-02">https://blog.devgenius.io/intro-to-swift-vfl-the-good-the-bad-and-the-vfl-6e59abbe410d?source=collection_archive---------23-----------------------#2020-07-02</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/></div><div class="ab cl jk jl hr jm" role="separator"><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp"/></div><div class="ig ih ii ij ik"><p id="c317" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">我记得早在2008年我第一次开始iOS开发时，我使用的是xib，当时一片混乱！界面构建器很难使用，而且社区很小。但是，嘿，基本的ui很容易实现——只需拖放就可以了。太神奇了。</p><p id="8363" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">我在创建应用程序时注意到，你的项目越复杂，UI创建就变得越困难。使用Interface Builder，在视图中拖放UI元素最终会导致内容重叠。当你试图整理东西时，你可能会拖动一个不同的UI元素，导致整个布局混乱。最终，您将得到一个界面构建器UI，并通过代码调整框架。</p><p id="5005" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">旋转手机时必须修改坐标和尺寸变得很麻烦(请注意，这只是一个单一尺寸的设备)。我有没有提到界面构建器在当时是如此的容易出错？我甚至还没有谈到我在与多个开发人员一起修改同一个Xib时所面临的问题。合并冲突太可怕了。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi kp"><img src="../Images/28668d41abf317a8614b2cf86c66c078.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/1*j6kqChMvYVcKtwWe4WuS2w.jpeg"/></div></figure><p id="ed05" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">由于我在拖放UI元素时面临的所有问题，我厌倦了，决定只用代码做所有的事情。起初我认为我做了一个错误的决定，但是在我使用编程式UI做了一些应用之后，我更加喜欢它了。您可以很容易地识别视图中的元素，并且对元素有更多的控制权(至少我是这样感觉的)。它还膨胀了ViewController，这是我愿意做出的牺牲。</p><p id="e235" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">那时候，为了布局一个元素，我们必须手动计算它的框架，开发和定位ui仍然是可管理的，因为你只有一个屏幕大小——一个屏幕大小🤯</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi kx"><img src="../Images/42cee39d49147bbf1c4e9a8390bb0cf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/1*kDj-oGdhk9yJX0IQD1w2Zg.jpeg"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">拥有一个单一的屏幕使它变得简单了一些</figcaption></figure><p id="b265" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">从编程角度来说，创建UI有其优点和缺点，在我看来，优点大于缺点。</p><p id="77c2" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">我在使用布局约束方面晚了几年。我记得是在2015年初，我第一次读到一个关于一个叫做VFL的新布局系统的帖子，因为我在管理不同的屏幕尺寸时遇到了困难。我想为什么不试试呢。</p></div><div class="ab cl jk jl hr jm" role="separator"><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp"/></div><div class="ig ih ii ij ik"><p id="5c77" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io">好人</strong></p><p id="6732" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">输入<strong class="jt io"><em class="lc">【VFL】</em></strong><em class="lc">或</em> <strong class="jt io"> <em class="lc">可视化格式化语言</em> </strong> <em class="lc">。</em>来自<a class="ae ld" href="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/ProgrammaticallyCreatingConstraints.html#//apple_ref/doc/uid/TP40010853-CH16-SW1" rel="noopener ugc nofollow" target="_blank">苹果的文档</a>:</p><blockquote class="le"><p id="750f" class="lf lg in bd lh li lj lk ll lm ln ko dk translated"><em class="lo">“可视化格式语言允许你使用类似ASCII艺术的字符串来定义你的约束。这提供了约束的可视化描述性表示。</em></p></blockquote><p id="3047" class="pw-post-body-paragraph jr js in jt b ju lp jw jx jy lq ka kb kc lr ke kf kg ls ki kj kk lt km kn ko ig bi translated">让我们列出一些使用VFL的利与弊。</p><p id="e7d6" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">优点:</p><ul class=""><li id="b2e0" class="lu lv in jt b ju jv jy jz kc lw kg lx kk ly ko lz ma mb mc bi translated">自动布局使用可视化格式语言将约束打印到控制台；因此，调试消息看起来非常类似于用于创建约束的代码。</li><li id="7237" class="lu lv in jt b ju md jy me kc mf kg mg kk mh ko lz ma mb mc bi translated">可视化格式语言允许您使用非常简洁的表达式一次创建多个约束。</li><li id="b34a" class="lu lv in jt b ju md jy me kc mf kg mg kk mh ko lz ma mb mc bi translated">可视化格式语言允许您仅创建有效的约束。</li></ul><p id="b8a3" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">缺点:</p><ul class=""><li id="533e" class="lu lv in jt b ju jv jy jz kc lw kg lx kk ly ko lz ma mb mc bi translated">某些约束(例如，纵横比、安全区域)无法使用可视化格式语言创建。</li><li id="aa0a" class="lu lv in jt b ju md jy me kc mf kg mg kk mh ko lz ma mb mc bi translated">编译器不会以任何方式验证字符串。您只能通过运行时测试来发现错误。</li></ul><p id="e9b3" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">VFL约束的一个例子</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi mi"><img src="../Images/53b509cf00113704719183fd419adcda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ILMeoWTtxao730QGMs6V3w.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">清单1-a:如何设置VFL约束的例子</figcaption></figure><p id="6ea1" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">让我们把事情分解一下。</p><p id="b8c9" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">为了创建VFL约束，我们需要使用</p><h2 id="758e" class="mn mo in bd mp mq mr dn ms mt mu dp mv kc mw mx my kg mz na nb kk nc nd ne nf bi translated"><em class="lo">nslayoutconstraint . constraints(with visual format:options:metrics:views)</em></h2><p id="76ca" class="pw-post-body-paragraph jr js in jt b ju ng jw jx jy nh ka kb kc ni ke kf kg nj ki kj kk nk km kn ko ig bi translated"><em class="lc">返回NSLayoutConstraints列表的</em>类方法。不要和<strong class="jt io"><em class="lc">NSLayoutConstraint(item:attribute:related by:to item:attribute:multiplier:constant)</em></strong></p><p id="fc2a" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">这给出了一个约束。</p><p id="bf78" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><em class="lc">nslayoutconstraint . constraints(with visual format:options:metrics:views)</em></p><p id="f06f" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">方法有4个主要参数:</p><blockquote class="nl nm nn"><p id="4066" class="jr js lc jt b ju jv jw jx jy jz ka kb no kd ke kf np kh ki kj nq kl km kn ko ig bi translated"><strong class="jt io"> withVisualFormat </strong>:约束的格式规范</p><p id="69ef" class="jr js lc jt b ju jv jw jx jy jz ka kb no kd ke kf np kh ki kj nq kl km kn ko ig bi translated"><strong class="jt io">选项</strong>:描述可视化格式字符串中所有对象的属性和布局方向的选项。</p><p id="4774" class="jr js lc jt b ju jv jw jx jy jz ka kb no kd ke kf np kh ki kj nq kl km kn ko ig bi translated"><strong class="jt io"> metrics </strong>:出现在可视化格式字符串中的常量字典。字典的键必须是视觉格式字符串中使用的字符串值。它们的值必须是<code class="fe nr ns nt nu b">NSNumber</code>对象。</p><p id="5e5a" class="jr js lc jt b ju jv jw jx jy jz ka kb no kd ke kf np kh ki kj nq kl km kn ko ig bi translated"><strong class="jt io">视图</strong>:可视化格式字符串中出现的视图的字典。这些键必须是在可视格式字符串中使用的字符串值，并且这些值必须是视图对象。</p></blockquote><p id="564a" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">这些参数在<a class="ae ld" href="https://developer.apple.com/documentation/uikit/nslayoutconstraint/1526944-constraints" rel="noopener ugc nofollow" target="_blank">苹果文档页面</a>有详细描述</p><p id="b83b" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">描述VFL的ASCII表示形式</p><pre class="kq kr ks kt gt nv nu nw nx aw ny bi"><span id="2bbd" class="mn mo in nu b gy nz oa l ob oc">// Main components of a VFL ascii<br/>// H:|[myView]|</span><span id="75a4" class="mn mo in nu b gy od oa l ob oc"><strong class="nu io">H</strong>          : orientation always followed by a colon(<strong class="nu io">:</strong>)<br/><strong class="nu io">|</strong>-first    : superview's leading<br/><strong class="nu io">[&lt;myView&gt;]</strong> : the element we wanted to layout. It is enclosed in brackets<br/><strong class="nu io">|</strong>-last     : superview's trailing</span></pre><p id="2b5a" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">这个简单的ASCII表示被转换成<em class="lc"> NSLayoutConstraints </em>，其表示方式如下:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi oe"><img src="../Images/581d9bf4e95d0d6b43dcdf856506ec6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NLeT2rNHyoxQFRMjwnqfAg.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">清单1-b: NSLayoutConstraint相当于清单1-a中的ascii表示</figcaption></figure><p id="cda5" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">我们已经可以看到VFL的不同和易用性。可读性得到了提高，更加简洁。</p><p id="8649" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">至少对我来说，阅读<code class="fe nr ns nt nu b">H:|[myView]|</code>比记忆<code class="fe nr ns nt nu b">myView.leading = superview.leading</code>和<code class="fe nr ns nt nu b">myView.trailing = superview.trailing</code>更容易</p><p id="4aa1" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">让我们举一个如何使用VFL的例子。</p><p id="f5f0" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">如果我们想要一个视图和它的超级视图一样大，那么我们可以在VFL中用两行简单的代码实现它。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi of"><img src="../Images/dde51f20b7a1e62eb9d7879cf28556ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HkoIFmu0kUOIbf5wlbuLZA.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">清单2-a:使“我的视图”适合其超级视图的简单约束</figcaption></figure><p id="c6f9" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">相当于为所有边实现NSLayoutConstraints。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi og"><img src="../Images/962fb927ed29c6ed1828dbb53f3c616a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5fQVYyLHKv21QZlsbYFiTA.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">清单2-b: NSLayoutConstraint相当于清单2-a中的ascii表示</figcaption></figure><p id="9a30" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">如果我们使用NSLayoutConstraint(如我们的示例清单2-b ),并且我们向视图添加更多的元素，约束管理会变得更加棘手、复杂和难以维护。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/bbfc8ee0367a1e4f0f453f09594d40bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1186/format:webp/1*3DvaYJWLcsHkkEHuusl2Hw.jpeg"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">一路VFL！</figcaption></figure></div><div class="ab cl jk jl hr jm" role="separator"><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp"/></div><div class="ig ih ii ij ik"><p id="7a1a" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io">坏的</strong></p><p id="0838" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">在我们开始之前，VFL，让我们看看硬币的另一面。让我们谈谈使用VFL时可能会遇到的头痛问题。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/c91e7d5808c7d1d001fdf401afe9bb24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*sASH166bueZups7G5R0thA.jpeg"/></div></figure><p id="1906" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io"> <em class="lc">首先也是最重要的</em> </strong>，在运行应用程序之前，我们无法发现我们是否做了一个糟糕的VFL布局。您只会在查看屏幕时遇到错误的VFL语法，因为它只在运行时有效😢你马上就会知道这是一个错误，因为它崩溃了。</p><p id="cbdd" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">让我给你举个例子:</p><pre class="kq kr ks kt gt nv nu nw nx aw ny bi"><span id="d762" class="mn mo in nu b gy nz oa l ob oc">let’s say you have a view which is very deep in the view stack like 5 click deep (if I were you, I would rethink the UX if it’s that deep)or you need to wait for some special condition before the view appears and on that view you encounter a breakage in your VFL then you need to do it all over again. </span></pre><p id="d43f" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io"> <em class="lc">其次</em> </strong>，VFL不考虑器件的凹口。所以处理安全区域需要不同的处理方式。如果我工作的屏幕是在UINavigationController或UITabBarController中的<strong class="jt io">而不是</strong>,那么我使用</p><pre class="kq kr ks kt gt nv nu nw nx aw ny bi"><span id="5685" class="mn mo in nu b gy nz oa l ob oc"><em class="lc">NSLayoutConstraint(item:attribute:relatedBy:toItem:attribute:multiplier:constant)</em></span></pre><p id="2ff1" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">来设置我的顶部和底部约束。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi oj"><img src="../Images/bb2e638167c32f47231b4018ace29ee1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q8JDrBCyV8llUBKV7ivYyg.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">清单3:设置安全的顶部和底部约束(这些还没有激活)</figcaption></figure><p id="a654" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io"> <em class="lc">最后一点</em> </strong>，让所有人都不愿使用编程UI创建的一点是，它会使视图创建过程变得臃肿。视图中有很多实体意味着有很多约束——如果你已经在使用手动约束，那么你会喜欢VFL，它肯定会减少你的布局代码。</p><p id="5ff3" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">使用VFL可能会有其他的问题，但对我来说，这三件事是让你不爱VFL的主要原因。</p></div><div class="ab cl jk jl hr jm" role="separator"><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp"/></div><div class="ig ih ii ij ik"><h2 id="22b0" class="mn mo in bd mp mq mr dn ms mt mu dp mv kc mw mx my kg mz na nb kk nc nd ne nf bi translated">VFL</h2><p id="9010" class="pw-post-body-paragraph jr js in jt b ju ng jw jx jy nh ka kb kc ni ke kf kg nj ki kj kk nk km kn ko ig bi translated">为了举例说明VFL的基本用法，让我们创建一个基本的登录屏幕。</p><p id="570e" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">登录屏幕将包含以下内容:</p><ul class=""><li id="6272" class="lu lv in jt b ju jv jy jz kc lw kg lx kk ly ko lz ma mb mc bi translated">欢迎标题</li><li id="42f6" class="lu lv in jt b ju md jy me kc mf kg mg kk mh ko lz ma mb mc bi translated">常规文本字段</li><li id="e5b0" class="lu lv in jt b ju md jy me kc mf kg mg kk mh ko lz ma mb mc bi translated">安全文本字段</li><li id="9165" class="lu lv in jt b ju md jy me kc mf kg mg kk mh ko lz ma mb mc bi translated">登录按钮</li></ul><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="ok ol l"/></div></figure><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi om"><img src="../Images/c011d61703e2047551c03735587eb87e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1082/format:webp/1*wEReKz497F0bGO53hyO97w.jpeg"/></div></figure><p id="00bd" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">我就说到这里，让你消化一下。这只是我对VFL的介绍。我使用VFL已经5年多了，我已经学会了如何喜欢它的怪癖，就像有人喜欢XIB的怪癖一样🤢</p><p id="359e" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">我将为高级VFL创建创建另一个内容，包括谓词、优先级、选项等。</p><p id="44dc" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">完整的代码你可以在这里找到<a class="ae ld" href="https://github.com/joshuaLareta/vfllogin" rel="noopener ugc nofollow" target="_blank"/>。</p></div></div>    
</body>
</html>