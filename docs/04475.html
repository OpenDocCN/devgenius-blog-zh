<html>
<head>
<title>Leetcode 1797. Design Authentication Manager — Biweekly Contest 48</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Leetcode 1797。设计认证经理—双周竞赛48</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/leetcode-1797-design-authentication-manager-biweekly-contest-48-8ef4d82a220d?source=collection_archive---------4-----------------------#2021-03-21">https://blog.devgenius.io/leetcode-1797-design-authentication-manager-biweekly-contest-48-8ef4d82a220d?source=collection_archive---------4-----------------------#2021-03-21</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="565f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">今天，我们将解决名为认证管理器的问题。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/948ac3edd8422030647070c2f66e64a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*07VOc5BSj2PEQS5CrDySkQ.png"/></div></div></figure></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><h1 id="2438" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">问题陈述</h1><p id="b69f" class="pw-post-body-paragraph jk jl in jm b jn lz jp jq jr ma jt ju jv mb jx jy jz mc kb kc kd md kf kg kh ig bi translated">有一个使用身份验证令牌的身份验证系统。对于每个会话，用户将收到一个新的身份验证令牌，该令牌将在<code class="fe me mf mg mh b">currentTime</code>后的<code class="fe me mf mg mh b">timeToLive</code>秒到期。如果令牌被更新，则到期时间将<strong class="jm io">延长</strong>到(可能不同)<code class="fe me mf mg mh b">currentTime</code>后<code class="fe me mf mg mh b">timeToLive</code>秒到期。</p><p id="15b7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">实现<code class="fe me mf mg mh b">AuthenticationManager</code>类:</p><ul class=""><li id="76e0" class="mi mj in jm b jn jo jr js jv mk jz ml kd mm kh mn mo mp mq bi translated"><code class="fe me mf mg mh b">AuthenticationManager(int timeToLive)</code>构造<code class="fe me mf mg mh b">AuthenticationManager</code>并设置<code class="fe me mf mg mh b">timeToLive</code>。</li><li id="a3b7" class="mi mj in jm b jn mr jr ms jv mt jz mu kd mv kh mn mo mp mq bi translated"><code class="fe me mf mg mh b">generate(string tokenId, int currentTime)</code>在给定的<code class="fe me mf mg mh b">currentTime</code>秒内用给定的<code class="fe me mf mg mh b">tokenId</code>生成新令牌。</li><li id="6f52" class="mi mj in jm b jn mr jr ms jv mt jz mu kd mv kh mn mo mp mq bi translated"><code class="fe me mf mg mh b">renew(string tokenId, int currentTime)</code>在给定的<code class="fe me mf mg mh b">currentTime</code>以秒为单位用给定的<code class="fe me mf mg mh b">tokenId</code>更新<strong class="jm io">未到期的</strong>令牌。如果给定的<code class="fe me mf mg mh b">tokenId</code>没有未到期的令牌，则请求被忽略，并且什么也不发生。</li><li id="19c5" class="mi mj in jm b jn mr jr ms jv mt jz mu kd mv kh mn mo mp mq bi translated"><code class="fe me mf mg mh b">countUnexpiredTokens(int currentTime)</code>返回给定当前时间未到期的<strong class="jm io">令牌的数量。</strong></li></ul><p id="4cd4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">注意，如果令牌在时间<code class="fe me mf mg mh b">t</code>到期，并且另一个动作在时间<code class="fe me mf mg mh b">t</code> ( <code class="fe me mf mg mh b">renew</code>或<code class="fe me mf mg mh b">countUnexpiredTokens</code>)发生，则到期发生在其他动作的之前的<strong class="jm io">。</strong></p><p id="96a9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">例1: </strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/abdf39f852ed14d146d486b229527418.png" data-original-src="https://miro.medium.com/v2/resize:fit:1342/format:webp/0*1Y6t5cu5ErfvENYp.png"/></div></figure><pre class="kj kk kl km gt mx mh my mz aw na bi"><span id="a80c" class="nb lc in mh b gy nc nd l ne nf"><strong class="mh io">Input</strong><br/>["AuthenticationManager", "<!-- -->renew<!-- -->", "generate", "<!-- -->countUnexpiredTokens<!-- -->", "generate", "<!-- -->renew<!-- -->", "<!-- -->renew<!-- -->", "<!-- -->countUnexpiredTokens<!-- -->"]<br/>[[5], ["aaa", 1], ["aaa", 2], [6], ["bbb", 7], ["aaa", 8], ["bbb", 10], [15]]<br/><strong class="mh io">Output</strong><br/>[null, null, null, 1, null, null, null, 0]</span><span id="9755" class="nb lc in mh b gy ng nd l ne nf"><strong class="mh io">Explanation</strong><br/>AuthenticationManager authenticationManager = new AuthenticationManager(5); // Constructs the AuthenticationManager with <!-- -->timeToLive<!-- --> = 5 seconds.<br/>authenticationManager.<!-- -->renew<!-- -->("aaa", 1); // No token exists with tokenId "aaa" at time 1, so nothing happens.<br/>authenticationManager.generate("aaa", 2); // Generates a new token with tokenId "aaa" at time 2.<br/>authenticationManager.<!-- -->countUnexpiredTokens<!-- -->(6); // The token with tokenId "aaa" is the only unexpired one at time 6, so return 1.<br/>authenticationManager.generate("bbb", 7); // Generates a new token with tokenId "bbb" at time 7.<br/>authenticationManager.<!-- -->renew<!-- -->("aaa", 8); // The token with tokenId "aaa" expired at time 7, and 8 &gt;= 7, so at time 8 the <!-- -->renew<!-- --> request is ignored, and nothing happens.<br/>authenticationManager.<!-- -->renew<!-- -->("bbb", 10); // The token with tokenId "bbb" is unexpired at time 10, so the <!-- -->renew<!-- --> request is fulfilled and now the token will expire at time 15.<br/>authenticationManager.<!-- -->countUnexpiredTokens<!-- -->(15); // The token with tokenId "bbb" expires at time 15, and the token with tokenId "aaa" expired at time 7, so currently no token is unexpired, so return 0.</span></pre><p id="3269" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">约束:</strong></p><ul class=""><li id="4352" class="mi mj in jm b jn jo jr js jv mk jz ml kd mm kh mn mo mp mq bi translated"><code class="fe me mf mg mh b">1 &lt;= timeToLive &lt;= 108</code></li><li id="aab9" class="mi mj in jm b jn mr jr ms jv mt jz mu kd mv kh mn mo mp mq bi translated"><code class="fe me mf mg mh b">1 &lt;= currentTime &lt;= 108</code></li><li id="f27f" class="mi mj in jm b jn mr jr ms jv mt jz mu kd mv kh mn mo mp mq bi translated"><code class="fe me mf mg mh b">1 &lt;= tokenId.length &lt;= 5</code></li><li id="6a88" class="mi mj in jm b jn mr jr ms jv mt jz mu kd mv kh mn mo mp mq bi translated"><code class="fe me mf mg mh b">tokenId</code>只由小写字母组成。</li><li id="af8c" class="mi mj in jm b jn mr jr ms jv mt jz mu kd mv kh mn mo mp mq bi translated">所有对<code class="fe me mf mg mh b">generate</code>的调用将包含<code class="fe me mf mg mh b">tokenId</code>的唯一值。</li><li id="0eca" class="mi mj in jm b jn mr jr ms jv mt jz mu kd mv kh mn mo mp mq bi translated">所有函数调用中的<code class="fe me mf mg mh b">currentTime</code>值将为<strong class="jm io">严格递增</strong>。</li><li id="5f79" class="mi mj in jm b jn mr jr ms jv mt jz mu kd mv kh mn mo mp mq bi translated">最多<code class="fe me mf mg mh b">2000</code>调用所有函数的组合。</li></ul></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><h1 id="e044" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">解决办法</h1><p id="e96c" class="pw-post-body-paragraph jk jl in jm b jn lz jp jq jr ma jt ju jv mb jx jy jz mc kb kc kd md kf kg kh ig bi translated">这是设计问题。我们需要创建一个AuthenticationManager。上面的问题陈述中给出了要求。一旦我们阅读了需求，我们就可以着手解决方案。我们将讨论解决这个问题的整个想法，然后，我们将研究所有的方法。</p><p id="8fb0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了跟踪每个<code class="fe me mf mg mh b">tokenId</code>的<code class="fe me mf mg mh b">tokenId </code>和<code class="fe me mf mg mh b">expirationTime </code>，我们将使用一个<code class="fe me mf mg mh b">HashMap</code>。我们将把<code class="fe me mf mg mh b">tokenId </code>存储为键，把<code class="fe me mf mg mh b">expirationTime </code>存储为值。</p><ul class=""><li id="e4b6" class="mi mj in jm b jn jo jr js jv mk jz ml kd mm kh mn mo mp mq bi translated"><code class="fe me mf mg mh b">AuthenticationManager </code> —我们初始化<code class="fe me mf mg mh b">HashMap </code>和<code class="fe me mf mg mh b">timeToLive</code>(到期时间)。</li><li id="0b51" class="mi mj in jm b jn mr jr ms jv mt jz mu kd mv kh mn mo mp mq bi translated"><code class="fe me mf mg mh b">generate </code> —生成新令牌。到期时间应该是<code class="fe me mf mg mh b">currentTime+timeToLive</code>。</li><li id="5ed1" class="mi mj in jm b jn mr jr ms jv mt jz mu kd mv kh mn mo mp mq bi translated"><code class="fe me mf mg mh b">renew </code> —如果令牌未过期，它会续订令牌。如果没有过期，那么我们可以将<code class="fe me mf mg mh b">expirationTime </code>更新为<code class="fe me mf mg mh b">currentTime+timeToLive</code>。</li><li id="e069" class="mi mj in jm b jn mr jr ms jv mt jz mu kd mv kh mn mo mp mq bi translated"><code class="fe me mf mg mh b">countUnexpiredTokens </code> —我们必须计算未到期的令牌。因此，为了方便起见，我们还将删除过期的令牌(所有函数调用中的<code class="fe me mf mg mh b">currentTime</code>的值将是<strong class="jm io">严格递增的</strong>)并返回有效令牌的大小(未过期)。</li></ul><p id="a352" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下面给出了java代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="ef9e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">复杂性分析(时间复杂性)</strong></p><ul class=""><li id="c42b" class="mi mj in jm b jn jo jr js jv mk jz ml kd mm kh mn mo mp mq bi translated"><code class="fe me mf mg mh b">AuthenticationManager </code> — O(1)</li><li id="6a6f" class="mi mj in jm b jn mr jr ms jv mt jz mu kd mv kh mn mo mp mq bi translated"><code class="fe me mf mg mh b">generate </code> — O(1)</li><li id="c8b6" class="mi mj in jm b jn mr jr ms jv mt jz mu kd mv kh mn mo mp mq bi translated"><code class="fe me mf mg mh b">renew </code> —O(1)</li><li id="a290" class="mi mj in jm b jn mr jr ms jv mt jz mu kd mv kh mn mo mp mq bi translated"><code class="fe me mf mg mh b">countUnexpiredTokens </code> — O(n)</li></ul><p id="9131" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">复杂性分析(空间复杂性)</strong></p><p id="ffe7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">O(n)因为我们用的是<code class="fe me mf mg mh b">HashMap</code>。</p><p id="fd4b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">代码可以在下面的存储库中找到。</p><div class="nj nk gp gr nl nm"><a href="https://github.com/sksaikia/LeetCode/blob/main/src/LC1701_1800/LC1797.java" rel="noopener  ugc nofollow" target="_blank"><div class="nn ab fo"><div class="no ab np cl cj nq"><h2 class="bd io gy z fp nr fr fs ns fu fw im bi translated">sksaikia/LeetCode</h2><div class="nt l"><h3 class="bd b gy z fp nr fr fs ns fu fw dk translated">在GitHub上创建一个帐户，为sksaikia/LeetCode开发做贡献。</h3></div><div class="nu l"><p class="bd b dl z fp nr fr fs ns fu fw dk translated">github.com</p></div></div><div class="nv l"><div class="nw l nx ny nz nv oa ks nm"/></div></div></a></div></div></div>    
</body>
</html>