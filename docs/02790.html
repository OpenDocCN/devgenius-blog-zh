<html>
<head>
<title>7 tips how to minimalize size of your webpack bundle</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何最小化你的网络包的 7 个技巧</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/7-tips-how-to-minimalize-size-of-your-webpack-bundle-e9e4bec63de4?source=collection_archive---------7-----------------------#2020-08-30">https://blog.devgenius.io/7-tips-how-to-minimalize-size-of-your-webpack-bundle-e9e4bec63de4?source=collection_archive---------7-----------------------#2020-08-30</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="85dd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在我的上一篇文章中，我写了关于获得您的包可能包含的内容的概述。这里可以看<a class="ae ki" href="https://medium.com/dev-genius/have-you-ever-wondered-what-is-in-your-cra-webpack-bundle-76d38ba4317a" rel="noopener">。</a></p><p id="6320" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在我们已经对您的包有了更深入的了解，我们可以<em class="kj">使用它</em>并尝试减少我们打包代码的大小。下面的文字包括我的<strong class="jm io">技巧和诀窍</strong>如何找到罪魁祸首，并减少网络打包包的大小。</p><p id="42a6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">冗余库</strong></p><p id="3940" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我认为这是一个很容易遵循的规则。找一个你不用的库。你可能知道一个 webpack 非常聪明，它使用了一个叫做<em class="kj">“树摇动”的工具。这意味着如果你在你的 package.json 中引用了这个库，但是你没有在你的代码中使用它，这个库将不会被添加到最终的包中。</em></p><p id="c5f9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然而，如果你<em class="kj">忘记</em>并在将来的某个地方使用这个包呢？无意中。你知道，这总是同一个老故事。因此，移除任何闲置的依赖关系以避免任何可能的意外错误似乎是合理的。</p><p id="6179" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">未充分利用的库</strong></p><p id="3b60" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">搜索你很少使用的库可能是很麻烦的任务。但这是值得做的。实际上，我会将它与<strong class="jm io">低挂 frui </strong> t 进行比较。</p><p id="d46c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">例如，在最近的一次任务中，我发现我们在我的一个项目中试验了 Luxon JS 库。我们只利用了它的一个函数来提供日期格式。因此，这是一个相当容易的决定。在移除包并用 MomentJS 的代码替换它之后，我们又将大小减少了几百千字节。</p><p id="1116" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">用你的代码替换你的库。</p><p id="6d67" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">偶尔，你会发现一个库函数可以很容易地被你自己的代码的三行代码代替。</p><p id="2525" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我想指出的是，上述方法一直备受争议。这有点违背众所周知的原则:“不要重新发明轮子。”这就是为什么我要在文章的最后详细阐述它。</p><p id="6e20" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">激进的方法</strong></p><p id="e194" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有时，您可能会削减少量的应用程序功能。也许，乍一看，这没有意义，但这种方法绝对值得一试。</p><p id="8108" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">例如，在我们的项目中，我们使用散列函数以“<em class="kj">加密的</em>”形式发送密码。它稍微增强了安全性。这种特殊技术的作者声称非常轻微。</p><p id="f52c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然而，它需要加密功能。因此，我删除了功能以及相关的库。并且，<em class="kj">突然</em>，我将最终大小的包减少了 300 千字节。</p><p id="33f6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这种情况下，我更喜欢保持<strong class="jm io">包较小的尺寸</strong>，而不是增加高度投机的安全特性。</p><p id="dfff" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">对你进口的东西进行精选。</strong></p><p id="eb01" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">由于上面提到的摇树机制，webpack 会删除你没有用过的代码。</p><p id="5ced" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们看一个很好的例子——来自 Google 的 MaterialUI。MaterialUI 是一个大型组件库。</p><p id="2b00" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">假设您有以下声明:</p><pre class="kk kl km kn gt ko kp kq kr aw ks bi"><span id="43d5" class="kt ku in kp b gy kv kw l kx ky">import { Button, TextField } from "@material-ui/core";</span></pre><p id="1e0f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">并且您将只使用<em class="kj">按钮</em>—<em class="kj">文本字段</em>将自动<strong class="jm io">省略</strong>。</p><p id="305d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">正如您在这里看到的:</p><figure class="kk kl km kn gt la gh gi paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="gh gi kz"><img src="../Images/b4950702b567804c6a2549b7533f3909.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3BKN2O7p47LDn4kd30q93A.png"/></div></div></figure><p id="4093" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">只有 33.29 KB 的 MaterialUI。</p><p id="71be" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">即使你写了这样一段代码:</p><pre class="kk kl km kn gt ko kp kq kr aw ks bi"><span id="f4cb" class="kt ku in kp b gy kv kw l kx ky">import * as all from {component}</span></pre><p id="8c94" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">它将仅仅执行您已经包含在代码中的那些组件的物理导入。你用过<em class="kj">无</em>吗？然后你的包里就没有<strong class="jm io">material ui 的</strong>标志了。</p><p id="2dd5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">就我个人而言，我觉得这种技术相当危险。库的作者可能很容易滥用全局状态，使库不可分。在这种情况下，树摇动机制没有机会识别出需要一个组件。在最好的情况下，这可能会导致构建崩溃。或者在最坏的情况下出现故障的应用程序<em class="kj">。</em></p><p id="76e4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然而，我坚信这在标准的公共图书馆中是一件罕见且不可能发生的事情。</p><p id="b2dd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">卫星图书馆</strong>。</p><p id="f93a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">偶尔，npm 库包含"<em class="kj">僚机</em>"MomentJS 因为包含了大量的本地化库而臭名昭著。除非您想要这些库，否则不要把它们放在包中。</p><p id="0397" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">要删除这些不必要的依赖项，请参考文章:</p><p id="0d2e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae ki" href="https://www.tutorialspoint.com/how-to-prevent-moment-js-from-loading-locales-with-webpack" rel="noopener ugc nofollow" target="_blank">https://www . tutorialspoint . com/how-to-prevent-moment-js-from-loading-locales-with-web pack</a></p><p id="9ff7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">请考虑到这一点，并确保您只使用 NPM 软件包的特定部分，这是你真正需要的。这些僚机是<strong class="jm io">定期巨大的图书馆</strong>。</p><p id="0969" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">代码拆分</strong></p><p id="5998" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">不幸的是，这不是你可以推迟到项目结束。更多的是一种<strong class="jm io">心态</strong>而不是在完成产品后或者优化阶段玩的把戏。此外，它带来了额外的复杂性和问题。</p><p id="3cae" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在我看来，代码分割是最后的手段。然而，对于规模不断增长的长期运行项目，这可能是您一直在寻找的<em class="kj">补救措施</em>。</p><p id="91d2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">旁注——用库代替你自己的代码。</p><p id="8539" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在 JS 行业，许多人倾向于坚持一条规则——<em class="kj">永远不要重新发明轮子</em>。换句话说，如果有人编写了一个库来处理一个问题，你最好使用 3d party 解决方案，而不是编写自己的解决方案。</p><p id="be4d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">事实上，许多开发人员和思想领袖认为这是一个完全有效的观点，花时间写了大量文章来支持他们的立场。</p><p id="ed74" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一方面，这种方法似乎完全合乎逻辑，令人信服。但是你还记得<strong class="jm io">向左</strong>的问题吗？如果你还没有听说过它，请阅读下面这篇很棒的文章，它有一个真正解释的名字。:)</p><p id="b207" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="kj">“一个开发人员如何在 11 行 JavaScript 代码中破坏 Node、Babel 和数千个项目。”</em></p><p id="4db7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae ki" href="https://www.theregister.com/2016/03/23/npm_left_pad_chaos/" rel="noopener ugc nofollow" target="_blank">https://www.theregister.com/2016/03/23/npm_left_pad_chaos/</a></p><p id="805c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">不幸的是，作为一个群体，我们还没有变得<em class="kj">开明</em>。</p><p id="2aa4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">鉴于“<em class="kj"> PadLeft </em>”案例，当我发现“<em class="kj"> IsEven </em>”库时，我真的很惊讶。</p><p id="7e6a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">就在上个月，我偶然发现了那个图书馆。它告诉你一个数是否是偶数。正如我们所有人可能都知道的那样，使用基本的算术运算编写一行代码来检查一个特定的数字是否是偶数就足够了。</p><p id="405e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但这并不是结束。NPM 模块对名为 IsOdd 的库有一个额外的依赖，而且，它还与名为 IsNumber 的库相关。</p><p id="3b5d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">毫无疑问，这些图书馆注定是一个笑话。然而，老实说，这已经成了一个非常恶毒的笑话，因为到目前为止已经有一百万个包被下载了。很明显，很多人没有理解这个笑话，掉进了陷阱。:)我怀疑你很少能找到像这个例子中这样极端的原则。库的作者应该包括一个免责声明。</p><p id="3106" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">总之，每当你想添加一些新的、闪亮的库时，请小心。有时候用自己的代码可以更好的解决<strong class="jm io"/><strong class="jm io">。</strong></p></div></div>    
</body>
</html>