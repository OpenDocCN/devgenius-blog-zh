<html>
<head>
<title>Memory Management and Garbage Collection</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">内存管理和垃圾收集</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/memory-management-and-garbage-collection-3b9660ccf7ba?source=collection_archive---------7-----------------------#2020-07-27">https://blog.devgenius.io/memory-management-and-garbage-collection-3b9660ccf7ba?source=collection_archive---------7-----------------------#2020-07-27</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="ceda" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">JavaScript如何将复杂的内存管理变得神奇</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/9f777bf984dbf078b82ea0f66a4c43af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*JXf9AOZbZUPWomYz"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">由<a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae ks" href="https://unsplash.com/@loravisuals?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> L O R A </a>拍摄的照片</figcaption></figure><p id="d62b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi lp translated"><span class="l lq lr ls bm lt lu lv lw lx di">在像C和C++这样的编程语言中，有两种类型的内存分配:静态和动态。静态内存分配是在我们创建一个固定大小的全局或局部变量时发生的。程序启动时分配一次，直到应用程序结束执行才释放。C和C++中的例子包括类型化变量和数组。另一种是动态内存分配。我们可以使用malloc()创建任何大小的“对象”，并且它们包含的字节数可以在运行时使用realloc()来更改。我们可以使用free()手动释放这样分配的内存。</span></p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ly"><img src="../Images/1d1ffbbb9685c8e586565816624633bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xxe8V-CC7ewyO9xMl6sGRQ.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">C语言中动态内存分配的一个例子</figcaption></figure><p id="2dbe" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这些事情会造成不可预见的内存泄漏和复杂性，比如需要知道变量(静态)和指针(动态)之间的区别，或者数组(固定长度)和链表(大小可以动态变化)之间的区别。人们使用C和C++已经有很长一段时间了，这些语言可能不会很快消失，但幸运的是，今天许多语言从程序员那里抽象出了这些概念。</p></div><div class="ab cl lz ma hr mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ig ih ii ij ik"><p id="de93" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi lp translated">Java、C#、JavaScript和Ruby等语言使用一种称为垃圾收集的系统，将所有这些东西从程序员那里抽象出来。JS中的收集器使用了一些方法。尽管如此，基本思想还是被称为内存周期:我们分配内存，程序使用内存，然后当不再需要内存时，垃圾收集器释放内存。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mg"><img src="../Images/a83798e5de225dbb4b19b9e9d0362b69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U9F1Bv9VoQnEJY0xHDxzkg.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">内存生命周期</figcaption></figure><p id="5030" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">当变量、对象或函数被创建时，JavaScript自动分配内存。垃圾收集器寻找一个好的理由在运行时释放这些内存，有一些算法可以帮助实现这个目标。</p></div><div class="ab cl lz ma hr mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ig ih ii ij ik"><h1 id="042e" class="mh mi in bd mj mk ml mm mn mo mp mq mr jt ms ju mt jw mu jx mv jz mw ka mx my bi translated">引用计数垃圾收集</h1><p id="9e5d" class="pw-post-body-paragraph kt ku in kv b kw mz jo ky kz na jr lb lc nb le lf lg nc li lj lk nd lm ln lo ig bi translated">引用计数垃圾收集是最简单的垃圾收集方法。它检查的不是某个对象是否仍然需要，而是其他变量或对象是否包含对它的引用。如果对该项目的引用数为零，则该项被确定为“垃圾”并被收集。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ne"><img src="../Images/a6205f69198af7d5eee486bfcd816942.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4MzICp5gSgzIcLPkWP9yLA.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">示例1</figcaption></figure><p id="6db3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">然而，这种方法有其局限性。如果我们在一个函数的作用域中创建两个变量，并将其中一个属性设置为与另一个对象相同。当我们调用这个函数时，程序为这两个对象分配内存。尽管如此，由于它们是循环引用的，即它们相互引用，所以使用引用计数算法的垃圾收集器不会将这些对象标记为垃圾，因为它们仍然有引用，即使程序离开了函数的作用域！我们现在有一个问题，如果我们调用这样的函数很多次，这是一个巨大的内存泄漏！</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nf"><img src="../Images/e3d384a3e9410871225207a7f367a060.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YyU7FiIU8XtGB6VR2aGJfw.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">示例2 —循环引用</figcaption></figure></div><div class="ab cl lz ma hr mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ig ih ii ij ik"><h1 id="dfbf" class="mh mi in bd mj mk ml mm mn mo mp mq mr jt ms ju mt jw mu jx mv jz mw ka mx my bi translated">标记-扫描算法</h1><p id="643d" class="pw-post-body-paragraph kt ku in kv b kw mz jo ky kz na jr lb lc nb le lf lg nc li lj lk nd lm ln lo ig bi translated">第二种更聪明的算法被称为标记-清除算法。一旦变量不可达，标记和清除将释放内存，而不是天真地计算对对象或变量的简单引用，就像我们的第二个循环引用变量的情况一样。顾名思义，这是一个两遍算法，首先将对象标记为删除，然后在第二遍中“清除”内存。</p><p id="7cc4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这里的核心概念是<em class="ng">可达性。</em>根据定义，有一组变量是可到达的，并且垃圾收集不会删除它们:根变量。这些变量包括当前函数的局部变量/参数、现有函数调用链中其他函数的变量/参数以及全局变量。如果一个非根变量被任何一个根变量引用，那么它就是可达的。这样，一旦变量超出范围，它就不再是根变量，并被标记为垃圾收集。</p></div><div class="ab cl lz ma hr mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ig ih ii ij ik"><p id="8d2a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi lp translated"><span class="l lq lr ls bm lt lu lv lw lx di">总之，</span>尽管我们无法控制在高级语言中如何以及何时分配/释放内存，但垃圾收集的魔力让程序员少了一件担心的事情，即使只是以一种次要的方式。</p><h2 id="55e8" class="nh mi in bd mj ni nj dn mn nk nl dp mr lc nm nn mt lg no np mv lk nq nr mx ns bi translated">来源:</h2><div class="nt nu gp gr nv nw"><a href="https://dzone.com/articles/memory-management-and-garbage-collection-in-javasc" rel="noopener  ugc nofollow" target="_blank"><div class="nx ab fo"><div class="ny ab nz cl cj oa"><h2 class="bd io gy z fp ob fr fs oc fu fw im bi translated">JavaScript中的内存管理和垃圾收集— DZone Web Dev</h2><div class="od l"><h3 class="bd b gy z fp ob fr fs oc fu fw dk translated">JavaScript中的内存管理和垃圾收集是一个有点陌生的话题，因为在JavaScript中我们不…</h3></div><div class="oe l"><p class="bd b dl z fp ob fr fs oc fu fw dk translated">dzone.com</p></div></div><div class="of l"><div class="og l oh oi oj of ok km nw"/></div></div></a></div><div class="nt nu gp gr nv nw"><a href="https://javascript.info/garbage-collection" rel="noopener  ugc nofollow" target="_blank"><div class="nx ab fo"><div class="ny ab nz cl cj oa"><h2 class="bd io gy z fp ob fr fs oc fu fw im bi translated">碎片帐集</h2><div class="od l"><h3 class="bd b gy z fp ob fr fs oc fu fw dk translated">JavaScript中的内存管理是自动执行的，对我们来说是不可见的。我们创造基本元素，物体…</h3></div><div class="oe l"><p class="bd b dl z fp ob fr fs oc fu fw dk translated">javascript.info</p></div></div><div class="of l"><div class="ol l oh oi oj of ok km nw"/></div></div></a></div><div class="nt nu gp gr nv nw"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management" rel="noopener  ugc nofollow" target="_blank"><div class="nx ab fo"><div class="ny ab nz cl cj oa"><h2 class="bd io gy z fp ob fr fs oc fu fw im bi translated">内存管理</h2><div class="od l"><h3 class="bd b gy z fp ob fr fs oc fu fw dk translated">像C这样的低级语言有手工内存管理原语，比如malloc()和free()。相比之下…</h3></div><div class="oe l"><p class="bd b dl z fp ob fr fs oc fu fw dk translated">developer.mozilla.org</p></div></div><div class="of l"><div class="om l oh oi oj of ok km nw"/></div></div></a></div></div></div>    
</body>
</html>