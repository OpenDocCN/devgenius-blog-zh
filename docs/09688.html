<html>
<head>
<title>Stream APIs in Java(with Examples)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java 中的流 API(带示例)</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/stream-apis-in-java-with-examples-97e7e709fb43?source=collection_archive---------10-----------------------#2022-09-05">https://blog.devgenius.io/stream-apis-in-java-with-examples-97e7e709fb43?source=collection_archive---------10-----------------------#2022-09-05</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="7965" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Java 8 很久以前就引入了 Streams。这是 Java 8 的主要和强大的特性之一。流是支持顺序和并行聚合操作的元素序列。</p><p id="8598" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">简单地说，stream 是我们在 Java 8 之前所做事情的抽象，比如创建循环、编写条件等等。它主要关注所有而不是部分。</p><blockquote class="ki"><p id="571e" class="kj kk in bd kl km kn ko kp kq kr kh dk translated"><strong class="ak">具体&gt;抽象&gt;具体阶段</strong></p></blockquote><p id="b8ee" class="pw-post-body-paragraph jk jl in jm b jn ks jp jq jr kt jt ju jv ku jx jy jz kv kb kc kd kw kf kg kh ig bi translated">它允许我们从命令式编程转向函数式编程。函数式编程使用函数来创建干净的、可维护的和更可读的代码。</p><p id="4321" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">流管道由流操作组成。流管道由一个源、一个或零个中间操作和一个终端操作组成。</p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi kx"><img src="../Images/27f0571e4a67b29699acd6ef9ad3bf49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JUX2RYHGHW592F0778pXXw.jpeg"/></div></div></figure><p id="ab7f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">源</strong> —可以是数组、集合、列表、集合、文件等。</p><p id="ff68" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">中间操作</strong> —将一个流转换成另一个流。流管道中允许零个或多个中间操作。一些中间操作是不同的，过滤、映射、排序、平面映射、限制等。</p><p id="6b8b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">终端操作</strong> —将流转换成具体类型。只允许一个终端操作。一些终端操作是收集、计数、归约、汇总统计等。</p><h2 id="888d" class="lj lk in bd ll lm ln dn lo lp lq dp lr jv ls lt lu jz lv lw lx kd ly lz ma mb bi translated">流的惰性赋值</h2><p id="a6ae" class="pw-post-body-paragraph jk jl in jm b jn mc jp jq jr md jt ju jv me jx jy jz mf kb kc kd mg kf kg kh ig bi translated">流是惰性的，这意味着只有在调用终端操作时才会对源数据执行中间操作。</p><p id="1e15" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所有中间操作都很懒。它们直到实际需要计算结果时才被执行。它带来了另一点，即流在某种意义上是非常强大的，因为它们在应用程序中是优化的和安全的。</p><h2 id="50f6" class="lj lk in bd ll lm ln dn lo lp lq dp lr jv ls lt lu jz lv lw lx kd ly lz ma mb bi translated"><strong class="ak">创建 Java 流</strong></h2><p id="7f5f" class="pw-post-body-paragraph jk jl in jm b jn mc jp jq jr md jt ju jv me jx jy jz mf kb kc kd mg kf kg kh ig bi translated">在 java 中有许多创建流的方法，下面将讨论其中的一些。</p><ol class=""><li id="a289" class="mh mi in jm b jn jo jr js jv mj jz mk kd ml kh mm mn mo mp bi translated"><strong class="jm io"> Java 提供了两种方法来创建顺序流和并行流</strong></li></ol><ul class=""><li id="5671" class="mh mi in jm b jn jo jr js jv mj jz mk kd ml kh mq mn mo mp bi translated">使用 stream()函数创建一个顺序流</li></ul><pre class="ky kz la lb gt mr ms mt mu aw mv bi"><span id="bb13" class="lj lk in ms b gy mw mx l my mz">private static List&lt;String&gt; list = Array.asList(“Hello”, “world”);</span><span id="48f9" class="lj lk in ms b gy na mx l my mz">Stream&lt;String&gt; stream = list.stream();</span></pre><ul class=""><li id="6c63" class="mh mi in jm b jn jo jr js jv mj jz mk kd ml kh mq mn mo mp bi translated">使用 parallel stream()函数创建一个并行流</li></ul><pre class="ky kz la lb gt mr ms mt mu aw mv bi"><span id="21da" class="lj lk in ms b gy mw mx l my mz">Stream&lt;String&gt; stream = list.parallelStream();</span></pre><p id="09c8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> 2。从单个值创建一个流</strong></p><pre class="ky kz la lb gt mr ms mt mu aw mv bi"><span id="9e04" class="lj lk in ms b gy mw mx l my mz">Stream&lt;String&gt; stream = Stream.of(“Hello”, “World”);</span></pre><p id="ed03" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> 3。使用数组创建流</strong></p><pre class="ky kz la lb gt mr ms mt mu aw mv bi"><span id="afb2" class="lj lk in ms b gy mw mx l my mz">Int[] arr = {1,2,3,4};</span><span id="e118" class="lj lk in ms b gy na mx l my mz"><strong class="ms io">// create a sequential stream from the specified array</strong></span><span id="126c" class="lj lk in ms b gy na mx l my mz">Stream&lt;Integer&gt; stream = Arrays.stream(arr);</span><span id="5bef" class="lj lk in ms b gy na mx l my mz"><strong class="ms io">// create a sequential stream from the specified subarray [start, end]</strong></span><span id="b9f0" class="lj lk in ms b gy na mx l my mz">Stream&lt;Integer&gt; stream = Arrays.stream(arr, start, end);</span></pre><p id="a302" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> 4。使用构建器创建流</strong></p><pre class="ky kz la lb gt mr ms mt mu aw mv bi"><span id="54bb" class="lj lk in ms b gy mw mx l my mz">Stream&lt;String&gt; streamBuilder = Stream.&lt;String&gt;builder().add("Hello").add("World").build();</span></pre><p id="0b7f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> 5。使用</strong>创建一个无限流</p><ul class=""><li id="5c6a" class="mh mi in jm b jn jo jr js jv mj jz mk kd ml kh mq mn mo mp bi translated"><strong class="jm io"> iterate()方法</strong> — Iterate 方法用于创建接受两个参数的无限流:<strong class="jm io">种子</strong> —流中的初始元素，<strong class="jm io">函数</strong> —应用于流的前一个元素，以产生流的下一个元素。</li></ul><pre class="ky kz la lb gt mr ms mt mu aw mv bi"><span id="c460" class="lj lk in ms b gy mw mx l my mz"><strong class="ms io">// print even numbers up to 20 using stream</strong></span><span id="9666" class="lj lk in ms b gy na mx l my mz">IntStream.iterate(0, x-&gt;x+1)<br/>.limit(20)<br/>.filter(x -&gt; x%2 == 0)<br/>.forEach(System.out::println);</span></pre><p id="36a1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">** limit 用于限制流中的元素数量</p><ul class=""><li id="f8b2" class="mh mi in jm b jn jo jr js jv mj jz mk kd ml kh mq mn mo mp bi translated"><strong class="jm io">生成方法</strong> —生成方法也用于创建无限流</li></ul><pre class="ky kz la lb gt mr ms mt mu aw mv bi"><span id="f768" class="lj lk in ms b gy mw mx l my mz"><strong class="ms io">//generate creates an infinite stream, here we are limited it to 10 elements</strong><br/>Stream&lt;Double&gt; randomDoubleStream = Stream.generate(Math::random).limit(10);</span></pre><h2 id="b2ef" class="lj lk in bd ll lm ln dn lo lp lq dp lr jv ls lt lu jz lv lw lx kd ly lz ma mb bi translated"><strong class="ak"> Java 流操作</strong></h2><p id="eadd" class="pw-post-body-paragraph jk jl in jm b jn mc jp jq jr md jt ju jv me jx jy jz mf kb kc kd mg kf kg kh ig bi translated">让我们看看在 stream api 的帮助下可以执行的一些常见操作。</p><h2 id="b616" class="lj lk in bd ll lm ln dn lo lp lq dp lr jv ls lt lu jz lv lw lx kd ly lz ma mb bi translated">中间操作—</h2><ol class=""><li id="5b9e" class="mh mi in jm b jn mc jr md jv nb jz nc kd nd kh mm mn mo mp bi translated"><strong class="jm io"> distinct() </strong></li></ol><p id="42d4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">distinct()从流中移除重复的元素，返回一个不同的流。它使用 equals 方法来决定两个元素是否相等。distinct()不接受任何参数。</p><pre class="ky kz la lb gt mr ms mt mu aw mv bi"><span id="4384" class="lj lk in ms b gy mw mx l my mz">List&lt;Integer&gt; list = List.of(11,22,3,3,4,5,5);</span><span id="c355" class="lj lk in ms b gy na mx l my mz">list.stream()<br/>.distinct()<br/>.forEach(System.out::println);</span></pre><p id="f80a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">2.<strong class="jm io">滤镜()</strong></p><p id="e32f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">filter()方法返回一个流，该流包含通过特定条件的原始流的元素。filter()方法将谓词作为参数，谓词只是一个表达式。</p><pre class="ky kz la lb gt mr ms mt mu aw mv bi"><span id="27f6" class="lj lk in ms b gy mw mx l my mz"><strong class="ms io">//Filter all persons who are living in London</strong></span><span id="6c1c" class="lj lk in ms b gy na mx l my mz">Predicate&lt;Person&gt; predicate = person -&gt; person.getAddress().contains("London");</span><span id="765a" class="lj lk in ms b gy na mx l my mz">List&lt;Person&gt; personList = getPersonList()<br/>.stream()<br/>.filter(predicate)<br/>.collect(Collectors.toList());</span></pre><p id="6aef" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">3.<strong class="jm io">地图()</strong></p><p id="37c8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">map()用于将一种流类型转换为另一种类型。在给定的函数应用到原始流的元素后，它产生一个新的流。</p><pre class="ky kz la lb gt mr ms mt mu aw mv bi"><span id="a408" class="lj lk in ms b gy mw mx l my mz"><strong class="ms io">//Transform person to employee stream</strong></span><span id="73fd" class="lj lk in ms b gy na mx l my mz">List&lt;Employee&gt; employees =  personList<br/>.stream()<br/>.map(Employee::map)<br/>.collect(Collectors.toList());</span><span id="fdc1" class="lj lk in ms b gy na mx l my mz">employees.forEach(person -&gt; System.out.println(person));</span></pre><p id="3837" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">4.<strong class="jm io">已排序()</strong></p><p id="49e5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">sorted()用于返回一个流，由按排序顺序排列的原始流的元素组成。</p><pre class="ky kz la lb gt mr ms mt mu aw mv bi"><span id="28c3" class="lj lk in ms b gy mw mx l my mz"><strong class="ms io">// sort an array in natural order</strong></span><span id="a2e3" class="lj lk in ms b gy na mx l my mz">Integer[] arr = {20, 90, 0, 2, 3};</span><span id="53ed" class="lj lk in ms b gy na mx l my mz">Arrays.stream(arr)<br/>.sorted()<br/>.forEach(x -&gt; System.out.println(x));</span><span id="d973" class="lj lk in ms b gy na mx l my mz"><strong class="ms io">//sort list of persons based on age</strong></span><span id="b6bd" class="lj lk in ms b gy na mx l my mz">personList.sort(Comparator.comparingInt(Person::getAge));</span></pre><p id="564a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">5.<strong class="jm io"> skip() </strong></p><p id="63ad" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">skip()在丢弃流的前 n 个元素后返回一个流。如果元素比 skip 函数中指定的少，那么将返回一个空流。</p><pre class="ky kz la lb gt mr ms mt mu aw mv bi"><span id="a6d9" class="lj lk in ms b gy mw mx l my mz"><strong class="ms io">//print number 0 to 20 and skip first 8 elements</strong></span><span id="dca3" class="lj lk in ms b gy na mx l my mz">IntStream<br/>.range(0, 20)<br/>.skip(8)<br/>.forEach(num -&gt; System.out.println(num));</span></pre><h2 id="5723" class="lj lk in bd ll lm ln dn lo lp lq dp lr jv ls lt lu jz lv lw lx kd ly lz ma mb bi translated">终端操作—</h2><ol class=""><li id="02a9" class="mh mi in jm b jn mc jr md jv nb jz nc kd nd kh mm mn mo mp bi translated"><strong class="jm io"> forEach() </strong></li></ol><p id="364e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">它是最简单也是最常见的流操作之一。它遍历 stream 元素，并对每个元素执行一个操作。</p><p id="c55a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">forEach()是一个终端操作，这意味着一旦执行了该操作，流管道就被认为是关闭的，不能再使用了。</p><pre class="ky kz la lb gt mr ms mt mu aw mv bi"><span id="838b" class="lj lk in ms b gy mw mx l my mz"><strong class="ms io">// print number 0 to 20 inclusive 20</strong></span><span id="fa24" class="lj lk in ms b gy na mx l my mz">IntStream<br/>.rangeClosed(0, 20)<br/>.forEach(num -&gt; System.out.println(num));</span></pre><p id="5674" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">2.<strong class="jm io">收集()</strong></p><p id="932e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">collect()通过收集器接口对 stream 的元素执行可变归约操作。</p><pre class="ky kz la lb gt mr ms mt mu aw mv bi"><span id="ae7f" class="lj lk in ms b gy mw mx l my mz"><strong class="ms io">//remove duplicates using collector method</strong></span><span id="431f" class="lj lk in ms b gy na mx l my mz">list<br/>.stream()<br/>.collect(Collectors.toSet())<br/>.forEach(System.out::println);</span></pre><p id="0994" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在上面的代码中，我们使用 toSet()收集器将所有流元素收集到一个集合中。</p><p id="28a9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">3.<strong class="jm io">减少()</strong></p><p id="ce94" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">reduce()允许通过使用提供的标识和一个<a class="ae ne" href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html#Associativity" rel="noopener ugc nofollow" target="_blank">关联</a>累加函数从一系列元素中产生一个元素，并返回一个缩减的可选值。</p><pre class="ky kz la lb gt mr ms mt mu aw mv bi"><span id="5b22" class="lj lk in ms b gy mw mx l my mz"><strong class="ms io">//reduce stream of integer array into total of all elements of the array</strong></span><span id="a7fa" class="lj lk in ms b gy na mx l my mz">int total = IntStream.of(7,12,13,4,5,6).reduce(0, (int x, int y) -&gt; x+y);</span></pre><p id="7de9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">短路端子操作</strong></p><ol class=""><li id="d1b7" class="mh mi in jm b jn jo jr js jv mj jz mk kd ml kh mm mn mo mp bi translated"><strong class="jm io"> anyMatch() </strong></li></ol><p id="1ad4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">anyMatch()检查是否有任何流匹配给定的谓词值。任何匹配的返回类型都是布尔型的，它接受谓词作为参数。如果流为空，则返回 false。</p><pre class="ky kz la lb gt mr ms mt mu aw mv bi"><span id="93d3" class="lj lk in ms b gy mw mx l my mz"><strong class="ms io">// find if array contains even number or not</strong></span><span id="7d48" class="lj lk in ms b gy na mx l my mz">boolean isEven = IntStream.of(7,12,13,4,5,6)</span><span id="79c5" class="lj lk in ms b gy na mx l my mz">.anyMatch(x -&gt; x%2 == 0);</span></pre><p id="fc13" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">2.<strong class="jm io"> findFirst() </strong></p><p id="f66e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">它返回流的第一个元素。如果 stream 为空，则返回空的可选值。findFirst()返回可选的数据类型。</p><pre class="ky kz la lb gt mr ms mt mu aw mv bi"><span id="6378" class="lj lk in ms b gy mw mx l my mz">Predicate&lt;Integer&gt; predicate = n -&gt; n &lt; 10 &amp;&amp; n &gt; 5;</span><span id="8beb" class="lj lk in ms b gy na mx l my mz"><strong class="ms io">//Find first element that satisfies given predicate</strong></span><span id="698b" class="lj lk in ms b gy na mx l my mz">Integer[] numbers = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};</span><span id="3197" class="lj lk in ms b gy na mx l my mz">Optional&lt;Integer&gt; first = Arrays.stream(numbers)<br/>.filter(predicate)<br/>.findFirst();</span></pre><p id="73b3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">3.<strong class="jm io"> findAny() </strong></p><p id="8ea1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">它返回满足给定谓词的流中的任何元素。如果 stream 为空，则返回空的可选值。</p><pre class="ky kz la lb gt mr ms mt mu aw mv bi"><span id="d836" class="lj lk in ms b gy mw mx l my mz"><strong class="ms io">//Find any element that satisfies given predicate</strong></span><span id="5a90" class="lj lk in ms b gy na mx l my mz">Optional&lt;Integer&gt; any = Arrays.stream(numbers)<br/>.filter(predicate)<br/>.findAny()</span></pre><p id="bc98" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">findFirst()和 findAny()的核心区别在于，findAny()是非确定性的，而 findFirst()是确定性的。非确定性意味着当你多次运行它时，你可能会得到不同的结果，但是使用确定性，你将总是得到相同的结果。如果需要稳定的结果，请改用 findFirst()。</p><h2 id="06c5" class="lj lk in bd ll lm ln dn lo lp lq dp lr jv ls lt lu jz lv lw lx kd ly lz ma mb bi translated">文件操作—</h2><p id="f2f5" class="pw-post-body-paragraph jk jl in jm b jn mc jp jq jr md jt ju jv me jx jy jz mf kb kc kd mg kf kg kh ig bi translated">我们也可以在文件操作中使用流。</p><pre class="ky kz la lb gt mr ms mt mu aw mv bi"><span id="c568" class="lj lk in ms b gy mw mx l my mz"><strong class="ms io">//Append Test string to each row of file and print the result</strong></span><span id="7f0f" class="lj lk in ms b gy na mx l my mz">Stream&lt;String&gt; file =  Files.lines(Paths.get("Test.txt"));</span><span id="abe1" class="lj lk in ms b gy na mx l my mz">file.map(row-&gt; String.format("%s %s", row, "Test"))<br/>.forEach(System.out::println);<br/>file.close();</span><span id="06f8" class="lj lk in ms b gy na mx l my mz"><strong class="ms io">//Stream rows from file, filter data based on some condition and print the result</strong></span><span id="d883" class="lj lk in ms b gy na mx l my mz">Stream&lt;String&gt; file1 = Files.lines(Paths.get("TestData.csv"));</span><span id="9574" class="lj lk in ms b gy na mx l my mz">file1.skip(1)<br/>.map(row -&gt; row.split(","))<br/>.filter(row -&gt; row.length &gt; 2)<br/>.filter(row -&gt; !row[2].contains("5"))<br/>.forEach(x -&gt; System.out.println(x[0] + " " + x[1] + " " + x[2]));</span></pre><p id="8f01" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">** Files.lines()以流的形式返回文件中的行。</p><p id="1e60" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在本文中，我们将了解 stream 的内部工作方式、stream 支持的各种操作、执行顺序以及 stream 提供的性能优势。</p><p id="1282" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您可以在下面找到该库中使用的示例的链接</p><div class="ng nh gp gr ni nj"><a href="https://github.com/shwetatyagi22/java-stream-api" rel="noopener  ugc nofollow" target="_blank"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd io gy z fp no fr fs np fu fw im bi translated">GitHub-shwetatyagi 22/Java-stream-API</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">Stream 是支持顺序和并行聚合操作的元素序列。或者我们可以简单地说流…</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">github.com</p></div></div><div class="ns l"><div class="nt l nu nv nw ns nx lh nj"/></div></div></a></div><p id="b021" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你喜欢这篇文章，请花一分钟给我鼓掌👏。</p></div></div>    
</body>
</html>