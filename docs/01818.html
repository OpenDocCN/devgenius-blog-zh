<html>
<head>
<title>Stop using Docker like a BFU</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">不要像BFU一样使用Docker</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/stop-using-docker-like-a-bfu-229215e6e06d?source=collection_archive---------25-----------------------#2020-07-12">https://blog.devgenius.io/stop-using-docker-like-a-bfu-229215e6e06d?source=collection_archive---------25-----------------------#2020-07-12</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div class="gh gi jk"><img src="../Images/0786cd4b8c29946b48d24ad0f17b9a05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*g_21el6iFe_xvWnO_tjhpw.jpeg"/></div></figure><p id="3cd0" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">在与各种客户打交道的过程中，我遇到了很多使用docker的开发人员——甚至是资深开发人员，他们没有任何更深入的知识或问题。运行其他人提供的命令，而不知道它们实际上是为什么和做什么的。</p><p id="8776" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">如果您是其中一员，或者您只是想对这项技术了解更多一点，那么这篇文章就是为您准备的。所以让我们开始吧。</p></div><div class="ab cl kp kq hr kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="ig ih ii ij ik"><h1 id="d551" class="kw kx in bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">Dockerfile文件</h1><p id="33fc" class="pw-post-body-paragraph jr js in jt b ju lu jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ly km kn ko ig bi translated"><strong class="jt io"> Dockerfile <em class="lz"> </em> </strong>不是某个天才DevOps的家伙准备的黑匣子。<strong class="jt io"> Dockerfile <em class="lz"> </em> </strong>通常是一个非常简单的文件(如果做得对的话),描述你的应用程序将在其中运行的容器。</p><p id="53e6" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">当您构建一个<strong class="jt io">docker文件</strong>时，您将获得<strong class="jt io"> docker映像</strong>。然后，Docker映像可以被推送到<strong class="jt io">映像注册中心，例如<a class="ae ma" href="https://hub.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker Hub </a>、<a class="ae ma" href="https://about.gitlab.com/" rel="noopener ugc nofollow" target="_blank"> Gitlab注册中心</a>或其他私有或公共注册中心提供者，并用作其他Docker文件的基础映像。</strong></p><p id="b540" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">大多数docker文件都包含来自、<strong class="jt io"> COPY </strong>、<strong class="jt io"> RUN、</strong>、<strong class="jt io"> WORKDIR </strong>、<strong class="jt io"> ENTRYPOINT </strong>和<strong class="jt io"> EXPOSE </strong>的命令，对于每个至少具备基本unix命令知识的开发人员来说，它们的意义应该非常明显。</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="d3c9" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io">来自</strong>定义父docker镜像，通常带有预安装的运行时环境。所以对于Javascript的NodeJs，对于Java的Gradle或OpenJDK，对于PHP的PHP-FPM等等，你懂了吧。</p><p id="9560" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io"> COPY </strong>顾名思义就是从容器内部的本地文件系统中复制文件或目录。复制文件有时可以通过<strong class="jt io">添加</strong>完成，其功能与<strong class="jt io">复制</strong>相似，但也有其他特定用途。欲了解更多信息，请查阅<a class="ae ma" href="https://docs.docker.com/engine/reference/builder/#add" rel="noopener ugc nofollow" target="_blank">官方文档</a>。</p><p id="b3c0" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io">运行</strong>将执行任何提供的命令。很简单。</p><p id="eccf" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io"> WORKDIR </strong>为下面的命令定义了根目录，所以你不必每次都指定完整的路径。在提到的例子中，<strong class="jt io">复制</strong>命令实际上将文件复制到<em class="lz"> /app </em>目录，而<strong class="jt io">运行</strong>将执行<em class="lz"> /app </em>目录中的命令。第二个<strong class="jt io">复制</strong>命令将保持原样，因为它使用整个系统路径。</p><p id="bf0e" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io">入口点</strong>将在容器开始时执行提供的命令或可执行文件。在特定情况下，可以使用<strong class="jt io"> CMD </strong>代替<strong class="jt io">入口点</strong>。如果你想了解更多，我再次建议你查阅官方文档。</p><p id="8f0f" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io"> EXPOSE </strong>定义容器监听的默认公开端口。</p></div><div class="ab cl kp kq hr kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="ig ih ii ij ik"><h1 id="caaa" class="kw kx in bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">Docker撰写</h1><p id="aac9" class="pw-post-body-paragraph jr js in jt b ju lu jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ly km kn ko ig bi translated">Docker compose，也就是您应用程序中神秘的<strong class="jt io">Docker-composer . yml</strong>文件(很久以前由其他人准备的)，定义了docker服务的配置，这些服务可以作为整个堆栈在您的本地环境中运行。</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="7f0e" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">基本docker组合文件包含配置文件的<strong class="jt io">版本</strong>和<strong class="jt io">服务的列表</strong>。</p><h2 id="d456" class="mh kx in bd ky mi mj dn lc mk ml dp lg kc mm mn lk kg mo mp lo kk mq mr ls ms bi translated">图像或构建</h2><p id="b4e3" class="pw-post-body-paragraph jr js in jt b ju lu jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ly km kn ko ig bi translated">每个服务或者定义了docker <strong class="jt io">映像</strong>或者属性<strong class="jt io"> build </strong>指向<strong class="jt io"> Dockerfile </strong>文件所在的文件夹。如果<strong class="jt io"> Dockerfile </strong>位于其他地方或者具有不同的名称，则<strong class="jt io"> build </strong>属性可能看起来像:</p><pre class="mb mc md me gt mt mu mv mw aw mx bi"><span id="ec4d" class="mh kx in mu b gy my mz l na nb">build:<br/>  context: ./my-folder<br/>  dockerfile: Dockerfile-awesome</span></pre><p id="54de" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">用<strong class="jt io">上下文</strong>描述Dockerfile的路径，用<strong class="jt io"> dockerfile </strong>描述其名称。</p><blockquote class="nc nd ne"><p id="d32b" class="jr js lz jt b ju jv jw jx jy jz ka kb nf kd ke kf ng kh ki kj nh kl km kn ko ig bi translated"><strong class="jt io">构建</strong>或<strong class="jt io">上下文</strong>路径也为<strong class="jt io"> Dockerfile </strong>命令定义了根文件夹。</p></blockquote><h2 id="7efe" class="mh kx in bd ky mi mj dn lc mk ml dp lg kc mm mn lk kg mo mp lo kk mq mr ls ms bi translated">港口</h2><p id="f0c2" class="pw-post-body-paragraph jr js in jt b ju lu jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ly km kn ko ig bi translated">公开容器端口，以便可以从本地主机访问它们。</p><pre class="mb mc md me gt mt mu mv mw aw mx bi"><span id="99ec" class="mh kx in mu b gy my mz l na nb">ports:<br/>  - localPort:containerPort</span></pre><h2 id="22ad" class="mh kx in bd ky mi mj dn lc mk ml dp lg kc mm mn lk kg mo mp lo kk mq mr ls ms bi translated">卷</h2><p id="fb15" class="pw-post-body-paragraph jr js in jt b ju lu jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ly km kn ko ig bi translated">您可以将容器目录或文件挂载到本地磁盘。大多数情况下，当您想要持久化数据，以便在重新创建容器时不会丢失数据，或者在开发过程中想要使用某种热重新加载时，您会用到这个特性。</p><pre class="mb mc md me gt mt mu mv mw aw mx bi"><span id="7fca" class="mh kx in mu b gy my mz l na nb">volumes:<br/>  - local-path:container-path</span></pre><p id="4f76" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">在我的例子中，我挂载了<em class="lz"> src/ </em>和<em class="lz"> config/ </em>文件夹，所以这些目录中的项目文件和容器文件会自动同步。</p><h2 id="48ff" class="mh kx in bd ky mi mj dn lc mk ml dp lg kc mm mn lk kg mo mp lo kk mq mr ls ms bi translated">环境</h2><p id="0cb1" class="pw-post-body-paragraph jr js in jt b ju lu jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ly km kn ko ig bi translated">包含传递给运行容器的ENV变量列表。</p><blockquote class="nc nd ne"><p id="6ccc" class="jr js lz jt b ju jv jw jx jy jz ka kb nf kd ke kf ng kh ki kj nh kl km kn ko ig bi translated">注意<strong class="jt io"> mongo-db </strong>服务在变量<strong class="jt io"> DB_URL </strong>中被引用。默认情况下，docker服务相互公开，只需在URL或其他变量中使用它们的名称就可以引用它们。</p></blockquote></div><div class="ab cl kp kq hr kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="ig ih ii ij ik"><h1 id="c6f8" class="kw kx in bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">命令</h1><h2 id="88cf" class="mh kx in bd ky mi mj dn lc mk ml dp lg kc mm mn lk kg mo mp lo kk mq mr ls ms bi translated">docker-向上组合(-d)</h2><ul class=""><li id="caf8" class="ni nj in jt b ju lu jy lv kc nk kg nl kk nm ko nn no np nq bi translated">这可能是创建和启动堆栈的最重要的命令。</li><li id="4ca6" class="ni nj in jt b ju nr jy ns kc nt kg nu kk nv ko nn no np nq bi translated">如果您的堆栈已经在运行，并且您已经更新了<strong class="jt io"> docker-compose.yml </strong>，它将重新创建受更新影响的服务。</li><li id="fc82" class="ni nj in jt b ju nr jy ns kc nt kg nu kk nv ko nn no np nq bi translated">使用参数<strong class="jt io"> -d </strong>或<strong class="jt io"> - detach </strong>将在后台运行堆栈。</li></ul><blockquote class="nc nd ne"><p id="e670" class="jr js lz jt b ju jv jw jx jy jz ka kb nf kd ke kf ng kh ki kj nh kl km kn ko ig bi translated"><strong class="jt io">Mac版Docker</strong>和【Windows版Docker带有预装的docker <strong class="jt io">仪表盘</strong> UI，你可以看到所有正在运行的容器或整个Docker用日志和其他有用的信息组成堆栈。</p></blockquote><h2 id="81b1" class="mh kx in bd ky mi mj dn lc mk ml dp lg kc mm mn lk kg mo mp lo kk mq mr ls ms bi translated">docker-撰写停止</h2><ul class=""><li id="41ac" class="ni nj in jt b ju lu jy lv kc nk kg nl kk nm ko nn no np nq bi translated">停止当前docker合成堆栈中的所有容器</li></ul><h2 id="9342" class="mh kx in bd ky mi mj dn lc mk ml dp lg kc mm mn lk kg mo mp lo kk mq mr ls ms bi translated">docker-向下合成</h2><ul class=""><li id="2d4f" class="ni nj in jt b ju lu jy lv kc nk kg nl kk nm ko nn no np nq bi translated">除了停止所有容器之外，还会删除所有容器以及所有相关的网络、卷和映像。</li></ul><h2 id="86a5" class="mh kx in bd ky mi mj dn lc mk ml dp lg kc mm mn lk kg mo mp lo kk mq mr ls ms bi translated">docker-compose build(SERVICE _ NAME)(-no-cache)</h2><ul class=""><li id="050a" class="ni nj in jt b ju lu jy lv kc nk kg nl kk nm ko nn no np nq bi translated">通过不带任何参数运行该命令，docker compose将使用<strong class="jt io"> build </strong>属性重建所有服务(使用本地Dockerfile的服务)</li><li id="c769" class="ni nj in jt b ju nr jy ns kc nt kg nu kk nv ko nn no np nq bi translated">通过指定服务名，docker compose将只重建指定的服务</li><li id="118f" class="ni nj in jt b ju nr jy ns kc nt kg nu kk nv ko nn no np nq bi translated">参数<strong class="jt io"> -无缓存</strong>将在不使用缓存的情况下重建docker映像(默认情况下<strong class="jt io">运行</strong>命令层被缓存，而<strong class="jt io">复制</strong>或<strong class="jt io">添加</strong>不被缓存)</li></ul><h2 id="1900" class="mh kx in bd ky mi mj dn lc mk ml dp lg kc mm mn lk kg mo mp lo kk mq mr ls ms bi translated">docker-撰写拉取(服务名称)</h2><ul class=""><li id="4296" class="ni nj in jt b ju lu jy lv kc nk kg nl kk nm ko nn no np nq bi translated">如果没有任何参数，docker compose将尝试使用指定的<strong class="jt io">图像</strong>来获取所有服务的最新图像</li><li id="556b" class="ni nj in jt b ju nr jy ns kc nt kg nu kk nv ko nn no np nq bi translated">如果您在开发期间使用docker图像标签，如<strong class="jt io">最新</strong>、<strong class="jt io">开发</strong>或<strong class="jt io"> lts </strong>，这个命令会非常有用</li><li id="dd34" class="ni nj in jt b ju nr jy ns kc nt kg nu kk nv ko nn no np nq bi translated">只有当图像作者推送具有完全相同版本号的新图像时，具有特定版本(如3.2.1)的图像才会被更新</li><li id="1ab9" class="ni nj in jt b ju nr jy ns kc nt kg nu kk nv ko nn no np nq bi translated">使用服务名作为参数，它将只尝试提取服务映像</li></ul></div><div class="ab cl kp kq hr kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="ig ih ii ij ik"><h2 id="4337" class="mh kx in bd ky mi mj dn lc mk ml dp lg kc mm mn lk kg mo mp lo kk mq mr ls ms bi translated">结论</h2><p id="18ba" class="pw-post-body-paragraph jr js in jt b ju lu jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ly km kn ko ig bi translated">关于docker和docker compose、其他Dockerfile命令和docker compose属性，肯定还有很多东西需要了解和学习，但这是我根据自己的经验认为绝对基础的东西。</p><p id="8228" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">希望它能帮助你或给你指出正确的方向，如果是这样，请留下👏或者很少。</p></div></div>    
</body>
</html>