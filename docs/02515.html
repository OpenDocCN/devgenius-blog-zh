<html>
<head>
<title>Cracking the Data Structure Interview</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">破解数据结构面试</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/cracking-the-data-structure-interview-c94394dc68b7?source=collection_archive---------7-----------------------#2020-08-09">https://blog.devgenius.io/cracking-the-data-structure-interview-c94394dc68b7?source=collection_archive---------7-----------------------#2020-08-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="919b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里是你可以从编码面试开始的地方。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/5114d7c721cbf9bfca099a1c9bbc32a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OZ4vnYyl-bB2Q_BT"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated"><a class="ae lb" href="https://unsplash.com/@kaleidico?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">万花筒</a>在<a class="ae lb" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="2d3c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">而在编码面试中，我们总是有不同类型的算法问题。在我们开始考虑解决方案之前，我们了解基本的数据结构吗？这里我分享一下编码面试的基础:数据结构。</p><p id="ee5b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们深入研究数据结构之前，让我解释一下什么是时间复杂度/大O。大O允许我们表达运行时间如何伸缩。基本上，它描述了数据增长的速率。下面是比较速率差异的典型图像。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi lc"><img src="../Images/5a283778dc0b347f67c449b2727a8b59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*fvMyYd9JnqWFaPPP.jpg"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">来源:<a class="ae lb" href="https://medium.com/@randerson112358" rel="noopener">randers 112358</a></figcaption></figure><p id="d40f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">图像反映了处理结果的时间，而数据输入随着您设计的算法而增长。</p><p id="b5bf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">只有学会了数据结构和时间复杂度，才能开始思考算法题的解法。在本文中，我将解释Java中的8种典型数据结构，以及它们在搜索、添加、删除和更新时的时间复杂度。</p></div><div class="ab cl ld le hu lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="ij ik il im in"><h1 id="cdc2" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">排列</h1><pre class="km kn ko kp gt mi mj mk ml aw mm bi"><span id="19d6" class="mn ll iq mj b gy mo mp l mq mr"><strong class="mj ir">public</strong> <strong class="mj ir">static</strong> <strong class="mj ir">void</strong> <!-- -->main(String args[])</span><span id="c385" class="mn ll iq mj b gy ms mp l mq mr">{</span><span id="4f6c" class="mn ll iq mj b gy ms mp l mq mr">ArrayList&lt;String&gt; al = <strong class="mj ir">new</strong> <!-- -->ArrayList&lt;&gt;();</span><span id="424b" class="mn ll iq mj b gy ms mp l mq mr">al.add("value1");</span><span id="1a09" class="mn ll iq mj b gy ms mp l mq mr">al.add("value2");</span><span id="1a0b" class="mn ll iq mj b gy ms mp l mq mr">al.add(1, "value3");</span><span id="31d9" class="mn ll iq mj b gy ms mp l mq mr">System.out.println("Initial ArrayList "<!-- --> <!-- -->+ al);</span><span id="6fcb" class="mn ll iq mj b gy ms mp l mq mr">al.set(1, "To");</span><span id="aefc" class="mn ll iq mj b gy ms mp l mq mr">System.out.println("Updated ArrayList "<!-- --> <!-- -->+ al);</span><span id="25c2" class="mn ll iq mj b gy ms mp l mq mr">}</span><span id="bca7" class="mn ll iq mj b gy ms mp l mq mr">// output<br/>Initial <!-- -->ArrayList<!-- --> [<!-- -->value1<!-- -->, <!-- -->value3<!-- -->, <!-- -->value2<!-- -->]<br/>Updated <!-- -->ArrayList<!-- --> [<!-- -->value1<!-- -->, <!-- -->To<!-- -->, <!-- -->value2<!-- -->]</span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mt"><img src="../Images/e689f247a821a4d524df2cc277729f5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GXzDB2Dx5TYFNv24CPkZrA.jpeg"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">来源:<a class="ae lb" href="https://www.geeksforgeeks.org/" rel="noopener ugc nofollow" target="_blank"> GeeksForGeeks </a></figcaption></figure><p id="7ff3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有两种类型的数组:固定大小的数组和动态数组。在java中，Array是固定大小的，ArrayList是动态的。这两者的区别在于它们是否能自动缩放。</p><ul class=""><li id="e25c" class="mu mv iq jp b jq jr ju jv jy mw kc mx kg my kk mz na nb nc bi translated">在ArrayList中，当元素的数量达到某个因子时，它会使自己的大小翻倍</li><li id="e9b8" class="mu mv iq jp b jq nd ju ne jy nf kc ng kg nh kk mz na nb nc bi translated">在数组中，大小从初始化时就固定了</li><li id="34a6" class="mu mv iq jp b jq nd ju ne jy nf kc ng kg nh kk mz na nb nc bi translated">在数组中，原始值存储在连续的内存位置。如果数组列表存储对象。</li><li id="bc4a" class="mu mv iq jp b jq nd ju ne jy nf kc ng kg nh kk mz na nb nc bi translated">引用存储在堆中的连续内存中，而对象的内存不是连续的。</li></ul><h2 id="5163" class="mn ll iq bd lm ni nj dn lq nk nl dp lu jy nm nn ly kc no np mc kg nq nr mg ns bi translated"><strong class="ak">时间复杂度:</strong></h2><p id="0ca5" class="pw-post-body-paragraph jn jo iq jp b jq nt js jt ju nu jw jx jy nv ka kb kc nw ke kf kg nx ki kj kk ij bi translated">按索引搜索:O(1)</p><p id="acfa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">按值搜索:O(n)</p><p id="547d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">删除:O(n)</p><p id="282e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">添加:O(1)</p><p id="1cf8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">插入:O(n)</p></div><div class="ab cl ld le hu lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="ij ik il im in"><h1 id="8cae" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">链接列表</h1><pre class="km kn ko kp gt mi mj mk ml aw mm bi"><span id="208b" class="mn ll iq mj b gy mo mp l mq mr"><strong class="mj ir">public</strong> <strong class="mj ir">static</strong> <strong class="mj ir">void</strong> <!-- -->main(String args[])</span><span id="c96f" class="mn ll iq mj b gy ms mp l mq mr">{</span><span id="7a66" class="mn ll iq mj b gy ms mp l mq mr">LinkedList&lt;String&gt; linkedList= <strong class="mj ir">new</strong> <!-- -->LinkedList&lt;&gt;();</span><span id="1f9b" class="mn ll iq mj b gy ms mp l mq mr">linkedList.add("value1");</span><span id="521b" class="mn ll iq mj b gy ms mp l mq mr">linkedList.add("value2");</span><span id="143c" class="mn ll iq mj b gy ms mp l mq mr">linkedList.add(1, "value3");</span><span id="f88e" class="mn ll iq mj b gy ms mp l mq mr">System.out.println("Initial LinkedList "<!-- --> <!-- -->+ ll);</span><span id="37eb" class="mn ll iq mj b gy ms mp l mq mr">linkedList.set(1, "To");</span><span id="e777" class="mn ll iq mj b gy ms mp l mq mr">System.out.println("Updated LinkedList "<!-- --> <!-- -->+ ll);</span><span id="2d5d" class="mn ll iq mj b gy ms mp l mq mr">}</span><span id="d539" class="mn ll iq mj b gy ms mp l mq mr">// output<br/>Initial LinkedList [<!-- -->value1<!-- -->, <!-- -->value3<!-- -->, <!-- -->value2<!-- -->]<br/>Updated LinkedList [<!-- -->value1<!-- -->, <!-- -->To<!-- -->, <!-- -->value2<!-- -->]</span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ny"><img src="../Images/49771c0d63f2e5f0dda6f8f88edd284c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6ReSYwX-z-n4jWPCRSxqBw.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">来源:<a class="ae lb" href="https://www.geeksforgeeks.org/" rel="noopener ugc nofollow" target="_blank"> GeeksForGeeks </a></figcaption></figure><p id="dac1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">LinkedList是一种线性数据结构。这些元素没有存储在连续的位置。每个节点都是一个独立的对象，具有数据部分和引用部分。节点通过引用进行链接。</p><p id="7c0b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">与Array相比，LinkedList插入和删除一个节点需要花费<strong class="jp ir">常量</strong>的时间。它也有一些缺点，如节点不能直接访问。我们需要从头开始，遍历列表到达目标节点。</p><p id="6f2f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">LinkedList的一个优点是，在某个因子上不需要把容量翻倍。它可以在需要时将节点添加到踪迹中。因此，当数据量增长时，LinkedList的容量也呈线性增长。</p><p id="75d6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">数组内存的增长有点跳跃，因为它有时必须加倍。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nz"><img src="../Images/255c3cee96ac10bc33914df176fb5df2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mawp8vtKUh4oNmvfcptbpQ.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated"><em class="oa">作者图片</em></figcaption></figure><h2 id="f639" class="mn ll iq bd lm ni nj dn lq nk nl dp lu jy nm nn ly kc no np mc kg nq nr mg ns bi translated">面试小贴士:</h2><ul class=""><li id="5722" class="mu mv iq jp b jq nt ju nu jy ob kc oc kg od kk mz na nb nc bi translated">永远记住如何向前移动指针:</li></ul><pre class="km kn ko kp gt mi mj mk ml aw mm bi"><span id="40e8" class="mn ll iq mj b gy mo mp l mq mr">current = current.next</span></pre><ul class=""><li id="02a9" class="mu mv iq jp b jq jr ju jv jy mw kc mx kg my kk mz na nb nc bi translated">更新LinkedNode中的指针:</li></ul><pre class="km kn ko kp gt mi mj mk ml aw mm bi"><span id="c2d0" class="mn ll iq mj b gy mo mp l mq mr">current.next = prev</span></pre><ul class=""><li id="7ccb" class="mu mv iq jp b jq jr ju jv jy mw kc mx kg my kk mz na nb nc bi translated">对于大多数问题，我们总是需要遍历链表。最好使用带有适当退出场景的<em class="oe"> while循环</em>，例如<em class="oe"> currentNode！= null。</em></li><li id="d98f" class="mu mv iq jp b jq nd ju ne jy nf kc ng kg nh kk mz na nb nc bi translated">我们可能需要一个假头来完成这个过程</li></ul><h2 id="3ef6" class="mn ll iq bd lm ni nj dn lq nk nl dp lu jy nm nn ly kc no np mc kg nq nr mg ns bi translated">时间复杂度分析:</h2><ul class=""><li id="af92" class="mu mv iq jp b jq nt ju nu jy ob kc oc kg od kk mz na nb nc bi translated">按值搜索:O(n)。</li><li id="6870" class="mu mv iq jp b jq nd ju ne jy nf kc ng kg nh kk mz na nb nc bi translated">添加、插入、删除:O(1)，在此之前，我们可能必须先搜索目标节点，这需要O(n)时间。</li></ul></div><div class="ab cl ld le hu lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="ij ik il im in"><h1 id="958e" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">HashSet和HashMap</h1><pre class="km kn ko kp gt mi mj mk ml aw mm bi"><span id="eaf0" class="mn ll iq mj b gy mo mp l mq mr"><strong class="mj ir">public</strong> <strong class="mj ir">static</strong> <strong class="mj ir">void</strong> <!-- -->main(String[] args)</span><span id="bde2" class="mn ll iq mj b gy ms mp l mq mr">{</span><span id="b550" class="mn ll iq mj b gy ms mp l mq mr">// Create an empty hash map</span><span id="29af" class="mn ll iq mj b gy ms mp l mq mr">HashMap&lt;String, Integer&gt; map = <strong class="mj ir">new</strong> <!-- -->HashMap&lt;&gt;();<br/></span><span id="4fc5" class="mn ll iq mj b gy ms mp l mq mr">// Add elements to the map</span><span id="98d0" class="mn ll iq mj b gy ms mp l mq mr">map.put("apple", 3);</span><span id="fb13" class="mn ll iq mj b gy ms mp l mq mr">map.put("pear", 5);</span><span id="215a" class="mn ll iq mj b gy ms mp l mq mr">map.put("cucumber", 78);<br/></span><span id="cdae" class="mn ll iq mj b gy ms mp l mq mr">// Print size and content</span><span id="aaa9" class="mn ll iq mj b gy ms mp l mq mr">System.out.println(map);</span><span id="2b70" class="mn ll iq mj b gy ms mp l mq mr">// Check if a key is present and if present, print value</span><span id="6c7e" class="mn ll iq mj b gy ms mp l mq mr"><strong class="mj ir">if</strong> <!-- -->(map.containsKey("cucumber")) {</span><span id="f9b8" class="mn ll iq mj b gy ms mp l mq mr">Integer quantity= map.get("cucumber");</span><span id="4068" class="mn ll iq mj b gy ms mp l mq mr">System.out.println("value for key" + " \"cucumber\" is:- " + quantity); }</span><span id="cb14" class="mn ll iq mj b gy ms mp l mq mr">}</span></pre><p id="2116" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">HashMap以(键，值)对的形式存储数据。哈希是Hashmap使用的一种技术，它将长字符串转换成短字符串来表示同一个字符串。如果知道密钥(短字符串)，可以在常数时间内求值。</p><p id="1662" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">HashSet由HashMap支持。它具有相同的键和值。因此，这个键在HashMap中应该是唯一的。该值在HashSet中应该是唯一的。</p><p id="ce4e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，HashMap中的键值对和HashSet中的值的顺序没有保证。</p><p id="7d14" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们深入研究HashMap的内部结构:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi of"><img src="../Images/40364f00d3bd02c7cc94be177785e30e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aG9hZlKrHk3LcgbEz1kNJg.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">来源:<a class="ae lb" href="https://techmastertutorial.in/java-collection-internal-hashmap.html" rel="noopener ugc nofollow" target="_blank"> <em class="oa">科技大师教程</em> </a></figcaption></figure><p id="df5c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于每个键对，底层类包含哈希值、键、值和下一个节点。</p><p id="c162" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们按关键字搜索，系统会将关键字转换为哈希值。</p><p id="c3a7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后使用该值在恒定时间内找到节点。</p><p id="0af4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当将值存储在桶中时，总是会发生冲突，这意味着哈希函数从不同的键生成相同的值。在这种情况下，我们有下一个节点将碰撞节点连接到LinkedList的末尾。</p><p id="ef96" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在python中，我们使用OrderedDict来保持Hashmap中元素的顺序。</p><h2 id="14a3" class="mn ll iq bd lm ni nj dn lq nk nl dp lu jy nm nn ly kc no np mc kg nq nr mg ns bi translated">时间复杂度:</h2><p id="0737" class="pw-post-body-paragraph jn jo iq jp b jq nt js jt ju nu jw jx jy nv ka kb kc nw ke kf kg nx ki kj kk ij bi translated">按关键字搜索:O(1)</p><p id="0dec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">按键删除:O(1)</p><p id="8905" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">添加/插入:O(1)</p></div><div class="ab cl ld le hu lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="ij ik il im in"><h1 id="d833" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">堆栈，队列</h1><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi og"><img src="../Images/259adb0bf2d4a98a696558439694b3f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1046/format:webp/1*zl6_xhyIWBmOh2mXYi2vJA.png"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">来源:<a class="ae lb" href="https://medium.com/@shahisa?source=post_page-----60f365963552----------------------" rel="noopener">伊萨韦弗</a></figcaption></figure><p id="ee97" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">堆栈和队列是线性数据结构。堆栈中的值遵循特定的顺序:先入后出。队列中的值遵循先入先出的顺序。</p><p id="61c0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">操作是常见的，堆栈和队列都需要推送/添加值和弹出/轮询值。此外，它们总是可以通过调用peek()来检查head值。</p><p id="f01e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">面试的时候，很少直接向栈和队列提问。在其他复杂的问题中，如BFS和DFS，它总是包含这些概念。但是，可能会要求您使用Array或LinkedList创建堆栈或队列。</p><h2 id="1dc2" class="mn ll iq bd lm ni nj dn lq nk nl dp lu jy nm nn ly kc no np mc kg nq nr mg ns bi translated">时间复杂度:</h2><p id="c607" class="pw-post-body-paragraph jn jo iq jp b jq nt js jt ju nu jw jx jy nv ka kb kc nw ke kf kg nx ki kj kk ij bi translated">按值搜索:O(n)</p><p id="ca23" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">民意调查/民意测验:O(1)</p><p id="b2df" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">推送/添加:O(1)</p><p id="8d3b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">peek: O(1)</p></div><div class="ab cl ld le hu lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="ij ik il im in"><h1 id="07ae" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">二叉树</h1><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/24f7a0f1c71b23a0359d95605ce96497.png" data-original-src="https://miro.medium.com/v2/resize:fit:840/format:webp/1*lwaDg8aL0XtdEndSDBtyvQ.png"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">来源:<a class="ae lb" href="https://www.geeksforgeeks.org/" rel="noopener ugc nofollow" target="_blank"> GeeksForGeeks </a></figcaption></figure><p id="f5a7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">二叉树是一种最多有两个子树(左右子树)的数据结构。这里有一种表示树的方法:</p><pre class="km kn ko kp gt mi mj mk ml aw mm bi"><span id="992e" class="mn ll iq mj b gy mo mp l mq mr"><strong class="mj ir">class</strong> <!-- -->Node {</span><span id="876b" class="mn ll iq mj b gy ms mp l mq mr"><strong class="mj ir">    int</strong> <!-- -->value;</span><span id="f14d" class="mn ll iq mj b gy ms mp l mq mr">    Node left, right;</span><span id="458a" class="mn ll iq mj b gy ms mp l mq mr"><strong class="mj ir">    public</strong> <!-- -->Node(<strong class="mj ir">int</strong> <!-- -->item) {</span><span id="9620" class="mn ll iq mj b gy ms mp l mq mr">        value = item;</span><span id="73db" class="mn ll iq mj b gy ms mp l mq mr">        left = right = <strong class="mj ir">null</strong>;</span><span id="29ff" class="mn ll iq mj b gy ms mp l mq mr">    } </span><span id="43e4" class="mn ll iq mj b gy ms mp l mq mr">}</span></pre><p id="02ec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在采访中，我们会问一些问题，例如:</p><ul class=""><li id="f111" class="mu mv iq jp b jq jr ju jv jy mw kc mx kg my kk mz na nb nc bi translated">前序，按序，后序，层次遍历树。</li><li id="5bb2" class="mu mv iq jp b jq nd ju ne jy nf kc ng kg nh kk mz na nb nc bi translated">倒置二叉树</li><li id="bb2f" class="mu mv iq jp b jq nd ju ne jy nf kc ng kg nh kk mz na nb nc bi translated">找出二叉树是相同的还是对称的。</li></ul><p id="efb1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">二叉树的一个实际应用是T2二叉查找树(BST)。 BST是左值小于父值，右值大于父值的数据结构。</p><p id="a4ae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这种情况下，如果我们将数据存储在BST中，那么搜索某个值将会非常快。搜索时间复杂度为O(h ),其中h是树的高度。如果我们想在1000万个节点中找到某个值，我们最多只需要比较30次。同样，最小值在左下方，最大值在右下方。如果我们在BST上应用有序搜索，我们将得到一个有序的数组。</p><p id="f319" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> HEAP </strong>是一种特殊的基于树的数据结构，其中的树是一棵完整的二叉树。通常，有两种类型的树:</p><ol class=""><li id="9c5a" class="mu mv iq jp b jq jr ju jv jy mw kc mx kg my kk oi na nb nc bi translated">Max-Heap :在Max-Heap中，根节点必须是所有子节点中最大的。对于该二叉树中的所有子树，相同的属性必须递归地为真。</li><li id="9a2d" class="mu mv iq jp b jq nd ju ne jy nf kc ng kg nh kk oi na nb nc bi translated"><strong class="jp ir">最小堆</strong>:在一个最小堆中，根节点必须是所有子节点中最小的。对于该二叉树中的所有子树，相同的属性必须递归地为真。</li></ol><p id="dff1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Heap常见的面试问题是找出一个数组中的第k个最大/最小值。显然，我们可以对数组进行排序并找到结果。但是排序的代价是昂贵的— O(nlogn)。如果我们使用堆，我们可以把值推到一个K大小的堆。每当有新的值添加到堆中时，它会对堆重新排序，以确保它以“堆”的方式排序。</p><p id="bb79" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这种情况下，我们的数组中有n个值，这需要O (n)来扫描，对于每个值，我们可能需要重新排列我们的堆，这平均需要O(logk)。所以，时间复杂度为O(nlogk)。下面是一个示例问题:</p><div class="oj ok gp gr ol om"><a href="https://www.geeksforgeeks.org/k-largestor-smallest-elements-in-an-array/" rel="noopener  ugc nofollow" target="_blank"><div class="on ab fo"><div class="oo ab op cl cj oq"><h2 class="bd ir gy z fp or fr fs os fu fw ip bi translated">数组中k个最大(或最小)的元素|增加了最小堆方法- GeeksforGeeks</h2><div class="ot l"><h3 class="bd b gy z fp or fr fs os fu fw dk translated">问题:写一个有效的程序来打印一个数组中k个最大的元素。数组中的元素可以在任何…</h3></div><div class="ou l"><p class="bd b dl z fp or fr fs os fu fw dk translated">www.geeksforgeeks.org</p></div></div><div class="ov l"><div class="ow l ox oy oz ov pa kv om"/></div></div></a></div></div><div class="ab cl ld le hu lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="ij ik il im in"><h1 id="5bf5" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">图表</h1><p id="1c2a" class="pw-post-body-paragraph jn jo iq jp b jq nt js jt ju nu jw jx jy nv ka kb kc nw ke kf kg nx ki kj kk ij bi translated">Graph是一个升级的树，而不是只有两个孩子，它有更多的相互连接的节点。这是图表:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi pb"><img src="../Images/d9968e04dc9bd3e0ef5d69c94d70020e.png" data-original-src="https://miro.medium.com/v2/resize:fit:458/0*Qe5kACgj635sHys_"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated"><em class="oa">作者图片</em></figcaption></figure><p id="ba4b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们有不同的方式来表示地图和BFS，DFS是流行的在图中搜索。欢迎您查看我的文章了解更多详情:</p><div class="oj ok gp gr ol om"><a href="https://medium.com/dev-genius/cracking-the-dfs-and-bfs-in-faang-interview-5589127c3f76" rel="noopener follow" target="_blank"><div class="on ab fo"><div class="oo ab op cl cj oq"><h2 class="bd ir gy z fp or fr fs os fu fw ip bi translated">在FAANG访谈中破解DFS和BFS</h2><div class="ot l"><h3 class="bd b gy z fp or fr fs os fu fw dk translated">深度优先搜索和广度优先搜索。</h3></div><div class="ou l"><p class="bd b dl z fp or fr fs os fu fw dk translated">medium.com</p></div></div><div class="ov l"><div class="pc l ox oy oz ov pa kv om"/></div></div></a></div></div><div class="ab cl ld le hu lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="ij ik il im in"><h1 id="cf02" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">最后的话:</h1><p id="21d8" class="pw-post-body-paragraph jn jo iq jp b jq nt js jt ju nu jw jx jy nv ka kb kc nw ke kf kg nx ki kj kk ij bi translated">本文涵盖了数据结构的基础知识。相信大家在深入挖掘编码面试之前都要了解这一点。然而，掌握数据结构还远远不足以破解编码问题。我们必须不断练习。</p><p id="d01f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">希望你能从这篇文章中学到一些东西。如果你有兴趣阅读我的其他文章，欢迎查看我的个人资料。你也可以通过媒体或邮件联系我。</p></div></div>    
</body>
</html>