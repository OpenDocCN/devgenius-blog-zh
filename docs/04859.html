<html>
<head>
<title>Can we have more than 1000000 elements in an array? yes, but …</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一个数组中可以有超过1000000个元素吗？是的，但是…</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/can-we-have-more-than-1000000-elements-in-an-array-yes-but-7a5c4e5b460a?source=collection_archive---------4-----------------------#2021-05-13">https://blog.devgenius.io/can-we-have-more-than-1000000-elements-in-an-array-yes-but-7a5c4e5b460a?source=collection_archive---------4-----------------------#2021-05-13</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="4e33" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在C语言中，它给出了“分段错误:核心转储”</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/493581cc0ce5e8aed988a885b80fa8b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:724/format:webp/1*KpXLgBfBNSRN5b_EsnL-_w.png"/></div></figure><p id="2007" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是我在完成算法设计和分析的作业时发现的有趣的事情。我必须为二分搜索法写一个算法(用任何编程语言)并分析它的时间复杂度。</p><p id="d753" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我通常更喜欢python，但在这里我想使用递归，因为python的最大深度递归只有1000，所以我用C来实现它。</p><p id="04ca" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你可能想知道为什么我需要1000多次递归调用来证明我的二分搜索算法运行正常。是的，我可以用小数字证明。</p><p id="03cd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是我想在我的终端中使用“时间”工具来实际计算时间，并根据我的算法的速度显示出来。所以，我不得不用C来表示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi kq"><img src="../Images/1cccdbd89b06c93a9cab2f604b4193c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:694/format:webp/1*_ErCAliyauX7fdvzKF0Zug.png"/></div></figure><p id="e6fc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">那时我才知道，在拥有一个大小为10，000，000的数组后，C不能再多处理一个空间。上面写着“分段故障:核心转储”。我可以停在这里，只使用10，000，000个元素进行分析。但我很好奇为什么C不会允许拥有超过10，000，000。</p><p id="18b5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后在谷歌上搜索了一番，并对我的代码进行了几次测试之后。我知道我们需要函数是“静态的”,以便在包含该函数的数组中有超过10，000，000个元素。</p><p id="416b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你声明一个函数是“静态的”,你就只能把这么大的数组放在函数中。这告诉编译器把它放在堆内存中，而不是堆栈中。这样，随着现代RAM的大小以千兆字节计，你不会有任何麻烦。</p><p id="05bc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">另一种方法是在任何函数外部声明、定义和初始化数组，使其成为一个全局变量。这也迫使它进入堆，避免堆栈溢出。</p><p id="f27a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我选择了第一个选项，因为我很少使用全局变量，因为我认为当我们使用全局变量时，这不是一个干净的代码。</p><pre class="kj kk kl km gt kr ks kt ku aw kv bi"><span id="8331" class="kw kx in ks b gy ky kz l la lb">#include &lt;stdio.h&gt; </span><span id="885b" class="kw kx in ks b gy lc kz l la lb">int binarySearch(int array[], int low, int high, int key) {<br/>   if (high &gt;= low) {<br/>        int mid = low + (high - low) / 2;<br/>        if (array[mid] == key)  return mid;<br/>        if (array[mid] &gt; key) return binarySearch(array, low, mid - 1, key);<br/>        return binarySearch(array, mid + 1, high, key);<br/>   }<br/>   return -1;<br/>}<br/>  <br/>int main(void)<br/>{  <br/>   static int array[10000000];<br/><br/>   int size;<br/>   printf("Enter size of array: ");<br/>   scanf("%d", &amp;size);<br/>   for(int i = 1; i &lt;= size; i++){<br/>       array[i] = i;<br/>   }<br/><br/>   int key;<br/>   printf("Enter key: ");<br/>   scanf("%d", &amp;key);<br/>   int result = binarySearch(array, 1, size, key);<br/>   (result == -1)? printf("Element is not present in array")<br/>                 : printf("Element is present at index %d", result);<br/>   return 0;<br/>}</span></pre><p id="059f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以，耶，耶，耶，耶，完成了。如果您想查看输出，请点击这里！</p><pre class="kj kk kl km gt kr ks kt ku aw kv bi"><span id="643f" class="kw kx in ks b gy ky kz l la lb">himabindu@dragonwarrior:~/Desktop/College/AA/AA-Lab$ time ./a.out<br/>Enter size of array: 10000000<br/>Enter key: 57000<br/>Element is present at index 57000</span><span id="ce9f" class="kw kx in ks b gy lc kz l la lb">real 0m6.737s<br/>user 0m0.045s<br/>sys 0m0.020s</span></pre><p id="6260" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">就是这样。感谢你阅读我的博客。</p><p id="96e5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">快乐学习🎈</p></div></div>    
</body>
</html>