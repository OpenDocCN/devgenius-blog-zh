<html>
<head>
<title>How Will Records Resolve the Getters and Setters Issue</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">记录将如何解决 Getters 和 Setters 问题</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-will-records-resolve-the-getters-and-setters-issue-60a06e56e9db?source=collection_archive---------4-----------------------#2022-11-02">https://blog.devgenius.io/how-will-records-resolve-the-getters-and-setters-issue-60a06e56e9db?source=collection_archive---------4-----------------------#2022-11-02</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><div class=""><h2 id="4e71" class="pw-subtitle-paragraph jo iq ir bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated">记录会让 getters 过时吗？</h2></div><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj kg"><img src="../Images/5b0c8d79396b21d474a381739a5fb0dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fzxJbYHLoDlHcYi5NUnFHA.jpeg"/></div></div><figcaption class="ks kt gk gi gj ku kv bd b be z dk translated">Brixiv 的照片:<a class="ae kw" href="https://www.pexels.com/photo/photo-of-a-border-collie-dog-catching-a-tennis-ball-at-the-beach-7316511/" rel="noopener ugc nofollow" target="_blank">https://www . pexels . com/photo/photo-a-border-collie-dog-catching-a-nettle-ball-at-beach-7316511/</a></figcaption></figure><p id="7f83" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><a class="ae kw" href="https://www.yegor256.com/2014/09/16/getters-and-setters-are-evil.html" rel="noopener ugc nofollow" target="_blank">吸气剂和设置剂是邪恶的</a>。或者他们不是。</p><p id="9c3d" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><strong class="kz is"> <em class="lt">无论哪种方式，你每天都在使用它们。</em>T9】</strong></p><p id="aa66" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><strong class="kz is"> <em class="lt">那么 Java 中的 getters 和 setters 会灭绝吗？未来什么会取代它们？除了 setters，我们还有其他选择吗？</em>T13】</strong></p><p id="8599" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">Lombok 已经着手解决 getters 问题。Lombok 为您生成了许多样板文件。Lombok 让生活变得更简单，但是 Java 会解决问题的根源。</p><p id="37ad" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><strong class="kz is"><em class="lt">Java 将如何解决 getters 和 setters 的问题？让我们看看。</em> </strong></p><h1 id="0963" class="lu lv ir bd lw lx ly lz ma mb mc md me jx mf jy mg ka mh kb mi kd mj ke mk ml bi translated">您仍将使用 getters 来隐藏实现</h1><p id="c1bb" class="pw-post-body-paragraph kx ky ir kz b la mm js lc ld mn jv lf lg mo li lj lk mp lm ln lo mq lq lr ls ik bi translated">大多数人认为 getters 公开了实现。结果是脆弱的代码。</p><p id="bc85" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><strong class="kz is"> <em class="lt">这是什么意思？如何用 getters 隐藏实现？</em> </strong></p><p id="de63" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">如果您可以更改实现，但 getter 可以保持不变，那么您就处于有利位置。所以 getters 应该与实现无关。</p><p id="9f11" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">是的，<code class="fe mr ms mt mu b">getX</code>对于 x 变量来说并不是一个伟大的设计。稍后我们将详细讨论记录如何解决这个问题。</p><p id="ef59" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><strong class="kz is"> <em class="lt">那么有什么好的吸气剂例子呢？</em>T25】</strong></p><p id="d775" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><strong class="kz is"><em class="lt">Spring 的</em></strong><a class="ae kw" href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/oauth2/core/user/OAuth2User.html" rel="noopener ugc nofollow" target="_blank"><strong class="kz is"><em class="lt">oauth 2 user</em></strong></a><strong class="kz is"><em class="lt">接口就是一个很好的例子。</em> </strong>它公开了<code class="fe mr ms mt mu b">getName</code>方法，在实现中可以有自己的东西。您的唯一名称可以是 JWT 解码的声明或用户属性。</p><p id="54f3" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">只要你兑现承诺，外面的客户不会在意。这让我们回到为什么 getters 是一个好的实践。</p><p id="9c65" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><strong class="kz is"> <em class="lt">也随着我们前进，吸气剂帮助我们清理。</em> </strong></p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="mv mw l"/></div></figure><p id="58b0" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">随着我们的进一步发展，我们可以这样做。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="mv mw l"/></div></figure><p id="587d" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">如果我们直接访问这些属性，会是什么样子？T47】</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="mv mw l"/></div></figure><p id="c69e" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">如果您更改为其他唯一标识符，您将需要更改类。</p><p id="bf52" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">此外，如果你搬到一个不同的物业，你将很难逐步淘汰旧物业。假设我们添加了 userId，但留下了 jwtClaim。您需要某种方式将它标记为不推荐使用。</p><p id="93ac" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">这里另一件重要的事情是不要将 getter 名称与底层实现捆绑在一起。正如我们在这里看到的，getter 是<code class="fe mr ms mt mu b">getName</code>，而不是<code class="fe mr ms mt mu b">getClaim</code>或<code class="fe mr ms mt mu b">getId</code>。</p><p id="9fba" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><strong class="kz is"> <em class="lt">为什么 getter 名字很重要？</em>T12】</strong></p><p id="af07" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">这减少了脑力劳动，因为我们不需要知道下面是什么。只要我们有一个唯一的标识符，我们就没事了。</p><p id="f397" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><em class="lt">使用 getters 我们能得到什么？</em>重构安全，API 不变，动作更快。</p><p id="55b8" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">Getter 名称对于抽象级别来说应该是正确的。如果使用<code class="fe mr ms mt mu b">getUserId</code>的话，依赖者是否需要知道课程提供了什么？最好将实现隐藏在一个<code class="fe mr ms mt mu b">getUniqueId</code>后面。</p></div><div class="ab cl mx my hv mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="ik il im in io"><p id="dfb6" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><strong class="kz is"> <em class="lt">暴露一切会导致不良使用。</em> </strong></p><p id="d172" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">比如<code class="fe mr ms mt mu b">Unsafe</code>在模块系统之前就曝光了。如果您已经从 Java 8 迁移到 Java 11，您会看到这个类。这是因为某些图书馆使用它，即使它是不安全的。</p><p id="5c50" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">这个类不是为公共使用而设计的，但是如果没有模块的话，Unsafe 是可以被访问的。当事情发生变化或者 Java 停止公开这个类时，您可能会失去支持。</p></div><div class="ab cl mx my hv mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="ik il im in io"><h1 id="0840" class="lu lv ir bd lw lx ne lz ma mb nf md me jx ng jy mg ka nh kb mi kd ni ke mk ml bi translated">您将使用 withers 创建不变的，而不是 setters</h1><p id="4f2a" class="pw-post-body-paragraph kx ky ir kz b la mm js lc ld mn jv lf lg mo li lj lk mp lm ln lo mq lq lr ls ik bi translated">初始化记录或设置某种状态的唯一方法是通过规范的构造函数。</p><p id="5533" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">因为变异，Setters 不受欢迎。记录只希望通过构造函数来保存突变。当然，开发人员利用(或滥用)这一事实，创建定制的 withers 来设置记录的部分更新。</p><pre class="kh ki kj kk gu nj mu nk nl aw nm bi"><span id="145f" class="nn lv ir mu b gz no np l nq nr">static Test fromA(double a) {  <br/>    double b = calc(a);  <br/>    double c = calc(a + b);  <br/>    return new Test(a,b,c);  <br/>}</span></pre><p id="767e" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">如果您希望从单个字段中计算其他记录成员，则可以使用此示例。唯一惯用的方法是这样做。没有其他方法，我们仍然可以调用紧凑构造函数。</p></div><div class="ab cl mx my hv mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="ik il im in io"><p id="a4a8" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><strong class="kz is"> <em class="lt">解决这个问题的一个办法就是枯萎。</em> </strong></p><p id="415c" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">Withers 可能会有一个用于添加 setter 逻辑的块。这样，您可以从一个参数中计算出一个成员。威瑟斯可以做的一个例子是:</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="mv mw l"/></div></figure><p id="fa46" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">今天我们已经有了类似的东西。那是龙目岛的<code class="fe mr ms mt mu b">WithBy</code>。</p><p id="fac0" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><code class="fe mr ms mt mu b"><a class="ae kw" href="https://github.com/projectlombok/lombok/issues/2368" rel="noopener ugc nofollow" target="_blank"><strong class="kz is"><em class="lt">WithBy</em></strong></a></code> <strong class="kz is"> <em class="lt">会像琥珀提供的马肩隆。</em> </strong></p><p id="1cce" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">至少想法是一样的。您将在 withers 中编写任意代码。如上例所示。</p><p id="fcf1" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><code class="fe mr ms mt mu b">with { /* your init code here*/ }</code></p><p id="9f1d" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">此外，如果你看一下由发表的关于 WithBy 的<a class="ae kw" href="https://github.com/projectlombok/lombok/issues/2368" rel="noopener ugc nofollow" target="_blank">评论，你会看到 Valhalla 和 Amber 将要解决的问题。比如自我参照型，这种原始瓦尔哈拉型是不会让发生的。这就是为什么这个问题需要一个语言解决方案。</a></p><p id="2c1d" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">正如龙目岛撰稿人所说，这里的另一个问题是不变性的成本。</p><p id="50a5" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">构建器对原始对象进行变异。所以如果你想改变 4 个属性，你总共有 2 个对象。对于 withers，将有 3 个中间对象。这将给 GC 带来压力，所以这也是 Java 应该解决的问题。 </p></div><div class="ab cl mx my hv mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="ik il im in io"><p id="43a8" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">Withers 将为嵌套对象操作提供更好的语法。T12】</p><p id="8d18" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">如果我们研究一下 WithBy 文档，我们会看到它解决了什么问题。对嵌套对象字段的修改变得很麻烦，而用 By sets 来简化这一操作。</p><pre class="kh ki kj kk gu nj mu nk nl aw nm bi"><span id="efac" class="nn lv ir mu b gz no np l nq nr">movie = movie.withDirector(movie.getDirector().withBirthDate(movie.getDirector().getBirthDate().plusDays(1)));</span></pre><p id="a83c" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">使用<code class="fe mr ms mt mu b">WithBy</code>,这应该可以归结为以下代码:</p><pre class="kh ki kj kk gu nj mu nk nl aw nm bi"><span id="29aa" class="nn lv ir mu b gz no np l nq nr">movie = movie.withDirectorBy(d -&gt; d.withBirthDateBy(bd -&gt; bd.plusDays(1)));</span></pre><p id="de33" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">对于 Java withers，将会是这样的<a class="ae kw" href="https://mail.openjdk.org/pipermail/amber-dev/2020-August/006485.html" rel="noopener ugc nofollow" target="_blank">:</a></p><pre class="kh ki kj kk gu nj mu nk nl aw nm bi"><span id="93a5" class="nn lv ir mu b gz no np l nq nr">minorityReport = minorityReport with { director with { dateOfBirth with { year = 1956 }}};</span></pre><h1 id="a831" class="lu lv ir bd lw lx ly lz ma mb mc md me jx mf jy mg ka mh kb mi kd mj ke mk ml bi translated">不变量的 Getters 没有意义</h1><p id="7a14" class="pw-post-body-paragraph kx ky ir kz b la mm js lc ld mn jv lf lg mo li lj lk mp lm ln lo mq lq lr ls ik bi translated">记录模式已经在远离 getters 方面做了很多工作。</p><p id="42f8" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">记录的另一个优点是快速重构。如果将记录与密封类型结合起来，重构会更容易。当您更改记录构造函数时，您也更改了每个 getter。</p><p id="a18f" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">密封类型到底能为你做什么？您可以<a class="ae kw" href="https://mail.openjdk.org/pipermail/amber-dev/2022-October/007518.html" rel="noopener ugc nofollow" target="_blank">将开关与记录及其类似元组的特性结合起来，以获得简洁的代码</a>。下面是没有穷举开关的示例代码。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="mv mw l"/></div></figure><p id="5867" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">和详尽的开关:</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="mv mw l"/></div></figure></div><div class="ab cl mx my hv mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="ik il im in io"><p id="c98b" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">如果使用密封类型，新的允许类型需要更新所有开关。穷举开关实现了这一特性。同样在未来，这个特性也会转移到任意职业。</p><p id="e98e" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">目前，解构对自定义类不起作用。这是一个枚举解构的错误。</p><p id="d984" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">如果你有以下定义。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="mv mw l"/></div></figure><p id="6e6e" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">下面的代码会抛出一个错误。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="mv mw l"/></div></figure></div><div class="ab cl mx my hv mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="ik il im in io"><p id="3e69" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><strong class="kz is"> <em class="lt">关于 getters 和 setters 将在哪里不复存在，你有其他想法吗？</em> </strong></p></div></div>    
</body>
</html>