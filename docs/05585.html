<html>
<head>
<title>Implementing Service Discovery for Microservices</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">实现微服务的服务发现</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/implementing-service-discovery-for-microservices-df737e012bc2?source=collection_archive---------0-----------------------#2021-09-13">https://blog.devgenius.io/implementing-service-discovery-for-microservices-df737e012bc2?source=collection_archive---------0-----------------------#2021-09-13</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><h1 id="ef4c" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">什么是服务发现？</h1><p id="9afe" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">对于使用微服务的开发人员来说，服务发现的概念应该很熟悉。</p><p id="1c6f" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">例如，如果服务A依赖于服务B，我们需要告诉服务A调用服务B，这是服务发现必须解决的问题。</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi ll"><img src="../Images/7120ba76d8ad6b9db651142cd5893f3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Nok5Pbkft-Sy3JxH.png"/></div></div></figure><ul class=""><li id="40ef" class="lx ly in kk b kl lg kp lh kt lz kx ma lb mb lf mc md me mf bi translated"><code class="fe mg mh mi mj b">Service B</code>向被称为<strong class="kk io">服务注册</strong>的<code class="fe mg mh mi mj b">Service Registry</code>注册自己</li><li id="54fc" class="lx ly in kk b kl mk kp ml kt mm kx mn lb mo lf mc md me mf bi translated"><code class="fe mg mh mi mj b">Service A</code>从<code class="fe mg mh mi mj b">Service Registry</code>发现<code class="fe mg mh mi mj b">Service B</code>的节点信息称为<strong class="kk io">服务发现</strong></li></ul><h1 id="764f" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">服务注册</h1><p id="985c" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">服务注册是针对服务器端的，在服务启动后需要注册，它分为几个部分。</p><ul class=""><li id="1bfb" class="lx ly in kk b kl lg kp lh kt lz kx ma lb mb lf mc md me mf bi translated">启动注册</li><li id="4b21" class="lx ly in kk b kl mk kp ml kt mm kx mn lb mo lf mc md me mf bi translated">定时更新</li><li id="4e2c" class="lx ly in kk b kl mk kp ml kt mm kx mn lb mo lf mc md me mf bi translated">撤退</li></ul><h1 id="c70f" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">启动注册</h1><p id="d6a5" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">当一个服务节点启动时，它需要注册自己<code class="fe mg mh mi mj b">Service Registry</code>，以便其他节点可以轻松地发现自己。当服务启动并准备好接受请求时，需要进行注册，并且将设置一个有效期，以防止进程在异常退出后被访问。</p><h1 id="d8a3" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">定时更新</h1><p id="eb90" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">相当于<code class="fe mg mh mi mj b">keep alive</code>周期性的告诉<code class="fe mg mh mi mj b">Service Registry</code>它还活着，可以继续服役。</p><h1 id="3170" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">撤退</h1><p id="c082" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">当一个进程退出时，我们应该主动撤销注册信息，以便调用者能够及时将请求分发到另一个节点。同时，go-zero保证了即使一个节点在没有主动注销的情况下退出，该节点也能通过自适应负载均衡及时脱网。</p><h1 id="a5b8" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">服务发现</h1><p id="7d1c" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">服务发现是针对调用方的，一般分为两类问题。</p><ul class=""><li id="6cbc" class="lx ly in kk b kl lg kp lh kt lz kx ma lb mb lf mc md me mf bi translated">库存提取</li><li id="b003" class="lx ly in kk b kl mk kp ml kt mm kx mn lb mo lf mc md me mf bi translated">增量手表</li></ul><p id="e877" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">还有一个常见的工程问题</p><ul class=""><li id="4f94" class="lx ly in kk b kl lg kp lh kt lz kx ma lb mb lf mc md me mf bi translated">应对服务发现失败</li></ul><p id="a4dc" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">当服务发现服务(例如etcd、consul、nacos等)出现时。)下去，我们不修改已经取过的端点列表，这样可以更好的保证我们所依赖的服务在etcd等之后仍然可以正常交互。倒下了。</p><h1 id="75e9" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">库存提取</h1><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi mp"><img src="../Images/4973f78b4c6d07a91cc97e09e57aa1d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*1DkRJdyaTPSXcb3Q.png"/></div></div></figure><p id="89b3" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">当<code class="fe mg mh mi mj b">Service A</code>启动时，它需要从<code class="fe mg mh mi mj b">Service Registry</code> : <code class="fe mg mh mi mj b">Service B1</code>，<code class="fe mg mh mi mj b">Service B2</code>，<code class="fe mg mh mi mj b">Service B3</code>中获取<code class="fe mg mh mi mj b">Service B</code>的现有节点列表，然后根据自己的负载均衡算法选择合适的节点发送请求。</p><h1 id="4de5" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">增量手表</h1><p id="235f" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">上图已经有<code class="fe mg mh mi mj b">Service B1</code>、<code class="fe mg mh mi mj b">Service B2</code>、<code class="fe mg mh mi mj b">Service B3</code>，如果<code class="fe mg mh mi mj b">Service B4</code>启动，那么我们需要通知<code class="fe mg mh mi mj b">Service A</code>有一个额外的节点。如图所示。</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi mq"><img src="../Images/2140a0a3dd2e180598d8907080b75bbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*19xzqsQX1pOmJm2n.png"/></div></div></figure><h1 id="38a0" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">服务发现失败</h1><p id="831a" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">对于服务调用者，我们都在内存中缓存一个可用节点列表。无论是使用<code class="fe mg mh mi mj b">etcd</code>、<code class="fe mg mh mi mj b">consul</code>还是<code class="fe mg mh mi mj b">nacos</code>，我们都可能会面临一次服务发现集群失败，以<code class="fe mg mh mi mj b">etcd</code>为例，当我们遇到<code class="fe mg mh mi mj b">etcd</code>失败时，我们需要冻结<code class="fe mg mh mi mj b">Service B</code>的节点信息而不改变它，此时一定不能清空节点信息，一旦清空就无法获取，而<code class="fe mg mh mi mj b">Service B</code>节点的节点很可能是正常的，<code class="fe mg mh mi mj b">go-zero</code>会自动隔离并恢复失败的节点。</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi mr"><img src="../Images/61e016c4b9292e3cbf5c5def1161772b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*-63cIZcKpjnCYeNV.png"/></div></div></figure><p id="eea6" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">这是服务注册和服务发现的基本原理，当然实现起来还是比较复杂的，所以我们先来看看<code class="fe mg mh mi mj b">go-zero</code>支持哪些服务发现方式。</p><h1 id="98ea" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">go-zero的内置服务发现</h1><p id="b461" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated"><code class="fe mg mh mi mj b">go-zero</code>默认支持三种服务发现方式。</p><ul class=""><li id="f801" class="lx ly in kk b kl lg kp lh kt lz kx ma lb mb lf mc md me mf bi translated">kubernetes基于端点的服务发现</li><li id="baf3" class="lx ly in kk b kl mk kp ml kt mm kx mn lb mo lf mc md me mf bi translated">基于etcd的服务发现</li><li id="a7a1" class="lx ly in kk b kl mk kp ml kt mm kx mn lb mo lf mc md me mf bi translated">直接联结</li><li id="25a9" class="lx ly in kk b kl mk kp ml kt mm kx mn lb mo lf mc md me mf bi translated">基于咨询的社区服务发现</li><li id="5430" class="lx ly in kk b kl mk kp ml kt mm kx mn lb mo lf mc md me mf bi translated">基于nacos的社区服务发现</li></ul><h1 id="323d" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">直接联结</h1><p id="63af" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">直接连接是最简单的方式，当我们的服务足够简单时，比如一台机器可以托管我们的业务，我们就可以这样使用它。</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi ms"><img src="../Images/96ae258e1f195f289c5c5cd3cc38f006.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*lal2IAFfr2AUC0yT.png"/></div></div></figure><p id="0aad" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">在<code class="fe mg mh mi mj b">rpc</code>配置文件中直接指定<code class="fe mg mh mi mj b">endpoints</code>，例如</p><pre class="lm ln lo lp gt mt mj mu mv aw mw bi"><span id="d171" class="mx jl in mj b gy my mz l na nb">Rpc:<br/>  Endpoints:<br/>  - 192.168.0.111:3456<br/>  - 192.168.0.112:3456</span></pre><p id="1fd6" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated"><code class="fe mg mh mi mj b">zrpc</code>调用者将把负载分配给这两个节点，其中一个有问题的节点<code class="fe mg mh mi mj b">zrpc</code>将自动退出，当该节点恢复时，将再次分配负载。</p><p id="a3c5" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">这种方法的缺点是不能动态添加节点，每个新节点都需要改变调用者的配置并重新启动。</p><h1 id="b132" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">基于etcd的服务发现</h1><p id="202e" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">一旦我们的服务达到一定的规模，因为一个服务可能依赖于许多服务，我们需要能够动态地添加和删除节点，而不必修改许多调用者配置和重新启动。</p><p id="08b9" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">常见的服务发现解决方案有<code class="fe mg mh mi mj b">etcd</code>、<code class="fe mg mh mi mj b">consul</code>、<code class="fe mg mh mi mj b">nacos</code>等。</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi nc"><img src="../Images/8ec6072dde6ecb291b56149f537b7669.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*EXoMoVKvr9Obl8_C.png"/></div></div></figure><p id="2348" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">go-zero有一个内置的基于<code class="fe mg mh mi mj b">etcd</code>的服务发现方案，使用如下。</p><pre class="lm ln lo lp gt mt mj mu mv aw mw bi"><span id="d5ad" class="mx jl in mj b gy my mz l na nb">Rpc:<br/>  Etcd:<br/>     Hosts:<br/>     - 192.168.0.111:2379<br/>     - 192.168.0.112:2379<br/>     - 192.168.0.113:2379<br/>     Key: user.rpc</span></pre><ul class=""><li id="1630" class="lx ly in kk b kl lg kp lh kt lz kx ma lb mb lf mc md me mf bi translated"><code class="fe mg mh mi mj b">Hosts</code>是<code class="fe mg mh mi mj b">etcd</code>集群地址</li><li id="b0c1" class="lx ly in kk b kl mk kp ml kt mm kx mn lb mo lf mc md me mf bi translated"><code class="fe mg mh mi mj b">Key</code>是注册服务的<code class="fe mg mh mi mj b">key</code></li></ul><h1 id="138b" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">基于Kubernetes端点的服务发现</h1><p id="cdc0" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">如果我们的服务部署在一个<code class="fe mg mh mi mj b">Kubernetes</code>集群上，<code class="fe mg mh mi mj b">Kubernetes</code>本身通过自己的<code class="fe mg mh mi mj b">etcd</code>管理集群状态，所有服务都将其节点信息注册到<code class="fe mg mh mi mj b">Endpoints</code>对象中，因此我们可以直接授予<code class="fe mg mh mi mj b">deployment</code>权限来读取集群的<code class="fe mg mh mi mj b">Endpoints</code>对象以获取节点信息。</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi nd"><img src="../Images/7644aa0f5b6abcc7d64dd196d86ba320.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*htqJH8GsL9xw8Q1E.png"/></div></div></figure><ul class=""><li id="5d3e" class="lx ly in kk b kl lg kp lh kt lz kx ma lb mb lf mc md me mf bi translated">启动时，<code class="fe mg mh mi mj b">Service B</code>的每个<code class="fe mg mh mi mj b">Pod</code>将向集群的<code class="fe mg mh mi mj b">Endpoints</code>注册</li><li id="abc6" class="lx ly in kk b kl mk kp ml kt mm kx mn lb mo lf mc md me mf bi translated">当<code class="fe mg mh mi mj b">Service A</code>的每个<code class="fe mg mh mi mj b">Pod</code>启动时，可以从集群的<code class="fe mg mh mi mj b">Endpoints</code>中获取<code class="fe mg mh mi mj b">Service B</code>的节点信息</li><li id="5fdd" class="lx ly in kk b kl mk kp ml kt mm kx mn lb mo lf mc md me mf bi translated">当<code class="fe mg mh mi mj b">Service B</code>的节点发生变化时，<code class="fe mg mh mi mj b">Service A</code>可以通过<code class="fe mg mh mi mj b">watch</code>集群的<code class="fe mg mh mi mj b">Endpoints</code>感知到</li></ul><p id="8493" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">在这个机制工作之前，我们需要配置当前<code class="fe mg mh mi mj b">namespace</code>中的<code class="fe mg mh mi mj b">pod</code>来访问集群<code class="fe mg mh mi mj b">Endpoints</code>，这里有三个概念。</p><ul class=""><li id="cd9e" class="lx ly in kk b kl lg kp lh kt lz kx ma lb mb lf mc md me mf bi translated">ClusterRole定义了一个不受<code class="fe mg mh mi mj b">namespace</code>控制的集群范围的权限角色。</li><li id="7b55" class="lx ly in kk b kl mk kp ml kt mm kx mn lb mo lf mc md me mf bi translated">ServiceAccount定义了<code class="fe mg mh mi mj b">namespace</code>范围内的<code class="fe mg mh mi mj b">service account</code></li><li id="5746" class="lx ly in kk b kl mk kp ml kt mm kx mn lb mo lf mc md me mf bi translated">ClusterRoleBinding将一个已定义的<code class="fe mg mh mi mj b">ClusterRole</code>绑定到另一个<code class="fe mg mh mi mj b">namespace</code>中的<code class="fe mg mh mi mj b">ServiceAccount</code></li></ul><p id="06fb" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">具体的<code class="fe mg mh mi mj b">Kubernetes</code>配置文件可以在<a class="ae ne" href="https://github.com/tal-tech/go-zero/tree/master/zrpc/internal/resolver/kube/deploy" rel="noopener ugc nofollow" target="_blank"> <strong class="kk io">这里找到</strong> </a>，其中<code class="fe mg mh mi mj b">namespace</code>根据需要进行修改。</p><p id="864c" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">注:记得在启动时检查这些配置是否到位，并且不能访问<code class="fe mg mh mi mj b">Endpoints</code>:)</p><p id="b313" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated"><code class="fe mg mh mi mj b">zrpc</code>的基于<code class="fe mg mh mi mj b">Kubernetes Endpoints</code>的服务发现使用如下。</p><pre class="lm ln lo lp gt mt mj mu mv aw mw bi"><span id="5570" class="mx jl in mj b gy my mz l na nb">Rpc:<br/>  Target: k8s://mynamespace/myservice:3456</span></pre><p id="e875" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">在哪里？</p><ul class=""><li id="6c90" class="lx ly in kk b kl lg kp lh kt lz kx ma lb mb lf mc md me mf bi translated"><code class="fe mg mh mi mj b">mynamespace</code>:被调用的<code class="fe mg mh mi mj b">rpc</code>服务所在的<code class="fe mg mh mi mj b">namespace</code></li><li id="b6c0" class="lx ly in kk b kl mk kp ml kt mm kx mn lb mo lf mc md me mf bi translated"><code class="fe mg mh mi mj b">myservice</code>:被调用的<code class="fe mg mh mi mj b">rpc</code>服务的名称</li><li id="987d" class="lx ly in kk b kl mk kp ml kt mm kx mn lb mo lf mc md me mf bi translated"><code class="fe mg mh mi mj b">3456</code>:被调用<code class="fe mg mh mi mj b">rpc</code>服务的端口</li></ul><p id="e9a2" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">确保添加<code class="fe mg mh mi mj b">serviceAccountName</code>来指定在创建<code class="fe mg mh mi mj b">deployment</code>配置文件时使用哪个<code class="fe mg mh mi mj b">ServiceAccount</code>，例如</p><pre class="lm ln lo lp gt mt mj mu mv aw mw bi"><span id="f2bf" class="mx jl in mj b gy my mz l na nb">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: alpine-deployment<br/>  labels:<br/>    app: alpine<br/>spec:<br/>  replicas: 1<br/>  selector:<br/>    matchLabels:<br/>      app: alpine<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: alpine<br/>    spec:<br/>      serviceAccountName: endpoints-reader<br/>      containers:<br/>      - name: alpine<br/>        image: alpine<br/>        command:<br/>        - sleep<br/>        - infinity</span></pre><p id="e8ea" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">注意<code class="fe mg mh mi mj b">serviceAccountName</code>指定哪个<code class="fe mg mh mi mj b">ServiceAccount</code>用于由<code class="fe mg mh mi mj b">deployment</code>创建的<code class="fe mg mh mi mj b">pod</code>。</p><p id="6a71" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">在<code class="fe mg mh mi mj b">server</code>和<code class="fe mg mh mi mj b">client</code>都部署到<code class="fe mg mh mi mj b">Kubernetes</code>集群后，您可以使用以下命令滚动重启所有<code class="fe mg mh mi mj b">server</code>节点</p><pre class="lm ln lo lp gt mt mj mu mv aw mw bi"><span id="fbed" class="mx jl in mj b gy my mz l na nb">kubectl rollout restart deploy -n adhoc server-deployment</span></pre><p id="0bd6" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">使用以下命令检查<code class="fe mg mh mi mj b">client</code>节点日志。</p><pre class="lm ln lo lp gt mt mj mu mv aw mw bi"><span id="c2a7" class="mx jl in mj b gy my mz l na nb">kubectl -n adhoc logs -f deploy/client-deployment --all-containers=true</span></pre><p id="3398" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">您可以看到我们的服务发现机制完美地跟随了<code class="fe mg mh mi mj b">server</code>节点的变化，并且在服务更新期间没有异常请求。</p><p id="3ceb" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">完整的代码示例可从[https://github . com/zero micro/zero-examples/tree/main/discovery/k8s](https://github . com/zero micro/zero-examples/tree/main/discovery/k8s)获得</p><p id="1a56" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">在下一篇文章中，我将解释如何基于<code class="fe mg mh mi mj b">consul</code>、<code class="fe mg mh mi mj b">nacos</code>等实现服务注册发现。在<code class="fe mg mh mi mj b">go-zero</code>，敬请期待！</p><h1 id="6081" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">项目地址</h1><p id="850e" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated"><a class="ae ne" href="https://github.com/tal-tech/go-zero" rel="noopener ugc nofollow" target="_blank"><strong class="kk io">https://github.com/tal-tech/go-zero</strong></a></p><p id="7897" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">欢迎用<code class="fe mg mh mi mj b">go-zero</code>和<strong class="kk io">星</strong>支持我们！</p></div></div>    
</body>
</html>