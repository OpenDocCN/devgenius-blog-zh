<html>
<head>
<title>Variadic Template C++: Implementing Unsophisticated Tuple</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">可变模板 C++:实现简单的元组</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/variadic-template-c-implementing-unsophisticated-tuple-b5fb1cf70d0?source=collection_archive---------23-----------------------#2020-06-15">https://blog.devgenius.io/variadic-template-c-implementing-unsophisticated-tuple-b5fb1cf70d0?source=collection_archive---------23-----------------------#2020-06-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/189e17098d5fd30ad3dda315332764bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d6oNEuiiktvUYsmt0qrsIA.png"/></div></div></figure><p id="51f9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从 C++11 开始，<code class="fe kw kx ky kz b"><a class="ae la" href="https://en.cppreference.com/w/cpp/utility/tuple" rel="noopener ugc nofollow" target="_blank">std::tuple</a></code>是对<a class="ae la" href="http://www.vishalchovatiya.com/21-new-features-of-modern-cpp-to-use-in-your-project/" rel="noopener ugc nofollow" target="_blank">现代 C++ </a>的惊人扩展，它提供了一个固定大小的不同值的集合。当然，用传统的方式来处理这些问题可能会有些可疑。但是，随后发布的 C++标准引入了几个特性&amp;助手，大大减少了必要的工作量。因此，在本文中，我将借助简单的元组实现来解释 C++中的变量模板。并带您了解 tuple 的一个棘手部分，即 tuple 元素的循环。尽管事实上我在之前的文章中已经掩盖了可变模板，即<a class="ae la" href="http://www.vishalchovatiya.com/cpp-template-a-quick-uptodate-look/" rel="noopener ugc nofollow" target="_blank"> C++模板:快速更新查看</a>。因此，我在这里的重点是混合可变模板&amp;元组实现和更多最新的 C++规范。</p><blockquote class="lb lc ld"><p id="3fee" class="jy jz le ka b kb kc kd ke kf kg kh ki lf kk kl km lg ko kp kq lh ks kt ku kv ij bi translated"><em class="iq"> /！\:原载@ www.vishalchovatiya.com</em><a class="ae la" href="http://www.vishalchovatiya.com/" rel="noopener ugc nofollow" target="_blank"><em class="iq"/></a><em class="iq">。</em></p></blockquote><h1 id="f884" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">动机</h1><ul class=""><li id="48f6" class="mg mh iq ka b kb mi kf mj kj mk kn ml kr mm kv mn mo mp mq bi translated">定义接受可变数量和类型的参数的类/结构/联合/函数通常很有用。</li><li id="140b" class="mg mh iq ka b kb mr kf ms kj mt kn mu kr mv kv mn mo mp mq bi translated">如果你已经使用过 C 语言，你会知道<code class="fe kw kx ky kz b">printf</code>函数可以接受任意数量的参数。这些功能完全通过宏或<a class="ae la" href="https://stackoverflow.com/questions/3792761/what-is-ellipsis-operator-in-c" rel="noopener ugc nofollow" target="_blank">省略号运算符</a>实现。正因为如此，它有几个缺点，如<a class="ae la" href="http://www.vishalchovatiya.com/cpp-type-casting-with-example-for-c-developers/" rel="noopener ugc nofollow" target="_blank">类型安全</a>，不能接受引用作为参数，等等。</li></ul><h1 id="eba0" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">可变类模板:实现元组类</h1><ul class=""><li id="d17c" class="mg mh iq ka b kb mi kf mj kj mk kn ml kr mm kv mn mo mp mq bi translated">所以，让我们借助变量模板构建自己的<a class="ae la" href="https://en.wikipedia.org/wiki/Abstract_data_type" rel="noopener ugc nofollow" target="_blank"> ADT </a>和<code class="fe kw kx ky kz b"><a class="ae la" href="https://en.cppreference.com/w/cpp/utility/tuple" rel="noopener ugc nofollow" target="_blank">std::tuple</a></code>一样。</li><li id="2d8e" class="mg mh iq ka b kb mr kf ms kj mt kn mu kr mv kv mn mo mp mq bi translated">C++中的变量模板通常从通用(空)定义开始，这也是后面专门化中模板递归终止的基础:</li></ul><pre class="mw mx my mz gt na kz nb nc aw nd bi"><span id="455e" class="ne lj iq kz b gy nf ng l nh ni">template &lt;typename... T&gt;<br/>struct Tuple { };</span></pre><ul class=""><li id="97d1" class="mg mh iq ka b kb kc kf kg kj nj kn nk kr nl kv mn mo mp mq bi translated">这已经允许我们定义一个空结构，即<code class="fe kw kx ky kz b">Tuple&lt;&gt; object;</code>，尽管这还不是很有用。接下来是递归案例专门化:</li></ul><pre class="mw mx my mz gt na kz nb nc aw nd bi"><span id="066b" class="ne lj iq kz b gy nf ng l nh ni">template&lt;<br/>            typename T, <br/>            typename... Rest    // Template parameter pack<br/>        &gt;<br/>struct Tuple&lt;T, Rest...&gt; {      // Class parameter pack<br/>    T first;<br/>    Tuple&lt;Rest...&gt; rest;        // Parameter pack expansion</span><span id="8d48" class="ne lj iq kz b gy nm ng l nh ni">    Tuple(const T&amp; f, const Rest&amp; ... r)<br/>        : first(f)<br/>        , rest(r...) {<br/>    }<br/>};</span><span id="6f2b" class="ne lj iq kz b gy nm ng l nh ni">Tuple&lt;bool&gt;                 t1(false);           // Case 1<br/>Tuple&lt;int, char, string&gt;    t2(1, 'a', "ABC");   // Case 2</span></pre><h1 id="fe8c" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">可变类模板是如何工作的？</h1><p id="cf46" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj nn kl km kn no kp kq kr np kt ku kv ij bi translated">为了理解可变类模板，考虑上面的用例 2，即<code class="fe kw kx ky kz b">Tuple&lt;int, char, string&gt; t2(1, 'a', "ABC");</code></p><ul class=""><li id="486b" class="mg mh iq ka b kb kc kf kg kj nj kn nk kr nl kv mn mo mp mq bi translated">声明首先匹配专门化，产生一个具有<code class="fe kw kx ky kz b">int first;</code>和<code class="fe kw kx ky kz b">Tuple&lt;char, string&gt; rest;</code>数据成员的结构。</li><li id="f463" class="mg mh iq ka b kb mr kf ms kj mt kn mu kr mv kv mn mo mp mq bi translated">rest 定义再次与专门化匹配，产生一个具有<code class="fe kw kx ky kz b">char first;</code>和<code class="fe kw kx ky kz b">Tuple&lt;string&gt; rest;</code>数据成员的结构。</li><li id="9e45" class="mg mh iq ka b kb mr kf ms kj mt kn mu kr mv kv mn mo mp mq bi translated">rest 定义再次匹配这个专门化，创建自己的<code class="fe kw kx ky kz b">string first;</code>和<code class="fe kw kx ky kz b">Tuple&lt;&gt; rest;</code>成员。</li><li id="c2ea" class="mg mh iq ka b kb mr kf ms kj mt kn mu kr mv kv mn mo mp mq bi translated">最后，这最后一个 rest 与基本用例定义相匹配，产生一个空结构。</li></ul><p id="58e6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以这样想象:</p><pre class="mw mx my mz gt na kz nb nc aw nd bi"><span id="9b1b" class="ne lj iq kz b gy nf ng l nh ni">Tuple&lt;int, char, string&gt;<br/>-&gt; int first<br/>-&gt; Tuple&lt;char, string&gt; rest<br/>    -&gt; char first<br/>    -&gt; Tuple&lt;string&gt; rest<br/>        -&gt; string first<br/>        -&gt; Tuple&lt;&gt; rest<br/>            -&gt; (empty)</span></pre><h1 id="c307" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">可变函数模板:为元组类实现 get &lt;&gt;()函数</h1><ul class=""><li id="64e5" class="mg mh iq ka b kb mi kf mj kj mk kn ml kr mm kv mn mo mp mq bi translated">到目前为止，我们已经设计了具有可变数量和类型的数据成员的数据结构。但是，它仍然没有用，因为没有从我们的元组类中检索数据的机制。所以让我们设计一个:</li></ul><pre class="mw mx my mz gt na kz nb nc aw nd bi"><span id="efbc" class="ne lj iq kz b gy nf ng l nh ni">template&lt;<br/>            size_t idx, <br/>            template &lt;typename...&gt; class Tuple, <br/>            typename... Args<br/>        &gt;<br/>auto get(Tuple&lt;Args...&gt; &amp;t) {<br/>    return GetHelper&lt;idx, Tuple&lt;Args...&gt;&gt;::get(t);<br/>}</span></pre><ul class=""><li id="cceb" class="mg mh iq ka b kb kc kf kg kj nj kn nk kr nl kv mn mo mp mq bi translated">如您所见，这个 get 函数在<code class="fe kw kx ky kz b">idx</code>上被模板化了。所以用法可以像<code class="fe kw kx ky kz b">get&lt;1&gt;(t)</code>，类似<code class="fe kw kx ky kz b"><a class="ae la" href="https://en.cppreference.com/w/cpp/utility/tuple" rel="noopener ugc nofollow" target="_blank">std::tuple</a></code>。然而，实际的工作是由一个助手类中的静态函数完成的，例如<code class="fe kw kx ky kz b">GetHelper</code>。</li><li id="844f" class="mg mh iq ka b kb mr kf ms kj mt kn mu kr mv kv mn mo mp mq bi translated">还要注意 C++14 风格的<code class="fe kw kx ky kz b">auto</code>返回类型的使用使我们的生活变得非常简单，否则，我们将需要一个非常复杂的返回类型表达式。</li><li id="7010" class="mg mh iq ka b kb mr kf ms kj mt kn mu kr mv kv mn mo mp mq bi translated">如此继续到助手类。这一次我们将需要一个空的 forward 声明和两个专门化。首先是空的声明:</li></ul><pre class="mw mx my mz gt na kz nb nc aw nd bi"><span id="b9b4" class="ne lj iq kz b gy nf ng l nh ni">template&lt;<br/>            size_t idx, <br/>            typename T<br/>        &gt;<br/>struct GetHelper;</span></pre><ul class=""><li id="9017" class="mg mh iq ka b kb kc kf kg kj nj kn nk kr nl kv mn mo mp mq bi translated">现在是基本情况(当<code class="fe kw kx ky kz b">idx==0</code>)。在这个专门化中，我们只返回第一个成员:</li></ul><pre class="mw mx my mz gt na kz nb nc aw nd bi"><span id="7c91" class="ne lj iq kz b gy nf ng l nh ni">template&lt;<br/>            typename T, <br/>            typename... Rest<br/>        &gt;<br/>struct GetHelper&lt;0, Tuple&lt;T, Rest...&gt;&gt; {<br/>    static T get(Tuple&lt;T, Rest...&gt; &amp;data) {<br/>        return data.first;<br/>    }<br/>};</span></pre><ul class=""><li id="7371" class="mg mh iq ka b kb kc kf kg kj nj kn nk kr nl kv mn mo mp mq bi translated">在递归情况下，我们递减<code class="fe kw kx ky kz b">idx</code>并为 rest 成员调用<code class="fe kw kx ky kz b">GetHelper</code>:</li></ul><pre class="mw mx my mz gt na kz nb nc aw nd bi"><span id="862e" class="ne lj iq kz b gy nf ng l nh ni">template&lt;<br/>            size_t idx, <br/>            typename T, <br/>            typename... Rest<br/>        &gt;<br/>struct GetHelper&lt;idx, Tuple&lt;T, Rest...&gt;&gt; {<br/>    static auto get(Tuple&lt;T, Rest...&gt; &amp;data) {<br/>        return GetHelper&lt;idx - 1, Tuple&lt;Rest...&gt;&gt;::get(data.rest);<br/>    }<br/>};</span></pre><ul class=""><li id="3db8" class="mg mh iq ka b kb kc kf kg kj nj kn nk kr nl kv mn mo mp mq bi translated">举个例子，假设我们有元组数据，我们需要<code class="fe kw kx ky kz b">get&lt;1&gt;(data)</code>。</li><li id="61cf" class="mg mh iq ka b kb mr kf ms kj mt kn mu kr mv kv mn mo mp mq bi translated">这调用了<code class="fe kw kx ky kz b">GetHelper&lt;1, Tuple&lt;T, Rest...&gt;&gt;&gt;::get(data)</code>(第二个专门化)。</li><li id="eb05" class="mg mh iq ka b kb mr kf ms kj mt kn mu kr mv kv mn mo mp mq bi translated">进而调用<code class="fe kw kx ky kz b">GetHelper&lt;0, Tuple&lt;T, Rest...&gt;&gt;&gt;::get(data.rest)</code>。</li><li id="3b49" class="mg mh iq ka b kb mr kf ms kj mt kn mu kr mv kv mn mo mp mq bi translated">并且最终返回(通过第一次特化，因为现在<code class="fe kw kx ky kz b">idx</code>是 0) <code class="fe kw kx ky kz b">data.rest.first</code>。</li></ul><p id="be80" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">原来如此！下面是完整的功能代码，以及 main 函数中的一些使用示例:</p><pre class="mw mx my mz gt na kz nb nc aw nd bi"><span id="75b5" class="ne lj iq kz b gy nf ng l nh ni">// Forward Declaration &amp; Base Case -----------------------------------------<br/>template&lt;<br/>            size_t idx,<br/>            typename T<br/>        &gt;<br/>struct GetHelper { };</span><span id="55ea" class="ne lj iq kz b gy nm ng l nh ni">template &lt;typename... T&gt;<br/>struct Tuple { };<br/>// -------------------------------------------------------------------------</span><span id="9c03" class="ne lj iq kz b gy nm ng l nh ni">// GetHelper ---------------------------------------------------------------<br/>template&lt;<br/>            typename T,<br/>            typename... Rest<br/>        &gt;<br/>struct GetHelper&lt;0, Tuple&lt;T, Rest...&gt;&gt; { // Specialization for index 0<br/>    static T get(Tuple&lt;T, Rest...&gt; &amp;data) {<br/>        return data.first;<br/>    }<br/>};</span><span id="a2ff" class="ne lj iq kz b gy nm ng l nh ni">template&lt;<br/>            size_t idx,<br/>            typename T,<br/>            typename... Rest<br/>        &gt;<br/>struct GetHelper&lt;idx, Tuple&lt;T, Rest...&gt;&gt; { // GetHelper Implementation<br/>    static auto get(Tuple&lt;T, Rest...&gt; &amp;data) {<br/>        return GetHelper&lt;idx - 1, Tuple&lt;Rest...&gt;&gt;::get(data.rest);<br/>    }<br/>};<br/>// -------------------------------------------------------------------------</span><span id="fd6f" class="ne lj iq kz b gy nm ng l nh ni">// Tuple Implementation ----------------------------------------------------<br/>template&lt;<br/>            typename T,<br/>            typename... Rest<br/>        &gt;<br/>struct Tuple&lt;T, Rest...&gt; {<br/>    T                   first;<br/>    Tuple&lt;Rest...&gt;      rest;</span><span id="121f" class="ne lj iq kz b gy nm ng l nh ni">    Tuple(const T &amp;f, const Rest &amp;... r)<br/>        : first(f)<br/>        , rest(r...) {<br/>    }<br/>};<br/>// -------------------------------------------------------------------------<br/></span><span id="12b3" class="ne lj iq kz b gy nm ng l nh ni">// get Implementation ------------------------------------------------------<br/>template&lt;<br/>            size_t idx, <br/>            template &lt;typename...&gt; class Tuple, <br/>            typename... Args<br/>        &gt;<br/>auto get(Tuple&lt;Args...&gt; &amp;t) {<br/>    return GetHelper&lt;idx, Tuple&lt;Args...&gt;&gt;::get(t);<br/>}<br/>// -------------------------------------------------------------------------<br/></span><span id="ae42" class="ne lj iq kz b gy nm ng l nh ni">int main() {<br/>    Tuple&lt;int, char, string&gt; t(500, 'a', "ABC");<br/>    cout &lt;&lt; get&lt;1&gt;(t) &lt;&lt; endl;<br/>    return 0;<br/>}</span></pre><h1 id="4e65" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">可变模板 vs 折叠表达式</h1><ul class=""><li id="7f59" class="mg mh iq ka b kb mi kf mj kj mk kn ml kr mm kv mn mo mp mq bi translated">有两种方法处理 C++参数包，即</li></ul><ol class=""><li id="e89b" class="mg mh iq ka b kb kc kf kg kj nj kn nk kr nl kv nq mo mp mq bi translated">递归</li><li id="822a" class="mg mh iq ka b kb mr kf ms kj mt kn mu kr mv kv nq mo mp mq bi translated">折叠表达式(来自 C++17)</li></ol><ul class=""><li id="c43a" class="mg mh iq ka b kb kc kf kg kj nj kn nk kr nl kv mn mo mp mq bi translated">在任何可能的情况下，我们都应该用折叠表达式处理参数包，而不是使用递归。因为它有一些好处:</li><li id="1f94" class="mg mh iq ka b kb mr kf ms kj mt kn mu kr mv kv mn mo mp mq bi translated">需要编写的代码更少</li><li id="c6f2" class="mg mh iq ka b kb mr kf ms kj mt kn mu kr mv kv mn mo mp mq bi translated">更快的代码(没有优化)，因为你只有一个单一的表达式，而不是多个函数调用</li><li id="7692" class="mg mh iq ka b kb mr kf ms kj mt kn mu kr mv kv mn mo mp mq bi translated">编译速度更快，因为您处理的模板实例更少</li></ul><h1 id="fdcb" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">用递归处理参数包</h1><ul class=""><li id="5036" class="mg mh iq ka b kb mi kf mj kj mk kn ml kr mm kv mn mo mp mq bi translated">正如我们前面看到的，可变模板从空定义开始，即递归的基本情况。</li></ul><pre class="mw mx my mz gt na kz nb nc aw nd bi"><span id="6c55" class="ne lj iq kz b gy nf ng l nh ni">void  print()  {}</span></pre><ul class=""><li id="cfb2" class="mg mh iq ka b kb kc kf kg kj nj kn nk kr nl kv mn mo mp mq bi translated">然后是递归案例专门化:</li></ul><pre class="mw mx my mz gt na kz nb nc aw nd bi"><span id="d129" class="ne lj iq kz b gy nf ng l nh ni">template&lt;   <br/>            typename First, <br/>            typename... Rest                    // Template parameter pack<br/>        &gt;     <br/>void print(First first, Rest... rest) {         // Function parameter pack<br/>    cout &lt;&lt; first &lt;&lt; endl;<br/>    print(rest...);                             // Parameter pack expansion<br/>}</span></pre><ul class=""><li id="8c03" class="mg mh iq ka b kb kc kf kg kj nj kn nk kr nl kv mn mo mp mq bi translated">这就足以让我们使用变量数目和变量类型的打印函数了。例如:</li></ul><pre class="mw mx my mz gt na kz nb nc aw nd bi"><span id="1a07" class="ne lj iq kz b gy nf ng l nh ni">print(500, 'a', "ABC");</span></pre><h1 id="ead2" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">用折叠表达式处理参数包</h1><pre class="mw mx my mz gt na kz nb nc aw nd bi"><span id="c46a" class="ne lj iq kz b gy nf ng l nh ni">template &lt;typename... Args&gt;<br/>void print(Args... args) {<br/>    (void(cout &lt;&lt; args &lt;&lt; endl), ...);<br/>}</span></pre><ul class=""><li id="f00d" class="mg mh iq ka b kb kc kf kg kj nj kn nk kr nl kv mn mo mp mq bi translated">看，不需要神秘的样板。这个解决方案看起来不是更整洁吗？</li><li id="f3a3" class="mg mh iq ka b kb mr kf ms kj mt kn mu kr mv kv mn mo mp mq bi translated">总共有 3 种折叠方式:一元折叠、二元折叠和逗号折叠。这里我们已经完成了对逗号的左折叠。你可以点击阅读更多关于折叠表达式<a class="ae la" href="https://www.codingame.com/playgrounds/2205/7-features-of-c17-that-will-simplify-your-code/fold-expressions" rel="noopener ugc nofollow" target="_blank">的内容。</a></li></ul><h1 id="9d44" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">在 C++中循环遍历/迭代元组元素</h1><ul class=""><li id="a2a7" class="mg mh iq ka b kb mi kf mj kj mk kn ml kr mm kv mn mo mp mq bi translated">如果我给你一个打印元组元素的任务，你首先想到的是:</li></ul><pre class="mw mx my mz gt na kz nb nc aw nd bi"><span id="8097" class="ne lj iq kz b gy nf ng l nh ni">template &lt;typename... Args&gt;<br/>void print(const std::tuple&lt;Args...&gt; &amp;t) {<br/>    for (const auto &amp;elem : t) // Error: no begin/end iterator<br/>        cout &lt;&lt; elem &lt;&lt; endl;<br/>}</span></pre><ul class=""><li id="bce7" class="mg mh iq ka b kb kc kf kg kj nj kn nk kr nl kv mn mo mp mq bi translated">但是，这样不行。<code class="fe kw kx ky kz b"><a class="ae la" href="https://en.cppreference.com/w/cpp/utility/tuple" rel="noopener ugc nofollow" target="_blank">std::tuple</a></code>没有<code class="fe kw kx ky kz b">begin</code> &amp; <code class="fe kw kx ky kz b">end</code>迭代器。</li><li id="0c49" class="mg mh iq ka b kb mr kf ms kj mt kn mu kr mv kv mn mo mp mq bi translated">好吧！所以，现在你可以尝试原始循环，对吗？</li></ul><pre class="mw mx my mz gt na kz nb nc aw nd bi"><span id="7a19" class="ne lj iq kz b gy nf ng l nh ni">template &lt;typename... Args&gt;<br/>void print(const std::tuple&lt;Args...&gt;&amp;   t) {<br/>    for (int i = 0; i &lt; sizeof...(Args); ++i)<br/>        cout &lt;&lt; std::get&lt;i&gt;(t) &lt;&lt; endl;    // Error :( , `i` needs to be compile time constant<br/>}</span></pre><ul class=""><li id="b41d" class="mg mh iq ka b kb kc kf kg kj nj kn nk kr nl kv mn mo mp mq bi translated">不要！你不能。我知道<code class="fe kw kx ky kz b">std::get&lt;&gt;</code>使用一个数字作为<a class="ae la" href="http://www.vishalchovatiya.com/cpp-template-a-quick-uptodate-look/#Non-Type_Template_Parameter" rel="noopener ugc nofollow" target="_blank">非类型模板参数</a>。</li><li id="4efe" class="mg mh iq ka b kb mr kf ms kj mt kn mu kr mv kv mn mo mp mq bi translated">但是，这个数字必须在编译时保持不变才能工作。所以有很多解决方案，我们会一一列举。</li></ul><h1 id="be4e" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">C++11:循环遍历元组元素</h1><pre class="mw mx my mz gt na kz nb nc aw nd bi"><span id="c924" class="ne lj iq kz b gy nf ng l nh ni">// Template recursion<br/>template &lt;size_t i, typename... Args&gt;<br/>struct printer  {<br/>    static void print(const tuple&lt;Args...&gt; &amp;t) {<br/>        cout &lt;&lt; get&lt;i&gt;(t) &lt;&lt; endl;<br/>        printer&lt;i + 1, Args...&gt;::print(t);<br/>    }<br/>};</span><span id="abb4" class="ne lj iq kz b gy nm ng l nh ni">// Terminating template specialisation<br/>template &lt;typename... Args&gt;<br/>struct printer&lt;sizeof...(Args), Args...&gt; {<br/>    static void print(const tuple&lt;Args...&gt; &amp;) {}<br/>};</span><span id="3925" class="ne lj iq kz b gy nm ng l nh ni">template &lt;typename... Args&gt;<br/>void print(const tuple&lt;Args...&gt; &amp;t) {<br/>    printer&lt;0, Args...&gt;::print(t);<br/>}</span><span id="3311" class="ne lj iq kz b gy nm ng l nh ni">tuple&lt;int, char, string&gt; t(1, 'A', "ABC");<br/>print(t);<br/>// Note: might not work in GCC, I've used clang</span></pre><ul class=""><li id="8e94" class="mg mh iq ka b kb kc kf kg kj nj kn nk kr nl kv mn mo mp mq bi translated">相信我，这并没有看起来那么复杂。如果你知道递归和模板专门化，你不会花超过 30 秒的时间来弄清楚这里发生了什么。</li><li id="8780" class="mg mh iq ka b kb mr kf ms kj mt kn mu kr mv kv mn mo mp mq bi translated">对于我们的例子<code class="fe kw kx ky kz b">tuple&lt;int, char, string&gt; t(1, 'A', "ABC");</code>，<code class="fe kw kx ky kz b">printer::print()</code>每次用递增的非类型模板参数<code class="fe kw kx ky kz b">i</code>调用模板递归，即<code class="fe kw kx ky kz b">template&lt;size_t i, typename... Args&gt; struct printer{};</code>。当<code class="fe kw kx ky kz b">i == sizeof...(Args)</code>出现时，我们的回收通过调用模板特殊化即<code class="fe kw kx ky kz b">template&lt;typename... Args&gt; struct printer&lt;sizeof...(Args), Args...&gt; { };</code>停止。</li></ul><h1 id="f270" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">C++17:循环遍历元组元素</h1><ul class=""><li id="c96a" class="mg mh iq ka b kb mi kf mj kj mk kn ml kr mm kv mn mo mp mq bi translated">用 C++ 17，稍微好一点，因为我们有 Fold 表达式。所以，我们不再需要递归了。</li></ul><pre class="mw mx my mz gt na kz nb nc aw nd bi"><span id="8074" class="ne lj iq kz b gy nf ng l nh ni">template &lt;typename... Args&gt;<br/>void print(const std::tuple&lt;Args...&gt; &amp;t) {<br/>    std::apply([](const auto &amp;... args) {<br/>        ((cout &lt;&lt; args &lt;&lt; endl), ...);<br/>    }, t);<br/>}</span></pre><ul class=""><li id="679d" class="mg mh iq ka b kb kc kf kg kj nj kn nk kr nl kv mn mo mp mq bi translated"><code class="fe kw kx ky kz b"><a class="ae la" href="https://en.cppreference.com/w/cpp/utility/apply" rel="noopener ugc nofollow" target="_blank">std::apply</a></code>设计为元组助手，接受仿函数或<a class="ae la" href="http://www.vishalchovatiya.com/learn-lambda-function-in-cpp-with-example/" rel="noopener ugc nofollow" target="_blank"> lambda 表达式</a>。虽然如果想要根据类型分派到不同的实现，您可以做得更好，但是您可以使用<code class="fe kw kx ky kz b">overloaded</code>类:</li></ul><pre class="mw mx my mz gt na kz nb nc aw nd bi"><span id="90b5" class="ne lj iq kz b gy nf ng l nh ni">template &lt;class... Ts&gt;<br/>struct overloaded : Ts... {<br/>    using Ts::operator()...;<br/>};</span><span id="90bb" class="ne lj iq kz b gy nm ng l nh ni">// Deduction guide, google `CTAD for aggregates` for more info<br/>template &lt;class... Ts&gt;<br/>overloaded(Ts...) -&gt; overloaded&lt;Ts...&gt;;   // not needed from C++20</span><span id="3676" class="ne lj iq kz b gy nm ng l nh ni">auto f = overloaded {<br/>    [](const int &amp;a)        { cout &lt;&lt; "From int: " &lt;&lt; a &lt;&lt; endl; },<br/>    [](const char &amp;b)       { cout &lt;&lt; "From char: " &lt;&lt; b &lt;&lt; endl; },<br/>    [](const string &amp;c)     { cout &lt;&lt; "From string: " &lt;&lt; c &lt;&lt; endl; },<br/>};</span><span id="c73b" class="ne lj iq kz b gy nm ng l nh ni">tuple&lt;int, char, string&gt;    t(1, 'A', "ABC");<br/>std::apply([&amp;](const auto &amp;... e) { (f(e), ...); }, t);</span></pre><h1 id="e74c" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">C++23:循环遍历元组元素</h1><pre class="mw mx my mz gt na kz nb nc aw nd bi"><span id="f5e3" class="ne lj iq kz b gy nf ng l nh ni">template &lt;typename... Args&gt;<br/>void print(const std::tuple&lt;Args...&gt; &amp;t) {<br/>    for... (const auto &amp;elem : t)<br/>        cout &lt;&lt; elem &lt;&lt; endl;<br/>}</span></pre><ul class=""><li id="141d" class="mg mh iq ka b kb kc kf kg kj nj kn nk kr nl kv mn mo mp mq bi translated">因此，从 C++23 我们可能有<a class="ae la" href="http://wg21.link/p1306" rel="noopener ugc nofollow" target="_blank">扩展语句</a>也就是<code class="fe kw kx ky kz b">for...()</code>。这看起来像一个循环，但它不是。它只是用模板标出每个调用范围，如下所示:</li></ul><pre class="mw mx my mz gt na kz nb nc aw nd bi"><span id="be70" class="ne lj iq kz b gy nf ng l nh ni">template &lt;typename... Args&gt;<br/>void print(const tuple&lt;Args...&gt; &amp;t) {<br/>    {<br/>        const auto &amp;elem = get&lt;0&gt;(t);<br/>        cout &lt;&lt; elem &lt;&lt; endl;<br/>    }<br/>    {<br/>        const auto &amp;elem = get&lt;1&gt;(t);<br/>        cout &lt;&lt; elem &lt;&lt; endl;<br/>    }<br/>    {<br/>        const auto &amp;elem = get&lt;2&gt;(t);<br/>        cout &lt;&lt; elem &lt;&lt; endl;<br/>    }<br/>}</span></pre><ul class=""><li id="af6e" class="mg mh iq ka b kb kc kf kg kj nj kn nk kr nl kv mn mo mp mq bi translated">而且很明显，没有<code class="fe kw kx ky kz b">break</code> &amp; <code class="fe kw kx ky kz b">continue</code>因为它不是循环。</li><li id="bfda" class="mg mh iq ka b kb mr kf ms kj mt kn mu kr mv kv mn mo mp mq bi translated">它基本上适用于所有可以通过<code class="fe kw kx ky kz b">std::get&lt;&gt;()</code>访问的标准容器。例如，普通数组、<code class="fe kw kx ky kz b">std::tuple</code>、<code class="fe kw kx ky kz b">std::pair</code>、<code class="fe kw kx ky kz b">std::array</code>、未展开的参数包、constexpr 范围等。</li></ul><h1 id="fa15" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">结束语</h1><p id="cf7a" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj nn kl km kn no kp kq kr np kt ku kv ij bi translated">我们的 tuple 类中还缺少很多东西，比如<a class="ae la" href="http://www.vishalchovatiya.com/all-about-copy-constructor-in-cpp-with-example/" rel="noopener ugc nofollow" target="_blank">复制构造函数</a>、<a class="ae la" href="http://www.vishalchovatiya.com/move-constructor-assignment-operator-with-shared-ptr/" rel="noopener ugc nofollow" target="_blank">移动构造函数</a>，一些操作符和 helper 类(比如<a class="ae la" href="https://en.cppreference.com/w/cpp/utility/tuple/tuple_size" rel="noopener ugc nofollow" target="_blank"> std::tuple_size </a>)。但是我希望现在你明白了如何使用可变模板来实现它。顺便说一下，实现那些缺失的东西将是你自己学习 variadic template 的良好开端。</p><p id="e34d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae la" href="http://www.vishalchovatiya.com/contact-2/" rel="noopener ugc nofollow" target="_blank">有什么建议，查询或者想说</a> <code class="fe kw kx ky kz b"><a class="ae la" href="http://www.vishalchovatiya.com/contact-2/" rel="noopener ugc nofollow" target="_blank">Hi</a></code> <a class="ae la" href="http://www.vishalchovatiya.com/contact-2/" rel="noopener ugc nofollow" target="_blank">？减轻压力，只需点击一下鼠标。</a> 🖱️</p></div></div>    
</body>
</html>