<html>
<head>
<title>Google Interview Problem: Longest String Chain</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">谷歌面试问题:最长的字符串链</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/google-interview-problem-longest-string-chain-5da51dd6bd4?source=collection_archive---------0-----------------------#2021-05-17">https://blog.devgenius.io/google-interview-problem-longest-string-chain-5da51dd6bd4?source=collection_archive---------0-----------------------#2021-05-17</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="4607" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">Swift +动态编程=🔥 🔥 🔥</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/076df5d96fe9ba480f76e5ccb038a38c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oJlQr9L9kPcfb-7KNDgWpg.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">第二个:Leetcode 1048</figcaption></figure><div class="ks kt gp gr ku kv"><a href="https://theswiftnerd.com/longest-string-chain-leetcode/" rel="noopener  ugc nofollow" target="_blank"><div class="kw ab fo"><div class="kx ab ky cl cj kz"><h2 class="bd io gy z fp la fr fs lb fu fw im bi translated">最长的字符串链(Leetcode 1048)</h2><div class="lc l"><h3 class="bd b gy z fp la fr fs lb fu fw dk translated">给定一个单词列表，每个单词由英文小写字母组成。假设单词1是单词2的前身，如果…</h3></div><div class="ld l"><p class="bd b dl z fp la fr fs lb fu fw dk translated">theswiftnerd.com</p></div></div><div class="le l"><div class="lf l lg lh li le lj km kv"/></div></div></a></div><p id="62b0" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">如果你正在准备编码面试，那就去Swift Nerd博客上看看令人惊叹的Swift Leetcode系列吧。</p><h1 id="f9b7" class="mg mh in bd mi mj mk ml mm mn mo mp mq jt mr ju ms jw mt jx mu jz mv ka mw mx bi translated">问题描述</h1><p id="0d47" class="pw-post-body-paragraph lk ll in lm b ln my jo lp lq mz jr ls lt na lv lw lx nb lz ma mb nc md me mf ig bi translated">给定一个单词列表，每个单词由英文小写字母组成。</p><p id="c4fc" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">假设<code class="fe nd ne nf ng b">word1</code>是<code class="fe nd ne nf ng b">word2</code>的前身，当且仅当我们可以在<code class="fe nd ne nf ng b">word1</code>的任意位置添加一个字母，使其等于<code class="fe nd ne nf ng b">word2</code>。比如<code class="fe nd ne nf ng b">"abc"</code>就是<code class="fe nd ne nf ng b">"abac"</code>的前身。</p><p id="33f9" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">一个<em class="nh">字链</em>是一个带有<code class="fe nd ne nf ng b">k &gt;= 1</code>的字序列<code class="fe nd ne nf ng b">[word_1, word_2, ..., word_k]</code>，其中<code class="fe nd ne nf ng b">word_1</code>是<code class="fe nd ne nf ng b">word_2</code>的前任，<code class="fe nd ne nf ng b">word_2</code>是<code class="fe nd ne nf ng b">word_3</code>的前任，以此类推。</p><p id="7f25" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">从给定的<code class="fe nd ne nf ng b">words</code>列表中选择单词，返回单词链的最大可能长度。</p><h1 id="3548" class="mg mh in bd mi mj mk ml mm mn mo mp mq jt mr ju ms jw mt jx mu jz mv ka mw mx bi translated">例子</h1><pre class="kd ke kf kg gt ni ng nj nk aw nl bi"><span id="bfb5" class="nm mh in ng b gy nn no l np nq"><strong class="ng io">Input:</strong> words = ["a","b","ba","bca","bda","bdca"]<br/><strong class="ng io">Output:</strong> 4<br/><strong class="ng io">Explanation</strong>: One of the longest word chain is "a","ba","bda","bdca".</span><span id="0596" class="nm mh in ng b gy nr no l np nq"><strong class="ng io">Input:</strong> words = ["xbc","pcxbcf","xb","cxbc","pcxbc"]<br/><strong class="ng io">Output:</strong> 5</span></pre><h1 id="621c" class="mg mh in bd mi mj mk ml mm mn mo mp mq jt mr ju ms jw mt jx mu jz mv ka mw mx bi translated">限制</h1><ul class=""><li id="3508" class="ns nt in lm b ln my lq mz lt nu lx nv mb nw mf nx ny nz oa bi translated"><code class="fe nd ne nf ng b">1 &lt;= words.length &lt;= 1000</code></li><li id="9f32" class="ns nt in lm b ln ob lq oc lt od lx oe mb of mf nx ny nz oa bi translated"><code class="fe nd ne nf ng b">1 &lt;= words[i].length &lt;= 16</code></li><li id="4172" class="ns nt in lm b ln ob lq oc lt od lx oe mb of mf nx ny nz oa bi translated"><code class="fe nd ne nf ng b">words[i]</code>仅由英文小写字母组成。</li></ul><h1 id="8b06" class="mg mh in bd mi mj mk ml mm mn mo mp mq jt mr ju ms jw mt jx mu jz mv ka mw mx bi translated">解决办法</h1><p id="ffe0" class="pw-post-body-paragraph lk ll in lm b ln my jo lp lq mz jr ls lt na lv lw lx nb lz ma mb nc md me mf ig bi translated">我们可以确定链中每个字符串的长度递增的模式，因此如果当前元素是“abc ”,则下一个元素的长度必须是Length(abc) + 1 = 4。问题陈述中的一个关键点是，当且仅当我们可以在word1中的任意位置添加一个字母使其等于word2时，word1可以是word2的前身。换句话说，word2应该比word1多一个字母，这个新字母的位置可以是任何地方。注意<em class="nh">不需要保持单词的顺序。</em></p><p id="052a" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">一件棘手的事情是，如果我们直觉地把我们的解决方案建立在前任的定义上，那么这将是困难的。举个例子，要检查“ab”是“acb”的前身，我们将不得不分割字符串，并尝试所有可能的字母组合，如果它们匹配的话。" ab" = {a-z} + "ab "，" a" + {a-z} + "b "，" ab" + {a-z}。如果字符空间增加，就会增加复杂性。如果我们颠倒定义呢？对于“acb”是链接中的一个连续链，我们可以将每个字符逐个删除，并与“ab”匹配。这是一个简单的O(L)运算。</p><h1 id="d9cb" class="mg mh in bd mi mj mk ml mm mn mo mp mq jt mr ju ms jw mt jx mu jz mv ka mw mx bi translated">自底向上动态编程</h1><p id="6969" class="pw-post-body-paragraph lk ll in lm b ln my jo lp lq mz jr ls lt na lv lw lx nb lz ma mb nc md me mf ig bi translated">当我们从左向右移动时，序列中单词的长度增加。如果我们可以根据单词的长度对其进行升序排序，我们就可以确定列表中的下一个单词会比当前单词更长。接下来，我们可以遍历排序后的列表，计算可能的最长序列的长度，其中索引I处的单词是结束单词。我们如何计算可能的前置字符是我们从字符串中一个接一个地删除一个字符，并检查结果字符串是否已经在链中起作用。我们将这个结果存储在一个映射中，其中<code class="fe nd ne nf ng b">key</code>是单词，<code class="fe nd ne nf ng b">value</code>是序列长度。通过这样做，我们可以确保，对于我们遇到的每个单词，我们已经知道它所有可能的前身的结果。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="og oh l"/></div></figure><h1 id="6ee9" class="mg mh in bd mi mj mk ml mm mn mo mp mq jt mr ju ms jw mt jx mu jz mv ka mw mx bi translated">复杂性分析</h1><p id="a9c6" class="pw-post-body-paragraph lk ll in lm b ln my jo lp lq mz jr ls lt na lv lw lx nb lz ma mb nc md me mf ig bi translated">对大小为N的列表进行排序需要O(NLogN)时间。我们迭代单词列表，并尝试通过逐个删除来匹配字符，这需要O(L2)。单词操作是O(L2 ),因为首先我们迭代单词长度以去除字符，即O(L ),并且对于每次迭代，我们试图构建剩余的字符串，它本身是O(L ),因此是O(L2)。因此，总时间复杂度增加到<em class="nh"> O(NLogN) + O(L2) </em>。</p><p id="facb" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">对于空间，最多可以存储N个字，因此它是线性的。</p><p id="9b18" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated"><strong class="lm io"> Time = O(NLogN) + O(L2) </strong> //其中N为字数，L为每个单词的长度</p><p id="a235" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated"><strong class="lm io"> Space = O(N) </strong></p></div><div class="ab cl oi oj hr ok" role="separator"><span class="ol bw bk om on oo"/><span class="ol bw bk om on oo"/><span class="ol bw bk om on"/></div><div class="ig ih ii ij ik"><p id="8d0a" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">感谢您的阅读。如果你喜欢这篇文章，并发现它很有用，请分享并像野火一样传播它！</p><p id="14ba" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">你可以在<a class="ae op" href="https://theswiftnerd.com/" rel="noopener ugc nofollow" target="_blank">the swift nerd</a>|<a class="ae op" href="https://www.linkedin.com/in/varunrathi28/" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>|<a class="ae op" href="https://github.com/varunrathi28" rel="noopener ugc nofollow" target="_blank">Github</a>上找到我</p></div></div>    
</body>
</html>