<html>
<head>
<title>Javascript is weird, or is it?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Javascript 很奇怪，是吗？</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/javascript-is-weird-or-is-it-4228e5211022?source=collection_archive---------23-----------------------#2020-06-24">https://blog.devgenius.io/javascript-is-weird-or-is-it-4228e5211022?source=collection_archive---------23-----------------------#2020-06-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/0c4fae0c2f578fb20ccaebb192812be9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HCUO7QGr9gTMZ0tI"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://unsplash.com/@sincerelymedia?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">精诚传媒</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unplash</a>上拍摄的照片</figcaption></figure><p id="e9f6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Javascript 是一种出身卑微的编程语言，主要用于在网站上进行愚蠢的交互，现在已经无处不在，其应用范围从物联网到人工智能和机器学习，根据<a class="ae kc" href="https://insights.stackoverflow.com/survey/2020#most-popular-technologies" rel="noopener ugc nofollow" target="_blank"> Stack Overflow 的开发者调查</a>连续 8 年被评为最受欢迎的编程语言。如果你能想到这一点，Javascript 可能就能做到。</p><p id="39f8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">尽管它很受欢迎，但许多人喜欢讨厌 Javascript，他们似乎认为它很奇怪，超级古怪，甚至不可预测。这种说法非常普遍，以至于很多博客甚至建议 Javascript 程序员完全避免像<code class="fe lb lc ld le b">Types</code>和<code class="fe lb lc ld le b">Coercion</code>这样的语言，因为“它会咬你的一口”。当我刚开始学习的时候，我同意其中的一些观点，但是我对这门语言了解的越多，我就越能理解和利用很多人所说的它的缺点。</p><p id="c3af" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Javascript 并不完美(没有一种编程语言是完美的)，但它绝不是不可预测的。Javascript 规范明确定义了该语言的行为，对 Javascript 内部工作机制的深入理解将使程序员能够利用其特性来构建复杂且可扩展的应用程序。</p><p id="7e38" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将尝试解释 Javascript 中某些“奇怪之处”背后的原因，我希望这能鼓励读者更深入地研究 Javascript，并真正欣赏这种语言的强大功能。</p><p id="dd2a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不久前，我在网上找到了这些幻灯片，我非常喜欢尝试找出这些问题的解决方案，所以我们将尝试在这里一起做</p><div class="lf lg gp gr lh li"><a href="https://slides.com/chrisoncode/javascript-is-weird" rel="noopener  ugc nofollow" target="_blank"><div class="lj ab fo"><div class="lk ab ll cl cj lm"><h2 class="bd ir gy z fp ln fr fs lo fu fw ip bi translated">JavaScript 很奇怪。我喜欢 JavaScript</h2><div class="lp l"><h3 class="bd b gy z fp ln fr fs lo fu fw dk translated">用幻灯片创建的演示文稿。</h3></div><div class="lq l"><p class="bd b dl z fp ln fr fs lo fu fw dk translated">slides.com</p></div></div><div class="lr l"><div class="ls l lt lu lv lr lw jw li"/></div></div></a></div><h1 id="f0bc" class="lx ly iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">强迫</h1><p id="0423" class="pw-post-body-paragraph kd ke iq kf b kg mv ki kj kk mw km kn ko mx kq kr ks my ku kv kw mz ky kz la ij bi translated"><strong class="kf ir">对</strong><code class="fe lb lc ld le b"><strong class="kf ir">Strings</strong></code><strong class="kf ir"/><code class="fe lb lc ld le b"><strong class="kf ir">Numbers</strong></code>进行算术运算</p><pre class="na nb nc nd gt ne le nf ng aw nh bi"><span id="0433" class="ni ly iq le b gy nj nk l nl nm">1 + "1" // results in "11"</span><span id="6610" class="ni ly iq le b gy nn nk l nl nm">9 + '99' + 100 // results in "999100"</span><span id="8207" class="ni ly iq le b gy nn nk l nl nm">'hello' + 'goodbye' // results in "hellogoodbye"</span><span id="4544" class="ni ly iq le b gy nn nk l nl nm">12 / "6" === 2 // true</span><span id="cb95" class="ni ly iq le b gy nn nk l nl nm">12 - "6" === 6 // true</span><span id="58c4" class="ni ly iq le b gy nn nk l nl nm">12 * "6" === 72 // true</span><span id="8aa1" class="ni ly iq le b gy nn nk l nl nm">12 + "6" === 18 // false</span></pre><p id="c300" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">结果可能会让一些人感到惊讶，但这是非常简单的。当在 Javascript 中对原语执行加法操作时，如果任何一个值是字符串，编译器将调用两个值的本机<code class="fe lb lc ld le b">ToString</code>实现，将非字符串强制转换为字符串，并执行字符串串联，如果是减法、乘法和除法等其他算术运算，将调用<code class="fe lb lc ld le b">ToNumber</code>实现。</p><p id="4368" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">数组上的算术运算</strong></p><pre class="na nb nc nd gt ne le nf ng aw nh bi"><span id="bb5d" class="ni ly iq le b gy nj nk l nl nm">["chris", "kapehe"] + ["mo", "bella"] // "chris,kapehemo,bella"</span><span id="d18b" class="ni ly iq le b gy nn nk l nl nm">["chris", "kapehe"] - ["mo", "bella"] // NaN</span></pre><p id="0258" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是一个更有趣的例子，也是造成混乱的主要原因，但是同样，通过应用 Javascript 规范中的算法，很容易理解。</p><pre class="na nb nc nd gt ne le nf ng aw nh bi"><span id="4785" class="ni ly iq le b gy nj nk l nl nm">["chris", "kapehe"] + ["mo", "bella"]</span><span id="5594" class="ni ly iq le b gy nn nk l nl nm">/**<br/>* When the Javascript compiler comes across this expression,<br/>* it invokes the native ToPrimitive implementation on both sides<br/>* of the expression and the expression becomes;<br/>*/</span><span id="59f9" class="ni ly iq le b gy nn nk l nl nm">"chris,kapehe" + "mo,bella"</span><span id="954a" class="ni ly iq le b gy nn nk l nl nm">// And from what we know about the addition operations on strings, this results in a string concatenation;</span><span id="701b" class="ni ly iq le b gy nn nk l nl nm">"chris,kapehemo,bella"</span><span id="1ad0" class="ni ly iq le b gy nn nk l nl nm">// For the subtraction case, we know that the native ToNumber implementation will be invoked resulting in </span><span id="1c63" class="ni ly iq le b gy nn nk l nl nm">NaN - NaN // NaN</span></pre><p id="a5f9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">参见:</p><p id="d81a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae kc" href="https://www.ecma-international.org/ecma-262/5.1/#sec-11.6" rel="noopener ugc nofollow" target="_blank">https://www.ecma-international.org/ecma-262/5.1/#sec-11.6</a></p><p id="422b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae kc" href="https://www.ecma-international.org/ecma-262/5.1/#sec-11.5" rel="noopener ugc nofollow" target="_blank">https://www.ecma-international.org/ecma-262/5.1/#sec-11.5</a></p><p id="a068" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b"><strong class="kf ir">==</strong></code> <strong class="kf ir"> vs </strong> <code class="fe lb lc ld le b"><strong class="kf ir">===</strong></code></p><p id="736b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">==</code>操作符是 Javascript 中另一个有着不好名声的功能。无数的博客帖子和教程都建议不惜一切代价避开操作员，只使用<code class="fe lb lc ld le b">===</code>，因为这样更“安全”,因为它不会尝试任何形式的强制。</p><pre class="na nb nc nd gt ne le nf ng aw nh bi"><span id="c931" class="ni ly iq le b gy nj nk l nl nm">new Array(3).toString() === ",," // true</span><span id="23ed" class="ni ly iq le b gy nn nk l nl nm">',,' === ['', '', ''] // false</span><span id="3f6b" class="ni ly iq le b gy nn nk l nl nm">',,' == ['', '', ''] // true</span></pre><p id="d661" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里的第一种情况非常简单，因为我们已经知道在数组上调用<code class="fe lb lc ld le b">ToString</code>会产生什么结果。让我们仔细看看第二种和第三种情况；</p><pre class="na nb nc nd gt ne le nf ng aw nh bi"><span id="8fe3" class="ni ly iq le b gy nj nk l nl nm">/**<br/>* This behaves as most would expect, a String is not the same as an * Array so this should be false<br/>*/</span><span id="600c" class="ni ly iq le b gy nn nk l nl nm">',,' === ['', '', ''] // false</span><span id="0fe6" class="ni ly iq le b gy nn nk l nl nm">/**<br/>* This might come as a surprise to most people but it is quite<br/>* straightforward. When the Javascript compiler encounters this, <br/>* it tries to get the Right-hand side and Left-hand side to be of<br/>* the same type so it invokes ToPrimitive on the Array<br/>*/</span><span id="49d1" class="ni ly iq le b gy nn nk l nl nm">',,' == ['', '', ''] // true</span><span id="d500" class="ni ly iq le b gy nn nk l nl nm">// this then becomes</span><span id="d341" class="ni ly iq le b gy nn nk l nl nm">',,' == ',,'</span><span id="2949" class="ni ly iq le b gy nn nk l nl nm">// And now since both sides of the expression are of the same type and value, we get `true` as the result.</span></pre><p id="9b35" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对强制有了深入的了解后，很明显<code class="fe lb lc ld le b">==</code>操作符确实比<code class="fe lb lc ld le b">===</code>更强大，并且当类型匹配时，它的行为与<code class="fe lb lc ld le b">===</code>操作符相同。</p><p id="3e09" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一个典型的例子是当我们需要检查<code class="fe lb lc ld le b">null</code>或<code class="fe lb lc ld le b">undefined</code>时<code class="fe lb lc ld le b">==</code>会发光</p><pre class="na nb nc nd gt ne le nf ng aw nh bi"><span id="4fb9" class="ni ly iq le b gy nj nk l nl nm">// Instead of doing this<br/>if (someValue === null || someValue == undefined)</span><span id="7fa9" class="ni ly iq le b gy nn nk l nl nm">// We could simply do<br/>if (someValue == null)</span><span id="6b70" class="ni ly iq le b gy nn nk l nl nm">//or<br/>if (someValue == undefined)</span></pre><p id="f269" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">参见:【https://www.ecma-international.org/ecma-262/5.1/#sec-11.9.3 T21】</p><h1 id="9dcc" class="lx ly iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">范围和吊装</h1><p id="3eaf" class="pw-post-body-paragraph kd ke iq kf b kg mv ki kj kk mw km kn ko mx kq kr ks my ku kv kw mz ky kz la ij bi translated"><strong class="kf ir">范围</strong></p><p id="3e0f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Javascript 中的作用域概念甚至会让有经验的 Javascript 开发人员感到困惑，几乎每个编写 Javascript 的人都曾经历过与 Javascript 的作用域系统有关的事情。词法范围可能是 Javascript 最好的特性之一，很好地理解它的工作原理可以增强开发人员解决问题的能力。</p><p id="db5a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们看看幻灯片中的几个例子；</p><pre class="na nb nc nd gt ne le nf ng aw nh bi"><span id="d78b" class="ni ly iq le b gy nj nk l nl nm">// Since `someVariable` has not yet been declared within this scope, an error is thrown</span><span id="1f07" class="ni ly iq le b gy nn nk l nl nm">console.log(someVariable) // Uncaught ReferenceError</span><span id="af56" class="ni ly iq le b gy nn nk l nl nm">/**<br/>* The `typeof` operator is special in that it can access an <br/>* undeclared variable without throwing an error. This means that <br/>* the `typeof` operator will always return a string no matter what<br/>*/<br/> <br/>console.log(typeof myVariable) // "undefined"</span><span id="ab5f" class="ni ly iq le b gy nn nk l nl nm">/**<br/>* Since we do not get block scoping with the `var` keyword, <br/>* the declaration of the `x` variable in the `if` block propagates <br/>* all through the function scope and the new value of `x` is 10<br/>*/</span><span id="e592" class="ni ly iq le b gy nn nk l nl nm">function doSomethingCool() {<br/>  var x = 5;    </span><span id="4a9e" class="ni ly iq le b gy nn nk l nl nm">  if (true) {<br/>    var x = 10;     <br/>    console.log(x); // 10<br/>  }</span><span id="e70a" class="ni ly iq le b gy nn nk l nl nm">  console.log(x); // 10<br/>}</span><span id="c4a1" class="ni ly iq le b gy nn nk l nl nm">doSomethingCool();</span><span id="5761" class="ni ly iq le b gy nn nk l nl nm">/**<br/>* With the `let` keyword, we now have block scoping and so <br/>* within the block scope created by the `if` statement, <br/>* we have a variable `x` whose value is 10<br/>* while the value of `x` remains 5 in the outer function scope<br/>*/</span><span id="3144" class="ni ly iq le b gy nn nk l nl nm">function doSomethingCool() {<br/>  let x = 5;    </span><span id="69d0" class="ni ly iq le b gy nn nk l nl nm">  if (true) {<br/>    let x = 10;     <br/>    console.log(x); // 10<br/>  }</span><span id="975c" class="ni ly iq le b gy nn nk l nl nm">  console.log(x); // 5<br/>}</span><span id="30f9" class="ni ly iq le b gy nn nk l nl nm">doSomethingCool();</span></pre><p id="77e9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">吊装</strong></p><p id="62b9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面这个例子是 Javascript 中提升的经典例子。它通常被描述为 Javascript 将某些代码移动到特定范围的顶部，但这并不完全准确。</p><p id="d5e3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">更好的理解方式是 Javascript 对代码进行两次传递，第一次传递设置范围、处理正式声明等，第二次传递执行代码。</p><pre class="na nb nc nd gt ne le nf ng aw nh bi"><span id="14f5" class="ni ly iq le b gy nj nk l nl nm">/**<br/>* In the 'processing' phase, we skip the invocation of `sayWhatup` <br/>* and process the formal declaration of the `sayWhatup` function<br/>* then at the execution stage, we find that `sayWhatup` has already * been declared and so we do not get a ReferenceError.<br/>*/</span><span id="46c4" class="ni ly iq le b gy nn nk l nl nm">sayWhatup(); // alert</span><span id="aedf" class="ni ly iq le b gy nn nk l nl nm">function sayWhatup() {<br/>    alert('whatup')<br/>}</span></pre><p id="4bea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里有另一个例子可以更清楚地说明这一点</p><pre class="na nb nc nd gt ne le nf ng aw nh bi"><span id="57c0" class="ni ly iq le b gy nj nk l nl nm">/**<br/>* In the 'processing' phase, we skip the invocation of `log` and <br/>* process the formal declaration of the `message` variable. <br/>* Since variable assignment happens during the execution stage, <br/>* `message` defaults to undefined, and that is what we see <br/>* when the code is executed.<br/>*/</span><span id="0a0f" class="ni ly iq le b gy nn nk l nl nm">console.log(message); // undefined</span><span id="1ed4" class="ni ly iq le b gy nn nk l nl nm">var message = 'HEY everybody!';</span></pre><p id="dc94" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">花点时间想出这里的其他例子:【https://slides.com/chrisoncode/javascript-is-weird】T2，看看你是否能想出来。</p><p id="fb3b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Javascript 是一种令人惊叹的语言，花些时间理解它是如何工作的，阅读说明书，它会帮助你体会到这种语言到底有多强大。</p></div></div>    
</body>
</html>