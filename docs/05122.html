<html>
<head>
<title>Integration Testing in Spring Boot Application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">集成测试在 Spring Boot 应用中的应用</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/integration-testing-in-spring-boot-application-7d44388ba070?source=collection_archive---------2-----------------------#2021-06-19">https://blog.devgenius.io/integration-testing-in-spring-boot-application-7d44388ba070?source=collection_archive---------2-----------------------#2021-06-19</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="0262" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这篇文章中，我将展示如何在 Spring Boot 应用程序中添加集成测试。</p><p id="bd68" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">集成测试在确保应用程序质量方面起着关键作用。有了像 Spring Boot 这样的框架，集成这样的测试就更容易了。然而，用集成测试来测试应用程序，而不是将它们部署到应用服务器上，这一点很重要。</p><p id="8fb0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">集成测试有助于测试应用程序的数据访问层。集成测试也有助于测试多个单元。对于 Spring Boot 应用程序，我们需要在<code class="fe ki kj kk kl b">ApplicationContext</code>中运行一个应用程序来运行测试。集成测试也可以帮助测试<a class="ae km" href="https://betterjavacode.com/programming/controller-advice-exception-handler-in-spring-boot" rel="noopener ugc nofollow" target="_blank">异常处理</a>。</p><h1 id="801c" class="kn ko in bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">Spring Boot 应用</h1><p id="2308" class="pw-post-body-paragraph jk jl in jm b jn ll jp jq jr lm jt ju jv ln jx jy jz lo kb kc kd lp kf kg kh ig bi translated">对于这个演示，我们将使用 REST APIs 构建一个简单的 Spring Boot 应用程序。我们将使用 H2 内存数据库来存储数据。最后，我将展示如何编写一个集成测试。该应用程序从国家漏洞数据库中读取一个 JSON 漏洞文件，并将其存储在 H2 数据库中。REST APIs 允许用户以更易读的格式获取数据。</p><h1 id="0938" class="kn ko in bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">属国</h1><p id="668b" class="pw-post-body-paragraph jk jl in jm b jn ll jp jq jr lm jt ju jv ln jx jy jz lo kb kc kd lp kf kg kh ig bi translated">首先，我们希望在这个应用程序中构建集成测试，所以我们需要包含依赖关系<code class="fe ki kj kk kl b">spring-boot-starter-test</code>。</p><pre class="lq lr ls lt gt lu kl lv lw aw lx bi"><span id="1a28" class="ly ko in kl b gy lz ma l mb mc">dependencies { <br/>implementation 'org.springframework.boot:spring-boot-starter-data-jpa' <br/>implementation 'org.springframework.boot:spring-boot-starter-web' implementation 'junit:junit:4.13.1' <br/>runtimeOnly 'com.h2database:h2:1.4.200' <br/>testImplementation 'org.springframework.boot:spring-boot-starter-test' <br/>}</span></pre><p id="deee" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ki kj kk kl b">spring-boot-starter-test</code>的这种依赖性允许我们添加测试相关的注释，我们很快就会看到。</p><h1 id="322e" class="kn ko in bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">REST API</h1><p id="7110" class="pw-post-body-paragraph jk jl in jm b jn ll jp jq jr lm jt ju jv ln jx jy jz lo kb kc kd lp kf kg kh ig bi translated">正如我之前所说，我们将有一个 REST API 来获取国家漏洞数据库数据。我们将创建一个带有两个 API 的 REST 控制器，一个获取漏洞列表，另一个通过 CVE id 获取漏洞。</p><pre class="lq lr ls lt gt lu kl lv lw aw lx bi"><span id="3421" class="ly ko in kl b gy lz ma l mb mc">@RestController<br/>@RequestMapping("/v1/beacon23/vulnerabilities")<br/>public class CveController<br/>{<br/><br/>    @Autowired<br/>    private CveService cveService;<br/><br/>    @GetMapping("/list")<br/>    public List getAllCveItems(@RequestParam(required = false, name="fromDate") String fromDate, @RequestParam(required = false, name=<br/>            "toDate") String toDate)<br/>    {<br/>        List cveDTOList = cveService.getCveItems(fromDate, toDate);<br/><br/>        if(cveDTOList == null || cveDTOList.isEmpty())<br/>        {<br/>            return new ArrayList&lt;&gt;();<br/>        }<br/>        else<br/>        {<br/>            return cveDTOList;<br/>        }<br/>    }<br/><br/>    @GetMapping<br/>    public ResponseEntity getCveItemById(@RequestParam("cveId") String cveId)<br/>    {<br/>        CveDTO cveDTO = cveService.getCveItemByCveId(cveId);<br/><br/>        if(cveDTO != null)<br/>        {<br/>            return new ResponseEntity&lt;&gt;(cveDTO, HttpStatus.OK);<br/>        }<br/>        else<br/>        {<br/>            return new ResponseEntity&lt;&gt;(HttpStatus.NO_CONTENT);<br/>        }<br/>    }<br/><br/>}</span></pre><p id="9520" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以我们有</p><ul class=""><li id="faf8" class="md me in jm b jn jo jr js jv mf jz mg kd mh kh mi mj mk ml bi translated">/v1/beacon 23/vulnerabilities/list—获取漏洞列表</li><li id="5ea5" class="md me in jm b jn mm jr mn jv mo jz mp kd mq kh mi mj mk ml bi translated">/v1/beacon 23/漏洞？cveId = value 通过 cveId 获取漏洞。</li></ul><h1 id="c366" class="kn ko in bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">服务</h1><p id="8625" class="pw-post-body-paragraph jk jl in jm b jn ll jp jq jr lm jt ju jv ln jx jy jz lo kb kc kd lp kf kg kh ig bi translated">现在，大多数业务逻辑和验证都发生在服务类中。正如我们在 API 中看到的，我们使用<code class="fe ki kj kk kl b">CVEService</code>来获取所需的数据。</p><pre class="lq lr ls lt gt lu kl lv lw aw lx bi"><span id="9163" class="ly ko in kl b gy lz ma l mb mc">    @Autowired<br/>    public CveDataDao cveDataDao;<br/><br/>    public List getCveItems(String from, String to)<br/>    {<br/>        LOGGER.debug("The date range values are from = {} and to = {}", from, to);<br/>        List cveDataList = cveDataDao.findAll();<br/>        List cveDTOList = new ArrayList&lt;&gt;();<br/><br/>        for(CveData cveData : cveDataList)<br/>        {<br/>            List cveList = cveData.getCveItems();<br/>            for(CveItem cveItem: cveList)<br/>            {<br/>                Date fromDate;<br/>                Date toDate;<br/><br/>                if(!isNullOrEmpty(from) &amp;&amp; !isNullOrEmpty(to))<br/>                {<br/>                    fromDate = DateUtil.formatDate(from);<br/>                    toDate = DateUtil.formatDate(to);<br/><br/>                    Date publishedDate = DateUtil.formatDate(cveItem.getPublishedDate());<br/><br/>                    if(publishedDate.after(toDate) || publishedDate.before(fromDate))<br/>                    {<br/>                        continue;<br/>                    }<br/>                }<br/>                CveDTO cveDTO = convertCveItemToCveDTO(cveItem);<br/>                cveDTOList.add(cveDTO);<br/>            }<br/>        }<br/>        return cveDTOList;<br/>    }<br/><br/>    private boolean isNullOrEmpty (String str)<br/>    {<br/>        return (str == null || str.isEmpty());<br/>    }<br/><br/>    private String buildDescription (List descriptionDataList)<br/>    {<br/>        if(descriptionDataList == null || descriptionDataList.isEmpty())<br/>        {<br/>            return EMPTY_STRING;<br/>        }<br/>        else<br/>        {<br/>            return descriptionDataList.get(0).getValue();<br/>        }<br/>    }<br/><br/>    private List buildReferenceUrls (List referenceDataList)<br/>    {<br/>        return referenceDataList.stream().map(it -&gt; it.getUrl()).collect(Collectors.toList());<br/>    }<br/><br/>    public CveDTO getCveItemByCveId(String cveId)<br/>    {<br/>        List cveDataList = cveDataDao.findAll();<br/>        CveDTO cveDTO = null;<br/><br/>        for(CveData cveData : cveDataList)<br/>        {<br/>            List cveItems = cveData.getCveItems();<br/><br/>            Optional optionalCveItem =<br/>                    cveItems.stream().filter(ci -&gt; ci.getCve().getCveMetadata().getCveId().equals(cveId)).findAny();<br/>            CveItem cveItem = null;<br/>            if(optionalCveItem.isPresent())<br/>            {<br/>                cveItem = optionalCveItem.get();<br/>            }<br/>            else<br/>            {<br/>                return cveDTO;<br/>            }<br/>            cveDTO = convertCveItemToCveDTO(cveItem);<br/>        }<br/><br/>        return cveDTO;<br/>    }</span></pre><h1 id="0595" class="kn ko in bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">@SpringBootTest 的用法</h1><p id="66bb" class="pw-post-body-paragraph jk jl in jm b jn ll jp jq jr lm jt ju jv ln jx jy jz lo kb kc kd lp kf kg kh ig bi translated">Spring Boot 提供了一个注释<code class="fe ki kj kk kl b">@SpringBootTest</code>，我们可以在集成测试中使用它。有了这个注释，测试可以启动应用程序上下文，该上下文可以包含应用程序运行所需的所有对象。</p><p id="31ba" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">集成测试提供了一个几乎类似于生产的场景来测试我们的代码。用<code class="fe ki kj kk kl b">@SpringBootTest</code>标注的测试通过用<code class="fe ki kj kk kl b">@SpringBootConfiguration</code>标注的应用程序类创建了测试中使用的应用程序上下文。</p><p id="8479" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这些测试启动一个嵌入式服务器，创建一个 web 环境，然后运行<code class="fe ki kj kk kl b">@Test</code>方法进行集成测试。我们需要添加一些属性来确保我们可以在使用<code class="fe ki kj kk kl b">@SpringBootTest</code>时启动 web 环境。</p><p id="5a82" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们也可以通过一个活动的概要文件来传递用于测试的属性。通常，我们为不同的环境使用这些概要文件，但是我们也可以只为测试使用一个特殊的概要文件。我们创建<code class="fe ki kj kk kl b">application-dev.yml</code>、<code class="fe ki kj kk kl b">application-prod.yml</code>配置文件。类似地，我们可以创建<code class="fe ki kj kk kl b">application-test.yml</code>并在测试中使用注释<code class="fe ki kj kk kl b">@ActiveProfiles('test')</code>。</p><h1 id="c5ef" class="kn ko in bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">集成测试示例</h1><p id="2035" class="pw-post-body-paragraph jk jl in jm b jn ll jp jq jr lm jt ju jv ln jx jy jz lo kb kc kd lp kf kg kh ig bi translated">对于我们的 REST API，我们将创建一个集成测试来测试我们的控制器。我们还将使用<code class="fe ki kj kk kl b">TestRestTemplate</code>来获取数据。该集成测试将如下所示:</p><pre class="lq lr ls lt gt lu kl lv lw aw lx bi"><span id="b7c8" class="ly ko in kl b gy lz ma l mb mc">package com.betterjavacode.beacon23.tests;<br/><br/>import org.junit.Test;<br/>import org.junit.runner.RunWith;<br/>import org.springframework.boot.test.context.SpringBootTest;<br/>import org.springframework.boot.test.web.client.TestRestTemplate;<br/>import org.springframework.boot.web.server.LocalServerPort;<br/>import org.springframework.http.HttpEntity;<br/>import org.springframework.http.HttpHeaders;<br/>import org.springframework.http.HttpMethod;<br/>import org.springframework.http.ResponseEntity;<br/>import org.springframework.test.context.junit4.SpringRunner;<br/><br/>import static org.junit.Assert.assertNotNull;<br/><br/>@RunWith(SpringRunner.class)<br/>@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)<br/>public class CveControllerTest<br/>{<br/>    @LocalServerPort<br/>    private int port;<br/><br/>    TestRestTemplate testRestTemplate = new TestRestTemplate();<br/><br/>    HttpHeaders headers = new HttpHeaders();<br/><br/>    @Test<br/>    public void testGetAllCveItems()<br/>    {<br/>        HttpEntity entity = new HttpEntity&lt;&gt;(null, headers);<br/><br/>        ResponseEntity responseEntity = testRestTemplate.exchange(createURLWithPort(<br/>                "/v1/beacon23/vulnerabilities/list"),HttpMethod.GET, entity, String.class);<br/><br/>        assertNotNull(responseEntity);<br/><br/>    }<br/><br/><br/>    private String createURLWithPort(String uri)<br/>    {<br/>        return "http://localhost:" + port + uri;<br/>    }<br/>}</span></pre><p id="3bcb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们为测试类使用了<code class="fe ki kj kk kl b">@SpringBootTest</code>注释，并通过使用带有 RANDOM_PORT 的<code class="fe ki kj kk kl b">webEnvironment</code>来设置应用程序上下文。我们还通过用<code class="fe ki kj kk kl b">@LocalServerPort</code>设置一个模拟端口来模拟本地 web 服务器。</p><p id="f012" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ki kj kk kl b">TestRestTemplate</code>允许我们模拟一个将调用我们的 API 的客户端。一旦我们运行这个测试(通过<code class="fe ki kj kk kl b">gradle build</code>或者通过 IntelliJ ),我们将看到 Spring Boot 应用程序上下文设置正在运行，应用程序在一个随机端口上运行。</p><p id="163b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">用<code class="fe ki kj kk kl b">@SpringBootTest</code>创建集成测试的一个缺点是它会降低构建应用程序的速度。在大多数企业环境中，您将通过持续集成和持续部署来实现这一点。在这种情况下，如果您有许多集成测试，它会减慢集成和部署的过程。</p><h1 id="07cb" class="kn ko in bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">结论</h1><p id="bb2e" class="pw-post-body-paragraph jk jl in jm b jn ll jp jq jr lm jt ju jv ln jx jy jz lo kb kc kd lp kf kg kh ig bi translated">最后，您应该在 Spring Boot 应用程序中使用集成测试，这取决于您的应用程序。但是尽管有缺点，允许一次测试多个单元的集成测试总是有用的。<code class="fe ki kj kk kl b">@SpringBootTest</code>是一个方便的注释，可用于设置应用程序上下文，允许我们在接近生产环境的情况下运行测试。</p></div><div class="ab cl mr ms hr mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ig ih ii ij ik"><p id="aaeb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="my">原载于 2021 年 6 月 19 日 https://betterjavacode.com</em><a class="ae km" href="https://betterjavacode.com/programming/integration-testing-in-spring-boot-application" rel="noopener ugc nofollow" target="_blank"><em class="my"/></a><em class="my">。</em></p></div></div>    
</body>
</html>