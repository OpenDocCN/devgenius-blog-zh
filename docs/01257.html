<html>
<head>
<title>PageObject Pattern into App Integration Tests</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">应用程序集成测试中的页面对象模式</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/pageobject-pattern-into-app-integration-tests-4c34eff10359?source=collection_archive---------19-----------------------#2020-06-28">https://blog.devgenius.io/pageobject-pattern-into-app-integration-tests-4c34eff10359?source=collection_archive---------19-----------------------#2020-06-28</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><blockquote class="jk jl jm"><p id="ca48" class="jn jo jp jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ig bi translated">感谢我的同事 Kane Shih 的合作。本文和大家分享一下在 Android 应用上使用 PageObject 的经验。</p></blockquote><p id="26f6" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk kl ig bi translated">PageObject 模式是 Martin Fowler 提出的 Web 应用程序 UI 自动化测试中一个著名的设计模式。它有效地将 UI 元素建模为对象，并允许开发人员操作它们，而无需深入研究实现细节。但是，这在移动应用程序开发中还不常见。</p><p id="5d14" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk kl ig bi translated">维护 Android UI 测试代码在今天是一个巨大的挑战。主要有两个原因:1。)对于不熟悉测试库的开发人员来说，编写 UI 测试需要时间。2.)由于市场的快速变化，生产代码频繁更改，这很快使 UI 测试代码过时。</p><p id="4eff" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk kl ig bi translated">在本文中，我们将介绍如何通过应用 PageObject 模式来解决这个问题，这使得我们的 UI 测试代码易于理解和修改。</p><h1 id="e67d" class="kq kr in bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">介绍</h1><h2 id="b71c" class="lo kr in bd ks lp lq dn kw lr ls dp la kn lt lu le ko lv lw li kp lx ly lm lz bi translated">应用集成测试</h2><p id="8cb0" class="pw-post-body-paragraph jn jo in jq b jr ma jt ju jv mb jx jy kn mc kb kc ko md kf kg kp me kj kk kl ig bi translated">UI 测试用例在物理设备或模拟器上运行，以模拟用户行为并保护它所覆盖的部分用户流。当一个工程师修改生产代码，不小心改变了 UI 的动作，对应的测试用例应该会失败；这有助于开发人员在早期发现问题。UI 测试也有助于模拟边缘情况，这使得产品代码更加健壮。随着现代 Android UI 变得越来越复杂，编写和维护 UI 测试的重要性也越来越大。</p><h2 id="e67a" class="lo kr in bd ks lp lq dn kw lr ls dp la kn lt lu le ko lv lw li kp lx ly lm lz bi translated">浓咖啡</h2><p id="b01c" class="pw-post-body-paragraph jn jo in jq b jr ma jt ju jv mb jx jy kn mc kb kc ko md kf kg kp me kj kk kl ig bi translated">大多数 Android 开发人员使用测试库<a class="ae km" href="https://developer.android.com/training/testing/espresso" rel="noopener ugc nofollow" target="_blank"> Espresso </a>编写 UI 测试，该测试库已经发布并由 Google 支持。Espresso 是一个游戏改变者，它使 UI 测试比以前更容易。以下是 Espresso 的典型测试代码:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="fd45" class="lo kr in mk b gy mo mp l mq mr">onView(withId(R.id.my_view))<br/> .perform(click())<br/> .check(matches(isDisplayed()))</span></pre><p id="66db" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk kl ig bi translated">尽管 Espresso 非常易于使用，但测试代码仍然深深依赖于生产 UI 实现细节。当涉及许多测试用例的视图实例发生变化时，开发人员需要同时更新它们。这可能会让维护 UI 测试变成一场噩梦。</p><h2 id="dc44" class="lo kr in bd ks lp lq dn kw lr ls dp la kn lt lu le ko lv lw li kp lx ly lm lz bi translated">页面对象模式</h2><p id="8534" class="pw-post-body-paragraph jn jo in jq b jr ma jt ju jv mb jx jy kn mc kb kc ko md kf kg kp me kj kk kl ig bi translated">在 PageObject 模式中，每个页面对象可能代表一个完整的页面或者一个复杂的 UI 组件(在移动框架中，页面意味着 Android 的片段或者 iOS 的 UIViewController)。我们可以将页面上的基本元素视为一个对象，而不是整个页面。它封装了实际 UI 组件的详细机制。</p><ul class=""><li id="7b37" class="ms mt in jq b jr js jv jw kn mu ko mv kp mw kl mx my mz na bi translated">马丁·福勒<a class="ae km" href="https://martinfowler.com/bliki/PageObject.html" rel="noopener ugc nofollow" target="_blank">页面对象</a></li><li id="4a5e" class="ms mt in jq b jr nb jv nc kn nd ko ne kp nf kl mx my mz na bi translated">硒，<a class="ae km" href="https://github.com/SeleniumHQ/selenium/wiki/PageObjects" rel="noopener ugc nofollow" target="_blank">页面对象</a></li></ul><h1 id="5705" class="kq kr in bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">体系结构</h1><h2 id="4f08" class="lo kr in bd ks lp lq dn kw lr ls dp la kn lt lu le ko lv lw li kp lx ly lm lz bi translated">基本页面类</h2><p id="551b" class="pw-post-body-paragraph jn jo in jq b jr ma jt ju jv mb jx jy kn mc kb kc ko md kf kg kp me kj kk kl ig bi translated">首先，我们定义了一个基本的 page 类，所有其他的 Page 对象都继承这个类。它有一个小函数<code class="fe ng nh ni mk b">fun &lt;reified T : Page&gt; <strong class="jq io">on</strong>(): T</code>,生成泛型类型的页面实例。这样，我们可以在任何时候连接<code class="fe ng nh ni mk b"><strong class="jq io">Page.on</strong>&lt;{PageObject}&gt;()</code>,并完全基于测试操作确定当前页面对象是什么。</p><p id="34c7" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk kl ig bi translated"><code class="fe ng nh ni mk b">Page.on()</code>接收一个泛型类型 T，并生成 T 的一个实际实例。我们使用<code class="fe ng nh ni mk b">T::class.constructors.<em class="jp">first</em>().call()</code>获取泛型构造函数，并查看第一个构造函数，通常是非参数化的构造函数，以创建 T 的一个实例</p><p id="3a10" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk kl ig bi translated">基本页面类也实现了<code class="fe ng nh ni mk b">fun back(): Page</code>。通过与<code class="fe ng nh ni mk b"><strong class="jq io">Page.on</strong>&lt;{PageObject}&gt;()</code>链接，很容易理解 back 之后应该是哪个页面对象。</p><figure class="mf mg mh mi gt nj"><div class="bz fp l di"><div class="nk nl l"/></div></figure><h2 id="388b" class="lo kr in bd ks lp lq dn kw lr ls dp la kn lt lu le ko lv lw li kp lx ly lm lz bi translated">页面对象类</h2><p id="55e8" class="pw-post-body-paragraph jn jo in jq b jr ma jt ju jv mb jx jy kn mc kb kc ko md kf kg kp me kj kk kl ig bi translated">每个页面对象必须继承基本的页面类，并覆盖函数<code class="fe ng nh ni mk b">fun verify()</code>来进行默认验证。例如，有一个 ItemPage 类继承了 Page 类，并验证 R.id.productitem_name 是否存在。</p><figure class="mf mg mh mi gt nj"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="31cf" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk kl ig bi translated">page 对象不一定要代表整个页面。在下面的示例中，SearchBoxPage 表示 DiscoveryPage 内部的一个子 UI 组件，该组件表示 DiscoveryFragment。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="aecf" class="lo kr in mk b gy mo mp l mq mr">@Test<br/>fun testSearchById() {<br/>    <strong class="mk io">Page.on&lt;DiscoveryPage&gt;()<br/>        .on&lt;SearchBoxPage&gt;()<br/>        </strong>.click()<br/>        .on&lt;SearchViewPage&gt;()<br/>        .searchKeyword(“7882691”)<br/>        .on&lt;ItemPage&gt;()<br/>        .withTitle(“A1NJ5J02”)<br/>}</span></pre><figure class="mf mg mh mi gt nj gh gi paragraph-image"><div role="button" tabindex="0" class="nn no di np bf nq"><div class="gh gi nm"><img src="../Images/25c5cdbfd9aaceb263a4c135b2f275ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*m7zHcLF5XrCO_vHU"/></div></div></figure><h2 id="7bf1" class="lo kr in bd ks lp lq dn kw lr ls dp la kn lt lu le ko lv lw li kp lx ly lm lz bi translated">科特林具体化</h2><p id="b639" class="pw-post-body-paragraph jn jo in jq b jr ma jt ju jv mb jx jy kn mc kb kc ko md kf kg kp me kj kk kl ig bi translated">Kotlin 的<code class="fe ng nh ni mk b">reified</code>功能强大，可以让测试代码精炼。如果没有它，我们将需要每次实例化页面对象，并失去动作之间的连接。</p><ul class=""><li id="0105" class="ms mt in jq b jr js jv jw kn mu ko mv kp mw kl mx my mz na bi translated">具体化了</li></ul><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="ae6d" class="lo kr in mk b gy mo mp l mq mr">@Test<br/>fun testSearchById() {<br/>    Page.on&lt;DiscoveryPage&gt;()<br/>        .on&lt;SearchBoxPage&gt;()<br/>        .click()<br/>        .on&lt;SearchViewPage&gt;()<br/>        .searchKeyword(“7882691”)<br/>        .back()<br/>        .on&lt;DiscoveryPage&gt;()<br/>}</span></pre><ul class=""><li id="e8b0" class="ms mt in jq b jr js jv jw kn mu ko mv kp mw kl mx my mz na bi translated">没有具体化</li></ul><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="3e0a" class="lo kr in mk b gy mo mp l mq mr">@Test<br/>fun testSearchById() {<br/>    DiscoveryPage()<br/>    SearchBoxPage().click()<br/>    SearchViewPage().searchKeyword(“7882691”).back()<br/>    DiscoveryPage()<br/>}</span></pre><h1 id="8b86" class="kq kr in bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">优势</h1><h2 id="b33c" class="lo kr in bd ks lp lq dn kw lr ls dp la kn lt lu le ko lv lw li kp lx ly lm lz bi translated">提高测试用例的可读性</h2><p id="870e" class="pw-post-body-paragraph jn jo in jq b jr ma jt ju jv mb jx jy kn mc kb kc ko md kf kg kp me kj kk kl ig bi translated">当使用我们提出的实现通过 PageObject 模式编写 UI 测试用例时，它看起来像下面这样:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="1099" class="lo kr in mk b gy mo mp l mq mr">@Test<br/>fun testSearchById() {<br/>    Page.on&lt;DiscoveryPage&gt;()<br/>        .on&lt;SearchBoxPage&gt;()<strong class="mk io"><br/>        </strong>.click()<br/>        .on&lt;SearchViewPage&gt;()<br/>        .searchKeyword(“7882691”)<br/>        .on&lt;ItemPage&gt;()<br/>        .withTitle(“A1NJ5J02”)<br/>}</span></pre><figure class="mf mg mh mi gt nj gh gi paragraph-image"><div role="button" tabindex="0" class="nn no di np bf nq"><div class="gh gi nt"><img src="../Images/cebce69e0cf1936c5be6d1275dcc78f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YR2cU8DGZ-upm9eegONkaA.png"/></div></div></figure><p id="9345" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk kl ig bi translated">很容易理解这个测试用例通过 DiscoveryFragment，并点击 SearchBox 视图，在 SearchView 中输入关键字，然后在 ItemPage 上显示指定的标题。</p><figure class="mf mg mh mi gt nj gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/8220a829231e030207e50fdb3608a183.png" data-original-src="https://miro.medium.com/v2/resize:fit:742/0*cORdhjA1yVjASHjo"/></div></figure><h2 id="c3a5" class="lo kr in bd ks lp lq dn kw lr ls dp la kn lt lu le ko lv lw li kp lx ly lm lz bi translated">易于扩展</h2><p id="43cb" class="pw-post-body-paragraph jn jo in jq b jr ma jt ju jv mb jx jy kn mc kb kc ko md kf kg kp me kj kk kl ig bi translated">在我们的产品中，许多片段包含一个 RecyclerView，它们之间的差异很小。在这种情况下，我们实现了一个基本的 scrollabepageobject，它对 RecyclerView 进行验证，并提供一些通用方法，如“单击索引 n 的项目”。另一个具有类似行为的 PageObject 可以扩展 scrollabepageobject 并独立进行一些自定义。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="f70c" class="lo kr in mk b gy mo mp l mq mr">open class ScrollablePage : Page() {<br/>    @IdRes<br/>    open val recyclerViewId: Int = R.id.<em class="jp">recycler_view</em></span><span id="ff3b" class="lo kr in mk b gy nv mp l mq mr">    fun clickItem(index: Int): Page {<br/>        Espresso.onView(withId(recyclerViewId))<br/>                .perform(<br/>                    RecyclerViewActions.<em class="jp">scrollToPosition</em>(index)<br/>                )<br/>        Espresso.onView(withId(recyclerViewId))<br/>                .perform(<br/>                    RecyclerViewActions.actionOnHolderItem(<br/>                        ItemMatcher(),<br/>                        click()<br/>                    ).atPosition(index)<br/>                )<br/>       return this<br/>    }<br/>}</span><span id="1d35" class="lo kr in mk b gy nv mp l mq mr">class SearchResultPage: ScrollablePage() {<br/>    …<br/>}</span></pre><h2 id="dcae" class="lo kr in bd ks lp lq dn kw lr ls dp la kn lt lu le ko lv lw li kp lx ly lm lz bi translated">从页面对象中分离导航</h2><p id="7145" class="pw-post-body-paragraph jn jo in jq b jr ma jt ju jv mb jx jy kn mc kb kc ko md kf kg kp me kj kk kl ig bi translated">典型的实现是每个页面对象的方法决定下一个页面对象并返回它。然而，这导致了一些问题:</p><ul class=""><li id="437e" class="ms mt in jq b jr js jv jw kn mu ko mv kp mw kl mx my mz na bi translated">同一操作的不同目的地</li><li id="7efb" class="ms mt in jq b jr nb jv nc kn nd ko ne kp nf kl mx my mz na bi translated">由于不同的入口点，向后导航</li><li id="bc99" class="ms mt in jq b jr nb jv nc kn nd ko ne kp nf kl mx my mz na bi translated">在没有实际操作的情况下步入子组件</li></ul><p id="d348" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk kl ig bi translated">我们可以通过<code class="fe ng nh ni mk b"><strong class="jq io">Page.on</strong>&lt;{PageObject}&gt;()</code>轻松解决之前的问题，这样我们就不会定义那些操作的目的地。我们可以在操作后识别当前页面。例如，不同的搜索关键字将导航到不同的结果页面、产品项目页面或品牌页面。我们可以识别出<code class="fe ng nh ni mk b">searchKeyword()</code>之后的页面。</p><p id="b923" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk kl ig bi translated">它将如下所示:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="250f" class="lo kr in mk b gy mo mp l mq mr">@Test<br/>fun testSearchById() {<br/>    Page.on&lt;DiscoveryPage&gt;()<br/>        .on&lt;SearchBoxPage&gt;()<br/>        .click()<br/>        <strong class="mk io">.on&lt;SearchViewPage&gt;()<br/>        .searchKeyword(“7882691”)<br/>        .on&lt;ItemPage&gt;()<br/>        </strong>.withTitle(“A1NJ5J02”)<br/>}</span></pre><figure class="mf mg mh mi gt nj gh gi paragraph-image"><div role="button" tabindex="0" class="nn no di np bf nq"><div class="gh gi nw"><img src="../Images/da4d2de4c9a8b243a92a11b2fb1ebe81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O25v5LpHv0qIgQ9sjXo9iA.png"/></div></div></figure><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="49b1" class="lo kr in mk b gy mo mp l mq mr">@Test<br/>fun testSearchByBrand() {<br/>    Page.on&lt;DiscoveryPage&gt;()<br/>        .on&lt;SearchBoxPage&gt;()<br/>        .click()<br/>        <strong class="mk io">.on&lt;SearchViewPage&gt;()<br/>        .searchKeyword(“timberland”)<br/>        .on&lt;BrandPage&gt;()<br/>        </strong>.withTitle(“Timberland”)<br/>}</span></pre><figure class="mf mg mh mi gt nj gh gi paragraph-image"><div role="button" tabindex="0" class="nn no di np bf nq"><div class="gh gi nw"><img src="../Images/534f26c399bf5d8b2b331f426e847fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZagdSh47HgIQqAJyc0Qv6A.png"/></div></div></figure><p id="60df" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk kl ig bi translated">同时，一些片段有多个不同的入口点。例如，在我们的例子中，ItemPage 可以通过搜索或单击 BrandPage 的产品列表上的一个项目来打开；由于每个场景的不同 backstacks，这也会影响 back key 的行为。这里是用<code class="fe ng nh ni mk b"><strong class="jq io">Page.on</strong>&lt;{PageObject}&gt;()</code>来解决问题。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="8d5f" class="lo kr in mk b gy mo mp l mq mr">@Test<br/>fun testItemDetail() {<br/>    Page.on&lt;ItemPage&gt;()<br/>        .clickDetail()<br/>        .on&lt;WebPage&gt;()<br/>        .withTitle(“The Product Details”)<br/>        <strong class="mk io">.back()<br/>        .on&lt;ItemPage&gt;()<br/></strong>}</span><span id="9ec5" class="lo kr in mk b gy nv mp l mq mr">@Test<br/>fun testBrandDetail() {<br/>    Page.on&lt;BrandPage&gt;()<br/>        .clickDetail()<br/>        .on&lt;WebPage&gt;()<br/>        .withTitle(“The Brand Details”)<br/>        <strong class="mk io">.back()<br/>        .on&lt;BrandPage&gt;()<br/></strong>}</span></pre><h1 id="d30b" class="kq kr in bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">结论</h1><p id="8073" class="pw-post-body-paragraph jn jo in jq b jr ma jt ju jv mb jx jy kn mc kb kc ko md kf kg kp me kj kk kl ig bi translated">通过使用页面对象模式，我们可以将所有与 Espresso 相关的 UI 操作代码隐藏到每个页面对象中，以使我们的测试代码易于阅读和理解。帮助您更快地开发和扩展 UI 测试覆盖率。</p><h2 id="0548" class="lo kr in bd ks lp lq dn kw lr ls dp la kn lt lu le ko lv lw li kp lx ly lm lz bi translated">提取那些通用的浓缩咖啡代码</h2><p id="b3c7" class="pw-post-body-paragraph jn jo in jq b jr ma jt ju jv mb jx jy kn mc kb kc ko md kf kg kp me kj kk kl ig bi translated">这可以帮助我们更快地创建页面对象，因为我们不必重复重写那些 Espresso 函数。第二，虽然 Espresso 现在是一个成熟的库，但它在未来可能仍然会有一些突破性的变化，以及作为一个外部库。最糟糕的情况是，一些新奇的下一代图书馆可能会凭空出现，并获得谷歌的支持，以取代 Espresso。</p><h2 id="8937" class="lo kr in bd ks lp lq dn kw lr ls dp la kn lt lu le ko lv lw li kp lx ly lm lz bi translated">考虑如何分离对应于产品 UI 的页面对象</h2><p id="5366" class="pw-post-body-paragraph jn jo in jq b jr ma jt ju jv mb jx jy kn mc kb kc ko md kf kg kp me kj kk kl ig bi translated">页面对象可以代表整个页面，但通常不是。根据我们的经验，它可以是一个搜索框，测试代码可以与之交互。这增加了可重用性，并帮助我们更快地开发。但是不要做的太复杂，设计过度。</p><p id="4c61" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk kl ig bi translated">理想情况下，当工程师完成一个特性实现时，UI 测试和页面对象也应该准备好了。然后，测试人员或项目经理可以使用这些方便的页面对象高效地编写更多的 UI 测试。</p></div></div>    
</body>
</html>