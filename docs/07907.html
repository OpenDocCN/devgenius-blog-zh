<html>
<head>
<title>The responsive layout for our Rust web application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Rust web 应用程序的响应式布局</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/the-responsive-layout-for-our-rust-web-application-8fb46fe14c8f?source=collection_archive---------5-----------------------#2022-05-02">https://blog.devgenius.io/the-responsive-layout-for-our-rust-web-application-8fb46fe14c8f?source=collection_archive---------5-----------------------#2022-05-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/dac0504cb2a1152deaba9de81a309f94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0VoLr6igUtJLV2zD"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@dose?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">剂量媒体</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="1ddf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们开始为 RSS 阅读器应用程序构建 web 组件之前，我们需要对事情的发展有一个初步的概念。本教程是关于 web 组件和 Javascript 模块的，我们不会在后端坚持太多。是的，我们会用 Rust 读取 RSS 数据，但这只是为了让教程更完整。我们的重点是前端。</p><p id="40e1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在编写代码时，我们还会看到一些用现代 Javascript 很好地表达的架构模式:关注点分离和依赖项的延迟加载。</p><p id="73d1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">信不信由你，我仍然看到没有响应的 web 应用程序，所以我们不会犯这样的错误。我们的应用程序将从一开始就响应迅速。这将是一个简单的两列应用程序，左边是提要列表，右边是文章列表。大概是这样的:</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lb"><img src="../Images/29237b2e811aa7c24a9f92e53c93119e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vNixp-m9jG7axQyxWBb-KQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">我们的 RSS 阅读器 web 应用程序的模拟用户界面</figcaption></figure><p id="6ea6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们超过某个宽度，字体会变小，如果我们使用移动宽度，用户界面会一分为二，变成这样:</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi lg"><img src="../Images/cf692bfad2e690f7cc4f7239187f2386.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/1*0Krh6mqTYDW8aYYo0QkCKg.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">RSS 阅读器应用程序的移动宽度</figcaption></figure><h2 id="a2ec" class="lh li iq bd lj lk ll dn lm ln lo dp lp ko lq lr ls ks lt lu lv kw lw lx ly lz bi translated">CSS 布局</h2><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ma"><img src="../Images/5dcde97ff79bdb003ae10957042d11d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q3_qi2frjLMQLpyZ6i2ZNQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">快速浏览项目结构</figcaption></figure><p id="c0cf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将有一个 CSS 文件为我们描述整个响应布局。我们把它放在<code class="fe mb mc md me b">shared/styles/base.css</code>里吧。这将是我们的基础 CSS，一切都从这里开始:</p><pre class="lc ld le lf gt mf me mg mh aw mi bi"><span id="f3bc" class="lh li iq me b gy mj mk l ml mm">:root {<br/>  --text-color: #2a3434;<br/>  --text-color-light: #778a8a;<br/>  --border-color: #bec5c4;<br/>  --font-family: Ubuntu, Roboto, "Segoe UI", sans-serif;<br/>  --selection-shadow: 0px 0px 3px var(--text-color-light);<br/>}</span><span id="ff1a" class="lh li iq me b gy mn mk l ml mm">body {<br/>  font-family: var(--font-family);<br/>  color: var(--text-color);<br/>  font-size: 20px;<br/>  margin: 0;<br/>  padding: 1em 3em;</span><span id="1cbd" class="lh li iq me b gy mn mk l ml mm">  display: grid;<br/>  grid-template-columns: 1fr 2fr;<br/>}</span><span id="5ed6" class="lh li iq me b gy mn mk l ml mm">a {<br/>  color: inherit;<br/>  text-decoration: none;<br/>}</span><span id="9700" class="lh li iq me b gy mn mk l ml mm">ul {<br/>  list-style: none;<br/>  margin: 0;<br/>  padding: 0;<br/>}<br/>li {<br/>  padding: 0.4em 0;<br/>}</span><span id="a959" class="lh li iq me b gy mn mk l ml mm">@media (max-width: 1000px) {<br/>  body {<br/>    font-size: 18px;<br/>  }<br/>}<br/>@media (max-width: 710px) {<br/>  body {<br/>    padding: 1em 1em;<br/>    font-size: 16px;</span><span id="5d2e" class="lh li iq me b gy mn mk l ml mm">    grid-template-columns: 1fr;<br/>  }<br/>}</span></pre><p id="137d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可以看到我们是如何定义一些通用的文本颜色、边框颜色、字体系列和阴影的。所有这些都是变量，所以我们可以重用它们。接下来，主体获取颜色、边距和填充，最重要的是，两列的网格布局。如果我们跳到底部，我们会看到网格是如何为移动宽度重新定义为单列的。请注意我们如何改变不同宽度的字体大小:<code class="fe mb mc md me b">20px</code>用于桌面，<code class="fe mb mc md me b">18px</code>用于桌面，<code class="fe mb mc md me b">16px</code>用于手机。</p><p id="8767" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">还要注意填充和边距都是如何用<code class="fe mb mc md me b">em</code>单位表示的。只要我们到处使用<code class="fe mb mc md me b">em</code>，当我们为不同的窗口宽度减小<code class="fe mb mc md me b">font-size</code>时，它们都会自动调整大小。如果我们以像素为单位指定所有字体，我们将不得不使用媒体查询来调整它们。对于<code class="fe mb mc md me b">em</code>就不是这样了，它是一个相对单位。这给了我们一个好处，即说出我们想要什么样的<code class="fe mb mc md me b">em</code>大小，然后当媒体查询生效时，因为它调整了<code class="fe mb mc md me b">body</code>中的基数<code class="fe mb mc md me b">font-size</code>，一切都会随之而来。</p><p id="ec94" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">尽管这个基本 CSS 很短，但它定义了我们需要的所有东西，以获得一个具有两列的完全响应的布局。让我们建立我们的 HTML。</p><h2 id="0ce5" class="lh li iq bd lj lk ll dn lm ln lo dp lp ko lq lr ls ks lt lu lv kw lw lx ly lz bi translated">HTML 模拟</h2><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ma"><img src="../Images/ea62c2ea2ecafd225d75725ccffc00f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Lw9PHq_cEKoxHemNGADGSg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">index.html 档案一瞥</figcaption></figure><p id="8ae9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mb mc md me b">index.html</code>现在将简单地显示假数据，这样我们可以看到我们的应用程序将会是什么样子:</p><pre class="lc ld le lf gt mf me mg mh aw mi bi"><span id="2919" class="lh li iq me b gy mj mk l ml mm">&lt;!DOCTYPE html&gt;<br/>&lt;html lang="en"&gt;<br/>&lt;head&gt;<br/>  &lt;title&gt;RSS Reader&lt;/title&gt;<br/>  &lt;meta charset="UTF-8"&gt;<br/>  &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;<br/> <br/>  &lt;link rel="stylesheet" href="index.css"&gt;<br/>  &lt;link rel="icon" href="favicon.svg"&gt;</span><span id="f297" class="lh li iq me b gy mn mk l ml mm">  &lt;script type="module" src="index.js"&gt;&lt;/script&gt;<br/>&lt;/head&gt;<br/>&lt;body&gt;<br/>  &lt;nav&gt;<br/>    &lt;ul id="feeds" class="feeds"&gt;<br/>      &lt;li&gt;&lt;a href="#"&gt;The Verge&lt;/a&gt;&lt;/li&gt;<br/>      &lt;li&gt;&lt;a href="#"&gt;Ars Technica&lt;/a&gt;&lt;/li&gt;<br/>      &lt;li&gt;&lt;a href="#"&gt;Hacker News&lt;/a&gt;&lt;/li&gt;<br/>    &lt;/ul&gt;<br/>  &lt;/nav&gt;</span><span id="ecfc" class="lh li iq me b gy mn mk l ml mm">  &lt;main&gt;<br/>    &lt;ul id="articles" class="articles"&gt;<br/>      &lt;li&gt;<br/>        &lt;details&gt;<br/>          &lt;summary&gt;Article 1&lt;/summary&gt;<br/>          &lt;div&gt;Article 1 summary&lt;/div&gt;<br/>        &lt;/details&gt;<br/>      &lt;/li&gt;<br/>    &lt;/ul&gt;<br/>    &lt;a class="back" href="#"&gt;Back&lt;/a&gt;<br/>  &lt;/main&gt;<br/>&lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="8115" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们在顶部有通常的<code class="fe mb mc md me b">meta</code>声明，一个到<code class="fe mb mc md me b">index.css</code>文件的链接，我们将在下面介绍，一个到<code class="fe mb mc md me b">index.js</code>的链接和一个到 favicon 的链接。注意，favicon 是一个<code class="fe mb mc md me b">svg</code>文件。我强烈推荐使用<code class="fe mb mc md me b">svg</code>图标。它们完全受所有浏览器的支持，可以在所有分辨率下缩放，并且通常非常小。使用它们时，你需要考虑的事情就少多了。</p><p id="b50c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">HTML 主体有两个元素:左边一列包含提要列表的<code class="fe mb mc md me b">nav</code>位和右边一列显示文章的<code class="fe mb mc md me b">main</code>位。它还有一个移动视图的后退按钮，一次只能显示一列。因此，当您选择一个提要时，您将看到文章和返回到提要列表的后退按钮。在台式机和平板电脑上，后退按钮将被隐藏。</p><p id="6720" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当然，一旦我们读取了数据，所有的模拟数据都会被真实数据所取代。现在我们只是用它来弄清楚 UI。<code class="fe mb mc md me b">index.html</code>文件引用一个 CSS 文件和一个 Javascript 文件。<code class="fe mb mc md me b">base.css</code>文件定义了应用程序的总体布局。<code class="fe mb mc md me b">index.css</code>文件定义了<code class="fe mb mc md me b">index.html</code>页面使用的细节。让我们来看看:</p><pre class="lc ld le lf gt mf me mg mh aw mi bi"><span id="47ab" class="lh li iq me b gy mj mk l ml mm">@import url(/shared/styles/base.css);</span><span id="2aba" class="lh li iq me b gy mn mk l ml mm">summary {<br/>  cursor: pointer;<br/>}<br/>summary::marker {<br/>  content: none;<br/>}</span><span id="66eb" class="lh li iq me b gy mn mk l ml mm">ul.articles li {<br/>  border-bottom: 1px solid var(--border-color);<br/>}<br/>ul.articles li div {<br/>  padding: 1em 0 0.2em 0;<br/>}<br/>ul.feeds li.selected a {<br/>  text-shadow: var(--selection-shadow);<br/>}<br/>ul.articles li.selected summary {<br/>  text-shadow: var(--selection-shadow);<br/>}</span><span id="2e70" class="lh li iq me b gy mn mk l ml mm">a.back {<br/>  display: none;<br/>}</span><span id="3a8d" class="lh li iq me b gy mn mk l ml mm">@media (max-width: 710px) {<br/>  main {<br/>    display: none;<br/>  }</span><span id="9f10" class="lh li iq me b gy mn mk l ml mm">  body.feed-selected nav {<br/>    display: none;<br/>  }<br/>  body.feed-selected main {<br/>    display: block;<br/>  }</span><span id="9a5d" class="lh li iq me b gy mn mk l ml mm">  a.back {<br/>    display: block;<br/>    padding-top: 2em;<br/>  }<br/>}</span></pre><p id="a199" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">细节是与主布局无关的一切:后退按钮何时出现，<code class="fe mb mc md me b">nav</code>和<code class="fe mb mc md me b">main</code>何时出现在移动宽度上，所选提要如何高亮显示，<code class="fe mb mc md me b">details</code>标签看起来如何。</p><p id="28b6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是请注意顶部的<code class="fe mb mc md me b">import</code>。文件<code class="fe mb mc md me b">index.html</code>简单地引用了它的<code class="fe mb mc md me b">index.css</code>文件，它不知道其他任何事情。理解<code class="fe mb mc md me b">base.css</code>的要求是<code class="fe mb mc md me b">index.css</code>的责任，所以我们在这里指定。在<code class="fe mb mc md me b">index.html</code>中加载<code class="fe mb mc md me b">base.css</code>和在这里加载有什么区别？这个<code class="fe mb mc md me b">index.html</code>文件简单地使用需要的标签构建 UI，它不关心样式。风格掌握在 CSS 手中。如果我们把现在的<code class="fe mb mc md me b">index.css</code>换成另一个，我们可以引用不同的基本样式:我们可以改变一切，而<code class="fe mb mc md me b">index.html</code>对此一无所知。关注点的完美分离。让我们看看 Javascript 文件:</p><pre class="lc ld le lf gt mf me mg mh aw mi bi"><span id="f3c1" class="lh li iq me b gy mj mk l ml mm">document.getElementById("feeds").addEventListener("click", (e) =&gt; {<br/>  document.body.classList.add("feed-selected");</span><span id="0dfa" class="lh li iq me b gy mn mk l ml mm">  const selection = document.querySelector("#feeds li.selected");<br/>  if (selection) selection.classList.remove("selected");<br/>  e.target.closest("li").classList.add("selected");<br/>});</span><span id="f012" class="lh li iq me b gy mn mk l ml mm">document.getElementById("articles").addEventListener("click", (e) =&gt; {<br/>  const selection = document.querySelector("#articles li.selected");<br/>  <br/>  if (selection) selection.classList.remove("selected");<br/>  e.target.closest("li").classList.add("selected");<br/>});</span><span id="a16a" class="lh li iq me b gy mn mk l ml mm">document.querySelector(".back").addEventListener("click", () =&gt; {<br/>  document.body.classList.remove("feed-selected");<br/>});</span></pre><p id="f18c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们只是处理提要和文章选择，以及点击后退按钮。如果我们选择了一篇文章，我们向它添加一个<code class="fe mb mc md me b">selected</code>类，对于提要也是如此。此外，如果我们单击一个提要，我们将<code class="fe mb mc md me b">feed-selected</code>类设置为<code class="fe mb mc md me b">body</code>，宣布一个提要被选中，并允许我们更改移动 UI 以显示文章，当我们单击<code class="fe mb mc md me b">back</code>按钮时，我们清除该类以返回到初始状态。</p><h2 id="f289" class="lh li iq bd lj lk ll dn lm ln lo dp lp ko lq lr ls ks lt lu lv kw lw lx ly lz bi translated">懒惰加载一切</h2><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mo"><img src="../Images/4840f1882c89b81e54852478a0364859.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f-bFP5xUW8x5t8u86C6RPA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">HTML 请求图</figcaption></figure><p id="bb6f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们看一下请求图，看看所有的东西是如何缓慢加载的。在上面右边网络面板的截图中，看看东西是如何加载的。我把连接速度调得很慢，这样我们就能看得很清楚了。首先，当然是加载<code class="fe mb mc md me b">index.html</code>文件。<code class="fe mb mc md me b">index.html</code>文件直接链接<code class="fe mb mc md me b">index.css</code>和<code class="fe mb mc md me b">index.js</code>，所以它们同时加载 next。下一个<code class="fe mb mc md me b">base.css</code>由<code class="fe mb mc md me b">index.css</code>请求，因此它遵循。最后是网站图标。</p><p id="9d5f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">类型为<code class="fe mb mc md me b">module</code>的<code class="fe mb mc md me b">index.html</code>加载了<code class="fe mb mc md me b">index.js</code>文件。这意味着它也可以异步加载。一旦我们开始向应用程序中添加更多的 Javascript 文件，我们将更详细地了解这是如何发生的。我们还将看到每一个需要的 Javascript 文件是如何被<code class="fe mb mc md me b">index.js</code>导入的，就像<code class="fe mb mc md me b">index.css</code>导入<code class="fe mb mc md me b">base.css</code>一样。</p><p id="31cf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Chrome 浏览器更详细地显示了启动器。它会告诉你谁引用了哪个文件，你会看到<code class="fe mb mc md me b">base.css</code>是被<code class="fe mb mc md me b">index.css</code>引用的，而不是被<code class="fe mb mc md me b">index.html</code>引用的。不幸的是，Firefox 更加通用。</p></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><p id="07aa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">暂时就这样了。下次我们将开始制作我们的第一个<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/html5-rss-reader-writing-the-first-web-components-949eec88dbf9"> HTML5 web 组件</a>。我们还将了解本地 Javascript 模块是如何工作的。他们现在已经完全发挥作用有一段时间了，所以现在可能是时候放弃需要像 Webpack 这样的捆绑器的旧类型模块了。</p><p id="4f3f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">代码一如既往地在<a class="ae kc" href="https://github.com/raduzaharia-medium/html5-rss-reader-mock-ui" rel="noopener ugc nofollow" target="_blank"> Github </a>上可用，但是正如我在<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/initial-setup-for-a-rust-web-application-using-web-components-and-native-javascript-modules-ee832c062e8a">上一篇文章</a>中所写的，不要急于克隆它。你现在不需要它。试着用自己的方式思考这篇文章，然后自己写出来。祝你好运，下次再见！</p></div></div>    
</body>
</html>