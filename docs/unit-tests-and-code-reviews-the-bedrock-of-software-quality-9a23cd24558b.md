# 单元测试和代码评审:软件质量的基石

> 原文：<https://blog.devgenius.io/unit-tests-and-code-reviews-the-bedrock-of-software-quality-9a23cd24558b?source=collection_archive---------1----------------------->

![](img/95197f40eccb236c08475a20031cb63d.png)

凯文·Ku 在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的照片

*作者注:在这篇文章中，我假设读者对现代代码评审是什么以及单元测试是什么有一个很好的理解。*

# 背景

测试和质量专家通常认为，为了达到质量，您需要大量的端到端测试来验证所有的用户需求。我不同意。当然，我们需要测试，但是大部分应该是单元测试。同样，代码评审和单元测试是软件质量的基础。

顺便提一下，在 Smartbear 的“2019 年代码审查状态”中(见[1])，参与者被问及他们的公司可以做的提高质量的第一件事是什么，代码审查和单元测试排在第二位，功能测试排在第六位。

这是为什么呢？让我们再深入一点。但首先讲一个小故事。

# 橡胶锤

西蒙·西内克在他的书《从为什么开始:伟大的领导者如何激励每个人采取行动》(见[6])中讲述了一个关于“橡胶锤”的故事。在那里，西蒙讲述了美国汽车高管参观日本汽车工厂的故事。

有一个很精彩的故事，讲的是一群美国汽车高管去日本看日本的一条装配线。在生产线的末端，门被装在铰链上，和美国一样。但是缺少了一些东西。在美国，一线工人会拿一个橡皮锤，轻轻敲打门的边缘，以确保门完全贴合。在日本，这种工作似乎并不存在。困惑之余，美国汽车公司的高管们问，他们在什么时候确保门完全合适。他们的日本导游看着他们，不好意思地笑了。“我们在设计时确保它适合我们。”在日本汽车工厂，他们没有检查问题并积累数据来找出最佳解决方案——他们从一开始就设计了他们想要的结果。如果他们没有达到他们想要的结果，他们明白这是因为他们在过程开始时所做的决定。一天结束时，当美国制造和日本制造的汽车从装配线上下来时，它们的车门看起来很合适。除了日本人不需要雇人敲门，也不需要买任何木槌。更重要的是，日本的门可能更耐用，甚至在事故中结构更坚固。所有这一切都是因为他们从一开始就确保了零件的一致性”

在某些方面，敲门的行为很像在发布之前运行端到端的测试。与其在过程的最后检查可能没有正确实现的东西，不如确保实现的东西在成为代码库的一部分之前就真正正确地实现了。这就是代码审查和单元测试的用武之地。

# 代码审查

编码是一门手艺。代码评审就像学徒和同行评审。团队开发的代码应该具有一定程度的一致性，这样团队中的任何开发人员都能够获得代码的一部分并对其进行处理。

在《干净代码:敏捷软件工艺手册》[2]一书中，几位行业专家被问及什么是好代码。总而言之，

1.  代码应该易于阅读和理解
2.  代码必须附有测试，并且是可测试的
3.  代码应该具有最小的依赖性
4.  代码应该在不损害可维护性的情况下尽可能高效
5.  从界面的设计就应该清楚代码应该如何表现，它应该按照预期表现

在“一个代码审查规则如何将我的团队变成一个梦之队”[3]中，Elena Flat 讲述了她的经历，因为她的团队在过去已经建立了强大的代码审查实践，他们能够标记团队在第二天早些时候为一个重要的客户会议进行一些最后一分钟的功能更改。没有 SPOF(单点故障),其中一部分代码只被一个开发人员理解。

那么这和质量有什么关系呢？嗯，就像科学论文的同行评审或文档的同行编辑一样，代码评审有助于清除代码中的问题。出现问题的原因可能有多种:

1.  代码是否满足了它应该满足的产品需求？
2.  代码有足够的测试覆盖率吗？
3.  提交的代码是否组织良好，易于理解？它是否给读者带来了过多的认知负担？
4.  代码是否潜在地增加了不必要的性能开销
5.  代码是否遵循良好的软件工程原则，例如低圈复杂度、低耦合、高内聚？

好的代码评审会带来好的代码质量。但这与整体系统或应用程序质量有什么关系呢？让我们来回答每个问题，看看它与整体质量的关系。

代码是否满足了它应该满足的产品需求？

这是不言自明的。如果代码变更没有满足产品需求，那么您就引入了一个 bug。代码运行是否完美并不重要。如果它没有做它应该做的事情，那么它就是一个 bug。

**代码有足够的测试覆盖率吗？**

测试本质上是为了确保关于代码的假设得到执行。没有人会在一周后记住一段代码中的所有假设，甚至作者自己也不会忘记。如果测试在代码更改后中断，这意味着基于现有代码的现有假设，新代码中的某些假设是不正确的。这就是为什么每个代码变更都伴随着相应的测试和足够的覆盖率是至关重要的。

在测试驱动开发(TDD)中，这被发挥到了极致。在编写测试来验证功能代码满足需求之前，不要编写任何一段功能代码。

提交的代码是否组织良好，易于理解？它是否给读者带来了过多的认知负担？

想象一下这种情况:你在一个星期五的凌晨 2 点遇到了一个关键的产品 bug。你已经度过了漫长的一周，但是 SLA 要求你尽快修复这个 bug。你去看看代码，看看有什么问题，你诅咒和发誓，因为上一个开发这部分代码的人让它变得难以理解。他试图提供帮助，发表了很多评论，但你无法判断这些评论是否仍然有效。最糟糕的是，他上周离开了公司，你知道他目前正在亚马逊丛林休假，因此无法联系。

虽然这种情况听起来有点不可思议，但实际上却非常普遍。遗留代码会导致严重的产品错误，这对任何开发人员来说都是一种祸害。最重要的是，难以理解的代码也是更多错误的来源，因为开发人员不知道他所做的代码更改是否会“爆炸”。这有点像我们在电影中看到的英雄试图通过切断正确的电线来禁用炸弹。

**代码是否潜在地增加了不必要的性能开销**

这很简单。质量的一个方面是你的系统性能如何。这可以转化为响应时间、冷启动时间(对于移动应用程序)、页面加载时间等。如果代码更改增加了显著的性能开销，那么它会影响系统的整体质量。

**代码是否遵循良好的软件工程原则，例如低圈复杂度、低耦合、高内聚？**

这关系到理解和解决代码问题的难易程度。这里有两个关键指标:圈复杂度和认知复杂度。不久前，我制作了一个[幻灯片来解释这两个指标。这些度量也涵盖了好的软件工程的关键方面，比如高内聚和低耦合。](https://www.slideshare.net/HeemengFoo/cyclomatic-and-cognitive-complexity)

## 一些伟大的代码审查指南

我个人发现谷歌的代码审查指南和 T2 的 Gitlab 的代码审查指南都非常适合作为团队的基础。

# 单元测试

在代码审查之后，单元测试是针对 bug 的下一层防御。在“对端到端测试说不”(见[5])中，Mike Wacker 展示了*测试金字塔*。底部是单元测试。他们在金字塔的底部，因为(a)他们是基础，(b)他们应该是最多的。

然而在现实中，有一些团队采用了反向金字塔——端到端测试比单元测试多得多。这通常是因为人们疯狂地追求产品与市场的匹配，因此对产品进行了大量创造性的迭代，因此很少编写测试。然后，一旦公司明确支持客户，他们就与咨询公司合作，或者雇佣一群测试工程师来编写端到端的测试，以自动验证构建。

为什么这不是一个可持续的解决方案，为什么单元测试是产品质量的关键？以下是原因:

1.  您可以用单元测试来度量测试覆盖率
2.  单元测试的总拥有成本(TCO)比端到端测试要便宜得多
3.  单元测试是很好的防护栏
4.  单元测试有效地记录了代码

在我进入第一点之前。你可以用单元测试来度量测试覆盖率，那些测试/质量专业人士一定会说“等等，功能覆盖率呢？这难道不包括端到端测试吗？”这就引出了我的下一点。

## 关于功能测试覆盖率的真相

本质上，功能测试覆盖是不可靠的。是的，这意味着如果一个测试或 QA 经理(我们将继续使用术语测试经理)说他有 100%的功能覆盖，你应该有所保留。

要理解为什么，您需要理解我们如何达到单元测试覆盖率。对于那些对分支覆盖没有理论理解的人，我推荐你浏览我的关于圈复杂度的幻灯片[。](https://www.slideshare.net/HeemengFoo/cyclomatic-and-cognitive-complexity)

我们计算分支覆盖率的方法是首先将代码表示为一个图(就像在图论中一样，而不是统计学中)。然后我们通过代码识别所有的*代码路径*。使用圈复杂度数，我们可以知道达到 100%分支覆盖率所需的单元测试数量的上限是多少。这意味着我们有了测量代码覆盖率的理论基础。

功能覆盖在大多数情况下没有这么强的数学基础。我说“大多数”是因为在*正式规范语言*中，你接近这样一个强大的基础。

下面是一个测试自动化是如何产生的典型场景。

1.  产品经理提出产品规格或产品需求文档(PRD)
2.  工程或测试经理然后使用 PRD 作为输入建立测试计划。然后，她将 PRD 中的各种需求分解成测试用例
3.  测试用例然后被实现到测试代码中

当我们说我们有 100%的功能覆盖时，我们的意思是测试计划中的每个测试都有一个等价的自动化测试。

这张图有什么问题？首先，我们如何知道珠三角是完整的？实际上，它通常要么是不完整的，要么是部分基于不正确的假设。这就是为什么构建最小可行产品(MVP ),然后严格应用 A/B 测试来提炼产品需求的实践变得如此流行的原因。

接下来，我们如何知道 PRD 到测试计划/案例的转换是否完成了？我们怎么知道它是一个双射映射？事实是我们没有。通常情况下，测试计划评审是由测试经理和关键利益相关者(如产品经理、工程领导等)一起进行的。以获得认同。这个过程容易出现人为错误。

最后，测试用例被翻译成测试代码。我们还有一个翻译报道的问题。我们如何知道翻译是否执行正确？事实是，我们无法保证这一点，因为这一过程也会受到人为错误的影响。

另外，对于那些感兴趣的人来说， [ProdPerfect](http://prodperfect.com) 有一种新颖的方法来测量 Web 端到端测试的功能覆盖率，值得一看。

## 为什么单元测试是产品质量的关键？

**你可以用单元测试来测量测试覆盖率**

这在上一节中已经介绍过了。事实上，现代工具，比如 SonarQube 甚至可以帮助你直观地看到单元测试没有覆盖到你的代码的哪些部分。

关键是:你能准确衡量的，你就能改进。

**单元测试的总拥有成本(TCO)比端到端测试便宜得多**

在典型的应用程序设置中，端到端测试包括 UI 级别的自动化测试。这提出了几个问题:

1.  由于各种原因，UI 测试被认为是“不可靠的”或不可靠的。如果您正在开发一个 Web 应用程序，可能会有浏览器 Javascript 引擎问题，或者后端的延迟问题
2.  由于后端 API 的各种问题，测试不可靠
3.  由于应用程序运行在移动设备或 PC 等硬件上，测试不可靠
4.  由于测试时间长，测试不可靠。例如，端到端测试可能会模拟用户执行购买流程，因为它需要几分钟(而不是几秒钟)来运行，这增加了(2)和(3)发生的可能性。
5.  由于测试依赖于某些数据配置，测试不可靠

所有这些问题都会导致误报。测试失败不是真正的失败，因为人类用户能够处理。这些误报需要人工干预以便从中恢复，因此增加了操作的总成本。

另一方面，单元测试通常是不涉及 UI 的小代码，因此构建、维护和运行起来要便宜得多。开发人员还可以在编写了一些新代码后快速运行单元测试套件，以查看是否有任何问题，而不必花费太多时间来构建整个应用程序。例如，如果您正在 Android 应用程序中处理几个 Java 类，如果它不涉及 UI，您不需要构建整个应用程序来测试您的代码。

为什么这是产品质量的关键？因为构建和维护成本更低，所以鼓励开发人员编写更多的测试。这就引出了下一点。

**单元测试造就伟大的护栏**

开发人员面临的一个问题是，他们可能某一天在代码库的一个区域工作，而第二天在另一个区域工作。这样做了几天后，他们会完全不知道几天前他们在做什么。他们可以盯着代码，完全不知道是什么让他们像几天前那样写代码。

![](img/655102c265ab51acb1794aa677dca77a.png)

婴儿卫士？由 [Les Anderson](https://unsplash.com/@lesanderson?utm_source=medium&utm_medium=referral) 在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄的照片

这就是单元测试的用武之地。他们对于开发者来说就像 ***【宝宝卫士】*** 。如果你的新代码违反了对代码的假设，一些单元测试(如果写得好的话)将会失败，你会说“哦，这很奇怪？”。这将引导你找出失败的原因，关于测试的假设是什么，看看这个假设是否仍然成立。这有两种可能的结果:(a)修正你的代码，使测试通过(b)修正测试，因为使测试为真的假设不再成立。

这就把我们带到了下一点。

**单元测试有效地记录代码**

一位非常有经验的软件工程师曾经告诉我“代码最准确的文档就是代码本身”。这是真的，因为在这个由持续部署驱动的一天发布多个版本的时代，手工编写的文档已经过时了。这就是 Swagger、Javadoc、pydoc 等工具如此受欢迎的原因——它们允许自动生成代码文档。

单元测试如何有效地记录代码？如果你运行他们，他们应该工作。理解代码如何工作的最好方法是看它的运行。此外，如果测试写得很好，它们将验证开发人员在编写代码时的所有假设。测试记录了这些假设。另一个开发人员(或一段时间后的同一个开发人员)在查看测试时将能够弄清楚那些假设是什么，如何使用代码以及其使用的界限是什么。

这对产品质量有什么影响？如果开发人员理解她正在处理的代码，她犯错误的机会就少了。

# 单元测试和代码评审是携手并进的

我不仅说单元测试和代码评审是软件质量的基石，如果两者都执行得很好，那么结果会比各部分的总和更大。原因是:

1.  单元测试结果对代码评审有很大的帮助
2.  代码评审员从查看单元测试中受益

## 单元测试结果对代码评审有很大的帮助

原因很简单:如果新代码破坏了现有的测试，那么一定是出了问题。开发人员应该首先确保新代码不会破坏测试，或者测试被修改以满足新的假设或需求。这将作为代码评审输入的一部分得到反映，因为大多数现代代码库管理工具，如 Github、Gitlab，将标记出您提交的所有代码更改。这将允许代码评审员提出问题:“为什么测试被改变了？是什么假设或要求发生了变化导致了这种情况？”

## 代码评审员从查看单元测试中受益

正如我之前提到的，单元测试记录了代码，开发人员在代码库的一部分工作时，很可能过一会儿就忘记了代码库的另一部分在做什么。当她审查一个代码变更时，她可能已经忘记了那个部分是如何工作的，但是通过查看测试，她能够弄清楚它。

# 结论

我希望现在你明白了为什么我说代码评审和单元测试构成了软件质量的基石，并且如果你想获得好的产品质量，你需要考虑拥有好的代码评审和单元测试。

# 参考

[1]“2019 年代码状态回顾”，2020，Smartbear，[https://smart bear . com/resources/ebooks/the-State-of-code-review-2019](https://smartbear.com/resources/ebooks/the-state-of-code-review-2019/#:~:text=The%20State%20of%20Code%20Review,and%20Insights%20for%20Dev%20Collaboration&text=This%20is%20the%206th%20Annual,practices%20common%20across%20software%20development.)

[2]《干净的代码:敏捷软件工艺手册》，罗伯特·C·马丁，皮尔森出版社，2008 年

[3]“一个代码审查规则如何将我的团队变成梦之队”，Elena Flat，Medium，2020 年 4 月，[https://Medium . com/inside-league/How-one-code-review-rule-turned-my-team-a-dream-team-fdb 172799d 11](https://medium.com/inside-league/how-one-code-review-rule-turned-my-team-into-a-dream-team-fdb172799d11)

[4]圈与认知复杂性，Hee-Meng Foo，2020 年 4 月，www.slideshare.net，[https://www . slide share . net/Hee Meng Foo/圈与认知复杂性](https://www.slideshare.net/HeemengFoo/cyclomatic-and-cognitive-complexity)

[5]“对端到端测试说不”，2015 年 4 月，Mike Wacker，谷歌测试博客，[https://Testing . Google Blog . com/2015/04/Just-say-no-to-more-end-to-end-end-tests . html](https://testing.googleblog.com/2015/04/just-say-no-to-more-end-to-end-tests.html)

[6]“从为什么开始:伟大的领导者如何激励每个人采取行动”Simon Sinek，2011 年 12 月，作品集