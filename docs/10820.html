<html>
<head>
<title>Its Okay If You Don’t Know Java Polymorphism?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如果你不知道 Java 多态性，没关系？</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/its-okay-if-you-dont-know-java-polymorphism-31530df3c4e0?source=collection_archive---------6-----------------------#2022-12-02">https://blog.devgenius.io/its-okay-if-you-dont-know-java-polymorphism-31530df3c4e0?source=collection_archive---------6-----------------------#2022-12-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="6114" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">软件工程之旅</h2><div class=""/><div class=""><h2 id="cc7c" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">为了学习如何以不同的方式执行某些任务，软件工程师应该熟悉多态性的概念。</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/715030ea00640b71821f1b27fefb9137.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bNPT2cFM3GlVFdGt"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">照片由来自 pianalytix 的 pianalytix mlops 拍摄</figcaption></figure><p id="83ee" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><strong class="lg ja">简介</strong></p><p id="005c" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">让我们首先用一种非常通俗的语言来理解 Java 多态性到底是什么，这是一个我们可以用多种方式执行一项任务的概念。</p><p id="e7a7" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">单词 Polymorphism 由两个希腊单词组成，即 poly 和 morphs，分别表示许多和形式。</p><p id="20d8" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">java 中有两种类型的多态性</p><ol class=""><li id="6f69" class="ma mb iq lg b lh li lk ll ln mc lr md lv me lz mf mg mh mi bi translated">编译时多态性</li><li id="75d6" class="ma mb iq lg b lh mj lk mk ln ml lr mm lv mn lz mf mg mh mi bi translated">运行时多态性</li></ol><h1 id="1849" class="mo mp iq bd mq mr ms mt mu mv mw mx my kf mz kg na ki nb kj nc kl nd km ne nf bi translated">编译时多态性</h1><p id="1ba6" class="pw-post-body-paragraph le lf iq lg b lh ng ka lj lk nh kd lm ln ni lp lq lr nj lt lu lv nk lx ly lz ij bi translated">如果在 Java 中重载静态方法，这就是编译时多态性的一个例子。</p><p id="6ca1" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">但是在我们学习编译时多态性之前，我们应该了解“方法重载”，因为这是编译时多态性的原因。</p><p id="3de2" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">它也被称为静态多态性。</p><h1 id="2a1a" class="mo mp iq bd mq mr ms mt mu mv mw mx my kf mz kg na ki nb kj nc kl nd km ne nf bi translated">方法重载:</h1><p id="b1ea" class="pw-post-body-paragraph le lf iq lg b lh ng ka lj lk nh kd lm ln ni lp lq lr nj lt lu lv nk lx ly lz ij bi translated">当一个类有多个同名但参数不同的方法时，这就是所谓的方法重载。</p><p id="f3ed" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">它增加了程序的可读性。</p><p id="d191" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">假设您必须执行给定数字的加法，但是可以有任意数量的参数，如果您编写的方法(如 a(int，int)用于两个参数，b(int，int，int)用于三个参数)可能会让您和其他程序员很难理解该方法的行为，因为它的名称不同。</p><p id="861e" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">因此，我们执行方法重载来快速找出程序。</p><p id="a351" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">我们可以通过以下方式重载该方法</p><ol class=""><li id="6106" class="ma mb iq lg b lh li lk ll ln mc lr md lv me lz mf mg mh mi bi translated">通过改变参数的数量</li><li id="8c41" class="ma mb iq lg b lh mj lk mk ln ml lr mm lv mn lz mf mg mh mi bi translated">通过更改数据类型</li></ol><p id="31d2" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><strong class="lg ja">示例 1: </strong>通过改变参数的数量来重载方法。</p><pre class="kp kq kr ks gt nl nm nn bn no np bi"><span id="92f0" class="nq mp iq nm b be nr ns l nt nu">class Adder{<br/>static int add(int a,int b){return a+b;}<br/>static int add(int a,int b,int c){return a+b+c;}<br/>}<br/><br/>class TestOverloading1{<br/>public static void main(String[] args){<br/>System.out.println(Adder.add(11,11));<br/>System.out.println(Adder.add(11,11,11));<br/>} }</span></pre><p id="5347" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><strong class="lg ja">输出:</strong></p><pre class="kp kq kr ks gt nl nm nn bn no np bi"><span id="5de5" class="nq mp iq nm b be nr ns l nt nu">22<br/>33</span></pre><p id="a66d" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><strong class="lg ja">例 2: </strong>通过改变数据类型实现方法重载。</p><pre class="kp kq kr ks gt nl nm nn bn no np bi"><span id="e785" class="nq mp iq nm b be nr ns l nt nu">class Adder{<br/>static int add(int a, int b){return a+b;}<br/>static double add(double a, double b){return a+b;}<br/>}<br/><br/>class TestOverloading2{<br/>public static void main(String[] args){<br/>System.out.println(Adder.add(11,11));<br/>System.out.println(Adder.add(12.3,12.6));<br/>} }</span></pre><p id="c6f6" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><strong class="lg ja">输出:</strong></p><pre class="kp kq kr ks gt nl nm nn bn no np bi"><span id="b6e8" class="nq mp iq nm b be nr ns l nt nu">22<br/>24.9</span></pre><p id="df0d" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><strong class="lg ja">注意:重载时需要记住的几点:</strong></p><ul class=""><li id="61b6" class="ma mb iq lg b lh li lk ll ln mc lr md lv me lz nv mg mh mi bi translated">我们不能改变这个方法的返回类型，因为这会引起歧义</li><li id="e367" class="ma mb iq lg b lh mj lk mk ln ml lr mm lv mn lz nv mg mh mi bi translated">我们也可以重载 main 方法，一个类中可以有任意数量的 main 方法。但是 JVM 调用 main()方法，该方法只接收字符串数组作为参数。</li></ul><p id="75ca" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><strong class="lg ja">示例:</strong></p><pre class="kp kq kr ks gt nl nm nn bn no np bi"><span id="a0eb" class="nq mp iq nm b be nr ns l nt nu">class TestOverloading4{<br/>public static void main(String[] args){System.out.println("main with String[]");}<br/>public static void main(String args){System.out.println("main with String");}<br/>public static void main(){System.out.println("main without args");}<br/>}</span></pre><p id="89fd" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><strong class="lg ja">输出:</strong></p><pre class="kp kq kr ks gt nl nm nn bn no np bi"><span id="7fcf" class="nq mp iq nm b be nr ns l nw nu">main with String[]</span></pre><h1 id="348f" class="mo mp iq bd mq mr ms mt mu mv mw mx my kf mz kg na ki nb kj nc kl nd km ne nf bi translated">运行时多态性</h1><p id="2379" class="pw-post-body-paragraph le lf iq lg b lh ng ka lj lk nh kd lm ln ni lp lq lr nj lt lu lv nk lx ly lz ij bi translated">运行时多态也称为<strong class="lg ja">动态方法分派</strong>是一个在运行时而不是编译时解析对被覆盖方法的调用的过程。</p><p id="c256" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">在这个过程中，通过超类的引用变量调用被覆盖的方法。要调用的方法的确定基于引用变量所引用的对象。</p><p id="85a1" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><strong class="lg ja">上抛</strong>如果父类的引用变量引用了子类的对象。</p><p id="4ebb" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><strong class="lg ja">例子:</strong></p><pre class="kp kq kr ks gt nl nm nn bn no np bi"><span id="89fe" class="nq mp iq nm b be nr ns l nt nu">class Bike{<br/>void run(){System.out.println("running");}<br/>}<br/>class Splendour extends Bike{<br/>void run(){System.out.println("running safely with 60km");}<br/>public static void main(String args[]){<br/>Bike b = new Splendor();//upcasting<br/>b.run();<br/>}<br/>}</span></pre><p id="3cb3" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><strong class="lg ja">输出:</strong></p><pre class="kp kq kr ks gt nl nm nn bn no np bi"><span id="5448" class="nq mp iq nm b be nr ns l nw nu">running safely with 60km.</span></pre><h1 id="4a15" class="mo mp iq bd mq mr ms mt mu mv mw mx my kf mz kg na ki nb kj nc kl nd km ne nf bi translated">方法覆盖</h1><p id="4998" class="pw-post-body-paragraph le lf iq lg b lh ng ka lj lk nh kd lm ln ni lp lq lr nj lt lu lv nk lx ly lz ij bi translated">如果一个子类拥有与父类相同的方法，这在 Java 中被称为方法覆盖。方法重写用于运行时多态性。</p><p id="2d2d" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">Java 方法覆盖的规则</p><ol class=""><li id="c6d7" class="ma mb iq lg b lh li lk ll ln mc lr md lv me lz mf mg mh mi bi translated">该方法必须与父类中的名称相同</li><li id="0ea2" class="ma mb iq lg b lh mj lk mk ln ml lr mm lv mn lz mf mg mh mi bi translated">该方法必须具有与父类中相同的参数。</li><li id="dd78" class="ma mb iq lg b lh mj lk mk ln ml lr mm lv mn lz mf mg mh mi bi translated">必须有一个 IS-A 关系(继承)</li></ol><p id="3519" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><strong class="lg ja">举例:</strong></p><pre class="kp kq kr ks gt nl nm nn bn no np bi"><span id="fc45" class="nq mp iq nm b be nr ns l nt nu">class Vehicle{<br/>//defining a method<br/>void run(){System.out.println("Vehicle is running");}<br/>}<br/>//Creating a child class<br/>class Bike extends Vehicle{<br/>//defining the same method as in the parent class<br/>void run(){System.out.println("Bike is running safely");}<br/>public static void main(String args[]){<br/>Bike obj = new Bike();//creating object<br/>obj.run();//calling method<br/>}<br/>}</span></pre><p id="32b1" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><strong class="lg ja">输出:</strong></p><pre class="kp kq kr ks gt nl nm nn bn no np bi"><span id="3009" class="nq mp iq nm b be nr ns l nw nu">Bike is running safely</span></pre><h1 id="bfa2" class="mo mp iq bd mq mr ms mt mu mv mw mx my kf mz kg na ki nb kj nc kl nd km ne nf bi translated">使用数据成员的运行时多态性</h1><p id="b324" class="pw-post-body-paragraph le lf iq lg b lh ng ka lj lk nh kd lm ln ni lp lq lr nj lt lu lv nk lx ly lz ij bi translated">方法可以被覆盖，但数据成员不能被覆盖，这意味着数据成员不能实现运行时多态性。</p><p id="6eab" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><strong class="lg ja">举例:</strong></p><pre class="kp kq kr ks gt nl nm nn bn no np bi"><span id="3269" class="nq mp iq nm b be nr ns l nt nu">class Bike{<br/>int speedlimit=90;<br/>}<br/>Class bike1 extends Bike{<br/>int speedlimit=150;<br/>public static void main(String args[]){<br/>Bike obj=new bike1();<br/>System.out.println(obj.speedlimit);//90<br/>}</span></pre><p id="8857" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><strong class="lg ja">输出:</strong></p><pre class="kp kq kr ks gt nl nm nn bn no np bi"><span id="b5bf" class="nq mp iq nm b be nr ns l nt nu">90</span></pre><h1 id="8e8f" class="mo mp iq bd mq mr ms mt mu mv mw mx my kf mz kg na ki nb kj nc kl nd km ne nf bi translated">具有多级继承的 Java 运行时多态性</h1><p id="198c" class="pw-post-body-paragraph le lf iq lg b lh ng ka lj lk nh kd lm ln ni lp lq lr nj lt lu lv nk lx ly lz ij bi translated"><strong class="lg ja">举例:</strong></p><pre class="kp kq kr ks gt nl nm nn bn no np bi"><span id="5f97" class="nq mp iq nm b be nr ns l nt nu">class Animal{<br/>void eat(){System.out.println("eating");}<br/>}<br/>class Dog extends Animal{<br/>void eat(){System.out.println("eating fruits");}<br/>}<br/>class labrador extends Dog{<br/>void eat(){System.out.println("drinking milk");}<br/>public static void main(String args[]){<br/>Animal a1,a2,a3;<br/>a1=new Animal();<br/>a2=new Dog();<br/>a3=new labrador();<br/>a1.eat();<br/>a2.eat();<br/>a3.eat();<br/>}<br/>}</span></pre><p id="80e7" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><strong class="lg ja">输出:</strong></p><pre class="kp kq kr ks gt nl nm nn bn no np bi"><span id="390d" class="nq mp iq nm b be nr ns l nw nu">eating<br/>eating fruits<br/>drinking Milk</span></pre><p id="b50d" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">具有或不具有多态性的 Java 代码:</p><p id="c7a6" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><strong class="lg ja">无多态性</strong></p><pre class="kp kq kr ks gt nl nm nn bn no np bi"><span id="4fd0" class="nq mp iq nm b be nr ns l nt nu">class Rectangle{<br/>int length;<br/>int width;<br/>void insert(int l, int w){<br/>length=l;<br/>width=w;<br/>}<br/>void calculateArea(){System.out.println(length*width);}<br/>}<br/>class TestRectangle1{<br/>public static void main(String args[]){<br/>Rectangle r1=new Rectangle();<br/>Rectangle r2=new Rectangle();<br/>r1.insert(11,5);<br/>r2.insert(3,15);<br/>r1.calculateArea();<br/>r2.calculateArea();<br/>}<br/>}</span></pre><p id="4fd6" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><strong class="lg ja">输出:</strong></p><pre class="kp kq kr ks gt nl nm nn bn no np bi"><span id="eceb" class="nq mp iq nm b be nr ns l nt nu">55<br/>45</span></pre><p id="0741" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><strong class="lg ja">具有多态性</strong></p><pre class="kp kq kr ks gt nl nm nn bn no np bi"><span id="69aa" class="nq mp iq nm b be nr ns l nt nu">class Rectangle {<br/>// Overloaded Area() function to<br/>// calculate the area of the rectangle<br/>// It takes two double parameters<br/>void Area(double S, double T)<br/>{<br/>System.out.println("Area of the rectangle: "<br/>+ S * T);<br/>}<br/>// Overloaded Area() function to<br/>// calculate the area of the rectangle.<br/>// It takes two float parameters<br/>void Area(int S, int T)<br/>{<br/>System.out.println("Area of the rectangle: "<br/>+ S * T);<br/>}<br/>}<br/>class ABC{<br/>// Driver code<br/>public static void main(String[] args)<br/>{<br/>// Creating object of Rectangle class<br/>Rectangle obj = new Rectangle();<br/>// Calling function<br/>obj.Area(20, 10);<br/>obj.Area(10.5, 5.5);<br/>}<br/>}</span></pre><p id="4bee" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><strong class="lg ja">输出:</strong></p><pre class="kp kq kr ks gt nl nm nn bn no np bi"><span id="3b69" class="nq mp iq nm b be nr ns l nt nu">Area of the rectangle: 200<br/>Area of the rectangle: 57.75</span></pre><p id="8bcd" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">时间复杂度:O(1)</p><p id="b11c" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><strong class="lg ja">多态性的优势</strong></p><ul class=""><li id="d5c5" class="ma mb iq lg b lh li lk ll ln mc lr md lv me lz nv mg mh mi bi translated">它帮助程序员在编写、测试和实现之后重用代码和类。它们可以以多种方式重用。</li><li id="63d4" class="ma mb iq lg b lh mj lk mk ln ml lr mm lv mn lz nv mg mh mi bi translated">单个变量名可用于存储多种数据类型的变量(Float、double、Long、Int 等)。</li><li id="3137" class="ma mb iq lg b lh mj lk mk ln ml lr mm lv mn lz nv mg mh mi bi translated">多态性有助于减少不同功能之间的耦合。</li></ul><p id="3225" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><strong class="lg ja">多态性的缺点</strong></p><ul class=""><li id="dfda" class="ma mb iq lg b lh li lk ll ln mc lr md lv me lz nv mg mh mi bi translated">多态性的缺点之一是开发人员发现很难在代码中实现多态性。</li><li id="a2a4" class="ma mb iq lg b lh mj lk mk ln ml lr mm lv mn lz nv mg mh mi bi translated">运行时多态性会导致性能问题，因为机器需要决定调用哪个方法或变量，所以它基本上会降低性能，因为决策是在运行时做出的。</li><li id="4314" class="ma mb iq lg b lh mj lk mk ln ml lr mm lv mn lz nv mg mh mi bi translated">多态性降低了程序的可读性。人们需要识别程序的运行时行为来识别实际的执行时间。</li></ul><h2 id="f48c" class="nx mp iq bd mq ny nz dn mu oa ob dp my ln oc od na lr oe of nc lv og oh ne iw bi translated">结论</h2><p id="3ac3" class="pw-post-body-paragraph le lf iq lg b lh ng ka lj lk nh kd lm ln ni lp lq lr nj lt lu lv nk lx ly lz ij bi translated">最后，我想对阅读我文章的读者说声谢谢。我希望它能帮助你增加关于多态性的知识。感谢阅读！</p></div></div>    
</body>
</html>