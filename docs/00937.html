<html>
<head>
<title>Linked List, Doubly Linked List in GoLang</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">链表，GoLang 中的双向链表</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/linked-list-doubly-linked-list-in-golang-14bdd33f62e1?source=collection_archive---------6-----------------------#2020-06-20">https://blog.devgenius.io/linked-list-doubly-linked-list-in-golang-14bdd33f62e1?source=collection_archive---------6-----------------------#2020-06-20</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="0be1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">上一篇<a class="ae ki" href="https://medium.com/dev-genius/singly-linked-list-in-golang-bb90a96c9933" rel="noopener">文章</a>我写了关于在单链表中插入并显示其内容。今天我想扩展那篇文章(我也是闲坐着)。我们将尝试删除最后一个节点。</p><p id="5cf2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这可以通过<br/> 1)遍历到最后一个节点来完成。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/90a9e2d71997163ddc76a7686a56d6dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o2tB8OJTxJ6hAYB7zbNm2w.png"/></div></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk translated">横越</figcaption></figure><p id="372c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">2)删除节点。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kz"><img src="../Images/4c0f2d367c7b5522188080a0f60cee12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*twnYyy3uZmKknkA9UOMVGQ.png"/></div></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk translated">删除</figcaption></figure><p id="e787" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">3)将前一个节点的下一个指针重置为空。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi la"><img src="../Images/02366cca27fd35138c1173948176bbe1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/format:webp/1*ouml-jWR2Q5M-QyDJBfSmA.png"/></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk translated">更新的链接列表</figcaption></figure><p id="e273" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们看一下代码片段:</p><pre class="kk kl km kn gt lb lc ld le aw lf bi"><span id="7546" class="lg lh in lc b gy li lj l lk ll">func (n *Node) DeleteNode() {<br/> iter := n<br/> for (iter.next).next != nil {<br/> iter = iter.next<br/> }<br/> iter.next = nil<br/>}</span></pre><p id="fe22" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">像往常一样，<code class="fe lm ln lo lc b">DeleteNode</code>函数前面有一个类型为<code class="fe lm ln lo lc b">*Node</code>的接收器，因此它只能通过类型为<code class="fe lm ln lo lc b">*Node</code>的变量来调用。这也让我们更好地理解了<code class="fe lm ln lo lc b">DeleteNode</code>的目的和关联。第一行设置了<code class="fe lm ln lo lc b">iter</code>变量。在<code class="fe lm ln lo lc b">for</code>循环中，它遍历所有节点以找到最后一个节点。然后将指向最后一个节点的下一个指针设置为<code class="fe lm ln lo lc b">nil</code>。</p><p id="05cf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">不要担心释放内存，因为 golang 的垃圾收集器会处理它。这种方法的效率是 O(n-1)。其中 n 是链表的大小。我们可以通过添加尾指针来尝试将删除节点算法优化到 O(1)。但是每次我们删除一个节点时，尾指针都需要调整以指向最后一个节点。这将是 O(n-1)。为了解决这个问题，我们使用了双向链表。</p><p id="cc01" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">双向链表是一种数据结构，其中每个节点既可以指向上一个节点，也可以指向下一个节点。所以它有三个元素:</p><pre class="kk kl km kn gt lb lc ld le aw lf bi"><span id="9755" class="lg lh in lc b gy li lj l lk ll">type Node struct {<br/> Prev *Node<br/> Data int<br/> Next *Node<br/>}</span></pre><p id="28ee" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">它大致如下图所示:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi lp"><img src="../Images/44d9c62f921f955f681e044cc7b13dd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1288/format:webp/1*fMUFdTvGwzB1eFQ-V7wqHw.png"/></div></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk translated">我漂亮的双向链表</figcaption></figure><p id="85db" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">由于存在前一个指针，我们将稍微修改我们的插入逻辑。<br/> 1)创建新节点<br/> 2)前一个指针将指向前一个节点。<br/> 3)下一个指针将指向空</p><p id="b0b3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">以下是代码片段:</p><pre class="kk kl km kn gt lb lc ld le aw lf bi"><span id="41d2" class="lg lh in lc b gy li lj l lk ll">var tail *Node</span><span id="259f" class="lg lh in lc b gy lq lj l lk ll">func (n *Node) AddNode(data int) {<br/> if tail == nil {<br/> tail = n<br/> }<br/> n = tail<br/> newNode := Node{n, data, nil}<br/> n.Next = &amp;newNode<br/> tail = &amp;newNode<br/>}</span></pre><p id="fa46" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们引入了<code class="fe lm ln lo lc b">tail</code>指针作为全局变量。它总是指向最后一个节点。我们正在初始化<code class="fe lm ln lo lc b">newNode := Node{n,data,nil}</code>。这里第一个字段值是前一个指针。每个新节点都应该指向前一个节点。下一个节点指针应该为空(或者在这种情况下为<code class="fe lm ln lo lc b">nil</code>)。正如您在这里看到的，通过引入<code class="fe lm ln lo lc b">tail</code>指针，我们已经将<code class="fe lm ln lo lc b">AddNode</code>的操作效率显著提高到 O(1)。我们不需要遍历整个数组来找到最后一个位置。</p><p id="cbb5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们看看如何以 O(1)的效率解决最后一个节点删除问题。以下是代码片段:</p><pre class="kk kl km kn gt lb lc ld le aw lf bi"><span id="3c84" class="lg lh in lc b gy li lj l lk ll">func (n *Node) DeleteLast() {<br/> tail = tail.Previous<br/> (tail.Next).Previous = nil<br/> tail.Next = nil<br/>}</span></pre><p id="ec79" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe lm ln lo lc b">tail</code>指针更新指向前一个节点。然后更新最后一个节点的<code class="fe lm ln lo lc b">Previous</code>和指向<code class="fe lm ln lo lc b">nil</code>的<code class="fe lm ln lo lc b">Next</code>指针。通过这种方式，我们不仅删除了最后一个节点，还保持了<code class="fe lm ln lo lc b">tail</code>指针的更新，并且都是 O(1)效率。<br/>完整源代码可点击此处<a class="ae ki" href="https://gist.github.com/sandeep-sarkar/082abfef7340f15c4ae030e6aa7ecb01" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/sandeep-sarkar/082 abfef 7340 f 15 C4 AE 030 e 6 aa 7 ECB 01</a>。</p></div></div>    
</body>
</html>