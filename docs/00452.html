<html>
<head>
<title>API calls between docker instances</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">docker 实例之间的 API 调用</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/api-calls-between-docker-instances-24124f5bf010?source=collection_archive---------2-----------------------#2020-06-08">https://blog.devgenius.io/api-calls-between-docker-instances-24124f5bf010?source=collection_archive---------2-----------------------#2020-06-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/aa2e117818d2aa10af365a9e6b47c796.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9TJjrOwiMEWLEnHHNxCt9A.png"/></div></div></figure><div class=""/><p id="d5d3" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在 docker 中运行应用程序可能是个好主意。但是，正确配置它需要一些时间，并且您可能会遇到某些问题。当我第一次在本地使用 docker 时，我无法让多个实例相互通信。所以我决定写一篇关于它的小文章。</p><p id="61d8" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对于这个例子，我们将设置两个项目。一个 API 和一个对 API 进行 curl 调用的客户端。</p><h2 id="70f6" class="kt ku iy bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">先决条件</h2><ul class=""><li id="c5d3" class="lm ln iy jx b jy lo kc lp kg lq kk lr ko ls ks lt lu lv lw bi translated">安装 docker</li><li id="ce85" class="lm ln iy jx b jy lx kc ly kg lz kk ma ko mb ks lt lu lv lw bi translated">安装 docker-compose—<a class="ae mc" href="https://docs.docker.com/compose/install/#install-compose" rel="noopener ugc nofollow" target="_blank">https://docs.docker.com/compose/install/#install-compose</a></li></ul><h2 id="58d3" class="kt ku iy bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">创建 API</h2><ul class=""><li id="4fd2" class="lm ln iy jx b jy lo kc lp kg lq kk lr ko ls ks lt lu lv lw bi translated">在项目的根目录下创建一个<code class="fe md me mf mg b">Dockerfile</code>，对于这个例子，我们将使用 Node，但是当然，你可以使用你喜欢的任何东西。</li><li id="4801" class="lm ln iy jx b jy lx kc ly kg lz kk ma ko mb ks lt lu lv lw bi translated">打开文件并添加以下内容:</li></ul><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="fa2f" class="kt ku iy mg b gy mp mq l mr ms">FROM node:12-alpine</span><span id="3795" class="kt ku iy mg b gy mt mq l mr ms">WORKDIR /var/www</span><span id="5f0b" class="kt ku iy mg b gy mt mq l mr ms">CMD node src/index.js</span></pre><p id="500b" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这将从 docker hub 下载<code class="fe md me mf mg b">node:12-alpine</code>映像，将当前文件夹设置为<code class="fe md me mf mg b">/var/www</code>，并运行 Node。</p><ul class=""><li id="675a" class="lm ln iy jx b jy jz kc kd kg mu kk mv ko mw ks lt lu lv lw bi translated">现在在项目的根中创建一个<code class="fe md me mf mg b">docker-compose.yml</code></li></ul><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="5258" class="kt ku iy mg b gy mp mq l mr ms">version: '3'</span><span id="5b0d" class="kt ku iy mg b gy mt mq l mr ms">services:<br/>    api:<br/>        build:<br/>            context: .<br/>        ports:<br/>            - 3000:3000<br/>        volumes:<br/>            - .:/var/www<br/>        networks:<br/>            default:<br/>                aliases:<br/>                    - my-api.dev</span></pre><p id="eca9" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在<code class="fe md me mf mg b">docker-compose.yml</code>文件中，我们配置了 API 服务。</p><p id="0979" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">重要的部分是<code class="fe md me mf mg b">networks.default.aliases</code>。这个属性将确保我们的 API 在 docker 网络中被称为<code class="fe md me mf mg b">my-api.dev</code>。我们将两个服务都连接到这个网络，并使用别名进行通信。</p><p id="d56d" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您可以在文档中找到所有属性的信息:<a class="ae mc" href="https://docs.docker.com/compose/compose-file/" rel="noopener ugc nofollow" target="_blank">https://docs.docker.com/compose/compose-file/</a></p><ul class=""><li id="dd9e" class="lm ln iy jx b jy jz kc kd kg mu kk mv ko mw ks lt lu lv lw bi translated">现在，在您的终端中运行以下命令来设置一个项目</li></ul><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="84e0" class="kt ku iy mg b gy mp mq l mr ms">docker-compose run --rm api npm init</span></pre><ul class=""><li id="bda4" class="lm ln iy jx b jy jz kc kd kg mu kk mv ko mw ks lt lu lv lw bi translated">你会得到一些关于项目名称，版本等的问题。回答完所有问题后，您应该会在项目文件夹中看到 package.json。</li><li id="7ba6" class="lm ln iy jx b jy lx kc ly kg lz kk ma ko mb ks lt lu lv lw bi translated">现在安装 express</li></ul><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="7deb" class="kt ku iy mg b gy mp mq l mr ms">docker-compose run --rm api npm i express</span></pre><ul class=""><li id="5de0" class="lm ln iy jx b jy jz kc kd kg mu kk mv ko mw ks lt lu lv lw bi translated">创建一个<code class="fe md me mf mg b">src</code>文件夹，并将以下内容添加到<code class="fe md me mf mg b">index.js</code></li><li id="0a1d" class="lm ln iy jx b jy lx kc ly kg lz kk ma ko mb ks lt lu lv lw bi translated">开始 API 吧！</li></ul><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="3916" class="kt ku iy mg b gy mp mq l mr ms">docker-compose -p my-project up api</span></pre><p id="0208" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">p(项目名称)标志将确保这个项目使用<code class="fe md me mf mg b">my-project_default</code>网络。我们将用这个标志启动这两个服务，以确保它们在同一个 docker 网络上。如果我们不传递这个标志，docker-compose 将使用默认的文件夹名。</p><ul class=""><li id="9457" class="lm ln iy jx b jy jz kc kd kg mu kk mv ko mw ks lt lu lv lw bi translated">当你去<code class="fe md me mf mg b"><a class="ae mc" href="http://127.0.0.1:3000/hello-docker" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:3000/hello-docker</a></code>你应该看到`你好码头工人！`</li></ul><h2 id="fc73" class="kt ku iy bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">创建第二个项目</h2><ul class=""><li id="e45b" class="lm ln iy jx b jy lo kc lp kg lq kk lr ko ls ks lt lu lv lw bi translated">打开一个新的终端窗口，因为我们希望我们的 API 继续运行。</li><li id="0b96" class="lm ln iy jx b jy lx kc ly kg lz kk ma ko mb ks lt lu lv lw bi translated">为第二个项目创建一个新文件夹，并创建一个<code class="fe md me mf mg b">Dockerfile</code></li></ul><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="89f9" class="kt ku iy mg b gy mp mq l mr ms"># We don't actually need the node image for this, it’s just for this example.<br/>FROM node:12-alpine</span><span id="5a79" class="kt ku iy mg b gy mt mq l mr ms">RUN apk add curl</span><span id="34a3" class="kt ku iy mg b gy mt mq l mr ms">CMD curl -s my-api.dev:3000/hello-docker</span></pre><p id="8ba5" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们将安装 curl 并调用我们在 API 项目中定义的别名。</p><ul class=""><li id="16bd" class="lm ln iy jx b jy jz kc kd kg mu kk mv ko mw ks lt lu lv lw bi translated">在根文件夹中创建一个<code class="fe md me mf mg b">docker-compose.yml</code>文件</li></ul><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="cee7" class="kt ku iy mg b gy mp mq l mr ms">version: '3'</span><span id="ea6f" class="kt ku iy mg b gy mt mq l mr ms">services:<br/>    client: # It’s important that the name is different than the one we used in the API project<br/>        build:<br/>            context: .</span></pre><ul class=""><li id="8d5c" class="lm ln iy jx b jy jz kc kd kg mu kk mv ko mw ks lt lu lv lw bi translated">让我们运行它！</li></ul><pre class="mh mi mj mk gt ml mg mm mn aw mo bi"><span id="27a9" class="kt ku iy mg b gy mp mq l mr ms">docker-compose -p my-project up client</span></pre><p id="aee4" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们在这里也使用-p 标志来确保这个项目与我们的 API 连接到同一个 docker 网络。</p><p id="2a54" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">就这样，如果一切按预期运行，您现在应该会在终端中看到<code class="fe md me mf mg b">{“message”:”Hello Docker!”}</code>。</p><h2 id="1359" class="kt ku iy bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">摘要</h2><ul class=""><li id="ecae" class="lm ln iy jx b jy lo kc lp kg lq kk lr ko ls ks lt lu lv lw bi translated"><code class="fe md me mf mg b">networks.default.aliases</code>属性可以用来给容器一个别名</li><li id="9e83" class="lm ln iy jx b jy lx kc ly kg lz kk ma ko mb ks lt lu lv lw bi translated">启动容器时使用同名的<code class="fe md me mf mg b">-p</code>标志，以确保容器使用相同的 docker 网络。</li><li id="9fa2" class="lm ln iy jx b jy lx kc ly kg lz kk ma ko mb ks lt lu lv lw bi translated">使用另一个服务的别名和端口调用 API(<code class="fe md me mf mg b">my-api.dev:3000</code>)</li></ul><p id="5283" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">请注意，这是一个非常基本的设置，我创建它只是为了展示如何使用<code class="fe md me mf mg b">networks.default.aliases</code>。您可以将这种设置用于本地开发，但绝对不能用于生产。</p></div></div>    
</body>
</html>