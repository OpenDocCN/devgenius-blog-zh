<html>
<head>
<title>Add Infinite Scrolling to a React App with the Intersection Observer API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用交叉点观察器API为React应用程序添加无限滚动</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/add-infinite-scrolling-to-a-react-app-with-the-intersection-observer-api-d3a3381f9a1c?source=collection_archive---------1-----------------------#2021-11-19">https://blog.devgenius.io/add-infinite-scrolling-to-a-react-app-with-the-intersection-observer-api-d3a3381f9a1c?source=collection_archive---------1-----------------------#2021-11-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/c5bbc3532ff894c2432083cc38ee9fdf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*r9Vh_3gLQJflZxAw"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@freetousesoundscom?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">自由使用声音</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上</figcaption></figure><p id="9030" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">无限滚动是我们必须经常添加到React应用程序中的东西。</p><p id="7175" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将了解如何使用交叉点观察器API为React应用程序添加无限滚动。</p><h1 id="44a8" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用交叉点观察器API添加无限滚动</h1><p id="8e69" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">交叉点观察器API允许我们在React应用程序中轻松添加无限滚动，因为我们可以使用它来检测列表底部的元素。</p><p id="f34c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们为页面底部的元素分配一个ref，然后我们可以使用交叉点观察器API来检测它何时越过屏幕边缘并显示在页面上。</p><p id="1c3b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为此，我们写道:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="4cb1" class="mn lc iq mj b gy mo mp l mq mr">import { useEffect, useRef, useState } from "react";<br/>export default function App() {<br/>  const lastItemRef = useRef();<br/>  const observer = useRef();<br/>  const [arr, setArr] = useState(<br/>    Array(30)<br/>      .fill()<br/>      .map((_, i) =&gt; i)<br/>  );<br/>  const [page, setPage] = useState(1);</span><span id="dcca" class="mn lc iq mj b gy ms mp l mq mr">useEffect(() =&gt; {<br/>    const options = {<br/>      root: document,<br/>      rootMargin: "20px",<br/>      threshold: 1<br/>    };<br/>    const callback = (entries) =&gt; {<br/>      if (entries[0].isIntersecting) {<br/>        const newPage = page + 1;<br/>        setArr((arr) =&gt; [<br/>          ...arr,<br/>          ...Array(30)<br/>            .fill()<br/>            .map((_, i) =&gt; i + 30 * (newPage - 1))<br/>        ]);<br/>        setPage(newPage);<br/>      }<br/>    };<br/>    observer.current = new IntersectionObserver(callback, options);<br/>    if (lastItemRef.current) {<br/>      observer.current.observe(lastItemRef.current);<br/>    }<br/>    return () =&gt; {<br/>      observer.current.disconnect();<br/>    };<br/>  });<br/>  return (<br/>    &lt;div className="App"&gt;<br/>      {arr.map((a, i) =&gt; {<br/>        if (i === arr.length - 1) {<br/>          return (<br/>            &lt;p key={a} ref={lastItemRef}&gt;<br/>              {a}<br/>            &lt;/p&gt;<br/>          );<br/>        }<br/>        return &lt;p key={a}&gt;{a}&lt;/p&gt;;<br/>      })}<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><p id="9899" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有<code class="fe mt mu mv mj b">lastItemRef</code>，它是我们分配给页面底部元素的ref。</p><p id="45cc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mj b">observer</code>是我们用来存储观察者的ref。</p><p id="1daf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mj b">arr</code>就是我们渲染到页面上的东西。</p><p id="e18b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有<code class="fe mt mu mv mj b">page</code>元素来告诉我们现在在哪一页。</p><p id="e122" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们有一个带有回调的<code class="fe mt mu mv mj b">useEffect</code>钩子，回调有一个<code class="fe mt mu mv mj b">options</code>对象来存储交叉点观察器的选项。</p><p id="e4ad" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mj b">root</code>是滚动容器，也就是<code class="fe mt mu mv mj b">document</code>对象。这就是<code class="fe mt mu mv mj b">html</code>元素。</p><p id="5f9e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mj b">rootMargin</code>我们观察的元素离屏幕边缘有多近，才能被认为与屏幕边缘相交。</p><p id="d10a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mj b">threshold</code>表示对于要运行的回调函数top，观察到的元素在根选项指定的元素中可见的程度。</p><p id="4755" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们用<code class="fe mt mu mv mj b">callback</code>来检查<code class="fe mt mu mv mj b">isIntersecting</code>是否为<code class="fe mt mu mv mj b">true</code>以将其视为交集。</p><p id="255c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们调用<code class="fe mt mu mv mj b">setArr</code>向<code class="fe mt mu mv mj b">arr</code>添加更多的项目，如果是<code class="fe mt mu mv mj b">true</code>的话。</p><p id="6c19" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们用我们正在观察的元素调用<code class="fe mt mu mv mj b">observe</code>，它存储在<code class="fe mt mu mv mj b">lastItemRef</code> current中。</p><p id="92a2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当组件卸载时，我们返回一个调用<code class="fe mt mu mv mj b">disconnect</code>的回调来清除交叉点观察器。</p><p id="cae6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们将<code class="fe mt mu mv mj b">arr</code>项渲染到<code class="fe mt mu mv mj b">p</code>元素中，并将<code class="fe mt mu mv mj b">lastItemRef</code>赋给最后渲染的元素，即屏幕底部的元素。</p><h1 id="36d9" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="518a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用交叉点观察器API轻松地将无限滚动添加到React应用程序中。</p></div></div>    
</body>
</html>