<html>
<head>
<title>How to build the SSR web application and mobile apps from the same code base</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何从相同的代码库构建 SSR web 应用程序和移动应用程序</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-to-build-the-ssr-web-application-and-mobile-apps-from-the-same-code-base-e6480640e8cf?source=collection_archive---------12-----------------------#2022-09-25">https://blog.devgenius.io/how-to-build-the-ssr-web-application-and-mobile-apps-from-the-same-code-base-e6480640e8cf?source=collection_archive---------12-----------------------#2022-09-25</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/0d67844b233fdc9235c3dc6455aacd12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*_SdvhOHsw1Pm4q0M.png"/></div></div></figure><div class=""/><p id="5cfd" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">服务器端呈现提高了初始页面加载速度。浏览器从服务器接收预先呈现的 HTML，因此构建页面花费的时间更少。</p><p id="b37c" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">此外，SSR 网站与 SEO 配合得更好。搜索引擎爬虫抓取网站的 HTML 内容，而不执行 JS 代码。没有 SSR，搜索引擎将不会索引页面内容，也不会找到内部链接。</p><p id="dae8" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">NuxtJS 有一个<a class="ae kt" href="https://nuxtjs.org/docs/concepts/server-side-rendering/" rel="noopener ugc nofollow" target="_blank">服务器端渲染</a>特性:</p><blockquote class="ku kv kw"><p id="0a0a" class="jv jw kx jx b jy jz ka kb kc kd ke kf ky kh ki kj kz kl km kn la kp kq kr ks ig bi translated"><em class="iy">服务器端呈现(SSR)是应用程序通过在服务器上显示网页而不是在浏览器中呈现网页的能力。服务器端将完全呈现的页面发送给客户端。</em></p></blockquote><p id="850c" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是，当您为移动应用程序构建静态站点时，您不能使用 SSR。在这里，我将展示如何使用 CapacitorJS 和 NuxtJS 从相同的代码库创建一个 SSR web 和跨平台移动应用程序。</p><h1 id="0e85" class="lb lc iy bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">构建应用程序</h1><p id="7c3c" class="pw-post-body-paragraph jv jw iy jx b jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks ig bi translated">例如，我们将构建一个简单的应用程序来显示基辅的当地时间。</p><p id="7abf" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了测试 SSR，我们需要从 API 服务器获取数据。我们将使用<a class="ae kt" href="https://v3.nuxtjs.org/getting-started/data-fetching/#usefetch" rel="noopener ugc nofollow" target="_blank"> useFetch </a>方法从<a class="ae kt" href="http://worldtimeapi.org/" rel="noopener ugc nofollow" target="_blank">worldtimeapi.org</a>API 接收数据。</p><p id="6b88" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们从<a class="ae kt" href="https://dev.to/daiquiri_team/how-to-create-android-and-ios-apps-from-the-nuxtjs-application-using-capacitorjs-134h" rel="noopener ugc nofollow" target="_blank">之前指南</a>中的应用开始。</p><p id="0a54" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">删除<code class="fe me mf mg mh b">app.vue</code>文件，添加<code class="fe me mf mg mh b">pages/index.vue</code>，内容如下:</p><figure class="mi mj mk ml gt ip"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="c65c" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里我们有:</p><ul class=""><li id="66f3" class="mo mp iy jx b jy jz kc kd kg mq kk mr ko ms ks mt mu mv mw bi translated">在<code class="fe me mf mg mh b">const timeData</code>变量中检索当前时间。</li><li id="0289" class="mo mp iy jx b jy mx kc my kg mz kk na ko nb ks mt mu mv mw bi translated">🕥在页面上显示时间。</li><li id="0151" class="mo mp iy jx b jy mx kc my kg mz kk na ko nb ks mt mu mv mw bi translated">🔄刷新按钮。</li></ul><p id="e470" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">运行<code class="fe me mf mg mh b">yarn dev</code>并检查<a class="ae kt" href="http://localhost:3000/" rel="noopener ugc nofollow" target="_blank"> http://localhost:3000/ </a>我们有什么:</p><figure class="mi mj mk ml gt ip gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/ca2f28413608b7ca218e38e2bcc6320d.png" data-original-src="https://miro.medium.com/v2/resize:fit:802/format:webp/0*G3XYx0iwU_lVTdnz.png"/></div></figure><p id="8156" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们来看看页面源代码:</p><figure class="mi mj mk ml gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi nd"><img src="../Images/3885842d8133781f23fb13cb04876db2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*7SZRKQBwqJBFSane.png"/></div></div></figure><p id="eab1" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在 NuxtJS 中，默认情况下启用服务器端呈现。但是如果我们为移动构建创建一个静态站点，我们会得到什么呢？运行<code class="fe me mf mg mh b">yarn generate &amp;&amp; yarn preview</code>并重新检查<a class="ae kt" href="http://localhost:3000/" rel="noopener ugc nofollow" target="_blank"> http://localhost:3000/ </a>。</p><p id="1e8d" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你尝试刷新页面，你会发现时间并没有改变。NuxtJS 在静态站点生成期间从服务器检索时间，并将其保存在预先呈现的 HTML 页面中。</p><p id="d305" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们给<code class="fe me mf mg mh b">nuxt.config.ts</code>加上<code class="fe me mf mg mh b">ssr: false</code></p><figure class="mi mj mk ml gt ip"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="6979" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">并且用<code class="fe me mf mg mh b">yarn generate &amp;&amp; yarn preview</code>重建站点。</p><p id="b729" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在 NuxtJS 在客户端运行 HTTP 请求。页面源中没有日期时间，每次刷新页面时日期时间都会发生变化。</p><figure class="mi mj mk ml gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi nd"><img src="../Images/b1b5b057158e459d1920dab1c3450510.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*h19eCdge_0atzxgK.png"/></div></div></figure><p id="abd0" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，我们必须构建一个带有 SSR 的 web 应用程序和一个纯客户端模式的移动应用程序。让我们使用一个环境标志<code class="fe me mf mg mh b">MOBILE_BUILD</code>:我们将用<code class="fe me mf mg mh b">MOBILE_BUILD=0</code>构建一个 web 应用程序，用<code class="fe me mf mg mh b">MOBILE_BUILD=1</code>构建一个移动应用程序。</p><p id="ea53" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您可以使用一个<code class="fe me mf mg mh b">.env</code>文件来存储环境变量，我将使用<code class="fe me mf mg mh b">export MOBILE_BUILD=1</code>。</p><p id="8451" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">变更<code class="fe me mf mg mh b">nuxt.config.ts</code>:</p><figure class="mi mj mk ml gt ip"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="c9f7" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">运行<code class="fe me mf mg mh b">yarn generate &amp;&amp; yarn preview</code>并验证应用程序是否在仅客户端模式下工作。</p><p id="f4d8" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后，让我们构建并检查 Android 应用程序:</p><pre class="mi mj mk ml gt ne mh nf ng aw nh bi"><span id="9b4f" class="ni lc iy mh b gy nj nk l nl nm">yarn cap sync<br/>yarn cap open android</span></pre><p id="0017" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在模拟器上运行应用程序，并检查刷新按钮是否有效。</p><figure class="mi mj mk ml gt ip gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/46a736adabd93494e446d9591ebe8d4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:492/format:webp/0*vXSUf4-uKCbhQB6k.png"/></div></figure><p id="c0da" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">🎉祝贺你，它工作了(至少在我的笔记本电脑上)🙂).</p></div></div>    
</body>
</html>