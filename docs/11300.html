<html>
<head>
<title>Utilizing the Heap in Assembly</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在程序集中使用堆</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/utilizing-the-heap-in-assembly-1f10011cdc1b?source=collection_archive---------7-----------------------#2022-12-31">https://blog.devgenius.io/utilizing-the-heap-in-assembly-1f10011cdc1b?source=collection_archive---------7-----------------------#2022-12-31</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="6daa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如何在代码运行后释放的结构上进行单元测试？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><a href="https://github.com/daminals/Unit_Testing_with_MUnit"><div class="gh gi ki"><img src="../Images/a9768b1a2dd5d5a88ecef190b3e8f52f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dHNIT3WNJSPfF_LVoOXDTg.png"/></div></a><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">在 GitHub 上查看这个项目！</figcaption></figure><blockquote class="ku kv kw"><p id="365c" class="jk jl kx jm b jn jo jp jq jr js jt ju ky jw jx jy kz ka kb kc la ke kf kg kh ig bi translated">在本文中，我将在 MIPS 中向堆引入动态内存分配，并扩展在我以前的文章中定义的测试用例模型<a class="ae lb" href="https://medium.com/@danielkoganx/list/munit-and-mips-testing-77aed8ce48dc" rel="noopener">来测试我的代码。如果你不熟悉 MIPS 编程语言，你可以看看这篇文章</a></p></blockquote><h1 id="bc41" class="lc ld in bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">堆简介</h1><p id="4e59" class="pw-post-body-paragraph jk jl in jm b jn ma jp jq jr mb jt ju jv mc jx jy jz md kb kc kd me kf kg kh ig bi translated">在编程中，堆是内存的一部分，可以存储动态分配的变量。在许多不同的编程语言中，堆是一种重要的数据结构，用于管理和分配计算机系统中的内存。</p><p id="9f26" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">堆支持在运行时而不是编译时分配内存，这是它的主要优点之一。因此，软件不再需要预先确定它需要多少内存，而是可以根据需要请求更多的内存。这对于内存需求波动或不可预测的程序尤其有用。</p><p id="1297" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">此外，堆是至关重要的，因为它们使内存分配和释放更有效。当不再需要内存时，程序可以将内存释放回堆，使其可供其他软件组件使用。这有助于防止内存泄漏，随着时间的推移，内存泄漏会导致程序消耗越来越多的内存，最终导致性能问题甚至崩溃。</p><p id="3b55" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">除了内存管理之外，在数据排序和搜索算法中也经常使用堆。它们是程序员工具箱中的一个关键工具，知道如何正确地利用它们对于开发有效和高效的代码是至关重要的。</p><h1 id="9440" class="lc ld in bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">编码示例</h1><p id="f959" class="pw-post-body-paragraph jk jl in jm b jn ma jp jq jr mb jt ju jv mc jx jy jz md kb kc kd me kf kg kh ig bi translated">在本文中，我将使用两个编码示例，一个简单的函数演示了堆如何工作以及我们如何对它们进行单元测试，然后一个复杂的示例应用了我在本文和前两篇文章中演示的概念。</p><h2 id="1fc8" class="mf ld in bd le mg mh dn li mi mj dp lm jv mk ml lq jz mm mn lu kd mo mp ly mq bi translated">保存到缓冲区</h2><p id="270c" class="pw-post-body-paragraph jk jl in jm b jn ma jp jq jr mb jt ju jv mc jx jy jz md kb kc kd me kf kg kh ig bi translated">第一个例子是一个“save_to_buffer”函数，它将在堆中分配空间，将一个值保存到堆中，然后将堆地址存储在提供的缓冲区中。</p><p id="a757" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我还将介绍一个我将在这个函数中使用的宏。</p><pre class="kj kk kl km gt mr ms mt bn mu mv bi"><span id="1a80" class="mw ld in ms b be mx my l mz na">.macro allocateHeapSpace(%a)<br/>  # ALLOCATE HEAP SPACE<br/>  addi $sp, $sp, -4 <br/>  sw $a0, 0($sp)<br/>  li $v0, 9<br/>  li $a0, %a <br/>  syscall<br/>  lw $a0, 0($sp)<br/>  addi $sp, $sp, 4<br/>.end_macro</span></pre><p id="bd56" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">MIPS 中的宏类似于高级编程语言中的函数。对于 MIPS 中的函数，我们传统上必须在跳转和链接到代码中的另一个标签之前将$ra 存储在堆栈中，这可能会引入许多错误和不必要的复杂性。宏允许我们编写代码，这些代码可以在编译时简单地复制并粘贴到我们的函数中。我们也将在编译时用适当的寄存器替换<code class="fe nb nc nd ms b">%a</code>。</p><p id="e023" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个宏将允许我们在堆中分配空间，我们将用它来保存我们的值。</p><p id="75bf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">第一个例子很简单，下面是代码:</p><pre class="kj kk kl km gt mr ms mt bn mu mv bi"><span id="90dd" class="mw ld in ms b be mx my l mz na">.globl save_to_buffer<br/>save_to_buffer:<br/>  # a0 = buffer, a1 = value, a2 = where_to_store_in_buffer<br/>  allocateHeapSpace(4) # saves address to v0<br/>  sw $a1, 0($v0)       # save value to heap<br/>  sll  $a2, $a2, 2     # Multiply by 4<br/>  add $a0,$a0,$a2      # find correct locale in buffer to store<br/>  sw $v0, 0($a0)       # save heap address to buffer<br/>  jr $ra</span></pre><p id="134e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我现在将展示我们的单元测试文件，以及一些预定义的测试。</p><pre class="kj kk kl km gt mr ms mt bn mu mv bi"><span id="40b6" class="mw ld in ms b be mx my l mz na">import org.junit.*;<br/>import org.junit.rules.Timeout;<br/><br/>import java.util.*;<br/>import java.io.*;<br/>import java.util.concurrent.TimeUnit;<br/><br/>import static edu.gvsu.mipsunit.munit.MUnit.Register.*;<br/>import static edu.gvsu.mipsunit.munit.MUnit.*;<br/>import static edu.gvsu.mipsunit.munit.MARSSimulator.*;<br/><br/>import org.junit.rules.Timeout;<br/>import java.util.concurrent.TimeUnit;<br/><br/>public class buffertest {<br/><br/>  int sp = 0;<br/>  int s0 = 0;<br/>  int s1 = 0;<br/>  int s2 = 0;<br/>  int s3 = 0;<br/>  int s4 = 0;<br/>  int s5 = 0;<br/>  int s6 = 0;<br/>  int s7 = 0;<br/>  int gp = 0;<br/><br/><br/>  @Before<br/>  public void preTest() {<br/>    s0 = get(s0);<br/>    s1 = get(s1);<br/>    s2 = get(s2);<br/>    s3 = get(s3);<br/>    s4 = get(s4);<br/>    s5 = get(s5);<br/>    s6 = get(s6);<br/>    s7 = get(s7);<br/>    sp = get(sp);<br/>    gp = get(gp);<br/>  }<br/><br/>  @After<br/>  public void postTest() {<br/>    Assert.assertEquals("Register convention violated $s0", s0, get(s0));<br/>    Assert.assertEquals("Register convention violated $s1", s1, get(s1));<br/>    Assert.assertEquals("Register convention violated $s2", s2, get(s2));<br/>    Assert.assertEquals("Register convention violated $s3", s3, get(s3));<br/>    Assert.assertEquals("Register convention violated $s4", s4, get(s4));<br/>    Assert.assertEquals("Register convention violated $s5", s5, get(s5));<br/>    Assert.assertEquals("Register convention violated $s6", s6, get(s6));<br/>    Assert.assertEquals("Register convention violated $s7", s7, get(s7));<br/>    Assert.assertEquals("Register convention violated $sp", sp, get(sp));<br/>    Assert.assertEquals("Register convention violated $gp", gp, get(gp));<br/>  }<br/><br/>  @Rule<br/>  public Timeout timeout = new Timeout(30000, TimeUnit.MILLISECONDS);<br/><br/><br/>  @Test<br/>  public void save_12() {<br/>    Label output_buffer = wordData(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0); <br/>    run("save_to_buffer", output_buffer, 12,0);<br/>    Assert.assertEquals(12, getWord(getWord(output_buffer.address())));<br/>  }<br/><br/><br/>  @Test<br/>  public void save_47() {<br/>    Label output_buffer = wordData(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0); <br/>    run("save_to_buffer", output_buffer, 47, 0);<br/>    Assert.assertEquals(47, getWord(getWord(output_buffer.address())));<br/>  }<br/><br/>  @Test<br/>  public void save_ascii() {<br/>    Label ascii = asciiData(true, "I love MIPS!");<br/>    Label output_buffer = wordData(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0); <br/>    run("save_to_buffer", output_buffer, ascii,0);<br/>    Assert.assertEquals("I love MIPS!", getString(getWord(getWord(output_buffer.address()))));<br/>  }<br/><br/>  @Test<br/>  public void save_12_and_47() {<br/>    Label output_buffer = wordData(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0); <br/>    run("save_to_buffer", output_buffer, 12,0);<br/>    Assert.assertEquals(12, getWord(getWord(output_buffer.address())));<br/>    run("save_to_buffer", output_buffer, 47,1);<br/>    Assert.assertEquals(47, getWord(getWord(output_buffer.address()+4)));<br/>  }<br/>}</span></pre><p id="befe" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">运行之后，我们的测试用例似乎表明我们的代码运行正确。然而，让我们添加一种方法来查看我们的缓冲区到我们的<code class="fe nb nc nd ms b">save_12_and_47</code>函数中的内容:</p><pre class="kj kk kl km gt mr ms mt bn mu mv bi"><span id="baed" class="mw ld in ms b be mx my l mz na">  @Test<br/>  public void save_12_and_47() {<br/>    Label output_buffer = wordData(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0); <br/>    run("save_to_buffer", output_buffer, 12,0);<br/>    Assert.assertEquals(12, getWord(getWord(output_buffer.address())));<br/>    for (int i=0; i&lt;2; i++) System.out.print(getWord(output_buffer.address()+i*4) + " ");<br/>    System.out.println();<br/>    run("save_to_buffer", output_buffer, 47,1);<br/>    Assert.assertEquals(47, getWord(getWord(output_buffer.address()+4)));<br/>    for (int i=0; i&lt;2; i++) System.out.print(getWord(output_buffer.address()+i*4) + " ");<br/>    System.out.println();<br/>  }</span></pre><p id="74f4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">并观察输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi ne"><img src="../Images/5386b620fffd76321155ca6205b0f7c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MZ8gOgzeHOpIInV-WRYj5g.png"/></div></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">缓冲区未更新，堆地址相同</figcaption></figure><p id="aa47" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如您所见，我们的缓冲区没有更新，我们的堆地址也完全相同。理论上，应该在堆中分配新的空间(<em class="kx">地址 268697604 </em>)，但是，似乎两个值使用了同一个空间。</p><p id="6dbe" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">嗯，在单元测试 MIPS 中，堆在每个单独的函数之后被释放。这意味着每次为每个单独的功能分配相同的空间。这就引出了一个问题:我们如何测试利用堆的 MIPS 函数？</p><p id="01e8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">做这件事的最佳方式实际上是在 mips 中将测试用例写成一个函数，然后在 MUnit 中测试这个函数。我举个例子吧！</p><pre class="kj kk kl km gt mr ms mt bn mu mv bi"><span id="db37" class="mw ld in ms b be mx my l mz na"># ...continued from save_to_buffer...<br/><br/>.globl save_12_and_47_test<br/>save_12_and_47_test:<br/>  # a0 = buffer // do not take in // a1=value a2=where_to_store_in_buffer<br/>  addi $sp,$sp,-4<br/>  sw $ra, 0($sp)<br/>  li $a1,12<br/>  li $a2,0<br/>  jal save_to_buffer<br/>  lw $ra, 0($sp)<br/>  li $a1,47<br/>  li $a2, 1<br/>  jal save_to_buffer<br/>  lw $ra, 0($sp)<br/>  addi $sp,$sp,4<br/>  jr $ra</span></pre><pre class="nj mr ms mt bn mu mv bi"><span id="ca8a" class="mw ld in ms b be mx my l mz na">  @Test<br/>  public void save_12_and_47() {<br/>    Label output_buffer = wordData(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0); <br/>    run("save_12_and_47_test", output_buffer);<br/>    int[] solutions = {12,47};<br/>    for (int i=0; i&lt;2; i++) System.out.print(getWord(output_buffer.address()+i*4) + " ");<br/>    System.out.println();<br/>    for (int i=0; i&lt;solutions.length; i++) Assert.assertEquals(solutions[i],getWord(getWord(output_buffer.address()+i*4)));<br/>  }</span></pre><p id="1912" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们来看看结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi nk"><img src="../Images/463843837165bec19ee8ab05d44cffe7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-F64M3Q5TOCFOgBpBLlg8Q.png"/></div></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">堆地址是正确的</figcaption></figure><p id="2a2d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">太好了！堆地址符合我们的预期，测试用例已经通过了！</p><h2 id="dd36" class="mf ld in bd le mg mh dn li mi mj dp lm jv mk ml lq jz mm mn lu kd mo mp ly mq bi translated">记忆化的斐波那契</h2><p id="e7e1" class="pw-post-body-paragraph jk jl in jm b jn ma jp jq jr mb jt ju jv mc jx jy jz md kb kc kd me kf kg kh ig bi translated">对于这个编码示例，我想使用记忆化修改我在第一篇 MUnit 文章中写的 fibonacci 函数。记忆化是一种提高函数速度的技术，它通过缓存昂贵的函数调用的结果，并在再次使用相同的输入时返回缓存的结果。</p><p id="fe42" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在我们的新版本中，我们将在堆中分配空间来存储 Fibonacci 函数以前的值。在我们的 Fibonacci 函数中，除了 n 之外，我们还将接受这个存储堆的地址。这个堆地址将作为一个地址数组，指向堆中的点，结果是不同的 Fibonacci 数。数组将按顺序存储，这意味着数组[0]的地址指向第一个斐波那契数，数组[1]指向第二个，依此类推。我们将检查这个数组，看它是否存储了 Fibonacci(n)的答案，如果没有，我们将运行递归函数，将每个新数字保存到数组中。</p><p id="00e6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下面是我们在堆中创建的数据结构的伪代码示例:</p><pre class="kj kk kl km gt mr ms mt bn mu mv bi"><span id="930a" class="mw ld in ms b be mx my l mz na">buffer fib_array:<br/>  words[addressToFib1, addressToFib2, addressToFib3,...., addressToFib100]</span></pre><p id="49bf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这被表示为一个标签，指向包含我们的斐波纳契数解的地址或 null 的字的数组。</p><p id="ec7c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在是这样的:</p><pre class="kj kk kl km gt mr ms mt bn mu mv bi"><span id="fa33" class="mw ld in ms b be mx my l mz na"># Compute the nth fibonacci number<br/>#<br/># n: the index of the fibonacci number to compute<br/>#<br/># return: the nth fibonacci number<br/><br/>.globl fibonacci<br/>fibonacci:<br/>    # inputs: a0=n<br/>    # Check if n is 0 or 1<br/>    li $t0, 1<br/>    beqz $a0, return_0<br/>    beq $a0, $t0, return_1<br/><br/>    # Compute the (n-1)th and (n-2)th fibonacci numbers<br/>    addi $sp, $sp, -16    # allocate space on the stack<br/>    sw $ra, 4($sp)       # save return address<br/>    sw $a0, 0($sp)       # save n<br/>    addi $a0, $a0, -1    # n-1<br/>    jal fibonacci        # call fibonacci(n-1)<br/>    sw $v0, 8($sp)       # store fib(n-1) in the stack<br/>    lw $a0, 0($sp)       # restore n<br/>    addi $a0, $a0, -2    # n-2<br/>    jal fibonacci        # call fibonacci(n-2)<br/>    sw $v0, 12($sp)      # store fib(n-2) in the stack<br/>    lw $ra, 4($sp)       # restore return address<br/>    # Return the sum of the (n-1)th and (n-2)th fibonacci numbers<br/>    lw $v0, 8($sp)       # load fib(n-1)<br/>    lw $v1, 12($sp)      # load fib(n-2)<br/>    add $v0, $v0, $v1<br/>    <br/>    addi $sp, $sp, 16     # deallocate space on the stack<br/>    jr $ra<br/><br/>return_0:<br/>    li $v0, 0    # return 0<br/>    jr $ra<br/><br/>return_1:<br/>    li $v0, 1    # return 1<br/>    jr $ra</span></pre><p id="9d27" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">除了 allocateHeapSpace 之外，我还编写了一些更有用的宏。</p><pre class="kj kk kl km gt mr ms mt bn mu mv bi"><span id="5474" class="mw ld in ms b be mx my l mz na">.macro getFibFrom(%address, %n)<br/>  # preserve s registers<br/>  addi $sp, $sp, -8<br/>  sw $s0, 0($sp)<br/>  sw $s1, 4($sp)<br/>  # logic<br/>  li $s0,4<br/>  mul $s0, %n, 4<br/>  add $s0, $s0, %address<br/>  lw $s1, 0($s0) # s1 now contains pointer to answer<br/>  beqz $s1, fib_not_present # if no pointer exists, return false<br/>  li $v1, 1 # return true<br/>  lw $s0, 0($s1) # return answer<br/>  move $v0, $s1<br/>  j end_getFibFrom<br/>  fib_not_present:<br/>  li $v0, -1 # return false<br/>  li $v1, -1<br/>  # end logic<br/>  end_getFibFrom:<br/>  lw $s0, 0($sp)<br/>  lw $s1, 4($sp)<br/>  addi $sp, $sp, 8<br/>.end_macro</span></pre><pre class="nj mr ms mt bn mu mv bi"><span id="4e4d" class="mw ld in ms b be mx my l mz na">.macro saveFibTo(%address, %n, %fib)<br/>  # preserve s registers<br/>  addi $sp, $sp, -8<br/>  sw $s0, 0($sp)<br/>  sw $v0, 4($sp)<br/>  # logic<br/>  li $s0,4<br/>  mul $s0, %n, 4<br/>  add $s0, $s0, %address<br/>  allocateHeapSpace(4) # 4 bytes = 1 word<br/>  sw %fib, 0($v0) # save fib to heap address<br/>  sw $v0, 0($s0) # save heap address to array<br/>  # end logic<br/>  lw $s0, 0($sp)<br/>  lw $v0, 4($sp)<br/>  addi $sp, $sp, 4<br/>.end_macro</span></pre><pre class="nj mr ms mt bn mu mv bi"><span id="19a6" class="mw ld in ms b be mx my l mz na">.macro allocateHeapSpaceReg(%a)<br/>  # ALLOCATE HEAP SPACE WITH REGISTER INSTEAD OF IMMEDIATE<br/>  addi $sp, $sp, -4 <br/>  sw $a0, 0($sp)<br/>  li $v0, 9<br/>  move $a0, %a <br/>  syscall<br/>  lw $a0, 0($sp)<br/>  addi $sp, $sp, 4<br/>.end_macro</span></pre><p id="f850" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">以及使用堆创建新的 fib 号数组的函数:</p><pre class="kj kk kl km gt mr ms mt bn mu mv bi"><span id="6e54" class="mw ld in ms b be mx my l mz na">.globl instantiate_array<br/>instantiate_array:<br/>  # a0 = array size<br/>  allocateHeapSpaceReg($a0)<br/>  move $a1, $v0<br/>  # set elements 0, 1 in buffer as base case<br/>  li $t0,1<br/>  saveFibTo($a1,$0,$0)<br/>  saveFibTo($a1,$t0,$t0)<br/>  move $v0, $a1<br/>  jr $ra</span></pre><p id="8272" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，让我们把它们放在一起，得到我们新的斐波那契函数！</p><pre class="kj kk kl km gt mr ms mt bn mu mv bi"><span id="06c7" class="mw ld in ms b be mx my l mz na">.globl fibonacci<br/>fibonacci:<br/>    # inputs: a0=n a1=buffer<br/>    # check if buffer contains answer:<br/>    getFibFrom($a1, $a0)<br/>    bgtz $v1, end_fibonacci<br/><br/>    # set elements 0, 1 in buffer as base case<br/>    li $t0,1<br/>    saveFibTo($a1,$0,$0)<br/>    saveFibTo($a1,$t0,$t0)<br/>    addi $sp, $sp, -4<br/>    sw $ra, 0($sp)<br/>    jal fibonacci_helper # run fib function<br/>    lw $ra, 0($sp)<br/>    addi $sp,$sp, 4<br/>    end_fibonacci:<br/>      jr $ra<br/><br/>.globl fibonacci_helper<br/>fibonacci_helper:<br/>    # inputs: a0=n a1=buffer<br/>    # Check if n is 0 or 1<br/>    li $t0, 1<br/>    beqz $a0, return_0<br/>    beq $a0, $t0, return_1<br/><br/>    addi $sp, $sp, -4<br/>    sw $0, 0($sp) # marker to save result to buffer<br/>    # check if fib(n) is in the list<br/>    getFibFrom($a1, $a0)<br/>    addi $sp, $sp, 4<br/>    bgtz $v0, return_fib_result<br/>    addi $sp, $sp, -4<br/>    li $t0, 1<br/>    sw $t0, 0($sp) # marker to save result to buffer<br/><br/>    # Compute the (n-1)th and (n-2)th fibonacci numbers<br/>    addi $sp, $sp, -16   # allocate space on the stack<br/>    sw $ra, 4($sp)       # save return address<br/>    sw $a0, 0($sp)       # save n<br/>    addi $a0, $a0, -1    # n-1<br/>    jal fibonacci_helper # call fibonacci(n-1)<br/>    sw $v0, 8($sp)       # store fib(n-1) in the stack<br/>    lw $ra, 4($sp)       # save return address<br/>    lw $a0, 0($sp)       # restore n<br/>    addi $a0, $a0, -2    # n-2<br/>    jal fibonacci_helper # call fibonacci(n-2)<br/>    sw $v0, 12($sp)      # store fib(n-2) in the stack<br/>    lw $ra, 4($sp)       # restore return address<br/>    # Return the sum of the (n-1)th and (n-2)th fibonacci numbers<br/>    lw $v0, 8($sp)       # load fib(n-1)<br/>    lw $v1, 12($sp)      # load fib(n-2)<br/>    add $v0, $v0, $v1    # solution<br/>    lw $a0, 0($sp)       # restore n<br/>    addi $sp, $sp, 16    # deallocate space on the stack<br/>    j end_fibonacci_n<br/><br/>    return_0:<br/>      li $v0, 0    # return 0<br/>      jr $ra<br/><br/>    return_1:<br/>      li $v0, 1    # return 1<br/>      jr $ra<br/><br/>    end_fibonacci_n:<br/>      lw $t0, 0($sp)<br/>      beqz $t0, return_fib_result<br/>        # save result<br/>        move $t0, $v0 # avoid using special registers as inputs<br/>        saveFibTo($a1,$a0,$t0)<br/>        addi $sp, $sp, 4<br/>      return_fib_result:<br/>        jr $ra</span></pre><p id="6ffc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里我们修改了原始代码的几个部分。我们添加了一个新的 helper 函数，它包含了我们大部分的旧代码，并放弃了<code class="fe nb nc nd ms b">fibonacci</code>标签，包含了对我们的值的缓冲区搜索，并为我们添加了基本案例。在<code class="fe nb nc nd ms b">fibonacci_helper</code>中，我们添加了一个检查来查看 fib(n-1 或 n-2)是否包含在缓冲区中，否则求解它们并将结果添加到缓冲区中的正确位置。</p><p id="2716" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里使用的例子并不是一个很好的利用堆的例子，因为我们存储了指向 int 的指针，而 int 可以很好地工作，然而这更多的是为了示范而不是最有效的代码。我们编写的代码的主要优点是不再需要计算两次斐波那契数，当我们多次运行该函数时，它将保持快速而不是缓慢。</p><p id="8eb1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我已经为我们的新功能修改了我在本文的<a class="ae lb" href="https://medium.com/dev-genius/introduction-to-unit-testing-in-munit-4ce7e24ff3f4" rel="noopener">中展示的测试用例，然后创建新的测试用例来充分利用这些特性！</a></p><pre class="kj kk kl km gt mr ms mt bn mu mv bi"><span id="cba0" class="mw ld in ms b be mx my l mz na">  @Test<br/>  public void test_zero() {<br/>    run("instantiate_array", 20);<br/>    run("fibonacci", 0,get(v0));<br/>    Assert.assertEquals(0, get(v0));<br/>  }<br/><br/>  @Test<br/>  public void test_one() {<br/>    run("instantiate_array", 20);<br/>    run("fibonacci", 1,get(v0));<br/>    Assert.assertEquals(1, get(v0));<br/>  }<br/><br/>  @Test<br/>  public void fib_25() {<br/>    run("instantiate_array", 120);<br/>    int address = get(v0);<br/>    for (int n=2; n&lt;25; n++){<br/>      run("fibonacci", n, get(v0)); <br/>      Assert.assertEquals("fibonacci failed at n=" + n, fibonacci_nums[n], get(v0));<br/>      // test buffer<br/>      for (Integer i=0; i&lt;n; i++) Assert.assertEquals("failed at buffer_val=" + i.toString(), fibonacci_nums[i], getWord(getWord(address+i*4)));    <br/>    }<br/>  }</span></pre><p id="1274" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在在测试<code class="fe nb nc nd ms b">fib_25</code>时出现了一个问题，我们得到的错误是:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi nl"><img src="../Images/bbd2aa0483540cf9d785c93dcc519a16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*74gLdg2jw9PByHi-oNuldw.png"/></div></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">穆尼特没能得到一个词</figcaption></figure><p id="5bf4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这也是我们之前遇到的问题，MUnit 覆盖了之前分配的堆空间。因此，我们测试此代码的最佳方式是编写基于 MIPS 函数的测试用例，以展示此新函数可以使用实例化的数组和以前 fib 编号的值。</p><pre class="kj kk kl km gt mr ms mt bn mu mv bi"><span id="9d2e" class="mw ld in ms b be mx my l mz na"># ...continued from fibonacci_helper...<br/><br/>.globl test_fib_0<br/>test_fib_0:<br/>  # inputs: a0=array_size<br/>  addi $sp, $sp, -8<br/>  sw $ra, 0($sp)<br/><br/>  jal instantiate_array<br/>  lw $ra, 0($sp)<br/>  move $a1, $v0<br/>  sw $v0, 4($sp)<br/><br/>  li $a0, 14<br/>  jal fibonacci<br/>  lw $ra, 0($sp)<br/>  li $a0, 21<br/>  jal fibonacci<br/>  lw $ra, 0($sp)<br/>  lw $v1, 4($sp)<br/>  addi $sp, $sp, 8<br/>  jr $ra</span></pre><pre class="nj mr ms mt bn mu mv bi"><span id="1493" class="mw ld in ms b be mx my l mz na">  @Test<br/>  public void test_fib_0() {<br/>    run("test_fib_0", 100); <br/>    Assert.assertEquals(fibonacci_nums[21], get(v0));<br/>    for (int n=0;n&lt;21;n++) Assert.assertEquals("fibonacci failed at n="+n, fibonacci_nums[n], getWord(getWord(get(v1)+n*4)));<br/>  }</span></pre><p id="8fd9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当我们运行我们的测试用例时，我们可以看到它们是成功的！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nf ng di nh bf ni"><div class="gh gi nm"><img src="../Images/90c961304ea843f9147e0ad66956a3c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hy8_X8jnuBwQ6GOBHFNgYA.png"/></div></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">成功！</figcaption></figure><p id="59b1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有大量的其他测试案例可以应用到这个函数上，因为它有很多可能出错的地方。然而，由于本文的目的是演示如何在 MUnit 中测试缓冲区，我将把这些额外的测试用例留给读者作为练习。请随意分叉这个项目的存储库，如下所示！</p><div class="nn no gp gr np nq"><a href="https://github.com/daminals/Unit_Testing_with_MUnit" rel="noopener  ugc nofollow" target="_blank"><div class="nr ab fo"><div class="ns ab nt cl cj nu"><h2 class="bd io gy z fp nv fr fs nw fu fw im bi translated">GitHub-da minals/Unit _ Testing _ with _ MUnit</h2><div class="nx l"><h3 class="bd b gy z fp nv fr fs nw fu fw dk translated">学习使用基于 JUnit 的测试框架 MUnit…</h3></div><div class="ny l"><p class="bd b dl z fp nv fr fs nw fu fw dk translated">github.com</p></div></div><div class="nz l"><div class="oa l ob oc od nz oe ko nq"/></div></div></a></div><p id="cd8e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">不要害怕看我以前关于这个话题的文章，看看下面的列表吧！</p><div class="nn no gp gr np"><div role="button" tabindex="0" class="ab bv gv cb fp of og bn oh ko ex"><div class="oi l"><div class="ab q"><div class="l di"><img alt="Daniel Kogan" class="l de bw oj ok fe" src="../Images/7850667f0a1b3a4df3d10e38d40dd0d7.png" width="20" height="20" loading="lazy" data-original-src="https://miro.medium.com/v2/resize:fill:40:40/1*AndoyUY0KtYQlny-dNuRJg.jpeg"/><div class="fb bw l oj ok fc n aw fd"/></div><div class="hh l fo"><p class="bd b dl z fp fq fr fs ft fu fv fw dk translated">丹尼尔·科岗</p></div></div><div class="on oo gw l"><h2 class="bd io tr ts fp tt fr fs nw fu fw im bi translated">MIPS 和 MUnit 测试</h2></div><div class="ab q"><div class="l fo"><a class="bd b be z bi tu au tv tw tx qj ty an eh ei tz ua ub el em eo de bk ep" href="https://medium.com/@danielkoganx/list/mips-and-munit-testing-77aed8ce48dc?source=post_page-----1f10011cdc1b--------------------------------" rel="noopener follow" target="_top">View list</a></div><div class="uc l fo"><span class="bd b dl z dk">4 stories</span></div></div></div><div class="pa dh pb fp ab pc fo di"><div class="di os bv ot ou"><div class="dh l"><img alt="" class="dh" src="../Images/93848048ab761a945c8634426d023c84.png" width="194" height="194" loading="lazy" role="presentation" data-original-src="https://miro.medium.com/v2/resize:fill:388:388/1*X-WGNQCQ6D-5oTBGBFKD6g.png"/></div></div><div class="di os bv ov ow ox"><div class="dh l"><img alt="" class="dh" src="../Images/a8678d135b4f27785654f1c415747a04.png" width="194" height="194" loading="lazy" role="presentation" data-original-src="https://miro.medium.com/v2/resize:fill:388:388/1*xGaSWaMkMcySOhu6auTzRA.png"/></div></div><div class="di bv oy oz ox"><div class="dh l"><img alt="" class="dh" src="../Images/b425d085e8a13ad518556bf490421e71.png" width="194" height="194" loading="lazy" role="presentation" data-original-src="https://miro.medium.com/v2/resize:fill:388:388/1*zxdQQn_P6Xu44foCqO55Qw.png"/></div></div></div></div></div></div></div>    
</body>
</html>