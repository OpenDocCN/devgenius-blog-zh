<html>
<head>
<title>Go Code Generator for Kubectl Plugins</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用于 Kubectl 插件的 Go 代码生成器</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/go-code-generator-for-kubectl-plugins-42543dd63525?source=collection_archive---------10-----------------------#2022-07-20">https://blog.devgenius.io/go-code-generator-for-kubectl-plugins-42543dd63525?source=collection_archive---------10-----------------------#2022-07-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="03dc" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">构建 cobra 代码生成器，一步生成基于 client-go 的 kubectl 插件</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/8daf46aa5699cea10a2d3f0a6ea64945.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pbbd3RhNm-hcf0ze"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">来自 unsplash，<a class="ae kv" href="https://unsplash.com/photos/m8SYncCFoVo" rel="noopener ugc nofollow" target="_blank"> @kimtunger </a></figcaption></figure><p id="6972" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在编码中，我们总是试图采用一些代码生成器来避免重复工作并提高生产率。当然，Go 社区也不例外，在那里各种工具被开发和共享，比如前面提到的<a class="ae kv" href="https://medium.com/swlh/kubernetes-operator-for-beginners-what-why-how-21b23f0cb9b1" rel="noopener">kube builder 提供的命令行工具</a>。</p><p id="34e8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">作为平台开发人员，我们为用户提供了特定的代码生成工具，旨在</p><ul class=""><li id="9ef8" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">使用户能够专注于业务，加速他们的开发过程。</li><li id="3fdf" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">统一框架和库。它不仅使您不必在框架选择上犹豫不决，并使学习曲线变平，而且通过提供统一的版本升级计划减少了可能的安全漏洞。</li><li id="f516" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">更有利于代码维护。</li></ul><p id="312e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在开始为 kubectl 插件设计 Go 命令行代码生成器之前，让我们先了解一些基本概念。</p><h1 id="3b79" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">Kubectl 插件</h1><p id="8367" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated"><a class="ae kv" href="https://kubernetes.io/docs/tasks/extend-kubectl/kubectl-plugins/" rel="noopener ugc nofollow" target="_blank"> kubectl 插件</a>是基于 kubectl 的一些可扩展的命令行工具，支持除默认功能之外的功能，比如扩展查询，一些<code class="fe nd ne nf ng b">kubectl get</code>和<code class="fe nd ne nf ng b">kubectl get -o wide</code>无法显示的状态和规范字段等。</p><p id="7a30" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">kubectl 插件并不局限于 Go，而是可以存在于任何合格的脚本或代码中。但是，它们中的许多都是在 Go 中实现的，因此它们可以与像<a class="ae kv" href="https://github.com/kubernetes/client-go" rel="noopener ugc nofollow" target="_blank"> client-go </a>这样的包进行交互，以丰富它们的功能。👉请阅读<a class="ae kv" href="https://medium.com/p/34daa9de15fd" rel="noopener"> <em class="nh">从头构建一个 Kubectl 插件</em> </a>以实现<em class="nh">。</em></p><h1 id="c8ef" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">Go 命令行工具</h1><p id="45b6" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">用 Go 实现 CLI 工具很常见，它不仅支持<code class="fe nd ne nf ng b">mod</code>和<code class="fe nd ne nf ng b">help</code>命令，还支持很多 Kubernetes 相关的工具，比如 kubebuilder 和<a class="ae kv" href="https://github.com/kubernetes-sigs/controller-runtime" rel="noopener ugc nofollow" target="_blank"> controller-runtime </a>。</p><p id="c76f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">实现 Go 命令行的最流行的方法。</p><ul class=""><li id="f1cc" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">土豪<a class="ae kv" href="https://pkg.go.dev/flag" rel="noopener ugc nofollow" target="_blank">旗包</a>。</li><li id="ecc2" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">“致命的”cobra，<a class="ae kv" href="https://github.com/spf13/cobra" rel="noopener ugc nofollow" target="_blank"> spf13/cobra </a>，最流行的 Go 命令行包，它提供了那些不可或缺的命令行特性，包括子命令、标志、可配置参数，被 Kubernetes、Etcd、Hugo 等使用。</li><li id="6051" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">一个更新的 Go 命令行包 urfave/cli ，功能类似于 cobra，但更方便。</li></ul><p id="4497" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Go 标志包在功能方面有缺陷，比如缺少子命令支持，只支持<code class="fe nd ne nf ng b">-f</code>标志而不支持<code class="fe nd ne nf ng b">--flag</code>，所以它很少用于实现命令行工具。详情请参考 pkg.dev 上的<a class="ae kv" href="https://pkg.go.dev/flag#example-package" rel="noopener ugc nofollow" target="_blank">示例</a></p><p id="bdab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">相反，<code class="fe nd ne nf ng b">spf13/cobra</code>或者<code class="fe nd ne nf ng b">urfave/cli</code>都可以支持 99%的场景。由于这两者在用法上非常相似，我将以 cobra 为例，带您完成下面的练习。</p><h2 id="2630" class="ni mh iq bd mi nj nk dn mm nl nm dp mq lf nn no ms lj np nq mu ln nr ns mw nt bi translated">命令行工具代码结构</h2><p id="fab9" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">Go 在代码实现方面有相当宽松的规范，允许我们将所有的<code class="fe nd ne nf ng b">.go</code>文件放在根目录下。然而，正如我们需要将文件放在一个合理的文件夹(包)中以保持文件的可读性一样，这同样适用于命令行工具代码。</p><p id="90ae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是一个设计良好的命令行工具代码结构。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nu"><img src="../Images/208bfc1a2c41593e66b27e62852d739b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*h1Fxmu-UWgJhcUrD"/></div></div></figure><p id="f4ee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如图所示，root 命令下有一组相关的子命令，以<code class="fe nd ne nf ng b">$name rootCmd subcommand --flags params</code>的格式调用。例如，<code class="fe nd ne nf ng b">go help</code>是一个根命令，支持包括<code class="fe nd ne nf ng b">mod</code>、<code class="fe nd ne nf ng b">build</code>等查询。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nv"><img src="../Images/5244fa05f95f1738ee1c0007590fce23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Vj305Au_n7WbUCXF"/></div></div></figure><p id="5282" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用 cobra 时，我们应该尝试以类似的方式构建代码。</p><h1 id="8ce0" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">使用 cobra</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/45f0754a73ee1e83e661d28753978cbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Sw2jS7f_vzme_ICP"/></div></div></figure><p id="8f3a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Cobra 功能丰富，这也解释了为什么它如此受 28K Github 明星的欢迎。</p><h2 id="77bd" class="ni mh iq bd mi nj nk dn mm nl nm dp mq lf nn no ms lj np nq mu ln nr ns mw nt bi translated">创建基于 cobra 的代码</h2><p id="7bf3" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">Cobra 是命令行包中的佼佼者，因为它有代码生成器，<a class="ae kv" href="https://github.com/spf13/cobra-cli" rel="noopener ugc nofollow" target="_blank"> cobra-cli </a>，它有助于代码构建和健康的代码结构。</p><ul class=""><li id="685b" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">安装 cobra。</li></ul><pre class="kg kh ki kj gt nx ng ny nz aw oa bi"><span id="8958" class="ni mh iq ng b gy ob oc l od oe"># Before Go 1.16 you should use go get<br/>go install github.com/spf13/cobra@latest</span></pre><ul class=""><li id="5c03" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">安装<a class="ae kv" href="https://github.com/spf13/cobra-cli/tree/main/cmd" rel="noopener ugc nofollow" target="_blank"> cobra-cli </a>，快速生成基本 cobra 命令行工具的代码。</li></ul><pre class="kg kh ki kj gt nx ng ny nz aw oa bi"><span id="d826" class="ni mh iq ng b gy ob oc l od oe">go install github.com/spf13/cobra-cli@latest<br/>mkdir cligen; cd cligen</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/6e6e985b4fe4613718fac53dfcbc8b43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*npZSpcZgYGOHQq8A"/></div></div></figure><ul class=""><li id="2b65" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">生成一个名为<code class="fe nd ne nf ng b">cligen</code>的工具。</li></ul><pre class="kg kh ki kj gt nx ng ny nz aw oa bi"><span id="04f6" class="ni mh iq ng b gy ob oc l od oe">cobra-cli init -a slaise -l MIT cligen</span></pre><p id="802a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们得到一个包含<code class="fe nd ne nf ng b">cmd/root.go</code>、<code class="fe nd ne nf ng b">main.go</code>和<code class="fe nd ne nf ng b">LICENSE</code>的 Go <code class="fe nd ne nf ng b">cligen</code>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi og"><img src="../Images/8259c8227c6f232ca71f568ac230734c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jyXXQavigGGo9EKe"/></div></div></figure><ul class=""><li id="999c" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">添加一个名为<code class="fe nd ne nf ng b">kubectlgen</code>的子命令。</li></ul><pre class="kg kh ki kj gt nx ng ny nz aw oa bi"><span id="90ba" class="ni mh iq ng b gy ob oc l od oe"># it will create a kubectlgen.go inside cmd/<br/>​​cobra-cli add kubectlgen</span></pre><p id="a39f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">新生成的<code class="fe nd ne nf ng b">kubectlgen</code>子命令中的内容如下。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oh"><img src="../Images/942bb351e9bd1ad1a664d82e3e8bcf12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_SZFxtICn80SAM8n"/></div></div></figure><p id="87c5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nd ne nf ng b">cobra-cli</code>帮助构建命令行代码框架，我们可以在此基础上进行重新开发。在未来代码生成工具的实现中借鉴 cobra-cli 的优点时，要绕开它的缺点。</p><ul class=""><li id="f90d" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">无法生成<code class="fe nd ne nf ng b">go.mod</code>文件。只有预先存在<code class="fe nd ne nf ng b">go.mod</code>文件，才能成功运行<code class="fe nd ne nf ng b">cobra-cli init</code>。</li><li id="fb67" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">只包含最简单的 cobra 特性，比如<code class="fe nd ne nf ng b">init</code>方法。</li></ul><h2 id="6c84" class="ni mh iq bd mi nj nk dn mm nl nm dp mq lf nn no ms lj np nq mu ln nr ns mw nt bi translated">眼镜蛇特征</h2><p id="a577" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">cobra 主要有<strong class="ky ir"> 5 个特性</strong>，这些特性在命令行工具设计中非常有用。</p><ul class=""><li id="9d8b" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><strong class="ky ir">自动生成根命令和子命令的帮助信息</strong>，包括命令描述、可选标志、用法等。其格式符合 bash 命令帮助信息的标准。</li><li id="ecc3" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">自动提供未识别命令的<strong class="ky ir">错误信息</strong>。</li><li id="7ac2" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">完全兼容长短标志(POSIX)，如<code class="fe nd ne nf ng b">-d</code>和<code class="fe nd ne nf ng b">— debug</code>。</li><li id="0e76" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">支持命令嵌套，即根命令的子命令可以有自己的子命令。</li><li id="2111" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">自动支持命令完成。</li></ul><p id="bb8e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">眼镜蛇的<strong class="ky ir"> 3 个最重要的概念</strong>是<code class="fe nd ne nf ng b">Commands</code>、<code class="fe nd ne nf ng b">Flags</code>和<code class="fe nd ne nf ng b">Args</code>。</p><p id="af6e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nd ne nf ng b"><strong class="ky ir">Command</strong></code>是 cobra 的核心，除了自动生成中的三个基本特性<code class="fe nd ne nf ng b">Use</code>、<code class="fe nd ne nf ng b">Short</code>、<code class="fe nd ne nf ng b">Long</code>之外，还支持几十个附加特性，比如最常用的<code class="fe nd ne nf ng b">Aliases</code>、<code class="fe nd ne nf ng b">SuggestFor</code>、<code class="fe nd ne nf ng b">Example</code>、<code class="fe nd ne nf ng b">Version</code>。另外，<code class="fe nd ne nf ng b">kubectlgen</code>子命令已经默认提供了<code class="fe nd ne nf ng b">Run</code>方法，可以直接编写命令的逻辑。并且可以依次运行一套<code class="fe nd ne nf ng b">Run</code>相关的方法。</p><ul class=""><li id="66b0" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><em class="nh">持续预运行</em></li><li id="18a3" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><em class="nh">预运行</em></li><li id="69eb" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><em class="nh">运行</em></li><li id="4605" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><em class="nh">运行后</em></li><li id="7dc2" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><em class="nh">持续后期运行</em></li></ul><p id="ea7f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每个函数使用相同的参数并提供其对应的<code class="fe nd ne nf ng b">xxxE</code>版本函数，这些函数使用 error 作为返回参数，比如<code class="fe nd ne nf ng b">RunE func(cmd *Command, args []string) error</code>。</p><p id="6fb3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nd ne nf ng b"><strong class="ky ir">Flags</strong></code>对于命令行工具也是必不可少的，cobra 支持持久和本地标志类型。</p><p id="1dc3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">“持久”意味着标志可用于分配给它的命令以及该命令下的每个子命令。“全局”是根命令上的永久标志。</p><p id="56c4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">相反，命令的“本地”标志仅适用于该特定命令。</p><p id="db7b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在底层，cobra 使用 spf13 的另一个包<a class="ae kv" href="https://github.com/spf13/pflag" rel="noopener ugc nofollow" target="_blank"> pflag </a>来解析标志。每个命令本身有两个<code class="fe nd ne nf ng b">flagSet</code>，支持<code class="fe nd ne nf ng b">usage</code>和<code class="fe nd ne nf ng b">sort</code>等基本功能，并包含后续的 arg 信息，分别用于存储持久标志和局部标志。</p><p id="f6b3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">同时，我们也可以将标志设置为“必需的”。</p><pre class="kg kh ki kj gt nx ng ny nz aw oa bi"><span id="5ce2" class="ni mh iq ng b gy ob oc l od oe">rootCmd.PersistentFlags().StringVarP(&amp;config, "config", "c", "", "Config File(required)")</span><span id="b183" class="ni mh iq ng b gy oi oc l od oe">rootCmd.MarkPersistentFlagRequired("config")</span></pre><p id="b02f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nd ne nf ng b">args</code>是一个字符串片，可以在验证、读取或转换后使用。</p><p id="a75c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有了以上所有的 cobra 知识和包含生成的<code class="fe nd ne nf ng b">kubectlgen</code>子命令的根命令，我们就可以完成我们的代码生成工具了。</p><h1 id="b360" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">实现 CLI 生成器</h1><h2 id="ee91" class="ni mh iq bd mi nj nk dn mm nl nm dp mq lf nn no ms lj np nq mu ln nr ns mw nt bi translated">代码功能</h2><p id="b613" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">首先，让我们列出一个 kubectl 插件应该包含哪些我们可以预先设计并自动生成的“模板化”代码。</p><ul class=""><li id="a051" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">一个<code class="fe nd ne nf ng b">go.mod</code>文件</li><li id="684a" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><code class="fe nd ne nf ng b">kubernetes.clientset </code>和<code class="fe nd ne nf ng b">discovery.DiscoveryClient</code>的生成方法。</li></ul><p id="d068" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个 kubectl 插件通常以两种方式使用<code class="fe nd ne nf ng b">client-go</code>包:通过<code class="fe nd ne nf ng b">kubernetes.clientset</code>访问<code class="fe nd ne nf ng b">Pods</code>和<code class="fe nd ne nf ng b">Deployments</code>等原生资源，或者通过<code class="fe nd ne nf ng b">discovery.DiscoveryClient</code>访问其他 CRD 资源。因此，我们最好在模板中包含这两个方法的生成。</p><ul class=""><li id="b617" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">配置对象</li></ul><p id="2462" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们通常使用一些标志和参数来访问和操作集群资源，这些标志和参数需要存储在一个 config 对象中。因此，我们可以生成一个最简单的版本。</p><ul class=""><li id="dfb6" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><code class="fe nd ne nf ng b">rootCmd</code>代码</li><li id="9547" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">默认的实现包括像<code class="fe nd ne nf ng b">help </code>和<code class="fe nd ne nf ng b">version</code>这样的支持命令。</li></ul><p id="5bc6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们将 cobra 和 client-go 相关的内容分离到一个合理结构的不同包中，生成一个项目如下。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/4c2c77afe3cd69ae525767d969fbee06.png" data-original-src="https://miro.medium.com/v2/resize:fit:928/0*WEdt40XjVUFTjvtd"/></div></figure><h2 id="d45d" class="ni mh iq bd mi nj nk dn mm nl nm dp mq lf nn no ms lj np nq mu ln nr ns mw nt bi translated">Go 模板</h2><p id="2e7c" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">然后，是关于如何生成代码？我想<code class="fe nd ne nf ng b">cobra-cli</code>已经给了我们一个很好的答案，<strong class="ky ir"> Go 模板</strong>！</p><p id="1224" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Go 模板用于解析模板文件，以便动态构建我们想要的最终文件。解析中，处理<code class="fe nd ne nf ng b">{{ . }}</code>变量或嵌套变量，传入参数。参数可以是<code class="fe nd ne nf ng b">map</code>或<code class="fe nd ne nf ng b">strcut</code>。模板代码通常有两行。</p><pre class="kg kh ki kj gt nx ng ny nz aw oa bi"><span id="70ce" class="ni mh iq ng b gy ob oc l od oe">t, err := template.ParseFiles(“tempalte.tmpl”)</span><span id="f963" class="ni mh iq ng b gy oi oc l od oe">err = t.Execute(io.Writer, data)</span></pre><p id="5b4f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以在<code class="fe nd ne nf ng b">cobra-cli</code>中找到非常好的例子，比如生成<code class="fe nd ne nf ng b">main.go</code>的<code class="fe nd ne nf ng b">cobra-cli init</code>命令调用<code class="fe nd ne nf ng b"><a class="ae kv" href="https://github.com/spf13/cobra-cli/blob/6049ad32caa8b81f554509863266de3099279264/tpl/main.go#L16" rel="noopener ugc nofollow" target="_blank">MainTemplate</a>()</code>方法来获取模板内容，然后在<code class="fe nd ne nf ng b"><a class="ae kv" href="https://github.com/spf13/cobra-cli/blob/7c6e26ac0939450323b7dd4acf8d8280dde3879e/cmd/project.go#L45" rel="noopener ugc nofollow" target="_blank">Project.Create()</a></code>方法中调用它。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><h2 id="2c64" class="ni mh iq bd mi nj nk dn mm nl nm dp mq lf nn no ms lj np nq mu ln nr ns mw nt bi translated">代码实现</h2><p id="4abc" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">最后，针对实际情况，设计了一个 kubectl-plugin 代码生成器，由 cobra 实现，集成 go-template 生成一个包含 cobra 命令、基本客户端 go 配置和客户端创建方法的 Go-code 框架。</p><p id="6c2e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">创建一个模板文件</strong></p><p id="cccc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当前模板文件包含<code class="fe nd ne nf ng b">go.mod.tpl</code>、<code class="fe nd ne nf ng b">main.go.tpl</code>等。，所需的参数主要从命令行标志传入，如工具名称。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi om"><img src="../Images/305d26113460707653841e11088bdfff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1086/0*Qq1iHQE5j5vfaZVe"/></div></figure><p id="8df4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nd ne nf ng b">main.go.tpl</code>如下图所示。<code class="fe nd ne nf ng b">name</code>是生成的目录和 Go 包的名称。</p><pre class="kg kh ki kj gt nx ng ny nz aw oa bi"><span id="bc42" class="ni mh iq ng b gy ob oc l od oe">package main</span><span id="5901" class="ni mh iq ng b gy oi oc l od oe">import "{{ .name }}/cmd"</span><span id="1d28" class="ni mh iq ng b gy oi oc l od oe">func main() {<br/>  cmd.Execute()<br/>}</span></pre><p id="d06c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">完善</strong> <code class="fe nd ne nf ng b"><strong class="ky ir">kubectlgen</strong></code> <strong class="ky ir">命令并解析模板</strong></p><p id="2988" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有三个步骤要走。</p><ul class=""><li id="0cec" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">添加标志，包括模板解析所需的信息。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi on"><img src="../Images/636eb05a4829ef747213bcfb85fbed65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RG_8L10wzSyuzjgH"/></div></div></figure><ul class=""><li id="8a9e" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">创建新工具的文件目录，该目录与模板中的目录结构一致。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oo"><img src="../Images/ae70e75f192d889d2b31558d8c4346a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rHkRw05rxbaqDDtk"/></div></div></figure><ul class=""><li id="f699" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">解析模板并将解析后的内容输出到相应的文件中。</li></ul><p id="fd6e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">两种方法:<code class="fe nd ne nf ng b">createFileFromTemplate</code>用于创建模板对象；<code class="fe nd ne nf ng b">templateGenerate</code>用于解析模板并将内容输出到文件。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="f2e8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">添加</strong> <code class="fe nd ne nf ng b"><strong class="ky ir">version</strong></code> <strong class="ky ir">和</strong> <code class="fe nd ne nf ng b"><strong class="ky ir">help</strong></code> <strong class="ky ir">命令</strong></p><p id="c638" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这两个命令都是辅助的。cobra 提供的<code class="fe nd ne nf ng b">help</code>命令非常好用，我们也可以用<code class="fe nd ne nf ng b">version.go.tpl</code>和<code class="fe nd ne nf ng b">help.go.tpl</code>模板定制。</p><h2 id="194f" class="ni mh iq bd mi nj nk dn mm nl nm dp mq lf nn no ms lj np nq mu ln nr ns mw nt bi translated">试验</h2><p id="fbf2" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">运行<code class="fe nd ne nf ng b">go build -o cligen</code>编译，然后测试。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi op"><img src="../Images/07337627ab5362d342cd76f1392970e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1286/0*hOSTfV8fcmTp7Axh"/></div></figure><p id="ac04" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">打开<code class="fe nd ne nf ng b">test-cli</code>目录中的文件，可以看到<code class="fe nd ne nf ng b">name</code>已经被替换为<code class="fe nd ne nf ng b">test-cli</code>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oq"><img src="../Images/e5f6e5f752094d4e8064ce467e849547.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-ptGsJMCe5W1Ddsy"/></div></div></figure><h1 id="e550" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">未来的步骤</h1><p id="1903" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">这个代码生成器目前还处于雏形阶段，只有生成功能。我们可以做更多的事情来帮助它成长。</p><ul class=""><li id="0156" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">添加许可证文件</li><li id="e9b6" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">添加默认的 GKE 支持，支持根据标志的<code class="fe nd ne nf ng b">gcloud</code>认证。</li><li id="9efb" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">模板化<code class="fe nd ne nf ng b">Pod</code>和<code class="fe nd ne nf ng b">Deployment</code>等原生资源的查询，增加子命令支持。</li><li id="b0bc" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">模板化不同的 CRD 查询，并添加子命令支持。</li><li id="cd43" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">将<code class="fe nd ne nf ng b">dynamic</code>和<code class="fe nd ne nf ng b">clientset</code>支持的不同资源分成不同的命令组。</li></ul><p id="337c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你还能想到什么吗？如果实现了，这将是加速 kubectl 插件编写的催化剂。参见<a class="ae kv" href="https://github.com/slaise/cligen" rel="noopener ugc nofollow" target="_blank"> github </a>上的完整代码。</p><p id="a416" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢阅读！</p><h1 id="e631" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">参考</h1><p id="b4c4" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated"><a class="ae kv" href="https://kubernetes.io/docs/tasks/extend-kubectl/kubectl-plugins/" rel="noopener ugc nofollow" target="_blank">https://kubernetes . io/docs/tasks/extend-kube CTL/kube CTL-plugins/</a></p><p id="b802" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://pkg.go.dev/flag#section-documentation" rel="noopener ugc nofollow" target="_blank">https://pkg.go.dev/flag#section-documentation</a></p></div></div>    
</body>
</html>