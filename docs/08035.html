<html>
<head>
<title>Writing a wrapper for console.log for better control in Angular, Part II</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为 console.log 编写包装器以更好地控制 Angular，第二部分</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/writing-a-wrapper-for-console-log-for-better-control-in-angular-part-ii-5b09b65af2c5?source=collection_archive---------7-----------------------#2022-05-12">https://blog.devgenius.io/writing-a-wrapper-for-console-log-for-better-control-in-angular-part-ii-5b09b65af2c5?source=collection_archive---------7-----------------------#2022-05-12</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="7456" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">驯服控制台</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/2f0c0fd072b0229e5c1ab8d11b7ee739.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6XGoHoszM7tI_jO3YnDCXw.png"/></div></div></figure><p id="2f60" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">接着是我们的<a class="ae lk" href="https://garage.sekrab.com/posts/writing-a-wrapper-for-console-log-for-better-control-in-javascript-part-i" rel="noopener ugc nofollow" target="_blank">控制台包装器</a>，在本文中，我将专门在 Angular 应用程序中使用它。该记录在<code class="fe ll lm ln lo b">RxJS</code>管道和错误记录中很有用。</p><p id="f27f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">首先，我们将脚本添加到<strong class="kq io">资产</strong>中，并在<code class="fe ll lm ln lo b">typings.d.ts</code>中声明它(如前文中所述)。</p><pre class="kd ke kf kg gt lp lo lq lr aw ls bi"><span id="2f0b" class="lt lu in lo b gy lv lw l lx ly">{<br/> "projects": {<br/>   "main": {<br/>     "architect": {<br/>       "build": {<br/>         "options": {<br/>           "scripts": [<br/>             // add the script however you wish<br/>              {<br/>                "input": "src/assets/js/console.js",<br/>                "bundleName": "script"<br/>              }<br/>            ]<br/>         }<br/>       }<br/>     }<br/>   }<br/> }<br/>}</span></pre><p id="991a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这在 SSR 运行时，会在服务器端出错，我们稍后会修复它。</p><blockquote class="lz ma mb"><p id="1450" class="ko kp mc kq b kr ks jo kt ku kv jr kw md ky kz la me lc ld le mf lg lh li lj ig bi translated"><em class="in">最终项目在</em><a class="ae lk" href="https://stackblitz.com/edit/angular-console-wrapper?file=src/app/core/rxjsops.ts" rel="noopener ugc nofollow" target="_blank"><em class="in">stack blitz</em></a>上</p></blockquote><h1 id="0383" class="mg lu in bd mh mi mj mk ml mm mn mo mp jt mq ju mr jw ms jx mt jz mu ka mv mw bi translated">角度误差处理</h1><p id="44a7" class="pw-post-body-paragraph ko kp in kq b kr mx jo kt ku my jr kw kx mz kz la lb na ld le lf nb lh li lj ig bi translated">Angular 中的默认错误处理程序记录未处理的错误。我们可以用自己的<a class="ae lk" href="https://angular.io/api/core/ErrorHandler" rel="noopener ugc nofollow" target="_blank">错误处理程序</a>(在根应用程序模块中提供)覆盖它:</p><pre class="kd ke kf kg gt lp lo lq lr aw ls bi"><span id="6c73" class="lt lu in lo b gy lv lw l lx ly">@Injectable()<br/>export class OurErrorHandler implements ErrorHandler {<br/>    handleError(error: any) {<br/>      _debug(error, 'Unhandled Error', 'e');<br/>    }<br/>}</span></pre><h1 id="af48" class="mg lu in bd mh mi mj mk ml mm mn mo mp jt mq ju mr jw ms jx mt jz mu ka mv mw bi translated">与 RxJS 一起使用</h1><p id="e179" class="pw-post-body-paragraph ko kp in kq b kr mx jo kt ku my jr kw kx mz kz la lb na ld le lf nb lh li lj ig bi translated">我们可以创建一个<a class="ae lk" href="https://medium.com/javascript-everyday/rxjs-custom-operators-f8b9aeab9631" rel="noopener">自定义操作符</a>,在管道中输出消息:</p><pre class="kd ke kf kg gt lp lo lq lr aw ls bi"><span id="870f" class="lt lu in lo b gy lv lw l lx ly">export const debug = (message: string, type?: string): MonoTypeOperatorFunction&lt;any&gt;  =&gt; {<br/>  return pipe(<br/>    tap(nextValue =&gt; {<br/>       _debug(nextValue, message, type);<br/>    })<br/>  );<br/>};</span><span id="5a74" class="lt lu in lo b gy nc lw l lx ly">// this is used with observables like this<br/>obs$.pipe(<br/>  debug('obs value')<br/>);</span></pre><p id="1229" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在之前一篇关于 Angular 中基于<a class="ae lk" href="https://garage.sekrab.com/posts/rxjs-based-angular-state-management" rel="noopener ugc nofollow" target="_blank"> RxJS 的状态管理的文章中，我们有一个 state 的基类。我们可以用 debug 语句来更新它，以记录所有的状态进度。在<code class="fe ll lm ln lo b">StateService</code>:</a></p><pre class="kd ke kf kg gt lp lo lq lr aw ls bi"><span id="6a2b" class="lt lu in lo b gy lv lw l lx ly">export class StateService&lt;T&gt;  {<br/> protected stateList: BehaviorSubject&lt;T[]&gt; = new BehaviorSubject([]);<br/> stateList$: Observable&lt;T[]&gt; = this.stateList<br/>    .asObservable()<br/>    // pipe to debug the constructor used, like ParamState, or TransactionState<br/>    .pipe(debug(this.constructor.name));<br/>}</span></pre><p id="2f53" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在，任何状态更新都将记录在控制台中。</p><h1 id="3980" class="mg lu in bd mh mi mj mk ml mm mn mo mp jt mq ju mr jw ms jx mt jz mu ka mv mw bi translated">Http 拦截器</h1><p id="8cf4" class="pw-post-body-paragraph ko kp in kq b kr mx jo kt ku my jr kw kx mz kz la lb na ld le lf nb lh li lj ig bi translated">在 devTools 调试中，会记录网络失败的尝试，显示完整的 URL，但不会记录成功的尝试。让我们将调试操作符添加到<code class="fe ll lm ln lo b">HttpInterceptor</code>中，以我们喜欢的方式记录所有数据，<em class="mc">这是必须的方式</em>😉</p><blockquote class="lz ma mb"><p id="c755" class="ko kp mc kq b kr ks jo kt ku kv jr kw md ky kz la me lc ld le mf lg lh li lj ig bi translated"><strong class="kq io"> <em class="in">【方法】【网址】【响应正文】</em> </strong></p></blockquote><pre class="kd ke kf kg gt lp lo lq lr aw ls bi"><span id="e78b" class="lt lu in lo b gy lv lw l lx ly">@Injectable()<br/>export class OurInterceptor implements HttpInterceptor {<br/>  intercept(req: HttpRequest&lt;any&gt;, next: HttpHandler): Observable&lt;HttpEvent&lt;any&gt;&gt; {</span><span id="d7f7" class="lt lu in lo b gy nc lw l lx ly">    // adjust req if needed<br/>    return next<br/>      .handle(req)<br/>      .pipe(<br/>        // pipe with req information, method, and url with params<br/>        debug(`${req.method} ${req.urlWithParams}`, 'p')<br/>      )<br/>    }<br/>}</span></pre><p id="0487" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">让我们重写调试操作符来处理以下内容:</p><ul class=""><li id="76b4" class="nd ne in kq b kr ks ku kv kx nf lb ng lf nh lj ni nj nk nl bi translated">如果<code class="fe ll lm ln lo b">nextValue</code>是<code class="fe ll lm ln lo b">HttpResponse</code>类型，我们需要记录<strong class="kq io">主体</strong>。</li><li id="6ada" class="nd ne in kq b kr nm ku nn kx no lb np lf nq lj ni nj nk nl bi translated">我们还需要过滤掉<code class="fe ll lm ln lo b">Sent</code>类型的无用值。那是一个在每个 http 响应之前设置的事件，没有什么价值，在其他可观察到的地方是<code class="fe ll lm ln lo b">undefined</code>。</li></ul><pre class="kd ke kf kg gt lp lo lq lr aw ls bi"><span id="5a39" class="lt lu in lo b gy lv lw l lx ly">export const debug = (message: string, type?: string): MonoTypeOperatorFunction&lt;any&gt;  =&gt; {<br/>     return pipe(<br/>        tap(nextValue =&gt; {<br/>            let value = nextValue;</span><span id="0680" class="lt lu in lo b gy nc lw l lx ly">            if (nextValue instanceof HttpResponse) {<br/>                // value is the body<br/>                value = nextValue.body;<br/>            }<br/>            // just filter out the sent event<br/>            if (nextValue &amp;&amp; &lt;any&gt;nextValue.type !== HttpEventType.Sent){<br/>                _debug(value, message, type);<br/>            }</span><span id="3dff" class="lt lu in lo b gy nc lw l lx ly">        })<br/>    );<br/>};</span></pre><p id="2a2e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在我的日志看起来像这样</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nr"><img src="../Images/c432620d0b3376623d0e97af4e9dc8c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*VrlKmt9iJUiGNiw8.png"/></div></div></figure><p id="634d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在发生<code class="fe ll lm ln lo b">PUT</code>或<code class="fe ll lm ln lo b">POST</code>事件的情况下，我们还可以在 Http 拦截器中记录请求<code class="fe ll lm ln lo b">body</code>:</p><pre class="kd ke kf kg gt lp lo lq lr aw ls bi"><span id="b8ba" class="lt lu in lo b gy lv lw l lx ly">@Injectable()<br/>export class OurInterceptor implements HttpInterceptor {<br/>  intercept(<br/>    req: HttpRequest&lt;any&gt;,<br/>    next: HttpHandler<br/>  ): Observable&lt;HttpEvent&lt;any&gt;&gt; {</span><span id="9883" class="lt lu in lo b gy nc lw l lx ly">    // log request body, prefix to distinguish or create a new console type<br/>    if (req.body) {<br/>      _debug(req.body, `Request: ${req.method} ${req.urlWithParams}`, 'p');<br/>    }</span><span id="8dfe" class="lt lu in lo b gy nc lw l lx ly">    return next.handle(adjustedReq).pipe(<br/>     //...<br/>    );<br/>  }<br/>}</span></pre><p id="ad18" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">日志看起来像这样</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ns"><img src="../Images/2e9317a933cdc1393ab0db3ee3a4e32a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*2x5yMHdVZKu1lZqr.png"/></div></div></figure><p id="adf4" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">让我们更上一层楼。让我使用<code class="fe ll lm ln lo b">tap</code>扩展回调来记录 Http 错误，就像这样:</p><pre class="kd ke kf kg gt lp lo lq lr aw ls bi"><span id="7e18" class="lt lu in lo b gy lv lw l lx ly">export const debug = (message: string, type?: string): MonoTypeOperatorFunction&lt;any&gt; =&gt; {<br/>  return pipe(<br/>    tap({<br/>      next: (nextValue) =&gt; {<br/>        let value = nextValue;</span><span id="e31c" class="lt lu in lo b gy nc lw l lx ly">        if (nextValue instanceof HttpResponse) {<br/>          // value is the body<br/>          value = nextValue.body;<br/>        }<br/>        // just filter out the sent event<br/>        if (nextValue &amp;&amp; &lt;any&gt;nextValue.type !== HttpEventType.Sent) {<br/>          _debug(value, message, type);<br/>        }<br/>      },<br/>      error: (error) =&gt; {<br/>        // in error, log erros, check for pecific type of http response errors<br/>        let value = error;<br/>        if (error instanceof HttpErrorResponse) {<br/>          value = `${error.status} ${error.message}`;<br/>        }<br/>        _debug(value, message, 'e');<br/>      },<br/>    })<br/>  );<br/>};</span></pre><p id="6d8b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在向您展示日志之前，我回到了我们上周构建的<a class="ae lk" href="https://garage.sekrab.com/posts/gtm-tracking-service-in-angular" rel="noopener ugc nofollow" target="_blank"> GTM 角度服务</a>，并且添加了一个<code class="fe ll lm ln lo b">_debug</code>语句:</p><pre class="kd ke kf kg gt lp lo lq lr aw ls bi"><span id="1c4c" class="lt lu in lo b gy lv lw l lx ly">// GTM service updated from a previous post<br/>export class GtmTracking {<br/>  // ...<br/>  public static RegisterEvent(track: IGtmTrack, extra?: any): void {<br/>    let data = {<br/>      event: track.event, gr_track: {<br/>        source: track.source,<br/>        ...extra<br/>      }<br/>    };<br/>    // add a special type of log here<br/>    _debug(data, 'register event', 'gtm');<br/>    this.Push(data)<br/>  }</span><span id="b0ed" class="lt lu in lo b gy nc lw l lx ly">  public static SetValues(values: any): void {<br/>    let data = {<br/>      gr_values: { ...values }<br/>    };<br/>    // and here:<br/>    _debug(data, 'Set GA value', 'gtm');<br/>    this.Push(data);<br/>  }<br/>}</span></pre><p id="3520" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在<code class="fe ll lm ln lo b">ErrorService</code>中，我们调用了<strong class="kq io"> GTM 注册事件</strong>，所以现在我们得到了一个看起来不错的控制台日志:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nt"><img src="../Images/58a7c10ba81c6ad0f092bd9d66015c2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*LFAwxda2fHDNnpaK.png"/></div></div></figure><p id="b947" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">错误对象可以进一步增强，但那是不同的主题，不同的文章。</p><h1 id="9f58" class="mg lu in bd mh mi mj mk ml mm mn mo mp jt mq ju mr jw ms jx mt jz mu ka mv mw bi translated">控制台过滤视图</h1><p id="5021" class="pw-post-body-paragraph ko kp in kq b kr mx jo kt ku my jr kw kx mz kz la lb na ld le lf nb lh li lj ig bi translated">我的<code class="fe ll lm ln lo b">console.log</code>错误而不是<code class="fe ll lm ln lo b">console.error</code>错误是有原因的，那就是；把控制台过滤成<strong class="kq io"> info </strong>消息，<strong class="kq io">忘记切换回所有消息的坏习惯。</strong>注意力持续时间不断缩短。这样我们就不会错过错误，退休后我们也能享受一些理智。</p><p id="aecb" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe ll lm ln lo b">_attn</code>是为了<strong class="kq io">取代通常的 console.log </strong>而特意创建的，调用<code class="fe ll lm ln lo b">_attn</code>的输出显示在控制台<strong class="kq io">详细日志</strong>下，它们看起来很亮，亮到足以让我们记得在构建之前删除它们。但是，如果我们未能删除它们，没关系，它们无论如何都不会在生产中显示。</p><p id="237d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这会影响性能吗？不是在 99%的应用中(99%就像是说世界的一半，不是一个真实的统计数据)。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nu"><img src="../Images/6cf907d45c12c2137e1cfbb5ca3b902b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*GtwDY0rd0fXCJbNy.png"/></div></div></figure><h1 id="b66c" class="mg lu in bd mh mi mj mk ml mm mn mo mp jt mq ju mr jw ms jx mt jz mu ka mv mw bi translated">服务器平台日志</h1><p id="c489" class="pw-post-body-paragraph ko kp in kq b kr mx jo kt ku my jr kw kx mz kz la lb na ld le lf nb lh li lj ig bi translated">使用的脚本是添加到 build 中的 JavaScript，并在<code class="fe ll lm ln lo b">index.html</code>中注入。这是故意的，因为我不希望每次使用时都使用<strong class="kq io"/><code class="fe ll lm ln lo b"><strong class="kq io">import</strong></code><strong class="kq io">。这种方法还有另外一个好处。首先，让我们修复服务器平台不运行的问题，因为那些方法在<strong class="kq io"> NodeJS </strong>中不存在。这是通过在 NodeJS <code class="fe ll lm ln lo b">global</code>对象中定义这些函数来实现的。NodeJS <strong class="kq io"> express 服务器</strong>应该包含以下内容</strong></p><pre class="kd ke kf kg gt lp lo lq lr aw ls bi"><span id="8b58" class="lt lu in lo b gy lv lw l lx ly">// fix NodeJs server running SSR<br/>global._debug = function (o, message, type) {<br/>  if(process.env.NODE_ENV !== 'production') {<br/>    console.log(message, o);<br/>  }<br/>};<br/>global._attn = function (o, message) {<br/> if(process.env.NODE_ENV !== 'production') {<br/>    console.log(message, o);<br/>  }<br/>}</span></pre><p id="08a3" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在，我们可以在构建之后、部署之前在服务器上显示消息。<strong class="kq io">打开或关闭，无需重建</strong>。语境为王，分离是新女王。</p><p id="c95a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">谢谢你读到这里。如果我玩错了牌，请告诉我。</p><h1 id="6965" class="mg lu in bd mh mi mj mk ml mm mn mo mp jt mq ju mr jw ms jx mt jz mu ka mv mw bi translated">资源</h1><ul class=""><li id="abfc" class="nd ne in kq b kr mx ku my kx nv lb nw lf nx lj ni nj nk nl bi translated"><a class="ae lk" href="https://angular.io/guide/http#intercepting-requests-and-responses" rel="noopener ugc nofollow" target="_blank">角度 Http 指南</a></li><li id="6bff" class="nd ne in kq b kr nm ku nn kx no lb np lf nq lj ni nj nk nl bi translated"><a class="ae lk" href="https://angular-console-wrapper.stackblitz.io/" rel="noopener ugc nofollow" target="_blank"> StackBlitz 应用程序(查看开发工具控制台)</a></li></ul><p id="5289" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">也发表在<a class="ae lk" href="https://garage.sekrab.com/posts/writing-a-wrapper-for-console-log-for-better-control-in-angular-part-ii" rel="noopener ugc nofollow" target="_blank"> Sekrab 车库</a></p><h2 id="8a63" class="lt lu in bd mh ny nz dn ml oa ob dp mp kx oc od mr lb oe of mt lf og oh mv oi bi translated">控制台系列</h2><ul class=""><li id="c5f3" class="nd ne in kq b kr mx ku my kx nv lb nw lf nx lj ni nj nk nl bi translated"><a class="ae lk" href="https://medium.com/@aayyash/writing-a-wrapper-for-console-log-for-better-control-in-javascript-part-i-9bbd238fb9ad" rel="noopener">为 console.log 编写一个包装器以更好地控制 JavaScript，第一部分</a></li><li id="a72b" class="nd ne in kq b kr nm ku nn kx no lb np lf nq lj ni nj nk nl bi translated"><a class="ae lk" rel="noopener ugc nofollow" target="_blank" href="/writing-a-wrapper-for-console-log-for-better-control-in-angular-part-ii-5b09b65af2c5">为 console.log 编写一个包装器以更好地控制 Angular，第二部分</a></li><li id="c9e8" class="nd ne in kq b kr nm ku nn kx no lb np lf nq lj ni nj nk nl bi translated"><a class="ae lk" href="https://medium.com/@aayyash/catching-and-handling-errors-in-angular-3ac6b95853ba" rel="noopener">捕捉和处理角度误差</a></li><li id="eb11" class="nd ne in kq b kr nm ku nn kx no lb np lf nq lj ni nj nk nl bi translated"><a class="ae lk" rel="noopener ugc nofollow" target="_blank" href="/catching-and-displaying-ui-errors-with-toast-messages-in-angular-db06f2605a6d">用 toast 消息捕获并显示 UI 错误</a></li><li id="34be" class="nd ne in kq b kr nm ku nn kx no lb np lf nq lj ni nj nk nl bi translated"><a class="ae lk" href="https://medium.com/@aayyash/auto-hiding-a-toast-message-in-angular-54f886ad6129" rel="noopener">自动隐藏有角度的祝酒辞</a></li></ul></div></div>    
</body>
</html>