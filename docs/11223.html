<html>
<head>
<title>K8s — Pod Topology</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">K8s — Pod 拓扑</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/k8s-pod-topology-6639cc2b34cc?source=collection_archive---------2-----------------------#2022-12-26">https://blog.devgenius.io/k8s-pod-topology-6639cc2b34cc?source=collection_archive---------2-----------------------#2022-12-26</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><div class=""><h2 id="2f55" class="pw-subtitle-paragraph jo iq ir bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated">多节点/区域/地区 Pod 分布</h2></div><figure class="kg kh ki kj gu kk gi gj paragraph-image"><div class="ab gv cl kl"><img src="../Images/c25c7843907745d564abf8e4d43659e4.png" data-original-src="https://miro.medium.com/v2/format:webp/0*kElNJxeOHApCzL8b.png"/></div></figure><p id="db6e" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">在大规模 K8s 集群中，例如 50 多个工作节点，或者工作节点位于不同的区域或地区，您可能希望将工作负载单元分布到不同的节点、区域甚至地区。</p><p id="4843" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">这使您的工作负载能够受益于高可用性和集群利用率。例如:</p><figure class="kg kh ki kj gu kk gi gj paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gi gj lk"><img src="../Images/bca9210cc5799a4faa6069cbe8a3808d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nXLlYSgdw1hfEusUiUfjoQ.png"/></div></div><figcaption class="lp lq gk gi gj lr ls bd b be z dk translated">图片来自 k8s.io</figcaption></figure><p id="f61c" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">管理集群中的 pod 分布并不容易。K8s 的 Pod <code class="fe lt lu lv lw b">affinity</code>和<code class="fe lt lu lv lw b">anti-affinity</code>功能允许对 Pod 放置进行一些控制。然而，这些特性只能解决部分 Pods 分发用例。</p><p id="0090" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">为了在集群中均匀分布 pod 以实现高可用性和高效的集群资源利用，引入了<code class="fe lt lu lv lw b">PodTopologySpread</code>调度插件。这个插件的第一个稳定版本是在 K8s v1.19。</p><h1 id="acc6" class="lx ly ir bd lz ma mb mc md me mf mg mh jx mi jy mj ka mk kb ml kd mm ke mn mo bi translated">拓扑扩展约束字段</h1><p id="7706" class="pw-post-body-paragraph ko kp ir kq b kr mp js kt ku mq jv kw kx mr kz la lb ms ld le lf mt lh li lj ik bi translated">这个<code class="fe lt lu lv lw b">topologySpreadConstraints</code>字段依赖于节点标签来识别每个工作节点所在的拓扑域。您可以定义一个或多个<code class="fe lt lu lv lw b">topologySpreadConstraints</code>条目来指示<code class="fe lt lu lv lw b">kube-scheduler</code>如何相对于集群中现有的 Pod 放置每个传入的 Pod。</p><p id="6c0b" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">当一个 Pod 定义了多个 topologySpreadConstraint 时，这些约束使用逻辑<code class="fe lt lu lv lw b">AND</code>操作进行组合:<code class="fe lt lu lv lw b">kube-scheduler</code>为满足所有配置约束的传入 Pod 寻找一个节点。</p><p id="4242" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated"><code class="fe lt lu lv lw b">topologySpreadConstraints</code>的模板看起来像:</p><pre class="kg kh ki kj gu mu lw mv bn mw mx bi"><span id="71c2" class="my ly ir lw b be mz na l nb nc">---<br/>apiVersion: v1<br/>kind: Pod<br/>metadata:<br/>  name: example-pod<br/>spec:<br/>  # Configure a topology spread constraint<br/>  topologySpreadConstraints:<br/>    - maxSkew: &lt;integer&gt;<br/>      minDomains: &lt;integer&gt; # optional; beta since v1.25<br/>      topologyKey: &lt;string&gt;<br/>      whenUnsatisfiable: &lt;string&gt;<br/>      labelSelector: &lt;object&gt;<br/>      matchLabelKeys: &lt;list&gt; # optional; alpha since v1.25<br/>      nodeAffinityPolicy: [Honor|Ignore] # optional; alpha since v1.25<br/>      nodeTaintsPolicy: [Honor|Ignore] # optional; alpha since v1.25<br/>  ### other Pod fields go here</span></pre><h2 id="db7e" class="nd ly ir bd lz ne nf dn md ng nh dp mh kx ni nj mj lb nk nl ml lf nm nn mn no bi translated">maxSkew</h2><p id="a0d4" class="pw-post-body-paragraph ko kp ir kq b kr mp js kt ku mq jv kw kx mr kz la lb ms ld le lf mt lh li lj ik bi translated">它描述了豆荚分布不均匀的程度。您必须指定此字段，并且数字必须大于零。</p><p id="2bf4" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">如果您设置了<code class="fe lt lu lv lw b">whenUnsatisfiable: DoNotSchedule</code>，那么<code class="fe lt lu lv lw b">maxSkew</code>将定义目标拓扑中匹配 pod 数量与全局最小值之间的最大允许差值(合格域中匹配 pod 的最小数量，或者如果合格域的数量小于 MinDomains，则为零)。</p><p id="49d3" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">例如，在一个 3 区集群中，<code class="fe lt lu lv lw b">MaxSkew</code>被设置为 1，并且具有相同<code class="fe lt lu lv lw b">labelSelector</code>分布的 pod 为 1/1/0:us-east-1a/us-east-1b/us-east-1c，如果<code class="fe lt lu lv lw b">MaxSkew</code>为 1，则进入的 pod 只能被调度到 us-east-1c 以变成 1/1/1；将其安排在 us-east-1a 或 us-east-1b 上会使 us-east-1a(us-east-1b)上的实际不对称(2-0)违反 max skew(1)；如果<code class="fe lt lu lv lw b">MaxSkew</code>为 2，可以将进入的 pod 安排到任何区域。</p><p id="be67" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">当<code class="fe lt lu lv lw b">whenUnsatisfiable=ScheduleAnyway</code>时，用于给予满足它的拓扑更高的优先级。这是必填字段。默认值为 1，不允许为 0。</p><h2 id="a7c7" class="nd ly ir bd lz ne nf dn md ng nh dp mh kx ni nj mj lb nk nl ml lf nm nn mn no bi translated">minDomains</h2><p id="4dff" class="pw-post-body-paragraph ko kp ir kq b kr mp js kt ku mq jv kw kx mr kz la lb ms ld le lf mt lh li lj ik bi translated">这表示合格域的最小数量。该字段是可选的。域是拓扑的一个特殊实例。合格域是其节点与节点选择器匹配的域。这是一个测试字段，默认情况下在<code class="fe lt lu lv lw b">K8sv1.25</code>中启用。</p><h2 id="9906" class="nd ly ir bd lz ne nf dn md ng nh dp mh kx ni nj mj lb nk nl ml lf nm nn mn no bi translated">地形关键</h2><p id="f9bb" class="pw-post-body-paragraph ko kp ir kq b kr mp js kt ku mq jv kw kx mr kz la lb ms ld le lf mt lh li lj ik bi translated">这是节点标签的关键。具有带有此关键字和相同值的标签的节点被视为处于同一拓扑中。我们将拓扑的每个实例(换句话说，一个<key value="">对)称为一个域。</key></p><p id="745a" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">调度程序将尝试在每个域中放置平衡数量的 pod。同样，我们将合格域定义为其节点满足<code class="fe lt lu lv lw b">nodeAffinityPolicy</code>和<code class="fe lt lu lv lw b">nodeTaintsPolicy</code>要求的域。</p><p id="adfd" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">例如，在您的 Pod 模板中，您可以定义以下内容:<br/> topologySpreadConstraints:</p><pre class="kg kh ki kj gu mu lw mv bn mw mx bi"><span id="8414" class="my ly ir lw b be mz na l nb nc">maxSkew: 1<br/>topologyKey: topology.kubernetes.io/zone</span></pre><p id="a7df" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">如果你的工人节点有标签:<code class="fe lt lu lv lw b">topology.kubernetes.io/zone=us-east-1a/b/c/d</code>。</p><blockquote class="np nq nr"><p id="cb91" class="ko kp ns kq b kr ks js kt ku kv jv kw nt ky kz la nu lc ld le nv lg lh li lj ik bi translated">注意，<code class="fe lt lu lv lw b">K8sv1.21</code>中有一个 bug，cluster-autoscaler 不能正确响应<code class="fe lt lu lv lw b">topology.kubernetes.io/zone</code>的新标签，你需要使用<code class="fe lt lu lv lw b">failure-domain.beta.kubernetes.io/zone</code>。</p></blockquote><h2 id="8ac6" class="nd ly ir bd lz ne nf dn md ng nh dp mh kx ni nj mj lb nk nl ml lf nm nn mn no bi translated">当无法满足时</h2><p id="3ed1" class="pw-post-body-paragraph ko kp ir kq b kr mp js kt ku mq jv kw kx mr kz la lb ms ld le lf mt lh li lj ik bi translated">这表明如何处理不满足展开限制的 Pod:</p><ul class=""><li id="823d" class="nw nx ir kq b kr ks ku kv kx ny lb nz lf oa lj ob oc od oe bi translated"><strong class="kq is"> DoNotSchedule </strong>(默认)告诉调度程序不要调度它。</li><li id="1441" class="nw nx ir kq b kr of ku og kx oh lb oi lf oj lj ob oc od oe bi translated"><strong class="kq is">schedule anway</strong>告诉调度器仍然对其进行调度，同时对使偏差最小化的节点进行优先级排序。</li></ul><h2 id="5342" class="nd ly ir bd lz ne nf dn md ng nh dp mh kx ni nj mj lb nk nl ml lf nm nn mn no bi translated">标签选择器</h2><p id="9a50" class="pw-post-body-paragraph ko kp ir kq b kr mp js kt ku mq jv kw kx mr kz la lb ms ld le lf mt lh li lj ik bi translated">它用于查找匹配的 pod。对匹配此标签选择器的 pod 进行计数，以确定其对应拓扑域中的 pod 数量。</p><h2 id="d53b" class="nd ly ir bd lz ne nf dn md ng nh dp mh kx ni nj mj lb nk nl ml lf nm nn mn no bi translated">matchLabelKeys</h2><p id="f88b" class="pw-post-body-paragraph ko kp ir kq b kr mp js kt ku mq jv kw kx mr kz la lb ms ld le lf mt lh li lj ik bi translated">这是一个窗格标签键列表，用于选择要计算展开的窗格。这些键用于从 pod 标签中查找值，这些键值标签与<code class="fe lt lu lv lw b">labelSelector</code>进行 and 运算，以选择一组现有的 pod，在该组 pod 上，将为即将到来的 pod 计算分布。pod 标签中不存在的键将被忽略。null 或空列表意味着只匹配标签选择器。</p><p id="1de4" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">有了<code class="fe lt lu lv lw b">matchLabelKeys</code>，用户不需要在不同版本之间更新<code class="fe lt lu lv lw b">pod.spec</code>。控制器/操作员只需要为不同版本的相同标签键设置不同的值。调度程序将根据<code class="fe lt lu lv lw b">matchLabelKeys</code>自动假定这些值。</p><p id="6a27" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">例如，如果用户使用<code class="fe lt lu lv lw b">Deployment</code>，他们可以使用由<code class="fe lt lu lv lw b">Deployment</code>控制器自动添加的以 pod-template-hash 为关键字的标签来区分单个部署中的不同修订。</p><p id="ee16" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">例如:</p><pre class="kg kh ki kj gu mu lw mv bn mw mx bi"><span id="dd00" class="my ly ir lw b be mz na l nb nc">topologySpreadConstraints:<br/>  - maxSkew: 1<br/>    topologyKey: kubernetes.io/hostname<br/>    whenUnsatisfiable: DoNotSchedule<br/>    matchLabelKeys:<br/>      - app<br/>      - pod-template-hash</span></pre><p id="ebff" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">注意，<code class="fe lt lu lv lw b">matchLabelKeys</code>字段是在 1.25 中添加的 alpha 字段。您必须启用 MatchLabelKeysInPodTopologySpread 特征门才能使用它。</p><h2 id="4901" class="nd ly ir bd lz ne nf dn md ng nh dp mh kx ni nj mj lb nk nl ml lf nm nn mn no bi translated">无亲缘关系策略</h2><p id="6e91" class="pw-post-body-paragraph ko kp ir kq b kr mp js kt ku mq jv kw kx mr kz la lb ms ld le lf mt lh li lj ik bi translated">它表明在计算 pod 拓扑分布偏差时，我们将如何处理 Pod 的<code class="fe lt lu lv lw b">nodeAffinity/nodeSelector</code>。有两种选择:</p><ul class=""><li id="7e56" class="nw nx ir kq b kr ks ku kv kx ny lb nz lf oa lj ob oc od oe bi translated"><strong class="kq is"> Honor </strong>:只有与 nodeAffinity/nodeSelector 匹配的节点才包含在计算中。</li><li id="9a82" class="nw nx ir kq b kr of ku og kx oh lb oi lf oj lj ob oc od oe bi translated"><strong class="kq is">忽略</strong>:忽略 nodeAffinity/nodeSelector。所有节点都包括在计算中。<br/>如果该值为空，则该行为等同于荣誉策略。<br/>在 v1.25 中，该字段是一个 alpha 级别字段。</li></ul><h2 id="c285" class="nd ly ir bd lz ne nf dn md ng nh dp mh kx ni nj mj lb nk nl ml lf nm nn mn no bi translated">无污点政策</h2><p id="95cd" class="pw-post-body-paragraph ko kp ir kq b kr mp js kt ku mq jv kw kx mr kz la lb ms ld le lf mt lh li lj ik bi translated">它表明在计算 pod 拓扑分布偏差时，我们将如何处理节点污染。与 nodeAffinityPolicy 类似，有两个选项:</p><ul class=""><li id="faa3" class="nw nx ir kq b kr ks ku kv kx ny lb nz lf oa lj ob oc od oe bi translated"><strong class="kq is">荣誉</strong>:包括没有污点的节点，以及传入的 pod 可以容忍的污点节点。</li><li id="0b95" class="nw nx ir kq b kr of ku og kx oh lb oi lf oj lj ob oc od oe bi translated"><strong class="kq is">忽略</strong>:忽略节点污点。包括所有节点。如果该值为 null，则该行为等同于忽略策略。<br/>在 v1.25 中，该字段是一个 alpha 级别字段。</li></ul><h1 id="825d" class="lx ly ir bd lz ma mb mc md me mf mg mh jx mi jy mj ka mk kb ml kd mm ke mn mo bi translated">Pod 拓扑演示</h1><p id="c2b8" class="pw-post-body-paragraph ko kp ir kq b kr mp js kt ku mq jv kw kx mr kz la lb ms ld le lf mt lh li lj ik bi translated">假设您有一个 4 节点集群，其中 3 个标有 foo: bar 的 pod 分别位于节点 1、节点 2 和节点 3:</p><figure class="kg kh ki kj gu kk gi gj paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gi gj ok"><img src="../Images/bfa01d959ae6f62e7fe936e6f1d49857.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AUSBwAvwRQUKpNjEvW_yQQ.png"/></div></div></figure><p id="f5cd" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">对于第 4 个 pod，如果您想将其安排到 us-east-1b 中的节点 4，可以按如下方式进行配置:</p><pre class="kg kh ki kj gu mu lw mv bn mw mx bi"><span id="0233" class="my ly ir lw b be mz na l nb nc">kind: Pod<br/>apiVersion: v1<br/>metadata:<br/>  name: myapp<br/>  labels:<br/>    foo: bar<br/>spec:<br/>  topologySpreadConstraints:<br/>  - maxSkew: 1<br/>    topologyKey: zone<br/>    whenUnsatisfiable: DoNotSchedule<br/>    labelSelector:<br/>      matchLabels:<br/>        foo: bar<br/>  containers:<br/>  - name: nginx<br/>    image: nginx:1.21.1</span></pre><p id="de6d" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">从上面的例子来看，配置<code class="fe lt lu lv lw b">topologyKey: zone</code>意味着平均分布将只应用于标签为<code class="fe lt lu lv lw b">zone: &lt;any value&gt;</code>的节点，没有<code class="fe lt lu lv lw b">zone</code>标签的节点将被跳过。字段<code class="fe lt lu lv lw b">whenUnsatisfiable: DoNotSchedule</code>告诉调度程序，如果调度程序找不到满足约束的方法，就让进来的 Pod 保持挂起。</p></div></div>    
</body>
</html>