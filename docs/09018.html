<html>
<head>
<title>Python — Best Practices for File Operations</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 文件操作的最佳实践</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/python-best-practices-for-file-operations-a8391f13dbe2?source=collection_archive---------1-----------------------#2022-07-25">https://blog.devgenius.io/python-best-practices-for-file-operations-a8391f13dbe2?source=collection_archive---------1-----------------------#2022-07-25</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><div class=""><h2 id="9582" class="pw-subtitle-paragraph jo iq ir bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated">日常一点 Python 知识！</h2></div><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj kg"><img src="../Images/5fe89d57f63a4d529747f712d550c8cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gA0yNQwCR7d2qh-M"/></div></div><figcaption class="ks kt gk gi gj ku kv bd b be z dk translated">照片由<a class="ae kw" href="https://unsplash.com/@hiteshchoudhary?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Hitesh Choudhary </a>在<a class="ae kw" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="c574" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">作为一名 Python 开发人员，我们每天使用 Python 完成不同的任务。文件操作是最常见的任务之一。使用 Python，您可以轻松地为他人生成漂亮的报告，并且只需几行代码就可以快速解析和组织数万个数据文件。</p><p id="f724" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">当我们编写与文件相关的代码时，我们通常会关注这些事情:我的代码够快吗？我的代码是否事半功倍？在本文中，我将向您推荐一个被低估的 Python 标准库模块，演示读取大文件的最佳方式，最后分享我对函数设计的一些想法。</p><h1 id="e75e" class="lt lu ir bd lv lw lx ly lz ma mb mc md jx me jy mf ka mg kb mh kd mi ke mj mk bi translated">使用 pathlib 模块</h1><p id="bd3f" class="pw-post-body-paragraph kx ky ir kz b la ml js lc ld mm jv lf lg mn li lj lk mo lm ln lo mp lq lr ls ik bi translated">如果你需要用 Python 做文件处理，标准库中的<code class="fe mq mr ms mt b">os</code>和<code class="fe mq mr ms mt b">os.path</code>模块一定是你无法回避的两个模块。在这两个模块中，有很多与文件路径处理、文件读写、文件状态查看相关的工具功能。</p><p id="2b5b" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">让我用一个例子来说明它们是如何使用的。假设一个目录下安装了很多数据文件，但是后缀不统一，那么既有<code class="fe mq mr ms mt b">.csv</code>又有<code class="fe mq mr ms mt b">.txt</code>文件。我们需要把所有的<code class="fe mq mr ms mt b">.txt</code>文件都改成<code class="fe mq mr ms mt b">.csv</code>后缀。</p><p id="ca6e" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">您可以像这样快速编写一个函数:</p><pre class="kh ki kj kk gu mu mt mv mw aw mx bi"><span id="16e6" class="my lu ir mt b gz mz na l nb nc">import os<br/>import os.path<br/><br/><br/>def unify_ext_with_os_path(path):<br/>    for filename in os.listdir(path):<br/>        basename, ext = os.path.splitext(filename)<br/>        if ext == '.txt':<br/>            abs_filepath = os.path.join(path, filename)<br/>            os.rename(abs_filepath, os.path.join(path, f'{basename}.csv'))</span></pre><p id="84c7" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">让我们看看上面的代码中使用了哪些与文件处理相关的函数:</p><ul class=""><li id="27c0" class="nd ne ir kz b la lb ld le lg nf lk ng lo nh ls ni nj nk nl bi translated"><code class="fe mq mr ms mt b">os.listdir(path)</code>:列出路径目录下的所有文件</li><li id="8926" class="nd ne ir kz b la nm ld nn lg no lk np lo nq ls ni nj nk nl bi translated"><code class="fe mq mr ms mt b">os.path.splitext(filename)</code>:分割文件名的基本名和后缀部分</li><li id="d0c0" class="nd ne ir kz b la nm ld nn lg no lk np lo nq ls ni nj nk nl bi translated"><code class="fe mq mr ms mt b">os.path.join(path, filename)</code>:需要操作的组合文件名是绝对路径</li><li id="6eeb" class="nd ne ir kz b la nm ld nn lg no lk np lo nq ls ni nj nk nl bi translated"><code class="fe mq mr ms mt b">os.rename(...)</code>:重命名文件</li></ul><p id="fece" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">虽然上面的函数可以完成需求，但是说实话，即使写了很多年的 Python 代码，我还是觉得这些函数不仅难记，而且最终的产品代码也不是很讨喜。</p><h2 id="844d" class="my lu ir bd lv nr ns dn lz nt nu dp md lg nv nw mf lk nx ny mh lo nz oa mj ob bi translated">使用 pathlib 模块</h2><p id="25f5" class="pw-post-body-paragraph kx ky ir kz b la ml js lc ld mm jv lf lg mn li lj lk mo lm ln lo mp lq lr ls ik bi translated">为了使文件处理更容易，Python 在 3.4 版本中引入了一个新的标准库模块:<code class="fe mq mr ms mt b"><a class="ae kw" href="https://docs.python.org/3/library/pathlib.html" rel="noopener ugc nofollow" target="_blank">pathlib</a></code>。它基于面向对象的思想设计，封装了大量与文件操作相关的功能。如果用它重写上面的代码，结果会大不一样。</p><p id="999c" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">使用<code class="fe mq mr ms mt b">pathlib</code>模块后的代码:</p><pre class="kh ki kj kk gu mu mt mv mw aw mx bi"><span id="77cc" class="my lu ir mt b gz mz na l nb nc">from pathlib import Path<br/><br/>def unify_ext_with_pathlib(path):<br/>    for fpath in Path(path).glob('*.txt'):<br/>        fpath.rename(fpath.with_suffix('.csv'))</span></pre><p id="e59d" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">与旧代码相比，新功能只需要两行代码就可以完成工作。这两行代码主要做以下事情:</p><ol class=""><li id="b284" class="nd ne ir kz b la lb ld le lg nf lk ng lo nh ls oc nj nk nl bi translated">首先使用<code class="fe mq mr ms mt b">Path(path)</code>将字符串路径转换成一个对象</li><li id="85f7" class="nd ne ir kz b la nm ld nn lg no lk np lo nq ls oc nj nk nl bi translated">调用<code class="fe mq mr ms mt b">.glob(‘*.txt’)</code>对路径下的所有东西进行模式匹配，并将其作为生成器返回，结果仍然是一个<code class="fe mq mr ms mt b">Path</code>对象，所以我们可以继续做下面的操作</li><li id="86dc" class="nd ne ir kz b la nm ld nn lg no lk np lo nq ls oc nj nk nl bi translated">使用<code class="fe mq mr ms mt b">.with_suffix(‘.csv’)</code>直接获取带有新后缀的文件的完整路径</li><li id="d7c2" class="nd ne ir kz b la nm ld nn lg no lk np lo nq ls oc nj nk nl bi translated">呼叫<code class="fe mq mr ms mt b">.rename(target)</code></li></ol><p id="e01d" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">与<code class="fe mq mr ms mt b">os</code>和<code class="fe mq mr ms mt b">os.path</code>相比，<code class="fe mq mr ms mt b">pathlib</code>模块引入后的代码明显更简单，整体感更强。所有与文件相关的操作都是一站式完成的。</p><p id="8bc7" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">除此之外，<code class="fe mq mr ms mt b">pathlib</code>模块还提供了许多有趣的用途。例如，使用<code class="fe mq mr ms mt b">/</code>操作符来组合文件路径:</p><pre class="kh ki kj kk gu mu mt mv mw aw mx bi"><span id="41d7" class="my lu ir mt b gz mz na l nb nc">&gt;&gt;&gt; import os.path<br/>&gt;&gt;&gt; os.path.join('/tmp', 'foo.txt')<br/>'/tmp/foo.txt'<br/><br/>&gt;&gt;&gt; from pathlib import Path<br/>&gt;&gt;&gt; Path('/tmp') / 'foo.txt'<br/>PosixPath('/tmp/foo.txt')</span></pre><p id="19da" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">或者使用<code class="fe mq mr ms mt b">.read_text()</code>快速读取文件内容:</p><pre class="kh ki kj kk gu mu mt mv mw aw mx bi"><span id="26e1" class="my lu ir mt b gz mz na l nb nc">&gt;&gt;&gt; with open('foo.txt') as file:<br/>...     print(file.read())<br/>...<br/>foo<br/><br/><br/>&gt;&gt;&gt; from pathlib import Path<br/>&gt;&gt;&gt; print(Path('foo.txt').read_text())<br/>foo</span></pre><p id="e0e5" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><a class="ae kw" href="https://www.python.org/dev/peps/pep-0519/" rel="noopener ugc nofollow" target="_blank"> PEP-519 </a>专门为“文件路径”定义了一个新的对象协议，这意味着从 PEP 生效时起，从 Python 3.6 开始，<code class="fe mq mr ms mt b">pathlib</code>中的路径对象可以与大多数只接受字符串路径的标准库函数兼容使用:</p><pre class="kh ki kj kk gu mu mt mv mw aw mx bi"><span id="9634" class="my lu ir mt b gz mz na l nb nc">&gt;&gt;&gt; p = Path('/tmp')<br/>&gt;&gt;&gt; os.path.join(p, 'foo.txt')<br/>'/tmp/foo.txt'</span></pre><h1 id="17bf" class="lt lu ir bd lv lw lx ly lz ma mb mc md jx me jy mf ka mg kb mh kd mi ke mj mk bi translated">流式传输大文件</h1><p id="72cb" class="pw-post-body-paragraph kx ky ir kz b la ml js lc ld mm jv lf lg mn li lj lk mo lm ln lo mp lq lr ls ik bi translated">几乎所有人都知道 Python 中有一个读取文件的“标准做法”:首先使用一个<code class="fe mq mr ms mt b">with open(fine_name)</code>上下文管理器获取一个 file 对象，然后<code class="fe mq mr ms mt b">for</code>用一个循环迭代它，逐行获取文件的内容。例如:</p><pre class="kh ki kj kk gu mu mt mv mw aw mx bi"><span id="bf91" class="my lu ir mt b gz mz na l nb nc">def count_nine(fname):<br/>    count = 0<br/>    with open(fname) as file:<br/>        for line in file:<br/>            count += line.count('9')<br/>    return count</span></pre><p id="eadf" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">为什么这种读取文件的方式会成为标准？这是因为它有两个好处:</p><ol class=""><li id="749f" class="nd ne ir kz b la lb ld le lg nf lk ng lo nh ls oc nj nk nl bi translated"><code class="fe mq mr ms mt b">with</code>:上下文管理器自动关闭打开的文件描述符</li><li id="cab1" class="nd ne ir kz b la nm ld nn lg no lk np lo nq ls oc nj nk nl bi translated">当迭代 file 对象时，内容是逐行返回的，不会占用太多内存</li></ol><p id="8007" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">但是这种标准做法也不是没有缺点。<strong class="kz is">如果正在读取的文件根本不包含任何换行符，那么上面的第二个好处就不成立</strong>。当代码被<code class="fe mq mr ms mt b">for line in file</code>执行时，line 会变成一个非常大的 string 对象，消耗非常可观的内存量。</p><h2 id="94c9" class="my lu ir bd lv nr ns dn lz nt nu dp md lg nv nw mf lk nx ny mh lo nz oa mj ob bi translated"><strong class="ak">成块读取</strong></h2><p id="b9b4" class="pw-post-body-paragraph kx ky ir kz b la ml js lc ld mm jv lf lg mn li lj lk mo lm ln lo mp lq lr ls ik bi translated">为了解决这个问题，我们需要暂时把这个“标准实践”放在一边，使用一个更低级的<code class="fe mq mr ms mt b">file.read()</code>方法。每个调用<code class="fe mq mr ms mt b">file.read(chunk_size)</code>将直接返回从当前位置读取的大小的<code class="fe mq mr ms mt b">chunk_size</code>文件内容，而不是在一个循环中迭代文件对象，而不需要等待任何换行符出现。</p><p id="b902" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">因此，新的代码片段将如下所示:</p><pre class="kh ki kj kk gu mu mt mv mw aw mx bi"><span id="d534" class="my lu ir mt b gz mz na l nb nc">def count_nine_v2(fname):<br/>    """Count total 9s，read 8kb each time<br/>    """<br/>    count = 0<br/>    block_size = 1024 * 8<br/>    with open(fname) as fp:<br/>        while True:<br/>            chunk = fp.read(block_size)<br/>            # If no more content<br/>            if not chunk:<br/>                break<br/>            count += chunk.count('9')<br/>    return count</span></pre><p id="0a4d" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">在新函数中，我们使用了一个<code class="fe mq mr ms mt b">while</code>循环来读取文件的内容，每次读取的最大大小为 8kb，这样可以避免之前拼接一个巨大字符串的过程，并且减少了很多内存的使用。</p><h2 id="d345" class="my lu ir bd lv nr ns dn lz nt nu dp md lg nv nw mf lk nx ny mh lo nz oa mj ob bi translated">将代码与发电机解耦</h2><p id="975c" class="pw-post-body-paragraph kx ky ir kz b la ml js lc ld mm jv lf lg mn li lj lk mo lm ln lo mp lq lr ls ik bi translated">假设我们说的不是 Python，而是其他编程语言。那么可以说上面的代码已经不错了。但如果分析一下<code class="fe mq mr ms mt b">count_nine_v2</code>函数，会发现循环体内部有两个独立的逻辑:数据生成(读调用和组块判断)和数据消耗。而这两个独立的逻辑是耦合在一起的。</p><p id="3191" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">为了提高复用性，我们可以定义一个新的<code class="fe mq mr ms mt b">chunked_file_reader</code>生成器函数，负责所有与“数据生成”相关的逻辑。这样里面的主循环<code class="fe mq mr ms mt b">count_nine_v3</code>只需要负责计数。</p><pre class="kh ki kj kk gu mu mt mv mw aw mx bi"><span id="0a67" class="my lu ir mt b gz mz na l nb nc">def chunked_file_reader(fp, block_size=1024 * 8):<br/>    """generator：Read file in chunks<br/>    """<br/>    while True:<br/>        chunk = fp.read(block_size)<br/>        # If no more content<br/>        if not chunk:<br/>            break<br/>        yield chunk<br/><br/><br/>def count_nine_v3(fname):<br/>    count = 0<br/>    with open(fname) as fp:<br/>        for chunk in chunked_file_reader(fp):<br/>            count += chunk.count('9')<br/>    return count</span></pre><p id="7d51" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">在这一点上，代码似乎没有优化的余地，但事实并非如此。<code class="fe mq mr ms mt b">iter(iterable)</code>是一个用于构造迭代器的内置函数，但它还有一个鲜为人知的用法。</p><p id="65cb" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">当我们用<code class="fe mq mr ms mt b">iter(callable, sentinel)</code>方法调用它时，它会返回一个特殊的对象，它会继续生成可调用对象 callable 的可调用结果，直到结果为 sentinel，迭代终止。</p><pre class="kh ki kj kk gu mu mt mv mw aw mx bi"><span id="c6ff" class="my lu ir mt b gz mz na l nb nc">def chunked_file_reader(file, block_size=1024 * 8):<br/>    """Generator：Use iter to read file in chunks<br/>    """<br/>    # Use partial(fp.read, block_size) to construct a new func<br/>    # Read and return fp.read(block_size) until ''<br/>    for chunk in iter(partial(file.read, block_size), ''):<br/>        yield chunk</span></pre><p id="173f" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">最后，只用两行代码，我们就完成了一个可重用的分块文件读取功能。</p><h1 id="9290" class="lt lu ir bd lv lw lx ly lz ma mb mc md jx me jy mf ka mg kb mh kd mi ke mj mk bi translated">文件对象的设计</h1><p id="1fdc" class="pw-post-body-paragraph kx ky ir kz b la ml js lc ld mm jv lf lg mn li lj lk mo lm ln lo mp lq lr ls ik bi translated">假设我们要统计每个文件中出现了多少个英文元音(aeiou)。只需对之前的代码做一些调整，新的函数就可以立刻编写出来<code class="fe mq mr ms mt b">count_vowels</code>。</p><pre class="kh ki kj kk gu mu mt mv mw aw mx bi"><span id="a749" class="my lu ir mt b gz mz na l nb nc">def count_vowels(filename):<br/>    """count (aeiou)s<br/>    """<br/>    VOWELS_LETTERS = {'a', 'e', 'i', 'o', 'u'}<br/>    count = 0<br/>    with open(filename, 'r') as fp:<br/>        for line in fp:<br/>            for char in line:<br/>                if char.lower() in VOWELS_LETTERS:<br/>                    count += 1<br/>    return count<br/><br/><br/># OUTPUT: 16<br/>print(count_vowels('sample_file.txt'))</span></pre><p id="aef8" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">为了保证程序的正确性，我们需要为它编写一些单元测试。但是当我准备写一个测试的时候，发现很麻烦。主要问题如下:</p><ol class=""><li id="9cc6" class="nd ne ir kz b la lb ld le lg nf lk ng lo nh ls oc nj nk nl bi translated">该函数接受文件路径作为参数，所以我们需要传递一个实际的文件</li><li id="fe40" class="nd ne ir kz b la nm ld nn lg no lk np lo nq ls oc nj nk nl bi translated">为了准备测试用例，我们需要提供一些样板文件或者编写一些临时文件</li><li id="19c1" class="nd ne ir kz b la nm ld nn lg no lk np lo nq ls oc nj nk nl bi translated">文件能否正常打开和读取已经成为我们需要测试的一个边界条件</li></ol><p id="9368" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><strong class="kz is">一般来说，如果你发现你的功能难以编写单元测试，那通常意味着你应该改进它的设计。</strong>以上功能应该如何改进？答案是:<em class="od">让函数依赖于“文件对象”而不是文件路径</em>。</p><p id="7987" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">让我们来试试:</p><pre class="kh ki kj kk gu mu mt mv mw aw mx bi"><span id="51f7" class="my lu ir mt b gz mz na l nb nc">def count_vowels_v2(fp):<br/>    """Count (aeiou)s<br/>    """<br/>    VOWELS_LETTERS = {'a', 'e', 'i', 'o', 'u'}<br/>    count = 0<br/>    for line in fp:<br/>        for char in line:<br/>            if char.lower() in VOWELS_LETTERS:<br/>                count += 1<br/>    return count<br/><br/><br/>with open('small_file.txt') as fp:<br/>    print(count_vowels_v2(fp))</span></pre><p id="ca2d" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">主要变化是提高了函数的适用性。因为 Python 是“鸭式”的，虽然函数需要接受一个 file 对象，但我们实际上可以将任何实现 file 协议的“类文件对象”传入<code class="fe mq mr ms mt b">count_vowels_v2</code>函数。</p><p id="17a9" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">而 Python 有很多“类文件对象”。例如，<code class="fe mq mr ms mt b">io</code>模块中的 StringIO 对象就是其中之一。它是一个特殊的基于内存的对象，与文件对象具有几乎相同的接口设计。</p><p id="63c0" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">使用 StringIO，我们可以非常方便地为函数编写单元测试。</p><pre class="kh ki kj kk gu mu mt mv mw aw mx bi"><span id="3f1d" class="my lu ir mt b gz mz na l nb nc">import pytest<br/>from io import StringIO<br/><br/><br/>@pytest.mark.parametrize(<br/>    "content,vowels_count", [<br/>        # Define test cases<br/>        # (content, expected_output)<br/>        ('', 0),<br/>        ('Hello World!', 3),<br/>        ('HELLO WORLD!', 3),<br/>        ('你好，世界', 0),<br/>    ]<br/>)<br/>def test_count_vowels_v2(content, vowels_count):<br/>    # Use StringIO to construct "file"<br/>    file = StringIO(content)<br/>    assert count_vowels_v2(file) == vowels_count</span></pre><p id="31b5" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">将函数参数改为“文件对象”的最大好处是提高了函数的适用性和可组合性。</p><p id="4db6" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">通过依赖更抽象的“类似文件的对象”而不是文件路径，它为如何使用函数提供了更多的可能性。StringIO、PIPE 和任何其他满足协议的对象都可以是函数的客户端。</p><h1 id="d603" class="lt lu ir bd lv lw lx ly lz ma mb mc md jx me jy mf ka mg kb mh kd mi ke mj mk bi translated">结论</h1><p id="3294" class="pw-post-body-paragraph kx ky ir kz b la ml js lc ld mm jv lf lg mn li lj lk mo lm ln lo mp lq lr ls ik bi translated">文件操作是我们日常工作中经常需要接触的领域。使用更方便的模块，使用生成器节省内存，编写更适用的函数，可以让我们写出更高效的代码。</p></div></div>    
</body>
</html>