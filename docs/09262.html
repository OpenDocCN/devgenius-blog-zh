<html>
<head>
<title>Object Mapping advanced features &amp; QoL with Kotlin</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kotlin 的对象映射高级功能和 QoL</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/object-mapping-advanced-features-qol-with-kotlin-c8ea8d9ebf20?source=collection_archive---------4-----------------------#2022-08-10">https://blog.devgenius.io/object-mapping-advanced-features-qol-with-kotlin-c8ea8d9ebf20?source=collection_archive---------4-----------------------#2022-08-10</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/c1d06d5cafaf0a32f2bdcc06d5661066.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pPWyKLTCSiwA2tQU"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">由<a class="ae jz" href="https://unsplash.com/@linkhoang?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Link Hoang </a>在<a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><p id="0caa" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当使用多层应用程序、外部库、遗留代码库或外部 API 时，我们经常需要在不同的对象或数据结构之间进行映射。</p><p id="39c4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在本教程中，我们将检查一些对象映射库的高级功能，以简化这项任务，同时节省开发和维护时间。</p><p id="81c4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在我们的例子中，我们将使用库<a class="ae jz" href="https://github.com/krud-dev/shapeshift/" rel="noopener ugc nofollow" target="_blank"> ShapeShift </a>。这是一个用于 Kotlin/Java 的轻量级对象映射库，有很多很酷的特性。</p><h1 id="2bd2" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">自动映射</h1><p id="8cd6" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">我们将轰轰烈烈地开始。自动映射能够并且将会为您节省大量时间和模板代码。一些应用程序需要对象之间的手动映射，但是大多数应用程序通过使用这一特性将节省大量的时间。更好的是，有了 ShapeShift 的默认转换器，我们甚至可以在不同的数据类型之间使用自动映射。</p><h1 id="93e3" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">简单映像</h1><p id="418f" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">让我们从一个简单的自动映射例子开始。我们有两个对象，想象它们也可能有几十个、几百个、甚至几千个字段(对于这里的疯狂的人来说)。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="3820" class="mk kz in mg b gy ml mm l mn mo">class User {<br/>    var id: String = ""<br/>    var name: String? = null<br/>    var email: String? = null<br/>    var phone: String? = null<br/>}</span><span id="7fba" class="mk kz in mg b gy mp mm l mn mo">class UserDTO {<br/>    var id: String = ""<br/>    var name: String? = null<br/>    var email: String? = null<br/>    var phone: String? = null<br/>}</span></pre><p id="ee72" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们想要映射从<code class="fe mq mr ms mg b">User</code>到<code class="fe mq mr ms mg b">UserDTO</code>的所有字段。使用自动映射，我们不需要写任何锅炉板代码。映射器将定义如下:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="c70f" class="mk kz in mg b gy ml mm l mn mo">val mapper = mapper&lt;User, UserDTO&gt; {<br/>    autoMap(AutoMappingStrategy.BY_NAME_AND_TYPE)<br/>}</span></pre><p id="f034" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">瞧啊。所有字段将自动映射，无需任何手动锅炉板代码。</p><h1 id="5e0a" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">高级映射</h1><p id="4d55" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">在这个例子中，我们将使用<a class="ae jz" href="https://shapeshift.krud.dev/api-documentation/transformers#default-transformers" rel="noopener ugc nofollow" target="_blank">默认变压器</a>的功率来进一步进行自动映射。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="ad45" class="mk kz in mg b gy ml mm l mn mo">class User {<br/>    var id: String = ""<br/>    var name: String? = null<br/>    var birthDate: Date? = null<br/>}</span><span id="df09" class="mk kz in mg b gy mp mm l mn mo">class UserDTO {<br/>    var id: String = ""<br/>    var fullName: String? = null<br/>    var birthDate: Long? = null<br/>}</span></pre><p id="c64a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">注意，在源类和目的类中,<code class="fe mq mr ms mg b">birthDate</code>字段的类型是不同的。但是使用默认变压器的能力，我们仍然可以在这里使用自动映射。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="4727" class="mk kz in mg b gy ml mm l mn mo">val mapper = mapper&lt;User, UserDTO&gt; {<br/>    autoMap(AutoMappingStrategy.BY_NAME)<br/>}</span></pre><p id="372b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们将自动映射策略改为<code class="fe mq mr ms mg b">BY_NAME</code>,这样它也可以映射不同类型的字段。现在我们需要向<code class="fe mq mr ms mg b">ShapeShift</code>实例注册一个默认的转换器，以便它知道如何将<code class="fe mq mr ms mg b">Date</code>转换为<code class="fe mq mr ms mg b">Long</code>。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="8637" class="mk kz in mg b gy ml mm l mn mo">val shapeShift = ShapeShiftBuilder()<br/>    .withTransformer(DateToLongMappingTransformer(), true)<br/>    .build()</span></pre><p id="ce2e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们还可以在自动映射的基础上添加手动映射，以便添加/更改行为。源类和目的类对于<code class="fe mq mr ms mg b">name</code>字段有不同的名称，所以我们将为它添加手动映射。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="3d40" class="mk kz in mg b gy ml mm l mn mo">val mapper = mapper&lt;User, UserDTO&gt; {<br/>    autoMap(AutoMappingStrategy.BY_NAME)<br/>    User::name mappedTo UserDTO::fullName<br/>}</span></pre><p id="e521" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">自动映射非常适合不需要特定映射的用例。它有助于减少配置映射所需的手动模板代码的数量，也有助于保持头脑清醒。</p><h1 id="3d48" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">变形金刚(电影名)</h1><p id="76fd" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">转换器是非常有用的功能，它允许您在映射字段时将字段的类型/值转换为不同的类型/值。</p><p id="3a79" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们广泛使用的一些使用案例:</p><ul class=""><li id="a248" class="mt mu in kc b kd ke kh ki kl mv kp mw kt mx kx my mz na nb bi translated">在服务器和客户端对象之间将日期转换为长整型，反之亦然。</li><li id="47a9" class="mt mu in kc b kd nc kh nd kl ne kp nf kt ng kx my mz na nb bi translated">将 JSON 字符串转换成它的实际类型，反之亦然。</li><li id="8168" class="mt mu in kc b kd nc kh nd kl ne kp nf kt ng kx my mz na nb bi translated">将逗号分隔的字符串转换为枚举列表。</li><li id="d140" class="mt mu in kc b kd nc kh nd kl ne kp nf kt ng kx my mz na nb bi translated">使用 Spring transformers 将另一个对象 id 从 DB 转换为它的对象或它的一个字段。</li></ul><h1 id="a123" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">基本变压器</h1><p id="7d77" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">我们将从一个简单的变压器例子开始。迄今为止和迄今为止的变压器:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="64ee" class="mk kz in mg b gy ml mm l mn mo">class DateToLongMappingTransformer : MappingTransformer&lt;Date, Long&gt; {<br/>    override fun transform(context: MappingTransformerContext&lt;out Date&gt;): Long? {<br/>        return context.originalValue?.time<br/>    }<br/>}</span><span id="6ab1" class="mk kz in mg b gy mp mm l mn mo">class LongToDateMappingTransformer : MappingTransformer&lt;Long, Date&gt; {<br/>    override fun transform(context: MappingTransformerContext&lt;out Long&gt;): Date? {<br/>        context.originalValue ?: return null<br/>        return Date(context.originalValue)<br/>    }<br/>}</span></pre><p id="5ef7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们现在需要做的就是<a class="ae jz" href="https://shapeshift.krud.dev/api-documentation/transformers#registering-transformers" rel="noopener ugc nofollow" target="_blank">注册</a>他们。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="56ca" class="mk kz in mg b gy ml mm l mn mo">val shapeShift = ShapeShiftBuilder()<br/>    .withTransformer(DateToLongMappingTransformer(), true) // "true" is optional, we are registering the transformers as default transformers, more on that later.<br/>    .withTransformer(LongToDateMappingTransformer(), true)<br/>    .build()</span></pre><p id="2d4d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">就是这样！我们现在可以在映射物体时使用变形金刚了。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="468c" class="mk kz in mg b gy ml mm l mn mo">class User {<br/>    var id: String = ""<br/>    var name: String? = null<br/>    var birthDate: Date? = null<br/>}</span><span id="20fb" class="mk kz in mg b gy mp mm l mn mo">class UserDTO {<br/>    var id: String = ""<br/>    var name: String? = null<br/>    var birthDate: Long? = null<br/>}</span><span id="2e57" class="mk kz in mg b gy mp mm l mn mo">val mapper = mapper&lt;User, UserDTO&gt; {<br/>    User::id mappedTo UserDTO::id<br/>    User::name mappedTo UserDTO::name<br/>    User::birthDate mappedTo UserDTO::birthDate withTransformer DateToLongMappingTransformer::class // We don't have to state the transformer here because it is a default transformer<br/>}</span></pre><h1 id="1eed" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">直列变压器</h1><p id="1844" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">在某些用例中，我们希望转换值，但是我们不需要可重用的转换器，我们也不想创建一个一次性使用的类。</p><p id="0d91" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">救援用直列式变压器！内联转换器允许转换值，而无需创建和注册转换器。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="63f0" class="mk kz in mg b gy ml mm l mn mo">val shapeShift = ShapeShiftBuilder()<br/>        .withMapping&lt;Source, Target&gt; {<br/>            // Map birthDate to birthYear with a transformation function<br/>            Source::birthDate mappedTo Target::birthYear withTransformer { (originalValue) -&gt;<br/>                originalValue?.year<br/>            }<br/>        }<br/>        .build()</span></pre><h1 id="4e05" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">高级变压器</h1><p id="3a82" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">转换器还允许我们对数据库或其他数据源进行转换。</p><p id="9eec" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这个例子中，我们将使用<a class="ae jz" href="https://shapeshift.krud.dev/guides/spring-usage" rel="noopener ugc nofollow" target="_blank"> Spring Boot 集成</a>的能力来创建带 DB 访问的变压器。</p><p id="f161" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们有三种型号:</p><ul class=""><li id="659b" class="mt mu in kc b kd ke kh ki kl mv kp mw kt mx kx my mz na nb bi translated">作业—数据库实体。</li><li id="a3dc" class="mt mu in kc b kd nc kh nd kl ne kp nf kt ng kx my mz na nb bi translated">用户—数据库实体。</li><li id="1478" class="mt mu in kc b kd nc kh nd kl ne kp nf kt ng kx my mz na nb bi translated">UserDTO —客户端模型。</li></ul><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="6f69" class="mk kz in mg b gy ml mm l mn mo">class Job {<br/>    var id: String = ""<br/>    var name: String = ""<br/>}</span><span id="8071" class="mk kz in mg b gy mp mm l mn mo">class User {<br/>    var id: String = ""<br/>    var jobId: String? = null<br/>}</span><span id="01c3" class="mk kz in mg b gy mp mm l mn mo">class UserDTO {<br/>    var id: String = ""<br/>    var jobName: String? = null<br/>}</span></pre><p id="69de" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们希望通过从数据库中查询作业并将其设置在 DTO 上，将<code class="fe mq mr ms mg b">User</code>上的<code class="fe mq mr ms mg b">jobId</code>转换为<code class="fe mq mr ms mg b">UserDTO</code>上的<code class="fe mq mr ms mg b">jobName</code>。</p><p id="7a82" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在 Spring 的例子中，通常避免静态函数或域对象上的函数与应用程序上下文交互。</p><p id="8f9f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们将使用 ShapeShift 的<a class="ae jz" href="https://shapeshift.krud.dev/guides/spring-usage" rel="noopener ugc nofollow" target="_blank"> Spring integration </a>来创建一个组件，作为访问我们的 DAO bean 的转换器。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="ee3c" class="mk kz in mg b gy ml mm l mn mo">@Component<br/>class JobIdToNameTransformer(<br/>    private val jobDao: JobDao<br/>) : MappingTransformer&lt;String, String&gt;() {<br/>    override fun transform(context: MappingTransformerContext&lt;out String&gt;): String? {<br/>        context.originalValue ?: return null<br/>        val job = jobDao.findJobById(context.originalValue!!)<br/>        return job.name <br/>    }<br/>}</span></pre><p id="aef5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">剩下要做的就是在我们的映射中使用这个转换器。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="1211" class="mk kz in mg b gy ml mm l mn mo">val mapper = mapper&lt;User, UserDTO&gt; {<br/>    User::id mappedTo UserDTO::id<br/>    User::jobId mappedTo UserDTO::jobName withTransformer JobIdToNameTransformer::class<br/>}</span></pre><p id="c524" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">使用变压器的另一个好处是它们的可重用性。在某些用例中，我们可以创建更多的通用转换器，这些转换器将具有广泛的应用。</p><h1 id="1540" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">默认变压器</h1><p id="ec96" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">注册变压器时，您可以指明变压器是否为<a class="ae jz" href="https://shapeshift.krud.dev/api-documentation/transformers#default-transformers" rel="noopener ugc nofollow" target="_blank">默认变压器</a>。当您将类型为&lt; A &gt;的字段映射到类型为&lt; B &gt;的字段而没有指定要使用的转换器时，将使用默认的类型为&lt; A、B &gt;的转换器。</p><p id="bad3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">正如我们已经看到的，默认转换器对于循环转换非常有用，尤其是对于自动映射。</p><h1 id="c0f0" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">深度映射</h1><p id="bd81" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">如果我们想在一个对象的字段中映射出/映射出可用的字段呢？我们甚至可以轻松做到这一点。</p><p id="ce54" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了访问子类，我们可以使用<code class="fe mq mr ms mg b">..</code>操作符。让我们看看下面的例子。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="93eb" class="mk kz in mg b gy ml mm l mn mo">class From {<br/>    var child: Child = Child()</span><span id="df6d" class="mk kz in mg b gy mp mm l mn mo">    class Child {<br/>        var value: String?<br/>    }<br/>}</span><span id="2237" class="mk kz in mg b gy mp mm l mn mo">class To {<br/>    var childValue: String?<br/>}</span></pre><p id="911b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们希望将<code class="fe mq mr ms mg b">From</code>类中的<code class="fe mq mr ms mg b">Child</code>类中的<code class="fe mq mr ms mg b">value</code>字段映射到<code class="fe mq mr ms mg b">To</code>类中的<code class="fe mq mr ms mg b">childValue</code>字段。我们将使用<code class="fe mq mr ms mg b">..</code>操作符创建一个映射器。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="4071" class="mk kz in mg b gy ml mm l mn mo">val mapper = mapper&lt;From, To&gt; {<br/>    From::child..From.Child::value mappedTo To::childValue<br/>}</span></pre><p id="9561" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们更进一步，多层次的深度。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="9518" class="mk kz in mg b gy ml mm l mn mo">class From {<br/>    var grandChildValue: String?<br/>}</span><span id="0b4a" class="mk kz in mg b gy mp mm l mn mo">class To {<br/>    var child: Child = Child()</span><span id="2078" class="mk kz in mg b gy mp mm l mn mo">    class Child {<br/>        var grandChild: GrandChild = GrandChild()<br/>    }</span><span id="21d3" class="mk kz in mg b gy mp mm l mn mo">    class GrandChild {<br/>        var value: String?<br/>    }<br/>}</span></pre><p id="4e34" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">要访问 grand child 字段，我们只需使用两次<code class="fe mq mr ms mg b">..</code>操作符。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="28c9" class="mk kz in mg b gy ml mm l mn mo">val mapper = mapper&lt;From, To&gt; {<br/>    From::grandChildValue mappedTo To::child..To.Child::grandChild..To.GrandChild::value<br/>}</span></pre><h1 id="af41" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">条件映射</h1><p id="7d8c" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">条件允许我们向特定的字段映射添加一个谓词，以确定是否应该映射这个字段。</p><p id="658d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">使用这个特性就像创建一个条件一样简单。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="8ac2" class="mk kz in mg b gy ml mm l mn mo">class NotBlankStringCondition : MappingCondition&lt;String&gt; {<br/>    override fun isValid(context: MappingConditionContext&lt;String&gt;): Boolean {<br/>        return !context.originalValue.isNullOrBlank()<br/>    }<br/>}</span></pre><p id="f54b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">并将该条件添加到所需的字段映射中。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="b16f" class="mk kz in mg b gy ml mm l mn mo">data class SimpleEntity(<br/>    val name: String<br/>)</span><span id="3c5a" class="mk kz in mg b gy mp mm l mn mo">data class SimpleEntityDisplay(<br/>    val name: String = ""<br/>)</span><span id="d82d" class="mk kz in mg b gy mp mm l mn mo">val mapper = mapper&lt;SimpleEntity, SimpleEntityDisplay&gt; {<br/>    SimpleEntity::name mappedTo SimpleEntityDisplay::name withCondition NotBlankStringCondition::class<br/>}</span></pre><h1 id="63a3" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">内嵌条件</h1><p id="2cbc" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">像变压器一样，条件也可以使用函数内联添加。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="dd46" class="mk kz in mg b gy ml mm l mn mo">val mapper = mapper&lt;SimpleEntity, SimpleEntityDisplay&gt; {<br/>    SimpleEntity::name mappedTo SimpleEntityDisplay::name withCondition {<br/>        !it.originalValue.isNullOrBlank()<br/>    }<br/>}</span></pre><h1 id="3a22" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">注释映射</h1><p id="5ed8" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">这个特性受到了很多人的讨厌，因为它违反了关注点分离的原则。我同意，这在某些应用程序中可能是一个问题，但是在某些用例中，所有对象都是同一个应用程序的一部分，在对象之上配置映射逻辑也非常有用。查看<a class="ae jz" href="https://shapeshift.krud.dev/api-documentation/annotations" rel="noopener ugc nofollow" target="_blank">文档</a>并自行决定。</p><h1 id="101d" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">结论</h1><p id="0d5e" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">对象映射库并不是每个应用程序的解决方案。对于小而简单的应用程序，使用锅炉板映射功能就足够了。但是，在开发更大、更复杂的应用程序时，对象映射库可以让您的代码更上一层楼，节省您的开发和维护时间。所有这些都减少了 boiler-plate 代码的数量，并从整体上改善了开发体验。</p><p id="9315" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">就我个人而言，我曾经使用过手动映射功能，并对此感到满意。它“只是”一些简单的代码行。在升级我们的应用程序以使用对象映射作为我们的“无模板”框架的一部分(我们将在稍后讨论该框架)之后，我不能回头了。现在我们把更多的时间花在重要和有趣的事情上，几乎没有时间花在无聊的锅炉板代码上。</p></div></div>    
</body>
</html>