<html>
<head>
<title>Property Wrappers in SwiftUI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SwiftUI中的属性包装器</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/property-wrappers-in-swiftui-a1f86499bed5?source=collection_archive---------3-----------------------#2021-07-04">https://blog.devgenius.io/property-wrappers-in-swiftui-a1f86499bed5?source=collection_archive---------3-----------------------#2021-07-04</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/0afe6e2b6d1cb003dc59d9058e0033c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NpwZB1ZcLxyEymfKnJzlsg.png"/></div></div></figure><p id="8954" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">变量行为通过属性包装得到增强。@ State、@ Binding、@ ObservedObject和@ EnvironmentObject是特定于SwiftUI的包装器，表示视图对变量所代表的数据的依赖。</p><h1 id="715a" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">@州</h1><figure class="ls lt lu lv gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lr"><img src="../Images/df54d8b854dd22f4c1dc77216f01e19b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V_LilFBdFOY2r-SuWBqIuw.png"/></div></div></figure><p id="3aa0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">@State是一个合理的术语，表示允许您自动监视和读取本地视图中的持久值的特性。每个@State都是一个框架管理的给定值的永久真值源。在声明视图时，具有预期生存期范围的简单值类型是理想的选择。</p><p id="d3ab" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您可以使用美元符号访问绑定变量的状态。$name</p><h1 id="9b54" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">@绑定</h1><p id="d148" class="pw-post-body-paragraph jv jw in jx b jy lw ka kb kc lx ke kf kg ly ki kj kk lz km kn ko ma kq kr ks ig bi translated">这是对另一个视图值类型的引用。如果你在本地改变绑定，它也会改变它的引用。这个包装器不拥有它的数据。</p><h1 id="4792" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">@环境</h1><p id="657e" class="pw-post-body-paragraph jv jw in jx b jy lw ka kb kc lx ke kf kg ly ki kj kk lz km kn ko ma kq kr ks ig bi translated">如果你想从系统中读取数据(配色方案，可访问性选项等)，你也可以创建自己的密钥。它不拥有自己的数据。</p><h1 id="c8f8" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated"><strong class="ak">@环境对象</strong></h1><figure class="ls lt lu lv gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mb"><img src="../Images/719d4f8ae881977c66ea45d3d14d24dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5ZHr7iJFVL26e3JtOfzuQw.png"/></div></div></figure><p id="bd02" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">@EnvironmentObject跨多个视图在应用程序中保持对象的持久性。它就像静态的，但是你用@EnvironmentObject标签来访问。当你用@EnvironmentObject声明一个对象时，你说你的应用程序允许一个内存地址，并允许所有视图访问它。</p><p id="987e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您可以通过以下方式访问环境对象</p><pre class="ls lt lu lv gt mc md me mf aw mg bi"><span id="573a" class="mh ku in md b gy mi mj l mk ml">.environmentObject(variable)</span></pre><h1 id="288a" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">@观察对象</h1><p id="8b43" class="pw-post-body-paragraph jv jw in jx b jy lw ka kb kc lx ke kf kg ly ki kj kk lz km kn ko ma kq kr ks ig bi translated">为了正确使用被观察对象，我们的类需要符合<code class="fe mm mn mo md b"><strong class="jx io">ObservableObject</strong></code>协议。它不拥有自己的数据。</p><p id="f003" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果我们想观察一个对象的状态，我们添加这个包装器。它与stateObject类似，但我们在创建新对象时必须使用ObservedObject。</p><p id="913d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们在内部使用Published和observed object类，所以当它发生变化时，它会自动发送变化。</p><h1 id="e55a" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">@已发布</h1><p id="53cb" class="pw-post-body-paragraph jv jw in jx b jy lw ka kb kc lx ke kf kg ly ki kj kk lz km kn ko ma kq kr ks ig bi translated">当我们有一个符合<code class="fe mm mn mo md b"><strong class="jx io">ObservableObject</strong></code>协议的类时，我们就有了这个变量的包装器，我们希望跟踪它们的变化。这个包装器告诉SwiftUI在发生变化时刷新。</p><h1 id="cdb2" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">@ StateObject</h1><p id="96e6" class="pw-post-body-paragraph jv jw in jx b jy lw ka kb kc lx ke kf kg ly ki kj kk lz km kn ko ma kq kr ks ig bi translated">用于存储来自符合<code class="fe mm mn mo md b"><strong class="jx io">ObservableObject</strong></code>协议新实例数据。它拥有自己的数据</p><p id="2507" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你想让你的变量在视图刷新时不被破坏，你应该使用这个包装器。</p><p id="645e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi">.</p></div></div>    
</body>
</html>