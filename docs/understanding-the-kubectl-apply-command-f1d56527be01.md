# 理解 Kubectl Apply 命令

> 原文：<https://blog.devgenius.io/understanding-the-kubectl-apply-command-f1d56527be01?source=collection_archive---------4----------------------->

在这篇文章中，我们将探索 **kubectl apply** 命令是如何在内部工作的。这将让你更好地理解 kubernetes 是如何工作的，并让你成为一名出色的 DevOps 工程师。

![](img/8dd8087ee7d35c2a762fb3ed049eb093.png)

通常，kubectl apply 命令用于以声明的方式创建和更新对象。

例如，要更新/创建 nginx.yaml 中定义的对象:

```
kubectl apply -f nginx.yaml
```

*提醒一下，前面的命令展示了如何使用 apply 命令以声明的方式创建和更新 kubernetes 对象。*

为了理解 apply 命令的内部原理，让我们先后退一步，理解对象是如何在 kubernetes 中创建的:

以 YAML 文件中定义的下列 POD 对象为例:

现在创建对象:

```
kubectl create -f nginx.yaml
```

**重要提示**:在后台，会在 kubernetes 中额外生成一个动态配置文件。这个新文件类似于我们在本地创建的文件。但是，它包含有关对象状态的更多信息:

**上面的文件是 kubernetes 集群上对象的实时配置。**

如上所述，kubernetes 将 status 字段附加到配置文件中，以便跟踪关于对象的信息。

这就是 kubernetes 如何在内部存储关于一个对象的信息，**而不管它是以何种方式创建的(声明式还是命令式)**。

# 返回到应用命令

执行 apply 命令时，会考虑簿记中的以下 3 个文件。

*   一个**本地配置文件**(开发者定义)
*   kubernetes 上的一个**活动对象定义**(由 kubernetes 创建的附加 YAML 文件)
*   **最后应用的配置**。(新)

您可能已经注意到，列出的前两个文件是我们之前讨论过的，第三个文件是 apply 命令特有的。

每当我们运行应用命令**时，所有的三个文件都被比较，以确定在活动对象上要做什么改变**

# 有关应用的配置文件的更多信息

本地对象配置文件**的 YAML 版本**被转换为 JSON 格式，然后被存储为**最后应用的**配置。

按照我们之前的例子:

# kubernetes 如何利用这些文件？

例如:假设我们将本地配置文件**中的 image 字段从 1.18 更新为 1.19，然后像以前一样运行 apply 命令。**

将改变后的图像域与**实时配置**中的值进行比较，如果有差异，则用新值更新实时配置。

在任何改变之后，最后应用的**JSON 文件总是被更新。**

此时你可能会问自己:JSON 应用配置文件的目的是什么？

最好用一个例子来说明这一点:

让我们假设一个字段被删除了，比方说，label 中的 type 字段在我们的**本地配置文件**中被删除了。当我们运行 kubectl apply 命令时，我们看到最后一个**应用的配置**有一个标签，但是它不存在于**本地配置**中。

这意味着该字段需要从**实时配置**(由 kubernetes 生成的 YAML 文件)中删除。

因此，如果一个字段存在于**实时配置**中，而不存在于**本地**或**最后应用的**配置中，那么它将保持原样。

但是如果某个字段在**本地文件**中丢失，并且存在于最后一个**应用的配置**中，这意味着在之前的步骤中该字段已被移除。

总之:新添加的**应用配置文件**帮助 kubernetes 找出已经从**本地文件**中删除的字段。

我们刚才讨论的内容可以在 kubernetes is 文档页面中详细参考。

# 包扎

*   我们学习了 kubectl apply 命令使用的三组文件
*   本地文件存储在我们的本地系统中。
*   **活动对象配置**在 kubernetes 内存中。

## 但是存储了最后应用的配置的 JSON 文件在哪里呢？

它作为一个名为**last applied configuration**的注释存储在 kubernetes 集群上的活动对象配置中。

> 所以请记住，这只有在您使用 apply 命令时才能完成，kubectl create 或 replace 命令不会像解释的那样存储最后应用的配置。

使用 apply 命令后，无论何时进行更改，apply 命令都会比较所有三个部分。

1.  **本地**定义文件。
2.  **活**对象配置文件。
3.  存储的**最后一次**应用的配置

*原载于*[*https://luispreciado . blog*](https://luispreciado.blog/posts/kubernetes/core-concepts/kubectl-apply)*。*