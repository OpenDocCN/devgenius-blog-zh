# 研磨 LeetCode 问题的禅:第 15 天-做数学

> 原文：<https://blog.devgenius.io/the-zen-of-grinding-leetcode-problems-day-15-doing-math-8094400c137b?source=collection_archive---------10----------------------->

你好，我看到你又回来了更多的 [**LeetCode 日常练习系列**](https://medium.com/@matei.danut.dm/the-zen-of-grinding-leetcode-problems-day-0-motivation-681842565166) **。**今天我做了 **2 道中等**题，在**总共 10 行代码下**。
什么给了？让我们来了解一下！

![](img/f358b6c298461b2c62d6af0ab8e9dfe1.png)

# 孤独寂寞的数字

[](https://leetcode.com/problems/find-all-lonely-numbers-in-the-array/) [## 查找数组中所有的孤立数字- LeetCode

### 给你一个整数数组 nums。当一个数 x 只出现一次，并且没有相邻的数(即 x +…

leetcode.com](https://leetcode.com/problems/find-all-lonely-numbers-in-the-array/) 

**见解**:

*   这是一个令人惊讶的简单问题，你所要做的就是按照描述中的说明去做，你就完成了，*不需要优化*
*   为了谨慎起见，我使用了一个**集合**来代替原来的 *nums* **list** ，以降低从 **O(n)** 到 **O(1)** 的*搜索操作*(即使用关键字中的**)的复杂度。**

# 我们用数学解决的问题

[](https://leetcode.com/problems/egg-drop-with-2-eggs-and-n-floors/) [## 有两个蛋和 N 层的蛋蛋- LeetCode

### 给你两个相同的鸡蛋，你可以进入一个有 n 层楼的建筑，从 1 到 n。你知道…

leetcode.com](https://leetcode.com/problems/egg-drop-with-2-eggs-and-n-floors/) 

**见解**:

*   这一次，只是阅读我的解决方案将*不会帮助你太多*。对于这样的数学问题，不仅需要**的解释**，还需要**的思维过程**引导你去解决它
*   必要的投掷总数为:
    number =*number _ of _ intact _ drops*+*(broken _ floor—prev _ floor)*
*   **完整滴数**是解决方案的第一部分。每次你扔出第一个鸡蛋而它没有打破，你就可以想上多少层楼就上多少层。显然，上去太慢有它的缺点，想象一下，如果你一层一层地上去，鸡蛋在最后一层上破了！
*   **(broken _ floor—prev _ floor)**是解决方案的第二部分。一旦你的第一个鸡蛋在特定的楼层被打破，你别无选择，只能一层一层地爬上去。这种情况最糟糕的情况是第二层楼板在 **(broken_floor — 1)** 楼板上断裂。
*   让我们想一想，当我们有两个鸡蛋的时候，我们要上几层楼。如果我们总是增加相同的数量，我们就没有真正正确地分配可用的操作数量。例如，如果我们有 100 层，我们向上 10 乘 10，如果鸡蛋在 10 层打破，我们还有 9 层要检查，总共有 10 个操作。如果它在 100 层坏了，我们还有 9 个要检查，总共 19 个操作！

![](img/8bbda6ca3edf57e6a037d29bd009e401.png)

这里有一个可爱的杰尼龟能走到这一步

*   这让我们想到了解决方案背后的**关键思想:我们应该在开始时跳得更多，在接近结尾时跳得更少。因为每次跳跃都算作一次操作，我们可以**通过总是比上次少跳 1 层来补偿****
*   假设在*最坏情况*中，我们必须在打破第一个鸡蛋之前进行 **d** 跳跃，我们从大小为**k**的跳跃开始，然后，我们应该能够使用像这样越来越小的跳跃爬上整个建筑:
*   **k+(k-1)+(k-2)+…+(k-d+1)≥n**
*   我们有≥因为我们最终可能会*越过*建筑一点
*   该等式相当于:
*   **d * k — (d * (d-1)) / 2 ≥ n**
*   哪个是
*   **d * (2*k — d + 1) ≥ 2n**
*   如果参照我们之前的公式， **d** 是**完好数下降数**，而 **k** 是**(破损数—预防数)**。为了获得整体最小的运算次数，我们必须确保 d 和 k 是平衡的，所以我们将认为它们相等。
*   因此，我们有
*   **d * (2 * d — d + 1) ≥ 2n**
*   **d * (d + 1) ≥ 2n**
*   此时，解(因为 k 和 d 相等)是前一个等式适用的*最小的 d*。
*   所以它要么是 int(sqrt(2n))要么是它上面的下一个整数。

结束语:

*   我不打算撒谎，我并不是第一次看问题就自己想出了解决办法。
*   事实上，有人不得不**向我解释**，然后一段时间过去了，然后我不得不**再次理解它**，然后过了一段时间我试图**开发我自己的解决方案**，最后我明白了
*   但这并不意味着我*这次记住了它*。我对采取什么样的**方向**有一些模糊的想法，但是在纸上得到实际的*数学公式*需要一点时间。
*   在这种情况下，人们可能会怀疑我是否真的**掌握了**解决方案，或者我只是**模糊地回忆起**它。或者作为一个更普遍的问题，**阅读大量 LeetCode 问题的解决方案**与**亲自实施它们**之间会有什么不同？
*   嗯，*首先是*，如果你**只是读而不写一行**，你**将不会有肌肉记忆**成为一个快速编码者。当我试图学习像 **K8S** 或 **AWS CLI** 或 **ArgoCD** 这样的基于 CLI 的工具时，我经常看到这种情况。我会阅读大量的教程和视频，我理解概念，但是我会努力记住语法。
*   这表明你缺乏经验，不管你有多快找到解决方案。面试官会希望**看到你编码**，所以弄清楚算法只是第一步。
*   *其次是*，这是更微妙的方式，如果你总是**阅读解决方案**，然后**休息一下**，然后**实施你所记得的**那还是 ***而不是*** 。
*   如果你总是**就你熟悉的**问题接受采访，这种方法很管用，但是在一个完全**新的** **场景**，**中，你会惊慌失措**。
*   那是因为你没有**的信心**到*知道你可以从零开始，建立一个粗略的解决方案，然后改进它*。
*   所以我给你的建议是，在阅读任何东西之前，先试着自己解决问题。然后，当你对结果感到*满意的时候，一定要**好好读一读，看看有没有一种方法可以改进**你甚至都没有想到。*