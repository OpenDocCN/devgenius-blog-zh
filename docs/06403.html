<html>
<head>
<title>A Primer on WebAssembly</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">WebAssembly入门</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/a-primer-on-webassembly-834150fdd7ae?source=collection_archive---------2-----------------------#2022-01-05">https://blog.devgenius.io/a-primer-on-webassembly-834150fdd7ae?source=collection_archive---------2-----------------------#2022-01-05</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="485a" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">以及为什么它还没有取代Javascript……</h2></div><p id="d743" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">正如这篇LinkedIn帖子中所详述的，2022年将是我潜入WebAssembly和Rust世界的一年。随着越来越多的人选择博客内容而不是其他媒体，这里是第一个，我希望会是一个涵盖上述主题的系列帖子。</p><p id="0556" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">尽管互联网上有各种形式的报道，但我认为任何关于新技术或工具的内容都应该从其诞生背后的动机开始。为了理解为什么会有WebAssembly的需求，让我们不要急着回想一下。</p><h1 id="7c20" class="kz la in bd lb lc ld le lf lg lh li lj jt lk ju ll jw lm jx ln jz lo ka lp lq bi translated">万维网的历史</h1><p id="b011" class="pw-post-body-paragraph kc kd in ke b kf lr jo kh ki ls jr kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">我们今天所知道的万维网，是从欧洲粒子物理研究所的一台NeXT计算机上的一个单页项目开始的。你仍然可以在这里看到它<a class="ae ky" href="http://info.cern.ch/hypertext/WWW/TheProject.html" rel="noopener ugc nofollow" target="_blank">。该页面是一个用HTML编写的简单的静态页面，包含项目链接和一些其他技术细节。这个项目背后的动机是通过一个文档交换网络实现学者之间的信息共享。</a></p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi lw"><img src="../Images/c8ad0a230e24b0fada9358f10c5189f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R9VxdtxU40-RLwKVzHEfAQ.jpeg"/></div></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk translated">第一个网页，鸣谢:欧洲粒子物理研究所</figcaption></figure><p id="2ed7" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">正如你可能在上面注意到的，第一个浏览器和我们今天使用的浏览器并没有根本的不同。然而，从那以后，网络内容的交互性已经发生了巨大的变化。随着它的普及和成熟，人们要求内容变得更加复杂，并在不同的操作系统和设备上呈现。这显然意味着与HTML文档中的各种元素进行交互并访问这些元素，而这个领域的领先者之一就是JavaScript。</p><h1 id="1b73" class="kz la in bd lb lc ld le lf lg lh li lj jt lk ju ll jw lm jx ln jz lo ka lp lq bi translated">进入..Java Script语言</h1><p id="62b1" class="pw-post-body-paragraph kc kd in ke b kf lr jo kh ki ls jr kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">JavaScript创建于1995年，其名称旨在利用Java的广泛应用，它的准入门槛非常低。这意味着即使是非技术人员也可以使用它在他们的网页中引入交互性。这促使它成为事实上的编译目标，与ActiveX、Adobe Flash、JavaBeans等竞争对手相抗衡。</p><p id="83aa" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是随着这种不受约束的增长，也有一些挑战。JavaScript是一种解释型语言。简单地说，你写的函数被打包并压缩成一个源文件。作为纯文本发送到客户端的浏览器，这需要被解析成<a class="ae ky" href="https://en.wikipedia.org/wiki/Abstract_syntax_tree" rel="noopener ugc nofollow" target="_blank">抽象语法树</a>，编译成字节码，然后由解释器执行。浏览器的<a class="ae ky" href="https://en.wikipedia.org/wiki/JavaScript_engine" rel="noopener ugc nofollow" target="_blank"> JavaScript引擎</a>然后通过JIT编译等方法发现任何潜在的优化，最终实现优化。这里的关键字是最终的，因为这是一个以速度为最终目标的漫长过程。</p><p id="e2f5" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然而，对速度的担忧不仅仅局限于到达目的地的复杂过程。对于性能是关键因素的更具挑战性的应用程序，性能水平缺乏一致性/可预测性是一个重大障碍。</p><p id="9938" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">此外，随着网络的普及，人们更热衷于将更复杂的语言引入竞争。在没有插件的情况下，使用JavaScript作为编译目标是唯一的选择。作为一种解释语言本身，上述操作变得复杂，因为如果要有效地实现它们，需要付出大量的努力。</p><h1 id="a693" class="kz la in bd lb lc ld le lf lg lh li lj jt lk ju ll jw lm jx ln jz lo ka lp lq bi translated"><strong class="ak"/></h1><p id="a151" class="pw-post-body-paragraph kc kd in ke b kf lr jo kh ki ls jr kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">作为JavaScript的一个子集，<a class="ae ky" href="http://asmjs.org/spec/latest/" rel="noopener ugc nofollow" target="_blank"> asm.js规范</a>旨在为C或C++等内存不安全的语言描述一个沙盒虚拟机，并为编译器提供一种低级、高效的目标语言。该规范首先由Mozilla Firefox浏览器实现，通过JavaScript引擎对有效的asm.js代码采用提前优化编译策略，引入了性能改进。</p><p id="1b00" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">引用<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Games/Tools/asm.js?source=post_page" rel="noopener ugc nofollow" target="_blank"> Mozilla文档</a>，</p><blockquote class="mm"><p id="cc4d" class="mn mo in bd mp mq mr ms mt mu mv kx dk translated">它是JavaScript的一个非常小的、严格的子集，只允许诸如“while”、“if”、数字、顶级命名函数和其他简单的构造。它不允许对象、字符串、闭包以及基本上任何需要堆分配的东西。Asm.js代码在许多方面类似于C，但它仍然是完全有效的JavaScript，可以在所有当前引擎中运行</p></blockquote><p id="3433" class="pw-post-body-paragraph kc kd in ke b kf mw jo kh ki mx jr kk kl my kn ko kp mz kr ks kt na kv kw kx ig bi translated">虽然asm.js在性能方面有所改进，但它仍然局限于可以用JavaScript表达的东西。作为JavaScript的非正式规范，而不是真正的标准，每个供应商都以他们认为合适的方式对其进行了优化。尽管它确实导致了<a class="ae ky" href="https://hacks.mozilla.org/2015/03/asm-speedups-everywhere/" rel="noopener ugc nofollow" target="_blank">最终的融合</a>，但在标准化方面肯定还有改进的空间。</p><h1 id="e01f" class="kz la in bd lb lc ld le lf lg lh li lj jt lk ju ll jw lm jx ln jz lo ka lp lq bi translated">输入… WebAssembly</h1><p id="60f4" class="pw-post-body-paragraph kc kd in ke b kf lr jo kh ki ls jr kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">基于asm.js的经验，所有主流浏览器都致力于为Web设计一种新的格式，最终目标之一是速度和效率。</p><blockquote class="mm"><p id="6079" class="mn mo in bd mp mq mr ms mt mu mv kx dk translated">WebAssembly，缩写为Wasm，旨在成为编程语言的可移植编译目标，支持客户端和服务器应用程序在web上的部署。</p></blockquote><p id="4c2e" class="pw-post-body-paragraph kc kd in ke b kf mw jo kh ki mx jr kk kl my kn ko kp mz kr ks kt na kv kw kx ig bi translated">那么<a class="ae ky" href="https://webassembly.org/" rel="noopener ugc nofollow" target="_blank"> WebAssembly </a>到底是什么？它是基于堆栈的机器的二进制指令格式。下面是一个简单的“Hello world”程序在Wasm中的部分片段。</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi nb"><img src="../Images/f76cd10bf3bd5c24eb6a119b0f829353.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x7yznGVYb9CDWgZF2HBrMw.png"/></div></div></figure><p id="68e4" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">从上面的代码片段可以看出，这比asm.js或JavaScript更接近于机器码。因此，解码、编译、获取和优化WebAssembly代码花费的时间更少是显而易见的。为什么？</p><p id="c7eb" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，一个JavaScript引擎在应用程序启动过程中所花费的典型时间如下所示。</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi nc"><img src="../Images/17dcf06a27f03d9bbeaecac4d01d3948.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TcGV789UvSFJXw0B_ZZuzQ.png"/></div></div></figure><p id="5cc1" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">尽管为了图示的描述，这些任务已经被分开，但实际上它们是相互交织在一起的，而不是分离的。对于较大的JavaScript应用程序，监控和编译代码的开销当然会增加。</p><p id="5427" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">与典型的WebAssembly流程形成对比。</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/500906258646b8d9369c85c609034d71.png" data-original-src="https://miro.medium.com/v2/resize:fit:758/format:webp/1*fEbgXDxFb2khZ5C1smcrCg.png"/></div></figure><p id="0bd6" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">不仅因为它更接近机器代码，所以花费的时间有了显著的不同，而且某些步骤也完全消除了。这显然会在大多数情况下(但不是所有情况下)带来更好的性能，因为WebAssembly仍处于萌芽阶段(MVP已于2017年完成)。</p><p id="97a6" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是等等..这是否意味着开发人员将会用WebAssembly而不是JavaScript来编写整个代码库？由于这是一个同类比较，这个问题的答案显然是肯定的。但事实并非如此！预计大多数Wasm开发人员将继续使用Rust、C等语言编写代码。然后编译成WebAssembly，这样用户就可以获得它的性能优势。</p><p id="6acc" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所以这个帖子到此为止！这里有一个在学习过程中帮助我的资源列表，</p><ul class=""><li id="5035" class="ne nf in ke b kf kg ki kj kl ng kp nh kt ni kx nj nk nl nm bi translated"><a class="ae ky" href="https://hacks.mozilla.org/" rel="noopener ugc nofollow" target="_blank">Mozilla黑客博客</a></li><li id="c254" class="ne nf in ke b kf nn ki no kl np kp nq kt nr kx nj nk nl nm bi translated">由Linux基金会在edX上提供的免费课程</li><li id="c6f5" class="ne nf in ke b kf nn ki no kl np kp nq kt nr kx nj nk nl nm bi translated"><a class="ae ky" href="https://blog.sessionstack.com/" rel="noopener ugc nofollow" target="_blank">session stack博客</a></li><li id="64a5" class="ne nf in ke b kf nn ki no kl np kp nq kt nr kx nj nk nl nm bi translated"><a class="ae ky" href="https://home.cern/science/computing/birth-web/short-history-web" rel="noopener ugc nofollow" target="_blank">欧洲核子研究中心网页</a></li><li id="1259" class="ne nf in ke b kf nn ki no kl np kp nq kt nr kx nj nk nl nm bi translated"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/WebAssembly" rel="noopener ugc nofollow" target="_blank"> MDN网络文档</a></li></ul><p id="176f" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ns">要了解我最新的科技恶作剧，请在</em><a class="ae ky" href="https://twitter.com/Divya_Mohan02" rel="noopener ugc nofollow" target="_blank"><em class="ns">Twitter</em></a><em class="ns">和</em><a class="ae ky" href="https://www.linkedin.com/in/divya-mohan0209/" rel="noopener ugc nofollow" target="_blank"><em class="ns">LinkedIn</em></a><em class="ns">上关注我。</em></p></div></div>    
</body>
</html>