<html>
<head>
<title>Git Repo File Push from NodeJS Script</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从 NodeJS 脚本推送 Git Repo 文件</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/git-repo-file-push-from-nodejs-script-f2d5c0fb0225?source=collection_archive---------3-----------------------#2022-10-13">https://blog.devgenius.io/git-repo-file-push-from-nodejs-script-f2d5c0fb0225?source=collection_archive---------3-----------------------#2022-10-13</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/68b993b91393a0ad777bf86840c0c402.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wMKX0U0wkehkwKjYy4ZXZg.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">照片由<a class="ae jz" href="https://unsplash.com/es/@praveentcom?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Praveen Thirumurugan </a>在<a class="ae jz" href="https://unsplash.com/s/photos/github?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="c32a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在本文中，我们将了解如何从运行的 nodejs 代码本身推送 git 存储库中的文件夹或文件。</p><p id="75f5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当我在我的一个项目中工作时，我不得不将文件从代码本身推到 git 库。但是我找不到解决这个问题的好办法，所以我写了这篇文章。</p><p id="3726" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对于我们的案例，我们将使用<strong class="kc io"> shellJS </strong>和<strong class="kc io"> simple-git </strong>模块。</p><p id="3084" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">ShellJS 是在 Node.js API 之上的 Unix shell 命令的可移植的<strong class="kc io"> (Windows/Linux/OS X) </strong>实现。您可以使用它来消除您的 shell 脚本对 Unix 的依赖，同时仍然保留其熟悉而强大的命令。您还可以全局安装它，这样您就可以从外部节点项目运行它——告别那些粗糙的 Bash 脚本！</p><p id="dfba" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">git-simple 是一个轻量级接口，用于在任何<a class="ae jz" href="https://nodejs.org" rel="noopener ugc nofollow" target="_blank"> node.js </a>应用程序中运行<code class="fe ky kz la lb b">git</code>命令。</p><p id="94c1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">了解更多关于<a class="ae jz" href="https://www.npmjs.com/package/shelljs" rel="noopener ugc nofollow" target="_blank"> shelljs </a>和<a class="ae jz" href="https://www.npmjs.com/package/simple-git" rel="noopener ugc nofollow" target="_blank"> simpleGit </a>的信息。</p><pre class="lc ld le lf gt lg lb lh li aw lj bi"><span id="76b7" class="lk ll in lb b gy lm ln l lo lp">npm i shelljs<br/>npm i simpleGit</span></pre><p id="ec30" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了从 GitHub 克隆 git 存储库，我们需要传递用户凭证(用户名和密码)。一种方法是通过 URL 本身传递用户名和密码。</p><p id="c8c7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们可以通过 simple-git 轻松做到这一点</p><p id="ddf4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">首先创建 simple-git 的实例，名称可以是 git 或您喜欢的任何名称。</p><pre class="lc ld le lf gt lg lb lh li aw lj bi"><span id="bb96" class="lk ll in lb b gy lm ln l lo lp">const simpleGit = require("simple-git");<br/>const git = simpleGit();</span></pre><p id="157a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在此之后，我们需要使用克隆方法来克隆所需的回购。</p><pre class="lc ld le lf gt lg lb lh li aw lj bi"><span id="f133" class="lk ll in lb b gy lm ln l lo lp">await git.clone(`https://${username}:${password}@github.com/yourepo`);</span></pre><p id="2a87" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是，如果我们只想进行克隆，前提是克隆之前没有完成，那么我们将检查存储库的文件夹名称是否存在，或者是否使用 fs 模块(<strong class="kc io">文件系统模块)</strong>允许在 nodejs 中使用文件系统。如果不存在，那么我们可以克隆。</p><pre class="lc ld le lf gt lg lb lh li aw lj bi"><span id="d8cf" class="lk ll in lb b gy lm ln l lo lp">if(!fs.existSync(path.resolve(__dirname, 'cloned folder name')); <br/>      await git.clone(`https://${username}:${password}@github.com/yourepo`);</span></pre><p id="fe2f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">克隆完成后，我们的任务是首先复制我们想要放入 git 存储库中的文件夹或文件。为此，我们将使用 fs-extra 模块。</p><p id="f87f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe ky kz la lb b">fs-extra</code>添加了本地<code class="fe ky kz la lb b">fs</code>模块中没有的文件系统方法，并为<code class="fe ky kz la lb b">fs</code>方法添加了 promise 支持。当我们想用 promise 复制整个文件夹时，它也很有帮助。</p><p id="7bba" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">要了解更多关于 fs-extra 的信息，请访问<a class="ae jz" href="https://www.npmjs.com/package/fs-extra" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><pre class="lc ld le lf gt lg lb lh li aw lj bi"><span id="31fa" class="lk ll in lb b gy lm ln l lo lp">const fse = require(fs-extra);<br/>...</span><span id="cd77" class="lk ll in lb b gy lq ln l lo lp">await fse.copySync(path.resolve(__dirname, 'folder where file is     present'), path.resolve(__dirname, 'git repo folder'), {                                   overwrite : true }, <br/>    (error)=&gt; {                                      <br/>        if(error)                                         <br/>           throw new error;                                        <br/>         else                                          <br/>           throw new "some internal error";                                    });</span><span id="95cf" class="lk ll in lb b gy lq ln l lo lp">....</span></pre><p id="4780" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">到目前为止，我们已经克隆了存储库，并将文件夹复制到克隆的存储库中。但是主要的工作是提交我们在存储库中所做的更改。</p><p id="4491" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，我们将使用 shellJS。Shelljs 为我们提供了在 nodejs 脚本中运行终端命令的功能。</p><p id="999e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们将使用 exec 命令来执行查询。</p><p id="80e2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">使用 exec，我们将首先在 git local 中添加文件夹，然后使用 commit 命令提交，之后我们将拉取更改，以便原始存储库和当前存储库中不会有任何意外的更改，然后我们将从本地推送更改。</p><p id="ea08" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所以这一切的全部代码如下</p><figure class="lc ld le lf gt jo"><div class="bz fp l di"><div class="lr ls l"/></div></figure></div><div class="ab cl lt lu hr lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ig ih ii ij ik"><p id="c28b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">希望你喜欢这篇文章。有许多其他方法可以做到这一点，但我个人认为这是最简单的。</p><p id="3be4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">感谢您抽出时间阅读这篇文章。</p></div></div>    
</body>
</html>