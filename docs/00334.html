<html>
<head>
<title>Key concepts about using JProfiler</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于使用 JProfiler 的关键概念</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/key-concepts-about-using-jprofiler-d1e70dc16ac7?source=collection_archive---------21-----------------------#2020-06-02">https://blog.devgenius.io/key-concepts-about-using-jprofiler-d1e70dc16ac7?source=collection_archive---------21-----------------------#2020-06-02</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/592a350f117e169eabeb75ca3979ee7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*TOFgubTaEtAxtjj-"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">克里斯蒂娜@ wocintechchat.com 在<a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="537d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">JProfiler 是<strong class="kc io">一个分析 JVM 内部情况的工具</strong>。E-J 技术公司开发了这个工具。最常见的用法是 CPU 分析或内存分析。在这篇文章中，我想详细介绍一些关于使用 JProfiler 的关键概念。</p><p id="1c34" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">每个软件开发人员在提高企业应用程序的性能时，都必须使用 JProfiler 或类似的工具 VisualVM 或 JDK 捆绑工具。之前，我已经展示了<a class="ae jz" href="https://betterjavacode.com/2018/12/29/jprofiler-for-performance-testing/" rel="noopener ugc nofollow" target="_blank">如何使用 JProfiler 进行性能测试</a>。</p><p id="29fa" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">JProfiler 专注于三个不同的主题，可以帮助开发人员分析他们的应用程序。</p><ul class=""><li id="1c1f" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx ld le lf lg bi translated"><strong class="kc io">方法调用</strong> —这显示了您的应用程序正在用方法调用做什么，以及哪里可以提高性能。</li><li id="4a90" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated"><strong class="kc io">线程和锁</strong> —要发现任何多线程问题，您应该检查 JProfiler 提供的线程和锁分析。</li><li id="65a7" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated"><strong class="kc io">分配</strong> —您可以分析堆上的对象、引用链和垃圾收集。因此，它有助于修复内存泄漏问题。</li></ul><p id="942a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">JProfiler 还提供了数据库分析，可以帮助理解数据库查询是否存在任何性能问题。我不会在这篇文章中讨论这个问题。</p><h1 id="32c5" class="lm ln in bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">JProfiler 设置</h1><p id="8655" class="pw-post-body-paragraph ka kb in kc b kd mk kf kg kh ml kj kk kl mm kn ko kp mn kr ks kt mo kv kw kx ig bi translated">使用 JProfiler 时，有两种方法可以收集数据。</p><ul class=""><li id="5c46" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx ld le lf lg bi translated"><strong class="kc io">采样</strong> —这不一定能提供所收集数据的准确性。这个特性不提供方法级的统计。使用这个特性的好处是，在运行 JProfiler 时，系统性能不会受到影响。</li><li id="796e" class="ky kz in kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated"><strong class="kc io">检测</strong> —这种模式收集全部数据，但也会严重影响应用程序的性能。优点是数据的准确性。如果您正在进行性能分析，这应该是您的默认选择，尽管有缺点，它提供了大量有助于分析性能的数据。</li></ul><h1 id="d25e" class="lm ln in bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">如何在正在运行的应用程序上运行 JProfiler</h1><p id="dcc7" class="pw-post-body-paragraph ka kb in kc b kd mk kf kg kh ml kj kk kl mm kn ko kp mn kr ks kt mo kv kw kx ig bi translated">JProfiler 提供了两种模式来启动对应用程序的分析。如果在本地模式下运行，那么在启动 JProfiler 时必须选择数据收集模式。在这种模式下，应用程序和 JProfiler 运行在同一台机器上。通常不推荐。</p><p id="e890" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在远程模式下，您将在一台远程机器上启动 JProfiler 代理，这台机器可能就是运行应用程序的机器。从您的本地 JProfiler 安装，您将连接到 JProfiler 代理。为此，您需要远程机器的 IP 地址以及 JProfiler 代理运行的端口。简而言之，您正在将 JProfiler GUI 连接到一个远程 JProfiler 代理，该代理正在分析您的应用程序。</p><h1 id="8e30" class="lm ln in bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">如何使用 JProfiler 分析应用程序性能</h1><p id="9d54" class="pw-post-body-paragraph ka kb in kc b kd mk kf kg kh ml kj kk kl mm kn ko kp mn kr ks kt mo kv kw kx ig bi translated">如果您正在应用程序上运行性能测试，那么当性能测试停止时，您将停止分析。一旦概要分析完成，JProfiler GUI 应该提供概要分析数据的快照。</p><p id="87e1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这个快照中，我们将有用于性能分析的数据生成的对象数、方法调用、垃圾收集、内存泄漏。现在，我们将从 JProfiler 快照数据中了解这些关键概念。</p><p id="1aed" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如下所示的 Telemetries 概览页面将让您了解垃圾收集活动、内存、线程、类和 CPU 负载等指标。</p><figure class="mq mr ms mt gt jo gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/0dd79abcde679e6216e60175341719c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/0*Ke5QyhfdG2YKLKI4"/></div></figure><figure class="mq mr ms mt gt jo gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/d4ee52bd530e2ac025a10843f8a047ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/0*OsJJaILyhVcnSxVi"/></div></figure><h1 id="7bf4" class="lm ln in bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">CPU 视图</h1><p id="2228" class="pw-post-body-paragraph ka kb in kc b kd mk kf kg kh ml kj kk kl mm kn ko kp mn kr ks kt mo kv kw kx ig bi translated">CPU 视图显示应用程序中每个方法的执行次数和调用关系。在 CPU 视图中，您可以找到您怀疑可能导致性能问题的任何特定方法。这是分析您的应用程序中的罪魁祸首的绝佳视角。</p><h1 id="5c87" class="lm ln in bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">调用树</h1><p id="02e8" class="pw-post-body-paragraph ka kb in kc b kd mk kf kg kh ml kj kk kl mm kn ko kp mn kr ks kt mo kv kw kx ig bi translated">调用树显示了应用程序执行期间所有方法调用的分层视图。JProfiler 有助于根据方法的总执行时间对它们进行排序。</p><figure class="mq mr ms mt gt jo gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/254276cf92172ae9b507db6b7a8ea7f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/0*unkjwHSYkeJm-8Vv"/></div></figure><figure class="mq mr ms mt gt jo gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/da11b2b8fee6189628d99eec90bd297b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/0*yEkp_WKZAr67XKtz"/></div></figure><p id="88b7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如上所示，我们可以看到从 Redis 缓存中读取数据的方法花费了最多的时间。</p><h1 id="243c" class="lm ln in bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">热点</h1><p id="4c66" class="pw-post-body-paragraph ka kb in kc b kd mk kf kg kh ml kj kk kl mm kn ko kp mn kr ks kt mo kv kw kx ig bi translated">在 CPU 视图的同一个视图中，有一个热点选项。这个视图可以根据各种因素对方法进行排序，比如单个执行时间、总执行时间、平均执行时间和调用次数。</p><h1 id="e828" class="lm ln in bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">实时记忆</h1><p id="3605" class="pw-post-body-paragraph ka kb in kc b kd mk kf kg kh ml kj kk kl mm kn ko kp mn kr ks kt mo kv kw kx ig bi translated">实时内存视图显示内存分配。这是我们可以发现是否有任何内存泄漏的地方。</p><figure class="mq mr ms mt gt jo gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/2c0ad139b181c97c3c167d6d459fd79d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/0*Xk0QmnRnQWzgsgnk"/></div></figure><figure class="mq mr ms mt gt jo gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/8f4a972c2c2474a6f3cd00cf411bbd7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/0*gwpTMaWt6LKkHNy6"/></div></figure><h1 id="1d1c" class="lm ln in bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">所有对象</h1><p id="5cd9" class="pw-post-body-paragraph ka kb in kc b kd mk kf kg kh ml kj kk kl mm kn ko kp mn kr ks kt mo kv kw kx ig bi translated">所有对象视图将显示在应用程序执行期间创建的所有对象以及这些对象的大小。</p><h1 id="632e" class="lm ln in bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">结论</h1><p id="57fc" class="pw-post-body-paragraph ka kb in kc b kd mk kf kg kh ml kj kk kl mm kn ko kp mn kr ks kt mo kv kw kx ig bi translated">在这篇文章中，我展示了如何使用 JProfiler 进行性能分析的一些关键概念。如果使用有效，JProfiler 是一个强大的工具。JProfiler 中有很多特性，在使用这个工具时会让人不知所措。希望这篇帖子对你使用 JProfiler 分析应用有所帮助。</p><h1 id="8aec" class="lm ln in bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">参考</h1><ol class=""><li id="b41c" class="ky kz in kc b kd mk kh ml kl mv kp mw kt mx kx my le lf lg bi translated">JProfiler 简介— <a class="ae jz" href="https://www.ej-technologies.com/resources/jprofiler/help/doc/main/introduction.html?spm=a2c65.11461447.0.0.4e294d65AgyslJ#jprofiler.introduction" rel="noopener ugc nofollow" target="_blank"> JProfiler 简介</a></li></ol></div><div class="ab cl mz na hr nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ig ih ii ij ik"><p id="32ed" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ng">原载于 2020 年 6 月 2 日</em><a class="ae jz" href="https://betterjavacode.com/jprofiler/key-concepts-about-using-jprofiler" rel="noopener ugc nofollow" target="_blank"><em class="ng">【https://betterjavacode.com】</em></a><em class="ng">。</em></p></div></div>    
</body>
</html>