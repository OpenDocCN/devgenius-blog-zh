<html>
<head>
<title>12 Ways to Add an Array of Integers in C# — Part 4: Again and Again and Again</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在C#中添加整数数组的12种方法—第4部分:一次又一次</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/12-ways-to-add-an-array-of-integers-in-c-part-4-again-and-again-and-again-dddd86ec8ee?source=collection_archive---------1-----------------------#2020-11-18">https://blog.devgenius.io/12-ways-to-add-an-array-of-integers-in-c-part-4-again-and-again-and-again-dddd86ec8ee?source=collection_archive---------1-----------------------#2020-11-18</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/ebd9ee9c4285ca3827934bfbe0333f8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O5M-VokRKzPZJ6Xid2_5Hg.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">照片由<a class="ae jz" href="https://unsplash.com/@laimannung?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> 𝓴𝓘𝓡𝓚 𝕝𝔸𝕀 </a>在<a class="ae jz" href="https://unsplash.com/s/photos/vortex?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="599a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当我要求开发人员向我展示如何在C#中添加整数数组时，可能95%的人都想到了一个简单的<code class="fe ky kz la lb b">for</code>循环(<a class="ae jz" href="https://medium.com/dev-genius/12-ways-to-add-an-array-of-integers-in-c-part-1-34753ff7f17a?source=friends_link&amp;sk=ffb9131efdf8777a4d01208093229f3d" rel="noopener">第1部分</a>)，这很棒。有几个想出了一个<code class="fe ky kz la lb b">foreach</code>循环(<a class="ae jz" href="https://medium.com/dev-genius/12-ways-to-add-an-array-of-integers-in-c-part-2-freeform-iteration-2f5c810a8e7b?source=friends_link&amp;sk=ae3d73998d2e57811d3bea1374f7ddc7" rel="noopener"> Part 2 </a>)，也很棒。对于极少数建议使用我个人最喜欢的<code class="fe ky kz la lb b">Enumerable.Sum</code> ( <a class="ae jz" href="https://medium.com/dev-genius/12-ways-to-add-an-array-of-integers-in-c-part-3-thinking-in-sets-e2f456454f88?source=friends_link&amp;sk=4dff1c44cc446516161d65fe6e0fba26" rel="noopener">第三部</a>)的人来说，这是额外的奖励。</p><p id="e656" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">有一种方法我<em class="lc">从未</em>有过候选建议:递归函数，也就是说，一个函数无限地调用自己，直到它满足某种停止条件。实际上，如果一个程序员真的建议在C#中使用递归来添加整数数组，我会感到震惊，更不用说沮丧了。</p><p id="baed" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是如果我们谈论的是，比如说，F#，而不是C#，那会怎么样呢？那会有什么不同吗？这里有一个非常合理的方法来解决F#中的问题。</p><figure class="ld le lf lg gt jo"><div class="bz fp l di"><div class="lh li l"/></div></figure><p id="bb59" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这其实是一个很好的方法。在C#中，<strong class="kc io">而不是</strong>是一个好方法。先说为什么。</p><h1 id="394a" class="lj lk in bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">递归</h1><p id="8d34" class="pw-post-body-paragraph ka kb in kc b kd mh kf kg kh mi kj kk kl mj kn ko kp mk kr ks kt ml kv kw kx ig bi translated">这是我们12种方法中的第8种，基本上与F#版本相同:</p><figure class="ld le lf lg gt jo"><div class="bz fp l di"><div class="lh li l"/></div></figure><p id="1a4b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所有这些代码做同样的事情？是的，恐怕是的。嗯，算是吧。F#有一个<code class="fe ky kz la lb b">::</code>语法，将数组分成头部和尾部。C#没有这样的语法，所以我们必须自己写一个<code class="fe ky kz la lb b">GetHeadAndTail</code>方法。F#还有一个很好的、简单的表达式语法，用于将输入与一系列模式进行匹配，并返回第一个匹配的内容。C#正在实现它的版本<code class="fe ky kz la lb b">match</code>(被称为<code class="fe ky kz la lb b">switch</code>)，但它似乎是一项正在进行的工作。</p><p id="6660" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">更糟糕的是，代码甚至不工作。我的意思是，它实际上在小数组上工作得很好。在大网站上，你听说过由杰夫·阿特伍德和乔尔·斯波尔斯基创建的广受欢迎的问答网站吗？它是以将要发生的事情命名的。是的，你会得到一个堆栈溢出。</p><p id="db9b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为什么在C#中会出现堆栈溢出，而在F#中不会？答案很简单:尾部递归。F#有，C#没有。</p><p id="750e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们大多数人都非常熟悉调用栈的概念。如果您曾经在。NET中，您已经看到了一个方法如何调用另一个方法，而另一个方法又调用另一个方法，等等。运行库跟踪该堆栈。但是堆栈空间是有限的资源。你只能有这么多的一个东西调用另一个东西调用另一个。做太多次，你会得到，嗯，我们已经说过了，一个StackOverflowException。</p><p id="eb83" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">用尾部递归可以解释很多东西。我不会做得很好，而且在这里也没什么关系。这里有一个<a class="ae jz" href="https://cs.stackexchange.com/a/7814" rel="noopener ugc nofollow" target="_blank">好的总结</a>。长话短说:如果递归调用是方法中的最后一项，编译器可以优化掉调用堆栈问题。在F#中。但在C#中没有。(为什么不呢？这里也不相关。<a class="ae jz" href="https://stackoverflow.com/q/491376/44586" rel="noopener ugc nofollow" target="_blank">看这个</a>。)</p><h1 id="10e1" class="lj lk in bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">极限递归</h1><p id="f410" class="pw-post-body-paragraph ka kb in kc b kd mh kf kg kh mi kj kk kl mj kn ko kp mk kr ks kt ml kv kw kx ig bi translated">所以在C#中这通常不是一个好方法。</p><p id="b0ba" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是对于小数据集，从性能上来说，这实际上并不可怕。方法9是方法8的一个稍微不那么丑陋的版本，具有硬编码(可以参数化)的最大长度。</p><figure class="ld le lf lg gt jo"><div class="bz fp l di"><div class="lh li l"/></div></figure><p id="70f9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">注意来自<code class="fe ky kz la lb b">Enumerable</code>的<code class="fe ky kz la lb b">Any</code>、<code class="fe ky kz la lb b">First</code>和<code class="fe ky kz la lb b">Skip</code>方法。我告诉过你这是一个有用的课程。</p><h1 id="c176" class="lj lk in bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">递归+指针</h1><p id="2b2f" class="pw-post-body-paragraph ka kb in kc b kd mh kf kg kh mi kj kk kl mj kn ko kp mk kr ks kt ml kv kw kx ig bi translated">但是等等！还有呢！如果……不，它永远不会工作……嗯，也许，只是也许……当然，YOLO……我们能不能把两个糟糕的想法合并成一个稍微不那么糟糕的想法？为什么是的，是的，我们可以。</p><figure class="ld le lf lg gt jo"><div class="bz fp l di"><div class="lh li l"/></div></figure><p id="ec72" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我希望我可以向您报告，这以某种方式解决了堆栈溢出异常。看起来应该是这样的。但事实并非如此，因为尽管它看起来不像C#，但它确实像c#，因此没有尾部调用优化。</p><p id="7acb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是还记得我们在F#中可悲的缺少一个<code class="fe ky kz la lb b">::</code>操作符来返回一个头和一个尾吗？好吧，有了不安全的C#，我们有了一个很好的选择。因为我们已经固定了内存地址，所以我们可以取消对指针的引用来获得头部，然后增加它来获得尾部(减少剩余的长度来保持直线)。</p><p id="814a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">随便你怎么说，但是对于小数据集来说，这是一种非常快的方法。</p></div><div class="ab cl mm mn hr mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ig ih ii ij ik"><p id="b24d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们能让它变得更奇怪吗？老实说，没有。我想不出来。不过，我很想听听你的想法。</p><p id="f4af" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是我们能让它变得更好吗？最后两种方法将探索一些想法，这些想法可能会也可能不会改进我们到目前为止所做的工作。我们下次会谈到这些。</p></div></div>    
</body>
</html>