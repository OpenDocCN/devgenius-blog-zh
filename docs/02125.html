<html>
<head>
<title>State management in Svelte</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">苗条的国家管理</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/state-management-in-svelte-b045213c9138?source=collection_archive---------2-----------------------#2020-07-20">https://blog.devgenius.io/state-management-in-svelte-b045213c9138?source=collection_archive---------2-----------------------#2020-07-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="548e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">组件通信的状态管理变得简单</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/2211fb29fec3727861d7dba06d6f2b89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fCOBpevfigJ0COX_de0TBQ.jpeg"/></div></div></figure><p id="de2c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">2020年，web开发不仅基于<strong class="kt ir">组件驱动的方法</strong>，还基于<strong class="kt ir">状态管理解决方案</strong>的使用。</p><p id="163b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在像<a class="ae ln" href="https://angular.io/" rel="noopener ugc nofollow" target="_blank"> Angular </a>这样的早期JavaScript框架中，应用程序的状态通常嵌入在<strong class="kt ir">路由</strong>、<strong class="kt ir">服务</strong>、<strong class="kt ir">控制器</strong>、<strong class="kt ir">本地存储</strong>和<strong class="kt ir">会话存储</strong>中。</p><p id="931f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">即使有这么多不同的数据存储解决方案看起来很有用，但当你有一个大型应用程序时，很难跟踪存储了什么以及存储在哪里，这就会成为一个问题。</p><p id="96ef" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">随着时间的推移，<strong class="kt ir">第三方解决方案</strong>诞生，以解决这种缺乏，如<a class="ae ln" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux </a>和<a class="ae ln" href="https://vuex.vuejs.org/" rel="noopener ugc nofollow" target="_blank"> Vuex </a>。</p><blockquote class="lo"><p id="d0c8" class="lp lq iq bd lr ls lt lu lv lw lx lm dk translated">Svelte有一个更简单的状态管理方法，它消除了安装库的需要，并提供了在框架内管理状态的存储。</p></blockquote><p id="c8f8" class="pw-post-body-paragraph kr ks iq kt b ku ly jr kw kx lz ju kz la ma lc ld le mb lg lh li mc lk ll lm ij bi translated">在本文中，我们将看到Svelte如何管理和处理组件之间共享数据的<strong class="kt ir">状态。</strong></p><h1 id="ca85" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">上下文API</h1><blockquote class="lo"><p id="8eaa" class="lp lq iq bd lr ls lt lu lv lw lx lm dk translated">细长的上下文API非常适合跨组件通信，而不必通过传递道具来使代码库变得复杂</p></blockquote><p id="e5cd" class="pw-post-body-paragraph kr ks iq kt b ku ly jr kw kx lz ju kz la ma lc ld le mb lg lh li mc lk ll lm ij bi translated"><strong class="kt ir">上下文API </strong>由<code class="fe mv mw mx my b">svelte</code>包<code class="fe mv mw mx my b">getContext</code>和<code class="fe mv mw mx my b">setContext</code>提供的<strong class="kt ir"> 2个函数</strong>提供。</p><p id="e676" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您可以通过在上下文中设置对象或值<strong class="kt ir">并将其与一个键相关联，使其在应用程序内的任何位置</strong>可用:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="7f48" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">要使<code class="fe mv mw mx my b">someKey</code>在应用程序的不同组件中可用，只需使用<code class="fe mv mw mx my b">getContext</code>功能导入它:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="3d4d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">请注意，<code class="fe mv mw mx my b">getContext</code>只能用于检索使用了<code class="fe mv mw mx my b">setContext</code>的组件或同一组件树中的组件的键。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nb"><img src="../Images/962a23d211640501c5bbf7c55badeea1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6YEOtfURxNgYjuUiNRoKaw.png"/></div></div></figure><p id="56a2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了在不同树中的两个组件之间传递属性和值，Svelte使用了<a class="ae ln" href="https://svelte.dev/docs#svelte_store" rel="noopener ugc nofollow" target="_blank">存储</a>。</p><h1 id="09a1" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">使用苗条的商店</h1><blockquote class="lo"><p id="8b0a" class="lp lq iq bd lr ls lt lu lv lw lx lm dk translated">当组件需要相互交流而不需要传递太多的道具，并且你有一些属性需要被不同的组件访问时，苗条商店是处理你的应用程序状态的一个很好的工具。</p></blockquote><p id="aa02" class="pw-post-body-paragraph kr ks iq kt b ku ly jr kw kx lz ju kz la ma lc ld le mb lg lh li mc lk ll lm ij bi translated">Svelte通过<strong class="kt ir"> stores </strong>处理这种类型的属性，store是一个保存一个值的对象，当值发生变化时，它会通知你<strong class="kt ir">。</strong></p><p id="9923" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="nc">想象一个有登录用户的app。<br/>把</em> <code class="fe mv mw mx my b"><em class="nc">user=</em></code> <em class="nc">道具传递给每个组件会很繁琐。<br/>许多组件将不得不接受</em> <code class="fe mv mw mx my b"><em class="nc">user=</em></code> <em class="nc">道具，只是为了传递它，因为孙儿或曾孙需要它。</em></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nd"><img src="../Images/03942d1ba031d8f218ae9baf069e7b17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KPGT2NQw_ysCdaCtMY09gw.png"/></div></div></figure><p id="8ca2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Svelte在应用程序中有两种处理状态的存储:<code class="fe mv mw mx my b">writable</code>和<code class="fe mv mw mx my b">readable</code>存储。</p><h2 id="0fdb" class="ne me iq bd mf nf ng dn mj nh ni dp mn la nj nk mp le nl nm mr li nn no mt np bi translated">可写商店</h2><blockquote class="lo"><p id="75b6" class="lp lq iq bd lr ls lt lu lv lw lx lm dk translated"><a class="ae ln" href="https://svelte.dev/docs#writable" rel="noopener ugc nofollow" target="_blank">可写存储</a>是包含可由不同组件访问的值或属性的对象。</p></blockquote><blockquote class="nq nr ns"><p id="fe33" class="kr ks nc kt b ku ly jr kw kx lz ju kz nt ma lc ld nu mb lg lh nv mc lk ll lm ij bi translated">让我们使用可写存储来保存一个值，然后我们可以在我们的应用程序中修改或传递这个值。</p></blockquote><p id="986f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">要访问这个值，您可以从存储中导出它，并将其保存为一个<strong class="kt ir"> JavaScript </strong>文件:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="e606" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后将其导入任何其他组件:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="8b36" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">可写存储器中的值可以改变。</p><p id="0cb3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您需要在导入的任何组件中更改<code class="fe mv mw mx my b">city</code>的值，您可以使用<code class="fe mv mw mx my b">set()</code>方法:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="8171" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">或者您可以使用<code class="fe mv mw mx my b">update()</code>方法运行回调，将当前值作为参数传递:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="dbfb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">另一种方法是使用Svelte的<code class="fe mv mw mx my b">subscribe()</code>方法，让组件监视您在商店中设置的值的变化:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mz na l"/></div></figure><h2 id="0801" class="ne me iq bd mf nf ng dn mj nh ni dp mn la nj nk mp le nl nm mr li nn no mt np bi translated">可读存储</h2><blockquote class="lo"><p id="7e79" class="lp lq iq bd lr ls lt lu lv lw lx lm dk translated"><a class="ae ln" href="https://svelte.dev/docs#readable" rel="noopener ugc nofollow" target="_blank">可读存储</a>顾名思义就是只读存储。</p><p id="dcdf" class="lp lq iq bd lr ls lt lu lv lw lx lm dk translated">如果存储中管理的数据不应由用户操作，则可以使用它。</p></blockquote><p id="11a7" class="pw-post-body-paragraph kr ks iq kt b ku ly jr kw kx lz ju kz la ma lc ld le mb lg lh li mc lk ll lm ij bi translated">可读存储是特殊的，因为<strong class="kt ir">它们不能从外部</strong>更新，没有<code class="fe mv mw mx my b">set()</code>或<code class="fe mv mw mx my b">update()</code>方法。</p><p id="7753" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当使用一个可读存储器时，<strong class="kt ir">你必须在创建它的时候设置它的值</strong>。</p><blockquote class="nq nr ns"><p id="e798" class="kr ks nc kt b ku kv jr kw kx ky ju kz nt lb lc ld nu lf lg lh nv lj lk ll lm ij bi translated">可读存储主要用于处理需要不可变的数据。</p></blockquote><p id="0b0c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们看一个例子，并使用可读存储制作一个计数器:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="6655" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">上面的计数器可以导入到另一个组件中:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mz na l"/></div></figure><h1 id="cca8" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">结论</h1><p id="f95c" class="pw-post-body-paragraph kr ks iq kt b ku nw jr kw kx nx ju kz la ny lc ld le nz lg lh li oa lk ll lm ij bi translated">谈到状态管理，Svelte并不是在重新发明轮子:<br/>我们已经熟悉了通过来自<strong class="kt ir"> React </strong>、<strong class="kt ir"> Angular </strong>和<strong class="kt ir"> Vue </strong>的商店来实现状态管理的想法。</p><p id="3a96" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Svelte的适应性使它成为构建小规模应用程序的绝佳选择，这些应用程序可能需要你在一定程度上处理状态。</p><p id="2db8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">创建定制存储的可能性节省了大量的样板代码(这些代码<a class="ae ln" href="https://blog.codecentric.de/en/2020/02/simplifying-redux-with-the-redux-toolkit/" rel="noopener ugc nofollow" target="_blank">可以被库</a>所取代)，并且允许你用特定领域的逻辑来实现存储。</p><p id="59dc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当然，随着GitHub上<a class="ae ln" href="https://github.com/sveltejs/svelte" rel="noopener ugc nofollow" target="_blank">苗条报告</a>的更多贡献者，我们应该会看到更多有前途的功能和改变。</p><p id="1126" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">感谢阅读！</p></div></div>    
</body>
</html>