<html>
<head>
<title>Does the GitOps emperor have no clothes?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">吉托普斯皇帝没有衣服吗？</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/does-the-gitops-emperor-have-no-clothes-ab1762a77096?source=collection_archive---------14-----------------------#2022-11-07">https://blog.devgenius.io/does-the-gitops-emperor-have-no-clothes-ab1762a77096?source=collection_archive---------14-----------------------#2022-11-07</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="c56d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">热门话题🔥🔥来自一个善良的地方。</p><p id="8d16" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在我开始讨论之前，我想澄清一下，我认为在 git 中以代码形式捕获所有内容有很多好处。静态定义、配方和我们如何制作软件的规范在各方面都是有用的。🌈</p><p id="c8ad" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然而，这些定义并不能帮助我们理解我们的动态环境，这是我对 GitOps 的基本问题。很多人声称 GitOps——它提供了更好的安全性、历史记录，以及漂移和协调的解决方案。我发现自己在想这些是否是真的，在这篇文章中我会解释为什么。</p><p id="7cdb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">GitOps 让我想起了古老的汉斯·克里斯蒂安·安徒生童话，关于什么是真实的，什么是想象的。皇帝宣称他穿着衣服，但如果他实际上什么都没穿呢？</p><h1 id="bbee" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">什么是 GitOps？</h1><p id="c946" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">在我们深入研究之前，让我们基于<a class="ae ll" href="https://www.weave.works/technologies/gitops/" rel="noopener ugc nofollow" target="_blank"> weavework 的四个原则</a>为我们所描述的 GitOps 设置一个基线</p><ol class=""><li id="836c" class="lm ln in jm b jn jo jr js jv lo jz lp kd lq kh lr ls lt lu bi translated">整个系统以声明的方式描述。</li><li id="68f9" class="lm ln in jm b jn lv jr lw jv lx jz ly kd lz kh lr ls lt lu bi translated">在 Git 中，规范的期望系统状态是版本化的。</li><li id="6b99" class="lm ln in jm b jn lv jr lw jv lx jz ly kd lz kh lr ls lt lu bi translated">可以自动应用到系统的已批准的更改。</li><li id="1e02" class="lm ln in jm b jn lv jr lw jv lx jz ly kd lz kh lr ls lt lu bi translated">软件代理确保正确性，并对差异发出警报。</li></ol><p id="c810" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">就像敏捷宣言一样，这四个原则很容易被接受。但是，和敏捷一样，将理论转化为实践是有趣的部分。</p><h1 id="cbac" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">GitOps 实际上是什么样子的？</h1><p id="8156" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">Gitops 强烈强调软件代理不断运行以将系统状态与期望状态融合的思想。</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div class="gh gi ma"><img src="../Images/ac346699bbfe86e2e8049a4a4d1b02d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/0*YCYosbg7QDp152gl.png"/></div></figure><p id="704f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">那么，我们如何使用典型的 GitOps 方法来协调这些状态呢？</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div class="gh gi ma"><img src="../Images/166040c5866d0d98267ba941c5eb5847.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/0*Ki5iF-9hv0pYGhww.png"/></div></figure><p id="2c7a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们将一个操作员(或代理)安装到我们的集群中，它从 git 配置报告中“提取”(稍后将详细介绍)所需的状态，做出决策，并相应地调整工作负载。</p><p id="8478" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是作为标准 DevOps 管道的替代方案提供的，标准 devo PS 管道将更改“推”到集群:</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div class="gh gi ma"><img src="../Images/72c1f4c7e3e2673b068b953a93749aa6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/0*_Mr2V1rSeBU27uGc.png"/></div></figure><p id="7256" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">好了，我们已经概述了理论并描述了基本的实践。现在谈谈 GitOps 的好处。当我们开始实施时，它们是如何实现的？</p><h1 id="036e" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">GitOps 的额外安全措施？🧐</h1><p id="b56c" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">首先，增加安全性。与简单地对我们的集群进行更改相比，采用“基于拉动”的方法有什么好处？主要优势是使用 GitOps，您的 CI 服务器没有生产访问权限，因此我们可以说这提高了我们的安全性。</p><p id="129d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">traditionaldevopsgitopsinfrastructureoperationaldeclarativedesired state untraceableversionedversionedchange ApprovalsTicketsPull requests pull requests deployments manual CI Event+GitOps operators security manual CI 中的 Secrets+infra 中的 secrets</p><p id="522b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然而，这种设置真的有额外的安全性吗？如果 CI 系统可以更新配置，GitOps 如何防止访问 CI 的恶意参与者部署流氓工作负载？🤔</p><h1 id="6e2d" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">版本和环境历史</h1><p id="e41d" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">GitOps 的另一个主要卖点是环境的版本化历史。这是真的，但是如果您的管道和部署信息在源 repo 中，您也可以从普通的旧 DevOps 中得到这一点。这个历史是有用的，但是它并不是环境实际变化的真实记录(稍后将详细介绍)。</p><h1 id="8ec7" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">反转</h1><p id="d386" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">使用 GitOps 回滚更简单吗？我的观点是，您最好通过恢复提交来使用常规的旧 DevOps。这里的好处是它使回滚成为一个标准的开发人员工作流，并使用源存储库进行版本控制。有什么不对劲吗？简单的 git 恢复</p><h1 id="316b" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">灾难恢复</h1><p id="9366" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">当您的整个集群宕机时会发生什么？当您想要启动一个新的集群时会发生什么？这些都是合理的问题。但是大多数团队没有推出蓝/绿集群。大多数公司都有一个或多个静态集群。大多数灾难恢复不会因为需要运行部署管道而受阻，我认为这应该在不需要 GitOps 的情况下编写脚本。</p><p id="2a06" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以，是的，我对它的好处表示怀疑。但是当我们开始考虑我们在实现 GitOps 时必须做出的权衡时，我有更多的保留。让我们看看那些。</p><h1 id="4b80" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">GitOps 面临的挑战</h1><p id="3b4d" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">GitOps 面临的第一大挑战是它对我们管道的影响。将部署从管道的早期阶段中分离出来会导致它们变得分布式。从价值流的角度来看，这很难理解从提交到生产的整个过程。它将资格鉴定的早期阶段与后期阶段分开。</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div class="gh gi ma"><img src="../Images/2bdc32b352b2347b18a00c1ea091658a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/0*dBmZdgT8Y-ZLycYK.png"/></div></figure><p id="c613" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这很重要，因为它从价值流中去除了开发人员的反馈。在这种情况下，如果部署失败，反馈来自哪里？开发人员如何获得部署过程的信息？他们如何通过自己的通知来增强部署过程？他们如何改进部署流程？</p><p id="8609" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">第二个副作用是将这些阶段分成两个工具集增加了开发和操作之间的差距。</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div class="gh gi ma"><img src="../Images/f7f72797a21804b1d234c8bb523340cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/0*HybGEpbgZw3ssHy0.png"/></div></figure><p id="8be2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">通常，GitOps 工具由一个中央平台团队运行和管理。CI 系统通常在团队的领域内。正如麦克卢汉元帅所说，“我们塑造我们的工具，然后我们的工具塑造我们”。</p><p id="8376" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">通过使用单独的配置 repo 来存储所需的状态，差距会进一步扩大:</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div class="gh gi ma"><img src="../Images/a2052679876937117585a18ca025ffac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/0*AQVE-DyR3V61KaH5.png"/></div></figure><p id="177b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">通常，git 存储库以单个微服务为中心，用一个单独的公共 repo 来描述所需的环境状态。一个是以代码和开发人员为中心，一个是以运营为中心。此外，不得不编写 glue pipeline 脚本来更新配置报告的情况并不少见。</p><h1 id="22b4" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">重新审视推与拉</h1><p id="d351" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">GitOps 的主要创新似乎是将运营转移到基于拉动的模式。这似乎是一个很大的变化，但仔细观察后，我认为这实际上是不正确的。[感谢我的好朋友亨里克·霍格给我解释清楚]</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div class="gh gi ma"><img src="../Images/64632955656f81fadce4ea5f53b730a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/0*DX9e0h940OLbEsua.png"/></div></figure><p id="1510" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">通常，GitOps 操作员从 git repo 中读取一个配置，对其应用零到多的转换，然后<strong class="jm io"> <em class="mi">将它</em> </strong>推入 kubernetes API 服务器。这正是您的部署工具在基于推的模型中所做的事情！使用 GitOps，我们将管道分布在两个异步工具上，使用 git 库作为信号量，但是<strong class="jm io">使用这两种方法，我们<em class="mi">将</em>更改推入我们的集群</strong>。</p><h1 id="39c2" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">这是一个伟大的漂移和和解，对不对？</h1><p id="70be" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">GitOps 的另一大优势是协调循环——自动修复任何偏差或手动更改。任何未记录的更改都将被删除，环境将与 git 定义保持一致。</p><p id="7fd1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">从表面上看，这似乎是一笔巨大的奖金。然而，我对此也有不同的看法。在我们开始协调未记录的变更之前，我们需要先问一下<strong class="jm io">它们为什么会发生</strong>。也许我们不想让他们和好？可能有很好的理由进行手动更改，我们可能不希望环境被自动修复。</p><p id="95a4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">另一个原因可能是蓄意破坏，在这种情况下，我们肯定希望人类参与调查和管理这种情况。在任何一种情况下，<strong class="jm io">配置漂移都应该导致适当的事件管理过程</strong>发生，而不仅仅是来自消失在以太网中的协调循环的松弛消息。</p><p id="0335" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">而且技术面，我感觉 Kubernetes 已经有和解循环了。您以声明的方式描述您的部署和配置，Kubernetes 的工作就是实现这一点。分层协调循环感觉像是增加了不必要的复杂性。</p><h1 id="f068" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">地图 git repo 不是区域</h1><p id="0cae" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">我们喜欢认为 git 配置存储库等同于事物如何变化，但实际上在这些静态定义和动态 DevOps 自动化中实际发生的事情之间存在差距。所有这些关于 GitOps 提供“单一真相来源”的说法都是不真实的。如果我想知道周四晚上到底在播什么，没有简单的方法。</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/5fd9b929b330a0e0bfd453b53e686101.png" data-original-src="https://miro.medium.com/v2/resize:fit:1146/format:webp/0*yxWb4XxZKWpYZ06R.png"/></div></figure><p id="ea53" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">GitOps 配置无法洞察手动更改、缩放事件、失败的协调和许多其他边缘情况。这些类型的事件会导致事故，但是当事故发生时，GitOps 不提供情况感知。</p><p id="3705" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当一个事件发生时，我们真正需要的是理解事情是如何<strong class="jm io"> <em class="mi">实际上</em> </strong>发生变化的。现代 GitOps 的一个大问题是开发人员和运营团队很少或没有实际发生的变更的真实记录。我们需要清楚，期望的状态并不是实际的状态。</p><h1 id="58f4" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">静态地看待变化是有益的，但也是有限的</h1><p id="f22a" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">我一开始说我完全支持将我们想要的 DevOps 的配方、定义和规格放入版本控制中。它给我们带来了各种各样的好处。让我们提醒自己它们是什么:</p><ul class=""><li id="c9a8" class="lm ln in jm b jn jo jr js jv lo jz lp kd lq kh mk ls lt lu bi translated"><strong class="jm io">更高的透明度</strong>:以熟悉的技术实现共享、审核和审计</li><li id="5833" class="lm ln in jm b jn lv jr lw jv lx jz ly kd lz kh mk ls lt lu bi translated"><strong class="jm io">代码工具和工作流</strong>:支持基于分支/拉请求的方法来集成变更</li><li id="f248" class="lm ln in jm b jn lv jr lw jv lx jz ly kd lz kh mk ls lt lu bi translated"><strong class="jm io">更好的质量</strong>:允许您在自动化过程中添加棉绒、检验器和静态分析，并强制变更的一致性</li><li id="851f" class="lm ln in jm b jn lv jr lw jv lx jz ly kd lz kh mk ls lt lu bi translated"><strong class="jm io">不变性</strong>:帮助最小化配置漂移</li><li id="d2b0" class="lm ln in jm b jn lv jr lw jv lx jz ly kd lz kh mk ls lt lu bi translated"><strong class="jm io">集中化</strong>:有助于减少“配置蔓延”:分布在多个不相连系统上的流程配置</li></ul><p id="5b99" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">到目前为止还不错——但是每个静态定义都有一个动态执行。有真实的事件发生，异步地和自动地，我们需要记录和理解结果。</p><p id="62dd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">静态定义动态执行构建脚本编译/打包测试套件测试运行部署文件部署 Docker 文件 Docker 映像构建基础架构模型基础架构更改</p><p id="c7cf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">毫不夸张地说，动态世界就是行动的地方。对于开发人员来说，从 GitOps 定义返回到事件、变更、排序和依赖项并不容易。</p><p id="9ea2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你仍然想知道为什么这很重要，谷歌 SRE 的书告诉我们“70%的中断是由于实时系统的变化。”所以，当事情出错时，动态世界应该是我们寻找答案的第一个地方。</p><h1 id="00fc" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">结论——谁是 GitOps？</h1><p id="d5ac" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">就像敏捷宣言一样，GitOps 的松散定义意味着它可以并且将会以各种不同的方式应用。广泛的教会途径是完美的书呆子狙击。terraform 是 GitOps 吗？也许吧？我不知道！</p><p id="5272" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">像敏捷一样，每个人都经历 FOMO。如果这是下一件大事呢？我们会因为害怕被抛在后面而赶潮流吗？对于敏捷，我们需要问“谁是敏捷的？”也许我们需要问“谁是 GitOps？”和以往一样，我们真正需要问自己的是——我们用这些工具为谁服务，我们试图解决什么问题？</p><p id="b1fd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在皇帝的新衣结束时，皇帝周围的人继续称赞他的新衣服，即使他们意识到他是完全赤裸的。当我们全身心投入某事并希望它成真时，我们任何人都会陷入尴尬的境地。就像人群中大喊“但是皇帝什么也没穿！”有时候，把你看到的说出来，让所有事情简单化是件好事。</p></div></div>    
</body>
</html>