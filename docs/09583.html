<html>
<head>
<title>Linked list in Javascript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Javascript 中的链表</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/linked-list-in-javascript-795595742087?source=collection_archive---------1-----------------------#2022-08-30">https://blog.devgenius.io/linked-list-in-javascript-795595742087?source=collection_archive---------1-----------------------#2022-08-30</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/b685fe7289ae131b2a20a695661d1e33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_jLMsU1kyQ2EZXFg7b7PQQ.png"/></div></div></figure><p id="8a5f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">数据结构介绍文章。链表的概念和应用于 Javascript 语言的实例。</p><h1 id="0c50" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">介绍</h1><p id="594c" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">数据结构是有效处理大量数据的一种手段，了解它的结构和组成可以给我们提供更有效的工具来设计与某些问题相关的产品。在这种情况下，我们将执行一个链表的介绍，回顾其特点和用途。</p><h1 id="17d5" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">概念添加到链表中</h1><p id="670d" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">链表是一种线性数据结构，由相互引用的元素组成，也就是说，链表中的每个元素都有一个指向下一个元素的引用对象或指针。注意这些元素存储在存储器中不连续的位置。</p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lw"><img src="../Images/6b3a8dd995c5fe3e9c6b7a04c183e448.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nTSPgu55sqW4GSbenynQaw.png"/></div></div></figure><p id="7668" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">链接列表由以下元素组成:</p><ol class=""><li id="b23c" class="mb mc in jx b jy jz kc kd kg md kk me ko mf ks mg mh mi mj bi translated"><strong class="jx io">链表</strong>:元素管理结构。</li><li id="ac53" class="mb mc in jx b jy mk kc ml kg mm kk mn ko mo ks mg mh mi mj bi translated"><strong class="jx io">节点</strong>:存储和连接元素，包含至少一个任何类型的感兴趣的数据和一个指向下一个节点的指针。</li><li id="a841" class="mb mc in jx b jy mk kc ml kg mm kk mn ko mo ks mg mh mi mj bi translated"><strong class="jx io"> HEAD </strong>:列表的初始节点。</li></ol><h1 id="6e9b" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">链接列表类型</h1><p id="2490" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">链表有多种实现方式，它们的区别在于它们指向的引用，一些实现方式包含循环引用，而另一些实现方式可能包含对后继节点或前趋节点的引用。</p><p id="1d79" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">以下是一些类型的链表:</p><h2 id="a7a7" class="mp ku in bd kv mq mr dn kz ms mt dp ld kg mu mv lh kk mw mx ll ko my mz lp na bi translated">简单链表</h2><p id="7966" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">链表，其中每个节点包含一个唯一的链接后续元素字段。</p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/ede5c9bfc9b9989c72c686df79816037.png" data-original-src="https://miro.medium.com/v2/resize:fit:986/format:webp/1*NPysu84B5uVWsOhGh_aq5w.png"/></div></figure><h2 id="2229" class="mp ku in bd kv mq mr dn kz ms mt dp ld kg mu mv lh kk mw mx ll ko my mz lp na bi translated">双向链表</h2><p id="5bc5" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">链表，其中每个节点包含一个双向链接，节点指向后继元素作为前趋元素。</p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/5b1a6a501b0f270c8cd0046660d1b9e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:986/format:webp/1*OXP3ccWN6InoAaxbd5IUmA.png"/></div></figure><h2 id="7129" class="mp ku in bd kv mq mr dn kz ms mt dp ld kg mu mv lh kk mw mx ll ko my mz lp na bi translated">循环链表</h2><p id="d341" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">类似于简单的链表，区别在于最后一个节点指向列表中的第一个节点。</p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/aace254b3e1d2f9e9d611b6c702e6ab2.png" data-original-src="https://miro.medium.com/v2/resize:fit:980/format:webp/1*TaIgyZGwwBoY54Ru0557FQ.png"/></div></figure><h1 id="16d0" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">在 Javascript 中实现链表</h1><p id="3fa3" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">为了在 Javascript 中实现一个链表，我们将依赖于库<a class="ae nd" href="https://github.com/trekhleb/javascript-algorithms" rel="noopener ugc nofollow" target="_blank">https://github.com/trekhleb/javascript-algorithms</a>，它包含了一个优秀的实现，但是我们将简化一些方法和结构以便能够理解它的操作。我们会支持面向对象编程的所有人。</p><h2 id="5f73" class="mp ku in bd kv mq mr dn kz ms mt dp ld kg mu mv lh kk mw mx ll ko my mz lp na bi translated">类别链接列表</h2><p id="1fb3" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">代表链表的类，这个类将拥有代表初始节点的<code class="fe ne nf ng nh b">head</code>属性。启动时，割台将被设置为<code class="fe ne nf ng nh b">null</code>。LinkedList 类在启动时不会有任何与之关联的节点。</p><pre class="lx ly lz ma gt ni nh nj bn nk nl bi"><span id="4fc5" class="nm ku in nh b be nn no l np nq">class LinkedList {<br/>  constructor() {<br/>    this.head = null;<br/>}</span></pre><h2 id="7592" class="mp ku in bd kv mq mr dn kz ms mt dp ld kg mu mv lh kk mw mx ll ko my mz lp na bi translated">类节点</h2><p id="e4da" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">表示节点的类，这个类将有两个属性，属性<code class="fe ne nf ng nh b">value</code>表示要存储的感兴趣的数据，属性<code class="fe ne nf ng nh b">next</code>表示指向列表中下一个项目的指针。</p><pre class="lx ly lz ma gt ni nh nj bn nk nl bi"><span id="3f6f" class="nm ku in nh b be nn no l np nq">class LinkedList {<br/>  constructor() {<br/>    this.head = null;<br/>}</span></pre><p id="c999" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">接下来的步骤是向<code class="fe ne nf ng nh b">LinkedList</code>类添加方法，这将帮助我们执行列表中节点的操作。例如，元素的插入、搜索和删除。</p><h2 id="c291" class="mp ku in bd kv mq mr dn kz ms mt dp ld kg mu mv lh kk mw mx ll ko my mz lp na bi translated">节点插入方法</h2><p id="241c" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">我们将从向链表中插入节点的基本方法开始。</p><p id="8a3a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">插入节点</strong></p><pre class="lx ly lz ma gt ni nh nj bn nk nl bi"><span id="2794" class="nm ku in nh b be nn no l np nq">insertNode(value) {<br/>  const newNode = new Node(value, null);<br/>  if (this.head === null) {<br/>    this.head = newNode;<br/>  } else {<br/>    let current = this.head;<br/>    while (current.next) {<br/>      current = current.next;<br/>    }<br/>    current.next = newNode;<br/>  }<br/> }<br/>}</span></pre><p id="357a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在代码片段中:</p><ul class=""><li id="1a0a" class="mb mc in jx b jy jz kc kd kg md kk me ko mf ks nr mh mi mj bi translated">使用参数指示的值创建一个新节点。</li><li id="2790" class="mb mc in jx b jy mk kc ml kg mm kk mn ko mo ks nr mh mi mj bi translated">第一个节点存储在<code class="fe ne nf ng nh b">head</code>属性中。</li><li id="c7d3" class="mb mc in jx b jy mk kc ml kg mm kk mn ko mo ks nr mh mi mj bi translated">后续节点将被绑定到最后一个元素的<code class="fe ne nf ng nh b">next</code>属性上，依此类推。</li></ul><p id="bfc1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">注意</strong>:我们可以用<code class="fe ne nf ng nh b">next</code>属性来区分列表的最后一个元素，这将有<code class="fe ne nf ng nh b">null</code>值。</p><h2 id="6455" class="mp ku in bd kv mq mr dn kz ms mt dp ld kg mu mv lh kk mw mx ll ko my mz lp na bi translated">节点显示方法</h2><p id="3046" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">我们将继续使用打印每个节点值的基本方法。</p><p id="f167" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">打印</strong></p><pre class="lx ly lz ma gt ni nh nj bn nk nl bi"><span id="0645" class="nm ku in nh b be nn no l np nq">print(){<br/>  let current = this.head;<br/>  while (current) {<br/>    console.log(current.value);<br/>    current = current.next;<br/>  }<br/>}</span></pre><p id="e77b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在代码片段中:</p><ul class=""><li id="f884" class="mb mc in jx b jy jz kc kd kg md kk me ko mf ks nr mh mi mj bi translated">我们逐个元素地遍历列表，打印属性的<code class="fe ne nf ng nh b">value</code>。</li></ul><h2 id="5a3f" class="mp ku in bd kv mq mr dn kz ms mt dp ld kg mu mv lh kk mw mx ll ko my mz lp na bi translated">节点搜索方法</h2><p id="1217" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">我们将继续介绍一种基于值搜索元素的基本方法。这一次，返回第一个匹配项。</p><p id="7e83" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> findNode </strong></p><pre class="lx ly lz ma gt ni nh nj bn nk nl bi"><span id="53f5" class="nm ku in nh b be nn no l np nq">findNode(value) {<br/>  let current = this.head;<br/>  while (current) {<br/>    if (current.value === value) {<br/>      return current;<br/>    }<br/>    current = current.next;<br/>  }<br/>  return null;<br/>}</span></pre><p id="9ed1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在代码片段中:</p><ul class=""><li id="9ca7" class="mb mc in jx b jy jz kc kd kg md kk me ko mf ks nr mh mi mj bi translated">我们对 while 循环使用相同的元素遍历技术，但是添加了一个比较值的条件。</li><li id="707f" class="mb mc in jx b jy mk kc ml kg mm kk mn ko mo ks nr mh mi mj bi translated">如果值等于要查找的值，则返回元素。</li><li id="5c68" class="mb mc in jx b jy mk kc ml kg mm kk mn ko mo ks nr mh mi mj bi translated">如果值不相等，它继续在列表中循环。</li><li id="664f" class="mb mc in jx b jy mk kc ml kg mm kk mn ko mo ks nr mh mi mj bi translated">如果没有找到元素，则返回<code class="fe ne nf ng nh b">null</code>。</li></ul><h2 id="bf29" class="mp ku in bd kv mq mr dn kz ms mt dp ld kg mu mv lh kk mw mx ll ko my mz lp na bi translated">节点移除方法</h2><p id="f9e0" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">我们将继续使用一种基于价值移除项目的基本方法。</p><p id="e9f2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">删除节点</strong></p><pre class="lx ly lz ma gt ni nh nj bn nk nl bi"><span id="950a" class="nm ku in nh b be nn no l np nq">deleteNode(value) {<br/>  if (this.head.value === value) {<br/>    this.head = this.head.next;<br/>  } else {<br/>    let current = this.head;<br/>    while (current.next) {<br/>    if (current.next.value === value) {<br/>       current.next = current.next.next;<br/>       return;<br/>    }<br/>    current = current.next;<br/>  }<br/> }<br/>}</span></pre><p id="030a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在代码片段中:</p><ul class=""><li id="020a" class="mb mc in jx b jy jz kc kd kg md kk me ko mf ks nr mh mi mj bi translated">我们遍历列表中的元素，找到带有值的节点。</li><li id="7903" class="mb mc in jx b jy mk kc ml kg mm kk mn ko mo ks nr mh mi mj bi translated">如果我们找到了节点，我们要做的是省略列表中的元素，也就是说，我们将跳过与后续元素连接的元素，完全消除当前引用。</li></ul><h2 id="08b1" class="mp ku in bd kv mq mr dn kz ms mt dp ld kg mu mv lh kk mw mx ll ko my mz lp na bi translated">完整代码</h2><pre class="lx ly lz ma gt ni nh nj bn nk nl bi"><span id="b39f" class="nm ku in nh b be nn no l np nq">class Node {<br/>  constructor(value, next) {<br/>    this.value = value;<br/>    this.next = next;  <br/>  }<br/>}<br/><br/>class LinkedList {<br/>  constructor() {<br/>    this.head = null;<br/>  }<br/>  <br/>  insertNode(value) {<br/>    const newNode = new Node(value, null);<br/>    if (this.head === null) {<br/>      this.head = newNode;<br/>    } else {<br/>      let current = this.head;<br/>      while (current.next) {<br/>        current = current.next;<br/>      }<br/>      current.next = newNode;<br/>    }<br/>  }<br/><br/>  print(){<br/>    let current = this.head;<br/>    while (current) {<br/>      console.log(current.value);<br/>      current = current.next;<br/>    }<br/>  }<br/><br/>  deleteNode(value) {<br/>    if (this.head.value === value) {<br/>      this.head = this.head.next;<br/>    } else {<br/>      let current = this.head;<br/>      while (current.next) {<br/>        if (current.next.value === value) {<br/>          current.next = current.next.next;<br/>          return;<br/>        }<br/>        current = current.next;<br/>      }<br/>    }<br/>  }<br/><br/>  findNode(value) {<br/>    let current = this.head;<br/>    while (current) {<br/>      if (current.value === value) {<br/>        return current;<br/>      }<br/>      current = current.next;<br/>    }<br/>    return null;<br/>  }<br/>}<br/><br/>const linkedList = new LinkedList();<br/>linkedList.insertNode(12);<br/>linkedList.insertNode(99);<br/>linkedList.insertNode(37);<br/>linkedList.print();<br/>console.log(linkedList.findNode(37));</span></pre><h1 id="c915" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">结局</h1><p id="19a4" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">在本文中，我们使用链表的基本方法，然而，这些方法应该足以涵盖链表的基本用例。当然，有许多方法可以扩展和改进我们的例子。我建议继续探索实现，并使它们适应您的需要。</p></div><div class="ab cl ns nt hr nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ig ih ii ij ik"><p id="7a29" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">感谢你远道而来，如果你觉得这很有用，别忘了鼓掌👏。订阅以接收更多内容🔔。</p><p id="532c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你需要额外的帮助，请联系我🤠。</p><ul class=""><li id="60b4" class="mb mc in jx b jy jz kc kd kg md kk me ko mf ks nr mh mi mj bi translated">✉️ <a class="ae nd" href="mailto:dcortes.net@gmail.com" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io">给我发邮件</strong> </a></li><li id="323a" class="mb mc in jx b jy mk kc ml kg mm kk mn ko mo ks nr mh mi mj bi translated">🤝<a class="ae nd" href="https://www.linkedin.com/in/dcortesnet/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io">在 LinkedIn 上联系我</strong> </a></li><li id="cbe1" class="mb mc in jx b jy mk kc ml kg mm kk mn ko mo ks nr mh mi mj bi translated">📮<a class="ae nd" href="https://twitter.com/dcortes_net" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io">在推特上联系我</strong> </a></li></ul><p id="3336" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">非常感谢您的阅读，我感谢您的时间。</p></div></div>    
</body>
</html>