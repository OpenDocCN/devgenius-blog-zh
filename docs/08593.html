<html>
<head>
<title>DataBase Replication 101</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据库复制 101</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/database-replication-101-d148514598a7?source=collection_archive---------14-----------------------#2022-06-26">https://blog.devgenius.io/database-replication-101-d148514598a7?source=collection_archive---------14-----------------------#2022-06-26</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="582f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这篇博客是我们从零开始讨论 101 个<strong class="jm io"> </strong>概念的系列文章的一部分，读者的入门知识有限。本文属于<strong class="jm io"> <em class="ki">中级</em> </strong>系列，因为它涉及对<strong class="jm io">数据库复制</strong>的理解，数据库复制主要用于复制分布在<a class="ae kj" href="https://aws.amazon.com/about-aws/global-infrastructure/regions_az/" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io">数据中心、可用性区域和云区域</strong> </a> <strong class="jm io"> </strong>的多个节点中的应用程序数据，以确保在单个节点出现故障时的数据可用性。</p><p id="7d73" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">101 系列中的一些早期博客如下:</p><p id="961c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae kj" rel="noopener ugc nofollow" target="_blank" href="/database-sharding-101-4ef36046c29c"> <strong class="jm io">数据库分片 101 </strong> <br/> </a> <a class="ae kj" rel="noopener ugc nofollow" target="_blank" href="/caching-strategy-101-3bc974d2a6cd"> <strong class="jm io">缓存策略 101</strong><br/></a><a class="ae kj" rel="noopener ugc nofollow" target="_blank" href="/cors-101-72b462396deb"><strong class="jm io">CORS 101</strong></a><strong class="jm io"><br/></strong><a class="ae kj" rel="noopener ugc nofollow" target="_blank" href="/circuit-breaker-pattern-101-be2d7fdb656"><strong class="jm io">断路器 101 </strong> <br/> </a> <a class="ae kj" rel="noopener ugc nofollow" target="_blank" href="/priority-queues-101-40eb4f6f5ee9"> <strong class="jm io">优先级队列 101</strong><strong class="jm io"><a class="ae kj" rel="noopener ugc nofollow" target="_blank" href="/async-communication-101-b04d5c95333a"><strong class="jm io"><br/>异步通信 101 </strong></a></strong></a></p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi kk"><img src="../Images/0e454ac42b230ffb229dd35723fa8cd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XFvyGQFAb3-tKXLyOO62lA.png"/></div></div></figure><h1 id="99af" class="kw kx in bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">什么是数据库复制？</h1><p id="41f6" class="pw-post-body-paragraph jk jl in jm b jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh ig bi translated">数据库复制是将应用程序数据的多个副本创建到一个或多个数据库服务器中的过程。复制可以实时进行，即主服务器上的每个<strong class="jm io">数据库操作查询</strong>都可以实时进行，或者在一天中以预定的频率定期进行。</p><p id="9265" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">此外，根据整个业务领域的<strong class="jm io">恢复点目标</strong>需求，在生产中进行同步或异步技术之间的设计选择。数据复制的主要目标是<strong class="jm io">减少停机时间，提高数据可用性，并在某些情况下通过使用只读操作的读取副本来减少应用程序延迟</strong>。</p><h1 id="c945" class="kw kx in bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">数据复制的类型</h1><p id="c8a3" class="pw-post-body-paragraph jk jl in jm b jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh ig bi translated">不同的云供应商有不同的数据复制技术来在多个数据库实例之间复制数据。然而，<strong class="jm io">将数据库事务标记为完成并触发返回给客户端</strong>的确认的底层机制用于将技术分为以下类型</p><h2 id="3d25" class="lz kx in bd ky ma mb dn lc mc md dp lg jv me mf lk jz mg mh lo kd mi mj ls mk bi translated">异步复制</h2><p id="afe6" class="pw-post-body-paragraph jk jl in jm b jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh ig bi translated">在异步复制中，一旦主服务器上的数据更新，客户端就会收到确认。对从设备的复制在后台发生，并且使用<a class="ae kj" href="https://severalnines.com/database-blog/what-look-if-your-mysql-replication-lagging" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io">复制滞后</strong> </a>度量来测量延迟。</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi ml"><img src="../Images/574e913dce9dfbaf235f6f7ecfed4d2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-DEIaIV89Yznq7FN7adCMg.jpeg"/></div></div></figure><p id="a154" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">由于存在延迟，因此在复制延迟期间，如果发生中断，从属服务器上的数据将会丢失。因此，这种方法在业务要求<strong class="jm io">零数据丢失</strong>的应用中不是首选。</p><h2 id="436a" class="lz kx in bd ky ma mb dn lc mc md dp lg jv me mf lk jz mg mh lo kd mi mj ls mk bi translated">同步复制</h2><p id="6671" class="pw-post-body-paragraph jk jl in jm b jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh ig bi translated">在同步复制中，数据库事务仅在向从服务器传播并应用了<strong class="jm io"> DML 事务更改</strong>后才会被标记为完成，即从服务器与主服务器一致。</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi mm"><img src="../Images/bd1e015b1be6f454a94ab4f5c2b220d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*us_KjVpxV6SpkuLqYx7P8Q.jpeg"/></div></div></figure><p id="b09a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">由于<strong class="jm io">复制传播和将</strong>应用到从设备是事务中的额外步骤，因此这种方法较慢，尤其是在跨区域写入事件的情况下。因此，对于有严格延迟要求的应用程序，这种方法不是首选。</p><h2 id="02ac" class="lz kx in bd ky ma mb dn lc mc md dp lg jv me mf lk jz mg mh lo kd mi mj ls mk bi translated">半同步复制</h2><p id="8a07" class="pw-post-body-paragraph jk jl in jm b jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh ig bi translated">半同步复制等待复制更改传播到辅助服务器，但是实际复制到从属服务器可能发生在确认发送回客户端之后。</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi mm"><img src="../Images/37ee36bd0f31b39338a58bee592b0b88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AZOZ9itkehWKKqNuoZx3-A.jpeg"/></div></div></figure><h1 id="fd4b" class="kw kx in bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">多主机对单主机</h1><p id="aa51" class="pw-post-body-paragraph jk jl in jm b jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh ig bi translated">复制策略可以根据作为数据库服务器一部分的<strong class="jm io">主节点(读/写)</strong>的数量以及复制过程的<strong class="jm io">单向/双向</strong>性质进行分类。</p><h2 id="175d" class="lz kx in bd ky ma mb dn lc mc md dp lg jv me mf lk jz mg mh lo kd mi mj ls mk bi translated"><strong class="ak">单主</strong></h2><p id="64ac" class="pw-post-body-paragraph jk jl in jm b jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh ig bi translated">在单主设置中，数据仅写入主服务器，并使用不同的复制策略复制到从服务器(<a class="ae kj" href="https://www.keboola.com/blog/database-replication-techniques" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io">基于日志、基于快照、基于密钥等</strong> </a>)。</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/84db897973a2f0a5c568760f42bb01f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:982/format:webp/1*mfdp8JSgPPWoslmjf_g23A.jpeg"/></div></figure><p id="0e37" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">给定用于主数据写入的单个节点，单主机设置总是一致的。如果主服务器出现故障，该设置需要一个额外的<strong class="jm io">故障转移步骤(手动/自动)</strong>才能从客户端取回写查询。</p><h2 id="375a" class="lz kx in bd ky ma mb dn lc mc md dp lg jv me mf lk jz mg mh lo kd mi mj ls mk bi translated"><strong class="ak">多主</strong></h2><p id="1396" class="pw-post-body-paragraph jk jl in jm b jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh ig bi translated">在多主设置中，来自客户端的数据可以写入任何主服务器。复制工作<strong class="jm io">双向</strong>以确保数据在<strong class="jm io">冲突解决</strong>后最终保持一致，以更新相似的实体。</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi mo"><img src="../Images/7e3115434bc0ae26e5122f60931a9edf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*akg3sVOPkdZgS38v8YBqtg.jpeg"/></div></div></figure><p id="fdfc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果其中一个主服务器离线，剩下的主服务器可以处理来自客户端的写负载，因此在这个设置中需要<strong class="jm io">数据库故障转移</strong>。</p><h1 id="b7d3" class="kw kx in bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">摘要</h1><p id="5a1e" class="pw-post-body-paragraph jk jl in jm b jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh ig bi translated">复制有助于满足关键业务领域的高可用性和灾难恢复需求，以便在停机时无缝运行。它与整体功能架构计算层的流量路由策略有效结合，解决了 RTO 和 RPO 一致性问题。大多数 PAAS 数据库，如<strong class="jm io"> Post Gress、My SQL、Azure SQL、Azure Cosmos、Aurora 等</strong>都有自动复制设置，以简化最终客户的最小操作设置。</p><p id="3033" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在本系列的专家博客中，我们将通过一个数据库示例来深入探讨基于日志、基于快照、基于键的复制策略。</p><p id="d99f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ki">如需反馈，请留言至</em><strong class="jm io"><em class="ki">Amit[dot]894[at]Gmail[dot]com</em></strong><em class="ki">或联系</em><a class="ae kj" href="https://about.me/amit_raj" rel="noopener ugc nofollow" target="_blank"><em class="ki">https://about.me/amit_raj</em></a><em class="ki">的任何链接。</em></p></div></div>    
</body>
</html>