<html>
<head>
<title>Implementing a distributed lock with Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 Go 实现分布式锁</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/implementing-a-distributed-lock-with-go-and-dbus-85a3f5ea0fb9?source=collection_archive---------2-----------------------#2022-08-12">https://blog.devgenius.io/implementing-a-distributed-lock-with-go-and-dbus-85a3f5ea0fb9?source=collection_archive---------2-----------------------#2022-08-12</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="ed09" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">用 dBus 实现分布式锁 via 的方法</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/c41b4da276294c48b977eafddd793cd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4NqJMhg2UnIQY0XT"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">图片<a class="ae ks" href="https://unsplash.com/@deepmind" rel="noopener ugc nofollow" target="_blank"> DeepMind </a> via unsplash</figcaption></figure><p id="baba" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">微服务架构是一种分布式系统，因为它将应用程序分解为独立的组件与整体架构不同，微服务架构由多个服务组成，每个服务处理应用程序功能的一个方面。随着 Kubernetes 等工具简化微服务的部署，这已经成为一种非常普遍的做法。而且你也不能怪开发者，因为微服务提供了多个故障点。多点故障使平台即使在其中一个服务关闭时也能运行。随着微服务的出现，帮助这些“微进程”通信的方法被开发出来。在这篇文章中，我将详细介绍我用 dBus 实现分布式锁的方法。如果你想知道，dBus“是一个消息总线系统，一种应用程序相互通信的简单方式。”我选择 dBus 是因为我想要一个利用预安装的 Linux 组件的解决方案。</p><h1 id="781e" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated"><strong class="ak">初始设置</strong></h1><p id="b8af" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">为了访问 dBus，我将实现包<code class="fe mm mn mo mp b">github.com/godbus/dbus/v5</code>。这个包提供了与 dBus 通信的绑定。我要做的第一件事是定义我的自定义锁类型。以下是该类型的定义:</p><pre class="kd ke kf kg gt mq mp mr ms aw mt bi"><span id="f5e0" class="mu lq in mp b gy mv mw l mx my">type BusLock struct {<br/> conn *dbus.Conn<br/> mu  *sync.Mutex<br/> id   string<br/>}</span></pre><p id="dca9" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">以下是每个字段的作用:</p><ul class=""><li id="c1f6" class="mz na in kv b kw kx kz la lc nb lg nc lk nd lo ne nf ng nh bi translated"><code class="fe mm mn mo mp b">conn</code>:连接到<code class="fe mm mn mo mp b">dbus</code>。这将用于发送和接收锁定消息。</li><li id="16ce" class="mz na in kv b kw ni kz nj lc nk lg nl lk nm lo ne nf ng nh bi translated"><code class="fe mm mn mo mp b">mu</code>:底层互斥，由接收到的消息锁定/解锁。</li><li id="4d89" class="mz na in kv b kw ni kz nj lc nk lg nl lk nm lo ne nf ng nh bi translated"><code class="fe mm mn mo mp b">id</code>:dBus 连接的唯一标识符。这用于防止程序处理自己的消息。</li></ul><p id="176d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">接下来，我将定义一个函数来初始化一个<code class="fe mm mn mo mp b">BusLock</code>对象。该功能将通过连接到系统总线来启动。然后在连接上放置一个滤波器，只接受路径<code class="fe mm mn mo mp b">/medium/examples/lock</code>的信号。提取连接 id，并将其设置为返回的<code class="fe mm mn mo mp b">BusLock</code>对象的属性，以及连接和互斥锁。下面是该函数的代码:</p><pre class="kd ke kf kg gt mq mp mr ms aw mt bi"><span id="2642" class="mu lq in mp b gy mv mw l mx my">func NewBusLock() (b BusLock, err error) {</span><span id="8162" class="mu lq in mp b gy nn mw l mx my"> conn, err := dbus.<strong class="mp io">SystemBus</strong>()<br/> if err != nil {<br/>  return<br/> }</span><span id="b9e0" class="mu lq in mp b gy nn mw l mx my"> if err = conn.<strong class="mp io">AddMatchSignal</strong>(<br/>   dbus.WithMatchObjectPath(<strong class="mp io">"/medium/examples/lock"</strong>),<br/> ); err != nil {<br/>  return<br/> }</span><span id="a1b2" class="mu lq in mp b gy nn mw l mx my"> ids := conn.Names()<br/> var m sync.Mutex</span><span id="6ff9" class="mu lq in mp b gy nn mw l mx my"> b = BusLock{<br/>   conn: conn,<br/>   id:   ids[0],<br/>   mu : &amp;m,<br/> }</span><span id="b7e8" class="mu lq in mp b gy nn mw l mx my"> return<br/>}</span></pre><p id="dfed" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">接下来，我将定义一个 struct 方法来监听和处理传入的信号。我给它取名<code class="fe mm mn mo mp b">Listen</code>。这就是奇迹开始发生的地方。方法<code class="fe mm mn mo mp b">Listen</code>的唯一职责是跨应用程序实例同步互斥状态。该功能将首先初始化一个类型为<code class="fe mm mn mo mp b">dbus.Signal</code>的通道。它会将通道指定为传入消息的接收者。然后，我利用一个循环来检查消息数据。我检查是否通过了<code class="fe mm mn mo mp b">true</code>或<code class="fe mm mn mo mp b">false</code>，并相应地更新锁。下面是方法<code class="fe mm mn mo mp b">Listen</code>的代码:</p><pre class="kd ke kf kg gt mq mp mr ms aw mt bi"><span id="655a" class="mu lq in mp b gy mv mw l mx my">func (b BusLock) Listen() {</span><span id="6da3" class="mu lq in mp b gy nn mw l mx my">   c := make(chan *dbus.<strong class="mp io">Signal</strong>, 10)</span><span id="acf9" class="mu lq in mp b gy nn mw l mx my">   b.conn.<strong class="mp io">Signal</strong>(c)</span><span id="20eb" class="mu lq in mp b gy nn mw l mx my">   fmt.Println("listening")</span><span id="6d7e" class="mu lq in mp b gy nn mw l mx my">   for v := range c {</span><span id="5b69" class="mu lq in mp b gy nn mw l mx my">    if v.Sender == b.id {<br/>     continue<br/>    }</span><span id="37fa" class="mu lq in mp b gy nn mw l mx my">    action := v.Body[0].(bool)<br/>    fmt.Println("From : ", v.Sender, v)</span><span id="19e4" class="mu lq in mp b gy nn mw l mx my">    if action {<br/>     b.mu.<strong class="mp io">Lock</strong>()<br/>     fmt.Println("Locking")<br/>     continue<br/>    }</span><span id="4768" class="mu lq in mp b gy nn mw l mx my">    fmt.Println("UnLocking")<br/>    b.mu.<strong class="mp io">Unlock</strong>()<br/> <br/> }<br/>}</span></pre><p id="c196" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">接下来，我将为类型<code class="fe mm mn mo mp b">BusLock</code>再添加两个方法。这些方法将负责锁定和解锁互斥体，以及发布事件。这两种方法的定义如下:</p><pre class="kd ke kf kg gt mq mp mr ms aw mt bi"><span id="a487" class="mu lq in mp b gy mv mw l mx my">func (b *BusLock) Lock (){</span><span id="f016" class="mu lq in mp b gy nn mw l mx my">  b.mu.Lock()<br/>  b.conn.Emit("/medium/examples/lock", "medium.examples.lock", true)<br/>}</span><span id="d26b" class="mu lq in mp b gy nn mw l mx my">func (b *BusLock) UnLock () {</span><span id="9d2e" class="mu lq in mp b gy nn mw l mx my">  b.mu.Unlock()<br/>  b.conn.Emit("/medium/examples/lock", "medium.examples.lock", false)<br/>}</span></pre><p id="9caa" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在我已经有了执行我想要的功能的最小代码集，我将开始实现。</p><h1 id="fa67" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">实施</h1><p id="6b04" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">为了实现它，我将首先调用<code class="fe mm mn mo mp b">NewBusLock</code>来初始化一个<code class="fe mm mn mo mp b">BusLock</code>类型的实例。初始化之后，我将调用 Goroutine 上的方法<code class="fe mm mn mo mp b">Listen</code>来监听传入的消息。在这篇文章中，我将添加另一个 Goroutine 来更好地说明我的观点。Goroutine 将锁定 10 秒。我会在里面写代码来测量这个过程的时间。下面是实现过程:</p><pre class="kd ke kf kg gt mq mp mr ms aw mt bi"><span id="4afe" class="mu lq in mp b gy mv mw l mx my">func main() {</span><span id="0806" class="mu lq in mp b gy nn mw l mx my"> bl, err := NewBusLock()</span><span id="a1dc" class="mu lq in mp b gy nn mw l mx my"> if err != nil {<br/>   log.Fatal(err)<br/> }</span><span id="5943" class="mu lq in mp b gy nn mw l mx my"> go bl.Listen()</span><span id="e6ba" class="mu lq in mp b gy nn mw l mx my"> go func(){</span><span id="bfed" class="mu lq in mp b gy nn mw l mx my">       now := time.Now()<br/>       // wait for other instance to set lock<br/>       time.Sleep(5 * time.Second)</span><span id="3f23" class="mu lq in mp b gy nn mw l mx my">       bl.Lock()<br/>       time.Sleep(10 * time.Second)<br/>       bl.UnLock()</span><span id="69e1" class="mu lq in mp b gy nn mw l mx my">       fmt.Println( time.Since(now) )</span><span id="ed91" class="mu lq in mp b gy nn mw l mx my">  }()<br/>  </span><span id="277f" class="mu lq in mp b gy nn mw l mx my">  // will keep program alive  <br/>  c := make(chan int)</span><span id="2cb9" class="mu lq in mp b gy nn mw l mx my">  &lt;-c</span><span id="ab7a" class="mu lq in mp b gy nn mw l mx my">}</span></pre><p id="91c1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我会运行这个程序两次。第一个应该不超过 15 秒，第二个应该至少需要 20 秒。第二个程序需要 20 秒，因为它在等待锁被释放(10 秒)并执行自己的操作，也是 10 秒。下面是这个想法在实践中的 gif 图:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi no"><img src="../Images/1a49938aca43048cb09e2b93c9c9d7fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*tpfsRdeZPn-F1g-d.gif"/></div></figure><h1 id="5b8d" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">结论</h1><p id="d61b" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">我选择用 dBus 实现分布式锁，因为它不需要在 Linux 等系统上下载额外的软件(如 redis)。这只是一个初始的<strong class="kv io">原型</strong>，因为它似乎只适用于<strong class="kv io"> 2 实例</strong>。我计划将来对它进行迭代。至于我的“Kuberneters”，dBus 有 TCP 支持。</p><p id="e9ff" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">不过，这种解决方案也有一些缺陷。外部系统组件的意外行为可能会导致此实现中断。另一件事是，锁发布后启动的实例不会收到当前状态。解决这个问题的一个方法是在启动时读取锁的状态。死锁也是一个问题，但是可以通过超时来缓解，以防实例在解锁之前崩溃。你可以在最下面找到这篇文章中使用的代码。</p><p id="f1b3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">附加链接</strong></p><div class="np nq gp gr nr ns"><a href="https://www.atlassian.com/microservices/microservices-architecture/distributed-architecture" rel="noopener  ugc nofollow" target="_blank"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd io gy z fp nx fr fs ny fu fw im bi translated">什么是分布式系统？亚特兰蒂斯人</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">分布式系统是一个计算机程序的集合，它利用跨多个…</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">www.atlassian.com</p></div></div></div></a></div><div class="np nq gp gr nr ns"><a href="https://www.freedesktop.org/wiki/Software/dbus/" rel="noopener  ugc nofollow" target="_blank"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd io gy z fp nx fr fs ny fu fw im bi translated">dbus</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">D-Bus 是一种消息总线系统，是应用程序之间相互通信的一种简单方式。除了进程间…</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">www.freedesktop.org</p></div></div></div></a></div><div class="np nq gp gr nr ns"><a href="https://github.com/godbus/dbus" rel="noopener  ugc nofollow" target="_blank"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd io gy z fp nx fr fs ny fu fw im bi translated">GitHub-godbus/dbus:D-Bus 的本地 Go 绑定</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">dbus 是一个简单的库，它为 D-Bus 消息总线系统实现了本地 Go 客户端绑定。完整的原生…</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">github.com</p></div></div></div></a></div><div class="np nq gp gr nr ns"><a href="https://github.com/cheikhshift/medium_examples/tree/main/distributed-lock" rel="noopener  ugc nofollow" target="_blank"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd io gy z fp nx fr fs ny fu fw im bi translated">medium _ examples/main cheikh shift 上的分布式锁/medium_examples</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">中型文章的代码示例。在 GitHub 上创建一个帐户，为 cheikhshift/medium_examples 开发做贡献。</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">github.com</p></div></div></div></a></div></div></div>    
</body>
</html>