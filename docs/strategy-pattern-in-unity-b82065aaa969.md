# 统一战略模式

> 原文：<https://blog.devgenius.io/strategy-pattern-in-unity-b82065aaa969?source=collection_archive---------0----------------------->

## 能力系统

比方说，我有一个技能系统，目前由一个枚举组成，包括火球术、狂怒、治疗和近战。我有一个使用当前选定能力的方法。在更新方法中，当空格键被按下时，它使用当前能力。

![](img/002c281b34303bee75a0e950b597326a.png)

能力赛跑者

现在的问题是，一个技能越复杂，我需要添加到这个脚本中的代码就越多。真的没有办法把这些分离出来。另一个问题是，如果我想增加更多的能力，装备多个能力，或者根据按键的不同而拥有不同的能力。这可能会很快失控。

## 更好的方法。

有能力跑者还有一个当前的能力场。

![](img/0aeadb1184515396d92c777b5438e56d.png)

能力赛跑者

这个能力指向一个有使用方法的接口。

![](img/156aefdbf862df08bfdf3a800d4430c9.png)

能力界面

这样我就可以从能力接口中获得能力

![](img/904a5f9d874add11078cf7b3e4d189d1.png)

能力

现在，如果我在这里更改名称，我刚才实现的是策略模式。

![](img/ecfa673502297048c04a09ce990633d0.png)

能力系统是战略模式

# 策略模式到底是什么

![](img/87bcb5145f5a039c3170b5a110701808.png)

战略模式

策略模式就是将行为或算法封装或包装在自己的类中。它的额外好处是允许在运行时分配行为或算法！如果您有一堆 If 语句或 switch 语句试图控制或调整行为，那么策略模式可能正是您清理代码所需要的。根据策略模式，类的行为不应该被继承。相反，它们应该使用接口封装。这与开放但封闭的实体原则是一致的，该原则提出类应该对扩展开放，但对修改封闭。这是一个很好的模式来创造能力系统，人工智能行为，或者武器系统。尽管我更喜欢用 Unity 的动画系统来创造我的人工智能行为。

## 定义

*   **策略** —声明一个所有支持的算法通用的接口。上下文使用这个接口来调用由具体策略定义的算法。
*   **具体策略** —使用策略接口实现算法。
*   **上下文** —配置有具体的策略对象。维护对策略对象的引用。可以定义一个接口，让策略访问它的数据。

# 履行

## 可靠性

![](img/156aefdbf862df08bfdf3a800d4430c9.png)

能力界面

第一步是创建能力界面

![](img/b8a44b47f74264f488e9c8df7dd7f021.png)

能力接口代码

转换能力跑步者使用新的界面

![](img/518f4dad10a6729d8fef25574055d7f7.png)

## 能力

下一步是创建每种能力，让它们实现责任接口。

![](img/2ddcd3adf3c9b4dc9fe5ceb86f68eb8e.png)

火球能力

![](img/2e6038dd73678bb38f22aec92adbc206.png)

愤怒能力

![](img/5b08bc65c55f867fbd3f4dae457914bf.png)

治愈能力

![](img/59cba2f100203c19169a7b23fbf407f9.png)

近战能力

## 使用能力

目前能力跑者不使用我新创造的任何能力。我需要一种方法来改变能力跑步者的当前能力，我目前不能用检查器这样做，因为 Unity 不序列化接口(内置)，这意味着我不能在检查器中分配这个字段。

![](img/ff9ad5bd9f894f9e4f81db62b4fc9a87.png)

能力赛跑者游戏对象

有许多不同的方法来实现这一点，我打算用最快的方法。我将添加一个当前能力属性，并创建一个单独的 Monobehavior 来改变能力。

![](img/587f3fadb8e3c404484eb710d42f7dff.png)

添加当前能力属性

现在我可以很容易地改变能力。

![](img/fdaf6795bf663e89538ed0c339e7bef5.png)

能力改变者

![](img/7a0ac5ad6b967bdd3cd2885f2ab35017.png)

行动能力

# 结论

策略模式是工具箱中的一个有用工具。我可以用它来清理我能力系统中的代码，使它更加可靠。现在我的代码对扩展开放，但对修改关闭。这也使得我的每个代码都有一个单独的职责。我可以很容易地在我的系统中添加新的能力来做不同的事情。如果我想改变一个能力的工作方式，我需要做的就是改变一个能力，我不需要在 switch 语句中找到它。，也很容易改变能力的使用方式。事实上，它们是一个接口，允许我把任何东西都变成一种能力。例如，我可以把火球变成一个单体行为，然后把它变成一个预置，或者我可以把治疗能力变成一个可脚本化的物体。我可以把近战能力变成一种武器。只要他们坚持接口，这并不重要。

当然，它也遵循了利斯科夫的替换法——“*派生类或子类必须可以替换它们的基类或父类*”、接口分离——“*不要强迫任何客户端实现与它们无关的接口*”、以及依赖倒置——*“高级模块不应该依赖于低级模块，而应该依赖于抽象。抽象不应该依赖于细节；更确切地说，细节应该取决于抽象。”，*但这是设计好的。策略模式本身实际上只解决了前两个基本原则，其余的都是在设计代码时遵循的。

代码可以在我的 Git Hub 页面上找到

[](https://github.com/JamesLaFritz/Design-Patterns-For-Unity/tree/release-StrategyPattern) [## GitHub-JamesLaFritz/Design-Patterns-For-Unity 发布时-StrategyPattern

### 报告 Bug 请求特性展示了 Unity 中不同的编程设计模式。有许多不同的…

github.com](https://github.com/JamesLaFritz/Design-Patterns-For-Unity/tree/release-StrategyPattern)