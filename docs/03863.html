<html>
<head>
<title>Spring WebClient vs RestTemplate — Comparison and Features</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Spring WebClient 与 rest template——比较和特性</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/spring-webclient-vs-resttemplate-comparison-and-features-c4390b7372ca?source=collection_archive---------1-----------------------#2020-12-27">https://blog.devgenius.io/spring-webclient-vs-resttemplate-comparison-and-features-c4390b7372ca?source=collection_archive---------1-----------------------#2020-12-27</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><h1 id="f780" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">介绍</h1><p id="a654" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">Spring 5 引入了一个新的反应式 web 客户端，叫做 web client。在这篇文章中，我将展示我们何时以及如何使用 Spring WebClient vs RestTemplate。我还将描述 WebClient 提供的特性。</p><h1 id="b5bf" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">什么是 RestTemplate？</h1><p id="d3bd" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">RestTemplate 是一个中央 Spring 类，允许从客户端进行 HTTP 访问。<code class="fe lh li lj lk b">RestTemplate</code>提供 POST、GET、PUT、DELETE、HEAD 和 OPTIONS HTTP 方法。RestTemplate 的简单用例是消费 Restful web 服务。</p><p id="f5d0" class="pw-post-body-paragraph ki kj in kk b kl ll kn ko kp lm kr ks kt ln kv kw kx lo kz la lb lp ld le lf ig bi translated">您可以创建一个提供 RestTemplate 实例的 bean。然后，您可以在计划调用 REST 服务的任何类中<code class="fe lh li lj lk b">@autowire</code>这个 bean。RestTemplate 是实现接口<code class="fe lh li lj lk b">RestOperations</code>的类。</p><p id="cd64" class="pw-post-body-paragraph ki kj in kk b kl ll kn ko kp lm kr ks kt ln kv kw kx lo kz la lb lp ld le lf ig bi translated">以下代码显示了 bean 的声明:</p><pre class="lq lr ls lt gt lu lk lv lw aw lx bi"><span id="aadc" class="ly jl in lk b gy lz ma l mb mc">@Bean public RestOperations restOperations() <br/>{ <br/>  return new RestTemplate(); <br/>}</span></pre><p id="9e8c" class="pw-post-body-paragraph ki kj in kk b kl ll kn ko kp lm kr ks kt ln kv kw kx lo kz la lb lp ld le lf ig bi translated">下面的代码显示了一个 REST 客户端“YelpClient”调用 Yelp 的 REST API 来获取租赁资产评论。</p><pre class="lq lr ls lt gt lu lk lv lw aw lx bi"><span id="0922" class="ly jl in lk b gy lz ma l mb mc">@Autowired <br/>private final RestOperations restOperations; </span><span id="f87a" class="ly jl in lk b gy md ma l mb mc">public List getRentalPropertyReviews(String address) <br/>{ <br/>  String url = buildRestUrl(businessId); <br/>  HttpHeaders httpHeaders = new HttpHeaders(); <br/>  String apiKey = getApiKey(YELP); <br/>  httpHeaders.add("Authorization","Bearer " + apiKey); <br/>  httpHeaders.setContentType(MediaType.APPLICATION_JSON); <br/>  HttpEntity entity = new HttpEntity("parameters", httpHeaders); <br/>  ResponseEntity response; <br/>  try { <br/>   response = restOperations.exchange(url, HttpMethod.GET,entity, String.class); <br/>  } <br/>  catch(RestClientException e) <br/>  { <br/>    throw new RuntimeException("Unable to retrieve reviews", e); <br/>  } <br/>}</span></pre><p id="7098" class="pw-post-body-paragraph ki kj in kk b kl ll kn ko kp lm kr ks kt ln kv kw kx lo kz la lb lp ld le lf ig bi translated">在上面的代码中，我们通过添加 Yelp 的 REST API 密钥作为授权的一部分来构建 HTTP 头。我们调用 GET 方法来获取评审数据。</p><p id="f29c" class="pw-post-body-paragraph ki kj in kk b kl ll kn ko kp lm kr ks kt ln kv kw kx lo kz la lb lp ld le lf ig bi translated">基本上，一个人必须做</p><ul class=""><li id="3eab" class="me mf in kk b kl ll kp lm kt mg kx mh lb mi lf mj mk ml mm bi translated">自动关联 RestTemplate 对象</li><li id="1d89" class="me mf in kk b kl mn kp mo kt mp kx mq lb mr lf mj mk ml mm bi translated">使用授权和内容类型构建 HTTP 头</li><li id="e98d" class="me mf in kk b kl mn kp mo kt mp kx mq lb mr lf mj mk ml mm bi translated">使用 HttpEntity 包装请求对象</li><li id="12f7" class="me mf in kk b kl mn kp mo kt mp kx mq lb mr lf mj mk ml mm bi translated">提供 URL、Http 方法和交换方法的返回类型。</li></ul><h1 id="8136" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">什么是 WebClient？</h1><p id="d997" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">Spring 5 引入了一个名为 web client 的反应式 web 客户端。这是一个执行 web 请求的接口。它是 Spring web 反应模块的一部分。WebClient 最终会取代 RestTemplate。</p><p id="a278" class="pw-post-body-paragraph ki kj in kk b kl ll kn ko kp lm kr ks kt ln kv kw kx lo kz la lb lp ld le lf ig bi translated">最重要的是，WebClient 是反应式的、非阻塞的、异步的，并且基于 HTTP 协议 Http/1.1 工作。</p><p id="767a" class="pw-post-body-paragraph ki kj in kk b kl ll kn ko kp lm kr ks kt ln kv kw kx lo kz la lb lp ld le lf ig bi translated">要使用 WebClient，您必须</p><ul class=""><li id="f937" class="me mf in kk b kl ll kp lm kt mg kx mh lb mi lf mj mk ml mm bi translated">创建 WebClient 的实例</li><li id="a55f" class="me mf in kk b kl mn kp mo kt mp kx mq lb mr lf mj mk ml mm bi translated">向 REST 端点发出请求</li><li id="2ead" class="me mf in kk b kl mn kp mo kt mp kx mq lb mr lf mj mk ml mm bi translated">处理响应</li></ul><pre class="lq lr ls lt gt lu lk lv lw aw lx bi"><span id="3fbd" class="ly jl in lk b gy lz ma l mb mc">WebClient webClient = WebClient .builder()  <br/>     .baseUrl("https://localhost:8443") <br/>     .defaultCookie("cookieKey", "cookieValue") <br/>     .defaultHeader(HttpHeaders.CONTENT_TYPE, <br/>        MediaType.APPLICATION_JSON_VALUE) <br/>     .defaultUriVariables(Collections.singletonMap("url", "https://localhost:8443"))<br/>     .build();</span></pre><p id="6aae" class="pw-post-body-paragraph ki kj in kk b kl ll kn ko kp lm kr ks kt ln kv kw kx lo kz la lb lp ld le lf ig bi translated">上面的代码显示了一种实例化 WebClient 的方法。您也可以通过简单地使用<code class="fe lh li lj lk b">WebClient webClient = WebClient.create();</code>来创建一个实例</p><p id="eabd" class="pw-post-body-paragraph ki kj in kk b kl ll kn ko kp lm kr ks kt ln kv kw kx lo kz la lb lp ld le lf ig bi translated"><code class="fe lh li lj lk b">WebClient</code>提供了<code class="fe lh li lj lk b">exchange</code>和<code class="fe lh li lj lk b">retrieve</code>两种方法。方法通常获取响应以及状态和头。<code class="fe lh li lj lk b">retrieve</code>方法直接获取响应体。比较好用。</p><p id="872e" class="pw-post-body-paragraph ki kj in kk b kl ll kn ko kp lm kr ks kt ln kv kw kx lo kz la lb lp ld le lf ig bi translated">同样，根据您是试图获取单个响应对象还是一系列对象，您可以使用<code class="fe lh li lj lk b">mono</code>或<code class="fe lh li lj lk b">flux</code>。</p><pre class="lq lr ls lt gt lu lk lv lw aw lx bi"><span id="4407" class="ly jl in lk b gy lz ma l mb mc">this.webClient = webClientBuilder.baseUrl("http://localhost:8080/v1/betterjavacode/").build(); <br/>this.webClient.get() <br/>.uri("users") <br/>.accept(MediaType.APPLICATION_JSON) .retrieve()<br/>.bodyToFlux(UserDto.class).collectList();</span></pre><p id="4b7a" class="pw-post-body-paragraph ki kj in kk b kl ll kn ko kp lm kr ks kt ln kv kw kx lo kz la lb lp ld le lf ig bi translated">上面的代码基本上使用<code class="fe lh li lj lk b">webClient</code>从 REST API 获取用户列表。</p><h1 id="835f" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">Spring WebClient vs RestTemplate</h1><p id="138a" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">我们已经知道这两个特性之间的一个关键区别。WebClient 是非阻塞客户端，RestTemplate 是阻塞客户端。</p><p id="bbd8" class="pw-post-body-paragraph ki kj in kk b kl ll kn ko kp lm kr ks kt ln kv kw kx lo kz la lb lp ld le lf ig bi translated">RestTemplate 在幕后使用 Java Servlet API。Servlet API 是一个同步调用者。因为它是同步的，线程将阻塞，直到 webclient 响应请求。</p><p id="0bcd" class="pw-post-body-paragraph ki kj in kk b kl ll kn ko kp lm kr ks kt ln kv kw kx lo kz la lb lp ld le lf ig bi translated">因此，等待结果的请求将会增加。这将导致内存的增加。</p><p id="e16e" class="pw-post-body-paragraph ki kj in kk b kl ll kn ko kp lm kr ks kt ln kv kw kx lo kz la lb lp ld le lf ig bi translated">另一方面，WebClient 是一个异步的非阻塞客户端。它使用 Spring 的反应框架。WebClient 是 Spring-WebFlux 模块的一部分。</p><p id="6973" class="pw-post-body-paragraph ki kj in kk b kl ll kn ko kp lm kr ks kt ln kv kw kx lo kz la lb lp ld le lf ig bi translated">Spring WebFlux 使用<a class="ae lg" href="https://github.com/reactor/reactor" rel="noopener ugc nofollow" target="_blank">反应器库</a>。它提供了<code class="fe lh li lj lk b">Mono</code>和<code class="fe lh li lj lk b">Flux</code> API 来处理数据序列。Reactor 是一个反应流库。而且，它的所有操作器都支持非阻塞背压。</p><h1 id="4722" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">如何在 Spring Boot 应用程序中使用 WebClient 的示例</h1><p id="f39c" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">我们可以结合 Spring Web MVC 和 Spring WebFlux 的功能。在本节中，我将创建一个示例应用程序。这个应用程序将使用 WebFlux 调用 REST API，我们将构建一个响应来显示一个包含用户列表的网页。</p><p id="8c03" class="pw-post-body-paragraph ki kj in kk b kl ll kn ko kp lm kr ks kt ln kv kw kx lo kz la lb lp ld le lf ig bi translated"><code class="fe lh li lj lk b">RestController</code>举这个例子是一个获取用户列表的 API:</p><pre class="lq lr ls lt gt lu lk lv lw aw lx bi"><span id="a2d9" class="ly jl in lk b gy lz ma l mb mc">package com.betterjavacode.webclientdemo.controllers; </span><span id="d7d4" class="ly jl in lk b gy md ma l mb mc">import com.betterjavacode.webclientdemo.dto.UserDto; <br/>import com.betterjavacode.webclientdemo.managers.UserManager; <br/>import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.GetMapping; <br/>import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; import java.util.List; </span><span id="4303" class="ly jl in lk b gy md ma l mb mc">@RestController <br/>@RequestMapping("v1/betterjavacode") <br/>public class UserController <br/>{ </span><span id="3d5e" class="ly jl in lk b gy md ma l mb mc">   @Autowired <br/>   public UserManager userManager; </span><span id="68f3" class="ly jl in lk b gy md ma l mb mc">   @GetMapping(value = "/users") <br/>   public List getUsers() <br/>   { <br/>     return userManager.getAllUsers(); <br/>   } <br/>}</span></pre><p id="23d5" class="pw-post-body-paragraph ki kj in kk b kl ll kn ko kp lm kr ks kt ln kv kw kx lo kz la lb lp ld le lf ig bi translated"><code class="fe lh li lj lk b">Controller</code>使用 WebClient 调用 REST API 的类如下所示:</p><pre class="lq lr ls lt gt lu lk lv lw aw lx bi"><span id="4162" class="ly jl in lk b gy lz ma l mb mc">package com.betterjavacode.webclientdemo.controllers; </span><span id="d46c" class="ly jl in lk b gy md ma l mb mc">import com.betterjavacode.webclientdemo.clients.UserClient; <br/>import com.betterjavacode.webclientdemo.dto.UserDto; <br/>import com.betterjavacode.webclientdemo.managers.UserManager; <br/>import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Controller; <br/>import org.springframework.ui.Model; <br/>import org.springframework.web.bind.annotation.GetMapping; <br/>import java.util.List; </span><span id="85c3" class="ly jl in lk b gy md ma l mb mc">@Controller <br/>public class MainController <br/>{ </span><span id="1e4d" class="ly jl in lk b gy md ma l mb mc">   @Autowired <br/>   UserClient userClient; </span><span id="6972" class="ly jl in lk b gy md ma l mb mc">   @GetMapping(value = "/") <br/>   public String home() <br/>   { <br/>     return "home"; <br/>   } </span><span id="6175" class="ly jl in lk b gy md ma l mb mc">   @GetMapping(value = "/users") <br/>   public String getUsers(Model model) <br/>   { <br/>     List users = userClient.getUsers().block(); <br/>     model.addAttribute("userslist", users); return "users"; <br/>   } <br/>}</span></pre><p id="86f9" class="pw-post-body-paragraph ki kj in kk b kl ll kn ko kp lm kr ks kt ln kv kw kx lo kz la lb lp ld le lf ig bi translated">现在，UserClient 的重要代码是我们将使用 WebClient 调用 REST API 的地方。</p><pre class="lq lr ls lt gt lu lk lv lw aw lx bi"><span id="e78f" class="ly jl in lk b gy lz ma l mb mc">package com.betterjavacode.webclientdemo.clients; </span><span id="1a4d" class="ly jl in lk b gy md ma l mb mc">import com.betterjavacode.webclientdemo.dto.UserDto; <br/>import org.springframework.http.MediaType; <br/>import org.springframework.stereotype.Service; <br/>import org.springframework.web.reactive.function.client.WebClient; import reactor.core.publisher.Flux; <br/>import reactor.core.publisher.Mono; <br/>import java.util.List; </span><span id="5097" class="ly jl in lk b gy md ma l mb mc">@Service <br/>public class UserClient <br/>{ </span><span id="6a7f" class="ly jl in lk b gy md ma l mb mc">  private WebClient webClient; <br/>  public UserClient(WebClient.Builder webClientBuilder) <br/>  { <br/>     this.webClient = webClientBuilder.baseUrl("http://localhost:8080/v1/betterjavacode/").build(); <br/>  } </span><span id="286a" class="ly jl in lk b gy md ma l mb mc">   public Mono&lt;List&gt; getUsers() <br/>   { <br/>     return this.webClient.get() <br/>            .uri("users") <br/>            .accept(MediaType.APPLICATION_JSON) <br/>            .retrieve().bodyToFlux(UserDto.class).collectList(); <br/>   } <br/>}</span></pre><p id="5f68" class="pw-post-body-paragraph ki kj in kk b kl ll kn ko kp lm kr ks kt ln kv kw kx lo kz la lb lp ld le lf ig bi translated">上面的代码显示了首先构建 WebClient，然后使用它从 REST API 中检索响应。<code class="fe lh li lj lk b">retrieve</code>方法提供<code class="fe lh li lj lk b">mono</code>或<code class="fe lh li lj lk b">flux</code>两种选择。因为我们有不止一个用户要获取，所以我们使用了<code class="fe lh li lj lk b">flux</code>。</p><p id="0a1a" class="pw-post-body-paragraph ki kj in kk b kl ll kn ko kp lm kr ks kt ln kv kw kx lo kz la lb lp ld le lf ig bi translated">这表明我们可以使用反应式、非阻塞的 WebClient，它是 Spring Web MVC 框架中 WebFlux 的一部分。</p><h1 id="d43d" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">Spring WebClient 还有什么？</h1><p id="b840" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">Spring WebClient 是<code class="fe lh li lj lk b">Spring WebFlux</code>框架的一部分。这个 API 的主要优点是开发人员不必担心并发性或线程。WebClient 负责这一点。</p><p id="5f3e" class="pw-post-body-paragraph ki kj in kk b kl ll kn ko kp lm kr ks kt ln kv kw kx lo kz la lb lp ld le lf ig bi translated">WebClient 有一个内置的 HTTP 客户端库支持来执行请求。这包括阿帕奇<code class="fe lh li lj lk b">HttpComponents</code>，码头反应<code class="fe lh li lj lk b">HttpClient</code>，或反应器<code class="fe lh li lj lk b">Netty</code>。</p><p id="c311" class="pw-post-body-paragraph ki kj in kk b kl ll kn ko kp lm kr ks kt ln kv kw kx lo kz la lb lp ld le lf ig bi translated"><code class="fe lh li lj lk b">WebClient.builder()</code>提供以下选项:</p><ul class=""><li id="a07f" class="me mf in kk b kl ll kp lm kt mg kx mh lb mi lf mj mk ml mm bi translated"><code class="fe lh li lj lk b">uriBuilderFactory</code> -定制<code class="fe lh li lj lk b">uriBuilderFactory</code>以使用基本 URL</li><li id="7008" class="me mf in kk b kl mn kp mo kt mp kx mq lb mr lf mj mk ml mm bi translated"><code class="fe lh li lj lk b">defaultHeader</code> -每个请求的标题</li><li id="267a" class="me mf in kk b kl mn kp mo kt mp kx mq lb mr lf mj mk ml mm bi translated"><code class="fe lh li lj lk b">defaultCookie</code> -针对每个请求的 Cookies</li><li id="11ec" class="me mf in kk b kl mn kp mo kt mp kx mq lb mr lf mj mk ml mm bi translated"><code class="fe lh li lj lk b">defaultRequest</code> -定制每个请求</li><li id="1266" class="me mf in kk b kl mn kp mo kt mp kx mq lb mr lf mj mk ml mm bi translated"><code class="fe lh li lj lk b">filter</code> -针对每个请求的客户端过滤器</li><li id="7a6c" class="me mf in kk b kl mn kp mo kt mp kx mq lb mr lf mj mk ml mm bi translated"><code class="fe lh li lj lk b">exchangeStrategies</code> - HTTP 消息阅读器/编写器定制</li></ul><p id="3533" class="pw-post-body-paragraph ki kj in kk b kl ll kn ko kp lm kr ks kt ln kv kw kx lo kz la lb lp ld le lf ig bi translated">我已经在上面的代码演示中展示了<code class="fe lh li lj lk b">retrieve</code>方法。</p><p id="95a7" class="pw-post-body-paragraph ki kj in kk b kl ll kn ko kp lm kr ks kt ln kv kw kx lo kz la lb lp ld le lf ig bi translated"><code class="fe lh li lj lk b">WebClient</code>也提供了一种方法<code class="fe lh li lj lk b">exchange</code>，有<code class="fe lh li lj lk b">exchangeToMono</code>和<code class="fe lh li lj lk b">exchangeToFlux</code>这样的变种。</p><p id="00e2" class="pw-post-body-paragraph ki kj in kk b kl ll kn ko kp lm kr ks kt ln kv kw kx lo kz la lb lp ld le lf ig bi translated">使用<code class="fe lh li lj lk b">attribute()</code>，我们还可以向请求添加属性。</p><p id="2d9f" class="pw-post-body-paragraph ki kj in kk b kl ll kn ko kp lm kr ks kt ln kv kw kx lo kz la lb lp ld le lf ig bi translated">或者，也可以使用<code class="fe lh li lj lk b">WebClient</code>进行同步使用。在我上面的例子<code class="fe lh li lj lk b">MainController</code>中，我使用<code class="fe lh li lj lk b">block</code>来获得最终结果。这基本上阻塞了并行调用，直到我们得到结果。</p><p id="6be6" class="pw-post-body-paragraph ki kj in kk b kl ll kn ko kp lm kr ks kt ln kv kw kx lo kz la lb lp ld le lf ig bi translated"><code class="fe lh li lj lk b">WebClient</code>提供的一个关键特性是<code class="fe lh li lj lk b">retryWhen()</code>。对于更具弹性的系统，这是一个很好的特性，您可以在使用<code class="fe lh li lj lk b">WebClient</code>时添加。</p><pre class="lq lr ls lt gt lu lk lv lw aw lx bi"><span id="6ccf" class="ly jl in lk b gy lz ma l mb mc">webClient <br/>.get() <br/>.uri(String.join("", "/users", id)) <br/>.retrieve() <br/>.bodyToMono(UserDto.class) <br/>.retryWhen(Retry.fixedDelay(5, Duration.ofMillis(100))) <br/>.block();</span></pre><p id="24e4" class="pw-post-body-paragraph ki kj in kk b kl ll kn ko kp lm kr ks kt ln kv kw kx lo kz la lb lp ld le lf ig bi translated"><code class="fe lh li lj lk b">retryWhen</code>将<code class="fe lh li lj lk b">Retry</code>类作为参数。</p><p id="d704" class="pw-post-body-paragraph ki kj in kk b kl ll kn ko kp lm kr ks kt ln kv kw kx lo kz la lb lp ld le lf ig bi translated"><code class="fe lh li lj lk b">WebClient</code>还提供了错误处理功能。<code class="fe lh li lj lk b">doOnError()</code>允许您处理错误。当单声道因错误而结束时，它被触发。<code class="fe lh li lj lk b">onErrorResume()</code>是基于错误的回退。</p><h1 id="e00d" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">结论</h1><p id="77a1" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">在这篇文章中，我展示了什么是 Spring WebClient，我们如何使用 Spring WebClient 和 RestTemplate，以及它提供了哪些不同的特性。</p><p id="1732" class="pw-post-body-paragraph ki kj in kk b kl ll kn ko kp lm kr ks kt ln kv kw kx lo kz la lb lp ld le lf ig bi translated">如果你喜欢这篇文章，你可以在这里订阅我的博客<a class="ae lg" href="https://betterjavacode.com/subscribe" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="7cb0" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">参考</h1><ol class=""><li id="0dc0" class="me mf in kk b kl km kp kq kt ms kx mt lb mu lf mv mk ml mm bi translated">Spring WebClient — <a class="ae lg" href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-client" rel="noopener ugc nofollow" target="_blank"> Spring 文档</a></li><li id="5223" class="me mf in kk b kl mn kp mo kt mp kx mq lb mr lf mv mk ml mm bi translated">WebClient 备忘单— <a class="ae lg" href="https://medium.com/swlh/spring-boot-webclient-cheat-sheet-5be26cfa3e" rel="noopener"> Spring WebClient </a></li></ol></div><div class="ab cl mw mx hr my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ig ih ii ij ik"><p id="1b8a" class="pw-post-body-paragraph ki kj in kk b kl ll kn ko kp lm kr ks kt ln kv kw kx lo kz la lb lp ld le lf ig bi translated"><em class="nd">原载于 2020 年 12 月 27 日 https://betterjavacode.com</em><em class="nd"><a class="ae lg" href="https://betterjavacode.com/programming/spring-webclient-vs-resttemplate-comparison-and-features" rel="noopener ugc nofollow" target="_blank"><em class="nd">。</em></a></em></p></div></div>    
</body>
</html>