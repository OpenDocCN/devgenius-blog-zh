<html>
<head>
<title>Let’s Build a Linux Shell — Part I</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们构建一个Linux Shell —第一部分</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/lets-build-a-linux-shell-part-i-954c95911501?source=collection_archive---------1-----------------------#2020-06-08">https://blog.devgenius.io/lets-build-a-linux-shell-part-i-954c95911501?source=collection_archive---------1-----------------------#2020-06-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/642a231f47395d3154e254873225b5bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*C9Vu3zjsL27f0raD"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">在<a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上<a class="ae jz" href="https://unsplash.com/@_imkiran?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Sai Kiran Anagani </a>拍摄的照片</figcaption></figure><p id="fb51" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">自Unix早期以来，shell一直是用户与操作系统交互的重要部分。第一个Unix shell(<a class="ae jz" href="https://en.wikipedia.org/wiki/Thompson_shell" rel="noopener ugc nofollow" target="_blank">Thompson shell</a>)的功能非常有限，主要是I/O重定向和命令管道。后来的shell在早期shell的基础上进行扩展，增加了越来越多的功能，这些功能包括单词扩展、历史替换、循环和条件表达式等等。</p><h1 id="41de" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">为什么是这个教程</h1><p id="91c2" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">在过去的20年里，我一直使用GNU/Linux作为我的主要操作系统。我用过很多GNU/Linux shell，包括但不限于<strong class="kc io"> bash </strong>、<strong class="kc io"> ksh </strong>和<strong class="kc io"> zsh </strong>。然而，我一直被这个问题所困扰:<em class="mb">是什么让壳滴答作响？</em>喜欢，例如:</p><ul class=""><li id="4e8e" class="mc md in kc b kd ke kh ki kl me kp mf kt mg kx mh mi mj mk bi translated">shell如何解析我的命令，将它们转换成可执行指令，然后执行这些命令？</li><li id="4222" class="mc md in kc b kd ml kh mm kl mn kp mo kt mp kx mh mi mj mk bi translated">shell如何实现不同的单词扩展过程，比如参数扩展、命令替换和算术扩展？</li><li id="87bb" class="mc md in kc b kd ml kh mm kl mn kp mo kt mp kx mh mi mj mk bi translated">shell是如何实现I/O重定向的？</li><li id="8176" class="mc md in kc b kd ml kh mm kl mn kp mo kt mp kx mh mi mj mk bi translated">…等等。</li></ul><p id="6985" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">由于大多数GNU/Linux shell都是开源的，如果您想了解shell的内部工作原理，您可以在网上搜索源代码并开始钻研(我实际上就是这么做的)。但这个建议其实说起来容易做起来难。例如，您应该从哪里开始阅读代码呢？哪些源文件包含实现I/O重定向的代码？哪里可以找到解析用户命令的代码？我想你明白了。</p><p id="65ea" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这就是为什么我决定写这篇教程，来帮助Linux用户和程序员更好地理解他们的shells。我们将一起从零开始实现一个全功能的Linux shell，<em class="mb">。</em>在这个过程中，我们将看到Linux shell如何通过实际编写完成上述任务的C代码来解析和执行命令、循环和条件表达式。我们将讨论单词扩展和I/O重定向，并且我们将看到执行特性的代码。</p><p id="732b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在本教程结束时，我们将有一个基本的Linux shell，它现在不会做太多，但我们将在接下来的部分中扩展和改进它。在本系列的最后，我们将拥有一个全功能的Linux shell，它可以解析和执行一组相当复杂的命令、循环和表达式。</p><h1 id="8e6d" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">你需要什么</h1><p id="b9df" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">为了完成本教程，您需要以下内容:</p><ul class=""><li id="fdff" class="mc md in kc b kd ke kh ki kl me kp mf kt mg kx mh mi mj mk bi translated">一个正常工作的GNU/Linux系统(我个人用的是<a class="ae jz" href="http://ubuntu.com/" rel="noopener ugc nofollow" target="_blank"> Ubuntu </a>和<a class="ae jz" href="http://fedoraproject.org/" rel="noopener ugc nofollow" target="_blank"> Fedora </a>，不过可以随意使用你喜欢的Linux发行版)。</li><li id="541d" class="mc md in kc b kd ml kh mm kl mn kp mo kt mp kx mh mi mj mk bi translated"><a class="ae jz" href="https://gcc.gnu.org/" rel="noopener ugc nofollow" target="_blank">GCC</a>(GNU编译器集合)来编译我们的shell。</li><li id="495d" class="mc md in kc b kd ml kh mm kl mn kp mo kt mp kx mh mi mj mk bi translated">一个文本编辑器来编写代码(我个人使用<a class="ae jz" href="https://wiki.gnome.org/Apps/Gedit" rel="noopener ugc nofollow" target="_blank"> GEdit </a>，但是你也可以使用<a class="ae jz" href="https://www.vim.org/" rel="noopener ugc nofollow" target="_blank"> Vim </a>、<a class="ae jz" href="https://www.gnu.org/software/emacs/" rel="noopener ugc nofollow" target="_blank"> Emacs </a>，或者任何其他编辑器)。</li><li id="187e" class="mc md in kc b kd ml kh mm kl mn kp mo kt mp kx mh mi mj mk bi translated">如何用c编程？</li></ul><p id="28f2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这里，我不打算深入讨论安装所需软件的细节。如果您不确定如何让您的系统运行以上任何软件包，请参考您的Linux发行版的文档，并确保您在继续下一步之前已经设置好了一切。</p><p id="19ea" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在让我们言归正传。我们将从鸟瞰Linux shell的组成开始。</p><h1 id="ab56" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">Linux Shell的组件</h1><p id="126c" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">外壳是一个复杂的软件，包含许多不同的部分。</p><p id="902f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">任何Linux shell的核心部分都是<strong class="kc io">命令行解释器</strong>，或<strong class="kc io"> CLI </strong>。这个部分有两个目的:它读取并解析用户命令，然后执行解析后的命令。你可以认为CLI本身有两个部分:一个<strong class="kc io">解析器</strong>(或前端)，一个<em class="mb"> </em> <strong class="kc io">执行器</strong>(或后端)。</p><p id="b5fa" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">解析器</strong>扫描输入并将其分解成令牌。一个<strong class="kc io">令牌</strong>由一个或多个字符(字母、数字、符号)组成，代表一个输入单元。例如，标记可以是变量名、关键字、数字或算术运算符。</p><p id="836a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">解析器</strong>获取这些标记，将它们组合在一起，并创建一个特殊的结构，我们称之为<strong class="kc io">抽象语法树</strong>，或<strong class="kc io"> AST </strong>。您可以将AST看作是您赋予shell的命令行的高级表示。<strong class="kc io">解析器</strong>获取AST并将其传递给<strong class="kc io">执行器</strong>，执行器读取AST并执行解析后的命令。</p><p id="0cd5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">shell的另一部分是用户界面，它通常在shell处于<strong class="kc io">交互模式</strong>时运行，例如，当您在shell提示符下输入命令时。这里，外壳在一个循环中运行，我们称之为<strong class="kc io">读取-评估-打印循环</strong>，或者<strong class="kc io"> REPL </strong>。顾名思义，shell读取输入，解析并执行它，然后循环读取下一个命令，依此类推，直到您输入一个命令，如<code class="fe mq mr ms mt b"><strong class="kc io">exit</strong></code>、<code class="fe mq mr ms mt b"><strong class="kc io">shutdown</strong></code>或<code class="fe mq mr ms mt b"><strong class="kc io">reboot</strong></code>。</p><p id="3239" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">大多数shell实现了一个称为<strong class="kc io">符号表</strong>的结构，shell用它来存储关于变量的信息，以及它们的值和属性。我们将在本教程的第二部分实现符号表。</p><p id="25ae" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Linux shells也有一个历史功能，允许用户访问最近输入的命令，然后编辑和重新执行命令，而不需要太多的输入。shell还可以包含<strong class="kc io">内置实用程序</strong>，这是一组特殊的命令，作为shell程序本身的一部分来实现。内置的实用程序包括常用的命令，如<code class="fe mq mr ms mt b"><strong class="kc io">cd</strong></code>、<code class="fe mq mr ms mt b"><strong class="kc io">fg</strong></code>和<code class="fe mq mr ms mt b"><strong class="kc io">bg</strong></code>。随着本教程的进行，我们将实现许多内置的实用程序。</p><p id="b526" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在我们已经知道了典型Linux shell的基本组件，让我们开始构建我们自己的shell。</p><h1 id="62ac" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">我们的第一个贝壳</h1><p id="76a0" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">我们的第一版shell不会做任何花哨的事情；它将只打印一个提示字符串，读取一行输入，然后将输入回显到屏幕上。在本教程的后续部分，我们将添加解析和执行命令、循环、条件表达式等功能。</p><p id="3e48" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们首先为这个项目创建一个目录。我通常在我的项目中使用<code class="fe mq mr ms mt b"><em class="mb">~/projects/</em></code>,但是也可以随意使用你觉得舒服的路径。</p><p id="c984" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们要做的第一件事是编写基本的REPL循环。创建一个名为<code class="fe mq mr ms mt b"><strong class="kc io">main.c</strong></code>的文件(使用<code class="fe mq mr ms mt b"><strong class="kc io">touch main.c</strong></code>，然后使用您喜欢的文本编辑器打开它。在您的<code class="fe mq mr ms mt b"><strong class="kc io">main.c</strong></code>文件中输入以下代码:</p><pre class="mu mv mw mx gt my mt mz na aw nb bi"><span id="6676" class="nc kz in mt b gy nd ne l nf ng"><em class="mb">#include &lt;stdio.h&gt;<br/>#include &lt;stdlib.h&gt;<br/>#include &lt;errno.h&gt;<br/>#include &lt;string.h&gt;<br/>#include "shell.h"</em></span><span id="aac2" class="nc kz in mt b gy nh ne l nf ng">int <strong class="mt io">main</strong>(int <strong class="mt io">argc</strong>, char **<strong class="mt io">argv</strong>)<br/>{<br/>    char *<strong class="mt io">cmd</strong>;</span><span id="d200" class="nc kz in mt b gy nh ne l nf ng">    do<br/>    {<br/><strong class="mt io">        print_prompt1();</strong></span><span id="af30" class="nc kz in mt b gy nh ne l nf ng"><strong class="mt io">        cmd = read_cmd();</strong></span><span id="3b38" class="nc kz in mt b gy nh ne l nf ng">        if(!cmd)<br/>        {<br/>            exit(EXIT_SUCCESS);<br/>        }</span><span id="b753" class="nc kz in mt b gy nh ne l nf ng"><strong class="mt io">        if(cmd[0] == '\0' || strcmp(cmd, "\n") == 0)<br/></strong>        {<br/>            free(cmd);<br/>            continue;<br/>        }</span><span id="fd5f" class="nc kz in mt b gy nh ne l nf ng"><strong class="mt io">        if(strcmp(cmd, "exit\n") == 0)<br/></strong>        {<br/>            free(cmd);<br/>            break;<br/>        }</span><span id="a1d9" class="nc kz in mt b gy nh ne l nf ng"><strong class="mt io">        printf("%s\n", cmd);</strong></span><span id="8bfd" class="nc kz in mt b gy nh ne l nf ng"><strong class="mt io">        free(cmd);</strong></span><span id="b3e8" class="nc kz in mt b gy nh ne l nf ng">    } while(1);</span><span id="cac1" class="nc kz in mt b gy nh ne l nf ng">    exit(EXIT_SUCCESS);<br/>}<!-- --> </span></pre><p id="b95a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们的<code class="fe mq mr ms mt b"><strong class="kc io">main()</strong></code>函数非常简单(我已经突出显示了最重要的几行，我们将在接下来讨论)，因为它只需要实现REPL循环。我们首先打印shell的提示符，然后读取命令(现在，让我们将命令定义为<em class="mb">一个以</em> <code class="fe mq mr ms mt b"><em class="mb">\n</em></code>结尾的输入行)。如果读取命令时出现错误，我们将退出shell。如果命令为空(即用户没有写任何东西就按下了<code class="fe mq mr ms mt b">ENTER</code>，我们跳过这个输入，继续循环。如果命令是<code class="fe mq mr ms mt b"><strong class="kc io">exit</strong></code>，我们退出shell。否则，我们回显命令，释放用于存储命令的内存，并继续循环。很简单，不是吗？</p><p id="0492" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们的<code class="fe mq mr ms mt b"><strong class="kc io">main()</strong></code>函数调用两个自定义函数<code class="fe mq mr ms mt b"><strong class="kc io">print_prompt1()</strong></code>和<code class="fe mq mr ms mt b"><strong class="kc io">read_cmd()</strong></code>。第一个函数打印提示字符串，第二个函数读取下一行输入。让我们仔细看看这两个函数。</p><h1 id="7c91" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">打印提示字符串</h1><p id="d4fe" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">我们说过，shell在读取每个命令之前会打印一个提示字符串。实际上，有五种不同类型的提示字符串:<strong class="kc io"> PS0 </strong>、<strong class="kc io"> PS1 </strong>、<strong class="kc io"> PS2 </strong>、<strong class="kc io"> PS3 </strong>、<strong class="kc io"> PS4 </strong>。第0个字符串，<strong class="kc io"> PS0 </strong>，只有<strong class="kc io"> bash </strong>使用，这里就不考虑了。其他四个字符串是在特定的时间打印的，此时shell想要向用户传递特定的消息。在这一节，我们将谈论PS1和PS2。其余的将在我们讨论更高级的shell主题时讨论。</p><p id="231a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在创建源文件<code class="fe mq mr ms mt b"><strong class="kc io">prompt.c</strong></code>并输入以下代码:</p><pre class="mu mv mw mx gt my mt mz na aw nb bi"><span id="a282" class="nc kz in mt b gy nd ne l nf ng"><em class="mb">#include &lt;stdio.h&gt;<br/>#include "shell.h"</em></span><span id="84ca" class="nc kz in mt b gy nh ne l nf ng">void <strong class="mt io">print_prompt1</strong>(void)<br/>{<br/>    fprintf(stderr, "$ ");<br/>}</span><span id="b932" class="nc kz in mt b gy nh ne l nf ng">void <strong class="mt io">print_prompt2</strong>(void)<br/>{<br/>    fprintf(stderr, "&gt; ");<br/>}<!-- --> </span></pre><p id="4e7d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">第一个函数打印<strong class="kc io">第一个提示字符串</strong>，或<strong class="kc io"> PS1 </strong>，这通常是在shell等待您输入命令时看到的。第二个函数打印<strong class="kc io">第二个提示字符串</strong>，或<strong class="kc io"> PS2 </strong>，当您输入一个多行命令时，shell会打印该字符串(下面将详细介绍)。</p><p id="0ea9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">接下来，让我们读取一些用户输入。</p><h1 id="f8ea" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">读取用户输入</h1><p id="66b2" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">打开文件<code class="fe mq mr ms mt b"><strong class="kc io">main.c</strong></code>并在最后输入以下代码，就在<code class="fe mq mr ms mt b"><strong class="kc io">main()</strong></code>函数之后:</p><pre class="mu mv mw mx gt my mt mz na aw nb bi"><span id="cc82" class="nc kz in mt b gy nd ne l nf ng">char *<strong class="mt io">read_cmd</strong>(void)<br/>{<br/>    char <strong class="mt io">buf</strong>[1024];<br/>    char *<strong class="mt io">ptr</strong> = NULL;<br/>    char <strong class="mt io">ptrlen</strong> = 0;<br/><br/><strong class="mt io">    while(fgets(buf, 1024, stdin))<br/></strong>    {<br/>        int buflen = strlen(buf);<br/><br/>        if(!ptr)<br/>        {<br/><strong class="mt io">            ptr = malloc(buflen+1);<br/></strong>        }<br/>        else<br/>        {<br/><strong class="mt io">            char *ptr2 = realloc(ptr, ptrlen+buflen+1);<br/><br/></strong>            if(ptr2)<br/>            {<br/>                ptr = ptr2;<br/>            }<br/>            else<br/>            {<br/>                free(ptr);<br/>                ptr = NULL;<br/>            }<br/>        }<br/><br/><strong class="mt io">        if(!ptr)<br/></strong>        {<br/>            fprintf(stderr, "error: failed to alloc buffer: %s\n", <br/>                    strerror(errno));<br/>            return NULL;<br/>        }<br/><br/><strong class="mt io">        strcpy(ptr+ptrlen, buf);<br/><br/></strong>        if(buf[buflen-1] == '\n')<br/>        {<br/>            if(buflen == 1 || buf[buflen-2] != '\\')<br/>            {<br/>                return ptr;<br/>            }<br/><br/>            ptr[ptrlen+buflen-2] = '\0';<br/>            buflen -= 2;<br/>            print_prompt2();<br/>        }<br/><br/>        ptrlen += buflen;<br/>    }<br/><br/>    return ptr;<br/>}</span></pre><p id="53b6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里我们从<em class="mb"> stdin </em>中读取1024字节块的输入，并将输入存储在一个缓冲区中。第一次读取输入(当前命令的第一个块)时，我们使用<code class="fe mq mr ms mt b"><strong class="kc io">malloc()</strong></code>创建缓冲区。对于后续的块，我们使用<code class="fe mq mr ms mt b"><strong class="kc io">realloc()</strong></code>扩展缓冲区。我们在这里应该不会遇到任何内存问题，但是如果发生了错误，我们会打印一条错误消息并返回<code class="fe mq mr ms mt b">NULL</code>。如果一切顺利，我们将刚刚从用户那里读取的输入块复制到我们的缓冲区，并相应地调整我们的指针。</p><p id="873b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最后一段代码很有趣。为了理解我们为什么需要这段代码，让我们考虑下面的例子。比方说你要输入一个真的，<em class="mb">真的</em>长行输入:</p><pre class="mu mv mw mx gt my mt mz na aw nb bi"><span id="fb56" class="nc kz in mt b gy nd ne l nf ng">echo "This is a very long line of input, one that needs to span two, three, or perhaps even more lines of input, so that we can feed it to the shell"</span></pre><p id="de1b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是一个愚蠢的例子，但它完美地展示了我们正在谈论的东西。要输入这么长的命令，我们可以在一行中写下全部内容(就像我们在这里做的那样)，这是一个繁琐而丑陋的过程。或者我们可以把鱼线切成小块，然后把这些小块放进鱼壳里，一次一片:</p><pre class="mu mv mw mx gt my mt mz na aw nb bi"><span id="2f8a" class="nc kz in mt b gy nd ne l nf ng">echo "This is a very long line of input, <strong class="mt io">\</strong><br/>      one that needs to span two, three, <strong class="mt io">\</strong><br/>      or perhaps even more lines of input, <strong class="mt io">\</strong><br/>      so that we can feed it to the shell"</span></pre><p id="b7fe" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在键入第一行之后，为了让shell知道我们没有完成输入，我们用反斜杠字符<code class="fe mq mr ms mt b">\\</code>结束每一行，后面跟着换行符(我还缩进了这些行，使它们更易读)。我们称这种<strong class="kc io">转义</strong>为换行符。当shell看到转义的换行符时，它知道需要丢弃这两个字符并继续读取输入。</p><p id="3079" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在让我们回到我们的<code class="fe mq mr ms mt b"><strong class="kc io">read_cmd()</strong></code>函数。我们讨论了最后一段代码，它是这样的:</p><pre class="mu mv mw mx gt my mt mz na aw nb bi"><span id="cadc" class="nc kz in mt b gy nd ne l nf ng">        if(buf[buflen-1] == '\n')<br/>        {<br/>            if(buflen == 1 || buf[buflen-2] != '\\')<br/>            {<br/>                return ptr;<br/>            }<br/><br/>            ptr[ptrlen+buflen-2] = '\0';<br/>            buflen -= 2;<br/>            print_prompt2();<br/>        }</span></pre><p id="1cd1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这里，我们检查缓冲区中的输入是否以<code class="fe mq mr ms mt b">\n</code>结束，如果是，那么<code class="fe mq mr ms mt b">\n</code>是否被反斜杠字符<code class="fe mq mr ms mt b">\\</code>转义为<strong class="kc io">。如果最后一个<code class="fe mq mr ms mt b">\n</code>没有被转义，则输入行完成，我们将其返回给<code class="fe mq mr ms mt b"><strong class="kc io">main()</strong></code>函数。否则，我们去掉这两个字符(<code class="fe mq mr ms mt b">\\</code>和<code class="fe mq mr ms mt b">\n</code>，打印出<strong class="kc io"> PS2 </strong>，继续读取输入。</strong></p><h1 id="a6ca" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">编译外壳</h1><p id="9ab9" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">有了上面的代码，我们的小生境shell就差不多可以编译了。在继续编译shell之前，我们将添加一个带有函数原型的头文件。这一步是可选的，但是它极大地提高了我们的代码可读性，并且防止了一些编译器警告。</p><p id="df07" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">创建源文件<code class="fe mq mr ms mt b"><strong class="kc io">shell.h</strong></code>，输入以下代码:</p><pre class="mu mv mw mx gt my mt mz na aw nb bi"><span id="9189" class="nc kz in mt b gy nd ne l nf ng"><em class="mb">#ifndef SHELL_H<br/>#define SHELL_H<br/><br/></em>void <strong class="mt io">print_prompt1</strong>(void);<br/>void <strong class="mt io">print_prompt2</strong>(void);<br/><br/>char *<strong class="mt io">read_cmd</strong>(void);<br/><br/><em class="mb">#endif</em><em class="mb"> </em></span></pre><p id="d556" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在让我们编译外壳。打开您最喜欢的终端模拟器(我使用<a class="ae jz" href="https://help.gnome.org/users/gnome-terminal/stable/" rel="noopener ugc nofollow" target="_blank"> GNOME终端</a>和<a class="ae jz" href="https://kde.org/applications/en/system/org.kde.konsole" rel="noopener ugc nofollow" target="_blank"> Konsole </a>测试我的命令行项目，但是您也可以使用<a class="ae jz" href="https://invisible-island.net/xterm/" rel="noopener ugc nofollow" target="_blank"> XTerm </a>，其他终端模拟器，或者Linux的<a class="ae jz" href="https://en.wikipedia.org/wiki/Virtual_console" rel="noopener ugc nofollow" target="_blank">虚拟控制台</a>)。导航到您的源目录，并确保其中有3个文件:</p><figure class="mu mv mw mx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ni"><img src="../Images/8c6c1c67a538515c4a80076938c605db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XZ2lIJ0XQ1DDGvEPF47ZxA.png"/></div></div></figure><p id="16ff" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在使用以下命令编译shell:</p><pre class="mu mv mw mx gt my mt mz na aw nb bi"><span id="2d7d" class="nc kz in mt b gy nd ne l nf ng">gcc -o shell main.c prompt.c</span></pre><p id="36e8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果一切顺利，<code class="fe mq mr ms mt b"><strong class="kc io">gcc</strong></code>应该不会输出任何东西，当前目录下应该有一个名为<code class="fe mq mr ms mt b"><strong class="kc io">shell</strong></code>的可执行文件:</p><figure class="mu mv mw mx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ni"><img src="../Images/e3b8f7607d5bd8ff9af094b645596c51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uukwlKx-UMpD2AdycCk90w.png"/></div></div></figure><p id="0196" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在通过运行<code class="fe mq mr ms mt b"><strong class="kc io">./shell</strong></code>调用shell，并尝试输入几个命令:</p><figure class="mu mv mw mx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ni"><img src="../Images/20774992a1670fdc8a6f9cb07d7391f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nE_rebf4yOPkyPHrG0E4XA.png"/></div></div></figure><p id="a866" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在第一种情况下，shell打印<strong class="kc io"> PS1 </strong>，默认为<code class="fe mq mr ms mt b"><strong class="kc io">$</strong></code>和一个空格。我们输入我们的命令<code class="fe mq mr ms mt b"><strong class="kc io">echo Hello World</strong></code>，shell向我们回显这个命令(我们将在第二部分中扩展我们的shell，使它能够解析和执行这个——以及其他——简单的命令)。</p><p id="9fdd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在第二种情况下，shell再次响应我们的(稍微长一点的)命令。在第三种情况下，我们将长命令分成4行。注意每次我们键入一个反斜杠后跟<code class="fe mq mr ms mt b">ENTER</code>，shell打印<strong class="kc io"> PS2 </strong>并继续读取输入。输入最后一行之后，shell合并所有的行，删除所有的转义换行符，并将命令返回给我们。</p><p id="be90" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">要退出shell，请键入<code class="fe mq mr ms mt b"><strong class="kc io">exit</strong></code>，然后键入<code class="fe mq mr ms mt b">ENTER</code>:</p><figure class="mu mv mw mx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ni"><img src="../Images/15f93e8dc84cfc869ac0ac1cdcd9484f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1wXSvfhac7tkcxO4gxeskA.png"/></div></div></figure><p id="deac" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">就是这样！我们刚刚完成了我们的第一个Linux shell。耶！</p><h1 id="9aa4" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">下一步是什么</h1><p id="d0f7" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">尽管我们的shell目前可以工作，但它并没有做任何有用的事情。在下一部分中，我们将修复我们的shell，使它能够解析和执行简单的命令。</p><p id="d98a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你可以从这里阅读第二部。</p><p id="485b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">敬请期待！</p></div></div>    
</body>
</html>