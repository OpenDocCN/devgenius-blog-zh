<html>
<head>
<title>Socket Programming in C — Client</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C-Client 中的套接字编程</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/socket-programming-in-c-client-4408231f9e65?source=collection_archive---------14-----------------------#2022-12-11">https://blog.devgenius.io/socket-programming-in-c-client-4408231f9e65?source=collection_archive---------14-----------------------#2022-12-11</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/4434e19ca3c409bef0a98206cacd383f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vGUFG2jRrpS8MEryrb0GyA.png"/></div></div></figure><p id="a628" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在前面的<a class="ae kt" href="https://yashpaneliya.medium.com/socket-programming-in-c-server-ca86486f6b49" rel="noopener">部分</a>中，我们使用套接字创建了一个服务器。现在，我们将使用相同的套接字创建客户机，这些客户机将简单地向服务器发送一些字符串，并从服务器接收字符串。</p><h1 id="9a97" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">创建一个套接字</h1><p id="e639" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">因为我们在这个完整的例子中使用了 TCP 套接字，所以客户端必须拥有与服务器套接字相同类型的套接字(即 SOCK_STREAM)。对于这个例子，所有其他参数也将保持不变。</p><pre class="lx ly lz ma gt mb mc md bn me mf bi"><span id="ca8f" class="mg kv in mc b be mh mi l mj mk">int sockfd;<br/>/* Opening a socket is exactly similar to the server process */<br/>if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) &lt; 0)<br/>{<br/>  printf("Unable to create socket\n");<br/>  return 0;<br/>}</span></pre><h1 id="68d4" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">指定服务器</h1><p id="398a" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">为了向服务器发送请求，托管服务器的地址和端口号是必需的。为了指定地址和端口号，将使用 sockaddr_in 类型的相同结构。<br/>这里的变化是，你需要提供服务器的确切地址(不是 INADDR_ANY-like server)，否则请求可能会转到某个没有我们的服务器的随机地址。<br/>对于本例，服务器将托管在本地机器上。要获得本地机器的 IP 地址，在终端中使用“<strong class="jx io">IP addr”</strong>命令(对于 Linux)。</p><pre class="lx ly lz ma gt mb mc md bn me mf bi"><span id="a6fe" class="mg kv in mc b be mh mi l mj mk">serv_addr.sin_family = AF_INET;<br/>serv_addr.sin_addr.s_addr = inet_addr("&lt;YOUR_IP_ADDRESS&gt;"); // FORMAT: XXX.XXX.XXX.XXX<br/>serv_addr.sin_port = 6000; // Must be same as server</span></pre><h1 id="da2f" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">连接到服务器</h1><p id="7ad6" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">为了向指定的服务器发送请求，使用 connect()函数，该函数接受 socket FD、指向 sockaddr_in 结构的指针以及该结构的大小。</p><pre class="lx ly lz ma gt mb mc md bn me mf bi"><span id="e696" class="mg kv in mc b be mh mi l mj mk">if (connect(sockfd, (struct sockaddr *)&amp;serv_addr, sizeof(serv_addr)) &lt; 0)<br/>{<br/>   printf("Unable to connect to server\n");<br/>   return 0;<br/>}</span></pre><p id="ecbf" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">连接后，客户端可以发送或接收消息。但是，当服务器不发送时，recv()会阻塞进程，同样，当服务器不接收时，send()也会阻塞。</p><h1 id="b6a1" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">发送和接收数据</h1><p id="6133" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">对于数据传输，使用 send()和 recv()函数。</p><pre class="lx ly lz ma gt mb mc md bn me mf bi"><span id="3777" class="mg kv in mc b be mh mi l mj mk">for (i = 0; i &lt; 100; i++)<br/>    buf[i] = '\0';<br/>recv(sockfd, buf, 100, 0);<br/>printf("%s\n", buf);<br/>for (i = 0; i &lt; 100; i++)<br/>    buf[i] = '\0';<br/>while (1)<br/>{<br/>    strcpy(buf, "Message from client");<br/>    send(sockfd, buf, 100, 0);<br/>}<br/>close(sockfd);</span></pre><p id="9f2c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">工作完成后需要关闭插座。否则不会被其他进程使用。</p></div><div class="ab cl ml mm hr mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ig ih ii ij ik"><h1 id="4176" class="ku kv in bd kw kx ms kz la lb mt ld le lf mu lh li lj mv ll lm ln mw lp lq lr bi translated">最终代码</h1><pre class="lx ly lz ma gt mb mc md bn me mf bi"><span id="8f35" class="mg kv in mc b be mh mi l mj mk">int sockfd;<br/>struct sockaddr_in serv_addr;<br/>int i;<br/>char buf[100];<br/>/* Opening a socket is exactly similar to the server process */<br/>if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) &lt; 0)<br/>{<br/>    printf("Unable to create socket\n");<br/>    return 0;<br/>}<br/>serv_addr.sin_family = AF_INET;<br/>serv_addr.sin_addr.s_addr = inet_addr("&lt;YOUR_IP_ADDRESS&gt;");<br/>serv_addr.sin_port = 6000;<br/><br/>if (connect(sockfd, (struct sockaddr *)&amp;serv_addr, sizeof(serv_addr)) &lt; 0)<br/>{<br/>    printf("Unable to connect to server\n");<br/>    return 0;<br/>}<br/><br/>for (i = 0; i &lt; 100; i++)<br/>    buf[i] = '\0';<br/>recv(sockfd, buf, 100, 0);<br/>printf("%s\n", buf);<br/>for (i = 0; i &lt; 100; i++)<br/>    buf[i] = '\0';<br/>close(sockfd);</span></pre><h2 id="8b27" class="mx kv in bd kw my mz dn la na nb dp le kg nc nd li kk ne nf lm ko ng nh lq ni bi translated">查看运行中的代码:</h2><p id="9e71" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">打开两个终端，在一个终端上运行服务器代码，在另一个终端上运行客户端代码。</p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nj"><img src="../Images/b95c1b96fe931b7391596b97bf38202e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*73PfGKzg92FxG7MiOEivUQ.png"/></div></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated">服务器输出</figcaption></figure><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi no"><img src="../Images/8d98b704dc98a781277a8a7c9e96cf8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_CkZ36AhZD9H0Pk1J_MOKA.png"/></div></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk translated">客户端输出</figcaption></figure></div><div class="ab cl ml mm hr mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ig ih ii ij ik"><p id="618a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里完成了一个非常简单的使用套接字的服务器-客户端通信的实现。在下一个也是最后一个<a class="ae kt" href="https://medium.com/@yashpaneliya/socket-programming-in-c-bonus-d794a0dc6f7" rel="noopener">部分</a>，我将演示如何处理来自浏览器的请求。它将更加实用，因为我们通常在日常生活中从浏览器发送请求。</p><p id="182d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你在本博客中发现任何问题或错误信息，请发表评论。这将有助于我和许多其他学习者理解这个概念。</p><p id="390b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">表现出一些欣赏👏👏如果你觉得这个博客有帮助，请与你的同事分享。</p><p id="65a9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">更了解我:<a class="ae kt" href="https://linktr.ee/yashpaneliya" rel="noopener ugc nofollow" target="_blank">https://linktr.ee/yashpaneliya</a></p></div></div>    
</body>
</html>