<html>
<head>
<title>Daily Coding Problem: Problem #4</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">日常编码问题:问题4</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/daily-coding-problem-problem-3-5d41600bc5fe?source=collection_archive---------22-----------------------#2020-07-13">https://blog.devgenius.io/daily-coding-problem-problem-3-5d41600bc5fe?source=collection_archive---------22-----------------------#2020-07-13</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/8de4ed80884e6f6622f47a4cedc29cae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*f6g8idGlOMISd5bu"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">Christopher Gower 在<a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="c384" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">问题</h1><blockquote class="ky kz la"><p id="7d63" class="lb lc ld le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ig bi translated">给定一个整数数组，求线性时间和常数空间中第一个缺失的正整数。换句话说，找到数组中不存在的最小正整数。该数组也可以包含重复项和负数。</p><p id="78bc" class="lb lc ld le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ig bi translated">比如输入<code class="fe ma mb mc md b">[3, 4, -1, 1]</code>要给<code class="fe ma mb mc md b">2</code>。输入<code class="fe ma mb mc md b">[1, 2, 0]</code>应该给<code class="fe ma mb mc md b">3</code>。</p><p id="f317" class="lb lc ld le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ig bi translated">您可以就地修改输入数组。</p></blockquote><p id="2882" class="pw-post-body-paragraph lb lc in le b lf lg lh li lj lk ll lm me lo lp lq mf ls lt lu mg lw lx ly lz ig bi translated">看问题时，首先想到的是检查从1开始的数字是否在列表中。如果不存在，瞧！！我们找到了第一个正的缺失数字。如果该号码存在，对下一个号码重复该过程。</p><h1 id="543b" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">解决方案1:天真</h1><p id="dff7" class="pw-post-body-paragraph lb lc in le b lf mh lh li lj mi ll lm me mj lp lq mf mk lt lu mg ml lx ly lz ig bi translated"><strong class="le io"> Python: </strong></p><figure class="mm mn mo mp gt jo"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="4ded" class="pw-post-body-paragraph lb lc in le b lf lg lh li lj lk ll lm me lo lp lq mf ls lt lu mg lw lx ly lz ig bi translated"><strong class="le io">开始:</strong></p><figure class="mm mn mo mp gt jo"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="32a7" class="pw-post-body-paragraph lb lc in le b lf lg lh li lj lk ll lm me lo lp lq mf ls lt lu mg lw lx ly lz ig bi translated"><strong class="le io">时间复杂度:</strong> O(n)</p><p id="163e" class="pw-post-body-paragraph lb lc in le b lf lg lh li lj lk ll lm me lo lp lq mf ls lt lu mg lw lx ly lz ig bi translated"><strong class="le io">空间复杂度:</strong> O(1)</p><p id="cae1" class="pw-post-body-paragraph lb lc in le b lf lg lh li lj lk ll lm me lo lp lq mf ls lt lu mg lw lx ly lz ig bi translated">注意:在python中，有些人可能认为使用<code class="fe ma mb mc md b">in</code>操作符检查元素是否存在可以将时间减少到O(n)。但不会！。因为，<code class="fe ma mb mc md b">in</code>操作符在内部迭代数组。因此时间复杂度将是相同的。检查https://wiki.python.org/moin/TimeComplexity中<a class="ae jz" href="https://wiki.python.org/moin/TimeComplexity" rel="noopener ugc nofollow" target="_blank">的<em class="ld">列表</em>部分</a></p><p id="9438" class="pw-post-body-paragraph lb lc in le b lf lg lh li lj lk ll lm me lo lp lq mf ls lt lu mg lw lx ly lz ig bi translated">解决这个问题的另一种方法是使用<code class="fe ma mb mc md b">sorting</code>。我们首先对数组进行排序。然后我们检查数组中是否有这个数字。</p><h1 id="efc1" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">解决方案2:排序</h1><p id="17ee" class="pw-post-body-paragraph lb lc in le b lf mh lh li lj mi ll lm me mj lp lq mf mk lt lu mg ml lx ly lz ig bi translated"><strong class="le io"> Python: </strong></p><figure class="mm mn mo mp gt jo"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="21f3" class="pw-post-body-paragraph lb lc in le b lf lg lh li lj lk ll lm me lo lp lq mf ls lt lu mg lw lx ly lz ig bi translated"><strong class="le io">去:</strong></p><figure class="mm mn mo mp gt jo"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="a6d0" class="pw-post-body-paragraph lb lc in le b lf lg lh li lj lk ll lm me lo lp lq mf ls lt lu mg lw lx ly lz ig bi translated">时间复杂度:O(nlogn)</p><p id="67b9" class="pw-post-body-paragraph lb lc in le b lf lg lh li lj lk ll lm me lo lp lq mf ls lt lu mg lw lx ly lz ig bi translated"><strong class="le io">空间复杂度:</strong> O(1)</p><p id="eae5" class="pw-post-body-paragraph lb lc in le b lf lg lh li lj lk ll lm me lo lp lq mf ls lt lu mg lw lx ly lz ig bi translated">我们如何在线性时间和恒定空间中实现这一点？🤔。我们能以某种方式使用数组的元素来找到最小的正缺失数吗？试着想想这个。我们可以使用数组元素来寻找缺失的数字。当我们在遍历时遇到列表中的元素<code class="fe ma mb mc md b">e</code>时，我们通过否定<code class="fe ma mb mc md b">arr[e] = -arr[e]</code>将位置<code class="fe ma mb mc md b">e</code>即<code class="fe ma mb mc md b">arr[e]</code>处的元素标记为已访问。如果它已经被标记，我们就不再访问它。列表中的负数怎么办？。为了确保它们(负数)不会妨碍我们寻找答案，我们将它们与正数分开。</p><h1 id="1fb6" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">解决方案3:标记访问过的元素</h1><p id="bb21" class="pw-post-body-paragraph lb lc in le b lf mh lh li lj mi ll lm me mj lp lq mf mk lt lu mg ml lx ly lz ig bi translated"><strong class="le io">蟒蛇:</strong></p><figure class="mm mn mo mp gt jo"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="cbec" class="pw-post-body-paragraph lb lc in le b lf lg lh li lj lk ll lm me lo lp lq mf ls lt lu mg lw lx ly lz ig bi translated"><strong class="le io">开始:</strong></p><figure class="mm mn mo mp gt jo"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="1aff" class="pw-post-body-paragraph lb lc in le b lf lg lh li lj lk ll lm me lo lp lq mf ls lt lu mg lw lx ly lz ig bi translated"><strong class="le io">时间复杂度:</strong> O(n)</p><p id="256a" class="pw-post-body-paragraph lb lc in le b lf lg lh li lj lk ll lm me lo lp lq mf ls lt lu mg lw lx ly lz ig bi translated"><strong class="le io">空间复杂度:</strong> O(1)</p><p id="12db" class="pw-post-body-paragraph lb lc in le b lf lg lh li lj lk ll lm me lo lp lq mf ls lt lu mg lw lx ly lz ig bi translated">我希望你们喜欢这篇文章。</p><p id="9e54" class="pw-post-body-paragraph lb lc in le b lf lg lh li lj lk ll lm me lo lp lq mf ls lt lu mg lw lx ly lz ig bi translated">如果你觉得有帮助，请分享和鼓掌非常感谢！😄</p><p id="3f16" class="pw-post-body-paragraph lb lc in le b lf lg lh li lj lk ll lm me lo lp lq mf ls lt lu mg lw lx ly lz ig bi translated">欢迎在评论区提问！。</p></div></div>    
</body>
</html>