<html>
<head>
<title>Typescript: when to use null, undefined or empty array?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Typescript:何时使用null、未定义或空数组？</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/typescript-when-to-use-null-undefined-or-empty-array-d45244ffc565?source=collection_archive---------0-----------------------#2021-08-13">https://blog.devgenius.io/typescript-when-to-use-null-undefined-or-empty-array-d45244ffc565?source=collection_archive---------0-----------------------#2021-08-13</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="a25c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">什么时候选择什么变体？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/0773bcd78be01b779cf90df0a263848f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*eVyLEoiIRnbmtCZSDRNzMQ.jpeg"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">乌孙挣脱枷锁。如此多不同的变体…</figcaption></figure><p id="1d99" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">TypeScript是强类型语言。</p><p id="75e7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了理解我们如何保护自己免受可空性问题的影响，我们需要首先理解TypeScript在处理null和undefined方面的设计方式。</p><p id="0164" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Null和undefined有不同的含义:</p><ol class=""><li id="a3fe" class="ku kv in jm b jn jo jr js jv kw jz kx kd ky kh kz la lb lc bi translated">某些东西还没有初始化，没有赋值:使用undefined。</li><li id="4506" class="ku kv in jm b jn ld jr le jv lf jz lg kd lh kh kz la lb lc bi translated">某些内容当前不可用:请使用null。</li></ol><pre class="kj kk kl km gt li lj lk ll aw lm bi"><span id="d072" class="ln lo in lj b gy lp lq l lr ls">let name = {};     // no property defined<br/>console.log(name); // undefined</span></pre><p id="0fc6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">值' undefined '表示一个变量已经被声明，但还没有被赋值。因此，变量的值是“未定义的”。</p><pre class="kj kk kl km gt li lj lk ll aw lm bi"><span id="31f4" class="ln lo in lj b gy lp lq l lr ls">let name = undefined;</span></pre><p id="ac07" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">另一方面，‘null’指的是不存在的对象，基本意思是‘空’或者‘什么都没有’。</p><p id="65e2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">将“null”赋给变量，以指定该变量不包含任何值或为空。但是“undefined”用于检查变量在声明后是否被赋值。</p><p id="8e00" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> Null vs空数组[] — </strong>返回空数组比返回Null好</p><p id="d7d7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我认为我们应该将null或undefined转换成[]，除非我们真的需要它是null或undefined的信息，但在这种情况下，我真的怀疑我们是否需要这个信息。这个简单的技巧将使代码变得容易得多，没有空检查，没有测试中要覆盖的额外分支，等等。这让我们的生活变得轻松了一些。</p><p id="5bb7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在1值的情况下，我们可以检查未定义的:</p><pre class="kj kk kl km gt li lj lk ll aw lm bi"><span id="52f5" class="ln lo in lj b gy lp lq l lr ls">if (name !== undefined) { }</span></pre><p id="3141" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">也足以用非常简短的方式写这张支票:</p><pre class="kj kk kl km gt li lj lk ll aw lm bi"><span id="af7a" class="ln lo in lj b gy lp lq l lr ls">if (name) {}        // undefined, null and false check inside</span></pre><p id="ad86" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">多种现代语言中可用的三元运算符— </strong> if (a)？乙:丙</p><p id="6ece" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果<strong class="jm io"> a </strong>不为空，则取<strong class="jm io"> b </strong>作为结果，否则取<strong class="jm io"> c </strong>作为余数。</p><pre class="kj kk kl km gt li lj lk ll aw lm bi"><span id="877c" class="ln lo in lj b gy lp lq l lr ls">const tariff = this.result?.tariff ? [this.result.tariff] : [];</span></pre><p id="b431" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">初始化空数组:</strong></p><pre class="kj kk kl km gt li lj lk ll aw lm bi"><span id="0115" class="ln lo in lj b gy lp lq l lr ls">const tariffs: Array&lt;MyTariff&gt; = new Array&lt;MyTariff&gt;();<br/><br/>const tariffs: Array&lt;MyTariff&gt; = [];   // as simplified syntax</span><span id="2b22" class="ln lo in lj b gy lt lq l lr ls">const tariffs: Array&lt;MyTariff&gt; = null; // unwanted behavior</span></pre><p id="ef65" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当我们试图迭代数组时，空数组提供了稳定的行为，因为null或undefined将中断迭代。</p><pre class="kj kk kl km gt li lj lk ll aw lm bi"><span id="7470" class="ln lo in lj b gy lp lq l lr ls">this.result?.sellingTariffs?.forEach(item =&gt; {<br/>  tariffs.push(item);<br/>  console.log(item);<br/>});</span></pre><p id="e365" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">操作员||或</strong></p><pre class="kj kk kl km gt li lj lk ll aw lm bi"><span id="8796" class="ln lo in lj b gy lp lq l lr ls">this.<!-- -->result.sellingTariff || true</span></pre><p id="0a63" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对于null和undefined值，以及false值，将计算为true。</p><pre class="kj kk kl km gt li lj lk ll aw lm bi"><span id="1dfe" class="ln lo in lj b gy lp lq l lr ls">this.result?.sellingTariffs || []      // if null return empty array</span></pre><p id="e311" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">空类型— </strong>表示只能取值为空的变量。</p><p id="eb7d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们只能将null赋值给包含null变量的变量。它变得有用的地方是，我们可以用联合类型将多个变量的值赋给它。</p><pre class="kj kk kl km gt li lj lk ll aw lm bi"><span id="95ac" class="ln lo in lj b gy lp lq l lr ls">// Defining nullable fields:<br/>type MyString = {<br/>  v: string | null;               // x could hold a value or a null<br/>};<br/>const resultStr: MyString = null; // or input string "Lorem ipsum";<br/>console.log(resultStr);           // result null</span></pre><p id="3e2c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">空值之间的差异&amp;未定义</strong></p><p id="c529" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Null和Undefined看起来很相似，但它们之间几乎没有区别。</p><p id="2348" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">1.null与==(相等检查)相比时等于未定义<br/> null与===(严格相等检查)相比时不等于未定义</p><p id="c87d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">2.当我们把null转换成一个数字时，它就变成了零。<br/>当我们将undefined转换为number时，它变成NaN</p><p id="a8d2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">3.null是JSON中的有效值。你可以把undefined表示成一个JSON</p><h2 id="9dc7" class="ln lo in bd lu lv lw dn lx ly lz dp ma jv mb mc md jz me mf mg kd mh mi mj mk bi translated">检查未定义的</h2><p id="3cad" class="pw-post-body-paragraph jk jl in jm b jn ml jp jq jr mm jt ju jv mn jx jy jz mo kb kc kd mp kf kg kh ig bi translated"><strong class="jm io"> typeOf </strong>也是一个经典的JavaScript方法，用于检查对象是否未定义:</p><pre class="kj kk kl km gt li lj lk ll aw lm bi"><span id="accf" class="ln lo in lj b gy lp lq l lr ls">if (typeOf tariff !== 'undefined') {<br/>  console.log(tariff); // is now safe to use<br/>}</span></pre><p id="fc52" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">同样通过使用等号运算符(<code class="fe mq mr ms lj b">==</code>)和严格等号运算符(<code class="fe mq mr ms lj b">===</code>)</p><pre class="kj kk kl km gt li lj lk ll aw lm bi"><span id="3265" class="ln lo in lj b gy lp lq l lr ls">let name: number | null | undefined;</span><span id="def5" class="ln lo in lj b gy lt lq l lr ls">console.log(name)                       //undefined</span><span id="6c95" class="ln lo in lj b gy lt lq l lr ls">console.log(typeof name)                //undefined</span><span id="6ad6" class="ln lo in lj b gy lt lq l lr ls">console.log(name ==null)  //true, == operator returns true for null</span><span id="e27e" class="ln lo in lj b gy lt lq l lr ls">console.log(name === null)              //false</span><span id="5034" class="ln lo in lj b gy lt lq l lr ls">console.log(name == undefined)          //true</span><span id="eaa2" class="ln lo in lj b gy lt lq l lr ls">console.log(name === undefined)         //true</span></pre><p id="725f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">数组的typeOf返回它的类型对象。</p><pre class="kj kk kl km gt li lj lk ll aw lm bi"><span id="5340" class="ln lo in lj b gy lp lq l lr ls">const arrayTest = ["Test1", "Test2"];<br/>console.log(typeOf arrayTest);           // object<br/>console.log(arrayTest instanceOf Array); // true</span></pre><p id="ed0d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">检查空数组:首先我们检查未定义的，其次可以检查属性。</p><pre class="kj kk kl km gt li lj lk ll aw lm bi"><span id="d852" class="ln lo in lj b gy lp lq l lr ls">if (arrayTest &amp;&amp; !arrayTest.length) { }</span></pre><p id="1530" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">操作员！— </strong>非空断言操作</p><p id="6223" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个操作符告诉编译器这个字段不是空的或者未定义的，但是它被定义了。</p><pre class="kj kk kl km gt li lj lk ll aw lm bi"><span id="9869" class="ln lo in lj b gy lp lq l lr ls">type Tariff = {<br/>  name: string;<br/>};</span><span id="0511" class="ln lo in lj b gy lt lq l lr ls">let tariff: Tariff;<br/>tariff = { name: "name" };  // initialize the object<br/><br/>console.log("Test it: ", tariff!.name);</span></pre><p id="3730" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是这个操作符不会改变对象的值。如果值为空或未定义，这个操作符就帮不了我们。应用程序将被很好地编译，但无论如何都会发生异常。</p><p id="0100" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">原则上在Kotlin语言中是相当的，用两个！！</p><p id="841a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">关税！！我们必须绝对确定这个对象不是空的或者未定义的。危险的假设。</p><p id="d425" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">操作员！！在打字稿中</strong></p><p id="51f7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">通过添加<code class="fe mq mr ms lj b">!!</code>，如果customerData为真，则表达式为<code class="fe mq mr ms lj b">true</code>，如果customerData为假，则表达式为<code class="fe mq mr ms lj b">false</code>，这就更容易管理了。</p><pre class="kj kk kl km gt li lj lk ll aw lm bi"><span id="8254" class="ln lo in lj b gy lp lq l lr ls">goToNextTab(): void {<br/>  <strong class="lj io">if (!!this.customerData) {</strong><br/>    this.router.navigateByUrl("myAnotherPage");<br/>  }<br/>}</span></pre><p id="3f0d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">而不是:</p><pre class="kj kk kl km gt li lj lk ll aw lm bi"><span id="4c36" class="ln lo in lj b gy lp lq l lr ls">hasNextTab<!-- -->(): boolean {<br/>  if(<!-- -->this.customerData<!-- -->) {<br/>    <!-- -->return true;<br/>  }<br/>  return false<br/>}</span></pre><p id="2796" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因为！！customerData现在是一个布尔表达式，而customerData可以是任何东西。这种表达式将允许编写这样的函数来返回true:</p><pre class="kj kk kl km gt li lj lk ll aw lm bi"><span id="6c68" class="ln lo in lj b gy lp lq l lr ls">const isSelected = (tariffs: Array, selected: Tariff): boolean =&gt; {<br/>  <!-- -->const found = tariffs?.find(tariff =&gt; tariff.Id === selected?.Id);<br/> <strong class="lj io"> return !!found;</strong><br/>});</span></pre><p id="e573" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">无效合并运算符？？</strong>同时检查<strong class="jm io">空</strong>和<strong class="jm io">未定义</strong></p><p id="cd44" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在另一个值为<code class="fe mq mr ms lj b">null</code>或<code class="fe mq mr ms lj b">undefined</code>的情况下，<code class="fe mq mr ms lj b">??</code>操作符可用于提供回退值。它有两个操作数，写成这样:</p><pre class="kj kk kl km gt li lj lk ll aw lm bi"><span id="5767" class="ln lo in lj b gy lp lq l lr ls">value ?? fallbackValue;</span></pre><p id="6897" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果左操作数是<code class="fe mq mr ms lj b">null</code>或<code class="fe mq mr ms lj b">undefined</code>，则<code class="fe mq mr ms lj b">??</code>表达式计算右操作数。</p><pre class="kj kk kl km gt li lj lk ll aw lm bi"><span id="6dd1" class="ln lo in lj b gy lp lq l lr ls">let result = null ?? "right value";<br/>let result = undefined ?? "right value";<br/>let lowercaseInput = input.toLowerCase() ?? ""; //if null, return ""</span></pre><p id="d4c6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">与科特林猫王算子有相同的逻辑？：</p><pre class="kj kk kl km gt li lj lk ll aw lm bi"><span id="651b" class="ln lo in lj b gy lp lq l lr ls">// take right operand if left is null<br/>const result = <!-- -->first operand ?: second operand</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi mt"><img src="../Images/31af7ed77942aaf69ab827a59848d11c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q4qnejpP-8E5Pjb1MJpaGg.jpeg"/></div></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">华金·索罗拉，1910年。“三名划手”</figcaption></figure><p id="7531" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">结论</strong></p><p id="190b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">TypeScript从JavaScript发展而来。在基础层面上有很多相似之处。这两种语言正在并行发展。但在我看来，最好根本不要用null，更喜欢undefined。我还提到了Kotlin语言来展示与null斗争的相同方法。</p><p id="9108" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">链接</strong></p><div class="my mz gp gr na nb"><a href="https://basarat.gitbook.io/typescript/recap/null-undefined" rel="noopener  ugc nofollow" target="_blank"><div class="nc ab fo"><div class="nd ab ne cl cj nf"><h2 class="bd io gy z fp ng fr fs nh fu fw im bi translated">空与未定义</h2><div class="ni l"><h3 class="bd b gy z fp ng fr fs nh fu fw dk translated">记得我说过你应该用。你当然知道(因为我刚刚说了，^).不要把它用于根级别的东西。在…</h3></div><div class="nj l"><p class="bd b dl z fp ng fr fs nh fu fw dk translated">basarat.gitbook.io</p></div></div><div class="nk l"><div class="nl l nm nn no nk np ko nb"/></div></div></a></div><div class="my mz gp gr na nb"><a href="https://stackoverflow.com/questions/28975896/is-there-a-way-to-check-for-both-null-and-undefined" rel="noopener  ugc nofollow" target="_blank"><div class="nc ab fo"><div class="nd ab ne cl cj nf"><h2 class="bd io gy z fp ng fr fs nh fu fw im bi translated">有没有办法同时检查“空”和“未定义”呢？</h2><div class="ni l"><h3 class="bd b gy z fp ng fr fs nh fu fw dk translated">我认为这个答案需要更新，检查旧答案的编辑历史。基本上，你有三个不同的…</h3></div><div class="nj l"><p class="bd b dl z fp ng fr fs nh fu fw dk translated">stackoverflow.com</p></div></div><div class="nk l"><div class="nq l nm nn no nk np ko nb"/></div></div></a></div></div></div>    
</body>
</html>