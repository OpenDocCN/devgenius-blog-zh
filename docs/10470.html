<html>
<head>
<title>How to safely append data to the same slice concurrently in Golang?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在 Golang 中安全地将数据并发追加到同一个片上？</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-to-safely-append-data-to-the-same-slice-concurrently-in-golang-df467e1ebc9c?source=collection_archive---------0-----------------------#2022-11-04">https://blog.devgenius.io/how-to-safely-append-data-to-the-same-slice-concurrently-in-golang-df467e1ebc9c?source=collection_archive---------0-----------------------#2022-11-04</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="db56" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在本文中，我们将通过不同的方法来实现，如等待组和互斥以及数据竞争的挑战。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8e9c1c4027e1a1a54f4da709511f9eed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eLrQqKlR4T8UNL82MD1HAg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">Fig 简介</figcaption></figure><p id="94ff" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Aim:一个将奇数和偶数从 0 到 9 分开并附加到它们相应的片上的程序。所以我们应该有奇数=[1，3，5，7，9](任意顺序)，偶数=[0，2，4，6，8](任意顺序)。</p><h1 id="ab67" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">仅使用 goroutines 尝试-0</h1><p id="eb53" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">背景:一个程序在启动时唯一拥有的 goroutine 是调用 main 函数的那个，因此我们称它为主 goroutine。go 语句生成新的 goroutines。go 语句是前缀为关键字 go 的常规函数或方法调用。go 语句使新形成的 goroutine 调用该函数。go 语句本身会立即结束。</p><p id="0340" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这个例子中，我们使用多个 go 例程添加到切片中。因此，我们将有一个主要的围棋例程和 10 个由匿名围棋函数创建的新围棋例程。</p><pre class="kj kk kl km gt mb mc md me aw mf bi"><span id="911b" class="mg kz in mc b gy mh mi l mj mk">package main</span><span id="03b9" class="mg kz in mc b gy ml mi l mj mk">import (<br/> "fmt"<br/>)</span><span id="eb77" class="mg kz in mc b gy ml mi l mj mk">func done() {</span><span id="d2d5" class="mg kz in mc b gy ml mi l mj mk">var odd = make([]int, 0)<br/> var even = make([]int, 0)</span><span id="18ac" class="mg kz in mc b gy ml mi l mj mk">for i := 0; i &lt;= 9; i++ {<br/>  if i%2 == 0 {<br/>   go func(i int) {<br/>    even = append(even, i)<br/>   }(i)<br/>  } else {<br/>   go func(i int) {<br/>    odd = append(odd, i)<br/>   }(i)<br/>  }<br/> }<br/> fmt.Println(odd)<br/> fmt.Println(even)</span><span id="10b5" class="mg kz in mc b gy ml mi l mj mk">}</span><span id="3e6e" class="mg kz in mc b gy ml mi l mj mk">func main() {<br/> for i := 1; i &lt;= 10; i++ {<br/>  fmt.Println("========================")<br/>  done()<br/> }<br/>}</span></pre><p id="a08b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/3f732bbf45fc4310ed11fe056c96803b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1226/format:webp/1*lv39lOD0dVT46hHX2TfOkQ.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图 1:输出</figcaption></figure><p id="adea" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">重大问题</strong>:</p><ul class=""><li id="f180" class="mn mo in jm b jn jo jr js jv mp jz mq kd mr kh ms mt mu mv bi translated">主 goroutine 可以完成它的执行，而不需要等待其他 go 例程(它们将把数据附加到片上)完成。因此，主 go 例程中的 print 语句会将数据仍被其他 go 例程追加的切片。</li><li id="60de" class="mn mo in jm b jn mw jr mx jv my jz mz kd na kh ms mt mu mv bi translated">数据竞争(我们将在下一部分讨论)</li></ul><h1 id="ee45" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">带有 sync.waitgroups 的尝试-1</h1><p id="648e" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">我们将使用 sync.waitgroups。借助 sync 包中的 WaitGroup 函数，程序可以等待特定的 goroutines。这些 Golang 同步技术会暂停程序执行，直到等待组中的 goroutines 完成运行。</p><p id="6df8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">简而言之，主程序将等到所有其他围棋程序完成。</p><p id="beac" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">工作组通知 WaitGroup。添加(1)每当循环开始时，它需要等待一个以上的 goroutine。之后，延期工作组。Done()在 goroutine 结束时提醒 WaitGroup。然后，wg。Wait()延迟执行，直到 goroutines 运行完毕。整个过程类似于在 wgAdd()中增加一个计数器，从 wg 计数器中减去。调用 done()时等待 wg 中的计数器达到 0。这是等待组工作的关键。</p><pre class="kj kk kl km gt mb mc md me aw mf bi"><span id="bb26" class="mg kz in mc b gy mh mi l mj mk">package main</span><span id="87a1" class="mg kz in mc b gy ml mi l mj mk">import (<br/> "fmt"<br/> "sync"<br/>)</span><span id="ee32" class="mg kz in mc b gy ml mi l mj mk">func done() {</span><span id="e2ee" class="mg kz in mc b gy ml mi l mj mk">var wg sync.WaitGroup<br/> var odd = make([]int, 0)<br/> var even = make([]int, 0)</span><span id="d8c3" class="mg kz in mc b gy ml mi l mj mk">for i := 0; i &lt;= 9; i++ {<br/>  wg.Add(1)<br/>  if i%2 == 0 {<br/>   go func(i int) {<br/>    defer wg.Done()<br/>    even = append(even, i)<br/>   }(i)<br/>  } else {<br/>   go func(i int) {<br/>    defer wg.Done()<br/>    odd = append(odd, i)<br/>   }(i)<br/>  }<br/> }<br/> wg.Wait()<br/> fmt.Println(odd)<br/> fmt.Println(even)</span><span id="3c80" class="mg kz in mc b gy ml mi l mj mk">}</span><span id="005d" class="mg kz in mc b gy ml mi l mj mk">func main() {<br/> for i := 1; i &lt;= 10; i++ {<br/>  fmt.Println("========================")<br/>  done()<br/> }<br/>}</span></pre><p id="a32f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">输出</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/126b09b1da718d18b8e0c1db8413a829.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/1*rwRGfA_4MT2IQm_AQ05O5g.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图 2:输出</figcaption></figure><p id="fea4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">现在发生了什么？</strong></p><p id="5bf9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了确保函数的一致性，我们运行了十次。毫无疑问，它比旧的要好，但有时结果并不像预期的那样。那么原因是什么。原因是数据竞赛。</p><p id="6cc8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">数据竞争</strong>:当两个或两个以上的 Goroutines 访问同一个内存位置时，其中至少有一个是写操作，它们之间没有排序，这就是所谓的数据竞争。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nc"><img src="../Images/eb627b5bccb37af1b00bcb01cc115116.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c4l76GIpoINQCdzEKqwqhg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图 3:至少两个 go 例程并发写入时的数据竞争</figcaption></figure><p id="995a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">更简单地说，当多个 goroutines 同时写一个片时，就会出现竞争情况。行为将是不可预测的。你需要一个互斥体。通过锁定保护追加。</p><p id="c8dc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们可以通过命令 go run -race pgm3b.go 来确认这一点</p><p id="5e67" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">数据竞争检查的输出</strong>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/3b25dd7d0573f46979ac4341caee802d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1340/format:webp/1*gd5gXHaw1rIDTN_5wo0Chw.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图 4:输出(数据竞争)</figcaption></figure><h1 id="3478" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">使用 sync.waitgroups 和 mutex 的尝试-2</h1><p id="1ae1" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">我们将对 sync.waitgroups 使用互斥。这不仅确保了主 go 例程等待所有其他 10 个 go 例程完成，而且还确保了在给定的时间点，只有一个 go 例程可以写入一个片。这就是互斥或者互斥的原理。附加由互斥体保护，避免脏写情况。</p><pre class="kj kk kl km gt mb mc md me aw mf bi"><span id="9d1a" class="mg kz in mc b gy mh mi l mj mk">package main</span><span id="bd43" class="mg kz in mc b gy ml mi l mj mk">import (<br/> "fmt"<br/> "sync"<br/>)</span><span id="0107" class="mg kz in mc b gy ml mi l mj mk">func done() {</span><span id="56a3" class="mg kz in mc b gy ml mi l mj mk">type answer struct {<br/>  MU   sync.Mutex<br/>  data []int<br/> }</span><span id="de65" class="mg kz in mc b gy ml mi l mj mk">var odd answer<br/> var even answer</span><span id="ed97" class="mg kz in mc b gy ml mi l mj mk">wg := &amp;sync.WaitGroup{}<br/> for i := 0; i &lt;= 9; i++ {<br/>  if i%2 == 0 {<br/>   wg.Add(1)<br/>   go func(i int) {<br/>    defer wg.Done()</span><span id="c474" class="mg kz in mc b gy ml mi l mj mk">even.MU.Lock()<br/>    even.data = append(even.data, i)<br/>    even.MU.Unlock()<br/>   }(i)<br/>  } else if i%2 == 1 {<br/>   wg.Add(1)<br/>   go func(i int) {<br/>    defer wg.Done()</span><span id="4be5" class="mg kz in mc b gy ml mi l mj mk">odd.MU.Lock()<br/>    odd.data = append(odd.data, i)<br/>    odd.MU.Unlock()<br/>   }(i)<br/>  }<br/> }</span><span id="cd02" class="mg kz in mc b gy ml mi l mj mk">wg.Wait()</span><span id="5624" class="mg kz in mc b gy ml mi l mj mk">fmt.Println(odd.data)</span><span id="9e6d" class="mg kz in mc b gy ml mi l mj mk">fmt.Println(even.data)</span><span id="34e7" class="mg kz in mc b gy ml mi l mj mk">}</span><span id="8c75" class="mg kz in mc b gy ml mi l mj mk">func main() {<br/> for i := 1; i &lt;= 10; i++ {<br/>  fmt.Println("========================")<br/>  done()</span><span id="5e91" class="mg kz in mc b gy ml mi l mj mk">}<br/>}</span></pre><p id="2809" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">输出:</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/2a619bde9588fd207fc2afbc113d49a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1214/format:webp/1*WTgBoOHFnjTxzGposEy2Lg.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图 5:输出</figcaption></figure><p id="1cec" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里我们可以看到没有观察到数据竞争，并且在所有 10 次迭代中输出都是一致的。这次没有数据竞赛。注意:互斥和等待组都是由 go 的同步包提供的。</p><p id="afe7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">数据赛跑检查:</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/153f2a26bac5234449a2ef8ee866b98d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1320/format:webp/1*mIcdyvDwKrYKipX2aA7iOQ.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图 6:输出(数据竞争检查)</figcaption></figure><h1 id="640c" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">简而言之…</h1><p id="7345" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">每当有多个 go 例程时，使用等待组，如果这些 go 例程同时在同一个数组、片或映射上写入，则在进行写入操作时，在这个共享内存(数组/片/映射)上使用互斥体。然而，如果多个 go 例程使用共享内存进行读(而不是写)操作，那么使用等待组应该没问题。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/7efe54ca4cf158d00bde9df11cfb5472.png" data-original-src="https://miro.medium.com/v2/resize:fit:1182/format:webp/1*JgPVKa8kBfnydv3B_fM_bg.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图 8:总结流程图(我在 draw.io 上画的)</figcaption></figure></div></div>    
</body>
</html>