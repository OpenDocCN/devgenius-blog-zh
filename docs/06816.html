<html>
<head>
<title>C# Problem: Alternative Builder Patterns</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C#问题:可选的构建器模式</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/c-problem-the-builder-pattern-af45eca342d7?source=collection_archive---------10-----------------------#2022-02-05">https://blog.devgenius.io/c-problem-the-builder-pattern-af45eca342d7?source=collection_archive---------10-----------------------#2022-02-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="6c7f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">和几种接近它的方法</em></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/3818d1e87aa2fd9499bfe70254db5bac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*59Ph5TT__-7qNDsJ"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">由<a class="ae lc" href="https://unsplash.com/@brett_jordan?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">布雷特·乔丹</a>在<a class="ae lc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="c266" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这篇文章可能包含附属链接，当你点击链接时，我可能会赚取一小笔佣金，而不会对你产生额外的费用。作为亚马逊的会员，我从合格的购买中获得收入。</p></div><div class="ab cl ld le hu lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="ij ik il im in"><p id="d20a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<a class="ae lc" href="https://amzn.to/3HuvpUZ" rel="noopener ugc nofollow" target="_blank">设计模式:可重用面向对象软件的元素</a>中，我们都听说过四人组的构建模式。该模式用于创建复杂对象，其组成部分必须以相同顺序或使用特定算法创建(<a class="ae lc" href="http://www.blackwasp.co.uk/gofpatterns.aspx" rel="noopener ugc nofollow" target="_blank">参考</a>)。这被认为是一种创造性的模式。</p><p id="3da5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">构建器模式的传统方法是使用抽象类(或接口)来构建一些复杂的对象。反过来，创建了一个具体的实现，它可以以不同的方式执行构建。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi lk"><img src="../Images/97499b92124eb0f92b8ec7b37ab57a6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:672/format:webp/0*94axvtz-VttqKiqp.png"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated"><a class="ae lc" href="http://www.blackwasp.co.uk/Builder.aspx" rel="noopener ugc nofollow" target="_blank">构建器设计模式(blackwasp.co.uk)</a></figcaption></figure><p id="f2fb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种方法适用于很多场景。然而，我质疑的是，这些动作应该放在哪里:<strong class="jp ir">在接口本身上，还是可以放在其他地方？</strong></p><p id="8bd3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本文的目标是根据构建器的输出提供利用构建器模式的不同方法。通常希望尽可能使用最小的接口，因为较大的接口需要更多的工作来重新实现(这是改天的话题)。</p><h1 id="cc47" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">为什么我们需要构建器模式</h1><p id="ba81" class="pw-post-body-paragraph jn jo iq jp b jq mj js jt ju mk jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">如果你在。NET Core，那么你可能一直在使用 builder 模式。例如，考虑以下情况:</p><h2 id="6ac9" class="mo lm iq bd ln mp mq dn lr mr ms dp lv jy mt mu lz kc mv mw md kg mx my mh mz bi translated">IServiceCollection</h2><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated"><a class="ae lc" href="https://github.com/dotnet/runtime/blob/main/src/libraries/Microsoft.Extensions.DependencyInjection.Abstractions/src/IServiceCollection.cs" rel="noopener ugc nofollow" target="_blank">位于主 dot net/runtime(github.com)的 runtime/iservicecollection . cs</a></figcaption></figure><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">使用</figcaption></figure><h2 id="42fd" class="mo lm iq bd ln mp mq dn lr mr ms dp lv jy mt mu lz kc mv mw md kg mx my mh mz bi translated">IConfigurationBuilder</h2><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated"><a class="ae lc" href="https://github.com/dotnet/runtime/blob/main/src/libraries/Microsoft.Extensions.Configuration.Abstractions/src/IConfigurationBuilder.cs" rel="noopener ugc nofollow" target="_blank">运行时/IConfigurationBuilder.cs 在主点网/运行时(github.com)</a></figcaption></figure><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">使用</figcaption></figure><p id="724f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这两个例子都展示了构建复杂对象的方法。</p><p id="d13c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们为应用程序构建依赖注入。我们正在“构建”它们，以减轻手动创建这些依赖项的需要。这里的方法是利用带有扩展方法的容器服务来构建对象(<a class="ae lc" rel="noopener ugc nofollow" target="_blank" href="/c-simple-interfaces-containers-f2980e76b2bd"> C#简单接口:容器</a>)。</p><p id="0e73" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第二，我们正在构建配置层次结构。我们采用多个复杂的配置源，并创建一个简单的<code class="fe nc nd ne nf b">IConfiguration</code>对象供应用程序使用，避免了我们自己手动搜索每个源的过程。这里的方法更传统，这里显式调用了一个<code class="fe nc nd ne nf b">Build</code>方法。</p><p id="4ec0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">乍一看，<code class="fe nc nd ne nf b">IServiceCollection</code>似乎不是一个建筑商。老实说，这个系列本身并不是。然而，在某种意义上，它在上面的代码中是如何被使用的是一个构建器模式(但不是在四人帮所讨论的严格定义中)。</p><p id="3f76" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">构建我们的对象和系统的每种方法都是有效的，但是我们使用哪种方法取决于我们的输出。</p><p id="6467" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们来讨论一下这两种方法。</p></div><div class="ab cl ld le hu lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="ij ik il im in"><h1 id="aa87" class="ll lm iq bd ln lo ng lq lr ls nh lu lv lw ni ly lz ma nj mc md me nk mg mh mi bi translated">传统方法(最常见)</h1><p id="4bf8" class="pw-post-body-paragraph jn jo iq jp b jq mj js jt ju mk jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">让我们用一个对构建者来说可能更独特的例子。假设我们正在构建一个应用程序的原型，然而，我们试图节省一些时间来设计一个数据库和实现一堆 SQL 存储库。因此，我们决定创建快速而肮脏的内存库(<a class="ae lc" rel="noopener ugc nofollow" target="_blank" href="/in-memory-repositories-a-forgotten-design-tool-1613151b8491">内存库:被遗忘的设计工具</a>)。创建这些存储库的时间在前期要便宜得多，因此在原型开发期间是有意义的。</p><p id="1d79" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，当我们在本地调试时，很快就会遇到问题…</p><p id="00f8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每次我们停止应用程序时，数据都会被清除。</p><p id="4710" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">解决这个问题的一个方法是创建一些初始化器，当我们在开发时，这些初始化器将在启动时初始化我们的内存“数据库”。这样，我们就有了可以测试的数据。</p><p id="954b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们定义几个我们将使用的接口。我们将省略这些实现，因为它们在这里无关紧要。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">产品存储库</figcaption></figure><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">类别知识库</figcaption></figure><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">库存仓库</figcaption></figure><p id="4b61" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些已经够直接了。我们省略了剩余的 CRUD 操作，因为我们在这个例子中不需要它们。</p><p id="47e0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们想从一个初始化器中建立我们的内存数据库。首先，我们确实应该创建一个可以在初始化器中使用的构建器。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="785f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个特殊的例子中，我们正在做一件有趣的事情。我们正在输出构建好的对象。你可能想知道为什么。这里的想法是，在我们准备好之前，我们不想持久存储这些数据(调用<code class="fe nc nd ne nf b">BuildAsync</code>)，但是我们在构建时需要标识符。这造成了一个难题。</p><p id="8603" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们是否立即将所有内容添加到数据库中并存储标识符？或者我们在构建器中跟踪对象及其依赖关系吗？还是我们手动处理？</p><p id="6d0c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一般来说，没有正确的答案。然而，就我而言，有几件事我们是知道的。</p><ol class=""><li id="254b" class="nl nm iq jp b jq jr ju jv jy nn kc no kg np kk nq nr ns nt bi translated">我们使用的是内存数据库，但是我们可能希望在某个时候为 SQL Server 重用这个构建器。</li><li id="4187" class="nl nm iq jp b jq nu ju nv jy nw kc nx kg ny kk nq nr ns nt bi translated">我们假设实体会发生变异，标识符会在插入时设置(就像 EF 一样)。这是一个我们用代码做的没有记录的契约，所有的实现都必须遵守它(最好有一些测试来确保这一点)。</li><li id="5f45" class="nl nm iq jp b jq nu ju nv jy nw kc nx kg ny kk nq nr ns nt bi translated">这是为了现在的开发目的，所以我们想使它变得简单，并限制初始化我们的数据所花费的时间。我们需要限制我们为此所做的工作量，否则我们可能会浪费宝贵的开发周期。</li></ol><p id="9b45" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于这些原因，我选择输出在多个阶段使用的对象。</p><p id="6069" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们定义一个简单的初始化器接口。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="b14a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里没什么复杂的。我们将简单地在我们的<code class="fe nc nd ne nf b">Program.cs</code>中做以下事情来确保我们运行初始化，</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="daa3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下一部分是构建器本身的实现，</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="1407" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您会注意到构建步骤将所有东西都推到提供的存储库中。请记住，我们假设这些回购坚持契约，并在每个实体上设置标识符。</p><p id="e57b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">之后，我们清空列表。一会儿你就会明白为什么了。</p><p id="b0fc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后要做的事情是创造我们的<code class="fe nc nd ne nf b">DevelopmentTestingInitializer</code>。这就是我们要使用构建器的地方。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="34e9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如您在这里看到的，我多次调用构建器上的<code class="fe nc nd ne nf b">BuildAsync</code>。这是为了节省每次创建构建器的时间。在这种情况下，它并不昂贵，因此我们可以安全地创建它 3 次。这更多的是为了举例。</p><p id="109d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在每次构建之后，我们假设<code class="fe nc nd ne nf b">Id</code>已经被填充了。这允许我们将项目传递到流程的下一个阶段。但是，在该方法的最后一部分，我们忽略了输出。我们不需要库存记录，所以我们丢弃了它们。</p><blockquote class="nz oa ob"><p id="298d" class="jn jo kl jp b jq jr js jt ju jv jw jx oc jz ka kb od kd ke kf oe kh ki kj kk ij bi translated">现在应该注意的是，这只是一个严格的例子。这里有许多错误，但我这样做是为了简洁。例如，我们真的不应该以这种方式将构建器注入到类中。相反，它应该是某种类型的构建器工厂，或者可能是我们完全忘记了构建器接口，而只是直接在初始化器类中建立具体的构建器类。这个例子的目的是展示如何构建一个复杂的系统，我相信我已经提供了。</p></blockquote><h2 id="bd02" class="mo lm iq bd ln mp mq dn lr mr ms dp lv jy mt mu lz kc mv mw md kg mx my mh mz bi translated">示例摘要</h2><p id="9b90" class="pw-post-body-paragraph jn jo iq jp b jq mj js jt ju mk jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">在本例中，我们采用了更传统的方法。当我们必须构建复杂的主题时，这种方法是最常见的。这不是一个我们构建单一类型的单一容器的例子。相反，它需要多个步骤，按顺序排列，最后是一个构建步骤。</p><p id="684f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我们知道主题的复杂性超出一个简单的列表时，我们应该使用这种方法。然而，如果我们可以利用列表法(下一节)，我们应该尽一切努力这样做。</p><h1 id="af52" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">容器方法(不太常见)</h1><p id="c0ab" class="pw-post-body-paragraph jn jo iq jp b jq mj js jt ju mk jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">按照本文的定义，容器只是一个项目列表或集合。根据容器的复杂程度，我们可能需要也可能不需要一组构建器方法。</p><p id="0131" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">记住，<code class="fe nc nd ne nf b">IServiceCollection</code>是一个简单的容器。但是在。NET 核心生态系统为依赖注入的使用构建了这个集合。这种方法的强大之处在于接口和容器实现的简单性，同时提供了在不改变接口的情况下进行无限扩展的能力。</p><p id="7544" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">只要有可能，我们应该尝试使用这种方法，因为契约很简单，而且我们的构建器的可扩展性几乎是无限的。</p><p id="a3d7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们用一个我以前在文章中没有展示过的例子。</p><p id="ce9c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我想建立一个动态数据字段集，可以在自定义工作流系统中使用。我们可能关心许多不同的数据字段:</p><ol class=""><li id="2e95" class="nl nm iq jp b jq jr ju jv jy nn kc no kg np kk nq nr ns nt bi translated"><strong class="jp ir">评论</strong>:允许用户允许评论的输入</li><li id="d0b3" class="nl nm iq jp b jq nu ju nv jy nw kc nx kg ny kk nq nr ns nt bi translated"><strong class="jp ir">日期和时间</strong>:允许用户插入日期、时间或日期/时间的输入</li><li id="7a02" class="nl nm iq jp b jq nu ju nv jy nw kc nx kg ny kk nq nr ns nt bi translated"><strong class="jp ir">文本</strong>:允许用户插入纯文本的输入</li><li id="3334" class="nl nm iq jp b jq nu ju nv jy nw kc nx kg ny kk nq nr ns nt bi translated">Uri :允许用户插入链接的输入，这些链接是经过验证的</li><li id="ad70" class="nl nm iq jp b jq nu ju nv jy nw kc nx kg ny kk nq nr ns nt bi translated"><strong class="jp ir">枚举选择</strong>:允许用户从枚举列表中选择的输入</li></ol><blockquote class="nz oa ob"><p id="96ce" class="jn jo kl jp b jq jr js jt ju jv jw jx oc jz ka kb od kd ke kf oe kh ki kj kk ij bi translated">我不会在示例中使用所有这些。只是提供一个理解问题的列表。</p></blockquote><p id="64c3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些字段中的每一个都将通知一个基于<code class="fe nc nd ne nf b">IDataFieldDefinition</code>集合动态生成的 UI。我们不会讨论这些单个字段类型的实现，因为这超出了本文的范围，但是我将展示这个接口来提供一个基本的理解。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="dbcc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们需要继续创建我们的容器，它将保存要呈现到屏幕上的数据字段的有序列表。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="2d50" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们如何着手使用这个集合是一个细节问题。同样，这超出了本文的范围，但是我不想让您完全蒙在鼓里。所以，现在，我将留给你这个珍闻。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="ef1a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦我们建立了一个集合，我们将创建我们的渲染上下文，并根据我们设置的任何算法来渲染集合。我们可以创造一个<code class="fe nc nd ne nf b">JsonPageRenderer</code>或者<code class="fe nc nd ne nf b">RazorPageRenderer</code>或者<code class="fe nc nd ne nf b">CommandLineRenderer</code>。理论上它可以是任何东西。你只需要用你的魅力。</p><p id="50aa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们有了最终结果，我们需要构建一些项目。我们可以这样做，</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="7b48" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是你不觉得这有点麻烦吗？从技术上来说，我们正在建立集合，但男人不觉得冗长。</p><p id="dd24" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们创建一些扩展方法来帮助我们。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="dbf0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，要使用这些扩展，我们可以做以下事情，</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="16af" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在这更直观了。而且更容易读懂。我想我更喜欢这种方式，而不是最后一种处理容器构建场景的方式。</p><h2 id="c82c" class="mo lm iq bd ln mp mq dn lr mr ms dp lv jy mt mu lz kc mv mw md kg mx my mh mz bi translated">示例摘要</h2><p id="96bf" class="pw-post-body-paragraph jn jo iq jp b jq mj js jt ju mk jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">这种方法最适合容器。虽然您可以在传统方法上使用扩展，老实说，这是值得鼓励的，但并不常见。然而，不要忽视使用构建器模式可以构建什么。我们对容器使用这种方法的原因是，它使开发人员的工作变得更加容易。这需要一些前期工作，但最终，我觉得这是值得的。</p></div><div class="ab cl ld le hu lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="ij ik il im in"><h1 id="d616" class="ll lm iq bd ln lo ng lq lr ls nh lu lv lw ni ly lz ma nj mc md me nk mg mh mi bi translated">结论和签署</h1><p id="f9bc" class="pw-post-body-paragraph jn jo iq jp b jq mj js jt ju mk jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">构建器模式是我们共同历史的重要组成部分。作为开发人员，我们已经经历了 30 多年。然而，如果使用得当，它仍然会带来很多价值。如果你正在具体地使用一个构建器，那么我们可能不会太关心接口设计或扩展方法。否则，我强烈建议在这种情况下使用扩展。</p><p id="5dbe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">扩展方法对于直接使用混凝土生成器没有意义。然而，抽象构建器或集合上的扩展方法具有巨大的优势。例如，如果您为一个集合或构建器接口构建 10 个不同的实现，这些扩展方法将自动地与它们一起工作。这是我喜欢扩展方法的主要原因。</p><p id="ab38" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有些人可能会说这不是真正的 OOP，但是你知道吗，我不确定我是否在乎。它节省了时间，提高了我的效率，并允许我轻松地扩展功能。每当我们为一个构建器组装一个接口时，我们应该致力于保持方法和属性的数量最少，这样我们就可以得到扩展方法的全部影响。</p><p id="1a19" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我保证，你不会失望的。</p><p id="a0d6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正确使用构建器模式，选择正确的方法，你就不会出错。但是任何东西都要适度使用。过度使用和使用不足一样会伤害代码库。</p><p id="bb00" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你喜欢这篇文章，请在 medium 上关注我。它鼓励我继续写作！</p><p id="92e3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">权力越大越好<em class="kl">单身</em>责任<em class="kl">原则</em>！</p></div></div>    
</body>
</html>