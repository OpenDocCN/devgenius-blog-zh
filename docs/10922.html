<html>
<head>
<title>The Misconception About React Memory Leak!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">对反应内存泄漏的误解！</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/the-misconception-about-react-memory-leak-c6d983aba21b?source=collection_archive---------5-----------------------#2022-12-07">https://blog.devgenius.io/the-misconception-about-react-memory-leak-c6d983aba21b?source=collection_archive---------5-----------------------#2022-12-07</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/4c78bd4eb4cfce6fdcca9a28ac66cb21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YN27ObrVTer4Mn4a"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">乔·兹洛梅克在<a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片说明了泄漏情况。</figcaption></figure><p id="062b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我写这篇文章是为了帮助澄清关于 React 内存泄漏的误解。有很多关于如何避免 React 内存泄漏的文章，但是很多文章都使用了一个不会导致内存泄漏的例子。</p><p id="9f43" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们看看经常使用的例子:</p><pre class="ky kz la lb gt lc ld le bn lf lg bi"><span id="6726" class="lh li in ld b be lj lk l ll lm">import { useState, useEffect } from "react";<br/>​<br/>export const UserList = () =&gt; {<br/>  const [users, setUsers] = useState(null);<br/>​<br/>  useEffect(() =&gt; {<br/>    const getUsers = async () =&gt; {<br/>      const usersResponse = await fetch("https://dummy-api.com/api/v1/users");<br/>      setUsers(await usersResponse.json());<br/>    };<br/>    getUsers();<br/>  }, []);<br/>​<br/>  return (<br/>    &lt;&gt;<br/>       ...my-jsx...<br/>    &lt;/&gt;<br/>  );<br/>};</span></pre><p id="ad19" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">上面的代码演示了一个简单的 React 组件获取数据并将结果设置为状态。但是如果用户在 API 响应之前从组件导航会发生什么呢？答案是在组件被卸载后调用 setState。这意味着我们在一个卸载的组件上设置状态。React &lt;= 17 was throwing an error within the console as the image below is showing.</p><figure class="ky kz la lb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ln"><img src="../Images/64976213663dc66800f7d74ae8606b01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eQZX4m5UZ-781RcNTJrGpw.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">- Warning: Can’t perform a React state update on an unmounted component.</figcaption></figure><p id="0315" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Is it true that this case is causing memory leaks as the message tells us? To understand it, we need some basic understanding of memory management.</p><h1 id="41b7" class="lo li in bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">Memory Management</h1><p id="803a" class="pw-post-body-paragraph ka kb in kc b kd ml kf kg kh mm kj kk kl mn kn ko kp mo kr ks kt mp kv kw kx ig bi translated">Every programming language needs to handle memory. With low-level languages, the programmer needs to administrate the memory manually. In high-level languages like JavaScript, it’s handled automatically.</p><p id="39db" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">The concept of memory management consists of three life cycles which are almost the same regardless of the language.</p><ol class=""><li id="e283" class="mq mr in kc b kd ke kh ki kl ms kp mt kt mu kx mv mw mx my bi translated">Allocating the needed memory</li><li id="305c" class="mq mr in kc b kd mz kh na kl nb kp nc kt nd kx mv mw mx my bi translated">Use the allocated memory</li><li id="f9bb" class="mq mr in kc b kd mz kh na kl nb kp nc kt nd kx mv mw mx my bi translated">Release the allocated memory when it’s not needed</li></ol><p id="b9d0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Within this article, I'm not going to explain those life cycles in detail. But we need to understand what release of the allocated memory is meaning and how it is done within JavaScript.</p><h2 id="6054" class="ne li in bd lp nf ng dn lt nh ni dp lx kl nj nk mb kp nl nm mf kt nn no mj np bi translated">Release of the allocated memory</h2><p id="f231" class="pw-post-body-paragraph ka kb in kc b kd ml kf kg kh mm kj kk kl mn kn ko kp mo kr ks kt mp kv kw kx ig bi translated">Release of the allocated memory means removing data within the memory that is not needed anymore. The release of allocated memory in JavaScript is accomplished by a Garbage Collector (GC), and therefore developers don't need to handle releasing of memory manually.</p><p id="f8ef" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Releasing allocated memory by reference is the main concept within Garbage Collectors. The reference concept is about whether an object has any other objects referencing it or not. If the object does not have anyone other objects referencing/pointing to it, it's collectable for the GC to release the allocated memory.</p><h1 id="fb20" class="lo li in bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated"><strong class="ak">回到 React 示例</strong></h1><p id="fd53" class="pw-post-body-paragraph ka kb in kc b kd ml kf kg kh mm kj kk kl mn kn ko kp mo kr ks kt mp kv kw kx ig bi translated">现在，我们对内存管理有了更多的了解，并且我们可以更好地理解为什么在本文顶部看到的代码示例中没有真正的内存泄漏。</p><p id="063e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">那么，如果在一个卸载的组件上调用 setState，会发生什么呢？因为 API 调用是一个承诺，一旦它被设置，就不再有对状态对象的连续引用。</p><p id="03c2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们了解到没有其他对象引用它的对象对于 GC 来说是可收集的。因为我们用户的状态没有任何其他对象引用它，所以它将被收集并从分配的内存中释放。因此，我们看到的关于内存泄漏的消息在这个特定场景中是不真实的。</p><p id="b8f3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果我们的组件订阅的是 WebSocket 连接，而不是 Promise HTTP 请求，那么就会出现内存泄漏。因为订阅的 WebSocket 连接将一直监听事件，所以会有内存泄漏。因此，将会有另一个引用状态的对象。正如我们所了解的，被另一个对象引用的对象不能被 GC 收集。</p><h1 id="c896" class="lo li in bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">结论</h1><p id="6db8" class="pw-post-body-paragraph ka kb in kc b kd ml kf kg kh mm kj kk kl mn kn ko kp mo kr ks kt mp kv kw kx ig bi translated">来自 React 的消息是一个误报，让开发人员误以为在 HTTP 请求响应之前卸载组件时，他们通过向后端发出常规 HTTP 请求而导致内存泄漏。</p><p id="ca49" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">React 合并了一个 Pull 请求来删除关于内存泄漏的错误消息。请随意查看 Github、<a class="ae jz" href="https://github.com/facebook/react/pull/22114" rel="noopener ugc nofollow" target="_blank">https://github.com/facebook/react/pull/22114</a>上的拉取请求，了解更多详情。</p><p id="a458" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">感谢阅读！🙌</p></div></div>    
</body>
</html>