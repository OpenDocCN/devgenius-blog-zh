# 日常编码问题:问题 7

> 原文：<https://blog.devgenius.io/daily-coding-problem-problem-7-d2dc3bbf7c30?source=collection_archive---------11----------------------->

![](img/c9bda24ea440a6681b7525087fe47bb1.png)

照片由 [XPS](https://unsplash.com/@xps?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 在 [Unsplash](https://unsplash.com/t/business-work?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上拍摄

我又遇到了另一个问题！。

# 问题

> 给定映射 a = 1，b = 2，… z = 26，以及一个编码的消息，计算它可以被解码的方式的数量。
> 
> 例如，消息“111”将给出 3，因为它可以被解码为“aaa”、“ka”和“ak”。
> 
> 您可以假设这些消息是可解码的。例如，不允许使用“001”。

尝试在这里应用暴力方法可能有点困难。我不是第一个想到暴力方法的。我看问题后最初的思维过程是用子问题来解决。比如，设编码后的消息为`12345`。这个问题可以分为两部分。

`1` + `2345`和`12` + `345`

这里`1`翻译成`a`，`12`翻译成`l`。

但是问题不能总是分成两个子问题。考虑案例`3345`。这里如果我们把问题分成两部分，我们得到

`3` + `345`和`33` + `45`

但是`33`什么也没翻译过来。允许的范围是`[1,26]`。所以这可以递归求解。既然是递归求解，那就来找基础条件吧。

1.  如果我们得到一个空字符串`''`,我们返回`1`,因为，一个空的编码字符串转换成一个空字符串。
2.  如果我们在编码的字符串中找到任何`0`，我们返回`0`，因为`0`什么也没有翻译。

有了这些，让我们试试我们的第一个解决方案。我们使用一个辅助函数`helper`和变量`k`来避免修改输入`data`。

# 解决方案 1:递归

**Python:**

**去:**

如果我们仔细观察，我们的解类似于`fibonacci`解。因为它是相同的，我们的时间复杂度也与 O(2^n).相似使用动态编程和记忆可以很容易地解决这个问题。不要被这些花哨的词语吓到。我们的解决方案的问题是，我们正在重新计算已经计算过的子问题。这样做增加了我们的计算时间。一种解决方法是存储我们之前计算的解决方案，并在同样的问题再次出现时使用它。这样，我们的解决方案就不会花费时间进行重新计算。

# 解决方案 2:记忆化

**Python:**

**去:**

时间复杂度: O(n)

**空间复杂度:** O(n)

我希望你们喜欢这篇文章。

如果你觉得有帮助，请分享和鼓掌非常感谢！😄

欢迎在评论区提问！。