<html>
<head>
<title>Introduction to React Hooks — Basic Hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React 挂钩简介—基本挂钩</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/introduction-to-react-hooks-e49738432f54?source=collection_archive---------11-----------------------#2020-06-06">https://blog.devgenius.io/introduction-to-react-hooks-e49738432f54?source=collection_archive---------11-----------------------#2020-06-06</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="65f2" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">用 React 钩子构建 web 应用程序的快速指南。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/b4f75fa2598d2b71018b43c262d6681e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_GZO1oEtSkFY405QQK02VA.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">马文·迈耶在<a class="ae ks" href="https://unsplash.com/s/photos/web-deveopment?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="2cac" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">React 钩子从 React 16.8 开始可用，从版本 0.59 开始支持 React Native。通常，我们知道 React 类组件是有状态的，而函数组件是无状态的。当有状态组件可以保持状态并处理数据变化时，无状态组件在功能上既没有状态也没有逻辑，而是通过 props render React 元素获取数据。</p><p id="4f03" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">所以，一般反应应用程序，父类组件保持状态并根据逻辑变化。然后，子功能组件通过 props 传递数据，并在不做任何更改的情况下呈现它们。</p><p id="dea0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">但是不再需要使用 React 类组件。使用带有 React 挂钩的功能组件…</p><p id="9f56" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">什么是反应钩子</strong></p><blockquote class="lp lq lr"><p id="576a" class="kt ku ls kv b kw kx jo ky kz la jr lb lt ld le lf lu lh li lj lv ll lm ln lo ig bi translated">钩子是让你从功能组件中“钩入”反应<strong class="kv io">状态</strong>和<strong class="kv io">生命周期特性</strong>的功能。钩子在类内部不起作用——它们让你在没有类的情况下使用 React。<a class="ae ks" href="https://reactjs.org/docs/hooks-state.html" rel="noopener ugc nofollow" target="_blank">来源</a></p></blockquote><p id="4de7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">根据上述语句 React Hooks 启用功能组件中的<strong class="kv io">状态</strong>和<strong class="kv io">生命周期特性</strong>。通过使用 React 钩子，你可以使用所有的特性而不需要一个类。你也不需要修改任何已经写好的代码来移动钩子。您可以在组件之间重用有状态逻辑，而无需改变它们的组件层次结构。也不需要使用生命周期方法，如<em class="ls">componentdimount()</em>，<em class="ls"> componentDidUpdate() </em>来执行副作用，使代码重用和代码组织更加困难。</p><p id="05c7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这里我将讨论基本<strong class="kv io">基本挂钩</strong>和<strong class="kv io">定制挂钩</strong>的比较类的组件。</p><p id="729e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">基本钩子:<br/>T25】使用状态<br/>使用效果<br/>使用上下文</p><p id="83c5" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">使用状态</strong></p><p id="c6fe" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们可以使用类和函数来编写 React 组件。首先，我编写 App 类组件。这里，显示的名称根据输入文本的改变而改变。这很简单，做起来…</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lw lx l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">图 1</figcaption></figure><p id="c223" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在，试着把上面的任务写成一个函数组件。我想添加“名称”状态变量的当前值，另一个是设置名称状态变量的函数“setName”。但是我很纠结(图 2 中的第 5 行和第 6 行),因为函数组件是无状态的？？</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lw lx l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">图 2</figcaption></figure><p id="90d3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">用钩子解决这个问题。<em class="ls">使用状态</em>从反应本地状态到功能组件解决问题。传递“helloWorld”来初始化状态名。这里，<em class="ls">使用状态</em>是一个钩子，它是 React 中的一个函数。<em class="ls">使用状态</em>可以在一个函数中多次使用</p><pre class="kd ke kf kg gt ly lz ma mb aw mc bi"><span id="d9d0" class="md me in lz b gy mf mg l mh mi"> import React, {<em class="ls">useState</em>} from ‘react’<br/> const [name, setName]= <em class="ls">useState</em>(‘helloWorld’); </span></pre><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lw lx l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">图 3</figcaption></figure><p id="14ad" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">使用效果</strong></p><p id="ce5f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">类有生命周期方法，从 React 组件的诞生到死亡，一系列事件执行这些方法。任何组件都会经历安装、更新和卸载。我们使用一些循环方法如<em class="ls">componentidmount()</em>，<em class="ls">componentiddupdate()</em>，<em class="ls"> componentWillUnmount() </em>等在类组件中执行副作用。像数据获取、订阅或从 React 组件手动更改 DOM 这样的操作被称为副作用。在下面的代码中添加了<em class="ls">componentdimount()</em>，<em class="ls"> componentDidUpdate() </em>来随着输入名称的改变而改变文档标题。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lw lx l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">图 4</figcaption></figure><p id="c3a3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">render()方法是纯的，没有副作用，因为它们会影响其他组件。那么如何在函数组件中实现呢？<em class="ls">使用效果</em>挂钩习惯了。在初始渲染和每次更新后都运行。<em class="ls"> useEffect </em>也是不止一次使用。</p><pre class="kd ke kf kg gt ly lz ma mb aw mc bi"><span id="0895" class="md me in lz b gy mf mg l mh mi">useEffect(()=&gt;{<br/>    document.title = name<br/>});</span></pre><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lw lx l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">图 5</figcaption></figure><p id="91c1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">使用上下文</strong></p><p id="354d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">Context API 提供了一种简单明了的方法来在组件之间共享状态，而不需要 React 本身传递属性。在这里浏览我以前的文档，学习更多关于上下文 API 的知识。<em class="ls"> useContext </em> hook 接受 Context 对象，其值从<em class="ls"> React.createContext()返回。</em></p><p id="633f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在示例<em class="ls">中，ColorContext </em>的默认值为 light。</p><pre class="kd ke kf kg gt ly lz ma mb aw mc bi"><span id="9628" class="md me in lz b gy mf mg l mh mi">const colors = {<br/> light: ‘white’,<br/> dark: ‘black’,<br/> danger: ‘red’<br/>}</span><span id="08ce" class="md me in lz b gy mj mg l mh mi">const ColorContext = React.createContext(colors.light);</span></pre><p id="9295" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="ls"> Home </em>函数<em class="ls"> useContext </em>接受<em class="ls"> ColorContext。</em></p><pre class="kd ke kf kg gt ly lz ma mb aw mc bi"><span id="04ee" class="md me in lz b gy mf mg l mh mi">function Home(){<br/> const color = useContext(ColorContext);<br/> return(<br/>  &lt;text style={{color: color.danger}} &gt;Hello world&lt;/text&gt;<br/> )<br/>}</span></pre><p id="b362" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">然后是<em class="ls"> &lt; ColorContext。提供者&gt; </em>提供了访问上下文的能力，上下文是从它包装的(这里是<strong class="kv io">的家)</strong>。它提供了向下传递给所有组件的数据和函数。</p><pre class="kd ke kf kg gt ly lz ma mb aw mc bi"><span id="7526" class="md me in lz b gy mf mg l mh mi">export default function App() {</span><span id="a902" class="md me in lz b gy mj mg l mh mi">return (<br/> &lt;ColorContext.Provider value={colors}&gt;<br/>  &lt;Home/&gt;<br/> &lt;/ColorContext.Provider&gt;<br/> );<br/>}</span></pre><p id="90c1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">完整的代码，</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="3df5" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">定制挂钩</strong></p><blockquote class="lp lq lr"><p id="dcde" class="kt ku ls kv b kw kx jo ky kz la jr lb lt ld le lf lu lh li lj lv ll lm ln lo ig bi translated">自定义钩子是一个 JavaScript 函数，它的名字以“use”开头，可以调用其他钩子。<a class="ae ks" href="https://reactjs.org/docs/hooks-custom.html" rel="noopener ugc nofollow" target="_blank">来源</a></p></blockquote><p id="a9ef" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">定制钩子的目标是防止复制逻辑。自定义挂钩允许在组件之间重用有状态逻辑，而无需添加更多组件。这段代码中的逻辑是独立于<em class="ls"> useNameInput() </em>和<em class="ls"> useDocumentTitle() </em>函数的。现在它们是钩子。现在自定义钩子完全独立于状态本身。所以现在你可以在一个组件中多次使用定制钩子。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lw lx l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">图 6</figcaption></figure><p id="243e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">挂钩规则</strong></p><p id="0a82" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">有两个规则来挂钩另外使用的 JavaScript 函数规则。</p><blockquote class="lp lq lr"><p id="4a56" class="kt ku ls kv b kw kx jo ky kz la jr lb lt ld le lf lu lh li lj lv ll lm ln lo ig bi translated">只调用顶层的钩子<strong class="kv io">。不要在循环、条件或嵌套函数中调用钩子。</strong></p><p id="c50f" class="kt ku ls kv b kw kx jo ky kz la jr lb lt ld le lf lu lh li lj lv ll lm ln lo ig bi translated">仅从 React 函数组件调用挂钩<strong class="kv io">。不要从常规的 JavaScript 函数中调用钩子。<a class="ae ks" href="https://reactjs.org/docs/hooks-rules.html" rel="noopener ugc nofollow" target="_blank">来源</a></strong></p></blockquote><p id="50e6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">结论</strong></p><p id="f229" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在本文中，我们讨论了 React 钩子的基本概念以及 React 引入钩子的原因。然后用钩子构建功能组件，并与类组件进行比较。主要讨论<em class="ls">使用状态</em>、<em class="ls">使用效果</em>、<em class="ls">使用上下文</em>和自定义钩子以及钩子的规则。我想这篇文章对那些进入 React Hooks 的人会有所帮助。接下来，我们将讨论:</p><div class="mk ml gp gr mm mn"><a href="https://medium.com/dev-genius/introduction-to-react-hooks-usereducer-7b87a6cb4289" rel="noopener follow" target="_blank"><div class="mo ab fo"><div class="mp ab mq cl cj mr"><h2 class="bd io gy z fp ms fr fs mt fu fw im bi translated">React 挂钩简介— useReducer</h2><div class="mu l"><h3 class="bd b gy z fp ms fr fs mt fu fw dk translated">使用 React Hooks 构建 web 应用程序的快速指南。</h3></div><div class="mv l"><p class="bd b dl z fp ms fr fs mt fu fw dk translated">medium.com</p></div></div><div class="mw l"><div class="mx l my mz na mw nb km mn"/></div></div></a></div><div class="mk ml gp gr mm mn"><a href="https://medium.com/dev-genius/performance-optimization-with-react-hooks-usecallback-usememo-f2e527651b79" rel="noopener follow" target="_blank"><div class="mo ab fo"><div class="mp ab mq cl cj mr"><h2 class="bd io gy z fp ms fr fs mt fu fw im bi translated">React 挂钩的性能优化—使用回调和使用备忘录</h2><div class="mu l"><h3 class="bd b gy z fp ms fr fs mt fu fw dk translated">使用 useCallback &amp; useMemo 钩子优化 web 应用程序性能的介绍。</h3></div><div class="mv l"><p class="bd b dl z fp ms fr fs mt fu fw dk translated">medium.com</p></div></div><div class="mw l"><div class="nc l my mz na mw nb km mn"/></div></div></a></div><p id="ac52" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">参考文献</strong></p><div class="mk ml gp gr mm mn"><a href="https://reactjs.org/docs/hooks-intro.html" rel="noopener  ugc nofollow" target="_blank"><div class="mo ab fo"><div class="mp ab mq cl cj mr"><h2 class="bd io gy z fp ms fr fs mt fu fw im bi translated">介绍钩子-反应</h2><div class="mu l"><h3 class="bd b gy z fp ms fr fs mt fu fw dk translated">钩子是 React 16.8 中的新增功能。它们允许您使用状态和其他 React 特性，而无需编写类。这个…</h3></div><div class="mv l"><p class="bd b dl z fp ms fr fs mt fu fw dk translated">reactjs.org</p></div></div><div class="mw l"><div class="nd l my mz na mw nb km mn"/></div></div></a></div><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ne lx l"/></div></figure></div></div>    
</body>
</html>