<html>
<head>
<title>Uplift Your Java Spring Boot To WebFlux Non-Blocking Application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将您的Java Spring Boot升级到WebFlux非阻塞应用程序</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/uplift-your-java-spring-boot-to-webflux-non-blocking-application-7b207999e669?source=collection_archive---------0-----------------------#2021-04-18">https://blog.devgenius.io/uplift-your-java-spring-boot-to-webflux-non-blocking-application-7b207999e669?source=collection_archive---------0-----------------------#2021-04-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="32d6" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">构建反应式Spring WebFlux快速指南</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/67e68ddcd5181739e0ce246d85d0e314.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3L6sLf9dzfR9V8_T"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">米卡·廷德尔在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="37e4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Spring MVC一直是一个流行的框架，不仅因为它的简单，还因为它提供了广泛的生产就绪特性，支持快速的系统开发。许多企业基于该框架构建了任务关键型系统。然而，这项技术并非没有缺点。它的每请求线程设计和同步I/O操作已经成为一个突出的问题，因为该设计会阻塞当前线程，直到它收到来自I/O操作(如文件访问、数据库访问和API消费)的响应。一方面，这种阻塞过程的编程使得编码更简单且易于处理，另一方面，这种设计导致计算资源的低效使用，并在具有大量请求的环境中引起性能问题。</p><p id="bbae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好消息是，该框架经历了一次革命性的突破，它创建了一套独立的技术堆栈，称为Spring WebFlux，支持端到端的异步I/O流程，并采用了事件循环而不是每请求一个线程的方法。主要好处是实现了高系统性能，同时需要较少的计算资源。</p><p id="aede" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Spring WebFlux很吸引人，经过多年的开发，这个技术栈已经成熟，可以用于生产。这一点值得注意，因为非阻塞系统的实现可能是一种未来的系统解决方案。我将分享如何构建一个反应式Spring REST API，并找出它与Spring MVC的系统开发有何不同。如果您习惯于使用Spring MVC编码系统，并且对探索更多关于Spring Reactive的内容感兴趣，那么这篇文章将是一个很好的参考。</p><h1 id="92ef" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">概观</h1><p id="2501" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">传统的Spring web框架基于Servlet堆栈，它通过为每个请求分配一个线程来处理传入的请求。而且，底层技术的I/O操作都是阻塞过程。换句话说，修改原始的Spring MVC框架以支持异步I/O并不是简单地改变某些组件，而是需要在系统架构的所有层上进行彻底的技术转移。</p><p id="2d6f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面的逻辑组件图展示了原始Spring MVC和Spring WebFlux之间的比较。这些变化不仅涉及web框架，还涉及web容器、安全性以及数据库访问。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mp"><img src="../Images/38f9b116a20d6ba5dabd091eefbadc4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*81f4t-YApaI6xX452W2VrA.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">Spring反应堆栈vs Servlet堆栈(来源:【https://spring.io/reactive】T4)</figcaption></figure><p id="4130" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可能会担心从零开始学习另一个全新的框架。事实上，即使幕后有巨大的变化，使用这种技术也很容易获得发展。感谢Spring团队，Spring是一个高质量的框架，具有周到和开发者友好的设计。你会发现Spring WebFlux应用的注释使用和整体结构和Spring MVC很相似。</p></div><div class="ab cl mq mr hu ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ij ik il im in"><h1 id="3b41" class="ls lt iq bd lu lv mx lx ly lz my mb mc jw mz jx me jz na ka mg kc nb kd mi mj bi translated">反应式编程一览</h1><p id="0012" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">熟悉WebFlux Spring应用程序开发的反应式编程至关重要。这种思维模式不同于传统的命令式编程，后者是一系列指令和逻辑。由于I/O操作是异步的，方法调用在发布/订阅模型中工作，因此方法调用将立即返回发布者对象，而无需等待I/O执行。然后，依赖于该数据的程序逻辑可以订阅发布者对象并获取数据以供进一步处理。</p><p id="1053" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">反应式编程是通过将系统逻辑构建为数据流和数据操作过程来以发布/订阅模型方法处理程序异步操作的方法之一。</p><p id="99de" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面这个简单的例子是根据产品信息和促销数据获取产品价格。程序逻辑首先检索产品记录，然后是促销信息，然后计算产品价格。整个过程是按顺序一步一步执行的，所以只有在当前操作完成后才会调用下一步。</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="6399" class="nh lt iq nd b gy ni nj l nk nl">Product product = productRespository.findById(productId);</span><span id="fd53" class="nh lt iq nd b gy nm nj l nk nl">Promotion promotion = promotionRepository.findByid(promotionId);</span><span id="e169" class="nh lt iq nd b gy nm nj l nk nl">Double productPrice = product.getPrice() — promotion.getDiscount();</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/5b54853e1150772d66584a0d9b3c5c6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*JGAMG4lN4AHvJGHlzWpALQ.jpeg"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">产品价格计算逻辑流程(同步流程)</figcaption></figure><p id="c879" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用反应式编程可以实现相同的逻辑，它调用I/O操作同时检索产品和促销，然后数据流将加入价格计算的记录。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/935197351be4cc18952125b90b19529f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*PuA1kFl_k3pheru4pCVefw.jpeg"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">产品价格计算逻辑流程(异步数据流)</figcaption></figure><p id="391d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下是Spring Reactive的示例代码:</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="0bab" class="nh lt iq nd b gy ni nj l nk nl">Mono&lt;Product&gt; product = productRepository.findById(productId);</span><span id="1501" class="nh lt iq nd b gy nm nj l nk nl">Mono&lt;Promotion&gt; promotion = promotionRepository.findById(promotionId);</span><span id="3527" class="nh lt iq nd b gy nm nj l nk nl">Mono&lt;Double&gt; productPrice = <br/>Mono.zip(product, promotion)<br/>.map(tuple -&gt; <br/>tuple.getT1().getPrice() - tuple.getT2().getDiscount())</span></pre><p id="13c5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可能会注意到返回对象被包装在一个类<strong class="ky ir"> Mono </strong>中，它是一个将检索到的数据返回给订阅者的发布者。我们可以使用出版商作为数据源，形成一个计算价格的数据流。让我们一步一步地解释数据流:</p><ol class=""><li id="e3da" class="no np iq ky b kz la lc ld lf nq lj nr ln ns lr nt nu nv nw bi translated">zip()将产品和促销组合成一个名为tuple的对象</li><li id="59d2" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr nt nu nv nw bi translated">map()是用于数据转换的函数。我们从元组中获取产品和促销，并计算价格。</li><li id="edc9" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr nt nu nv nw bi translated">计算结果被包装在单声道中</li></ol><p id="32e5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要处理返回值，可以使用lambda函数作为输入，在Mono对象上调用<em class="oc"> subscribe() </em>。一旦数据准备就绪，该函数将被调用。</p><p id="80fb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，当I/O过程完成时，价格数据将被打印到控制台。</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="5c49" class="nh lt iq nd b gy ni nj l nk nl">product.subscribe(p -&gt; { <br/>     System.out.println(p.doubleValue());<br/>});</span></pre><h2 id="9dc2" class="nh lt iq bd lu od oe dn ly of og dp mc lf oh oi me lj oj ok mg ln ol om mi on bi translated"><strong class="ak">出版商——单色/通量</strong></h2><p id="4be6" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">有两种类型的发布者<strong class="ky ir"> — </strong></p><ul class=""><li id="6ffd" class="no np iq ky b kz la lc ld lf nq lj nr ln ns lr oo nu nv nw bi translated"><strong class="ky ir"> Mono </strong>可以发布零个或单个数据</li><li id="f41a" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr oo nu nv nw bi translated"><strong class="ky ir">通量</strong>可以<strong class="ky ir"> </strong>发布零个或多个数据。</li></ul><p id="d2a2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，如果服务将返回产品记录列表，我们将对数据进行包装:</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="90e0" class="nh lt iq nd b gy ni nj l nk nl">Flux&lt;Product&gt; products = productRepository.findAll();</span></pre><p id="dbdb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您将在WebFlux Spring应用程序开发中频繁使用这两个类。</p><p id="db4d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦您熟悉了反应式编程，您将能够更快地构建Spring反应式应用程序。</p></div><div class="ab cl mq mr hu ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ij ik il im in"><h1 id="508c" class="ls lt iq bd lu lv mx lx ly lz my mb mc jw mz jx me jz na ka mg kc nb kd mi mj bi translated">Maven依赖性</h1><p id="0c44" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">由于底层技术不同，您将需要使用一组不同的Maven启动器。在Spring Initializr中，可以选择依赖关系— <strong class="ky ir"> Spring Reactive Web </strong>进行Maven / Gradle项目生成。如果需要无阻塞访问持久数据，还可以选择<strong class="ky ir"> Spring Data R2DBC </strong>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi op"><img src="../Images/e280913f9c693dcb3a46df63496bb8b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cXDhEC4wRAnbG2mxvfGFOQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">弹簧反作用应用程序的弹簧初始值</figcaption></figure><p id="62fa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">生成的Maven项目将包括以下spring boot starter依赖项:</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="6df4" class="nh lt iq nd b gy ni nj l nk nl">&lt;dependency&gt;<br/>  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br/>  &lt;artifactId&gt;spring-boot-starter-webflux&lt;/artifactId&gt;<br/>&lt;/dependency&gt;</span><span id="b000" class="nh lt iq nd b gy nm nj l nk nl">&lt;dependency&gt;<br/>  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br/>  &lt;artifactId&gt;spring-boot-starter-data-r2dbc&lt;/artifactId&gt;<br/>&lt;/dependency&gt;</span></pre></div><div class="ab cl mq mr hu ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ij ik il im in"><h1 id="6f91" class="ls lt iq bd lu lv mx lx ly lz my mb mc jw mz jx me jz na ka mg kc nb kd mi mj bi translated">控制器</h1><p id="2aa7" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">控制器为传入的请求定义入口点。它与Spring MVC非常相似，因为大多数注释都是相同的，比如<em class="oc">、@RestController、@RequestMapping、@PathVariable、</em>等等。尽管底层技术完全不同，但Spring framework会自动检测Maven依赖性，并在反应式堆栈上运行控制器。唯一的区别是使用Mono/Flux来包装响应数据。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oq or l"/></div></figure></div><div class="ab cl mq mr hu ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ij ik il im in"><h1 id="047a" class="ls lt iq bd lu lv mx lx ly lz my mb mc jw mz jx me jz na ka mg kc nb kd mi mj bi translated">REST API集成</h1><p id="d646" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">REST API是服务间集成的常见模式，尤其是在微服务架构中。<strong class="ky ir"> <em class="oc"> RestTemplate </em> </strong>是一个非常有用的进行HTTP请求的实用类，它基于阻塞I/O，由于Spring团队已经构建了一个支持异步操作的新版HTTP client<strong class="ky ir"><em class="oc">WebClient</em></strong>，团队正式宣布RestTemplate处于维护模式，并推荐开发者使用新的web客户端。</p><p id="968a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">WebClient的API设计类似于RestTemplate。方法调用很容易理解。让我们看一下关于如何使用新的web客户机发出GET和POST HTTP请求的示例代码。</p><h2 id="c603" class="nh lt iq bd lu od oe dn ly of og dp mc lf oh oi me lj oj ok mg ln ol om mi on bi translated">HTTP GET</h2><p id="fcb9" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">这个例子是通过记录id检索一个产品。URL是使用UriBuilder通过一个路径变量和查询参数构建的。响应被自动反序列化到目标对象中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oq or l"/></div></figure><h2 id="84c8" class="nh lt iq bd lu od oe dn ly of og dp mc lf oh oi me lj oj ok mg ln ol om mi on bi translated">HTTP帖子</h2><p id="7c1e" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">为了保存一个新记录，web客户端发出一个http post请求，其内容类型为标题中指定的application/json。请求体被自动序列化为JSON格式以便提交。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="9c1c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在撰写本文时，<strong class="ky ir">Spring</strong><strong class="ky ir">OpenFeign</strong>还不支持非阻塞I/O，如果你真的想使用open feign进行反应式支持的系统开发，那么你可以查看这个<a class="ae kv" href="https://github.com/Playtika/feign-reactive" rel="noopener ugc nofollow" target="_blank"> GitHub项目</a>，这也是Spring团队建议的，直到Spring OpenFeign准备好非阻塞I/O。</p></div><div class="ab cl mq mr hu ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ij ik il im in"><h1 id="86ad" class="ls lt iq bd lu lv mx lx ly lz my mb mc jw mz jx me jz na ka mg kc nb kd mi mj bi translated">数据库访问</h1><p id="3db9" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">Java中的所有关系数据库访问都依赖于底层的JDBC驱动程序，这些驱动程序是基于设计的阻塞I/O的。因此，一种全新的底层驱动程序R2DBC应运而生，以支持异步数据库访问。毫无疑问，替换底层驱动程序并重写应用程序中的每一层是一项巨大的工作。然而，社区正在快速变化，R2DBC驱动程序现在已经可以用于许多流行的数据库，如Oracle、MySQL、MS SQL server。不过，R2DBC支持NoSQL数据库，比如MongoDB和Cassandra。</p><h2 id="e8a8" class="nh lt iq bd lu od oe dn ly of og dp mc lf oh oi me lj oj ok mg ln ol om mi on bi translated">数据存储库</h2><p id="9612" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">JPA数据仓库是一个强大的工具，因为它使数据仓库的开发变得简单，并且节省了构建数据CRUD操作的样板代码的大量工作。使用JPA，开发人员可以简单地定义一个数据访问接口，然后框架会在运行时自动生成实现。尽管JPA到目前为止还不支持R2DBC，但是Spring data framework提供了类似的特性，这样您就可以通过创建带有定制查询的接口来定义数据存储库。</p><p id="47dc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，这是一个阻塞I/O的产品存储库接口。这是一个扩展到CrudRepository的JPA接口，支持基本数据访问。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="24d0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">只需简单地将继承更改为<strong class="ky ir"><em class="oc">ReactiveCrudRepository</em></strong>，您的存储库将支持无阻塞的数据库访问。所有预定义方法如<em class="oc"> save()、findAll()、findById() </em>的返回数据类型都是Mono/Flux，以支持异步操作。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="950f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它也适用于NoSQL数据库。这是MongoDB存储库定义的一个示例:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="f7d6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不幸的是，由于Hibernate等底层ORM框架目前仅支持JDBC同步操作，因此还不支持一对多、多对一和多对多等数据关系特性。因此，如果需要数据关系的支持，您将需要构建应用程序逻辑。</p></div><div class="ab cl mq mr hu ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ij ik il im in"><h1 id="4816" class="ls lt iq bd lu lv mx lx ly lz my mb mc jw mz jx me jz na ka mg kc nb kd mi mj bi translated">测试</h1><p id="4af2" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">自动化测试单元测试、集成测试和端到端测试的概念可以应用于WebFlux Spring应用程序。如果您想了解测试和模仿的基本概念，您会发现这篇文章很有用。</p><div class="os ot gp gr ou ov"><a href="https://medium.com/dev-genius/java-spring-the-best-practice-of-modern-software-quality-assurance-e5aa66466627" rel="noopener follow" target="_blank"><div class="ow ab fo"><div class="ox ab oy cl cj oz"><h2 class="bd ir gy z fp pa fr fs pb fu fw ip bi translated">Java Spring——现代软件质量保证的最佳实践</h2><div class="pc l"><h3 class="bd b gy z fp pa fr fs pb fu fw dk translated">确保软件质量的全面指南</h3></div><div class="pd l"><p class="bd b dl z fp pa fr fs pb fu fw dk translated">medium.com</p></div></div><div class="pe l"><div class="pf l pg ph pi pe pj kp ov"/></div></div></a></div><p id="7a1c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看看每个组件，看看如何为WebFlux应用程序开发测试代码。</p><h2 id="d49b" class="nh lt iq bd lu od oe dn ly of og dp mc lf oh oi me lj oj ok mg ln ol om mi on bi translated">控制器</h2><p id="6274" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">控制器上的单元测试是通过模拟所有其他依赖来隔离控制器。为了在控制器上测试而初始化部分应用上下文，可以使用Spring MVC中的<strong class="ky ir"><em class="oc">@ WebMvcTest</em></strong><em class="oc"/>对应的注释<em class="oc"/><strong class="ky ir"><em class="oc">@ WebFluxTest</em></strong><em class="oc"/>。</p><p id="5932" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了模拟http请求并验证WebFlux应用程序的响应，Spring提供了一个有用的实用程序类TestWebClient，它利用新的HTTP客户端WebClient来执行异步请求，它还为控制器的响应验证提供了额外的功能。</p><p id="d2c3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个例子验证了来自REST控制器的外汇汇率响应。只需使用<em class="oc"> @Autowired </em>注释就可以获得TestWebClient的一个实例。在请求提交给控制器之后，TestWebClient的方法可以很容易地断言状态代码和响应体。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oq or l"/></div></figure><h2 id="8e07" class="nh lt iq bd lu od oe dn ly of og dp mc lf oh oi me lj oj ok mg ln ol om mi on bi translated">成分</h2><p id="1883" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">组件单元测试的设置和注释与Spring MVC基本相同。您可以使用像<em class="oc"> @SpringJUnitConfig </em>和<em class="oc"> @ContextConfiguration </em>这样的注释来初始化测试执行的应用程序上下文。还有，使用<em class="oc"> @MockBean </em>来模仿对象和创建测试用例。</p><p id="e9e2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了验证来自Mono/Flux的数据流，Spring提供了一个实用程序类<strong class="ky ir"> <em class="oc"> StepVerifier </em> </strong>，可以依次检查Mono/Flux数据流输出的每一项。</p><p id="823b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本例的单元测试检查Flux数据流，以按顺序逐个断言数据元素。在交付3个预期项目时，StepVerifier预期这是数据流的结尾。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oq or l"/></div></figure><h2 id="ee2a" class="nh lt iq bd lu od oe dn ly of og dp mc lf oh oi me lj oj ok mg ln ol om mi on bi translated">数据存储库</h2><p id="087d" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">Spring支持使用注释<strong class="ky ir"><em class="oc">@ datar 2 DBC test</em></strong><em class="oc">，</em>对反应式数据仓库进行部分应用上下文初始化，该注释类似于同步数据仓库中的函数注释<strong class="ky ir"><em class="oc">@ DataJpaTest</em></strong><em class="oc"/>。</p><p id="3d91" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，对反应式数据存储库的单元测试比对阻塞I/O版本的数据存储库的单元测试需要更多的样板代码，因为Spring反应式数据存储库没有类似于Hibernate和<em class="oc"> @Sql </em>注释的特性。Hibernate自动创建数据表，而<em class="oc">@ Sql</em><strong class="ky ir"><em class="oc"/></strong>注释可以在单元测试用例之前运行Sql文件进行数据设置。因此，您需要构建代码来创建数据库表和测试数据设置，以便测试您的异步数据存储库。</p><p id="e429" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个例子展示了在执行每个测试用例之前重新创建数据库表的设置方法。在没有<em class="oc"> @Sql </em>注释的情况下，您可以看到示例中的测试数据设置使用了实用程序类R2dbcTemplate，首先将记录插入数据库，然后在数据存储库的<em class="oc"> findAll() </em>上执行测试。最后，使用<em class="oc"> StepVerifier </em>验证Flux数据流中的结果。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oq or l"/></div></figure><h1 id="e535" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">最后的想法</h1><p id="6d44" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">异步I/O操作能力和事件循环结构可以有效地利用计算资源，获得更好的并发性能。它优于传统的每请求线程和阻塞I/O操作，后者只能以同步方式一步一步地访问I/O。然而，使用Java实现这种设计的开发可能是一项复杂的工作。WebFlux Spring是一个非常棒的高质量框架，提供了一种简单的非阻塞系统开发方式。</p><p id="8d3d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">总的来说，技术已经成熟，可以生产了。尽管某些特性还没有实现，比如对ORM数据关系的支持和对数据库测试的支持，但是这个框架正在快速发展，在不久的将来会有更多的新特性出现。</p></div></div>    
</body>
</html>