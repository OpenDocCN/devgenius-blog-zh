<html>
<head>
<title>SonarQube Cognitive Complexity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">认知复杂性</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/sonarqube-cognitive-complexity-265640dbad3e?source=collection_archive---------2-----------------------#2022-01-07">https://blog.devgenius.io/sonarqube-cognitive-complexity-265640dbad3e?source=collection_archive---------2-----------------------#2022-01-07</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="cbba" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有时一个方法中的条件太多。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/cad8aa194c51a61ae023745295dd94f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/1*Xg3yKvRCE0cOAz8xla2RvQ.png"/></div></figure><p id="4887" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Sonar应用对开发者发现bug、冗余的地方和很多重构的动力都有极大的帮助。有时候可能会很烦，但是…</p><p id="9558" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">第一部分:SonarQube </p><p id="6d77" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">SonarQube是一个非常有用的工具。它包含了许多最流行的编程语言的规则。</p><p id="09f4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在特殊情况下，SonarQube会检查一个块中有多少个嵌套循环和条件。他开始争论这个数字是否超过了最大复杂度的极限15。</p><p id="c083" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是给开发人员的一个信号，是时候重构代码了。</p><p id="8fee" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">认知复杂性法则。</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kq"><img src="../Images/e3104ba7b51d0c1511970916404fd004.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RW_LerKcE3CxHLiMkfOpIw.png"/></div></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk translated">声纳认知复杂性的例子</figcaption></figure><p id="5b9b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">SonarQube将他在嵌套块或整个方法中找到的条件数计算为圈复杂度。当它达到极限时，SonarQube <strong class="jm io">会阻止你认为</strong>构建已经完成。</p><p id="a0fc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果您的项目将SonarQube与Bitbucket、Github、Gitlab和类似的存储库同步，它将阻止您与主分支进行合并。</p><p id="b2e0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以我们得到了SonarQube的回应:</p><p id="b013" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="kz">“重构这个函数，将其认知复杂度从26降低到允许的15。”</em>认知复杂性是衡量一个功能的控制流理解起来有多难的一个指标。认知复杂性高的功能将难以维持。</p><p id="9993" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">SonarQube计算“if”条件、嵌套循环(如“for”、“forEach”、“do-while”)以及“&amp;&amp;”和“||”的数量。</p><p id="40cb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">假设我们有一个在Java代码中充满条件的肮脏方法:</p><pre class="kj kk kl km gt la lb lc ld aw le bi"><span id="cb55" class="lf lg in lb b gy lh li l lj lk">public static final String <em class="kz">NEWLINE </em>= "\n";<br/>private String buildPriceInformation(DetailCharge charge) {</span><span id="6f11" class="lf lg in lb b gy ll li l lj lk">  String totalRate = calculateTheRate();</span><span id="25b2" class="lf lg in lb b gy ll li l lj lk">  List&lt;String&gt; lines = <em class="kz">newArrayList</em>();<br/>  lines.add(totalRate);</span><span id="5bbb" class="lf lg in lb b gy ll li l lj lk"><strong class="lb io">  if (charge.hasIdentifiers() &amp;&amp; hasDocumentPrice(charge)) {<br/>    lines.add(<em class="kz">EMPTY</em>);<br/>  }</strong><br/><br/>  if (charge.getLocation() != null) {<br/>    lines.add(<em class="kz">EMPTY</em>);<br/>  }<br/><br/>  if (charge.isFlagCharge()) {<br/>    lines.add(<em class="kz">EMPTY</em>);<br/>  }<br/>  return Joiner.<em class="kz">on</em>(<em class="kz">NEWLINE</em>).join(lines);<br/>}</span></pre><p id="3e7c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以，我们这里有4个条件的复杂性。可能的解决方案之一—将<strong class="jm io"> &amp; &amp; </strong>条件的逻辑移到另一个单独的方法中。</p><pre class="kj kk kl km gt la lb lc ld aw le bi"><span id="d097" class="lf lg in lb b gy lh li l lj lk">private boolean isChargeHasDocumentPrice(DetailCharge charge) {<br/>    return charge.hasIdentifiers() &amp;&amp; hasDocumentPrice(charge);<br/>}</span></pre><p id="c8e7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">它在SonarQube分析中减少了1个数的复杂度。所以现在我们可以在我们的主方法中这样调用它:</p><pre class="kj kk kl km gt la lb lc ld aw le bi"><span id="28eb" class="lf lg in lb b gy lh li l lj lk">if (isChargeHasDocumentPrice(charge)) {<br/>    lines.add(<em class="kz">EMPTY</em>);<br/>}</span></pre><p id="2b0f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这使得我们的源代码可读性更好。避免在一个函数中使用许多嵌套循环和条件。声纳激励我们重构我们的想法和思维方式。有时候修改旧的稳定代码是很不容易的。</p><p id="c071" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">第二部分。“如果”语句的替代项。</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi lm"><img src="../Images/c192a9b575c989d95144ea6f5a318926.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jLhdCnTWhL0sRlT9Fk3F6w.png"/></div></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk translated">只是嵌套循环和if语句的一个示例</figcaption></figure><p id="7d30" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">“如果”语句的替代方案有哪些？</p><ol class=""><li id="1ca5" class="ln lo in jm b jn jo jr js jv lp jz lq kd lr kh ls lt lu lv bi translated"><strong class="jm io">三进制记数法</strong> : result = A？如果A为真或不为空，则返回B否则返回c。</li></ol><pre class="kj kk kl km gt la lb lc ld aw le bi"><span id="c7f3" class="lf lg in lb b gy lh li l lj lk">private boolean invertBoolean(boolean b) {<br/>  return b ? false : true;<br/>}<br/>private int getMinValue(int i, int j) {<br/>  return (i &lt; j) ? i : j;<br/>}</span></pre><p id="7eb8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">2.<strong class="jm io">开关</strong>声明。</p><pre class="kj kk kl km gt la lb lc ld aw le bi"><span id="6af8" class="lf lg in lb b gy lh li l lj lk">int i = 10;<br/>switch (i) {<br/>  case 5:<br/>    System.out.println("i = 5");<br/>    break;<br/>  case 10:<br/>    System.out.println("i = 10");<br/>    break;<br/>  default:<br/>    System.out.println("i does not equals 5 or 10");<br/>}</span></pre><p id="b06d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">3.<strong class="jm io">函数式编程</strong>方法来自Java 8、Kotlin、RxJava、RxKotlin或RxJs。</p><p id="bf26" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">例如，我们有一个集合，需要检查布尔条件:</p><pre class="kj kk kl km gt la lb lc ld aw le bi"><span id="2da1" class="lf lg in lb b gy lh li l lj lk">List&lt;ChargeCode&gt; charges = getChargeCodes();<br/>for(ChargeCode c: charges) {<br/>  if(c.isResolved()) {<br/>    c.printLabel();<br/>  }<br/>}</span></pre><p id="050b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">函数式方法让我们将这些行重构为一个句子:</p><pre class="kj kk kl km gt la lb lc ld aw le bi"><span id="1803" class="lf lg in lb b gy lh li l lj lk">var result = rules.stream().filter(<!-- -->ChargeCode<!-- -->::<!-- -->isResolved<!-- -->)<br/>              .forEach(ChargeCode::printLabel);</span></pre><p id="ceef" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">4.<strong class="jm io">可选</strong>。不要在if/else之前声明变量就进行检查。</p><pre class="kj kk kl km gt la lb lc ld aw le bi"><span id="a9d2" class="lf lg in lb b gy lh li l lj lk">List&lt;String&gt; names = Arrays.asList("A", "B", "", "C", "", "D");<br/>Optional&lt;List&lt;String&gt;&gt; optionalList = Optional.of(names);</span><span id="8e2d" class="lf lg in lb b gy ll li l lj lk">int length = optionalList.map(List::size).orElse(0);</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi lw"><img src="../Images/c9730ae24d84cb67ea41c1fd47e08850.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*akaUhaiTGtAVs-dntgjaKQ.jpeg"/></div></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk translated">华金·索罗拉，1915年“圣塞巴斯蒂安的海浪”</figcaption></figure><p id="7202" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">结论</strong></p><p id="499e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">SonarQube支持多种语言的规则。检查的逻辑总是相同的。不管你用什么——Java，Kotlin，Typescript，或者其他语言。可以重构源代码以获得更好的性能和可读性。</p><p id="e1dc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">链接</strong></p><div class="ly lz gp gr ma mb"><a href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/if.html" rel="noopener  ugc nofollow" target="_blank"><div class="mc ab fo"><div class="md ab me cl cj mf"><h2 class="bd io gy z fp mg fr fs mh fu fw im bi translated">if-then和if-then-else语句</h2><div class="mi l"><h3 class="bd b gy z fp mg fr fs mh fu fw dk translated">if-then语句是所有控制流语句中最基本的。它告诉你的程序执行某个…</h3></div><div class="mj l"><p class="bd b dl z fp mg fr fs mh fu fw dk translated">docs.oracle.com</p></div></div></div></a></div><div class="ly lz gp gr ma mb"><a href="https://stackoverflow.com/questions/52741725/what-is-cognitive-complexity-in-sonar-report" rel="noopener  ugc nofollow" target="_blank"><div class="mc ab fo"><div class="md ab me cl cj mf"><h2 class="bd io gy z fp mg fr fs mh fu fw im bi translated">声纳报告中的认知复杂性是什么？</h2><div class="mi l"><h3 class="bd b gy z fp mg fr fs mh fu fw dk translated">在搜索了一些博客并与声纳团队交谈后，我发现了一个简单的认知定义和计算…</h3></div><div class="mj l"><p class="bd b dl z fp mg fr fs mh fu fw dk translated">stackoverflow.com</p></div></div><div class="mk l"><div class="ml l mm mn mo mk mp ko mb"/></div></div></a></div><div class="ly lz gp gr ma mb"><a href="https://www.sonarsource.com/java/" rel="noopener  ugc nofollow" target="_blank"><div class="mc ab fo"><div class="md ab me cl cj mf"><h2 class="bd io gy z fp mg fr fs mh fu fw im bi translated">Java | SonarSource的代码质量和代码安全性</h2><div class="mi l"><h3 class="bd b gy z fp mg fr fs mh fu fw dk translated">SonarSource提供了可能是你能找到的最好的Java静态代码分析。它使用最先进的…</h3></div><div class="mj l"><p class="bd b dl z fp mg fr fs mh fu fw dk translated">www.sonarsource.com</p></div></div><div class="mk l"><div class="mq l mm mn mo mk mp ko mb"/></div></div></a></div></div></div>    
</body>
</html>