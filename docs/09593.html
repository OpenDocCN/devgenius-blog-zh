<html>
<head>
<title>NodeJS Gateway — Part 2: Setting Up our Database (MongoDB)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">NodeJS 网关—第 2 部分:设置我们的数据库(MongoDB)</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/nodejs-gateway-part-2-setting-up-our-database-mongodb-f947e5746a4b?source=collection_archive---------11-----------------------#2022-08-30">https://blog.devgenius.io/nodejs-gateway-part-2-setting-up-our-database-mongodb-f947e5746a4b?source=collection_archive---------11-----------------------#2022-08-30</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/a3c9efe72e69ae2251be24a8391f1fab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_lp6l_eZVFnUAZVZ8V0_Iw.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated"><a class="ae jz" href="https://unsplash.com/@rubaitulazad?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Rubaitul Azad </a>在<a class="ae jz" href="https://unsplash.com/s/photos/mongodb-and-typescript?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="53cb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">NoSQL 数据库使得用基本模式开始开发你的项目或应用程序变得容易，并且由于一致性可以用这种类型的数据库跳过，随着我们的变量和交互的增加，扩展变得容易，这就是为什么我们使用 MongoDB 作为我们的网关。这也是因为 API 应用程序(参考下面关于我们正在构建的项目的链接)将是保存所有最终事务或交互数据(Postgres)的应用程序。</p><p id="0e9e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果您对我们正在开发的内容感到困惑，请访问下面的链接:</p><div class="ky kz gp gr la lb"><a href="https://medium.com/@nkunzecaleb/how-i-build-a-payment-gateway-using-javascript-2e4f3e52b7cd" rel="noopener follow" target="_blank"><div class="lc ab fo"><div class="ld ab le cl cj lf"><h2 class="bd io gy z fp lg fr fs lh fu fw im bi translated">我如何使用 Javascript 构建支付网关。</h2><div class="li l"><h3 class="bd b gy z fp lg fr fs lh fu fw dk translated">在我的大学/学院学习之后(大约 5 年前)，我渴望建立一个项目，不仅是为了创收…</h3></div><div class="lj l"><p class="bd b dl z fp lg fr fs lh fu fw dk translated">medium.com</p></div></div><div class="lk l"><div class="ll l lm ln lo lk lp jt lb"/></div></div></a></div><p id="af01" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在前一篇文章(第 1 部分)中，我们能够将<code class="fe lq lr ls lt b">mongodb</code>和 mongose<code class="fe lq lr ls lt b">npm</code>模块添加到网关中。在这篇文章中，我们将专注于创建集合的模式，保存、检索、更新和删除数据库集合中的数据。</p><p id="6094" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果您想知道什么是集合，您可以将它们与 SQL 数据库中的表或关系相关联。因为 NoSQL 数据库是由类似 JSON 文档类型的数据库组成的非表格数据库，而 MongoDB 是其中的一部分。因此，记录(在 SQL 数据库中)或条目是 NoSQL 中的文档，集合是一组文档(记录)。我希望这不会引起混淆。你可以在这里查看更广泛的解释<a class="ae jz" href="https://www.mongodb.com/nosql-explained" rel="noopener ugc nofollow" target="_blank"> NoSQL 解释</a>、<a class="ae jz" href="https://www.techtarget.com/searchdatamanagement/definition/NoSQL-Not-Only-SQL" rel="noopener ugc nofollow" target="_blank"> TechTarget </a>和<a class="ae jz" href="https://www.couchbase.com/resources/why-nosql" rel="noopener ugc nofollow" target="_blank"> NoSQL 数据库</a>。</p><p id="cff9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们将看到为一个基本的演示内部(app)传输事务插入数据，该事务具有<code class="fe lq lr ls lt b">transaction_id</code> <code class="fe lq lr ls lt b">transaction_type</code> <code class="fe lq lr ls lt b">sender_account_id</code> <code class="fe lq lr ls lt b">recipient_account_id</code> <code class="fe lq lr ls lt b">amount</code> <code class="fe lq lr ls lt b">currency</code> <code class="fe lq lr ls lt b">transaction_note</code>然后是<code class="fe lq lr ls lt b">date_time</code>。</p><p id="82c9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">首先，我们将从创建一个模式开始，简单地说，这个模式就是要保存在数据库中的数据的格式。让我们继续为我们的事务数据创建一个模型文件<code class="fe lq lr ls lt b">transactionModel.ts</code>,并添加以下代码。</p><figure class="lu lv lw lx gt jo"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="f4c5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">从代码中，我们看到除了可选的交易记录之外，所有的输入都是必需的。在定义了模式<code class="fe lq lr ls lt b">transactionSchema</code>之后，我们在第 13 行创建了<code class="fe lq lr ls lt b">transactionModel</code>，它将用于搜索、保存和检索交易相关数据。请记住，这是基本的，我们将继续添加更多的值或变量。</p><p id="5b12" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们继续测试我们的模型，看看我们是否可以从数据库中保存和检索数据。为此，我们将创建 3 个路由来保存和检索我们的事务数据。</p><ul class=""><li id="d21f" class="ma mb in kc b kd ke kh ki kl mc kp md kt me kx mf mg mh mi bi translated"><code class="fe lq lr ls lt b">POST /api/transaction</code>创建交易</li><li id="7fd8" class="ma mb in kc b kd mj kh mk kl ml kp mm kt mn kx mf mg mh mi bi translated"><code class="fe lq lr ls lt b">GET /api/transaction/:id</code>获取单笔交易的交易数据</li><li id="f469" class="ma mb in kc b kd mj kh mk kl ml kp mm kt mn kx mf mg mh mi bi translated"><code class="fe lq lr ls lt b">GET /api/transactions</code>获取所有交易</li></ul><p id="04f7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这部分更多的是关于数据库，所以我们不会深入到路线。现在，我们可以用基本的路由来测试我们的模式。为此，我们将添加一个<code class="fe lq lr ls lt b">body-parser</code>模块，它将帮助我们制作一个中间件，将我们的请求数据转换为 JSON 格式进行存储。使用下面的命令。</p><pre class="lu lv lw lx gt mo lt mp mq aw mr bi"><span id="0ede" class="ms mt in lt b gy mu mv l mw mx">npm install body-parser --save</span></pre><p id="a4b9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在我们可以将下面的代码添加到我们的<code class="fe lq lr ls lt b">app.ts</code>文件中</p><pre class="lu lv lw lx gt mo lt mp mq aw mr bi"><span id="1d86" class="ms mt in lt b gy mu mv l mw mx">const bodyParser = require('body-parser');</span><span id="a8ef" class="ms mt in lt b gy my mv l mw mx">app.use(bodyParser.json());<br/>app.use(bodyParser.urlencoded({ extended: true }));</span></pre><p id="9aac" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所以我们有看起来像这样的<code class="fe lq lr ls lt b">app.ts</code></p><figure class="lu lv lw lx gt jo"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="78f0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后我们在 routes 文件夹中创建一个<code class="fe lq lr ls lt b">transactions</code>路由文件<code class="fe lq lr ls lt b">transactions.ts</code>。最后，我们将下面的代码添加到它:</p><figure class="lu lv lw lx gt jo"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="8d6f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您可以运行<code class="fe lq lr ls lt b">npm run start</code>来构建并启动我们的服务器。</p><p id="a880" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">从上面的代码中，保存通过对收到的请求体数据调用<code class="fe lq lr ls lt b">mongoose start()</code>函数而创建的事务，并且当保存过程成功或失败时，这将向客户端发送回一个响应。请看下面来自《邮差》的截图。</p><figure class="lu lv lw lx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mz"><img src="../Images/371920d6a20e1390cb23f71a388071f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FSv_bbkyQwcgKLVsv0lU4A.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">保存交易明细的过帐请求(成功)</figcaption></figure><p id="0112" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了获得一个事务，我们在 route 中传递了<code class="fe lq lr ls lt b">id</code>参数，该参数用于搜索类似于在事务创建期间生成的<code class="fe lq lr ls lt b">transactionId</code>的事务。请看下面来自《邮差》的截图。</p><figure class="lu lv lw lx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mz"><img src="../Images/2238c8f6af7de6b4a4b967f01ad8c960.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YJ735zCcD_B801obC_-XjA.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">检索单个事务的 GET 请求(成功)</figcaption></figure><p id="0e9f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后，我们还可以通过在 mongoose 的<code class="fe lq lr ls lt b">find()</code>函数中不传递任何参数来查询所有要返回的事务。请看下面来自《邮差》的截图。</p><figure class="lu lv lw lx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mz"><img src="../Images/892558c9f0dfa216b4883976df3021a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dvzE14KL5MfN_VvS1r3OZg.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">检索所有事务的 GET 请求(成功)</figcaption></figure><p id="5922" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在 postman 中，失败的操作将如下所示。</p><figure class="lu lv lw lx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mz"><img src="../Images/c8600965c62cc1e7bf5329da68e0aab8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jy1Gp57JvnYueS7C6Z352Q.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">检索单个事务的 GET 请求失败。</figcaption></figure><p id="1781" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这一路走来做得很好，我们已经看到了我们将如何与我们的数据库交互，在其他部分，我们将看到从数据库中修改和删除我们的数据。</p><p id="bf77" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我想再次感谢你完成这篇文章，你可以鼓掌，甚至跟随我看更多这样的文章，因为我穿越了我创建支付网关的旅程。请随时纠正我的错误。学习是要走的路。</p><p id="b8ac" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">接下来，我们将着眼于路由、中间件，希望还有控制器。我试着让这些尽可能短，以避免一口气有一个完整的教科书🤩。</p><p id="85dc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果你想看到完成的代码(到目前为止)，你可以使用下面的链接从 repo 获得。</p><div class="ky kz gp gr la lb"><a href="https://github.com/Cank256/payie" rel="noopener  ugc nofollow" target="_blank"><div class="lc ab fo"><div class="ld ab le cl cj lf"><h2 class="bd io gy z fp lg fr fs lh fu fw im bi translated">GitHub - Cank256/payie:支付解决方案项目</h2><div class="li l"><h3 class="bd b gy z fp lg fr fs lh fu fw dk translated">支付解决方案项目。在 GitHub 上创建一个帐户，为 Cank256/payie 开发做贡献。</h3></div><div class="lj l"><p class="bd b dl z fp lg fr fs lh fu fw dk translated">github.com</p></div></div><div class="lk l"><div class="na l lm ln lo lk lp jt lb"/></div></div></a></div><p id="dcd1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">直到下一个帖子😎。</p></div></div>    
</body>
</html>