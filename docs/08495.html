<html>
<head>
<title>Java Virtual Threads</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java 虚拟线程</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/java-virtual-threads-715c162c6c39?source=collection_archive---------3-----------------------#2022-06-19">https://blog.devgenius.io/java-virtual-threads-715c162c6c39?source=collection_archive---------3-----------------------#2022-06-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ea09" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">我们将不再编写丑陋的异步代码。也许吧。</h2></div><p id="deb9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae lb" href="https://github.com/openjdk/jdk19" rel="noopener ugc nofollow" target="_blank"> JDK 19 </a>已经在前一周分叉，虚拟线程 API(最初由<a class="ae lb" href="https://wiki.openjdk.org/display/loom/Main" rel="noopener ugc nofollow" target="_blank">项目 Loom </a>引入)是一个部分实现的特性，将成为下一个版本的一部分。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi lc"><img src="../Images/c6a9fb54854a80408f5020a2636e65ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kPm95Qhzc4XYasoJ"/></div></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk translated">约翰·安维克在<a class="ae lb" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><blockquote class="ls lt lu"><p id="35d7" class="kf kg lv kh b ki kj jr kk kl km ju kn lw kp kq kr lx kt ku kv ly kx ky kz la ij bi translated">在所有重要的方面，虚拟线程的性能类似于平台线程，但足够便宜，你可以拥有数百万个以上的线程。这为您提供了异步编程模型的可伸缩性和同步代码的简单性。<a class="ae lb" href="https://www.youtube.com/watch?v=UG9nViGZCEw" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=UG9nViGZCEw</a></p></blockquote><ul class=""><li id="69ab" class="lz ma iq kh b ki kj kl km ko mb ks mc kw md la me mf mg mh bi translated">一个标准的<strong class="kh ir"> Java 平台线程</strong>是一个<strong class="kh ir">操作系统线程上的一个薄薄的包装器，它与它的生命周期严格相关。</strong>平台线程的数量因此受限于操作系统线程的数量。</li><li id="be09" class="lz ma iq kh b ki mi kl mj ko mk ks ml kw mm la me mf mg mh bi translated">一个<strong class="kh ir">虚拟线程不附属于任何特定的操作系统线程，一旦被 JDK 识别为阻塞(例如，当它正在运行 I/O 操作时),就会自动从其底层操作系统线程</strong>分离。虚拟线程的数量可以远大于操作系统线程的数量。</li></ul><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi mn"><img src="../Images/3e33ea1de1dff9d56f56803e1e2dec3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CNvDz--5yOvEXbLVQhQxLQ.png"/></div></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk translated">虚拟线程与平台线程</figcaption></figure><p id="218e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">虚拟线程只有在 CPU 上执行计算时才会消耗 OS 线程。</strong>许多虚拟线程可以依赖同一个操作系统线程，有效地共享它。我们获得的结果是与异步风格编程时相同的可伸缩性，只是这是透明地实现的。<em class="lv">预期结果(理论上)是，有了虚拟线程，我们将不再需要使用异步代码或基于事件的模式来“将应用的吞吐量限制在与底层硬件所能支持的同等水平”，因为这将由 JDK 透明地完成。换句话说，没有更难听的</em> <a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/an-epic-tale-comparing-jdbc-and-r2dbc-in-a-real-world-scenario-a536db512834"> <em class="lv">无功编程</em> </a> <em class="lv">废话。</em></p><p id="93f9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了实现这种从 OS 线程(称为载体线程)的解耦和快速安装-卸载，虚拟线程被实现为廉价的。事实上，它们太便宜了，不应该像我们在标准 Java 多线程应用程序中通常做的那样，将它们放在一起。虽然平台线程需要将其整个堆栈存储在内存中，预先预留大约 20MBs，但虚拟线程存储在垃圾收集堆中，该堆可以根据需要增长和收缩，以容纳任意深度的堆栈。这个深度将比一个标准平台线程的完整调用堆栈更容易被占用，因为我们将使用虚拟线程来执行短期任务。</p><h1 id="7fd2" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">JDK 螺纹 API 的主要变化</h1><p id="9cbf" class="pw-post-body-paragraph kf kg iq kh b ki ng jr kk kl nh ju kn ko ni kq kr ks nj ku kv kw nk ky kz la ij bi translated">JDK19 将出货<code class="fe nl nm nn no b"><strong class="kh ir">Executors.newVirtualThreadPerTaskExecutor()</strong></code></p><pre class="ld le lf lg gt np no nq nr aw ns bi"><span id="239f" class="nt mp iq no b gy nu nv l nw nx">try (var executor = <strong class="no ir">Executors.newVirtualThreadPerTaskExecutor()</strong>) {<br/>    IntStream.range(0, 10_000).forEach(i -&gt; {<br/>        executor.submit(() -&gt; {<br/>            Thread.sleep(Duration.ofSeconds(1));<br/>            return i;<br/>        });<br/>    });<br/>}  // executor.close() is called implicitly, and waits</span></pre><p id="fe06" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">和<code class="fe nl nm nn no b"><strong class="kh ir">Thread.startVirtualThread(Runnable)</strong></code>方法。</p><pre class="ld le lf lg gt np no nq nr aw ns bi"><span id="02f0" class="nt mp iq no b gy nu nv l nw nx">var vThread = Thread.startVirtualThread(() -&gt; {<br/>    System.out.println("Hello from the virtual thread");         <br/>});</span></pre><h1 id="e809" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">还缺少什么</h1><p id="c4fa" class="pw-post-body-paragraph kf kg iq kh b ki ng jr kk kl nh ju kn ko ni kq kr ks nj ku kv kw nk ky kz la ij bi translated">绝大多数开发人员并不直接使用线程。我们 90%依赖于实现“每个请求一个线程”模型的 web 服务器。线程是由 web 服务器自动为我们创建的。</p><p id="7bfe" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这就是为什么<a class="ae lb" href="https://openjdk.org/jeps/425" rel="noopener ugc nofollow" target="_blank"> JEP 425 </a>的第一个基本目标是“<strong class="kh ir">使以简单的每请求线程风格编写的服务器应用程序能够以接近最优的硬件利用率进行扩展”</strong>，第二个目标是“使使用 <code class="fe nl nm nn no b"><strong class="kh ir">java.lang.Thread</strong></code> <strong class="kh ir"> API 的现有代码能够以最小的改变采用虚拟线程”。</strong></p><p id="6098" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">听起来不错，但行不通。</p><p id="68de" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">虚拟线程当前的一个巨大限制是，使用同步代码块会导致锁定操作系统线程。</strong>钉住一个线程意味着承载线程很忙，在监视器被释放之前不能用于其他虚拟线程。长时间频繁固定会损害应用程序的可伸缩性。即使 JEP 声明“不需要替换不经常使用的<code class="fe nl nm nn no b">synchronized</code>块和方法(例如，只在启动时执行)或者保护内存操作的方法”，我们也应该尽可能地使用<a class="ae lb" href="https://docs.oracle.com/en/java/javase/18/docs/api/java.base/java/util/concurrent/locks/ReentrantLock.html" rel="noopener ugc nofollow" target="_blank"> ReentrantLock </a>。</p><p id="8881" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个<a class="ae lb" href="https://github.com/mp911de/spring-boot-virtual-threads-experiment" rel="noopener ugc nofollow" target="_blank">实验</a>的目的是在 Tomcat 中使用虚拟线程，它总结了<code class="fe nl nm nn no b">synchronized</code>在包含的库中使用的次数。</p><ul class=""><li id="bbe9" class="lz ma iq kh b ki kj kl km ko mb ks mc kw md la me mf mg mh bi translated">光:12 人</li><li id="a3ad" class="lz ma iq kh b ki mi kl mj ko mk ks ml kw mm la me mf mg mh bi translated">Tomcat(嵌入式内核):576</li><li id="c5af" class="lz ma iq kh b ki mi kl mj ko mk ks ml kw mm la me mf mg mh bi translated">PGJDBC: 134</li><li id="eacf" class="lz ma iq kh b ki mi kl mj ko mk ks ml kw mm la me mf mg mh bi translated">春季数据:13</li><li id="c64a" class="lz ma iq kh b ki mi kl mj ko mk ks ml kw mm la me mf mg mh bi translated">弹簧框架:329</li></ul><h1 id="f731" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">结论</h1><p id="0ec0" class="pw-post-body-paragraph kf kg iq kh b ki ng jr kk kl nh ju kn ko ni kq kr ks nj ku kv kw nk ky kz la ij bi translated">依我拙见，OS Java 社区已经带来了一个已经实现的伟大特性，并且<strong class="kh ir"> </strong>在其他多线程语言(比如 Go 或 Erlang)中取得了巨大成功。</p><p id="11c0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同步限制是即将到来的 JDK 版本应该真正解决的问题。如果 JDK 不能直接解决这一限制，我们将不会从虚拟线程的使用中获得很大的好处，因为与遗留代码的集成将带来大量“同步”的代码块。</p></div></div>    
</body>
</html>