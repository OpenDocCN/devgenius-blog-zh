<html>
<head>
<title>Regex Text Validator in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift 中的正则表达式文本验证器</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/regex-text-validator-in-swift-43864103feca?source=collection_archive---------4-----------------------#2022-01-26">https://blog.devgenius.io/regex-text-validator-in-swift-43864103feca?source=collection_archive---------4-----------------------#2022-01-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="76c8" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在 Swift 中为您的项目创建一个可重用的正则表达式文本验证器管理器</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/8197b16988a90fb7c443de7813b1be1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n90o-Vx_YMuHJ7VGmNGokA.jpeg"/></div></div></figure><p id="05ec" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">几乎每个大中型应用程序都需要用户提供一些信息。通常，提供它们最直接的方式是通过任何类型的输入文本字段。但是我们如何保证用户输入的文本是正确的呢？也许我们用数字的形式询问用户的年龄，而他/她用一个简单的字符串发来了年龄信息……或者用户输入了完全错误的信息，比如“🥳”🤗👌".在这种情况下，我们需要验证我们的测试。</p><p id="023e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">验证用户输入最常见的方式是使用一个<strong class="kt ir">正则表达式</strong>，也称为 regex。</p></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><p id="5338" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们从维基百科的一些定义开始:</p><blockquote class="lu lv lw"><p id="8023" class="kr ks lx kt b ku kv jr kw kx ky ju kz ly lb lc ld lz lf lg lh ma lj lk ll lm ij bi translated">一个<strong class="kt ir">正则表达式</strong>(简称为<strong class="kt ir"> regex </strong>或<strong class="kt ir">regexp</strong>；也称为<strong class="kt ir">有理表达式</strong>是一系列<a class="ae mb" href="https://en.wikipedia.org/wiki/Character_(computing)" rel="noopener ugc nofollow" target="_blank">字符</a>，指定了<a class="ae mb" href="https://en.wikipedia.org/wiki/String_(computer_science)" rel="noopener ugc nofollow" target="_blank">文本</a>中的<a class="ae mb" href="https://en.wikipedia.org/wiki/Pattern_matching" rel="noopener ugc nofollow" target="_blank"> <em class="iq">搜索模式</em> </a>。通常这样的模式被<a class="ae mb" href="https://en.wikipedia.org/wiki/String-searching_algorithm" rel="noopener ugc nofollow" target="_blank">字符串搜索算法</a>用于对<a class="ae mb" href="https://en.wikipedia.org/wiki/String_(computer_science)" rel="noopener ugc nofollow" target="_blank">字符串</a>的“查找”或“查找和替换”操作，或者用于输入验证。它是在<a class="ae mb" href="https://en.wikipedia.org/wiki/Theoretical_computer_science" rel="noopener ugc nofollow" target="_blank">理论计算机科学</a>和<a class="ae mb" href="https://en.wikipedia.org/wiki/Formal_language" rel="noopener ugc nofollow" target="_blank">形式语言</a>理论中发展起来的技术。</p></blockquote><p id="8a70" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">基本上，它是一个字符串，有自己的规则提供给函数，用来分析输入文本并检查它是否与 regex 本身的规则相匹配。</p><p id="213b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你想学习如何创建一个正则表达式，看一看我最近的一篇文章，在那里我向你展示了一个非常方便的在线工具。</p><p id="5199" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">该框架附带了一系列处理正则表达式的方法，因此验证文本非常容易。只需 3 个步骤即可完成:</p><ul class=""><li id="aa00" class="mg mh iq kt b ku kv kx ky la mi le mj li mk lm ml mm mn mo bi translated">用您想要应用的正则表达式模式创建一个<code class="fe mc md me mf b">NSRegularExpression</code>对象。</li><li id="ab9f" class="mg mh iq kt b ku mp kx mq la mr le ms li mt lm ml mm mn mo bi translated">用你想要验证的字符串文本创建一个<code class="fe mc md me mf b">NSRange</code>……你甚至可以只验证你输入文本的一部分，也就是范围。</li><li id="eec4" class="mg mh iq kt b ku mp kx mq la mr le ms li mt lm ml mm mn mo bi translated">如果文本中有一个<code class="fe mc md me mf b">firstMatch</code>，则使用正则表达式结果验证文本。</li></ul><p id="57cf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">超级简单！</p><p id="0081" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">第一个简单的解决方案是为测试创建一个函数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="b76f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个功能可以用…但是有点笨拙。为了验证一个文本，我们需要以类似的方式调用它:</p><pre class="kg kh ki kj gt mw mf mx my aw mz bi"><span id="6d4a" class="na nb iq mf b gy nc nd l ne nf"><strong class="mf ir">let</strong> isValid = validate(text: “UserName”, with: #”^[A-Za-z]+$”#)</span></pre><p id="05af" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">请注意，我使用了<code class="fe mc md me mf b">#"text here"#</code>字符串文字符号。有了正则表达式，避免写转义字符就变得非常方便了。</p><p id="8a6d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在我们的项目中反复调用前面的函数不是很干净。我们可以做一些改进。</p><p id="dcba" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我首先想到的是把功能改造成一个<code class="fe mc md me mf b">String Extension</code>。这很明显，因为我们需要验证的所有文本都是一个字符串。让我们现在就开始吧:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="c3fe" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">嗯，现在情况好多了。现在让我们来看看我们的调用函数:</p><pre class="kg kh ki kj gt mw mf mx my aw mz bi"><span id="fb41" class="na nb iq mf b gy nc nd l ne nf"><strong class="mf ir">let</strong> isValid = “UserName”.isValidWith(regex: #”^[A-Za-z]+$”#)</span></pre><p id="2d72" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">哇！更加清晰，可读性更强！</p><p id="5567" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">非常好。这可能足够了，但我们仍有改进的空间。这个解决方案很好，但是我认为这里有两个问题。</p><p id="37d7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你正在做一个大项目，你将需要在不同的部分反复执行相同的验证。如果每次需要时都编写正则表达式模式，最终会出现问题和所谓的技术债务。如果你在你的应用的七个点中验证一个用户名，而业务部门决定改变验证规则，该怎么办？也许现在允许空格？我向你保证，你不会改变所有七个地方的正则表达式，你会发现一个错误…可能在一个月后的产品中被发现。可怕的事情！</p><p id="db52" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">第二个问题是可读性…你能告诉我这个正则表达式是干什么用的吗？</p><pre class="kg kh ki kj gt mw mf mx my aw mz bi"><span id="1aa0" class="na nb iq mf b gy nc nd l ne nf"><strong class="mf ir">let</strong> isValid = “Username”.isValidWith(regex: #”^(?:[A-Z][AEIOU][AEIOUX]|[B-DF-HJ-NP-TV-Z]{2}[A-Z]){2}(?:[\dLMNP-V]{2}(?:[A-EHLMPR-T](?:[04LQ][1–9MNP-V]|[15MR][\dLMNP-V]|[26NS][0–8LMNP-U])|[DHPS][37PT][0L]|[ACELMRT][37PT][01LM]|[AC-EHLMPR-T][26NS][9V])|(?:[02468LNQSU][048LQU]|[13579MPRTV][26NS])B[26NS][9V])(?:[A-MZ][1–9MNP-V][\dLMNP-V]{2}|[A-M][0L](?:[1–9MNP-V][\dLMNP-V]|[0L][1–9MNP-V]))[A-Z]$”#)</span></pre><p id="4172" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果答案是肯定的…那么，你不需要这篇文章，我很抱歉地说，你已经浪费了你生命中的三分钟😁…不要再读了😉。</p><p id="3377" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">幸运的是 Swift 给了我们一个非常干净的解决方案…我们可以使用<code class="fe mc md me mf b">enum</code>案例！</p><p id="5346" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们在<code class="fe mc md me mf b">String Extension</code>内部构建一个完整的管理器:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="ad53" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如您所见，我已经创建了一些示例来展示这种方法。我们一行一行的分析吧。</p><ul class=""><li id="c2e9" class="mg mh iq kt b ku kv kx ky la mi le mj li mk lm ml mm mn mo bi translated">第 4 行:我在<code class="fe mc md me mf b">Foundation String</code>中创建了一个嵌套类型。看一看<a class="ae mb" href="https://medium.com/@alessandromanilii/nested-object-in-swift-4cda290bfa18" rel="noopener">这篇文章</a>中的这个技巧。</li><li id="711b" class="mg mh iq kt b ku mp kx mq la mr le ms li mt lm ml mm mn mo bi translated">第 5 行:我创建了一个<code class="fe mc md me mf b">none</code>规则……以防万一，你永远不会知道。</li><li id="e297" class="mg mh iq kt b ku mp kx mq la mr le ms li mt lm ml mm mn mo bi translated">第 8–9 行:为了给规则更多的灵活性，我在枚举中使用了一个<code class="fe mc md me mf b">associated value</code>。在应用程序中，文本输入有不同的字符串限制是很常见的。有了这个小变量，我们就万事俱备了。</li><li id="7447" class="mg mh iq kt b ku mp kx mq la mr le ms li mt lm ml mm mn mo bi translated">第 14 行:这里我创建了一个返回正则表达式代码的<code class="fe mc md me mf b">private var pattern: String</code>。将它包装在一个<code class="fe mc md me mf b">enum</code>中使得一切都非常可读。</li><li id="c924" class="mg mh iq kt b ku mp kx mq la mr le ms li mt lm ml mm mn mo bi translated">第 40 行:我们之前的函数做了一点修改(见第 43 行)。</li></ul><p id="cc86" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">请记住在枚举的每种情况下添加小的注释，以便澄清一切。编写干净的代码通常是我们的主要目标。</p><p id="4df0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在让我们看看我们的代码可读性如何:</p><pre class="kg kh ki kj gt mw mf mx my aw mz bi"><span id="3c7b" class="na nb iq mf b gy nc nd l ne nf"><strong class="mf ir">let</strong> isValid = “Username”.isValidWith(regexType: .minLetters(8))<br/><strong class="mf ir">let</strong> isValid = "appleseed@apple.com".isValidWith(regexType: .email)</span></pre><p id="897f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">不仅如此，现在正则表达式的所有模式都在代码的一个地方。都在一起，写一次。多神奇啊！</p><p id="6680" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果需要额外的正则表达式，只需在枚举中添加一个 case 即可。超级容易，超级快！</p></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><p id="7db5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我希望你喜欢这篇文章，如果你喜欢，请鼓掌。<br/>如果这篇文章对你有用，请随意<a class="ae mb" href="https://www.buymeacoffee.com/dy59tqxn794" rel="noopener ugc nofollow" target="_blank">给我一杯咖啡</a>，并允许我创造更多酷的内容和文章。</p><p id="d267" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">享受你的编码！</p></div></div>    
</body>
</html>