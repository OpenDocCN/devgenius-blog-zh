<html>
<head>
<title>Leetcode Contest 297</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Leetcode 竞赛 297</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/leetcode-contest-297-75150be135ed?source=collection_archive---------9-----------------------#2022-06-12">https://blog.devgenius.io/leetcode-contest-297-75150be135ed?source=collection_archive---------9-----------------------#2022-06-12</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/aba3d10f65ecda73fb60cb0fb0b293c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qOtTFUPIRHImlEmyY00oDg.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">照片由<a class="ae jz" href="https://unsplash.com/@afgprogrammer?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">穆罕默德·拉赫马尼</a>在<a class="ae jz" href="https://unsplash.com/s/photos/coding-competition?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="d959" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">问题 1</h1><h2 id="75e0" class="ky kb in bd kc kz la dn kg lb lc dp kk ld le lf ko lg lh li ks lj lk ll kw lm bi translated"><a class="ae jz" href="https://leetcode.com/contest/weekly-contest-297/problems/calculate-amount-paid-in-taxes/" rel="noopener ugc nofollow" target="_blank">计算已缴税款</a></h2><blockquote class="ln lo lp"><p id="1ded" class="lq lr ls lt b lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo ig bi translated">给你一个<strong class="lt io"> 0 索引的</strong> 2D 整数数组<code class="fe mp mq mr ms b">brackets</code>，其中<code class="fe mp mq mr ms b">brackets[i] = [upperi, percenti]</code>表示<code class="fe mp mq mr ms b">ith</code>税级的上限为<code class="fe mp mq mr ms b">upperi</code>，税率为<code class="fe mp mq mr ms b">percenti</code>。括号按上限排序<strong class="lt io">(即<code class="fe mp mq mr ms b">upperi-1 &lt; upperi</code>代表<code class="fe mp mq mr ms b">0 &lt; i &lt; brackets.length</code>)。</strong></p><p id="ea17" class="lq lr ls lt b lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo ig bi translated">税款计算如下:</p><p id="300d" class="lq lr ls lt b lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo ig bi translated">赚取的第一笔<code class="fe mp mq mr ms b">upper0</code>美元按<code class="fe mp mq mr ms b">percent0</code>的税率征税。</p><p id="a3d7" class="lq lr ls lt b lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo ig bi translated">接下来赚的<code class="fe mp mq mr ms b">upper1 - upper0</code>美元按<code class="fe mp mq mr ms b">percent1</code>的税率征税。</p><p id="5bf2" class="lq lr ls lt b lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo ig bi translated">接下来赚的<code class="fe mp mq mr ms b">upper2 - upper1</code>美元按<code class="fe mp mq mr ms b">percent2</code>的税率征税。</p><p id="0a66" class="lq lr ls lt b lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo ig bi translated">诸如此类。</p><p id="d946" class="lq lr ls lt b lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo ig bi translated">给你一个整数<code class="fe mp mq mr ms b">income</code>,代表你赚了多少钱。申报你必须缴税的金额。实际答案的<code class="fe mp mq mr ms b">10-5</code>范围内的答案将被接受。</p></blockquote><h2 id="5f5c" class="ky kb in bd kc kz la dn kg lb lc dp kk ld le lf ko lg lh li ks lj lk ll kw lm bi translated">方法</h2><p id="4349" class="pw-post-body-paragraph lq lr in lt b lu mt lw lx ly mu ma mb ld mv me mf lg mw mi mj lj mx mm mn mo ig bi translated">我们循环通过<strong class="lt io">括号</strong>，直到括号中提供的收入上限超过我们的收入。我们跟踪以前的收入界限来计算税收等级，当收入上限超过收入时，我们使用最大等级来计算税收和回报。</p><h2 id="7fe4" class="ky kb in bd kc kz la dn kg lb lc dp kk ld le lf ko lg lh li ks lj lk ll kw lm bi translated">解决办法</h2><div class="my mz gp gr na nb"><a href="https://github.com/bumblebee211196/lc_contests/blob/main/contest_297/python/problem1.py" rel="noopener  ugc nofollow" target="_blank"><div class="nc ab fo"><div class="nd ab ne cl cj nf"><h2 class="bd io gy z fp ng fr fs nh fu fw im bi translated">LC _ contracts/problem 1 . py 在主大黄蜂 211196/LC _ contracts</h2><div class="ni l"><h3 class="bd b gy z fp ng fr fs nh fu fw dk translated">此文件包含双向 Unicode 文本，其解释或编译可能与下面显示的不同…</h3></div><div class="nj l"><p class="bd b dl z fp ng fr fs nh fu fw dk translated">github.com</p></div></div><div class="nk l"><div class="nl l nm nn no nk np jt nb"/></div></div></a></div><blockquote class="ln lo lp"><p id="5676" class="lq lr ls lt b lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo ig bi translated">时间复杂度:O(n)</p><p id="d24c" class="lq lr ls lt b lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo ig bi translated">空间复杂度:O(1)</p></blockquote><h1 id="d3fe" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">问题 2</h1><h2 id="8775" class="ky kb in bd kc kz la dn kg lb lc dp kk ld le lf ko lg lh li ks lj lk ll kw lm bi translated"><a class="ae jz" href="https://leetcode.com/contest/weekly-contest-297/problems/minimum-path-cost-in-a-grid/" rel="noopener ugc nofollow" target="_blank">网格中的最小路径成本</a></h2><blockquote class="ln lo lp"><p id="ee73" class="lq lr ls lt b lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo ig bi translated">给你一个由从<code class="fe mp mq mr ms b">0</code>到<code class="fe mp mq mr ms b">m * n - 1</code>的<strong class="lt io">个不同的</strong>个整数组成的<strong class="lt io"> 0 索引的</strong> <code class="fe mp mq mr ms b">m x n</code>个整数矩阵<code class="fe mp mq mr ms b">grid</code>。你可以在这个矩阵中从一个单元格移动到下一个行的<strong class="lt io">中的任何其他单元格。也就是说，如果您在单元格<code class="fe mp mq mr ms b">(x, y)</code>中，那么<code class="fe mp mq mr ms b">x &lt; m - 1</code>，您可以移动到单元格<code class="fe mp mq mr ms b">(x + 1, 0)</code>、<code class="fe mp mq mr ms b">(x + 1, 1)</code>、...，<code class="fe mp mq mr ms b">(x + 1, n - 1)</code>。<strong class="lt io">注意</strong>不能从最后一行的单元格移动。</strong></p><p id="ba73" class="lq lr ls lt b lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo ig bi translated">每个可能的移动都有一个由大小为<code class="fe mp mq mr ms b">(m * n) x n</code>的<strong class="lt io"> 0 索引的</strong> 2D 数组<code class="fe mp mq mr ms b">moveCost</code>给出的代价，其中<code class="fe mp mq mr ms b">moveCost[i][j]</code>是从具有值<code class="fe mp mq mr ms b">i</code>的单元格移动到下一行的列<code class="fe mp mq mr ms b">j</code>中的单元格的代价。从最后一行<code class="fe mp mq mr ms b">grid</code>的单元格开始移动的代价可以忽略。</p><p id="e50e" class="lq lr ls lt b lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo ig bi translated"><code class="fe mp mq mr ms b">grid</code>中一条路径的成本是所有被访问的单元格值的<strong class="lt io">总和</strong>加上所有移动的<strong class="lt io">总和</strong>。返回从第 <strong class="lt io"> <em class="in">行第一个</em> </strong> <em class="in">行的任意单元格开始，到最后一个</em>  <em class="in">行的任意单元格结束的路径的<em class="in"/><strong class="lt io"><em class="in">最小</em> </strong> <em class="in">成本。</em></em></p></blockquote><h2 id="a27c" class="ky kb in bd kc kz la dn kg lb lc dp kk ld le lf ko lg lh li ks lj lk ll kw lm bi translated">方法</h2><p id="88db" class="pw-post-body-paragraph lq lr in lt b lu mt lw lx ly mu ma mb ld mv me mf lg mw mi mj lj mx mm mn mo ig bi translated">假设只有一行，那么结果会很简单，选择网格中的最小值。</p><p id="ffe5" class="pw-post-body-paragraph lq lr in lt b lu lv lw lx ly lz ma mb ld md me mf lg mh mi mj lj ml mm mn mo ig bi translated">如果输入有两行，那么对于第二行中的每个值，我们将找到从第一行中的任何单元格到达的最小成本。最终结果将是第二行中每个单元的成本中的最小值。</p><p id="6f6c" class="pw-post-body-paragraph lq lr in lt b lu lv lw lx ly lz ma mb ld md me mf lg mh mi mj lj ml mm mn mo ig bi translated">对于网格中的任何单元，我们计算到达它的最小成本。我们对网格中除第一行之外的每个单元格重复这一过程。为了避免重新计算，我们维护了一个 2D 网格来缓存我们的结果。2D 网格最后一行中的最小值将是我们的结果。</p><h2 id="4dea" class="ky kb in bd kc kz la dn kg lb lc dp kk ld le lf ko lg lh li ks lj lk ll kw lm bi translated">解决办法</h2><div class="my mz gp gr na nb"><a href="https://github.com/bumblebee211196/lc_contests/blob/main/contest_297/python/problem2.py" rel="noopener  ugc nofollow" target="_blank"><div class="nc ab fo"><div class="nd ab ne cl cj nf"><h2 class="bd io gy z fp ng fr fs nh fu fw im bi translated">LC _ contracts/problem 2 . py 在主大黄蜂 211196/LC _ contracts</h2><div class="ni l"><h3 class="bd b gy z fp ng fr fs nh fu fw dk translated">此文件包含双向 Unicode 文本，其解释或编译可能与下面显示的不同…</h3></div><div class="nj l"><p class="bd b dl z fp ng fr fs nh fu fw dk translated">github.com</p></div></div><div class="nk l"><div class="nq l nm nn no nk np jt nb"/></div></div></a></div><blockquote class="ln lo lp"><p id="2283" class="lq lr ls lt b lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo ig bi translated">时间复杂度:O(m * n)</p><p id="b775" class="lq lr ls lt b lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo ig bi translated">空间复杂度:O(m * n)</p></blockquote><h1 id="ff2e" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">问题 3</h1><h2 id="290c" class="ky kb in bd kc kz la dn kg lb lc dp kk ld le lf ko lg lh li ks lj lk ll kw lm bi translated"><a class="ae jz" href="https://leetcode.com/contest/weekly-contest-297/problems/fair-distribution-of-cookies/" rel="noopener ugc nofollow" target="_blank">公平分配饼干</a></h2><blockquote class="ln lo lp"><p id="58ea" class="lq lr ls lt b lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo ig bi translated">给你一个整数数组<code class="fe mp mq mr ms b">cookies</code>，其中<code class="fe mp mq mr ms b">cookies[i]</code>表示<code class="fe mp mq mr ms b">ith</code>包中的饼干数量。你还会得到一个整数<code class="fe mp mq mr ms b">k</code>,表示将所有的饼干袋分配给<strong class="lt io">多少个孩子。同一个袋子里的所有饼干必须给同一个孩子，不能分开。</strong></p><p id="4f22" class="lq lr ls lt b lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo ig bi translated">分配的<strong class="lt io">不公平性</strong>定义为分配中单个孩子获得的<strong class="lt io">最大</strong> <strong class="lt io">总</strong>饼干。</p><p id="a967" class="lq lr ls lt b lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo ig bi translated">返回<em class="in"/><strong class="lt io"><em class="in">最小</em> </strong> <em class="in">所有分配的不公平</em>。</p></blockquote><h2 id="fd2a" class="ky kb in bd kc kz la dn kg lb lc dp kk ld le lf ko lg lh li ks lj lk ll kw lm bi translated">方法</h2><p id="59c4" class="pw-post-body-paragraph lq lr in lt b lu mt lw lx ly mu ma mb ld mv me mf lg mw mi mj lj mx mm mn mo ig bi translated">这个问题可以用回溯来解决。我们尝试了所有可能的组合来最小化分配的不公平性。</p><p id="1b2a" class="pw-post-body-paragraph lq lr in lt b lu lv lw lx ly lz ma mb ld md me mf lg mh mi mj lj ml mm mn mo ig bi translated"><strong class="lt io">注意:</strong>对于 python 来说，天真的回溯将 TLE。因此，需要应用分支的界限。在这种情况下，当不公平性超过先前计算的结果时，我们不进行分支。因为分布中的不公平性已经超过了先前计算的结果，所以转到分支的末端没有意义。</p><h2 id="d294" class="ky kb in bd kc kz la dn kg lb lc dp kk ld le lf ko lg lh li ks lj lk ll kw lm bi translated">解决办法</h2><div class="my mz gp gr na nb"><a href="https://github.com/bumblebee211196/lc_contests/blob/main/contest_297/python/problem3.py" rel="noopener  ugc nofollow" target="_blank"><div class="nc ab fo"><div class="nd ab ne cl cj nf"><h2 class="bd io gy z fp ng fr fs nh fu fw im bi translated">LC _ contracts/problem 3 . py 在主大黄蜂 211196/LC _ contracts</h2><div class="ni l"><h3 class="bd b gy z fp ng fr fs nh fu fw dk translated">此文件包含双向 Unicode 文本，其解释或编译可能与下面显示的不同…</h3></div><div class="nj l"><p class="bd b dl z fp ng fr fs nh fu fw dk translated">github.com</p></div></div><div class="nk l"><div class="nr l nm nn no nk np jt nb"/></div></div></a></div><blockquote class="ln lo lp"><p id="a1a7" class="lq lr ls lt b lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo ig bi translated">时间复杂度:O(k^n)</p><p id="52ed" class="lq lr ls lt b lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo ig bi translated">空间复杂度:O(k)</p></blockquote><h1 id="d868" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">问题 4</h1><h2 id="b31b" class="ky kb in bd kc kz la dn kg lb lc dp kk ld le lf ko lg lh li ks lj lk ll kw lm bi translated"><a class="ae jz" href="https://leetcode.com/contest/weekly-contest-297/problems/naming-a-company/" rel="noopener ugc nofollow" target="_blank">命名公司</a></h2><blockquote class="ln lo lp"><p id="d7d1" class="lq lr ls lt b lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo ig bi translated">您得到了一个字符串数组<code class="fe mp mq mr ms b">ideas</code>，它表示在命名公司的过程中使用的名称列表。命名公司的过程如下:</p><p id="3a82" class="lq lr ls lt b lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo ig bi translated">从<code class="fe mp mq mr ms b">ideas</code>中选择 2 个<strong class="lt io">不同的</strong>名称，分别称为<code class="fe mp mq mr ms b">ideaA</code>和<code class="fe mp mq mr ms b">ideaB</code>。</p><p id="d6fc" class="lq lr ls lt b lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo ig bi translated">将<code class="fe mp mq mr ms b">ideaA</code>和<code class="fe mp mq mr ms b">ideaB</code>的第一个字母互换。</p><p id="7f77" class="lq lr ls lt b lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo ig bi translated">如果新名称的<strong class="lt io">和</strong>都没有在原<code class="fe mp mq mr ms b">ideas</code>中找到，那么名称<code class="fe mp mq mr ms b">ideaA ideaB</code>(<code class="fe mp mq mr ms b">ideaA</code>和<code class="fe mp mq mr ms b">ideaB</code>的<strong class="lt io">串联</strong>，中间用空格隔开)就是有效的公司名称。</p><p id="dde7" class="lq lr ls lt b lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo ig bi translated">否则，它不是有效的名称。</p><p id="aa03" class="lq lr ls lt b lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo ig bi translated">返回<em class="in"/><strong class="lt io"><em class="in">不同</em> </strong> <em class="in">的公司有效名称</em>。</p></blockquote><h2 id="31a5" class="ky kb in bd kc kz la dn kg lb lc dp kk ld le lf ko lg lh li ks lj lk ll kw lm bi translated">方法</h2><p id="ba71" class="pw-post-body-paragraph lq lr in lt b lu mt lw lx ly mu ma mb ld mv me mf lg mw mi mj lj mx mm mn mo ig bi translated">我们把所有的名字按其开头字母分组。以不同字符开头的名字只有在它们的正文不匹配时才能被考虑。</p><p id="5860" class="pw-post-body-paragraph lq lr in lt b lu lv lw lx ly lz ma mb ld md me mf lg mh mi mj lj ml mm mn mo ig bi translated">比如“coffee”和“donuts”有不同的起始字符和不同的体“c-offee”和“d-onuts”。交换这里的起始字符就产生了两个不同的单词“c-onuts”和“d-offee”。然而，“咖啡”和“太妃糖”有不同的起始字符，但具有相同的体“c-offee”和“t-offee”。交换起始字符不会产生不同的单词。</p><p id="fb03" class="pw-post-body-paragraph lq lr in lt b lu lv lw lx ly lz ma mb ld md me mf lg mh mi mj lj ml mm mn mo ig bi translated">我们可以使用一个<strong class="lt io">设置</strong>和<strong class="lt io">差值</strong>操作来消除这种情况。</p><h2 id="3f80" class="ky kb in bd kc kz la dn kg lb lc dp kk ld le lf ko lg lh li ks lj lk ll kw lm bi translated">解决办法</h2><div class="my mz gp gr na nb"><a href="https://github.com/bumblebee211196/lc_contests/blob/main/contest_297/python/problem4.py" rel="noopener  ugc nofollow" target="_blank"><div class="nc ab fo"><div class="nd ab ne cl cj nf"><h2 class="bd io gy z fp ng fr fs nh fu fw im bi translated">LC _ contracts/problem 4 . py 在主大黄蜂 211196/LC _ contracts</h2><div class="ni l"><h3 class="bd b gy z fp ng fr fs nh fu fw dk translated">此文件包含双向 Unicode 文本，其解释或编译可能与下面显示的不同…</h3></div><div class="nj l"><p class="bd b dl z fp ng fr fs nh fu fw dk translated">github.com</p></div></div><div class="nk l"><div class="ns l nm nn no nk np jt nb"/></div></div></a></div><blockquote class="ln lo lp"><p id="6904" class="lq lr ls lt b lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo ig bi translated">时间复杂度:O(m)其中 m 是相同起始字符下的主体的最大数量。这个时间复杂度主要是由于集差运算。</p><p id="c62c" class="lq lr ls lt b lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo ig bi translated">空间复杂度:O(n)</p></blockquote><p id="9cfc" class="pw-post-body-paragraph lq lr in lt b lu lv lw lx ly lz ma mb ld md me mf lg mh mi mj lj ml mm mn mo ig bi translated">我希望你们喜欢这篇文章。</p><p id="ee4b" class="pw-post-body-paragraph lq lr in lt b lu lv lw lx ly lz ma mb ld md me mf lg mh mi mj lj ml mm mn mo ig bi translated">如果你觉得有帮助，请分享和鼓掌非常感谢！😄</p><p id="71f9" class="pw-post-body-paragraph lq lr in lt b lu lv lw lx ly lz ma mb ld md me mf lg mh mi mj lj ml mm mn mo ig bi translated">欢迎在评论区提问！。</p></div></div>    
</body>
</html>