<html>
<head>
<title>Apache Arrow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">阿帕奇箭头</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/apache-arrow-2d72137d9e84?source=collection_archive---------1-----------------------#2022-10-31">https://blog.devgenius.io/apache-arrow-2d72137d9e84?source=collection_archive---------1-----------------------#2022-10-31</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/ae00c793d15982202be680a19f079a09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*46a_JRL3Pxl4YWCp79s3wQ.png"/></div></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk translated"><a class="ae ja" href="https://arrow.apache.org/" rel="noopener ugc nofollow" target="_blank">https://arrow.apache.org/</a></figcaption></figure><div class=""/><p id="6556" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一种独立于语言的内存列数据格式</p><h2 id="feb7" class="ky kz jd bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">什么是阿帕奇箭？</h2><p id="1011" class="pw-post-body-paragraph ka kb jd kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">Apache Arrow 的核心是一个标准化的、独立于语言的内存列格式规范，用于在内存中表示表格数据集。它还包括将箭头表示公开为 API 的库。</p><figure class="lx ly lz ma gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi lw"><img src="../Images/b94400bd1b1ae3aa2c9c92357cc1f6a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mw19wwO5T8R1U6kuDY2i0g.png"/></div></div></figure><p id="2f59" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Apache Arrow 正在用于 pandas、Dremio、Spark、Amazon Data Wrangler、AWS Athena、AWS Lake Formation、Superset、Streamlit 和 Drill 等项目。</p><h2 id="705b" class="ky kz jd bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">关键组件</h2><ul class=""><li id="c97a" class="mb mc jd kc b kd lr kh ls kl md kp me kt mf kx mg mh mi mj bi translated">数据交换规范</li><li id="7731" class="mb mc jd kc b kd mk kh ml kl mm kp mn kt mo kx mg mh mi mj bi translated">输入输出库</li><li id="a32a" class="mb mc jd kc b kd mk kh ml kl mm kp mn kt mo kx mg mh mi mj bi translated">网络格式</li><li id="5a74" class="mb mc jd kc b kd mk kh ml kl mm kp mn kt mo kx mg mh mi mj bi translated">向量计算库</li><li id="9407" class="mb mc jd kc b kd mk kh ml kl mm kp mn kt mo kx mg mh mi mj bi translated">分区数据集管理器</li></ul><h2 id="e21a" class="ky kz jd bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">内存中的列数据格式</h2><figure class="lx ly lz ma gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi mp"><img src="../Images/fd2320301fa28471d983cdb1e3cf5c00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PyGVibdKYT7clA3yvFIGPA.png"/></div></div></figure><p id="8240" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">到处写，到处跑。</p><figure class="lx ly lz ma gt ip gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/c3ac39691fa6449e05d52061f4d8f8d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1262/format:webp/1*hjpJy8nA7KriAYX3e-cRMA.png"/></div></figure><h2 id="0cba" class="ky kz jd bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">Arrow 性能优势</h2><ul class=""><li id="fa29" class="mb mc jd kc b kd lr kh ls kl md kp me kt mf kx mg mh mi mj bi translated"><strong class="kc je">与平台和语言无关— </strong> Arrow 是一个通晓多种语言的人。</li><li id="5490" class="mb mc jd kc b kd mk kh ml kl mm kp mn kt mo kx mg mh mi mj bi translated"><strong class="kc je">平行度</strong>。一次数据传输可以并行跨越多个节点、处理器和系统。</li><li id="7a69" class="mb mc jd kc b kd mk kh ml kl mm kp mn kt mo kx mg mh mi mj bi translated"><strong class="kc je">缓存局部性:</strong> Arrow 将相似的类型一起存储在内存中。这使得高速缓存预取更加有效，最大限度地减少了因高速缓存未命中和主内存访问导致的 CPU 延迟。</li><li id="c642" class="mb mc jd kc b kd mk kh ml kl mm kp mn kt mo kx mg mh mi mj bi translated"><strong class="kc je">流水线:</strong> Arrow 通过最大限度地减少循环内指令数量和循环复杂性，减少了分支预测失败。</li></ul><figure class="lx ly lz ma gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi mr"><img src="../Images/0688db7f8acde43e3a8a621093dbe0ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bja60xcVvHtIGoNBFYqeLg.png"/></div></div></figure><ul class=""><li id="5974" class="mb mc jd kc b kd ke kh ki kl ms kp mt kt mu kx mg mh mi mj bi translated"><strong class="kc je"> SIMD 指令:</strong> Arrow 组织数据，使其非常适合 SIMD(在单个时钟周期内执行多个操作)操作。</li></ul><figure class="lx ly lz ma gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi mv"><img src="../Images/63ee0d2d693cb7e6305e35c53749f159.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yb47aT1-KdY-SguYRUmIrQ.png"/></div></div></figure><ul class=""><li id="c495" class="mb mc jd kc b kd ke kh ki kl ms kp mt kt mu kx mg mh mi mj bi translated"><strong class="kc je">零拷贝数据共享:</strong>当两个系统采用 Arrow 作为内部表示时，一个系统可以将数据直接交给另一个系统使用，从而减少数据移动开销。</li><li id="da95" class="mb mc jd kc b kd mk kh ml kl mm kp mn kt mo kx mg mh mi mj bi translated">Arrow 旨在最大限度地降低在网络上移动数据的成本。它利用分散/集中读取和写入，并具有零序列化/反序列化设计，允许节点之间的低成本数据移动。</li></ul><h2 id="88d4" class="ky kz jd bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">在 Python 中使用箭头。</h2><pre class="lx ly lz ma gt mw mx my bn mz na bi"><span id="e9ef" class="nb kz jd mx b be nc nd l ne nf"># pip install pyarrow<br/>import pyarrow as pa<br/>import pyarrow.compute as pc<br/>import pyarrow.dataset as ds<br/>import pyarrow.flight # transmit arrow buffers over gRPC<br/>import pyarrow.parquet<br/>import pyarrow.feather<br/><br/>mmap_file = pa.memorty_map('demo-file.arrow', r)<br/>table = pa.ipc.RecordBatchFileReader(mmap_file).read_all()<br/>df = table.to_pandas()<br/># pandas -&gt; arrow -&gt; pandas<br/>table_pa = pa.Table.from_pandas(df_pandas)<br/>df_pandas = table_pa.to_pandas()</span></pre><h2 id="1363" class="ky kz jd bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">数据类型映射</h2><blockquote class="ng nh ni"><p id="5856" class="ka kb nj kc b kd ke kf kg kh ki kj kk nk km kn ko nl kq kr ks nm ku kv kw kx ig bi translated">模式—元数据<br/>表—数据帧<br/>数组—列表/列</p></blockquote><h2 id="b4e9" class="ky kz jd bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">箭头的 PySpark 设置</h2><pre class="lx ly lz ma gt mw mx nn no aw np bi"><span id="ffb6" class="ky kz jd mx b gy nq nr l ns nf">spark.sql.execution.arrow.pyspark.enabled=<strong class="mx je">true<br/></strong>spark.sql.execution.arrow.pyspark.fallback.enabled=<strong class="mx je">true</strong><br/>spark.sql.parquet.mergeSchema=<strong class="mx je">false</strong><br/>spark.hadoop.parquet.enable.summary-metadata=<strong class="mx je">false</strong><br/>spark.sql.execution.arrow.maxRecordsPerBatch=20000</span></pre><p id="692f" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">PyArrow 还集成了 Hive、Kudu 和 Cassandra</p><h2 id="9cf0" class="ky kz jd bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">箭头飞行</h2><p id="a362" class="pw-post-body-paragraph ka kb jd kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">Arrow Flight 是一种基于专用 gRPC 的数据传输协议，它简化了大型数据集在网络接口上的高性能传输。Arrow Flight 保持内存中格式的相同在线表示，消除了序列化开销。</p><h2 id="153d" class="ky kz jd bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">是什么让阿帕奇箭飞行速度很快？</h2><ul class=""><li id="dffc" class="mb mc jd kc b kd lr kh ls kl md kp me kt mf kx mg mh mi mj bi translated"><strong class="kc je">无序列化/反序列化</strong>。由于跨系统的相同表示，当数据跨越流程边界时，不需要进行数据重组。</li><li id="f20a" class="mb mc jd kc b kd mk kh ml kl mm kp mn kt mo kx mg mh mi mj bi translated"><strong class="kc je">批量操作</strong>。Arrow Flight 对记录批次进行操作，而不必访问单独的列、记录或单元格。</li><li id="66e3" class="mb mc jd kc b kd mk kh ml kl mm kp mn kt mo kx mg mh mi mj bi translated"><strong class="kc je">无限并行</strong>。Flight 是一种横向扩展技术，因此实际上，吞吐量只受客户端和服务器以及两者之间的网络的能力限制。</li><li id="5fe9" class="mb mc jd kc b kd mk kh ml kl mm kp mn kt mo kx mg mh mi mj bi translated"><strong class="kc je">高效的网络利用。</strong> Flight 使用 gRPC 和 HTTP/2 传输数据，提供高网络利用率。</li></ul><p id="d29d" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">使用 Flight 提供数据</p><pre class="lx ly lz ma gt mw mx my bn mz na bi"><span id="f014" class="nb kz jd mx b be nc nd l ne nf">import pyarrow as pa<br/>import pyarrow.flight as flight<br/><br/>def deliver_data(flight_server, pyarrow_df):<br/>    flight_server.serve_buffers(df, metadata=pyarrow_df.schema.metadata)<br/><br/>with flight.FlightServer.from_ports(port_range=(9000, 90001)) as server:<br/>    serve_data(server)</span></pre><blockquote class="ng nh ni"><p id="2c80" class="ka kb nj kc b kd ke kf kg kh ki kj kk nk km kn ko nl kq kr ks nm ku kv kw kx ig bi translated">雪花和 BigQuery 都支持以箭头格式传递结果。</p></blockquote><pre class="lx ly lz ma gt mw mx nn no aw np bi"><span id="4643" class="ky kz jd mx b gy nq nr l ns nf">pip install snowflake-connector-python[pandas]<br/>ctx = snowflake.connector.connect(...)<br/>cur = ctx.cursor()<br/>sql = "select * from demo_table"<br/>cur.execute(sql)<br/>df = cur.fetch_pandas_all()<br/># alternate<br/>for df in cur.fetch_pandas_batches()<br/>    ...</span></pre><h2 id="4129" class="ky kz jd bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">箭头飞行 SQL</h2><p id="00b6" class="pw-post-body-paragraph ka kb jd kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">它是从数据库进行高性能数据传输的通用(适用于所有数据库引擎的单一驱动程序)标准。它是建立在箭飞行之上的。而使用 Arrow Flight SQL 读取 10 M 记录比使用 PyODBC 读取 10M 记录快 15 倍。</p><figure class="lx ly lz ma gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi nt"><img src="../Images/1afd169172e098f9acf8eebcb04eed04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jylaAQ0JQ5JdfaC0BRU8Xw.png"/></div></div></figure><h2 id="fffa" class="ky kz jd bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">极地</h2><p id="da14" class="pw-post-body-paragraph ka kb jd kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">Polars 是一个非常快的数据帧库，使用 Apache Arrow 作为内存模型在 Rust 中实现。</p><pre class="lx ly lz ma gt mw mx nn no aw np bi"><span id="7a22" class="ky kz jd mx b gy nq nr l ns nf">pip install polars[numpy,pandas,pyarrow]</span></pre><h2 id="6473" class="ky kz jd bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">Arrow 的其他功能</h2><ul class=""><li id="1289" class="mb mc jd kc b kd lr kh ls kl md kp me kt mf kx mg mh mi mj bi translated">支持压缩和编码</li><li id="d3d3" class="mb mc jd kc b kd mk kh ml kl mm kp mn kt mo kx mg mh mi mj bi translated">支持 CPU 加速</li><li id="4828" class="mb mc jd kc b kd mk kh ml kl mm kp mn kt mo kx mg mh mi mj bi translated">支持 GPU</li></ul><p id="2499" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">感谢阅读！！</p></div></div>    
</body>
</html>