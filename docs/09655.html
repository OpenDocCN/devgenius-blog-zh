<html>
<head>
<title>Elixir 1.14 — What’s New and Why it Matters</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">酏剂 1.14 —新增内容及其重要性</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/elixir-1-14-whats-new-and-why-it-matters-8ee238d223d3?source=collection_archive---------3-----------------------#2022-09-03">https://blog.devgenius.io/elixir-1-14-whats-new-and-why-it-matters-8ee238d223d3?source=collection_archive---------3-----------------------#2022-09-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="2663" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">仙丹 1.14 刚刚发布。了解新内容，更重要的是，了解它的重要性。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/6db2e10467be72776d6892db8b94dce9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zs0JaL55Sr4guzLM"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">Jan Ranft 在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="5aab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://elixir-lang.org" rel="noopener ugc nofollow" target="_blank"> Elixir 1.14 现已发布</a>，对已经令人惊叹的语言进行了几项重大改进。虽然有很多变化，但出现最多的主题之一是围绕检查和调试——一些受欢迎的变化改善了开发和调试体验。</p><p id="f941" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我们将深入探讨 1.14 中的新特性，更重要的是，为什么这些变化如此重要。我们将在这里关注更大和更重要的变化，但是还有大量的其他变化、错误修复和改进。有关变更的完整列表，请参见<a class="ae kv" href="https://github.com/elixir-lang/elixir/blob/v1.14/CHANGELOG.md" rel="noopener ugc nofollow" target="_blank">酏剂变更日志</a>。</p><h1 id="254d" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">使用 Kernel.dbg/2 进行更好的调试</h1><p id="dbc3" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">记录和检查输出是 Elixir 的一种常见调试技术，尤其是在高度并发的应用程序中，传统的调试方法(如断点)可能难以使用。这通常涉及到<code class="fe mp mq mr ms b">IO.inspect/2</code>的使用，它打印一个值的“已检查”表示。新的<code class="fe mp mq mr ms b">Kernel.dbg/2</code>通过在<code class="fe mp mq mr ms b">IO.inspect/2</code>提供的基础上增加额外的上下文来提供更好的调试功能。</p><p id="be7c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们来看看变更日志中提供的例子。下面是调用<code class="fe mp mq mr ms b">dbg</code>的代码可能的样子:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="51ca" class="mx lt iq ms b gy my mz l na nb"># In my_file.exs<br/>feature = %{name: :dbg, inspiration: "Rust"}<br/>dbg(feature)<br/>dbg(Map.put(feature, :in_version, "1.14.0"))</span></pre><p id="1e4a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是我们在执行代码时看到的输出:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="9d89" class="mx lt iq ms b gy my mz l na nb">$ elixir my_file.exs<br/>[my_file.exs:2: (file)]<br/>feature #=&gt; %{inspiration: "Rust", name: :dbg}<br/><br/>[my_file.exs:3: (file)]<br/>Map.put(feature, :in_version, "1.14.0") #=&gt; %{in_version: "1.14.0", inspiration: "Rust", name: :dbg}</span></pre><p id="d6be" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除了改进的调试输出，<code class="fe mp mq mr ms b">Kernel.dbg</code>还为其他工具提供了一个可配置的集成点:例如，<code class="fe mp mq mr ms b">IEx</code>与<code class="fe mp mq mr ms b">dbg</code>集成以提供断点行为，这样您就可以在使用<code class="fe mp mq mr ms b">IEx</code>运行时检查应用程序的状态。</p><h2 id="9c0d" class="mx lt iq bd lu nc nd dn ly ne nf dp mc lf ng nh me lj ni nj mg ln nk nl mi nm bi translated">为什么它很重要</h2><p id="a367" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">对于 Elixir，调试可能是一个棘手的话题，因为工具和经验往往落后于其他流行语言。Kernel.dbg 的引入并没有完全解决缺点，但它是一个受欢迎的补充，是朝着正确方向迈出的一步。它既增强了现有的调试输出方法(通常使用<code class="fe mp mq mr ms b">IO.inspect</code>、<code class="fe mp mq mr ms b">IO.puts</code>)，又通过为其他工具提供一个集成点来支持更高级的方法。</p><h1 id="48ad" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">更好的 IO.inspect 输出:基于表达式的检查</h1><p id="3a61" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">补充新的<code class="fe mp mq mr ms b">Kernel.dbg/2</code>功能的是对<code class="fe mp mq mr ms b">IO.inspect/2</code>本身的改进。使用变更日志中的例子，让我们看看之前的<code class="fe mp mq mr ms b">inspect</code>行为:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="9eca" class="mx lt iq ms b gy my mz l na nb">iex(1)&gt; [:apple, :banana]<br/>[:apple, :banana]</span><span id="bb75" class="mx lt iq ms b gy nn mz l na nb">iex(2)&gt; MapSet.new([:apple, :banana])<br/>#MapSet&lt;[:apple, :banana]&gt;</span></pre><p id="c497" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的例子中，我们看到我们的列表表达式产生了一个我们可以复制和粘贴的有效的灵丹妙药代码表示——但是我们的<code class="fe mp mq mr ms b">MapSet</code>表达式没有！</p><p id="d4d9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">随着 1.14 中的变化，像<code class="fe mp mq mr ms b">MapSet</code>这样的内部结构现在产生的<code class="fe mp mq mr ms b">inspect</code>输出是有效的灵丹妙药:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="52a1" class="mx lt iq ms b gy my mz l na nb">iex(1)&gt; MapSet.new([:apple, :banana]) |&gt; MapSet.put(:pear)<br/>MapSet.new([:apple, :banana, :pear])</span></pre><h2 id="eaf0" class="mx lt iq bd lu nc nd dn ly ne nf dp mc lf ng nh me lj ni nj mg ln nk nl mi nm bi translated">为什么它很重要</h2><p id="9af1" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">酏剂的 REPL 是酏剂开发过程中非常重要的一部分——价值<em class="no">检验</em>是每个评估步骤的一部分。能够从表达式中复制和粘贴输入和输出值是 REPL 循环的一个重要部分，在 1.14 之前，这有时会因为输出不是有效的 Elixir 代码而变得更加困难。对于任何花时间使用 Elixir 控制台的人来说，这一变化将是一个受欢迎的补充。</p><h1 id="195b" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">新主管类型:分区主管</h1><p id="beef" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">Elixir 1.14 引入了一个新的<code class="fe mp mq mr ms b"><a class="ae kv" href="https://hexdocs.pm/elixir/main/PartitionSupervisor.html" rel="noopener ugc nofollow" target="_blank">PartitionSupervisor</a></code>，它可以用来管理多个相同的进程(默认情况下等于核心的数量)，然后可以通过您选择的某个<em class="no">分区键</em>来分别路由请求。这种新的管理器可以为任何进程提供简单的并发和负载平衡。</p><p id="789e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们快速看一下发行说明中的示例:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="1e22" class="mx lt iq ms b gy my mz l na nb">partitioning_key = self()<br/>ErrorReporter.report({:via, PartitionSupervisor, {Reporters, partitioning_key}}, error)</span></pre><p id="5b6b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个例子中，<code class="fe mp mq mr ms b">ErrorReporter</code> <em class="no"> </em>模块通过分区管理器在几个<code class="fe mp mq mr ms b">Reporter</code>进程中平衡负载。所提供的<code class="fe mp mq mr ms b">partitioning_key</code>指定了应该使用哪个进程——在本例中，通过使用<code class="fe mp mq mr ms b">self()</code>,调用者确保了单个进程总是使用同一个报告者，但是您可以很容易地通过其他值(如用户 ID 或主机名)进行划分。</p><h2 id="a654" class="mx lt iq bd lu nc nd dn ly ne nf dp mc lf ng nh me lj ni nj mg ln nk nl mi nm bi translated">为什么它很重要</h2><p id="c1fe" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><code class="fe mp mq mr ms b">PartitionSupervisor</code>作为一种嵌入式解决方案，有助于解决一个常见的性能瓶颈:单个消费者流程因请求而过载。Elixir 最大的优势之一是它构建在 Erlang/OTP 之上，并且开箱即用，对并发性提供了真正惊人的支持。像<code class="fe mp mq mr ms b">PartitionSupervisor</code>这样的新增功能有助于进一步增强这种支持。</p><h1 id="9a0a" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">重述—酏剂 1.14</h1><p id="ab6c" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">Elixir 是一种非常棒的编程语言，而且还会变得越来越好。虽然 1.14 的更新并不是惊天动地的，但它带来了许多重要的人体工程学改进，使其更容易使用。有关酏剂 1.14 的更多信息，包括如何安装或升级，请参见<a class="ae kv" href="https://elixir-lang.org/install.html" rel="noopener ugc nofollow" target="_blank">酏剂安装页面</a>。</p></div><div class="ab cl np nq hu nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="ij ik il im in"><p id="8988" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://blog.devgenius.io/@jonnystartup" rel="noopener ugc nofollow" target="_blank"> <em class="no">乔纳森</em> </a> <em class="no">在创业公司大&amp;小有超过 20 年的工程领导经验。如果你喜欢这篇文章，</em> <a class="ae kv" href="https://www.buymeacoffee.com/jonnystartup" rel="noopener ugc nofollow" target="_blank"> <em class="no">请考虑给乔纳森留个提示</em> </a> <em class="no">！</em></p></div></div>    
</body>
</html>