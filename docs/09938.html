<html>
<head>
<title>Introduction to SQL Stored Procedures</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SQL 存储过程简介</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/introduction-to-sql-stored-procedures-68eb8d6d6e6?source=collection_archive---------8-----------------------#2022-09-24">https://blog.devgenius.io/introduction-to-sql-stored-procedures-68eb8d6d6e6?source=collection_archive---------8-----------------------#2022-09-24</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/f548f327166b83726a9ff3eea7f40513.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PD0oRQbjevNt2UwiuT5VNg.png"/></div></div></figure><blockquote class="jv"><p id="1cd6" class="jw jx in bd jy jz ka kb kc kd ke kf dk translated">本文概述了存储过程。</p></blockquote><h2 id="7fc1" class="kg kh in bd ki kj kk dn kl km kn dp ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">🧐什么是<strong class="ak">存储过程</strong></h2><p id="c2e5" class="pw-post-body-paragraph lc ld in le b lf lg lh li lj lk ll lm kp ln lo lp kt lq lr ls kx lt lu lv kf ig bi lw translated"><span class="l lx ly lz bm ma mb mc md me di"> S </span>暗指 put，存储过程是一个或多个 SQL 语句的集合，这些语句被<strong class="le io"> <em class="mf">保留以备将来使用</em> </strong>。虽然您可以将它们视为批处理文件，但它们不仅仅是批处理文件。</p><blockquote class="jv"><p id="9d2c" class="jw jx in bd jy jz mg mh mi mj mk kf dk translated"><em class="ml"> SQLite 不支持存储过程。</em></p></blockquote></div><div class="ab cl mm mn hr mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ig ih ii ij ik"><h2 id="ee0a" class="kg kh in bd ki kj mt dn kl km mu dp ko kp mv kr ks kt mw kv kw kx mx kz la lb bi translated"><strong class="ak">🔗理解为什么要使用存储过程</strong></h2><ol class=""><li id="e80b" class="my mz in le b lf lg lj lk kp na kt nb kx nc kf nd ne nf ng bi translated">通过将复杂的操作封装到一个简单易用的单元中来简化它们。</li><li id="5d54" class="my mz in le b lf nh lj ni kp nj kt nk kx nl kf nd ne nf ng bi translated">以确保数据一致性，而无需重复创建一系列步骤。如果所有开发人员和应用程序都使用相同的存储过程，那么每个人都将使用相同的代码。</li><li id="84e0" class="my mz in le b lf nh lj ni kp nj kt nk kx nl kf nd ne nf ng bi translated">简化变更管理。如果表、列名、业务逻辑或其他任何内容发生变化，只需修改存储过程代码，其他人不需要知道这些变化。</li><li id="b38f" class="my mz in le b lf nh lj ni kp nj kt nk kx nl kf nd ne nf ng bi translated">以减少处理命令所需的工作量。DBMS 执行的工作较少，因为存储过程通常以编译形式存储。这导致增强的性能。</li><li id="631f" class="my mz in le b lf nh lj ni kp nj kt nk kx nl kf nd ne nf ng bi translated">创建更健壮、适应性更强的代码。有些 SQL 语言功能和部分只能在单个请求中访问。这就是存储过程可以使用它们的原因。</li></ol><blockquote class="jv"><p id="8eda" class="jw jx in bd jy jz ka kb kc kd ke kf dk translated">存储过程的语法在不同的 DBMSs 中变化很大。实际上，创建完全可移植的存储过程非常困难。</p></blockquote></div><div class="ab cl mm mn hr mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ig ih ii ij ik"><h1 id="63a4" class="nm kh in bd ki nn no np kl nq nr ns ko nt nu nv ks nw nx ny kw nz oa ob la oc bi translated">💎创建存储过程</h1><p id="2c30" class="pw-post-body-paragraph lc ld in le b lf lg lh li lj lk ll lm kp ln lo lp kt lq lr ls kx lt lu lv kf ig bi translated"><strong class="le io"> <em class="mf">创建或替换过程</em> </strong>存在于 PostgreSQL 中，用于创建新过程或用新定义替换现有定义。对于能够<strong class="le io">创建或替换过程</strong>的 PostgreSQL 用户，需要该语言的<strong class="le io">使用权限</strong>。</p><figure class="oe of og oh gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi od"><img src="../Images/e55b9d80faed55e80ee4dcdcda8cb57f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GtCg7Ztka3FVfU5EaKPTbw.png"/></div></div></figure><p id="d6ed" class="pw-post-body-paragraph lc ld in le b lf oi lh li lj oj ll lm kp ok lo lp kt ol lr ls kx om lu lv kf ig bi translated">当指定模式名时，会在模式中生成一个过程。否则，当前模式包含新构建的模式。另外，CREATE 或 REPLACE 过程可用于修改或替换当前过程的定义。</p><h2 id="2162" class="kg kh in bd ki kj mt dn kl km mu dp ko kp mv kr ks kt mw kv kw kx mx kz la lb bi translated">现在，不要忘记 SQL Server，这里有几个使用它的例子</h2><figure class="oe of og oh gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi od"><img src="../Images/e9daec90dbd940825c784c744c938011.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x2xrQOfO_Mbs4784MEjhRg.png"/></div></div></figure><p id="5dc1" class="pw-post-body-paragraph lc ld in le b lf oi lh li lj oj ll lm kp ok lo lp kt ol lr ls kx om lu lv kf ig bi translated">这个存储过程没有任何参数。调用应用程序通过使用 SQL Server 的返回代码支持来检索该值。这里使用<code class="fe on oo op oq b">DECLARE</code>语句声明了一个名为<code class="fe on oo op oq b">@news_count</code>的局部变量。然后在<code class="fe on oo op oq b">SELECT</code>语句中使用这个变量，以便它包含由<code class="fe on oo op oq b">COUNT()</code>函数返回的值。最后，<code class="fe on oo op oq b">RETURN</code>语句用于将计数作为<code class="fe on oo op oq b">RETURN @news_count</code>返回给调用应用程序。</p><h2 id="d0cf" class="kg kh in bd ki kj mt dn kl km mu dp ko kp mv kr ks kt mw kv kw kx mx kz la lb bi translated"><strong class="ak">执行存储过程</strong></h2><figure class="oe of og oh gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi od"><img src="../Images/1fc6a0807510a81058f176d5e9d5232c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mASbijnEJsHvsWUng-Cr4w.png"/></div></div></figure><p id="99c2" class="pw-post-body-paragraph lc ld in le b lf oi lh li lj oj ll lm kp ok lo lp kt ol lr ls kx om lu lv kf ig bi translated">这段代码声明一个变量来保存存储过程返回的内容，执行存储过程，然后使用一个<code class="fe on oo op oq b">SELECT</code>来显示返回值。</p></div><div class="ab cl mm mn hr mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ig ih ii ij ik"><h1 id="fae9" class="nm kh in bd ki nn no np kl nq nr ns ko nt nu nv ks nw nx ny kw nz oa ob la oc bi translated">🤓存储过程和函数</h1><p id="9ef8" class="pw-post-body-paragraph lc ld in le b lf lg lh li lj lk ll lm kp ln lo lp kt lq lr ls kx lt lu lv kf ig bi translated">与函数不同，存储过程<strong class="le io">不会</strong>返回值。解释很简单:存储过程的唯一功能是<strong class="le io"> <em class="mf">完成动作</em> </strong>。</p><h2 id="ed0b" class="kg kh in bd ki kj mt dn kl km mu dp ko kp mv kr ks kt mw kv kw kx mx kz la lb bi translated"><strong class="ak">让我们创建一个存储过程</strong></h2><figure class="oe of og oh gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi or"><img src="../Images/9e54233047cf7f61ebabee316ff39bc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MIuQEDgZtL6LKWptMIgteQ.png"/></div></div></figure><p id="42d7" class="pw-post-body-paragraph lc ld in le b lf oi lh li lj oj ll lm kp ok lo lp kt ol lr ls kx om lu lv kf ig bi translated"><em class="mf">姑且称之为</em></p><figure class="oe of og oh gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi or"><img src="../Images/e2b93eed75cff0c0c1c77fbc9c30db54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hnG8oJtZNVDfo1Yuxe339g.png"/></div></div></figure><h2 id="002d" class="kg kh in bd ki kj mt dn kl km mu dp ko kp mv kr ks kt mw kv kw kx mx kz la lb bi translated"><strong class="ak">现在让我们创建一个函数</strong></h2><figure class="oe of og oh gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi or"><img src="../Images/e8374bad708ec806e54dd204ea77d8b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pRYwpky4XDv3cGM2Zll2EA.png"/></div></div></figure><p id="2d18" class="pw-post-body-paragraph lc ld in le b lf oi lh li lj oj ll lm kp ok lo lp kt ol lr ls kx om lu lv kf ig bi translated"><em class="mf">姑且称之为</em></p><figure class="oe of og oh gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi or"><img src="../Images/b966da92d175b8cf2e6aeb7a01e9d037.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MLdsJEGnfn8ABpB7QB_eZA.png"/></div></div></figure><h2 id="bb50" class="kg kh in bd ki kj mt dn kl km mu dp ko kp mv kr ks kt mw kv kw kx mx kz la lb bi translated">🆚以下是存储过程与函数的区别:</h2><ul class=""><li id="081a" class="my mz in le b lf lg lj lk kp na kt nb kx nc kf os ne nf ng bi translated">当使用<strong class="le io"> INOUT </strong>参数时，存储过程不需要返回任何东西，只返回一行。</li><li id="988e" class="my mz in le b lf nh lj ni kp nj kt nk kx nl kf os ne nf ng bi translated">在存储过程中，可以提交和回滚事务，但在函数中不行。</li><li id="aa79" class="my mz in le b lf nh lj ni kp nj kt nk kx nl kf os ne nf ng bi translated">您使用<code class="fe on oo op oq b">CALL/EXECUTE</code>语句而不是<code class="fe on oo op oq b">SELECT</code>语句来执行存储过程。</li><li id="e595" class="my mz in le b lf nh lj ni kp nj kt nk kx nl kf os ne nf ng bi translated">与函数不同，过程不能在其他 DML 命令中分层。</li></ul></div><div class="ab cl mm mn hr mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ig ih ii ij ik"><h2 id="e11c" class="kg kh in bd ki kj mt dn kl km mu dp ko kp mv kr ks kt mw kv kw kx mx kz la lb bi translated">😎优势..</h2><ul class=""><li id="5078" class="my mz in le b lf lg lj lk kp na kt nb kx nc kf os ne nf ng bi translated">只要可行，就可以经常重新引入存储过程，这大大减少了应用程序和数据库服务器之间的往返次数。</li><li id="36ed" class="my mz in le b lf nh lj ni kp nj kt nk kx nl kf os ne nf ng bi translated">应用程序现在只需调用一个函数，而不是发送 SQL 语句来检索结果和消除响应时间。</li><li id="2836" class="my mz in le b lf nh lj ni kp nj kt nk kx nl kf os ne nf ng bi translated">提高了应用程序的效率。PostgreSQL 数据库服务器预先组合了用户定义的函数和存储过程。</li></ul></div><div class="ab cl mm mn hr mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ig ih ii ij ik"><blockquote class="jv"><p id="283d" class="jw jx in bd jy jz mg mh mi mj mk kf dk translated">我希望你觉得这篇文章很有趣💕！</p></blockquote></div></div>    
</body>
</html>