<html>
<head>
<title>SQL Exercise: Solving Time Series Gap</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SQL 练习:解决时间序列差距</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/sql-exercise-solving-time-series-gap-8946113e35b8?source=collection_archive---------19-----------------------#2022-12-14">https://blog.devgenius.io/sql-exercise-solving-time-series-gap-8946113e35b8?source=collection_archive---------19-----------------------#2022-12-14</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="3f96" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">使用 BigQuery UNNEST 和 GENERATE_DATE_ARRAY 函数</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/fa451d765f8858fa62fe4185f02d6cb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kBjl3WUOHtV87sLVj3kavA.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">卡斯帕·卡米尔·鲁宾的图片来自 Unsplash。</figcaption></figure><p id="c87f" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">时间序列数据，如销售交易和用户注册，可能并不总是清晰明了。一些交易日之间可能会有间隙。此问题可能是由自然事件(无业务事件)或异常情况(缺少数据)引起的。我们需要正确地处理这个问题，这样我就不会在我们的下游任务上引起另一个问题，比如在我们的仪表板和报告上。无论是由于自然现象还是异常现象，我们仍然需要在仪表板和报告中报告这些差距，以便向利益相关者提供正在发生的事情的完整视图。我们不能跳过它们。</p><p id="a589" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">本文将演示如何处理这样的问题。我将分享一个有类似问题的案例研究的例子，以及如何使用带有 BigQuery 的<code class="fe lo lp lq lr b">UNNEST</code>和<code class="fe lo lp lq lr b">GENERATE_DATE_ARRAY</code>函数的 SQL 来处理它。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi ls"><img src="../Images/e0c3253866f64ec7a17c067638496820.png" data-original-src="https://miro.medium.com/v2/resize:fit:986/format:webp/1*_-4rq6Xf72KiOMRdgVkFJA.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">按作者分类的图像-时间序列数据中的缺口示例。</figcaption></figure><h2 id="e612" class="lt lu in bd lv lw lx dn ly lz ma dp mb lb mc md me lf mf mg mh lj mi mj mk ml bi translated">数据集。</h2><p id="f738" class="pw-post-body-paragraph ks kt in ku b kv mm jo kx ky mn jr la lb mo ld le lf mp lh li lj mq ll lm ln ig bi translated">本次演示的数据集是为教学目的创建的模拟数据集。数据集包含一些模拟的<strong class="ku io">海运价格数据</strong>，它们在交易日之间有一些<strong class="ku io">的间隙。数据存储在<code class="fe lo lp lq lr b">freight_datapoints</code>和<code class="fe lo lp lq lr b">freight_ports</code>表中。请在下面找到这两个表格的信息摘要。你可以在这里找到数据集。</strong></p><p id="8c01" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><strong class="ku io">货运数据点表</strong></p><p id="2567" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><strong class="ku io">日</strong> : <em class="ms">数据点有效的日期。</em><br/>T5】d _ id:<em class="ms">数据点的 ID。</em> <br/> <strong class="ku io">公司</strong> : <em class="ms">数据点所属的公司。</em><br/><strong class="ku io">supplied _ id</strong>:<em class="ms">供应商(客户与之签约的)的 ID 号。</em> <br/> <strong class="ku io">公司 _ 类别</strong> : <em class="ms">数据点所属公司的类别。</em> <br/> <strong class="ku io">关税 _ 类型</strong> : <em class="ms">数据点的关税类型。</em><br/><strong class="ku io">valid _ from</strong>:<em class="ms">数据点的开始合同有效期。</em><br/><strong class="ku io">p _ contract _ Length</strong>:<em class="ms">数据点价格有效期长度。</em><br/><strong class="ku io">c _ contract _ Length</strong>:<em class="ms">数据点的合同有效期长度。</em> <br/> <strong class="ku io">创建了</strong> : <em class="ms">数据点进入数据库的时间戳。</em> <br/> <strong class="ku io">价格</strong> : <em class="ms">数据点的总价。</em> <br/> <strong class="ku io">原点 _pid </strong> : <em class="ms">原点端口的 pid 号。</em><br/><strong class="ku io">destination _ pid</strong>:<em class="ms">目的端口的 PID 号。</em></p><pre class="kd ke kf kg gt mt lr mu bn mv mw bi"><span id="f8c0" class="mx lu in lr b be my mz l na nb">| day                        | d_id      | company   | supplier_id | company_category | tariff_type | valid_from                 | p_contract_length | c_contract_length | created                    | price | origin_pid | destination_pid |<br/>|----------------------------|-----------|-----------|-------------|------------------|-------------|----------------------------|-------------------|-------------------|----------------------------|-------|------------|-----------------|<br/>| 2012-06-01 00:00:00.000000 | 337204473 | company_0 | 1375        | category_1       | FAK         | 2012-06-01 00:00:00.000000 | 61                | 365               | 2012-08-17 11:00:06.598627 | 195.0 | 802        | 736             |<br/>| 2012-06-02 00:00:00.000000 | 337204473 | company_0 | 1375        | category_1       | FAK         | 2012-06-01 00:00:00.000000 | 61                | 365               | 2012-08-17 11:00:06.598627 | 195.0 | 802        | 736             |<br/>| 2012-06-03 00:00:00.000000 | 337204473 | company_0 | 1375        | category_1       | FAK         | 2012-06-01 00:00:00.000000 | 61                | 365               | 2012-08-17 11:00:06.598627 | 195.0 | 802        | 736             |<br/>| 2012-06-04 00:00:00.000000 | 337204473 | company_0 | 1375        | category_1       | FAK         | 2012-06-01 00:00:00.000000 | 61                | 365               | 2012-08-17 11:00:06.598627 | 195.0 | 802        | 736             |<br/>| 2012-06-05 00:00:00.000000 | 337204473 | company_0 | 1375        | category_1       | FAK         | 2012-06-01 00:00:00.000000 | 61                | 365               | 2012-08-17 11:00:06.598627 | 195.0 | 802        | 736             |</span></pre><p id="b91e" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><strong class="ku io">货运港口表</strong></p><p id="824c" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><strong class="ku io"> pid </strong> : <em class="ms">端口的 id。</em> <br/> <strong class="ku io">名称</strong> : <em class="ms">人类可读的端口名称。</em> <br/> <strong class="ku io">代码</strong>:港口的<em class="ms">代码。</em> <br/> <strong class="ku io">国家</strong> : <em class="ms">港口所在的国家。</em> <br/> <strong class="ku io">纬度</strong> : <em class="ms">港口所在的纬度。</em> <br/> <strong class="ku io">经度</strong> : <em class="ms">港口所在地的经度。</em> <br/> <strong class="ku io">地区</strong> : <em class="ms">港口的地理区域。</em></p><pre class="kd ke kf kg gt mt lr mu bn mv mw bi"><span id="a18a" class="mx lu in lr b be my mz l na nb">| pid | code  | name        | country | latitude         | longitude       | region   |<br/>|-----|-------|-------------|---------|------------------|-----------------|----------|<br/>| 153 | CNCWN | Chiwan      | China   | 22.466666666667  | 113.88333333333 | region_2 |<br/>| 764 | CNDAL | Dalian      | China   | 34.783333333333  | 109.91666666667 | region_2 |<br/>| 405 | CNLYG | Lianyungang | China   | 34.716666666667  | 119.43333333333 | region_2 |<br/>| 266 | CNNBO | Ningbo      | China   | 29.8666666666667 | 121.55          | region_2 |<br/>| 912 | CNNSA | Nansha      | China   | 22.771671        | 113.60848       | region_2 |</span></pre><h2 id="7d06" class="lt lu in bd lv lw lx dn ly lz ma dp mb lb mc md me lf mf mg mh lj mi mj mk ml bi translated">商业问题</h2><blockquote class="nc nd ne"><p id="5a8c" class="ks kt ms ku b kv kw jo kx ky kz jr la nf lc ld le ng lg lh li nh lk ll lm ln ig bi translated">选择 region _ 1-region _ 2 级别中每个始发地-目的地港口对每天的最高每日价格。如果端口对没有某一天的价格，它应该显示为-999。确保您的答案<strong class="ku io">不包含同一地区内的端口对(例如，伊斯坦布尔作为起点，Koper 作为目的地)。</strong></p></blockquote><p id="97a4" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">该问题要求我们提供每个交易日和港口对(始发地-目的地)的最高运费价格报告。此外，它说，如果交易日之间有差距，那么我们将把价格定为-999。下面是我将如何处理这个问题(以及其他 SQL 问题)。如果他们与你不同，请在评论区分享你的方法。</p><ol class=""><li id="ead4" class="ni nj in ku b kv kw ky kz lb nk lf nl lj nm ln nn no np nq bi translated">理解问题，并从问题中确定维度、衡量标准和过滤器/条件。</li><li id="c2bc" class="ni nj in ku b kv nr ky ns lb nt lf nu lj nv ln nn no np nq bi translated">设计你的解决方案，并写一段伪代码说明如何解决这个问题。</li><li id="b902" class="ni nj in ku b kv nr ky ns lb nt lf nu lj nv ln nn no np nq bi translated">为解决方案创建 SQL 语句。</li></ol><h2 id="2331" class="lt lu in bd lv lw lx dn ly lz ma dp mb lb mc md me lf mf mg mh lj mi mj mk ml bi translated">确定维度、度量和过滤器。</h2><p id="b123" class="pw-post-body-paragraph ks kt in ku b kv mm jo kx ky mn jr la lb mo ld le lf mp lh li lj mq ll lm ln ig bi translated">如果您有使用 BI 工具(如 Tableau 和 Metabase)的经验，那么维度、度量和过滤器对您来说应该不是陌生的概念。</p><blockquote class="nc nd ne"><p id="a65b" class="ks kt ms ku b kv kw jo kx ky kz jr la nf lc ld le ng lg lh li nh lk ll lm ln ig bi translated"><strong class="ku io">维度</strong>提供围绕业务流程事件的上下文(如客户名称、产品类型、位置等)。</p><p id="98ad" class="ks kt ms ku b kv kw jo kx ky kz jr la nf lc ld le ng lg lh li nh lk ll lm ln ig bi translated"><strong class="ku io"> Measure </strong>存储可量化的业务数据(如价格、销售、库存等)。</p><p id="6793" class="ks kt ms ku b kv kw jo kx ky kz jr la nf lc ld le ng lg lh li nh lk ll lm ln ig bi translated"><strong class="ku io">过滤器</strong>根据规定的条件分割或限制数据。</p></blockquote><p id="88f1" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">如下所示，从这个问题中，我们可以看到有 2 个维度(交易日和端口对)、1 个度量(具有最大聚合的价格)和 2 个过滤器/条件(从同一地区排除端口对，并将缺失的价格转换为-999)。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nw"><img src="../Images/5f1c3e971765f80f9543aa22f46e0753.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XZ3MCOAILBA9RLY1ADIZjQ.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">按作者、尺寸、测量和过滤器分类的图像。</figcaption></figure><h2 id="13d4" class="lt lu in bd lv lw lx dn ly lz ma dp mb lb mc md me lf mf mg mh lj mi mj mk ml bi translated">解决方案的伪代码。</h2><p id="a3c6" class="pw-post-body-paragraph ks kt in ku b kv mm jo kx ky mn jr la lb mo ld le lf mp lh li lj mq ll lm ln ig bi translated">我的解决方案有 3 个步骤:</p><ol class=""><li id="5e8a" class="ni nj in ku b kv kw ky kz lb nk lf nl lj nm ln nn no np nq bi translated">首先，我们需要从<code class="fe lo lp lq lr b">ports</code>表中获得 port-origin 和 port-destination 的区域名称(以过滤出位于同一区域的端口对)。为了获得这个信息，我们需要将<code class="fe lo lp lq lr b">freight_datapoints</code>表与<code class="fe lo lp lq lr b">freight_ports</code>表连接两次，每次都获得港口起始地区名称和港口目的地地区名称。之后，我们需要过滤数据，使其仅包含作为始发地的<code class="fe lo lp lq lr b">region_1</code>和作为目的地的<code class="fe lo lp lq lr b">region_2</code>。最后，使用最高价格作为衡量标准，在交易日和端口对(维度)级别粒度上聚合数据。为了可读性，我将把这个操作放在一个名为<code class="fe lo lp lq lr b">max_price_per_day</code>的 CTE 中。</li><li id="434a" class="ni nj in ku b kv nr ky ns lb nt lf nu lj nv ln nn no np nq bi translated">其次，为了确定差距(对于每个交易日和港口对)，我首先需要生成一个日期数组，范围从<code class="fe lo lp lq lr b">freight_datapoints</code>表中的最早交易日:<code class="fe lo lp lq lr b">2012–06–01</code>到最大运费日期:<code class="fe lo lp lq lr b">2012–11–15</code>。然后，我将创建这些日期和端口对的组合。我将把这个操作放在一个名为<code class="fe lo lp lq lr b">dates_portpairs_array</code>的 CTE 中。</li><li id="49ea" class="ni nj in ku b kv nr ky ns lb nt lf nu lj nv ln nn no np nq bi translated">最后，为了得出结果，我将使用基于交易日期和端口对的<code class="fe lo lp lq lr b">LEFT JOIN</code>来组合<code class="fe lo lp lq lr b">dates_portpairs_array</code>和<code class="fe lo lp lq lr b">max_price_per_day</code>。价格缺失的记录(<code class="fe lo lp lq lr b">NULL</code> from <code class="fe lo lp lq lr b">max_price_per_day</code>)是缺口，将被转换为-999。</li></ol><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nx"><img src="../Images/c9ddafe3daafa4f8f65306c974444fbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z7kb1Uo8SeMzQZ9GWLULPw.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">作者图片，解决步骤。</figcaption></figure><h2 id="5e55" class="lt lu in bd lv lw lx dn ly lz ma dp mb lb mc md me lf mf mg mh lj mi mj mk ml bi translated">解决方案的 SQL 语句。</h2><p id="91ea" class="pw-post-body-paragraph ks kt in ku b kv mm jo kx ky mn jr la lb mo ld le lf mp lh li lj mq ll lm ln ig bi translated">对于解决方案，由于表存储在 BigQuery 中，所以我将使用 BigQuery 标准 SQL 方言。如果您想继续学习，您可以在这里下载<a class="ae mr" href="https://github.com/Balurc/datasets/tree/main/freight" rel="noopener ugc nofollow" target="_blank">数据集</a>，并将它们上传到您的 BigQuery 数据仓库(获得免费层帐户)。</p><p id="3876" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">下面是对<code class="fe lo lp lq lr b">max_price_per_day</code> <strong class="ku io"> </strong> CTE 的查询。请参考伪代码部分，了解我是如何构建这个查询的。如果您继续执行并运行该查询，现在您应该会看到两个交易日之间有一些间隔。</p><pre class="kd ke kf kg gt mt lr mu bn mv mw bi"><span id="6b45" class="mx lu in lr b be my mz l ny nb">WITH max_price_per_day as(<br/>  SELECT <br/>   DATE(day) as freight_date,<br/>   orig.pid || ' - ' || dest.pid AS orig_dest_port_pair,<br/>   MAX(price) as max_price<br/>  FROM freight.freight_datapoints dp<br/>  INNER JOIN freight.freight_ports orig<br/>   ON dp.origin_pid = orig.pid<br/>  INNER JOIN freight.freight_ports dest<br/>   ON dp.destination_pid = dest.pid<br/>  WHERE orig.region = 'region_1'<br/>    AND dest.region = 'region_2'<br/>  GROUP BY freight_date, orig_dest_port_pair<br/>)</span></pre><p id="7534" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">在 CTE，我使用了 2 个函数；<code class="fe lo lp lq lr b">GENERATE_DATE_ARRAY</code>和<code class="fe lo lp lq lr b">UNNEST</code>。<code class="fe lo lp lq lr b">GENERATE_DATE_ARRAY</code>函数将根据以下参数返回一个日期数组:</p><pre class="kd ke kf kg gt mt lr mu bn mv mw bi"><span id="2a2b" class="mx lu in lr b be my mz l ny nb">-- GENERATE_DATE_ARRAY function Syntax <br/>GENERATE_DATE_ARRAY(start_date, end_date[, INTERVAL INT64_expr date_part])<br/><br/>- start_date must be a DATE<br/>- end_date must be a DATE<br/>- INT64_expr must be an INT64<br/>- date_part must be either DAY, WEEK, MONTH, QUARTER, or YEAR.</span></pre><p id="4ed8" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><code class="fe lo lp lq lr b">UNNEST</code>获取一个数组并返回一个表，该表中的每个元素都有一行。<code class="fe lo lp lq lr b">GENERATE_DATE_ARRAY</code>函数只返回数组格式的日期(单行)，因此我们使用<code class="fe lo lp lq lr b">UNNEST</code>将数组中的每个元素转换成单行。下面是一个如何将两种功能结合使用的示例。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nz"><img src="../Images/02d75555d8464f05defe7aab153ac761.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qxw9MPDvUiS_o_pMiXaYgw.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">图片由作者提供，使用 UNNEST 和 GENERATE_DATE_ARRAY 函数。</figcaption></figure><p id="37ef" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">有了这些之后，我使用 BigQuery 逗号(<code class="fe lo lp lq lr b">UNION ALL</code>)创建了每个日期和端口对的组合。这将生成一个表，其中每个日期都有数据集中每个可用的端口对。这是对 CTE 的查询。</p><pre class="kd ke kf kg gt mt lr mu bn mv mw bi"><span id="707c" class="mx lu in lr b be my mz l ny nb">dates_portpairs_array as (<br/> SELECT *<br/> FROM<br/> (SELECT * FROM UNNEST(GENERATE_DATE_ARRAY('2012-06-01', '2012-11-15', INTERVAL 1 DAY)) dt),<br/> (SELECT DISTINCT orig_dest_port_pair from max_price_per_day)<br/>)</span></pre><p id="375c" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">最终的查询将所有 cte 组合在一起，并使用<code class="fe lo lp lq lr b">COALESCE</code>函数将 missing/ <code class="fe lo lp lq lr b">NULL</code>价格(由于差距)转换为-999。</p><pre class="kd ke kf kg gt mt lr mu bn mv mw bi"><span id="e599" class="mx lu in lr b be my mz l ny nb">SELECT <br/>  dy.dt as freight_date, <br/>  dy.orig_dest_port_pair, <br/>  COALESCE(mx.max_price, -999) as max_price<br/>FROM days dy<br/>LEFT JOIN max_price_per_day mx<br/>  ON dy.dt = mx.freight_date<br/> AND dy.orig_dest_port_pair =  mx.orig_dest_port_pair<br/>ORDER BY dy.dt, dy.orig_dest_port_pair</span></pre><p id="fcff" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">完整的查询如下。</p><pre class="kd ke kf kg gt mt lr mu bn mv mw bi"><span id="84b1" class="mx lu in lr b be my mz l ny nb">WITH max_price_per_day as(<br/>  SELECT <br/>   DATE(day) as freight_date,<br/>   orig.pid || ' - ' || dest.pid AS orig_dest_port_pair,<br/>   MAX(price) as max_price<br/>  FROM freight.freight_datapoints dp<br/>  INNER JOIN freight.freight_ports orig<br/>   ON dp.origin_pid = orig.pid<br/>  INNER JOIN freight.freight_ports dest<br/>   ON dp.destination_pid = dest.pid<br/>  WHERE orig.region = 'region_1'<br/>    AND dest.region = 'region_2'<br/>  GROUP BY freight_date, orig_dest_port_pair<br/>),<br/><br/>dates_portpairs_array as (<br/> SELECT *<br/> FROM<br/> (SELECT * FROM UNNEST(GENERATE_DATE_ARRAY('2012-06-01', '2012-11-15', INTERVAL 1 DAY)) dt),<br/> (SELECT DISTINCT orig_dest_port_pair from max_price_per_day)<br/>)<br/><br/>SELECT <br/>  dy.dt as freight_date, <br/>  dy.orig_dest_port_pair, <br/>  COALESCE(mx.max_price, -999) as max_price<br/>FROM dates_portpairs_array dy<br/>LEFT JOIN max_price_per_day mx<br/>  ON dy.dt = mx.freight_date<br/>   AND dy.orig_dest_port_pair =  mx.orig_dest_port_pair<br/>ORDER BY dy.dt, dy.orig_dest_port_pair</span></pre><p id="cbb2" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">我希望这对你来说是一个有趣的练习，你已经学到了一些新的有价值的东西，可以应用到你的工作中。我知道还有其他方法可以解决这个问题，如果你有，请在评论区告诉我。任何反馈都将不胜感激。</p></div></div>    
</body>
</html>