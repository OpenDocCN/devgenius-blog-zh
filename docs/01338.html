<html>
<head>
<title>JavaScript Best Practices — Spaces, Objects, and Strings</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript 最佳实践—空间、对象和字符串</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/javascript-best-practices-spaces-objects-and-strings-7b9bcdea342f?source=collection_archive---------22-----------------------#2020-06-30">https://blog.devgenius.io/javascript-best-practices-spaces-objects-and-strings-7b9bcdea342f?source=collection_archive---------22-----------------------#2020-06-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/d1802f8e329876d9e3c18c4f5550c843.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*S3umn7IiY-XYKmXU"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@autthaporn?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">autthaporate pradid pong 先生在</a><a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">un plash</a>上拍摄</figcaption></figure><p id="439f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像任何类型的应用程序一样，JavaScript 应用程序也必须写得很好。</p><p id="9a1d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">否则，我们以后会遇到各种问题。</p><p id="96a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究在编写 JavaScript 代码时应该遵循的一些最佳实践。</p><h1 id="b6e0" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">没有用于缩进的混合空间和制表符</h1><p id="3339" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">混合空格和制表符会导致文本编辑器出现问题。</p><p id="63e1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们不应该将它们混合在一起。</p><p id="3f15" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，我们使用 2 个空格，并自动将制表符转换为 2 个空格。</p><h1 id="c887" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">除缩进外，没有多个空格</h1><p id="521c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们只使用 2 个空格作为缩进。</p><p id="6be6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在所有其他地方，我们应该使用一个空间，以避免浪费空间。</p><h1 id="aefc" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">没有将返回对象分配给变量就没有新的</h1><p id="cb11" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果我们用<code class="fe me mf mg mh b">new</code>创建一个新的对象，那么我们应该把它分配给一个变量，这样我们就可以使用它了。</p><p id="6bfb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="0e06" class="mq lc iq mh b gy mr ms l mt mu">new Dog();</span></pre><p id="683e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="9069" class="mq lc iq mh b gy mr ms l mt mu">const dog = new Dog();</span></pre><h1 id="324c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">不要使用函数构造函数</h1><p id="61bb" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们不应该使用<code class="fe me mf mg mh b">Function</code>，它接受函数代码的字符串并返回一个函数。</p><p id="9f21" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在字符串中运行代码是一种安全隐患。</p><p id="7cae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，因为代码在字符串中，所以很难调试和优化。</p><p id="58ba" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们不应该写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="b010" class="mq lc iq mh b gy mr ms l mt mu">const add = new Function('a', 'b', 'return a + b');</span></pre><p id="634a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，我们写道:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="0fb2" class="mq lc iq mh b gy mr ms l mt mu">const add = (a, b) =&gt; a + b;</span></pre><h1 id="354c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">不要使用对象构造函数</h1><p id="22f2" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们不应该使用<code class="fe me mf mg mh b">Object</code>构造函数，因为它不会给我们带来用对象文字创建它们的好处。</p><p id="3ac5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这只会让代码更长。</p><p id="02a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="33d3" class="mq lc iq mh b gy mr ms l mt mu">let foo = new Object();</span></pre><p id="49d2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们应该写道:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="f8f2" class="mq lc iq mh b gy mr ms l mt mu">let foo = {};</span></pre><h1 id="97c2" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">没有新的要求</h1><p id="a5ea" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们不应该把<code class="fe me mf mg mh b">new</code>和<code class="fe me mf mg mh b">require</code>放在一起。</p><p id="0914" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这可能会造成以下两者之间的混淆:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="f931" class="mq lc iq mh b gy mr ms l mt mu">const foo = new require('foo');</span></pre><p id="8dee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以及:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="10da" class="mq lc iq mh b gy mr ms l mt mu">const foo = new (require('foo'));</span></pre><p id="692c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们应该避免这些表达。</p><h1 id="958a" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">不要将符号作为构造函数</h1><p id="c3d9" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe me mf mg mh b">Symbol</code>为出厂功能。它不是构造函数。</p><p id="ccaf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们不应该写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="610f" class="mq lc iq mh b gy mr ms l mt mu">const foo = new Symbol('foo');</span></pre><p id="0f7c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，我们写道:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="820f" class="mq lc iq mh b gy mr ms l mt mu">const foo = Symbol('foo');</span></pre><h1 id="7740" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">没有原始包装实例</h1><p id="6520" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们不应该使用像<code class="fe me mf mg mh b">String</code>或<code class="fe me mf mg mh b">Boolean</code>这样的函数作为构造函数。</p><p id="b7cc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是因为它们返回类型为<code class="fe me mf mg mh b">'object'</code>的值，这很令人困惑。</p><p id="baa8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，代码更长。</p><p id="2dc0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们不应该使用它。</p><p id="6d7a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="a0b5" class="mq lc iq mh b gy mr ms l mt mu">const message = new String('hi');</span></pre><p id="63e3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="9ec5" class="mq lc iq mh b gy mr ms l mt mu">const message = 'hi';</span></pre><p id="d598" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">文字更短，可以消除任何可能出现的混淆。</p><h1 id="29d1" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">不要将全局对象属性称为函数</h1><p id="2529" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们不应该把全局对象属性称为函数。</p><p id="5921" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">他们不应该被召唤。</p><p id="877b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们不应该写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="c430" class="mq lc iq mh b gy mr ms l mt mu">const math = Math();</span></pre><h1 id="e57f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">无八进制文字</h1><p id="a01d" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们不应该写八进制数字文字。</p><p id="601d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们在 JavaScript 中几乎从来没有用处，因为它们以 0 开头，所以我们可能会将其与十进制数字混淆。</p><p id="d990" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们不应该写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="d338" class="mq lc iq mh b gy mr ms l mt mu">const octal = 042;</span></pre><p id="7d7d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，我们写道:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="c439" class="mq lc iq mh b gy mr ms l mt mu">const decimal = 34;</span></pre><h1 id="010e" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">没有八进制转义序列</h1><p id="d32f" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们的代码中不应该有八进制转义序列。</p><p id="7ce9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们没有用，拥有它们可能是个错误。</p><p id="f082" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们不应该写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="607b" class="mq lc iq mh b gy mr ms l mt mu">const foo = 'foo \251'</span></pre><p id="eb8a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，我们写道:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="8195" class="mq lc iq mh b gy mr ms l mt mu">const foo = 'foo';</span></pre><h1 id="4159" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用 __dirname 或 __filename 时没有字符串串联</h1><p id="e89b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们应该使用<code class="fe me mf mg mh b">path.join</code>来连接路径，这样我们就可以在所有操作系统中正确地使用路径。</p><p id="48a2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，代替书写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="1cf9" class="mq lc iq mh b gy mr ms l mt mu">const pathToFile = __dirname + '/foo.js'</span></pre><p id="41d7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="3423" class="mq lc iq mh b gy mr ms l mt mu">const pathToFile = path.join(__dirname, 'foo.js')</span></pre><h1 id="d234" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">不要使用 __proto__</h1><p id="6ea6" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如<code class="fe me mf mg mh b">__</code>字符所示，<code class="fe me mf mg mh b">__proto__</code>属性并不意味着被直接访问。</p><p id="5e36" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，我们应该使用<code class="fe me mf mg mh b">Object.getPrototypeOf</code>方法来获取对象的原型。</p><p id="739a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们不应该写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="b2c2" class="mq lc iq mh b gy mr ms l mt mu">const foo = obj.__proto__;</span></pre><p id="692e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是我们应该写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="ac32" class="mq lc iq mh b gy mr ms l mt mu">const foo = Object.getPrototypeOf(obj);</span></pre><h1 id="372c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">不要重新声明变量</h1><p id="345f" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们不应该在代码中重新声明变量。</p><p id="0020" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们在同一个作用域中声明了两个同名的变量，我们会得到一个错误。</p><p id="a4b6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，我们应该给现有的同名变量重新赋值。</p><p id="c34d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不要写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="0420" class="mq lc iq mh b gy mr ms l mt mu">let name = 'james';<br/>let name = 'joe';</span></pre><p id="8e6e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="4eb1" class="mq lc iq mh b gy mr ms l mt mu">let name = 'james';<br/>name = 'joe';</span></pre><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/7073e72dfee5fc4a8b95eff92fe159a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*eI4-G_DydahzGZZR"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@behz?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">贝扎德·加法尔安</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="2355" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="3573" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们不应该在同一个范围内声明同名的变量。</p><p id="7f1f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，我们应该用<code class="fe me mf mg mh b">getPrototypeOf</code>的方法得到一个物体的原型。</p><p id="5687" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还应该注意 JavaScript 代码的间距。</p></div></div>    
</body>
</html>