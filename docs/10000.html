<html>
<head>
<title>Graph Modeling in PySpark using GraphFrames: Part 3 - Finding Paths</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 GraphFrames 在 PySpark 中进行图形建模:第 3 部分——查找路径</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/graph-modeling-in-pyspark-using-graphframes-part-3-finding-paths-2fdd74920f1b?source=collection_archive---------5-----------------------#2022-09-28">https://blog.devgenius.io/graph-modeling-in-pyspark-using-graphframes-part-3-finding-paths-2fdd74920f1b?source=collection_archive---------5-----------------------#2022-09-28</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="647d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是多部分教程的第 2 部分，在本教程中，我们将研究一些使用图算法寻找路径的方法。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/5c4c9b250f1614a6a56a706c318c4560.png" data-original-src="https://miro.medium.com/v2/resize:fit:1022/format:webp/0*hzk8BEfy7WcLmhWt.jpg"/></div></figure><blockquote class="kq kr ks"><p id="83be" class="jk jl kt jm b jn jo jp jq jr js jt ju ku jw jx jy kv ka kb kc kw ke kf kg kh ig bi translated">如果您还没有阅读本教程的第 1 部分，我强烈建议您在跳到这里之前先阅读第 1 部分。如果您对图形框架有所了解，可以跳过第 1 部分</p><p id="e0b4" class="jk jl kt jm b jn jo jp jq jr js jt ju ku jw jx jy kv ka kb kc kw ke kf kg kh ig bi translated"><a class="ae kx" href="https://sharmashorya1996.medium.com/graph-modeling-in-pyspark-using-graphframes-part-1-e7cb42099182" rel="noopener">https://sharmashorya 1996 . medium . com/graph-modeling-in-py spark-using-graph frames-part-1-e7cb 42099182</a></p></blockquote><p id="dd4b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们将使用“交通数据集”,在该数据集上，我们将找到城市之间的路径以及与旅行相关的成本。</p><p id="e82e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们从常见的步骤开始</p><pre class="kj kk kl km gt ky kz la lb aw lc bi"><span id="c3c0" class="ld le in kz b gy lf lg l lh li">import os<br/>import sys<br/>import glob<br/>from os.path import abspath<br/>os.environ['SPARK_HOME'] = 'C:\spark-3.1.2-bin-hadoop3.2'<br/>os.environ['JAVA_HOME'] = 'C:\Program Files\Java\jdk1.8.0_201'<br/>os.environ['HADOOP_HOME'] = 'C:\spark-3.1.2-bin-hadoop3.2'<br/>spark_python = os.path.join(os.environ.get('SPARK_HOME',None),'python')<br/>py4j = glob.glob(os.path.join(spark_python,'lib','py4j-*.zip'))[0]<br/>graphf = glob.glob(os.path.join(spark_python,'graphframes.zip'))[0]<br/>sys.path[:0]=[spark_python,py4j]<br/>sys.path[:0]=[spark_python,graphf]<br/>os.environ['PYTHONPATH']=py4j+os.pathsep+graphf<br/>import findspark<br/>findspark.init()<br/>findspark.find()<br/>from pyspark.sql import SparkSession<br/>spark = SparkSession.builder.appName("Spark Examples").enableHiveSupport().getOrCreate()</span><span id="3056" class="ld le in kz b gy lj lg l lh li">from graphframes import *<br/>import networkx as nx<br/>import matplotlib.pyplot as plt</span></pre><p id="c5fe" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在让我们导入数据集</p><pre class="kj kk kl km gt ky kz la lb aw lc bi"><span id="59fa" class="ld le in kz b gy lf lg l lh li">transport_nodes = spark.read.format("csv").option("inferSchema", "true").option("header", "true").load("transport-nodes.csv")<br/>transport_nodes.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lk"><img src="../Images/c284cd287c21d6e3472bfe89b93787de.png" data-original-src="https://miro.medium.com/v2/resize:fit:692/format:webp/1*xdyno8w9Z6ar_BxkNXVuBQ.png"/></div></figure><pre class="kj kk kl km gt ky kz la lb aw lc bi"><span id="002f" class="ld le in kz b gy lf lg l lh li">transport_relationships = spark.read.format("csv").option("inferSchema", "true").option("header", "true").load("transport-relationships.csv")<br/>transport_relationships.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ll"><img src="../Images/0f1f15b9103c11c82c3a6d4642828154.png" data-original-src="https://miro.medium.com/v2/resize:fit:726/format:webp/1*cYRmgE7csQ0I-yG3hZ8gag.png"/></div></figure><p id="d016" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在让我们使用我们在第 1 部分中创建的函数来绘制有向图</p><pre class="kj kk kl km gt ky kz la lb aw lc bi"><span id="d498" class="ld le in kz b gy lf lg l lh li"># the function will plot the source and destination nodes and connect them by meand of undirected line<br/>def plot_directed_graph(edge_list):<br/>    plt.figure(figsize=(9,9))<br/>    gplot=nx.DiGraph()<br/>    edge_labels = {}<br/>    for row in edge_list.select("src", "dst", "cost").take(1000):<br/>        gplot.add_edge(row["src"], row["dst"])<br/>        edge_labels[(row["src"], row["dst"])] = row["cost"]<br/>    pos = nx.spring_layout(gplot)<br/>    nx.draw(gplot, pos, with_labels=True, font_weight="bold", node_size=3500)<br/>    nx.draw_networkx_edge_labels(gplot, pos, edge_labels=edge_labels, font_color="green", font_size=11, font_weight="bold")</span></pre><p id="2961" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们初始化图形框架并绘制它</p><pre class="kj kk kl km gt ky kz la lb aw lc bi"><span id="aa12" class="ld le in kz b gy lf lg l lh li">route = GraphFrame(transport_nodes, transport_relationships)<br/>plot_directed_graph(route.edges)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lm"><img src="../Images/302fe2ec6b504e73130289b7fe95558f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1238/format:webp/1*O1y4cBCqlLZhHIMbY3h6Ww.png"/></div></figure><p id="c54f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们应用 BFS 和最短路径函数来获得路径。</p><h2 id="cd8e" class="ld le in bd ln lo lp dn lq lr ls dp lt jv lu lv lw jz lx ly lz kd ma mb mc md bi translated">广度优先搜索</h2><p id="a3ef" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">让我们找到豪达和乌得勒支之间的路径</p><pre class="kj kk kl km gt ky kz la lb aw lc bi"><span id="c0f9" class="ld le in kz b gy lf lg l lh li">#BFS</span><span id="969e" class="ld le in kz b gy lj lg l lh li">filtered_paths = route.bfs("id = 'Gouda'", "id = 'Utrecht'")<br/>filtered_paths.show(truncate=False)<br/>filtered_paths.count()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/e63d18a2020dedde0040bd320ecda72f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1272/format:webp/1*xFN6_1yIS4FotwPXpQH5iA.png"/></div></figure><p id="56c2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">结果中只显示了一条边，这意味着在我们的图表中，这两个地方实际上有直接的联系。</p><p id="a410" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们以豪达的 BFS 为起点，费利克斯托为终点，</p><pre class="kj kk kl km gt ky kz la lb aw lc bi"><span id="b17f" class="ld le in kz b gy lf lg l lh li">#BFS</span><span id="53b5" class="ld le in kz b gy lj lg l lh li">filtered_paths = route.bfs("id = 'Gouda'", "id = 'Felixstowe'")<br/>filtered_paths.show(truncate=False)<br/>filtered_paths.count()</span></pre><p id="21f6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">结果是这些节点之间没有路径。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/538362f2a8fb600ed68127dd53229093.png" data-original-src="https://miro.medium.com/v2/resize:fit:488/format:webp/1*Ar5_kaRdT8FxutqvOOh88Q.png"/></div></figure><p id="f796" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们找出阿姆斯特丹和费利克斯托之间的路径，我们知道它们之间没有直接的路径，</p><pre class="kj kk kl km gt ky kz la lb aw lc bi"><span id="07fd" class="ld le in kz b gy lf lg l lh li">#BFS</span><span id="de3d" class="ld le in kz b gy lj lg l lh li">filtered_paths = route.bfs("id = 'Amsterdam'", "id = 'Felixstowe'")<br/>filtered_paths.show(truncate=False)<br/>filtered_paths.count()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi ml"><img src="../Images/708c1f3c0464bdcbb9d4aaa2e803f32e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x32HsQ0re4ERylveQLMQSQ.png"/></div></div></figure><p id="5f9c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们提供给 BFS 的两个参数实际上可以匹配多个节点，并且我们不限于基于 id 进行过滤。</p><pre class="kj kk kl km gt ky kz la lb aw lc bi"><span id="f4d4" class="ld le in kz b gy lf lg l lh li">#BFS</span><span id="5d06" class="ld le in kz b gy lj lg l lh li">filtered_paths = route.bfs("id = 'Amsterdam'", "population &lt; 500000")<br/>filtered_paths.show(truncate=False)<br/>filtered_paths.count()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi mq"><img src="../Images/0d8c973f1e778d9233be28f6995cf4ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5mwd0ObrICEh-B9A0iTnGQ.png"/></div></div></figure><p id="324d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">虽然我们在阿姆斯特丹和有人口的节点之间有 2 个以上的连接&lt; 500000, only 2 nodes showed up because BFS considers the number of Hops, and all other connections were indirect.</p><p id="7a1a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">This time let’s look for the shortest path by specifying a maxPathLength parameter.</p><pre class="kj kk kl km gt ky kz la lb aw lc bi"><span id="1028" class="ld le in kz b gy lf lg l lh li">#BFS</span><span id="40f4" class="ld le in kz b gy lj lg l lh li">filtered_paths = route.bfs("id = 'Amsterdam'", "id = 'London'", maxPathLength=5)<br/>filtered_paths.show(truncate=False)<br/>filtered_paths.count()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi mr"><img src="../Images/fb1e811982bd23ecade548b84caade14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pImD_ulWhUD-51ylH57DPQ.png"/></div></div></figure><p id="7956" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">To find the shortest path from all connected nodes to a specific node in our graph, we can make use of the shortest path function.</p><h2 id="5c56" class="ld le in bd ln lo lp dn lq lr ls dp lt jv lu lv lw jz lx ly lz kd ma mb mc md bi translated">Shortest paths function</h2><pre class="kj kk kl km gt ky kz la lb aw lc bi"><span id="f1f9" class="ld le in kz b gy lf lg l lh li"># shortest path</span><span id="38d0" class="ld le in kz b gy lj lg l lh li">filtered_paths = route.shortestPaths(landmarks=["Ipswich"])</span><span id="8505" class="ld le in kz b gy lj lg l lh li">filtered_paths.show(truncate=False)<br/>filtered_paths.count()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/dd9cb772ecf906d7fc4d336307a44cd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:992/format:webp/1*1leh-8Fnp0pTh-GcOrpmng.png"/></div></figure><p id="f2c9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">This brings us to the end of this part, In the next and the final part of this series we will look into some other graph algorithms.</p></div><div class="ab cl mt mu hr mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ig ih ii ij ik"><p id="3510" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">The code and datasets for this tutorial are present at :</p><div class="na nb gp gr nc nd"><a href="https://github.com/shorya1996/PySpark/blob/main/GettingStartedWithGraphFramesPart3.ipynb" rel="noopener  ugc nofollow" target="_blank"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd io gy z fp ni fr fs nj fu fw im bi translated">PySpark/GettingStartedWithGraphFramesPart3.ipynb at main · shorya1996/PySpark</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">The repository contains examples of various pyspark tips and tricks - PySpark/GettingStartedWithGraphFramesPart3.ipynb…</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">github.com</p></div></div><div class="nm l"><div class="nn l no np nq nm nr ko nd"/></div></div></a></div><p id="a31e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">在 Linkedin 上关注我</strong></p><p id="2b4f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">【领英:<a class="ae kx" href="https://www.linkedin.com/in/shorya-sharma-b94161121/" rel="noopener ugc nofollow" target="_blank"><strong class="jm io">https://www.linkedin.com/in/shorya-sharma-b94161121</strong></a>【领英】</p></div></div>    
</body>
</html>