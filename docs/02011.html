<html>
<head>
<title>JavaScript Best Practices — Spread, Rest, and Promises</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript 最佳实践—传播、休息和承诺</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/javascript-best-practices-spread-rest-and-promises-b7b0663ef5c7?source=collection_archive---------22-----------------------#2020-07-16">https://blog.devgenius.io/javascript-best-practices-spread-rest-and-promises-b7b0663ef5c7?source=collection_archive---------22-----------------------#2020-07-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/1a8fec408667e2aea1064f05455a412d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vNTSg16GhKzaf6xu"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">克里斯·莱佩尔特在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="c292" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了使代码易于阅读和维护，我们应该遵循一些最佳实践。</p><p id="0f90" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这篇文章中，我们将看看我们应该遵循的一些最佳实践，以使每个人的生活更轻松。</p><h1 id="7325" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">用正则表达式文字代替<code class="fe lz ma mb mc b">RegExp</code>构造函数的使用</h1><p id="8d23" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">正则表达式文字比使用<code class="fe lz ma mb mc b">RegExp</code>构造函数要短得多。</p><p id="28e0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们应该用它们来支持构造函数。</p><p id="c60a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="54ca" class="mq lc iq mc b gy mr ms l mt mu">new RegExp("^\\d\\.$");</span></pre><p id="77d1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="c87f" class="mq lc iq mc b gy mr ms l mt mu">/^\\d\\.$"/</span></pre><h1 id="4cac" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用 Rest 参数代替<code class="fe lz ma mb mc b">arguments</code></h1><p id="0bd9" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lz ma mb mc b">argyments</code>对象不支持箭头函数，也不是数组。</p><p id="ccd7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Rest 参数返回一个参数数组。</p><p id="a66d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们应该用那个来代替。</p><p id="a05d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="c82d" class="mq lc iq mc b gy mr ms l mt mu">function foo() {<br/>  console.log(arguments);<br/>}</span></pre><p id="805b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="df02" class="mq lc iq mc b gy mr ms l mt mu">function foo(...args) {<br/>  console.log(args);<br/>}</span></pre><h1 id="a85f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用扩展语法代替<code class="fe lz ma mb mc b">.apply()</code></h1><p id="8cbb" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">我们应该使用 spread 语法而不是<code class="fe lz ma mb mc b">apply</code>。</p><p id="ff23" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="f5bc" class="mq lc iq mc b gy mr ms l mt mu">const args = [1, 2, 3, 100, 200];<br/>Math.max.apply(Math, args);</span></pre><p id="311a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="6cb9" class="mq lc iq mc b gy mr ms l mt mu">const args = [1, 2, 3, 100, 200];<br/>Math.max(...args);</span></pre><p id="0d0b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们不需要<code class="fe lz ma mb mc b">apply</code>，除非我们想改变<code class="fe lz ma mb mc b">this</code>的值。</p><h1 id="60af" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用模板文本而不是字符串串联</h1><p id="57c9" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">我们应该使用模板文字而不是字符串连接。</p><p id="acae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在模板文字中包含表达式要容易得多。</p><p id="f0fb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="660c" class="mq lc iq mc b gy mr ms l mt mu">const str = "hello, " + name + "!";</span></pre><p id="26b2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="2f9e" class="mq lc iq mc b gy mr ms l mt mu">const str = `hello, ${name}!`;</span></pre><h1 id="d7b2" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">返回每个<code class="fe lz ma mb mc b">then()</code>内部，创建可读和可重用的承诺链</h1><p id="2ab6" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">如果我们想在承诺上调用<code class="fe lz ma mb mc b">then</code>，我们应该返回一些东西。</p><p id="791b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="7b3c" class="mq lc iq mc b gy mr ms l mt mu">myPromise.then(() =&gt; {<br/>  doSomething()<br/>})</span></pre><p id="aeec" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="1f9e" class="mq lc iq mc b gy mr ms l mt mu">myPromise.then(() =&gt; {<br/>  return doSomething()<br/>})</span></pre><h1 id="2f5a" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">对未退回的承诺使用<code class="fe lz ma mb mc b">catch()</code></h1><p id="8f7c" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">我们应该在未返回的承诺上使用<code class="fe lz ma mb mc b">catch</code>来捕捉它们发生的任何错误。</p><p id="495c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="7427" class="mq lc iq mc b gy mr ms l mt mu">myPromise<br/>  .then(doSomething)<br/>  .then(doMore)<br/>  .catch(errors)</span></pre><p id="db64" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">其中<code class="fe lz ma mb mc b">errors</code>是一个回调函数，用于捕获承诺中出现的任何错误。</p><h1 id="ef74" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">确保在 ES5 环境中使用之前创建一个<code class="fe lz ma mb mc b">Promise</code>构造函数</h1><p id="82e3" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lz ma mb mc b">Promise</code>构造函数是在 ES6 中引入的。</p><p id="31b6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以任何用旧版本 ES 编写的代码都必须使用 promise 库来创建承诺。</p><p id="eb29" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="25eb" class="mq lc iq mc b gy mr ms l mt mu">const x = Promise.resolve('foo');</span></pre><p id="e5e7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="8ed9" class="mq lc iq mc b gy mr ms l mt mu">const Promise = require('bluebird');<br/>const x = Promise.resolve('foo');</span></pre><h1 id="0991" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">没有嵌套的<code class="fe lz ma mb mc b">then()</code>或<code class="fe lz ma mb mc b">catch() S</code>语句</h1><p id="a437" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">我们应该避免嵌套的<code class="fe lz ma mb mc b">then</code>或<code class="fe lz ma mb mc b">catch</code>语句。</p><p id="4df7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="6633" class="mq lc iq mc b gy mr ms l mt mu">myPromise.then(val =&gt;<br/>  doWork(val).then(doMore)<br/>)</span></pre><p id="0f66" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="7d35" class="mq lc iq mc b gy mr ms l mt mu">myPromise<br/>  .then(doWork)<br/>  .then(doMore)<br/>  .catch(errors)</span></pre><h1 id="4c98" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">避免在 Promise 静态方法上使用<code class="fe lz ma mb mc b">new</code></h1><p id="4eb0" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">如果我们正在调用<code class="fe lz ma mb mc b">Promise</code>静态方法，那么我们不应该'；使用<code class="fe lz ma mb mc b">new</code>关键字。</p><p id="fd54" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="869e" class="mq lc iq mc b gy mr ms l mt mu">new Promise.resolve(value)<br/>new Promise.reject(error)<br/>new Promise.race([foo, bar])<br/>new Promise.all([foo, bar])</span></pre><p id="c248" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="4817" class="mq lc iq mc b gy mr ms l mt mu">Promise.resolve(value)<br/>Promise.reject(error)<br/>Promise.race([foo, bar])<br/>Promise.all([foo, bar])</span></pre><h1 id="ebbb" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><code class="fe lz ma mb mc b">finally()</code>中没有退货单</h1><p id="6670" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lz ma mb mc b">finally</code>中的<code class="fe lz ma mb mc b">return</code>语句是无用的，因为没有什么会消耗结果。</p><p id="a343" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，与其写:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="9c8d" class="mq lc iq mc b gy mr ms l mt mu">myPromise.finally((val) =&gt; {<br/>  return val<br/>})</span></pre><p id="0545" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="cbbe" class="mq lc iq mc b gy mr ms l mt mu">myPromise.finally((val) =&gt; {<br/>  console.log(val)<br/>})</span></pre><h1 id="993f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">不需要时，<code class="fe lz ma mb mc b">Promise.resolve</code>或<code class="fe lz ma mb mc b">Promise.reject</code>中没有包装值</h1><p id="a114" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">当不需要值时，我们不应该将它们包装在<code class="fe lz ma mb mc b">Promise.resolve</code>或<code class="fe lz ma mb mc b">Promis.reject</code>中。</p><p id="793b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="a103" class="mq lc iq mc b gy mr ms l mt mu">myPromise.then((val) =&gt; {<br/>  return Promise.resolve(val * 3);<br/>})<br/>myPromise.then((val) =&gt; {<br/>  return Promise.reject('foo');<br/>})</span></pre><p id="276a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="bc5b" class="mq lc iq mc b gy mr ms l mt mu">myPromise.then((val) =&gt; {<br/>  return val * 3<br/>})<br/>myPromise.then((val) =&gt; {<br/>  throw 'foo'<br/>})</span></pre><p id="600f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lz ma mb mc b">return</code>将返回一个承诺，其中解析值为返回值。</p><p id="0519" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lz ma mb mc b">throw</code>会拒绝给定值的承诺。</p><h1 id="614d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">创建新承诺时保持一致的参数名称</h1><p id="7376" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">在创建新的承诺时，我们应该有一致的参数名。</p><p id="a539" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样，他们做什么就不会有任何混淆。</p><p id="811b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="a511" class="mq lc iq mc b gy mr ms l mt mu">new Promise((reject, resolve) =&gt; { ... })</span></pre><p id="9f7f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">其功能顺序错误，或者:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="d07a" class="mq lc iq mc b gy mr ms l mt mu">new Promise((ok, fail) =&gt; { ... })</span></pre><p id="b494" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有不标准的名字，我们写:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="3f7e" class="mq lc iq mc b gy mr ms l mt mu">new Promise((resolve, reject) =&gt; { ... })</span></pre><h1 id="4b5b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">与回调模式相比，更喜欢异步/等待模式</h1><p id="b29b" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lz ma mb mc b">async</code>和<code class="fe lz ma mb mc b">await</code>比回调模式短，所以我们可以起诉。</p><p id="0cc8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="e292" class="mq lc iq mc b gy mr ms l mt mu">myPromise<br/>  .then((val) =&gt; {<br/>    return foo();<br/>  })<br/>  .then((val) =&gt; {<br/>    return bar();<br/>  })<br/>  .then((val) =&gt; {<br/>    return val;<br/>  })</span></pre><p id="365b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="5cf8" class="mq lc iq mc b gy mr ms l mt mu">const foo = async () =&gt; {<br/>  const val1 = await myPromise;<br/>  const val2 = await foo();<br/>  const val3 = await bar();<br/>  return va3;<br/>}</span></pre><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/0357297c1e0b7402a7c144d7ffb95355.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*swSM2UbaMOdNc3dl"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">克里斯蒂娜·安妮·科斯特洛在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="d7b0" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="0d8c" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">我们应该用 spread 和 rest 代替<code class="fe lz ma mb mc b">apply</code>和<code class="fe lz ma mb mc b">arguments</code>。</p><p id="8a4b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">承诺可以用很多方法来清理。</p></div></div>    
</body>
</html>