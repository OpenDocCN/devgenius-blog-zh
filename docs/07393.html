<html>
<head>
<title>Object-Oriented Programming in Python — Understanding Methods</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 中的面向对象编程——理解方法</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/object-oriented-programming-in-python-understanding-methods-6a542dad1fee?source=collection_archive---------11-----------------------#2022-03-21">https://blog.devgenius.io/object-oriented-programming-in-python-understanding-methods-6a542dad1fee?source=collection_archive---------11-----------------------#2022-03-21</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="63fd" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">理解 Python 类中不同类型的方法以及如何使用它们</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/ebbe0716ced053ecc7310f4e845dc75b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wiZVlJA6f9QecYSu"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">Todd Quackenbush 在<a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="0fa7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在上一篇文章中，我讨论了关于<em class="lp">变量</em>——一个<em class="lp">类</em>的两个基本构件之一。在这篇文章中，我们将讨论另一个构建模块— <em class="lp">方法</em>。如果你需要复习一下<em class="lp">变量</em>，你可以看看我之前的帖子——<a class="ae ks" href="https://curious-joe.net/post/2202-03-16-oop-python-variables-in-class/oop-python-inheritance-subclass/" rel="noopener ugc nofollow" target="_blank">Python 中的面向对象编程——理解变量</a>。</p><h1 id="feb1" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">方法入门</h1><blockquote class="mi"><p id="bd30" class="mj mk in bd ml mm mn mo mp mq mr lo dk translated"><em class="ms">方法</em>是嵌入在类<em class="ms">中的函数。</em></p></blockquote><p id="ab4d" class="pw-post-body-paragraph kt ku in kv b kw mt jo ky kz mu jr lb lc mv le lf lg mw li lj lk mx lm ln lo ig bi translated"><em class="lp">方法</em>必须至少有一个参数。没有所谓的无参数<em class="lp">方法</em>。通常情况下，<code class="fe my mz na nb b">self</code>被用作不需要任何自定义参数的<em class="lp">方法</em>中的参数。<code class="fe my mz na nb b">self</code>是指<em class="lp">对象</em>，为其调用<em class="lp">方法</em>，并使<em class="lp">对象的</em> <em class="lp">变量</em>和<em class="lp">方法</em>可供该方法使用。使用<code class="fe my mz na nb b">self</code>这个词是一种通常被遵循的规范。所以即使<code class="fe my mz na nb b">self</code>可以用其他任何词代替，这样做也会增加不必要的惊喜。</p><h1 id="13e3" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">情况</h1><p id="910c" class="pw-post-body-paragraph kt ku in kv b kw nc jo ky kz nd jr lb lc ne le lf lg nf li lj lk ng lm ln lo ig bi translated">假设我们成功交付了第一个简单的项目，创建了一个能够添加和删除元素的列表，我们已经有了一个新客户。他想要一个类似的列表，但是有一个稍微严格的要求——他想将元素的类型限制为数字类型。</p><p id="18d5" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">因为基本要求仍然相同:</p><ul class=""><li id="bd25" class="nh ni in kv b kw kx kz la lc nj lg nk lk nl lo nm nn no np bi translated">这是一份名单，</li><li id="e10d" class="nh ni in kv b kw nq kz nr lc ns lg nt lk nu lo nm nn no np bi translated">应该能够添加和删除元素，</li><li id="d051" class="nh ni in kv b kw nq kz nr lc ns lg nt lk nu lo nm nn no np bi translated">并显示整个列表，</li></ul><p id="c6e9" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们将重用我们之前创建的类<code class="fe my mz na nb b">NumList</code>，并使用名为<code class="fe my mz na nb b">StrictNumList</code>的<em class="lp">子类</em>来构建它。在<code class="fe my mz na nb b">StrictNumList</code>中我们可以看到已经定义了两个<em class="lp">方法</em>:<code class="fe my mz na nb b">__check_value()</code>和<code class="fe my mz na nb b">add_value()</code>。稍后将提供更多相关信息。</p><pre class="kd ke kf kg gt nv nb nw nx aw ny bi"><span id="9e2c" class="nz lr in nb b gy oa ob l oc od">class NumList:<br/>    def __init__(self, name = ""):<br/>        self.instName = name<br/>        self.__list = [] <br/>    <br/>    def add_value(self, val):<br/>        self.__list.append(val)<br/>    <br/>    def remove_value(self):<br/>        rv = self.__list[-1]<br/>        del self.__list[-1]<br/>        return rv<br/>    <br/>    def get_list(self):<br/>        return self.__list</span><span id="b78e" class="nz lr in nb b gy oe ob l oc od">class StrictNumList(NumList):<br/>    def __init__(self, name):<br/>        super().__init__(name)<br/>        <br/>    def __check_value(self, val):<br/>        return str(val).isalpha()<br/>            <br/>    def add_value(self, val):<br/>        if not self.__check_value(val):<br/>            super().add_value(val)<br/>        else: <br/>            input_val = input("Insert a number: ")<br/>            val = float(input_val)<br/>            super().add_value(val)</span><span id="7b7a" class="nz lr in nb b gy oe ob l oc od">sl01 = StrictNumList(name = "Number List B1")<br/>sl01.instName<br/>sl01.add_value(2)<br/>sl01.add_value("abc")</span><span id="380e" class="nz lr in nb b gy oe ob l oc od">Insert a number: 5</span><span id="554a" class="nz lr in nb b gy oe ob l oc od">sl01.get_list()</span><span id="61bd" class="nz lr in nb b gy oe ob l oc od">[2, 5.0]</span></pre><h1 id="7e97" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">构造函数——一种特殊的方法</h1><p id="df6a" class="pw-post-body-paragraph kt ku in kv b kw nc jo ky kz nd jr lb lc ne le lf lg nf li lj lk ng lm ln lo ig bi translated"><code class="fe my mz na nb b">__init__</code>或 Python <em class="lp">构造函数</em>是一种特殊的<em class="lp">方法</em>，用于初始化<em class="lp">类</em>。</p><ul class=""><li id="1938" class="nh ni in kv b kw kx kz la lc nj lg nk lk nl lo nm nn no np bi translated">它在每次实例化<em class="lp">类</em>时运行，并使<em class="lp">类</em>可用。</li><li id="6037" class="nh ni in kv b kw nq kz nr lc ns lg nt lk nu lo nm nn no np bi translated">它必须至少有一个参数— <code class="fe my mz na nb b">self</code>才能使<em class="lp">对象</em>的属性可用。</li><li id="a88c" class="nh ni in kv b kw nq kz nr lc ns lg nt lk nu lo nm nn no np bi translated">与其他方法不同，<code class="fe my mz na nb b">__init__</code>不能返回值或者不能在<em class="lp">类</em>的内部或外部被调用。例如，你不能创建像&lt; <code class="fe my mz na nb b">object name</code> &gt; &lt; <code class="fe my mz na nb b">.</code> &gt; <code class="fe my mz na nb b">__init__()</code>这样的调用方法。</li></ul><h1 id="bd93" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">方法的类型</h1><p id="fda9" class="pw-post-body-paragraph kt ku in kv b kw nc jo ky kz nd jr lb lc ne le lf lg nf li lj lk ng lm ln lo ig bi translated">像<em class="lp">变量</em>，<em class="lp">方法</em>可以是公共的或者私有的，或者更好地称为<em class="lp">部分</em>私有的(还记得<em class="lp">的名字吗？).</em></p><h2 id="1f75" class="nz lr in bd ls of og dn lw oh oi dp ma lc oj ok mc lg ol om me lk on oo mg op bi translated">私有方法</h2><ul class=""><li id="5f6f" class="nh ni in kv b kw nc kz nd lc oq lg or lk os lo nm nn no np bi translated">命名私有<em class="lp">方法</em>遵循与私有<em class="lp">变量</em>相同的模式——在方法名前添加两个下划线(<code class="fe my mz na nb b">__</code>)。</li><li id="05d3" class="nh ni in kv b kw nq kz nr lc ns lg nt lk nu lo nm nn no np bi translated">名称操纵与<em class="lp">类</em>名称的工作方式与它与<em class="lp">变量</em>的工作方式相同。</li></ul></div><div class="ab cl ot ou hr ov" role="separator"><span class="ow bw bk ox oy oz"/><span class="ow bw bk ox oy oz"/><span class="ow bw bk ox oy"/></div><div class="ig ih ii ij ik"><p id="8810" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="lp">为什么要用私有方法？</em></p><p id="b423" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">使用私有<em class="lp">变量</em>的原因相同。创建这些<em class="lp">方法</em>的主要原因是为了在其他<em class="lp">方法</em>中使用，因此它们不需要从<em class="lp">对象</em>中直接访问。</p></div><div class="ab cl ot ou hr ov" role="separator"><span class="ow bw bk ox oy oz"/><span class="ow bw bk ox oy oz"/><span class="ow bw bk ox oy"/></div><div class="ig ih ii ij ik"><p id="7181" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">但是正如我们从上一篇博客中所知道的，名称篡改实际上使它们变得可用。所以使用这个被破坏的名字，我们实际上也可以访问私有的<em class="lp">方法</em>。</p><p id="8c5b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在我们的示例类<code class="fe my mz na nb b">StrictNumList</code>中，我们创建了<code class="fe my mz na nb b">__check_value()</code>作为私有<em class="lp">方法</em>。因为它的主要用途是在<code class="fe my mz na nb b">add_value()</code>方法内部使用。但是，请检查下面的代码，看看我们如何仍然可以使用损坏的名称访问这个方法！</p><pre class="kd ke kf kg gt nv nb nw nx aw ny bi"><span id="fbf7" class="nz lr in nb b gy oa ob l oc od"># calling private method - __check_value() using its mangled name <br/>sl01._StrictNumList__check_value('5.5')</span><span id="8317" class="nz lr in nb b gy oe ob l oc od">False</span></pre><h2 id="ac5f" class="nz lr in bd ls of og dn lw oh oi dp ma lc oj ok mc lg ol om me lk on oo mg op bi translated">公共方法</h2><p id="80ff" class="pw-post-body-paragraph kt ku in kv b kw nc jo ky kz nd jr lb lc ne le lf lg nf li lj lk ng lm ln lo ig bi translated">公共<em class="lp">方法</em>可以使用点符号直接从<em class="lp">对象</em>中访问，即&lt;<code class="fe my mz na nb b">object name</code>&gt;&lt;<code class="fe my mz na nb b">.</code>&gt;&lt;<code class="fe my mz na nb b">method name</code>&gt;。在我们的例子中，<code class="fe my mz na nb b">add_value()</code>是一个公共变量。</p><p id="7eca" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">🛑但是请注意我们是如何在<em class="lp">超</em>和<em class="lp">子类</em>中定义这个方法的。这叫做<em class="lp">方法覆盖</em>。</p><blockquote class="mi"><p id="4a5b" class="mj mk in bd ml mm mn mo mp mq mr lo dk translated"><em class="ms">当你在子类中不同地定义相同的方法时，方法覆盖发生。</em></p></blockquote><p id="4bd8" class="pw-post-body-paragraph kt ku in kv b kw mt jo ky kz mu jr lb lc mv le lf lg mw li lj lk mx lm ln lo ig bi translated">要成功使用方法重写，您需要满足两个条件:</p><ul class=""><li id="da76" class="nh ni in kv b kw kx kz la lc nj lg nk lk nl lo nm nn no np bi translated">这只有在<em class="lp">类</em>继承上下文中才有可能。或者换句话说，<em class="lp">方法</em>继承在同一个<em class="lp">类</em>内部不起作用。</li><li id="0a35" class="nh ni in kv b kw nq kz nr lc ns lg nt lk nu lo nm nn no np bi translated"><em class="lp">子类</em>应该与<em class="lp">超类</em>具有相同的名称和参数数量。</li></ul><p id="8755" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">🛑还注意到，来自<em class="lp">超类</em>的<code class="fe my mz na nb b">add_value()</code>方法是如何在<em class="lp">子类</em> <code class="fe my mz na nb b">SuperNumList</code>的<code class="fe my mz na nb b">add_value()</code>方法中使用的。</p><h1 id="0d60" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">下一步是什么</h1><p id="8762" class="pw-post-body-paragraph kt ku in kv b kw nc jo ky kz nd jr lb lc ne le lf lg nf li lj lk ng lm ln lo ig bi translated">到目前为止，在 Python 系列的 OOP 中，</p><ul class=""><li id="fb63" class="nh ni in kv b kw kx kz la lc nj lg nk lk nl lo nm nn no np bi translated">我们已经介绍了<em class="lp">类</em>和它们的基本构件，</li><li id="460c" class="nh ni in kv b kw nq kz nr lc ns lg nt lk nu lo nm nn no np bi translated">我们已经学习了<em class="lp">继承</em>及其使用<em class="lp">子类</em>的应用，</li><li id="1de0" class="nh ni in kv b kw nq kz nr lc ns lg nt lk nu lo nm nn no np bi translated">在这篇文章中，我们详细介绍了<em class="lp">变量</em>和<em class="lp">方法</em>。</li></ul><p id="2f65" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在下一篇文章中，我们将尝试了解 Python 异常的内幕。通过这样做，我们将看到学习这些主题将如何派上用场！编码快乐！</p></div><div class="ab cl ot ou hr ov" role="separator"><span class="ow bw bk ox oy oz"/><span class="ow bw bk ox oy oz"/><span class="ow bw bk ox oy"/></div><div class="ig ih ii ij ik"><p id="dfa4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">阅读 Python 中 OOP 系列的其他文章:</strong></p><div class="pa pb gp gr pc pd"><a href="https://towardsdatascience.com/object-oriented-programming-in-python-understanding-variable-e451cf581368" rel="noopener follow" target="_blank"><div class="pe ab fo"><div class="pf ab pg cl cj ph"><h2 class="bd io gy z fp pi fr fs pj fu fw im bi translated">Python 中的面向对象编程——理解变量</h2><div class="pk l"><h3 class="bd b gy z fp pi fr fs pj fu fw dk translated">理解 Python 类中不同类型的变量以及如何使用它们。</h3></div><div class="pl l"><p class="bd b dl z fp pi fr fs pj fu fw dk translated">towardsdatascience.com</p></div></div><div class="pm l"><div class="pn l po pp pq pm pr km pd"/></div></div></a></div><div class="pa pb gp gr pc pd"><a href="https://towardsdatascience.com/object-oriented-programming-in-python-inheritance-and-subclass-9c62ad027278" rel="noopener follow" target="_blank"><div class="pe ab fo"><div class="pf ab pg cl cj ph"><h2 class="bd io gy z fp pi fr fs pj fu fw im bi translated">Python 中的面向对象编程——继承和子类</h2><div class="pk l"><h3 class="bd b gy z fp pi fr fs pj fu fw dk translated">理解继承的基本概念，并通过创建子类来应用它们。</h3></div><div class="pl l"><p class="bd b dl z fp pi fr fs pj fu fw dk translated">towardsdatascience.com</p></div></div><div class="pm l"><div class="ps l po pp pq pm pr km pd"/></div></div></a></div><div class="pa pb gp gr pc pd"><a href="https://towardsdatascience.com/oop-in-python-understanding-a-class-bcc088e595c6" rel="noopener follow" target="_blank"><div class="pe ab fo"><div class="pf ab pg cl cj ph"><h2 class="bd io gy z fp pi fr fs pj fu fw im bi translated">Python 中的 OOP 理解一个类</h2><div class="pk l"><h3 class="bd b gy z fp pi fr fs pj fu fw dk translated">理解 Python 类的基本组件。</h3></div><div class="pl l"><p class="bd b dl z fp pi fr fs pj fu fw dk translated">towardsdatascience.com</p></div></div><div class="pm l"><div class="pt l po pp pq pm pr km pd"/></div></div></a></div><div class="pa pb gp gr pc pd"><a href="https://towardsdatascience.com/object-oriented-programming-in-python-what-and-why-d966e9e0fd03" rel="noopener follow" target="_blank"><div class="pe ab fo"><div class="pf ab pg cl cj ph"><h2 class="bd io gy z fp pi fr fs pj fu fw im bi translated">Python 中的面向对象编程——什么和为什么？</h2><div class="pk l"><h3 class="bd b gy z fp pi fr fs pj fu fw dk translated">学习 Python 中的面向对象编程。</h3></div><div class="pl l"><p class="bd b dl z fp pi fr fs pj fu fw dk translated">towardsdatascience.com</p></div></div><div class="pm l"><div class="pu l po pp pq pm pr km pd"/></div></div></a></div></div></div>    
</body>
</html>