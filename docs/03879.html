<html>
<head>
<title>Receive and Decode SSTV Images from the International Space Station</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">接收和解码来自国际空间站的SSTV图像</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/receive-and-decode-sstv-images-from-the-international-space-station-65a5c39f4b25?source=collection_archive---------1-----------------------#2020-12-29">https://blog.devgenius.io/receive-and-decode-sstv-images-from-the-international-space-station-65a5c39f4b25?source=collection_archive---------1-----------------------#2020-12-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="023e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每年，国际空间站都会安排一系列的慢扫描电视(SSTV)传输，这些图像使用145.800兆赫的业余无线电频率传输。如何接收和解码？让我们弄清楚。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/ffa26c7ad372437c215bd5f061a356f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*5MBDH2RwrtdhTr6U.jpg"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">图片来源【https://en.wikipedia.org/wiki/International_Space_Station T2】</figcaption></figure><h1 id="11b8" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">总说明</h1><p id="8046" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">从国际空间站传来的图像是由<a class="ae kl" href="https://www.ariss.org" rel="noopener ugc nofollow" target="_blank"> ARISS </a>团队完成的，这个项目的崇高目标是吸引人们对太空探索和航天的关注。这些广播一年进行几次，世界任何地方的任何人都可以在145.8兆赫频率上接收SSTV图像。SSTV(慢扫描电视)格式本身是很久以前创建的，它甚至被用来传输来自俄罗斯“月球3号”站的月球背面的图像。很久以后，SSTV在业余业余无线电爱好者中流行起来，因为它使得用无线电收发机发送和接收图像成为可能。经过一些改变，SSTV格式保留到了今天。在70年代，慢扫描图像的接收只能使用特殊和昂贵的设备，现在可以使用一台PC、免费软件解码器和RTL-SDR接收器，价格为35美元。</p><h1 id="15ec" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">接受</h1><p id="716a" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">因为信号是从绕地球轨道运行的空间站发出的，我们首先需要知道接收的准确时间。早期使用的是Orbitron软件，但现在打开n2yo.com页面查看最近的飞越时间要容易得多。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mf"><img src="../Images/9b44ae3a1cd67d42d93bcee9fde90cfe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*uRrBUxM_0oiqjOnE.png"/></div></div></figure><p id="4b71" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">右上角的频率不是为SSTV，我们需要145.800兆赫的频率。当然，我们还需要一个收音机，最便宜的RTL-SDR V3就可以了。大约35美元你就可以买到这样一套设备，它非常适合于无线电实验:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mg"><img src="../Images/05d35814ca960690b0ebe244fa5bce44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*UXqHcnSgUJNExHUW.png"/></div></div></figure><p id="2878" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果一切操作正确，信号应该出现在频谱上:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mh"><img src="../Images/9647666dc53ab8d27de75414abb2ba6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*tv8F6Jw3iLcokuzl.png"/></div></div></figure><p id="8993" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于录音，我们需要使用调频类型。图像处理可以使用第三方软件和虚拟音频电缆实时完成，但出于教育目的，我将数据保存在WAV中，并用纯Python自己解码。</p><h1 id="3496" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">解码</h1><p id="7d87" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">有许多SSTV软件解码器，让你做几个鼠标点击的过程。我对数据格式本身更感兴趣，所以我们来看看如何手动解码。</p><p id="bdf7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们可以看看信号频谱:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mi"><img src="../Images/af934d3df75a5ef4209940bd4fcf6c81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*msaxs8rPc1cb9LPg.png"/></div></div></figure><p id="e962" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">SSTV是一种模拟格式，线按顺序传输，一条线传输的持续时间为0.5秒。使用频率调制，其中频率取决于画面亮度-黑色电平对应于1500赫兹，白色电平对应于2300赫兹。</p><p id="5311" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们加载图像并将带通滤波器应用于数据:</p><pre class="kn ko kp kq gt mj mk ml mm aw mn bi"><span id="e015" class="mo ld iq mk b gy mp mq l mr ms">import scipy.io.wavfile as wav<br/>import scipy.signal as signal<br/>import numpy as np<br/>import matplotlib.pyplot as plt<br/>from PIL import Image<br/></span><span id="0c5c" class="mo ld iq mk b gy mt mq l mr ms">fs, data = wav.read('HDSDR_20201228_075406Z_145803kHz_AF.wav')</span><span id="28aa" class="mo ld iq mk b gy mt mq l mr ms">def butter_bandpass(lowcut, highcut, fs, order=5):<br/>    nyq = 0.5 * fs<br/>    low = lowcut / nyq<br/>    high = highcut / nyq<br/>    b, a = signal.butter(order, [low, high], btype='band')<br/>    return b, a<br/></span><span id="1bf3" class="mo ld iq mk b gy mt mq l mr ms">def butter_bandpass_filter(data, lowcut, highcut, fs, order=5):<br/>    b, a = butter_bandpass(lowcut, highcut, fs, order=order)<br/>    y = signal.lfilter(b, a, data)<br/>    return y</span><span id="0cea" class="mo ld iq mk b gy mt mq l mr ms">data1 = butter_bandpass_filter(data, 1400, 2200, fs, order=4)</span></pre><p id="9f46" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下一步是应用频率解调器。我没有找到合适的库，所以我只能通过计算数据过零来手动获取频率:</p><pre class="kn ko kp kq gt mj mk ml mm aw mn bi"><span id="6f26" class="mo ld iq mk b gy mp mq l mr ms">data_fsk = np.zeros(len(data1))</span><span id="02d5" class="mo ld iq mk b gy mt mq l mr ms">pos1 = 0<br/>for p in range(0, len(data1)-1):<br/>    if np.sign(data1[p]) != np.sign(data1[p+1]):<br/>        pr = p - pos1<br/>        data_fsk[pos1:p] = np.full(p - pos1, pr)<br/>        pos1 = p</span></pre><p id="3e27" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们可以将数据“扩展”为2D图像:</p><pre class="kn ko kp kq gt mj mk ml mm aw mn bi"><span id="fa8e" class="mo ld iq mk b gy mp mq l mr ms">frame_width = int(0.5*fs) + 203<br/>w, h = frame_width, data_fsk.shape[0]//frame_width<br/>image = Image.new('RGB', (w, h))</span><span id="71b8" class="mo ld iq mk b gy mt mq l mr ms">data_2d = data_fsk[:w*h].reshape((h,w))<br/>for py in range(h):<br/>    for px in range(w):<br/>        lum = int(data_2d[py][px]*16)<br/>        if lum &lt; 0: lum = 0<br/>        if lum &gt; 255: lum = 255<br/>        image.putpixel((px, py), (lum, lum, lum))</span></pre><p id="e893" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">显示:</p><pre class="kn ko kp kq gt mj mk ml mm aw mn bi"><span id="78c3" class="mo ld iq mk b gy mp mq l mr ms">plt.imshow(image)<br/>plt.show()</span></pre><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mu"><img src="../Images/b48ecad9a5365b5872fd4cd6e6d48086.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*xy5JkbcNKIZZlLkF.png"/></div></div></figure><p id="2bdc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们看到一幅相当有趣的图画。每条线路传输4帧。这是一幅彩色图像，以<strong class="jp ir"> YCrCb </strong>格式编码，更准确地说，y1 crcb y2——一行包含<em class="mv">两行</em>亮度和<em class="mv">两行的一个</em>颜色数据。因此，图像的颜色分辨率是亮度分辨率的一半。最终图像为640x480，总共传输240行。</p><p id="b750" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一行在0.5s内传输，总共240行给我们120秒的完整传输时间，即2分钟。这种SSTV格式的名称<em class="mv"> PD-120 </em>也向我们表明了这种价值。</p><p id="5f07" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后一步是执行YCrCb =&gt; RGB转换:</p><pre class="kn ko kp kq gt mj mk ml mm aw mn bi"><span id="fd85" class="mo ld iq mk b gy mp mq l mr ms">image_rgb = Image.new('RGB', (w//4, 2*h))<br/>for py in range(h):<br/>    for px in range(int(0.125*fs)):<br/>            <em class="mv"># PD-120 – 640×480, 190 ?s/pixel</em><br/>            k = 32<br/>            y0 = 255 - k*data_2d[py][px]<br/>            cr = 255 - k*data_2d[py][px + int(0.1216*fs)]<br/>            cb = 255 - k*data_2d[py][px + 2*int(0.1216*fs)]<br/>            y1 = 255 - k*data_2d[py][px + 3*int(0.1216*fs)]<br/>            image_rgb.putpixel((px, 2*py), (int(y0 + 1.402 * cr), int(y0 - 0.34414 * cb - 0.71414 * cr), int(y0 + 1.772 * cb)))<br/>            image_rgb.putpixel((px, 2*py + 1), (int(y1 + 1.402 * cr), int(y1 - 0.34414 * cb - 0.71414 * cr), int(y1 + 1.772 * cb)))</span></pre><p id="5042" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是非常简单的代码，只是一个概念证明，没有任何边缘对齐和颜色标准化。但是有些颜色很容易辨别:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mw"><img src="../Images/29299ace3166abf6f94ad28d590e5e5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*nkX5XmHOi0548Ea_.png"/></div></div></figure><p id="3f75" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这只是一个大概的想法。我没有目标要制造另一个SSTV转换器，有很多这样的转换器。好的话，来自同一个WAV文件的图像如下所示:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/617837dc2715b3b326128a857b871449.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*GpiUE9Px9DbcaCN7.png"/></div></figure><h1 id="b3db" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">结论</h1><p id="5b7c" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">正如我们所看到的，SSTV解码并不太难，而且相当有趣。感兴趣的人可以自己尝试接收来自国际空间站的图像。今年(写这篇文章时是2020年)，转移将持续到12月31日(希望明年会再次发生)，所以还有几天时间接收来自ISS的照片。当然没有必要使用Python，SSTV解码器可以在任何平台上下载。</p><p id="0a18" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">同样值得感谢的是国际空间站业余无线电项目的所有参与者对这些活动的支持。对于业余无线电爱好者、小学生和学生来说，这是一个亲身体验太空探索的好机会。</p></div></div>    
</body>
</html>