<html>
<head>
<title>Async-Await-ing for your Loving Promises</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">异步等待你爱的承诺</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/async-await-ing-for-your-loving-promises-98a892332769?source=collection_archive---------14-----------------------#2022-04-18">https://blog.devgenius.io/async-await-ing-for-your-loving-promises-98a892332769?source=collection_archive---------14-----------------------#2022-04-18</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/fe19934c0049beeade4c43b8c176d6e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*drcxhYgRXvmiOW_e8eCHGw.jpeg"/></div></div></figure><p id="7fd0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">等待别人充满爱意的承诺是非常困难的，但在 JavaScript 中却不是这样；感谢 JavaScript 中 async/await 奶油般的语法糖。在本文中，我们将看到编写承诺的演变，从 then()和 catch()方法到超级棒的 async/await 语法。</p><p id="1e92" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">真爱在等待，JavaScript 承诺也在等待。Promises 在 JavaScript 中提供了很多东西，从回调地狱回到提供一堆有用的方法来承诺异常处理的链接特性。但是在你的心里仍然有一个小故障，它提醒你你实际上是在处理一个异步操作，它不可能是同步的，甚至看起来也不是。</p><p id="0e03" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">async/await 关键字处理了 JavaScript 中的承诺。现在你的承诺可以很棒，同时看起来也很迷人。在本文中，让我们来看看它们是如何工作的。</p><p id="8eb5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这篇文章将构成前两篇文章的一些代码逻辑，一篇是关于<a class="ae kt" href="https://codeomelet.com/posts/why-your-crush-and-javascript-does-not-callback-anymore" rel="noopener ugc nofollow" target="_blank">回调</a>，另一篇是关于<a class="ae kt" href="https://codeomelet.com/posts/making-promises-in-love-and-javascript" rel="noopener ugc nofollow" target="_blank">承诺</a>。如果你已经对 JavaScript 的承诺感到满意，就没有必要去查看它们了。</p><p id="a125" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在开始编写代码之前，让我们为 async/await 设置一些基本规则，如下所示:</p><ol class=""><li id="921c" class="ku kv in jx b jy jz kc kd kg kw kk kx ko ky ks kz la lb lc bi translated">Await 关键字只在异步函数和顶级模块体中有效。</li><li id="a691" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks kz la lb lc bi translated">使用 try and catch 块处理承诺的解析和拒绝。</li></ol><h1 id="78de" class="li lj in bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">异步/等待</h1><p id="722a" class="pw-post-body-paragraph jv jw in jx b jy mg ka kb kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated">事不宜迟，看看下面这个超级复杂的 promise 例子，没什么，只是一个简单的偶数查找函数，如下所示:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="855e" class="mu lj in mq b gy mv mw l mx my">const isEven = (number) =&gt; {<br/>    return new Promise((resolve, reject) =&gt; {<br/>        // super complex math problem<br/>        if (number % 2 === 0) {<br/>            resolve();<br/>        } else {<br/>            reject();<br/>        }<br/>    });<br/>};<br/><br/>isEven(4)<br/>    .then(() =&gt; console.log("Yay! it's even"))<br/>    .catch(() =&gt; console.log("Meh! it's odd"));</span></pre><p id="e262" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">到目前为止，生活还不错，但异步/等待触摸会更好。我们可以简单地用 await 关键字替换 then 和朗朗上口的方式，如下所示:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="3fb7" class="mu lj in mq b gy mv mw l mx my">await isEven(2);<br/>console.log("Yay! it's even");</span></pre><p id="c95e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">上面一行肯定会给出一个错误，因为我们有一个没有异步的 await。因此，如果你在代码的顶层，想调用一个返回 promise 对象的函数，并且想使用 async/await 方式，只需使用<a class="ae kt" href="https://developer.mozilla.org/en-US/docs/Glossary/IIFE" rel="noopener ugc nofollow" target="_blank">life</a>(立即调用函数表达式)。</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="f4f9" class="mu lj in mq b gy mv mw l mx my">(async _ =&gt; {<br/>    await isEven(2);<br/>    console.log("Yay! it's even");<br/>})();</span></pre><p id="2e21" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，上面的代码可以工作，但不适用于奇数，因为我们不处理承诺的拒绝，我们将面临一个异常。让我们将 await 调用包装在一个 try-catch 块中，如下所示:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="662b" class="mu lj in mq b gy mv mw l mx my">(async _ =&gt; {<br/>    try {<br/>        await isEven(2);<br/>        console.log("Yay! it's even");<br/>    } catch {<br/>        console.log("Meh! it's odd")<br/>    }<br/>})();</span></pre><p id="8217" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，我们已经成功地按照 async/await 规范重写了代码。</p><h1 id="4ae0" class="li lj in bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">异步/等待解决和拒绝</h1><p id="80e3" class="pw-post-body-paragraph jv jw in jx b jy mg ka kb kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated">让我们继续回忆一下<a class="ae kt" href="https://codeomelet.com/posts/making-promises-in-love-and-javascript" rel="noopener ugc nofollow" target="_blank">上一篇文章</a>中的一个例子；其中我们编写了一个基于 factorial finder promise 的方法，该方法将 number 作为参数，并返回一个解析为 factorial 的 promise，或者在 number 格式不正确的情况下返回一个错误。</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="63a9" class="mu lj in mq b gy mv mw l mx my">const factorial = (number) =&gt; {<br/>    return new Promise((resolve, reject) =&gt; {<br/>        if (typeof number === 'number') {<br/>            let fact = 1;<br/>            for (let i = 1; i &lt;= number; i++) {<br/>                fact *= i;<br/>            }<br/>            resolve(fact);<br/>        } else {<br/>            reject('The number provided must be of type number');<br/>        }<br/>    });<br/>};</span><span id="b69f" class="mu lj in mq b gy mz mw l mx my">(async _ =&gt; {<br/>    try {<br/>        const result = await factorial(5);<br/>        console.log('Factorial:', result);<br/>    } catch (error) {<br/>        console.log('Error:', error)<br/>    }<br/>})();</span></pre><p id="7fd4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">非常简单，你的异步代码将慢慢看起来像同步代码。</p><h1 id="88b7" class="li lj in bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">异步/等待承诺方法</h1><p id="d694" class="pw-post-body-paragraph jv jw in jx b jy mg ka kb kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated">很明显，您可以用 async/await 方式轻松地使用 promise 方法。下面我们简单地创建了一堆承诺，并用 Promise.all()方法将这些承诺组合成一个单元；通过将 await 放在 Promise.all()方法之前，我们可以简单地等待所有异步任务完成。</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="d556" class="mu lj in mq b gy mv mw l mx my">const p1 = new Promise((resolve, reject) =&gt; setTimeout(_ =&gt; resolve('value 1'), 3000));<br/>const p2 = new Promise((resolve, reject) =&gt; setTimeout(_ =&gt; resolve('value 2'), 500));<br/>const p3 = new Promise((resolve, reject) =&gt; setTimeout(_ =&gt; resolve('value 3'), 2000));</span><span id="be5d" class="mu lj in mq b gy mz mw l mx my">const promises = [p1, p2, p3];</span><span id="47b7" class="mu lj in mq b gy mz mw l mx my">(async _ =&gt; {<br/>    try {<br/>        const result = await Promise.all(promises);<br/>        console.log('result:', result)<br/>    } catch (error) {<br/>        console.log('error:', error)<br/>    }<br/>})();</span><span id="0c48" class="mu lj in mq b gy mz mw l mx my">// result: [ 'value 1', 'value 2', 'value 3' ]</span></pre><p id="d172" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们同样可以使用所有的 promise 方法(allSetteleted，any，race)。</p><h1 id="03a3" class="li lj in bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">异步/等待承诺链</h1><p id="a574" class="pw-post-body-paragraph jv jw in jx b jy mg ka kb kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated">承诺链已经在<a class="ae kt" href="https://codeomelet.com/posts/making-promises-in-love-and-javascript" rel="noopener ugc nofollow" target="_blank">之前的文章</a>中展示过，所以我们将选择相同的场景。但是首先检查以下异步调用:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="1e1f" class="mu lj in mq b gy mv mw l mx my">const db = require('./db')</span><span id="67aa" class="mu lj in mq b gy mz mw l mx my">const fetchUserById = (id) =&gt; {<br/>    return new Promise((resolve, reject) =&gt; {<br/>        setTimeout(() =&gt; {<br/>            const results = db.users.find(i =&gt; i.id === id);<br/>            results ?<br/>                resolve(results) :<br/>                reject('Not found');<br/>        }, 500);<br/>    });<br/>};</span><span id="5f61" class="mu lj in mq b gy mz mw l mx my">const fetchPostsByUserId = (userId) =&gt; {<br/>    return new Promise((resolve, reject) =&gt; {<br/>        setTimeout(() =&gt; {<br/>            const results = db.posts.filter(i =&gt; i.userId === userId);<br/>            results.length ?<br/>                resolve(results) :<br/>                reject('Not found');<br/>        }, 500);<br/>    });<br/>};</span><span id="f314" class="mu lj in mq b gy mz mw l mx my">const fetchCommentsByPostId = (postId) =&gt; {<br/>    return new Promise((resolve, reject) =&gt; {<br/>        setTimeout(() =&gt; {<br/>            const results = db.comments.filter(i =&gt; i.postId === postId);<br/>            results.length ?<br/>                resolve(results) :<br/>                reject('Not found');<br/>        }, 500);<br/>    });<br/>};</span></pre><p id="1ac0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我带来了来自<a class="ae kt" href="https://codeomelet.com/posts/making-promises-in-love-and-javascript" rel="noopener ugc nofollow" target="_blank">的前一篇文章</a>的相同代码，它解释了上述异步调用的承诺链:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="8a13" class="mu lj in mq b gy mv mw l mx my">let result;</span><span id="85a2" class="mu lj in mq b gy mz mw l mx my">fetchUserById(1)<br/>    .then(user =&gt; {<br/>        result = user;<br/>        return fetchPostsByUserId(user.id);<br/>    })<br/>    .then(posts =&gt; {<br/>        result.posts = posts;<br/>        return Promise.all(result.posts.map(i =&gt; fetchCommentsByPostId(i.id)));<br/>    })<br/>    .then(comments =&gt; {<br/>        result.posts.forEach(post =&gt; post.comments = comments.flat().filter(i =&gt; i.postId === post.id));<br/>        return result;<br/>    })<br/>    .then(result =&gt; console.log('User:', result))<br/>    .catch(error =&gt; console.log('Error:', error));</span></pre><p id="d517" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，让我们用 async/await 来修饰上述代码逻辑，如下所示:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="c167" class="mu lj in mq b gy mv mw l mx my">(async _ =&gt; {<br/>    try {<br/>        const user = await fetchUserById(1);<br/>        const posts = await fetchPostsByUserId(user.id);<br/>        const comments = await Promise.all(posts.map(i =&gt; fetchCommentsByPostId(i.id)));</span><span id="04d8" class="mu lj in mq b gy mz mw l mx my">user.posts = posts.map(post =&gt; ({<br/>            ...post,<br/>            comments: comments.flat().filter(i =&gt; i.postId === post.id)<br/>        }));<br/>        console.log('User:', user);<br/>    } catch (error) {<br/>        console.log('Error:', error)<br/>    }<br/>})();</span></pre><p id="9c25" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">像冰淇淋一样甜，我们首先获取用户，然后是用户的帖子，然后是借助 Promise.all()方法获取每个帖子的评论。唉，我们把评论数组和它们各自的帖子拉平，形成最终的用户对象。</p><p id="a9c0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">简单地说，在使用 async/await 时，我们需要记住以下几点:</p><ol class=""><li id="0f29" class="ku kv in jx b jy jz kc kd kg kw kk kx ko ky ks kz la lb lc bi translated">await 关键字只在异步函数中起作用，所以如果你的函数在顶层，那么你可以使用异步生命</li><li id="ce55" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks kz la lb lc bi translated">try 块用于解决的承诺，而 catch 用于拒绝的承诺</li><li id="0603" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks kz la lb lc bi translated">您也可以使用 finally 块</li></ol><p id="b5e0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae kt" href="https://github.com/ZakiMohammed/javascript-async-await/archive/master.zip" rel="noopener ugc nofollow" target="_blank">下载代码</a></p><p id="d179" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae kt" href="https://github.com/ZakiMohammed/javascript-async-await" rel="noopener ugc nofollow" target="_blank"> Git 存储库</a></p><h1 id="642f" class="li lj in bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">摘要</h1><p id="89aa" class="pw-post-body-paragraph jv jw in jx b jy mg ka kb kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated">自从我开始了解 async/await，我就投身其中；我找到了每一种按照 async/await 规范编码的可能方法。这不是什么花哨的编码方式，但它甚至可以让复杂的代码看起来容易理解。我见过一些混乱的回调地狱，甚至承诺被束缚得太多，以至于失去控制。除了友好之外，如果你已经是一个有 JavaScript 承诺的专业人士，这很容易理解。async/await 是魔法棒在你的 promise 代码上挥动后的效果。</p><p id="f9a7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">希望这篇文章有所帮助。</p></div><div class="ab cl na nb hr nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ig ih ii ij ik"><p id="a0ae" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="nh">最初发表于</em><a class="ae kt" href="https://codeomelet.com/posts/async-await-ing-for-your-loving-promises" rel="noopener ugc nofollow" target="_blank"><em class="nh">【https://codeomelet.com】</em></a><em class="nh">。</em></p></div></div>    
</body>
</html>