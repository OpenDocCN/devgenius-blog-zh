<html>
<head>
<title>Toppling the pyramids</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">推倒金字塔</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/toppling-the-pyramids-27ace578a7e?source=collection_archive---------13-----------------------#2020-06-15">https://blog.devgenius.io/toppling-the-pyramids-27ace578a7e?source=collection_archive---------13-----------------------#2020-06-15</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><h1 id="0b17" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">为什么测试金字塔不适用于UI应用程序</h1><p id="246f" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">当我第一次开始开发软件时，我接触了测试金字塔。对于门外汉来说，测试金字塔是一种如何平衡不同类型测试的哲学。这个想法是单元测试很便宜——编写和运行都很快——所以应该有很多，而端到端测试很贵——编写和运行都很慢——所以应该只有几个。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi lg"><img src="../Images/d5d2dc8566a60892d847a4ef43bf4ca2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1120/format:webp/1*IBpGR7l_cU-NlkIBSr81AQ.png"/></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk translated">测试金字塔。将服务改为一体化</figcaption></figure></div><div class="ab cl ls lt hr lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ig ih ii ij ik"><h2 id="804f" class="lz jl in bd jm ma mb dn jq mc md dp ju kt me mf jy kx mg mh kc lb mi mj kg mk bi translated">为什么单元测试不适合UI应用程序开发</h2><p id="cb12" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">你可以对测试金字塔提出的批评之一是，它没有考虑到测试的价值。如果E2E测试花费了×10倍的时间来编写/运行，但是给了您×100倍的信心，您的部署将会成功，这是一个很好的权衡。</p><p id="b3b0" class="pw-post-body-paragraph ki kj in kk b kl ml kn ko kp mm kr ks kt mn kv kw kx mo kz la lb mp ld le lf ig bi translated">单元测试对于具有简单输入、复杂处理和简单输出的代码最为有效。这是因为您可以为不同的输入/输出编写少量的测试用例，并在中间覆盖许多复杂的处理。如果您选择重写您的测试已经覆盖的处理部分。这是对大多数API工作方式的完美描述，但不是UI应用程序的工作方式。</p><p id="1e28" class="pw-post-body-paragraph ki kj in kk b kl ml kn ko kp mm kr ks kt mn kv kw kx mo kz la lb mp ld le lf ig bi translated">今天，大多数UI开发都发生在更高的层次上。将组件和API调用连接在一起。有一种趋势是为UI组件拍摄快照——用一组参数实例化组件，并使用生成的DOM作为输出。这里的问题是输入很复杂，输出太冗长，大多数情况下无法查看。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi mq"><img src="../Images/a7584776f6ee23171879e81a6be97a82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DFE_qTeiHfi8ZcoXG7dRqw.png"/></div></div></figure><p id="6d38" class="pw-post-body-paragraph ki kj in kk b kl ml kn ko kp mm kr ks kt mn kv kw kx mo kz la lb mp ld le lf ig bi translated">上面的梦境场景代表了大多数API，而噩梦版本更接近于大多数UI组件的工作方式。输入可以有很多道具。生成的DOM可能有几十行或几百行长。而且这还是在你不得不考虑框架、API调用、应用状态等之前。，所有这些你都必须模仿才能到达你的单元。</p><p id="470f" class="pw-post-body-paragraph ki kj in kk b kl ml kn ko kp mm kr ks kt mn kv kw kx mo kz la lb mp ld le lf ig bi translated">换句话说，您必须做大量的手工工作来设置输入，并评估输出，以测试中间的最小复杂性。</p><p id="7928" class="pw-post-body-paragraph ki kj in kk b kl ml kn ko kp mm kr ks kt mn kv kw kx mo kz la lb mp ld le lf ig bi translated">但是有一个解决方案…</p></div><div class="ab cl ls lt hr lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ig ih ii ij ik"><h2 id="9cd5" class="lz jl in bd jm ma mb dn jq mc md dp ju kt me mf jy kx mg mh kc lb mi mj kg mk bi translated">测试奖杯</h2><p id="00f7" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">Kent C. Dodds提出的这种方法考虑到了UI应用程序开发。它叫做测试奖杯。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/ff7f19956b4073d3e81f520183343363.png" data-original-src="https://miro.medium.com/v2/resize:fit:1358/format:webp/1*VKmTksWmooMyPHSNHRLBVw.jpeg"/></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk translated">好吧，所以他必须努力让它看起来像个战利品。</figcaption></figure><h2 id="366c" class="lz jl in bd jm ma mb dn jq mc md dp ju kt me mf jy kx mg mh kc lb mi mj kg mk bi translated">静态</h2><p id="dd59" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">静态代码分析包括ESLint、SonarQube和Flow/TypeScript之类的东西。一旦设置好了，你就不需要再投入更多的时间，所以这非常便宜。</p><h2 id="24b3" class="lz jl in bd jm ma mb dn jq mc md dp ju kt me mf jy kx mg mh kc lb mi mj kg mk bi translated"><strong class="ak">单位</strong></h2><p id="2321" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">很少，涵盖通用代码。例如，我不经常对React组件进行单元测试，但是如果它是共享的或者普通的JS函数，我有时会对一个钩子进行单元测试。我用的量词是这样的:</p><blockquote class="mw mx my"><p id="6bc3" class="ki kj mz kk b kl ml kn ko kp mm kr ks na mn kv kw nb mo kz la nc mp ld le lf ig bi translated">将其分解到自己的npm包中是否有价值？</p></blockquote><p id="4b70" class="pw-post-body-paragraph ki kj in kk b kl ml kn ko kp mm kr ks kt mn kv kw kx mo kz la lb mp ld le lf ig bi translated">即使我现在没有时间进行重构，这也是一个很好的迹象，表明它会喜欢单元测试。</p><h2 id="d306" class="lz jl in bd jm ma mb dn jq mc md dp ju kt me mf jy kx mg mh kc lb mi mj kg mk bi translated">综合</h2><p id="a159" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">许多，覆盖所有路径。这些给了你几乎和E2E一样多的信心，但成本却是后者的一小部分。我用这些覆盖快乐和不快乐的道路。</p><h2 id="8b8d" class="lz jl in bd jm ma mb dn jq mc md dp ju kt me mf jy kx mg mh kc lb mi mj kg mk bi translated">E2E</h2><p id="d122" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">很少，覆盖幸福的道路。给你最大的信心，你的用户将能够继续使用你的应用程序。</p></div><div class="ab cl ls lt hr lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ig ih ii ij ik"><h2 id="cb1a" class="lz jl in bd jm ma mb dn jq mc md dp ju kt me mf jy kx mg mh kc lb mi mj kg mk bi translated">结论</h2><p id="c130" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">作为UI开发人员，我们今天做的很多工作都围绕着集成。如果你使用的是像<a class="ae nd" href="https://material-ui.com/" rel="noopener ugc nofollow" target="_blank"> Material-UI </a>、<a class="ae nd" href="https://vuetifyjs.com/en/" rel="noopener ugc nofollow" target="_blank"> Vuetify </a>这样的组件库，或者一些内部的东西，那么你会花很多时间在所有这些组件和你的API之间进行集成。在这种情况下，单元测试总是很难实现。如果你发现自己不得不模仿很多，这通常是一个迹象，表明你正在试图对不是一个单元的东西进行单元测试。</p><p id="0138" class="pw-post-body-paragraph ki kj in kk b kl ml kn ko kp mm kr ks kt mn kv kw kx mo kz la lb mp ld le lf ig bi translated">我花了一段时间来转换，但我发现自己正在移动——几乎没有注意到——到测试奖杯的方法。它让我对自己的部署更有信心，编写测试的工作量也更少。</p><p id="ea05" class="pw-post-body-paragraph ki kj in kk b kl ml kn ko kp mm kr ks kt mn kv kw kx mo kz la lb mp ld le lf ig bi translated"><br/>祝一切顺利，尼克</p></div></div>    
</body>
</html>