<html>
<head>
<title>Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">库伯内特斯</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/kubernetes-d51c3ba54ce1?source=collection_archive---------8-----------------------#2022-04-07">https://blog.devgenius.io/kubernetes-d51c3ba54ce1?source=collection_archive---------8-----------------------#2022-04-07</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="3034" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">假设我们有一个程序运行在我们的机器 X 上，带有所有的依赖项、配置等。现在想象一下，我们通过 github/将程序/代码转移到一台配置相同的朋友机器 Y 上，但是相同的程序无法在机器 Y 上运行/工作，那么会出现什么问题呢？代码不可能是错的，因为我们刚刚写了它。所以也许 Y 机会有问题？？？？？？？</p><p id="4c16" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">好吧，这是个问题，但解决方案是什么呢？如果我们将你的机器 X 直接发送给你的朋友，而他只是在他的机器 y 上运行你的机器，这看起来公平又愚蠢，但如果你仔细想想，这可能是一个非常好的主意，不是吗？这个想法是码头工人的核心概念，这种机器被称为<strong class="jm io">集装箱</strong>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/35abf345887987efdad84de967ac6b9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bhrza8qtKg1bvqfM"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@carrier_lost?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">伊恩·泰勒</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><p id="a354" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">容器化的应用程序是那些在特定环境(或容器)中运行的程序，这些程序随后会与它的依赖项或需求一起被运送到其他系统上。在现实世界中，可能有成吨的容器用于运行一个程序/平台。此外，还有负载平衡、可用性、伸缩、回滚、调度等任务。由于这些都是乏味的过程，他们需要一个管理工具来为开发者处理同样的事情，这样就出现了一个叫做<strong class="jm io"> Kubernetes </strong>的容器管理工具。</p><p id="b521" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Kubernetes 也称为 k8，是一个容器管理/编排工具，用于在一组服务器上自动化、部署和管理容器化的应用程序。具体来说，它用于部署、调度、扩展、负载平衡、批处理执行、回滚和监控。Kubernetes 的使用量很大，尽管 Kubernetes 的替代产品包括 docker swarn、Apache mesos 等。</p><p id="f3c3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Docker 创建容器，Kubernetes 管理它。潜入 Kubernetes 的功能，我们有:-</p><ol class=""><li id="475b" class="kz la in jm b jn jo jr js jv lb jz lc kd ld kh le lf lg lh bi translated"><strong class="jm io">自动装箱</strong> : —装箱是一项功能，Kubernetes 引擎根据每个容器的内存、资源需求自动将容器包装在服务器内部，以便于它们运行。例如:-我们有 5 个容器，比如 a、b、c、d、e。因此 Kubernetes 引擎会自动将这些容器放入<strong class="jm io">服务器(bin)</strong>中，无需人工干预。</li></ol><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi li"><img src="../Images/3c1ea9ed01bde4022b685415c1fbfa1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fpq9zzy8TNqfD4MNLTUbvQ.png"/></div></div></figure><p id="3fc3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">2 <strong class="jm io">。服务发现和负载平衡</strong> : —现在 Kubernetes 不直接运行容器。他们将这些容器放入<strong class="jm io">容器</strong>(与存储单元和唯一 IP 包装在一起的容器集合)和<strong class="jm io">节点</strong>(容器集合)。不同的豆荚可以组合在一起，放在一个大包装下，这个包装可以作为所有豆荚的共同点。现在这项服务在受到外部 IP 攻击时，可以提供负载均衡和发现功能。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lj"><img src="../Images/d842b0186c0d6b20bed5b501b4d7ee7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1114/format:webp/1*uN6CYoMXD951Sc0hUdLRqg.png"/></div></figure><p id="0557" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">3.<strong class="jm io">存储编排</strong> : —在 Pod 内运行的容器可能需要存储或 RAM 等。因此，我们可以在一个 Pod 内的多个容器之间共享一个存储空间，或者每个容器都有自己的存储空间。此外，我们可以进行数据库集成，如 AWS 存储或 NFs 存储。</p><p id="e783" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">4.<strong class="jm io">自我修复</strong> : — Kubernetes 倾向于维护我们部署的容器。如果发生故障或失败，它会自动多次重新运行容器。此外，它还执行定期健康检查等。总结自我修复，Kubernetes 做了:-</p><p id="4123" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果容器出现故障:-它会自行重启容器。</p><p id="a20f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果节点失效:—在另一个节点上复制和调度容器</p><p id="50a3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果容器不响应手动或自动健康检查:—关闭容器</p><p id="fa44" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">5.<strong class="jm io">自动推出和回滚</strong> : — Kubernetes 在出现错误等情况下自动执行回滚。类似地，编排工具还会自动处理新功能等的推出，同时确保应用程序不会停机。</p><p id="bba0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">6.<strong class="jm io">秘密和配置管理</strong> : —在 Kubernetes 中，我们有两个对象，秘密和配置映射。Secret 存储密码等数据，而 config 存储配置文件等。这两个管理对象都位于 Pod 外部。这些值存储在名为<strong class="jm io"> ETCD 的键值数据存储中，最大大小为 1MB </strong>(用于秘密存储)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lk"><img src="../Images/dd6d52b509975f7a3125019be13c26d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/1*8EgiWV9w3GI-vuz48UmWaw.png"/></div></div></figure><p id="cf33" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">7.<strong class="jm io">批处理执行</strong> : —批处理作业需要运行一个可执行文件/进程来完成。在 Kubernetes 中，从运行到完成的作业主要用于批处理。每个作业创建一个或多个 pod。在作业执行过程中，如果任何容器或箱出现故障，作业控制器将在另一个节点上重新调度该容器、箱。可以并行运行多个单元，并且可以根据需要纵向扩展。作业完成后，单元将从运行状态变为关闭状态。</p><p id="e0bd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">8.<strong class="jm io">水平缩放</strong> : — Kubernetes 内置了对容器缩放的支持。这可以通过命令或 UI 来完成。Kubernetes 中有三个工具:-</p><p id="9ea9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">复制控制器:缩写为 RC，它允许创建多个 pod，并且在 pod 崩溃的情况下，RC 会自动替换相同的 pod。它从清单文件中获取所有关于要运行的 pod 数量等信息。</p><p id="431d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">舱单文件:存储关于运输舱数量、运输舱负载等信息。</p><p id="7225" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">水平机架自动缩放器:-这是一种用于监控 CPU 利用率的工具，复制容器基于此设置机架数量，即缩放。自动缩放器每 15 秒运行一次，以查看 CPU 利用率。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ll"><img src="../Images/a6dd5e6c52274a63d0c3fb03e0e27807.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S5ZFZdfU7XUoDuF8ce7E7g.png"/></div></div></figure><h1 id="addd" class="lm ln in bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">库伯内特斯的建筑</h1><p id="6194" class="pw-post-body-paragraph jk jl in jm b jn mk jp jq jr ml jt ju jv mm jx jy jz mn kb kc kd mo kf kg kh ig bi translated">Kubernetes 的核心组件是主节点和工作节点。它们一起形成一个团队或集群。群集是工作节点和主节点的集合，每个群集至少应该有一个主节点和一个群集节点。每个节点由 Pod 组成，而 Pod 又由容器、存储单元和 IP 组成。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mp"><img src="../Images/b9972c7a9cc449a60ee891c79ac544d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N_QAs1G4Ro2Pr9HW2BO9FQ.png"/></div></div></figure><p id="2a61" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在建立 Kubernetes 时，我们得到一个集群。主节点负责管理工作节点以及这些节点中的 pod。Kubernetes master 包括:-</p><p id="6504" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">API 服务器</p><p id="520d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">调度程序</p><p id="ba11" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">控制器管理器</p><p id="174a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">ETCD</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/4fe78d91a88e957d8da473004306350d.png" data-original-src="https://miro.medium.com/v2/resize:fit:998/format:webp/1*VuJndgQGhv5LqHMYmOgJAw.png"/></div></figure><p id="8424" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">o API 服务器:API 允许应用程序相互通信。API 服务器是 Kubernetes 控制平面的前端。它为几乎每个操作公开 API。用户、管理设备和命令行界面(针对用户)等都与 API 服务器进行对话，以便与 Kubernetes 集群进行交互。用户可以使用 Kubectl 与 Kubernetes API 进行交互。</p><p id="c0da" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">o 调度器:它跨多个节点调度 pod。主服务器上的组件监视新创建的没有分配节点的 pod，并为它们选择一个运行节点。调度程序通过 API 服务器从 etc 获得集群中每个工作节点的资源使用数据。<strong class="jm io">调度程序从配置文件</strong>中获取所有信息。</p><p id="7337" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">o 控制管理器:它是主服务器上运行控制器的组件。该组件有两种类型的控制器，Kube 控制器管理器和云控制器管理器。</p><p id="82aa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">ETCD:这是一个开源的分布式键值数据库。它用于管理键值对并存储它们。只有<strong class="jm io"> API 服务器</strong>可以与 etcd 数据存储通信。</p><p id="8d04" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如前所述，集群由主节点和工作节点组成。母版的构成如上所述。然而，工人要简单得多，可描述如下:-</p><p id="49ae" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">库伯莱</p><p id="a22f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Kube 代理</p><p id="2dfe" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">容器运行时</p><p id="a2e2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">v Kubelet: — kubelet 是运行在每个节点上的代理。它与主节点的组件通信，并确保容器在 pod 中运行。kubelet 接受一组通过各种机制提供的 Pod 规范，并确保这些 Pod 规范中描述的容器运行正常。如果任何 pod 出现任何问题，kubelet 会尝试在同一节点或不同节点上重新启动 pod。</p><p id="2b30" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">v Kube-Proxy:-它是节点中的核心网络组件。在每个节点上运行的网络代理，负责维护网络配置和规则。它向外界公开服务，并处理 Kubernetes 中的核心网络组件。所有工作节点都运行一个名为 kube-proxy 的守护进程，它监视主节点上的 API 服务器添加和删除服务和端点</p><p id="ea72" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">容器运行时:— Kubernetes 没有能力直接处理容器。为了运行和管理容器的生命周期，Kubernetes 需要在计划 Pod 及其容器的节点上运行容器运行时。几个运行时引擎包括 Docker、Contained、Cri-o、Rklet 等。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/0ec0b228360aec652c7f02f27984f058.png" data-original-src="https://miro.medium.com/v2/resize:fit:1050/format:webp/1*SO5CR2kPO7I4wivQ1Uhm0A.png"/></div></figure><p id="7d8e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这基本上就是库伯内特斯的风格。<strong class="jm io">感谢阅读，希望你喜欢这篇文章。通过订阅我的邮件列表或关注我</strong>:)，期待更多这样的文章</p></div></div>    
</body>
</html>