<html>
<head>
<title>Secure way to use Secrets with Java using Azure Key Vault and Managed Identity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Azure Key Vault 和托管身份在 Java 中使用机密的安全方式</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/azure-key-vault-and-managed-identity-for-java-on-azure-platforms-f4b1b791a214?source=collection_archive---------1-----------------------#2022-04-20">https://blog.devgenius.io/azure-key-vault-and-managed-identity-for-java-on-azure-platforms-f4b1b791a214?source=collection_archive---------1-----------------------#2022-04-20</a></blockquote><div><div class="fc ic id ie if ig"/><div class="ih ii ij ik il"><div class=""/><p id="a90b" class="pw-post-body-paragraph jl jm io jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki ih bi translated">现代分布式系统需要各种各样的秘密，如 API 密钥、SSH 证书、数据库密码等。这些秘密应该安全地保存在一个安全的仓库里，就像我们现实生活中的个人金库一样。不出所料，每个云服务提供商都提供自己版本的安全商店，如 Azure Key Vault、AWS KMS、谷歌云 KMS 等。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj kj"><img src="../Images/1917973550c0afdad688bb9534f8e0a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*yzcOcl4855XGRTTdihwMYQ.jpeg"/></div><figcaption class="kr ks gk gi gj kt ku bd b be z dk translated"><a class="ae kv" href="https://makeameme.org/meme/someone-figured-out-c3fdc09613" rel="noopener ugc nofollow" target="_blank">https://makeameme.org/meme/someone-figured-out-c3fdc09613</a></figcaption></figure><p id="9cc1" class="pw-post-body-paragraph jl jm io jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki ih bi translated">有了 Azure Key Vault，开发人员不必再将秘密存储在他们的应用程序中。这听起来可能令人兴奋，但这里有一个小警告。我们需要<strong class="jn ip">的第一个凭证</strong>来访问密钥库，以访问商店中的实际秘密。秘密被安全地保存在保险库中，但是使用第一凭证对密钥库的访问可能会无意中帮助黑客从单个地方窃取秘密，如果我们一开始不使用密钥库，这将会困难得多。您一定想知道是否有任何方法可以消除第一个凭证的使用，幸运的是，Azure 上有一个名为托管身份的解决方案。本文将探讨 Azure 托管身份如何工作，以及我们如何使用它来访问 Azure Key Vault 以安全地管理凭据。</p><h1 id="a323" class="kw kx io bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">托管身份</h1><p id="0eb1" class="pw-post-body-paragraph jl jm io jn b jo lu jq jr js lv ju jv jw lw jy jz ka lx kc kd ke ly kg kh ki ih bi translated">对于那些不熟悉托管身份的人来说，<a class="ae kv" href="https://docs.microsoft.com/en-us/azure/active-directory/managed-identities-azure-resources/overview" rel="noopener ugc nofollow" target="_blank">微软文档</a>有一个简单明了的解释如下。</p><p id="d9b5" class="pw-post-body-paragraph jl jm io jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki ih bi translated"><em class="lz">“开发人员面临的一个常见挑战是管理机密和凭证，这些机密和凭证用于保护组成解决方案的不同组件之间的通信。托管身份</em> <strong class="jn ip"> <em class="lz">消除了开发人员管理凭证</em> </strong> <em class="lz">的需求。</em></p><p id="f99c" class="pw-post-body-paragraph jl jm io jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki ih bi translated"><em class="lz">托管身份为应用程序</em>  <em class="lz">提供一个</em> <strong class="jn ip"> <em class="lz">身份，以便在连接到支持 Azure Active Directory (Azure AD)身份验证的资源时使用。应用程序可以使用托管身份来获取 Azure AD 令牌。</em> <strong class="jn ip"> <em class="lz">同</em> </strong> <a class="ae kv" href="https://docs.microsoft.com/en-us/azure/key-vault/general/overview" rel="noopener ugc nofollow" target="_blank"> <strong class="jn ip"> <em class="lz">天蓝色密钥库</em> </strong> </a> <strong class="jn ip"> <em class="lz">，开发者可以使用托管身份访问资源。</em> </strong> <em class="lz">密钥库以安全的方式存储凭证，并允许访问存储帐户。”</em></strong></p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="gi gj ma"><img src="../Images/beea9e3b85012b60587ff4c146163f45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Vx3oRqMSyuRLseos.png"/></div></div><figcaption class="kr ks gk gi gj kt ku bd b be z dk translated"><a class="ae kv" href="https://docs.microsoft.com/en-us/azure/active-directory/managed-identities-azure-resources/how-managed-identities-work-vm#system-assigned-managed-identity" rel="noopener ugc nofollow" target="_blank">https://docs . Microsoft . com/en-us/azure/active-directory/managed-identities-azure-resources/how-managed-identities-work-VM # system-assigned-managed-identity</a></figcaption></figure><p id="dd5e" class="pw-post-body-paragraph jl jm io jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki ih bi translated">那么，它到底是如何消除开发人员的凭证管理的呢？让我们看看上面的图表。这看起来可能太复杂了，但它比最初想象的要简单。您的代码使用托管身份通过 Azure IMDS(可在 169.254.169.254 到达的实例元数据服务)获取访问令牌，并使用获取的令牌访问 Azure 服务，而不是直接使用凭据访问 Azure 资源(图中最右边)(<strong class="jn ip">流程 4–6</strong>)。</p><p id="53f3" class="pw-post-body-paragraph jl jm io jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki ih bi translated">使用托管身份获取访问令牌是有意义的。但是 IMDS 怎么知道我的代码可以使用托管身份呢？如果恶意代码使用了不允许它们使用的 MI，该怎么办？受管身份绑定到虚拟机或虚拟机规模集。(<strong class="jn ip">Flow 1–3</strong>)，Azure 假设在特定 VM 上运行的一个或多个应用已经过验证，并被允许使用绑定的 MI。现在，应该很清楚，您需要将受管身份分配给虚拟机/VMSS，以便使用它。在 CaaS(Azure Kubernetes Service)和 PaaS(App Service，Spring Cloud)的情况下，平台可以为我们处理这些。</p><h1 id="02ca" class="kw kx io bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">使用托管身份访问密钥库</h1><p id="cb4f" class="pw-post-body-paragraph jl jm io jn b jo lu jq jr js lv ju jv jw lw jy jz ka lx kc kd ke ly kg kh ki ih bi translated">我们简要介绍了托管身份的基础知识。让我们从这里用命令和代码做一些“边做边学”的工作。有两种类型的受管身份，<a class="ae kv" href="https://docs.microsoft.com/en-us/azure/active-directory/managed-identities-azure-resources/overview#managed-identity-types" rel="noopener ugc nofollow" target="_blank">系统分配的受管身份和用户分配的受管身份。</a>我将创建一个用户分配的托管身份，因为我想在不同的平台上重复使用它。</p><pre class="kk kl km kn gu mf mg mh mi aw mj bi"><span id="6210" class="mk kx io mg b gz ml mm l mn mo">$ az identity create --resource-group sandbox-rg --name jay-managedidentity<br/>{<br/>  "clientId": "34dce330-*****",<br/>  "id": "/subscriptions/*****/resourcegroups/sandbox-rg/providers/Microsoft.ManagedIdentity/userAssignedIdentities/jay-managedidentity",<br/>  "location": "southeastasia",<br/>  "name": "jay-managedidentity",<br/>  "principalId": "deca1f30-04ed-*****",<br/>  "resourceGroup": "sandbox-rg",<br/>  "tags": {},<br/>  "tenantId": "72f988bf-*****",<br/>  "type": "Microsoft.ManagedIdentity/userAssignedIdentities"<br/>}</span></pre><p id="4e36" class="pw-post-body-paragraph jl jm io jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki ih bi translated">我假设您已经准备好了 Azure Key Vault 实例。如果没有，请在继续下一步之前快速创建一个。我们需要向托管身份授予权限，以便它可以从密钥库中读取机密。进入 Azure Portal，选择 Azure Key Vault，点击左边的<code class="fe mp mq mr mg b">Add access policy</code>。我允许秘密的所有权限。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="gi gj ms"><img src="../Images/cfb85ee660a7e4d1a89e70e28aa94e05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ywV1gbigEMNGlSuyUmm9gg.png"/></div></div><figcaption class="kr ks gk gi gj kt ku bd b be z dk translated">Azure 密钥保管库访问策略</figcaption></figure><p id="ae75" class="pw-post-body-paragraph jl jm io jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki ih bi translated">MI 准备好了，Key vault 权限也到位了，接下来看代码。两个必需的依赖项为 Azure 资源提供了所有的身份验证选项。</p><pre class="kk kl km kn gu mf mg mh mi aw mj bi"><span id="a744" class="mk kx io mg b gz ml mm l mn mo">&lt;dependency&gt;<br/>    &lt;groupId&gt;com.microsoft.azure&lt;/groupId&gt;<br/>    &lt;artifactId&gt;msal4j&lt;/artifactId&gt;<br/>    &lt;version&gt;1.11.2&lt;/version&gt;<br/>&lt;/dependency&gt;<br/>&lt;dependency&gt;<br/>    &lt;groupId&gt;com.azure&lt;/groupId&gt;<br/>    &lt;artifactId&gt;azure-identity&lt;/artifactId&gt;<br/>    &lt;version&gt;1.5.0&lt;/version&gt;<br/>&lt;/dependency&gt;</span></pre><p id="dd76" class="pw-post-body-paragraph jl jm io jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki ih bi translated">对于 Spring Boot 应用程序，<code class="fe mp mq mr mg b">Azure Support</code> starter 默认包含这两个依赖项。</p><pre class="kk kl km kn gu mf mg mh mi aw mj bi"><span id="cde0" class="mk kx io mg b gz ml mm l mn mo"><em class="lz">&lt;</em>dependency<em class="lz">&gt;<br/>   &lt;</em>groupId<em class="lz">&gt;</em>com.azure.spring<em class="lz">&lt;/</em>groupId<em class="lz">&gt;<br/>   &lt;</em>artifactId<em class="lz">&gt;</em>spring-cloud-azure-starter<em class="lz">&lt;/</em>artifactId<em class="lz">&gt;<br/>&lt;/</em>dependency<em class="lz">&gt;</em></span></pre><p id="4b29" class="pw-post-body-paragraph jl jm io jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki ih bi translated">需要使用应用程序属性进行配置。下面是示例代码中的<code class="fe mp mq mr mg b">application.yml</code>。我想使用 Azure Key Vault 作为 PropertySource 之一，这样我就可以将值注入到我的变量中。(property-source-enabled 为 true)。然后我想使用用户分配的托管身份来连接 Azure Key Vault，所以我将 managed-identity-enabled 设置为 true，并提供托管身份的客户端 id。然后，当然，我们需要告诉他们哪个密钥库是我们想要使用的，所以我们放置了<code class="fe mp mq mr mg b">property-sources</code>。</p><pre class="kk kl km kn gu mf mg mh mi aw mj bi"><span id="2aca" class="mk kx io mg b gz ml mm l mn mo">logging:<br/>  level:<br/>    com.azure: DEBUG<br/>spring:<br/>  cloud:<br/>    azure:<br/>      keyvault:<br/>        secret:<br/><strong class="mg ip">          property-source-enabled: true<br/>          property-sources:<br/>            - name: app-***<br/>              endpoint: ${KEYVAULT_URI}<br/>          credential:<br/>            client-id: ${MANAGED_IDENTITY_CLIENT_ID}<br/>            managed-identity-enabled: true</strong></span></pre><p id="8eb0" class="pw-post-body-paragraph jl jm io jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki ih bi translated">有了这些属性，AzureKeyVaultSecretAutoConfiguration 将使用托管身份的客户端 id 从 IMDS 获取访问令牌，使用访问令牌从密钥库中读取机密，并在启动时将其注入属性源。从那里，我们可以使用<code class="fe mp mq mr mg b">@Value</code>将秘密注入变量。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="mt mu l"/></div></figure><p id="7440" class="pw-post-body-paragraph jl jm io jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki ih bi translated">如代码所示，我将一个秘密<code class="fe mp mq mr mg b">connectionString</code>注入到 String 中，这需要被创建。</p><pre class="kk kl km kn gu mf mg mh mi aw mj bi"><span id="c798" class="mk kx io mg b gz ml mm l mn mo">$ az keyvault secret set --vault-name "app-***" \<br/>    --name "connectionString" \<br/>    --value "Java on Azure!"</span></pre><p id="382c" class="pw-post-body-paragraph jl jm io jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki ih bi translated">整个源代码<a class="ae kv" href="https://github.com/eggboy/keyvault-mi" rel="noopener ugc nofollow" target="_blank"> <strong class="jn ip">都在 Github 上。</strong> </a></p><h1 id="3490" class="kw kx io bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">在 Azure 平台上使用托管身份</h1><p id="436b" class="pw-post-body-paragraph jl jm io jn b jo lu jq jr js lv ju jv jw lw jy jz ka lx kc kd ke ly kg kh ki ih bi translated">此时，代码和环境已经准备好运行。让我们在 Azure 平台上运行示例应用程序。像 Azure App Service 和 Azure Spring Cloud 这样的 PaaS 平台在 Azure 门户上提供身份设置，以快速设置系统分配和用户分配的托管身份。</p><p id="6374" class="pw-post-body-paragraph jl jm io jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki ih bi translated"><strong class="jn ip"> Azure 应用服务</strong></p><p id="bf68" class="pw-post-body-paragraph jl jm io jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki ih bi translated">对于部署，我将使用 maven 插件<code class="fe mp mq mr mg b">azure-webapp-maven-plugin</code>快速创建一个应用服务，并在其上部署 Spring boot 应用。</p><pre class="kk kl km kn gu mf mg mh mi aw mj bi"><span id="4c0f" class="mk kx io mg b gz ml mm l mn mo">$ <strong class="mg ip">mvn com.microsoft.azure:azure-webapp-maven-plugin:2.5.0:config</strong><br/>[INFO] Scanning for projects...<br/>[INFO]<br/>[INFO] -------------------&lt; com.microsoft.gbb:keyvault-mi &gt;--------------------<br/>[INFO] Building keyvault-mi 0.0.1-SNAPSHOT<br/>[INFO] --------------------------------[ jar ]---------------------------------<br/>[INFO]<br/>[INFO] --- azure-webapp-maven-plugin:2.5.0:config (default-cli) @ keyvault-mi ---<br/>Auth type: AZURE_CLI<br/>Default subscription: ***<br/>Username: ***<br/>[INFO] Subscription: ***<br/>[INFO] It may take a few minutes to load all Java Web Apps, please be patient.<br/>[INFO] Reflections took 192 ms to scan 6 urls, producing 24 keys and 484 values<br/>[WARNING] There are no Java Web Apps in current subscription, please follow the following steps to create a new one.<br/>Define value for OS [Linux]:<br/>  1: Windows<br/>* 2: Linux<br/>  3: Docker<br/>Enter your choice:<br/>Define value for javaVersion [Java 8]:<br/>* 1: Java 8<br/>  2: Java 11<br/>  3: Java 17<br/>Enter your choice: 3<br/>Define value for pricingTier [P1v2]:<br/>   1: B1<br/>   2: B2<br/>   3: B3<br/>   4: D1<br/>   5: EP1<br/>   6: EP2<br/>   7: EP3<br/>   8: F1<br/>*  9: P1v2<br/>  10: P1v3<br/>  11: P2v2<br/>  12: P2v3<br/>  13: P3v2<br/>  14: P3v3<br/>  15: S1<br/>  16: S2<br/>  17: S3<br/>  18: Y1<br/>Enter your choice:<br/>Please confirm webapp properties<br/>Subscription Id : ***<br/>AppName : keyvault-mi-1650465630677<br/>ResourceGroup : keyvault-mi-1650465630677-rg<br/>Region : centralus<br/>PricingTier : P1v2<br/>OS : Linux<br/>Java : Java 17<br/>Web server stack: Java SE<br/>Deploy to slot : false<br/>Confirm (Y/N) [Y]:<br/>[INFO] Saving configuration to pom.<br/>[INFO] ------------------------------------------------------------------------<br/>[INFO] BUILD SUCCESS<br/>[INFO] ------------------------------------------------------------------------<br/>[INFO] Total time:  01:38 min<br/>[INFO] Finished at: 2022-04-20T22:41:47+08:00<br/>[INFO] ------------------------------------------------------------------------<br/>$ <strong class="mg ip">mvn clean package -Dmaven.test.skip=true</strong><br/>...<br/>$ <strong class="mg ip">mvn azure-webapp:deploy</strong></span></pre><p id="972b" class="pw-post-body-paragraph jl jm io jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki ih bi translated">应用程序应该无法启动，因为我们错过了一些东西。首先，我们需要向应用服务添加用户分配的托管身份。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="gi gj mv"><img src="../Images/eb320044a73abbb95a2a70843699a747.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zpVcIFjVVvT2G1pPIoG-Pg.png"/></div></div><figcaption class="kr ks gk gi gj kt ku bd b be z dk translated">具有托管身份的应用服务设置</figcaption></figure><p id="0dbb" class="pw-post-body-paragraph jl jm io jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki ih bi translated">然后，我们需要提供两个环境变量，MANAGED_IDENTITY_CLIENT_ID 和 KEYVAULT_URI。MANAGED_IDENTITY_CLIENT_ID 是托管身份的客户端 ID，KEYVAULT_URI 是金库 URI，<a class="ae kv" href="https://app-secrets-vault.vault.azure.net/" rel="noopener ugc nofollow" target="_blank">https://* * * . Vault . azure . net/</a></p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="gi gj mw"><img src="../Images/2b1e413d567232744327736cf62cda34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m5Ecdvq8Wje_Oq5ZJf_6EQ.png"/></div></div><figcaption class="kr ks gk gi gj kt ku bd b be z dk translated">配置会将设置注入环境变量</figcaption></figure><p id="3454" class="pw-post-body-paragraph jl jm io jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki ih bi translated">添加应用程序设置将重新启动应用程序。这一次，由于分配了 MI 并设置了环境变量，它应该能够顺利启动。除了执行器之外，示例应用程序没有端点，因此我们需要测试执行器端点，如<a class="ae kv" href="https://***.azurewebsites.net/actuator/env" rel="noopener ugc nofollow" target="_blank">https://* * * . azure websites . net/actuator/env</a></p><p id="c349" class="pw-post-body-paragraph jl jm io jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki ih bi translated"><strong class="jn ip">注意:由于我们使用 Key Vault 作为其中一个 PropertySource，如果示例应用程序由于某种原因无法连接到 Key Vault，它将不会启动。</strong></p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="gi gj mx"><img src="../Images/089689be0a93feca852966b78f3ebf72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*05O6xGYgLiqnO-SgREapmg.png"/></div></div><figcaption class="kr ks gk gi gj kt ku bd b be z dk translated">在应用服务上运行的示例应用</figcaption></figure><p id="c645" class="pw-post-body-paragraph jl jm io jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki ih bi translated"><strong class="jn ip"> Azure Kubernetes 服务</strong></p><p id="4057" class="pw-post-body-paragraph jl jm io jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki ih bi translated">与 App Service 不同，Azure Portal 上没有分配 MI 的方法。相反，AKS 提供了一个名为 AAD Pod Identity 的插件，应该使用 Azure CLI 启用它。AAD Pod 身份提供 Pod 级分配(还记得 MI 是在虚拟机/VMSS 级分配的吗？)以库伯内特人的方式。</p><p id="a60f" class="pw-post-body-paragraph jl jm io jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki ih bi translated"><strong class="jn ip">注意:AAD Pod Identity 目前在预览中，它不会使 GA 成为 Azure AD Workload Identity，因为它将在未来取代它。可以看我之前的文章— </strong> <a class="ae kv" href="https://eggboy.medium.com/azure-workload-identity-preview-on-aks-with-spring-boot-46b245d7d127" rel="noopener"> <strong class="jn ip"> Azure 工作负载身份预览关于 AKS 搭配 Spring Boot </strong> </a></p><p id="4b44" class="pw-post-body-paragraph jl jm io jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki ih bi translated">在 AKS 上启用 AAD Pod 身份的步骤是<a class="ae kv" href="https://docs.microsoft.com/en-us/azure/aks/use-azure-ad-pod-identity" rel="noopener ugc nofollow" target="_blank">这里是</a>。启用 AAD Pod 身份插件后，使用示例报告中的<code class="fe mp mq mr mg b">deployment.yaml</code>在 AKS 上部署 Pod。这里最重要的是<code class="fe mp mq mr mg b">aadpodidbinding</code>，它将受管身份与 pod 绑定在一起。</p><pre class="kk kl km kn gu mf mg mh mi aw mj bi"><span id="8eea" class="mk kx io mg b gz ml mm l mn mo">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: keyvault-mi<br/>  labels:<br/>    app: keyvault-mi<br/>spec:<br/>  replicas: 1<br/>  template:<br/>    metadata:<br/>      name: keyvault-mi<br/>      labels:<br/>        <strong class="mg ip">aadpodidbinding: jay-managedidentity</strong><br/>        app: keyvault-mi<br/>    spec:<br/>      containers:<br/>        - name: keyvault-mi<br/>          image: eggboy/keyvault-mi:0.0.3<br/>          imagePullPolicy: Always<br/>          env:<br/>            - name: MANAGED_IDENTITY_CLIENT_ID<br/>              value:<br/>            - name: KEYVAULT_URI<br/>              value:<br/>      restartPolicy: Always<br/>  selector:<br/>    matchLabels:<br/>      app: keyvault-mi</span></pre><p id="9d4f" class="pw-post-body-paragraph jl jm io jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki ih bi translated">通过查看两个 CRD，<code class="fe mp mq mr mg b">azureidentity</code>和<code class="fe mp mq mr mg b">azureidentitybinding</code>，您可以看到它们是如何绑定在一起的。(kubectl get azureidentity，azureidentitybinding)如果绑定设置正确，大多数情况下都可以正常工作。但是可能会有一些其他的问题，比如权限、错误的客户端 id 等等。一开始并不明显。在这种情况下，您应该看到在 kube-system 名称空间中运行的<code class="fe mp mq mr mg b">nmi</code> Daemonset 的日志。</p><p id="81ad" class="pw-post-body-paragraph jl jm io jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki ih bi translated">就像我在上面对 App Service 所做的那样，您应该能够访问 actuator 端点来查看它的运行。</p><p id="fc98" class="pw-post-body-paragraph jl jm io jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki ih bi translated"><strong class="jn ip">湛蓝的春云</strong></p><p id="c5fb" class="pw-post-body-paragraph jl jm io jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki ih bi translated">就像我们在 App Service 上做的一样，我们可以在 Azure Portal 上分配托管身份。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="gi gj my"><img src="../Images/8c494bf0ffb19db979503071aa1b5d0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fnERPD1tjLabpWrrVZq4HA.png"/></div></div><figcaption class="kr ks gk gi gj kt ku bd b be z dk translated">蔚蓝春云上的身份</figcaption></figure><h1 id="0bc2" class="kw kx io bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">在没有任何凭据的情况下连接 PostgresSQL</h1><p id="0b4b" class="pw-post-body-paragraph jl jm io jn b jo lu jq jr js lv ju jv jw lw jy jz ka lx kc kd ke ly kg kh ki ih bi translated">我们确实看到，使用托管身份消除了管理凭据以访问密钥库的需要。如果与 Spring Boot 自动配置相结合，这个强大的模式会引入一个引人注目的用例。Azure Key Vault 作为 PropertySource 可以触发数据库等数据服务的自动配置，而无需在应用程序中保留任何凭据。我们将看到一个示例，其中我们将使用 Azure Key Vault 和托管身份连接到 PostgreSQL，而无需在应用程序中持有任何凭据。对于前面的示例应用程序，我们只需要更改两件事情。在<code class="fe mp mq mr mg b">pom.xml</code>中添加 JPA 依赖项来访问 PostgreSQL。</p><pre class="kk kl km kn gu mf mg mh mi aw mj bi"><span id="7ff3" class="mk kx io mg b gz ml mm l mn mo"><em class="lz">&lt;</em>dependency<em class="lz">&gt;<br/>   &lt;</em>groupId<em class="lz">&gt;</em>org.springframework.boot<em class="lz">&lt;/</em>groupId<em class="lz">&gt;<br/>   &lt;</em>artifactId<em class="lz">&gt;</em>spring-boot-starter-data-jpa<em class="lz">&lt;/</em>artifactId<em class="lz">&gt;<br/>&lt;/</em>dependency<em class="lz">&gt;<br/>&lt;</em>dependency<em class="lz">&gt;<br/>   &lt;</em>groupId<em class="lz">&gt;</em>org.postgresql<em class="lz">&lt;/</em>groupId<em class="lz">&gt;<br/>   &lt;</em>artifactId<em class="lz">&gt;</em>postgresql<em class="lz">&lt;/</em>artifactId<em class="lz">&gt;<br/>   &lt;</em>scope<em class="lz">&gt;</em>runtime<em class="lz">&lt;/</em>scope<em class="lz">&gt;<br/>&lt;/</em>dependency<em class="lz">&gt;</em></span></pre><p id="5aa7" class="pw-post-body-paragraph jl jm io jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki ih bi translated">依赖关系中有了 Spring Data JPA，<a class="ae kv" href="https://github.com/spring-projects/spring-boot/blob/main/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jdbc/DataSourceAutoConfiguration.java" rel="noopener ugc nofollow" target="_blank">Data source auto configuration</a>将尝试在启动时自动读取<code class="fe mp mq mr mg b">spring.datasource.url</code>并构建数据源。数据源总共需要 3 个属性，<code class="fe mp mq mr mg b">spring.datasource.url</code>、<code class="fe mp mq mr mg b">spring.datasource.username</code>和<code class="fe mp mq mr mg b">spring.datasource.password</code>，这些是我们需要存储在密钥库中的内容。不过有一个小问题，因为密钥库不允许“.”所以我们应该用'-'来代替它。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="mt mu l"/></div></figure><p id="b0e9" class="pw-post-body-paragraph jl jm io jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki ih bi translated">就是这样。现在在平台上运行它，并检查日志。使用 Azure Key Vault 提供的凭据成功创建 HikariPool。</p><pre class="kk kl km kn gu mf mg mh mi aw mj bi"><span id="5f8d" class="mk kx io mg b gz ml mm l mn mo">2022-04-20 03:39:34.244  INFO 1 --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Starting...<br/>2022-04-20 03:39:37.888  INFO 1 --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Start completed.<br/>2022-04-20 03:39:37.953  INFO 1 --- [           main] o.hibernate.jpa.internal.util.LogHelper  : HHH000204: Processing PersistenceUnitInfo [name: default]<br/>2022-04-20 03:39:38.000  INFO 1 --- [           main] org.hibernate.Version                    : HHH000412: Hibernate ORM core version 5.6.7.Final<br/>2022-04-20 03:39:38.170  INFO 1 --- [           main] o.hibernate.annotations.common.Version   : HCANN000001: Hibernate Commons Annotations {5.1.2.Final}<br/>2022-04-20 03:39:38.293  INFO 1 --- [           main] org.hibernate.dialect.Dialect            : HHH000400: Using dialect: org.hibernate.dialect.PostgreSQL10Dialect<br/>2022-04-20 03:39:38.971  INFO 1 --- [           main] o.h.e.t.j.p.i.JtaPlatformInitiator       : HHH000490: Using JtaPlatform implementation: [org.hibernate.engine.transaction.jta.platform.internal.NoJtaPlatform]<br/>2022-04-20 03:39:38.985  INFO 1 --- [           main] j.LocalContainerEntityManagerFactoryBean : Initialized JPA EntityManagerFactory for persistence unit 'default'<br/>2022-04-20 03:39:39.063  WARN 1 --- [           main] JpaBaseConfiguration$JpaWebConfiguration : spring.jpa.open-in-view is enabled by default. Therefore, database queries may be performed during view rendering. Explicitly configure spring.jpa.open-in-view to disable this warning</span></pre><p id="0aa8" class="pw-post-body-paragraph jl jm io jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki ih bi translated">如果你理解了这个基本概念，你就可以创造性地将它与其他服务结合起来。这种模式可以帮助在 Azure 上构建生产应用程序，在<a class="ae kv" href="https://12factor.net/" rel="noopener ugc nofollow" target="_blank"> 12 因素应用</a>方法中有一个很好的参考。<a class="ae kv" href="https://12factor.net/" rel="noopener ugc nofollow" target="_blank"> 12 因素应用</a>中的第四个因素是后台服务，被描述为“可以分离当前生产数据库，并附加新数据库—所有这些都无需任何代码更改。”更改密钥库中的凭据可以有效地分离/附加到新数据库，而无需任何代码更改。我相信，对于这种模式，在 Azure 上使用带有托管身份的密钥库是最优雅、最安全的方式。</p><h1 id="74b6" class="kw kx io bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">包扎</h1><p id="382b" class="pw-post-body-paragraph jl jm io jn b jo lu jq jr js lv ju jv jw lw jy jz ka lx kc kd ke ly kg kh ki ih bi translated">使用 MI 访问资源是生产 Azure 客户最流行的模式。例如，如果您查看 Hashicorp Vault(Azure Key Vault 等价物)的<a class="ae kv" href="https://www.vaultproject.io/docs/auth/azure" rel="noopener ugc nofollow" target="_blank">身份验证方法</a>，您不会对它也使用托管身份感到惊讶。希望这篇文章能帮助 Java 开发者在 Azure 上写好生产代码。</p></div><div class="ab cl mz na hs nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ih ii ij ik il"><p id="4e6b" class="pw-post-body-paragraph jl jm io jn b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki ih bi translated">如果你喜欢我的文章，请留下一些掌声，或者开始关注我。可以上<a class="ae kv" href="https://www.linkedin.com/in/cloudnativejay/" rel="noopener ugc nofollow" target="_blank"><strong class="jn ip">Linkedin</strong></a><strong class="jn ip">找我。谢谢！</strong></p></div></div>    
</body>
</html>