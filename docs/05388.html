<html>
<head>
<title>Navigating lists in Jetpack Compose with LazyListState</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用LazyListState编写Jetpack中的导航列表</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/navigating-lists-in-jetpack-compose-with-lazyliststate-b416d7448014?source=collection_archive---------2-----------------------#2021-08-02">https://blog.devgenius.io/navigating-lists-in-jetpack-compose-with-lazyliststate-b416d7448014?source=collection_archive---------2-----------------------#2021-08-02</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/b1820a254e29114d1f36ca9995b3d7d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GzyZ7M7WsZK40yklVvotaw.png"/></div></div></figure><div class=""/><p id="a28b" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当Jetpack Compose还处于alpha阶段时，我立刻被一个简单的演示所吸引:用LazyColumn替换RecyclerView。需要RecyclerView 5个文件的事情，LazyColumn用5行就能完成。</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="d463" class="lc ld iy ky b gy le lf l lg lh">LazyColumn {<br/>  items(data) {<br/>    ListItem(it)<br/>  }<br/>}</span></pre><p id="a99e" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">LazyColumn的生产率和开发人员体验的提高是惊人的，而且对于基本用例来说，它非常简单。<a class="ae li" href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/lazy/LazyListState" rel="noopener ugc nofollow" target="_blank"> LazyListState </a>更上一层楼。在本文中，我将向您介绍LazyListState的几个最有用的特性。</p><h1 id="0e68" class="lj ld iy bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">正在设置</h1><p id="4fc5" class="pw-post-body-paragraph jv jw iy jx b jy mg ka kb kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated">使用LazyListState非常简单，只需用<code class="fe ml mm mn ky b">rememberLazyListState()</code>创建一个有状态的LazyListState实例，并将其传递给你的LazyColumn。</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="9a19" class="lc ld iy ky b gy le lf l lg lh">val listState = <!-- -->rememberLazyListState<!-- -->()<br/>LazyColumn(listState = listState)</span></pre><p id="b7ef" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">就是这样！现在我们准备开始使用我们的LazyListState。</p><h1 id="24be" class="lj ld iy bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">性能</h1><p id="729d" class="pw-post-body-paragraph jv jw iy jx b jy mg ka kb kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated">LazyListState有3个非常有用的属性:<code class="fe ml mm mn ky b">firstVisibleItemIndex</code>、<code class="fe ml mm mn ky b">firstVisibleItemScrollOffset</code>和<code class="fe ml mm mn ky b">isScrollInProgress</code>。</p><p id="9b51" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">顾名思义，<code class="fe ml mm mn ky b">firstVisibleItemIndex</code>返回屏幕上第一个可见项目的索引。这类似于RecyclerView的LayoutManager的<code class="fe ml mm mn ky b">findFirstVisibleItemPosition()</code>，但是增加了一个强大的合成功能，它可以反映任何给定时间的状态，因此当底层状态发生变化时，它会强制进行重组。例如，在下面的代码片段中，我们的文本composable将始终显示第一个可见项的索引，并在用户滚动LazyColumn时自动更新。</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="ace0" class="lc ld iy ky b gy le lf l lg lh">val listState = <!-- -->rememberLazyListState<!-- -->()<br/>...<br/>Text(text = "First index: ${listState.firstVisibleItemIndex}")</span></pre><p id="c47a" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">没有滚动侦听器，没有更新文本的调用，没有无效视图。由于Compose的声明性范式，读取<code class="fe ml mm mn ky b">firstVisibleItemIndex</code>确保您的UI总是反映最新的数据。</p><p id="beae" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">类似地，<code class="fe ml mm mn ky b">firstVisibleItemScrollOffset</code>反映第一个可见项目的顶部和第一个可见像素之间的像素距离。例如，如果您跳到列表中索引3处的项目，然后向下滚动135像素，<code class="fe ml mm mn ky b">firstVisibleItemScrollOffset</code>将是135。当您在项目边界上滚动时，该属性会自动重置。因此，在前面的例子中，如果索引3处的项目只有100像素高，那么在我们滚动135像素后，<code class="fe ml mm mn ky b">firstVisibleItemIndex</code>将是4，<code class="fe ml mm mn ky b">firstVisibleItemScrollOffset</code>将是35。与RecyclerView相比，这是一个显著的改进，RecyclerView令人困惑的是，它没有保持自己的滚动偏移量，手动跟踪是一个噩梦。</p><p id="5c70" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">第三个有用的属性是<code class="fe ml mm mn ky b">isScrollInProgress</code>，它根据当前是否有滚动正在进行而返回true或false。同样，因为Compose是声明性的，而LazyListState是有状态的，所以它总是反映最新的数据。一个方便的用例可能是每当用户滚动时显示当前滚动位置的标题横幅。</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="362a" class="lc ld iy ky b gy le lf l lg lh">if (listState.isScrollInProgress) {<br/>    val currentItem = items[listState.firstVisibleItemIndex]<br/>    HeaderBanner(currentItem)<br/>}</span></pre><h1 id="db7e" class="lj ld iy bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">卷动</h1><p id="4f96" class="pw-post-body-paragraph jv jw iy jx b jy mg ka kb kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated">LazyListState还允许您使用<code class="fe ml mm mn ky b">scrollToItem()</code>将LazyColumn滚动到特定位置。<code class="fe ml mm mn ky b">scrollToItem()</code>需要一个参数<code class="fe ml mm mn ky b">index</code>，并允许一个可选的第二参数<code class="fe ml mm mn ky b">scrollOffset</code>。正如您可能已经猜到的那样，将这个函数与我们上面看到的属性结合起来，可以让我们保存和调用我们确切的滚动位置。</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="8259" class="lc ld iy ky b gy le lf l lg lh">// Save the current scroll position to a Datastore, database, etc.</span><span id="d6af" class="lc ld iy ky b gy mo lf l lg lh">saveScrollPosition(<br/>  listState.firstVisibleItemIndex,<br/>  listState.firstVisibleItemScrollOffset<br/>)</span><span id="0103" class="lc ld iy ky b gy mo lf l lg lh">...</span><span id="69fe" class="lc ld iy ky b gy mo lf l lg lh">// And recall the previous scroll position</span><span id="77a8" class="lc ld iy ky b gy mo lf l lg lh">val index = ...<br/>val offset = ...</span><span id="4112" class="lc ld iy ky b gy mo lf l lg lh">listState.scrollToItem(index, offset)</span></pre><p id="3de7" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">需要注意的是<code class="fe ml mm mn ky b">scrollToItem()</code>是一个挂起函数，因此必须从协程范围内调用。这很容易用<code class="fe ml mm mn ky b">rememberCoroutineScope()</code>组合。所以一个真实的例子应该是这样的:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="64b9" class="lc ld iy ky b gy le lf l lg lh">val coroutineScope = rememberCoroutineScope()<br/>val listState = rememberLazyListState()</span><span id="fb69" class="lc ld iy ky b gy mo lf l lg lh">...</span><span id="7aac" class="lc ld iy ky b gy mo lf l lg lh">coroutineScope.launch {<br/>    listState.scrollToItem(index, offset)<br/>}</span></pre><p id="5be2" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe ml mm mn ky b">scrollToItem()</code>可以在响应用户交互(如点击按钮或拖动滑块)时调用，也可以在启动时调用。如果您在发布时调用它，有两个重要的细节需要注意。首先，<a class="ae li" href="https://developer.android.com/jetpack/compose/side-effects" rel="noopener ugc nofollow" target="_blank">组件应该没有副作用</a>，因此您的协程应该从<a class="ae li" href="https://developer.android.com/jetpack/compose/side-effects#launchedeffect" rel="noopener ugc nofollow" target="_blank"> LaunchedEffect </a>启动。第二，<code class="fe ml mm mn ky b">rememberLazyListState()</code>接受两个可选参数作为初始索引和滚动偏移量。因此，在上面的例子中，我们在启动时加载前一个滚动位置，从存储中加载索引和偏移量，并在创建LazyListState时将它们传递给more函数可能更有意义:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="e6ba" class="lc ld iy ky b gy le lf l lg lh">val savedIndex = ...<br/>val savedOffset = ...<br/><br/>val listState = rememberLazyListState(savedIndex, savedOffset)</span></pre><p id="85d0" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后需要注意的是，LazyListState还提供了一个函数<code class="fe ml mm mn ky b">animateScrollToItem()</code>。这与<code class="fe ml mm mn ky b">scrollToItem()</code>的行为完全一样，除了它将激活滚动事件，而不是立即跳到新位置。</p><p id="ae9e" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="mp">关注更多关于Kotlin和Android开发的最佳实践。</em></p></div></div>    
</body>
</html>