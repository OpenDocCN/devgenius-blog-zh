<html>
<head>
<title>My Experience With Vue 3 and Typescript So Far</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">到目前为止，我使用Vue 3和Typescript的经验</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/my-experience-with-vue-3-and-typescript-so-far-564bb65d4e39?source=collection_archive---------1-----------------------#2020-10-22">https://blog.devgenius.io/my-experience-with-vue-3-and-typescript-so-far-564bb65d4e39?source=collection_archive---------1-----------------------#2020-10-22</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/0604ccb66b21f04df15a80b2f7dd8d7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NyisOzgsS8_al3RRw-pLgw.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated"><a class="ae jz" href="https://unsplash.com/photos/C7jBZEGciCU" rel="noopener ugc nofollow" target="_blank">https://unsplash.com/photos/C7jBZEGciCU</a></figcaption></figure><blockquote class="ka kb kc"><p id="e012" class="kd ke kf kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ig bi translated">本文原载于我的博客:<a class="ae jz" href="https://marvinblum.de/blog/my-experience-with-vue-3-and-typescript-so-far-bZ1DQzJdjK" rel="noopener ugc nofollow" target="_blank">https://Marvin Blum . de/blog/my-experience-with-vue-3-and-typescript-so-far-bZ1DQzJdjK</a></p></blockquote><p id="a368" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">我最近开始为<a class="ae jz" href="https://pirsch.io/" rel="noopener ugc nofollow" target="_blank"> Pirsch </a>开发用户界面，很高兴听到Vue 3 <a class="ae jz" href="https://news.vuejs.org/issues/186" rel="noopener ugc nofollow" target="_blank">已经正式发布</a>并标记为生产就绪。虽然大多数其他核心库，如vue-router和vuex，仍处于测试阶段，但我不想在Vue 2上构建。不要误解我，Vue 2是一个很好的框架并且很稳定，但是我对我构建前端的方法不再满意了。</p><p id="063a" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">这篇文章是关于过渡到一个新的项目设置，我在Vue 3中的第一步，以及我使用它和TypeScript的经验。我将提供代码示例，并强调几个我认为有用且令人耳目一新的特性。</p><h1 id="9c41" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">一些背景</h1><p id="af08" class="pw-post-body-paragraph kd ke in kg b kh md kj kk kl me kn ko lc mf kr ks ld mg kv kw le mh kz la lb ig bi translated">当他们从版本1过渡到版本2时，我开始学习Vue，并且我很快建立了自己的设置，忽略了通过vue-cli设置项目的默认方式。然而，这一次，我只是想使用现有的东西，而不是用我的头脑去建立像webpack这样的东西。此外，我想尝试一下TypeScript，这是我很久以来一直回避的东西，主要是因为我认为它会在普通的JavaScript之上增加一个额外的抽象层，这对我来说似乎是不必要的。我们最近开始开发一款名为<a class="ae jz" href="https://pirsch.io/" rel="noopener ugc nofollow" target="_blank"> Pirsch </a>的新产品，它的前端相当简单，我借此机会尝试了一些新东西。由于我是打字初学者，如果你发现任何奇怪或明显的错误，请告诉我。</p><h1 id="7092" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">设置</h1><p id="f0db" class="pw-post-body-paragraph kd ke in kg b kh md kj kk kl me kn ko lc mf kr ks ld mg kv kw le mh kz la lb ig bi translated">建立一个新的Vue 3项目的最好方法是安装并使用<a class="ae jz" href="https://cli.vuejs.org/" rel="noopener ugc nofollow" target="_blank"> vue-cli </a>。</p><figure class="mj mk ml mm gt jo gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/6d97e04d9ea569e59eba6e909fd37391.png" data-original-src="https://miro.medium.com/v2/resize:fit:962/format:webp/0*Ztrm8K9NhjLdlW88.png"/></div></figure><p id="253b" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">运行<code class="fe mn mo mp mq b">vue create &lt;name&gt;</code>设置一个新项目。</p><p id="88a0" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">该命令将在<code class="fe mn mo mp mq b">test-app</code>目录下生成一个新项目，并创建基本结构。请注意，您必须在开始时从<code class="fe mn mo mp mq b">Manually select features</code>选项中选择Vue 3和TypeScript，因为它仍然被标记为实验性的。</p><figure class="mj mk ml mm gt jo gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/535eac5d8c5aec88c9c0e3adea7870e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:462/format:webp/0*yeNZyY1hg6Dvpc4d.png"/></div></figure><p id="b6b2" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">新Vue 3项目的现成项目结构。</p><p id="313f" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">到目前为止没有什么令人惊讶的，但真正让我惊讶的是一切开箱即用。我曾经有两个命令，一个用于构建Vue应用程序本身，一个用于编译Sass文件。有了这个新的设置，我只需将文件放在<code class="fe mn mo mp mq b">public</code>目录中，它们就会被自动编译成CSS。</p><p id="9ae4" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">我所做的唯一更改是删除了<code class="fe mn mo mp mq b">assets</code>文件夹，并向<code class="fe mn mo mp mq b">package.json</code>添加了一个命令，以便在发生变化时进行重建(build仍然用于产品发布)。</p><figure class="mj mk ml mm gt jo gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/7be9d48a05ecc517dc9682451b943790.png" data-original-src="https://miro.medium.com/v2/resize:fit:1212/format:webp/0*tx9Whq3EEY9PGkX4.png"/></div></figure><p id="33e1" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">非常精瘦的<code class="fe mn mo mp mq b">package.json</code>。</p><p id="282b" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">我过去常常将我的应用程序嵌入到一个定制的Go服务器中，以控制配置、标题、文件提供方式、更简单的部署，当然还可以添加一些功能。默认情况下，<code class="fe mn mo mp mq b">build</code>和<code class="fe mn mo mp mq b">watch</code>命令会将编译后的文件放到根目录下的<code class="fe mn mo mp mq b">dist</code>文件夹中。应用程序本身是Go服务器的一个子目录。</p><figure class="mj mk ml mm gt jo gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/97d48174f8e17a8ed27e50fdef6144b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:764/format:webp/0*3paP2Ahq3aA2v9qC.png"/></div></figure><p id="c914" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">之前，我只是服务于整个UI目录，但这次我必须选择<code class="fe mn mo mp mq b">dist</code>下的目录才能使其工作。</p><pre class="mj mk ml mm gt mu mq mv mw aw mx bi"><span id="884a" class="my lg in mq b gy mz na l nb nc">server.ServeStaticFiles(router, "/js/", "ui/dist/js")<br/>server.ServeStaticFiles(router, "/css/", "ui/dist/css")<br/>server.ServeStaticFiles(router, "/img/", "ui/dist/img")<br/>server.ServeStaticFiles(router, "/fonts/", "ui/dist/fonts")<br/>router.HandleFunc("/favicon.ico", func(w http.ResponseWriter, r *http.Request) {<br/>    http.ServeFile(w, r, "ui/dist/favicon.ico")<br/>})<br/>router.PathPrefix("/").HandlerFunc(func(w http.ResponseWriter, r *http.Request) {<br/>    http.ServeFile(w, r, "ui/dist/index.html")<br/>})</span></pre><p id="470b" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">注意<code class="fe mn mo mp mq b">ui/public</code>的每个子目录都会在<code class="fe mn mo mp mq b">dist</code>内部创建一个目录，所以你需要在Go中将其添加到路由器中。<code class="fe mn mo mp mq b">favicon </code>和<code class="fe mn mo mp mq b">index.html </code>是我目前仅有的特殊文件。索引是最后提供的，因为无论访问者在哪个页面，都需要发送索引。如果有人访问<code class="fe mn mo mp mq b">yourdomain.com/foo/bar</code>，服务器会尝试在<code class="fe mn mo mp mq b">foo/bar</code>中查找索引文件。</p><h1 id="3f3d" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">组合API</h1><p id="45ec" class="pw-post-body-paragraph kd ke in kg b kh md kj kk kl me kn ko lc mf kr ks ld mg kv kw le mh kz la lb ig bi translated">您可能已经听说过复合API。这是一种定义组件结构和行为的新方法，与使用对象符号定义组件的传统方法并存。我开始只是使用Composition API来设定目标，因为我看过的视频看起来很有希望。你仍然可以使用传统的方式来定义你的组件，但是到目前为止，我对此非常满意。万一你打算从Vue 2升级，你不需要重写一切。但是如果你开始一个新项目，我会建议你马上使用Vue 3。</p><p id="9879" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">我是在不得不实施多次下拉的时候爱上的。这是Pirsch的一个例子，当我构建菜单时，必须添加四个下拉菜单，它们在功能上是一样的。</p><figure class="mj mk ml mm gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nd"><img src="../Images/8ee3859698bc08dcc37245a205a7f7c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Bwnt5nFEdeTui5ot.jpeg"/></div></div></figure><p id="2442" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">皮尔希菜单的早期版本。</p><p id="5d25" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">有一个用于域、资源、时间框架和您的帐户的下拉列表。从功能上讲，它们都是一样的。你点击菜单项，它就打开了。如果您单击下拉列表之外的任何地方，它将关闭。解决这个问题的一种方法是创建一个组件并在任何地方重用它，但是在这种情况下，HTML结构略有不同。有了新的Composition API，你可以将这个问题外包到它自己的文件和函数中，并在你需要的组件中使用它。</p><pre class="mj mk ml mm gt mu mq mv mw aw mx bi"><span id="15e9" class="my lg in mq b gy mz na l nb nc">import {ref, Ref} from "vue";</span><span id="ddae" class="my lg in mq b gy ne na l nb nc">// This defines which attributes and functions will be available to the component.<br/>interface Dropdown {<br/>    dropdownElement: Ref&lt;HTMLElement&gt;<br/>    dropdown: Ref&lt;boolean&gt;<br/>    toggleDropdown(): void<br/>}</span><span id="f910" class="my lg in mq b gy ne na l nb nc">// And this is the re-usable function which will be called from the components.<br/>export function useDropdown(): Dropdown {<br/>    const dropdownElement = ref(document.createElement("div"));<br/>    const dropdown = ref(false);</span><span id="a90e" class="my lg in mq b gy ne na l nb nc">    function toggleDropdown() {<br/>        dropdown.value = !dropdown.value;<br/>    }</span><span id="7502" class="my lg in mq b gy ne na l nb nc">    window.addEventListener("mouseup", e =&gt; {<br/>        const element = dropdownElement.value;</span><span id="38fd" class="my lg in mq b gy ne na l nb nc">        if(/* ... */) {<br/>            dropdown.value = false;<br/>        }<br/>    });</span><span id="6560" class="my lg in mq b gy ne na l nb nc">    return {<br/>        dropdownElement,<br/>        dropdown,<br/>        toggleDropdown<br/>    };<br/>}</span></pre><p id="b0d9" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">作为一个例子，这是你可以在上面的截图中看到的域选择。</p><pre class="mj mk ml mm gt mu mq mv mw aw mx bi"><span id="262c" class="my lg in mq b gy mz na l nb nc">&lt;template&gt;<br/>    &lt;div class="selection cursor-pointer" v-on:click="toggleDropdown" ref="dropdownElement"&gt;<br/>        &lt;span&gt;{{activeDomain.hostname}}&lt;/span&gt;<br/>        &lt;div class="dropdown" v-show="dropdown"&gt;<br/>            &lt;div v-for="domain in domains"<br/>                 :key="domain.id"<br/>                 v-on:click="switchDomain(domain)"&gt;{{domain.hostname}}&lt;/div&gt;<br/>        &lt;/div&gt;<br/>    &lt;/div&gt;<br/>&lt;/template&gt;</span><span id="7a9b" class="my lg in mq b gy ne na l nb nc">&lt;script lang="ts"&gt;<br/>    import /* ... */;</span><span id="bfe8" class="my lg in mq b gy ne na l nb nc">    export default defineComponent({<br/>        setup() {<br/>            /* ... */</span><span id="221d" class="my lg in mq b gy ne na l nb nc">            return {<br/>                ...useDropdown(),<br/>                /* ... */<br/>            };<br/>        }<br/>    });<br/>&lt;/script&gt;</span></pre><p id="f727" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">只需要将函数添加到设置函数的返回语句中，boom！您可以使用模板中的功能。我还有更多这样的例子，但我想你们已经明白了。</p><h1 id="ed86" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">组件结构</h1><p id="05a9" class="pw-post-body-paragraph kd ke in kg b kh md kj kk kl me kn ko lc mf kr ks ld mg kv kw le mh kz la lb ig bi translated">Composition API的另一个主要好处是，您现在可以按照自己想要的方式构建代码。一个组件可能需要数百行代码，这取决于你的应用程序的复杂程度(多亏了Composition API，这应该不会再那么容易了)，你必须以某种方式将数据、方法和其他部分分开。编辑大型组件自然包括大量的滚动，例如，看不到您在方法内部处理的数据。但是，现在您可以在使用数据的函数上方定义数据，并将其混合。所以与其有这样的东西。</p><pre class="mj mk ml mm gt mu mq mv mw aw mx bi"><span id="7c4f" class="my lg in mq b gy mz na l nb nc">&lt;template&gt;<br/>    &lt;!-- lots of code --&gt;<br/>&lt;/template&gt;</span><span id="ad71" class="my lg in mq b gy ne na l nb nc">&lt;script&gt;<br/>    import /* ... */;</span><span id="4da2" class="my lg in mq b gy ne na l nb nc">    export default {<br/>        data() {<br/>            return {<br/>                foo: 42,<br/>                /* far away from each other! */<br/>                bar: ""<br/>            };<br/>        },<br/>        /* maybe even more code */<br/>        methods: {<br/>            methodA() {<br/>                this.foo++;<br/>            },<br/>            /* 500 lines of code */<br/>            methodB() {<br/>                this.bar = "Hello World!";<br/>            }<br/>        }<br/>    }<br/>&lt;/script&gt;</span></pre><p id="dc30" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">您现在可以让它更容易阅读。</p><pre class="mj mk ml mm gt mu mq mv mw aw mx bi"><span id="91cc" class="my lg in mq b gy mz na l nb nc">&lt;template&gt;<br/>    &lt;!-- lots of code --&gt;<br/>&lt;/template&gt;</span><span id="4201" class="my lg in mq b gy ne na l nb nc">&lt;script lang="ts"&gt;<br/>    import /* ... */;</span><span id="734e" class="my lg in mq b gy ne na l nb nc">    export default defineComponent({<br/>        setup() {<br/>            const foo = ref(42);<br/>            <br/>            function methodA() {<br/>            	foo.value++;<br/>            }<br/>            <br/>            /*  500 lines of code */<br/>            <br/>            const bar = ref("");<br/>            <br/>            function methodB() {<br/>            	bar.value = "Hello World!";<br/>            }<br/>            <br/>            return {<br/>            	foo,<br/>                methodA,<br/>                bar,<br/>                methodB<br/>            };<br/>        }<br/>    });<br/>&lt;/script&gt;</span></pre><p id="9797" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">您甚至不需要向模板公开所有数据。想象一下<code class="fe mn mo mp mq b">foo</code>只是内部使用。你仍然需要在<code class="fe mn mo mp mq b">data</code>中定义它来访问它。现在，你可以在<code class="fe mn mo mp mq b">setup</code>中使用一个常规变量。</p><h1 id="998b" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">带类型脚本的泛型</h1><p id="c407" class="pw-post-body-paragraph kd ke in kg b kh md kj kk kl me kn ko lc mf kr ks ld mg kv kw le mh kz la lb ig bi translated">另一个让我对自己使用TypeScript的选择感到非常满意的时刻是我必须实现列表的时候。列表通常用于显示表格中的数据。它们通常由“我的应用程序”中的“卡片”组成，显示它是什么，以及一些额外的字段和按钮来编辑或从列表中删除它们。</p><figure class="mj mk ml mm gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nf"><img src="../Images/a15c493de6f83b04a5e75f963ee9c6bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*yPDawOuQHopq6v6N.png"/></div></div></figure><p id="d764" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">我知道此刻这看起来不太好…</p><p id="d55c" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">由于列表是在页面上使用的，我不想一遍又一遍地重复实现它们。您可能会猜到我使用了组合API来实现该行为，但是这次它必须是通用的。</p><p id="c08a" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">打字稿的优势是…你知道…检查类型。所以我们想建立一个类型保存的可重用函数。正如你在上面看到的，它需要支持<code class="fe mn mo mp mq b">User</code>类型，还有<code class="fe mn mo mp mq b">Client</code>类型。为此，您可以使用泛型。</p><pre class="mj mk ml mm gt mu mq mv mw aw mx bi"><span id="7bec" class="my lg in mq b gy mz na l nb nc">interface ListEntry {<br/>    id: number<br/>}</span><span id="d3ad" class="my lg in mq b gy ne na l nb nc">interface List&lt;T extends ListEntry&gt; {<br/>    /* ... */<br/>}</span><span id="a4c0" class="my lg in mq b gy ne na l nb nc">export function useList&lt;T extends ListEntry&gt;(): List&lt;T&gt; {<br/>    const entries = ref&lt;T[]&gt;([]);<br/>    const selectedEntry = ref&lt;T&gt;();</span><span id="bcff" class="my lg in mq b gy ne na l nb nc">    /*  */</span><span id="b168" class="my lg in mq b gy ne na l nb nc">    return {<br/>        entries,<br/>        selectedEntry,<br/>        /* ... */<br/>    };<br/>}</span></pre><p id="de1c" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">这里的导入部分是<code class="fe mn mo mp mq b">ListEntry</code>，它为我的应用程序中的所有实体定义了一个接口。它们都有一个ID，用于Vue中的<code class="fe mn mo mp mq b">:key</code>属性，也用于在列表中添加和删除条目。下面是你如何利用它。</p><pre class="mj mk ml mm gt mu mq mv mw aw mx bi"><span id="e2cc" class="my lg in mq b gy mz na l nb nc">setup() {<br/>    const {entries, addEntry, removeEntry /* ... */} = useList&lt;User&gt;();<br/>    <br/>    /* ... */<br/>    <br/>    return {<br/>        entries,<br/>        addEntry,<br/>        removeEntry,<br/>        /* ... */<br/>    };<br/>}</span></pre><h1 id="2673" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">模板</h1><p id="c555" class="pw-post-body-paragraph kd ke in kg b kh md kj kk kl me kn ko lc mf kr ks ld mg kv kw le mh kz la lb ig bi translated">模板基本保持不变，但是有一些变化让我更加喜欢Vue 3。对我来说最突出的一点是，你不再需要为你所有的组件都有一个根元素。所以像这样定义组件的模板是没问题的。</p><pre class="mj mk ml mm gt mu mq mv mw aw mx bi"><span id="c58b" class="my lg in mq b gy mz na l nb nc">&lt;template&gt;<br/>    &lt;h2&gt;Email&lt;/h2&gt;<br/>    &lt;form v-on:submit.prevent="save"&gt;<br/>        &lt;FormInput label="Email Address" name="email" type="email" v-model="email" :err="validationError('email')" /&gt;<br/>        &lt;FormSubmit value="Save" /&gt;<br/>    &lt;/form&gt;<br/>&lt;/template&gt;</span><span id="ebd5" class="my lg in mq b gy ne na l nb nc">&lt;script lang="ts"&gt;<br/>    /* ... */<br/>&lt;/script&gt;</span></pre><p id="5694" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">乍一看，这似乎并不重要，但在Vue 2中，有时不得不人为地向组件添加一个根元素，即使它不是样式或结构所必需的。</p><h1 id="0438" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">结论</h1><p id="1fda" class="pw-post-body-paragraph kd ke in kg b kh md kj kk kl me kn ko lc mf kr ks ld mg kv kw le mh kz la lb ig bi translated">我还可以谈很多，比如用linter来保持代码的整洁，但我认为这已经足够了。当我对Vue 3和TypeScript有更多的经验时，我可能会写一篇后续文章。在相当长的一段时间里，我拒绝转换到可能被认为是最佳实践的方法。如果你和我一样，需要知道所有东西是如何工作的，甚至是项目设置，确保你不要浪费时间去做这些，而是花时间去做一些有用的事情。</p><p id="73a1" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko lc kq kr ks ld ku kv kw le ky kz la lb ig bi translated">如果你现在有了尝试Vue 3的灵感，你可以阅读<a class="ae jz" href="https://v3.vuejs.org/guide/migration/introduction.html#render-function" rel="noopener ugc nofollow" target="_blank">的介绍</a>，它比我更好地展示了Vue 2和3之间的主要和次要差异。</p></div></div>    
</body>
</html>