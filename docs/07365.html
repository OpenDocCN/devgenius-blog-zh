<html>
<head>
<title>Building Web Service with NodeJS — Part 5 (Pagination, Data Transfer Object)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 NodeJS 构建 Web 服务—第 5 部分(分页、数据传输对象)</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/building-web-service-with-nodejs-part-5-pagination-data-transfer-object-c5fbf7bd21f1?source=collection_archive---------0-----------------------#2022-03-19">https://blog.devgenius.io/building-web-service-with-nodejs-part-5-pagination-data-transfer-object-c5fbf7bd21f1?source=collection_archive---------0-----------------------#2022-03-19</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/0d10ed5f29acf665a5bfe4ca2f368f8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TsfmWf-5fbyDUunWzqAb5A.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">NodeJS</figcaption></figure><blockquote class="jz ka kb"><p id="7f0c" class="kc kd ke kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">嗨，读者们，你们好吗？希望你一切都好。</p></blockquote><p id="6a34" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lb kp kq kr lc kt ku kv ld kx ky kz la ig bi translated">欢迎回到 NodeJS 教程的第 5 部分。在我们的<a class="ae le" href="https://bitsizelearning.medium.com/building-web-service-with-nodejs-part-4-connecting-to-database-3daca3ff49ae" rel="noopener">前一部分中，</a>我们将应用程序连接到 MongoDB，并利用它来创建和读取数据。在这一部分，我们将主要尝试再次重构我们的代码，使它们更具可读性和可维护性。在这个过程中，我将介绍<strong class="kf io">数据传输对象</strong>。</p><p id="7ffe" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lb kp kq kr lc kt ku kv ld kx ky kz la ig bi translated">如果您需要上一篇第 4 部分的代码，请在这里查看<a class="ae le" href="https://github.com/bitsizelearning/icecream-store/tree/part4" rel="noopener ugc nofollow" target="_blank"/><strong class="kf io">。<br/> </strong>第 5 部分的完整代码可以在<a class="ae le" href="https://github.com/bitsizelearning/icecream-store/tree/part5" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><h1 id="a1a4" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">术语</h1><p id="9e07" class="pw-post-body-paragraph kc kd in kf b kg md ki kj kk me km kn lb mf kq kr lc mg ku kv ld mh ky kz la ig bi translated">在这部分之前，我们已经使用了类似于<strong class="kf io">方法</strong>或请求<strong class="kf io">主体</strong>的术语。我将简单地列出一些 REST API 端点的术语，这样我们就不会有误解。看看下面这些我们会经常用到的术语。</p><figure class="mj mk ml mm gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mi"><img src="../Images/9b010f1adfed21cfcffe07a5682085e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BfJzoO6bBy113_beXW5hCw.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">REST API 端点术语</figcaption></figure><h1 id="8565" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated"><strong class="ak">从我们停止的地方继续</strong></h1><p id="a077" class="pw-post-body-paragraph kc kd in kf b kg md ki kj kk me km kn lb mf kq kr lc mg ku kv ld mh ky kz la ig bi translated">到目前为止，我们已经创建了用于创建(POST)和读取(find all &amp; one) (GET)操作的 API。让我们看一看其中的每一个，看看我们可以改进什么。</p><h2 id="f871" class="mn lg in bd lh mo mp dn ll mq mr dp lp lb ms mt lt lc mu mv lx ld mw mx mb my bi translated">获取所有菜单(获取/菜单)</h2><p id="7125" class="pw-post-body-paragraph kc kd in kf b kg md ki kj kk me km kn lb mf kq kr lc mg ku kv ld mh ky kz la ig bi translated">在我们的 get all menus API 处理程序中，我们使用 Menu.find 方法来检索数据库中的所有菜单并在响应中发送它们。有什么不好？到目前为止，似乎没有什么问题，因为我们在数据库中只有一个菜单记录(香草冰淇淋)。然而，在现实世界中，我们的数据库中可能有更多的记录。现实世界中的一个例子可能是存储(数百万甚至数十亿)交易记录的银行服务。如果我们一次性检索所有记录，服务器将会内存不足而崩溃。</p><p id="c20b" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lb kp kq kr lc kt ku kv ld kx ky kz la ig bi translated">那我们该怎么办？通常，我们会为这样的 get all APIs 做<strong class="kf io">分页</strong>。在 API 请求中，我们需要发送哪个<strong class="kf io">页面</strong>以及一个页面中我们想要检索多少项(<strong class="kf io">限制</strong>)。这些信息作为一个<strong class="kf io">查询</strong>放入请求 URL 中。网址看起来像这样<strong class="kf io">获取/菜单？page=1 &amp; limit=10 </strong>。页面和限制可以在<strong class="kf io"> req.query </strong>我们的处理函数中找到。然后，我们使用<strong class="kf io">跳过</strong>和<strong class="kf io">限制</strong>在我们的 Menu.find 调用之后。我们最终会像遵循代码一样。</p><pre class="mj mk ml mm gt mz na nb nc aw nd bi"><span id="0670" class="mn lg in na b gy ne nf l ng nh">router.get('/', async (req, res, next) =&gt; {<br/>  try {<br/>    const { page, limit } = req.query;<br/>    const menus = await Menu.find()<br/>      .skip((page - 1) * limit)<br/>      .limit(limit);</span><span id="ec2d" class="mn lg in na b gy ni nf l ng nh">    res.json({<br/>      data: menus,<br/>    });<br/>  } catch (error) {<br/>    next(error);<br/>  }<br/>});</span></pre><p id="46ff" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lb kp kq kr lc kt ku kv ld kx ky kz la ig bi translated">如果我们在响应中包含我们的分页信息，以便 API 消费者知道他们在哪个<strong class="kf io">页面</strong>，<strong class="kf io">有多少记录</strong> <strong class="kf io"> &amp; </strong> <strong class="kf io">页面</strong>，这通常也是一个好主意。为此，我们还需要用<strong class="kf io"> Menu.count </strong>从数据库中获取计数。为了构建我们的分页信息，让我们在 lib 文件夹中创建一个<strong class="kf io"> util.js </strong>文件，并在那里创建一个函数。</p><h2 id="f778" class="mn lg in bd lh mo mp dn ll mq mr dp lp lb ms mt lt lc mu mv lx ld mw mx mb my bi translated">src/lib/util.js</h2><pre class="mj mk ml mm gt mz na nb nc aw nd bi"><span id="fcee" class="mn lg in na b gy ne nf l ng nh">export const getPaginationInfo = (page, limit, count) =&gt; {<br/>  return {<br/>    page: +page,<br/>    limit: +limit,<br/>    totalCount: count,<br/>    totalPages: Math.ceil(count / limit),<br/>  };<br/>};</span></pre><p id="5cb1" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lb kp kq kr lc kt ku kv ld kx ky kz la ig bi translated">回到 get all 处理函数中，我们将使用这个函数添加分页信息。我们还要定义 page 和 limit 的默认值，这样，如果请求在查询中没有 page 和 limit，我们仍然可以设置 page 和 limit 值。</p><pre class="mj mk ml mm gt mz na nb nc aw nd bi"><span id="e9b7" class="mn lg in na b gy ne nf l ng nh">import { getPaginationInfo } from '../../lib/util';</span><span id="e89a" class="mn lg in na b gy ni nf l ng nh">...</span><span id="447e" class="mn lg in na b gy ni nf l ng nh">router.get('/', async (req, res, next) =&gt; {<br/>  try {<br/>    const { page = 1, limit = 10 } = req.query;<br/>    const [menus, count] = await Promise.all([<br/>      Menu.find()<br/>        .skip((page - 1) * limit)<br/>        .limit(limit),<br/>      Menu.count(),<br/>    ]);</span><span id="d918" class="mn lg in na b gy ni nf l ng nh">    res.json({<br/>      data: menus,<br/>      pagination: getPaginationInfo(page, limit, count),<br/>    });<br/>  } catch (error) {<br/>    next(error);<br/>  }<br/>});</span></pre><blockquote class="jz ka kb"><p id="6200" class="kc kd ke kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">注意，我们使用<strong class="kf io"> Promise.all </strong>来使查找和计数函数调用<strong class="kf io">异步</strong>。</p></blockquote><p id="b476" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lb kp kq kr lc kt ku kv ld kx ky kz la ig bi translated">我们现在应该在每次点击 API 时获得分页信息。</p><figure class="mj mk ml mm gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nj"><img src="../Images/b561b80bdcd3b894b72a19271cb2c578.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MBmS2B9nVblWa9TR06oS5w.png"/></div></div></figure><p id="de93" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lb kp kq kr lc kt ku kv ld kx ky kz la ig bi translated">我们还能改进什么？如果我们仔细观察从 API 获得的响应数据，我们会看到<strong class="kf io"> _id </strong>和<strong class="kf io"> __v </strong>键。这些键值对是由 MongoDB 生成的。虽然我们需要菜单 id 来引用它们，但我们不需要辅助的 __v 键值。更具体地说，在我们的数据库记录中可能有我们不希望在 API 响应中发送的信息，无论这些信息是否由我们定义。我们没有排除这些信息，而是定义了哪些信息需要作为 API 响应发送。这就是我们需要<strong class="kf io">数据传输对象</strong> ( <strong class="kf io"> DTO </strong> ) <strong class="kf io">的地方。</strong></p><h2 id="d2d8" class="mn lg in bd lh mo mp dn ll mq mr dp lp lb ms mt lt lc mu mv lx ld mw mx mb my bi translated">数据传输对象(DTO)</h2><blockquote class="jz ka kb"><p id="29a5" class="kc kd ke kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">声明，事实上我不知道我对 DTO 的定义是否正确。你可以在谷歌上找到更多关于 DTO 的信息，或者在这里看一下定义。</p></blockquote><p id="c361" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lb kp kq kr lc kt ku kv ld kx ky kz la ig bi translated">数据传输对象是连接领域、业务和应用层的对象。dto 基本上是持有键值对的“哑”对象。</p><blockquote class="jz ka kb"><p id="de8b" class="kc kd ke kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">简单点说，<strong class="kf io">域</strong>是数据库，<strong class="kf io">业务</strong>是我们在处理函数中的逻辑，<strong class="kf io">应用</strong>是我们的 web 服务 API。</p></blockquote><p id="f463" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lb kp kq kr lc kt ku kv ld kx ky kz la ig bi translated">在我们的用例中，我们将为一个菜单创建一个 DTO，它只保存我们需要发送给 API 响应的值。由于我们使用的是 Javascript，这是一种松散类型的语言，为我们的 DTO 创建类(面向对象的方法)是如此的麻烦。相反，让我们创建将 mongoose 文档映射到我们想要的 DTO 的函数。</p><p id="cd91" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lb kp kq kr lc kt ku kv ld kx ky kz la ig bi translated">在 src 文件夹中新建一个名为<strong class="kf io"> dto </strong>的文件夹和一个名为<strong class="kf io"> menu.dto.js </strong>的文件。我们将在这里定义获取 DTO 函数。目前，我们需要我们的菜单模型的 id，名称和描述。</p><h2 id="9901" class="mn lg in bd lh mo mp dn ll mq mr dp lp lb ms mt lt lc mu mv lx ld mw mx mb my bi translated">src/dto/menu.dto.js</h2><pre class="mj mk ml mm gt mz na nb nc aw nd bi"><span id="f531" class="mn lg in na b gy ne nf l ng nh">export const getMenuDTO = (menu) =&gt; ({<br/>  id: menu._id,<br/>  name: menu.name,<br/>  description: menu.description,<br/>});</span></pre><p id="2ee6" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lb kp kq kr lc kt ku kv ld kx ky kz la ig bi translated">在这个过程中，让我们在同一个文件中为整个响应定义 get DTO 函数。这个函数将接收菜单和分页信息。我们还将使用我们刚刚创建的<strong class="kf io"> getMenuDTO </strong>函数来映射菜单中的每个菜单。我们也可以在这个函数中移动它们，而不是在我们的处理函数中构造分页。文件应该是这样结束的。</p><pre class="mj mk ml mm gt mz na nb nc aw nd bi"><span id="6c45" class="mn lg in na b gy ne nf l ng nh">import { getPaginationInfo } from '../lib/util';</span><span id="dd74" class="mn lg in na b gy ni nf l ng nh">export const getMenuDTO = (menu) =&gt; ({<br/>  name: menu.name,<br/>  description: menu.description,<br/>});</span><span id="156d" class="mn lg in na b gy ni nf l ng nh">export const getMenuResponseDTO = (menus, page, limit, count) =&gt; ({<br/>  data: menus.map(getMenuDTO),<br/>  pagination: getPaginationInfo(page, limit, count),<br/>});</span></pre><p id="e905" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lb kp kq kr lc kt ku kv ld kx ky kz la ig bi translated">然后，回到我们的 get all 处理函数，我们只需要调用这个 getMenuResponseDTO 并发送值作为响应。</p><pre class="mj mk ml mm gt mz na nb nc aw nd bi"><span id="1004" class="mn lg in na b gy ne nf l ng nh">import { getMenuResponseDTO } from '../../dto/menu.dto';</span><span id="1814" class="mn lg in na b gy ni nf l ng nh">...</span><span id="30c7" class="mn lg in na b gy ni nf l ng nh">router.get('/', async (req, res, next) =&gt; {<br/>  try {<br/>    const { page = 1, limit = 10 } = req.query;<br/>    const [menus, count] = await Promise.all([<br/>      Menu.find()<br/>        .skip((page - 1) * limit)<br/>        .limit(limit),<br/>      Menu.count(),<br/>    ]);</span><span id="7705" class="mn lg in na b gy ni nf l ng nh">    res.json(getMenuResponseDTO(menus, page, limit, count));<br/>  } catch (error) {<br/>    next(error);<br/>  }<br/>});</span></pre><p id="9ab2" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lb kp kq kr lc kt ku kv ld kx ky kz la ig bi translated">我们现在应该获得 id、名称和描述作为响应值。</p><figure class="mj mk ml mm gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nj"><img src="../Images/d027ff49742b497603ad8f2e28ccef50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pq15h1nM_yumTJbcEX9tUg.png"/></div></div></figure><h2 id="67a0" class="mn lg in bd lh mo mp dn ll mq mr dp lp lb ms mt lt lc mu mv lx ld mw mx mb my bi translated">按 id 获取菜单(GET /menu/:id)</h2><p id="1dc6" class="pw-post-body-paragraph kc kd in kf b kg md ki kj kk me km kn lb mf kq kr lc mg ku kv ld mh ky kz la ig bi translated">对于这个 API，我们还可以为响应创建 DTO。让我们将函数添加回 src/dto/menu.dto.js 中。</p><pre class="mj mk ml mm gt mz na nb nc aw nd bi"><span id="1fce" class="mn lg in na b gy ne nf l ng nh">export const getMenuByIdResponseDTO = (menu) =&gt; ({<br/>  data: getMenuDTO(menu),<br/>});</span></pre><p id="821d" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lb kp kq kr lc kt ku kv ld kx ky kz la ig bi translated">如果找不到 id，我们还有抛出错误的代码。代码有点麻烦，我们需要创建一个错误对象，并向该对象添加状态 404。那么为什么不把未找到的错误定义为一个对象，那么我们只需要在每次出现 404 错误时抛出未找到的错误对象。在 lib 文件夹中创建一个名为<strong class="kf io"> errors.js </strong>的新文件。我们将扩展 javascript Error 类并分配 404 状态。</p><h2 id="6e92" class="mn lg in bd lh mo mp dn ll mq mr dp lp lb ms mt lt lc mu mv lx ld mw mx mb my bi translated">src/lib/errors.js</h2><pre class="mj mk ml mm gt mz na nb nc aw nd bi"><span id="1ce6" class="mn lg in na b gy ne nf l ng nh">export class NotFoundError extends Error {<br/>  constructor(message) {<br/>    super(message);<br/>    this.status = 404;<br/>  }<br/>}</span></pre><p id="c078" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lb kp kq kr lc kt ku kv ld kx ky kz la ig bi translated">回到处理函数中…</p><pre class="mj mk ml mm gt mz na nb nc aw nd bi"><span id="cf88" class="mn lg in na b gy ne nf l ng nh">...<br/>import { getMenuByIdResponseDTO } from '../../dto/menu.dto';<br/>import { NotFoundError } from '../../lib/errors';</span><span id="ede6" class="mn lg in na b gy ni nf l ng nh">...</span><span id="19b5" class="mn lg in na b gy ni nf l ng nh">router.get('/:id', async (req, res, next) =&gt; {<br/>  try {<br/>    const id = req.params.id;<br/>    const menu = await Menu.findOne({ _id: id });<br/>    if (!menu) {<br/>      throw new NotFoundError('Id Not Found');<br/>    }<br/>    res.json(getMenuByIdResponseDTO(menu));<br/>  } catch (err) {<br/>    next(err);<br/>  }<br/>});</span></pre><h2 id="f7c4" class="mn lg in bd lh mo mp dn ll mq mr dp lp lb ms mt lt lc mu mv lx ld mw mx mb my bi translated">创建菜单 API(发布/菜单)</h2><p id="e55d" class="pw-post-body-paragraph kc kd in kf b kg md ki kj kk me km kn lb mf kq kr lc mg ku kv ld mh ky kz la ig bi translated">目前，我们的创建菜单 API 只返回一个成功消息。然而，如果 API 也返回新创建的菜单 id 就更好了。让我们在 menu.dto.js 中为这个 API 创建一个 get DTO 响应函数</p><pre class="mj mk ml mm gt mz na nb nc aw nd bi"><span id="9535" class="mn lg in na b gy ne nf l ng nh">export const getCreateMenuResponseDTO = (menu) =&gt; ({<br/>  message: 'Success create menu',<br/>  id: menu._id,<br/>});</span></pre><p id="0812" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lb kp kq kr lc kt ku kv ld kx ky kz la ig bi translated">现在，在处理函数中，让我们创建一个菜单变量来存储 Menu.create 函数返回值。然后我们可以将这个菜单传递给我们的创建 DTO 函数。</p><pre class="mj mk ml mm gt mz na nb nc aw nd bi"><span id="0f35" class="mn lg in na b gy ne nf l ng nh">import {<br/>  ...<br/>  getMenuResponseDTO,<br/>} from '../../dto/menu.dto';</span><span id="7446" class="mn lg in na b gy ni nf l ng nh">...</span><span id="7ff6" class="mn lg in na b gy ni nf l ng nh">router.post('/', async (req, res, next) =&gt; {<br/>  try {<br/>    const menu = await Menu.create({<br/>      name: req.body.name,<br/>      description: req.body.description,<br/>    });<br/>    res.json(getCreateMenuResponseDTO(menu));<br/>  } catch (error) {<br/>    next(error);<br/>  }<br/>});</span></pre><p id="7e48" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lb kp kq kr lc kt ku kv ld kx ky kz la ig bi translated">让我们尝试创建一个新的冰淇淋菜单。</p><figure class="mj mk ml mm gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nk"><img src="../Images/d42ce9fea274aa04521837b250bfd114.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hHYq9M_hg53fnhBs1i2PZg.png"/></div></div></figure><p id="8f2c" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lb kp kq kr lc kt ku kv ld kx ky kz la ig bi translated">现在，随着成功消息的出现，我们也得到了一个 id 响应。让我们复制这个 id，并尝试将它与 get by id API 一起使用。</p><figure class="mj mk ml mm gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nl"><img src="../Images/18446531445eb32a9fad0ccb14ab04b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SpvhhwI-ssuL3wkRm0lDmw.png"/></div></div></figure><p id="1496" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lb kp kq kr lc kt ku kv ld kx ky kz la ig bi translated">现在，我们应该得到新菜单的 id、名称和描述。</p><p id="7627" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lb kp kq kr lc kt ku kv ld kx ky kz la ig bi translated">至此，我们已经通过创建分页和创建 dto 来重构我们的 API，从而将我们的数据库文档模型连接到我们的 API 响应。让我们把为每个 API 响应创建 d to 作为标准。我知道这有点麻烦，但在真正的生产就绪应用程序中，这是我们通常做的。</p></div><div class="ab cl nm nn hr no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="ig ih ii ij ik"><p id="5290" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lb kp kq kr lc kt ku kv ld kx ky kz la ig bi translated">让我们在这里休息一下。让我们在下一部分完成 CRUD 操作。</p><p id="ddcf" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lb kp kq kr lc kt ku kv ld kx ky kz la ig bi translated">您可以在我的公共 github 资源库中看到完整的第 5 部分代码。<br/> <a class="ae le" href="https://github.com/bitsizelearning/icecream-store/tree/part5" rel="noopener ugc nofollow" target="_blank"> <strong class="kf io">点击这里！</strong>T12】</a></p><p id="383f" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lb kp kq kr lc kt ku kv ld kx ky kz la ig bi translated">谢谢你，希望你喜欢阅读它。有没有什么错误或者是我没有解释清楚的地方？有什么我应该改进的吗？</p><p id="18ed" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn lb kp kq kr lc kt ku kv ld kx ky kz la ig bi translated">如果你愿意的话，给作者留个便条和一些掌声来帮助频道发展。:)</p></div></div>    
</body>
</html>