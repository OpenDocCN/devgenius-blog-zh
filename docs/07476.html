<html>
<head>
<title>Easy Sorting in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在 Go 中轻松排序</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/easy-sorting-in-go-17525f6f900b?source=collection_archive---------8-----------------------#2022-03-28">https://blog.devgenius.io/easy-sorting-in-go-17525f6f900b?source=collection_archive---------8-----------------------#2022-03-28</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/b2d0aa75fdea0708968a90d19142b8e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pW4QjGcV7vgp1G12fS3ltQ.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">玩积木的地鼠。</figcaption></figure><p id="8103" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">排序是开发人员中的一个热门话题。它是计算机科学中最重要的算法之一，因为许多重要的算法都依赖于有序数组。例如，二分搜索法算法通常被认为是最快的搜索方法之一。然而，为了让它工作，我们需要提供一个排序的数组。</p><p id="ad1f" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我不打算在这里深入研究排序算法，因为这超出了本文的范围。但是，这是一个非常有趣的话题，所以你一定要查一下。但是，即使排序算法并不有趣，您也可能遇到过必须对元素列表进行排序的情况。有一种更简单的方法来排序，而不是从头开始实现自己的算法。在这篇文章中，我们将看到如何在 Go 中轻松地排序。尽情享受吧！</p><h1 id="8655" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">使用 Go 标准库中的排序包</h1><p id="2f21" class="pw-post-body-paragraph jz ka in kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ig bi translated">Go 通常对效用函数采取极简主义的方法，所以在很多情况下你必须创建自己的做事方法。例如，没有内置函数来获取数组的最小值或最大值。</p><p id="feab" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">幸运的是，Go 提供了开箱即用的功能，因为排序是如此重要的功能。您可以导入<code class="fe ma mb mc md b">sort</code>包，并使用它的功能。</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="fd22" class="mm ky in md b gy mn mo l mp mq">package main<br/><br/>import (<br/>    "fmt"<br/>    "sort"<br/>)<br/><br/>func main() {<br/>    intSlice := []int{5, 3, 9}<br/>    sort.Ints(intSlice)<br/><br/>    f64Slice := []float64{4.8, 10.5, 7.4}<br/>    sort.Float64s(f64Slice)<br/><br/>    stringSlice := []string{"Banana", "Apple", "Cherry"}<br/>    sort.Strings(stringSlice)<br/><br/>    fmt.Println(intSlice, f64Slice, stringSlice)<br/>}</span><span id="a5df" class="mm ky in md b gy mr mo l mp mq">[3 5 9] [4.8 7.4 10.5] [Apple Banana Cherry]</span></pre><p id="8fd9" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这三个基本的分类将会让你走得很远，但是在这个包中有一段有趣的代码。</p><h1 id="4598" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">排序。连接</h1><p id="a576" class="pw-post-body-paragraph jz ka in kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ig bi translated">有一个接口被定义为<code class="fe ma mb mc md b">sort.Interface</code>。下面是代码的样子。</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="4e8d" class="mm ky in md b gy mn mo l mp mq">type Interface interface {<br/>    Len() int<br/>    Less(i, j int) bool<br/>    Swap(i, j int)<br/>}</span></pre><p id="1df8" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">让我们把它拆开，检查每个功能。</p><ul class=""><li id="4832" class="ms mt in kb b kc kd kg kh kk mu ko mv ks mw kw mx my mz na bi translated"><code class="fe ma mb mc md b">Len()</code>只是告诉你数组的长度。</li><li id="1df1" class="ms mt in kb b kc nb kg nc kk nd ko ne ks nf kw mx my mz na bi translated"><code class="fe ma mb mc md b">Less()</code>获取索引<code class="fe ma mb mc md b">i</code>和<code class="fe ma mb mc md b">j</code>并检查第 I 个元素是否小于第 j 个元素。</li><li id="bbe1" class="ms mt in kb b kc nb kg nc kk nd ko ne ks nf kw mx my mz na bi translated">交换第 I 个和第 j 个元素的顺序。</li></ul><p id="e54f" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">有些人可能已经注意到，这是一个非常容易实现的接口。这是什么意思？</p><h1 id="7f67" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">实现您自己的排序</h1><p id="2e58" class="pw-post-body-paragraph jz ka in kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ig bi translated">是的，您可以创建自定义排序。如果以上三种方法都不适合你的需求，那就创建一个实现<code class="fe ma mb mc md b">sort.Interface</code>的类型，然后对其应用<code class="fe ma mb mc md b">sort.Sort()</code>。这里有一个简单的例子。</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="1d35" class="mm ky in md b gy mn mo l mp mq">package main<br/><br/>import (<br/>    "fmt"<br/>    "sort"<br/>)<br/><br/>type employee struct {<br/>    name string<br/>    lastname string<br/>    age int<br/>    phoneNumber int<br/>}<br/><br/>type employeeDb []employee<br/><br/>// employeeDb implements sort.Interface<br/>func (edb employeeDb) Len() int {<br/>    return len(edb)<br/>}<br/><br/>func (edb employeeDb) Less(i, j int) bool {<br/>    if edb[i].age == edb[j].age {<br/>        if edb[i].lastname == edb[j].lastname {<br/>            return edb[i].name &lt; edb[j].name<br/>        }<br/>        return edb[i].lastname &lt; edb[j].lastname<br/>    }<br/>    return edb[i].age &lt; edb[j].age<br/>}<br/><br/>func (edb employeeDb) Swap(i, j int) {<br/>    edb[i], edb[j] = edb[j], edb[i]<br/>}<br/><br/>func main() {<br/>    myDb := employeeDb{<br/>        {"Jacob", "Kim", 21, 1234567890},<br/>        {"Chris", "Hemsworth", 38, 9375913934},<br/>        {"Robert", "Downey Jr.", 56, 4459183048},<br/>        {"John", "Doe", 22, 4793721933},<br/>        {"Jane", "Doe", 22, 4792091933},<br/>    }<br/>    sort.Sort(myDb)<br/>    for _, v := range myDb {<br/>        fmt.Println(v)<br/>    }<br/>}</span><span id="3077" class="mm ky in md b gy mr mo l mp mq">{Jacob Kim 21 1234567890}<br/>{Jane Doe 22 4792091933}<br/>{John Doe 22 4793721933}<br/>{Chris Hemsworth 38 9375913934}<br/>{Robert Downey Jr. 56 4459183048}</span></pre><p id="16e5" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">唷，那是一大堆要消化的代码。但是我们可以一起看整体流程。</p><ul class=""><li id="8765" class="ms mt in kb b kc kd kg kh kk mu ko mv ks mw kw mx my mz na bi translated">我们定义了一个新的类型<code class="fe ma mb mc md b">employee</code>，它是一个保存雇员姓名、年龄和电话号码的结构。</li><li id="ba7a" class="ms mt in kb b kc nb kg nc kk nd ko ne ks nf kw mx my mz na bi translated">我们还定义了一个新的类型<code class="fe ma mb mc md b">employeeDb</code>，它是一个<code class="fe ma mb mc md b">employee</code>的数组。这个类型实现了<code class="fe ma mb mc md b">sort.Interface</code>，因为它定义了<code class="fe ma mb mc md b">Len()</code>、<code class="fe ma mb mc md b">Less()</code>和<code class="fe ma mb mc md b">Swap</code>。</li><li id="d6ad" class="ms mt in kb b kc nb kg nc kk nd ko ne ks nf kw mx my mz na bi translated"><code class="fe ma mb mc md b">Len()</code>只是返回<code class="fe ma mb mc md b">employeeDb</code>的长度，<code class="fe ma mb mc md b">Swap()</code>只是交换第 I 个和第 j 个元素。<code class="fe ma mb mc md b">Less()</code>有点长但是很简单。我们试图通过先按年龄排序来确定哪个值更大。如果年龄相等，那么我们尝试先按姓氏排序，然后按名字排序。</li><li id="2f37" class="ms mt in kb b kc nb kg nc kk nd ko ne ks nf kw mx my mz na bi translated">当我们<code class="fe ma mb mc md b">sort.Sort()</code>的时候，可以看到员工先按年龄排序。由于无名氏和无名氏年龄相同，所以按姓氏排序。然而，他们也有相同的姓氏！所以它们是按名字排序的。剩下的就不言自明了。</li></ul><p id="2c8b" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我必须说，这是一个很好的分类方法。根据你如何处理<code class="fe ma mb mc md b">Less()</code>，你可以想出一种完全不同的排序方式。</p><h1 id="6636" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">结论</h1><p id="9362" class="pw-post-body-paragraph jz ka in kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ig bi translated">这也是我认为 Go 是一门很酷的语言的原因之一。你可以实现一个接口来享受它的所有功能。这里的要点是，<code class="fe ma mb mc md b">sort</code>包为您提供了基本的排序，如果它们不够，那么实现<code class="fe ma mb mc md b">sort.Interface</code>是一种根据您自己的规则对定制类型进行排序的简单方法。</p><p id="14d2" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">希望这篇帖子有所帮助！你可以在<a class="ae ng" href="https://dev.to/jpoly1219/easy-sorting-in-go-56ae" rel="noopener ugc nofollow" target="_blank"> Dev.to </a>和<a class="ae ng" href="https://jpoly1219.github.io" rel="noopener ugc nofollow" target="_blank"> my personal site </a>上阅读这篇文章。</p></div></div>    
</body>
</html>