<html>
<head>
<title>Creating an Automated Data Processing Pipeline with Apache Airflow, Kubernetes, and R — Part 3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Apache Airflow、Kubernetes 和 R 创建自动化数据处理管道—第 3 部分</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/creating-an-automated-data-processing-pipeline-with-apache-airflow-kubernetes-and-r-part-3-cc2a113e4c27?source=collection_archive---------9-----------------------#2022-02-03">https://blog.devgenius.io/creating-an-automated-data-processing-pipeline-with-apache-airflow-kubernetes-and-r-part-3-cc2a113e4c27?source=collection_archive---------9-----------------------#2022-02-03</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/ee975e8e41135aa4ece4b7ca779ba661.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-3gF9v-BNznlhK7-"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">泰勒·维克在<a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="4014" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在本教程的第一部分的<a class="ae jz" href="https://robert-a-gutierrez.medium.com/creating-an-automated-data-processing-pipeline-with-apache-airflow-kubernetes-and-r-part-1-925f99b812e7#a1b3-e616252e3faa" rel="noopener">中，我们设置了我们的 Cloud Composer 环境，我们的本地环境，并创建了模板库。在第二部分</a>中，我们进入正题:建立我们的第一个容器映像；编写我们的第一个 DAG 和 task 将我们的容器映像、DAG 和任务部署到 Google Cloud 在气流中运行我们的 DAG！</p><p id="40db" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在第三部分，我们将讨论插件。<a class="ae jz" href="https://airflow.apache.org/docs/apache-airflow/stable/plugins.html" rel="noopener ugc nofollow" target="_blank">插件</a>是我们扩展 Airflow 的方式，它们的功能可以包括创建自定义操作符、连接到 CRM 和数据库以及其他外部服务、挂钩和 UI 中的自定义页面。<a class="ae jz" href="https://github.com/airflow-plugins/" rel="noopener ugc nofollow" target="_blank">Github 上有一个很大的插件列表</a>，你可以查看；您可能会在那里找到您需要的东西，但我将带您了解如何创建一个小的 UI 插件:一个“手动触发”页面，它允许您通过使用一个方便的表单来手动触发 DAG，该表单包含每个参数的字段。</p><h1 id="7b2f" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">介绍</h1><p id="6547" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">作为一名开发人员，当手动触发 Airflow 中的 DAG 并需要传递额外的参数时，我可以在触发 DAG 之前将纯 JSON 写入我们的<code class="fe mb mc md me b">conf</code>变量。虽然这样做的界面很简单(一个带有“触发”按钮的文本框)，但它工作得足够好。随着我和我们的分析团队更好地定义我们的自动化管道的技术需求，每当我们触发 DAG 时，我们需要指定某些事情变得很清楚。这个 DAG 是我从去年开始为我们的网络健康调查报告(您可以在此处找到有关该项目的更多详细信息)自动生成数据的努力的高潮，它需要由两个参数触发:哪个调查管理机构引用传入的数据，以及我们正在为哪个学校网络处理数据。旧版本的管道使用来自调查管理部门<em class="mf">所有</em>学校网络的传入数据，而我们希望我们的新管道一次处理一个网络的数据。这样，我们可以为已经完成调查的学校生成报告数据，而不必等待所有学校完成调查。</p><p id="7093" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们最终得到了三个参数:<code class="fe mb mc md me b">instantiator</code>，它表示触发 DAG 的人(以更好地分离云存储中的输出)；<code class="fe mb mc md me b">survey_administration_name</code>，它是我们的网络健康调查门户为特定调查管理机构提供的唯一名称；以及<code class="fe mb mc md me b">network_id</code>，它是标识学校网络的唯一整数。</p><p id="48b1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了让我们的分析人员使用 Airflow 更容易，似乎应该构建某种手动触发表单，用户可以从下拉列表中选择 DAG，查看预期的参数列表，输入值，然后触发 DAG。方便地链接到当前 DAG 运行的图形视图和云存储文件夹，期待输出似乎也是一个好主意。这最终体现在手动触发插件中。</p><p id="fa2d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这段代码的很大一部分来自本教程。我在这里对其进行了扩展，并提供了一些额外的功能。为了简单起见，我将使用本教程前一部分中的示例 DAG，并添加上面提到的参数。</p><h1 id="7868" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">创建气流 UI 插件</h1><p id="c8f7" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">在本教程的前几部分，你已经看到了插件的内容，以及暗示我上面提到的手动触发插件的代码。让我们深入这个插件代码，并解释我们之前看到的那些位。</p><figure class="mh mi mj mk gt jo gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/b6cf4069709da17a7897cf8db33b79ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1048/format:webp/1*3d8loddnanHO4jlkbFtEnA.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">UI 插件的文件夹结构</figcaption></figure><p id="c480" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这种文件夹结构在其他指南中被推荐，我认为它也是有意义的。Airflow UI 是在 Flask 上构建的，因此，与任何其他 Flask 应用程序一样，我们可以为静态资产定义一个位置，为模板定义一个位置，为视图定义一个位置。</p><p id="b050" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">视图模板生成一个具有如下形式的页面:我们的 Airflow 实例中所有 DAG 的下拉列表(默认情况下也可以选择一个)，通过选择一个 DAG，我们可以看到一组与我们为 DAG 指定的参数相匹配的字段。字段可以是必填的，也可以是可选的。在提交表单时，我们被重定向回该页面，但我们看到一条提示消息，通知我们触发成功。该消息读回我们的参数值，并包含一些有用的链接。</p><p id="610c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">view 方法将接受我们的表单提交，过滤我们选择的 DAG，创建我们的自定义运行 ID，然后在将表单数据作为<code class="fe mb mc md me b">conf</code>变量传递时触发 DAG。然后，它会生成结果的快速消息。</p><h2 id="435a" class="ml kz in bd la mm mn dn le mo mp dp li kl mq mr lm kp ms mt lq kt mu mv lu mw bi translated">步骤 1: DAG 触发参数</h2><p id="c142" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">正如我在上面发布的类似教程中所建议的，我已经为我们的 DAG 对象添加了一个新属性，<code class="fe mb mc md me b">trigger_arguments</code>。让我们调出我们的示例 DAG，并将其添加进去。</p><figure class="mh mi mj mk gt jo"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="19f3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe mb mc md me b">trigger_arguments</code>它仅仅是一本为我们的参数定义一些属性的字典吗？表单字段上方有一个用户友好的显示名称，一个字段类型(<code class="fe mb mc md me b">enum</code>用于下拉菜单)，参数名称的复数形式，触发时是否需要，如果没有提供默认值，以及一个显示在表单字段下方的描述。</p><p id="3392" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们已经添加了我上面提到的三个参数。这取决于我们的模板以一种漂亮的方式显示它们。</p><h2 id="a71a" class="ml kz in bd la mm mn dn le mo mp dp li kl mq mr lm kp ms mt lq kt mu mv lu mw bi translated">第二步:模板</h2><p id="5375" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">模板文件使用 Jinja 语法，为了拥有完整的气流 UI，我们需要在文件中包含一些东西。省略它们将意味着一个空白的页面，当你从气流中来到页面时，这是不和谐的。</p><figure class="mh mi mj mk gt jo"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="1ba3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们需要导入一些东西，包括一些块，尽管这是相当标准的东西。我们现在拥有的是一个带有 Dag 下拉列表和一组与这些 Dag 的<code class="fe mb mc md me b">trigger_arguments</code>匹配的字段的表单。一些 Javascript 控制这些字段集的切换以及打开 HTML5 表单验证。还有一点 CSS 的一般样式，我添加了 Bootstrap 的动画微调图标。</p><p id="4b11" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Airflow 使用 Bootstrap 作为它的外观和感觉，所以如果我们愿意，我们可以在布局或页面以及一些 jQuery 中使用 Bootstrap 模式。</p><h2 id="01e9" class="ml kz in bd la mm mn dn le mo mp dp li kl mq mr lm kp ms mt lq kt mu mv lu mw bi translated">第三步:查看方法</h2><p id="390f" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">现在让我们看看我们的视图方法代码。</p><figure class="mh mi mj mk gt jo"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="8953" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这份文件有点长，但我会从头到尾看一遍。</p><p id="4697" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们定义了一个函数来帮助我们正确地触发 DAG，提供 Airflow 期望的所有属性，并将我们提交的参数放入<code class="fe mb mc md me b">conf</code>。然后，我们有一个定义自定义运行 ID 的函数。由 Airflow 创建的默认运行 ID 类似于“&lt;TRIGGER _ TYPE&gt;_&lt;DATETIME _ AS _ ISO&gt;”，所以您最终得到的 ID 类似于</p><pre class="mh mi mj mk gt mz me na nb aw nc bi"><span id="b399" class="ml kz in me b gy nd ne l nf ng">manual__2022-01-27T09:56:01.162295+0000</span></pre><p id="cacb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">首先，日期时间总是采用 UTC 格式，其次，通过查看这个 ID 不可能知道是谁触发了 DAG 运行。因此，我创建了一个自定义的运行 ID，添加了<code class="fe mb mc md me b">instantiator</code>并将日期时间转换为我们的本地时区。您可以将自定义跑步 ID 代码更改为您想要的任何值，只要它是唯一的。</p><p id="a85b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们的<code class="fe mb mc md me b">FlaskAdminTriggerView</code>类中的 view 方法保存了大部分代码，但是它的设置和其他 Flask view 方法一样。我们建立一个 DAG IDs 和它们各自的 trigger_arguments 的字典，然后为任何<code class="fe mb mc md me b">enum</code>类型的参数添加下拉选择。对于<code class="fe mb mc md me b">instanstiator</code>的选择，在 Airflow 中创建一个变量并将列表定义为<code class="fe mb mc md me b">valid_instantiators</code>是有意义的。</p><p id="c794" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当提交表单时，我们只过滤掉我们选择的 DAG 的字段。我们为<code class="fe mb mc md me b">instantiator</code>设置一个默认值，添加我们的<code class="fe mb mc md me b">custom_run_id</code>，然后将其全部发送给我们的触发函数。我们构建了我们漂亮的小 flash 消息，添加了一些有用的链接，然后全部呈现出来。</p><p id="a2c6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在我们得到了我们的<code class="fe mb mc md me b">FlaskAdminTriggerView</code>类的一个实例，这里的属性确保我们可以从导航菜单访问我们的新页面。<code class="fe mb mc md me b">category</code>让我们向导航中的现有下拉菜单添加一个菜单项<em class="mf">或</em>添加一个新的下拉菜单。<code class="fe mb mc md me b">name</code>是菜单项的名称，<code class="fe mb mc md me b">endpoint</code>是页面的路径名。</p><p id="7e82" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">定义一个<code class="fe mb mc md me b">Blueprint</code>让我们使用我们创建的文件夹设置，静态资产和模板被分离出来。如果需要，我们可以在 Docs nav 项下添加一个到 Github repo 的链接。</p><p id="5bea" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最后，我们定义了 plugin 类，它允许我们将插件“插入”到 Airflow 中，这样它就可以加载到 UI 中了。</p><h2 id="ae78" class="ml kz in bd la mm mn dn le mo mp dp li kl mq mr lm kp ms mt lq kt mu mv lu mw bi translated">步骤 parse _ job _ args 任务</h2><p id="913a" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">让我们简单地看一下<code class="fe mb mc md me b">parse_job_args</code>任务，您可能已经在示例 DAG 中看到过，并且包含在<code class="fe mb mc md me b">tasks/common</code>文件夹中。</p><p id="1803" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个特殊任务利用<code class="fe mb mc md me b">PythonOperator</code>及其<code class="fe mb mc md me b">provide_context</code>参数来获取我们提交给<code class="fe mb mc md me b">conf</code>变量的值。</p><figure class="mh mi mj mk gt jo"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="598b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们希望传递给<code class="fe mb mc md me b">conf</code>的参数可以被 DAG 中的所有任务访问，因此我们将利用一个名为 XComs 的气流特性。XComs 基本上形成一个 DAG“状态”, DAG 中的所有任务都可以访问它。它们的工作原理是将变量“推入”状态以存储它们，然后“拉出”它们以读取它们。它们最适合用于小的、可序列化的数据，因此避免推送数据帧或其他大型任务输出。这些可以很容易地上传到云存储，然后由未来的任务下载。</p><p id="c70f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这种情况下，我们希望在 DAG 的第一个任务中推送我们的参数，以便所有其他任务都可以访问这些值。在我们的<code class="fe mb mc md me b">PythonOperator</code>中，我们定义了一个可调用函数，并将<code class="fe mb mc md me b">provide_context</code>设置为<code class="fe mb mc md me b">True</code>。现在，在我们的 callable 中，我们可以访问 Airflow 传递给模板的所有<a class="ae jz" href="https://airflow.apache.org/docs/apache-airflow/stable/templates-ref.html" rel="noopener ugc nofollow" target="_blank">变量。我们将使用<code class="fe mb mc md me b">kwargs</code>作为字典来访问它们。<code class="fe mb mc md me b">conf</code>来自 DAGRun 对象<code class="fe mb mc md me b">dag_run</code>，任务实例<code class="fe mb mc md me b">ti</code>是我们推送 XComs 的地方。</a></p></div><div class="ab cl nh ni hr nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ig ih ii ij ik"><p id="49c6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">既然我们的参数值已经保存，我们如何在其他任务中访问它们呢？我们需要对代码做一点小小的修改。拉起<code class="fe mb mc md me b">tasks/__init__.py</code>，查看<code class="fe mb mc md me b">DEFAULT_ENV_VARS</code>字典。</p><figure class="mh mi mj mk gt jo"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="7c2e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是我隐藏传递给任务的环境变量的地方。正如您可能在<a class="ae jz" href="https://airflow.apache.org/docs/apache-airflow/stable/templates-ref.html" rel="noopener ugc nofollow" target="_blank">气流模板参考页面</a>上看到的，我们可以访问<code class="fe mb mc md me b">task_instance</code>对象，并且我们可以以类似 Jinja 的方式使用它。任务实例对象是我们可以利用<code class="fe mb mc md me b">xcom_push</code>和<code class="fe mb mc md me b">xcom_pull</code>的地方。我们可以在这里添加之前作为环境变量保存的三个参数。</p><p id="b400" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我将这三个参数作为“默认”环境变量的一部分，因为我在任何地方都使用它们，但是将它们放在任务定义中可能更有意义。</p><h2 id="970c" class="ml kz in bd la mm mn dn le mo mp dp li kl mq mr lm kp ms mt lq kt mu mv lu mw bi translated">第五步:测试</h2><p id="1c84" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">是时候看看我们所有的努力为我们赢得了什么！</p><figure class="mh mi mj mk gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi no"><img src="../Images/d16faba79722dbb1058b073e53a04783.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qqOSNE90Vk4Vcc_ANrDSGg.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">我们完成的手动触发页面</figcaption></figure><p id="ea2f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">简单却有效。切换下拉列表中的 DAG 将相应地交换表单字段(如果您有多个 DAG)。如果您试图在任何必填字段丢失数据时单击 Trigger，浏览器将会报错。如果所有字段都已填写，并且您单击 Trigger，您将在按钮内看到一个漂亮的微调图标。</p><p id="d30b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为什么我们不触发我们的 DAG？</p><figure class="mh mi mj mk gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi no"><img src="../Images/e4169928de7a00fe831769eae550af1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7rjpjypI69rej38Fg4O67w.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">我们的手动触发页面，在触发 DAG 后</figcaption></figure><p id="aabd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">成功！“即时消息”不是世界上最漂亮的东西，但它表达了一个观点。第一个链接将带您到您当前运行的 DAG 的图形视图，而第二个链接向您显示云存储中所有预览运行的输出，第三个链接将是您当前运行的输出。</p></div><div class="ab cl nh ni hr nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ig ih ii ij ik"><h1 id="7e9b" class="ky kz in bd la lb np ld le lf nq lh li lj nr ll lm ln ns lp lq lr nt lt lu lv bi translated">总结</h1><p id="cebe" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">您已经成功创建了您的第一个 Airflow 插件，这是一个 UI 插件，它提供了一个“手动触发”页面来帮助手动触发带有参数的 Dag。</p><p id="d198" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我计划学习更多关于 Spark 的知识，所以将来我可能会写一些关于如何在 Google Dataproc 中运行 Spark 工作流并从 Airflow DAG 中触发它的东西。敬请期待！</p><p id="4e36" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这里找到本教程以前的部分:<a class="ae jz" href="https://robert-a-gutierrez.medium.com/creating-an-automated-data-processing-pipeline-with-apache-airflow-kubernetes-and-r-part-1-925f99b812e7" rel="noopener">第一部分</a>和<a class="ae jz" href="https://robert-a-gutierrez.medium.com/creating-an-automated-data-processing-pipeline-with-apache-airflow-kubernetes-and-r-part-2-2e95c2e9ae5e" rel="noopener">第二部分</a>。</p></div></div>    
</body>
</html>