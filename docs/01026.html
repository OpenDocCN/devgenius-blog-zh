<html>
<head>
<title>Bloom Filter Data Structure</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">布隆过滤器数据结构</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/bloom-filter-data-structure-df7d9da78eec?source=collection_archive---------14-----------------------#2020-06-22">https://blog.devgenius.io/bloom-filter-data-structure-df7d9da78eec?source=collection_archive---------14-----------------------#2020-06-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><blockquote class="jn jo jp"><p id="a6cd" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">一个<!-- -->布隆过滤器是一个概率数据结构，它快速且高效地判断一个元素是否出现在集合中。</p></blockquote><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi kp"><img src="../Images/bb4ea7ba532e0e9ca3346c431ff2e332.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*oestOdRjJTzAJAzj"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">由<a class="ae lf" href="https://unsplash.com/@kmuza?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">卡洛斯·穆扎</a>在<a class="ae lf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="a58c" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">这种效率的代价是Bloom filter是一种概率数据结构:它告诉我们元素要么肯定不在集合中，要么可能在集合中。</p><p id="6d3c" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">布隆过滤器的基本数据结构是位数组。<br/>这里有一个小例子，我们将用来演示:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi lj"><img src="../Images/4080e345e3eddcde19d47146a4d13c52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CwaPmEKGAvwIAOwVbrnSiw.png"/></div></div></figure><p id="7d79" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">上面是25位的位数组。<br/>现在假设我们的哈希函数是h1、h2和h3 <br/>元素是Rat、Cat、Dog</p><p id="3ff2" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">上表显示了每个哈希函数处理后元素的值。</p><blockquote class="jn jo jp"><p id="ad96" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">它是如何工作的？</p></blockquote><p id="6603" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">对于每个元素，我们将它传递给哈希函数，比如说，<br/> Dog被传递给h1，给出7，我们在比特数组中设置编号为7的索引。<br/> Dog被传递给h2，给出11，我们在位数组中设置编号为11的索引。<br/> Dog被传递给h3，给出13，我们在位数组中设置编号为13的索引。<br/>对其他元件执行相同的操作，并继续设置位数组…</p><p id="33f7" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">现在，当我们需要检查该元素是否存在时，我们将该元素传递给那些哈希函数，并检查位数组中的索引是否已设置。<br/>这就是我们如何知道元素是否存在于系统中。</p><blockquote class="jn jo jp"><p id="8d57" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">为什么是概率性的？</p></blockquote><p id="a999" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi lk translated"><span class="l ll lm ln bm lo lp lq lr ls di"> S </span> uppose对于元素God，<br/> h1哈希函数返回10，<br/> h2哈希函数返回6，<br/> h3哈希函数返回13，那么Bloom filter将返回true，表明它存在于我们的系统中。这就是为什么我们说元素不存在是100%确定的，但元素存在是概率性的。</p><blockquote class="jn jo jp"><p id="c613" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">我们将引用具有k个散列、过滤器中的m个比特以及已经插入的n个元素的布隆过滤器。</p></blockquote><p id="d14f" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated"><strong class="jt ir">哈希函数</strong></p><p id="7c04" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">布隆过滤器中使用的散列函数应该是独立且均匀分布的。他们也应该尽可能快。</p><p id="a3f1" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">足够独立的快速、简单的散列的例子包括brumb、fnv散列系列和HashMix。</p><p id="88a2" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">我应该把我的Bloom滤镜做多大？</p><p id="bd08" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">布隆过滤器的一个很好的特性是你可以修改过滤器的误报率。过滤器越大，误报越少，过滤器越小，误报越多。<br/>您的误报率大约为(1-e-kn/m)k，因此您可以插入n个您希望插入的元素，并尝试不同的k和m值来配置您的滤波器。</p><p id="c2b3" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">我应该使用多少个散列函数？</p><p id="b82e" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">你的散列函数越多，你的bloom filter就越慢，它就越快填满。但是，如果数量太少，您可能会遭受太多的假阳性。因为在创建过滤器时必须选择k，所以您必须大概知道n应该在什么范围内。一旦你有了这个，你仍然需要选择一个潜在的m(位数)和k(散列函数的个数)。</p><p id="bfa8" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">这似乎是一个困难的优化问题，但幸运的是，给定一个m和一个n，我们有一个函数来选择k的最优值:(m/n)ln(2)</p><p id="54bb" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">因此，为了选择布隆过滤器的大小，我们:<br/> -选择n的值<br/> -选择m的值<br/> -计算k的最佳值<br/> -计算我们选择的n、m和k的值的误差率</p><p id="8133" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">如果不能接受，返回步骤2，改变m；否则我们就完了。</p><p id="f897" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated"><strong class="jt ir">布鲁姆滤镜的速度和空间效率如何？</strong></p><p id="9d88" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">给定具有m位和k个散列函数的布隆过滤器，插入和成员测试都是O(k)。也就是说，每当您想要向集合添加元素或检查集合成员资格时，您只需要通过k个散列函数运行元素，并将其添加到集合或检查那些位。</p><p id="ff1c" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">空间优势比较难总结；同样，这取决于你愿意容忍的错误率。它还取决于待插入元素的潜在范围；如果非常有限，确定性位向量可以做得更好。如果您甚至不能大概估计要插入的元素数量，那么使用哈希表或可伸缩的Bloom过滤器可能会更好。</p><p id="35da" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated"><strong class="jt ir">应用</strong></p><p id="7e5e" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">布隆过滤器在软件工程中有大量的应用。</p><ul class=""><li id="df59" class="lt lu iq jt b ju jv jy jz lg lv lh lw li lx ko ly lz ma mb bi translated">Medium在medium博客推荐中使用bloom filter来检查用户之前是否已经阅读过这篇文章。</li><li id="723a" class="lt lu iq jt b ju mc jy md lg me lh mf li mg ko ly lz ma mb bi translated">Google Bigtable、Apache HBase和Apache Cassandra以及Postgresql使用bloom filters来<em class="js">减少对不存在的行或列的磁盘查找</em>。避免代价高昂的磁盘查找大大提高了数据库查询操作的性能。</li><li id="361f" class="lt lu iq jt b ju mc jy md lg me lh mf li mg ko ly lz ma mb bi translated">内容交付网络提供商Akamai使用Bloom filter来避免缓存用户仅请求一次的web对象(也称为“<strong class="jt ir">一击不中的奇迹</strong>”)。使用Bloom filter来检测对web对象的第二次请求，并仅在其第二次请求时缓存该对象，可以防止一击即中的奇迹进入磁盘缓存，从而显著减少磁盘工作负载并提高磁盘缓存命中率。</li><li id="742e" class="lt lu iq jt b ju mc jy md lg me lh mf li mg ko ly lz ma mb bi translated">谷歌Chrome浏览器曾经使用布隆过滤器来识别恶意网址。首先根据本地Bloom过滤器检查任何URL，并且只有当Bloom过滤器返回肯定结果时，才执行对URL的全面检查(并且如果也返回肯定结果，则用户会发出警告)</li></ul><p id="bd62" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated">布隆过滤器的一些现有实现是</p><ul class=""><li id="9a9f" class="lt lu iq jt b ju jv jy jz lg lv lh lw li lx ko ly lz ma mb bi translated">布谷鸟过滤器是布鲁姆过滤器的另一种变体。Cuckoo过滤器支持动态添加和删除项目，同时实现比Bloom过滤器更高的性能。法尔汉有一个很好的关于布谷鸟和布鲁姆过滤器区别的<a class="ae lf" href="https://medium.com/techlog/cuckoo-filter-vs-bloom-filter-from-a-gophers-perspective-94d5e6c53299" rel="noopener">博客</a>。</li></ul><p id="fb07" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lg kd ke kf lh kh ki kj li kl km kn ko ij bi translated"><strong class="jt ir">参考文献</strong></p><div class="mh mi gp gr mj mk"><a href="https://llimllib.github.io/bloomfilter-tutorial/#:~:text=A%20Bloom%20filter%20is%20a,may%20be%20in%20the%20set." rel="noopener  ugc nofollow" target="_blank"><div class="ml ab fo"><div class="mm ab mn cl cj mo"><h2 class="bd ir gy z fp mp fr fs mq fu fw ip bi translated">布隆过滤器示例</h2><div class="mr l"><h3 class="bd b gy z fp mp fr fs mq fu fw dk translated">Bloom filter是一种数据结构，旨在快速高效地告诉您某个元素是否存在…</h3></div><div class="ms l"><p class="bd b dl z fp mp fr fs mq fu fw dk translated">llimllib.github.io</p></div></div><div class="mt l"><div class="mu l mv mw mx mt my kz mk"/></div></div></a></div><div class="mh mi gp gr mj mk"><a href="https://en.wikipedia.org/wiki/Counting_Bloom_filter#:~:text=A%20Counting%20Bloom%20filter%20is,sequence%20of%20elements%20is%20given." rel="noopener  ugc nofollow" target="_blank"><div class="ml ab fo"><div class="mm ab mn cl cj mo"><h2 class="bd ir gy z fp mp fr fs mq fu fw ip bi translated">计数布隆过滤器</h2><div class="mr l"><h3 class="bd b gy z fp mp fr fs mq fu fw dk translated">计数型Bloom filter是Bloom filter的一种广义数据结构，用于测试一个计数型Bloom filter的计数是否…</h3></div><div class="ms l"><p class="bd b dl z fp mp fr fs mq fu fw dk translated">en.wikipedia.org</p></div></div></div></a></div></div></div>    
</body>
</html>