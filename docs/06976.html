<html>
<head>
<title>Two Ways to Immediately Improve Your Python Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">有两种方法可以立即改进您的 Python 代码</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/two-ways-to-immediately-improve-your-python-code-a249b0250c22?source=collection_archive---------11-----------------------#2022-02-15">https://blog.devgenius.io/two-ways-to-immediately-improve-your-python-code-a249b0250c22?source=collection_archive---------11-----------------------#2022-02-15</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><h1 id="26ff" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">即使是顶级开发人员也会犯的两个最常见的错误</h1><p id="b7a6" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">在所有关于人工智能的讨论中，你有没有想过好的人工智能技术可以如何帮助你发展成为一名软件工程师？将软件分析工具应用到你的代码中看起来很棘手，但是它变得越来越容易了。</p><p id="240b" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">我<a class="ae ll" rel="noopener ugc nofollow" target="_blank" href="/your-github-code-could-be-better-c77583e94e79">将 LGTM </a>应用于一些公共代码库来识别常见错误。</p><p id="112f" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">请看下面的两篇文章，找到立即改进代码的方法。</p></div><div class="ab cl lm ln hr lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="ig ih ii ij ik"><h1 id="8000" class="jk jl in bd jm jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh bi translated">精确断言</h1><p id="a335" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">对于测试，Python 有全系列的资产，比如 assertIn、assertGreater 和 assertIsNotNone。作为开发人员，坚持使用 assertTrue 或 assertFalse 是很常见的。然而，这些断言不会提供描述性消息。哪个对你来说更容易理解？</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="8968" class="mh jl in md b gy mi mj l mk ml">AssertionError: False is not true : Not found.<br/>// Or...<br/>AssertionError: 'message' not found in 'Custom string' : Not found.</span></pre><figure class="ly lz ma mb gt mn gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi mm"><img src="../Images/719557909ebde739a06d2aee6a857ea2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7QsgyKDhP4H8Ussn"/></div></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk translated">由<a class="ae ll" href="https://unsplash.com/@epicantus?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">达里娅·内布里亚希娜</a>在<a class="ae ll" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="1007" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">当然，您可以添加定制的消息来提供更多的信息，但是如果内置函数已经为您完成了这些工作，那就更有帮助了。</p><p id="aec9" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">所以当你写测试的时候，你可以在任何时候使用 assertTrue 或者 assertFalse 的时候仔细考虑。有没有一个更精确的断言可以让你省去以后调试的麻烦？</p></div><div class="ab cl lm ln hr lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="ig ih ii ij ik"><h1 id="13ef" class="jk jl in bd jm jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh bi translated">重点进口</h1><p id="a0d2" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">看看典型的 Python 程序，你会发现<strong class="kk io">大量的导入</strong>。我们经常添加到这个列表中，但是我们多久从这个列表中删除一次呢？我们可能删除了最后一个 NumPy 用法，但是我们删除了导入吗？</p><figure class="ly lz ma mb gt mn gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi mz"><img src="../Images/a74b59ee7ae548f14560c899a5b5b399.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*24jQJGo_6a1kcZx-"/></div></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk translated">照片由<a class="ae ll" href="https://unsplash.com/@rosebox?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">罗斯博格رز باکس </a>在<a class="ae ll" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="1d9a" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">如果我们想避免程序变得臃肿，在更新代码时考虑什么时候可以删除导入是有意义的。这可能是一个更适合静态分析器的功能，因为即使是最勤奋的工程师也可能会错过一些未使用的导入。也就是说，关注它可以减少我们程序的大小。</p><p id="90de" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">同样，只进口我们需要的东西至关重要。许多 Python 程序会导入所有内容(“从<module>导入*”)。特别是如果模块没有定义“__all__”，我们的全局命名空间就可能被污染。结果是大量未使用的变量、函数等等。另外，潜在的命名冲突！这是避免的好办法。</module></p></div><div class="ab cl lm ln hr lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="ig ih ii ij ik"><h1 id="af17" class="jk jl in bd jm jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh bi translated">奖金:默认参数，变量定义</h1><p id="089f" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">对于那些阅读到最后的人来说，这里有一些额外的奖励:</p><p id="8d56" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">不要改变默认参数！当函数被定义时，缺省参数被求值…仅一次。假设我们有以下程序:</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="1604" class="mh jl in md b gy mi mj l mk ml">def example(inputs=[]):<br/>    inputs.append("ran_once")<br/>    return inputs</span></pre><p id="66c7" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">第一次运行时，它将返回["ran_once"]。第二次，["ran_once "，" ran_once"]。诸如此类。除非这是您想要的行为<em class="my">，而且很少是</em>，这里有一个更好的方法来编写函数:</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="c51e" class="mh jl in md b gy mi mj l mk ml">def example(inputs=None):<!-- --> </span><span id="2576" class="mh jl in md b gy na mj l mk ml">inputs.append("ran_once")<br/>    if inputs is None:<br/>      inputs = []<br/>    inputs.append("ran_once")<br/>    return inputs</span></pre><p id="adb6" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated"><strong class="kk io">变量定义。</strong>变量在被使用或从未被使用之前被重定义是非常普遍的。我怀疑这发生在代码更改期间。这可能是在更新代码时需要注意的事情，但也是静态分析器可以帮助解决的事情。</p><p id="94d2" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">同时，程序经常在函数不被使用时保存它的返回值。例如，您想调用一个函数来启动一个服务，但是您从来不检查返回值。在这种情况下，不保存返回值对于阅读您的代码的人来说更容易理解，并且减少了内存的使用。</p></div><div class="ab cl lm ln hr lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="ig ih ii ij ik"><p id="759f" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">你已经坚持到最后了！奖金什么的。向你致敬。</p><figure class="ly lz ma mb gt mn gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi nb"><img src="../Images/ea607dacdc9c67721e9bf9ed15ecb52f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*h7QtRjc2uhRuGyFP"/></div></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk translated">照片由<a class="ae ll" href="https://unsplash.com/@wflwong?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">沃伦·王</a>在<a class="ae ll" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure></div></div>    
</body>
</html>