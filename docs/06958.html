<html>
<head>
<title>How to Play Bulls and Cows with Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用 Python 玩牛牛</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-to-play-bulls-and-cows-with-python-5b9d2ae95ba4?source=collection_archive---------13-----------------------#2022-02-14">https://blog.devgenius.io/how-to-play-bulls-and-cows-with-python-5b9d2ae95ba4?source=collection_archive---------13-----------------------#2022-02-14</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="8ac5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ki">一款带自动解的老号码猜谜游戏</em></p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi kj"><img src="../Images/db09ea42cbe60c4f04207d910e31bf39.png" data-original-src="https://miro.medium.com/v2/resize:fit:588/format:webp/0*8YOFTF8CZTmR_pAO.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">来源:https://en.wikipedia.org/wiki/Bulls_and_Cows<a class="ae kv" href="https://en.wikipedia.org/wiki/Bulls_and_Cows" rel="noopener ugc nofollow" target="_blank"/></figcaption></figure><p id="5b4f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae kv" href="https://en.wikipedia.org/wiki/Bulls_and_Cows" rel="noopener ugc nofollow" target="_blank">公牛和母牛</a>是一个数字猜谜游戏，我第一次接触它是在 20 多年前，当时我还在 Excel 上写 VBA。我甚至创建了一个 Excel 版本，现在仍然有效(我曾在 2001 年和埃里克·廖(Eric Liao)一起工作，但从 2005 年开始改用我的法定姓名沙扬·廖):</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi kw"><img src="../Images/b604fa69d9d74aa3ccb17cb54f02d5ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1362/format:webp/1*S4BU7EfnBzvO4MBhpteCAw.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">作者版权</figcaption></figure><p id="4998" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">受 Wordle 游戏(<a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/how-to-cheat-in-wordle-with-python-b72e8904f868">如何用 Python 在 Wordle 中作弊</a>)的启发，我决定重温一下这个猜数游戏，用我新喜欢的编程语言 Python。</p><h1 id="348c" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">游戏规则</h1><p id="6897" class="pw-post-body-paragraph jk jl in jm b jn lv jp jq jr lw jt ju jv lx jx jy jz ly kb kc kd lz kf kg kh ig bi translated">这个游戏的正式名称是<strong class="jm io">公牛和牛</strong>，通常由两个玩家玩，玩家 A 编造一个没有重复数字的 4 位数，玩家 B 试图一轮一轮地猜出秘密数字。</p><p id="83cd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对于每个猜测，玩家 A 将以“1 牛 2 牛”的形式向玩家 B 提供分数，这意味着在玩家 B 猜测的 4 个数字中，有 1 个正确的数字在正确的位置，2 个正确的数字在错误的位置。</p><p id="b2b4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">例如，如果秘密数字是 5213，而玩家 B 猜中了 1234，他将得到“1 头公牛 2 头母牛”的分数，因为数字 2 是不正确的位置，而数字 1 和 3 是正确的，但出现在错误的位置。</p><p id="efb8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">玩家 B 的目标是达到“4 公牛 0 母牛”的分数，这意味着他猜对了整个数字。</p><p id="aa93" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">玩家 A 通常由电脑玩，“1 牛 2 牛”分数通常简称为“1A2B”。</p><p id="d3af" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">与<strong class="jm io"> Wordle </strong>相比，公牛和母牛实际上要困难得多，因为从每个分数提供的信息非常有限。比如上面的 1234 (1 牛 2 牛)的情况，你不会知道哪个数字是牛，哪两个数字是牛。</p><p id="eae7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你愿意，事情会变得更难。例如，您可以使用 5 位数或更多位数来代替 4 位数的密码。您可以允许号码中有重复的数字，而不是没有重复的 4 位数。你甚至可以用 4 个字母的单词代替 4 位数。</p><h1 id="b92a" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">Python 实现</h1><h2 id="bc77" class="ma ky in bd kz mb mc dn ld md me dp lh jv mf mg ll jz mh mi lp kd mj mk lt ml bi translated">生成一个随机数</h2><p id="5ec3" class="pw-post-body-paragraph jk jl in jm b jn lv jp jq jr lw jt ju jv lx jx jy jz ly kb kc kd lz kf kg kh ig bi translated">第一个逻辑步骤是生成一个 4 位随机数，如下所示:</p><pre class="kk kl km kn gt mm mn mo mp aw mq bi"><span id="abda" class="ma ky in mn b gy mr ms l mt mu">import random<br/>rndnum = random.randint(1000, 9999)</span></pre><p id="3330" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">请注意，<code class="fe mv mw mx mn b">random.randint</code>接受一个起始整数和一个结束整数，并且两者都包含在内，这与<code class="fe mv mw mx mn b">range</code>不同。此外，您希望从 1000 开始，以排除任何少于 4 位数的数字。</p><p id="da73" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是，这仍然会返回具有重复数字的数字，例如 1111。以下代码扩展了随机数生成函数的无效性和通用性:</p><pre class="kk kl km kn gt mm mn mo mp aw mq bi"><span id="36e7" class="ma ky in mn b gy mr ms l mt mu">def gen_rand_num(digits=4, no_leading_zeros=True, no_repeating_digits=True):<br/>    if digits&gt;=10:<br/>        no_repeating_digits = False<br/>    start = 10**(digits-1) if no_leading_zeros else 0<br/>    end = 10**digits-1<br/>    while True:<br/>        rndnum = random.randint(start, end)<br/>        rndnum_str = f'{{0:0{digits}d}}'.format(rndnum)<br/>        if no_repeating_digits:<br/>            if len(set(rndnum_str))==digits:<br/>                return rndnum_str<br/>        else:<br/>            return rndnum_str</span></pre><p id="53a5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">实际上有一种更好的方法，通过预先生成一个有效数字的列表，用排列代替检查有效性并在无效时生成另一个数字。</p><h2 id="61ef" class="ma ky in bd kz mb mc dn ld md me dp lh jv mf mg ll jz mh mi lp kd mj mk lt ml bi translated">检查用户输入的分数</h2><p id="e360" class="pw-post-body-paragraph jk jl in jm b jn lv jp jq jr lw jt ju jv lx jx jy jz ly kb kc kd lz kf kg kh ig bi translated">要获得用户输入，您可以简单地使用 Python 中的<code class="fe mv mw mx mn b">input</code>方法:</p><pre class="kk kl km kn gt mm mn mo mp aw mq bi"><span id="b433" class="ma ky in mn b gy mr ms l mt mu">for i in range(10):<br/>    guess = input(f'Round {i+1}, enter your guess: ')</span></pre><p id="3d90" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后，您需要做的就是对照生成的随机数逐个数字地检查用户输入:</p><pre class="kk kl km kn gt mm mn mo mp aw mq bi"><span id="5257" class="ma ky in mn b gy mr ms l mt mu">def cal_score_against(guess, against):<br/>    rndnum_str = f'{{0:04d}}'.format(int(against))<br/>    rndnum_lst = list(rndnum_str)<br/>    guess_str = f'{{0:04d}}'.format(int(guess))<br/>    guess_lst = list(guess_str)<br/>    a = sum([n==rndnum_lst[i] for i, n in enumerate(guess_lst)])<br/>    b = sum([n in rndnum_lst and n!=rndnum_lst[i]<br/>        for i, n in enumerate(guess_lst)])<br/>    return f'{a}A{b}B'</span></pre><p id="e8fc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">上面代码中的列表理解比<code class="fe mv mw mx mn b">for</code>循环更优雅，并且利用了 Python 中的<code class="fe mv mw mx mn b">sum([True, False])=1</code>特性来计算命中次数。</p><h2 id="ea97" class="ma ky in bd kz mb mc dn ld md me dp lh jv mf mg ll jz mh mi lp kd mj mk lt ml bi translated">绕成一圈</h2><p id="2edf" class="pw-post-body-paragraph jk jl in jm b jn lv jp jq jr lw jt ju jv lx jx jy jz ly kb kc kd lz kf kg kh ig bi translated">对于<em class="ki">公牛和母牛</em>的简单实现来说，这几乎就是全部了，让我们把它包装成一个循环，并尝试一下:</p><pre class="kk kl km kn gt mm mn mo mp aw mq bi"><span id="cf6b" class="ma ky in mn b gy mr ms l mt mu">import random</span><span id="8651" class="ma ky in mn b gy my ms l mt mu">def gen_rand_num(digits=4, no_leading_zeros=True, no_repeating_digits=True):<br/>    if digits&gt;=10:<br/>        no_repeating_digits = False<br/>    start = 10**(digits-1) if no_leading_zeros else 0<br/>    end = 10**digits-1<br/>    while True:<br/>        rndnum = random.randint(start, end)<br/>        rndnum_str = f'{{0:0{digits}d}}'.format(rndnum)<br/>        if no_repeating_digits:<br/>            if len(set(rndnum_str))==digits:<br/>                return rndnum_str<br/>        else:<br/>            return rndnum_str</span><span id="def7" class="ma ky in mn b gy my ms l mt mu">def cal_score_against(guess, against):<br/>    rndnum_str = f'{{0:04d}}'.format(int(against))<br/>    rndnum_lst = list(rndnum_str)<br/>    guess_str = f'{{0:04d}}'.format(int(guess))<br/>    guess_lst = list(guess_str)<br/>    a = sum([n==rndnum_lst[i] for i, n in enumerate(guess_lst)])<br/>    b = sum([n in rndnum_lst and n!=rndnum_lst[i]<br/>        for i, n in enumerate(guess_lst)])<br/>    return f'{a}A{b}B'</span><span id="f7d8" class="ma ky in mn b gy my ms l mt mu">rndnum = gen_rand_num()<br/>for i in range(10):<br/>    guess = input(f'Round {i+1}, enter your guess: ')<br/>    score = cal_score_against(guess, rndnum)<br/>    if score=='4A0B':<br/>        print(f'{score}, you won!')<br/>        break<br/>    else:<br/>        print(score)<br/>else:<br/>    print(f'You lose, correct answer is: {numble.get_answer()}')</span><span id="0be1" class="ma ky in mn b gy my ms l mt mu"><strong class="mn io">output:</strong><br/>Round 1, enter your guess: 1023<br/>2A0B<br/>Round 2, enter your guess: 1045<br/>0A1B<br/>Round 3, enter your guess: 4623<br/>2A0B<br/>Round 4, enter your guess: 5723<br/>2A1B<br/>Round 5, enter your guess: 8523<br/>4A0B, you won!</span></pre><p id="8c40" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当然，上面的 37 行代码是一个简化的实现，您可能已经发现了一些隐藏的错误，比如没有做任何事情来处理不正确的输入。但它服务于目的。</p><h1 id="f60a" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">懒得去玩？试试自动猜测！</h1><p id="f34f" class="pw-post-body-paragraph jk jl in jm b jn lv jp jq jr lw jt ju jv lx jx jy jz ly kb kc kd lz kf kg kh ig bi translated">像我这么懒，当然不会就此打住。我可以快速找到的一个自动猜测解决方案是通过遍历所有可能的答案并对照已知分数进行检查的蛮力方法。</p><pre class="kk kl km kn gt mm mn mo mp aw mq bi"><span id="94e0" class="ma ky in mn b gy mr ms l mt mu">def auto_guess(rndnum):<br/>    print('Game started, auto guessing ...')<br/>    start = 10**(self.digits-1) if self.no_leading_zeros else 0<br/>    end = 10**self.digits-1<br/>    guesses = {}<br/>    for guess in range(start, end+1):<br/>        valid = True<br/>        for item, value in guesses.items():<br/>            if cal_score_against(item, guess)!=value:<br/>                valid = False<br/>                break<br/>        else:<br/>            score = cal_score_against(guess, rndnum)<br/>            guesses[guess] = score<br/>        if not valid:<br/>            continue<br/>        if score=='4A0B':<br/>            print(f'Round {len(guesses)}, {guess}: {score}, you won!')<br/>            break<br/>        else:<br/>            print(f'Round {len(guesses)}, {guess}: {score}')</span><span id="b7fa" class="ma ky in mn b gy my ms l mt mu"><strong class="mn io">output:</strong><br/>Game started, auto guessing ...<br/>Round 1, 1023: 0A2B<br/>Round 2, 2145: 0A2B<br/>Round 3, 3256: 0A2B<br/>Round 4, 4361: 1A1B<br/>Round 5, 4530: 1A1B<br/>Round 6, 4602: 0A0B<br/>Round 7, 5731: 3A0B<br/>Round 8, 5831: 3A0B<br/>Round 9, 5931: 4A0B, you won!</span></pre><p id="cfc3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我实际上用这种方法测试了所有 4536 个可能隐藏的数字，用了 2m11s 来完成所有的猜测。有几个最多需要 9 轮才能猜出来，比如上面的<code class="fe mv mw mx mn b">5931</code>。根据<a class="ae kv" href="https://en.wikipedia.org/wiki/Bulls_and_Cows" rel="noopener ugc nofollow" target="_blank">维基百科</a>，证明所有问题都可以在 7 个步骤下解决，平均最小步骤为 5.21。我认为我的暴力算法非常成功。</p><h1 id="b536" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">还有一点</h1><p id="8f98" class="pw-post-body-paragraph jk jl in jm b jn lv jp jq jr lw jt ju jv lx jx jy jz ly kb kc kd lz kf kg kh ig bi translated">用 GUI 而不是我简陋的命令行版本来实现这个游戏听起来似乎可行。但是只要在你的应用程序商店上搜索<em class="ki">公牛和母牛</em>，你就会发现大量的免费版本。除非你想把它作为学习新东西的一个挑战，否则不值得付出汗水。</p></div></div>    
</body>
</html>