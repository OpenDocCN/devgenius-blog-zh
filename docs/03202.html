<html>
<head>
<title>Tutorial — Azure Functions via Linux Containers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">教程—通过Linux容器实现Azure功能</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/tutorial-azure-functions-via-linux-containers-74aac0a89581?source=collection_archive---------1-----------------------#2020-10-12">https://blog.devgenius.io/tutorial-azure-functions-via-linux-containers-74aac0a89581?source=collection_archive---------1-----------------------#2020-10-12</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/591c7b6e66279aae0befc7a1479746d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tQCVMQvqtH0eYGyOdwTdxw.png"/></div></div></figure><h1 id="079e" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">介绍</h1><p id="b254" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">在过去的几年中，无服务器功能已经成为产品架构师工具箱中的一个重要工具。像<a class="ae lr" href="https://aws.amazon.com/lambda/" rel="noopener ugc nofollow" target="_blank"> Amazon Lambda </a>、<a class="ae lr" href="https://azure.microsoft.com/en-us/services/functions/" rel="noopener ugc nofollow" target="_blank"> Azure Functions </a>和<a class="ae lr" href="https://workers.cloudflare.com/" rel="noopener ugc nofollow" target="_blank"> Cloudflare Workers </a>这样的产品允许以比平台即服务产品更简单的方式开发和部署小型、专注的功能。</p><p id="62d0" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">我不认为它们(还)是需要授权、共享业务逻辑以及其他横切关注点的全功能API应用程序的替代品。然而，在最近的一个项目中，我们希望使用一个移动应用程序可以调用的Azure函数。我们的挑战是Azure Function中的功能需要访问免费Azure Function应用服务计划中不提供的操作系统原语(GDI functions)。</p><p id="75e2" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">我们找到了一个供应商推荐和这个<a class="ae lr" href="https://docs.microsoft.com/en-us/azure/azure-functions/functions-create-function-linux-custom-image?tabs=bash%2Cportal&amp;pivots=programming-language-csharp" rel="noopener ugc nofollow" target="_blank">微软Azure教程</a>，它为我们指明了使用基于Linux的Docker容器作为Azure功能的部署机制的方向。这种方法:</p><p id="34d1" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">1.满足我们能够访问操作系统原语的要求。</p><p id="8821" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">2.使用较便宜的Linux Azure功能应用服务计划。</p><p id="90ff" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">3.允许本地开发人员在一个容器中进行测试，该容器实际上等同于将在Azure上部署和运行的容器。</p><p id="d32e" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">第三点值得解释一下。正如您将在本教程中看到的，微软为基于Linux的Docker容器Azure函数提供了基本容器映像。Azure函数运行时是基础映像一部分。虽然支持Azure云环境的其余部分并不存在于本地，但运行时是相同的。因此，本地测试提供了更大程度的信心，即该功能在部署到Azure时将同样执行。</p><p id="3b6d" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">对于本教程，我们将开发一个基于HTTP-trigger的Azure函数和存储队列触发的Azure函数。我们将使用Azure Function CLI工具在本地开发和运行它们。然后我们将在Docker容器中运行和测试它们。然后我们将它们作为Docker容器部署到Azure。</p><h2 id="9de5" class="lx jw in bd jx ly lz dn kb ma mb dp kf le mc md kj li me mf kn lm mg mh kr mi bi translated"><strong class="ak">本教程中使用的工具:</strong></h2><p id="f1cf" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated"><a class="ae lr" href="https://www.npmjs.com/package/azure-functions-core-tools" rel="noopener ugc nofollow" target="_blank"> Azure Function CLI工具</a></p><p id="d694" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated"><a class="ae lr" href="https://www.docker.com/products/docker-desktop" rel="noopener ugc nofollow" target="_blank"> Docker桌面</a></p><p id="fb0b" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated"><a class="ae lr" href="https://docs.microsoft.com/en-us/cli/azure/?view=azure-cli-latest" rel="noopener ugc nofollow" target="_blank"> Azure CLI工具</a></p><p id="2b60" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated"><a class="ae lr" href="https://docs.microsoft.com/en-us/azure/storage/common/storage-use-emulator" rel="noopener ugc nofollow" target="_blank"> Azure存储模拟器</a></p><p id="95a7" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated"><a class="ae lr" href="https://azure.microsoft.com/en-us/features/storage-explorer/" rel="noopener ugc nofollow" target="_blank"> Azure存储浏览器</a></p><h2 id="8738" class="lx jw in bd jx ly lz dn kb ma mb dp kf le mc md kj li me mf kn lm mg mh kr mi bi translated"><strong class="ak">本教程的组成部分:</strong></h2><p id="1e70" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated"><strong class="kv io"> 1。创建一个基于本地HTTP触发器的Azure函数</strong></p><p id="dc73" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated"><strong class="kv io"> 2。在本地容器中运行函数</strong></p><p id="be61" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated"><strong class="kv io"> 3。将HTTP触发器功能容器部署到Azure </strong></p><p id="e33d" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated"><strong class="kv io"> 4。创建一个本地队列触发的Azure函数</strong></p><p id="b2a3" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated"><strong class="kv io"> 5。增强队列触发功能</strong></p><p id="40fd" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">6。在本地Docker容器中运行队列触发函数</p><p id="28bb" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">7。将队列触发的功能容器部署到Azure </p><h1 id="1be4" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">第1部分:创建一个基于本地HTTP触发器的Azure函数</h1><p id="6168" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">首先，我们将创建一个简单的基于HTTP触发器的Azure函数。这一步与Linux容器相关的唯一方面是下面第2步中的<em class="mj"> — docker </em>参数。您可以省略该参数，并使用这些步骤开始使用您计划作为“普通”Azure Function应用服务(即，不是容器)部署的Azure Function。</p><p id="3277" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">先决条件:安装<a class="ae lr" href="https://www.npmjs.com/package/azure-functions-core-tools" rel="noopener ugc nofollow" target="_blank"> Azure功能核心CLI工具</a>。</p><p id="4deb" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">从空目录中的PowerShell提示符启动:</p><blockquote class="mk ml mm"><p id="5823" class="kt ku mj kv b kw ls ky kz la lt lc ld mn lu lg lh mo lv lk ll mp lw lo lp lq ig bi translated">1.Run: <strong class="kv io"> func — version </strong> <br/>这是Azure Function CLI工具的命令。它应该显示如下内容:3.0.2881</p><p id="5d5d" class="kt ku mj kv b kw ls ky kz la lt lc ld mn lu lg lh mo lv lk ll mp lw lo lp lq ig bi translated">2.run:<strong class="kv io">func init httptriggerfunction 01—worker-runtime dot net—docker</strong><br/>这将创建一个新的Azure Function项目，具有适当的。csproj文件和所需的Azure函数文件。</p><p id="d61a" class="kt ku mj kv b kw ls ky kz la lt lc ld mn lu lg lh mo lv lk ll mp lw lo lp lq ig bi translated">3.运行:<strong class="kv io">CD http triggerfunction 01</strong></p><p id="f4e4" class="kt ku mj kv b kw ls ky kz la lt lc ld mn lu lg lh mo lv lk ll mp lw lo lp lq ig bi translated">4.run:<strong class="kv io">func new—name HttpTrigger—template " HTTP Trigger "</strong><br/>这样就创建了一个新的基于HTTP Trigger的Azure函数。</p><p id="89e5" class="kt ku mj kv b kw ls ky kz la lt lc ld mn lu lg lh mo lv lk ll mp lw lo lp lq ig bi translated">5.Run: <strong class="kv io"> func start </strong> <br/>在默认端口7071上运行该功能。</p><p id="de20" class="kt ku mj kv b kw ls ky kz la lt lc ld mn lu lg lh mo lv lk ll mp lw lo lp lq ig bi translated">6.在浏览器中打开<a class="ae lr" href="http://localhost:7071/api/HttpTrigger" rel="noopener ugc nofollow" target="_blank">http://localhost:7071/API/http trigger</a>查看函数的响应。</p><p id="c38b" class="kt ku mj kv b kw ls ky kz la lt lc ld mn lu lg lh mo lv lk ll mp lw lo lp lq ig bi translated">7.PowerShell中的Ctrl-C来停止功能app。</p></blockquote><p id="8a3f" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">在运行该函数之前，新项目和函数在Windows资源管理器中如下所示:</p><figure class="mr ms mt mu gt jo gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/c2f2a0331db8590122eb0b3cc89ad8b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:962/format:webp/1*K24Buko2IZA-_yaO8tk9JA.png"/></div></figure><p id="bcde" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">此时，您还可以打开。并在调试器下运行它。第一次这样做时，Visual Studio可能会显示一个“下载Azure Function CLI工具”对话框。显然，至少在某些场景中，VS使用了与直接安装不同的安装方式。</p><h1 id="2a22" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">第2部分:在本地容器中运行函数</h1><p id="7230" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">先决条件:安装并运行最新版本的Docker桌面。</p><blockquote class="mk ml mm"><p id="7142" class="kt ku mj kv b kw ls ky kz la lt lc ld mn lu lg lh mo lv lk ll mp lw lo lp lq ig bi translated">1.运行:<strong class="kv io"> docker info </strong> <br/>验证它返回关于docker的信息，确保Docker Desktop正在运行。</p><p id="1a65" class="kt ku mj kv b kw ls ky kz la lt lc ld mn lu lg lh mo lv lk ll mp lw lo lp lq ig bi translated">2.检查生成的Dockerfile文件:</p></blockquote><figure class="mr ms mt mu gt jo"><div class="bz fp l di"><div class="mv mw l"/></div></figure><blockquote class="mk ml mm"><p id="4280" class="kt ku mj kv b kw ls ky kz la lt lc ld mn lu lg lh mo lv lk ll mp lw lo lp lq ig bi translated">3.运行:<strong class="kv io">任。\Dockerfile。\Dockerfile.local </strong> <br/>我们稍后会解释这样做的原因。简而言之，这是为了区分用于构建本地容器的Docker文件和用于构建要在Azure中部署的容器的Docker文件。它们之间唯一的区别是在构建容器时添加的环境变量。</p><p id="74e9" class="kt ku mj kv b kw ls ky kz la lt lc ld mn lu lg lh mo lv lk ll mp lw lo lp lq ig bi translated">4.运行:<strong class="kv io"> docker构建—文件。\Dockerfile.local —标记local/httptrigger01:v0.1.0。</strong> <br/>注“.”在命令行的末尾。该命令构建容器的本地版本。图像名称的“local/”前缀是一种约定，表示它不打算上传到Docker Hub。</p><p id="ee05" class="kt ku mj kv b kw ls ky kz la lt lc ld mn lu lg lh mo lv lk ll mp lw lo lp lq ig bi translated">5.运行:<strong class="kv io"> docker images </strong> <br/>这将显示新的图像名称，例如<br/>local/http trigger 01v 0 . 1 . 0 b 2 EB 87 ce 6 AC 3大约一分钟前484MB</p><p id="c330" class="kt ku mj kv b kw ls ky kz la lt lc ld mn lu lg lh mo lv lk ll mp lw lo lp lq ig bi translated">6.run:<strong class="kv io">docker run-p:8080:80 local/http trigger 01:v 0 . 1 . 0</strong><br/>这样运行容器，将主机(Windows)上的端口8080映射到容器中的端口80。</p><p id="9197" class="kt ku mj kv b kw ls ky kz la lt lc ld mn lu lg lh mo lv lk ll mp lw lo lp lq ig bi translated">7.在浏览器<br/>中打开<a class="ae lr" href="http://localhost:8080/api/HttpTrigger" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/API/http trigger</a>此时，你会得到一个401未授权错误，我们将在下面解释。</p><p id="c3af" class="kt ku mj kv b kw ls ky kz la lt lc ld mn lu lg lh mo lv lk ll mp lw lo lp lq ig bi translated">8.在另一个PowerShell提示符下，运行:<strong class="kv io"> docker ps </strong> <br/>这列出了正在运行的图像。记下容器ID，例如1a82b3021578。</p><p id="72ed" class="kt ku mj kv b kw ls ky kz la lt lc ld mn lu lg lh mo lv lk ll mp lw lo lp lq ig bi translated">9.在另一个PowerShell提示符下，运行:<strong class="kv io">docker stop 1a 82b 3021578</strong><br/>这将停止原始PowerShell会话中容器。您将在该提示符下看到“作业停止”消息。</p></blockquote><p id="0793" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">您得到401未授权错误的原因是因为由<strong class="kv io"> func new </strong>命令创建的触发函数将其授权级别设置为“function”。Azure Function Core CLI工具(即<strong class="kv io"> func start </strong>)并不强制该属性——它们是用于本地开发和开发者级测试的。本地容器所基于的映像确实强制实施了该属性，但是由于它不在Azure中运行，所以还没有创建包含在HTTP请求中以允许函数执行的密钥。</p><p id="4689" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">为了解决这个问题，我们将把授权级别改为匿名。</p><blockquote class="mk ml mm"><p id="627e" class="kt ku mj kv b kw ls ky kz la lt lc ld mn lu lg lh mo lv lk ll mp lw lo lp lq ig bi translated">1.将选项“—配置调试”添加到Dockerfile.local的“dotnet publish”命令<br/>中，这确保了它将使用项目的“调试”配置。</p></blockquote><figure class="mr ms mt mu gt jo"><div class="bz fp l di"><div class="mv mw l"/></div></figure><blockquote class="mk ml mm"><p id="91b4" class="kt ku mj kv b kw ls ky kz la lt lc ld mn lu lg lh mo lv lk ll mp lw lo lp lq ig bi translated">2.确保在中启用了“调试”常量符号。csproj文件。</p></blockquote><figure class="mr ms mt mu gt jo"><div class="bz fp l di"><div class="mv mw l"/></div></figure><blockquote class="mk ml mm"><p id="0e8b" class="kt ku mj kv b kw ls ky kz la lt lc ld mn lu lg lh mo lv lk ll mp lw lo lp lq ig bi translated">3.编辑HttpTrigger.cs文件，以便AuthorizationLevel对于调试版本是“匿名”的。</p></blockquote><figure class="mr ms mt mu gt jo"><div class="bz fp l di"><div class="mv mw l"/></div></figure><blockquote class="mk ml mm"><p id="33aa" class="kt ku mj kv b kw ls ky kz la lt lc ld mn lu lg lh mo lv lk ll mp lw lo lp lq ig bi translated">4.重新运行上面的步骤3到8。步骤6中的请求现在成功了。</p></blockquote><h1 id="cc2a" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">第3部分:将功能容器部署到Azure</h1><p id="2ebc" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">接下来，我们将从项目构建一个容器，并将容器部署到Azure。</p><p id="70ac" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated"><em class="mj">先决条件:拥有一个Docker Hub账户，您可以向其发布Docker图片。安装了</em> <a class="ae lr" href="https://docs.microsoft.com/en-us/cli/azure/?view=azure-cli-latest" rel="noopener ugc nofollow" target="_blank"> <em class="mj"> Azure CLI工具</em> </a> <em class="mj">。</em></p><blockquote class="mk ml mm"><p id="a836" class="kt ku mj kv b kw ls ky kz la lt lc ld mn lu lg lh mo lv lk ll mp lw lo lp lq ig bi translated">1.将Docker.local文件复制到Docker.azure文件，并将配置更改为“Release”</p></blockquote><figure class="mr ms mt mu gt jo"><div class="bz fp l di"><div class="mv mw l"/></div></figure><blockquote class="mk ml mm"><p id="e44f" class="kt ku mj kv b kw ls ky kz la lt lc ld mn lu lg lh mo lv lk ll mp lw lo lp lq ig bi translated">2.运行:<strong class="kv io"> docker构建—文件。\ docker file . azure—tag adhalejrawh/http trigger 01:v 0 . 1 . 0。</strong> <br/>这构建了我们将部署到Azure的映像。映像名称的“adhalejrawh/”前缀是一个约定，表示该映像将被推送到Docker Hub帐户。</p><p id="3ef9" class="kt ku mj kv b kw ls ky kz la lt lc ld mn lu lg lh mo lv lk ll mp lw lo lp lq ig bi translated">3.运行:<strong class="kv io"> docker登录</strong> <br/>这可以确保您登录到Docker Hub。如果您在Docker Desktop中登录到Docker Hub，它会简单地通知您登录成功。</p><p id="2ca7" class="kt ku mj kv b kw ls ky kz la lt lc ld mn lu lg lh mo lv lk ll mp lw lo lp lq ig bi translated">4.run:<strong class="kv io">Docker push adhalejrawh/http trigger 01:v 0 . 1 . 0</strong><br/>这将图像推送到Docker Hub。当你创建Azure function应用服务时，你将告诉Azure使用这个图像，它将从Docker Hub中提取这个图像。</p><p id="93e3" class="kt ku mj kv b kw ls ky kz la lt lc ld mn lu lg lh mo lv lk ll mp lw lo lp lq ig bi translated">5.运行以下命令来设置我们将重用的一些shell变量:<br/><strong class="kv io">$ resource group = " awhlunchandlerng "</strong><br/><strong class="kv io">$ storage account = " awhlunchandlernsa "</strong><br/><strong class="kv io">$ function plan = " awhlunchandlernap "</strong><br/><strong class="kv io">$ function name = " awhlunchandlernhttptriggerfunction "</strong></p><p id="f48b" class="kt ku mj kv b kw ls ky kz la lt lc ld mn lu lg lh mo lv lk ll mp lw lo lp lq ig bi translated">6.运行:<strong class="kv io"> az —版本</strong> <br/>验证Azure CLI工具已安装且可访问。</p><p id="c5cd" class="kt ku mj kv b kw ls ky kz la lt lc ld mn lu lg lh mo lv lk ll mp lw lo lp lq ig bi translated">7.运行:<strong class="kv io"> az登录</strong> <br/>登录你的Azure账户。这可能会将您带到一个浏览器窗口，并在您登录PowerShell会话时给您一条消息。</p><p id="9ffb" class="kt ku mj kv b kw ls ky kz la lt lc ld mn lu lg lh mo lv lk ll mp lw lo lp lq ig bi translated">8.运行:<strong class="kv io">az account Set—subscription { subscription-guid }</strong><br/>将您的资源使用上下文设置为适当的订阅。</p><p id="846e" class="kt ku mj kv b kw ls ky kz la lt lc ld mn lu lg lh mo lv lk ll mp lw lo lp lq ig bi translated">9.运行:<strong class="kv io">az group Create—name＄resource group—location east us 2</strong><br/>为Azure函数创建一个资源组。</p><p id="eb41" class="kt ku mj kv b kw ls ky kz la lt lc ld mn lu lg lh mo lv lk ll mp lw lo lp lq ig bi translated">10.运行:<strong class="kv io">az storage account Create—name＄storage account—location east us 2—resource-group＄resource group—SKU Standard _ LRS</strong><br/>创建存储帐户。将由应用洞察等Azure功能使用。可用于基于存储队列的Azure函数触发器。</p><p id="9ee8" class="kt ku mj kv b kw ls ky kz la lt lc ld mn lu lg lh mo lv lk ll mp lw lo lp lq ig bi translated">11.运行:<strong class="kv io">az function app plan Create—resource-group $ resource group—name $ function plan—location east us 2—number-of-workers 1—SKU EP1—is-Linux</strong><br/>创建函数app服务计划。这指定了有多少硬件资源可用于该功能。</p><p id="6a23" class="kt ku mj kv b kw ls ky kz la lt lc ld mn lu lg lh mo lv lk ll mp lw lo lp lq ig bi translated">12.run:<strong class="kv io">az function app Create-name $ function name-storage-account $ storage account-resource-group $ resource group-plan $ function plan-deployment-container-image-name adhalejrawh/http trigger 01:v 0 . 1 . 0-functions-version 3</strong><br/>创建函数，告诉Azure要向其部署哪个映像。您需要注意该命令显示的json结果中的几条信息:<br/> —“默认主机名”值:<a class="ae lr" href="http://awhlunchandlearnhttptriggerfunction.azurewebsites.net/" rel="noopener ugc nofollow" target="_blank">awhlunchandlearnhttptriggerfunction.azurewebsites.net</a><br/>—“id”值，类似于:"/subscriptions/c 602 D2 fa-790 b-4721–93e 8–4ab 9315064 e 1/resource groups/awhlunchandlerng/providers/Microsoft。web/sites/AwhLunchAndLearnHttpTriggerFunction "</p><p id="da2e" class="kt ku mj kv b kw ls ky kz la lt lc ld mn lu lg lh mo lv lk ll mp lw lo lp lq ig bi translated">13.run:<strong class="kv io">$ storageConnectionString = az storage account show-connection-string-resource-group $ resource group-name $ storage account-query connectionString-output tsv</strong><br/>将连接字符串保存到shell变量中的存储帐户。</p><p id="7c75" class="kt ku mj kv b kw ls ky kz la lt lc ld mn lu lg lh mo lv lk ll mp lw lo lp lq ig bi translated">14.run:<strong class="kv io">az function app config appsettings Set-name $ function name-resource-group $ resource group-settings azurewebjobstorage = $ storageConnectionString</strong><br/>将连接字符串设置为函数的配置(环境)变量。</p><p id="4faf" class="kt ku mj kv b kw ls ky kz la lt lc ld mn lu lg lh mo lv lk ll mp lw lo lp lq ig bi translated">15.在浏览器<br/>中转到<a class="ae lr" href="https://awhlunchandlearnhttptriggerfunction.azurewebsites.net/api/HttpTrigger" rel="noopener ugc nofollow" target="_blank">https://awhlunchandlerlearnhttptriggerfunction . azure websites . net/API/http trigger</a>应得到401未授权，因为授权级别是function，这意味着需要传递一个密钥才能调用该函数。</p><p id="940c" class="kt ku mj kv b kw ls ky kz la lt lc ld mn lu lg lh mo lv lk ll mp lw lo lp lq ig bi translated">16.run:<strong class="kv io">az rest-method post-uri "/subscriptions/c 602 d2fa-790 b-4721–93e 8–4ab 9315064 e 1/resource groups/awhlunchandlerng/providers/Microsoft。web/sites/AwhLunchAndLearnHttpTriggerFunction/host/default/list keys？API-version = 2018–11–01”—查询函数Keys.default —输出tsv </strong> <br/>获取函数的密钥。它是以下形式的字符串:scywieh 8 hcywbkvpcqnfxsudgy 7k 9k 27 nqw 2 wd 3km a5 bwis 8 dwk ixg = =</p><p id="8fbc" class="kt ku mj kv b kw ls ky kz la lt lc ld mn lu lg lh mo lv lk ll mp lw lo lp lq ig bi translated">17.将该键作为查询字符串参数添加到URL中，命名为“code”:<br/><a class="ae lr" href="https://awhlunchandlearnhttptriggerfunction.azurewebsites.net/api/HttpTrigger?code=sCyWIEH8hCyWBKVPcqNfXSudgy7K9k27nQw2WD3kMa5BWIS8Dwkixg==" rel="noopener ugc nofollow" target="_blank">https://awhlunchandlearnhttpttrigger function . azure websites . net/API/http trigger？code = scywieh 8 hcywbkvpcqnfxsudgy 7 K9 k 27 nqw 2 D3 KMA 5 bwis 8 dwk ixg = =</a><br/>现在该函数返回一个200 OK，具有预期的输出。</p></blockquote><h1 id="88bd" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">第4部分:创建本地队列触发的Azure函数</h1><p id="0a43" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">Azure的功能可能会“绑定”到(或被触发)多种不同的技术<a class="ae lr" href="https://docs.microsoft.com/en-us/azure/azure-functions/functions-triggers-bindings" rel="noopener ugc nofollow" target="_blank">。HTTP触发器是最简单的触发机制，适用于函数需要与其他后端技术(如数据库)进行交互并将数据返回给调用该函数的应用程序的情况。因此，对于调用者来说，HTTP触发器功能是同步的。</a></p><p id="62ac" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">通常，一个函数只需要给出所需的数据，而不必向需要该函数执行的应用程序返回任何东西。在这些情况下，通常使用由队列中的消息触发的Azure函数。</p><p id="2c5c" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">现在我们将创建一个Azure函数，它由到达<a class="ae lr" href="https://azure.microsoft.com/en-us/services/storage/queues/" rel="noopener ugc nofollow" target="_blank"> Azure队列存储</a>的消息触发。</p><p id="8305" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">我们不会重复已经讨论过的细节。我们将关注队列触发的Azure函数的不同之处。</p><p id="e6dc" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">先决条件:安装<a class="ae lr" href="https://docs.microsoft.com/en-us/azure/storage/common/storage-use-emulator" rel="noopener ugc nofollow" target="_blank"> Azure存储模拟器</a>和<a class="ae lr" href="https://azure.microsoft.com/en-us/features/storage-explorer/" rel="noopener ugc nofollow" target="_blank"> Azure存储浏览器</a>。</p><blockquote class="mk ml mm"><p id="9544" class="kt ku mj kv b kw ls ky kz la lt lc ld mn lu lg lh mo lv lk ll mp lw lo lp lq ig bi translated"><strong class="kv io"> 1 </strong>。从第1部分开始，遵循一般模式来初始化一个函数项目和一个函数:</p><p id="85ad" class="kt ku mj kv b kw ls ky kz la lt lc ld mn lu lg lh mo lv lk ll mp lw lo lp lq ig bi translated">a.<strong class="kv io">func init queuetriggerfunction 01—worker-runtime dot net—docker</strong></p><p id="380f" class="kt ku mj kv b kw ls ky kz la lt lc ld mn lu lg lh mo lv lk ll mp lw lo lp lq ig bi translated">b.<strong class="kv io">CD queuetriggerfunction 01</strong></p><p id="21f0" class="kt ku mj kv b kw ls ky kz la lt lc ld mn lu lg lh mo lv lk ll mp lw lo lp lq ig bi translated">c.<strong class="kv io"> func new — name QueueHandler —模板队列</strong></p><p id="685f" class="kt ku mj kv b kw ls ky kz la lt lc ld mn lu lg lh mo lv lk ll mp lw lo lp lq ig bi translated"><strong class="kv io"> 2 </strong>。启动Microsoft Azure存储模拟器</p><p id="43ee" class="kt ku mj kv b kw ls ky kz la lt lc ld mn lu lg lh mo lv lk ll mp lw lo lp lq ig bi translated"><strong class="kv io"> 3 </strong>。启动Microsoft Azure存储浏览器</p><p id="ba29" class="kt ku mj kv b kw ls ky kz la lt lc ld mn lu lg lh mo lv lk ll mp lw lo lp lq ig bi translated"><strong class="kv io"> 4 </strong>。运行功能:<strong class="kv io"> func启动</strong></p><p id="3147" class="kt ku mj kv b kw ls ky kz la lt lc ld mn lu lg lh mo lv lk ll mp lw lo lp lq ig bi translated"><strong class="kv io"> 5 </strong>。在步骤1c中创建的函数中的默认队列名称是“myqueue-items”:</p><p id="70b2" class="kt ku mj kv b kw ls ky kz la lt lc ld mn lu lg lh mo lv lk ll mp lw lo lp lq ig bi translated">a.在存储资源管理器中，导航至本地和连接-&gt;存储帐户-&gt;本地仿真器-&gt;队列</p><p id="1109" class="kt ku mj kv b kw ls ky kz la lt lc ld mn lu lg lh mo lv lk ll mp lw lo lp lq ig bi translated">b.如果它没有名为“myqueue-items”的队列，则添加一个</p><p id="1a43" class="kt ku mj kv b kw ls ky kz la lt lc ld mn lu lg lh mo lv lk ll mp lw lo lp lq ig bi translated">c.将消息添加到队列中</p></blockquote><figure class="mr ms mt mu gt jo gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/b3f89a153caddbc1cafe18725c35e8ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:938/format:webp/1*9yFBEDXyEx-iRnHHAxJEDA.png"/></div></figure><blockquote class="mk ml mm"><p id="62d9" class="kt ku mj kv b kw ls ky kz la lt lc ld mn lu lg lh mo lv lk ll mp lw lo lp lq ig bi translated"><strong class="kv io"> 6 </strong>。在运行该功能的控制台窗口中，您将看到回显到屏幕上的消息</p></blockquote><figure class="mr ms mt mu gt jo"><div class="bz fp l di"><div class="mv mw l"/></div></figure><h1 id="eba7" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">第5部分:增强队列功能</h1><p id="6989" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">在本教程的第4部分，我们创建了一个Azure函数，它由到达存储队列的消息触发。该功能是一个合理的起点，但是它需要一些更改来作为生产就绪功能的基础:</p><p id="84cf" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">1.告诉函数监视哪个队列的连接字符串是函数的配置参数，但是队列名称是硬编码的。队列名称也应该是一个配置参数。</p><p id="2372" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">2.该函数应该期望队列消息采用json格式，这种格式可以反序列化为强类型对象。</p><p id="20ed" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated"><strong class="kv io">将队列名称更改为配置参数</strong></p><p id="4f61" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">生成的队列函数如下所示:</p><figure class="mr ms mt mu gt jo"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="669a" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">将其更改如下:</p><figure class="mr ms mt mu gt jo"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="cc70" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">我们已经将带有连接字符串的参数的名称设置为显式的(AzureWebJobsStorage)。我们还通过在名称(%QueueName%)周围放置“%”字符，使队列名称成为一个配置参数。</p><p id="3b68" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">为了在函数本地运行时实现这一点，我们还需要将配置参数添加到local.settings.json，它在本地运行时充当函数的Azure配置参数。</p><figure class="mr ms mt mu gt jo"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="e519" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated"><strong class="kv io">接受消息为JSON </strong></p><p id="9f4f" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">因为排队消息的标准格式可能是json，所以创建一个简单的队列消息类:</p><figure class="mr ms mt mu gt jo"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="d327" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">将消息从json反序列化到QueueMessage类的实例，并记录消息详细信息:</p><figure class="mr ms mt mu gt jo"><div class="bz fp l di"><div class="mv mw l"/></div></figure><h2 id="9831" class="lx jw in bd jx ly lz dn kb ma mb dp kf le mc md kj li me mf kn lm mg mh kr mi bi translated">运行该功能</h2><blockquote class="mk ml mm"><p id="ec5e" class="kt ku mj kv b kw ls ky kz la lt lc ld mn lu lg lh mo lv lk ll mp lw lo lp lq ig bi translated">1.和第4部分一样，通过<strong class="kv io"> func start </strong>运行函数</p><p id="7a41" class="kt ku mj kv b kw ls ky kz la lt lc ld mn lu lg lh mo lv lk ll mp lw lo lp lq ig bi translated">2.在存储浏览器中，创建“本地队列”队列；并向队列中添加一条消息:</p></blockquote><figure class="mr ms mt mu gt jo"><div class="bz fp l di"><div class="mv mw l"/></div></figure><blockquote class="mk ml mm"><p id="3467" class="kt ku mj kv b kw ls ky kz la lt lc ld mn lu lg lh mo lv lk ll mp lw lo lp lq ig bi translated">3.该功能将显示记录的输出:</p></blockquote><figure class="mr ms mt mu gt jo"><div class="bz fp l di"><div class="mv mw l"/></div></figure><h1 id="0769" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">第6部分:在本地Docker容器中运行队列触发函数</h1><h2 id="c341" class="lx jw in bd jx ly lz dn kb ma mb dp kf le mc md kj li me mf kn lm mg mh kr mi bi translated">从本地Docker容器访问存储模拟器</h2><p id="8984" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">本地容器当然可以配置为引用实际的Azure存储队列:只需将容器中的AzureWebJobsStorage配置变量设置为Azure队列的连接字符串，我们将在第7部分中看到。然而，如果所有需要的工具和技术都在本地运行，那么进行本地开发会更方便。也许你的本地电脑无法连接到Azure。</p><p id="d5c8" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">由于该函数在容器中运行，而存储模拟器在主机操作系统中运行，因此面临的挑战是，默认情况下，容器无法连接到存储模拟器来从队列中提取消息。这可以通过将主机上容器可访问的端口代理到存储模拟器侦听的端口来解决。</p><p id="9f5b" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">根据<a class="ae lr" href="https://docs.microsoft.com/en-us/azure/storage/common/storage-use-emulator" rel="noopener ugc nofollow" target="_blank"> Azure存储模拟器</a>文档，模拟器监听本地127.0.0.1地址，使用端口10000用于blobs，10001用于队列，10002用于表。Docker利用Hyper-V虚拟以太网适配器作为交换机，在容器和主机之间提供连接。运行“ipconfig /all”可以看到这一点:</p><figure class="mr ms mt mu gt jo"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="b614" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">为了允许容器连接到存储模拟器，我们将虚拟交换机的IP地址上的端口40000、40001和40002(任意选择)代理到存储模拟器的端口(这必须在具有管理员权限的命令提示符下完成):</p><figure class="mr ms mt mu gt jo"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="220a" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">通过使用“netstat -an”查找监听端点来验证结果:</p><figure class="mr ms mt mu gt jo"><div class="bz fp l di"><div class="mv mw l"/></div></figure><h2 id="d58d" class="lx jw in bd jx ly lz dn kb ma mb dp kf le mc md kj li me mf kn lm mg mh kr mi bi translated">配置并构建本地Docker容器</h2><blockquote class="mk ml mm"><p id="189e" class="kt ku mj kv b kw ls ky kz la lt lc ld mn lu lg lh mo lv lk ll mp lw lo lp lq ig bi translated">1.将生成的Dockerfile重命名为Dockerfile.local</p><p id="b1ed" class="kt ku mj kv b kw ls ky kz la lt lc ld mn lu lg lh mo lv lk ll mp lw lo lp lq ig bi translated">2.编辑Dockerfile.local以添加其他环境变量设置:</p></blockquote><figure class="mr ms mt mu gt jo"><div class="bz fp l di"><div class="mv mw l"/></div></figure><blockquote class="mk ml mm"><p id="c126" class="kt ku mj kv b kw ls ky kz la lt lc ld mn lu lg lh mo lv lk ll mp lw lo lp lq ig bi translated">3.请注意AzureWebJobsStorage和QueueName环境变量。当通过“func start”或在Visual Studio中运行时，这些设置将取代local.settings.json文件中的设置。用于AzureWebJobsStorage的值是与local.settings.json中的“UseDevelopmentStorage=true”等效的连接字符串格式，请参见<a class="ae lr" href="https://docs.microsoft.com/en-us/azure/storage/common/storage-use-emulator" rel="noopener ugc nofollow" target="_blank"> Azure存储模拟器</a>的文档。不过，您会注意到IP地址和端口与我们上面代理的相匹配，例如<a class="ae lr" href="http://172.31.160.1:40001/" rel="noopener ugc nofollow" target="_blank">http://172 . 31 . 160 . 1:40001</a>。</p><p id="2a37" class="kt ku mj kv b kw ls ky kz la lt lc ld mn lu lg lh mo lv lk ll mp lw lo lp lq ig bi translated">4.按照第2部分中的过程，构建容器:<br/> <strong class="kv io"> docker build — file。\Dockerfile.local —标记local/queuetrigger01:v0.1.0。</strong></p><p id="8d80" class="kt ku mj kv b kw ls ky kz la lt lc ld mn lu lg lh mo lv lk ll mp lw lo lp lq ig bi translated">5.运行容器:<strong class="kv io">docker run-p:8080:80 local/queuetrigger 01:v 0 . 1 . 0</strong></p><p id="d575" class="kt ku mj kv b kw ls ky kz la lt lc ld mn lu lg lh mo lv lk ll mp lw lo lp lq ig bi translated">6.使用Azure Storage Explorer，向Azure Storage Emulator中名为“local-container-queue”的队列发布一条消息:</p></blockquote><figure class="mr ms mt mu gt jo"><div class="bz fp l di"><div class="mv mw l"/></div></figure><blockquote class="mk ml mm"><p id="b5e6" class="kt ku mj kv b kw ls ky kz la lt lc ld mn lu lg lh mo lv lk ll mp lw lo lp lq ig bi translated">7.当本地容器中运行的Azure函数轮询队列时，它将输出消息内容。与通过“func start”或Visual Studio运行函数相比，轮询通常需要更长的时间:</p></blockquote><figure class="mr ms mt mu gt jo"><div class="bz fp l di"><div class="mv mw l"/></div></figure><h1 id="311c" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">第7部分:将队列触发的功能容器部署到Azure</h1><p id="e0f1" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">这些步骤与第3部分中我们将HTTP触发器功能部署到Azure时的步骤非常相似。</p><blockquote class="mk ml mm"><p id="1b54" class="kt ku mj kv b kw ls ky kz la lt lc ld mn lu lg lh mo lv lk ll mp lw lo lp lq ig bi translated">1.将Docker.local文件复制到Docker.azure</p><p id="13f4" class="kt ku mj kv b kw ls ky kz la lt lc ld mn lu lg lh mo lv lk ll mp lw lo lp lq ig bi translated">2.从Docker.azure中移除AzureWebJobsStorage和QueueName环境设置，并将“Release”指定为构建配置:</p></blockquote><figure class="mr ms mt mu gt jo"><div class="bz fp l di"><div class="mv mw l"/></div></figure><blockquote class="mk ml mm"><p id="102d" class="kt ku mj kv b kw ls ky kz la lt lc ld mn lu lg lh mo lv lk ll mp lw lo lp lq ig bi translated">环境设置将在Azure Function app服务中配置。这允许将相同的容器部署到开发、测试、UAT和生产环境中。</p><p id="4e97" class="kt ku mj kv b kw ls ky kz la lt lc ld mn lu lg lh mo lv lk ll mp lw lo lp lq ig bi translated">3.构建容器:<strong class="kv io"> docker构建文件。\ docker file . azure—tag adhalejrawh/queuetrigger 01:v 0 . 1 . 0。</strong></p><p id="e530" class="kt ku mj kv b kw ls ky kz la lt lc ld mn lu lg lh mo lv lk ll mp lw lo lp lq ig bi translated">4.确保您已登录Docker Hub、Azure，并且在Azure中设置了正确的订阅。(参见<a class="ae lr" href="https://awhcode.atlassian.net/wiki/spaces/SI/pages/1234796682/Part+3+Azure+Functions+via+Linux+Containers" rel="noopener ugc nofollow" target="_blank">第三部分</a>)</p><p id="0ec6" class="kt ku mj kv b kw ls ky kz la lt lc ld mn lu lg lh mo lv lk ll mp lw lo lp lq ig bi translated">5.将集装箱推到码头中心:<strong class="kv io">码头推送adhalejrawh/queuetrigger 01:v 0 . 1 . 0</strong></p><p id="50f1" class="kt ku mj kv b kw ls ky kz la lt lc ld mn lu lg lh mo lv lk ll mp lw lo lp lq ig bi translated">6.确保在命令shell中设置了第3部分中的shell变量，并将$functionName设置为“awhlunchandlernqueuetriggerfunction”</p><p id="89d1" class="kt ku mj kv b kw ls ky kz la lt lc ld mn lu lg lh mo lv lk ll mp lw lo lp lq ig bi translated">7.创建函数:<strong class="kv io">az function app create-name $ function name-storage-account $ storage account-resource-group $ resource group-plan $ function plan-deployment-container-image-name adhalejrawh/queuetrigger 01:v 0 . 1 . 0-functions-version 3</strong><br/>注意，除非第3部分中的资源组、存储容器和应用服务计划已被删除，否则它们仍然存在并可应用于此函数。</p><p id="8f8f" class="kt ku mj kv b kw ls ky kz la lt lc ld mn lu lg lh mo lv lk ll mp lw lo lp lq ig bi translated">8.获取存储容器的连接字符串:<strong class="kv io">$ storageConnectionString = az storage account show-connection-string-resource-group $ resource group-name $ storage account-query connectionString-output tsv</strong></p><p id="a755" class="kt ku mj kv b kw ls ky kz la lt lc ld mn lu lg lh mo lv lk ll mp lw lo lp lq ig bi translated">9.设置连接字符串的配置设置:<strong class="kv io">az function app config appsettings set-name $ function name-resource-group $ resource group-settings azurewebjobstorage = $ storageConnectionString</strong></p><p id="2627" class="kt ku mj kv b kw ls ky kz la lt lc ld mn lu lg lh mo lv lk ll mp lw lo lp lq ig bi translated">10.设置队列名称的配置设置:<strong class="kv io">az function app config appsettings set—name＄function name—resource-group＄resource group—settings queue name = azure-container-queue</strong></p></blockquote><h2 id="68e6" class="lx jw in bd jx ly lz dn kb ma mb dp kf le mc md kj li me mf kn lm mg mh kr mi bi translated"><strong class="ak">验证队列触发功能</strong></h2><p id="109d" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">此时，Azure函数已经存在，并且具有连接到存储帐户和监视队列中的消息所需的配置设置。因为这个简单的函数不会产生验证它是否工作的结果，所以我们可以用两种方法来验证这个函数。</p><blockquote class="mk ml mm"><p id="84b3" class="kt ku mj kv b kw ls ky kz la lt lc ld mn lu lg lh mo lv lk ll mp lw lo lp lq ig bi translated">1.使用Azure Storage Explorer，将一条消息放入队列中，并查看它是否被选中，而不会被放入“有害”队列:</p></blockquote><figure class="mr ms mt mu gt jo gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/61017ef1e2a67bf92ebf38d0249d03b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:938/format:webp/1*nVYEnoW3a-caoDK8WgylKA.png"/></div></figure><blockquote class="mk ml mm"><p id="2b03" class="kt ku mj kv b kw ls ky kz la lt lc ld mn lu lg lh mo lv lk ll mp lw lo lp lq ig bi translated">如果该功能工作正常，在添加邮件后的大约1分钟内，邮件将从队列中消失(在Storage Explorer中对队列使用“刷新”)。</p><p id="0806" class="kt ku mj kv b kw ls ky kz la lt lc ld mn lu lg lh mo lv lk ll mp lw lo lp lq ig bi translated">“毒药”队列是当队列触发的函数因未处理的异常而退出时，Azure将创建的队列。病毒队列的名称是以“-poison”为后缀的队列名称。您可以通过刷新存储容器中的“队列”来检查是否创建了病毒队列。</p><p id="c438" class="kt ku mj kv b kw ls ky kz la lt lc ld mn lu lg lh mo lv lk ll mp lw lo lp lq ig bi translated">2.从Azure门户监控Azure功能的日志流:<br/>转到该订阅的Azure门户，选择Azure功能资源。转到右侧的“日志流”刀片，实时监控该功能的日志。然后将消息放入队列中。</p></blockquote><figure class="mr ms mt mu gt jo gh gi paragraph-image"><div class="gh gi my"><img src="../Images/d4a6b8acc57ed64e450c6181e21c4ffc.png" data-original-src="https://miro.medium.com/v2/resize:fit:966/format:webp/1*qpmsGP8Tcah9lwYzoSIP8Q.png"/></div></figure><p id="fe17" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">我们可以在日志流中看到函数日志消息的输出。</p><p id="5d94" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated"><strong class="kv io">结论</strong></p><p id="4534" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">在本教程中，我们创建了一个HTTP trigger Azure函数，在本地运行它，用该函数构建并运行一个本地Docker容器，并在Azure中部署和测试该函数。我们还创建了一个队列触发器Azure函数，使用Azure存储模拟器在本地运行它，在本地Docker容器中构建并运行该函数，同时监控Azure存储模拟器，并在Azure中部署和测试该函数。</p><p id="bcf9" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">有了这些技术的介绍，您就可以开始在Azure函数中实现您的应用程序逻辑了。</p><p id="c749" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated"><strong class="kv io">-唐尼·黑尔，AWH软件开发团队负责人</strong></p></div></div>    
</body>
</html>