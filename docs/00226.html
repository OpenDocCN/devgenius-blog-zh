<html>
<head>
<title>Learn Golang by building a fintech banking app — Lesson2: Login and REST API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过构建金融科技银行应用程序学习Golang第2课:登录和REST API</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/learn-golang-by-building-a-fintech-banking-app-lesson2-login-and-rest-api-5bfa2a27eec2?source=collection_archive---------1-----------------------#2020-05-22">https://blog.devgenius.io/learn-golang-by-building-a-fintech-banking-app-lesson2-login-and-rest-api-5bfa2a27eec2?source=collection_archive---------1-----------------------#2020-05-22</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/2ef6524390183f1f3461adff22516c0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sbE8Jrs50sfK_TMlDmz-Ow.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated"><a class="ae jz" href="https://www.duomly.com" rel="noopener ugc nofollow" target="_blank">在线编程课程</a></figcaption></figure><p id="b315" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">本帖原载:<br/><a class="ae jz" href="https://www.blog.duomly.com/golang-course-with-building-a-fintech-banking-app-lesson-2-login-and-rest-api" rel="noopener ugc nofollow" target="_blank">https://www . blog . duomly . com/golang-course-with-building-a-fin tech-banking-app-lesson-2-log in-and-rest-API</a></p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h1 id="9507" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">介绍</h1><p id="b740" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">在Golang课程的最后一集，我们做了一个项目设置和第一次数据库迁移。<br/> <br/>下面是网址:<br/><a class="ae jz" href="https://www.blog.duomly.com/golang-course-with-building-a-fintech-banking-app-lesson-1-start-the-project" rel="noopener ugc nofollow" target="_blank">https://www . blog . duomly . com/golang-course-with-building-a-fintech-banking-app-lesson-1-start-the-project</a><br/><br/>在《通过构建fin tech银行app学习Angular 9用Tailwind CSS》的最后一集里，我的朋友Anna创建了项目设置和第一次登录UI，你可以用它来连接我们的后端，构建完整的金融科技应用。</p><p id="1057" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">下面是网址:<br/><a class="ae jz" href="https://www.blog.duomly.com/angular-course-building-a-banking-application-with-tailwind-css-lesson-1-start-the-project/" rel="noopener ugc nofollow" target="_blank">https://www . blog . duomly . com/angular-course-building-a-banking-application-with-tailwind-CSS-lesson-1-start-the-project/</a><br/><br/>在今天的这一集里，你将学习到how Golang课程的第二部分，我们将重点介绍用户认证。我将教你如何构建登录功能以及如何创建REST API的第一个端点。<br/> <br/>我们将对旧代码进行一点重构，使其更加简洁。<br/> <br/>我们开始吧！<br/> <br/>顺便说一句，如果你更喜欢视频，这里有youtube版本:</p><figure class="mi mj mk ml gt jo"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">Golang课程第2课:登录和REST API</figcaption></figure><h1 id="7513" class="lf lg in bd lh li mo lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ms ma mb mc bi translated">重构接口</h1><p id="f15b" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">我们需要做的第一步是重构我们在前一集创建的接口。为此，我们需要创建名为“interfaces”的目录，并在该目录下创建名为“interfaces.go”的文件。</p><pre class="mi mj mk ml gt mt mu mv mw aw mx bi"><span id="3238" class="my lg in mu b gy mz na l nb nc">package interfaces</span><span id="465c" class="my lg in mu b gy nd na l nb nc">import "github.com/jinzhu/gorm"</span><span id="199d" class="my lg in mu b gy nd na l nb nc">type User struct {<br/>    gorm.Model<br/>  Username string<br/>    Email string<br/>    Password string<br/>}</span><span id="72a7" class="my lg in mu b gy nd na l nb nc">type Account struct {<br/>    gorm.Model<br/>  Type string<br/>    Name string<br/>    Balance uint<br/>    UserID uint<br/>}</span><span id="4140" class="my lg in mu b gy nd na l nb nc">type ResponseAccount struct {<br/>    ID uint<br/>    Name string<br/>    Balance int<br/>}</span><span id="21e4" class="my lg in mu b gy nd na l nb nc">type ResponseUser struct {<br/>    ID uint<br/>    Username string<br/>    Email string<br/>    Accounts []ResponseAccount<br/>}</span></pre><p id="165d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">接下来，我们需要使用interfaces.go文件中的结构，而不是migrations.go中的结构。<br/> <br/>您的migrations.go文件应该如下例所示。</p><pre class="mi mj mk ml gt mt mu mv mw aw mx bi"><span id="3352" class="my lg in mu b gy mz na l nb nc">package migrations</span><span id="53d0" class="my lg in mu b gy nd na l nb nc">import (<br/>    "duomly.com/go-bank-backend/helpers"<br/>    "duomly.com/go-bank-backend/interfaces"<br/>    _ "github.com/jinzhu/gorm/dialects/postgres"<br/>)</span><span id="05b2" class="my lg in mu b gy nd na l nb nc">func connectDB() *gorm.DB {<br/>    db, err := gorm.Open("postgres", "host=127.0.0.1 port=5432 user=postgres dbname=bankapp password=postgres sslmode=disable")<br/>    HandleErr(err)<br/>    return db<br/>}</span><span id="4ecc" class="my lg in mu b gy nd na l nb nc">func createAccounts() {<br/>    db := connectDB()</span><span id="43a9" class="my lg in mu b gy nd na l nb nc">    users := &amp;[2]interfaces.User{<br/>        {Username: "Martin", Email: "martin@martin.com"},<br/>        {Username: "Michael", Email: "michael@michael.com"},<br/>    }</span><span id="c839" class="my lg in mu b gy nd na l nb nc">    for i := 0; i &lt; len(users); i++ {<br/>        // Correct one way<br/>        generatedPassword := helpers.HashAndSalt([]byte(users[i].Username))<br/>        user := &amp;interfaces.User{Username: users[i].Username, Email: users[i].Email, Password: generatedPassword}<br/>        db.Create(&amp;user)</span><span id="718c" class="my lg in mu b gy nd na l nb nc">        account := &amp;interfaces.Account{Type: "Daily Account", Name: string(users[i].Username + "'s" + " account"), Balance: uint(10000 * int(i+1)), UserID: user.ID}<br/>        db.Create(&amp;account)<br/>    }<br/>    defer db.Close()<br/>}<br/></span><span id="8e61" class="my lg in mu b gy nd na l nb nc">func Migrate() {<br/>    User := &amp;interfaces.User{}<br/>    Account := &amp;interfaces.Account{}<br/>    db := connectDB()<br/>    db.AutoMigrate(&amp;User, &amp;Account)<br/>    defer db.Close()</span><span id="ee2a" class="my lg in mu b gy nd na l nb nc">    createAccounts()<br/>}</span></pre><h1 id="7aca" class="lf lg in bd lh li mo lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ms ma mb mc bi translated">重构ConnectDB到助手</h1><p id="3a20" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">下一步还将涉及migrations.go文件和helpers.go. <br/> <br/>我们需要将“connectDB”函数移动到helpers.go. <br/>接下来，我们需要通过命名为“ConnectDB”来导出它。</p><p id="cca6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最后一步是在migrations.go中重用它，但以导入的形式。你的helpers.go应该看起来像下面的例子:</p><pre class="mi mj mk ml gt mt mu mv mw aw mx bi"><span id="7984" class="my lg in mu b gy mz na l nb nc">package helpers</span><span id="ebdb" class="my lg in mu b gy nd na l nb nc">import (<br/>    "github.com/jinzhu/gorm"<br/>    _ "github.com/lib/pq"<br/>    "golang.org/x/crypto/bcrypt"<br/>)<br/></span><span id="e089" class="my lg in mu b gy nd na l nb nc">func HandleErr(err error) {<br/>    if err != nil {<br/>        panic(err.Error())<br/>    }<br/>}</span><span id="9339" class="my lg in mu b gy nd na l nb nc">func HashAndSalt(pass []byte) string {<br/>    hashed, err := bcrypt.GenerateFromPassword(pass, bcrypt.MinCost)<br/>    HandleErr(err)</span><span id="fbeb" class="my lg in mu b gy nd na l nb nc">    return string(hashed)<br/>}</span><span id="2393" class="my lg in mu b gy nd na l nb nc">func ConnectDB() *gorm.DB {<br/>    db, err := gorm.Open("postgres", "host=127.0.0.1 port=5432 user=postgres dbname=bankapp password=postgres sslmode=disable")<br/>    HandleErr(err)<br/>    return db<br/>}</span></pre><p id="7eb5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您的migrations.go应该类似于下面的示例:</p><pre class="mi mj mk ml gt mt mu mv mw aw mx bi"><span id="970e" class="my lg in mu b gy mz na l nb nc">package migrations</span><span id="1f81" class="my lg in mu b gy nd na l nb nc">import (<br/>    "duomly.com/go-bank-backend/helpers"<br/>    "duomly.com/go-bank-backend/interfaces"<br/>    _ "github.com/jinzhu/gorm/dialects/postgres"<br/>)</span><span id="9dd4" class="my lg in mu b gy nd na l nb nc">func createAccounts() {<br/>    db := helpers.ConnectDB()</span><span id="f0a5" class="my lg in mu b gy nd na l nb nc">    users := &amp;[2]interfaces.User{<br/>        {Username: "Martin", Email: "martin@martin.com"},<br/>        {Username: "Michael", Email: "michael@michael.com"},<br/>    }</span><span id="801b" class="my lg in mu b gy nd na l nb nc">    for i := 0; i &lt; len(users); i++ {<br/>        // Correct one way<br/>        generatedPassword := helpers.HashAndSalt([]byte(users[i].Username))<br/>        user := &amp;interfaces.User{Username: users[i].Username, Email: users[i].Email, Password: generatedPassword}<br/>        db.Create(&amp;user)</span><span id="991e" class="my lg in mu b gy nd na l nb nc">        account := &amp;interfaces.Account{Type: "Daily Account", Name: string(users[i].Username + "'s" + " account"), Balance: uint(10000 * int(i+1)), UserID: user.ID}<br/>        db.Create(&amp;account)<br/>    }<br/>    defer db.Close()<br/>}<br/></span><span id="af97" class="my lg in mu b gy nd na l nb nc">func Migrate() {<br/>    User := &amp;interfaces.User{}<br/>    Account := &amp;interfaces.Account{}<br/>    db := helpers.ConnectDB()<br/>    db.AutoMigrate(&amp;User, &amp;Account)<br/>    defer db.Close()</span><span id="d439" class="my lg in mu b gy nd na l nb nc">    createAccounts()<br/>}</span></pre><h1 id="7049" class="lf lg in bd lh li mo lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ms ma mb mc bi translated">创建登录功能</h1><p id="7af8" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">现在我们可以进入登录逻辑。<br/> <br/>我们要做的第一件事是创建一个名为“users”的目录和一个名为“users.go”的文件。<br/> <br/>在“users.go”中我们应该创建一个名为“users”的包，以及一个名为“Login”的空函数。<br/> <br/>函数“登录”要以“用户名”和“通行证”为字符串。我们应该能够返回一个“任何”类型的键的地图。你也应该导入一些dep，但是你可以从下面的例子中复制它们。</p><pre class="mi mj mk ml gt mt mu mv mw aw mx bi"><span id="3a1a" class="my lg in mu b gy mz na l nb nc">package users</span><span id="d9a5" class="my lg in mu b gy nd na l nb nc">import (<br/>    "time"</span><span id="8598" class="my lg in mu b gy nd na l nb nc">    "duomly.com/go-bank-backend/helpers"<br/>    "duomly.com/go-bank-backend/interfaces"<br/>    "github.com/dgrijalva/jwt-go"<br/>    "golang.org/x/crypto/bcrypt"<br/>)</span><span id="7a35" class="my lg in mu b gy nd na l nb nc">func Login(username string, pass string) map[string]interface{} {</span><span id="5c7c" class="my lg in mu b gy nd na l nb nc">}</span></pre><p id="a3b5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在登录名<br/>中连接数据库我们要做的下一件重要的事情是创建数据库连接，并从函数params中查找具有用户名的用户。<br/> <br/>我们需要记住带有RecordNotFound函数的“if”语句，如果用户处于“未找到”状态，该函数会通知我们。</p><pre class="mi mj mk ml gt mt mu mv mw aw mx bi"><span id="355e" class="my lg in mu b gy mz na l nb nc">db := helpers.ConnectDB()<br/>user := &amp;interfaces.User{}<br/>if db.Where("username = ? ", username).First(&amp;user).RecordNotFound() {<br/>    return map[string]interface{}{"message": "User not found"}<br/>}</span></pre><h1 id="ea83" class="lf lg in bd lh li mo lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ms ma mb mc bi translated">验证密码</h1><p id="672a" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">当我们有一个用户时，我们应该验证我们发送的密码是否正确。<br/> <br/>在同一个名为“Login”的函数中，我们需要使用一个方法“bcrypt”来创建简单的密码验证。CompareHashAndPassword”。<br/> <br/>接下来，我们需要创建if语句，在这里我们将检查我们的密码是否不匹配，是否没有错误。<br/> <br/>如果是，应该返回“密码错误”的消息。</p><pre class="mi mj mk ml gt mt mu mv mw aw mx bi"><span id="a90e" class="my lg in mu b gy mz na l nb nc">passErr := bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(pass))</span><span id="1b3c" class="my lg in mu b gy nd na l nb nc">if passErr == bcrypt.ErrMismatchedHashAndPassword &amp;&amp; passErr != nil {<br/>    return map[string]interface{}{"message": "Wrong password"}<br/>}</span></pre><h1 id="75b6" class="lf lg in bd lh li mo lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ms ma mb mc bi translated">为用户查找帐户</h1><p id="d669" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">现在我们有了用户、密码，所有的都已经验证过了，但是我们的用户还不完整。<br/> <br/>我们需要一个用户对象的银行账户。<br/> <br/>为了达到这个目的，我们应该用ResponseAccount类型定义var账户。<br/>我们将从该数组内的数据库中分配数据。<br/> <br/>接下来，我们需要请求数据库返回“帐户”表中所有记录的“id”、“name”和“balance”字段，其中“user_id”等于我们的用户id。</p><pre class="mi mj mk ml gt mt mu mv mw aw mx bi"><span id="fcf3" class="my lg in mu b gy mz na l nb nc">accounts := []interfaces.ResponseAccount{}<br/>db.Table("accounts").Select("id, name, balance").Where("user_id = ? ", user.ID).Scan(&amp;accounts)</span></pre><h1 id="18f3" class="lf lg in bd lh li mo lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ms ma mb mc bi translated">设置响应用户</h1><p id="1362" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">下一步，我们应该设置responseUser的结构，并为键赋值。</p><p id="e558" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在responseUser结构之后，我们可以关闭数据库连接。</p><pre class="mi mj mk ml gt mt mu mv mw aw mx bi"><span id="4ff0" class="my lg in mu b gy mz na l nb nc">responseUser := &amp;interfaces.ResponseUser{<br/>    ID: user.ID,<br/>    Username: user.Username,<br/>    Email: user.Email,<br/>    Accounts: accounts,<br/>}</span><span id="1c92" class="my lg in mu b gy nd na l nb nc">defer db.Close()</span></pre><h1 id="4b2c" class="lf lg in bd lh li mo lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ms ma mb mc bi translated">签名令牌</h1><p id="f3b5" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">“登录”功能的最后也是最关键的部分之一是我们应该设置和签名的JWT令牌。</p><p id="9223" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为此，我们将使用JWT方案。</p><p id="69b5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">看看在下面的例子中应该如何做。</p><pre class="mi mj mk ml gt mt mu mv mw aw mx bi"><span id="9f0e" class="my lg in mu b gy mz na l nb nc">tokenContent := jwt.MapClaims{<br/>    "user_id": user.ID,<br/>    "expiry": time.Now().Add(time.Minute * 60).Unix(),<br/>}<br/>jwtToken := jwt.NewWithClaims(jwt.GetSigningMethod("HS256"), tokenContent)<br/>token, err := jwtToken.SignedString([]byte("TokenPassword"))<br/>helpers.HandleErr(err)</span></pre><h1 id="22a1" class="lf lg in bd lh li mo lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ms ma mb mc bi translated">准备响应</h1><p id="2819" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">终于！“登录”功能的最后一部分是我们将返回到API中的响应。</p><p id="d7fb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们应该设置一个消息“一切正常”，我们的令牌传递给“jwt”键，responseUser传递给“data”参数。</p><pre class="mi mj mk ml gt mt mu mv mw aw mx bi"><span id="93ba" class="my lg in mu b gy mz na l nb nc">var response = map[string]interface{}{"message": "all is fine"}<br/>response["jwt"] = token<br/>response["data"] = responseUser</span><span id="65be" class="my lg in mu b gy nd na l nb nc">return response</span></pre><h1 id="688f" class="lf lg in bd lh li mo lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ms ma mb mc bi translated">创建一个API包</h1><p id="e48f" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">现在，我们可以进入API。<br/>我们应该完成的第一步是一个名为“api”的新目录，接下来创建一个具有相同名称和“go”扩展名的文件。</p><p id="a83e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这个文件中，我们应该声明一个名为“api”的包，并导入一些依赖项。</p><pre class="mi mj mk ml gt mt mu mv mw aw mx bi"><span id="b873" class="my lg in mu b gy mz na l nb nc">package api</span><span id="5815" class="my lg in mu b gy nd na l nb nc">import (<br/>    "encoding/json"<br/>    "fmt"<br/>    "io/ioutil"<br/>    "log"<br/>    "net/http"</span><span id="b2b0" class="my lg in mu b gy nd na l nb nc">    "duomly.com/go-bank-backend/helpers"<br/>    "duomly.com/go-bank-backend/users"</span><span id="4eec" class="my lg in mu b gy nd na l nb nc">    "github.com/gorilla/mux"<br/>)</span></pre><h1 id="057e" class="lf lg in bd lh li mo lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ms ma mb mc bi translated">在API中创建结构</h1><p id="a559" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">第二步是结构声明。</p><p id="6d2d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们应该创建两个结构体，第一个结构体名为“Login ”,其中“Username”是一个字符串,“Password”也是一个字符串。</p><p id="d175" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最后一个结构应声明为“ErrResponse ”,并将“Message”声明为字符串。</p><pre class="mi mj mk ml gt mt mu mv mw aw mx bi"><span id="c91a" class="my lg in mu b gy mz na l nb nc">type Login struct {<br/>    Username string<br/>    Password string<br/>}<br/></span><span id="d0f3" class="my lg in mu b gy nd na l nb nc">type ErrResponse struct {<br/>    Message string<br/>}</span></pre><h1 id="b5f4" class="lf lg in bd lh li mo lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ms ma mb mc bi translated">在API中创建一个登录函数</h1><p id="da21" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">在这一步，我们将为我们的API创建第一个函数。</p><p id="2da0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">应该命名为“login”，取“w http。ResponseWriter”和“r *http。请求”作为参数。</p><pre class="mi mj mk ml gt mt mu mv mw aw mx bi"><span id="8afd" class="my lg in mu b gy mz na l nb nc">func login(w http.ResponseWriter, r *http.Request) {</span><span id="7377" class="my lg in mu b gy nd na l nb nc">}</span></pre><h1 id="6a6f" class="lf lg in bd lh li mo lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ms ma mb mc bi translated">读取API调用的主体</h1><p id="a67c" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">“login”函数中的第一个逻辑是读取API请求主体的代码。我们应该指定“body”和“err”变量，并将“ioutil”赋值。ReadAll”，请求的正文在里面。<br/>接下来，我们需要通过使用“helpers”包中的“HandleErr”并在内部传递“Err”来验证是否一切正常。</p><pre class="mi mj mk ml gt mt mu mv mw aw mx bi"><span id="57ea" class="my lg in mu b gy mz na l nb nc">body, err := ioutil.ReadAll(r.Body)<br/>helpers.HandleErr(err)</span></pre><h1 id="2874" class="lf lg in bd lh li mo lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ms ma mb mc bi translated">处理登录</h1><p id="ff72" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">该功能最重要的部分是正确登录。</p><p id="3c44" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们需要定义一个类型为“Login”的变量，并在那里分配解组的请求体。</p><p id="8452" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">接下来，我们应该将格式化的用户名和密码传递给“users”。登录”。</p><p id="3fb1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们应该将该逻辑分配给名为“login”的变量。</p><pre class="mi mj mk ml gt mt mu mv mw aw mx bi"><span id="be65" class="my lg in mu b gy mz na l nb nc">var formattedBody Login<br/>err = json.Unmarshal(body, &amp;formattedBody)<br/>helpers.HandleErr(err)<br/>login := users.Login(formattedBody.Username, formattedBody.Password)</span></pre><h1 id="86f8" class="lf lg in bd lh li mo lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ms ma mb mc bi translated">准备API调用的响应</h1><p id="d740" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">调用登录后，要检查登录消息是否等于“一切正常”。</p><p id="448b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果是，我们应该声明一个名为“resp”的变量，并将登录名赋给它。</p><p id="b777" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">接下来，我们应该使用“json。NewEncoder”并编码我们的resp。</p><pre class="mi mj mk ml gt mt mu mv mw aw mx bi"><span id="0669" class="my lg in mu b gy mz na l nb nc">if login["message"] == "all is fine" {<br/>    resp := login<br/>    json.NewEncoder(w).Encode(resp)<br/>} else {</span><span id="b378" class="my lg in mu b gy nd na l nb nc">}</span></pre><h1 id="5c7f" class="lf lg in bd lh li mo lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ms ma mb mc bi translated">处理else中的错误</h1><p id="4145" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">现在，当我们处理“如果”语句时，我们也应该处理“错误”。</p><p id="89eb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为此，我们应该创建一个“else”语句，并在其中格式化一个响应。<br/> <br/>我们需要返回一个字符串为“用户名或密码错误”的“消息”，作为一个值。</p><p id="9abf" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这种反应应与阳性情况一样进行编码。</p><pre class="mi mj mk ml gt mt mu mv mw aw mx bi"><span id="24f4" class="my lg in mu b gy mz na l nb nc">if login["message"] == "all is fine" {<br/>    resp := login<br/>    json.NewEncoder(w).Encode(resp)<br/>} else {<br/>    resp := ErrResponse{Message: "Wrong username or password"}<br/>    json.NewEncoder(w).Encode(resp)<br/>}</span></pre><h1 id="dfc8" class="lf lg in bd lh li mo lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ms ma mb mc bi translated">创建startApi函数</h1><p id="c85c" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">在API逻辑的最后一步，我们应该创建一个合适的路由器，并处理我们的API端点。</p><p id="2ea5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们将使用gorilla mux创建一个路由器，首先，我们将定义接受“POST”方法的“/login”端点。</p><p id="2d0e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">接下来，我们应该在8888端口上设置一个HTTP侦听器。</p><pre class="mi mj mk ml gt mt mu mv mw aw mx bi"><span id="9fc6" class="my lg in mu b gy mz na l nb nc">func StartApi() {<br/>    router := mux.NewRouter()<br/>    router.HandleFunc("/login", login).Methods("POST")<br/>    fmt.Println("App is working on port :8888")<br/>    log.Fatal(http.ListenAndServe(":8888", router))</span><span id="7df7" class="my lg in mu b gy nd na l nb nc">}</span></pre><h1 id="8ad6" class="lf lg in bd lh li mo lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ms ma mb mc bi translated">在主函数中实现API</h1><p id="cde3" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">API准备好了！<br/>要让它工作，我们应该在“main.go”文件的“main”函数中实现API。</p><p id="746a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">检查下面的例子。</p><pre class="mi mj mk ml gt mt mu mv mw aw mx bi"><span id="c0c3" class="my lg in mu b gy mz na l nb nc">package main</span><span id="68a6" class="my lg in mu b gy nd na l nb nc">import "duomly.com/go-bank-backend/api"</span><span id="f263" class="my lg in mu b gy nd na l nb nc">func main() {<br/>    // migrations.Migrate()<br/>    api.StartApi()<br/>}</span></pre><h1 id="5279" class="lf lg in bd lh li mo lk ll lm mp lo lp lq mq ls lt lu mr lw lx ly ms ma mb mc bi translated">运行API</h1><p id="f9d5" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">呜哇！<br/>现在你可以运行你的应用并开始测试了。<br/>打开项目目录中的终端，键入:</p><pre class="mi mj mk ml gt mt mu mv mw aw mx bi"><span id="a278" class="my lg in mu b gy mz na l nb nc">go run main.go</span></pre><p id="5214" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">结论<br/>恭喜你，你的项目有了登录和第一个rest API。<br/> <br/>你可以从课程开始连接它与前端:<br/> <br/> <a class="ae jz" href="https://www.blog.duomly.com/angular-course-building-a-banking-application-with-tailwind-css-lesson-1-start-the-project/" rel="noopener ugc nofollow" target="_blank">通过搭建fintech银行app </a> <br/> <br/>用Tailwind CSS学习Angular 9如果你想把代码和我做的做个对比这里是网址:<br/><br/><a class="ae jz" href="https://github.com/Duomly/go-bank-backend%C2%A0" rel="noopener ugc nofollow" target="_blank">https://github.com/Duomly/go-bank-backend</a><br/><br/>这节课的分支名为“Golang-course-Lesson-2”。<br/> <br/>下节课我们将构建用户注册时再见。</p><figure class="mi mj mk ml gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ne"><img src="../Images/da0dbcf44b16aceb7cca413a6d9a5ef7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LJmZtnXM9S7lwHQJTEQngg.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated"><a class="ae jz" href="https://www.duomly.com" rel="noopener ugc nofollow" target="_blank">编程课程在线</a></figcaption></figure><p id="6552" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">感谢您的阅读，来自Duomly的Radek</p></div></div>    
</body>
</html>