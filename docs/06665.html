<html>
<head>
<title>Canvas Translation and State Management — Custom Views on Android — Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">画布翻译和状态管理 Android 上的自定义视图——第 2 部分</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/canvas-translation-and-state-management-custom-views-on-android-part-2-1428171b4eef?source=collection_archive---------6-----------------------#2022-01-24">https://blog.devgenius.io/canvas-translation-and-state-management-custom-views-on-android-part-2-1428171b4eef?source=collection_archive---------6-----------------------#2022-01-24</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/9dd69017a69247ee87f9486a9e8a2106.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PcHe8dLSi0CVoo_GBkcKqA.jpeg"/></div></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk translated">图片来源:<a class="ae ja" href="https://www.pexels.com/@thesocialsundae" rel="noopener ugc nofollow" target="_blank">卡莉·赖特</a>——佩克斯</figcaption></figure><div class=""/><p id="2c19" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ky">欢迎来到本系列关于 Android 定制视图的第二部分。这是上一篇文章</em> <a class="ae ja" href="https://medium.com/@olaolaore/an-introduction-to-custom-views-on-android-part-1-4972a10fb133" rel="noopener"> <em class="ky">之后的内容，上一篇文章解释了使用定制视图</em> </a> <em class="ky">(及其实现)的基本原理，所以如果您还没有阅读过这篇文章，那么您可能想先浏览一下。</em></p><p id="d27d" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ky">在本文中，我们将重点关注画布翻译，并通过使其动态化来为我们的自定义视图添加一些特色。好吧，让我们开始吧！</em></p><h2 id="c648" class="kz la jd bd lb lc ld dn le lf lg dp lh kl li lj lk kp ll lm ln kt lo lp lq lr bi translated">画布翻译</h2><p id="6e99" class="pw-post-body-paragraph ka kb jd kc b kd ls kf kg kh lt kj kk kl lu kn ko kp lv kr ks kt lw kv kw kx ig bi translated">Android 画布有一个<strong class="kc je">原点</strong>，所有绘制都从这里调用“开始”/“测量”。通常，这是视图中左上角的点(0，0)。如果我们想在画布上的不同点上绘制多个对象，那么试图在我们想要绘制的每个点上保持标签会变得很忙乱。以这张图表为例。</p><figure class="ly lz ma mb gt ip gh gi paragraph-image"><div class="gh gi lx"><img src="../Images/701af526a9bdacadcac00418cffc83a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:936/format:webp/1*5Y3z2oeUvd0ujV-NdewcDA.png"/></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk translated">没有画布平移的绘图元素</figcaption></figure><p id="dc40" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">有点过了？我也这么认为。但是不需要太多的细节，这就是当我们有大量的元素要画，并且我们最终从原点开始计算坐标值时，模糊的画看起来会是什么样子。正如您在上面看到的，每条线都来自原点，这使得很难记住和维护何时需要进行更改，因为当一个点改变位置时，其他每个点都必须重新计算。</p><p id="68e9" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一个解决方法是将  <em class="ky"> </em>画布进行<strong class="kc je"> <em class="ky">平移，这有助于我们从本质上“移动”原点，所以我们在绘制时不用太担心周围的坐标，除了我们想要绘制的元素的坐标。下图<strong class="kc je">试图</strong>提供更多的清晰度。</em></strong></p><figure class="ly lz ma mb gt ip gh gi paragraph-image"><div class="gh gi mc"><img src="../Images/05c380c5069196a97eb54b619f0a3fbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/format:webp/1*cdMmpQTK8o1X75mKOJ7gPQ.png"/></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk translated">通过画布平移改进绘图</figcaption></figure><p id="525a" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这个“翻译”版本中，我们看到了一些不同的东西。我们只使用实际的原点(左上角)来绘制矩形，而不是每次绘制操作都从原点重新计算点。之后，我们将整个原点平移到三角形的顶部。一旦到了这里，我们需要做的就是用新的原点画出三角形。</p><p id="21f0" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最后，我们最后一次平移到画布上的另一个位置，这个位置作为一个圆的中心，然后我们用半径画圆。</p><p id="ff3c" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这在很大程度上有助于消除绘制大量形状时从画布的实际原点进行不必要的重复计算。当需要时，我们可以通过将画布原点移动到下一个绘制调用的区域来抵制所有这些。</p><h2 id="8f03" class="kz la jd bd lb lc ld dn le lf lg dp lh kl li lj lk kp ll lm ln kt lo lp lq lr bi translated">现在我们明白了为什么我们想要翻译画布，那么我们该怎么做呢？</h2><blockquote class="md"><p id="455b" class="me mf jd bd mg mh mi mj mk ml mm kx dk translated">canvas.translate(x，y)</p></blockquote><p id="aba8" class="pw-post-body-paragraph ka kb jd kc b kd mn kf kg kh mo kj kk kl mp kn ko kp mq kr ks kt mr kv kw kx ig bi translated">x 和 y 参数表示画布原点应该移动到的点——我们的新原点(我们的绘制调用将从这里开始)。为了更好地理解这个概念，让我们通过移动画布的原点来绘制另一组形状。</p></div><div class="ab cl ms mt hr mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ig ih ii ij ik"><h2 id="e901" class="kz la jd bd lb lc ld dn le lf lg dp lh kl li lj lk kp ll lm ln kt lo lp lq lr bi translated">我们会画什么</h2><p id="cff7" class="pw-post-body-paragraph ka kb jd kc b kd ls kf kg kh lt kj kk kl lu kn ko kp lv kr ks kt lw kv kw kx ig bi translated">我们将绘制与上一篇文章中相同的形状，但是位置不同(样式也不同)。这一次，我们的形状将被勾勒出来，这将使用 Paint 类中的一种样式来完成。让我们从创建画图对象开始。</p><figure class="ly lz ma mb gt ip"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="b9f3" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在上面的代码片段中，我们创建了一个名为<strong class="kc je"> outlinedRectPaint </strong>的 paint 对象。在 init 块中，我们像往常一样设置颜色，但是现在我们设置 paint 对象的 style 属性。我们有三个绘画风格的选项，它们是:<em class="ky">填充</em>、<em class="ky">填充和描边</em>和<em class="ky">描边</em>。我们将使用笔画，因为我们希望我们的形状有轮廓/边框样式。最后，我们设置形状笔画的宽度(多大)。</p><p id="6dcf" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在 onDraw 方法中:</p><figure class="ly lz ma mb gt ip"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="cebb" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后我们定义我们的 drawOutlinedRectangle 方法。在这个方法中，我们首先将画布平移到一个新的原点，然后绘制我们的形状。这是在下面的代码中完成的:</p><figure class="ly lz ma mb gt ip"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="7b29" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，translate 方法获取 x 和 y 坐标，并转换到这些线(x，y)相交的点。我们在 x 轴上不做任何移动(因此为 0)，但在 y 轴上向下移动 160px。这可以在下图中看到</p><figure class="ly lz ma mb gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi nb"><img src="../Images/e045527d29eab57c5649b87f7f4353fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aSGI94253EemD48IYaEhmA.png"/></div></div></figure><p id="9591" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一旦完成，我们用画图对象画出我们的矩形。记住，我们已经移动了画布原点，所以我们当前的位置<strong class="kc je"> (0，160) </strong>实际上是我们新的<strong class="kc je"> (0，0) </strong>。</p><p id="c30a" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">接下来，我们在画布的另一边画一个圆形。</p><h2 id="5581" class="kz la jd bd lb lc ld dn le lf lg dp lh kl li lj lk kp ll lm ln kt lo lp lq lr bi translated">画一个有轮廓的圆。</h2><p id="0bd7" class="pw-post-body-paragraph ka kb jd kc b kd ls kf kg kh lt kj kk kl lu kn ko kp lv kr ks kt lw kv kw kx ig bi translated">首先，我们开始创建我们的圆形绘制对象。</p><figure class="ly lz ma mb gt ip"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="f483" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们基本上经历了与第一个绘制对象相同的过程，只是这次有所不同。然后，我们在 onDraw 方法中添加函数调用。</p><figure class="ly lz ma mb gt ip"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="be35" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在我们的 drawOutlinedCircle 方法中，我们从再次转换画布原点开始。从视图宽度将 X 设置为 75px(考虑半径)，Y 轴是 75px 加上之前的 Y 位置 160px(再次考虑半径)。</p><figure class="ly lz ma mb gt ip"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="8163" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果你注意到了，X 轴和 Y 轴相交的点是圆心，所以我们保持该点为我们的 X 轴和 Y 轴坐标，因此为(0，0)。然后我们用 75px 作为我们的圆半径。然后我们得出这个结果。</p><figure class="ly lz ma mb gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi nb"><img src="../Images/bb527538c75a5c4732ca30af808e6299.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yypm0bmJBwPBUVYQ0DZiiQ.png"/></div></div></figure><p id="6735" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">既然我们已经学会了如何画矩形和圆形，让我们试着通过改变形状的状态来使它们变得动态。</p><h1 id="6e75" class="nc la jd bd lb nd ne nf le ng nh ni lh nj nk nl lk nm nn no ln np nq nr lq ns bi translated">管理视图状态</h1><p id="f008" class="pw-post-body-paragraph ka kb jd kc b kd ls kf kg kh lt kj kk kl lu kn ko kp lv kr ks kt lw kv kw kx ig bi translated">大多数时候，我们想要改变我们的自定义视图的状态。我们可能希望它通过改变它的一些属性来做出反应或制作动画，或者根据用户交互(触摸、按住、拖动等)来改变一些细节。当使用自定义视图时，告诉视图其状态需要更改的一种方法是用更改的属性重绘视图。</p><p id="875b" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">按照这种思路，当视图发生变化时，我们可能会想到调用 onDraw，但是当视图准备好时，视图本身会调用 onDraw——所以我们不能这样做。另一方面，我们得到了一个叫做<code class="fe nt nu nv nw b">invalidate()</code>的便利实用程序。当这个方法被调用时，我们告诉视图一些视图属性已经改变，当前的渲染是无效的，需要被改变。<code class="fe nt nu nv nw b">invalidate</code>指示视图重绘其状态。</p><h2 id="409c" class="kz la jd bd lb lc ld dn le lf lg dp lh kl li lj lk kp ll lm ln kt lo lp lq lr bi translated">那么我们会做什么呢？</h2><p id="a688" class="pw-post-body-paragraph ka kb jd kc b kd ls kf kg kh lt kj kk kl lu kn ko kp lv kr ks kt lw kv kw kx ig bi translated">我们将在自定义视图的底部添加一个按钮，点击后，我们可以改变在自定义视图中绘制的形状的颜色。我们首先给视图一个固定的高度(300dp ),并将按钮放在下面的代码中:</p><figure class="ly lz ma mb gt ip"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="3619" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在连接切换按钮之前，我们将采用的方法是拥有一个随机颜色列表，当单击按钮时，我们将在列表的边界内获得一个随机索引，并为 paint 对象设置一个新颜色。在下面的代码中，我们添加了颜色列表和获取随机索引的逻辑。</p><figure class="ly lz ma mb gt ip"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="9086" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在上面的代码片段中，我们创建了一个颜色列表，<code class="fe nt nu nv nw b">getRandomIndex</code>方法返回一个介于 0 和颜色列表最后一个索引之间的索引。让我们继续定义切换颜色的逻辑。</p><figure class="ly lz ma mb gt ip"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="87e9" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在上面的代码中，在我们为所有四个 paint 对象设置了新的颜色之后，我们调用了<code class="fe nt nu nv nw b">invalidate()</code>，这用新的颜色重绘了我们的视图状态。我们现在可以从视图中链接按钮。</p><figure class="ly lz ma mb gt ip"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="08e5" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这样，在运行应用程序后，我们得到了下面的结果。单击切换按钮会改变自定义视图中的形状状态。</p><figure class="ly lz ma mb gt ip gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/d9cfbf8d4606936784ee47421945fd9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*XtbeERLbc9684xAdwBfP2w.gif"/></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk translated">将动态应用到自定义视图后的输出。</figcaption></figure><h2 id="6be1" class="kz la jd bd lb lc ld dn le lf lg dp lh kl li lj lk kp ll lm ln kt lo lp lq lr bi translated">咻！，这是一个漫长的。</h2><p id="0ea0" class="pw-post-body-paragraph ka kb jd kc b kd ls kf kg kh lt kj kk kl lu kn ko kp lv kr ks kt lw kv kw kx ig bi translated">在这篇文章中，我们学习了如何翻译画布原点，并使绘图调用和计算更简洁、更易读。我们还学习了如何通过利用 invalidate 方法的超级能力来修改视图状态。如果你对本文或<a class="ae ja" href="https://medium.com/@olaolaore/an-introduction-to-custom-views-on-android-part-1-4972a10fb133" rel="noopener">前一篇</a>中讨论的任何概念有任何疑问，请在下面留言或在<a class="ae ja" href="https://twitter.com/OlaOlaore" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上联系我。我很乐意回答。</p><p id="9bc9" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">干杯！，感谢您的阅读。</p></div></div>    
</body>
</html>