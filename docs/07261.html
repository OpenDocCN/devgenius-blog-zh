<html>
<head>
<title>JUnit5: Parallelization of Parameterized Tests (Only)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JUnit5:参数化测试的并行化(仅限)</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/junit5-parallelization-of-parameterized-tests-only-57ddb00233fa?source=collection_archive---------4-----------------------#2022-03-10">https://blog.devgenius.io/junit5-parallelization-of-parameterized-tests-only-57ddb00233fa?source=collection_archive---------4-----------------------#2022-03-10</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="222a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi ki translated">亲爱的读者，你好！今天，我将向您展示一篇关于如何并行化 JUnit5 参数化测试的快速文章(仅限于)。</p></div><div class="ab cl kr ks hr kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ig ih ii ij ik"><h1 id="d0bf" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">语境</h1><p id="68f5" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">最近，我需要提高我的 JUnit 集成测试用例的效率，因为这些测试用例由于其顺序性质而在运行时花费了大量时间，因此，通过延迟最新功能进入生产环境，损害了我们的 CI/CD 管道部署并最终损害了我们的最终客户。</p><p id="e285" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">作为我尝试提高测试用例效率和性能的一部分，我决定使用最近 JUnit5 的一个实验特性:<a class="ae mb" href="https://junit.org/junit5/docs/snapshot/user-guide/#writing-tests-parallel-execution" rel="noopener ugc nofollow" target="_blank">并行执行</a>。这个特性的目标是允许客户轻松地管理他们的测试用例的执行顺序，允许他们有选择地并行运行，从而降低测试执行的速度。</p><p id="8008" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">请注意，对于我的特定用例，这样的测试用例在相同的实体上对不同的测试执行情况有效，因此必须只对参数化的测试实现并发性(而不是对一个类的所有测试方法)。因此，提高性能的一个要求是只并发运行参数化测试的测试用例，每个测试用例仍然必须按顺序运行。</p></div><div class="ab cl kr ks hr kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ig ih ii ij ik"><h1 id="d10b" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">履行</h1><p id="1362" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">既然已经知道了需求，那就让我们动手吧！</p><p id="1d00" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了在您的应用中启用并行化特性，第一步是在您的包的<code class="fe mc md me mf b">/src</code>文件夹中创建一个<code class="fe mc md me mf b">junit-platform.properties</code>配置文件，以便启用并行化特性，如下所示:</p><figure class="mg mh mi mj gt mk"><div class="bz fp l di"><div class="ml mm l"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">JUnit 并行性的配置</figcaption></figure><p id="7993" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">俗话说<em class="mr">“一张图片胜过百万字”</em>，在这种情况下，它非常适合如何解释 JUnit 关于两个可用并发配置属性的并发性(<code class="fe mc md me mf b">junit.jupiter.execution.parallel.mode.default</code>、<code class="fe mc md me mf b">junit.jupiter.execution.parallel.mode.classes.default</code>，摘自<a class="ae mb" href="https://junit.org/junit5/docs/snapshot/user-guide/#writing-tests-parallel-execution" rel="noopener ugc nofollow" target="_blank">文档</a>):</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi ms"><img src="../Images/1e08e3ef8db9b1ca62396e1c593eacab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5MxtKdqG3kba7OelHwz1tg.png"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">JUnit5 并行性—可能的配置</figcaption></figure><p id="ab4b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如前所述，我们案例中使用的配置支持并行化特性以及测试执行的默认行为规范按顺序运行(<code class="fe mc md me mf b">same_thread</code> - bucket 1)。这将满足我们按顺序运行测试用例和测试类的需求。</p><p id="c276" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用当前的配置，我们将会看到执行将会顺序运行所有的测试方法(包括参数化测试)。等等…但这不是我们想要的！是的，为了同时运行选定的参数化测试，需要实现一个变通方法:使用 JUnit5 嵌套类，其目标是对内部非静态类的测试用例进行分组，以便可以与父实例(顶级类)共享状态。为此，必须指定<code class="fe mc md me mf b"><a class="ae mb" href="https://junit.org/junit5/docs/5.4.1/api/org/junit/jupiter/api/Nested.html" rel="noopener ugc nofollow" target="_blank">@Nested</a></code>注释。</p><p id="cf1c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了实现我们只并行化参数化测试的目标，我们将需要用<code class="fe mc md me mf b"><a class="ae mb" href="https://junit.org/junit5/docs/5.3.0/api/org/junit/jupiter/api/parallel/Execution.html" rel="noopener ugc nofollow" target="_blank">@Execution</a></code>注释来注释嵌套类参数化测试方法，说明这样的测试方法应该如何运行，也称为<em class="mr">执行模式</em> : <code class="fe mc md me mf b">CONCURRENT</code>(并行)或<code class="fe mc md me mf b">SAME_THREAD</code>(顺序)。</p><p id="d044" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这种方法的思想是使用嵌套类作为测试类的子组，其中包含的测试方法都应该并行运行(用<code class="fe mc md me mf b">CONCURRENT</code>执行模式注释)。因此，在一个类中可以有不同的参数化测试方法(细分为嵌套类),并且可以对如何运行这些方法进行细粒度的控制。</p><p id="7555" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了更好地理解这是如何实现的，下面是一个简单的 JUnit 测试类的粘贴，它遵循了建议的方法。</p><figure class="mg mh mi mj gt mk"><div class="bz fp l di"><div class="ml mm l"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">并行测试用例</figcaption></figure><p id="d43d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">根据上面的要点，很明显在顶级测试类中创建了两个嵌套类。每个类都有自己的参数化测试方法，用<code class="fe mc md me mf b">@Execution(ExecutionMode.CONCURRENT)</code>标注，这意味着嵌套类中的方法应该并行运行。</p><p id="dadf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">请记住，我们运行测试的默认配置是顺序的，因此默认情况下，嵌套类将按顺序实例化(顺序执行)。有了<code class="fe mc md me mf b">CONCURRENT</code>执行模式注释的规范，在每个内部类中定义的参数化测试将并行运行，从而实现预期的目标。下面的要点给出了上述代码的执行结果。</p><figure class="mg mh mi mj gt mk"><div class="bz fp l di"><div class="ml mm l"/></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">并行测试执行结果</figcaption></figure><p id="428e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如前所述，很明显，对于每个嵌套类(顺序执行)，有两个独立的容器<em class="mr">旋转</em> <em class="mr">上升</em>，对于嵌套类内部的每个参数化测试运行，并发性得到了保证，正如日志所证明的。因此，目标达到了:混合执行解决方案的实现关注于使用参数化测试的细粒度并发模式顺序运行测试方法。</p></div><div class="ab cl kr ks hr kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ig ih ii ij ik"><h1 id="55b1" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">结论</h1><p id="a400" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">在本文中，我们展示了如何轻松地执行参数化测试的并发测试用例，同时顺序运行一个类的其余测试方法。这对于那些想要在保证高度可靠的测试基础设施的同时改进他们的测试用例执行的团队来说可能是有用的。</p><p id="578f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们的管道中使用了所提出的方法，自部署以来，我们已经看到测试执行时间从大约 330000 毫秒显著减少到大约 73000 毫秒(～-78%)！</p><p id="3769" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我希望这篇文章是有价值的和翔实的。如果这对你有用，请随时告诉我。下次再见！</p></div><div class="ab cl kr ks hr kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ig ih ii ij ik"><h1 id="e437" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">参考</h1><ul class=""><li id="4e8a" class="mz na in jm b jn lw jr lx jv nb jz nc kd nd kh ne nf ng nh bi translated">【https://junit.org/junit5/docs/current/user-guide/ T4】</li><li id="a77f" class="mz na in jm b jn ni jr nj jv nk jz nl kd nm kh ne nf ng nh bi translated"><a class="ae mb" href="https://www.baeldung.com/junit-5-parallel-tests" rel="noopener ugc nofollow" target="_blank">https://www.baeldung.com/junit-5-parallel-tests</a></li><li id="965d" class="mz na in jm b jn ni jr nj jv nk jz nl kd nm kh ne nf ng nh bi translated"><a class="ae mb" href="https://stackoverflow.com/questions/39470022/running-junit-parameterized-tests-not-classes-in-parallel" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/39470022/running-JUnit-parameterized-tests-not-class-in-parallel</a></li></ul></div></div>    
</body>
</html>