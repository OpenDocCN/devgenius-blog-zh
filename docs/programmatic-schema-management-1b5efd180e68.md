# 编程模式管理

> 原文：<https://blog.devgenius.io/programmatic-schema-management-1b5efd180e68?source=collection_archive---------6----------------------->

文章首发@ own your data . ai。

在[上一篇关于传统与现代数据处理的文章](https://ownyourdata.ai/wp/traditional-vs-modern-analytics-data-processing-part-1/)中，我讨论了依赖自动模式发现时可能遇到的问题。我仍然认为这对于实验来说是一个非凡的特性，但是对于生产(面向用户)应用程序来说，我相信模式应该得到管理，数据契约应该到位。

# 作为代码的模式管理

在 Python 应用程序开发中，web 框架在数据库模型和数据库迁移的帮助下提供模式管理特性。开发人员不需要编写 SQL 来定义他们的数据库对象，他们不需要连接到生产环境来部署他们的更改(当然，部署时可能出现的问题除外)。通过这一过程，应用团队实现了:

*   作为代码的模式管理
*   作为 CI/CD 一部分的模式管理

如果不是代码，什么是表模式？我认为模式是基础设施，而不是数据资产。两者的主要区别在于，基础设施由部署管道管理，而数据资产由执行管道管理。

![](img/86785b10d6a7b1844928620dd36323a9.png)

在现代数据平台设置中，我们经常会看到数据的完全刷新包括:

*   重新定义模式
*   重新加载数据

通过在运行时重新定义模式，将会丢失模式的所有重要历史元数据。时间旅行特征变得不可用，因为对象创建的元数据被覆盖。因此，我认为模式(面向用户的应用程序)应该在部署时而不是运行时进行管理。

那么如何管理这个模式呢？

# DDL 脚本

在任何数据平台中，模式都是通过数据定义语言来管理的，数据定义语言包含“创建”、“替换”、“更改”、“删除”等命令。标准流程是这样的，数据工程师用 DDL 创建一个 SQL 脚本，并打包它以便部署。在部署时，脚本通常是手动执行的，并且涉及到大量的复制/粘贴工作(或者使用内部工具来避免这种手动操作)。一个这样的 DDL 脚本是:

```
create table raw_orders_managed(
    id integer primary key,
    order_timestamp timestamp not null,
    customer_id integer not null,
    order_status varchar(10) not null,
    order_amount decimal(10,2) not null,
    order_currency varchar(3) not null,
    products jsonb,
    inserted_datetime timestamp not null default current_timestamp 
);
```

# 作为代码的模式—地形

如果你已经在云上工作，你可以使用 terraform 来管理你的基础设施组件作为代码。对于任何云提供商，您都可以轻松找到定义表格所需的模块，请查看附录中的链接。

# 模式作为代码— Python

如果您作为软件工程师和数据工程师使用 Python，那么您一定已经使用过 SQLAlchemy。它是一个对象关系映射器，提供了连接数据库、执行 SQL (DDL 和 DML)等实用工具，并且在默认情况下，提供了连接大多数事务数据库的连接器。作为这样一个常用的工具，分析数据库也在实现它们的连接器(查看附录章节的方言页面)。

在上一篇文章中，我已经用它删除并重新创建了托管 Postgres 表:

![](img/77240003683339b60a5ec7c56299228b.png)

通过使用 sqlalchemy 连接器，我们可以开始用底层数据库的方言定义表:我们可以定义键、约束和默认值。更重要的是，通过我们自己管理模式，我们可以轻松地确保我们的流程是[可审计的](https://ownyourdata.ai/wp/a-way-to-ensure-auditability-in-data-processing/)，这是我们无法通过自动模式发现实现的(在数据库世界中，通过 Spark 我们可以利用元数据信息！).

# alembic 简介

Alembic 是一个数据库迁移工具，使用它您可以:

1.  执行您自己的 DDL/DML
2.  为您自动生成 CREATE 和 ALTER 语句
3.  作为部署管道的一部分执行迁移

## 设置

用`pip install alembic`或`poetry add alembic`安装 alembic。运行`alembic init database_management`，这将创建:

*   将保存迁移文件的名为`database_management`的目录
*   需要配置连接字符串的文件`alembic.ini`:

```
sqlalchemy.url = postgresql://postgres:postgres@postgres_db:5432/postgres
```

首先，我在一个. py 文件中创建一个 SQLAlchemy 模型:

```
from sqlalchemy.ext.declarative import declarative_basefrom sqlalchemy import Column
from sqlalchemy import DateTime
from sqlalchemy import Integer
from sqlalchemy import String
from sqlalchemy.sql import funcBase = declarative_base() class RawCustomer(Base):
    __tablename__ = "raw_customer" id = Column(Integer, primary_key=True, index=True)
    email_address = Column(String(320), unique=True)
    first_name = Column(String(100))
    last_name = Column(String(100))
    inserted_datetime = Column(DateTime, server_default=func.now()) class Config:
        orm_mode = True
```

我通过运行`alembic revision --autogenerate -m "Create Raw Customer table"`生成迁移脚本，这将在`data_management/versions`下生成一个迁移文件:

```
"""Create Raw Customer tableRevision ID: 8d79a6002e55
Revises: 
Create Date: 2022-11-10 07:47:35.492949"""
from alembic import op
import sqlalchemy as sa # revision identifiers, used by Alembic.
revision = '8d79a6002e55'
down_revision = None
branch_labels = None
depends_on = None def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('raw_customer',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('email_address', sa.String(length=320), nullable=True),
    sa.Column('first_name', sa.String(length=100), nullable=True),
    sa.Column('last_name', sa.String(length=100), nullable=True),
    sa.Column('inserted_datetime', sa.DateTime(), server_default=sa.text('now()'), nullable=True),
    sa.PrimaryKeyConstraint('id'),
    sa.UniqueConstraint('email_address')
    )
    op.create_index(op.f('ix_raw_customer_id'), 'raw_customer', ['id'], unique=False)
    # ### end Alembic commands ### def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_index(op.f('ix_raw_customer_id'), table_name='raw_customer')
    op.drop_table('raw_customer')
    # ### end Alembic commands ###
```

为了应用它，只需运行`alembic upgrade head`，现在就在数据库上创建了表:

```
postgres=# \d raw_customer
                                            Table "public.raw_customer"
      Column       |            Type             | Collation | Nullable |                 Default                  
-------------------+-----------------------------+-----------+----------+------------------------------------------
 id                | integer                     |           | not null | nextval('raw_customer_id_seq'::regclass)
 email_address     | character varying(320)      |           |          | 
 first_name        | character varying(100)      |           |          | 
 last_name         | character varying(100)      |           |          | 
 inserted_datetime | timestamp without time zone |           |          | now()
Indexes:
    "raw_customer_pkey" PRIMARY KEY, btree (id)
    "ix_raw_customer_id" btree (id)
    "raw_customer_email_address_key" UNIQUE CONSTRAINT, btree (email_address)
```

为了撤销迁移，只需运行`alembic downgrade base`，它将执行迁移文件中的所有降级功能。现在该表已不存在:

```
postgres=# \d raw_customer
Did not find any relation named "raw_customer".
```

使用上面的方法，所有的模式都作为代码生成，并且它们成为您的 CI/CD 管道的一部分，受益于代码审查和单元测试。

# 结论

虽然模式可以从数据中导出，但它是一个基础设施组件，需要像这样管理:通过 DDL 脚本、terraform 或代码。通过这样做，您可以从 CI/CD 的积极方面以及底层存储系统提供的功能中获益。

# 附录

1.  [Terraform AWS 胶水](https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/glue_catalog_table)
2.  [Terraform Azure 数据工厂拼花地板](https://registry.terraform.io/providers/hashicorp/azurerm/latest/docs/resources/data_factory_dataset_parquet)
3.  [Terraform Google BigQuery](https://registry.terraform.io/providers/hashicorp/google/latest/docs/resources/bigquery_table)
4.  [SQLAlchemy](https://www.sqlalchemy.org/)
5.  [SQLAlchemy 方言](https://docs.sqlalchemy.org/en/14/dialects/)
6.  [Alembic](https://alembic.sqlalchemy.org/en/latest/)