<html>
<head>
<title>Introduction to prisma</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">prisma 简介</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/introduction-to-prisma-4d05989f8130?source=collection_archive---------2-----------------------#2022-06-07">https://blog.devgenius.io/introduction-to-prisma-4d05989f8130?source=collection_archive---------2-----------------------#2022-06-07</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/77ed2e65fc849ccf2f034caca9289dbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nVgxCx6t1Hl-n2iT6n0jzQ.jpeg"/></div></div></figure><p id="b256" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">编写 SQL 查询是一件麻烦的事情。变得更难维护，也容易搞砸。ORMs 被引入来解决这个问题。</p><h1 id="a7da" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">什么是 ORM？</h1><p id="bfef" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">ORM 代表<em class="lx">对象关系映射器</em>。对象关系映射器是一种技术，允许您使用面向对象的范例查询和操作数据库中的数据。<a class="ae kt" href="https://www.djangoproject.com/" rel="noopener ugc nofollow" target="_blank">姜戈</a>是最受欢迎的 ORM 之一。不管使用什么数据库，操作数据库的代码都是一样的。这使得在需要时切换到不同的数据库变得更加容易。</p><h1 id="aea1" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">Prisma 是什么？</h1><p id="05a6" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">Prisma 是 NodeJS 的 ORM。Prisma 支持 MySQL、SQLite、PostgreSQL、SQL Server 和 MongoDB。但是对 MongoDB 的支持还不稳定。Prisma 有 3 种工具:</p><p id="1d56" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae kt" href="https://github.com/prisma/prisma-client-js" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> Prisma Client JS </strong> </a>是一个数据库客户端，它允许我们通过普通的 JavaScript 方法和对象访问数据库，而不必用数据库语言本身编写查询。</p><p id="abe8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae kt" href="https://github.com/prisma/migrate" rel="noopener ugc nofollow" target="_blank"><strong class="jx io">Prisma Migrate</strong></a>是一款数据库模式迁移工具。它帮助我们跟踪迁移历史，并让我们轻松地恢复和重放迁移。</p><p id="e933" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae kt" href="https://github.com/prisma/studio" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> Prisma Studio </strong> </a>是一个管理界面，允许我们查看、添加和更改数据库中的数据。</p><h2 id="9cb6" class="ly kv in bd kw lz ma dn la mb mc dp le kg md me li kk mf mg lm ko mh mi lq mj bi translated">先决条件</h2><ul class=""><li id="5c14" class="mk ml in jx b jy ls kc lt kg mm kk mn ko mo ks mp mq mr ms bi translated">在本教程中，我们将在 NodeJS 应用程序中使用 Prisma，因此建议您对 NodeJS 和 npm 有一些基本的了解。</li><li id="bbd0" class="mk ml in jx b jy mt kc mu kg mv kk mw ko mx ks mp mq mr ms bi translated">我们将在本教程中使用<a class="ae kt" href="https://www.postgresql.org/" rel="noopener ugc nofollow" target="_blank"> PostgreSQL </a>，所以了解一点 PostgreSQL 知识会有所帮助。</li></ul><h1 id="2b2e" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">设置 Prisma:</h1><p id="b8e7" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">让我们首先设置一个空的 nodejs 应用程序。在项目目录中打开终端并运行以下命令。</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="d6a2" class="ly kv in nd b gy nh ni l nj nk">npm init -y<br/>npm install prisma --save-dev</span></pre><p id="1a7e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">上述命令将创建一个空节点 js 项目，并将 prisma 作为 dev 依赖项添加到项目中。</p><p id="39f1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下一步是通过使用以下命令创建一个<a class="ae kt" href="https://www.prisma.io/docs/concepts/components/prisma-schema" rel="noopener ugc nofollow" target="_blank">模式</a>文件来设置 Prisma</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="0842" class="ly kv in nd b gy nh ni l nj nk">npx prisma init</span></pre><p id="2262" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您应该会看到如下所示的响应</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="2495" class="ly kv in nd b gy nh ni l nj nk">✔ Your Prisma schema was created at prisma/schema.prisma<br/>You can now open it in your favorite editor.<br/><br/>Next steps:<br/>1. Set the DATABASE_URL in the .env file to point to your existing database. If your database has no tables yet, read https://pris.ly/d/getting-started<br/>2. Set the provider of the datasource block in schema.prisma to match your database: postgresql, mysql, sqlite, sqlserver, mongodb or cockroachdb (Preview).<br/>3. Run prisma db pull to turn your database schema into a Prisma schema.<br/>4. Run prisma generate to generate the Prisma Client. You can then start querying your database.<br/><br/>More information in our documentation:<br/>https://pris.ly/d/getting-started</span></pre><p id="36ab" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这会在<strong class="jx io"> prisma </strong>目录下创建一个名为<strong class="jx io"> schema.prisma </strong>的模式文件，并为您的环境变量创建一个. env 文件。</p><h1 id="e760" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">Prisma 架构文件:</h1><p id="3da0" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">让我们检查模式文件中的内容，模式文件应该有如下代码</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="db53" class="ly kv in nd b gy nh ni l nj nk">// This is your Prisma schema file,<br/>// learn more about it in the docs: https://pris.ly/d/prisma-schema<br/><br/>generator client {<br/>  provider = "prisma-client-js"<br/>}<br/><br/>datasource db {<br/>  provider = "postgresql"<br/>  url      = env("DATABASE_URL")<br/>}</span></pre><p id="76ab" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe nl nm nn nd b">generator</code>部分是我们指定想要生成 Prisma 的客户端的地方。客户端通过运行<strong class="jx io"> prisma generate </strong>命令生成。每当对数据库模式进行更改时，我们都需要运行这个命令。</p><p id="802c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe nl nm nn nd b">datasource</code>部分是我们提供将要使用的数据库提供者的地方。默认情况下已经选择了<strong class="jx io"> postgresql </strong>。我们可以使用环境变量<strong class="jx io"> DATABASE_URL </strong>给出数据库连接 URL。现在在<strong class="jx io"> url </strong>下添加一个新行，并添加。</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="5326" class="ly kv in nd b gy nh ni l nj nk">shadowDatabaseUrl = env(“SHADOW_DATABASE_URL”)</span></pre><p id="fecc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">每次运行开发命令时，都会自动创建和删除<a class="ae kt" href="https://www.prisma.io/docs/concepts/components/prisma-migrate/shadow-database" rel="noopener ugc nofollow" target="_blank">影子数据库</a>，主要用于检测模式漂移等问题。如果您提供给 prisma 的数据库用户拥有创建新数据库的权限，则不需要这样做。当设置 prisma 时，您不需要它，但是当您开始对数据库进行更改时，您将需要它</p><p id="6fe9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">打开<code class="fe nl nm nn nd b">.env</code>文件，并更新连接 URL 以指向您自己的数据库。</p><p id="cf61" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">连接 URL 的格式取决于您使用的数据库。的。env 文件应该有 2 个变量，带有更新的连接 URL</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="5968" class="ly kv in nd b gy nh ni l nj nk">DATABASE_URL="postgresql://USER:PASSWORD@HOST:PORT/DATABASE?schema=SCHEMA"<br/>SHADOW_DATABASE_URL="postgresql://USER:PASSWORD@HOST:PORT/DATABASE?schema=SCHEMA"</span></pre><p id="2076" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">接下来打开<strong class="jx io"> schema.prisma </strong>文件，让我们在<strong class="jx io">模型</strong>块中添加<code class="fe nl nm nn nd b">User</code>和<code class="fe nl nm nn nd b">Post</code>模型。在所有的改变之后，schema.prisma 文件应该如下所示。</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="1985" class="ly kv in nd b gy nh ni l nj nk">generator client {<br/>  provider = "prisma-client-js"<br/>}<br/><br/>datasource db {<br/>  provider = "postgresql"<br/>  url      = env("DATABASE_URL")<br/>  shadowDatabaseUrl = env("SHADOW_DATABASE_URL")<br/>}<br/><br/>model Post {<br/>  id        Int      @id @default(autoincrement())<br/>  createdAt DateTime @default(now())<br/>  title     String   @db.VarChar(255)<br/>  content   String?<br/>  published Boolean  @default(false)<br/>  author    User     @relation(fields: [authorId], references: [id])<br/>  authorId  Int<br/>}<br/><br/>model User {<br/>  id      Int      @id @default(autoincrement())<br/>  email   String   @unique<br/>  name    String?<br/>  posts   Post[]<br/>}</span></pre><p id="1aa9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">模态是您在应用程序中使用的实体。<strong class="jx io">用户</strong>模态具有以下属性</p><p id="8ed1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe nl nm nn nd b">id</code>是<strong class="jx io"> Int </strong>数据类型的主键，自动递增。我们可以使用<strong class="jx io"> @id </strong>属性使一个字段成为主键</p><p id="394a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe nl nm nn nd b">email</code>和<code class="fe nl nm nn nd b">name</code>属于<strong class="jx io">型串</strong></p><p id="2620" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe nl nm nn nd b">posts</code>属于类型<strong class="jx io"> Post </strong>，带有类型修饰符<strong class="jx io"> [] </strong>，这意味着我们可以在一个用户下保存一个帖子列表</p><p id="1700" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">类似地，我们的 Post 模式具有以下属性</p><p id="caea" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe nl nm nn nd b">id</code>是<strong class="jx io"> Int </strong>类型的主键。</p><p id="bcba" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe nl nm nn nd b">createdAt</code>的类型为<strong class="jx io">日期时间</strong>。</p><p id="8d70" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe nl nm nn nd b">title</code>和<code class="fe nl nm nn nd b">content</code>属于<strong class="jx io">字符串</strong>类型</p><p id="f6c6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe nl nm nn nd b">published</code>属于类型<strong class="jx io">布尔</strong></p><p id="3ec8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe nl nm nn nd b">author</code>属于类型<strong class="jx io">用户</strong>。这是必需的，因为我们需要告诉 Prisma that 模态与用户模态有一个外键(在这种情况下是多对多关系)。我们可以指定文章模式中的哪个字段可以用来存储文章的用户 id，在本教程中我们已经提到了使用<strong class="jx io">@ relation(fields:[author id]</strong></p><p id="7090" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe nl nm nn nd b">authorId</code>为<strong class="jx io"> Int </strong>类型，用于与用户模型建立多对多关系。</p><h1 id="4fe0" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">使用 Prisma 迁移</h1><p id="8fb4" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">运行以下命令在数据库中生成表。</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="163a" class="ly kv in nd b gy nh ni l nj nk">npx prisma migrate dev — name init</span></pre><p id="2ed0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">该命令还会在<code class="fe nl nm nn nd b">prisma/migrations </code>目录下生成一个迁移文件。这是一个简单的 SQL 文件，让用户可以方便地看到 Prisma 在幕后做了什么。</p><h1 id="6fcd" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">安装 Prisma 客户端</h1><p id="f98f" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">使用以下命令安装 Prisma 数据库客户端</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="6fd8" class="ly kv in nd b gy nh ni l nj nk">npm install @prisma/client</span></pre><p id="8bf9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您可以使用以下命令来生成 Prisma 客户端</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="dbe9" class="ly kv in nd b gy nh ni l nj nk">npx prisma generate</span></pre><p id="d8df" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">将来无论何时对 prisma 模式进行更改，您都需要手动调用<strong class="jx io"> prisma generate </strong>，以适应 Prisma 客户端 API 中的更改。</p><h1 id="8325" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">查询数据库</h1><p id="f6d2" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">创建一个名为<strong class="jx io"> index.js </strong>的新文件，并在其中添加以下代码</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="92f5" class="ly kv in nd b gy nh ni l nj nk">const { PrismaClient } = require('@prisma/client')<br/><br/>const prisma = new PrismaClient()<br/><br/>async function main() {<br/>    <em class="lx">// insert a record into user table and post table</em><br/>    await prisma.user.create({<br/>        data: {<br/>            name: 'John',<br/>            email: 'john@example.com',<br/>            posts: {<br/>                create: { title: 'Hello World' },<br/>            }<br/>        },<br/>    })<br/>    <em class="lx">// fetch all the records</em><br/>    const allUsers = await prisma.user.findMany({<br/>        include: {<br/>            posts: true,<br/>        },<br/>    })<br/>    console.dir(allUsers, { depth: null })<br/>}<br/><br/>main()<br/>    .catch((e) =&gt; {<br/>        throw e<br/>    })<br/>    .finally(async () =&gt; {<br/>        await prisma.$disconnect()<br/>    })</span></pre><p id="a316" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在上面的代码中，我们首先导入了 prisma 客户端，并使用<code class="fe nl nm nn nd b">const prisma = new PrismaClient()</code>创建了一个新实例。</p><p id="3f87" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后，我们声明了<code class="fe nl nm nn nd b"><strong class="jx io">main()</strong></code>函数，并在用户模式中插入了一条新记录，我们还可以在同一个命令中插入与用户相关的帖子。Prisma 将在用户表和 post 表中添加一条记录。</p><p id="563a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后，我们获取了用户表中的所有记录以及与用户相关的帖子</p><p id="9636" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们已经调用了 main 函数来运行查询。现在使用以下命令运行 index.js 文件</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="a0a5" class="ly kv in nd b gy nh ni l nj nk">node ./index.js</span></pre><p id="d7ab" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">用户记录连同帖子将在终端中打印出来</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="6a8d" class="ly kv in nd b gy nh ni l nj nk">[<br/>    {<br/>        id: 1,<br/>        email: 'john@example.com',<br/>        name: 'John',<br/>        posts: [<br/>            {<br/>                id: 1,<br/>                createdAt: 2022-05-26T00:53:45.909Z,<br/>                title: 'Hello World',<br/>                content: null,<br/>                published: false,<br/>                authorId: 1<br/>            }<br/>        ]<br/>    }<br/>]</span></pre><p id="708e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">类似地，如果您想要获取所有的帖子并获取与它们相关联的用户。您可以使用下面的代码</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="6412" class="ly kv in nd b gy nh ni l nj nk">const allPosts = await prisma.post.findMany({<br/>    include: {<br/>        author: true,<br/>    },<br/>})</span></pre><p id="09f5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这将打印以下内容</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="8d1c" class="ly kv in nd b gy nh ni l nj nk">[<br/>    {<br/>        id: 1,<br/>        createdAt: 2022-05-26T00:53:45.909Z,<br/>        title: 'Hello World',<br/>        content: null,<br/>        published: false,<br/>        authorId: 1,<br/>        author: { id: 1, email: 'john@example.com', name: 'John' }<br/>    }<br/>]</span></pre><p id="78d4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">恭喜🎉您已经成功安装了 Prisma。</p><h1 id="a06a" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">探索 Prisma Studio 管理</h1><p id="d349" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">Prisma 附带了一个管理 UI，用于对我们的数据执行 CRUD 操作。运行以下命令打开 Prisma studio。</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="9bb0" class="ly kv in nd b gy nh ni l nj nk">npx prisma studio</span></pre><p id="b9a6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果您在浏览器中打开<a class="ae kt" href="http://localhost:5555/" rel="noopener ugc nofollow" target="_blank"> http://localhost:5555/ </a>，您可以访问管理界面。</p><figure class="my mz na nb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi no"><img src="../Images/7794b27a1b53fe8017429d440afe7802.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q1v07E4Iug4d1wBlFs5A4w.png"/></div></div></figure><p id="54fb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您可以单击并打开表格</p><p id="cc8d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你可以在这个<a class="ae kt" href="https://github.com/dinesh24murali/prisma_example/tree/javascript-setup" rel="noopener ugc nofollow" target="_blank"> github repo </a>中参考上面的全部源代码。</p></div><div class="ab cl np nq hr nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="ig ih ii ij ik"><p id="7d25" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你想了解什么是 Next.js 以及如何使用它，请查看我们的<a class="ae kt" href="https://codeknight.in/react/next_js_crash_course" rel="noopener ugc nofollow" target="_blank">博客</a>。</p></div></div>    
</body>
</html>