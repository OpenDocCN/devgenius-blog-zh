# 测试异步消息驱动架构

> 原文：<https://blog.devgenius.io/testing-asynchronous-message-driven-architecture-1e8a107d7029?source=collection_archive---------3----------------------->

![](img/9cb1f82e79f56bbbd12cf18def2efd12.png)

测试是我们系统的重要组成部分。易于理解和修改的测试将有助于我们长期保持项目的良好状态。
首先，我们可以从同步代码开始，但是迟早我们需要开始异步处理我们的部分流程，这就是消息驱动架构变得方便的时候。

使用`Message Driven Architecture`时，我们的主要目标是组件的松耦合、从问题中快速恢复以及处理高负载的可能性。
然而，由于解耦和异步的处理方式，测试变得更具挑战性。

从这种测试的速度和维护的角度来看，测试这种架构很容易成为噩梦。
在本文中，我们将致力于使用[生态交错带框架](https://blog.ecotone.tech/)中的示例，使这些测试快速、易于理解和编写。

# 异步执行

当我们处理同步代码时，编写测试非常简单。
我们设立`state`，我们称一些`Class`或`API`，我们`assert`我们的期望。

对于异步代码，我们有`publisher of a message`(例如命令/事件)和`message consumer`，它们在不同的进程中运行。如果我们想要测试完整场景，这使得测试变得更加棘手，因为它需要两个进程进行通信。

我们的测试场景是下订单并向客户发送异步确认通知。

> *`*asynchronous*`*属性与通道(队列/传输)相关。
> 可以运行与通道同名的消费者(* `*notifications*` *)来开始消费消息和执行我们的事件处理程序。**

# *在不同的进程中运行发布者和消费者*

*我们可以运行发布给定消息的测试用例(发布者端)，并在后台运行消费者。然后我们会循环等待我们的期望被实现。*

*然而，这种解决方案有一些缺点:*

*   *它增加了测试运行时间，因为现在我们引导新的过程*
*   *调试变得很困难，因为它在后台运行，我们不能完全控制执行*
*   *我们不能使用`in memory` / `dummy`实现，因为一个过程中的变化在第二个过程中是不可见的*

*有很多这样的测试会大大降低测试套件的速度。
当测试套件失败时，可能很难调试原因，因为消费者进程是后台进程。
除了由于缺乏共享内存堆栈，我们还需要构建一些工具来支持这一点(例如，在我们考虑测试失败之前，继续检查数据库中的状态是否已经改变了 X 秒)。*

> *在单独的进程中运行 publisher 和 consumer 的最大优点是，这是最接近产品运行方式的方式。
> 然而，这带来了巨大的成本，因为这些类型的测试很慢，很难调试，并且由于需要支持工具，经常开始偏离生产。*

*当我们将运行消费者进程时，它将阻塞我们的测试套件，因为消费者在处理完给定的消息后将等待下一个消息。
但是`Consumers`可以实现，有可能拦截执行。
拦截主要用于启动事务、记录日志和错误处理，但也可用于测试目的。使用这种技术，我们可以实现`limit of handled messages`和`execution time limit`。
`Handled message limit`将确保我们完成测试的速度与消息处理的速度一样快，`execution time limit`另一方面在失败的情况下保护测试的完成。*

> *在测试中运行消费者时，一定要截取它。
> 这将减少测试套件时间，并确保没有僵尸进程在后台运行。*

# *将异步代码作为同步代码运行*

*在大多数情况下，`consuming process`实际上是同一个应用程序，这意味着我们实际上也可以从`publishing process`运行它。*

*在与我们的测试场景相同的流程中运行 consumer，将减少我们的测试套件时间，并使调试更加容易。
它还将允许我们在内存实现中使用，因为更改将在同一流程中发生。这是一个巨大的优势，因为我们可以轻松地模拟特定场景。*

> **在同一个流程(测试场景)中运行发布者和消费者，仍然很像生产运行，因为执行的代码是相同的。**

# *在内存通道中运行消费者*

*在大多数情况下，当我们在幕后使用 real Message Broker 运行测试时，我们不能并行运行我们的测试。
此外，当我们与 Message Broker 交互时，我们的测试场景比在内存实现中花费的时间要长得多。*

*被消费者消费的`Message Queue`只是一个`Message Channel`。如果我们的消费者实现是从特定的代理实现中抽象出来的，那么我们可以用`In Memory Message Channel`来代替它。
这正是 econtero 的情况，您可以根据自己的情况切换消息通道实现。*

> *使用消息通道的内存实现，可以加速测试并允许并行运行它们。*

# *从轮询切换到事件驱动*

*`Pollable channels (Queues)`创建`[Pollable consumers](https://blog.ecotone.tech/messaging/messaging-concepts/consumer#polling-consumer)`，这意味着代码将被异步执行。
第二个选项被称为`[Event-Driven consumer](https://blog.ecotone.tech/messaging/messaging-concepts/consumer#event-driven-consumer)`，这意味着代码被同步触发(想象同步事件/命令处理程序)。*

*生态区框架支持消息通道和不同的消费者实现，因此我们能够将代码从异步运行切换到同步运行，反之亦然。*

> *有了好的消息传递框架，异步性就被抽象掉了，我们可以编写不知道消费过程的代码。这允许我们编写更简单的测试和切换 Message Broker 实现，而不会影响我们的产品代码。*

# *限制你的测试范围*

*在消息传递体系结构中，给定的消息被多个处理程序使用的情况经常发生。然而，在给定的测试场景中，我们可能只对流程的一小部分感兴趣，我们希望跳过其余部分。*

*在生态交错带测试支持下，我们提供了给定测试场景下应解决的类别列表。这样，我们可以在给定的测试场景中轻松地测试我们代码库的一小部分。*

```
*$ecotoneTestSupport = EcotoneLite::bootstrapForTesting(
	// pass list of classes that should be included in this test
    [OrderService::class, OrderNotifier::class,
    $dependencyContainer
);*
```

# *摘要*

*由于解耦的本质和异步性，测试消息驱动架构可能具有挑战性。然而，它有很多优点，尤其是当系统增长时，这在某个时候成为一种需要。*

*我们可以用消息框架提供的良好支持工具来降低门槛。
所以最终我们可以获得所有消息传递的好处，并且仍然能够编写简单而有效的测试。*