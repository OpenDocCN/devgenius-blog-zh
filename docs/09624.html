<html>
<head>
<title>Kustomize Introduction</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">草泽游戏攻略</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/kustomize-introduction-a52ea3eff66d?source=collection_archive---------12-----------------------#2022-09-01">https://blog.devgenius.io/kustomize-introduction-a52ea3eff66d?source=collection_archive---------12-----------------------#2022-09-01</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div class="gh gi jk"><img src="../Images/5dacbdc9dafc6fec43585a29ead0ba81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*scm-2pvsRe5S2t9pVWtz1g.png"/></div></figure><h1 id="8176" class="jr js in bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">Kubernetes 和 Kustomize 简介:如何使用 Kustomize 轻松定制任何资源配置？</h1><p id="6675" class="pw-post-body-paragraph kp kq in kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">在 Kubernetes 中，就像在计算机科学的任何其他生态系统中一样，我们需要使用配置的概念来引导我们不同的过程。</p><p id="9dd4" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated">通过 Kubernetes，我们驱动不同的资源(工作负载、部署、pod、配置图、机密、服务等)。</p><blockquote class="ls lt lu"><p id="cbc3" class="kp kq lv kr b ks ln ku kv kw lo ky kz lw lp lc ld lx lq lg lh ly lr lk ll lm ig bi translated">资源是 Kubernetes API 中的一个端点，它存储某种 API 对象的集合；例如，内置的 Pod 资源包含一组 Pod 对象。</p></blockquote><p id="56c4" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated">像任何生态系统一样，我们可以有几种不同的环境。因此，在 Kubernetes <strong class="kr io"> K8s </strong>中，我们可能会遇到以下常见情况:</p><ul class=""><li id="addf" class="lz ma in kr b ks ln kw lo la mb le mc li md lm me mf mg mh bi translated">发展环境</li><li id="a141" class="lz ma in kr b ks mi kw mj la mk le ml li mm lm me mf mg mh bi translated">质量保证环境</li><li id="d842" class="lz ma in kr b ks mi kw mj la mk le ml li mm lm me mf mg mh bi translated">生产环境</li></ul><p id="c412" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated">在关于 kustomize 的第一部分中，我们将在教程中重点关注一种类型的资源:<strong class="kr io">工作负载</strong>，我们将了解如何 Kustomize 每个环境的副本数量:-)</p><p id="4670" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated">换句话说，我们将研究如何为每个环境定制部署。今天，我们将使用一个常见的设置:豆荚的数量。</p><p id="29d4" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated">因为很明显，它在产量上要高于其他环境。</p><p id="a094" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated">因此，我们将看到 Kustomize 如何帮助我们覆盖一个工作负载的配置。</p><p id="fa32" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated">在下一节中，我们来看看什么是 Kustomize。</p><h1 id="53f6" class="jr js in bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">草泽</h1><p id="56a8" class="pw-post-body-paragraph kp kq in kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">首先:为什么使用 Kustomize 是最好的选择，即使我们有像 Helm 这样的工具。</p><h1 id="6c63" class="jr js in bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">利弊</h1><p id="c8e2" class="pw-post-body-paragraph kp kq in kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">Kustomize 比 Helm 简单多了。它不需要复杂的模板，甚至不需要安装，如果你最近使用 kubectl 的话。事实上，1.14 及以上版本的 kubectl 都可以使用 Kustomize。</p><p id="118e" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated">从 1.14 开始与 kubectl 集成，它允许您在不接触模板的情况下对配置进行声明性更改。</p><p id="49b8" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated">所以基本上我们什么都不需要做，只需要将 Kustomize 和 kubectl 一起使用，并带有一些选项！</p><p id="5a90" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated">此外，我们不需要使用模板，用于配置 k8s 资源的 yaml 文件将不会受到不同环境之间 Kustomize 的影响！</p><p id="dd4f" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated">现在为了我们的需要，我们将使用<strong class="kr io">补丁</strong>的概念，有一个基础和覆盖。我们稍后会解释这三个词的意思。</p><p id="f672" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated">我们将会看到即使在更复杂的情况下使用 Kustomize 也是多么容易。事实上，我们还可以在整个代码中使用 Kustomize 来处理集群状态。</p><p id="63df" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated">现在让我们看看缺点</p><p id="d161" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated">使用 Kustomize，我们需要添加更多的文件，这样我们就可以告诉 Kustomize 工具要做什么。但在其他方面，这是一种非常好且灵活的方法。</p><h1 id="b422" class="jr js in bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">Kustomize 怎么用</h1><p id="f0f0" class="pw-post-body-paragraph kp kq in kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">Kustomize 有三种不同的主要用途:</p><ul class=""><li id="eabc" class="lz ma in kr b ks ln kw lo la mb le mc li md lm me mf mg mh bi translated">我们的 kubernetes 资源的设置字段(设置名称空间、设置或添加名称、公共标签或注释)</li><li id="4266" class="lz ma in kr b ks mi kw mj la mk le ml li mm lm me mf mg mh bi translated">定制我们的 kubernetes 资源(通过应用带有<strong class="kr io"> patchesStrategicMerge </strong>或<strong class="kr io"> patchesJson6902 </strong>的补丁)</li><li id="5350" class="lz ma in kr b ks mi kw mj la mk le ml li mm lm me mf mg mh bi translated">从其他来源获取资源</li></ul><p id="e58b" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated">在本教程中，我们将重点关注第二个选项:定制我们的 Kubernetes 资源，并了解何时使用一种修补策略。</p><p id="d019" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated">现在我们看到了如何使用 Kustomize，我们需要学习最后一个概念:基础和覆盖</p><h1 id="194b" class="jr js in bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">重叠的概念</h1><p id="ac65" class="pw-post-body-paragraph kp kq in kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">使用 Kustomize，我们总是从一个原始的资源配置文件开始。在我们的用例中，我们将从一个部署 yaml 文件开始，该文件将配置如何在 kubernetes 集群中部署工作负载。</p><p id="af0e" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated">一旦我们有了这个原始文件，我们将看到 kustomize 如何在不接触原始文件的情况下，通过原始文件的转换来应用覆盖更改。</p><p id="8c21" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated">我们将在这里应用一个特殊的覆盖转换:通过在这里修补可以在不同环境(开发、QA、生产)之间改变的工作负载数量来进行修补。</p><p id="d9cf" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated">例如，在开发中，我们将需要一个实例，对于 QA，我们可以通过多达 3 个实例来测试工作负载如何处理扩展。最后，我们将在 PROD 上应用 6 个实例。</p><p id="d9b6" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated">我们将首先创建原始的部署 YAML 文件，正如我们在使用 kubernetes 时所做的那样。</p><p id="07e6" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated"><strong class="kr io">该文件无需修改即可在不同的环境中使用。</strong></p><p id="30a9" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated">现在我们有了原始的资源清单，我们将需要 Kustomize 将使用的另一个文件，以便能够应用覆盖转换:</p><figure class="mo mp mq mr gt jo gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/417aed79b4923aef30f44a593c31fc31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1278/0*HJj6XzbAjPcYS9AM"/></div></figure><p id="60f9" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated">基本上，Kustomize 使用补丁在现有的标准配置文件上引入特定于环境的变化，而不会干扰它。</p><p id="a652" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated">所以我们的部署 yaml 文件将保持不变。</p><p id="6298" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated">让我们首先组织我们的演示。我们将有一个基本目录和三个不同的“覆盖”目录(每个环境一个:dev qa 和 prod)</p><figure class="mo mp mq mr gt jo gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/d4d97ca9843277a0d5116ff544f6bef4.png" data-original-src="https://miro.medium.com/v2/resize:fit:452/0*F2iZ5kLQWkLDou6V"/></div></figure><p id="f19f" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated">首先创建一个名为“Kustomize”的目录</p><p id="0265" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated">然后创建一个名为<strong class="kr io">【基地】</strong>的目录。</p><p id="7088" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated">“base”目录将包含描述我们的部署资源的原始 yaml 文件。Kustomize 不会碰它。按照惯例，我们可以将它存储在一个名为<strong class="kr io">“base”</strong>的目录中。我们在基本目录中只需要一个特殊的文件:</p><p id="9edd" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated">“基本”目录将与我们将创建的<strong class="kr io">“覆盖”</strong>目录形成对比，后者仅包含通过转换应用于原始目录的变化。</p><p id="6b37" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated">然后，我们为环境创建 3 个“覆盖”目录:dev、qa、prod。</p><p id="9266" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated">最后我们得到:</p><figure class="mo mp mq mr gt jo gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/8c35745b4c2a363cc6553c1b169c3a98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/0*CAWEwhyRfbl9mv0r"/></div></figure><p id="7fc1" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated">因此，让我们进入“基本”目录</p><pre class="mo mp mq mr gt mu mv mw mx aw my bi"><span id="1faa" class="mz js in mv b gy na nb l nc nd">C:\Tutorial\Kustomize <br/>λ cd base\</span></pre><p id="0bff" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated">我们将从使用模拟运行从 kubectl 生成 YAML 部署文件开始，这将从一个基本的 kubettl 命令创建 YAML 部署配置文件。</p><p id="26ba" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated">我们将使用 nginx docker 映像来演示 nginx 应用程序。</p><p id="b337" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated">为此，我们可以使用以下命令:</p><p id="48be" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated"><code class="fe ne nf ng mv b"># kubectl create deployment --image=nginx mynginx --dry-run=client -o yaml</code></p><p id="f2ca" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated">该命令做两件事:</p><ul class=""><li id="b47b" class="lz ma in kr b ks ln kw lo la mb le mc li md lm me mf mg mh bi translated">使用命令<strong class="kr io">创建名为 mynginx 的部署</strong>来构建部署(我们可以使用任何名称), mynginx 将是部署名称。部署将使用没有任何标签的 docker 镜像<strong class="kr io"> nginx </strong>(这意味着该命令将采用最新版本)</li><li id="5065" class="lz ma in kr b ks mi kw mj la mk le ml li mm lm me mf mg mh bi translated">在 yaml 中显示 kubectl run 命令在标准输出中的结果。</li></ul><p id="feb0" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated">我们得到以下结果</p><pre class="mo mp mq mr gt mu mv mw mx aw my bi"><span id="d31d" class="mz js in mv b gy na nb l nc nd">λ kubectl create deployment --image=nginx mynginx --dry-run=client -o yaml     <br/>apiVersion: apps/v1                                                            <br/>kind: Deployment                                                               <br/>metadata:                                                                      <br/>  creationTimestamp: null                                                      <br/>  labels:                                                                      <br/>    app: mynginx                                                               <br/>  name: mynginx                                                                <br/>spec:                                                                          <br/>  replicas: 1                                                                  <br/>  selector:                                                                    <br/>    matchLabels:                                                               <br/>      app: mynginx                                                             <br/>  strategy: {}                                                                 <br/>  template:                                                                    <br/>    metadata:                                                                  <br/>      creationTimestamp: null                                                  <br/>      labels:                                                                  <br/>        app: mynginx                                                           <br/>    spec:                                                                      <br/>      containers:                                                              <br/>      - image: nginx                                                           <br/>        name: nginx                                                            <br/>        resources: {}                                                          <br/>status: {}</span></pre><p id="7564" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated">让我们使用命令将它保存到基本目录中的部署 yaml 配置文件中</p><pre class="mo mp mq mr gt mu mv mw mx aw my bi"><span id="e989" class="mz js in mv b gy na nb l nc nd">λ kubectl create deployment --image=nginx mynginx --dry-run=client -o yaml &gt; deployment.yaml</span></pre><figure class="mo mp mq mr gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi nh"><img src="../Images/80c22f5d99b2982b087a41f340a37a62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*L0Yv8D_XxdL9QklA"/></div></div></figure><p id="5f5d" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated">让我们看看文件的内容:</p><pre class="mo mp mq mr gt mu mv mw mx aw my bi"><span id="4663" class="mz js in mv b gy na nb l nc nd">C:\Tutorial\Kustomize\base<br/>λ cat deployment.yaml<br/>apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  creationTimestamp: null<br/>  labels:<br/>    app: mynginx<br/>  name: mynginx<br/>spec:<br/>  replicas: 1<br/>  selector:<br/>    matchLabels:<br/>      app: mynginx<br/>  strategy: {}<br/>  template:<br/>    metadata:<br/>      creationTimestamp: null<br/>      labels:<br/>        app: mynginx<br/>    spec:<br/>      containers:<br/>      - image: nginx<br/>        name: nginx<br/>        resources: {}<br/>status: {}</span></pre><p id="a8a1" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated">让我们删除空值和空值:</p><pre class="mo mp mq mr gt mu mv mw mx aw my bi"><span id="02f8" class="mz js in mv b gy na nb l nc nd">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  labels:<br/>    app: mynginx<br/>  name: mynginx<br/>spec:<br/>  replicas: 1<br/>  selector:<br/>    matchLabels:<br/>      app: mynginx<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: mynginx<br/>    spec:<br/>      containers:<br/>      - image: nginx<br/>        name: nginx</span></pre><p id="f375" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated">我们有文件:</p><pre class="mo mp mq mr gt mu mv mw mx aw my bi"><span id="14df" class="mz js in mv b gy na nb l nc nd">λ ls -last<br/>total 1<br/>1 -rw-r--r-- 1 xxx 1049089 392 Aug 29 17:45 deployment.yaml<br/>0 drwxr-xr-x 1 xxx 1049089   0 Aug 29 10:06 ./<br/>0 drwxr-xr-x 1 xxx 1049089   0 Aug 29 10:03 ../</span></pre><p id="4e89" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated">让我们应用它，看看它是否有效:</p><pre class="mo mp mq mr gt mu mv mw mx aw my bi"><span id="be64" class="mz js in mv b gy na nb l nc nd">C:\Tutorial\Kustomize\base<br/>λ kubectl apply -f deployment.yaml<br/>deployment.apps/mynginx created</span><span id="fb64" class="mz js in mv b gy nm nb l nc nd">λ kubectl get deploy<br/>NAME      READY   UP-TO-DATE   AVAILABLE   AGE<br/>mynginx   1/1     1            1           56s</span></pre><p id="1465" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated">好了，现在我们确定这个部署配置 yaml 文件是有效的，我们可以开始研究如何在“base”目录中告诉 Kustomize 它了！</p><p id="14f1" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated">但是首先我们需要检查 Kustomize 是否在我们的 Kubectl 内:)</p><pre class="mo mp mq mr gt mu mv mw mx aw my bi"><span id="8f7c" class="mz js in mv b gy na nb l nc nd">C:\Tutorial\Kustomize\base<br/>λ kubectl kustomize --help<br/>Build a set of KRM resources using a 'kustomization.yaml' file. The DIR argument must be a path to a<br/>directory containing 'kustomization.yaml', or a git repository URL with a path suffix specifying<br/>same with respect to the repository root. If DIR is omitted, '.' is assumed.</span><span id="eb9d" class="mz js in mv b gy nm nb l nc nd">Examples:<br/>  # Build the current working directory<br/>  kubectl kustomize</span><span id="5c8e" class="mz js in mv b gy nm nb l nc nd"># Build some shared configuration directory<br/>  kubectl kustomize /home/config/production</span><span id="d83d" class="mz js in mv b gy nm nb l nc nd"># Build from github<br/>  kubectl kustomize <a class="ae nn" href="https://github.com/kubernetes-sigs/kustomize.git/examples/helloWorld?ref=v1.0.6" rel="noopener ugc nofollow" target="_blank">https://github.com/kubernetes-sigs/kustomize.git/examples/helloWorld?ref=v1.0.6</a></span><span id="c0fa" class="mz js in mv b gy nm nb l nc nd">Options:<br/>      --enable-alpha-plugins=false: enable kustomize plugins<br/>      --enable-helm=false: Enable use of the Helm chart inflator generator.<br/>      --enable-managedby-label=false: enable adding app.kubernetes.io/managed-by<br/>  -e, --env=[]: a list of environment variables to be used by functions<br/>      --helm-command='helm': helm command (path to executable)<br/>      --load-restrictor='LoadRestrictionsRootOnly': if set to 'LoadRestrictionsNone', local<br/>kustomizations may load files from outside their root. This does, however, break the relocatability<br/>of the kustomization.<br/>      --mount=[]: a list of storage options read from the filesystem<br/>      --network=false: enable network access for functions that declare it<br/>      --network-name='bridge': the docker network to run the container in<br/>  -o, --output='': If specified, write output to this path.<br/>      --reorder='legacy': Reorder the resources just before output. Use 'legacy' to apply a legacy<br/>reordering (Namespaces first, Webhooks last, etc). Use 'none' to suppress a final reordering.</span><span id="976e" class="mz js in mv b gy nm nb l nc nd">Usage:<br/>  kubectl kustomize DIR [flags] [options]</span><span id="e32a" class="mz js in mv b gy nm nb l nc nd">Use "kubectl options" for a list of global command-line options (applies to all commands).</span></pre><p id="4f94" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated">让我们试试第一个例子:</p><pre class="mo mp mq mr gt mu mv mw mx aw my bi"><span id="d957" class="mz js in mv b gy na nb l nc nd"># Build the current working directory<br/>  kubectl kustomize</span></pre><p id="832d" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated">我们得到的结果是:</p><pre class="mo mp mq mr gt mu mv mw mx aw my bi"><span id="b3bb" class="mz js in mv b gy na nb l nc nd">C:\Tutorial\Kustomize\base<br/>λ kubectl kustomize<br/>Error: unable to find one of 'kustomization.yaml', 'kustomization.yml' or 'Kustomization' in directory 'C:\Tutorial\Kustomize\base'</span></pre><p id="1e44" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated">好了，现在我们知道我们可以选择:</p><ul class=""><li id="d89f" class="lz ma in kr b ks ln kw lo la mb le mc li md lm me mf mg mh bi translated">kustomization.yaml 或 kustomization.yml</li><li id="5c38" class="lz ma in kr b ks mi kw mj la mk le ml li mm lm me mf mg mh bi translated">甚至目录库定制化</li></ul><p id="de58" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated">让我们创建以下文件:kustomization.yaml，其中仅包含以下内容:</p><pre class="mo mp mq mr gt mu mv mw mx aw my bi"><span id="adfd" class="mz js in mv b gy na nb l nc nd">resources:<br/>  - deployment.yaml</span></pre><p id="59ca" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated">没别的了。</p><p id="bc0f" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated">最后，我们有:</p><pre class="mo mp mq mr gt mu mv mw mx aw my bi"><span id="0930" class="mz js in mv b gy na nb l nc nd">C:\Tutorial\Kustomize\base<br/>λ ls -last<br/>total 6<br/>4 drwxr-xr-x 1 nbarlatier 1049089   0 Aug 30 22:16 ./<br/>1 -rw-r--r-- 1 nbarlatier 1049089  31 Aug 30 22:14 kustomization.yaml<br/>1 -rw-r--r-- 1 nbarlatier 1049089 392 Aug 29 17:45 deployment.yaml<br/>0 drwxr-xr-x 1 nbarlatier 1049089   0 Aug 29 10:03 ../</span></pre><p id="cf53" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated">让我们看看 Kustomize 在与 kubectl 一起使用时会做什么:</p><pre class="mo mp mq mr gt mu mv mw mx aw my bi"><span id="633a" class="mz js in mv b gy na nb l nc nd">C:\Tutorial\Kustomize\base<br/>λ kubectl kustomize<br/>apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  creationTimestamp: null<br/>  labels:<br/>    app: mynginx<br/>  name: mynginx<br/>spec:<br/>  replicas: 1<br/>  selector:<br/>    matchLabels:<br/>      app: mynginx<br/>  strategy: {}<br/>  template:<br/>    metadata:<br/>      creationTimestamp: null<br/>      labels:<br/>        app: mynginx<br/>    spec:<br/>      containers:<br/>      - image: nginx<br/>        name: nginx<br/>        resources: {}<br/>status: {}</span></pre><p id="6410" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated">它只是重新显示部署内容，这与使用-dry-run=client -o yaml 创建部署非常相似！Kustomize 必须在幕后使用它。:-)</p><p id="65dd" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated">现在我们有了“基础”，现在让我们通过进入 dev 文件夹来查看“叠加”:</p><pre class="mo mp mq mr gt mu mv mw mx aw my bi"><span id="9faa" class="mz js in mv b gy na nb l nc nd">C:\Tutorial\Kustomize\base <br/>λ cd ..\dev <br/>C:\Tutorial\Kustomize\dev</span></pre><p id="54b6" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated">让我们创建以下 Dev 覆盖文件:kustomization.yaml，内容如下:</p><pre class="mo mp mq mr gt mu mv mw mx aw my bi"><span id="74f2" class="mz js in mv b gy na nb l nc nd">λ cat kustomization.yaml<br/>apiVersion: kustomize.config.k8s.io/v1beta1<br/>kind: Kustomization<br/>bases:<br/>  - ../base<br/>patchesStrategicMerge:<br/>  - numberReplica.yaml</span></pre><p id="7b1f" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated">覆盖文件总是引用基础，所以 Kustomize 知道什么资源是目标。我们使用 patchesStrategicMerge 策略来改变副本的数量。最后，我们给出 yaml 文件名，它将包含开发环境的副本数量:numberReplica.yaml，内容如下:</p><pre class="mo mp mq mr gt mu mv mw mx aw my bi"><span id="6f83" class="mz js in mv b gy na nb l nc nd">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>    name: mynginx<br/>spec:<br/>    replicas: 2</span></pre><p id="555f" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated">在这个覆盖文件中，我们只是告诉它将部署 mynginx 作为目标，并将副本的数量设置为 2！</p><p id="3625" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated">因此，现在我们准备测试如何覆盖开发的基础，并显示这个转换的结果，而不接触基础和覆盖文件。</p><p id="49c0" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated">让我们记住我们的文件和目录结构:</p><pre class="mo mp mq mr gt mu mv mw mx aw my bi"><span id="01f0" class="mz js in mv b gy na nb l nc nd">C:\Tutorial  (Tutorial@1.0.0)<br/>λ tree Kustomize\ /f<br/>Folder PATH listing for volume OS<br/>Volume serial number is C0000100 8021:2C9C<br/>C:\TUTORIAL\KUSTOMIZE<br/>├───base<br/>│       deployment.yaml<br/>│       kustomization.yaml<br/>│<br/>├───dev<br/>│       kustomization.yaml<br/>│       numberReplica.yaml<br/>│<br/>├───prod<br/>└───qa</span></pre><p id="9c3a" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated">让我们在 dev 环境中应用 kustomize，在 kubectl 和命令 kustomize 的帮助下非常简单，我们只需传递 dev 目录:</p><pre class="mo mp mq mr gt mu mv mw mx aw my bi"><span id="bcf1" class="mz js in mv b gy na nb l nc nd">λ kubectl kustomize Kustomize\dev\</span></pre><p id="00dd" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated">我们得到如下显示</p><pre class="mo mp mq mr gt mu mv mw mx aw my bi"><span id="633b" class="mz js in mv b gy na nb l nc nd">C:\Tutorial  (Tutorial@1.0.0)<br/>λ kubectl kustomize Kustomize\dev\<br/>apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  labels:<br/>    app: mynginx<br/>  name: mynginx<br/>spec:<br/>  replicas: 2<br/>  selector:<br/>    matchLabels:<br/>      app: mynginx<br/>  strategy: {}<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: mynginx<br/>    spec:<br/>      containers:<br/>      - image: nginx<br/>        name: nginx<br/>        resources: {}<br/>status: {}</span></pre><p id="cbc8" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated">我们可以看到副本的数量现在是 2！当我们创建覆盖 yaml 文件时，我们必须小心考虑正确的 yaml 缩进，以便补丁合并在 yaml 中选择正确的键值元组。</p><p id="7a37" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated">让我们对 QA 和 PROD 做同样的事情:</p><p id="5f77" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated">kustomization.yaml 文件不会改变:</p><p id="9345" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated">kustomization.yaml:</p><pre class="mo mp mq mr gt mu mv mw mx aw my bi"><span id="fa01" class="mz js in mv b gy na nb l nc nd">apiVersion: kustomize.config.k8s.io/v1beta1<br/>kind: Kustomization<br/>bases:<br/>  - ../base<br/>patchesStrategicMerge:<br/>  - numberReplica.yaml</span></pre><p id="0a0c" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated">对于 QA 和 PROD，只有 numberReplica.yaml 文件随着复制副本的数量而变化:</p><p id="0f09" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated">对于质量保证:</p><pre class="mo mp mq mr gt mu mv mw mx aw my bi"><span id="46a3" class="mz js in mv b gy na nb l nc nd">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: mynginx<br/>spec:<br/>  replicas: 4</span></pre><p id="0adb" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated">对于产品:</p><pre class="mo mp mq mr gt mu mv mw mx aw my bi"><span id="66b7" class="mz js in mv b gy na nb l nc nd">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: mynginx<br/>spec:<br/>  replicas: 8</span></pre><p id="2b86" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated">让我们看看最后一棵树:</p><pre class="mo mp mq mr gt mu mv mw mx aw my bi"><span id="b4eb" class="mz js in mv b gy na nb l nc nd">C:\Tutorial  (Tutorial@1.0.0)<br/>λ tree Kustomize\ /f<br/>Folder PATH listing for volume OS<br/>Volume serial number is C0000100 8021:2C9C<br/>C:\TUTORIAL\KUSTOMIZE<br/>├───base<br/>│       deployment.yaml<br/>│       kustomization.yaml<br/>│<br/>├───dev<br/>│       kustomization.yaml<br/>│       numberReplica.yaml<br/>│<br/>├───prod<br/>│       kustomization.yaml<br/>│       numberReplica.yaml<br/>│<br/>└───qa<br/>        kustomization.yaml<br/>        numberReplica.yaml</span></pre><p id="21a6" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated">让我们测试 Kustomize 如何帮助我们在不改变原始部署的情况下为每个环境拥有 3 个不同的 yaml 部署配置</p><pre class="mo mp mq mr gt mu mv mw mx aw my bi"><span id="1395" class="mz js in mv b gy na nb l nc nd">C:\Tutorial\Kustomize<br/>λ kubectl kustomize dev<br/>apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  labels:<br/>    app: mynginx<br/>  name: mynginx<br/>spec:<br/>  replicas: 2<br/>  selector:<br/>    matchLabels:<br/>      app: mynginx<br/>  strategy: {}<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: mynginx<br/>    spec:<br/>      containers:<br/>      - image: nginx<br/>        name: nginx<br/>        resources: {}<br/>status: {}</span><span id="1457" class="mz js in mv b gy nm nb l nc nd">C:\Tutorial\Kustomize<br/>λ kubectl kustomize qa<br/>apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  labels:<br/>    app: mynginx<br/>  name: mynginx<br/>spec:<br/>  replicas: 4<br/>  selector:<br/>    matchLabels:<br/>      app: mynginx<br/>  strategy: {}<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: mynginx<br/>    spec:<br/>      containers:<br/>      - image: nginx<br/>        name: nginx<br/>        resources: {}<br/>status: {}</span><span id="f3f0" class="mz js in mv b gy nm nb l nc nd">C:\Tutorial\Kustomize<br/>λ kubectl kustomize prod<br/>apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  labels:<br/>    app: mynginx<br/>  name: mynginx<br/>spec:<br/>  replicas: 8<br/>  selector:<br/>    matchLabels:<br/>      app: mynginx<br/>  strategy: {}<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: mynginx<br/>    spec:<br/>      containers:<br/>      - image: nginx<br/>        name: nginx<br/>        resources: {}<br/>status: {}</span></pre><p id="a1ee" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated">我们可以看到每个环境中副本数量的变化:</p><ul class=""><li id="07b4" class="lz ma in kr b ks ln kw lo la mb le mc li md lm me mf mg mh bi translated">戴夫:2</li><li id="2ec9" class="lz ma in kr b ks mi kw mj la mk le ml li mm lm me mf mg mh bi translated">问答:4</li><li id="1e92" class="lz ma in kr b ks mi kw mj la mk le ml li mm lm me mf mg mh bi translated">产品:8</li></ul><p id="be3f" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated">到目前为止，我们只使用 Kustomize 来显示转换的结果。它不适用于 kubernetes 集群。</p><p id="faf1" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated">现在，让我们看看如何将 kustomization 应用于我们的集群:</p><p id="846b" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated">我们使用它非常简单</p><pre class="mo mp mq mr gt mu mv mw mx aw my bi"><span id="e795" class="mz js in mv b gy na nb l nc nd">kubectl apply -k EnvDirectory</span></pre><p id="d394" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated">对于 Dev，我们得到:</p><pre class="mo mp mq mr gt mu mv mw mx aw my bi"><span id="e681" class="mz js in mv b gy na nb l nc nd">C:\Tutorial\Kustomize<br/>λ kubectl apply -k dev<br/>deployment.apps/mynginx created</span></pre><p id="86b2" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated">让我们检查部署:</p><pre class="mo mp mq mr gt mu mv mw mx aw my bi"><span id="cc47" class="mz js in mv b gy na nb l nc nd">C:\Tutorial\Kustomize<br/>λ kubectl get deployment<br/>NAME      READY   UP-TO-DATE   AVAILABLE   AGE<br/>mynginx   2/2     2            2           57s</span></pre><p id="8b69" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated">我们果然有两个复制品！</p><p id="38cd" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated">让我们将 kustomization 应用于 QA:</p><pre class="mo mp mq mr gt mu mv mw mx aw my bi"><span id="6221" class="mz js in mv b gy na nb l nc nd">C:\Tutorial\Kustomize<br/>λ kubectl apply -k qa<br/>deployment.apps/mynginx configured</span></pre><p id="15d9" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated">我们注意到部署是配置的，而不是创建的，因为我只更改了副本的数量，但在现实世界中，我们应该更改 kubectl 的名称空间甚至集群配置。</p><p id="5c91" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated">但是我想在这里只关注最简单形式的 Kustomize。</p><p id="f8a8" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated">让我们再次检查部署:</p><pre class="mo mp mq mr gt mu mv mw mx aw my bi"><span id="6729" class="mz js in mv b gy na nb l nc nd">C:\Tutorial\Kustomize<br/>λ kubectl get deployment<br/>NAME      READY   UP-TO-DATE   AVAILABLE   AGE<br/>mynginx   4/4     4            4           3m59s</span></pre><p id="acfa" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated">最后，让我们检查一下产品</p><pre class="mo mp mq mr gt mu mv mw mx aw my bi"><span id="3e9f" class="mz js in mv b gy na nb l nc nd">C:\Tutorial\Kustomize<br/>λ kubectl apply -k prod<br/>deployment.apps/mynginx configured</span><span id="96cd" class="mz js in mv b gy nm nb l nc nd">C:\Tutorial\Kustomize<br/>λ kubectl get deployment<br/>NAME      READY   UP-TO-DATE   AVAILABLE   AGE<br/>mynginx   4/8     8            4           4m36s</span><span id="6ea7" class="mz js in mv b gy nm nb l nc nd">C:\Tutorial\Kustomize<br/>λ kubectl get deployment<br/>NAME      READY   UP-TO-DATE   AVAILABLE   AGE<br/>mynginx   8/8     8            8           4m57s</span></pre><p id="c8bb" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated">我们声明性地得到了我们想要的 8 个实例！</p><p id="71d7" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated">所以现在让我们总结一下:</p><ul class=""><li id="fce8" class="lz ma in kr b ks ln kw lo la mb le mc li md lm me mf mg mh bi translated">我们使用了一种类型的覆盖:带有 patchesStrategicMerge 策略的补丁，因此我们可以更改每个环境的副本数量</li></ul><figure class="mo mp mq mr gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="ni nj di nk bf nl"><div class="gh gi no"><img src="../Images/56d2d97935a58dd84c50eda0a6744c86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kLVLqMYwVaVd6UvR"/></div></div></figure><ul class=""><li id="b2f2" class="lz ma in kr b ks ln kw lo la mb le mc li md lm me mf mg mh bi translated">我们看到了如何在不接触我们的集群的情况下查看 kustomization 结果</li><li id="fcad" class="lz ma in kr b ks mi kw mj la mk le ml li mm lm me mf mg mh bi translated">我们看到了如何将 kustomization 应用于我们在每个环境的集群上的部署</li></ul><p id="6a54" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated">那都是乡亲们！下一次，我们将深入探讨如何改变名称空间，并使用 Kustomize 提供的其他类型的策略。</p><p id="eec1" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated">感谢你阅读这篇文章，如果你喜欢它，我将不胜感激，如果你能给一个喜欢或关注我。祝您愉快！</p></div><div class="ab cl np nq hr nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="ig ih ii ij ik"><p id="39ba" class="pw-post-body-paragraph kp kq in kr b ks ln ku kv kw lo ky kz la lp lc ld le lq lg lh li lr lk ll lm ig bi translated"><em class="lv">原载于</em><a class="ae nn" href="https://nicolasbarlatier.hashnode.dev/introduction-kubernetes-and-kustomize-how-to-easily-customize-any-resource-configuration-with-kustomize" rel="noopener ugc nofollow" target="_blank"><em class="lv">https://nicolasbarlatier . hash node . dev</em></a><em class="lv">。</em></p></div></div>    
</body>
</html>