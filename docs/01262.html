<html>
<head>
<title>Our journey to Micro Frontend</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我们的微前端之旅</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/our-journey-to-micro-frontend-5fbe5f9f69a2?source=collection_archive---------24-----------------------#2020-06-28">https://blog.devgenius.io/our-journey-to-micro-frontend-5fbe5f9f69a2?source=collection_archive---------24-----------------------#2020-06-28</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="e665" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">我的团队解释了实施微前端的原因、方式、我们面临的问题和解决方案</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/e7a0000f0b3a87349c761a3f981dc629.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vylU3HC0S7je-O4j1AG1Dw.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated"><a class="ae ks" href="https://www.freepik.com/free-photos-vectors/red" rel="noopener ugc nofollow" target="_blank">jcomp 制作的红色照片</a></figcaption></figure><p id="7c3b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">微前端架构是开发前端的一种方式，大致相当于后端的微服务。<br/>你把你的前端分成可以独立开发、测试和部署的小块。</p><p id="a014" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">微前端有一些好处，如:</p><ul class=""><li id="2386" class="lp lq in kv b kw kx kz la lc lr lg ls lk lt lo lu lv lw lx bi translated">你<strong class="kv io">可以</strong>为应用程序的特定部分使用不同的技术(小心这一点)。</li><li id="9809" class="lp lq in kv b kw ly kz lz lc ma lg mb lk mc lo lu lv lw lx bi translated">微前端通过将一个大的代码库分割成更小的部分来帮助管理它。</li><li id="a5ad" class="lp lq in kv b kw ly kz lz lc ma lg mb lk mc lo lu lv lw lx bi translated">更小的部分导致更可伸缩的开发。更多的人可以在同一个应用上工作。</li></ul><p id="557c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">模块化代码有它自己的好处，当然也有一些缺点。</p><p id="a429" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">不要担心，在这篇博客结束时，你会对什么是微前端有一个很好的理解。</p><blockquote class="md me mf"><p id="2252" class="kt ku mg kv b kw kx jo ky kz la jr lb mh ld le lf mi lh li lj mj ll lm ln lo ig bi translated">现在，让我们谈谈我们的旅程。</p></blockquote><p id="bc22" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="mg">*所有图片仅供理解，并非事实陈述。</em></p><h2 id="3aeb" class="mk ml in bd mm mn mo dn mp mq mr dp ms lc mt mu mv lg mw mx my lk mz na nb nc bi translated">背景</h2><p id="bd3a" class="pw-post-body-paragraph kt ku in kv b kw nd jo ky kz ne jr lb lc nf le lf lg ng li lj lk nh lm ln lo ig bi translated">我们有一个使用 React 和 Spring Boot 构建的应用程序。它在后端遵循微服务架构。然而，frontend 是一个完整的 react 应用程序。它的架构是这样的。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/acff35a683f5d765e93aec471759b8e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:826/format:webp/1*CNTfKkDRF4GA2lwqPQ-iJw.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated"><a class="ae ks" href="https://micro-frontends.org/" rel="noopener ugc nofollow" target="_blank">micro-frontends.org</a></figcaption></figure><p id="54f5" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">有一天</p><blockquote class="md me mf"><p id="2d7e" class="kt ku mg kv b kw kx jo ky kz la jr lb mh ld le lf mi lh li lj mj ll lm ln lo ig bi translated">*产品负责人走进<br/>“我有这些我们必须构建的新功能…，<br/>还有一件事，微前端”——产品负责人<br/>*麦克风掉落</p></blockquote><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="bde4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这是一个笑话，坦率地说，我不记得他说了什么，因为谁会听产品负责人的。<br/>又是一个笑话。…请不要解雇我。</p><p id="73f8" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">他有将分散的项目整合成单一产品的远见。我们的项目被选中转化为这个产品。</p><p id="1880" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这个想法是，其他项目将集成到我们的项目中，原始团队将保持他们的应用程序的一部分。这与我们正在经历的向部落模式的转变是携手并进的。</p><p id="ef0a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这就是我们部落的样子。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nl"><img src="../Images/461a064d8d492d4348995ca40ad89892.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z8a646n7V7naFuEHYrCZ2w.png"/></div></div></figure><p id="5a72" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">所有这些团队，现在称为小队，是部落的一部分，部落有一种产品。产品的每个部分都将由一个小组负责。每个部分必须覆盖该领域的端到端。</p><p id="3a57" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">由于这篇文章是关于微前端的，所以我不会详细介绍部落模型。<br/>需要知道的重要一点是，在部落模型中，一个团队被分成几个小组。每个组都是应用程序的一部分的所有者。<br/>这些团队应该能够独立设计、开发、测试和部署他们的应用程序部分。</p><p id="f00a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">允许团队整合到我们的项目中，同时拥有上述所有的自由，这是我们面临的挑战。</p><p id="2064" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们去绘图板，看看是否和如何能做到这一点。<br/>在后端，我们使用了完美的微服务架构。可以为要集成的项目创建新的服务。</p><p id="6f8c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">问题在前端。一些突出的例子:</p><ul class=""><li id="d5a7" class="lp lq in kv b kw kx kz la lc lr lg ls lk lt lo lu lv lw lx bi translated">我们的应用程序本身就很大，添加更多将由其他团队编写的代码似乎是一场灾难。</li><li id="b1c6" class="lp lq in kv b kw ly kz lz lc ma lg mb lk mc lo lu lv lw lx bi translated">我们希望每个班都能够独立部署。</li><li id="af59" class="lp lq in kv b kw ly kz lz lc ma lg mb lk mc lo lu lv lw lx bi translated">我们希望小队之间的依赖性最小。队伍之间需要的配合越少越好。</li></ul><p id="8277" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们知道我们需要独立的代码库，因为多个团队在一个 git 存储库中处理同一个项目会导致</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nm"><img src="../Images/035e36af94721f1ce2d5397e70ed508b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P58uac6GEkM9RxLaqBdbKQ.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">意大利面条——由弗里皮克设计的<a class="ae ks" href="http://www.freepik.com" rel="noopener ugc nofollow" target="_blank"/></figcaption></figure><p id="5db5" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在这一点上，我们知道我们必须去微前端。我们不确定的是我们想要构建时集成还是运行时集成。</p><p id="8761" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="mg">词汇表:<br/>主机——每个人都融入其中的那个。<br/>微前端——被集成的那个。</em></p><p id="57a6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">本质上，在构建时集成中，您将代码导出为库，宿主应用程序会将其作为依赖项添加并呈现。<br/>在运行时集成中，你直接在 index.html 文件中添加微前端的捆绑 JS 文件，所以主机只在浏览器中获取你的代码，而不是在那之前。</p><p id="9988" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们没有选择构建时集成，因为这会造成团队之间的依赖。每当一个小队想要部署到 prod 时，他们必须在主机中更新他们的版本并运行一些测试。我们希望避免这种依赖。我们希望小队能够独立部署。</p><p id="328c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在来看运行时集成，这也是我们最终要做的。</p><p id="35ff" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">有了运行时集成，我们可以拥有一切。然而，这种设置的成本很高。</p><p id="2209" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们研究了不同的方法，最终决定采用定制的方法，因为我们希望在对主机进行最小改动的情况下集成微前端。<br/>还有，我们挑 react 开发微前端。</p><p id="147b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们的定制方法是将整个微前端作为 react 组件导出，并在主机应用程序中呈现。</p><p id="b0da" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">请注意，导出的微前端将在运行时在浏览器中可用。它不是主机的构建时依赖项。</p><p id="4cce" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在我们的应用就是这样划分的。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nn"><img src="../Images/5e71d374f60224a137fef109c51b24ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XUDnk767rKw6ajxMvn28fw.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated"><a class="ae ks" href="https://micro-frontends.org/" rel="noopener ugc nofollow" target="_blank">micro-frontends.org</a></figcaption></figure><h2 id="72e9" class="mk ml in bd mm mn mo dn mp mq mr dp ms lc mt mu mv lg mw mx my lk mz na nb nc bi translated">我们是怎么做到的？</h2><p id="0f6f" class="pw-post-body-paragraph kt ku in kv b kw nd jo ky kz ne jr lb lc nf le lf lg ng li lj lk nh lm ln lo ig bi translated">我假设你知道 react &amp;如何在正常情况下捆绑一个前端应用程序。<br/>我们正在使用 webpack 捆绑我们的应用。</p><p id="5902" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在一个普通的应用程序中，你可以将入口点设置为<code class="fe no np nq nr b">index.js</code>。此<code class="fe no np nq nr b">index.js</code>有以下代码。</p><pre class="kd ke kf kg gt ns nr nt nu aw nv bi"><span id="7e9d" class="mk ml in nr b gy nw nx l ny nz">ReactDOM.render(<strong class="nr io">&lt;</strong>App<strong class="nr io">/&gt;</strong>, document.getElementById("root"));</span></pre><p id="705d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe no np nq nr b">ReactDOM.render</code>负责在网页上渲染应用程序。</p><p id="f9f8" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们没有导出这个<code class="fe no np nq nr b">index.js</code>，而是通过在 webpack 中将<code class="fe no np nq nr b">App.jsx</code>设置为<code class="fe no np nq nr b">entrypoint</code>来导出<code class="fe no np nq nr b">&lt;App/&gt;</code>组件，并将其捆绑为一个库。</p><p id="3170" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这创建了一个 JS 文件，当添加到一个<code class="fe no np nq nr b">index.html</code>时，在<code class="fe no np nq nr b">window</code>对象中设置<code class="fe no np nq nr b">App</code>组件。</p><p id="82ec" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">下面是 webpack 配置的相关部分，它将微前端捆绑到一个库中。</p><pre class="kd ke kf kg gt ns nr nt nu aw nv bi"><span id="fae6" class="mk ml in nr b gy nw nx l ny nz">webpackConfig <strong class="nr io">=</strong> {<br/>    entry: './src/App.jsx',<br/>    output: {<br/>        library: 'app',<br/>        libraryTarget: 'umd'<br/>    }<br/>}</span></pre><h2 id="9574" class="mk ml in bd mm mn mo dn mp mq mr dp ms lc mt mu mv lg mw mx my lk mz na nb nc bi translated">问题</h2><p id="3bce" class="pw-post-body-paragraph kt ku in kv b kw nd jo ky kz ne jr lb lc nf le lf lg ng li lj lk nh lm ln lo ig bi translated">我们面临的一些突出挑战:</p><ul class=""><li id="ae79" class="lp lq in kv b kw kx kz la lc lr lg ls lk lt lo lu lv lw lx bi translated">本地开发设置</li><li id="b002" class="lp lq in kv b kw ly kz lz lc ma lg mb lk mc lo lu lv lw lx bi translated">功能测试和与主机应用程序的集成测试</li><li id="fc53" class="lp lq in kv b kw ly kz lz lc ma lg mb lk mc lo lu lv lw lx bi translated">CSS 类名冲突</li><li id="4477" class="lp lq in kv b kw ly kz lz lc ma lg mb lk mc lo lu lv lw lx bi translated">主机和微前端之间的通信</li><li id="ecfc" class="lp lq in kv b kw ly kz lz lc ma lg mb lk mc lo lu lv lw lx bi translated">生产部署</li><li id="9fc3" class="lp lq in kv b kw ly kz lz lc ma lg mb lk mc lo lu lv lw lx bi translated">捆绑大小</li></ul><p id="6f28" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这是我们对他们每个人做的。</p><h2 id="48bd" class="mk ml in bd mm mn mo dn mp mq mr dp ms lc mt mu mv lg mw mx my lk mz na nb nc bi translated">本地开发设置</h2><p id="78db" class="pw-post-body-paragraph kt ku in kv b kw nd jo ky kz ne jr lb lc nf le lf lg ng li lj lk nh lm ln lo ig bi translated">我们的自定义方法有一个问题，即没有主机就无法渲染微前端。这是因为我们将代码捆绑成一个库。我们需要一些可以使用这个库并显示在用户界面上的东西。</p><p id="3d19" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这个问题的一个显而易见的解决方案是在本地运行主机，并将微前端连接到它。这将允许我们在主机中查看我们的应用程序。</p><p id="ab3d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这种方法有问题。首先，我们现在依赖于另一个团队(一个维护主机的团队)，其次，运行两个服务器很麻烦，我们也失去了热重装。</p><p id="7d7b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在 react 的本地设置中，每个人都使用热重装。这允许您更改代码并立即看到更改。这看起来微不足道，但是对生产力有着重要的影响。</p><p id="89a4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">为了解决这个问题，我们创建了单独的 webpack 配置。一个用于生产，我们用<code class="fe no np nq nr b">App.jsx</code>作为入口点，另一个用于本地，入口点是<code class="fe no np nq nr b">index.jsx</code>。</p><blockquote class="md me mf"><p id="a213" class="kt ku mg kv b kw kx jo ky kz la jr lb mh ld le lf mi lh li lj mj ll lm ln lo ig bi translated">等等，这是什么<code class="fe no np nq nr b"><em class="in">index.jsx</em></code>？</p></blockquote><p id="f7c2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们的<code class="fe no np nq nr b">index.jsx</code>就像普通 react app 的<code class="fe no np nq nr b">index.jsx</code>。两者都有<code class="fe no np nq nr b">ReactDOM.render</code>来呈现页面上的内容。</p><p id="10eb" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">index.jsx 相关部分:<br/>T13】</p><p id="e7e3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们将这个<code class="fe no np nq nr b">index.jsx</code>保存在一个单独的文件夹中，远离<code class="fe no np nq nr b">src</code>。我们将其命名为<code class="fe no np nq nr b">appShell</code>。这个<code class="fe no np nq nr b">appShell</code>用于本地开发，并作为一个容器来呈现<code class="fe no np nq nr b">&lt;App/&gt;</code>组件。我们不打算在生产捆绑包的<code class="fe no np nq nr b">appShell</code>文件夹中捆绑任何东西。</p><p id="0a83" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这允许我们在没有实际主机的情况下在微前端上工作，并热重装我们的更改。</p><p id="ff59" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们的项目文件结构:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi oa"><img src="../Images/5c91998086145e5faf5752da16a48d85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B-q_hlg4Yf-n4E_5uPR_IA.png"/></div></div></figure><h2 id="ae25" class="mk ml in bd mm mn mo dn mp mq mr dp ms lc mt mu mv lg mw mx my lk mz na nb nc bi translated">功能测试和与主机的集成测试</h2><p id="f805" class="pw-post-body-paragraph kt ku in kv b kw nd jo ky kz ne jr lb lc nf le lf lg ng li lj lk nh lm ln lo ig bi translated">正如本地设置一样，一个显而易见的方法是测试主机内部的微前端。就像本地设置一样，缺点是我们增加了对另一个小队的依赖。如果他们的代码被破解，我们的测试就会失败。</p><p id="d439" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">为了避免依赖性并保持微前端的独立性，我们创建了一个新的用于功能测试的准系统主机，代码足够运行微前端。我们使用这个测试实例编写了所有功能测试。</p><p id="72f8" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们还编写了与真实主机的集成测试。这个集成测试是一个最小的测试，只检查微前端是否加载。</p><p id="1d24" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们在微前端和主机的功能测试套件中添加了这个集成测试。两者现在都在部署前检查集成。这允许我们在微前端和主机的管道之间实现零依赖性。</p><h2 id="0d48" class="mk ml in bd mm mn mo dn mp mq mr dp ms lc mt mu mv lg mw mx my lk mz na nb nc bi translated">CSS 类名冲突</h2><p id="984a" class="pw-post-body-paragraph kt ku in kv b kw nd jo ky kz ne jr lb lc nf le lf lg ng li lj lk nh lm ln lo ig bi translated">微前端的另一个问题是，每个微前端都创建自己的 CSS 类，如果它们有相同的名称，这些类可能会相互冲突。为了避免这个问题，我们给每个 CSS 类名加了前缀。</p><p id="7e53" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">为了自动做到这一点，我们在 webpack 中定制了<code class="fe no np nq nr b">css-loader</code>。</p><pre class="kd ke kf kg gt ns nr nt nu aw nv bi"><span id="7b32" class="mk ml in nr b gy nw nx l ny nz">cssLoader = {<br/>    loader: 'css-loader',<br/>    options: {<br/>        modules: {<br/>            getLocalIdent: (context, localIdentName, localName) =&gt; {<br/>                return `awesome_${localName}`;<br/>            }<br/>        }<br/>    }<br/>}</span></pre><p id="f678" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">将上面的内容添加到 webpack 中会给每个 CSS 类加上前缀<code class="fe no np nq nr b">awesome_</code>。将应用程序名称作为前缀将确保您永远不会有冲突的 CSS 类。</p><p id="1a2c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们通过<code class="fe no np nq nr b">css-loader</code>这样做，因为我们希望这是一个背景，我们甚至可以忘记它的存在。</p><h2 id="701f" class="mk ml in bd mm mn mo dn mp mq mr dp ms lc mt mu mv lg mw mx my lk mz na nb nc bi translated">主机和微前端之间的通信</h2><p id="3791" class="pw-post-body-paragraph kt ku in kv b kw nd jo ky kz ne jr lb lc nf le lf lg ng li lj lk nh lm ln lo ig bi translated">在我们的用例中，主机和微前端之间没有太多的通信。我们现在所做的是，当一些东西需要从主机传到微前端时，我们将其作为<code class="fe no np nq nr b">props</code>传递下去。<br/>对于需要从微前端到主机的事情，我们通过事件来完成。</p><p id="3a4f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们已经创建了一个事件总线，任何微前端都可以在其中发布事件。它作为一个共同的沟通渠道。</p><p id="4348" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">另一个我们正在考虑但没有实施的方法是共享 redux。有了共享的 redux，你可以轻松地进行双向交流。这种方法有一个风险，即任何人都可以修改商店中的任何内容。这就是为什么我们没有采取这种方法。</p><p id="160c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我不会详细讨论事件，因为它本身就是一个博客。</p><h2 id="298b" class="mk ml in bd mm mn mo dn mp mq mr dp ms lc mt mu mv lg mw mx my lk mz na nb nc bi translated">生产部署</h2><p id="8bef" class="pw-post-body-paragraph kt ku in kv b kw nd jo ky kz ne jr lb lc nf le lf lg ng li lj lk nh lm ln lo ig bi translated">这是一个重要的挑战。如何独立部署两个 app？如果小队在部署前必须互相检查，那么这个模型将是不可扩展的。</p><p id="43bd" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">一件重要的事情，我们有集成测试，以确保微前端工作良好，所有的团队运行它们。这些测试是端到端的测试。这些是防止小队破坏别人的 else 代码所必需的。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ob"><img src="../Images/5d8a60e2a01f06d7b5abf1e263af9708.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xe32hEl4dRZTEioykAKErQ.png"/></div></div></figure><p id="ddf7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">上图是我们的架构的样子。<br/>我们在 Nginx 服务器上部署了主机代码，这个 Nginx 是每个请求的入口点。</p><p id="6eff" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">Nginx 是一款可以托管静态文件的软件，比如 HTML、CSS &amp; JS，它还可以路由流量。</p><p id="5c3c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">搜索微前端的代码部署在不同的 Nginx 上。</p><p id="07f3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这些服务器由不同的团队管理。所以他们的部署是独立的。</p><p id="306b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们看看页面加载时会发生什么。</p><p id="7330" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">当你打开我们网站的第一件事就是从主机服务器下载<code class="fe no np nq nr b">index.html</code>。<br/>接下来，这个<code class="fe no np nq nr b">index.html</code>有这几行。</p><pre class="kd ke kf kg gt ns nr nt nu aw nv bi"><span id="c3ef" class="mk ml in nr b gy nw nx l ny nz">&lt;script type="text/javascript" src="app.js"&gt;&lt;/script&gt;<br/>&lt;script type="text/javascript" src="search/bundle.js"&gt;&lt;/script&gt;</span></pre><p id="88af" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">然后浏览器会发送一个下载这些文件的请求。第一个文件<code class="fe no np nq nr b">app.js</code>是直截了当的，它是主机的代码，可以在主机的服务器上获得。</p><p id="7571" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">第二个文件<code class="fe no np nq nr b">search/bundle.js</code>存在于微前端的服务器上，而不在主机上。</p><p id="ca0a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">浏览器只知道主机的服务器，所以它发送这个请求到主机，在那里我们有一个路由规则来转发(传递)所有以<code class="fe no np nq nr b">/search</code>开始的请求来搜索微前端的服务器。而现在这个请求是由微前端的服务器来服务的。</p><p id="d68d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">重要的是，这是一个转发(传递)而不是重定向。</p><p id="175d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在主机上有一个路由规则将<code class="fe no np nq nr b">/search</code>的控制权交给搜索小队，这样每个小队都可以控制自己的部分。</p><h2 id="f5f0" class="mk ml in bd mm mn mo dn mp mq mr dp ms lc mt mu mv lg mw mx my lk mz na nb nc bi translated">捆绑大小</h2><p id="d0b3" class="pw-post-body-paragraph kt ku in kv b kw nd jo ky kz ne jr lb lc nf le lf lg ng li lj lk nh lm ln lo ig bi translated">当采用微前端的方法，应用程序在运行时结合时，这个问题就出现了。</p><p id="ba81" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">每个应用程序都必须捆绑它们所有的依赖项(react 和其他)。<br/>每个微前端都捆绑了它们所有的依赖项，因此存在大量重复的依赖项。</p><p id="5871" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这是一个我们尚未解决的问题。我们在浏览器上缓存我们的 JS 文件，所以这个问题只在用户第一次加载页面时出现，所以我们还没有优先考虑它。</p><h2 id="a440" class="mk ml in bd mm mn mo dn mp mq mr dp ms lc mt mu mv lg mw mx my lk mz na nb nc bi translated">如果你喜欢这篇文章，请点击👏按钮并分享，帮助其他人找到它！欢迎在下方留言评论。</h2><p id="a01e" class="pw-post-body-paragraph kt ku in kv b kw nd jo ky kz ne jr lb lc nf le lf lg ng li lj lk nh lm ln lo ig bi translated">你可以在这里 &amp; <a class="ae ks" href="https://micro-frontends.org/" rel="noopener ugc nofollow" target="_blank">这里</a>阅读更多关于微前端<a class="ae ks" href="https://martinfowler.com/articles/micro-frontends.html" rel="noopener ugc nofollow" target="_blank">的内容。</a></p></div></div>    
</body>
</html>