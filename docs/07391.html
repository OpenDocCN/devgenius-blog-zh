<html>
<head>
<title>Namespace an excuse to talk about global variables</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">名称空间是谈论全局变量的借口</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/namespace-an-excuse-to-talk-about-global-variables-ed35434c1b5c?source=collection_archive---------9-----------------------#2022-03-21">https://blog.devgenius.io/namespace-an-excuse-to-talk-about-global-variables-ed35434c1b5c?source=collection_archive---------9-----------------------#2022-03-21</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="f423" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这篇文章中，我们将了解什么是名称空间，以及我们如何从不必要的变量中清除全局范围。这篇文章是在考虑使用 Swift 语言的情况下写的。</p><h1 id="459c" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">目录</h1><ul class=""><li id="1ab4" class="lg lh in jm b jn li jr lj jv lk jz ll kd lm kh ln lo lp lq bi translated">什么是名称空间？</li><li id="d35a" class="lg lh in jm b jn lr jr ls jv lt jz lu kd lv kh ln lo lp lq bi translated">命名空间提示和技巧</li><li id="8978" class="lg lh in jm b jn lr jr ls jv lt jz lu kd lv kh ln lo lp lq bi translated">SwiftUI 框架中的@命名空间</li><li id="0bbe" class="lg lh in jm b jn lr jr ls jv lt jz lu kd lv kh ln lo lp lq bi translated">关于命名空间的建议</li></ul><h1 id="e486" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">什么是名称空间？</h1><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi lw"><img src="../Images/8e2f46f9ae23c629e978e6398db005a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*62gm0TfYM4LwnpQ214qUUQ.png"/></div></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk translated">它是 python 语言中不同名称空间的饼状图。</figcaption></figure><ul class=""><li id="7222" class="lg lh in jm b jn jo jr js jv mm jz mn kd mo kh ln lo lp lq bi translated">通常</li><li id="85a5" class="lg lh in jm b jn lr jr ls jv lt jz lu kd lv kh ln lo lp lq bi translated">迅速地</li></ul><h2 id="0870" class="mp kj in bd kk mq mr dn ko ms mt dp ks jv mu mv kw jz mw mx la kd my mz le na bi translated">通常</h2><p id="e89c" class="pw-post-body-paragraph jk jl in jm b jn li jp jq jr lj jt ju jv nb jx jy jz nc kb kc kd nd kf kg kh ig bi translated">名称空间是程序的一个区域，它被命名并用于将变量、函数等组合在一起。命名空间为其内部的标识符提供了一个范围。下面列出了命名空间的一些好处:</p><ul class=""><li id="aba7" class="lg lh in jm b jn jo jr js jv mm jz mn kd mo kh ln lo lp lq bi translated">代码组织</li><li id="d40f" class="lg lh in jm b jn lr jr ls jv lt jz lu kd lv kh ln lo lp lq bi translated">防止名称冲突。</li><li id="4fcf" class="lg lh in jm b jn lr jr ls jv lt jz lu kd lv kh ln lo lp lq bi translated">提供封装</li></ul><p id="d7a5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">代码组织<br/> </strong>一般来说，命名空间允许我们将代码分组，并将代码分成不同的区域，每个区域都有自己的变量和函数集。这简化了我们的编程过程，并清除了全局 scobe 中不需要的标识符(类型、函数、变量等的名称)。</p><p id="cf1d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">防止名称冲突<br/> </strong>当我们将所有代码存储在一个名称空间中时，名称冲突的可能性增加了，但是将我们的关注点划分到不同的主名称空间将有助于防止冲突。</p><p id="1f6c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">提供封装<br/> 我们主要担心的一个问题是封装，封装认为一个类、结构等应该只能访问需要它们操作的东西，而不能更多。创建不同代码区域的名称空间为我们封装代码提供了更好的机会。</p><h2 id="06c4" class="mp kj in bd kk mq mr dn ko ms mt dp ks jv mu mv kw jz mw mx la kd my mz le na bi translated">迅速地</h2><ul class=""><li id="9057" class="lg lh in jm b jn li jr lj jv lk jz ll kd lm kh ln lo lp lq bi translated">描述</li><li id="ea2f" class="lg lh in jm b jn lr jr ls jv lt jz lu kd lv kh ln lo lp lq bi translated">导入语句</li></ul><p id="d05f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">描述<br/> </strong>不幸的是，命名空间没有被明确地处理。在 Swift 中，所有类型、变量等都由模块自动确定范围，这对应于 Xcode 目标。</p><p id="376d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">大多数时候，不需要模块前缀就可以访问内置标识符，比如 Int、String 等。</p><pre class="lx ly lz ma gt ne nf ng nh aw ni bi"><span id="07b1" class="mp kj in nf b gy nj nk l nl nm">var randomNmber = Int.random(in: 0...10)<br/>print(randomNumber)<br/>/*<br/>Result-----<br/>A number between 0 and 10<br/>*/</span></pre><p id="0189" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在上面的例子中，虽然 Int 结构是在文件外部声明的，但是它是可访问的并且是自动构造的。</p><p id="8339" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是如果我们想要一个同名的结构会怎么样呢？</p><pre class="lx ly lz ma gt ne nf ng nh aw ni bi"><span id="a0b1" class="mp kj in nf b gy nj nk l nl nm">struct Int{}<br/>var randomNmber = Int.random(in: 0...10)<br/>print(randomNumber)<br/>/*<br/>Result-----<br/>Error: Type 'Int' has no member 'random(in:)'<br/>*/</span></pre><p id="2396" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">发生这种情况是因为在冲突的情况下，局部类型遮蔽了外部类型。为了解决这种模糊性，必须明确提及名称空间(正如在“Swift”是所有预定义和预声明标识符的名称空间之前所提到的)。</p><pre class="lx ly lz ma gt ne nf ng nh aw ni bi"><span id="7039" class="mp kj in nf b gy nj nk l nl nm">var randomNmber = Swift.Int.random(in: 0...10)</span></pre><p id="df4f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这样，我们既可以有一个本地 Int，也可以访问预定义的 Int。</p><p id="b43a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">注意:如果我们有两个不同的框架，它们都实现了两个同名的不同类或结构，我们需要导入它们，因此将它们都导入到一个文件中，我们应该明确指定我们想要使用哪个框架和哪个类。</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi nn"><img src="../Images/f300107b3db85473ec674707e58434c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iC8JkEKVoB_c1mrEpeZw1A.png"/></div></div></figure><p id="5292" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">导入语句<br/> </strong>按子模块导入:你要注意，类和模块是有层次架构的。当我们想要导入一个类或模块时，我们无意中导入了它的所有子模块。</p><pre class="lx ly lz ma gt ne nf ng nh aw ni bi"><span id="567f" class="mp kj in nf b gy nj nk l nl nm"><strong class="nf io">import</strong> UIKit.NSAttributedString</span><span id="8e73" class="mp kj in nf b gy no nk l nl nm"><strong class="nf io">func</strong> foo() -&gt; UIView { </span><span id="b76d" class="mp kj in nf b gy no nk l nl nm"><strong class="nf io">return</strong> UIView()</span><span id="94c1" class="mp kj in nf b gy no nk l nl nm">}</span></pre><p id="5973" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这里，例如，我们只是导入了一个 NSAttributedString，但是 UIView(整个 UIKit 和 Foundation)也是另外导入的。</p><p id="8a56" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">那么我们能做些什么来解决这个问题呢？答案带在下面:</p><p id="3b37" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">按符号导入:<strong class="jm io"> <br/> </strong>只有导入的符号(而不是声明它的模块)在当前作用域中可用:</p><pre class="lx ly lz ma gt ne nf ng nh aw ni bi"><span id="1b6c" class="mp kj in nf b gy nj nk l nl nm">import class UIKit.NSAttributedString  </span><span id="9be5" class="mp kj in nf b gy no nk l nl nm">func foo() -&gt; UIView {  return UIView() }</span><span id="3cb2" class="mp kj in nf b gy no nk l nl nm">/*<br/>Result-----<br/>Error: Use of undeclared type 'UIView'<br/>*/</span></pre><p id="fc06" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">个人观点:<br/>所以我的观点是，我们应该只导入那些我们需要的类和结构，例如，如果我们想在 SwiftUI 中扩展 Color，我们不需要导入整个 SwiftUI，我们应该只导入 Color 结构。</p><h1 id="3c1f" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">SwiftUI 框架中的@命名空间</h1><p id="a2cf" class="pw-post-body-paragraph jk jl in jm b jn li jp jq jr lj jt ju jv nb jx jy jz nc kb kc kd nd kf kg kh ig bi translated">在 SwiftUI 中，苹果开发人员为我们提供了一种可能性，可以将视图从一个动画到另一个，并与它们进行交互，就好像它们是同一个视图一样，我说的是“SwiftUI 匹配几何效果”(更多信息请阅读<a class="ae np" href="https://swiftui-lab.com/matchedgeometryeffect-part1/" rel="noopener ugc nofollow" target="_blank"> this </a>)。</p><p id="a215" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">基本上，它让你能够将两个不同的视图同步为一个视图，并从一个视图到另一个视图制作动画。如果同一视图出现在视图层次结构的两个不同部分，并且想要在它们之间设置动画效果(例如，从列表视图到缩放的详细视图),那么可以使用匹配几何效果。</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/a2b62f2a4d0f9c52b20dd1a3c01743ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1148/1*h9fLfmAp0_2dXDzj7GujQA.gif"/></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk translated"><a class="ae np" href="https://swiftui-lab.com/matchedgeometryeffect-part1/" rel="noopener ugc nofollow" target="_blank">https://swiftui-lab.com/matchedgeometryeffect-part1/</a></figcaption></figure><p id="a958" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用匹配几何效果的一个例子。</p><p id="a61e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，只有当您可以指定哪些视图应被视为一个视图以及从一个视图到另一个视图的步骤时，匹配的几何效果才能正确工作。第二部分(一个视图到达第二个视图必须经历的步骤)不是我们现在关心的主题，而是第一部分(指定哪两个视图应该被认为是一个视图)。</p><p id="112f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们通过给视图一个 ID 和一个名称空间来指定视图。名称空间使得在一个地方不存在两个不同视图的两个相同的 ID 成为可能，并且它通过将视图和 ID 封装在不同的名称空间中来将它们彼此分开。</p><p id="2e1a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下面是相应结果的示例:</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi nr"><img src="../Images/6eb88ae224c29f7832b8ff60be0878b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IeBJL4xjSsmykCuzMReUtQ.png"/></div></div></figure><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/80b0036e16c6196d0c80c469fe9693da.png" data-original-src="https://miro.medium.com/v2/resize:fit:554/1*BWfZ6jUHUXw_sxWuxAxuRA.gif"/></div></figure><h1 id="1d5f" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">关于带有枚举的命名空间的建议</h1><p id="0fe1" class="pw-post-body-paragraph jk jl in jm b jn li jp jq jr lj jt ju jv nb jx jy jz nc kb kc kd nd kf kg kh ig bi translated">不幸的是，在 swift 中没有创建名称空间的直接方法，但是您可以考虑使用数据结构，比如枚举。</p><p id="3ef3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">枚举当然不能用于所有事情，但在某些情况下，如管理应用程序或资产中的颜色，可以使用。请注意下面的例子:</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi nt"><img src="../Images/895effa9a9672c3f16532a20c4f1bb5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MtQ1-m8nWOW6XUYAHAskcg.png"/></div></div></figure><p id="9e17" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，我们可以将颜色字符串和资产字符串封装在各自的颜色和资产枚举中，而不是污染全局名称空间。</p><p id="f9a1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">那么为什么是 enum 呢？与结构不同，枚举没有合成的初始值设定项；与类不同，它们不允许子类化，这使它们成为模拟名称空间的完美候选。</p><p id="67fb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">正如您在上面的代码示例中看到的，您甚至可以将不同的关注点分组到一个大的枚举中，并为该关注点的不同区域创建多个子枚举，例如，您可以拥有一个包含颜色、字体等的 StyleGuide 枚举，或者拥有一个包含您通过应用程序使用的所有图像、图标、插图等的 Asset 枚举。这里我带来了一个 styleGuide enum，用于演示我在一个项目中使用过的内容。</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi nu"><img src="../Images/0767f0fe286d73604d81b07dcc8bac06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t7E0nMRLLZptLOvb-5UpsQ.png"/></div></div></figure><h1 id="b8e9" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">结论</h1><p id="79ae" class="pw-post-body-paragraph jk jl in jm b jn li jp jq jr lj jt ju jv nb jx jy jz nc kb kc kd nd kf kg kh ig bi translated">现在你会想我们在哪里讨论过全局变量？你说得对，我们至少到现在才知道。使用全局变量，让它们到处出现，确实会给我们带来很大的麻烦，原因有几个。简而言之，它们可以通过所有的应用程序环境访问，事实上，我们无法监控可能导致访问它们的过程，这可能会导致我们进行繁琐的调试过程，长话短说，它们令人毛骨悚然，它们使全局名称空间过于拥挤，等等。</p><p id="ac52" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这取决于我们开发人员创造更好的编程和开发应用程序和模块的体验，我认为我们应该考虑和采用每一个和任何一个可以在尊重软件工程概念的同时简化过程和改善开发体验的行动。在这种情况下，我认为使用枚举可以是一个巨大的推动。确保你知道如何以及何时可以使用它们，然后去做，不要问任何人。</p></div></div>    
</body>
</html>