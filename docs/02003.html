<html>
<head>
<title>Node.js Tips — HTTP Proxies, Mongoose Schemas, Read Files, and More</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js技巧——HTTP代理、Mongoose模式、读取文件等等</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/node-js-tips-http-proxies-mongoose-schemas-read-files-and-more-c41aa8b83ddb?source=collection_archive---------14-----------------------#2020-07-16">https://blog.devgenius.io/node-js-tips-http-proxies-mongoose-schemas-read-files-and-more-c41aa8b83ddb?source=collection_archive---------14-----------------------#2020-07-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/18544a9c67e17db1928f9220bee331a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4wbDdYw0U0gwrRz3"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">亨特·汤普森在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="9b23" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像任何类型的应用程序一样，当我们编写节点应用程序时，有一些困难的问题需要解决。</p><p id="96a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究一些编写节点应用程序时常见问题的解决方案。</p><h1 id="1361" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">在Node.js中创建简单的HTTP代理</h1><p id="b178" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">要用Node.js创建一个简单的HTTP代理，我们可以使用<code class="fe me mf mg mh b">node-http-proxy</code>库。</p><p id="1dd9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过运行以下命令来安装它:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="16df" class="mq lc iq mh b gy mr ms l mt mu">npm install http-proxy --save</span></pre><p id="740b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="d899" class="mq lc iq mh b gy mr ms l mt mu">const http = require('http');<br/>const httpProxy = require('http-proxy');<br/>const proxy = httpProxy.createProxyServer({});<br/><br/>http.createServer((req, res) =&gt; {<br/>  proxy.web(req, res, { target: 'http://www.example.com' });<br/>}).listen(3000);</span></pre><p id="cbdc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们调用<code class="fe me mf mg mh b">createProxyServer</code>来创建代理服务器。</p><p id="8386" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们调用<code class="fe me mf mg mh b">proxy.web</code>将我们的请求重定向到<code class="fe me mf mg mh b">http://example.com</code>。</p><h1 id="8f42" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">Node.js中的fs.createReadStream与fs.readFile</h1><p id="0c2a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们应该使用<code class="fe me mf mg mh b">fs.createReadStream</code>一次读取一个文件的一部分。</p><p id="c43b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这意味着我们可以读取大文件，而无需将所有内容加载到内存中。</p><p id="e2e9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">fs.readFile</code>适合读取整个文件。这意味着它适合阅读小文件。</p><p id="64ae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">读流可以接受数据，而不会使主机系统不堪重负。</p><h1 id="f199" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">在Express.js中获取发出请求的域</h1><p id="d661" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用Express获得发起请求的域。</p><p id="8cd7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们所要做的就是使用<code class="fe me mf mg mh b">req.get('host')</code>来获取<code class="fe me mf mg mh b">HOST</code>头。</p><p id="98e9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这适用于非跨来源请求。</p><p id="07ec" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于跨来源请求，我们可以使用<code class="fe me mf mg mh b">req.get('origin')</code>来代替。</p><p id="7768" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，我们可以使用<code class="fe me mf mg mh b">req.headers.host</code>和<code class="fe me mf mg mh b">req.headers.origin</code>来做同样的事情。</p><p id="fd64" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们想获得一个客户端的IP地址，我们可以使用<code class="fe me mf mg mh b">req.socket.remoteAddress</code>。</p><h1 id="f132" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">用对象id数组创建Mongoose模式</h1><p id="a4c8" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">要创建一个包含对象id数组的Mongoose模式，我们只需向数组传递一个构造函数或模式。</p><p id="60a4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="9daa" class="mq lc iq mh b gy mr ms l mt mu">const userSchema = mongoose.Schema({<br/>  lists: [listSchema],<br/>  friends: [{ type : ObjectId, ref: 'User' }]<br/>});</span><span id="9b8a" class="mq lc iq mh b gy mv ms l mt mu">exports.User = mongoose.model('User', userSchema);</span></pre><p id="128e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们传入<code class="fe me mf mg mh b">listSchema</code>来使用一个现有的模式作为一个带有数组的模式。</p><p id="1920" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">listSchema</code>是现有的猫鼬模式。</p><p id="79e4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也可以像处理<code class="fe me mf mg mh b">friends</code>一样传入一个对象。</p><p id="6d69" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们让<code class="fe me mf mg mh b">friends</code>引用自身。</p><h1 id="b65e" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">监听Node.js中所有发出的事件</h1><p id="c59d" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">为了监听所有发出的事件，我们可以使用通配符。</p><p id="fc08" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以用<code class="fe me mf mg mh b">eventemitter2</code>包做到这一点。</p><p id="4c12" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它支持命名空间和通配符。</p><p id="8836" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="06e0" class="mq lc iq mh b gy mr ms l mt mu">const EventEmitter2 = require('eventemitter2');<br/>const emitter = new EventEmitter2({<br/>  wildcard: false,<br/>  delimiter: '.',<br/>  newListener: false,<br/>  removeListener: false,<br/>  maxListeners: 10,<br/>  verboseMemoryLeak: false,<br/>  ignoreErrors: false<br/>});</span><span id="198a" class="mq lc iq mh b gy mv ms l mt mu">emitter.on('bar.*', (val) =&gt; {<br/>  console.log(this.event, valu);<br/>});</span></pre><p id="7d5f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们收听名称以<code class="fe me mf mg mh b">bar.</code>开头的所有事件</p><p id="b3fa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们可以监听多个事件和用符号表示标识符的事件。</p><h1 id="fb2e" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">在客户端JavaScript中访问Express.js局部变量</h1><p id="5104" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以在客户端JavaScript中访问Express局部变量。</p><p id="dd29" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们要做的就是传入一个对象作为<code class="fe me mf mg mh b">res.render</code>的第二个参数。</p><p id="fce5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以通过键名来访问变量。</p><p id="b1af" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="4029" class="mq lc iq mh b gy mr ms l mt mu">res.render('index', {<br/>  title: 'page title',<br/>  urls: JSON.stringify(urls),<br/>});</span></pre><p id="81ca" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以通过书写来访问它们:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="5317" class="mq lc iq mh b gy mr ms l mt mu">const urls = !{urls};</span></pre><p id="8432" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们的Jad模板中</p><p id="7461" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们必须使用stringy<code class="fe me mf mg mh b">urls</code>,因为变量是通过字符串插值添加的。</p><h1 id="180f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">如何检查邮件头是否已经用快递寄出</h1><p id="6bbf" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以检查是否已经用<code class="fe me mf mg mh b">res.headerSent</code>属性发送了报头。</p><p id="e61c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="891f" class="mq lc iq mh b gy mr ms l mt mu">if (res.headersSent) { <br/>  //...<br/>}</span></pre><h1 id="cd2b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">将时间戳转换为人类日期</h1><p id="8b7d" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过使用<code class="fe me mf mg mh b">Date</code>构造函数将时间戳转换为人类的日期。</p><p id="5b68" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="9a8f" class="mq lc iq mh b gy mr ms l mt mu">const date = new Date(1591399037536);</span></pre><p id="9d94" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以调用<code class="fe me mf mg mh b">toDateString</code>、<code class="fe me mf mg mh b">toTimeString</code>或<code class="fe me mf mg mh b">toLocaleDateString</code>来按照我们喜欢的方式格式化字符串。</p><h1 id="8e6a" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">测量节点应用程序中代码的计时</h1><p id="fff2" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">要测量节点应用程序的计时，我们可以使用<code class="fe me mf mg mh b">performance.now()</code>方法。</p><p id="faf2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="5054" class="mq lc iq mh b gy mr ms l mt mu">const {<br/>  performance<br/>} = require('perf_hooks');<br/><br/>console.log(performance.now());</span></pre><p id="de5b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们只是从<code class="fe me mf mg mh b">perf_hooks</code>导入<code class="fe me mf mg mh b">performance</code>对象，然后在其上调用<code class="fe me mf mg mh b">now</code>方法。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/82291449ab14a1cd6a0c312549d1a611.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*sstCxag982no7qOU"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">里卡多·莫拉在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="893b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="edd8" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用<code class="fe me mf mg mh b">performance.now()</code>方法来衡量绩效。</p><p id="4b26" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要创建HTTP代理，我们可以使用第三方包来完成。</p><p id="7155" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Mongoose模式中可以有数组。</p><p id="c87b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以从Express的头中获得请求的主机名。</p><p id="29f1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">读流适合读大文件，<code class="fe me mf mg mh b">readFile</code>适合读小文件。</p></div></div>    
</body>
</html>