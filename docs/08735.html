<html>
<head>
<title>Avoid Java wildcard imports… but why?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">避免 Java 通配符导入…但是为什么呢？</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/avoid-java-wildcard-imports-but-why-f219644cdd97?source=collection_archive---------6-----------------------#2022-07-06">https://blog.devgenius.io/avoid-java-wildcard-imports-but-why-f219644cdd97?source=collection_archive---------6-----------------------#2022-07-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/de5f071491bb5b369d9365edc35e9643.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wJ5EU7oOjhe2TxXv"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">十到角落口袋？照片由<a class="ae kc" href="https://unsplash.com/@christianw?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">克里斯蒂安·威迪格</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="bceb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了组织 Java 程序需要的各种类和接口，我们可以将它们放在包中。然后，您可以根据 Java 类或接口来自的包来完全限定它的名称。举个例子，</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="6963" class="lk ll iq lg b gy lm ln l lo lp"><strong class="lg ir">java.util.</strong>List&lt;<strong class="lg ir">java.util.</strong>Currency&gt; currencies <br/>        = new <strong class="lg ir">java.util.</strong>ArrayList&lt;<strong class="lg ir">java.util.</strong>Currency&gt;();</span></pre><p id="d673" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">会很快变老。所以 Java 也提供了 Import 语句。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="b1b3" class="lk ll iq lg b gy lm ln l lo lp">package org.example.currency;</span><span id="a999" class="lk ll iq lg b gy lq ln l lo lp"><strong class="lg ir">import java.util.ArrayList;<br/>import java.util.Currency;<br/>import java.util.List;</strong></span><span id="54b6" class="lk ll iq lg b gy lq ln l lo lp">public class CurrencyUtils {</span><span id="605a" class="lk ll iq lg b gy lq ln l lo lp">    // etc., etc.</span><span id="2932" class="lk ll iq lg b gy lq ln l lo lp">}</span></pre><p id="dd28" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，利用导入和“钻石”语法(Java 7 和更高版本)，我们可以简化<code class="fe lr ls lt lg b">currencies</code>的声明:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="7c8b" class="lk ll iq lg b gy lm ln l lo lp"><strong class="lg ir">List&lt;Currency&gt;</strong> currencies = new <strong class="lg ir">ArrayList&lt;&gt;</strong>();</span></pre><p id="8ef5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为什么停在那里？我们可以更进一步，删除更多的行。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="42f0" class="lk ll iq lg b gy lm ln l lo lp">package org.example.currency;</span><span id="dfd3" class="lk ll iq lg b gy lq ln l lo lp"><strong class="lg ir">import java.util.*;</strong></span><span id="740e" class="lk ll iq lg b gy lq ln l lo lp">public class CurrencyUtils {</span><span id="e752" class="lk ll iq lg b gy lq ln l lo lp">    // etc., etc.</span><span id="7c37" class="lk ll iq lg b gy lq ln l lo lp">}</span></pre><p id="afdb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种类型的导入语句称为“通配符”导入。你们中那些年龄足够大，还记得 DOS 的人可能还记得输入类似“dir *”的命令。xml”(该示例也适用于 Windows 10 命令行，它列出了目录中的 XML 文件，但省略了列表中带有其他扩展名的文件)。</p><p id="6462" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">示例导入并不意味着<code class="fe lr ls lt lg b">java.util</code>包中的所有东西都会被导入。只有<code class="fe lr ls lt lg b">CurrencyUtils</code>类的花括号中实际引用的<code class="fe lr ls lt lg b">java.util</code>类和接口(但不是完全限定的)会被通配符导入引入。</p><p id="fde4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">存在命名冲突的可能性。虽然这实际上并不是通配符导入的最糟糕的问题，但是几乎每个人都会首先提到这个问题。假设您有<code class="fe lr ls lt lg b">java.awt</code>和<code class="fe lr ls lt lg b">java.util</code>的通配符导入。</p><p id="dfe1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么编译器将不知道您所说的“<code class="fe lr ls lt lg b">List</code>”是什么意思，而您的集成开发环境(IDE)会让您知道:</p><figure class="lb lc ld le gt jr gh gi paragraph-image"><div class="gh gi lu"><img src="../Images/6d53eb7aa6667a5d032f7ef6b3dab4c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1012/format:webp/1*kmA9hy2Ks1qmcMrEFtdBLw.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">IntelliJ IDEA 的屏幕截图告诉您，由于通配符导入冲突，引用不明确。</figcaption></figure><p id="24bb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您的 IDE 可能建议了一种解决这一困难的方法:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="3116" class="lk ll iq lg b gy lm ln l lo lp">import java.awt.*;<br/>import java.util.*;<br/><strong class="lg ir">import java.util.List;</strong></span></pre><p id="2718" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您的类合法地需要从<code class="fe lr ls lt lg b">java.awt</code>导入几乎所有的东西，只留下<code class="fe lr ls lt lg b">List</code>和那个包中的一两件其他东西，那么通配符导入是值得的。</p><p id="cb43" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是……真的有必要从<code class="fe lr ls lt lg b">java.awt</code>进口几乎所有东西吗？或者，就此而言，从<code class="fe lr ls lt lg b">java.util</code>开始，不同东西的大杂烩应该是三个或四个独立的包？</p><p id="df4a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为 Java 虚拟机并没有真正看到“子包”，所以对<code class="fe lr ls lt lg b">java.util</code>的通配符导入实际上并没有从<code class="fe lr ls lt lg b">java.util.regex</code>、<code class="fe lr ls lt lg b">java.util.concurrent</code>等处得到任何东西。</p><p id="707c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我看来，一揽子导入的最大问题是它模糊了程序员的意图。如果您没有使用通过通配符导入引入的包中的所有内容，那么就很难记住为什么要将该导入放在第一位。</p><p id="15ea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不管是否使用导入，都可能是这种情况，尽管这当然会有所不同。例如，假设您打开了一个已经有一段时间没有使用的项目，您注意到在项目中一个不太充实的类中有一些未使用的导入。</p><p id="e2f7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设其中一个导入是对<code class="fe lr ls lt lg b">java.time</code>的通配符导入，另一个是对<code class="fe lr ls lt lg b">java.util</code>的通配符导入。您可能希望<code class="fe lr ls lt lg b">java.time</code>用时间戳或时间间隔做一些事情。</p><p id="9098" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是<code class="fe lr ls lt lg b">java.util</code>导入几乎可以用于任何事情:也许您需要一些集合，比如著名的<code class="fe lr ls lt lg b">ArrayList&lt;E&gt;</code>，或者也许您需要地区和货币数据，或者也许您需要一些按位操作。</p><p id="ca83" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">甚至有可能是你想让<code class="fe lr ls lt lg b">java.util</code>使用备受争议的<code class="fe lr ls lt lg b">Date</code>和日历类。不过，可能不是 64 进制的东西。那个包裹装得太多了。</p><p id="30b6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">即使实际上使用了通配符导入，程序员的意图仍然不像特定导入那样清晰。</p><p id="10ee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用包中的单个类或接口就足以将通配符导入视为已使用。然后，确定什么来自什么包的唯一方法是逐个删除通配符导入，并查看每个删除的通配符导入会导致什么错误。</p><p id="462e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">实际上，还有另一种方法，但是太费时间了，不值得:转到每个提到的类型并导航到声明(你应该能够在任何主要的 ide 中做到这一点)。例如，在 NetBeans 中有一种稍微简单的方法:</p><figure class="lb lc ld le gt jr gh gi paragraph-image"><div class="gh gi lv"><img src="../Images/21c1565d39d130c00a73d6cb0b60a828.png" data-original-src="https://miro.medium.com/v2/resize:fit:944/format:webp/1*iAQI96_-4CWN7FOeBkTC0w.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">在这个 NetBeans 截图中，我们看到图形环境类来自 Java 的抽象窗口工具包(AWT)包。</figcaption></figure><p id="59b8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是这仍然需要一行一行地仔细检查源文件，寻找那些你不记得它们来自哪个包的类型。</p><p id="45e1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">作为一个非常粗略的准则，只有当您需要包中一半以上的类和接口时，才使用通配符导入(枚举类型是一种特殊的类)。</p><p id="31fb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你确实需要导入一个包中的所有东西，这可能意味着你正在处理的类应该在你要导入的包中。</p><p id="feb1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这可能表明违反了适用于包的单一责任原则，因为一个包有多个责任(<code class="fe lr ls lt lg b">java.util</code>就是一个恰当的例子)。</p><p id="599d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者，这也可能意味着违反了适用于类的单一责任原则，因为类有多个责任，如果它只有一个责任，它可能需要更少的导入。</p><p id="9347" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，不要担心忘记从一个给定的包中编写一个特定的导入，然后在某个时候想起回到源文件的顶部会分散你的注意力。在这种情况下，您的 IDE 可能会有所帮助。</p><p id="047e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，假设您已经从<code class="fe lr ls lt lg b">java.io</code>导入了几个类，但是没有从<code class="fe lr ls lt lg b">IOException</code>导入。然后，您需要调用抛出<code class="fe lr ls lt lg b">IOException</code>的东西，这是一个检查过的异常。</p><p id="f51f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">继续编写那个调用。那么您的 IDE 可能会提供添加一个 Throws 子句或者用 Try-Catch 块包围调用。如果您接受其中一个建议，您的 IDE 可能还会添加必要的特定导入。至少 IntelliJ 会。</p><p id="2003" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一方面，如果您放弃 ide，转而使用像 Vim 这样的文本编辑器并在命令行上编译，您可能会更加关心通配符导入带来的重构便利性。</p><p id="4504" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，假设你认为你需要<code class="fe lr ls lt lg b">java.util.Map&lt;K, V&gt;</code>和<code class="fe lr ls lt lg b">java.util.TreeMap&lt;K, V&gt;</code>。但是之后你决定使用<code class="fe lr ls lt lg b">HashMap&lt;K, V&gt;</code>而不是<code class="fe lr ls lt lg b">TreeMap&lt;K, V&gt;</code>。</p><p id="4580" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有了<code class="fe lr ls lt lg b">java.util.*</code>的通配符导入，即使没有 IDE 的帮助，这种改变也容易得多。您甚至可以决定使用只有一个类型参数而不是两个的标准集合。</p><p id="c450" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">支持通配符导入的另一个理由是，它使得与被导入的包的耦合更松散。松耦合是一件好事。假设包<em class="lw"> B </em>中的类<em class="lw"> C </em>从包<em class="lw"> A </em>中导入了某种东西，松耦合意味着在不破坏类<em class="lw"> C </em>的情况下对包<em class="lw"> A </em>进行修改更容易。</p><p id="7446" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是通配符导入真的放松了耦合吗，还是仅仅掩盖了耦合的紧密性？</p><p id="0eb6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设包<em class="lw"> A </em>中的类<em class="lw"> D </em>在该包的最新版本中被弃用。例如，如果包<em class="lw"> B </em>中的类<em class="lw"> C </em>有 20 个对类<em class="lw"> D </em>的引用，那么如果这 20 个引用中有一个是特定的导入，那么差别就很小。</p><p id="d4b0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">即使使用通配符导入，本例中的<em class="lw"> C </em>与<em class="lw"> D </em>的耦合也过于紧密。如果在下一个版本中<em class="lw"> D </em>被完全删除，那么不需要删除<em class="lw"> C </em>中的一个特定导入是一个非常小的便利。</p><p id="02b5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是 IDE 更容易做到的事情之一。在 IDE 中，不推荐使用的类或接口标有删除线，通配符导入除外。我肯定这些在记事本中不会被这样标记，我也怀疑 Vim 会标记不推荐使用的项目。</p><p id="b22d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">尽可能多地引用<em class="lw"> D </em>的超类或接口可能对松散耦合更有帮助。例如，如果<em class="lw"> J </em>是<em class="lw"> D </em>的抽象超类或者是<em class="lw"> D </em>实现的接口，那么“<em class="lw"> J x </em> <code class="fe lr ls lt lg b"> = new </code> <em class="lw"> D </em> <code class="fe lr ls lt lg b">()</code>”对<em class="lw"> D </em>的耦合比“<em class="lw"> D x </em> <code class="fe lr ls lt lg b"> = new </code> <em class="lw"> D </em> <code class="fe lr ls lt lg b">()</code>更松散</p><p id="7100" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Java 中的通配符导入提供了一些短期便利。但是这种便利是以清晰为代价的，并且减少了程序员的深思熟虑的印象。</p><p id="f261" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">出于这个原因，而不是因为担心与像<code class="fe lr ls lt lg b">java.awt.List</code>这样晦涩的类发生命名冲突，Java 中的通配符导入通常应该避免。</p></div></div>    
</body>
</html>