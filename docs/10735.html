<html>
<head>
<title>Typescript in Mongoose</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">猫鼬语打字稿</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/typescript-in-mongoose-9994fca6987b?source=collection_archive---------1-----------------------#2022-11-26">https://blog.devgenius.io/typescript-in-mongoose-9994fca6987b?source=collection_archive---------1-----------------------#2022-11-26</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/491e09d1ce0abe4b671eb694f7e4e83b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QUrJ-O5A_SrqSVNh"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">照片由<a class="ae jz" href="https://unsplash.com/@clark_fransa?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">阿诺·弗朗西斯卡</a>在<a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><h1 id="ba7f" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">在 Mongoose 中使用 typescript</h1><p id="f50b" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">Mongoose 是一个非常好的用于 NodeJS 运行时的 ODM 包，它帮助你创建一个更加面向对象的方法来处理数据库。另一方面，typescript 是 Javascript 的类型化版本，但是我看到许多人对如何使用 mongoose 和 typescript 感到困惑，因为它是嵌套的和基本的</p><h2 id="3482" class="lw kb in bd kc lx ly dn kg lz ma dp kk lj mb mc ko ln md me ks lr mf mg kw mh bi translated">我们需要猫鼬的打字稿吗？</h2><p id="eac3" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">这个问题的答案与你的项目方法有关，但是如果你选择了 typescript，那么使用你的改进类型是必须的，否则你仍然可以在没有定义任何模式的情况下使用 mongoose 和 typescript，你的救世主将是<code class="fe mi mj mk ml b">any</code>关键字</p><h2 id="be46" class="lw kb in bd kc lx ly dn kg lz ma dp kk lj mb mc ko ln md me ks lr mf mg kw mh bi translated">typescript 可以使用 mongoose 自定义方法和属性吗？</h2><p id="98a6" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">是的，它是。Mongoose 提供了开箱即用的接口，让我们可以创建各种接口，并帮助我们定义必要的属性和方法。如果你想了解 mongoose 和自定义方法，那么请阅读我之前的文章</p><div class="mm mn gp gr mo mp"><a href="https://javascript.plainenglish.io/encrypt-fields-with-mongoose-method-and-plugin-7c2452263e2d" rel="noopener  ugc nofollow" target="_blank"><div class="mq ab fo"><div class="mr ab ms cl cj mt"><h2 class="bd io gy z fp mu fr fs mv fu fw im bi translated">如何用 Mongoose 方法和插件加密字段</h2><div class="mw l"><h3 class="bd b gy z fp mu fr fs mv fu fw dk translated">关于我们如何使用 mongoose 方法来管理需要加密的密码或类似密码的字段的指南…</h3></div><div class="mx l"><p class="bd b dl z fp mu fr fs mv fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="my l"><div class="mz l na nb nc my nd jt mp"/></div></div></a></div><div class="mm mn gp gr mo mp"><a href="https://javascript.plainenglish.io/create-own-method-in-mongoose-model-5fefa7975b9d" rel="noopener  ugc nofollow" target="_blank"><div class="mq ab fo"><div class="mr ab ms cl cj mt"><h2 class="bd io gy z fp mu fr fs mv fu fw im bi translated">如何使用 Mongoose 创建一个方法</h2><div class="mw l"><h3 class="bd b gy z fp mu fr fs mv fu fw dk translated">使用 Mongoose 创建比较密码或获取已删除记录的方法指南。</h3></div><div class="mx l"><p class="bd b dl z fp mu fr fs mv fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="my l"><div class="ne l na nb nc my nd jt mp"/></div></div></a></div><h1 id="b646" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">用 typescript 和 mongoose 创建项目</h1><p id="9633" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">我有一个用于 mongoose 和 typescript 的引导项目，其中安装了依赖项。出于本文的考虑，我将使用两个数据库模型</p><ul class=""><li id="2ca1" class="nf ng in la b lb nh lf ni lj nj ln nk lr nl lv nm nn no np bi translated">应用程序用户</li><li id="c5b3" class="nf ng in la b lb nq lf nr lj ns ln nt lr nu lv nm nn no np bi translated">申请地点</li></ul><p id="8184" class="pw-post-body-paragraph ky kz in la b lb nh ld le lf ni lh li lj nv ll lm ln nw lp lq lr nx lt lu lv ig bi translated">我们会用它们来创造变化</p><h2 id="ddb8" class="lw kb in bd kc lx ly dn kg lz ma dp kk lj mb mc ko ln md me ks lr mf mg kw mh bi translated">定义模式类型</h2><p id="e1c3" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">从项目开始，我们可以从定义模式和创建第一个接口开始，让我们从<code class="fe mi mj mk ml b">ApplicationUser</code>开始并定义它的属性</p><pre class="ny nz oa ob gt oc ml od bn oe of bi"><span id="c97d" class="og kb in ml b be oh oi l oj ok">export interface IApplicationUser {<br/>  email: string;<br/>  firstName: string;<br/>  lastName: string;<br/>}</span></pre><blockquote class="ol om on"><p id="4f8b" class="ky kz oo la b lb nh ld le lf ni lh li op nv ll lm oq nw lp lq or nx lt lu lv ig bi translated">主要文章建议使用和扩展来自<code class="fe mi mj mk ml b">Document</code>mongose 的接口，但是如果你想定义自定义方法或关系，你不应该使用它们。例如<code class="fe mi mj mk ml b">interface ApplicationUser extends Document</code></p></blockquote><p id="689d" class="pw-post-body-paragraph ky kz in la b lb nh ld le lf ni lh li lj nv ll lm ln nw lp lq lr nx lt lu lv ig bi translated">现在我们的模型有了一些属性，让我们向模式中添加一些实例方法和静态方法</p><h2 id="7d15" class="lw kb in bd kc lx ly dn kg lz ma dp kk lj mb mc ko ln md me ks lr mf mg kw mh bi translated">添加类型化实例和静态 mongoose 方法类型</h2><p id="1823" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">我们可以用我们想要的自定义方法再创建一个接口，我们将在稍后的实现中使用这个接口</p><pre class="ny nz oa ob gt oc ml od bn oe of bi"><span id="a7ea" class="og kb in ml b be oh oi l oj ok">interface IApplicationUserMethods {<br/>  fullName(): string;<br/>}</span></pre><p id="d82c" class="pw-post-body-paragraph ky kz in la b lb nh ld le lf ni lh li lj nv ll lm ln nw lp lq lr nx lt lu lv ig bi translated">现在，你应该知道的一件事是实例方法不是模型本身的属性，但另一方面，结果静态方法是模型的属性，所以对于任何静态方法或查询帮助器，我们需要覆盖模型接口</p><pre class="ny nz oa ob gt oc ml od bn oe of bi"><span id="a68c" class="og kb in ml b be oh oi l oj ok">interface IApplicationUserModel extends Model&lt;<br/>  IApplicationUser,<br/>  {},<br/>  IApplicationUserMethods<br/>&gt; {<br/>    findAllUsers(): HydratedDocument&lt;IApplicationUser, IApplicationUserMethods&gt;<br/>}</span></pre><p id="ff31" class="pw-post-body-paragraph ky kz in la b lb nh ld le lf ni lh li lj nv ll lm ln nw lp lq lr nx lt lu lv ig bi translated">为了覆盖模型接口，我们将在前面创建的接口的帮助下创建我们的模型定义，并将它们从 mongoose 传递给<code class="fe mi mj mk ml b">Model</code> type，然后附加自定义声明</p><blockquote class="ol om on"><p id="08c8" class="ky kz oo la b lb nh ld le lf ni lh li op nv ll lm oq nw lp lq or nx lt lu lv ig bi translated">HydratedDocument 是 mongoose 在计算后将返回的实例类型。它将拥有模型的模式定义，而不是实例定义</p></blockquote><h2 id="588a" class="lw kb in bd kc lx ly dn kg lz ma dp kk lj mb mc ko ln md me ks lr mf mg kw mh bi translated">创建模型架构</h2><p id="b317" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">在创建实际模型之前，我们有 3 个接口，我们将使用它们来创建模式。schema 方法有三个接口<code class="fe mi mj mk ml b">Model definition, overrided model and instance methods interface</code>，因为我们已经定义了覆盖模型，所以我们不需要传递第三个参数</p><pre class="ny nz oa ob gt oc ml od bn oe of bi"><span id="8a31" class="og kb in ml b be oh oi l oj ok">const ApplicationUserSchema = new Schema&lt;<br/>  IApplicationUser,<br/>  IApplicationUserModel<br/>&gt;({<br/>  email: { type: String, required: true, unique: true },<br/>  firstName: { type: String, required: true },<br/>  lastName: { type: String, required: true },<br/>});<br/><br/>// static method<br/>ApplicationUserSchema.statics.findAllUsers = function() {<br/>  return this.find();<br/>}<br/><br/>// instance method<br/>ApplicationUserSchema.method("fullName", function fullName() {<br/>  return this.firstName + " " + this.lastName;<br/>});<br/><br/>// exporting the schema and model<br/>const ApplicationUser = mongoose.model&lt;IApplicationUser, IApplicationUserModel&gt;(<br/>  "ApplicationUser",<br/>  ApplicationUserSchema<br/>);<br/>export default ApplicationUser;</span></pre><p id="59c3" class="pw-post-body-paragraph ky kz in la b lb nh ld le lf ni lh li lj nv ll lm ln nw lp lq lr nx lt lu lv ig bi translated">就是这个，文件现在看起来像这样，差不多是我们刚刚讨论的所有内容的总和</p><figure class="ny nz oa ob gt jo gh gi paragraph-image"><div class="gh gi os"><img src="../Images/f015e87122f4b4972e47b193d8119459.png" data-original-src="https://miro.medium.com/v2/resize:fit:1372/format:webp/1*jmHtDOMnvW3HrHhTHCU_Mg.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">主模型的模式定义</figcaption></figure><h2 id="5bc7" class="lw kb in bd kc lx ly dn kg lz ma dp kk lj mb mc ko ln md me ks lr mf mg kw mh bi translated">使用模型</h2><p id="0f18" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">现在，让我们使用我们的模型来查看和检查字段是否是自动填充的。如果您将鼠标悬停在属性上，您将不会看到任何错误和字段的定义，这对于自定义方法和静态方法也是如此，并且 typescript 将编译时不会出现任何错误</p><figure class="ny nz oa ob gt jo gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/2f19280e8a0a90b706445b8485e1d4f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1074/format:webp/1*hIqmU579mFLbPiw6GYD4mQ.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">现场人口的结果</figcaption></figure><figure class="ny nz oa ob gt jo gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/143562764ddba169a8ce8c4cad2cef44.png" data-original-src="https://miro.medium.com/v2/resize:fit:898/format:webp/1*Qzpr0INsY-VsyqZoySglfw.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">属性检查器的结果</figcaption></figure><p id="02ee" class="pw-post-body-paragraph ky kz in la b lb nh ld le lf ni lh li lj nv ll lm ln nw lp lq lr nx lt lu lv ig bi translated">现在一切都编译好了，没有错误，让我们来看看文章的另一个问题陈述。<em class="oo">“如何使用 typescript 填充字段？”</em></p><h2 id="be5d" class="lw kb in bd kc lx ly dn kg lz ma dp kk lj mb mc ko ln md me ks lr mf mg kw mh bi translated"><em class="ov">使用带有类型脚本的填充字段</em></h2><p id="bb1b" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">这有点棘手，因为填充的字段使用相同的键来填充和存储实例的 id。为了解决这个问题，我们有几种方法，让我们逐一讨论</p><p id="c000" class="pw-post-body-paragraph ky kz in la b lb nh ld le lf ni lh li lj nv ll lm ln nw lp lq lr nx lt lu lv ig bi translated">为了开始这个解决方案，让我们使用一个名为<code class="fe mi mj mk ml b">ApplicationPlace</code>的新模型，其中<code class="fe mi mj mk ml b">maintainer</code>是将被映射到<code class="fe mi mj mk ml b">ApplicationUser</code>模型的键，并从中填充数据</p><p id="3a97" class="pw-post-body-paragraph ky kz in la b lb nh ld le lf ni lh li lj nv ll lm ln nw lp lq lr nx lt lu lv ig bi translated">定义模式——我们将有一个名为 location 的字段，另一个是 maintainer，它将从<code class="fe mi mj mk ml b">ApplicationUser</code>模型中填充</p><pre class="ny nz oa ob gt oc ml od bn oe of bi"><span id="bdcd" class="og kb in ml b be oh oi l oj ok">// schema<br/>const ApplicationPlaceSchema: Schema = new Schema({<br/>  location: { type: String, required: true },<br/>  maintainer: { type: Schema.Types.ObjectId, required: true },<br/>});<br/><br/>// interface<br/>export interface IApplicationPlace extends Document {<br/>  location: string;<br/>  maintainer: HydratedDocument&lt;IApplicationUser&gt;['_id']<br/>}<br/><br/>export default mongoose.model&lt;IApplicationPlace&gt;(<br/>  "ApplicationPlace",<br/>  ApplicationPlaceSchema<br/>);</span></pre><p id="3f61" class="pw-post-body-paragraph ky kz in la b lb nh ld le lf ni lh li lj nv ll lm ln nw lp lq lr nx lt lu lv ig bi translated">要在界面中定义一个填充的字段，我们可以使用<code class="fe mi mj mk ml b">HydratedDocument&lt;ModelInterface&gt;[fieldname]</code>将字段映射到我们选择的模型。既然我们使用默认关系，那么我们可以使用<code class="fe mi mj mk ml b">_id</code>字段。</p><p id="cad6" class="pw-post-body-paragraph ky kz in la b lb nh ld le lf ni lh li lj nv ll lm ln nw lp lq lr nx lt lu lv ig bi translated">现在，这两个字段都有可用的选项，但是默认情况下，它将指向 ObjectId 定义。我们可以在使用 populate 方法时改变这一点</p><figure class="ny nz oa ob gt jo gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/24c235f3cb9d4dd796203a3b5efa8650.png" data-original-src="https://miro.medium.com/v2/resize:fit:1326/format:webp/1*cpU95cwSQoBUreHaKOoYbA.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">使用填充字段的结果</figcaption></figure><p id="2a89" class="pw-post-body-paragraph ky kz in la b lb nh ld le lf ni lh li lj nv ll lm ln nw lp lq lr nx lt lu lv ig bi translated">这种用法的关键在于，我们显式定义了下面函数的输出，该函数与 typescript 中的关键字<code class="fe mi mj mk ml b">as</code>的作用相同</p><h2 id="2387" class="lw kb in bd kc lx ly dn kg lz ma dp kk lj mb mc ko ln md me ks lr mf mg kw mh bi translated">定义填充字段的另一种方法</h2><p id="7665" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">还有一种方法，我们可以通过使用<code class="fe mi mj mk ml b">PopulatedDoc</code>类型并传递具有预期类型的其他模型接口来定义字段，如下例所示</p><pre class="ny nz oa ob gt oc ml od bn oe of bi"><span id="b387" class="og kb in ml b be oh oi l oj ok">export interface IApplicationPlace extends Document {<br/>  location: string;<br/>  maintainer: PopulatedDoc&lt;Document&lt;ObjectId&gt; &amp; IApplicationUser&gt;<br/>}</span></pre><p id="7ce3" class="pw-post-body-paragraph ky kz in la b lb nh ld le lf ni lh li lj nv ll lm ln nw lp lq lr nx lt lu lv ig bi translated">这种方法的缺点是，我们必须总是在处理程序中检查预期的类型，这可能会更加繁琐。</p><pre class="ny nz oa ob gt oc ml od bn oe of bi"><span id="de72" class="og kb in ml b be oh oi l oj ok"> if (maintainer == null || maintainer instanceof ObjectId) {<br/>    throw new Error('should be populated');<br/>  } else {<br/>    // Works<br/>    doc.maintainer.firstName.trim();<br/>  }</span></pre><h2 id="048b" class="lw kb in bd kc lx ly dn kg lz ma dp kk lj mb mc ko ln md me ks lr mf mg kw mh bi translated">结论</h2><p id="8a0f" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">在项目中使用 typescript 将提高错误处理能力，并对未来的错误有更好的了解。Mongoose 是一种我们可以充分利用的类型化 ODM。我希望我们都能从这篇文章中学到一些新的东西，并且您可以在<a class="ae jz" href="https://github.com/Piyush-Use-Personal/mongoose-typescript" rel="noopener ugc nofollow" target="_blank">mongose typescript 库</a>中找到源代码。快乐编码。</p></div></div>    
</body>
</html>