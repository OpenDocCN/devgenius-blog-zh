<html>
<head>
<title>(Java) Writing JSON parser in 300 lines of code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">(Java)用 300 行代码编写 JSON 解析器</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/java-writing-json-parser-in-300-lines-of-code-c3c1711acba6?source=collection_archive---------13-----------------------#2022-11-24">https://blog.devgenius.io/java-writing-json-parser-in-300-lines-of-code-c3c1711acba6?source=collection_archive---------13-----------------------#2022-11-24</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="ef1b" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">这是用 Java 代码进行自顶向下解析的简短介绍</h2></div><p id="081d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果大多数人不认为编写编译器(和解析器)是一件苦差事，世界上可能会有更多的编程语言。我也分享了这个信念很长一段时间，直到我来到这个伟大的系列。这一点和最近缺乏编程挑战激发了我写这篇文章。</p><blockquote class="kz la lb"><p id="7e8f" class="kc kd lc ke b kf kg jo kh ki kj jr kk ld km kn ko le kq kr ks lf ku kv kw kx ig bi translated"><strong class="ke io">解析器</strong>是一个软件组件，它获取输入数据(通常是文本)并构建<a class="ae ky" href="https://en.wikipedia.org/wiki/Data_structure" rel="noopener ugc nofollow" target="_blank">数据结构</a>——通常是某种<a class="ae ky" href="https://en.wikipedia.org/wiki/Parse_tree" rel="noopener ugc nofollow" target="_blank">解析树</a>、<a class="ae ky" href="https://en.wikipedia.org/wiki/Abstract_syntax_tree" rel="noopener ugc nofollow" target="_blank">抽象语法树</a>或其他层次结构，在检查语法是否正确的同时给出输入的结构表示。—维基百科</p></blockquote><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi lg"><img src="../Images/39e52442b6b3a35b68d3eefaee67d14b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lX2FYFZEr2D6rhBQ"/></div></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">丹尼尔·施鲁迪在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="fabd" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这篇文章中，我想展示以自顶向下的方式解析抽象语法树就像一堆方法在输入缓冲区中递归地互相调用一样简单。</p></div><div class="ab cl lw lx hr ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ig ih ii ij ik"><h1 id="7b7b" class="md me in bd mf mg mh mi mj mk ml mm mn jt mo ju mp jw mq jx mr jz ms ka mt mu bi translated">JSON</h1><p id="8947" class="pw-post-body-paragraph kc kd in ke b kf mv jo kh ki mw jr kk kl mx kn ko kp my kr ks kt mz kv kw kx ig bi translated">JSON 的简单性导致它出现在大多数微服务架构中。它的语法也非常简单。如此简单，以至于很容易在一天内完成解析器。</p><p id="61bb" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">表达语法的常见方式是<a class="ae ky" href="https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form" rel="noopener ugc nofollow" target="_blank">巴克斯-诺尔形式</a>，这里是针对 JSON 的:</p><pre class="lh li lj lk gt na nb nc bn nd ne bi"><span id="cd90" class="nf me in nb b be ng nh l ni nj">json ::= element<br/><br/>value ::= object | array | string | number | 'true' | 'false' | 'null'<br/><br/>object ::= '{' ws '}' | '{' members '}'<br/><br/>members ::= member | member ',' members<br/><br/>member ::= ws string ws ':' element<br/><br/>array ::= '[' ws ']' | '[' elements ']'<br/><br/>elements ::= element | element ',' elements<br/><br/>element ::= ws value ws<br/><br/>string ::= '"' characters '"'<br/><br/>characters ::= "" | character characters<br/><br/>character ::= &lt;any printable character&gt;<br/><br/>number ::= integer fraction exponent<br/><br/>integer ::= digit | onenine digits | '-' digit | '-' onenine digits<br/><br/>digits ::= digit | digit digits<br/><br/>digit ::= '0' | onenine<br/><br/>onenine ::= '1' . '9'<br/><br/>fraction ::= "" | '.' digits<br/><br/>exponent ::= "" | 'E' sign digits | 'e' sign digits<br/><br/>sign ::= "" | '+' | '-'<br/><br/>ws ::= &lt;any whitespace character&gt;</span></pre><h1 id="25b5" class="md me in bd mf mg nk mi mj mk nl mm mn jt nm ju mp jw nn jx mr jz no ka mt mu bi translated">密码</h1><p id="fa9d" class="pw-post-body-paragraph kc kd in ke b kf mv jo kh ki mw jr kk kl mx kn ko kp my kr ks kt mz kv kw kx ig bi translated">解析的结果是嵌套结构的树。我们将借助多态来表示元素(想想<a class="ae ky" href="https://refactoring.guru/design-patterns/composite" rel="noopener ugc nofollow" target="_blank">复合模式</a>)。每个元素都继承自共同的祖先，其中一些元素还可以包含其他元素。从 Java 14 开始，用记录表示这些结构变得非常容易。</p><pre class="lh li lj lk gt na nb nc bn nd ne bi"><span id="3f77" class="nf me in nb b be ng nh l np nj">public interface Element {<br/>}<br/><br/>public record Object(Map&lt;String, Element&gt; members) implements Element {<br/>}<br/><br/>public record Array(List&lt;Element&gt; elements) implements Element {<br/>}<br/><br/>public record Str(String value) implements Element {<br/>}<br/><br/>public record Number(String value) implements Element {<br/>}<br/><br/>public record True() implements Element {<br/>}<br/><br/>public record False() implements Element {<br/>}<br/><br/>public record Null() implements Element {<br/>}</span></pre><p id="fba2" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">大多数课程建议首先对输入进行标记化，然后在第二阶段对标记进行解析。但是为了简单起见，让我们将这两个阶段合并为一个阶段。除了设计的主要工作之外…</p><pre class="lh li lj lk gt na nb nc bn nd ne bi"><span id="cc70" class="nf me in nb b be ng nh l np nj">public static class ParseResult {<br/><br/>        public final int offset;<br/>        public final Element content;<br/>        public final boolean isError;<br/>        public final boolean isEOF;<br/>        private final int snapshot;<br/><br/>        public ParseResult(int offset) {<br/>            this(offset, offset, null, false, false);<br/>        }<br/><br/>        private ParseResult(int offset, int snapshot, Element content, <br/>                            boolean isEOF, boolean isError) {<br/>            this.offset = offset;<br/>            this.snapshot = snapshot;<br/>            this.content = content;<br/>            this.isEOF = isEOF;<br/>            this.isError = isError;<br/>            this.map = new HashMap&lt;&gt;();<br/>            this.list = new ArrayList&lt;&gt;();<br/>        }<br/>}</span></pre><p id="6ed5" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是所有奇迹发生的班级。而且是一个<a class="ae ky" href="https://medium.com/@afcastano/monads-for-java-developers-part-1-the-optional-monad-aa6e797b8a6e" rel="noopener">单子</a>。简而言之，它是一种同时保存多个(矛盾的)值的容器类型，但是对所有这些值的方法调用都是相同的。</p><p id="9e87" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，与其用 ifs 检查它是否是一个错误或者文件的结尾，不如让两个元素，isError 和 isEOF 都嵌入到 monad 中，只是将一些解析调用链接在一起。</p><pre class="lh li lj lk gt na nb nc bn nd ne bi"><span id="7604" class="nf me in nb b be ng nh l np nj">  public ParseResult acceptChar(char[] buffer, char ch) {<br/>      if (isError || isEOF) return error();<br/>      if (!isChar(buffer, ch)) return error();<br/>      return advance(buffer, 1);<br/>  }<br/><br/>  public ParseResult advance(char[] buffer, int plus) {<br/>      if (isError || isEOF) return this;<br/>      return new ParseResult(offset + plus, snapshot, <br/>              content, isEOF(buffer, plus), false);<br/>  }<br/><br/>  public ParseResult acceptZeroOrMany(char[] buffer, <br/>                                      Predicate&lt;Character&gt; pred) {<br/>      if (isError || isEOF) return this;<br/>      int plus = 0;<br/>      while (!isEOF(buffer, plus) <br/>              &amp;&amp; pred.test(buffer[this.offset + plus])) plus++;<br/>      return new ParseResult(this.offset + plus, snapshot, <br/>              content, isEOF(buffer, plus), false);<br/>  }<br/><br/>  public boolean isEOF(char[] buffer, int plus) {<br/>      return this.offset + plus &gt;= buffer.length;<br/>  }<br/><br/>  public boolean isChar(char[] buffer, Predicate&lt;Character&gt; pred) {<br/>      if (isError || isEOF) return false;<br/>      return pred.test(buffer[this.offset]);<br/>  }<br/><br/>  public boolean isChar(char[] buffer, char c) {<br/>      return isChar(buffer, ch -&gt; ch == c);<br/>  }</span></pre><p id="d4e8" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">以上是在整个解析器中使用的助手函数。可以把它们看作解析逻辑的最基本的构件。请注意，它们在前奏中都有快速失效开关。我认为这是不言自明的——我们不断地从模式中接受字符，直到我们遇到文件的结尾。</p><pre class="lh li lj lk gt na nb nc bn nd ne bi"><span id="3dbb" class="nf me in nb b be ng nh l np nj">ParseResult parseTrue(char[] buffer) {<br/>    return parseLiteral(buffer, "true", True::new);<br/>}<br/><br/>ParseResult parseNull(char[] buffer) {<br/>    return parseLiteral(buffer, "null", Null::new);<br/>}<br/><br/>ParseResult parseFalse(char[] buffer) {<br/>    return parseLiteral(buffer, "false", False::new);<br/>}<br/><br/>private ParseResult parseLiteral(char[] buffer, String label, <br/>                                         Supplier&lt;Element&gt; ctor) {<br/>      if (isEOF || isError) return this;<br/><br/>      var pr = advance(buffer, label.length());<br/><br/>      if (!pr.isError &amp;&amp; pr.token(buffer).equals(label))<br/>          return new ParseResult(pr.offset, pr.snapshot, <br/>                  ctor.get(), pr.isEOF, false);<br/>      else return error();<br/> }<br/><br/>private String token(char[] buffer) {<br/>    return new String(buffer, this.snapshot, <br/>        Math.min(this.offset, buffer.length) - this.snapshot);<br/>}</span></pre><p id="c864" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">JSON 中有 3 种文字类型:true、false 和 null。只要用文字长度推进偏移量并检查相应的令牌(从快照到偏移量)是否与字符串匹配就足够了。</p><pre class="lh li lj lk gt na nb nc bn nd ne bi"><span id="6542" class="nf me in nb b be ng nh l np nj">  ParseResult parseString(char[] buffer) {<br/>      if (isEOF || isError) return this;<br/><br/>      return acceptChar(buffer, '"')<br/>              .acceptZeroOrMany(buffer, c -&gt; c != '"')<br/>              .acceptChar(buffer, '"')<br/>              .token(buffer, Str::new);<br/>  }<br/><br/>  ParseResult parseNumber(char[] buffer) {<br/>      if (isEOF || isError) return this;<br/><br/>      var o = this;<br/>      if (o.isChar(buffer, '-')) o = o.acceptChar(buffer, '-');<br/><br/>      if (o.isError || o.isEOF) return error();<br/><br/>      if (o.isChar(buffer, '0')) {<br/>          return o.acceptChar(buffer, '0').token(buffer, Number::new);<br/>      } else if (o.isChar(buffer, Character::isDigit)) {<br/>          o = o.acceptZeroOrMany(buffer, Character::isDigit);<br/>      } else return error();<br/><br/>      if (o.isChar(buffer, '.')) {<br/>          o = o.acceptChar(buffer, '.')<br/>                  .acceptZeroOrMany(buffer, Character::isDigit);<br/>      }<br/><br/>      if (o.isChar(buffer, 'E') || o.isChar(buffer, 'e')) {<br/>          o = o.advance(buffer, 1);<br/>          if (o.isChar(buffer, '-')) {<br/>              o = o.advance(buffer, 1);<br/>          }<br/>          o = o.acceptZeroOrMany(buffer, Character::isDigit);<br/>      }<br/><br/>      return o.token(buffer, Number::new);<br/>  }<br/><br/>  ParseResult token(char[] buffer, Function&lt;String, Element&gt; ctor) {<br/>      if (isError) return this;<br/>      return new ParseResult(offset, snapshot, <br/>              ctor.apply(token(buffer).replace("\"", "")), <br/>              isEOF, false);<br/>  }</span></pre><p id="1ef8" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在我们看到了字符串和数字的更复杂的规则。数字可以是整数，也可以是带可选符号的小数。因此，如果括号是可选的，它应该是这样的:[-]10[.12[e30]]。</p><pre class="lh li lj lk gt na nb nc bn nd ne bi"><span id="943b" class="nf me in nb b be ng nh l np nj"> public static class ParseResult {<br/><br/>        public final int offset;<br/>        public final Element content;<br/>        public final boolean isError;<br/>        public final boolean isEOF;<br/>        private final Map&lt;String, Element&gt; map;  // + <br/>        private final List&lt;Element&gt; list;  // +<br/>        private final int snapshot;<br/>}<br/><br/><br/>ParseResult parseObject(char[] buffer) {<br/>      if (isEOF || isError) return this;<br/><br/>      var o = acceptChar(buffer, '{')<br/>              .acceptZeroOrMany(buffer, Character::isWhitespace);<br/><br/>      if (o.isChar(buffer, '}')) {<br/>          return o.acceptChar(buffer, '}').container(() -&gt; new Object(map));<br/>      }<br/><br/>      o = o.parseMember(buffer, map);<br/><br/>      while (!o.isEOF &amp;&amp; !o.isError &amp;&amp; !o.isChar(buffer, '}')) {<br/>          o = o.acceptChar(buffer, ',').parseMember(buffer, map);<br/>      }<br/>      o = o.acceptChar(buffer, '}');<br/><br/>      return o.container(() -&gt; new Object(map));<br/>  }<br/><br/>  ParseResult parseArray(char[] buffer) {<br/>      if (isEOF || isError) return this;<br/><br/>      var o = acceptChar(buffer, '[')<br/>              .acceptZeroOrMany(buffer, Character::isWhitespace);<br/>      if (o.isChar(buffer, ']')) {<br/>          return o.acceptChar(buffer, ']').container(() -&gt; new Array(list));<br/>      }<br/><br/>      o = o.parseElement(buffer, list);<br/><br/>      while (!o.isEOF &amp;&amp; !o.isError &amp;&amp; !o.isChar(buffer, ']')) {<br/>          o = o.acceptChar(buffer, ',').parseElement(buffer, list);<br/>      }<br/>      return o.acceptChar(buffer, ']').container(() -&gt; new Array(list));<br/>  }<br/><br/>  ParseResult parseElement(char[] buffer, List&lt;Element&gt; list) {<br/>      if (isEOF || isError) return this;<br/><br/>      var o = acceptZeroOrMany(buffer, Character::isWhitespace)<br/>              .element(buffer, ParseResult::new)<br/>              .acceptZeroOrMany(buffer, Character::isWhitespace);<br/>      if (!o.isError &amp;&amp; list != null) list.add(o.content);<br/>      return o;<br/>  }<br/><br/><br/>  ParseResult parseMember(char[] buffer, Map&lt;String, Element&gt; map) {<br/>      if (isEOF || isError) return this;<br/><br/>      String key;<br/>      Element value;<br/><br/>      var o = acceptZeroOrMany(buffer, Character::isWhitespace)<br/>              .snapshot().parseString(buffer);<br/>      key = ((Str) o.content).value;<br/><br/>      o = o.acceptZeroOrMany(buffer, Character::isWhitespace)<br/>              .acceptChar(buffer, ':').parseElement(buffer, null);<br/>      value = o.content;<br/><br/>      if (!o.isError &amp;&amp; map != null) {<br/>          map.put(key, value);<br/>      }<br/>      return o;<br/>  }<br/><br/> ParseResult element(char[] buffer, Function&lt;Integer, ParseResult&gt; offset) {<br/>      if (isError) return this;<br/>      return offset.apply(this.offset).parseValue(buffer);<br/>  }<br/><br/> ParseResult container(Supplier&lt;Element&gt; ctor) {<br/>      if (isError) return this;<br/>      return new ParseResult(offset, snapshot, ctor.get(), isEOF, false);<br/>  }</span></pre><p id="b4f4" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所以对象只是键值对的集合，数组是值的集合。这里的技巧是扩展一个 monad 来保存 Java 列表和映射。剩下的就不言自明了。</p><pre class="lh li lj lk gt na nb nc bn nd ne bi"><span id="d3ad" class="nf me in nb b be ng nh l np nj"> ParseResult parseValue(char[] buffer) {<br/>      if (isEOF || isError) return this;<br/><br/>      return parseTrue(buffer)<br/>              .orElse(parseFalse(buffer))<br/>              .orElse(parseNull(buffer))<br/>              .orElse(parseString(buffer))<br/>              .orElse(parseNumber(buffer))<br/>              .orElse(parseArray(buffer))<br/>              .orElse(parseObject(buffer)).<br/>              orElse(new ParseResult(offset).error());<br/>  }<br/><br/>  public ParseResult orElse(ParseResult other) {<br/>      return isError ? other : this;<br/>  }</span></pre><p id="2171" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">还记得上一个示例中的 parseValue 吗？在这里！现在你可以看到整个语法的递归性。因为元素可以是这些变体中的任何一种，所以容器类型可以在其中嵌套其他容器类型。</p><pre class="lh li lj lk gt na nb nc bn nd ne bi"><span id="8567" class="nf me in nb b be ng nh l np nj"> public Element read(String text) {<br/>    char[] buffer = text.toCharArray();<br/><br/>    var result = new ParseResult(0).parseElement(buffer, null);<br/>    if (result.isError || !result.isEOF) {<br/>        throw new RuntimeException("Json parsing exception");<br/>    }<br/>    return result.content;<br/>}<br/><br/>public String write(Element tree) {<br/>    return switch (tree) {<br/>        case True ignored -&gt; "true";<br/>        case False ignored -&gt; "false";<br/>        case Null ignored -&gt; "null";<br/>        case Number n -&gt; n.value;<br/>        case Str s -&gt; "\"" + s.value + "\"";<br/>        case Array a -&gt; {<br/>            var join = new StringJoiner(",", "[", "]");<br/>            a.elements.forEach(e -&gt; join.add(write(e)));<br/>            yield join.toString();<br/>        }<br/>        case Object o -&gt; {<br/>            var join = new StringJoiner(",", "{", "}");<br/>            o.members.forEach((k, v) -&gt; join.add(k + ":" + write(v)));<br/>            yield join.toString();<br/>        }<br/>        default -&gt; throw new RuntimeException("Unknown tree element");<br/>    };<br/>}</span></pre><p id="b020" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">终于锦上添花了。</p><h1 id="5451" class="md me in bd mf mg nk mi mj mk nl mm mn jt nm ju mp jw nn jx mr jz no ka mt mu bi translated">结论</h1><p id="6efe" class="pw-post-body-paragraph kc kd in ke b kf mv jo kh ki mw jr kk kl mx kn ko kp my kr ks kt mz kv kw kx ig bi translated">就这样，你成功了。这个帖子至少有两个要点。首先，编写解析器非常简单。当然，递归没有在循环中处理令牌那么快，但我认为解决方案的简单性仍然是优势。</p><p id="a879" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">第二个解析器的逻辑有点混乱。但是使用 monad，您可以封装检查并快速失败。那么剩下的逻辑就是调用链接在一起的问题。</p><p id="6911" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你可以在这里获得全部代码<a class="ae ky" href="https://gist.github.com/dgawlik/c4c608e29f4757be8b004d67cc17ce32" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="e26a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">谢谢！</p></div></div>    
</body>
</html>