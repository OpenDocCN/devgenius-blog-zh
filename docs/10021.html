<html>
<head>
<title>Switch from Java to Kotlin in 10 minutes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">10 分钟内从 Java 切换到 Kotlin</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/switch-from-java-to-kotlin-in-15-minutes-5e667c4f8b03?source=collection_archive---------6-----------------------#2022-09-30">https://blog.devgenius.io/switch-from-java-to-kotlin-in-15-minutes-5e667c4f8b03?source=collection_archive---------6-----------------------#2022-09-30</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><h1 id="3201" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">简介:</h1><p id="b0a0" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">当我在 Kotlin 进行第一次技术面试时，我对 Kotlin 一窍不通，但对 Java 已经足够好了。我在最终失败的面试前 15 分钟才意识到这个问题。我真的希望有一篇教程文章来帮助我在 15 分钟内快速学会从 Java 到 Kotlin 的上下文切换。</p><p id="f3fa" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">现在我已经在 Kotlin 工作了 3 年多。这篇文章总结了我在过去 3 年里学到的最关键的区别，以帮助你从 Java 转换到 Kotlin:</p><ol class=""><li id="152a" class="ll lm in kk b kl lg kp lh kt ln kx lo lb lp lf lq lr ls lt bi translated">句法</li><li id="534f" class="ll lm in kk b kl lu kp lv kt lw kx lx lb ly lf lq lr ls lt bi translated">类和接口</li><li id="40f1" class="ll lm in kk b kl lu kp lv kt lw kx lx lb ly lf lq lr ls lt bi translated">希腊字母的第 11 个</li><li id="1614" class="ll lm in kk b kl lu kp lv kt lw kx lx lb ly lf lq lr ls lt bi translated">零安全</li><li id="bbf2" class="ll lm in kk b kl lu kp lv kt lw kx lx lb ly lf lq lr ls lt bi translated">范围功能:<code class="fe lz ma mb mc b">let</code>和<code class="fe lz ma mb mc b">apply</code></li><li id="627c" class="ll lm in kk b kl lu kp lv kt lw kx lx lb ly lf lq lr ls lt bi translated">扩展ˌ扩张</li></ol><h1 id="1b7c" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated"><strong class="ak"> 1。语法:</strong></h1><ol class=""><li id="fedb" class="ll lm in kk b kl km kp kq kt md kx me lb mf lf lq lr ls lt bi translated">类型总是跟在变量名后面</li></ol><p id="cedf" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">与 Java 不同，变量类型总是跟在变量名后面，用冒号<code class="fe lz ma mb mc b">:</code>互相隔开:</p><h2 id="f2d8" class="mg jl in bd jm mh mi dn jq mj mk dp ju kt ml mm jy kx mn mo kc lb mp mq kg mr bi translated">Java 语言(一种计算机语言，尤用于创建网站)</h2><pre class="ms mt mu mv gt mw mc mx my aw mz bi"><span id="8e19" class="mg jl in mc b gy na nb l nc nd">String text = "Hello world";</span></pre><h2 id="1d77" class="mg jl in bd jm mh mi dn jq mj mk dp ju kt ml mm jy kx mn mo kc lb mp mq kg mr bi translated"><strong class="ak">科特林</strong></h2><pre class="ms mt mu mv gt mw mc mx my aw mz bi"><span id="9e68" class="mg jl in mc b gy na nb l nc nd">var text: String = "Hello world"</span></pre><p id="960a" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">没有类型<code class="fe lz ma mb mc b">String</code>它也能工作，因为<code class="fe lz ma mb mc b">"Hello world"</code>被称为<code class="fe lz ma mb mc b">String</code></p><pre class="ms mt mu mv gt mw mc mx my aw mz bi"><span id="990b" class="mg jl in mc b gy na nb l nc nd">var text = "Hello world"</span></pre><p id="4a6f" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">请注意，在该行的末尾不再有<code class="fe lz ma mb mc b">;</code></p><p id="6b8b" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">对于函数声明，变量类型也在变量名之后，返回类型也在函数的末尾。另外，Kotlin 中的函数自带关键字<code class="fe lz ma mb mc b">fun</code>。</p><h2 id="a20c" class="mg jl in bd jm mh mi dn jq mj mk dp ju kt ml mm jy kx mn mo kc lb mp mq kg mr bi translated">Java 语言(一种计算机语言，尤用于创建网站)</h2><pre class="ms mt mu mv gt mw mc mx my aw mz bi"><span id="2bd0" class="mg jl in mc b gy na nb l nc nd">String displayAge(String name, int age) {<br/>  return name + " is " + age " years old.";<br/>}</span></pre><h2 id="6119" class="mg jl in bd jm mh mi dn jq mj mk dp ju kt ml mm jy kx mn mo kc lb mp mq kg mr bi translated">科特林</h2><pre class="ms mt mu mv gt mw mc mx my aw mz bi"><span id="6e29" class="mg jl in mc b gy na nb l nc nd">fun displayAge(name : String, age : Int) : String {<br/>  return name + " is " + age " years old."<br/>}</span></pre><ul class=""><li id="42c5" class="ll lm in kk b kl lg kp lh kt ln kx lo lb lp lf ne lr ls lt bi translated"><code class="fe lz ma mb mc b">val</code>关键字将使你的变量不可变，类似于 Java 中的<code class="fe lz ma mb mc b">final</code></li><li id="ad95" class="ll lm in kk b kl lu kp lv kt lw kx lx lb ly lf ne lr ls lt bi translated"><code class="fe lz ma mb mc b">var</code>关键字使变量可变，可以在初始化后重新赋值</li></ul><pre class="ms mt mu mv gt mw mc mx my aw mz bi"><span id="29ac" class="mg jl in mc b gy na nb l nc nd">var name = "Coding WeiShengSu"<br/>name = "WeiShengSu" // can reassign value after initialization<br/>val text = "this text cannot be updated after initialization"</span></pre><h1 id="cd30" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">2.类别和接口:</h1><p id="d2eb" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">在 Java 中，我们通常会将参数传递给构造函数并保存为最终属性，或者根据给定的参数设置属性，例如:</p><pre class="ms mt mu mv gt mw mc mx my aw mz bi"><span id="e37c" class="mg jl in mc b gy na nb l nc nd">class User {<br/>    private final String firstName;<br/>    private final String lastName;<br/>    public final String fullName;<br/>    public bool isAdmin;</span><span id="54da" class="mg jl in mc b gy nf nb l nc nd"><br/>    public User(String firstName, String lastName, bool isAdmin) {<br/>        this.firstName = firstName;<br/>        this.lastName = lastName;<br/>        fullName = firstName + " " + lastName;<br/>    }<br/>}</span></pre><p id="26da" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">Kotlin 只是通过<code class="fe lz ma mb mc b">val</code>或<code class="fe lz ma mb mc b">var</code>将属性保存在构造函数中。默认值也可以在构造函数中赋值。</p><pre class="ms mt mu mv gt mw mc mx my aw mz bi"><span id="69c2" class="mg jl in mc b gy na nb l nc nd">class User(<br/>  private val firstName:String, <br/>  private val lastName: String,<br/>  val isAdmin: Bool = false<br/>) {<br/>  val fullName: String = firstName + " " + lastName<br/>}</span></pre><p id="23f6" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">类声明非常类似于 Java。代替关键字<code class="fe lz ma mb mc b">implements</code>和<code class="fe lz ma mb mc b">extends</code></p><pre class="ms mt mu mv gt mw mc mx my aw mz bi"><span id="13d9" class="mg jl in mc b gy na nb l nc nd">class Administrator extends User {<br/>  public Administrator(String firstName, String lastName) {<br/>    super(firstName, lastName, true);<br/>  }<br/>}</span></pre><p id="e8be" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">Kotlin 只是简单地使用<code class="fe lz ma mb mc b">:</code>来表示实现一个接口或扩展一个类:</p><pre class="ms mt mu mv gt mw mc mx my aw mz bi"><span id="ee36" class="mg jl in mc b gy na nb l nc nd">class Administrator(<br/>    firstName: String,<br/>    lastName: String<br/>) : User("Admin", "User", true)</span></pre><p id="64f8" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">为了实例化一个类，Java 使用了关键字<code class="fe lz ma mb mc b">new</code>,这个关键字在 Kotlin 中被删除了</p><pre class="ms mt mu mv gt mw mc mx my aw mz bi"><span id="5749" class="mg jl in mc b gy na nb l nc nd">val user = User("Coding", "weishengsu", false)</span></pre><p id="f03d" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">为了实例化一个实现接口的对象，Kotlin 使用<code class="fe lz ma mb mc b">object</code>和<code class="fe lz ma mb mc b">:</code></p><pre class="ms mt mu mv gt mw mc mx my aw mz bi"><span id="fe6f" class="mg jl in mc b gy na nb l nc nd">interface Callback {<br/>  fun onSuccess(results : String)<br/>}</span><span id="0b70" class="mg jl in mc b gy nf nb l nc nd">val callback = object : Callback {<br/>  override fun onSuccess(results : String) {<br/>    // handle results<br/>  }<br/>}</span></pre><h1 id="3379" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">3.λ:</h1><p id="c58c" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">让我们举一个关于网络抓取的例子。通常网络请求函数接受上面定义的<code class="fe lz ma mb mc b">Callback</code>，并发出网络请求。一旦结果回来，就会触发<code class="fe lz ma mb mc b">Callback</code>。</p><p id="1721" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated"><strong class="kk io">获取网络功能</strong></p><pre class="ms mt mu mv gt mw mc mx my aw mz bi"><span id="8e42" class="mg jl in mc b gy na nb l nc nd">// Java<br/>void fetchFromNetwork(Callback callback) {<br/>  // make a network request<br/>  callback.onSuccess(results);<br/>}</span></pre><p id="38dc" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">如果我们没有定义接口<code class="fe lz ma mb mc b">Callback</code>,只是想要一个一次性的函数作为参数，我们也可以在这里用</p><pre class="ms mt mu mv gt mw mc mx my aw mz bi"><span id="9fc6" class="mg jl in mc b gy na nb l nc nd">callback: (results: String) -&gt; Unit)</span></pre><p id="7205" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">这意味着函数接受类型为<code class="fe lz ma mb mc b">String</code>的参数结果并返回<code class="fe lz ma mb mc b">void</code>，在 Kotlin 中是<code class="fe lz ma mb mc b">Unit</code>:</p><pre class="ms mt mu mv gt mw mc mx my aw mz bi"><span id="219c" class="mg jl in mc b gy na nb l nc nd">// Kotlin<br/>fun fetchFromNetwork(callback: Callback) {<br/>  // make a network request<br/>  callback.onSuccess(results)<br/>}</span><span id="542e" class="mg jl in mc b gy nf nb l nc nd">// or </span><span id="50d3" class="mg jl in mc b gy nf nb l nc nd">fun fetchFromNetwork(callback: (results: String) -&gt; Unit)) {<br/>  // make a network request<br/>  callback.onSuccess(results)<br/>}</span></pre><p id="1182" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">客户端用一个新的<code class="fe lz ma mb mc b">Callback</code>对象调用函数<code class="fe lz ma mb mc b">fetchFromNetwork</code>:</p><pre class="ms mt mu mv gt mw mc mx my aw mz bi"><span id="8866" class="mg jl in mc b gy na nb l nc nd">// Java:<br/>fetchFromNetwork(new Callback() {<br/>    @Override<br/>    public void onSuccess(String results) {<br/>        // handle the results, maybe update the UI with the data<br/>        updateUi(results);<br/>    }<br/>});</span></pre><ol class=""><li id="00ba" class="ll lm in kk b kl lg kp lh kt ln kx lo lb lp lf lq lr ls lt bi translated">Kotlin 中的等效方法调用非常相似，但是将实例化调用<code class="fe lz ma mb mc b">new Callback() { ... }</code>替换为<code class="fe lz ma mb mc b">object : Callback { ... }</code></li></ol><pre class="ms mt mu mv gt mw mc mx my aw mz bi"><span id="5949" class="mg jl in mc b gy na nb l nc nd">// Kotlin<br/>fetchFromNetwork(object : Callback {<br/>    @Override<br/>    fun onSuccess(results : String) {<br/>        // handle the results, maybe update the UI with the data<br/>        updateUi(results)<br/>    }<br/>})</span></pre><p id="f1df" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">2.Lambda 替换回调接口</p><p id="e066" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">因为回调接口中只有一个函数，所以我们可以将<code class="fe lz ma mb mc b">object : Callback { ... }</code>及其覆盖方法<code class="fe lz ma mb mc b">onSuccess</code>简化为一个 lamba，只用于<code class="fe lz ma mb mc b">onSuccess</code>的实现:</p><p id="883e" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated"><code class="fe lz ma mb mc b">{ arguments -&gt; body of the function }</code></p><pre class="ms mt mu mv gt mw mc mx my aw mz bi"><span id="c148" class="mg jl in mc b gy na nb l nc nd">// Kotlin<br/>fetchFromNetwork({ results : String -&gt;<br/>     // handle the results, maybe update the UI with the data<br/>     updateUi(results)<br/>})</span></pre><p id="de14" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">3.<code class="fe lz ma mb mc b">it</code>是默认参数</p><p id="de48" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">如果不指定参数名<code class="fe lz ma mb mc b">results</code>，参数默认为<code class="fe lz ma mb mc b">it</code></p><pre class="ms mt mu mv gt mw mc mx my aw mz bi"><span id="f191" class="mg jl in mc b gy na nb l nc nd">// Kotlin<br/>fetchFromNetwork({ <br/>     // handle the results, maybe update the UI with the data<br/>     updateUi(it)<br/>})</span></pre><p id="229b" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">4.删除括号</p><p id="4e60" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">更简单的是，lambda 可以移出括号:</p><pre class="ms mt mu mv gt mw mc mx my aw mz bi"><span id="6801" class="mg jl in mc b gy na nb l nc nd">fetchFromNetwork {<br/>     // handle the results, maybe update the UI with the data<br/>     updateUi(it)<br/>}</span></pre><p id="3fe3" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">这种模式在科特林很常见。举几个例子:</p><p id="930a" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated"><strong class="kk io"> forEachIndexed </strong></p><p id="9143" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">参数<code class="fe lz ma mb mc b">{ index : Int, name : String -&gt; iteration body }</code>是一个函数<code class="fe lz ma mb mc b">action</code>，它接受索引和类型<code class="fe lz ma mb mc b">T</code>并返回<code class="fe lz ma mb mc b">Unit</code>:</p><pre class="ms mt mu mv gt mw mc mx my aw mz bi"><span id="2c9a" class="mg jl in mc b gy na nb l nc nd">val names = listOf("Coding", "WeiShengSu", "John", "Susan")</span><span id="3d74" class="mg jl in mc b gy nf nb l nc nd">names.forEachIndexed { index, name -&gt;<br/>  println(name + " is at position " + index)<br/>}</span></pre><p id="7979" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated"><strong class="kk io">过滤器</strong></p><p id="15f1" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">参数<code class="fe lz ma mb mc b">{ name: String -&gt; iteration body returns Boolean }</code></p><p id="42d5" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">是一个接受类型<code class="fe lz ma mb mc b">T</code>并返回<code class="fe lz ma mb mc b">Boolean</code>的谓词，指示对象是否需要过滤。<code class="fe lz ma mb mc b">filter</code>函数将返回列表中匹配谓词条件的所有对象:</p><pre class="ms mt mu mv gt mw mc mx my aw mz bi"><span id="1ef3" class="mg jl in mc b gy na nb l nc nd">fun &lt;T&gt; Iterable&lt;T&gt;.filter(predicate: (T) -&gt; Boolean): List&lt;T&gt;</span></pre><p id="6c30" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">下面是调用<code class="fe lz ma mb mc b">filter</code>函数的例子。</p><pre class="ms mt mu mv gt mw mc mx my aw mz bi"><span id="d33d" class="mg jl in mc b gy na nb l nc nd">val names = listOf("Coding", "WeiShengSu", "John", "", "Susan")</span><span id="69d4" class="mg jl in mc b gy nf nb l nc nd">val notEmptyNames = names.filter { name -&gt;<br/>  return@filter name.isNotEmpty()<br/>}</span></pre><p id="d0b1" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">因为 lambda 在另一个函数中被调用，我们需要<code class="fe lz ma mb mc b">@filter</code>标签来指定 lambda 的返回，而不是其他函数的返回。</p><p id="b07b" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated"><strong class="kk io">最后一行是 lambda </strong>中的返回值</p><p id="0aea" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">因为默认情况下 lambda 的最后一行是返回值，我们可以简单地删除<code class="fe lz ma mb mc b">return@filter</code>来使之超级干净</p><pre class="ms mt mu mv gt mw mc mx my aw mz bi"><span id="53f7" class="mg jl in mc b gy na nb l nc nd">val notEmptyNames = names.filter { name -&gt;<br/>  name.isNotEmpty()<br/>}</span></pre><h2 id="4810" class="mg jl in bd jm mh mi dn jq mj mk dp ju kt ml mm jy kx mn mo kc lb mp mq kg mr bi translated">4.空、可空、非空和空安全</h2><figure class="ms mt mu mv gt nh gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/b371cab3eccfb550fe12ba078ec961cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:840/format:webp/0*6GjnEvIIN2cdCyOh.png"/></div></figure><p id="d3c9" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">在 Java 中，有这么多的<code class="fe lz ma mb mc b">object != null</code>检查、<code class="fe lz ma mb mc b">@Nullable</code>、<code class="fe lz ma mb mc b">@Nonnull</code>来防止 lint、编译器或者单元测试的空指针异常。</p><p id="1877" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">关键字<code class="fe lz ma mb mc b">?</code>能够处理各种空的情况</p><p id="fac4" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated"><strong class="kk io">可空</strong></p><p id="8295" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">任何带有<code class="fe lz ma mb mc b">?</code>的变量类型都意味着可以为空，例如:<code class="fe lz ma mb mc b">String?</code> <code class="fe lz ma mb mc b">Int?</code> <code class="fe lz ma mb mc b">User?</code></p><pre class="ms mt mu mv gt mw mc mx my aw mz bi"><span id="9555" class="mg jl in mc b gy na nb l nc nd">var user: User? = null // variable user can be null</span></pre><p id="a11d" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">对于函数，参数或返回类型也可以为空</p><pre class="ms mt mu mv gt mw mc mx my aw mz bi"><span id="686a" class="mg jl in mc b gy na nb l nc nd">fun getUserName(user: User?) : String?</span></pre><p id="76b3" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">对于<code class="fe lz ma mb mc b">&lt; NullableType? &gt;</code>中的类型，它也可以为空</p><ul class=""><li id="23e7" class="ll lm in kk b kl lg kp lh kt ln kx lo lb lp lf ne lr ls lt bi translated"><code class="fe lz ma mb mc b">List&lt;String?&gt;</code>列表不可为空，但是列表的元素可以为空</li><li id="dc61" class="ll lm in kk b kl lu kp lv kt lw kx lx lb ly lf ne lr ls lt bi translated"><code class="fe lz ma mb mc b">List&lt;String&gt;?</code>列表可以为空，但列表的元素不可为空</li></ul><p id="aced" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated"><strong class="kk io">空检查</strong>T11】</p><p id="b058" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">为了访问可空变量的属性，我们使用安全的调用操作符<code class="fe lz ma mb mc b">?.</code>，这在调用链中非常有用</p><pre class="ms mt mu mv gt mw mc mx my aw mz bi"><span id="2848" class="mg jl in mc b gy na nb l nc nd">// Java<br/>final Result result = fetchForResults();</span><span id="574b" class="mg jl in mc b gy nf nb l nc nd">if (result != null &amp;&amp;<br/>    result.status != null &amp;&amp;<br/>    result.status.code != null ) {<br/>    println(result.status.code);<br/>}</span></pre><p id="77da" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">我们可以用<code class="fe lz ma mb mc b">?.</code>链接所有可空的属性</p><pre class="ms mt mu mv gt mw mc mx my aw mz bi"><span id="98f0" class="mg jl in mc b gy na nb l nc nd">if (result?.status?.code? != null) {<br/>  println(result?.status?.code)<br/>}</span></pre><p id="0a10" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated"><strong class="kk io">猫王操作员</strong>T14】</p><p id="e753" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">如果变量为空，那么我们给变量赋予默认值，否则使用变量值:</p><pre class="ms mt mu mv gt mw mc mx my aw mz bi"><span id="778e" class="mg jl in mc b gy na nb l nc nd">// Java</span><span id="46b8" class="mg jl in mc b gy nf nb l nc nd">int len;<br/>if (list != null) {<br/>  len = list.size();<br/>} else {<br/>  len = 0;<br/>}</span></pre><p id="8c29" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated"><code class="fe lz ma mb mc b">?:</code>如果为空，帮助您指定默认值:</p><pre class="ms mt mu mv gt mw mc mx my aw mz bi"><span id="7252" class="mg jl in mc b gy na nb l nc nd">// Kotlin</span><span id="d8bf" class="mg jl in mc b gy nf nb l nc nd">val len = list?.size() ?: 0</span></pre><p id="0dd4" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated"><code class="fe lz ma mb mc b">?:</code>对于函数中的提前返回或者为空时抛出异常非常有用</p><pre class="ms mt mu mv gt mw mc mx my aw mz bi"><span id="0531" class="mg jl in mc b gy na nb l nc nd">fun foo(user: User?): String? {<br/>    val parent = user?.getParent() ?: return null<br/>    val name = user?.getName() ?: throw IllegalArgumentException("name expected")<br/>    // handle non-null parent and name<br/>}</span></pre><p id="2649" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated"><strong class="kk io">安全施放</strong></p><p id="6b87" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated"><code class="fe lz ma mb mc b">as?</code>帮你投给给定的职业。如果对象不是给定类的实例，它就返回 null</p><pre class="ms mt mu mv gt mw mc mx my aw mz bi"><span id="cc74" class="mg jl in mc b gy na nb l nc nd">fun getUserName(obj: Any): String? {<br/>  val user = obj as? User<br/>  if (user == null) {<br/>    return null  // handle when the object is not instance of User<br/>  } else {<br/>    return user.name<br/>  }<br/>}</span></pre><p id="7706" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">或者通过<code class="fe lz ma mb mc b">?.</code>简化</p><pre class="ms mt mu mv gt mw mc mx my aw mz bi"><span id="d2c8" class="mg jl in mc b gy na nb l nc nd">fun getUserName(obj: Any): String? {<br/>  return (obj as? User)?.name<br/>}</span></pre><h1 id="42b2" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">5.范围函数 let 和<code class="fe lz ma mb mc b">apply</code></h1><p id="c477" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">我发现大多数情况下可以通过<code class="fe lz ma mb mc b">let</code>和<code class="fe lz ma mb mc b">apply</code>来实现。如果您对其他范围功能感兴趣，如<code class="fe lz ma mb mc b">run</code>、<code class="fe lz ma mb mc b">with</code>和<code class="fe lz ma mb mc b">also</code>，您可以在这里找到更多详细信息<a class="ae nk" href="https://kotlinlang.org/docs/scope-functions.html" rel="noopener ugc nofollow" target="_blank"/></p><p id="72ff" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated"><strong class="kk io">让</strong></p><p id="bd0a" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated"><code class="fe lz ma mb mc b">let{ variableName -&gt; }</code>对非空对象执行 lambda 并返回最后一行，以上例为结果状态:</p><pre class="ms mt mu mv gt mw mc mx my aw mz bi"><span id="c2e1" class="mg jl in mc b gy na nb l nc nd">// Java<br/>final Result result = fetchForResults();</span><span id="fb87" class="mg jl in mc b gy nf nb l nc nd">if (result != null &amp;&amp;<br/>    result.status != null &amp;&amp;<br/>    result.status.code != null ) {<br/>    println(result.status.code);<br/>}</span></pre><p id="7edb" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">我们实际上可以用 lambda <code class="fe lz ma mb mc b">let</code>来链接:</p><pre class="ms mt mu mv gt mw mc mx my aw mz bi"><span id="276f" class="mg jl in mc b gy na nb l nc nd">result?.status?.code?.let { code -&gt; <br/>  println(code)<br/>}</span></pre><p id="011c" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">不指定变量名<code class="fe lz ma mb mc b">code</code>:</p><pre class="ms mt mu mv gt mw mc mx my aw mz bi"><span id="4332" class="mg jl in mc b gy na nb l nc nd">result?.status?.code?.let { println(it) }</span></pre><p id="e500" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated"><strong class="kk io">应用</strong></p><p id="a056" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated"><code class="fe lz ma mb mc b">apply</code>也执行 lambda，但是使用<code class="fe lz ma mb mc b">this</code>来访问对象。它还返回了对象<code class="fe lz ma mb mc b">this</code>。<code class="fe lz ma mb mc b">apply</code>当我们试图在同一个对象上设置一堆属性或方法时，这非常有用:</p><pre class="ms mt mu mv gt mw mc mx my aw mz bi"><span id="9152" class="mg jl in mc b gy na nb l nc nd">// Java<br/>User user = new User();<br/>user.age = 20;<br/>user.name = "WeiShengSu"<br/>user.grantPermission();</span></pre><p id="502c" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">其中在同一个对象上设置了几个属性<code class="fe lz ma mb mc b">user</code>:</p><pre class="ms mt mu mv gt mw mc mx my aw mz bi"><span id="afed" class="mg jl in mc b gy na nb l nc nd">val user = User().apply {<br/>  this.age = 20 <br/>  this.name = "WeiShengSu"<br/>  this.grantPermission()<br/>}</span></pre><p id="11eb" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">或者我们甚至可以简化没有<code class="fe lz ma mb mc b">this</code></p><pre class="ms mt mu mv gt mw mc mx my aw mz bi"><span id="dcd8" class="mg jl in mc b gy na nb l nc nd">val user = User().apply {<br/>  age = 20 <br/>  name = "WeiShengSu"<br/>  grantPermission()<br/>}</span></pre><h1 id="b340" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">6.扩展:</h1><p id="09b4" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">Kotlin 能够通过称为<em class="nl">扩展的特殊修饰来扩展类/接口的功能。</em>要声明一个扩展函数，在它的类名或接口名前面加上<code class="fe lz ma mb mc b">.</code>和方法名:</p><pre class="ms mt mu mv gt mw mc mx my aw mz bi"><span id="9e0d" class="mg jl in mc b gy na nb l nc nd">// Java<br/>// This method will return the last Element of given list<br/>// return null if the list is empty</span><span id="99c0" class="mg jl in mc b gy nf nb l nc nd">public static String getLastElementOrNull(List&lt;String&gt; texts) {<br/>  if (texts.size() == 0) {<br/>    return null;<br/>  }<br/>  return texts.get(texts.size() - 1);<br/>}</span><span id="dcee" class="mg jl in mc b gy nf nb l nc nd">// To call the function:<br/>String lastElement = getLastElementOrNull(texts);</span></pre><p id="fc41" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">在扩展函数中，我们可以通过可选关键字<code class="fe lz ma mb mc b">this</code>直接访问公共属性或方法:</p><pre class="ms mt mu mv gt mw mc mx my aw mz bi"><span id="cd9d" class="mg jl in mc b gy na nb l nc nd">fun List&lt;String&gt;.getLastElementOrNull() : String? {<br/>  if (this.size() == 0) {<br/>    return null<br/>  }<br/>  return get(this.size() - 1)<br/>}</span></pre><p id="71da" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">一旦我们声明了扩展函数，所有的<code class="fe lz ma mb mc b">List&lt;String&gt;</code>都有我们刚刚在上面声明的这个函数:</p><pre class="ms mt mu mv gt mw mc mx my aw mz bi"><span id="546f" class="mg jl in mc b gy na nb l nc nd">val texts: List&lt;String&gt; = listOf("WeiShengSu")</span><span id="adc9" class="mg jl in mc b gy nf nb l nc nd">// To cal the function:<br/>val lastElement = texts.getLastElementOrNull()</span></pre><p id="901d" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">更酷的是，类类型可以为空，例如:</p><pre class="ms mt mu mv gt mw mc mx my aw mz bi"><span id="ad51" class="mg jl in mc b gy na nb l nc nd">// Java, if it is a null number, just return string "null"<br/>public static String convertToString(@Nullable Integer number) {<br/>  if (number == null) return "null";<br/>  return number.toString();<br/>}</span></pre><p id="a78f" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">在这种情况下，用<code class="fe lz ma mb mc b">Int?</code>声明扩展函数:</p><pre class="ms mt mu mv gt mw mc mx my aw mz bi"><span id="013b" class="mg jl in mc b gy na nb l nc nd">fun Int?.convertToString() {<br/>  if (this == null) return "null"<br/>  return this.toString()<br/>}</span></pre><p id="9d80" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">或者更简单:</p><pre class="ms mt mu mv gt mw mc mx my aw mz bi"><span id="b6fd" class="mg jl in mc b gy na nb l nc nd">fun Int?.convertToString() {<br/>  return this?.toString() ?: "null"<br/>}</span></pre><p id="dedc" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">在这种情况下，我们甚至可以在一个可空的 Int ( <code class="fe lz ma mb mc b">Int?</code>)上调用这个扩展，而不需要<code class="fe lz ma mb mc b">?</code>检查:</p><pre class="ms mt mu mv gt mw mc mx my aw mz bi"><span id="322a" class="mg jl in mc b gy na nb l nc nd">val number : Int? = getNumberSomewhere() // maybe nullable number<br/>val textNumber : String = number.convertToString()</span></pre><h1 id="bb1f" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">7.结论</h1><p id="26e9" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">希望这些主题能帮助您快速从 Java 切换到 Kotlin。</p><p id="354a" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">还有几个话题和 Java 不一样。但是如果你读到这里，你应该能够理解，阅读和用 Kotlin 写一些代码。其余的差异应该很简单，或者可以通过专门的谷歌搜索快速发现。</p><p id="a586" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">请跟随，鼓掌并在下面留下你的评论</p></div></div>    
</body>
</html>