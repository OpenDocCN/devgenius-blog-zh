<html>
<head>
<title>React Lifecycle</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应生命周期</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/react-lifecycle-a91848dfc0d0?source=collection_archive---------6-----------------------#2020-10-01">https://blog.devgenius.io/react-lifecycle-a91848dfc0d0?source=collection_archive---------6-----------------------#2020-10-01</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><h1 id="31ee" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">概观</h1><p id="c418" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">在 react 中，组件有三个阶段:<a class="ae lg" href="https://reactjs.org/docs/react-component.html#mounting" rel="noopener ugc nofollow" target="_blank">挂载</a>、<a class="ae lg" href="https://reactjs.org/docs/react-component.html#updating" rel="noopener ugc nofollow" target="_blank">更新</a>和<a class="ae lg" href="https://reactjs.org/docs/react-component.html#unmounting" rel="noopener ugc nofollow" target="_blank">卸载</a>。<a class="ae lg" href="https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/" rel="noopener ugc nofollow" target="_blank">反应生命周期图</a></p><h1 id="3e44" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">增加</h1><p id="834e" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">挂载阶段是创建组件并将其插入 DOM 的阶段。此阶段依次调用的方法有:</p><h2 id="9f91" class="lh jl in bd jm li lj dn jq lk ll dp ju kt lm ln jy kx lo lp kc lb lq lr kg ls bi translated"><a class="ae lg" href="https://reactjs.org/docs/react-component.html#constructor" rel="noopener ugc nofollow" target="_blank">构造函数()</a></h2><p id="46a7" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">constructor()方法在挂载之前被调用。没有必要定义构造函数方法。通常，构造函数方法用于初始化状态和/或绑定方法。如果组件接受 props，那么在定义方法时它应该是一个参数。道具不应该复制成状态。此外，构造函数不应调用 setState()。</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="19fd" class="lh jl in ly b gy mc md l me mf">constructor(props) {<br/>   super(props); // Necessary to access props in constructor<br/>  this.state = { counter: 0 };<br/>  this.handleClick = this.handleClick.bind(this);<br/>}</span></pre><h2 id="561d" class="lh jl in bd jm li lj dn jq lk ll dp ju kt lm ln jy kx lo lp kc lb lq lr kg ls bi translated"><a class="ae lg" href="https://reactjs.org/docs/react-component.html#render" rel="noopener ugc nofollow" target="_blank"> render() </a></h2><p id="788b" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">render()方法是类组件唯一需要的方法。渲染方法查看组件状态和属性，并返回以下内容之一:</p><ul class=""><li id="ae22" class="mg mh in kk b kl mi kp mj kt mk kx ml lb mm lf mn mo mp mq bi translated">React 元素——典型的 html 标签，如<div>或 react 组件<component/></div></li><li id="0039" class="mg mh in kk b kl mr kp ms kt mt kx mu lb mv lf mn mo mp mq bi translated">数组和<a class="ae lg" href="https://reactjs.org/docs/fragments.html" rel="noopener ugc nofollow" target="_blank">片段</a> —呈现多个元素</li><li id="dfb1" class="mg mh in kk b kl mr kp ms kt mt kx mu lb mv lf mn mo mp mq bi translated"><a class="ae lg" href="https://reactjs.org/docs/portals.html" rel="noopener ugc nofollow" target="_blank">门户</a> —在不同的 DOM 子树中呈现孩子</li><li id="4581" class="mg mh in kk b kl mr kp ms kt mt kx mu lb mv lf mn mo mp mq bi translated">字符串和数字—典型文本</li><li id="a7f7" class="mg mh in kk b kl mr kp ms kt mt kx mu lb mv lf mn mo mp mq bi translated">布尔值或空值—不呈现任何内容。例如:返回布尔&amp;&amp; <div/></li></ul><h2 id="eb68" class="lh jl in bd jm li lj dn jq lk ll dp ju kt lm ln jy kx lo lp kc lb lq lr kg ls bi translated"><a class="ae lg" href="https://reactjs.org/docs/react-component.html#componentdidmount" rel="noopener ugc nofollow" target="_blank">componentidmount()</a></h2><p id="9032" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">组件挂载后会立即调用 componentDidMount()方法。需要 DOM 节点或 API 调用的初始化应该用这个方法。您可以在此设置订阅，但请确保在 componentWillUnmount()中取消订阅。虽然您可以在此方法中调用 setState()，但它会触发额外的 render()方法调用。</p><h1 id="8b80" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">更新</h1><p id="f7e3" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">更新阶段是道具或状态改变的时候。此阶段依次调用的方法有:</p><h2 id="d1bc" class="lh jl in bd jm li lj dn jq lk ll dp ju kt lm ln jy kx lo lp kc lb lq lr kg ls bi translated"><a class="ae lg" href="https://reactjs.org/docs/react-component.html#render" rel="noopener ugc nofollow" target="_blank">渲染()</a></h2><p id="e4d7" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">与挂载阶段的 render()方法相同。</p><h2 id="302e" class="lh jl in bd jm li lj dn jq lk ll dp ju kt lm ln jy kx lo lp kc lb lq lr kg ls bi translated"><a class="ae lg" href="https://reactjs.org/docs/react-component.html#componentdidupdate" rel="noopener ugc nofollow" target="_blank"> componentDidUpdate() </a></h2><p id="ff3c" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">如果组件状态或属性有任何变化，componentDidMount()将被立即调用。初始渲染时不会调用它。如果你使用这个方法，确保你有一个条件语句，否则它将陷入无限循环。</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="29e9" class="lh jl in ly b gy mc md l me mf">componentDidUpdate(prevProps) {<br/>    // Usually compare props with previous props<br/>    if (this.props.id !== prevProps.id) {<br/>        this.getUser(this.props.userID);<br/>    }<br/>}</span></pre><h1 id="372b" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">卸载</h1><p id="f1c7" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">卸载阶段是从 DOM 中删除组件的时候。此阶段调用的唯一方法是:</p><h2 id="ebe4" class="lh jl in bd jm li lj dn jq lk ll dp ju kt lm ln jy kx lo lp kc lb lq lr kg ls bi translated"><a class="ae lg" href="https://reactjs.org/docs/react-component.html#componentwillunmount" rel="noopener ugc nofollow" target="_blank"> componentWillUnmount() </a></h2><p id="8466" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">在卸载组件之前，立即调用 componentWillUnmount()方法。这是进行任何必要清理的地方，如使计时器无效、取消订阅和取消网络请求。您不应该在此方法中调用 setState()，因为它将不会在到达此点后呈现。</p><h1 id="c523" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">结论</h1><p id="a643" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">在 React 的旧版本中，每个阶段调用更多的生命周期和方法。上面列出的方法是最常用的方法。任何没有列出的方法都被认为是遗留的或者不是通用的生命周期。</p></div></div>    
</body>
</html>