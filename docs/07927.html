<html>
<head>
<title>Model View Controller Family</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">模型视图控制器系列</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/model-view-controller-family-3a0d869d81ea?source=collection_archive---------2-----------------------#2022-05-04">https://blog.devgenius.io/model-view-controller-family-3a0d869d81ea?source=collection_archive---------2-----------------------#2022-05-04</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="637d" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">MVC，MVP，MVVM 有什么区别。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/8d5d00784ec5801cf47f889a0fc7f12c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*KPhSSY3hCDQSBVAIVP6Fmw.gif"/></div></div></figure><p id="a689" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">模型视图控制器通常用于开发用户界面。它将相关的程序逻辑分成三个独立但又相互联系的部分。这允许游戏的不同方面彼此分离，允许我们回到单一责任。目前，这种模式有几种不同的实现方式:传统的模型视图控制器(MVC)、模型视图呈现器(MVP)和模型视图视图模型(MVVM)。三者都使用基本概念，措辞略有不同，交流方式也略有不同。</p><h1 id="fdeb" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">传统模型视图控制器(MVC)</h1><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mc"><img src="../Images/bb09547073e5deca5f966c5b98e1d198.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YRL-_4UjueNU8WxWWlOVBA.png"/></div></div><figcaption class="md me gj gh gi mf mg bd b be z dk translated">传统模型视图控制器(MVC)</figcaption></figure><ol class=""><li id="d3bb" class="mh mi in kq b kr ks ku kv kx mj lb mk lf ml lj mm mn mo mp bi translated">模型——商业逻辑，或者在游戏开发中，游戏逻辑。</li><li id="7bb8" class="mh mi in kq b kr mq ku mr kx ms lb mt lf mu lj mm mn mo mp bi translated">视图—用户看到的内容。这负责格式化和渲染。它观察模型并对变更事件做出响应(观察者模式)。</li><li id="367a" class="mh mi in kq b kr mq ku mr kx ms lb mt lf mu lj mm mn mo mp bi translated">控制器——控制用户与游戏/应用交互的方式。接受用户输入并更新模型。</li></ol><h1 id="a4d7" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">模型视图演示者(MVP)</h1><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mv"><img src="../Images/3162068cf8acc4c20307672f0173f17a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R0PHERdk5H-xyvYzrRh0Yw.png"/></div></div><figcaption class="md me gj gh gi mf mg bd b be z dk translated">模型视图演示者(MVP)</figcaption></figure><p id="30b5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这是通常在 Unity 和一些 web HTML 中使用的。这和 MVC 的最大区别是责任被转移了，我们有一个演示者而不是一个控制者。最大的原因是因为我们不能对视图做太多，渲染是在内部或幕后处理的。我们可以用 Unity 的 UI 系统改变游戏中元素的渲染，该系统内置了与视图交互的事件，获取输入事件。</p><ol class=""><li id="6021" class="mh mi in kq b kr ks ku kv kx mj lb mk lf ml lj mm mn mo mp bi translated">视图—用户看到的内容(呈现)并接受用户的输入。由演示者更新，并将输入事件发送给演示者。Unity 已经在为我们做这件事了。</li><li id="7ae4" class="mh mi in kq b kr mq ku mr kx ms lb mt lf mu lj mm mn mo mp bi translated">Presenter 响应来自视图的输入事件(观察者模式)，并根据接收到的输入事件更新模型(输入处理)。当一个 On Change 事件来自模型(观察者模式)时，它也更新视图(格式)。</li><li id="204d" class="mh mi in kq b kr mq ku mr kx ms lb mt lf mu lj mm mn mo mp bi translated">模型——游戏逻辑由演示者控制。向演示者发送更改事件(观察者模式)。</li></ol><h1 id="9a0e" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">模型视图视图模型(MVVM)</h1><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mw"><img src="../Images/4f38531d117f436b307c02c025f5f9da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*79lUhSbnODHPHsqRtPeitw.png"/></div></div><figcaption class="md me gj gh gi mf mg bd b be z dk translated">模型视图视图模型(MVVM)</figcaption></figure><p id="b1f3" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果使用新的 UI，则在 Unity 中使用。当用 UXML 构造 UI 时，也在一些 Windows 窗体应用程序和 Web 应用程序中使用</p><p id="9c1e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这与 MVP 是一样的，唯一的区别是我们有一个视图模型，而不是一个演示者。视图和视图模型通过数据绑定进行通信。</p><ol class=""><li id="26be" class="mh mi in kq b kr ks ku kv kx mj lb mk lf ml lj mm mn mo mp bi translated">视图—用户看到的内容，并接受用户的输入。由 ViewModel 更新，并通过数据绑定将输入事件发送到 ViewModel。</li><li id="a52f" class="mh mi in kq b kr mq ku mr kx ms lb mt lf mu lj mm mn mo mp bi translated">ViewModel 用于视图和模型之间的通信。使用数据绑定与视图通信。Model On Change 事件将导致绑定到视图的变量更新。当视图中的一个输入绑定发生变化时，绑定到它的一个变量也发生变化，然后视图将更新模型。</li><li id="cb7e" class="mh mi in kq b kr mq ku mr kx ms lb mt lf mu lj mm mn mo mp bi translated">模型——游戏逻辑由视图模型控制。在更改事件时发送 ViewModel a(观察者模式)。</li></ol><h1 id="ad48" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">结论</h1><p id="339c" class="pw-post-body-paragraph ko kp in kq b kr mx jo kt ku my jr kw kx mz kz la lb na ld le lf nb lh li lj ig bi translated">MVC——模型游戏逻辑从控制器中处理的视图逻辑和输入逻辑中分离出来。</p><p id="46a7" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">MVP——MVC 的发展。演示者处理输入逻辑和视图逻辑。视图更加被动，只处理渲染和事件管理。</p><p id="cbff" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">MVVM —类似于 MVP，但是在视图和视图模型之间使用绑定。</p><p id="1095" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">互联网上有大量关于模型-视图-控制器模式的文章。这种模式一开始对我来说很难理解，直到我意识到 MVC、MVP 和 MVVM 都是同样的模式。它们之间的区别在于，它们是如何基于您正在使用的系统中的限制来实际实现的。了解这一点，如果您正在使用 Unity 并且已经实现了 MVP，并且希望在使用 UXML 的项目中使用新的 UI 系统，您所要做的就是将 Presenter 复制为 ViewModel，然后使用绑定在视图和视图模型之间进行通信。</p></div></div>    
</body>
</html>