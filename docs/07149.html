<html>
<head>
<title>Kotlin SpringBoot App in Minikube Windows Cluster</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Minikube Windows 集群中的 Kotlin SpringBoot 应用程序</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/kotlin-springboot-app-in-minikube-windows-cluster-c5269e3f88fb?source=collection_archive---------13-----------------------#2022-03-01">https://blog.devgenius.io/kotlin-springboot-app-in-minikube-windows-cluster-c5269e3f88fb?source=collection_archive---------13-----------------------#2022-03-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="07db" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个简单的教程中，我们将看到在 Minikube 中运行 SpringBoot Kotlin 应用程序的每个步骤。我花了 2 /3 个小时在本地运行一切，我希望我开始时有一个这样的作战计划。所以在这里，希望有所帮助。我将只关注 Windows 操作系统，但我认为 Linux 主机的过程应该非常相似。</p><ul class=""><li id="70a7" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated">1-先决条件</li><li id="29fd" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">2- Kotlin 应用程序</li><li id="b7d8" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">三容器图像</li><li id="58ad" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">4 支 k8 部署</li><li id="2ca0" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">5-结论</li></ul><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi kz"><img src="../Images/6bf8cb2d3c25bdc9e56891cda95e2d83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3Y3s-xxc6aWF-eO8"/></div></div><figcaption class="ll lm gj gh gi ln lo bd b be z dk translated">Marek Piwnicki 在<a class="ae lp" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="babf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意:过几天我会继续这篇文章。我将展示如何在 Minikube 中运行、配置和使用 Kafka 集群。我还将提供从代理向 Kotlin 应用程序发送和接收消息所需的样板配置，反之亦然。</p><h1 id="4a98" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">1-先决条件</h1><blockquote class="mo mp mq"><p id="579b" class="jn jo mr jp b jq jr js jt ju jv jw jx ms jz ka kb mt kd ke kf mu kh ki kj kk ij bi translated"><strong class="jp ir">码头工人</strong></p></blockquote><p id="61aa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下载并安装<a class="ae lp" href="https://desktop.docker.com/win/main/amd64/Docker%20Desktop%20Installer.exe" rel="noopener ugc nofollow" target="_blank">安装程序。</a>(注意:如果您的管理员帐户不同于您的用户帐户，您必须在安装后将用户添加到 docker-users 组中)</p><blockquote class="mo mp mq"><p id="ac84" class="jn jo mr jp b jq jr js jt ju jv jw jx ms jz ka kb mt kd ke kf mu kh ki kj kk ij bi translated"><strong class="jp ir">库贝克特尔</strong></p></blockquote><pre class="la lb lc ld gt mv mw mx my aw mz bi"><span id="142e" class="na lr iq mw b gy nb nc l nd ne">$curl -LO “<a class="ae lp" href="https://dl.k8s.io/v1.23.0/bin/windows/amd64/kubectl.exe.sha256%22" rel="noopener ugc nofollow" target="_blank">https://dl.k8s.io/v1.23.0/bin/windows/amd64/kubectl.exe.sha256"</a></span></pre><p id="8152" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将下载的可执行文件放在一个文件夹中。将该文件夹放到“%PATH%”环境变量中。(我一直用同一个目录“C:\script”。在那里，我有大量的批处理工具和脚本。这样，我就不必每次都为路径添加新的目录..这也适用于可执行文件的链接(？)).</p><blockquote class="mo mp mq"><p id="9d10" class="jn jo mr jp b jq jr js jt ju jv jw jx ms jz ka kb mt kd ke kf mu kh ki kj kk ij bi translated"><strong class="jp ir"> Minikube </strong></p></blockquote><p id="9fa0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果没有 WGET，<a class="ae lp" href="https://www.gnu.org/software/wget/" rel="noopener ugc nofollow" target="_blank">安装 WGET </a>:</p><pre class="la lb lc ld gt mv mw mx my aw mz bi"><span id="eec8" class="na lr iq mw b gy nb nc l nd ne">$ wget install minikube</span></pre><p id="aa64" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在所有这些安装之后，你可能需要几次非常无聊的重启。之后，您应该可以运行:</p><pre class="la lb lc ld gt mv mw mx my aw mz bi"><span id="05eb" class="na lr iq mw b gy nb nc l nd ne">$ minikube start</span></pre><p id="1761" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">并成功地输出令人惊叹的消息。</p><h1 id="93df" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">2- Kotlin 应用程序</h1><p id="a07e" class="pw-post-body-paragraph jn jo iq jp b jq nf js jt ju ng jw jx jy nh ka kb kc ni ke kf kg nj ki kj kk ij bi translated">从<a class="ae lp" href="https://start.spring.io/" rel="noopener ugc nofollow" target="_blank">https://start.spring.io/</a>生成 SpringBoot Kotlin 应用程序。选择 Kotlin 和 Gradle 作为构建工具。此外，您应该添加 spring-boot-starter-web 依赖项。下载可执行文件并解压。</p><p id="810c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们必须向代码中添加一个简单的控制器。这个端点会用“hello world”这种无聊的句子来回答。没什么创意，我知道，我知道。</p><pre class="la lb lc ld gt mv mw mx my aw mz bi"><span id="798d" class="na lr iq mw b gy nb nc l nd ne">import org.springframework.web.bind.annotation.GetMapping<br/>import org.springframework.web.bind.annotation.RestController</span><span id="8844" class="na lr iq mw b gy nk nc l nd ne">@RestController<br/>class OrderController {</span><span id="109a" class="na lr iq mw b gy nk nc l nd ne">  @GetMapping(“/”)<br/>  fun home(): String {<br/>    return “Hello World”<br/>  }</span><span id="876c" class="na lr iq mw b gy nk nc l nd ne">}</span></pre><p id="f7dc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在项目的根目录下运行下面的命令，生成 build/libs/ <artifact-name>。冲突</artifact-name></p><pre class="la lb lc ld gt mv mw mx my aw mz bi"><span id="f623" class="na lr iq mw b gy nb nc l nd ne"><em class="mr">$ ./gradlew clean build</em></span></pre><p id="f358" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果一切顺利，你应该会发现它就在那里，和一个“plain.jar”工件在一起。这是作为独立服务器运行应用程序所需的没有依赖性的 jar。我们不需要那个罐子。将以下代码片段添加到“gradle.build.kts”文件中以将其移除:</p><pre class="la lb lc ld gt mv mw mx my aw mz bi"><span id="df0d" class="na lr iq mw b gy nb nc l nd ne">tasks.getByName&lt;Jar&gt;(“jar”) {<br/>   enabled = false<br/>}</span></pre><p id="1b36" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">太好了。在新的“干净构建”之后，我们应该在 lib 目录中只有正确的 jar。</p><h1 id="777a" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">三容器图像</h1><p id="e293" class="pw-post-body-paragraph jn jo iq jp b jq nf js jt ju ng jw jx jy nh ka kb kc ni ke kf kg nj ki kj kk ij bi translated">我们需要实际提供应用程序的 Dockerfile。(我认为，在特性中，docker 图像将被标准化，并在所选框架本身中提供。已经有一个自动的<a class="ae lp" href="https://github.com/cloud66-oss/starter" rel="noopener ugc nofollow" target="_blank"> Dockerfile 生成器</a>可以自动检测你需要的图片，并根据你的需要构建 docker 文件。好主意！).</p><p id="f903" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这种情况下，我使用 OpenJDK-17 作为基础映像。注意，这个映像的构建并不包括工件本身的构建，但是可以将这个阶段作为一个额外的前一步。</p><pre class="la lb lc ld gt mv mw mx my aw mz bi"><span id="4811" class="na lr iq mw b gy nb nc l nd ne">FROM openjdk:17-jdk-alpine</span><span id="41f4" class="na lr iq mw b gy nk nc l nd ne">ARG JAR_FILE=build/libs/*.jar</span><span id="8e44" class="na lr iq mw b gy nk nc l nd ne">COPY ${JAR_FILE} app.jar</span><span id="138f" class="na lr iq mw b gy nk nc l nd ne">ENTRYPOINT [“java”, “-jar”, “/app.jar”]</span></pre><p id="23e4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为 Minikube 应用程序中需要这个映像，所以在实际构建映像之前，我们必须在 PowerShell 中运行它，具体命令如下:<br/><strong class="jp ir"><em class="mr">&lt;&lt;&lt;</em></strong><em class="mr">我建议从</em><a class="ae lp" href="https://aka.ms/pscore6" rel="noopener ugc nofollow" target="_blank"><em class="mr">https://aka.ms/pscore6</em></a><em class="mr">—它带来了</em> <strong class="jp ir"> <em class="mr">性能改进和几个新特性&gt; &gt; &gt; </em> </strong> <em class="mr"/></p><pre class="la lb lc ld gt mv mw mx my aw mz bi"><span id="75ac" class="na lr iq mw b gy nb nc l nd ne">$ minikube docker-env | Invoke-Expression</span></pre><p id="82e5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae lp" href="https://stackoverflow.com/questions/52310599/what-does-minikube-docker-env-mean" rel="noopener ugc nofollow" target="_blank"> Minikube docker-env </a>指令返回一组变量。这些变量将帮助您的 docker CLI(您在其中编写 docker 命令)与 minikube 创建的 VM 中的 docker 守护进程连接！</p><p id="e376" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们实际上可以构建图像了(在同一个 shell 中！):</p><pre class="la lb lc ld gt mv mw mx my aw mz bi"><span id="a156" class="na lr iq mw b gy nb nc l nd ne">$ docker build — no-cache -t order-ms:0.0.1 .</span></pre><h1 id="15f9" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">4 支 k8 部署</h1><p id="c5af" class="pw-post-body-paragraph jn jo iq jp b jq nf js jt ju ng jw jx jy nh ka kb kc ni ke kf kg nj ki kj kk ij bi translated">最后，我们可以开始考虑 Minikube 内部的实际部署。让我们使用刚刚创建的映像生成一个部署文件，将端口 8080 公开为容器端口:</p><pre class="la lb lc ld gt mv mw mx my aw mz bi"><span id="3439" class="na lr iq mw b gy nb nc l nd ne">$ kubectl create deployment order — image=order-ms:0.0.1 — replicas=2 -o yaml — dry-run=client — port=8080 &gt; order.yaml</span></pre><p id="e5d2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你会在 CWD 里面找到<strong class="jp ir"> order.yaml </strong>文件。通过将 ImagePullPolicy 添加到 IfNotPresent 来编辑该文件:</p><pre class="la lb lc ld gt mv mw mx my aw mz bi"><span id="419b" class="na lr iq mw b gy nb nc l nd ne">...<br/>spec:<br/>   containers:<br/>   - image: order-ms:0.0.5<br/>     imagePullPolicy: IfNotPresent<br/>     name: order-ms<br/>     ports:<br/>     - containerPort: 8080</span></pre><p id="629e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这样，我们可以使用刚刚构建的本地映像。</p><p id="fda9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好吧。此时，我们可以应用部署:</p><pre class="la lb lc ld gt mv mw mx my aw mz bi"><span id="67ed" class="na lr iq mw b gy nb nc l nd ne">$ kubectl apply -f order.yaml</span></pre><p id="2da1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">要真正触及 Kotlin 应用程序内的端点，它位于 Docker 容器内，位于 Kubernetes POD 内，位于 Minikube 应用程序集群内的 k8s 集群内…这有点棘手(你别说！？).但是我们没有失去信心。</strong></p><p id="72d2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们需要创建一个 Kubernetes 服务:</p><pre class="la lb lc ld gt mv mw mx my aw mz bi"><span id="026d" class="na lr iq mw b gy nb nc l nd ne">$ kubectl expose deployment order — type=LoadBalancer — port=8080 — dry-run=client -o yaml &gt; load-bal.yaml</span><span id="fc99" class="na lr iq mw b gy nk nc l nd ne">$ kubectl apply -f load-bal.yaml</span></pre><p id="942e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">(是的，实际生成 YAML 文件总是更好，这样你就可以轻松地对它们进行版本化或编辑)</p><p id="e995" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">太好了。现在我们必须到达终点。但是怎么做呢？</p><p id="11b2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们跑:</p><pre class="la lb lc ld gt mv mw mx my aw mz bi"><span id="8f9a" class="na lr iq mw b gy nb nc l nd ne">$ kubectl get svc</span></pre><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi nl"><img src="../Images/dab82bdc7c8bf7e12ae9c00eacae0c2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*TnUpbZuxqy3nM0D8"/></div></div></figure><p id="2062" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，订单负载平衡器没有外部 IP，因为它仍处于<pending>状态。像这样，从外面是不可能到达那个终点的。</pending></p><p id="a44b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">需要做的是打开一个额外的 shell 并运行:</p><pre class="la lb lc ld gt mv mw mx my aw mz bi"><span id="149f" class="na lr iq mw b gy nb nc l nd ne">$ minikube tunnel</span></pre><p id="82ea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个命令为所有 k8s 名称空间中的所有负载平衡器服务打开一个隧道。再次运行以下命令:</p><pre class="la lb lc ld gt mv mw mx my aw mz bi"><span id="a71d" class="na lr iq mw b gy nb nc l nd ne">$ kubectl get svc</span></pre><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi nm"><img src="../Images/1a87fb26862660958764823804f68319.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*efICnY8V9dInCGmo"/></div></div></figure><p id="6add" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里是我们要到达的终点和港口。外部 IP +端口字符串的左边部分(127.0.0.1:8080)</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/f5600ac13d5704f2098923a19ae95272.png" data-original-src="https://miro.medium.com/v2/resize:fit:652/0*hVhOVwtjTcxkHw83"/></div></figure><h1 id="40da" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">结论</h1><p id="e4a7" class="pw-post-body-paragraph jn jo iq jp b jq nf js jt ju ng jw jx jy nh ka kb kc ni ke kf kg nj ki kj kk ij bi translated">我们已经看到了如何在运行 Minikube 的 Kubernetes 集群中配置运行基于 Kotlin 的 SpringBoot 应用程序所需的一切。在下一篇文章中:在 Minikube 中运行、配置和使用 Kafka 集群。使用 Kotlin 应用程序接收和消费卡夫卡信息。</p><p id="bd16" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">感谢你的阅读，如果你想点击订阅！</p><p id="db4c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但前提是你愿意。我是说真的。</p></div></div>    
</body>
</html>