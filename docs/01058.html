<html>
<head>
<title>The Command Pattern in Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java中的命令模式</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/the-command-pattern-in-java-8a545a56d68a?source=collection_archive---------3-----------------------#2020-06-23">https://blog.devgenius.io/the-command-pattern-in-java-8a545a56d68a?source=collection_archive---------3-----------------------#2020-06-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="3d77" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">权威指南</h2><div class=""/><div class=""><h2 id="58cf" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">命令模式是一种行为设计模式，是GoF正式设计模式列表的一部分。该模式旨在将执行给定动作(命令)所需的所有数据封装在一个对象中</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/fc8b5fa8bddb32d2271fa05caeeb4b2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SFcwg86IPHy1GHWFhXwxKA.jpeg"/></div></div></figure><h1 id="0dde" class="la lb iq bd lc ld le lf lg lh li lj lk kf ll kg lm ki ln kj lo kl lp km lq lr bi translated">介绍</h1><p id="8833" class="pw-post-body-paragraph ls lt iq lu b lv lw ka lx ly lz kd ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">你现在很可能已经知道了行为模式。行为模式是关于Java对象连接的问题。虽然大约有12种属于行为模式的设计模式，但是命令模式占据了它特殊的位置，因为它比其他模式使用得更频繁。订单设计背后的动机是<strong class="lu ja">分离</strong>命令及其消费者之间的基本原理。</p><p id="ed99" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">命令模式的关键部分是<strong class="lu ja">将</strong>所有与命令相关的数据封装在一个对象中。通常，这是通过一组方法、它们的参数以及这些方法所属的一个或多个被称为<strong class="lu ja">接收器</strong>的对象来完成的。所以关于解耦的重要一点是，如果你必须改变这些值中的任何一个，你只需要改变一个类。</p><p id="6985" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">在经典版本中，实现命令模式包括五个步骤。</p><ul class=""><li id="a48b" class="mt mu iq lu b lv mo ly mp mb mv mf mw mj mx mn my mz na nb bi translated"><strong class="lu ja">命令</strong>接口:这通常被声明为执行命令的单一方法。</li><li id="2f7f" class="mt mu iq lu b lv nc ly nd mb ne mf nf mj ng mn my mz na nb bi translated"><strong class="lu ja"> ConcreteCommand </strong>:这是一个带有参数的操作，将调用传递给接收者；在传统方法中，一个命令只调用一个<em class="nh">接收者</em>的一个或多个方法，而不是执行业务逻辑。</li><li id="c09a" class="mt mu iq lu b lv nc ly nd mb ne mf nf mj ng mn my mz na nb bi translated">接受者<strong class="lu ja"/>:尤其知道如何执行动作。</li><li id="b1cc" class="mt mu iq lu b lv nc ly nd mb ne mf nf mj ng mn my mz na nb bi translated"><strong class="lu ja">调用者</strong>:要求命令执行请求。</li><li id="d37b" class="mt mu iq lu b lv nc ly nd mb ne mf nf mj ng mn my mz na nb bi translated"><strong class="lu ja">客户端</strong>:创建<strong class="lu ja">具体命令</strong>对象，设置<em class="nh">接收者</em>。</li></ul><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/4f2cd73dcbbb2f4a6cd7b60792b37151.png" data-original-src="https://miro.medium.com/v2/resize:fit:1328/format:webp/0*mBh909T8YekVHIyv.jpg"/></div></figure><h1 id="0a05" class="la lb iq bd lc ld le lf lg lh li lj lk kf ll kg lm ki ln kj lo kl lp km lq lr bi translated">命令模式的示例</h1><p id="cf66" class="pw-post-body-paragraph ls lt iq lu b lv lw ka lx ly lz kd ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">假设你要建立一个家庭自动化系统，你需要打开和关闭供暖系统。这两个命令在很大程度上是相似的。我们可以创建一个名为<code class="fe nj nk nl nm b">Command</code>的接口，它只有一个名为<code class="fe nj nk nl nm b">execute()</code>的方法。</p><pre class="kp kq kr ks gt nn nm no np aw nq bi"><span id="4bc7" class="nr lb iq nm b gy ns nt l nu nv">public interface Command {<br/>    void execute();<br/>}</span></pre><p id="7376" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">我们现在将创建两个实现<code class="fe nj nk nl nm b">Command</code>接口的类。这些具体的类封装了命令执行两个命令所需的数据，即<em class="nh">加热开启</em>和<em class="nh">加热关闭</em>。</p><p id="5ddd" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">首先。<code class="fe nj nk nl nm b">HeatingOnCommand</code>将实现<code class="fe nj nk nl nm b">Command</code>接口。</p><pre class="kp kq kr ks gt nn nm no np aw nq bi"><span id="2adc" class="nr lb iq nm b gy ns nt l nu nv">public class HeatingOnCommand implements Command {<br/> <br/>    private HeatingSystem heatingSystem;<br/> <br/>    public HeatingOnCommand(HeatingSystem heatingSystem) {<br/>        this.heatingSystem = heatingSystem;<br/>    }<br/> <br/>    @Override<br/>    public void execute() {<br/>        heatingSystem.heatOn();<br/>    }<br/>}</span></pre><p id="4868" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">接下来，<code class="fe nj nk nl nm b">HeatingOffCommand</code>将实现<code class="fe nj nk nl nm b">Command</code>接口。<code class="fe nj nk nl nm b">HeatingOffCommand</code>基本上和<code class="fe nj nk nl nm b">HeatingOnCommand</code>的代码一样。</p><pre class="kp kq kr ks gt nn nm no np aw nq bi"><span id="8dc8" class="nr lb iq nm b gy ns nt l nu nv">public class HeatingOffCommand implements Command {<br/> <br/>    private HeatingSystem heatingSystem;<br/> <br/>    public HeatingOffCommand(HeatingSystem heatingSystem) {<br/>        this.heatingSystem = heatingSystem;<br/>    }<br/> <br/>    @Override<br/>    public void execute() {<br/>        heatingSystem.heatOff();<br/>    }<br/>}</span></pre><p id="782b" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">接下来，我们将创建我们的<em class="nh">接收器</em>类，它是这里的<code class="fe nj nk nl nm b">HeatingSystem</code>类</p><pre class="kp kq kr ks gt nn nm no np aw nq bi"><span id="4a2f" class="nr lb iq nm b gy ns nt l nu nv">public class HeatingSystem  {<br/> <br/>    public void heatOn() {<br/>        System.out.println("Turn on heat");<br/>    }<br/> <br/>    public void heatOff() {<br/>        System.out.println("Turn off heat");<br/>    }<br/>}</span></pre><p id="0c0d" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">接下来，我们需要要求<strong class="lu ja">调用者类</strong>。invoker类决定如何执行命令。例如，调用者可以保存一个需要以特定顺序执行的命令列表。</p><p id="3417" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">我们在这里将invoker类命名为<code class="fe nj nk nl nm b">Controller</code>。</p><pre class="kp kq kr ks gt nn nm no np aw nq bi"><span id="3d0e" class="nr lb iq nm b gy ns nt l nu nv">public class Controller {<br/> <br/>    private Command command;<br/> <br/>    public void setCommand(Command command) {<br/>        this.command = command;<br/>    }<br/> <br/>    public void executeCommand() {<br/>        command.execute();<br/>    }<br/>}</span></pre><p id="7e96" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">最后，我们的客户端或<code class="fe nj nk nl nm b">main</code>方法将使用调用者来执行命令。</p><pre class="kp kq kr ks gt nn nm no np aw nq bi"><span id="658b" class="nr lb iq nm b gy ns nt l nu nv">public class HomeHeatingSystemAutomation {<br/> <br/>    public static void main(String[] args) {<br/> <br/>        Controller controller = new Controller();<br/>        HeatingSystem heatingSystem = new HeatingSystem();<br/> <br/>        Command heatOn = new HeatingOnCommand(light);<br/>        Command heatOff = new HeatingOffCommand(light);<br/> <br/>        controller.setCommand(heatOn);<br/>        controller.executeCommand();<br/> <br/>        controller.setCommand(heatOff);<br/>        controller.executeCommand();<br/>    }<br/>}</span></pre><p id="3481" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">基本上，main方法中有三个重要步骤。</p><ol class=""><li id="2907" class="mt mu iq lu b lv mo ly mp mb mv mf mw mj mx mn nw mz na nb bi translated">从invoker类创建一个对象，在我们的应用程序中是<code class="fe nj nk nl nm b">Controller</code>。</li><li id="4ebd" class="mt mu iq lu b lv nc ly nd mb ne mf nf mj ng mn nw mz na nb bi translated">从我们将要执行的命令中创建对象。</li><li id="3846" class="mt mu iq lu b lv nc ly nd mb ne mf nf mj ng mn nw mz na nb bi translated">使用调用程序执行命令。</li></ol><p id="4ef4" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">可能还需要其他步骤来支持这三个主要步骤。例如，这个<code class="fe nj nk nl nm b">main()</code>方法创建了一个<code class="fe nj nk nl nm b">HeatingSystem</code>对象，因为需要传递一个<code class="fe nj nk nl nm b">HeatingSystem</code>对象来创建<code class="fe nj nk nl nm b">Command</code>对象。当您执行这段代码时，将产生以下输出。</p><h1 id="203f" class="la lb iq bd lc ld le lf lg lh li lj lk kf ll kg lm ki ln kj lo kl lp km lq lr bi translated">附加选项</h1><p id="cf3b" class="pw-post-body-paragraph ls lt iq lu b lv lw ka lx ly lz kd ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">命令模式可以与以下选项一起使用:</p><ul class=""><li id="89ae" class="mt mu iq lu b lv mo ly mp mb mv mf mw mj mx mn my mz na nb bi translated">将命令添加到队列中以便以后执行；</li><li id="c77a" class="mt mu iq lu b lv nc ly nd mb ne mf nf mj ng mn my mz na nb bi translated">支持撤消/重做操作；</li><li id="80fe" class="mt mu iq lu b lv nc ly nd mb ne mf nf mj ng mn my mz na nb bi translated">存储命令的历史；</li><li id="5971" class="mt mu iq lu b lv nc ly nd mb ne mf nf mj ng mn my mz na nb bi translated">序列化命令以将它们存储在磁盘上；</li></ul><p id="9341" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">这些选项对于模式来说并不重要，但在实践中经常使用。</p><h1 id="f8ea" class="la lb iq bd lc ld le lf lg lh li lj lk kf ll kg lm ki ln kj lo kl lp km lq lr bi translated">结论</h1><p id="293b" class="pw-post-body-paragraph ls lt iq lu b lv lw ka lx ly lz kd ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">命令模式的主要优点是它将调用操作的对象与知道如何执行操作的对象分离开来。这种模式的各种修改可以用来保存请求的历史，实现撤销功能和创建宏命令。然而，应用程序可能会变得更加复杂，因为这种模式增加了另一个抽象层。</p></div></div>    
</body>
</html>