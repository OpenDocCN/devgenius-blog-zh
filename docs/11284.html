<html>
<head>
<title>A Smarter Min Max Chess AI in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 中更聪明的最小最大国际象棋人工智能</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/a-smarter-min-max-chess-ai-in-python-224be62c385c?source=collection_archive---------2-----------------------#2022-12-30">https://blog.devgenius.io/a-smarter-min-max-chess-ai-in-python-224be62c385c?source=collection_archive---------2-----------------------#2022-12-30</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="1557" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">欢迎来到我的 Python 象棋教程系列的第 3 部分！在本教程中，我们将扩展并改进第 2 部分中简单的最小最大算法。让我们开始吧！</p><p id="85ab" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">第一部分:<a class="ae ki" href="https://medium.com/dev-genius/simple-interactive-chess-gui-in-python-c6d6569f7b6c" rel="noopener">https://medium . com/dev-genius/simple-interactive-chess-GUI-in-python-c 6d 6569 f 7 b 6 c</a></p><p id="d017" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">第二部分:<a class="ae ki" href="https://medium.com/dev-genius/simple-min-max-chess-ai-in-python-2910a3602641" rel="noopener">https://medium . com/dev-genius/simple-min-max-chess-ai-in-python-2910 a 3602641</a></p></div><div class="ab cl kj kk hr kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="ig ih ii ij ik"><p id="ed3e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">以下是我们将在第 2 部分中改进的主要问题:</p><ul class=""><li id="c37b" class="kq kr in jm b jn jo jr js jv ks jz kt kd ku kh kv kw kx ky bi translated">增加一本打开的书来弥补最小最大深度的不足</li><li id="93ea" class="kq kr in jm b jn kz jr la jv lb jz lc kd ld kh kv kw kx ky bi translated">在人工智能中实现赢/平/输条件</li><li id="b1d9" class="kq kr in jm b jn kz jr la jv lb jz lc kd ld kh kv kw kx ky bi translated">提炼什么是通过占空间的想法做出好的举动</li></ul></div><div class="ab cl kj kk hr kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="ig ih ii ij ik"><pre class="le lf lg lh gt li lj lk bn ll lm bi"><span id="b5a0" class="ln lo in lj b be lp lq l lr ls">import chess.polyglot<br/>import chess<br/><br/>BOARD = chess.Board()<br/>#opening book<br/>reader = chess.polyglot.open_reader('baron30.bin')<br/><br/>#search the opening book for this game state<br/>opening_move = reader.get(BOARD)<br/><br/>#if no move is found<br/>if opening_move == None:<br/>    move = None<br/>#if move is found<br/>else:<br/>    move = opening_move.move<br/><br/>print(move)</span></pre><p id="1068" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们的第一个代码块向我们展示了如何使用 chess 模块实现一本打开的书。我用的是男爵开书，详情可以在这里找到(<a class="ae ki" href="https://www.chessprogramming.net/new-version-of-the-baron-v3-43-plus-the-barons-polyglot-opening-book/" rel="noopener ugc nofollow" target="_blank">https://www . chess programming . net/new-version-of-the-Baron-v3-43-plus-the-barons-polyglot-opening-book/</a>)。该代码只是在当前游戏状态中搜索打开的书中的一步棋，并从书中选择最佳的一步棋。</p></div><div class="ab cl kj kk hr kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="ig ih ii ij ik"><pre class="le lf lg lh gt li lj lk bn ll lm bi"><span id="c1d3" class="ln lo in lj b be lp lq l lr ls">#list to store score of each<br/>scores = []<br/>#iterating over the possible moves<br/>for move in moves:<br/>    outcome = temp.outcome()<br/>    #if we not at an endstate<br/>    if outcome == None:<br/>        # we will have code here to deepen our search <br/>        # and return an evaluation of the move<br/>        pass<br/>    #if our move checkmates our opponent<br/>    elif temp.is_checkmate():<br/>        # we return this move as it is our best move<br/>        return move<br/>    # if our move ends in a draw<br/>    else:<br/>        scores.append(0)</span></pre><p id="df89" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们的第二个代码块展示了我们将如何在 Min Max 函数中实现我们的赢/平/输条件。象棋模块有一个非常漂亮的<strong class="jm io">象棋。Board.outcome() </strong>告诉我们是否处于将死/和棋状态的函数。这是用来快速告诉我们停止评估状态，如果我们在一个残局，节省我们的时间，并作出更好的决定。</p></div><div class="ab cl kj kk hr kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="ig ih ii ij ik"><pre class="le lf lg lh gt li lj lk bn ll lm bi"><span id="40d6" class="ln lo in lj b be lp lq l lr ls">def eval_space(BOARD):<br/>    no_moves = len(list(BOARD.legal_moves))<br/><br/>    #this function is always between 0 and 1 so we will never evaluate<br/>    #this as being greater than a pawns value. The 20 value is arbitrary<br/>    #but this number is chosen as it centers value around 0.5<br/>    value = (no_moves/(20+no_moves))<br/>    <br/>    if BOARD.turn == True:<br/>        return value<br/>    else:<br/>        return -value</span></pre><p id="692f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们的第三个代码块是一个二级评估函数。这是需要的，因为对于许多移动来说，可能移动的当前评估是相等的。背后的想法是，在大多数情况下，一个人在一个回合中可能走的步数越多，他的位置就越好(假设材料数量相等)。所以我们简单地将可能的移动次数相加，并通过下面的函数进行计算。</p><figure class="le lf lg lh gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi lt"><img src="../Images/b338aad0be0bd47b046b8d7117764ea5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z63eXMSlhvYiHb7NqJxtDA.png"/></div></div><figcaption class="mb mc gj gh gi md me bd b be z dk translated">空间评价函数</figcaption></figure><p id="89fb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们选择这个函数，因为它受(0，1)限制，并且严格递增。这意味着<em class="mf">值</em>将始终位于 0 和 1 之间，并且随着<em class="mf"> x </em>增加<em class="mf">值</em>也将增加，保持更多可能移动次数将导致更高<em class="mf">值的特性。</em>它还保持了作为第二评估函数的属性，因此它永远不能添加/移除比棋子更多的值。</p><figure class="le lf lg lh gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi mg"><img src="../Images/4625f045d25ccc9bcc89210a73c9524c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JV6k66DAu78sPJm55hkoCw.png"/></div></div><figcaption class="mb mc gj gh gi md me bd b be z dk translated">Y 轴上的值函数和 X 轴上的移动次数。a = 10</figcaption></figure></div><div class="ab cl kj kk hr kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="ig ih ii ij ik"><p id="c29c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有了这三个改进，我们现在可以将它们结合起来，创建一个更好的最小最大算法，如下所示。</p><pre class="le lf lg lh gt li lj lk bn ll lm bi"><span id="6619" class="ln lo in lj b be lp lq l lr ls">import chess<br/>from copy import deepcopy<br/>import random<br/>import chess.polyglot<br/><br/>#opening book<br/>reader = chess.polyglot.open_reader('baron30.bin')<br/><br/>def random_agent(BOARD):<br/>    return random.choice(list(BOARD.legal_moves))<br/><br/>scoring= {'p': -1,<br/>          'n': -3,<br/>          'b': -3,<br/>          'r': -5,<br/>          'q': -9,<br/>          'k': 0,<br/>          'P': 1,<br/>          'N': 3,<br/>          'B': 3,<br/>          'R': 5,<br/>          'Q': 9,<br/>          'K': 0,<br/>          <br/>          }<br/><br/>def eval_board(BOARD):<br/>    score = 0<br/>    pieces = BOARD.piece_map()<br/>    for key in pieces:<br/>        score += scoring[str(pieces[key])]<br/><br/>    return score<br/><br/>def eval_space(BOARD):<br/>    no_moves = len(list(BOARD.legal_moves))<br/><br/>    #this function is always between 0 and 1 so we will never evaluate<br/>    #this as being greater than a pawns value. The 20 value is arbitrary<br/>    #but this number is chosen as it centers value around 0.5<br/>    value = (no_moves/(20+no_moves))<br/>    <br/>    if BOARD.turn == True:<br/>        return value<br/>    else:<br/>        return -value<br/><br/>def min_maxN(BOARD,N):<br/><br/>    opening_move = reader.get(BOARD)<br/>    if opening_move == None:<br/>        pass<br/>    else:<br/>        return opening_move.move<br/><br/>    #generate list of possible moves<br/>    moves = list(BOARD.legal_moves)<br/>    scores = []<br/><br/>    #score each move<br/>    for move in moves:<br/>        #temp allows us to leave the original game state unchanged<br/>        temp = deepcopy(BOARD)<br/>        temp.push(move)<br/><br/>        #here we must check that the game is not over<br/>        outcome = temp.outcome()<br/>        <br/>        #if checkmate<br/>        if outcome == None:<br/>            #if we have not got to the final depth<br/>            #we search more moves ahead<br/>            if N&gt;1:<br/>                temp_best_move = min_maxN(temp,N-1)<br/>                temp.push(temp_best_move)<br/><br/>            scores.append(eval_board(temp))<br/><br/>        #if checkmate<br/>        elif temp.is_checkmate():<br/><br/>            # we return this as best move as it is checkmate<br/>            return move<br/><br/>        # if stalemate<br/>        else:<br/>            #value to disencourage a draw<br/>            #the higher the less likely to draw<br/>            #default value should be 0<br/>            #we often pick 0.1 to get the bot out of loops in bot vs bot<br/>            val = 1000<br/>            if BOARD.turn == True:<br/>                scores.append(-val)<br/>            else:<br/>                scores.append(val)<br/><br/>        #this is the secondary eval function<br/>        scores[-1] = scores[-1] + eval_space(temp)<br/><br/>    if BOARD.turn == True:<br/>        best_move = moves[scores.index(max(scores))]<br/>    else:<br/>        best_move = moves[scores.index(min(scores))]<br/><br/>    return best_move<br/>        <br/># a simple wrapper function as the display only gives one imput , BOARD<br/><br/>def min_max1(BOARD):<br/>    return min_maxN(BOARD,1)<br/><br/>def min_max2(BOARD):<br/>    return min_maxN(BOARD,2)<br/><br/>def min_max3(BOARD):<br/>    return min_maxN(BOARD,3)<br/><br/>def min_max4(BOARD):<br/>    return min_maxN(BOARD,4)<br/></span></pre><p id="1c41" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是它在深度 3 的一个例子</p><figure class="le lf lg lh gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi mh"><img src="../Images/874f4d0ed58afa1dec4edce8abe66630.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*BC_rG3DIJSk99H6TaiSDzw.gif"/></div></div><figcaption class="mb mc gj gh gi md me bd b be z dk translated">最小最大深度 3(黑色)与随机代理(白色)</figcaption></figure><p id="dd74" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们可以看到它很好地打开了中心，并在最后找到了一个巨大的十字交叉将军！不幸的是，深度 3 是我在花费太长时间之前所能合理达到的深度，所以这可能是我下一个需要改进的地方。感谢你完成了我的 3 部分教程！</p><p id="da9c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你想对抗这个 AI，复制最后的代码块并运行我的教程<a class="ae ki" href="https://medium.com/dev-genius/simple-interactive-chess-gui-in-python-c6d6569f7b6c" rel="noopener">第一部分</a>中的<strong class="jm io"> main_one_agent </strong>。</p></div></div>    
</body>
</html>