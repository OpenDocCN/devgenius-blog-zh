<html>
<head>
<title>Road to Genius: advanced #34</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">天才之路:进阶#34</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/road-to-genius-advanced-34-aa5bdb4b5300?source=collection_archive---------33-----------------------#2020-07-16">https://blog.devgenius.io/road-to-genius-advanced-34-aa5bdb4b5300?source=collection_archive---------33-----------------------#2020-07-16</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="05ea" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">每天我都要解决几个Codr分级模式的编码挑战和难题。目标是达到天才的等级，在这个过程中我解释了我是如何解决这些问题的。你不需要任何编程背景就可以开始，而且你会学到很多新的有趣的东西。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/1b275ed4135e3afb13a332dcdcae2b65.png" data-original-src="https://miro.medium.com/v2/resize:fit:582/format:webp/0*eG5ejO-GSHlcrHzy.png"/></div></figure><p id="b7ee" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这个挑战中，我们需要计算出<code class="fe kq kr ks kt b">A</code>的值，它是一个未知函数<code class="fe kq kr ks kt b">LGC</code>的输出，该函数将一组数字作为单个参数。</p><p id="454e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">从第一行开始，我们注意到这个函数只对唯一的数字(没有重复的)感兴趣，因为它将数组转换成一个集合:</p><pre class="kj kk kl km gt ku kt kv kw aw kx bi"><span id="f9c9" class="ky kz in kt b gy la lb l lc ld">nums = new Set(nums)</span></pre><p id="e194" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后使用<code class="fe kq kr ks kt b">forEach</code>方法遍历集合中的每一项，其中<code class="fe kq kr ks kt b">x</code>是数字。</p><p id="d6a9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">它检查<code class="fe kq kr ks kt b">nums</code>是否包含<code class="fe kq kr ks kt b">x-1</code>，如果不包含，则设置<code class="fe kq kr ks kt b">y=x+1</code>。接下来是一个while循环，只要<code class="fe kq kr ks kt b">nums</code>包含<code class="fe kq kr ks kt b">y</code>，它就会将<code class="fe kq kr ks kt b">y</code>递增1。最后设置<code class="fe kq kr ks kt b">max</code>:</p><pre class="kj kk kl km gt ku kt kv kw aw kx bi"><span id="4f7a" class="ky kz in kt b gy la lb l lc ld">max = Math.max(max, y-x)</span></pre><p id="ce17" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你可以用两种方法来解决这个问题，要么你在纸上/电子表格上算出每个数字。这是一个可行的方法，因为你只需要迭代6个数字，所以只需要一两分钟。</p><p id="2237" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是如果这个数组包含50个随机数，那么你需要一个更聪明的方法。诀窍是先搞清楚这个算法在做什么。</p><p id="0739" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里有一些我注意到的事情:我们有变量<code class="fe kq kr ks kt b">x</code>和<code class="fe kq kr ks kt b">y</code>，其中<code class="fe kq kr ks kt b">x</code>保持静态，但是<code class="fe kq kr ks kt b">y</code>增加了1。看起来<code class="fe kq kr ks kt b">x</code>是起点，<code class="fe kq kr ks kt b">y</code>是终点。</p><p id="a275" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后我们有了这条线:</p><pre class="kj kk kl km gt ku kt kv kw aw kx bi"><span id="b6a9" class="ky kz in kt b gy la lb l lc ld">max = Math.max(max, y-x)</span></pre><p id="a987" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这将记录所有数量的<code class="fe kq kr ks kt b">nums</code>中从<code class="fe kq kr ks kt b">x</code>到<code class="fe kq kr ks kt b">y</code>的最大距离。注意，只要<code class="fe kq kr ks kt b">nums</code>包含<code class="fe kq kr ks kt b">y</code>，while循环的条件就是将<code class="fe kq kr ks kt b">y</code>加1。显然，该算法旨在找出<code class="fe kq kr ks kt b">nums</code>中连续数字的最大长度/距离。</p><p id="4a20" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">例:<code class="fe kq kr ks kt b">nums = [1,2,6,7,8,9]</code> <br/>连号最大长度为4 ( <code class="fe kq kr ks kt b">6 -&gt; 9</code>)。</p><p id="3903" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">回到我们的挑战，最大长度是2，唯一最长的连续序列是<code class="fe kq kr ks kt b">1 -&gt; 2</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi le"><img src="../Images/7e7253abca109bd99ba06eebc87d19fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:444/format:webp/0*tCs53gITNmIXKeEK.png"/></div></figure><p id="af0d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">注意，这个算法不需要对输入数组(nums)进行排序，因为如果对它进行了排序，那么这个算法可以编写得更简单一些。</p><p id="4d9c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">通过解决这些挑战，你可以训练自己成为一名更好的程序员。您将学到更新更好的分析、调试和改进代码的方法。因此，你在商业上会更有效率和价值。在<a class="ae lf" href="https://nevolin.be/codr/" rel="noopener ugc nofollow" target="_blank">https://nevolin.be/codr/</a>加入我的天才之路，提升你的编程技能</p></div></div>    
</body>
</html>