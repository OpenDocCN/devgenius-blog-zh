<html>
<head>
<title>Sagas in distributed systems</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">分布式系统中的传奇</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/sagas-in-distributed-systems-e57efef59798?source=collection_archive---------3-----------------------#2021-11-27">https://blog.devgenius.io/sagas-in-distributed-systems-e57efef59798?source=collection_archive---------3-----------------------#2021-11-27</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="ba93" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在分布式系统中，实现事务间的完全隔离是相对昂贵的。系统要么必须为每个事务维护锁，并潜在地阻止其他并发事务取得进展，要么中止一些事务以维护<strong class="jm io">安全</strong>，这导致了一些徒劳的努力。</p><p id="c191" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在处理交易方面能不能做的更好！？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c97365e2e56028f034f3c02f15023d2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ktow7xWFDFyfPBrt"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@goumbik?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">卢卡斯·布拉塞克</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h2 id="2897" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">长期事务</h2><p id="883a" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">长期事务本质上是指持续时间更长的事务，大约是几个小时甚至几天，而不是几毫秒。之所以会发生这种情况，是因为该事务处理大量数据，需要人工输入才能继续，或者需要与速度较慢的第三方系统进行通信。</p><h2 id="a343" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">LLT的例子</h2><ul class=""><li id="30d3" class="lx ly in jm b jn ls jr lt jv lz jz ma kd mb kh mc md me mf bi translated">在大数据集上计算报告的批处理作业</li><li id="45a3" class="lx ly in jm b jn mg jr mh jv mi jz mj kd mk kh mc md me mf bi translated">保险公司的索赔，包含需要人工输入的各个阶段</li><li id="e855" class="lx ly in jm b jn mg jr mh jv mi jz mj kd mk kh mc md me mf bi translated">在线订购产品，从订购到交付需要几天时间</li></ul><p id="d296" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，使用通用并发机制运行这些事务会显著降低<strong class="jm io">性能</strong>,因为它们需要长时间占用资源，而不是对它们进行操作。</p><p id="9fa0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有时，长期事务并不真正需要彼此之间完全<em class="ml">隔离</em>，但它们仍然需要<em class="ml">原子</em>，以便在部分故障下保持<em class="ml">一致性</em>。因此，研究人员提出了一个新概念:传奇故事。</p><h2 id="455f" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">冒险故事</h2><p id="4a5e" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated"><em class="ml"> saga </em>是一个事务序列T1 <em class="ml"> T </em> 1，T2 <em class="ml"> T </em> 2，…，TN<em class="ml">T</em>T<em class="ml">N</em>可以与其他事务交错。然而，保证要么所有的事务都成功，要么没有一个成功，保持<em class="ml">原子性</em>保证。每个事务Ti<em class="ml">T</em>T<em class="ml">I</em>都与所谓的补偿事务Ci<em class="ml">C</em>T<em class="ml">I</em>相关联，在需要回滚的情况下执行该补偿事务</p><h2 id="9712" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">利益</h2><p id="a845" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">传奇事务的概念在分布式系统中非常有用。分布式事务通常很难，只能通过在<em class="ml">性能</em>和<em class="ml">可用性</em>上妥协来实现。</p><p id="4869" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有些情况下，我们可以使用saga事务来代替分布式事务。这将满足我们所有的业务需求，同时保持我们的系统松散耦合，实现良好的<em class="ml">可用性</em>和<em class="ml">性能</em>。</p><h2 id="8e1b" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">奇怪的场景</h2><p id="3021" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">考虑两个并发订单A和B的场景，其中A从仓库中保留了最后一个项目。因此，订单B在第一步就失败了，并且因为零库存而被拒绝。后来，订单A在第二步也失败了，因为顾客的卡没有足够的钱。然后，运行相关的补偿事务，将保留的项目返回到仓库。</p><p id="ac82" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这意味着订单被拒绝，而它本可以被正常处理。当然，这种违反隔离的行为不会产生严重的后果。然而，在某些情况下，后果可能更严重，例如，客户在没有收到产品的情况下被收费。</p><blockquote class="mm mn mo"><p id="1697" class="jk jl ml jm b jn jo jp jq jr js jt ju mp jw jx jy mq ka kb kc mr ke kf kg kh ig bi translated">我们可以通过在应用层提供隔离来解决这个问题</p></blockquote><h2 id="424a" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">语义锁</h2><p id="bb3f" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">语义锁的使用本质上表明一些数据项当前正在处理中，应该被区别对待或者根本不被访问。一个<em class="ml">传奇的最后一个事务</em>负责释放这个锁并将数据重置为正常状态。</p><h2 id="075c" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">交换更新</h2><p id="9d42" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">不管执行顺序如何，使用具有相同效果的可交换更新。这有助于减少容易出现更新丢失现象的情况。</p><h1 id="9335" class="ms la in bd lb mt mu mv le mw mx my lh mz na nb lk nc nd ne ln nf ng nh lq ni bi translated">重新安排传奇的结构</h1><p id="fb4f" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">对saga结构进行重新排序，这样一个被称为<strong class="jm io"> pivot transaction </strong>的事务就在可能失败的事务和不会失败的事务之间划定了一个界限。</p><p id="10e7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">通过这种方式，不能失败但如果由于其他事务的失败而回滚可能导致严重问题的事务可以被移动到<em class="ml"> pivot事务</em>之后。</p><p id="b444" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这方面的一个例子是增加账户余额的交易。如果另一个并发的<em class="ml"> saga </em>读取余额的增加，但随后前一个事务被回滚，则该事务可能会产生严重的后果。将该事务移动到<em class="ml"> pivot事务</em>之后意味着它永远不会回滚，因为只有在<em class="ml"> pivot事务</em>之后的所有事务才能成功。</p></div><div class="ab cl nj nk hr nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="ig ih ii ij ik"><p id="faff" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">正如我前面所说的，事务之间完全<strong class="jm io">隔离</strong>是相对昂贵的，saga是处理这种情况的方法之一，请分享您的想法。</p></div></div>    
</body>
</html>