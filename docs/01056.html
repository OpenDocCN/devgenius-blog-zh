<html>
<head>
<title>Where ngOnDestroy Fails You</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">哪里让你失望了</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/where-ngondestroy-fails-you-54a8c2eca0e0?source=collection_archive---------1-----------------------#2020-06-23">https://blog.devgenius.io/where-ngondestroy-fails-you-54a8c2eca0e0?source=collection_archive---------1-----------------------#2020-06-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/13c19d3a01a89f3517b76f92b25548ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vDZTyWh714lKn3sMFx6jQQ.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">亚历山大·安德鲁斯在<a class="ae kc" href="/s/photos/navigation?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="c2fb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae kc" href="https://angular.io/api/core/OnDestroy" rel="noopener ugc nofollow" target="_blank"> ngOnDestroy </a>是Angular迄今为止最重要的生命周期挂钩之一。它用于取消订阅事件，并在销毁组件/服务之前处理任何拆卸事件。尽管我们对NGO destroy完成这些事情充满信心，但有时候NGO destroy实际上会让你失望。</p><p id="045a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于4个导航事件，将<em class="lb">而不是</em>调用ngOnDestroy:</p><ul class=""><li id="72c1" class="lc ld iq kf b kg kh kk kl ko le ks lf kw lg la lh li lj lk bi translated">页面刷新</li><li id="3fc4" class="lc ld iq kf b kg ll kk lm ko ln ks lo kw lp la lh li lj lk bi translated">关闭选项卡/浏览器</li><li id="b5e0" class="lc ld iq kf b kg ll kk lm ko ln ks lo kw lp la lh li lj lk bi translated">导航到不同的页面</li></ul><p id="6ee6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这些情况下，如果用户执行这些导航事件中的任何一个，运行某些需要保存的指令(比如临时会话状态)将不会被保存。</p><p id="2584" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，让我们假设我们有数据，我们临时存储了<a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Web/API/Window/sessionStorage" rel="noopener ugc nofollow" target="_blank"> sessionStorage </a>对象，我们希望在组件被销毁时保存这些数据。</p><figure class="lq lr ls lt gt jr"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="3f4f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是当我们按F5重新加载页面时会发生什么呢？数据不持久！ngOnDestroy不会被调用，因为当导航到不同的路径时，一些组件不会被破坏。</p><h2 id="0ecb" class="lw lx iq bd ly lz ma dn mb mc md dp me ko mf mg mh ks mi mj mk kw ml mm mn mo bi translated">拯救路由器事件！</h2><p id="f031" class="pw-post-body-paragraph kd ke iq kf b kg mp ki kj kk mq km kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated">我相信你一定知道Angular内部的<a class="ae kc" href="https://angular.io/api/router/Router#events" rel="noopener ugc nofollow" target="_blank">路由器</a>服务。您可以使用这项服务来订阅任何与角度路线和导航相关的内容。</p><p id="fcbe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用这个类，我们可以订阅<a class="ae kc" href="https://angular.io/api/router/Router#events" rel="noopener ugc nofollow" target="_blank"> events </a>变量，这是一个订阅路由器事件的可观察变量。</p><p id="45c0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">订阅可观察事件时，有几种不同的导航周期可供您订阅。其中包括:</p><ul class=""><li id="3ff4" class="lc ld iq kf b kg kh kk kl ko le ks lf kw lg la lh li lj lk bi translated"><strong class="kf ir">导航开始</strong>:导航开始时触发。</li><li id="17ac" class="lc ld iq kf b kg ll kk lm ko ln ks lo kw lp la lh li lj lk bi translated"><strong class="kf ir"> GuardCheckStart </strong>:检查组件的第一个防护(如果有)时触发。</li><li id="cf82" class="lc ld iq kf b kg ll kk lm ko ln ks lo kw lp la lh li lj lk bi translated"><strong class="kf ir"> ActivationStart </strong>:路由的<a class="ae kc" href="https://angular.io/api/router/Resolve" rel="noopener ugc nofollow" target="_blank">解析</a>阶段触发</li></ul><p id="d71d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">注意:</strong>这些周期中的每一个也有它们的结束版本</p><p id="876b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">回到上面的例子，我们可以做两件事:将代码放在事件的订阅者内部，或者在订阅者内部调用ngOnDestroy。</p><figure class="lq lr ls lt gt jr"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="790c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以下是所做的更改:</p><ol class=""><li id="db6f" class="lc ld iq kf b kg kh kk kl ko le ks lf kw lg la mu li lj lk bi translated">将路由器服务注入到类中</li><li id="2ccd" class="lc ld iq kf b kg ll kk lm ko ln ks lo kw lp la mu li lj lk bi translated">订阅ngOnInit内部可观察到的事件</li><li id="a7be" class="lc ld iq kf b kg ll kk lm ko ln ks lo kw lp la mu li lj lk bi translated">在那里调用代码</li></ol><h2 id="5973" class="lw lx iq bd ly lz ma dn mb mc md dp me ko mf mg mh ks mi mj mk kw ml mm mn mo bi translated">外卖食品</h2><p id="b7a5" class="pw-post-body-paragraph kd ke iq kf b kg mp ki kj kk mq km kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated">只有在刷新应用程序或离开应用程序时必须保存数据时，才应使用此方法。在大多数情况下，ngOnDestroy将完成您需要的一切，尤其是在取消订阅事件时。这些代码可以帮助您处理在执行浏览器导航活动时需要调用代码的任何必要情况。</p><p id="ad70" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">希望这有所帮助！</p></div></div>    
</body>
</html>