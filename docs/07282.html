<html>
<head>
<title>Compile-time and runtime polymorphism 101</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编译时和运行时多态性 101</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/beginners-guide-to-compile-time-and-runtime-polymorphism-in-java-72d197862778?source=collection_archive---------3-----------------------#2022-03-11">https://blog.devgenius.io/beginners-guide-to-compile-time-and-runtime-polymorphism-in-java-72d197862778?source=collection_archive---------3-----------------------#2022-03-11</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="c1c2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">本文将帮助您轻松理解编译时多态性和运行时多态性之间的区别。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2ecad81ed4a272d3e36c62c05e113e83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OtcmK1aF9kJUnjuO"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@avivrchmdn?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Aviv Rachmadian </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="6816" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">定义</h1><p id="d8ca" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated"><code class="fe mc md me mf b">define: polymorphism</code></p><p id="dbb1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">多边形+变形=多种形式</strong></p><blockquote class="mg mh mi"><p id="f1c0" class="jk jl mj jm b jn jo jp jq jr js jt ju mk jw jx jy ml ka kb kc mm ke kf kg kh ig bi translated">多态是为不同类型的实体提供一个单一的接口，或者使用一个单一的符号来表示多个不同的类型。</p><p id="1c2f" class="jk jl mj jm b jn jo jp jq jr js jt ju mk jw jx jy ml ka kb kc mm ke kf kg kh ig bi translated">这个概念是从生物学的一个原理借用来的，即一个有机体或物种可以有许多不同的形式或阶段</p></blockquote><h1 id="cf2a" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">Java 程序生命周期</h1><p id="329c" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">在讨论编译时和运行时多态之间的区别之前，让我们先了解一下什么是编译，什么是运行时。</p><p id="1444" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">众所周知，Java 是一种高级语言，我们以人类可读/可理解的格式编写程序，使用定义的语法和语义，遵循定义的规则和规定。但是机器只能理解 1 和 0。那么我们的程序是如何工作的呢？我们来了解一下。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mn"><img src="../Images/5ab730faa49d38eda355611c95eb0ff7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PDfkcSJ_NNmPMiDu9cmimA.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">JDK (Java 开发工具包)——粗糙的架构</figcaption></figure><ol class=""><li id="9cf5" class="mo mp in jm b jn jo jr js jv mq jz mr kd ms kh mt mu mv mw bi translated">我们编写普通的高级 java 程序(例如 HelloWorld.java)</li><li id="e016" class="mo mp in jm b jn mx jr my jv mz jz na kd nb kh mt mu mv mw bi translated">然后我们必须运行<code class="fe mc md me mf b">javac HelloWorld.java</code>将人类可读的代码编译成字节码(HelloWorld.class)</li><li id="49e7" class="mo mp in jm b jn mx jr my jv mz jz na kd nb kh mt mu mv mw bi translated">字节码类似于机器码，但并不完全如此。因为有这么多不同的操作系统，如 Windows，Mac，Linux 等。)很难为每个 OS 生成机器码。因此，我们的编译器生成的字节码被提供给一个虚拟机，它是驻留在 JRE (Java 运行时环境)中的 JVM (Java 虚拟机)。</li><li id="c1d4" class="mo mp in jm b jn mx jr my jv mz jz na kd nb kh mt mu mv mw bi translated">JVM 最终解释字节码，并将其解释给底层操作系统。</li></ol><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nc"><img src="../Images/6aa5573caf17d8224643f305da17d984.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IPKNpGcBN-hJHaaGkBzaXg.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">解释编译时和运行时的流程图</figcaption></figure><ol class=""><li id="0d2a" class="mo mp in jm b jn jo jr js jv mq jz mr kd ms kh mt mu mv mw bi translated"><strong class="jm io">编译期</strong>:当高级 java 程序正在被转换成字节码(。java - &gt;。类)。在这个过程中，编译器检查代码的语法、语义和类型。</li><li id="aa58" class="mo mp in jm b jn mx jr my jv mz jz na kd nb kh mt mu mv mw bi translated"><strong class="jm io">运行时</strong>:机器代码执行时。</li></ol><h1 id="69c4" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">编译时和运行时多态性</h1><p id="2147" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">现在我们对 java 程序的生命周期以及编译和运行时的区别有了一个基本的概念。让我们深入探讨编译时和运行时多态性的主题。</p><h2 id="f81e" class="nd la in bd lb ne nf dn lf ng nh dp lj jv ni nj ln jz nk nl lr kd nm nn lv no bi translated">编译时多态性</h2><blockquote class="mg mh mi"><p id="83d0" class="jk jl mj jm b jn jo jp jq jr js jt ju mk jw jx jy ml ka kb kc mm ke kf kg kh ig bi translated">又称<strong class="jm io">静态多态</strong>。这种类型的多态性只能由编译器解决。我们甚至在运行之前就知道哪些代码块将被执行。</p></blockquote><p id="1122" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在一个类中，可以有几个方法共享相同的名称，但在</p><ol class=""><li id="175b" class="mo mp in jm b jn jo jr js jv mq jz mr kd ms kh mt mu mv mw bi translated">参数类型</li><li id="65e6" class="mo mp in jm b jn mx jr my jv mz jz na kd nb kh mt mu mv mw bi translated">参数数量</li><li id="158f" class="mo mp in jm b jn mx jr my jv mz jz na kd nb kh mt mu mv mw bi translated">方法中声明的参数的顺序</li></ol><p id="c6be" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个概念叫做<strong class="jm io">方法重载</strong>。在这种情况下，在编译时，根据参数类型、参数数量或参数顺序，编译器决定调用哪个方法。</p><p id="5b32" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">此处需要注意的重要事项。</strong></p><blockquote class="mg mh mi"><p id="c58e" class="jk jl mj jm b jn jo jp jq jr js jt ju mk jw jx jy ml ka kb kc mm ke kf kg kh ig bi translated">重载方法可能有也可能没有不同的返回类型。但是返回类型本身不足以让编译器在运行时确定要执行哪个方法。</p></blockquote><p id="2d71" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">举例</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi np"><img src="../Images/6c5d35cbeb8f1c3e0d5cf1e7ef242383.png" data-original-src="https://miro.medium.com/v2/resize:fit:946/format:webp/1*hAONZe3MH1mmPIn5e7yIbA.jpeg"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">编译时多态性示例</figcaption></figure><pre class="kj kk kl km gt nq mf nr ns aw nt bi"><span id="f46b" class="nd la in mf b gy nu nv l nw nx">public class CompileTimeDemo<br/>{<br/>  public static void main(String[] args)<br/>  {<br/>    int result1 = sum(1, 2);<br/>    double result2 = sum(2.5, 3.6);<br/>    int result3 = sum(1, 2, 3);<br/>    double result4 = div(10, 2.5);<br/>    double result5 = div(9.75, 2);</span><span id="b532" class="nd la in mf b gy ny nv l nw nx">    System.out.println("CASE 1 - Parameter type" + <br/>        " result1: " + result1 + <br/>        " result2: " + result2<br/>    );</span><span id="4508" class="nd la in mf b gy ny nv l nw nx">    System.out.println("CASE 2 - Number of parameters" + <br/>        " result1: " + result1 + <br/>        " result3: " + result3<br/>    );</span><span id="5043" class="nd la in mf b gy ny nv l nw nx">    System.out.println("CASE 3 -" + <br/>       " Order of the parameters declared in the method" + <br/>       " result4: " + result4 + <br/>       " result5: " + result5<br/>    );<br/>  }</span><span id="5b55" class="nd la in mf b gy ny nv l nw nx">  // sum for two integer<br/>  public static int sum(int n1, int n2)<br/>  {<br/>    return n1 + n2;<br/>  }<br/>  <br/>  // sum for two double<br/>  public static double sum(double n1, double n2)<br/>  {<br/>    return n1 + n2;<br/>  }<br/>  <br/>  // sum for three integer<br/>  public static int sum(int n1, int n2, int n3)<br/>  {<br/>    return n1 + n2 + n3;<br/>  }<br/>  <br/>  // division for two, order (int, double)<br/>  public static double div(int n1, double n2) {<br/>    return n1 / n2;<br/>  }<br/>  <br/>  // division for two, order (double, int)<br/>  public static double div(double n1, int n2) {<br/>    return n1 / n2;<br/>  }</span><span id="6d82" class="nd la in mf b gy ny nv l nw nx">}</span></pre><p id="641f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这个例子中，我们可以看到方法重载的所有三种情况。</p><h2 id="5264" class="nd la in bd lb ne nf dn lf ng nh dp lj jv ni nj ln jz nk nl lr kd nm nn lv no bi translated">运行时多态性</h2><blockquote class="mg mh mi"><p id="dd45" class="jk jl mj jm b jn jo jp jq jr js jt ju mk jw jx jy ml ka kb kc mm ke kf kg kh ig bi translated">又称<strong class="jm io">动态多态</strong>。这种类型的多态性在运行时得到动态解析。即使在编译之后，我们也不知道哪些代码块将被执行。</p></blockquote><p id="3f4f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当一个子类提供了一个已经存在于它的父类中的方法的特定定义，那么我们称这个概念为<strong class="jm io">方法覆盖</strong>。</p><p id="3b99" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">此处需要注意的重要事项。</strong></p><blockquote class="mg mh mi"><p id="22d0" class="jk jl mj jm b jn jo jp jq jr js jt ju mk jw jx jy ml ka kb kc mm ke kf kg kh ig bi translated">它必须具有相同的名称、相同的参数(类型、长度和顺序)和相同的返回类型</p><p id="7557" class="jk jl mj jm b jn jo jp jq jr js jt ju mk jw jx jy ml ka kb kc mm ke kf kg kh ig bi translated">它不能重写声明为 final 或 static 的方法</p><p id="a11c" class="jk jl mj jm b jn jo jp jq jr js jt ju mk jw jx jy ml ka kb kc mm ke kf kg kh ig bi translated">它不能有更严格的访问修饰符。</p><p id="07d4" class="jk jl mj jm b jn jo jp jq jr js jt ju mk jw jx jy ml ka kb kc mm ke kf kg kh ig bi translated">它可能有一个限制较少的访问修饰符。</p><p id="ee26" class="jk jl mj jm b jn jo jp jq jr js jt ju mk jw jx jy ml ka kb kc mm ke kf kg kh ig bi translated">它必须<em class="in">而不是</em>抛出一个新的或更广泛的检查异常。</p><p id="8401" class="jk jl mj jm b jn jo jp jq jr js jt ju mk jw jx jy ml ka kb kc mm ke kf kg kh ig bi translated">它可能抛出更窄、更少或没有检查的异常。</p><p id="e691" class="jk jl mj jm b jn jo jp jq jr js jt ju mk jw jx jy ml ka kb kc mm ke kf kg kh ig bi translated">重写方法可以引发任何未检查的异常，不管重写方法是否声明了该异常。</p></blockquote><p id="c82c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">示例</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/ca40cdb4be8a4cf1ea461674b5438a15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s0W0KWkraQLcN7LbFprmeQ.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">运行时多态性示例</figcaption></figure><pre class="kj kk kl km gt nq mf nr ns aw nt bi"><span id="0a55" class="nd la in mf b gy nu nv l nw nx">class Crypto{  <br/> double getTotalMarketValue(){return 0;}  <br/>}</span><span id="41bc" class="nd la in mf b gy ny nv l nw nx">class Bitcoin extends Crypto{  <br/> double getTotalMarketValue(){return 826;}  <br/>}</span><span id="9337" class="nd la in mf b gy ny nv l nw nx">class Ethereum extends Crypto{  <br/> double getTotalMarketValue(){return 390;}  <br/>}</span><span id="041c" class="nd la in mf b gy ny nv l nw nx">class BinanceCoin extends Crypto{  <br/> double getTotalMarketValue(){return 79.5;}  <br/>}</span><span id="25d0" class="nd la in mf b gy ny nv l nw nx">class RunTimeDemo {  <br/> public static void main(String args[]){  <br/>    Crypto crypto;  <br/>    crypto = new Bitcoin();  <br/>    System.out.println(<br/>        "Bitcoin Total market value in (Billion $): " + <br/>        crypto.getTotalMarketValue()<br/>    ); <br/> <br/>    crypto = new Ethereum();  <br/>    System.out.println(<br/>        "Ethereum Total market value in (Billion $): " + <br/>        crypto.getTotalMarketValue()<br/>    ); <br/> <br/>    crypto = new BinanceCoin();  <br/>    System.out.println(<br/>        "BinanceCoin Total market value in (Billion $): " + <br/>        crypto.getTotalMarketValue()<br/>    );  <br/> }  <br/>}</span></pre><p id="d0e1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这个例子中，我们可以看到所有的子类，如比特币、以太坊等。正在扩展加密类，然后覆盖<code class="fe mc md me mf b">getTotalMarketValue()</code>方法。</p></div><div class="ab cl oa ob hr oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="ig ih ii ij ik"><p id="6092" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你想了解更多，请浏览这些文档:</p><ol class=""><li id="ad03" class="mo mp in jm b jn jo jr js jv mq jz mr kd ms kh mt mu mv mw bi translated"><a class="ae ky" href="http://www.eeng.dcu.ie/~ee553/ee402notes/html/ch04s02.html" rel="noopener ugc nofollow" target="_blank">http://www.eeng.dcu.ie/~ee553/ee402notes/html/ch04s02.html</a></li><li id="3e83" class="mo mp in jm b jn mx jr my jv mz jz na kd nb kh mt mu mv mw bi translated"><a class="ae ky" href="https://www.baeldung.com/cs/runtime-vs-compile-time" rel="noopener ugc nofollow" target="_blank">https://www.baeldung.com/cs/runtime-vs-compile-time</a></li><li id="4ccc" class="mo mp in jm b jn mx jr my jv mz jz na kd nb kh mt mu mv mw bi translated"><a class="ae ky" href="https://www.freecodecamp.org/news/polymorphism-in-java-tutorial-with-object-oriented-programming-example-code/" rel="noopener ugc nofollow" target="_blank">https://www . freecodecamp . org/news/polymorphism-in-Java-tutorial-with-object-oriented-programming-example-code/</a></li></ol></div></div>    
</body>
</html>