<html>
<head>
<title>How To Magically Speed Up Java Coding</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何神奇地加速Java编码</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-to-magically-speed-up-java-coding-76fa1a68e0f4?source=collection_archive---------0-----------------------#2021-08-30">https://blog.devgenius.io/how-to-magically-speed-up-java-coding-76fa1a68e0f4?source=collection_archive---------0-----------------------#2021-08-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7e86" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用Lombok少写多做</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/c8903a6af0cb1a770a2cc81703efb4d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kkuLfcLapuenkruR3SmJOg.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">米兰·波波维奇在<a class="ae kv" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="d1f4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不管编程语言的类型如何，样板代码的构建都是不可避免的。这既乏味又耗时，您可能会发现自己将时间花费在构建样板代码上，而不是通过编码业务功能来传递价值。</p><p id="20ce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于Java编程，Java bean约定需要setters和getters来访问属性。我们需要时间来维持这些方法。例如，客户机的Java bean类定义具有以下属性:id、名字、姓氏和出生日期。您可以看到一个setters和getters列表以及一个默认的构造函数。尽管许多现代IDE支持为这些方法生成代码，但它只是帮助您在第一次生成模板，如果您重命名或删除类中的属性，则需要手动调整它们。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="c415" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有没有什么方法可以消除编写样板结构代码的手工工作，并加快软件开发的速度？<a class="ae kv" href="https://projectlombok.org" rel="noopener ugc nofollow" target="_blank"> Lombok </a>是一个奇妙的Java库，它就像一根神奇的魔杖，在幕后自动生成样板代码。通过使用Lombok批注@Setter、@Getter和@NoArgConstructor，无需修改源代码即可生成Setter、Getter和默认构造函数。生成的方法在源代码中不可见，但您可以在IDE的代码结构视图中看到它们。客户机Java bean现在看起来更干净、更简单。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lu"><img src="../Images/c607dbe5f24edb4f8dc98cdae979c19a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H_g3AIS7PYNcD0Hsn9wu6w.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">由Lombok生成的代码</figcaption></figure><h1 id="32cd" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">龙目岛是如何运作的？</h1><p id="2c86" class="pw-post-body-paragraph kw kx iq ky b kz mn jr lb lc mo ju le lf mp lh li lj mq ll lm ln mr lp lq lr ij bi translated">虽然大多数ide的代码生成功能实际上更新了源代码文件，但Lombok以不同的方式更新，方法是在不修改源代码的情况下悄悄生成的。事实上，Lombok在编译过程中进行了修改，让我解释一下它是如何在幕后工作的。下面的过程图说明了高级Java编译过程。首先，Java源代码文件被提供给编译器，编译器解析源代码并生成抽象源代码树(AST)的数据结构。接下来，它调用处理程序进行注释处理。Lombok库被调用来处理它自己的注释，比如上面例子中的@Getter、@Setter和@NoArgConstructor。因此，魔法在这一步开始发挥作用，Lombok通过根据注释注入setters、getters和constructor来修改AST。最后，AST被转换并输出到类文件。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ms"><img src="../Images/a717df9c2b1ee870d18e62b8b29aaa49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RA6nwcqVW1eQGUx2a48Psg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">用Lombok实现的Java编译程序</figcaption></figure><p id="93e3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">换句话说，Lombok通过入侵编译过程来注入代码。由于Lombok的工作方式，一些人反对使用它。由于无法看到生成的方法，因此如果生成的代码有问题，很难进行故障排除。然而，生产率的提高和干净的源代码的好处绝对超过了对生成代码的关注。由于该库很受欢迎并被众多项目采用，Lombok库相当稳定。</p><p id="4456" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Lombok库不仅支持setter和getter方法的生成，还支持logger实例化、对象比较等其他常用代码。使用该库的次数越多，需要编写的代码就越少，从而加快开发过程。在本文中，我将向您展示流行的Lombok特性的用法，以及它如何加速您的代码编写。</p></div><div class="ab cl mt mu hu mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ij ik il im in"><h1 id="d63b" class="lv lw iq bd lx ly na ma mb mc nb me mf jw nc jx mh jz nd ka mj kc ne kd ml mm bi translated">如何设置龙目岛？</h1><p id="84d5" class="pw-post-body-paragraph kw kx iq ky b kz mn jr lb lc mo ju le lf mp lh li lj mq ll lm ln mr lp lq lr ij bi translated">为了让maven与Lombok一起工作，您需要在maven pom.xml中包含这种依赖关系，以便Maven与Lombok一起工作。</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="43cc" class="nk lw iq ng b gy nl nm l nn no">&lt;dependency&gt;<br/>  &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;<br/>  &lt;artifactId&gt;lombok&lt;/artifactId&gt;<br/>  &lt;version&gt;1.18.20&lt;/version&gt;<br/>&lt;/dependency&gt;</span></pre><p id="d7d3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">生成的方法在IDE的代码结构视图中可见，具体可以分别参考<a class="ae kv" href="https://projectlombok.org/setup/eclipse" rel="noopener ugc nofollow" target="_blank"> Eclipse </a>和<a class="ae kv" href="https://projectlombok.org/setup/intellij" rel="noopener ugc nofollow" target="_blank"> IntelliJ IDEA </a>。</p></div><div class="ab cl mt mu hu mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ij ik il im in"><h1 id="191d" class="lv lw iq bd lx ly na ma mb mc nb me mf jw nc jx mh jz nd ka mj kc ne kd ml mm bi translated">构造器</h1><p id="1a5c" class="pw-post-body-paragraph kw kx iq ky b kz mn jr lb lc mo ju le lf mp lh li lj mq ll lm ln mr lp lq lr ij bi translated">构造函数是对象实例化的特殊方法。为Java类定义默认构造函数是最佳实践。即使Java编译器为您的类生成了默认的构造函数，您也需要手动定义一个，因为如果您的类没有任何参数化的构造函数，编译器不会生成默认的构造函数。您可能还需要定义参数化的构造函数，以便可以用值实例化对象。除非您有专门的逻辑来实例化类，否则您的大多数构造函数定义将类似于这个示例。它调用其父类的构造函数，并将输入参数设置为类属性。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="af6b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以通过Lombok annotations @ NoArgsConstructor和@AllArgsConstructor来避免重复的代码，这两个代码分别生成默认的构造函数和带有所有类属性的输入参数的构造函数。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lu"><img src="../Images/9eb9f0feddb7c77621c20393f4cdc374.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YuESckAQyvNKE6elo02aVQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">由Lombok生成的构造函数</figcaption></figure></div><div class="ab cl mt mu hu mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ij ik il im in"><h1 id="5e79" class="lv lw iq bd lx ly na ma mb mc nb me mf jw nc jx mh jz nd ka mj kc ne kd ml mm bi translated">相等检查— hashCode() &amp; equals()</h1><p id="f15d" class="pw-post-body-paragraph kw kx iq ky b kz mn jr lb lc mo ju le lf mp lh li lj mq ll lm ln mr lp lq lr ij bi translated">作为业务功能的一部分，我们经常需要检查对象是否相同。例如，HashMap使用hashCode()和equals()来确定键对象是否在同一个值中。因此，如果您想将Java类存储为Map中的关键对象，您需要覆盖这两个方法。</p><p id="43d2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是hashCode()和equals()的示例实现。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="4daf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果将注释@EqualsAndHashCode添加到类定义中，将会自动生成相同的函数。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lu"><img src="../Images/d26f7e4199ea60a3d1cf824789eab923.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r0McaW3lY8TOxCqPiPYYwQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">Lombok生成了equals()和hashCode()</figcaption></figure></div><div class="ab cl mt mu hu mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ij ik il im in"><h1 id="adaa" class="lv lw iq bd lx ly na ma mb mc nb me mf jw nc jx mh jz nd ka mj kc ne kd ml mm bi translated">对象字符串转换— toString()</h1><p id="6f81" class="pw-post-body-paragraph kw kx iq ky b kz mn jr lb lc mo ju le lf mp lh li lj mq ll lm ln mr lp lq lr ij bi translated">在日志中打印对象的默认行为是类名和哈希代码，这对调试和日志跟踪没有意义。开发人员需要自己构建toString()，将所有字段值放入StringBuilder并输出到String当然是一项繁琐的任务。每当属性有任何变化时，保持这个方法最新的努力是令人讨厌的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="9887" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">示例数据的字符串输出如下所示:</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="49b7" class="nk lw iq ng b gy nl nm l nn no">Client(id=1,firstName=John,lastName=Doe,dateOfBirth=Sun Aug 29 18:43:00 BST 2021)</span></pre><p id="bc22" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Lombok注释提供了toString()方法的一个方便的实现，这样所有的字段值都用下面的示例输出值打印出来。这个注释节省了您维护方法的精力，因为它会自动包含字符串输出中的所有字段。如果您想从字符串输出中排除一些字段，那么可以通过将@ToString。排除对特定字段的注释。</p><p id="4895" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">生成的toString()方法将产生与上面相同的输出。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/724e062c2611fc3954f094947898401a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BPJh31ax3zhszx_krrdOpA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">由Lombok生成的toString()</figcaption></figure></div><div class="ab cl mt mu hu mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ij ik il im in"><h1 id="506a" class="lv lw iq bd lx ly na ma mb mc nb me mf jw nc jx mh jz nd ka mj kc ne kd ml mm bi translated">便捷的批注快捷方式— @Data</h1><p id="3f50" class="pw-post-body-paragraph kw kx iq ky b kz mn jr lb lc mo ju le lf mp lh li lj mq ll lm ln mr lp lq lr ij bi translated">因为@ToString、@EqualAndHashCode、@Getter和@Setter对于大多数类定义来说都很常见，所以Lombok提供了一个方便的快捷方式@Data，将所有的注释放在一起。现在，类定义看起来更清晰了。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lu"><img src="../Images/b3670c8ee60a3787b977dbbfca77d3f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KiyKLTHhQPUD0-tejB-ezA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">通过数据注释生成的方法</figcaption></figure></div><div class="ab cl mt mu hu mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ij ik il im in"><h1 id="d645" class="lv lw iq bd lx ly na ma mb mc nb me mf jw nc jx mh jz nd ka mj kc ne kd ml mm bi translated">用于对象构造的生成器模式— @Builder</h1><p id="6bef" class="pw-post-body-paragraph kw kx iq ky b kz mn jr lb lc mo ju le lf mp lh li lj mq ll lm ln mr lp lq lr ij bi translated">除了这些基本的通用方法，Lombok还能够为更高级的设计模式生成代码——对象构建器和不可变设置器。</p><p id="6c5e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Java中的对象构造可以使用构造函数或setters来完成。这些构建对象的传统方法对于简单的类定义来说工作得很好。如果你的构造函数有多个构造函数，事情会变得混乱。大多数开发人员可能都有在调用构造函数时混淆参数序列的经验。</p><p id="cff2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">即使构造函数很简单，也可能会混淆姓和名的参数。</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="f239" class="nk lw iq ng b gy nl nm l nn no">Client client = new Client(1l, “John”, “Joe”, new Date(2000, 1, 1));</span></pre><p id="bb03" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用setter方法会更好吗？setter的使用更加冗长，它清楚地显示了正在配置什么参数，但是它不适用于没有setter方法的不可变对象。</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="303c" class="nk lw iq ng b gy nl nm l nn no">Client client = new Client();<br/>client.setId(1l);<br/>client.setFirstName(“John”);<br/>client.setLastName( “Joe”);<br/>client.setDateOfBirth(new Date(2000, 1, 1);</span></pre><p id="44f4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">随着传统对象构造的限制，对象构建器的设计模式已经成为业界的流行。如果你想了解更多关于<a class="ae kv" href="https://dzone.com/articles/design-patterns-the-builder-pattern" rel="noopener ugc nofollow" target="_blank">构建器模式</a>的信息，请阅读这篇文章。</p><p id="35a2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">构建器模式的实现需要为构建器创建一个内部类。Lombok允许我们通过在类定义中添加注释@Builder来轻松地创建构建器模式。该示例显示了内部类ClientBuilder是使用添加到类定义中的注释生成的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lu"><img src="../Images/855e2d28d10081d770f04cb30ff76f34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mRHtvlPae-BNDMAwNChe8Q.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">由Lombok生成的构建器代码</figcaption></figure><p id="d4f3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，我们可以使用builder()方法获得构建器。代码可读性更强，也更容易理解。</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="a62f" class="nk lw iq ng b gy nl nm l nn no">Client client = Client.builder()<br/>.id(1l)<br/>.firstName("John")<br/>.lastName("Joe")<br/>.dateOfBirth(new Date(2000, 1, 1))<br/>.build();</span></pre></div><div class="ab cl mt mu hu mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ij ik il im in"><h1 id="232d" class="lv lw iq bd lx ly na ma mb mc nb me mf jw nc jx mh jz nd ka mj kc ne kd ml mm bi translated">不可变对象的Setter方法— @With</h1><p id="3e47" class="pw-post-body-paragraph kw kx iq ky b kz mn jr lb lc mo ju le lf mp lh li lj mq ll lm ln mr lp lq lr ij bi translated">不变性是近年来流行的设计模式。基于这种模式开发的应用程序是线程安全的，并且易于跟踪应用于数据模型的更改。不可变对象不能被修改，这意味着如果您想更新任何字段值，您需要克隆一个具有新字段值的新对象。</p><p id="85e4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在函数式编程中，对象是不可变的，你需要通过克隆一个新的来改变它。例如，下面的示例代码将额外的费用应用于货币汇率列表。map()方法中带有新汇率的新货币汇率对象。</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="d92b" class="nk lw iq ng b gy nl nm l nn no">List&lt;CurrencyRate&gt; updatedRateList =<br/>currencyRateList.stream()<br/>.map(currencyRate -&gt; new CurrencyRate(currencyRate.currencyPair, currencyRate.rate + 0.0025, currencyRate.expiryTime, currencyRate.bookingRef, currencyRate.source, currencyRate.createdAt, currencyRate.requesterId))<br/>.collect(Collectors.toList());</span></pre><p id="8413" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对象构造不太可读，因为它涉及流中的许多参数。为了简化代码，让我们应用“枯萎”设计模式。这是一个快捷方式，它创建一个具有新速率值的新对象，而其余数据字段保持不变。</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="73b3" class="nk lw iq ng b gy nl nm l nn no">List&lt;CurrencyRate&gt; updatedRateList =<br/>currencyRateList.stream()<br/>.map(currencyRate -&gt; currencyRate.withRate(currencyRate.rate + 0.0025))<br/>.collect(Collectors.toList());</span></pre><p id="37b9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要实现这种设计模式，请定义一个名为withRate(Double updatedRate)的方法，该方法使用带有更新后的汇率值的构造函数来创建货币汇率对象。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="883d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要使用Lombok启用“枯萎”设计模式，只需在字段中添加@With注释。该注释可以应用于类级别，以便为所有数据字段自动创建“Wither”方法。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lu"><img src="../Images/ee561a0326f0f51fc2b907360136ece8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gdylsN_raDnTtLflKBr1gQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">龙目岛产生的“枯萎”方法</figcaption></figure></div><div class="ab cl mt mu hu mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ij ik il im in"><h1 id="394b" class="lv lw iq bd lx ly na ma mb mc nb me mf jw nc jx mh jz nd ka mj kc ne kd ml mm bi translated">记录器实例化</h1><p id="e0bb" class="pw-post-body-paragraph kw kx iq ky b kz mn jr lb lc mo ju le lf mp lh li lj mq ll lm ln mr lp lq lr ij bi translated">虽然我们不应该依赖System.out和System.err进行日志记录，但最佳实践是采用Slf4j和log4j之类的日志记录系统。需要将记录器定义为类中的静态对象，以便在类中进行日志记录。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="4121" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是一个优化这种常见模式的机会。Lombok提供了支持记录器实例化的注释。支持多种日志系统，完整列表请参考此处的<a class="ae kv" href="https://projectlombok.org/features/log" rel="noopener ugc nofollow" target="_blank">。下面的例子应用了@Slf4J注释，它创建了一个名为“log”的静态日志字段。</a></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/f108b600ec8cfbcd4490d3212cf0aa82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M_xL3ulGhupCxdtDnt70jg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">由Lombok生成的记录器</figcaption></figure><h1 id="9fbb" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">字段默认值(实验特征)</h1><p id="96c3" class="pw-post-body-paragraph kw kx iq ky b kz mn jr lb lc mo ju le lf mp lh li lj mq ll lm ln mr lp lq lr ij bi translated">有了Lombok生成的setters、getters、constructors和builders，只需要在类定义中定义数据字段，对于定义d to和域对象特别有用。但是，下面Client的类定义里还有什么可以进一步简化的？有没有重复的模式？所有数据字段都是该类的私有成员。按照Java bean约定的定义，class封装了所有数据字段，并通过getters和setters公开它们。然后，让我们通过字段默认值注释的实验特性来进一步简化代码。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nr"><img src="../Images/628d0d3bcdd2dc21742a3aea2fc55386.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L-6CPvdz-vJ-ILbU71dUpA.png"/></div></div></figure><p id="2484" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">@FieldDefaults注释允许我们指定类属性的默认访问级别。因此，我们可以简单地省略每个数据字段的访问修饰符，因为Lombok会根据注释自动分配默认的访问级别。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ns"><img src="../Images/9e931964ccaad7d26b34963b099db198.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PWrfZp4erMu4BfSB5BVzhw.png"/></div></div></figure></div><div class="ab cl mt mu hu mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ij ik il im in"><h1 id="97d6" class="lv lw iq bd lx ly na ma mb mc nb me mf jw nc jx mh jz nd ka mj kc ne kd ml mm bi translated">最后的想法</h1><p id="9e5a" class="pw-post-body-paragraph kw kx iq ky b kz mn jr lb lc mo ju le lf mp lh li lj mq ll lm ln mr lp lq lr ij bi translated">Lombok是一个神奇的工具，它可以神奇地生成样板代码，所以我们不需要担心样板代码的维护，例如setters、getters和constructors，因为它会在我们编辑源代码时自动更新和生成它们。它能够显著提高生产率，并产生高度简化的代码。另一方面，如果您没有完全理解它的用法并误用注释，我们可能会遇到意外的系统行为。因此，强烈建议您通读文档，确保完全理解用法。</p></div></div>    
</body>
</html>