<html>
<head>
<title>Hunting Memory Leakage in JavaScript Application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在 JavaScript 应用程序中寻找内存泄漏</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/memory-management-and-hunting-leakage-in-javascript-47fca2527ddf?source=collection_archive---------1-----------------------#2020-04-28">https://blog.devgenius.io/memory-management-and-hunting-leakage-in-javascript-47fca2527ddf?source=collection_archive---------1-----------------------#2020-04-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/2d9f231789fc1cb52d25599c8192e056.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AnC8bImIvY83aFdG1R1OHA.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">弓箭手阿拉什(来源:<a class="ae kc" href="https://unsplash.com/@alirzasahb" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></figcaption></figure><h1 id="2857" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated"><strong class="ak">垃圾收集</strong></h1><p id="0557" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">它是程序通过回收程序中不再使用的对象所占用的内存来执行自动内存管理的过程。一个对象在创建时使用的内存会一直保持分配状态，直到有对该对象的引用为止。当这些对象被认为不再使用时，释放内存的自动完成就发生了，这就是垃圾收集，简单地说，就是销毁未使用的对象。</p><p id="88e7" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">另一方面，<strong class="ld ir">手动内存管理</strong>是指程序员明确使用指令来释放内存。在 C 编程中，开发人员需要使用 malloc()和 deallocate()函数来处理内存分配和释放。在 JavaScript 中，由于没有接口暴露给内存管理，所以所有的内存管理都交给了用户。就是<strong class="ld ir">垃圾收集</strong>。</p><h1 id="0833" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated"><strong class="ak">节点中的存储方案</strong></h1><p id="043e" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">NodeJs 中的内存管理是通过<a class="ae kc" href="https://v8.dev/" rel="noopener ugc nofollow" target="_blank"><strong class="ld ir">V8</strong></a><strong class="ld ir">:</strong>' Google 的开源高性能 JavaScript 和 WebAssembly 引擎<em class="me"> ' </em>。分配给程序执行的总内存是<strong class="ld ir">常驻集</strong>。这又分为以下几个部分:</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mf"><img src="../Images/63e464fe5929ea6894f1dd59627ba7ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lqRl4r0gQfWtFwnq_bJzuQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">图 V8 中的存储方案</figcaption></figure><h2 id="d498" class="mk ke iq bd kf ml mm dn kj mn mo dp kn lm mp mq kr lq mr ms kv lu mt mu kz mv bi translated"><strong class="ak">代号</strong></h2><p id="c4c4" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">正在执行的实际代码。</p><h2 id="12f4" class="mk ke iq bd kf ml mm dn kj mn mo dp kn lm mp mq kr lq mr ms kv lu mt mu kz mv bi translated"><strong class="ak">堆栈</strong></h2><p id="f7d2" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">静态数据包括方法、原始值、定义程序控制流的指针和指向堆中对象的指针都存储在这里。</p><h2 id="dc0c" class="mk ke iq bd kf ml mm dn kj mn mo dp kn lm mp mq kr lq mr ms kv lu mt mu kz mv bi translated"><strong class="ak">堆</strong></h2><p id="4109" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">V8 存储对象或动态数据的内存段。堆是最大的内存块，专门用于存储引用类型，如对象、字符串和闭包，在这里进行垃圾收集。堆有两个主要部分:</p><ul class=""><li id="fbe9" class="mw mx iq ld b le lz li ma lm my lq mz lu na ly nb nc nd ne bi translated"><strong class="ld ir">新空间:</strong>新空间的大小约为 1-8MB，驻留在此的对象称为<strong class="ld ir">新一代</strong>。</li><li id="e167" class="mw mx iq ld b le nf li ng lm nh lq ni lu nj ly nb nc nd ne bi translated"><strong class="ld ir">旧空间:</strong>经历了两次清除收集的对象现在从新空间转移到旧空间<strong class="ld ir"> </strong>，称为<strong class="ld ir">老代</strong>。在分配了某些旧空间内存后，会发生昂贵的垃圾收集(标记-清除和标记-压缩)。</li></ul><p id="70a9" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">为了获得程序中内存使用的基本信息，让我们在 NodeJs 程序中执行下面的代码并观察输出。</p><pre class="mg mh mi mj gt nk nl nm nn aw no bi"><span id="f2f9" class="mk ke iq nl b gy np nq l nr ns"><strong class="nl ir">process.memoryUsage();</strong></span><span id="3984" class="mk ke iq nl b gy nt nq l nr ns">// Output (in bytes)</span><span id="d7c2" class="mk ke iq nl b gy nt nq l nr ns">{<br/> <br/> rss: 365801472,</span><span id="b500" class="mk ke iq nl b gy nt nq l nr ns"> heapTotal: 94416896,</span><span id="6f0f" class="mk ke iq nl b gy nt nq l nr ns"> heapUsed: 79383696,</span><span id="f809" class="mk ke iq nl b gy nt nq l nr ns"> external: 351234</span><span id="70db" class="mk ke iq nl b gy nt nq l nr ns">}</span></pre><h1 id="5ed2" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated"><strong class="ak">内存泄漏的来源</strong></h1><p id="8e2f" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">内存泄漏是指程序不需要的内存没有返回到操作系统或空闲内存池的情况。</p><h2 id="22e0" class="mk ke iq bd kf ml mm dn kj mn mo dp kn lm mp mq kr lq mr ms kv lu mt mu kz mv bi translated"><strong class="ak"> 1。关闭</strong></h2><p id="ecad" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">让我们考虑下面的内存泄漏<strong class="ld ir">流星开发商</strong>成立。</p><pre class="mg mh mi mj gt nk nl nm nn aw no bi"><span id="b2a4" class="mk ke iq nl b gy np nq l nr ns">var theThing = null;</span><span id="cd8c" class="mk ke iq nl b gy nt nq l nr ns">const replaceThing = function () {<br/>  var originalThing = theThing;<br/>  <br/>  var unused = function () {<br/>    if (originalThing)<br/>      console.log("hi");<br/>  };<br/>  <br/>  theThing = {<br/>    longStr: new Array(1000000).join('*'),<br/>    someMethod: function () {<br/>      console.log(someMessage);<br/>    }<br/>  };</span><span id="c270" class="mk ke iq nl b gy nt nq l nr ns">};</span><span id="3a22" class="mk ke iq nl b gy nt nq l nr ns">setInterval(replaceThing, 1000);</span></pre><h2 id="38b2" class="mk ke iq bd kf ml mm dn kj mn mo dp kn lm mp mq kr lq mr ms kv lu mt mu kz mv bi translated"><strong class="ak">解说</strong></h2><p id="1186" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">在 JavaScript 中，<a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures" rel="noopener ugc nofollow" target="_blank">闭包</a>允许您从内部函数访问外部函数的范围。内部函数可以访问外部函数的变量和参数。在上面的例子中，在<strong class="ld ir"> <em class="me"> replaceThing </em> </strong>中定义的函数，即函数<strong class="ld ir"> <em class="me"> someMethod </em> </strong>和函数<strong class="ld ir"> <em class="me"> unused </em> </strong>共享同一个父作用域。</p><p id="9203" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">变量<strong class="ld ir"> <em class="me">原值</em> </strong>仅从函数<strong class="ld ir"> <em class="me">中引用，未使用</em> </strong>。执行<strong class="ld ir"> <em class="me"> replaceThing </em> </strong>时，函数<strong class="ld ir"> <em class="me">未使用的</em> </strong>本身被清理。但是，第二个闭包<strong class="ld ir"> <em class="me"> someMethod </em> </strong>不会被清理，因为它可以从全局范围内的<strong class="ld ir">thing</strong>中被引用。我们可以看到<strong class="ld ir"> <em class="me"> someMethod </em> </strong>根本不引用<strong class="ld ir"> originalThing </strong>但是，<strong class="ld ir"><em class="me">original thing</em></strong>仍然没有被垃圾收集。为什么？嗯，实现闭包的典型方式是每个函数对象都有一个到表示其词法范围的字典式对象的链接。</p><p id="8a7a" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">一旦一个变量被任何闭包<em class="me">使用，它就会出现在该范围内所有<em class="me">闭包共享的词法环境中。由于<strong class="ld ir"> <em class="me"> somemethod </em> </strong>与<strong class="ld ir"><em class="me"/></strong>共享闭包范围，引用<strong class="ld ir"><em class="me"/></strong>必须将<strong class="ld ir"> <em class="me">改为</em> </strong>强制其保持活动状态。这阻止了它的收集。</em></em></p><h2 id="bcf3" class="mk ke iq bd kf ml mm dn kj mn mo dp kn lm mp mq kr lq mr ms kv lu mt mu kz mv bi translated"><strong class="ak"> 2。意外全局变量</strong></h2><p id="ce2c" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">JavaScript 中未声明的变量会在全局对象中创建新的变量。</p><pre class="mg mh mi mj gt nk nl nm nn aw no bi"><span id="f101" class="mk ke iq nl b gy np nq l nr ns">function foo(arg) {<br/>    bar = "this is hidden global variable";<br/>}</span><span id="6eef" class="mk ke iq nl b gy nt nq l nr ns">// is equivalent to:</span><span id="994c" class="mk ke iq nl b gy nt nq l nr ns">function foo(arg) {<br/>    window.bar = "this is explicit global variable";<br/>}</span></pre><p id="1e16" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">在浏览器的情况下，全局对象是“<strong class="ld ir">窗口”。在 NodeJs 中，根节点通常是对象“<strong class="ld ir">全局</strong>或“<strong class="ld ir">流程</strong>”。变量<strong class="ld ir"> bar </strong>永远不能被收集，因为它是在全局作用域中定义的，会导致内存泄漏。</strong></p><h2 id="d36a" class="mk ke iq bd kf ml mm dn kj mn mo dp kn lm mp mq kr lq mr ms kv lu mt mu kz mv bi translated"><strong class="ak"> 3。忘记回调或定时器</strong></h2><pre class="mg mh mi mj gt nk nl nm nn aw no bi"><span id="9ae0" class="mk ke iq nl b gy np nq l nr ns">var someResource = getData();</span><span id="2695" class="mk ke iq nl b gy nt nq l nr ns">setInterval(function() {<br/>  var node = document.getElementById('domode');<br/>  <br/>  if(node) {<br/>    node.innerHTML = JSON.stringify(someResource));<br/>  }<br/>}, 1000);</span></pre><p id="2df4" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">如果<strong class="ld ir">节点</strong>变量未被使用，区间处理程序中的整个块就变得不必要了。无法收集处理程序，因为间隔处于活动状态并会导致内存泄漏。</p><h2 id="1af3" class="mk ke iq bd kf ml mm dn kj mn mo dp kn lm mp mq kr lq mr ms kv lu mt mu kz mv bi translated"><strong class="ak"> 4。超出 DOM 引用范围</strong></h2><pre class="mg mh mi mj gt nk nl nm nn aw no bi"><span id="84a3" class="mk ke iq nl b gy np nq l nr ns">var elements = {<br/>  button: document.getElementById('button'),<br/>  image: document.getElementById('image'),<br/>  text:document.getElementById('text')<br/>};</span><span id="a7ad" class="mk ke iq nl b gy nt nq l nr ns">function doStuff() {     <br/>  image.src = 'http://some.url/image';     <br/>  button.click();     <br/>}  </span><span id="c451" class="mk ke iq nl b gy nt nq l nr ns">function removeButton() {<br/>  // The button is a direct child of body.<br/>  document.body.removeChild(document.getElementById('button'));</span><span id="2196" class="mk ke iq nl b gy nt nq l nr ns">  // still have reference to button in global elements dictionary<br/>  // cannot be garbage collected<br/>}</span></pre><h2 id="cb33" class="mk ke iq bd kf ml mm dn kj mn mo dp kn lm mp mq kr lq mr ms kv lu mt mu kz mv bi translated"><strong class="ak">解说</strong></h2><p id="f48e" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">button 元素仍在字典中，并且由于对 button 的引用而无法通过垃圾回收来回收。</p><p id="ef5c" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">让我们考虑一个场景:一个 HTML <table>由许多<tr>和<td>组成，从 DOM 中移除表格但保留对单元格的</td><td>引用，GC 不会收集所有内容。事实上，该表仍然保留在内存中。</td><td>保持对表的引用，不能被垃圾收集。换句话说，javascript 代码对表格单元格的引用允许表格保留在内存中。</td></tr></table></p><h2 id="c3a6" class="mk ke iq bd kf ml mm dn kj mn mo dp kn lm mp mq kr lq mr ms kv lu mt mu kz mv bi translated"><strong class="ak"> 5。旧浏览器和漏洞百出的扩展</strong></h2><p id="0f8d" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">旧浏览器(IE6–7)因造成内存泄漏而臭名昭著，因为它不能处理 DOM 对象和 JavaScript 对象之间的循环引用。有时，错误的浏览器扩展可能会导致内存泄漏。</p><h2 id="8696" class="mk ke iq bd kf ml mm dn kj mn mo dp kn lm mp mq kr lq mr ms kv lu mt mu kz mv bi translated"><strong class="ak"> 6。</strong> <strong class="ak">事件监听器&amp;缓存</strong></h2><p id="aabc" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">当 DOM 元素及其对应的事件侦听器没有相同的生命周期时，可能会导致内存泄漏。无限增长的缓存会导致高内存消耗，并导致内存泄漏。</p><h1 id="9ab8" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated"><strong class="ak">垃圾收集机制</strong></h1><p id="2398" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">垃圾收集分两个阶段进行:</p><h2 id="01cd" class="mk ke iq bd kf ml mm dn kj mn mo dp kn lm mp mq kr lq mr ms kv lu mt mu kz mv bi translated"><strong class="ak"> 1。扫气</strong></h2><p id="2284" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">新空间中的内存分配是廉价的。当我们需要新空间中的空间时，分配指针增加。当这个分配指针超过某个限制时，清除算法被触发，快速移除死对象。</p><h2 id="6f98" class="mk ke iq bd kf ml mm dn kj mn mo dp kn lm mp mq kr lq mr ms kv lu mt mu kz mv bi translated"><strong class="ak"> 2。标记、扫描和压缩阶段</strong></h2><p id="47c3" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">旧空间的大小可能超过数百兆字节，标记-清除和标记-压缩在该空间上运行的频率会降低。程序和旧空间大小的行为改变了这种垃圾收集。简单地说，对象被标记为“活的”或“死的”，删除“死的”对象，然后压缩内存以进行优化。</p><ul class=""><li id="d72d" class="mw mx iq ld b le lz li ma lm my lq mz lu na ly nb nc nd ne bi translated"><strong class="ld ir">标记阶段</strong> : V8 使用三种标记方案，分别是<strong class="ld ir">白色(</strong>未发现的物体)、<strong class="ld ir">灰色</strong>(发现了物体，但其邻居未被发现)、以及<strong class="ld ir">黑色(</strong>物体及其所有邻居被发现)。</li><li id="9d7d" class="mw mx iq ld b le nf li ng lm nh lq ni lu nj ly nb nc nd ne bi translated"><strong class="ld ir">扫描阶段:</strong>释放<strong class="ld ir">白色</strong>(“死”)对象的内存。</li><li id="2382" class="mw mx iq ld b le nf li ng lm nh lq ni lu nj ly nb nc nd ne bi translated"><strong class="ld ir">压缩阶段</strong>:内存组织在此阶段进行，以实现更快的内存访问，将对象从碎片页面迁移到内存区域的开头。</li></ul><p id="6dd8" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">传统的垃圾收集实现了<strong class="ld ir">Stop World</strong>垃圾收集，在垃圾收集过程中程序会暂停。</p><h1 id="4163" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated"><strong class="ak">or Nico——V8 发动机中的垃圾收集器</strong></h1><p id="94e8" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">它部署并行、增量和并发机制来释放主线程。</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/923cedffb001d18c3a6ad3f93d32263c.png" data-original-src="https://miro.medium.com/v2/resize:fit:884/format:webp/1*WLrc1xtT8cPl0Fm9AlW4_Q.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">图 V8 垃圾收集器— Ornico</figcaption></figure><h2 id="619a" class="mk ke iq bd kf ml mm dn kj mn mo dp kn lm mp mq kr lq mr ms kv lu mt mu kz mv bi translated"><strong class="ak">平行</strong></h2><p id="1c69" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">尽管如此，Stop-the-world 机制引入了助手线程，它们在同一时间完成大致等量的工作。总暂停时间除以引入的线程数(加上一些同步时间)。</p><h2 id="527f" class="mk ke iq bd kf ml mm dn kj mn mo dp kn lm mp mq kr lq mr ms kv lu mt mu kz mv bi translated"><strong class="ak">并发</strong></h2><p id="ff81" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">主线程完全自由地执行 Javascript，辅助线程在后台进行垃圾收集。</p><h2 id="015c" class="mk ke iq bd kf ml mm dn kj mn mo dp kn lm mp mq kr lq mr ms kv lu mt mu kz mv bi translated"><strong class="ak">惰性/增量</strong></h2><p id="4bc6" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">这是在一系列增量暂停中进行的，其中所需的总工作的一小部分是立即进行的。花费在主线程上的总时间并没有减少，但是，它会随着时间的推移而增加。</p><h1 id="61e6" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated"><strong class="ak">狩猎内存泄漏</strong></h1><h2 id="0dee" class="mk ke iq bd kf ml mm dn kj mn mo dp kn lm mp mq kr lq mr ms kv lu mt mu kz mv bi translated"><strong class="ak"> 1。使用节点检查器</strong></h2><p id="b088" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">让我们以检查模式开始我们的应用程序:</p><pre class="mg mh mi mj gt nk nl nm nn aw no bi"><span id="41b6" class="mk ke iq nl b gy np nq l nr ns">node --inpsect=9229 index.js </span></pre><p id="244d" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">在 Chrome 浏览器上打开:</p><pre class="mg mh mi mj gt nk nl nm nn aw no bi"><span id="2033" class="mk ke iq nl b gy np nq l nr ns">chrome://inspect</span></pre><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nv"><img src="../Images/01c55a6c528492867e62b45f092158e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tLlUz8BpfDzCnItk"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">图通过浏览器检查</figcaption></figure><p id="41e6" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">点击<strong class="ld ir">检查后，</strong>专用开发工具打开如下。在内存- &gt;配置文件下，点击<strong class="ld ir">拍摄快照。</strong>可以在<strong class="ld ir">汇总</strong>、<strong class="ld ir">比较</strong>、<strong class="ld ir">遏制</strong>、&amp;、<strong class="ld ir">支配者</strong>模式下查看输出。</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nv"><img src="../Images/1a940142cbc97c3ca6d75e308113b5c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bGo7dZSciESGA4u6"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">图获取堆快照</figcaption></figure><h2 id="bb19" class="mk ke iq bd kf ml mm dn kj mn mo dp kn lm mp mq kr lq mr ms kv lu mt mu kz mv bi translated"><strong class="ak">汇总视图</strong></h2><p id="5110" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">这个视图对于追踪 DOM 泄漏特别有帮助。当元素已经从 DOM 中移除，但由于 Javascript 中的引用而保留了它们的内存时，会导致 DOM 泄漏。有关源代码，请参考此处的<a class="ae kc" href="https://github.com/BibekShah09/detached-dom-node/tree/master" rel="noopener ugc nofollow" target="_blank"/>。</p><ul class=""><li id="fddd" class="mw mx iq ld b le lz li ma lm my lq mz lu na ly nb nc nd ne bi translated"><strong class="ld ir">构造函数</strong>表示使用该构造函数创建的所有对象。</li><li id="d1e4" class="mw mx iq ld b le nf li ng lm nh lq ni lu nj ly nb nc nd ne bi translated"><strong class="ld ir"> Shallow size </strong>是对象本身所拥有的内存大小。</li><li id="beff" class="mw mx iq ld b le nf li ng lm nh lq ni lu nj ly nb nc nd ne bi translated"><strong class="ld ir"> Retained size </strong>是对象及其相关对象被删除后释放的内存大小。</li><li id="212a" class="mw mx iq ld b le nf li ng lm nh lq ni lu nj ly nb nc nd ne bi translated"><strong class="ld ir">距离</strong>使用节点的最短简单路径显示到根的距离。</li></ul><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nv"><img src="../Images/d6306be49f42bb7a712e07b07da35e55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ad1_hjGyl1tceK3O"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">图摘要视图</figcaption></figure><h2 id="cc60" class="mk ke iq bd kf ml mm dn kj mn mo dp kn lm mp mq kr lq mr ms kv lu mt mu kz mv bi translated"><strong class="ak">对比视图</strong></h2><p id="bed0" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">它用于记录和比较两个(或多个)内存快照，并执行比较。释放内存和引用计数中的增量的存在使您可以确认内存泄漏的存在和原因，这可以进一步深入。</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nw"><img src="../Images/ee3d80e1557ee72e2246916e978593ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nRqukVoZRZwiRzHBtZ6bKA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">图不同快照的堆比较</figcaption></figure><h2 id="9531" class="mk ke iq bd kf ml mm dn kj mn mo dp kn lm mp mq kr lq mr ms kv lu mt mu kz mv bi translated"><strong class="ak">堆比较的细节</strong></h2><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nv"><img src="../Images/5da6f4d2dde88aff5227b1cf9e8a8827.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_FWmGF2omtJQp-fm"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">图堆比较详细信息</figcaption></figure><h2 id="9b56" class="mk ke iq bd kf ml mm dn kj mn mo dp kn lm mp mq kr lq mr ms kv lu mt mu kz mv bi translated"><strong class="ak">安全壳视图</strong></h2><p id="e43e" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">它提供了一个更好的对象结构视图，允许我们深入到一个较低的层次。</p><h2 id="3471" class="mk ke iq bd kf ml mm dn kj mn mo dp kn lm mp mq kr lq mr ms kv lu mt mu kz mv bi translated"><strong class="ak">支配者视图</strong></h2><p id="0de6" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">这个视图有助于确认没有对对象的意外引用仍然存在(即它们被很好地包含)，并且删除/垃圾收集实际上正在工作。</p><h2 id="e3ab" class="mk ke iq bd kf ml mm dn kj mn mo dp kn lm mp mq kr lq mr ms kv lu mt mu kz mv bi translated"><strong class="ak"> 2。使用堆转储模块并加载</strong></h2><p id="393c" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">或者，heapdump 模块允许获取堆快照。</p><pre class="mg mh mi mj gt nk nl nm nn aw no bi"><span id="9b10" class="mk ke iq nl b gy np nq l nr ns">const heapDump = require('heapdump');</span><span id="9d24" class="mk ke iq nl b gy nt nq l nr ns">function writeSnapShot() {<br/>  heapDump.writeSnapshot(function (err, filename) {<br/>   console.log('dump written to', filename);<br/> });<br/>}; </span><span id="9c5c" class="mk ke iq nl b gy nt nq l nr ns">module.exports = writeSnapShot;</span></pre><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nx"><img src="../Images/0fe0c3f2faf343eb08a5454e6b37c7a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GbHdNgrC07G9P6-Is4t0Sg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">图加载堆快照</figcaption></figure><p id="8b89" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">在 Chrome 浏览器中加载快照文件，并像以前一样继续进行分析。</p><h2 id="2ab4" class="mk ke iq bd kf ml mm dn kj mn mo dp kn lm mp mq kr lq mr ms kv lu mt mu kz mv bi translated">3.分配抽样/时间表</h2><p id="2f99" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">可以通过分配分析来查看时间序列上的分配。选择“时间线上的分配工具”。</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nv"><img src="../Images/569c396261abb5adbf4a8de8866217e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8dC0K2Z8tLv9fqda"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">图选择分配采样模式</figcaption></figure><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nv"><img src="../Images/e0de52a56161db07147e573ff25bead1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tv3F9IYx8h9zE7F6"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">图分配抽样详细信息</figcaption></figure><p id="efa0" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">蓝色条显示代表新的内存分配，这是您的<strong class="ld ir">内存泄漏</strong>的潜在候选。单击蓝线以查看当时发生的分配分析的详细信息。</p><h2 id="243a" class="mk ke iq bd kf ml mm dn kj mn mo dp kn lm mp mq kr lq mr ms kv lu mt mu kz mv bi translated"><strong class="ak"> 4。时间线视图</strong></h2><p id="449c" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">对于 UI 跟踪，时间轴视图可能会有所帮助。在 Chrome Dev Tools 中:选择<strong class="ld ir">性能</strong> → <strong class="ld ir">启用内存复选框</strong> → <strong class="ld ir">进行录制</strong>。</p><p id="885f" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">提示:通过单击收集垃圾按钮，从强制垃圾收集后开始记录。</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ny"><img src="../Images/cda3fc8a7bf620ce17673a44ee274c50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ao1qRPLldYYsvbXjiyp2ig.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">图时间轴视图</figcaption></figure><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nz"><img src="../Images/9a5bfd6e5dd501be106e59bc53e765cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o4bEh-Nz80U4wBCEivwvDg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">图放大的时间轴视图</figcaption></figure><p id="d024" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">蓝线表示 JavaScript 堆内存，还指定了程序在采样周期内消耗的范围。当单击蓝色虚线部分(内存使用情况)时，会显示主要 GC 和次要 GC。我们可以看到，次要 GC 比主要 GC 出现得更频繁。</p><p id="ec63" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">绿线表示文档中 HTML 节点的数量。程序中增加的 HTML 节点表明未被引用的 DOM 节点可能无法被 GC 收集，从而导致内存泄漏。</p><h2 id="8519" class="mk ke iq bd kf ml mm dn kj mn mo dp kn lm mp mq kr lq mr ms kv lu mt mu kz mv bi translated"><strong class="ak"> 5。命令行选项</strong></h2><p id="3a1a" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">Node 提供了不同的命令行选项来更深入地研究垃圾收集。考虑以下命令行:</p><pre class="mg mh mi mj gt nk nl nm nn aw no bi"><span id="e622" class="mk ke iq nl b gy np nq l nr ns">node --expose-gc --trace-gc index.js</span></pre><ul class=""><li id="8af9" class="mw mx iq ld b le lz li ma lm my lq mz lu na ly nb nc nd ne bi translated"><strong class="ld ir"> trace-gc </strong>:显示每次垃圾收集后的跟踪行。</li><li id="7315" class="mw mx iq ld b le nf li ng lm nh lq ni lu nj ly nb nc nd ne bi translated"><strong class="ld ir"> expose-gc </strong>:启用调用 global.gc()强制节点运行垃圾回收。</li></ul><p id="3a9b" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">更多命令行文本请参考<a class="ae kc" href="https://gist.github.com/listochkin/10973974" rel="noopener ugc nofollow" target="_blank">这里的</a>。</p><h2 id="0fa7" class="mk ke iq bd kf ml mm dn kj mn mo dp kn lm mp mq kr lq mr ms kv lu mt mu kz mv bi translated">6。云服务和 NPM 包</h2><p id="eed2" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">像 GCP ( <a class="ae kc" href="https://cloud.google.com/profiler" rel="noopener ugc nofollow" target="_blank"> Cloud Profiler </a>)这样的云服务提供了关于 JavaScript 堆细节的信息。不同的 npm 包可用于跟踪垃圾收集。</p><h2 id="fce9" class="mk ke iq bd kf ml mm dn kj mn mo dp kn lm mp mq kr lq mr ms kv lu mt mu kz mv bi translated"><strong class="ak">参考文献</strong></h2><ol class=""><li id="ce24" class="mw mx iq ld b le lf li lj lm oa lq ob lu oc ly od nc nd ne bi translated"><a class="ae kc" href="https://auth0.com/blog/four-types-of-leaks-in-your-javascript-code-and-how-to-get-rid-of-them/" rel="noopener ugc nofollow" target="_blank">https://auth 0 . com/blog/four-types-of-leaks-in-your-JavaScript-code-and-how-to-get-off-them/</a></li><li id="5bb8" class="mw mx iq ld b le nf li ng lm nh lq ni lu nj ly od nc nd ne bi translated"><a class="ae kc" href="https://developers.google.com/web/tools/chrome-devtools/memory-problems" rel="noopener ugc nofollow" target="_blank">https://developers . Google . com/web/tools/chrome-dev tools/memory-problems</a></li><li id="d58b" class="mw mx iq ld b le nf li ng lm nh lq ni lu nj ly od nc nd ne bi translated"><a class="ae kc" href="https://www.lambdatest.com/blog/eradicating-memory-leaks-in-javascript/" rel="noopener ugc nofollow" target="_blank">https://auth 0 . com/blog/four-types-of-leaks-in-your-JavaScript-code-and-how-to-get-off-them/</a></li><li id="341b" class="mw mx iq ld b le nf li ng lm nh lq ni lu nj ly od nc nd ne bi translated"><a class="ae kc" href="https://blog.risingstack.com/node-js-at-scale-node-js-garbage-collection/" rel="noopener ugc nofollow" target="_blank">https://blog . rising stack . com/node-js-at-scale-node-js-garbage-collection/</a></li><li id="0a57" class="mw mx iq ld b le nf li ng lm nh lq ni lu nj ly od nc nd ne bi translated"><a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/Memory _ Management</a></li></ol></div></div>    
</body>
</html>