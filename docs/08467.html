<html>
<head>
<title>The Power of Recursion</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">递归的力量</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/the-power-of-recursion-b15910be9ee7?source=collection_archive---------7-----------------------#2022-06-16">https://blog.devgenius.io/the-power-of-recursion-b15910be9ee7?source=collection_archive---------7-----------------------#2022-06-16</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div class="gh gi jk"><img src="../Images/63b6fad8576588308816b80239ed47f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*-CY2jPiY13OOVj9f6Crx9A.png"/></div></figure><p id="4f28" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">在这篇博文中，我将讨论递归以及调用递归函数时堆栈中会发生什么。所有代码示例都是用 C 编程语言编写的。</p><h1 id="bb61" class="kp kq in bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">什么是递归？</h1><blockquote class="ln lo lp"><p id="a78e" class="jr js lq jt b ju jv jw jx jy jz ka kb lr kd ke kf ls kh ki kj lt kl km kn ko ig bi translated">要理解递归，首先你必须理解什么是递归！</p></blockquote><p id="b789" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">玩笑归玩笑，简单地说<strong class="jt io">递归就是函数调用自己。</strong></p><h2 id="660a" class="lu kq in bd kr lv lw dn kv lx ly dp kz kc lz ma ld kg mb mc lh kk md me ll mf bi translated">递归与迭代</h2><p id="cf96" class="pw-post-body-paragraph jr js in jt b ju mg jw jx jy mh ka kb kc mi ke kf kg mj ki kj kk mk km kn ko ig bi translated">假设你想在一个盒子里找到一把钥匙，你有什么方法可以解决这个问题？</p><p id="3f62" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">下面的插图来自<a class="ae ml" href="https://g.co/kgs/b5Sbzv" rel="noopener ugc nofollow" target="_blank">搜索算法书</a>展示了两种不同的方法:迭代和递归方法。</p><figure class="mn mo mp mq gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi mm"><img src="../Images/8457d42faf682ffb0a33b3017c45cac7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u28JOyOZs12TC16u5yUfPw.png"/></div></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">图来自 Adit Bhargava 的《搜索算法:程序员和其他好奇者图解指南》</figcaption></figure><p id="dfcb" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">在<strong class="jt io">迭代方法</strong>中，你穿过一堆盒子——只要盒子堆不是空的，你就抓住一个盒子仔细看——如果你找到钥匙就停下来——问题解决了！否则，你就继续下去，寻找并添加盒子，直到盒子堆空了或者你找到了钥匙。这就是迭代，一系列的指令或代码被重复，直到达到一个特定的最终结果。</p><p id="5068" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">而在<strong class="jt io">递归方法</strong>中，你只需遍历盒子中的每一项，要么找到密钥，要么一遍又一遍地遍历盒子中的每一项。这就是递归，一个反复调用自己的函数。</p><p id="eadf" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">请注意，这两种方法完成了相同的事情，每个递归函数都可以迭代编写，反之亦然。</p><p id="9c68" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">现在我们知道了什么是递归，让我们通过查看一个代码示例来更深入地了解一下。</p><h1 id="4e0c" class="kp kq in bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">递归函数</h1><p id="1d09" class="pw-post-body-paragraph jr js in jt b ju mg jw jx jy mh ka kb kc mi ke kf kg mj ki kj kk mk km kn ko ig bi translated">让我们以函数<code class="fe mz na nb nc b"> _pow_recursion</code>为例，它使用递归计算一个数的幂并返回结果。它有两个浮点类型的参数:<code class="fe mz na nb nc b">x </code>是基数，<code class="fe mz na nb nc b">y</code>是幂数。</p><pre class="mn mo mp mq gt nd nc ne nf aw ng bi"><span id="21d5" class="lu kq in nc b gy nh ni l nj nk">float _pow_recursion(float x, float y)<br/>{<br/>    if (y == 0)<br/>        return (1);<br/>    if (y &lt; 0)<br/>        return (_pow_recursion(x, y + 1) / x);<br/><br/>    return (_pow_recursion(x, y - 1) * x);<br/>}</span></pre><h2 id="e94b" class="lu kq in bd kr lv lw dn kv lx ly dp kz kc lz ma ld kg mb mc lh kk md me ll mf bi translated">基本和递归情况</h2><p id="800b" class="pw-post-body-paragraph jr js in jt b ju mg jw jx jy mh ka kb kc mi ke kf kg mj ki kj kk mk km kn ko ig bi translated">每个递归函数都有两个部分:</p><ul class=""><li id="e5be" class="nl nm in jt b ju jv jy jz kc nn kg no kk np ko nq nr ns nt bi translated">递归情况——这是函数调用自身的时候</li><li id="f2a7" class="nl nm in jt b ju nu jy nv kc nw kg nx kk ny ko nq nr ns nt bi translated">基本情况是，函数不调用自己</li></ul><p id="3643" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">因为递归程序很容易进入无限循环，所以我们需要基本情况。当基本情况为真时，这用于<strong class="jt io">终止递归函数</strong>。</p><p id="93a7" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">如果我们看看上面的代码示例，当<code class="fe mz na nb nc b">y</code>达到 0 时，程序将停止并返回 1——这是<strong class="jt io">的基本情况:</strong></p><pre class="mn mo mp mq gt nd nc ne nf aw ng bi"><span id="4716" class="lu kq in nc b gy nh ni l nj nk">if (y == 0)  // BASE CASE<br/>     return (1); </span></pre><p id="1e0c" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">只要<code class="fe mz na nb nc b">y </code>大于 0，函数就会一直调用自己——这就是<strong class="jt io">递归的情况:</strong></p><pre class="mn mo mp mq gt nd nc ne nf aw ng bi"><span id="1c2b" class="lu kq in nc b gy nh ni l nj nk">if (y &lt; 0) // RECURSIVE CASE<br/>     return (_pow_recursion(x, y + 1) / x)</span><span id="a0aa" class="lu kq in nc b gy nz ni l nj nk">return (_pow_recursion(x, y - 1) * x); // RECURSIVE CASE</span></pre><p id="a8bb" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">让我们看看<strong class="jt io">调用递归函数时，堆栈</strong>上会发生什么。</p><h1 id="556e" class="kp kq in bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">调用堆栈</h1><blockquote class="oa"><p id="c5f5" class="ob oc in bd od oe of og oh oi oj ko dk translated">调用堆栈是一种抽象的堆栈数据结构，它存储程序按顺序调用的函数的信息，以便每个函数可以在完成时返回到调用它的代码。</p></blockquote><p id="8fd7" class="pw-post-body-paragraph jr js in jt b ju ok jw jx jy ol ka kb kc om ke kf kg on ki kj kk oo km kn ko ig bi translated">(要了解更多关于栈和堆的知识，建议你参考我之前的文章《C 编程中的<a class="ae ml" href="https://medium.com/@chiaracaprasi/memory-in-c-programming-5fee2e0f17a2?source=friends_link&amp;sk=89fbd0328ce6516c918b46aaff9a7241" rel="noopener">内存</a>)</p><p id="48c8" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">堆栈有后进先出顺序(LIFO)，这意味着当我们在堆栈中存储项目时，返回的第一个项目是我们放入的最后一个项目，就像在一堆盒子或一堆盘子中一样。向堆栈顶部添加一个新项目称为<strong class="jt io"> Push </strong>，从堆栈中移除最顶部的项目称为<strong class="jt io"> Pop </strong>。</p><p id="2082" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">堆栈在递归中起着重要的作用。事实上，在满足基本情况之前，函数一直存储在堆栈中。</p><p id="613f" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">让我们来看看它的实际应用——我们将继续上面的例子，并如下调用递归函数:<code class="fe mz na nb nc b">_pow_recursion(3, 4)</code>。</p><p id="fa76" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">这是我画的一张图，用来展示<strong class="jt io">在递归中栈上会发生什么。</strong></p><figure class="mn mo mp mq gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi op"><img src="../Images/285a33c4bf3bb148ec6ae42f89120576.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k0K4vzVCMqgMLU-jBO3btA.jpeg"/></div></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">Chiara Caprasi 绘制的图，展示了调用递归函数时堆栈中发生的情况</figcaption></figure><p id="123d" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">请注意，每次递归调用都会在堆栈内存中创建该方法的新副本。随着对<code class="fe mz na nb nc b">_pow_recursion</code>的每次调用，<code class="fe mz na nb nc b">y</code>的值都会改变。然后，该值被返回并更新到每个函数调用。然后将返回值乘以<code class="fe mz na nb nc b">x</code>，直到最后一次调用——我们最终得到最终值，在本例中是 81。</p><p id="05d2" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">递归函数在每次递归调用时都会将值添加到堆栈中，并在调用结束前一直保存这些值。由于这个原因，递归使用更多的内存。无限递归可能会导致堆栈内存耗尽或堆栈溢出。</p><h1 id="ea78" class="kp kq in bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated"><strong class="ak">递归的力量</strong>🔑</h1><p id="c255" class="pw-post-body-paragraph jr js in jt b ju mg jw jx jy mh ka kb kc mi ke kf kg mj ki kj kk mk km kn ko ig bi translated">回到开头的例子，我们已经看到有两种方法可以找到答案——迭代和递归具有相同的解决问题的能力。</p><p id="6eb5" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">即使没有性能上的好处，使用递归优于迭代也有一些优点和缺点。让我们来看一些:</p><p id="2853" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io">优点</strong></p><ul class=""><li id="1e16" class="nl nm in jt b ju jv jy jz kc nn kg no kk np ko nq nr ns nt bi translated">递归有助于减少代码的长度，使其更容易读写。</li><li id="f8a7" class="nl nm in jt b ju nu jy nv kc nw kg nx kk ny ko nq nr ns nt bi translated">有些问题更适合递归方法，因为它们本质上是递归的，如树遍历、<a class="ae ml" href="https://www.geeksforgeeks.org/c-program-for-tower-of-hanoi/" rel="noopener ugc nofollow" target="_blank">汉诺塔</a>等。<em class="lq"> </em>对于这类问题，最好是写递归代码。注意——许多重要的算法都使用递归:合并排序、快速排序、斐波那契数列、阶乘问题等。</li></ul><p id="f40c" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io">缺点</strong></p><ul class=""><li id="fa29" class="nl nm in jt b ju jv jy jz kc nn kg no kk np ko nq nr ns nt bi translated">递归会占用更多的内存空间，因为所有的函数都会保留在堆栈中，直到到达基本情况。</li><li id="eb19" class="nl nm in jt b ju nu jy nv kc nw kg nx kk ny ko nq nr ns nt bi translated">递归很容易导致无限循环，因此，如果函数处理不当，计算机可能会耗尽内存(堆栈溢出！)</li><li id="2dd7" class="nl nm in jt b ju nu jy nv kc nw kg nx kk ny ko nq nr ns nt bi translated">虽然递归可以使代码变得简洁，但由于其长度较小，也使代码难以理解——因此在处理递归函数的代码时，必须格外小心。</li></ul><p id="4eeb" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">感谢你阅读这篇博客——我希望你喜欢它，并发现它有所帮助。如果你有任何问题、评论或者只是打个招呼，请通过<a class="ae ml" href="https://www.linkedin.com/in/chiara-caprasi/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>联系我，或者通过 Medium 关注我。</p><p id="70d1" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><em class="lq">保持快乐，继续编码！</em>👩🏻‍💻</p><figure class="mn mo mp mq gt jo"><div class="bz fp l di"><div class="oq or l"/></div></figure></div><div class="ab cl os ot hr ou" role="separator"><span class="ov bw bk ow ox oy"/><span class="ov bw bk ow ox oy"/><span class="ov bw bk ow ox"/></div><div class="ig ih ii ij ik"><h2 id="5820" class="lu kq in bd kr lv lw dn kv lx ly dp kz kc lz ma ld kg mb mc lh kk md me ll mf bi translated">参考资料和有用的资源</h2><ul class=""><li id="f45d" class="nl nm in jt b ju mg jy mh kc oz kg pa kk pb ko nq nr ns nt bi translated">这里有一个非常棒的 10 分钟递归视频，展示了堆栈是如何工作的<a class="ae ml" href="https://www.youtube.com/watch?v=Mv9NEXX1VHc" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=Mv9NEXX1VHc</a></li><li id="abb5" class="nl nm in jt b ju nu jy nv kc nw kg nx kk ny ko nq nr ns nt bi translated"><a class="ae ml" href="https://g.co/kgs/b5Sbzv" rel="noopener ugc nofollow" target="_blank">搜索算法书</a></li></ul><div class="pc pd gp gr pe pf"><a href="https://www.freecodecamp.org/news/how-recursion-works-explained-with-flowcharts-and-a-video-de61f40cb7f9/" rel="noopener  ugc nofollow" target="_blank"><div class="pg ab fo"><div class="ph ab pi cl cj pj"><h2 class="bd io gy z fp pk fr fs pl fu fw im bi translated">递归是如何工作的——用流程图和视频解释</h2><div class="pm l"><h3 class="bd b gy z fp pk fr fs pl fu fw dk translated">Adit Bhargava 的插图(以及本文中的所有内容)&gt;“为了理解递归，首先必须理解…</h3></div><div class="pn l"><p class="bd b dl z fp pk fr fs pl fu fw dk translated">www.freecodecamp.org</p></div></div><div class="po l"><div class="pp l pq pr ps po pt jp pf"/></div></div></a></div></div></div>    
</body>
</html>