<html>
<head>
<title>Connecting to Firestore — Link-Sharing Site Part 3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">连接到 Firestore —链接共享网站第 3 部分</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/connecting-to-firestore-link-sharing-site-part-3-f37ce41a4389?source=collection_archive---------16-----------------------#2022-04-26">https://blog.devgenius.io/connecting-to-firestore-link-sharing-site-part-3-f37ce41a4389?source=collection_archive---------16-----------------------#2022-04-26</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="e9de" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">将 web 应用程序连接到 Firestore。最后，一个工作链接共享网站…</h2></div><h1 id="feef" class="kc kd in bd ke kf kg kh ki kj kk kl km jt kn ju ko jw kp jx kq jz kr ka ks kt bi translated">介绍</h1><p id="ebe7" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">感谢您花时间和我一起创建一个新的链接共享网站。在上一篇文章中，我谈到了我是如何初始化 Firebase 的。今天我要谈谈我是如何将 web 应用程序与 Firebase 的产品结合起来的。特别是，我将介绍我是如何连接 Firestore 的，并为用户提供了一种提交和查看存储在 Firestore 上的链接的方式。</p></div><div class="ab cl lr ls hr lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ig ih ii ij ik"><h1 id="ec50" class="kc kd in bd ke kf ly kh ki kj lz kl km jt ma ju ko jw mb jx kq jz mc ka ks kt bi translated">处理认证</h1><p id="3ecd" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">在<a class="ae lq" href="https://adamjhawley.com/post/2022-03-14-creating-a-link-sharing-site-part-2/#creating-an-sign-up-page" rel="noopener ugc nofollow" target="_blank">之前的文章</a>中，我描述了如何使用 Firebase SDK 函数<code class="fe md me mf mg b"><a class="ae lq" href="https://firebase.google.com/docs/auth/web/password-auth#create_a_password-based_account" rel="noopener ugc nofollow" target="_blank">createUserWithEmailAndPassword()</a></code>将注册表单连接到 Firebase 身份验证。</p><p id="3d2e" class="pw-post-body-paragraph ku kv in kw b kx mh jo kz la mi jr lc ld mj lf lg lh mk lj lk ll ml ln lo lp ig bi translated">即使在注册之后，我认为我必须首先创建一个帐户，然后单独调用一个登录函数。然而，Firebase SDK 使它比这更容易！如果帐户创建成功，用户将自动登录。</p><h2 id="a78a" class="mm kd in bd ke mn mo dn ki mp mq dp km ld mr ms ko lh mt mu kq ll mv mw ks mx bi translated">Web 组件重定向</h2><p id="be2f" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">因此，用户创建了一个帐户并登录。在这一点上，我所知道的大多数网站会将用户重定向回他们之前的页面或另一个特定的页面。为了简单起见，我选择在用户登录时将他们重定向到“浏览”页面。该页面是用户可以“浏览”所有最近添加的链接的页面，它也充当主页(见下文)。</p><figure class="mz na nb nc gt nd gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi my"><img src="../Images/d17e061bec5c29f41b5226549b1cc236.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*6yFr662yq10JcB2W.png"/></div></div></figure><p id="bae2" class="pw-post-body-paragraph ku kv in kw b kx mh jo kz la mi jr lc ld mj lf lg lh mk lj lk ll ml ln lo lp ig bi translated">最初，<code class="fe md me mf mg b">createAccount()</code>看起来是这样的:</p><pre class="mz na nb nc gt nk mg nl nm aw nn bi"><span id="3c86" class="mm kd in mg b gy no np l nq nr">createAccount(email, password) {<br/>  const auth = getAuth();<br/>  createUserWithEmailAndPassword(auth, email, password)<br/>  .then((userCredential) =&gt; {<br/>      const user = userCredential.user;<br/>  })<br/>}</span></pre><p id="a47d" class="pw-post-body-paragraph ku kv in kw b kx mh jo kz la mi jr lc ld mj lf lg lh mk lj lk ll ml ln lo lp ig bi translated">起初，我调用了<code class="fe md me mf mg b">createAccount()</code>，然后立即将用户重定向到一个新页面。<strong class="kw io">没有等待</strong> <code class="fe md me mf mg b"><strong class="kw io">createUserWithEmailAndPassword()</strong></code> <strong class="kw io">的响应。</strong>我很快意识到这是一个问题，账户创建成功与否并不重要。如果用户点击了注册表单中的“提交”按钮，他们就会被重定向、认证或不认证。</p><p id="103c" class="pw-post-body-paragraph ku kv in kw b kx mh jo kz la mi jr lc ld mj lf lg lh mk lj lk ll ml ln lo lp ig bi translated">但是，如果由于使用了无效的电子邮件或密码等错误而没有创建帐户，那么用户界面应该给用户一个修改表单条目的机会。为了解决这个问题，我将我的<code class="fe md me mf mg b">createAccount()</code>逻辑包装在一个<code class="fe md me mf mg b">Promise</code>中:</p><pre class="mz na nb nc gt nk mg nl nm aw nn bi"><span id="1d3a" class="mm kd in mg b gy no np l nq nr">createAccount(email, password) {<br/>  return new Promise ((resolve, reject) =&gt; {<br/>    const auth = getAuth()<br/>    createUserWithEmailAndPassword(auth, email, password)<br/>    .then((userCredential) =&gt; {<br/>        this.user = userCredential.user;<br/>        resolve()<br/>    })<br/>  })<br/>}</span></pre><p id="0119" class="pw-post-body-paragraph ku kv in kw b kx mh jo kz la mi jr lc ld mj lf lg lh mk lj lk ll ml ln lo lp ig bi translated">作为 JavaScript 的相对新手，我仍在努力掌握与<code class="fe md me mf mg b">async</code>、<code class="fe md me mf mg b">await</code>、<code class="fe md me mf mg b">Promise</code>等相关的一切。所以对于新来者，我最近出版了一本关于 JavaScript 承诺入门的指南。</p><h2 id="ac5e" class="mm kd in bd ke mn mo dn ki mp mq dp km ld mr ms ko lh mt mu kq ll mv mw ks mx bi translated">正在登录</h2><p id="0c70" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">用户可以创建账户，万岁！但是他们每次都要注册一个新账户才能登录。对我来说听起来不太用户友好…</p><p id="67e9" class="pw-post-body-paragraph ku kv in kw b kx mh jo kz la mi jr lc ld mj lf lg lh mk lj lk ll ml ln lo lp ig bi translated">尽可能保持简单，我制作了一个和注册页面一模一样的登录页面。唯一的区别是当用户点击“提交”时会发生什么。我的<code class="fe md me mf mg b">signIn()</code>方法和<code class="fe md me mf mg b">createAccount()</code>几乎一模一样。不同的是<code class="fe md me mf mg b">signIn()</code>使用的是<code class="fe md me mf mg b"><a class="ae lq" href="https://firebase.google.com/docs/auth/web/password-auth#sign_in_a_user_with_an_email_address_and_password" rel="noopener ugc nofollow" target="_blank">signInWithEmailAndPassword()</a></code>而不是前面提到的<code class="fe md me mf mg b">createUserWithEmailAndPassword()</code>。</p><figure class="mz na nb nc gt nd gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi ns"><img src="../Images/5ae002e2df1e5e1b1e617c5f28829dc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Wm93OA_sv5Qwkhk3.png"/></div></div></figure><p id="7046" class="pw-post-body-paragraph ku kv in kw b kx mh jo kz la mi jr lc ld mj lf lg lh mk lj lk ll ml ln lo lp ig bi translated"><strong class="kw io">工作签到页面</strong></p><p id="82b4" class="pw-post-body-paragraph ku kv in kw b kx mh jo kz la mi jr lc ld mj lf lg lh mk lj lk ll ml ln lo lp ig bi translated">现在是庆祝的时候了！连接到 Firestore 的工作验证。用户现在可以在网站上创建账户，以后再登录。</p></div><div class="ab cl lr ls hr lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ig ih ii ij ik"><h1 id="0397" class="kc kd in bd ke kf ly kh ki kj lz kl km jt ma ju ko jw mb jx kq jz mc ka ks kt bi translated">Firestore</h1><h2 id="c1dc" class="mm kd in bd ke mn mo dn ki mp mq dp km ld mr ms ko lh mt mu kq ll mv mw ks mx bi translated">添加链接</h2><p id="2a93" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">放到网站的内容上。在<a class="ae lq" href="https://adamjhawley.com/post/2022-04-26-creating-a-link-sharing-site-part-3/#web-component-redirects" rel="noopener ugc nofollow" target="_blank"> web 组件重定向部分</a>和本系列第 1 部分中，我们已经看到了用户将如何查看浏览页面上的链接，我展示了如何创建一个提交链接的页面，但提到提交按钮根本不起作用。是时候改变了！</p><p id="1fbc" class="pw-post-body-paragraph ku kv in kw b kx mh jo kz la mi jr lc ld mj lf lg lh mk lj lk ll ml ln lo lp ig bi translated">我首先创建了一个事件处理程序<code class="fe md me mf mg b">submitLink</code>来处理表单中的提交按钮被按下的情况:</p><pre class="mz na nb nc gt nk mg nl nm aw nn bi"><span id="d3da" class="mm kd in mg b gy no np l nq nr">get _form () {<br/>  return this.renderRoot.querySelector('#submit-form')<br/>}<br/><br/>async submitLink (e) {<br/>  let userTitle = this._form.querySelector('#title-input').value<br/>  let userLink = this._form.querySelector('#link-input').value<br/>  const db = getFirestore(this.app);<br/>  let col = collection(db, 'links')<br/>  await addDoc(col, {<br/>    link: userLink,<br/>    title: userTitle<br/>  })<br/><br/>  const event = new CustomEvent('submitted-link')<br/>  this.dispatchEvent(event)<br/>}</span></pre><p id="d440" class="pw-post-body-paragraph ku kv in kw b kx mh jo kz la mi jr lc ld mj lf lg lh mk lj lk ll ml ln lo lp ig bi translated">我还修改了模板中的提交按钮，以使用新的<code class="fe md me mf mg b">submitLink</code>处理程序:</p><pre class="mz na nb nc gt nk mg nl nm aw nn bi"><span id="e25d" class="mm kd in mg b gy no np l nq nr">&lt;sl-button @click=${this.submitLink}&gt;Submit&lt;/sl-button&gt;<!-- --> </span></pre><p id="3048" class="pw-post-body-paragraph ku kv in kw b kx mh jo kz la mi jr lc ld mj lf lg lh mk lj lk ll ml ln lo lp ig bi translated">在 Firebase 方面，我从使用<a class="ae lq" href="https://firebase.google.com/docs/firestore/quickstart#initialize" rel="noopener ugc nofollow" target="_blank"> getFirestore() </a>开始。我将<code class="fe md me mf mg b">this.app</code>传递给<code class="fe md me mf mg b">getFirestore()</code>，其中<code class="fe md me mf mg b">this.app</code>是传递给 web 组件的属性，等于<code class="fe md me mf mg b"><a class="ae lq" href="https://firebase.google.com/docs/firestore/quickstart#initialize" rel="noopener ugc nofollow" target="_blank">initializeApp()</a></code>的输出。第一行的目的是通过访问数据库初始化一个变量。</p><p id="d1db" class="pw-post-body-paragraph ku kv in kw b kx mh jo kz la mi jr lc ld mj lf lg lh mk lj lk ll ml ln lo lp ig bi translated">然后我定义了<code class="fe md me mf mg b">col</code>，一个可以访问数据库中特定集合的变量:</p><pre class="mz na nb nc gt nk mg nl nm aw nn bi"><span id="557b" class="mm kd in mg b gy no np l nq nr">let col = collection(db, 'links')</span></pre><p id="945a" class="pw-post-body-paragraph ku kv in kw b kx mh jo kz la mi jr lc ld mj lf lg lh mk lj lk ll ml ln lo lp ig bi translated">最后一步是将包含链接的文档添加到集合中:</p><pre class="mz na nb nc gt nk mg nl nm aw nn bi"><span id="330e" class="mm kd in mg b gy no np l nq nr">await addDoc(col, {<br/>  link: userLink,<br/>  title: userTitle<br/>})</span></pre><p id="6859" class="pw-post-body-paragraph ku kv in kw b kx mh jo kz la mi jr lc ld mj lf lg lh mk lj lk ll ml ln lo lp ig bi translated">如果此操作成功，那么我们已经将链接添加到数据库中！接下来，我使用与前面描述的<a class="ae lq" href="https://adamjhawley.com/post/2022-04-26-creating-a-link-sharing-site-part-3/#web-component-redirects" rel="noopener ugc nofollow" target="_blank">相同的策略</a>通过分派一个定制事件将用户重定向到一个新页面。</p><h2 id="401c" class="mm kd in bd ke mn mo dn ki mp mq dp km ld mr ms ko lh mt mu kq ll mv mw ks mx bi translated">阅读链接</h2><p id="b73d" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">幸运的是，从 Firestore 上阅读和在上面写作非常相似。下面是我用来从 links 集合中获取所有可用链接的代码行:</p><pre class="mz na nb nc gt nk mg nl nm aw nn bi"><span id="ab13" class="mm kd in mg b gy no np l nq nr">const db = getFirestore(this.app)<br/>let col = collection(db, 'links')<br/>const querySnapshot = await getDocs(col)<br/>querySnapshot.forEach((doc) =&gt; {<br/>  this.linkBoxes.push(doc.data())<br/>})</span></pre><p id="3544" class="pw-post-body-paragraph ku kv in kw b kx mh jo kz la mi jr lc ld mj lf lg lh mk lj lk ll ml ln lo lp ig bi translated">前两行与写作完全相同，并完全遵循我在<a class="ae lq" href="https://adamjhawley.com/post/2022-04-26-creating-a-link-sharing-site-part-3/#adding-links" rel="noopener ugc nofollow" target="_blank">上一部分</a>中描述的内容。事情在第三行有一点变化。</p><p id="7545" class="pw-post-body-paragraph ku kv in kw b kx mh jo kz la mi jr lc ld mj lf lg lh mk lj lk ll ml ln lo lp ig bi translated">一个<code class="fe md me mf mg b"><a class="ae lq" href="https://firebase.google.com/docs/reference/js/v8/firebase.firestore.QuerySnapshot" rel="noopener ugc nofollow" target="_blank">querySnapshot</a></code>包含一个查询的结果。通过对整个集合<code class="fe md me mf mg b">col</code>使用<code class="fe md me mf mg b">getDocs()</code>，我要求将集合中的所有文档返回到变量<code class="fe md me mf mg b">querySnapshot</code>中。</p><p id="6119" class="pw-post-body-paragraph ku kv in kw b kx mh jo kz la mi jr lc ld mj lf lg lh mk lj lk ll ml ln lo lp ig bi translated">一旦查询被解析，我将遍历每个文档，并将它们添加到浏览页面上显示的链接列表中。</p><blockquote class="nt nu nv"><p id="e11f" class="ku kv nw kw b kx mh jo kz la mi jr lc nx mj lf lg ny mk lj lk nz ml ln lo lp ig bi translated">注意:要访问每个文档的内容，您必须遍历每个文档并调用它的<code class="fe md me mf mg b">.data()</code>方法。</p></blockquote><p id="260a" class="pw-post-body-paragraph ku kv in kw b kx mh jo kz la mi jr lc ld mj lf lg lh mk lj lk ll ml ln lo lp ig bi translated">这就是全部了！链接提交工作，现在主页是使用用户正确提交的链接填充的。</p></div><div class="ab cl lr ls hr lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ig ih ii ij ik"><h1 id="23a8" class="kc kd in bd ke kf ly kh ki kj lz kl km jt ma ju ko jw mb jx kq jz mc ka ks kt bi translated">结论</h1><p id="812f" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">在本次更新中，我讨论了:</p><ul class=""><li id="4ed2" class="oa ob in kw b kx mh la mi ld oc lh od ll oe lp of og oh oi bi translated"><a class="ae lq" href="https://adamjhawley.com/post/2022-04-26-creating-a-link-sharing-site-part-3/#web-component-redirects" rel="noopener ugc nofollow" target="_blank">我如何使用 JavaScript 承诺执行重定向</a></li><li id="2158" class="oa ob in kw b kx oj la ok ld ol lh om ll on lp of og oh oi bi translated"><a class="ae lq" href="https://adamjhawley.com/post/2022-04-26-creating-a-link-sharing-site-part-3/#signing-in" rel="noopener ugc nofollow" target="_blank">签到页面是如何产生的</a></li><li id="1bc9" class="oa ob in kw b kx oj la ok ld ol lh om ll on lp of og oh oi bi translated"><a class="ae lq" href="https://adamjhawley.com/post/2022-04-26-creating-a-link-sharing-site-part-3/#adding-links" rel="noopener ugc nofollow" target="_blank">用户如何获得提交链接的能力</a></li><li id="74b2" class="oa ob in kw b kx oj la ok ld ol lh om ll on lp of og oh oi bi translated"><a class="ae lq" href="https://adamjhawley.com/post/2022-04-26-creating-a-link-sharing-site-part-3/#reading-links" rel="noopener ugc nofollow" target="_blank">主页如何动态加载 Firestore 的链接</a></li></ul><p id="acb6" class="pw-post-body-paragraph ku kv in kw b kx mh jo kz la mi jr lc ld mj lf lg lh mk lj lk ll ml ln lo lp ig bi translated">我真诚地希望你喜欢这个更新。如果你想知道我什么时候发布更多更新，可以考虑在<a class="ae lq" href="https://medium.com/@adamjhawley" rel="noopener"> Medium </a>上关注我，或者在<a class="ae lq" href="https://twitter.com/_adamjhawley" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上关注我。</p><p id="4bfe" class="pw-post-body-paragraph ku kv in kw b kx mh jo kz la mi jr lc ld mj lf lg lh mk lj lk ll ml ln lo lp ig bi translated"><em class="nw">原载于</em><a class="ae lq" href="https://adamjhawley.com/post/2022-04-26-creating-a-link-sharing-site-part-3/" rel="noopener ugc nofollow" target="_blank"><em class="nw">https://adamjhawley.com</em></a><em class="nw">。</em></p></div></div>    
</body>
</html>