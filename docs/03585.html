<html>
<head>
<title>Functional JavaScript — Monads</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">函数式JavaScript —单子</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/functional-javascript-monads-dd7416cc2b8e?source=collection_archive---------2-----------------------#2020-11-21">https://blog.devgenius.io/functional-javascript-monads-dd7416cc2b8e?source=collection_archive---------2-----------------------#2020-11-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/818973de63c905b8bc1bc817088ebdc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jeaMimdTHI-GOMbo"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@jamie452?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">杰米街</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="5c13" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JavaScript部分是一种函数式语言。</p><p id="7b04" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要学习JavaScript，我们必须学习JavaScript的功能部分。</p><p id="6eb1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将看看如何用JavaScript来传输函数和函子。</p><h1 id="863b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">也许是函子</h1><p id="3e60" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">一个可能函子是让我们以不同的方式实现一个<code class="fe me mf mg mh b">map</code>函数的函子。</p><p id="a7c5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们首先创建一个存储值的构造函数:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="1082" class="mq lc iq mh b gy mr ms l mt mu">const MayBe = function(val) {<br/>  this.value = val;<br/>}</span><span id="d8aa" class="mq lc iq mh b gy mv ms l mt mu">MayBe.of = function(val) {<br/>  return new MayBe(val);<br/>}</span></pre><p id="25c1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们添加<code class="fe me mf mg mh b">MayBe</code>仿函数特有的方法。</p><p id="5b2b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有<code class="fe me mf mg mh b">isNothing</code>方法来检查<code class="fe me mf mg mh b">this.value</code>是否有问题。</p><p id="0ddc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">根据<code class="fe me mf mg mh b">this.value</code>是否有东西，<code class="fe me mf mg mh b">map</code>方法将返回不同的东西。</p><p id="2dab" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们补充:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="6cd5" class="mq lc iq mh b gy mr ms l mt mu">MayBe.prototype.isNothing = function() {<br/>  return (this.value === null || this.value === undefined);<br/>};</span><span id="bbad" class="mq lc iq mh b gy mv ms l mt mu">MayBe.prototype.map = function(fn) {<br/>  return this.isNothing() ? MayBe.of(null) : MayBe.of(fn(this.value));<br/>};</span></pre><p id="5288" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们共同拥有:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="fee2" class="mq lc iq mh b gy mr ms l mt mu">const MayBe = function(val) {<br/>  this.value = val;<br/>}</span><span id="e3a3" class="mq lc iq mh b gy mv ms l mt mu">MayBe.of = function(val) {<br/>  return new MayBe(val);<br/>}</span><span id="7986" class="mq lc iq mh b gy mv ms l mt mu">MayBe.prototype.isNothing = function() {<br/>  return (this.value === null || this.value === undefined);<br/>};</span><span id="bf28" class="mq lc iq mh b gy mv ms l mt mu">MayBe.prototype.map = function(fn) {<br/>  return this.isNothing() ? MayBe.of(null) : MayBe.of(fn(this.value));<br/>};</span></pre><p id="7a84" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以通过写来使用它:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="3ecf" class="mq lc iq mh b gy mr ms l mt mu">const str = MayBe.of("foo").map((x) =&gt; x.toUpperCase())</span></pre><p id="8054" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到<code class="fe me mf mg mh b">MayBe</code>实例的<code class="fe me mf mg mh b">value</code>属性是<code class="fe me mf mg mh b">'FOO'</code>。</p><p id="a5ab" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果<code class="fe me mf mg mh b">this.value</code>为<code class="fe me mf mg mh b">null</code>或<code class="fe me mf mg mh b">undefined</code>，那么<code class="fe me mf mg mh b">map</code>将返回一个<code class="fe me mf mg mh b">MayBe</code>函子，其中<code class="fe me mf mg mh b">value</code>为<code class="fe me mf mg mh b">null</code>。</p><p id="eb74" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以如果我们有这样的东西:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="7e7e" class="mq lc iq mh b gy mr ms l mt mu">const str = MayBe.of("james")<br/>  .map(() =&gt; undefined)<br/>  .map((x) =&gt; `Mr. ${x}`)</span></pre><p id="d73d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将得到<code class="fe me mf mg mh b">value</code>的最终值为<code class="fe me mf mg mh b">null</code>，而不是抛出一个错误。</p><h1 id="aac2" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">任一函子</h1><p id="1e21" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe me mf mg mh b">Either</code>仿函数允许我们用分支来解决问题。</p><p id="f3d1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们创建一个<code class="fe me mf mg mh b">Nothing</code>或<code class="fe me mf mg mh b">Some</code>函子，并在一个对象中取出它们。</p><p id="9abb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们写道:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="11f5" class="mq lc iq mh b gy mr ms l mt mu">const Nothing = function(val) {<br/>  this.value = val;<br/>};</span><span id="c29b" class="mq lc iq mh b gy mv ms l mt mu">Nothing.of = function(val) {<br/>  return new Nothing(val);<br/>};</span><span id="951f" class="mq lc iq mh b gy mv ms l mt mu">Nothing.prototype.map = function(f) {<br/>  return this;<br/>};</span><span id="250e" class="mq lc iq mh b gy mv ms l mt mu">const Some = function(val) {<br/>  this.value = val;<br/>};</span><span id="f169" class="mq lc iq mh b gy mv ms l mt mu">Some.of = function(val) {<br/>  return new Some(val);<br/>};</span><span id="7e8f" class="mq lc iq mh b gy mv ms l mt mu">Some.prototype.map = function(fn) {<br/>  return Some.of(fn(this.value));<br/>}</span></pre><p id="471e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在如果想保存一些数据，那么我们可以使用<code class="fe me mf mg mh b">Some</code>函子。</p><p id="9c01" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">否则，我们使用<code class="fe me mf mg mh b">Nothing</code>仿函数来保存一些不存在的值。</p><h1 id="0d67" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">单子</h1><p id="d313" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">单子是一个带有<code class="fe me mf mg mh b">chain</code>方法的函子。</p><p id="4e6e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果<code class="fe me mf mg mh b">this.value</code>有值，<code class="fe me mf mg mh b">chain</code>方法调用<code class="fe me mf mg mh b">join</code>方法来调用它返回一个<code class="fe me mf mg mh b">MayBe</code>实例。</p><p id="db08" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="15ad" class="mq lc iq mh b gy mr ms l mt mu">const MayBe = function(val) {<br/>  this.value = val;<br/>}</span><span id="e04f" class="mq lc iq mh b gy mv ms l mt mu">MayBe.of = function(val) {<br/>  return new MayBe(val);<br/>}</span><span id="cb30" class="mq lc iq mh b gy mv ms l mt mu">MayBe.prototype.isNothing = function() {<br/>  return (this.value === null || this.value === undefined);<br/>};</span><span id="dfed" class="mq lc iq mh b gy mv ms l mt mu">MayBe.prototype.map = function(fn) {<br/>  return this.isNothing() ? MayBe.of(null) : MayBe.of(fn(this.value));<br/>};</span><span id="1eba" class="mq lc iq mh b gy mv ms l mt mu">MayBe.prototype.join = function() {<br/>  return this.isNothing() ? MayBe.of(null) : this.value;<br/>}</span><span id="7e3d" class="mq lc iq mh b gy mv ms l mt mu">MayBe.prototype.chain = function(f) {<br/>  return this.map(f).join()<br/>}</span></pre><p id="84f4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">join</code>方法检查<code class="fe me mf mg mh b">this.value</code>是<code class="fe me mf mg mh b">null</code>还是<code class="fe me mf mg mh b">undefined</code>。</p><p id="f4b0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果是，那么我们返回一个<code class="fe me mf mg mh b">null</code> <code class="fe me mf mg mh b">MayBe</code>函子。</p><p id="473c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">否则，我们返回<code class="fe me mf mg mh b">this.value</code>。</p><p id="81fe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">chain</code>就是把<code class="fe me mf mg mh b">map</code>和<code class="fe me mf mg mh b">join</code>合在一起。</p><p id="bc8d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样，如果我们将某个东西映射到<code class="fe me mf mg mh b">null</code>，那么它将保持<code class="fe me mf mg mh b">null</code>。</p><p id="d8fd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么我们可以这样写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="3439" class="mq lc iq mh b gy mr ms l mt mu">let mayBe = MayBe.of({<br/>  data: [{<br/>    title: 'foo',<br/>    children: [{<br/>      bar: 2<br/>    }]<br/>  }]<br/>})</span><span id="3c66" class="mq lc iq mh b gy mv ms l mt mu">let ans = mayBe.map((arr) =&gt; arr.data)<br/>  .chain((obj) =&gt; map(obj, (x) =&gt; {<br/>    return {<br/>      title: x.title<br/>    }<br/>  }))</span></pre><p id="282d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们从传递给<code class="fe me mf mg mh b">of</code>的对象中获取<code class="fe me mf mg mh b">title</code>。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/719f33ae4ff44124cdcb12bd9bcdfb1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*x9xTuvKoAERI6TNz"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://unsplash.com/@johnprice?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">约翰·普莱斯</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="5be7" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="8d83" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">单子是一个具有<code class="fe me mf mg mh b">chain</code>方法的函子，它执行映射和连接。</p></div></div>    
</body>
</html>