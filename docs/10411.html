<html>
<head>
<title>Stepping through PostgreSQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">逐步执行 PostgreSQL</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/stepping-through-postgresql-f40990685a56?source=collection_archive---------11-----------------------#2022-10-31">https://blog.devgenius.io/stepping-through-postgresql-f40990685a56?source=collection_archive---------11-----------------------#2022-10-31</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="a93b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Postgres 是世界上最受欢迎、最常用和最受欢迎的数据库之一，我们中的一些人想看看它是如何创造奇迹的，这是毫无疑问的。在寻找相同的东西时，我惊讶地发现，通过逐步完成 postgres 后端过程，浏览 Postgres 代码库是多么容易。本文可以作为快速探索 postgres 代码库的参考指南。</p><p id="a096" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">注意:我强烈建议您在阅读本文时设置一个测试机器(vm)并运行实时 Postgres 系统。</p><p id="2912" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">GDB 快速指南</strong></p><ol class=""><li id="39ed" class="ki kj in jm b jn jo jr js jv kk jz kl kd km kh kn ko kp kq bi translated">要附加到一个进程:<em class="kr">sudo GD b-p&lt;PID&gt;T3】</em></li><li id="9884" class="ki kj in jm b jn ks jr kt jv ku jz kv kd kw kh kn ko kp kq bi translated">附加断点:<em class="kr">中断&lt;文件&gt; : &lt;行号&gt; </em></li><li id="b094" class="ki kj in jm b jn ks jr kt jv ku jz kv kd kw kh kn ko kp kq bi translated">运行到断点:<em class="kr"> c </em></li><li id="e01e" class="ki kj in jm b jn ks jr kt jv ku jz kv kd kw kh kn ko kp kq bi translated">单步<em class="kr">进入</em>功能:<em class="kr"> s </em></li><li id="bcc1" class="ki kj in jm b jn ks jr kt jv ku jz kv kd kw kh kn ko kp kq bi translated">步骤<em class="kr">越过</em>功能:<em class="kr"> n </em></li><li id="ba8f" class="ki kj in jm b jn ks jr kt jv ku jz kv kd kw kh kn ko kp kq bi translated">打印一个值:<em class="kr"> p &lt;变量&gt;T17】或<em class="kr"> p * &lt;变量&gt;T19】</em></em></li><li id="41bd" class="ki kj in jm b jn ks jr kt jv ku jz kv kd kw kh kn ko kp kq bi translated">调用函数:<em class="kr">调用&lt;func&gt;T21】</em></li><li id="3df1" class="ki kj in jm b jn ks jr kt jv ku jz kv kd kw kh kn ko kp kq bi translated">打印 postgres 节点:<em class="kr">调用 pprint( &lt; mem 地址&gt; ) </em></li><li id="2136" class="ki kj in jm b jn ks jr kt jv ku jz kv kd kw kh kn ko kp kq bi translated">按下<em class="kr">回车</em>键重复上一条命令。</li></ol><p id="60c3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">注意:在阅读本文时，您可能会迷路，在这种情况下，请完成当前的执行，在您应该在的函数上添加一个新的断点，执行查询并再次运行调试器。</p><h1 id="31b6" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated"><strong class="ak">设置</strong></h1><p id="b4b1" class="pw-post-body-paragraph jk jl in jm b jn lv jp jq jr lw jt ju jv lx jx jy jz ly kb kc kd lz kf kg kh ig bi translated">让我们克隆最新的 postgres(在我的例子中是 16devel)并用调试符号构建它。在开始之前，确保你有合适的构建工具(gcc 通过 build-essentials 等)。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="1ce1" class="mj ky in mf b gy mk ml l mm mn">git clone <a class="ae mo" href="https://git.postgresql.org/git/postgresql.git" rel="noopener ugc nofollow" target="_blank">https://git.postgresql.org/git/postgresql.git</a></span><span id="81c4" class="mj ky in mf b gy mp ml l mm mn"># I highly recommend checking out this commit so that<br/># functions/files which I mention here remains consistent<br/>git checkout 5543677ec90a15c73dab5ed4f0902b3b920f0b87</span><span id="47ef" class="mj ky in mf b gy mp ml l mm mn">./configure   --enable-debug<br/>make -j4<br/>sudo make install</span><span id="62e7" class="mj ky in mf b gy mp ml l mm mn">sudo adduser postgres<br/>sudo mkdir /usr/local/pgsql/data<br/>chown postgres /usr/local/pgsql/data</span><span id="23d5" class="mj ky in mf b gy mp ml l mm mn"># start postgres with output to stdout (keep this terminal open)<br/>/usr/local/pgsql/bin/postgres -D /usr/local/pgsql/data <br/></span></pre><p id="0426" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">准备 psql 客户端:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="a415" class="mj ky in mf b gy mk ml l mm mn">sudo su postgres</span><span id="d0ba" class="mj ky in mf b gy mp ml l mm mn"># create a dummy db<br/>/usr/local/pgsql/bin/createdb test</span><span id="8267" class="mj ky in mf b gy mp ml l mm mn"># open psql<br/>/usr/local/pgsql/bin/psql test</span></pre><p id="1d22" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">创建一个虚拟表并插入一些值:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="c501" class="mj ky in mf b gy mk ml l mm mn">create table t(id int);</span><span id="06bb" class="mj ky in mf b gy mp ml l mm mn">insert into t values(1);<br/>insert into t values(2);<br/>insert into t values(10);</span></pre><p id="41ea" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Postgres 主后端进程在 src/backend/tcop/postgres.c 中的<em class="kr"> PostgresMain </em>处定义，后端进程的初始化发生在这里。让我们读一点代码。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="6427" class="mj ky in mf b gy mk ml l mm mn">InitPostgres(dbname, InvalidOid,   /* database to connect to */<br/>username, InvalidOid,  /* role to connect as */<br/>!am_walsender, /* honor session_preload_libraries? */<br/>false,         /* don't ignore datallowconn */<br/>NULL);         /* no out_dbname */</span></pre><p id="55e7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">主循环:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="1805" class="mj ky in mf b gy mk ml l mm mn">for (;;)<br/>{</span><span id="46de" class="mj ky in mf b gy mp ml l mm mn">...</span></pre><p id="49a7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">设置连接状态</p><p id="93ef" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="kr">set _ PS _ display(" idle in transaction ")</em>或<em class="kr"> set_ps_display("idle") </em>取决于<em class="kr">IsTransactionOrTransactionBlock()。</em></p><p id="6cea" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">诸如此类。</p><p id="34d6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们现在可以走了，让我们开始吧:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="812e" class="mj ky in mf b gy mk ml l mm mn">SELECT pg_backend_pid();</span></pre><p id="e95e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这将为我们提供 postgres 后端进程 id。我们将把它附在 gdb 上。</p><p id="404c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在新终端中，运行</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="9d91" class="mj ky in mf b gy mk ml l mm mn">sudo gdb -p &lt;pid from above&gt;</span></pre><p id="14da" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">它应该正确加载调试符号:</p><figure class="ma mb mc md gt mr gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi mq"><img src="../Images/a5737a2d51051b3c7262baf69b4e5642.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9N1qB1XCaYWnXk6pIikidQ.png"/></div></div></figure><p id="da89" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">添加断点，例如<em class="kr">first char = read command(&amp;input _ message)</em>其中<em class="kr"> </em>位于 src/back end/tcop/postgres . c:4483</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="2433" class="mj ky in mf b gy mk ml l mm mn">break src/backend/tcop/postgres.c:4483</span></pre><p id="f097" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在 psql 中，运行一些查询，比如:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="da62" class="mj ky in mf b gy mk ml l mm mn">select * from t where id &gt; 1 and id &lt; 10;</span></pre><p id="9149" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你可以选择<em class="kr">继续</em>到断点(按 c)或者观察事情如何从头开始(继续按 n)。</p><p id="54f0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在后一种情况下，您会看到一些 WaitEvents 和网络 i/o 来接收输入包。</p><figure class="ma mb mc md gt mr gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi my"><img src="../Images/afb86af5441400af0360f0354e32072f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jvCkHDkHlBHOImaz3O7opg.png"/></div></div></figure><p id="c1fb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您可以继续按 n(或按 enter)并观察控制流。你会注意到很多<em class="kr">检查中断</em>()。</p><p id="9517" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">中断处理在 src/backend/tcop/postgres.c 中的<em class="kr"> ProcessInterrupts </em>中定义。</p><p id="4b6a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">不管怎样，继续吧。</p><figure class="ma mb mc md gt mr gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/5940a233bfd99501fe73b3dca1a5d278.png" data-original-src="https://miro.medium.com/v2/resize:fit:962/format:webp/1*hjTOoggu6LO95P9s5JJfnQ.png"/></div><figcaption class="na nb gj gh gi nc nd bd b be z dk translated">打印首字符</figcaption></figure><p id="192c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">还记得<em class="kr">first char = read command(&amp;input _ message)吗？</em>它读取我们的输入并转储<em class="kr">first char</em>(81)</p><p id="ca48" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">十进制 81 是 ASCII 中的字符 Q。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="36a4" class="mj ky in mf b gy mk ml l mm mn">switch (firstchar)<br/>  {<br/>   case 'Q':   /* simple query */<br/>    {<br/>     const char *query_string;</span><span id="dfc7" class="mj ky in mf b gy mp ml l mm mn">/* Set statement_timestamp() */<br/>     SetCurrentStatementStartTimestamp();</span><span id="cef3" class="mj ky in mf b gy mp ml l mm mn">query_string = pq_getmsgstring(&amp;input_message);<br/>     pq_getmsgend(&amp;input_message);</span><span id="9c59" class="mj ky in mf b gy mp ml l mm mn">if (am_walsender)<br/>     {<br/>      if (!exec_replication_command(query_string))<br/>       exec_simple_query(query_string);<br/>     }<br/>     else<br/>      exec_simple_query(query_string);</span><span id="fdfd" class="mj ky in mf b gy mp ml l mm mn">send_ready_for_query = true;<br/>    }<br/>    break;</span></pre><p id="daa6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这里，我们要去的情况' Q '。我们可以在这里验证我们的查询字符串。</p><figure class="ma mb mc md gt mr gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/c995556da276f8f9a3f7479c55e7da8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1374/format:webp/1*3gAO_B0RIz6fpITr7FPkDQ.png"/></div></figure><p id="f56e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最后<em class="kr">exec _ simple _ query(query _ string)</em>被调用。我们需要介入此事(新闻界)</p><figure class="ma mb mc md gt mr gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi nf"><img src="../Images/1d4d4f3659a4d56b87e009a4bc4fcf4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eC2Dbcx_UEjPET6crgOe5g.png"/></div></div></figure><p id="8091" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">两步，你就会找到 pgstat _ report _ activity(STATE _ RUNNING，query_string)。pgstat_report_activity 在 src/back end/utils/activity/back end _ status . c 中定义。</p><p id="349b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">后端状态被定义为枚举:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="c2d8" class="mj ky in mf b gy mk ml l mm mn">typedef enum BackendState<br/>{<br/> STATE_UNDEFINED,<br/> STATE_IDLE,<br/> STATE_RUNNING,<br/> STATE_IDLEINTRANSACTION,<br/> STATE_FASTPATH,<br/> STATE_IDLEINTRANSACTION_ABORTED,<br/> STATE_DISABLED<br/>} BackendState;</span></pre><p id="ea8b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这可以方便地转换成在 src/back end/utils/ADT/pgstatfuncs . c 中定义的 pg_stat_get_activity()中的常用符号。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="db55" class="mj ky in mf b gy mk ml l mm mn">switch (beentry-&gt;st_state)<br/>   {<br/>    case STATE_IDLE:<br/>     values[4] = CStringGetTextDatum("idle");<br/>     break;<br/>    case STATE_RUNNING:<br/>     values[4] = CStringGetTextDatum("active");<br/>     break;<br/>    case STATE_IDLEINTRANSACTION:<br/>     values[4] = CStringGetTextDatum("idle in transaction");<br/>     break;<br/>    case STATE_FASTPATH:<br/>     values[4] = CStringGetTextDatum("fastpath function call");<br/>     break;<br/>    case STATE_IDLEINTRANSACTION_ABORTED:<br/>     values[4] = CStringGetTextDatum("idle in transaction (aborted)");<br/>     break;<br/>    case STATE_DISABLED:<br/>     values[4] = CStringGetTextDatum("disabled");<br/>     break;<br/>    case STATE_UNDEFINED:<br/>     nulls[4] = true;<br/>     break;<br/>   }</span></pre><p id="5ec8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">好的，查询状态正在运行。</p><p id="a016" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们到达<em class="kr"> start_xact_command </em>(在 src/backend/tcop/postgres.c 中定义)</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="60cc" class="mj ky in mf b gy mk ml l mm mn">/*<br/> * Convenience routines for starting/committing a single command.<br/> */<br/>static void<br/>start_xact_command(void)<br/>{<br/> if (!xact_started)<br/> {<br/>  StartTransactionCommand();</span><span id="2df5" class="mj ky in mf b gy mp ml l mm mn">xact_started = true;<br/> }</span><span id="9b50" class="mj ky in mf b gy mp ml l mm mn">/*<br/>  * Start statement timeout if necessary.  Note that this'll intentionally<br/>  * not reset the clock on an already started timeout, to avoid the timing<br/>  * overhead when start_xact_command() is invoked repeatedly, without an<br/>  * interceding finish_xact_command() (e.g. parse/bind/execute).  If that's<br/>  * not desired, the timeout has to be disabled explicitly.<br/>  */<br/> enable_statement_timeout();</span><span id="f378" class="mj ky in mf b gy mp ml l mm mn">/* Start timeout for checking if the client has gone away if necessary. */<br/> if (client_connection_check_interval &gt; 0 &amp;&amp;<br/>  IsUnderPostmaster &amp;&amp;<br/>  MyProcPort &amp;&amp;<br/>  !get_timeout_active(CLIENT_CONNECTION_CHECK_TIMEOUT))<br/>  enable_timeout_after(CLIENT_CONNECTION_CHECK_TIMEOUT,<br/>        client_connection_check_interval);<br/>}</span></pre><p id="4acf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">好吧，有道理。继续前进，我们遇到了<em class="kr"> memoryContext </em>，它切换到了<em class="kr">未命名的预准备语句(</em>非常简洁)！继续前进，直到到达<em class="kr">parsetree _ list = pg _ parse _ query(query _ string)</em></p><p id="4ae6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">调用 n(而不是单步执行，因为我们不打算查看解析是如何工作的)和<em class="kr"> p parsetree_list </em>来获取它的地址。现在让我们打印 parsetree。</p><p id="c791" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="kr">调用 pprint(&lt;mem _ address&gt;)</em>并查看 postgres 进程的输出。</p><figure class="ma mb mc md gt mr gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi nf"><img src="../Images/f83be3d2e6efc0c18f1fc2116ed82f7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bMRARoeZqr8AfRUSXqvjBg.png"/></div></div></figure><p id="e413" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在 postgres 后端标准输出中:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="7096" class="mj ky in mf b gy mk ml l mm mn">(<br/>   {RAWSTMT <br/>   :stmt <br/>      {SELECTSTMT <br/>      :distinctClause &lt;&gt; <br/>      :intoClause &lt;&gt; <br/>      :targetList (<br/>         {RESTARGET <br/>         :name &lt;&gt; <br/>         :indirection &lt;&gt; <br/>         :val <br/>            {COLUMNREF <br/>            :fields (<br/>               {A_STAR<br/>               }<br/>            )<br/>            :location 7<br/>            }<br/>         :location 7<br/>         }<br/>      )<br/>      :fromClause (<br/>         {RANGEVAR <br/>         :schemaname &lt;&gt; <br/>         :relname t <br/>         :inh true <br/>         :relpersistence p <br/>         :alias &lt;&gt; <br/>         :location 14<br/>         }<br/>      )<br/>      :whereClause <br/>         {BOOLEXPR <br/>         :boolop and <br/>         :args (<br/>            {A_EXPR <br/>            :name ("&gt;")<br/>            :lexpr <br/>               {COLUMNREF <br/>               :fields ("id")<br/>               :location 22<br/>               }<br/>            :rexpr <br/>               {A_CONST <br/>               :val 1 <br/>               :location 27<br/>               }<br/>            :location 25<br/>            }<br/>            {A_EXPR <br/>            :name ("\&lt;")<br/>            :lexpr <br/>               {COLUMNREF <br/>               :fields ("id")<br/>               :location 33<br/>               }<br/>            :rexpr <br/>               {A_CONST <br/>               :val 10 <br/>               :location 38<br/>               }<br/>            :location 36<br/>            }<br/>         )<br/>         :location 29<br/>         }<br/>      :groupClause &lt;&gt; <br/>      :groupDistinct false <br/>      :havingClause &lt;&gt; <br/>      :windowClause &lt;&gt; <br/>      :valuesLists &lt;&gt; <br/>      :sortClause &lt;&gt; <br/>      :limitOffset &lt;&gt; <br/>      :limitCount &lt;&gt; <br/>      :limitOption 0 <br/>      :lockingClause &lt;&gt; <br/>      :withClause &lt;&gt; <br/>      :op 0 <br/>      :all false <br/>      :larg &lt;&gt; <br/>      :rarg &lt;&gt;<br/>      }<br/>   :stmt_location 0 <br/>   :stmt_len 40<br/>   }<br/>)</span></pre><p id="da61" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是原始的解析树(称为抽象语法树，简称 AST)。让我们继续前进，直到到达<em class="kr">raw stmt * parsetree = lfirst _ node(raw stmt，parsetree_item) </em></p><figure class="ma mb mc md gt mr gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi nf"><img src="../Images/b4ef463e4b0ae525d2d571e3e60f5e9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0Exlk8Eyrm4BvhHQphDx5w.png"/></div></div></figure><p id="d51a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在本例中，<em class="kr"> lfirst_node </em>与之前打印的解析树相同(所以我们只有一个节点)。</p><p id="acf1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="kr">commandTag = CreateCommandTag(parse tree-&gt;stmt)</em></p><p id="672e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">其中 commandTag 是 CMDTAG_SELECT，它被传递给 set _ PS _ display(GetCommandTagName(commandTag))以用于状态显示。</p><p id="3364" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们最终到达<em class="kr"> BeginCommand(commandTag，dest)，</em>recall commandTag = CMDTAG _ SELECT，dest=DestRemote。因为我们没有把 parsetree 传递到这里，所以这里必须做一些其他的事情。</p><blockquote class="ng nh ni"><p id="6abf" class="jk jl kr jm b jn jo jp jq jr js jt ju nj jw jx jy nk ka kb kc nl ke kf kg kh ig bi translated">BeginCommand —在命令开始时初始化目标</p></blockquote><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="0af0" class="mj ky in mf b gy mk ml l mm mn">void<br/>BeginCommand(CommandTag commandTag, CommandDest dest)<br/>{<br/> /* Nothing to do at present */<br/>}</span></pre><p id="58c0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">BeginCommand 是在 src/backend/tcop/dest.c 中定义的，除非我遗漏了什么，否则它并没有做什么令人印象深刻的事情。继续前进。</p><p id="3478" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们找到另一个 start_xact_command()并检查 _FOR_INTERRUPTS，这很好。Postgres 已经解析了我们的查询，但还没有创建计划或开始任何执行。</p><p id="5024" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这一点上可以看到一个非常重要的注释。</p><blockquote class="ng nh ni"><p id="4522" class="jk jl kr jm b jn jo jp jq jr js jt ju nj jw jx jy nk ka kb kc nl ke kf kg kh ig bi translated">/* <br/> *如果使用隐式事务块，并且我们还没有在<br/> *事务块中，则启动一个隐式块来强制将该语句<br/> *与任何后续语句组合在一起。(我们每次通过循环都必须这样做<br/>*；否则，<br/> *列表中的提交/回滚将导致后面的语句不被分组。)<br/> */</p></blockquote><p id="fab3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们到达<em class="kr">query tree _ list = pg _ analyze _ and _ rewrite _ fixed params(parsetree，query_string，NULL，0，NULL) </em></p><p id="7556" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们看看这个树在分析和重写后是什么样子。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="b585" class="mj ky in mf b gy mk ml l mm mn">(<br/>   {QUERY <br/>   :commandType 1 <br/>   :querySource 0 <br/>   :canSetTag true <br/>   :utilityStmt &lt;&gt; <br/>   :resultRelation 0 <br/>   :hasAggs false <br/>   :hasWindowFuncs false <br/>   :hasTargetSRFs false <br/>   :hasSubLinks false <br/>   :hasDistinctOn false <br/>   :hasRecursive false <br/>   :hasModifyingCTE false <br/>   :hasForUpdate false <br/>   :hasRowSecurity false <br/>   :isReturn false <br/>   :cteList &lt;&gt; <br/>   :rtable (<br/>      {RANGETBLENTRY <br/>      :alias &lt;&gt; <br/>      :eref <br/>         {ALIAS <br/>         :aliasname t <br/>         :colnames ("id")<br/>         }<br/>      :rtekind 0 <br/>      :relid 16389 <br/>      :relkind r <br/>      :rellockmode 1 <br/>      :tablesample &lt;&gt; <br/>      :lateral false <br/>      :inh true <br/>      :inFromCl true <br/>      :requiredPerms 2 <br/>      :checkAsUser 0 <br/>      :selectedCols (b 8)<br/>      :insertedCols (b)<br/>      :updatedCols (b)<br/>      :extraUpdatedCols (b)<br/>      :securityQuals &lt;&gt;<br/>      }<br/>   )<br/>   :jointree <br/>      {FROMEXPR <br/>      :fromlist (<br/>         {RANGETBLREF <br/>         :rtindex 1<br/>         }<br/>      )<br/>      :quals <br/>         {BOOLEXPR <br/>         :boolop and <br/>         :args (<br/>            {OPEXPR <br/>            :opno 521 <br/>            :opfuncid 147 <br/>            :opresulttype 16 <br/>            :opretset false <br/>            :opcollid 0 <br/>            :inputcollid 0 <br/>            :args (<br/>               {VAR <br/>               :varno 1 <br/>               :varattno 1 <br/>               :vartype 23 <br/>               :vartypmod -1 <br/>               :varcollid 0 <br/>               :varlevelsup 0 <br/>               :varnosyn 1 <br/>               :varattnosyn 1 <br/>               :location 22<br/>               }<br/>               {CONST <br/>               :consttype 23 <br/>               :consttypmod -1 <br/>               :constcollid 0 <br/>               :constlen 4 <br/>               :constbyval true <br/>               :constisnull false <br/>               :location 27 <br/>               :constvalue 4 [ 1 0 0 0 0 0 0 0 ]<br/>               }<br/>            )<br/>            :location 25<br/>            }<br/>            {OPEXPR <br/>            :opno 97 <br/>            :opfuncid 66 <br/>            :opresulttype 16 <br/>            :opretset false <br/>            :opcollid 0 <br/>            :inputcollid 0 <br/>            :args (<br/>               {VAR <br/>               :varno 1 <br/>               :varattno 1 <br/>               :vartype 23 <br/>               :vartypmod -1 <br/>               :varcollid 0 <br/>               :varlevelsup 0 <br/>               :varnosyn 1 <br/>               :varattnosyn 1 <br/>               :location 33<br/>               }<br/>               {CONST <br/>               :consttype 23 <br/>               :consttypmod -1 <br/>               :constcollid 0 <br/>               :constlen 4 <br/>               :constbyval true <br/>               :constisnull false <br/>               :location 38 <br/>               :constvalue 4 [ 10 0 0 0 0 0 0 0 ]<br/>               }<br/>            )<br/>            :location 36<br/>            }<br/>         )<br/>         :location 29<br/>         }<br/>      }<br/>   :mergeActionList &lt;&gt; <br/>   :mergeUseOuterJoin false <br/>   :targetList (<br/>      {TARGETENTRY <br/>      :expr <br/>         {VAR <br/>         :varno 1 <br/>         :varattno 1 <br/>         :vartype 23 <br/>         :vartypmod -1 <br/>         :varcollid 0 <br/>         :varlevelsup 0 <br/>         :varnosyn 1 <br/>         :varattnosyn 1 <br/>         :location 7<br/>         }<br/>      :resno 1 <br/>      :resname id <br/>      :ressortgroupref 0 <br/>      :resorigtbl 16389 <br/>      :resorigcol 1 <br/>      :resjunk false<br/>      }<br/>   )<br/>   :override 0 <br/>   :onConflict &lt;&gt; <br/>   :returningList &lt;&gt; <br/>   :groupClause &lt;&gt; <br/>   :groupDistinct false <br/>   :groupingSets &lt;&gt; <br/>   :havingQual &lt;&gt; <br/>   :windowClause &lt;&gt; <br/>   :distinctClause &lt;&gt; <br/>   :sortClause &lt;&gt; <br/>   :limitOffset &lt;&gt; <br/>   :limitCount &lt;&gt; <br/>   :limitOption 0 <br/>   :rowMarks &lt;&gt; <br/>   :setOperations &lt;&gt; <br/>   :constraintDeps &lt;&gt; <br/>   :withCheckOptions &lt;&gt; <br/>   :stmt_location 0 <br/>   :stmt_len 40<br/>   }<br/>)</span></pre><p id="e2d1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">印象深刻！注意前面的 RAWSTMT 是如何被转换成 QUERY 的。</p><p id="14f1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">接下来:<em class="kr">plantree _ list = pg _ plan _ queries(query tree _ list，query_string，<br/> CURSOR_OPT_PARALLEL_OK，NULL) </em></p><figure class="ma mb mc md gt mr gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi nm"><img src="../Images/66b46ef75c98563a04695f3057d465e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wia3XF-2wAZx6NbSOzzYdQ.png"/></div></div></figure><p id="a4ed" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="kr"> plantree_list </em>长这样:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="7a86" class="mj ky in mf b gy mk ml l mm mn">(<br/>   {PLANNEDSTMT <br/>   :commandType 1 <br/>   :queryId 0 <br/>   :hasReturning false <br/>   :hasModifyingCTE false <br/>   :canSetTag true <br/>   :transientPlan false <br/>   :dependsOnRole false <br/>   :parallelModeNeeded false <br/>   :jitFlags 0 <br/>   :planTree <br/>      {SEQSCAN <br/>      :scan.plan.startup_cost 0 <br/>      :scan.plan.total_cost 48.25 <br/>      :scan.plan.plan_rows 13 <br/>      :scan.plan.plan_width 4 <br/>      :scan.plan.parallel_aware false <br/>      :scan.plan.parallel_safe true <br/>      :scan.plan.async_capable false <br/>      :scan.plan.plan_node_id 0 <br/>      :scan.plan.targetlist (<br/>         {TARGETENTRY <br/>         :expr <br/>            {VAR <br/>            :varno 1 <br/>            :varattno 1 <br/>            :vartype 23 <br/>            :vartypmod -1 <br/>            :varcollid 0 <br/>            :varlevelsup 0 <br/>            :varnosyn 1 <br/>            :varattnosyn 1 <br/>            :location 7<br/>            }<br/>         :resno 1 <br/>         :resname id <br/>         :ressortgroupref 0 <br/>         :resorigtbl 16389 <br/>         :resorigcol 1 <br/>         :resjunk false<br/>         }<br/>      )<br/>      :scan.plan.qual (<br/>         {OPEXPR <br/>         :opno 521 <br/>         :opfuncid 147 <br/>         :opresulttype 16 <br/>         :opretset false <br/>         :opcollid 0 <br/>         :inputcollid 0 <br/>         :args (<br/>            {VAR <br/>            :varno 1 <br/>            :varattno 1 <br/>            :vartype 23 <br/>            :vartypmod -1 <br/>            :varcollid 0 <br/>            :varlevelsup 0 <br/>            :varnosyn 1 <br/>            :varattnosyn 1 <br/>            :location 22<br/>            }<br/>            {CONST <br/>            :consttype 23 <br/>            :consttypmod -1 <br/>            :constcollid 0 <br/>            :constlen 4 <br/>            :constbyval true <br/>            :constisnull false <br/>            :location 27 <br/>            :constvalue 4 [ 1 0 0 0 0 0 0 0 ]<br/>            }<br/>         )<br/>         :location 25<br/>         }<br/>         {OPEXPR <br/>         :opno 97 <br/>         :opfuncid 66 <br/>         :opresulttype 16 <br/>         :opretset false <br/>         :opcollid 0 <br/>         :inputcollid 0 <br/>         :args (<br/>            {VAR <br/>            :varno 1 <br/>            :varattno 1 <br/>            :vartype 23 <br/>            :vartypmod -1 <br/>            :varcollid 0 <br/>            :varlevelsup 0 <br/>            :varnosyn 1 <br/>            :varattnosyn 1 <br/>            :location 33<br/>            }<br/>            {CONST <br/>            :consttype 23 <br/>            :consttypmod -1 <br/>            :constcollid 0 <br/>            :constlen 4 <br/>            :constbyval true <br/>            :constisnull false <br/>            :location 38 <br/>            :constvalue 4 [ 10 0 0 0 0 0 0 0 ]<br/>            }<br/>         )<br/>         :location 36<br/>         }<br/>      )<br/>      :scan.plan.lefttree &lt;&gt; <br/>      :scan.plan.righttree &lt;&gt; <br/>      :scan.plan.initPlan &lt;&gt; <br/>      :scan.plan.extParam (b)<br/>      :scan.plan.allParam (b)<br/>      :scan.scanrelid 1<br/>      }<br/>   :rtable (<br/>      {RANGETBLENTRY <br/>      :alias &lt;&gt; <br/>      :eref <br/>         {ALIAS <br/>         :aliasname t <br/>         :colnames ("id")<br/>         }<br/>      :rtekind 0 <br/>      :relid 16389 <br/>      :relkind r <br/>      :rellockmode 1 <br/>      :tablesample &lt;&gt; <br/>      :lateral false <br/>      :inh false <br/>      :inFromCl true <br/>      :requiredPerms 2 <br/>      :checkAsUser 0 <br/>      :selectedCols (b 8)<br/>      :insertedCols (b)<br/>      :updatedCols (b)<br/>      :extraUpdatedCols (b)<br/>      :securityQuals &lt;&gt;<br/>      }<br/>   )<br/>   :resultRelations &lt;&gt; <br/>   :appendRelations &lt;&gt; <br/>   :subplans &lt;&gt; <br/>   :rewindPlanIDs (b)<br/>   :rowMarks &lt;&gt; <br/>   :relationOids (o 16389)<br/>   :invalItems &lt;&gt; <br/>   :paramExecTypes &lt;&gt; <br/>   :utilityStmt &lt;&gt; <br/>   :stmt_location 0 <br/>   :stmt_len 40<br/>   }<br/>)</span></pre><p id="340d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">通知类型 PLANNEDSTMT。这里发生了很多有趣的事情。我们可以以后再去。向前几步后，我们到达门户创建。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="d023" class="mj ky in mf b gy mk ml l mm mn">/*<br/> * Create unnamed portal to run the query or queries in. If there<br/> * already is one, silently drop it.<br/> */<br/>portal = CreatePortal("", true, true);</span></pre><p id="7ad5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">接着是<em class="kr"> PortalStart(portal，NULL，0，InvalidSnapshot) </em></p><blockquote class="ng nh ni"><p id="2bfd" class="jk jl kr jm b jn jo jp jq jr js jt ju nj jw jx jy nk ka kb kc nl ke kf kg kh ig bi translated">为执行准备门户。</p></blockquote><p id="cfa7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">还在准备中！让我们检查一下这里发生了什么(按 s)。<em class="kr"> PortalStart </em>是在 src/backend/tcop/pquery.c 中定义的，让我们继续一步步来</p><figure class="ma mb mc md gt mr gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi nn"><img src="../Images/8e753b7bc2f2444b5d7f25c9ebdbeb48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lNwJSdgHIeEOPsK1D3htxg.png"/></div></div></figure><p id="18dc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">QueryDesc 被创建:<em class="kr"> queryDesc = CreateQueryDesc(…)。</em>这在同一个文件中定义，即 src/backend/tcop/pquery.c</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="b9b5" class="mj ky in mf b gy mk ml l mm mn">/*<br/> * CreateQueryDesc<br/> */<br/>QueryDesc *<br/>CreateQueryDesc(PlannedStmt *plannedstmt,<br/>    const char *sourceText,<br/>    Snapshot snapshot,<br/>    Snapshot crosscheck_snapshot,<br/>    DestReceiver *dest,<br/>    ParamListInfo params,<br/>    QueryEnvironment *queryEnv,<br/>    int instrument_options)<br/>{<br/> QueryDesc  *qd = (QueryDesc *) palloc(sizeof(QueryDesc));</span><span id="e7b7" class="mj ky in mf b gy mp ml l mm mn">qd-&gt;operation = plannedstmt-&gt;commandType; /* operation */<br/> qd-&gt;plannedstmt = plannedstmt; /* plan */<br/> qd-&gt;sourceText = sourceText; /* query text */<br/> qd-&gt;snapshot = RegisterSnapshot(snapshot); /* snapshot */<br/> /* RI check snapshot */<br/> qd-&gt;crosscheck_snapshot = RegisterSnapshot(crosscheck_snapshot);<br/> qd-&gt;dest = dest;   /* output dest */<br/> qd-&gt;params = params;  /* parameter values passed into query */<br/> qd-&gt;queryEnv = queryEnv;<br/> qd-&gt;instrument_options = instrument_options; /* instrumentation wanted? */</span><span id="adb2" class="mj ky in mf b gy mp ml l mm mn">/* null these fields until set by ExecutorStart */<br/> qd-&gt;tupDesc = NULL;<br/> qd-&gt;estate = NULL;<br/> qd-&gt;planstate = NULL;<br/> qd-&gt;totaltime = NULL;</span><span id="d6b3" class="mj ky in mf b gy mp ml l mm mn">/* not yet executed */<br/> qd-&gt;already_executed = false;</span><span id="8bdf" class="mj ky in mf b gy mp ml l mm mn">return qd;<br/>}</span></pre><p id="00be" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最后我们到达<em class="kr"> ExecutorStart(queryDesc，myeflags)。</em> ExecutorStart 在 src/back end/executor/execmain . c 中定义，进入 ExecutorStart，在某个点:<em class="kr">query desc-&gt;estate = estate</em></p><p id="7e03" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">其中房地产是房地产对象</p><blockquote class="ng nh ni"><p id="2d4c" class="jk jl kr jm b jn jo jp jq jr js jt ju nj jw jx jy nk ka kb kc nl ke kf kg kh ig bi translated">/*————<br/>* Create executorstate<br/>*<br/>*创建并初始化一个 EState 节点，它是整个执行器调用的<br/> *工作存储的根。<br/> * <br/> *原则上，这将创建每个查询的内存上下文，该上下文将被<br/> *用于保存查询结束前的所有工作数据。<br/> *注意，每个查询的上下文将成为调用者的<br/> * CurrentMemoryContext 的子上下文。<br/>*————<br/>*/</p></blockquote><p id="155f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">经过一些步骤后，我们到达 InitPlan。InitPlan 是在 src/back end/executor/execmain . c 中定义的</p><blockquote class="ng nh ni"><p id="64fd" class="jk jl kr jm b jn jo jp jq jr js jt ju nj jw jx jy nk ka kb kc nl ke kf kg kh ig bi translated">/*———————<br/>* init plan<br/>*<br/>*初始化查询计划:打开文件，分配存储<br/> *启动规则管理器<br/>*—————————<br/>*/</p></blockquote><p id="26d8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">打开文件，让我看看。步入 initPlan。通过单步调试，我们到达了 src/back end/executor/execprocnode . c 中定义的 ExecInitNode。</p><blockquote class="ng nh ni"><p id="347e" class="jk jl kr jm b jn jo jp jq jr js jt ju nj jw jx jy nk ka kb kc nl ke kf kg kh ig bi translated">/<br/> * <br/> *输入:<br/>*“node”是查询计划器<br/>*“estate”是计划树的共享执行状态<br/>*“e flags”是 executor.h <br/> * <br/>中描述的标志位的按位或运算，返回给定计划节点对应的计划状态节点。<br/>*—————<br/>*/</p></blockquote><p id="4505" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="kr">execlintNode</em>将 node 作为 param，让我们看看它是什么样子的:</p><figure class="ma mb mc md gt mr gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi no"><img src="../Images/d87d37e7f9786358f5e9c8e967ec0d5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TbvWdF8GgLBVfGIlH7cH4A.png"/></div></div></figure><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="2240" class="mj ky in mf b gy mk ml l mm mn">{SEQSCAN <br/>   :scan.plan.startup_cost 0 <br/>   :scan.plan.total_cost 48.25 <br/>   :scan.plan.plan_rows 13 <br/>   :scan.plan.plan_width 4 <br/>   :scan.plan.parallel_aware false <br/>   :scan.plan.parallel_safe true <br/>   :scan.plan.async_capable false <br/>   :scan.plan.plan_node_id 0 <br/>   :scan.plan.targetlist (<br/>      {TARGETENTRY <br/>      :expr <br/>         {VAR <br/>         :varno 1 <br/>         :varattno 1 <br/>         :vartype 23 <br/>         :vartypmod -1 <br/>         :varcollid 0 <br/>         :varlevelsup 0 <br/>         :varnosyn 1 <br/>         :varattnosyn 1 <br/>         :location 7<br/>         }<br/>      :resno 1 <br/>      :resname id <br/>      :ressortgroupref 0 <br/>      :resorigtbl 16389 <br/>      :resorigcol 1 <br/>      :resjunk false<br/>      }<br/>   )<br/>   :scan.plan.qual (<br/>      {OPEXPR <br/>      :opno 521 <br/>      :opfuncid 147 <br/>      :opresulttype 16 <br/>      :opretset false <br/>      :opcollid 0 <br/>      :inputcollid 0 <br/>      :args (<br/>         {VAR <br/>         :varno 1 <br/>         :varattno 1 <br/>         :vartype 23 <br/>         :vartypmod -1 <br/>         :varcollid 0 <br/>         :varlevelsup 0 <br/>         :varnosyn 1 <br/>         :varattnosyn 1 <br/>         :location 22<br/>         }<br/>         {CONST <br/>         :consttype 23 <br/>         :consttypmod -1 <br/>         :constcollid 0 <br/>         :constlen 4 <br/>         :constbyval true <br/>         :constisnull false <br/>         :location 27 <br/>         :constvalue 4 [ 1 0 0 0 0 0 0 0 ]<br/>         }<br/>      )<br/>      :location 25<br/>      }<br/>      {OPEXPR <br/>      :opno 97 <br/>      :opfuncid 66 <br/>      :opresulttype 16 <br/>      :opretset false <br/>      :opcollid 0 <br/>      :inputcollid 0 <br/>      :args (<br/>         {VAR <br/>         :varno 1 <br/>         :varattno 1 <br/>         :vartype 23 <br/>         :vartypmod -1 <br/>         :varcollid 0 <br/>         :varlevelsup 0 <br/>         :varnosyn 1 <br/>         :varattnosyn 1 <br/>         :location 33<br/>         }<br/>         {CONST <br/>         :consttype 23 <br/>         :consttypmod -1 <br/>         :constcollid 0 <br/>         :constlen 4 <br/>         :constbyval true <br/>         :constisnull false <br/>         :location 38 <br/>         :constvalue 4 [ 10 0 0 0 0 0 0 0 ]<br/>         }<br/>      )<br/>      :location 36<br/>      }<br/>   )<br/>   :scan.plan.lefttree &lt;&gt; <br/>   :scan.plan.righttree &lt;&gt; <br/>   :scan.plan.initPlan &lt;&gt; <br/>   :scan.plan.extParam (b)<br/>   :scan.plan.allParam (b)<br/>   :scan.scanrelid 1<br/>   }</span></pre><p id="c464" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里我们可以看到节点类型是 SEQSCAN。在当前函数(<em class="kr">execlintnode</em>)中，我们可以找到计算结果的巨型开关。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="91db" class="mj ky in mf b gy mk ml l mm mn">switch (nodeTag(node))<br/> {<br/>   /*<br/>    * control nodes<br/>    */<br/>  case T_Result:<br/>   result = (PlanState *) ExecInitResult((Result *) node,<br/>              estate, eflags);<br/>   break;<br/>...</span></pre><p id="8cd4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对于我们的节点 SeqScan，我们快速跳转到<em class="kr"> ExecInitSeqScan </em>。在<em class="kr"> ExecInitSeqScan </em>内部的步骤(在 src/back end/executor/nodeseqscan . c 中定义)。</p><p id="c1b9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">逐句通过，直到我们到达<em class="kr"> ExecOpenScanRelation </em>(在 src/back end/executor/executils . c 中定义)，进入这个，然后进入<em class="kr">ExecGetRangeTableRelation</em>。继续前进，直到你到达</p><p id="c054" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="kr">rel = table _ open(rte-&gt;relid，NoLock) </em></p><p id="815a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="kr"> table_open </em>在 src/back end/access/table/table . c 中定义。</p><blockquote class="ng nh ni"><p id="1b97" class="jk jl kr jm b jn jo jp jq jr js jt ju nj jw jx jy nk ka kb kc nl ke kf kg kh ig bi translated">/*———<br/>* table _ open—通过关系 OID <br/> * <br/> *打开一个表关系，这基本上是 relation_open 加上检查关系<br/> *不是索引也不是复合类型。(调用者还应该在假设它有<br/> *存储之前<br/> *检查它不是视图或外部表。)<br/>*———<br/>*/</p></blockquote><figure class="ma mb mc md gt mr gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi np"><img src="../Images/ecd9da7909fdc7fb6cca77316a2184d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y5BO7oTRLuC0gJ3_a0tnnA.png"/></div></div><figcaption class="na nb gj gh gi nc nd bd b be z dk translated">relationId 稍后会有用</figcaption></figure><p id="0439" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这就调用了<em class="kr"> relation_open </em>，单步执行该函数。</p><p id="bc0c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="kr"> relation_open </em>在 src/back end/access/common/relation.c 中定义(不要和另一个在不同路径定义的 relation . c 混淆)。</p><p id="01cd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="kr"> relation_open </em>先取一个锁:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="e710" class="mj ky in mf b gy mk ml l mm mn">/* Get the lock before trying to open the relcache entry */<br/> if (lockmode != NoLock)<br/>  LockRelationOid(relationId, lockmode);</span><span id="1d6f" class="mj ky in mf b gy mp ml l mm mn">/* The relcache does all the real work... */<br/>r = RelationIdGetRelation(relationId);</span></pre><p id="57a6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后做真正的工作。让我们看看<em class="kr"> RelationIdGetRelation </em>做什么，进入这个函数。<em class="kr"> RelationIdGetRelation </em>在 src/back end/utils/cache/rel cache . c 中定义。</p><blockquote class="ng nh ni"><p id="04c7" class="jk jl kr jm b jn jo jp jq jr js jt ju nj jw jx jy nk ka kb kc nl ke kf kg kh ig bi translated">/*<br/>* RelationIdGetRelation<br/>*<br/>*查找 OID 的 reldesc 如果缓存中没有，请创建一个。<br/> * <br/> *如果找不到给定 relid <br/> *的 pg_class 行，则返回 NULL(表示我们正在尝试访问刚删除的关系)。<br/> *通过 elog 报告任何其他错误。<br/> * <br/> * NB:调用者在<br/> * relation ID 上至少应该已经有 AccessShareLock，否则会有恶劣的竞争条件。<br/> * <br/> * NB:关系参考计数递增，如果是新条目，则设置为 1。<br/> *调用者最终应递减计数。(通常，<br/> *这是通过调用 RelationClose()实现的。)<br/> */</p></blockquote><p id="15a2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里发生了很多事情。让我们继续前进，直到我们从<em class="kr"> ExecInitSeqScan </em>返回，并观察事情如何展开<em class="kr">。</em></p><figure class="ma mb mc md gt mr gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi nq"><img src="../Images/ab0ff6924b460fe816fecd76ca49ac61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kRwpc8yi2usEfsu-jtZuzQ.png"/></div></div></figure><p id="7c04" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">再进行一些初始化，<em class="kr"> scanstate- &gt; ss </em>如下所示:</p><figure class="ma mb mc md gt mr gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi nr"><img src="../Images/dbbd64b60d5907d19efc919ed6fa8ac4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZcqmMwmNJV5vws4Epr_lDA.png"/></div></div></figure><p id="fd6f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">其中<em class="kr"> ss </em>是 src/include/nodes/execnodes.h 中定义的扫描状态</p><blockquote class="ng nh ni"><p id="cccb" class="jk jl kr jm b jn jo jp jq jr js jt ju nj jw jx jy nk ka kb kc nl ke kf kg kh ig bi translated">/*————<br/>* scan state 信息<br/> * <br/> * ScanState 为代表<br/> *底层关系扫描的节点类型扩展 PlanState。它还可以用于扫描底层计划节点输出的节点<br/>*——在这种情况下，只有<br/>* ScanTupleSlot 实际上是有用的，它引用从子计划中检索的元组<br/> *。<br/> * <br/> *正在扫描的 current relation relation relation relation(如果没有则为 NULL)<br/>* currents can desc 用于扫描的当前扫描描述符(如果没有则为 NULL)<br/>* scan tuple Slot 指向保存扫描元组的元组表中的 slot 的指针<br/>*—————<br/>*/<br/>typedef struct scan state<br/>{<br/>plan state PS；/*它的第一个字段是 NodeTag */<br/>Relation ss _ current Relation；<br/>struct tables candescdata * ss _ currents candesc；<br/>TupleTableSlot * ss _ ScanTupleSlot；<br/> }扫描状态；</p></blockquote><p id="c36c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们继续前进，直到我们从最初的计划返回，很长的一段路，不是吗？</p><p id="fd71" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">移出<em class="kr"> standard_ExecutorStart </em>然后是<em class="kr"> PortalStart </em>，我们又回到了 pquery.c 文件。所有上述情况都发生在创建查询计划上。</p><blockquote class="ng nh ni"><p id="f59e" class="jk jl kr jm b jn jo jp jq jr js jt ju nj jw jx jy nk ka kb kc nl ke kf kg kh ig bi translated">/* <br/> *调用 ExecutorStart 准备执行计划<br/> */</p></blockquote><p id="a40c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">此时快速转储所有信息:</p><figure class="ma mb mc md gt mr gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi ns"><img src="../Images/2f53bdfd4cb753576854ea7fc5bdacaa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*diDcxUavAZ94GTKqHnzWBw.png"/></div></div><figcaption class="na nb gj gh gi nc nd bd b be z dk translated">计划测试</figcaption></figure><figure class="ma mb mc md gt mr gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi nt"><img src="../Images/17b026ab4485bd69368f2e4bb0a15e60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mHyJDMIReUMkk38UpICmYw.png"/></div></div></figure><p id="290d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">另外，<em class="kr"> tupleDescriptor </em>:</p><figure class="ma mb mc md gt mr gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi nu"><img src="../Images/1e9882835b93e71da71a60a9f641f52f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kRGrmZcvttQXPkcZiAq82g.png"/></div></div></figure><p id="8d86" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">注意<em class="kr"> attname(char*) </em>其中数据是 id(我们的列名)。</p><p id="b05b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">单步执行，系统准备输出流(这里是为了<em class="kr">去删除</em>，我们的 psql 客户端)。</p><figure class="ma mb mc md gt mr gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi nv"><img src="../Images/f5d48a748f5405002feb077cdc1a35f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DYCJGE7kFvY6wALkit5rMg.png"/></div></div></figure><p id="f3bb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们步入<em class="kr"> PortalRun </em>(在 src/backend/tcop/pquery.c 中定义)。</p><blockquote class="ng nh ni"><p id="a2ef" class="jk jl kr jm b jn jo jp jq jr js jt ju nj jw jx jy nk ka kb kc nl ke kf kg kh ig bi translated">运行门户的一个或多个查询。</p></blockquote><p id="f8fd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">继续步进，直到到达:<em class="kr">n processed = portal run select(portal，true，count，dest) </em></p><p id="e32f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">进入<em class="kr"> PortalRunSelect </em>然后 ExecutorRun(在 src/back end/executor/execmain . c 中定义)。</p><blockquote class="ng nh ni"><p id="6b0c" class="jk jl kr jm b jn jo jp jq jr js jt ju nj jw jx jy nk ka kb kc nl ke kf kg kh ig bi translated">/*——————————<br/>*执行器运行<br/> * <br/> *这是执行器模块的主例程。它接受来自流量 cop 的<br/> *查询描述符，并执行<br/> *查询计划。<br/> * <br/> * ExecutorStart 一定已经被调用了。<br/> * <br/> *如果方向为 NoMovementScanDirection，则不执行任何操作<br/> *除了启动/关闭目的地。否则，<br/> *我们在指定方向上检索多达“count”个元组。<br/> * <br/> *注:count = 0 解释为没有入口限制，即运行到<br/> *完成。还要注意，计数限制仅适用于<br/> *检索到的元组，而不适用于例如由可修改表计划节点插入/更新/删除的<br/> *。<br/> * <br/> *没有返回值，但是输出元组(如果有)发送到<br/>* query desc 中指定的目的接收方；并且在顶层处理的元组的数量<br/> *可以在<br/> * estate- &gt; es_processed 中找到。<br/> * <br/> *我们提供了一个函数钩子变量，让可加载插件<br/> *在调用 ExecutorRun 时获得控制权。这样的插件通常会调用 standard_ExecutorRun()。<br/>*<br/>*—————<br/>*/</p></blockquote><p id="ca2e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">好的，这是主执行器，它获取元组并输出到目标接收器。实际实现在<em class="kr"> standard_ExecutorRun </em>中。</p><p id="d4a5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">进入<em class="kr">执行计划</em>(在同一个文件中定义)。</p><blockquote class="ng nh ni"><p id="fdc4" class="jk jl kr jm b jn jo jp jq jr js jt ju nj jw jx jy nk ka kb kc nl ke kf kg kh ig bi translated">/<br/> * <br/> *如果 numberTuples 为 0 <br/> * <br/> *则运行完成。注意:ctid 属性是一个“垃圾”属性，在<br/> *用户可以看到它之前被删除<br/>*——————<br/>*/</p></blockquote><p id="e480" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">处理元组的无限循环。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="c719" class="mj ky in mf b gy mk ml l mm mn">/*<br/>  * Loop until we've processed the proper number of tuples from the plan.<br/>  */<br/> for (;;)<br/> {<br/><br/>   * Execute the plan and obtain a tuple<br/>   */<br/>  slot = ExecProcNode(planstate);</span><span id="16b1" class="mj ky in mf b gy mp ml l mm mn">/*<br/>   * if the tuple is null, then we assume there is nothing more to<br/>   * process so we just end the loop...<br/>   */<br/>  if (TupIsNull(slot))<br/>   break;</span><span id="8b2a" class="mj ky in mf b gy mp ml l mm mn">&lt;snip&gt; <br/>  if (sendTuples)<br/>  {<br/>   /*<br/>    * If we are not able to send the tuple, we assume the  destination<br/>    * has closed and no more tuples can be sent. If that's the case,<br/>    * end the loop.<br/>    */<br/>   if (!dest-&gt;receiveSlot(slot, dest))<br/>    break;<br/>  }</span></pre><p id="7fd7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="kr"> ExecProcNode </em>(在 src/include/executor/executor . h 中定义)调用对应节点的<em class="kr"> ExecProcNode </em>。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="d697" class="mj ky in mf b gy mk ml l mm mn">/* ----------------------------------------------------------------<br/> *  ExecProcNode<br/> *<br/> *  Execute the given node to return a(nother) tuple.<br/> * ----------------------------------------------------------------<br/> */<br/>#ifndef FRONTEND<br/>static inline TupleTableSlot *<br/>ExecProcNode(PlanState *node)<br/>{<br/> if (node-&gt;chgParam != NULL) /* something changed? */<br/>  ExecReScan(node);  /* let ReScan handle this */</span><span id="f024" class="mj ky in mf b gy mp ml l mm mn">return node-&gt;ExecProcNode(node);<br/>}<br/>#endif</span></pre><p id="e088" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在当前情况下，<em class="kr"> ExecProcNodeFirst </em>(在 src/back end/executor/execprocnode . c 中定义)被调用。</p><figure class="ma mb mc md gt mr gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi nt"><img src="../Images/b12b9f8ad2a361de7576c086be0917b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Cv5T-FPEu9TIPaWe1Ojkqg.png"/></div></div></figure><p id="6384" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">进而设置<em class="kr">node-&gt;ExecProcNode = node-&gt;ExecProcNodeReal。</em></p><p id="f653" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当前情况下，<em class="kr">节点- &gt; ExecProcNode </em>为<em class="kr"> ExecSeqScan </em>(在 src/back end/executor/nodeseqscan . c 中定义)。</p><p id="eba6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">ExecSeqScan:</p><blockquote class="ng nh ni"><p id="f537" class="jk jl kr jm b jn jo jp jq jr js jt ju nj jw jx jy nk ka kb kc nl ke kf kg kh ig bi translated">/*—————————<br/>* ExecSeqScan(node)<br/>*<br/>*顺序扫描关系，返回下一个符合条件的<br/> *元组。<br/> *我们调用 ExecScan()例程，并传递给它适当的<br/> *访问方法函数。<br/>*——————<br/>*/</p></blockquote><p id="5231" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="kr"> ExecSeqScan </em>调用<em class="kr"> ExecScan </em>(在 src/back end/executor/ExecScan . c 中定义)，别忘了插手。单步执行 ExecScanFetch(在 src/back end/executor/execscan . c 中定义，同一个文件),它拉入一个槽</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="e947" class="mj ky in mf b gy mk ml l mm mn">slot = ExecScanFetch(node, accessMtd, recheckMtd);</span></pre><p id="5dba" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">保持步进，当到达<em class="kr"> table_beginscan </em>(在 src/back end/access/heap/heap am . c 中定义)时再步进。在这里，<em class="kr"> scandesc </em>被填充。单步执行并进入下一个函数<em class="kr"> table_scan_getnextslot </em>(在<em class="kr"/>src/include/access/tableam . h 中定义)，进入同一函数中的<em class="kr"> scan_getnextslot </em>。</p><p id="eb17" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="kr"> scan_getnextslot </em>指向<em class="kr"> heap_getnextslot </em>(在 src/back end/access/heap/heap am . c 中定义)调用<em class="kr"> heapgettup_pagemode </em>(进入此函数)<em class="kr">。</em></p><blockquote class="ng nh ni"><p id="95de" class="jk jl kr jm b jn jo jp jq jr js jt ju nj jw jx jy nk ka kb kc nl ke kf kg kh ig bi translated">heapgettup_pagemode —以一次一页的模式获取下一个堆元组</p></blockquote><figure class="ma mb mc md gt mr gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi nw"><img src="../Images/b147723b2a15ac0bb16b3eea9a0fa59b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KsCgc1R5BjrlfYCACdbIBw.png"/></div></div></figure><p id="7304" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如你所见，我们在第一页。</p><p id="5e08" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们进入<em class="kr"> heapgetpage </em>(在同一个文件中)，它调用<em class="kr"> ReadBufferExtended </em>(在 src/back end/storage/buffer/buf mgr . c 中定义)。</p><blockquote class="ng nh ni"><p id="932f" class="jk jl kr jm b jn jo jp jq jr js jt ju nj jw jx jy nk ka kb kc nl ke kf kg kh ig bi translated">readbufferedextended—返回包含所请求关系的所请求的<br/>块的缓冲区。</p></blockquote><p id="47ed" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">它调用<em class="kr"> ReadBuffer_common </em>并依次调用<em class="kr"> BufferAlloc。</em></p><figure class="ma mb mc md gt mr gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi nx"><img src="../Images/d87ae207bcdb1f96151c8242f5d9b28e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*INHFsrAmwQWkY7TWdtltHw.png"/></div></div><figcaption class="na nb gj gh gi nc nd bd b be z dk translated">万一你迷路了，可以往回走</figcaption></figure><blockquote class="ng nh ni"><p id="8d72" class="jk jl kr jm b jn jo jp jq jr js jt ju nj jw jx jy nk ka kb kc nl ke kf kg kh ig bi translated">/*<br/>* buffer alloc—read buffer 子程序。处理共享<br/> *缓冲区的查找。如果已经不存在缓冲区，则选择一个替换的<br/> *牺牲页并逐出旧页，但不读入新页。<br/> * <br/> *“策略”可以是一个缓冲区替换策略对象，或者 NULL 为<br/> *默认策略。当<br/> *使用默认策略时，所选缓冲区的 usage_count 增加，否则可能不会增加(见 PinBuffer)。<br/> * <br/> *返回的缓冲区被钉住，并且已经被标记为保存<br/> *所需页面。如果已经有了想要的页面，*foundPtr 被<br/> *设置为真。否则，*foundPtr 被设置为假，并且缓冲区被标记为<br/> *作为 IO _ IN _ PROGRESSReadBuffer 现在需要进行 I/O 来填充它。<br/> * <br/> * *foundPtr 实际上与缓冲区的 BM_VALID 标志是冗余的，但是<br/> *为了简单起见，我们在 ReadBuffer 中保留了它。<br/> * <br/> *入口和出口都没有锁。<br/> */</p></blockquote><p id="5c44" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">漂亮！</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="249d" class="mj ky in mf b gy mk ml l mm mn">/* create a tag so we can lookup the buffer */<br/> InitBufferTag(&amp;newTag, &amp;smgr-&gt;smgr_rlocator.locator, forkNum, blockNum);</span><span id="c3c7" class="mj ky in mf b gy mp ml l mm mn">/* determine its hash code and partition lock ID */<br/> newHash = BufTableHashCode(&amp;newTag);<br/> newPartitionLock = BufMappingPartitionLock(newHash);</span><span id="5e83" class="mj ky in mf b gy mp ml l mm mn">/* see if the block is in the buffer pool already */<br/> LWLockAcquire(newPartitionLock, LW_SHARED);<br/>buf_id = BufTableLookup(&amp;newTag, newHash);</span></pre><p id="1e44" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> <em class="kr">首先，它试图在缓冲区中查找页面，如果没有找到，则其他页面被逐出，所需页面从磁盘加载到缓冲区。</em> </strong></p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="56f8" class="mj ky in mf b gy mk ml l mm mn">/*<br/>  * Didn't find it in the buffer pool.  We'll have to initialize a new<br/>  * buffer.  Remember to unlock the mapping lock while doing the work.<br/>  */<br/> LWLockRelease(newPartitionLock);</span><span id="75cd" class="mj ky in mf b gy mp ml l mm mn">/* Loop here in case we have to try another victim buffer */<br/> for (;;)<br/> {<br/>  /*<br/>   * Ensure, while the spinlock's not yet held, that there's a free<br/>   * refcount entry.<br/>   */<br/>  ReservePrivateRefCountEntry();</span><span id="6ce0" class="mj ky in mf b gy mp ml l mm mn">/*<br/>   * Select a victim buffer.  The buffer is returned with its header<br/>   * spinlock still held!<br/>   */<br/>  buf = StrategyGetBuffer(strategy, &amp;buf_state);</span><span id="287b" class="mj ky in mf b gy mp ml l mm mn">Assert(BUF_STATE_GET_REFCOUNT(buf_state) == 0);</span><span id="5ab8" class="mj ky in mf b gy mp ml l mm mn">/* Must copy buffer flags while we still hold the spinlock */<br/>  oldFlags = buf_state &amp; BUF_FLAG_MASK;</span><span id="7273" class="mj ky in mf b gy mp ml l mm mn">/* Pin the buffer and then release the buffer spinlock */<br/>  PinBuffer_Locked(buf);<br/>&lt;snip&gt;</span></pre><p id="ba11" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们看看在我们的情况下会发生什么。</p><figure class="ma mb mc md gt mr gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/fff9fd7d468d77239d7a94d63e5af443.png" data-original-src="https://miro.medium.com/v2/resize:fit:860/format:webp/1*ikEa_NNYeO2QUpv7KkXMFA.png"/></div><figcaption class="na nb gj gh gi nc nd bd b be z dk translated">在缓冲区本身中找到页面</figcaption></figure><p id="3c4b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Buf 在<em class="kr"> heapgetpage </em>中返回，我们到达:<em class="kr">DP = buffer getpage(buffer)</em></p><figure class="ma mb mc md gt mr gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/d0cb01cbd524348e0329070fbb4a1491.png" data-original-src="https://miro.medium.com/v2/resize:fit:860/format:webp/1*evq-EYZrCeBlpyUFPB6dHA.png"/></div><figcaption class="na nb gj gh gi nc nd bd b be z dk translated">缓冲区是 191</figcaption></figure><p id="8e10" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们看看如何从缓冲区获取页面，进入<em class="kr"> BufferGetPage </em>(在 src/include/storage/bufmgr.h 中定义)调用<em class="kr"> BufferGetBlock </em>。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="6ee1" class="mj ky in mf b gy mk ml l mm mn">/*<br/> * BufferGetBlock<br/> *  Returns a reference to a disk page image associated with a buffer.<br/> *<br/> * Note:<br/> *  Assumes buffer is valid.<br/> */<br/>static inline Block<br/>BufferGetBlock(Buffer buffer)<br/>{<br/> Assert(BufferIsValid(buffer));</span><span id="6b59" class="mj ky in mf b gy mp ml l mm mn">if (BufferIsLocal(buffer))<br/>  return LocalBufferBlockPointers[-buffer - 1];<br/> else<br/>  return (Block) (BufferBlocks + ((Size) (buffer - 1)) * BLCKSZ);<br/>}</span></pre><p id="1a00" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">其中<em class="kr"> BLCKSZ </em>是块大小(在 src/include/pg_config.h 中定义)</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="70a7" class="mj ky in mf b gy mk ml l mm mn">/* Size of a disk block --- this also limits the size of a tuple. You can set it bigger if you need bigger tuples (although TOAST should reduce the need to have large tuples, since fields can be spread across multiple tuples).<br/>BLCKSZ must be a power of 2. The maximum possible value of BLCKSZ is currently 2^15 (32768). This is determined by the 15-bit widths of the lp_off and lp_len fields in ItemIdData (see include/storage/itemid.h). Changing BLCKSZ requires an initdb. */<br/>#define BLCKSZ 8192</span></pre><p id="6795" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们继续<em class="kr"> getpageitem </em>，单步执行后，我们到达下面给出的行，单步执行:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="b2e0" class="mj ky in mf b gy mk ml l mm mn">loctup.t_data = (HeapTupleHeader) PageGetItem((Page) dp, lpp);</span></pre><p id="7526" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">其中<em class="kr"> PageGetItem </em>(在 src/include/storage/bufpage.h 中定义)看起来像:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="0a72" class="mj ky in mf b gy mk ml l mm mn">/*<br/> * PageGetItem<br/> *  Retrieves an item on the given page.<br/> *<br/> * Note:<br/> *  This does not change the status of any of the resources passed.<br/> *  The semantics may change in the future.<br/> */<br/>static inline Item<br/>PageGetItem(Page page, ItemId itemId)<br/>{<br/> Assert(page);<br/> Assert(ItemIdHasStorage(itemId));</span><span id="fafa" class="mj ky in mf b gy mp ml l mm mn">return (Item) (((char *) page) + ItemIdGetOffset(itemId));<br/>}</span></pre><p id="63d9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">注意<em class="kr"> loctup.t_data </em>是 HeapTupleHeader 的类型。</p><figure class="ma mb mc md gt mr gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi nz"><img src="../Images/333b7a64e2cdb3953b315af2836a63fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aDc9GOuOS7s6ChqD7SknFw.png"/></div></div><figcaption class="na nb gj gh gi nc nd bd b be z dk translated">元组头看起来像这样</figcaption></figure><p id="7944" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，我们回到我们的主函数<em class="kr"> heapgettup_pagemode。</em></p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="8e9b" class="mj ky in mf b gy mk ml l mm mn">/*<br/>  * advance the scan until we find a qualifying tuple or run out of stuff to scan<br/>  */<br/> for (;;)<br/> {<br/>&lt;snip&gt;</span></pre><p id="2c74" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你可以看穿剩下的代码或者继续退出。最后，我们看到 slot 被发送到我们的远程目的地。<em class="kr"> set_ps_display("idle") </em>被调用，将查询状态从活动更改为空闲。现在可以在 psql 中看到结果。</p><h1 id="f5ae" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">结论</h1><p id="9b84" class="pw-post-body-paragraph jk jl in jm b jn lv jp jq jr lw jt ju jv lx jx jy jz ly kb kc kd lz kf kg kh ig bi translated">我惊讶地发现，在逐步遍历 postgres(当它执行查询时)时，遍历 Postgres 代码库是多么容易，本文希望它能使这个过程变得更加容易。一旦你完成了一些查询(比如连接、递归 CTE 等等)。)，可以获得更多的见解。</p><p id="fa13" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">参考/资源</strong></p><ol class=""><li id="75c7" class="ki kj in jm b jn jo jr js jv kk jz kl kd km kh kn ko kp kq bi translated">Postgres 设置:<a class="ae mo" href="https://www.postgresql.org/docs/9.6/install-procedure.html" rel="noopener ugc nofollow" target="_blank">https://www.postgresql.org/docs/9.6/install-procedure.html</a></li><li id="142d" class="ki kj in jm b jn ks jr kt jv ku jz kv kd kw kh kn ko kp kq bi translated">广东发展银行:<a class="ae mo" href="https://wiki.postgresql.org/wiki/Developer_FAQ#gdb" rel="noopener ugc nofollow" target="_blank">https://wiki.postgresql.org/wiki/Developer_FAQ#gdb</a></li></ol><p id="c4ff" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">注意:请随时添加您的评论/建议/任何更正。</p></div></div>    
</body>
</html>