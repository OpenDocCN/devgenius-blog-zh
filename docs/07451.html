<html>
<head>
<title>Building Web Service with NodeJS — Part 6 (Update &amp; Delete)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 NodeJS 构建 Web 服务—第 6 部分(更新和删除)</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/building-web-service-with-nodejs-part-6-update-delete-a763fdc00674?source=collection_archive---------4-----------------------#2022-03-26">https://blog.devgenius.io/building-web-service-with-nodejs-part-6-update-delete-a763fdc00674?source=collection_archive---------4-----------------------#2022-03-26</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/0d10ed5f29acf665a5bfe4ca2f368f8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TsfmWf-5fbyDUunWzqAb5A.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">NodeJS</figcaption></figure><p id="6a34" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">大家好，感谢阅读到这一部分。欢迎来到本教程系列的第 6 部分。在<a class="ae kx" href="https://bitsizelearning.medium.com/building-web-service-with-nodejs-part-5-pagination-data-transfer-object-c5fbf7bd21f1" rel="noopener">的前一部分</a>中，我们重构了一些代码，并在 API 响应中使用了 DTO。让我们继续用<strong class="kb io">更新</strong>和<strong class="kb io">删除</strong>操作来实现 CRUD 操作。</p><p id="7ffe" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">如果您需要上一篇第 5 部分的代码，请在这里查看<a class="ae kx" href="https://github.com/bitsizelearning/icecream-store/tree/part5" rel="noopener ugc nofollow" target="_blank"/>。<strong class="kb io"> <br/> </strong>第 6 部分的完整代码可以在<a class="ae kx" href="https://github.com/bitsizelearning/icecream-store/tree/part6" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><h1 id="dc76" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">时间戳&amp;已删除</h1><p id="90c1" class="pw-post-body-paragraph jz ka in kb b kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ma ku kv kw ig bi translated">在转到更新和删除操作之前，让我们向菜单模型添加一些额外的信息。我们将添加<strong class="kb io">时间戳</strong>和<strong class="kb io">被删除的</strong>字段。时间戳字段是<strong class="kb io">创建时间</strong>和<strong class="kb io">更新时间</strong>。每次我们插入新菜单和更新菜单时，都应该插入和更新这些值。同时，isDeleted 是我们将要实现的删除操作的帮助器字段。让我们将菜单模式更新如下。</p><h2 id="9897" class="mb kz in bd la mc md dn le me mf dp li kk mg mh lm ko mi mj lq ks mk ml lu mm bi translated">src/models/menu.js</h2><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="18dc" class="mb kz in ms b gy mw mx l my mz">import { Schema, model } from 'mongoose';</span><span id="c235" class="mb kz in ms b gy na mx l my mz">const menuSchema = new Schema(<br/>  {<br/>    name: String,<br/>    description: String,<br/>    isDeleted: {<br/>      type: Boolean,<br/>      default: false,<br/>    },<br/>  },<br/>  { timestamps: true }<br/>);</span><span id="37e1" class="mb kz in ms b gy na mx l my mz">export const Menu = model('menus', menuSchema);</span></pre><p id="06a6" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在模式中，我们添加了一个 isDeleted 字段和一个设置为 false 的默认选项。这意味着每当我们插入一个新菜单时，isDeleted 值将自动设置为 false。为了添加时间戳字段，我们利用了 mongoose 的模式选项<strong class="kb io"> { timestamps: true } </strong>。该选项将自动为我们处理 createdTime 和 updatedTime 值。这些字段通常不会显示在 API 响应中(我们用 dto 处理了这一点)。</p><p id="f40e" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">请注意，在菜单模式中添加新字段后，数据库中现有的菜单数据不会自动更新。现在让我们删除数据库中所有的菜单数据。我们可以稍后用新字段重新插入这些菜单。</p><p id="c579" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">如果你按照我的建议使用 MongoDB Compass，你可以连接到数据库，然后寻找我们的<strong class="kb io">菜单</strong>集合(在屏幕的左侧)。将指针悬停在每个菜单记录(文档)上，单击垃圾箱图标以标记删除，然后单击删除以实际删除数据。</p><figure class="mn mo mp mq gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nb"><img src="../Images/2af0f2be481c27f67ba6d82a7f55256b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MiwgQiM-760peGTjW5hxAg.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">删除标志</figcaption></figure><figure class="mn mo mp mq gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nc"><img src="../Images/669c96c6312cfd7159510fc904070203.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6VNCgP3QdS1OXP3fHTjj0g.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">删除文档</figcaption></figure><p id="c189" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">现在，启动应用程序，用 POST /menu API 创建一个新菜单。</p><figure class="mn mo mp mq gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nd"><img src="../Images/7320a6e9c743b5051d8ddbc7db177278.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vzc0UPd0dt0Ah9G52zyCSQ.png"/></div></div></figure><p id="077e" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在 MongoDB Compass 上单击 refresh，我们应该看到我们的菜单和新字段一起被插入。</p><figure class="mn mo mp mq gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ne"><img src="../Images/9aa3b994bd605a45a4326da58930a4ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v8n3sIczMTmG2fqKLBVhow.png"/></div></div></figure><h1 id="31ff" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">删除菜单 DELETE /menu/:id</h1><p id="599e" class="pw-post-body-paragraph jz ka in kb b kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ma ku kv kw ig bi translated">我们将首先从删除操作开始。让我们回到路由器菜单，添加删除路由。要删除一个菜单文档，我们实际上可以使用<strong class="kb io"> Menu.delete </strong>。但是，请注意，该功能将真正永久删除我们的数据。在生产就绪应用程序场景中，我们可能不会使用真正的删除操作，相反，我们将使用<strong class="kb io">更新</strong>，并将我们的 isDeleted 字段设置为<strong class="kb io"> false </strong>。要更新菜单文档，我们可以使用<strong class="kb io"> Menu.findOneAndUpdate </strong>。这个函数更新我们的文档，然后返回值。</p><h2 id="23f1" class="mb kz in bd la mc md dn le me mf dp li kk mg mh lm ko mi mj lq ks mk ml lu mm bi translated">src/routes/menu/index.js</h2><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="dedc" class="mb kz in ms b gy mw mx l my mz">...</span><span id="01ba" class="mb kz in ms b gy na mx l my mz">router.delete('/:id', async (req, res, next) =&gt; {<br/>  try {<br/>    const deleted = await Menu.findOneAndUpdate(<br/>      { _id: req.params.id, isDeleted: false },<br/>      { isDeleted: true }<br/>    );<br/>    if (!deleted) {<br/>      throw new NotFoundError('No menu deleted');<br/>    }<br/>    res.json(getDeleteMenuResponseDTO(deleted));<br/>  } catch (error) {<br/>    next(error);<br/>  }<br/>});</span><span id="ebac" class="mb kz in ms b gy na mx l my mz">...</span></pre><h2 id="4ea5" class="mb kz in bd la mc md dn le me mf dp li kk mg mh lm ko mi mj lq ks mk ml lu mm bi translated">src/dto/menu.dto.js</h2><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="b565" class="mb kz in ms b gy mw mx l my mz">...</span><span id="2d4e" class="mb kz in ms b gy na mx l my mz">export const getDeleteMenuResponseDTO = (menu) =&gt; ({<br/>  message: 'Success delete menu',<br/>  id: menu._id,<br/>});</span></pre><p id="03c5" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">让我们尝试插入另一个菜单，然后删除它。比方说，如果我们有一个失败的冰淇淋菜单，因为没有人想点它们，所以我们想删除它。</p><figure class="mn mo mp mq gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nf"><img src="../Images/e1142a61e5973387b150ea0ada0b9489.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DTRHqTszrfDH0qmLSO1zZw.png"/></div></div></figure><p id="2a84" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">从响应中获取 id，并在我们新的删除 API 中使用它。</p><figure class="mn mo mp mq gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ng"><img src="../Images/d985fbf11ffa5c09599b78184c77aa01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FKe_dopngUjU1qC4sCYfIA.png"/></div></div></figure><p id="7714" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在我们的数据库中，我们可以看到咸冰淇淋的 isDeleted 值设置为 true，updatedTime 设置为当前时间戳。</p><figure class="mn mo mp mq gt jo gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/8bb4cacba7f38f211ef7c2e4b03f64b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1006/format:webp/1*yt2tIzHL0vyF_fdDNkeZ0Q.png"/></div></figure><p id="822f" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">不，它还没有完成。因为我们使用的是 isDeleted 方法而不是真正的 delete，所以我们需要修改 GET 和 GET by id API，以便只检索带有<strong class="kb io"> isDeleted: false </strong>的文档。</p><p id="b5b7" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">src/routes/menu/index.js</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="80f9" class="mb kz in ms b gy mw mx l my mz">...</span><span id="4bd3" class="mb kz in ms b gy na mx l my mz">router.get('/', async (req, res, next) =&gt; {<br/>  try {<br/>    const { page = 1, limit = 10 } = req.query;<br/>    const [menus, count] = await Promise.all([<br/>      Menu.find({ isDeleted: false })<br/>        .skip((page - 1) * limit)<br/>        .limit(limit),<br/>      Menu.count({ isDeleted: false }),<br/>    ]);</span><span id="5679" class="mb kz in ms b gy na mx l my mz">    res.json(getMenuResponseDTO(menus, page, limit, count));<br/>  } catch (error) {<br/>    next(error);<br/>  }<br/>});</span><span id="ec84" class="mb kz in ms b gy na mx l my mz">router.get('/:id', async (req, res, next) =&gt; {<br/>  try {<br/>    const id = req.params.id;<br/>    const menu = await Menu.findOne({ _id: id, isDeleted: false });<br/>    if (!menu) {<br/>      throw new NotFoundError('Id Not Found');<br/>    }<br/>    res.json(getMenuByIdResponseDTO(menu));<br/>  } catch (err) {<br/>    next(err);<br/>  }<br/>});</span><span id="cc7e" class="mb kz in ms b gy na mx l my mz">...</span></pre><p id="8c28" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们的 GET API 现在应该只返回一条记录。</p><figure class="mn mo mp mq gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ni"><img src="../Images/4f73644418a07d54ed4200d4f32430af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BSzRU7mL0h0QJMIed92WUg.png"/></div></div></figure><p id="95ef" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">让我们也试着通过删除咸冰淇淋 id。它应该返回未找到响应。</p><figure class="mn mo mp mq gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nf"><img src="../Images/be962aecefa3c073388ab3e970c88f69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fu8X79v_J3MPCC31jribDw.png"/></div></div></figure><h1 id="a1a4" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">更新菜单补丁/菜单/:id</h1><p id="50f2" class="pw-post-body-paragraph jz ka in kb b kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ma ku kv kw ig bi translated">为了更新资源，我们通常使用 PUT 或 PATCH 方法。如果我们想更新整个文档，我们可以使用 PUT 方法。如果我们只想更新文档的一些值，我们使用 PATCH。我们将使用相同的<strong class="kb io"> Menu.findOneAndUpdate </strong>来更新我们的数据，但是我们需要检查请求主体中要更新的字段。让我们也传递<strong class="kb io"> new: true </strong>选项来返回新的更新值，而不是旧的值。我们现在可以更新菜单的名称或描述。</p><h2 id="300a" class="mb kz in bd la mc md dn le me mf dp li kk mg mh lm ko mi mj lq ks mk ml lu mm bi translated">src/routes/menu/index.js</h2><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="8b1f" class="mb kz in ms b gy mw mx l my mz">...</span><span id="b7ee" class="mb kz in ms b gy na mx l my mz">router.patch('/:id', async (req, res, next) =&gt; {<br/>  try {<br/>    const toUpdate = {};<br/>    const { name, description } = req.body;<br/>    if (name) toUpdate.name = name;<br/>    if (description) toUpdate.description = description;</span><span id="a0b8" class="mb kz in ms b gy na mx l my mz">    const updated = await Menu.findOneAndUpdate(<br/>      { _id: req.params.id, isDeleted: false },<br/>      toUpdate,<br/>      { new: true }<br/>    );<br/>    if (!updated) {<br/>      throw new NotFoundError('No menu updated');<br/>    }<br/>    res.json(getUpdateMenuResponseDTO(updated));<br/>  } catch (error) {<br/>    next(error);<br/>  }<br/>});</span></pre><h2 id="3acf" class="mb kz in bd la mc md dn le me mf dp li kk mg mh lm ko mi mj lq ks mk ml lu mm bi translated">src/dto/menu.dto.js</h2><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="4fc2" class="mb kz in ms b gy mw mx l my mz">export const getUpdateMenuResponseDTO = (menu) =&gt; ({<br/>  message: 'Success update menu',<br/>  id: menu._id,<br/>  name: menu.name,<br/>  description: menu.description,<br/>});</span></pre><p id="edb5" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">让我们尝试更新华尼拉·艾斯霜的描述。</p><figure class="mn mo mp mq gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nj"><img src="../Images/781f63c86e1110af748ca19829121cc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CQpw0lMZuwa75Zy2eJSBKg.png"/></div></div></figure><p id="db83" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">搞定！</strong>我们完成了菜单的 CRUD(创建、读取、更新、删除)操作实现。现在，您应该对如何开发一个最简单的 RESTful web 服务有了大致的了解。这仍然是一个相当短的部分，让我们在结束这一部分之前补充一些有用的东西。</p><p id="7396" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们可以观察到我们的 GET、PATCH 和 DELETE APIs 在请求参数中使用了<strong class="kb io"> id </strong>。这个 id 应该是一个有效的 MongoDB id，称为<strong class="kb io"> ObjectId </strong>。现在，如果我们将无效的 id 传递给请求参数，我们会得到令人讨厌的内部服务器错误响应，因为 mongoose 不能将 id 转换为 ObjectId。</p><figure class="mn mo mp mq gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nk"><img src="../Images/bb2d7d64ce7d23244f4ce790a6b3acd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*An1XwbiZM_0-bhNHLFFCSA.png"/></div></div></figure><p id="7c4f" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">让我们来处理这个错误。对于每个使用 id 作为请求参数的 API，我们需要在到达处理函数之前验证 id。这就是中间件派上用场的地方。创建一个名为<strong class="kb io">middleware</strong>的新文件夹，并在其中创建一个名为<strong class="kb io"> validation.js </strong>的文件。我们将使用来自 mongoose 的<strong class="kb io"> ObjectId.isValid </strong>函数。如果 id 无效，我们将抛出一个错误请求(HTTP 400)错误响应。如果 id 是一个有效的 ObjectId，我们将调用<strong class="kb io">下一个</strong>回调函数来获得我们实际的处理函数。</p><h2 id="7a85" class="mb kz in bd la mc md dn le me mf dp li kk mg mh lm ko mi mj lq ks mk ml lu mm bi translated">src/middleware/validation . js</h2><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="891e" class="mb kz in ms b gy mw mx l my mz">import mongoose from 'mongoose';<br/>import { BadRequestError } from '../lib/errors';</span><span id="a865" class="mb kz in ms b gy na mx l my mz">export const validateObjectId = (req, res, next) =&gt; {<br/>  if (!mongoose.Types.ObjectId.isValid(req.params.id)) {<br/>    throw new BadRequestError('Invalid ObjectId in request params');<br/>  }<br/>  next();<br/>};</span></pre><h2 id="bec5" class="mb kz in bd la mc md dn le me mf dp li kk mg mh lm ko mi mj lq ks mk ml lu mm bi translated">src/lib/errors.js</h2><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="b503" class="mb kz in ms b gy mw mx l my mz">...</span><span id="7501" class="mb kz in ms b gy na mx l my mz">export class BadRequestError extends Error {<br/>  constructor(message) {<br/>    super(message);<br/>    this.status = 400;<br/>  }<br/>}</span></pre><p id="7eb3" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">然后，让我们在 GET、DELETE 和 PATCH by id 路由中添加中间件 validateObjectId。将函数作为参数传递到我们的处理函数之前。</p><h2 id="4254" class="mb kz in bd la mc md dn le me mf dp li kk mg mh lm ko mi mj lq ks mk ml lu mm bi translated">src/routes/menu/index.js</h2><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="b559" class="mb kz in ms b gy mw mx l my mz">import { validateObjectId } from '../../middlewares/validations';</span><span id="9db8" class="mb kz in ms b gy na mx l my mz">...</span><span id="1549" class="mb kz in ms b gy na mx l my mz">router.get('/:id', validateObjectId, async (req, res, next) =&gt; {</span><span id="ef3f" class="mb kz in ms b gy na mx l my mz">...</span><span id="cd13" class="mb kz in ms b gy na mx l my mz">router.delete('/:id', validateObjectId, async (req, res, next) =&gt; {</span><span id="9b6f" class="mb kz in ms b gy na mx l my mz">...</span><span id="86e7" class="mb kz in ms b gy na mx l my mz">router.patch('/:id', validateObjectId, async (req, res, next) =&gt; {</span><span id="8377" class="mb kz in ms b gy na mx l my mz">...</span></pre><p id="f3d7" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">让我们尝试在 API 请求中再次使用无效的 ObjectId 作为参数。</p><figure class="mn mo mp mq gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nj"><img src="../Images/20a824f7ab2d74a76017e3b81bc4848f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SMVRinQe06Kuwu-D-OKk-g.png"/></div></div></figure><p id="cad1" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">现在，我们应该得到一个错误的请求响应，其中有一条消息告诉我们 id 无效。</p></div><div class="ab cl nl nm hr nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ig ih ii ij ik"><p id="5290" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在下一部分中，让我们讨论我们的应用程序的数据或整体系统设计。</p><p id="ddcf" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">您可以在我的公共 github 资源库中看到完整的第 6 部分代码。<br/> <a class="ae kx" href="https://github.com/bitsizelearning/icecream-store/tree/part6" rel="noopener ugc nofollow" target="_blank"> <strong class="kb io">点击这里！</strong>T12】</a></p><p id="383f" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">谢谢你，希望你喜欢阅读它。有没有什么错误或者是我没有解释清楚的地方？有什么我应该改进的吗？</p><p id="18ed" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">如果你愿意的话，给作者留个便条和一些掌声来帮助频道发展。:)</p></div></div>    
</body>
</html>