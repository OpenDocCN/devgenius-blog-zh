<html>
<head>
<title>Normalisation in SQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SQL 中的规范化</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/normalization-in-sql-46ca5c0afc2d?source=collection_archive---------1-----------------------#2022-09-21">https://blog.devgenius.io/normalization-in-sql-46ca5c0afc2d?source=collection_archive---------1-----------------------#2022-09-21</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="4a4e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们为什么要标准化数据？这个问题在我们脑海里蹦出来对吧？！井数据通常是非常混乱和肮脏的，有空值、重复、空白和大量冗余数据。</p><p id="269a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在我们来看看重复和冗余之间的区别。</p><h2 id="2442" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">复制是指创建一个数据的精确副本，正如您在下面看到的，第二条记录被复制，这可能会导致问题。</h2><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi lb"><img src="../Images/e74bd00dea9f1cfac73dbfa658e677f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:972/format:webp/1*Euhf1ljELpz2_natXg6vzg.png"/></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk translated">图 1 重复记录</figcaption></figure><h2 id="b678" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">而冗余是指数据中有两个意义相似但不重复的值。</h2><p id="dab1" class="pw-post-body-paragraph jk jl in jm b jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ig bi translated">下面是一个例子，你可以看到印度、Bharat 和 IND 的意思是一样的，但是当选择印度时，Bharat 和 IND 将被忽略。</p><p id="ed0b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">孟买和孟买的情况类似。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi ls"><img src="../Images/4da662cd5e2863842a0d6ce5cdc31e3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:790/format:webp/1*07kVqZqqAyvRmSasLUBUCQ.png"/></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk translated">图 2 冗余</figcaption></figure><p id="850c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">数据完整性受到冗余和重复数据的挑战。</p><h2 id="6437" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">如何摆脱冗余？</h2><p id="9832" class="pw-post-body-paragraph jk jl in jm b jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ig bi translated">答案很简单，你把数据标准化。</p><ol class=""><li id="b5db" class="lt lu in jm b jn jo jr js jv lv jz lw kd lx kh ly lz ma mb bi translated"><strong class="jm io">第一个规范化形式</strong> —多值列(同一列有逗号分隔值或多值)</li></ol><p id="b3ce" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">例子—</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi mc"><img src="../Images/544065b5cfdd24c2bc5d0e4eabde6992.png" data-original-src="https://miro.medium.com/v2/resize:fit:988/format:webp/1*R5bdG5kTOeYA-_Gvoau-Uw.png"/></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk translated">图 3</figcaption></figure><p id="4250" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这里，我想将 Watson 改为 Parker，因此为了避免冗余和多值列，我们将拆分列，使它们更加原子化。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi md"><img src="../Images/d5ca09c36fa9640084608e374866841b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1284/format:webp/1*f0tEh0tUusG8xs4elDmL7w.png"/></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk translated">图 4</figcaption></figure><p id="dbff" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如上表所示，我们将一列分成三列，以避免冗余和列中的多个值。</p><p id="1155" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">2.<strong class="jm io">第二种规范化形式— </strong>在同一个表中，正常键依赖于主键，即部分依赖，就会出现冗余。</p><p id="9345" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了解决这种冗余，我们将表一分为二并创建主/引用表，我们需要确保 NON_KEY 列应该直接依赖于主键。</p><p id="784b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">例子—</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi md"><img src="../Images/5cca15be5dd4dccd92d919ad693670ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1284/format:webp/1*w0YzeUxEehFoJ0t9dC84Gg.png"/></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk translated">图 5</figcaption></figure><p id="b24d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">拆分表—</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi me"><img src="../Images/5c1167c06f1177c969f7141645efc536.png" data-original-src="https://miro.medium.com/v2/resize:fit:1210/format:webp/1*79MeLQxl4ZYEbTY2Gp6rjQ.png"/></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk translated">图 6</figcaption></figure><p id="45c9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> 3。第三种标准化形式— </strong></p><p id="ac89" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一些冗余本质上是暂时的，这意味着非键列依赖于非键列，这违反了第三范式。</p><p id="3efc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">从下表可以看出，ID→州，州→国家。因此，我们推断，国家是过渡性依赖于身份证。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/2cb19ca905c132333866398f52d30100.png" data-original-src="https://miro.medium.com/v2/resize:fit:1086/format:webp/1*jcXu6Wat3KfFV7CCgG5xfA.png"/></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk translated">图 7</figcaption></figure><p id="83ba" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在我们知道了依赖关系，我们将把表分成两个表，以规范化和解决冗余。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/6081b916d7702624748251289ad50db8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1186/format:webp/1*S69zp2WDNzwsZ3j74vbg3A.png"/></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk translated">图 8</figcaption></figure><p id="c6b9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">需要记住的一点是，标准化的增加将会降低性能。</p><blockquote class="mh mi mj"><p id="db91" class="jk jl mk jm b jn jo jp jq jr js jt ju ml jw jx jy mm ka kb kc mn ke kf kg kh ig bi translated"><em class="in">这篇文章就到这里，希望你喜欢。如果您能分享这篇文章，并留下您的想法、建议和推荐，我将不胜感激，希望您能不断进步、学习和成长。</em></p><p id="766b" class="jk jl mk jm b jn jo jp jq jr js jt ju ml jw jx jy mm ka kb kc mn ke kf kg kh ig bi translated"><em class="in">下次见，</em></p></blockquote><h1 id="c608" class="mo kj in bd kk mp mq mr kn ms mt mu kq mv mw mx kt my mz na kw nb nc nd kz ne bi translated">保持警惕。保持好奇。</h1><h1 id="96db" class="mo kj in bd kk mp mq mr kn ms mt mu kq mv mw mx kt my mz na kw nb nc nd kz ne bi translated">再见</h1></div></div>    
</body>
</html>