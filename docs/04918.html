<html>
<head>
<title>BDD Automation: from executable specifications to automated tests</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">BDD自动化:从可执行规范到自动化测试</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/bdd-automation-from-executable-specifications-to-automated-tests-11b0c2650490?source=collection_archive---------5-----------------------#2021-05-21">https://blog.devgenius.io/bdd-automation-from-executable-specifications-to-automated-tests-11b0c2650490?source=collection_archive---------5-----------------------#2021-05-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="d540" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">文章</h2><div class=""/><div class=""><h2 id="a1be" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">约翰·弗格森·斯马特的第二版《BDD在行动》</h2></div><p id="2faa" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">本文探索了可供使用的BDD自动化工具。</p></div><div class="ab cl ll lm hu ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="ij ik il im in"><p id="319a" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">在<a class="ae ko" href="https://www.manning.com/?utm_source=medium&amp;utm_medium=organic&amp;utm_campaign=book_smart_bdd_1_9_20" rel="noopener ugc nofollow" target="_blank">manning.com</a>结账时，将<strong class="kr ja"> fccsmart2 </strong>输入折扣代码框，即可享受40%的折扣<a class="ae ko" href="https://www.manning.com/books/bdd-in-action-second-edition?utm_source=medium&amp;utm_medium=organic&amp;utm_campaign=book_smart_bdd_1_9_20" rel="noopener ugc nofollow" target="_blank"> <em class="ls"> BDD in Action，第二版</em> </a>。</p></div><div class="ab cl ll lm hu ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="ij ik il im in"><p id="027d" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">许多专门的BDD工具可以用来自动化您的验收标准。流行的选择包括Cucumber(针对Java、JavaScript、Ruby和许多其他语言)、SpecFlow(针对。NET)，以及行为(对于Python)。尽管它们不是必不可少的，但是这些工具使得以结构化的形式表达自动化测试变得更加容易，类似于通常使用的“给定…当…然后”表达式。这使得产品所有者和测试人员更容易理解和识别自动化验收标准，这反过来可以帮助增加他们对自动化测试和自动化验收测试方法的信心。</p><h2 id="90e2" class="lt lu iq bd lv lw lx dn ly lz ma dp mb ky mc md me lc mf mg mh lg mi mj mk iw bi translated"><strong class="ak">用Maven和Cucumber建立项目</strong></h2><p id="e200" class="pw-post-body-paragraph kp kq iq kr b ks ml ka ku kv mm kd kx ky mn la lb lc mo le lf lg mp li lj lk ij bi translated">在本文中，我将使用几种不同的BDD工具举例说明。我们使用Cucumber和Java<a class="ae ko" href="https://freecontent.manning.com/bdd-automation-from-executable-specifications-to-automated-tests/#id_ftn1" rel="noopener ugc nofollow" target="_blank">【1】</a>编写可执行的规范，项目使用Maven构建和运行。<a class="ae ko" href="https://freecontent.manning.com/bdd-automation-from-executable-specifications-to-automated-tests/#id_ftn2" rel="noopener ugc nofollow" target="_blank">【2】</a>测试报告是使用Serenity BDD生成的，<a class="ae ko" href="https://freecontent.manning.com/bdd-automation-from-executable-specifications-to-automated-tests/#id_ftn3" rel="noopener ugc nofollow" target="_blank">【3】</a>这是一个开源库，可以更容易地组织和报告BDD测试结果。</p><p id="b95f" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">本文的源代码可以在GitHub<a class="ae ko" href="https://freecontent.manning.com/bdd-automation-from-executable-specifications-to-automated-tests/#id_ftn4" rel="noopener ugc nofollow" target="_blank">【4】</a>和Manning网站上找到。我们将遍历整个过程，跟随Tess和Dave在Cucumber中实现自动化验收测试，并使用这些测试来驱动他们的开发过程。如果您想跟进，您需要一个安装了以下软件的开发环境:</p><ul class=""><li id="f13b" class="mq mr iq kr b ks kt kv kw ky ms lc mt lg mu lk mv mw mx my bi translated">Java JDK(示例代码是使用OpenJava 12.0.2开发的，但是它应该可以在JDK 1.8或更高版本中正常工作)</li><li id="b6e1" class="mq mr iq kr b ks mz kv na ky nb lc nc lg nd lk mv mw mx my bi translated">Maven 3.6.x</li><li id="ca8d" class="mq mr iq kr b ks mz kv na ky nb lc nc lg nd lk mv mw mx my bi translated">Git(如果您想查看运行中的示例解决方案</li></ul><p id="ab99" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">Tess和Dave做的第一件事是使用Maven原型创建一个新的Maven项目。Maven原型是一种用正确的目录布局和Maven构建脚本创建框架项目的便捷方式。为了使用Cucumber和Serenity创建一个新项目，他们在命令行上运行以下命令:</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="d724" class="lt lu iq nj b gy nn no l np nq">$ mvn archetype:generate -Dfilter=serenity-cucumber4</span></pre><p id="e00d" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">该命令列出了可用的匹配原型，并提示他们选择想要使用的原型。只提供一个原型，他们输入“1”。接下来，他们输入一个Maven组id(“manning . BDD inaction”)一个artefact id(“火车时刻表”)和一个初始版本(他们将此作为默认的“1.0快照”)。Maven还提示输入项目的根包(它们保留为默认值，与组id相同)。整个过程看起来像这样:</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="40dc" class="lt lu iq nj b gy nn no l np nq">[INFO] Generating project in Interactive mode<br/> [WARNING] No archetype found in remote catalog. Defaulting to internal catalog<br/> [INFO] No archetype defined. Using maven-archetype-quickstart (org.apache.maven.archetypes:maven-archetype-quickstart:1.0)<br/> Choose archetype:<br/> 1: local -&gt; net.serenity-bdd:serenity-cucumber4-archetype (Serenity automated acceptance testing project using Selenium 2, JUnit and Cucumber-JVM)<br/> Choose a number or apply filter (format: [groupId:]artifactId, case sensitive contains): : <strong class="nj ja">1</strong><br/> Define value for property 'groupId': <strong class="nj ja">manning.bddinaction</strong><br/> Define value for property 'artifactId': <strong class="nj ja">train-timetables</strong><br/> Define value for property 'version' 1.0-SNAPSHOT: :<br/> Define value for property 'package' manning.bddinaction: :<br/> Confirm properties configuration:<br/> groupId: manning.bddinaction<br/> artifactId: train-timetables<br/> version: 1.0-SNAPSHOT<br/> package: manning.bddinaction<br/>  Y: : <strong class="nj ja">Y</strong><br/> [INFO] ---------------------------------------------------------------------<br/> [INFO] Using following parameters for creating project from Archetype: serenity-cucumber4-archetype:2.0.72<br/> [INFO] ---------------------------------------------------------------------<br/> -<br/> [INFO] BUILD SUCCESS<br/> [INFO] ---------------------------------------------------------------------<br/> [INFO] Total time:  30.818 s<br/> [INFO] Finished at: 2019-09-22T17:14:18-04:00<br/> [INFO] ---------------------------------------------------------------------</span></pre><p id="4e48" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">这在列车时刻表目录中创建了一个新的项目结构，如下所示:</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="615d" class="lt lu iq nj b gy nn no l np nq">|____train-timetables<br/> | |____pom.xml                                                   #1<br/> | |____build.gradle                                                       #2<br/> | |____src<br/> | | |____main<br/> | | | |____java                                                  #3<br/> | | | | |____manning<br/> | | | | | |____bddinaction<br/> | | | | | | |____app<br/> | | | | | | | |____Calculator.java<br/> | | |____test                                                     #4<br/> | | | |____resources<br/> | | | | |____features                                             #5<br/> | | | | | |____math<br/> | | | | | | |____adding_numbers.feature<br/> | | | |____java<br/> | | | | |____manning<br/> | | | | | |____bddinaction<br/> | | | | | | |____acceptancetests<br/> | | | | | | | |____AcceptanceTestSuite.java                            #6<br/> | | | | | | |____steps<br/> | | | | | | | |____MathsStepDefinitions.java</span></pre><p id="1db2" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated"><strong class="kr ja"># 1 Maven POM . XML构建脚本</strong></p><p id="e14b" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated"><strong class="kr ja"> #2一个等价的Gradle构建脚本</strong></p><p id="a9f3" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated"><strong class="kr ja"> #3应用程序代码在此处</strong></p><p id="1457" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated"><strong class="kr ja"> #4测试代码在此处</strong></p><p id="9bc9" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated"><strong class="kr ja"> #5黄瓜特征文件放在src/test/resource下</strong></p><p id="a592" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated"><strong class="kr ja"> #6这是主要的测试转轮类</strong></p><p id="1114" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">进入火车时刻表文件夹，运行“mvn验证”命令。这将下载您需要的任何依赖项，并运行与项目框架捆绑在一起的简单特性文件:</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="806c" class="lt lu iq nj b gy nn no l np nq">$ cd train-timetables<br/> $ mvn verify<br/> [INFO] Scanning for projects...<br/> …<br/> [INFO] -------------------------------------------------------<br/> [INFO]  T E S T S<br/> [INFO] -------------------------------------------------------<br/> [INFO] Running manning.bddinaction.AcceptanceTestSuite<br/> …<br/> [INFO] ---------------------------------------------------------------------<br/> [INFO] BUILD SUCCESS<br/> [INFO] ---------------------------------------------------------------------<br/> [INFO] Total time:  6.343 s<br/> [INFO] Finished at: 2019-09-22T18:17:16-04:00<br/> [INFO] ---------------------------------------------------------------------</span></pre><p id="0a5c" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">现在他们已经有了一个项目框架并开始运行，Tess和Dave继续进行更有趣的工作:以Cucumber可以执行的形式实现他们之前发现的场景。</p><h2 id="7c04" class="lt lu iq bd lv lw lx dn ly lz ma dp mb ky mc md me lc mf mg mh lg mi mj mk iw bi translated"><strong class="ak">记录黄瓜中的可执行规范</strong></h2><p id="3387" class="pw-post-body-paragraph kp kq iq kr b ks ml ka ku kv mm kd kx ky mn la lb lc mo le lf lg mp li lj lk ij bi translated">在Cucumber中，我们在名为<em class="ls">特征文件</em>的特殊文件中记录我们之前编写的场景。这些文件有一个”。feature”后缀，顾名思义，它包含了描述特定特性行为的所有场景。</p><p id="72f6" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">下面是Tess如何记录她和Jill在上一个问题中定义的场景:</p><p id="9ac5" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated"><strong class="kr ja">清单1。用黄瓜表示的验收标准</strong></p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="f99c" class="lt lu iq nj b gy nn no l np nq">Feature: Show next departing trains<br/>  <br/>   As a commuter travelling between two stations on the same line<br/>   I want to know what time the next trains for my destination will leave<br/>   So that I can spend less time waiting at the station<br/>  <br/>   Scenario: Next train going to the requested destination on the same line<br/>     Given the T1 train to Chatswood leaves Hornsby at 8:02, 8:15, 8:21<br/>     When Travis want to travel from Hornsby to Chatswood at 8:00<br/>     Then he should be told about the trains at: 8:02, 8:15</span></pre><p id="ce7c" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">这只不过是我们之前讨论的示例的结构化版本。粗体字(Feature、Scenario、Given、When和Then)是标记特征文件结构的关键字。其他的都是普通的商业语言。</p><p id="d8d1" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">Java项目的一个常见约定是将特性文件放在src/test/resources/features目录下。在这个目录中，功能文件可以按照高级功能或主题进行分组。例如，随着项目的进展，团队可能会得到如下目录:</p><ul class=""><li id="0dc2" class="mq mr iq kr b ks kt kv kw ky ms lc mt lg mu lk mv mw mx my bi translated">路线(路线计算和时间表信息)</li><li id="8878" class="mq mr iq kr b ks mz kv na ky nb lc nc lg nd lk mv mw mx my bi translated">通勤者(通勤者的个性化出行数据)</li><li id="f8c0" class="mq mr iq kr b ks mz kv na ky nb lc nc lg nd lk mv mw mx my bi translated">通知(通勤者的延迟通知)</li></ul><p id="def2" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">目前，一个特征文件就足够了。Tess在features文件夹中创建了“路线”目录，并添加了一个名为show _ next _ departing _ trains . feature的文件。她还删除了math目录，该目录与用于演示目的的skeleton项目一起提供。目录结构现在看起来像这样:</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="ad52" class="lt lu iq nj b gy nn no l np nq">|____src<br/> | |____test<br/> | | |____resources<br/> | | | |____features<br/> | | | | |____itineraries<br/>    | | | | | |____show_next_departing_trains.feature</span></pre><p id="3bc0" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">这现在算作一个可执行的规范。尽管场景背后没有让它测试任何东西的代码，但您仍然可以执行它。如果您想尝试一下，请进入火车时刻表目录并运行以下命令:</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="bc02" class="lt lu iq nj b gy nn no l np nq">$ mvn clean verify</span></pre><p id="038f" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">这将在目标/站点/serenity目录中生成一组报告。<a class="ae ko" href="https://freecontent.manning.com/bdd-automation-from-executable-specifications-to-automated-tests/#id_ftn5" rel="noopener ugc nofollow" target="_blank">【5】</a>如果你打开这个目录中的index.html文件，点击屏幕底部测试表中的唯一测试，你应该会看到如图1所示的内容。</p><figure class="ne nf ng nh gt ns gh gi paragraph-image"><div role="button" tabindex="0" class="nt nu di nv bf nw"><div class="gh gi nr"><img src="../Images/4c34de2746ed046c21e57f457a522b66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*DwlV-wJyw2SRLMCp.png"/></div></div><figcaption class="nz oa gj gh gi ob oc bd b be z dk translated">图一。验收测试报告中的黄瓜特性</figcaption></figure><p id="c75f" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">此时，场景不再是简单的文本文档；它现在是一个<em class="ls">可执行规范</em>。它可以作为自动化构建过程的一部分来运行，以自动确定特定的特性是否已经完成。当第一次执行这样的测试时，它们被标记为“pending”，用BDD的术语来说，这意味着测试已经自动化，但是实现支持特性的代码还没有被编写。随着特性的实现和验收测试的成功，它们被标记为“通过”,表明您已经完成了这方面的工作。</p><p id="d2f0" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">这些场景中使用的语言与Jill在与团队的对话中使用的术语非常接近。当场景出现在测试报告中时，使用这种熟悉的语言使得测试人员、最终用户和其他非开发人员更容易理解正在测试什么特性以及它们是如何被测试的。</p><p id="31a4" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">活文档不仅仅是测试报告。它还应该报告您所有指定需求的状态，甚至那些还没有任何测试的需求。这给你的项目和产品一个更完整的描述。例如，Serenity BDD既报告已经构建和测试的特性，也报告仅仅以未实现的特性文件的形式计划和定义的特性(您可以在图2中看到一个例子)。</p><figure class="ne nf ng nh gt ns gh gi paragraph-image"><div role="button" tabindex="0" class="nt nu di nv bf nw"><div class="gh gi od"><img src="../Images/d55226fc35d0db5a9daad82b44afb4e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*PL-nue9KxObxhUW9.png"/></div></div><figcaption class="nz oa gj gh gi ob oc bd b be z dk translated">图二。活文档也应该告诉你你已经指定了什么需求，即使还没有针对它们的测试。</figcaption></figure><h2 id="8b11" class="lt lu iq bd lv lw lx dn ly lz ma dp mb ky mc md me lc mf mg mh lg mi mj mk iw bi translated"><strong class="ak">自动化可执行规范</strong></h2><p id="5f39" class="pw-post-body-paragraph kp kq iq kr b ks ml ka ku kv mm kd kx ky mn la lb lc mo le lf lg mp li lj lk ij bi translated">现在是时候将这个可执行的规范转化为自动化测试了。首先，Tess仔细检查了框架项目附带的test runner类。它被配置为运行<em class="ls">特性</em>目录下的所有特性文件，如下所示:</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="e728" class="lt lu iq nj b gy nn no l np nq">@RunWith(CucumberWithSerenity.<strong class="nj ja">class</strong>)<br/> @CucumberOptions(features=<strong class="nj ja">"src/test/resources/features/"</strong>,   <br/>                  glue=<strong class="nj ja">"manning.bddinaction"</strong><br/> )<br/> <strong class="nj ja">public class</strong> AcceptanceTestSuite {}</span></pre><p id="d29b" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">在未来的某一天，她可能会给这个跑步者类添加更多的选项，但现在还不错。</p><p id="8b73" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">接下来，她和Dave编写了测试自动化代码，每当执行他们的场景时都会调用这些代码。请记住，他们的场景如下所示:</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="5e20" class="lt lu iq nj b gy nn no l np nq"><strong class="nj ja">Scenario</strong>: Next train going to the requested destination on the same line<br/>     <strong class="nj ja">Given</strong> the T1 train to Central leaves Hornsby at 08:02, 08:15, 08:21<br/>     <strong class="nj ja">When</strong> Travis want to travel from Hornsby to Chatswood at 08:00<br/>     <strong class="nj ja">Then</strong> he should be told about the trains at: 08:02, 08:15</span></pre><p id="6763" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">他们需要为这些给定的、<em class="ls">、</em>、<em class="ls">和</em>步骤中的每一个写一个方法。Cucumber使用特殊的注释(命名得相当恰当:给定、<em class="ls">@当</em>和<em class="ls">@然后</em>)来知道每个场景步骤要运行哪个方法。这些注释使用正则表达式来标识Cucumber场景中表示测试数据的部分(例如火车线路、车站和时间)。例如，第一个<em class="ls">给定</em>步骤的注释需要传入列车线路、始发站和目的站以及出发时间。我们通常称这个代码为<em class="ls">粘合代码</em>，因为它将场景步骤中的文本绑定到实际的测试自动化或者应用程序代码。</p><p id="c1d1" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">Tess和Dave为这一步编写的初始代码如下所示:</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="0c27" class="lt lu iq nj b gy nn no l np nq"><strong class="nj ja">@Given("the (.*) train to (.*) leaves (.*) at (.*)")</strong><br/> <strong class="nj ja">    public void theTrainLeavesAt(String line,</strong><br/> <strong class="nj ja">                                 String destination,</strong><br/> <strong class="nj ja">                                 String departure,</strong><br/> <strong class="nj ja">                                 String departingAt){}</strong></span></pre><p id="f895" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">Tess将这些方法放在一个名为<em class="ls">departmentinstepdefinitions</em>的类中，她将这个类放在test runner类下面的<em class="ls"> steps </em>包中。完整的类如清单2所示。</p><p id="f52b" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated"><strong class="kr ja">清单2。一个基本的黄瓜场景实现</strong></p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="350a" class="lt lu iq nj b gy nn no l np nq">package manning.bddinaction.steps;<br/>  <br/> import cucumber.api.java.en.Given;<br/> import cucumber.api.java.en.Then;<br/> import cucumber.api.java.en.When;<br/> import java.time.LocalTime;<br/> import java.util.List;<br/> import java.util.stream.Collectors;<br/>  <br/> import static java.util.Arrays.stream;<br/>  <br/> public class DepartingTrainsStepDefinitions {<br/>  <br/>     @Given("the (.*) train to Central leaves Hornsby at (.*)").        #1<br/>     public void theTrainLeavesAt(String line, String departingAt) {}<br/>  <br/>     @When("Travis want to travel from (.*) to (.*) at (.*)").          #2<br/>     public void travelBetween(String departureStation,<br/>                               String destinationStation,<br/>                               String departingAt) {}<br/>  <br/>     @Then("he should be told about the trains at: (.*)").              #3<br/>     public void shouldBeToldAboutTheTrainsAt(String departureTimes) {}<br/>     }</span></pre><p id="3a16" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated"><strong class="kr ja"> #1给定步长</strong></p><p id="d436" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated"><strong class="kr ja"> #2 A时的步骤</strong></p><p id="0cd1" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated"><strong class="kr ja"> #3 A然后步骤</strong></p><p id="7b2f" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">对于实践BDD的团队来说，像这样的代码是通向生产代码的大门。它准确地告诉您底层代码需要做什么来满足业务需求。从这里开始，我们不仅可以考虑我们的产品代码应该做什么，还可以考虑如何最好地测试它。</p><p id="a319" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">这就是泰丝和戴夫接下来要做的。让我们跟踪他们将这些空方法转化为完全成熟的自动化验收测试的过程，然后使用这些测试来推出产品代码。</p><h2 id="dd29" class="lt lu iq bd lv lw lx dn ly lz ma dp mb ky mc md me lc mf mg mh lg mi mj mk iw bi translated"><strong class="ak">实现胶水代码</strong></h2><p id="e40c" class="pw-post-body-paragraph kp kq iq kr b ks ml ka ku kv mm kd kx ky mn la lb lc mo le lf lg mp li lj lk ij bi translated">BDD实践者喜欢从他们需要获得的结果开始，并逆向工作。苔丝和戴夫从第<code class="fe oe of og nj b">@Then</code>步开始，这一步表达了他们期望的结果。他们设想一个实现时间表逻辑的服务。他们不确定这项服务应该是什么样的，但是他们知道他们需要一个建议出发时间的列表。编写glue代码给了他们一个绝佳的机会来试验不同的API设计，看看他们最喜欢什么。</p><p id="22ce" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">Tess更新了<em class="ls"> @Then </em>方法，如下所示:</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="7752" class="lt lu iq nj b gy nn no l np nq">@Then("he should be told about the trains at: (.*)")<br/> public void shouldBeToldAboutTheTrainsAt(String expectedDepartures) {<br/>     List&lt;LocalTime&gt; expected = localTimesFrom(expectedDepartures);       #1<br/>     assertThat(proposedDepartures).isEqualTo(expected);                  #2<br/> }<br/>  <br/> private List&lt;LocalTime&gt; localTimesFrom(String listOfDepartureTimes) {<br/>     return stream(listOfDepartureTimes.split(","))<br/>             .map(LocalTime::parse)<br/>             .collect(Collectors.toList());<br/>  }</span></pre><p id="b110" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated"><strong class="kr ja"> #1将逗号分隔的时间列表转换为Java LocalTime对象列表</strong></p><p id="d6b6" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated"><strong class="kr ja"> #2使用AssertJ断言检查服务返回的日期是否与Cucumber场景</strong>中列出的日期相同。</p><p id="2ec9" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">自然，这段代码还不能编译。他们需要声明<code class="fe oe of og nj b">proposedDepartures</code>变量，并计算出建议的火车将来自哪里；这将在适当的时候到来。</p><p id="af67" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">在编写代码之前编写可执行的规范是发现和充实您需要的技术设计以交付业务目标的好方法。它帮助您发现什么领域类有意义，您需要什么服务，以及服务之间需要如何交互。它还帮助你思考如何使你的代码易于测试，易于测试的代码易于维护。</p><p id="a3cd" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">在这种情况下，Tess设想了一个名为<em class="ls">findnext departments()</em>的简单方法来查找从给定车站出发的下一个发车时间。当她将这段代码添加到步骤定义方法中时，结果如下所示:</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="903c" class="lt lu iq nj b gy nn no l np nq"><strong class="nj ja">List&lt;LocalTime&gt; proposedDepartures;</strong><br/> <strong class="nj ja"> </strong><br/> <strong class="nj ja">@When("Travis want to travel from (.*) to (.*) at (.*)")                   #1</strong><br/> <strong class="nj ja">public void travelBetween(String departure,                                #2  </strong><br/> <strong class="nj ja">                          String destination,                              #2         </strong><br/> <strong class="nj ja">                          String departingAt) {,                           #2  </strong><br/> <strong class="nj ja">    LocalTime departureTime = LocalTime.parse(departingAt);</strong><br/> <strong class="nj ja"> </strong><br/> <strong class="nj ja">    proposedDepartures = itineraryService.findNextDepartures(departure,    #3</strong><br/> <strong class="nj ja">                                                             destination,  #3</strong><br/> <strong class="nj ja">                                                             departingAt); #3</strong><br/> <strong class="nj ja"> </strong><br/> <strong class="nj ja">}</strong></span></pre><p id="d675" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated"><strong class="kr ja"> #1当步骤</strong></p><p id="b8ec" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated"><strong class="kr ja"> #2从When步骤</strong>传入参数</p><p id="55ec" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated"><strong class="kr ja"> #3寻找下一个出发时间</strong></p><p id="4d10" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">“巡回服务从哪里来？”戴夫想知道。“我们需要在早期定义它。”他在类的顶部添加了下面一行来创建服务:</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="37c4" class="lt lu iq nj b gy nn no l np nq">ItineraryService itineraryService = new ItineraryService();</span></pre><p id="3725" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">接下来，他创建了<em class="ls">巡回服务</em>类本身，以及<em class="ls">findnextdepartments()</em>方法的空实现。</p><p id="678c" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">“巡回服务需要知道我们在给定步骤中提到的时间表细节，”Tess指出。“那是一个单独的问题，也许应该放在它自己的类中”。</p><p id="0637" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">“我同意，”戴夫说，“但我们不要因此而分心；时间表的逻辑可能令人毛骨悚然。让我们创建一个时间表接口，以模拟我们的行程服务需要如何与时间表服务进行交互。”</p><p id="378c" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">这是一种典型的BDD方法，通常被称为“由外向内”。当我们实现一个层时，我们发现它需要运行的其他东西，它需要调用的其他服务。我们有一个选择；我们可以直接构建这些东西，也可以把它们放在一边，建模成一个接口或虚拟类，以后再回来。如果第一种方法适用于简单的问题，那么对于更复杂的代码，专注于手头的工作通常会更有效。</p><p id="40d1" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">为了通过这个验收标准，我们的英雄现在需要实现<code class="fe oe of og nj b">findNextDepartures()</code>方法，但是要让这个场景绿色。他们需要改变方式，从验收测试转向单元测试。正如您将看到的，验收测试用于演示应用程序的高级端到端行为，单元测试用于构建实现该行为的组件</p><p id="1cd9" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">验收测试通常使用完整或接近完整的应用程序堆栈，而单元测试则关注孤立的单个组件。单元测试使我们更容易专注于让一个特定的类工作，并确定它需要什么其他的服务或组件。单元测试也使得检测和隔离错误或回归变得更加容易。为了通过验收标准，你通常会编写许多小的单元测试(见图2.8)。在单元测试层面，实践BDD的团队通常使用测试驱动开发(TDD)来驱动实现。</p><p id="5398" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">TDD看似简单。您编写一个测试，描述您期望您的应用程序如何运行。自然就失败了，因为你还没有写任何代码。您编写了足够的代码来通过这个测试。一旦你的测试通过，你看看你的代码，想想你如何整理它，重构它来改进设计，或者当你回到轨道上时，使它更容易阅读和理解。</p><p id="bd4e" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">行为驱动开发和测试驱动开发都是示例驱动开发的例子。在这两种方法中，我们都使用具体的例子来说明、讨论和理解我们想要实现的行为。主要的区别在于TDD倾向于以开发人员为中心的活动，并且它在类、方法和API的详细级别上运行。正如我们已经看到的，BDD是以团队为中心的，并且着眼于业务目标、特性和场景的更大图景。</p><figure class="ne nf ng nh gt ns gh gi paragraph-image"><div role="button" tabindex="0" class="nt nu di nv bf nw"><div class="gh gi oh"><img src="../Images/811be6aa1ef7c18dd73f924e28b3e729.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*WSBIlGDaeJpUbOWy.png"/></div></div><figcaption class="nz oa gj gh gi ob oc bd b be z dk translated">图3。您通常需要编写许多低级的、TDD风格的单元测试来获得通过的自动化验收标准。</figcaption></figure><p id="6a22" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">让我们回到泰丝和戴夫身上。他们将使用JUnit 5编写单元测试，JUnit 5是Java的一个通用单元测试库。现代单元测试库现在通常包括对BDD风格测试的良好支持。</p><p id="b7fa" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">他们从一个单元测试开始，这个单元测试展示了<code class="fe oe of og nj b">findNextDepartures()</code>方法的一个基本用例。您可以在清单3中看到代码。</p><p id="bc49" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated"><strong class="kr ja">清单3。一个简单的BDD风格的单元测试</strong></p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="c241" class="lt lu iq nj b gy nn no l np nq">package manning.bddinaction.itineraries;<br/>  <br/> import org.junit.jupiter.api.DisplayName;<br/> import org.junit.jupiter.api.Test;<br/> import java.time.LocalTime;<br/> import java.util.List;<br/>  <br/> import static org.assertj.core.api.Assertions.assertThat;<br/>  <br/> @DisplayName("When finding the next train departure times")<br/> class WhenFindingNextDepatureTimes {<br/>  <br/>     @Test<br/>     @DisplayName("we should get the first train after the requested time")<br/>     void tripWithOneScheduledTime() {<br/>  <br/>         // Given<br/>         ItineraryService itineraryService = new ItineraryService();     #1<br/>  <br/>         // When<br/>         List&lt;LocalTime&gt; proposedDepartures<br/>             = itineraryService.findNextDepartures(LocalTime.of(8,25),   #2<br/>                                                   "Hornsby",            #2<br/>                                                   "Central");           #2<br/>  <br/>         // Then<br/>         assertThat(proposedDepartures)                                  #3<br/>             .containsExactly(LocalTime.of(8,30));                       #3<br/>     }<br/> }</span></pre><p id="b84f" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated"><strong class="kr ja"> #1创建新的旅程服务</strong></p><p id="7c4d" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated"><strong class="kr ja"> #2查找8:25后从洪斯比到中央车站的发车时间</strong></p><p id="ac4a" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated"><strong class="kr ja"> #3检查服务返回预期时间8:30 </strong></p><p id="659e" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">“我对这次考试不满意”，苔丝说。“我可以看到，我们希望找到8:25之后从Hornsby到Central的下一趟列车，但它没有明确说明为什么答案是8:30——我们是在依赖可能会改变的测试数据吗？这个时间从哪里来？”</p><p id="713b" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">“说得好”，戴夫说。“我们需要包括一个时间表，并设置一些测试数据。我们还不知道时间表API应该是什么样子，但我们可以用一种方法来创建一个时间表，该时间表总是返回特定的出发时间列表。”</p><p id="9ed4" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">Dave重构了单元测试，如下所示:</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="94ef" class="lt lu iq nj b gy nn no l np nq">private LocalTime at(String time) {<br/>     return LocalTime.parse(time, DateTimeFormatter.ofPattern("H:mm"));  #1<br/>     }<br/>  <br/>     private TimeTable departures(LocalTime... departures) { return null; }#2<br/>  <br/>     @Test<br/>  @DisplayName("should the first after the departure time")<br/>  void tripWithOneScheduledTime() {<br/>  <br/>     // Given<br/>     timeTable = departures(at("8:10"), at("8:20"), at("8:30"));              #3<br/>     itineraries = new ItineraryService(timeTable);                  #4<br/>  <br/>     // When<br/>     List&lt;LocalTime&gt; proposedDepartures<br/>        = itineraries.findNextDepartures(at("8:25"),"Hornsby","Central"); #5<br/>  <br/>     // Then<br/>     assertThat(proposedDepartures).containsExactly(at("8:30"));          #6<br/>  }</span></pre><p id="3aed" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated"><strong class="kr ja"> #1创建本地日期的实用方法</strong></p><p id="6ef2" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">一旦我们知道时间表类是如何工作的，这个方法返回一个正确配置的时间表。</p><p id="883a" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated"><strong class="kr ja"> #3创建在指定时间发车的列车时刻表</strong></p><p id="5a12" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated"><strong class="kr ja"> #4创建使用此时间表的路线服务</strong></p><p id="b81b" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated"><strong class="kr ja"> #5查找8:25后从Hornsby到Central的发车时间</strong></p><p id="5282" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated"><strong class="kr ja"> #6检查服务返回预期时间8:30 </strong></p><p id="a7b1" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">“我们可以猜测时间表类需要什么方法，但是开始实现<em class="ls">findnextdepartments()</em>方法并查看我们需要时间表提供什么信息可能更容易，”Tess建议道。</p><p id="81c7" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">经过一番试验，苔丝和戴夫一致认为，这种方法的主要工作是找出两站之间有哪些线路(这是时刻表应该知道的事情)，并找出在指定时间后到达的下两趟列车。您可以在清单4中看到完整的实现。</p><p id="6225" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated"><strong class="kr ja">清单4。巡回服务班</strong></p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="ac2f" class="lt lu iq nj b gy nn no l np nq">package manning.bddinaction.itineraries;<br/>  <br/> import manning.bddinaction.timetables.TimeTable;<br/>  <br/> import java.time.LocalTime;<br/> import java.util.List;<br/> import java.util.stream.Collectors;<br/>  <br/> public class ItineraryService {<br/>     private TimeTable timeTable;<br/>  <br/>     public ItineraryService(TimeTable timeTable) {<br/>         this.timeTable = timeTable;<br/>     }<br/>  <br/>     public List&lt;LocalTime&gt; findNextDepartures(LocalTime departureTime,<br/>                                               String from,<br/>                                               String to) {<br/>  <br/>         List&lt;String&gt; lines = timeTable.findLinesThrough(from, to);      #1<br/>  <br/>         return lines.stream()<br/>                .flatMap(line -&gt; timeTable.getDepartures(line)           #2<br/>                                         .stream())                     #2<br/>                .filter(trainTime -&gt; !trainTime.isBefore(departureTime)) #3<br/>                .sorted()                                                #4<br/>                .limit(2)                                                #5<br/>                .collect(Collectors.toList());                           #6<br/>     }<br/> }</span></pre><p id="f2fd" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated"><strong class="kr ja"> #1询问途经出发地和目的地的线路时刻表。车站</strong></p><p id="4f68" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated"><strong class="kr ja"> #2询问时刻表，了解这些线路的发车时间列表</strong></p><p id="c744" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated"><strong class="kr ja"> #3只保留不早于要求出发时间的出发时间</strong></p><p id="7622" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated"><strong class="kr ja"> #4先显示较早的列车</strong></p><p id="fa41" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated"><strong class="kr ja"> #5只保留前两个发车时间</strong></p><p id="8f15" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated"><strong class="kr ja"> #6返回本地时间对象列表</strong></p><p id="c4e0" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">最后，他们在测试中实现了一个虚拟版本的时间表，返回一个硬编码的时间列表。时间表类的逻辑变得比这复杂得多，但是从行程服务的角度来看，它只需要知道时间表在请求出发时间时发回正确的出发时间。</p><p id="8109" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">这是BDD团队中通常采用的由外向内开发风格的一个很好的例子。在编写这个类的过程中，Tess和Dave发现了他们从时间表类中需要的两件事:它需要告诉他们哪条铁路线经过任意两个车站，以及每条线上的火车什么时候离开给定的车站。他们已经精确地确定了他们需要的方法以及这些方法应该做什么。</p><p id="681a" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">基于这个实现，<code class="fe oe of og nj b">TimeTable</code>接口至少需要包括这些方法:</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="3222" class="lt lu iq nj b gy nn no l np nq"><strong class="nj ja">public interface</strong> TimeTable {<br/>     List&lt;String&gt; findLinesThrough(String from, String to);<br/>     List&lt;LocalTime&gt; getDepartures(String lineName, String from);<br/> }</span></pre><p id="3f07" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">稍后可能会有更多，但从路线服务的角度来看，这些已经足够了。</p><p id="02ae" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">现在他们已经定义了<code class="fe oe of og nj b">TimeTable</code>接口，他们可以返回到最初的测试并完成<code class="fe oe of og nj b">departures()</code>方法，返回我们要求的出发时间:</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="af94" class="lt lu iq nj b gy nn no l np nq">private TimeTable departures(LocalTime... departures) {<br/>     return new TimeTable() {<br/>             @Override<br/>             public List&lt;String&gt; findLinesThrough(String from,<br/>                                                  String to) {<br/>                 return List.of("T1");<br/>             }<br/>  <br/>             @Override<br/>             public List&lt;LocalTime&gt; getDepartures(String line, String from) {<br/>                 return List.of(departures);<br/>             }<br/>         };<br/>     }</span></pre><p id="5bd7" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">成功！有了这个虚拟实现，他们的第一个单元测试就通过了。</p><p id="537c" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">“太好了！”苔丝说。“这个班还需要做什么？”</p><p id="0a28" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">两人继续探索旅程服务的行为，并增加了一些测试来说明这种行为的不同方面。例如，他们希望添加返回多个计划时间的场景，以确保只返回前两个时间。他们还想检查没有更多列车的边缘情况。您可以阅读清单5中的完整测试类。</p><p id="1778" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated"><strong class="kr ja">清单5。已完成的WhenFindingNextDepatureTimes类</strong></p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="6ccd" class="lt lu iq nj b gy nn no l np nq">package manning.bddinaction.itineraries;<br/>  <br/> import manning.bddinaction.timetables.TimeTable;<br/> import org.junit.jupiter.api.DisplayName;<br/> import org.junit.jupiter.api.Test;<br/>  <br/> import java.time.LocalTime;<br/> import java.time.format.DateTimeFormatter;<br/> import java.util.List;<br/>  <br/> import static org.assertj.core.api.Assertions.assertThat;<br/>  <br/> @DisplayName("When finding the next departure times")<br/> class WhenFindingNextDepatureTimes {<br/>  <br/>     private LocalTime at(String time) {<br/>         return LocalTime.parse(time, DateTimeFormatter.ofPattern("H:mm"));<br/>     }<br/>  <br/>     private static TimeTable departures(LocalTime... departures) {   #1<br/>         return new TimeTable() {<br/>  <br/>             @Override<br/>             public List&lt;String&gt; findLinesThrough(String departingFrom, <br/>                                                  String goingTo) {<br/>                 return List.of("T1");<br/>             }<br/>  <br/>             @Override<br/>             public List&lt;LocalTime&gt; getDepartures(String line,<br/>                                                  String from) {<br/>                 return List.of(departures);<br/>             }<br/>         };<br/>     }<br/>  <br/>     TimeTable timeTable;<br/>     ItineraryService itineraries;<br/>  <br/>     @Test<br/>     @DisplayName("should the first after the departure time")<br/>     void tripWithOneScheduledTime() {<br/>  <br/>         timeTable = departures(at("8:10"), at("8:20"), at("8:30"));     #2<br/>         itineraries = new ItineraryService(timeTable);<br/>  <br/>         List&lt;LocalTime&gt; proposedDepartures<br/>             = itineraries.findNextDepartures(at("8:25"),                #3<br/>                                              "Hornsby","Central");      #3<br/>  <br/>         assertThat(proposedDepartures).containsExactly(at("8:30"));     #4<br/>  <br/>     }<br/>  <br/>     @Test<br/>     @DisplayName("should propose the next 2 trains")<br/>     void tripWithSeveralScheduledTimes() {                         #5<br/>  <br/>         timeTable<br/>           = departures(at("8:10"), at("8:20"), at("8:30"), at("8:45"));<br/>         itineraries = new ItineraryService(timeTable);<br/>  <br/>         List&lt;LocalTime&gt; proposedDepartures<br/>          = itineraries.findNextDepartures(at("8:05"),"Hornsby","Central");<br/>  <br/>         assertThat(proposedDepartures)<br/>           .containsExactly(at("8:10"), at("8:20"));<br/>     }<br/>  <br/>     @Test<br/>     @DisplayName("No trains should be returned if none are available"). #6<br/>     void anAfterHoursTrip() {<br/>  <br/>         timeTable = departures(at("8:10"), at("8:20"), at("8:30"));<br/>         itineraries = new ItineraryService(timeTable);<br/>  <br/>         List&lt;LocalTime&gt; proposedDepartures<br/>                 = itineraries.findNextDepartures(at("8:50"),<br/>                 "Hornsby", "Central");<br/>  <br/>         assertThat(proposedDepartures).isEmpty();<br/>     }<br/> }</span></pre><p id="ab13" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated"><strong class="kr ja"> #1为测试目的创建一个虚拟时间表</strong></p><p id="28d3" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated"><strong class="kr ja"> #2假时刻表，返回一组硬编码的出发时间。</strong></p><p id="a0bb" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated"><strong class="kr ja"> #3呼叫巡回服务，查找下一个出发时间</strong></p><p id="0ed4" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated"><strong class="kr ja"> #4核对预计发车时间</strong></p><p id="09ee" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated"><strong class="kr ja"> #5一个稍微复杂一点的测试，检查我们返回不超过两次。</strong></p><p id="59a1" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated"><strong class="kr ja"> #6边缘情况测试，检查在最后一次出发时间之后没有时间返回</strong></p><p id="ef0c" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">随着路线服务的完成，步骤中的<em class="ls">现在开始运行。是时候进入<em class="ls">给出的</em>步骤了:</em></p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="4cd7" class="lt lu iq nj b gy nn no l np nq"><strong class="nj ja">Given</strong> the T1 train to Central leaves Hornsby at 8:02, 8:15, 8:21</span></pre><p id="1f77" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">这一步需要准备行程服务使用的时间表。虽然他们可以使用一个虚拟时间表，但是像这样的BDD场景通常希望验证所有的系统组件都像它们应该的那样一起工作。</p><p id="7cf3" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">“看起来我们需要在这一步准备实际的时间表数据。那会是什么样子？”苔丝想知道。</p><p id="cd1e" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">“我们用一个<em class="ls"> scheduleService </em>方法创建一个<code class="fe oe of og nj b">CanScheduleServices</code>接口来表示这种能力怎么样？我们也可以把它添加到时间表界面中，但是感觉像是一个单独的问题。“大概是这样的:”</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="0084" class="lt lu iq nj b gy nn no l np nq">public interface CanScheduleServices{<br/>     void scheduleService(String line,<br/>                          List&lt;LocalTime&gt; departingAt,<br/>                          String departure,<br/>                          String destination);<br/> }</span></pre><p id="d82a" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">Tess重构了给定的步骤的<em class="ls">粘合代码，以使用该方法:</em></p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="a3a2" class="lt lu iq nj b gy nn no l np nq">InMemoryTimeTable timeTable = new InMemoryTimeTable();<br/>     ItineraryService itineraryService = new ItineraryService(timeTable);<br/>  <br/>     @Given("the (.*) train to (.*) leaves (.*) at (.*)")<br/>     public void theTrainLeavesAt(String line,<br/>                                  String from,<br/>                                  String to,<br/>                                  String departingAt) {<br/>         List&lt;LocalTime&gt; departureTimes = localTimesFrom(departingAt);<br/>         timeTable.scheduleService(line, departureTimes, from, to);<br/>     }<br/>     private List&lt;LocalTime&gt; localTimesFrom(String listOfDepartureTimes) {<br/>         return stream(listOfDepartureTimes.split(","))<br/>                 .map(String::trim)<br/>                 .map(LocalTime::parse)<br/>                 .collect(Collectors.toList());<br/>     }</span></pre><p id="548b" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated"><strong class="kr ja"> #1为特定的林贝</strong>安排出发时间</p><p id="8736" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated"><strong class="kr ja"> #2将小黄瓜场景中的文本转换成本地时间对象列表的实用方法</strong></p><p id="e080" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">“现在我们需要编写一个类来实现时间表接口和CanScheduleService接口”。</p><p id="a777" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">两人再次使用测试优先的策略来想象和实现一个时间表类。他们决定从一个叫做<em class="ls">in memory timetable</em>的简单实现开始。他们从一个像这样的空实现开始:</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="560c" class="lt lu iq nj b gy nn no l np nq">public class InMemoryTimeTable implements TimeTable, CanScheduleServices {<br/>  <br/>     @Override<br/>     public void scheduleService(String line,<br/>                                 List&lt;LocalTime&gt; departingAt,<br/>                                 String departure,<br/>                                 String destination) {}<br/>  <br/>     @Override<br/>     public List&lt;String&gt; findLinesThrough(String from, String to) {<br/>         return null;<br/>     }<br/>  <br/>     @Override<br/>     public List&lt;LocalTime&gt; getDepartures(String lineName, String from) {<br/>         return null;<br/>     }<br/> }</span></pre><p id="3788" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">由于他们选择的模块化设计，以后更容易发展这种实现，甚至用完全不同的实现替换它。</p><p id="aef3" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">第一个测试侧重于调度服务，如下所示:</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="4a11" class="lt lu iq nj b gy nn no l np nq">@DisplayName("When scheduling train services")<br/> class WhenRecordingTrainSchedules {<br/>  <br/>     // Given<br/>     InMemoryTimeTable timeTable = new InMemoryTimeTable();           #1<br/>  <br/>     @Test<br/>     @DisplayName("We can schedule a trip with a single scheduled time")<br/>     void tripWithOneScheduledTime() {<br/>         // When<br/>         timeTable.scheduleService("T1", LocalTimes.at("09:15"),              #2<br/>                                        "Hornsby",<br/>                                  "Central");<br/>         // Then<br/>         assertThat(timeTable.getDepartures("T1", "Hornsby")).hasSize(1);<br/>     }<br/> }</span></pre><p id="a832" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated"><strong class="kr ja"> #1创建新的时间表</strong></p><p id="5a5b" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated"><strong class="kr ja"> #2安排一个单一出发时间的服务</strong></p><p id="a18a" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated"><strong class="kr ja"> #3检查预定出发时间</strong></p><p id="ac96" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">这个测试引导这两个人向<code class="fe oe of og nj b">InMemoryTimeTable</code>类添加一些数据结构。他们决定将预定的行程存储在一个地图中，按行程名称进行索引。</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="c57a" class="lt lu iq nj b gy nn no l np nq">public class InMemoryTimeTable implements TimeTable, CanScheduleServices {<br/>     private Map&lt;String, ScheduledService&gt; schedules = new HashMap&lt;&gt;(); #1<br/>  <br/>     @Override<br/>     public void scheduleService(String line,<br/>                                 List&lt;LocalTime&gt; departingAt,<br/>                                 String from,<br/>                                 String to) {<br/>         schedules.put(line,<br/>                       new ScheduledService(from, to, departingAt));    #2   <br/>        }<br/>    }</span></pre><p id="163f" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated"><strong class="kr ja"> #1在由线路名称索引的地图中存储预定服务</strong></p><p id="f8f1" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated"><strong class="kr ja"> #2记录预定服务</strong></p><p id="ab6d" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">他们还决定将预定服务表示为一个域类，如下所示:</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="cbc4" class="lt lu iq nj b gy nn no l np nq">public class ScheduledService {<br/>     private final String departure;<br/>     private final String destination;<br/>     private final List&lt;LocalTime&gt; departureTimes;<br/>  <br/>     public ScheduledService(String from, String to, List&lt;LocalTime&gt; at) {<br/>         this.departure = from;<br/>         this.destination = to;<br/>         this.departureTimes = at;<br/>     }<br/>        …<br/>    }</span></pre><p id="2854" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">这足以让代码通过。这很简单，他们认为还不需要重构。</p><p id="4fcd" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">现在他们对代码感到满意了，他们继续探索时间表行为，检查描述当您安排几个出发时间以及当您添加多行时会发生什么。每次他们都重复这个循环，编写一个小测试，让它失败，然后检查他们的代码，寻找潜在的改进。经过几次测试后，他们对生产线调度的正常运行感到满意。</p><p id="813f" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">“我们完了，对吧？”戴夫说。</p><p id="783d" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">“没那么快”，苔丝说。我们几乎忘记了时间表接口方法。"</p><p id="060e" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">苔丝是对的。这对于给定的步骤来说足够了，但是对于整个场景来说还不够。他们的下一项工作是编写一个测试，探索<em class="ls"> findLinesThrough() </em>和<em class="ls">get departments()</em>方法。</p><p id="0e10" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">“让我们从简单的例子开始，寻找一条穿过两个车站的线路”，Dave建议道:</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="3b80" class="lt lu iq nj b gy nn no l np nq">@Test<br/> @DisplayName("When querying train services")<br/> class WhenQueryingTrainServices {<br/>     // Given<br/>     InMemoryTimeTable timeTable = new InMemoryTimeTable();<br/>  <br/>     @Test<br/>     @DisplayName("We can ask which lines go through any two stations")<br/>     void queryLinesThroughStations() {<br/>         // When<br/>         timeTable.scheduleService("T1",<br/>                                   LocalTimes.at("09:15"),<br/>                                   "Hornsby", "Central");<br/>         // Then<br/>         assertThat(timeTable.findLinesThrough("Hornsby",<br/>                                                     "Central")).hasSize(1);<br/>     }   <br/> }<br/>  <br/> Their initial implementation of the <em class="ls">findLinesThrough() method looks like this:</em><br/>  <br/>     @Override<br/>     public List&lt;String&gt; findLinesThrough(String from, String to) {<br/>          schedules.entrySet()<br/>                 .stream()<br/>                 .filter(line -&gt; (line.getValue().getDeparture().equals(from)         <br/>                         &amp;&amp; line.getValue().getDestination().equals(to)))<br/>                 .map(Map.Entry::getKey)<br/>                 .collect(Collectors.toList());<br/>          }</span></pre><p id="0914" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">这使得测试通过，但戴夫不相信。“这不是世界上可读性最好的代码”，他评论道。"让我们看看是否可以重构它，使它更容易理解."</p><p id="22d7" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">“也许我们可以整理一下过滤逻辑”，苔丝建议道。“我们试图做的是找到穿过我们提供的两个车站的线路，方向是正确的。”</p><p id="b653" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">“如果我们这样写呢？”戴夫说。他修改了代码，提出了两个新方法，允许他将linesGoThrough()方法重构为可读性更强的方法:</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="5845" class="lt lu iq nj b gy nn no l np nq">private Set&lt;String&gt; lineNames() { return  schedules.keySet(); }       #1<br/>  <br/>     private boolean lineGoesThrough(String line, String from, String to){ #2<br/>         return schedules.getOrDefault(line, ScheduledService.NO_SERVICE)<br/>                         .goesBetween(from,to);<br/>     }<br/>     @Override<br/>     public List&lt;String&gt; findLinesThrough(String from, String to) {<br/>         return lineNames().stream()<br/>                           .filter(line  -&gt; lineGoesThrough(line, from, to))<br/>                           .collect(Collectors.toList());<br/>     }</span></pre><p id="b3cc" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated"><strong class="kr ja"> #1查找所有预定线路的名称</strong></p><p id="c1e4" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated"><strong class="kr ja"> #2检查给定预定线路是否在两个站点之间的便捷方法</strong></p><p id="45c4" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">这也导致他重构ScheduledService类:</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="2484" class="lt lu iq nj b gy nn no l np nq">public class ScheduledService {<br/>     private final String departure;<br/>     private final String destination;<br/>     private final List&lt;LocalTime&gt; departureTimes;<br/>  <br/>     public static ScheduledService NO_SERVICE                             #1<br/>             = new ScheduledService("","", Lists.emptyList());<br/>  <br/>     public ScheduledService(String from, String to, List&lt;LocalTime&gt; at) {…}<br/>  <br/>     public List&lt;LocalTime&gt; getDepartureTimes() {<br/>         return departureTimes;<br/>     }<br/>  <br/>     public boolean goesBetween(String from, String to) {                  #2<br/>         return departure.equals(from) &amp;&amp; destination.equals(to);<br/>     }<br/> }</span></pre><p id="4394" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated"><strong class="kr ja"> #1表示没有出发时间的服务的常数值</strong></p><p id="ef5d" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated"><strong class="kr ja"> #2一种方便的方法，可以更容易地检查两个站点之间的给定服务</strong></p><p id="37ee" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">一旦他们通过了这一关，他们就会添加一个新的测试来说明如何获得给定线路的出发时间:</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="7740" class="lt lu iq nj b gy nn no l np nq">@Test<br/>     @DisplayName("Each line can have a number of departure times")<br/>     void trainLinesHaveMoreThanOneDepartureTime() {<br/>         // When<br/>         timeTable.scheduleService("T1",<br/>                 LocalTimes.at("09:15","09:45"),<br/>                 "Hornsby",<br/>                 "Central");<br/>         // Then<br/>         assertThat(timeTable.getDepartures ( "T1", "Hornsby")).hasSize(2);<br/>     }</span></pre><p id="e07f" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">经过六次这样的小测试后，它们最终得到了清单6中所示的InMemoryTimeTable类。你也可以在Github上看到完整的测试类。</p><p id="6a02" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated"><strong class="kr ja">清单6。已完成的InMemoryTimeTable类</strong></p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="361b" class="lt lu iq nj b gy nn no l np nq">package manning.bddinaction.timetables;<br/>  <br/> import java.time.LocalTime;<br/> import java.util.*;<br/> import java.util.stream.Collectors;<br/>  <br/> public class InMemoryTimeTable implements TimeTable, CanScheduleServices {<br/>  <br/>     private Map&lt;String, ScheduledService&gt; schedules = new HashMap&lt;&gt;();<br/>  <br/>     @Override<br/>     public void scheduleService(String line,<br/>                                 List&lt;LocalTime&gt; departingAt,<br/>                                 String from,<br/>                                 String to) {<br/>         schedules.put(line,<br/>                       new ScheduledService(from, to, departingAt));    <br/>     }<br/>  <br/>     private Set&lt;String&gt; lineNames() { return  schedules.keySet(); }<br/>  <br/>     private boolean lineGoesThrough(String line, String from, String to) {<br/>         return schedules.getOrDefault(line, ScheduledService.NO_SERVICE)<br/>                         .goesBetween(from,to);<br/>     }<br/>     @Override<br/>     public List&lt;String&gt; findLinesThrough(String from, String to) {<br/>         return lineNames().stream()<br/>                 .filter(line  -&gt; lineGoesThrough(line, from,to))<br/>                 .collect(Collectors.toList());<br/>     }<br/>  <br/>     @Override<br/>     public List&lt;LocalTime&gt; getDepartures(String lineName, String from) {<br/>         if (!schedules.containsKey(lineName)) {<br/>             throw new UnknownLineException("No line found: " + lineName);<br/>         }<br/>         return schedules.get(lineName).getDepartureTimes();<br/>     }<br/> }</span></pre><h2 id="ef7e" class="lt lu iq bd lv lw lx dn ly lz ma dp mb ky mc md me lc mf mg mh lg mi mj mk iw bi translated"><strong class="ak">演示:作为实时文档的测试</strong></h2><p id="f4c1" class="pw-post-body-paragraph kp kq iq kr b ks ml ka ku kv mm kd kx ky mn la lb lc mo le lf lg mp li lj lk ij bi translated">一旦实现了一个特性，您应该能够运行您的测试，并在待定的测试中看到通过验收标准(参见图4)。当您应用像BDD这样的实践时，这个结果不仅仅告诉您您的应用程序满足了业务需求。通过验收测试也是进步的具体衡量标准。实现的测试要么通过，要么失败。理想情况下，如果某个特性的所有验收标准都已经自动化并成功运行，您就可以说这个特性已经完成并准备投入生产。</p><figure class="ne nf ng nh gt ns gh gi paragraph-image"><div role="button" tabindex="0" class="nt nu di nv bf nw"><div class="gh gi oi"><img src="../Images/bae8b2b51b2c14ee64e313778c690976.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*4WeZ4J8G15N9qLWy.png"/></div></div><figcaption class="nz oa gj gh gi ob oc bd b be z dk translated">图4。通过的测试现在应该出现在测试报告中</figcaption></figure><p id="394b" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">除了评估应用程序的质量之外，测试的状态还清楚地表明了它在开发过程中所处的位置。通过测试的比例与指定的验收标准的总数相比，很好地显示了到目前为止已经完成了多少工作以及还剩下多少工作。此外，通过跟踪已完成的自动化验收测试的数量与未完成的测试的数量，您可以了解您随着时间的推移所取得的进展。</p><p id="769d" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">当你用这种叙述风格编写测试时，另一个好处就出现了。每一个自动化的验收测试都成为一个文档化的、工作的例子，展示了系统如何被用来解决一个特定的业务需求。当测试是web测试时，工作的例子会用截屏来说明。</p><h2 id="2e4d" class="lt lu iq bd lv lw lx dn ly lz ma dp mb ky mc md me lc mf mg mh lg mi mj mk iw bi translated"><strong class="ak">测试员呢？自动化验收测试和质量保证。</strong></h2><p id="280f" class="pw-post-body-paragraph kp kq iq kr b ks ml ka ku kv mm kd kx ky mn la lb lc mo le lf lg mp li lj lk ij bi translated">当自动化验收测试通过时，自动将您的应用程序部署到生产环境中，这需要大量的训练以及对自动化测试的质量和全面性的极大信心。这是一个有价值的目标，许多组织都做到了这一点，但对大多数组织来说，事情并不那么简单。</p><p id="d317" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">在典型的企业环境中，测试人员可能仍然希望在将应用程序发布到生产环境之前至少进行一些探索性测试。如果自动化测试结果清晰可见，他们可以节省QA团队通常花费在回归或基本机械测试上的几天或几周时间，让他们专注于更有趣的测试活动。这反过来可以大大加快发布周期。</p><h2 id="7012" class="lt lu iq bd lv lw lx dn ly lz ma dp mb ky mc md me lc mf mg mh lg mi mj mk iw bi translated"><strong class="ak">维修</strong></h2><p id="10cc" class="pw-post-body-paragraph kp kq iq kr b ks ml ka ku kv mm kd kx ky mn la lb lc mo le lf lg mp li lj lk ij bi translated">在许多组织中，一旦应用程序投入生产，从事初始项目的开发人员就不再维护它。相反，该任务被移交给维护或BAU(照常营业)团队。在这种环境中，可执行的规范和活文档是简化移交过程的好方法，因为它们提供了一组应用程序功能的工作示例和支持这些功能的代码说明。</p><p id="b043" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">可执行的规范也使维护团队更容易实现变更或错误修复。让我们通过一个简单的例子来看看这是如何工作的。假设用户已经请求被告知将要到达的下四趟列车，而不仅仅是当前情况下的下两趟列车。</p><p id="6a13" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">与此需求相关的场景如下:</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="bfee" class="lt lu iq nj b gy nn no l np nq"><strong class="nj ja">Scenario</strong>: Next train going to the requested destination on the same line<br/>     <strong class="nj ja">Given</strong> the T1 train to Central leaves Hornsby at 08:02, 08:15, 08:21<br/>     <strong class="nj ja">When</strong> Travis want to travel from Hornsby to Chatswood at 08:00<br/>     <strong class="nj ja">Then</strong> he should be told about the trains at: 08:02, 08:15</span></pre><p id="61b6" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">这个场景表达了您当前对需求的理解:应用程序当前的行为是这样的，并且您已经自动化了验收标准和单元测试来证明它。</p><p id="bc11" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">新的用户请求改变了这一切。现在的场景应该是这样的:</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="6b85" class="lt lu iq nj b gy nn no l np nq"><strong class="nj ja">Scenario</strong>: Next train going to the requested destination on the same line<br/>     <strong class="nj ja">Given</strong> the T1 train to Chatswood leaves Hornsby at 08:02, 08:15, 08:21, 8:34, 8:45<br/>     <strong class="nj ja">When</strong> Travis want to travel from Hornsby to Chatswood at 08:00<br/>     <strong class="nj ja">Then</strong> he should be told about the trains at: 08:02, 08:15, 08:21, 08:34</span></pre><p id="ded0" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">当您运行这个新场景时，它会失败(参见图5)。这很好！它表明应用程序没有做需求要求它做的事情。现在您有了实现这一修改的起点。</p><figure class="ne nf ng nh gt ns gh gi paragraph-image"><div role="button" tabindex="0" class="nt nu di nv bf nw"><div class="gh gi oj"><img src="../Images/9cdaf6a98840dad4e2529d23dd93a75f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ngtSGEdI-2evzZ6U.png"/></div></div><figcaption class="nz oa gj gh gi ob oc bd b be z dk translated">图5。失败的验收标准说明了需求所要求的和应用程序当前所做的之间的差异。</figcaption></figure><p id="0606" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">从这里开始，您可以使用单元测试来隔离需要更改的代码。您将更新“应该提议接下来的两列火车”单元测试，以反映新的验收标准:</p><pre class="ne nf ng nh gt ni nj nk nl aw nm bi"><span id="2d13" class="lt lu iq nj b gy nn no l np nq"><strong class="nj ja">@Test</strong><br/> <strong class="nj ja">@DisplayName("should propose the next 4 trains")</strong><br/> <strong class="nj ja">void tripWithSeveralScheduledTimes() {</strong><br/> <strong class="nj ja"> </strong><br/> <strong class="nj ja">    timeTable</strong><br/> <strong class="nj ja">      = departures(</strong><br/> <strong class="nj ja">          at("8:10"),at("8:20"),at("8:30"),at("8:45"),at("8:45"));      #1</strong><br/> <strong class="nj ja">    itineraries = new ItineraryService(timeTable);</strong><br/> <strong class="nj ja"> </strong><br/> <strong class="nj ja">    List&lt;LocalTime&gt; proposedDepartures</strong><br/> <strong class="nj ja">       = itineraries.findNextDepartures(at("8:05"), "Hornsby", "Central");</strong><br/> <strong class="nj ja"> </strong><br/> <strong class="nj ja">    assertThat(proposedDepartures)</strong><br/> <strong class="nj ja">       .containsExactly(at("8:10"), at("8:20"), at("8:30"),at("8:45")); #2</strong><br/> <strong class="nj ja">    }</strong></span></pre><p id="0bf5" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated"><strong class="kr ja"> #1假装服务现在返回更多的行程。</strong></p><p id="60d3" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated"><strong class="kr ja"> #2你现在期望行程服务返回四次。</strong></p><p id="94bb" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">这反过来又帮助您隔离出需要在<code class="fe oe of og nj b">ItineraryService</code>类中更改的代码。从这里开始，您将处于一个更好的位置来正确地更新代码。</p><p id="db69" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">对于较大的变更，显然需要做更多的工作，但是原则对于任何规模的修改都是一样的。如果变更请求是对现有特性的修改，您需要更新自动接受标准来反映新的需求。如果变更是您当前的验收标准没有捕捉到的缺陷修复，那么您需要编写新的自动化验收标准来重现缺陷，然后修复缺陷，最后使用验收标准来证明缺陷已经解决。如果变更大到使现有的验收标准变得多余，您可以删除旧的验收标准并编写新的标准。</p><p id="cc83" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">本文到此为止。</p><p id="fe57" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">如果你想了解这本书的更多信息，你可以在我们基于浏览器的<a class="ae ko" href="https://livebook.manning.com/book/bdd-in-action-second-edition" rel="noopener ugc nofollow" target="_blank"> liveBook </a>阅读器<a class="ae ko" href="https://livebook.manning.com/book/bdd-in-action-second-edition?origin=product-look-inside&amp;utm_source=medium&amp;utm_medium=organic&amp;utm_campaign=book_smart_bdd_1_9_20" rel="noopener ugc nofollow" target="_blank">这里</a>查看。</p></div><div class="ab cl ll lm hu ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="ij ik il im in"><p id="f693" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated"><a class="ae ko" href="https://freecontent.manning.com/bdd-automation-from-executable-specifications-to-automated-tests/#id_ftnref1" rel="noopener ugc nofollow" target="_blank">【1】</a>如果Java不是你的那杯茶，不用担心；代码示例被设计为任何具有一些编程背景的人都可以阅读。</p><p id="881b" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">Maven(http://maven.apache.org/)是Java世界中广泛使用的构建工具。</p><p id="290c" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated">请访问Serenity BDD站点(http://serenity-bdd.info)了解关于这个库的更多信息。</p><p id="2155" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated"><a class="ae ko" href="https://freecontent.manning.com/bdd-automation-from-executable-specifications-to-automated-tests/#id_ftnref4" rel="noopener ugc nofollow" target="_blank">【4】</a>GitHub上这篇文章的出处是<a class="ae ko" href="https://github.com/bdd-in-action/chapter-2." rel="noopener ugc nofollow" target="_blank">https://github.com/bdd-in-action/chapter-2.</a></p><p id="cd86" class="pw-post-body-paragraph kp kq iq kr b ks kt ka ku kv kw kd kx ky kz la lb lc ld le lf lg lh li lj lk ij bi translated"><a class="ae ko" href="https://freecontent.manning.com/bdd-automation-from-executable-specifications-to-automated-tests/#id_ftnref5" rel="noopener ugc nofollow" target="_blank">【5】</a>如果你不是Maven的普通用户，Maven首先下载它需要使用的库——这可能需要一些时间，但是你只需要做一次。</p></div></div>    
</body>
</html>