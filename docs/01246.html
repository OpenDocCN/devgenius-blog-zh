<html>
<head>
<title>Guaranteed message delivery with RabbitMQ</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用RabbitMQ保证消息传递</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/guaranteed-message-delivery-with-rabbitmq-5211cff5f1e3?source=collection_archive---------8-----------------------#2020-06-28">https://blog.devgenius.io/guaranteed-message-delivery-with-rabbitmq-5211cff5f1e3?source=collection_archive---------8-----------------------#2020-06-28</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/d9ff04c103a4dff3f32fa661a04248d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*J-qRZYLVksm_iCT7"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">micha Parzuchowski在<a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="915b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">RabbitMQ是一个成熟稳定的消息服务器，它使用AMQP协议在生产者和消费者之间交换消息。</p><p id="5cd5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">它可以服务于多种用例，包括:瞬态通道、扇出消息、联合等。</p><p id="1603" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这里，我将解释我最常见的用例的一些(可能是全部)配置和参数:保证工人作业队列的消息传递。</p><p id="3463" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这意味着，如果消息被RabbitMQ接受，它将被使用，并且只有在确认后才从队列中删除。</p><p id="9941" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这将包括交换、队列、消费者和生产者设置。也不会涉及RabbitMQ服务器的可靠性和集群。我也不关心订购，因为我大部分时间使用多个消费者。</p><h1 id="dfc4" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">快速RabbitMQ概述</h1><p id="8909" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">要使用rabbitmq，您需要打开一个到服务器的连接。在这个连接上，您可以打开一个或多个通道，这些通道是您用来发布和使用消息的。</p><p id="677c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">建议您在一个渠道发布，在另一个渠道消费。此外，在大多数实现中，通道不是线程安全的，所以每个线程需要一个通道，或者确保同步其访问。</p><p id="e12b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">要“在rabbitmq上发布消息”,你需要将消息发布到交易所。交换接收消息并将其路由到队列。</p><p id="4d19" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">要从rabbitmq获取消息，您需要从队列中获取。要删除消息，您可以确认或拒绝它们。您也可以nack和requeue，将消息保留在队列中。</p><p id="6ac1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">声明是创建交换和队列的行为。绑定是将交换连接到队列。</p><h1 id="a365" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">不丢失您的交换和队列</h1><p id="f748" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">首先，我们需要确保我们的交换和队列能够经受住重启和断开连接，为此，我们要使我们的交换和队列“持久”。</p><p id="8d26" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对于exchange，这意味着“持久=真”、“自动删除=假”和“内部=假”在声明时最好设置为参数。</p><p id="2f20" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对于queue，这意味着在声明queue时，需要将“durable=true”、“auto-delete=false”和“exclusive=false”设置为参数。但是在下面的几个段落中有更多关于队列的论点。</p><p id="45e1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这意味着交换和队列将继续存在，即使不再有客户端存在，并且在服务器重启的情况下。声明的交换和队列是持久的。</p><p id="7f0b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您还需要将交换绑定到队列，以使消息可访问。</p><h1 id="7c07" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">不丢失被拒绝的邮件</h1><p id="24cb" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">现在，当消费消息失败时，它们会被拒绝。如果您想捕获那些失败的消息，您可以设置一个死信队列。</p><p id="6407" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">死信队列，伴随着死信交换，是一种从队列中捕获被拒绝的消息的方法。</p><p id="c840" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您将它们设置为常规交换，通常以“.”为后缀。dlx”和以”结尾的队列。dlq”并绑定它们。还要记得让两者都耐用。</p><p id="3609" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在声明队列时，将“x-dead-letter-exchange = exchange-name . dlx”和“x-dead-letter-routing-key=”设置为参数。</p><p id="0adb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">交换和排队申报汇总</strong></p><p id="bd22" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你声明，按顺序:</p><ul class=""><li id="b183" class="mb mc in kc b kd ke kh ki kl md kp me kt mf kx mg mh mi mj bi translated">持久的交换</li><li id="7200" class="mb mc in kc b kd mk kh ml kl mm kp mn kt mo kx mg mh mi mj bi translated">失败消息的持久交换(dlx)</li><li id="47c4" class="mb mc in kc b kd mk kh ml kl mm kp mn kt mo kx mg mh mi mj bi translated">失败消息的持久队列(dlq)</li><li id="8c2c" class="mb mc in kc b kd mk kh ml kl mm kp mn kt mo kx mg mh mi mj bi translated">将dlx绑定到dlq</li><li id="54db" class="mb mc in kc b kd mk kh ml kl mm kp mn kt mo kx mg mh mi mj bi translated">具有死信参数的持久队列</li><li id="0036" class="mb mc in kc b kd mk kh ml kl mm kp mn kt mo kx mg mh mi mj bi translated">将第一个交换绑定到最后一个队列</li></ul><p id="02b1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当然，这是在单个交换到单个队列的情况下，如果您想要路由到多个队列，您需要重复dlq和队列步骤。</p><h1 id="2749" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">安全使用邮件</h1><p id="2930" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">在AMPQ，使用消息的方式实际上不止一种，但是最常用和推荐的方式是使用consume方法。</p><p id="5c87" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您应该将“自动确认”设置为false，并确保仅在消息可以删除时确认消息。</p><p id="f7c2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果你不能处理一个消息，你应该拒绝它，所以他们去DLQ。</p><p id="fbdc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果您未能确认或拒绝消息，它最终会回到队列中。</p><p id="ad40" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这将确保消息仅在您处理完之后才离开队列，并在失败时进入dlq。</p><p id="831c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一旦你在DLQ消费并确认了一条消息，这条消息就会消失。您还可以将来自DLQ的消息推回到原始队列中进行重新处理。</p><h1 id="d1bb" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">安全发布</h1><p id="646c" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">拥有持久的队列并不意味着持久的消息。消息仍将保留在内存中，并在重新启动或消息不可路由时丢失。</p><p id="e8d0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了确保消息将被路由到一个队列，您将它设置为“mandatory=true”。这意味着，只有当消息在队列中结束时，publish才会返回成功，如果消息不可路由，您会收到错误消息(比如在交换中没有绑定，或者路由关键字规则不正确)。</p><p id="bb51" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">要确保消息进入磁盘，您需要设置“persistent=true”。这将确保rabbitmq将它写入队列中的磁盘。</p><p id="c7ba" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最后。您应该等待消息被写入的确认。</p><p id="fb97" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">还有交易等其他方法，但更快且推荐的方法是使用等待确认。</p><p id="0779" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您在一个打开的通道上调用confirm或wait_for_confirms来等待rabbitmq确认在这个通道上发送的消息被写入了它们应该被写入的位置。</p><p id="afa7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您可以等待每条消息，或者发布一批消息并等待一次。等待是每个频道。</p><p id="c9e0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">使用“懒惰”消息来控制内存使用，使rabbitmq尽可能快地写入磁盘也是有用的。除非你使用仲裁队列，但这是另一个职位。</p><h1 id="d054" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">结论</h1><p id="1126" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">这些都是我所知道的确保你的rabbitmq信息安全的措施。除了集群，但那是另一个故事。</p><p id="6988" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">重要的是要注意，我们增加的每一个坚持、每一个保证都会影响性能。直接的瞬时消息可能是你能走得最快的。也就是说，这仍然是一个非常快速和高效的消息服务器。</p><p id="f41c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果您密切关注内存消耗、磁盘空间和服务器的打开连接数，即使没有以上所有措施，RabbitMQ也很可能不会让您失望。</p><p id="c7ef" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我错过了什么吗？还有其他建议吗？</p></div></div>    
</body>
</html>