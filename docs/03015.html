<html>
<head>
<title>Transactional integration Kafka with database</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kafka与数据库的事务集成</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/transactional-integration-kafka-with-database-7eb5fc270bdc?source=collection_archive---------0-----------------------#2020-09-21">https://blog.devgenius.io/transactional-integration-kafka-with-database-7eb5fc270bdc?source=collection_archive---------0-----------------------#2020-09-21</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/e2118a6f0483a7fb66824740550246e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_8yvmp6hoAhg4ew3_OUuCQ.png"/></div></div></figure><h1 id="9ae8" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">介绍</h1><p id="f581" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">越来越多的项目现在选择Kafka作为他们的消息传递基础设施。这种技术的选择并不总是受到以线性可伸缩性处理大量数据的实际需求的驱动。我们经常可以听到Kafka在平常枯燥的涉及琐碎文档工作流管理的企业项目中的应用。在这种情况下，回答“为什么”这个问题并不容易。有时，它可能是由炒作和卡夫卡在著名项目中的使用的令人印象深刻的例子引起的。在其他情况下，它可能受到以客户的钱为代价进行实验的机会的启发，用先进的技术吸引他。</p><p id="cdac" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">例如，如果我们使用Kafka来分析高负载网站上的用户活动，收集关于客户行为的所有事件，我们有一个密集的数据流，但是每个事件都可能丢失，而不会给整个业务流程带来问题。这种方法不适用于大多数企业应用程序，在这些应用程序中，我们迫切需要Kafka和数据库之间的健壮事务集成。</p><p id="4bbf" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">的确，卡夫卡支持交易，但只是单个话题之间的交易。我们可以原子地接收传入的消息，处理它，发送一些传出的消息，同时可靠地确认原始消息的接收。只要我们只处理Kafka数据，这种方法就很好。在业务流程中涉及任何第三方数据源的任何尝试都会被卡住，因为Kafka从根本上不支持XA事务。</p><p id="5a02" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">在最简单的情况下，我们可以在本地存储任何处理服务的实例状态，并通过向特定的专用“归档”主题发送消息来伴随每次更新。这种发送可以与处理所有其他消息一起事务性地执行，因此数据完整性不会受到影响。在崩溃重启之后，我们总是可以通过从这个“归档”主题中读取整个消息流来恢复这个状态(“事件源”模式，Kafka Streams使用类似的方法)。实例状态可以实现为内存中的结构、文件集合，甚至本地数据库(RockDB经常用于此)。</p><p id="7a74" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">然而，这种方法有一些明显的缺点。</p><ul class=""><li id="b040" class="lw lx in kv b kw lr la ls le ly li lz lm ma lq mb mc md me bi translated">首先，在数据量大，数据完全丢失的情况下，恢复过程可能会太长。</li><li id="3886" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">其次，对位于不同处理服务实例中的数据执行“联合”操作是复杂的。任何查询操作都必须分成几个部分，然后连接接收到的结果。它会降低可扩展性，并且可能需要客户端提供额外的内存来进行进一步的数据处理。更新操作的情况甚至是值得的，因为以事务方式更新几个实例是相当复杂的。</li></ul><p id="8aa4" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">在大多数情况下，我们希望对服务的所有实例继续使用通常的单个数据库，并通过发送/接收Kafka消息以事务方式执行更新。本文主要关注实现这一需求的不同方法。</p><h1 id="d99d" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">发送消息</h1><p id="e4dd" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">让我们从发送消息开始。我们可以非事务性地执行，结果会遇到以下问题:</p><ul class=""><li id="9cea" class="lw lx in kv b kw lr la ls le ly li lz lm ma lq mb mc md me bi translated">如果我们先发送数据库，然后再发送消息，我们将冒接收方永远不会知道更新结果的风险。</li><li id="dcf3" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">如果我们先发送消息，那么接收者可能会在提交数据库事务之前过早地请求更新的数据。此外，数据库更新操作可能会以错误结束，然后邮件的发送方和接收方可能会处于不一致的状态。</li></ul><p id="b3ec" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">乍一看，至少可以描述六种根本不同的方法来实现可靠和一致的操作实现。</p><h2 id="6b0b" class="mk jw in bd jx ml mm dn kb mn mo dp kf le mp mq kj li mr ms kn lm mt mu kr mv bi translated">发送前在数据库中临时存储消息</h2><p id="e30a" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">这是一种标准而简单的JEE模式:</p><ul class=""><li id="7d96" class="lw lx in kv b kw lr la ls le ly li lz lm ma lq mb mc md me bi translated">数据库更新操作创建消息，并将它们存储在数据库表中——队列中以供调度</li><li id="6fe6" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">一个专用的调度程序从队列中读取这些消息，发送出去，然后删除它们。</li></ul><p id="0642" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">在服务实例死亡的情况下，我们最大的风险是发送它，然后接收一些消息两次。但事实上，任何分布式系统的开发人员都应该随时准备应对这类问题。</p><p id="a6f5" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">对于每个发送的消息，应用程序在负载下执行一到两个额外的查询，这取决于调度策略。</p><p id="8c35" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">需要强调的是，遵循这个模式，我们根本不用卡夫卡交易。所有的信息最初都是从卡夫卡的角度出发的。</p><p id="7a70" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated"><strong class="kv io">优点:</strong></p><ul class=""><li id="8651" class="lw lx in kv b kw lr la ls le ly li lz lm ma lq mb mc md me bi translated">对所有开发人员来说是最直截了当、透明和清晰的</li><li id="7869" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">在最简单的情况下，基于“select for update skip locked”操作，它可以很容易地实现。这种实现对所有技术都是一样的，不需要复杂的基础设施组件。</li><li id="adb7" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">有现成的实现，例如，Spring <strong class="kv io"> JdbcMessageStore </strong>或Yandex“d b-queue”</li></ul><p id="c90e" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated"><strong class="kv io">缺点:</strong></p><ul class=""><li id="a141" class="lw lx in kv b kw lr la ls le ly li lz lm ma lq mb mc md me bi translated">即使应用程序不执行任何业务活动，并且根本不发送消息，数据库上相当大的额外负载也是永久的连续轮询。</li><li id="6e45" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">如果消息生成的速度比发送出去的速度快，那么表就会积累更多的数据，从而进一步降低调度过程的速度。因此，我们有一个负反馈系统，这不是很好。</li><li id="b729" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">从发送流程的角度来看，消息按照提交事务的顺序出现，而不是按照应用程序通过将记录保存在队列表中“发送”消息的顺序。例如，让一个事务在时间T1、T3发送消息，并在时间T10提交它们。另一笔交易在T4 T2时间T5也做了同样的事情。在这种情况下，消息将按照T2、T4… T1、T3的顺序发送。</li><li id="fe2e" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">在一个分区的上下文中保持消息的顺序要求在任何给定时间集群中只有一个专用线程，该线程从该分区发出消息。这种限制的可靠实现也不简单。</li><li id="dd1c" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">一些正确的、经过仔细测试的、随时可用的实现(例如<strong class="kv io"> JdbcMessageStore </strong>)只能与特定的基础设施一起应用，这本身就是重量级的。</li></ul><p id="5d77" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">结果，这种方法的严格正确的实现变得非常复杂，并且不够可伸缩，尤其是在高负载的情况下。那些愿意的人可以自己在论坛上阅读关于<strong class="kv io"> JdbcMessageStore </strong>性能问题的讨论。如果我们不特别关心消息顺序，高吞吐量不是关键，也许卡夫卡也不需要？</p><h2 id="4681" class="mk jw in bd jx ml mm dn kb mn mo dp kf le mp mq kj li mr ms kn lm mt mu kr mv bi translated">卡夫卡JDBC连接器</h2><p id="63f9" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">Kafka还建议应用程序外部实现前面的方法——JDBC连接器(源和宿)。这些模块允许将表记录转换成消息，或者相反。如前所述，发送消息是通过以可配置的间隔轮询源数据库表来实现的。</p><p id="4745" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">主要的优点是这个功能已经实现了，并且它与已经存在的应用程序的集成只需要开发人员最少的努力。</p><p id="1bdf" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">上述问题的另一个缺点是需要在集群中部署其他基础设施并对其进行管理。此外，该模块的配置选项并不意味着可以在单个分区的上下文中保存消息的顺序，这使得这种方法的适用性受到一定的限制。</p><p id="35f8" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">总的来说，这种方法似乎更像是一种集成现成应用程序的技术，而不是解决问题的方法。</p><h2 id="78bd" class="mk jw in bd jx ml mm dn kb mn mo dp kf le mp mq kj li mr ms kn lm mt mu kr mv bi translated">低层的“更改数据-捕获”模式</h2><p id="ebac" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">这也是对第一种方法的一些修改，但是没有通过SQL查询轮询数据库服务器。在这种情况下，我们安装特殊的软件，可以订阅系统事件，对相应表中的新记录做出反应，并将它们转换为Kafka消息。</p><p id="22ba" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">现在，下一个工具可用了:</p><ul class=""><li id="050b" class="lw lx in kv b kw lr la ls le ly li lz lm ma lq mb mc md me bi translated">【Linkedin的数据总线—仅支持Oracle</li><li id="1a34" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">Debezium——最知名的解决方案，通过插件架构支持大量数据库</li><li id="4e7b" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">来自网飞的DBLog——它看起来还没有作为开源软件发布</li><li id="ee5e" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated"><strong class="kv io">瓶装水</strong>——它很受欢迎，但没有得到更多支持</li></ul><p id="5557" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">优点和缺点列表大致相同，但是引入中间存储的主要缺点已经消除——不存在持续轮询。</p><h2 id="4d56" class="mk jw in bd jx ml mm dn kb mn mo dp kf le mp mq kj li mr ms kn lm mt mu kr mv bi translated">组合事务管理器</h2><p id="e627" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">这种模式是Spring生态系统的标准模式:<strong class="kv io">基于<strong class="kv io"> JpaTransactionManager </strong>和<strong class="kv io"> KafkaTransactionManager </strong>的chained KafkaTransactionManager</strong>，后者反过来管理本地Kafka事务。</p><p id="2f67" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">这种方法可以被认为是“1PC尽力模式”的一种实现。这种模式的主要思想是，最“稳定”的资源的更改与最后的更改一起提交，这大大降低了两个系统不一致的最终状态的风险。</p><p id="852f" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">主要问题是我们以什么样的顺序联合事务管理器:</p><ul class=""><li id="fa9a" class="lw lx in kv b kw lr la ls le ly li lz lm ma lq mb mc md me bi translated">在负载情况下，数据库操作的提交时间可能很长，如果我们首先提交Kafka，收到消息的客户将无法请求修改的数据</li><li id="0e2c" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">如果我们在数据库之后提交Kafka，服务有一点点可能会在这两个操作中间终止</li></ul><p id="997f" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">是的，最后一种概率很低，我们通常会忽略。但是如果我们将它乘以大量的消息，我们将会得到相当真实的损失，这是不可接受的，例如，在处理财务数据期间。从另一个角度来看，如果只处理很少的信息，重新思考我们是否需要卡夫卡可能是有意义的。</p><p id="985c" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">怎样才能消除损失的风险？简单的想法是将发送的消息可靠地保存在数据库中，并在Kafka提交操作之后立即删除它们。这种方法最简单的实现可以基于以下常见组件:</p><p id="eaeb" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated"><strong class="kv io"> &gt;事务性作用域存储。</strong></p><p id="f4ed" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">最初，我试图使用本地线程变量，但在几次不成功的尝试和大量相当复杂的代码之后，我决定Spring transactional context可能是它的最佳位置。</p><p id="30e1" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">代替变量，我在<strong class="kv io">ChainedKafkaTransactionManager</strong>配置中添加了第三个事务管理器，它使用以下信息管理<strong class="kv io"> InfoHolder </strong>对象:</p><ul class=""><li id="7c38" class="lw lx in kv b kw lr la ls le ly li lz lm ma lq mb mc md me bi translated"><strong class="kv io"> currentTx </strong> —当前卡夫卡交易的UUID</li><li id="6307" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated"><strong class="kv io">commit error</strong>—Kafka提交错误事件的标志</li><li id="1dc7" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated"><strong class="kv io">深度</strong> —嵌套Kafka交易的索引</li><li id="2a6e" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated"><strong class="kv io">传播</strong> —当前Kafka交易的传播属性</li></ul><p id="d6dd" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated"><strong class="kv io"> &gt;特殊伪事务管理器</strong></p><p id="5e5b" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated"><strong class="kv io">ChainedKafkaTransactionManager</strong>在所有其他事务管理器之前和之后调用它<strong class="kv io"> </strong>。它唯一的责任是提供对具有最大深度值的“最后一个”<strong class="kv io"> InfoHolder </strong>实例的访问——对最后一个嵌套Kafka事务的描述。<strong class="kv io"> InfoHolder </strong>的所有实例都存储在<strong class="kv io">transactionsynchronizationmanager . resource map</strong>集合中，并在事务管理相关操作期间进行更改。</p><p id="1176" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">另一个它的逻辑很简单:</p><ul class=""><li id="d5d5" class="lw lx in kv b kw lr la ls le ly li lz lm ma lq mb mc md me bi translated">在<strong class="kv io"> doGetTransaction() </strong>上，它用<strong class="kv io">deep = lastinfoholder . deep+1</strong>创建新的<strong class="kv io"> InfoHolder </strong>对象(如果是第一个实例，则为1)。这段代码在其他两个事务管理器之前执行。</li><li id="83ab" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">在<strong class="kv io"> doBegin() </strong>上，它接收<strong class="kv io"> InfoHolder </strong>实例作为<strong class="kv io">事务</strong>参数的值，并通过调用<strong class="kv io">transactionsynchronizationmanager . bind resource()</strong>函数将其注册到<strong class="kv io">transactionsynchronizationmanager . resource map</strong>集合中。根据<strong class="kv io"> TransactionDefinition </strong>参数的<strong class="kv io"> propagation </strong>属性的值，它将<strong class="kv io"> currentTx </strong>属性的值从上一个<strong class="kv io"> InfoHolder </strong>实例复制到当前实例，或者生成新实例(例如，如果<strong class="kv io">propagation = = REQUIRES _ NEW</strong></li><li id="8999" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">在<strong class="kv io">docleanupfatecompletion()</strong>上，它读取最后一个<strong class="kv io"> InfoHolder </strong>对象，并使用相应的<strong class="kv io"> currentTx </strong>属性从数据库中删除所有消息，但前提是<strong class="kv io"> (deep == 0或propagation == REQUIRES_NEW)和commit terror = = false</strong>(真实的表达式更复杂，但对于示例来说已经足够了)。此外，它还执行<strong class="kv io"> unbindResource() </strong>操作，并从<strong class="kv io">TransactionSynchronizationManager</strong>范围中抛出最后一个<strong class="kv io"> InfoHolder </strong>对象。这段代码在其他两个事务管理器之后执行。</li></ul><p id="0e38" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated"><strong class="kv io"> &gt;卡夫卡制作人</strong></p><ul class=""><li id="4496" class="lw lx in kv b kw lr la ls le ly li lz lm ma lq mb mc md me bi translated">它的主要职责是用<strong class="kv io"> currentTx </strong>属性保存数据库中的任何消息，该属性可以从由<strong class="kv io">transactionsynchronizationmanager . resource map</strong>集合提供的最后一个<strong class="kv io"> InfoHolder </strong>对象中读取。</li><li id="ab46" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">发送的消息以<strong class="kv io"> ProducerRecord </strong>实例的形式提供，包含所有必要的信息，以便在提交期间出现任何问题时再次发送。</li><li id="731d" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">也有必要考虑到，卡夫卡忽略了这个代码的所有例外。所以，如果我们需要使用它们，唯一的办法就是把它保存在最后一个<strong class="kv io"> InfoHolder </strong>对象中。</li></ul><p id="276c" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">&gt;这个构造的最后一个组件是稍微定制的<strong class="kv io"> KafkaTransactionManager。</strong>上<strong class="kv io">的doCommit() </strong>方法它:</p><ul class=""><li id="fa39" class="lw lx in kv b kw lr la ls le ly li lz lm ma lq mb mc md me bi translated">从<strong class="kv io">TransactionSynchronizationManager</strong>获取最后一个<strong class="kv io"> InfoHolder </strong>对象，并将其<strong class="kv io"> commitError </strong>属性设置为true</li><li id="3690" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">执行原始的<strong class="kv io"> doCommit() </strong>方法</li><li id="8e89" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">将<strong class="kv io"> commitError </strong>属性设置回false</li></ul><p id="6d40" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">最后一个组件是<strong class="kv io"> ApplicationReadyEvent </strong>的监听器，它从表中读取所有“遗忘”的消息，并在死亡后重新启动服务时再次发送它们。为了最大限度地减少发送的重复项的数量，可以执行以下操作:</p><ul class=""><li id="b9c2" class="lw lx in kv b kw lr la ls le ly li lz lm ma lq mb mc md me bi translated">等待一段时间，直到服务实例不可用时启动的事务完成。</li><li id="931f" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">从传出主题中读取最新消息，并从数据库表中删除相应的条目。</li></ul><p id="0173" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">下图旨在说明上述交互:</p><figure class="mx my mz na gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mw"><img src="../Images/9a5f59383ddb2635141c6657a9448ba8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ptE2_kFLcYxaOvLia8S9TQ.png"/></div></div></figure><p id="92ca" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated"><strong class="kv io">优点:</strong></p><ul class=""><li id="9244" class="lw lx in kv b kw lr la ls le ly li lz lm ma lq mb mc md me bi translated">根本没有持续的数据库轮询。</li><li id="5f8d" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">SQL请求的数量可以最小化到每个事务2个(通过在<strong class="kv io"> InfoHolder </strong>对象中批处理消息)。</li><li id="48fa" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">发送消息和删除成功提交的消息的过程不能相互“滞后”。</li><li id="47b7" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">用于临时存储“提交过程中”的消息的表的大小总是很小，并且操作执行得非常快。</li><li id="9488" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">实现足够紧凑和清晰。</li></ul><p id="b81c" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated"><strong class="kv io">缺点</strong></p><ul class=""><li id="2109" class="lw lx in kv b kw lr la ls le ly li lz lm ma lq mb mc md me bi translated">对于每个平台(例如，Spring / JEE)，我们需要以特定的方式实现它。</li><li id="8317" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">由于单个事务有许多不同的可能组合，彻底测试这些代码是一项挑战。在编写了几十个测试之后，我意识到这个过程真的是无止境的。</li><li id="c6df" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">由于超时，任何与事务相关的代码都很难调试。</li><li id="ebdb" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">像Camunda这样的高级框架喜欢在给定的地方进行定制，有些甚至试图在线程之间移植事务的上下文(我自己也不止一次这样做过)。没有人能保证你的代码与这些技巧保持兼容。</li></ul><p id="bc75" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">虽然我已经设法使这种方法可靠地工作，但总的来说，它似乎相当脆弱，需要广泛和昂贵的测试。所以，我只能推荐它用于大而长的项目。</p><h2 id="06a4" class="mk jw in bd jx ml mm dn kb mn mo dp kf le mp mq kj li mr ms kn lm mt mu kr mv bi translated">目的主题作为传递证明的用法</h2><p id="4006" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">这种方法的总体思路大致相同:</p><ul class=""><li id="7f21" class="lw lx in kv b kw lr la ls le ly li lz lm ma lq mb mc md me bi translated">简介<strong class="kv io">chained KafkaTransactionManager</strong>为<strong class="kv io"> JpaTransactionManager </strong>和<strong class="kv io"> KafkaTransactionManager的组合。</strong></li><li id="02a0" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">在数据库事务期间可靠地保存Kafka消息。</li><li id="ccd3" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">在Kafka事务成功提交后删除它。</li></ul><p id="b097" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">唯一的区别是移除的方法:</p><ul class=""><li id="a466" class="lw lx in kv b kw lr la ls le ly li lz lm ma lq mb mc md me bi translated">每条消息都包含相应数据库记录的主键值。</li><li id="3d27" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">专用的系统消息监听器接收来自输出主题的所有消息，并从数据库中删除相关记录。它可以从Kafka读取它们，立即确认，并出于优化目的从数据库中删除整个数据集。</li></ul><p id="fac0" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">恢复过程大致相同，但是由于保存和删除数据库记录之间的延迟更大，因此最好在再次发送被遗忘的消息之前阅读输出主题。</p><p id="9466" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">下图旨在说明上述交互:</p><figure class="mx my mz na gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nb"><img src="../Images/d4981d110625e939d7d8f1dae82858c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PPysIdN03epvUB3WwWwsng.png"/></div></div></figure><p id="31ae" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated"><strong class="kv io">优点:</strong></p><ul class=""><li id="d3c1" class="lw lx in kv b kw lr la ls le ly li lz lm ma lq mb mc md me bi translated">就分布式日志技术而言，最符合逻辑、最直接、最透明</li><li id="8b89" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">对系统服务和组件的入侵最小</li><li id="e599" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">由于简单性，它对错误和错误有很强的适应性。</li><li id="10e7" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">完全没有持续的数据库轮询，完全是事件驱动的过程</li><li id="f0af" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">在许多情况下，根本不需要任何<strong class="kv io">ChainedKafkaTransactionManager</strong>就可以轻松实现</li></ul><p id="5a1f" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated"><strong class="kv io">缺点</strong></p><ul class=""><li id="f4ca" class="lw lx in kv b kw lr la ls le ly li lz lm ma lq mb mc md me bi translated">资源消耗最大(每条消息一到两个SQL查询、与代理的连接、后台网络流量、监听器线程等等)</li><li id="10cb" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">保存和删除数据库记录、表中的更多数据</li></ul><p id="bdcd" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">通过一些小的修改，这种方法可以应用于完全非事务性的服务，例如邮件服务器。</p><h2 id="131b" class="mk jw in bd jx ml mm dn kb mn mo dp kf le mp mq kj li mr ms kn lm mt mu kr mv bi translated">Kafka与数据库TX事务的组合</h2><p id="22b6" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">有这样一种交易模式，称为“最后资源策略优化(LRCO)”这种方法意味着不支持XA的资源可以(相对)安全地包含在包含多个资源的两阶段提交事务中。</p><p id="6a1d" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">重要的是:交易必须是两阶段的(通常是XA)。除了一个资源之外，所有资源都必须支持XA。</p><p id="1cb3" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">就我从文档中看到的，很多事务管理器都支持这种类型的优化，例如JBoss提供的和Atomikos</p><p id="ab2e" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">当然，如果数据库支持XA事务，这看起来是最无缝的解决方案。不幸的是，Atomikos，例如，开箱即用，包含这种模式的实现只有JDBC数据源和不知道卡夫卡。我可以找到任何关于成功实现这种方法的信息。</p><h2 id="6da5" class="mk jw in bd jx ml mm dn kb mn mo dp kf le mp mq kj li mr ms kn lm mt mu kr mv bi translated">业务驱动的方法</h2><p id="0fea" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">这种方法是默认推荐的<strong class="kv io">ChainedKafkaTransactionManager</strong>与考虑一些业务需求和合理权衡的组合。</p><p id="bbc4" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">首先，我建议在可靠负载和模拟基础设施问题下测量丢失消息的频率。如果你每年最多能错过十条消息，每笔交易的平均金额在100欧元左右，那就意味着投入大量的时间和精力在上述问题的解决上没有任何意义。忘记并继续解决业务任务，以增加未来最大可能的损害。</p><p id="b083" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">其次，如果您做的是严肃的业务，我建议您已经有了一些SLA集合、监控系统和工具来解决“夹在中间”的业务实体的问题。这种工具的存在意味着单个业务操作已经以无能为力的方式实现了。因此，消息的丢失将不可避免地被监控检测到，之后您只需请求再次执行上一个操作。如果您没有这样的监控系统，那么您要解决的问题将比本文中描述的更加严重。</p><p id="a7c2" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">第三，越复杂的代码被设计成最小化可能的损失，它内部包含的错误就越多。开发、调试和修复错误所需的时间就越长。它消耗的内存和处理器时间就越多。此外，我们不应该忘记，由于这些错误造成的事故也要花钱。</p><p id="efac" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">一般来说，这个推理应该放在文章的开头，但那样就没有人再往下读了，我也就没有理由展示我深入的知识了。</p><h1 id="0ffa" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">接收消息</h1><p id="6f8f" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">这种情况要容易得多:即使没有Kafka事务模式，您也可以完成数据库事务并确认Kafka消息。</p><p id="6f53" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">如果倒楣的事情发生，最大的问题是两次收到相同的信息。防止它不是一个重要的问题(无论如何，在分布式架构中，我们必须以某种方式这样做):</p><ul class=""><li id="0163" class="lw lx in kv b kw lr la ls le ly li lz lm ma lq mb mc md me bi translated">将消息的唯一键(技术=主题名+分区索引+偏移量或业务，这可能更好)插入到具有唯一索引的专用表中。我们可以在流程开始时立即执行，对于重复的数据库事务将立即回滚。</li><li id="88ee" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">这个表可以定期清理，不会降低性能，因为您很难期望以超过一周的时间间隔收到副本。但是，一切当然取决于业务流程。</li><li id="f013" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">此外，有必要考虑到该表是高并发存储。因此，我们需要在数据库级别优化它(例如，对于Oracle，通过INITRANS选项)，并通过分片进行优化(向每个表发送几个单独的表，这些表中有散列键分割后的相应剩余部分)。</li></ul><p id="87dd" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">如果处理每条消息都需要执行与数据库相关的操作，那么这种模式或多或少是最佳的。在这种情况下，I/O吞吐量受到数据库的限制，每条消息增加一个查询并不会改变太多情况。此外，大多数时候，我们不仅需要拒绝重复，还需要通过返回与以前相同的值来提供服务的幂等性。这个值必须存储在某个地方，与唯一消息键一起存储更合理。在企业应用程序的情况下，这大约是所有用例的99.99%。</p><p id="ce3f" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">但是，如果您只需要不时地更新数据库，该怎么办呢？对于一些优化最直接的方法，我们可以应用Bloom filter——空间高效的概率数据结构，由Burton Howard Bloom在1970年提出，来测试一个元素是否是集合成员。</p><p id="db96" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">从实现的角度来看，它只是一个位数组。唯一的细微差别是它是假阳性的。通过设置误报决策的概率(从业务角度来看这是可以接受的)和受控元素的数量，您可以获得所需的数组大小。</p><p id="881c" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">因此，重复筛选的优化实现可能如下所示:</p><ul class=""><li id="715d" class="lw lx in kv b kw lr la ls le ly li lz lm ma lq mb mc md me bi translated">对于每个分区，过滤器的状态分别存储在数据库中。</li><li id="e264" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">应用程序使用<strong class="kv io">ConsumerRebalanceListener</strong>来获取关于重新平衡过程的事件。</li><li id="a321" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">在分配分区之后，应用程序加载相应过滤器的状态，在撤销之后，将状态与数据处理的结果一起保存，包括最后的偏移。</li><li id="1a3c" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">应用程序将消息的唯一键应用于过滤器，从而在接收到每条消息时识别出重复的消息。是的，我们的过滤器可以返回假阳性结果，我们可以丢失一些信息，但我们可以控制这种“倒霉事”的目标频率，并使可能的损失可以接受。</li><li id="caf8" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">应用程序定期将处理结果保存在数据库中，包括过滤器的状态和最后的偏移。</li><li id="00e6" class="lw lx in kv b kw mf la mg le mh li mi lm mj lq mb mc md me bi translated">从死亡状态重启后，应用程序从数据库中读取先前的状态(过滤器+处理结果)，应用偏移量，并继续工作</li></ul><p id="b5ad" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">布隆过滤器也可以应用于前一种情况，以最小化SQL查询的数量。但是，只有当我们想要使用相当大的时间窗口(这会导致一个巨大的表)并且不关心幂等性时，它才是合理的。在这种情况下，我们首先使用过滤器，只有在肯定答案的情况下，才使用SQL查询验证它。</p><h1 id="8e36" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">结论</h1><p id="cc38" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">Kafka并不是处理企业应用程序内部事务性用例的最佳解决方案。如果你不是脸书，也不打算开发一个世界范围的支付系统，你可能不需要它。XA事务加入了JMS和数据库，能够完全满足你的所有需求。</p><p id="e184" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">然而，可以想象Kafka在实现CQRS /事件源模式、提供备份存储以及促进新类型服务的引入方面是有用的。</p><p id="9792" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">在Kafka和数据库之间实现事务性交互时，建议遵循最简单的方法，不要追求实现的绝对精度。通常，折中的方法会更好地减少可能的损失。</p><p id="e028" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">对于发送消息，我可以推荐一种带有标准<strong class="kv io">ChainedKafkaTransactionManager</strong>的方法，无需任何额外的定制。如果你是偏执狂，你可以用一个目的地话题作为传递的证明。接收消息的最佳方法是使用专用表来存储接收到的消息的密钥和答案。</p><p id="2c81" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">最后的一般建议是:测试、衡量和估计可能的金钱损失。不要试图最小化在真空中操作球形马的成本。</p></div></div>    
</body>
</html>