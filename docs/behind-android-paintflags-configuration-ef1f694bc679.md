# Android Paintflags 配置，已解释

> 原文：<https://blog.devgenius.io/behind-android-paintflags-configuration-ef1f694bc679?source=collection_archive---------12----------------------->

![](img/2bdc5f5755df2cbc9ce7966009a75a34.png)

当我在做一个 Android Kotlin 项目时，我偶然发现了这段代码:

目的很简单。我们需要在复选框被选中时删除文本，或者在复选框未被选中时删除删除线。但出于某种原因，Android 配置它的方式很奇怪，至少对我来说是这样。

我之所以觉得奇怪，是因为这是我第一次在任何框架或者 SDK 中遇到以 bitmask 作为配置的情况。有几个框架/库不使用位掩码的例子:

*   CSS:如果你想显示一些东西，你可以直接在 CSS 文件中给类或者`id`配置添加一个属性。
*   Laravel:完成的大部分配置都是用 PHP 的数组。
*   Tailwind:你只需要在自己的视图中使用已有的类。
*   Flutter:要么构建小部件类，要么以通常的方式设置现有的属性(使用类的属性)。

然后我意识到，这实际上是一个很酷的方式来使用他们的配置位掩码。

# 我们来谈谈位掩码

位掩码只是修改一个或多个位的行为。更多细节可以在[维基百科](https://en.wikipedia.org/wiki/Mask_(computing))找到，但是如果你愿意，你可以留在这里继续阅读我的解释。

## 等等…先说 Bit 吧

那么，什么是比特呢？一位(二进制数字的缩写)是计算中最基本的单位或信息。它用两个值表示逻辑值:0(或假)和 1(或真)。在特定状态下，计算机只能保存其中一个值(不能同时保存两个值)。

这位在计算机中也用来表示数字。我们每次处理一个数，计算机总是以二进制为基数(2 为基数)进行处理。由于计算机已经使用位，二进制比日常的十进制更容易处理。

```
+-----------+--------------+
|  Decimal  | 8-Bit Binary |
+-----------+--------------+
| 0         |     00000000 |
| 1         |     00000001 |
| 2         |     00000010 |
| 3         |     00000011 |
| 4         |     00000100 |
| 5         |     00000101 |
| 6         |     00000110 |
| 7         |     00000111 |
| 8         |     00001000 |
| and so on |              |
+-----------+--------------+
```

上表描述了十进制和二进制之间的比较。每当二进制系统每 10 个数字(从 0 到 10)重复一个数字，二进制系统每 2 个数字(从 0，1，然后 10)重复一个数字。请注意，我在实数前面附加了零，只是为了向您展示计算机内存中的数字表示。

我在这里不打算深入谈论 bit，只是向你们展示数字是如何以 bit 存储的。你可以在这里了解更多关于读取二进制数[的知识。之后，我们再回头讨论比特操作。](https://www.lifewire.com/how-to-read-binary-4692830)

## 位操作和位掩码

你知道你可以操纵钻头`by hand` ( `by hand`我的意思是你可以在某个位置操纵钻头)？有一种特殊的方法，叫做位掩码。

位掩码是一种位操作类型，可用于更改一个或多个位。具体来说，它是一个辅助数据(在我们的例子中是数字)，可以用来更改原始数字。

为了学习位操作，我们必须先学习位操作符。就像算术计算一样，有许多位操作符可以和位掩码一起使用来改变整数。

```
+-------------+----------+-------------------+--------------+
|    Name     | Operator | Kotlin equivalent | Truth table? |
+-------------+----------+-------------------+--------------+
| AND         | &        | and               | yes          |
| OR          | |        | or                | yes          |
| XOR         | ^        | xor               | yes          |
| Shift left  | <<       | shl               | no           |
| Shift right | >>       | shr               | no           |
| Invert      | ~        | .inv() method     | no           |
+-------------+----------+-------------------+--------------+
```

在这篇文章中，我将关注除了`xor`之外的所有操作符，因为我们需要知道那些用于`Paintflags`配置的操作符。

## `AND`与或运算

`AND`和`OR`操作是位操作中最基本的操作。每个运算取两个数字，并根据真值表产生结果:

```
+-----------+-----------+------------+-----------+
| Operand 1 | Operand 2 | AND result | OR result |
+-----------+-----------+------------+-----------+
|         0 |         0 |          0 |         0 |
|         0 |         1 |          0 |         1 |
|         1 |         0 |          0 |         1 |
|         1 |         1 |          1 |         1 |
+-----------+-----------+------------+-----------+
```

正如你所看到的，`AND`操作只在两个操作数都为 1 时产生 1，而`OR`操作在其中一个操作数为 1 时产生 1。基于此，我们可以使用:

1.  `AND`将任一位更改为 0 的操作(也称为`unset`)。例:5&3 = 000000101&00000011 = 00000001 = 1。
2.  `OR`将任一位变为 1 的操作(又称`set`)。例如:5 | 3 = 00000101 | 00000011 = 00000111 = 7。

## 倒置

假设你有一个数字 7，用比特表示为`00000111`。如果我想反转所有的位(从 0 到 1，从 1 到 0)，该怎么办？我们使用反演算子。在 Java 中，您可以像这样反转这些位:

但是，在 Kotlin 中，不使用`~`操作符，而是使用`.inv()`方法:

万一你问为什么显示`-8`，那是因为反位是`11111000`。如果变量是*无符号*整数(没有负值)，会显示`4294967288`。但是，因为我们使用带符号的整数(带正/负号的整数)，计算机会显示负整数。你可以在这里了解更多关于负整数表示[的知识。](https://www.bbc.co.uk/bitesize/guides/zjfgjxs/revision/5)

## 移位

假设你有一个数字 6，用位`00000110`表示。您想要乘以 2 的幂(例如 4)，但是出于性能原因，您不想使用乘法运算符。嗯，这种情况下可以左移`sqrt(N)`倍。每向左移动一次意味着你要乘以 2。如果你向左移动 2 次，这意味着你要乘以`2 to the power of 2`，也就是 4。

```
+------------+----------+
| Shift left |   Bit    |
+------------+----------+
|          0 | 00000110 |
|          1 | 00001100 |
|          2 | 00011000 |
|          3 | 00110000 |
+------------+----------+
```

"等等，但是这意味着，如果我右移，我将这个数除以 2 的幂？"是的，你是对的！如果你把这位向右移，情况正好相反。

但是，位移法不仅仅用于数的乘/除。我们可以用它来控制特定的位。我们将在 Paintflags 配置中看到更多这样的内容。

# Paintflags 配置

让我们回到文章开头的片段:

`paintFlags`属性是一个有符号整数，所以它包含 64 位。`STRIKE_THRU_TEXT_FLAG`是一个值为 16 的常数。你知道如何用比特来表示数字 16 吗？让我们记住 16 是 2 的 4 次方，或者换句话说是`1 << 4`。这就是 64 位整数中的数字 16:

```
00000000 00000000 00000000 00010000
```

现在，最初，`paintFlags`配置不设置任何东西。这意味着，`paintFlags`中的所有位都是`0`。

但是，现在我们想要应用删除线，所以我们决定设置显示删除线的位。在这种情况下，它是第 5 个最低有效位(意思是:从右数第 5 位)。所以，我们必须左移 4 次。幸运的是，Kotlin 已经有了常量，所以我们只需使用`OR`操作符来激活设置:

```
00000000 00000000 00000000 00000000
00000000 00000000 00000000 00010000
----------------------------------- OR
00000000 00000000 00000000 00010000
```

还记得我说过的“设置”吗？为此我们使用了`OR`操作符。

但是，关于`else`条款呢？如果我们想取消贯穿配置呢？我们只需要“复位”第 5 个最低有效位。我们如何取消设置？我们使用 AND 运算符，并确保位掩码中的第 5 个最低有效位被反转，因此该位将被“设置为 0”。不要担心，其他位不会受到影响，因为这就是`AND`操作符的性质:只有当位掩码为 0 时，它才会改变。

```
00000000 00000000 00000000 00010000
11111111 11111111 11111111 11101111
----------------------------------- AND
00000000 00000000 00000000 00000000
```

现在，如果我们错误地使用了`OR`操作符，会发生什么呢？这意味着我们激活了要显示的其他属性:

```
00000000 00000000 00000000 00010000
11111111 11111111 11111111 11101111
----------------------------------- OR
11111111 11111111 11111111 11111111
```

好吧，现在我们(可能)得到了混乱的用户界面。

## 为什么使用位掩码？

现在你可能想知道，为什么配置要使用位掩码？为什么不用通常的方式设置或取消设置呢？

事实证明，在一个整数中可以存储多个配置。这有助于 Android 节省存储空间。由于 Android 是一个移动系统，对存储的贪婪不是一件明智的事情。因此，也许 Android SDK 开发人员认为，从长远来看，让它更紧凑更好(这是一个有效的论点)。

我希望现在您已经对位和位掩码有了很高的理解。位操作不仅对这类问题有用，对其他问题也有用，比如厄拉多塞的[筛子、](https://cp-algorithms.com/algebra/sieve-of-eratosthenes.html)[旅行售货员问题](https://www.youtube.com/watch?v=JE0JE8ce1V0)等等。

不过，这只是介绍。随着您对底层系统的深入研究，我敢肯定您会遇到很多位操作。