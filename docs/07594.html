<html>
<head>
<title>API : 101</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">API : 101</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/api-101-773ec501b485?source=collection_archive---------4-----------------------#2022-04-08">https://blog.devgenius.io/api-101-773ec501b485?source=collection_archive---------4-----------------------#2022-04-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="59ae" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这篇博客是我们从零开始讨论 101 个<strong class="jm io"> </strong>概念的系列文章的一部分，读者的入门知识有限。这篇文章属于<em class="ki">初级</em>系列，因为它涉及创建 API 时的一些基本设计模式。</p><p id="e262" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">云系列中的一些早期博客如下:</p><p id="a414" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae kj" rel="noopener ugc nofollow" target="_blank" href="/async-communication-101-b04d5c95333a"> <strong class="jm io">异步通信 101 </strong> <br/> </a> <a class="ae kj" rel="noopener ugc nofollow" target="_blank" href="/load-balancing-101-8251350c033f"> <strong class="jm io">负载均衡 101</strong></a><strong class="jm io"><br/></strong><a class="ae kj" rel="noopener ugc nofollow" target="_blank" href="/caching-101-634ef4f8ed1b"><strong class="jm io">缓存 101</strong></a><strong class="jm io"><br/></strong><a class="ae kj" rel="noopener ugc nofollow" target="_blank" href="/database-101-13d593ec4078"><strong class="jm io">数据库 101 </strong> </a></p><h1 id="8e38" class="kk kl in bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">什么是 API？</h1><p id="3334" class="pw-post-body-paragraph jk jl in jm b jn li jp jq jr lj jt ju jv lk jx jy jz ll kb kc kd lm kf kg kh ig bi translated">API 代表<strong class="jm io">应用编程接口，</strong>云上托管的两个物理硬件或虚拟机之间的连接。与实际的用户界面不同，API 在后台异步或同步地公开一组功能，这取决于所支持的业务领域。</p><p id="c1f3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">根据所公开的实际操作，API 可以是各种类型的- <strong class="jm io"> GET、POST、PUT、PATCH、DELETE 等。</strong>涵盖作为<em class="ki">请求主体/标题、</em>响应主体/标题的一部分发送的规范的文件称为<strong class="jm io"> API 规范。</strong></p><p id="2c21" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">作为 API 开发的一部分，应该添加两个突出的特性— <strong class="jm io">平台独立性</strong>，即任何客户端都能够调用 API，以及<strong class="jm io">服务演进</strong>，即能够向这些 API 添加新功能，而无需对客户端进行任何更改。</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi ln"><img src="../Images/4506301917c818d50133996da956795f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XqPes393o3cTBeRMSKI_qg.jpeg"/></div></div></figure><h1 id="502e" class="kk kl in bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">REST API 的类型</h1><p id="2831" class="pw-post-body-paragraph jk jl in jm b jn li jp jq jr lj jt ju jv lk jx jy jz ll kb kc kd lm kf kg kh ig bi translated">Web API 可以理想地公开为<a class="ae kj" href="https://en.wikipedia.org/wiki/Representational_state_transfer" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> REST </strong> </a>或<a class="ae kj" href="https://en.wikipedia.org/wiki/SOAP" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> SOAP </strong> </a>，REST 由于其互操作性是现代架构中更常用的模式。本节将介绍 REST 学校中公开的流行 API 方法。</p><ul class=""><li id="9035" class="lz ma in jm b jn jo jr js jv mb jz mc kd md kh me mf mg mh bi translated"><strong class="jm io"> GET </strong> —在指定的 URI 位置检索资源。通常的响应代码是<strong class="jm io"> 200 ( </strong>内容存在)、<strong class="jm io"> 204 </strong>(无内容)或<strong class="jm io"> 404 </strong>(未找到)。</li><li id="b732" class="lz ma in jm b jn mi jr mj jv mk jz ml kd mm kh me mf mg mh bi translated"><strong class="jm io">POST</strong>–在指定的 URI 位置创建资源。通常的响应代码是<strong class="jm io"> 201 </strong>(内容已创建)或<strong class="jm io"> 400 ( </strong>错误请求)。</li><li id="1361" class="lz ma in jm b jn mi jr mj jv mk jz ml kd mm kh me mf mg mh bi translated"><strong class="jm io">PUT</strong>–在指定的 URI 位置创建或替换资源。通常的响应代码是<strong class="jm io"> 201 </strong>(内容已创建)、<strong class="jm io"> 204 </strong>(无内容)或<strong class="jm io"> 409 </strong>(冲突)</li><li id="23cb" class="lz ma in jm b jn mi jr mj jv mk jz ml kd mm kh me mf mg mh bi translated"><strong class="jm io">补丁</strong>–部分更新指定 URL 上的资源。通常的响应代码是<strong class="jm io"> 201 </strong>(内容已创建)或<strong class="jm io"> 400 </strong>(错误请求)。</li><li id="b1bd" class="lz ma in jm b jn mi jr mj jv mk jz ml kd mm kh me mf mg mh bi translated"><strong class="jm io">删除</strong> —删除指定 URL 上的资源。通常的响应代码是<strong class="jm io"> 204 </strong>(无内容)或<strong class="jm io"> 404 </strong>(未找到)</li></ul><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi mn"><img src="../Images/cf6188dba8cf590c6a6ceebfcafd42e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vmiMHXPUCtBOvHCmIztDUQ.png"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated"><strong class="bd km">REST API 的示例</strong></figcaption></figure><h1 id="43a9" class="kk kl in bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">REST API 的成熟度模型</h1><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi ms"><img src="../Images/da387c3207d5b092edd5d7569be7213b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tvWUQcXiC2BSBajD-51GLQ.png"/></div></div></figure><ul class=""><li id="1aa3" class="lz ma in jm b jn jo jr js jv mb jz mc kd md kh me mf mg mh bi translated"><strong class="jm io">级别 1.0 </strong> —最不符合<strong class="jm io"> REST </strong>应用程序架构，该级别只为整个应用程序公开一个<strong class="jm io"> HTTP POST </strong>方法</li><li id="a678" class="lz ma in jm b jn mi jr mj jv mk jz ml kd mm kh me mf mg mh bi translated"><strong class="jm io">级别 2.0 — </strong>与级别 1.0 不同，该级别为不同的资源公开了多个<strong class="jm io"> HTTP POST </strong> URI。</li><li id="3872" class="lz ma in jm b jn mi jr mj jv mk jz ml kd mm kh me mf mg mh bi translated"><strong class="jm io">3.0 级— </strong>比 2.0 级更成熟，这个级别公开了不同的方法类型，如<strong class="jm io"> GET、POST、PUT、PATCH 等。</strong></li><li id="8980" class="lz ma in jm b jn mi jr mj jv mk jz ml kd mm kh me mf mg mh bi translated"><strong class="jm io"> Level 4.0 — </strong>最成熟和最稀有的层次，这个层次通过超文本暴露应用的不同状态，也称为<a class="ae kj" href="https://en.wikipedia.org/wiki/HATEOAS" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> HATEOAS </strong> </a> <strong class="jm io">。</strong></li></ul><h1 id="71a1" class="kk kl in bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">API 建议</h1><ul class=""><li id="e0c1" class="lz ma in jm b jn li jr lj jv mt jz mu kd mv kh me mf mg mh bi translated">API 端点应该基于名词而不是实际的动词。<strong class="jm io">举例</strong>-<strong class="jm io"><em class="ki">domain.com/orders/</em></strong>比<strong class="jm io"><em class="ki">domain.com/create-orders/.</em></strong></li><li id="f087" class="lz ma in jm b jn mi jr mj jv mk jz ml kd mm kh me mf mg mh bi translated">应该避免简单反映内部数据库结构的 API。如果数据库引擎的底层模式发生变化，API 应该独立于它。</li><li id="3ca9" class="lz ma in jm b jn mi jr mj jv mk jz ml kd mm kh me mf mg mh bi translated">避免使用 URI 层级超过三层的 API。ex—<strong class="jm io"><em class="ki">domain.com/x1/x2/x3</em></strong>应该回避。</li><li id="30ef" class="lz ma in jm b jn mi jr mj jv mk jz ml kd mm kh me mf mg mh bi translated">应该避免喋喋不休的应用程序，即多个 API 调用来暴露少量资源。这增加了 web 服务器的整体负载，相反，理想情况下，API 应该返回非规范化的大型资源。</li><li id="30f3" class="lz ma in jm b jn mi jr mj jv mk jz ml kd mm kh me mf mg mh bi translated">Restful APIs 应该进行版本控制，以确保向后兼容性。例-<strong class="jm io">domain.com/v1/orders 和 domain.com/v2/orders.</strong></li><li id="0765" class="lz ma in jm b jn mi jr mj jv mk jz ml kd mm kh me mf mg mh bi translated">任何 API 响应都不应该覆盖任何应用程序状态，并且在业务流中调用 API 的相对顺序应该是独立的。</li></ul><h1 id="5188" class="kk kl in bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">例子</h1><p id="6c20" class="pw-post-body-paragraph jk jl in jm b jn li jp jq jr lj jt ju jv lk jx jy jz ll kb kc kd lm kf kg kh ig bi translated">为了使用一个支持服务和模型层的示例 java rest 应用程序，可以使用下面的 repo。</p><div class="mw mx gp gr my mz"><a href="https://github.com/amit894/azure-function-incidentbot/tree/master/src/main/java/org/example/incidentbot" rel="noopener  ugc nofollow" target="_blank"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd io gy z fp ne fr fs nf fu fw im bi translated">azure-function-incident bot/src/main/Java/org/example/incident bot at master…</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">Azure 函数上的 Java 事件机器人。通过创建一个……为 Amit 894/azure-function-incident bot 开发做出贡献</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">github.com</p></div></div><div class="ni l"><div class="nj l nk nl nm ni nn lx mz"/></div></div></a></div><h1 id="76db" class="kk kl in bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">摘要</h1><p id="f586" class="pw-post-body-paragraph jk jl in jm b jn li jp jq jr lj jt ju jv lk jx jy jz ll kb kc kd lm kf kg kh ig bi translated">API 构成了大多数现代应用程序的主干。良好的设计有助于将应用程序扩展到非功能性需求，如性能、可靠性和弹性。API 设计有用的另一个领域是用于监控和调试目的的端到端请求跟踪，以支持生产系统。虽然这篇博客讨论了 API 实现的基础，但是我们将使用一个实际的例子来讨论如何将一个业务功能分解成多个 API。</p><p id="9fe0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ki">如需反馈，请留言至</em><strong class="jm io"><em class="ki">Amit[dot]894【at】Gmail[dot]com</em></strong><em class="ki">或联系</em><a class="ae kj" href="https://about.me/amit_raj" rel="noopener ugc nofollow" target="_blank"><em class="ki">【https://about.me/amit_raj】</em></a><em class="ki">的任何链接。</em></p></div></div>    
</body>
</html>