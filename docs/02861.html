<html>
<head>
<title>C# protecting Swagger endpoints</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C#保护 Swagger 端点</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/csharp-protecting-swagger-endpoints-82ae5cfc7eb1?source=collection_archive---------0-----------------------#2020-09-06">https://blog.devgenius.io/csharp-protecting-swagger-endpoints-82ae5cfc7eb1?source=collection_archive---------0-----------------------#2020-09-06</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><blockquote class="jk jl jm"><p id="b8a1" class="jn jo jp jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ig bi translated">以前的类似文章:<br/> <a class="ae km" href="https://medium.com/dev-genius/nswag-csharp-client-with-generics-support-6ad6a09f81d6?source=your_stories_page---------------------------" rel="noopener">具有泛型支持的 C#客户端使用 NSwag </a> <br/> <a class="ae km" href="https://medium.com/dev-genius/nswag-charp-client-from-multiple-api-versions-7c79a3de4622?source=your_stories_page---------------------------" rel="noopener">来自多个 API 版本的 C#客户端使用 NSwag </a></p></blockquote><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div class="gh gi kn"><img src="../Images/54e82033a5838a19da7a21f10bfe39b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2M_5XrMSPbureqKRuXNTjg.png"/></div></figure><p id="dade" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kv ka kb kc kw ke kf kg kx ki kj kk kl ig bi translated">如果我们不想向世界开放我们的 OpenAPI 模式，该怎么办？我们可以选择一些路径:</p><ul class=""><li id="1806" class="ky kz in jq b jr js jv jw kv la kw lb kx lc kl ld le lf lg bi translated">基本授权</li><li id="787d" class="ky kz in jq b jr lh jv li kv lj kw lk kx ll kl ld le lf lg bi translated">使用身份服务器的 OpenId 连接授权</li></ul><p id="f503" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kv ka kb kc kw ke kf kg kx ki kj kk kl ig bi translated">在本文中，我将展示第二条道路。</p><h2 id="a86e" class="lm ln in bd lo lp lq dn lr ls lt dp lu kv lv lw lx kw ly lz ma kx mb mc md me bi translated">默认工具</h2><p id="3576" class="pw-post-body-paragraph jn jo in jq b jr mf jt ju jv mg jx jy kv mh kb kc kw mi kf kg kx mj kj kk kl ig bi translated">首先，我尝试用 swagger UI 的集成工具配置 OAuth 2 授权:</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="ff68" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kv ka kb kc kw ke kf kg kx ki kj kk kl ig bi translated">但是它也有一些缺点。</p><ul class=""><li id="3af6" class="ky kz in jq b jr js jv jw kv la kw lb kx lc kl ld le lf lg bi translated">如果访问令牌过期，那么你什么也做不了，只能再次注销登录——非常不舒服</li><li id="1446" class="ky kz in jq b jr lh jv li kv lj kw lk kx ll kl ld le lf lg bi translated">API 方法受到保护，但大摇大摆的 UI 页面对所有人开放</li></ul><p id="1e85" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kv ka kb kc kw ke kf kg kx ki kj kk kl ig bi translated">为了解决这些缺点，应该保护 swagger 端点，并且 OAuth 2 的客户端应该正常工作。</p><h2 id="2fb2" class="lm ln in bd lo lp lq dn lr ls lt dp lu kv lv lw lx kw ly lz ma kx mb mc md me bi translated">保护 swagger 端点</h2><p id="1b49" class="pw-post-body-paragraph jn jo in jq b jr mf jt ju jv mg jx jy kv mh kb kc kw mi kf kg kx mj kj kk kl ig bi translated">集中保护您的 API 和与服务的通信的最佳方式是 Identity Server。在<a class="ae km" href="http://docs.identityserver.io/en/release/intro/test.html" rel="noopener ugc nofollow" target="_blank">identity server 4</a>和 ASP.NET 核心中的<a class="ae km" href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/routing?view=aspnetcore-3.1" rel="noopener ugc nofollow" target="_blank">路由的帮助下，我们已经:</a></p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="f97c" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kv ka kb kc kw ke kf kg kx ki kj kk kl ig bi translated">在这些更改之后，任何未授权的访问端点的尝试(<em class="jp"> /swagger/index.html </em>、<em class="jp">/swagger/v1/swagger . JSON</em>以及其他与 swagger 相关的内容)都将导致重定向到 identity server 登录页面。</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="mm ml l"/></div></figure><h2 id="8e72" class="lm ln in bd lo lp lq dn lr ls lt dp lu kv lv lw lx kw ly lz ma kx mb mc md me bi translated">添加自定义 oidc-客户端</h2><p id="679a" class="pw-post-body-paragraph jn jo in jq b jr mf jt ju jv mg jx jy kv mh kb kc kw mi kf kg kx mj kj kk kl ig bi translated">现在我们已经保护了端点，但是如何通过 swagger UI 调用 API 方法并添加新的访问令牌呢？Identity server 提供客户端库，对于 javascript 来说是<a class="ae km" href="https://github.com/IdentityModel/oidc-client-js/wiki" rel="noopener ugc nofollow" target="_blank"> oidc-client-js </a>。</p><p id="bc75" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kv ka kb kc kw ke kf kg kx ki kj kk kl ig bi translated">让我们将 oidc 客户端连接到 swagger UI 页面。这里我们准备了 swagger UI 来支持客户端:</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="6b44" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kv ka kb kc kw ke kf kg kx ki kj kk kl ig bi translated">只有三行:</p><ul class=""><li id="3b0b" class="ky kz in jq b jr js jv jw kv la kw lb kx lc kl ld le lf lg bi translated"><code class="fe mn mo mp mq b">showMutatedRequest</code>设置为<code class="fe mn mo mp mq b">false</code> ( <a class="ae km" href="https://github.com/swagger-api/swagger-ui/issues/4778" rel="noopener ugc nofollow" target="_blank">关于 swagger-ui 库的卷曲输出问题</a>)</li><li id="7ed4" class="ky kz in jq b jr lh jv li kv lj kw lk kx ll kl ld le lf lg bi translated"><code class="fe mn mo mp mq b">requestInterceptor: swagOidc.requestInterceptor</code> —自定义<a class="ae km" href="https://swagger.io/docs/open-source-tools/swagger-ui/usage/configuration/" rel="noopener ugc nofollow" target="_blank">请求拦截器</a>，这里我将为传出的请求添加授权头</li><li id="d3f1" class="ky kz in jq b jr lh jv li kv lj kw lk kx ll kl ld le lf lg bi translated"><code class="fe mn mo mp mq b">CustomJavaScriptPath = "index.js"</code> —自定义 js 文件，新的 oidc 客户端驻留在其中</li></ul><p id="3d63" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kv ka kb kc kw ke kf kg kx ki kj kk kl ig bi translated"><a class="ae km" href="https://github.com/IdentityServer/IdentityServer4/tree/main/samples/Clients" rel="noopener ugc nofollow" target="_blank">有足够的例子</a>来配置一个特定的客户端。我用了部分<a class="ae km" href="https://github.com/IdentityServer/IdentityServer4/tree/main/samples/Clients/src/JsOidc" rel="noopener ugc nofollow" target="_blank">这个</a>。<code class="fe mn mo mp mq b">CustomJavaScriptPath</code>只允许加载一个文件，不支持模块(<a class="ae km" href="https://github.com/RicoSuter/NSwag/pull/3030" rel="noopener ugc nofollow" target="_blank">拉取请求</a>)。所以我们需要 bundler，它将把 oidc-client-js 和我们的定制逻辑捆绑到一个文件中。快速的谷歌搜索让我找到了包裹。</p><p id="e13b" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kv ka kb kc kw ke kf kg kx ki kj kk kl ig bi translated">阅读包裹的文档并添加所需的包裹后，我们有:</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="mk ml l"/></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">索引. js</figcaption></figure><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/bda86819f83b37741c977077d753e228.png" data-original-src="https://miro.medium.com/v2/resize:fit:776/format:webp/1*h5-jledJuffx8wPIznx4Cw.png"/></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">包含自定义脚本和 package.json 的新文件夹</figcaption></figure><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="mk ml l"/></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">package.json</figcaption></figure><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="mk ml l"/></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">callback.html 页面</figcaption></figure><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/858852392c621016cb0c8b16a79aaeb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:784/format:webp/1*HcJRSsxuCYPYSki8AYMHfQ.png"/></div></figure><p id="df63" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kv ka kb kc kw ke kf kg kx ki kj kk kl ig bi translated"><em class="jp"> package.json </em>脚本部分的命令<code class="fe mn mo mp mq b">build</code>捆绑<em class="jp"> index.js </em>文件，输出到<em class="jp"> wwwroot </em>文件夹，将模块公开为 UMD(使用<code class="fe mn mo mp mq b">swagOidc</code>公开<em class="jp"> index.js </em>的所有导出)。</p><p id="07f1" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kv ka kb kc kw ke kf kg kx ki kj kk kl ig bi translated">进行一些测试来检查令牌刷新。在下面的屏幕截图中，API 请求在自动访问令牌刷新前后具有成功状态代码:</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi mx"><img src="../Images/c6be363de1e5c58dab23df9711621986.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5buq8y61UEkgCgSofyYMbQ.png"/></div></div></figure><p id="134a" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kv ka kb kc kw ke kf kg kx ki kj kk kl ig bi translated">最后，将 npm run 命令添加到构建管道中会很有用:</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="mk ml l"/></div></figure></div><div class="ab cl nc nd hr ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="ig ih ii ij ik"><h1 id="a60c" class="nj ln in bd lo nk nl nm lr nn no np lu nq nr ns lx nt nu nv ma nw nx ny md nz bi translated">概述</h1><p id="01ec" class="pw-post-body-paragraph jn jo in jq b jr mf jt ju jv mg jx jy kv mh kb kc kw mi kf kg kx mj kj kk kl ig bi translated">这个解决方案实际上不是特定的。您可以将相同的解决方案应用于 Swashbuckle。因此，您的 API 将受到保护，不受外界影响。</p><p id="ac61" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kv ka kb kc kw ke kf kg kx ki kj kk kl ig bi translated">最终的代码你可以在我的知识库中找到，链接在<strong class="jq io">参考文献</strong>部分。</p><h1 id="0f09" class="nj ln in bd lo nk oa nm lr nn ob np lu nq oc ns lx nt od nv ma nw oe ny md nz bi translated">参考</h1><div class="of og gp gr oh oi"><a href="https://github.com/Rynaret/SwagGenSample/tree/feature/protect-swagger-endpoints" rel="noopener  ugc nofollow" target="_blank"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd io gy z fp on fr fs oo fu fw im bi translated">Rynaret/SwagGenSample</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">功能/保护-swagger-端点</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">github.com</p></div></div><div class="or l"><div class="os l ot ou ov or ow kt oi"/></div></div></a></div><div class="of og gp gr oh oi"><a href="http://docs.identityserver.io/en/release/index.html" rel="noopener  ugc nofollow" target="_blank"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd io gy z fp on fr fs oo fu fw im bi translated">欢迎使用 IdentityServer4(最新)- IdentityServer4 1.0.0 文档</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">本文件涵盖了主要分支机构的最新版本。这可能还没有发布。使用下方的版本选择器…</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">docs.identityserver.io</p></div></div><div class="or l"><div class="ox l ot ou ov or ow kt oi"/></div></div></a></div><div class="of og gp gr oh oi"><a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/routing?view=aspnetcore-3.1" rel="noopener  ugc nofollow" target="_blank"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd io gy z fp on fr fs oo fu fw im bi translated">ASP.NET 核心中的路由</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">路由负责匹配传入的 HTTP 请求，并将这些请求分派给应用程序的可执行文件…</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">docs.microsoft.com</p></div></div><div class="or l"><div class="oy l ot ou ov or ow kt oi"/></div></div></a></div></div></div>    
</body>
</html>