<html>
<head>
<title>Typescript double “notnot” !! operator</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">打字稿双“notnot”！！操作员</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/typescript-double-notnot-operator-486d9f6d0c8f?source=collection_archive---------1-----------------------#2022-02-15">https://blog.devgenius.io/typescript-double-notnot-operator-486d9f6d0c8f?source=collection_archive---------1-----------------------#2022-02-15</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="e790" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">设计决策与代码的复杂性和灵活性。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8fb3899aabc09826d7055d755453ba36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CEbOrzw6k24eTHuTSE8Alg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">试想一下，我们如何比较前端开发和台球游戏的复杂程度。</figcaption></figure><p id="b1cc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我总是喜欢强类型的 Typescript 和使代码紧凑的操作符。</p><p id="f4b6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">众所周知，夏尔！符号仅仅意味着值的还原逻辑状态。Java，Kotlin，Typescript 广泛使用:</p><pre class="kj kk kl km gt ky kz la lb aw lc bi"><span id="a8c6" class="ld le in kz b gy lf lg l lh li">const myValue: boolean = true;<br/>if (!myValue) { console.log(myValue); }<br/>if (myValue === false) { console.log(myValue); }</span></pre><p id="736a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">居然，双感叹<strong class="jm io">！！</strong>不是操作员。只是炭而已！重复两次。一种使代码可读性更好的有用符号。因为我们也可以用同样的效果写布尔值。</p><pre class="kj kk kl km gt ky kz la lb aw lc bi"><span id="d972" class="ld le in kz b gy lf lg l lh li">!!false === false<br/>!!true === true</span></pre><p id="b105" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们使用布尔运算符:</p><pre class="kj kk kl km gt ky kz la lb aw lc bi"><span id="8e35" class="ld le in kz b gy lf lg l lh li">Boolean(false) === false // they really equals to each other<br/>Boolean(true) === true</span></pre><p id="0933" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">理论和最价差组合</strong></p><p id="12ce" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">“not not”符号的思想是将变量转换为布尔型:</p><pre class="kj kk kl km gt ky kz la lb aw lc bi"><span id="bc31" class="ld le in kz b gy lf lg l lh li">let v = 0;<br/>v ? true : false  //equals false <br/>v ? true : false  //equals true<br/>!!v<!-- --> === false<!-- -->     //false</span><span id="2501" class="ld le in kz b gy lj lg l lh li">v = 1;<br/>v ? true : false  //equals true<br/>!v ? true : false //equals false<br/>!!v<!-- --> === true<!-- -->      //true<br/>if (typeof !!v)   // boolean</span><span id="ce31" class="ld le in kz b gy lj lg l lh li">!!false === false<br/>!!true === true</span><span id="e30f" class="ld le in kz b gy lj lg l lh li">!!0 === false     // 0 is the exception value in TS<br/>!!1 === true      // TS inverts that, so you can get it as a boolean</span></pre><p id="3265" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Typescript 认为下列值为假:</p><ul class=""><li id="b592" class="lk ll in jm b jn jo jr js jv lm jz ln kd lo kh lp lq lr ls bi translated">空字符串: ""</li><li id="e6b2" class="lk ll in jm b jn lt jr lu jv lv jz lw kd lx kh lp lq lr ls bi">0</li><li id="66b6" class="lk ll in jm b jn lt jr lu jv lv jz lw kd lx kh lp lq lr ls bi translated">空</li><li id="de54" class="lk ll in jm b jn lt jr lu jv lv jz lw kd lx kh lp lq lr ls bi translated">不明确的</li><li id="f157" class="lk ll in jm b jn lt jr lu jv lv jz lw kd lx kh lp lq lr ls bi translated">圆盘烤饼</li></ul><pre class="kj kk kl km gt ky kz la lb aw lc bi"><span id="9dad" class="ld le in kz b gy lf lg l lh li">!!"" === false            // empty string is false<br/>!!undefined === false     // undefined primitive is false<br/>!!null === false          // null is false<br/>!!isNaN(value) === false</span><span id="3bfe" class="ld le in kz b gy lj lg l lh li">private getExpected(): number {<br/>  const value = parseInt(this.expectedQuote.value, 1);<br/>  return isNaN(value) ? null : value;<br/>}</span></pre><p id="3156" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Typescript 将下列值视为真理:</p><ul class=""><li id="4446" class="lk ll in jm b jn jo jr js jv lm jz ln kd lo kh lp lq lr ls bi translated">对象:{}</li><li id="3990" class="lk ll in jm b jn lt jr lu jv lv jz lw kd lx kh lp lq lr ls bi translated">数组:[]</li><li id="cea8" class="lk ll in jm b jn lt jr lu jv lv jz lw kd lx kh lp lq lr ls bi translated">非空字符串:“值”</li><li id="c349" class="lk ll in jm b jn lt jr lu jv lv jz lw kd lx kh lp lq lr ls bi translated">非零数字</li><li id="c1fa" class="lk ll in jm b jn lt jr lu jv lv jz lw kd lx kh lp lq lr ls bi translated">Date:new Date()；</li></ul><p id="0dfd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">执行代码的 JavaScript 引擎会在必要时尝试将一个值转换(或强制)为布尔值，比如在 if 语句中进行计算。</p><pre class="kj kk kl km gt ky kz la lb aw lc bi"><span id="e0e8" class="ld le in kz b gy lf lg l lh li">!!"not empty string" === true<br/>!!{} === true;                 // an (empty) object is truthy<br/>!![] === true;                 // an (empty) array is truthy</span><span id="bc44" class="ld le in kz b gy lj lg l lh li">const array = [1,2,3];<br/>!!array[0];                    // true<br/>!!array[3];                    // false</span><span id="5918" class="ld le in kz b gy lj lg l lh li">const obj = {<br/>  value: 1,<br/>  item: undefined<br/>};<br/>!!obj.value;                   // true<br/>!!obj.item;                    // false</span><span id="fc9e" class="ld le in kz b gy lj lg l lh li">const fibonacci: number = 1.6180339887;<br/>!!fibonacci === true;</span><span id="12e6" class="ld le in kz b gy lj lg l lh li">const dt = new <em class="ly">Date</em>();<br/>!!dt === true;</span></pre><p id="55a7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">一些实际方面使用的“不是不”。</strong></p><p id="b624" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这只是一个虚拟脚本来显示逻辑是如何工作的！！</p><p id="f4c1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">用！！在<strong class="jm io"> if </strong>语句内:</p><pre class="kj kk kl km gt ky kz la lb aw lc bi"><span id="84ea" class="ld le in kz b gy lf lg l lh li">userData: UserData = null;</span><span id="3a98" class="ld le in kz b gy lj lg l lh li">ngOnInit(): void {<br/>  this.userData = this.serviceCall.getData();<br/>}</span><span id="be2b" class="ld le in kz b gy lj lg l lh li">routeAhead(): void {<br/>  if (!!this.userData) {<br/>    this.router.navigateByUrl("vault");<br/>  }<br/>}</span></pre><p id="95a0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">无论使用什么函数，只有 false 或 true 将作为<strong class="jm io">布尔值</strong>返回:</p><pre class="kj kk kl km gt ky kz la lb aw lc bi"><span id="7f88" class="ld le in kz b gy lf lg l lh li">function isFound(): boolean {<br/>  return !!(charge as PricedCharge).spotCharge<br/>    || !!(charge as ChargeState).charge;<br/>}</span></pre><p id="a108" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用它<strong class="jm io">λ</strong>返回:</p><pre class="kj kk kl km gt ky kz la lb aw lc bi"><span id="0e4f" class="ld le in kz b gy lf lg l lh li">const isChargeSelected = (charge: PricedCharge): boolean =&gt; {<br/>  const found = charge?.find(item =&gt; <br/>    item.chargeUniqueId === charge?.chargeUniqueId);</span><span id="7fb9" class="ld le in kz b gy lj lg l lh li">  return !!found &amp;&amp; charge.length === 1;<br/>};</span></pre><p id="e742" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当转换为布尔型时，一些类似的对象:</p><pre class="kj kk kl km gt ky kz la lb aw lc bi"><span id="1035" class="ld le in kz b gy lf lg l lh li">private hasMapContacts(charge: PricedCharge): boolean {<br/>  return !!charge.departmentContact<br/>      || !!charge.archivedContact<br/>      || !!charge.users?.emailAddress<br/>      || !!charge.charge?.distributions;<br/>}</span></pre><p id="8728" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">结论</strong></p><p id="bbfa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">简化的符号使源代码更加紧凑，可读性更强。我已经添加了一些这种用法有用的实际例子。但是当然，你可以写 Boolean(变量)来检查。这是一个品味和你的项目设计决策的问题。</p><p id="b53a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">返回 true 或 false 值是一个不错的想法，但是社区中对这种表示法有一些批评，它增加了代码的复杂性，降低了灵活性，等等。当然，0 数字作为一个假值增加了许多开发者的讽刺。</p></div></div>    
</body>
</html>