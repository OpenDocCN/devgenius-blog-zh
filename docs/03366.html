<html>
<head>
<title>Automating to copy a set of commits from one branch to another</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">自动将一组提交从一个分支复制到另一个分支</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/automating-to-copy-a-set-of-commits-from-one-branch-to-another-11db4a98715c?source=collection_archive---------10-----------------------#2020-10-26">https://blog.devgenius.io/automating-to-copy-a-set-of-commits-from-one-branch-to-another-11db4a98715c?source=collection_archive---------10-----------------------#2020-10-26</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="5ab8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">本文将描述如何将一组连续的提交从存储库中的一个分支复制到另一个分支</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4610e1b23fff4b4623e50f6744a3e6f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Cqwz58a0G9gTMYbg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@yancymin?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">扬西·敏</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="ad44" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">最终剧本</h1><p id="eb59" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated"><a class="ae ky" href="https://gist.github.com/Muhammadwasi/05fa262f3afd92163896fbe8295b9b16" rel="noopener ugc nofollow" target="_blank">代码链接</a></p><p id="7091" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们 bash 脚本<code class="fe mc md me mf b">copy_commits</code>的最终版本应该是这样的</p><pre class="kj kk kl km gt mg mf mh mi aw mj bi"><span id="2bb7" class="mk la in mf b gy ml mm l mn mo">copy_commits.sh -p &lt;project_path&gt; -s &lt;source-branch&gt; -t &lt;target-branch&gt; -f &lt;commit-start&gt; -e &lt;commit-end&gt;</span></pre><p id="74de" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们假设我们有两个分支<strong class="jm io"> dev1 </strong>和<strong class="jm io"> dev2 </strong>，我们想要将一组连续的提交从<strong class="jm io"> dev1 </strong>移动到<strong class="jm io"> dev2 </strong></p><p id="3262" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> dev1 </strong>分支有 5 次提交，而<strong class="jm io"> dev2 </strong>分支有 1 次提交。并且，我们希望通过指定开始提交和结束提交，将<strong class="jm io"> dev1 </strong>的 4 个额外提交复制到<strong class="jm io"> dev2 </strong>分支。</p><h1 id="b4a5" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">步伐</h1><p id="9a17" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">我们将执行以下步骤来自动化该任务。</p><ol class=""><li id="dd17" class="mp mq in jm b jn jo jr js jv mr jz ms kd mt kh mu mv mw mx bi translated">首先，我们将解析脚本执行时传递的参数。这些值将存储在以下五个变量中:</li></ol><ul class=""><li id="7626" class="mp mq in jm b jn jo jr js jv mr jz ms kd mt kh my mv mw mx bi translated"><code class="fe mc md me mf b">$PROJECT_PATH</code></li><li id="1079" class="mp mq in jm b jn mz jr na jv nb jz nc kd nd kh my mv mw mx bi translated"><code class="fe mc md me mf b">$SOURCE_BRANCH</code></li><li id="15ae" class="mp mq in jm b jn mz jr na jv nb jz nc kd nd kh my mv mw mx bi translated"><code class="fe mc md me mf b">$TARGET_BRANCH</code></li><li id="4e48" class="mp mq in jm b jn mz jr na jv nb jz nc kd nd kh my mv mw mx bi translated"><code class="fe mc md me mf b">$FROM_COMMIT</code></li><li id="a7cb" class="mp mq in jm b jn mz jr na jv nb jz nc kd nd kh my mv mw mx bi translated"><code class="fe mc md me mf b">$TO_COMMIT</code></li></ul><ol class=""><li id="004e" class="mp mq in jm b jn jo jr js jv mr jz ms kd mt kh mu mv mw mx bi translated">我们将首先检查到<strong class="jm io"> dev1 </strong>分支(源分支),并获取一个数组中开始和结束提交之间的所有提交。</li><li id="de5b" class="mp mq in jm b jn mz jr na jv nb jz nc kd nd kh mu mv mw mx bi translated">然后我们将检查到<strong class="jm io"> dev2 </strong>分支，我们将从数组中取出每个提交，并在<strong class="jm io"> dev2 </strong>(目标分支)上挑选提交</li></ol><h2 id="810b" class="mk la in bd lb ne nf dn lf ng nh dp lj jv ni nj ln jz nk nl lr kd nm nn lv no bi translated">步骤 1:解析参数并将参数存储到变量中</h2><pre class="kj kk kl km gt mg mf mh mi aw mj bi"><span id="7a14" class="mk la in mf b gy ml mm l mn mo">while getopts ":p:s:t:f:e:" o; do<br/>    case "${o}" in<br/>    p)<br/>            PROJECT_PATH="${OPTARG}"<br/>            ;;<br/>        s)<br/>            SOURCE_BRANCH="${OPTARG}"<br/>            ;;<br/>        t)<br/>            TARGET_BRANCH="${OPTARG}"<br/>            ;;<br/>        f)<br/>            FROM_COMMIT="${OPTARG}"<br/>            ;;<br/>        e)<br/>            TO_COMMIT="${OPTARG}"<br/>            ;;<br/>        *)<br/>            abnormal_exit<br/>            ;;<br/>    esac<br/>done</span></pre><p id="054f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">以下是<code class="fe mc md me mf b">abnormal_exit()</code>功能的代码</p><pre class="kj kk kl km gt mg mf mh mi aw mj bi"><span id="e074" class="mk la in mf b gy ml mm l mn mo"># Prints usage<br/>usage() {                                      <br/>  echo "Usage: $0 -p &lt;project_path&gt; -s &lt;source-branch&gt; -t &lt;target-branch&gt; -f &lt;commit-start&gt; -e &lt;commit-target&gt;  " 1&gt;&amp;2 <br/>}</span><span id="7b1a" class="mk la in mf b gy np mm l mn mo"># Prints usage and exit<br/>abnormal_exit() {                              <br/>  usage<br/>  exit 1<br/>}</span></pre><h2 id="5368" class="mk la in bd lb ne nf dn lf ng nh dp lj jv ni nj ln jz nk nl lr kd nm nn lv no bi translated">步骤 2:从源分支获取提交散列，并将其存储到一个数组中</h2><pre class="kj kk kl km gt mg mf mh mi aw mj bi"><span id="cff5" class="mk la in mf b gy ml mm l mn mo">commits=($(git rev-list "$FROM_COMMIT^..$TO_COMMIT"))</span></pre><ul class=""><li id="a7a3" class="mp mq in jm b jn jo jr js jv mr jz ms kd mt kh my mv mw mx bi translated"><code class="fe mc md me mf b">git rev-list</code>用于按时间倒序列出 git 提交。因此，最新的提交将在数组的开始处。</li><li id="fd31" class="mp mq in jm b jn mz jr na jv nb jz nc kd nd kh my mv mw mx bi translated"><code class="fe mc md me mf b">&lt;start_commit_hash&gt;..&lt;end_commit_hash&gt;</code>是表示从<strong class="jm io"> start_commit_hash </strong>(不包含)到<strong class="jm io"> end_commit_hash </strong>(包含)开始的符号。如果我们想在结果中得到<strong class="jm io"> start_commit_hash </strong>，那么我们必须指定开始提交的父级。可以在提交散列的末尾使用插入符号<code class="fe mc md me mf b">^</code>来指定开始提交的父提交。这就是为什么在开始提交的末尾使用了一个脱字符号。</li><li id="7a62" class="mp mq in jm b jn mz jr na jv nb jz nc kd nd kh my mv mw mx bi translated"><code class="fe mc md me mf b">$FROM_COMMIT^</code>:表示从<code class="fe mc md me mf b">$FROM_COMMIT</code>之父开始。脱字符号(^)用于指定提交的父级，否则<code class="fe mc md me mf b">$FROM_COMMIT</code>将不会包含在最终结果中。</li><li id="c03e" class="mp mq in jm b jn mz jr na jv nb jz nc kd nd kh my mv mw mx bi translated"><code class="fe mc md me mf b">$(some_command_here)</code>:当我们想要运行某个命令，但是想要将命令的输出存储到一个变量中时，使用这个符号。因此，我们可以将它的输出赋给左边的一个变量。</li><li id="df11" class="mp mq in jm b jn mz jr na jv nb jz nc kd nd kh my mv mw mx bi translated"><code class="fe mc md me mf b">($(some_command_here))</code>:如果我们将一些文本封装到括号中，那么 bash 会根据 IFS(内部字段分隔符)将它们转换成一个数组。默认情况下，它是空白。因此<code class="fe mc md me mf b">$(some_command_here)</code>的输出将被转换成一个数组。</li></ul><h2 id="171c" class="mk la in bd lb ne nf dn lf ng nh dp lj jv ni nj ln jz nk nl lr kd nm nn lv no bi translated">步骤 3:通过从提交数组中挑选提交，在目标分支上应用提交</h2><p id="9890" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">我们已经将所有的提交放入了<code class="fe mc md me mf b">commits</code>数组。现在，我们必须检查目标分支。</p><pre class="kj kk kl km gt mg mf mh mi aw mj bi"><span id="67af" class="mk la in mf b gy ml mm l mn mo">git checkout $TARGET_BRANCH</span><span id="d578" class="mk la in mf b gy np mm l mn mo">if ! [[ $? -eq 0 ]]<br/>then<br/>    echo $'\u274c' "ERROR: Failed to checkout to $TARGET_BRANCH"<br/>    exit 2<br/>fi</span></pre><p id="5a2f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们必须逐个选择每个提交并运行<code class="fe mc md me mf b">cherry-pick</code>命令。但是，请记住，我们必须以相反的顺序选择提交，因为最近的提交是在数组的开始。这就是为什么我们将开始从提交数组的<code class="fe mc md me mf b">length-1</code>索引中挑选提交。</p><pre class="kj kk kl km gt mg mf mh mi aw mj bi"><span id="e4ba" class="mk la in mf b gy ml mm l mn mo"># For each commit<br/>for ((i=$((${#commits[@]}-1));i&gt;=0;i--))<br/>do<br/>    echo "Cherry Picking ${commits[i]} ..."<br/>    git cherry-pick "${commits[i]}"<br/>    # If the above command fails, then exit with proper message<br/>    if ! [[ $? -eq 0 ]]<br/>    then<br/>        echo "ERROR: Cherry pick commit with ${commits[i]} failed, exiting..."<br/>        exit 2<br/>    fi<br/>    # Show success message for the copied commit<br/>    echo "DONE: Commit ${commits[i]} copied"<br/>done</span></pre><ul class=""><li id="cd68" class="mp mq in jm b jn jo jr js jv mr jz ms kd mt kh my mv mw mx bi translated"><code class="fe mc md me mf b">#</code>用于查找数组的长度。</li><li id="9a90" class="mp mq in jm b jn mz jr na jv nb jz nc kd nd kh my mv mw mx bi translated">循环从长度-1 开始，我们将递减<code class="fe mc md me mf b">i</code>直到它小于 0。</li><li id="f700" class="mp mq in jm b jn mz jr na jv nb jz nc kd nd kh my mv mw mx bi translated"><code class="fe mc md me mf b">$?</code>用于获取最近执行的命令的退出状态代码。</li></ul><h2 id="464f" class="mk la in bd lb ne nf dn lf ng nh dp lj jv ni nj ln jz nk nl lr kd nm nn lv no bi translated">最终脚本截图</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/dc0ce4452f75f8343cee07097ebe6a50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1378/format:webp/1*LniWy3M5iXMjBVUiKMYYHQ.jpeg"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">Git 项目提交日志</figcaption></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/bc321922290134816e067f1db547615a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6LxT64HczwoiZlhI0DJQpA.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">脚本执行时的屏幕截图</figcaption></figure></div></div>    
</body>
</html>