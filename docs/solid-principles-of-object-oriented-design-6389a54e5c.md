# 面向对象设计的坚实原则

> 原文：<https://blog.devgenius.io/solid-principles-of-object-oriented-design-6389a54e5c?source=collection_archive---------19----------------------->

面向对象设计原理简介

![](img/27b256e975f6337e636b7de97c3f203f.png)

米尔科·布利克在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄的照片

> **拥有一把锤子并不能让一个人成为建筑师**

****因此，如果有人认为他了解面向对象编程(OO 语言),就意味着他只了解类、对象和一些非常基本的 OOP 概念。了解固体原理对你有什么帮助？任何猜测…****

****嗯，它让你擅长面向对象的设计。****

****因此，一切都与设计有关。而不是 OOP、变量、循环和其他框架。它是关于开发一个好的(面向对象设计)软件。****

****好的软件是一段坚实的代码，这意味着它易于更改、维护、阅读、扩展、测试、优化等等。如果你是一名软件工程师，我敢肯定你一定听说过坚实的原则。如名称原则意味着，即信念系统的基础。同样，坚实的原则为更好的软件设计提供了基础。****

****在开始这些坚实的原则是什么之前，让我们谈谈为什么它们是开发人员的一套重要工具。****

# ****为什么是固体？****

****基于实体的解决方案非常容易维护。固体实际上是一种改变的设计。改变在软件开发中是如此普遍，而可靠的设计使之变得容易，因为这些原则通过去除设计气味和分离代码中的依赖(通过依赖注入)来帮助我们编写高度内聚和松散耦合的代码。它专注于分离事物，而不是触及已经工作的东西，主要的和最重要的原因是设计不仅好而且更好的软件，能够容易地处理需求中的变化或增强系统的功能，而不会面临重大问题。根据罗伯特·C·马丁(鲍勃大叔)的说法，****

> ****软件的设计就是源代码本身。****

****另一方面，当软件管理做得不好时，代码会变得不灵活和更脆弱，软件中的小变化会导致错误，为了避免这种情况，我们遵循可靠的原则。****

# ****什么是固体？****

****SOLID 是一个描述优秀代码设计原则集合的术语，由 Robert C. Martin 在 2000 年发明，他也被称为 Bob 叔叔。

简而言之:

一套 5 条原则，当遵循这些原则时，程序会变得更容易维护、可测试、无 bug，并且开发速度更快。****

****[🖐](https://emojipedia.org/hand-with-fingers-splayed/) 立体设计原则是五个原则的组合
1- **S** 单一责任原则
2- **O** 笔闭合原则
3- **L** 伊斯科夫替代原则
4- **I** 界面分离原则
5- **D** 依赖倒置原则

以上五个原则统称为立体原则。现在让我们来理解每一个原理。****

# ******1-单一责任原则:******

*****一个班级应该有一个单一的责任。*****

****SRP 声明一个类应该有一个单一的任务或单一的目的，这意味着只有一个改变的理由。****

****这个概念与**耦合和内聚**密切相关。耦合是模块之间关系的指示。内聚性是一个模块内部关系的指示。****

****例如，考虑一个编译和打印报告的模块。设想这样一个模块可以因为两个原因而被改变。首先，报告的内容可能会改变。第二，报告的格式可以改变。这两件事因为不同的原因而改变。一个实质性的，一个化妆品。单一责任原则认为问题的这两个方面实际上是两个独立的责任，因此应该在不同的类或模块中。将两个在不同时间因不同原因而变化的事物联系在一起是一个糟糕的设计。****

****让一个班级专注于一个单独的问题是很重要的，因为这样可以使班级更加强大。继续前面的例子，
如果报告编译过程有变化，如果它是同一类的一部分，则打印代码中断的危险更大。
另一方面，如果类被分解成高内聚的类(分为编译和打印两个部分)，那么对其中任何一个类的更改对整个系统的影响都较小。****

****所以，一个好的软件设计应该是高内聚低耦合的。所以不喜欢长方法，避免上帝对象(因为它引入了高耦合和内聚)，因为它们是更大问题的症状——缺乏单一责任，破坏性的解耦，记住如果你的方法中有区域，你就没有遵守单一责任原则！所以要仔细决定哪些代码应该放在一起，哪些应该分开。如果你理解并掌握了单一责任原则，那很好，因为其他一切都由此而来。****

# ******2-开闭原理:******

****OCP 声明***软件实体(类、模块、方法等。)应该对扩展开放，但对修改关闭* **"** 这意味着你应该能够扩展一个类行为，而不用修改它。******

******在实践中，这意味着创建软件实体，其行为可以改变，而不需要编辑和重新编译代码本身。证明这一原则的最简单的方法是考虑做一件事的方法。
假设它写入一个特定的文件，该文件的名称被硬编码到方法中。如果需求改变了，在某些情况下文件名需要不同，我们必须打开方法来改变文件名。另一方面，如果文件名已经作为参数传入，我们将能够修改这个方法的行为而不改变它的源代码，保持它不被修改。因此，使用这一原则将现有代码与修改后的代码分离开来，这样可以提供更好的稳定性、可维护性，并最大限度地减少代码中的更改。******

******开闭原则也可以通过许多其他方式来实现，
包括通过使用继承或者通过组合的
设计模式，比如策略模式。

**策略模式**是开/闭原理的支柱(来自鲍伯·马丁的固性原理)。******

# ********3-利斯科夫替代原理:********

******“是-可替代的”不仅仅是“是-A”******

******LSP 声明“*派生类或子类必须可以替换它们的基类或父类*”。这确保了作为父类的子类的任何类都可以代替其父类使用，而不会出现任何意外的行为。******

******让我们做一个简单的例子:******

******正如你在上面的代码中注意到的，鸵鸟是一只鸟，但它不会飞，鸵鸟类是 bird 类的一个子类型，但它不能使用 fly 方法，这意味着我们违反了 LSP 原则。******

******问题是 Bird 的 Fly()方法太粗糙了，我们需要一些改进，因为不是所有的鸟都能飞。******

# ********4-界面分离原理:********

*******“不要依赖你不用的东西”*******

******ISP 声明“*客户不应被迫依赖他们不使用的方法”。*******

******接口应该属于客户端，而不是库或层次结构。应用程序开发人员应该喜欢瘦的、集中的接口，而不是一个“胖”的接口，它提供的功能比特定的类或方法需要的更多。基于方法组，许多小接口是首选的，每个方法服务于一个子模块。在许多语言中，比如 Java，接口可以从多个其他接口继承。因此，如果您在应用程序的某些部分需要一个更大的界面，而在其他部分不需要，您可以从两个或更多的其他界面组合它。如果您发现自己正在重构一个遗留代码库，这也是一个要记住的好方法，它已经有了您不能破坏的大接口。考虑这样一个界面:******

******很容易想象这样一个接口会完全失控，拥有比任何类都需要的更多的功能。比方说，为了防止
一个登录表单上的方法多于它所需要的，您可以创建一个特定于登录的接口，并让现有的接口从中扩展:******

******理想情况下，您的瘦接口应该是内聚的，这意味着它们有逻辑上属于一起的操作组。这将防止您在现实世界的系统中大多数时候都以每个方法一个接口而告终(与上面的小例子相反)。******

# ******5-依赖性倒置原则:******

*******“依靠抽象，而不是具体”*******

******这个原则声明高级模块不应该依赖于低级模块；两者都应该依赖于抽象。抽象不应该依赖于细节。细节应该依赖于抽象。******

******当编写软件来实现它时，每个模块或方法都明确地引用它的合作者，这种情况非常普遍。这种类型的编程通常缺乏足够的抽象层，并导致非常紧密耦合的系统，因为每个模块都直接引用较低级别的模块。******

******考虑一个带有按钮的用户界面表单。当单击按钮时，会触发一个事件。在事件中，创建了业务逻辑层(BLL)类的新实例，并调用了其方法之一。在 BLL 类的方法中，创建了一个数据访问层(DAL)类的新实例，并调用了它的一个方法。这个方法反过来进行数据库查询。******

******这种方法的结果是系统中的一切都与数据库紧密耦合。依赖树是 UI -> BLL -> DAL -> DB，
并且这些依赖是可传递的。这些类和方法都紧密耦合在一起，因为直接实例化正在发生(记住:New 是 Glue)，尽管如果使用静态方法调用，您也会看到这种行为。纠正这个设计问题的方法是应用依赖倒置原则，这通常从引入新接口开始。******

******考虑一个带有按钮的用户界面表单。当单击按钮时，会触发一个事件。作为对事件的响应，窗体的私有成员(其类型只是一个接口)具有一个名为的方法。在 click 事件处理程序中找不到“new”关键字。创建表单时，通过一个称为**依赖注入**的过程，提供接口的实现。同样，如果这个方法提供关键的业务逻辑，但是也需要访问系统的持久层，那么它也可以指定(在其构造函数中显式地)一个或多个它所依赖的接口，这可能包括**存储库模式**的实现。业务逻辑类的方法中也不会存在静态方法调用或“new”关键字。******

******一般来说，为了产生想要的结果，软件应该尽可能的简单。然而，一旦更新软件变得痛苦，就应该调整软件的设计来消除这种痛苦。通常，这些原则，除了更一般的**不要重复**原则，可以在重构软件成为更好的设计时用作指南。******

# ********结论:********

******学会在哪里应用这个设计原则是非常重要的。将它应用到正确的地方会使我们的生活更容易，我们的代码会更加灵活，以更少的努力来适应新的变化。如果你学到了至少一件事&如果你觉得内容值得分享。😊提供反馈、评论或开始讨论。不吝指正。******

******干杯！！******