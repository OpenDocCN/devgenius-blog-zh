<html>
<head>
<title>Design patterns in Ruby — chain of responsibility</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Ruby 中的设计模式——责任链</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/design-patterns-in-ruby-chain-of-responsibility-6b984220ac37?source=collection_archive---------15-----------------------#2020-07-08">https://blog.devgenius.io/design-patterns-in-ruby-chain-of-responsibility-6b984220ac37?source=collection_archive---------15-----------------------#2020-07-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/a9515114cf97fd05422d9a3dfc6e9ff2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*llD0d2qBWSaJPdzS"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">Joshua Fuller 在<a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="cd79" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你有一个大的<code class="fe ky kz la lb b">if/else</code>语句来决定如何在你的一个类中处理一些逻辑。</p><pre class="lc ld le lf gt lg lb lh li aw lj bi"><span id="6eb2" class="lk ll in lb b gy lm ln l lo lp">if order.currency == 'gdp' &amp;&amp; order.amount &lt; 500<br/>  PayPalPayment.process(order)<br/>elsif order.currency == 'gdp' &amp;&amp; order.amount &gt; 500<br/>  StripePayment.process(order)<br/>elsif order.currency == 'usd'<br/>  SquarePayment.process(order)<br/>elsif order.currency == 'eur'<br/>  PayPalPayment.process(order) <br/>elsif order.currency == 'zar'<br/>  WesternUnionPayment.process(order)<br/>elsif # more examples <br/>... <br/>end</span></pre><h2 id="e542" class="lk ll in bd lq lr ls dn lt lu lv dp lw kl lx ly lz kp ma mb mc kt md me mf mg bi translated">为什么这是个问题？</h2><p id="a582" class="pw-post-body-paragraph ka kb in kc b kd mh kf kg kh mi kj kk kl mj kn ko kp mk kr ks kt ml kv kw kx ig bi translated">发送方对象(包含上面代码的类)完全耦合到接收方类(例如<code class="fe ky kz la lb b">StripePayment</code>、<code class="fe ky kz la lb b">PayPalPayment</code>等)，它知道所有可能的处理程序和决定使用哪个处理程序的逻辑。如果处理程序发生了变化(例如，删除、添加或更新了一个处理程序)，或者如果确定使用哪个处理程序的逻辑发生了变化(例如，Stripe 引入了一个限制)，那么在对这个已经臃肿的类进行更改时，您就有破坏应用程序的风险，更不用说让别人理解您的程序在做什么变得越来越困难了。</p><h2 id="0ec4" class="lk ll in bd lq lr ls dn lt lu lv dp lw kl lx ly lz kp ma mb mc kt md me mf mg bi translated">这种设计模式解决了什么问题？</h2><ol class=""><li id="5f9e" class="mm mn in kc b kd mh kh mi kl mo kp mp kt mq kx mr ms mt mu bi translated">有多个对象可以处理这个请求(例如，<code class="fe ky kz la lb b">StripePayment</code>，<code class="fe ky kz la lb b">PayPalPayment</code>)，但是直到运行时(也就是当你知道使用哪种货币进行购买时)，你才知道使用哪一个。</li><li id="1389" class="mm mn in kc b kd mv kh mw kl mx kp my kt mz kx mr ms mt mu bi translated">您希望将发出请求的对象(发送者)和处理请求的对象(接收者)分离，这样发送者只需要知道请求将被处理，接收者和发送者彼此没有明确的了解。</li></ol><h2 id="50f3" class="lk ll in bd lq lr ls dn lt lu lv dp lw kl lx ly lz kp ma mb mc kt md me mf mg bi translated">这种设计模式的一般概念是什么？</h2><p id="fa66" class="pw-post-body-paragraph ka kb in kc b kd mh kf kg kh mi kj kk kl mj kn ko kp mk kr ks kt ml kv kw kx ig bi translated">责任链模式是一种<em class="na">行为设计模式</em>。行为设计模式与算法和对象之间的责任分配有关，包括它们之间的通信模式。设计模式的其他类别是创造型*和结构型**。</p><p id="198e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这种模式通过给多个对象一个处理请求的机会，避免了将请求的发送者耦合到接收者。链接接收对象，并沿着链传递请求，直到有对象处理它。</p></div><div class="ab cl nb nc hr nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ig ih ii ij ik"><h2 id="458a" class="lk ll in bd lq lr ls dn lt lu lv dp lw kl lx ly lz kp ma mb mc kt md me mf mg bi translated">我们如何实现这种模式？</h2><p id="1872" class="pw-post-body-paragraph ka kb in kc b kd mh kf kg kh mi kj kk kl mj kn ko kp mk kr ks kt ml kv kw kx ig bi translated">我们可以创建一个处理程序链，而不是一个大的<code class="fe ky kz la lb b">if/else</code>语句。请求将按顺序通过每个处理程序(如果链中的每个链接无法解析请求，则将其传递给下一个链接)，直到找到可以解析请求的处理程序。</p><figure class="lc ld le lf gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ni"><img src="../Images/ca56a243f721b487d39891002784f2f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CR4wb3j5GoBWB2hrPl4aGg.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">逻辑图的处理程序链流程</figcaption></figure><p id="75e1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">好吧，让我们进入代码。我们将创建一个基本处理程序，所有的处理程序都将继承它</p><pre class="lc ld le lf gt lg lb lh li aw lj bi"><span id="1217" class="lk ll in lb b gy lm ln l lo lp">class BaseHandler   <br/>  attr_reader :successor    </span><span id="e821" class="lk ll in lb b gy nj ln l lo lp">  def initialize(successor = nil)<br/>    @successor = successor    <br/>  end    </span><span id="71c7" class="lk ll in lb b gy nj ln l lo lp">  def call(transaction)<br/>    if can_handle?(transaction)<br/>      handle(transaction)<br/>    else<br/>      successor.call(transaction)<br/>    end<br/>  end    </span><span id="1a94" class="lk ll in lb b gy nj ln l lo lp">  def handle(_transaction)<br/>    raise NotImplementedError, 'Each handler should respond to handle and can_handle? methods'   <br/>  end <br/>end</span></pre><p id="b712" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在我们需要创建链。我们可以从第一个处理程序开始，我们希望它是最具体的处理程序。</p><pre class="lc ld le lf gt lg lb lh li aw lj bi"><span id="129c" class="lk ll in lb b gy lm ln l lo lp">class PayPalHandler &lt; BaseHandler</span><span id="c37d" class="lk ll in lb b gy nj ln l lo lp">  private # all the public methods are in the BaseHandler</span><span id="5db9" class="lk ll in lb b gy nj ln l lo lp">  def handle(transaction)     <br/>    puts "handling the transaction with PayPal payment provider"<br/>  end     </span><span id="7be3" class="lk ll in lb b gy nj ln l lo lp">  def can_handle?(transaction)<br/>    transaction.amount &lt; 500 &amp;&amp; transaction.currency == 'GDP' || transaction.currency == 'EUR'  <br/>  end<br/>end</span></pre><p id="6c02" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们将添加另一个处理程序，作为链中的第二个环节</p><pre class="lc ld le lf gt lg lb lh li aw lj bi"><span id="841f" class="lk ll in lb b gy lm ln l lo lp">class StripeHandler &lt; BaseHandler</span><span id="d74b" class="lk ll in lb b gy nj ln l lo lp">  private</span><span id="4c71" class="lk ll in lb b gy nj ln l lo lp">  def handle(transaction)     <br/>    puts "handling the transaction with Stripe payment provider"<br/>  end</span><span id="5744" class="lk ll in lb b gy nj ln l lo lp">  def can_handle?(transaction)<br/>    transaction.amount &gt; 500 &amp;&amp; transaction.currency == 'GDP'<br/>  end<br/>end</span></pre><p id="0c59" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在我们可以创建链。</p><pre class="lc ld le lf gt lg lb lh li aw lj bi"><span id="eda8" class="lk ll in lb b gy lm ln l lo lp">transaction = Transaction.new(currency: 'GDP', amount: 600)</span><span id="1bbd" class="lk ll in lb b gy nj ln l lo lp">chain = PayPalHandler.new(StripeHandler.new)</span><span id="9623" class="lk ll in lb b gy nj ln l lo lp">chain.call</span></pre><p id="5291" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当我们运行<code class="fe ky kz la lb b">chain.call</code>时，它将转到第一个处理器(<code class="fe ky kz la lb b">PayPalHandler</code>)，如果它是<code class="fe ky kz la lb b">can_handle?</code>，那么它将是<code class="fe ky kz la lb b">handl</code>，链将停止。如果它不能处理，它将把事务传递给第二个处理程序<code class="fe ky kz la lb b">StripeHandler</code>并调用它的<code class="fe ky kz la lb b">call</code>方法，以此类推。</p><p id="a690" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">添加更多的处理程序很容易，例如:</p><pre class="lc ld le lf gt lg lb lh li aw lj bi"><span id="dbaa" class="lk ll in lb b gy lm ln l lo lp">chain = PayPalHandler.new(StripeHandler.new(SquareHandler.new(WesternUnionHandler.new)))</span><span id="aea4" class="lk ll in lb b gy nj ln l lo lp">chain.call</span></pre><p id="ca3e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们可以轻松地删除处理程序或改变处理程序的顺序。</p><pre class="lc ld le lf gt lg lb lh li aw lj bi"><span id="58c6" class="lk ll in lb b gy lm ln l lo lp">chain = StripeHandler.new(SquareHandler.new(PayPalHandler.new))</span></pre><blockquote class="nk nl nm"><p id="9f23" class="ka kb na kc b kd ke kf kg kh ki kj kk nn km kn ko no kq kr ks np ku kv kw kx ig bi translated"><strong class="kc io"> *创新设计</strong> <strong class="kc io">模式</strong>抽象实例化过程。它们有助于使一个系统独立于它的对象是如何被创建、组合和表现的(第 3 章，Go4)。例子包括单例、工厂方法、构建器、抽象工厂和原型。</p><p id="1650" class="ka kb na kc b kd ke kf kg kh ki kj kk nn km kn ko no kq kr ks np ku kv kw kx ig bi translated"><strong class="kc io"> **结构设计模式</strong>关注的是类和对象如何组成更大的结构。他们使用继承来组成接口或实现。一个简单的例子是多重继承如何将两个或多个类混合成一个类，从而产生一个结合了其父类属性的类。例子包括适配器、桥、组合、Facade、Flyweight 和代理模式(第 4 章，Go4)。</p></blockquote></div></div>    
</body>
</html>