<html>
<head>
<title>How I set up JWT with Rails API and React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我如何用 Rails API 设置 JWT 和 React</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-i-set-up-jwt-with-rails-api-and-react-3caec9b00482?source=collection_archive---------0-----------------------#2021-12-21">https://blog.devgenius.io/how-i-set-up-jwt-with-rails-api-and-react-3caec9b00482?source=collection_archive---------0-----------------------#2021-12-21</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="9ff4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在熨斗学校的最后一个项目中，我决定创建一个 web 应用程序，它可以让用户使用 JWT 安全地登录。在我从 Bootcamp 毕业之前，我想测试我在客户端配置用户身份验证的技能，因为好的应用程序是安全的应用程序。</p><p id="995c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在很大程度上，我从几篇不同的文章中获得了很多帮助(所有这些文章都在最后链接了下来)，但是当然，我必须自己弄清楚逻辑，这本身就是一个令人沮丧的时刻。😵‍💫</p><h1 id="8256" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">后端设置</h1><p id="3729" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">我首先使用 API 标志创建了我的 Rails API 项目，并通过在我的终端中键入以下内容来指定我的数据库系统:</p><p id="a2db" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ll lm ln lo b">rails new project-name-here --api --database=postgresql</code></p><p id="0603" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">通过指定我希望 postgreSQL 用于我的数据库，这使得以后部署到 Heroku 上更容易，并且如果您的开发和生产使用相同的数据库系统，实际上对您的应用程序更好。</p><p id="e9c6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">接下来的步骤自然是将新创建的应用程序推送到我的 GitHub，并向<code class="fe ll lm ln lo b">gemfile</code>添加必要的宝石。</p><h2 id="e648" class="lp kj in bd kk lq lr dn ko ls lt dp ks jv lu lv kw jz lw lx la kd ly lz le ma bi translated">宝石💎</h2><p id="242f" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">我用来设置 JWT 的相关宝石有<code class="fe ll lm ln lo b">pg</code>、<code class="fe ll lm ln lo b">bcrpyt</code>、<code class="fe ll lm ln lo b">jwt</code>和<code class="fe ll lm ln lo b">active_model_serializers</code>。</p><p id="8d8e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在终端中运行了<code class="fe ll lm ln lo b">bundle</code>之后，我已经准备好开始实际操作了。</p><h2 id="baf0" class="lp kj in bd kk lq lr dn ko ls lt dp ks jv lu lv kw jz lw lx la kd ly lz le ma bi translated">模型💁🏻‍♀️</h2><p id="0d9d" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">对于这个特定的项目，我创建了三个模型:用户、旅行和地点。它们是如何联系在一起的:</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/178d7f70315af4cf0214513f5cd1652b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1312/format:webp/1*REKptF00f_OhOYlv829-Sw.jpeg"/></div></figure><p id="e39d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了生成这些模型，我在终端中输入(以用户模型为例):</p><pre class="mc md me mf gt mj lo mk ml aw mm bi"><span id="d61c" class="lp kj in lo b gy mn mo l mp mq">rails g resource User first_name last_name email password_digest --no-test-framework --skip-template-engine</span></pre><p id="e2f8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">添加<code class="fe ll lm ln lo b">--skip-template-engine</code>纯粹是为了确保没有视图文件夹/文件被创建，包含<code class="fe ll lm ln lo b">password_digest</code>是因为我们正在使用<code class="fe ll lm ln lo b">bcrypt</code>。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi mr"><img src="../Images/9f36bd0d3ed702025d082e9c7a97a97d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DwlJki85ZaCp3ZqRo9nCaw.png"/></div></div><figcaption class="mw mx gj gh gi my mz bd b be z dk translated">用户模型</figcaption></figure><p id="0b6b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">正如你从上面看到的，我们不需要验证密码，因为来自<code class="fe ll lm ln lo b">bcrypt</code>的<code class="fe ll lm ln lo b">has_secure_password</code>会帮我们处理好。</p><h2 id="37b8" class="lp kj in bd kk lq lr dn ko ls lt dp ks jv lu lv kw jz lw lx la kd ly lz le ma bi translated">🕹主计长</h2><p id="9ab7" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">我们需要注意的三个控制器是:</p><ol class=""><li id="24f0" class="na nb in jm b jn jo jr js jv nc jz nd kd ne kh nf ng nh ni bi translated"><code class="fe ll lm ln lo b">application_controller</code></li><li id="7e11" class="na nb in jm b jn nj jr nk jv nl jz nm kd nn kh nf ng nh ni bi translated"><code class="fe ll lm ln lo b">users_controller</code></li><li id="e2ad" class="na nb in jm b jn nj jr nk jv nl jz nm kd nn kh nf ng nh ni bi translated"><code class="fe ll lm ln lo b">sessions_controller</code></li></ol><p id="62f4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们先来处理一下<code class="fe ll lm ln lo b"><strong class="jm io">application_controller</strong></code>，因为这一个有点疯狂。</p><figure class="mc md me mf gt mg"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="dc00" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我知道这有很多要解释的。我们先从第一种方法开始:<code class="fe ll lm ln lo b">jwt_key</code>。</p><p id="d6c4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了利用<code class="fe ll lm ln lo b">Rails.application.credentials.jwt_key</code>，我们需要首先创建并隐藏我们的密钥。</p><ol class=""><li id="bdb1" class="na nb in jm b jn jo jr js jv nc jz nd kd ne kh nf ng nh ni bi translated"><strong class="jm io">创建 256 位密钥，使用</strong> <code class="fe ll lm ln lo b"><strong class="jm io">openssl</strong></code></li></ol><p id="c47a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在你的终端输入:<code class="fe ll lm ln lo b">openssl rand -base64 32</code>。</p><p id="002a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这将输出一个随机的 32 字节/256 位字母和字符的混乱。抓住这个键，因为现在我们必须把它藏在应用程序文件中的某个地方。</p><p id="370c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">2.藏钥匙</p><p id="bcb8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在你的终端输入:<code class="fe ll lm ln lo b">EDITOR="code --wait" rails credentials:edit</code></p><p id="0bf1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这将在您的 VS 代码中打开一个文件，您可以在其中存储密钥。</p><p id="dd8c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">3.将密钥添加到文件中</p><p id="d7a6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">添加以下散列:<code class="fe ll lm ln lo b">jwt_key: 256-bit-secret-key-here-instead-of-this</code>并保存和退出该文件。</p><p id="ac5e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，我们已经创建了我们的密钥并保存了它，我们可以继续其他控制器。关于<code class="fe ll lm ln lo b">application_controller</code>的其他方法，我不会说太多细节，但是要真正理解他们在幕后做什么，请随意在控制台中摆弄你的代码或者谷歌一下来掌握这个概念！🤓</p><p id="d06c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">就这样，让我们进入<code class="fe ll lm ln lo b"><strong class="jm io">users_controller</strong></code>。提醒一下，<code class="fe ll lm ln lo b">users_controller</code>和<code class="fe ll lm ln lo b">sessions_controller</code>的区别在于<em class="nq">新</em>用户将被定向到<code class="fe ll lm ln lo b">create</code>的方法，而<em class="nq">返回的</em>用户将被定向到<code class="fe ll lm ln lo b">create</code>的方法。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi nr"><img src="../Images/23d78bb10a405e877eb36d2814a335a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jdkS2mk7NA_9EMLqPIptoQ.png"/></div></div><figcaption class="mw mx gj gh gi my mz bd b be z dk translated">用户 _ 控制器创建方法</figcaption></figure><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi ns"><img src="../Images/6668d8ecf2a55e10aa82dd1daf755177.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j5YPATn6lEWS07JxfWvoXw.png"/></div></div><figcaption class="mw mx gj gh gi my mz bd b be z dk translated">用户 _ 控制器用户 _ 参数</figcaption></figure><p id="34d4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">第 12 行的<code class="fe ll lm ln lo b">issue_token</code>来自<code class="fe ll lm ln lo b">application_controller</code>，第 13 行的<code class="fe ll lm ln lo b">UserSerializer</code>来自我之前添加的<code class="fe ll lm ln lo b">active_model_serializers</code>宝石。</p><p id="d440" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是非常不言自明的，所以我将移动到 JWT 设置的下一个控制器，这是<code class="fe ll lm ln lo b"><strong class="jm io">sessions_controller</strong></code>，我同样不会太详细，因为代码本身也是不言自明的。</p><figure class="mc md me mf gt mg"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="d3a1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ll lm ln lo b">create</code>方法用于登录用户，而<code class="fe ll lm ln lo b">show</code>方法用于确定用户是否已经登录。而且提醒一下，<code class="fe ll lm ln lo b">user.authenticate</code>来源于<code class="fe ll lm ln lo b">bcrypt</code>。</p><h2 id="99bc" class="lp kj in bd kk lq lr dn ko ls lt dp ks jv lu lv kw jz lw lx la kd ly lz le ma bi translated">🛣路线</h2><p id="1938" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">随着我们的模型和重要控制器的设置，我们可以移动到我们的<code class="fe ll lm ln lo b">routes.rb</code>文件中的路线。我为我的项目设置 URL 的方式如下:</p><pre class="mc md me mf gt mj lo mk ml aw mm bi"><span id="a816" class="lp kj in lo b gy mn mo l mp mq">post "/signup", to: "users#create"<br/>post "/login", to: "sessions#create"<br/>get "/authorized", to: "sessions#show"<br/>get "/dashboard", to: "users#show"</span></pre><p id="fd03" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">至此，我们已经基本完成了后端的工作，现在让我们开始前端的工作吧！</p><h1 id="9fa3" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">前端设置</h1><p id="d8cf" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">不幸的是，前端设置不像后端设置那样简单，因为每个人的前端架构都会略有不同，但在大多数情况下，它涉及到利用<code class="fe ll lm ln lo b">localStorage</code>。</p><h2 id="7658" class="lp kj in bd kk lq lr dn ko ls lt dp ks jv lu lv kw jz lw lx la kd ly lz le ma bi translated">localStorage.setItem()</h2><p id="a0c4" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">现在我们已经在后端生成了一个 JWT，我们如何让前端识别这个 JWT 呢？对于我的项目，我已经在我的<code class="fe ll lm ln lo b">logInUser</code> action creator 中设置了这个，但是你可以把这个逻辑放在你自己项目中任何你认为合适的地方。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi nt"><img src="../Images/5be472aebc44e789411ddccf0ac8d384.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_dljZlwBZpdu0zlGDlY_mg.png"/></div></div><figcaption class="mw mx gj gh gi my mz bd b be z dk translated">登录用户操作创建者</figcaption></figure><p id="06e5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">重要的 note❗️，因为我们在后端设置了我们的头应该包含一个授权对象(来自第 20 行的<code class="fe ll lm ln lo b">application_controller</code>，我们必须在上面的第 33 行包含<code class="fe ll lm ln lo b">Authorization: localStorage.token</code>。</p><p id="362c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">正如您在第 44 行和第 45 行中看到的，我们获取了从登录用户那里接收到的用户和令牌对象，并将其保存到我们的<code class="fe ll lm ln lo b">localStorage</code>中。</p><p id="5819" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们需要利用<code class="fe ll lm ln lo b">localStorage</code>，因为每次应用程序刷新时，状态不会持续，这意味着应用程序状态中的令牌将被清除。因此，为了确保我们的应用程序意识到用户确实登录了，我们必须能够保存最初从登录生成的令牌，并将其保存到我们的<code class="fe ll lm ln lo b">localStorage</code>中，因此我们的应用程序现在知道查看浏览器的<code class="fe ll lm ln lo b">localStorage</code>来查看令牌是否确实存在，也就是用户是否登录了。</p><p id="b556" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我知道这听起来很复杂，所以一定要花几秒钟来读一遍。</p><h2 id="8c9f" class="lp kj in bd kk lq lr dn ko ls lt dp ks jv lu lv kw jz lw lx la kd ly lz le ma bi translated">localStorage.getItem()</h2><p id="17ba" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">既然我们已经在<code class="fe ll lm ln lo b">localStorage</code>中设置了用户和令牌对象，我们必须<em class="nq">从存储中获取</em>对象以便使用数据。</p><p id="a32b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对于我的项目，我希望应用程序在启动时检查用户和令牌对象是否存在于<code class="fe ll lm ln lo b">localStorage</code>中。因此，我在我的<code class="fe ll lm ln lo b">App</code>组件的<code class="fe ll lm ln lo b">componentDidMount()</code>方法中添加了以下代码。</p><pre class="mc md me mf gt mj lo mk ml aw mm bi"><span id="08e0" class="lp kj in lo b gy mn mo l mp mq"><em class="nq">let</em> token = localStorage.getItem("token");<br/><em class="nq">let</em> user = localStorage.getItem("user");</span><span id="44f4" class="lp kj in lo b gy nu mo l mp mq">if (token &amp;&amp; user) {<br/>   this.props.fetchCurrentUser();<br/>}</span></pre><p id="e9c4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">要了解更多细节和查看完整代码，请务必查看该项目的前端<a class="ae nv" href="https://github.com/kim-jenny5/my-travelogue-frontend" rel="noopener ugc nofollow" target="_blank"> GitHub </a>。</p><h2 id="1e05" class="lp kj in bd kk lq lr dn ko ls lt dp ks jv lu lv kw jz lw lx la kd ly lz le ma bi translated">localStorage.removeItem()</h2><p id="9b80" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">正如设置和获取令牌很重要一样，确保包含从<code class="fe ll lm ln lo b">localStorage</code>中移除对象的代码。</p><p id="0764" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我已经将我的<code class="fe ll lm ln lo b">localStorage.removeItem()</code>行代码包含在两个不同的组件中——一个在错误发生时作为自动防故障装置，另一个在用户注销时使用。</p><p id="fb3e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">主要针对您的应用程序，您只需添加以下代码行，供用户单击注销按钮时使用。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi nw"><img src="../Images/40f608152e36d4ed4c027e9ee18f7024.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dPynrmE8aahSFeccgqpI7A.png"/></div></div></figure><p id="976c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">从上面可以看到，一旦用户点击退出按钮，就会触发这个函数，从<code class="fe ll lm ln lo b">localStorage</code>中删除用户和令牌对象，并将一个动作分派给<code class="fe ll lm ln lo b">logOutUser()</code>动作创建者。</p><p id="795f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">总之，这是关于如何用 JWT 设置你的应用程序安全的一般要点。我试图尽可能地深入，但是如果我要详细描述每一行，这篇文章将会很长(甚至更多🤯比它已经是)。</p><p id="eab0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我强烈建议看看我的 GitHub 后端和前端报告，以了解整个代码流，以及我在下面链接的三篇文章，因为每篇文章都帮助我完成了创建安全应用程序的个人挑战。我希望这有所帮助，并希望你的过程顺利！😊</p><h1 id="423b" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">资源</h1><h2 id="39fb" class="lp kj in bd kk lq lr dn ko ls lt dp ks jv lu lv kw jz lw lx la kd ly lz le ma bi translated">我的 GitHub 关于这个项目的报告</h2><ul class=""><li id="91ab" class="na nb in jm b jn lg jr lh jv nx jz ny kd nz kh oa ng nh ni bi translated"><a class="ae nv" href="https://github.com/kim-jenny5/my-travelogue-backend" rel="noopener ugc nofollow" target="_blank">后端</a></li><li id="85ff" class="na nb in jm b jn nj jr nk jv nl jz nm kd nn kh oa ng nh ni bi translated"><a class="ae nv" href="https://github.com/kim-jenny5/my-travelogue-frontend" rel="noopener ugc nofollow" target="_blank">前端</a></li></ul><h2 id="c0e5" class="lp kj in bd kk lq lr dn ko ls lt dp ks jv lu lv kw jz lw lx la kd ly lz le ma bi translated">对我有帮助的文章</h2><ul class=""><li id="f641" class="na nb in jm b jn lg jr lh jv nx jz ny kd nz kh oa ng nh ni bi translated"><a class="ae nv" href="https://dev.to/evanrpavone/setting-up-jwt-in-rails-api-backend-for-react-frontend-9d8" rel="noopener ugc nofollow" target="_blank">https://dev . to/evanrpavone/setting-up-jwt-in-rails-API-back end-for-react-frontend-9d 8</a></li><li id="af3d" class="na nb in jm b jn nj jr nk jv nl jz nm kd nn kh oa ng nh ni bi translated"><a class="ae nv" href="https://dev.to/kahawaiikailana/rails-api-quickstart-guide-with-postgressql-and-jwt-tokens-3pnk" rel="noopener ugc nofollow" target="_blank">https://dev . to/kahawaiikailana/rails-API-quick start-guide-with-PostgreSQL-and-jwt-tokens-3pnk</a></li><li id="4720" class="na nb in jm b jn nj jr nk jv nl jz nm kd nn kh oa ng nh ni bi translated"><a class="ae nv" href="https://medium.com/swlh/the-client-side-authentication-system-using-jwt-token-on-my-rails-react-app-65d4760be3d" rel="noopener">https://medium . com/swlh/the-client-side-authentic ation-system-using-jwt-token-on-my-rails-react-app-65d 4760 be3d</a></li></ul></div></div>    
</body>
</html>