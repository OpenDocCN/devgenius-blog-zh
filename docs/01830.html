<html>
<head>
<title>Node.js Tips — Format JSON, Remove Object with MongoDB, Parallel Execution, and More</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js技巧—格式化JSON、使用MongoDB移除对象、并行执行等等</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/node-js-tips-format-json-remove-object-with-mongodb-parallel-execution-7b9dac1ae323?source=collection_archive---------37-----------------------#2020-07-12">https://blog.devgenius.io/node-js-tips-format-json-remove-object-with-mongodb-parallel-execution-7b9dac1ae323?source=collection_archive---------37-----------------------#2020-07-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/703f322c21cecc6de5f73519b89fb00c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vO5c0JHL2tegCoxR"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">由<a class="ae kc" href="https://unsplash.com/@ferminrp?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Fermin Rodriguez Penelas </a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><p id="30cc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像任何类型的应用程序一样，当我们编写节点应用程序时，有一些困难的问题需要解决。</p><p id="96a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究一些编写节点应用程序时常见问题的解决方案。</p><h1 id="31e9" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">在Node.js中编写格式化的JSON</h1><p id="1cea" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">要在节点应用程序中打印格式化的JSON，我们可以使用带有一些额外参数的<code class="fe me mf mg mh b">JSON.stringify</code>方法。</p><p id="8c5b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="1a97" class="mq lc iq mh b gy mr ms l mt mu">JSON.stringify(obj, null, 2)</span></pre><p id="9468" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">添加两个缩进空间。</p><h1 id="9bb2" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">用MongoDB从数组中删除对象</h1><p id="0593" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过使用<code class="fe me mf mg mh b">update</code>方法用MongoDB从数组中移除一个对象。</p><p id="9b6e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="39eb" class="mq lc iq mh b gy mr ms l mt mu">db.collection.update(<br/>  {'_id': ObjectId("5150a1199fac0e6910000002")}, <br/>  { $pull: { "items" : { id: 123 } } },<br/>  false,<br/>  true <br/>);</span></pre><p id="2290" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们传入查询，这是拥有数组的文档的ID。</p><p id="9d19" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后第二个参数获取要更新的项目，这是我们想要从<code class="fe me mf mg mh b">items</code>数组中移除的项目。</p><p id="0049" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">$pull</code>删除数组中的项目。</p><p id="5fcc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第三个参数意味着我们不想做upsert。</p><p id="fa75" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后一个参数意味着我们要处理多个文档。</p><h1 id="7ecf" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">Node.js中的console.log与console.info</h1><p id="2a1d" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们使用<code class="fe me mf mg mh b">console.log</code>方法来记录一般消息。</p><p id="c947" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">console.info</code>专门用于记录信息性消息。</p><p id="3179" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，除了名字和它们的预期用途之外，它们几乎做同样的事情。</p><h1 id="fc32" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">复制到Node.js中的剪贴板</h1><p id="efd2" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">要将一些内容复制到剪贴板，我们可以运行一个shell命令来将一些内容复制到剪贴板。</p><p id="a99d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，在Linux中，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="1180" class="mq lc iq mh b gy mr ms l mt mu">const exec = require('child_process').exec;</span><span id="d570" class="mq lc iq mh b gy mv ms l mt mu">const getClipboard = (func) =&gt; {<br/>  exec('/usr/bin/xclip -o -selection clipboard', (err, stdout, stderr) =&gt; {<br/>    if (err || stderr) { <br/>      throw new Error(stderr);<br/>    }<br/>    func(null, stdout);<br/>  });<br/>};</span><span id="38b5" class="mq lc iq mh b gy mv ms l mt mu">getClipboard((err, text) =&gt; {<br/>  if (err) {<br/>    console.error(err);<br/>  }<br/>  console.log(text);<br/>});</span></pre><p id="ad99" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用命令获取剪贴板的内容并输出到标准输出。</p><p id="2435" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们可以使用<code class="fe me mf mg mh b">clipboardy</code>包来读写剪贴板。</p><p id="0d14" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="d8db" class="mq lc iq mh b gy mr ms l mt mu">const clipboardy = require('clipboardy');<br/>clipboardy.writeSync('copy me');</span></pre><p id="2794" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">复制到剪贴板。</p><p id="205d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要从剪贴板粘贴，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="ce50" class="mq lc iq mh b gy mr ms l mt mu">const clipboardy = require('clipboardy');<br/>clipboardy.readSync();</span></pre><h1 id="62b0" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">协调Node.js中的并行执行</h1><p id="0141" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">为了在Noe应用中协调代码的并行执行，我们可以使用<code class="fe me mf mg mh b">async</code>库。</p><p id="e52d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="9deb" class="mq lc iq mh b gy mr ms l mt mu">const async = require('async');<br/>const fs = require('fs');<br/>const A = (c) =&gt; { fs.readFile('file1', c) };<br/>const B = (c) =&gt; { fs.readFile('file2', c) };<br/>const C = (result) =&gt; {<br/>  // get all files and use them<br/>}</span><span id="5375" class="mq lc iq mh b gy mv ms l mt mu">async.parallel([A, B], C);</span></pre><p id="0671" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有3个读文件进程，我们将前2个放在一起，这样我们可以并行运行它们。</p><p id="614f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦它们都完成了，我们就运行函数<code class="fe me mf mg mh b">C</code>。</p><p id="8f2b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们用<code class="fe me mf mg mh b">parallel</code>方法完全控制哪些并行运行，哪些串行运行。</p><h1 id="1936" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">要求和功能</h1><p id="51f9" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果我们要调用<code class="fe me mf mg mh b">require</code>来导入一个函数。</p><p id="c403" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们必须将该功能分配给<code class="fe me mf mg mh b">module.exports</code>。</p><p id="cc42" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><p id="cad5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">app/routes.js</code></p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="8dd4" class="mq lc iq mh b gy mr ms l mt mu">module.exports = (app, passport) =&gt; {<br/>  // ...<br/>}</span></pre><p id="30bd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="b871" class="mq lc iq mh b gy mr ms l mt mu">require('./app/routes')(app, passport);</span></pre><p id="bc5d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要调用import函数并立即调用它。</p><h1 id="3c04" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">带发电机的异步/等待和ES6产出</h1><p id="f3de" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe me mf mg mh b">async</code>和<code class="fe me mf mg mh b">await</code>与发电机关系非常密切。</p><p id="e8f0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">他们只是总能产生承诺的发电机。</p><p id="d2b5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们被编译成带有巴别塔的生成器。</p><p id="1e6b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">async</code>和<code class="fe me mf mg mh b">await</code>总是用<code class="fe me mf mg mh b">yield</code>。</p><p id="e731" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它用于将产生的值解包为承诺，并将解析后的值传递给异步函数。</p><p id="88e2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们应该使用<code class="fe me mf mg mh b">async</code>和<code class="fe me mf mg mh b">await</code>来链接承诺，因为我们可以链接它们，就好像代码是同步的一样。</p><p id="9a4d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是，它只能回报承诺。</p><p id="a6ce" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">async</code>和<code class="fe me mf mg mh b">await</code>是构建在生成器之上的一个抽象概念，使得使用它们更加容易。</p><h1 id="bdba" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">从Node.js HTTP Get请求中获取数据</h1><p id="3510" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用<code class="fe me mf mg mh b">http</code>模块的<code class="fe me mf mg mh b">get</code>方法发出GET请求。</p><p id="c6f1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="d73b" class="mq lc iq mh b gy mr ms l mt mu">const http = require('http');</span><span id="1a06" class="mq lc iq mh b gy mv ms l mt mu">const options = {<br/>  //...<br/>};</span><span id="b218" class="mq lc iq mh b gy mv ms l mt mu">http.get(options, (response) =&gt; {  <br/>  response.setEncoding('utf8')  <br/>  response.on('data', console.log)  <br/>  response.on('error', console.error)  <br/>})</span></pre><p id="acaa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">response</code>是一个读取流，所以我们必须监听<code class="fe me mf mg mh b">data</code>事件来获取数据。</p><p id="acf9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们通过监听<code class="fe me mf mg mh b">error</code>事件来获取错误。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/fc9a859db39c960711ddda9c28cd9780.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Y34e2dC68oC-AUT9"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://unsplash.com/@shrouda?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">谢伊·鲁达</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="2d77" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="9615" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用<code class="fe me mf mg mh b">http</code>模块来发出GET请求。</p><p id="8079" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要从MongoDB文档的数组中删除一个项目，我们可以使用带有<code class="fe me mf mg mh b">$pull</code>命令的<code class="fe me mf mg mh b">update</code>方法。</p><p id="e345" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">async</code>模块让我们处理函数的并行和串行执行。</p><p id="071e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们可以使用shell命令或第三方库来操作剪贴板。</p><p id="ad53" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">async</code>和<code class="fe me mf mg mh b">await</code>是生成器之上的抽象。</p></div></div>    
</body>
</html>