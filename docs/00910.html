<html>
<head>
<title>How to Create an Apple Card Payment Dial — Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何创建Apple Card支付拨号——第2部分</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-to-create-an-apple-card-payment-dial-part-2-ad056b8cf572?source=collection_archive---------16-----------------------#2020-06-19">https://blog.devgenius.io/how-to-create-an-apple-card-payment-dial-part-2-ad056b8cf572?source=collection_archive---------16-----------------------#2020-06-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="612f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">表盘上的文字以及如何在曲线上绘制文字。</strong></p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/1f2007ff8dabc361bc02a5b224a23cfb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t4tRA1aDjPWbneqHqU_NDQ.jpeg"/></div></div></figure><p id="ec8d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本系列的第1部分中，我们设计了表盘的基本界面。在这一部分，我们将在表盘内布置文字。</p><p id="2e0c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们需要在这里布局的文本是顶部和底部的标签，“帐户余额”和“显示我的钱”。</p><p id="3ea3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">苹果在这里有一个CoreText样本项目<a class="ae kx" href="https://developer.apple.com/library/archive/samplecode/CoreTextArcCocoa/Introduction/Intro.html" rel="noopener ugc nofollow" target="_blank"/>。它沿着弧线绘制文本，我认为这就足够了，不幸的是，这不是我所需要的适合。底部的线应该是上下颠倒的。所以我实现了自己的文本路径解决方案。</p><p id="f329" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我选择使用<a class="ae kx" href="https://en.wikipedia.org/wiki/B%C3%A9zier_curve" rel="noopener ugc nofollow" target="_blank">贝塞尔曲线</a>，它会给我自由来设计我想要的文本。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ky"><img src="../Images/97bb746a435eef7399354dde16cfed7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zC-UONk7tjWdF1o3WOSrnQ.jpeg"/></div></div></figure><h1 id="cf69" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">贝塞尔曲线</h1><p id="ad76" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">为了沿着曲线布局文本，我们需要计算曲线的点和切线。我们使用<a class="ae kx" href="https://en.wikipedia.org/wiki/Tangent" rel="noopener ugc nofollow" target="_blank">手柄</a>找到我们需要旋转文本的角度。把切线想象成我们需要在上面绘制文本的线。</p><p id="6346" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">贝塞尔曲线有如下等式:<br/>𝐁❨𝘵❩=❨𝟷𝘵❩𝚸₀+𝟹❨𝟷𝘵❩𝘵𝚸₁+𝟹❨𝟷𝘵❩𝘵𝚸₂+𝘵𝚸₃，且≤1</p><p id="bb59" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">而它的正切方程是:<br/>𝐁❨𝘵❩=𝟹❨𝟷𝘵❩❨𝚸₁𝚸₀+𝟼❨𝟷𝘵❩𝘵❨𝚸₂𝚸₁)+𝟹𝘵❨𝚸₃</p><p id="25c0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以下函数生成曲线的点和切线。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="8e50" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面的函数以0.001为步长从0到1循环通过曲线方程。为了画出曲线，我们画出将这些点连接在一起的线。这实际上是曲线的近似，而不是真实的曲线。</p><p id="1c11" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">结果存储在一个简单的结构中，如下所示:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mc md l"/></div></figure><h1 id="2115" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">呈现文本</h1><p id="a767" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">文本将呈现在图形上下文中。在Swift中，我总是忘记如何正确设置<code class="fe me mf mg mh b">CGContext</code>的最后一个参数，所以我创建了一个简单的CGContext包装器。</p><blockquote class="mi mj mk"><p id="e98e" class="jn jo ml jp b jq jr js jt ju jv jw jx mm jz ka kb mn kd ke kf mo kh ki kj kk ij bi translated">你也可以使用<code class="fe me mf mg mh b">UIGraphicsUIGraphicsImageRenderer</code>来达到同样的效果。</p></blockquote><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="d224" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们准备渲染字符串，我创建了一个函数<code class="fe me mf mg mh b">render(attributedString: curve: bitmap:)</code> <br/>作为<code class="fe me mf mg mh b">NSAttributedString</code>传入文本，这样我们就可以控制字体、颜色、对齐和字距等参数。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="0602" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们在这里做的是在曲线上找到一个适合字符宽度的空间，一旦我们找到一个足够大的空间，我们就绘制该字符的字形，并重复这个过程，直到所有的字符都被绘制出来，或者我们用完了曲线上的空间。</p><p id="71cf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们进一步分解它。我们用<code class="fe me mf mg mh b">attributedString</code>创建一个<code class="fe me mf mg mh b">CTLine</code>来获得该行的<code class="fe me mf mg mh b">CTRun</code>。我们只对第一次字形运行感兴趣。然后我们检查是否需要字距调整。</p><p id="4ad0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">函数<code class="fe me mf mg mh b">indexOfStartPoint()</code>检查属性字符串的文本对齐。如果文本没有左对齐，我们需要找到曲线上我们想要开始呈现文本的点。因此，如果文本是右对齐的，我们测量曲线的长度(记住曲线只是一系列线)并测量文本的长度，从曲线的长度中减去文本的长度将告诉我们需要在曲线上的哪里开始。<br/>同样，如果文本居中，找到曲线的中点，减去文本长度的一半，就会告诉我们需要从哪里开始。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="b1ca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">回到<code class="fe me mf mg mh b">render()</code>现在我们知道了我们想从曲线上的哪一点开始，我们循环遍历字形，测量每个字形，然后试图找到曲线上适合字形的点的范围。一旦我们找到了这个范围，就得到这个范围中点的正切值，从这个正切值我们可以通过求正切值的反正切值来计算我们需要旋转字形的角度。</p><p id="5cf1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有了曲线上我们想要绘制字形的点和旋转它的角度，只需设置位图上下文的转换来匹配这些参数并绘制字形。<br/>你会注意到我们也在循环中得到字体和颜色，我们可以在循环之外进行检查，但这样我们就失去了定制每个字形的文本的能力。</p><h1 id="0420" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">回到表盘</h1><p id="7f8a" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">让我们重构上面的内容，这样我们就可以在我们的视图中使用它。</p><p id="7bbf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在Xcode的<em class="ml">项目导航器</em>新建一个组，姑且称之为<em class="ml">弯曲文字</em>。</p><blockquote class="mi mj mk"><p id="d25e" class="jn jo ml jp b jq jr js jt ju jv jw jx mm jz ka kb mn kd ke kf mo kh ki kj kk ij bi translated">如果看不到<strong class="jp ir">项目导航器</strong>窗格，打开<em class="iq">视图</em>菜单，然后转到<em class="iq">导航器</em>子菜单，选择<em class="iq">显示项目导航器</em>。</p></blockquote><p id="3d9b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">选择该组并创建一个名为<em class="ml"> CurvedTextRenderer </em>的新swift文件。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mp"><img src="../Images/97008b99cf720243020aad8cea74ada9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7XiyxLD7-DD-0Sfz9SYlEQ.jpeg"/></div></div></figure><p id="8f6e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">向名为<em class="ml"> Bitmap.swift </em>的组中添加一个新文件，并从上面添加<code class="fe me mf mg mh b">Bitmap</code>类。</p><p id="3e84" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">给<code class="fe me mf mg mh b">CurvedTextRenderer</code>添加一个<code class="fe me mf mg mh b">bitmap</code>属性。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="8b88" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将上面的<code class="fe me mf mg mh b">Curve</code>结构添加到<code class="fe me mf mg mh b">CurvedTextRenderer</code>。</p><p id="2d8d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了更容易编写贝塞尔曲线方程并提高可读性，我在一个名为<em class="ml"> CGPointAdditions.swift </em>的单独文件中添加了一些关于<code class="fe me mf mg mh b">CGPoint</code>的操作符重载，如下所示:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="1f21" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<code class="fe me mf mg mh b">CurvedTextRenderer</code>中增加<code class="fe me mf mg mh b">computeBezierCurve(::::)</code>、<code class="fe me mf mg mh b">render(:::)</code>和<code class="fe me mf mg mh b">indexOfStartPoint(:::)</code>功能。</p><p id="4066" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如上所述，我们需要一个图形上下文来呈现我们的内容。为了在我们的视图中呈现图形上下文，我们需要添加一个UIImageView。</p><p id="e8e2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">打开<strong class="jp ir"> PaymentDialView.xib </strong>，在<em class="ml">文本视图</em>中添加一个UIImageView，确保它在标签的后面，通过使它成为<em class="ml">文本视图</em>中最上面的子视图来实现。将它固定到它的超级视图，我们称之为<em class="ml">位图视图</em>。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mp"><img src="../Images/1c9254123ddd2db07a46047160779fad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s17HA3ifMTwmhwWR8BP2qg.jpeg"/></div></div></figure><p id="5a17" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过创建一个出口，然后将其连接到<em class="ml">位图视图</em>，将我们的<em class="ml">位图视图</em>连接到<code class="fe me mf mg mh b">PaymentDialView</code>类。</p><p id="8331" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们在<code class="fe me mf mg mh b">CurvedTextRenderer</code>上创建一个类方法，我们向它传递两个属性字符串和图像视图的框架。它将返回我们可以在图像视图中设置的图形上下文的图像。</p><h1 id="5725" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">类方法</h1><p id="8d0f" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">我们的类方法将有以下声明:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="d43b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了画出这两根弦，我们需要两条曲线，一条是上面的弦，一条是下面的弦。在曲线文本的顶部截图中，文本绘制在线的上方，我们需要在绘制顶部曲线时考虑到这一点。</p><p id="41cd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们首先需要创建一个<code class="fe me mf mg mh b">CurvedTextRenderer</code>的实例。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="3440" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后设置我们的图形上下文，我们使用传入的帧大小创建一个:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="8a8b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我在上面提到过，文本被绘制在曲线的上方，这意味着如果我们使用<code class="fe me mf mg mh b">frame</code>的当前大小来绘制曲线的点，顶部的字符串将被绘制在我们的图形上下文之外。因此，我们需要创建一个新的插入框架，一个比背景的尺寸小，但共享同一个中心的框架。我们还将在顶部添加一些额外的填充，使文本看起来更好。插入的值将是顶部字符串的字体大小乘以一个行距因子，我已经将行距设置为1.7。从顶部属性字符串中检索字体大小。</p><blockquote class="mi mj mk"><p id="3176" class="jn jo ml jp b jq jr js jt ju jv jw jx mm jz ka kb mn kd ke kf mo kh ki kj kk ij bi translated">根据本<a class="ae kx" href="http://digerati-illuminatus.blogspot.com/2008/05/approximating-semicircle-with-cubic.html" rel="noopener ugc nofollow" target="_blank">帖</a>用贝塞尔曲线逼近一个圆弧，控制点需要</p><p id="76f5" class="jn jo ml jp b jq jr js jt ju jv jw jx mm jz ka kb mn kd ke kf mo kh ki kj kk ij bi translated"><code class="fe me mf mg mh b">xValueInset = Diameter * 0.05<br/> yValueOffset = radius * 4.0 / 3.0</code></p><p id="a1ef" class="jn jo ml jp b jq jr js jt ju jv jw jx mm jz ka kb mn kd ke kf mo kh ki kj kk ij bi translated"><code class="fe me mf mg mh b">P0 = (0,0)<br/> P1 = (xValueInset, yValueOffset)<br/> P2 = (Diameter - xValueInset, yValueOffset)<br/> P3 = (Diameter, 0)</code></p></blockquote><p id="b68d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">作为上述结果，我们的顶部曲线的点将如下:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="2e13" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe me mf mg mh b">scaledFrame</code>是<code class="fe me mf mg mh b">frame</code>乘以<code class="fe me mf mg mh b">UIScreen.main.scale</code>，将帧缩放到设备的原生分辨率。</p><p id="3cf6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于底部的字符串，我们遵循与上面类似的方法，但是我们没有添加行距因子，因为文本是在曲线上方绘制的。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="840c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我们返回上下文的UIImage以显示在视图中。</p><p id="7817" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<code class="fe me mf mg mh b">PaymentDialView</code>的<code class="fe me mf mg mh b">commonInit()</code>中，我们需要调用这个类方法来设置图像。我们还将在<code class="fe me mf mg mh b">updateConstraints()</code>中再次调用它，以便每当图像视图改变其框架时，图像视图更新其内容。我们将把所有这些放在一个单独的函数中，这样我们就不必重复自己，防止代码重复。</p><p id="0578" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们在<code class="fe me mf mg mh b">PaymentDialView</code>中的<code class="fe me mf mg mh b">updateRoundedTextView()</code>函数看起来像这样:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="120e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的视图现在应该是这样的:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mq"><img src="../Images/cdf3f95227ca33c96bbfcaa4cb147d85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2-Yj03ZXPKpyAnN9Zy6BDA.jpeg"/></div></div></figure><p id="ff8d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我必须承认，我发现这部分是最难的，它花了最长的时间来发展！<br/>我希望你喜欢这一部分，它足够清晰。和我一起参加第3部分，在表盘上设置交互。</p><h1 id="f0d5" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">奖励材料</h1><p id="2d91" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">在第1部分中，我们将<code class="fe me mf mg mh b">updateConstriants()</code>添加到了<code class="fe me mf mg mh b">prepareForInterfaceBuilder()</code>中，因此当我们打开<strong class="jp ir"> Main.storyboard </strong>时，应该会出现以下内容:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mp"><img src="../Images/5f9ea19e7bb1435f3c8cd90f3feefa3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0tLbzWaUYpCWMPgFkWg6dw.jpeg"/></div></div></figure><p id="cdda" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，我们也希望能够更改<em class="ml">界面构建器</em>中的文本，这样我们就不必一直运行项目来查看我们的更改。我们通过添加这两个属性来实现:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="3762" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还需要更新<code class="fe me mf mg mh b">updateRoundedTextView()</code>函数来使用这些值，而不是硬编码的值。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="a692" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有了以上内容，我们应该能够在<em class="ml">界面构建器</em>中进行以下操作。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mp"><img src="../Images/8704538bb7de26ba5ce369c472a9b5d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pfmk4fkEGbpaFfT-3pfhyg.jpeg"/></div></div></figure><p id="30d7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们也可以改变字体，字体大小，字距和文字颜色。亲爱的读者，我将把它作为一个练习。</p><p id="2aa0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请加入我的第3部分，让表盘响应用户输入。</p></div></div>    
</body>
</html>