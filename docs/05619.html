<html>
<head>
<title>Building Microservices with Event-Driven Architecture</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用事件驱动架构构建微服务</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/building-microservices-with-event-driven-architecture-f9243d812442?source=collection_archive---------2-----------------------#2021-09-18">https://blog.devgenius.io/building-microservices-with-event-driven-architecture-f9243d812442?source=collection_archive---------2-----------------------#2021-09-18</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="55fd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在本帖中，我们将讨论如何使用事件驱动架构构建微服务。作为帖子的一部分，我还将展示一个事件驱动的微服务的例子。如果你不知道什么是微服务，可以从<a class="ae ki" href="https://betterjavacode.com/core-java/spring-boot-and-microservices" rel="noopener ugc nofollow" target="_blank">我这里的入门</a>开始。</p><h1 id="e705" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">微服务—事件驱动架构</h1><p id="4ae8" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">传统上，我们会使用基于REST的微服务。在这个微服务中，客户端会请求数据，然后服务器会用数据做出响应。但是也有缺点，客户端必须等待服务器响应。服务器可能关闭或服务于其他请求，正在延迟对当前客户端请求的响应。</p><p id="ecbc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">简而言之，当系统因为同步连接而变得缓慢时，我们可以使用事件驱动架构来使系统异步。</p><p id="2433" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">事件驱动的微服务使用最终一致的方法。每当有更新或事务时，每个服务都会发布事件数据。其他服务订阅此服务发布事件。当这些订阅的服务接收到事件时，它们更新它们的数据。</p><p id="7b7a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这种方法的一个简单例子是:当客户兑换礼品卡时，会创建一个单独的兑换事件，并由不同的服务消费。</p><ol class=""><li id="2cf3" class="lm ln in jm b jn jo jr js jv lo jz lp kd lq kh lr ls lt lu bi translated">可以在数据库中写入兑换记录的奖励服务</li><li id="a2c0" class="lm ln in jm b jn lv jr lw jv lx jz ly kd lz kh lr ls lt lu bi translated">顾客收到通过礼品卡购买的商品</li><li id="257f" class="lm ln in jm b jn lv jr lw jv lx jz ly kd lz kh lr ls lt lu bi translated">合作伙伴服务验证礼品卡，并允许兑现和相应地处理顾客购买的商品。</li></ol><p id="c473" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae ki" href="https://www.educative.io/path/scalability-system-design?aff=VRQq" rel="noopener ugc nofollow" target="_blank">事件驱动架构</a>要么通过队列，要么通过发布-订阅模型。在发布/订阅模型中，服务发布事件，订阅的服务消费该事件。和队列、主题做的事情区别不大。</p><h1 id="e98d" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">事件驱动架构的优势</h1><ul class=""><li id="6c56" class="lm ln in jm b jn lh jr li jv ma jz mb kd mc kh md ls lt lu bi translated"><strong class="jm io">松耦合</strong> —服务不需要依赖其他服务。考虑到架构是反应式的，服务可以相互独立。</li><li id="433d" class="lm ln in jm b jn lv jr lw jv lx jz ly kd lz kh md ls lt lu bi translated"><strong class="jm io">异步</strong> —发布服务将发布事件。订阅服务可以随时使用事件。异步架构的主要优点是服务不会阻塞资源。</li><li id="2aa8" class="lm ln in jm b jn lv jr lw jv lx jz ly kd lz kh md ls lt lu bi translated"><strong class="jm io">扩展</strong> —由于服务是独立的，大多数服务执行单一任务。这也使得寻找瓶颈变得更加容易。</li></ul><h1 id="125b" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">事件驱动架构的缺点</h1><p id="7afc" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">每一个设计都是一种取舍。在分布式系统中，我们没有完美的设计。使用事件驱动的架构，人们可以通过分离关注点轻松地过度设计解决方案。</p><p id="7ce3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">事件驱动架构需要前期投资。由于数据不一定立即可用，这可能会引起一些事务方面的问题。如果数据有问题，最终的一致性可能很难调查。可能存在重复事件，从而导致重复数据。事件驱动模型不支持ACID事务。</p><h1 id="0a63" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">建筑框架</h1><p id="0e96" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">尽管有这些缺点，事件驱动架构速度很快，并能成功地交付结果。所以下一个问题是选择什么框架来构建这个架构。目前，有两种选择</p><h1 id="3d6d" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">信息处理</h1><p id="f344" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">在消息处理中，服务创建消息并将其发送到目的地。订阅服务从该目的地获取消息。在AWS中，我们使用SNS(简单通知服务)和SQS(简单队列服务)。服务向主题发送消息，订阅该主题的队列获取该消息并进一步处理它。</p><p id="d389" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">SNS和SQS并不是唯一的框架。消息队列使用代理的存储和转发系统，事件在代理之间传递。ActiveMQ和RabbitMQ是消息队列的另外两个例子</p><h1 id="7c2f" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">流处理</h1><p id="e7d8" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">在流处理中，服务发送一个事件，订阅的服务拾取该事件。然而，事件并不针对特定的目标。</p><p id="27e8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">通常，事件的生产者发出事件，并可以将它们存储在存储器中。事件的消费者可以消费来自数据存储的那些事件。最流行的流处理框架是Kafka 。基本上，它遵循发布-订阅模型。</p><p id="d80e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最重要的是，流处理器(如Kafka)提供了数据的持久性。数据不会丢失，如果系统离线，它可以再现事件的历史。</p><h1 id="bbf6" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">基于事件驱动架构的微服务演示</h1><p id="37ca" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">作为演示的一部分，我们将实现一个Spring Boot应用程序和ActiveMQ消息代理服务。</p><h1 id="9c28" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">ActiveMQ消息服务</h1><p id="065a" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">ActiveMQ是一个开源的消息代理。目前，它支持用Java、Python、.Net、C++等等。</p><p id="2651" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">点击从<a class="ae ki" href="https://activemq.apache.org/" rel="noopener ugc nofollow" target="_blank">下载ActiveMQ。一旦你在你的机器上解压了下载的文件夹，你可以转到<code class="fe me mf mg mh b">bin</code>目录，用一个命令<code class="fe me mf mg mh b">activemq.bat start</code>启动ActiveMQ服务器。这将在<code class="fe me mf mg mh b"><a class="ae ki" href="http://localhost:8161." rel="noopener ugc nofollow" target="_blank">http://localhost:8161</a></code> </a><a class="ae ki" href="http://localhost:8161." rel="noopener ugc nofollow" target="_blank">启动ActiveMQ服务器。</a></p><h1 id="eb0d" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">Spring Boot的发送者应用程序</h1><p id="1375" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">现在，让我们使用Spring Boot创建一个消息发送者应用程序。我们将需要以下依赖关系</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="f341" class="mq kk in mh b gy mr ms l mt mu">dependencies { <br/>implementation 'org.springframework.boot:spring-boot-starter-activemq' <br/>implementation 'org.springframework.boot:spring-boot-starter-web' testImplementation 'org.springframework.boot:spring-boot-starter-test' <br/>}</span></pre><p id="2b00" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们将添加JMS配置来创建ActiveMQ队列。</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="0e5b" class="mq kk in mh b gy mr ms l mt mu">@Configuration<br/>public class JmsConfig<br/>{<br/>    @Bean<br/>    public Queue queue()<br/>    {<br/>        return new ActiveMQQueue("demo-queue");<br/>    }<br/>}</span></pre><p id="eeaf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这为我们的队列<code class="fe me mf mg mh b">demo-queue</code>创建了一个bean。为了通过我们的sender应用程序向该队列发送消息，我们将创建一个REST API，如下所示:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="1282" class="mq kk in mh b gy mr ms l mt mu">@RestController<br/>@RequestMapping("/v1/betterjavacode/api")<br/>public class MessageController<br/>{<br/>    @Autowired<br/>    private Queue queue;<br/><br/>    @Autowired<br/>    private JmsTemplate jmsTemplate;<br/><br/>    @GetMapping("/message/")<br/>    public ResponseEntity sendMessage(@RequestBody String message)<br/>    {<br/>        jmsTemplate.convertAndSend(queue, message);<br/>        return new ResponseEntity(message, HttpStatus.OK);<br/>    }<br/><br/>}</span></pre><p id="5d7a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">随后，我们在RestController中注入了<code class="fe me mf mg mh b">queue</code>和<code class="fe me mf mg mh b">jmsTemplate</code>bean，这样就可以发送消息了。</p><p id="4773" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">另一方面，我们还将有一个接收方应用程序，它将是一个目的地服务或消费者服务，使用来自发送方应用程序的消息。</p><p id="43c9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在我们的receiver应用程序中创建一个消息消费者类</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="fe46" class="mq kk in mh b gy mr ms l mt mu">@Component<br/>@EnableJms<br/>public class MessageConsumer<br/>{<br/>    private final Logger logger = LoggerFactory.getLogger(MessageConsumer.class);<br/><br/>    @JmsListener(destination = "demo-queue")<br/>    public void receiveMessage(String message)<br/>    {<br/>        // TO-DO<br/>        logger.info("Received a message = {}", message);<br/>    }<br/>}</span></pre><p id="4276" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">带有destination的注释<code class="fe me mf mg mh b">@JmsListener</code>让应用程序监听那个队列。<code class="fe me mf mg mh b">@EnableJms</code>启用注释<code class="fe me mf mg mh b">@JmsListener</code>。</p><p id="9baa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们仍然需要添加ActiveMQ属性，以便两个应用程序都知道ActiveMQ服务器在哪里运行。因此，将以下属性添加到<code class="fe me mf mg mh b">application.properties</code></p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="6371" class="mq kk in mh b gy mr ms l mt mu">spring.activemq.broker-url=tcp://localhost:61616 spring.activemq.user=admin spring.activemq.password=admin</span></pre><p id="0a9f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在启动两个Spring Boot应用程序。发送方应用程序运行在8080上，接收方应用程序运行在8081上。</p><figure class="mi mj mk ml gt mw gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/46ea656a9f458d90909adb0a8e1a148e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/0*Xd8OmH8uoZDs8fk5"/></div></figure><p id="b4a6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，如果我们检查receiver应用程序的日志，我们将看到它已经使用了来自ActiveMQ队列<code class="fe me mf mg mh b">demo-queue</code>的消息。</p><figure class="mi mj mk ml gt mw gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/aab65975d993c0f56b74d4430a177feb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/0*zBmetr6w8Op7AiXt"/></div></figure><p id="2bfe" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们还可以看到ActiveMQ服务器中队列的状态。</p><figure class="mi mj mk ml gt mw gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/bcce877c5a239a1cbca4e06fe6089ea3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/0*n8mo35VgFgqmSLh5"/></div></figure><p id="c210" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这里，您可以看到队列从发送方接收到两条消息，并将其传递给消费者。这个演示的代码可以在我的<a class="ae ki" href="https://github.com/yogsma/betterjavacode" rel="noopener ugc nofollow" target="_blank"> github库</a>中找到。</p><h1 id="9f8b" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">结论</h1><p id="5d41" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">在这篇文章中，我讨论了微服务的事件驱动架构。我们还讨论了这种架构的优点和缺点。最后，我们展示了如何使用ActiveMQ为异步通信建立一个基于事件驱动架构的微服务。</p><p id="5124" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">另外，如果你还没有买我的《春季安全》一书，你可以在这里买<a class="ae ki" href="https://yogsma.gumroad.com/l/VgSdH" rel="noopener ugc nofollow" target="_blank">或者在这里</a>阅读更多信息。</p><h1 id="95ce" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">参考</h1><p id="2b42" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">使用ActiveMQ的事件驱动微服务— <a class="ae ki" href="https://itnext.io/event-driven-microservices-with-spring-boot-and-activemq-5ef709928482" rel="noopener ugc nofollow" target="_blank"> ActiveMQ </a></p></div><div class="ab cl mz na hr nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ig ih ii ij ik"><p id="0a06" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ng">原载于2021年9月18日</em><a class="ae ki" href="https://betterjavacode.com/programming/microservices-event-driven-architecture" rel="noopener ugc nofollow" target="_blank"><em class="ng">https://betterjavacode.com</em></a>T22。</p></div></div>    
</body>
</html>