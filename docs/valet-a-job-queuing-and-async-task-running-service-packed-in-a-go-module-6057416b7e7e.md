# Valet，打包在 Go 模块中的作业队列和异步任务运行服务

> 原文：<https://blog.devgenius.io/valet-a-job-queuing-and-async-task-running-service-packed-in-a-go-module-6057416b7e7e?source=collection_archive---------4----------------------->

![](img/47c1ed6bfd06038e54be99d2fc63f78a.png)

几个月前，我偶然发现了@ matiasvarela 的这篇文章，作者通过一个示例项目向我们介绍了六边形架构。这激励我通过实践特定的设计模式来构建这个新项目。

> 什么是贴身男仆？

这个想法并不新鲜。作业队列服务和异步任务运行程序。一个守护进程，它公开一个 API，负责异步和并发地执行“繁重”的任务。它位于其他服务之间，只有一个职责:完成繁重的工作并存储结果(如果有的话)。

那么什么是合适的任务呢？如何安排任务的执行？我们如何向每个任务传递参数，我们如何从语言对并发性的内置支持中获益，以使所有这些更有效？让我们通过进入项目的实现细节来回答这些问题。

你可以在 GitHub 上找到这个项目:[https://github.com/svaloumas/valet](https://github.com/svaloumas/valet)

不言而喻，这里介绍的每种方法都只是可能的解决方案之一，如果有任何反馈，我们将不胜感激。

> **回调**

任务是用户定义的函数，由服务在未来的某个时间或立即作为回调运行。代客按如下方式处理所有可能的回电:

每个任务都应该实现一个固定的类型。签名`func(…interface{}) (interface{}, error)`被用作任务的类型。

TaskFunc 是任务应该实现的类型。

您可以通过 API 端点向函数传递参数。这些参数将总是放在`args[0]`中，因此可以从函数内部访问它们，它们的类型将是`map[string]interface{}`。正如我们将在后面看到的，多个任务可以按顺序一个接一个地运行。在这种情况下，`args[1]`将保存前一个任务的结果，以便当前的任务可以使用它们和自己的参数。任务的返回值总是一个`interface{}`，带有我们可能需要存储为任务结果的任何元数据和一个`error`。

您还可以定义自定义结构，并将请求有效负载中给出的`map[string]interface{}`类型参数解码成您自己的数据结构。

下面的两个函数将参数解码成自定义结构。他们都在内部使用@ [Mitchell Hashimoto](https://github.com/mitchellh) 的 [mapstructure](https://github.com/mitchellh/mapstructure) 。

任务函数中使用的助手函数。

让我们把它们放在一起。下面是一个用户定义的任务的例子，它实现了`TaskFunc`类型，以及一个将任务参数解码成的结构。

一个虚拟任务回调示例。

任务在服务初始化时注册，并存储在内存中的映射中，以便可以使用唯一的字符串标识符调用它们的函数值。

服务初始化期间的任务注册。

该服务在运行时使用简单的查找机制，将每个任务名称与其对应的函数值相关联。

内存中任务查找。

现在我们已经将任务存储在内存中，我们可以创建新的作业和管道，通过 API 调用将参数传递给函数，方法是将它们添加到请求有效负载中。

作业创建请求负载示例。

那么，什么是工作，什么是管道呢？

> **六角形建筑**

如果你还没有，花几分钟阅读 Matias 关于这个设计模式的文章(你可以找到下面的链接)。

**域**

项目的核心是领域。这是与业务逻辑相关的数据结构存在的地方。代客的主域实体是*作业*。

作业只是封装了与将要运行的任务相关的所有元数据。诸如我们在标记为失败之前为特定作业设置的超时间隔、作业状态(是挂起、正在进行还是已完成)以及创建、开始或完成时间的时间戳等信息都是作业的一部分。

另一个主要实体是*管道*，它代表了需要以指定顺序一个接一个运行的作业序列。执行管道时，每个作业都可以选择使用前一个已完成作业的结果。

**端口(接口)**

代客需要两个“外部”系统才能正常运行。一个队列，用于实现其作业排队机制，一个存储系统，用于保存作业和/或管道的元数据及其结果。

在设计模式的术语中，队列和存储系统都是受驱动的角色。定义了两个端口来启用与参与者的交互，*作业队列* & *存储*。

对于像 CLI 工具或任何其他应用程序这样的驱动程序参与者，为了创建新的或管理现有的作业和管道，还定义了驱动程序参与者接口及其具体实现，即所谓的服务。

**适配器**

目前，该项目提供了 JobQueue 接口的三个具体实现。一个简单而轻量级的内存 FIFO 队列，

简单的内存 FIFO 队列实现。

一个 RabbitMQ 客户端，用于将服务与现有的消息代理连接起来；一个 Redis 客户端，利用`LPUSH`和`RPOP` Redis 命令，将 NoSQL 存储用作作业队列。

至于存储接口，提供了四个具体的实现，使服务成为许多环境的即插即用组件。内存中的键值存储，用于没有外部存储可用时或用于测试目的。关系存储系统支持 MySQL 和 PostgreSQL。最后，作为 NoSQL 代表的 Redis 也可以用于持久性，因为它有一个可用的适配器。

关于驱动参与者适配器，提供了支持 HTTP 和 gRPC 通信的处理程序实现。

**依赖注入**

按照这种方法构建项目布局的另一个主要优点是，我们可以在初始化不同的内部组件时利用依赖注入。这也涉及到工厂模式的使用。

使用工厂模式初始化适配器。

依赖注入来初始化服务。

> **并发**

运行任务的内部组件是一个基本的工人池实现。可用工作线程的数量以及工作线程池内部队列都是可配置的。

初始化可配置数量的员工。

每个工作者监听这个内部队列，等待要完成的工作，消费消息，并执行工作。

Worker 侦听 worker pool 队列中的工作。

在流水线的情况下，所有的任务都由同一个工人执行，因为他们必须等待每个任务完成，然后才能继续下一个任务。

> **运行任务**

处理用户定义的函数可能很棘手。最好的情况是函数成功运行，或者甚至产生一个错误值，这是意料之中的，它的消息将与任何结果元数据一起保存。但是函数很容易引入死锁，导致永久等待，当然还有资源泄漏。它也可以快乐地恐慌。

在围棋中，恐慌是个例外。然而，它足以将其错误堆栈跟踪传播到执行的主线程，并破坏整个进程。对于一个至少需要运行数百个功能的服务，我们当然负担不起这样的费用！我们必须像处理普通事件一样处理恐慌。我们可以通过利用内置的`recover()`函数来做到这一点。一个匿名的`func`被延迟来检查是否发生了紧急情况，提取紧急消息，并通过一个通道将其作为一个作业结果发送，该作业结果将在我们的持久层中结束。

负责任务执行的 go-routine。

至于潜在的死锁，我们能做的不多，至少用这个简单而不复杂的方法。我们可以为任务设置一个超时间隔，而不是试图在死锁条件下停止正在运行的 go-routine。这样，在出现死锁的情况下，我们仍然会损失一些资源，但是我们应该能够继续服务于其他任务，而不是永远等待有问题的任务结束。毕竟，在将它们注册为服务中的任务之前，由用户来测试他们自己的功能的行为。

等待作业结果或超时，以先出现的为准。

> **Go 模块**

最初的想法是将*代客*作为`cmd`提供，这样我们就可以构建和扩展 Docker 容器并开始使用它。使用这种方法，我们必须下载项目的源代码，并将我们的任务函数放在项目的特定目录中。从那里，我们要么有一些脚本来解析我们的源文件，并在构建可执行文件之前通过修改 *valet* 源代码的某个部分来注册任务，要么我们必须自己完成。那将是既乏味又容易出错的。最糟糕的是，我们必须在两个地方维护这些功能，一个是我们的仓库，另一个是*代客*仓库。

为了让每个人都更容易，该服务作为 Go 模块提供。您可以在存储库下维护您的任务函数，并通过实现一个简单的`main`函数来构建您自己的可执行文件副本，如下所示。

一个主函数的例子，需要建立自己的代客 cmd。

在相应的[自述文件](https://github.com/svaloumas/valet#installation)部分找到完整的安装指南。

> **参考文献**

*   [https://medium . com/@ matiasvarela/hexagon-architecture-in-go-CFD 4 e 436 FAA 3](https://medium.com/@matiasvarela/hexagonal-architecture-in-go-cfd4e436faa3)
*   [https://vaadin.com/learn/tutorials/ddd/ddd_and_hexagonal](https://vaadin.com/learn/tutorials/ddd/ddd_and_hexagonal)
*   【https://github.com/mitchellh/mapstructure 号