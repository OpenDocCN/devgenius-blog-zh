<html>
<head>
<title>How To Better Poll APIs in React?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在 React 中更好的轮询 API？</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-to-better-poll-apis-in-react-312bddc604a4?source=collection_archive---------0-----------------------#2022-07-06">https://blog.devgenius.io/how-to-better-poll-apis-in-react-312bddc604a4?source=collection_archive---------0-----------------------#2022-07-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c14b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">setInterval 的替代方案，是一个更好的间隔调用异步方法的解决方案</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/8115cbfa2c5cbed0e2c80b6063b8ab7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8hwpt4VG4TGaPvIt"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@agebarros?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">阿格巴洛斯</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="84ea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在 web 开发中，我们可能需要不断地轮询后端 API，以获取最新的数据来更新页面。虽然 WebSocket 是一个更好的选择，但是在某些情况下轮询也可以。</p><p id="8c89" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那么在 React 里怎么做呢？</p><h1 id="7c0c" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">设置间隔</h1><p id="4b3b" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我们可以使用 setInterval 连续执行异步方法，这可能是最简单的解决方案。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="8bcd" class="mu lt iq mq b gy mv mw l mx my">const App = () =&gt; {<br/>  const [origin, setOrigin] = useState('');</span><span id="fb4c" class="mu lt iq mq b gy mz mw l mx my">  const updateState = useCallback(async () =&gt; {<br/>    const response = await fetch('<a class="ae kv" href="https://httpbin.org/get'" rel="noopener ugc nofollow" target="_blank">https://httpbin.org/get'</a>);<br/>    const data = await response.json();<br/>    setOrigin(data?.origin ?? '');<br/>  }, []);</span><span id="006b" class="mu lt iq mq b gy mz mw l mx my">  useEffect(() =&gt; {<br/>    setInterval(updateState, 3000);<br/>  }, [updateState]);</span><span id="e419" class="mu lt iq mq b gy mz mw l mx my">  return &lt;main&gt;{`Your origin is: ${origin}`}&lt;/main&gt;;<br/>};</span></pre><p id="9a32" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是这种解决方案存在一些问题。首先<code class="fe na nb nc mq b">setInterval</code>不准确，原因你可以查一下我的这篇文章:</p><div class="nd ne gp gr nf ng"><a href="https://blog.bitsrc.io/how-to-get-an-accurate-setinterval-in-javascript-ca7623d1d26a" rel="noopener  ugc nofollow" target="_blank"><div class="nh ab fo"><div class="ni ab nj cl cj nk"><h2 class="bd ir gy z fp nl fr fs nm fu fw ip bi translated">如何在 JavaScript 中获得准确的倒计时</h2><div class="nn l"><h3 class="bd b gy z fp nl fr fs nm fu fw dk translated">为什么 setInterval 不准确？</h3></div><div class="no l"><p class="bd b dl z fp nl fr fs nm fu fw dk translated">blog.bitsrc.io</p></div></div><div class="np l"><div class="nq l nr ns nt np nu kp ng"/></div></div></a></div><p id="ab9b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第二，它的粒度不好控制，而且造成浪费。例如，对于一个响应时间很长的 API 请求，页面上最后一个响应的内容还没有更新，下一个请求会再次发送。</p><p id="2292" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这并不理想。</p><h1 id="a229" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">设置超时+异步…等待</h1><p id="b9e9" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我们可以使用<code class="fe na nb nc mq b">setTimeout</code>和<code class="fe na nb nc mq b">async...await</code>来实现一个定制的钩子:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="d76e" class="mu lt iq mq b gy mv mw l mx my">const useIntervalAsync = (fn: () =&gt; Promise&lt;unknown&gt;, ms: number) =&gt; {<br/>  const timeout = useRef&lt;number&gt;();</span><span id="1649" class="mu lt iq mq b gy mz mw l mx my">  const run = useCallback(async () =&gt; {<br/>    await fn();<br/>    timeout.current = window.setTimeout(run, ms);<br/>  }, [fn, ms]);</span><span id="9f42" class="mu lt iq mq b gy mz mw l mx my">  useEffect(() =&gt; {<br/>    run();<br/>    return () =&gt; {<br/>      window.clearTimeout(timeout.current);<br/>    };<br/>  }, [run]);<br/>};</span></pre><p id="18ed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，它是这样使用的:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="025f" class="mu lt iq mq b gy mv mw l mx my">const App = () =&gt; {<br/>  const [origin, setOrigin] = useState('');</span><span id="7f93" class="mu lt iq mq b gy mz mw l mx my">  const updateState = useCallback(async () =&gt; {<br/>    const response = await fetch('<a class="ae kv" href="https://httpbin.org/get'" rel="noopener ugc nofollow" target="_blank">https://httpbin.org/get'</a>);<br/>    const data = await response.json();<br/>    setOrigin(data?.origin ?? '');<br/>  }, []);</span><span id="bcf6" class="mu lt iq mq b gy mz mw l mx my">  useIntervalAsync(updateState, 3000);</span><span id="4740" class="mu lt iq mq b gy mz mw l mx my">  return &lt;main&gt;{`Your origin is: ${origin}`}&lt;/main&gt;;<br/>};</span></pre><p id="e12b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个解决方案使用<code class="fe na nb nc mq b">async...await</code>和<code class="fe na nb nc mq b">setTimeout</code>来确保异步任务在下一个调度任务之前完成。并在<code class="fe na nb nc mq b">useEffect</code>的清理阶段清理下一个调度任务。</p><p id="8861" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是异步任务总是很棘手。设想一种情况:如果使用这个钩子的组件在等待异步响应时被卸载，那么这个定时任务将总是在后台运行。这是一个严重的错误，我们可以通过记录挂载状态来避免它。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="cade" class="mu lt iq mq b gy mv mw l mx my">const useIntervalAsync = (fn: () =&gt; Promise&lt;unknown&gt;, ms: number) =&gt; {<br/>  const timeout = useRef&lt;number&gt;();<br/>  const mountedRef = useRef(false);</span><span id="08c0" class="mu lt iq mq b gy mz mw l mx my">  const run = useCallback(async () =&gt; {<br/>    await fn();<br/>    if (mountedRef.current) {<br/>      timeout.current = window.setTimeout(run, ms);<br/>    }<br/>  }, [fn, ms]);</span><span id="4af7" class="mu lt iq mq b gy mz mw l mx my">  useEffect(() =&gt; {<br/>    mountedRef.current = true;<br/>    run();</span><span id="e096" class="mu lt iq mq b gy mz mw l mx my">  return () =&gt; {<br/>      mountedRef.current = false;<br/>      window.clearTimeout(timeout.current);<br/>    };<br/>  }, [run]);<br/>};</span></pre><p id="381c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个 bug 可以通过记录<code class="fe na nb nc mq b">mountedRef</code>的挂载状态来避免。很简单，没错，但其实很实用，当然你也可以把挂载状态做成自定义钩子重用。例如下面的<code class="fe na nb nc mq b">useMountedState</code>:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="17c1" class="mu lt iq mq b gy mv mw l mx my">import { useCallback, useEffect, useRef } from 'react';</span><span id="d6de" class="mu lt iq mq b gy mz mw l mx my">const useMountedState = () =&gt; {<br/>  const mountedRef = useRef(false);<br/>  const getState = useCallback(() =&gt; mountedRef.current, []);</span><span id="6635" class="mu lt iq mq b gy mz mw l mx my">  useEffect(() =&gt; {<br/>    mountedRef.current = true;</span><span id="84db" class="mu lt iq mq b gy mz mw l mx my">  return () =&gt; {<br/>      mountedRef.current = false;<br/>    };<br/>  }, []);</span><span id="e369" class="mu lt iq mq b gy mz mw l mx my">  return getState;<br/>};</span><span id="7f87" class="mu lt iq mq b gy mz mw l mx my">export default useMountedState;</span></pre><h1 id="add8" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">复杂情况</h1><p id="76af" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在一些更复杂的情况下，我们可能需要主动更新页面信息。例如，在一些交互之后，我期望立即调用<code class="fe na nb nc mq b">updateState</code>来更新页面上的最新数据。</p><p id="8bf4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当然我可以直接调用<code class="fe na nb nc mq b">updateState</code>，但是下一个预定的任务可能会执行的很快，很浪费。所以我们可以给<code class="fe na nb nc mq b">useIntervalAsync</code>添加特性，让它支持 flushing。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="cb36" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以看到我们添加了<code class="fe na nb nc mq b">flush</code>方法。其内部逻辑是取消下一个调度任务，直接执行<code class="fe na nb nc mq b">run</code>方法。</p><p id="0198" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是我们加了一个<code class="fe na nb nc mq b">runningCount</code>，这是为了什么？</p><p id="34d9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">设想一种情况:当钩子内部以正常的逻辑间隔执行<code class="fe na nb nc mq b">run</code>函数，而异步响应正在等待解决时，外部调用<code class="fe na nb nc mq b">flush</code>期望立即执行，然后<code class="fe na nb nc mq b">run</code>会再次执行。这是因为上一个<code class="fe na nb nc mq b">run</code>还没有解决，最新的调度任务还没有创建，所以不能取消。</p><p id="89c8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">也就是说，此时有两个<code class="fe na nb nc mq b">run</code>函数正在被执行，虽然这并不关键，但是如果我们还是用之前的逻辑，那么这两个<code class="fe na nb nc mq b">run</code>在被解析后会创建两个定时任务。这导致了更大的浪费。</p><p id="8b5b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以我们可以使用<code class="fe na nb nc mq b">runningCount</code>来记录当前的执行次数，并在<code class="fe na nb nc mq b">next</code>函数中确保只有当<code class="fe na nb nc mq b">runningCount</code>为<code class="fe na nb nc mq b">0</code>时才创建一个新的调度任务。</p><p id="8627" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，通过 TypeScript 的泛型，我们可以很容易地包装原始函数，以适应更多的情况。一个简单的例子:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="3748" class="mu lt iq mq b gy mv mw l mx my">const App = () =&gt; {<br/>  const [origin, setOrigin] = useState('');</span><span id="1806" class="mu lt iq mq b gy mz mw l mx my">  const updateState = useCallback(async () =&gt; {<br/>    const response = await fetch('<a class="ae kv" href="https://httpbin.org/get'" rel="noopener ugc nofollow" target="_blank">https://httpbin.org/get'</a>);<br/>    const data = await response.json();<br/>    setOrigin(data?.origin ?? '');<br/>  }, []);</span><span id="9399" class="mu lt iq mq b gy mz mw l mx my">  const update = useIntervalAsync(updateState, 3000);</span><span id="c5db" class="mu lt iq mq b gy mz mw l mx my">  return (<br/>    &lt;main&gt;<br/>      &lt;div&gt;{`Your origin is: ${origin}`}&lt;/div&gt;<br/>      &lt;button onClick={update}&gt;update&lt;/button&gt;<br/>    &lt;/main&gt;<br/>  );<br/>};</span></pre><h1 id="9a7d" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结论</h1><p id="569d" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">处理异步任务总是很棘手，我们可能需要小心不要出错。希望这篇文章对你有帮助。</p><p id="acb3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你对今天的内容有什么想法，请留下你的评论。</p></div><div class="ab cl nx ny hu nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="ij ik il im in"><p id="f753" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="oe">感谢阅读。如果你喜欢这样的故事，想支持我，请考虑成为</em> <a class="ae kv" href="https://medium.com/@islizeqiang/membership" rel="noopener"> <em class="oe">中会员</em> </a> <em class="oe">。每月 5 美元，你可以无限制地访问媒体内容。如果你通过</em> <a class="ae kv" href="https://medium.com/@islizeqiang/membership" rel="noopener"> <em class="oe">我的链接</em> </a> <em class="oe">报名，我会得到一点佣金。</em></p><p id="4cda" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你的支持对我来说很重要——谢谢。</p></div></div>    
</body>
</html>