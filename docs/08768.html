<html>
<head>
<title>Application Of Singleton and Delegated Properties</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">单一属性和委托属性的应用</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/application-of-singleton-and-delegated-properties-d8ddd18bc7b3?source=collection_archive---------1-----------------------#2022-07-09">https://blog.devgenius.io/application-of-singleton-and-delegated-properties-d8ddd18bc7b3?source=collection_archive---------1-----------------------#2022-07-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="0bf1" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">让我们通过学习 Singleton 和 Delegates 属性来实现数据库。</h2></div><p id="ef16" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在 Android 中创建单例类的一个简单方法是:</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lb"><img src="../Images/035ecb92584f519c400dd0271b74f669.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Yg9TYOjjxgVYKsTl"/></div></div></figure><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi ln"><img src="../Images/2d555a14bb964e5e62e6d3b682610f86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DjNIfE0Zo9zzgXA2J_2e5Q.png"/></div></div></figure><p id="e2d2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们知道在<strong class="kh ir"> onCreate </strong> invoke 之前，我们不会使用实例，所以实例总是不可空的。</p><p id="e92e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个解决方案似乎有点怪异。我们需要定义一个属性，然后定义一个函数来返回该属性。</p><p id="8423" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有别的方法得到类似的结果吗？是的，我们可以将一个属性的值委托给另一个类。这些就是俗称的<strong class="kh ir">委托属性</strong>。</p><p id="5c0b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在一个属性中有一些我们可能需要的常见行为会很有趣地被重用，比如<strong class="kh ir">懒惰</strong>T6】值或者<strong class="kh ir">可观察</strong>T10】属性。Kotlin 提供了一种方法，将一个属性需要的代码委托给另一个类，而不是重复声明相同的代码。这就是所谓的<strong class="kh ir"> <em class="lo">委托属性</em> </strong>。</p><p id="6f7a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们使用从属性中获取或设置时，调用<strong class="kh ir">委托属性</strong>的<strong class="kh ir"> getValue </strong>和<strong class="kh ir"> setValue </strong>。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lp"><img src="../Images/4edb3e2aca723163c561339dbf49c89f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N4AMiN1WPOJYxKr6ey52kA.png"/></div></div></figure><p id="d0bf" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">T 是委托其行为的属性类型。<em class="lo"> getValue </em>函数接收对类的引用和属性的元数据。<em class="lo">设置值</em>功能也接收正在分配的值。如果属性是不可变的(<strong class="kh ir"> <em class="lo"> Val </em> </strong>)，那么只会需要<em class="lo"> getValue </em>函数。这是属性委托的分配方式:</p><blockquote class="lq lr ls"><p id="0b6f" class="kf kg lo kh b ki kj jr kk kl km ju kn lt kp kq kr lu kt ku kv lv kx ky kz la ij bi translated"><strong class="kh ir">类示例{ var p: String by Delegate() } </strong></p></blockquote><p id="032b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">标准代表</strong></p><p id="5157" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Kotlin 标准库中包含一组<strong class="kh ir">标准委托</strong>。这些是委托非常有用的最常见的情况，但是我们也可以创建自己的委托。</p><p id="609d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">懒惰</strong></p><p id="0390" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它需要一个在第一次调用<strong class="kh ir"> getValue </strong>时执行的 lambda，所以属性的初始化被延迟到那个时刻。后续调用将返回相同的值。这对于那些并不总是必需的和/或需要一些其他部件在这个部件被使用之前准备好的东西来说是非常有趣的。我们可以节省内存并跳过初始化，直到需要该属性。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lw"><img src="../Images/52441e11b49a2eed657cd33064f628db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*flFkEhyzyGF4lwzb8xKQOQ.png"/></div></div></figure><p id="acbb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">默认情况下，惰性属性的计算是<em class="lo"> synchronized </em>:该值只在一个线程中计算，但是所有线程都会看到相同的值。如果不需要初始化委托的同步来允许多个线程同时执行它，则将<code class="fe lx ly lz ma b">LazyThreadSafetyMode.PUBLICATION</code>作为参数传递给<code class="fe lx ly lz ma b">lazy()</code>。</p><p id="e475" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你确定初始化总是发生在使用属性的线程中，你可以使用<code class="fe lx ly lz ma b">LazyThreadSafetyMode.NONE</code>。它不会产生任何线程安全保证和相关的开销。</p><p id="8699" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">可观察的</strong></p><p id="f706" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个<strong class="kh ir">委托</strong>将帮助我们检测我们需要观察的任何属性的变化。每次调用 set 函数时，它都会执行我们指定的 lambda 表达式。因此，在新值被赋值后，我们接收到<strong class="kh ir">委托属性、</strong>旧的<strong class="kh ir">值和<strong class="kh ir">新的</strong>值。</strong></p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi mb"><img src="../Images/9758dd90a25404be9d3212c90d77e0d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MVH8COr-smNTDGMI1jl6tg.png"/></div></div></figure><p id="aeb5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个例子代表了某种 ViewModel 类，它知道我的属性更改，并在每次分配新值时将它们保存到数据库中。</p><p id="e1a7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">可否决</strong></p><p id="604e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是一种特殊的可观察值，让您决定是否必须保存该值。它可用于在保存值之前检查某些条件。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi mc"><img src="../Images/9377bcc8f58cfb807008b69405146698.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ylwt5_qOuNLSmB0RHX03Cw.png"/></div></div></figure><h1 id="ba92" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">在地图中存储属性</h1><p id="daa4" class="pw-post-body-paragraph kf kg iq kh b ki mv jr kk kl mw ju kn ko mx kq kr ks my ku kv kw mz ky kz la ij bi translated">一个日常用例是在一个<strong class="kh ir">地图</strong>中存储属性值。这经常出现在应用程序中，比如解析 JSON 或者执行其他动态任务。在这种情况下，您可以使用映射实例作为委托属性的委托。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi na"><img src="../Images/7801de91ad64240e32c8bc5dd0e7400e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zX9TRr1Sef6p_kj8tlHTTQ.png"/></div></div></figure><p id="2737" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在此示例中，构造函数获取一个地图:</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi nb"><img src="../Images/05433b6ee198ef6f533f7d6c622265d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nqlrdIxL9T87P7MkkhI1nQ.png"/></div></div></figure><p id="b820" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">委派属性通过与属性名称相关联的字符串键从该映射中获取值:</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi nc"><img src="../Images/4c05c577f8b935099f23fc9e2c3152b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8-6-7_gbdU27HzD16TaATA.png"/></div></div></figure><p id="d204" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你使用一个<code class="fe lx ly lz ma b">MutableMap</code>而不是一个只读的<code class="fe lx ly lz ma b">Map</code>，这也适用于<code class="fe lx ly lz ma b">var</code>的属性:</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi nd"><img src="../Images/88d0c161b2f3961b18b5a9efa7b11404.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2T7jcXdMjes9HwD72le16Q.png"/></div></div></figure><p id="5b28" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">如何创建自定义代表</strong></p><p id="ec93" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">比方说，我们想要创建一个只能赋值一次的不可空委托。第二次赋值时，会抛出异常。Kotlin 库提供了我们的委托必须实现的两个接口:ReadOnlyProperty 和 ReadWriteProperty。应该使用哪一个取决于委托的属性是 val 还是 var。</p><p id="4a8c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以在 Android 视图绑定中创建<a class="ae ne" href="https://medium.com/@dev.soni04/get-rid-of-lateinit-var-when-using-databinding-e9e8c9d6c559" rel="noopener">自定义委托属性</a>来消除绑定中的<strong class="kh ir"> lateinit var </strong>。</p><div class="nf ng gp gr nh ni"><a href="https://medium.com/@dev.soni04/get-rid-of-lateinit-var-when-using-databinding-e9e8c9d6c559" rel="noopener follow" target="_blank"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd ir gy z fp nn fr fs no fu fw ip bi translated">使用数据绑定时删除 lateinit 变量</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">让我们先来谈谈活动绑定类:</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">medium.com</p></div></div><div class="nr l"><div class="ns l nt nu nv nr nw ll ni"/></div></div></a></div><p id="fc16" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以做的第一件事是创建一个扩展 ReadWriteProperty 的类:</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi nx"><img src="../Images/4f88e5c66c87fb5782c32abab5d1a4d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N80L68q5N3CR3LqlMzWZEQ.png"/></div></div></figure><p id="ca59" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个<strong class="kh ir">委托</strong>可以处理任何<strong class="kh ir">不可空的</strong>类型。它将接收任何类型对象的引用，并使用<strong class="kh ir"> T </strong>作为 getter 和 setter 的类型。</p><p id="85ac" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们需要实现这些方法。</p><ul class=""><li id="5305" class="ny nz iq kh b ki kj kl km ko oa ks ob kw oc la od oe of og bi translated">如果被赋值的话，<strong class="kh ir"> getter </strong>将返回一个值，否则将抛出一个<strong class="kh ir">异常</strong>。</li><li id="a738" class="ny nz iq kh b ki oh kl oi ko oj ks ok kw ol la od oe of og bi translated"><strong class="kh ir">设置器</strong>将赋值给仍然为空的值，否则将抛出<strong class="kh ir">异常</strong>。</li></ul><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi nx"><img src="../Images/767cc7503d988b5d25e16115102c2e4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AFaECSTtSJIzYHWP2VHhrg.png"/></div></div></figure><p id="44ab" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们创建一个对象，该对象具有一个提供新委托的函数:</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi om"><img src="../Images/be9a4235d6b7bb8d208bbe19db0ac4d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SLU6EMSIGC8Wy73DLi5Xiw.png"/></div></div></figure><blockquote class="lq lr ls"><p id="2fa3" class="kf kg lo kh b ki kj jr kk kl km ju kn lt kp kq kr lu kt ku kv lv kx ky kz la ij bi translated">现在让我们使用自定义委托创建一个 App 类的对象:<br/> <strong class="kh ir"> var 实例:App by delegates XT . notnullsinglevalue()</strong></p></blockquote><p id="de2a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就是这样。感谢阅读；请不要忘记鼓掌并关注关于高级<strong class="kh ir"> kotlin </strong>的新文章。</p><p id="1a2b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">敬请关注…</p><div class="nf ng gp gr nh ni"><a rel="noopener  ugc nofollow" target="_blank" href="/abstraction-in-modern-world-54022c477912"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd ir gy z fp nn fr fs no fu fw ip bi translated">现代世界中的抽象</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">本文将定义如何在 Kotlin 世界中准确地使用现代世界中的抽象。</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">blog.devgenius.io</p></div></div><div class="nr l"><div class="on l nt nu nv nr nw ll ni"/></div></div></a></div><div class="nf ng gp gr nh ni"><a href="https://medium.com/subscribe/@dev.soni04" rel="noopener follow" target="_blank"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd ir gy z fp nn fr fs no fu fw ip bi translated">每当 Dev Soni 发布时收到一封电子邮件。</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">每当 Dev Soni 发布时收到一封电子邮件。注册后，如果您还没有，您将创建一个中型帐户…</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">medium.com</p></div></div><div class="nr l"><div class="oo l nt nu nv nr nw ll ni"/></div></div></a></div><p id="40f5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">给我买一杯<a class="ae ne" href="https://www.buymeacoffee.com/devsoni044" rel="noopener ugc nofollow" target="_blank">咖啡</a></p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi op"><img src="../Images/b9e5d7ac1011ea0586a4fa1894a61730.png" data-original-src="https://miro.medium.com/v2/resize:fit:620/0*25SgvRyaN7WZKUrd.gif"/></div></figure></div></div>    
</body>
</html>