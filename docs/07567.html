<html>
<head>
<title>React just turned 18! 18 things you must know!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React 刚满 18 岁！你必须知道的 18 件事！</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/react-just-turned-18-18-things-you-must-know-32672e141f0f?source=collection_archive---------3-----------------------#2022-04-06">https://blog.devgenius.io/react-just-turned-18-18-things-you-must-know-32672e141f0f?source=collection_archive---------3-----------------------#2022-04-06</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/7ddf0cbbf4a48a104411673c6117bf16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IEotr8fY1EKbXVyp"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">由<a class="ae jz" href="https://unsplash.com/@_andreamin?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">安德里亚·米尼尼</a>在<a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><p id="f8ff" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi ky translated">刚刚发布的 eact 18 这里列出了你需要知道的一切，以及更多！React 的团队已经做出了一些定义性和根本性的改变，这些改变将塑造 React 在这个版本之后的发展道路。其中包括一些重要的变化和许多新的 API。</p><h2 id="c21c" class="lh li in bd lj lk ll dn lm ln lo dp lp kl lq lr ls kp lt lu lv kt lw lx ly lz bi translated"><strong class="ak"> 1。安装。</strong></h2><p id="3b75" class="pw-post-body-paragraph ka kb in kc b kd ma kf kg kh mb kj kk kl mc kn ko kp md kr ks kt me kv kw kx ig bi translated">安装新的 React18 真的很容易。</p><p id="acca" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果您正在使用<code class="fe mf mg mh mi b">npm</code>，则:</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="8b24" class="lh li in mi b gy mr ms l mt mu">npm install react react-dom</span></pre><p id="52b6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">或者如果你用的是纱线:</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="7482" class="lh li in mi b gy mr ms l mt mu">yarn add react react-dom</span></pre><p id="5e53" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你会在你的控制台上看到类似<code class="fe mf mg mh mi b">ReactDOM.render is no longer supported in React 18</code> <strong class="kc io"> </strong>的警告。</p><h2 id="357a" class="lh li in bd lj lk ll dn lm ln lo dp lp kl lq lr ls kp lt lu lv kt lw lx ly lz bi translated">2.升级客户端渲染 API</h2><p id="e5d5" class="pw-post-body-paragraph ka kb in kc b kd ma kf kg kh mb kj kk kl mc kn ko kp md kr ks kt me kv kw kx ig bi translated">上述错误可以在代码更新后得到解决</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="503f" class="lh li in mi b gy mr ms l mt mu">// React v17 and before<br/>import { render } from 'react-dom';<br/>const container = document.getElementById('app');<br/>render(&lt;App/&gt;, container);<br/><br/>// React v18<br/>import { createRoot } from 'react-dom/client';<br/>const container = document.getElementById('app');<br/>const root = createRoot(container);<br/>root.render(&lt;App/&gt;);</span></pre><p id="3598" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果您没有切换到新的 API，即使您安装了最新版本，您的应用程序也将继续运行 React 17。这个新的根 API 允许您享受 React18 的新实现细节，称为<strong class="kc io">并发 React。</strong></p><h2 id="6ce4" class="lh li in bd lj lk ll dn lm ln lo dp lp kl lq lr ls kp lt lu lv kt lw lx ly lz bi translated">3.并发反应</h2><p id="7f57" class="pw-post-body-paragraph ka kb in kc b kd ma kf kg kh mb kj kk kl mc kn ko kp md kr ks kt me kv kw kx ig bi translated"><strong class="kc io"> Concurrent React </strong>在 React 内部实现了一个软件开发的基本概念，称为<em class="mv">“并发”。</em>众所周知，JavaScript 是单线程语言。这意味着，如果你正在执行一个任务，它将阻塞线程，下一个任务不能开始，除非前一个任务已经完成。这就像你的父母让你吃完蔬菜再吃冰淇淋一样。😆</p><p id="51bd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是并发性允许您将这些任务分成更小的部分，并作为独立的任务无序地执行它们。这意味着，你可以吃 3 勺蔬菜，然后 1 勺冰淇淋，然后 2 勺蔬菜，等等。😜</p><h2 id="1d75" class="lh li in bd lj lk ll dn lm ln lo dp lp kl lq lr ls kp lt lu lv kt lw lx ly lz bi translated">4.渲染— React 17 及之前</h2><p id="38ff" class="pw-post-body-paragraph ka kb in kc b kd ma kf kg kh mb kj kk kl mc kn ko kp md kr ks kt me kv kw kx ig bi translated">在 React 17 之前，更新是在单个不间断的同步事务中呈现的。假设我们的应用程序中有以下功能。</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="41b4" class="lh li in mi b gy mr ms l mt mu">const renderPopup = () =&gt; {</span><span id="d400" class="lh li in mi b gy mw ms l mt mu">    setData(input.data);</span><span id="f878" class="lh li in mi b gy mw ms l mt mu">    setLoader(input.isEnabled);</span><span id="929a" class="lh li in mi b gy mw ms l mt mu">}</span></pre><p id="2a46" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">随着同步渲染，一旦<code class="fe mf mg mh mi b">setData</code>更新开始渲染，没有什么可以中断它，直到用户可以在屏幕上看到结果。只有在此之后，<code class="fe mf mg mh mi b">setLoader</code>才能执行渲染。</p><h2 id="1c69" class="lh li in bd lj lk ll dn lm ln lo dp lp kl lq lr ls kp lt lu lv kt lw lx ly lz bi translated">5.渲染-反应 18</h2><p id="d6a0" class="pw-post-body-paragraph ka kb in kc b kd ma kf kg kh mb kj kk kl mc kn ko kp md kr ks kt me kv kw kx ig bi translated">借助于<strong class="kc io">并发反应</strong>渲染是可中断的。有了新的并发 API React<strong class="kc io"/>可以开始呈现更新，在执行过程中停止，获取更紧急的更新，然后稍后继续。然而，React 保证即使渲染被中断，UI 也将保持一致。这意味着即使在大型渲染任务中，用户界面也可以立即响应用户输入，创造流畅的用户体验。非常类似于在中间放一勺冰淇淋，如果你认为这是一个更紧急的行动。</p><h2 id="e915" class="lh li in bd lj lk ll dn lm ln lo dp lp kl lq lr ls kp lt lu lv kt lw lx ly lz bi translated">6.官方特性#1:自动配料</h2><p id="7353" class="pw-post-body-paragraph ka kb in kc b kd ma kf kg kh mb kj kk kl mc kn ko kp md kr ks kt me kv kw kx ig bi translated">状态批处理就是将多个状态更新组合成一个单独的重新渲染，以获得更好的性能。让我们把注意力转移到上面的<code class="fe mf mg mh mi b">renderPopup</code>函数上。在 React 17 和之前的版本中，这两种不同的状态会一个接一个地触发两个独立的渲染。默认情况下，React 仅在 React 事件处理程序中进行批处理更新，而不在 promises、setTimeout、本机事件处理程序或任何其他事件中进行批处理更新。</p><p id="4603" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">使用 React 18，状态批处理将在任何处理程序中自动发生，无需任何代码更改。</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="c69c" class="lh li in mi b gy mr ms l mt mu">// Before<br/>setTimeout(() =&gt; {<br/>  setName(name);<br/>  setAge(18);<br/>  // React will render twice, one for each state update<br/>}, 300);<br/><br/>// After: updates inside of timeouts, promises,<br/>// or any other event are batched.`<br/>setTimeout(() =&gt; {<br/>  setName(name);<br/>  setAge(18);<br/>  // React will only re-render once at the end<br/>}, 300);</span></pre><h2 id="f2e2" class="lh li in bd lj lk ll dn lm ln lo dp lp kl lq lr ls kp lt lu lv kt lw lx ly lz bi translated">7.如何避免自动配料</h2><p id="7f34" class="pw-post-body-paragraph ka kb in kc b kd ma kf kg kh mb kj kk kl mc kn ko kp md kr ks kt me kv kw kx ig bi translated">如果您不希望在代码的某些部分使用批处理，您可以通过使用<code class="fe mf mg mh mi b">flushSync</code>退出:</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="dd4e" class="lh li in mi b gy mr ms l mt mu">import { flushSync } from 'react-dom';</span><span id="c3be" class="lh li in mi b gy mw ms l mt mu">function handleClick() {<br/>  flushSync(() =&gt; {<br/>    setName(name);<br/>  });<br/>  // React has updated the DOM by now<br/>  flushSync(() =&gt; {<br/>    setAge(18);<br/>  });<br/>  // React has updated the DOM by now<br/>}</span></pre><div class="mx my gp gr mz na"><a href="https://reactjs.org/docs/react-dom.html#flushsync" rel="noopener  ugc nofollow" target="_blank"><div class="nb ab fo"><div class="nc ab nd cl cj ne"><h2 class="bd io gy z fp nf fr fs ng fu fw im bi translated">反应</h2><div class="nh l"><h3 class="bd b gy z fp nf fr fs ng fu fw dk translated">react-dom 包提供了特定于 dom 的方法，可以在应用程序的顶层使用，也可以作为转义…</h3></div><div class="ni l"><p class="bd b dl z fp nf fr fs ng fu fw dk translated">reactjs.org</p></div></div><div class="nj l"><div class="nk l nl nm nn nj no jt na"/></div></div></a></div><h2 id="68d1" class="lh li in bd lj lk ll dn lm ln lo dp lp kl lq lr ls kp lt lu lv kt lw lx ly lz bi translated">8.官方功能#2:过渡</h2><p id="e5d0" class="pw-post-body-paragraph ka kb in kc b kd ma kf kg kh mb kj kk kl mc kn ko kp md kr ks kt me kv kw kx ig bi translated">React 中有两种类型的更新:</p><p id="8dd1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> a .紧急更新</strong> →通过输入、点击或按压触发的 DOM 更新需要在 DOM 上立即响应。</p><p id="0fa7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> b .过渡更新→ </strong> DOM 更新，如呈现用户可以等待查看的列表或演示组件。这是从一个视图到另一个视图的 UI 转换。</p><p id="fcc1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">借助 concurrent React，我们可以将紧急更新优先于过渡更新，这样用户就不会感到体验不佳。</p><h2 id="b001" class="lh li in bd lj lk ll dn lm ln lo dp lp kl lq lr ls kp lt lu lv kt lw lx ly lz bi translated">9.过渡 API</h2><p id="9c25" class="pw-post-body-paragraph ka kb in kc b kd ma kf kg kh mb kj kk kl mc kn ko kp md kr ks kt me kv kw kx ig bi translated"><code class="fe mf mg mh mi b">startTransition</code> API 让我们通知 React 哪些更新是<em class="mv">紧急</em>哪些是<em class="mv">转换</em>:</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="8cac" class="lh li in mi b gy mr ms l mt mu">import {startTransition} from 'react';</span><span id="c4ef" class="lh li in mi b gy mw ms l mt mu">// Urgent: Show what was typed<br/>setInputName(input);</span><span id="dc6e" class="lh li in mi b gy mw ms l mt mu">// Mark any state updates inside as transitions<br/>startTransition(() =&gt; {<br/>  setFilteredNames(input);<br/>});</span></pre><p id="c3af" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">包装在 startTransition 中的状态更新被认为是非紧急的，如果有更紧急的更新进来，就会被中断。如果一个过渡被用户中断，React 将抛出没有完成的陈旧渲染工作，只渲染最新的更新。</p><p id="12d6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你可以使用<code class="fe mf mg mh mi b">useTransition</code>作为钩子，或者在不能像类组件一样使用<code class="fe mf mg mh mi b">useTransition</code>的地方使用<code class="fe mf mg mh mi b">startTransition</code>函数。</p><h2 id="90a8" class="lh li in bd lj lk ll dn lm ln lo dp lp kl lq lr ls kp lt lu lv kt lw lx ly lz bi translated">10.如何实现 useTransition</h2><p id="0699" class="pw-post-body-paragraph ka kb in kc b kd ma kf kg kh mb kj kk kl mc kn ko kp md kr ks kt me kv kw kx ig bi translated"><code class="fe mf mg mh mi b">useTransition</code>是一个钩子，它返回<code class="fe mf mg mh mi b">startTransition</code>函数和一个<code class="fe mf mg mh mi b">isPending</code>值来跟踪挂起状态。</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="5f90" class="lh li in mi b gy mr ms l mt mu">const [isPending, startTransition] = useTransition();</span></pre><p id="9aa9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe mf mg mh mi b">startTransition</code>可如上例所述使用，而<code class="fe mf mg mh mi b">isPending</code>可用于显示加载器，指示过渡何时激活或完成。React 在下面提供了一个简单的例子。</p><div class="mx my gp gr mz na"><a href="https://reactjs.org/docs/hooks-reference.html#usetransition" rel="noopener  ugc nofollow" target="_blank"><div class="nb ab fo"><div class="nc ab nd cl cj ne"><h2 class="bd io gy z fp nf fr fs ng fu fw im bi translated">钩子 API 参考-反应</h2><div class="nh l"><h3 class="bd b gy z fp nf fr fs ng fu fw dk translated">钩子是 React 16.8 中的新增功能。它们允许您使用状态和其他 React 特性，而无需编写类。这个…</h3></div><div class="ni l"><p class="bd b dl z fp nf fr fs ng fu fw dk translated">reactjs.org</p></div></div><div class="nj l"><div class="np l nl nm nn nj no jt na"/></div></div></a></div><h2 id="1d2a" class="lh li in bd lj lk ll dn lm ln lo dp lp kl lq lr ls kp lt lu lv kt lw lx ly lz bi translated">11.如何实现 startTransition</h2><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="1177" class="lh li in mi b gy mr ms l mt mu">React.startTransition(callback)</span></pre><p id="1d51" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe mf mg mh mi b">startTransition</code>易于使用，工作原理与上述完全相同。</p><div class="mx my gp gr mz na"><a href="https://reactjs.org/docs/react-api.html#starttransition" rel="noopener  ugc nofollow" target="_blank"><div class="nb ab fo"><div class="nc ab nd cl cj ne"><h2 class="bd io gy z fp nf fr fs ng fu fw im bi translated">反应顶级 API -反应</h2><div class="nh l"><h3 class="bd b gy z fp nf fr fs ng fu fw dk translated">React 是 React 库的入口点。如果从一个标签加载 React，这些顶级 API 可以在…</h3></div><div class="ni l"><p class="bd b dl z fp nf fr fs ng fu fw dk translated">reactjs.org</p></div></div><div class="nj l"><div class="nq l nl nm nn nj no jt na"/></div></div></a></div><h2 id="48c4" class="lh li in bd lj lk ll dn lm ln lo dp lp kl lq lr ls kp lt lu lv kt lw lx ly lz bi translated">12.官方特性#3:对 SSR 的悬念支持</h2><p id="3c3e" class="pw-post-body-paragraph ka kb in kc b kd ma kf kg kh mb kj kk kl mc kn ko kp md kr ks kt me kv kw kx ig bi translated">悬疑以前支持用 React.lazy 进行代码拆分。使用 React 18，它在服务器上支持相同的功能。</p><blockquote class="nr ns nt"><p id="beb2" class="ka kb mv kc b kd ke kf kg kh ki kj kk nu km kn ko nv kq kr ks nw ku kv kw kx ig bi translated">在 React 18 中，我们在服务器上添加了对悬念的支持，并使用并发渲染功能扩展了它的功能。</p><p id="7403" class="ka kb mv kc b kd ke kf kg kh ki kj kk nu km kn ko nv kq kr ks nw ku kv kw kx ig bi translated">React 18 中的悬念与过渡 API 结合使用效果最佳。如果您在过渡期间暂停，React 将防止已经可见的内容被回退替换。相反，React 将延迟渲染，直到加载了足够的数据，以防止出现错误的加载状态。</p></blockquote><h2 id="a1db" class="lh li in bd lj lk ll dn lm ln lo dp lp kl lq lr ls kp lt lu lv kt lw lx ly lz bi translated">13.官方特性#4:新的 hook - useId</h2><p id="6146" class="pw-post-body-paragraph ka kb in kc b kd ma kf kg kh mb kj kk kl mc kn ko kp md kr ks kt me kv kw kx ig bi translated"><code class="fe mf mg mh mi b">useId</code>是一个钩子，用于生成跨服务器和客户端稳定的惟一 id。这个 ID 意味着 HTML 标签的<code class="fe mf mg mh mi b">id</code>属性，而不是 UUID 生成器。我们可以声明如下:</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="acda" class="lh li in mi b gy mr ms l mt mu">import { useId } from "react";</span><span id="cbf0" class="lh li in mi b gy mw ms l mt mu">const Name = useId();</span></pre><p id="7dce" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">并按如下方式使用:</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="e7dc" class="lh li in mi b gy mr ms l mt mu">&lt;div&gt;      <br/>   &lt;label htmlFor={Name}&gt;Name&lt;/label&gt;      <br/>   &lt;input type="text" id={Name} name="Name" /&gt; <br/>&lt;/div&gt;</span></pre><p id="1ddb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe mf mg mh mi b">useId</code>返回类似<code class="fe mf mg mh mi b">:r10:</code>的字符串</p><h2 id="d35a" class="lh li in bd lj lk ll dn lm ln lo dp lp kl lq lr ls kp lt lu lv kt lw lx ly lz bi translated">14.官方特性#5:新钩子——useDeferredValue</h2><p id="be87" class="pw-post-body-paragraph ka kb in kc b kd ma kf kg kh mb kj kk kl mc kn ko kp md kr ks kt me kv kw kx ig bi translated"><code class="fe mf mg mh mi b">useDeferredValue</code>与<code class="fe mf mg mh mi b">startTransition</code>非常相似，它允许你延迟重新渲染树的非紧急部分。由于没有固定的时间延迟，React 将在第一次渲染反映在屏幕上后立即尝试延迟渲染。延迟呈现是可中断的，不会阻止用户输入。</p><div class="mx my gp gr mz na"><a href="https://reactjs.org/docs/hooks-reference.html#usedeferredvalue" rel="noopener  ugc nofollow" target="_blank"><div class="nb ab fo"><div class="nc ab nd cl cj ne"><h2 class="bd io gy z fp nf fr fs ng fu fw im bi translated">钩子 API 参考-反应</h2><div class="nh l"><h3 class="bd b gy z fp nf fr fs ng fu fw dk translated">钩子是 React 16.8 中的新增功能。它们允许您使用状态和其他 React 特性，而无需编写类。这个…</h3></div><div class="ni l"><p class="bd b dl z fp nf fr fs ng fu fw dk translated">reactjs.org</p></div></div><div class="nj l"><div class="nx l nl nm nn nj no jt na"/></div></div></a></div><h2 id="8c55" class="lh li in bd lj lk ll dn lm ln lo dp lp kl lq lr ls kp lt lu lv kt lw lx ly lz bi translated">15.官方特性#6:库挂钩</h2><p id="6279" class="pw-post-body-paragraph ka kb in kc b kd ma kf kg kh mb kj kk kl mc kn ko kp md kr ks kt me kv kw kx ig bi translated">引入了一些像<code class="fe mf mg mh mi b">useSyncExternalStore, useInsertionEffect</code>这样的钩子，它们应该主要由库作者而不是普通开发人员使用。但是你总是可以多读一些关于他们的书来增强你的理解。</p><h2 id="6845" class="lh li in bd lj lk ll dn lm ln lo dp lp kl lq lr ls kp lt lu lv kt lw lx ly lz bi translated">16.突破性变化#1:</h2><p id="19a6" class="pw-post-body-paragraph ka kb in kc b kd ma kf kg kh mb kj kk kl mc kn ko kp md kr ks kt me kv kw kx ig bi translated">在这个版本中，React 将放弃对将于 2022 年停止支持的 Internet Explorer 的支持。此外，React now 依赖于现代浏览器的功能，如<code class="fe mf mg mh mi b">Promise</code>、<code class="fe mf mg mh mi b">Symbol</code>等。如果您支持旧的浏览器和设备，您应该考虑在您的捆绑应用程序中包含一个全局 polyfill。</p><h2 id="027a" class="lh li in bd lj lk ll dn lm ln lo dp lp kl lq lr ls kp lt lu lv kt lw lx ly lz bi translated">17.突破性变化#2:</h2><p id="dfdf" class="pw-post-body-paragraph ka kb in kc b kd ma kf kg kh mb kj kk kl mc kn ko kp md kr ks kt me kv kw kx ig bi translated">由于所有更新都将被自动批处理，无论它们来自何处，这可能会在您的应用程序中导致意外的行为。总是在产品发布之前进行测试！</p><h2 id="ac4f" class="lh li in bd lj lk ll dn lm ln lo dp lp kl lq lr ls kp lt lu lv kt lw lx ly lz bi translated">18.突破性变化#3:</h2><p id="b04d" class="pw-post-body-paragraph ka kb in kc b kd ma kf kg kh mb kj kk kl mc kn ko kp md kr ks kt me kv kw kx ig bi translated">一些重要的反对意见。请检查以下列表。</p><div class="mx my gp gr mz na"><a href="https://reactjs.org/blog/2022/03/08/react-18-upgrade-guide.html#deprecations" rel="noopener  ugc nofollow" target="_blank"><div class="nb ab fo"><div class="nc ab nd cl cj ne"><h2 class="bd io gy z fp nf fr fs ng fu fw im bi translated">如何升级到 React 18 - React 博客</h2><div class="nh l"><h3 class="bd b gy z fp nf fr fs ng fu fw dk translated">正如我们在发布会上分享的，React 18 引入了由我们新的并发渲染器支持的功能，并逐步…</h3></div><div class="ni l"><p class="bd b dl z fp nf fr fs ng fu fw dk translated">reactjs.org</p></div></div><div class="nj l"><div class="ny l nl nm nn nj no jt na"/></div></div></a></div><h1 id="d379" class="nz li in bd lj oa ob oc lm od oe of lp og oh oi ls oj ok ol lv om on oo ly op bi translated">结论</h1><p id="cc11" class="pw-post-body-paragraph ka kb in kc b kd ma kf kg kh mb kj kk kl mc kn ko kp md kr ks kt me kv kw kx ig bi translated">随着 React 18 在社区中被采用，我们将在这些基础上学习更多。最终，许多最佳实践将会出现，这将帮助我们编写更高效、更干净的代码。在不久的将来，我一定会写一篇同样的文章。如果你认为这篇文章对你有价值，请在<a class="ae jz" href="https://medium.com/@abhayganjoo" rel="noopener"> <strong class="kc io">中</strong> </a>关注和<strong class="kc io">订阅</strong>给我！</p><p id="3f3d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这篇文章中，我从 React 文档中引用了许多很棒的片段，所以不要忘记也去看看。此外，还有一些关于增强 React 应用程序性能的优秀文章👇</p><div class="mx my gp gr mz na"><a href="https://blog.bitsrc.io/how-to-make-your-react-application-even-faster-3efe9387cbb1" rel="noopener  ugc nofollow" target="_blank"><div class="nb ab fo"><div class="nc ab nd cl cj ne"><h2 class="bd io gy z fp nf fr fs ng fu fw im bi translated">我优化了我的 React 应用程序，让它变得更快</h2><div class="nh l"><h3 class="bd b gy z fp nf fr fs ng fu fw dk translated">今天，我们将深入探讨记忆化(有例子！).这是一个伟大的技术，帮助我们提高…</h3></div><div class="ni l"><p class="bd b dl z fp nf fr fs ng fu fw dk translated">blog.bitsrc.io</p></div></div><div class="nj l"><div class="oq l nl nm nn nj no jt na"/></div></div></a></div><div class="mx my gp gr mz na"><a href="https://javascript.plainenglish.io/the-abc-of-code-splitting-ebb7060ca704" rel="noopener  ugc nofollow" target="_blank"><div class="nb ab fo"><div class="nc ab nd cl cj ne"><h2 class="bd io gy z fp nf fr fs ng fu fw im bi translated">代码拆分的基础知识</h2><div class="nh l"><h3 class="bd b gy z fp nf fr fs ng fu fw dk translated">代码分割是优化 JavaScript/React 应用程序加载性能的绝佳工具。我们将实现这一点…</h3></div><div class="ni l"><p class="bd b dl z fp nf fr fs ng fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="nj l"><div class="or l nl nm nn nj no jt na"/></div></div></a></div><div class="mx my gp gr mz na"><a href="https://17.reactjs.org/docs/concurrent-mode-intro.html" rel="noopener  ugc nofollow" target="_blank"><div class="nb ab fo"><div class="nc ab nd cl cj ne"><h2 class="bd io gy z fp nf fr fs ng fu fw im bi translated">引入并发模式(实验)- React</h2><div class="nh l"><h3 class="bd b gy z fp nf fr fs ng fu fw dk translated">注意:这一页是关于稳定版本中还没有的实验性特性。它旨在早期…</h3></div><div class="ni l"><p class="bd b dl z fp nf fr fs ng fu fw dk translated">17.reactjs.org</p></div></div><div class="nj l"><div class="os l nl nm nn nj no jt na"/></div></div></a></div><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="609f" class="lh li in mi b gy mr ms l mt mu"><strong class="mi io">Want to Connect?</strong></span><span id="1154" class="lh li in mi b gy mw ms l mt mu">LinkedIn : <a class="ae jz" href="https://www.linkedin.com/in/abhayganjoo/" rel="noopener ugc nofollow" target="_blank">https://www.linkedin.com/in/abhayganjoo/</a></span></pre></div></div>    
</body>
</html>