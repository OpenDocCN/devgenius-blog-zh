<html>
<head>
<title>Object-Oriented Programming in Java — Method Overriding</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java 面向对象编程——方法覆盖</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/object-oriented-programming-in-java-method-overriding-ed5d4a4eb14e?source=collection_archive---------6-----------------------#2021-05-13">https://blog.devgenius.io/object-oriented-programming-in-java-method-overriding-ed5d4a4eb14e?source=collection_archive---------6-----------------------#2021-05-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="2ee5" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">简单介绍、实现、优点、限制、方法重写的规则以及方法重载和重写之间的区别</h2></div><h2 id="05cd" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">介绍</h2><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lb"><img src="../Images/63ad44846a99b61bae59a48f557e64f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DBcuSk7yu6Q-q2ey"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk translated">米歇尔·勒恩斯在<a class="ae lr" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><p id="e3fc" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma ko mb mc md ks me mf mg kw mh mi mj mk ij bi translated">在子类中重新定义父类方法的过程称为方法重写。换句话说，当子类提供由它的父类之一声明的方法的特定实现时，方法重写就发生了。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/1e674b0c5fc017e100140db84d2dc5e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:952/format:webp/0*CHnZmT4ew-fYC6gd.png"/></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk translated">具有两个特定形状类的形状类</figcaption></figure><p id="bb2d" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma ko mb mc md ks me mf mg kw mh mi mj mk ij bi translated">在这种情况下，Rectangle 和 Circle 类覆盖了 Shape 类的<strong class="lu ir"> getArea() </strong>方法。</p><p id="0e5b" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma ko mb mc md ks me mf mg kw mh mi mj mk ij bi translated">重写是为了让子类可以向父类已经提供的方法提供自己的实现。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/a602501950014906dcde42d0da1b89db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1196/format:webp/1*vsOYmLkzryLKK93tLz4aiA.png"/></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk translated">具有两个特定形状类的形状类</figcaption></figure><p id="30a5" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma ko mb mc md ks me mf mg kw mh mi mj mk ij bi translated">在这种情况下:</p><ol class=""><li id="f00b" class="mn mo iq lu b lv lw ly lz ko mp ks mq kw mr mk ms mt mu mv bi translated"><strong class="lu ir">父类</strong>中的方法被称为<strong class="lu ir">被覆盖的方法</strong>。</li><li id="64b9" class="mn mo iq lu b lv mw ly mx ko my ks mz kw na mk ms mt mu mv bi translated"><strong class="lu ir">覆盖方法</strong>是<strong class="lu ir">子类</strong>中的方法。</li></ol><h2 id="4fe4" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">履行</h2><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="21e8" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma ko mb mc md ks me mf mg kw mh mi mj mk ij bi translated">输出是</p><pre class="lc ld le lf gt nd ne nf ng aw nh bi"><span id="942b" class="kf kg iq ne b gy ni nj l nk nl">Area of the Circle: 12.56<br/>Area of the Rectangle: 4.0</span></pre><h2 id="ffc4" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">优势</h2><ol class=""><li id="212e" class="mn mo iq lu b lv nm ly nn ko no ks np kw nq mk ms mt mu mv bi translated">因为对象解析发生在运行时，所以它有助于基于父类或接口编写泛型代码。</li><li id="64f2" class="mn mo iq lu b lv mw ly mx ko my ks mz kw na mk ms mt mu mv bi translated">提供同一方法的多个实现，并可用于使用 super 关键字调用父类重写的方法。</li><li id="99af" class="mn mo iq lu b lv mw ly mx ko my ks mz kw na mk ms mt mu mv bi translated">定义一个类可以有什么行为，以及实现该行为的类将如何实现该行为。</li></ol><h2 id="c795" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">限制</h2><ol class=""><li id="4af9" class="mn mo iq lu b lv nm ly nn ko no ks np kw nq mk ms mt mu mv bi translated">静态方法不能被重写。</li><li id="66f8" class="mn mo iq lu b lv mw ly mx ko my ks mz kw na mk ms mt mu mv bi translated">我们无法重写构造函数。</li><li id="ebda" class="mn mo iq lu b lv mw ly mx ko my ks mz kw na mk ms mt mu mv bi translated">重写方法可能不会引发比被重写方法引发的异常更严重的已检查异常。</li><li id="3f20" class="mn mo iq lu b lv mw ly mx ko my ks mz kw na mk ms mt mu mv bi translated">不能降低被重写方法的可见性。</li><li id="d5d6" class="mn mo iq lu b lv mw ly mx ko my ks mz kw na mk ms mt mu mv bi translated">不可能重写无法继承的方法。</li></ol><h2 id="f58b" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">方法重写的规则</h2><ol class=""><li id="c5e2" class="mn mo iq lu b lv nm ly nn ko no ks np kw nq mk ms mt mu mv bi translated">论点单应该与被覆盖方法的相同。</li><li id="15a2" class="mn mo iq lu b lv mw ly mx ko my ks mz kw na mk ms mt mu mv bi translated">返回类型必须与超类的实际重写方法中声明的返回类型相同或为其子类型。</li><li id="2334" class="mn mo iq lu b lv mw ly mx ko my ks mz kw na mk ms mt mu mv bi translated">访问级别不能比被重写方法的访问级别更严格。举个例子:如果超类中的方法被声明为 public，那么子类中的重写方法既不能是 private 也不能是 protected。</li><li id="ea39" class="mn mo iq lu b lv mw ly mx ko my ks mz kw na mk ms mt mu mv bi translated">实例方法只有在子类继承它们时才能被覆盖。</li><li id="2952" class="mn mo iq lu b lv mw ly mx ko my ks mz kw na mk ms mt mu mv bi translated">不能重写已声明为 final 的方法。</li><li id="b49c" class="mn mo iq lu b lv mw ly mx ko my ks mz kw na mk ms mt mu mv bi translated">静态方法不能被重写，但可以被重新声明。</li><li id="16f6" class="mn mo iq lu b lv mw ly mx ko my ks mz kw na mk ms mt mu mv bi translated">如果一个方法不能被继承，它就不能被重写。</li><li id="6ee5" class="mn mo iq lu b lv mw ly mx ko my ks mz kw na mk ms mt mu mv bi translated">任何超类方法，如果没有被与实例超类相同的包中的子类声明为 private 或 final，都可以被与实例超类相同的包中的子类覆盖。</li><li id="4d6c" class="mn mo iq lu b lv mw ly mx ko my ks mz kw na mk ms mt mu mv bi translated">只有声明为 public 或 protected 的非 final 方法可以被不同包中的子类覆盖。</li><li id="2af9" class="mn mo iq lu b lv mw ly mx ko my ks mz kw na mk ms mt mu mv bi translated">无论被重写的方法是否引发异常，重写的方法都可以引发任何未检查的异常。另一方面，重写方法不应引发比被重写方法声明的异常更新或更广泛的检查异常。重写方法能够引发比被重写方法更窄或更少的异常。</li><li id="6d4f" class="mn mo iq lu b lv mw ly mx ko my ks mz kw na mk ms mt mu mv bi translated">构造函数是不可重写的。</li></ol><p id="4033" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma ko mb mc md ks me mf mg kw mh mi mj mk ij bi translated"><strong class="lu ir">最后一点提示:</strong><strong class="lu ir">super</strong>关键字在调用被覆盖方法的超类版本时使用。</p><h2 id="8f7b" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">方法的重载和重写之间的区别</h2><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="nb nc l"/></div></figure><h2 id="5a15" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">方法重载示例</h2><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="e06f" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma ko mb mc md ks me mf mg kw mh mi mj mk ij bi translated">这里我们有三个不同版本的<strong class="lu ir"> add() </strong>函数。在这种情况下，<strong class="lu ir"> add() </strong>函数被重载。</p><p id="d5bb" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma ko mb mc md ks me mf mg kw mh mi mj mk ij bi translated">你可以在我的上一篇文章中读到关于 Java 中面向对象编程的知识——多态性。</p><p id="c7dd" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma ko mb mc md ks me mf mg kw mh mi mj mk ij bi translated">希望这能有所帮助。也分享你的想法。</p></div></div>    
</body>
</html>