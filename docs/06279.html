<html>
<head>
<title>Optimizing the service response time by using MapReduce</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 MapReduce 优化服务响应时间</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/optimizing-the-service-response-time-by-using-mapreduce-d0379755072d?source=collection_archive---------7-----------------------#2021-12-27">https://blog.devgenius.io/optimizing-the-service-response-time-by-using-mapreduce-d0379755072d?source=collection_archive---------7-----------------------#2021-12-27</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/faccf3607049091532babe08587d2eca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AMVi7uhUXMaz2IwlNeqlKA.png"/></div></div></figure><p id="9ba0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们的服务达到大约 30 毫秒的平均延迟的主要先决条件之一是我们使用 MapReduce，它允许我们的服务调用许多服务，这通常取决于最慢请求的响应时间。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi kt"><img src="../Images/50afecb4d176f21731885d0511bff00d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QBWoY0G6qyZBXDRt"/></div></div></figure><p id="4f31" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对于您现有的服务，无需优化数据库操作、优化缓存或重写业务逻辑，只需通过 MapReduce 并行化正交(不相关)请求，您就可以显著减少服务响应时间。</p><p id="a805" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在本文中，我们将向您详细介绍 MapReduce 实现的细节。</p><h1 id="f425" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">为什么需要 MapReduce</h1><p id="b269" class="pw-post-body-paragraph jv jw in jx b jy lw ka kb kc lx ke kf kg ly ki kj kk lz km kn ko ma kq kr ks ig bi translated">在实际的业务场景中，我们经常需要从不同的 rpc 服务中获取相应的属性来组装复杂的对象。</p><p id="18b3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">例如，查询产品详细信息。</p><ol class=""><li id="8d39" class="mb mc in jx b jy jz kc kd kg md kk me ko mf ks mg mh mi mj bi translated">产品服务—查询产品属性</li><li id="147a" class="mb mc in jx b jy mk kc ml kg mm kk mn ko mo ks mg mh mi mj bi translated">库存服务—查询库存属性</li><li id="2c15" class="mb mc in jx b jy mk kc ml kg mm kk mn ko mo ks mg mh mi mj bi translated">价格服务-查询价格属性</li><li id="52c9" class="mb mc in jx b jy mk kc ml kg mm kk mn ko mo ks mg mh mi mj bi translated">营销服务—查询营销属性</li></ol><p id="1344" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果是串行调用，响应时间会随着 rpc 调用的次数线性增加，所以我们一般会将串行改为并行，以优化响应时间。</p><p id="ab1c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">使用<code class="fe mp mq mr ms b">WaitGroup</code>的简单场景也能满足需求，但是如果我们需要检查 rpc 调用返回的数据，数据处理转换，数据聚合呢？go-zero 实现了一个基于 MapReduce 架构的进程内数据批处理<code class="fe mp mq mr ms b">MapReduce</code>并发工具类。</p><h1 id="4918" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">设计理念</h1><p id="3d5e" class="pw-post-body-paragraph jv jw in jx b jy lw ka kb kc lx ke kf kg ly ki kj kk lz km kn ko ma kq kr ks ig bi translated">让我们试着站在作者的角度，为并发工具整理出可能的业务场景:</p><ol class=""><li id="7dbb" class="mb mc in jx b jy jz kc kd kg md kk me ko mf ks mg mh mi mj bi translated">查询产品详情:支持并发调用多个服务来组合产品属性，支持可以立即结束的调用错误。</li><li id="f4c2" class="mb mc in jx b jy mk kc ml kg mm kk mn ko mo ks mg mh mi mj bi translated">产品详情页自动推荐用户卡券:支持并发验证卡券，失败自动拒绝，全部退回。</li></ol><p id="5793" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">以上实际上是对输入数据进行处理，最后输出清洗后的数据。数据处理有一个非常经典的异步模式:生产者-消费者模式。所以我们可以抽象出数据批处理的生命周期，大致可以分为三个阶段。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mt"><img src="../Images/90ad21b8b36c36d426d7a8b5e85e8b86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*g09tlNJTeTDyxPTe"/></div></div></figure><ol class=""><li id="b70f" class="mb mc in jx b jy jz kc kd kg md kk me ko mf ks mg mh mi mj bi translated">数据生产生成</li><li id="ba3c" class="mb mc in jx b jy mk kc ml kg mm kk mn ko mo ks mg mh mi mj bi translated">数据处理映射器</li><li id="1410" class="mb mc in jx b jy mk kc ml kg mm kk mn ko mo ks mg mh mi mj bi translated">数据聚合缩减器</li></ol><p id="72b0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">数据产生是必不可少的阶段，数据处理和数据聚合是可选阶段，数据产生和处理支持并发调用，数据聚合基本上是纯内存操作，所以单个并发进程就可以完成。</p><p id="f884" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">由于数据处理的不同阶段是由不同的 go routine 执行的，因此自然要考虑使用通道来实现 go routine 之间的通信。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mt"><img src="../Images/287504adfcc18cbcc51825048711fcd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Uyj1KrJR5G1ouHbZ"/></div></div></figure><p id="0ae5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如何随时终止该进程？</p><p id="ea0e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">很简单，只需监听全局结束通道或 goroutine 中给定的上下文。</p><h1 id="a962" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">归零码实现</h1><p id="c1b4" class="pw-post-body-paragraph jv jw in jx b jy lw ka kb kc lx ke kf kg ly ki kj kk lz km kn ko ma kq kr ks ig bi translated"><code class="fe mp mq mr ms b">core/mr/mapreduce.go</code></p><h1 id="d0f2" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">必备知识—基本渠道使用</h1><p id="bcb2" class="pw-post-body-paragraph jv jw in jx b jy lw ka kb kc lx ke kf kg ly ki kj kk lz km kn ko ma kq kr ks ig bi translated">由于 MapReduce 源代码使用了很多通道进行通信，所以让我们来提一些基本的通道用法:</p><ul class=""><li id="ba56" class="mb mc in jx b jy jz kc kd kg md kk me ko mf ks mu mh mi mj bi translated">写完后记得关闭频道</li></ul><pre class="ku kv kw kx gt mv ms mw mx aw my bi"><span id="7741" class="mz kz in ms b gy na nb l nc nd">ch := make(<strong class="ms io">chan</strong> <strong class="ms io">interface</strong>{})<br/>// You need to actively close the channel when you finish writing<br/><strong class="ms io">defer</strong> <strong class="ms io">func</strong>() {<br/>    close(ch)<br/>}()<br/><strong class="ms io">go</strong> <strong class="ms io">func</strong>() {<br/>    // v,ok mode Read the channel<br/>    <strong class="ms io">for</strong> {<br/>        v, ok := &lt;-ch<br/>        <strong class="ms io">if</strong> !ok {<br/>            <strong class="ms io">return</strong><br/>        }<br/>        t.Log(v)<br/>    }</span><span id="c9e9" class="mz kz in ms b gy ne nb l nc nd">    // for range mode reads the channel, the channel closes the loop and exits automatically<br/>    <strong class="ms io">for</strong> i := <strong class="ms io">range</strong> ch {<br/>        t.Log(i)<br/>    }</span><span id="414c" class="mz kz in ms b gy ne nb l nc nd">    // Clear the channel, the channel close loop exits automatically<br/>    <strong class="ms io">for</strong> <strong class="ms io">range</strong> ch {<br/>    }<br/>}()<br/><strong class="ms io">for</strong> i := 0; i &lt; 10; i++ {<br/>    ch &lt;- i<br/>    time.Sleep(time.Second)<br/>}</span></pre><ul class=""><li id="9467" class="mb mc in jx b jy jz kc kd kg md kk me ko mf ks mu mh mi mj bi translated">封闭通道仍然支持读取</li><li id="024f" class="mb mc in jx b jy mk kc ml kg mm kk mn ko mo ks mu mh mi mj bi translated">限制通道读写权限</li></ul><pre class="ku kv kw kx gt mv ms mw mx aw my bi"><span id="b64d" class="mz kz in ms b gy na nb l nc nd">// Read-only channel<br/><strong class="ms io">func</strong> <strong class="ms io">readChan</strong>(rch &lt;-<strong class="ms io">chan</strong> <strong class="ms io">interface</strong>{}) {<br/>    <strong class="ms io">for</strong> i := <strong class="ms io">range</strong> rch {<br/>        log.Println(i)<br/>    }<br/>}</span><span id="7c55" class="mz kz in ms b gy ne nb l nc nd">// Write only the channel<br/><strong class="ms io">func</strong> <strong class="ms io">writeChan</strong>(wch <strong class="ms io">chan</strong>&lt;- <strong class="ms io">interface</strong>{}) {<br/>    wch &lt;- 1<br/>}</span></pre><h1 id="2fab" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">接口定义</h1><p id="f8e1" class="pw-post-body-paragraph jv jw in jx b jy lw ka kb kc lx ke kf kg ly ki kj kk lz km kn ko ma kq kr ks ig bi translated">让我们从三个核心函数定义开始。</p><ol class=""><li id="02f9" class="mb mc in jx b jy jz kc kd kg md kk me ko mf ks mg mh mi mj bi translated">数据生产</li><li id="e368" class="mb mc in jx b jy mk kc ml kg mm kk mn ko mo ks mg mh mi mj bi translated">数据处理</li><li id="4ae7" class="mb mc in jx b jy mk kc ml kg mm kk mn ko mo ks mg mh mi mj bi translated">数据聚合</li></ol><pre class="ku kv kw kx gt mv ms mw mx aw my bi"><span id="c2c1" class="mz kz in ms b gy na nb l nc nd">// data production func<br/>// source - data is produced and written to source<br/>GenerateFunc <strong class="ms io">func</strong>(source <strong class="ms io">chan</strong>&lt;- <strong class="ms io">interface</strong>{})</span><span id="32f3" class="mz kz in ms b gy ne nb l nc nd">// data processing func<br/>// item - the produced data<br/>// writer - call writer.Write() to pass the processed data backwards to the reducer<br/>// cancel - terminates the process func<br/>MapperFunc <strong class="ms io">func</strong>(item <strong class="ms io">interface</strong>{}, writer Writer, cancel <strong class="ms io">func</strong>(error))</span><span id="2563" class="mz kz in ms b gy ne nb l nc nd">// data aggregation func<br/>// pipe - the processed data<br/>// writer - call writer.Write() to return the aggregated data to the user<br/>// cancel - terminates the process func<br/>ReducerFunc <strong class="ms io">func</strong>(pipe &lt;-<strong class="ms io">chan</strong> <strong class="ms io">interface</strong>{}, writer Writer, cancel <strong class="ms io">func</strong>(error))</span></pre><h1 id="73e5" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">面向用户的方法定义</h1><p id="91de" class="pw-post-body-paragraph jv jw in jx b jy lw ka kb kc lx ke kf kg ly ki kj kk lz km kn ko ma kq kr ks ig bi translated"><a class="ae nf" href="https://go-zero.dev/cn/mapreduce.html" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io">用法可以查看官方文档，这里就不赘述了</strong> </a></p><p id="caab" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">面向用户的方法更多，方法分为两大类。</p><p id="9a8d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">不归</strong></p><ul class=""><li id="566f" class="mb mc in jx b jy jz kc kd kg md kk me ko mf ks mu mh mi mj bi translated">当出现错误时，执行过程立即终止</li><li id="ebd0" class="mb mc in jx b jy mk kc ml kg mm kk mn ko mo ks mu mh mi mj bi translated">执行过程不关注错误</li></ul><p id="fe7b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">带有返回值</strong></p><ul class=""><li id="d0fd" class="mb mc in jx b jy jz kc kd kg md kk me ko mf ks mu mh mi mj bi translated">手动写入源，手动读取聚合数据通道</li><li id="c5fa" class="mb mc in jx b jy mk kc ml kg mm kk mn ko mo ks mu mh mi mj bi translated">手动写入源，自动读取聚合数据通道</li><li id="54c3" class="mb mc in jx b jy mk kc ml kg mm kk mn ko mo ks mu mh mi mj bi translated">外部传递到源，自动读取聚合数据通道</li></ul><pre class="ku kv kw kx gt mv ms mw mx aw my bi"><span id="e850" class="mz kz in ms b gy na nb l nc nd">// Concurrent execution of func, any error will terminate the process immediately<br/><strong class="ms io">func</strong> <strong class="ms io">Finish</strong>(fns ... . <strong class="ms io">func</strong>() <strong class="ms io">error</strong>) <strong class="ms io">error</strong></span><span id="057d" class="mz kz in ms b gy ne nb l nc nd">// Execute func concurrently, even if an error occurs, the process will not be terminated<br/><strong class="ms io">func</strong> <strong class="ms io">FinishVoid</strong>(fns ... .<strong class="ms io">func</strong>())</span><span id="e05e" class="mz kz in ms b gy ne nb l nc nd">// requires the user to manually write the production data to the source, process the data and return a channel for reading<br/>// opts - optional parameter, currently contains: number of concurrent processes in the data processing phase<br/><strong class="ms io">func</strong> <strong class="ms io">Map</strong>(generate GenerateFunc, mapper MapFunc, opts . .Option)</span><span id="b1e2" class="mz kz in ms b gy ne nb l nc nd">// no return value, no focus on errors<br/><strong class="ms io">func</strong> <strong class="ms io">MapVoid</strong>(generate Generate GenerateFunc, mapper VoidMapFunc, opts . . Option)</span><span id="3303" class="mz kz in ms b gy ne nb l nc nd">// No return value, focus on errors<br/><strong class="ms io">func</strong> <strong class="ms io">MapReduceVoid</strong>(generate Generate GenerateFunc, mapper MapperFunc, reducer VoidReducerFunc, opts . . Option)</span><span id="15df" class="mz kz in ms b gy ne nb l nc nd">// requires the user to manually write the production data to source and return the aggregated data<br/>// generate produce<br/>// mapper processing<br/>// reducer aggregation<br/>// opts - optional parameter, currently contains: number of processors in the data processing phase<br/><strong class="ms io">func</strong> <strong class="ms io">MapReduce</strong>(generate Generate GenerateFunc, mapper MapperFunc, reducer ReducerFunc, opts . .Option) (<strong class="ms io">interface</strong>{}, error)</span><span id="a6fd" class="mz kz in ms b gy ne nb l nc nd">// Support passing in a data source channel and returning the aggregated data<br/>// source - the data source channel<br/>// mapper - reads the source content and processes it<br/>// reducer - the data is processed and sent to the reducer for aggregation<br/><strong class="ms io">func</strong> <strong class="ms io">MapReduceWithSource</strong>(source &lt;-<strong class="ms io">chan</strong> <strong class="ms io">interface</strong>{}, mapper MapperFunc, reducer ReducerFunc,<br/>    opts . .Option) (<strong class="ms io">interface</strong>{}, error)</span></pre><p id="72d1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">核心方法是 MapReduceWithSource 和 Map，所有其他方法都在内部调用它们。一旦弄清楚 MapReduceWithSource 方法，调用 Map 就不是什么大事了。</p><h1 id="1951" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">MapReduceWithSource 源代码实现</h1><p id="0015" class="pw-post-body-paragraph jv jw in jx b jy lw ka kb kc lx ke kf kg ly ki kj kk lz km kn ko ma kq kr ks ig bi translated">都在这个图表里了</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ng"><img src="../Images/ace28dbdb68f12eb49e722c08572bd42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*TIKLA3tehZc-Db2q"/></div></div></figure><pre class="ku kv kw kx gt mv ms mw mx aw my bi"><span id="c20d" class="mz kz in ms b gy na nb l nc nd">// Support passing in a data source channel and returning the aggregated data<br/>// source - the data source channel<br/>// mapper - reads the source content and processes it<br/>// reducer - send the data to the reducer for aggregation after processing<br/><strong class="ms io">func</strong> <strong class="ms io">MapReduceWithSource</strong>(source &lt;-<strong class="ms io">chan</strong> <strong class="ms io">interface</strong>{}, mapper MapperFunc, reducer ReducerFunc,<br/>    opts . .Option) (<strong class="ms io">interface</strong>{}, error) {<br/>    // Optional parameter settings<br/>    options := buildOptions(opts...)<br/>    // Aggregate data channel, need to manually call write method to write to output<br/>    output := make(<strong class="ms io">chan</strong> <strong class="ms io">interface</strong>{})<br/>    // output will only be read once at the end<br/>    <strong class="ms io">defer</strong> <strong class="ms io">func</strong>() {<br/>        // If there are multiple writes, it will block and cause a concurrent leak<br/>        // Here we use for range to check if the data can be read, and if it can be read, it means it was written multiple times<br/>        // Why do we use panic here? It's better to show the user that the usage is wrong than to fix it automatically<br/>        <strong class="ms io">for</strong> <strong class="ms io">range</strong> output {<br/>            panic("more than one element written in reducer")<br/>        }<br/>    }()<br/>    // create a cached chan with a capacity of workers<br/>    // means that up to workers are allowed to process data at the same time<br/>    collector := make(<strong class="ms io">chan</strong> <strong class="ms io">interface</strong>{}, options.workers)<br/>    // Data aggregation task completion flag<br/>    done := syncx.NewDoneChan()<br/>    // Writer that supports blocking writes to chan<br/>    writer := newGuardedWriter(output, done.Done())<br/>    // Single instance closure<br/>    <strong class="ms io">var</strong> closeOnce sync.<br/>    <strong class="ms io">var</strong> retErr errorx.AtomicError<br/>    // The data aggregation task is finished and the finish flag is sent<br/>    finish := <strong class="ms io">func</strong>() {<br/>        // Can only be closed once<br/>        closeOnce.Do(<strong class="ms io">func</strong>() {<br/>            // send the completion signal for the aggregation task, the close function will write a zero value to chan<br/>            done.Close()<br/>            // Close the data aggregation chan<br/>            close(output)<br/>        })<br/>    }<br/>    // Cancel the operation<br/>    cancel := once(<strong class="ms io">func</strong>(err error) {<br/>        // set error<br/>        <strong class="ms io">if</strong> err ! = <strong class="ms io">nil</strong> {<br/>            retErr.Set(err)<br/>        } <strong class="ms io">else</strong> {<br/>            retErr.Set(ErrCancelWithNil)<br/>        }<br/>        // Clear the source channel<br/>        drain(source)<br/>        // call the finish method<br/>        finish()<br/>    })</span><span id="2bca" class="mz kz in ms b gy ne nb l nc nd">    <strong class="ms io">go</strong> <strong class="ms io">func</strong>() {<br/>        <strong class="ms io">defer</strong> <strong class="ms io">func</strong>() {<br/>            // Clear the aggregation task channel<br/>            drain(collector)<br/>            // Capture the panic<br/>            <strong class="ms io">if</strong> r := recover(); r ! = <strong class="ms io">nil</strong> {<br/>                // Call the cancel method to end immediately<br/>                cancel(fmt.Errorf("%v", r))<br/>            } <strong class="ms io">else</strong> {<br/>                // end normally<br/>                finish()<br/>            }<br/>        }()<br/>        // Perform data processing<br/>        // Note that writer.write writes the processed data to output<br/>        reducer(collector, writer, cancel)<br/>    }()<br/>    // Perform data processing asynchronously<br/>    // source - data production<br/>    // collector - data collection<br/>    // done - the end flag<br/>    // workers - concurrent count<br/>    <strong class="ms io">go</strong> executeMappers(<strong class="ms io">func</strong>(item <strong class="ms io">interface</strong>{}, w Writer) {<br/>        mapper(item, w, cancel)<br/>    }, source, collector, done.Done(), options.workers)<br/>    // The reducer writes the processed data to the output.<br/>    // Read the output when you need the data back<br/>    // If the output has been written more than twice<br/>    // then the defer func at the beginning will still be able to read the data<br/>    // This detects that the user has called the write method more than once<br/>    value, ok := &lt;-output<br/>    <strong class="ms io">if</strong> err := retErr.Load(); err ! = <strong class="ms io">nil</strong> {<br/>        <strong class="ms io">return</strong> <strong class="ms io">nil</strong>, err<br/>    } <strong class="ms io">else</strong> <strong class="ms io">if</strong> ok {<br/>        <strong class="ms io">return</strong> value, <strong class="ms io">nil</strong><br/>    } <strong class="ms io">else</strong> {<br/>        <strong class="ms io">return</strong> <strong class="ms io">nil</strong>, ErrReduceNoOutput<br/>    }<br/>}</span><span id="d660" class="mz kz in ms b gy ne nb l nc nd">// Data processing<br/><strong class="ms io">func</strong> <strong class="ms io">executeMappers</strong>(mapper MapFunc, input &lt;-<strong class="ms io">chan</strong> <strong class="ms io">interface</strong>{}, collector <strong class="ms io">chan</strong>&lt;- <strong class="ms io">interface</strong>{},<br/>    done &lt;-<strong class="ms io">chan</strong> lang.PlaceholderType, workers <strong class="ms io">int</strong>) {<br/>    // goroutine coordinates the synchronization semaphore<br/>    <strong class="ms io">var</strong> wg sync.WaitGroup<br/>    <strong class="ms io">defer</strong> <strong class="ms io">func</strong>() {<br/>        // Wait for data processing tasks to complete<br/>        // prevent the data-processing concurrent from simply quitting before the data has been processed<br/>        wg.Wait()<br/>        // Close the data processing channel<br/>        close(collector)<br/>    }()<br/>    // channel with buffer, buffer size is workers<br/>    // control the number of concurrent processes for data processing<br/>    pool := make(<strong class="ms io">chan</strong> lang.PlaceholderType, workers)<br/>    // data processing writer<br/>    writer := newGuardedWriter(collector, done)<br/>    <strong class="ms io">for</strong> {<br/>        <strong class="ms io">select</strong> {<br/>        // listen to external end signal, end directly<br/>        <strong class="ms io">case</strong> &lt;-done:<br/>            <strong class="ms io">return</strong><br/>        // Control the number of data processing concurrently<br/>        // buffer capacity -1<br/>        // will be blocked when there is no capacity, waiting for capacity to be released<br/>        <strong class="ms io">case</strong> pool &lt;- lang.Placeholder:<br/>            // blocking waiting to produce data channel<br/>            item, ok := &lt;-input<br/>            // If ok is false, input is closed or cleared<br/>            // Data processing is complete, execute exit<br/>            <strong class="ms io">if</strong> !ok {<br/>                // buffer capacity + 1<br/>                &lt;-pool<br/>                // end this loop<br/>                <strong class="ms io">return</strong><br/>            }<br/>            // wg synchronize semaphore +1<br/>            wg.Add(1)<br/>            // better to safely run caller defined method<br/>            // perform data processing asynchronously to prevent panic errors<br/>            threading.GoSafe(<strong class="ms io">func</strong>() {<br/>                <strong class="ms io">defer</strong> <strong class="ms io">func</strong>() {<br/>                    // wg synchronize semaphore-1<br/>                    wg.Done()<br/>                    // buffer capacity +1<br/>                    &lt;-pool<br/>                }()</span><span id="71ff" class="mz kz in ms b gy ne nb l nc nd">                mapper(item, writer)<br/>            })<br/>        }<br/>    }<br/>}</span></pre><h1 id="bb23" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">摘要</h1><p id="a642" class="pw-post-body-paragraph jv jw in jx b jy lw ka kb kc lx ke kf kg ly ki kj kk lz km kn ko ma kq kr ks ig bi translated">我花了大概两个晚上的时间钻研<code class="fe mp mq mr ms b">MapReduce</code>源代码，整体看腻了。一方面我对 go 语言不是很精通，尤其是 channel 的用法，需要经常停下来查看相关文档才能理解作者的写法，另一方面通过 channel 交流实现多个 goroutines 之间的协作真的是相当烧脑(佩服作者的思维能力)。</p><p id="d9da" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">其次，第一次看源代码的时候肯定会比较迷茫，其实没关系找到程序的入口(公共基础组件一般都是面向方法)先沿着主线一路往下看每一句代码理解加注释，然后再看分支线代码。</p><p id="2e2c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果真的有不明白的地方，检查提交记录的代码很有可能解决一个 bug 的修改，比如下面的代码我已经看了很多遍但是不明白。</p><pre class="ku kv kw kx gt mv ms mw mx aw my bi"><span id="4dd5" class="mz kz in ms b gy na nb l nc nd">// Aggregate data channel, you need to manually call the write method to write to the output<br/>output := make(<strong class="ms io">chan</strong> <strong class="ms io">interface</strong>{})<br/>// output will only be read once at the end<br/><strong class="ms io">defer</strong> <strong class="ms io">func</strong>() {<br/>    // If there are multiple writes, it will block and cause a concurrent leak<br/>    // Here we use for range to check if the data can be read, and if it can be read, it means it was written multiple times<br/>    // Why do we use panic here? It's better to show the user that the usage is wrong than to fix it automatically<br/>    <strong class="ms io">for</strong> <strong class="ms io">range</strong> output {<br/>        panic("more than one element written in reducer")<br/>    }<br/>}()</span></pre><p id="1325" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后画出流程图基本上让源代码可以理解，对我来说，这种方法是相当愚蠢但有效的。</p><h1 id="8784" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">项目地址</h1><p id="f80b" class="pw-post-body-paragraph jv jw in jx b jy lw ka kb kc lx ke kf kg ly ki kj kk lz km kn ko ma kq kr ks ig bi translated"><a class="ae nf" href="https://github.com/zeromicro/go-zero" rel="noopener ugc nofollow" target="_blank"><strong class="jx io">https://github.com/zeromicro/go-zero</strong></a></p><p id="e2c2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">欢迎用<code class="fe mp mq mr ms b">go-zero</code>和<strong class="jx io">星</strong>支持我们！</p></div></div>    
</body>
</html>