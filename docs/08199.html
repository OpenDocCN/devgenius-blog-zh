<html>
<head>
<title>Catching and displaying UI errors with toast messages in Angular</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 toast 消息捕获和显示 UI 错误</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/catching-and-displaying-ui-errors-with-toast-messages-in-angular-db06f2605a6d?source=collection_archive---------3-----------------------#2022-05-25">https://blog.devgenius.io/catching-and-displaying-ui-errors-with-toast-messages-in-angular-db06f2605a6d?source=collection_archive---------3-----------------------#2022-05-25</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="fedd" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">错误和干杯</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/cac6a049dcad79145aae7ec1065117e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TVxkA6FjOevBMXAP1N9GzQ.png"/></div></div></figure><p id="a110" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在<a class="ae lk" href="https://garage.sekrab.com/posts/catching-and-handling-errors-in-angular" rel="noopener ugc nofollow" target="_blank">的上一篇文章:Angular </a>中的捕获和处理错误中，我们处理了来自 Http 响应和 RxJS 操作符的错误，通过将错误返回给消费者，让每个消费者进行不同的处理。今天，我们将为 Toast 消息创建一个组件，它可能用于错误处理。</p><p id="eb17" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">最终项目可以在<a class="ae lk" href="https://stackblitz.com/edit/angular-error-toast?file=src/app/toast/toast.state.ts" rel="noopener ugc nofollow" target="_blank"> StackBlitz </a>上找到。在<a class="ae lk" href="https://stackblitz.com/edit/angular-error-toast?file=src/app/components/list.partial.ts" rel="noopener ugc nofollow" target="_blank">components/list . partial . ts</a>中找到<code class="fe ll lm ln lo b">catchError</code>的使用示例，点击导航中的<strong class="kq io"> transactions </strong>查看其工作情况。另一个例子见<code class="fe ll lm ln lo b">components/form.partial.ts</code>。</p><h1 id="ffb3" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">多好的祝酒辞！</h1><p id="043f" class="pw-post-body-paragraph ko kp in kq b kr mh jo kt ku mi jr kw kx mj kz la lb mk ld le lf ml lh li lj ig bi translated">让我们从简单的开始。非常简单:给<code class="fe ll lm ln lo b">app.component root</code>添加一个组件，并控制它的一些事情。</p><pre class="kd ke kf kg gt mm lo mn mo aw mp bi"><span id="4814" class="mq lq in lo b gy mr ms l mt mu">@Component({<br/>    selector: 'gr-toast',<br/>    template: `<br/>      &lt;div class="toast"&gt;<br/>        &lt;div class="text"&gt;text here&lt;/div&gt;<br/>        &lt;button&gt;Dismiss&lt;/button&gt;<br/>      &lt;/div&gt;<br/>    `,<br/>    changeDetection: ChangeDetectionStrategy.OnPush,<br/>    styleUrls: ['./toast.css'],<br/>})<br/>export class ToastPartialComponent  {<br/>    constructor() {</span><span id="167a" class="mq lq in lo b gy mv ms l mt mu">    }<br/>}</span></pre><p id="f8c2" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这将手动附加到正文:</p><pre class="kd ke kf kg gt mm lo mn mo aw mp bi"><span id="9f18" class="mq lq in lo b gy mr ms l mt mu">&lt;!--  in app.component.html --&gt;<br/>&lt;gr-toast&gt;&lt;/gr-toast&gt;</span><span id="0108" class="mq lq in lo b gy mv ms l mt mu">&lt;!--  and in app.module, add a declaration, this will end in Angular 14, hopefully --&gt;</span></pre><p id="fbbf" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">让我们给它最简单的风格，以便能够使用它:</p><pre class="kd ke kf kg gt mm lo mn mo aw mp bi"><span id="c10f" class="mq lq in lo b gy mr ms l mt mu">/* basic css for the toast */<br/>.toast {<br/>  border-radius: 5px;<br/>  max-width: 80vw;<br/>  display: flex;<br/>  flex-wrap: nowrap;<br/>  align-items: center;<br/>  justify-content: space-between;<br/>  background-color: #263238;<br/>  color: #fff;<br/>  position: fixed;<br/>  bottom: 10px;<br/>  left: 10px;<br/>  font-size: 90%;<br/>  z-index: 5100;<br/>}<br/>.text {<br/>  padding: 20px;<br/>  flex-basis: 100%;<br/>  margin-right: 10px;<br/>}</span><span id="e31a" class="mq lq in lo b gy mv ms l mt mu">button {<br/>  padding: 20px;<br/>  cursor: pointer;<br/>  font-weight: bold;<br/>  color: inherit;<br/>}</span></pre><p id="862e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">左下角看起来是这样的。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/f48b992b3798143c0d8301122d7de446.png" data-original-src="https://miro.medium.com/v2/resize:fit:712/0*VxYAjcECQibhfK-A"/></div></figure><p id="6451" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">为了在任何地方访问 toast 的可见性，它需要由 root 中提供的服务来处理。<strong class="kq io">最简单形式的服务有一个内部主题，作为可观察对象公开</strong>，将内容从“null”更改为“something”。</p><blockquote class="mx my mz"><p id="4388" class="ko kp na kq b kr ks jo kt ku kv jr kw nb ky kz la nc lc ld le nd lg lh li lj ig bi translated"><em class="in">我们稍后可以将它变成我们在</em> <a class="ae lk" href="https://garage.sekrab.com/posts/rxjs-based-state-management-in-angular-part-v" rel="noopener ugc nofollow" target="_blank"> <em class="in"> RxJS 状态管理</em> </a> <em class="in">中构建的状态服务。</em></p></blockquote><p id="bc83" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">服务如下:</p><pre class="kd ke kf kg gt mm lo mn mo aw mp bi"><span id="b162" class="mq lq in lo b gy mr ms l mt mu">import { Injectable } from '@angular/core';<br/>import { BehaviorSubject, Observable } from 'rxjs';</span><span id="4fa5" class="mq lq in lo b gy mv ms l mt mu">// the simple model will become bigger as wel move on<br/>export interface IToast {<br/>    text?: string;<br/>}</span><span id="91ee" class="mq lq in lo b gy mv ms l mt mu">@Injectable({ providedIn: 'root' })<br/>export class Toast {<br/>  // internal subject to control the state<br/>  private toast: BehaviorSubject&lt;IToast | null&gt; = new BehaviorSubject(null);<br/>  toast$: Observable&lt;IToast | null&gt; = this.toast.asObservable();</span><span id="bc00" class="mq lq in lo b gy mv ms l mt mu"> // show, simply updates the state to something<br/>  Show(text: string) {<br/>    this.toast.next({ text: text });<br/>  }<br/>  // hide, simple updates the state to null<br/>  Hide() {<br/>    this.toast.next(null);<br/>  }<br/>}</span></pre><p id="d60d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">然后在 toast 模板中，我们观察 toast 状态:</p><pre class="kd ke kf kg gt mm lo mn mo aw mp bi"><span id="81b2" class="mq lq in lo b gy mr ms l mt mu">@Component({<br/>  selector: 'gr-toast',<br/>  // in template watch the toast observable for null values to hide all<br/>  template: `<br/>    &lt;ng-container *ngIf="toastState.toast$ | async as toast"&gt;<br/>      &lt;div class="toast"&gt;<br/>        &lt;div class="text"&gt;{{ toast.text }} &lt;/div&gt;<br/>        &lt;!-- on click, hide the toast --&gt;<br/>        &lt;button (click)="toastState.Hide()"&gt;Dismiss&lt;/span&gt;<br/>      &lt;/div&gt;<br/>    &lt;/ng-container&gt;<br/>    `,<br/>  changeDetection: ChangeDetectionStrategy.OnPush,<br/>  styleUrls: ['./toast.css'],<br/>})<br/>export class ToastPartialComponent {<br/>  // inject the state<br/>  constructor(public toastState: Toast) {}<br/>}</span></pre><p id="d0d8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在任何组件中显示和隐藏非常简单:</p><p id="e51d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe ll lm ln lo b">this.toast.Show('hello world');</code></p><blockquote class="mx my mz"><p id="4d38" class="ko kp na kq b kr ks jo kt ku kv jr kw nb ky kz la nc lc ld le nd lg lh li lj ig bi translated"><em class="in">是不是看起来太简单了？确实是。故意的。</em></p></blockquote><p id="a303" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">所以现在，回到我们的 RxJS 捕获和未处理的错误。最终结果看起来是这样的:</p><pre class="kd ke kf kg gt mm lo mn mo aw mp bi"><span id="cd6a" class="mq lq in lo b gy mr ms l mt mu">// in a component that uses the custom operator to unify the error model:<br/>getProjects() {<br/>  this.projects$ = this.projectService.GetProjects().pipe(<br/>    catchError(error =&gt; {<br/>      // here we use our toast, we pass the code only<br/>      this.toast.Show(error.code);<br/>     <br/>      // then continue, nullifying<br/>      return of(null);<br/>    })<br/>  )<br/>}</span></pre><p id="77a0" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">所以我们现在知道第一个参数应该是一个<strong class="kq io">代码</strong>，它转化为一个消息。</p><h1 id="e849" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">文本资源</h1><p id="f5c0" class="pw-post-body-paragraph ko kp in kq b kr mh jo kt ku mi jr kw kx mj kz la lb mk ld le lf ml lh li lj ig bi translated">翻译信息的代码？那看起来像是<strong class="kq io">资源</strong>。正如我之前在<a class="ae lk" href="https://garage.sekrab.com/posts/seo-in-angular-with-ssr-part-i" rel="noopener ugc nofollow" target="_blank"> SEO 服务</a>中所说，我避开了<strong class="kq io"> i18n 包</strong>，创建了自己的<a class="ae lk" href="https://stackblitz.com/edit/angular-seo-service?file=src/app/resources.ts" rel="noopener ugc nofollow" target="_blank">资源文件</a>。我们将在此基础上进行构建，但稍有改动。由于<strong class="kq io">代码是从服务器</strong>返回的，我们想要两件东西:</p><ul class=""><li id="f72a" class="ne nf in kq b kr ks ku kv kx ng lb nh lf ni lj nj nk nl nm bi translated">找不到的代码的“<strong class="kq io">未知</strong>”通用文本</li><li id="01b6" class="ne nf in kq b kr nn ku no kx np lb nq lf nr lj nj nk nl nm bi translated">一条<strong class="kq io">回退消息</strong>，以防我们希望回退特定于某些情况</li></ul><pre class="kd ke kf kg gt mm lo mn mo aw mp bi"><span id="9731" class="mq lq in lo b gy mr ms l mt mu">// under root/locale/resources.ts, lets add a few codes<br/>export const keys = {<br/>  // an unknown key to fall back to<br/>  Unknown:<br/>    'Oops! We could not perform the required action for some reason. We are looking into it right now.',<br/>  // an empty one just in case<br/>  NoRes: '', // if resource is not found<br/>  // some generic keys of our choice<br/>  Required: 'Required',<br/>  Error: 'An error occurred',<br/>  DONE: 'Done',<br/>  // some specific ones<br/>  UNAUTHORIZED: 'Login or register first.',<br/>  INVALID_VALUE: 'Value entered is not within the range allowed',</span><span id="97a5" class="mq lq in lo b gy mv ms l mt mu">  // mapping from server or API<br/>  PROJECT_ADD_FAILED: 'Server did not like this project',<br/>};</span></pre><p id="c042" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">编写 Show 方法时考虑到了这一点:</p><pre class="kd ke kf kg gt mm lo mn mo aw mp bi"><span id="d4ca" class="mq lq in lo b gy mr ms l mt mu">// Toast show method takes code, and fallback<br/>Show(code: string, fallback?: string) {<br/>  // get message from code, keys is found in locale/resources.ts<br/>  let message = keys[code];<br/>  // if it does not exist, fall back message<br/>  if (!message) {<br/>    // if fallback is not provided, return unknown<br/>    message = fallback || keys.Unknown;<br/>  }<br/>  this.toast.next({ text: message });<br/>}</span></pre><p id="83d9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这种先找到一个键然后再返回的模式，在任何使用资源的地方都会用到。它<strong class="kq io">将代码从资源</strong>中分离出来，使得“未知”更加普遍。但是，因为它解耦了它们，所以在开发期间，当我们真的不知道从服务器期待什么代码时，它更宽容。所以，做以下事情，风险自担(这是我个人的选择):</p><h1 id="2229" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">资源类</h1><p id="dc30" class="pw-post-body-paragraph ko kp in kq b kr mh jo kt ku mi jr kw kx mj kz la lb mk ld le lf ml lh li lj ig bi translated">让我们把这个模式放到它自己的类中:</p><pre class="kd ke kf kg gt mm lo mn mo aw mp bi"><span id="4b1c" class="mq lq in lo b gy mr ms l mt mu">import { keys } from '../../locale/resources';</span><span id="1e48" class="mq lq in lo b gy mv ms l mt mu">// a simple class that translates resources into actual messages<br/>export class Res {<br/>  public static Get(key: string, fallback?: string): string {<br/>    // get message from key<br/>    if (keys[key]) {<br/>      return keys[key];<br/>    }<br/>    // if not found, fallback, if not provided return NoRes<br/>    return fallback || keys.NoRes;<br/>  }<br/>}</span></pre><p id="ee33" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在我们可以在像这样的任何地方使用它</p><p id="f64b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe ll lm ln lo b">Res.Get('Invalid_Email');</code></p><p id="443a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">或者代码是否更加不可预测</p><p id="f782" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe ll lm ln lo b">Res.Get(serverCode, 'Use this message instead');</code></p><p id="de98" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">由于第二个参数也是文本，我们可以选择一个现有的资源来替换它</p><p id="cd45" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe ll lm ln lo b">Res.Get(serverCode, keys.Unknown);</code></p><p id="40e5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这就是我们将用于祝酒词的内容，此外还公开了回退。回到我们的展示方法，这应该是决定信息的最灵活和全面的方法。</p><pre class="kd ke kf kg gt mm lo mn mo aw mp bi"><span id="c066" class="mq lq in lo b gy mr ms l mt mu">Show(code: string, fallback?: string) {<br/>  // use code, then use fallback, then use keys.Unknown<br/>  const message = Res.Get(code, fallback || keys.Unknown);<br/>  this.toast.next({ text: message });<br/>}</span></pre><h1 id="f8c4" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">错误处理细节</h1><p id="f797" class="pw-post-body-paragraph ko kp in kq b kr mh jo kt ku mi jr kw kx mj kz la lb mk ld le lf ml lh li lj ig bi translated">到目前为止，toast 是一个通用工具，我们可以直接使用它来显示组件中的错误:</p><pre class="kd ke kf kg gt mm lo mn mo aw mp bi"><span id="a0fa" class="mq lq in lo b gy mr ms l mt mu">create(project: Partial&lt;IProject&gt;) {<br/>  // we can catch errors in "error" body or as an operator to RxJS pipe<br/>  this.projectService.CreateProject(project).subscribe({<br/>    next: (data) =&gt; {<br/>      console.log(data?.id);<br/>    },<br/>    error: (error: IUiError) =&gt; {<br/>      // this needs a bit more information, specifically style<br/>      // also error may not have 'code'<br/>      this.toast.Show(error.code); <br/>    }<br/>  });<br/>}</span><span id="23b9" class="mq lq in lo b gy mv ms l mt mu">// in a simpler non-subscribing observable<br/>getProjects() {<br/>  this.projects$ = this.projectService.GetProjects().pipe(<br/>    catchError((error:IUiError) =&gt; {<br/>      // same as above<br/>      this.toastShow(error.code);<br/>      // then continue, nullifying, remember here to account for "null" values<br/>      // in the component consuming this observable<br/>      return of(null);<br/>    })<br/>  )<br/>}</span></pre><p id="c68d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这将成为一种模式，所以让我们缩小尺寸，把它从组件中去掉:</p><p id="a1bd" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe ll lm ln lo b">catchError(e=&gt;this.toast.HandleUiError(e[, fallBack]))</code></p><p id="c7ff" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">此外，我们需要注意错误处理的最后一道关口，<strong class="kq io">如果错误不是</strong> a <code class="fe ll lm ln lo b">UiError</code>呢？如果是 JavaScript 错误呢？在 toast state 服务中，我们添加了这个新的<code class="fe ll lm ln lo b">HandleUiError</code>方法，以及一个最终的重新抛出:</p><pre class="kd ke kf kg gt mm lo mn mo aw mp bi"><span id="f0fb" class="mq lq in lo b gy mr ms l mt mu">export class Toast {<br/>  // ...<br/>  <br/>  // show code then return null<br/>  HandleUiError(error: IUiError, fallback?: string): Observable&lt;any&gt; {<br/>    // if error.code exists it is our error<br/>    if (error.code) {<br/>      this.Show(error.code, fallback);<br/>      return of(null);<br/>    } else {<br/>      // else, throw it back to Angular Error Service, this is a JS error<br/>      return throwError(() =&gt; error);<br/>    }<br/>  }<br/>}</span></pre><h1 id="3cdf" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">所有误差都相等吗？</h1><p id="0df2" class="pw-post-body-paragraph ko kp in kq b kr mh jo kt ku mi jr kw kx mj kz la lb mk ld le lf ml lh li lj ig bi translated">随着我们继续前进并创建样式，我们会认为所有来自<code class="fe ll lm ln lo b">catchError</code>语句的祝酒词都是红色失败。但是他们都是这样吗？从 UI 角度来看，<strong class="kq io">肯定不是</strong>。考虑以下使用案例</p><h2 id="6e7d" class="mq lq in bd lr ns nt dn lv nu nv dp lz kx nw nx mb lb ny nz md lf oa ob mf oc bi translated">通过电子邮件添加成员</h2><p id="ed93" class="pw-post-body-paragraph ko kp in kq b kr mh jo kt ku mi jr kw kx mj kz la lb mk ld le lf ml lh li lj ig bi translated">一个允许管理员通过电子邮件添加新用户的特性，一个好的 API 应该(至少)有两点:</p><ul class=""><li id="62de" class="ne nf in kq b kr ks ku kv kx ng lb nh lf ni lj nj nk nl nm bi translated">创建新用户:<code class="fe ll lm ln lo b">POST users/</code>不仅仅是电子邮件</li><li id="20d2" class="ne nf in kq b kr nn ku no kx np lb nq lf nr lj nj nk nl nm bi translated">添加会员:<code class="fe ll lm ln lo b">POST members/</code>用用户 ID，或者邮箱，前面可以加“通过邮箱查找用户”。</li></ul><p id="7143" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">作为开发人员，我们将从通过电子邮件添加成员<strong class="kq io">开始。如果邮件不存在，<strong class="kq io">将返回错误 404 </strong>。用户界面只需要建立在它的基础上，允许管理员继续填写其他领域。<strong class="kq io">消息，如果有的话，在这种情况下；不是错误，而是信息</strong>。<strong class="kq io">消息，如果有的话，在这种情况下；不是错误，而是信息</strong>。</strong></p><h2 id="cf49" class="mq lq in bd lr ns nt dn lv nu nv dp lz kx nw nx mb lb ny nz md lf oa ob mf oc bi translated">超时的用户</h2><p id="52f2" class="pw-post-body-paragraph ko kp in kq b kr mh jo kt ku mi jr kw kx mj kz la lb mk ld le lf ml lh li lj ig bi translated">服务器可能会返回<strong class="kq io">错误 401 或 403，这不是终端</strong>。这种情况下的消息不是错误，而是信息性的，带有“重新登录”按钮，或者在更严重的情况下，是重定向。</p><p id="6358" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">先加风格，看看怎么适应。</p><h1 id="a20d" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">式样</h1><p id="5567" class="pw-post-body-paragraph ko kp in kq b kr mh jo kt ku mi jr kw kx mj kz la lb mk ld le lf ml lh li lj ig bi translated">将会有重复的模式来显示红框、黄框、绿框等等。</p><p id="5026" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe ll lm ln lo b">this.toast.ShowError</code></p><p id="d704" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe ll lm ln lo b">this.toast.ShowWarning</code></p><p id="50e0" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe ll lm ln lo b">this.toast.ShowSuccess</code></p><p id="5607" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe ll lm ln lo b">this.toast.Show (default)</code></p><p id="8fe8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们将在州服务中添加那些重复的功能。由于我们有额外的选项，<strong class="kq io">回退文本将被合并到文本选项</strong>中。</p><pre class="kd ke kf kg gt mm lo mn mo aw mp bi"><span id="9bf0" class="mq lq in lo b gy mr ms l mt mu">// adapt the toast state service to have options as a second argument<br/>// fallback message is now part of options <br/>  Show(code: string, options?: IToast): void {<br/>    // get message from code<br/>    const message = Res.Get(code, options?.text || keys.Unknown);<br/>    // pass options<br/>    this.toast.next({...options, text: message})<br/>  }</span><span id="743f" class="mq lq in lo b gy mv ms l mt mu">// shortcuts for specific styles, replace fallback with options<br/>  ShowError(code: string, options?: IToast) {<br/>    this.Show(code, { extracss: 'error', ...options });<br/>  }<br/>  ShowSuccess(code: string, options?: IToast) {<br/>    this.Show(code, { extracss: 'success', ...options });<br/>  }<br/>  ShowWarning(code: string, options?: IToast) {<br/>    this.Show(code, { extracss: 'warning', ...options });<br/>  }<br/>  <br/>  // replace fallback here as well<br/>  HandleUiError(error: IUiError, options?: IToast): Observable&lt;any&gt; {<br/>    // if error.code exists it is our error<br/>    if (error.code) {<br/>      this.Show(error.code, options);<br/>      return of(null);<br/>    } else {<br/>      // else, throw it back to Angular Error Service, this is a JS error<br/>      return throwError(() =&gt; error);<br/>    }<br/>  }<br/>  <br/>  // using it is now like this<br/>  // this.toast.Show('SomeCode', {text: 'fallback message'});</span></pre><p id="a0b3" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在我们的 css 文件中</p><pre class="kd ke kf kg gt mm lo mn mo aw mp bi"><span id="32cc" class="mq lq in lo b gy mr ms l mt mu">/* add to toast.css */<br/>.toast.warning {<br/>  background-color: var(--yellow);<br/>  color: #263238;<br/>}<br/>.toast.error {<br/>  background-color: var(--red);<br/>}<br/>.toast.success {<br/>  background-color: var(--green);<br/>}</span></pre><p id="5b34" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在我们的 toast 组件模板中</p><p id="1e5c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe ll lm ln lo b">&lt;div class="toast {{toast.extracss}}"&gt;</code></p><p id="fe02" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">但是我们希望“toast”被修改，我们也希望它被默认。为了实现这一点，我们需要状态服务中的一个<strong class="kq io">默认选项</strong>变量</p><pre class="kd ke kf kg gt mm lo mn mo aw mp bi"><span id="1674" class="mq lq in lo b gy mr ms l mt mu">// in toast state service<br/> private defaultOptions: IToast = {<br/>    css: 'toast',<br/>    extracss: '',<br/>    text: '',<br/>  };</span><span id="3025" class="mq lq in lo b gy mv ms l mt mu">  Show(code: string, options?: IToast) {<br/>    // extend default options<br/>    const _options: IToast = { ...this.defaultOptions, ...options };</span><span id="5aa9" class="mq lq in lo b gy mv ms l mt mu">    const message = Res.Get(code, options?.text || keys.Unknown);<br/>    this.toast.next({ ..._options, text: message });<br/>  }</span></pre><p id="86f1" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在我们的 toast 组件模板中</p><p id="214e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe ll lm ln lo b">&lt;div class="{{ toast.css }} {{toast.extracss}}"&gt;</code></p><p id="2921" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">有了所有这些小工具，创建一个非常具体和动态的警告消息看起来像这样</p><pre class="kd ke kf kg gt mm lo mn mo aw mp bi"><span id="12f3" class="mq lq in lo b gy mr ms l mt mu">// extreme case of a warning when an upload file is too large<br/>const size = Config.Upload.MaximumSize;<br/>this.toast.ShowWarning(<br/>  // empty code to fallback<br/>  '',<br/>  // fallback to a dynamically created message<br/>  { text: Res.Get('FILE_LARGE').replace('$0', size)}<br/>);<br/>  <br/>// where FILE_LARGE is:<br/>// FILE_LARGE: 'The size of the file is larger than the specified limit ($0 KB)'</span></pre><h1 id="e161" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">Http 状态错误</h1><p id="f883" class="pw-post-body-paragraph ko kp in kq b kr mh jo kt ku mi jr kw kx mj kz la lb mk ld le lf ml lh li lj ig bi translated">回到我们的消费者组件，在那里捕获错误。在示例“获取项目”功能中，我们有以下可能的结果:</p><pre class="kd ke kf kg gt mm lo mn mo aw mp bi"><span id="7c8b" class="mq lq in lo b gy mr ms l mt mu">getProjects() {<br/>  this.projects$ = this.projectService.GetProjects().pipe(<br/>    catchError(error =&gt; {<br/>     // what is the error? is it 404? or 401?<br/>     if (error.status === 400){<br/>      this.toast.ShowError(error.code);<br/>     }<br/>     if (error.status === 404) {<br/>       // ignore code from server<br/>       this.toast.ShowWarning('PROJECT_NOT_FOUND');<br/>     }<br/>     if ([401, 403].includes(error.status)){<br/>       // ignore codes and always show unauthorized<br/>       // and in the future also pass a button to login<br/>       this.toast.Show('UNAUTHORIZED', {button: 'TODO'} );<br/>       // or simply log out<br/>       this.authService.logout();<br/>     }<br/>     // and other error statuses...<br/>     // then continue, nullifying<br/>     return of(null);<br/>    })<br/>  )<br/>}</span></pre><blockquote class="mx my mz"><p id="c443" class="ko kp na kq b kr ks jo kt ku kv jr kw nb ky kz la nc lc ld le nd lg lh li lj ig bi translated"><em class="in">注意:如果我们把 toast 组件放在 root app 中，重定向到 login 不会让它消失，这正是我们想要的，如果你重定向到一个没有 toast 组件的路由，显示它就没有意义了，因为它会被移除。</em></p></blockquote><p id="0b2d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这是解决问题的一种方法。尽管这是一种模式，我们也应该把它移植到我们的国家服务中。同时，我们应该<strong class="kq io">创建按钮</strong>界面。</p><pre class="kd ke kf kg gt mm lo mn mo aw mp bi"><span id="5d86" class="mq lq in lo b gy mr ms l mt mu">// rewriting HandleUiError<br/> HandleUiError(error: IUiError, options?: IToast): Observable&lt;any&gt; {<br/>    if (error.code) {<br/>      // do a switch case for specific errors<br/>      switch (error.status) {<br/>        case 500:<br/>          // terrible error, code always unknown<br/>          this.ShowError('Unknown', options);<br/>          break;<br/>        case 400:<br/>          // server error<br/>          this.ShowError(error.code, options);<br/>          break;<br/>        case 401:<br/>        case 403:<br/>          // auth error, just show a unified message, need to add options for button<br/>          this.Show('UNAUTHORIZED', options);<br/>          break;<br/>        case 404:<br/>          // thing does not exist, better let each component decide<br/>          this.ShowWarning(error.code, options);<br/>          break;<br/>        default:<br/>          // other errors<br/>          this.ShowError(error.code, options);<br/>      }<br/>      return of(null);<br/>    } else {<br/>      return throwError(() =&gt; error);<br/>    }<br/>  }</span></pre><p id="82c6" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">使用它是非常灵活的，如果我想具体说明 404 错误，下面是最终结果:</p><pre class="kd ke kf kg gt mm lo mn mo aw mp bi"><span id="6a79" class="mq lq in lo b gy mr ms l mt mu">getProjects() {<br/>  this.projects$ = this.projectService.GetProjects().pipe(<br/>    catchError((error) =&gt; {<br/>      // you could override the extracss, or fallback text<br/>      // this.toast.HandleUiError(error, { extracss: 'warning' })<br/>      // but if 404, i want a different code<br/>      if (error.status === 404) {<br/>        error.code = 'PROJECT_NOT_FOUND';<br/>      }<br/>      return this.toast.HandleUiError(error);<br/>    });<br/>}</span></pre><p id="ff6c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们现在可以进行任何类型的特定组合，这是我们之前添加成员的场景，用户 404 不是错误:</p><pre class="kd ke kf kg gt mm lo mn mo aw mp bi"><span id="a0d6" class="mq lq in lo b gy mr ms l mt mu">// example of handling 404 differently<br/>assignMember() {<br/>  this.user$ = this.userService.GetUser('email@something.com').pipe(<br/>    catchError((error) =&gt; {<br/>      if (error.status !== 404) {<br/>        return this.toast.HandleUiError(error);<br/>      }<br/>      // a 404 means new user needs to be created<br/>      // may be a toast of that? optional<br/>      this.toast.Show('ADDING_NEW_USER');<br/>      // return new user object and continue<br/>      return of({email: 'email@something.com'});<br/>    });<br/>}</span></pre><p id="ef28" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">您可以更具体地说明您正在进行的项目的需求。因此，请留意重复的模式，并小心处理它们。</p><h1 id="3235" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">动作按钮</h1><p id="47df" class="pw-post-body-paragraph ko kp in kq b kr mh jo kt ku mi jr kw kx mj kz la lb mk ld le lf ml lh li lj ig bi translated">最后但同样重要的是，我们需要公开按钮，以允许除“解散”之外的按钮。首先，让我们将按钮添加到模板中，并传递 click 事件:</p><pre class="kd ke kf kg gt mm lo mn mo aw mp bi"><span id="e3d3" class="mq lq in lo b gy mr ms l mt mu">&lt;!-- in toast template --&gt;<br/> &lt;div class="{{toast.css}} {{toast.extracss}}"&gt;<br/>  &lt;div class="text"&gt;{{ toast.text }} &lt;/div&gt;<br/>  &lt;div class="buttons" *ngIf="toast.buttons.length"&gt;<br/>    &lt;!-- TODO: add buttons collection to model, and click handler prop --&gt;<br/>      &lt;button *ngFor="let button of toast.buttons"<br/>       [class]="button.css" <br/>       (click)="button.click($event)"<br/>      &gt;{{button.text}}&lt;/button&gt;<br/>  &lt;/div&gt;<br/>&lt;/div&gt;</span></pre><p id="5434" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在 toast 模型中，我们添加了 buttons 集合，每个按钮是一个至少包含文本和 css 的元素，以及一个 click 方法:</p><pre class="kd ke kf kg gt mm lo mn mo aw mp bi"><span id="5848" class="mq lq in lo b gy mr ms l mt mu">export interface IToast {<br/>  text?: string;<br/>  css?: string; // basic css, defaults to toast<br/>  extracss?: string; // extra styling<br/>  buttons?: IToastButton[]; // action buttons<br/>}</span><span id="83a7" class="mq lq in lo b gy mv ms l mt mu">export interface IToastButton {<br/>  text: string;<br/>  css?: string;<br/>  // and a click handler<br/>  click?: (event: MouseEvent) =&gt; void;<br/>}</span></pre><p id="3e6d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">例如，在我们的消费者组件中，<strong class="kq io">登录以继续</strong>场景，让我们在 toast 中添加一个登录按钮。</p><pre class="kd ke kf kg gt mm lo mn mo aw mp bi"><span id="f5bf" class="mq lq in lo b gy mr ms l mt mu">// inside a catchError operator<br/> return this.toast.HandleUiError(error, {<br/>  buttons: [<br/>    {<br/>      text: 'Login', // better use resources keys<br/>      click: (event) =&gt; {<br/>        // route to login then close toast<br/>        this.router.navigateByUrl('/login');<br/>        this.toast.Hide();<br/>      }<br/>    }<br/>  ],<br/>});</span></pre><p id="d981" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们也可以创建默认的解散按钮。可选地添加它的最安全的方法是<strong class="kq io">暴露解散按钮</strong>，并像对待任何其他按钮一样对待它。在敬酒状态服务中:</p><pre class="kd ke kf kg gt mm lo mn mo aw mp bi"><span id="9cd8" class="mq lq in lo b gy mr ms l mt mu">// public dismiss button<br/>dismissButton = {<br/>  css: 'btn-close',<br/>  text: keys.DISMISS,<br/>  click: (event: MouseEvent) =&gt; {<br/>    this.Hide();<br/>  },<br/>};<br/>  <br/>// added to default options<br/>private defaultOptions: IToast = {<br/>  css: 'toast',<br/>  extracss: '',<br/>  text: '',<br/>  // add dismiss by default<br/>  buttons: [this.dismissButton]<br/>};</span></pre><p id="7bf1" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">回到我们要添加两个按钮的消费组件:</p><pre class="kd ke kf kg gt mm lo mn mo aw mp bi"><span id="865d" class="mq lq in lo b gy mr ms l mt mu">// inside a catchError operator<br/>return this.toast.HandleUiError(error, {<br/>  buttons: [<br/>    {<br/>      text: 'Login', <br/>      click: (event) =&gt; {<br/>        // route to login then close toast<br/>        this.router.navigateByUrl('/login');<br/>        this.toast.Hide();<br/>      }<br/>    },<br/>    // add dismiss as well<br/>    this.toast.dismissButton<br/>  ]<br/>});</span></pre><p id="d4da" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">为适应新的按钮，对 CSS 做了一些小小的添加:</p><pre class="kd ke kf kg gt mm lo mn mo aw mp bi"><span id="143c" class="mq lq in lo b gy mr ms l mt mu">/*allow multiple buttons to appear on one line*/<br/>.buttons {<br/>  display: flex;<br/>}</span></pre><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi od"><img src="../Images/0786bb9b91f0a4cd7bc26561b830c0c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1184/0*XpXl5D-VJGHDAwnC"/></div></figure><h1 id="1aaf" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">自动隐藏</h1><p id="2822" class="pw-post-body-paragraph ko kp in kq b kr mh jo kt ku mi jr kw kx mj kz la lb mk ld le lf ml lh li lj ig bi translated">祝酒词应该在一段时间后自动隐藏，但那要等到下周。谢谢你读到这里，如果你发现了角落里的蜘蛛，请告诉我。</p><p id="8e97" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">最终的项目在<a class="ae lk" href="https://stackblitz.com/edit/angular-error-toast?file=src/app/toast/toast.state.ts" rel="noopener ugc nofollow" target="_blank">的 StackBlitz </a>上。</p><h2 id="d913" class="mq lq in bd lr ns nt dn lv nu nv dp lz kx nw nx mb lb ny nz md lf oa ob mf oc bi translated">控制台系列</h2><ul class=""><li id="c5f3" class="ne nf in kq b kr mh ku mi kx oe lb of lf og lj nj nk nl nm bi translated"><a class="ae lk" href="https://medium.com/@aayyash/writing-a-wrapper-for-console-log-for-better-control-in-javascript-part-i-9bbd238fb9ad" rel="noopener">为 console.log 编写一个包装器以更好地控制 JavaScript，第一部分</a></li><li id="a72b" class="ne nf in kq b kr nn ku no kx np lb nq lf nr lj nj nk nl nm bi translated"><a class="ae lk" rel="noopener ugc nofollow" target="_blank" href="/writing-a-wrapper-for-console-log-for-better-control-in-angular-part-ii-5b09b65af2c5">为 console.log 编写一个包装器，以便更好地控制 Angular，第二部分</a></li><li id="c9e8" class="ne nf in kq b kr nn ku no kx np lb nq lf nr lj nj nk nl nm bi translated"><a class="ae lk" href="https://medium.com/@aayyash/catching-and-handling-errors-in-angular-3ac6b95853ba" rel="noopener">捕捉和处理角度误差</a></li><li id="eb11" class="ne nf in kq b kr nn ku no kx np lb nq lf nr lj nj nk nl nm bi translated"><a class="ae lk" rel="noopener ugc nofollow" target="_blank" href="/catching-and-displaying-ui-errors-with-toast-messages-in-angular-db06f2605a6d">用 toast 消息捕获并显示 UI 错误</a></li><li id="34be" class="ne nf in kq b kr nn ku no kx np lb nq lf nr lj nj nk nl nm bi translated"><a class="ae lk" href="https://medium.com/@aayyash/auto-hiding-a-toast-message-in-angular-54f886ad6129" rel="noopener">自动隐藏有角度的祝酒辞</a></li></ul></div></div>    
</body>
</html>