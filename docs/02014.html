<html>
<head>
<title>JavaScript Best Practices — Spaces, Functions, Negations</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript最佳实践—空格、函数、否定</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/javascript-best-practices-spaces-functions-negations-7fc1ff26e9ee?source=collection_archive---------25-----------------------#2020-07-16">https://blog.devgenius.io/javascript-best-practices-spaces-functions-negations-7fc1ff26e9ee?source=collection_archive---------25-----------------------#2020-07-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/483eb26fa19f398c6aed277424c2cb26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qf8AzPzsNpNbOork"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@r3dmax?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">乔纳森派</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="d15d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了使代码易于阅读和维护，我们应该遵循一些最佳实践。</p><p id="0f90" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这篇文章中，我们将看看我们应该遵循的一些最佳实践，以使每个人的生活更轻松。</p><h1 id="f466" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">循环中没有函数</h1><p id="c3b5" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">循环中的函数会导致错误，因为它们是如何在循环中创建的。</p><p id="9e80" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用<code class="fe me mf mg mh b">var</code>，循环索引总是最后一个，因为它在完成之前不会被传递给变量函数。</p><p id="0a14" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而不是写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="4643" class="mq lc iq mh b gy mr ms l mt mu">for (var i = 0; i &lt; 10; i++) {<br/>  funcs[i] = function() {<br/>    return i;<br/>  };<br/>}</span></pre><p id="747e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="7113" class="mq lc iq mh b gy mr ms l mt mu">for (let i = 0; i &lt; 10; i++) {<br/>  funcs[i] = function() {<br/>    return i;<br/>  };<br/>}</span></pre><p id="6edf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">来获取返回的函数中<code class="fe me mf mg mh b">i</code>的期望值，也就是每次迭代时循环的索引值。</p><p id="d056" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用<code class="fe me mf mg mh b">var</code>，该值将始终为10。</p><h1 id="8b24" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">没有神奇的数字</h1><p id="b4a4" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">幻数很难理解，我们必须在多个地方改变它们，所以我们应该把它们赋给命名的常量。</p><p id="8a91" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而不是写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="58bc" class="mq lc iq mh b gy mr ms l mt mu">const now = Date.now();<br/>const anHourLater = now + (60 * 60 * 1000);</span></pre><p id="15a2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="a24e" class="mq lc iq mh b gy mr ms l mt mu">const SECONDS_IN_HOUR = 60 * 60;</span></pre><h1 id="9095" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">在字符类语法中没有由多个码位组成的字符</h1><p id="b0bb" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们不应该有由多个代码点组成的字符。</p><p id="579d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是因为它们将与任一字符匹配。</p><p id="86c3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以w应该写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="d261" class="mq lc iq mh b gy mr ms l mt mu">/^[a]$/u.test("a")</span></pre><p id="1fa3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而不是:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="68b5" class="mq lc iq mh b gy mr ms l mt mu">/^[Á]$/u.test("Á")</span></pre><h1 id="6fe5" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">没有不同运营商的混合</h1><p id="d60a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">混合不同的操作符是令人困惑的，所以我们不应该这样做。</p><p id="f7d3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="6951" class="mq lc iq mh b gy mr ms l mt mu">const foo = a &amp;&amp; b || c || d;    </span></pre><p id="7355" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用一些括号来分隔表达式:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="aa80" class="mq lc iq mh b gy mr ms l mt mu">const foo = (a &amp;&amp; b) || c || d;</span></pre><h1 id="ab15" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><code class="fe me mf mg mh b">require</code>与常规变量声明混合的调用</h1><p id="7468" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">为了清楚起见，我们没有用逗号分隔常规变量来编写<code class="fe me mf mg mh b">require</code>调用，而是将它们都写在各自的行中。</p><p id="dd0a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="59d4" class="mq lc iq mh b gy mr ms l mt mu">const eventEmitter = require('events').EventEmitter,<br/>  foo = 10,<br/>  bar = 'baz';</span></pre><p id="4d3b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="99a5" class="mq lc iq mh b gy mr ms l mt mu">const eventEmitter = require('events').EventEmitter;<br/>const foo = 10;<br/>let bar = 'baz';</span></pre><h1 id="ba62" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">没有混合空间和缩进标签</h1><p id="36c9" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">混合空格和制表符进行缩进会导致文本编辑器解析和格式化的问题，所以我们应该将制表符转换成空格。</p><h1 id="2f2d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">不使用链式赋值表达式</h1><p id="d421" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">链式赋值表达式将创建全局变量。</p><p id="7666" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不在变量声明关键字旁边的将是全局的。</p><p id="f743" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们也很难阅读。</p><p id="2984" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="f2d5" class="mq lc iq mh b gy mr ms l mt mu">const foo = bar = 0;</span></pre><p id="71a9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么<code class="fe me mf mg mh b">bar</code>是全局的<code class="fe me mf mg mh b">foo</code>是常数。</p><p id="e2e8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，为了清楚起见，我们将它们分开:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="9722" class="mq lc iq mh b gy mr ms l mt mu">const foo = -0;<br/>const bar = 0;</span></pre><h1 id="3331" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">没有多个空格</h1><p id="f8b7" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">除了缩进，一个空格就足够了。</p><p id="495d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们应该为表达式保留一个单独的空间。</p><p id="1ee2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而不是写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="84e9" class="mq lc iq mh b gy mr ms l mt mu">if(foo  === "baz") {}</span></pre><p id="c62a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="4471" class="mq lc iq mh b gy mr ms l mt mu">if(foo === "baz") {}</span></pre><h1 id="8424" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">没有多行字符串</h1><p id="9b6c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们不应该用反斜杠写多行字符串。</p><p id="1c7d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不规范，不好。</p><p id="289c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以与其写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="2a03" class="mq lc iq mh b gy mr ms l mt mu">let x = "line 1 \<br/>  line 2";</span></pre><p id="e063" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="3adb" class="mq lc iq mh b gy mr ms l mt mu">let x = `line 1 <br/>  line 2`;</span></pre><p id="aa86" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于多行字符串，我们使用模板字符串而不是常规字符串。</p><h1 id="dc80" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">没有多个空行</h1><p id="1de2" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">多个空行对于分隔代码没有用。</p><p id="befe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们只需要一个。</p><p id="48d9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以与其写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="d6f3" class="mq lc iq mh b gy mr ms l mt mu">let foo = 5;</span><span id="6559" class="mq lc iq mh b gy mv ms l mt mu">var bar = 3;</span></pre><p id="9f1a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="d4a6" class="mq lc iq mh b gy mr ms l mt mu">let foo = 5;</span><span id="8f92" class="mq lc iq mh b gy mv ms l mt mu">var bar = 3;</span></pre><h1 id="cc47" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">不重新分配本机对象</h1><p id="73ce" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们不应该将本机对象重新分配给任何其他对象。</p><p id="432a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们不希望因此出现任何意外的结果。</p><p id="1890" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以与其写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="577b" class="mq lc iq mh b gy mr ms l mt mu">Object = null<br/>undefined = 1</span></pre><p id="a1e1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="106b" class="mq lc iq mh b gy mr ms l mt mu">let foo = null;<br/>let bar = 1;</span></pre><h1 id="62d5" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">没有否定的条件</h1><p id="1168" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">被否定的条件很难读懂，所以我们应该尽可能地避免它们。</p><p id="dd56" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="21bf" class="mq lc iq mh b gy mr ms l mt mu">if (!a) {<br/>  doSomething();<br/>} else {<br/>  doMore();<br/>}</span></pre><p id="b705" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="f6d2" class="mq lc iq mh b gy mr ms l mt mu">if (a) {<br/>  doSomething();<br/>} else {<br/>  doMore();<br/>}</span></pre><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/1a4f5ff3a4927521fa3dd77f8f2f0023.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7Mh7TFQLM6EIq53T"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">Benoit Gauzere 在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="062a" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="b7d4" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们的代码中不需要多个空格。</p><p id="6d9d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">否定的条件应该用肯定的条件代替。</p><p id="3f2d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">幻数应该用命名的常数代替。</p><p id="76bb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意，我们没有包含具有多个代码点的字符的正则表达式。</p><p id="4bc3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">空格和制表符不能混用。</p></div></div>    
</body>
</html>