<html>
<head>
<title>Code Optimizations when Using Async/Await</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用异步/等待时的代码优化</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/the-fallacy-of-async-await-c0df0f9dd59d?source=collection_archive---------4-----------------------#2022-01-03">https://blog.devgenius.io/the-fallacy-of-async-await-c0df0f9dd59d?source=collection_archive---------4-----------------------#2022-01-03</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="4d8b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Async/Await 已经被引入到 JavaScript 中，以应对称为回调地狱的问题。在 async/await 之前，有几个“中间”解决方案试图解决这个问题:</p><ol class=""><li id="6bf6" class="ki kj in jm b jn jo jr js jv kk jz kl kd km kh kn ko kp kq bi translated">使用<a class="ae kr" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="noopener ugc nofollow" target="_blank">承诺</a></li><li id="f4ff" class="ki kj in jm b jn ks jr kt jv ku jz kv kd kw kh kn ko kp kq bi translated">使用<a class="ae kr" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator" rel="noopener ugc nofollow" target="_blank">发电机</a>和<a class="ae kr" href="https://www.npmjs.com/package/co" rel="noopener ugc nofollow" target="_blank">公司</a>库</li><li id="e152" class="ki kj in jm b jn ks jr kt jv ku jz kv kd kw kh kn ko kp kq bi translated">使用 async/await 作为第二个解决方案的语法糖</li></ol><p id="9ff8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当我们应用解决方案 2 或 3 时，有一个风险<strong class="jm io">是我们没有利用 node.js 的最大卖点。至少在 node.js 获得牵引力时，它是最大的卖点。也就是异步的性质和<a class="ae kr" href="https://nodejs.org/en/docs/guides/blocking-vs-non-blocking/" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io">无阻塞 I/O </strong> </a>。</strong></p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="d977" class="lg lh in lc b gy li lj l lk ll"><strong class="lc io"># Inefficient</strong><br/>let result1 = await fetch('/request1');<br/>let result2 = await fetch('/request2');<br/>doSomeCalculation(result1);</span></pre><p id="8fe9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">正如您在上面的代码中看到的，第二个请求只有在第一个请求得到响应后才会执行，然后程序等待第二个请求完成。只有在第二个请求完成后，才会调用<strong class="jm io">dosomecocalculation</strong>函数。在这两个请求期间，cpu 处于空闲状态。</p><p id="dc49" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">老实说，在大多数情况下这并不重要。谨记:“<em class="lm">过早优化是万恶之源</em>”(参见[01])。无论如何，为了让思维更快，我们可以这样写代码:</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="cbb7" class="lg lh in lc b gy li lj l lk ll"><strong class="lc io"># Efficient</strong><br/>let request1 = fetch('/request1');<br/>let request2 = fetch('/request2');</span><span id="afe9" class="lg lh in lc b gy ln lj l lk ll">let result1 = await request1;<br/>doSomeCalculation(result1);</span><span id="f2d3" class="lg lh in lc b gy ln lj l lk ll">let result2 = await request2;</span></pre><p id="5f46" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这段代码有两个性能优势:</p><ol class=""><li id="0fca" class="ki kj in jm b jn jo jr js jv kk jz kl kd km kh kn ko kp kq bi translated">我们同时发送两个请求，而不等待第一个请求完成。</li><li id="2b60" class="ki kj in jm b jn ks jr kt jv ku jz kv kd kw kh kn ko kp kq bi translated">假设第一个请求完成得比第二个请求快得多，我们已经可以在等待第二个请求完成时利用 CPU 和 doSomeCalculation。在这种情况下，显示的代码优于<em class="lm"> Promise.all([request1，request2]) </em>。</li></ol><p id="9e13" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最诚挚的问候，</p><p id="9632" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">奥利弗，正在制作<a class="ae kr" href="https://www.monsterwriter.app/" rel="noopener ugc nofollow" target="_blank">怪兽写手</a></p><p id="9f95" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">【01】【https://ubiquity.acm.org/article.cfm?】<a class="ae kr" href="https://ubiquity.acm.org/article.cfm?id=1513451#:~:text=Trying%20to%20do%20the%20optimization,best%20practice%20among%20software%20engineers" rel="noopener ugc nofollow" target="_blank">id = 1513451 #:~:text = Trying % 20 to % 20 do % 20 the % 20 optimization，best % 20 practice % 20 in % 20 software % 20 engineers</a>。</strong></p></div></div>    
</body>
</html>