<html>
<head>
<title>5 Things I wish I knew about Apache Airflow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于阿帕奇气流，我希望知道的 5 件事</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/5-things-i-wish-i-knew-about-apache-airflow-c03e09084cf4?source=collection_archive---------4-----------------------#2022-03-24">https://blog.devgenius.io/5-things-i-wish-i-knew-about-apache-airflow-c03e09084cf4?source=collection_archive---------4-----------------------#2022-03-24</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="f374" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在旅程开始时，气流可能很难理解。阅读这些提示来加速你的学习曲线。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/02939f7eea7b378c871eb157b63b760a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_R7WEIneY6v6jbC-NSfHaw.jpeg"/></div></div></figure><h2 id="6595" class="ku kv in bd kw kx ky dn kz la lb dp lc jv ld le lf jz lg lh li kd lj lk ll lm bi translated">任务回调</h2><p id="c69a" class="pw-post-body-paragraph jk jl in jm b jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ig bi translated">一个常见的请求是设置一个警报(无论是在空闲时间、团队等。)如果你的任务失败了。这可以使用<code class="fe ls lt lu lv b">on_failure_callback</code>轻松完成。您只需要传递一个函数，这个函数稍后将使用<code class="fe ls lt lu lv b">context</code>字典参数来调用。<br/>以同样的方式，气流现在提供<code class="fe ls lt lu lv b">on_success_callback</code>、<code class="fe ls lt lu lv b">on_retry_callback,</code>和<code class="fe ls lt lu lv b">sla_miss_callback</code>。如果您感兴趣，请查看官方文档，包括一个不错的示例。</p><p id="221e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> Pro 提示</strong>:也可以使用<code class="fe ls lt lu lv b">functools.partial</code>支持回调的附加参数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure></div><div class="ab cl ly lz hr ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ig ih ii ij ik"><h2 id="b10e" class="ku kv in bd kw kx ky dn kz la lb dp lc jv ld le lf jz lg lh li kd lj lk ll lm bi translated">触发规则</h2><p id="4f52" class="pw-post-body-paragraph jk jl in jm b jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ig bi translated">现在你可能会问<em class="mf">我可以运行一个单独的运营商作为回拨</em>？答案是<em class="mf">没有</em>，但是有办法做到。<br/>一个用例示例是在一个步骤中建立一个集群，在第二个步骤中运行作业，最后拆除集群。这些步骤中的每一步都应该是单独的气流任务。但是您希望确保群集根据您的作业结果独立地被清除。默认情况下，Airflow 会等待所有上游任务成功，您可以使用<code class="fe ls lt lu lv b">trigger_rule</code>来更改行为。</p><p id="4bc0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ls lt lu lv b">all_success</code>是默认的触发规则。在上面的小例子中，我们将简单地使用<code class="fe ls lt lu lv b">all_done</code>规则。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="86bf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">气流提供了更多的触发规则设置，去查看文档。</p></div><div class="ab cl ly lz hr ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ig ih ii ij ik"><h2 id="2b6b" class="ku kv in bd kw kx ky dn kz la lb dp lc jv ld le lf jz lg lh li kd lj lk ll lm bi translated">过去的依赖关系</h2><p id="b1c5" class="pw-post-body-paragraph jk jl in jm b jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ig bi translated">除了任务相关性(用运算符<code class="fe ls lt lu lv b">&gt;&gt; / &lt;&lt;</code>或<code class="fe ls lt lu lv b">set_downstream / set_upstream</code>设置)，您还可以设置过去的相关性。这意味着一个任务实例将依赖于前一个任务实例的状态。气流提供了两种可能性:</p><p id="f09f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ls lt lu lv b">depends_on_past</code> —如果设置为<code class="fe ls lt lu lv b">True</code>，则导致任务实例依赖于其前一个任务实例的成功。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mh"><img src="../Images/6afbd7e528954dad2e1d9fe443517173.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fO7bZspAuvwSvpdSeJzf8g.png"/></div></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk translated">依赖于过去的例子</figcaption></figure><p id="c2b4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在上面的例子中，我们为<code class="fe ls lt lu lv b">templated</code>任务设置了<code class="fe ls lt lu lv b">depends_on_past=True</code>。最后一个<code class="fe ls lt lu lv b">templated</code>任务实例将不会被调度，因为前一个<code class="fe ls lt lu lv b">templated</code>实例没有成功完成。</p><p id="76f3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ls lt lu lv b">wait_for_downstream</code> —如果设置为<code class="fe ls lt lu lv b">True</code>，任务 X 的一个实例将等待任务 X 的前一个实例下游的任务<em class="mf">成功完成后再运行。</em></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mm"><img src="../Images/8e1c6465ca93fb469f891f61f9be7d35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_lGhvSpu6HvDNuho1wt5wg.png"/></div></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk translated">等待下游示例</figcaption></figure><p id="e86b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这个例子中，我们为<code class="fe ls lt lu lv b">sleep</code>任务设置了<code class="fe ls lt lu lv b">wait_for_downstream=True</code>。我们可以观察到第三个<code class="fe ls lt lu lv b">sleep</code>任务没有被调度，因为第二个<code class="fe ls lt lu lv b">templated</code>任务失败了。</p><p id="6d07" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">专业提示:如果你不确定为什么你的任务没有被安排好，去 Airflow UI 点击<code class="fe ls lt lu lv b">Task Instance Details,</code>，在顶部你会看到<code class="fe ls lt lu lv b">Dependencies Blocking Task From Getting Scheduled</code>。</p></div><div class="ab cl ly lz hr ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ig ih ii ij ik"><h2 id="a7ce" class="ku kv in bd kw kx ky dn kz la lb dp lc jv ld le lf jz lg lh li kd lj lk ll lm bi translated">模板和宏</h2><p id="aac0" class="pw-post-body-paragraph jk jl in jm b jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ig bi translated">Airflow 支持 Jinja 模板，这被证明对编写 Dag 非常有用。</p><p id="b51b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">大多数情况下，您可能会利用<code class="fe ls lt lu lv b">{{ ds }}</code>，它是逻辑(以前的执行)日期的模板化变量。不要忘记，逻辑日期是你的时间表间隔的开始。其他一些有用的宏有:</p><p id="5414" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ls lt lu lv b">{{ dag }}</code> — dag 对象</p><p id="a5f4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ls lt lu lv b">{{ task }}</code> —任务对象</p><p id="de2e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ls lt lu lv b">{{ var.value.my_var }}</code> —具有全局定义变量的字典</p><p id="9006" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Airflow 引入了新的模板来实现更好的数据间隔处理，例如，如果您希望使用 SQL 查询来获取整个 dag 间隔的数据，这将非常有用:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk translated">数据间隔模板</figcaption></figure><p id="2df1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对于更高级的用法，可以考虑使用宏。有了宏，你就可以使用一堆 python 库(<code class="fe ls lt lu lv b">datetime</code>、<code class="fe ls lt lu lv b">random</code>、<code class="fe ls lt lu lv b">dateutil</code>等等)。)在你的模板里面。选中此示例，它将打印比逻辑日期早四天的年份:</p><pre class="kj kk kl km gt mn lv mo mp aw mq bi"><span id="505d" class="ku kv in lv b gy mr ms l mt mu">{{ (execution_date — macros.timedelta(days=4)).strftime('%Y') }}</span></pre><p id="99e4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">和往常一样，我建议查看关于模板的<a class="ae mg" href="https://airflow.apache.org/docs/apache-airflow/stable/templates-ref.html" rel="noopener ugc nofollow" target="_blank">文档。</a></p><p id="760f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">请注意，不是每个运算符的所有参数都可以使用模板。您只能对注册在<code class="fe ls lt lu lv b">template_fields</code>操作符<em class="mf"> ' </em> s 属性中的参数执行此操作。点击<code class="fe ls lt lu lv b">Task Instance Details</code>-&gt;-<code class="fe ls lt lu lv b">template_fields</code>，可以在操作员定义或气流界面中找到模板化的字段。</p></div><div class="ab cl ly lz hr ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ig ih ii ij ik"><h2 id="03b0" class="ku kv in bd kw kx ky dn kz la lb dp lc jv ld le lf jz lg lh li kd lj lk ll lm bi translated">丰富的 CLI</h2><p id="820f" class="pw-post-body-paragraph jk jl in jm b jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ig bi translated">Airflow 附带了一组非常丰富的 CLI 命令。从我的经验来看，令人惊讶的是只有少数用户知道它。以下是我的最爱:</p><p id="29cb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ls lt lu lv b">airflow config list/get-value</code> —查看当前气流配置</p><p id="2146" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ls lt lu lv b">airflow dags next-execution</code> —获取 dag 的下一次执行日期时间</p><p id="b83e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ls lt lu lv b">airflow dags show</code> —将 dag 的图形渲染为 PNG 或点文件</p><p id="51d0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ls lt lu lv b">airflow dags test</code> —使用调试器执行给定 dag 和执行日期的单个 dagrun</p><p id="5a12" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ls lt lu lv b">airflow variable list/get</code> —查看当前气流变量</p><p id="2d51" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">更多信息，请查看关于气流 CLI 的<a class="ae mg" href="https://airflow.apache.org/docs/apache-airflow/stable/cli-and-env-variables-ref.html" rel="noopener ugc nofollow" target="_blank">文档。</a></p></div><div class="ab cl ly lz hr ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ig ih ii ij ik"><p id="e6c3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">感谢您阅读这个故事。别忘了订阅我的频道，获取来自数据工程和云的最新新闻和提示&amp;技巧。</p></div></div>    
</body>
</html>