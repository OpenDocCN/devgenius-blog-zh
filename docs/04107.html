<html>
<head>
<title>Using MongoDB with Mongoose — Populate Virtuals</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用MongoDB和mongose——填充虚拟机</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/using-mongodb-with-mongoose-populate-virtuals-91710f066de7?source=collection_archive---------2-----------------------#2021-01-26">https://blog.devgenius.io/using-mongodb-with-mongoose-populate-virtuals-91710f066de7?source=collection_archive---------2-----------------------#2021-01-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/170019e76b7a7cdb4217ac9405e4084f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9YcKNUoJ7_AStdIy"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">由<a class="ae kc" href="https://unsplash.com/@veverkolog?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">杜安·斯美塔纳</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="4295" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了简化MongoDB数据库操作，我们可以使用mongose NPM包来简化MongoDB数据库的操作。</p><p id="0b19" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将了解如何使用Mongoose来操作我们的MongoDB数据库。</p><h1 id="92d0" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">填充虚拟</h1><p id="1d1c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以控制两个模型如何连接在一起。</p><p id="a553" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="aa7f" class="mn lc iq mj b gy mo mp l mq mr">async function run() {<br/>  const { createConnection, Types, Schema } = require('mongoose');<br/>  const db = createConnection('mongodb://localhost:27017/test');<br/>  const PersonSchema = new Schema({<br/>    name: String,<br/>    band: String<br/>  });</span><span id="16e3" class="mn lc iq mj b gy ms mp l mq mr">  const BandSchema = new Schema({<br/>    name: String<br/>  });</span><span id="dd30" class="mn lc iq mj b gy ms mp l mq mr">  BandSchema.virtual('members', {<br/>    ref: 'Person',<br/>    localField: 'name',<br/>    foreignField: 'band',<br/>    justOne: false,<br/>    options: { sort: { name: -1 }, limit: 5 }<br/>  });</span><span id="28d3" class="mn lc iq mj b gy ms mp l mq mr">  const Person = db.model('Person', PersonSchema);<br/>  const Band = db.model('Band', BandSchema);<br/>  const person = new Person({ name: 'james', band: 'superband' });<br/>  await person.save();<br/>  const band = new Band({ name: 'superband' });<br/>  await band.save();<br/>  const bands = await Band.find({}).populate('members').exec();<br/>  console.log(bands[0].members);<br/>}<br/>run();</span></pre><p id="9eb5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们照常创建<code class="fe mt mu mv mj b">PersonSchema</code>，但是<code class="fe mt mu mv mj b">BandSchema</code>是不同的。</p><p id="05f6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们调用带有连接字段调用<code class="fe mt mu mv mj b">members</code>的<code class="fe mt mu mv mj b">virtual</code>方法，将带有<code class="fe mt mu mv mj b">band</code>名字的人设置为给定的名字。</p><p id="367d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mj b">ref</code>属性是我们想要加入的模型的名称。</p><p id="da42" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mj b">localField</code>是我们想要与<code class="fe mt mu mv mj b">PersonSchema</code>连接的<code class="fe mt mu mv mj b">BandSchema</code>的字段。</p><p id="0cf9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mj b">foreignField</code>是<code class="fe mt mu mv mj b">PersonSchema</code>的字段，我们希望将其与<code class="fe mt mu mv mj b">BandSchema</code>连接起来。</p><p id="4477" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mj b">justOne</code>意味着我们只返回连接的第一个条目。</p><p id="6a09" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mj b">options</code>有查询选项。</p><p id="2f23" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">默认情况下，<code class="fe mt mu mv mj b">toJSON()</code>输出中不包含虚拟。</p><p id="249f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们想在使用依赖于<code class="fe mt mu mv mj b">JSON.stringify()</code>的函数时填充虚拟显示，那么添加<code class="fe mt mu mv mj b">virtuals</code>选项并将其设置为<code class="fe mt mu mv mj b">true</code>。</p><p id="e4f7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="6146" class="mn lc iq mj b gy mo mp l mq mr">async function run() {<br/>  const { createConnection, Types, Schema } = require('mongoose');<br/>  const db = createConnection('mongodb://localhost:27017/test');<br/>  const PersonSchema = new Schema({<br/>    name: String,<br/>    band: String<br/>  });</span><span id="6f17" class="mn lc iq mj b gy ms mp l mq mr">  const BandSchema = new Schema({<br/>    name: String<br/>  }, { toJSON: { virtuals: true } });</span><span id="8fe5" class="mn lc iq mj b gy ms mp l mq mr">  BandSchema.virtual('members', {<br/>    ref: 'Person',<br/>    localField: 'name',<br/>    foreignField: 'band',<br/>    justOne: false,<br/>    options: { sort: { name: -1 }, limit: 5 }<br/>  });</span><span id="24df" class="mn lc iq mj b gy ms mp l mq mr">  const Person = db.model('Person', PersonSchema);<br/>  const Band = db.model('Band', BandSchema);<br/>  const person = new Person({ name: 'james', band: 'superband' });<br/>  await person.save();<br/>  const band = new Band({ name: 'superband' });<br/>  await band.save();<br/>  const bands = await Band.find({}).populate('members').exec();<br/>  console.log(bands[0].members);<br/>}<br/>run();</span></pre><p id="6bf0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">将<code class="fe mt mu mv mj b">virtuals</code>选项添加到<code class="fe mt mu mv mj b">BandSchema</code>中。</p><p id="f595" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们使用填充投影，那么<code class="fe mt mu mv mj b">foreignField</code>应该包含在投影中:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="d0de" class="mn lc iq mj b gy mo mp l mq mr">async function run() {<br/>  const { createConnection, Types, Schema } = require('mongoose');<br/>  const db = createConnection('mongodb://localhost:27017/test');<br/>  const PersonSchema = new Schema({<br/>    name: String,<br/>    band: String<br/>  });</span><span id="212a" class="mn lc iq mj b gy ms mp l mq mr">  const BandSchema = new Schema({<br/>    name: String<br/>  }, { toJSON: { virtuals: true } });</span><span id="724a" class="mn lc iq mj b gy ms mp l mq mr">  BandSchema.virtual('members', {<br/>    ref: 'Person',<br/>    localField: 'name',<br/>    foreignField: 'band',<br/>    justOne: false,<br/>    options: { sort: { name: -1 }, limit: 5 }<br/>  });</span><span id="a201" class="mn lc iq mj b gy ms mp l mq mr">  const Person = db.model('Person', PersonSchema);<br/>  const Band = db.model('Band', BandSchema);<br/>  const person = new Person({ name: 'james', band: 'superband' });<br/>  await person.save();<br/>  const band = new Band({ name: 'superband' });<br/>  await band.save();<br/>  const bands = await Band.find({}).populate({ path: 'members', select: 'name band' }).exec();<br/>  console.log(bands[0].members);<br/>}<br/>run();</span></pre><p id="e502" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用一个带有<code class="fe mt mu mv mj b">path</code>的对象调用<code class="fe mt mu mv mj b">populate</code>来获取虚拟字段，而<code class="fe mt mu mv mj b">select</code>属性有一个字符串，其中包含我们希望用空格分隔的字段名。</p><h1 id="796a" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="c887" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用Mongoose填充虚拟特性，通过一个列而不是一个ID列来连接两个模型。</p></div></div>    
</body>
</html>