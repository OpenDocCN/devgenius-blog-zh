<html>
<head>
<title>Gatsby.js — GraphQL Queries</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Gatsby.js — GraphQL 查询</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/gatsby-js-graphql-queries-f0f1d8bb3062?source=collection_archive---------3-----------------------#2021-02-06">https://blog.devgenius.io/gatsby-js-graphql-queries-f0f1d8bb3062?source=collection_archive---------3-----------------------#2021-02-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/5a2940ade9caeb72efb79ac4a4d45492.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FXVgOhIi8jqoiH_5"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">卢克·切瑟在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="7125" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Gatsby 是一个基于 React 的静态网站框架。</p><p id="f7a9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以用它从外部数据源创建静态网站等等。</p><p id="fb08" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将看看如何用 Gatsby 创建一个站点。</p><h1 id="5745" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">限制</h1><p id="0771" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以限制 GraphQL 查询结果中返回的结果数量。</p><p id="e1ec" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="fb9b" class="mn lc iq mj b gy mo mp l mq mr">{<br/>  allMarkdownRemark(limit: 3) {<br/>    totalCount<br/>    edges {<br/>      node {<br/>        frontmatter {<br/>          title<br/>        }<br/>      }<br/>    }<br/>  }<br/>}</span></pre><p id="7e1f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用<code class="fe ms mt mu mj b">title</code>字段获取前 3 个降价帖子。</p><h1 id="b925" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">跳跃</h1><p id="9e35" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用<code class="fe ms mt mu mj b">skip</code>参数跳过一些结果:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="88ef" class="mn lc iq mj b gy mo mp l mq mr">{<br/>  allMarkdownRemark(skip: 3) {<br/>    totalCount<br/>    edges {<br/>      node {<br/>        frontmatter {<br/>          title<br/>        }<br/>      }<br/>    }<br/>  }<br/>}</span></pre><h1 id="b0c4" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">过滤器</h1><p id="d4ef" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用<code class="fe ms mt mu mj b">filter</code>参数过滤结果:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="d301" class="mn lc iq mj b gy mo mp l mq mr">{<br/>  allMarkdownRemark(filter: {frontmatter: {title: {ne: ""}}}) {<br/>    totalCount<br/>    edges {<br/>      node {<br/>        frontmatter {<br/>          title<br/>        }<br/>      }<br/>    }<br/>  }<br/>}</span></pre><p id="d270" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将<code class="fe ms mt mu mj b">filtet</code>设置为一个对象，其<code class="fe ms mt mu mj b">title</code>不等于<code class="fe ms mt mu mj b">frontmatter</code>中的空字符串。</p><p id="32cb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以结合多个领域。</p><p id="8433" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="4833" class="mn lc iq mj b gy mo mp l mq mr">{<br/>  allMarkdownRemark(filter: {frontmatter: {title: {ne: ""}}, wordCount: {words: {gte: 1}}}) {<br/>    totalCount<br/>    edges {<br/>      node {<br/>        frontmatter {<br/>          title<br/>        }<br/>      }<br/>    }<br/>  }<br/>}</span></pre><p id="d21f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">搜索标题不等于空字符串且字数大于或等于 1 的降价帖子。</p><h1 id="d930" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">经营者</h1><p id="7d3c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">运营商的完整列表包括:</p><ul class=""><li id="c124" class="mv mw iq kf b kg kh kk kl ko mx ks my kw mz la na nb nc nd bi translated"><code class="fe ms mt mu mj b">eq</code>:等号的简称，必须与给定数据完全匹配</li><li id="21e3" class="mv mw iq kf b kg ne kk nf ko ng ks nh kw ni la na nb nc nd bi translated"><code class="fe ms mt mu mj b">ne</code>:不等于的简称，必须与给定数据不同</li><li id="f109" class="mv mw iq kf b kg ne kk nf ko ng ks nh kw ni la na nb nc nd bi translated"><code class="fe ms mt mu mj b">regex</code>:正则表达式的简称，必须匹配给定的模式。注意反斜杠需要转义两次，所以<code class="fe ms mt mu mj b">/\w+/</code>需要写成<code class="fe ms mt mu mj b">"/\\\\w+/"</code>。</li><li id="6ccc" class="mv mw iq kf b kg ne kk nf ko ng ks nh kw ni la na nb nc nd bi translated"><code class="fe ms mt mu mj b">glob</code>:global 的缩写，允许我们使用通配符<code class="fe ms mt mu mj b">*</code>，作为任何非空字符串的占位符</li><li id="be5b" class="mv mw iq kf b kg ne kk nf ko ng ks nh kw ni la na nb nc nd bi translated"><code class="fe ms mt mu mj b">in</code>:数组中的简称，必须是数组的一个元素</li><li id="58cf" class="mv mw iq kf b kg ne kk nf ko ng ks nh kw ni la na nb nc nd bi translated"><code class="fe ms mt mu mj b">nin</code>:not in a array 的简称，不能是数组的元素</li><li id="8dd9" class="mv mw iq kf b kg ne kk nf ko ng ks nh kw ni la na nb nc nd bi translated"><code class="fe ms mt mu mj b">gt</code>:大于的简称，必须大于给定值</li><li id="6f0f" class="mv mw iq kf b kg ne kk nf ko ng ks nh kw ni la na nb nc nd bi translated"><code class="fe ms mt mu mj b">gte</code>:大于等于的简称，必须大于等于给定值</li><li id="f1ab" class="mv mw iq kf b kg ne kk nf ko ng ks nh kw ni la na nb nc nd bi translated"><code class="fe ms mt mu mj b">lt</code>:小于的简称，必须小于给定值</li><li id="7253" class="mv mw iq kf b kg ne kk nf ko ng ks nh kw ni la na nb nc nd bi translated"><code class="fe ms mt mu mj b">lte</code>:小于或等于的简称，必须小于或等于给定值</li><li id="b207" class="mv mw iq kf b kg ne kk nf ko ng ks nh kw ni la na nb nc nd bi translated"><code class="fe ms mt mu mj b">elemMatch</code>:元素匹配的简称。我们用这个运算符找到与给定值匹配的元素。</li></ul><h1 id="b7b4" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">分类</h1><p id="6f7b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以对结果中返回的项目进行排序。</p><p id="bc3f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为此，我们写道:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="2603" class="mn lc iq mj b gy mo mp l mq mr">{<br/>  allMarkdownRemark(sort: {fields: [frontmatter___date], order: ASC}) {<br/>    totalCount<br/>    edges {<br/>      node {<br/>        frontmatter {<br/>          title<br/>          date<br/>        }<br/>      }<br/>    }<br/>  }<br/>}</span></pre><p id="38a5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">添加<code class="fe ms mt mu mj b">order</code>字段，让我们对<code class="fe ms mt mu mj b">frontmatter.date</code>字段进行排序。</p><h1 id="d655" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">格式化日期</h1><p id="7b36" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以格式化我们的结果。为了格式化日期，我们写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="e159" class="mn lc iq mj b gy mo mp l mq mr">{<br/>  allMarkdownRemark(filter: {frontmatter: {date: {ne: null}}}) {<br/>    edges {<br/>      node {<br/>        frontmatter {<br/>          title<br/>          date(formatString: "dddd DD MMMM YYYY")<br/>        }<br/>      }<br/>    }<br/>  }<br/>}</span></pre><p id="3847" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到完整的日期，大概是:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="bfc1" class="mn lc iq mj b gy mo mp l mq mr">{<br/>  "data": {<br/>    "allMarkdownRemark": {<br/>      "edges": [<br/>        {<br/>          "node": {<br/>            "frontmatter": {<br/>              "title": "My First Post",<br/>              "date": "Wednesday 10 July 2019"<br/>            }<br/>          }<br/>        }<br/>      ]<br/>    }<br/>  },<br/>  "extensions": {}<br/>}</span></pre><h1 id="d212" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="0a88" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用 Gatsby 的 GraphQL API 进行各种查询。</p></div></div>    
</body>
</html>