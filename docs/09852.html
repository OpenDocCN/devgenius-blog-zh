<html>
<head>
<title>Learning Go, A Journey: Channel #6</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习围棋之旅:第六频道</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/learning-go-a-journey-channel-6-939850c57fb1?source=collection_archive---------10-----------------------#2022-09-17">https://blog.devgenius.io/learning-go-a-journey-channel-6-939850c57fb1?source=collection_archive---------10-----------------------#2022-09-17</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="c069" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">大家好！很高兴再次见到你，我希望你过得很好。在这篇文章中，我想分享我在学习 Go 编程语言方面的进步。这一周，我了解了渠道。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d29fbb529cbfbde890fc09ada93a7f38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ah1QwyAZ1rumeJpqo1ehIQ.png"/></div></div></figure><h1 id="932e" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">什么是渠道？</h1><p id="6385" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">Go 创建者将通道定义为“通道通过发送和接收指定元素类型的值来提供并发执行功能以进行通信的机制。未初始化通道的值为零。为了创建一个通道，我们使用内置函数“make”</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lx"><img src="../Images/f609ccfce116195999eac8b94b193500.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mIdUh54ZgSNSe_59"/></div></div></figure><p id="1c8e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">从上图中，我们可以通过将通道类型(本例中为整数)定义为参数来创建通道。频道就像一场接力赛，参赛者必须同时传递和接受接力棒。例如</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lx"><img src="../Images/18fcc2bf1b09b8864cb50d911fdcab17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-K6T3HIKCQuRtPJl"/></div></div></figure><p id="2ff3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们可以使用指向通道的箭头向通道发送一个值。要接收一个值，我们可以使用一个从通道指向外的箭头。但是请注意，我们必须发送来自另一个 goroutine 的值。这是因为如果我们在同一个 goroutine(在本例中是主 goroutine)中运行它，程序将返回一个致命错误。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lx"><img src="../Images/90e19213249fb4e1b67a7d147a045341.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-_HQI0iLUX7Cspu-"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ly"><img src="../Images/64aac248044883a16ba312650353c492.png" data-original-src="https://miro.medium.com/v2/resize:fit:866/0*8VDL_ypTzQS1j1tw"/></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk translated">输出</figcaption></figure><p id="587b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们能够向通道发送尽可能多的值。那么，如何限制一个通道内的值的数量呢？我们可以使用缓冲通道。例如</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lx"><img src="../Images/630067debc5eb901987f4df95fe87f00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Uey8tsnIq6MaJEtL"/></div></div></figure><p id="e864" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">请注意，我们不必在另一个 goroutine 中运行它。这是因为之前已经定义了通道的长度(即 2)。如果我们向通道发送 2 个以上的值，它将返回一个错误。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lx"><img src="../Images/de5c07821dfcedd859da19549af9cf0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*sKc3Kjor3g77mlha"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi md"><img src="../Images/7d38b2dcc3afdb23f6d3aea3671f8aa5.png" data-original-src="https://miro.medium.com/v2/resize:fit:860/0*_pQx8U6aHn9-8f9U"/></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk translated">输出</figcaption></figure><h1 id="1e08" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">定向信道</h1><p id="46d4" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">频道有 3 种类型:</p><h2 id="b8de" class="me kv in bd kw mf mg dn la mh mi dp le jv mj mk li jz ml mm lm kd mn mo lq mp bi translated">双向通道</h2><p id="dd4a" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">双向通道意味着我们可以接收或发送到通道。我上面讨论的例子是一个双向通道。</p><h2 id="c892" class="me kv in bd kw mf mg dn la mh mi dp le jv mj mk li jz ml mm lm kd mn mo lq mp bi translated">仅发送通道</h2><p id="cb43" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">只发送通道意味着我们只能向一个通道发送一个值。要创建它，我们必须放置一个指向通道的箭头。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lx"><img src="../Images/093d31136798dfa36fe173e9b1f7716c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8SEp5v9_cpd4pETi"/></div></div></figure><p id="826c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果我们试图从只发送的通道接收一个值，它将返回一个错误。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lx"><img src="../Images/6f6717fc81e43c898317c54ca7ebedd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*o4eHpat8JGMjGmjW"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mq"><img src="../Images/dfd70d5d06627313666d385fb9a23062.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_8pfkKy4iHvaCqav"/></div></div></figure><h2 id="f672" class="me kv in bd kw mf mg dn la mh mi dp le jv mj mk li jz ml mm lm kd mn mo lq mp bi translated">只收信道</h2><p id="0a37" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">只接收通道意味着我们只能从一个通道接收值。例如</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lx"><img src="../Images/db37737fcad3a5f96ab698148e50e60b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FYXcQKLrCA5YsAoA"/></div></div></figure><p id="0334" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果我们试图向只接收的通道发送一个值，程序将返回一个错误</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lx"><img src="../Images/dffd3484ddd61bc64f05a25472c84191.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QuB6WWaopYHeZsoh"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mr"><img src="../Images/2e083a93283a34b2a72684add3b6b966.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*EVIjvmLGAGCEhFv2"/></div></div></figure><h1 id="ad41" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">航道范围</h1><p id="6c55" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">我们可以通过使用“for range”子句来对一个通道进行测距。例如</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lx"><img src="../Images/ee7ae5931fb37a576bc7ce401df7955d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hhVwclZXLg7wlmp8"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/37534369858871d3907f88b78dc8c560.png" data-original-src="https://miro.medium.com/v2/resize:fit:282/0*Vty8_QoKLVnp6oLP"/></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk translated">输出</figcaption></figure><p id="2459" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">正如我们所看到的，我们可以在向通道发送值的同时覆盖通道。而当值达到 4 时，我们可以返回或退出程序。</p><h1 id="2833" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">挑选</h1><blockquote class="mt mu mv"><p id="a520" class="jk jl mw jm b jn jo jp jq jr js jt ju mx jw jx jy my ka kb kc mz ke kf kg kh ig bi translated">select 语句让 goroutine 等待多个通信操作。select 阻塞，直到它的一个事例可以运行，然后它执行那个事例。如果多个都准备好了，它会随机选择一个。— Go 文档</p></blockquote><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lx"><img src="../Images/3e96723bb647c05d75051caca640411e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gXcMOmBDlQw3jCmG"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi na"><img src="../Images/adbc6149f29b4d77c742735e6abedb0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:284/0*hJeUGVw1irxIbpwH"/></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk translated">输出</figcaption></figure><p id="1cf6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">正如我们所看到的，select 块将检查任何可以运行的案例。为了退出无限循环，我们可以创建一个新的 case 来检查插入是否已经结束。</p><h2 id="5d2c" class="me kv in bd kw mf mg dn la mh mi dp le jv mj mk li jz ml mm lm kd mn mo lq mp bi translated">逗号 ok 习语</h2><p id="e35c" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">另一种检查我们是否完成了向通道发送值的方法是使用逗号 ok 习语。例如</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lx"><img src="../Images/8fb71954b8eeb8efeedbf03de8c75e47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qDtZVE3zAu1tWJ5g"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/9df6e1070dcd14d25c4457f9798a9f02.png" data-original-src="https://miro.medium.com/v2/resize:fit:264/0*xEMBEPhRozqXCPBV"/></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk translated">输出</figcaption></figure><h1 id="9fa8" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">扇入</h1><p id="bac8" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">扇入是指我们有两个不同的通道，并希望将它们合并为一个通道。例如</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lx"><img src="../Images/e90e990ebd1e1513fc6336c306608ed3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vT_EtX_52sQsY238"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/5477a41afc07acfcca2fc35957d3c447.png" data-original-src="https://miro.medium.com/v2/resize:fit:278/0*ZlXfziHLQzJ2-etz"/></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk translated">输出</figcaption></figure><h1 id="d83d" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">扇出</h1><p id="05d1" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">扇出与扇入相反，扇入是指我们将一个通道中的值分成几个通道。例如</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lx"><img src="../Images/f11af3b07f4ed7d99dfd7c0744c4c07a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*KAmJgGkGSKS3vqu-"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/938f7e0faf6d6ece8db60bf1ffa3d2d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:266/0*p2ynDs4XrZj9DF20"/></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk translated">产出</figcaption></figure><h1 id="a68d" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">节流</h1><p id="e3a6" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">节流是当我们限制 goroutines 运行的数量时。通过使用这个，我们可以控制我们想要使用多少资源。例如</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lx"><img src="../Images/85c72f100ffbe2d3d2c3a6150d1b64ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kpdFXrL4vSBob7Kz"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/9e90bb061adcc9f2b97781024a62dd59.png" data-original-src="https://miro.medium.com/v2/resize:fit:290/0*ZwE7bMJvG7B3VWlw"/></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk translated">产出</figcaption></figure><p id="0985" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">正如我们所看到的，我们通过增加我们想要的 goro tine 的数量(在本例中为 10)来限制运行的 goro tine 的数量。</p><h1 id="76db" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">语境</h1><p id="5318" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">上下文用于解决 goroutine 泄漏。例如，有一个进程部署了几个 goro tine，当该进程结束时，您也希望取消所有正在运行的 goro tine。所以我们用上下文来说明。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lx"><img src="../Images/a318a96467267508cdb9f74d8247dafe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dQO0AJavfD6Taj7p"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/cfb8a19739f3f015467f808a8f2af26f.png" data-original-src="https://miro.medium.com/v2/resize:fit:758/0*_jOgMDQRdYYVz08-"/></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk translated">产出</figcaption></figure><p id="0331" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们可以看到，当我们用数字填充频道时，几个 goroutines 同时运行。完成后，我们可以取消上下文运行来清理 goroutines。</p></div><div class="ab cl ng nh hr ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="ig ih ii ij ik"><p id="6ffa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">本文到此为止，不要忘记留下一个喜欢并与他人分享。如果你有任何反馈，我将很高兴，如果你在下面留下评论。感谢大家阅读这篇文章，祝大家过得愉快👋。</p><p id="d78a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">资源</p><ul class=""><li id="61bf" class="nn no in jm b jn jo jr js jv np jz nq kd nr kh ns nt nu nv bi translated"><a class="ae nw" href="https://www.udemy.com/course/learn-how-to-code/" rel="noopener ugc nofollow" target="_blank">学习如何编程:谷歌的 Go (golang)编程语言</a></li><li id="ad5d" class="nn no in jm b jn nx jr ny jv nz jz oa kd ob kh ns nt nu nv bi translated"><a class="ae nw" href="https://go.dev/ref/spec" rel="noopener ugc nofollow" target="_blank">Go 编程语言规范</a></li><li id="cf90" class="nn no in jm b jn nx jr ny jv nz jz oa kd ob kh ns nt nu nv bi translated"><a class="ae nw" href="https://go.dev/tour/concurrency/5" rel="noopener ugc nofollow" target="_blank">格朗精选</a></li></ul></div></div>    
</body>
</html>