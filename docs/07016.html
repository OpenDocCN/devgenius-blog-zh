<html>
<head>
<title>Linux — High Disk I/O Troubleshoot</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Linux —高磁盘 I/O 故障排除</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/linux-high-disk-i-o-troubleshoot-368b98b4be1a?source=collection_archive---------8-----------------------#2022-02-19">https://blog.devgenius.io/linux-high-disk-i-o-troubleshoot-368b98b4be1a?source=collection_archive---------8-----------------------#2022-02-19</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><div class=""><h2 id="fecb" class="pw-subtitle-paragraph jo iq ir bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated">高级 Linux 磁盘 I/O 故障排除技能</h2></div><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj kg"><img src="../Images/e910408353b70ece573f9b3649fb4f68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IYQK_NU_WvbqYH_mpvvhFQ.png"/></div></div></figure><p id="8e0c" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">在我以前的文章中，我谈到了“Linux —磁盘 I/O 性能”，让我们今天做一些练习，并从一个高磁盘 I/O 故障排除用例中获得乐趣。</p><h1 id="2997" class="lo lp ir bd lq lr ls lt lu lv lw lx ly jx lz jy ma ka mb kb mc kd md ke me mf bi translated">案例准备</h1><p id="67b9" class="pw-post-body-paragraph ks kt ir ku b kv mg js kx ky mh jv la lb mi ld le lf mj lh li lj mk ll lm ln ik bi translated">让我们在 Linux 主机上运行以下 docker 容器来模拟一些高磁盘 I/O 场景:</p><pre class="kh ki kj kk gu ml mm mn mo aw mp bi"><span id="dd96" class="mq lp ir mm b gz mr ms l mt mu">$ docker run --name=app -p 80:80 -itd tonylixu/word-pop<br/>9bc4614419bc606064b3d35c5ba86be3fb55617dcd0e61791b4326f6df7c8c37</span><span id="21ea" class="mq lp ir mm b gz mv ms l mt mu">$ docker ps<br/>CONTAINER ID   IMAGE             COMMAND            CREATED         STATUS         PORTS                               NAMES<br/>9bc4614419bc   feisky/word-pop   "python /app.py"   6 minutes ago   Up 6 minutes   0.0.0.0:80-&gt;80/tcp, :::80-&gt;80/tcp   app</span></pre><p id="3cc9" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">一旦容器启动并运行，让我们使用<code class="fe mw mx my mm b">curl</code>命令访问 URL“http://127 . 0 . 0 . 1 ”:</p><pre class="kh ki kj kk gu ml mm mn mo aw mp bi"><span id="a92c" class="mq lp ir mm b gz mr ms l mt mu">$ curl <a class="ae mz" href="http://127.0.0.1" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1</a><br/>hello world</span></pre><p id="5036" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">我们可以看到案件正常开始。现在让我们查询一个特定的端点:</p><pre class="kh ki kj kk gu ml mm mn mo aw mp bi"><span id="a37f" class="mq lp ir mm b gz mr ms l mt mu">$ time curl <a class="ae mz" href="http://127.0.0.1/popularity/word" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1/popularity/word</a><br/>{<br/>  "popularity": 0.0,<br/>  "word": "word"<br/>}</span><span id="1a73" class="mq lp ir mm b gz mv ms l mt mu">real 0m44.134s<br/>user 0m0.000s<br/>sys 0m0.008s</span></pre><p id="4eaa" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">从上面的结果可以看出，it 工具<code class="fe mw mx my mm b">44</code>秒就把结果拿回来了！这是怎么回事？为什么查询需要这么长时间？</p><h1 id="5069" class="lo lp ir bd lq lr ls lt lu lv lw lx ly jx lz jy ma ka mb kb mc kd md ke me mf bi translated">案例故障排除</h1><p id="92d7" class="pw-post-body-paragraph ks kt ir ku b kv mg js kx ky mh jv la lb mi ld le lf mj lh li lj mk ll lm ln ik bi translated">您可能认为这与网络有关，但是在我们深入研究之前，让我们使用<code class="fe mw mx my mm b">top</code>命令来观察系统性能:</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj na"><img src="../Images/86de9f70d760d7f8e0321bab30b4cba8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_RbXbRaB9naj8OeNo0hhyA.png"/></div></div></figure><p id="6723" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">查看 top 的输出，可以看到两个 CPU 的 iowait 都很高。尤其是 CPU1，iowait 达到了 80%，还有 2.2GB 剩余内存，看起来足够了。</p><p id="7013" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">再往下看，process 节中 PID 为 3920 的 python 进程的 CPU 使用率略高，达到 28%。虽然 28%不是性能瓶颈，但是有点可疑——可能和<code class="fe mw mx my mm b">iowait</code>增加有关。</p><p id="653e" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">让我们执行一个<code class="fe mw mx my mm b">ps</code>命令:</p><pre class="kh ki kj kk gu ml mm mn mo aw mp bi"><span id="4407" class="mq lp ir mm b gz mr ms l mt mu">$ ps aux | grep 3920<br/>root      3920 13.1  0.7 103860 29232 pts/0    Sl+  15:14   2:46 /usr/local/bin/python /app.py</span></pre><p id="67e2" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">从 ps 的输出可以看出，这个 CPU 使用率很高的进程正是我们的案例应用。但是先不要急着分析 CPU 的问题，因为此时 CPU 使用率还没有达到临界高，已经达到 90%的<code class="fe mw mx my mm b">iowait</code>是我们的第一个解决方案。</p><p id="6a17" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">接下来，让我们使用<code class="fe mw mx my mm b">iostat</code>命令继续我们的 I/O 分析:</p><ul class=""><li id="a103" class="nb nc ir ku b kv kw ky kz lb nd lf ne lj nf ln ng nh ni nj bi translated"><code class="fe mw mx my mm b">-d</code> : I/O 性能指示器</li><li id="95fc" class="nb nc ir ku b kv nk ky nl lb nm lf nn lj no ln ng nh ni nj bi translated"><code class="fe mw mx my mm b">-x</code>:显示扩展统计数据</li></ul><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj np"><img src="../Images/1a9b259fe90e61ba8746a4d8e5b67fbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DNMiQBN7gbT4fvM6eaa7Hw.png"/></div></div></figure><p id="d8e2" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">从<code class="fe mw mx my mm b">iostat</code>的输出中，我们观察到<code class="fe mw mx my mm b">wKB/s</code>相当高，62MB/秒，磁盘<code class="fe mw mx my mm b">xvda</code>的 I/O 使用率为 100%。显然，我们正在经历 I/O 饱和。此外，发出的写请求的平均队列长度是 34.85，也是一个很高的数字。</p><p id="21c1" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">所以现在的问题是，我们如何知道哪个进程导致了 I/O 问题？我们有一个 PID 为 3920 的可疑 Python 进程，但是我们如何确定 Python 进程是 I/O 杀手呢？</p><p id="eca1" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">让我们使用<code class="fe mw mx my mm b">pidstat</code>来检查流程:</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj nq"><img src="../Images/f976ecefd2e987986521fc2baeca4551.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GuXZS5WdX_OQ8168IrYfkA.png"/></div></div></figure><p id="7056" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">从上面的输出中，我们可以看到是 3920 Python 进程导致了 I/O 性能瓶颈。</p><p id="9d6d" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">至此，你大概觉得下一步很简单。我们可以只使用<code class="fe mw mx my mm b">strace</code>确认是否是写文件，然后使用<code class="fe mw mx my mm b">lsof</code>找到文件描述符对应的文件。然后我们修改代码并重新部署应用程序。</p><p id="c9a6" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">不错的主意，让我们试试:</p><pre class="kh ki kj kk gu ml mm mn mo aw mp bi"><span id="e901" class="mq lp ir mm b gz mr ms l mt mu">$ strace -p 3920 2&gt;&amp;1 | grep write<br/>...hangs</span></pre><p id="bcef" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">遗憾的是，没有与任何<code class="fe mw mx my mm b">write</code>系统调用相关的输出。此时，你可能会问，这是怎么回事？为什么根本没有<code class="fe mw mx my mm b">write</code>系统调用？如果没有<code class="fe mw mx my mm b">write</code>系统调用，这个进程 3920 怎么会导致 I/O 问题呢？这不奇怪吗？</p><p id="e5ce" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">对于文件写，应该有相应的写系统调用，但是用现有的工具找不到踪迹。这个时候就该考虑换工具的问题了。我怎么知道文件被写到哪里？</p><p id="8094" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">让我们使用<code class="fe mw mx my mm b">filetop</code>(<a class="ae mz" href="https://github.com/iovisor/bcc/blob/master/tools/filetop.py" rel="noopener ugc nofollow" target="_blank">https://github.com/iovisor/bcc/blob/master/tools/filetop.py</a>)，一个跟踪内核读写文件的新工具。您可以在我刚才提供的链接中找到安装说明。</p><p id="fc18" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">安装完成后，让我们运行<code class="fe mw mx my mm b">filetop</code></p><pre class="kh ki kj kk gu ml mm mn mo aw mp bi"><span id="fa00" class="mq lp ir mm b gz mr ms l mt mu">$ filetop -C<br/>15:57:06 loadavg: 2.22 2.20 1.77 1/193 21777</span><span id="4ec8" class="mq lp ir mm b gz mv ms l mt mu">TID    COMM             READS  WRITES R_Kb    W_Kb    T FILE<br/>21776  python           0      1      0       4882    R 594.txt<br/>21776  python           0      1      0       4736    R 583.txt<br/>21776  python           0      1      0       4589    R 582.txt<br/>21776  python           0      1      0       4394    R 580.txt<br/>21776  python           0      1      0       3857    R 576.txt<br/>21776  python           0      1      0       3808    R 592.txt<br/>21776  python           0      1      0       3271    R 579.txt<br/>21776  python           0      1      0       2978    R 593.txt<br/>21776  python           0      1      0       2929    R 575.txt<br/>21776  python           0      1      0       2929    R 573.txt<br/>21776  python           0      1      0       2880    R 577.txt<br/>21776  python           0      1      0       2832    R 586.txt<br/>21776  python           0      1      0       2587    R 574.txt<br/>21776  python           0      1      0       2441    R 578.txt<br/>21776  python           0      1      0       2441    R 587.txt<br/>21776  python           0      1      0       2392    R 585.txt<br/>21776  python           0      1      0       2343    R 590.txt<br/>21776  python           0      1      0       2294    R 591.txt<br/>21776  python           0      1      0       2246    R 572.txt<br/>21776  python           0      1      0       2246    R 584.txt<br/>....</span></pre><p id="aa0f" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">你会看到<code class="fe mw mx my mm b">filetop</code>输出 8 列，分别是线程 ID、线程命令行、读写次数、读写大小(KB)、文件类型、读写文件名。</p><p id="e7e4" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">观察一段时间后，你会发现每隔一段时间，线程号为 21776 的 python 应用会先写大量的 txt 文件，然后大量读取。</p><p id="f5ef" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">线程号为 21776 的线程属于哪个进程？我们可以用<code class="fe mw mx my mm b">ps</code>命令来检查它:</p><pre class="kh ki kj kk gu ml mm mn mo aw mp bi"><span id="1646" class="mq lp ir mm b gz mr ms l mt mu">$ ps -efT | grep 21776<br/>root      3920 21776  3888 30 15:59 pts/0    00:00:07 /usr/local/bin/python /app.py</span></pre><p id="bab6" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">我们看到这个线程正是案例应用程序 3920 的线程。现在，我们如何知道它正在写哪个(哪些)文件呢？</p><p id="c4a4" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">我们可以使用<code class="fe mw mx my mm b">opensnoop</code>(<a class="ae mz" href="https://github.com/iovisor/bcc/blob/master/tools/opensnoop.py" rel="noopener ugc nofollow" target="_blank">https://github . com/io visor/bcc/blob/master/tools/open snoop . py</a>)命令:</p><pre class="kh ki kj kk gu ml mm mn mo aw mp bi"><span id="b7d3" class="mq lp ir mm b gz mr ms l mt mu">PID    COMM               FD ERR PATH<br/>3920   python              6   0 /tmp/2ec58410-919d-11ec-aa6a-0242ac110002/657.txt<br/>3920   python              6   0 /tmp/2ec58410-919d-11ec-aa6a-0242ac110002/658.txt<br/>3920   python              6   0 /tmp/2ec58410-919d-11ec-aa6a-0242ac110002/659.txt<br/>3920   python              6   0 /tmp/2ec58410-919d-11ec-aa6a-0242ac110002/660.txt<br/>3920   python              6   0 /tmp/2ec58410-919d-11ec-aa6a-0242ac110002/661.txt<br/>3920   python              6   0 /tmp/2ec58410-919d-11ec-aa6a-<br/>...<br/>3920   python              6   0 /tmp/2ec58410-919d-11ec-aa6a-0242ac110002/667.txt<br/>3920   python              6   0 /tmp/2ec58410-919d-11ec-aa6a-0242ac110002/668.txt<br/>3920   python              6   0 /tmp/2ec58410-919d-11ec-aa6a-0242ac110002/669.txt<br/>3920   python              6   0 /tmp/2ec58410-919d-11ec-aa6a-0242ac110002/670.txt</span></pre><p id="0d14" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">这次通过<code class="fe mw mx my mm b">opensnoop</code>的输出，我们基本可以判断 python 应用会动态生成一批文件来临时存储数据，用完了就删除，导致处理非常慢。</p><p id="e3f9" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">让我们检查一下<code class="fe mw mx my mm b">ppy.py</code>的内容:</p><pre class="kh ki kj kk gu ml mm mn mo aw mp bi"><span id="d147" class="mq lp ir mm b gz mr ms l mt mu">$ docker cp 9bc4614419bc:app.py ./<br/>$ cat app.y<br/><br/><a class="ae mz" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank">@app</a>.route("/popularity/&lt;word&gt;") <br/>def word_popularity(word): <br/>  dir_path = '/tmp/{}'.format(uuid.uuid1()) <br/>  count = 0 <br/>  sample_size = 1000 <br/>   <br/>  def save_to_file(file_name, content): <br/>    with open(file_name, 'w') as f: <br/>    f.write(content)</span><span id="886d" class="mq lp ir mm b gz mv ms l mt mu">try: <br/>    # initial directory firstly <br/>    os.mkdir(dir_path)</span><span id="61fe" class="mq lp ir mm b gz mv ms l mt mu"># save article to files <br/>    for i in range(sample_size): <br/>        file_name = '{}/{}.txt'.format(dir_path, i) <br/>        article = generate_article() <br/>        save_to_file(file_name, article)</span><span id="04dd" class="mq lp ir mm b gz mv ms l mt mu"># count word popularity <br/>    for root, dirs, files in os.walk(dir_path): <br/>        for file_name in files: <br/>            with open('{}/{}'.format(dir_path, file_name)) as f: <br/>                if validate(word, f.read()): <br/>                    count += 1 <br/>    finally: <br/>        # clean files <br/>        shutil.rmtree(dir_path, ignore_errors=True)</span><span id="5af0" class="mq lp ir mm b gz mv ms l mt mu">return jsonify({'popularity': count / sample_size * 100, 'word': word})</span></pre><p id="6148" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">从源代码中可以看到，在这个案例应用中，每个请求的处理过程中，都会生成一批临时文件，然后读入内存进行处理，最后整个目录都会被删除。</p><h1 id="265a" class="lo lp ir bd lq lr ls lt lu lv lw lx ly jx lz jy ma ka mb kb mc kd md ke me mf bi translated">结论</h1><p id="e967" class="pw-post-body-paragraph ks kt ir ku b kv mg js kx ky mh jv la lb mi ld le lf mj lh li lj mk ll lm ln ik bi translated">在本文中，我们解决了一个高 I/O 延迟的问题。首先，我们用<code class="fe mw mx my mm b">top</code>和<code class="fe mw mx my mm b">iostat</code>分析了系统的 CPU 和磁盘使用情况。我们发现了磁盘 I/O 瓶颈，也知道瓶颈是由案例应用程序引起的。</p><p id="824d" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">接下来，我们使用<code class="fe mw mx my mm b">strace</code>来观察系统调用，使用<code class="fe mw mx my mm b">filetop</code> + <code class="fe mw mx my mm b">opensnoop</code>命令来识别被写入的线程和文件。</p><p id="eeed" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">我希望您喜欢这个故障排除用例。</p></div></div>    
</body>
</html>