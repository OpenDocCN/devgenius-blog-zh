<html>
<head>
<title>Problems with a shunting yard algorithm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">调车场算法的问题</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/problems-with-a-shunting-yard-algorithm-95cc462dc750?source=collection_archive---------9-----------------------#2022-01-12">https://blog.devgenius.io/problems-with-a-shunting-yard-algorithm-95cc462dc750?source=collection_archive---------9-----------------------#2022-01-12</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/aaef5cb1fccdabfbd164eb5377c8bfe8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pNz6L9LH-OB6dmeKQBlLxA.jpeg"/></div></div></figure><p id="84f2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我已经用 java 成功实现了一个调车场算法。该算法本身很简单，但我有符号化的麻烦。目前，除了一件事之外，这个算法适用于我想要的所有东西。我如何区分减法(-)和负数(-)呢</p><p id="d8a1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">比如 4–3 是减法，但-4+3 是负数</p><p id="1aaa" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我现在知道如何找出何时应该是负数，何时应该是负号，但是算法应该放在哪里，因为如果你把它作为一个函数，它并不总是有效</p><p id="65de" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi">3 + 4 * 2 / -( 1 − 5 ) ^ 2 ^ 3</p><p id="cfc9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当 1–5 变成-4 时，它会在平方和立方之前变成 4</p><p id="5e83" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">就像 3+4 * 2/cos(15)^ 2 ^ 3 一样，你需要在平方和立方之前取余弦值</p><p id="4cf3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是在真正的数学中，你不会用 a——因为你实际上说的是 3+4 * 2/-((15)^ 2 ^ 3)才能得到正确的值。</p><p id="ec25" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">——————</strong>答案</p><p id="cb56" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这听起来像是在做一个 lex-then-parse 风格的解析器，在 lexer 中需要一个简单的状态机来为一元和二进制减号获取单独的标记。(在 PEG 解析器中，这不是你需要担心的事情。)</p><p id="bc92" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在 JavaCC，你会有一个<code class="fe kt ku kv kw b">DEFAULT</code>州，在那里你会认为<code class="fe kt ku kv kw b">-</code>人物是<code class="fe kt ku kv kw b">UNARY_MINUS</code>。当您对一个主表达式的结尾进行标记化时(根据您给出的例子，可以是一个结束参数，也可以是一个整数)，那么您将切换到<code class="fe kt ku kv kw b">INFIX</code>状态，在这里<code class="fe kt ku kv kw b">-</code>将被认为是<code class="fe kt ku kv kw b">INFIX_MINUS</code>。一旦遇到任何中缀运算符，就会返回到<code class="fe kt ku kv kw b">DEFAULT</code>状态。</p><p id="6eb4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你自己卷，可能会简单一点。看看这个<a class="ae kx" href="http://en.literateprograms.org/Shunting_yard_algorithm_%28Python%29#Operators" rel="noopener ugc nofollow" target="_blank"> Python 代码</a>的聪明做法。基本上，当你遇到一个<code class="fe kt ku kv kw b">-</code>的时候，你只是检查一下前面的 token 是不是中缀运算符。该示例使用字符串<code class="fe kt ku kv kw b">"-u"</code>来表示一元减号标记，这便于非正式的标记化。据我所知，Python 示例确实无法处理<code class="fe kt ku kv kw b">-</code>跟在开放 paren 后面或者出现在输入开始处的情况。那些也应该被认为是一元的。</p><p id="d183" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了在调车场算法本身中正确处理一元减号，它需要比任何中缀运算符具有更高的优先级，并且需要标记为右关联。(确保您处理了右结合性。您可能已经忽略了它，因为您的其余操作符是左关联的。)这在 Python 代码中已经足够清楚了(尽管我会使用某种结构而不是两个独立的映射)。</p><p id="36b7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">到了求值的时候，您需要稍微不同地处理一元运算符，因为您只需要从堆栈中弹出一个数字，而不是两个。取决于您的实现看起来像什么，可能更容易的是浏览列表并用<code class="fe kt ku kv kw b">[-1, "*"]</code>替换每一次出现的<code class="fe kt ku kv kw b">"-u"</code>。</p><p id="5976" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你能理解 Python，你应该能在我链接的例子中看到我所说的一切。我发现代码比其他人提到的 C 版本更容易阅读。另外，如果你好奇的话，我曾经写过一篇关于在 Ruby 中使用调车场<a class="ae kx" href="http://austintaylor.org/blog/2010/07/25/treetop-operator-precedence/" rel="noopener ugc nofollow" target="_blank">的文章，但是我把一元操作符作为一个独立的非终结符来处理，所以没有显示出来。</a></p></div></div>    
</body>
</html>