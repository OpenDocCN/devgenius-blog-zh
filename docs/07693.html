<html>
<head>
<title>Typescript classical function vs arrow method</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">打字稿经典函数与箭头方法</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/typescript-classical-function-vs-arrow-method-6f08b04e891?source=collection_archive---------0-----------------------#2022-04-16">https://blog.devgenius.io/typescript-classical-function-vs-arrow-method-6f08b04e891?source=collection_archive---------0-----------------------#2022-04-16</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="2c85" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">何时使用不同的符号。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b7c174e1d1abce5157806f26325f6654.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tQ7HSoRCFt9KeCyFT_Ks3Q.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">华金·索罗拉，1910 年</figcaption></figure><p id="b33d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">经典函数和箭法挺像的，只是语法不一样。</p><p id="c51b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">从 ES2015 开始，有一个<em class="ky">箭头函数</em>语法可用:它有轻量级语法，使用匿名函数，没有显式返回。</p><pre class="kj kk kl km gt kz la lb lc aw ld bi"><span id="c926" class="le lf in la b gy lg lh l li lj">const result = (person) =&gt; {<br/>  return `Good afternoon, ${person}`;<br/>}<br/>RxJs method "find" which looks for records in array:</span><span id="0875" class="le lf in la b gy lk lh l li lj">const preSelectedTariff = this._tariffs?.find(tariff =&gt; tariff.tariffUniqueId === this.selectedTariff?.tariffUniqueId);</span></pre><p id="313f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Lambda 是一个小型匿名函数。它可以接受任意数量的参数，但只能有一个表达式。但是匿名会产生一些问题:</p><ol class=""><li id="124e" class="ll lm in jm b jn jo jr js jv ln jz lo kd lp kh lq lr ls lt bi translated">更难调试</li></ol><p id="2d70" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当您得到一个错误时，您将无法跟踪函数的名称或者错误发生的确切行号。</p><p id="f113" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">2.块作用域——逻辑上适用于经典函数。函数可以以任何顺序声明，应用程序可以以任何方式工作。</p><pre class="kj kk kl km gt kz la lb lc aw ld bi"><span id="fd4f" class="le lf in la b gy lg lh l li lj">callMyFunction();</span><span id="e875" class="le lf in la b gy lk lh l li lj">function callMyFunction() {<br/>  console.log(`Rnd number ${getAnother(1000)}`);<br/>}<br/>function getAnother(max: number) {<br/>  return Math.floor(Math.random() * (max + 1));<br/>}</span></pre><p id="62ba" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是命令式编程和函数式编程。他们每个人都有自己的优势。但是由于块范围的原因，函数应该按照它们出现的顺序来声明。</p><pre class="kj kk kl km gt kz la lb lc aw ld bi"><span id="e733" class="le lf in la b gy lg lh l li lj">tryToCallInWrongOrder();</span><span id="f372" class="le lf in la b gy lk lh l li lj">const tryToCallInWrongOrder = () =&gt; {<br/>  console.log(`Trying to call the function ${getAnother(1001)}`);<br/>}<br/>function getAnother(max: number) {<br/>  return Math.floor(Math.random() * (max + 1));<br/>}</span></pre><p id="9ced" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">3.没有自我引用</p><p id="059d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你的函数需要一个自引用，那么它就不会工作。例如，它可以是递归或事件处理程序。</p><p id="d731" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">当你不应该使用箭头方法时:</strong></p><ol class=""><li id="c6bc" class="ll lm in jm b jn jo jr js jv ln jz lo kd lp kh lq lr ls lt bi translated">对象方法</li></ol><p id="0aea" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当在对象内部使用 arrow 函数时，它从外部作用域继承<code class="fe lu lv lw la b">this</code>值，而不是从局部作用域继承，并且<code class="fe lu lv lw la b">count </code>变量不可用。</p><pre class="kj kk kl km gt kz la lb lc aw ld bi"><span id="8ed2" class="le lf in la b gy lg lh l li lj">const counter = {<br/>  count: 0,<br/>  getFollowing: () =&gt; this.count+1,<br/>  getCurrent: () =&gt; this.count<br/>};<br/>console.log( counter.getFollowing() );</span></pre><p id="535e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">2.在 JavaScript 中:使用 arguments 对象的函数。</p><p id="45e7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">箭头函数没有<code class="fe lu lv lw la b">arguments</code>对象。因此，如果您有一个使用<code class="fe lu lv lw la b">arguments</code>对象的函数，则不能使用 arrow 函数。</p><pre class="kj kk kl km gt kz la lb lc aw ld bi"><span id="93e8" class="le lf in la b gy lg lh l li lj">const concat = (separator) =&gt; {<br/>    let args = Array.prototype.slice.call(arguments, 1);<br/>    return args.join(separator);<br/>}</span></pre><p id="015a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是参数在常规函数中起作用:</p><pre class="kj kk kl km gt kz la lb lc aw ld bi"><span id="629c" class="le lf in la b gy lg lh l li lj">function getChar() {<br/>  return Array.prototype.slice.call(arguments,0,1);<br/>}<br/>console.log(getChar('a','b','c'));</span><span id="cdae" class="le lf in la b gy lk lh l li lj">// or use separator like this:<br/>function concat(separator) {<br/>    let args = Array.prototype.slice.call(arguments, 2);<br/>    return args.join(separator);<br/>}<br/>console.log( concat(',', 'A', 'B', 'C', 'D', 'E') );</span></pre><p id="434d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">3.当它使你的代码更难理解时</p><p id="291d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">正则函数提供了 100%清晰的输入参数和输出类型语法。但是 arrow 方法对于哪种输入类型和输出是什么并不那么直接。这就是函数式编程方法。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lx"><img src="../Images/82b70f0cae1b998829bb767e3ac9f8e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*prmm-2jrkmIAwV704qfv1A.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">美丽拯救世界</figcaption></figure><p id="579f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">该方法的两种表示法之间的优势差异是什么？</strong></p><ol class=""><li id="7f70" class="ll lm in jm b jn jo jr js jv ln jz lo kd lp kh lq lr ls lt bi translated"><strong class="jm io">继承</strong></li></ol><p id="9e43" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Arrow 方法不允许在子类中继承相同的方法，它不会被覆盖。</p><pre class="kj kk kl km gt kz la lb lc aw ld bi"><span id="e078" class="le lf in la b gy lg lh l li lj">class Parent {<br/>  method = () =&gt; { <!-- -->console.log("Parent method"); <!-- -->}<br/>}<br/>class Child extends Parent {<br/>  method = () =&gt; {  // won't override Parent method</span><span id="87fb" class="le lf in la b gy lk lh l li lj">    super.method();<br/>    // won't work because <!-- -->refers to <!-- -->Parent.prototype.method<!-- -->, <br/>    // which doesn't exist<br/>  }<br/>}</span></pre><p id="01f4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> 2。新</strong></p><p id="7e43" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">常规函数是可构造的，可以使用 new 关键字调用它们。</p><pre class="kj kk kl km gt kz la lb lc aw ld bi"><span id="8151" class="le lf in la b gy lg lh l li lj">const kv = new <strong class="la io"><em class="ky">Map</em></strong>();<br/><br/>kv.set("Test msg", "Unknown");<br/>kv.set("", "Unknown");<br/>kv.set(null, "Unknown");<br/>kv.forEach((value, key) =&gt; {<br/>  <strong class="la io"><em class="ky">expect</em></strong>(new RequestTypePipe().transform(key)).toEqual(value);<br/>});</span></pre><p id="dcf5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是，箭头函数永远不能用作构造函数。因此，不能用 new 关键字调用它们:</p><pre class="kj kk kl km gt kz la lb lc aw ld bi"><span id="4687" class="le lf in la b gy lg lh l li lj">let add = (x: number, y: number) =&gt; console.log(x + y);<br/>const error = new add(1, 1); //TypeError: 'add' is not a constructor<br/>const result = add(1000, 1);</span></pre><p id="9b40" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">新的</strong>关键字提供了创建实例的清晰方法:</p><pre class="kj kk kl km gt kz la lb lc aw ld bi"><span id="4cf8" class="le lf in la b gy lg lh l li lj">private readonly unsubscribe$: Subject&lt;void&gt; = new Subject();<br/>private chargeSubscription: Subscription;</span><span id="5568" class="le lf in la b gy lk lh l li lj">ngOnDestroy(): void {<br/>  this.unsubscribe$.next();<br/>  this.unsubscribe$.complete();<br/>}</span><span id="18d1" class="le lf in la b gy lk lh l li lj">private readonly subscribeToQuotation = (): void =&gt; {<br/>  this.chargeSubscription = this.myService()<br/>    .pipe(takeUntil(this.unsubscribe$))<br/>    .subscribe(charge =&gt; this.handleCharge(charge));<br/>};</span></pre><p id="17c7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> 3。参数绑定</strong></p><pre class="kj kk kl km gt kz la lb lc aw ld bi"><span id="6c36" class="le lf in la b gy lg lh l li lj">const mapToLocationCode = (geo: Geo): string =&gt; geo?.code || "";</span><span id="1e87" class="le lf in la b gy lk lh l li lj">return mapToLocationCode(houseObject.geo);</span></pre><p id="bf98" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是，如果要访问箭头函数中的参数，可以使用 rest 运算符:</p><pre class="kj kk kl km gt kz la lb lc aw ld bi"><span id="e3f4" class="le lf in la b gy lg lh l li lj">var arrowFunction = (...args) =&gt; {<br/>    console.log(...args)<br/>}<br/>arrowFunction("my", "additional", "argument");</span></pre><p id="7a0e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> 4。隐式返回</strong></p><p id="b7ac" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">经典函数使用<strong class="jm io"> return </strong>关键字来返回值。如果它被遗漏，那么函数将返回未定义。</p><p id="b276" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">箭头函数减少了代码，提供隐式返回，使代码更干净。</p><pre class="kj kk kl km gt kz la lb lc aw ld bi"><span id="c28a" class="le lf in la b gy lg lh l li lj">let message = () =&gt; 1001;<br/>const result = (message: () =&gt; void) =&gt; { console.log(message) };</span><span id="4f04" class="le lf in la b gy lk lh l li lj">// pass message as a parameter<br/>result(message); </span></pre><p id="34de" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这来自科特林的世界:如果没有争论——用下划线:</p><pre class="kj kk kl km gt kz la lb lc aw ld bi"><span id="abd8" class="le lf in la b gy lg lh l li lj">let myArrowMethod = _ =&gt; console.log("Arrow Method");</span></pre><p id="308b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> 5。这个</strong></p><p id="0be8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">ES6 arrow 方法没有' this '，不能绑定到一个<code class="fe lu lv lw la b">this</code>关键字。我们所能做的就是引用外部作用域变量。</p><pre class="kj kk kl km gt kz la lb lc aw ld bi"><span id="42ee" class="le lf in la b gy lg lh l li lj">const thename = "Alex";<br/>let nameObject = {<br/>  name : "Another Alex",<br/>  arrowMethod: () =&gt; {<br/>    console.log('arrowFunc: ' + thename);  //access to outer variabl<br/>  },<br/>  classicFunction() {<br/>    console.log('classicFunction: ' + this.name); <br/>  }   <br/>}<br/>nameObject.arrowMethod();<br/>nameObject.classicFunction();</span></pre><p id="e944" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">常规函数用它自己的定义创建一个对象和一个作用域，但用 arrow 方法不一样。</p><pre class="kj kk kl km gt kz la lb lc aw ld bi"><span id="276b" class="le lf in la b gy lg lh l li lj">let currentValue: { value: string };</span><span id="f3ac" class="le lf in la b gy lk lh l li lj">// Classic Function<br/>const saveFunction = function (data: any) {<br/>  currentValue = { 'value': data };<br/>  console.log(currentValue);<br/>}<br/>// Arrow Function<br/>const arrowMethod = (data: any) =&gt; {<br/>  currentValue = { 'value': data };<br/>  console.log(currentValue);<br/>}<br/>saveFunction('method');<br/>arrowMethod('arrow');</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ly"><img src="../Images/fc3ec149d01dfb0a990d4890bdd54ceb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kE2pQgY-JokCNWm3w4Uq0A.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">华金·索罗拉，“大浪如圣塞巴斯蒂安”，1918 年</figcaption></figure><p id="73ac" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">结论</strong></p><p id="0318" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">还有很多其他的区别，我描述其中的主要区别。很难说，什么时候选择这些方法之一。函数式编程需要更少的代码，经常使用箭头方法！</p></div></div>    
</body>
</html>