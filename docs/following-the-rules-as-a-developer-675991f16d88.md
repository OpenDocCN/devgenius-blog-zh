# 作为开发人员遵守规则

> 原文：<https://blog.devgenius.io/following-the-rules-as-a-developer-675991f16d88?source=collection_archive---------12----------------------->

*以及何时打破它们*

![](img/a25c19a41a663fa95bd6023427fcae33.png)

由[丹·迈耶斯](https://unsplash.com/@dmey503?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄的照片

这篇文章可能包含附属链接，当你点击链接时，我可能会赚取一小笔佣金，而不会对你产生额外的费用。作为亚马逊的会员，我从合格的购买中获得收入。

现在，我要分享的可能不是我们都同意的。如果你不是那种挑战现状的人，或者更糟糕的是，不能诚实地反思自己的能力，那么我会建议你现在回头，忘记你曾经看过这篇文章。这篇文章是关于我们在开发世界中作为信条遵循的一些“规则”应该如何被打破。问题实际上围绕着我们应该何时打破它们。

这不一定是详尽的指南。这更像是一篇观点文章。最重要的是，这是一件需要自我反思的作品。我不能告诉你你是谁，什么时候这些情况是合适的。这是一个技巧和经验的问题。

说到这里，我想先谈谈技能。

# 德雷福斯模型

> 技能获得的 **Dreyfus 模型**是学习者如何通过正式的指导和练习获得[技能](https://en.wikipedia.org/wiki/Skill)的模型，用于[教育](https://en.wikipedia.org/wiki/Education)和[运筹学](https://en.wikipedia.org/wiki/Operations_research)领域。Stuart 和 Hubert Dreyfus 兄弟于 1980 年在一份长达 18 页的报告中提出了这个模型，这份报告是他们在加州大学伯克利分校美国空军科学研究办公室作战研究中心的研究报告。[【1】](https://en.wikipedia.org/wiki/Dreyfus_model_of_skill_acquisition#cite_note-1)该模型提出一个学生要经过五个截然不同的阶段，最初确定为:新手、胜任、熟练、专业、精通。
> 
> [-维基百科](https://en.wikipedia.org/wiki/Dreyfus_model_of_skill_acquisition)

德雷福斯模型是一个很好的个人技能指南。它提供了一种方法来衡量我们的能力，方法是利用心理功能并对它们进行适当的分类。虽然没有一个模型是完美的，但我确实觉得我不止一次看到这个模型在实践中的应用。

我们都知道“经验年限”是技能水平最差的指标。它可能告诉我们一个人的潜力，但它不是一个保证。我的意思是，一个 6 个月前开始编程的开发人员不太可能精通软件开发的艺术。事实上，他们才刚刚开始。然而，20 年的经验可能和 1 年的经验重复 20 次一样好。因为开发人员已经工作了 20 年，所以不能保证他们已经掌握了这项技术。

尽管没人知道这句话的出处，但一个流行的说法是来自 Shibumi。

> “如果你小心避免空洞的冗余，你可以获得经验。不要陷入一个工匠的错误，他自称有二十年的**工艺经验，而事实上他只有一年的****——二十倍的*** *。永远不要怨恨你的长辈所拥有的经验优势。回想一下，他们用生命的硬币为这段经历付出了代价，掏空了一个无法再装满的钱包。”**
> 
> *[-特雷瓦尼安，Shibumi](https://www.aamboli.com/quotes/book/shibumi)*

*但是我跑题了。德雷福斯模型是一个有趣的概念。在与开发人员交流并了解他们如何通过技能增长周期适应各种情况时，它实际上是有帮助的。不同的人在不同的季节有他们的经历，我们需要衡量这个水平，让我们讨论和训练他们特定的话题。它还可以通知我们他们何时还没有完全准备好采用特定的方法或技术。它也能告诉我们需要学习什么来继续我们的掌握之路。*

*下面的引语来自我 5 年前买的一本关于这个主题的很棒的书，我强烈推荐，书名是安迪·亨特的[务实的思考和学习:重构你的湿件](https://amzn.to/3slkkz0)。他介绍了学习和 Dreyfus 模型在编程中的应用(以及一系列其他主题)。他和戴维·托马斯是《务实的程序员》一书的作者。*

*让我们来看看安迪定义的德雷福斯模型的五个阶段。*

## *第一阶段:新手(开始)*

> *新手很在意自己的成功能力；由于缺乏经验指导，他们真的不知道他们的行动是否会一切顺利。新手不是特别想学；他们只想完成眼前的目标。他们不知道如何应对错误，因此当事情出错时，他们很容易陷入困惑。*
> 
> ***新手需要菜谱。***
> 
> *-务实的思考和学习:重构你的湿件*

*这里重要的方面是新手(或初学者)需要**规则**。他们需要指导。他们需要指导。这很自然。当你第一次开始编程时，你会查找教程，购买教授 For-Loops、If-Then 分支和其他语言关键词的书籍。规则为任何开发人员在开始他们的旅程时提供了最初的指导。*

## *第二阶段:高级初学者*

> *一旦越过了新手的障碍，人们就开始从高级初学者的角度来看待问题。高级初学者可以开始一点点脱离固定的规则集。他们可以自己尝试任务，但仍然难以排除故障。*
> 
> ***高级初学者不要大图***
> 
> *-务实的思考和学习:重构你的湿件*

*在这一点上，你的技能在进步，但是你仍然需要大量的文档和查找一些任务，但是你可以在没有太多指导的情况下开始你的工作，假设这些任务是相当基础的或者重复的。他们可以采纳他人的建议，但这仍然是基于过去的经验。*

## *第三阶段:胜任*

> *在第三阶段，实践者现在可以开发问题领域的概念模型，并有效地使用这些模型。他们可以自己解决问题，并开始解决新的问题——他们以前从未面对过的问题。他们可以开始寻求和应用专家的建议，并有效地使用它。*
> 
> ***有能力排除故障。***
> 
> *-务实的思考和学习:重构你的湿件*

*在这个阶段，开发人员擅长完成工作。但这也是开发人员缺乏自我反省的地方，我发现很多开发人员如果离开的话会在这里呆很长时间。*

## *第四阶段:精通*

> *熟练的从业者需要大局。他们会寻找并想要理解围绕这项技能的更大的概念框架。他们会对过于简单的信息感到非常沮丧。*
> 
> ***精通修行的人可以自我纠正。***
> 
> *-务实的思考和学习:重构你的湿件*

*在这里，我们看到开发人员真正掌握了他们的技能，并专注于改进。他们有能力接受实际的建议，从别人那里学习，而不必直接经历失败。当失败发生时，他们观察并“自我纠正”,同时有能力学习。*

*“过于简化的信息”的想法让我想起了那些(在这个平台上)对关于开发的基本文章感到沮丧的人。有些显而易见或描述不当的事情。*

## *第五阶段:专家(精通)*

> *在任何领域，专家都是知识和信息的主要来源……专家知道不相关的细节和非常重要的细节之间的区别，也许不是在有意识的层面上，但专家知道哪些细节应该关注，哪些细节可以安全地忽略。这位专家非常擅长有针对性、有重点的模式匹配。*
> 
> ***专家凭直觉工作***
> 
> *-务实的思考和学习:重构你的湿件*

*这是最后一站。专家不常见。大约 1%到 5%的人口被认为是某一特定技能的专家(J.T. Hackos 和 D.M. Stevens。*在线交流的标准*。约翰·威利的儿子们，纽约，纽约州，1997 年)。*

*这既令人鼓舞又令人沮丧。*

*我是专家吗？是吗？我们能成为专家吗？这是我从书中引用的最后一句话。*

> *当你在某个领域不太熟练时，你更有可能认为自己实际上是这方面的专家。*
> 
> *在论文《不熟练和不自知:难以认识到自己的无能是如何导致自我评估膨胀的》(《个性与社会心理学杂志》)。77[6]:1121–1134, 1999)…*
> 
> *-务实的思考和学习:重构你的湿件*

*最后一句话更多的是关于我们。为了让我们正确地评估我们在哪里，我们必须自我反省。这是软件、关系和生活中的关键。这对我们的成长至关重要。*

*我们应该努力意识到我们属于哪一类，因为它直接影响我们如何学习和我们达到精通的能力。*

# *规则存在的原因*

*规则适用于初学者、高级初学者和胜任者。它们并不真正为熟练者和专家而存在。*

*为什么？*

*因为**“规则毁了专家。”***

*如前所述，规则有助于指导开发人员走上最佳实践的道路。在大多数情况下，专家们想出了这些规则，正是为了指导我们，开发者，沿着我们的道路走向精通。但是在规则存在之前，它必须被所说的“专家”发现他们为了我们而把工作、时间和“掏空生活的钱包”。*

*现在，当我说规则时，我真正的意思是这些年来我们被教导的所有事情。当你阅读这份清单时，要明白我同意这些发展的“规则”。但是我们应该认识到，它们在你的旅程中的某一点上起着“指南”的作用。*

*   ***YAGNI——你不会需要它**:我们应该假设一些能力现在不应该被建造，因为我们真的不知道我们是否会需要它。*
*   ***接吻——保持简单“傻傻的”**:简单应该是任何设计的关键目标*
*   *单一责任原则:一个类的改变不应该有一个以上的原因。*
*   ***开闭原则**:软件实体…应该对扩展开放，但对修改关闭*
*   ***依赖倒置原则**:依赖抽象，而不是具体。*
*   ***组合超越继承**:通过组合对象而不是从基类继承来实现多态行为和重用。*

*这样的例子不胜枚举。*

*我要重申，这些都是软件开发中重要且关键的原则，我绝不是建议我们应该突然停止使用它们。事实上，即使我是这样建议的，而且你相信我的每一句话，你也会违反我想表达的东西… **规则总是有例外**。*

# *规则的例外*

*现在让我们举一个简单的例子。我听说一个很流行的理论是 YAGNI 原理。通常是这样的…*

> ***开发人员 A** :“我们真的需要担心现在添加一个表来跟踪性能指标吗？”*
> 
> ***开发人员 B** :“好吧，当我们从现在起 6 个月后开始出现性能问题，而我们不知道原因时，会发生什么呢？”*
> 
> ***开发者 A** :“当这种情况发生时，我们会把功能放进去，但是我们真的不知道是否会有任何问题。”*
> 
> *开发人员 B :“我想这是真的，但之后我们将不得不重新构建代码并进行部署。”*
> 
> *开发者 A :“也许吧，但我认为是 YAGNI。为什么现在把工作放进去？我认为我们应该等待”*
> 
> ***开发商 B** :“好的。有道理。这可能是白费力气。”*

*这种情况下谁是对的？*

*在我看来，两者都不是。原因。没有人真正有一个好的论点。依我拙见，YAGNI 永远不是一个论点。你为什么不需要它？给我一个比“我们可能不需要它”更好的理由但是另一方面，在这种情况下，构建/部署代码也不是一个好的论点。*

*为什么？*

*因为没人讨论成本。我认为**开发者 B** 肯定更接近，但这取决于重新构建和部署代码的成本。如果构建和部署代码需要数小时的工作、一组人员的部署和多次 QA 迭代，那么**开发人员 B** 是对的。*

*然而，如果代码可以在几分钟内重新构建和部署，同时经过全面测试，那么**开发者 A** 是对的。*

*在这个想象的场景中，**开发者 A** 是一个理想主义者，而**开发者 B** 对未来充满恐惧；两者在技能上大概都是称职的(或以下)。也不是我们想成为的人。我们希望在方法上务实。这就是行家(或专家)发挥作用的地方。这就是需要直觉和过去的经验来做出判断的地方。*

*在这种情况下，我们考虑打破的“规则”是 YAGNI。我们应该吗？从这个例子我们不知道。但是我们可以说，无论是从商业角度还是从开发效率角度来看，打破 YAGNI 都是完全有意义的。*

*那么，我能给你一个关于何时打破规则的硬性规定吗？不，不完全是，但是我能提供一点指导。如果有任何疑问，*

> *根据成本做出决定。*

*但什么是“成本？”让我们讨论一下这个问题。*

# *发展的成本*

*成本通常与金钱有关($$$)。然而，这是一个廉价的方法(双关语)。*

> *不，成本其实是时间的问题。*

*这是我们最有价值的资产。自然，时间可以转化为金钱，但更重要的是，我们不应该在重复的任务上浪费我们在这个世界上仅有的一点时间。*

*因此，当我想到成本时，我会想到执行某些任务所花费的时间，以及所花费的任何努力的效率(比如说快 5 倍)。任务变得越有效率，花费的时间就越少，反过来，我们从执行任务中获得的价值就越大。出于这个原因，我会打破任何妨碍效率的规则。*

*我的技能是软件开发，80%的时间，我遵循上面所有的规则。然而，偶尔，我会开发一个方法、类或框架来打破这些规则。当我写一个不想再做的子系统时，这种情况经常发生。*

*这些原则中的一些是建立在我们将会一遍又一遍地接触代码的想法上的。为了可读性和简单性，我们遵循这些规则以确保其他开发人员能够理解其目的。但是有什么比有效的、经过测试的、易于维护的代码更好呢？*

> *有效的、经过测试的、永远不需要维护的代码。*

*这并不经常发生，但偶尔，你会偶然发现一个问题，用一种新颖的方式解决它，它会一遍又一遍地工作。然后，您决定将该代码放入一个库中，以便可以反复重用。然后几年过去了，才不得不看这些代码。是的，我经历过，虽然不经常。我发现当你考虑未来和潜在的变化时，这种情况发生的可能性更大；尤其是当你了解业务和他们如何运作。*

## *个人例子*

*许多年前，我为我工作的一家公司开发了一个支付系统。老板当时有非常具体的需求，我们需要实现这些需求。然而，我很了解这个人，也明白他最终会想要一些额外的改变，但这些改变没有被考虑，因为当时并不需要。*

*但我更清楚。*

*YAGNI 的想法被抛出了很多。然而，我能够赢得这场争论，请注意，在此过程中我有很多自我怀疑。这个想法是为了给系统增加额外的灵活性“以防万一”*

*没有进入太多的细节，你瞧，不到 8 个月后，他要求一个改变，虽然不完全是我想象的那样，可以被系统处理。实际上没有必要改变。事实上，他很惊讶我们可以在不重新部署代码的情况下处理他认为是巨大的需求变更。*

*我承认我当时冒险与资深开发人员对抗，但最终还是成功了。老实说，在代码运行了大约 3 年而没有任何变化之后，我们最终得到了一个我们无法处理的需求。我们必须改变代码和结构。*

*但是人类是一个好的开始，特别是对于我们所建造的。*

*尽管它并不完美，但关键是，代码在处理新的需求时已经工作了很多年，从来不需要修改。我们只需通过用户界面对其进行稍微不同的配置，这正是关键所在。代码并不漂亮，我也绝不是专家，但是在经历了这种深谋远虑之后，我明白了有时候规则是可以打破的，可以让业务和开发人员受益。*

*你必须记住，通过不必处理那些代码，我能够处理对业务至关重要的其他应用程序，而不是维护这个应用程序。从成本角度来看，这是非常低的成本。增加灵活性所需的时间大约是前期额外 2 周的工作。几乎 3 年没有成本。在我看来这是一个胜利。*

# *结论和签署*

*打破规则并为公司或你正在开发的产品增加价值是可能的。我经历过这个。虽然人们可能会在原则上回避这一点，但这是我最重视的事情:我的时间。通过节省我的时间，我能够保持软件的低成本，同时仍然在该领域进行创新。*

*作为一名初级开发人员，我建议您继续尽最大能力遵循“规则”并掌握它们。如果不了解它们为什么存在，你就很难理解什么时候应该打破它们。我给出的例子是我破坏了“YAGNI”的一个实例，然而，也有我破坏了“继承之上的合成”、“亲吻”等的例子。从来不是偶然，也不是出于懒惰。相反，它归结为成本。成本和效率是我前进的动力。如果我能开发出不需要维护的软件，那就是成功。是的，最终你很可能不得不接触代码，所以保持代码的整洁、易读仍然是至关重要的，但是为了达到把你在一个问题上花费的时间减到最少的目标，偶尔的例外可能是必要的。*

*随着你越来越接近成为你所在行业的“专家”，这些决定不可避免地变得更加清晰。有时，你可能需要尝试不同的决定，才能理解为什么有些事情行得通，有些事情行不通。但这是你成为最好的开发者所必须做的。要有实验性。要谦虚。最重要的是，要有效率。*

*如果你喜欢这篇文章，请在 medium 上关注我。它鼓励我继续写作！*

*为了无限和超越，*编码基础*！*