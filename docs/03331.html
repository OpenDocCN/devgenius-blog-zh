<html>
<head>
<title>Better JavaScript — Loops and Arrays</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">更好的 JavaScript——循环和数组</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/better-javascript-loops-and-arrays-70a32fc1c2f5?source=collection_archive---------9-----------------------#2020-10-23">https://blog.devgenius.io/better-javascript-loops-and-arrays-70a32fc1c2f5?source=collection_archive---------9-----------------------#2020-10-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/89a1acafb8a09e0856ee159392af3a74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mgGuvvJQZOy5Gi8v"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">沃尔代·瓦格纳在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="0995" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像任何类型的应用程序一样，JavaScript 应用程序也必须写得很好。</p><p id="9a1d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">否则，我们以后会遇到各种各样的问题。</p><p id="96a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究改进 JavaScript 代码的方法。</p><h1 id="8d1a" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">不要在枚举过程中修改对象</h1><p id="9605" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们不应该在枚举过程中修改对象。</p><p id="4fc0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">for-in 循环不需要与对象修改保持同步。</p><p id="2822" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此我们可能会在循环中得到过期的项目。</p><p id="35fd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这意味着如果我们改变被修改的对象，我们应该依靠 for-in 循环来实现可预测的行为。</p><p id="08b1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们不应该有这样的代码:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="188a" class="mn lc iq mj b gy mo mp l mq mr">const dict = {<br/>  james: 33,<br/>  bob: 22,<br/>  mary: 41<br/>}</span><span id="9663" class="mn lc iq mj b gy ms mp l mq mr">for (const name in dict) {<br/>  delete dict.bob;<br/>}</span></pre><p id="ee8c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有了<code class="fe mt mu mv mj b">dict</code>对象，但是我们在 for-in 循环中修改了它。</p><p id="b821" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是这个循环并不需要获得最新的更改，所以<code class="fe mt mu mv mj b">bob</code>可能仍然会出现。</p><h1 id="a9a8" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">对于数组迭代，for-of 循环优于 for-in 循环</h1><p id="64db" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">for-in 循环不是用来遍历数组的。</p><p id="1a76" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">顺序是不可预测的，我们得到的是项目的键，而不是项目本身。</p><p id="ae6a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以如果我们有这样的东西:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="fbf8" class="mn lc iq mj b gy mo mp l mq mr">const scores = [4, 4, 5, 7, 7, 3, 6, 6];<br/>let total = 0;<br/>for (const score in scores) {<br/>  total += score;<br/>}<br/>const mean = total / scores.length;</span></pre><p id="3b01" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mj b">score</code>会是这个阵的关键。</p><p id="738d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们不会把分数加起来。</p><p id="8f9d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，键将是一个字符串，所以我们将连接键字符串，而不是添加。</p><p id="f4ed" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，我们应该使用 for-of 循环来遍历数组。</p><p id="ee9c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="d355" class="mn lc iq mj b gy mo mp l mq mr">const scores = [4, 4, 5, 7, 7, 3, 6, 6];<br/>let total = 0;<br/>for (const score of scores) {<br/>  total += score;<br/>}<br/>const mean = total / scores.length;</span></pre><p id="a73a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过 for-of 循环，我们获得数组或任何其他可迭代对象的条目，这样我们实际上就获得了数字。</p><h1 id="73d5" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">更喜欢迭代方法而不是循环</h1><p id="60ec" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们应该尽可能使用数组方法来操作数组条目，而不是循环。</p><p id="28c8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以使用<code class="fe mt mu mv mj b">map</code>方法将条目映射到一个数组。</p><p id="621d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="20b9" class="mn lc iq mj b gy mo mp l mq mr">const inputs = ['foo ', ' bar', 'baz ']<br/>const trimmed = inputs.map((s) =&gt; {<br/>  return s.trim();<br/>});</span></pre><p id="4cf4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用回调函数调用了<code class="fe mt mu mv mj b">map</code>来修剪每个字符串中的空白。</p><p id="ea26" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这比使用如下循环要短得多:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="afdc" class="mn lc iq mj b gy mo mp l mq mr">const inputs = ['foo ', ' bar', 'baz ']<br/>const trimmed = [];<br/>for (const s of inputs) {<br/>  trimmed.push(s.trim());<br/>}</span></pre><p id="e3a4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们必须编写更多的代码来进行修整，并将其推送到<code class="fe mt mu mv mj b">trimmed</code>数组。</p><p id="d91a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">还有很多其他的方法，比如<code class="fe mt mu mv mj b">filter</code>、<code class="fe mt mu mv mj b">reduce</code>、<code class="fe mt mu mv mj b">reduceRight</code>、<code class="fe mt mu mv mj b">some</code>、<code class="fe mt mu mv mj b">every</code>等等。我们可以用它来简化我们的代码。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/b4db0092d0bca722f811f4f733b293c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*eqdP-DQEARSXgf8O"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@tine999?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Tine ivani</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="fa0d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="49a3" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们不应该在枚举过程中修改对象。</p><p id="eee0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们应该更喜欢迭代方法而不是循环。</p><p id="ad6f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">for-of 比 for-in 循环更适合迭代。</p></div></div>    
</body>
</html>