# Java 中数组排序的不同方法

> 原文：<https://blog.devgenius.io/different-ways-to-sort-an-array-in-java-3f3d201c48a4?source=collection_archive---------6----------------------->

![](img/d996cccc0f091ce48a4c081f89d8bb54.png)

[莎拉·布朗](https://unsplash.com/@sweetpagesco?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍照

在 java 中，主要有两种方法对数组进行排序。

您可以让 java 类实现 comparable，并实际实现 compareTo 方法。这样，Arrays.sort 将确切地知道它将依靠什么算法来对数组进行排序。

或者您可以实现一个比较器类，通过名称或 id 来比较对象。然后，在您的客户端代码中，您可以使用比较器作为第二个参数来执行 Arrays.sort。

在我们深入可比和比较器之前，让我们先来讨论一下这两者是如何工作的。

可比较的

Comparable 是一个可以由任何 java 类实现的接口。它为一个对象提供了与另一个对象进行比较的兼容性，以便进行排序。

此外，实现 comparable 接口的类可以通过实现 compareTo 方法自定义排序方式。

事实上，实现 comparable 接口的类必须实现 compareTo 方法。

让我们看看下面这个实现 comparable 的类:

正如你已经注意到的，当一个类实现 comparable 时，你也必须指定泛型。这个泛型将是可比较的对象/类的类型。

在文件内部，您还需要实现一个 compareTo 方法。这是你决定你想要你的类对象如何排序的地方。在上面的场景中，我们希望所有对按照 endTime 升序排序，就像 compareTo 方法中规定的那样。

如果结束时间是一样的呢？我们还可以执行以下操作:

在这里，如果配对的结束时间相同，那么我们可以按开始时间升序对配对进行排序。

到目前为止，我们已经展示了实现 comparable 的类是怎样的。当客户机实际上有一个 pair 数组并对它们进行排序时，看起来是什么样的？

让我们来看看:

虽然使一个类实现具有可比性确实给了它对象类以我们想要的方式排序的能力，但当有一个数组时，它也将一个特定的排序行为耦合到每个 pair 实例上。如果我们想按 endTime 升序对某些对进行排序，而按 end time 降序对其他对进行排序呢？使用实现 comparable 的 pair 类无法做到这一点。

输入比较器。

Comparator 是一个允许类对用户定义的类的对象进行排序的接口。我们没有将排序功能与类本身紧密结合，而是将排序逻辑留给一个比较器，该比较器专门处理比较两个对象的逻辑:

在这里，PairComparatorByEndTime 实现了比较器接口，并且需要实现 compare 方法。类似于 compareTo，排序的逻辑在这里决定。

在客户端代码中，有另一个重载的 arrays.sort 方法，它接受两个参数而不是一个，第二个参数是一个比较器实例。

有了比较器，pair 类不再需要实现 comparable，而是由比较器进行排序:

如果需要，您还可以包含一个不同的比较器来按开始时间排序。

每种方法的优缺点是什么？

使用 comparable，您可以简单地将排序逻辑浓缩到对象类中。您不需要在外部维护不同的比较器类来担心如何对对象的数组/集合进行排序。

然而，这只会限制对象以一种方式排序，并且您不能真正不同地排序两个对象的数组/集合。如果您在扩展代码时将它用于生产代码，这可能是一个问题。

使用 comparator，您可以给客户端代码几个选项来对类实例的数组进行排序。这避免了使用 comparable 的缺陷，并为用户提供了更多的灵活性，可以根据需要对集合进行不同的排序。

然而，由于不同的比较器类有额外的逻辑，因此需要维护更多的代码。想象一下，您维护的所有类都有几个比较器。这意味着需要在代码库中维护更多的测试和逻辑。

作为一名开发人员，您可以根据问题的范围来决定使用哪种解决方案。

就是这样！编码快乐！

如果有问题/顾虑，欢迎在本文中发表评论。