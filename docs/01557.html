<html>
<head>
<title>JavaScript Tips — bind and apply, Loops, and Nested Properties</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript提示—绑定和应用、循环和嵌套属性</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/javascript-tips-bind-and-apply-loops-and-nested-properties-d50c62f8026b?source=collection_archive---------18-----------------------#2020-07-06">https://blog.devgenius.io/javascript-tips-bind-and-apply-loops-and-nested-properties-d50c62f8026b?source=collection_archive---------18-----------------------#2020-07-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/a00a484b114d6426a8a6004f38cb44c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*J04tKEmT-wUZ1lPY"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@ansgarscheffold?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Ansgar Scheffold </a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="ac2f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像任何类型的应用程序一样，当我们编写JavaScript应用程序时，有一些困难的问题需要解决。</p><p id="96a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究一些常见JavaScript问题的解决方案。</p><h1 id="d575" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">JavaScript for…in vs for</h1><p id="ba7c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">for-in和for循环是不同的。</p><p id="0311" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">for-in专门用于遍历对象的属性。</p><p id="e601" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="b468" class="mn lc iq mj b gy mo mp l mq mr">for (const key in obj){<br/>  //...<br/>}</span></pre><p id="b489" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">key</code>是对象的属性名。</p><p id="569a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">for循环可以用于任何事情。</p><p id="4e92" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="f14d" class="mn lc iq mj b gy mo mp l mq mr">for (let i = 0; i &lt; a.length; i++){<br/>  //...<br/>}</span></pre><p id="3bcc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用循环遍历数组<code class="fe ms mt mu mj b">a</code>。</p><p id="6e57" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是我们可以用它做任何事情。</p><h1 id="297a" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">的使用。使用“new”运算符应用()</h1><p id="945b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以将<code class="fe ms mt mu mj b">apply</code>用于任何功能。</p><p id="0284" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了一起使用它们，我们用<code class="fe ms mt mu mj b">bind</code>和<code class="fe ms mt mu mj b">apply</code>方法一起创建了一个新的构造函数。</p><p id="d2f9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="2e99" class="mn lc iq mj b gy mo mp l mq mr">function newCall(Cls, ...args) {<br/>  return new (Function.prototype.bind.apply(Cls, args));  <br/>}</span></pre><p id="99df" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们创建了<code class="fe ms mt mu mj b">newCall</code>构造函数get类，我们想用。</p><p id="514f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到了<code class="fe ms mt mu mj b">args</code>。</p><p id="9120" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">bind</code>返回一个新的构造函数，它用我们想要的参数<code class="fe ms mt mu mj b">args</code>调用带有<code class="fe ms mt mu mj b">Cls</code>构造函数的<code class="fe ms mt mu mj b">apply</code>。</p><p id="ea79" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们可以通过编写以下代码来使用构造函数:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="4a48" class="mn lc iq mj b gy mo mp l mq mr">const s = newCall(Foo, a, b, c);</span></pre><p id="3cce" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用参数<code class="fe ms mt mu mj b">a</code>、<code class="fe ms mt mu mj b">b</code>和<code class="fe ms mt mu mj b">c</code>将<code class="fe ms mt mu mj b">Foo</code>构造函数传递给<code class="fe ms mt mu mj b">newCall</code>。</p><p id="2911" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到一个用这些参数创建的<code class="fe ms mt mu mj b">Foo</code>实例。</p><h1 id="984d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><script type="“text/template”"> … </script>的使用</h1><p id="2160" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">类型为<code class="fe ms mt mu mj b">text/template</code>的脚本标签被一些库用作模板。</p><p id="1228" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，jQuery可以从这个脚本标签中获取模板。</p><p id="26fe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们有:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="c947" class="mn lc iq mj b gy mo mp l mq mr">&lt;script id="hello" type="text/template"&gt;<br/>  hello world<br/>&lt;/script&gt;<br/>&lt;script&gt;<br/>  console.log($('#hello').html());<br/>&lt;/script&gt;</span></pre><p id="c5a0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后jQuery获取ID为<code class="fe ms mt mu mj b">hello</code>的脚本标签，并通过调用<code class="fe ms mt mu mj b">html</code>从其中返回HTML内容。</p><p id="59e6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们在控制台日志中记录了<code class="fe ms mt mu mj b">'hello world'</code>。</p><h1 id="0400" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">在不知道键的情况下获取JavaScript对象的所有属性值</h1><p id="292e" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过几种方式获得JavaScript对象的所有属性值，而不需要知道键。</p><p id="49e6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一种方法是使用for-in循环:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="a552" class="mn lc iq mj b gy mo mp l mq mr">for(var key in obj) {<br/>  const value = obj[key];<br/>  //...<br/>}</span></pre><p id="616d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还可以使用<code class="fe ms mt mu mj b">Object.key</code>方法获得所有属性键的数组。</p><p id="37e4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="27fc" class="mn lc iq mj b gy mo mp l mq mr">const keys = Object.keys(obj);<br/><br/>for (const key of keys) {<br/>  const val = obj[key];  <br/>}</span></pre><p id="81d6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们使用for-of循环遍历从<code class="fe ms mt mu mj b">Object.keys</code>返回的键数组。</p><p id="80f8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">Object.values</code>返回数组中的所有值。</p><p id="924e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们可以循环遍历这些值，而不需要获取键:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="8da6" class="mn lc iq mj b gy mo mp l mq mr">const values = Object.values(obj);</span><span id="d7eb" class="mn lc iq mj b gy mv mp l mq mr">for (const val of values) {<br/>  //...<br/>}</span></pre><h1 id="c236" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">通过字符串路径访问嵌套的JavaScript对象和数组</h1><p id="6fec" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">有几种方法可以获得对象中嵌套属性的值。</p><p id="03ee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一种方法是从头开始编写一个函数:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="b310" class="mn lc iq mj b gy mo mp l mq mr">const resolve(path, obj = {}, separator = '.') {<br/>  const properties = Array.isArray(path) ? path : path.split(separator);<br/>  return properties.reduce((prev, curr) =&gt; prev &amp;&amp; prev[curr], obj)<br/>}</span></pre><p id="8e70" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们创建了<code class="fe ms mt mu mj b">resolve</code>方法来获得每个级别的属性。</p><p id="37cb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">属性路径由分隔符分开。</p><p id="efa1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们遍历所有属性，用<code class="fe ms mt mu mj b">reduce</code>得到嵌套属性的值。</p><p id="e510" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么我们可以这样称呼它:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="3bcd" class="mn lc iq mj b gy mo mp l mq mr">resolve("style.width", document.body)</span></pre><p id="a878" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">获取对象的属性。</p><p id="2ca9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果有一个数组，我们写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="1b98" class="mn lc iq mj b gy mo mp l mq mr">resolve("part.0.size", obj)</span></pre><p id="0bcc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">其中0是数组的索引。</p><p id="f827" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了让我们的生活更容易，我们可以使用洛达什<code class="fe ms mt mu mj b">get</code>法。</p><p id="6844" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="fa16" class="mn lc iq mj b gy mo mp l mq mr">_.get(object, 'a[0].b.c');</span></pre><p id="3275" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过路径获取属性。</p><h1 id="de45" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">对飞行前请求的响应未通过访问控制检查错误</h1><p id="1a82" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">此错误意味着在实际请求失败之前发出的选项请求。</p><p id="2365" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要解决此问题，我们可以关闭CORS。</p><p id="d436" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们可以使用类似Nginx的代理来处理选项请求。</p><p id="fe84" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还可以通过确保options请求得到成功响应来适当地启用CORS。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/1cffae9a76758e9efb04b0d2c2127d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hwqNu1rbCZECB5qw"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@eddietsy?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">埃迪Tsy </a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="bf0b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="aec6" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">for-in循环不同于for循环。</p><p id="87dc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了确保跨域请求成功，我们应该确保正确配置我们的服务器。</p><p id="0d5c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有一些方法可以访问对象的嵌套路径。</p><p id="082d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以一起使用<code class="fe ms mt mu mj b">bind</code>和<code class="fe ms mt mu mj b">apply</code>。</p></div></div>    
</body>
</html>