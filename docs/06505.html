<html>
<head>
<title>Some Software Architecture Styles</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一些软件架构风格</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/some-software-architecture-styles-fbb57f7716b9?source=collection_archive---------0-----------------------#2022-01-13">https://blog.devgenius.io/some-software-architecture-styles-fbb57f7716b9?source=collection_archive---------0-----------------------#2022-01-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c546" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">各种历史和现代软件架构风格的快速总结。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/fa19c0107a48c1c74e3a83679d88078a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*71rN6qVMLzld-cdt"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae kv" href="https://unsplash.com/@austindistel?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Austin Distel </a>拍摄的照片</figcaption></figure><p id="534f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每个软件项目都是不同的，但这并不意味着没有我们可以挑选出的趋势。</p><h1 id="7a55" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">大泥球</h1><p id="960b" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">当你没有选择一个架构时，这就是你最终得到的架构。mud 的“大球”指的是无结构的、意大利面条式的代码库，这些代码库来自一个没有计划如何构建他们的解决方案的团队。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mp"><img src="../Images/bbe15b264b103a5de13b795d9598467a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*PUpmmubfNQLkalZw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">“泥巴大球”的名称来自于无组织的耦合和调用模式的网络，它们代表了没有清晰架构的项目</figcaption></figure><p id="a150" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">系统的不同部分通常是高度耦合的，维护非常困难，向陌生人解释一切是如何组合在一起的几乎是不可能的。无论如何都要避免这种情况。</p><h1 id="dda2" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">分层架构</h1><p id="4bd6" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">最简单和最常见的架构风格之一是分层架构。代码被技术领域划分成离散的层。这清楚地表明了代码的归属。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mq"><img src="../Images/28433b6ba8cbadf2d7dfb47525832f0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*OZJtJGCUORSe6-CF.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">典型的代码层分解</figcaption></figure><p id="433a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个典型的规则是每一层都是封闭的，这意味着它只能被它旁边的层访问，这有助于防止耦合。每一层都可以整体部署在一起，也可以单独部署。通常，表示层(UI)和数据库将分别部署到代码的其余部分。</p><h1 id="3464" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">流水线架构</h1><p id="b064" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">管道架构以两种类型的装置为中心；管道和过滤器:</p><p id="3080" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">过滤器</strong>是独立的无状态计算单元。他们应该专注于做一件特定的任务。过滤器可以产生、测试、转换或消耗数据。</p><p id="b2a9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">管道</strong>是过滤器之间的通信通道。它们是一种方式，用于构建过滤器的管道。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ca"><img src="../Images/fd13e3a2228395a0037726aff8713bd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*OgOrnuAeA4nHNWx5.png"/></div></div></figure><h2 id="9172" class="mr lt iq bd lu ms mt dn ly mu mv dp mc lf mw mx me lj my mz mg ln na nb mi nc bi translated">微内核架构(插件架构)</h2><p id="9b28" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">微内核架构基于构建核心系统的思想，该核心系统包含系统实现其核心目的所需的最少功能。然后通过独立的插件提供额外的功能。想象一下 VS Code:基本的应用程序非常有限，但是通过添加插件，你可以使应用程序非常强大，并且适合你和你的项目。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nd"><img src="../Images/c1b8b77b4506aefb35450abdc7dd1ad8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*b-Jw8_9JkbBCDCRx.png"/></div></div></figure><p id="1db2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通常，插件是相互隔离的，因此相互之间是不耦合的。他们也有独立的存储空间。插件可以是核心系统整体的一部分，也可以单独部署。如果与插件的通信是通过某种标准化的消息传递形式完成的，比如 REST，那么就不需要要求所有的东西都用同一种语言编写。</p><h2 id="307a" class="mr lt iq bd lu ms mt dn ly mu mv dp mc lf mw mx me lj my mz mg ln na nb mi nc bi translated">基于服务的架构</h2><p id="c01a" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在这种架构中，功能由基于域的服务来划分。该服务可以共享数据库和用户界面，但彼此独立运行。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ne"><img src="../Images/bc2ef0c01c8ac71c614ff844480576b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ceV86CvPidVokZdn.png"/></div></div></figure><p id="71b6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">服务可以彼此独立地部署。需求较高的服务可以获得更多的资源或被复制。还可能有一个 API 代理将请求从 UI 路由到正确的服务。</p><h2 id="fad7" class="mr lt iq bd lu ms mt dn ly mu mv dp mc lf mw mx me lj my mz mg ln na nb mi nc bi translated">事件驱动架构</h2><p id="4df4" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">事件驱动系统对用户界面或内部发生的事件做出“反应”。这种系统是由事件处理器构建的；小型独立计算单元。系统中的事件流可以通过两种不同的方式发生。</p><p id="536f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">在代理拓扑下，</strong>没有对事件处理的集中控制。每个处理器可以广播它自己的事件来触发另一个处理器，形成一个事件链。不需要管理特定事件处理器或执行步骤之间的连接。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nf"><img src="../Images/7d3e6d986d46d1b0c5c003c8c4ac1551.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*g-FavJyf0qDBRK3X.png"/></div></div></figure><p id="9d41" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">在中介拓扑</strong>下有一些中央控制。当事件进入系统时，事件调解器控制调用哪些处理器以及调用的顺序。可能有多个并行或分层工作的事件调解器。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ng"><img src="../Images/ee250ea1b217c00153530477deb0b722.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*N5tVJNZg9dgsvQfV.png"/></div></div></figure><h2 id="37e0" class="mr lt iq bd lu ms mt dn ly mu mv dp mc lf mw mx me lj my mz mg ln na nb mi nc bi translated"><strong class="ak">微服务架构</strong></h2><p id="1c0a" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">微服务系统是由许多可独立部署的、专注于领域的服务构建而成的。“微”来自于这样一个事实，即每个服务应该只专注于做一件事。微服务通常使用 REST 之类的东西进行通信(可能通过 API 网关)，用不同的语言编写，并且有独立的存储。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nh"><img src="../Images/b4f0910fc1c2662e6968f00dc9d8ceab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Fn0FSx8sfW3SBLwN.png"/></div></div></figure><p id="53fa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">微服务通常是独立部署的。这是一种“云原生”架构，使用弹性来提供性能和可用性。</p><h1 id="f113" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">更多来自我</h1><p id="9950" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">如果你想更多地了解决定使用哪种架构的人，我推荐我的文章<a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/what-is-a-software-architect-5f1e441cdb2f">什么是软件架构师？</a>。</p><p id="d8f2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您想更深入地了解微服务架构，请阅读<a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/the-pitfalls-and-problems-with-microservices-a41ffcc19c38">微服务的陷阱和问题</a></p><p id="0b61" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我还在我的抖音上制作了这个主题的视频</p></div></div>    
</body>
</html>