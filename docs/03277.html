<html>
<head>
<title>Understanding FutureBuilder in Flutter</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解颤振中的未来建筑</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/understanding-futurebuilder-in-flutter-491501526373?source=collection_archive---------3-----------------------#2020-10-19">https://blog.devgenius.io/understanding-futurebuilder-in-flutter-491501526373?source=collection_archive---------3-----------------------#2020-10-19</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="6f87" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">因为您的构建方法不能是异步的</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/d37cbd04e1a4225b06bf8ed5d103dd12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yVHmY2gx4EIhSU2C"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">Emile Perron 在<a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="6b01" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在这篇文章中，我们将看看Flutter中的FutureBuilder小部件。在我们开始之前，让我们后退一步，了解一下Flutter的未来，以及如何使用异步编程。</p><h1 id="4181" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">异步编程</h1><p id="a559" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">在其最基本的形式中，异步方法允许程序在等待另一个操作完成时继续执行。这不同于同步编程，在同步编程中，操作会阻止其他操作执行，直到它完成。这些例子有:</p><ul class=""><li id="0813" class="mm mn in kv b kw kx kz la lc mo lg mp lk mq lo mr ms mt mu bi translated">通过网络获取数据(想想无限滚动)</li><li id="3019" class="mm mn in kv b kw mv kz mw lc mx lg my lk mz lo mr ms mt mu bi translated">数据库操作</li><li id="53c4" class="mm mn in kv b kw mv kz mw lc mx lg my lk mz lo mr ms mt mu bi translated">文件输入输出操作</li></ul><p id="d76d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果你以前使用过JavaScript，你会熟悉<a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="noopener ugc nofollow" target="_blank"> <em class="na">承诺</em> </a> <em class="na">的概念。</em>在dart中，我们有Future类，并使用async和await关键字。借助ECMAScript 2017规范，async/await模式也可用于JavaScript以及C#等其他编程语言。</p></div><div class="ab cl nb nc hr nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ig ih ii ij ik"><p id="4855" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在本文中，我们将制作一个简单的联系人列表应用程序，并模拟使用FutureBuilder异步加载列表。</p><h1 id="ac89" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">第一部分</h1><p id="bda7" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">在我们开始研究如何使用FutureBuilders之前，让我们先完成一些任务，比如制作模型、UI和创建一些虚拟数据。</p><h2 id="8a5b" class="ni lq in bd lr nj nk dn lv nl nm dp lz lc nn no mb lg np nq md lk nr ns mf nt bi translated">模型</h2><p id="aa14" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">首先，让我们定义我们的<em class="na">联系人</em>模型。为了简单起见，我们将采集有限的数据。</p><pre class="kd ke kf kg gt nu nv nw nx aw ny bi"><span id="729d" class="ni lq in nv b gy nz oa l ob oc"><em class="na">class </em>Contact {<br/>  <em class="na">final </em>String firstName;<br/>  <em class="na">final </em>String lastName;<br/>  <em class="na">final </em>String imageUrl;<br/>  <em class="na">final </em>String phone;<br/><br/>  Contact({<br/>    <em class="na">this</em>.firstName,<br/>    <em class="na">this</em>.lastName,<br/>    <em class="na">this</em>.imageUrl,<br/>    <em class="na">this</em>.phone,<br/>  });<br/>}</span></pre><h2 id="ded6" class="ni lq in bd lr nj nk dn lv nl nm dp lz lc nn no mb lg np nq md lk nr ns mf nt bi translated">联系卡</h2><p id="6f18" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">完成后，让我们为联系人卡片创建一个UI:</p><pre class="kd ke kf kg gt nu nv nw nx aw ny bi"><span id="c17a" class="ni lq in nv b gy nz oa l ob oc"><em class="na">import </em>'package:flutter/material.dart';<br/><em class="na">import </em>'model/contact.dart';<br/><br/><em class="na">class </em>ContactCard <em class="na">extends </em>StatelessWidget {<br/>  <em class="na">final </em>Contact contact;<br/><br/>  ContactCard(<em class="na">this</em>.contact);<br/>  @override<br/>  Widget build(BuildContext context) {<br/>    <em class="na">return </em>Container(<br/>      padding: <em class="na">const </em>EdgeInsets.symmetric(horizontal: 10),<br/>      decoration: BoxDecoration(<br/>        border: Border(<br/>          bottom: BorderSide(<br/>            color: Colors.<em class="na">grey</em>[500],<br/>            width: 0.5,<br/>          ),<br/>        ),<br/>      ),<br/>      child: Row(<br/>        crossAxisAlignment: CrossAxisAlignment.center,<br/>        children: [<br/>          Container(<br/>            padding: <em class="na">const </em>EdgeInsets.only(top: 10, right: 15, bottom: 10),<br/>            child: ClipOval(<br/>              child: Image.network(<br/>                contact.imageUrl,<br/>                width: 50,<br/>                height: 50,<br/>              ),<br/>            ),<br/>          ),<br/>          Expanded(<br/>            child: Column(<br/>              crossAxisAlignment: CrossAxisAlignment.start,<br/>              children: [<br/>                Text('${contact.firstName} ${contact.lastName}'),<br/>                SizedBox(height: 2),<br/>                Text('${contact.phone}'),<br/>              ],<br/>            ),<br/>          ),<br/>          Row(<br/>            mainAxisSize: MainAxisSize.min,<br/>            children: [<br/>              Icon(<br/>                Icons.<em class="na">create</em>,<br/>                color: Colors.<em class="na">grey</em>[600],<br/>              ),<br/>              SizedBox(width: 15.0),<br/>              Icon(<br/>                Icons.<em class="na">message</em>,<br/>                color: Colors.<em class="na">grey</em>[600],<br/>              ),<br/>              SizedBox(width: 15.0),<br/>              Icon(<br/>                Icons.<em class="na">call</em>,<br/>                color: Colors.<em class="na">grey</em>[600],<br/>              ),<br/>            ],<br/>          ),<br/>        ],<br/>      ),<br/>    );<br/>  }<br/>}</span></pre><h2 id="8725" class="ni lq in bd lr nj nk dn lv nl nm dp lz lc nn no mb lg np nq md lk nr ns mf nt bi translated">虚拟数据</h2><p id="339f" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">关于虚拟数据，请参考<a class="ae ks" href="https://github.com/stef0296/future_builder/blob/main/lib/dummy-data.dart" rel="noopener ugc nofollow" target="_blank">虚拟数据. dart </a>文件。现在，我们已经完成了与创建数据和部分UI相关的次要任务，让我们开始手头的主要任务，即构建显示联系人的ListView。</p><h1 id="edd8" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">第二部分</h1><p id="d820" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">现在我们已经完成了应用程序的所有构建模块，让我们把它们放在一起，看看我们的应用程序是什么样子的。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="od oe l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">来源:<a class="ae ks" href="https://giphy.com/gifs/Bi6FcO7UoutWM" rel="noopener ugc nofollow" target="_blank"> Giphy </a></figcaption></figure><p id="3891" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在让我们从定义我们的未来开始，这将获取我们的联系人数据。</p><pre class="kd ke kf kg gt nu nv nw nx aw ny bi"><span id="4932" class="ni lq in nv b gy nz oa l ob oc">Future&lt;List&lt;Contact&gt;&gt; _getContacts() async {<br/>  List&lt;Contact&gt; contacts = dummyData;<br/>  await Future.delayed(Duration(seconds: 10));<br/>  return Future.value(contacts);<br/>}</span></pre><p id="76cd" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们从前面定义的虚拟数据中获取联系人。在下一行中，您将看到我使用了Future.delayed()方法。这可用于在定义的时间内暂停代码执行。这有助于我们模拟从服务器获取数据时通常会观察到的缓冲区。完成延迟值后，我们使用Future.value()方法返回联系人列表。</p><p id="1e55" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">接下来要做的是定义一个变量，这个变量将包含我们刚刚定义的未来。</p><pre class="kd ke kf kg gt nu nv nw nx aw ny bi"><span id="1852" class="ni lq in nv b gy nz oa l ob oc">Future&lt;List&lt;Contact&gt;&gt; _contacts;</span></pre><p id="3e2a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们将我们的<em class="na"> _getContacts() </em>未来分配给initState()中的<em class="na"> _contacts </em>变量。</p><pre class="kd ke kf kg gt nu nv nw nx aw ny bi"><span id="74ac" class="ni lq in nv b gy nz oa l ob oc">@override<br/>void initState() {<br/>  super.initState();<br/>  _contacts = _getContacts();<br/>}</span></pre><p id="3ae9" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在你一定想知道为什么我们这样做是对的？难道不能直接把<em class="na"> _getContacts() </em>直接赋给FutureBuilder，而不是引入另一个变量吗？</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="of oe l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">来源:<a class="ae ks" href="https://giphy.com/gifs/reaction-1X7lCRp8iE0yrdZvwd" rel="noopener ugc nofollow" target="_blank"> Giphy </a></figcaption></figure><p id="ba3a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果您通读了Flutter文档，您会注意到build方法可以在任何时候被调用。这将包括setState()或设备方向更改。这意味着设备配置或小部件重建的任何变化都将多次触发您的未来。为了防止这种情况，我们确保未来是在<em class="na"> initState() </em>中获得的，而不是在<em class="na"> build() </em>方法本身中获得的。这是你可能在很多在线教程中注意到的，他们把未来方法直接分配给未来建造者，这实际上是错误的。</p><p id="b801" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在我们已经解决了这个问题，让我们看看我们的<em class="na"> build() </em>方法:</p><pre class="kd ke kf kg gt nu nv nw nx aw ny bi"><span id="b8e0" class="ni lq in nv b gy nz oa l ob oc">@override<br/>Widget build(BuildContext context) {<br/>  return FutureBuilder&lt;List&lt;Contact&gt;&gt;(<br/>    future: _contacts,<br/>    builder: (ctx, snapshot) {<br/>      List&lt;Contact&gt; contacts = snapshot.data;<br/>      switch (snapshot.connectionState) {<br/>        case ConnectionState.done:<br/>        return _buildListView(contacts);<br/>        default:<br/>        return _buildLoadingScreen();<br/>      }<br/>    },<br/>  );<br/>}</span><span id="c064" class="ni lq in nv b gy og oa l ob oc">Widget _buildListView(List&lt;Contact&gt; contacts) {<br/>  return ListView.builder(<br/>    itemBuilder: (ctx, idx) {<br/>      return ContactCard(contacts[idx]);<br/>    },<br/>    itemCount: contacts.length,<br/>  );<br/>}</span><span id="31c1" class="ni lq in nv b gy og oa l ob oc">Widget _buildLoadingScreen() {<br/>  return Center(<br/>    child: Container(<br/>    width: 50,<br/>    height: 50,<br/>    child: CircularProgressIndicator(),<br/>    ),<br/>  );<br/>}</span></pre><p id="fbe4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们用列表类型&lt;联系人类型&gt;来定义我们的<em class="na"> FutureBuilder() </em>。虽然这不是绝对必要的，但在我们的构建器方法中，这对于类型推断是有帮助的。我们将<em class="na"> _contacts </em>未来交给未来的建造者。</p><p id="211c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">FutureBuilders的一个优点是我们有可用的ConnectionState枚举。根据快照的连接状态，我们可以显示不同的小部件，如加载屏幕或错误屏幕。</p><p id="dd41" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们基本上有四种状态。</p><ol class=""><li id="918d" class="mm mn in kv b kw kx kz la lc mo lg mp lk mq lo oh ms mt mu bi translated"><a class="ae ks" href="https://api.flutter.dev/flutter/widgets/ConnectionState-class.html" rel="noopener ugc nofollow" target="_blank">无</a>，可能有一些初始数据。</li><li id="31b4" class="mm mn in kv b kw mv kz mw lc mx lg my lk mz lo oh ms mt mu bi translated"><a class="ae ks" href="https://api.flutter.dev/flutter/widgets/ConnectionState-class.html" rel="noopener ugc nofollow" target="_blank">等待</a>，表示异步操作已经开始，通常数据为空。</li><li id="b0e7" class="mm mn in kv b kw mv kz mw lc mx lg my lk mz lo oh ms mt mu bi translated"><a class="ae ks" href="https://api.flutter.dev/flutter/widgets/ConnectionState-class.html" rel="noopener ugc nofollow" target="_blank">激活</a>，数据不为空，可能随时间变化。</li><li id="15e1" class="mm mn in kv b kw mv kz mw lc mx lg my lk mz lo oh ms mt mu bi translated"><a class="ae ks" href="https://api.flutter.dev/flutter/widgets/ConnectionState-class.html" rel="noopener ugc nofollow" target="_blank">完成</a>，数据非空。</li></ol><p id="2e44" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在我们已经准备好了所有的部分，让我们看看我们的应用程序是什么样子的:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/48d5b4e859aeac55750a0112fb9eb5a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:736/1*x1i4NrTXrEKtrpUr1cx11Q.gif"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">获取数据时显示加载屏幕</figcaption></figure><p id="a7c4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们最初有一个10秒钟可见的加载屏幕，随后，它被替换为<em class="na"> ListView.builder()。</em>根据不同的连接状态，我们可以有额外的屏幕，但是，为了简单起见，我们将坚持使用2个屏幕。</p><h1 id="c6f4" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">包裹</h1><p id="17dc" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">我们了解了异步编程是如何工作的，并设计和构建了一个简单的联系人应用程序来演示<em class="na"> FutureBuilder </em>方法是如何工作的。我们也了解了为什么我们应该在<em class="na"> initState() </em>中而不是在build方法中获得我们的<em class="na">未来</em>。最后，我们看到了ConnectionState枚举以及如何在我们的构建器中使用它。</p><p id="b14f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果你喜欢这个，请通过鼓掌和评论让我知道。此外，请随意评论您希望我在下一篇文章中涵盖的主题。在那之前，编码快乐！</p><p id="e42a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">你可以在这里查看完整的代码:</p><div class="oj ok gp gr ol om"><a href="https://github.com/stef0296/future_builder" rel="noopener  ugc nofollow" target="_blank"><div class="on ab fo"><div class="oo ab op cl cj oq"><h2 class="bd io gy z fp or fr fs os fu fw im bi translated">stef 0296/未来建造者</h2><div class="ot l"><h3 class="bd b gy z fp or fr fs os fu fw dk translated">这个项目是一个Flutter应用程序的起点。一些资源来…</h3></div><div class="ou l"><p class="bd b dl z fp or fr fs os fu fw dk translated">github.com</p></div></div><div class="ov l"><div class="ow l ox oy oz ov pa km om"/></div></div></a></div><p id="b75c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">参考:</p><p id="1d00" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><a class="ae ks" href="https://api.flutter.dev/flutter/widgets/FutureBuilder/future.html" rel="noopener ugc nofollow" target="_blank">https://API . flutter . dev/flutter/widgets/future builder/future . html</a></p><p id="05c9" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><a class="ae ks" href="https://api.flutter.dev/flutter/widgets/FutureBuilder-class.html" rel="noopener ugc nofollow" target="_blank">https://API . flutter . dev/flutter/widgets/future builder-class . html</a></p><p id="ec92" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><a class="ae ks" href="https://api.flutter.dev/flutter/widgets/ConnectionState-class.html" rel="noopener ugc nofollow" target="_blank">https://API . flutter . dev/flutter/widgets/connection state-class . html</a></p></div></div>    
</body>
</html>