<html>
<head>
<title>Singleton Pattern for One-Of-a-Kind Objects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">独一无二的对象的单例模式</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/singleton-pattern-for-one-of-a-kind-objects-java-a63c774d9d4?source=collection_archive---------7-----------------------#2022-03-19">https://blog.devgenius.io/singleton-pattern-for-one-of-a-kind-objects-java-a63c774d9d4?source=collection_archive---------7-----------------------#2022-03-19</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="66d6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi ki translated">欢迎回到设计模式系列！👻这是一组文章，我决定发起传播他们的知识👀</p><p id="070d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">不要错过我在该系列中的其他文章:</p><ul class=""><li id="6e1f" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh kw kx ky kz bi translated">策略模式:<a class="ae la" href="/towardsdev/strategy-pattern-for-independent-algorithms-kotlin-70ed24c7bd8b" rel="noopener ugc nofollow" target="_blank">https://medium . com/toward sdev/strategy-pattern-for-independent-algorithms-kot Lin-70 ed 24 c 7 BD 8 b</a></li><li id="af60" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">观察者模式:<a class="ae la" href="/towardsdev/observer-pattern-for-loose-coupling-kotlin-f5ab804609bb" rel="noopener ugc nofollow" target="_blank">https://medium . com/toward sdev/observer-pattern-for-loose-coupling-kot Lin-f5ab 804609 bb</a></li><li id="21c6" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">装饰者模式:<a class="ae la" href="/towardsdev/decorator-decorator-pattern-for-object-composition-kotlin-7cec92cbaf7b" rel="noopener ugc nofollow" target="_blank">https://medium . com/toward sdev/decorator-decorator-pattern-for-object-composition-kot Lin-7 CEC 92 cbaf 7b</a></li><li id="de54" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">工厂模式:<a class="ae la" href="https://medium.com/dev-genius/factory-patterns-to-hide-instantiation-kotlin-d5f01cf01921" rel="noopener">https://medium . com/dev-genius/factory-patternS-to-hide-instantiation-kot Lin-D5 f 01 cf 01921</a></li></ul><p id="99bc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你想更深入地研究模式的世界，请不要吝啬这本书:<a class="ae la" href="https://www.oreilly.com/library/view/head-first-design/9781492077992/" rel="noopener ugc nofollow" target="_blank">https://www . oreilly . com/library/view/head-first-design/9781492077992/</a></p><p id="ad5b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">结构:</p><ul class=""><li id="a61d" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh kw kx ky kz bi translated">介绍</li><li id="a7a4" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">问题</li><li id="8ef2" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">设计遵循的原则:<code class="fe li lj lk ll b">null</code> <strong class="jm io">本文中的</strong></li><li id="e041" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">额外部分</li><li id="fc04" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">最终解决方案代码(在本文中，它不同于以前的代码)</li><li id="13ab" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">图画</li></ul><p id="6768" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">前言:【https://wickedlysmart.com/head-first-design-patterns/】正如我上面提到的，在本文中我不会使用我自己的代码，而是本书作者提供的 Java 代码:<a class="ae la" href="https://wickedlysmart.com/head-first-design-patterns/" rel="noopener ugc nofollow" target="_blank"/>。为什么这样你会在 article✌️的主要部分找到它</strong></p></div><div class="ab cl lm ln hr lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="ig ih ii ij ik"><h1 id="972c" class="lt lu in bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">单一模式</h1><h2 id="c4c6" class="mr lu in bd lv ms mt dn lz mu mv dp md jv mw mx mh jz my mz ml kd na nb mp nc bi translated">介绍</h2><p id="9081" class="pw-post-body-paragraph jk jl in jm b jn nd jp jq jr ne jt ju jv nf jx jy jz ng kb kc kd nh kf kg kh ig bi translated">当你开始在不同的程序中编写软件时，你会发现相同的模式可能会以稍微不同的方式实现。举例？</p><ul class=""><li id="854f" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh kw kx ky kz bi translated"><strong class="jm io"> Singleton </strong>在 Java 中使用<code class="fe li lj lk ll b">static</code>，但在 Kotlin 中它只是<code class="fe li lj lk ll b">object</code>，而在 Python 中它利用了<code class="fe li lj lk ll b">metaclass</code>及其周围的东西</li><li id="f844" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated"><strong class="jm io">适配器</strong>(模式将在下一篇文章中出现)有两个主要实现:它在 Java 中使用<em class="ni">组合</em>(由于缺少<em class="ni">多重继承</em>)和在 Python 中使用<em class="ni">多重继承</em>(尽管没有人限制您使用<em class="ni">组合</em>)</li></ul><p id="7ce2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我想强调的是，不同语言的概念是一样的，但是实现可能是 vary☝️</p><blockquote class="nj nk nl"><p id="c229" class="jk jl ni jm b jn jo jp jq jr js jt ju nm jw jx jy nn ka kb kc no ke kf kg kh ig bi translated">这就是为什么大师们证明:“不要死记硬背实现，而是要理解超越一种语言的概念”</p></blockquote><h2 id="1569" class="mr lu in bd lv ms mt dn lz mu mv dp md jv mw mx mh jz my mz ml kd na nb mp nc bi translated">问题</h2><p id="194b" class="pw-post-body-paragraph jk jl in jm b jn nd jp jq jr ne jt ju jv nf jx jy jz ng kb kc kd nh kf kg kh ig bi translated">想象一下，你有一个程序，它有多个线程，缓存和类似的东西。我们不希望他们互相混杂。</p><p id="323d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">想到的可能的解决方案？</p><ul class=""><li id="49d9" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh kw kx ky kz bi translated">使用<code class="fe li lj lk ll b">global</code> <strong class="jm io">变量</strong></li><li id="48e8" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">使用<code class="fe li lj lk ll b">static</code></li></ul><p id="f8c5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们马上剖析这些例子:</p><ol class=""><li id="9248" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh np kx ky kz bi translated"><code class="fe li lj lk ll b">global</code>不是一个好主意，因为它们通常在应用程序启动时被初始化。因此，如果一个是<strong class="jm io">资源密集型</strong>应用程序导致从不使用它- &gt;浪费宝贵的资源👎🏼</li><li id="8161" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh np kx ky kz bi translated">在某些情况下，将所有东西都声明为<code class="fe li lj lk ll b">static</code>可能是一种选择，但是它有一个很大的缺点。哪一个？与初始化顺序相关的细微错误，因此过度使用<code class="fe li lj lk ll b">static</code>可能会导致难以发现的问题</li></ol><p id="f0b8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe li lj lk ll b">=&gt;</code>为了拯救我们，开发了<strong class="jm io">单例模式</strong>来确保身份(唉，并不总是这样，但我会在<strong class="jm io">额外部分</strong>中提到它)</p><p id="3645" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">它利用私有和公共的构造函数和心爱的<code class="fe li lj lk ll b">static</code>关键字。</p><p id="054d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我向你展示达到模式最终状态的步骤👨🏻‍💻：</p><ol class=""><li id="91c0" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh np kx ky kz bi translated">为了使类适合实例化，我们需要<code class="fe li lj lk ll b">public constructor</code>:</li></ol><p id="b111" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe li lj lk ll b">public ExampleOfClass</code></p><p id="cdb6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">2.为了使一个类对外部世界不可见，我们将它转储到前面的公共类中，并使它:</p><p id="3bb4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe li lj lk ll b">private ExampleOfInnerClass</code></p><p id="81fa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">3.为了初始化这个内部类，我们肯定需要调用一些方法。使用<code class="fe li lj lk ll b">static</code>使其可从<code class="fe li lj lk ll b">public</code>构造器访问:</p><p id="4d3c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe li lj lk ll b">public static ExampleOfInnerClass getInstance()</code></p><p id="b80d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">4.为什么将<code class="fe li lj lk ll b">static</code>用于<strong class="jm io">单例</strong>变量，例如:</p><p id="b8b4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe li lj lk ll b">private static Singleton uniqueInstance</code></p><p id="cebb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">阅读以下关于<a class="lg lh ep" href="https://medium.com/u/d53dd768d047?source=post_page-----a63c774d9d4--------------------------------" rel="noopener" target="_blank">堆栈溢出</a>的帖子:<a class="ae la" href="https://stackoverflow.com/a/26993425/16543524" rel="noopener ugc nofollow" target="_blank">https://stackoverflow.com/a/26993425/16543524</a></p><p id="22ee" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">毕竟，让我们观察单例模式的最终代码，并讨论 it🛠的可能修改</p><h2 id="f340" class="mr lu in bd lv ms mt dn lz mu mv dp md jv mw mx mh jz my mz ml kd na nb mp nc bi translated">额外部分</h2><p id="52d9" class="pw-post-body-paragraph jk jl in jm b jn nd jp jq jr ne jt ju jv nf jx jy jz ng kb kc kd nh kf kg kh ig bi translated">但首先，让我说一点题外话:</p><ul class=""><li id="6beb" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh kw kx ky kz bi translated">什么是<code class="fe li lj lk ll b">static</code>？我不是一个重 JVM 的家伙，但可以解释一下:这个词告诉 JVM，当应用程序启动时，它应该用这个关键字<strong class="jm io">初始化(或只是记住)变量。</strong></li><li id="3997" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">记住<strong class="jm io">单例</strong>不是简单的<em class="ni">为了模式而模式</em>的东西。它里面可以有很多种方法。</li><li id="feef" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">当另一个线程/资源访问<strong class="jm io"> Singleton </strong>时，它检查方法:实例是否已经初始化？如果你不明白我对 about🧐的说教，请看下一节的<code class="fe li lj lk ll b">getInstance()</code>方法</li><li id="6bc9" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">该模式违反了<strong class="jm io">实</strong>中的 S:<strong class="jm io">单一责任原则</strong>。</li></ul><blockquote class="nj nk nl"><p id="16da" class="jk jl ni jm b jn jo jp jq jr js jt ju nm jw jx jy nn ka kb kc no ke kf kg kh ig bi translated">类应该只做一件事，不要与各种</p></blockquote><ul class=""><li id="e199" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh kw kx ky kz bi translated">那么，<strong class="jm io">单例</strong>不就是<strong class="jm io">松耦合</strong>吗</li></ul><p id="daf4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最后两个项目符号并不意味着该模式在某种程度上是低劣的。它经常因此受到批评，但这就是世界的真相:我们并不总是坚持最佳实践🤷‍♂️</p><ul class=""><li id="a129" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh kw kx ky kz bi translated">科特林没有成熟的<strong class="jm io">单例模式</strong>，也就是说，它只是一个简单的<code class="fe li lj lk ll b">object</code>。这就是为什么我决定用 Java 解释一切</li><li id="6b78" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">当我们有多个类装入器&amp; <strong class="jm io">单例类</strong>时，可能会出现<strong class="jm io">单例类</strong>的问题。解决方案？自己指定类装入器。</li></ul><h2 id="ba6f" class="mr lu in bd lv ms mt dn lz mu mv dp md jv mw mx mh jz my mz ml kd na nb mp nc bi translated"><strong class="ak">最终解决方案代码</strong></h2><p id="e42a" class="pw-post-body-paragraph jk jl in jm b jn nd jp jq jr ne jt ju jv nf jx jy jz ng kb kc kd nh kf kg kh ig bi translated">首先，让我们看看基本的<strong class="jm io"> Singleton </strong>，然后我们会考虑改善它的方法</p><figure class="nq nr ns nt gt nu"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="f8de" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">正如我在之前的文章中所描述的:</p><ul class=""><li id="a597" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh kw kx ky kz bi translated"><code class="fe li lj lk ll b">public class Singleton </code>构造器使类对外部世界可访问</li><li id="4024" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated"><code class="fe li lj lk ll b">private Singleton</code>构造函数使类对外部世界不可见</li><li id="4b64" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated"><code class="fe li lj lk ll b">public static Singleton getInstance()</code>允许<code class="fe li lj lk ll b">public class Singleton</code>访问该方法</li><li id="36af" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated"><code class="fe li lj lk ll b">private static Singleton uniqueInstance</code>同样的帖子在<a class="lg lh ep" href="https://medium.com/u/d53dd768d047?source=post_page-----a63c774d9d4--------------------------------" rel="noopener" target="_blank">栈溢出</a>:<a class="ae la" href="https://stackoverflow.com/a/26993425/16543524" rel="noopener ugc nofollow" target="_blank">https://stackoverflow.com/a/26993425/16543524</a></li></ul><p id="cbe8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你会想:有什么可以改进的？老实说，总体结构保持不变，但是要应用一些小的变化(它们带来的重要性范围并不小)。</p><p id="f0d6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果我们有多个线程，它们同时访问单个的会怎么样？- &gt;当每个线程都可能进入这个类时会引起骚动，在和<code class="fe li lj lk ll b">if (uniqueInstance == null)</code>之后<strong class="jm io">它们都将创建自己的实例。因此它引起了许多麻烦😰</strong></p><p id="0538" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">怎么才能修好？</p><ol class=""><li id="2490" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh np kx ky kz bi translated">在<code class="fe li lj lk ll b">getInstance()</code>方法中使用<code class="fe li lj lk ll b">synchronized</code>关键字。这将导致线程等待，直到另一个解锁方法。</li></ol><p id="0bf2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">遵守代码:</p><figure class="nq nr ns nt gt nu"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="0bd4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">关注<code class="fe li lj lk ll b">synchronized</code></p><p id="fc6f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">2.“热切创造”的独生子女</p><p id="047f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">首先看看代码，然后我会一步一步地解释他们是如何做到的:</p><figure class="nq nr ns nt gt nu"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="8d4d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">回忆一下<code class="fe li lj lk ll b">static</code>的解释？同样，当 app 被初始化时，JVM 开始了解所有的<code class="fe li lj lk ll b">static</code>。这里，我们的<code class="fe li lj lk ll b">static</code>变量调用方法来创建一个<strong class="jm io">单例</strong>实例<code class="fe li lj lk ll b">=&gt;</code>当我们进一步使用该方法时，变量将已经被初始化。</p><p id="2997" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">3.DCI:双重检查锁定</p><p id="a3a1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你知道<code class="fe li lj lk ll b">synchronized</code>的骗局吗？它会消耗大量资源，如果它很关键，我们有一个解决方案:</p><figure class="nq nr ns nt gt nu"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="eeaf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，在这种方法中，如果两个线程发现自己在 <code class="fe li lj lk ll b">if (uniqueInstance == null)</code>之后<strong class="jm io">，代码阻塞变量，然后进行第二次检查(为什么？- &gt;暂时请等待🙏)，如果还是<code class="fe li lj lk ll b">null</code>，初始化变量。所以，你可以拥有 questions❓:</strong></p><ul class=""><li id="0b3f" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh kw kx ky kz bi translated">为什么要第二次检查？因此，两个线程通过了第一个<code class="fe li lj lk ll b">if</code>检查。然后，我们通过<code class="fe li lj lk ll b">synchronized</code>进行阻挡。第一个线程已结束初始化，第二个线程开始运行。但是在第二次<code class="fe li lj lk ll b">if</code>检查中:实例已经存在- &gt;不需要创建它。当实例没有实现时，我们只使用一次<code class="fe li lj lk ll b">synchronized</code>。</li><li id="c6ed" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">什么是<code class="fe li lj lk ll b">violate</code>？它告诉<strong class="jm io">线程</strong>在变量的当前值中查找(在我们的例子中，它在类内部)，但是不在线程的<strong class="jm io">缓存</strong>中查找(在那里变量可能没有被初始化)</li></ul><p id="63f0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">‼️Danger‼️:这种方法在 Java 5 之前是行不通的</p><p id="def8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">4.我们也可以用 Java Enum 做<strong class="jm io"> Singleton </strong>，但是我将在本文中跳过它。</p><h2 id="5dd9" class="mr lu in bd lv ms mt dn lz mu mv dp md jv mw mx mh jz my mz ml kd na nb mp nc bi translated"><strong class="ak">图纸</strong>💫</h2><figure class="nq nr ns nt gt nu gh gi paragraph-image"><div role="button" tabindex="0" class="ny nz di oa bf ob"><div class="gh gi nx"><img src="../Images/b5a076398a0909e704d871fcd0e5c321.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U5zuWtQtxceU6D7InRC3cg.jpeg"/></div></div></figure><p id="f369" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在照片中你可以看到我的涂鸦🙄我画了各种实现，做了几点注释。</p><blockquote class="nj nk nl"><p id="9be8" class="jk jl ni jm b jn jo jp jq jr js jt ju nm jw jx jy nn ka kb kc no ke kf kg kh ig bi translated">如果你没有得到什么，留下评论，我会来解释</p></blockquote><h2 id="e3d9" class="mr lu in bd lv ms mt dn lz mu mv dp md jv mw mx mh jz my mz ml kd na nb mp nc bi translated">结尾部分📣</h2><blockquote class="nj nk nl"><p id="8910" class="jk jl ni jm b jn jo jp jq jr js jt ju nm jw jx jy nn ka kb kc no ke kf kg kh ig bi translated"><strong class="jm io">单例模式</strong>的学术定义:它确保类只有一个实例。此外，它还提供了一个<strong class="jm io">全局访问点</strong></p></blockquote><p id="43e4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">今天就这些了。查看我在该系列中以前的文章👋</p><p id="c61f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你可以找到我:</p><ul class=""><li id="d0df" class="kr ks in jm b jn jo jr js jv kt jz ku kd kv kh kw kx ky kz bi translated">领英:<a class="ae la" href="http://www.linkedin.com/in/sleeplesschallenger" rel="noopener ugc nofollow" target="_blank">www.linkedin.com/in/sleeplesschallenger</a></li><li id="3d39" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">GitHub:<a class="ae la" href="https://github.com/SleeplessChallenger" rel="noopener ugc nofollow" target="_blank">https://github.com/SleeplessChallenger</a></li><li id="9f70" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">leet code:<a class="ae la" href="https://leetcode.com/SleeplessChallenger/" rel="noopener ugc nofollow" target="_blank">https://leetcode.com/SleeplessChallenger/</a></li><li id="df45" class="kr ks in jm b jn lb jr lc jv ld jz le kd lf kh kw kx ky kz bi translated">电报:@无眠挑战者</li></ul></div></div>    
</body>
</html>