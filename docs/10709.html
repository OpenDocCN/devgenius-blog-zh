<html>
<head>
<title>Data Cleaning Using SQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 SQL 清理数据</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/data-cleaning-using-sql-eca765259779?source=collection_archive---------1-----------------------#2022-11-24">https://blog.devgenius.io/data-cleaning-using-sql-eca765259779?source=collection_archive---------1-----------------------#2022-11-24</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="2b0a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最近我做了一个关于使用 SQL 清理数据的个人项目。在这篇文章中，我将从头到尾解释整个过程。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/fcb51175ea3bb65c0095a2cfc272a904.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wnu0hHFaj6wDj8-oe_CtEQ.jpeg"/></div></div></figure><h1 id="3213" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">介绍</h1><p id="d058" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated"><strong class="jm io">数据清理</strong>是纠正或删除脏数据的过程，即数据集或数据库中不正确、损坏、格式不正确、重复或不完整的数据。</p><p id="6d69" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> SQL </strong>代表<strong class="jm io">结构化查询语言</strong>，是一种用于在关系数据库中查询和操作结构化数据的语言。当我们处理 MS Excel 或 Google Sheets 等电子表格程序无法处理的大量数据时，SQL 是数据分析中非常有用的工具。</p><p id="45f8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有许多 SQL 编辑器，您可以加载数据集或数据库来操作和查询，以获得必要的信息。一些流行的 SQL 编辑器有 MySQL、Microsoft SQL Server、Postgre SQL、Bigquery、SQL Lite 等。所有 SQL 编辑器的基本语法都是相似的，但是在不同的 SQL 编辑器中可能会有一些细微的差别。</p><p id="2bcc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对于这个特殊的项目，我使用了微软的 SQL 服务器。</p><p id="b175" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我写的完整查询可以在这里  找到<a class="ae lx" href="https://bit.ly/3TF7tV3" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> <em class="ly">。</em></strong></a></p><h2 id="30c6" class="lz kv in bd kw ma mb dn la mc md dp le jv me mf li jz mg mh lm kd mi mj lq mk bi translated"><strong class="ak">数据集</strong></h2><p id="4b68" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">我在这个项目中使用的数据集是我从<a class="ae lx" href="https://www.kaggle.com/datasets/tmthyjames/nashville-housing-data" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> Kaggle </strong> </a>获得的没有任何<strong class="jm io"> PII </strong>(个人身份信息)的开源数据。在这个数据集中，有关于热门的纳什维尔住房市场的家庭价值数据的信息。这个数据集中有超过 56000 行和 19 列，标题分别为:UniqueID、ParcelID、LandUse、PropertyAddress、SaleDate、SalePrice、LegalReference、soldas vaitable、OwnerName、OwnerAddress、areas、TaxDistrict、LandValue、BuildingValue、TotalValue、year building、believes、FullBath、HalfBath。该数据集有许多不一致之处，这使得该数据集非常适合进行数据清理。</p></div><div class="ab cl ml mm hr mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ig ih ii ij ik"><h1 id="40c3" class="ku kv in bd kw kx ms kz la lb mt ld le lf mu lh li lj mv ll lm ln mw lp lq lr bi translated">目标</h1><p id="1a3b" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">清理该数据集时，我的目标如下:</p><ol class=""><li id="8212" class="mx my in jm b jn jo jr js jv mz jz na kd nb kh nc nd ne nf bi translated">必要时标准化日期格式。</li><li id="d62b" class="mx my in jm b jn ng jr nh jv ni jz nj kd nk kh nc nd ne nf bi translated">填充 PropertyAddress 列中存在的空值。</li><li id="1468" class="mx my in jm b jn ng jr nh jv ni jz nj kd nk kh nc nd ne nf bi translated">必要时将地址、城市和州分成单独的列。</li><li id="145f" class="mx my in jm b jn ng jr nh jv ni jz nj kd nk kh nc nd ne nf bi translated">必要时将缩写转换成它们各自的完整形式。</li><li id="1006" class="mx my in jm b jn ng jr nh jv ni jz nj kd nk kh nc nd ne nf bi translated">移除和删除重复值。</li><li id="ae5c" class="mx my in jm b jn ng jr nh jv ni jz nj kd nk kh nc nd ne nf bi translated">删除未使用的列。</li></ol></div><div class="ab cl ml mm hr mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ig ih ii ij ik"><h1 id="964d" class="ku kv in bd kw kx ms kz la lb mt ld le lf mu lh li lj mv ll lm ln mw lp lq lr bi translated">程序</h1><p id="0ff2" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">首先，我调出整个数据集来查看其中的所有行、列和数据。我研究数据，找出数据集中的不一致之处。数据集中存在一些主要错误，例如，在<strong class="jm io">销售日期</strong>列中，数据类型为<strong class="jm io">日期-时间</strong>；在数据集的某些重要部分存在许多<strong class="jm io"> NULL </strong>值，例如在<strong class="jm io"> PropertyAddress </strong>列中；无论哪里有地址，实际的本地地址、城市和州(如果有的话)都集中在一列中，由一个<strong class="jm io">分隔符</strong>分隔，这将使分析变得困难；<strong class="jm io">缩写</strong>出现，可能会在后期阶段使利益相关者混淆；存在一些分析不需要的额外列。</p><h2 id="8ace" class="lz kv in bd kw ma mb dn la mc md dp le jv me mf li jz mg mh lm kd mi mj lq mk bi translated">必要时标准化日期格式</h2><p id="7c67" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">在<strong class="jm io">销售日期</strong>列中，日期的默认格式为<strong class="jm io">日期时间</strong>。但是对于分析来说，<strong class="jm io">时间</strong>组件是不必要的，因此必须删除，只保留<strong class="jm io">日期</strong>组件。我通过使用以下查询做到了这一点:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nl"><img src="../Images/abde9e37ccff3b4fc90c50980cda2170.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zp3lEO6C30W65mjzLJBZ0g.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">查询 1</figcaption></figure><p id="e391" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">消除时间约束的过程可以通过两种方式来完成，如上面的查询所示。在我的例子中，第一个查询由于某种原因没有正常工作，所以我不得不使用<strong class="jm io"> ALTER TABLE </strong>命令来代替。在这里，我创建了一个名为<strong class="jm io"> SaleDateConverted </strong>的新列并对其进行了转换，并将数据类型设置为<strong class="jm io"> DATE </strong>。逐一运行该查询后，结果如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nq"><img src="../Images/4fb8a2bbe88106edb89036759ce2aeb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:586/format:webp/1*hjTQTAxitCoH9Vgml8KB8Q.png"/></div></div></figure><p id="2a6e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在上图中，可以看到一个名为<strong class="jm io"> SalesDateConverted </strong>的新列被创建，并且只保留日期，而不是日期和时间。</p><h2 id="9c12" class="lz kv in bd kw ma mb dn la mc md dp le jv me mf li jz mg mh lm kd mi mj lq mk bi translated">填充 PropertyAddress 列中存在的空值</h2><p id="f397" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">在浏览数据时，我发现数据集中有许多字段都有空值。如果不消除这些问题，它们会在执行分析时导致重大问题，并且还会显著改变结果。</p><p id="aaa7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">其中一个可能导致很多问题的列是<strong class="jm io"> PropertyAddress </strong>列，因为没有它的地址就不可能在市场上找到房产。为了找到空值，我编写了以下查询:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/0f268d5930903ee58249cbe87ced15ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j8QxngOC_-XL1BaFCKeAiQ.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">查询 2</figcaption></figure><p id="62ac" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">运行查询后，结果如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/80f7c6fdbea1654a622bf5f56f18c43c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kIGsEmeKc1ryTx8gNoZ8iA.png"/></div></div></figure><p id="5a77" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在上图中，可以看到查询提取了所有的空值。总共存在<strong class="jm io"> 104 个空</strong>值。</p><p id="bc1d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一旦我发现所有的<strong class="jm io"> NULL </strong>值，它们必须用属性地址填充，因为这个字段不能保持空白。如果您仔细观察该表，您会注意到具有<strong class="jm io">相同 ParcelID </strong>的<strong class="jm io">行</strong>具有<strong class="jm io">相同的属性地址</strong>。为了使这种比较更容易，您可以键入以下查询并运行它(可选)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/96bd259bdba114e0dde40faa4d2214d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8D7ENQ1M5FerfgiEMP1CQg.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">查询 3</figcaption></figure><p id="89a2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，当确认对于同一个<strong class="jm io">ParcelID</strong>,<strong class="jm io">property address</strong>也是相同的，您可以使用它来填充特定列中的<strong class="jm io"> NULL </strong>值。为此，我必须在表上做一个<strong class="jm io">自连接</strong>，以便使用<strong class="jm io"> ParcelID </strong>和<strong class="jm io"> PropertyAddress </strong>之间的关系来填充<strong class="jm io"> NULL </strong>值。执行此操作的查询如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/9405159e726f2aa334b95577801c9f4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FEjz30hnjxLYt0TWX6uFlg.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">查询 4</figcaption></figure><p id="2043" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在上面的查询中，我只是随机地将连接的表命名为<strong class="jm io">‘a’</strong>和<strong class="jm io">‘b’</strong>，以使它们与<strong class="jm io">连接</strong>不同。<strong class="jm io"> ISNULL </strong>的语法是<em class="ly"> ISNULL(我们要寻找一个空值，我们要用什么来填充空值)。</em>is NULL 查询用地址填充了<strong class="jm io"> NULL </strong>单元格，其中<strong class="jm io"> ParcelID </strong>是公共的，而<strong class="jm io"> UniqueID </strong>不匹配。我使用了<strong class="jm io"> UniqueID </strong>来确保相同的 parcel ID 不会被比较两次(因为两个不同行的 parcel id 可能相同，但不是唯一 id)。</p><p id="25a7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，我已经编写了这个查询，我必须更新 PropertyAddress 列中的这些新值。为此，查询如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/b86c6eaf5244bf62df8920952dcfadf0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6tukeiHjrHP3IQwm_t36Cw.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">查询 5</figcaption></figure><p id="5621" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">更新该列后，如果您再次从上面运行查询 4，它将不会返回任何结果。这是因为所有的<strong class="jm io">空值</strong>现在都被填充了。</p><h2 id="b56f" class="lz kv in bd kw ma mb dn la mc md dp le jv me mf li jz mg mh lm kd mi mj lq mk bi translated">必要时将地址、城市和州分成单独的列</h2><p id="e134" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">如果您查看<strong class="jm io">属性地址</strong>和<strong class="jm io">所有者地址</strong>列，您会注意到地址的三个部分，即<strong class="jm io">实际地址</strong>、<strong class="jm io">城市</strong>，以及<strong class="jm io">所有者地址</strong>的情况下<strong class="jm io">状态</strong>，所有这些都包含在同一列中，并带有<strong class="jm io">分隔符</strong>。这种格式的问题是，如果您想单独查询地址、城市和州，您将无法这样做。所以，首先，你必须把地址分成两三个单独的类别，然后把它们分别放在不同的栏里。</p><p id="0d00" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为此，查询如下:</p><ul class=""><li id="939b" class="mx my in jm b jn jo jr js jv mz jz na kd nb kh nw nd ne nf bi translated"><strong class="jm io">为物业地址:</strong></li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/0556abfe832ff942ccf7c266cc705ea3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6gzY8MZjSV-eevHy4oqobQ.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">查询 6</figcaption></figure><p id="69bd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在上面的查询中，我们使用了<strong class="jm io">子串</strong>查询和<strong class="jm io"> CHARINDEX </strong>查询。</p><p id="08c0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> SUBSTRING </strong>查询从字符串中提取一些字符。它的语法是:<em class="ly"> SUBSTRING(我们要从哪里提取，从哪里开始，长度)</em>。</p><p id="80a4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在第一个<strong class="jm io">子串</strong>查询中，我想从<strong class="jm io">属性地址</strong>列中提取数据，我想让它从<strong class="jm io">第一个</strong>位置开始，并使用<strong class="jm io"> CHARINDEX </strong>命令插入长度(<strong class="jm io"> -1 </strong>用于消除中间的逗号)，并给它一个别名<strong class="jm io">“地址”</strong>。</p><p id="a3c0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在第二个<strong class="jm io">子串</strong>查询中，我再次希望从<strong class="jm io">属性地址</strong>中提取数据，我使用 CHARINDEX ( <strong class="jm io"> +1 </strong>是为了在指定起点时排除逗号后的空格)，并指定<strong class="jm io">长度</strong>，我使用<strong class="jm io"> LEN </strong>查询使用了<strong class="jm io">属性地址</strong>列中任何内容的长度，并给它一个别名<strong class="jm io"/></p><p id="3087" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，随着查询正常工作，我创建了新的列，然后将这些提取的值插入到这些列中。为此，我使用了以下查询:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/16e56a07aac00d0e5135b064ed440c47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XJRQwx06AMfHmucZiTrVNQ.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">查询 7</figcaption></figure><p id="672b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在一个接一个地运行查询后，结果是在表中创建了两个新列，并用我使用前面的查询提取的数据填充。结果如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/8a890428441128388e2e6cb67cc46061.png" data-original-src="https://miro.medium.com/v2/resize:fit:594/format:webp/1*WA6dAGfjFVlCAjK5LJciuw.png"/></div></figure><p id="9ea2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在上图中，您可以看到来自<strong class="jm io"> PropertyAddress </strong>列的数据现在被分别填充到两个不同的列中。因此，信息按地址和城市拆分，并分别填充到列<strong class="jm io">propertysplitdaddress</strong>和<strong class="jm io"> PropertySplitCity </strong>中。</p><ul class=""><li id="1c8f" class="mx my in jm b jn jo jr js jv mz jz na kd nb kh nw nd ne nf bi translated"><strong class="jm io">给主人的地址</strong></li></ul><p id="6531" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在<strong class="jm io">拥有者地址</strong>栏中，有<strong class="jm io">两个分隔符</strong>和<strong class="jm io">三个部分，即<strong class="jm io">实际地址</strong>、<strong class="jm io">城市</strong>和<strong class="jm io">状态</strong>。如果我像在<strong class="jm io"> PropertyAddress </strong>列中那样分割地址，这将变得非常复杂和耗时，并且还可能出现错误。因此，在这种情况下，我使用了另一个查询，如下所示:</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/df77a3a5c754852db26def31d32e9f5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VcxOGFTo7y8HRn8fE00f6g.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">查询 8</figcaption></figure><p id="d210" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在上面的查询中，我使用了<strong class="jm io"> PARSENAME </strong>关键字。它返回指定对象名的指定部分。这个查询<strong class="jm io">在分隔<strong class="jm io">分隔的</strong>值时非常有用</strong>，但是它只能检测到“<strong class="jm io">句点(。)</strong>而不是<strong class="jm io">逗号(，)</strong>。PARSENAME 查询的语法是:</p><p id="b969" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ly"> PARSENAME('对象名'，'对象件')</em>。</p><p id="22bc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是在我的例子中，问题是不同的值由逗号分隔。因此，为了让<strong class="jm io"> PARSENAME </strong>查询工作，将<strong class="jm io">逗号</strong>转换成<strong class="jm io">句点</strong>非常重要。为此，我使用了<strong class="jm io">替换</strong>查询，它将<strong class="jm io">’、</strong>替换为<strong class="jm io">’<strong class="jm io">解析名</strong>可以读取的。</strong></p><p id="04e7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">注意:</strong><strong class="jm io">PARESENAME</strong>反向读取列中的值，所以我没有按照升序<strong class="jm io"> (1，2，3) </strong>来命名<strong class="jm io"> <em class="ly"> object_piece </em> </strong>，而是按照降序<strong class="jm io"/><strong class="jm io">(3，2，1) </strong>来命名，这样它就可以先读取地址，然后是城市，最后是州。</p><p id="76c8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">运行<strong class="jm io">查询 8 </strong>后，<strong class="jm io"> OwnerAddress </strong>列中的值根据分隔符所在的位置被分成三个单独的列，如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/3d276e92b2b45cc9bf33089502781839.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v3XeE0Ft4GQCxRZSGnlzDA.png"/></div></div></figure><p id="7393" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在我有了地址、城市和州的单独值，它们必须被填充到各自的列中。为此，我使用了以下查询:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/c65e713ded5072c3f0d26ace50f17f52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hXbssi9I_nnTSXPw-WhVSg.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">查询 9</figcaption></figure><p id="c220" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在逐一运行上述查询后，创建了三个新列:<strong class="jm io"> OwnerSplitAddress </strong>、<strong class="jm io"> OwnerSplitCity </strong>和<strong class="jm io"> OwnerSplitState、</strong>，它们分别由地址、城市和州的独立值填充。</p><p id="a19d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，如果您查看更新后的表，会发现添加了三个新列，并填充了相应的数据，如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi od"><img src="../Images/2a8ce318d33dfa32c53000d120f847f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:914/format:webp/1*vzbgXoQR5oLn4_USfO-5mQ.png"/></div></figure><h2 id="81af" class="lz kv in bd kw ma mb dn la mc md dp le jv me mf li jz mg mh lm kd mi mj lq mk bi translated">必要时将缩写转换成它们各自的完整形式</h2><p id="6ee1" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">如果你看一下<strong class="jm io">纳什维尔房屋数据集</strong>，在<strong class="jm io">soldas vacate</strong>列中，数据类型是<strong class="jm io"> boolean </strong>，即<strong class="jm io"> Yes </strong>和<strong class="jm io"> No </strong>。但是如果查询<strong class="jm io">不同</strong>值的个数，结果是<strong class="jm io">四个</strong>，分别是<strong class="jm io">是</strong>、<strong class="jm io">否</strong>、<strong class="jm io"> Y </strong>和<strong class="jm io"> N </strong>。要检查这一点，请使用以下查询:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/e9f23aa5f462f1f5a9202cea2cd5ca77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OvsZY4lGIqRd8CYnE56Dlg.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">查询 10</figcaption></figure><p id="3c08" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当执行上述查询时，它会给出以下结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi of"><img src="../Images/5b20331c11cff9613bf9441b4007f913.png" data-original-src="https://miro.medium.com/v2/resize:fit:1170/format:webp/1*L7Hz52KgtlmCfzj6f4Nrpg.png"/></div></figure><p id="5ea7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你可以看到我之前提到的四个不同的值。</p><p id="9f8b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果您想进一步查看每个值的数量，请编写以下查询:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/044e373e3f6eb4444bbf5104b992d9db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aP0x0xVmc0aags41Ny7LfA.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">查询 11</figcaption></figure><p id="1057" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">运行上述查询后，它会给出以下结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/47e02c6a57deaa1bc02b9a9835da3e5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:770/format:webp/1*YqoBI9Zpqsc-P5cCLAH4tQ.png"/></div></figure><p id="7755" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">上图可以看到，有<strong class="jm io"> 52 </strong> <strong class="jm io"> Y </strong>值和<strong class="jm io"> 399 N </strong>值，很多。</p><p id="2b60" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是这可能会在未来的分析过程中产生问题。于是，我不得不将<strong class="jm io"> Y </strong>和<strong class="jm io"> N </strong>值分别转换为“<strong class="jm io">是</strong>”和“<strong class="jm io">否</strong>”。</p><p id="b0dc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为此，我编写了以下查询:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/2ed174a859ba733e62608838e0f8b23d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xpy15DqOtg1vnSw917V-Vg.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">查询 12</figcaption></figure><p id="3e8b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在上面的查询中，我使用了<strong class="jm io"> CASE </strong>语句将<strong class="jm io"> Y </strong>和<strong class="jm io"> N </strong>值分别转换为“<strong class="jm io"> Yes </strong>和“<strong class="jm io"> No </strong>”。运行上述查询时，结果如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/bcf5a16d446daeab75fc7938295f0a8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*qMTMKve0YYxS_dHEKdNHlg.png"/></div></div></figure><p id="c1b3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果您仔细观察结果，在新的列中，您会注意到所有的 Y 和 N 值已经分别成功地更改为“Yes”和“No”。</p><p id="e915" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，由于查询成功，我必须用结果值更新表。为此，我编写了以下查询:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/2a49d081902c2ade2f38a7a3a0f21e51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oxvvbLezzQWsv3lNItGrUQ.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">查询 13</figcaption></figure><p id="3df2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">运行上述查询后，如果您取出更新的表并运行<strong class="jm io">查询 11，</strong>您将注意到没有<strong class="jm io"> Y </strong>和<strong class="jm io"> N </strong>值，相反，<strong class="jm io"> Yes </strong>和<strong class="jm io"> No </strong>值的数量增加，表明该表已被更新。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/d2735c6a9bfec3a245768e9833fc9b5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:586/format:webp/1*uqjrvCZ0nxIYnCt2zuX-Nw.png"/></div></figure><h2 id="4c74" class="lz kv in bd kw ma mb dn la mc md dp le jv me mf li jz mg mh lm kd mi mj lq mk bi translated">查找和删除重复值</h2><p id="d290" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">如果您仔细查看数据集，您会发现许多列都有重复的值。这些可能会扭曲后面部分分析的结果。因此，必须找到并替换这些重复的值。</p><p id="7ba2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了找出重复的值，我编写了以下查询:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/226966aceac512ebf65e578ee211d02e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P8cb0eqqJtHn2k4dCMCScA.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">查询 14</figcaption></figure><p id="661e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当执行这个查询时，<strong class="jm io"> row_num </strong>列显示值 1 和 2。如果值为 2，则意味着这些值是重复值。</p><p id="9d1f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">注意:</strong>在上面的查询中，我使用了<strong class="jm io">窗口函数(</strong> <em class="ly">)一个窗口函数在一组与当前行</em>有某种关系的表格行中执行计算。您应该对特定行特有的内容进行分区。所以，在这种情况下，我选择了<strong class="jm io"> ParcelID </strong>、<strong class="jm io"> PropertyAddress </strong>、<strong class="jm io"> SalePrice </strong>、<strong class="jm io"> SaleDate </strong>和<strong class="jm io"> LegalReference </strong>。现在，如果所有这些在两行或更多行中是相同的，那么这意味着“该行是重复的行”。然后我们按<strong class="jm io">唯一</strong>到<strong class="jm io">重复值</strong>的东西排序，即<strong class="jm io">唯一 ID </strong>，我们将其命名为<strong class="jm io"> row_num </strong>。<strong class="jm io"> ROW_NUMBER </strong>语句返回结果集分区内某一行的<strong class="jm io"><em class="ly"/></strong>，从每个分区的第一行的<strong class="jm io"> 1 </strong>开始。</p><p id="ed60" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了在我获得的值中运行任何进一步的查询，我必须临时存储这些值。为了做到这一点，我使用了<strong class="jm io"> CTE </strong> ( <strong class="jm io">公共表表达式</strong>)，它作为带有记录和列的<strong class="jm io">虚拟表</strong>，在查询执行期间创建，由查询使用，并在查询执行后消除。</p><p id="3975" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用 CTE，我使用以下查询过滤掉了所有具有重复值的行:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/37aaabc7c06247a0f1dbe6d3ffb4b0f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aXF7zriP31CKgByTM4ecYw.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">查询 15</figcaption></figure><p id="2fbb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在上面的查询中，我使用了<strong class="jm io"> WHERE </strong>语句来过滤掉<strong class="jm io"> row_num </strong>列的值<strong class="jm io">大于 1 </strong>的行(这意味着它有重复值)。运行查询后，我发现该表有<strong class="jm io"> 104 个重复的</strong>值。</p><p id="3ba0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，所有重复值都已找到，我必须删除它们，为此，我只需将上述查询中的第二个<strong class="jm io"> SELECT </strong>语句更改为<strong class="jm io"> DELETE </strong>语句，以删除所有重复的行，如以下查询所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/e3411dbe13689c1a4632a07eb37b659a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3FHmp-LLCZfODzNQVb1X5Q.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">查询 16</figcaption></figure><p id="fc09" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">执行上述查询后，所有的<strong class="jm io">重复</strong>行都被<strong class="jm io">删除</strong>，现在如果再次运行<strong class="jm io">查询 15 </strong>，将不会返回任何值，因为所有的重复都被消除了。</p><h2 id="792e" class="lz kv in bd kw ma mb dn la mc md dp le jv me mf li jz mg mh lm kd mi mj lq mk bi translated">删除未使用的列</h2><p id="3099" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">现在，如果您查看表中的数据，那么<strong class="jm io"> PropertyAddress </strong>和<strong class="jm io"> OwnerAddress </strong>对我们不再有用，因为它们的数据已经被拆分到单独的列中。此外，<strong class="jm io"> TaxDistrict </strong>列对于任何进一步的目的都是无用的。所以，我现在可以删除这些列了。</p><p id="2153" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">注意:</strong>在实践中，您不能从原始数据中删除列，但是这在您保存视图以备后用时很有用。</p><p id="fc80" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了删除这些列，我使用了以下查询:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/008a0f20243a8f5848719aff55b1bff4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uIlbBJETLhk9Gv7pcrQLtg.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">查询 17</figcaption></figure><p id="36d3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我还决定删除<strong class="jm io">销售日期</strong>列，因为我已经创建了<strong class="jm io">销售日期转换的</strong>列。为此，我使用了上面查询中的<strong class="jm io"> ALTER TABLE </strong>和<strong class="jm io"> DROP TABLE </strong>语句。如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/201f55087c32c7ba55bc477c91a3b57a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eQmty17xH7djszGfr6mUHw.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">查询 18</figcaption></figure><p id="552a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，当我查询拉出整个表时，所做的所有更改都清晰可见。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/69e07dea819bc4f10b18f2f64a0f7808.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-uWy9ngohv-UkSYJlAD6Hw.png"/></div></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">查询 19</figcaption></figure><p id="99aa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">纳什维尔住宅</strong>数据集，在清理过程结束后，看起来如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/263f68f0adf5435ca2e25ed7383b65e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kRqwejPMA1vOrDMBfJ-6hA.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/1898c042e820009652e912b06b5fe69c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z_yMOFZAo5fc0ruTNlwy8A.png"/></div></div></figure><h2 id="4619" class="lz kv in bd kw ma mb dn la mc md dp le jv me mf li jz mg mh lm kd mi mj lq mk bi translated">未来范围</h2><p id="3428" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">可以进一步清理数据(比如填充剩余的空值)，还可以使用 SQL 对清理后的数据进行进一步分析，还可以提取特定的数据，将其保存为视图，稍后可以用于创建可视化效果，以收集关于数据的更多信息。</p><h2 id="7837" class="lz kv in bd kw ma mb dn la mc md dp le jv me mf li jz mg mh lm kd mi mj lq mk bi translated"><strong class="ak">感谢您的阅读！</strong></h2></div></div>    
</body>
</html>