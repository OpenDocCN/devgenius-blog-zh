<html>
<head>
<title>Composite Pattern in Unity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">统一中的复合模式</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/composite-pattern-in-unity-fc90e60c946f?source=collection_archive---------5-----------------------#2022-05-03">https://blog.devgenius.io/composite-pattern-in-unity-fc90e60c946f?source=collection_archive---------5-----------------------#2022-05-03</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="f23c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">假设我想把我能力的复杂性提升到一个新的水平。</p><p id="149d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我想要一个强力攻击技能，它是一个序列技能。顺序异能是一种拥有一系列异能的异能，并且按照列表中的顺序来使用每种异能。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/aa10076eea11f0894ca6352a7bed7df9.png" data-original-src="https://miro.medium.com/v2/resize:fit:566/format:webp/1*U46I1Cy4VeCbOERN2ZXU6Q.png"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">强力攻击序列</figcaption></figure><p id="5c77" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">强力攻击会运行治疗技能，然后是愤怒技能，最后是持续伤害技能。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi ku"><img src="../Images/718886d1e1585a2c46fe92abca8b4494.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fla1YwlnXaFHTXltdL6v7A.png"/></div></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">强力攻击序列</figcaption></figure><p id="aa37" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">“持续造成伤害”是一个平行异能，它同时使用列表中的所有异能。它会造成即时伤害和延迟伤害。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi kz"><img src="../Images/700b936f17476152028c6cc4e73d8056.png" data-original-src="https://miro.medium.com/v2/resize:fit:998/format:webp/1*ltDFT1qB-2zmqs2dy6a6pQ.png"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">随着时间的推移造成损害</figcaption></figure><p id="4a40" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我最终得到的是一个复杂的层次结构，它重用了大量代码，并允许我将不同的功能放在一起。要做到这一点，我需要复合模式，它看起来很像策略和装饰模式。</p><h1 id="fc36" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">事实真相</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ly"><img src="../Images/8a568b6b8224a9fe0f90492f1aaaccc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*3_p7t5o1dgq6UByKCP-ing.jpeg"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">来源:https://en.wikipedia.org/wiki/Composite_pattern</figcaption></figure><p id="fe7f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">复合的目的是将对象组合成树形结构来表示部分-整体层次结构。它允许我有一个树形结构，并要求树形结构中的每个节点执行一项任务。这也是如何建立行为树。这种模式的主要缺点是很难限制复合材料的组件类型。</p><h2 id="b4b7" class="ma lb in bd lc mb mc dn lg md me dp lk jv mf mg lo jz mh mi ls kd mj mk lw ml bi translated">定义</h2><ol class=""><li id="72ce" class="mm mn in jm b jn mo jr mp jv mq jz mr kd ms kh mt mu mv mw bi translated"><strong class="jm io">组件</strong> —组件为组合中的对象以及访问和管理其子组件声明接口。它还实现了所有类通用的接口的默认行为。</li><li id="6de3" class="mm mn in jm b jn mx jr my jv mz jz na kd nb kh mt mu mv mw bi translated"><strong class="jm io"> Leaf </strong> — Leaf 定义组合中图元对象的行为。它表示组合中的叶对象。(它下面没有物体，像树上的一片叶子。)</li><li id="3865" class="mm mn in jm b jn mx jr my jv mz jz na kd nb kh mt mu mv mw bi translated"><strong class="jm io"> Composite </strong> — Composite 存储子组件，并在组件接口中实现子组件相关的操作。(下面可以有其他物体，比如树枝。)</li><li id="7cff" class="mm mn in jm b jn mx jr my jv mz jz na kd nb kh mt mu mv mw bi translated"><strong class="jm io">客户端</strong> —客户端通过组件接口操纵合成中的对象。</li></ol><p id="15d9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">客户端使用组件类接口与组合结构中的对象进行交互。如果收件人是叶子，则直接处理请求。如果接收方是一个复合组件，那么它通常会将请求转发给其子组件，可能会在转发前后执行额外的操作。</p><h2 id="84b2" class="ma lb in bd lc mb mc dn lg md me dp lk jv mf mg lo jz mh mi ls kd mj mk lw ml bi translated">作为复合模式的复杂能力</h2><p id="3f29" class="pw-post-body-paragraph jk jl in jm b jn mo jp jq jr mp jt ju jv nc jx jy jz nd kb kc kd ne kf kg kh ig bi translated">这看起来像下面这样。</p><ol class=""><li id="990a" class="mm mn in jm b jn jo jr js jv nf jz ng kd nh kh mt mu mv mw bi translated"><strong class="jm io">客户</strong> —能力跑者。</li><li id="a551" class="mm mn in jm b jn mx jr my jv mz jz na kd nb kh mt mu mv mw bi translated"><strong class="jm io">组件</strong> —可靠性。</li><li id="b5fa" class="mm mn in jm b jn mx jr my jv mz jz na kd nb kh mt mu mv mw bi translated">叶子——愤怒，治疗，近战，愤怒，其他能力</li><li id="0bfc" class="mm mn in jm b jn mx jr my jv mz jz na kd nb kh mt mu mv mw bi translated"><strong class="jm io">复合</strong>——序列、平行、其他能力与一系列子系。</li></ol><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi ni"><img src="../Images/1744b6745b6ba03714a146ad149b7a8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*wXFf-f9LYEo8Of-OvK5c_w.gif"/></div></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">作为复合模式的复杂能力</figcaption></figure><h1 id="4aa2" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">履行</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi nj"><img src="../Images/c96f42c5771f28cd6856fd2712c0e86e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PAMy7DWfb36rp9rv7gmC9w.png"/></div></div></figure><p id="0595" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我需要两种不同的复合能力类型；顺序能力和平行能力。</p><h2 id="e037" class="ma lb in bd lc mb mc dn lg md me dp lk jv mf mg lo jz mh mi ls kd mj mk lw ml bi translated">序列能力</h2><p id="0a0e" class="pw-post-body-paragraph jk jl in jm b jn mo jp jq jr mp jt ju jv nc jx jy jz nd kb kc kd ne kf kg kh ig bi translated">首先，我创建了一个使用能力接口的能力。</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="d550" class="ma lb in nl b gy np nq l nr ns">public class SequenceAbility : IAbility<br/>{<br/><br/>    #region Implementation of IAbility<br/><br/>    <em class="nt">/// &lt;inheritdoc /&gt;<br/>    </em>public void Use(){}<br/><br/>    #endregion<br/>}</span></pre><p id="31fb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了使用复合模式，我需要添加一个责任子数组。</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="5ea1" class="ma lb in nl b gy np nq l nr ns">private IAbility[] m_abilities;</span></pre><p id="f2ef" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当然，现在我需要一种方法来设置子元素，所以我创建了一个构造函数，将子元素作为参数。</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="b255" class="ma lb in nl b gy np nq l nr ns">public SequenceAbility(IAbility[] children)<br/>{<br/>    m_abilities = children;<br/>}</span></pre><p id="c3a9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最后，我需要通过孩子排序，并使用每一个。</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="bc01" class="ma lb in nl b gy np nq l nr ns">public void Use()<br/>{<br/>    foreach (IAbility ability in m_abilities)<br/>    {<br/>        ability.Use();<br/>    }<br/>}</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/c650bf930b661463b740712dcb4a3cbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*dKija-C4GZnrgs1kyC8q2w.png"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">序列能力</figcaption></figure><h2 id="a386" class="ma lb in bd lc mb mc dn lg md me dp lk jv mf mg lo jz mh mi ls kd mj mk lw ml bi translated">平行能力</h2><p id="c8a3" class="pw-post-body-paragraph jk jl in jm b jn mo jp jq jr mp jt ju jv nc jx jy jz nd kb kc kd ne kf kg kh ig bi translated">首先，我创建了一个使用能力接口的能力。</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="d1e1" class="ma lb in nl b gy np nq l nr ns">public class ParallelAbility : IAbility<br/>{</span><span id="ac01" class="ma lb in nl b gy nv nq l nr ns">    #region Implementation of IAbility</span><span id="fb1c" class="ma lb in nl b gy nv nq l nr ns">    <em class="nt">/// &lt;inheritdoc /&gt;<br/>    </em>public void Use(){}</span><span id="38c7" class="ma lb in nl b gy nv nq l nr ns">    #endregion<br/>}</span></pre><p id="209f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了使用复合模式，我需要添加一个责任子数组。</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="361b" class="ma lb in nl b gy np nq l nr ns">private IAbility[] m_abilities;</span></pre><p id="2c77" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当然，现在我需要一种方法来设置子元素，所以我创建了一个构造函数，将子元素作为参数。</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="0da6" class="ma lb in nl b gy np nq l nr ns">public ParallelAbility(IAbility[] children)<br/>{<br/>    m_abilities = children;<br/>}</span></pre><p id="c8be" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最后，我需要并行使用所有的能力。</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="b4c3" class="ma lb in nl b gy np nq l nr ns">public void Use()<br/>{<br/>    ParallelUse();<br/>}</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/7ae450a80b3329e66b65a5fc34299c0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:972/format:webp/1*J7cReeNnjkeK6A_drMatVA.png"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">平行能力</figcaption></figure><p id="3c96" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">并行使用方法实现与如何实现复合模式无关。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi nx"><img src="../Images/b45232aeb555090d512ec0f64d43718d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TvDYDaJPOHRtljpnICb8Jw.png"/></div></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">并行使用任务</figcaption></figure><h2 id="54f4" class="ma lb in bd lc mb mc dn lg md me dp lk jv mf mg lo jz mh mi ls kd mj mk lw ml bi translated">强力攻击</h2><p id="6be1" class="pw-post-body-paragraph jk jl in jm b jn mo jp jq jr mp jt ju jv nc jx jy jz nd kb kc kd ne kf kg kh ig bi translated">现在对于异能攻击能力。所以我不需要创造额外的伤害能力，因为这是不必要的，所以我把伤害能力改为近战能力。我会在能力跑者中创造这个能力。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi ny"><img src="../Images/c078b5d4966467515791609f1c9249e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KdkAn_Jc1JF8f9L19uflOA.png"/></div></div></figure><p id="8525" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">第一步是制造一个名为 powerAttackAbility 的新序列异能。序列异能需要一系列的异能来排序，在这里是治疗异能、愤怒异能和平行异能。并行能力需要一系列能力并行运行，在这种情况下是近战能力和带有延迟装饰的近战能力。</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="e655" class="ma lb in nl b gy np nq l nr ns">private SequenceAbility m_powerAttackAbility = new SequenceAbility(<br/>    new IAbility[]<br/>    {<br/>        new HealAbility(), new RageAbility(),<br/>        new ParallelAbility(new IAbility[]<br/>        {<br/>            new MeleeAbility(),<br/>            new DelayedDecorator(new MeleeAbility())<br/>        })<br/>    });</span></pre><p id="2ef3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在我需要做的就是当按钮被点击的时候把这个设置为当前能力，并使用当前能力；</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="852f" class="ma lb in nl b gy np nq l nr ns">public void SetPowerAttackAbility()<br/>{<br/>    m_currentAbility = m_powerAttackAbility;<br/>    Use();<br/>}</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi nz"><img src="../Images/92ff9ea6aac10b8f2d58423cbb1de472.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*phgvXWtvK3FdpltWo4XxUQ.png"/></div></div></figure><p id="e88d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在 Unity 中，我需要让我的能量按钮在被点击时运行新的设定能量攻击功能。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/b8bdff797a312772351418310f362cb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:762/1*DtaVqWrNWA2WXHyVGnw1yQ.gif"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi ob"><img src="../Images/061245ee27ca914703e9d6e38524a7d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*rNSB-M0WTOQ_BI-rIenzVg.gif"/></div></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">使用能量攻击</figcaption></figure><h1 id="aebd" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">结论</h1><p id="e487" class="pw-post-body-paragraph jk jl in jm b jn mo jp jq jr mp jt ju jv nc jx jy jz nd kb kc kd ne kf kg kh ig bi translated">使用复合模式，我可以用一些简单的能力创建复杂的能力树。请注意，这段代码可以使用一些工作的方式，并行使用和复合使用的实现，现在我可以垃圾邮件的权力攻击和并行能力只运行一次。这里唯一的 Unity 特定代码是能力运行器，因为它是一个 MonoBehavior，其余的是纯 C#。这使我能够在不同的 C#应用程序中重用所有这些，如果我想的话。</p><h1 id="8736" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">代码可以在 Git Hub 上找到</h1><div class="oc od gp gr oe of"><a href="https://github.com/JamesLaFritz/Design-Patterns-For-Unity/tree/release-CompositePattern" rel="noopener  ugc nofollow" target="_blank"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd io gy z fp ok fr fs ol fu fw im bi translated">GitHub-JamesLaFritz/发布时用于统一的设计模式-复合模式</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">报告 Bug 请求特性展示了 Unity 中不同的编程设计模式。有许多不同的…</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">github.com</p></div></div><div class="oo l"><div class="op l oq or os oo ot ko of"/></div></div></a></div></div></div>    
</body>
</html>