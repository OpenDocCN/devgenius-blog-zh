<html>
<head>
<title>Part 4 — HOW TO: Configure messaging with RabbitMQ in a Spring Boot application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">第 4 部分—如何:在 Spring Boot 应用程序中使用 RabbitMQ 配置消息传递</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/part-4-how-to-configure-messaging-with-rabbitmq-in-a-spring-boot-application-a73e2453da95?source=collection_archive---------2-----------------------#2022-05-09">https://blog.devgenius.io/part-4-how-to-configure-messaging-with-rabbitmq-in-a-spring-boot-application-a73e2453da95?source=collection_archive---------2-----------------------#2022-05-09</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="75e3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你对微服务感兴趣，还没有遇到过基于消息的通信<strong class="jm io"><em class="ki"/></strong>，相信我，我会告诉你的。</p><p id="5f67" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在<strong class="jm io"> <em class="ki"> HOW TO </em> </strong>系列教程中，我将给你一个在<strong class="jm io"><em class="ki">【Spring Boot】</em></strong>应用程序中使用<strong class="jm io"> <em class="ki"> RabbitMQ </em> </strong>消息传递配置的实际例子。我们将构建一个应用程序，使用 Spring AMQP 的<strong class="jm io"><em class="ki">rabbit template</em></strong><em class="ki"/>发布消息，使用<strong class="jm io"><em class="ki">rabbit listener</em></strong>订阅消息。</p><p id="1874" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您可能和我一样，一开始会有些困惑，在深入细节之前，让我们先了解一些消息传递的关键概念。</p><p id="7a7f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">到<strong class="jm io"> <em class="ki">源代码库</em> </strong>的链接将在本教程的末尾添加。</p><h2 id="dca5" class="kj kk in bd kl km kn dn ko kp kq dp kr jv ks kt ku jz kv kw kx kd ky kz la lb bi translated">什么是基于消息的通信</h2><p id="1458" class="pw-post-body-paragraph jk jl in jm b jn lc jp jq jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh ig bi translated">消息传递是一种在应用程序之间传输数据的方法。我们通常使用同步请求-响应架构来开发我们的应用程序。然而，在微服务的情况下，这种方法变得不充分和不可靠，因为它不能在我们的分布式系统的多个数据源之间保持一致。相反，我们必须依靠异步交换消息。</p><p id="207f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">例如，RabbitMQ 正是这种解决方案的提供者之一。它位于消息生产者和消费者之间，充当<strong class="jm io"> <em class="ki">中间消息传递层</em> </strong>，并提供有用的功能，如<em class="ki">持久消息存储</em>、<em class="ki">消息过滤</em>和<em class="ki">消息转换</em>。</p><p id="ef24" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您可能会有点惊讶，但是 Java 有自己的消息服务(JMS) API，用于应用程序之间的消息传递。然而，由于供应商和平台的互操作性，我们无法使用 JMS 客户机和代理。这就是 AMQP 拯救世界的地方。</p><h2 id="08fd" class="kj kk in bd kl km kn dn ko kp kq dp kr jv ks kt ku jz kv kw kx kd ky kz la lb bi translated">什么是 AMQP</h2><p id="8a8f" class="pw-post-body-paragraph jk jl in jm b jn lc jp jq jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh ig bi translated">根据<a class="ae lh" href="https://www.cloudamqp.com/blog/what-is-amqp-and-why-is-it-used-in-rabbitmq.html" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> <em class="ki">定义</em></strong></a><strong class="jm io"><em class="ki">:</em></strong></p><blockquote class="li lj lk"><p id="fe2e" class="jk jl ki jm b jn jo jp jq jr js jt ju ll jw jx jy lm ka kb kc ln ke kf kg kh ig bi translated">高级消息队列协议(AMQP)是作为一种开放的标准协议而创建的，它允许系统之间的消息传递互操作性，而不考虑消息代理供应商或使用的平台；有了 AMQP，你可以使用任何你想要的符合 AMQP 标准的客户端库，以及任何你想要的符合 AMQP 标准的代理。使用 AMQP 的消息客户端是完全不可知的。</p></blockquote><p id="4b97" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这意味着 AMQP 只是一个<strong class="jm io"><em class="ki"/></strong>，提供了一套应该如何通过 AMQP 消息<strong class="jm io"> <em class="ki">代理</em> </strong>控制整个消息传递过程的标准，就像 RabbitMQ 一样。</p><p id="03f0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">正如<a class="ae lh" href="https://www.rabbitmq.com/" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="ki">rabbit MQ</em></strong></a>的官方网页所解释的:</p><blockquote class="li lj lk"><p id="9d39" class="jk jl ki jm b jn jo jp jq jr js jt ju ll jw jx jy lm ka kb kc ln ke kf kg kh ig bi translated">RabbitMQ 是一个消息代理:它接受和转发消息。你可以把它想象成一个邮局:当你把想要邮寄的邮件放入邮箱时，你可以确定邮递员最终会把邮件送到你的收件人手中。在这个类比中，RabbitMQ 是一个邮箱，一个邮局，一个信件载体。</p></blockquote><p id="5b4e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">更准确地说，过程如下:一个名为<strong class="jm io"> <em class="ki">生产者</em> </strong>的客户向一个<strong class="jm io"> <em class="ki">交易所</em> </strong>发送一条消息。根据交换类型定义的规则和消息中提供的路由关键字，交换然后将消息副本分发到<strong class="jm io"> <em class="ki">队列</em></strong>——本质上是大型消息缓冲区。该消息最终由一个<strong class="jm io"> <em class="ki">用户</em> </strong>消费。</p><p id="260c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你对更多的理论解释和一些实际例子感兴趣，可以看看<a class="ae lh" href="https://www.rabbitmq.com/tutorials/tutorial-one-spring-amqp.html" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> <em class="ki">官方网页</em> </strong> </a>上的教程。</p><p id="eaf6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在我们进入下一个话题之前，我认为回顾一下 AMQP 的一些组成部分是非常有益的。</p><h2 id="a148" class="kj kk in bd kl km kn dn ko kp kq dp kr jv ks kt ku jz kv kw kx kd ky kz la lb bi translated">什么是 AMQP 实体</h2><p id="01e1" class="pw-post-body-paragraph jk jl in jm b jn lc jp jq jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh ig bi translated">一条<strong class="jm io"> <em class="ki">消息</em> </strong>是从发布者传到队列中，然后被消费者订阅的一条信息。每条消息都有一组定义其参数的头。</p><p id="e033" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一个<strong class="jm io"> <em class="ki">队列</em> </strong>是一个缓冲区，可以存储以后要消费的消息。它的属性可以在创建过程中更改。路由关键字用于将队列链接到交换机。</p><p id="c14a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> <em class="ki">绑定</em> </strong>是队列和交换之间的关系，由交换用来将消息路由到队列的一组规则组成。</p><p id="b92f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">基于<strong class="jm io"> <em class="ki">交换类型</em> </strong>和交换与队列之间的绑定，消息被路由到队列。若要接收消息，队列必须至少绑定到一个交换。路由关键字用于向交换机发送消息。之后，交换机会将邮件副本分发到队列中。</p><p id="ae84" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> <em class="ki"> AMQP 经纪商实行四种基本的交易类型</em> </strong>:</p><ul class=""><li id="ba51" class="lo lp in jm b jn jo jr js jv lq jz lr kd ls kh lt lu lv lw bi translated"><strong class="jm io"> <em class="ki">直接</em></strong>–通过匹配完整的路由关键字将消息路由到队列。</li><li id="35d4" class="lo lp in jm b jn lx jr ly jv lz jz ma kd mb kh lt lu lv lw bi translated"><strong class="jm io"> <em class="ki">扇出</em></strong>–将消息路由到与其绑定的所有队列。</li><li id="c9be" class="lo lp in jm b jn lx jr ly jv lz jz ma kd mb kh lt lu lv lw bi translated"><strong class="jm io"> <em class="ki">主题</em></strong>–通过将路由关键字与模式匹配，将消息路由到多个队列。</li><li id="7d8f" class="lo lp in jm b jn lx jr ly jv lz jz ma kd mb kh lt lu lv lw bi translated"><strong class="jm io"> <em class="ki">标题</em></strong>–根据消息标题路由消息。</li></ul><p id="d3ac" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了便于理解，我尝试用下面的图表来表示这些交换类型:</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi mc"><img src="../Images/1aad219ca5027787f21aa63734f78fd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BO_W7XX5HIQg2Kfk-oJ4rg.png"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">AMQP 经纪人实施的四种基本交易类型</figcaption></figure><p id="e8a2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你想更深入地了解这些交换类型、绑定、路由键以及应该如何或何时使用它们，可以看看这个好看的博客<a class="ae lh" href="https://hevodata.com/learn/rabbitmq-exchange-type/" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> <em class="ki">这里</em> </strong> </a>。</p><h2 id="8099" class="kj kk in bd kl km kn dn ko kp kq dp kr jv ks kt ku jz kv kw kx kd ky kz la lb bi translated">设置 RabbitMQ 代理</h2><p id="a7f5" class="pw-post-body-paragraph jk jl in jm b jn lc jp jq jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh ig bi translated">让我们首先设置一个<strong class="jm io"> <em class="ki"> RabbitMQ 服务器</em> </strong>来处理消息的接收和发送。有几种方法可以做到这一点，但是在我们的教程中，我们将使用<strong class="jm io"><em class="ki">Docker Compose</em></strong>来快速午餐一个 RabbitMQ 服务器(您必须有一个<strong class="jm io"> <em class="ki"> Docker </em> </strong>在本地运行，这个解决方案才能工作)。</p><p id="40c6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">首先，用<strong class="jm io"><em class="ki">Spring Initializr</em></strong>创建一个新项目，添加<strong class="jm io"> <em class="ki"> Spring AMQP </em> </strong>作为依赖项:</p><pre class="md me mf mg gt ms mt mu mv aw mw bi"><span id="d706" class="kj kk in mt b gy mx my l mz na">&lt;dependency&gt;<br/>    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br/>    &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;<br/>&lt;/dependency&gt;</span></pre><p id="4865" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Spring AMQP 是为<em class="ki"> AMQP 实体</em>、<em class="ki">连接管理、消息发布、</em>和<em class="ki">消息消费</em>提供抽象的实现。</p><p id="8542" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后，在项目的根目录下创建一个<code class="fe nb nc nd mt b"><strong class="jm io"><em class="ki">docker-compose.yml</em></strong></code>文件，并将下面的代码粘贴到那里:</p><pre class="md me mf mg gt ms mt mu mv aw mw bi"><span id="9416" class="kj kk in mt b gy mx my l mz na">rabbitmq:<br/>  image: rabbitmq:management<br/>  ports:<br/>    - "5672:5672"<br/>    - "15672:15672"</span></pre><p id="9618" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里，我们公开端口<code class="fe nb nc nd mt b"><strong class="jm io">5672</strong></code> <strong class="jm io"> </strong>，这样我们的应用程序就可以连接到 RabbitMQ。并且，我们公开了端口<code class="fe nb nc nd mt b"><strong class="jm io">15672</strong></code>，以便我们可以通过管理 UI:<a class="ae lh" href="http://localhost:15672/" rel="noopener ugc nofollow" target="_blank"><em class="ki">HTTP://localhost:15672</em></a>或 HTTP API:<a class="ae lh" href="http://localhost:15672/api/index.html" rel="noopener ugc nofollow" target="_blank"><em class="ki">HTTP://localhost:15672/API/index . html</em></a>来查看我们的 RabbitMQ 代理正在做什么。</p><p id="65f4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">目前，把这个文件留在这里。我们将在几分钟内需要它。</p><h2 id="ee06" class="kj kk in bd kl km kn dn ko kp kq dp kr jv ks kt ku jz kv kw kx kd ky kz la lb bi translated">设置 Exchange 配置</h2><p id="f60f" class="pw-post-body-paragraph jk jl in jm b jn lc jp jq jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh ig bi translated">我们将为两种交换类型设置配置:<em class="ki">扇出</em>和<em class="ki">主题</em>。</p><p id="73a9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果您还记得，<strong class="jm io"> <em class="ki">扇出交换</em> </strong>向所有绑定队列广播相同的消息，而<strong class="jm io"> <em class="ki">主题交换</em> </strong>使用路由关键字将消息传递到特定的一个或多个绑定队列。</p><p id="3466" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们创建一个包含以下配置的<code class="fe nb nc nd mt b"><strong class="jm io"><em class="ki">ExchangeConfig</em></strong></code>类:</p><pre class="md me mf mg gt ms mt mu mv aw mw bi"><span id="8ee0" class="kj kk in mt b gy mx my l mz na">@Configuration<br/>public class ExchangeConfig {<br/>    public static final String <em class="ki">FANOUT_EXCHANGE_NAME </em>= "fanout.exchange";<br/>    public static final String <em class="ki">TOPIC_EXCHANGE_NAME </em>= "topic.exchange";<br/><br/>    public static final String <em class="ki">FANOUT_QUEUE_1_NAME </em>= "fanout.queue1";<br/>    public static final String <em class="ki">FANOUT_QUEUE_2_NAME </em>= "fanout.queue2";<br/><br/>    public static final String <em class="ki">TOPIC_QUEUE_1_NAME </em>= "topic.queue1";<br/>    public static final String <em class="ki">TOPIC_QUEUE_2_NAME </em>= "topic.queue2";<br/><br/>    @Bean<br/>    public Declarables fanoutBindings() {<br/>        Queue fanoutQueue1 = new Queue(<em class="ki">FANOUT_QUEUE_1_NAME</em>, false);<br/>        Queue fanoutQueue2 = new Queue(<em class="ki">FANOUT_QUEUE_2_NAME</em>, false);<br/><br/>        FanoutExchange fanoutExchange = new FanoutExchange(<em class="ki">FANOUT_EXCHANGE_NAME</em>, false, false);<br/><br/>        return new Declarables(<br/>                fanoutQueue1,<br/>                fanoutQueue2,<br/>                fanoutExchange,<br/>                BindingBuilder<br/>                        .<em class="ki">bind</em>(fanoutQueue1)<br/>                        .to(fanoutExchange),<br/>                BindingBuilder<br/>                        .<em class="ki">bind</em>(fanoutQueue2)<br/>                        .to(fanoutExchange)<br/>        );<br/>    }<br/><br/>    @Bean<br/>    public Declarables topicBindings() {<br/>        Queue topicQueue1 = new Queue(<em class="ki">TOPIC_QUEUE_1_NAME</em>, false);<br/>        Queue topicQueue2 = new Queue(<em class="ki">TOPIC_QUEUE_2_NAME</em>, false);<br/><br/>        TopicExchange topicExchange = new TopicExchange(<em class="ki">TOPIC_EXCHANGE_NAME</em>, false, false);<br/><br/>        return new Declarables(<br/>            topicQueue1,<br/>            topicQueue2,<br/>            topicExchange,<br/>            BindingBuilder<br/>                    .<em class="ki">bind</em>(topicQueue1)<br/>                    .to(topicExchange)<br/>                    .with("*.legal.*"),<br/>            BindingBuilder<br/>                    .<em class="ki">bind</em>(topicQueue2)<br/>                    .to(topicExchange)<br/>                    .with("#.error")<br/>        );<br/>    }<br/>    <br/>}</span></pre><p id="7f92" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">object 是 Spring AMQP 提供的一个非常方便的工具，它允许我们聚合所有队列、交换和绑定的声明。</p><p id="1c4a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在上面的代码中，我们建立了一个扇出交换，有两个队列与之相关联。当我们向此交换发送消息时，我们希望两个队列都能收到它。您可能已经注意到，在这种类型的交换中，邮件中包含的任何路由关键字都会被忽略。</p><p id="3836" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">还声明了一个主题交换，有两个具有不同绑定模式的队列。当路由关键字与模式匹配时，消息将被放入队列中。</p><p id="e4e1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">“<code class="fe nb nc nd mt b"><strong class="jm io">*</strong></code>用于匹配装订模式中某个位置的单词，而“<code class="fe nb nc nd mt b"><strong class="jm io">#</strong></code>用于匹配零个或多个单词。这意味着<code class="fe nb nc nd mt b"><strong class="jm io"><em class="ki">topicQueue1</em></strong></code>将接收具有三个字的路由关键字的消息，“合法”作为中间字，而<code class="fe nb nc nd mt b"><strong class="jm io"><em class="ki">topicQueue2</em></strong></code>将获得路由关键字以单词 error 结尾的消息。</p><h2 id="8b20" class="kj kk in bd kl km kn dn ko kp kq dp kr jv ks kt ku jz kv kw kx kd ky kz la lb bi translated">建立一个生产者</h2><p id="d59e" class="pw-post-body-paragraph jk jl in jm b jn lc jp jq jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh ig bi translated">接下来，让我们创建一个新类<code class="fe nb nc nd mt b"><strong class="jm io"><em class="ki">Producer</em></strong></code>并粘贴以下代码片段:</p><pre class="md me mf mg gt ms mt mu mv aw mw bi"><span id="f177" class="kj kk in mt b gy mx my l mz na">@Component<br/>public class Producer {<br/>    public static final String <em class="ki">BINDING_PATTERN_LEGAL </em>= "company.legal.documents";<br/>    public static final String <em class="ki">BINDING_PATTERN_ERROR </em>= "company.documents.report.error";<br/><br/>    @Bean<br/>    public ApplicationRunner runner(RabbitTemplate rabbitTemplate) {<br/>        String message = "A sample message";<br/>        return args -&gt; {<br/>            rabbitTemplate.convertAndSend(<br/>                    ExchangeConfig.<em class="ki">FANOUT_EXCHANGE_NAME</em>,<br/>                    "",<br/>                    message<br/>            );<br/>            rabbitTemplate.convertAndSend(<br/>                    ExchangeConfig.<em class="ki">TOPIC_EXCHANGE_NAME</em>,<br/>                    <em class="ki">BINDING_PATTERN_LEGAL</em>,<br/>                    message<br/>            );<br/>            rabbitTemplate.convertAndSend(<br/>                    ExchangeConfig.<em class="ki">TOPIC_EXCHANGE_NAME</em>,<br/>                    <em class="ki">BINDING_PATTERN_ERROR</em>,<br/>                    message<br/>            );<br/>        };<br/>    }<br/>}</span></pre><p id="ac72" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了发送我们的示例消息，我们将使用<code class="fe nb nc nd mt b"><strong class="jm io"><em class="ki">RabbitTemplate</em></strong></code>的<code class="fe nb nc nd mt b"><strong class="jm io"><em class="ki">convertAndSend()</em></strong></code>方法，一旦应用程序启动，它将被立即注入。</p><p id="831e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当向扇出交换机发送消息时，路由关键字只是一个空字符串，因为它被忽略，并且消息被转发到所有绑定的队列。</p><p id="cea8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当向主题交换提交消息时，我们包括路由键，它决定消息将被传递到哪个队列。</p><h2 id="2c24" class="kj kk in bd kl km kn dn ko kp kq dp kr jv ks kt ku jz kv kw kx kd ky kz la lb bi translated">配置消费者</h2><p id="1ba6" class="pw-post-body-paragraph jk jl in jm b jn lc jp jq jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh ig bi translated">创建一个新的类<code class="fe nb nc nd mt b"><strong class="jm io"><em class="ki">Consumer </em></strong></code>并设置四个消费者来获取生成的消息——每个队列一个:</p><pre class="md me mf mg gt ms mt mu mv aw mw bi"><span id="1d47" class="kj kk in mt b gy mx my l mz na">@Component<br/>public class Consumer {<br/><br/>    @RabbitListener(queues = ExchangeConfig.<em class="ki">FANOUT_QUEUE_1_NAME</em>)<br/>    public void consumeMessageFromFanoutQueue1(String message) {<br/>        System.<em class="ki">out</em>.println(<br/>                "Received fanout queue 1 message: " + message<br/>        );<br/>    }<br/><br/>    @RabbitListener(queues = ExchangeConfig.<em class="ki">FANOUT_QUEUE_2_NAME</em>)<br/>    public void consumeMessageFromFanoutQueue2(String message) {<br/>        System.<em class="ki">out</em>.println(<br/>                "Received fanout queue 2 message: " + message<br/>        );<br/>    }<br/><br/>    @RabbitListener(queues = ExchangeConfig.<em class="ki">TOPIC_QUEUE_1_NAME</em>)<br/>    public void consumeMessageFromTopicQueue1(String message) {<br/>        System.<em class="ki">out</em>.println(<br/>                "Received topic: " + <br/>                        Producer.<em class="ki">BINDING_PATTERN_LEGAL </em>+<br/>                        " queue 1 message: " + message<br/>        );<br/>    }<br/><br/>    @RabbitListener(queues = ExchangeConfig.<em class="ki">TOPIC_QUEUE_2_NAME</em>)<br/>    public void consumeMessageFromTopicQueue2(String message) {<br/>        System.<em class="ki">out</em>.println(<br/>                "Received topic: " +<br/>                        Producer.<em class="ki">BINDING_PATTERN_ERROR </em>+<br/>                        " queue 2 message: " + message<br/>        );<br/>    }<br/>    <br/>}</span></pre><p id="4e7c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe nb nc nd mt b"><strong class="jm io"><em class="ki">@RabbitListener</em></strong></code>注释用于配置消费者。队列的名称作为参数提供给它。消费者完全不知道交换或路由密钥。</p><h2 id="167a" class="kj kk in bd kl km kn dn ko kp kq dp kr jv ks kt ku jz kv kw kx kd ky kz la lb bi translated">测试应用程序</h2><p id="cae9" class="pw-post-body-paragraph jk jl in jm b jn lc jp jq jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh ig bi translated">我们的 Spring Boot 应用程序将通过与 RabbitMQ 的连接自动初始化应用程序，并设置所有队列、交换和绑定。</p><p id="acab" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">启动 Docker，然后在<code class="fe nb nc nd mt b"><strong class="jm io"><em class="ki">docker-compose.yml</em></strong></code>文件所在的项目根目录下运行<code class="fe nb nc nd mt b"><strong class="jm io"><em class="ki">docker-compose up</em></strong></code>命令。成功提取图像后，启动应用程序。</p><p id="e31a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">输出将如下所示:</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi ne"><img src="../Images/15b6f9be26b88c96285742e16b46128b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NcY0RmYG_gYHjRAdwz5qWA.png"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">运行我们的应用程序后成功输出</figcaption></figure><p id="99ed" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当然，不能保证消息的顺序。</p></div><div class="ab cl nf ng hr nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ig ih ii ij ik"><p id="8855" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这个简短的教程中，我们讨论了扇出和与<strong class="jm io"><em class="ki"/></strong>和<strong class="jm io"> <em class="ki"> RabbitMQ </em> </strong>的主题交流。</p><p id="7fcb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你错过了什么，所有代码都可以在我的<a class="ae lh" href="https://github.com/anitalakhadze/rabbitmq-exchange-demo" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> <em class="ki"> GitHub 资源库</em> </strong> </a>上找到。</p><p id="7820" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">请让我知道你对这个系列中即将到来的博客有什么问题、评论或建议。</p><p id="a7f9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> <em class="ki">敬请关注，不要错过以下教程！</em> </strong></p></div></div>    
</body>
</html>