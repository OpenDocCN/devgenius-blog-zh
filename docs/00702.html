<html>
<head>
<title>Reversing a Linked List</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反转链接列表</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/reversing-a-linked-list-93f5680c6223?source=collection_archive---------34-----------------------#2020-06-14">https://blog.devgenius.io/reversing-a-linked-list-93f5680c6223?source=collection_archive---------34-----------------------#2020-06-14</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/a4b6540ed5b537afcae7951f38d7c038.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*LGYyRkdfHOObriV4.jpg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">HOTLITTLEPOTATO的信用</figcaption></figure><p id="23fb" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在准备你的编码面试时，你可能遇到过这个非常流行的链表问题，反转一个链表。这个问题初看起来很吓人，但是如果你记得链表的结构以及如何操作每个节点之间的指针，这个问题会变得简单得多。</p><p id="a005" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">链表的结构</strong></p><p id="f67f" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">所以很快，让我们回顾一下单链表的基本结构。链表本质上看起来像这样:</p><figure class="ky kz la lb gt jo gh gi paragraph-image"><div class="gh gi kx"><img src="../Images/1d12b69f3d33779f93dfad8ed752141b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1368/format:webp/0*7QAUd7veGol_X-VV.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">黑客地球的荣誉</figcaption></figure><p id="1e1d" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">有一个链表头，可以看作是链表的第一个元素。链表的每个元素称为一个“节点”，每个节点有两个属性。链表具有存储信息的数据属性和指向链表中下一个“节点”的指针的下一个属性。上图展示了一个叫做单链表的链表的例子。单链表只能单向运行，每个节点只能指向下一个节点。有一种类型的链表称为双向链表，其中每个“节点”都有一个指针指向下一个“节点”和前一个“节点”。</p><p id="29b9" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">反转链表</strong></p><p id="06a5" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">既然我们已经讨论了什么是链表，那么让我们深入这个问题。假设你得到了这个单链表。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="9fc4" class="lh li in ld b gy lj lk l ll lm"><strong class="ld io">Input:</strong> 1-&gt;2-&gt;3-&gt;4-&gt;NULL</span></pre><p id="41ee" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">写一个函数，以一个链表作为参数，返回这个链表，但是取反。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="7672" class="lh li in ld b gy lj lk l ll lm"><strong class="ld io">Expected Output: </strong>4-&gt;3-&gt;2-&gt;1-&gt;NULL</span></pre><p id="5260" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">那么我们该如何解决这个问题呢？如果你熟悉链表的结构，你会意识到解决这个问题的关键是利用指针。</p><p id="a274" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">如果我们一步一步地遍历每个节点，并翻转下一个指针指向前一个节点，会怎么样？所以它看起来会像这样:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="9482" class="lh li in ld b gy lj lk l ll lm">1&lt;-2-&gt;3-&gt;4-&gt;NULL</span><span id="66be" class="lh li in ld b gy ln lk l ll lm">1&lt;-2-3-&gt;4-&gt;NULL</span><span id="dbb7" class="lh li in ld b gy ln lk l ll lm">NULL&lt;-1&lt;-2&lt;-3&lt;-4</span></pre><p id="19e2" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">包含4的节点将成为新的头，包含1的节点现在将指向NULL。那么代码是什么样子的呢？</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="dfcd" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">边缘病例？</strong></p><p id="b0f7" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">当处理算法问题时，你应该总是考虑可能使你的解决方案失败的边缘情况。</p><p id="3a25" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">一种可能的边缘情况是链表为空。我们的解决方案仍然有效，因为while循环永远不会运行，因为current是<code class="fe lq lr ls ld b">null</code>。因为我们返回的是设置为null的<code class="fe lq lr ls ld b">prev</code>，所以我们的解决方案是可行的。</p><p id="fbab" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">你还能想到什么吗？</p><p id="f45f" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">如果你认为你已经掌握了这个链表问题，我肯定会建议测试一下你在<a class="ae lt" href="https://leetcode.com/problems/reverse-linked-list-ii/" rel="noopener ugc nofollow" target="_blank">反转链表II </a>上的知识。</p></div></div>    
</body>
</html>