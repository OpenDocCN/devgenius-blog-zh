<html>
<head>
<title>A crash course on floating point numbers in a computer, Part II</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">计算机中浮点数的速成课程，第二部分</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/a-crash-course-on-floating-point-numbers-in-a-computer-part-ii-6fca16a0a321?source=collection_archive---------5-----------------------#2020-10-17">https://blog.devgenius.io/a-crash-course-on-floating-point-numbers-in-a-computer-part-ii-6fca16a0a321?source=collection_archive---------5-----------------------#2020-10-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/919f3aa93b6a404c270da1e74e587ef2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QtTBLtqcM_Hq5ZpU"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">天文学研究需要测量很大的距离，但有时也需要测量很小的距离。照片由<a class="ae kc" href="https://unsplash.com/@brianna_santellan?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">陈伶俐·桑特兰</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="e53d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">浮点数是现代计算机程序员认为理所当然的便利。但是它们也很复杂，如果对浮点数的工作原理没有基本的了解，就会导致意想不到的问题。</p><p id="2880" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">浮点数是如此的复杂，以至于这篇仅仅解释基础知识的文章也变得相当长。时间太长了，所以我决定把它分成两部分。</p><p id="08cc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<a class="ae kc" href="https://medium.com/dev-genius/a-crash-course-on-floating-point-numbers-in-a-computer-part-i-a7a70f67a27" rel="noopener">第一部分</a>，我解释了符号位、指数位和尾数位。但是我几乎没有提到浮点运算是如何工作的，浮点有什么用，以及它是如何在主要的计算机编程语言中可用的。这就是这部分的内容。</p><h1 id="bd40" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">只是一点点关于浮点运算</h1><p id="4992" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我承认我并不完全理解浮点运算。但是，我一直明白浮点运算有很多陷阱。</p><p id="b515" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，根据我在第一部分中所写的内容，有三个算术运算应该很容易理解:两个不改变位模式的运算(加0，乘以1)和一个只改变符号位的运算(乘以1)。</p><p id="62d0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">仔细想想，翻倍和减半可能也很容易，只需调整指数位，尽管有一些注意事项。</p><p id="f583" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要使一个数翻倍，只需将指数位增加1，前提是不能让所有指数位都打开。若要减半，请将指数位减少1，前提是仍有至少一个指数位保持开启。</p><p id="be37" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Evan Wallace的<a class="ae kc" href="http://evanw.github.io/float-toy/" rel="noopener ugc nofollow" target="_blank"> Float Toy </a>是一个可视化浮点数位模式的好工具。当您第一次在Web浏览器中加载该页面时，它会显示16位、32位和64位浮点中π的位模式。</p><p id="69fe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在Float Toy中可以看到，π在16位浮点中的位模式是4248。如果打开第11位(根据显示的标签)，得到4648，代表6.28125 (Float Toy显示6.282)。大概是π的两倍。</p><p id="d991" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">点击第11位关闭，我们回到3.140625。现在，我将要求您切换16位数字的所有五个指数位，以获得3E48，它表示1.5703125，大约是π的一半。</p><p id="53b6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果打开除最后一位以外的所有指数位，则得到7A48，表示整数51456。上的所有指数位给出7E48，当然是NaN。数字102912在16位浮点中作为无穷大丢失。</p><p id="f651" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">往另一个方向走，16位浮点有可能变得小于π/32768。近似值0.000095873799用0648表示。但是0248不会给我们π/65536，因为，在所有指数位关闭的情况下，该数字是次正规的。</p><p id="1d1f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，要获得16位浮点的π/65536，我们需要对0648位模式进行更彻底的更改:我们需要将所有尾数位向右移动一位，并且我们需要移入不再隐式的前导1。</p><p id="c718" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样我们就得到了0324，刚好是0648的一半。但是当然:我没有意识到，因为指数位仍然有一位(最低有效指数位)，所以在正常/次正常中断上减半只是将所有位向右移动<em class="me">的简单事情。</em></p><p id="d5b5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当然，假设要减半的数字为正(如果为负，则符号位需要保持不变，最高有效指数位为0)。</p><p id="7997" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要继续减半，只要继续向右移位。在这个例子中，我们得到0192，00C9，0064，0032，0019，000C，0006，0003，0001，然后只有0000。由于所有的on位都被移出，这个数字已经变得和0难以区分了。</p><p id="180b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">点击所有这些位可能会很繁琐，这就是为什么我没有要求您对π的32位或64位表示进行同样的操作。我希望这个玩具有能在指数或尾数位上加或减1的按钮。如果我在网上找不到这样的东西，也许我会编写这样的程序。</p><p id="8aca" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我不知道芯片如何将两个非零浮点数相加，除了如何将一个次正规数加1:只需打开最低有效指数位。</p><p id="5d76" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是我确实知道是什么导致了臭名昭著的0.1+0.2 = 0.300000000000000004的结果，其中0.00000000000004似乎是凭空出现的。</p><p id="e04d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">显然1/10 + 1/5 = 3/10，而3作为浮点数除以10确实给出了0.3的正确结果。但通过浮点加法，0.1和0.2不会出现这种情况。</p><p id="d4da" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">作为64位浮点数的数字0.1表示为3FB9 9999 9999 999A。这意味着1 × 1/16 × 10/16。但是10/16无法用有限的比特精确表示。</p><p id="1852" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那是因为10/16 = 3/2+3/32+3/512+3/8192+3/131072+…但是在64位浮点中，尾数只有52位，3/9007199254740992被向上舍入到1/2251799813685248。</p><p id="993c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这已经足够接近10/16了。同样，0.2表示为3FC9 9999 9999 999A，它试图得到1 × 1/8 × 10/16。指数位增加1，尾数位保持不变，3/9007199254740992向上舍入到1/2251799813685248，与0.1相同。</p><p id="acdd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">考虑到浮点运算的限制，这里最好的结果是3FD3 3333 3333 3333，其中3/72057594037927936和无穷和的所有较小被加数都被忽略。</p><p id="12b0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是3fb 9 9999 9999 999 a+3fc 9 9999 9999 999 a反而给出3FD3 3333 3333 3334。所以3FD3 3333 3333 3333已经超调了整整1/4503599627370496。</p><p id="491f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">重要的是要考虑规模。例如，考虑用16位浮点表示16384和0.00006103515625是多么容易。前者是7400，后者是0400。</p><p id="6dcd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是16384+0.00006103515625 = 16384.00006103515625超出了16位浮点精确表示的能力。在64位浮点中，该数字是40D0 0000 0100 0000。但是在16位浮点中，较小的数字就丢失了。</p><p id="cdcc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而且，好像无穷大还不够古怪，浮点中的无穷大更古怪。无穷大加无穷大是无穷大。我想，有道理。但是正无穷大加负无穷大是NaN，不是我预期的0。</p><p id="d331" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果无穷大代表任何特定的数，那么零是有意义的。但它在浮点中的含义通常是一个在可用位宽中无法合理近似的数字。</p><p id="68b3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，在64位浮点运算中，2 × 10 ⁰⁸作为无穷大丢失，尽管这两个被乘数都可以很容易地用给定位宽表示。因此，如果一个“无穷大”代表2 × 1⁰ ⁰⁸，另一个“无穷大”代表其他数字，它们的差不可能是0。所以电脑给了我们NaN。</p><p id="9295" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">除了乘以2的幂或乘以1的幂，我不知道浮点乘法是如何工作的。同样，除了除以2的幂或1的幂，我不知道浮点除法是如何工作的。</p><p id="88a4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在大多数芯片上，整数被零除往往会导致某种错误、异常或中断。但是当然浮点除以零是不一样的，也不一定导致NaN。</p><p id="3b48" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意，给定一个正数<em class="me"> x </em>，如果<em class="me">x</em>T24】1，那么1/<em class="me">x</em>T25】1。例如，1/16 = 0.0625。<em class="me"> x </em>越大，1/ <em class="me"> x </em>越小越接近0。显然1/1 = 1。随着正的<em class="me"> x </em>越来越小，越来越接近0，越大的1/ <em class="me"> x </em>越来越大。例如，1/0.0625 = 16，1/0.03125 = 32，1/0.015625 = 64。</p><p id="8b94" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以<em class="me"> x </em>越小，1/ <em class="me"> x </em>越接近无穷大。这表明1/0等于正无穷大，这就是浮点运算的结果。</p><p id="fa34" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，如果<em class="me"> x </em>为负，它越接近0，1/ <em class="me"> x </em>就越接近<em class="me">负</em>无穷大。例如，1/0.0625 = 16，1/0.03125 = 32，1/0.015625 = 64。因此，在浮点运算中，1/0等于负无穷大。</p><p id="b7fb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">图表<em class="me"> y </em> = 1/ <em class="me"> x </em>应该很清楚地说明了这一点。例如，在Wolfram Alpha 上看到的<a class="ae kc" href="https://www.wolframalpha.com/input/?i=graph+1%2Fx" rel="noopener ugc nofollow" target="_blank">。只要绘图区域显示正的和负的<em class="me"> x </em>，你就会看到两条曲线在相反的象限上，永远不会相交。</a></p><p id="001d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是0/0可能是什么呢？唯一符合逻辑的选择就是南。从我在我的系统上做的实验来看，那个特定的NaN似乎是FFF8 0000 0000 0000，它是“最小”的“负”NaN，具有最高有效位。</p><p id="b88b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对了，还记得我在第一部分说的“负”零吗？原来正数除以负零等于负无穷大，负数除以负零等于正无穷大。去想想。</p><p id="10e1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是正零除以负零还是NaN，负零除以负零也是NaN，负零除以正零也是NaN。</p><p id="d602" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">NaN可能出现的另一种情况是取负数的平方根。若<em class="me"> x </em>为零或正，则其主平方根为√ <em class="me"> x </em>，如√2 ≈ 1.4142。但是√(<em class="me">x</em>)是<em class="me"> i </em> √ <em class="me"> x </em>，例如√(2)≈1.4142<em class="me">I</em>。而且当然浮点不能代表<em class="me"> i </em>的任何倍数，0除外。</p><p id="f43d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以如果<em class="me"> x </em>为正，浮点中的√(<em class="me">x</em>)也应该给NaN。为此，我也得到0000 0000 0000法郎，因为我已经尝试过了。也许在某些系统中，NaN给出了一些关于平方根使用方法的线索。</p><p id="178b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我怀疑这个方法是经常被认为是艾萨克·牛顿爵士，有时是约瑟夫·拉弗森的方法。虽然“牛顿法”是一个非常聪明的算法，而且它有助于证明我的观点，即无理数的浮点表示是有理逼近(至少是那些不会迷失到无穷大的逼近)。</p><p id="ea39" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">用这种方法求一个正数<em class="me"> x </em>的平方根，我们从一个猜想开始，称之为<em class="me"> g </em> (0)。它不一定是一个非常好的猜测；只要它不是什么古怪的东西，它应该会相当快地给我们一个像样的答案。</p><p id="824b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么<em class="me">g</em>(1)=(<em class="me">g</em>(0)+<em class="me">x</em>/<em class="me">g</em>(0))/2。更一般的，对于<em class="me"> n </em> &gt; 0，<em class="me">g</em>(<em class="me">n</em>)=(<em class="me">g</em>(<em class="me">n</em>—1)+<em class="me">x</em>/<em class="me">g</em>(<em class="me">n</em>—1))/2。聪明的是，如果<em class="me"> g </em> ( <em class="me"> n </em>)太低，<em class="me"> g </em> ( <em class="me"> n </em> + 1)就会有点高，如果<em class="me"> g </em> ( <em class="me"> n </em>)太高，<em class="me"> g </em> ( <em class="me"> n </em> + 1)就会有点低。</p><p id="89c0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果√ <em class="me"> x </em>是无理数，那么这个过程可以持续到无穷远，其中<em class="me"> g </em> ( <em class="me"> n </em>)永远不会精确地等于√ <em class="me"> x </em>，但是对于我们的任何实际需求来说都足够接近。</p><p id="723f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当然，浮点运算的局限性意味着很快<em class="me"> g </em> ( <em class="me"> n </em>)和√ <em class="me"> x </em>之间的差异太小而无法表示，并且<em class="me"> g </em> ( <em class="me"> n </em>)显然与<em class="me"> g </em> ( <em class="me"> n </em> + 1)相同。</p><p id="2c90" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">初始猜测的典型选择是<em class="me"> g </em> (0) = 1，这对于较大的正数有点不好。另一个显而易见的选择是<em class="me"> g </em> (0) = <em class="me"> x </em>，这当然只能保证对于<em class="me"> x </em> = 1是正确的(对于<em class="me"> x </em> = 0会导致被零除)。</p><p id="6827" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一种更复杂的获得初始猜测的方法是将<em class="me"> g </em> (0)设置为最小整数，这样<em class="me"> g </em> (0) ≥ <em class="me"> x </em>。实际上最大的整数比如<em class="me"> g </em> (0) ≤ <em class="me"> x </em>也很好用。</p><p id="ad66" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">举个例子，让我们用<em class="me"> x </em> = 8来试试。设置<em class="me"> g </em> (0) = 2，我们看到<em class="me"> g </em> (1) = (2 + 8/2)/2 = 6/2 = 3。这是另一个选择，如果我们选择最小的整数，那么g<em class="me">g</em>(0)≥<em class="me">x</em>。</p><p id="2a87" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么<em class="me">g</em>(2)=(3+8/3)/2 =(17/3)/2 = 17/6，大致就是2.8333。接下来，我们有577/204，然后是665857/235416，886731088897/313506783024，157258404803291863353217/555992422174934068969056，以此类推。</p><p id="8c56" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为√8是无理数，所以这些分数中没有一个会恰好等于√8。但是<em class="me">g</em>(5)= 886731088897/313506783024换算成64位浮点已经等于2.8284271247461903。</p><p id="b92b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这可能是64位浮点中√8所能得到的最好结果。这个数乘以自身得出8.00000000000002。我想差不多了。</p><p id="71e9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是为了得到分数的结果，我实际上在一个分数类中使用了整数运算，该类提供了一个函数，以64位浮点数的形式给出分数的近似值。</p><p id="8c65" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以本质上我推迟了浮点运算的使用，直到最后。如果我们从一开始就使用64位浮点数，我们得到的序列是2.0，3.0，2.833333333333333，2.8284313725490193，2.82842747，2.82842747，2.8，2712474，619，2.8，3333，333333，2.8，3333333，2.3333333333，2，2.4733，2，2.34</p><p id="79ab" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我想这里的2.82712474619就是数学家所说的“不动点”但是因为这个数字比我们用fraction类得到的数字少了两位小数，我们可能会认为它不够精确。</p><p id="280d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而2.82842712474619×2.82842712474619 = 7.999999999995。与8相差0.00000000000002，与前面的结果一样，但方向相反。</p><p id="0935" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们可以使用更大的分子或分母，或者在浮点中使用更多的位，我们可以得到2.8284271247461900976，它的平方使我们更接近8。</p><p id="b5d4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于浮点运算只有64位，所以这个数字被四舍五入为2.8284271247461903。位模式是4006 A09E 667F 3BCD。将最低的两个字节改为3BCC得到2.82842712474619，3BCE得到2.8247461907。</p><p id="6a76" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们能够将初始猜测设为类似于<em class="me"> g </em> (0) = <em class="me"> i </em>的值，那么这种算法对于负数<em class="me">非常有效。数字<em class="me"> i </em>是“虚数”，因此<em class="me">I</em>= 1。</em></p><p id="efbb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是由于数字<em class="me"> i </em>不能用浮点表示，该算法要么导致负无穷大，要么导致无限循环。</p><p id="fab1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，对于<em class="me">x</em>= 1，设置<em class="me"> g </em> (0) = 1，则<em class="me">g</em>(1)=(1+1/(1))/2 = 0，然后试图计算<em class="me"> g </em> (2)会导致被零除。但是在浮点运算中，这给出了负无穷大作为计算的定点，这当然是错误的。</p><p id="35c0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果<em class="me"> g </em> (0) = 1/2，似乎没有不动点。看起来这个序列只是在正值和负值之间漫无目的地振荡。</p><p id="b58d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一般来说，浮点运算中的加法和减法是不确定的，这取决于错误发生在哪里，而乘法和除法往往更可靠。</p><p id="0c53" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，我想比这更进一步，并且说，实际上，您应该使用整数运算，并且推迟浮点运算，直到绝对必要的时候。</p><p id="9cb9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">嗯，要看目的；你应该测试一下。如果浮点运算始终没有得到您想要的结果，请尝试不同的方法。</p><h1 id="d242" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">浮点对什么有好处，对什么没好处</h1><p id="b6cd" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">考虑到所有这些，应该很清楚浮点数有什么好处，有什么坏处。</p><p id="f7ac" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">64位精度的浮点运算适用于大多数科学计算，这些计算往往有一定的误差容限。</p><p id="594b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，假设你现在想计算地球和火星之间的距离。你不需要知道精确到毫米甚至千米的距离。</p><p id="dacf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我写这篇文章时，我们谈论的是6200多万公里。当你读到这里时，确切的数字几乎肯定会有所不同，但6200万公里足以满足我们的好奇心。</p><p id="8ee9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">浮点对于货币来说不是那么好，除了货币转换。当你处理一种货币(例如，美元)的货币时，你需要定点运算，通常定点到小数点后两三位。</p><p id="b682" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">真的，在只处理一种货币的时候，我们真正需要的是整数运算。例如，就计算机而言，470.25美元可能就是47，025美分。</p><p id="0bd7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样，合计美元金额，这是一个简单的整数美分金额相加的问题，而不用担心随机万亿分之一的美分出现在你最不期望的时候。</p><p id="c29b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当然，有人真的需要一个计算器来计算10到20美分是不现实的。但是仅仅因为我想不出一个现实的例子，浮点会引入一个意想不到的和不可接受的错误，并不意味着这样的事情不会发生。</p><p id="a98e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">还有，没有无限美元这种东西。什么是$NaN？毫无意义。浮点格式通常不适合只涉及一种货币的计算。</p><p id="6160" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，浮点对于货币转换是必不可少的，即使当货币接近1:1等值时。例如，470.25美元兑换398.04€(当你读这篇文章时可能是一样的，但更有可能不是)。</p><p id="2cb7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了完成这一转换，您需要当前汇率，在我撰写本文时是0.846443。然后，无论你使用美分兑换美分(47，025美分兑换39803.982075美分兑换1欧元)还是美元(470.25美元兑换398.03982075)，都有必要进行一些四舍五入或舍位。</p><p id="bec1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但一般来说，将浮点数舍入或截断为整数比将二进制浮点数舍入或截断为特定的小数位数更简单。</p><p id="5908" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本例中，将39803.982075美分的欧元四舍五入为39804美分的欧元比将398.03982075美分的欧元四舍五入为398.04欧元更可靠。放置小数点的任务最好留给一个专门用来表示金额的类来完成。</p><p id="c21d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不管你怎么做，测试都是非常重要的，特别是对于那些有不同“小数”位数的货币(例如，日元没有，利比亚第纳尔有三位)。</p><p id="237c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">他们说时间就是金钱，事实证明浮点通常不适合表示游戏中经过的时间，尽管64位精度比32位精度问题更少。</p><p id="0fdb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最好用整数来表示毫秒；这些可以根据显示需要转换成秒或分钟。</p><h1 id="12d9" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">在下一部分…</h1><p id="5cd8" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我又要把这个分开了。第三部分将关注主流编程语言中的浮点运算。</p></div></div>    
</body>
</html>