<html>
<head>
<title>Python Decorators with Arguments and Named tuple</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有参数和命名元组的 Python 装饰器</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/python-decorators-with-arguments-and-named-tuple-9ac58f4392ad?source=collection_archive---------19-----------------------#2022-08-25">https://blog.devgenius.io/python-decorators-with-arguments-and-named-tuple-9ac58f4392ad?source=collection_archive---------19-----------------------#2022-08-25</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="80e5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在之前的装饰者教程中，我没有涉及一个主题——带参数的装饰者。</p><p id="622d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">带参数的装饰器是一个接受自定义参数并返回实际装饰器(将应用于被装饰函数)的函数。</p><p id="dcfe" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">要了解更多，请查看下面的普通装饰者示例。</p><pre class="ki kj kk kl gt km kn ko kp aw kq bi"><span id="0543" class="kr ks in kn b gy kt ku l kv kw">def decorator_Function(org_function):<br/>    def inner_Function():<br/>        print("Printing from Decorators")<br/>        return org_function()<br/>    return inner_Function<br/><br/><br/>@decorator_Function<br/>def display():<br/>    print('Print Display')<br/><br/>display()<br/>Output-<br/>Printing from Decorators<br/>Print Display</span></pre><p id="8639" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里，我们在装饰器内部传递 display()函数，并向它添加一条消息。</p><p id="db0f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">假设我们想在调用装饰器时添加一些自定义消息，而不是硬编码的消息，那么我们可以使用带参数的装饰器。</p><p id="95ff" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下面是一个相同的例子。</p><pre class="ki kj kk kl gt km kn ko kp aw kq bi"><span id="e514" class="kr ks in kn b gy kt ku l kv kw">def outer_example(message):<br/>    def decorator_Function(org_function):<br/>        def inner_Function():<br/>            print(message,"Printing from Decorators")<br/>            return org_function()<br/>        return inner_Function<br/>    return  decorator_Function<br/><br/><br/>@outer_example('Testing - ')<br/>def display():<br/>    print('Print Display')<br/><br/>display()<br/>Output-<br/>Testing -  Printing from Decorators<br/>Print Display</span></pre><p id="a928" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在上面的例子中，我们在装饰器上添加了一个 outer_example()并传递了参数，我们还引入了一个嵌套层作为 outer_example，并需要添加一个返回装饰器的 return 语句。</p><p id="66d0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在我们可以传递带有 display()函数的' @outer_example '作为装饰器，并传递参数。在这里，我们将“测试”作为一条消息添加并打印出来。</p><p id="b99b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">命名元组:- </strong></p><p id="255e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">命名元组是集合模块下的另一个类。像字典类型的对象一样，它包含映射到一些值的键。在这种情况下，我们可以使用键和索引来访问元素。</p><p id="2fff" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里是一个普通元组的例子，我们使用索引来访问值。</p><pre class="ki kj kk kl gt km kn ko kp aw kq bi"><span id="0cd4" class="kr ks in kn b gy kt ku l kv kw">color = [55,67,123]<br/>print(color[0])<br/>Output-<br/>55</span></pre><p id="10a4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">假设在上面的例子中，如果“55”表示红色，67 表示“绿色”，依此类推，我们就无法将数值与数字联系起来。因此，如果我们想做同样的事情，我们也可以使用字典，并将其标记为键-值对。</p><pre class="ki kj kk kl gt km kn ko kp aw kq bi"><span id="ae36" class="kr ks in kn b gy kt ku l kv kw">color = {'red':55,'green':67,'white':123}<br/>print(color['red'])</span></pre><p id="1978" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是 Dictionary 是一个可变的对象，而 tuple 是不可变的，所以如果我们需要使用 tuple 执行相同的操作，那么我们可以使用一个命名的 tuple。</p><pre class="ki kj kk kl gt km kn ko kp aw kq bi"><span id="0788" class="kr ks in kn b gy kt ku l kv kw">from collections import namedtuple<br/>#Creating Named tuple<br/>Color = namedtuple('Color',['red','green','white'])<br/># Mapping the value<br/>color = Color(55,67,123)<br/># accessing the value<br/>print(color.red)<br/>Output-<br/>55</span></pre></div></div>    
</body>
</html>