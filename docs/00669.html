<html>
<head>
<title>C# client from an OpenAPI specification with generics support using NSwag</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 NSwag 从支持泛型的 OpenAPI 规范中获得 C#客户端</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/nswag-csharp-client-with-generics-support-6ad6a09f81d6?source=collection_archive---------1-----------------------#2020-06-14">https://blog.devgenius.io/nswag-csharp-client-with-generics-support-6ad6a09f81d6?source=collection_archive---------1-----------------------#2020-06-14</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><blockquote class="jk jl jm"><p id="c51e" class="jn jo jp jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ig bi translated"><em class="in">其他类似文章:<br/> </em> <a class="ae km" href="https://medium.com/dev-genius/nswag-charp-client-from-multiple-api-versions-7c79a3de4622" rel="noopener">多个 API 版本的 C#客户端使用 NSwag </a> <em class="in"> <br/> </em> <a class="ae km" href="https://medium.com/dev-genius/csharp-protecting-swagger-endpoints-82ae5cfc7eb1" rel="noopener"> C#保护 Swag 端点</a></p></blockquote><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi kn"><img src="../Images/993c440fe3d5175d934c18b4fbbfb3c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*XgjnLuci7ruuBeVS.png"/></div></div></figure><p id="1d6c" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kz ka kb kc la ke kf kg lb ki kj kk kl ig bi translated">最近，我在使用 NSwag 生成 C#客户端时遇到了泛型支持的困难。我做了一些研究，试图找到解决办法。因此，在本文中，我将与您分享如何使用 NSwag 优化 C#客户端代码生成的解决方案。</p></div><div class="ab cl lc ld hr le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ig ih ii ij ik"><p id="e2ac" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kz ka kb kc la ke kf kg lb ki kj kk kl ig bi translated"><em class="jp">我使用默认的 Web API 项目作为起点(创建说明可以在</em> <a class="ae km" href="https://docs.microsoft.com/en-us/aspnet/core/tutorials/first-web-api?view=aspnetcore-3.1&amp;tabs=visual-studio#create-a-web-project" rel="noopener ugc nofollow" target="_blank"> <em class="jp">这里</em> </a> <em class="jp">找到)。</em></p><h1 id="285e" class="lj lk in bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">模式的生成</h1><p id="758b" class="pw-post-body-paragraph jn jo in jq b jr mh jt ju jv mi jx jy kz mj kb kc la mk kf kg lb ml kj kk kl ig bi translated">首先，我们需要一个模式。在<em class="jp"> nswag </em> <a class="ae km" href="https://github.com/RicoSuter/NSwag/wiki/AspNetCore-Middleware" rel="noopener ugc nofollow" target="_blank">知识库</a>中有一个文档说明了如何从 c# ASP.NET(Core)控制器添加 OpenAPI 3.0 规范的 NSwag 生成。</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">Startup.cs —配置 OpenAPI</figcaption></figure><p id="4844" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kz ka kb kc la ke kf kg lb ki kj kk kl ig bi translated">接下来，我们将自动生成<em class="jp">wag . JSON</em>文件以供进一步使用。可以通过多种方式<a class="ae km" href="https://github.com/RicoSuter/NSwag/wiki/CommandLine" rel="noopener ugc nofollow" target="_blank"/>完成。我决定选择<a class="ae km" href="https://github.com/RicoSuter/NSwag/wiki/NSwag.MSBuild" rel="noopener ugc nofollow" target="_blank"><em class="jp">ms build</em></a><em class="jp"/>因为这种方法可以避免团队成员原本应该做的额外动作。<em class="jp"> NSwag。MSBuild </em>转到包参考，并通过恢复<em class="jp">numget</em>包来安装解决方案。</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">App.csproj 添加了 NSwag。MSBuild 包和目标“SwaggerToFile”</figcaption></figure><p id="6567" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kz ka kb kc la ke kf kg lb ki kj kk kl ig bi translated">构建<em class="jp">应用</em>后，出现<em class="jp">swag . JSON</em>文件:</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/c1f4bee89ccac44990c68ac45ec602e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:768/format:webp/1*24muE319UFta-ej6DAdhEw.png"/></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">解决方案资源管理器中的 swagger.json</figcaption></figure><h1 id="9737" class="lj lk in bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">模式中的泛型</h1><p id="87fa" class="pw-post-body-paragraph jn jo in jq b jr mh jt ju jv mi jx jy kz mj kb kc la mk kf kg lb ml kj kk kl ig bi translated">很简单，不是吗？但是仿制药呢？<br/>如果我们希望任何 API 响应都有一个包装的响应结构，该怎么办？让我们为 API 响应创建一个新的泛型类，而不是枯燥的<a class="ae km" href="https://github.com/dotnet/aspnetcore/blob/master/src/Mvc/Mvc.Core/src/ActionResultOfT.cs" rel="noopener ugc nofollow" target="_blank"> <em class="jp">操作结果</em> </a> <em class="jp"> : </em></p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">API response . cs—API 请求的自定义响应模型</figcaption></figure><p id="b060" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kz ka kb kc la ke kf kg lb ki kj kk kl ig bi translated">为了测试的目的，我们在<em class="jp">weatherforestcontroller</em>上增加了以下动作:</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">WeatherForecastController.cs</figcaption></figure><p id="f8d4" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kz ka kb kc la ke kf kg lb ki kj kk kl ig bi translated">我们在<em class="jp"> csproj </em> target 中有一个神奇的脚本，所以在构建<em class="jp"> App 之后，</em>应该会出现一个更新的<em class="jp"> swagger.json </em>文件。下面是一个结果:</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">swagger.json</figcaption></figure><p id="0e4c" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kz ka kb kc la ke kf kg lb ki kj kk kl ig bi translated">唉，出事了。模式中有<code class="fe mt mu mv mw b">ApiResponseOfIEnumerableOfWeatherForecast</code> <em class="jp"> </em>。它看起来与理想世界相去甚远。我们能用它做什么？深挖问题，定制！</p><p id="4947" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kz ka kb kc la ke kf kg lb ki kj kk kl ig bi translated">NSwag 有很多机会改变行为，无论是代码还是模式生成(<a class="ae km" href="https://github.com/RicoSuter/NSwag/wiki/Document-Processors-and-Operation-Processors" rel="noopener ugc nofollow" target="_blank">文档处理器和操作处理器</a>，<a class="ae km" href="https://github.com/RicoSuter/NJsonSchema" rel="noopener ugc nofollow" target="_blank"> NJsonSchema </a>)。</p><p id="1253" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kz ka kb kc la ke kf kg lb ki kj kk kl ig bi translated">自定义<code class="fe mt mu mv mw b">SchemaNameGenerator</code> <em class="jp"> </em>和<code class="fe mt mu mv mw b">TypeNameGenerator</code>应该有助于解决我们的问题:</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">CustomSchemaNameGenerator.cs</figcaption></figure><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">CustomTypeNameGenerator.cs</figcaption></figure><p id="c99d" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kz ka kb kc la ke kf kg lb ki kj kk kl ig bi translated">关于这些类的几句话:</p><ul class=""><li id="9994" class="mx my in jq b jr js jv jw kz mz la na lb nb kl nc nd ne nf bi translated"><em class="jp">customschemanamegenerator . cs</em>更改模式名，例如<code class="fe mt mu mv mw b">ApiResponseOfIEnumerableOfWeatherForecast</code> <em class="jp"> </em>转到<code class="fe mt mu mv mw b">ApiResponse&lt;IEnumerable&lt;WeatherForecast&gt;&gt;</code></li><li id="30d8" class="mx my in jq b jr ng jv nh kz ni la nj lb nk kl nc nd ne nf bi translated"><em class="jp">custom typename generator . cs</em>在类型生成过程中跳过模式名称的任何更改，只是从模式中返回相同的名称(您可以与<a class="ae km" href="https://github.com/RicoSuter/NJsonSchema/blob/958afa39a8386a6f02bf6604aca742e4d18acb61/src/NJsonSchema/DefaultTypeNameGenerator.cs" rel="noopener ugc nofollow" target="_blank"><em class="jp">DefaultTypeNameGenerator</em></a>进行比较，后者删除了尖括号和其他括号)</li></ul><p id="934b" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kz ka kb kc la ke kf kg lb ki kj kk kl ig bi translated">剩下的最后一件事就是把它全部打开。</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">Startup.cs —使用自定义生成器更新</figcaption></figure><p id="9970" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kz ka kb kc la ke kf kg lb ki kj kk kl ig bi translated">再一次<em class="jp"> App </em>重建后，<em class="jp"> swagger.json </em>文件转化为如下:</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">定制后的 swagger.json</figcaption></figure><p id="4195" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kz ka kb kc la ke kf kg lb ki kj kk kl ig bi translated">看起来好多了。</p><p id="6a2e" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kz ka kb kc la ke kf kg lb ki kj kk kl ig bi translated">接下来，我们转到客户端生成部分。</p><h1 id="e9aa" class="lj lk in bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">客户生成</h1><p id="2ff8" class="pw-post-body-paragraph jn jo in jq b jr mh jt ju jv mi jx jy kz mj kb kc la mk kf kg lb ml kj kk kl ig bi translated">好了，现在我们有了一个很好的模式。但是 API 客户端呢？对于客户端生成，我们可以使用相同的<em class="jp"> NSwag </em>工具。</p><p id="cacd" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kz ka kb kc la ke kf kg lb ki kj kk kl ig bi translated"><em class="jp"> NSwag </em>工具使用特定的配置文件来生成 C#客户端。我使用命令<code class="fe mt mu mv mw b">nswag new</code>创建一个默认文件(更多关于命令<a class="ae km" href="https://github.com/RicoSuter/NSwag/wiki/CommandLine#execute-nswag-configuration-document" rel="noopener ugc nofollow" target="_blank">的信息在这里</a>)。</p><p id="ae32" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kz ka kb kc la ke kf kg lb ki kj kk kl ig bi translated">结果文件:</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">nswag.json</figcaption></figure><p id="703e" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kz ka kb kc la ke kf kg lb ki kj kk kl ig bi translated">与默认配置文件的不同之处在于:</p><pre class="ko kp kq kr gt nl mw nm nn aw no bi"><span id="3abb" class="np lk in mw b gy nq nr l ns nt">"defaultVariables": "OutDir="<br/>"url": "swagger.json"<br/>"namespace": "AppApiClient"<br/>"output": "$(OutDir)"</span></pre><p id="48b1" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kz ka kb kc la ke kf kg lb ki kj kk kl ig bi translated">然后，我们需要在<em class="jp"> csproj </em>文件中为客户端生成添加一个新的目标:</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">添加了目标“CsharpClientGeneration”的 App.csproj</figcaption></figure><p id="a867" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kz ka kb kc la ke kf kg lb ki kj kk kl ig bi translated">剩下最后的动作:创建<em class="jp"> ApiClient </em>项目，重新构建<em class="jp"> App </em>。</p><p id="2433" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kz ka kb kc la ke kf kg lb ki kj kk kl ig bi translated"><em class="jp"> ApiClient </em>项目<em class="jp"> </em>是一个简单的类库。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi nu"><img src="../Images/358a0ac6821d9da73e136c23af583736.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PKD06mKNaiKQHIrSWAgCwA.png"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">ApiClient 项目创建</figcaption></figure><p id="cd5d" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kz ka kb kc la ke kf kg lb ki kj kk kl ig bi translated">现在重建<em class="jp"> App 后，</em>执行<em class="jp"> CsharpClientGeneration </em>目标，<em class="jp"> </em>和 C#客户端出现在<em class="jp">/API client/appapi client . cs</em>中。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/da6cd627f9f9991dfd8c8ca3226ac183.png" data-original-src="https://miro.medium.com/v2/resize:fit:772/format:webp/1*UhPP-jdTH2gvh78M1-mBEQ.png"/></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">解决方案资源管理器中的 AppApiClient.cs</figcaption></figure><p id="5982" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kz ka kb kc la ke kf kg lb ki kj kk kl ig bi translated">在<em class="jp"> AppApiClient.cs </em>中有这样的代码行:</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">AppApiClient.cs</figcaption></figure><p id="6c12" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kz ka kb kc la ke kf kg lb ki kj kk kl ig bi translated">生成的客户端没有得到泛型支持，很可悲:(</p><h1 id="9aed" class="lj lk in bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">支持泛型</h1><p id="040e" class="pw-post-body-paragraph jn jo in jq b jr mh jt ju jv mi jx jy kz mj kb kc la mk kf kg lb ml kj kk kl ig bi translated">GitHub 上有一些问题:</p><ul class=""><li id="a764" class="mx my in jq b jr js jv jw kz mz la na lb nb kl nc nd ne nf bi translated"><a class="ae km" href="https://github.com/RicoSuter/NSwag/issues/1139" rel="noopener ugc nofollow" target="_blank">使用自定义泛型类#1139 生成 C # dto</a></li><li id="138e" class="mx my in jq b jr ng jv nh kz ni la nj lb nk kl nc nd ne nf bi translated"><a class="ae km" href="https://github.com/RicoSuter/NJsonSchema/issues/23" rel="noopener ugc nofollow" target="_blank">增加描述仿制药的扩展#23 </a></li></ul><p id="3bb3" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kz ka kb kc la ke kf kg lb ki kj kk kl ig bi translated">现在似乎没有完美的解决方案。但是有没有变通的办法呢？</p><p id="ab37" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kz ka kb kc la ke kf kg lb ki kj kk kl ig bi translated">最简单的方法是改变生成文件的内容。还有<a class="ae km" href="https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild-tasks?view=vs-2019" rel="noopener ugc nofollow" target="_blank"> <em class="jp"> MSBuild 任务</em> </a>和更现代的<a class="ae km" href="https://docs.microsoft.com/en-us/dotnet/core/tools/global-tools" rel="noopener ugc nofollow" target="_blank"> <em class="jp"> dotnet 工具</em> </a>。</p><p id="5507" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kz ka kb kc la ke kf kg lb ki kj kk kl ig bi translated">在<a class="ae km" href="https://github.com/loresoft/msbuildtasks" rel="noopener ugc nofollow" target="_blank">loresoft/msbuildtasks</a>GitHub 资源库中有 MSBuild 社区任务项目，不幸的是它不支持 NET Core。在<a class="ae km" href="https://github.com/natemcmaster/dotnet-tools" rel="noopener ugc nofollow" target="_blank">natem cmaster/dot net-tools</a>GitHub 存储库中有一个工具列表。</p><p id="b346" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kz ka kb kc la ke kf kg lb ki kj kk kl ig bi translated">我选择网络工具，因为它是现代\_(ツ)_/</p><p id="91ca" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kz ka kb kc la ke kf kg lb ki kj kk kl ig bi translated">工具列表中有<a class="ae km" href="https://github.com/JosefPihrt" rel="noopener ugc nofollow" target="_blank">JosefPihrt</a>/<a class="ae km" href="https://github.com/JosefPihrt/Orang" rel="noopener ugc nofollow" target="_blank">Orang</a>GitHub 库，非常适合我们的案例。它的描述是<em class="jp">“使用的力量搜索、替换、重命名和删除目录、文件及其内容。NET 正则表达式"</em>。这个工具的版本是<em class="jp"> 0.1.0-rc </em>，但是据说只用于<em class="jp"> App </em>构建，在运行时不会用到，所以<em class="jp"> rc 没有问题。</em></p><p id="985c" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kz ka kb kc la ke kf kg lb ki kj kk kl ig bi translated">新<em class="jp"> csproj </em>目标中的集成<code class="fe mt mu mv mw b">orang replace</code>命令:</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">添加了目标“MakeItGenericAgain”的 App.csproj</figcaption></figure><p id="4993" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kz ka kb kc la ke kf kg lb ki kj kk kl ig bi translated">在<em class="jp"> App </em>重建后客户端看起来更好，现在我们已经生成了类，例如<code class="fe mt mu mv mw b">public partial class ApiResponse&lt;IEnumerable&lt;WeatherForecast&gt;&gt;</code>产生了……编译错误。</p><p id="5494" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kz ka kb kc la ke kf kg lb ki kj kk kl ig bi translated">排除问题类应该有所帮助:</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">nswag.json</figcaption></figure><p id="3f35" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kz ka kb kc la ke kf kg lb ki kj kk kl ig bi translated">这不是一个理想的解决方案，但是通常，d to 是与服务器共享的，不需要在客户机上生成它们。所以我创建了这样一个通用库<em class="jp"> App。ApiDtos </em>和修改后的<em class="jp"> nswag.json: </em></p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">nswag.json 和其他名称空间用法</figcaption></figure><h1 id="92cc" class="lj lk in bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">LF 和 CRLF 线结束</h1><p id="ed05" class="pw-post-body-paragraph jn jo in jq b jr mh jt ju jv mi jx jy kz mj kb kc la mk kf kg lb ml kj kk kl ig bi translated">在使用<em class="jp"> NSwag 的过程中，</em>我注意到有时 git 客户端中有变化而没有变化。当然是<em class="jp"> LF </em>和<em class="jp"> CRLF。</em></p><p id="dae5" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kz ka kb kc la ke kf kg lb ki kj kk kl ig bi translated"><em class="jp"> NSwag </em>生成以<em class="jp"> LF </em>结尾的文件。让我们在<code class="fe mt mu mv mw b">orang</code>的帮助下再次修复。<em class="jp"> csproj </em>目标<em class="jp">makeit generic gain:</em>的最后一块</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">带有更新目标"<em class="nw"> MakeItGenericAgain </em>"的 App.csproj</figcaption></figure></div><div class="ab cl lc ld hr le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ig ih ii ij ik"><h1 id="beb4" class="lj lk in bd ll lm nx lo lp lq ny ls lt lu nz lw lx ly oa ma mb mc ob me mf mg bi translated">概述</h1><p id="2fff" class="pw-post-body-paragraph jn jo in jq b jr mh jt ju jv mi jx jy kz mj kb kc la mk kf kg lb ml kj kk kl ig bi translated">NSwag 是一个如何编写正确库的例子。这是一个非常灵活和可定制的工具。我的文章给出了如何为我们独特的案例定制这些神奇工具的想法。当然，你们都可以更进一步，调整自己的不便之处。</p><p id="ff1e" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kz ka kb kc la ke kf kg lb ki kj kk kl ig bi translated">最终的<em class="jp">应用</em>你可以在我的资源库中找到，链接在<strong class="jq io">参考</strong>部分。</p><p id="02bf" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy kz ka kb kc la ke kf kg lb ki kj kk kl ig bi translated"><strong class="jq io"> <em class="jp">更新:</em> </strong>你也可以阅读 Renat Sungatullin 的《<a class="ae km" href="https://link.medium.com/mZ1n7x7k87" rel="noopener"> C#客户端来自多个 API 版本使用 NSwag </a>》</p><h1 id="3ae1" class="lj lk in bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">参考</h1><div class="oc od gp gr oe of"><a href="https://github.com/Rynaret/SwagGenSample/tree/nswag-generation-with-generics" rel="noopener  ugc nofollow" target="_blank"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd io gy z fp ok fr fs ol fu fw im bi translated">Rynaret/SwagGenSample</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">如何使用 NSwag 从具有泛型支持的 OpenAPI 规范生成 C#客户端的示例…</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">github.com</p></div></div><div class="oo l"><div class="op l oq or os oo ot kx of"/></div></div></a></div><div class="oc od gp gr oe of"><a href="https://github.com/RicoSuter/NSwag/wiki/AspNetCore-Middleware" rel="noopener  ugc nofollow" target="_blank"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd io gy z fp ok fr fs ol fu fw im bi translated">RicoSuter/NSwag</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">包装:NSwag。AspNetCore.NETStandard 1.6+，。NET 标准 2.0，。网芯和。NET 4 . 5 . 1+NuGet 包提供了…</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">github.com</p></div></div><div class="oo l"><div class="ou l oq or os oo ot kx of"/></div></div></a></div><div class="oc od gp gr oe of"><a href="https://github.com/natemcmaster/dotnet-tools" rel="noopener  ugc nofollow" target="_blank"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd io gy z fp ok fr fs ol fu fw im bi translated">natem cmaster/dot net-工具</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">的工具扩展列表。NET 核心命令行(dotnet CLI)，又名为’。NET 核心全球工具。提示:💡全球工具…</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">github.com</p></div></div><div class="oo l"><div class="ov l oq or os oo ot kx of"/></div></div></a></div><div class="oc od gp gr oe of"><a href="https://github.com/JosefPihrt/Orang" rel="noopener  ugc nofollow" target="_blank"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd io gy z fp ok fr fs ol fu fw im bi translated">JosefPihrt/Orang</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">Orang 是一个跨平台的命令行工具，用于:所有这些命令都由。NET 正则表达式引擎…</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">github.com</p></div></div><div class="oo l"><div class="ow l oq or os oo ot kx of"/></div></div></a></div></div></div>    
</body>
</html>