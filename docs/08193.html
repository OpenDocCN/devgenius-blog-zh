<html>
<head>
<title>JavaScript Promise Chaining — Avoid Callback Hell</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript 承诺链——避免回调地狱</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/javascript-promise-chaining-avoid-callback-hell-6e04818d4464?source=collection_archive---------9-----------------------#2022-05-24">https://blog.devgenius.io/javascript-promise-chaining-avoid-callback-hell-6e04818d4464?source=collection_archive---------9-----------------------#2022-05-24</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/b63e2fb1872edff33edcaff25f4c78e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*uLjTm9CLmmITQC233T-KzA.gif"/></div></div></figure><p id="cde6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你从事 JavaScript web 开发，我猜你已经熟悉了一个<code class="fe kt ku kv kw b">Promise</code>,并且曾经多次面临回调地狱。JavaScript 中的承诺链是解决回调地狱问题的一种方法，我们将在本文中讨论它。但是，对于那些不熟悉这些概念的人，让我们稍微回顾一下。</p></div><div class="ab cl kx ky hr kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ig ih ii ij ik"><h1 id="847e" class="le lf in bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">什么是 JavaScript <code class="fe kt ku kv kw b">Promise</code>？</h1><p id="cbb9" class="pw-post-body-paragraph jv jw in jx b jy mc ka kb kc md ke kf kg me ki kj kk mf km kn ko mg kq kr ks ig bi translated">在 JavaScript (ES6 和更高版本)中，<code class="fe kt ku kv kw b">Promise</code>是一个对象，表示异步操作的状态和结果，比如 API 调用或 IO 读/写。状态包括<em class="mh">未决</em>、<em class="mh">完成</em>和<em class="mh">拒绝</em>。</p><ul class=""><li id="b9d9" class="mi mj in jx b jy jz kc kd kg mk kk ml ko mm ks mn mo mp mq bi translated">挂起:操作正在进行，尚未返回结果。</li><li id="f10c" class="mi mj in jx b jy mr kc ms kg mt kk mu ko mv ks mn mo mp mq bi translated">完成:一次操作成功，结果返回。</li><li id="90c6" class="mi mj in jx b jy mr kc ms kg mt kk mu ko mv ks mn mo mp mq bi translated">拒绝:操作失败，返回错误。</li></ul><p id="56e7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一个<code class="fe kt ku kv kw b">Promise</code>有两种方法:<code class="fe kt ku kv kw b">then</code>和<code class="fe kt ku kv kw b">catch</code>。<code class="fe kt ku kv kw b">then</code>方法接受一个<em class="mh">回调</em>一个要在承诺完成后发起的动作，同时<code class="fe kt ku kv kw b">catch</code>在承诺被拒绝时运行。</p><pre class="mw mx my mz gt na kw nb nc aw nd bi"><span id="bb92" class="ne lf in kw b gy nf ng l nh ni">// Asynchronous API call operation<br/>getWeatherTodayPromise<br/>   .then((weatherForecast) =&gt; { // Fulfilled<br/>      // Synchronous operation<br/>      display(weatherForecast)<br/>   })<br/>   .catch((error) = &gt; { // Rejected<br/>      console.error(error)<br/>   })</span></pre></div><div class="ab cl kx ky hr kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ig ih ii ij ik"><h1 id="28b6" class="le lf in bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">什么是回调地狱？</h1><p id="f8e0" class="pw-post-body-paragraph jv jw in jx b jy mc ka kb kc md ke kf kg me ki kj kk mf km kn ko mg kq kr ks ig bi translated">简而言之，当你的回调被多层嵌套时，它就变得难以管理了。这在任何编程语言中都可能发生，在异步操作中更常见。JavaScript 中深度嵌套的承诺和回调只是回调地狱的一种形式，本文中的例子都是基于这种回调地狱的变化。</p><pre class="mw mx my mz gt na kw nb nc aw nd bi"><span id="4685" class="ne lf in kw b gy nf ng l nh ni">// A typical callback hell which involves multiple JavaScript promises<br/>firstPromise<br/>   .then(secondPromise<br/>      .then(thirdPromise<br/>         .then(...).catch(...)<br/>      ).catch(...)<br/>   ).catch(...)</span></pre><p id="6792" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">可读性是一方面，但是回调函数会导致其他范围问题。一个典型的例子是当一个内在承诺引起的错误没有被发现时的错误隐藏(吞咽)。</p><pre class="mw mx my mz gt na kw nb nc aw nd bi"><span id="cb6f" class="ne lf in kw b gy nf ng l nh ni">// Asynchronous API call operation<br/>getWeatherTodayPromise<br/>   .then((weatherForecast) =&gt; {<br/>      // Asynchronous IO operation<br/>      writeWeatherForecastToLogFilePromise(weatherForecast) // FAILED</span><span id="9691" class="ne lf in kw b gy nj ng l nh ni">          ...</span><span id="b7e3" class="ne lf in kw b gy nj ng l nh ni">         // Unlike try-catch, there is no outer "catch-all" solution<br/>         // You must have a "catch" at every nested promise<br/>         // Or else, the promise is not terminated, and the error information is lost<br/>         .catch((error) =&gt; {<br/>            // IO error is caught here<br/>            console.error("Inner promise", error)<br/>         })<br/>   })<br/>   .catch((error) = &gt; {<br/>       // IO error is NOT caught here<br/>       console.error("Outer promise", error)<br/>   })</span></pre></div><div class="ab cl kx ky hr kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ig ih ii ij ik"><h1 id="0e23" class="le lf in bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">JavaScript 中的承诺链是什么？</h1><p id="561a" class="pw-post-body-paragraph jv jw in jx b jy mc ka kb kc md ke kf kg me ki kj kk mf km kn ko mg kq kr ks ig bi translated">你刚刚学到了回调地狱表示不可管理的嵌套层次的回调。也就是说，解决这个问题的一个方法是让回调不再嵌套。弄浅一点！</p><p id="4735" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">JavaScript 中的承诺链接是指连续调用多个<code class="fe kt ku kv kw b">then</code>和<code class="fe kt ku kv kw b">catch</code>方法来完全移除嵌套层次，同时仍然保持预期的输出。你可以说这是重构代码库的一种方式。</p><pre class="mw mx my mz gt na kw nb nc aw nd bi"><span id="aaf9" class="ne lf in kw b gy nf ng l nh ni">// Promise chaining<br/>firstPromise<br/>   .then(() =&gt; secondPromise)<br/>   .then(() =&gt; thirdPromise)<br/>   .then(...)<br/>   .catch(...)<br/>   .catch(...)<br/>   .catch(...)<br/>   .then(...)</span><span id="d4fb" class="ne lf in kw b gy nj ng l nh ni">// A typical callback hell which involves multiple JavaScript promises<br/>firstPromise<br/>   .then(secondPromise<br/>      .then(thirdPromise<br/>         .then(...).catch(...)<br/>      ).catch(...)<br/>   ).catch(...)</span></pre><p id="968e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果您处理的是常规的基于回调的函数(而不是承诺)，那么您需要首先对函数进行承诺，以应用承诺链。有很多方法可以做到这一点，比如使用一个<code class="fe kt ku kv kw b"><a class="ae nk" href="https://github.com/mikehall314/es6-promisify" rel="noopener ugc nofollow" target="_blank">es6-promisify</a></code>库。</p></div><div class="ab cl kx ky hr kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ig ih ii ij ik"><h1 id="b2c2" class="le lf in bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">JavaScript 中的承诺链是如何工作的？</h1><ul class=""><li id="a353" class="mi mj in jx b jy mc kc md kg nl kk nm ko nn ks mn mo mp mq bi translated"><code class="fe kt ku kv kw b">then</code>和<code class="fe kt ku kv kw b">catch</code>是一个<code class="fe kt ku kv kw b">Promise</code>对象的方法，所以要创建一个链，<code class="fe kt ku kv kw b">then</code>方法中的回调必须返回一个新的<code class="fe kt ku kv kw b">Promise</code>。</li></ul><pre class="mw mx my mz gt na kw nb nc aw nd bi"><span id="2042" class="ne lf in kw b gy nf ng l nh ni">// Correct implementation<br/>// "() =&gt; something" is a shorthand for "() =&gt; {return something})<br/>const secondPromise = firstPromise.then(() =&gt; newPromise)<br/>secondPromise.then(() =&gt; anotherPromise).then(...)</span><span id="e5f3" class="ne lf in kw b gy nj ng l nh ni">// Wrong implementation and an exception is raised<br/>firstPromise.then(() =&gt; null).then(...)</span></pre><ul class=""><li id="afd1" class="mi mj in jx b jy jz kc kd kg mk kk ml ko mm ks mn mo mp mq bi translated">一个承诺的结果被带到下一个<code class="fe kt ku kv kw b">then</code>。</li></ul><pre class="mw mx my mz gt na kw nb nc aw nd bi"><span id="7886" class="ne lf in kw b gy nf ng l nh ni">getWeatherTodayPromise<br/>   .then(weatherForecastResult =&gt; writeWeatherForecastToLogFilePromise(weatherForecastResult))<br/>   // writeWeatherForecastToLogFilePromise(weatherForecastResult) if fulfilled will provide "ioWriteResult"<br/>   .then(ioWriteResult =&gt; Promise.all([<br/>      anotherPromise(ioWriteResult),<br/>      andSomethingElsePromise(),<br/>    ]))<br/>   .then(listOfResults =&gt; ...)</span></pre><ul class=""><li id="2bae" class="mi mj in jx b jy jz kc kd kg mk kk ml ko mm ks mn mo mp mq bi translated">我们可以手动初始化并返回一个新的<code class="fe kt ku kv kw b">Promise</code>对象来形成承诺链。您可以应用这种技术将代码库分割成更小的块，而不是在一个回调中执行任务。</li></ul><pre class="mw mx my mz gt na kw nb nc aw nd bi"><span id="25ba" class="ne lf in kw b gy nf ng l nh ni">firstPromise<br/>   .then(() =&gt; {<br/>       const isSuccess = synchronousOperation() // boolean<br/>       return isSuccess ? Promise.resolve("Success") : Promise.reject(new Error("404"))<br/>    })<br/>    .then((result) =&gt; console.log(result)) // Print "Success"<br/>    .catch(error) =&gt; console.error(error)) // Print an error with "404" message</span></pre><ul class=""><li id="dbe2" class="mi mj in jx b jy jz kc kd kg mk kk ml ko mm ks mn mo mp mq bi translated">一个<code class="fe kt ku kv kw b">then</code>方法有第二个可选的<code class="fe kt ku kv kw b">onRejectedCallback</code>参数，但是因为我们不使用它，所以每当出现异常时，浏览器会沿着整个承诺链查找给定错误的第一个可接受的<code class="fe kt ku kv kw b">catch</code>。</li><li id="2fde" class="mi mj in jx b jy mr kc ms kg mt kk mu ko mv ks mn mo mp mq bi translated">通过使用 promise chaining，您可以拥有一个类似于<code class="fe kt ku kv kw b">try-catch</code>的外部“无所不包”的解决方案，因此不再有错误吞咽的可能性。对于多个错误，您可以在一个<code class="fe kt ku kv kw b">catch</code>中有一个条件语句，或者您可以将它们分割成多个单独的<code class="fe kt ku kv kw b">catch</code>，如下所示。</li></ul><pre class="mw mx my mz gt na kw nb nc aw nd bi"><span id="9434" class="ne lf in kw b gy nf ng l nh ni">rejected5xxPromise<br/>   .catch(HTTP 4xx) // Browser: "Not here"<br/>   .catch(HTTP 5xx) // Browser: "Okay, this catches the 5xx error"<br/>   .catch(Other unexpected errors) // Skip</span></pre><ul class=""><li id="686f" class="mi mj in jx b jy jz kc kd kg mk kk ml ko mm ks mn mo mp mq bi translated">您可以在<code class="fe kt ku kv kw b">catch</code>后链接一个<code class="fe kt ku kv kw b">then</code>。这意味着“无论如何都要操作”。</li></ul><pre class="mw mx my mz gt na kw nb nc aw nd bi"><span id="b7b8" class="ne lf in kw b gy nf ng l nh ni">rejected5xxPromise<br/>   .catch(HTTP 5xx)<br/>   .then(console.log("This line is always printed out"))</span></pre></div><div class="ab cl kx ky hr kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ig ih ii ij ik"><h1 id="aa9d" class="le lf in bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">包裹</h1><p id="eee7" class="pw-post-body-paragraph jv jw in jx b jy mc ka kb kc md ke kf kg me ki kj kk mf km kn ko mg kq kr ks ig bi translated">JavaScript promise chaining 是一个简单但强大的特性，可以解决常见的嵌套回调问题(回调地狱)。要兑现承诺，你需要记住两个要点。</p><ol class=""><li id="d59e" class="mi mj in jx b jy jz kc kd kg mk kk ml ko mm ks no mo mp mq bi translated">可以连续调用多个<code class="fe kt ku kv kw b">then</code>和<code class="fe kt ku kv kw b">catch</code>，如<code class="fe kt ku kv kw b">promise.then(...).then(...).catch(...).catch(...)</code>。</li><li id="5248" class="mi mj in jx b jy mr kc ms kg mt kk mu ko mv ks no mo mp mq bi translated">在<code class="fe kt ku kv kw b">then</code>方法中的回调必须返回一个新的<code class="fe kt ku kv kw b">Promise</code>对象，这样链才能继续。</li></ol><p id="ee9b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">该规则也适用于 TypeScript。ES2016(又名 ES7)中引入了<code class="fe kt ku kv kw b">async/await</code>功能，它让我们的生活变得更加轻松。也就是说，如果你因为某种原因不能使用 ES7 特性，那么 promise chaining 是重构你的代码库的一个很好的选择。</p></div><div class="ab cl kx ky hr kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ig ih ii ij ik"><p id="7ec6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对网页开发感兴趣？我的其他文章可能对你有帮助！</p><ul class=""><li id="2099" class="mi mj in jx b jy jz kc kd kg mk kk ml ko mm ks mn mo mp mq bi translated"><a class="ae nk" href="https://hungvu.tech/front-end-tech-stack-components" rel="noopener ugc nofollow" target="_blank">你应该知道的前端、顶级框架和库</a></li><li id="6604" class="mi mj in jx b jy mr kc ms kg mt kk mu ko mv ks mn mo mp mq bi translated"><a class="ae nk" href="https://hungvu.tech/github-cli-in-3-minutes" rel="noopener ugc nofollow" target="_blank">GitHub CLI 3 分钟</a></li></ul></div></div>    
</body>
</html>