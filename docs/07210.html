<html>
<head>
<title>Simple REST service in Golang with OpenAPI spec and ORM</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Golang 中的简单 REST 服务，带有 OpenAPI 规范和 ORM</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/simple-rest-service-in-golang-with-openapi-spec-and-orm-a447b1086e21?source=collection_archive---------3-----------------------#2022-03-06">https://blog.devgenius.io/simple-rest-service-in-golang-with-openapi-spec-and-orm-a447b1086e21?source=collection_archive---------3-----------------------#2022-03-06</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="d1dd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">网上已经有很多关于 REST 服务实现的文章。与此同时，不同的技术和库有更多的组合。我在寻找一个使用 Go 的实现，有易于手动测试的 Swagger UI，在后端有一个数据库，有最少的样板文件。这些是我使用的库:</p><ul class=""><li id="42f9" class="ki kj in jm b jn jo jr js jv kk jz kl kd km kh kn ko kp kq bi translated"><a class="ae kr" href="https://gorm.io/" rel="noopener ugc nofollow" target="_blank"> gorm </a>作为 orm 库</li><li id="2089" class="ki kj in jm b jn ks jr kt jv ku jz kv kd kw kh kn ko kp kq bi translated"><a class="ae kr" href="https://github.com/spf13/viper" rel="noopener ugc nofollow" target="_blank">蝰蛇</a>进行配置管理</li><li id="0a2d" class="ki kj in jm b jn ks jr kt jv ku jz kv kd kw kh kn ko kp kq bi translated"><a class="ae kr" href="https://github.com/gin-gonic/gin" rel="noopener ugc nofollow" target="_blank"> gin </a>作为 web 框架</li><li id="a7ad" class="ki kj in jm b jn ks jr kt jv ku jz kv kd kw kh kn ko kp kq bi translated">从 go 注释中生成 OpenAPI 规范</li></ul><p id="2b20" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae kr" href="https://github.com/ragoncsa/todo/tree/v0.1.0" rel="noopener ugc nofollow" target="_blank"><strong class="jm io">github 上的源代码</strong> </a></p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi kx"><img src="../Images/43ee46b93cccb77aa26e80d357e57048.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vcQ1fR3viOgZzFOG5v4NUQ.png"/></div></div></figure><h1 id="b3d9" class="lj lk in bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">包装布局</h1><p id="041b" class="pw-post-body-paragraph jk jl in jm b jn mh jp jq jr mi jt ju jv mj jx jy jz mk kb kc kd ml kf kg kh ig bi translated">我使用了本·约翰逊建议的包装布局<a class="ae kr" href="https://medium.com/@benbjohnson/standard-package-layout-7cdbc8391fc1" rel="noopener">。这些是摘自他文章的关键观点:</a></p><ul class=""><li id="e615" class="ki kj in jm b jn jo jr js jv kk jz kl kd km kh kn ko kp kq bi translated">拥有一个不依赖于任何其他包的域包(“一种描述数据和流程如何交互的逻辑高级语言”)</li><li id="6a3e" class="ki kj in jm b jn ks jr kt jv ku jz kv kd kw kh kn ko kp kq bi translated">在其他包中保留依赖项，并复制包名以强制我们自己隔离外部依赖项。例如，通过创建我们自己的“http”包，将确保对“net/http”的引用只驻留在我们的“http”中</li><li id="299b" class="ki kj in jm b jn ks jr kt jv ku jz kv kd kw kh kn ko kp kq bi translated">将共享模拟子包与简单的手写模拟一起使用</li></ul><p id="239a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">根据这些想法，我创建了下面的包:</p><ul class=""><li id="629d" class="ki kj in jm b jn jo jr js jv kk jz kl kd km kh kn ko kp kq bi translated"><strong class="jm io">域:</strong>用于服务接口及其使用的数据结构。</li><li id="c36e" class="ki kj in jm b jn ks jr kt jv ku jz kv kd kw kh kn ko kp kq bi translated"><strong class="jm io"> gorm: </strong>用于通过 orm 抽象的数据库交互。</li><li id="0fd0" class="ki kj in jm b jn ks jr kt jv ku jz kv kd kw kh kn ko kp kq bi translated"><strong class="jm io"> http </strong>:用于处理 http 流量。这也可以称为 gin，因为这是使用的框架。</li><li id="bc02" class="ki kj in jm b jn ks jr kt jv ku jz kv kd kw kh kn ko kp kq bi translated"><strong class="jm io"> mock: </strong>为用于测试的仿制品。</li></ul><p id="d455" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在我们有了我们的包布局，让我们看看一些关于实现的细节。</p><h1 id="9aa6" class="lj lk in bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">领域</h1><p id="37cc" class="pw-post-body-paragraph jk jl in jm b jn mh jp jq jr mi jt ju jv mj jx jy jz mk kb kc kd ml kf kg kh ig bi translated">这里我们有一个简单的结构，非常适合演示。</p><figure class="ky kz la lb gt lc"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="9857" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我按照 gorm 惯例命名任务中的字段。例如，ID 将成为主键。</p><h1 id="3898" class="lj lk in bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">gorm 包</h1><p id="5ae5" class="pw-post-body-paragraph jk jl in jm b jn mh jp jq jr mi jt ju jv mj jx jy jz mk kb kc kd ml kf kg kh ig bi translated">这是与数据库交互的实现。由于使用了 gorm，这不会引入对数据库的直接依赖，这样做的好处是可以在需要时更改数据库。然而，我在这个演示中使用 gorm 的动机更多的是为了减少样板文件。我不想手动定义我的数据库模式，或者手动编写 SQL。这样可以更快地启动和运行一些东西。(尽管 gorm 也支持手写 SQL ，这在构建更复杂的东西时可能会变得很方便。)</p><figure class="ky kz la lb gt lc"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="fc26" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Gorm 还<a class="ae kr" href="https://gorm.io/docs/migration.html" rel="noopener ugc nofollow" target="_blank">支持数据库迁移</a>，这有助于保持模式与代码中的数据结构同步。</p><figure class="ky kz la lb gt lc"><div class="bz fp l di"><div class="mm mn l"/></div></figure><h1 id="9cfc" class="lj lk in bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">http 包</h1><p id="e282" class="pw-post-body-paragraph jk jl in jm b jn mh jp jq jr mi jt ju jv mj jx jy jz mk kb kc kd ml kf kg kh ig bi translated">为了处理 HTTP 请求和实现路由，我们使用了<a class="ae kr" href="https://github.com/gin-gonic/gin" rel="noopener ugc nofollow" target="_blank"> Gin Web 框架</a>。我发现 Gin 需要的样板文件比<a class="ae kr" href="https://github.com/gorilla/mux" rel="noopener ugc nofollow" target="_blank"> mux </a>少。我喜欢你不需要使用一个<a class="ae kr" href="https://pkg.go.dev/encoding/json#Encoder" rel="noopener ugc nofollow" target="_blank"> JSON 编码器</a>在 HTTP 响应中返回你的 JSON。我还发现模型绑定很方便。下面是一个如何在任务创建的处理程序中使用它的例子</p><figure class="ky kz la lb gt lc"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="2805" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">路由在一个中央文件中单独定义，传递一个具有处理程序的接口。</p><figure class="ky kz la lb gt lc"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="14f0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">昂首阔步的杜松子酒</strong></p><p id="07ad" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae kr" href="https://github.com/swaggo/swag" rel="noopener ugc nofollow" target="_blank"> Swag </a>将 Go 注释转换为 Swagger Documentation 2.0。Open API Spec(又名 Swagger spec)的最新版本是<a class="ae kr" href="https://swagger.io/specification/" rel="noopener ugc nofollow" target="_blank"> 3.0.3 </a>，但是我没有找到一个支持 v3 的生成 Spec 的工具。另外，我的目标是让 Swagger UI 可用于手动测试，它可以与 Open API v2 和 v3 一起工作，因此它符合目的。</p><p id="1b9c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">规范生成也被称为“代码优先方法”。<a class="ae kr" href="https://smartbear.com/blog/embracing-an-api-design-first-approach/" rel="noopener ugc nofollow" target="_blank">对 API 的一般建议是首先创建规范</a>并从中生成代码，以确保当实现已经完成时，设计问题不会在事后出现。然而，要快速创建小的演示(像这样)，代码优先的方法可能更好。此外，当您需要为现有服务创建规范时，它可能会有好处。</p><p id="e32b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">规范生成是由 API 操作上的注释驱动的(在我们的例子中是处理程序实现)</p><figure class="ky kz la lb gt lc"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="bdc7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">以及数据结构上的标签。</p><figure class="ky kz la lb gt lc"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="e691" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Swag 还支持大多数流行的 go web 框架，如 gin with <a class="ae kr" href="https://github.com/swaggo/gin-swagger" rel="noopener ugc nofollow" target="_blank"> gin-swagger </a>。这样我们就可以添加一个服务于 Swagger UI 的处理程序。它可以简单地用其他路线来定义。</p><figure class="ky kz la lb gt lc"><div class="bz fp l di"><div class="mm mn l"/></div></figure><h1 id="6c78" class="lj lk in bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">单元测试和模拟</h1><p id="de46" class="pw-post-body-paragraph jk jl in jm b jn mh jp jq jr mi jt ju jv mj jx jy jz mk kb kc kd ml kf kg kh ig bi translated">我使用了手写的简单模拟。</p><figure class="ky kz la lb gt lc"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="0764" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因为它在域中实现了 TaskService 接口，所以可以将其传递给 http。TaskService 作为后端，因此可以测试处理程序。</p><h1 id="25d7" class="lj lk in bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">一些摩擦:处理日期和时间</h1><p id="a534" class="pw-post-body-paragraph jk jl in jm b jn mh jp jq jr mi jt ju jv mj jx jy jz mk kb kc kd ml kf kg kh ig bi translated">唯一一次，当我发现这些组件不能直接使用时，是处理日期和时间。Swag 没有对它的本地支持，所以需要实现编组和解组，并为 time.Time 定义一个包装器。</p><figure class="ky kz la lb gt lc"><div class="bz fp l di"><div class="mm mn l"/></div></figure><h1 id="0e03" class="lj lk in bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">建造和运行</h1><p id="3c0a" class="pw-post-body-paragraph jk jl in jm b jn mh jp jq jr mi jt ju jv mj jx jy jz mk kb kc kd ml kf kg kh ig bi translated">我们可以构建一个安装了 go 二进制文件的容器映像</p><figure class="ky kz la lb gt lc"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="2056" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后使用 docker-compose 构建一个包含数据库的本地测试环境</p><figure class="ky kz la lb gt lc"><div class="bz fp l di"><div class="mm mn l"/></div></figure><h1 id="c1d9" class="lj lk in bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">结论</h1><p id="953e" class="pw-post-body-paragraph jk jl in jm b jn mh jp jq jr mi jt ju jv mj jx jy jz mk kb kc kd ml kf kg kh ig bi translated">在这篇文章中，我们介绍了如何用 Go 构建一个简单的 REST 服务。我们从包布局开始，然后实现域逻辑，使用 gorm 添加 ORM 支持，使用 gin 处理 HTTP 流量和路由。我们还使用 swag 生成了 Open API spec，并构建了一个本地测试环境来进行测试。</p><p id="f25b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">接下来，我们可以添加某种形式的身份验证和授权、日志记录，也许还可以添加一个部署脚本来部署到云提供商…</p><p id="ec52" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你对这个话题有什么意见，不要留着给自己，发个评论吧:)谢谢</p></div></div>    
</body>
</html>