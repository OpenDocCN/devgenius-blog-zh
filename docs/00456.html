<html>
<head>
<title>Find the largest distance between two nodes in a tree (a.k.a Diameter of The Tree)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">找出树中两个节点之间的最大距离(也就是树的直径)</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/find-the-largest-distance-between-two-nodes-in-a-tree-a-k-a-diameter-of-the-tree-620e33d7b0d8?source=collection_archive---------6-----------------------#2020-06-08">https://blog.devgenius.io/find-the-largest-distance-between-two-nodes-in-a-tree-a-k-a-diameter-of-the-tree-620e33d7b0d8?source=collection_archive---------6-----------------------#2020-06-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="324e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">大家好…..今天我们将讨论一个关于树的有趣问题，这个问题在各种形式的技术访谈中经常被问到。首先让我们看看问题陈述。</p><p id="0d0a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">问题陈述:- </strong> <br/> <em class="ki">有一棵未加权的树，由 N 个节点组成。我们需要找到树中两个节点之间的最大距离。两个节点之间的距离将是节点之间路径上的边数。<br/>路径将是唯一的，因为它是一棵树。</em></p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi kj"><img src="../Images/5f06134209f2578673f9b2f4e14319d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*OfvvOTZQCjyzGfjmvOXexA.jpeg"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">有 9 个节点的无向树</figcaption></figure><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi kj"><img src="../Images/2a180cd9220b43ecd4b9198b28bf99e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*1WDx2432ItCS7ujO3DtdXg.jpeg"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">上述树的最大路径</figcaption></figure><h2 id="0464" class="kv kw in bd kx ky kz dn la lb lc dp ld jv le lf lg jz lh li lj kd lk ll lm ln bi translated">输入:</h2><p id="8c7d" class="pw-post-body-paragraph jk jl in jm b jn lo jp jq jr lp jt ju jv lq jx jy jz lr kb kc kd ls kf kg kh ig bi translated">第一行包含每个测试用例的测试用例数量<br/>:第一行包含树中节点的数量，即 N 和边的数量，即 M。<br/>接下来的 N 行包含两个整数 U 和 V，它们表示节点 U 和节点 V 之间的一条边</p><p id="980c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">输出:<br/> </strong>为每个测试用例打印一个新行中树的最大距离。</p><h1 id="1272" class="lt kw in bd kx lu lv lw la lx ly lz ld ma mb mc lg md me mf lj mg mh mi lm mj bi translated">强力解决方案:-</h1><p id="e8a6" class="pw-post-body-paragraph jk jl in jm b jn lo jp jq jr lp jt ju jv lq jx jy jz lr kb kc kd ls kf kg kh ig bi translated">在看了问题陈述并思考了一会儿后，我意识到我需要找到两个节点之间的最大距离，例如，在上面的例子中，最大距离是六个单元/边的节点 9 和节点 6 之间的距离。我们怎样才能找到它呢？？？<br/>我首先想到的是做一个<a class="ae mk" href="https://www.geeksforgeeks.org/breadth-first-search-or-bfs-for-a-graph/" rel="noopener ugc nofollow" target="_blank"> BFS(广度优先搜索)</a>从每个节点开始寻找树中每隔一个节点的距离。<br/>节点 2、3、4、5…9 到节点 1 的距离<br/>节点 1、3、4、5…9 到节点 2 的距离，依此类推……… <br/>跟踪每个节点遍历的最大距离将会给我们很好的答案…</p><p id="2eeb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下面是蛮力方法的 C++实现</p><pre class="kk kl km kn gt ml mm mn mo aw mp bi"><span id="24ae" class="kv kw in mm b gy mq mr l ms mt">#include &lt;bits/stdc++.h&gt;<br/>using namespace std;</span><span id="703f" class="kv kw in mm b gy mu mr l ms mt">int ans = INT_MIN;</span><span id="8524" class="kv kw in mm b gy mu mr l ms mt">void bfs(int start, vector&lt;vector&lt;int&gt; &gt; &amp;adjList)<br/>{<br/>    int n = adjList.size();<br/>    int res = 0; //to get the maximum distance of the current particular node under investigation</span><span id="ad77" class="kv kw in mm b gy mu mr l ms mt">vector&lt;int&gt; distance(n+1, -1); //to store distance of nodes from the start node<br/>    distance[start] = 0; //distance of start node from itself will be 0</span><span id="d90a" class="kv kw in mm b gy mu mr l ms mt">//queue to do breadth first search from the start node<br/>    queue&lt;int&gt; q;<br/>    q.push(start);</span><span id="69be" class="kv kw in mm b gy mu mr l ms mt">while(!q.empty())<br/>    {<br/>        int curr = q.front();<br/>        q.pop();</span><span id="3b9d" class="kv kw in mm b gy mu mr l ms mt">//try to explore the childs of the current node under investigation<br/>        for(int i = 0; i &lt; (int)adjList[curr].size(); i++)<br/>        {<br/>            //distance of this node from start is -1 i.e this node <br/>            //hasn't been explored yet so add it to the queue to get explored<br/>            if(distance[adjList[curr][i]] == -1)<br/>            {<br/>                distance[adjList[curr][i]] = distance[curr]+1;<br/>                q.push(adjList[curr][i]);<br/>                res = max(res, distance[adjList[curr][i]]);<br/>            }<br/>        }<br/>    }</span><span id="cce3" class="kv kw in mm b gy mu mr l ms mt">//find the global maximum answer<br/>    ans = max(ans, res);<br/>}</span><span id="d551" class="kv kw in mm b gy mu mr l ms mt">int DiameterofTree(int n, vector&lt;vector&lt;int &gt; &gt;&amp; edgelist)<br/>{<br/>    //convert edgeList representation to adjacency list representation<br/>    vector&lt;vector&lt;int&gt; &gt; adjList(n+1);<br/>    for(int i = 0; i &lt; (int)edgelist.size(); i++)<br/>    {<br/>        adjList[edgelist[i][0]].push_back(edgelist[i][1]);<br/>        adjList[edgelist[i][1]].push_back(edgelist[i][0]);<br/>    }</span><span id="90a1" class="kv kw in mm b gy mu mr l ms mt">//do a bfs on each node of the graph<br/>    for(int i = 1; i &lt;= n; i++)<br/>        bfs(i, adjList);</span><span id="e5ca" class="kv kw in mm b gy mu mr l ms mt">return ans;<br/>}</span><span id="3b0d" class="kv kw in mm b gy mu mr l ms mt">int main()<br/>{<br/>    int tests;<br/>    cin&gt;&gt;tests;<br/>    while(tests--)<br/>    {<br/>        //refresh the answer for each case<br/>        ans  = INT_MIN;<br/>        //number of nodes and edges in the graph<br/>        int nodes, edges;<br/>        cin &gt;&gt; nodes &gt;&gt; edges;<br/>        <br/>        //originally edgelist is given to represent the graph<br/>        int vertex1, vertex2;<br/>        vector&lt;vector&lt;int &gt; &gt; edgelist;<br/>        for(int i = 0; i &lt; edges; i++)<br/>        {<br/>            cin &gt;&gt; vertex1 &gt;&gt; vertex2;<br/>            vector&lt;int &gt; temp = {vertex1, vertex2};<br/>            edgelist.push_back(temp);<br/>        }<br/>        <br/>        int result = DiameterofTree(nodes, edgelist);<br/>        cout &lt;&lt; result &lt;&lt; "\n";<br/>    }<br/>    return 0;<br/>}</span></pre><p id="4e34" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是让我们看看它的时间复杂度，它是 O( V * ( V+E ) ) <br/>因为我们在每个节点上做一个 BFS 需要 O( V+E)时间，也就是 BFS 做了 V 次，因此时间复杂度是 O(V)，这不是一个好的锁定协议。我们能做得更好吗……..让我看看……</p><h1 id="2007" class="lt kw in bd kx lu lv lw la lx ly lz ld ma mb mc lg md me mf lj mg mh mi lm mj bi translated">优化的解决方案:-</h1><p id="eaf6" class="pw-post-body-paragraph jk jl in jm b jn lo jp jq jr lp jt ju jv lq jx jy jz lr kb kc kd ls kf kg kh ig bi translated">是的，我们可以改进我们的蛮力实现<br/>,只是我们需要更聪明地应用 BFS 遍历。</p><p id="0f00" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们从任意一个节点 X 开始一个 BFS，寻找距离 X 最远的节点 Y。这个节点 Y 将是树中最长路径的末端节点。然后在这个节点 Y 上应用一个 BFS，找到实际最长路径的另一端，得到想要的结果。</p><p id="e361" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在上面的例子中，假设我们从节点 1 开始一个 BFS，距离节点 1 最远的节点是节点 9。然后我们在节点 9 上应用 BFS，得到离它最远的节点，这里是节点 6(也是节点 5)。更多细节请参考<a class="ae mk" href="https://stackoverflow.com/questions/20010472/proof-of-correctness-algorithm-for-diameter-of-a-tree-in-graph-theory" rel="noopener ugc nofollow" target="_blank">该堆栈溢出帖子</a></p><p id="94bf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">唯一需要修改的块是:-</p><pre class="kk kl km kn gt ml mm mn mo aw mp bi"><span id="29ef" class="kv kw in mm b gy mq mr l ms mt">int DiameterofTree(int n, vector&lt;vector&lt;int &gt; &gt;&amp; edgelist)</span><span id="1e93" class="kv kw in mm b gy mu mr l ms mt">{</span><span id="eeb5" class="kv kw in mm b gy mu mr l ms mt">vector&lt;vector&lt;int&gt; &gt; adjList(n+1);</span><span id="1115" class="kv kw in mm b gy mu mr l ms mt">for(int i = 0; i &lt; (int)edgelist.size(); i++)</span><span id="f653" class="kv kw in mm b gy mu mr l ms mt">{</span><span id="0cc5" class="kv kw in mm b gy mu mr l ms mt">adjList[edgelist[i][0]].push_back(edgelist[i][1]);</span><span id="1921" class="kv kw in mm b gy mu mr l ms mt">adjList[edgelist[i][1]].push_back(edgelist[i][0]);</span><span id="9a90" class="kv kw in mm b gy mu mr l ms mt">}</span><span id="b01c" class="kv kw in mm b gy mu mr l ms mt">//first bfs from an arbitrary node to find the farthest node from it</span><span id="bcca" class="kv kw in mm b gy mu mr l ms mt">int x = bfs(1, adjList);</span><span id="8671" class="kv kw in mm b gy mu mr l ms mt">//use that farthest node to find the other end of the longest path in the tree</span><span id="8f72" class="kv kw in mm b gy mu mr l ms mt">int z = bfs(x, adjList);</span><span id="999f" class="kv kw in mm b gy mu mr l ms mt">return ans; //it is a global variable</span><span id="a124" class="kv kw in mm b gy mu mr l ms mt">}</span></pre><p id="b907" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">由于涉及两次 BFS 遍历，因此时间复杂度为 O(V+E ),其中 V 是图中顶点的数量，E 是图中边的数量。这是一个很好的协议。不是吗..？你觉得怎么样…？？？</p></div><div class="ab cl mv mw hr mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ig ih ii ij ik"><p id="2907" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我知道我的解释是否有助于你理解这个问题。我期待着你的建议，以改善我的文章。你可以把你对 jainlokesh318@gmail.com 的回应寄给我。</p><h1 id="b951" class="lt kw in bd kx lu lv lw la lx ly lz ld ma mb mc lg md me mf lj mg mh mi lm mj bi translated">快乐编码…！！！</h1></div></div>    
</body>
</html>