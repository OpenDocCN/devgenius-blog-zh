<html>
<head>
<title>Automatic Resource Allocation on AWS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">AWS上的自动资源分配</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/automatic-resource-allocation-on-aws-5907736724be?source=collection_archive---------8-----------------------#2021-12-31">https://blog.devgenius.io/automatic-resource-allocation-on-aws-5907736724be?source=collection_archive---------8-----------------------#2021-12-31</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="ca4a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">自动伸缩是一种以动态方式分配计算资源的云计算技术。服务器群或池中的活动服务器数量通常会随着用户需求的波动而自动变化，这取决于负载。</p><p id="808b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">假设你有一个销售产品的网站，突然有一天你有成千上万的客户访问你的网站，好吧，这是个好消息！但是如果你的网站因为流量过大而瘫痪了呢？这会给你的业务带来巨大的损失，这就是为什么你需要web服务器的自动伸缩。</p></div><div class="ab cl ki kj hr kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="ig ih ii ij ik"><blockquote class="kp kq kr"><p id="5099" class="jk jl ks jm b jn jo jp jq jr js jt ju kt jw jx jy ku ka kb kc kv ke kf kg kh ig bi translated">我们使用Ansible来管理EC2自动伸缩应用程序部署。它是完美的，因为它很容易与CI等当前流程集成，允许快速创建持续部署管道。</p></blockquote><p id="d27a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">目标:</strong>创建一个设置，其中我们有一些初始数量的web服务器和一个负载平衡器，将请求重定向到这些服务器以平衡负载，以及一个自动缩放组来监控这些服务器，并在更多负载或服务器故障时启动更多服务器。</p><figure class="kx ky kz la gt lb gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi kw"><img src="../Images/65383fafbdfa384933ae237c57100377.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GArVCtBgdVvdSVj_rZhavg.jpeg"/></div></div></figure><p id="19f1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">该设置的工作流程如下:</p><h1 id="c28d" class="li lj in bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">准备AWS</h1><p id="f315" class="pw-post-body-paragraph jk jl in jm b jn mg jp jq jr mh jt ju jv mi jx jy jz mj kb kc kd mk kf kg kh ig bi translated">我们将使用EC2 classic，从为服务器创建EC2安全组开始，仅使用TCP/22打开必要的端口(对于web服务器，使用端口80)。</p><p id="68e0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对于对实例的SSH访问，创建一个新的密钥对。您可以上传现有的SSH公钥，或者创建一个新的私钥/公钥对。</p><h1 id="2981" class="li lj in bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated"><strong class="ak">设置Ansible </strong></h1><p id="5814" class="pw-post-body-paragraph jk jl in jm b jn mg jp jq jr mh jt ju jv mi jx jy jz mj kb kc kd mk kf kg kh ig bi translated">Ansible使用Boto进行AWS交互，因此请确保您的控制主机上安装了boto。我们还将利用AWS CLI工具，所以也要获得这些工具。</p><blockquote class="kp kq kr"><p id="1e81" class="jk jl ks jm b jn jo jp jq jr js jt ju kt jw jx jy ku ka kb kc kv ke kf kg kh ig bi translated">pip安装python-boto awscli</p></blockquote><p id="885e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">同样安装ansible，假设ansible版本为1.9.x</p><blockquote class="kp kq kr"><p id="e6d3" class="jk jl ks jm b jn jo jp jq jr js jt ju kt jw jx jy ku ka kb kc kv ke kf kg kh ig bi translated">add-apt-repository PPA:ansi ble/ansi ble<br/>apt-get install ansi ble</p></blockquote><p id="a112" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您应该将aws服务器放在“~/”中。AWS/凭据”</p><blockquote class="kp kq kr"><p id="0c19" class="jk jl ks jm b jn jo jp jq jr js jt ju kt jw jx jy ku ka kb kc kv ke kf kg kh ig bi translated">【凭证】<br/>AWS _ access _ key _ id =&lt;your _ access _ key _ here&gt;<br/>AWS _ secret _ access _ key =&lt;your _ secret _ key _ here&gt;</p></blockquote><h1 id="6cbf" class="li lj in bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">创建启动配置</h1><p id="54c1" class="pw-post-body-paragraph jk jl in jm b jn mg jp jq jr mh jt ju jv mi jx jy jz mj kb kc kd mk kf kg kh ig bi translated">一个启动配置是一个实例配置模板，Auto <br/> Scaling group使用它来启动EC2实例，所以现在我们想要创建一个<br/>新的启动配置来描述应该从这个AMI中<br/>启动的新实例。我们将创建一个角色来处理这个问题。</p><pre class="kx ky kz la gt ml mm mn mo aw mp bi"><span id="f6d5" class="mq lj in mm b gy mr ms l mt mu">- name: Create Launch Configuration<br/>  ec2_lc:<br/>    region: "ap-south-1"<br/>    name: "webserver1"<br/>    image_id: "{{ ami.image_id }}"<br/>    key_name: "{{ keypair }}"<br/>    instance_type: "t2.micro"<br/>    security_groups: "{{ security_groups }}"<br/>    volumes:<br/>      - device_name: /dev/xvda<br/>        device_type: gp2<br/>        volume_size: 10<br/>        delete_on_termination: true<br/>    instance_monitoring: yes</span></pre><p id="bc6a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">镜像id应该是你的web服务器镜像id，在这里你可以在aws上制作自己的ami。</p><h1 id="b4fd" class="li lj in bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">创建一个弹性负载平衡器</h1><p id="a649" class="pw-post-body-paragraph jk jl in jm b jn mg jp jq jr mh jt ju jv mi jx jy jz mj kb kc kd mk kf kg kh ig bi translated">客户端将连接到一个弹性负载均衡器，该均衡器将把<br/>传入的请求分发到我们已经启动的<br/>即将到来的自动伸缩组中的实例中。同样，我们将创建另一个角色来处理<br/>ELB的管理，并从我们的剧本中应用它。</p><pre class="kx ky kz la gt ml mm mn mo aw mp bi"><span id="965f" class="mq lj in mm b gy mr ms l mt mu"># roles/load-balancer/tasks/main.yml<br/><br/>- name: Configure Elastic Load Balancers<br/>  ec2_elb_lb:<br/>    region: "ap-south-1"<br/>    name: webapp<br/>    state: present<br/>    zones: "{{ zone }}"<br/>    connection_draining_timeout: 60<br/>    listeners:<br/>      - protocol: http<br/>        load_balancer_port: 80<br/>        instance_port: 80<br/>    health_check:<br/>      ping_protocol: http<br/>      ping_port: 80<br/>      ping_path: "/"<br/>      response_timeout: 10<br/>      interval: 30<br/>      unhealthy_threshold: 6<br/>      healthy_threshold: 2<br/>  register: elb_result</span></pre><h1 id="ae7f" class="li lj in bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">创建和配置自动缩放组</h1><p id="5976" class="pw-post-body-paragraph jk jl in jm b jn mg jp jq jr mh jt ju jv mi jx jy jz mj kb kc kd mk kf kg kh ig bi translated">我们将创建一个自动缩放组，并将其配置为使用我们之前创建的Launch <br/>配置。在我们定义的范围内，<br/> AWS将根据所有实例的当前<br/>负载，动态地将实例发送到ASG。同样，当负载下降时，一些实例会相应地终止<br/>。在一个或多个扩展策略中定义了启动或<br/>终止的实例的确切数量，这些策略也是<br/>创建的，并与ASG相关联。</p><pre class="kx ky kz la gt ml mm mn mo aw mp bi"><span id="7137" class="mq lj in mm b gy mr ms l mt mu"># roles/auto-scaling/tasks/main.yml<br/><br/>- name: Retrieve current Auto Scaling Group properties<br/>  command: "aws --region ap-south-1 autoscaling describe-auto-scaling-groups --auto-scaling-group-names webapp"<br/>  register: asg_properties_result<br/><br/>- name: Set asg_properties variable from JSON output if the Auto Scaling Group already exists<br/>  set_fact:<br/>    asg_properties: "{{ (asg_properties_result.stdout | from_json).AutoScalingGroups[0] }}"<br/>  when: (asg_properties_result.stdout | from_json).AutoScalingGroups | count<br/><br/>- name: Configure Auto Scaling Group and perform rolling deploy<br/>  ec2_asg:<br/>    region: "ap-south-1"<br/>    name: webapp<br/>    launch_config_name: webapp<br/>    availability_zones: "{{ zone }}"<br/>    health_check_type: ELB<br/>    health_check_period: 300<br/>    desired_capacity: "{{ asg_properties.DesiredCapacity | default(2) }}"<br/>    replace_all_instances: yes<br/>    replace_batch_size: "{{ (asg_properties.DesiredCapacity | default(2) / 4) | round(0, 'ceil') | int }}"<br/>    min_size: 2<br/>    max_size: 10<br/>    load_balancers:<br/>      - webapp<br/>    state: present<br/>  register: asg_result<br/><br/>- name: Configure Scaling Policies<br/>  ec2_scaling_policy:<br/>    region: "ap-south-1"<br/>    name: "{{ item.name }}"<br/>    asg_name: webapp<br/>    state: present<br/>    adjustment_type: "{{ item.adjustment_type }}"<br/>    min_adjustment_step: "{{ item.min_adjustment_step }}"<br/>    scaling_adjustment: "{{ item.scaling_adjustment }}"<br/>    cooldown: "{{ item.cooldown }}"<br/>  with_items:<br/>    - name: "Increase Group Size"<br/>      adjustment_type: "ChangeInCapacity"<br/>      scaling_adjustment: +1<br/>      min_adjustment_step: 1<br/>      cooldown: 180<br/>    - name: "Decrease Group Size"<br/>      adjustment_type: "ChangeInCapacity"<br/>      scaling_adjustment: -1<br/>      min_adjustment_step: 1<br/>      cooldown: 300<br/>  register: sp_result<br/><br/>- name: Determine Metric Alarm configuration<br/>  set_fact:<br/>    metric_alarms:<br/>      - name: "{{ asg_name }}-ScaleUp"<br/>        comparison: "&gt;="<br/>        threshold: 50.0<br/>        alarm_actions:<br/>          - "{{ sp_result.results[0].arn }}"<br/>      - name: "{{ asg_name }}-ScaleDown"<br/>        comparison: "&lt;="<br/>        threshold: 20.0<br/>        alarm_actions:<br/>          - "{{ sp_result.results[1].arn }}"</span></pre><p id="d28a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里发生了更多的事情。为了完成我们的配置，我们不仅要配置我们的ASG和扩展规则，还要生成CloudWatch指标警报，以测量我们实例的负载，并将它们与适当的扩展策略相关联。</p><p id="1418" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您可以根据需要在这里修改许多变量:</p><p id="5f0a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe mv mw mx mm b">replace_all_instances:</code>指定所有当前运行的实例都应该被新实例替换。</p><p id="be2c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe mv mw mx mm b">replace_batch_size:</code>如果您一直在运行更多的实例，您可能希望增加这个值。</p><h1 id="ce21" class="li lj in bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">搞定了。</h1><p id="556d" class="pw-post-body-paragraph jk jl in jm b jn mg jp jq jr mh jt ju jv mi jx jy jz mj kb kc kd mk kf kg kh ig bi translated">现在我们已经完成了处理EC2自动扩展部署的脚本，剩下的就是将它连接到您当前的系统，并在您需要新部署时调用它。</p><p id="e30a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所有代码都可以在<a class="ae my" href="https://github.com/Abhay3008/Automatic-resource-allocation" rel="noopener ugc nofollow" target="_blank"> github </a>上获得。</p><p id="09c3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一定要鼓掌！！</p></div></div>    
</body>
</html>