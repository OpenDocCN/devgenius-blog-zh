<html>
<head>
<title>Kotlin Flows -What, Why and How?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">科特林流-什么，为什么和如何？</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/kotlin-flows-what-why-and-how-e9054327f795?source=collection_archive---------2-----------------------#2022-06-30">https://blog.devgenius.io/kotlin-flows-what-why-and-how-e9054327f795?source=collection_archive---------2-----------------------#2022-06-30</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><blockquote class="jk jl jm"><p id="0238" class="jn jo jp jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ig bi translated">随波逐流吧！！</p></blockquote><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/1d814888d9b8db3337ef0ee81d1a4a48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*rVZ3X1XN95poHckA.jpg"/></div></div></figure><p id="3136" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ky ka kb kc kz ke kf kg la ki kj kk kl ig bi translated">作为一名 Android 开发人员，我们无法逃脱周围的协同程序。说到协程，我们经常会遇到另一个问题，在 kotlin 中我们称之为<strong class="jq io"> <em class="jp">流</em> </strong>。听起来很酷，但它的功能确实如此。所以为什么不从基础开始探索和了解这些酷的科特林流呢？</p><p id="4599" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ky ka kb kc kz ke kf kg la ki kj kk kl ig bi translated">在本文中，我们将尝试回答以下关于科特林流的问题</p><ul class=""><li id="4a19" class="lb lc in jq b jr js jv jw ky ld kz le la lf kl lg lh li lj bi translated">什么是心流，它们有什么作用？</li><li id="f29a" class="lb lc in jq b jr lk jv ll ky lm kz ln la lo kl lg lh li lj bi translated">我们为什么要使用它们？</li><li id="0b47" class="lb lc in jq b jr lk jv ll ky lm kz ln la lo kl lg lh li lj bi translated">我们应该如何使用它们？</li><li id="9389" class="lb lc in jq b jr lk jv ll ky lm kz ln la lo kl lg lh li lj bi translated">取消基础</li><li id="9edc" class="lb lc in jq b jr lk jv ll ky lm kz ln la lo kl lg lh li lj bi translated">流程转换</li></ul><blockquote class="jk jl jm"><p id="a3ca" class="jn jo jp jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ig bi translated">如果你还没有开始，是时候开始了！</p></blockquote></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><h2 id="6971" class="lw lx in bd ly lz ma dn mb mc md dp me ky mf mg mh kz mi mj mk la ml mm mn mo bi translated">什么是心流，它们有什么作用？</h2><p id="f801" class="pw-post-body-paragraph jn jo in jq b jr mp jt ju jv mq jx jy ky mr kb kc kz ms kf kg la mt kj kk kl ig bi translated">流动基本上是一些值序列的发射。是的，这就是花。就像我们有生活数据，我们有流动。虽然有一些差异我们不会在这里讨论，但是你可以开始理解心流是如何工作的。</p><p id="33fb" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ky ka kb kc kz ke kf kg la ki kj kk kl ig bi translated">考虑这样一个场景，我们希望在不阻塞主线程的情况下，在一些计算之后，一个接一个地打印一些接收到的值序列。让我们看看如何才能实现它。</p><p id="cb83" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ky ka kb kc kz ke kf kg la ki kj kk kl ig bi translated"><strong class="jq io"> <em class="jp">带常规功能</em> </strong></p><p id="f36e" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ky ka kb kc kz ke kf kg la ki kj kk kl ig bi translated">函数返回一个整数列表，我们立刻得到输出，这是同步的。所以这不能完全满足我们的需要。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="f48e" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ky ka kb kc kz ke kf kg la ki kj kk kl ig bi translated"><strong class="jq io"> <em class="jp">同</em> </strong></p><p id="5cbe" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ky ka kb kc kz ke kf kg la ki kj kk kl ig bi translated">我们修改示例函数以返回一个序列，每个值等待 1。这里我们看到，在输出中，所有的值都打印出来后，输出了"<em class="jp"> main end" </em>。这意味着这也是同步的，我们必须寻找另一个工作。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="95dc" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ky ka kb kc kz ke kf kg la ki kj kk kl ig bi translated"><strong class="jq io"> <em class="jp">带暂停功能</em> </strong></p><p id="0df6" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ky ka kb kc kz ke kf kg la ki kj kk kl ig bi translated">挂起函数也是常规函数，它在协程范围内顺序操作，直到被提供挂起计算。所以即使这样也帮不了我们。</p><p id="3f25" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ky ka kb kc kz ke kf kg la ki kj kk kl ig bi translated"><strong class="jq io"> <em class="jp">同</em> </strong></p><p id="7199" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ky ka kb kc kz ke kf kg la ki kj kk kl ig bi translated">现在我们修改我们的<em class="jp"> example() </em>函数来给出一个流。在输出中，我们看到“<em class="jp"> main end </em>”在 flow 收集它的值之前打印出来，这表明 flow 没有阻塞我们的主线程并异步运行。</p><p id="c14a" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ky ka kb kc kz ke kf kg la ki kj kk kl ig bi translated">此外，我们注意到，现在<em class="jp"> example() </em>函数不是一个挂起函数，它立即返回，我们继续以异步方式收集流。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="6966" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ky ka kb kc kz ke kf kg la ki kj kk kl ig bi translated">这就是流量的用处。它们为我们提供了对异步值流支持。在本文的后面，我们将看到如何利用流做更多的事情。</p></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><h2 id="3007" class="lw lx in bd ly lz ma dn mb mc md dp me ky mf mg mh kz mi mj mk la ml mm mn mo bi translated">我们为什么要使用它们？</h2><p id="4c17" class="pw-post-body-paragraph jn jo in jq b jr mp jt ju jv mq jx jy ky mr kb kc kz ms kf kg la mt kj kk kl ig bi translated">我们可以在许多场景中使用流，特别是当我们有一些后台任务正在进行，并且它根据任务的一些状态发出一些数据，并且我们需要对这些状态做出反应时。</p><p id="2e86" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ky ka kb kc kz ke kf kg la ki kj kk kl ig bi translated">它们可能有用的几个场景如下:</p><p id="48f2" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ky ka kb kc kz ke kf kg la ki kj kk kl ig bi translated"><strong class="jq io"> <em class="jp">用况</em> </strong></p><p id="32bc" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ky ka kb kc kz ke kf kg la ki kj kk kl ig bi translated">考虑进行一个 api 调用，其中我们的 UI 根据 api 调用的响应进行更新，即我们收到一个错误或成功，或者 api 调用已经开始，我们需要显示一些加载的 UI。我们这里有三个不同的状态要捕捉，所以 flow 是一个很好的选择。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="a2f9" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ky ka kb kc kz ke kf kg la ki kj kk kl ig bi translated"><strong class="jq io"> <em class="jp">在流式 API 中</em> </strong></p><p id="67d3" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ky ka kb kc kz ke kf kg la ki kj kk kl ig bi translated">如果我们使用一些流式 API，并且需要经常捕获事件，那么在这种情况下，flow 就可以派上用场。</p><p id="6841" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ky ka kb kc kz ke kf kg la ki kj kk kl ig bi translated"><strong class="jq io"> <em class="jp">为事件或数据状态</em> </strong></p><p id="8568" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ky ka kb kc kz ke kf kg la ki kj kk kl ig bi translated">像 MutableSharedFlow、MutableStateFlow 这样的流类型可以分别用于 UI 的事件和状态更新。</p></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><h2 id="fe51" class="lw lx in bd ly lz ma dn mb mc md dp me ky mf mg mh kz mi mj mk la ml mm mn mo bi translated">我们应该如何使用它们？</h2><p id="b0bb" class="pw-post-body-paragraph jn jo in jq b jr mp jt ju jv mq jx jy ky mr kb kc kz ms kf kg la mt kj kk kl ig bi translated">到目前为止，我们已经对流动的内容和原因有了一些基本的了解。现在让我们来了解一下流的'<em class="jp">'如何'</em>。</p><p id="ffe5" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ky ka kb kc kz ke kf kg la ki kj kk kl ig bi translated">首先如何使用流量。嗯！通过简单地在流构建器中编写代码，或者通过使用<strong class="jq io"> <em class="jp"> asFlow() </em> </strong>转换任何集合/序列。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="62e9" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ky ka kb kc kz ke kf kg la ki kj kk kl ig bi translated">是的，就这么简单。请注意，该函数没有被挂起。这意味着函数通过给我们一个操作流来立即返回。</p><p id="b299" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ky ka kb kc kz ke kf kg la ki kj kk kl ig bi translated">有趣且重要的一点是，流只有在被收集后才开始执行，也就是说，在我们为流设置收集器之前，它们不会开始执行。</p><blockquote class="jk jl jm"><p id="6677" class="jn jo jp jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ig bi translated">这就是为什么流动是冷流。</p></blockquote><p id="9b69" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ky ka kb kc kz ke kf kg la ki kj kk kl ig bi translated">如果我们收集流量两次，那么它将再次发出值。考虑下面的代码:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="5a11" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ky ka kb kc kz ke kf kg la ki kj kk kl ig bi translated">它的输出是:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="d792" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ky ka kb kc kz ke kf kg la ki kj kk kl ig bi translated">耶！太酷了。让我们继续前进。</p></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><h2 id="fb76" class="lw lx in bd ly lz ma dn mb mc md dp me ky mf mg mh kz mi mj mk la ml mm mn mo bi translated">取消基础</h2><p id="7631" class="pw-post-body-paragraph jn jo in jq b jr mp jt ju jv mq jx jy ky mr kb kc kz ms kf kg la mt kj kk kl ig bi translated">我们知道协同程序遵循合作取消。以同样的方式流动也坚持合作取消。</p><blockquote class="jk jl jm"><p id="15d5" class="jn jo jp jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ig bi translated">如果您不了解协程的基础知识，那么请阅读这里的<a class="ae mw" rel="noopener ugc nofollow" target="_blank" href="/kotlin-coroutines-what-why-how-99529c951a2e">和这里的</a>和<a class="ae mw" rel="noopener ugc nofollow" target="_blank" href="/kotlin-coroutines-job-and-timeout-d7b8c5416d69">您不会失望的。</a></p></blockquote><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="bd1f" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ky ka kb kc kz ke kf kg la ki kj kk kl ig bi translated">正如我们所看到的，一旦时间到了，流不会发出值，我们在时间限制内只能得到一个值。</p></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><h2 id="0d31" class="lw lx in bd ly lz ma dn mb mc md dp me ky mf mg mh kz mi mj mk la ml mm mn mo bi translated">流程转换</h2><p id="be97" class="pw-post-body-paragraph jn jo in jq b jr mp jt ju jv mq jx jy ky mr kb kc kz ms kf kg la mt kj kk kl ig bi translated">可以使用操作符来转换流，就像我们对集合和序列所做的那样。这些运算符应用于上游流并返回下游流。这些操作符是冰冷的，就像流量一样。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="6257" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ky ka kb kc kz ke kf kg la ki kj kk kl ig bi translated">考虑这个例子，流发出 10 个值，但是在上游使用操作符，我们创建了一个新的下游。</p><ul class=""><li id="6d9e" class="lb lc in jq b jr js jv jw ky ld kz le la lf kl lg lh li lj bi translated">筛选运算符筛选出值。</li><li id="1f5f" class="lb lc in jq b jr lk jv ll ky lm kz ln la lo kl lg lh li lj bi translated">Map 运算符将 int 值转换为延迟 1 秒的字符串值。</li><li id="da8a" class="lb lc in jq b jr lk jv ll ky lm kz ln la lo kl lg lh li lj bi translated">然后最后收集打印结果。</li></ul><p id="a3a3" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ky ka kb kc kz ke kf kg la ki kj kk kl ig bi translated">这里需要注意的一件重要事情是，操作符是针对每个发出的值顺序执行的。</p><p id="114c" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ky ka kb kc kz ke kf kg la ki kj kk kl ig bi translated">你可以寻找更多的操作符来从一个给定的流中创建新的流，这就是流转换的含义。</p></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><p id="b2f3" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ky ka kb kc kz ke kf kg la ki kj kk kl ig bi translated">哇哦。现在我们对 kotlin 中的流有了一些更好的理解，是时候开始学习流了。我们将在以后的文章中讨论更多关于流的内容，但是现在这已经足够了。</p><blockquote class="jk jl jm"><p id="7c8b" class="jn jo jp jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ig bi translated">如果你想了解协程的基础知识，请查看我的文章<a class="ae mw" rel="noopener ugc nofollow" target="_blank" href="/kotlin-coroutines-what-why-how-99529c951a2e">这里</a>和<a class="ae mw" rel="noopener ugc nofollow" target="_blank" href="/kotlin-coroutines-job-and-timeout-d7b8c5416d69">这里</a>。</p></blockquote><p id="2ae7" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ky ka kb kc kz ke kf kg la ki kj kk kl ig bi translated">目前就这些了！敬请期待！</p><p id="ffd0" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ky ka kb kc kz ke kf kg la ki kj kk kl ig bi translated">通过 medium(如果内容对您有帮助)或<a class="ae mw" href="https://github.com/aqua30" rel="noopener ugc nofollow" target="_blank"> github </a>与我联系，并订阅电子邮件以同步了解更多关于 Android 的有趣话题。</p><p id="8076" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ky ka kb kc kz ke kf kg la ki kj kk kl ig bi translated">直到下一次…</p><p id="526b" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ky ka kb kc kz ke kf kg la ki kj kk kl ig bi translated">干杯！</p></div></div>    
</body>
</html>