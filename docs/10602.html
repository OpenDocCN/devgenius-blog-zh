<html>
<head>
<title>Working with Matrix in Python — Cheatsheet</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在 Python 中使用矩阵 Cheatsheet</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/working-with-matrix-in-python-cheatsheet-2654835d9dc7?source=collection_archive---------2-----------------------#2022-11-15">https://blog.devgenius.io/working-with-matrix-in-python-cheatsheet-2654835d9dc7?source=collection_archive---------2-----------------------#2022-11-15</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/53f0536e7e6ca75c0dea8f9385e7b4a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vctj1NqTlevzDVSs0GLszw.jpeg"/></div></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk translated">照片由<a class="ae ja" href="https://unsplash.com/@vlado?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">弗拉多·帕诺维奇</a>在<a class="ae ja" href="https://unsplash.com/s/photos/matrix?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><div class=""/><p id="1c20" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">理解矩阵运算。</p><p id="a4d1" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">矩阵是一个二维数组。矩阵通常用来表示一个图(邻接矩阵)或动态编程状态。矩阵也用于模拟游戏，如井字游戏、数独、纵横字谜、战舰等。</p><p id="c6d3" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们可以用 python 生成一个全零的 m * n 矩阵，如下所示:</p><p id="14cb" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe ky kz la lb b">matrix = [[0 for _ in range(n)] for _ in range(m)]</code></p><h2 id="f810" class="lc ld jd bd le lf lg dn lh li lj dp lk kl ll lm ln kp lo lp lq kt lr ls lt lu bi translated">矩阵的遍历</h2><figure class="lw lx ly lz gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi lv"><img src="../Images/c293be1a9561ea37208c1afd9b64dcfa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5zwDl5Cr8wdeGsFHCAZEow.png"/></div></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk translated">矩阵属性—行、列、对角线</figcaption></figure><p id="fa51" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">下面的代码描述了遍历矩阵的逻辑。</p><pre class="lw lx ly lz gt ma lb mb bn mc md bi"><span id="bddf" class="me ld jd lb b be mf mg l mh mi">matrix = [<br/>    ['a', 'b', 'c', 'd'], <br/>    ['e', 'f', 'g', 'h'], <br/>    ['i', 'j', 'k', 'l'], <br/>    ['m', 'n', 'o', 'p']<br/>    ]<br/><br/>m, n = len(matrix), len(matrix[0]) # get matrix size<br/><br/>for i in range(m): # iterate through rows<br/>    print(f"Row No:=====&gt; {i}")<br/>    for j in range(n): # iterate through cols<br/>        print(f"\t Col No {j}")</span></pre><h2 id="d097" class="lc ld jd bd le lf lg dn lh li lj dp lk kl ll lm ln kp lo lp lq kt lr ls lt lu bi translated">按列遍历</h2><pre class="lw lx ly lz gt ma lb mb bn mc md bi"><span id="dff9" class="me ld jd lb b be mf mg l mh mi">matrix = [<br/>    [1, 2, 3, 4], <br/>    [5, 6, 7, 8], <br/>    [9, 10, 11, 12], <br/>    [13, 14, 15, 16]<br/>    ]<br/><br/>for col in zip(*matrix):<br/>    print(*col)<br/>    <br/># alternative<br/><br/>m, n = len(matrix), len(matrix[0])<br/>for col in range(n):<br/>    for row in range(m):<br/>        print(matrix[row][col], end=' ')<br/>    print()</span></pre><p id="92b2" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><a class="ae ja" href="https://leetcode.com/problems/check-if-every-row-and-column-contains-all-numbers" rel="noopener ugc nofollow" target="_blank">检查所有行和列中的所有数字是否都存在</a></p><h2 id="a42f" class="lc ld jd bd le lf lg dn lh li lj dp lk kl ll lm ln kp lo lp lq kt lr ls lt lu bi translated">遍历像元的邻居</h2><figure class="lw lx ly lz gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi mj"><img src="../Images/7da16841feec7e007fdfbe11f9ff498d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yE8HaJqnScBtPZyjukBSGg.png"/></div></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk translated">矩阵从一个单元向不同方向移动</figcaption></figure><p id="a39f" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">下面的代码描述了遍历相邻单元格的代码。</p><pre class="lw lx ly lz gt ma lb mb bn mc md bi"><span id="e4c7" class="me ld jd lb b be mf mg l mh mi">matrix = [<br/>    ['a', 'b', 'c', 'd'], <br/>    ['e', 'f', 'g', 'h'], <br/>    ['i', 'j', 'k', 'l'], <br/>    ['m', 'n', 'o', 'p']<br/>    ]<br/><br/>row, col = (1, 2)  # current position<br/>directions = [<br/>    (0, 1), # right<br/>    (1, 1), # right down<br/>    (1, 0), # down<br/>    (1, -1), # down left<br/>    (0, -1), # left<br/>    (-1, -1), # left up<br/>    (-1, 0), # up<br/>    (-1, 1) # right, up<br/>    ]<br/>print(f"Current cell: {matrix[row][col]}")<br/><br/>for dx, dy in directions:<br/>    new_row, new_col = row + dx, col + dy<br/>    if 0 &lt;= new_row &lt; m and 0&lt;=new_col&lt;n: # boundary check<br/>        print(f"New Pos {(new_row, new_col)}: {matrix[new_row][new_col]}")</span></pre><p id="dd77" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><a class="ae ja" href="https://leetcode.com/problems/largest-local-values-in-a-matrix" rel="noopener ugc nofollow" target="_blank">矩阵中的最大局部值</a> <br/> <a class="ae ja" href="https://leetcode.com/problems/special-positions-in-a-binary-matrix" rel="noopener ugc nofollow" target="_blank">二进制矩阵中的特殊位置</a> <br/> <a class="ae ja" href="https://leetcode.com/problems/lucky-numbers-in-a-matrix" rel="noopener ugc nofollow" target="_blank">矩阵中的幸运数字</a> <br/> <a class="ae ja" href="https://leetcode.com/problems/image-smoother" rel="noopener ugc nofollow" target="_blank">图像更平滑</a></p><h2 id="8fee" class="lc ld jd bd le lf lg dn lh li lj dp lk kl ll lm ln kp lo lp lq kt lr ls lt lu bi translated">矩阵的对角单元</h2><figure class="lw lx ly lz gt ip gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/d128e242072d3ee2eeaba6d35e9d515c.png" data-original-src="https://miro.medium.com/v2/resize:fit:846/format:webp/1*UGrFXYbpJzgJjPIfphsexw.png"/></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk translated">对角遍历</figcaption></figure><p id="c3e6" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">矩阵中的对角元素满足以下两个约束之一</p><p id="f065" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe ky kz la lb b">1. i == j 2. j == n-i-1</code></p><pre class="lw lx ly lz gt ma lb mb bn mc md bi"><span id="70b4" class="me ld jd lb b be mf mg l mh mi">matrix = [<br/>    [1, 2, 3, 4], <br/>    [5, 6, 7, 8], <br/>    [9, 10, 11, 12], <br/>    [13, 14, 15, 16]<br/>    ]<br/><br/>m, n = len(matrix), len(matrix[0])<br/>for i in range(m):<br/>    for j in range(n):<br/>        if j == i or j == n-i-1:<br/>            print(matrix[i][j])</span></pre><p id="e580" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><a class="ae ja" href="https://leetcode.com/problems/check-if-matrix-is-x-matrix/" rel="noopener ugc nofollow" target="_blank"> X 矩阵</a></p><h2 id="d534" class="lc ld jd bd le lf lg dn lh li lj dp lk kl ll lm ln kp lo lp lq kt lr ls lt lu bi translated">最大的魔方</h2><p id="2889" class="pw-post-body-paragraph ka kb jd kc b kd ml kf kg kh mm kj kk kl mn kn ko kp mo kr ks kt mp kv kw kx ig bi translated">一个<code class="fe ky kz la lb b">k x k</code> <strong class="kc je">幻方</strong>是一个填充了整数的<code class="fe ky kz la lb b">k x k</code>网格，使得每行总和、每列总和以及两个对角线总和<strong class="kc je">都等于</strong>。魔方<strong class="kc je">中的整数不必是不同的</strong>。每一个<code class="fe ky kz la lb b">1 x 1</code>格子都是一个<strong class="kc je">魔方</strong>。</p><p id="c70b" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">给定一个<code class="fe ky kz la lb b">m x n</code>整数<code class="fe ky kz la lb b">grid</code>，返回<em class="mq">在此网格</em>内可以找到的 <strong class="kc je"> <em class="mq">最大魔方</em> </strong> <em class="mq">的</em><strong class="kc je"><em class="mq"/></strong><em class="mq">(即边长</em> <code class="fe ky kz la lb b">k</code> <em class="mq">)。</em></p><pre class="lw lx ly lz gt ma lb mb bn mc md bi"><span id="4b15" class="me ld jd lb b be mf mg l mh mi">class Solution:<br/>    def largestMagicSquare(self, grid: List[List[int]]) -&gt; int:<br/>        m, n = len(grid), len(grid[0])<br/>        size = min(m, n)<br/>        for k in range(size, 0, -1):<br/>            for i in range(m-k+1):<br/>                for j in range(n-k+1):<br/>                    if self.is_magic_square(grid, i, j, k):<br/>                        return k<br/><br/>    def is_magic_square(self, grid, x, y, k):<br/>        diag_sum, anti_diag_sum  = 0, 0<br/>        for i in range(k):<br/>            diag_sum += grid[x+i][y+i]<br/>            anti_diag_sum += grid[x+i][y+k-i-1]<br/>        if diag_sum != anti_diag_sum:<br/>            return False<br/><br/>        for i in range(k):<br/>            row_sum = sum(grid[x+i][y:y+k])<br/>            if row_sum != diag_sum:<br/>                return False<br/>            col_sum = sum((grid[x+j][y+i] for j in range(k)))<br/>            if col_sum != diag_sum:<br/>                return False<br/>        return True</span></pre><p id="28b2" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">注意:上述解决方案可以通过使用前缀 sum 进行优化。因为这个博客是关于矩阵的，所以我把它留在这里。阅读我的另一篇解释前缀总和的博客。</p><h2 id="06c7" class="lc ld jd bd le lf lg dn lh li lj dp lk kl ll lm ln kp lo lp lq kt lr ls lt lu bi translated">对列表进行模运算以生成矩阵</h2><figure class="lw lx ly lz gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi mr"><img src="../Images/fa1075b900c0f5c881c9c2943cfff900.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VJJvuPhl7TgmetuUmgH86g.png"/></div></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk translated">矩阵扁平化</figcaption></figure><p id="17dd" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">以下代码描述了从展平矩阵创建 m * n 维矩阵的代码。</p><pre class="lw lx ly lz gt ma lb mb bn mc md bi"><span id="6601" class="me ld jd lb b be mf mg l mh mi">flattened = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]<br/>print(f"Flattened :\n{flattened}")<br/><br/>m, n = 3, 5<br/><br/>matrix = [['' for _ in range(n)] for _ in range(m)]<br/><br/>for idx, val in enumerate(flattened):<br/>    row, col = divmod(idx, n)<br/>    matrix[row][col] = val<br/><br/>print(f"Matrix:\n{matrix}")</span></pre><p id="7024" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><a class="ae ja" href="https://leetcode.com/problems/convert-1d-array-into-2d-array" rel="noopener ugc nofollow" target="_blank">将 1D 转换为 2D 阵列</a></p><h2 id="162e" class="lc ld jd bd le lf lg dn lh li lj dp lk kl ll lm ln kp lo lp lq kt lr ls lt lu bi translated">螺旋矩阵</h2><p id="3882" class="pw-post-body-paragraph ka kb jd kc b kd ml kf kg kh mm kj kk kl mn kn ko kp mo kr ks kt mp kv kw kx ig bi translated">给定一个<code class="fe ky kz la lb b">m x n</code> <code class="fe ky kz la lb b">matrix</code>，按照螺旋顺序返回 <code class="fe ky kz la lb b">matrix</code> <em class="mq">的所有元素<em class="mq">。</em></em></p><pre class="lw lx ly lz gt ma lb mb bn mc md bi"><span id="89c1" class="me ld jd lb b be mf mg l mh mi">class Solution:<br/>    def generateMatrix(self, n: int) -&gt; List[List[int]]:<br/>        res = [[0]*n  for i in range(n)]<br/>        top, bottom, left, right = 0, n-1, 0, n-1<br/>        move=1<br/>        elem = 1<br/>        <br/>        while left &lt;= right and top &lt;= bottom:<br/>            if move==1:<br/>                for i in range(left, right+1):<br/>                    res[top][i] = elem<br/>                    elem += 1<br/>                top += 1<br/>                <br/>            elif move==2:<br/>                for i in range(top, bottom + 1):<br/>                    res[i][right] = elem<br/>                    elem += 1<br/>                right -= 1<br/>            elif move==3:<br/>                for i in range(right, left-1, -1):<br/>                    res[bottom][i] = elem<br/>                    elem += 1<br/>                bottom -= 1<br/>            else:<br/>                for i in range(bottom, top-1, -1):<br/>                    res[i][left] = elem<br/>                    elem += 1<br/>                left += 1;<br/>            move += 1;<br/>            <br/>            move=move%4<br/>    <br/>        return res</span></pre><h2 id="e039" class="lc ld jd bd le lf lg dn lh li lj dp lk kl ll lm ln kp lo lp lq kt lr ls lt lu bi translated">转置矩阵</h2><p id="6760" class="pw-post-body-paragraph ka kb jd kc b kd ml kf kg kh mm kj kk kl mn kn ko kp mo kr ks kt mp kv kw kx ig bi translated">矩阵的转置是通过将矩阵的行交换成列或者将列交换成行来实现的。</p><figure class="lw lx ly lz gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi ms"><img src="../Images/bf484bd3ac1b39fef8f51ef7b823ed6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E8JGHgJPOKEvjGy2B6oHhg.png"/></div></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk translated">矩阵转置</figcaption></figure><p id="6c47" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">下面的代码描述了转置矩阵的逻辑。</p><pre class="lw lx ly lz gt ma lb mb bn mc md bi"><span id="112a" class="me ld jd lb b be mf mg l mh mi">matrix = [<br/>    ['a', 'b', 'c', 'd'], <br/>    ['e', 'f', 'g', 'h'], <br/>    ['i', 'j', 'k', 'l'], <br/>    ['m', 'n', 'o', 'p']<br/>    ]<br/><br/>print(f"Current Matrix:\n{matrix}")<br/><br/>transpose = []<br/><br/>for row in zip(*matrix):<br/>    transpose.append(list(row))<br/><br/>print(f"Transposed Matrix:\n{transpose}")</span></pre><h2 id="7718" class="lc ld jd bd le lf lg dn lh li lj dp lk kl ll lm ln kp lo lp lq kt lr ls lt lu bi translated">顺时针旋转矩阵 90 度</h2><figure class="lw lx ly lz gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi mt"><img src="../Images/5515be36d6b86469c60804ad224da2bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L6kjamVq4WK1xpq1cH5U6w.png"/></div></div></figure><p id="f0cc" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">下面的代码描述了顺时针旋转矩阵 90 度的逻辑。为此，我们转置并沿着转置矩阵的中间翻转列值。</p><pre class="lw lx ly lz gt ma lb mb bn mc md bi"><span id="a947" class="me ld jd lb b be mf mg l mh mi">matrix = [<br/>    ['a', 'b', 'c', 'd'], <br/>    ['e', 'f', 'g', 'h'], <br/>    ['i', 'j', 'k', 'l'], <br/>    ['m', 'n', 'o', 'p']<br/>    ]<br/><br/>print(f"Current Matrix:\n{matrix}")<br/><br/>transpose = []<br/><br/>for row in zip(*matrix):<br/>    transpose.append(list(row))<br/><br/>print(f"Transposed Matrix:\n{transpose}")<br/><br/>m, n = len(transpose), len(transpose[0])<br/><br/>for i in range(m):<br/>    for j in range(n//2):<br/>        transpose[i][j], transpose[i][n-j-1] = transpose[i][n-j-1], transpose[i][j]<br/><br/>print(f"Flipped Matrix:\n{transpose}")</span></pre><p id="fc97" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><a class="ae ja" href="https://leetcode.com/problems/determine-whether-matrix-can-be-obtained-by-rotation" rel="noopener ugc nofollow" target="_blank">检查是否可以通过旋转获得矩阵</a></p><h2 id="2549" class="lc ld jd bd le lf lg dn lh li lj dp lk kl ll lm ln kp lo lp lq kt lr ls lt lu bi translated">最左边至少有一个 1 的列</h2><p id="0d39" class="pw-post-body-paragraph ka kb jd kc b kd ml kf kg kh mm kj kk kl mn kn ko kp mo kr ks kt mp kv kw kx ig bi translated"><strong class="kc je">按行排序的二进制矩阵</strong>意味着所有元素都是<code class="fe ky kz la lb b">0</code>或<code class="fe ky kz la lb b">1</code>，矩阵的每一行都按非降序排序。</p><p id="8096" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">给定一个<strong class="kc je">行排序的二进制矩阵</strong> <code class="fe ky kz la lb b">binaryMatrix</code>，返回<em class="mq">最左边</em> <strong class="kc je"> <em class="mq">列</em> </strong> <em class="mq">的索引(0 索引)，其中</em>为 1。如果这样的索引不存在，返回<code class="fe ky kz la lb b">-1</code>。</p><p id="fdc0" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">用不到一维的乘积解决这个问题。</p><pre class="lw lx ly lz gt ma lb mb bn mc md bi"><span id="a57b" class="me ld jd lb b be mf mg l mh mi">class Solution:<br/>    def leftMostColumnWithOne(self, binaryMatrix: 'BinaryMatrix') -&gt; int:<br/>        rows, cols = binaryMatrix.dimensions()<br/>        <br/>        current_row = 0<br/>        current_col = cols - 1<br/>        <br/>        while current_row &lt; rows and current_col &gt;= 0:<br/>            if binaryMatrix.get(current_row, current_col) == 0:<br/>                current_row += 1<br/>            else:<br/>                current_col -= 1<br/><br/>        return current_col + 1 if current_col != cols - 1 else -1</span></pre><p id="19ba" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><a class="ae ja" href="https://leetcode.com/problems/available-captures-for-rook" rel="noopener ugc nofollow" target="_blank">车可用的捕获</a></p><p id="9f7a" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在一个<code class="fe ky kz la lb b">8 x 8</code>棋盘上，有<strong class="kc je">正好一个</strong>白车<code class="fe ky kz la lb b">'R'</code>和一些白象<code class="fe ky kz la lb b">'B'</code>，黑卒<code class="fe ky kz la lb b">'p'</code>，以及空方格<code class="fe ky kz la lb b">'.'</code>。</p><p id="c06a" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当车移动时，它选择四个基本方向中的一个(北、东、南或西)，然后朝那个方向移动，直到它选择停止，到达棋盘边缘，抓住一个黑色棋子，或被一个白色主教阻挡。如果一辆车在它的回合中可以抓住一个兵，那么它被认为是在攻击一个兵。白车可用的<strong class="kc je">数量</strong>是白车正在<strong class="kc je">攻击</strong>的兵的数量。</p><p id="28ab" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">返回<em class="mq">白车</em>可用的  <em class="mq">数量的</em> <strong class="kc je"> <em class="mq">。</em></strong></p><pre class="lw lx ly lz gt ma lb mb bn mc md bi"><span id="ef72" class="me ld jd lb b be mf mg l mh mi">class Solution:<br/>    def numRookCaptures(self, board: List[List[str]]) -&gt; int:<br/>        for i in range(8):<br/>            for j in range(8):<br/>                if board[i][j] == 'R':<br/>                    rook_x, rook_y = i, j<br/>        res = 0<br/>        for dx, dy in [(1, 0), (0, 1), (-1, 0), (0, -1)]:<br/>            x, y = rook_x + dx, rook_y + dy<br/>            while 0 &lt;= x &lt; 8 and 0 &lt;= y &lt; 8:<br/>                if board[x][y] == 'p': <br/>                    res += 1<br/>                if board[x][y] != '.': <br/>                    break<br/>                x, y = x + dx, y + dy<br/>        return res</span></pre><p id="2205" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><a class="ae ja" href="https://leetcode.com/problems/surface-area-of-3d-shapes" rel="noopener ugc nofollow" target="_blank">三维形状的表面积</a></p><p id="b1ff" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">给你一个<code class="fe ky kz la lb b">n x n</code> <code class="fe ky kz la lb b">grid</code>，在那里你放置了一些<code class="fe ky kz la lb b">1 x 1 x 1</code>立方体。每个值<code class="fe ky kz la lb b">v = grid[i][j]</code>代表放置在单元格<code class="fe ky kz la lb b">(i, j)</code>顶部的<code class="fe ky kz la lb b">v</code>立方体塔。</p><p id="68c4" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">放置这些立方体后，您决定将任何直接相邻的立方体相互粘合，形成几个不规则的 3D 形状。</p><p id="e558" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">返回<em class="mq">最终形状的总表面积</em>。</p><p id="5962" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc je">注:</strong>每个形状的底面计入其表面积。</p><pre class="lw lx ly lz gt ma lb mb bn mc md bi"><span id="9273" class="me ld jd lb b be mf mg l mh mi">class Solution:<br/>    def surfaceArea(self, grid: List[List[int]]) -&gt; int:<br/>        l = len(grid)<br/>        area = 0<br/>        for row in range(l):<br/>            for col in range(l):<br/>                if grid[row][col]:<br/>                    area += (grid[row][col]*4) +2 <br/>                if row:<br/>                    area -= min(grid[row][col],grid[row-1][col])*2 <br/>                if col:<br/>                    area -= min(grid[row][col],grid[row][col-1])*2 <br/>        return area</span></pre><h2 id="1ee8" class="lc ld jd bd le lf lg dn lh li lj dp lk kl ll lm ln kp lo lp lq kt lr ls lt lu bi translated">合计到目标的子矩阵的数量</h2><p id="a300" class="pw-post-body-paragraph ka kb jd kc b kd ml kf kg kh mm kj kk kl mn kn ko kp mo kr ks kt mp kv kw kx ig bi translated">给定一个<code class="fe ky kz la lb b">matrix</code>和一个<code class="fe ky kz la lb b">target</code>，返回总和为 target 的非空子矩阵的数量。</p><p id="a4fd" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">子矩阵<code class="fe ky kz la lb b">x1, y1, x2, y2</code>是具有<code class="fe ky kz la lb b">x1 &lt;= x &lt;= x2</code>和<code class="fe ky kz la lb b">y1 &lt;= y &lt;= y2</code>的所有单元<code class="fe ky kz la lb b">matrix[x][y]</code>的集合。</p><p id="1465" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果两个子矩阵<code class="fe ky kz la lb b">(x1, y1, x2, y2)</code>和<code class="fe ky kz la lb b">(x1', y1', x2', y2')</code>具有不同的坐标，则它们是不同的:例如，如果<code class="fe ky kz la lb b">x1 != x1'</code>。</p><pre class="lw lx ly lz gt ma lb mb bn mc md bi"><span id="fcc0" class="me ld jd lb b be mf mg l mh mi">from collections import defaultdict<br/>class Solution:<br/>    def numSubmatrixSumTarget(self, matrix: List[List[int]], target: int) -&gt; int:<br/>        r, c = len(matrix), len(matrix[0])<br/><br/>        ps = [[0] * (c + 1) for _ in range(r + 1)]<br/>        for i in range(1, r + 1):<br/>            for j in range(1, c + 1):<br/>                ps[i][j] = ps[i - 1][j] + ps[i][j - 1] - ps[i - 1][j - 1] + matrix[i - 1][j - 1]<br/>        <br/>        count = 0<br/><br/>        for r1 in range(1, r + 1):<br/>            for r2 in range(r1, r + 1):<br/>                h = defaultdict(int)<br/>                h[0] = 1<br/>                <br/>                for col in range(1, c + 1):<br/>                    curr_sum = ps[r2][col] - ps[r1 - 1][col]<br/>                    count += h[curr_sum - target]<br/>                    h[curr_sum] += 1<br/>        return count</span></pre><h2 id="b728" class="lc ld jd bd le lf lg dn lh li lj dp lk kl ll lm ln kp lo lp lq kt lr ls lt lu bi translated">矩阵要验证的拐角情况:</h2><ul class=""><li id="f279" class="mu mv jd kc b kd ml kh mm kl mw kp mx kt my kx mz na nb nc bi translated">空矩阵。检查所有数组的长度都不是 0</li><li id="8de8" class="mu mv jd kc b kd nd kh ne kl nf kp ng kt nh kx mz na nb nc bi translated">1 x 1 矩阵</li><li id="e896" class="mu mv jd kc b kd nd kh ne kl nf kp ng kt nh kx mz na nb nc bi translated">只有一行或一列的矩阵</li></ul><p id="8a0b" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">编码快乐！！</p></div></div>    
</body>
</html>