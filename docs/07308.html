<html>
<head>
<title>Scheduling Execution in PHP</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在 PHP 中调度执行</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/scheduling-execution-in-php-e9e5023b793c?source=collection_archive---------4-----------------------#2022-03-14">https://blog.devgenius.io/scheduling-execution-in-php-e9e5023b793c?source=collection_archive---------4-----------------------#2022-03-14</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/e9188ec549b2e57734c97e4ae752e036.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yvpj7grqUJNnQ3aXowS2-g.jpeg"/></div></div></figure><p id="a7df" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们经常需要在应用程序中安排给定业务功能的执行。时机取决于我们想要达到的目标。它可以是每月执行的发票或用户在网站上注册后发送的通知。在本文中，我们将深入探讨 PHP 中调度执行的不同方式。</p><p id="0d8e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">本文假设了关于<a class="ae kt" href="https://blog.ecotone.tech/cqrs-in-php/" rel="noopener ugc nofollow" target="_blank">命令</a>和<a class="ae kt" href="https://blog.ecotone.tech/event-handling-in-php/" rel="noopener ugc nofollow" target="_blank">事件</a>的基本知识。</p><h1 id="f145" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">计划批处理作业</h1><p id="dcc9" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">最常见的方法是计划批处理作业。<br/>这是一个在特定时间上升的进程，在大多数情况下执行大型数据库查询，获取大部分数据并执行相关操作。</p><blockquote class="lx ly lz"><p id="0228" class="jv jw ma jx b jy jz ka kb kc kd ke kf mb kh ki kj mc kl km kn md kp kq kr ks ig bi translated">在 PHP 世界中，调度批处理作业大多由 Cron 作业实现，它在给定的时间执行进程。</p></blockquote><p id="24d8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">批处理在实现、访问数据库、迭代和执行方面非常简单。<br/>这样我们能实现什么？</p><ul class=""><li id="cf16" class="me mf in jx b jy jz kc kd kg mg kk mh ko mi ks mj mk ml mm bi translated">我们可以获取过去 15 分钟内注册的所有用户，向他们发送欢迎通知。</li><li id="3ec0" class="me mf in jx b jy mn kc mo kg mp kk mq ko mr ks mj mk ml mm bi translated">我们可以获取所有订单来重新计算公司收入统计数据。</li><li id="1420" class="me mf in jx b jy mn kc mo kg mp kk mq ko mr ks mj mk ml mm bi translated">对于一个特定的用户，我们可能有一个在给定日期给他开发票的协议，所以我们会寻找过期的日期来生成它</li></ul><h1 id="4d65" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">计划作业实施</h1><p id="d38d" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">拥有一个系统 cron 作业经常会产生跟踪问题，如果出现问题，需要运行非 PHP 进程。<br/>如果这对你来说有问题，econtero 将计划作业引入 PHP。</p><h1 id="2bf9" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">预定方法</h1><figure class="ms mt mu mv gt jo"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="d6ad" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe my mz na nb b">#[Scheduled]</code>中的<code class="fe my mz na nb b">EndpointId</code>定义了将用于执行过程的名称。<code class="fe my mz na nb b">#[Poller]</code>定义了这个方法应该如何执行。</p><p id="fc37" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">该方法将被安排为每 10 秒执行一次。<br/>流程现在可以运行:</p><pre class="ms mt mu mv gt nc nb nd ne aw nf bi"><span id="a7c1" class="ng kv in nb b gy nh ni l nj nk"># Symfony<br/>bin/console ecotone:run notificationSender -vvv</span><span id="c66e" class="ng kv in nb b gy nl ni l nj nk"># Laravel<br/>artisan ecotone:run notificationSender -vvv</span><span id="a5ac" class="ng kv in nb b gy nl ni l nj nk"># Lite<br/>$messagingSystem-&gt;run("notificationSender");</span></pre><h1 id="89a3" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">预定处理程序</h1><p id="c779" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">您也可以计划执行给定的<code class="fe my mz na nb b">Command Handler</code>。</p><figure class="ms mt mu mv gt jo"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="cd74" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe my mz na nb b">#[Scheduled]</code>的第一个参数表示路由到<code class="fe my mz na nb b">Command Handler</code>。<br/>在本例中，我们设置了 Cron 每分钟执行一次，并调用我们的命令处理程序。</p><h1 id="1db8" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">计划批处理作业的问题</h1><p id="db8c" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">有时，计划的批处理作业可能会出现问题。</p><ul class=""><li id="cef7" class="me mf in jx b jy jz kc kd kg mg kk mh ko mi ks mj mk ml mm bi translated">批处理作业通常会对数据库产生巨大的负载，从而影响系统的最终用户。</li><li id="364b" class="me mf in jx b jy mn kc mo kg mp kk mq ko mr ks mj mk ml mm bi translated">如果批处理作业将在午夜失败怎么办？如果我们能发现并通知它，那么系统的用户是幸运的，然而，开发者可能会有另一个不眠之夜。如果我们的脚本在处理过程中中断，这将变得更加困难。因为我们需要从中恢复，并且只对尚未处理的部分数据运行作业。</li><li id="ec07" class="me mf in jx b jy mn kc mo kg mp kk mq ko mr ks mj mk ml mm bi translated">如果我们想在白天采取行动呢？<br/>我们要么需要增加系统资源，要么同意在此期间可能会影响最终用户。</li></ul><p id="d4da" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以一定有更好的方法，对吗？</p><h1 id="7539" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">信息发送</h1><p id="b871" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">为我们提供了一个坚实稳定的平台来处理此类问题。<br/>它帮助我们构建能够在高负载下良好扩展和运行的应用程序。</p><p id="7be0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">那么什么是<code class="fe my mz na nb b">Message</code>？<br/>消息是一封信，可以通知系统中最近发生的事件，或者命令系统应该执行的动作。</p><p id="d2e8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">使用消息传递，我们一次处理一条消息(一条记录),为了保持系统稳定，我们可以将消息排队，并在准备好的时候处理它们。<br/>这样就解决了超负荷，一次处理多条记录的问题。因为我们可以将消息排队并逐个处理它们。</p><blockquote class="lx ly lz"><p id="71aa" class="jv jw ma jx b jy jz ka kb kc kd ke kf mb kh ki kj mc kl km kn md kp kq kr ks ig bi translated">消息传递为系统提供了更大的稳定性，因为如果我们在特定消息上失败了，我们可以重试该消息或将其提交审查并继续处理其他消息。</p></blockquote><h1 id="17cf" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">静态消息时间表</h1><p id="ac60" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">假设我们想在注册 5 分钟后给新注册的用户发送一个通知。</p><figure class="ms mt mu mv gt jo"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="2989" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">注册后，我们正在发布事件<code class="fe my mz na nb b">UserWasRegistered</code>。现在我们可以异步处理这个事件<a class="ae kt" href="https://docs.ecotone.tech/modelling/asynchronous-handling" rel="noopener ugc nofollow" target="_blank">并延迟执行。</a></p><figure class="ms mt mu mv gt jo"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="9c55" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe my mz na nb b">#[Delayed]</code>以毫秒为单位描述我们希望延迟执行多长时间。</p><blockquote class="lx ly lz"><p id="0988" class="jv jw ma jx b jy jz ka kb kc kd ke kf mb kh ki kj mc kl km kn md kp kq kr ks ig bi translated">生态区向每个事件处理程序传递一个消息的副本。由于这一点，你可以延迟一个处理程序，而立即执行另一个</p></blockquote><h1 id="cd60" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">动态消息时间表</h1><p id="93df" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">如果我们想动态地决定何时执行一个给定的流程，我们可以在发送消息时定义它。</p><p id="ad1d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">假设用户下了订单，如果他要快速发货，我们想推迟 3 天或者 7 天。</p><figure class="ms mt mu mv gt jo"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="4637" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">还有我们的<code class="fe my mz na nb b">Command Handler</code></p><figure class="ms mt mu mv gt jo"><div class="bz fp l di"><div class="mw mx l"/></div></figure><blockquote class="lx ly lz"><p id="3bae" class="jv jw ma jx b jy jz ka kb kc kd ke kf mb kh ki kj mc kl km kn md kp kq kr ks ig bi translated"><em class="in">我们使用异步来存储我们发送的消息。例如，我们可以通过 RabbitMQ 或 DBAL(数据库)来支持它。</em></p></blockquote><h1 id="1652" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">定期消息时间表</h1><p id="096a" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">我们可能还想做一些重复性的动作，比如开发票。在给定的时间周期后执行给定的执行。</p><p id="71fb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们为用户实现发票。<br/>用户注册后，我们将注册第一次尝试生成的发票。<br/>发票生成后，我们将延迟注册另一次尝试。</p><figure class="ms mt mu mv gt jo"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="c74a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在新用户注册后，我们将他加入到流程中。<br/>如果用户将被阻止，那么<code class="fe my mz na nb b">generateInvoice</code>我们可以只做一个返回而不发布事件，给定用户的流程将简单地结束。<br/>这将创建一个消息流，我们将每次为给定的用户生成发票，直到我们决定停止它的那一刻。</p><blockquote class="lx ly lz"><p id="c4bf" class="jv jw ma jx b jy jz ka kb kc kd ke kf mb kh ki kj mc kl km kn md kp kq kr ks ig bi translated">如果您将<code class="fe my mz na nb b">#[Asynchronous]</code>属性放在类的顶部，它将应用于所有的<code class="fe my mz na nb b">Handlers</code>。</p></blockquote><h1 id="0ea7" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">摘要</h1><p id="a65e" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">econtero 为 PHP 带来了一个真正的消息平台。它提供了简单易用的工具，以一种可靠稳定的方式将事物粘合在一起。<br/>消息传递是一个强大的概念，一旦开发人员习惯了这一点，它可以省去许多不眠之夜，尤其是在关键业务组件中。</p><p id="046c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你可以在这里阅读更多关于生态交错带的信息。<br/>如果您想查看以下使用 econtero Lite 的文章的实现，请点击<a class="ae kt" href="https://github.com/ecotoneframework/quickstart-examples/tree/master/Schedule/src" rel="noopener ugc nofollow" target="_blank">这里</a>。</p></div></div>    
</body>
</html>