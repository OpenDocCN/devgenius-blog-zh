<html>
<head>
<title>Real-time Web Updates From Your PostgreSQL Database</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">来自 PostgreSQL 数据库的实时 Web 更新</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/real-time-web-updates-from-your-postgresql-database-2289528b0f28?source=collection_archive---------4-----------------------#2022-01-25">https://blog.devgenius.io/real-time-web-updates-from-your-postgresql-database-2289528b0f28?source=collection_archive---------4-----------------------#2022-01-25</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/ec27275d4ad42cadaa33c4f1effc968e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QUQNC112FDt-KB_mT6eUBA.png"/></div></div></figure><p id="5eaa" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我在阅读 PostgreSQL 时，注意到一个有趣的特性，叫做逻辑复制。文档解释说逻辑复制是:</p><blockquote class="kt ku kv"><p id="9f23" class="jv jw kw jx b jy jz ka kb kc kd ke kf kx kh ki kj ky kl km kn kz kp kq kr ks ig bi translated">一种复制数据对象及其更改的方法，基于它们的复制标识(通常是主键)。</p></blockquote><p id="3e9f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">换句话说，这是一种通过让数据库向订阅者节点实时发布逻辑数据更改来确保数据库副本始终同步的方法。</p><p id="068c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">复制订阅服务器通常是充当主服务器副本的另一个数据库，但不限于此，它可以是任何东西。如果我们把它变成一个网络服务呢？然后，该服务可以将这些更改推送到 web 应用程序的多个客户端，这样它们就可以实时同步数据。</p><p id="b932" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">实际上还有另一个 PostgreSQL 特性，NOTIFY 命令，用于生成通知，但是我们需要为我们感兴趣的每个表编写数据库触发器，并且字符串有效负载大小有 8000 字节的限制。逻辑复制没有这样的限制，可以监听数据库中的所有表，这使得它更具可伸缩性。</p><p id="dc25" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以我写了一个小型开源库，结合了<a class="ae la" href="https://dotnetify.net/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> dotNetify </strong> </a>和 PostgreSQL 逻辑复制。您可以使用它构建一个带有 ASP.NET 5 的 web 应用程序，该应用程序可以对应用程序的任何用户提交给 PostgreSQL 数据库的所有插入、更新和删除操作做出反应。</p><p id="c63d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我把这个库命名为<strong class="jx io"> DotNetify。Postgres </strong> ( <a class="ae la" href="https://github.com/dsuryd/dotNetify/tree/master/DotNetifyLib.Postgres" rel="noopener ugc nofollow" target="_blank">源代码</a>)，你的项目不会涉及轮询数据库，建立一个复杂的发布/订阅系统，或者根本不需要多少代码。博客的其余部分将带你构建一个演示应用程序。</p><h1 id="4a6b" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">PostgreSQL 设置</h1><p id="a4e3" class="pw-post-body-paragraph jv jw in jx b jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks ig bi translated">要在 PostgreSQL 数据库中启用逻辑复制，请找到<em class="kw"> postgresql.conf </em>配置文件，将参数<code class="fe me mf mg mh b">wal_level</code>更改为<em class="kw">逻辑</em>，并将<code class="fe me mf mg mh b">max_wal_senders</code>和<code class="fe me mf mg mh b">max_replication_slots</code>都至少更改为 1。更改将在服务重新启动后生效。</p><p id="7bbd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您也可以使用 SQL 命令来更改它们:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="96cf" class="mq lc in mh b gy mr ms l mt mu">ALTER SYSTEM SET wal_level='logical';<br/>ALTER SYSTEM SET max_wal_senders='10';<br/>ALTER SYSTEM SET max_replication_slots='10';</span></pre><p id="5c4e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下一步是创建出版物:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="dc35" class="mq lc in mh b gy mr ms l mt mu">CREATE PUBLICATION my_pub FOR ALL TABLES;</span></pre><p id="3b29" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们将它设置为发布所有表的数据更改，但是如果您愿意，您可以将它限制为只发布特定的表。</p><p id="1780" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当 PostgreSQL 发布复制记录(也称为<em class="kw">预写日志</em>或 WAL)时，它使用一种叫做复制槽的东西来确保记录在订户收到之前不会被删除。</p><p id="5b38" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">复制槽很棒，因为它们允许订户暂时离线，并且在重新连接时，只需从停止的地方继续。但是有一个警告:在长时间的断开事件中，WAL 记录可能会堆积起来，达到耗尽空间并使数据库崩溃的程度，因此，需要监控这些槽。</p><p id="a0e8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下面是我们创建复制槽的方式:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="6b5c" class="mq lc in mh b gy mr ms l mt mu">SELECT * FROM pg_create_logical_replication_slot('my_slot', 'pgoutput');</span></pre><p id="75ab" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="kw"> pgoutput </em>是 PostgreSQL 的标准逻辑解码插件，用于将 WAL 的更改转换为逻辑复制协议。</p><p id="51b9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对于演示，让我们创建一个简单的表。我们还将创建一个新用户，我们的 web 服务将使用该用户连接到数据库:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="9fd1" class="mq lc in mh b gy mr ms l mt mu">CREATE TABLE IF NOT EXISTS businesses (<br/>  business_id serial PRIMARY KEY,<br/>  business_name VARCHAR ( 50 ) UNIQUE NOT NULL,<br/>  rating integer<br/>);</span><span id="26e2" class="mq lc in mh b gy mv ms l mt mu">CREATE USER my_user WITH PASSWORD 'my_pwd';<br/>ALTER ROLE my_user WITH REPLICATION;<br/>GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO my_user;<br/>GRANT USAGE, SELECT ON ALL SEQUENCES IN SCHEMA public TO my_user;</span></pre><p id="878c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">请注意，我们将复制角色赋予了用户。订阅复制插槽需要拥有此角色。</p><p id="fb10" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Postgres 数据库现在已经为逻辑复制进行了配置。下一步是创建一个 web 服务来订阅我们创建的复制槽，并将更改推送到网站。</p><h1 id="545f" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">Web 服务设置</h1><p id="bee4" class="pw-post-body-paragraph jv jw in jx b jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks ig bi translated">你可以从<a class="ae la" href="https://github.com/dsuryd/dotNetify/tree/master/Demo/React/RealtimeDb.Postgres" rel="noopener ugc nofollow" target="_blank">这个 Github repo </a>下载源代码。这是一个与 React/Typescript 前端和 web pack ASP.NET 项目。安装 npm 包后，您可以从 Visual Studio 或 dotnet CLI 运行项目。</p><p id="83b6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">代码为演示表提供了一个实体类:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="b3df" class="mq lc in mh b gy mr ms l mt mu">[Table("businesses")]<br/>public class Business<br/>{<br/>  [Column("business_id")]<br/>  [Key]<br/>  public long Id { get; set; }</span><span id="2648" class="mq lc in mh b gy mv ms l mt mu">  [Column("business_name")]<br/>  public string Name { get; set; }</span><span id="bf61" class="mq lc in mh b gy mv ms l mt mu">  [Column("rating")]<br/>  public int Rating { get; set; }<br/>}</span></pre><p id="d2c1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">有一个简单的 React 客户端来显示表的内容，以及相关的<em class="kw"> dotNetify </em>视图模型。视图模型通过一个 API 订阅表上的 PostgreSQL 数据更改事件，这个 API 由<strong class="jx io"> DotNetify。Postgres </strong>库提供状态更新，并将状态更新实时推送到客户端:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="132c" class="mq lc in mh b gy mr ms l mt mu">public class BusinessesVM : BaseVM<br/>  {<br/>    private IDisposable _subs;</span><span id="1f80" class="mq lc in mh b gy mv ms l mt mu">    // Real-time list; see: https://dotnetify.net/core/api/crud.<br/>    [ItemKey(nameof(Business.Id))]<br/>    public List&lt;Business&gt; Businesses { get; set; }</span><span id="bb85" class="mq lc in mh b gy mv ms l mt mu">    public BusinessesVM(IDbChangeObserver dbChangeObserver)<br/>    {<br/>        Businesses = new List&lt;Business&gt;();</span><span id="e0d7" class="mq lc in mh b gy mv ms l mt mu">        _subs = dbChangeObserver<br/>          .Observe&lt;Business&gt;()<br/>          .Subscribe(e =&gt;<br/>          {<br/>              if (e is DbInsertEvent&lt;Business&gt;)<br/>              {<br/>                var row = (e as DbInsertEvent&lt;Business&gt;).Row;<br/>                this.AddList(nameof(Businesses), row);<br/>              }<br/>              else if (e is DbUpdateEvent&lt;Business&gt;)<br/>              {<br/>                var row = (e as DbUpdateEvent&lt;Business&gt;).NewRow;<br/>                this.UpdateList(nameof(Businesses), row);<br/>              }<br/>              else if (e is DbDeleteEvent&lt;Business&gt;)<br/>              {<br/>                var key = (e as DbDeleteEvent&lt;Business&gt;).Row.Id;<br/>                this.RemoveList(nameof(Businesses), key);<br/>              }<br/>              PushUpdates();<br/>        });<br/>    }</span><span id="adb0" class="mq lc in mh b gy mv ms l mt mu">    public override void Dispose() =&gt; _subs.Dispose();<br/>  }</span></pre><p id="e720" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">PostgreSQL 数据库的连接字符串以及发布和复制插槽名称在服务启动类中配置:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="391a" class="mq lc in mh b gy mr ms l mt mu">public void ConfigureServices(IServiceCollection services)<br/>{<br/>    services.AddSignalR();<br/>    services.AddDotNetify();<br/>    services.AddDotNetifyPostgres(new PostgresConfiguration<br/>    {<br/>      ConnectionString = <br/>         Configuration.GetConnectionString("Postgres"),<br/>      PublicationName = "my_pub",<br/>      ReplicationSlotName = "my_slot"<br/>    });<br/>}</span></pre><p id="86a2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这就是全部了！以下是该应用对数据变化的反应:</p><figure class="mi mj mk ml gt jo gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/20f6b7a56ded3331f86b66a53318932c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/0*ReJBrqhCl6phHAp4.gif"/></div></figure><h1 id="be8c" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">带 EF 内核的完整 CRUD</h1><p id="b485" class="pw-post-body-paragraph jv jw in jx b jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks ig bi translated">到目前为止，我们有一个只对数据库中的数据变化做出反应的网页。让我们更进一步，让它也能够进行 CRUD 操作。为此，我们将使用 EF Core 和<a class="ae la" href="https://www.npgsql.org/" rel="noopener ugc nofollow" target="_blank"> Npgsql </a>库。</p><p id="f8a8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们为演示表添加一个<code class="fe me mf mg mh b">DbContext</code>类:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="8d5b" class="mq lc in mh b gy mr ms l mt mu">public class BusinessDbContext : DbContext<br/>{<br/>  public DbSet&lt;Business&gt; Businesses { get; set; }<br/>  public BusinessDbContext(<br/>    DbContextOptions&lt;BusinessDbContext&gt; options): base(options) <br/>  {}<br/>}</span></pre><p id="9796" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">由于生命周期长，DotNetify 视图模型必须使用工厂来创建新的<code class="fe me mf mg mh b">DbContext</code>。所以我们在启动类中配置了<code class="fe me mf mg mh b">DbContextFactory</code>服务:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="ba28" class="mq lc in mh b gy mr ms l mt mu">public void ConfigureServices(IServiceCollection services)<br/>{<br/>  ...<br/>  services.AddDbContextFactory&lt;BusinessDbContext&gt;(options =&gt;     <br/>    options.UseNpgsql(<br/>      Configuration.GetConnectionString("Postgres")));<br/>}</span></pre><p id="ded7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后一步是在视图模型上实现 CRUD 方法:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="796f" class="mq lc in mh b gy mr ms l mt mu">public class BusinessesVM : BaseVM<br/>{<br/>  private IDbContextFactory&lt;BusinessDbContext&gt; _contextFactory;</span><span id="ed31" class="mq lc in mh b gy mv ms l mt mu">  [ItemKey(nameof(Business.Id))]<br/>  public List&lt;Business&gt; Businesses { get; set; }</span><span id="31cd" class="mq lc in mh b gy mv ms l mt mu">  public BusinessesVM(<br/>    IDbContextFactory&lt;BusinessDbContext&gt; dbContextFactory,<br/>    IDbChangeObserver dbChangeObserver)<br/>  {<br/>      _contextFactory = dbContextFactory;</span><span id="f035" class="mq lc in mh b gy mv ms l mt mu">      using var dbContext = _contextFactory.CreateDbContext();<br/>      Businesses = dbContext.Businesses.OrderBy(x =&gt; x.Id).ToList();</span><span id="00c8" class="mq lc in mh b gy mv ms l mt mu">      this.ObserveList&lt;Business&gt;(<br/>         nameof(Businesses), dbChangeObserver);<br/>  }</span><span id="6b88" class="mq lc in mh b gy mv ms l mt mu">  public void Add(Business businessInfo)<br/>  {<br/>      using var dbContext = _contextFactory.CreateDbContext();<br/>      dbContext.Businesses.Add(businessInfo);<br/>      dbContext.SaveChanges();<br/>  }</span><span id="8cdb" class="mq lc in mh b gy mv ms l mt mu">  public void Update(Business businessInfo)<br/>  {<br/>      using var dbContext = _contextFactory.CreateDbContext();<br/>      var business = dbContext.Businesses.Find(businessInfo.Id);<br/>      if (business != null)<br/>      {<br/>        business.Name = businessInfo.Name;<br/>        business.Rating = businessInfo.Rating;<br/>        dbContext.SaveChanges();<br/>      }<br/>  }</span><span id="d3d4" class="mq lc in mh b gy mv ms l mt mu">  public void Remove(Business businessInfo)<br/>  {<br/>      using var dbContext = _contextFactory.CreateDbContext();<br/>      var business = dbContext.Businesses.Find(businessInfo.Id);<br/>      if (business != null)<br/>      {<br/>        dbContext.Businesses.Remove(business);<br/>        dbContext.SaveChanges();<br/>      }<br/>  }<br/>}</span></pre><p id="5caa" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您可能已经注意到，之前处理订阅和数据更改事件的代码被简化为对<em class="kw">observer list</em>扩展方法的一次调用。</p><p id="e2b8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下面是调用这些 CRUD 方法的 React 客户端的摘录:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="9c25" class="mq lc in mh b gy mr ms l mt mu">export const Businesses = () =&gt; {<br/>  const { vm, state } = useConnect&lt;State&gt;("BusinessesVM", this);<br/>  const [newName, setNewName] = useState&lt;string&gt;("");</span><span id="952d" class="mq lc in mh b gy mv ms l mt mu">  const addBusiness = (name: string) =&gt; {<br/>    vm.$dispatch({ Add: new Business(0, name) });<br/>    setNewName("");<br/>  };</span><span id="2b7c" class="mq lc in mh b gy mv ms l mt mu">  const updateBusiness = (id: number, name: string, rating: number) =&gt; {<br/>    vm.$dispatch({ Update: new Business(id, name, rating) });<br/>  };</span><span id="06c4" class="mq lc in mh b gy mv ms l mt mu">  const removeBusiness = (id: number) =&gt; {<br/>    vm.$dispatch({ Remove: new Business(id) });<br/>  };<br/>...</span></pre><p id="3119" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">至此，这是在我们应用一些 CRUD 操作时，应用程序的两个浏览器实例保持同步的演示:</p><figure class="mi mj mk ml gt jo gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/e4dc32470fc299433f1b3ebe0a620750.png" data-original-src="https://miro.medium.com/v2/resize:fit:1284/0*E-uwprGGjmbb7qev.gif"/></div></figure><p id="eb62" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">希望这对你有用！我很想听听你的想法。回复<a class="ae la" href="https://twitter.com/dotnetify/status/1422453418581389315" rel="noopener ugc nofollow" target="_blank">我的推文</a>让我知道。并随意转发！</p></div><div class="ab cl my mz hr na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ig ih ii ij ik"><p id="9711" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="kw">先前发表于</em><a class="ae la" href="https://dsuryd.github.io/dotNetify/realtime-postgres/" rel="noopener ugc nofollow" target="_blank">T5【https://dsuryd.github.io/dotNetify/realtime-postgres/】</a><em class="kw">。</em></p></div></div>    
</body>
</html>