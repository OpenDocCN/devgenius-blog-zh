<html>
<head>
<title>React component patterns to use based on need (Part 3)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">根据需要使用组件模式(第 3 部分)</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/react-component-patterns-to-use-based-on-need-part-3-4d524eae9561?source=collection_archive---------3-----------------------#2022-05-02">https://blog.devgenius.io/react-component-patterns-to-use-based-on-need-part-3-4d524eae9561?source=collection_archive---------3-----------------------#2022-05-02</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/8d3b461b90f7cd4ea62e66327bd9e454.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5MEiumeHgqA7hut1huE-5A.png"/></div></div></figure><p id="7b29" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在本系列的<a class="ae kt" rel="noopener ugc nofollow" target="_blank" href="/react-component-patterns-to-use-based-on-need-part-1-55694f2e676e"> 1 </a>和<a class="ae kt" rel="noopener ugc nofollow" target="_blank" href="/react-component-patterns-to-use-based-on-need-part-2-e15270191cc9"> 2 </a>部分，我们讨论了前三个问题，包括钩子、容器、hoc、渲染道具、复合组件、道具集合和道具获取器。</p><p id="aef9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">到目前为止，我们看到的模式都是关于组件的结构、它们的交互和道具。在这最后一部分，让我们向内看，看看如何从组件用户的角度管理状态。</p><p id="0877" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">问题</strong>:</p><p id="73ee" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="ku">先前已解决:</em></p><ol class=""><li id="6d7a" class="kv kw in jx b jy jz kc kd kg kx kk ky ko kz ks la lb lc ld bi translated">我们的组件中有逻辑吗？</li><li id="e1ff" class="kv kw in jx b jy le kc lf kg lg kk lh ko li ks la lb lc ld bi translated">许多组件都应该遵循层次结构吗？</li><li id="73ea" class="kv kw in jx b jy le kc lf kg lg kk lh ko li ks la lb lc ld bi translated">我们是否向多个组件发送同一组道具？</li></ol><p id="59e6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="ku">本文将讨论:</em></p><ol class=""><li id="c7ad" class="kv kw in jx b jy jz kc kd kg kx kk ky ko kz ks la lb lc ld bi translated"><strong class="jx io">我们是否有需要重置的状态？</strong></li><li id="dc71" class="kv kw in jx b jy le kc lf kg lg kk lh ko li ks la lb lc ld bi translated">用户应该对组件的行为有更多的控制权吗？</li><li id="0ce5" class="kv kw in jx b jy le kc lf kg lg kk lh ko li ks la lb lc ld bi translated"><strong class="jx io">还有其他杂项需求吗？</strong></li></ol><h2 id="9564" class="lj lk in bd ll lm ln dn lo lp lq dp lr kg ls lt lu kk lv lw lx ko ly lz ma mb bi translated">我们有需要重置的状态吗？</h2><p id="4cb9" class="pw-post-body-paragraph jv jw in jx b jy mc ka kb kc md ke kf kg me ki kj kk mf km kn ko mg kq kr ks ig bi translated">有些组件需要比其他组件更易于配置。除了它们是有状态的，我们还可以考虑它们是否需要:</p><ul class=""><li id="8b54" class="kv kw in jx b jy jz kc kd kg kx kk ky ko kz ks mh lb lc ld bi translated"><em class="ku">用 props 提供的值初始化</em>，即组件的初始值不需要硬编码</li><li id="7cca" class="kv kw in jx b jy le kc lf kg lg kk lh ko li ks mh lb lc ld bi translated">具有将状态复位到初始状态的能力</li></ul><p id="3529" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这种模式的常见例子通常是数字，如触发器和计数器。出于原创的原因，我选择了一个电子邮件列表项，类似于你打开电子邮件账户时看到的内容。“已读”状态可以通过项目内的按钮重置。</p><figure class="mi mj mk ml gt jo"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="7431" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这个例子中，我们传入一个属性作为状态的初始值。如果缺少它，我们可以默认为硬编码的值，使它更灵活。如果用户想将状态重置为初始状态，他可以点击触发<code class="fe mo mp mq mr b">resetRead</code>方法的“重置”按钮。简单吧？</p><p id="339f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在实际开发中，仅仅重置状态可能还不够！大多数情况下，<strong class="jx io">副作用</strong>需要运行。例如，我们需要在重置时将<code class="fe mo mp mq mr b">hasRead</code>状态保存在后端。</p><p id="67d5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">请记住，在重置过程中，一定要处理好副作用！在下面的代码片段中，我们在重置时调用一个父组件方法，它可以作为一个属性传入。</p><figure class="mi mj mk ml gt jo"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="9ed4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们的代码可以初始化状态，提供重置功能，并处理重置过程中的副作用！由于所有这些都是组件的<em class="ku">逻辑</em>部分，如果需要重用，我们可以将其提取到一个<em class="ku">钩子</em>中。</p><figure class="mi mj mk ml gt jo"><div class="bz fp l di"><div class="mm mn l"/></div></figure><h2 id="5f2e" class="lj lk in bd ll lm ln dn lo lp lq dp lr kg ls lt lu kk lv lw lx ko ly lz ma mb bi translated">用户应该对组件的行为有更多的控制权吗？</h2><p id="323f" class="pw-post-body-paragraph jv jw in jx b jy mc ka kb kc md ke kf kg me ki kj kk mf km kn ko mg kq kr ks ig bi translated">“控制”这个词让人想起了组件的<em class="ku">控制支柱</em>的概念，其中子组件的值总是由状态驱动。通常，表单元素如&lt;输入&gt;被控制。例如:</p><pre class="mi mj mk ml gt ms mr mt mu aw mv bi"><span id="d537" class="lj lk in mr b gy mw mx l my mz">[email, setEmail] = useState('');<br/>// ...<br/>&lt;input value={email} onChange={(e) =&gt; setEmail(e.target.value)} /&gt;</span></pre><p id="2b17" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">背后的<em class="ku">想法</em>很简单:给组件的用户更多的控制权！为了实现这一点，我们需要提供一个值和一个处理程序来更新这个值。</p><p id="03dc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">控制道具对于简单的用例来说已经足够了，但是当事情变得更复杂时会发生什么呢？我们会继续添加和元素数量一样多的值和处理程序吗？显然，这并不理想，因为它变得难以维护。</p><p id="bfaa" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">状态缩减器</strong>模式非常适合这种情况。非常适合<strong class="jx io"> <em class="ku">反转状态</em> </strong>的控制，即允许用户根据自己的需求<strong class="jx io"> <em class="ku">进行管理。</em> </strong></p><p id="a923" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们可以使用<code class="fe mo mp mq mr b">useReducer</code>钩子来管理多个状态字段，然后传入一个<em class="ku">自定义缩减器</em>到<em class="ku">覆盖</em>部分或全部默认的状态字段，这样组件的用户就可以从外部控制组件。</p><p id="16b3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">状态缩减器有用的另一个原因是<strong class="jx io"> <em class="ku">可组合性</em> </strong>。我们可以通过选择&amp;组装不同的元素来增强功能，而不是修改单个元素。</p><p id="a8ab" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们构建一个产品搜索过滤器，允许您选择一种服装类型&amp;一组颜色，然后单击 search 显示结果。大概是这样的:</p><figure class="mi mj mk ml gt jo gh gi paragraph-image"><div class="gh gi na"><img src="../Images/f239034cb9af4f0c291121f8e9b284bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:732/format:webp/1*DP5xzEX-kKSAWGtJeQEpWw.png"/></div></figure><p id="c2a8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先，假设逻辑都在组件本身内部。我们有两种状态，每种过滤器对应一种状态，即产品和颜色。条件是我们只能选择一种产品，而且要多少颜色都可以。</p><figure class="mi mj mk ml gt jo"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="b0dd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们已经可以将组件的“逻辑”部分抽象成一个钩子了！由于我们要处理多个过滤器的选择，我们可以使用一个<code class="fe mo mp mq mr b">useReducer</code>和<code class="fe mo mp mq mr b">dispatch</code>动作来代替管理许多<code class="fe mo mp mq mr b">useState</code>钩子。</p><p id="1a3a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">以下示例显示了重构后的组件:</p><figure class="mi mj mk ml gt jo"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="af94" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果一个<strong class="jx io"> <em class="ku">新要求</em> </strong> <em class="ku"> </em>要求我们以这样一种方式扩展代码，如果选择了“t 恤”&amp;“黑色”，那么颜色“午夜蓝”必须自动添加到搜索中，即一般行为的例外，该怎么办？如果这个组件被多个实体使用，并且每个实体都有自己的异常，那该怎么办？在这种情况下，我们将<em class="ku">而不是</em>能够修改我们的减速器和吊钩以满足所有需求！</p><p id="8d5f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们必须向我们的 API(组件)的消费者提供更多的控制，以便他们可以定制其行为。我们不能用简单的控制道具做到这一点，因为它会变得太复杂。相反，传入一个<strong class="jx io">定制的缩减器</strong>，它可以<em class="ku">覆盖</em>默认的缩减器！</p><p id="99c1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">更新我们的钩子，使用一个 reducer 道具，或者像这样回到默认状态:</p><pre class="mi mj mk ml gt ms mr mt mu aw mv bi"><span id="fe1c" class="lj lk in mr b gy mw mx l my mz">const useProductSearchFilter = (<strong class="mr io">reducer = productSearchFilterReducer</strong>) =&gt; {<br/>  const [{ product, colors }, dispatch] = useReducer(<br/>    <strong class="mr io">reducer</strong>,<br/>    initialProductSearchFilterState<br/>  );</span><span id="187e" class="lj lk in mr b gy nb mx l my mz">  // ...</span><span id="a09e" class="lj lk in mr b gy nb mx l my mz">});</span></pre><p id="6b35" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">组件也可以类似地更新:</p><pre class="mi mj mk ml gt ms mr mt mu aw mv bi"><span id="1585" class="lj lk in mr b gy mw mx l my mz">const ProductSearchFilter = ({<br/>  products = [],<br/>  colors = [],<br/>  sizes = [],<br/>  onSearch = () =&gt; {},<br/>  <strong class="mr io">reducer</strong><br/>}) =&gt; {<br/>  const {<br/>    product,<br/>    colors: selectedColors,<br/>    selectProduct,<br/>    selectColors<br/>  } = useProductSearchFilter(<strong class="mr io">reducer</strong>);</span><span id="971e" class="lj lk in mr b gy nb mx l my mz">  // ...</span><span id="fddf" class="lj lk in mr b gy nb mx l my mz">});</span></pre><p id="5bc7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，消费者可以添加例外，即如果满足以下条件，我们必须自动将“午夜蓝”颜色添加到搜索中:</p><figure class="mi mj mk ml gt jo"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="5596" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">请注意，消费者可能需要访问默认缩减器。</p><h2 id="326e" class="lj lk in bd ll lm ln dn lo lp lq dp lr kg ls lt lu kk lv lw lx ko ly lz ma mb bi translated">还有其他杂七杂八的需求吗？</h2><p id="39f8" class="pw-post-body-paragraph jv jw in jx b jy mc ka kb kc md ke kf kg me ki kj kk mf km kn ko mg kq kr ks ig bi translated">在本节中，我不想讨论任何一种模式。我补充是为了全面。一旦我们选择了一个模式，还需要考虑其他的实现。问这个问题会让你有意识的去思考他们。</p><p id="3e1d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">除了选择模式，我们应该认识到优化的需要，比如用<code class="fe mo mp mq mr b">useCallback</code>或<code class="fe mo mp mq mr b">useMemo</code>来记忆函数。</p><p id="5555" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">有时，由于性能的限制，一个特定的模式，尽管非常适合我们的需求，可能并不是实际的方法！</p><h2 id="1af6" class="lj lk in bd ll lm ln dn lo lp lq dp lr kg ls lt lu kk lv lw lx ko ly lz ma mb bi translated">摘要</h2><ul class=""><li id="9967" class="kv kw in jx b jy mc kc md kg nc kk nd ko ne ks mh lb lc ld bi translated">如果你需要设置一个初始状态并重置为初始状态，使用状态初始化器模式</li><li id="c88d" class="kv kw in jx b jy le kc lf kg lg kk lh ko li ks mh lb lc ld bi translated">在状态初始化模式下的重置过程中处理必要的副作用</li><li id="c466" class="kv kw in jx b jy le kc lf kg lg kk lh ko li ks mh lb lc ld bi translated">如果状态变得太复杂，不建议使用控制属性来控制组件</li><li id="0e48" class="kv kw in jx b jy le kc lf kg lg kk lh ko li ks mh lb lc ld bi translated">状态缩减器模式允许组件的消费者提供一个定制的缩减器来覆盖默认的缩减器</li><li id="68eb" class="kv kw in jx b jy le kc lf kg lg kk lh ko li ks mh lb lc ld bi translated">状态缩减器是一个很好的模式，可以将我们的状态控制转化给消费者，并实现可组合性</li></ul><p id="ddfe" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是如何根据需要选择反应模式的系列文章的最后一部分。希望你觉得有用！(参见<a class="ae kt" rel="noopener ugc nofollow" target="_blank" href="/react-component-patterns-to-use-based-on-need-part-1-55694f2e676e">第一部分</a> &amp; <a class="ae kt" rel="noopener ugc nofollow" target="_blank" href="/react-component-patterns-to-use-based-on-need-part-2-e15270191cc9">第二部分</a>)</p><p id="47b7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">(我在其他平台也很活跃。主要是，<a class="ae kt" href="https://www.linkedin.com/in/pushkar-desai-811a75102/" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>&amp;<a class="ae kt" href="https://twitter.com/pushkardk" rel="noopener ugc nofollow" target="_blank">Twitter</a></p></div></div>    
</body>
</html>