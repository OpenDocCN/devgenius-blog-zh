<html>
<head>
<title>Ruby — Working with Blocks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Ruby —使用块</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/ruby-working-with-blocks-1640e6861d0c?source=collection_archive---------8-----------------------#2022-02-22">https://blog.devgenius.io/ruby-working-with-blocks-1640e6861d0c?source=collection_archive---------8-----------------------#2022-02-22</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div class="gh gi jk"><img src="../Images/971672f77eb82b024421ee7f9fbeb510.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E3zcTb0_fHjW_bYCwrI5Gw.jpeg"/></div></figure><p id="0db7" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io">简介</strong></p><p id="0fdb" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">Ruby 程序员广泛使用块，它们是语言的基础部分。因此，对积木的良好理解将真正帮助你建立一个良好的基础，在此基础上你可以继续学习其他更复杂的概念。</p><p id="277f" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">块是组合在一起的一段代码，稍后可以执行这段代码来完成某项任务。块是一段语法，但不是对象。块连接到方法调用。没有方法就不能有块。你会经常看到块和方法一起使用，但是需要注意的是块不是一个参数或者一个变量或者一个方法。可以使用花括号或 do end 关键字来定义块。这两者在优先顺序上有细微的区别。在代码执行期间，大括号具有更高的优先级。不过现在，只要记住这是 Ruby 程序员使用的惯例，多行语句使用 do end 语法，单行语句使用大括号。如果你是一个初学者，你可能会看到块类似于方法。但是你需要明白它们有什么不同。一旦你定义了一个方法，你可以一次又一次的调用它，但是块只能执行一次。此外，与方法不同，块一旦完成执行就不会持久。我们在方法中使用块的原因是，如果你想定制附加在方法上的功能，你可以使用块。当你使用块的时候，这个方法将包含所有通用的并且在块中保持不变的东西，并且将包含独特的或者可定制的动作。</p><p id="7668" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io">写一块</strong></p><p id="7596" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">定义一个块有两种方法，一种是用“<em class="kp">花括号</em>，一种是用“<em class="kp"> do </em>”和“end”关键字。让我们看一些例子。</p><p id="84fb" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">花括号:</p><pre class="kq kr ks kt gt ku kv kw kx aw ky bi"><span id="1aea" class="kz la in kv b gy lb lc l ld le">3.times { puts “This is how you write a block” }</span></pre><p id="6654" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">带关键字:</p><pre class="kq kr ks kt gt ku kv kw kx aw ky bi"><span id="e3b2" class="kz la in kv b gy lb lc l ld le">3.times do<br/>  puts “This is how you write a block”<br/>  puts “This is how you write a block with do and end”<br/>end</span></pre><p id="a221" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">上面的两个示例代码做同样的事情。打印输出“这是你如何写一个块”3 次。如果你仔细观察，你会发现如果它是一个单独的语句，花括号允许你以简洁易读的形式写一个块。同样，如果块由多个语句组成，那么用 do，end 关键字将它括起来更有意义。</p><p id="6624" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">让我们看另一个例子:</p><p id="85cb" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">让我们用值 7、8 和 9 创建一个数组。然后我们调用这个数组上的每个方法，指定我们想要对这些项目做什么。在这种情况下，我们将打印它们。</p><pre class="kq kr ks kt gt ku kv kw kx aw ky bi"><span id="f362" class="kz la in kv b gy lb lc l ld le">arr = [7,8,9]</span></pre><p id="8ed4" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">花括号:</p><pre class="kq kr ks kt gt ku kv kw kx aw ky bi"><span id="dc7a" class="kz la in kv b gy lb lc l ld le">arr.each { |element| puts element }</span></pre><p id="fb66" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">带关键字:</p><pre class="kq kr ks kt gt ku kv kw kx aw ky bi"><span id="8437" class="kz la in kv b gy lb lc l ld le">arr.each do |element|<br/>  puts element<br/>end</span></pre><p id="5fa6" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io">编写块方法</strong></p><p id="c1c1" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">让我们看看如何利用块来编写我们自己的方法。在这种情况下，block 被认为是我们方法的一个参数。</p><p id="aba3" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">我们的方法:</p><pre class="kq kr ks kt gt ku kv kw kx aw ky bi"><span id="5304" class="kz la in kv b gy lb lc l ld le">def my_method<br/>  puts “Inside my method”<br/>end</span></pre><p id="f7eb" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">阻止:</p><pre class="kq kr ks kt gt ku kv kw kx aw ky bi"><span id="ba63" class="kz la in kv b gy lb lc l ld le">my_method do<br/>  puts “block as argument”<br/>end</span></pre><p id="c32a" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">当你运行这个代码块的时候，你只能看到我的方法里面的<em class="kp">是 put put。原因是，即使我们传递了 block block 方法，我们也没有指定如何处理它，所以这个方法忽略了它。让我们修改方法来执行代码块。为此，我们将添加一个名为“yield”的关键字。</em></p><p id="295a" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">我们的方法:</p><pre class="kq kr ks kt gt ku kv kw kx aw ky bi"><span id="0ec4" class="kz la in kv b gy lb lc l ld le">def my_method<br/>  puts “Inside my method”<br/>  yield<br/>end</span></pre><p id="c509" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">阻止:</p><pre class="kq kr ks kt gt ku kv kw kx aw ky bi"><span id="a281" class="kz la in kv b gy lb lc l ld le">my_method do<br/>  puts “block as argument”<br/>end</span></pre><p id="332c" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">现在我们的输出看起来像这样:</p><pre class="kq kr ks kt gt ku kv kw kx aw ky bi"><span id="b7db" class="kz la in kv b gy lb lc l ld le">Inside my method<br/>block as argument</span></pre><p id="26a3" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">如果你想在你的方法中多次执行你的代码块，你需要在所有这些地方添加关键字" yield"。</p><pre class="kq kr ks kt gt ku kv kw kx aw ky bi"><span id="c108" class="kz la in kv b gy lb lc l ld le">def my_method<br/>  yield<br/>  puts “Inside my method”<br/>  yield<br/>end</span><span id="1208" class="kz la in kv b gy lf lc l ld le">my_method do<br/>  puts “ — — — — — -”<br/>end</span></pre><p id="984b" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">现在我们的输出看起来像这样:</p><pre class="kq kr ks kt gt ku kv kw kx aw ky bi"><span id="d480" class="kz la in kv b gy lb lc l ld le">— — — — — -<br/>Inside my method<br/>— — — — — -</span></pre><p id="53a0" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io">有争论的街区</strong></p><p id="8675" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">块可以像方法一样接受参数。每当我们编写一个带参数的块时，你可以认为参数被传递给了这个块。让我们看一个例子:</p><pre class="kq kr ks kt gt ku kv kw kx aw ky bi"><span id="d5de" class="kz la in kv b gy lb lc l ld le">def welcome<br/>  puts “What is your name ?”<br/>  name = gets.chomp<br/>  yield name<br/>end</span><span id="0b96" class="kz la in kv b gy lf lc l ld le">welcome do |name|<br/>  puts “Welcome #{name}”<br/>end</span></pre><p id="3c85" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">在这段代码中，方法捕获用户输入并将其分配给 name 变量，然后将其传递给块，并块打印输出。</p><p id="8a5c" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">如果我们运行上面代码，我们会得到这样的结果:(用户输入 John 的名字)</p><pre class="kq kr ks kt gt ku kv kw kx aw ky bi"><span id="a6e4" class="kz la in kv b gy lb lc l ld le"><strong class="kv io">Welcome John</strong></span></pre><p id="93dc" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io">用调用方法</strong>调用程序块</p><p id="89e9" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">Yield 不是调用块的唯一方式，块可以接受多个参数。让我们看看谁可以使用 block.call 方法调用一个块。</p><pre class="kq kr ks kt gt ku kv kw kx aw ky bi"><span id="2bbc" class="kz la in kv b gy lb lc l ld le">def welcome(question, &amp;my_block)<br/>  puts question<br/>  name = gets.chomp<br/>  my_block.call(name)<br/>end</span><span id="53e2" class="kz la in kv b gy lf lc l ld le">welcome(“What is your name ?”) do |name|<br/>  puts “Welcome #{name}”<br/>end</span></pre><p id="9895" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">这类似于前面的块参数示例。这里我们的 greet 方法有两个参数，一个问题和块名 my_block。注意“my_block”前的“&amp;”符号，这就是我们如何通知 ruby 这不是另一个参数，而是一个块。另外，现在我们用 my_block.call 方法替换了“yield”。如果您运行这段代码，您将得到与上面带有参数示例的块相同的结果。</p><p id="6c2f" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">现在您已经知道如何编写 Ruby 块了。因此，开始在您的应用程序中使用它们，看看有什么不同。</p></div></div>    
</body>
</html>