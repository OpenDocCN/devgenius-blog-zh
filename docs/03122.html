<html>
<head>
<title>A quick and dirty implementation of Sokoban with JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用JavaScript快速实现Sokoban</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/a-quick-and-dirty-implementation-of-sokoban-with-javascript-1e77e04c70b4?source=collection_archive---------3-----------------------#2020-10-02">https://blog.devgenius.io/a-quick-and-dirty-implementation-of-sokoban-with-javascript-1e77e04c70b4?source=collection_archive---------3-----------------------#2020-10-02</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div class="gh gi jk"><img src="../Images/329a8b48d62fa0b93eda262d4e9681a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1284/format:webp/1*ZV9UOsUUM0_gvgh9IyDo_A.jpeg"/></div></figure><p id="19c1" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">不缺少Sokoban实现。最著名的实现之一就是YASC推箱子。首字母缩写代表“又一个推箱子克隆”</p><p id="240e" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">在网上已经有至少一个使用JavaScript的推箱子实现:<a class="ae kp" href="http://www.game-sokoban.com/index.php" rel="noopener ugc nofollow" target="_blank">game-sokoban.com</a>，我经常玩这个。我不知道是谁编的程序。</p><p id="fcc9" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">作为Scala中Sokoban实现的前期工作的一部分，我决定使用HTML、CSS和JavaScript来实现一个快速而简单的实现。</p><p id="1f78" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">推箱子关卡的基本概念很容易理解:你移动箱子，这样每个箱子都在一个目标上。</p><p id="91fc" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">找出解决某个特定关卡的具体步骤，这可能相当困难，尤其是如果目标上已经有一些盒子，并且您必须在将其他盒子移入之前将它们移出。</p><p id="6510" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">推箱子级别通常被分组到集合中。想必一套的第一关很容易。如果你解决了这个问题，你就可以进入第二关，这可能会稍微困难一些。</p><p id="d552" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">对于我的JavaScript实现，我决定只使用“普通的”JavaScript。如果你想跟着做，你不需要NPM安装一百个不同的库。我甚至不打算使用jQuery。</p><p id="65eb" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">如果你愿意，可以参考<a class="ae kp" href="https://github.com/Alonso-del-Arte/sokoban-ascii" rel="noopener ugc nofollow" target="_blank">我的GitHub库</a>。为了让你可以在浏览器中玩游戏，而不需要调用存储库，它有一个gh-pages分支。</p><p id="21a2" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">进入<a class="ae kp" href="https://alonso-del-arte.github.io/sokoban-ascii/index.html" rel="noopener ugc nofollow" target="_blank">索引页面</a>，选择难度等级。实际上，即使您非常擅长在其他实现中玩推箱子，也应该选择从简单开始。第二次移动后没有单次移动撤消，重新开始该级别的唯一方法是刷新页面。</p><p id="3247" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">这个项目有一个Git ignore文件的唯一原因是为了排除一个草稿Sokoban级别的文件夹。</p><p id="7814" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">至于文本编辑器，如果您愿意，当然可以使用Visual Studio代码。可能有点矫枉过正。如果你真的想的话，你绝对可以使用Sublime Text、Vim甚至记事本。</p><p id="b997" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">我使用Adobe括号，因为我已经开始喜欢它用于HTML项目。它是免费的，这当然很有帮助。</p><p id="5399" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">我喜欢Sublime，但是我还没有喜欢到愿意掏钱买的程度，所以就不再用了。崇高的试用期应该是无限期的，但来吧，它不应该需要超过一年的时间来作出决定。</p><p id="0e39" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">Adobe Brackets有一个JavaScript linter，但在大多数情况下，我发现它远不如Firefox在控制台中给出的错误和警告有用。</p><p id="c995" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">另外，我想我会从ES5开始，遇到一些问题，然后不得不切换到ES6。JavaScript是一种极其复杂的编程语言，我是作为一个尝试过用Malbolge编程的人这么说的。</p><p id="b73d" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">虽然公平地说，我实际上在JavaScript中完成了一些事情，但在Malbolge中什么也没完成。</p><p id="b0c9" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">我还决定不对JavaScript实现使用测试驱动开发。这使得开发过程变得快速(当然假设我没有遇到意想不到的问题，这在JavaScript中更容易发生)但也很肮脏。</p><p id="3af9" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">在这个特别的项目中，我没有像我想象的那样笨手笨脚。我想绝对清楚的是，我想出的东西仍然需要相当多的努力。它不是突然出现的。</p><p id="b178" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">我做的另一个决定是不在任何游戏元素中使用任何图形。那么，用哪些角色来代表游戏元素呢？</p><p id="1e53" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">我曾短暂考虑过使用表情符号。但是我意识到我不能指望它们都有相同的宽度，也不能指望它们在广泛使用的等宽字体中可用。</p><p id="0a29" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi">I also considered kanji, which are used in Chinese and Japanese, and to a much lesser extent Korean and Vietnamese. Google Translate gives me “壁” (“kabe”) for “wall,” which doesn’t look particularly wall-like to me, and worse, “ボックス” (“bokkusu”) for “box.”</p><p id="3fae" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">也许最初的Sokoban程序员确实使用了汉字，但更有可能的是，他们使用了一小组现在被认为实际上是标准的ASCII字符。那为什么不直接用那些呢？我照做了。</p><p id="1e5f" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">具有推箱子级别的HTML页面应该链接样式表和脚本。然后，在Body标签的<code class="fe kq kr ks kt b">onload</code>属性中，页面调用<code class="fe kq kr ks kt b">initialize()</code>，这是一个寻找预格式化标签的过程。例如:</p><pre class="ku kv kw kx gt ky kt kz la aw lb bi"><span id="37a8" class="lc ld in kt b gy le lf l lg lh">&lt;pre&gt;       ####;<br/>########  ##;<br/>#          ###;<br/># @$$ ##   ..#;<br/># $$   ##  ..#;<br/>#         ####;<br/>###########;&lt;/pre&gt;</span></pre><p id="f24e" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">注意，如果HTML页面有多个预格式化的元素，只有第一个这样的元素会被解析并理解为Sokoban级别。任何其他的都将被忽略。</p><p id="3003" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">然后，脚本解析元素内容中的推箱子符号。除了分号之外，上面的示例显示了七个最常用的推箱子符号中的五个:</p><ul class=""><li id="ce9d" class="li lj in jt b ju jv jy jz kc lk kg ll kk lm ko ln lo lp lq bi translated">墙砖的井号(#)</li><li id="12ba" class="li lj in jt b ju lr jy ls kc lt kg lu kk lv ko ln lo lp lq bi translated">空目标的周期</li><li id="f5a2" class="li lj in jt b ju lr jy ls kc lt kg lu kk lv ko ln lo lp lq bi translated">星号(*)代表目标上的方框</li><li id="1b27" class="li lj in jt b ju lr jy ls kc lt kg lu kk lv ko ln lo lp lq bi translated">美元符号($)表示不在目标上的方框</li><li id="d0cb" class="li lj in jt b ju lr jy ls kc lt kg lu kk lv ko ln lo lp lq bi translated">球门上玩家标记(推杆)的加号(+)</li><li id="f42f" class="li lj in jt b ju lr jy ls kc lt kg lu kk lv ko ln lo lp lq bi translated">不在球门上的玩家标志</li><li id="28ee" class="li lj in jt b ju lr jy ls kc lt kg lu kk lv ko ln lo lp lq bi translated">当然，一个没有被其他任何东西占据的地方的空间，不管这个地方是在墙外还是墙内</li></ul><p id="87cb" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">该脚本还理解较少使用但可能同样标准的符号，如“B”代表不在目标上的方框,“B”代表目标上的方框。</p><p id="0fc0" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">我认为换行和回车会有问题。也许有一种更聪明的方法，但是我决定简单地通过使用分号来回避这个问题，分号是旧编程语言中令人讨厌的祸害，它表示行的结束。</p><p id="0f56" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">如果最后一个字符被省略，脚本会推断它是分号。但是不用担心，脚本不会在其他任何位置推断分号。</p><p id="3093" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">该脚本还检查盒子的数量是否与目标的数量相匹配。如果有一个不匹配，像太多的盒子太少的目标，它会给出警告，但如果你想，它仍然会让你发挥水平。</p><p id="2353" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">没有任何其他级别的验证，当然也没有验证该级别是否有解决方案。这种验证是一个艰巨的任务，即使是一个专门的推箱子程序，包括一个解算器，如YASC推箱子。</p><p id="c448" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">我应该提到，该脚本使用了几个全局变量，包括两个数字来保存玩家令牌的当前(<em class="lw"> x </em>，<em class="lw"> y </em>)坐标，以及计数器，用于记录目标上有多少个方块以及玩家到目前为止已经走了多少步。如果这不是快速和肮脏的，这将是一个明确的不要。</p><p id="07f2" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">另一个全局变量<code class="fe kq kr ks kt b">currentState</code>是一个二维数组，它最初按照解析Sokoban符号的顺序保存这些符号。初始化之后，它只能通过<code class="fe kq kr ks kt b">queryPosition()</code> getter和<code class="fe kq kr ks kt b">changePosition()</code> setter来访问，但是没有任何东西来强制进行封装。</p><p id="66c9" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">一旦板的初始状态被读入并显示出来，就该给整个文档附加一个事件监听器了。实际上，我之前已经放在那里了，但是也许我应该重构一下。</p><pre class="ku kv kw kx gt ky kt kz la aw lb bi"><span id="fbe0" class="lc ld in kt b gy le lf l lg lh">document.onkeydown = processArrowKey;</span></pre><p id="2e33" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">这使得每次按下任何键时都会调用<code class="fe kq kr ks kt b">processArrowKey()</code>过程。我承认我在将箭头键代码与相应的<code class="fe kq kr ks kt b">x</code>和<code class="fe kq kr ks kt b">y</code>坐标变化进行匹配时有点阅读障碍。</p><p id="1370" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">通过查看事件对象的键码，该过程确定是否按下了箭头键。如果是这种情况，就会计算相对坐标。</p><pre class="ku kv kw kx gt ky kt kz la aw lb bi"><span id="0ace" class="lc ld in kt b gy le lf l lg lh">function processArrowKey(e) {<br/>    var x, y;<br/>    switch(e.keyCode) {<br/>        case 37: <br/>            x = 0;<br/>            y = -1;<br/>            break;<br/>        case 38: <br/>            x = -1;<br/>            y = 0;<br/>            break;<br/>        case 39: <br/>            x = 0;<br/>            y = 1;<br/>            break;<br/>        case 40: <br/>            x = 1;<br/>            y = 0;<br/>            break;<br/>        default:<br/>            x = 0;<br/>            y = 0;<br/>    }<br/>    if (canMove(x, y)) {<br/>        writeBoard();<br/>    }<br/>}</span></pre><p id="384d" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><code class="fe kq kr ks kt b">canMove()</code>函数是一个布尔函数，如果玩家令牌可以移动到指定的相对位置，则返回true，否则返回false。这里引用的函数太长了，可能周期也太长了。这意味着也许我应该重构，把它分解成更小的函数。</p><p id="c586" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">如果相对(<em class="lw"> x </em>，<em class="lw"> y </em>)坐标为(0，0)，<code class="fe kq kr ks kt b">canMove()</code>返回false。我可以重构它，使它总是用非零的相对坐标来调用，但这只会删除三行。</p><p id="126e" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">使用非零相对坐标，<code class="fe kq kr ks kt b">canMove()</code>接下来计算绝对位置，并使用<code class="fe kq kr ks kt b">queryPosition()</code>计算出在建议的新位置有什么(如果有的话)。</p><p id="ac5d" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">在这一点上，我利用Switch-Case fall-through来避免重复行，例如，当建议位置中的项目是一个盒子时，无论是否在目标上。</p><pre class="ku kv kw kx gt ky kt kz la aw lb bi"><span id="2798" class="lc ld in kt b gy le lf l lg lh">        case "*":<br/>            playerToken = "+";<br/>        case "$":<br/>            if (canPush(absoluteX, absoluteY, <br/>                        relativeX, relativeY)) {<br/>                if (currPlayerToken == "@") {<br/>                    changePosition(playerX, playerY, " ");<br/>                } else {<br/>                    changePosition(playerX, playerY, ".");<br/>                }<br/>                playerX = absoluteX;<br/>                playerY = absoluteY;<br/>                changePosition(playerX, playerY, playerToken);<br/>                moveCount++;<br/>                return true;<br/>            }<br/>            return false;</span></pre><p id="0985" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">Scala中没有切换失败这样的东西，所以我可能会想出一个解决方案，虽然不那么聪明，但是更简洁。</p><p id="92e8" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">显然<code class="fe kq kr ks kt b">canMove()</code>不是一个纯粹的函数，因为它有改变玩家令牌位置的副作用，如果确定它可以移动到那里，<code class="fe kq kr ks kt b">canPush()</code>也不是，因为它改变了受影响盒子的状态。就像我说的，这会又快又脏。</p><p id="9d98" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">我将为Hacktoberfest开放GitHub知识库。</p></div></div>    
</body>
</html>