<html>
<head>
<title>The Magic of C++ Templates and Static Variables</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C++模板和静态变量的魔力</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/the-magic-of-c-templates-and-static-variables-7c77531cab7b?source=collection_archive---------0-----------------------#2021-10-21">https://blog.devgenius.io/the-magic-of-c-templates-and-static-variables-7c77531cab7b?source=collection_archive---------0-----------------------#2021-10-21</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><h1 id="f1c2" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">释放函数模板的力量</h1><p id="f900" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">泛型编程越来越受欢迎，Golang 最终计划在其 1.18 版本中使用泛型，因为它是 Go 开发者多年来最渴望的特性。通过允许您的算法跨数据类型使用，您可以最大限度地减少代码重复并节省时间。</p><p id="57ba" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">C++以其编译时优化而闻名(<em class="lg">不幸的是，这也是为什么 C++程序需要一段时间来编译！</em>)。泛型的编译时检查至关重要，难道 C++和泛型不是完美的一对吗？</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi lm"><img src="../Images/13f9d3b409727aefbe608bc902833abd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wqAWx8JOWENRg3VH"/></div></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk translated">在<a class="ae mc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上<a class="ae mc" href="https://unsplash.com/@anshu18?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">安舒 A </a>的照片</figcaption></figure><p id="aea1" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">在 C++中，这种功能是通过使用<strong class="kk io"> <em class="lg">模板</em> </strong>来提供的。模板和泛型有细微的区别，模板提供了额外的功能，这将在后面讨论。</p><p id="fd6b" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">在这篇文章中，我想重点讨论一下函数模板的使用:静态变量。</p><p id="a7fd" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">假设你有一个算法类。对于那个类，你有几个子类:贪婪、递归和暴力。对于每一个，您可能有一个类似的静态变量，例如一个列表列表，其中包含算法的每个输入的每种可能的类型。现在，您需要测试所有类型组合是否正常工作。你怎么能这样做？</p><p id="4bf0" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">嗯，静态变量属于派生类，<strong class="kk io">而不是</strong>基本算法类，因为它只在贪婪算法、递归算法和蛮力算法中共享，而不是在所有算法中共享。这就是模板派上用场的地方！请参见下面的示例代码:</p><pre class="ln lo lp lq gt md me mf mg aw mh bi"><span id="f24f" class="mi jl in me b gy mj mk l ml mm">template &lt;class ChosenAlgorithm&gt;<br/>std::vector&lt;std::vector&lt;Type&gt;&gt;<br/>GetValidTypes()<br/>{<br/>  std::vector&lt;std::vector&lt;Type&gt;&gt; type_combinations = ChosenAlgorithm::supported_types_;<br/>  std::vector&lt;std::vector&lt;Type&gt;&gt; valid_combinations;<br/>  for(auto type_list: supported_types){<br/>    if(ChosenAlgorithm::AreValidTypes(type_list))<br/>      valid_combinations.emplace_back(type_list);</span><span id="0e72" class="mi jl in me b gy mn mk l ml mm">  return valid_combinations;</span><span id="27ef" class="mi jl in me b gy mn mk l ml mm">}</span></pre><p id="3aca" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">如果你仔细观察，你会注意到我们不仅使用了静态成员变量 supported_types_ 而且还使用了静态成员函数 AreValidTypes。有什么神奇的<em class="lg">(还有危险！)</em>关于模板是没有强制多态性的。您可以用任何类调用 GetValidTypes，编译器将检查该类是否具有使用模板所需的所有成员。</p><pre class="ln lo lp lq gt md me mf mg aw mh bi"><span id="09a3" class="mi jl in me b gy mj mk l ml mm">auto types = GetValidTypes&lt;Greedy&gt;();</span></pre><p id="b70e" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">额外的好处是，您可以让<em class="lg">模板参数</em>成为函数的一个这样的参数，以确定您正在使用哪个类！然后，您不必手动指定模板参数。</p><pre class="ln lo lp lq gt md me mf mg aw mh bi"><span id="5ae1" class="mi jl in me b gy mj mk l ml mm">template &lt;class ChosenAlgorithm&gt;<br/>std::vector&lt;std::vector&lt;Type&gt;&gt;<br/>GetValidTypes(ChosenAlgorithm algo)<br/>{<br/>  ...<br/>}<br/>...</span><span id="1166" class="mi jl in me b gy mn mk l ml mm">//Call elsewhere<br/>Recursive a = new Recursive();<br/>auto types = GetValidTypes(a);</span></pre></div><div class="ab cl mo mp hr mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ig ih ii ij ik"><h1 id="e3e7" class="jk jl in bd jm jn mv jp jq jr mw jt ju jv mx jx jy jz my kb kc kd mz kf kg kh bi translated">模板与泛型</h1><p id="c67a" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">C++中没有泛型，不像 Java 这样的语言有泛型类型。C++使用模板来实现泛型编程。模板和一般的泛型有什么不同？</p><p id="b45b" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">在 C++中，编译器为您使用的每组唯一的模板参数生成一个单独的模板。这可能导致代码膨胀。同时，<strong class="kk io">编译器只生成需要的成员和函数</strong>，链接器尽可能减少代码重用。这种复制粘贴方法会导致可靠的编译时检查，因此如果您在模板中使用的任何类缺少所需的函数或变量，您都会收到一个错误。</p><p id="5f54" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">有了这种编译时检查，在使用模板时就不那么需要类限制了！另外，这种<strong class="kk io">检查意味着如果你创建多个模板，编译器会找到与所需函数/变量</strong>匹配的模板。</p><p id="9fe7" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">这意味着你<em class="lg">可以重载你的模板</em>并且<em class="lg">编译器会计算出哪个</em>有意义！例如，假设我们编写了下面两个模板。如果您用一个没有 AreValidTypes 的类调用 GetValidTypes()，编译器将使用第二个模板。</p><pre class="ln lo lp lq gt md me mf mg aw mh bi"><span id="7c40" class="mi jl in me b gy mj mk l ml mm">template &lt;class ChosenAlgorithm&gt;<br/>std::vector&lt;std::vector&lt;Type&gt;&gt;<br/>GetValidTypes()<br/>{<br/>  std::vector&lt;std::vector&lt;Type&gt;&gt; type_combinations = ChosenAlgorithm::supported_types_;<br/>  std::vector&lt;std::vector&lt;Type&gt;&gt; valid_combinations;<br/>  for(auto type_list: supported_types){<br/>    if(ChosenAlgorithm::AreValidTypes(type_list))<br/>      valid_combinations.emplace_back(type_list);</span><span id="76ef" class="mi jl in me b gy mn mk l ml mm">  return valid_combinations;</span><span id="2de7" class="mi jl in me b gy mn mk l ml mm">}</span><span id="c9a7" class="mi jl in me b gy mn mk l ml mm">template &lt;class ChosenAlgorithm&gt;<br/>std::vector&lt;std::vector&lt;Type&gt;&gt;<br/>GetValidTypes()<br/>{<br/>  return ChosenAlgorithm::supported_types_;<br/>}</span></pre><p id="04fa" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">你可以看到危险，因为你通常想要明确。然而，这也创造了简化的机会。</p><p id="bbd3" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">C++ <strong class="kk io">模板为大量代码重用</strong>打开了大门，在可能的情况下优化我们的程序，使其保持简洁。这篇文章有望打开 C++模板的使用之门，从类模板到模板特殊化等等<em class="lg">还有更多有待发现！</em></p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi na"><img src="../Images/ed564ca36c4df573b16e423155aaaf26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*80FfK5Fkl7Wo6VHu"/></div></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk translated"><a class="ae mc" href="https://unsplash.com/@henniestander?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Hennie Stander </a>在<a class="ae mc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure></div></div>    
</body>
</html>