<html>
<head>
<title>How to Create a Rails API for your Poker App!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何为你的扑克应用创建一个 Rails API！</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-to-create-rails-api-for-your-poker-app-a68c1eb4327c?source=collection_archive---------10-----------------------#2020-06-16">https://blog.devgenius.io/how-to-create-rails-api-for-your-poker-app-a68c1eb4327c?source=collection_archive---------10-----------------------#2020-06-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/6b8888d61d1cb3cd9e5582bf4e57e90d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OcpVmKq7tFfK6BuzbIUbrA.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">口袋 a！</figcaption></figure><p id="a5b4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">对于这篇博文，我想谈谈为玩扑克(德州扑克)创建一个 Rails API。</p><p id="6b98" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我一直在尝试创建一个 React/Rails 应用程序，允许人们实时聊天和玩扑克。我希望能为 poker 数据库找到一个 gem 或 GitHub repo，但是我找不到一个只支持 Rails 的 API，所以我自己创建了这个数据库。</p><p id="e2a0" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">分解扑克游戏的玩法既有挑战性又很有趣；下面是我如何将用户和游戏数据持久化到 Rails 数据库中的。</p><ul class=""><li id="9b08" class="la lb iq ke b kf kg kj kk kn lc kr ld kv le kz lf lg lh li bi translated">我发现<a class="ae lj" href="https://github.com/dilshanraja/Texas-holdem" rel="noopener ugc nofollow" target="_blank">这个回购</a>对扑克游戏的一些逻辑很有帮助。它类似于我正在尝试制作的应用程序。</li><li id="f946" class="la lb iq ke b kf lk kj ll kn lm kr ln kv lo kz lf lg lh li bi translated"><a class="ae lj" href="https://github.com/atribecalledarty/console-poker" rel="noopener ugc nofollow" target="_blank">这里的</a>是 GitHub 的完整项目。</li><li id="ccb9" class="la lb iq ke b kf lk kj ll kn lm kr ln kv lo kz lf lg lh li bi translated"><a class="ae lj" href="https://www.888poker.com/en/texas-holdem-poker-rules.pdf" rel="noopener ugc nofollow" target="_blank">扑克规则的全部细节。</a></li><li id="b030" class="la lb iq ke b kf lk kj ll kn lm kr ln kv lo kz lf lg lh li bi translated"><a class="ae lj" href="https://github.com/Jberczel/holdem" rel="noopener ugc nofollow" target="_blank"> Holdem gem </a>比较扑克手牌。</li></ul><h1 id="f9fd" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">首先是模型和属性。</h1><p id="b56d" class="pw-post-body-paragraph kc kd iq ke b kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ij bi translated">我们有三种不同的模式:<strong class="ke ir">游戏</strong>、<strong class="ke ir">回合、</strong>和<strong class="ke ir">用户</strong>。</p><p id="06f8" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">用户玩一个由许多回合组成的游戏。扑克的主要逻辑包含在回合模型中—回合模型负责处理游戏的状态。</p><p id="388d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">关联:用户模型同时属于游戏和回合模型。游戏和回合模式都有很多用户。</p><p id="954a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="ms">注:我将使用术语“</em> <strong class="ke ir"> <em class="ms">下注回合</em> </strong> <em class="ms">”或“</em> <strong class="ke ir"> <em class="ms">阶段</em> </strong> <em class="ms">”来指代一个阶段，即翻牌前、翻牌圈、转牌圈和河牌圈，而“回合”将用于指代整个扑克回合。</em></p><p id="7826" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">以下是我们需要的用户模型和倒圆角模型的属性:</p><h2 id="1166" class="mt lq iq bd lr mu mv dn lv mw mx dp lz kn my mz md kr na nb mh kv nc nd ml ne bi translated">用户模型</h2><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="nj nk l"/></div></figure><ul class=""><li id="3056" class="la lb iq ke b kf kg kj kk kn lc kr ld kv le kz lf lg lh li bi translated"><strong class="ke ir"> round_bet </strong> = &gt;这样我们就可以跟踪用户每轮下注(即翻牌前、翻牌圈、转牌圈、河牌圈)的当前下注金额</li><li id="1c30" class="la lb iq ke b kf lk kj ll kn lm kr ln kv lo kz lf lg lh li bi translated"><strong class="ke ir">筹码</strong> = &gt;用户拥有的总筹码</li><li id="c105" class="la lb iq ke b kf lk kj ll kn lm kr ln kv lo kz lf lg lh li bi translated"><strong class="ke ir">玩</strong> = &gt;他们是在当前手牌还是已经盖牌？</li><li id="2178" class="la lb iq ke b kf lk kj ll kn lm kr ln kv lo kz lf lg lh li bi translated"><strong class="ke ir">牌</strong> = &gt;用户的两张牌(孔牌)</li></ul><h2 id="620b" class="mt lq iq bd lr mu mv dn lv mw mx dp lz kn my mz md kr na nb mh kv nc nd ml ne bi translated">圆形模型</h2><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="nj nk l"/></div></figure><ul class=""><li id="c761" class="la lb iq ke b kf kg kj kk kn lc kr ld kv le kz lf lg lh li bi translated"><strong class="ke ir">_ playing</strong>=&gt;一轮开始了还是结束了？</li><li id="3be1" class="la lb iq ke b kf lk kj ll kn lm kr ln kv lo kz lf lg lh li bi translated"><strong class="ke ir">状态</strong> = &gt;一个状态消息数组，这样我们就可以很容易地访问游戏的流程(例如“翻牌…，轮到玩家 1…，等等)。)= &gt; <em class="ms">我在我的应用程序中使用这个属性来轻松地向客户端显示游戏状态。</em></li><li id="e488" class="la lb iq ke b kf lk kj ll kn lm kr ln kv lo kz lf lg lh li bi translated"><strong class="ke ir"> small_blind_index </strong> = &gt;游戏的小盲注指数，用于确定每个下注阶段第一个下注的玩家。<em class="ms">(我希望能够指定每轮新扑克的开始玩家，这样我就可以轮流开始每场游戏的小盲注玩家)。</em></li><li id="0bc5" class="la lb iq ke b kf lk kj ll kn lm kr ln kv lo kz lf lg lh li bi translated"><strong class="ke ir">轮到谁了？</strong></li><li id="737f" class="la lb iq ke b kf lk kj ll kn lm kr ln kv lo kz lf lg lh li bi translated"><strong class="ke ir">锅</strong> = &gt;当前锅</li><li id="a498" class="la lb iq ke b kf lk kj ll kn lm kr ln kv lo kz lf lg lh li bi translated"><strong class="ke ir">highest _ bet _ for _ phase</strong>=&gt;跟踪当前一轮下注的赌注</li><li id="0a41" class="la lb iq ke b kf lk kj ll kn lm kr ln kv lo kz lf lg lh li bi translated"><strong class="ke ir">社区 _ 牌</strong> = &gt;社区牌(翻牌、转牌、河牌)</li><li id="e9b4" class="la lb iq ke b kf lk kj ll kn lm kr ln kv lo kz lf lg lh li bi translated"><strong class="ke ir"> all_in </strong> = &gt;有人全押了吗？— <em class="ms">我不想处理对分彩池，所以当有人全押时，就不允许再加注了。让我知道，如果你有一个雄辩的解决方案分裂锅。</em></li><li id="273e" class="la lb iq ke b kf lk kj ll kn lm kr ln kv lo kz lf lg lh li bi translated"><strong class="ke ir">no _ players _ for _ phase&amp;turn _ count</strong>=&gt;(no _ players _ for _ phase 表示一个阶段的玩家人数)。我们使用这些来确保所有玩家都在给定的一轮下注中下注</li></ul><h1 id="21b6" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">创建游戏逻辑:</h1><p id="b349" class="pw-post-body-paragraph kc kd iq ke b kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ij bi translated">在我们开始运行扑克游戏之前，这里有一些关于德州扑克结构的信息。<strong class="ke ir">扑克</strong>共有四轮下注:前翻牌、<strong class="ke ir">翻牌</strong>、<strong class="ke ir">转牌</strong>和<strong class="ke ir">河牌</strong>。<strong class="ke ir">在每轮下注中，行动从“小盲注，</strong>”开始(在翻牌圈，盲注后面的人开始下注)。然后，<strong class="ke ir">每个玩家走一步，直到每个玩家都有机会下注</strong>。<strong class="ke ir">在一轮下注结束之前，每位活跃玩家必须已经下了与该轮下注的最高赌注相等的赌注</strong>。例如，如果最高赌注是 400 英镑，那么在一轮下注结束之前，每个没有弃牌的玩家都必须投入 400 英镑。</p><p id="5372" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir"/><strong class="ke ir">一场扑克游戏只能以两种方式结束:所有下注回合都已结束，或者除了一名玩家之外所有玩家都弃牌</strong>。因此，在每个玩家的回合之后，我们将检查这些条件中的任何一个。我们还会在每一轮结束后查看一个下注阶段是否结束，以开始下一个阶段。</p><h2 id="de4c" class="mt lq iq bd lr mu mv dn lv mw mx dp lz kn my mz md kr na nb mh kv nc nd ml ne bi translated">每个玩家回合后要检查的条件:</h2><ol class=""><li id="61fb" class="la lb iq ke b kf mn kj mo kn nl kr nm kv nn kz no lg lh li bi translated">除了一个玩家，其他玩家都弃牌了吗？= &gt;给最后一名玩家奖金</li><li id="5e77" class="la lb iq ke b kf lk kj ll kn lm kr ln kv lo kz no lg lh li bi translated">最后一轮下注结束了吗？= &gt;执行摊牌=决定赢家并分配奖金</li><li id="896b" class="la lb iq ke b kf lk kj ll kn lm kr ln kv lo kz no lg lh li bi translated">当前一轮下注结束了吗？= &gt;开始下一轮下注</li></ol><p id="6cc5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这基本上是整个游戏流程的逻辑。我们只需开始游戏，发牌(我们稍后会讨论如何处理牌)，收集盲注，然后等待玩家的行动。每回合后，我们检查回合属性和玩家属性，以确定游戏的状态。</p><h1 id="ac9b" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">圆形型号代码:</h1><h2 id="6062" class="mt lq iq bd lr mu mv dn lv mw mx dp lz kn my mz md kr na nb mh kv nc nd ml ne bi translated">常数:</h2><p id="e94c" class="pw-post-body-paragraph kc kd iq ke b kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ij bi translated">阶段:0 = &gt;翻牌圈，1 = &gt;翻牌圈，2 = &gt;转牌圈，3 = &gt;河牌圈。</p><p id="7004" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">盲注被硬编码为 200 和 400。</p><h2 id="87bb" class="mt lq iq bd lr mu mv dn lv mw mx dp lz kn my mz md kr na nb mh kv nc nd ml ne bi translated">我们将需要的方法:</h2><ul class=""><li id="ef51" class="la lb iq ke b kf mn kj mo kn nl kr nm kv nn kz lf lg lh li bi translated"><strong class="ke ir">轮到</strong> = &gt;轮到谁了？</li><li id="ff27" class="la lb iq ke b kf lk kj ll kn lm kr ln kv lo kz lf lg lh li bi translated"><strong class="ke ir"> active_players </strong> = &gt;未折叠的用户数组(按 id 排序)</li><li id="8913" class="la lb iq ke b kf lk kj ll kn lm kr ln kv lo kz lf lg lh li bi translated"><strong class="ke ir">access_community_cards</strong>=&gt;游戏开始时，所有的社区卡(五张)都会被分发，access _ community _ cards 用于确定当前阶段有哪些卡可用。(卡片将采用“<code class="fe np nq nr ns b">Ac 7d 4c Td Qc".</code>”格式)。</li><li id="b37f" class="la lb iq ke b kf lk kj ll kn lm kr ln kv lo kz lf lg lh li bi translated"><strong class="ke ir">阶段 _ 完成了？</strong> = &gt;要不要进入下一个投注阶段？<br/>由两个条件决定:<br/> 1)回合数(turn _ count)&gt;no _ players _ for _ phase(表示每个人都获得了下注的机会)<br/> 2) <strong class="ke ir"> players_have_bet？</strong> = &gt;所有玩家的回合赌注等于当前赌注或最高 _bet_for_phase</li></ul><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="nj nk l"/></div></figure><h1 id="1e2e" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">开始</h1><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="a6b3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">当回合开始时:</p><ul class=""><li id="58e7" class="la lb iq ke b kf kg kj kk kn lc kr ld kv le kz lf lg lh li bi translated"><strong class="ke ir">为用户设置所有相关属性</strong>。<br/> <em class="ms">注意:在我的应用程序中，在一轮开始时，该轮将有权访问它的游戏，而游戏也有权访问它的玩家。当回合开始时，我需要抓取游戏的玩家，并将每个玩家的 round_id 设置为回合。</em></li><li id="a046" class="la lb iq ke b kf lk kj ll kn lm kr ln kv lo kz lf lg lh li bi translated">将<strong class="ke ir"> is_playing </strong>设置为真。</li><li id="afa2" class="la lb iq ke b kf lk kj ll kn lm kr ln kv lo kz lf lg lh li bi translated">然后，<strong class="ke ir">摆牌</strong>和<strong class="ke ir">开始第一轮下注</strong>。</li></ul><h1 id="e484" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">套装 _ 卡片</h1><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="nj nk l"/></div></figure><ul class=""><li id="21ac" class="la lb iq ke b kf kg kj kk kn lc kr ld kv le kz lf lg lh li bi translated">添加状态。</li><li id="01c9" class="la lb iq ke b kf lk kj ll kn lm kr ln kv lo kz lf lg lh li bi translated"><strong class="ke ir">发牌社区牌和发牌玩家牌</strong>。我们使用格式'<em class="ms"> Ns，'</em>来表示一张牌，其中 N =数字，s =小写字母。稍后，我们使用宝石“holdem”来决定使用这种形式的最佳手牌。参见<a class="ae lj" href="https://github.com/Jberczel/holdem" rel="noopener ugc nofollow" target="_blank">‘holdem’自述</a>查看手部构造和对比细节。</li></ul><h1 id="5c01" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">开始 _ 下注 _ 回合</h1><p id="1528" class="pw-post-body-paragraph kc kd iq ke b kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ij bi translated">调用 start_betting_round()开始每一轮下注(翻牌前、翻牌圈、转牌圈和河牌)。</p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="nj nk l"/></div></figure><ul class=""><li id="e074" class="la lb iq ke b kf kg kj kk kn lc kr ld kv le kz lf lg lh li bi translated">添加下注回合状态的案例陈述。</li><li id="7ab7" class="la lb iq ke b kf lk kj ll kn lm kr ln kv lo kz lf lg lh li bi translated">将活动用户的“<strong class="ke ir"> round_bet </strong>”重置为 0。记住 round_bet 是用户对下注回合的下注。</li><li id="a3dc" class="la lb iq ke b kf lk kj ll kn lm kr ln kv lo kz lf lg lh li bi translated">设置<strong class="ke ir"> no_players_for_phase </strong>。(该阶段的玩家人数)</li><li id="7f52" class="la lb iq ke b kf lk kj ll kn lm kr ln kv lo kz lf lg lh li bi translated">重置当前下注(<strong class="ke ir">最高 _ 下注 _ 相位</strong>和<strong class="ke ir">回合 _ 计数</strong>)。</li><li id="d2bd" class="la lb iq ke b kf lk kj ll kn lm kr ln kv lo kz lf lg lh li bi translated">并设置<strong class="ke ir">转位</strong>。(每轮下注期间，small_blind_index 开始动作。)</li><li id="5978" class="la lb iq ke b kf lk kj ll kn lm kr ln kv lo kz lf lg lh li bi translated"><strong class="ke ir">如果 phase == 0(翻牌前)，为前两名玩家下盲注。</strong></li></ul><h1 id="8a73" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">user . make _ move &amp; round . make _ player _ move</h1><p id="7670" class="pw-post-body-paragraph kc kd iq ke b kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ij bi translated">在我的应用中，<strong class="ke ir">“移动”是由轮到它的玩家做出的，而不是回合本身。我认为这个架构作为游戏的隐喻更有意义。<strong class="ke ir">玩家在游戏中出招。</strong></strong></p><p id="38f4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir"> user.make_move('call') </strong>是我们向回合提交移动的方式。这将调用回合方法<strong class="ke ir">make _ player _ move(‘call’)。</strong></p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="eb0d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">… make_player_move:</p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="add9" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir"> next_turn() </strong>通过递增 turn_index 和 turn_count 来设置下一轮。<em class="ms">注意:接受 blinds 布尔值，当 blinds = true 时，不会增加 turn_count。</em></p><p id="dfdd" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir"> make_player_move() </strong>带三个 arg，两个可选。</p><p id="3f68" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">(1)命令名，(2)加注量，以及(3)加注 Blinds 布尔值。</p><p id="752b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">例如 make_player_move('raise '，SMALL_BLINDS，true) <br/>例如 make_player_move('fold ')</p><p id="2211" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="ms">我们需要 blinds boolean，这样当前两名玩家在翻牌前自动加注盲注时，这些“移动”就不会算作回合。请记住，在翻牌前，“第一个”下注的人是盲注之后的人。</em></p><p id="8e2e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">然后，我们对每种命令类型都有一个 if-else 语句。</p><p id="d543" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">最后，<strong class="ke ir">这里是控制游戏流程的东西:</strong>在每一个回合之后，我们检查(1)游戏是否结束了？或者(2)下注阶段结束了？</p><ol class=""><li id="a2b7" class="la lb iq ke b kf kg kj kk kn lc kr ld kv le kz no lg lh li bi translated"><strong class="ke ir">除了一个人都折了？</strong> <strong class="ke ir">如果有，end_game_by_fold。</strong></li><li id="34a2" class="la lb iq ke b kf lk kj ll kn lm kr ln kv lo kz no lg lh li bi translated"><strong class="ke ir">投注回合结束？</strong> <strong class="ke ir">如果是，调用 initiate_next_phase </strong>。</li></ol><p id="050d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">initiate _ next _ phase()</strong>=&gt;如果有人全押，或者如果当前阶段是最后一个阶段，则进入“<strong class="ke ir">摊牌</strong>”，这是玩家手牌的对决，并决定赢家。否则，开始下一个投注阶段。</p><p id="a04e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">为了缩短这篇博文，我不会去实现每一种移动。</p><p id="3713" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><a class="ae lj" href="https://gist.github.com/atribecalledarty/8b016826c07fac1b4a62ded2e200cbb4" rel="noopener ugc nofollow" target="_blank"> <em class="ms">这里是</em> </a> <em class="ms">对每个命令的完整 make_player_move 方法。</em></p><p id="791b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">有几件事要注意:</p><ul class=""><li id="56c3" class="la lb iq ke b kf kg kj kk kn lc kr ld kv le kz lf lg lh li bi translated"><em class="ms">当最后一个被索引的人弃牌时，我们需要将 turn_index 重置为 0。</em></li><li id="43be" class="la lb iq ke b kf lk kj ll kn lm kr ln kv lo kz lf lg lh li bi translated"><em class="ms">确保“叫牌”、“检查”和“加注”动作有效。</em></li><li id="a429" class="la lb iq ke b kf lk kj ll kn lm kr ln kv lo kz lf lg lh li bi translated"><strong class="ke ir"> <em class="ms">确保所有玩家都能负担得起任何人可以加注的最高金额</em></strong><em class="ms">——我们这样做是为了避免底池分裂。</em></li><li id="ae75" class="la lb iq ke b kf lk kj ll kn lm kr ln kv lo kz lf lg lh li bi translated"><em class="ms">在“跟注”和“加注”期间，检查玩家是否全押(因为在下注阶段结束时，如果有人全押，我们就会摊牌。)</em></li></ul><h1 id="c323" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">摊牌</h1><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="nj nk l"/></div></figure><h2 id="d64e" class="mt lq iq bd lr mu mv dn lv mw mx dp lz kn my mz md kr na nb mh kv nc nd ml ne bi translated">1.确定获胜玩家:</h2><p id="0261" class="pw-post-body-paragraph kc kd iq ke b kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ij bi translated">为了确定获胜的玩家，我们需要一组最好的手牌和最好的玩家。</p><p id="2d0a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">迭代剩余的玩家:</p><ol class=""><li id="2701" class="la lb iq ke b kf kg kj kk kn lc kr ld kv le kz no lg lh li bi translated">使用玩家卡和社区卡创建一个 Holdem::PokerHand.new。<br/> <strong class="ke ir">注意:包含在 Gemfile </strong> <code class="fe np nq nr ns b"><strong class="ke ir">gem ‘holdem’</strong></code> <strong class="ke ir">和</strong> <code class="fe np nq nr ns b"><strong class="ke ir">run bundle install</strong></code> <br/> <em class="ms">构造器从字符串创建一手牌，例如“4c Kc 4h 5d 6s Kd Qs”<br/>你可以比较两个不同的手牌&gt;、&lt;或==。<br/> </em> <a class="ae lj" href="https://github.com/Jberczel/holdem" rel="noopener ugc nofollow" target="_blank"> <em class="ms">查看文档</em> </a> <em class="ms">了解更多详情。</em></li><li id="a703" class="la lb iq ke b kf lk kj ll kn lm kr ln kv lo kz no lg lh li bi translated">如果该玩家是第一个玩家，则将他们和他们的手牌添加到最佳玩家和最佳手牌中。</li><li id="3827" class="la lb iq ke b kf lk kj ll kn lm kr ln kv lo kz no lg lh li bi translated">将每个人的手牌与当前的最佳手牌进行比较，并添加或重置最佳手牌&amp;最佳玩家。</li></ol><p id="9b9e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">花点时间理解这里的逻辑。我们最终拥有一批最好的手牌和最好的玩家。</p><h2 id="37c4" class="mt lq iq bd lr mu mv dn lv mw mx dp lz kn my mz md kr na nb mh kv nc nd ml ne bi translated">2.分配奖金并结束游戏</h2><p id="6e32" class="pw-post-body-paragraph kc kd iq ke b kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ij bi translated">用于添加状态消息的 if 语句。<strong class="ke ir">向赢家支付底池奖金。</strong>最后，<strong class="ke ir">设置 is_playing = false。</strong></p></div><div class="ab cl nt nu hu nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="ij ik il im in"><p id="0be9" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">最后，我们成功了！我们可以成功地玩完一整轮扑克，每个玩家的走法都保存在数据库中。</p><p id="c3d3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">一个简单的用法示例:</p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="449d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们并没有真正谈论状态信息，因为我想把注意力集中在游戏的结构上。在 round_instance.status 中跟踪状态消息使我们能够很容易地将游戏的流程传达给客户端。</p><p id="236f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">关于扑克逻辑需要记住的一些事情:游戏只能以两种方式结束。摊牌(所有下注回合都已结束)或还剩一名玩家。当用户提交移动时，回合模型检查自身及其用户的属性，以确定游戏的状态。</p><p id="1d20" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这是我第一次想出的解决方案。我认为可以有一些改进:具体来说，减少圆形模型的属性。让我知道我是否能做任何改进！</p><p id="6683" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">你可以在<a class="ae lj" href="https://github.com/atribecalledarty/console-poker" rel="noopener ugc nofollow" target="_blank">我的完整项目</a>中查看模型和迁移。</p></div></div>    
</body>
</html>