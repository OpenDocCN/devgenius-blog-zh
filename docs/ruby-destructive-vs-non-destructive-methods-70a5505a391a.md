# Ruby:破坏性方法与非破坏性方法

> 原文：<https://blog.devgenius.io/ruby-destructive-vs-non-destructive-methods-70a5505a391a?source=collection_archive---------2----------------------->

![](img/6200bc51ca4327bef729366be1cf1e6d.png)

奥斯卡·伊尔迪兹在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄的照片

今天我想谈谈 Ruby 中的破坏性和非破坏性方法。为了做到这一点，我们需要理解什么是对象 id。Ruby 中的每个对象都有一个唯一的标识符，称为对象 id。这可以通过在对象上调用#object_id 方法来访问。对于不可变的对象，如整数和符号，与对象 id 相关联的值不能改变。例如:

```
Output:x = 2Object_id = 5x = 6Object_id = 13
```

首先，变量 **x** 被初始化为 2，其对象 id 为 **5。然后，我们加上 4，这样 **x** 等于 6。对象 id 现已更改为 **13** 。这是因为在第 4 行，我们将 **x** 重新分配给 **x + 4** 或 6。在 Ruby 中，整数是不可变的，这意味着它们不能改变。因此，如果不改变对象 id，就不可能改变 **x** 的值。符号也是如此。但是字符串、数组和散列是可变的，这意味着它们可以被改变。例如:**

```
Output:string = HelloObject_id = 70331830343140string = Hello WorldObject_id = 70331830343140
```

在这种情况下，我们改变了字符串变量的值，但是保持对象 id 不变。这是因为 **# < <** 方法改变了它所调用的对象，而不是将变量重新分配给一个新的对象。

现在我们已经讨论了对象 id，我们可以定义一个破坏性的方法。在 Ruby(和其他语言)中，破坏性方法是一种变异它所调用的对象的方法。例如，上一个示例中的 **# < <** 方法是一个破坏性方法，因为它变异了调用它的字符串对象。这是另一个使用数组的破坏性方法的例子。

```
Output: array = [4, 2, 3, 1, 5]Object_id = 70141400757740array = [1, 2, 3, 4, 5]Object_id = 70141400757740
```

请注意“！”**#排序结束！**方法。这表明这种方法是破坏性的。许多破坏性方法都有一个“！”最后，但不是所有人都这样做，请务必检查文档。文档用小箭头表示方法的返回值。点击[这个链接](https://docs.ruby-lang.org/en/2.6.0/Array.html#method-i-sort)明白我的意思。非破坏性的 **#sort** 方法显示返回‘new _ ary’，而破坏性的 **#sort！**方法只显示' ary '被返回。需要注意的是，你不能只加一个“！”让它具有破坏性的方法。这是以不同方式实现的两个独立的方法，并非所有方法都有这两种实现。现在，让我们看看非破坏性方法是如何工作的。

```
Output:array = [4, 2, 3, 1, 5]Object_id = 70101328557600array = [4, 2, 3, 1, 5]Object_id = 70101328557600
```

而且…看起来好像什么都没发生。实际上，尽管如此， **#sort** 方法还是像预期的那样工作。因为它不是一个破坏性的方法，所以它返回一个新的排序数组，而不是改变原始数组。然而，我们没有捕获返回值，这使得我们的代码实际上毫无用处。以下是我们可以做的。

```
Output: array = [4, 2, 3, 1, 5]Object_id = 70267318031780array = [4, 2, 3, 1, 5]sorted_array = [1, 2, 3, 4, 5]Object_id = 70267318031460
```

这次我们在一个名为 **sorted_array** 的变量中捕获了返回值。这是一个具有自己的对象 id 的新对象，如输出的最后一行所示。现在我们已经看到了 Ruby 中一些内置的破坏性和非破坏性方法，让我们试着创建自己的方法。你认为下面的代码会输出什么？

```
Output: HelloHello
```

程序输出“Hello”两次，因为我们的方法实际上并没有改变字符串。相反，它会将其重新分配给一个新字符串“Hello World”因为我们没有捕获方法的返回值，所以我们看不到任何变化。对代码进行快速更新可以解决这个问题。

```
Output: HelloObject id = 70312641836240Hello WorldObject id = 70312641836240
```

现在我们的方法是破坏性的，它改变了我们传递给它的字符串。这是因为我们在自定义方法中使用了破坏性的 **# < <** 方法。我们可以通过检查对象 id 是否仍然相同来确认这一点。一般来说，如果我们在自定义方法中调用一个破坏性方法，那么自定义方法也将是破坏性的。然而，也有一些例外。看看下面的例子。在向下滚动之前，尝试猜测它将输出什么。

```
Output:HelloHello
```

这个有点棘手，让我们把它分成小块。首先，我们将变量**字符串**初始化为“Hello”。然后我们定义**问候**的方法。之后，我们调用**字符串**上的方法。在我们方法的第一行，我们将变量**字符串**重新赋值为“Hello goodbye”。这意味着当我们在方法的第二行调用破坏性方法 **# < <** 时，我们是在新对象“Hello goodbye”上调用它。正因为如此，我们原来的字符串没有改变。这可以通过对象 id 更清楚地显示出来。

```
Output: HelloObject_id = 70260376327360Object_id = 70260376327160Hello
```

如您所见，在我们将字符串重新赋值为“hello goodbye”之后，对象 id 发生了变化。

希望你现在对破坏性和非破坏性方法有了更好的理解。学习这个概念是很重要的，这样你就能理解什么时候你可以调用一个方法，什么时候你需要获取返回值。当你的程序产生意想不到的结果时，它还可以帮助你追踪错误。感谢您的阅读，祝您编码愉快！