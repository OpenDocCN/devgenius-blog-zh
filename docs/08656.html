<html>
<head>
<title>Segment Tree — Unravelled</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">细分树-未展开</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/segment-tree-unravelled-370f4754b074?source=collection_archive---------17-----------------------#2022-06-30">https://blog.devgenius.io/segment-tree-unravelled-370f4754b074?source=collection_archive---------17-----------------------#2022-06-30</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/bc7d2dd2872e3d7fbe20c926c566ade7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ivMJFEQhOna6XmWH58yNFw.jpeg"/></div></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk translated"><a class="ae ja" href="https://unsplash.com/@zoo_monkey?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">动物园 _ 猴子</a>在<a class="ae ja" href="https://unsplash.com/s/photos/bamboo?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><div class=""/><p id="cc54" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">更快的范围查询</p><p id="ae21" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">段树是一种灵活的基于树的数据结构，允许有效地回答数组上的范围查询。它还允许修改数组。这种数据结构采用了两种好的算法策略 1。预计算所需的查询 2。分而治之。它在输入的较小部分上计算期望的结果。</p><p id="c4e0" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">假设我们有一个数组:2，3，-1，5，-2，4，8，10。</p><h2 id="a2bd" class="ky kz jd bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">构建树</h2><p id="6ae3" class="pw-post-body-paragraph ka kb jd kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">为了构建树，我们通过将范围减半来连续构建左右树。当我们到达范围的开始和结束相同的叶节点时，我们将节点的值设置为数组索引值(A[start])。然后我们回到父节点，将其值设置为子节点的 min。</p><figure class="lx ly lz ma gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi lw"><img src="../Images/7b43c38a79ce3e9a0d1b8eb1a57ec51d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N_y0YKULktucJXmtvie9jg.png"/></div></div></figure><p id="29b3" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">上图显示了用于查找各种范围最小值的段树。它有 2N-1 个节点，N 是数组的大小。</p><figure class="lx ly lz ma gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi mb"><img src="../Images/a159722ebc75b00202599b448d3357d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tJ0RylriSCh5K8GuJBtQyA.png"/></div></div></figure><h2 id="5d23" class="ky kz jd bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">询问</h2><p id="3ace" class="pw-post-body-paragraph ka kb jd kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">为了查询，我们遍历树并寻找重叠的区间。那里有三个箱子:</p><ol class=""><li id="e9e7" class="mc md jd kc b kd ke kh ki kl me kp mf kt mg kx mh mi mj mk bi translated">重叠→我们左右遍历</li><li id="5f49" class="mc md jd kc b kd ml kh mm kl mn kp mo kt mp kx mh mi mj mk bi translated">外部→回到父级</li><li id="8b7e" class="mc md jd kc b kd ml kh mm kl mn kp mo kt mp kx mh mi mj mk bi translated">完全在范围内→取节点的值并返回到父节点</li></ol><figure class="lx ly lz ma gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi mq"><img src="../Images/a0bdc3eacc8852e7dd709bd430eef7f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jiFpmmUk_Xyj7_XNPbKRDA.png"/></div></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk translated">分段树查询遍历</figcaption></figure><p id="7aa6" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">查询的参与者节点</p><figure class="lx ly lz ma gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi mr"><img src="../Images/13895c074521fd12f8139b6fb45d0dd6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eLMI-gtbcXrOLbVJrsIMlA.png"/></div></div></figure><h2 id="9b26" class="ky kz jd bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">更新</h2><p id="e0d9" class="pw-post-body-paragraph ka kb jd kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">为了更新索引，我们继续遍历或索引所在的一半，并继续直到我们到达范围具有单个元素的地方(start == end)。一旦我们读取了这个节点，我们就更新了那个引导节点的值。遍历回父节点，根据其子节点值更新节点值。</p><figure class="lx ly lz ma gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi ms"><img src="../Images/1caf877668110fd2ea50f8c78c0bab92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NHQT72FRGYTE_qI28eg7pA.png"/></div></div></figure><p id="c939" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">问题:</p><p id="108a" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">给定一个大小为<strong class="kc je"> N </strong>的整数数组<strong class="kc je"> A </strong>。您必须执行两种类型的查询，在每个查询中，您会得到三个整数 x、y 和 z。如果<strong class="kc je"> x = 0 </strong>，则更新<strong class="kc je"> A[y] = z </strong>。如果<strong class="kc je"> x = 1 </strong>，则输出数组<strong class="kc je"> A </strong>中索引<strong class="kc je"> y </strong>和<strong class="kc je"> z </strong>之间的最小元素。查询由大小为 M x 3 的二维 T21 数组表示，其中 B[i][0]表示 x，B[i][1]表示 y，B[i][2]表示 z</p><pre class="lx ly lz ma gt mt mu mv mw aw mx bi"><span id="9fab" class="ky kz jd mu b gy my mz l na nb">A = [1, 4, 1]<br/>B = [[1, 1, 3], [0, 1, 5], [1, 1, 2]] <br/>OP =  [1, 4]</span></pre><p id="3ad2" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">代码实现(使用数组)</p><pre class="lx ly lz ma gt mt mu mv mw aw mx bi"><span id="d7c8" class="ky kz jd mu b gy my mz l na nb">import math<br/>class Solution:<br/>    # <a class="ae ja" href="http://twitter.com/param" rel="noopener ugc nofollow" target="_blank">@param</a> A : list of integers<br/>    # <a class="ae ja" href="http://twitter.com/param" rel="noopener ugc nofollow" target="_blank">@param</a> B : list of list of integers<br/>    # <a class="ae ja" href="http://twitter.com/return" rel="noopener ugc nofollow" target="_blank">@return</a> a list of integers<br/>    def buildSegmentTree(self, A, idx, s, e):<br/>        if s == e:<br/>            self.seg_tree[idx] = A[s]<br/>        else:<br/>            mid = (s+e)//2<br/>            l = idx*2+1<br/>            r = idx*2+2<br/>            self.buildSegmentTree(A, l, s, mid)<br/>            self.buildSegmentTree(A, r, mid+1, e)<br/>            self.seg_tree[idx] = min(self.seg_tree[l], self.seg_tree[r])<br/>    <br/>    def update(self, idx, s, e, index, val):<br/>        if s == e:<br/>            self.seg_tree[idx] = val<br/>            return<br/>        <br/>        mid = (s+e)//2<br/>        l = idx*2+1<br/>        r = idx*2+2<br/>        lc, rc = self.seg_tree[l], self.seg_tree[r]<br/>        if index &lt;= mid:<br/>            self.update(l, s, mid, index, val)<br/>            lc = self.seg_tree[l]<br/>        else:<br/>            self.update(r, mid+1, e, index, val)<br/>            rc = self.seg_tree[r]</span><span id="5ec9" class="ky kz jd mu b gy nc mz l na nb">        self.seg_tree[idx] = min(lc, rc)<br/>    <br/>    def getMin(self, idx, s, e, l,  r):<br/>        if (l &lt;= s and r &gt;=e):<br/>            return self.seg_tree[idx]<br/>        if (l&gt;e or r&lt;s):<br/>            return math.inf<br/>        mid = (s+e)//2<br/>        lc = 2*idx+1<br/>        rc = lc+1<br/>        return min(self.getMin(lc, s, mid, l, r), self.getMin(rc, mid+1, e, l, r))</span><span id="f9a7" class="ky kz jd mu b gy nc mz l na nb">    def solve(self, A, B):<br/>        n = len(A)<br/>        self.seg_tree = [0] * (4*n)<br/>        self.buildSegmentTree(A, 0, 0, n-1)<br/>        res = []</span><span id="bcb1" class="ky kz jd mu b gy nc mz l na nb">        for x, y, z in B:<br/>            if x == 0:<br/>                self.update(0, 0, n-1, y-1, z)<br/>            else:<br/>                z -= 1<br/>                res.append(self.getMin(0, 0, n-1, y-1, z))<br/>        return res</span></pre><p id="de78" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们使用 4*n 大小的数组。为了得到这个上限，观察树的高度是⌈log2n⌉，深度 h 的水平上最右边的节点位于数组中的位置 2^(h+1-1。这是使用以下等式推导出来的。</p><p id="b597" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">s(n)≤(2 ^(⌈log2n⌉+1))−1<br/>&lt;2⋅(2^⌈log2n⌉)<br/>=4⋅2^(⌈log2n⌉−1)<br/>≤4⋅2^(⌊log2n⌋)<br/>≤4n</p><p id="d8b4" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">此外，树的数组表示使用(idx*2+1)和(idx*2+2)来存储索引(idx)处的节点的子节点。</p><p id="1eb3" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">编码快乐！！</p></div></div>    
</body>
</html>