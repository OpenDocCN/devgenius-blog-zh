<html>
<head>
<title>Best of Modern JavaScript — Class Safety and Pros and Cons</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">现代JavaScript的精华——一流的安全性和优缺点</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/best-of-modern-javascript-class-safety-and-pros-and-cons-90141019e2af?source=collection_archive---------4-----------------------#2020-10-23">https://blog.devgenius.io/best-of-modern-javascript-class-safety-and-pros-and-cons-90141019e2af?source=collection_archive---------4-----------------------#2020-10-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/91789cd80c076835c59bfd88a5905144.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xepoXUXqvoa-YK6k"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://unsplash.com/@yakimadesign?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">乔丹·罗兰</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="0ba9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">自2015年以来，JavaScript有了巨大的进步。</p><p id="c894" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在用起来比以前舒服多了。</p><p id="193a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将看看如何用JavaScript定义类。</p><h1 id="8ccc" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">安全检查</h1><p id="4240" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">JavaScript解释器在实例化类时会做一些安全检查。</p><p id="e3f9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">this</code>最初在派生构造函数中未初始化意味着如果我们试图在子类中调用<code class="fe me mf mg mh b">super</code>之前访问<code class="fe me mf mg mh b">this</code>将会抛出错误。</p><p id="7732" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当<code class="fe me mf mg mh b">this</code>被初始化时，调用<code class="fe me mf mg mh b">super</code>会产生一个<code class="fe me mf mg mh b">ReferenceError</code>，因为<code class="fe me mf mg mh b">super</code>已经被调用来初始化<code class="fe me mf mg mh b">this</code>。</p><p id="6fd3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果构造函数返回一个非对象，那么抛出一个<code class="fe me mf mg mh b">TypeError</code>。</p><p id="9912" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果一个构造函数显式地返回一个对象，那么它就被用作结果。</p><p id="7e92" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种情况下<code class="fe me mf mg mh b">this</code>初始化与否并不重要。</p><h1 id="cf03" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">extends关键字</h1><p id="148b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们扩展的值必须是一个构造函数。</p><p id="f010" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是，<code class="fe me mf mg mh b">null</code>是允许的。</p><p id="c9fb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="299a" class="mq lc iq mh b gy mr ms l mt mu">class Foo extends Bar {}</span></pre><p id="53e3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">鉴于<code class="fe me mf mg mh b">Bar</code>是一个构造函数。</p><p id="c428" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这种情况下,<code class="fe me mf mg mh b">Foo.prototype</code>应该是<code class="fe me mf mg mh b">Bar</code>。</p><p id="fc6d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="bee6" class="mq lc iq mh b gy mr ms l mt mu">class Foo extends Object {}</span></pre><p id="52fc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于<code class="fe me mf mg mh b">Object</code>是构造函数。</p><p id="b5a3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这种情况下，<code class="fe me mf mg mh b">Foo.prototype</code>应该是<code class="fe me mf mg mh b">Object</code>。</p><p id="8d5a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="ee25" class="mq lc iq mh b gy mr ms l mt mu">class Foo extends null {}</span></pre><p id="6a56" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么<code class="fe me mf mg mh b">Foo.prototype</code>就是<code class="fe me mf mg mh b">null</code>。</p><h1 id="d26d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">在方法中引用基类属性</h1><p id="8c0a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以在方法中引用基类属性。</p><p id="d070" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="6ce3" class="mq lc iq mh b gy mr ms l mt mu">class Person {<br/>  constructor(name) {<br/>    this.name = name;<br/>  }</span><span id="0ba4" class="mq lc iq mh b gy mv ms l mt mu">  toString() {<br/>    return `${this.name}`;<br/>  }<br/>}</span></pre><p id="cdb2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以通过编写以下代码为<code class="fe me mf mg mh b">Person</code>创建一个子类:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="3878" class="mq lc iq mh b gy mr ms l mt mu">class Student extends Person {<br/>  constructor(name, grade) {<br/>    super(name);<br/>    this.grade = grade;<br/>  }<br/>  <br/>  toString() {<br/>    return `${super.toString()} (${this.grade})`;<br/>  }<br/>}</span></pre><p id="872a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们创建<code class="fe me mf mg mh b">toString</code>来创建一个用<code class="fe me mf mg mh b">super.toString</code>调用<code class="fe me mf mg mh b">Person</code>的<code class="fe me mf mg mh b">toString</code>方法的方法。</p><p id="3ff1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是通过在原型链上搜索<code class="fe me mf mg mh b">toString</code>方法来获得<code class="fe me mf mg mh b">toString</code>方法并调用它来完成的。</p><p id="92bb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果找到了，就调用这个方法。</p><p id="4b47" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这与我们在ES5或更早版本中所做的不同。</p><p id="6682" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在早期版本中，我们用<code class="fe me mf mg mh b">call</code>方法调用超类方法。</p><p id="a47d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="b2b1" class="mq lc iq mh b gy mr ms l mt mu">var result = Person.prototype.toString.call(this);</span></pre><p id="0621" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在ES6或更高版本中，我们可以看到，我们不必直接引用父类。</p><p id="9191" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们就用<code class="fe me mf mg mh b">super</code>。</p><p id="fb01" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">super</code>可用于子类方法和构造函数。</p><p id="b40c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们不能在函数声明中使用。</p><p id="ce78" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用<code class="fe me mf mg mh b">super</code>的方法不能移动。</p><p id="4ae1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它与创建它的对象相关联。</p><h1 id="5850" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">班级的利弊</h1><p id="74ad" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">上课有好处也有坏处。</p><p id="6fce" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">类语法使得构造函数看起来更像基于类的语言中的类。</p><p id="f968" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">非传统的继承模式让许多人感到困惑。</p><p id="5c82" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它隐藏了管理原型和构造函数的复杂性。</p><p id="714d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">类与任何当前代码都是向后兼容的，所以不会引入重大的变化。</p><p id="6a6a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">类语法支持子类化。</p><p id="11de" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">初学者也更容易理解类语法而不是原型。</p><p id="a567" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">继承不需要库，这很好。</p><p id="7422" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这使得它们更便于携带。</p><p id="93b3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们也为更高级的OOP特性提供了基础，比如traits和mixins。</p><p id="8554" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">还可以使用ide、文本编辑器等等更容易地对类进行静态分析。</p><p id="9fb5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，它们确实隐藏了JavaScript面向对象模型的真实本质。</p><p id="72c9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JavaScript类看起来像它自己的实体，但它实际上是一个函数。</p><p id="0e9d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，由于向后兼容性的需要，JavaScrtipt类不可能是一个全新的实体。</p><p id="5e79" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是使类语法与现有代码一起工作的一种折衷。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/60cf20a3783bc7712e407f2de55522b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7Rzie0LONYbv2aT_"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@freestocks?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> freestocks </a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><h1 id="e21c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="40b6" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">JavaScript解释器为我们提供了对类的安全检查。</p><p id="9dca" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，类语法也有优点和缺点。</p></div></div>    
</body>
</html>