# 软件设计原则

> 原文：<https://blog.devgenius.io/software-design-principles-ccc3913bfd56?source=collection_archive---------2----------------------->

软件设计是给人类的。这意味着我们创造设计，让人们更好地理解事情是如何工作的，让他们容易地改变我们的代码或增加更多的功能。关键是，你知道如何引导你的决定吗？

![](img/575fc0dc7d4611c9c8420eae9a52d3e7.png)

当我和其他工程师谈论设计时，我通常会遵循一些我认为有用的设计原则来解释我的观点。我注意到并不是每个人都知道它们，但我认为它们对做决定很有帮助。

## 责任

我认为，当我们编写软件时，需要回答的一个更重要的问题是哪个(模块、类或文件)负责做我想做的事情。为了帮助我们做到这一点，我们可以使用 [**抓**](https://en.wikipedia.org/wiki/GRASP_(object-oriented_design)) 的模式。所有这些都很有帮助，但我想强调一些:

*   信息专家:行为用行为管理的数据去对象。
*   创建者:谁创建了对象 A？一般来说，如果满足以下一个或多个条件，则分配给类 B 创建对象 A 的职责:
    —B 的实例包含或复合聚合 A 的实例
    —B 的实例记录 A 的实例
    —B 的实例紧密使用 A 的实例
    —B 的实例拥有 A 实例的初始化信息，并在创建时传递它。
*   耦合:我们系统的一个单元与我们系统的其他单元有多大的关联。例如，如果一个类使用另一个类，那么这个类就是与另一个类耦合的。低耦合可以帮助你插拔组件，它将简化你代码的修改部分。
*   高内聚:一个单元、模块或类与正在使用的数据的相关程度。例如，在一个有三个属性的类中，如果大多数方法只使用两个属性，并且只有一个方法使用另一个属性，那么这个信息和这个方法可能与这个类无关，这就是一个低内聚的例子。这个原则可以帮助你找到新的类或方法来负责我们在一个类中所做的事情。

[**扎实的**](https://en.wikipedia.org/wiki/SOLID) 原则也会帮助你理解设计中的问题:

*   s:[单一责任原则](https://en.wikipedia.org/wiki/Single-responsibility_principle):“一个[类](https://en.wikipedia.org/wiki/Class_(computer_programming))的改变不应该有一个以上的原因。”换句话说，每个类应该只有一个责任。
*   o:[开闭原则](https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle):“软件实体…应该对扩展开放，但对修改关闭。”
*   l:[利斯科夫替换原则](https://en.wikipedia.org/wiki/Liskov_substitution_principle):“使用指向基类的指针或引用的函数必须能够在不知道的情况下使用派生类的对象。”
*   I:[接口分离原则](https://en.wikipedia.org/wiki/Interface_segregation_principle):“许多特定于客户端的接口比一个通用接口要好。”
*   d:[依赖倒置原则](https://en.wikipedia.org/wiki/Dependency_inversion_principle):“依赖抽象，而非具体。”

依赖倒置原理也和[关注点分离](https://en.wikipedia.org/wiki/Separation_of_concerns) (SoC)有很大关系。例如，SoC 正在创建分层架构。

## 行为

设计不同于让东西工作。我的意思是，软件需要做的第一件事就是按照我们想要的方式工作。设计是为了简化事情，而不是让事情变得更复杂。这个想法在 [**简单设计的四个法则**](https://martinfowler.com/bliki/BeckDesignRules.html) 中有很好的描述:

*   通过测试
*   揭示意图
*   无重复
*   最少元素

最后一条规则“最少元素”是反对过度工程化，反对意外的复杂性。复杂性是解决代码问题的代价。所以我们需要确保我们选择了对我们有利的权衡。[](https://en.wikipedia.org/wiki/KISS_principle)**(保持简单愚蠢)是记住设计越简单越好这个想法的另一种方式。
例如，如果我们决定使用[六边形架构](/the-whys-of-hexagonal-architecture-1ccca8476c86?sk=8d8e99e381ae473c001fd80c348fa5f8)我们需要确保团队中的每个人都理解各层增加的复杂性，这个决定的原因必须被整个团队分享和接受。这种架构还需要足够的业务逻辑，如果我们只做一个 CRUD 系统，那么我们就是过度工程化，因为如果没有业务逻辑，我们只有一个中间层，它什么也不做，一个信号是有许多 dto 和服务，它们只是调用存储库，根本没有编排。**

**另一个对抗过度工程的伟大原则是[**【YAGNI】**](https://en.wikipedia.org/wiki/You_aren%27t_gonna_need_it)(你不需要它)。意外的复杂性是所有过度工程案例的根源，也是我们公司所有复杂性的根源。
YAGNI 告诉我们要避免写任何代码，决定任何今天还没有真正证据来支付那个决定的事情。所以试着问问你自己，如果你用“因为在未来…”来回答这个问题，你为什么决定你正在决定的事情，不要写，不要买，不要做任何事情。等到未来更近的时候，你就有了更多那个可能的未来的证明。
这适用于编写用户故事、创建基础设施、选择技术或其他，只需等到 [**最后负责的时刻再决定**](/to-decide-or-not-to-decide-thats-the-question-f186d5858aba) 。
YAGNI 的另一面是 [**过早的优化**](https://en.wikipedia.org/wiki/Program_optimization) ，请避开它们:**

***“过早优化是编程中所有罪恶(或者至少是大部分罪恶)的根源”——Donald Knuth***

## **界面设计**

**这并不是说 REST 或 SOAP，而是一般来说，你创建的任何与你的库、系统交互或连接到第三方系统的接口。**

**创建一个界面的第一件事就是从这个界面的客户端来考虑。简化客户的体验将有助于我们更好地维护代码。这里可以帮助我们的一个原则是 [**最小惊讶原则**](https://en.wikipedia.org/wiki/Principle_of_least_astonishment) **:****

*   **它建议系统的组件应该以大多数用户期望的方式运行。**

**例如，没有人期望一个名为 retrieveXXX 的函数返回一个值并使用一些参数来改变参数中的任何内容。这个原则也是简单设计的 4 个规则的一部分，揭示了意图，事实上告诉我们要避免惊讶。**

**我们需要明白任何抽象都是有漏洞的，这是由 [**漏洞抽象定律** s](https://www.joelonsoftware.com/2002/11/11/the-law-of-leaky-abstractions/) :
**所有非平凡的抽象在某种程度上都是有漏洞的。****

**但是我们不应该根据接口实现的细节来定义我们的接口。这实际上是立体的依赖于抽象，而不是具体。因此，当我们决定创建一个接口来将代码从行为中分离出来时，我们应该尽量不要向上层暴露这些抽象的所有细节。这就是为什么我更喜欢在 java 中使用运行时异常来处理连接超时、读取超时或任何与底层通信层相关的事情，而不是表示业务逻辑中的这些错误。
我知道在这种情况下，我将异常作为我的异常处理部分的“gotos”来管理，以向上层服务/用户响应错误。这样，我的域和控制器对底层的通信网络问题一无所知。我正在选择一些折衷方案，我更喜欢保持一个简单的设计，而不是在我的业务代码中管理那些不受控制的错误。**

**我这样做也是为了避免掩盖不受控制的错误，因为以后更难理解系统中发生了什么。原因是我尽量遵循 [**不倒快的原则**](https://en.wikipedia.org/wiki/Fail-fast) 。这个想法不是试图从不可恢复的情况中恢复过来。让我们假设发生的任何错误都是不可恢复的，在其他情况下，我们可以改变设计并具体管理该部分，但如果我们默认决定掩盖一切，我们将无法理解错误的来源。
这方面的一个例子是向数据库请求一些数据，如果我们的连接失败，我们可以将这些值设置为 null 并使用该对象。在这种情况下，任何其他需要该对象的功能都会产生一个空指针异常。在这种情况下，很难理解错误不是空指针，而是数据的加载，因为我们有一个返回 null 的 try catch(exception)。**

## **面向对象的程序设计(Object Oriented Programming)**

**面向对象编程的关键不是继承，也不是多态。关键是 [**封装**](https://www.sumologic.com/glossary/encapsulation/) **，**记住这一点将有助于你了解你的设计是否违背了它。如果你正在用任何 OOP 语言编写代码，你应该试着使用 [**信息专家**](https://www.sourcecodeexamples.net/2018/06/information-expert-grasp-pattern.html) 来理解一个方法应该写在哪里。打破封装的一种方法是使用“getters ”,因为它们公开了类的细节，并将应该负责该类的方法移动到该类的客户端。
“吸杂者”问题介绍 [**吸杂者**](https://en.wikipedia.org/wiki/Law_of_Demeter) 定律:**

*   **每个单元应该只对其他单元有有限的了解:只有与当前单元“密切”相关的单元。**
*   **每个单位应该只和自己的朋友说话；不要和陌生人说话。**
*   **只和你最亲近的朋友说话。**

## **代码/数据的复制**

**代码重复是个问题，这就是为什么我们有**干**(不重复自己)。DRY 不仅仅是代码复制:**

****“在一个系统中，每一项知识都必须有一个单一的、明确的、权威的表示方式****

**这不是因为软件中的某种道德问题。这是一个问题，因为它增加了团队的 [**认知负荷**](https://en.wikipedia.org/wiki/Cognitive_load) 当发现一个 bug 或添加一个新行为时，要记住更改所有的副本。**

**但是干很多时候是借口[夫妇](https://en.wikipedia.org/wiki/GRASP_(object-oriented_design)#Low_coupling)我们服务，这不是一个好主意。软件中的一切都是一种交换，但是如果你想让你的团队独立工作，这就是你引入微服务的原因，不要使用 DRY 来创建可重复使用的服务。有意识地选择你的取舍。**

**[**单一来源的真理**](https://en.wikipedia.org/wiki/Single_source_of_truth) 也与干非常相关，它可以帮助我们很容易地理解数据在哪里。例如，服务或数据库上的分布式缓存并不能帮助我们获得单一的事实来源。如果我们没有性能问题，缓存会增加更多的复杂性，并且不支持 SST。正如我所说的，软件就是选择你的折衷方案，缓存只有在我们需要解决性能问题时才有用。**

**干也不好用来创造我们不需要的东西(YAGNI)， [**法则之三**](https://en.wikipedia.org/wiki/Rule_of_three_(computer_programming)) (三振出局，你重构)可以帮助我们理解什么时候应用干。基本上这条规则告诉我们要等到问题足够大但又不太大的时候。
你可以使用它，例如当你有一个 switch case 或者多个 if，你开始看到你的代码对扩展是开放的，但对修改是关闭的。一个“如果”和一个“其他”通常不是问题，但是当我们有三个基于相同条件的“如果”时，也许我们可以想办法去掉“如果”。**

**还有很多，不过大概这些是我用的比较多的。它们通常帮助我决定走哪条路是最好的，它们也是很多事情的潜在原因( [GOF 模式](https://en.wikipedia.org/wiki/Design_Patterns)、分层架构，为什么当他们有解决不了任何问题的想法时，你应该对他们说不)。**

***更多内容尽在*[*blog . dev genius . io*](http://blog.devgenius.io)*。***