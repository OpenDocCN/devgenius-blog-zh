<html>
<head>
<title>LeetCode 111. Minimum Depth of Binary Tree (Solution with images)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">LeetCode 111。二叉树的最小深度(用图像求解)</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/leetcode-111-minimum-depth-of-binary-tree-50b775ec4a1d?source=collection_archive---------6-----------------------#2022-08-19">https://blog.devgenius.io/leetcode-111-minimum-depth-of-binary-tree-50b775ec4a1d?source=collection_archive---------6-----------------------#2022-08-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><h1 id="7932" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">问题:→</h1><p id="6a4a" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">给定一棵二叉树，求其最小深度。</p><p id="340e" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">最小深度是从根节点到最近的叶节点的最短路径上的节点数。</p><p id="2048" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated"><strong class="kn ir">注意:</strong>叶子是没有子节点的节点。</p><p id="102a" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated"><strong class="kn ir">例一:</strong></p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi lo"><img src="../Images/4d20fbd91b2b107b0277984e7b905202.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/0*QLlvI2MxJCEUiSmu.jpg"/></div></figure><pre class="lp lq lr ls gt lw lx ly lz aw ma bi"><span id="c5d9" class="mb jo iq lx b gy mc md l me mf"><strong class="lx ir">Input:</strong> root = [3,9,20,null,null,15,7]<br/><strong class="lx ir">Output:</strong> 2</span></pre><p id="7c31" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated"><strong class="kn ir">例 2: </strong></p><pre class="lp lq lr ls gt lw lx ly lz aw ma bi"><span id="2c23" class="mb jo iq lx b gy mc md l me mf"><strong class="lx ir">Input:</strong> root = [2,null,3,null,4,null,5,null,6]<br/><strong class="lx ir">Output:</strong> 5</span></pre><p id="2e78" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated"><strong class="kn ir">约束:</strong></p><ul class=""><li id="c288" class="mg mh iq kn b ko lj ks lk kw mi la mj le mk li ml mm mn mo bi translated">树中的节点数在范围<code class="fe mp mq mr lx b">[0, 105]</code>内。</li><li id="72b9" class="mg mh iq kn b ko ms ks mt kw mu la mv le mw li ml mm mn mo bi translated"><code class="fe mp mq mr lx b">-1000 &lt;= Node.val &lt;= 1000</code></li></ul><h1 id="6fd8" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">解决方案:→</h1><p id="bf28" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">一般来说，我们可以通过以下方式检查深度。</p><p id="cbe1" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">这里，我们将遍历树<strong class="kn ir"> </strong>并找到<strong class="kn ir">的第一个节点</strong>，它的<strong class="kn ir">左侧</strong>和<strong class="kn ir">右侧</strong>为<strong class="kn ir">空</strong>，我们从<strong class="kn ir">返回那个节点</strong>并检查<strong class="kn ir">的深度，</strong>这将是我们的答案。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi mx"><img src="../Images/c9b8ae3c42c46a71cfd24b07f46e2118.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*hrZ0yydmke-BJ7QCcdwfAw.gif"/></div></div></figure><p id="fe5d" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">现在，让我们用代码来理解，</p><p id="d894" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">首先，我们将检查，如果根节点为空，那么我们不需要对树进行任何遍历，我们可以简单地返回<strong class="kn ir"> 0 </strong>。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/71caa9babd6c123a8c03c67b8e8a9756.png" data-original-src="https://miro.medium.com/v2/resize:fit:632/format:webp/1*FiXsIwh6C2VFzQF-9imPxw.png"/></div></figure><p id="3172" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">之后，如果<strong class="kn ir">根</strong>为<strong class="kn ir">不为空</strong>，那么我们会将此添加到<strong class="kn ir">队列中。</strong></p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi nd"><img src="../Images/2567c6d798268e6c162dd2d4b671d35f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*723OxEaIj37-YhUahqRa9A.png"/></div></div></figure><p id="88c3" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">现在，队列不为空，所以它将在<strong class="kn ir">而</strong>循环中，现在我们检查<strong class="kn ir">队列的</strong>大小为 1。</p><p id="5536" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">之后，我们将进入<strong class="kn ir">内部 while 循环</strong>，其中条件满足，因此接下来，我们将从<strong class="kn ir">队列中取出节点</strong>，这是<strong class="kn ir">节点(1) </strong>。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi nd"><img src="../Images/b248074c663c7b85b6128c6b7bc4fa9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tUEX961Cxm9djXoQrE0fKw.png"/></div></div></figure><p id="8ddf" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">现在，首先我们检查<strong class="kn ir">根节点(1) </strong>的左<strong class="kn ir">和右<strong class="kn ir">是否都为空</strong>？如果没有，那么我们继续前进，尝试将那些<strong class="kn ir">节点</strong>添加到<strong class="kn ir">队列</strong>。</strong></p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi nd"><img src="../Images/bb679854e29678191f1f44b5b225997e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zohhHBAOQtqRugjsDDFBXg.png"/></div></div></figure><p id="0c22" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">现在，大小变成了<strong class="kn ir"> 0 </strong>，所以<strong class="kn ir">内 while 循环</strong>的条件将为<strong class="kn ir">假</strong>，</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi nd"><img src="../Images/63ba68fa493f569c7ecc6912b7864214.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5ysntabjzYhgZxo09UZ6bw.png"/></div></div></figure><p id="6399" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">现在，<strong class="kn ir">深度值</strong>将增加<strong class="kn ir"> 1 </strong>，然后和前面的步骤一样，我们将移动到<strong class="kn ir">外 while 循环</strong>，在那里我们计算<strong class="kn ir">大小</strong>并进入<strong class="kn ir">内 while 循环。</strong></p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi nd"><img src="../Images/06cac3e8c1c2f113676583fb4d855fe4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vlF399fAOwgKZ3AM3s0-Ew.png"/></div></div></figure><p id="7a57" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">现在，<strong class="kn ir"> que.poll() </strong>将被调用，因此<strong class="kn ir">第一个节点</strong>即<strong class="kn ir">节点(2)</strong>被从<strong class="kn ir">队列</strong>中移除，并将其分配给<strong class="kn ir">节点</strong>。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi nd"><img src="../Images/c41a19689d1a9f91533a9541e25d4f0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*exj3bv4R29h3EZyUtxpytA.png"/></div></div></figure><p id="540a" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">现在对于节点(2)，左节点和右节点都变成 null，所以如果条件将满足，并返回当前深度，</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi ne"><img src="../Images/6790873df0514b4835660d0cd9cab9eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f7D8XqXjCh4RamOVnjTrqg.png"/></div></div></figure><p id="eb89" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">因此，两个循环都将退出，返回的结果将是<strong class="kn ir"> 2 </strong>。</p><p id="f481" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">函数结束，我们简单的返回<strong class="kn ir">深度</strong>，这将是我们的<strong class="kn ir">答案</strong>。</p><p id="53b4" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">现在，让我们看看完整的源代码。</p><h1 id="614d" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">代码(Java): →</h1><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="nf ng l"/></div></figure><h1 id="7058" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">代码(Python): →</h1><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="nf ng l"/></div></figure><h1 id="dfe6" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">时间复杂度</h1><p id="e828" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">这里，我们采用了两个 while 循环。第一个 while 循环仅用于深度计算，第二个 while 循环用于<strong class="kn ir">迭代所有节点</strong>，因此时间复杂度为 O( <strong class="kn ir"> n </strong>)。</p><h1 id="3330" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">空间复杂性</h1><p id="598e" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">由于我们使用了一个额外的队列，所以，空间复杂度将是 O(n)<strong class="kn ir">。</strong></p><p id="273e" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">感谢你阅读这篇文章，❤</p><p id="0f72" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">如果这篇文章对你有帮助，请鼓掌👏这篇文章。</p><p id="30fe" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">请在<a class="ae ni" href="https://medium.com/@alexmurphyas8" rel="noopener">媒体</a>上关注我，我会像上面一样发布有用的信息。</p><p id="a8ff" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">insta gram→<a class="ae ni" href="https://www.instagram.com/alexmurphyas8/" rel="noopener ugc nofollow" target="_blank">https://www.instagram.com/alexmurphyas8/</a></p><p id="2a48" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">推特→<a class="ae ni" href="https://twitter.com/AlexMurphyas8" rel="noopener ugc nofollow" target="_blank">https://twitter.com/AlexMurphyas8</a></p><p id="e28f" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">如果我做错了什么？让我在评论中。我很想进步。</p></div></div>    
</body>
</html>