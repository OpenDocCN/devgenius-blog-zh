<html>
<head>
<title>Concurrency in Go is hard</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">围棋中的并发很难</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/concurrency-in-go-is-hard-57500304650?source=collection_archive---------0-----------------------#2022-08-17">https://blog.devgenius.io/concurrency-in-go-is-hard-57500304650?source=collection_archive---------0-----------------------#2022-08-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="bae0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我知道这个标题可能有些混乱，因为 Go 通常以对并发性的良好内置支持而闻名。但是，我不一定认为在 Go 中写并发软件很容易。让我告诉你我的意思。</p><h1 id="38f2" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">使用全局变量</h1><p id="791a" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">第一个例子是我们在一个项目中遇到的事情。直到最近，<a class="ae lo" href="https://github.com/Shopify/sarama" rel="noopener ugc nofollow" target="_blank"> sarama </a>库(Apache Kafka 的 Go 库)包含以下代码段(在<code class="fe lp lq lr ls b">sarama/version.go</code>):</p><pre class="lt lu lv lw gt lx ls ly lz aw ma bi"><span id="73e2" class="mb km iq ls b gy mc md l me mf">package sarama<br/><br/>import "runtime/debug"<br/><br/>var v string<br/><br/>func version() string {<br/>    if v == "" {<br/>        bi, ok := debug.ReadBuildInfo()<br/>        if ok {<br/>            v = bi.Main.Version<br/>        } else {<br/>            v = "dev"<br/>        }<br/>    }<br/>    return v<br/>}</span></pre><p id="1c16" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">乍一看，这看起来很好，对不对？如果版本不是全局设置的，它要么基于构建信息，要么分配给一个静态值(<code class="fe lp lq lr ls b">dev</code>)。否则，版本按原样返回。当我们运行这段代码时，它看起来像预期的那样工作。</p><p id="0ab3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，当并发调用<code class="fe lp lq lr ls b">version</code>函数时，全局变量<code class="fe lp lq lr ls b">v</code>可能会被多个 goroutines 同时访问，从而导致潜在的数据竞争。这些问题很难追踪，因为它们只在运行时的正确条件下发生。</p><h2 id="8f6b" class="mb km iq bd kn mg mh dn kr mi mj dp kv jy mk ml kz kc mm mn ld kg mo mp lh mq bi translated">解决方案</h2><p id="be3d" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">这个问题在<a class="ae lo" href="https://github.com/Shopify/sarama/pull/2171" rel="noopener ugc nofollow" target="_blank"> #2171 </a>中通过使用<code class="fe lp lq lr ls b">sync.Once</code>得到了修复，根据文档，它是“一个只执行一个动作的对象”这意味着我们可以用它来设置一次版本，这样对<code class="fe lp lq lr ls b">version</code>函数的后续调用就会返回结果。修复如下所示:</p><pre class="lt lu lv lw gt lx ls ly lz aw ma bi"><span id="a507" class="mb km iq ls b gy mc md l me mf">package sarama<br/><br/>import (<br/>    "runtime/debug"<br/>    "sync"<br/>)<br/><br/>var (<br/>    v     string<br/>    vOnce sync.Once<br/>)<br/><br/>func version() string {<br/>    vOnce.Do(func() {<br/>        bi, ok := debug.ReadBuildInfo()<br/>        if ok {<br/>           v = bi.Main.Version<br/>        } else {<br/>           v = "dev"<br/>        }<br/>    })<br/>    return v<br/>}</span></pre><p id="a24d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然我认为在这种情况下，它也可以不使用<code class="fe lp lq lr ls b">sync</code>包，通过使用<code class="fe lp lq lr ls b">init</code>函数设置变量<code class="fe lp lq lr ls b">v</code>一次来修复。由于变量<code class="fe lp lq lr ls b">v</code>在 Go 运行<code class="fe lp lq lr ls b">init</code>函数后不会改变，所以应该没问题。</p><h2 id="9a37" class="mb km iq bd kn mg mh dn kr mi mj dp kv jy mk ml kz kc mm mn ld kg mo mp lh mq bi translated">如何预防</h2><p id="0d7f" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">如果您只想启动应用程序，可以在测试期间或使用<code class="fe lp lq lr ls b">go run</code>时使用<a class="ae lo" href="https://go.dev/doc/articles/race_detector" rel="noopener ugc nofollow" target="_blank">数据竞争检测器</a>(从 Go 1.1 开始可用<a class="ae lo" href="https://go.dev/blog/race-detector" rel="noopener ugc nofollow" target="_blank">)。当它检测到潜在的数据竞争时，它将打印一个警告。为了展示这是如何工作的，我稍微修改了一下代码，以触发数据竞争:</a></p><pre class="lt lu lv lw gt lx ls ly lz aw ma bi"><span id="0d25" class="mb km iq ls b gy mc md l me mf">package main</span><span id="3809" class="mb km iq ls b gy mr md l me mf">import (<br/>    "fmt"<br/>    "runtime/debug"<br/>)</span><span id="bf66" class="mb km iq ls b gy mr md l me mf">var v string</span><span id="86cc" class="mb km iq ls b gy mr md l me mf">func version() string {<br/>    if v == "" {<br/>        bi, ok := debug.ReadBuildInfo()<br/>        if ok {<br/>            v = bi.Main.Version<br/>        } else {<br/>            v = "dev"<br/>        }<br/>    }<br/>    return v<br/>}</span><span id="acdb" class="mb km iq ls b gy mr md l me mf">func main() {<br/>    go func() {<br/>        version()<br/>    }()</span><span id="9113" class="mb km iq ls b gy mr md l me mf">    fmt.Println(version())<br/>}</span></pre><p id="b272" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们可以用<code class="fe lp lq lr ls b">-race</code>标志运行它来启用竞争检测器:</p><pre class="lt lu lv lw gt lx ls ly lz aw ma bi"><span id="82be" class="mb km iq ls b gy mc md l me mf">➜ go run -race .                               <br/>==================<br/>WARNING: DATA RACE<br/>Write at 0x000104a16b90 by main goroutine:<br/>  main.version()<br/>      main.go:14 +0x78<br/>  main.main()<br/>      main.go:27 +0x30</span><span id="03b2" class="mb km iq ls b gy mr md l me mf">Previous read at 0x000104a16b90 by goroutine 7:<br/>  main.version()<br/>      main.go:11 +0x2c<br/>  main.main.func1()<br/>      main.go:24 +0x24</span><span id="063d" class="mb km iq ls b gy mr md l me mf">Goroutine 7 (finished) created at:<br/>  main.main()<br/>      main.go:23 +0x2c<br/>==================<br/>(devel)<br/>Found 1 data race(s)<br/>exit status 66</span></pre><p id="59b2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如您所见，检测到了数据竞争。如果我们分析输出，我们可以看到我们同时读写了<code class="fe lp lq lr ls b">v</code>变量。这就是我们所说的数据竞赛。这被称为数据竞争，因为两个 goroutines 都在“竞争”访问相同的数据。</p><figure class="lt lu lv lw gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi ca"><img src="../Images/762c932df857642d602b1a8fc51ded0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LBoQY8JtSoSBXAvkcMVqgg.png"/></div></div><figcaption class="mz na gj gh gi nb nc bd b be z dk translated">竞争检测器输出的可视化表示</figcaption></figure><h1 id="7a04" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">从同步包中复制结构</h1><p id="84e3" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">我确实在 GitHub 上找到了一些真实世界的例子，但是没有一个值得在这里提及。相反，我将根据我制作的一个示例来解释这一点。所以是这样的:</p><pre class="lt lu lv lw gt lx ls ly lz aw ma bi"><span id="72ed" class="mb km iq ls b gy mc md l me mf">package main</span><span id="f397" class="mb km iq ls b gy mr md l me mf">import "sync"</span><span id="af1b" class="mb km iq ls b gy mr md l me mf">type User struct {<br/>    lock sync.RWMutex<br/>    Name string<br/>}</span><span id="3cce" class="mb km iq ls b gy mr md l me mf">func doSomething(u User) {<br/>    u.lock.RLock()<br/>    defer u.lock.RUnlock()</span><span id="8d4c" class="mb km iq ls b gy mr md l me mf">    // do something with `u`<br/>}</span><span id="6772" class="mb km iq ls b gy mr md l me mf">func main() {<br/>    u := User{Name: "John"}</span><span id="06b9" class="mb km iq ls b gy mr md l me mf">    doSomething(u)<br/>}</span></pre><p id="f1cd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">结构包含两个属性:一个读/写锁和一个字符串。当调用<code class="fe lp lq lr ls b">doSomething</code>函数时，变量<code class="fe lp lq lr ls b">u</code>被复制到堆栈上(也称为通过值传递)，包括它的字段。这是一个问题，因为正如 sync 包的文档所述:</p><blockquote class="nd ne nf"><p id="0263" class="jn jo ng jp b jq jr js jt ju jv jw jx nh jz ka kb ni kd ke kf nj kh ki kj kk ij bi translated">包同步提供了基本的同步原语，如互斥锁。除了 Once 和 WaitGroup 类型之外，大多数类型都是供低级库例程使用的。更高级别的同步最好通过信道和通信来完成。</p><p id="9eb5" class="jn jo ng jp b jq jr js jt ju jv jw jx nh jz ka kb ni kd ke kf nj kh ki kj kk ij bi translated"><strong class="jp ir">不应复制包含此包中定义的类型的值。</strong></p></blockquote><p id="a8bc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当对<code class="fe lp lq lr ls b">doSomething</code>函数求值时，运行<code class="fe lp lq lr ls b">RLock</code> / <code class="fe lp lq lr ls b">RUnlock</code>不会影响<code class="fe lp lq lr ls b">User</code>结构中的原始锁，使其无效。</p><h2 id="155f" class="mb km iq bd kn mg mh dn kr mi mj dp kv jy mk ml kz kc mm mn ld kg mo mp lh mq bi translated">解决方案</h2><p id="9893" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">请改用指向锁的指针。指针将被复制并指向相同的值。更新后的版本如下所示:</p><pre class="lt lu lv lw gt lx ls ly lz aw ma bi"><span id="19c2" class="mb km iq ls b gy mc md l me mf">type User struct {<br/>    lock *sync.RWMutex<br/>    Name string<br/>}</span></pre><h2 id="27af" class="mb km iq bd kn mg mh dn kr mi mj dp kv jy mk ml kz kc mm mn ld kg mo mp lh mq bi translated">如何预防</h2><p id="9fed" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">当从<code class="fe lp lq lr ls b">sync</code>封装中复制类型时，使用<a class="ae lo" href="https://pkg.go.dev/golang.org/x/tools/go/analysis/passes/copylock" rel="noopener ugc nofollow" target="_blank"> copylock analyzer </a>显示警告。最简单的方法是在发布代码之前运行<code class="fe lp lq lr ls b">go vet</code>。对原始代码运行此命令会产生以下输出:</p><pre class="lt lu lv lw gt lx ls ly lz aw ma bi"><span id="36eb" class="mb km iq ls b gy mc md l me mf">➜ go vet .<br/># data-synchronization<br/>./main.go:10:20: doSomething passes lock by value: data-synchronization.User contains sync.RWMutex<br/>./main.go:20:14: call of doSomething copies lock value: data-synchronization.User contains sync.RWMutex</span></pre><h1 id="f670" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">利用时间。在...之后</h1><p id="2241" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">在 GitHub 上搜索时，我在 Hashicorp (一种分布式共识算法)的<a class="ae lo" href="https://github.com/hashicorp/raft" rel="noopener ugc nofollow" target="_blank"> Raft 实现中发现了一个</a><a class="ae lo" href="https://github.com/hashicorp/raft/pull/484" rel="noopener ugc nofollow" target="_blank"> pull 请求</a>，我们可以用它来演示下面的问题。让我们从显示代码开始(在<code class="fe lp lq lr ls b">api.go</code>):</p><pre class="lt lu lv lw gt lx ls ly lz aw ma bi"><span id="e1d8" class="mb km iq ls b gy mc md l me mf">var timer &lt;-chan time.Time<br/>if timeout &gt; 0 {<br/>    timer = time.After(timeout)<br/>}<br/><br/>// Perform the restore.<br/>restore := &amp;userRestoreFuture{<br/>    meta:   meta,<br/>    reader: reader,<br/>}<br/>restore.init()<br/>select {<br/>case &lt;-timer:<br/>    return ErrEnqueueTimeout<br/>case &lt;-r.shutdownCh:<br/>    return ErrRaftShutdown<br/>case r.userRestoreCh &lt;- restore:<br/>    // If the restore is ingested then wait for it to complete.<br/>    if err := restore.Error(); err != nil {<br/>        return err<br/>    }<br/>}</span></pre><p id="44d0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这段代码来自于<code class="fe lp lq lr ls b">Restore</code>方法。select 语句等待下列情况之一:计时器(用于定义超时时间)、关闭通道或还原操作完成时。这很简单，那么问题是什么呢？</p><p id="1da4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lp lq lr ls b">time.After</code>函数看起来像这样:</p><pre class="lt lu lv lw gt lx ls ly lz aw ma bi"><span id="8a88" class="mb km iq ls b gy mc md l me mf">func After(d Duration) &lt;-chan Time {<br/>    return NewTimer(d).C<br/>}</span></pre><p id="1669" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以它只不过是<code class="fe lp lq lr ls b">time.NewTimer,</code>的简写，但是它“泄露”了计时器(因为没有对<code class="fe lp lq lr ls b">timer.Stop</code>的调用)。文档对此做了如下描述:</p><blockquote class="nd ne nf"><p id="c6f0" class="jn jo ng jp b jq jr js jt ju jv jw jx nh jz ka kb ni kd ke kf nj kh ki kj kk ij bi translated">之后等待持续时间过去，然后在返回的信道上发送当前时间。它等效于 NewTimer(d).C。在计时器触发之前，垃圾收集器不会恢复基础计时器。如果效率是一个问题，请使用 NewTimer 并调用 Timer。如果不再需要计时器，请停止。</p></blockquote><p id="119f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我真的不明白一个故意“泄露”计时器的函数(导致潜在的长期分配，取决于持续时间)怎么会出现在标准库中…</p><h2 id="638d" class="mb km iq bd kn mg mh dn kr mi mj dp kv jy mk ml kz kc mm mn ld kg mo mp lh mq bi translated">解决方案</h2><p id="7381" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">我们可以手动创建定时器，而不是使用<code class="fe lp lq lr ls b">time.After</code>。看起来是这样的:</p><pre class="lt lu lv lw gt lx ls ly lz aw ma bi"><span id="e150" class="mb km iq ls b gy mc md l me mf">var timerCh &lt;-chan time.Time<br/>if timeout &gt; 0 {<br/>    timer := time.NewTimer(timeout)<br/>    defer timer.Stop()<br/>    timerCh = timer.C<br/>}</span><span id="d94c" class="mb km iq ls b gy mr md l me mf">// Perform the restore.<br/>restore := &amp;userRestoreFuture{<br/>    meta:   meta,<br/>    reader: reader,<br/>}<br/>restore.init()<br/>select {<br/>case &lt;-timerCh:<br/>    return ErrEnqueueTimeout<br/>case &lt;-r.shutdownCh:<br/>    return ErrRaftShutdown<br/>case r.userRestoreCh &lt;- restore:<br/>    // If the restore is ingested then wait for it to complete.<br/>    if err := restore.Error(); err != nil {<br/>        return err<br/>    }<br/>}</span></pre><p id="a7cc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当函数完成时，即使定时器没有触发，它也会被清除。</p><h2 id="4771" class="mb km iq bd kn mg mh dn kr mi mj dp kv jy mk ml kz kc mm mn ld kg mo mp lh mq bi translated">如何预防</h2><p id="6b55" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">我不会在任何代码库中使用<code class="fe lp lq lr ls b">time.After</code>。除了节省一两行代码之外，并没有什么真正的好处，尽管它可能会带来一些问题，主要是在代码的热路径中使用时。</p><h1 id="eadc" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">结论</h1><p id="f966" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">利用 Go 内置的对并发的支持，可以快速编写并发软件。然而，它让用户来确保数据正确同步，并且标准库中的工具按预期使用。这一点，再加上 Go 的简单性，使得编写稳定、无错误的并发软件变得困难。</p></div></div>    
</body>
</html>