<html>
<head>
<title>useCallback() hook to improve React component performance: A complete guide</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Callback()钩子提高 React 组件性能:完全指南</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/usecallback-hook-to-improve-react-component-performance-a-complete-guide-89bd4997574c?source=collection_archive---------2-----------------------#2022-11-13">https://blog.devgenius.io/usecallback-hook-to-improve-react-component-performance-a-complete-guide-89bd4997574c?source=collection_archive---------2-----------------------#2022-11-13</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/c03c1e2861d4a4820b72967c9dca83f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x8TByBnpic9g8zBy1XpLiQ.png"/></div></div></figure><p id="1a57" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这篇博客中，我们将了解<strong class="jx io"> React </strong>中的<strong class="jx io"> useCallback() </strong>钩子。我们将从介绍开始，看看它的代码实现。我们还将讨论如何以及何时使用 useCallback()钩子。</p><p id="59f7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在我们继续使用 useCallback()钩子之前，你需要理解使用 useMemo()钩子和 react memo()时 React  中的<a class="ae kt" rel="noopener ugc nofollow" target="_blank" href="/react-memo-and-usememo-explained-in-the-right-way-you-should-know-this-af10a805e620"> <strong class="jx io">记忆。在这里，我将简单地解释一下 react 备忘录，如果你需要详细的解释，请点击<a class="ae kt" rel="noopener ugc nofollow" target="_blank" href="/react-memo-and-usememo-explained-in-the-right-way-you-should-know-this-af10a805e620"> <strong class="jx io">这里</strong> </a></strong></a></p><h1 id="dea9" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">React 重新渲染和性能缺陷</h1><p id="38b1" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">我们都知道，当 react 组件的状态或道具发生变化时，它会进行渲染，所有子组件也会进行渲染。在某些情况下，我们可能会遇到这样的情况:父组件进行了渲染，但子组件中不需要进行渲染，因为子组件的状态和属性都没有改变，但子组件仍然进行了渲染，因为父组件正在重新渲染，这将是由于不必要的渲染而导致的性能缺陷。</p><blockquote class="lx"><p id="4558" class="ly lz in bd ma mb mc md me mf mg ks dk translated">让我们看一个不必要的重新渲染的例子</p></blockquote><blockquote class="mh mi mj"><p id="b2fc" class="jv jw mk jx b jy ml ka kb kc mm ke kf mn mo ki kj mp mq km kn mr ms kq kr ks ig bi translated"><strong class="jx io"> App.js </strong></p></blockquote><figure class="mt mu mv mw gt jo"><div class="bz fp l di"><div class="mx my l"/></div><figcaption class="mz na gj gh gi nb nc bd b be z dk translated"><strong class="ak"> App.js </strong>(父组件)</figcaption></figure><blockquote class="mh mi mj"><p id="61bd" class="jv jw mk jx b jy jz ka kb kc kd ke kf mn kh ki kj mp kl km kn mr kp kq kr ks ig bi translated"><strong class="jx io"> Child.js </strong></p></blockquote><figure class="mt mu mv mw gt jo"><div class="bz fp l di"><div class="mx my l"/></div><figcaption class="mz na gj gh gi nb nc bd b be z dk translated"><strong class="ak"> Child.js </strong>(子组件)</figcaption></figure><blockquote class="mh mi mj"><p id="9c18" class="jv jw mk jx b jy jz ka kb kc kd ke kf mn kh ki kj mp kl km kn mr kp kq kr ks ig bi translated"><strong class="jx io">输出</strong>(页面加载时的初始渲染)</p></blockquote><figure class="mt mu mv mw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nd"><img src="../Images/6ccb20828a1fe1dc2c8ab0b2ff6612e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l0BMFBDP1pRag8JcZOGd7A.png"/></div></div><figcaption class="mz na gj gh gi nb nc bd b be z dk translated">页面加载时的输出</figcaption></figure><blockquote class="mh mi mj"><p id="e3c7" class="jv jw mk jx b jy jz ka kb kc kd ke kf mn kh ki kj mp kl km kn mr kp kq kr ks ig bi translated"><strong class="jx io">输出</strong>(当父组件重新渲染时)</p></blockquote><figure class="mt mu mv mw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ne"><img src="../Images/ffd95a957237b6b69c31e08b20e1c299.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3B-YmMnHqsJrbF3LTzYP_g.png"/></div></div><figcaption class="mz na gj gh gi nb nc bd b be z dk translated">父组件重新呈现时的输出</figcaption></figure><p id="5761" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在上面的代码片段及其输出中，我们可以看到，当父组件重新渲染时，子组件的属性或状态不会改变，但由于父组件重新渲染，它仍然会重新渲染并产生相同的输出，我们都知道任何组件不必要的重新渲染都是一个性能陷阱。为了避免这种不必要的重新渲染，我们使用 react memo。</p><h1 id="92c1" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">反应备忘录及其重要性</h1><p id="237c" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">React memo 记忆 React 组件，仅当其属性或状态发生变化时，才允许其重新渲染。从而提高反应元件的性能。</p><blockquote class="lx"><p id="3fd6" class="ly lz in bd ma mb mc md me mf mg ks dk translated">让我们使用 react memo，避免不必要的重新渲染</p></blockquote><blockquote class="mh mi mj"><p id="f6b0" class="jv jw mk jx b jy ml ka kb kc mm ke kf mn mo ki kj mp mq km kn mr ms kq kr ks ig bi translated"><strong class="jx io"> App.js 组件将与上述组件相同。</strong></p><p id="710e" class="jv jw mk jx b jy jz ka kb kc kd ke kf mn kh ki kj mp kl km kn mr kp kq kr ks ig bi translated"><strong class="jx io"> Child.js </strong></p></blockquote><figure class="mt mu mv mw gt jo"><div class="bz fp l di"><div class="mx my l"/></div></figure><blockquote class="mh mi mj"><p id="d315" class="jv jw mk jx b jy jz ka kb kc kd ke kf mn kh ki kj mp kl km kn mr kp kq kr ks ig bi translated"><strong class="jx io">输出</strong></p></blockquote><figure class="mt mu mv mw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nf"><img src="../Images/0bfd9d27fcd110888a069ceead180a24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8fg6_R1ZBK-2i_1ipvSI7A.png"/></div></div><figcaption class="mz na gj gh gi nb nc bd b be z dk translated">没有不必要的重新呈现的记忆子组件的输出</figcaption></figure><p id="faa7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在上面的例子中，我们使用 memo()来记忆我们的子组件，避免了不必要的重新渲染。</p><blockquote class="lx"><p id="3e09" class="ly lz in bd ma mb mc md me mf mg ks dk translated">让我们添加一个功能，像父组件(App.js)一样在子组件中添加数据</p></blockquote><blockquote class="mh mi mj"><p id="131a" class="jv jw mk jx b jy ml ka kb kc mm ke kf mn mo ki kj mp mq km kn mr ms kq kr ks ig bi translated"><strong class="jx io"> App.js </strong></p></blockquote><figure class="mt mu mv mw gt jo"><div class="bz fp l di"><div class="mx my l"/></div></figure><blockquote class="mh mi mj"><p id="5a41" class="jv jw mk jx b jy jz ka kb kc kd ke kf mn kh ki kj mp kl km kn mr kp kq kr ks ig bi translated"><strong class="jx io"> child.js </strong></p></blockquote><figure class="mt mu mv mw gt jo"><div class="bz fp l di"><div class="mx my l"/></div></figure><blockquote class="mh mi mj"><p id="2496" class="jv jw mk jx b jy jz ka kb kc kd ke kf mn kh ki kj mp kl km kn mr kp kq kr ks ig bi translated"><strong class="jx io">输出</strong></p></blockquote><figure class="mt mu mv mw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ng"><img src="../Images/d10679e36f39e07d56be042270a6d8f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2ltKJcjFbCPrQPQvBUE2FQ.png"/></div></div></figure><p id="e83a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，当我们添加功能以在子组件中添加数据时，我们的 memoize 子组件不工作了。当父组件重新呈现时，子组件也会重新呈现。这是因为我们将一个函数(addChildData)传递给了在父组件中声明的子组件。</p><p id="dc5b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">每当父组件重新呈现时，函数(addChildData)会被重新创建并存储在具有新内存引用的新内存位置，因此 memoize 子组件会重新呈现，因为 addChildData 属性的引用已更改。对同一个函数的引用的这种变化会导致重新呈现，这可以使用 useCallback()钩子来解决。</p><h1 id="4a77" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">useCallback()挂钩简介</h1><p id="5c15" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">useCallback()是一个钩子，它通过在重新呈现之间记忆或缓存函数来帮助我们提高 react 组件的性能。</p><p id="aa03" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当组件重新呈现时，组件中的每个函数都会被重新创建，因此存储这些函数的内存位置也会发生变化。这也意味着这些函数的地址或引用发生了变化。</p><p id="bf0c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">useCallback()钩子返回一个内存化的回调函数，该函数作为一个道具传递给子组件。这意味着，我们可以在渲染之间使用相同的函数，而不是在每次重新渲染时都重新创建函数，这样可以避免不必要的渲染。</p><p id="9bbe" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">useCallback 挂钩仅在其依赖项之一发生变化时运行。</p><h2 id="7bba" class="nh kv in bd kw ni nj dn la nk nl dp le kg nm nn li kk no np lm ko nq nr lq ns bi translated">您需要传递两个东西来使用回调:</h2><ol class=""><li id="19de" class="nt nu in jx b jy ls kc lt kg nv kk nw ko nx ks ny nz oa ob bi translated">要在重新呈现之间缓存的函数定义。</li><li id="44c8" class="nt nu in jx b jy oc kc od kg oe kk of ko og ks ny nz oa ob bi translated">依赖项列表，包括在函数中使用的组件中的每个值。</li></ol><pre class="mt mu mv mw gt oh oi oj bn ok ol bi"><span id="4041" class="om kv in oi b be on oo l op oq">const cachedFn = useCallback(function, dependencies)</span></pre><blockquote class="lx"><p id="ab33" class="ly lz in bd ma mb or os ot ou ov ks dk translated">让我们实现 useCallback()钩子来记忆或缓存函数，避免不必要的重新呈现</p></blockquote><blockquote class="mh mi mj"><p id="b48e" class="jv jw mk jx b jy ml ka kb kc mm ke kf mn mo ki kj mp mq km kn mr ms kq kr ks ig bi translated"><strong class="jx io"> App.js </strong></p></blockquote><figure class="mt mu mv mw gt jo"><div class="bz fp l di"><div class="mx my l"/></div></figure><blockquote class="mh mi mj"><p id="6c86" class="jv jw mk jx b jy jz ka kb kc kd ke kf mn kh ki kj mp kl km kn mr kp kq kr ks ig bi translated"><strong class="jx io"> Child.js </strong></p></blockquote><figure class="mt mu mv mw gt jo"><div class="bz fp l di"><div class="mx my l"/></div></figure><blockquote class="mh mi mj"><p id="5631" class="jv jw mk jx b jy jz ka kb kc kd ke kf mn kh ki kj mp kl km kn mr kp kq kr ks ig bi translated"><strong class="jx io">输出</strong></p></blockquote><figure class="mt mu mv mw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ow"><img src="../Images/e100ec33a35857917744cf7fd817e72e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FfOZRtXm-V1KL48nq-GzCA.png"/></div></div><figcaption class="mz na gj gh gi nb nc bd b be z dk translated">实现 useCallback()挂钩后的输出</figcaption></figure><p id="34c5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">通过 useCallback 钩子的实现，我们成功地避免了不必要的重新渲染，从而提高了 react 组件的性能。</p><h1 id="8907" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">什么时候不使用 useCallback()钩子？</h1><p id="bfe7" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">useCallback()钩子主要用于通过记忆昂贵的函数来优化性能。这是通过添加依赖项列表来实现的，但是如果你用不必要的 useCallback()填充整个组件，性能就会下降。</p><p id="d3b3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">感谢您阅读至此。我希望现在您已经理解了 react 中的 useCallback()钩子及其重要性。</strong></p><h1 id="8280" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">如果你想要更多这样的内容，请在媒体上关注我，订阅我的 YouTube 频道</h1><h1 id="7910" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">有疑问吗？通过推特<a class="ae kt" href="https://twitter.com/izrajesh" rel="noopener ugc nofollow" target="_blank">联系我</a></h1></div></div>    
</body>
</html>