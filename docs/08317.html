<html>
<head>
<title>Interfaces and Abstract Classes in JAVA</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JAVA 中的接口和抽象类</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/interfaces-and-abstract-classes-in-java-5329ef1e1343?source=collection_archive---------4-----------------------#2022-06-05">https://blog.devgenius.io/interfaces-and-abstract-classes-in-java-5329ef1e1343?source=collection_archive---------4-----------------------#2022-06-05</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="ac7e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">作者:Atharva Sawaleshwarkar，Mohiddin Shikalgar，Tanmay Shah，Farhan Shaikh，Yash Shejwal </p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/0b8ddb7157da3fe6ec7ab683807b7d41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ULaOZ5uwL8oeZpqW7NIn_w.png"/></div></div></figure><p id="be09" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当我们学习 java 和它的概念时，我们肯定会遇到叫做接口的概念。接口是 java 的关键特性之一，每个 JAVA 开发人员都应该知道它的用途和应用。界面带来了许多优点和缺点。</p><p id="b275" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们深入理解接口。当实现接口时，我们肯定会遇到被称为抽象类的术语。什么是抽象类？为什么需要它们？接口是什么？接口的用途是什么？为什么接口在其中使用抽象类？你会在这篇博文中得到所有答案。</p><h1 id="bf03" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">什么是接口？</h1><p id="68a3" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">接口是 java 中的一种特殊机制，有助于实现抽象。实际上，接口是一个类的蓝图。它有静态常数和抽象方法。接口只能有抽象方法(只有没有主体的方法)。</p><p id="679d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是目前，在 java 9 中，我们也可以在接口中使用<strong class="jm io">私有、默认和静态方法</strong>。</p><p id="ee6a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们忽略技术词汇，去简单的逻辑理解用来实现<strong class="jm io"> <em class="ki">抽象</em> </strong>的接口。</p><h1 id="2867" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">什么是抽象？</h1><p id="c9af" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">举个现实生活中的例子，我们都在手机上使用 app。每当我们想使用任何应用程序时，我们都必须在其中创建一个帐户。在注册过程中，当我们用我们的电话号码注册时，OTP 就会出现在我们的手机上。</p><p id="5377" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在这里有一个抽象的答案，我们知道 OTP 是在点击应用程序中的“发送 OTP”按钮后出现的，但我们不知道该系统在后端是如何工作的。点击按钮后，实际发生了什么。这种成功完成任务而不向用户显示后端实际发生了什么的行为被称为抽象。</p><p id="6338" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们可以使用 java 中的接口和抽象类来实现抽象。</p><h1 id="1d44" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">为什么要使用接口？</h1><p id="a43f" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">使用该界面主要有三个原因。它们在下面给出。</p><ul class=""><li id="b779" class="ly lz in jm b jn jo jr js jv ma jz mb kd mc kh md me mf mg bi translated">它用于实现抽象。</li><li id="9b51" class="ly lz in jm b jn mh jr mi jv mj jz mk kd ml kh md me mf mg bi translated">通过接口，我们可以支持多重继承的功能。</li><li id="c2ce" class="ly lz in jm b jn mh jr mi jv mj jz mk kd ml kh md me mf mg bi translated">它可以用来实现松耦合。</li></ul><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/a1554f1984fd33cc0666117304c67eab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-72Yl0kx_an54IqguBiXqQ.png"/></div></div></figure><h1 id="5dca" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">如何使用界面？</h1><p id="e3f3" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">该接口是使用“interface”关键字声明的。它提供了抽象，意味着它声明了类的结构。接口中的所有方法都是抽象的，默认情况下都被设置为 public、static 和 final。实现接口的任何类都必须实现接口中声明的所有方法。</p><pre class="kk kl km kn gt mm mn mo mp aw mq bi"><span id="41e3" class="mr kw in mn b gy ms mt l mu mv">interface &lt;interface_name&gt;{  <br/>       <br/>     // declare constant fields  <br/>     // declare methods that abstract   <br/>     // by default. <br/> }</span></pre><p id="633e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">与接口类似，抽象也可以通过使用抽象类来实现。</p><h1 id="a695" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">什么是抽象类？</h1><p id="593c" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">抽象类是前面带有“Abstract”关键字的类。它们既包含抽象方法，也包含具体方法(包含主体的方法)。抽象类不能被实例化，它们需要被扩展，它们的方法需要被实现。</p><p id="db04" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">要记住的要点</p><ul class=""><li id="c3f1" class="ly lz in jm b jn jo jr js jv ma jz mb kd mc kh md me mf mg bi translated">抽象类必须用 abstract 关键字声明。</li><li id="49b8" class="ly lz in jm b jn mh jr mi jv mj jz mk kd ml kh md me mf mg bi translated">它可以有抽象和非抽象的方法。</li><li id="4c97" class="ly lz in jm b jn mh jr mi jv mj jz mk kd ml kh md me mf mg bi translated">它不能被实例化。</li><li id="b175" class="ly lz in jm b jn mh jr mi jv mj jz mk kd ml kh md me mf mg bi translated">它也可以有构造函数和静态方法。</li><li id="07e0" class="ly lz in jm b jn mh jr mi jv mj jz mk kd ml kh md me mf mg bi translated">它可以有最终的方法，强制子类不要改变方法的主体。</li></ul><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/59d3002156e549e2733e310d4675a11f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XiPHp11u8xLVmmFnoqU6rQ.png"/></div></div></figure><h1 id="0295" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">具有抽象方法的抽象类示例:</h1><p id="3fb8" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">在这个例子中，Bike 是一个抽象类，只包含一个抽象方法运行。它的实现由 Honda 类提供。</p><pre class="kk kl km kn gt mm mn mo mp aw mq bi"><span id="69ac" class="mr kw in mn b gy ms mt l mu mv">abstract class Bike{  <br/>  abstract void run();  <br/>}  <br/>class Honda4 extends Bike{  <br/>void run(){System.out.println("running safely");}  <br/>public static void main(String args[]){  <br/> Bike obj = new Honda4();  <br/> obj.run();  <br/>}  <br/>}</span></pre><h1 id="6d6c" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">具有构造函数、数据成员和方法的抽象类:</h1><p id="107d" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">抽象类可以有数据成员、抽象方法、方法体(非抽象方法)、构造函数，甚至 main()方法。</p><pre class="kk kl km kn gt mm mn mo mp aw mq bi"><span id="f493" class="mr kw in mn b gy ms mt l mu mv">//Example of an abstract class that has abstract and non-abstract methods  <br/> abstract class Bike{  <br/>   Bike(){System.out.println("bike is created");}  <br/>   abstract void run();  <br/>   void changeGear(){System.out.println("gear changed");}  <br/> }  <br/>//Creating a Child class which inherits Abstract class  <br/> class Honda extends Bike{  <br/> void run(){System.out.println("running safely..");}  <br/> }  <br/>//Creating a Test class which calls abstract and non-abstract methods  <br/> class TestAbstraction2{  <br/> public static void main(String args[]){  <br/>  Bike obj = new Honda();  <br/>  obj.run();  <br/>  obj.changeGear();</span><span id="f148" class="mr kw in mn b gy mw mt l mu mv">}<br/>}</span></pre><p id="6e12" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在主要的问题出现了，接口和抽象类都有助于抽象，但是我们应该更多地使用哪一个呢？</p><p id="f2ad" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Java 不像 c++那样支持多重继承。我们可以使用接口实现多重继承。</p><p id="67b7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">用于抽象</strong>:</p><p id="ce12" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">抽象类帮助= 1 到 100%</p><p id="39e7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">界面帮助= 100%</p><h1 id="1cbf" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">Java 接口示例</h1><p id="5aff" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">在这个例子中，Drawable 接口只有一个方法。它的实现由 Rectangle 和 Circle 类提供。在真实的场景中，接口由其他人定义，但其实现由不同的实现提供者提供。而且，是别人用的。使用该接口的用户隐藏了实现部分。</p><pre class="kk kl km kn gt mm mn mo mp aw mq bi"><span id="6a50" class="mr kw in mn b gy ms mt l mu mv">//Interface declaration: by first user  <br/>interface Drawable{  <br/>void draw();  <br/>}  <br/>//Implementation: by second user  <br/>class Rectangle implements Drawable{  <br/>public void draw(){System.out.println("drawing rectangle");}  <br/>}  <br/>class Circle implements Drawable{  <br/>public void draw(){System.out.println("drawing circle");}  <br/>}  <br/>//Using interface: by third user  <br/>class TestInterface1{  <br/>public static void main(String args[]){  <br/>Drawable d=new Circle();//In real scenario, object is provided by method e.g. getDrawable()  <br/>d.draw();  <br/>}}</span></pre><h1 id="c6e6" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">Java 中通过接口的多重继承</h1><p id="e513" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">如果一个类实现了多个接口，或者一个接口扩展了多个接口，这就是所谓的多重继承。</p><pre class="kk kl km kn gt mm mn mo mp aw mq bi"><span id="0ad0" class="mr kw in mn b gy ms mt l mu mv">interface Printable{  <br/>void print();  <br/>}  <br/>interface Showable{  <br/>void show();  <br/>}  <br/>class A7 implements Printable,Showable{  <br/>public void print(){System.out.println("Hello");}  <br/>public void show(){System.out.println("Welcome");}  <br/>  <br/>public static void main(String args[]){  <br/>A7 obj = new A7();  <br/>obj.print();  <br/>obj.show();  <br/> }  <br/>}</span></pre><h1 id="242b" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">java 中不支持通过类进行多重继承，但通过接口是可以的，为什么？</h1><p id="2242" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">正如我们在继承中所解释的，由于不明确，在类的情况下不支持多重继承。</p><p id="d6c1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是，在接口的情况下它是受支持的，因为没有歧义。因为它的实现是由实现类提供的。</p><p id="1121" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们希望你理解了接口背后的概念以及为什么使用它们？</p><p id="6c11" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">留下评论，分享你的想法。</p><p id="01e9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">参考:</p><p id="df75" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">https://www.javatpoint.com/abstract-method-in-java<a class="ae mx" href="https://www.javatpoint.com/abstract-method-in-java" rel="noopener ugc nofollow" target="_blank"/></p><p id="5375" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">【https://www.javatpoint.com/class-and-interface-in-java T4】</p></div></div>    
</body>
</html>