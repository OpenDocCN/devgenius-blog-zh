<html>
<head>
<title>Connecting to Database in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">连接到 Go 中的数据库</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/connecting-to-database-in-go-f98c3a7a06a8?source=collection_archive---------2-----------------------#2022-05-02">https://blog.devgenius.io/connecting-to-database-in-go-f98c3a7a06a8?source=collection_archive---------2-----------------------#2022-05-02</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="1cbc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">欢迎回到<em class="ki">Golang Web 开发简介</em>。上次，我们学习了如何使用<code class="fe kj kk kl km b">gorilla/mux</code>。这一次，我们将学习如何建立一个数据库并连接到它。我们开始吧！</p><h1 id="a056" class="kn ko in bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">从为什么开始</h1><p id="dab3" class="pw-post-body-paragraph jk jl in jm b jn ll jp jq jr lm jt ju jv ln jx jy jz lo kb kc kd lp kf kg kh ig bi translated">理解我们为什么需要数据库是很重要的。对于大多数 web 应用程序来说，数据库连接是必要的，因为需要一种可靠地持久存储数据的方法。</p><p id="ff08" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们可以创建一个结构并在那里存储数据。大概是这样的:</p><pre class="lq lr ls lt gt lu km lv lw aw lx bi"><span id="13e0" class="ly ko in km b gy lz ma l mb mc">type BookData struct {<br/>    title string<br/>    author string<br/>    isbn string<br/>}<br/></span><span id="9843" class="ly ko in km b gy md ma l mb mc">books := []BookData{<br/>    {"Tools of Titans", "Tim Ferriss", "978-13-28683-78-6"},<br/>    {"Siddhartha", "Herman Hesse", "978-1529024043"},<br/>}</span></pre><p id="38aa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当然，这可能会存储书籍数据，但在我们的 RAM 中。这不是一个好主意，因为内存存储是不稳定的。当您关闭数据库时，存储在 RAM 中的数据将被销毁。</p><p id="8b29" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">想象一下去法国旅行。你可以看到埃菲尔铁塔，吃最好的餐馆的高级菜肴，结交新朋友。将它存储到内存中就是试图在你的头脑中记住所有这些珍贵的记忆。使用数据库就像拍照并保存到你的电脑上。</p><p id="8118" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对于我们的游戏玩家朋友(比如我！)，想象一下每次有服务器维护的时候，你的账号数据都在重置。呀。</p><p id="2d28" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用适合存储数据的工具是个好主意。<code class="fe kj kk kl km b">database/sql</code>包提供对 SQL 数据库的支持。如果您想使用 NoSQL 数据库，您很可能需要第三方软件包。对于本教程，我们将使用 PostgreSQL。</p><h1 id="cfa2" class="kn ko in bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">创建数据库</h1><p id="30b9" class="pw-post-body-paragraph jk jl in jm b jn ll jp jq jr lm jt ju jv ln jx jy jz lo kb kc kd lp kf kg kh ig bi translated">创建数据库的简单方法是使用 Docker 映像。Docker 是一个让我们在容器内部运行服务的工具。容器化服务允许它们在隔离的环境中运行，使得运行、停止和删除变得容易。</p><p id="fecf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">首先，让我们安装 Docker。我强烈推荐你按照本教程使用简单的 Docker 命令。本教程将安装 Docker，并帮助您了解 Docker 是什么以及它是如何工作的。</p><p id="8812" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一旦你完成了教程，我们就可以开始处理我们的容器了。创建一个名为<code class="fe kj kk kl km b">docker-compose.yml</code>的文件，编辑如下:</p><pre class="lq lr ls lt gt lu km lv lw aw lx bi"><span id="627e" class="ly ko in km b gy lz ma l mb mc">version: "3.7"</span><span id="d125" class="ly ko in km b gy md ma l mb mc">services:<br/>  database:<br/>    container_name: database<br/>    image: postgres<br/>    ports:<br/>      - "5432:5432"<br/>    volumes:<br/>      - ./database:/var/lib/postgresql/data<br/>    environment:<br/>      - POSTGRES_DB=bookstoreDB<br/>      - POSTGRES_USER=jacob<br/>      - POSTGRES_PASSWORD=password</span></pre><p id="e12b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">上面的文件做了几件事:</p><ul class=""><li id="3c8e" class="mf mg in jm b jn jo jr js jv mh jz mi kd mj kh mk ml mm mn bi translated">它从 Docker Hub 中提取<code class="fe kj kk kl km b">postgres</code>图像。</li><li id="e77c" class="mf mg in jm b jn mo jr mp jv mq jz mr kd ms kh mk ml mm mn bi translated">容器打开 5432 端口让我们连接。</li><li id="2477" class="mf mg in jm b jn mo jr mp jv mq jz mr kd ms kh mk ml mm mn bi translated">它设置连接到数据库时要使用的环境变量。</li><li id="dfe5" class="mf mg in jm b jn mo jr mp jv mq jz mr kd ms kh mk ml mm mn bi translated">POSTGRES_USER 和 POSTGRES_PASSWORD 可以是任何值。对于本教程，我使用<code class="fe kj kk kl km b">jacob</code>和<code class="fe kj kk kl km b">password</code>。</li><li id="1852" class="mf mg in jm b jn mo jr mp jv mq jz mr kd ms kh mk ml mm mn bi translated">由于容量的原因，数据在<code class="fe kj kk kl km b">/var/lib/postgresql/data</code>保存在容器中。</li></ul><p id="79ef" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们可以使用以下命令来运行它:</p><pre class="lq lr ls lt gt lu km lv lw aw lx bi"><span id="926e" class="ly ko in km b gy lz ma l mb mc">docker-compose up -d</span></pre><p id="eb72" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们可以使用以下命令来停止这种情况:</p><pre class="lq lr ls lt gt lu km lv lw aw lx bi"><span id="ba2f" class="ly ko in km b gy lz ma l mb mc">docker-compose down</span></pre><p id="b0e1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一旦容器开始运行，我们就可以使用名为 pgAdmin 的工具连接到数据库。在这里为您的操作系统<a class="ae me" href="https://www.pgadmin.org/download/" rel="noopener ugc nofollow" target="_blank">安装 pgAdmin。安装后，打开应用程序。向左，右键点击<code class="fe kj kk kl km b">Servers</code>，并转到<code class="fe kj kk kl km b">Create &gt; Server</code>。</a></p><ul class=""><li id="fff6" class="mf mg in jm b jn jo jr js jv mh jz mi kd mj kh mk ml mm mn bi translated">在“常规”选项卡中，随意命名。转到连接选项卡。</li><li id="3c0c" class="mf mg in jm b jn mo jr mp jv mq jz mr kd ms kh mk ml mm mn bi translated">主机名/地址是<code class="fe kj kk kl km b">localhost</code>。</li><li id="e479" class="mf mg in jm b jn mo jr mp jv mq jz mr kd ms kh mk ml mm mn bi translated">端口是<code class="fe kj kk kl km b">5432</code>。</li><li id="37f4" class="mf mg in jm b jn mo jr mp jv mq jz mr kd ms kh mk ml mm mn bi translated">维护数据库是<code class="fe kj kk kl km b">bookstoreDB</code>。</li><li id="20ee" class="mf mg in jm b jn mo jr mp jv mq jz mr kd ms kh mk ml mm mn bi translated">用户名和密码是您在<code class="fe kj kk kl km b">docker-compose.yml</code>文件中设置的。</li></ul><p id="92a3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">保存后，pgAdmin 将创建一个新的连接。一旦我们下拉到<code class="fe kj kk kl km b">bookstoreDB</code>，我们可以点击顶部工具栏的<code class="fe kj kk kl km b">Tools &gt; Query Tool</code>。这将打开一个窗口，我们可以在其中键入和执行 SQL 查询。</p><p id="c217" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">好吧，设置过程很长，但我们以后不用经常碰它了。让我们继续进行代码。</p><h1 id="c04b" class="kn ko in bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">休斯敦，你收到了吗？</h1><p id="b581" class="pw-post-body-paragraph jk jl in jm b jn ll jp jq jr lm jt ju jv ln jx jy jz lo kb kc kd lp kf kg kh ig bi translated">我们知道为什么我们需要一个数据库，并且已经创建了一个 PostgreSQL 实例。现在我们需要从我们的围棋程序中建立一个连接。</p><pre class="lq lr ls lt gt lu km lv lw aw lx bi"><span id="87c2" class="ly ko in km b gy lz ma l mb mc">// main.go<br/>package main</span><span id="605b" class="ly ko in km b gy md ma l mb mc">import (<br/>    "database/sql"<br/>    "fmt"<br/>    "log"</span><span id="8744" class="ly ko in km b gy md ma l mb mc">    "github.com/gorilla/mux"<br/>    _"github.com/lib/pq"<br/>)</span><span id="e4fd" class="ly ko in km b gy md ma l mb mc">var DB *sql.DB</span><span id="1c46" class="ly ko in km b gy md ma l mb mc">const (<br/>    HOST = "localhost"<br/>    PORT = 5432<br/>    USER = "jacob"<br/>    PASSWORD = "password"<br/>    DBNAME = "bookstoreDB"<br/>)</span><span id="9fc9" class="ly ko in km b gy md ma l mb mc">func main() {<br/>    connString := fmt.Sprintf(<br/>        "host=%s port=%d user=%s password=%s dbname=%s sslmode=disable",<br/>        HOST, PORT, USER, PASSWORD, DBNAME,<br/>    )</span><span id="b9dd" class="ly ko in km b gy md ma l mb mc">    DB, err := sql.Open("postgres", connString)<br/>    if err != nil {<br/>        log.Fatal(err)<br/>    }<br/>    defer DB.Close()</span><span id="f632" class="ly ko in km b gy md ma l mb mc">    // mux definition and route registration (from last tutorial)<br/>    r := mux.NewRouter()</span><span id="0944" class="ly ko in km b gy md ma l mb mc">    r.HandleFunc("/", homeHandler)</span><span id="d767" class="ly ko in km b gy md ma l mb mc">    booksSubR := r.PathPrefix("/books").Subrouter()</span><span id="fe33" class="ly ko in km b gy md ma l mb mc">    booksSubR.HandleFunc("/all", AllHandler).Methods(http.MethodGet)<br/>    booksSubR.HandleFunc("/{isbn}", IspnHandler).Methods(http.MethodGet)<br/>    booksSubR.HandleFunc("/new", NewHandler).Methods(http.MethodPost)<br/>    booksSubR.HandleFunc("/update", UpdateHandler).Methods(http.MethodPut)<br/>    booksSubR.HandleFunc("/delete/{isbn}", DeleteIspnHandler).Methods(http.MethodDelete)</span><span id="93f0" class="ly ko in km b gy md ma l mb mc">    log.Fatal(http.ListenAndServe(":8090", r))<br/>}</span></pre><p id="40b9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是一种非常简单、易于理解的建立联系的方式。</p><pre class="lq lr ls lt gt lu km lv lw aw lx bi"><span id="9dd5" class="ly ko in km b gy lz ma l mb mc">import (<br/>    "database/sql"<br/>    "fmt"<br/>    "log"</span><span id="1c21" class="ly ko in km b gy md ma l mb mc">    "github.com/gorilla/mux"<br/>    _"github.com/lib/pq"   <br/>)</span></pre><p id="1bb3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最后一条进口声明看起来很可疑。为什么开头有下划线？还有，Go 已经提供了<code class="fe kj kk kl km b">database/sql</code>包，为什么还要下载这个包？这些都是很棒的问题！</p><ul class=""><li id="c707" class="mf mg in jm b jn jo jr js jv mh jz mi kd mj kh mk ml mm mn bi translated"><code class="fe kj kk kl km b">database/sql</code>旨在支持许多 SQL 和类似 SQL 的数据库。它不包括所有数据库的驱动程序。包开发者认为将驱动程序从<code class="fe kj kk kl km b">database/sql</code>包中分离出来会更有效。可以把它想象成一个模块化的旅行适配器，其中电源模块保持不变，但插脚可以互换。</li><li id="705d" class="mf mg in jm b jn mo jr mp jv mq jz mr kd ms kh mk ml mm mn bi translated"><code class="fe kj kk kl km b">github.com/lib/pq</code>是 PostgreSQL 的驱动程序。这个包有点不同，因为代码中没有我们使用这个驱动程序的地方。因此，我们在前面加了一个下划线，表示用户正在使用这个驱动程序，但没有主动调用它。</li></ul><p id="e14b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">确保运行<code class="fe kj kk kl km b">go mod tidy</code>来更新依赖列表。</p><pre class="lq lr ls lt gt lu km lv lw aw lx bi"><span id="3517" class="ly ko in km b gy lz ma l mb mc">var DB *sql.DB</span></pre><ul class=""><li id="1be2" class="mf mg in jm b jn jo jr js jv mh jz mi kd mj kh mk ml mm mn bi translated">我们使用<code class="fe kj kk kl km b">var DB *sql.DB</code>将连接数据存储为一个全局变量。</li><li id="72fd" class="mf mg in jm b jn mo jr mp jv mq jz mr kd ms kh mk ml mm mn bi translated">数据库被表示为指向结构<code class="fe kj kk kl km b">sql.DB</code>的指针，因为 DB 本身就是一个大结构。取它的指针更有效率。</li></ul><p id="5983" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你不知道指针是什么，那它就是一个存储对象内存地址的变量。</p><ul class=""><li id="4978" class="mf mg in jm b jn jo jr js jv mh jz mi kd mj kh mk ml mm mn bi translated">具有多个属性的大型结构等对象会占用大量空间。传来传去很繁琐，因为程序每次都需要复制很多数据。</li><li id="0271" class="mf mg in jm b jn mo jr mp jv mq jz mr kd ms kh mk ml mm mn bi translated">如果我们使用一个指针，我们只是传递一个对对象的引用，这要简单得多。</li><li id="dcad" class="mf mg in jm b jn mo jr mp jv mq jz mr kd ms kh mk ml mm mn bi translated">当我们整理文件时，我们倾向于创建某些文件夹的快捷方式，对吗？我们不必将文件复制到桌面上。我们只需要创建一个快捷方式，这样可以节省大量宝贵的千兆字节。</li></ul><p id="6b96" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">总有一天，我会写一本关于指针的指南，这样更多的人可以得到帮助。</p><pre class="lq lr ls lt gt lu km lv lw aw lx bi"><span id="024a" class="ly ko in km b gy lz ma l mb mc">const (<br/>    HOST = "localhost"<br/>    PORT = 5432<br/>    USER = "jacob"<br/>    PASSWORD = "password"<br/>    DBNAME = "bookstoreDB"<br/>)</span><span id="92d0" class="ly ko in km b gy md ma l mb mc">func main() {<br/>    connString := fmt.Sprintf(<br/>        "host=%s port=%d user=%s password=%s dbname=%s sslmode=disable",<br/>        HOST, PORT, USER, PASSWORD, DBNAME,<br/>    )</span><span id="3832" class="ly ko in km b gy md ma l mb mc">    DB, err := sql.Open("postgres", connString)<br/>    if err != nil {<br/>        log.Fatal(err)<br/>    }<br/>    defer DB.Close()<br/>}</span></pre><ul class=""><li id="79b2" class="mf mg in jm b jn jo jr js jv mh jz mi kd mj kh mk ml mm mn bi translated">为了连接到我们的数据库，我们需要定义主机、端口、用户名、密码、数据库名和 SSL 模式。这些不会改变，所以把它们声明为常量是个好主意。</li><li id="6317" class="mf mg in jm b jn mo jr mp jv mq jz mr kd ms kh mk ml mm mn bi translated">这些值遵循我们在<code class="fe kj kk kl km b">docker-compse.yml</code>文件中定义的环境变量。</li><li id="96ff" class="mf mg in jm b jn mo jr mp jv mq jz mr kd ms kh mk ml mm mn bi translated"><code class="fe kj kk kl km b">connString</code>是保存所有这些变量的字符串，作为选项传递给<code class="fe kj kk kl km b">sql.Open()</code>。</li><li id="0617" class="mf mg in jm b jn mo jr mp jv mq jz mr kd ms kh mk ml mm mn bi translated"><code class="fe kj kk kl km b">sql.Open()</code>将我们的程序连接到数据库。它的返回值存储在我们的<code class="fe kj kk kl km b">DB</code>变量中。</li><li id="62ea" class="mf mg in jm b jn mo jr mp jv mq jz mr kd ms kh mk ml mm mn bi translated">我们需要在应用程序不运行时关闭我们的连接，所以我们使用<code class="fe kj kk kl km b">defer</code>关键字在应用程序停止前关闭连接。</li></ul><p id="fdc0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用全局变量适用于像这样的简单应用程序，但不建议在生产中使用，因为全局变量对于突变是不安全的。简单地说，我们无法控制全局变量会发生什么。随着您的进步，依赖注入将会被更频繁地使用。然而，这个概念超出了今天教程的范围。</p><h1 id="a71e" class="kn ko in bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">结论</h1><p id="a6fd" class="pw-post-body-paragraph jk jl in jm b jn ll jp jq jr lm jt ju jv ln jx jy jz lo kb kc kd lp kf kg kh ig bi translated">感谢您的阅读！我希望今天讨论查询，但是这会使教程太长。此外，引入 Docker 和 PostgreSQL 等新工具已经让人难以接受。下一个教程将是关于查询数据库的，所以请继续关注！</p><p id="1b67" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你也可以在<a class="ae me" href="https://dev.to/jpoly1219/connecting-to-database-in-go-4m95" rel="noopener ugc nofollow" target="_blank"> Dev.to </a>和<a class="ae me" href="https://jpoly1219.github.io" rel="noopener ugc nofollow" target="_blank">我的个人网站</a>上阅读这个帖子。</p></div></div>    
</body>
</html>