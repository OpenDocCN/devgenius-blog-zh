<html>
<head>
<title>Export docx file with python-docx in Django app</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Django应用程序中使用python-docx导出docx文件</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/export-docx-file-with-python-docx-in-django-app-527ff5eb7280?source=collection_archive---------1-----------------------#2021-04-14">https://blog.devgenius.io/export-docx-file-with-python-docx-in-django-app-527ff5eb7280?source=collection_archive---------1-----------------------#2021-04-14</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/d74510bbc8c5f224db17d4637e7103f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JYabE9GkiOFRNLWYE1HIRQ.png"/></div></div></figure><div class=""/><p id="076c" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">导出文件是一个常用的功能，允许用户检索他们的数据。</p><p id="71c0" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在整个系列中，我将概述在Django应用程序中导出文件的各种方法。导出的文件格式可能包括docx、csv、zip或pdf。</p><p id="e325" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这个系列的第一篇文章中，我将介绍导出一个<strong class="jx iz"> docx </strong>文件的过程。我们将利用一个名为python-docx的库来实现这一点。</p></div><div class="ab cl kt ku hr kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ig ih ii ij ik"><h1 id="21c3" class="la lb iy bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">python-docx</h1><h2 id="1fa7" class="ly lb iy bd lc lz ma dn lg mb mc dp lk kg md me lo kk mf mg ls ko mh mi lw mj bi translated">介绍</h2><p id="fdc7" class="pw-post-body-paragraph jv jw iy jx b jy mk ka kb kc ml ke kf kg mm ki kj kk mn km kn ko mo kq kr ks ig bi translated">python-dox是一个python库，用于创建和更新Microsoft Word(。docx)文件。(请在此查看<a class="ae mp" href="https://python-docx.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank">官方文件</a>)</p><p id="f32b" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">python-docx背后的基本概念是创建一个文档对象，您可以向其中添加内容，如段落、标题、分页符、表格、图片以及粗体或斜体等样式选项。</p><p id="7a01" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">示例:</p><pre class="mq mr ms mt gt mu mv mw bn mx my bi"><span id="ab29" class="mz lb iy mv b be na nb l nc nd">from docx import Document<br/>document = Document()<br/>document.add_paragraph('Lorem ipsum dolor sit amet.')</span></pre><h2 id="3b1f" class="ly lb iy bd lc lz ma dn lg mb mc dp lk kg md me lo kk mf mg ls ko mh mi lw mj bi translated">安装</h2><p id="b049" class="pw-post-body-paragraph jv jw iy jx b jy mk ka kb kc ml ke kf kg mm ki kj kk mn km kn ko mo kq kr ks ig bi translated">要安装<a class="ae mp" href="https://pypi.org/project/python-docx/" rel="noopener ugc nofollow" target="_blank"> python-docx </a>，运行命令:</p><pre class="mq mr ms mt gt mu mv mw bn mx my bi"><span id="fffe" class="mz lb iy mv b be na nb l nc nd">pip install python-docx</span></pre><p id="ae3d" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你正在使用docker，并且有一个<strong class="jx iz"> requirement.txt </strong>文件，你可以在上面添加你所有的库，不要忘记添加“python-docx”版本。</p><h1 id="8a18" class="la lb iy bd lc ld ne lf lg lh nf lj lk ll ng ln lo lp nh lr ls lt ni lv lw lx bi translated">导出视图</h1><p id="23ec" class="pw-post-body-paragraph jv jw iy jx b jy mk ka kb kc ml ke kf kg mm ki kj kk mn km kn ko mo kq kr ks ig bi translated">为了能够通过API下载docx文件，我们通常创建一个只允许GET方法的视图。</p><pre class="mq mr ms mt gt mu mv nj nk aw nl bi"><span id="c36c" class="ly lb iy mv b gy nm nn l no nd"><strong class="mv iz">class</strong> ExportDocx(APIView):<br/>    <strong class="mv iz">def</strong> get(self, request, *args, **kwargs):<br/>        # create an empty document object<br/>        document = Document()<br/><br/>        # save document info<br/>        buffer = io.BytesIO()<br/>        document.save(buffer)  # save your memory stream<br/>        buffer.seek(0)  # rewind the stream<br/><br/>        # put them to streaming content response <br/>        # within docx content_type<br/>        response = StreamingHttpResponse(<br/>            streaming_content=buffer,  # use the stream's content<br/>            content_type='<!-- -->application/vnd.openxmlformats-officedocument.wordprocessingml.document<!-- -->'<br/>        )<br/><br/>        response['Content-Disposition'] = 'attachment;filename=Test.docx'<br/>        response["Content-Encoding"] = 'UTF-8'<br/><br/>        <strong class="mv iz">return</strong> response</span></pre><p id="cf24" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一旦我们创建了一个空文档，下一步就是保存它并将其发送给响应。</p><p id="eeca" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz"> python-docx </strong>提供了一个<strong class="jx iz"> document.save() </strong>方法，接受流而不是文件名。</p><p id="f540" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们可以初始化一个<strong class="jx iz"> io。BytesIO() </strong>对象来存储文档信息，然后将其发送给用户。</p><p id="963d" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了处理大量数据并返回响应，我们使用了<strong class="jx iz"> StreamingHttpResponse </strong>函数，并将docx文件的内容类型设置为<strong class="jx iz">application/vnd . openxml formats-office document . wordprocessingm</strong>。</p><h1 id="8759" class="la lb iy bd lc ld ne lf lg lh nf lj lk ll ng ln lo lp nh lr ls lt ni lv lw lx bi translated">构建文档内容</h1><p id="b2c8" class="pw-post-body-paragraph jv jw iy jx b jy mk ka kb kc ml ke kf kg mm ki kj kk mn km kn ko mo kq kr ks ig bi translated">在启用下载空docx文件后，下一步是开始为docx构建内容。详细说明建议参考python-docx文档。</p><p id="7870" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">要添加标题文本，您可以使用<strong class="jx iz">。add_heading() </strong>方法，而要添加段落，可以使用<strong class="jx iz">。</strong>add _ paragraph()方法。</p><p id="d3c9" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果您想要样式化文本，您可以在段落中添加一个段落。</p><p id="537a" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">作为一个例子，我创建了一个<strong class="jx iz"> build_document() </strong>方法来构建文档中的所有内容。</p><pre class="mq mr ms mt gt mu mv mw bn mx my bi"><span id="819d" class="mz lb iy mv b be na nb l nc nd">def build_document(self):<br/>    document = Document() <br/><br/>    # add a header<br/>    document.add_heading("This is a header")<br/><br/>    # add a paragraph<br/>    document.add_paragraph("This is a normal style paragraph")<br/><br/>    # add a paragraph within an italic text then go on with a break.<br/>    paragraph = document.add_paragraph()<br/>    run = paragraph.add_run()<br/>    run.italic = True<br/>    run.add_text("text will have italic style")<br/>    run.add_break()<br/>    <br/>    return document</span></pre><p id="8cfa" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后，我将用下面的代码替换在视图中创建空文档的代码:</p><pre class="mq mr ms mt gt mu mv mw bn mx my bi"><span id="c040" class="mz lb iy mv b be na nb l nc nd">document = self.build_document()</span></pre><p id="bafa" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当前导出结果如下所示:</p><figure class="mq mr ms mt gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi np"><img src="../Images/c75078cb560cda28336020aa1b86b0ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6WwDktlFfBnFCRf0qBhDbg.png"/></div></div><figcaption class="nq nr gj gh gi ns nt bd b be z dk translated">。从Django使用python-docx导出docx文件</figcaption></figure><h1 id="9168" class="la lb iy bd lc ld ne lf lg lh nf lj lk ll ng ln lo lp nh lr ls lt ni lv lw lx bi translated">高级—构建html内容</h1><p id="4841" class="pw-post-body-paragraph jv jw iy jx b jy mk ka kb kc ml ke kf kg mm ki kj kk mn km kn ko mo kq kr ks ig bi translated">本质上，我可以导出一个包含内容的docx文件。首先，我简单地在一个段落中添加内容:</p><pre class="mq mr ms mt gt mu mv mw bn mx my bi"><span id="f98f" class="mz lb iy mv b be na nb l nc nd"># add paragraph for html content<br/>document.add_paragraph("&lt;p&gt;Nice to see Prep note 2&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Prep note 2 content 1&lt;/li&gt;&lt;li&gt;Prep note 2 content 2&lt;/li&gt;&lt;/ul&gt;")</span></pre><p id="2fce" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然而，有一个奇怪的显示如下:</p><figure class="mq mr ms mt gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi np"><img src="../Images/8bcd9900f81da959e89d5cdc98344c47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WqKUPW8OMobySfujhz217Q.png"/></div></div></figure><p id="806d" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我需要找到一种方法，将HTML内容转换成纯文本，同时保留基本格式，如斜体、粗体和项目符号。下面是一个示例:</p><p id="ce28" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="nu">很高兴看到准备注释2 <br/> ●准备注释2内容1 <br/> ●准备注释2内容2 </em></p><p id="d1c5" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">经过研究，我发现了一个Python内置库，叫做<a class="ae mp" href="https://docs.python.org/3/library/html.parser.html" rel="noopener ugc nofollow" target="_blank">html . parser</a>——简单的HTML和XHTML解析器。</p><p id="4867" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">遵循<a class="ae mp" href="https://github.com/python-openxml/python-docx/issues/352" rel="noopener ugc nofollow" target="_blank">示例</a>创建一个名为<strong class="jx iz"> DocumentHTMLParser </strong>的类来处理它，如下所示:</p><pre class="mq mr ms mt gt mu mv mw bn mx my bi"><span id="593e" class="mz lb iy mv b be na nb l nc nd">class DocumentHTMLParser(HTMLParser):<br/>    """<br/>    Document Within HTML Parser<br/>    """<br/>    def __init__(self, document):<br/>        """<br/>        Override __init__ method<br/>        """<br/>        HTMLParser.__init__(self)<br/>        self.document = document<br/>        self.paragraph = None<br/>        self.run = None<br/><br/>    def add_paragraph_and_feed(self, html):<br/>        """<br/>        Custom method where add paragraph and feed<br/>        """<br/>        self.paragraph = self.document.add_paragraph()<br/>        self.feed(html)<br/><br/>    def handle_starttag(self, tag, attrs):<br/>        """<br/>        Override handle_starttag method<br/>        """<br/>        self.run = self.paragraph.add_run()<br/><br/>        if tag in ["ul"]:<br/>            self.run.add_break()<br/>        if tag in ["li"]:<br/>            self.run.add_text(u'        \u2022    ')<br/><br/>    def handle_endtag(self, tag):<br/>        """<br/>        Override handle_endtag method<br/>        """<br/>        if tag in ["li"]:<br/>            self.run.add_break()<br/><br/>    def handle_data(self, data):<br/>        """Override handle_data method"""<br/>        self.run.add_text(data)</span></pre><p id="52b6" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">上面的代码涉及重写HTMLParser类中的一个函数，并使用段落的运行来基于开始标记定制其样式。如果某个标签需要在末尾处中断，我们会为其添加一个中断。然后，我在视图中使用这个自定义类来处理HTML内容:</p><pre class="mq mr ms mt gt mu mv mw bn mx my bi"><span id="7bb1" class="mz lb iy mv b be na nb l nc nd">def build_document(self):<br/>    """Build content document"""<br/>    document = Document()<br/>    doc_html_parser = DocumentHTMLParser(document)<br/><br/>    # add a header<br/>    document.add_heading("This is a header")<br/><br/>    # add a paragraph<br/>    document.add_paragraph("This is a normal style paragraph")<br/><br/>    # add a paragraph within an italic text then go on with a break.<br/>    paragraph = document.add_paragraph()<br/>    run = paragraph.add_run()<br/>    run.italic = True<br/>    run.add_text("text will have italic style")<br/>    run.add_break()<br/>    <br/>    # with html content, call method add_paragraph_and_feed tui build content<br/>    html_content = "&lt;p&gt;Nice to see Prep note 2&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Prep note 2 content 1&lt;/li&gt;&lt;li&gt;Prep note 2 content 2&lt;/li&gt;&lt;/ul&gt;"<br/>    doc_html_parser.add_paragraph_and_feed(html_content)</span></pre><p id="ff7e" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">以下是HTML内容生成的docx文件:</p><figure class="mq mr ms mt gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi nv"><img src="../Images/c28452765c8084230c9defb46313a027.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r38ObgWQsmYXXdV6sVwOYQ.png"/></div></div></figure><h1 id="36e7" class="la lb iy bd lc ld ne lf lg lh nf lj lk ll ng ln lo lp nh lr ls lt ni lv lw lx bi translated">单元测试</h1><p id="7dee" class="pw-post-body-paragraph jv jw iy jx b jy mk ka kb kc ml ke kf kg mm ki kj kk mn km kn ko mo kq kr ks ig bi translated">在后端，单元测试是保护应用程序的关键组件。在我的项目中，通过测试，每个拉请求至少需要80%的代码覆盖率，这使得单元测试成为开发过程中的一个强制性部分。为了帮助编写单元测试，我们使用了诸如<a class="ae mp" href="https://factoryboy.readthedocs.io/en/stable/" rel="noopener ugc nofollow" target="_blank"> factory_boy </a>和<a class="ae mp" href="https://docs.pytest.org/en/stable/" rel="noopener ugc nofollow" target="_blank"> pytest </a>之类的库。如果您不熟悉这些库，您可以在继续之前查看提供的链接。</p><p id="599f" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这一节中，我将不涉及如何使用或编写Django应用程序的单元测试。相反，我将确保导出的docx文件具有正确的名称和类型，并且该文件包含预期的内容和样式。</p><h2 id="ca84" class="ly lb iy bd lc lz ma dn lg mb mc dp lk kg md me lo kk mf mg ls ko mh mi lw mj bi translated">测试内容响应</h2><p id="162a" class="pw-post-body-paragraph jv jw iy jx b jy mk ka kb kc ml ke kf kg mm ki kj kk mn km kn ko mo kq kr ks ig bi translated">我对导出的文件进行了一些基本检查，例如验证响应状态、内容类型和文件名。</p><pre class="mq mr ms mt gt mu mv mw bn mx my bi"><span id="6d36" class="mz lb iy mv b be na nb l nc nd">def test_export_docx_general(self):<br/>    """<br/>    Ensure general content like<br/>    status response, content type, file name exported correctly<br/>    """<br/>    response = self.client.get(reverse("export_docx"))<br/>    import pdb;pdb.set_trace()</span></pre><p id="44ff" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">通过使用<strong class="jx iz">导入pdbpdb.set_trace() </strong>在单元测试中提出<strong class="jx iz"> GET </strong>请求后，我可以检查当前数据了。</p><p id="1195" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">以下是它的一个示例:</p><pre class="mq mr ms mt gt mu mv mw bn mx my bi"><span id="99a1" class="mz lb iy mv b be na nb l nc nd">&lt;django.http.response.StreamingHttpResponse object at 0x7fc392a61990&gt;<br/>(Pdb) response.status_code<br/>200<br/>(Pdb) response.streaming_content<br/>&lt;map object at 0x7fc3927aadd0&gt;<br/>(Pdb) response.streaming_content.__dir__()<br/>['__getattribute__', '__iter__', '__next__', '__new__', '__reduce__', '__doc__', '__repr__', '__hash__', '__str__', '__setattr__', '__delattr__', '__lt__', '__le__', '__eq__', '__ne__', '__gt__', '__ge__', '__init__', '__reduce_ex__', '__subclasshook__', '__init_subclass__', '__format__', '__sizeof__', '__dir__', '__class__']<br/>(Pdb) response.get("Content-Type")<br/>'application/vnd.openxmlformats-officedocument.wordprocessingml.document'<br/>(Pdb) response.get("Content-Disposition")<br/>'attachment;filename=Recipe_Pho_2021-04-15-14-34-09.docx'</span></pre><p id="6dce" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如前面的代码块所示，我可以继续编写单元测试来检查导出文件的一般内容，例如文件的内容类型、状态代码和名称。</p><pre class="mq mr ms mt gt mu mv mw bn mx my bi"><span id="a18a" class="mz lb iy mv b be na nb l nc nd">def test_export_docx_general(self):<br/>    """<br/>    Ensure general content like<br/>    status response, content type, file name exported correctly<br/>    """<br/>    response = self.client.get(reverse("export_docx"))<br/>    assert response.status_code == status.HTTP_200_OK<br/>    assert response.get("Content-Type") == \<br/>        "application/vnd.openxmlformats-officedocument.wordprocessingml.document"<br/>    filename = response.get("Content-Disposition").split("=")<br/>    assert filename == "Test.docx"</span></pre><p id="e0fe" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">请注意上面的<strong class="jx iz">response . streaming _ content</strong>对象，该对象显示为地图对象，没有任何测试数据。最初，我不确定如何准确测试文档的内容和风格。尽管研究了各种方案，我还是找不到合适的解决方案。</p><p id="ebde" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后，我自己想出了一个测试构建文档的解决方案，如下所示:</p><h2 id="1485" class="ly lb iy bd lc lz ma dn lg mb mc dp lk kg md me lo kk mf mg ls ko mh mi lw mj bi translated">测试文档内容</h2><p id="6f2e" class="pw-post-body-paragraph jv jw iy jx b jy mk ka kb kc ml ke kf kg mm ki kj kk mn km kn ko mo kq kr ks ig bi translated">我在代码中创建了一个名为<strong class="jx iz"> build_document </strong>的函数来构建文档，现在可以进行测试了:</p><pre class="mq mr ms mt gt mu mv mw bn mx my bi"><span id="48d7" class="mz lb iy mv b be na nb l nc nd">def build_document(self):<br/>    """Build content document"""<br/>    document = Document()<br/>    doc_html_parser = DocumentHTMLParser(document)<br/><br/>    # with html content, call method add_paragraph_and_feed tui build content<br/>    html_content = "&lt;p&gt;Nice to see Prep note 2&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Prep note 2 content 1&lt;/li&gt;&lt;li&gt;Prep note 2 content 2&lt;/li&gt;&lt;/ul&gt;"<br/>    doc_html_parser.add_paragraph_and_feed(html_content)</span></pre><p id="86e3" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我的解决方案是直接调用这个函数在模拟视图上进行测试。下面是它在测试函数中的表现:</p><pre class="mq mr ms mt gt mu mv mw bn mx my bi"><span id="e8f2" class="mz lb iy mv b be na nb l nc nd">def test_build_document_for_docx(self):<br/>    """Ensure document built content and style correctly"""<br/>    # inline import just for you know where they are<br/>    from django.http import HttpRequest<br/>    from rest_framework.request import Request as DRFRequest<br/><br/>    # mock drf request<br/>    request = HttpRequest()<br/>    request.method = 'GET'<br/>    drf_request = DRFRequest(request)<br/>    drf_request.user = self.user<br/><br/>    # mock view with request<br/>    view = ExportRecipesDocx()<br/>    view.request = request<br/><br/>    # call function in view directly<br/>    document = view.build_document()<br/>    import pdb;pdb.set_trace()</span></pre><p id="6e7d" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我再次检查了文档配置文件。作为一个例子，我只是有一个个人的好奇心和爱探索他们are^^</p><pre class="mq mr ms mt gt mu mv mw bn mx my bi"><span id="4363" class="mz lb iy mv b be na nb l nc nd">(Pdb) document<br/>&lt;docx.document.Document object at 0x7fd5e65140a0&gt;<br/>(Pdb) document._body.paragraphs<br/>[&lt;docx.text.paragraph.Paragraph object at 0x7fd5e5d5fb50&gt;]<br/>(Pdb) document._body.paragraphs[0].runs<br/>[&lt;docx.text.run.Run object at 0x7fd5e5e419d0&gt;, &lt;docx.text.run.Run object at 0x7fd5e5eba6d0&gt;, &lt;docx.text.run.Run object at 0x7fd5e5eba410&gt;, &lt;docx.text.run.Run object at 0x7fd5e5eba3d0&gt;]<br/>(Pdb) document._body.paragraphs[0].runs[0].text<br/>'Nice to see Prep note 2\n'<br/>(Pdb) document._body.paragraphs[0].runs[0].style.name<br/>'Default Paragraph Font'<br/>(Pdb) document._body.paragraphs[0].runs[0].style.priority<br/>1<br/>(Pdb) document._body.paragraphs[0].runsp[1].text</span></pre><p id="8836" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在我当前的<strong class="jx iz"> build_document </strong>方法中，我创建了一个段落并向其中添加了一些段落，同时还根据HTML的开始和结束标签在必要的地方插入了分隔符。</p><p id="0fc9" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下面是我的单元测试的最终版本，用于检查文档的内容和样式:</p><pre class="mq mr ms mt gt mu mv mw bn mx my bi"><span id="c63a" class="mz lb iy mv b be na nb l nc nd">def test_build_document_for_docx(self):<br/>    """Ensure document built content and style correctly"""<br/>    # mock request and view initialize like above code<br/>    # ...<br/>    # call function in view directly<br/>    document = view.build_document()<br/><br/>    paragraphs = document._body.paragraphs<br/>    assert len(paragraphs) == 1<br/>    assert paragraphs[0].style.name == "Normal"<br/>    assert paragraphs[0].style.priority is None<br/>    assert [<br/>        'Nice to see Prep note 2',<br/>        '\n',<br/>        '        •    Prep note 2 content 1\n',<br/>        '        •    Prep note 2 content 2\n'<br/>    ] == [item.text for item in paragraphs[0].runs]<br/>    assert {None} == {item.italic for item in paragraphs[0].runs}<br/>    assert {None} == {item.bold for item in paragraphs[0].runs}</span></pre></div><div class="ab cl kt ku hr kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ig ih ii ij ik"><p id="48de" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在Django应用程序中导出文件是一个迷人的过程，Python有几个库对处理内容格式很有用。</p><p id="fe9d" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在本文中，我们讨论了一个在Django应用程序中导出docx文件的简单例子。</p></div><div class="ab cl kt ku hr kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ig ih ii ij ik"><p id="64e0" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你觉得这很有帮助，请考虑在下面的<a class="ae mp" href="https://ko-fi.com/beautyoncode" rel="noopener ugc nofollow" target="_blank">链接</a>给我买杯咖啡。</p><p id="0af2" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我的个人博客上的<a class="ae mp" href="https://beautyoncode.com/export-docx-file-with-python-docx-in-django-app/" rel="noopener ugc nofollow" target="_blank">原帖欢迎您的访问。</a></p></div></div>    
</body>
</html>