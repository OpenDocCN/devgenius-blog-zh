# Elixir 如何帮助您编写无错误的并发代码

> 原文：<https://blog.devgenius.io/how-elixir-helps-you-write-bug-free-concurrent-code-97dfd0577f19?source=collection_archive---------10----------------------->

## 这并不神奇，但如果你曾与其他语言中的并发错误作斗争，肯定会有这种感觉

![](img/d0b5d8b7091a0af91112402edb5b40a0.png)

独立进程同时争夺资源——Florian Schmetz 在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的照片

*并发*是指系统同时执行多项操作，在现代软件开发中这几乎是不可避免的。例如，如果您正在构建任何一种处理多个客户端的服务器，那么您将不得不处理并发性。同样，在移动应用程序中，用户界面、网络呼叫等有单独的线程。

不同的语言和框架处理并发的方式不同，公平地说，有些语言和框架比其他语言和框架提供了更好的工具。许多语言公开了诸如线程和各种锁之类的原语，剩下的就留给开发人员去解决了。虽然这些是构建并发应用程序所需要的核心工具，但是构建无错误的并发代码却很难。

在这篇文章中，我们将看看并发编程是如何出错的，以及 [Elixir 编程语言](http://elixir-lang.org)如何在 [Erlang/OTP](https://www.erlang.org) (开放电信平台)的帮助下，帮助我们编写无错误的并发代码。

# 并发性—什么会出错(WCGW)？

构建并发应用程序意味着不再能够通过我们编写代码时使用的严格线性流程进行推理——它变成了一个由许多独立运行且相互交互的事物组成的复杂系统。这可能会导致各种各样的问题。

最近一个关于开源软件并发问题的案例研究描述了以下几类潜在的并发错误:

*   *数据竞争* ***，*** 当两个或多个线程试图访问和写入相同的数据时。
*   *死锁:* 当两个或多个线程试图访问受锁保护的共享资源时(通常是为了修复数据竞争！)
*   *活锁:*类似于死锁，除了一个线程实际上没有被锁定——它持续执行，试图获取共享资源。
*   *饥饿:*由于资源被分配给更高优先级的进程，进程不能在分配的时间内完成。
*   *阻塞挂起:*当一个线程等待一个资源的时间长得令人无法接受。类似饿死，但最终成功。
*   *违反顺序:*违反了多线程之间的预期操作顺序。
*   *原子性违反:*一个线程中的两个代码块与另一个线程中的代码块交错，导致计算结果不一致。换句话说，开发人员想要或期望成为原子的代码块并没有被原子地执行。

这些 bug 很难在代码中发现，也很难找到原因。许多“常规的”代码错误可以通过一步一步的过程推理出来。并发性问题并非如此——有时并发性错误只会表现出完全意想不到的事情发生！例如，您的并发代码可能在 99%的情况下都能完美工作，但是当外部服务意外地花费了稍微长一点的时间来响应时，就会触发一个潜在的 bug。

此外，这些错误可能是邪恶的，因为它们可能并不明显——它们可能会悄悄地破坏程序状态，只会在未来引起问题，与实际的代码问题在空间和时间上是分开的。

# Elixir 如何防止并发错误

因此，现在我们已经看到了使用并发性有多可怕，我们将探索 Elixir 如何帮助您避免这些问题。

请注意，虽然 Elixir *帮助*编写无错误的并发代码，但它并不保证*您的代码会这样做。例如，虽然 Elixir 消除了 actor 模式邮箱导致*死锁*的一些常见原因，但是通过让两个或更多的进程相互等待来处理消息，肯定*有可能*造成死锁。这将表明您的代码中存在架构问题，这是很容易避免的，但关键是，长生不老药不会神奇地阻止您这样做。*

也就是说，让我们跳到 Elixir 如何帮助您更正确地编写代码并避免并发问题。

## 函数式编程—无共享状态

处理可变状态是并发系统中最大的问题来源之一。您可能会遇到两个进程试图同时修改同一个结构的错误；或者一个进程试图读取一个正在被另一个进程更新的结构。

这些错误通常使用某种形式的*锁*来解决，这引入了它自己的一组陷阱:性能问题或死锁是在试图解决这种可变性问题时突然出现的常见问题。

Elixir 可以避免并发错误的主要原因之一是因为根本没有可变状态——它是一种*函数式*编程语言。当然，*状态*有时对于让程序做有用的事情是必要的，所以 Elixir *确实*启用了各种状态，但是它很好地隔离到了流程级别，并作为用新值调用的流程函数来实现。因此，不需要处理*共享的*可变状态，状态管理通常也不需要锁(虽然不太常见，但锁仍然可以用于其他用途，比如外部资源)。

## 演员模型和邮箱

*actor model* 是一种并发方法，它涉及多个称为*actor*的流程，这些流程独立工作并通过*消息*进行交互。当收到消息时，它们可以由一个参与者以线性方式进行处理。

因为消息是在队列中交付的，并且是线性处理的，所以我们可以保证所讨论的代码是自动执行的:我们可以确保一次处理一条消息，并且是完整地处理。

例如，考虑读取、编辑和写入磁盘上的文件的一段代码。如果没有某种形式的同步，当两个线程试图同时写入文件时，文件可能会很快损坏。就像管理共享状态一样，其他语言可能会使用某种锁定机制来解决这个问题，但是在 actor 模型中，它不需要特殊的处理:如果单个进程负责该任务，它将串行处理消息。

actor 模型的另一个有趣的好处是，如果我们设计我们的系统来正确地使用 actor 模型，我们并不真的关心*我们的代码在哪里执行——因为，我们可以与运行在其他服务器上的代码无缝地交互！这可以帮助我们在需要时将应用水平扩展到其他服务器。*

## 轻量级隔离进程

继续参与者模型主题，Elixir 通过使用轻量级的独立进程来鼓励并发性。许多语言和运行时使用 [OS 级*线程*](https://en.wikipedia.org/wiki/Thread_(computing)) 进行并发。

相对而言，操作系统级线程是资源密集型的。它们需要内存分配和释放，在它们的生命周期中需要一定程度的持续内存使用，并且需要专门用于调度的大量 CPU 使用。许多系统对可以创建的线程数量有硬限制和实际限制。虽然它可能因平台和语言而异，但通常这些限制在数百或数千以内，但实际上，许多系统被设计为使用更少的限制(可能少于 10)。

另一方面，Elixir 和 Erlang/OTP 使用[轻量级*进程*](https://www.erlang.org/doc/reference_manual/processes.html) 来代替(不要与 OS 级进程混淆——那些根本不是轻量级的！).一个 Elixir 流程使用非常少的资源来创建和执行，这意味着我们可以创建许多*数万个或更多个*并发运行，而不会对性能产生重大影响，至少对流程管理本身是如此。

这些进程是独立运行的(它们不共享状态),并且是完全隔离的:如果一个进程崩溃，它不会影响任何其他进程。

能够轻松地创建如此多的流程改变了我们构建系统的方式:我们可以为系统的较小部分创建专用的、隔离的流程。例如，我们可以在游戏、聊天应用程序或任何其他类型的实时交互系统中为单个客户端设置单独的进程，并轻松处理成千上万个进程！

请注意，Erlang VM 本身*的确*使用 OS 级线程来执行进程，以便优化 CPU 的使用(通常是 CPU 内核的数量)。但是因为它是一个固定的、少量的线程，所以在线程创建或管理方面没有太多的开销。

## “让它崩溃”——流程树和主管

基于“轻量级隔离进程”线程(请原谅双关语)，使用 Elixir 进行并发管理的一个更吸引人的方面是错误处理哲学。“让它崩溃”意味着因为我们的计算被很好地隔离，我们可以通过简单地让一个进程崩溃来处理某些类型的错误。进程崩溃是完全隔离的，不会使我们的整个系统崩溃，我们可以通过重新初始化进程来恢复。

Erlang/OTP 将流程布置成称为监督树的分层树结构。树中的每个节点负责管理其子节点，包括在进程崩溃时决定如何处理。虽然有许多不同的恢复策略，但最基本的是简单地重启失败的进程。

举个例子，让我们考虑构建一个像 Slack 这样的实时聊天客户端。我们有许多用户通过 Websockets 或一些类似的协议连接到系统。在 Elixir 中，我们可以为每个用户设计一个专用的套接字进程。也许由于客户端的网络连接不良，我们的套接字偶尔会意外关闭——我们如何处理这可能在系统中引起的错误？在 Elixir 中，一个有效的策略是什么都不做——用户的进程将崩溃，而不会影响系统的其余部分，并且可以根据需要用新的进程重新建立连接。

在没有这些独立进程和“让它崩溃”原则的其他系统中，我们至少需要一些异常处理和数据清理，否则单个客户端故障可能会导致整个线程或进程崩溃，影响系统中更多的用户。

# 重述— Elixir 支持开箱即用的并发性

关于 Elixir 并发故事最好的部分是，所有这些都是开箱即用的 Elixir 的一部分。虽然有些语言通过附加组件和第三方库支持其中一些功能，但 Elixir 将这些功能直接构建到语言和运行时本身中。更好的是，这里提到的所有东西不仅用 Elixir 简化了并发性，它们还使并发性具有很高的性能！

因此，虽然您可以用多种语言构建高性能、无错误的并发系统，但您会发现使用 Elixir 要容易得多。如果您厌倦了与死锁或其他多线程问题作斗争，请尝试使用 Elixir。

[*乔纳森*](https://blog.devgenius.io/@jonnystartup) *在创业公司大&小有超过 20 年的工程领导经验。如果你喜欢这篇文章，* [*请考虑给乔纳森留个提示*](https://www.buymeacoffee.com/jonnystartup) *！*