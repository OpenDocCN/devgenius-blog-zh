<html>
<head>
<title>What the Decorators in Plain Words | Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么装修工在平原的话| Python</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/what-the-decorators-in-plain-words-python-b600623ea497?source=collection_archive---------0-----------------------#2022-04-12">https://blog.devgenius.io/what-the-decorators-in-plain-words-python-b600623ea497?source=collection_archive---------0-----------------------#2022-04-12</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/></div><div class="ab cl jk jl hr jm" role="separator"><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp"/></div><div class="ig ih ii ij ik"><figure class="js jt ju jv gt jw gh gi paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="gh gi jr"><img src="../Images/3c542ad1d9f0074d82026269a505b315.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jOOpCexXjH9oBra0"/></div></div></figure><p id="2efa" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">装饰器是 Python 中非常强大和有用的工具，因为它允许程序员<strong class="kf io">修改函数</strong> <strong class="kf io">或类</strong>的行为。装饰者允许我们包装另一个函数，以便扩展包装函数的行为，<strong class="kf io">而不需要对原始函数源代码做任何修改</strong>。</p></div><div class="ab cl jk jl hr jm" role="separator"><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp"/></div><div class="ig ih ii ij ik"><h2 id="d312" class="lb lc in bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">内容计划:</h2><ol class=""><li id="1158" class="lu lv in kf b kg lw kk lx ko ly ks lz kw ma la mb mc md me bi translated"><a class="ae mf" href="#37ef" rel="noopener ugc nofollow"> <em class="mg">学习装饰师的必备条件</em> </a> <em class="mg">。</em></li><li id="685c" class="lu lv in kf b kg mh kk mi ko mj ks mk kw ml la mb mc md me bi translated"><a class="ae mf" href="#d474" rel="noopener ugc nofollow"> <em class="mg">变回装修工</em> </a> <em class="mg">。</em></li><li id="54d9" class="lu lv in kf b kg mh kk mi ko mj ks mk kw ml la mb mc md me bi translated"><a class="ae mf" href="#3b6c" rel="noopener ugc nofollow"> <em class="mg">带参数</em> </a> <em class="mg">的装修功能。</em></li><li id="8eaf" class="lu lv in kf b kg mh kk mi ko mj ks mk kw ml la mb mc md me bi translated"><a class="ae mf" href="#f275" rel="noopener ugc nofollow"><em class="mg"/></a><em class="mg">连锁装修工。</em></li><li id="e017" class="lu lv in kf b kg mh kk mi ko mj ks mk kw ml la mb mc md me bi translated">将参数传递给装饰者。</li><li id="e15b" class="lu lv in kf b kg mh kk mi ko mj ks mk kw ml la mb mc md me bi translated"><a class="ae mf" href="#4806" rel="noopener ugc nofollow"> <em class="mg">调试装修工</em> </a></li><li id="852d" class="lu lv in kf b kg mh kk mi ko mj ks mk kw ml la mb mc md me bi translated"><a class="ae mf" href="#6720" rel="noopener ugc nofollow"> <em class="mg">结论</em> </a> <em class="mg">。</em></li></ol></div><div class="ab cl jk jl hr jm" role="separator"><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp"/></div><div class="ig ih ii ij ik"><figure class="js jt ju jv gt jw gh gi paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="gh gi jr"><img src="../Images/ab5a3a6f9331fcee1af3a7ad68983a28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*sqaLVfP0jQ7-BX8q"/></div></div></figure><h1 id="37ef" class="mm lc in bd ld mn mo mp lg mq mr ms lj mt mu mv lm mw mx my lp mz na nb ls nc bi translated">学习装饰者的先决条件</h1><p id="7885" class="pw-post-body-paragraph kd ke in kf b kg lw ki kj kk lx km kn ko nd kq kr ks ne ku kv kw nf ky kz la ig bi translated">要理解 decorators，你首先要了解 Python 的一些基础知识。</p><p id="313b" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">你应该对 Python 中的<strong class="kf io">一切</strong>(甚至是类)<strong class="kf io">都是对象</strong>这一事实感到舒服。我们定义的名称只是与这些对象相关的标识符。函数不是豁免，它们也是对象(包括属性)。同一个函数对象可以有不同的相关名称。</p><figure class="js jt ju jv gt jw"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="d609" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated"><strong class="kf io">输出:</strong></p><pre class="js jt ju jv gt ni nj nk nl aw nm bi"><span id="2be3" class="lb lc in nj b gy nn no l np nq">Hello<br/>Hello</span></pre><p id="a158" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">当您执行代码时，两个函数返回相同的输出。在这种情况下，<code class="fe nr ns nt nj b">original</code>和<code class="fe nr ns nt nj b">also_original</code>名称指的是同一个功能对象。</p><p id="2d92" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">事情越来越奇怪了。</p><p id="ccb0" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">函数可以作为参数传递给另一个函数。</p><p id="9d49" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">如果你用过 Python 中的<code class="fe nr ns nt nj b">map()</code>、<code class="fe nr ns nt nj b">filter()</code>、<code class="fe nr ns nt nj b">reduce()</code>等函数，那么你就已经知道这个了。</p><p id="6cac" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">这些以其他函数为自变量的函数也称为高阶函数。这方面的一个例子如下:</p><figure class="js jt ju jv gt jw"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="d8c0" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated"><strong class="kf io">输出:</strong></p><pre class="js jt ju jv gt ni nj nk nl aw nm bi"><span id="2037" class="lb lc in nj b gy nn no l np nq">11<br/>9</span></pre><p id="0cd7" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">此外，一个函数可以返回另一个函数:</p><figure class="js jt ju jv gt jw"><div class="bz fp l di"><div class="ng nh l"/></div></figure></div><div class="ab cl jk jl hr jm" role="separator"><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp"/></div><div class="ig ih ii ij ik"><p id="4a54" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated"><strong class="kf io">输出:</strong></p><pre class="js jt ju jv gt ni nj nk nl aw nm bi"><span id="3c87" class="lb lc in nj b gy nn no l np nq">Nested local function</span></pre><p id="b287" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">这里，<code class="fe nr ns nt nj b">is_returned()</code>是一个嵌套的局部函数，它在我们每次调用<code class="fe nr ns nt nj b">is_called()</code>时被定义并返回。</p></div><div class="ab cl jk jl hr jm" role="separator"><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp"/></div><div class="ig ih ii ij ik"><figure class="js jt ju jv gt jw gh gi paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="gh gi nu"><img src="../Images/d760a3cdf0cf6521786cf2a53f5c107b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FN-XDiRVtuteO64L7tddlA.png"/></div></div></figure><h1 id="d474" class="mm lc in bd ld mn mo mp lg mq mr ms lj mt mu mv lm mw mx my lp mz na nb ls nc bi translated">回到装饰者</h1><p id="c23d" class="pw-post-body-paragraph kd ke in kf b kg lw ki kj kk lx km kn ko nd kq kr ks ne ku kv kw nf ky kz la ig bi translated">函数和方法被称为<strong class="kf io">可调用</strong>，因为它们可以被调用。</p><p id="c401" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">实际上，任何实现特殊的<code class="fe nr ns nt nj b">__call__()</code>方法的对象都被称为 callable。因此，在最基本的意义上，装饰器是一个可调用的对象，并返回一个可调用的对象。</p><p id="78eb" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">简而言之，装饰者接受一个函数，添加一些功能并返回它:</p><figure class="js jt ju jv gt jw"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="35bb" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated"><strong class="kf io">输出:</strong></p><pre class="js jt ju jv gt ni nj nk nl aw nm bi"><span id="23f6" class="lb lc in nj b gy nn no l np nq"># say_hi()<br/>Hello!</span><span id="142d" class="lb lc in nj b gy nv no l np nq"># say_hi_ask_question()<br/>I got decorated<br/>Hello!<br/>What`s up?</span></pre><p id="7659" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">函数<code class="fe nr ns nt nj b">say_hi()</code>已经被修饰，返回的函数被命名为<code class="fe nr ns nt nj b">say_hi_ask_question()</code></p><p id="736f" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">您可以看到 decorator 函数向<code class="fe nr ns nt nj b">say_hi()</code>函数添加了一些新的附加特性。这类似于包装礼物。那就像包装礼物一样。装饰工作就像一个包装。被装饰的物体的性质(里面实际的礼物)保持不变。但现在，它看起来很漂亮(因为它已经被装饰)。</p><p id="e3c4" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">通常，我们修饰一个函数，并将其重新赋值为:</p><pre class="js jt ju jv gt ni nj nk nl aw nm bi"><span id="64c5" class="lb lc in nj b gy nn no l np nq">say_hi_ask_question = ask_question(say_hi)</span></pre><p id="d462" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">这是一种常见的结构，因此 Python 有一种语法来简化它。</p><p id="3cd7" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">您可以使用带有装饰函数名称的<code class="fe nr ns nt nj b">@</code>符号，并将它放在要装饰的函数的定义之上。例如:</p><figure class="js jt ju jv gt jw"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="4655" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">相当于:</p><pre class="js jt ju jv gt ni nj nk nl aw nm bi"><span id="1aaa" class="lb lc in nj b gy nn no l np nq">say_hi_ask_question = ask_question(say_hi)</span></pre><p id="cefc" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">这只是实现 decorators 的语法糖。</p></div><div class="ab cl jk jl hr jm" role="separator"><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp"/></div><div class="ig ih ii ij ik"><h1 id="3b6c" class="mm lc in bd ld mn nw mp lg mq nx ms lj mt ny mv lm mw nz my lp mz oa nb ls nc bi translated">用参数修饰函数</h1><p id="e732" class="pw-post-body-paragraph kd ke in kf b kg lw ki kj kk lx km kn ko nd kq kr ks ne ku kv kw nf ky kz la ig bi translated">上面的装饰很简单，只适用于没有参数的函数。如果您的函数采用如下参数，会发生什么情况:</p><figure class="js jt ju jv gt jw"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="7597" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">该功能有两个参数，<code class="fe nr ns nt nj b">a</code>和<code class="fe nr ns nt nj b">b</code>。我们知道如果我们将<code class="fe nr ns nt nj b">b</code>作为<code class="fe nr ns nt nj b">0</code>传入，它会给出一个错误。</p><p id="98e4" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated"><strong class="kf io">输出:</strong></p><pre class="js jt ju jv gt ni nj nk nl aw nm bi"><span id="2178" class="lb lc in nj b gy nn no l np nq">0.4</span><span id="2453" class="lb lc in nj b gy nv no l np nq">Traceback (most recent call last):<br/>...<br/>ZeroDivisionError: division by zero</span></pre><p id="3830" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">让我们编写一个装饰器来检查将导致错误的情况:</p><figure class="js jt ju jv gt jw"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="3fc3" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">如果出现错误情况，这个新工具将返回<code class="fe nr ns nt nj b">None</code>。</p><p id="9d1a" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated"><strong class="kf io">输出:</strong></p><pre class="js jt ju jv gt ni nj nk nl aw nm bi"><span id="6b5a" class="lb lc in nj b gy nn no l np nq">I am going to divide 2 and 5<br/>0.4<br/><br/>I am going to divide 2 and 0<br/>Whoops! cannot divide</span></pre><p id="ba65" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">这允许您修饰接受参数的函数。</p><p id="8882" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">细心的观察者会注意到装饰器中嵌套的<code class="fe nr ns nt nj b">wrapper()</code>函数的参数和它所装饰的函数的参数是一样的。考虑到这一点，我们现在可以编写通用的 decorators 来处理任意数量的参数。</p><p id="ebb6" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">在 Python 中，这种魔术是作为<code class="fe nr ns nt nj b">function(*args, **kwargs)</code>来完成的。这样，<code class="fe nr ns nt nj b">args</code>将是位置参数的元组，<code class="fe nr ns nt nj b">kwargs</code>将是关键字参数的字典。这种装饰器的一个例子是:</p><figure class="js jt ju jv gt jw"><div class="bz fp l di"><div class="ng nh l"/></div></figure></div><div class="ab cl jk jl hr jm" role="separator"><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp"/></div><div class="ig ih ii ij ik"><h1 id="f275" class="mm lc in bd ld mn nw mp lg mq nx ms lj mt ny mv lm mw nz my lp mz oa nb ls nc bi translated">链接装饰者</h1><p id="529d" class="pw-post-body-paragraph kd ke in kf b kg lw ki kj kk lx km kn ko nd kq kr ks ne ku kv kw nf ky kz la ig bi translated">在 Python 中，多个装饰者可以链接在一起。</p><p id="7867" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">这意味着一个<strong class="kf io">函数可以用不同的(或相同的)装饰者装饰几次</strong>。只需将装饰器放在所需功能之上:</p><figure class="js jt ju jv gt jw"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="6da5" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated"><strong class="kf io">输出:</strong></p><pre class="js jt ju jv gt ni nj nk nl aw nm bi"><span id="2ced" class="lb lc in nj b gy nn no l np nq">******************************<br/>------------------------------<br/>There are symbols around me<br/>------------------------------<br/>******************************</span></pre><p id="d9d4" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">上面的语法为:</p><pre class="js jt ju jv gt ni nj nk nl aw nm bi"><span id="5daf" class="lb lc in nj b gy nn no l np nq">@star<br/>@line<br/>def print_msg(msg):<br/>    print(msg)</span></pre><p id="51c6" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">相当于:</p><pre class="js jt ju jv gt ni nj nk nl aw nm bi"><span id="1f83" class="lb lc in nj b gy nn no l np nq">def print_msg(msg):<br/>    print(msg)</span><span id="5b37" class="lb lc in nj b gy nv no l np nq"><br/>print_msg = star(line(print_msg))</span></pre><p id="4b9c" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated"><strong class="kf io">我们链接装饰者<strong class="kf io">的顺序</strong>很重要</strong>。如果您将顺序颠倒为:</p><pre class="js jt ju jv gt ni nj nk nl aw nm bi"><span id="ac2d" class="lb lc in nj b gy nn no l np nq">@line<br/>@star<br/>def print_msg(msg):<br/>    print(msg)</span></pre><p id="fbfb" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated"><strong class="kf io">输出将是:</strong></p><pre class="js jt ju jv gt ni nj nk nl aw nm bi"><span id="7dbb" class="lb lc in nj b gy nn no l np nq">------------------------------<br/>******************************<br/>There are symbols around me<br/>******************************<br/>------------------------------</span></pre></div><div class="ab cl jk jl hr jm" role="separator"><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp"/></div><div class="ig ih ii ij ik"><h1 id="65f0" class="mm lc in bd ld mn nw mp lg mq nx ms lj mt ny mv lm mw nz my lp mz oa nb ls nc bi translated">将参数传递给装饰者</h1><p id="e72a" class="pw-post-body-paragraph kd ke in kf b kg lw ki kj kk lx km kn ko nd kq kr ks ne ku kv kw nf ky kz la ig bi translated">让我们谈谈如何<strong class="kf io">将参数传递给装饰器本身</strong>。为了实现这一点，我们定义了一个接受参数的装饰器，然后在其中定义了一个装饰器。接下来，我们像前面一样在装饰器中定义一个包装函数。</p><figure class="js jt ju jv gt jw"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="76fe" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated"><strong class="kf io">输出:</strong></p><pre class="js jt ju jv gt ni nj nk nl aw nm bi"><span id="133d" class="lb lc in nj b gy nn no l np nq">The wrapper can access all the variables<br/>	- from the decorator maker: Hello this is an argument of the decorator<br/>	- from the function call: Hi this is argument of the function<br/>and pass them to the decorated function<br/><br/>This is the decorated function and it only knows about its arguments:<br/>Hi this is argument of the function</span></pre><p id="f38b" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">如果去掉<code class="fe nr ns nt nj b">@decorator_maker_with_arguments("Hello", "this is an argument of decorator")</code></p><p id="f4bc" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated"><strong class="kf io">输出将是:</strong></p><pre class="js jt ju jv gt ni nj nk nl aw nm bi"><span id="db94" class="lb lc in nj b gy nn no l np nq">This is the decorated function and it only knows about its arguments:<br/>Hi this is an argument of the function</span></pre></div><div class="ab cl jk jl hr jm" role="separator"><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp"/></div><div class="ig ih ii ij ik"><figure class="js jt ju jv gt jw gh gi paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="gh gi ob"><img src="../Images/efa860e8f529091bf2e948eaca73e376.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MvmWhcWk6dZx-v1UsSSgMQ.png"/></div></div></figure><h1 id="4806" class="mm lc in bd ld mn mo mp lg mq mr ms lj mt mu mv lm mw mx my lp mz na nb ls nc bi translated">调试装饰器</h1><p id="2f03" class="pw-post-body-paragraph kd ke in kf b kg lw ki kj kk lx km kn ko nd kq kr ks ne ku kv kw nf ky kz la ig bi translated">正如我们已经注意到的，装饰者包装函数。原始函数名、它的 docstring 和参数列表<strong class="kf io">都被封装器</strong>隐藏了。例如，当我们试图访问<code class="fe nr ns nt nj b">decorated_function_with_arguments</code>元数据时，我们将看到包装器关闭元数据。这给调试带来了挑战。</p><pre class="js jt ju jv gt ni nj nk nl aw nm bi"><span id="e321" class="lb lc in nj b gy nn no l np nq">decorated_function_with_arguments.__name__</span><span id="a3bc" class="lb lc in nj b gy nv no l np nq">'wrapper'</span><span id="de8b" class="lb lc in nj b gy nv no l np nq">decorated_function_with_arguments.__doc__</span><span id="5bf0" class="lb lc in nj b gy nv no l np nq">'This is the wrapper function'</span></pre><p id="931e" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">为了解决这个挑战，Python 提供了一个<code class="fe nr ns nt nj b">functools.wraps</code>装饰器。这个装饰器将丢失的元数据从未装饰的函数复制到装饰的结束函数中。让我们展示一下如何做到这一点。</p><figure class="js jt ju jv gt jw"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="1f1a" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated"><strong class="kf io">输出将是:</strong></p><pre class="js jt ju jv gt ni nj nk nl aw nm bi"><span id="202f" class="lb lc in nj b gy nn no l np nq">'HELLO THERE'</span></pre><p id="94d7" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">当我们检查<code class="fe nr ns nt nj b">say_hi()</code>元数据时，我们注意到它现在引用的是函数的元数据，而不是包装器的元数据。</p><pre class="js jt ju jv gt ni nj nk nl aw nm bi"><span id="a253" class="lb lc in nj b gy nn no l np nq">say_hi.__name__</span><span id="4ca5" class="lb lc in nj b gy nv no l np nq">'say_hi'</span><span id="314c" class="lb lc in nj b gy nv no l np nq">say_hi.__doc__</span><span id="7240" class="lb lc in nj b gy nv no l np nq">'This will say hi'</span></pre><p id="2d26" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated"><strong class="kf io">任何时候都建议用</strong> <code class="fe nr ns nt nj b">functools.wraps</code>来定义装修工。这将有助于您在调试过程中避免头痛。</p></div><div class="ab cl jk jl hr jm" role="separator"><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp"/></div><div class="ig ih ii ij ik"><figure class="js jt ju jv gt jw gh gi paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="gh gi nu"><img src="../Images/e7643a2f1c1d2677d33a8a33c8716572.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JnkISvQTWq7B1WJE2Qn5YQ.jpeg"/></div></div></figure><h1 id="6720" class="mm lc in bd ld mn mo mp lg mq mr ms lj mt mu mv lm mw mx my lp mz na nb ls nc bi translated">结论</h1><p id="f9ac" class="pw-post-body-paragraph kd ke in kf b kg lw ki kj kk lx km kn ko nd kq kr ks ne ku kv kw nf ky kz la ig bi translated">装饰器是一种优雅的方式，可以在不修改源代码的情况下扩展原始函数的功能。此外，您定义的 decorators 可以接受参数或者恢复到一组预定义的默认参数。这篇文章介绍了装饰者的基本知识，以及如何将它们整合到我们的功能设计中。</p></div><div class="ab cl jk jl hr jm" role="separator"><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp"/></div><div class="ig ih ii ij ik"><p id="c446" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated"><em class="mg">附言:如果你喜欢这篇文章，</em> <a class="ae mf" href="https://medium.com/@vlad.bashtannyk" rel="noopener"> <em class="mg">关注我</em> </a>，<em class="mg">点击“拍手”几下，</em> <em class="mg">留下反馈。祝你好运，高效编程！谢谢大家！</em></p><p id="2b1e" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated"><a class="ae mf" href="https://www.linkedin.com/in/vladyslav-bashtannyk/" rel="noopener ugc nofollow" target="_blank"><em class="mg">LinkedIn</em></a><em class="mg">——</em><a class="ae mf" href="https://twitter.com/VladyslavBasht2" rel="noopener ugc nofollow" target="_blank"><em class="mg">Twitter</em></a></p></div></div>    
</body>
</html>