<html>
<head>
<title>Elasticsearch in Action: Boosting scores using Distance Feature Query</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">弹性搜索实践:使用距离特征查询提高得分</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/elasticsearch-in-action-boosting-scores-using-distance-feature-query-7546b2dea284?source=collection_archive---------8-----------------------#2022-11-16">https://blog.devgenius.io/elasticsearch-in-action-boosting-scores-using-distance-feature-query-7546b2dea284?source=collection_archive---------8-----------------------#2022-11-16</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div class="gh gi jk"><img src="../Images/95a3991b60dc7d79ed2993deb247df4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*nVXtNoFBzDjIvnz-Use6yg.png"/></div><figcaption class="jr js gj gh gi jt ju bd b be z dk translated">节选自我即将出版的书:弹性搜索在行动</figcaption></figure><p id="f70d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="kt">在接下来的几个月里，我将针对每个主题以迷你系列的形式展示这些短小精悍的文章。节选自我的书</em><a class="ae ku" href="https://www.manning.com/books/elasticsearch-in-action-second-edition?utm_source=mkonda&amp;utm_medium=affiliate&amp;utm_campaign=book_konda_elasticsearch_7_23_21&amp;a_aid=mkonda&amp;a_bid=edbc50d4" rel="noopener ugc nofollow" target="_blank"><em class="kt">elastic search in Action，第二版</em> </a> <em class="kt">。代码在我的</em><a class="ae ku" href="https://github.com/madhusudhankonda" rel="noopener ugc nofollow" target="_blank"><em class="kt">GitHub</em></a><em class="kt">库中。您可以在存储库中找到可执行的 Kibana 脚本，这样您就可以直接在 Kibana 中运行命令。所有代码都经过 Elasticsearch 8.4 版本的测试。</em></p></div><div class="ab cl kv kw hr kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="ig ih ii ij ik"><p id="7778" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Elasticsearch 有一些专门服务于特定功能的高级查询。例如，使用<code class="fe lc ld le lf b">distance_feature</code>查询提高在指定位置提供冰镇饮料的咖啡馆的分数——这是本文的主题。</p><p id="51e0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当搜索经典文献时，我们可能希望添加一个子句来查找 1813 年出版的书籍。除了返回所有的文学经典书籍，我们可以期待找到<em class="kt">傲慢与偏见</em>(简·奥斯汀的经典)，但我们的想法是将<em class="kt">傲慢与偏见</em>放在列表的首位，因为它是在 1813 年印刷的。高居榜首无非是提高基于特定子句的查询结果的相关性分数；在这种情况下，我们特别希望 1813 年出版的书籍被赋予更高的重要性。</p><p id="9541" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">通过使用<code class="fe lc ld le lf b">distance_feature</code>查询，这种特性在 Elasticsearch 中是可用的。该查询获取结果，并且如果它们更接近起始日期(在该示例中为 1813)，则用更高的相关性分数来标记它们中的一些。</p><p id="46a8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe lc ld le lf b">distance_feature</code>查询也为位置提供了类似的支持。如果我们愿意，我们可以突出显示更靠近提升到列表顶部的特定地址的位置。假设我们想要查找所有供应炸鱼和薯条的餐馆，但是那些名列前茅的餐馆应该在伦敦桥附近的自治市附近。(博罗市场是世界知名的十三世纪工匠食品市场；见<a class="ae ku" href="https://boroughmarket.org.uk.)" rel="noopener ugc nofollow" target="_blank">https://boroughmarket . org . uk)</a></p><p id="3583" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对于这样的用例，我们可以使用<code class="fe lc ld le lf b">distance_feature</code>查询，它致力于找到更接近原始位置或日期的结果。日期和位置是分别声明为<code class="fe lc ld le lf b">date</code>(我们也可以声明为<code class="fe lc ld le lf b">date_nanos</code>)和<code class="fe lc ld le lf b">geo_point</code>数据类型的字段。越接近给定日期或给定位置的结果在相关性分数上被评定得越高。让我们看几个例子来详细理解这个概念。</p><h1 id="c093" class="lg lh in bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">使用地理定位提高附近大学的分数</h1><p id="1f75" class="pw-post-body-paragraph jv jw in jx b jy me ka kb kc mf ke kf kg mg ki kj kk mh km kn ko mi kq kr ks ig bi translated">在搜索英国的大学时，我们希望优先选择离一个地方较近的大学；比如骑士桥方圆 10 公里内的所有大学。我们需要提高这些比赛的分数。</p><p id="e6fd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了试验这个场景，让我们为大学索引创建一个映射，并将位置声明为一个<code class="fe lc ld le lf b">geo_point</code>字段。下面的清单创建了四所大学的映射和索引:两所在伦敦，两所在该国其他地方。</p><pre class="mj mk ml mm gt mn lf mo bn mp mq bi"><span id="9666" class="mr lh in lf b be ms mt l mu mv"># Create a mapping of universities index with bare minimum fields<br/>PUT universities<br/>{<br/>  "mappings": {<br/>    "properties": {<br/>      "name":{<br/>        "type": "text"<br/>      },<br/>      "location":{<br/>        "type": "geo_point"<br/>      }<br/>    }<br/>  }<br/>}<br/><br/># And index a few universities<br/>PUT universities/_doc/1<br/>{<br/>  "name":"London School of Economics (LSE)",<br/>  "location":[0.1165, 51.5144]<br/>}<br/>PUT universities/_doc/2<br/>{<br/>  "name":"Imperial College London",<br/>  "location":[0.1749, 51.4988]<br/>}<br/>PUT universities/_doc/3<br/>{<br/>  "name":"University of Oxford",<br/>  "location":[1.2544, 51.7548]<br/>}<br/>PUT universities/_doc/4<br/>{<br/>  "name":"University of Cambridge",<br/>  "location":[0.1132, 52.2054]<br/>}</span></pre><p id="07ed" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">既然索引和数据已经准备好了，让我们获取大学，提高相关性分数，这样那些靠近伦敦桥的大学就会在列表的顶部。参见图 12.12 中的伦敦地图，图中显示了这些大学在上述地点周围的大致距离。为此，我们使用 distance_feature 查询，它匹配查询标准，但基于查询中提供的附加参数提高了相关性分数。</p><figure class="mj mk ml mm gt jo gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/ffa052714c764baf07334359be497461.png" data-original-src="https://miro.medium.com/v2/resize:fit:1026/format:webp/1*-cOb5Xpxs9abvG5nhP-Ehw.png"/></div><figcaption class="jr js gj gh gi jt ju bd b be z dk translated"><strong class="bd li">图 12.12 伦敦地图显示伦敦桥周围的大学</strong></figcaption></figure><p id="49e6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先，让我们编写查询，然后深入了解细节。下面的清单在一个 bool 查询中使用了一个<code class="fe lc ld le lf b">distance_feature</code>查询来获取大学。</p><pre class="mj mk ml mm gt mn lf mo bn mp mq bi"><span id="20a0" class="mr lh in lf b be ms mt l mu mv">GET universities/_search<br/>{<br/>  "query": {<br/>    "distance_feature": {<br/>      "field": "location",<br/>      "origin": [-0.0860, 51.5048],<br/>      "pivot": "10 km"<br/>    }<br/>  }<br/>}</span></pre><p id="05fd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">执行该查询时，将搜索返回我们的两所大学(伦敦经济学院和伦敦帝国理工学院)的所有大学。此外，如果这些大学中的任何一所位于原点周围 10 公里的范围内(-0.0860，51.5048 代表英国的伦敦桥)，它们的得分就会比其他大学高<em class="kt"/>。</p><p id="b357" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们暂停一下，看看<code class="fe lc ld le lf b">distance_feature</code>查询是由什么组成的。<code class="fe lc ld le lf b">distance_feature</code>查询需要这些属性:</p><ul class=""><li id="778c" class="mx my in jx b jy jz kc kd kg mz kk na ko nb ks nc nd ne nf bi translated"><code class="fe lc ld le lf b">field</code> —文档中的<code class="fe lc ld le lf b">geo_point</code>字段</li><li id="9a6d" class="mx my in jx b jy ng kc nh kg ni kk nj ko nk ks nc nd ne nf bi translated"><code class="fe lc ld le lf b">origin</code> —测量距离的焦点(经度和纬度)</li><li id="f190" class="mx my in jx b jy ng kc nh kg ni kk nj ko nk ks nc nd ne nf bi translated"><code class="fe lc ld le lf b">pivot</code> —距焦点的距离</li></ul><p id="0398" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在上面的查询中，伦敦经济学院(LSE)大学比帝国理工学院离伦敦桥更近；因此，伦敦经济学院以更高的分数名列榜首。</p><p id="6d65" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们也可以使用带有日期的<code class="fe lc ld le lf b">distance_feature</code>查询，这是下一节的主题。</p><h1 id="4af7" class="lg lh in bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">使用日期提高分数</h1><p id="99e4" class="pw-post-body-paragraph jv jw in jx b jy me ka kb kc mf ke kf kg mg ki kj kk mh km kn ko mi kq kr ks ig bi translated">在最后一节中，<code class="fe lc ld le lf b">distance_feature</code>查询帮助我们搜索大学，提高了那些更接近某个地理位置的大学的分数。还有一个类似的需求可以通过<code class="fe lc ld le lf b">distance_feature</code>查询来满足:如果结果围绕一个日期旋转，则提高结果的得分。</p><p id="4068" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">假设我们要搜索所有的 iPhone 发布日期，以那些在 2020 年 12 月 1 日前后 30 天内发布的 iPhone 为榜首(没有特别的原因，除了尝试这个概念)。我们可以像上一节一样编写一个类似的查询，只是字段属性将基于日期。让我们首先创建一个 iphone 映射，并将一些 iphone 编入我们的索引。下面清单中的查询可以做到这一点。</p><pre class="mj mk ml mm gt mn lf mo bn mp mq bi"><span id="d82b" class="mr lh in lf b be ms mt l mu mv">PUT iphones<br/>{<br/>  "mappings": {<br/>    "properties": {<br/>      "name":{<br/>        "type": "text"<br/>      },<br/>      "release_date":{<br/>        "type": "date",<br/>        "format": "dd-MM-yyyy"<br/>      }<br/>    }<br/>  }<br/>}<br/><br/># Indexing a few documents<br/>PUT iphones/_doc/1<br/>{ <br/>  "name":"iPhone",<br/>  "release_date":"29-06-2007"<br/>}<br/>PUT iphones/_doc/2<br/>{<br/>  "name":"iPhone 12",<br/>  "release_date":"23-10-2020"<br/>}<br/>PUT iphones/_doc/3<br/>{<br/>  "name":"iPhone 13",<br/>  "release_date":"24-09-2021"<br/>}<br/>PUT iphones/_doc/4<br/>{<br/>  "name":"iPhone 12 Mini",<br/>  "release_date":"13-11-2020"<br/>}</span></pre><p id="69d5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们有了一个索引，其中包含了一批 iphone，让我们开发一个查询来满足我们的要求:我们将获取所有的 iphone，但对 2020 年 12 月 1 日前后 30 天发布的 iphone 进行优先排序。下一个清单中的查询做到了这一点。</p><pre class="mj mk ml mm gt mn lf mo bn mp mq bi"><span id="4fde" class="mr lh in lf b be ms mt l mu mv">GET iphones/_search<br/>{<br/>  "query": {<br/>    "bool": {<br/>      "must": [<br/>        {<br/>          "match": {<br/>            "name": "12"<br/>          }<br/>        }<br/>      ],<br/>      "should": [<br/>        {<br/>          "distance_feature": {<br/>            "field": "release_date", <br/>            "origin": "1-12-2020", <br/>            "pivot": "30 d" <br/>          }<br/>        }<br/>      ]<br/>    }<br/>  }<br/>}</span></pre><p id="cb48" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在上面的查询中，我们用一个<code class="fe lc ld le lf b">must</code>和一个<code class="fe lc ld le lf b">should</code>子句将一个<code class="fe lc ld le lf b">distance_feature</code>包装在一个 bool 查询中(我们在以前的文章中学习过<code class="fe lc ld le lf b">bool</code>查询)。<code class="fe lc ld le lf b">must</code>子句搜索 name 字段中带有 12 的所有文档，并从我们的索引中返回 iPhone 12 和 iPhone 12 mini 文档。我们的要求是优先考虑 12 月 1 日前后 30 天发布的手机(因此，可能是 2020 年 11 月至 12 月发布的所有手机)。</p><p id="ca80" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了满足这个要求，should 子句使用<code class="fe lc ld le lf b">distance_feature</code>查询来提高与所提到的数据转换日期最接近的匹配文档的分数。该查询从 iphones 索引中获取所有文档。任何在 2020 年 12 月 1 日(原产地)之前或之后 30 天发布的 iPhone 都会以更高的相关性分数返回。</p><p id="6bdc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">请记住，<code class="fe lc ld le lf b">should</code>子句返回的所有匹配项都将计入总得分。因此，你应该会看到 iPhone 12 Mini 高居榜首，因为这款 iPhone 的发布日期(" release _ date ":" 13–11–2020 ")更接近于枢轴日期(" origin ":" 01–12–2020 " 30 天)。为了完整起见，下面的代码片段显示了查询结果。</p><pre class="mj mk ml mm gt mn lf mo bn mp mq bi"><span id="df7a" class="mr lh in lf b be ms mt l mu mv">"hits" : [<br/>      {<br/>        "_index" : "iphones",<br/>        "_id" : "4",<br/>        "_score" : 1.1876879,<br/>        "_source" : {<br/>          "name" : "iPhone 12 Mini",<br/>          "release_date" : "13-11-2020"<br/>        }<br/>      },<br/>      {<br/>        "_index" : "iphones",<br/>        "_id" : "2",<br/>        "_score" : 1.1217185,<br/>        "_source" : {<br/>          "name" : "iPhone 12",<br/>          "release_date" : "23-10-2020"<br/>        }<br/>      }<br/>    ]</span></pre><p id="9b27" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">正如你所看到的，iPhone 12 Mini 的得分高于 iPhone 12，因为它是在我们的 pivot 日期前 17 天发布的，而 iPhone 12 的发布时间比这早一点(几乎提前了 5 周)。</p><p id="0cac" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">差不多就是这样。请多跟我学，当然，也请为我鼓掌:)</p></div><div class="ab cl kv kw hr kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="ig ih ii ij ik"><p id="1942" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="kt">这些短文是从我的书</em><a class="ae ku" href="https://www.manning.com/books/elasticsearch-in-action-second-edition?utm_source=mkonda&amp;utm_medium=affiliate&amp;utm_campaign=book_konda_elasticsearch_7_23_21&amp;a_aid=mkonda&amp;a_bid=edbc50d4" rel="noopener ugc nofollow" target="_blank"><em class="kt">elastic search in Action 第二版</em> </a> <em class="kt">中摘录的。代码在我的</em><a class="ae ku" href="https://github.com/madhusudhankonda" rel="noopener ugc nofollow" target="_blank"><em class="kt">GitHub</em></a><em class="kt">库中。</em></p><figure class="mj mk ml mm gt jo gh gi paragraph-image"><div class="gh gi jk"><img src="../Images/95a3991b60dc7d79ed2993deb247df4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*nVXtNoFBzDjIvnz-Use6yg.png"/></div><figcaption class="jr js gj gh gi jt ju bd b be z dk translated">行动中的弹性研究</figcaption></figure></div></div>    
</body>
</html>