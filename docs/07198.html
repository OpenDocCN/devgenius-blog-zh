<html>
<head>
<title>“execvp” system call in Python: Everything you need to know!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 中的“execvp”系统调用:你需要知道的一切！</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/execvp-system-call-in-python-everything-you-need-to-know-c402fe6886eb?source=collection_archive---------3-----------------------#2022-03-05">https://blog.devgenius.io/execvp-system-call-in-python-everything-you-need-to-know-c402fe6886eb?source=collection_archive---------3-----------------------#2022-03-05</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div class="gh gi jk"><img src="../Images/c63bf6fad1af68ed7f68b3309e981faf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1330/format:webp/0*HkBTIFOl_pfD8i9z.jpg"/></div></figure><p id="97d8" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">系统调用的 exec 系列用于在新进程中运行命令或代码文件。在<code class="fe kp kq kr ks b">Linux</code>中，这个新进程是通过替换发出<code class="fe kp kq kr ks b">exec</code>调用的进程而创建的，但是在<code class="fe kp kq kr ks b">Windows</code>中，事情有点不同。在这篇博客中，我们将报道<code class="fe kp kq kr ks b">Python</code>的<code class="fe kp kq kr ks b">execvp</code>系统调用。我们也将利用在这个博客中学到的东西来解决一个有趣的问题！</p><h1 id="b0b1" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">问题陈述和动机</h1><p id="e640" class="pw-post-body-paragraph jr js in jt b ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko ig bi translated">我最近被分配了一个关于<code class="fe kp kq kr ks b">Operating Systems</code>的任务，其中有一个关于<code class="fe kp kq kr ks b">execvp</code>系统调用的有趣问题。现在，互联网上有一些这个问题的实现，但都是用<code class="fe kp kq kr ks b">C</code>写的。在追求一个<code class="fe kp kq kr ks b">pythonic</code>实现的过程中，我踏上了探索之旅，在这里我将把它作为动力！我们将在博客的最后应用<code class="fe kp kq kr ks b">execvp</code>的理论知识来解决这个特殊的问题！问题是-</p><blockquote class="lw lx ly"><p id="6161" class="jr js lz jt b ju jv jw jx jy jz ka kb ma kd ke kf mb kh ki kj mc kl km kn ko ig bi translated">编写程序 p1、p2 和 p3 的集合，使它们以相同的 PID 顺序执行，并且每个程序还应该打印其 PID。用户应该能够调用这些程序的任意组合来实现所需的功能。例如，考虑三个程序 twice、half 和 square，它们只接受一个整数作为参数，并执行一些特定的操作。这些操作可能就像-</p><p id="f3bc" class="jr js lz jt b ju jv jw jx jy jz ka kb ma kd ke kf mb kh ki kj mc kl km kn ko ig bi translated">$twice 10 打印 20 和某个数字，这是它的 PID <br/> $half 10 打印 5 和某个数字，这是它的 PID <br/> $square 10 打印 100 和某个数字，这是它的 PID <br/>现在用户应该能够以任何组合组合组合这些程序，以实现所需的结果。</p><p id="882a" class="jr js lz jt b ju jv jw jx jy jz ka kb ma kd ke kf mb kh ki kj mc kl km kn ko ig bi translated">比如-<br/>$ twice square half twice half 10<br/>要计算<em class="in">half(twice(half(square(twice(10))))))</em>并打印<strong class="jt io"> 200 </strong>作为结果。它还应该在执行时打印每个程序的进程 id。<strong class="jt io">注意，在这种情况下，每个程序打印的进程 id 应该是相同的。</strong></p><p id="2776" class="jr js lz jt b ju jv jw jx jy jz ka kb ma kd ke kf mb kh ki kj mc kl km kn ko ig bi translated">$square twice 2 <br/>要计算两次(square(2))并打印<strong class="jt io"> 8 </strong>作为结果，square 和 twice 的进程 id，应该是一样的。</p><p id="e2ad" class="jr js lz jt b ju jv jw jx jy jz ka kb ma kd ke kf mb kh ki kj mc kl km kn ko ig bi translated">评估顺序是从左到右</p><p id="57c9" class="jr js lz jt b ju jv jw jx jy jz ka kb ma kd ke kf mb kh ki kj mc kl km kn ko ig bi translated">注意最后一个参数是整数，剩下的参数是要调用的程序。</p><p id="f203" class="jr js lz jt b ju jv jw jx jy jz ka kb ma kd ke kf mb kh ki kj mc kl km kn ko ig bi translated">这个应该一般适用于任意 n 个进程，都是你写的。</p></blockquote><h1 id="86c5" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">文档！</h1><p id="026c" class="pw-post-body-paragraph jr js in jt b ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko ig bi translated">让我们从浏览<code class="fe kp kq kr ks b">execvp</code>的文档开始-</p><pre class="md me mf mg gt mh ks mi mj aw mk bi"><span id="5cde" class="ml ku in ks b gy mm mn l mo mp">os.execvp(file, args)</span><span id="6864" class="ml ku in ks b gy mq mn l mo mp">These functions all execute a new program, replacing the current process; they do not return. On Unix, the new executable is loaded into the current process, and will have the same process id as the caller. Errors will be reported as OSError exceptions.</span></pre><p id="0156" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">关键要点-</p><ol class=""><li id="69f0" class="mr ms in jt b ju jv jy jz kc mt kg mu kk mv ko mw mx my mz bi translated">所有的<code class="fe kp kq kr ks b">exec</code>调用都在<code class="fe kp kq kr ks b">os</code>库中实现。</li><li id="df67" class="mr ms in jt b ju na jy nb kc nc kg nd kk ne ko mw mx my mz bi translated"><code class="fe kp kq kr ks b">os.execvp</code>接受两个参数，<code class="fe kp kq kr ks b">file</code>和<code class="fe kp kq kr ks b">args</code>。</li><li id="f386" class="mr ms in jt b ju na jy nb kc nc kg nd kk ne ko mw mx my mz bi translated">新进程不是子进程，而是替代当前进程的新进程。</li><li id="7bf7" class="mr ms in jt b ju na jy nb kc nc kg nd kk ne ko mw mx my mz bi translated">没有返回值。</li><li id="66ed" class="mr ms in jt b ju na jy nb kc nc kg nd kk ne ko mw mx my mz bi translated">在<code class="fe kp kq kr ks b">UNIX</code>系统上，进程 ID ( <code class="fe kp kq kr ks b">PID</code>)与调用者保持一致。</li><li id="8583" class="mr ms in jt b ju na jy nb kc nc kg nd kk ne ko mw mx my mz bi translated">为了节省您的时间，我发现<code class="fe kp kq kr ks b">file</code>应该是一个可执行文件，而<code class="fe kp kq kr ks b">args</code>也应该有可执行文件的名称。我们将在下面更详细地探讨这个问题！</li></ol><h1 id="e92d" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">一个最小的例子</h1><p id="4e49" class="pw-post-body-paragraph jr js in jt b ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko ig bi translated">现在我们知道了一些关于<code class="fe kp kq kr ks b">execvp</code>的东西，让我们试着在我们的代码中使用它。传统是以“你好，世界”节目开始，我们不能违背传统。此外，我们将需要 2 个<code class="fe kp kq kr ks b">Python</code>文件、一个调用者和一个打印“Hello world”的文件</p><h2 id="6a04" class="ml ku in bd kv nf ng dn kz nh ni dp ld kc nj nk lh kg nl nm ll kk nn no lp np bi translated">caller.py</h2><figure class="md me mf mg gt jo"><div class="bz fp l di"><div class="nq nr l"/></div></figure><h2 id="ab2e" class="ml ku in bd kv nf ng dn kz nh ni dp ld kc nj nk lh kg nl nm ll kk nn no lp np bi translated">hello.py</h2><figure class="md me mf mg gt jo"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="f3ac" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">注意<code class="fe kp kq kr ks b">caller.py</code>中的<code class="fe kp kq kr ks b">execvp</code>是如何将可执行文件的名称(<code class="fe kp kq kr ks b">python</code>)作为第一个参数，将完整的命令(包括可执行文件的名称)作为第二个参数。奔跑<code class="fe kp kq kr ks b">caller.py</code>给了我们《Hello world》，一切如预期！</p><h1 id="603c" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">execvp 的内部机制和处理进程 id</h1><p id="fd94" class="pw-post-body-paragraph jr js in jt b ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko ig bi translated">根据文档，<code class="fe kp kq kr ks b">execvp</code>应该用新流程替换调用者流程，而不是在<code class="fe kp kq kr ks b">UNIX</code>系统中创建一个<code class="fe kp kq kr ks b">subprocess</code>。这意味着当进行系统调用时，进程 ID 不应该改变。让我们尝试一下，但是首先，让我们为 3 个不同的函数创建 3 个不同的文件— <code class="fe kp kq kr ks b">square</code>、<code class="fe kp kq kr ks b">half</code>和<code class="fe kp kq kr ks b">double</code></p><figure class="md me mf mg gt jo"><div class="bz fp l di"><div class="nq nr l"/></div></figure><figure class="md me mf mg gt jo"><div class="bz fp l di"><div class="nq nr l"/></div></figure><figure class="md me mf mg gt jo"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="acdf" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">这些文件中唯一的新东西是<code class="fe kp kq kr ks b">os.getpid()</code>，它将返回运行这些文件的进程的进程 ID。让我们也修改我们的<code class="fe kp kq kr ks b">caller</code>来执行其中一个文件——</p><figure class="md me mf mg gt jo"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="8440" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">我们现在也检查调用者中的进程 ID。此外，为了避免在可执行文件的名称上出错，我们现在将使用<code class="fe kp kq kr ks b">sys.executable</code>！在<code class="fe kp kq kr ks b">Windows</code>中执行<code class="fe kp kq kr ks b">caller.py</code>会产生以下输出-</p><pre class="md me mf mg gt mh ks mi mj aw mk bi"><span id="dea0" class="ml ku in ks b gy mm mn l mo mp">CALLER PID: 3156</span><span id="a82e" class="ml ku in ks b gy mq mn l mo mp">DOUBLE PID: 20940 | RESULT: 20</span></pre><p id="189b" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">结果肯定很奇怪，因为进程 id 不一样。让我们在<code class="fe kp kq kr ks b">WSL</code>(Linux 的 Windows 子系统)中尝试相同的代码</p><pre class="md me mf mg gt mh ks mi mj aw mk bi"><span id="6804" class="ml ku in ks b gy mm mn l mo mp">CALLER PID: 34<br/>DOUBLE PID: 34 | RESULT: 20</span></pre><p id="dc50" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">结果与文档相符！由于进程 id 是相同的，调用方进程一定已经通过<code class="fe kp kq kr ks b">execvp</code>系统调用被替换为新的进程。请注意，我们不必将可执行文件的名称从<code class="fe kp kq kr ks b">python</code>改为<code class="fe kp kq kr ks b">python3</code>，因为<code class="fe kp kq kr ks b">sys.executable</code>会自动选择它！</p><p id="c4f2" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">因此，<code class="fe kp kq kr ks b">os.execvp</code>在<code class="fe kp kq kr ks b">Windows</code>和<code class="fe kp kq kr ks b">UNIX</code>系统上表现不同。在<code class="fe kp kq kr ks b">Windows</code>上，它产生或创建一个新进程(子进程或子进程)，而在<code class="fe kp kq kr ks b">UNIX</code>系统上，它用一个新进程替换原来的进程！</p><h1 id="12cb" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">开发 CLI</h1><p id="b37e" class="pw-post-body-paragraph jr js in jt b ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko ig bi translated">现在我们知道了如何在<code class="fe kp kq kr ks b">Python</code>中使用<code class="fe kp kq kr ks b">execvp</code>，让我们继续我们最初的问题！让我们创建一个文件，通过命令行控制一切—</p><figure class="md me mf mg gt jo"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="9ca4" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">该文件在执行时接受一个 CLI 参数列表，这些参数是函数名和一个数字。最后一个 CLI 参数必须是一个必须通过各种操作进行处理的数字。该文件的一个使用示例是—</p><pre class="md me mf mg gt mh ks mi mj aw mk bi"><span id="3d51" class="ml ku in ks b gy mm mn l mo mp">python cli.py -l twice square half twice half 10</span></pre><p id="94a8" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">这应该在内部转化为—</p><pre class="md me mf mg gt mh ks mi mj aw mk bi"><span id="8cc0" class="ml ku in ks b gy mm mn l mo mp">half(twice(half(square(twice(10)))))</span></pre><p id="d29d" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">并且应该打印所有的结果和相关的进程 id。</p><p id="9158" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">记住，<code class="fe kp kq kr ks b">os.execvp</code>不返回任何东西。因此，一旦新的<code class="fe kp kq kr ks b">python</code>文件被调用执行，控制流就不会回到我们的 CLI 文件。为了解决这个问题，我们必须在我们的操作函数中添加额外的代码，这些代码将调用下一个文件而不返回到<code class="fe kp kq kr ks b">cli.py</code>。</p><h1 id="d466" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">修改操作文件</h1><p id="6ddb" class="pw-post-body-paragraph jr js in jt b ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko ig bi translated">每个操作文件中的代码都应该修改，添加—</p><figure class="md me mf mg gt jo"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="e994" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">其中<code class="fe kp kq kr ks b">operation</code>为<code class="fe kp kq kr ks b">double</code>、<code class="fe kp kq kr ks b">half</code>或<code class="fe kp kq kr ks b">square</code>。</p><p id="a53a" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">代码使用<code class="fe kp kq kr ks b">sys.argv[-1]</code>接受最后一个 CLI 参数，并将其传递给相关的操作函数。然后，最后一个参数被替换为获得的结果，除了第一个以外的所有 CLI 参数都被传递到<code class="fe kp kq kr ks b">os.execvp</code>，它调用下一个操作文件！</p><p id="45cd" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">在这两者之间，我们还需要添加一个条件，以便在到达最后一个参数(一个数字)时退出。这最后一个参数将是最终结果，因为在此之前我们已经处理了所有的参数(函数名)!</p><p id="df3b" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">让我们修改每个操作文件—</p><figure class="md me mf mg gt jo"><div class="bz fp l di"><div class="nq nr l"/></div></figure><figure class="md me mf mg gt jo"><div class="bz fp l di"><div class="nq nr l"/></div></figure><figure class="md me mf mg gt jo"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="d7f1" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">这些文件现在会重复地互相调用，整个系统将会工作而不会返回到以前的文件！</p><h1 id="a719" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">决赛成绩</h1><p id="a4e5" class="pw-post-body-paragraph jr js in jt b ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko ig bi translated">运行以下程序—</p><pre class="md me mf mg gt mh ks mi mj aw mk bi"><span id="fb38" class="ml ku in ks b gy mm mn l mo mp">python cli.py -l double square half double half 10</span></pre><p id="aa51" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">在<code class="fe kp kq kr ks b">Windows</code>的结果是—</p><pre class="md me mf mg gt mh ks mi mj aw mk bi"><span id="89cd" class="ml ku in ks b gy mm mn l mo mp">CLI PID: 7376<br/>['double', 'square', 'half', 'double', 'half', '10']</span><span id="29ef" class="ml ku in ks b gy mq mn l mo mp">DOUBLE PID: 32496 | RESULT: 20.0<br/>SQUARE PID: 15144 | RESULT: 400.0<br/>HALF PID: 4860 | RESULT: 200.0<br/>DOUBLE PID: 24928 | RESULT: 400.0<br/>HALF PID: 27868 | RESULT: 200.0</span><span id="ca82" class="ml ku in ks b gy mq mn l mo mp">FINAL PID: 27868 | FINAL RESULT: 200.0</span></pre><p id="b5e0" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">有用！程序给出了我们想要的输出！注意这些<code class="fe kp kq kr ks b">PID</code>是如何不一样的，这在上面已经详细讨论过了。</p><p id="8532" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">运行以下程序—</p><pre class="md me mf mg gt mh ks mi mj aw mk bi"><span id="6dfd" class="ml ku in ks b gy mm mn l mo mp">python3 cli.py -l double square half double half 10</span></pre><p id="8c29" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">在<code class="fe kp kq kr ks b">Windows Subsystem for Linux</code>上的结果是—</p><pre class="md me mf mg gt mh ks mi mj aw mk bi"><span id="b8b0" class="ml ku in ks b gy mm mn l mo mp">CLI PID: 33<br/>['double', 'square', 'half', 'double', 'half', '10']</span><span id="a26c" class="ml ku in ks b gy mq mn l mo mp">DOUBLE PID: 33 | RESULT: 20.0<br/>SQUARE PID: 33 | RESULT: 400.0<br/>HALF PID: 33 | RESULT: 200.0<br/>DOUBLE PID: 33 | RESULT: 400.0<br/>HALF PID: 33 | RESULT: 200.0</span><span id="7ac6" class="ml ku in ks b gy mq mn l mo mp">FINAL PID: 33 | FINAL RESULT: 200.0</span></pre><p id="daa4" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">这个也行！程序再次给出了我们想要的输出！这一次<code class="fe kp kq kr ks b">PID</code>号保持原样，没有<code class="fe kp kq kr ks b">subprocesses</code>号被制造出来！</p><h1 id="372f" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">摘要</h1><p id="651e" class="pw-post-body-paragraph jr js in jt b ju lr jw jx jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko ig bi translated">在上面的博客中，我们了解了如何使用属于 exec 系统调用家族的系统调用。我们进一步看到了 execvp 的行为在 Windows 和 UNIX 系统中的不同。最终我们解决了一个网上没有 Pythonic 解的问题！:)</p></div></div>    
</body>
</html>