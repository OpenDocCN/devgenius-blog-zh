<html>
<head>
<title>Debugging Go Code with Delve</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 Delve 调试 Go 代码</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/debugging-go-code-with-delve-22fe9de7e380?source=collection_archive---------1-----------------------#2022-06-20">https://blog.devgenius.io/debugging-go-code-with-delve-22fe9de7e380?source=collection_archive---------1-----------------------#2022-06-20</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><blockquote class="jk jl jm"><p id="27cb" class="jn jo jp jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ig bi translated">天才是百分之一的天赋加上百分之九十九的努力</p><p id="dffd" class="jn jo jp jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ig bi translated"><em class="in">“e = MC”</em></p><p id="cf19" class="jn jo jp jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ig bi translated"><em class="in"> —阿尔伯特·爱因斯坦</em></p></blockquote><p id="4901" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy km ka kb kc kn ke kf kg ko ki kj kk kl ig bi translated">在软件开发领域，报价可能会稍有变化:</p><blockquote class="jk jl jm"><p id="1f01" class="jn jo jp jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ig bi translated"><em class="in">“软件开发就是 1%编程，99%调试。”</em></p><p id="4f20" class="jn jo jp jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ig bi translated"><em class="in">“错误=更多代码^ 2”</em></p><p id="467c" class="jn jo jp jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ig bi translated"><em class="in"> —某资深开发者，可能是</em></p></blockquote><p id="f979" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy km ka kb kc kn ke kf kg ko ki kj kk kl ig bi translated">调试是所有开发人员都必须经历的事情，它不在乎你的专业知识。这是一个令人沮丧的过程。犯错是人之常情，错误绝对会潜入你的程序。我不知道为什么，但是错误就像你的代码一样是你的后代，所以你有责任处理它们。</p><h1 id="0c67" class="kp kq in bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">我们都喜欢打印调试…</h1><p id="844c" class="pw-post-body-paragraph jn jo in jq b jr ln jt ju jv lo jx jy km lp kb kc kn lq kf kg ko lr kj kk kl ig bi translated">如果你是计算机科学专业的本科生，那么你可能有过一个不愉快的经历，那就是某个项目似乎没有按照你想要的方式运行。这也适用于其他开发人员。我的代码不工作，我不明白为什么。</p><p id="2b02" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy km ka kb kc kn ke kf kg ko ki kj kk kl ig bi translated">我不知道为什么会这样，但是开发人员普遍倾向于打印调试。在代码中您认为有错误的部分，您应该打印输入和输出变量。</p><p id="faf6" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy km ka kb kc kn ke kf kg ko ki kj kk kl ig bi translated">对于修复简单的错误，打印调试通常更快。调试最重要的部分是检查您是否向函数提供了正确的输入，以及函数是否产生了想要的输出。打印语句可以很容易地处理这个问题。然而，有一些讨厌的 bug 往往出现在一个函数中，但却来自一个遥远的函数。还有一些情况下，你可能想检查调用栈，跟踪变量的生命周期，等等。</p><p id="f25e" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy km ka kb kc kn ke kf kg ko ki kj kk kl ig bi translated">相信我，你会遇到这样的情况，你觉得你在浪费大量的时间来打印报表。你的代码看起来会很丑，你会迷失在自己的代码中。那些时候，你希望你知道如何使用调试器。</p><p id="59d3" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy km ka kb kc kn ke kf kg ko ki kj kk kl ig bi translated">如果你不相信，试着这样想。知道如何使用调试器很好。我认为，因为不知道如何使用调试器而使用打印调试是一种糟糕的做法。像任何技能一样，不知道不应该是你不使用/学习它的主要原因。那就像叫外卖，因为你不知道怎么做饭。或者因为不知道如何使用健身器材而不健身。或者因为不理解一个概念而不学习……你懂了。</p><h1 id="ae37" class="kp kq in bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">使用 Delve 调试器</h1><p id="c5b1" class="pw-post-body-paragraph jn jo in jq b jr ln jt ju jv lo jx jy km lp kb kc kn lq kf kg ko lr kj kk kl ig bi translated">有一个流行的调试器叫做<strong class="jq io"> gdb </strong>可以调试 Go 代码。然而，Go 文档并不推荐它，而是向您指出一个更好的选择:<strong class="jq io"> Delve </strong>。</p><p id="034d" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy km ka kb kc kn ke kf kg ko ki kj kk kl ig bi translated">Delve 就像一个工具箱，里面有很多工具可以帮助你消灭那些讨厌的 bug。可以用诱饵站就不用徒手抓蟑螂了。Delve 为你提供杀虫剂、诱饵站、火把等。Delve 是专门用来抓 Go bugs 的，相当好用。</p><p id="729d" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy km ka kb kc kn ke kf kg ko ki kj kk kl ig bi translated">首先，让我们安装它。如果您运行的是 Go v1.16 或更高版本(您可能应该这样做)，您可以使用下面的代码行:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="2678" class="mb kq in lx b gy mc md l me mf">$ go install github.com/go-delve/delve/cmd/dlv@latest</span></pre><p id="e7cf" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy km ka kb kc kn ke kf kg ko ki kj kk kl ig bi translated">确保通过运行以下命令安装了它:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="1d44" class="mb kq in lx b gy mc md l me mf">$ dlv version</span></pre><p id="aa31" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy km ka kb kc kn ke kf kg ko ki kj kk kl ig bi translated">Delve 用于调试主包和测试。不幸的是，除了<code class="fe mg mh mi lx b">main</code>之外，它在调试包方面相当有限，因为 Delve 需要程序的工作可执行文件，这需要一个<code class="fe mg mh mi lx b">main</code>包。像我一样，如果你正在编写一个没有<code class="fe mg mh mi lx b">main</code>包的库，你需要为你的代码编写测试，然后调试它。</p><h1 id="af63" class="kp kq in bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">回顾我最常用的命令，并附有示例代码</h1><p id="fc57" class="pw-post-body-paragraph jn jo in jq b jr ln jt ju jv lo jx jy km lp kb kc kn lq kf kg ko lr kj kk kl ig bi translated">这是我们将在这个例子中使用的代码。</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="73f4" class="mb kq in lx b gy mc md l me mf">package main</span><span id="ce84" class="mb kq in lx b gy mj md l me mf">import (<br/>    "fmt"<br/>    "math"<br/>)</span><span id="9427" class="mb kq in lx b gy mj md l me mf">func main() {<br/>    n1 := []float64{0.1, 0.2, 0.3, 0.4, 0.5}<br/>    n2 := []float64{math.NaN(), 0.2, 0.3, 0.4, 0.5}</span><span id="5279" class="mb kq in lx b gy mj md l me mf">    mean1 := calcMean(n1)<br/>    mean2 := calcMean(n2)</span><span id="20e3" class="mb kq in lx b gy mj md l me mf">    fmt.Println("mean1:", mean1)<br/>    fmt.Println("mean2:", mean2)<br/>}</span><span id="267c" class="mb kq in lx b gy mj md l me mf">func calcMean(nums []float64) float64 {<br/>    mean := 0.0<br/>    for _, num := range nums {<br/>        mean += num<br/>    }<br/>    mean /= float64(len(nums))</span><span id="db56" class="mb kq in lx b gy mj md l me mf">    return mean<br/>}</span></pre><p id="3e6a" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy km ka kb kc kn ke kf kg ko ki kj kk kl ig bi translated">代码真的很简单！<code class="fe mg mh mi lx b">main</code>函数定义了两个切片<code class="fe mg mh mi lx b">n1</code>和<code class="fe mg mh mi lx b">n2</code>，并调用<code class="fe mg mh mi lx b">calcMean</code>计算每个平均值。这段代码看起来很好，编译器也没有抱怨。如果有任何语法错误，我们甚至不能编译我们的代码。然而，这段代码实际上有一个小问题。你能猜出它可能是什么吗？</p><p id="7ac8" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy km ka kb kc kn ke kf kg ko ki kj kk kl ig bi translated">好吧，让我们运行代码，看看会发生什么。</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="55d3" class="mb kq in lx b gy mc md l me mf">$ go run main.go<br/>mean1: 0.3<br/>mean2: NaN</span></pre><p id="a249" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy km ka kb kc kn ke kf kg ko ki kj kk kl ig bi translated">有意思。<code class="fe mg mh mi lx b">mean1</code>看起来还行，但是<code class="fe mg mh mi lx b">mean2</code>看起来有点怪。我们想要一个数字，而不是一个<code class="fe mg mh mi lx b">NaN</code>值。为什么会这样？让我们使用调试器来弄清楚到底发生了什么。</p><p id="c17b" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy km ka kb kc kn ke kf kg ko ki kj kk kl ig bi translated"><code class="fe mg mh mi lx b">cd</code>到包含您的<code class="fe mg mh mi lx b">main.go</code>文件的目录中，然后运行:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="dfea" class="mb kq in lx b gy mc md l me mf">$ dlv debug</span></pre><p id="7831" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy km ka kb kc kn ke kf kg ko ki kj kk kl ig bi translated">如果您正在调试测试，您可以<code class="fe mg mh mi lx b">cd</code>进入保存您的<code class="fe mg mh mi lx b">*_test.go</code>文件的目录，然后运行这个:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="e14d" class="mb kq in lx b gy mc md l me mf">$ dlv test</span></pre><p id="62ec" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy km ka kb kc kn ke kf kg ko ki kj kk kl ig bi translated">据我所知，Delve 没有 GUI 前端，所以你需要使用命令行来使用 Delve。这很好，因为 Delve 有一个友好的 CLI，你实际上可以理解。</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="5010" class="mb kq in lx b gy mc md l me mf">$ dlv debug<br/>Type 'help' for list of commands.<br/>(dlv)</span></pre><p id="27bc" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy km ka kb kc kn ke kf kg ko ki kj kk kl ig bi translated">你会看到我们已经进入了 Delve 界面。现在我们可以运行特定于 Delve 的命令来帮助我们修复这个 bug。</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="aa18" class="mb kq in lx b gy mc md l me mf">(dlv) break main.go:8<br/>Breakpoint 1 set at 0x496732 for main.main() ./main.go:8</span></pre><p id="fce7" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy km ka kb kc kn ke kf kg ko ki kj kk kl ig bi translated">第一个命令是<code class="fe mg mh mi lx b">break</code>。它会在您的代码中创建一个<em class="jp">断点</em>。断点是代码中可以停止执行的点。在这种情况下，我在文件<code class="fe mg mh mi lx b">main.go</code>的第 8 行设置了一个断点。在可疑代码之前设置断点很有用。通常，它是一个接受输入并返回输出的函数。要转到断点，我们可以使用以下命令:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="31ae" class="mb kq in lx b gy mc md l me mf">(dlv) continue<br/>&gt; main.main() ./main.go:8 (hits goroutine(1):1 total:1) (PC: 0x496732)<br/>     3: import (<br/>     4:         "fmt"<br/>     5:         "math"<br/>     6: )<br/>     7:<br/>=&gt;   8: func main() {<br/>     9:         n1 := []float64{0.1, 0.2, 0.3, 0.4, 0.5}<br/>    10:         n2 := []float64{math.NaN(), 0.2, 0.3, 0.4, 0.5}<br/>    11:<br/>    12:         mean1 := calcMean(n1)<br/>    13:         mean2 := calcMean(n2)</span></pre><p id="85ec" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy km ka kb kc kn ke kf kg ko ki kj kk kl ig bi translated"><code class="fe mg mh mi lx b">continue</code>将继续遍历代码，直到到达下一个断点。如果没有设置断点，<code class="fe mg mh mi lx b">continue</code>将只是运行整个程序，结束运行。在这里，continue 将把我们带到第 8 行。注意，断点实际上不会运行指定的行。现在让我们一行一行来。</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="a0dc" class="mb kq in lx b gy mc md l me mf">(dlv) next<br/>&gt; main.main() ./main.go:9 (PC: 0x496749)<br/>     4:         "fmt"<br/>     5:         "math"<br/>     6: )<br/>     7:<br/>     8: func main() {<br/>=&gt;   9:         n1 := []float64{0.1, 0.2, 0.3, 0.4, 0.5}<br/>    10:         n2 := []float64{math.NaN(), 0.2, 0.3, 0.4, 0.5}<br/>    11:<br/>    12:         mean1 := calcMean(n1)<br/>    13:         mean2 := calcMean(n2)<br/>    14:<br/>(dlv) next<br/>&gt; main.main() ./main.go:10 (PC: 0x4967fa)<br/>     5:         "math"<br/>     6: )<br/>     7:<br/>     8: func main() {<br/>     9:         n1 := []float64{0.1, 0.2, 0.3, 0.4, 0.5}<br/>=&gt;  10:         n2 := []float64{math.NaN(), 0.2, 0.3, 0.4, 0.5}<br/>    11:<br/>    12:         mean1 := calcMean(n1)<br/>    13:         mean2 := calcMean(n2)<br/>    14:<br/>    15:         fmt.Println("mean1:", mean1)</span></pre><p id="14b2" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy km ka kb kc kn ke kf kg ko ki kj kk kl ig bi translated">我们使用<code class="fe mg mh mi lx b">next</code>命令转到下一行。这里，我们遍历第 9 行和第 10 行，在那里我们定义了<code class="fe mg mh mi lx b">n1</code>和<code class="fe mg mh mi lx b">n2</code>。让我们看看这些片段在调试器中是如何表示的。</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="818b" class="mb kq in lx b gy mc md l me mf">(dlv) print n1<br/>[]float64 len: 5, cap: 5, [0.1,0.2,0.3,0.4,0.5]<br/>(dlv) print n2<br/>Command failed: could not find symbol value for n2</span></pre><p id="9b13" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy km ka kb kc kn ke kf kg ko ki kj kk kl ig bi translated">我们使用<code class="fe mg mh mi lx b">print</code>命令来查看变量的细节。然而，我们看到了一些奇怪的东西。<code class="fe mg mh mi lx b">print n1</code>有效，但<code class="fe mg mh mi lx b">print n2</code>无效。这是因为当我们在某一行时，该行不会被执行，直到我们移动到下一行。<code class="fe mg mh mi lx b">n1</code>在第 9 行定义，而<code class="fe mg mh mi lx b">n2</code>在第 10 行定义。我们目前在第 10 行，这意味着第 9 行已经执行，但是第 10 行还没有执行。要解决这个问题，我们只需要转到下一行。</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="e0cb" class="mb kq in lx b gy mc md l me mf">(dlv) next<br/>&gt; main.main() ./main.go:12 (PC: 0x4968a5)<br/>     7:<br/>     8: func main() {<br/>     9:         n1 := []float64{0.1, 0.2, 0.3, 0.4, 0.5}<br/>    10:         n2 := []float64{math.NaN(), 0.2, 0.3, 0.4, 0.5}<br/>    11:<br/>=&gt;  12:         mean1 := calcMean(n1)<br/>    13:         mean2 := calcMean(n2)<br/>    14:<br/>    15:         fmt.Println("mean1:", mean1)<br/>    16:         fmt.Println("mean2:", mean2)<br/>    17: }<br/>(dlv) print n1<br/>[]float64 len: 5, cap: 5, [0.1,0.2,0.3,0.4,0.5]<br/>(dlv) print n2<br/>[]float64 len: 5, cap: 5, [NaN,0.2,0.3,0.4,0.5]</span></pre><p id="2a84" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy km ka kb kc kn ke kf kg ko ki kj kk kl ig bi translated">你现在可以看到<code class="fe mg mh mi lx b">print n2</code>是如何按预期工作的了。</p><p id="d55d" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy km ka kb kc kn ke kf kg ko ki kj kk kl ig bi translated">我们现在在第 12 行，这是使用调试器区别于打印调试的地方。Delve 有一个特性，你可以<em class="jp">进入</em>一个函数。顾名思义，单步执行函数允许我们一步一步地进入函数并检查函数。我会告诉你这意味着什么:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="f295" class="mb kq in lx b gy mc md l me mf">(dlv) step<br/>&gt; main.calcMean() ./main.go:19 (PC: 0x496ac0)<br/>    14:<br/>    15:         fmt.Println("mean1:", mean1)<br/>    16:         fmt.Println("mean2:", mean2)<br/>    17: }<br/>    18:<br/>=&gt;  19: func calcMean(nums []float64) float64 {<br/>    20:         mean := 0.0<br/>    21:         for _, num := range nums {<br/>    22:                 mean += num<br/>    23:         }<br/>    24:         mean /= float64(len(nums))</span></pre><p id="56a8" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy km ka kb kc kn ke kf kg ko ki kj kk kl ig bi translated">使用<code class="fe mg mh mi lx b">step</code>进入一个功能。我们可以看到我们的范围是如何从<code class="fe mg mh mi lx b">main</code>函数变成<code class="fe mg mh mi lx b">calcMean</code>函数的。</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="b445" class="mb kq in lx b gy mc md l me mf">(dlv) args<br/>nums = []float64 len: 5, cap: 5, [...]<br/>~r0 = 0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004074232364696</span></pre><p id="6a31" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy km ka kb kc kn ke kf kg ko ki kj kk kl ig bi translated">使用<code class="fe mg mh mi lx b">args</code>将显示功能参数。<code class="fe mg mh mi lx b">nums</code>是<code class="fe mg mh mi lx b">calcMean</code>的输入。<code class="fe mg mh mi lx b">~r0</code>表示函数的返回值。<code class="fe mg mh mi lx b">r</code>代表返回，<code class="fe mg mh mi lx b">0</code>代表第 0 个返回值。如果我们有多个返回值，我们会有类似于<code class="fe mg mh mi lx b">r0, r1, r2...</code>的东西。<code class="fe mg mh mi lx b">~</code>代表一个未命名的值。我们知道<code class="fe mg mh mi lx b">calcMean</code>将返回一个<code class="fe mg mh mi lx b">float64</code>，但是我们没有为它指定一个名称。</p><p id="c657" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy km ka kb kc kn ke kf kg ko ki kj kk kl ig bi translated">我们也可以使用<code class="fe mg mh mi lx b">print</code>命令检查功能输入。</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="9382" class="mb kq in lx b gy mc md l me mf">(dlv) print nums<br/>[]float64 len: 5, cap: 5, [0.1,0.2,0.3,0.4,0.5]</span></pre><p id="b396" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy km ka kb kc kn ke kf kg ko ki kj kk kl ig bi translated">所以我们知道输入没有问题。我们继续吧。我们希望跟踪<code class="fe mg mh mi lx b">mean</code>变量的值。为此，使用<code class="fe mg mh mi lx b">display</code>命令。</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="41ac" class="mb kq in lx b gy mc md l me mf">(dlv) display -a mean<br/>0: mean = error could not find symbol value for mean<br/>(dlv) next<br/>&gt; main.calcMean() ./main.go:20 (PC: 0x496ae5)<br/>    15:         fmt.Println("mean1:", mean1)<br/>    16:         fmt.Println("mean2:", mean2)<br/>    17: }<br/>    18:<br/>    19: func calcMean(nums []float64) float64 {<br/>=&gt;  20:         mean := 0.0<br/>    21:         for _, num := range nums {<br/>    22:                 mean += num<br/>    23:         }<br/>    24:         mean /= float64(len(nums))<br/>    25:<br/>0: mean = error could not find symbol value for mean<br/>(dlv) next<br/>&gt; main.calcMean() ./main.go:21 (PC: 0x496aeb)<br/>    16:         fmt.Println("mean2:", mean2)<br/>    17: }<br/>    18:<br/>    19: func calcMean(nums []float64) float64 {<br/>    20:         mean := 0.0<br/>=&gt;  21:         for _, num := range nums {<br/>    22:                 mean += num<br/>    23:         }<br/>    24:         mean /= float64(len(nums))<br/>    25:<br/>    26:         return mean<br/>0: mean = 0</span></pre><p id="a6a7" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy km ka kb kc kn ke kf kg ko ki kj kk kl ig bi translated">使用<code class="fe mg mh mi lx b">-a</code>标志将变量添加到我们的显示列表中。如果我们移到下一行，您可以看到<code class="fe mg mh mi lx b">mean</code>的值是如何显示在底部的。</p><p id="394d" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy km ka kb kc kn ke kf kg ko ki kj kk kl ig bi translated">有一个小错误，说我们如何<code class="fe mg mh mi lx b">could not find symbol value</code>。这是因为<code class="fe mg mh mi lx b">mean</code>还没有定义。当我们在第 21 行并且已经定义了<code class="fe mg mh mi lx b">mean</code>时，你可以看到这个错误是如何消失的。</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="27c1" class="mb kq in lx b gy mc md l me mf">(dlv) next<br/>&gt; main.calcMean() ./main.go:22 (PC: 0x496b44)<br/>    17: }<br/>    18:<br/>    19: func calcMean(nums []float64) float64 {<br/>    20:         mean := 0.0<br/>    21:         for _, num := range nums {<br/>=&gt;  22:                 mean += num<br/>    23:         }<br/>    24:         mean /= float64(len(nums))<br/>    25:<br/>    26:         return mean<br/>    27: }<br/>0: mean = 0<br/>(dlv) next<br/>&gt; main.calcMean() ./main.go:21 (PC: 0x496b56)<br/>    16:         fmt.Println("mean2:", mean2)<br/>    17: }<br/>    18:<br/>    19: func calcMean(nums []float64) float64 {<br/>    20:         mean := 0.0<br/>=&gt;  21:         for _, num := range nums {<br/>    22:                 mean += num<br/>    23:         }<br/>    24:         mean /= float64(len(nums))<br/>    25:<br/>    26:         return mean<br/>0: mean = 0.1<br/>(dlv) next<br/>&gt; main.calcMean() ./main.go:22 (PC: 0x496b44)<br/>    17: }<br/>    18:<br/>    19: func calcMean(nums []float64) float64 {<br/>    20:         mean := 0.0<br/>    21:         for _, num := range nums {<br/>=&gt;  22:                 mean += num<br/>    23:         }<br/>    24:         mean /= float64(len(nums))<br/>    25:<br/>    26:         return mean<br/>    27: }<br/>0: mean = 0.1<br/>(dlv) next<br/>&gt; main.calcMean() ./main.go:21 (PC: 0x496b56)<br/>    16:         fmt.Println("mean2:", mean2)<br/>    17: }<br/>    18:<br/>    19: func calcMean(nums []float64) float64 {<br/>    20:         mean := 0.0<br/>=&gt;  21:         for _, num := range nums {<br/>    22:                 mean += num<br/>    23:         }<br/>    24:         mean /= float64(len(nums))<br/>    25:<br/>    26:         return mean<br/>0: mean = 0.30000000000000004<br/>(dlv) next<br/>&gt; main.calcMean() ./main.go:22 (PC: 0x496b44)<br/>    17: }<br/>    18:<br/>    19: func calcMean(nums []float64) float64 {<br/>    20:         mean := 0.0<br/>    21:         for _, num := range nums {<br/>=&gt;  22:                 mean += num<br/>    23:         }<br/>    24:         mean /= float64(len(nums))<br/>    25:<br/>    26:         return mean<br/>    27: }<br/>0: mean = 0.30000000000000004<br/>(dlv) next<br/>&gt; main.calcMean() ./main.go:21 (PC: 0x496b56)<br/>    16:         fmt.Println("mean2:", mean2)<br/>    17: }<br/>    18:<br/>    19: func calcMean(nums []float64) float64 {<br/>    20:         mean := 0.0<br/>=&gt;  21:         for _, num := range nums {<br/>    22:                 mean += num<br/>    23:         }<br/>    24:         mean /= float64(len(nums))<br/>    25:<br/>    26:         return mean<br/>0: mean = 0.6000000000000001<br/>(dlv) next<br/>&gt; main.calcMean() ./main.go:22 (PC: 0x496b44)<br/>    17: }<br/>    18:<br/>    19: func calcMean(nums []float64) float64 {<br/>    20:         mean := 0.0<br/>    21:         for _, num := range nums {<br/>=&gt;  22:                 mean += num<br/>    23:         }<br/>    24:         mean /= float64(len(nums))<br/>    25:<br/>    26:         return mean<br/>    27: }<br/>0: mean = 0.6000000000000001<br/>(dlv) next<br/>&gt; main.calcMean() ./main.go:21 (PC: 0x496b56)<br/>    16:         fmt.Println("mean2:", mean2)<br/>    17: }<br/>    18:<br/>    19: func calcMean(nums []float64) float64 {<br/>    20:         mean := 0.0<br/>=&gt;  21:         for _, num := range nums {<br/>    22:                 mean += num<br/>    23:         }<br/>    24:         mean /= float64(len(nums))<br/>    25:<br/>    26:         return mean<br/>0: mean = 1<br/>(dlv) next<br/>&gt; main.calcMean() ./main.go:22 (PC: 0x496b44)<br/>    17: }<br/>    18:<br/>    19: func calcMean(nums []float64) float64 {<br/>    20:         mean := 0.0<br/>    21:         for _, num := range nums {<br/>=&gt;  22:                 mean += num<br/>    23:         }<br/>    24:         mean /= float64(len(nums))<br/>    25:<br/>    26:         return mean<br/>    27: }<br/>0: mean = 1<br/>(dlv) next<br/>&gt; main.calcMean() ./main.go:21 (PC: 0x496b56)<br/>    16:         fmt.Println("mean2:", mean2)<br/>    17: }<br/>    18:<br/>    19: func calcMean(nums []float64) float64 {<br/>    20:         mean := 0.0<br/>=&gt;  21:         for _, num := range nums {<br/>    22:                 mean += num<br/>    23:         }<br/>    24:         mean /= float64(len(nums))<br/>    25:<br/>    26:         return mean<br/>0: mean = 1.5<br/>(dlv) next<br/>&gt; main.calcMean() ./main.go:24 (PC: 0x496b65)<br/>    19: func calcMean(nums []float64) float64 {<br/>    20:         mean := 0.0<br/>    21:         for _, num := range nums {<br/>    22:                 mean += num<br/>    23:         }<br/>=&gt;  24:         mean /= float64(len(nums))<br/>    25:<br/>    26:         return mean<br/>    27: }<br/>0: mean = 1.5</span></pre><p id="c36f" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy km ka kb kc kn ke kf kg ko ki kj kk kl ig bi translated">我为冗长的输出道歉，但是我真的想向您展示<code class="fe mg mh mi lx b">mean</code>在每次迭代中是如何变化的。你可以看到平均值在增加。</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="4d75" class="mb kq in lx b gy mc md l me mf">(dlv) next<br/>&gt; main.calcMean() ./main.go:26 (PC: 0x496b87)<br/>    21:         for _, num := range nums {<br/>    22:                 mean += num<br/>    23:         }<br/>    24:         mean /= float64(len(nums))<br/>    25:<br/>=&gt;  26:         return mean<br/>    27: }<br/>0: mean = 0.3</span></pre><p id="8719" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy km ka kb kc kn ke kf kg ko ki kj kk kl ig bi translated"><code class="fe mg mh mi lx b">mean</code>除以后等于 0.3，因此对于<code class="fe mg mh mi lx b">n1</code>的输入，该函数按预期工作。让我们看看当我们输入<code class="fe mg mh mi lx b">n2</code>时会发生什么。</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="ed0c" class="mb kq in lx b gy mc md l me mf">(dlv) next<br/>&gt; main.main() ./main.go:12 (PC: 0x4968c5)<br/>Values returned:<br/>        ~r0: 0.3</span><span id="c496" class="mb kq in lx b gy mj md l me mf">     7:<br/>     8: func main() {<br/>     9:         n1 := []float64{0.1, 0.2, 0.3, 0.4, 0.5}<br/>    10:         n2 := []float64{math.NaN(), 0.2, 0.3, 0.4, 0.5}<br/>    11:<br/>=&gt;  12:         mean1 := calcMean(n1)<br/>    13:         mean2 := calcMean(n2)<br/>    14:<br/>    15:         fmt.Println("mean1:", mean1)<br/>    16:         fmt.Println("mean2:", mean2)<br/>    17: }<br/>0: mean = error could not find symbol value for mean<br/>(dlv) display -d 0<br/>(dlv)</span></pre><p id="fd67" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy km ka kb kc kn ke kf kg ko ki kj kk kl ig bi translated">当我们到达返回线时，我们就离开了范围。我们需要从显示列表中删除<code class="fe mg mh mi lx b">mean</code>，因为我们不再跟踪它了。运行<code class="fe mg mh mi lx b">display -d</code>并使用列表中变量的 id 跟随它。在我们的例子中，它是 0。</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="1dd9" class="mb kq in lx b gy mc md l me mf">(dlv) next<br/>&gt; main.main() ./main.go:13 (PC: 0x4968cb)<br/>     8: func main() {<br/>     9:         n1 := []float64{0.1, 0.2, 0.3, 0.4, 0.5}<br/>    10:         n2 := []float64{math.NaN(), 0.2, 0.3, 0.4, 0.5}<br/>    11:<br/>    12:         mean1 := calcMean(n1)<br/>=&gt;  13:         mean2 := calcMean(n2)<br/>    14:<br/>    15:         fmt.Println("mean1:", mean1)<br/>    16:         fmt.Println("mean2:", mean2)<br/>    17: }<br/>    18:<br/>(dlv) step<br/>&gt; main.calcMean() ./main.go:19 (PC: 0x496ac0)<br/>    14:<br/>    15:         fmt.Println("mean1:", mean1)<br/>    16:         fmt.Println("mean2:", mean2)<br/>    17: }<br/>    18:<br/>=&gt;  19: func calcMean(nums []float64) float64 {<br/>    20:         mean := 0.0<br/>    21:         for _, num := range nums {<br/>    22:                 mean += num<br/>    23:         }<br/>    24:         mean /= float64(len(nums))<br/>(dlv) print nums<br/>[]float64 len: 5, cap: 5, [NaN,0.2,0.3,0.4,0.5]</span></pre><p id="8322" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy km ka kb kc kn ke kf kg ko ki kj kk kl ig bi translated">我们再次进入<code class="fe mg mh mi lx b">calcMean</code>功能。我们打印<code class="fe mg mh mi lx b">nums</code>并检查输入是否符合预期。</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="8eb5" class="mb kq in lx b gy mc md l me mf">dlv) display -a mean<br/>0: mean = error could not find symbol value for mean<br/>(dlv) next<br/>&gt; main.calcMean() ./main.go:20 (PC: 0x496ae5)<br/>    15:         fmt.Println("mean1:", mean1)<br/>    16:         fmt.Println("mean2:", mean2)<br/>    17: }<br/>    18:<br/>    19: func calcMean(nums []float64) float64 {<br/>=&gt;  20:         mean := 0.0<br/>    21:         for _, num := range nums {<br/>    22:                 mean += num<br/>    23:         }<br/>    24:         mean /= float64(len(nums))<br/>    25:<br/>0: mean = error could not find symbol value for mean<br/>(dlv) next<br/>&gt; main.calcMean() ./main.go:21 (PC: 0x496aeb)<br/>    16:         fmt.Println("mean2:", mean2)<br/>    17: }<br/>    18:<br/>    19: func calcMean(nums []float64) float64 {<br/>    20:         mean := 0.0<br/>=&gt;  21:         for _, num := range nums {<br/>    22:                 mean += num<br/>    23:         }<br/>    24:         mean /= float64(len(nums))<br/>    25:<br/>    26:         return mean<br/>0: mean = 0</span></pre><p id="24cb" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy km ka kb kc kn ke kf kg ko ki kj kk kl ig bi translated">我们使用<code class="fe mg mh mi lx b">display</code>命令来跟踪<code class="fe mg mh mi lx b">mean</code>。</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="a49a" class="mb kq in lx b gy mc md l me mf">(dlv) next<br/>&gt; main.calcMean() ./main.go:22 (PC: 0x496b44)<br/>    17: }<br/>    18:<br/>    19: func calcMean(nums []float64) float64 {<br/>    20:         mean := 0.0<br/>    21:         for _, num := range nums {<br/>=&gt;  22:                 mean += num<br/>    23:         }<br/>    24:         mean /= float64(len(nums))<br/>    25:<br/>    26:         return mean<br/>    27: }<br/>0: mean = 0<br/>(dlv) next<br/>&gt; main.calcMean() ./main.go:21 (PC: 0x496b56)<br/>    16:         fmt.Println("mean2:", mean2)<br/>    17: }<br/>    18:<br/>    19: func calcMean(nums []float64) float64 {<br/>    20:         mean := 0.0<br/>=&gt;  21:         for _, num := range nums {<br/>    22:                 mean += num<br/>    23:         }<br/>    24:         mean /= float64(len(nums))<br/>    25:<br/>    26:         return mean<br/>0: mean = NaN</span><span id="3f75" class="mb kq in lx b gy mj md l me mf">(dlv) next<br/>&gt; main.calcMean() ./main.go:22 (PC: 0x496b44)<br/>    17: }<br/>    18:<br/>    19: func calcMean(nums []float64) float64 {<br/>    20:         mean := 0.0<br/>    21:         for _, num := range nums {<br/>=&gt;  22:                 mean += num<br/>    23:         }<br/>    24:         mean /= float64(len(nums))<br/>    25:<br/>    26:         return mean<br/>    27: }<br/>0: mean = NaN<br/>(dlv) next<br/>&gt; main.calcMean() ./main.go:21 (PC: 0x496b56)<br/>    16:         fmt.Println("mean2:", mean2)<br/>    17: }<br/>    18:<br/>    19: func calcMean(nums []float64) float64 {<br/>    20:         mean := 0.0<br/>=&gt;  21:         for _, num := range nums {<br/>    22:                 mean += num<br/>    23:         }<br/>    24:         mean /= float64(len(nums))<br/>    25:<br/>    26:         return mean<br/>0: mean = NaN</span></pre><p id="4f36" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy km ka kb kc kn ke kf kg ko ki kj kk kl ig bi translated">女士们先生们，这就是窃听器的位置。注意当我们添加第一个元素<code class="fe mg mh mi lx b">nums</code>时<code class="fe mg mh mi lx b">mean</code>是如何变成<code class="fe mg mh mi lx b">NaN</code>的。从那时起，无论我们给它添加什么，<code class="fe mg mh mi lx b">mean</code>都会保持<code class="fe mg mh mi lx b">NaN</code>。显然，这是一种不受欢迎的行为。我们想忽略 NaN 值，在没有它们的情况下计算平均值。</p><p id="640c" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy km ka kb kc kn ke kf kg ko ki kj kk kl ig bi translated">使用<code class="fe mg mh mi lx b">exit</code>退出调试器。</p><p id="9901" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy km ka kb kc kn ke kf kg ko ki kj kk kl ig bi translated">让我们回到我们的代码，将<code class="fe mg mh mi lx b">calcMean</code>代码更新如下:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="6748" class="mb kq in lx b gy mc md l me mf">func calcMean(nums []float64) float64 {<br/>    mean := 0.0<br/>    nanCount := 0<br/>    for _, num := range nums {<br/>        if math.IsNaN(num) {<br/>            nanCount++<br/>            continue<br/>        }<br/>        mean += num<br/>    }<br/>    mean /= float64(len(nums) - nanCount)</span><span id="ed90" class="mb kq in lx b gy mj md l me mf">    return mean<br/>}</span></pre><p id="7664" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy km ka kb kc kn ke kf kg ko ki kj kk kl ig bi translated">如果我们遇到一个 NaN 值，我们将<code class="fe mg mh mi lx b">nanCount</code>加 1，并通过使用<code class="fe mg mh mi lx b">continue</code>跳到下一次迭代。计算平均值时，我们用<code class="fe mg mh mi lx b">nums</code>的和除以<code class="fe mg mh mi lx b">nums</code>的长度减去 NaNs 的个数。</p><p id="6a4b" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy km ka kb kc kn ke kf kg ko ki kj kk kl ig bi translated">现在让我们看看我们的代码是如何运行的。</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="4cdd" class="mb kq in lx b gy mc md l me mf">$ go run main.go<br/>mean1: 0.3<br/>mean2: 0.35</span></pre><p id="056c" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy km ka kb kc kn ke kf kg ko ki kj kk kl ig bi translated">不错！我们成功地调试了代码。</p><h1 id="d6bf" class="kp kq in bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">结论</h1><p id="7822" class="pw-post-body-paragraph jn jo in jq b jr ln jt ju jv lo jx jy km lp kb kc kn lq kf kg ko lr kj kk kl ig bi translated">我们学会了如何像专家一样使用 Delve 调试我们的代码。当然，上面的例子可以通过在<code class="fe mg mh mi lx b">calcMean</code>的循环中添加一个 print 语句来轻松调试。然而，当你在旅途中遇到讨厌的 bug 时，你会感谢自己读了这篇帖子，知道如何使用调试器。Delve 提供了更多的命令，你可以在他们的<a class="ae mk" href="https://github.com/go-delve/delve/tree/master/Documentation/cli" rel="noopener ugc nofollow" target="_blank">文档</a>中查看。上一次，我们学习了如何编写测试来防止错误。当错误出现时，我们现在知道如何使用调试器来消除它们。</p><p id="fb93" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy km ka kb kc kn ke kf kg ko ki kj kk kl ig bi translated">感谢您的阅读！你也可以在<a class="ae mk" href="https://dev.to/jpoly1219/debugging-go-code-with-delve-2l67" rel="noopener ugc nofollow" target="_blank"> Dev.to </a>和<a class="ae mk" href="https://jpoly1219.github.io" rel="noopener ugc nofollow" target="_blank">我的个人网站</a>上阅读这篇文章。</p></div></div>    
</body>
</html>