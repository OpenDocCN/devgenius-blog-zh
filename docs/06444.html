<html>
<head>
<title>Easy JSON in Kotlin with a Type-Safe Builder DSL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kotlin中的简单JSON和类型安全生成器DSL</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/writing-a-dsl-in-kotlin-42a9029b93a6?source=collection_archive---------5-----------------------#2022-01-08">https://blog.devgenius.io/writing-a-dsl-in-kotlin-42a9029b93a6?source=collection_archive---------5-----------------------#2022-01-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><h2 id="1963" class="il im in bd b dl io ip iq ir is it dk iu translated" aria-label="kicker paragraph">履行</h2><div class=""/><div class=""><h2 id="a1d3" class="pw-subtitle-paragraph jt iw in bd b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk dk translated">简化Jackson和Gson语法</h2></div></div><div class="ab cl kl km hr kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="ig ih ii ij ik"><p id="5d9a" class="pw-post-body-paragraph ks kt in ku b kv kw jx kx ky kz ka la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><em class="lo">更新:项目已迁移到新的域，并包含Gson支持</em></p></div><div class="ab cl kl km hr kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="ig ih ii ij ik"><p id="06f5" class="pw-post-body-paragraph ks kt in ku b kv kw jx kx ky kz ka la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">在2019年学习了Kotlin 中的<a class="ae lp" href="https://kotlinlang.org/docs/type-safe-builders.html" rel="noopener ugc nofollow" target="_blank">类型安全构建器之后，我想创建一种特定于领域的语言(DSL)，以避免不得不使用Jackson中相当繁琐的创建模式。写了太多遍之后，我感觉自己像是建筑师鲍勃。</a></p><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="gh gi lu"><img src="../Images/a0917912134af34127abb9a99956044c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pJcTGzqkIZypeT_u"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk translated">马克·波特顿在<a class="ae lp" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h2 id="739c" class="mk ml in bd mm mn mo dn mp mq mr dp ms lb mt mu mv lf mw mx my lj mz na nb it bi translated">领域特定语言(DSL)</h2><p id="f7f5" class="pw-post-body-paragraph ks kt in ku b kv nc jx kx ky nd ka la lb ne ld le lf nf lh li lj ng ll lm ln ig bi translated">如果您以前没有见过类型安全生成器，它是一种以半声明方式构建复杂层次数据结构的方法。Kotlin的HTML 就是一个很好的例子。这给出了类似于以下内容的领域特定语言(DSL ):</p><pre class="lv lw lx ly gt nh lt ni nj aw nk bi"><span id="635b" class="mk ml in lt b gy nl nm l nn no"><strong class="lt ix">fun</strong> result() = html {<br/>  head {<br/>    title {+<strong class="lt ix">"XML encoding with Kotlin"</strong>}<br/>  }<br/>  body {<br/>    h1 {+<strong class="lt ix">"Kotlin DSL"</strong>}<br/>    p  {<br/>      +"Here is "<br/>      a("https://kotlinlang.org") { +"official Kotlin site" }<strong class="lt ix"><br/>    </strong>}<br/>  }<br/>}</span></pre><p id="5a41" class="pw-post-body-paragraph ks kt in ku b kv kw jx kx ky kz ka la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">如果你以前使用过HTML，这可能看起来有点奇怪，但也很熟悉，在Kotlin中，我们有表示为关键字的函数，这些函数几乎是从<code class="fe lq lr ls lt b">&lt;html&gt;...&lt;/html&gt;</code>到<code class="fe lq lr ls lt b">html { ... }</code>的事务。</p><h2 id="3af8" class="mk ml in bd mm mn mo dn mp mq mr dp ms lb mt mu mv lf mw mx my lj mz na nb it bi translated">Maven/Gradle导入</h2><pre class="lv lw lx ly gt nh lt ni nj aw nk bi"><span id="fe21" class="mk ml in lt b gy nl nm l nn no">implementation("com.abroadbent:jackson-dsl:0.2.0")<br/>implementation("com.abroadbent:gson-dsl:0.2.0")</span><span id="d553" class="mk ml in lt b gy np nm l nn no">&lt;dependency&gt;<br/>  &lt;groupId&gt;com.abroadbent&lt;/groupId&gt;<br/>  &lt;artifactId&gt;jackson-dsl&lt;/artifcatId&gt;<br/>  &lt;version&gt;0.2.0<br/>&lt;/dependency&gt;<br/>&lt;dependency&gt;<br/>  &lt;groupId&gt;com.abroadbent&lt;/groupId&gt;<br/>  &lt;artifactId&gt;gson-dsl&lt;/artifcatId&gt;<br/>  &lt;version&gt;0.2.0<br/>&lt;/dependency&gt;</span></pre><h2 id="a5ef" class="mk ml in bd mm mn mo dn mp mq mr dp ms lb mt mu mv lf mw mx my lj mz na nb it bi translated">JSON DSL语法</h2><p id="890e" class="pw-post-body-paragraph ks kt in ku b kv nc jx kx ky nd ka la lb ne ld le lf nf lh li lj ng ll lm ln ig bi translated">使用Kotlin DSL，我们有操作符用于<code class="fe lq lr ls lt b">array</code>和<code class="fe lq lr ls lt b">object</code>以及原语创建(通过<code class="fe lq lr ls lt b">string</code>、<code class="fe lq lr ls lt b">int</code>、<code class="fe lq lr ls lt b">long</code>、<code class="fe lq lr ls lt b">double</code>和<code class="fe lq lr ls lt b">boolean</code>函数)，我们可以使用<code class="fe lq lr ls lt b">put</code>构建对象，使用<code class="fe lq lr ls lt b">add</code>构建数组。</p><p id="189f" class="pw-post-body-paragraph ks kt in ku b kv kw jx kx ky kz ka la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">一旦在<code class="fe lq lr ls lt b">array</code>或<code class="fe lq lr ls lt b">object</code>的上下文中，原语函数将期望在<code class="fe lq lr ls lt b">array</code>中有一个值，在<code class="fe lq lr ls lt b">object</code>中有一个键/值对。这加强了DSL的类型安全方面，因为您将无法创建不转换成Jackson JSON库的东西。</p><p id="ced9" class="pw-post-body-paragraph ks kt in ku b kv kw jx kx ky kz ka la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">这导致一个简单的语法，例如:</p><pre class="lv lw lx ly gt nh lt ni nj aw nk bi"><span id="ed0f" class="mk ml in lt b gy nl nm l nn no">val cat = object {<br/>  put("name", "Princess")<br/>  put("breed", "British Shorthair")<br/>  put("age", 3)<br/>  put("healthy", true)<br/>  array("hobbies") {<br/>    add("sleeping")<br/>    add("eating")<br/>    add("purring")<br/>  }<br/>}</span></pre><h2 id="72bb" class="mk ml in bd mm mn mo dn mp mq mr dp ms lb mt mu mv lf mw mx my lj mz na nb it bi translated">例子</h2><p id="7e2e" class="pw-post-body-paragraph ks kt in ku b kv nc jx kx ky nd ka la lb ne ld le lf nf lh li lj ng ll lm ln ig bi translated">假设我们想要创建(相当荒谬的)JSON对象:</p><pre class="lv lw lx ly gt nh lt ni nj aw nk bi"><span id="188b" class="mk ml in lt b gy nl nm l nn no">{ <br/>  "one": 171,<br/>  "two": [<br/>    false,<br/>    {<br/>      "three": "bar"<br/>    }<br/>  ],<br/>  "four": {<br/>    "five": 1.83<br/>  }<br/>}</span></pre><p id="e58f" class="pw-post-body-paragraph ks kt in ku b kv kw jx kx ky kz ka la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">使用Jackson builder，我们通过以下方式创建它:</p><pre class="lv lw lx ly gt nh lt ni nj aw nk bi"><span id="87bf" class="mk ml in lt b gy nl nm l nn no">val json = mapper.createObjectNode()<br/>  .put("one", 171)<br/>  .set&lt;ObjectNode&gt;(<br/>    "two", mapper.createArrayNode()<br/>      .add(false)<br/>      .add(<br/>        mapper.createObjectNode()<br/>          .put("three", "bar")<br/>      )<br/>    )<br/>  .set&lt;ObjectNode&gt;(<br/>    "four", mapper.createObjectNode()<br/>      .put("five", 1.83)<br/>  )</span></pre><p id="0a24" class="pw-post-body-paragraph ks kt in ku b kv kw jx kx ky kz ka la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">这感觉相当混乱和难以阅读。使用DSL，通过以下方式创建相同的JSON对象:</p><pre class="lv lw lx ly gt nh lt ni nj aw nk bi"><span id="6f85" class="mk ml in lt b gy nl nm l nn no">val json = `object` <strong class="lt ix">{<br/>    </strong>put("one", 171)<br/>    array("two") <strong class="lt ix">{<br/>        </strong>add(false)<br/>        obj <strong class="lt ix">{<br/>            </strong>put("three", "bar")<br/>        <strong class="lt ix">}<br/>    }<br/>    `</strong>object`("four") <strong class="lt ix">{<br/>        </strong>put("five", 1.83)<br/>    <strong class="lt ix">}<br/>}</strong></span></pre><p id="419b" class="pw-post-body-paragraph ks kt in ku b kv kw jx kx ky kz ka la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">这在结构上更接近原始的JSON对象，避免了必须使用<code class="fe lq lr ls lt b">createObjectNode</code>和<code class="fe lq lr ls lt b">createArrayNode</code>的问题，我们也不需要使用Jackson的<code class="fe lq lr ls lt b">set&lt;ObjectNode&gt;</code>的类型安全措施。</p></div><div class="ab cl kl km hr kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="ig ih ii ij ik"><h2 id="7da2" class="mk ml in bd mm mn mo dn mp mq mr dp ms lb mt mu mv lf mw mx my lj mz na nb it bi translated">履行</h2><p id="53b6" class="pw-post-body-paragraph ks kt in ku b kv nc jx kx ky nd ka la lb ne ld le lf nf lh li lj ng ll lm ln ig bi translated">使用<code class="fe lq lr ls lt b">@DslMarker</code>创建一个新的注释来创建构建器，该注释将定义DSL。在我们的例子中，我们创建了一个名为<code class="fe lq lr ls lt b">@JsonMarker</code>的注释。</p><p id="88fb" class="pw-post-body-paragraph ks kt in ku b kv kw jx kx ky kz ka la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">我们创建了一个抽象类<code class="fe lq lr ls lt b">JacksonElement</code>,用<code class="fe lq lr ls lt b">@JsonMarker</code>标注来表示它是DSL语言对象。我们有两个<code class="fe lq lr ls lt b">JacksonElement</code>的实现，分别是<code class="fe lq lr ls lt b">JacksonObject</code>和<code class="fe lq lr ls lt b">JacksonArray</code>，它们分别是Jackson对象和数组的表示。我们在<code class="fe lq lr ls lt b">JacksonObject</code>中定义的任何东西都将在<code class="fe lq lr ls lt b">object { … }</code>范围内被允许，在<code class="fe lq lr ls lt b">JacksonArray</code>中定义的任何东西都将在<code class="fe lq lr ls lt b">array { … }</code>范围内被允许。</p><p id="0f19" class="pw-post-body-paragraph ks kt in ku b kv kw jx kx ky kz ka la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">对于<code class="fe lq lr ls lt b">hashCode</code>、<code class="fe lq lr ls lt b">equals</code>和<code class="fe lq lr ls lt b">toString</code>功能，在<code class="fe lq lr ls lt b">JacksonObject</code>和<code class="fe lq lr ls lt b">JacksonArray</code>之间有一个公共接口。但是<code class="fe lq lr ls lt b">JacksonObject</code>中改变元素的函数提供了一个<code class="fe lq lr ls lt b">key</code>值来存储对象中的值，而<code class="fe lq lr ls lt b">JacksonArray</code>只存储值。因此，<code class="fe lq lr ls lt b">JacksonObject</code>将原始字符串函数定义为<code class="fe lq lr ls lt b">fun put(key: String, value: String)</code>，而<code class="fe lq lr ls lt b">JacksonArray</code>将其定义为<code class="fe lq lr ls lt b">fun add(value: String)</code>。</p><p id="9ae8" class="pw-post-body-paragraph ks kt in ku b kv kw jx kx ky kz ka la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">对于Gson来说，这完全相同，只是使用了名为<code class="fe lq lr ls lt b">GsonElement</code>、<code class="fe lq lr ls lt b">GsonObject</code>和<code class="fe lq lr ls lt b">GsonArray</code>的类。</p><p id="2f88" class="pw-post-body-paragraph ks kt in ku b kv kw jx kx ky kz ka la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">API的设计是有意简化的，使用DSL语言，您可以用最少的努力构建嵌套的对象和数组。由于这个项目是为了对Kotlin中的类型安全构建器进行采样而创建的，所以它只是解决了一个重复使用Jackson的<code class="fe lq lr ls lt b">ObjectMapper</code>类的<code class="fe lq lr ls lt b">createObjectNode</code>和<code class="fe lq lr ls lt b">createArrayNode</code>函数的问题。</p><h2 id="6f8c" class="mk ml in bd mm mn mo dn mp mq mr dp ms lb mt mu mv lf mw mx my lj mz na nb it bi translated">警告</h2><p id="2b2d" class="pw-post-body-paragraph ks kt in ku b kv nc jx kx ky nd ka la lb ne ld le lf nf lh li lj ng ll lm ln ig bi translated">由于<code class="fe lq lr ls lt b">"object"</code>是Kotlin中的保留关键字，为了创建一个对象，需要在单词<code class="fe lq lr ls lt b">`object` { … }</code>两边加上反勾(<code class="fe lq lr ls lt b">`</code>)，或者别名<code class="fe lq lr ls lt b">obj { … }</code>可用。</p></div><div class="ab cl kl km hr kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="ig ih ii ij ik"><h2 id="fbe3" class="mk ml in bd mm mn mo dn mp mq mr dp ms lb mt mu mv lf mw mx my lj mz na nb it bi translated">CI管道</h2><p id="40a8" class="pw-post-body-paragraph ks kt in ku b kv nc jx kx ky nd ka la lb ne ld le lf nf lh li lj ng ll lm ln ig bi translated">该项目使用Github Actions，这在我创建该项目时也是相对较新的。这个配置文件在<code class="fe lq lr ls lt b">.github/workflows/build.yml</code>目录下以便设置构建步骤。</p><pre class="lv lw lx ly gt nh lt ni nj aw nk bi"><span id="ed16" class="mk ml in lt b gy nl nm l nn no">name: Build<br/>on: [ push ]<br/>jobs:<br/>  build:<br/>    runs-on: macos-latest<br/>    steps:<br/>      - name: Checkout<br/>        uses: actions/checkout@v3<br/>      - name: Setup JDK<br/>        uses: actions/setup-java@v3<br/>        with:<br/>          distribution: temurin<br/>          java-version: 11<br/>      - name: Validate Gradle wrapper<br/>        uses: gradle/wrapper-validation-action@v1<br/>      - name: Gradle build<br/>        uses: gradle/gradle-build-action@v2<br/>        with:<br/>          arguments: build<br/>      - name: Publish reports to Codecov<br/>        uses: codecov/codecov-action@v3</span></pre><p id="7d26" class="pw-post-body-paragraph ks kt in ku b kv kw jx kx ky kz ka la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">该构建将在最新版本的MacOS上的Github中的任何push或pull请求上运行。第一步<code class="fe lq lr ls lt b">actions/checkout@v3</code>将源代码下载到机器上，第二步<code class="fe lq lr ls lt b">actions/setup-java@v3</code>将设置Java版本11的Eclipse Temurin版本。</p><p id="4f58" class="pw-post-body-paragraph ks kt in ku b kv kw jx kx ky kz ka la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><code class="fe lq lr ls lt b">gradle/wrapper-validation-action</code>和<code class="fe lq lr ls lt b">gradle/gradle-build-action </code>步骤负责运行构建和测试阶段，然后运行我们的Jacoco覆盖报告。<code class="fe lq lr ls lt b">codecov/codecov-action@v3</code>的最后一步将把覆盖报告推送到code，这意味着您可以在<a class="ae lp" href="https://app.codecov.io/gh/AlexBroadbent/json-dsl" rel="noopener ugc nofollow" target="_blank"> CodeCov </a>上看到完整的报告。</p><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="gh gi nq"><img src="../Images/95e1be1ee69d364ec1bf6ce08814d5fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3ofzjernQELuvCBLlkGcew.png"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk translated">GitHub构建工作流成功运行</figcaption></figure></div><div class="ab cl kl km hr kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="ig ih ii ij ik"><h2 id="a49c" class="mk ml in bd mm mn mo dn mp mq mr dp ms lb mt mu mv lf mw mx my lj mz na nb it bi translated">结论</h2><p id="384f" class="pw-post-body-paragraph ks kt in ku b kv nc jx kx ky nd ka la lb ne ld le lf nf lh li lj ng ll lm ln ig bi translated">希望这篇文章表明，用Kotlin编写DSL减少了使用第三方库时的重复和复杂性。你可以随意地在Github上创建这个库，通过<code class="fe lq lr ls lt b">implementation("com.abroadbent:jackson-dsl:0.2.0")</code>或<code class="fe lq lr ls lt b">implementation("com.abroadbent:gson-dsl:0.2.0")</code>来使用DSL或者在你自己的项目中使用它</p></div><div class="ab cl kl km hr kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="ig ih ii ij ik"><h2 id="086f" class="mk ml in bd mm mn mo dn mp mq mr dp ms lb mt mu mv lf mw mx my lj mz na nb it bi translated"><strong class="ak">源代码</strong></h2><p id="4381" class="pw-post-body-paragraph ks kt in ku b kv nc jx kx ky nd ka la lb ne ld le lf nf lh li lj ng ll lm ln ig bi translated"><a class="ae lp" href="https://github.com/AlexBroadbent/json-dsl/" rel="noopener ugc nofollow" target="_blank">https://github.com/AlexBroadbent/json-dsl</a></p><h2 id="ab0d" class="mk ml in bd mm mn mo dn mp mq mr dp ms lb mt mu mv lf mw mx my lj mz na nb it bi translated"><strong class="ak">代码覆盖率</strong></h2><p id="408b" class="pw-post-body-paragraph ks kt in ku b kv nc jx kx ky nd ka la lb ne ld le lf nf lh li lj ng ll lm ln ig bi translated"><a class="ae lp" href="https://app.codecov.io/gh/AlexBroadbent/jackson-dsl" rel="noopener ugc nofollow" target="_blank">https://app.codecov.io/gh/AlexBroadbent/jackson-dsl</a></p><h2 id="ca23" class="mk ml in bd mm mn mo dn mp mq mr dp ms lb mt mu mv lf mw mx my lj mz na nb it bi translated"><strong class="ak"> Maven中央神器</strong></h2><p id="37dd" class="pw-post-body-paragraph ks kt in ku b kv nc jx kx ky nd ka la lb ne ld le lf nf lh li lj ng ll lm ln ig bi translated"><a class="ae lp" href="https://search.maven.org/artifact/com.abroadbent/jackson-dsl/0.2.0/jar" rel="noopener ugc nofollow" target="_blank">https://search . maven . org/artifact/com . abroad bent/Jackson-DSL/0 . 2 . 0/jar</a></p><p id="081a" class="pw-post-body-paragraph ks kt in ku b kv kw jx kx ky kz ka la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><a class="ae lp" href="https://search.maven.org/artifact/com.abroadbent/gson-dsl/0.2.0/jar" rel="noopener ugc nofollow" target="_blank">https://search . maven . org/artifact/com . abroad bent/gson-DSL/0 . 2 . 0/jar</a></p></div></div>    
</body>
</html>