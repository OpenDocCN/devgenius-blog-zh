<html>
<head>
<title>Clone A Graph</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">克隆一张图</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/clone-a-graph-b2b1e6e7e900?source=collection_archive---------14-----------------------#2020-06-15">https://blog.devgenius.io/clone-a-graph-b2b1e6e7e900?source=collection_archive---------14-----------------------#2020-06-15</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/2c5c9d000bcb3532fe9c6e05ba3c2aad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DR0SOnOF_uSaxajU"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated"><a class="ae jz" href="https://unsplash.com/@m_b_m?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> M. B. M. </a>在<a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><p id="90a1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">嘿…不要以为这只是小孩子的游戏。这当然容易，但并不简单。</p><p id="1f68" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们看看问题陈述:-</p><p id="928a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">问题陈述:- </strong> <em class="ky"> <br/>给出一个</em> <a class="ae jz" href="https://en.wikipedia.org/wiki/Connectivity_(graph_theory)#Connected_graph" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io"> <em class="ky">连通</em> </strong> </a> <em class="ky">的无向图中的一个节点的引用。</em></p><p id="c8c3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ky">返回一个</em> <a class="ae jz" href="https://en.wikipedia.org/wiki/Object_copying#Deep_copy" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io"> <em class="ky">深度复制</em> </strong> </a> <em class="ky">(克隆)的图形。</em></p><p id="a463" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ky">图中的每个节点都包含一个 val ( </em> <code class="fe kz la lb lc b"><em class="ky">int</em></code> <em class="ky">)和一个它的邻居列表(</em> <code class="fe kz la lb lc b"><em class="ky">List[Node]</em></code> <em class="ky">)。</em></p><pre class="ld le lf lg gt lh lc li lj aw lk bi"><span id="b066" class="ll lm in lc b gy ln lo l lp lq">class Node {<br/>public:<br/>    int val;<br/>    vector&lt;Node*&gt; neighbors;<br/>    <br/>    Node() {<br/>        val = 0;<br/>        neighbors = vector&lt;Node*&gt;();<br/>    }<br/>    <br/>    Node(int _val) {<br/>        val = _val;<br/>        neighbors = vector&lt;Node*&gt;();<br/>    }<br/>    <br/>    Node(int _val, vector&lt;Node*&gt; _neighbors) {<br/>        val = _val;<br/>        neighbors = _neighbors;<br/>    }<br/>};</span></pre><p id="1827" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">假设:- <br/> </strong> <em class="ky">为了简单起见，每个节点的值与节点的索引相同(1-indexed)。例如，第一个节点用</em> <code class="fe kz la lb lc b"><em class="ky">val = 1</em></code> <em class="ky">，第二个节点用</em> <code class="fe kz la lb lc b"><em class="ky">val = 2</em></code> <em class="ky">等等。该图在测试用例中使用邻接表来表示。</em></p><p id="9b4d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> <em class="ky">邻接表</em> </strong> <em class="ky">是一组无序的</em> <strong class="kc io"> <em class="ky">列表</em> </strong> <em class="ky">用来表示一个有限图。每个列表描述了图中节点的邻居集。</em></p><p id="95fe" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ky">给定的节点将始终是第一个带有</em> <code class="fe kz la lb lc b"><em class="ky">val = 1</em></code> <em class="ky">的节点。必须返回给定节点</em>  <em class="ky">的</em> <strong class="kc io"> <em class="ky">副本，作为对克隆图形的引用。</em></strong></p><p id="56ab" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">示例 1:</p><figure class="ld le lf lg gt jo gh gi paragraph-image"><div class="gh gi lr"><img src="../Images/7a7c8987638f20077f9cd991cef72bd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1228/format:webp/1*mBjnqIg1pFMeIb9PNpoxMg.jpeg"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">资料来源:www.leetcode.com</figcaption></figure><pre class="ld le lf lg gt lh lc li lj aw lk bi"><span id="cbf1" class="ll lm in lc b gy ln lo l lp lq"><strong class="lc io">Input:</strong> adjList = [[2,4],[1,3],[2,4],[1,3]]<br/><strong class="lc io">Output:</strong> [[2,4],[1,3],[2,4],[1,3]]<br/><strong class="lc io">Explanation:</strong> There are 4 nodes in the graph.<br/>1st node (val = 1)'s neighbours are 2nd node (val = 2) and 4th node (val = 4).<br/>2nd node (val = 2)'s neighbours are 1st node (val = 1) and 3rd node (val = 3).<br/>3rd node (val = 3)'s neighbours are 2nd node (val = 2) and 4th node (val = 4).<br/>4th node (val = 4)'s neighbours are 1st node (val = 1) and 3rd node (val = 3).</span></pre></div><div class="ab cl ls lt hr lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ig ih ii ij ik"><p id="73ac" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在你开始狂热地观看我想与你分享的方法之前，我想敦促你花一些时间来思考解决方案。</p><p id="116e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">下面是 LeetCode 的原问题链接，供你练习:- <a class="ae jz" href="https://leetcode.com/problems/clone-graph/" rel="noopener ugc nofollow" target="_blank">克隆图</a></p></div><div class="ab cl ls lt hr lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ig ih ii ij ik"><p id="8276" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我想和你分享 BFS 和 DFS 解决这个问题的方法。<br/>让我们从 DFS 开始:-</p><h1 id="e2cb" class="lz lm in bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated"><strong class="ak">解决方案 1:深度优先搜索(DFS) </strong></h1><p id="ea5c" class="pw-post-body-paragraph ka kb in kc b kd mw kf kg kh mx kj kk kl my kn ko kp mz kr ks kt na kv kw kx ig bi translated">由于我们只需要制作原始图节点的一个克隆节点，<br/>我们创建原始图的每个节点到克隆图的每个节点的映射，然后在克隆节点之间制作相应的连接。</p><h2 id="514a" class="ll lm in bd ma nb nc dn me nd ne dp mi kl nf ng mm kp nh ni mq kt nj nk mu nl bi translated"><em class="nm">步骤:- </em></h2><ol class=""><li id="762d" class="nn no in kc b kd mw kh mx kl np kp nq kt nr kx ns nt nu nv bi translated"><em class="ky">处理边缘情况:- </em>如果节点为空，则返回空<br/>例如:-如果 adjList 为[]，则输出应为[]，因为图为空。</li><li id="6f77" class="nn no in kc b kd nw kh nx kl ny kp nz kt oa kx ns nt nu nv bi translated">如果节点的克隆版本已经存在，则返回克隆节点。</li><li id="cdad" class="nn no in kc b kd nw kh nx kl ny kp nz kt oa kx ns nt nu nv bi translated">否则，使用与当前节点相同的数据创建一个新的克隆节点，并在映射中链接它们。</li><li id="17f9" class="nn no in kc b kd nw kh nx kl ny kp nz kt oa kx ns nt nu nv bi translated">遍历当前节点的每个邻居，并将邻居的克隆节点连接到当前节点的克隆节点。</li><li id="95c0" class="nn no in kc b kd nw kh nx kl ny kp nz kt oa kx ns nt nu nv bi translated">返回当前节点。</li></ol><pre class="ld le lf lg gt lh lc li lj aw lk bi"><span id="5903" class="ll lm in lc b gy ln lo l lp lq">class Solution {<br/>public:<br/>    //to store mapping of   clone nodes with original graph nodes<br/>    unordered_map&lt;Node*, Node*&gt; cloneLink;<br/>    Node* cloneGraph(Node* node) <br/>    {<br/>        //handle edge case is node is null<br/>        if(node == NULL)<br/>            return NULL;<br/>        <br/>        //clone node already exists then return it<br/>        if( cloneLink[node])<br/>            return cloneLink[node];<br/>        <br/>        //if doesn't exist then create a clone<br/>        //node with same data of the current node<br/>        Node* curr = new Node(node-&gt;val);<br/>        <br/>        //and link that node to the mapping<br/>        cloneLink[node] = curr;<br/>        <br/>        //go through each neighbour of current node and <br/>        //push the clone nodes of the neighbour to the <br/>        //neighbor vector of the current node<br/>        for(int i = 0; i &lt; (node-&gt;neighbors).size(); i++)<br/>            curr-&gt;neighbors.push_back( cloneGraph(<br/>                                       node-&gt;neighbors[i]) );<br/>        <br/>        //return the current node<br/>        return curr;<br/>    }<br/>};</span></pre><h1 id="205c" class="lz lm in bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">解决方案 2:广度优先搜索(BFS)</h1><p id="2719" class="pw-post-body-paragraph ka kb in kc b kd mw kf kg kh mx kj kk kl my kn ko kp mz kr ks kt na kv kw kx ig bi translated">让我用一种新方式来解释这些方法。我将解释这些步骤，并给出实现这些步骤的代码片段。</p><p id="93b8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">主要思想是从给定的节点开始，并像通常那样将它推入队列，以将当前节点的子节点推入队列。我们注意只推送队列中的原始图节点，因为最初只有那些节点包含其子节点的信息。然后对于每个孩子，如果它在队列中，就把它放入队列，如果它没有被放入队列，就克隆它</p><h2 id="444d" class="ll lm in bd ma nb nc dn me nd ne dp mi kl nf ng mm kp nh ni mq kt nj nk mu nl bi translated">步骤:-</h2><ol class=""><li id="24ed" class="nn no in kc b kd mw kh mx kl np kp nq kt nr kx ns nt nu nv bi translated"><em class="ky">边缘案例处理:</em>如果节点为空，则返回空</li></ol><pre class="ld le lf lg gt lh lc li lj aw lk bi"><span id="27e9" class="ll lm in lc b gy ln lo l lp lq">if(node == NULL)<br/>   return NULL;</span></pre><p id="cf56" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">2.我们维护一个访问过的向量来跟踪哪些节点被访问了，哪些没有被访问。</p><pre class="ld le lf lg gt lh lc li lj aw lk bi"><span id="6df4" class="ll lm in lc b gy ln lo l lp lq">vector&lt;int&gt; visited(101, 0);</span></pre><p id="12c1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">3.还要维护一个向量来保存指定节点值的克隆。如果还没有克隆节点值，那么它在那个位置将有 NULL。</p><pre class="ld le lf lg gt lh lc li lj aw lk bi"><span id="1473" class="ll lm in lc b gy ln lo l lp lq">vector&lt;Node*&gt; doesCloneExists(101, NULL);</span></pre><p id="189f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">4.克隆我们在函数调用中得到的根节点，并将其放入队列中进行 BFS。<br/>注意:-仅将原始图节点推入队列，因为最初只有它们包含任何节点的子节点信息。</p><pre class="ld le lf lg gt lh lc li lj aw lk bi"><span id="3c44" class="ll lm in lc b gy ln lo l lp lq">queue&lt;Node*&gt; q;<br/>q.push(node);</span></pre><p id="ceef" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">5.将此节点标记为已访问，并将此克隆节点的引用存储在 doesCloneExists 向量中。</p><pre class="ld le lf lg gt lh lc li lj aw lk bi"><span id="cf24" class="ll lm in lc b gy ln lo l lp lq">visited[node-&gt;val] = 1;<br/>doesCloneExists[node-&gt;val] = root;</span></pre><p id="f043" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">6.执行步骤 7 - 11，直到队列为空</p><p id="25ff" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">7.将队列前面的节点存储为当前正在调查的节点。然后弹出来。</p><pre class="ld le lf lg gt lh lc li lj aw lk bi"><span id="8522" class="ll lm in lc b gy ln lo l lp lq">Node *curr = q.front();<br/>q.pop();</span></pre><p id="728c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">8.对于当前节点的每个邻居，遵循步骤 9 到步骤 11</p><p id="029f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">9.如果这个节点还没有被访问过，那么把它放入队列，并标记为已访问。</p><pre class="ld le lf lg gt lh lc li lj aw lk bi"><span id="57bc" class="ll lm in lc b gy ln lo l lp lq">if(visited[neigh-&gt;val] == 0)<br/>{<br/>    q.push(neigh);<br/>    visited[neigh-&gt;val] = 1;</span></pre><p id="2399" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">10.检查此未访问节点的克隆是否存在。如果 clone 不存在，则制作一个克隆，并将其引用存储在 doesCloneExists 向量的相应索引值下。<br/>结束步骤 9 的 if 块。</p><pre class="ld le lf lg gt lh lc li lj aw lk bi"><span id="35c9" class="ll lm in lc b gy ln lo l lp lq">     if(doesCloneExists[neigh-&gt;val] == NULL)<br/>     {<br/>          Node* childClone = new Node(neigh-&gt;val);<br/>          doesCloneExists[neigh-&gt;val] = childClone;<br/>     }         <br/>}</span></pre><p id="403a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">11.将相邻节点的克隆添加到正在调查的当前节点的邻居列表中。</p><pre class="ld le lf lg gt lh lc li lj aw lk bi"><span id="8691" class="ll lm in lc b gy ln lo l lp lq">doesCloneExists[curr-&gt;val]-&gt;neighbors.<br/>                            push_back(doesCloneExists[neigh-&gt;val]);</span></pre><p id="d7cc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">12.最后返回根克隆节点。</p><p id="4ea0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是我解释的完整 BFS 方法的完整演示。</p><pre class="ld le lf lg gt lh lc li lj aw lk bi"><span id="682d" class="ll lm in lc b gy ln lo l lp lq">Node* cloneGraph(Node* node) <br/>    {<br/>        if(node == NULL)<br/>            return NULL;<br/>        vector&lt;int&gt; visited(101, 0);<br/>        vector&lt;Node*&gt; doesCloneExists(101, NULL);<br/>            <br/>        Node *root = new Node(node-&gt;val);<br/>        <br/>        queue&lt;Node*&gt; q;<br/>        q.push(node);<br/>        visited[node-&gt;val] = 1;<br/>        doesCloneExists[node-&gt;val] = root;<br/>        <br/>        while(!q.empty())<br/>        {<br/>            Node *curr = q.front();<br/>            q.pop();<br/>            <br/>            for(Node *neigh : curr-&gt;neighbors)<br/>            {<br/>           <br/>                if(visited[neigh-&gt;val] == 0)<br/>                {<br/>                    visited[neigh-&gt;val] = 1;<br/>                    q.push(neigh);<br/>                    <br/>                    if(doesCloneExists[neigh-&gt;val] == NULL)<br/>                    {<br/>                        Node* childClone = new Node(neigh-&gt;val);<br/>                        doesCloneExists[neigh-&gt;val] = childClone;<br/>                    }<br/>                    <br/>                }<br/>                doesCloneExists[curr-&gt;val]-&gt;neighbors.                                                  push_back(doesCloneExists[neigh-&gt;val]);<br/>            }<br/>        }<br/>        <br/>        return root;<br/>    }</span></pre></div><div class="ab cl ls lt hr lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ig ih ii ij ik"><p id="f036" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我希望我的解释能够帮助你理解这个问题的概念。然而，我愿意接受各种反馈。你可以通过发邮件到 jainlokesh318@gmail.com 很容易地联系到我。</p></div><div class="ab cl ls lt hr lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ig ih ii ij ik"><h1 id="4f2e" class="lz lm in bd ma mb ob md me mf oc mh mi mj od ml mm mn oe mp mq mr of mt mu mv bi translated">快乐编码……..！！！！！！！！</h1></div></div>    
</body>
</html>