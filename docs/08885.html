<html>
<head>
<title>Creating fast-running Julia executables by dispatching during testing.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过在测试期间调度来创建快速运行的 Julia 可执行文件。</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/creating-fast-running-julia-executables-by-dispatching-during-testing-de56301d2bf1?source=collection_archive---------12-----------------------#2022-07-16">https://blog.devgenius.io/creating-fast-running-julia-executables-by-dispatching-during-testing-de56301d2bf1?source=collection_archive---------12-----------------------#2022-07-16</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="19a8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">作者:@jmmshn</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/ded2867a7188c89b129d49a5bd3c6ab0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*XY9MIgXh9oAXu7x641862g.png"/></div></figure><p id="0ddf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">与 Python 这样的解释语言相比，Julia 的主要优势之一是编译代码的执行速度更快。虽然编译代码的执行速度更快，但 Julia 的实时(JIT)编译行为(这使得这种神奇的事情成为可能)导致了比解释语言更长的“首次绘图时间”。在本教程中，我们将详细介绍设置 Julia 代码的预编译可执行文件的步骤，与直接在 Julia 解释器中运行代码相比，它可以快 20 倍。</p><p id="75de" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">本教程将使用朱莉娅·REPL 和 bash 终端。朱莉娅·REPL 的代码将遵循一个<code class="fe kq kr ks kt b">julia&gt;</code>提示，bash 终端的代码将遵循一个<code class="fe kq kr ks kt b">%</code>提示。</p><p id="01fc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">首先，我们必须用<code class="fe kq kr ks kt b">PkgTemplates</code>建立代码的框架。导航到你想工作的目录，启动一个朱莉娅·REPL。从朱莉娅·REPL，确保安装了<code class="fe kq kr ks kt b">PkgTemplates</code>:</p><pre class="kj kk kl km gt ku kt kv kw aw kx bi"><span id="f232" class="ky kz in kt b gy la lb l lc ld">julia&gt; using Pkg; Pkg.add(<!-- -->"PkgTemplates<!-- -->")</span></pre><p id="40fe" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">安装 PkgTemplates 后，使用以下命令加载它:</p><pre class="kj kk kl km gt ku kt kv kw aw kx bi"><span id="f89f" class="ky kz in kt b gy la lb l lc ld">using <!-- -->PkgTemplates</span></pre><p id="dc9a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一个<code class="fe kq kr ks kt b">Template</code>对象可以使用朱莉娅·REPL 交互式创建，我们想要提供的字段可以通过按<code class="fe kq kr ks kt b">Enter</code>来选择。按<code class="fe kq kr ks kt b">d</code>确认字段开始填写所需信息:</p><pre class="kj kk kl km gt ku kt kv kw aw kx bi"><span id="cd59" class="ky kz in kt b gy la lb l lc ld">julia&gt; tpl = Template(interactive=true)("MyPkg")<br/>Template keywords to customize:<br/>[press: d=done, a=all, n=none]<br/>   [X] user<br/>   [X] authors<br/> &gt; [X] dir<br/>   [ ] host<br/>   [ ] julia<br/>   [ ] plugins<br/>Enter value for 'user' (String, required): myname<br/>Enter value for 'authors' (Vector{String}, comma-delimited, default="myname &lt;myname<a class="ae le" href="mailto:jmmshn@gmail.com" rel="noopener ugc nofollow" target="_blank">@gmail.com</a>&gt; and contributors"):<br/>Enter value for 'dir' (String, default="~/.julia/dev"): ./</span></pre><p id="60b9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这个基本示例中，创建一个名为<code class="fe kq kr ks kt b">MyPkg</code>的新包，并用个人信息修改<code class="fe kq kr ks kt b">user</code>和<code class="fe kq kr ks kt b">authors</code>字段。当提示<code class="fe kq kr ks kt b">dir</code>字段时，用<code class="fe kq kr ks kt b">./</code>回复，将包作为子目录放在当前文件夹中。之后，检查<code class="fe kq kr ks kt b">MyPkg</code>子目录是否填充了以下内容(在 Linux 中使用<code class="fe kq kr ks kt b">tree</code>命令显示):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="4081" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您可以通过确认<code class="fe kq kr ks kt b">./Manifest.toml</code>文件已创建来确认环境已创建。创建子目录后，使用<code class="fe kq kr ks kt b">cd</code>在子目录中导航，并使用<code class="fe kq kr ks kt b">pwd</code>确认您位于 MyPkg 子目录中:</p><pre class="kj kk kl km gt ku kt kv kw aw kx bi"><span id="cd07" class="ky kz in kt b gy la lb l lc ld">julia&gt; cd("MyPkg"); pwd()<br/>"/home/myname/repos/working_dir/MyPkg"</span></pre><p id="1bf9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">从这个目录中，我们可以激活当前目录中的 Julia 环境，并安装本教程剩余部分所需的惟一依赖项(<code class="fe kq kr ks kt b">UnicodePlots</code>)。</p><pre class="kj kk kl km gt ku kt kv kw aw kx bi"><span id="ed7b" class="ky kz in kt b gy la lb l lc ld">julia&gt; Pkg.activate("./"); Pkg.add("UnicodePlots")</span></pre><p id="1431" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在本教程的剩余部分，我们将从这里运行所有的命令，打开 bash 终端并导航到同一个<code class="fe kq kr ks kt b">MyPkg</code>目录也会有所帮助。您可以通过检查<code class="fe kq kr ks kt b">./Manifest.toml</code>来确认软件包已经安装，并确保它已经用新的软件包进行了更新。</p><p id="95c4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在<code class="fe kq kr ks kt b">./src/MyPkg.jl</code>文件中，我们将用下面的简单代码替换模板代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="bba8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">注意这里的<code class="fe kq kr ks kt b">MyPkg.julia_main()</code>是最终可执行文件中调用的函数的默认名称。注意，返回类型必须被指定为<code class="fe kq kr ks kt b">Cint</code>，这样函数才能被正确调度。该函数将读取第一个命令行参数，并在模块内部调用相应的函数。</p><p id="0ee4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有了源代码，我们已经可以看到它作为一个标准的 Julia 脚本的表现了。这可以通过在终端中发出以下命令来实现:</p><pre class="kj kk kl km gt ku kt kv kw aw kx bi"><span id="31cf" class="ky kz in kt b gy la lb l lc ld">% time julia --project="./" -e \<br/>"using MyPkg; MyPkg.julia_main()" hello</span><span id="6575" class="ky kz in kt b gy lh lb l lc ld">Hello, from MyPkg!<br/>julia --project="./" -e "using MyPkg; MyPkg.julia_main()" hello  1.68s user 0.48s system 131% cpu <strong class="kt io">1.579</strong> total</span></pre><p id="c81a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里，我们将短程序<code class="fe kq kr ks kt b">using MyPkg; MyPkg.julia_main()</code>作为 Julia 脚本运行，并将<code class="fe kq kr ks kt b">hello</code>作为唯一的参数，并使用 Linux 程序<code class="fe kq kr ks kt b">time</code>来检查性能。为了获得正确的时间度量，我们应该发出几次命令，因为第一次运行包含定制代码的 Julia 包会产生少量开销。我们可以用<code class="fe kq kr ks kt b">plot</code>作为参数来检查同一个脚本的运行时间:</p><pre class="kj kk kl km gt ku kt kv kw aw kx bi"><span id="7e5f" class="ky kz in kt b gy la lb l lc ld">% time julia --project="./" -e "using MyPkg; MyPkg.julia_main()" plot<br/>      ⡤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⢤<br/>    1 ⡇⠀⠀⠀⠀⠀⠀⡰⠊⠉⠉⠑⢄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸<br/>      ⡇⠀⠀⠀⠀⢀⠎⠀⠀⠀⠀⠀⠈⢢⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸<br/>      ⡇⠀⠀⠀⢠⠊⠀⠀⠀⠀⠀⠀⠀⠀⠑⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸<br/>      ⡇⠀⠀⢀⠏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠹⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸<br/>      ⡇⠀⠀⡞⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢳⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸<br/>      ⡇⠀⡜⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢣⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸<br/>      ⡇⢰⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸<br/>      ⡇⠧⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠼⡤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⢤⠤⠤⠤⠤⢸<br/>      ⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠱⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⠇⠀⠀⠀⠀⢸<br/>      ⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢣⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡎⠀⠀⠀⠀⠀⢸<br/>      ⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡜⠀⠀⠀⠀⠀⠀⢸<br/>      ⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡰⠁⠀⠀⠀⠀⠀⠀⢸<br/>      ⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⡆⠀⠀⠀⠀⠀⠀⠀⠀⡰⠁⠀⠀⠀⠀⠀⠀⠀⢸<br/>      ⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢢⠀⠀⠀⠀⠀⠀⡔⠁⠀⠀⠀⠀⠀⠀⠀⠀⢸<br/>   -1 ⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠑⢄⣀⣀⡠⠎⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸<br/>      ⠓⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠚<br/>      ⠀0⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀7⠀<br/>julia --project="./" -e "using MyPkg; MyPkg.julia_main()" plot  2.60s user 0.52s system 120% cpu <strong class="kt io">2.596</strong> total</span></pre><p id="2ecc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">查看<code class="fe kq kr ks kt b">total</code>运行时间，我们看到将<code class="fe kq kr ks kt b">julia_main</code>中的代码作为脚本运行只需要不到 1.5 秒的时间来运行<code class="fe kq kr ks kt b">hello</code>参数，而使用<code class="fe kq kr ks kt b">plot</code>参数运行的时间几乎是前者的两倍。</p><p id="e68f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用<code class="fe kq kr ks kt b">PackageCompiler</code>我们可以将 Julia 环境的整个状态转换成二进制文件，直到调用<code class="fe kq kr ks kt b">julia_main</code>函数，这将在<code class="fe kq kr ks kt b">app</code>子目录中创建一个可执行文件:</p><pre class="kj kk kl km gt ku kt kv kw aw kx bi"><span id="9a51" class="ky kz in kt b gy la lb l lc ld">julia&gt; using PackageCompiler; PackageCompiler.create_app("./", "app")</span></pre><p id="3bfc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里要注意的是，<code class="fe kq kr ks kt b">incremental=true</code>标志意味着你不必每次都从头开始，这样可以大大加快编译二进制文件的速度。编译完成后，您应该会在<code class="fe kq kr ks kt b">./app/bin/MyPkg</code>看到一个可执行文件</p><pre class="kj kk kl km gt ku kt kv kw aw kx bi"><span id="fe85" class="ky kz in kt b gy la lb l lc ld">time ./app/bin/MyPkg hello<br/>Hello, from MyPkg!<br/>./app/bin/MyPkg hello  0.33s user 0.43s system 319% cpu <strong class="kt io">0.238</strong> total</span></pre><p id="01d3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你好</p><pre class="kj kk kl km gt ku kt kv kw aw kx bi"><span id="1c05" class="ky kz in kt b gy la lb l lc ld">% time ./app/bin/MyPkg plot<br/>      ⡤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⢤<br/>    1 ⡇⠀⠀⠀⠀⠀⠀⡰⠊⠉⠉⠑⢄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸<br/>      ⡇⠀⠀⠀⠀⢀⠎⠀⠀⠀⠀⠀⠈⢢⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸<br/>      ⡇⠀⠀⠀⢠⠊⠀⠀⠀⠀⠀⠀⠀⠀⠑⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸<br/>      ⡇⠀⠀⢀⠏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠹⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸<br/>      ⡇⠀⠀⡞⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢳⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸<br/>      ⡇⠀⡜⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢣⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸<br/>      ⡇⢰⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸<br/>      ⡇⠧⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠼⡤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⢤⠤⠤⠤⠤⢸<br/>      ⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠱⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⠇⠀⠀⠀⠀⢸<br/>      ⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢣⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡎⠀⠀⠀⠀⠀⢸<br/>      ⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡜⠀⠀⠀⠀⠀⠀⢸<br/>      ⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡰⠁⠀⠀⠀⠀⠀⠀⢸<br/>      ⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⡆⠀⠀⠀⠀⠀⠀⠀⠀⡰⠁⠀⠀⠀⠀⠀⠀⠀⢸<br/>      ⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢢⠀⠀⠀⠀⠀⠀⡔⠁⠀⠀⠀⠀⠀⠀⠀⠀⢸<br/>   -1 ⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠑⢄⣀⣀⡠⠎⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸<br/>      ⠓⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠚<br/>      ⠀0⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀7⠀<br/>./app/bin/MyPkg plot  0.93s user 0.41s system 164% cpu <strong class="kt io">0.965</strong> total</span></pre><p id="9173" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们可以看到，对于，我们在<code class="fe kq kr ks kt b">hello</code>获得了很小的性能提升(从<strong class="jm io"> 1.579 </strong> → <strong class="jm io"> 0.238 </strong>秒)，但是对于<code class="fe kq kr ks kt b">parse</code>参数，性能提升非常显著(从<strong class="jm io"> 2.596 </strong> → <strong class="jm io"> 0.965 </strong>秒)。虽然这令人印象深刻，但它似乎没有达到 Julia 承诺的“读起来像 python，运行起来像 C++”的要求。这里的问题是内核在每次可执行文件被调用时都要重新启动，并且在下一次调用可执行文件时不能访问在调用<code class="fe kq kr ks kt b">julia_main</code>时创建的 JIT 编译的对象。所以在某种意义上，即使我们的代码使用<code class="fe kq kr ks kt b">PackageCompiler</code>预编译，方法仍然没有被“分派”,所以当可执行文件被调用时，有一个 Julia 代码表示但是没有可用的机器代码。关于调度工作的更多信息，请阅读<a class="ae le" href="https://docs.julialang.org/en/v1/manual/methods/" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><p id="ebbc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">由于 Julia 只在执行过程中遇到特定的调用签名后才真正编译代码，所以我们只需确保在创建可执行文件之前至少调用一次我们包中的函数。<code class="fe kq kr ks kt b">PackageCompiler</code>通过<code class="fe kq kr ks kt b">precompile_execution_file</code>标志允许这种确切的用法，它运行指定的 Julia 脚本，以便在创建可执行文件之前生成所有的 JIT 代码。虽然这可以是任何一个 Julia 脚本，但是这里一个明显的选择是使用由<code class="fe kq kr ks kt b">PkgTemplates</code>创建的<code class="fe kq kr ks kt b">runtests.jl</code>脚本，它可以作为单元测试和预编译脚本。在我们的示例中，我们可以将以下基本测试放在<code class="fe kq kr ks kt b">runtests.jl</code>文件中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="1c11" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后，我们可以运行测试，以确保一切工作正常:</p><pre class="kj kk kl km gt ku kt kv kw aw kx bi"><span id="d807" class="ky kz in kt b gy la lb l lc ld">julia&gt; Pkg.test()</span></pre><p id="b3d0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在可以创建一个完全预调度版本的应用程序，并将其放在一个名为<code class="fe kq kr ks kt b">app_pc</code>的文件夹中。</p><pre class="kj kk kl km gt ku kt kv kw aw kx bi"><span id="45b8" class="ky kz in kt b gy la lb l lc ld">julia&gt; PackageCompiler.create_app("./", "app_pc", precompile_execution_file="./test/runtests.jl")</span></pre><p id="d7dc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，我们可以对更新后的应用进行计时，以查看性能差异。</p><p id="8551" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对于基本的<code class="fe kq kr ks kt b">hello</code>选项，预调度代码在<strong class="jm io"> 0.097 </strong>秒内完成运行。</p><pre class="kj kk kl km gt ku kt kv kw aw kx bi"><span id="824b" class="ky kz in kt b gy la lb l lc ld">% time ./app_pc/bin/MyPkg hello</span><span id="0f1f" class="ky kz in kt b gy lh lb l lc ld">Hello, from MyPkg!<br/>./app_pc/bin/MyPkg hello  0.09s user 0.06s system 106% cpu <strong class="kt io">0.097</strong> total</span></pre><p id="6253" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对于更复杂的<code class="fe kq kr ks kt b">plot</code>选项，预调度代码在<strong class="jm io"> 0.103 </strong>秒内运行。</p><pre class="kj kk kl km gt ku kt kv kw aw kx bi"><span id="c234" class="ky kz in kt b gy la lb l lc ld">time ./app_pc/bin/MyPkg plot<br/>      ⡤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⢤<br/>    1 ⡇⠀⠀⠀⠀⠀⠀⡰⠊⠉⠉⠑⢄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸<br/>      ⡇⠀⠀⠀⠀⢀⠎⠀⠀⠀⠀⠀⠈⢢⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸<br/>      ⡇⠀⠀⠀⢠⠊⠀⠀⠀⠀⠀⠀⠀⠀⠑⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸<br/>      ⡇⠀⠀⢀⠏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠹⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸<br/>      ⡇⠀⠀⡞⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢳⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸<br/>      ⡇⠀⡜⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢣⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸<br/>      ⡇⢰⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸<br/>      ⡇⠧⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠼⡤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⠤⢤⠤⠤⠤⠤⢸<br/>      ⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠱⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⠇⠀⠀⠀⠀⢸<br/>      ⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢣⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡎⠀⠀⠀⠀⠀⢸<br/>      ⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡜⠀⠀⠀⠀⠀⠀⢸<br/>      ⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡰⠁⠀⠀⠀⠀⠀⠀⢸<br/>      ⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⡆⠀⠀⠀⠀⠀⠀⠀⠀⡰⠁⠀⠀⠀⠀⠀⠀⠀⢸<br/>      ⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢢⠀⠀⠀⠀⠀⠀⡔⠁⠀⠀⠀⠀⠀⠀⠀⠀⢸<br/>   -1 ⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠑⢄⣀⣀⡠⠎⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸<br/>      ⠓⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠒⠚<br/>      ⠀0⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀7⠀<br/>./app_pc/bin/MyPkg plot  0.11s user 0.06s system 121% cpu <strong class="kt io">0.103</strong> total</span></pre><p id="f5da" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这些都是非常简单的函数，与作为脚本运行相比，当这些函数被预先调度时，性能提高了 20 倍以上！！对于调度结构更复杂的更复杂的包，潜在的性能增益甚至会更大。</p></div></div>    
</body>
</html>