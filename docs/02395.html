<html>
<head>
<title>The Hitchhiker’s Guide to the Containers: A Foolproof, Hands-on Docker Tutorial (Part 1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">集装箱搭便车指南:简单实用的码头工人教程(第一部分)</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/the-hitchhikers-guide-to-the-containers-a-foolproof-hands-on-docker-tutorial-part-1-499a6ce0a9a9?source=collection_archive---------9-----------------------#2020-08-01">https://blog.devgenius.io/the-hitchhikers-guide-to-the-containers-a-foolproof-hands-on-docker-tutorial-part-1-499a6ce0a9a9?source=collection_archive---------9-----------------------#2020-08-01</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/10df63734673a5fbdb606aae56ff355f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OYyPflvkUbn3JoY-6AttRQ.jpeg"/></div></div></figure><p id="400b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对于一个初学者来说，理解Docker并不是一件容易的事情。我承认，我在使用和理解容器方面已经挣扎了很长时间，我还有很多工作要做。要牢固地理解Docker背后的概念，为什么它如此具有革命性，以及为什么即使是初学编程的人也可能从学习和使用它中受益，这其中有许多微妙之处。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div class="gh gi kt"><img src="../Images/928304c4d72197b13ed5921f5292a2ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/0*3lL3Y8K_G2sHa5r0.gif"/></div></figure><p id="7c26" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是我一次小小的尝试，来疏导一小时又一小时的头痛、绝望和啊哈！瞬间变成初学者友好，易消化的格式。这是一系列文章中的第一篇，我希望它能在你的Docker之旅中给你一个良好的开端！</p><h1 id="0a62" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">一些历史</h1><p id="bc2d" class="pw-post-body-paragraph jv jw in jx b jy lw ka kb kc lx ke kf kg ly ki kj kk lz km kn ko ma kq kr ks ig bi translated">编写软件的典型方式很简单。一个开发人员在他的本地机器上工作，安装一堆包，设置环境，等等。一旦必要的代码处于良好的状态，我们的开发朋友将代码分享给运营人员，然后…它不起作用了。</p><blockquote class="mb mc md"><p id="6c7a" class="jv jw me jx b jy jz ka kb kc kd ke kf mf kh ki kj mg kl km kn mh kp kq kr ks ig bi translated"><strong class="jx io"><em class="in">Ops:</em></strong>T5】你的代码不行。</p><p id="eb65" class="jv jw me jx b jy jz ka kb kc kd ke kf mf kh ki kj mg kl km kn mh kp kq kr ks ig bi translated"><strong class="jx io"> <em class="in"> Dev: </em> </strong> <em class="in">嘿它在我的机器上工作！</em></p><p id="f7b4" class="jv jw me jx b jy jz ka kb kc kd ke kf mf kh ki kj mg kl km kn mh kp kq kr ks ig bi translated"><strong class="jx io"> <em class="in"> Ops: </em> </strong> <em class="in">你运行的</em> <code class="fe mi mj mk ml b"><em class="in">XXX</em></code> <em class="in">是什么版本？</em></p><p id="b5c8" class="jv jw me jx b jy jz ka kb kc kd ke kf mf kh ki kj mg kl km kn mh kp kq kr ks ig bi translated"><strong class="jx io"> <em class="in">德夫:</em> </strong> <em class="in">我没有主意，伙计……</em></p></blockquote><p id="13d7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">可以想象，我们花了很长时间对开发环境进行故障排除，而不是发布特性和改进。</p><p id="dd76" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">找到的解决方案在<strong class="jx io">虚拟机管理程序</strong>和<strong class="jx io">虚拟机(VM)</strong>中。有了虚拟机，您可以将一个完全配置好的操作系统与您的代码一起打包发货，并启动您认为合适的开发和测试环境。编码变成了启动一个虚拟机，配置你需要的环境，开发软件，测试它，你的工作就完成了！但是所有这些是如何工作的呢？什么是虚拟机？让我们看看运行虚拟机的计算机的架构。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mm"><img src="../Images/58dc5052f1e621e202e3d97cacefa482.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*U96ExP7R1wwZfJMT"/></div></div></figure><p id="949d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">有很多术语你可能不知道，所以我们来看一下。<strong class="jx io">基础设施</strong>是计算机硬件，意味着CPU、RAM、SSD和硬盘、主板以及任何其他东西都是主机物理组件的一部分。<strong class="jx io">主机操作系统</strong>是安装在基础设施上的操作系统。例如，如果你要购买一台MacBook，铝壳和所有组件都是基础架构的一部分，而MacOS是主机操作系统。</p><p id="d736" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">管理程序</strong>是一个处理虚拟机创建的软件。这些虚拟机中的每一个都可以运行它们独立的进程，因为它们相信它们正在使用基础架构中的硬件资源。实际上，虚拟机管理程序从基础架构提供的资源池中分配硬件。简而言之，它创建主机硬件部分的虚拟表示，并让虚拟机在其上运行，管理资源。如图所示，有两种类型的虚拟机管理程序，具体取决于它们在系统体系结构中的位置。</p><h2 id="218c" class="mn kz in bd la mo mp dn le mq mr dp li kg ms mt lm kk mu mv lq ko mw mx lu my bi translated">裸机虚拟机管理程序(类型1):</h2><p id="fa66" class="pw-post-body-paragraph jv jw in jx b jy lw ka kb kc lx ke kf kg ly ki kj kk lz km kn ko ma kq kr ks ig bi translated">虚拟机管理程序软件直接安装在硬件上，并嵌入其组件中。在这种情况下，这些基础架构上没有主机操作系统。这些是生产环境中使用的最常见的虚拟机管理程序类型，因为它们更安全，并且由于如此接近计算机级别而具有更高的性能。</p><h2 id="3af6" class="mn kz in bd la mo mp dn le mq mr dp li kg ms mt lm kk mu mv lq ko mw mx lu my bi translated">托管的虚拟机管理程序(类型2):</h2><p id="6c78" class="pw-post-body-paragraph jv jw in jx b jy lw ka kb kc lx ke kf kg ly ki kj kk lz km kn ko ma kq kr ks ig bi translated">管理程序软件安装在操作系统上。如果您使用过虚拟机，这很可能是您使用过的虚拟机管理程序类型。简单想想Oracle VirtualBox、Parallels Desktop、VMWare Fusion或任何主要的虚拟机提供商。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mz"><img src="../Images/e4c21fb148ff31853f2929c3c7767df7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Dm4lDHvY0sl_uqHK"/></div></div></figure><p id="e334" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里要注意的重要一点是，虽然虚拟机管理程序提供所有资源和虚拟化硬件，但它不提供操作系统。这就是<strong class="jx io">客户操作系统</strong>发挥作用的地方，因为它是运行在虚拟机上的操作系统。这些都是成熟的操作系统，包括系统运行所需的所有附加软件。这给流程带来了大量额外的膨胀，并减少了单个主机可以运行的虚拟机数量。</p><p id="a008" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">考虑安装任何操作系统。例如，全新安装的Windows还附带了所有常见的附加应用程序和支持软件。我怀疑我们的生产级Nginx服务器会大量使用Paint 3D的闪亮副本。</p><h1 id="1ee7" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">输入Docker</h1><p id="c7df" class="pw-post-body-paragraph jv jw in jx b jy lw ka kb kc lx ke kf kg ly ki kj kk lz km kn ko ma kq kr ks ig bi translated">一个集装箱解决了“IDK，伙计”这个永恒的问题。它在我的机器上运行”和虚拟机的性能开销，为您提供了可在任何操作系统上运行的开发环境的可移植、可复制的映像。当一个应用程序被容器化时，它与它所有的依赖项捆绑在一起。这样，如果我想在不同的机器上运行应用程序，我不需要安装除Docker之外的任何东西，因为使我的应用程序运行的所有东西都嵌入了Docker映像。</p><p id="101e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这样做的原因是Docker直接在我们机器的<strong class="jx io">内核</strong>上运行它的容器。内核是非常低级的程序，它完全控制计算机中的软件和硬件，允许两者进行通信。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div class="gh gi na"><img src="../Images/f355ec0d65099df1fd6961ce0dbf77e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1226/0*iUdZft0wRJh_f1IH"/></div></figure><p id="b59b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Docker容器的所有进程都与主操作系统的进程一起运行，尽管在逻辑上是隔离的。这种隔离是通过Linux内核中的实用程序实现的，特别是<strong class="jx io">【LXC】</strong>(Linux容器)、<strong class="jx io"> cgroups </strong>(控制组)和<strong class="jx io">名称空间</strong>。这些工作的细节有点复杂，但是我们将在以后的教程中探索它们。</p><p id="69cd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Docker是基于这些实用程序构建的，扩展了它们，并使它们易于与一个高级API(称为Docker引擎)一起使用。Docker引擎是一个REST API，可以通过HTTP访问，或者更常见的是通过命令行界面访问。它向Docker守护进程发送指令，Docker守护进程是一个持续运行的后台进程，管理Docker容器和机器内核之间的每一次交互。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nb"><img src="../Images/2c91e161afb35cbd1d0db6dc5ae92de8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XrH6zQLmrGWlfzzT"/></div></div></figure><h2 id="8636" class="mn kz in bd la mo mp dn le mq mr dp li kg ms mt lm kk mu mv lq ko mw mx lu my bi translated">将Docker与虚拟机进行比较</h2><p id="a8bc" class="pw-post-body-paragraph jv jw in jx b jy lw ka kb kc lx ke kf kg ly ki kj kk lz km kn ko ma kq kr ks ig bi translated">让我们再次看看VM架构图，并将其与Docker的工作方式进行比较。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nc"><img src="../Images/16e451ea1def55629f882fd8f661c1f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yf8hJrDqqxoScP4H"/></div></div></figure><p id="8c35" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这就是Docker相对于VMs的优势所在。正如我们之前解释的那样，假设容器使用主机的内核来运行它们的进程，那么运行容器就没有开销。容器不需要内核引导，它只使用运行容器化的应用程序所必需的进程，只要我的应用程序停止，它就停止，并且在不使用时不占用硬件资源。</p><h2 id="b5ae" class="mn kz in bd la mo mp dn le mq mr dp li kg ms mt lm kk mu mv lq ko mw mx lu my bi translated">TL；速度三角形定位法(dead reckoning)</h2><p id="7858" class="pw-post-body-paragraph jv jw in jx b jy lw ka kb kc lx ke kf kg ly ki kj kk lz km kn ko ma kq kr ks ig bi translated">Docker是一种在开发环境中打包应用程序的快捷方式，确保它们可以在任何基础设施、配置或操作系统下运行。</p><h2 id="2822" class="mn kz in bd la mo mp dn le mq mr dp li kg ms mt lm kk mu mv lq ko mw mx lu my bi translated">甚至更TL；速度三角形定位法(dead reckoning)</h2><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/9da07599af16d87fa4be078a881c4514.png" data-original-src="https://miro.medium.com/v2/resize:fit:844/0*ug0JDlLQFN3ux9PI"/></div></figure><h1 id="c0a3" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">一些码头工人术语</h1><p id="baba" class="pw-post-body-paragraph jv jw in jx b jy lw ka kb kc lx ke kf kg ly ki kj kk lz km kn ko ma kq kr ks ig bi translated">我们解释了Docker是什么，为什么它很棒，但是你肯定听说过Docker文件、Docker图像、Docker容器，或者其他。让我们弄清楚那些东西是什么意思。</p><h2 id="485e" class="mn kz in bd la mo mp dn le mq mr dp li kg ms mt lm kk mu mv lq ko mw mx lu my bi translated">Docker图像</h2><p id="cc48" class="pw-post-body-paragraph jv jw in jx b jy lw ka kb kc lx ke kf kg ly ki kj kk lz km kn ko ma kq kr ks ig bi translated">Docker图像是用于构建容器的只读文件。它们包括容器化流程运行所需的一切，比如源代码、依赖项、运行时和对象。最重要的是，它为容器提供了一个私有文件系统。映像是轻量级的、可移植的，可用于快速、大规模地部署应用程序。每个图像都是由一个称为Dockerfile的Docker专用脚本构建的。</p><h2 id="5b41" class="mn kz in bd la mo mp dn le mq mr dp li kg ms mt lm kk mu mv lq ko mw mx lu my bi translated">Dockerfile文件</h2><p id="9c11" class="pw-post-body-paragraph jv jw in jx b jy lw ka kb kc lx ke kf kg ly ki kj kk lz km kn ko ma kq kr ks ig bi translated">Dockerfile是一个配方，它为如何构建映像提供了清晰有序的说明。Dockerfile由一系列<code class="fe mi mj mk ml b">[action]</code> <code class="fe mi mj mk ml b">[target]</code>命令组成，每个命令创建一个新层。我们将在本系列的后续部分中讨论层，但是现在，我们可以把它们看作是可以单独缓存(即保存到内存中)以供将来构建的构建块。</p><h2 id="a266" class="mn kz in bd la mo mp dn le mq mr dp li kg ms mt lm kk mu mv lq ko mw mx lu my bi translated">码头集装箱</h2><p id="eb6f" class="pw-post-body-paragraph jv jw in jx b jy lw ka kb kc lx ke kf kg ly ki kj kk lz km kn ko ma kq kr ks ig bi translated">一旦我们从docker文件构建了一个映像，我们最终可以将它部署为一个容器。容器只不过是Docker图像的实例。多个容器可以同时在同一台机器上运行，并且可以从同一个Docker映像实例化多个容器。容器在其进程运行或失败之前一直存在。</p><p id="c792" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">结合极快的启动时间，我们可以看出它们在需要快速扩展的环境中的价值。我们可以启动我们的底层基础设施能够处理的容器，或者手动分配的资源允许的容器，并且我们可以很快地摆脱它们。</p><h2 id="1e8c" class="mn kz in bd la mo mp dn le mq mr dp li kg ms mt lm kk mu mv lq ko mw mx lu my bi translated">Docker注册表</h2><p id="03a3" class="pw-post-body-paragraph jv jw in jx b jy lw ka kb kc lx ke kf kg ly ki kj kk lz km kn ko ma kq kr ks ig bi translated">如果我们想自己控制服务的每一个细节，我们可以写一个docker文件来指定实现的每一步。但是在大多数用例中，我们可能对运行我们日常使用的服务的预构建映像感兴趣。出于这个原因，我们可以浏览<a class="ae ne" href="https://hub.docker.com" rel="noopener ugc nofollow" target="_blank"> Docker Hub </a>，这是一个各种软件的预建映像的在线注册表，从常用的应用程序，如数据库(MySQL、Redis、Postgres等)、web服务器(Nginx、Apache)或CMS (WordPress)到大多数语言的开发环境(Python、Node.js、Java等)。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nf"><img src="../Images/3464bfb1c11704ea795bc05559fda31c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0Qd1SpGZV75-hjdD"/></div></div></figure><p id="617a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您通过DockerHub文件构建的图像可以被推送到各种注册中心，如果我们想让它们公开，可以推送到DockerHub如果我们想让它们保密，可以推送到像<a class="ae ne" href="https://aws.amazon.com/ecr/" rel="noopener ugc nofollow" target="_blank"> AWS弹性容器注册中心</a>、<a class="ae ne" href="https://azure.microsoft.com/en-us/services/container-registry/" rel="noopener ugc nofollow" target="_blank"> Azure容器注册中心</a>或<a class="ae ne" href="https://cloud.google.com/container-registry" rel="noopener ugc nofollow" target="_blank"> GCP容器注册中心</a>这样的注册中心。如果我们希望我们的图像是超级私有的，我们也可以通过运行一个本地实例<a class="ae ne" href="https://hub.docker.com/_/registry" rel="noopener ugc nofollow" target="_blank"> Docker Registry </a>来托管我们的私有注册中心，Docker Hub上有一个Docker图像。</p><p id="d5a7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们现在对Docker的基本构件有了更好的了解。我们还可以识别Docker容器的周期，从创建到实例化。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ng"><img src="../Images/d10fb4dbc761795c0c571b688109d9b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*k7ydz4hkHwJ9QsYp"/></div></div></figure><h1 id="28d6" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">下一步？</h1><p id="8c41" class="pw-post-body-paragraph jv jw in jx b jy lw ka kb kc lx ke kf kg ly ki kj kk lz km kn ko ma kq kr ks ig bi translated">咻！已经有很多信息需要消化了！请确保您理解Docker的基本概念，以及为什么如此多的开发人员喜欢它存在于这个世界上。在本系列的第2部分中，我们将开始接触Docker CLI，从Docker Hub中提取一些图像，并获得在各种用例中正确运行容器的经验。</p><p id="4b31" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，如果你愿意，可以通过推特和我保持联系，让我知道你对这个指南的想法。我希望你喜欢你和Docker的第一步，因为这将是一次远足！</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/acce5e7650c04ac3fa2e28e1da6f8c02.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/0*ZTh6syr029uoOF-B"/></div></figure></div><div class="ab cl ni nj hr nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="ig ih ii ij ik"><p id="6d34" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="me">最初发表于</em><a class="ae ne" href="https://blog.antoniolofiego.com/the-hitchhikers-guide-to-the-containers-a-foolproof-hands-on-docker-tutorial-part-1-ckdc4tni0031759s14z0pdd2j" rel="noopener ugc nofollow" target="_blank">T5【https://blog.antoniolofiego.com】</a><em class="me">。</em></p></div></div>    
</body>
</html>