<html>
<head>
<title>LeetCode 26. Remove Duplicates from Sorted Array (get solution with images)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">LeetCode 26。从已排序的数组中删除重复项(用图像获得解决方案)</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/leetcode-26-remove-duplicates-from-sorted-array-73ce2ca9d603?source=collection_archive---------0-----------------------#2022-07-26">https://blog.devgenius.io/leetcode-26-remove-duplicates-from-sorted-array-73ce2ca9d603?source=collection_archive---------0-----------------------#2022-07-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="b3f7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">链接:→<a class="ae kl" href="https://leetcode.com/problems/remove-duplicates-from-sorted-array/" rel="noopener ugc nofollow" target="_blank">https://leet code . com/problems/remove-duplicates-from-sorted-array/</a></p><h1 id="993a" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated"><strong class="ak">问题:→ </strong></h1><p id="e556" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">给定一个按<strong class="jp ir">非降序</strong>排序的整数数组<code class="fe lp lq lr ls b">nums</code>，就地 移除重复的<a class="ae kl" href="https://en.wikipedia.org/wiki/In-place_algorithm" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">，使得每个唯一元素只出现<strong class="jp ir">一次</strong>。要素的<strong class="jp ir">相对顺序</strong>应与<strong class="jp ir">保持一致</strong>。</strong></a></p><p id="0a27" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为在某些语言中不可能改变数组的长度，所以您必须将结果放入数组<code class="fe lp lq lr ls b">nums</code>的<strong class="jp ir">第一部分</strong>。更正式的说法是，如果删除重复项后还有<code class="fe lp lq lr ls b">k</code>元素，那么<code class="fe lp lq lr ls b">nums</code>的第一个<code class="fe lp lq lr ls b">k</code>元素应该保存最终结果。除了第一个<code class="fe lp lq lr ls b">k</code>元素之外，你留下什么并不重要。</p><p id="1400" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将最终结果放入 <code class="fe lp lq lr ls b">nums</code>的第一个 <code class="fe lp lq lr ls b">k</code> <em class="lt">槽后，返回<code class="fe lp lq lr ls b">k</code> <em class="lt">。</em></em></p><p id="e7a1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不要<strong class="jp ir">而不要</strong>为另一个数组分配额外的空间。你必须用 O(1)个额外内存通过<strong class="jp ir">就地修改输入数组</strong><a class="ae kl" href="https://en.wikipedia.org/wiki/In-place_algorithm" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir"/></a>来做到这一点。</p><p id="f5da" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">自定义判断:</strong></p><p id="3d89" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">法官将使用以下代码测试您的解决方案:</p><pre class="lu lv lw lx gt ly ls lz ma aw mb bi"><span id="a435" class="mc kn iq ls b gy md me l mf mg">int[] nums = [...]; // Input array<br/>int[] expectedNums = [...]; // The expected answer with correct length</span><span id="ae1c" class="mc kn iq ls b gy mh me l mf mg">int k = removeDuplicates(nums); // Calls your implementation</span><span id="419c" class="mc kn iq ls b gy mh me l mf mg">assert k == expectedNums.length;<br/>for (int i = 0; i &lt; k; i++) {<br/>    assert nums[i] == expectedNums[i];<br/>}</span></pre><p id="d5a9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果所有断言都通过，那么您的解决方案将被<strong class="jp ir">接受</strong>。</p><p id="2307" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">例 1: </strong></p><pre class="lu lv lw lx gt ly ls lz ma aw mb bi"><span id="7f0f" class="mc kn iq ls b gy md me l mf mg"><strong class="ls ir">Input:</strong> nums = [1,1,2]<br/><strong class="ls ir">Output:</strong> 2, nums = [1,2,_]<br/><strong class="ls ir">Explanation:</strong> Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively.<br/>It does not matter what you leave beyond the returned k (hence they are underscores).</span></pre><p id="6c24" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">例 2: </strong></p><pre class="lu lv lw lx gt ly ls lz ma aw mb bi"><span id="8c71" class="mc kn iq ls b gy md me l mf mg"><strong class="ls ir">Input:</strong> nums = [0,0,1,1,1,2,2,3,3,4]<br/><strong class="ls ir">Output:</strong> 5, nums = [0,1,2,3,4,_,_,_,_,_]<br/><strong class="ls ir">Explanation:</strong> Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively.<br/>It does not matter what you leave beyond the returned k (hence they are underscores).</span></pre><p id="c75e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">约束:</strong></p><ul class=""><li id="2452" class="mi mj iq jp b jq jr ju jv jy mk kc ml kg mm kk mn mo mp mq bi translated"><code class="fe lp lq lr ls b">1 &lt;= nums.length &lt;= 3 * 104</code></li><li id="e9ff" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated"><code class="fe lp lq lr ls b">-100 &lt;= nums[i] &lt;= 100</code></li><li id="ba86" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated"><code class="fe lp lq lr ls b">nums</code>按<strong class="jp ir">非递减</strong>顺序排序。</li></ul><h1 id="9368" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated"><strong class="ak">解决方案:→ </strong></h1><p id="cdd1" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">这个问题可以通过使用额外的阵列很容易地解决，但是在问题中你可以看到它明确地提到<strong class="jp ir">而不是</strong>为另一个阵列分配额外的空间。</p><ul class=""><li id="38c5" class="mi mj iq jp b jq jr ju jv jy mk kc ml kg mm kk mn mo mp mq bi translated">所以我们只需要在给定的数组中进行运算。</li><li id="f2ba" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated">这里数组将总是按升序排序。</li></ul><p id="5a95" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">假设，我们给了下面一个<strong class="jp ir"> nums </strong>数组。</p><figure class="lu lv lw lx gt mx gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/22442b8389449df6b41566aec32be9b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:860/format:webp/1*xmOUBbQl8_u63t8WhQm_CA.png"/></div></figure><p id="d7d9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里唯一元素的数量是<strong class="jp ir"> 2 </strong>，所以输出将是<strong class="jp ir"> 2 </strong>。</p><figure class="lu lv lw lx gt mx gh gi paragraph-image"><div class="gh gi na"><img src="../Images/103034012ced5b7c621cf0b86894de0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:546/format:webp/1*DCWV7SXli-jX15ZLbr2itA.png"/></div></figure><p id="3961" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以看到，第一个数字将始终被视为唯一的数字，因此，我们需要开始与第二个数字进行比较，第二个数字在这里也是“1”。</p><figure class="lu lv lw lx gt mx gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/55aa67f5c2c4685b404f5892d82c648a.png" data-original-src="https://miro.medium.com/v2/resize:fit:760/format:webp/1*pl49d4u6VGFtuWfGioFgkA.png"/></div></figure><ol class=""><li id="9d91" class="mi mj iq jp b jq jr ju jv jy mk kc ml kg mm kk nc mo mp mq bi translated">现在我们开始遍历给定的数组，因为我们已经将第一个元素计数为<strong class="jp ir"> uniqueCount = 1 </strong>，我们将从第二个元素开始读取数组，因此起始索引位置将为<strong class="jp ir"> 1 </strong>，如下所示</li></ol><figure class="lu lv lw lx gt mx gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi nd"><img src="../Images/2f8fe3d0ba73308f3d0951e280eeb5c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eQfL8ZHClz4ALOLevn2zTA.png"/></div></div></figure><p id="e85c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在 i = 1，所以我们将第一个<strong class="jp ir">索引</strong>num[1]的值= 1 与其前一个索引<strong class="jp ir">零</strong>索引<strong class="jp ir"> num[0]的值= 1 进行比较。</strong></p><figure class="lu lv lw lx gt mx gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi ni"><img src="../Images/7b973f1b2b46fde1b08b15c36215871a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d543k0jMkzGaUmEEAPwYUg.png"/></div></div></figure><p id="2165" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为两个值相同，所以我们的 if 条件将失败，现在我们继续前进。<strong class="jp ir"> i = 2 </strong></p><figure class="lu lv lw lx gt mx gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi nj"><img src="../Images/7cf5dea1eb250f192739b0e04fedeb8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3a977ZCapEtb-KXM4u1Gyw.png"/></div></div></figure><p id="45f7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在 i = 2，所以我们比较第二个索引<strong class="jp ir">第二个索引<strong class="jp ir"> num[2]的值= 2 </strong>和它的前一个索引<strong class="jp ir">第一个索引</strong>第二个索引<strong class="jp ir"> num[1]的值= 1。</strong></strong></p><figure class="lu lv lw lx gt mx gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi nk"><img src="../Images/1c1328a8f26b5da67f9e7133fe21f884.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LTo1UCjqz0YhzeVcgq-LBw.png"/></div></div></figure><p id="e0f1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里，if 条件将为<strong class="jp ir">真。</strong>现在我们正在向 if 条件内部移动。</p><p id="3a56" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">nums[1] = nums[2] → num[1]值将被 num[2]覆盖。</p><figure class="lu lv lw lx gt mx gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi nl"><img src="../Images/2abe0aeb050e80e8c4ea627e5486a3b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*673-OCHPRyh919pkawOu3w.png"/></div></div></figure><p id="806d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们已经找到了另一个 uniqueCount，所以我们将值更新+1。</p><figure class="lu lv lw lx gt mx gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi nm"><img src="../Images/7d710119a6c4fd755747bd397aa04a5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RJr3_wsgXqLenIkAfTZvqQ.png"/></div></div></figure><p id="5dc8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们的下一次迭代，<strong class="jp ir"> i </strong>将是 3，但是给定数组的长度也是 3，所以我们的 for 循环条件将变为 false，</p><figure class="lu lv lw lx gt mx gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi nn"><img src="../Images/dbd73e5bfc6615b773ed64d709f79868.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B22AwrBS5vceinkkxvVx9Q.png"/></div></div></figure><p id="e482" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以返回结果为 2，这是真的，你可以看到，在我们给定的数组中只有两个，唯一的元素和数组，我们可以得到更新。</p><figure class="lu lv lw lx gt mx gh gi paragraph-image"><div class="gh gi no"><img src="../Images/1da7e22ef50c78e5f582d4342d7a249e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1096/format:webp/1*aZzwJeQjvq5ahWBvzAlpow.png"/></div></figure><h2 id="3cce" class="mc kn iq bd ko np nq dn ks nr ns dp kw jy nt nu la kc nv nw le kg nx ny li nz bi translated"><strong class="ak">代码(Java): </strong></h2><figure class="lu lv lw lx gt mx"><div class="bz fp l di"><div class="oa ob l"/></div></figure><h2 id="35b0" class="mc kn iq bd ko np nq dn ks nr ns dp kw jy nt nu la kc nv nw le kg nx ny li nz bi translated"><strong class="ak">代码(Python): </strong></h2><figure class="lu lv lw lx gt mx"><div class="bz fp l di"><div class="oa ob l"/></div></figure><h1 id="8703" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">时间复杂度</h1><p id="cdcf" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">我们只扫描一次数组，因此时间复杂度是 O(n)  。</p><h1 id="e3fa" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">空间复杂性</h1><p id="b076" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">由于我们没有使用任何额外的数组，所以空间复杂度将是 O(1)<strong class="jp ir"><em class="lt">。</em></strong></p><p id="dd29" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">感谢你阅读这篇文章，❤</p><p id="038e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我做错了什么？让我在评论中。我很想进步。</p><p id="fc5d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">拍手声👏如果这篇文章对你有帮助。</p></div></div>    
</body>
</html>