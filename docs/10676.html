<html>
<head>
<title>Map Struct and It’s Basics</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">映射结构及其基础</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/map-struct-and-its-basics-4bde55ebc16c?source=collection_archive---------3-----------------------#2022-11-21">https://blog.devgenius.io/map-struct-and-its-basics-4bde55ebc16c?source=collection_archive---------3-----------------------#2022-11-21</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="aa04" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">各种领域的软件开发人员肯定都以这样或那样的方式处理过数据映射。从使用 DTO 映射值到使用高级技术映射列表或复杂的 JSON，每个人都使用过数据映射技术。传统上，每个人都从创建结果和请求的 POJO 开始，并使用 getters 或 setters 来映射值。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/bf2ba0270ce88c0e1838425b86ffb987.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LMmdBPdqqt4D5dAx"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@tracycodes?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">特雷西·亚当斯</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="fb50" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">随着时间的推移，这种非常方便的对象创建方法变得不那么方便了，因为它需要大量的行、高代码复杂性和许多测试用例来覆盖映射器行。为了更好地理解这一点，想象一个由 100 个不同的键值对组成的复杂 JSON。这意味着至少要做 100 次 obj1.set(json.get())并且在编写测试用例时不要忘记 100x 的行数。</p><p id="060b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了降低复杂性，开发人员想出了地图绘制器和许多地图构建器来帮助自动绘制地图。MapStruct 就是这样一种技术。根据定义，“MapStruct 是一个<strong class="jm io">开源的基于 Java 的代码生成器</strong>，它为映射实现创建代码。它<strong class="jm io">在编译期间使用注释处理来生成映射器类</strong>实现，并大大减少了通常由手工编写的样板代码的数量”。非正式地解释，这是 OG spring-boot 提供的另一个@ somehing。</p><p id="49c5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">使用 MapStruct </strong></p><p id="8407" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">根据定义，MapStruct 使用注释，并为我们提供了对象映射的模板。帮助我们使用 MapStuct 的依赖关系是:-</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi kz"><img src="../Images/b986945241624450b572f31d407851f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aghk16m91M9tzm7RuS2Wdg.png"/></div></div></figure><p id="443c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">上面的版本应该很容易通过<a class="ae ky" href="https://mvnrepository.com/artifact/org.mapstruct/mapstruct" rel="noopener ugc nofollow" target="_blank"> Maven 资源库</a>找到。为了解释工作原理，让我们考虑 2 个对象，即 obj1 和 obj2。Obj1 是一个 POJO，包含两个字段 name 和 age。Obj2 也是一个 POJO，它有 3 个字段名称、代码和年龄。我们这里不需要消气剂。</p><p id="b528" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">由于 MapStruct 在编译时工作，我们还需要在构建中添加插件，允许 spring 在进行 mvn 全新安装或 mvn spring-boot:run 时生成源代码。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi la"><img src="../Images/05befa9659512bb68049d5632d0a1027.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EF2H8paLjNDAM-p1MkmxAg.png"/></div></div></figure><p id="c666" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">从开发开始，首先我们需要一个用<strong class="jm io"> @Mapper 注释的接口。</strong>例如</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lb"><img src="../Images/9ed4b8cd8ed96df31f69fe6d250de2e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/1*y_zkdKnpxcApvfRaiq8u6g.png"/></div></figure><p id="6546" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">另一个例子是:-</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi kz"><img src="../Images/1056b4211579c59ecf2470c683ec9005.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LUb5IEXrc4Lgrb5B8G2Muw.png"/></div></div></figure><p id="d80d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Mapper()中的值是这样的配置:-</p><p id="37c1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">1.<em class="lc"> ComponentModel </em>告诉 MapStruct，在生成映射器实现类时，我们希望通过 Spring 使用依赖注入支持来创建它。</p><p id="653b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">2.nullValuePropertyMappingStrategy 告诉 spring 忽略是否映射了任何空值。</p><p id="a25c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">3.nullValueCheckStrategy 告诉 spring 在任何值映射之前总是检查 null。它所做的只是添加 if(obj1.getKey()！=空)</p><p id="de0d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">其次，我们需要为对象编写等价的映射来告诉 spring，什么与谁映射。这可以通过以下方式实现</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi kz"><img src="../Images/0d8dfe4e63cfe482ae33d2f445021602.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hLTrc4c29BR3Qwfvdg1e8g.png"/></div></div></figure><p id="6c71" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">1.<strong class="jm io"> @Mapping </strong>是完成我们所有工作的核心注释。Target 是引用 Obj2 中字段的值，source 是引用 Obj1 的值。</p><p id="3205" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">2.第 2 行是第 1 行的替代，它展示了一个场景，其中我们需要硬编码一个值或将常量赋给结果集。</p><p id="8366" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">3.第 3 行是一个经典的例子，其中我们有一些逻辑，但映射不能直接完成。它可以像使用 if-else 一样简单，也可以是复杂的开关情况。Java()告诉 spring 对象的映射必须使用函数 mapAge()，其中包含 paramerer obj1。</p><p id="fba4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">要写一个函数，我们只需要做。注意:-这必须在我们编写@Mapping(target，source)的同一个接口中编写。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ld"><img src="../Images/8e41daf07bd07424bde5c6f10e534d6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J8icJnOEcZFrlW7sBr6S2Q.png"/></div></div></figure><p id="b7cd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在要使用创建的映射器，我们只需要自动连接映射结构映射器并在我们想要的函数中使用 mapper.toObj2(obj1 ),我们就可以开始了。</p><p id="85ff" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">MapStruct 用@Mapping()和@Mapper()提供了很多选项。我们可以在@Mapping 中使用 checks @NotNull、@Nullable，或者使用我们自己的定制验证器。最后，您不需要实际运行代码来查看映射器如何工作。我们可以进行 mvn 全新安装，在<strong class="jm io">目标文件夹&gt; src &gt; our_class </strong>中我们应该有等价的映射。试着检查一下这个文件，你会惊讶地发现从 Spring 开始我们的手动工作已经减少了多少。</p><p id="3ace" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我希望这有助于开始使用 MapStruct。更详细的用法可以从 spring 官方社区的文档中获得。感谢阅读。别忘了点个赞然后关注:)</p></div></div>    
</body>
</html>