<html>
<head>
<title>Longest Increasing Sub-sequence O(nlogn)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">最长递增子序列O(nlogn)</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/longest-increasing-subsequence-o-nlogn-8239e5de4b5c?source=collection_archive---------7-----------------------#2020-06-15">https://blog.devgenius.io/longest-increasing-subsequence-o-nlogn-8239e5de4b5c?source=collection_archive---------7-----------------------#2020-06-15</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/8331a74fe6e98391c65b9b11d31446fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5C7QvKdhDUvulf9c"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated"><a class="ae jz" href="https://unsplash.com/@sctgrhm?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">斯科特·格雷厄姆</a>在<a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><p id="e40d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最长递增子序列(LIS)问题是寻找给定序列的最长子序列的长度，使得该子序列的所有元素按递增顺序排序。</p><p id="b2ff" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">例如，{10，12，9，13，21，50，41，65，85}的LIS长度为7，LIS为{10，12，13，21，50，65，85}。</p><p id="fb95" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个问题可以使用递归或动态规划以O(n)复杂度来解决。<br/>但是有另一种方法可以以O(nlogn)的复杂度和O(n)的空间复杂度来解决这个问题(对于最坏的情况，当序列以升序排列时)。</p><blockquote class="ky kz la"><p id="7fa0" class="ka kb lb kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated">让我们深入研究这种方法:<br/>代码非常简短，易于理解。</p></blockquote><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="6bad" class="lo lp in lk b gy lq lr l ls lt">import bisect<br/>def lis(arr):<br/>  if len(arr) == 0:<br/>    return 0</span><span id="fc88" class="lo lp in lk b gy lu lr l ls lt">  l = [arr[0]]<br/>  <br/>  for element in arr[1:]:<br/>    pos = bisect.bisect(l, element)<br/>    if pos == len(l):      <br/>      if element &gt; l[pos - 1]:<br/>        l.append(element)<br/>    else:<br/>      if element != l[pos - 1]:<br/>        l[pos] = element<br/>  return len(l)</span><span id="f9d5" class="lo lp in lk b gy lu lr l ls lt">if __name__ == "__main__":<br/>  print(lis([10, 12, 9, 13, 21, 50, 41, 65, 85]))</span></pre><h1 id="3c84" class="lv lp in bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">这是如何工作的？</h1><p id="2180" class="pw-post-body-paragraph ka kb in kc b kd ms kf kg kh mt kj kk kl mu kn ko kp mv kr ks kt mw kv kw kx ig bi translated">这个概念是，对于列表中的每个元素，我们检查它在最长子序列列表中的位置(结果数组)。<br/>可以有两种情况<strong class="kc io"/>:</p><ul class=""><li id="0333" class="mx my in kc b kd ke kh ki kl mz kp na kt nb kx nc nd ne nf bi translated"><strong class="kc io">在</strong>的结果数组里面，这意味着我们应该用这个值替换旧的值。(在替换之前，我们验证该数字与结果数组中的数字不同)</li><li id="b55b" class="mx my in kc b kd ng kh nh kl ni kp nj kt nk kx nc nd ne nf bi translated"><strong class="kc io">在</strong>结果数组之外，这意味着它是一个新的递增序列，所以我们把它附加到结果数组中。(在追加之前，我们验证它与结果数组中的数字不同)</li></ul><p id="1fcb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这种技术是可行的，因为我们总是按照递增的顺序添加新的数字。</p><figure class="lf lg lh li gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nl"><img src="../Images/a716078c1b3c2ca7fa489ef97788858f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lrNZJM9TMdi1TNRuVkGoqw.png"/></div></div></figure><figure class="lf lg lh li gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nm"><img src="../Images/bc0138fe5a5d00eb6cbfe90201fc6fdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GqOPu-U3LOeRmP4O614LQg.png"/></div></div></figure><p id="bb8e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">上面的结果来自leetcode，它验证程序并显示执行时间和消耗的内存。</p><p id="809b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">注</strong>:该程序只能用来统计最长子序列数组的长度。如果我们需要实际的序列，我们需要使用二维数组来存储每个长度的序列。通常在编程竞赛中，我们只对最长序列的长度感兴趣。</p><blockquote class="ky kz la"><p id="ccb9" class="ka kb lb kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated">不过，如果您对序列本身感兴趣，请查看下面的代码:</p></blockquote><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="f3d9" class="lo lp in lk b gy lq lr l ls lt">    def lis_nlogn(arr):</span><span id="de1d" class="lo lp in lk b gy lu lr l ls lt">        if len(arr) == 0:<br/>          return 0<br/>        <br/>        l = [[arr[0]]]<br/>        for element in arr[1:]:<br/>            pos = bisect.bisect(l[-1], element)<br/>            if pos == len(l):<br/>                if element &gt; l[pos - 1][pos - 1]:<br/>                    l.append(l[pos -1] + [element])<br/>            elif pos == 0:<br/>                l[pos][pos] = element<br/>            else:<br/>                if element != l[pos - 1][pos -1]:<br/>                    l[pos][pos] = element<br/>        return len(l)<br/>## l contains the actual sequence </span></pre><p id="14d1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">使用这种方法，对于同一组测试用例，执行时间为60 ms，内存消耗增加到38.4 MB。</p></div><div class="ab cl nn no hr np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ig ih ii ij ik"><p id="64f4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果我们感兴趣的是长度而不是实际的序列，请确保使用第一个程序。</p></div></div>    
</body>
</html>