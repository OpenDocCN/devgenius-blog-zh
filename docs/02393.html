<html>
<head>
<title>Vectors in C++: A simple guide</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C++中的向量:简单指南</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/vectors-in-c-a-simple-guide-1c809e4d7ef6?source=collection_archive---------7-----------------------#2020-08-01">https://blog.devgenius.io/vectors-in-c-a-simple-guide-1c809e4d7ef6?source=collection_archive---------7-----------------------#2020-08-01</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/a502aaeaa2e926f57971768e0fcc84a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*KZrqnLYB6_PDOsHf"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">照片由<a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae jz" href="https://unsplash.com/@azhar93?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Azharul Islam </a>拍摄</figcaption></figure><p id="eb69" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果你是程序员，你一定玩过数组。C++中的向量非常像数组，但是它们比数组更灵活。</p><p id="83e2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这篇文章是关于C++中向量的综合指南。所以让我们开始吧。</p><h1 id="1a4c" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">什么是向量？</h1><p id="a26f" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">Vector是C++编程语言标准模板库中的模板类。C++中的向量是存储元素的序列容器。</p><p id="2d8e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">它是一个动态存储元素的容器。</p><blockquote class="mb mc md"><p id="6cae" class="ka kb me kc b kd ke kf kg kh ki kj kk mf km kn ko mg kq kr ks mh ku kv kw kx ig bi translated">简单地说，向量是<strong class="kc io">动态数组</strong>，具有自我调整大小的能力。</p></blockquote><p id="b218" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">向量的大小可以根据需求增长，也就是说，当程序员在向量中添加元素时。</p><h1 id="ac4e" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">迭代器</h1><h2 id="50c9" class="mi kz in bd la mj mk dn le ml mm dp li kl mn mo lm kp mp mq lq kt mr ms lu mt bi translated">向量::begin()</h2><p id="b706" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">begin()函数用于返回指向向量第一个元素的迭代器。</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="4986" class="mi kz in mz b gy nd ne l nf ng">vector_name.begin()</span></pre><h2 id="8d76" class="mi kz in bd la mj mk dn le ml mm dp li kl mn mo lm kp mp mq lq kt mr ms lu mt bi translated">vector::end()</h2><p id="36bc" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">end()函数用于返回指向向量最后一个元素的迭代器。</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="e2d6" class="mi kz in mz b gy nd ne l nf ng">vector_name.end()</span></pre><h1 id="622c" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">尺寸和容量</h1><p id="ee39" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">向量有两种相关的大小。</p><ol class=""><li id="9ee8" class="nh ni in kc b kd ke kh ki kl nj kp nk kt nl kx nm nn no np bi translated">其中一个被称为<strong class="kc io"> size </strong>，它指示了它当前保存的元素数量。</li><li id="ff8a" class="nh ni in kc b kd nq kh nr kl ns kp nt kt nu kx nm nn no np bi translated">另一个叫做<strong class="kc io">容量</strong>，是它可以容纳的元素数量。</li></ol><figure class="mu mv mw mx gt jo gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/3349aff14e3156c4d1c04e138ab6d97e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1156/1*8lStNrSYDZXB3-kv0Uo_hw.gif"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">作者照片</figcaption></figure><p id="66e6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在vector的末尾增加额外的空间是为了减少每次向vector添加新元素时的内存分配成本。</p><p id="f97d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如上图所示，当通过向vector添加一些元素来填充可用空间时，<strong class="kc io">vector的容量增加了两个</strong>，这意味着分配给vector的内存增加了一倍。在解释与vector类相关联的capacity()方法时，下面包含了此行为的示例。</p><h1 id="17a0" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">如何初始化向量</h1><p id="c457" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">在初始化一个vector之前，你要知道要使用vector，你必须包含下面的头文件。</p><blockquote class="mb mc md"><p id="58b7" class="ka kb me kc b kd ke kf kg kh ki kj kk mf km kn ko mg kq kr ks mh ku kv kw kx ig bi translated">#包括<vector/></p></blockquote><p id="985b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在让我们回到初始化。</p><p id="2c12" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">向量可以串行存储任何类型的数据。存储在vector中的数据类型可以是int、char、float等，也可以是特定类的vector。</p><p id="ccbd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">向量通常如下初始化，</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="078e" class="mi kz in mz b gy nd ne l nf ng">vector&lt;int&gt; a;<br/>vector&lt;char&gt; ch;<br/>vector&lt;Book&gt; b; // where Book is a class defined.</span></pre><p id="872a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">从下面的代码中，可以更详细地理解向量的初始化。</p><figure class="mu mv mw mx gt jo"><div class="bz fp l di"><div class="nw nx l"/></div></figure><h1 id="7105" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">Vector类上可用的方法</h1><blockquote class="mb mc md"><p id="b37a" class="ka kb me kc b kd ke kf kg kh ki kj kk mf km kn ko mg kq kr ks mh ku kv kw kx ig bi translated"><strong class="kc io"> <em class="in"> push_back() </em> </strong></p></blockquote><p id="0986" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">该方法<strong class="kc io">在矢量的末端</strong>添加元素。</p><blockquote class="mb mc md"><p id="5d70" class="ka kb me kc b kd ke kf kg kh ki kj kk mf km kn ko mg kq kr ks mh ku kv kw kx ig bi translated"><strong class="kc io"> <em class="in"> pop_back() </em> </strong></p></blockquote><p id="b769" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个方法<strong class="kc io">从向量中移除最后一个元素</strong>。</p><blockquote class="mb mc md"><p id="f464" class="ka kb me kc b kd ke kf kg kh ki kj kk mf km kn ko mg kq kr ks mh ku kv kw kx ig bi translated"><strong class="kc io"> <em class="in">尺寸()</em> </strong></p></blockquote><p id="a3c4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">返回它当前保存的元素数量。</p><p id="4b90" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">通过下面代码可以很好地理解以上三种方法:</p><figure class="mu mv mw mx gt jo"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="b804" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">输出:</strong></p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="491a" class="mi kz in mz b gy nd ne l nf ng">0. size: 0<br/>1. size: 10<br/>2. size: 20<br/>3. size: 19</span></pre><blockquote class="mb mc md"><p id="f1e3" class="ka kb me kc b kd ke kf kg kh ki kj kk mf km kn ko mg kq kr ks mh ku kv kw kx ig bi translated"><strong class="kc io"> <em class="in">容量()</em> </strong></p></blockquote><p id="3f2c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">返回<strong class="kc io">它能容纳的元素数量</strong>。</p><p id="245e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">通过下面例子可以很好地理解，</p><figure class="mu mv mw mx gt jo"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="cc58" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">输出:</strong></p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="7447" class="mi kz in mz b gy nd ne l nf ng">0. capacity: 0<br/>1. capacity: 16</span></pre><p id="8dff" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">解释:</strong></p><ol class=""><li id="376e" class="nh ni in kc b kd ke kh ki kl nj kp nk kt nl kx nm nn no np bi translated">在<strong class="kc io">初始化</strong>后，矢量<strong class="kc io">容量</strong>为零<strong class="kc io"/></li><li id="9391" class="nh ni in kc b kd nq kh nr kl ns kp nt kt nu kx nm nn no np bi translated">在<strong class="kc io">添加第一个</strong>元素后<strong class="kc io">容量</strong>变为<strong class="kc io">一个</strong></li><li id="a711" class="nh ni in kc b kd nq kh nr kl ns kp nt kt nu kx nm nn no np bi translated">在<strong class="kc io">增加第二个</strong>元素后<strong class="kc io">容量</strong>变成了<strong class="kc io">两个</strong></li><li id="d4cc" class="nh ni in kc b kd nq kh nr kl ns kp nt kt nu kx nm nn no np bi translated">在<strong class="kc io">增加第三个</strong>元素后<strong class="kc io">容量</strong>变成了<strong class="kc io">四个</strong></li><li id="2df9" class="nh ni in kc b kd nq kh nr kl ns kp nt kt nu kx nm nn no np bi translated">在<strong class="kc io">添加第五个</strong>元素后<strong class="kc io">容量</strong>变成了<strong class="kc io">八个</strong></li><li id="5083" class="nh ni in kc b kd nq kh nr kl ns kp nt kt nu kx nm nn no np bi translated">在<strong class="kc io">增加第九个</strong>元素后<strong class="kc io">容量</strong>变成了<strong class="kc io">十六个</strong></li></ol><blockquote class="mb mc md"><p id="410e" class="ka kb me kc b kd ke kf kg kh ki kj kk mf km kn ko mg kq kr ks mh ku kv kw kx ig bi translated"><strong class="kc io"> <em class="in">空()</em> </strong></p></blockquote><p id="b60f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">返回布尔值<strong class="kc io">真</strong>或<strong class="kc io">假</strong>。</p><ol class=""><li id="89f8" class="nh ni in kc b kd ke kh ki kl nj kp nk kt nl kx nm nn no np bi translated">如果vector为空，则为True</li><li id="58de" class="nh ni in kc b kd nq kh nr kl ns kp nt kt nu kx nm nn no np bi translated">如果vector不为空，则为False</li></ol><p id="c34a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">通过下面例子可以很好地理解，</p><figure class="mu mv mw mx gt jo"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="7b46" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">输出:</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="90bf" class="mi kz in mz b gy nd ne l nf ng">1<br/>0</span></pre><blockquote class="mb mc md"><p id="c098" class="ka kb me kc b kd ke kf kg kh ki kj kk mf km kn ko mg kq kr ks mh ku kv kw kx ig bi translated"><strong class="kc io"> <em class="in">前面()</em> </strong></p></blockquote><p id="f9ba" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">返回向量的<strong class="kc io">前元素</strong>。</p><blockquote class="mb mc md"><p id="5fc5" class="ka kb me kc b kd ke kf kg kh ki kj kk mf km kn ko mg kq kr ks mh ku kv kw kx ig bi translated"><strong class="kc io"> <em class="in">回()</em> </strong></p></blockquote><p id="d3a3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">返回向量的最后一个元素。</p><p id="6d28" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">以下代码解释了front()和back()函数，</p><figure class="mu mv mw mx gt jo"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="53fb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">输出:</strong></p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="2a19" class="mi kz in mz b gy nd ne l nf ng">Front element: 0<br/>Back element: 9</span></pre><blockquote class="mb mc md"><p id="073f" class="ka kb me kc b kd ke kf kg kh ki kj kk mf km kn ko mg kq kr ks mh ku kv kw kx ig bi translated"><strong class="kc io"> <em class="in">插入()</em> </strong></p></blockquote><p id="f78b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在数组中间插入元素。</p><blockquote class="mb mc md"><p id="5a22" class="ka kb me kc b kd ke kf kg kh ki kj kk mf km kn ko mg kq kr ks mh ku kv kw kx ig bi translated"><strong class="kc io"> <em class="in"> erase() </em> </strong></p></blockquote><p id="6752" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">从数组中间擦除元素。</p><p id="6f99" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">insert()和erase()可以通过下面的代码示例很好地理解，</p><figure class="mu mv mw mx gt jo"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="8286" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">输出:</strong></p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="3af2" class="mi kz in mz b gy nd ne l nf ng">The vector elements are: 2 3 7 10 20 30 40<br/>After Erase: 2 3 10 20 30 40</span></pre></div><div class="ab cl ny nz hr oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="ig ih ii ij ik"><h1 id="4480" class="ky kz in bd la lb of ld le lf og lh li lj oh ll lm ln oi lp lq lr oj lt lu lv bi translated">结论</h1><p id="3ffd" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">在本文中，我们学习了C++中的向量以及与它们相关的方法。我们也看到了一些使用它们的例子。</p></div><div class="ab cl ny nz hr oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="ig ih ii ij ik"><p id="fb6f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">非常感谢您的阅读。祝你愉快！</p></div></div>    
</body>
</html>