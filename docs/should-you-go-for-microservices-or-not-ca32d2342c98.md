# 您是否应该选择微服务？

> 原文：<https://blog.devgenius.io/should-you-go-for-microservices-or-not-ca32d2342c98?source=collection_archive---------14----------------------->

*   微服务是一种现在更常用于开发的网络应用架构。有时，您可能想知道我们是否需要继续前进？此次迁移面临哪些挑战？就像那样。如果你有这样的想法，这篇文章将会有所帮助。
*   如今我们称之为**单片应用的应用。**我们这样称呼它，是因为它有一个可执行文件用于整个应用程序。(整个应用程序打包到一个文件中)
*   想象一个在线比萨订购系统的场景。所以我们有用户界面、业务层、客户注册流程、员工注册流程、计费/订购流程，就像许多流程一样。

**单片应用中的缺点**

> 现在假设我们需要对用户界面做一个小小的修改。所以，您只需更改简单的内容，但需要考虑并发送整个文件。在这种情况下，我们必须检查整个应用程序，完全脱机，检查整个性能，就像 wise 一样，这可能会导致越来越深的处理。

很明显，您可以看到这一缺点将如何影响应用程序。

> 单片应用程序的另一个问题是为单个应用程序维护庞大的代码库，这可能需要 100 多名工程师来维护。所以当一些问题出现时，没人会知道是谁的错。谁需要为此负责？所以调试过程可能会导致巨大的混乱。

**单片应用的优势**

> 它很容易测试，因为如果你想写集成测试单个应用程序，因为没有依赖性。
> 
> 易于监控。因为这是一个应用程序，我们可以确定确切的部分。
> 
> **上述缺点的解决方案？微服务**

![](img/6d8bc2fe09b6e580d931bdb60307e82c.png)

参考:[https://pretius.com/](https://pretius.com/)

# **微服务**

*   **这是一个借助容器创建分布式应用程序的架构概念/设计**。它们之所以得名，是因为应用程序的每个功能都作为独立的服务运行。有人说微服务就是 SOA(面向服务的体系结构)
*   但是**应用服务具有可重用性，而微服务则更注重解耦。**
*   它是领域驱动的开发，并且有明确的范围。
*   它应该运行自己的进程(自己的 web 容器),并且独立于其他进程。
*   微服务可以通过一些轻量级机制(大多数时间是 HTTP)与其他服务通信
*   微服务作为单独的服务进行扩展和部署。
*   建议尽可能保持分散控制。

**可扩展性的艺术**

![](img/c1ed3736ae00a25a1766d28b3eb86f21.png)

参考自《可伸缩性的艺术》

*   x 轴-该轴表示水平应用程序缩放。
*   z 轴——这个轴通过分割相似的东西来缩放应用程序。
*   Y 轴代表*功能分解*。在这里，我们可以将各种流程视为独立的服务。我们可以独立部署相关服务，而不是部署整个应用程序。

> 让我们回到之前讨论过的场景。在线比萨饼订购系统。所以我们有 UI、业务层、客户注册流程、员工、搜索流程、注册流程、计费/订购流程。因此，根据微服务架构，这 7 项服务将拥有 7 项不同的独立服务。

*   让我们以搜索服务为例。这可能是假日期间需求最高的服务。所以可能会有巨大的流量。在这里，我们有能力生成新的搜索服务，然后平衡负载(单独可扩展)。
*   在早期的架构中，我们必须从整个应用程序中向外扩展并生成实例。但现在我们有 7 个不同的服务，但我们从搜索服务创建其他实例。
*   另一个优势是，当遇到正常流量的平常日子时，我们可以取消所有其他额外的服务，并保持正常的服务。(成本效益高)
*   在微服务架构中，我们必须确保服务依赖于其他因素。应该能够在任何给定时间移除/插入。以便部署不应该有硬依赖关系的服务。如果有它将违反微服务质量。

让我们考虑一个有 A、B、C 服务的场景，现在服务 A 将要调用 B，但是考虑一个服务 B 已经超时的情况。现在我们必须维护这个容错包，应该能够维护并克服这种故障情况。因此，有一些机制将在后面的文章中讨论。

实施微服务的一个最苛刻的方面是它应该具有从消费者到后端的可见性。

# 微服务的优势

*   **可以清楚地区分断层**
*   **根据需要在个人服务上试验新技术是很灵活的**。
*   **更好地理解服务中的功能。**
*   可伸缩性:由于服务是独立的，我们可以更容易地伸缩。(成本和时间有效)

# 微服务的缺点

*   **必须非常注意请求是如何在模块之间传递的。**(否则可能导致长时间的延迟)
*   **服务量越大-所需资源越多。**
*   **全局测试困难**
*   **由于故障中出现大量日志文件，解决/调试可能会更加困难。**
*   **对于需要快速创建和迭代的方法来说，实现起来可能较慢，而且过于复杂。**