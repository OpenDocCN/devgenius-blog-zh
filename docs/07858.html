<html>
<head>
<title>Object Pool Pattern in Unity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Unity 中的对象池模式</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/object-pool-pattern-in-unity-f285adea5d5a?source=collection_archive---------0-----------------------#2022-04-28">https://blog.devgenius.io/object-pool-pattern-in-unity-f285adea5d5a?source=collection_archive---------0-----------------------#2022-04-28</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/b7c0d054c8af89bb4d1f7965b5886e3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mrZjWFRzBPPzd10vbMCcNg.jpeg"/></div></div></figure><p id="87b3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">使用一组随时可用的初始化对象，而不是按需分配和销毁它们。这有助于提高性能，因为它重用了对象，而不是不断地销毁和创建它们。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi kt"><img src="../Images/aecc1f6bd7ee942c9ef5ea66640decdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VbgVUhT1Z6PlFINQ__Hvzw.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">对象池可视化示例</figcaption></figure><p id="8003" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我有一个带有子弹组件的子弹预置和一个用于视觉的精灵渲染。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div class="gh gi lc"><img src="../Images/214756b0cdf1d2266395ea15a1e38efc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1010/format:webp/1*BKqyKkoaVisE3kWGLSuSKA.png"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">预制项目符号</figcaption></figure><p id="6c61" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">子弹行为有一个速度，在更新方法中子弹以这个速度移动。当摄像头看不到子弹时，它就会自我毁灭。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div class="gh gi ld"><img src="../Images/dcf749838f03daf63e1217517258c27c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1178/format:webp/1*INLiuqdSoLgSOf74hXgTzQ.png"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">项目符号行为</figcaption></figure><p id="acce" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我有一个带有发射器组件的发射器。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div class="gh gi le"><img src="../Images/f046e3195d16b9faedf40b9c163476c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1008/format:webp/1*EkFGLCoIlLDXpWDwKPTx3w.png"/></div></figure><p id="d31f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">发射器行为包含一个子弹预置，当我按空格键一个新的子弹在游戏中创建。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lf"><img src="../Images/a011d521b0daa8da61cdeacf363a4cbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-5Pu3vUoD2oDEJFpqGy7PQ.png"/></div></div></figure><p id="ca44" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">每次我按下空格键，就会产生一个新的子弹，当子弹到达屏幕的末端时，子弹就会从游戏中移除。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lg"><img src="../Images/779a6292ffe19bf7375cf44c1b34f23b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*B-ecsg6FG1cGe7KaJy1K2w.gif"/></div></div></figure><p id="510e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这个例子中，没有足够的东西影响游戏的性能，但是想象一下，每一帧都有成百上千个这样的东西被创建和破坏。</p><h1 id="515e" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">履行</h1><p id="772e" class="pw-post-body-paragraph jv jw in jx b jy mf ka kb kc mg ke kf kg mh ki kj kk mi km kn ko mj kq kr ks ig bi translated">如果你使用的是 Unity 2021，Unity 已经内置了一个。</p><div class="mk ml gp gr mm mn"><a href="https://docs.unity3d.com/ScriptReference/Pool.ObjectPool_1.html" rel="noopener  ugc nofollow" target="_blank"><div class="mo ab fo"><div class="mp ab mq cl cj mr"><h2 class="bd io gy z fp ms fr fs mt fu fw im bi translated">对象池</h2><div class="mu l"><h3 class="bd b gy z fp ms fr fs mt fu fw dk translated">UnityEngine 中的类。Pool /实现于:UnityEngine。CoreModule 实现接口:IObjectPool 建议更改…</h3></div><div class="mv l"><p class="bd b dl z fp ms fr fs mt fu fw dk translated">docs.unity3d.com</p></div></div><div class="mw l"><div class="mx l my mz na mw nb jt mn"/></div></div></a></div><p id="149e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果您使用的是旧版本的 Unity，那么您必须制作自己的 see Unity Learn 作为一个良好的起点/</p><div class="mk ml gp gr mm mn"><a href="https://learn.unity.com/tutorial/introduction-to-object-pooling" rel="noopener  ugc nofollow" target="_blank"><div class="mo ab fo"><div class="mp ab mq cl cj mr"><h2 class="bd io gy z fp ms fr fs mt fu fw im bi translated">对象池介绍- Unity Learn</h2><div class="mu l"><h3 class="bd b gy z fp ms fr fs mt fu fw dk translated">对象池是优化您的项目和减轻 CPU 负担的一个很好的方法，当您不得不…</h3></div><div class="mv l"><p class="bd b dl z fp ms fr fs mt fu fw dk translated">learn.unity.com</p></div></div><div class="mw l"><div class="nc l my mz na mw nb jt mn"/></div></div></a></div><p id="9eca" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我将展示如何在 Unity 2021 中使用新的对象池。</p><p id="6ddc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我需要做的第一件事是在客户机上创建一个我想要的类型的 IObjectPool，在我的例子中，它是启动器中的一个子弹池。我还要确保我使用的是 UnityEngine。池命名空间。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nd"><img src="../Images/ee596c799a12eae3f333fb971334bc61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*5X6UH-3EWbJSEhhsiU9bIg.gif"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">IObjectPool <bullet>已添加到启动器</bullet></figcaption></figure><p id="639e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">接下来，我需要用一个具体的实现实例化这个池，我将在 Awake 中完成。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ne"><img src="../Images/d89705e1b95c728cf8e7ae48c74319e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*BbCQ8IPQbkahk4ZGv7SzwQ.gif"/></div></div></figure><p id="5903" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了创建池，池需要几个函数。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nf"><img src="../Images/a98edf5e56022cd0757892987d5f2159.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fO2uMs7WlZmcUb8c6sH-Ag.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated"><a class="ae ng" href="https://docs.unity3d.com/2021.3/Documentation/ScriptReference/Pool.ObjectPool_1-ctor.html" rel="noopener ugc nofollow" target="_blank">https://docs . unity 3d . com/2021.3/Documentation/script reference/Pool。ObjectPool_1-ctor.html </a></figcaption></figure><p id="6c05" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我使用 Rider 作为我的 IDE，这样我就可以一边走一边自动创建这些函数。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nh"><img src="../Images/8a16e2a766c45e8236d216ed303b52e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*WQRCfSV0tDQfAgE6Q_t1bw.gif"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">实例化新池并创建函数</figcaption></figure><p id="2e5e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后 3 个参数有默认值，所以我不需要为它们指定什么。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ni"><img src="../Images/651f7487da5f00b7a518d12d13f26dfb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RnOeeQUdbYSvM0RiPYsdyA.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">建立一个新的子弹池</figcaption></figure><h2 id="9407" class="nj li in bd lj nk nl dn ln nm nn dp lr kg no np lv kk nq nr lz ko ns nt md nu bi translated">创建方法</h2><blockquote class="nv nw nx"><p id="7c89" class="jv jw ny jx b jy jz ka kb kc kd ke kf nz kh ki kj oa kl km kn ob kp kq kr ks ig bi translated">createFunc 用于在池为空时创建新实例。在大多数情况下，这将只是()= &gt;新的 T()。</p></blockquote><p id="9056" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我不是在 Update 方法中实例化一个新的项目符号，而是从池中获取一个项目符号，并在 create 方法中实例化该项目符号。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi oc"><img src="../Images/1731ab6b49d3128481fa45c855c14dd6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*eUb-rDACC51TaW1uvfVGaw.gif"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">从池中获取一个新的项目符号，并在 Create 方法中实例化该项目符号</figcaption></figure><h2 id="8439" class="nj li in bd lj nk nl dn ln nm nn dp lr kg no np lv kk nq nr lz ko ns nt md nu bi translated">Get 方法上的操作</h2><blockquote class="nv nw nx"><p id="ec18" class="jv jw ny jx b jy jz ka kb kc kd ke kf nz kh ki kj oa kl km kn ob kp kq kr ks ig bi translated">从池中取出实例时调用 actionOnGet。</p></blockquote><p id="4c8a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当我从泳池里拿到一颗子弹时，这就是我想要发生的。我要子弹把自己设置成主动，把子弹的位置设置成发射架的位置。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi od"><img src="../Images/8ccad668c8e06a2d1b853f8490648d70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Z8VN-gpU33T7n0ioUlN_0g.gif"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">在获取项目符号时</figcaption></figure><h2 id="abec" class="nj li in bd lj nk nl dn ln nm nn dp lr kg no np lv kk nq nr lz ko ns nt md nu bi translated">对发布方法的操作</h2><blockquote class="nv nw nx"><p id="cc74" class="jv jw ny jx b jy jz ka kb kc kd ke kf nz kh ki kj oa kl km kn ob kp kq kr ks ig bi translated">当实例返回到池中时调用 actionOnRelease。这可用于清理或禁用实例。</p></blockquote><p id="7329" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我将停用场景中的子弹游戏对象。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/45bf843f2832cf10a77b3597e06dcb09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1344/1*HIt39WCl7YHeJgVBIL7L0Q.gif"/></div></figure><h2 id="ec05" class="nj li in bd lj nk nl dn ln nm nn dp lr kg no np lv kk nq nr lz ko ns nt md nu bi translated">销毁方法上的操作</h2><blockquote class="nv nw nx"><p id="5fa8" class="jv jw ny jx b jy jz ka kb kc kd ke kf nz kh ki kj oa kl km kn ob kp kq kr ks ig bi translated">当元素由于池达到最大大小而无法返回到池时，调用 actionOnDestroy。</p></blockquote><p id="608d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果子弹池太大，那么我将摧毁子弹游戏对象。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi of"><img src="../Images/0678e669efbe4afdb41dd35892c04b2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*PVkU8g7YzQPpZtI6rLk6QA.gif"/></div></div></figure><h2 id="2a28" class="nj li in bd lj nk nl dn ln nm nn dp lr kg no np lv kk nq nr lz ko ns nt md nu bi translated">正确处理子弹</h2><p id="6698" class="pw-post-body-paragraph jv jw in jx b jy mf ka kb kc mg ke kf kg mh ki kj kk mi km kn ko mj kq kr ks ig bi translated">目前我的子弹行为/组件/脚本告诉子弹在隐形时自我毁灭。我需要把子弹放回游泳池。在一个真实的游戏中，我可能会使用一个碰撞器和一个内置的物理方法/功能，比如触发回车。我将在这个演示中使用隐形。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi og"><img src="../Images/74f21c921e3653985e68c16b20f7b8a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*BIFnPA_ajEznSjKg0InstQ.gif"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">正确地将子弹释放回泳池</figcaption></figure><p id="c766" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我还需要能够设置对池的引用。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi oh"><img src="../Images/8cf9ab2144010bde19baf19bc58c46a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*3S7YUkadYTuzFg-TMpVagw.gif"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">方法来设置对池的引用</figcaption></figure><p id="9ec2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我需要在发射器创建子弹的时候设置子弹所属的池。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi oi"><img src="../Images/4452e6bc6080b907dea9879f6f4f41d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*gR45TcsS3-uAqsOKkHOUAw.gif"/></div></div></figure><h1 id="be40" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">现在子弹池工作正常。</h1><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi oj"><img src="../Images/2d9787589d57ddeca9de79fc2b2d53f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*aW0e2ibx-D1gS6mdvIQl6Q.gif"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">Unity 创建项目符号并使用项目符号池</figcaption></figure><h2 id="5020" class="nj li in bd lj nk nl dn ln nm nn dp lr kg no np lv kk nq nr lz ko ns nt md nu bi translated">最大池大小</h2><p id="9dfa" class="pw-post-body-paragraph jv jw in jx b jy mf ka kb kc mg ke kf kg mh ki kj kk mi km kn ko mj kq kr ks ig bi translated">请注意，子弹被返回到池中，游戏对象变为非活动状态。现在，游戏将在池中创建多达 10，000 颗子弹，请注意，我实际达到的最大值是 13。我可以将池的最大大小设置为 5 或 10，Unity 将删除不需要的多余项目符号。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ok"><img src="../Images/8cc34e64a1a29beed26cace639bbc4f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*_dIv5A0h0jLns2__agq1rg.gif"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">将最大尺寸设置为 5</figcaption></figure><p id="14cb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在 Unity 将只在场景中保留 5 颗子弹，并销毁不适合池中的子弹。它首先从库中获取子弹，如果库中没有子弹，它将创建一个新的子弹。子弹被送回弹药库，如果弹药库已经达到最大尺寸，那么子弹将被销毁。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ol"><img src="../Images/9d597d6387cb6a07788632fe15f7a01e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*MnccAow9_ME5lcMdogRaEA.gif"/></div></div></figure><p id="58f0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">代码可以在我的 Git Hub 页面上找到</p><div class="mk ml gp gr mm mn"><a href="https://github.com/JamesLaFritz/Design-Patterns-For-Unity/tree/release-ObjectPooling" rel="noopener  ugc nofollow" target="_blank"><div class="mo ab fo"><div class="mp ab mq cl cj mr"><h2 class="bd io gy z fp ms fr fs mt fu fw im bi translated">GitHub-JamesLaFritz/Design-Patterns-For-Unity 发布时-对象池</h2><div class="mu l"><h3 class="bd b gy z fp ms fr fs mt fu fw dk translated">报告 Bug 请求特性展示了 Unity 中不同的编程设计模式。有许多不同的…</h3></div><div class="mv l"><p class="bd b dl z fp ms fr fs mt fu fw dk translated">github.com</p></div></div><div class="mw l"><div class="om l my mz na mw nb jt mn"/></div></div></a></div></div></div>    
</body>
</html>