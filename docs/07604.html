<html>
<head>
<title>Introduction to Binary Search</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">二分搜索法简介</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/introduction-to-binary-search-6c60304f42f7?source=collection_archive---------6-----------------------#2022-04-09">https://blog.devgenius.io/introduction-to-binary-search-6c60304f42f7?source=collection_archive---------6-----------------------#2022-04-09</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="26f9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">假设你正在那些大电话簿中寻找一个名叫“文森特”的人。这些书可能有 100 页，以线性方式从头开始搜索每一页，直到找到那个人，这将是乏味的。幸运的是，这本书是按字母顺序排列的，所以我们可以使用 hack。</p><p id="b4db" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">想象一下在中间打开书。你看着这一页，看到以“S”开头的名字。知道“V”在“S”之后，你把书撕成两半，把名字在“S”下面的那半本书扔掉。现在你只剩下一本更小的书要处理了。</p><p id="e87f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">接下来，你再把剩下的书打开一半。你看着你着陆的地方，看到以“X”开头的名字。你再把书撕成两半，把名字在“X”上面的那一半扔掉。</p><p id="9e1f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">不断重复这个过程，很快你就会看到以“V”开头的页面。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/2760665645c1765fdee6f8e383486c8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*lNiCVjqvIYmK0dSi1jmHTg.gif"/></div></figure><p id="bc38" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是<strong class="jm io">二分搜索法</strong>的概念。二分搜索法是一种有效的算法，用于搜索按 T2 排序的数组或列表中的值。它是被称为<a class="ae kq" href="https://en.wikipedia.org/wiki/Divide-and-conquer_algorithm" rel="noopener ugc nofollow" target="_blank"> <em class="kr">分治</em> </a>的一大类算法的一部分。这些类别的算法将一个复杂的问题分成更小的更容易解决的子问题。对二分搜索法来说，在解决方案的每个阶段，问题几乎每次都减半。</p></div><div class="ab cl ks kt hr ku" role="separator"><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx ky"/><span class="kv bw bk kw kx"/></div><div class="ig ih ii ij ik"><p id="190d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了说明这个算法的过程，假设我们想在下面的有序数字数组中找到 89。图中的底部和顶部分别是保存开始和结束索引的变量。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gh gi kz"><img src="../Images/767c6a2827bad0348c5ad222e34ea24d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UwKZ8TU9RZIvG6EgdtRucA.png"/></div></div></figure><p id="5258" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们首先使用底部和顶部变量计算中间值。中间值是 47，这不是我们想要的值。因为我们知道 47 &lt; 89, we can eliminate the left half of the array (every value before and including 47). This is done by assigning the bottom variable to middle index + 1. Our problem size has halved.</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gh gi le"><img src="../Images/9f96d743eae43924278fca318e9fc1f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*42CM6xntu2DT7DjE3Dn2ZQ.png"/></div></div></figure><p id="69fc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">The process repeats again. We calculate the middle value to be 97. Then we know that 97 &gt; 89 和数组的右半部分可以通过将 top 变量设置为 middle index - 1 从搜索中消除。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gh gi lf"><img src="../Images/16dbbc11e572544b1c91cac9477c7ac5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LobprP-rEcxJ-JXc7Gim9Q.png"/></div></div></figure><p id="7789" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们再次重复这个过程。中间值计算为 89。我们看到 89 = 89，因此我们可以停止搜索并返回值或索引！</p><p id="79e3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">线性搜索需要我们走 7 步，但是二分搜索法只用了 3 步就找到了 89。对于较小的阵列，两种算法之间的计算时间可以忽略不计。然而，对于大型数据集——我们谈论的是数百万个值，<a class="ae kq" href="https://www.khanacademy.org/computing/computer-science/algorithms/binary-search/a/running-time-of-binary-search" rel="noopener ugc nofollow" target="_blank">二分搜索法比线性搜索</a>更有效。</p><h1 id="aac4" class="lg lh in bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">伪代码</h1><p id="55a7" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">二分搜索法的步骤可以写成:</p><ol class=""><li id="7a04" class="mj mk in jm b jn jo jr js jv ml jz mm kd mn kh mo mp mq mr bi translated">创建一个名为“bottom”的变量，指向子数组的下限</li><li id="a59d" class="mj mk in jm b jn ms jr mt jv mu jz mv kd mw kh mo mp mq mr bi translated">创建一个名为“top”的变量，指向子数组的上限</li><li id="ad24" class="mj mk in jm b jn ms jr mt jv mu jz mv kd mw kh mo mp mq mr bi translated">创建一个名为“middle”的变量，指向子数组的中间</li><li id="1518" class="mj mk in jm b jn ms jr mt jv mu jz mv kd mw kh mo mp mq mr bi translated">当底部&lt;= top, do the following:</li></ol><ul class=""><li id="5019" class="mj mk in jm b jn jo jr js jv ml jz mm kd mn kh mx mp mq mr bi translated">Calculate the middle value</li><li id="f51f" class="mj mk in jm b jn ms jr mt jv mu jz mv kd mw kh mx mp mq mr bi translated">If middle value = target value, return the index</li><li id="6dc3" class="mj mk in jm b jn ms jr mt jv mu jz mv kd mw kh mx mp mq mr bi translated">if middle value &lt; target value, set bottom = middle + 1</li><li id="09ac" class="mj mk in jm b jn ms jr mt jv mu jz mv kd mw kh mx mp mq mr bi translated">If middle value &gt;为目标值时，设定顶部=中间-1</li></ul><p id="db05" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">5.数组中不存在目标值</p><p id="ce25" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae kq" href="https://gist.github.com/xihai01/045cd00527f0ef7feebceca537d53f28" rel="noopener ugc nofollow" target="_blank">JS 中实现的一个例子</a></p><h1 id="b5de" class="lg lh in bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">视觉演示</h1><p id="ead1" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">这个小程序直观地展示了二分搜索法的想法。目标值是我们试图猜测的数字，用户的猜测是我们的二分搜索法算法中的中间值。</p><div class="my mz gp gr na nb"><a href="https://xihai01.github.io/binary-search/" rel="noopener  ugc nofollow" target="_blank"><div class="nc ab fo"><div class="nd ab ne cl cj nf"><h2 class="bd io gy z fp ng fr fs nh fu fw im bi translated">React 应用</h2><div class="ni l"><h3 class="bd b gy z fp ng fr fs nh fu fw dk translated">使用 create-react-app 创建的网站</h3></div><div class="nj l"><p class="bd b dl z fp ng fr fs nh fu fw dk translated">xihai01.github.io</p></div></div></div></a></div><p id="6959" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">GitHub 回购:</p><div class="my mz gp gr na nb"><a href="https://github.com/xihai01/binary-search" rel="noopener  ugc nofollow" target="_blank"><div class="nc ab fo"><div class="nd ab ne cl cj nf"><h2 class="bd io gy z fp ng fr fs nh fu fw im bi translated">GitHub -西海 01/二进制搜索:二分搜索法游戏</h2><div class="ni l"><h3 class="bd b gy z fp ng fr fs nh fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="nj l"><p class="bd b dl z fp ng fr fs nh fu fw dk translated">github.com</p></div></div><div class="nk l"><div class="nl l nm nn no nk np ko nb"/></div></div></a></div></div></div>    
</body>
</html>