<html>
<head>
<title>Convert API Requests to Mongo Filters with One Function — Standardizing Your API Queries.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用一个函数将 API 请求转换成 Mongo 过滤器——标准化您的 API 查询。</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/mongo-filter-generator-safe-client-side-filtering-with-mongoose-f9968a410e18?source=collection_archive---------5-----------------------#2022-03-30">https://blog.devgenius.io/mongo-filter-generator-safe-client-side-filtering-with-mongoose-f9968a410e18?source=collection_archive---------5-----------------------#2022-03-30</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="46d5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">大家好！感谢您的加入！</p><p id="d32c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">今天，我想分享一个我过去谈论过的库的更新——Mongo Filter Generator——版本 0 . 3 . 0[版本 0.3.3 发布时！】正式发售。</p><p id="6ebd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">自从上次我有机会分享这个库以来，我已经引入了一些新的选项来进一步扩展 API 的过滤功能！</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/f1cdb08387dd55818e42e5f019fa5ec5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tek_JwGAyAaugKYl4mqzRA.jpeg"/></div></div></figure><h1 id="9b72" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">MFG 将服务器请求转换为 Mongo 过滤器</h1><p id="df9f" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated"><code class="fe ly lz ma mb b">mongo-filter-generator</code>的主要目标是<strong class="jm io"> <em class="ki">标准化</em> </strong>客户端如何从使用 mongose/MongoDB 的服务器请求数据。标准化使事情变得简单和可预测！</p><p id="60b1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">MFG 以一种超级简单的方式做到了这一点。</p><p id="07ce" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">通过一个快捷函数发送传入请求，返回 Mongo <code class="fe ly lz ma mb b">filter</code>！将那个<code class="fe ly lz ma mb b">filter</code>传入你喜欢的<code class="fe ly lz ma mb b">model.find()</code>方法，正确的文档就找到了。</p><p id="1e88" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">不再需要编写代码来处理每种过滤可能性的每种情况。在 3 行中，您可以用<code class="fe ly lz ma mb b">mongo-filter-generator</code>将<em class="ki">过滤后的</em>和<em class="ki">分页后的</em>数据返回给客户端。</p><pre class="kk kl km kn gt mc mb md me aw mf bi"><span id="ddbf" class="mg kw in mb b gy mh mi l mj mk">const resolver = {<br/>  getUsers: async (_, args) =&gt; {<br/>    const { filter } = GenerateMongo({fieldFilters: args});<br/>    const users = User.findAndPaginate(filter);<br/>    return users;<br/>  }<br/>}</span></pre><h1 id="4feb" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">具有提供的类型的标准化查询</h1><p id="7dcf" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">该库为 restful 和 graphql APIs 提供了类型(SDL 和类型脚本！)可以应用于预期的请求，服务器端。这意味着无论查询什么资源，服务器都可以期待相同的形状查询。</p><p id="7d47" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这些类型被称为<code class="fe ly lz ma mb b">fieldFilters</code>——有几个可供选择，如<code class="fe ly lz ma mb b">StringFieldFilter</code>、<code class="fe ly lz ma mb b">IntFieldFilter</code>、<code class="fe ly lz ma mb b">BooleanFieldFilter</code>、<code class="fe ly lz ma mb b">DateFieldFilter</code>和<code class="fe ly lz ma mb b">StringArrayFieldFilter</code>。</p><p id="0c43" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用字段过滤器定义输入类型(GraphQL)或请求正文类型定义(REST)。</p><p id="176c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">将字段过滤器应用到 GraphQL 服务器很简单。</p><pre class="kk kl km kn gt mc mb md me aw mf bi"><span id="2b1c" class="mg kw in mb b gy mh mi l mj mk">type User {<br/>  _id: ID!<br/>  name: String!<br/>  age: Int!<br/>  married: Boolean!<br/>  favFoods: [String!]!<br/>  createdAt: DateTime!<br/>}</span><span id="2dd9" class="mg kw in mb b gy ml mi l mj mk">input GetUsersInput {<br/>  _id: StringFieldFilter<br/>  name: [StringFieldFilter]<br/>  age: IntFieldFilter<br/>  married: BooleanFieldFilter<br/>  favFoods: [StringArrayFieldFilter]<br/>  createdAt: DateFieldFilter<br/>}</span><span id="3e00" class="mg kw in mb b gy ml mi l mj mk">type GetUsersResponse {<br/>  data: [User!]!<br/>}</span><span id="840b" class="mg kw in mb b gy ml mi l mj mk">type Query {<br/>  getUsers(getUsersInput: GetUsersInput): GetUsersResponse!<br/>}</span></pre><p id="40a2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">请放心，您可以以多种方式使用字段过滤器，包括在数组或嵌套对象中。</p><p id="a56d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">上面使用的字段过滤器和标量由 MFG 包提供，存储库中的 README.md 有关于如何向应用程序添加类型(包括标量)的简单说明。我不打算在这里看完整的教程，因为这是一个更高层次的制造视图。</p><h1 id="b85d" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">扩展客户端的功能</h1><p id="7993" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">因为字段过滤器不仅仅是基本的输入类型，它们扩展了客户端查找、过滤和分页请求的能力。过滤器提供了标准化的输入，允许客户端决定应该如何查询数据库。</p><h2 id="97b2" class="mg kw in bd kx mm mn dn lb mo mp dp lf jv mq mr lj jz ms mt ln kd mu mv lr mw bi translated">字段过滤器中的附加选项</h2><p id="07b5" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">除了查询本身之外，字段筛选器还为客户端提供了其他筛选选项。选项的范围取决于过滤器的类型，这使得每个过滤器对于客户端来说都是强大且唯一的。</p><p id="b0da" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下面的请求显示了客户端如何使用提供的过滤器来指定查询。</p><p id="b29e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">例如，下面的变量/请求体可用于查询用户最喜欢的食物有<strong class="jm io"> <em class="ki">比萨饼或鸡翅—</em>—</strong>以及与<strong class="jm io"> <em class="ki"> jim 或 john 部分匹配的名称(regex)。</em>T19】</strong></p><p id="16c5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您可以在示例中看到各种查询选项。</p><pre class="kk kl km kn gt mc mb md me aw mf bi"><span id="ca0c" class="mg kw in mb b gy mh mi l mj mk">{<br/>  "getUsersInput": {<br/>    "favFoods": [<br/>      {<br/>        "arrayOptions": "IN",<br/>        "filterBy": "REGEX",<br/>        "string": ["pizza"],<br/>        "operator": "OR",<br/>        "groups": ["favFoodsGroup.and"]<br/>      },<br/>      {<br/>        "arrayOptions": "IN",<br/>        "filterBy": "REGEX",<br/>        "string": ["wings"],<br/>        "operator": "OR",<br/>        "groups": ["favFoodsGroup.and"]<br/>      }<br/>    ],<br/>    "name": [<br/>      {<br/>        "filterBy": "REGEX",<br/>        "operator": "OR",<br/>        "string": "jim",<br/>        "groups": ["namesGroup.or"]<br/>      },<br/>      {<br/>        "filterBy": "REGEX",<br/>        "operator": "OR",<br/>        "string": "john",<br/>        "groups": ["namesGroup.or"]<br/>      }<br/>    ]<br/>  }<br/>}</span></pre><p id="3120" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ly lz ma mb b">arrayOptions</code>、<code class="fe ly lz ma mb b">filterBy</code>、<code class="fe ly lz ma mb b">operator</code>和<code class="fe ly lz ma mb b">groups</code>都是我们上面应用的字段过滤类型自动提供的选项。</p><h1 id="dd0b" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">转换请求 GenerateMongo 函数</h1><p id="7c57" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">类型化允许您轻松地扩展过滤选项，并为客户端标准化查询，但除了形成预期的请求之外，别无他用。这就是所提供的方法有用的地方。</p><p id="31b0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">由于类型应该符合特定的形状，我们可以对数据做更多的事情，包括使用<code class="fe ly lz ma mb b">GenerateMongo</code>方法将字段过滤器转换成 MongoDB 过滤器。</p><p id="e32a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">只需将请求体或 graphql 输入传递给<code class="fe ly lz ma mb b">GenerateMongo</code>方法，解析嵌套字段过滤器的请求对象，这些过滤器作为 MongoDB 过滤器返回。</p><pre class="kk kl km kn gt mc mb md me aw mf bi"><span id="b60a" class="mg kw in mb b gy mh mi l mj mk">const {filter, options} = GenerateMongo({<br/>    fieldFilters: args.getUsersInput <br/>  });</span></pre><p id="c01e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果您对我们上面的查询中解析的<code class="fe ly lz ma mb b">filter</code>对象感兴趣，请查看一下！</p><pre class="kk kl km kn gt mc mb md me aw mf bi"><span id="4220" class="mg kw in mb b gy mh mi l mj mk">{<br/>  "$or": [<br/>    {<br/>      "$or": [<br/>        {<br/>          "name": {...}<br/>        },<br/>        {<br/>          "name": {...}<br/>        }<br/>      ]<br/>    }<br/>  ],<br/>  "$and": [<br/>    {<br/>      "$or": [<br/>        {<br/>          "favFoods": {<br/>            "$in": [{...}]<br/>          }<br/>        },<br/>        {<br/>          "favFoods": {<br/>            "$in": [{...}]<br/>          }<br/>        }<br/>      ]<br/>    }<br/>  ]<br/>}</span></pre><p id="6fde" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">把<code class="fe ly lz ma mb b">filter</code>对象传给 Mongo 就这样！</p><pre class="kk kl km kn gt mc mb md me aw mf bi"><span id="8c28" class="mg kw in mb b gy mh mi l mj mk">const users = User.find(filter);</span></pre><p id="f8c1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">或者，将它传递给同样提供的 Find 和 Paginate 方法。查看文档了解更多相关信息！</p><h1 id="b9b7" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">0.3.0 版的功能</h1><p id="e7fb" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">嘿，谢谢你坚持到现在！我希望您可以看到 MFG 库可以帮助标准化和扩展使用 Mongoose 的 API 的客户端过滤选项！除了使客户机请求过滤数据标准化之外，该库还处理将请求转换成 Mongo 过滤器的繁重工作。</p><p id="60d2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">版本 0.3.0 刚刚推出，包含了一些新特性，允许客户端在查询 API 时拥有更大的能力。</p><h2 id="d35f" class="mg kw in bd kx mm mn dn lb mo mp dp lf jv mq mr lj jz ms mt ln kd mu mv lr mw bi translated">字段过滤运算符</h2><p id="afd8" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">像<code class="fe ly lz ma mb b">and</code>和<code class="fe ly lz ma mb b">or</code>这样的操作符已经从过滤器配置转移到现场过滤器本身。这允许每个过滤器选择它是否应该作为一个<code class="fe ly lz ma mb b">$and</code>操作在查询中被要求，或者对于一个<code class="fe ly lz ma mb b">$or</code>操作是可选的。</p><h2 id="43b8" class="mg kw in bd kx mm mn dn lb mo mp dp lf jv mq mr lj jz ms mt ln kd mu mv lr mw bi translated">日期字段过滤器</h2><p id="4060" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">新的日期字段筛选器允许您搜索符合日期限制的文档。</p><pre class="kk kl km kn gt mc mb md me aw mf bi"><span id="a0dc" class="mg kw in mb b gy mh mi l mj mk">type DateFieldFilter = {<br/>  date: Date;<br/>  filterBy: 'EQ' | 'NE' | 'LT' | 'GT' | 'LTE' | 'GTE';<br/>  operator?: 'AND' | 'OR';<br/>  groups?: string[];<br/>};</span></pre><h2 id="8785" class="mg kw in bd kx mm mn dn lb mo mp dp lf jv mq mr lj jz ms mt ln kd mu mv lr mw bi translated">组</h2><p id="4ec9" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">字段过滤器中的<code class="fe ly lz ma mb b">groups</code>属性允许客户端混合匹配条件和操作符，以进行更广泛的过滤。</p><p id="32bb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有了组，我们现在可以在<code class="fe ly lz ma mb b">and/or</code>组中组合属性，就像这样…</p><p id="e2e3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们可以找到这样的用户:</p><p id="4fdf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ly lz ma mb b">(name === 'Nick' || age === 22) &amp;&amp; (married === false &amp;&amp; favoriteFood === "Pizza")</code></p><p id="5198" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">注意分组——姓名和年龄现在组合在一个<code class="fe ly lz ma mb b">or</code>组中，而已婚和<code class="fe ly lz ma mb b">favoriteFoods</code>在一个<code class="fe ly lz ma mb b">and</code>组中。</p><p id="2983" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，客户端可以指定这些自定义分组，您不再需要编写自定义代码来处理客户端可能请求的各种选项。</p><p id="de43" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您可以对每个查询应用任意多个组，因为您可以为每个组选择自定义名称。这意味着您可以编写一个字段筛选器并将其应用于多个组。</p></div><div class="ab cl mx my hr mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="ig ih ii ij ik"><p id="98e0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个库非常有用！我非常兴奋能够有方法将过滤功能扩展到客户端，同时保持简单易用的服务器端代码。</p><p id="cda8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你喜欢它的发展方向，请随意查看这个库，用 GitHub 注册表中的 NPM 安装它，并告诉我你的想法。下面是链接！</p><div class="ne nf gp gr ng nh"><a href="https://github.com/The-Devoyage/mongo-filter-generator/packages/1228449" rel="noopener  ugc nofollow" target="_blank"><div class="ni ab fo"><div class="nj ab nk cl cj nl"><h2 class="bd io gy z fp nm fr fs nn fu fw im bi translated">软件包 mongo-filter-generator</h2><div class="no l"><h3 class="bd b gy z fp nm fr fs nn fu fw dk translated">使用 Typescript 和 GraphQL 类型为 Mongoose 查找、过滤和分页插件。-mongo-filter-generator 包…</h3></div><div class="np l"><p class="bd b dl z fp nm fr fs nn fu fw dk translated">github.com</p></div></div><div class="nq l"><div class="nr l ns nt nu nq nv kt nh"/></div></div></a></div><p id="d66d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你想支持我在这个项目中添加更多的功能，请随时在这里的评论中或 Github 中提出请求。</p><p id="f303" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">感谢您的入住！希望这有助于塑造你的下一个 API！</p></div></div>    
</body>
</html>