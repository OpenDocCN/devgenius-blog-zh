<html>
<head>
<title>Stack Patterns</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">堆叠模式</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/stack-patterns-99d7e4953f62?source=collection_archive---------0-----------------------#2021-03-10">https://blog.devgenius.io/stack-patterns-99d7e4953f62?source=collection_archive---------0-----------------------#2021-03-10</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/255b8838dd4670ea0f89bc23d9461a47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xXFV4g7j2ER7VPWTb2LkYw.png"/></div></div></figure></div><div class="ab cl jv jw hr jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="ig ih ii ij ik"><p id="d11e" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">在处理算法问题时，我们应该更多地关注问题之间的相似性。如果我们能找到这些相似之处，那么解决那类问题就变得非常容易了。今天我们将讨论堆栈中的模式。</p><p id="bea8" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">有了这个模式，我们可以解决很多基于栈的问题。我们甚至可以解决流行的<a class="ae la" href="https://www.geeksforgeeks.org/the-stock-span-problem/" rel="noopener ugc nofollow" target="_blank"> <strong class="ke io">股票跨度</strong> </a>和<a class="ae la" href="https://leetcode.com/problems/largest-rectangle-in-histogram/" rel="noopener ugc nofollow" target="_blank"> <strong class="ke io">直方图最大面积</strong> </a>的问题。</p><h1 id="f16e" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak">接近</strong></h1><p id="63b7" class="pw-post-body-paragraph kc kd in ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ig bi translated">让我们来看看<strong class="ke io">下一个更大的元素</strong>问题。这里我们必须找到数组中每个数字的下一个更大的元素。我们将使用堆栈来存储更大的元素。我们将向后遍历数组。</p><p id="428a" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">算法:</p><ol class=""><li id="4197" class="me mf in ke b kf kg kj kk kn mg kr mh kv mi kz mj mk ml mm bi translated">将数组的最后一个元素压入堆栈</li><li id="011b" class="me mf in ke b kf mn kj mo kn mp kr mq kv mr kz mj mk ml mm bi translated">对于所有其他元素，重复以下过程</li></ol><p id="c485" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">—检查堆栈是否为空，如果是，则在该索引处放-1。即。该数字没有比其右侧更大的元素。<br/> —如果堆栈的 peek 大于当前元素，则堆栈 peek 是下一个更大的元素。</p><p id="280f" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">—如果没有，继续弹出堆栈的顶部，直到找到一个大于当前元素的元素</p><p id="52ff" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">—如果现在堆栈为空，则将-1 放在该索引处(没有更大的元素)</p><p id="102d" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">—否则堆栈的 peek 是更大的元素</p><p id="5965" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">—推入堆栈中的当前元素</p><p id="ede7" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">算法在这里可以理解。</p><figure class="mt mu mv mw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ms"><img src="../Images/75e7468f4496f5c6732e6ef9e7d7cf0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*ZhULRGR14L1vd01OWSQtHg.gif"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">下一个更大元素的算法的预演</figcaption></figure><p id="7ef3" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">现在你已经理解了如何解决这个问题，你可以自己想象其他相关的问题了。</p><p id="362c" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">如果我们遵循这种方法，只需稍加修改，就可以轻松解决<strong class="ke io">下一个较小元素</strong>、<strong class="ke io">上一个较大元素</strong>和<strong class="ke io">上一个较小元素</strong>的问题。</p><p id="b2eb" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">下面给出了所有四个问题和 java 代码。</p><p id="93cc" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated"><strong class="ke io">下一个更大的元素</strong></p><figure class="mt mu mv mw gt jo"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="7e1a" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated"><strong class="ke io">下一个更小的元素</strong></p><figure class="mt mu mv mw gt jo"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="1305" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated"><strong class="ke io">先前更大的元素</strong></p><figure class="mt mu mv mw gt jo"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="656f" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated"><strong class="ke io">先前较小的元素</strong></p><figure class="mt mu mv mw gt jo"><div class="bz fp l di"><div class="nb nc l"/></div></figure></div><div class="ab cl jv jw hr jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="ig ih ii ij ik"><p id="77b4" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">自己尝试这些问题。</p><ol class=""><li id="16bd" class="me mf in ke b kf kg kj kk kn mg kr mh kv mi kz mj mk ml mm bi translated"><a class="ae la" href="https://www.interviewbit.com/problems/nearest-smaller-element/" rel="noopener ugc nofollow" target="_blank">前一个最小元素</a></li><li id="30c4" class="me mf in ke b kf mn kj mo kn mp kr mq kv mr kz mj mk ml mm bi translated"><a class="ae la" href="https://leetcode.com/problems/132-pattern/" rel="noopener ugc nofollow" target="_blank">先前较大的元素变化</a></li><li id="acaf" class="me mf in ke b kf mn kj mo kn mp kr mq kv mr kz mj mk ml mm bi translated"><a class="ae la" href="https://www.geeksforgeeks.org/find-the-nearest-smaller-numbers-on-left-side-in-an-array/" rel="noopener ugc nofollow" target="_blank">数组左边最小的</a></li></ol><p id="b3cf" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">4.<a class="ae la" href="https://www.geeksforgeeks.org/next-greater-element/" rel="noopener ugc nofollow" target="_blank">下一个更大的元素</a></p><p id="9aa6" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">5.<a class="ae la" href="https://www.geeksforgeeks.org/next-smaller-element/" rel="noopener ugc nofollow" target="_blank">下一个更小的元素</a></p><p id="9c0e" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">6.<a class="ae la" href="https://www.geeksforgeeks.org/previous-greater-element/" rel="noopener ugc nofollow" target="_blank">先前更大的元素</a></p></div><div class="ab cl jv jw hr jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="ig ih ii ij ik"><p id="0614" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">在我们以后的教程中，我们会尝试扩展这个问题，用这个模式解决更多的问题。你可以自己尝试以下问题。</p><ol class=""><li id="5c77" class="me mf in ke b kf kg kj kk kn mg kr mh kv mi kz mj mk ml mm bi translated"><a class="ae la" href="https://www.geeksforgeeks.org/the-stock-span-problem/" rel="noopener ugc nofollow" target="_blank">库存跨度问题</a></li><li id="c2d3" class="me mf in ke b kf mn kj mo kn mp kr mq kv mr kz mj mk ml mm bi translated"><a class="ae la" href="https://leetcode.com/problems/largest-rectangle-in-histogram/" rel="noopener ugc nofollow" target="_blank">最大面积直方图</a></li><li id="44b6" class="me mf in ke b kf mn kj mo kn mp kr mq kv mr kz mj mk ml mm bi translated"><a class="ae la" href="https://www.geeksforgeeks.org/maximum-size-rectangle-binary-sub-matrix-1s/" rel="noopener ugc nofollow" target="_blank">2D 直方图的最大面积</a></li></ol></div><div class="ab cl jv jw hr jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="ig ih ii ij ik"><p id="67f0" class="pw-post-body-paragraph kc kd in ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">代码可以在这里找到</p><div class="nd ne gp gr nf ng"><a href="https://github.com/sksaikia/LeetCode/tree/main/src/patterns/stack" rel="noopener  ugc nofollow" target="_blank"><div class="nh ab fo"><div class="ni ab nj cl cj nk"><h2 class="bd io gy z fp nl fr fs nm fu fw im bi translated">sksaikia/LeetCode</h2><div class="nn l"><h3 class="bd b gy z fp nl fr fs nm fu fw dk translated">在 GitHub 上创建一个帐户，为 sksaikia/LeetCode 开发做贡献。</h3></div><div class="no l"><p class="bd b dl z fp nl fr fs nm fu fw dk translated">github.com</p></div></div><div class="np l"><div class="nq l nr ns nt np nu jt ng"/></div></div></a></div></div></div>    
</body>
</html>