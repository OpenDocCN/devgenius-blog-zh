<html>
<head>
<title>Android: Solving the Pain Points of MVI Architecture in Practice</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android:在实践中解决 MVI 架构的痛点</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/android-solving-the-pain-points-of-mvi-architecture-in-practice-4971fa9ed9c0?source=collection_archive---------7-----------------------#2022-08-22">https://blog.devgenius.io/android-solving-the-pain-points-of-mvi-architecture-in-practice-4971fa9ed9c0?source=collection_archive---------7-----------------------#2022-08-22</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/f4107eb457f7831bc9ad8010f7009392.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Cq0ZV7sgKPnRK9Qh.jpg"/></div></div></figure><p id="7ba3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">通过这篇文章可以快速了解:</p><p id="ff96" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">1.为什么用 MVI，</p><p id="620a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">2.为什么最终考虑使用 SharedFlow 实现，</p><p id="e682" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">3.repeatOnLifecycle + SharedFlow 的思路实现 MVI。</p><h1 id="09de" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">为什么是 MVI</h1><p id="8816" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">MVI 是一个反应式模型，通过唯一的入口传入参数，从唯一的出口接收结果和完成响应。</p><p id="5bb4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">换句话说，通过在 MVI 模型中聚合状态，页面根据返回的结果统一完成 UI 呈现，确保</p><ul class=""><li id="ed71" class="lw lx in jx b jy jz kc kd kg ly kk lz ko ma ks mb mc md me bi translated">获得的状态总是最新的，并且来自可靠和唯一的来源</li><li id="f7cf" class="lw lx in jx b jy mf kc mg kg mh kk mi ko mj ks mb mc md me bi translated">消除可变的样板代码</li></ul><p id="1da4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">“消除样板代码”相信开发者都有体会。“获得的状态总是最新的，来源是可靠的和唯一的”，这是值得怀疑的，所以我们继续寻找。</p><h1 id="dbfc" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">MVI 原始理论模型</h1><p id="26f4" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">根据互联网上的 MVI 理论模型，经典 MVI 模型的伪代码示例如下:</p><figure class="mk ml mm mn gt jo"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="5e31" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们很容易发现，经典的 MVI 模型“牵一发而动全身”，即无论修改哪个 widget，所有控件都需要重新渲染状态。</p><p id="149f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这样在 Android View 系统下就有了额外的性能开销。当页面小部件的显示逻辑比较复杂或者需要频繁渲染时，很容易造成丢帧。</p><h1 id="3ad6" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">改进版本 1:使用数据绑定</h1><p id="816a" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">考虑到数据绑定 ObservableField 的去抖动特性，页面可以考虑 ObservableField 来完成状态的改变，以尽可能消除“小部件渲染”的性能开销。</p><figure class="mk ml mm mn gt jo"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="496b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是，以上只是免除渲染，观察回调中的逻辑还是要去的，</p><p id="8c70" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">开发人员需要有使用数据绑定的经验，另外还要编写数据绑定样板代码和 XML 绑定。</p><h1 id="b988" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">改进版本 2:使用密封类进行分流</h1><p id="81d6" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">根据业务场景，转移最初放置在数据类中的状态:</p><figure class="mk ml mm mn gt jo"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="6a53" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这样，这个业务场景的 UI 逻辑可以单独运行:</p><figure class="mk ml mm mn gt jo"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="d44a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">网上流行的例子，包括官方的例子，就在这里探讨和分享。</p><p id="edef" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但在实战中很容易发现，Replay 1 的模型如 BehaviorSubject、LiveData、StateFlow 都是理想化的“过度工程”产品，在生产环境中容易出现不可预知的问题。</p><p id="516a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">例如，当屏幕关闭时(页面生命周期离开开始)，replay 1 模型只保存最后一个，那么在 MVI 分流设计下，屏幕打开后(页面生命周期返回开始)，多种类型的消息只会推送最后一个，其余的全部丢失。</p><h1 id="73a3" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">改进版本 3:使用 SharedFlow 推送结果</h1><p id="31e5" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">SharedFlow 中有一个队列。如果希望在屏幕打开后自动推送多种类型的消息，可以将重播次数设置为与队列长度相同，比如 10。</p><figure class="mk ml mm mn gt jo"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="ee10" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">由于 replay 会按照设定的次数重播队列中的元素，所以当 replay 开始时，它会可视化地重播所有的，包括消耗的和未消耗的，也就是 widget 上的旧数据“闪现”，</p><p id="d6c8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这不是一次好的经历。</p><h1 id="a564" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">改进版本 4:通过计数防止重复推回</h1><p id="2ee7" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">所以这里可以加一个判断——如果已经消费了，下次重播就不消费了。</p><figure class="mk ml mm mn gt jo"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="bcd3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是每次创建页面都需要这样写，是不是不舒服，</p><p id="ec2c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，它可以内聚，并统一提取到一个单独的框架中进行维护。</p><p id="17fb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">MVI-调度员-KTX 应运而生。</p><h1 id="1c80" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">改进版本 5:MVI 样板逻辑的内聚性</h1><p id="9add" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">如下，通过内聚样板逻辑，如 repeatOnLifecycle、计数比较、可变/不可变等。</p><figure class="mk ml mm mn gt jo"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="7430" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这样，即使开发者不熟悉 MVI 和 mutable，也可以通过专注于“输入-输出”来自动完成“单向数据流”的开发。</p><figure class="mk ml mm mn gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mq"><img src="../Images/4f47e3219a2a244e6b7211ecb281ed04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9gn1phRCAI3C62H78vmOlQ.jpeg"/></div></div></figure><h1 id="b52c" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">改进版本 6:添加版本以防止订阅推迟</h1><p id="5a3c" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">在分析了大量样本后，我们很容易知道，在敏捷开发的过程中，实际高频的问题就是“消息分发一致性问题”。</p><p id="eff5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">与其刻意区分状态和事件这两个理论概念，不如将两者合二为一，升级为“消费且只消费一次”这种简洁易懂的线上模型。</p><p id="ee38" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，这里可以添加一个 verison 比较。</p><figure class="mk ml mm mn gt jo"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="2590" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这样可以实现“多观察者消费，每个观察者只消费一次”，并且可以解决页面初始化或屏幕对屏幕场景中的“流缺失集合”而不会导致意外错误:</p><p id="05f1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对于 UI 事件，比如对话框弹出、toast 弹出和页面跳转，可以使用这个模型，</p><p id="9dfa" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对于 UI 状态，如进度呈现、btnChecked 呈现，也可以使用该模型，</p><p id="8134" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">状态可以通过 DataBinding ObservaField 或 Jetpack 进行动作和响应，在 Jetpack ViewModel 中构造可变状态和托管，整个过程如下:</p><pre class="mk ml mm mn gt mr ms mt mu aw mv bi"><span id="f48b" class="mw ku in ms b gy mx my l mz na">  UI Layer          Domain Layer         Data Layer<br/>unified Event  -&gt; Domain Dispatcher -&gt; Data Component<br/>UI State/Event &lt;- Domain Dispatcher &lt;- Data Component</span></pre><p id="f0c7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这样，当页面旋转和重建时，页面自动从 Jetpack ViewModel 获取 ObservaField/mutableState 绑定和呈现小部件，而不需要 replay 1 模型推回。</p><blockquote class="nb nc nd"><p id="9a42" class="jv jw ne jx b jy jz ka kb kc kd ke kf nf kh ki kj ng kl km kn nh kp kq kr ks ig bi translated"><em class="in"> SharedFlow 仅限于 Kotlin 项目。如果想在 Java 项目中使用，可以参考 MVI-Dispatcher 的设计，内部维护一个队列，通过 Mutable-Result 实现上述功能。</em></p></blockquote><h1 id="9e7d" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">概括起来</h1><p id="0961" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">理论模型都是为了解决特定环境下的特定问题。MVI 是一个理想化的理论模型，直接用于生产环境可能会滋生不可预测的问题，所以我们不断尝试、交流、反馈和更新。</p><p id="982d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">感谢那些愿意“实事求是”测试反馈和交流的人，MVI-调度员系统框架发展到今天。</p><p id="dbb8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Github:MVI 调度员</p><p id="4fbd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae ni" href="https://github.com/KunMinX/MVI-Dispatcher-KTX" rel="noopener ugc nofollow" target="_blank">Github:MVI-调度员-KTX </a></p></div></div>    
</body>
</html>