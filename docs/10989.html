<html>
<head>
<title>How can we manage Payload and Response without writing POJO class in Java with Rest-Assured?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">不放心用 Java 写 POJO 类，怎么管理 Payload 和 Response？</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-can-we-manage-payload-and-response-without-writing-pojo-class-in-java-with-rest-assured-8ce07217947c?source=collection_archive---------7-----------------------#2022-12-12">https://blog.devgenius.io/how-can-we-manage-payload-and-response-without-writing-pojo-class-in-java-with-rest-assured-8ce07217947c?source=collection_archive---------7-----------------------#2022-12-12</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/8d8aa8353b260f16028b5d43864ba146.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E6XZF55HQILdfYppSl30CA.png"/></div></div></figure><div class=""/><p id="6c86" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对于任何使用 Java 和放心的 API 测试自动化项目，我愿意分享我是如何处理有效载荷和响应的。</p><p id="64e9" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">提取响应数据最常见的方法是在开发 API 测试自动化项目时使用 POJO 类。然而，如果您使用放心(在本文的其余部分我将称之为 RA)来测试 API，那么就没有必要编写 POJO 类。相反，您可以利用 RA 特性。下面是 RA 可以用来实现这一点的一些特性。作为第一步，我们来讨论一下有效载荷</p><p id="ef48" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">以下列表中的任何对象都可以用作 RA 中的有效负载。</p><ul class=""><li id="aff6" class="kt ku iy jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated">线</li><li id="5533" class="kt ku iy jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">字节[]</li><li id="e963" class="kt ku iy jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">文件</li><li id="7091" class="kt ku iy jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">输入流</li><li id="5b5e" class="kt ku iy jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">目标</li></ul><p id="4fe6" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">换句话说，我们有许多选项来管理有效载荷，我通常遵循这种方法。</p><p id="aed9" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先，项目资源是存储有效载荷的好地方。</p><figure class="li lj lk ll gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi lh"><img src="../Images/34907a535459236fdfe595e2e504db75.png" data-original-src="https://miro.medium.com/v2/resize:fit:722/format:webp/1*yhkviiYG0H8IpFo3_kdNPA.png"/></div></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk translated">有效载荷</figcaption></figure><p id="3fcb" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">1-从资源中获取 JSON 作为字符串</p><p id="0c79" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下面是我通常用来获取字符串形式的文件内容的代码。它可以在 MAC 电脑、Linux 电脑或 Windows 电脑上无缝运行</p><pre class="li lj lk ll gt lq lr ls bn lt lu bi"><span id="c218" class="lv lw iy lr b be lx ly l lz ma">public String getFile(String fileName) {<br/>        var is = Objects.requireNonNull(<br/>                getClass()<br/>                        .getClassLoader()<br/>                        .getResourceAsStream("payloads/" + fileName));<br/>        try {<br/>            return new String(is.readAllBytes());<br/>        } catch (IOException e) {<br/>            throw new RuntimeException(String.format("An error occurred message:%s", e.getMessage()));<br/>        }<br/>    }</span></pre><p id="c17a" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">2- JsonPath 可用于根据需要更新 JSON</p><p id="7661" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这就是棘手的地方。在接收到字符串形式的有效载荷后，我们如何更新 JSON 字段呢？</p><p id="e29e" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">第一步是用 JSON 选择器(JSON path)读取 JSON 字段，为此，我们需要将 string 有效负载转换为 com.jayway.jsonpath 的 DocumentContext 对象。</p><pre class="li lj lk ll gt lq lr ls bn lt lu bi"><span id="92ca" class="lv lw iy lr b be lx ly l lz ma"> private DocumentContext getJsonDocumentContext(String json) {<br/>        var configuration = Configuration.builder()<br/>                .jsonProvider(new JacksonJsonNodeJsonProvider())<br/>                .mappingProvider(new JacksonMappingProvider())<br/>                .build();<br/>        return using(configuration).parse(json);<br/>    }</span></pre><p id="b7f7" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">通过使用 com . jayway . jsonpath . JSON path . read()，我们现在能够使用 JSON path 和作为 DocumentContext 的有效负载</p><p id="96e1" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因为所有的 JSON 字段都有一个类型，所以在更新 JSON 时，我们需要用正确的对象类型更新 JSON 字段，read()方法也以对象的形式返回值。</p><p id="94fd" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们可以根据对象推导出字段值的类型，然后更新 JSON 字段，以便在获得对象后反映有效的类型。</p><pre class="li lj lk ll gt lq lr ls bn lt lu bi"><span id="d40d" class="lv lw iy lr b be lx ly l lz ma">    public String updateJsonValue(String json, String jsonKey, Object newValue) {<br/>        DocumentContext context = getJsonDocumentContext(json);<br/>        ParseHelper parseHelper = new ParseHelper();<br/>        try {<br/>            var o = read(json, jsonKey);<br/>            var valueType = o.getClass().getSimpleName();<br/><br/>            switch (valueType) {<br/>                case "Integer" -&gt; {<br/>                    Integer integerValue = parseHelper.parsStringToInt(String.valueOf(newValue));<br/>                    if (integerValue != null)<br/>                        context.set(jsonKey, integerValue);<br/>                }<br/>                case "BigInteger" -&gt; {<br/>                    BigInteger bigInteger = parseHelper.parsStringToBigint((String) newValue);<br/>                    if (bigInteger != null)<br/>                        context.set(jsonKey, bigInteger);<br/>                }<br/>                case "Boolean" -&gt; {<br/>                    Boolean boolValue = parseHelper.parseStringToBoolean(String.valueOf(newValue));<br/>                    if (boolValue != null)<br/>                        context.set(jsonKey, boolValue);<br/>                }<br/>                case "Float" -&gt; {<br/>                    Float floatValue = parseHelper.parsStringToFloat(String.valueOf(newValue));<br/>                    if (floatValue != null)<br/>                        context.set(json, floatValue);<br/>                }<br/>                case "Double" -&gt; {<br/>                    Double doubleValue = parseHelper.parsStringToDouble(String.valueOf(newValue));<br/>                    if (doubleValue != null)<br/>                        context.set(jsonKey, doubleValue);<br/>                }<br/>                default -&gt; context.set(jsonKey, newValue);<br/>            }<br/>            return context.jsonString();<br/>        } catch (PathNotFoundException je) {<br/>            log.warn("{} is couldn't find, in JSON \n{}", jsonKey, json);<br/>            return json;<br/>        }<br/>    }</span></pre><p id="71fe" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这种情况下，我们现在有了更新的 JSON 的字符串表示。</p><p id="b4fb" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们用一个真实的场景来尝试一下</p><pre class="li lj lk ll gt lq lr ls bn lt lu bi"><span id="0613" class="lv lw iy lr b be lx ly l lz ma">-- payload<br/>{<br/>  "id": 0,<br/>  "category": {<br/>    "id": 0,<br/>    "name": "string"<br/>  },<br/>  "name": "doggie",<br/>  "photoUrls": [<br/>    "string"<br/>  ],<br/>  "tags": [<br/>    {<br/>      "id": 0,<br/>      "name": "string"<br/>    }<br/>  ],<br/>  "status": "available"<br/>}</span></pre><p id="71c5" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">既然我们已经创建了方法，我们将更新上面的 JSON。</p><pre class="li lj lk ll gt lq lr ls bn lt lu bi"><span id="bb0f" class="lv lw iy lr b be lx ly l lz ma"> @Test<br/> public void managingPayload(){<br/>        var fileHelper = new FileHelper();<br/><br/>        var payload = fileHelper.getFile("pet.json");<br/><br/>        var jsonHelper = new JSONHelper();<br/><br/>        payload = jsonHelper.updateJsonValue(payload,"id","10");<br/>        payload = jsonHelper.updateJsonValue(payload,"category.id","1");<br/>        payload = jsonHelper.updateJsonValue(payload,"photoUrls[0]","shorturl.at/rJXZ2");<br/>        payload = jsonHelper.updateJsonValue(payload,"tags[0].id","1");<br/>        payload = jsonHelper.updateJsonValue(payload,"tags[0].name","#dog");<br/>        payload = jsonHelper.updateJsonValue(payload,"status","sold");<br/><br/>        given()<br/>                .basePath("{version}/pet")<br/>                .pathParam("version","v2")<br/>                .contentType(ContentType.JSON)<br/>                .body(payload)<br/>        .when()<br/>                .post()<br/>        .then()<br/>                .statusCode(200)<br/>                .body("id",equalTo(10))<br/>                .body("category.id",equalTo(1))<br/>                .body("photoUrls[0]",equalTo("shorturl.at/rJXZ2"))<br/>                .body("tags[0].id",equalTo(1))<br/>                .body("tags[0].name",equalTo("#dog"))<br/>                .body("status",equalTo("sold"));<br/>  }</span></pre><p id="b09f" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下面的代码演示了如何在不创建 POJO 类的情况下提取响应，这样我们就可以将 JSON 转换成 map 对象，以便在合适的时候使用。</p><pre class="li lj lk ll gt lq lr ls bn lt lu bi"><span id="5759" class="lv lw iy lr b be lx ly l lz ma"> var responseMap = given()<br/>                .basePath("{version}/pet")<br/>                .pathParam("version", "v2")<br/>                .contentType(ContentType.JSON)<br/>                .body(payload)<br/>                .when()<br/>                .post()<br/>                .as(new TypeRef&lt;Map&lt;String, Object&gt;&gt;() {<br/>                });<br/>  assertEquals(responseMap.get("id"), 1);<br/>  assertEquals(((Map&lt;String, Object&gt;) responseMap.get("category")).get("id"), 2);</span></pre><p id="977f" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是如果 response 是 JSONArray 呢？</p><pre class="li lj lk ll gt lq lr ls bn lt lu bi"><span id="2fa5" class="lv lw iy lr b be lx ly l lz ma"> var responseMap = given()<br/>                .basePath("{version}/pet")<br/>                .pathParam("version", "v2")<br/>                .contentType(ContentType.JSON)<br/>                .body(payload)<br/>                .when()<br/>                .post()<br/>                .as(new TypeRef&lt;List&lt;Map&lt;String, Object&gt;&gt;&gt;() {<br/>                });</span></pre><p id="6251" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们还可以获得所需类型的响应字段</p><pre class="li lj lk ll gt lq lr ls bn lt lu bi"><span id="6874" class="lv lw iy lr b be lx ly l lz ma">var tagId = response.jsonPath().getInt("tags[0].id");<br/>assertEquals(tagId,2);</span></pre><p id="fe05" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">要访问 git repo，请查看以下链接。</p><div class="im in gp gr io mb"><a href="https://github.com/serhatozdursun/payload_and_responses" rel="noopener  ugc nofollow" target="_blank"><div class="mc ab fo"><div class="md ab me cl cj mf"><h2 class="bd iz gy z fp mg fr fs mh fu fw ix bi translated">GitHub-serhatozdursun/payload _ and _ response</h2><div class="mi l"><h3 class="bd b gy z fp mg fr fs mh fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="mj l"><p class="bd b dl z fp mg fr fs mh fu fw dk translated">github.com</p></div></div><div class="mk l"><div class="ml l mm mn mo mk mp iu mb"/></div></div></a></div><p id="8390" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">总之，我想说的是不要总是一成不变。大多数情况下，做任何事情都有比其他方法更好的方法。</p><p id="3223" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">希望这篇文章能帮助你们中的一些人给自己的项目增加更多的价值。</p></div></div>    
</body>
</html>