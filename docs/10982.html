<html>
<head>
<title>Excelling at dbt: Jinja &amp; Macros for modular and cleaner SQL Queries — Part 2/2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">擅长 dbt: Jinja 和宏，用于模块化和更简洁的 SQL 查询—第 2/2 部分</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/excelling-at-dbt-jinja-macros-for-modular-and-cleaner-sql-queries-part-2-2-88949c1af46c?source=collection_archive---------0-----------------------#2022-12-12">https://blog.devgenius.io/excelling-at-dbt-jinja-macros-for-modular-and-cleaner-sql-queries-part-2-2-88949c1af46c?source=collection_archive---------0-----------------------#2022-12-12</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="9574" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">了解控制结构和宏</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/6447055ce2d8142244c3dec24893d75b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7UT1tvK_lZN5TugFRhsBlQ.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">图片来自 Unsplash，作者 Shahadat Rahman</figcaption></figure><p id="cd89" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">这是理解如何利用 Jinja 和宏编写更好的 SQL 查询的系列文章的第二篇。<a class="ae lo" href="https://medium.com/@baluramachandra90/excelling-at-dbt-jinja-macros-for-modular-and-cleaner-sql-queries-part-1-2-55e29d4b29e2" rel="noopener">在之前的帖子</a>中，我们讨论了 Jinja 中的一些基本构建块如分隔符、变量、列表、字典、过滤器等。在这篇文章中，我们将进一步加强我们对控制结构和宏的了解。提醒一下，在这篇文章中，你会看到一些使用足球统计数据集的 SQL 示例，请<a class="ae lo" href="https://medium.com/@baluramachandra90/extract-and-load-football-statistics-to-google-cloud-storage-bigquery-with-airflow-1a217227dbd1" rel="noopener">下载数据集</a>并<a class="ae lo" href="https://docs.getdbt.com/docs/get-started/installation" rel="noopener ugc nofollow" target="_blank">安装数据库</a> t。</p></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><h2 id="29f1" class="lw lx in bd ly lz ma dn mb mc md dp me lb mf mg mh lf mi mj mk lj ml mm mn mo bi translated">控制结构</h2><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mp"><img src="../Images/857fdee079b711f5b0b014c3a7b2e8de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pv9u8s-1CI1hgegPnN23bA.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">图片来自 Jordan Ladikos 的 Unsplash</figcaption></figure><p id="10f2" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">在 Jinja 中，控制结构使我们能够控制代码/程序执行的流程。它允许我们用<code class="fe mq mr ms mt b">conditions</code>和<code class="fe mq mr ms mt b">loops</code>组合 SQL 代码。控制结构出现在<code class="fe mq mr ms mt b">{% ... %}</code>块中。有了控制结构，我们可以创建更多的动态查询，避免大量的代码重复。</p><h2 id="69ae" class="lw lx in bd ly lz ma dn mb mc md dp me lb mf mg mh lf mi mj mk lj ml mm mn mo bi translated">条件语句</h2><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mu"><img src="../Images/59e68eb93637296a20ff1e6809e321ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZMai0Zyx0sTh-N7z-i4KXw.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">图片来自 ictshore</figcaption></figure><p id="a492" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">为了让条件语句(<code class="fe mq mr ms mt b">if/else</code>)起作用，需要一个开始<code class="fe mq mr ms mt b">{% if %}</code>标签和一个结束<code class="fe mq mr ms mt b">{% endif %}</code>标签。我们在开始标记中定义我们的条件，然后在满足条件时执行查询。请参见下面的示例。</p><pre class="kd ke kf kg gt mv mt mw bn mx my bi"><span id="d054" class="mz lx in mt b be na nb l nc nd"># Set the condition parameter as a variable<br/>{% set football_club = 'Valencia' %}<br/><br/># Define the condition in the opening block<br/>{% if football_club == 'Valencia' %}<br/>    It's a Spanish Football Club<br/>{% else %}<br/>    It's not a Spanish Football Club<br/>{% endif %}<br/><br/>Output:<br/>--&gt; It's a Spanish Football Club</span></pre><p id="7793" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">现在，让我们把 SQL 和条件语句结合起来。在下面的例子中，不是调整整个查询，我们可以通过调整参数<code class="fe mq mr ms mt b">wins</code>的值，简单地获取由特定条件参数化的记录。如果<code class="fe mq mr ms mt b">wins</code>参数等于<code class="fe mq mr ms mt b">Home</code>，则满足 if 条件(<code class="fe mq mr ms mt b">True</code>)。当它评估为<code class="fe mq mr ms mt b">True</code>时，查询将获取主队在他们的场地上赢得比赛的记录。但如果不是，将触发<code class="fe mq mr ms mt b">else</code>条款，并获取客场球队在对手场地获胜的记录。</p><pre class="kd ke kf kg gt mv mt mw bn mx my bi"><span id="1d0d" class="mz lx in mt b be na nb l nc nd">--Set the condition parameter as a variable<br/>{% set wins = 'Home' %}<br/><br/>--This query tries to fetch records based on team status (Home or Away)<br/>select *<br/>from {{ source('staging', 'english-premier-league-table') }}<br/>{% if wins == 'Home' %}<br/>    where FTR = 'H'<br/>{% else %}<br/>    where FTR = 'A'<br/>{% endif %}</span></pre><p id="0eaa" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">为了增加复杂性和灵活性，您还可以在条件语句中添加<code class="fe mq mr ms mt b">{% elif %}</code>子句。这将为您提供一个选项，在退回到默认的<code class="fe mq mr ms mt b">{% else %}</code>子句之前询问更多的条件。</p><h2 id="9658" class="lw lx in bd ly lz ma dn mb mc md dp me lb mf mg mh lf mi mj mk lj ml mm mn mo bi translated">For 循环</h2><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ne"><img src="../Images/3b2aca5701db84d39b093ebfc3eda82f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0O7VNtg__LIHgU8QjcR-Rg.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">图片来自 Tite Ivanic 的 Unsplash</figcaption></figure><p id="eb32" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">我们使用 for-loop 迭代一系列项目，例如显示一个名为<code class="fe mq mr ms mt b">payment_methods</code>的列表中提供的支付方式列表。我们可以用与条件语句(<code class="fe mq mr ms mt b">if/else</code>)完全相同的方式在 Jinja 中创建 for 循环，条件语句在<code class="fe mq mr ms mt b">{%...%}</code>块中。</p><p id="7067" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">要创建一个 for 循环，需要有开始<code class="fe mq mr ms mt b">{% for %}</code>和结束<code class="fe mq mr ms mt b">{% endfor %}</code>标签。在下面的例子中，我循环遍历一个字典，并像我们通常在 Python 中那样列出。</p><pre class="kd ke kf kg gt mv mt mw bn mx my bi"><span id="8460" class="mz lx in mt b be na nb l nc nd"># An example of using for-loop to iterate over a dictionary.<br/>{% set favorite_player = {'lazio':'alessandro nesta',<br/>                          'dortmund':'tomáš rosický',<br/>                          'lyon':'juninho pernambucano',<br/>                          'valencia':'pablo aimar',<br/>                          'man united':'paul scholes'<br/>                       }<br/> <br/>%}<br/><br/># Loop over favorite player dictionary and convert each key and value to uppercase letter.<br/>{% for club, player in favorite_player.items() %}<br/>My favorite football player from {{ club | title() }} is {{ player | title() }}<br/>{% endfor %}<br/><br/>Output:<br/>--&gt; My favorite football player from Lazio is Alessandro Nesta<br/>--&gt; My favorite football player from Dortmund is Tomáš Rosický<br/>--&gt; My favorite football player from Lyon is Juninho Pernambucano<br/>--&gt; My favorite football player from Valencia is Pablo Aimar<br/>--&gt; My favorite football player from Man United is Paul Scholes<br/><br/>-----------------------------------------------------------------------------<br/># An example of using for-loop with conditional statement to iterate over a list.<br/>{% set items = ['Dog','Cat','Bird', 'Carrot'] %}<br/><br/># Loop over the list and print the output based on the specified conditions.<br/>{% for item in items %}<br/>    {% if item == 'Carrot' %}<br/>        {% set item_type = 'vegetable' %}<br/>    {% else %}<br/>        {% set item_type = 'animal' %}<br/>    {% endif %}<br/><br/>    {{ item }} is {{ item_type }}<br/><br/>{% endfor %}</span></pre><p id="f02e" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">让我们举一个例子来说明如何在 Jinja 的 SQL 中使用 for-loop。以下查询的目的是计算 2016-2019 赛季 3 个足球俱乐部的主场胜率(以透视表格式)。如果您希望添加另一个俱乐部/物品，您可以简单地将其添加到<code class="fe mq mr ms mt b">football_clubs</code>列表中。如果没有 Jinja 和 for-loop，我们将有 3 行<code class="fe mq mr ms mt b">case when</code>语句用于这 3 个不同的俱乐部。想象一下，如果我们有 10 个甚至 20 个俱乐部/项目，那么我们的查询会非常长，可读性差，难以维护。这就是金佳来拯救我们的地方。</p><pre class="kd ke kf kg gt mv mt mw bn mx my bi"><span id="1298" class="mz lx in mt b be na nb l nc nd">-- List to iterate over, you can add more clubs/items in the list.<br/>{% set football_clubs = ['Man United','Liverpool', 'Man City'] %}<br/><br/>-- Loop over the list and use conditional statement to ensure there isn't a trailing comma at end of the loop.<br/>select<br/>    season, <br/>    {% for club in football_clubs %}<br/>    round((sum(case when HomeTeam = '{{ club }}' and FTR = 'H' then 1 else 0 end) / sum(case when HomeTeam = '{{ club }}' then 1 else 0 end)),2) * 100 as {{ club | replace(' ', '')}}_home_win_pct<br/>    {% if not loop.last %}, {% endif %}<br/>    {% endfor %}<br/>from {{ source('staging', 'english-premier-league-table') }}<br/>where season in ('season-1819','season-1718','season-1617')<br/>group by season<br/>order by season desc<br/><br/>Output:<br/><br/>| season      | ManUnited_home_win_pct | Liverpool_home_win_pct | ManCity_home_win_pct |<br/>|-------------|------------------------|------------------------|----------------------|<br/>| season-1819 | 53                     | 89                     | 95                   |<br/>| season-1718 | 79                     | 63                     | 84                   |<br/>| season-1617 | 42                     | 63                     | 58                   |</span></pre><p id="a906" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">你可能注意到我在上面的例子中使用了<code class="fe mq mr ms mt b">{% if not loop.last %}, {% endif %}</code>。这是一个条件语句，我用它来确保循环末尾没有尾随逗号，这会中断查询。</p><p id="9bff" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">下面是另一个更复杂的 for-loop 和 if/else 计算 2018/19 赛季各俱乐部总积分(<code class="fe mq mr ms mt b">football_clubs</code>)的例子。<a class="ae lo" href="https://datahub.io/sports-data/english-premier-league#resource-season-1819" rel="noopener ugc nofollow" target="_blank">数据集是“旋转的”格式</a>，所以我需要先将它分成每个俱乐部的主场和客场统计数据，然后再将它们组合起来(垂直)计算总积分(主场+客场)。</p><pre class="kd ke kf kg gt mv mt mw bn mx my bi"><span id="6f0a" class="mz lx in mt b be na nb l nc nd">-- A for-loop that first breaks the datasets and unions them back to calculate total points received<br/>{%- set football_clubs = ['Man United','Liverpool','Man City'] -%}<br/>{%- set status = ['HomeTeam','AwayTeam'] -%}<br/><br/>with summary as (<br/>{% for club in football_clubs -%}<br/>    {% for st in status -%}<br/>    select <br/>        {{ st }} as team,<br/>        {% if st == 'HomeTeam' -%}<br/>                case <br/>                    when FTR = 'H' then 3<br/>                    when FTR = 'D' then 1<br/>                    else 0 end points<br/>        {% else -%}<br/>                case <br/>                    when FTR = 'A' then 3<br/>                    when FTR = 'D' then 1<br/>                    else 0 end points<br/>        {% endif -%}<br/>    from {{ source('staging', 'english-premier-league-table') }}<br/>    where season = 'season-1819'<br/>        and {{ st }} = '{{ club }}'<br/>        {% if not loop.last %} union all {% endif %}<br/>    {% endfor -%}<br/>    {% if not loop.last %} union all {% endif %}<br/>{% endfor -%}<br/>)<br/><br/>-- Calculate the points (aggregation)<br/>select <br/>    team, <br/>    sum(points) as total_points<br/>from summary<br/>group by team<br/>order by total_points desc<br/><br/>Output:<br/><br/>| team       | total_points |<br/>|------------|--------------|<br/>| Man City   | 98           |<br/>| Liverpool  | 97           |<br/>| Man United | 66           |</span></pre><h2 id="ed5e" class="lw lx in bd ly lz ma dn mb mc md dp me lb mf mg mh lf mi mj mk lj ml mm mn mo bi translated">宏指令</h2><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nf"><img src="../Images/8fd3be199ef59fded64fbcd79f9a5d00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I9u5aaZtCOYiI9W49LZD9g.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">图片来自 Unsplash，作者 Danil Shostak</figcaption></figure><p id="17fa" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">对于那些有过使用 VBA (Visual Basic for Application)经验的人来说，宏可能并不陌生。我们在 VBA 使用宏，通过在函数中自动处理来加速手工任务。宏类似于 Python 和 Javascript 等其他编程语言中的函数。</p><p id="8f40" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">我们使用宏来使我们的代码变得干巴巴的(不要重复自己)，这意味着模块化和可重用。使用宏也会提高我们的开发速度。金贾的一个特点就是宏。要定义宏，您需要具备以下组件:</p><ul class=""><li id="f3f4" class="ng nh in ku b kv kw ky kz lb ni lf nj lj nk ln nl nm nn no bi translated">开始标签<code class="fe mq mr ms mt b">{% macro %}</code>和结束标签<code class="fe mq mr ms mt b">{% endmacro %}</code></li><li id="71d1" class="ng nh in ku b kv np ky nq lb nr lf ns lj nt ln nl nm nn no bi translated">宏的名字(在开始标签中)后面跟着一个圆括号<code class="fe mq mr ms mt b">()</code>，你将在这里放置你的参数。</li><li id="b8ac" class="ng nh in ku b kv np ky nq lb nr lf ns lj nt ln nl nm nn no bi translated">开始和结束标记内部/之间的实际代码(逻辑)。</li></ul><p id="32be" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">在 dbt 中，您可以在 sql 文件中定义宏，并将其放在 macros 目录中。以下示例显示了一个宏，该宏标准化了<code class="fe mq mr ms mt b">Date</code>列中的日期格式(值)。在这个例子中，我创建了一个名为<code class="fe mq mr ms mt b">new_date_format</code>的宏。</p><p id="5c9f" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">如果您继续操作，您应该会看到<code class="fe mq mr ms mt b">english-premier-league-table</code>表中的<code class="fe mq mr ms mt b">Date</code>列有多种日期格式(11/08/2018，2018–08–20&amp;29/12/12)。我们需要标准化格式，以便<code class="fe mq mr ms mt b">Date</code>列可以正确地用于下游分析。一旦定义了宏，就可以在查询中使用它，方法是在<code class="fe mq mr ms mt b">{{...}}</code>表达式块中调用它(指定宏名)。</p><pre class="kd ke kf kg gt mv mt mw bn mx my bi"><span id="0ee9" class="mz lx in mt b be na nb l nc nd">-- Macro to standardize date format with BigQuery SQL --&gt; new_date_format.sql<br/>{% macro new_date_format(dt) %}<br/>coalesce(safe.parse_date('%Y-%m-%d', {{ dt }}), <br/>          safe.parse_date('%d/%m/%y', {{ dt }}), <br/>          safe.parse_date('%d/%m/%Y', {{ dt }}))<br/>{% endmacro %}<br/><br/>-- Call the macro inside the SQL query<br/>select <br/>    HomeTeam, <br/>    Date as old_date_format,<br/>    {{ new_date_format('Date') }} as new_date_format<br/>from {{ source('staging', 'english-premier-league-table') }}<br/>where season = 'season-1819'<br/><br/>Output:<br/><br/>| HomeTeam     | old_match_date | new_match_date |<br/>|--------------|----------------|----------------|<br/>| Fulham       | 11/08/2018     | 2018-08-11     |<br/>| Huddersfield | 29/12/12       | 2012-12-29     |<br/>| Arsenal      | 20/08/2018     | 2018-08-20     |</span></pre><p id="a5bb" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">但是，您可能会想，为什么只为那个单一的任务创建宏呢？难道它不是为了解决多个类似的问题而被重用的吗？是的，我明白你的意思。在我的模式中，有 5 个表(如下)有类似的问题，在这种情况下，我可以将<code class="fe mq mr ms mt b">new_date_format</code>宏应用到这些表中的每个<code class="fe mq mr ms mt b">Date</code>列，以标准化日期格式。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/ba7916068db13b8f8c0caad61f6bf7fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:936/format:webp/1*AvvVaSl5c6ClQX1CHU5hZQ.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">图片来自作者</figcaption></figure><p id="d3a6" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">以下是我从不同来源收集的一些宏观例子。</p><pre class="kd ke kf kg gt mv mt mw bn mx my bi"><span id="4ac8" class="mz lx in mt b be na nb l nc nd">-- Source: Data Engineering Zoomcamp course<br/><br/>{# This macro returns the description of the payment_type. #}<br/><br/>{% macro get_payment_type_description(payment_type) %}<br/><br/>    case {{ payment_type }}<br/>        when 1 then 'Credit card'<br/>        when 2 then 'Cash'<br/>        when 3 then 'No charge'<br/>        when 4 then 'Dispute'<br/>        when 5 then 'Unknown'<br/>        when 6 then 'Voided trip'<br/>    end<br/><br/>{% endmacro %}<br/>-------------------------------------------------------------------------------<br/><br/>-- Source: course.getdbt.com<br/><br/>{# A macro that creates multiple case when statements based on values submitted. #}<br/><br/>{% macro pivot_data_step(column, values, then_val, else_val) %}<br/><br/>  {% for value in values %}<br/>    sum(case when {{ column }} = '{{ value }}' then {{ then_val }} else {{ else_val}} end) as {{ column }}_amount<br/>  {% endfor %}<br/><br/>{% endmacro %}<br/><br/>-------------------------------------------------------------------------------<br/><br/>-- Source: course.getdbt.com<br/><br/>{# A macro that drops any database objects that are older than 7 days by default. #}<br/><br/>{% macro clean_stale_models(database=target.database, schema=target.schema, days=7, dry_run=True) %}<br/>    <br/>    {% set get_drop_commands_query %}<br/>        select<br/>            case <br/>                when table_type = 'VIEW'<br/>                    then table_type<br/>                else <br/>                    'TABLE'<br/>            end as drop_type, <br/>            'DROP ' || drop_type || ' {{ database | upper }}.' || table_schema || '.' || table_name || ';'<br/>        from {{ database }}.information_schema.tables <br/>        where table_schema = upper('{{ schema }}')<br/>        and last_altered &lt;= current_date - {{ days }} <br/>    {% endset %}<br/><br/>    {{ log('\nGenerating cleanup queries...\n', info=True) }}<br/>    {% set drop_queries = run_query(get_drop_commands_query).columns[1].values() %}<br/><br/>    {% for query in drop_queries %}<br/>        {% if dry_run %}<br/>            {{ log(query, info=True) }}<br/>        {% else %}<br/>            {{ log('Dropping object with command: ' ~ query, info=True) }}<br/>            {% do run_query(query) %} <br/>        {% endif %}       <br/>    {% endfor %}<br/>    <br/>{% endmacro %}</span></pre><p id="0958" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">到目前为止，我们已经看到了宏的强大功能，但是在使用宏时有一些重要的权衡需要注意:</p><ul class=""><li id="9709" class="ng nh in ku b kv kw ky kz lb ni lf nj lj nk ln nl nm nn no bi translated">您可能会尝试将一长串 SQL 代码重写为宏。虽然它确实遵循 DRY 范式，但是将所有东西都转换为宏会使人们难以理解代码实际上在做什么。</li><li id="6ec8" class="ng nh in ku b kv np ky nq lb nr lf ns lj nt ln nl nm nn no bi translated">当你写代码的时候，你应该努力在枯燥和可读性之间取得平衡，这样当你和其他人在一个项目中一起工作的时候，他们可以很好地理解你的代码，并继续以一种富有成效的方式工作。</li></ul><p id="ef07" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">我希望我在这些 Jinja &amp; Macros 系列中所介绍的内容对您未来的工作有所帮助。如果你有任何反馈，请写在评论区。谢谢你。</p><h2 id="ed7f" class="lw lx in bd ly lz ma dn mb mc md dp me lb mf mg mh lf mi mj mk lj ml mm mn mo bi translated">其他资源:</h2><ul class=""><li id="710b" class="ng nh in ku b kv nv ky nw lb nx lf ny lj nz ln nl nm nn no bi translated">在创建任何宏之前，我建议您查看一下<a class="ae lo" href="https://hub.getdbt.com/" rel="noopener ugc nofollow" target="_blank"> dbt 包</a>。dbt 中的包包含一些宏，您可以将它们导入到您的 dbt 项目中，以便您可以利用它们，例如<a class="ae lo" href="https://github.com/dbt-labs/dbt-utils/tree/1.0.0/#macros" rel="noopener ugc nofollow" target="_blank"> dbt_utils </a>。</li><li id="df17" class="ng nh in ku b kv np ky nq lb nr lf ns lj nt ln nl nm nn no bi translated">如果你想了解更多关于 Jinja 和宏以及如何在 dbt 中使用它们，我强烈推荐你注册并学习免费的<a class="ae lo" href="https://courses.getdbt.com/collections" rel="noopener ugc nofollow" target="_blank"> dbt 课程</a>。</li></ul></div></div>    
</body>
</html>