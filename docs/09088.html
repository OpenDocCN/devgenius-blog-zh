<html>
<head>
<title>A few must-learn JavaScript hacks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一些必须学习的 JavaScript 技巧</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/a-few-must-learn-javascript-hacks-50c84dfb5010?source=collection_archive---------0-----------------------#2022-07-29">https://blog.devgenius.io/a-few-must-learn-javascript-hacks-50c84dfb5010?source=collection_archive---------0-----------------------#2022-07-29</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/84c976651f370d3dfbadb221f4aeb877.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*K9qQNeavgtmPXbsa"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">布莱克·康纳利在<a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="739d" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">减少如果…其他面条代码</h1><ul class=""><li id="0019" class="ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">一旦我们开始写两个以上，如果…else 函数是时候考虑是否有更好的方法来优化它们了。</li><li id="7163" class="ky kz in la b lb lq ld lr lf ls lh lt lj lu ll lm ln lo lp bi translated">例如，如果我们需要根据麦当劳的名称来计算食物的价格，您可能会这样做。</li></ul><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lv"><img src="../Images/0bf213ee141878cb13e9cc12d00724b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rqF_lEDBQ5b-RRUQSkhNDA.png"/></div></div></figure><ul class=""><li id="40b5" class="ky kz in la b lb ma ld mb lf mc lh md lj me ll lm ln lo lp bi translated">这种编写方式会使函数体有很多条件判断语句，下次要添加产品时需要修改函数内部的逻辑，添加一个 if…。else 语句，这在某种程度上也违背了开放和封闭的原则，当我们需要添加一个逻辑来尝试扩展软件实体来解决变更的需求，而不是通过修改现有代码来完成变更。</li><li id="1a92" class="ky kz in la b lb lq ld lr lf ls lh lt lj lu ll lm ln lo lp bi translated">这是一种非常经典的优化方式，我们可以使用类似 Map 结构的数据来保存所有的商品，这里我们直接创建一个对象来存储。</li></ul><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mf"><img src="../Images/dd3dd7b2bfa68828173b36927fdca098.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aV0offFsTxhvK0pvB4UIOQ.png"/></div></div></figure><ul class=""><li id="d7dd" class="ky kz in la b lb ma ld mb lf mc lh md lj me ll lm ln lo lp bi translated">这样下次我们需要添加一个商品的时候就不需要改变 getPrice 的逻辑了，当然这里其实更多的人喜欢直接在地方直接使用 foodMap，我这里只是举了一个简单的例子来表达这个想法。</li><li id="f66e" class="ky kz in la b lb lq ld lr lf ls lh lt lj lu ll lm ln lo lp bi translated">那么这个时候就有同学会问，如果我不想只用 string 键的话，这个时候你可以用 new Map，思路是类似的，额外扩展一个实体来存储修改。</li></ul><h1 id="1589" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">流水线操作而不是冗余循环</h1><ul class=""><li id="d274" class="ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">有这样一份麦当劳食品清单</li></ul><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mg"><img src="../Images/b8f97bcbde605ea0a7a2a389d6816424.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*juEqpyAHvs8T7J63V6erxg.png"/></div></div></figure><ul class=""><li id="d0d4" class="ky kz in la b lb ma ld mb lf mc lh md lj me ll lm ln lo lp bi translated">如果你想找到属于套餐 1 的食物，你会怎么找？</li><li id="79bf" class="ky kz in la b lb lq ld lr lf ls lh lt lj lu ll lm ln lo lp bi translated">上面的方法是我们以前使用的方法，显然我们用 filter 和 map 代替 for 循环不仅是为了让代码更简洁，也是为了让语义更清晰，所以我们一眼就能看出它是先过滤数组，再重组数组。</li></ul><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mh"><img src="../Images/9276ec3aa9352fc9f5392452362ad58a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W3WtiH4IpWlyoe17S018gA.png"/></div></div></figure><h1 id="57ff" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">查找替换冗余循环</h1><ul class=""><li id="8859" class="ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">和上面的例子一样，如果我们想通过属性值在这个 food 对象数组中查找特定的食物，find 就很有用。</li></ul><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mi"><img src="../Images/6d316ba61e666c7ac02d73a58fee2749.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uQhbQ7h-SvCTiwkDqhA99g.png"/></div></div></figure><h1 id="3620" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">包括替换冗余环路</h1><ul class=""><li id="9efb" class="ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">类似上面两个细节，这些都是已有的函数，也就是我们不用重写内置函数，明智地使用它会节省很多时间。</li><li id="32d7" class="ky kz in la b lb lq ld lr lf ls lh lt lj lu ll lm ln lo lp bi translated">众所周知，一碗康某福老坛酸菜牛肉面有酸菜、面条、牛肉粒、香烟、脚皮，那么我们想用函数确认面条里面有没有脚皮我们怎么写会更简洁呢？</li></ul><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mj"><img src="../Images/38f0bd465787a99e958f0c618b116b50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WxjYtY1rws_cPWAkA_ra-A.png"/></div></div></figure><ul class=""><li id="a120" class="ky kz in la b lb ma ld mb lf mc lh md lj me ll lm ln lo lp bi translated">同样的，也不只是康某福的酸菜牛肉面可以这么杂耍；查找数组中特定元素的所有类似操作都可以使用 includes 函数调用。</li></ul><h1 id="e4c0" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">结果返回值</h1><ul class=""><li id="212f" class="ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">我们通常在编写一些带有返回值的函数时经常会为返回值变量的命名而纠结，甚至对于一些长函数不使用变量而是直接返回，这样的习惯其实是不好的，因为下次我们引用代码时还需要重新理清逻辑。</li><li id="b426" class="ky kz in la b lb lq ld lr lf ls lh lt lj lu ll lm ln lo lp bi translated">通常，在一个小函数中，我们可以使用 result 作为返回值。</li></ul><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mk"><img src="../Images/9e48a49c2a183c02e18cc2d952cb8252.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CfMjzKWRBLY-K0QlXdzHOA.png"/></div></div></figure><h1 id="9dde" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">提前返回</h1><ul class=""><li id="aaa8" class="ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">但是，上面使用 result 作为返回值并不适用于所有情况，经常会有一些时候，我们需要提前结束函数体，以避免稍后同事对程序的冗余读取。</li><li id="1810" class="ky kz in la b lb lq ld lr lf ls lh lt lj lu ll lm ln lo lp bi translated">下面的例子中当我们选择的 Key 不存在时应该立即返回，这样你就不必继续阅读下面的代码，否则面对更复杂的函数会增加很多阅读成本。</li></ul><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ml"><img src="../Images/47fa5e9cbc3004778e6fcf26832630b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vHGMFq0pe9Ekrd4G66dWTg.png"/></div></div></figure><h1 id="fbce" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">保持物体完整</h1><ul class=""><li id="3c9b" class="ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">往往当我们通过请求得到后端返回的数据时会根据一些属性进行处理，如果要处理的属性数量较少，很多同学会习惯使用第一种方法。</li><li id="ecac" class="ky kz in la b lb lq ld lr lf ls lh lt lj lu ll lm ln lo lp bi translated">但实际上，这种习惯并不好，因为当你无法确定函数后来是否需要添加依赖属性时应该保持对象的完整性，正如我在上一篇文章中提到的，学会拥抱变化，如果 getDocDetail 不仅要使用图标和内容，还可能有标题、日期和其他属性，那么我们还不如直接将完整的对象传递进来，这样不仅增加了更短的参数列表，还使代码更具可读性。</li></ul><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mm"><img src="../Images/f68980212f22656ab38d35e91040d3d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xivAqyOossE6cX3yJ0gJCg.png"/></div></div></figure><h1 id="13af" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">使用运算符</h1><ul class=""><li id="9f49" class="ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">当我们需要创建一个新的变量时，有时我们需要检查其值所引用的变量是否为 null 或未定义，因此我们可以使用简单的方法来编写它。</li></ul><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mn"><img src="../Images/1621b7a5c167d0338b4320c7481e0221.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PfzHfTkofpZ9Jyl9ONrMWA.png"/></div></div></figure></div></div>    
</body>
</html>