<html>
<head>
<title>Moving Averages using Akka Streams — Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Akka流的移动平均线—第2部分</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/calculating-moving-averages-using-akka-streams-part-2-c41bb1699feb?source=collection_archive---------9-----------------------#2022-01-06">https://blog.devgenius.io/calculating-moving-averages-using-akka-streams-part-2-c41bb1699feb?source=collection_archive---------9-----------------------#2022-01-06</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><h2 id="601a" class="il im in bd b dl io ip iq ir is it dk iu translated" aria-label="kicker paragraph">数据工程</h2><div class=""/><div class=""><h2 id="fe3d" class="pw-subtitle-paragraph jt iw in bd b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk dk translated">流市场数据的移动平均线函数计算指南</h2></div><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/e1b19140d346a83c3ef19958917757c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*r6dcXgrowl6ZJ2aU"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated"><a class="ae lb" href="https://unsplash.com/@m_____me?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> m. </a>在<a class="ae lb" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><p id="5197" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi ly translated">kka Streams是一个非常强大的流数据处理工具。它有一个参与者模型，可以在大型企业环境中管理反压力。这就是为什么我决定开发一个功能堆栈，它能够以非常高效的内存使用来处理流式市场数据。现在，让我们言归正传。</p></div><div class="ab cl mh mi hr mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ig ih ii ij ik"><p id="d152" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">在<a class="ae lb" href="https://medium.com/@ali.t.asl/calculating-moving-averages-using-akka-streams-a9844acf9527" rel="noopener">上一篇文章</a>中，我使用了Akka流和一个actor来实现移动平均。与我将在本文中讨论的方法相比，这种方法在管理方面很差。在这个方法中，我们仍然需要手工设计一个actor，但是actor将被添加到Akka Streams管道中，并与之集成。如文件所述:</p><blockquote class="mo mp mq"><p id="9e2b" class="lc ld mr le b lf lg jx lh li lj ka lk ms lm ln lo mt lq lr ls mu lu lv lw lx ig bi translated">在许多用例中，同时使用actor和streams可能是合理的:a)当集成现有的基于流或actor的API时。b)当存在应该跨多个流共享的任何可变状态时。c)当流运行时，有任何可变的状态或逻辑可以被“从外部”影响。</p></blockquote><p id="5bae" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">您可以使用两种方法将actor集成到Akka Streams管道中，要么使用<code class="fe mv mw mx my b">ask</code>方法，要么使用<code class="fe mv mw mx my b">actorRefWithBackpressure</code>。在<code class="fe mv mw mx my b">actorRefWithBackpressure</code>中，我们定义了参与者使用的对象和传播反压力的管道。例如:</p><pre class="km kn ko kp gt mz my na nb aw nc bi"><span id="4138" class="nd ne in my b gy nf ng l nh ni">val sink = Sink.actorRefWithBackpressure(<br/>  receiver,<br/>  onInitMessage = InitMessage,<br/>  ackMessage = AckMessage,<br/>  onCompleteMessage = OnCompleteMessage,<br/>  onFailureMessage = onErrorMessage<br/>)</span></pre><p id="a61a" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">对了，这里我就用<code class="fe mv mw mx my b">ask</code>的方法。</p><p id="d064" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">实现新管道的第一步是定义一个参与者。</p><pre class="km kn ko kp gt mz my na nb aw nc bi"><span id="eaa8" class="nd ne in my b gy nf ng l nh ni">class StateActor extends Actor with ActorLogging {<br/>  override def receive: Receive = Stateful(List[Double]())<br/><br/>  def Stateful(numOfTicks: Int, ticks: List[Double]): Receive = {<br/>    case UpdateState(newTick: Double) =&gt;<br/>      log.debug("Updating state.")<br/>      sender() ! UpdateState(ticks)<br/>      if (ticks.length &gt;= numOfTicks) <br/>        context.become(Stateful(ticks.tail :+ newTick))<br/>      else context.become(Stateful(ticks :+ newTick))<br/>    case _ =&gt; log.info("Invalid option!")<br/>  }<br/>}</span></pre><p id="cbd0" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">我们的actor用每条新消息更新它的状态，如这些文章的第1部分所述。响应类型是<code class="fe mv mw mx my b">UpdateState</code>，它包含最后一个分笔成交点的列表。</p><p id="a848" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">在下一步中，我们需要使用actor创建一个Akka流。</p><pre class="km kn ko kp gt mz my na nb aw nc bi"><span id="fe8d" class="nd ne in my b gy nf ng l nh ni">val stateActor = system.actorOf(Props[StateActor],"state")<br/>val stateFlow = Flow[UpdateState].ask[UpdateState](1)(stateActor)</span></pre><p id="eb98" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">首先，我们在之前创建的actor系统中创建一个<code class="fe mv mw mx my b">ActorRef</code>。然后，我们需要使用提到的actor创建一个流。</p><pre class="km kn ko kp gt mz my na nb aw nc bi"><span id="2dda" class="nd ne in my b gy nf ng l nh ni">val firstFlow = source.via(Flow[Double].map(tick =&gt; {<br/>  println(s"New tick: <strong class="my ix">$</strong>tick")<br/>  UpdateState(tick)<br/>}))</span><span id="9b52" class="nd ne in my b gy nj ng l nh ni">val secondFlow = firstFlow.via(stateFlow)<br/>  .via(Flow[UpdateState].filter(state =&gt; state.newTick match {<br/>    case list: List[Double] =&gt; list.length == numOfTicks<br/>  }))</span><span id="05f0" class="nd ne in my b gy nj ng l nh ni">val thirdFlow = secondFlow<br/>  .to(Sink.foreach[UpdateState](tickList =&gt; tickList.newTick match {<br/>    case list: List[Double] =&gt; println(list.sum / list.length)<br/>  })).run()</span></pre><p id="f574" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">管道将消息传递到基于角色的流中。然后，基于消息的长度对此流返回的消息进行过滤。在接收器中，计算滴答列表的平均值并打印到控制台中。</p><p id="1324" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">如果我们基于数据类型转换来分析管道，那么<code class="fe mv mw mx my b">firstFlow</code>将对应于<code class="fe mv mw mx my b">Source[Double, NotUsed]#Repr[UpdateState]</code>或者简单地对应于<code class="fe mv mw mx my b">Source[UpdateState, NotUsed]</code>，正如源代码所定义的。</p><pre class="km kn ko kp gt mz my na nb aw nc bi"><span id="9187" class="nd ne in my b gy nf ng l nh ni">final class Source[+Out, +Mat](<br/>    override val traversalBuilder: LinearTraversalBuilder,<br/>    override val shape: SourceShape[Out])<br/>    extends FlowOpsMat[Out, Mat]<br/>    with Graph[SourceShape[Out], Mat] {<br/><br/>  override type Repr[+O] = Source[O, Mat @uncheckedVariance]<br/>  ...<br/>}</span></pre><p id="db33" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">第二个流将返回与actor返回的数据类型相同的类型，以响应我们的请求。</p><p id="f867" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">正如文档中所讨论的，在<code class="fe mv mw mx my b">via</code>的定义中:</p><pre class="km kn ko kp gt mz my na nb aw nc bi"><span id="0d22" class="nd ne in my b gy nf ng l nh ni"><strong class="my ix">def </strong>via[T, Mat2](flow: Graph[FlowShape[Out, T], Mat2]): Repr[T]</span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nk"><img src="../Images/f638edf45352ac2f1a23ce81c4be4ce2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k7FpT6sAhuXfqStoD1mjWg.png"/></div></div></figure><p id="faad" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">组合流返回的物化值将是当前流的物化值。使用<code class="fe mv mw mx my b">viaMat</code>方法可以改变这种行为。</p></div></div>    
</body>
</html>