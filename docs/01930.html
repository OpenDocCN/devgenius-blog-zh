<html>
<head>
<title>Node.js Tips — Express Errors, URLs, Parameters and Writing Files</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js 提示—表达错误、URL、参数和编写文件</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/node-js-tips-express-errors-urls-parameters-and-writing-files-f75657b8e08e?source=collection_archive---------23-----------------------#2020-07-14">https://blog.devgenius.io/node-js-tips-express-errors-urls-parameters-and-writing-files-f75657b8e08e?source=collection_archive---------23-----------------------#2020-07-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/0e524ed1fc644317dcf6c15a72c05525.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uO9OSpoRdEktv9A9"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@xeniabogarova?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Xenia Bogarova </a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="86c1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像任何类型的应用程序一样，当我们编写节点应用程序时，有一些困难的问题需要解决。</p><p id="96a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究一些编写节点应用程序时常见问题的解决方案。</p><h1 id="128c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">找不到页面时出现渲染错误</h1><p id="393f" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用<code class="fe me mf mg mh b">res.render</code>呈现一个错误消息。</p><p id="ee98" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="edd4" class="mq lc iq mh b gy mr ms l mt mu">app.use((req, res, next) =&gt; {<br/>  res.render('404', { status: 404, url: req.url });<br/>});</span></pre><p id="aa45" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">来显示 404 错误。</p><p id="1faa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">'404'</code>是模板名。</p><p id="7f34" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个对象包含了我们想要在<code class="fe me mf mg mh b">404</code>模板上显示的内容。</p><p id="261c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也可以通过编写来制作一个通用的错误处理中间件；</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="dbb5" class="mq lc iq mh b gy mr ms l mt mu">app.use((err, req, res, next) =&gt; {<br/>  res.render('500', {<br/>    status: err.status || 500,<br/>    error: err<br/>  });<br/>});</span></pre><p id="6f99" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将<code class="fe me mf mg mh b">err</code>作为第一个参数。</p><p id="5526" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以用<code class="fe me mf mg mh b">err.status</code>得到错误状态代码，然后我们可以将对象传递给<code class="fe me mf mg mh b">500</code>页面模板。</p><h1 id="f3d8" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">在 Node.js 中写入文件</h1><p id="3f92" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用 Node.js 和<code class="fe me mf mg mh b">writeFile</code>、<code class="fe me mf mg mh b">writeFileSync</code>或者一个写流来写文件。</p><p id="5c24" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="53de" class="mq lc iq mh b gy mr ms l mt mu">const fs = require('fs');</span><span id="3b67" class="mq lc iq mh b gy mv ms l mt mu">fs.writeFile("/tmp/foo.txt", "hello world", (err) =&gt; {<br/>  if (err) {<br/>    return console.log(err);<br/>  }<br/>  console.log("The file was saved!");<br/>});</span></pre><p id="cb33" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="0c42" class="mq lc iq mh b gy mr ms l mt mu">const fs = require('fs');</span><span id="b495" class="mq lc iq mh b gy mv ms l mt mu">fs.writeFileSync('/tmp/foo.txt', 'hello world');</span></pre><p id="9c09" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们都将文件路径和内容作为前两个参数。</p><p id="0da9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">writeFile</code>也接受一个用<code class="fe me mf mg mh b">err</code>调用的回调(如果存在的话)。</p><p id="7520" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要创建写流，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="4761" class="mq lc iq mh b gy mr ms l mt mu">const fs = require('fs');<br/>const  stream = fs.createWriteStream("/tmp/foo.txt");<br/>stream.once('open', (fd) =&gt; {<br/>  stream.write("hello\n");<br/>  stream.write("world\n");<br/>  stream.end();<br/>});</span></pre><p id="3333" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用要写入的文件路径调用<code class="fe me mf mg mh b">createWriteStream</code> to。</p><p id="14e8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们用<code class="fe me mf mg mh b">stream.once</code>打开流。</p><p id="b5d4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们从<code class="fe me mf mg mh b">stream.write</code>开始写。</p><p id="340b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们必须用<code class="fe me mf mg mh b">stream.end</code>关闭流。</p><h1 id="c802" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">在 Express 中获取查询字符串变量</h1><p id="435a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用<code class="fe me mf mg mh b">req.query</code>属性获得查询字符串变量。</p><p id="041b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它将查询字符串解析成键值对的对象。</p><p id="89d9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="4259" class="mq lc iq mh b gy mr ms l mt mu">const express = require('express');<br/>const app = express();</span><span id="6f39" class="mq lc iq mh b gy mv ms l mt mu">app.get('/', (req, res) =&gt; {<br/>  res.send(req.query.id);<br/>});</span><span id="2346" class="mq lc iq mh b gy mv ms l mt mu">app.listen(3000);</span></pre><p id="5605" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们有一个类似于<code class="fe me mf mg mh b">?id=10</code>的查询字符串，那么<code class="fe me mf mg mh b">req.query.id</code>就是 10。</p><h1 id="edea" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">在 Express 应用程序中检索发布查询参数</h1><p id="54c9" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用<code class="fe me mf mg mh b">body-parser</code>包获得 POST 查询参数。</p><p id="a5dc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要使用它，我们必须通过运行以下命令来安装它:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="ca83" class="mq lc iq mh b gy mr ms l mt mu">npm install --save body-parser</span></pre><p id="8dd5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="4a97" class="mq lc iq mh b gy mr ms l mt mu">const bodyParser = require('body-parser');<br/>app.use(bodyParser.json());<br/>app.use(bodyParser.urlencoded({ <br/>  extended: true<br/>}));</span></pre><p id="5991" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们导入模块，以便我们可以使用它。</p><p id="644a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们调用<code class="fe me mf mg mh b">bodyParser.json()</code>，它返回一个中间件来使用这个中间件。</p><p id="bc7b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">urlencoded</code>解析 URL 编码体。</p><p id="f84a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">extended</code>设置为<code class="fe me mf mg mh b">true</code>意味着我们可以用它解析 URL 编码字符串中的 JSON 主体。</p><h1 id="5e26" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">将 CORS 标题添加到选项路线</h1><p id="fd37" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用自己的中间件轻松完成所有的连线工作。</p><p id="4abd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="46e7" class="mq lc iq mh b gy mr ms l mt mu">const allowCrossDomain = (req, res, next) =&gt; {<br/>  res.header('Access-Control-Allow-Origin', 'example.com');<br/>  res.header('Access-Control-Allow-Methods', 'GET,PUT,POST,DELETE');<br/>  res.header('Access-Control-Allow-Headers', 'Content-Type');<br/>  next();<br/>}</span></pre><p id="55bf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">Access-Control-Allow-Origin</code>头让浏览器知道哪些域可以访问 API。</p><p id="6ac5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">Access-Control-Allow-Methods</code>告诉浏览器允许调用哪种请求。</p><p id="3b8d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">Access-Control-Allow-Headers</code>告诉浏览器可以发送什么样的内容。</p><p id="e965" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">更简单的方法是使用<code class="fe me mf mg mh b">cors</code>中间件。</p><p id="cf68" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要使用它，我们可以运行:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="2fb6" class="mq lc iq mh b gy mr ms l mt mu">npm install cors --save</span></pre><p id="35dd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">来安装它。</p><p id="5cdd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="27cf" class="mq lc iq mh b gy mr ms l mt mu">const cors = require('cors');<br/>const express = require('express');<br/>const app = express();<br/>app.use(cors());<br/>app.options('*', cors());</span></pre><p id="06e5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们在整个应用程序上使用<code class="fe me mf mg mh b">cors</code>中间件:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="3547" class="mq lc iq mh b gy mr ms l mt mu">app.use(cors());</span></pre><p id="5a7d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们允许使用以下方式调用选项路线:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="7e82" class="mq lc iq mh b gy mr ms l mt mu">app.options('*', cors());</span></pre><h1 id="e754" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">如何在 Express 中获得完整的 URL</h1><p id="2c45" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用<code class="fe me mf mg mh b">req.protocol</code>属性来获取协议，也就是<code class="fe me mf mg mh b">http</code>或<code class="fe me mf mg mh b">https</code>部分。</p><p id="b3c7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，我们可以用<code class="fe me mf mg mh b">req.get('host')</code>得到主机名。</p><p id="c747" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们得到了带有<code class="fe me mf mg mh b">req.originalUrl</code>的完整 URL。</p><p id="e1db" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了解析合并成完整的 URL，我们可以使用<code class="fe me mf mg mh b">url</code>模块。</p><p id="6e07" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="d9d9" class="mq lc iq mh b gy mr ms l mt mu">const requrl = url.format({<br/>  protocol: req.protocol,<br/>  host: req.get('host'),<br/>  pathname: req.originalUrl,<br/>});</span></pre><p id="e09a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以在路由处理器内部或任何其他地方这样做。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/a6972ff67062143d7f6abf10d738830e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gQ2oULi9KLr8KNmf"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@r3dmax?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Jonatan Pie </a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="b7ad" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="1477" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过传入一个模板来呈现一个错误页面，并获得我们想要显示的状态或错误。</p><p id="6a3e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">url</code>模块可以将 URL 部分组合在一起。</p><p id="9a98" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">写文件有很多种方法。</p><p id="919d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">CORS 可以通过设置一些响应头或使用带有 Express 的<code class="fe me mf mg mh b">cors</code>中间件来完成。</p></div></div>    
</body>
</html>