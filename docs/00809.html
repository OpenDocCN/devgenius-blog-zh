<html>
<head>
<title>Training an ML Model for Sentiment Analysis in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python训练用于情感分析的ML模型</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/training-an-ml-model-for-sentiment-analysis-in-python-63b6b8c68792?source=collection_archive---------3-----------------------#2020-06-17">https://blog.devgenius.io/training-an-ml-model-for-sentiment-analysis-in-python-63b6b8c68792?source=collection_archive---------3-----------------------#2020-06-17</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/f14ee0209550c04b731e79d80adf12bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wjRMMRBFvdy3mlAiUfpw4g.jpeg"/></div></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk translated">照片由伊戈尔·沙巴林拍摄</figcaption></figure><div class=""/><p id="a1bc" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">情感分析是文本分类的一项任务。特别是，它是关于确定一篇文章是积极的，消极的，还是中性的。有了一组相应的标记句子，你可以训练一个机器学习模型，然后可以用来对新句子进行预测。本文展示了训练这样一个模型的过程，只需几行代码就可以在一个使用sklearn库的Python脚本中实现。</p><h1 id="305d" class="kx ky jc bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">从数据集中加载数据</h1><p id="912e" class="pw-post-body-paragraph jz ka jc kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ig bi translated">在文章示例中，我们将利用可从UCI机器学习知识库获得的<a class="ae ma" href="https://archive.ics.uci.edu/ml/datasets/Sentiment+Labelled+Sentences" rel="noopener ugc nofollow" target="_blank">情感标签句子数据集</a>。该数据集包含用正面或负面情绪标记的客户产品评论。这些评论来自三个不同的网站，包括imdb.com、Amazon.com和yelp.com。因此，数据来自三个不同的文件。数据集中的实例总数是3000。在文章示例中，我们将仅使用取自Amazon.com的实例(标记的句子)。这是1000个句子，其中500个是肯定的，另外500个是否定的。</p><p id="6da1" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在下面的代码片段中，您将数据加载到pandas数据框架中，以简化进一步的计算:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="48ba" class="mk ky jc mg b gy ml mm l mn mo">&gt;&gt;&gt; import pandas as pd<br/>&gt;&gt;&gt; df = pd.read_csv('/datasets/sentiment/amazon_cells_labelled.txt', names=['review', 'sentiment'], sep='\t') <br/>&gt;&gt;&gt; df.head()</span><span id="8de6" class="mk ky jc mg b gy mp mm l mn mo">0 So there is no way for me to plug it in here i… 0<br/>1 Good case, Excellent value. 1<br/>2 Great for the jawbone. 1<br/>3 Tied to charger for conversations lasting more… 0<br/>4 The mic is great. 1</span></pre><h1 id="0ff8" class="kx ky jc bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">将数据集分成训练集和测试集</h1><p id="dcfe" class="pw-post-body-paragraph jz ka jc kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ig bi translated">如果您还记得，我们的目标是训练一个模型来预测评论的情绪。第一步是将我们拥有的数据分成训练集和测试集。使用sklearn库，这可以通过几行代码来完成:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="344d" class="mk ky jc mg b gy ml mm l mn mo">&gt;&gt;&gt; from sklearn.model_selection import train_test_split<br/>&gt;&gt;&gt; reviews = df['review'].values<br/>&gt;&gt;&gt; labels = df['sentiment'].values<br/>&gt;&gt;&gt; reviews_train, reviews_test, y_train, y_test = train_test_split(reviews, labels, test_size=0.2, random_state=1000)</span></pre><p id="f079" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在这个特定的例子中，我们使用80/20模式划分数据集，这意味着随机选择的80%的实例用于训练模型，而另外20%用于进一步的测试。无论如何，我们目前拥有的仍然是两个带有标记文本数据的集合。然而，为了训练一个ML模型，然后测试它，我们需要一种用数字表示文本数据的方法。</p><p id="3989" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这可以通过被称为单词包(BoW)的技术来实现。可以用sklearn的CountVectorizer()函数为文本数据生成BoW矩阵。该函数设计用于将文本转换为数字特征向量，首先执行标记化和过滤停用词。CountVectorizer()使用默认标记器或自定义标记器执行标记化。下一节说明了如何使用spaCy实现自定义标记化器函数。同样，实现自定义记号赋予器是一个可选步骤，因为您可以选择使用默认记号赋予器。</p><h1 id="8f1b" class="kx ky jc bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">使用spaCy创建自定义标记器(可选)</h1><p id="bba7" class="pw-post-body-paragraph jz ka jc kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ig bi translated">在继续使用spaCy创建自定义标记器之前，您需要安装spaCy及其英语模型。详情可在位于https://spacy.io/usage/的<a class="ae ma" href="https://spacy.io/usage/" rel="noopener ugc nofollow" target="_blank">空间文件中找到。完成这些安装后，您可以实现一个自定义spacy_tokenizer函数，它可能如下所示:</a></p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="d22b" class="mk ky jc mg b gy ml mm l mn mo">&gt;&gt;&gt; from spacy.lang.en.stop_words import STOP_WORDS<br/>&gt;&gt;&gt; from spacy.lang.en import English<br/>&gt;&gt;&gt; import string<br/>&gt;&gt;&gt; punctuations = string.punctuation<br/>&gt;&gt;&gt; parser = English()<br/>&gt;&gt;&gt; stopwords = list(STOP_WORDS)<br/>&gt;&gt;&gt; def spacy_tokenizer(utterance):<br/>      tokens = parser(utterance)<br/>      return [token.lemma_.lower().strip() for token in tokens if token.text.lower().strip() not in stopwords and token.text not in punctuations]</span></pre><p id="2315" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">注意，您甚至不需要创建spaCy的NLP管道来实现上面的记号赋予器。这里需要注意的另一件有趣的事情是，您使用string.punctuation来获取标点符号的字符串，而不是spaCy的语言特性。否则，您将不得不加载spaCy的英语模型并创建NLP管道。</p><h1 id="3de3" class="kx ky jc bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">将文本转换成数字特征向量</h1><p id="59f6" class="pw-post-body-paragraph jz ka jc kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ig bi translated">如前所述，将文本转换为特征向量可以通过sklearn的CountVectorizer()函数来完成。在下面的例子中，我们使用在上一节中创建的spaCy的自定义标记器。或者，您可以使用默认选项，不向CountVectorizer()传递任何参数。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="8a21" class="mk ky jc mg b gy ml mm l mn mo">&gt;&gt;&gt; from sklearn.feature_extraction.text import CountVectorizer<br/>&gt;&gt;&gt; vectorizer = CountVectorizer(tokenizer = spacy_tokenizer, ngram_range=(1,1))<br/>&gt;&gt;&gt; #By default, the vectorizer might be created as follows:<br/>&gt;&gt;&gt; #vectorizer = CountVectorizer()<br/>&gt;&gt;&gt; vectorizer.fit(reviews_train)</span></pre><p id="c258" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">下面你把文本转换成数字特征向量:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="7975" class="mk ky jc mg b gy ml mm l mn mo">&gt;&gt;&gt; X_train = vectorizer.transform(reviews_train)<br/>&gt;&gt;&gt; X_test = vectorizer.transform(reviews_test)</span></pre><h1 id="e933" class="kx ky jc bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">训练模型</h1><p id="8c3a" class="pw-post-body-paragraph jz ka jc kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ig bi translated">现在您已经准备好训练模型了。特别是，你需要训练一个分类器，这样它就可以预测一篇评论的情绪。在这个特殊的例子中，我们使用一个逻辑回归分类器。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="7475" class="mk ky jc mg b gy ml mm l mn mo">&gt;&gt;&gt; from sklearn.linear_model import LogisticRegression<br/>&gt;&gt;&gt; classifier = LogisticRegression()<br/>&gt;&gt;&gt; classifier.fit(X_train, y_train)</span></pre><h1 id="592d" class="kx ky jc bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">模型评估</h1><p id="a652" class="pw-post-body-paragraph jz ka jc kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ig bi translated">现在您已经训练了您的模型，您如何知道它是否可以对新数据做出正确的预测。因此，模型的准确性指的是模型做出的正确预测的百分比。为了评估模型的准确性，您需要一组用于测试的标记数据。这就是为什么通常的做法是将带标签的数据集分为训练集和测试集，正如我们在将数据集分为训练集和测试集一节中所做的那样。现在，为了评估我们的模型，您可以发出以下代码:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="6cd9" class="mk ky jc mg b gy ml mm l mn mo">&gt;&gt;&gt; accuracy = classifier.score(X_test, y_test)<br/>&gt;&gt;&gt; print(“Accuracy:”, accuracy)</span><span id="d309" class="mk ky jc mg b gy mp mm l mn mo">Accuracy: 0.785</span></pre><p id="24d1" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这意味着我们模型的准确率是78.5%</p><h1 id="7be8" class="kx ky jc bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">对新数据的预测</h1><p id="0e7e" class="pw-post-body-paragraph jz ka jc kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ig bi translated">这可能是最有趣的部分。你有模型。现在怎么办？在下面的代码中，我们对模型应用新的检查，看看它是否能正确地做出预测。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="4a14" class="mk ky jc mg b gy ml mm l mn mo">&gt;&gt;&gt; new_reviews = ['Old version of python useless', 'Very good effort, but not five stars', 'Clear and concise']<br/>&gt;&gt;&gt; X_new = vectorizer.transform(new_reviews)<br/>&gt;&gt;&gt; classifier.predict(X_new)</span><span id="311a" class="mk ky jc mg b gy mp mm l mn mo">array([0, 1, 1])</span></pre><p id="e5e9" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">正如您所看到的，这个模型对于上面的评论工作得很好。</p><h1 id="c3f7" class="kx ky jc bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">渴望更多的例子？</h1><p id="034a" class="pw-post-body-paragraph jz ka jc kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ig bi translated">渴望更多关于使用NLP技术的场景示例吗？看看我的<a class="ae ma" href="https://nostarch.com/NLPPython" rel="noopener ugc nofollow" target="_blank"> NLP书</a>的这个<a class="ae ma" href="https://github.com/nlptechbook/examples" rel="noopener ugc nofollow" target="_blank"> github库</a>。</p></div></div>    
</body>
</html>