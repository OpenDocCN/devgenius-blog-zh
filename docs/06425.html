<html>
<head>
<title>A Look at Instance, Static, Class and Abstract Methods in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的实例、静态、类和抽象方法</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/a-look-at-instance-static-class-and-abstract-methods-in-python-c82bd06c0430?source=collection_archive---------7-----------------------#2022-01-06">https://blog.devgenius.io/a-look-at-instance-static-class-and-abstract-methods-in-python-c82bd06c0430?source=collection_archive---------7-----------------------#2022-01-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/549f839d0f180769b22f1b6391b0ea2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0KtXHA7Wvw5icLjt"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">迈克尔·泽兹奇在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="a8ed" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">面向对象编程，尽管受到许多人的严厉批评，仍然是许多软件开发领域的主导范式。</p><p id="4bc9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Python之所以简洁，是因为您可以用过程化、函数化或面向对象的方式编写代码。然而，为了更好的可读性和可维护性，我建议尽可能使用OOP。</p><p id="b106" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">即使您正在使用过程化或函数式风格编写代码，强烈建议您至少熟悉OOP最佳实践，因为您将使用的许多第三方框架和库将以OOP方式编写。能够阅读和理解这些代码将会给你很大的帮助。</p><p id="aec8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我将研究Python类可以包含的各种类型的方法，以及何时使用它们是一个好主意。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="5775" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">实例方法</h1><p id="da77" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">实例方法是最常见的类型，这是有道理的。当从一个类中实例化一个对象时，您定义了这个对象将拥有的一些属性，也称为对象的<em class="ml">状态</em>。实例方法旨在访问和修改这种状态。虽然在Python中，我们不像在Java中那样显式声明对象的私有和公共属性，但是只通过您定义的实例方法来访问和修改您的实例属性是一个很好的实践。</p><p id="9998" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以将实例方法与静态、类和抽象方法区分开来，因为实例方法是唯一不要求在其签名上使用装饰器的方法(我们将在代码示例中看到)。它们还包含关键字<em class="ml"> self </em>作为第一个参数(相当于Java和JavaScript中的<em class="ml"> this </em>)，尽管这个名称完全是约定俗成的，理论上您可以随意命名。然而，我强烈建议坚持这个惯例，因为把它改变成除了<em class="ml">自己</em>之外的任何东西都不会让你的团队成员觉得很有趣。</p><p id="ca11" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们看一个简单的例子:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="0ae8" class="mv lj iq mr b gy mw mx l my mz">class Employee:</span><span id="7b37" class="mv lj iq mr b gy na mx l my mz">def __init__(self, name, department, annual_salary):<br/>    self.name = name<br/>    self.department = department<br/>    self.annual_salary  = annual_salary</span><span id="4621" class="mv lj iq mr b gy na mx l my mz">def get_monthly_salary(self):<br/>    return self.annual_salary / 12</span><span id="6e2f" class="mv lj iq mr b gy na mx l my mz">def earn_promotion(self,new_department, new_salary): <br/>    self.department = new_department<br/>    self.annual_salary = new_salary</span><span id="c3d9" class="mv lj iq mr b gy na mx l my mz">tim = Employee('Tim Jones','Engineering',90_000)<br/>print(tim.get_monthly_salary())<br/>tim.earn_promotion('Management',105_000)<br/>print(tim.get_monthly_salary())</span></pre><p id="7adf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">除了用作对象构造器的<em class="ml"> __init__ </em> dunder方法，我们看到我们的Employee类还有2个方法，都是实例方法。</p><p id="f352" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一个是为了从年薪中计算出月薪，另一个是为了以防工程师蒂姆因努力工作而得到奖励并获得晋升。如您所见，使用实例方法的主要原因是为了访问或修改对象的状态。</p><p id="b542" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Python非常灵活，也允许您直接更改对象属性，如下所示:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="3b8f" class="mv lj iq mr b gy mw mx l my mz">tim.department = 'Sales'<br/>print(tim.department)</span></pre><p id="3035" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是这通常被认为不是一个好的实践。理想情况下，您应该只通过该类的API(在这种情况下，API意味着该类公开的一组公共方法)来修改状态。您有时会看到开发人员通过在属性名称前添加单下划线或双下划线来强调属性是私有的，不能直接修改，但这不会阻止Python解释器执行直接的属性修改。</p><h1 id="8981" class="li lj iq bd lk ll nb ln lo lp nc lr ls lt nd lv lw lx ne lz ma mb nf md me mf bi translated">静态方法</h1><p id="fa97" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">当您想要调用某个类的某个方法，而不实际实例化该类时，静态方法非常有用。在Python中，当我们定义一个静态方法时，我们需要使用<em class="ml">静态方法</em>装饰器，正如你将在代码示例中看到的。因为静态方法不访问任何实例变量，所以它不需要一个<em class="ml">自身</em>属性。</p><p id="6175" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是，什么时候你甚至需要一个没有实际对象的类的方法呢？</p><p id="309f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一个很好的例子是，当您想按某个资源对一组方法进行分组时。假设你正在使用一个在圆上做各种计算的模块。您可以定义一个名为Circles的类，然后为所有不同种类的操作添加静态方法。下面是我的意思的一个示例代码片段:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="aaa9" class="mv lj iq mr b gy mw mx l my mz">import math</span><span id="2929" class="mv lj iq mr b gy na mx l my mz">class Circles:</span><span id="f4b1" class="mv lj iq mr b gy na mx l my mz">    @staticmethod<br/>    def get_area(radius):<br/>        return radius * radius * math.pi</span><span id="0792" class="mv lj iq mr b gy na mx l my mz">    @staticmethod<br/>    def get_circumference(radius):<br/>        return 2 * radius * math.pi</span><span id="80ac" class="mv lj iq mr b gy na mx l my mz">area = Circles.get_area(3)<br/>print(area)<br/>circumference = Circles.get_circumference(3)<br/>print(circumference)</span></pre><p id="7501" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这实际上是一种非常常见的模式，对于许多用例来说非常有用。看看Java内置的<a class="ae kc" href="https://docs.oracle.com/javase/7/docs/api/java/util/Arrays.html" rel="noopener ugc nofollow" target="_blank">数组类</a>就知道了。它的所有方法都是静态的，如果你在Java中使用数组，你很可能必须使用这个类。</p><p id="843a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一个好的用例是<em class="ml">工厂</em>设计模式。尽管工厂也可以被实例化并具有实例方法，但如果工厂的返回值依赖于全局变量或与实际工厂的实例属性无关的变量，那么使用静态方法的工厂并不少见。这里有一个例子:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="0e6a" class="mv lj iq mr b gy mw mx l my mz">class EmployeeFactory:</span><span id="7cd1" class="mv lj iq mr b gy na mx l my mz">@staticmethod<br/>def get_employee(name,department,salary):<br/>    if department == 'design':<br/>        return Designer(name, department, salary)<br/>    elif department == 'management':<br/>        return Manager(name, department, salary)<br/>    elif department == 'engineering':<br/>        return Engineer(name, department, salary)</span><span id="426d" class="mv lj iq mr b gy na mx l my mz">name = request.args['name']<br/>department = request.args['department']<br/>salary = request.args['salary']<br/>employee = EmployeeFactory.get_employee(name, department, salary)</span></pre><p id="ca6a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如您所见，我们根据传递的部门实例化了工厂中某个雇员类型的对象。然而，我们是从HTML表单(或您能想到的任何其他来源)获取部门值的，所以没有必要实例化工厂。我们只是在工厂内部访问该方法，因为它是静态的。</p><h1 id="dabe" class="li lj iq bd lk ll nb ln lo lp nc lr ls lt nd lv lw lx ne lz ma mb nf md me mf bi translated">类方法</h1><p id="c202" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">类方法有点类似于静态方法，主要区别在于类方法可以访问<em class="ml">类变量</em>。在我的经验中，它们比静态和实例方法更不常见，但实际上我在产品代码中不止一次地使用过它们。与静态方法类似，类方法也需要装饰器，只不过这次是类方法<em class="ml">。</em></p><p id="9772" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用类方法的一个很好的例子是，如果你有一个值，它需要成为你的类的一部分，但是这个值是一个常量。访问令牌和秘密就是一个很好的例子。看一下这段代码:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="4733" class="mv lj iq mr b gy mw mx l my mz">import os<br/>import requests<br/>from requests.auth import HTTPBasicAuth</span><span id="c25a" class="mv lj iq mr b gy na mx l my mz">class TweetCollector:</span><span id="1a31" class="mv lj iq mr b gy na mx l my mz">    API_KEY = os.getenv('TWITTER_API_KEY')<br/>    API_SECRET = os.getenv('TWITTER_SECRET')<br/>    TWITTER_API_BASE_URL = os.getenv('TWITTER_API_BASE_URL')</span><span id="a101" class="mv lj iq mr b gy na mx l my mz">    @classmethod<br/>    def get_tweets_from_handle(cls,handle_id):<br/>        req = requests.get(cls.TWITTER_API_BASE_URL,      auth=HTTPBasicAuth(cls.API_KEY, cls.API_SECRET))<br/>    return req.json()</span></pre><p id="2dc4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里我们有一个名为TweetCollector的类，它调用Twitter API并获取属于某个Twitter句柄的tweets。然而，为了使用Twitter的API，我们需要使用API key + API secret，所以将它们添加到TweetCollector类是有意义的，因为它们永远不会改变，并且我们需要它们用于TweetCollector发出的每个调用。</p><p id="399e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">类方法的另一个很好的用例是，如果您希望在实例化类中的对象之前跟踪类内部的值。这里有一个例子:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="8372" class="mv lj iq mr b gy mw mx l my mz">class Package:</span><span id="ec15" class="mv lj iq mr b gy na mx l my mz">    package_id = 1_000_001<br/>    <br/>    def __init__(self, sender, reciever, weight):<br/>        self.sender = sender<br/>        self.reciever = reciever<br/>        self.weight = weight<br/>        self.package_id = Package.assign_package_id()</span><span id="bf8f" class="mv lj iq mr b gy na mx l my mz">    def get_package_id(self):<br/>        return self.package_id</span><span id="8921" class="mv lj iq mr b gy na mx l my mz">    @classmethod<br/>    def assign_package_id(cls):<br/>        package_id = cls.package_id<br/>        cls.package_id += 1<br/>        return package_id</span><span id="a057" class="mv lj iq mr b gy na mx l my mz"><br/>print(Package.package_id)<br/>new_package = Package('Amy from NY', 'Jose from Madrid', 10)<br/>print(new_package.get_package_id())<br/>print(Package.package_id)</span></pre><p id="d89e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里我们有一个名为Package的类，它同时具有实例和类方法。我们使用一个名为<em class="ml"> package_id </em>的类变量来确保每个包都使用正确的id进行序列化，该id在每次实例化一个新的包对象后递增。请记住，这个package_id只存储在应用程序内存中，所以一旦程序终止，它将恢复到初始值。我承认，这可能不是生产的最佳用例，但肯定可以用于各种用例。</p><h1 id="7435" class="li lj iq bd lk ll nb ln lo lp nc lr ls lt nd lv lw lx ne lz ma mb nf md me mf bi translated">抽象方法</h1><p id="66b8" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">我们都知道Python不支持接口。当我们知道对一个接口 进行<a class="ae kc" href="https://en.wikipedia.org/wiki/Interface-based_programming" rel="noopener ugc nofollow" target="_blank"> <em class="ml">编程被认为是实现OOP的一个非常好的实践时，这有时真的会令人沮丧。它基本上意味着，如果某个类希望成为某个类型，您应该实现需要履行的某个契约。</em></a></p><p id="bc0d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果一个名为<em class="ml"> ArrayList </em>的类想要成为<em class="ml"> List </em>家族的一部分，它需要实现<em class="ml"> List </em>接口声明的所有方法。有点像大学兄弟会的入会仪式。如果你想被正式接纳为会员，你需要做其他会员做的所有事情。</p><p id="444f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它是多态性的基石，在Java和C#等语言中广泛使用，甚至在Golang中也是如此，Golang并不是真正的OOP语言(至少不是完全意义上的)。不得不在没有接口的情况下编写OOP有点问题，尤其是如果你试图实现类似于<a class="ae kc" href="https://en.wikipedia.org/wiki/Hexagonal_architecture_(software)" rel="noopener ugc nofollow" target="_blank">六边形架构</a>的东西。</p><p id="2e61" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">幸运的是，有一种变通方法- <em class="ml">抽象方法。</em></p><p id="696b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设我正在做一个项目，它是一组域驱动的微服务。我被委派在其中一个服务的数据层工作，让我们称之为<em class="ml">用户</em>服务。它的作用是注册新用户，获取活动用户的列表，以及删除不活动的用户。</p><p id="5206" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我需要创建一个类来完成我对这个有用资源的所有数据库调用，但是，团队仍然不确定我们将使用哪个数据库。事实上，我们甚至不确定它是SQL数据库还是NoSQL数据库。</p><p id="850e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">更糟糕的是，我们可能会在项目进行到一半时切换数据库。</p><p id="dc13" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我聪明地决定创建一个抽象类(缺少一个接口)，它将描述这个服务用于所有数据库调用的方法。</p><p id="7b9a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我的意思是:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="da25" class="mv lj iq mr b gy mw mx l my mz">from abc import ABC, abstractmethod</span><span id="0c0f" class="mv lj iq mr b gy na mx l my mz">class UserRepository(ABC):</span><span id="0aa5" class="mv lj iq mr b gy na mx l my mz">    @abstractmethod<br/>    def add_user(username, email, password):<br/>        pass</span><span id="b928" class="mv lj iq mr b gy na mx l my mz">    @abstractmethod<br/>    def get_active_users():<br/>        pass</span><span id="05ca" class="mv lj iq mr b gy na mx l my mz">    @abstractmethod<br/>    def delete_inactive_user(username):<br/>        pass</span></pre><p id="d14c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这将作为任何将进行数据库调用的类的契约。如果它想成为一个用户存储库，它需要实现这三个方法，因为我们的业务需求明确声明我们需要能够添加新用户，获得活动用户的列表，并且能够删除非活动用户。</p><p id="f6e7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们正在从内置的<a class="ae kc" href="https://docs.python.org/3/library/abc.html" rel="noopener ugc nofollow" target="_blank"> abc模块</a>中导入ABC(抽象基类的缩写)，该模块用于Python中关于抽象类的所有功能。</p><p id="b8ca" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您试图实例化这个抽象类，您将得到一个错误:</p><p id="c004" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="ml">类型错误:无法用抽象方法add_user、delete_inactive_user、get_users实例化抽象类UserRepository】</em></p><p id="0a3c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">既然团队最终决定使用MySQL作为我们的数据库，我们可以通过继承我们的基类来实现将在生产中执行数据库调用的实际类:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="e930" class="mv lj iq mr b gy mw mx l my mz">class MySQLUserRepository(UserRepository):</span><span id="92a5" class="mv lj iq mr b gy na mx l my mz">    def add_user(username, email, password):<br/>        # Here we implement the mysql logic       </span><span id="4c7a" class="mv lj iq mr b gy na mx l my mz">        add_user_using_mysql_logic()<br/>  <br/>    def get_users():<br/>        users = fetch_users_from_mysql()<br/>        return users</span><span id="10d2" class="mv lj iq mr b gy na mx l my mz">    def delete_inactive_user(username):<br/>        delete_user_using_mysql_logic()</span></pre><p id="af17" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">既然所有的抽象方法都是通过实现特定于从MySQL访问数据的逻辑来实现的，那么这个类就可以成功地用在我们的代码中了。</p><p id="16fb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我出于某种原因忘记实现最后一个方法，让它保持抽象，我会得到下面的错误:</p><p id="b645" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="ml">类型错误:无法用抽象方法delete_inactive_user </em>实例化抽象类MySQLUserRepository</p><p id="ed24" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，如果项目进行了4个月，团队意识到对于我们的用例来说，迁移到像DynamoDB这样的NoSQL数据库更有意义，我可以创建一个新的类，它也继承了抽象类，方法名称以及预期的最终结果和高级功能将保持不变。当然，访问DynamoDB的逻辑会有所不同。但是，这意味着我只需要更改该类中的逻辑，而服务中的其他内容将保持不变:</p><pre class="mm mn mo mp gt mq mr ms mt aw mu bi"><span id="b771" class="mv lj iq mr b gy mw mx l my mz">class DynamoDBUserRepository(UserRepository):<br/>    <br/>    def add_user(username, email, password):<br/>        add_user_using_dynamodb_logic()</span><span id="826f" class="mv lj iq mr b gy na mx l my mz">    def get_users():<br/>        users = fetch_users_from_dynamodb()<br/>        return users</span><span id="d6bc" class="mv lj iq mr b gy na mx l my mz">    def delete_inactive_user(username):<br/>        delete_user_using_dynamodb_logic()</span></pre></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><p id="e78c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从所有这些例子中可以看出，每种方法类型都有一个很好的用例。有时，您也可以根据自己的编码习惯来选择方法类型，但是在这种情况下，您应该始终考虑其他类型是否是更好的解决方案。</p><p id="979b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">本文到此为止。一如既往，如果你喜欢，请尽情鼓掌:)</p><p id="c867" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我错过了什么，请留下评论。</p><p id="260b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">感谢阅读！</p></div></div>    
</body>
</html>