<html>
<head>
<title>Simple React Application with Flask and Kubernetes Deployment</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有烧瓶和 Kubernetes 部署的简单 React 应用程序</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/simple-react-application-with-flask-and-kubernetes-deployment-cb4dc240e8dc?source=collection_archive---------2-----------------------#2022-03-24">https://blog.devgenius.io/simple-react-application-with-flask-and-kubernetes-deployment-cb4dc240e8dc?source=collection_archive---------2-----------------------#2022-03-24</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/00693b53f06b29cb11a7970025a4ee0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vQJ7M9eekFBTqJGrwzKhjg.png"/></div></div></figure><p id="cdfb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在我完成数学和数据科学的学习后，我需要一个快速而简单的 Web 应用程序来以适当的格式展示我的工作。许多有价值的库和语言有助于建立一个庞大的可伸缩的 web 应用程序。但在我的情况下，我只是需要一个快速和肮脏的解决方案，它适用于演示和项目的开始。成功启动后，您可以决定是否应该添加或更改一些库。</p><h1 id="c0ea" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated"><strong class="ak">第一步:安装必要的库</strong></h1><p id="2829" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">本分步指南中使用的<strong class="jx io">编程语言</strong>:</p><ul class=""><li id="dc05" class="lw lx in jx b jy jz kc kd kg ly kk lz ko ma ks mb mc md me bi translated">计算机编程语言</li><li id="84ca" class="lw lx in jx b jy mf kc mg kg mh kk mi ko mj ks mb mc md me bi translated">java 描述语言</li><li id="6cac" class="lw lx in jx b jy mf kc mg kg mh kk mi ko mj ks mb mc md me bi translated">Go(针对 Docker 和 Kubernetes)</li></ul><p id="5655" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">使用的<strong class="jx io">框架</strong>:</p><ul class=""><li id="f1e5" class="lw lx in jx b jy jz kc kd kg ly kk lz ko ma ks mb mc md me bi translated">瓶</li><li id="d895" class="lw lx in jx b jy mf kc mg kg mh kk mi ko mj ks mb mc md me bi translated">反应堆</li></ul><p id="7179" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对于安装，请遵循他们网站上的在线安装步骤。这里推荐使用 python 的虚拟环境！并为应用程序创建一个文件夹<em class="mk"> my-app </em>。对于步骤 2，导航到终端中的应用程序文件夹。</p><h1 id="906d" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated"><strong class="ak">第二步:创建一个 React 应用</strong></h1><p id="1418" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">为了创建前端文件夹结构，我们需要在终端中使用以下命令。</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="4071" class="mu ku in mq b gy mv mw l mx my">npx create-react-app frontend</span></pre><p id="08e8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们的 react-app 叫做<em class="mk">前端。</em>设置好前端后，我们的项目文件夹设置应该是这样的:</p><p id="6d98" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我的-app <br/> ├──前端<br/>│├──readme . MD<br/>│├──node _ modules<br/>│├──package . JSON<br/>│├──。gitignore <br/> │ ├──公立<br/> │ └── src</p><p id="e028" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">除了前端，我们还创建了一个后端和 Kubernetes 文件夹。后端文件夹是我们的 flask-server，包括一个./static，。/templates 文件夹和 main.py 文件。Kubernetes 文件夹包括我们用于部署的 Kubernetes 文件。结果应该是这样的:</p><p id="5422" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">my-app <br/> ├──前端<br/> ├──后端<br/> │ ├──静态<br/> │ ├──模板<br/>│└──main . py<br/>└──kubernetes</p><p id="f61b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">要让我们的 flask 应用充满活力，请将以下代码粘贴到 main.py 文件中:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="3d18" class="mu ku in mq b gy mv mw l mx my">from flask import Flask, render_template<br/>from flask_cors import CORS</span><span id="d5c0" class="mu ku in mq b gy mz mw l mx my">app = Flask(__name__)<br/>CORS(app)</span><span id="c662" class="mu ku in mq b gy mz mw l mx my">@app.route(“/”)<br/>def my_index():<br/>    return render_template(“index.html”, flask_token=”Hello there!”)</span><span id="b91f" class="mu ku in mq b gy mz mw l mx my">app.run(host=’0.0.0.0', debug=True)</span></pre><h1 id="7d47" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated"><strong class="ak">第三步:打开 React 网络包</strong></h1><p id="5e22" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">现在棘手的部分来了。为了通过 flask 服务器服务 react 应用程序，我们需要运行一个命令并更改一些文件。导航到前端目录:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="cd79" class="mu ku in mq b gy mv mw l mx my">npm run eject</span></pre><p id="2884" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个命令解包 react 应用程序的配置文件。我们需要这样做来改变我们的应用程序到后端目录的构建路径，以便 flask 可以服务它。为此，我们需要更改文件:</p><ul class=""><li id="8bb0" class="lw lx in jx b jy jz kc kd kg ly kk lz ko ma ks mb mc md me bi translated">网络包.配置. js</li><li id="40e3" class="lw lx in jx b jy mf kc mg kg mh kk mi ko mj ks mb mc md me bi translated">paths.js</li></ul><p id="eaf3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在前端文件夹中，我们发现了一个新的文件夹<em class="mk"> config </em>，我们可以在其中找到这些文件。</p><p id="5076" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">打开 paths.js 文件，用下面一行更改 appBuild 条目:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="b7dc" class="mu ku in mq b gy mv mw l mx my">appBuild: resolveApp(‘../backend/static/react’),</span></pre><p id="5423" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在构建 react-app 之后，我们会注意到所有创建的文件都将位于并保存在这个文件夹中。</p><p id="7dbe" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，让我们打开 webpack.config.js 文件，找到以下代码:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="22a4" class="mu ku in mq b gy mv mw l mx my">new HtmlWebpackPlugin(<br/>       Object.assign(<br/>        {},<br/>        {<br/>          inject: true,<br/>          template: paths.appHtml,<br/>          filename: “../../templates/index.html” //line added<br/>        },<br/>        isEnvProduction<br/>          ? {<br/>              minify: {<br/>                 removeComments: true,<br/>                 collapseWhitespace: true,<br/>                 removeRedundantAttributes: true,<br/>                 useShortDoctype: true,<br/>                 removeEmptyAttributes: true,<br/>                 removeStyleLinkTypeAttributes: true,<br/>                 keepClosingSlash: true,<br/>                 minifyJS: true,<br/>                 minifyCSS: true,<br/>                 minifyURLs: true,<br/>                },<br/>            }<br/>          : undefined<br/>       )<br/>   ),</span></pre><p id="f81f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们添加了带有文件名的行。它是我们后端文件夹中的目录。</p><p id="62c1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">react 环境中的最后一个变化是前端目录中的 package.json 文件。我们需要在文件末尾添加一个新的变量主页，这样应用程序就知道在哪里放置 javascript 和 CSS 的链接。在最后一个括号结束之前添加这一行。</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="e870" class="mu ku in mq b gy mv mw l mx my">“homepage”: “/static/react”, </span></pre><h1 id="ea13" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated"><strong class="ak">步骤 4:运行烧瓶应用程序</strong></h1><p id="fb94" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">现在我们可以检查一切是否正常工作，flask 是否正确地为 react 应用程序提供服务。</p><p id="2c0e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在终端的前端目录中运行</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="78ff" class="mu ku in mq b gy mv mw l mx my">npm run build</span></pre><p id="f745" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">并检查新的输出文件是否保存在 static 和 templates 目录下的后端文件夹中。</p><p id="2097" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果是这种情况，重定向到终端中的后端目录并运行</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="91d0" class="mu ku in mq b gy mv mw l mx my">python main.py</span></pre><p id="c41f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">通过浏览器进入<a class="ae na" href="http://localhost:5000" rel="noopener ugc nofollow" target="_blank"> http://localhost:5000 </a>查看应用程序是否运行。</p><h1 id="94ab" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated"><strong class="ak">第五步:创建 Dockerfiles </strong></h1><p id="1ce8" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">Dockerfiles，因为我们希望将我们的应用程序部署到 Kubernetes 或任何其他地方。在 docker 文件中准备好您的应用程序总是好的。当我们创建生产构建时，我们需要构建一个 docker 文件。如果您想开发和更改 react 应用程序，您需要运行不同的设置来查看 react 应用程序中的更改。但是在这里，我们希望将我们的应用程序部署到 Kubernetes 集群中，我们在该集群中使用生产就绪的构建。</p><p id="4c12" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">后端的 docker 文件如下所示:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="060b" class="mu ku in mq b gy mv mw l mx my">FROM python:3.8.1-slim-buster as builder<br/>WORKDIR /usr/src/app</span><span id="254a" class="mu ku in mq b gy mz mw l mx my">ENV PYTHONDONTWRITEBYTECODE 1<br/>ENV PYTHONUNBUFFERED 1</span><span id="b036" class="mu ku in mq b gy mz mw l mx my">RUN apt-get update &amp;&amp; \<br/>apt-get install -y — no-install-recommends gcc<br/>RUN pip install — upgrade pip<br/>RUN pip install flake8</span><span id="3fcd" class="mu ku in mq b gy mz mw l mx my">COPY . /usr/src/app/<br/>COPY ./requirements.txt .</span><span id="007b" class="mu ku in mq b gy mz mw l mx my">RUN pip wheel — no-cache-dir — no-deps — wheel-dir /usr/src/app/wheels -r requirements.txt</span><span id="0992" class="mu ku in mq b gy mz mw l mx my">FROM python:3.8.1-slim-buster<br/>RUN mkdir -p /home/app<br/>RUN addgroup — system app &amp;&amp; adduser — system — group app</span><span id="c70e" class="mu ku in mq b gy mz mw l mx my">ENV HOME=/home/app<br/>ENV APP_HOME=/home/app/backend</span><span id="7065" class="mu ku in mq b gy mz mw l mx my">RUN mkdir $APP_HOME</span><span id="ddac" class="mu ku in mq b gy mz mw l mx my">WORKDIR $APP_HOME</span><span id="c78b" class="mu ku in mq b gy mz mw l mx my">RUN apt-get update &amp;&amp; apt-get install -y — no-install-recommends netcat</span><span id="6dd2" class="mu ku in mq b gy mz mw l mx my">COPY — from=builder /usr/src/app/wheels /wheels<br/>COPY — from=builder /usr/src/app/requirements.txt .</span><span id="2fdf" class="mu ku in mq b gy mz mw l mx my">RUN pip install — upgrade pip<br/>RUN pip install — no-cache /wheels/*</span><span id="5c7a" class="mu ku in mq b gy mz mw l mx my">COPY ./entrypoint.prod.sh $APP_HOME<br/>COPY . $APP_HOME</span><span id="0def" class="mu ku in mq b gy mz mw l mx my">RUN chown -R app:app $APP_HOME<br/>USER app</span><span id="bf0d" class="mu ku in mq b gy mz mw l mx my">ENTRYPOINT [“/home/app/backend/entrypoint.sh”]</span></pre><p id="5197" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如您所见，Dockerfile 文件相当长。不要害怕它；复制粘贴！但是这里需要提到的一点是，除了 Dockerfile 之外，我们还需要创建两个额外的文件。像 docker 文件一样，将它们放在后端目录中。一个文件是我们虚拟环境的 requirements.txt:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="43eb" class="mu ku in mq b gy mv mw l mx my">pip freeze &gt; requirements.txt  </span></pre><p id="a451" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">第二个文件是 entrypoint.sh 文件，它处理启动 flask 应用程序的命令。它既可以在 Kubernetes 文件中完成，也可以通过 done 文件完成。这看起来很简单:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="de03" class="mu ku in mq b gy mv mw l mx my">#!/bin/sh<br/>python main.py<br/>exec “$@”</span></pre><h1 id="0d44" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated"><strong class="ak">第六步:测试并发布 Dockerfile </strong></h1><p id="eaa7" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">创建 docker 文件后，需要对其进行测试和发布。要尝试它，通过命令行构建 Docker 映像(通过终端导航到后端文件夹):</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="78eb" class="mu ku in mq b gy mv mw l mx my">docker build -t yourusername/my-app .</span></pre><p id="6d66" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果构建成功，您可以快速启动应用程序:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="dfbd" class="mu ku in mq b gy mv mw l mx my">docker run -p5000:5000 yourusername/my-app</span></pre><p id="f0b5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个命令将在我们的本地环境中创建应用程序，我们可以使用<a class="ae na" href="http://localhost:5000" rel="noopener ugc nofollow" target="_blank"> http://localhost:5000 </a>访问它。</p><p id="9813" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果一切正常，我们需要将我们的图像发布到 Docker 存储库中，以便 Kubernetes 可以找到它:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="5f09" class="mu ku in mq b gy mv mw l mx my">docker login</span></pre><p id="6b9e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">用版本号重新标记图像:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="e5f3" class="mu ku in mq b gy mv mw l mx my">docker tag yourusername/my-app yourdockerhubusername/my-app:v1</span></pre><p id="f639" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后推动以下内容:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="0291" class="mu ku in mq b gy mv mw l mx my">docker push yourdockerhubusername/my-app:v1</span></pre><h1 id="05f6" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated"><strong class="ak">步骤 7:创建 Kubernetes 文件</strong></h1><p id="27e7" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">当你是 Kubernetes 的初学者时，我建议先看一个教程。如果你不想这样做，复制 Kubernetes 文件，准备好了。</p><p id="3842" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在本文中，我们不会讨论 Kubernetes 集群以及如何启动一个集群。它还依赖于您的 Kubernetes 集群，即您需要的文件。例如，在您的 Kubernetes 文件中需要考虑网络策略或不同的安全问题。但是假设我们有一个相当开放的 Kubernetes 集群在运行。我们首先需要为其中的项目创建一个名称空间。由于我们已经在文件夹结构中创建了一个文件夹 Kubernetes，我们将在其中创建所有文件。</p><p id="0561" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="mk"> MyApp-namespace.yaml: </em></p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="de9a" class="mu ku in mq b gy mv mw l mx my">apiVersion: v1<br/>kind: Namespace<br/>metadata:<br/>   name: myapp<br/>   labels:<br/>      name: myapp</span></pre><p id="5914" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这个名称空间下，将为我们的应用程序重新定位空间。现在让我们创建<em class="mk"> MyApp-deployment.yaml: </em></p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="736d" class="mu ku in mq b gy mv mw l mx my">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata: <br/>   creationTimestamp: null <br/>   labels: <br/>       name: myapp <br/>   name: myapp   <br/>   namespace: myapp<br/>spec: <br/>   replicas: 1 <br/>   selector: <br/>       matchLabels: <br/>           name: myapp <br/>       strategy: <br/>           type: Recreate <br/>       template: <br/>           metadata: <br/>              creationTimestamp: null <br/>              labels: <br/>                  name: myapp <br/>           spec: <br/>              containers: <br/>                  — args: <br/>                      — python<br/>                      — main.py <br/>                    image: yourdockerhubusername/my-app:v1 <br/>                    name: myapp<br/>                    ports: <br/>                      — containerPort: 5000 <br/>               restartPolicy: Always</span></pre><p id="4aef" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对你来说，这个文件中最重要的部分是<em class="mk">图片</em>行，你需要在这里插入你发布的 Docker 图片的链接。</p><p id="a5da" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">可能是需要添加一些安全方面的问题，比如 securityContext。</p><p id="c4ef" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们要创建的以下文件是<em class="mk"> MyApp-service.yaml </em>:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="06fd" class="mu ku in mq b gy mv mw l mx my">apiVersion: v1<br/>kind: Service<br/>metadata: <br/>   creationTimestamp: null <br/>   labels: <br/>       name: myapp <br/>   name: myapp<br/>   namespace: myapp<br/>spec: <br/>   ports: <br/>      — name: “5000” <br/>        port: 5000 <br/>        targetPort: 5000 <br/>   selector: <br/>      name: myapp<br/>status: loadBalancer: {}</span></pre><p id="8ffb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们的部署可以用这个文件在 Kubernetes 集群中“对话”。</p><p id="a28b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后一步，我们想创建一个 URL，在这个 URL 上我们可以查看我们部署的应用程序。</p><p id="3abc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="mk"> MyApp-ingress.yaml: </em></p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="18cc" class="mu ku in mq b gy mv mw l mx my">apiVersion: networking.k8s.io/v1<br/>kind: Ingress<br/>metadata: <br/>    name: ingress-myapp <br/>    annotations: <br/>        nginx.ingress.kubernetes.io/rewrite-target: /$1<br/>spec: <br/>    rules: <br/>       — host: myapp.link.com<br/>         http: <br/>            paths:<br/>               — path: / <br/>                 pathType: Prefix <br/>                 backend: <br/>                     service: <br/>                         name: myapp<br/>                         port: <br/>                            number: 5000</span></pre><p id="45ce" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们现在创建了一个通过 flask 提供的生产就绪型 react 应用程序，并将其部署在 Kubernetes 集群上。正如我之前提到的，这是一个快速且容易构建的解决方案，如果您想要为拥有超过 1000 名用户的公司提供一个可扩展的解决方案，那么不推荐使用它。然后你需要添加不同的框架和不同于 flask 的服务器。</p><h1 id="4e70" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated"><strong class="ak">结论</strong></h1><p id="a5f9" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">有了这个简单的工具箱和管道，您可以快速部署您的应用程序进行演示，这样每个人都可以看到您的解决方案和应用程序。当然，您也可以为您的应用程序添加不同的设置，在 Kubernetes 集群中添加其他服务，并通过 Github Actions 添加 CD/CI-Pipeline 来加快部署。</p></div></div>    
</body>
</html>