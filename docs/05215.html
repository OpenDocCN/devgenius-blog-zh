<html>
<head>
<title>[Refactoring] Inspect Method Extraction From LeetCode</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">[重构]检查从LeetCode提取的方法</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/refactoring-review-method-extraction-from-leetcode-ebb85371ab6d?source=collection_archive---------8-----------------------#2021-07-02">https://blog.devgenius.io/refactoring-review-method-extraction-from-leetcode-ebb85371ab6d?source=collection_archive---------8-----------------------#2021-07-02</a></blockquote><div><div class="fc ic id ie if ig"/><div class="ih ii ij ik il"><div class=""/><h1 id="4929" class="jl jm io bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">重复代码的难闻气味</h1><p id="94df" class="pw-post-body-paragraph kj kk io kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ih bi translated">事实上，这是开发人员工作中几乎每天都会遇到的常见情况，尤其是当您试图通过从某处复制和粘贴相同的代码来快速完成一些逻辑时。因为你的源代码似乎由几个冗余的、相同的代码组成，所以出现了不好的味道。</p><figure class="li lj lk ll gu lm gi gj paragraph-image"><div class="gi gj lh"><img src="../Images/315c864369dd7c43ce7e8a30e60a8f40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*jvHbQ_wB00U-0yDxlJ2_Yg.png"/></div></figure><p id="6559" class="pw-post-body-paragraph kj kk io kl b km lp ko kp kq lq ks kt ku lr kw kx ky ls la lb lc lt le lf lg ih bi translated">大多数开发者关心这个问题吗？当你的项目规模仍然很小时，这可能不会有太大的影响。然而，当项目规模扩大时，在项目中留下重复代码的习惯会给后续维护带来风险，因为这不仅降低了项目的可读性，还降低了项目的可维护性。</p><p id="4bf4" class="pw-post-body-paragraph kj kk io kl b km lp ko kp kq lq ks kt ku lr kw kx ky ls la lb lc lt le lf lg ih bi translated">为了消除不好的味道，团队成员应该遵守一个规则<strong class="kl ip">尽可能重用相同逻辑的功能，而不是在不同的源代码位置生成相同的代码</strong>。</p></div><div class="ab cl lu lv hs lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ih ii ij ik il"><h1 id="153c" class="jl jm io bd jn jo mb jq jr js mc ju jv jw md jy jz ka me kc kd ke mf kg kh ki bi translated">方法提取</h1><p id="1733" class="pw-post-body-paragraph kj kk io kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ih bi translated">下面以LeetCode中的一道题，<a class="ae mg" href="https://leetcode.com/problems/add-two-numbers/" rel="noopener ugc nofollow" target="_blank">加二数</a>为例来说明<strong class="kl ip">方法提取</strong>的概念。试着自己解决问题；检查你的来源是否有异味。</p><p id="4b8c" class="pw-post-body-paragraph kj kk io kl b km lp ko kp kq lq ks kt ku lr kw kx ky ls la lb lc lt le lf lg ih bi translated">例如，下面的源代码是我对这个问题的解决方案，它试图将两个由列表表示的数字相加。每个节点包含一个数字，它们的列表长度可能不同。</p><figure class="li lj lk ll gu lm"><div class="bz fq l di"><div class="mh mi l"/></div></figure><p id="d756" class="pw-post-body-paragraph kj kk io kl b km lp ko kp kq lq ks kt ku lr kw kx ky ls la lb lc lt le lf lg ih bi translated">为了解决这个问题，我遍历了两个列表，计算了每个节点值和下一个数字(如果两个数字之和大于10)。在这一段中，我不打算解释这个问题是如何基于某种逻辑或其他任何东西解决的细节。这将留给读者去思考。我想请你帮我从源代码中找出一些不好的味道；尝试改进它们，使其更具可读性和可维护性。</p><p id="6e62" class="pw-post-body-paragraph kj kk io kl b km lp ko kp kq lq ks kt ku lr kw kx ky ls la lb lc lt le lf lg ih bi translated">如果您仔细阅读了它，我想您会发现一些在下面的示例代码中出现了多次的“重复”片段。在我看来，我想把相同的逻辑分成两类。</p><p id="f2c6" class="pw-post-body-paragraph kj kk io kl b km lp ko kp kq lq ks kt ku lr kw kx ky ls la lb lc lt le lf lg ih bi translated">首先，对节点值求和决定了新节点的值。从上面的主旨来看，这个逻辑分散在源的周围，混合着做同一件事的各种变量！这是一种难闻的气味。</p><figure class="li lj lk ll gu lm"><div class="bz fq l di"><div class="mh mi l"/></div></figure><p id="48e2" class="pw-post-body-paragraph kj kk io kl b km lp ko kp kq lq ks kt ku lr kw kx ky ls la lb lc lt le lf lg ih bi translated">其次，计算下一个可能数字的逻辑重复了几次，这在整个上下文中是明显可见的。这也是一种不好的气味！</p><figure class="li lj lk ll gu lm"><div class="bz fq l di"><div class="mh mi l"/></div></figure><p id="2333" class="pw-post-body-paragraph kj kk io kl b km lp ko kp kq lq ks kt ku lr kw kx ky ls la lb lc lt le lf lg ih bi translated">为了减少不好的味道，我们通常应用<strong class="kl ip">方法提取</strong>来简化编程逻辑。<strong class="kl ip"> <em class="mj">顾名思义，它从源代码中提取常见的逻辑，并重新编写到某些函数中，以极大地消除程序的冗余</em> </strong> <em class="mj">。</em></p><p id="d7fc" class="pw-post-body-paragraph kj kk io kl b km lp ko kp kq lq ks kt ku lr kw kx ky ls la lb lc lt le lf lg ih bi translated">例如，我们可以将这两个逻辑重新定义为下面的函数，这样这两个组的行为将更加清晰易读。</p><figure class="li lj lk ll gu lm"><div class="bz fq l di"><div class="mh mi l"/></div></figure><figure class="li lj lk ll gu lm"><div class="bz fq l di"><div class="mh mi l"/></div></figure><p id="bcaf" class="pw-post-body-paragraph kj kk io kl b km lp ko kp kq lq ks kt ku lr kw kx ky ls la lb lc lt le lf lg ih bi translated">再来重新贴一下这个问题的解决方案的整体来源。在通过方法提取细化逻辑之后，它的可读性如预期的那样增加了。也许有些读者想通过其他方法进一步优化它。欢迎在下面评论！</p><figure class="li lj lk ll gu lm"><div class="bz fq l di"><div class="mh mi l"/></div></figure><h1 id="2f98" class="jl jm io bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">蔻驰的低语声</h1><p id="fbfb" class="pw-post-body-paragraph kj kk io kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ih bi translated">对于许多开发人员来说，通过重新编写函数来简化重复的逻辑来重构代码是非常常见的。然而，随着项目规模的扩大，这种习惯可能很难继续下去，这会导致复杂的、重复的片段分散在各个源代码中。</p><p id="e714" class="pw-post-body-paragraph kj kk io kl b km lp ko kp kq lq ks kt ku lr kw kx ky ls la lb lc lt le lf lg ih bi translated">从我的经验来看，为团队建立一个共同的规则来培养不生成冗余代码的共识会更好。在一个Scrum团队中，他们可能会提议将这条规则添加到他们的DoD(完成的定义)中，以防止不好的气味发生。</p></div></div>    
</body>
</html>