<html>
<head>
<title>Understanding Kubernetes Probes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解Kubernetes探头</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/understanding-kubernetes-probes-5daaff67599a?source=collection_archive---------0-----------------------#2020-08-02">https://blog.devgenius.io/understanding-kubernetes-probes-5daaff67599a?source=collection_archive---------0-----------------------#2020-08-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="9778" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">配置就绪、活动和启动探测器，以检测和处理不正常的pod。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/1a7b70a5755a28218692bf3726fcc22b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TEW6JxabCexdRuE_7KwpfQ.png"/></div></div></figure><p id="3ffb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">分布式系统和微服务架构的挑战之一是自动检测不健康的应用程序，将请求重新路由到其他可用系统，并恢复损坏的组件。健康检查是应对这一挑战并确保可靠性的一种方式。使用Kubernetes，通过探针配置健康检查，以确定每个pod的状态。</p><p id="fa76" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">默认情况下，Kubernetes只是观察pod的生命周期，并在容器从<code class="fe kx ky kz la b">Pending</code>状态转移到<code class="fe kx ky kz la b">Succeeded</code>状态时开始将流量路由到pod。Kubelet还监视应用程序崩溃，并重启pod进行恢复。许多开发人员认为这种基本设置已经足够了，尤其是当pod内部的应用程序配置了守护进程管理器(例如Node.js的PM2)时。但是，由于Kubernetes认为一个pod是健康的，只要所有容器启动，就可以接受请求，所以应用程序可能在实际准备好之前就接收流量。如果应用程序需要在处理应用程序逻辑之前初始化某些状态、建立数据库连接或加载数据，就会发生这种情况。当部署开始扩展，未准备好的应用程序接收流量并发回500个错误时，应用程序实际准备好的时间与Kubernetes认为准备好的时间之间的差距就成了一个问题。</p><p id="6a93" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是Kubernetes探测器用来定义容器何时准备好接受流量以及容器何时应该重新启动的地方。从Kubernetes 1.16开始，现在支持三种类型的探针。在本帖中，我们将回顾不同类型的探测、最佳实践和工具，以检测具有潜在配置问题的部署。</p><h1 id="f97c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">Kubernetes探针</h1><p id="e48c" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">Kubernetes支持≤ 1.15版本的就绪性和活性探测。启动探针是在1.16中作为alpha特性添加的，并在1.18中升级为beta特性(<em class="me">警告:1.16不赞成使用几个Kubernetes APIs。使用本</em> <a class="ae mf" href="https://medium.com/dev-genius/upgrading-to-kubernetes-1-16-ad977933694d" rel="noopener"> <em class="me">迁移指南</em> </a> <em class="me">检查兼容性</em>。</p><p id="9578" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所有探头都有以下参数:</p><ul class=""><li id="4344" class="mg mh iq jp b jq jr ju jv jy mi kc mj kg mk kk ml mm mn mo bi translated"><code class="fe kx ky kz la b">initialDelaySeconds</code>:启动活动或就绪探测前等待的秒数</li><li id="67a8" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated"><code class="fe kx ky kz la b">periodSeconds</code>:多久检查一次探头</li><li id="0f11" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated"><code class="fe kx ky kz la b">timeoutSeconds</code>:将探头标记为超时(运行状况检查失败)前的秒数</li><li id="da8f" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated"><code class="fe kx ky kz la b">successThreshold</code>:探针通过的最小连续成功检查次数</li><li id="c088" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated"><code class="fe kx ky kz la b">failureThreshold</code>:将探头标记为失败前的重试次数。对于活性探针，这将导致pod重新启动。对于就绪探测，这将把pod标记为未就绪。</li></ul><h2 id="84a4" class="mu lc iq bd ld mv mw dn lh mx my dp ll jy mz na lp kc nb nc lt kg nd ne lx nf bi translated">就绪探测</h2><p id="ad17" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">准备就绪探测器用于让kubelet知道应用程序何时准备好接受新的流量。如果应用程序在流程开始后需要一些时间来初始化状态，那么可以配置就绪探测来告诉Kubernetes在发送新流量之前等待。就绪性探测的一个主要用例是将流量导向服务背后的部署。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ng"><img src="../Images/0a55120389ccdccf45f1cb8817fa2457.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*AvaYbgMkeHJ0Pis8.GIF"/></div></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk translated">图片来源:<a class="ae mf" href="https://cloud.google.com/blog/products/gcp/kubernetes-best-practices-setting-up-health-checks-with-readiness-and-liveness-probes" rel="noopener ugc nofollow" target="_blank"> GCP博客</a></figcaption></figure><p id="4bd0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">准备就绪探测器需要注意的一件重要事情是，它<strong class="jp ir">会在pod的整个生命周期</strong>中运行。这意味着准备就绪探测器不仅会在启动时运行，而且会在pod运行期间反复运行。这是为了处理应用程序暂时不可用的情况(即加载大量数据、等待外部连接)。在这种情况下，我们不一定要终止应用程序，而是等待它恢复。准备就绪探测器用于检测这种情况，并且不会向这些pod发送流量，直到它再次通过准备就绪检查。</p><h2 id="29ef" class="mu lc iq bd ld mv mw dn lh mx my dp ll jy mz na lp kc nb nc lt kg nd ne lx nf bi translated">活性探针</h2><p id="3dda" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">另一方面，活性探测用于重启不健康的容器。kubelet定期向活性探测器发出pings命令，确定其健康状况，如果活性检查失败，就会杀死pod。活性检查可以帮助应用程序从死锁状态中恢复。在没有活性检查的情况下，Kubernetes认为死锁的pod是健康的，因为从Kubernetes的角度来看，底层进程继续运行。通过配置活跃度探测器，kubelet可以检测到应用程序处于不良状态，并重启pod以恢复可用性。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ng"><img src="../Images/d34d19591dd53cc83a33522c0feb331b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yicsIyLNZJlDlIsf.GIF"/></div></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk translated">图片来源:<a class="ae mf" href="https://cloud.google.com/blog/products/gcp/kubernetes-best-practices-setting-up-health-checks-with-readiness-and-liveness-probes" rel="noopener ugc nofollow" target="_blank"> GCP博客</a></figcaption></figure><h2 id="1b53" class="mu lc iq bd ld mv mw dn lh mx my dp ll jy mz na lp kc nb nc lt kg nd ne lx nf bi translated"><strong class="ak">启动探针</strong></h2><p id="b460" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">启动探测类似于就绪探测，但只在启动时执行。它们针对启动缓慢的容器或初始化过程不可预测的应用程序进行了优化。通过准备就绪探测，我们可以配置<code class="fe kx ky kz la b">initialDelaySeconds</code>来确定在探测准备就绪之前要等待多长时间。现在考虑一个应用程序，它偶尔需要下载大量数据或在进程开始时执行一个昂贵的操作。由于<code class="fe kx ky kz la b">initialDelaySeconds</code>是一个静态数字，我们被迫总是采取最坏的情况(或者扩展可能影响长时间运行行为的<code class="fe kx ky kz la b">failureThreshold</code>)并等待很长时间，即使该应用程序不需要执行长时间运行的初始化步骤。使用启动探测器，我们可以配置<code class="fe kx ky kz la b">failureThreshold</code>和<code class="fe kx ky kz la b">periodSeconds</code>来更好地模拟这种不确定性。例如，将<code class="fe kx ky kz la b">failureThreshold</code>设置为15，将<code class="fe kx ky kz la b">periodSeconds</code>设置为5，这意味着应用程序在失败前需要15 x 5 = 75s才能启动。</p><h1 id="3622" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">配置探测操作</h1><p id="1c44" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">现在我们已经了解了不同类型的探测器，我们可以研究配置每个探测器的三种不同方式。</p><h2 id="245d" class="mu lc iq bd ld mv mw dn lh mx my dp ll jy mz na lp kc nb nc lt kg nd ne lx nf bi translated"><strong class="ak"> HTTP </strong></h2><p id="74bd" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">kubelet向一个端点发送一个HTTP GET请求，并检查2xx或3xx响应。您可以重用现有的HTTP端点，或者设置一个轻量级HTTP服务器用于探测目的(例如，带有<code class="fe kx ky kz la b">/healthz</code>端点的Express服务器)。</p><p id="0760" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">HTTP探测器接受额外的参数:</p><ul class=""><li id="1b7f" class="mg mh iq jp b jq jr ju jv jy mi kc mj kg mk kk ml mm mn mo bi translated"><code class="fe kx ky kz la b">host</code>:要连接的主机名(默认:pod的IP)</li><li id="99be" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated"><code class="fe kx ky kz la b">scheme</code> : HTTP(默认)或HTTPS</li><li id="f5e3" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated"><code class="fe kx ky kz la b">path</code>:HTTP/S服务器上的路径</li><li id="cfb4" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated"><code class="fe kx ky kz la b">httpHeaders</code>:自定义标题，如果您需要用于验证、CORS设置等的标题值</li><li id="3414" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated"><code class="fe kx ky kz la b">port</code>:访问服务器的端口名称或端口号</li></ul><pre class="km kn ko kp gt nl la nm nn aw no bi"><span id="c504" class="mu lc iq la b gy np nq l nr ns">livenessProbe:<br/>   httpGet:<br/>     path: /healthz<br/>     port: 8080</span></pre><h2 id="ed8f" class="mu lc iq bd ld mv mw dn lh mx my dp ll jy mz na lp kc nb nc lt kg nd ne lx nf bi translated">传输控制协议（Transmission Control Protocol）</h2><p id="74f5" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">如果您只需要检查是否可以建立TCP连接，您可以指定一个TCP探测器。如果可以建立TCP连接，则pod标记为健康。对于不适合HTTP调用的gRPC或FTP服务器，使用TCP探测可能很有用。</p><pre class="km kn ko kp gt nl la nm nn aw no bi"><span id="d3de" class="mu lc iq la b gy np nq l nr ns">readinessProbe:<br/>   tcpSocket:<br/>     port: 21</span></pre><h2 id="0a7d" class="mu lc iq bd ld mv mw dn lh mx my dp ll jy mz na lp kc nb nc lt kg nd ne lx nf bi translated">命令</h2><p id="24e0" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">最后，可以将探测器配置为运行shell命令。如果命令返回退出代码0，则检查通过；否则，该pod被标记为不健康。如果不希望公开HTTP服务器/端口，或者如果通过命令检查初始化步骤更容易(例如，检查是否创建了配置文件，运行CLI命令)，这种类型的探测器可能会很有用。</p><pre class="km kn ko kp gt nl la nm nn aw no bi"><span id="4b09" class="mu lc iq la b gy np nq l nr ns">readinessProbe:<br/>   exec:<br/>     command: ["/bin/sh", "-ec", "vault status -tls-skip-verify"]</span></pre><h1 id="f849" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">最佳实践</h1><p id="f4e7" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">探测器的确切参数取决于您的应用程序，但这里有一些开始使用的一般最佳实践:</p><ul class=""><li id="91bb" class="mg mh iq jp b jq jr ju jv jy mi kc mj kg mk kk ml mm mn mo bi translated">对于较旧的(≤ 1.15) Kubernetes集群，使用具有初始延迟的就绪探测器来处理容器启动阶段(为此使用p99次)。但是要让这个检查变得轻量级，因为准备就绪探测将在pod的整个生命周期中执行。我们不希望探测超时，因为就绪检查需要很长时间来计算。</li><li id="cdb5" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated">对于较新的(≥ 1.16) Kubernetes集群，对启动时间不可预测或可变的应用程序使用启动探测器。启动探针可以与准备就绪和活性探针共享相同的端点(例如<code class="fe kx ky kz la b">/healthz</code>),但是将<code class="fe kx ky kz la b">failureThreshold</code>设置得比其他探针高，以考虑更长的启动时间，但是对于活性和准备就绪检查来说更合理的故障时间。</li><li id="2e02" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated">如果准备就绪探测不用于其他信令目的，则准备就绪探测和活性探测可以共享同一个端点。如果只有一个pod(即使用垂直Pod自动缩放器)，请设置就绪探测器来处理启动行为，并使用活性探测器来确定健康状况。在这种情况下，将pod标记为不健康意味着停机。</li><li id="d53e" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated">准备就绪检查可以以各种方式用于发出系统降级的信号。例如，如果应用程序失去了与数据库的连接，可以使用就绪探测来暂时阻止新的请求，并允许系统重新连接。还可以通过将繁忙的pod标记为未就绪来将工作负载平衡到其他pod。</li></ul><p id="9a03" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">简而言之，定义良好的探针通常会带来更好的弹性和可用性。确保观察启动时间和系统行为，以便随着应用程序的变化调整探头设置。</p><h1 id="e44b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">工具</h1><p id="71c8" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">最后，考虑到Kubernetes探针的重要性，您可以使用Kubernetes资源分析工具来检测缺失的探针。这些工具可以针对现有集群运行，或者嵌入到CI/CD流程中，以便在没有正确配置资源的情况下自动拒绝工作负载。</p><ul class=""><li id="eb7b" class="mg mh iq jp b jq jr ju jv jy mi kc mj kg mk kk ml mm mn mo bi translated"><a class="ae mf" href="https://github.com/FairwindsOps/polaris" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">【北极星】</strong> </a>:一个资源分析工具，有一个漂亮的仪表盘，也可以用作验证webhook或CLI工具。</li><li id="ace4" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated"><a class="ae mf" href="https://github.com/zegl/kube-score" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> kube-score </strong> </a>:一个静态代码分析工具，可以处理Helm、Kustomize和标准YAML文件。</li><li id="dc54" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated"><a class="ae mf" href="https://github.com/derailed/popeye" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">Popeye</strong></a><strong class="jp ir">:</strong>只读实用工具，用于扫描Kubernetes集群并报告配置的潜在问题。</li></ul></div></div>    
</body>
</html>