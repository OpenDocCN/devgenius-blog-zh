<html>
<head>
<title>Understanding Kubernetes Probes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解 Kubernetes 探头</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/understanding-kubernetes-probes-5daaff67599a?source=collection_archive---------0-----------------------#2020-08-02">https://blog.devgenius.io/understanding-kubernetes-probes-5daaff67599a?source=collection_archive---------0-----------------------#2020-08-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="9778" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">配置就绪、活动和启动探测器，以检测和处理不正常的 pod。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/1a7b70a5755a28218692bf3726fcc22b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TEW6JxabCexdRuE_7KwpfQ.png"/></div></div></figure><p id="3ffb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">分布式系统和微服务架构的挑战之一是自动检测不健康的应用程序，将请求重新路由到其他可用系统，并恢复损坏的组件。健康检查是应对这一挑战并确保可靠性的一种方式。使用 Kubernetes，通过探针配置健康检查，以确定每个 pod 的状态。</p><p id="fa76" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">默认情况下，Kubernetes 只是观察 pod 的生命周期，并在容器从<code class="fe kx ky kz la b">Pending</code>状态转移到<code class="fe kx ky kz la b">Succeeded</code>状态时开始将流量路由到 pod。Kubelet 还监视应用程序崩溃，并重启 pod 进行恢复。许多开发人员认为这种基本设置已经足够了，尤其是当 pod 内部的应用程序配置了守护进程管理器(例如 Node.js 的 PM2)时。但是，由于 Kubernetes 认为一个 pod 是健康的，只要所有容器启动，就可以接受请求，所以应用程序可能在实际准备好之前就接收流量。如果应用程序需要在处理应用程序逻辑之前初始化某些状态、建立数据库连接或加载数据，就会发生这种情况。当部署开始扩展，未准备好的应用程序接收流量并发回 500 个错误时，应用程序实际准备好的时间与 Kubernetes 认为准备好的时间之间的差距就成了一个问题。</p><p id="6a93" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是 Kubernetes 探测器用来定义容器何时准备好接受流量以及容器何时应该重新启动的地方。从 Kubernetes 1.16 开始，现在支持三种类型的探针。在本帖中，我们将回顾不同类型的探测、最佳实践和工具，以检测具有潜在配置问题的部署。</p><h1 id="f97c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">Kubernetes 探针</h1><p id="e48c" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">Kubernetes 支持≤ 1.15 版本的就绪性和活性探测。启动探针是在 1.16 中作为 alpha 特性添加的，并在 1.18 中升级为 beta 特性(<em class="me">警告:1.16 不赞成使用几个 Kubernetes APIs。使用本</em> <a class="ae mf" href="https://medium.com/dev-genius/upgrading-to-kubernetes-1-16-ad977933694d" rel="noopener"> <em class="me">迁移指南</em> </a> <em class="me">检查兼容性</em>。</p><p id="9578" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所有探头都有以下参数:</p><ul class=""><li id="4344" class="mg mh iq jp b jq jr ju jv jy mi kc mj kg mk kk ml mm mn mo bi translated"><code class="fe kx ky kz la b">initialDelaySeconds</code>:启动活动或就绪探测前等待的秒数</li><li id="67a8" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated"><code class="fe kx ky kz la b">periodSeconds</code>:多久检查一次探头</li><li id="0f11" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated"><code class="fe kx ky kz la b">timeoutSeconds</code>:将探头标记为超时(运行状况检查失败)前的秒数</li><li id="da8f" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated"><code class="fe kx ky kz la b">successThreshold</code>:探针通过的最小连续成功检查次数</li><li id="c088" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated"><code class="fe kx ky kz la b">failureThreshold</code>:将探头标记为失败前的重试次数。对于活性探针，这将导致 pod 重新启动。对于就绪探测，这将把 pod 标记为未就绪。</li></ul><h2 id="84a4" class="mu lc iq bd ld mv mw dn lh mx my dp ll jy mz na lp kc nb nc lt kg nd ne lx nf bi translated">就绪探测</h2><p id="ad17" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">准备就绪探测器用于让 kubelet 知道应用程序何时准备好接受新的流量。如果应用程序在流程开始后需要一些时间来初始化状态，那么可以配置就绪探测来告诉 Kubernetes 在发送新流量之前等待。就绪性探测的一个主要用例是将流量导向服务背后的部署。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ng"><img src="../Images/0a55120389ccdccf45f1cb8817fa2457.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*AvaYbgMkeHJ0Pis8.GIF"/></div></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk translated">图片来源:<a class="ae mf" href="https://cloud.google.com/blog/products/gcp/kubernetes-best-practices-setting-up-health-checks-with-readiness-and-liveness-probes" rel="noopener ugc nofollow" target="_blank"> GCP 博客</a></figcaption></figure><p id="4bd0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">准备就绪探测器需要注意的一件重要事情是，它<strong class="jp ir">会在 pod 的整个生命周期</strong>中运行。这意味着准备就绪探测器不仅会在启动时运行，而且会在 pod 运行期间反复运行。这是为了处理应用程序暂时不可用的情况(即加载大量数据、等待外部连接)。在这种情况下，我们不一定要终止应用程序，而是等待它恢复。准备就绪探测器用于检测这种情况，并且不会向这些 pod 发送流量，直到它再次通过准备就绪检查。</p><h2 id="29ef" class="mu lc iq bd ld mv mw dn lh mx my dp ll jy mz na lp kc nb nc lt kg nd ne lx nf bi translated">活性探针</h2><p id="3dda" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">另一方面，活性探测用于重启不健康的容器。kubelet 定期向活性探测器发出 pings 命令，确定其健康状况，如果活性检查失败，就会杀死 pod。活性检查可以帮助应用程序从死锁状态中恢复。在没有活性检查的情况下，Kubernetes 认为死锁的 pod 是健康的，因为从 Kubernetes 的角度来看，底层进程继续运行。通过配置活跃度探测器，kubelet 可以检测到应用程序处于不良状态，并重启 pod 以恢复可用性。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ng"><img src="../Images/d34d19591dd53cc83a33522c0feb331b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yicsIyLNZJlDlIsf.GIF"/></div></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk translated">图片来源:<a class="ae mf" href="https://cloud.google.com/blog/products/gcp/kubernetes-best-practices-setting-up-health-checks-with-readiness-and-liveness-probes" rel="noopener ugc nofollow" target="_blank"> GCP 博客</a></figcaption></figure><h2 id="1b53" class="mu lc iq bd ld mv mw dn lh mx my dp ll jy mz na lp kc nb nc lt kg nd ne lx nf bi translated"><strong class="ak">启动探针</strong></h2><p id="b460" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">启动探测类似于就绪探测，但只在启动时执行。它们针对启动缓慢的容器或初始化过程不可预测的应用程序进行了优化。通过准备就绪探测，我们可以配置<code class="fe kx ky kz la b">initialDelaySeconds</code>来确定在探测准备就绪之前要等待多长时间。现在考虑一个应用程序，它偶尔需要下载大量数据或在进程开始时执行一个昂贵的操作。由于<code class="fe kx ky kz la b">initialDelaySeconds</code>是一个静态数字，我们被迫总是采取最坏的情况(或者扩展可能影响长时间运行行为的<code class="fe kx ky kz la b">failureThreshold</code>)并等待很长时间，即使该应用程序不需要执行长时间运行的初始化步骤。使用启动探测器，我们可以配置<code class="fe kx ky kz la b">failureThreshold</code>和<code class="fe kx ky kz la b">periodSeconds</code>来更好地模拟这种不确定性。例如，将<code class="fe kx ky kz la b">failureThreshold</code>设置为 15，将<code class="fe kx ky kz la b">periodSeconds</code>设置为 5，这意味着应用程序在失败前需要 15 x 5 = 75s 才能启动。</p><h1 id="3622" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">配置探测操作</h1><p id="1c44" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">现在我们已经了解了不同类型的探测器，我们可以研究配置每个探测器的三种不同方式。</p><h2 id="245d" class="mu lc iq bd ld mv mw dn lh mx my dp ll jy mz na lp kc nb nc lt kg nd ne lx nf bi translated"><strong class="ak"> HTTP </strong></h2><p id="74bd" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">kubelet 向一个端点发送一个 HTTP GET 请求，并检查 2xx 或 3xx 响应。您可以重用现有的 HTTP 端点，或者设置一个轻量级 HTTP 服务器用于探测目的(例如，带有<code class="fe kx ky kz la b">/healthz</code>端点的 Express 服务器)。</p><p id="0760" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">HTTP 探测器接受额外的参数:</p><ul class=""><li id="1b7f" class="mg mh iq jp b jq jr ju jv jy mi kc mj kg mk kk ml mm mn mo bi translated"><code class="fe kx ky kz la b">host</code>:要连接的主机名(默认:pod 的 IP)</li><li id="99be" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated"><code class="fe kx ky kz la b">scheme</code> : HTTP(默认)或 HTTPS</li><li id="f5e3" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated"><code class="fe kx ky kz la b">path</code>:HTTP/S 服务器上的路径</li><li id="cfb4" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated"><code class="fe kx ky kz la b">httpHeaders</code>:自定义标题，如果您需要用于验证、CORS 设置等的标题值</li><li id="3414" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated"><code class="fe kx ky kz la b">port</code>:访问服务器的端口名称或端口号</li></ul><pre class="km kn ko kp gt nl la nm nn aw no bi"><span id="c504" class="mu lc iq la b gy np nq l nr ns">livenessProbe:<br/>   httpGet:<br/>     path: /healthz<br/>     port: 8080</span></pre><h2 id="ed8f" class="mu lc iq bd ld mv mw dn lh mx my dp ll jy mz na lp kc nb nc lt kg nd ne lx nf bi translated">传输控制协议（Transmission Control Protocol）</h2><p id="74f5" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">如果您只需要检查是否可以建立 TCP 连接，您可以指定一个 TCP 探测器。如果可以建立 TCP 连接，则 pod 标记为健康。对于不适合 HTTP 调用的 gRPC 或 FTP 服务器，使用 TCP 探测可能很有用。</p><pre class="km kn ko kp gt nl la nm nn aw no bi"><span id="d3de" class="mu lc iq la b gy np nq l nr ns">readinessProbe:<br/>   tcpSocket:<br/>     port: 21</span></pre><h2 id="0a7d" class="mu lc iq bd ld mv mw dn lh mx my dp ll jy mz na lp kc nb nc lt kg nd ne lx nf bi translated">命令</h2><p id="24e0" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">最后，可以将探测器配置为运行 shell 命令。如果命令返回退出代码 0，则检查通过；否则，该 pod 被标记为不健康。如果不希望公开 HTTP 服务器/端口，或者如果通过命令检查初始化步骤更容易(例如，检查是否创建了配置文件，运行 CLI 命令)，这种类型的探测器可能会很有用。</p><pre class="km kn ko kp gt nl la nm nn aw no bi"><span id="4b09" class="mu lc iq la b gy np nq l nr ns">readinessProbe:<br/>   exec:<br/>     command: ["/bin/sh", "-ec", "vault status -tls-skip-verify"]</span></pre><h1 id="f849" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">最佳实践</h1><p id="f4e7" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">探测器的确切参数取决于您的应用程序，但这里有一些开始使用的一般最佳实践:</p><ul class=""><li id="91bb" class="mg mh iq jp b jq jr ju jv jy mi kc mj kg mk kk ml mm mn mo bi translated">对于较旧的(≤ 1.15) Kubernetes 集群，使用具有初始延迟的就绪探测器来处理容器启动阶段(为此使用 p99 次)。但是要让这个检查变得轻量级，因为准备就绪探测将在 pod 的整个生命周期中执行。我们不希望探测超时，因为就绪检查需要很长时间来计算。</li><li id="cdb5" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated">对于较新的(≥ 1.16) Kubernetes 集群，对启动时间不可预测或可变的应用程序使用启动探测器。启动探针可以与准备就绪和活性探针共享相同的端点(例如<code class="fe kx ky kz la b">/healthz</code>),但是将<code class="fe kx ky kz la b">failureThreshold</code>设置得比其他探针高，以考虑更长的启动时间，但是对于活性和准备就绪检查来说更合理的故障时间。</li><li id="2e02" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated">如果准备就绪探测不用于其他信令目的，则准备就绪探测和活性探测可以共享同一个端点。如果只有一个 pod(即使用垂直 Pod 自动缩放器)，请设置就绪探测器来处理启动行为，并使用活性探测器来确定健康状况。在这种情况下，将 pod 标记为不健康意味着停机。</li><li id="d53e" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated">准备就绪检查可以以各种方式用于发出系统降级的信号。例如，如果应用程序失去了与数据库的连接，可以使用就绪探测来暂时阻止新的请求，并允许系统重新连接。还可以通过将繁忙的 pod 标记为未就绪来将工作负载平衡到其他 pod。</li></ul><p id="9a03" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">简而言之，定义良好的探针通常会带来更好的弹性和可用性。确保观察启动时间和系统行为，以便随着应用程序的变化调整探头设置。</p><h1 id="e44b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">工具</h1><p id="71c8" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">最后，考虑到 Kubernetes 探针的重要性，您可以使用 Kubernetes 资源分析工具来检测缺失的探针。这些工具可以针对现有集群运行，或者嵌入到 CI/CD 流程中，以便在没有正确配置资源的情况下自动拒绝工作负载。</p><ul class=""><li id="eb7b" class="mg mh iq jp b jq jr ju jv jy mi kc mj kg mk kk ml mm mn mo bi translated"><a class="ae mf" href="https://github.com/FairwindsOps/polaris" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">【北极星】</strong> </a>:一个资源分析工具，有一个漂亮的仪表盘，也可以用作验证 webhook 或 CLI 工具。</li><li id="ace4" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated"><a class="ae mf" href="https://github.com/zegl/kube-score" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> kube-score </strong> </a>:一个静态代码分析工具，可以处理 Helm、Kustomize 和标准 YAML 文件。</li><li id="dc54" class="mg mh iq jp b jq mp ju mq jy mr kc ms kg mt kk ml mm mn mo bi translated"><a class="ae mf" href="https://github.com/derailed/popeye" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">Popeye</strong></a><strong class="jp ir">:</strong>只读实用工具，用于扫描 Kubernetes 集群并报告配置的潜在问题。</li></ul></div></div>    
</body>
</html>