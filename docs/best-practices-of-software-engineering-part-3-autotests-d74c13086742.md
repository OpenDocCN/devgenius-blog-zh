# 软件工程最佳实践。第三部分。自动测试。

> 原文：<https://blog.devgenius.io/best-practices-of-software-engineering-part-3-autotests-d74c13086742?source=collection_archive---------7----------------------->

![](img/e9711b1ba275399d7aafe1fab0742867.png)

在本文中，是时候讨论测试自动化了。当我们试图自动化测试过程时，我们不能忽视它们。所以现在，我将谈论测试自动化，以及一般的测试，但是将集中在系统测试上。

随着项目的增长，它可能开始变成一个无法控制的怪物。产品中的缺陷数量越来越多，测试和发布的时间也越来越长。同时，市场竞争越来越激烈，需要越来越快的产品发布。因此，你需要加快产品开发的速度。但是，如何做到这一点而不出现质量漏洞呢？

对于如何增加[上市时间](https://medium.com/@kirillmedvednykov/best-practices-of-software-engineering-part-2-velocity-metrics-692c401acb4b)，你有不同的选择，其中之一是帮助你的 QA 自动化他的工作。例如，您可以自动化“回归测试”，重要的“端到端”场景，或者测试的“前提条件流程”。这并不意味着单元测试或功能测试不重要，我只是想向您展示一个总体情况。每种测试类型都将帮助您控制代码的质量。不同的是，不同类型的测试将控制不同类型的错误，并将对您的产品和钱包产生不同的影响。

# 自动测试的类型

让我们看看自动测试的类型，并尝试理解它们的优缺点。

**单元测试。**这是测试产品代码、模块、类或功能，与代码的其余部分隔离开来。

Pluses:

*   书写简单快捷。它们只需要很少的写作时间，而且入门门槛很低。
*   错误定位。错误发生在哪里是显而易见的，不需要调试代码来查找错误。
*   易于维护。如果测试代码中有什么变化，在测试中很容易修复。
*   不需要基础设施来运行测试。你不一定需要詹金斯或其他特殊管道等特殊工作。您可以在本地机器上运行它。
*   代码质量。帮助您控制代码的质量，提高代码的可读性和低复杂性。我将在我的下一篇文章中详细讨论这一点。

减

*   漫长的回报。为了感受这些测试的真实影响，必须有大量的测试。仅仅因为有这么多，这些测试的效果将随着时间的推移而被感受到。
*   对于测试，必须有高质量的代码。如果你有某种非常复杂的遗留代码，那么用单元测试覆盖这些代码几乎是不可能的。但另一方面，这也是一个优势。如果你写单元测试，你的代码会更好。这一点与这个列表中的最后一个加号相反。

**整合测试。**测试系统中协同工作的几个类/模块。

Pluses:

*   测试处理时间短。通常它们通过的速度比单元测试慢，但是在你需要的时候运行一次还是可以的。
*   可接受的误差定位。它们并没有将错误显示为模块化的，但是可能出现错误的代码量仍然非常有限。

缺点:

*   比单元测试更复杂。测试比单元测试更难编写和维护。但是，他们的门槛仍然很低。
*   基础设施。可能需要基础设施来运行测试。这意味着这需要时间。

**系统测试。**整体测试程序。

Pluses:

*   测试很快就有回报。少量的测试发现了许多错误。即使一个测试也能够发现一堆缺陷，并且这种测试的效果立即可见。
*   测试的行为就像用户一样。像 Selenium 这样的工具可以在你的网站上模拟用户的旅程，启动浏览器，加载页面，按下按钮等等。

缺点:

*   错误定位错误。例如:你为某个系统的注册用户写了一个测试，结果失败了。错在哪里？可能是:表单验证、orm 问题、数据库中不正确的数据类型、电子邮件发送问题等。
*   很好的准备时间。对于系统测试，一次测试运行 20 分钟可视为正常速度。而且，可能需要十几次或更多次这样的测试。当然，您可以并行化测试，但是这将比功能测试或单元测试花费更多的处理时间，并且会增加支持成本。
*   这是一个完整的软件产品。通常，这样的测试是作为独立的项目编写的，需要独立的支持专家、特殊任务、工作流程等。

# 我什么时候需要写自动测试？

在我看来，如果不止一个开发人员在你的项目上工作，你需要使用自动化。但是为了更深入的理解，我已经添加了一些要点来帮助你理解什么时候开始做自动化。

*   大量的手工测试和缺乏时间进行回归测试。对于该指标，请参考[手动测试时间](https://medium.com/@kirillmedvednykov/best-practices-of-software-engineering-part-2-velocity-metrics-692c401acb4b) (MTT)度量。
*   很多时间花在准备测试上，例如，生成测试数据或设置环境。
*   一个有几个团队的大型项目，其中一个程序员可能会破坏另一个程序员的代码。
*   生产中由于人为因素造成的大量错误。这将有助于衡量“在生产服务器上发现的问题率”
*   在引入误差、检测误差和校正误差之间有一段很长的时间。

# 如何理解要自动化什么？

经常发生的情况是，对系统进行全面的回归测试是不合理的昂贵。这就提出了下面的问题:为了在发布成本和产品质量之间取得平衡，应该检查什么？要解决这个问题，你需要有明确的产品需求。我不建议在没有它的情况下开始自动化测试过程。即使是最简单或最差的质量需求也将有助于确定功能的数量，手动测试需要多少时间，以及需要自动测试覆盖的功能。这些需求将有助于选择哪些测试对自动化至关重要。

例如，你可以有 20 个需求，每个需求包含 10-20 个测试。手工测试可能要花费大量的时间来完成这样一个范围的测试，以进行全面的回归。对于一个项目来说，这可能是不合理的昂贵，尤其是如果你正在开发一些 web 项目，并且每周发布一次或两次。在这种情况下，您可以将测试分成几个组(例如:高优先级、中优先级、低优先级)，并决定在每次发布之前需要通过哪些测试组。此外，您可以将最不稳定模块中的测试添加到必需测试列表中。找到不稳定的模块可以帮助度量“缺陷密度”,这是我在上一篇文章中谈到的。

根据上面的例子，如果您用自动测试覆盖了所有重要的功能，您可以显著地加快通过回归测试的过程。但是，同样值得理解的是，自动测试也是要花钱的。开发测试并维护它们的正常工作需要时间，尤其是如果它们是系统测试的话。因此，你不应该给自己设定自动测试 100%覆盖的目标，任何地方你都需要用常识来指导。

# 如何高效评估？

为了理解这一点，有必要测量这样的指标:自动测试发现的 bug 的数量，自动测试的需求覆盖率是多少，以及它们节省了多少时间或金钱。使用这些指标，你将有机会计算自动测试的投资回报率。它字面上显示了多少钱，如果它真的帮助你。

作为一个例子，我将向你展示我们如何在我当前的项目中评估测试覆盖率。我们使用吉拉的 xRay 插件，它帮助我们管理产品需求，并查看每个版本的测试覆盖率。当我们运行测试时，我们会在吉拉自动创建一个文本执行问题，并将自动测试的结果链接到那里。然后这个 TextExecution 会自动链接到部署任务。因此，通过任何部署票证的链接，我们都可以看到报告。

![](img/7fee6ac9607d9a25b2969ff344c4ea1d.png)

此报告显示测试覆盖的需求数量和内容、运行的测试以及失败的测试数量。同样在这个报告中，您可以看到更详细的信息。

![](img/50c8899ac7ad332e1822f97f454718b4.png)

这种方法帮助我们评估被测试功能的数量，并估计我们需要多少时间来完成一个完整的回归，以及我们需要多少时间来自动化整个项目。

# 监控测试

同样在我们的项目中，我们使用在真实项目上运行的“监控测试”。他们几乎不对项目做任何更改，也不删除或添加任何东西。事实上，它们的功能就像真实系统的冒烟测试:检查数据一致性，REST Api 的可用性，如果调度任务及时工作，用户可以登录到系统，访问权限正确分配给他，等等。这些测试有助于我们在一些事件发生后立即了解问题，也有助于发布产品的新版本，并控制生产服务器上是否一切正常。

需要注意的是:每个产品都是特定的，需要不同的产品测试策略。测试方法中没有灵丹妙药。

## 软件工程的最佳实践

1.  [目标](https://medium.com/@kirillmedvednykov/best-practices-of-software-engineering-part-1-goals-4457a907e756)
2.  [速度指标](https://medium.com/@kirillmedvednykov/best-practices-of-software-engineering-part-2-velocity-metrics-692c401acb4b)
3.  [自动测试](https://medium.com/@kirillmedvednykov/best-practices-of-software-engineering-part-3-autotests-d74c13086742)
4.  [自动化](https://medium.com/@kirillmedvednykov/best-practices-of-software-engineering-part-4-automation-eaf795b9a8d8)
5.  [代码质量](https://medium.com/dev-genius/best-practices-of-software-engineering-part-5-code-quality-164e9c87d6db)