<html>
<head>
<title>Classes in React — aren’t bad.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React 中的类—还不错。</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/class-in-react-isnt-bad-653e98a628fb?source=collection_archive---------11-----------------------#2022-11-25">https://blog.devgenius.io/class-in-react-isnt-bad-653e98a628fb?source=collection_archive---------11-----------------------#2022-11-25</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/475e3fb9e2124eda36b2820c89336172.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RyCnkfyCNk7eGc7Dbl51FA.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">由<a class="ae jz" href="https://unsplash.com/es/@freeche?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Kvistholt 摄影</a>在<a class="ae jz" href="https://unsplash.com/s/photos/programming?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="772b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如你所知，React 试图从<strong class="kc io">类组件</strong>迁移到<strong class="kc io">功能组件</strong>中，但它不能完全做到，并且<strong class="kc io">类组件</strong>与功能组件有所不同，功能组件尚未添加。</p><h2 id="9032" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated"><strong class="ak">最受欢迎的案例:</strong></h2><blockquote class="lr"><p id="7492" class="ls lt in bd lu lv lw lx ly lz ma kx dk translated"><strong class="ak"> useEffect </strong>为异步，<strong class="ak">componentid mount</strong>为同步。</p></blockquote><p id="65e3" class="pw-post-body-paragraph ka kb in kc b kd mb kf kg kh mc kj kk kl md kn ko kp me kr ks kt mf kv kw kx ig bi translated">可能你看到的最常见的情况是，当我们用包装器绑定一个 ref 并试图查看 ref 的宽度时，如果你使用一个<strong class="kc io"> useEffect </strong>我们将会看到<code class="fe mg mh mi mj b">0 -&gt; width(px)</code>但是<strong class="kc io"> componentDidMount </strong>会立即这样做。</p><p id="c8b2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">主要原因是<strong class="kc io">使用效果</strong>和<strong class="kc io">组件安装</strong>工作机构的不同，尤其是安装阶段的不同；</p><ol class=""><li id="d4e8" class="mk ml in kc b kd ke kh ki kl mm kp mn kt mo kx mp mq mr ms bi translated">在类组件中，<strong class="kc io">componentdimount</strong>生命周期的机制除了<strong class="kc io"> async </strong>回调之外，都立即设置状态函数。</li><li id="f20c" class="mk ml in kc b kd mt kh mu kl mv kp mw kt mx kx mp mq mr ms bi translated"><code class="fe mg mh mi mj b">render</code>方法创建一个新的<strong class="kc io"> VRDOM </strong>。</li></ol><blockquote class="my mz na"><p id="cd47" class="ka kb nb kc b kd ke kf kg kh ki kj kk nc km kn ko nd kq kr ks ne ku kv kw kx ig bi translated"><em class="in">一般来说，</em><strong class="kc io"><em class="in">use effect</em></strong><em class="in">在油漆提交后运行。</em></p></blockquote><h2 id="f93d" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">UPD: React 18 改变了使用效果机制。</h2><p id="1ded" class="pw-post-body-paragraph ka kb in kc b kd nf kf kg kh ng kj kk kl nh kn ko kp ni kr ks kt nj kv kw kx ig bi translated">如果你使用的是<strong class="kc io"> createRoot </strong>方法——所有的 React setState 函数都会被同步刷新。</p><pre class="nk nl nm nn gt no mj np bn nq nr bi"><span id="14d5" class="ns kz in mj b be nt nu l nv nw">ReactDOM.createRoot(rootElement).render(&lt;App /&gt;)</span></pre><p id="5946" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是<strong class="kc io">方法</strong>渲染不允许这么做。</p><pre class="nk nl nm nn gt no mj np bn nq nr bi"><span id="15cb" class="ns kz in mj b be nt nu l nv nw">ReactDOM.render(&lt;App /&gt;, rootElement)</span></pre><blockquote class="my mz na"><p id="2a47" class="ka kb nb kc b kd ke kf kg kh ki kj kk nc km kn ko nd kq kr ks ne ku kv kw kx ig bi translated"><em class="in">主要区别</em> <strong class="kc io"> <em class="in">使用效果</em> </strong> <em class="in">和</em> <strong class="kc io"> <em class="in">组件卸载</em> </strong> <em class="in">是这个生命周期实现时的一个阶段。</em></p></blockquote><p id="f8e3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">正如你所理解的，useEffect 可能是类和功能组件之间区别的最流行的例子。</strong></p><blockquote class="my mz na"><p id="12bb" class="ka kb nb kc b kd ke kf kg kh ki kj kk nc km kn ko nd kq kr ks ne ku kv kw kx ig bi translated">但这还不是全部，除此之外，它们之间还有其他不同之处。</p></blockquote><h2 id="07d9" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">React 中的类，但不涉及类组件。</h2><p id="e4a8" class="pw-post-body-paragraph ka kb in kc b kd nf kf kg kh ng kj kk kl nh kn ko kp ni kr ks kt nj kv kw kx ig bi translated">考虑到上次关于 React 中<strong class="kc io">类</strong> vs <strong class="kc io">泛函组件</strong>的讨论——很多学弟认为 React 中<strong class="kc io">类</strong>不好。</p><p id="6316" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">React 开发人员试图将<strong class="kc io">函数式编程范式</strong>融入他们的哲学中，因为这一点，许多低年级学生认为<strong class="kc io"> FP </strong>比<strong class="kc io"> OOP </strong>更好，但事实并非如此。</p><p id="0c44" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">让我们以 OOP 的基本示例以及如何创建和管理应用商店为例:</strong></p><p id="1e35" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> MobX: </strong></p><pre class="nk nl nm nn gt no mj np bn nq nr bi"><span id="1ad1" class="ns kz in mj b be nt nu l nv nw">class Profile {<br/>  is_exit = false;<br/><br/>  constructor() {<br/>    makeAutoObservable(this);<br/>  }<br/><br/>  exitFromAccount() {<br/>    this.is_exit = !this.is_exit;<br/>  }<br/>}<br/><br/>const account = new Profile();<br/><br/>const Block = observer(() =&gt; {<br/>  console.log(account.is_exit);<br/>  return (<br/>    &lt;div&gt;<br/>      &lt;button<br/>        onClick={account.exitFromAccount}&gt;<br/>          Click!<br/>      &lt;/button&gt;<br/>    &lt;/div&gt;<br/>  );<br/>});</span></pre><p id="6d75" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是一个关于 MobX 如何工作的非常简单的例子。</p><blockquote class="my mz na"><p id="fa06" class="ka kb nb kc b kd ke kf kg kh ki kj kk nc km kn ko nd kq kr ks ne ku kv kw kx ig bi translated"><em class="in">我不会只讲概念就讲它是如何工作的。</em></p></blockquote><p id="b00d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> MobX </strong>使用<strong class="kc io">函数反应式编程</strong>，但是我们使用了一个类来描述我们的商店模型，乍一看这可能会产生一些疑问。</p><blockquote class="lr"><p id="a072" class="ls lt in bd lu lv lw lx ly lz ma kx dk translated">没有错误的编程范式，只有特定情况下的正确范式。</p></blockquote><p id="d6b1" class="pw-post-body-paragraph ka kb in kc b kd mb kf kg kh mc kj kk kl md kn ko kp me kr ks kt mf kv kw kx ig bi translated">在这个<strong class="kc io"> MobX </strong>片段中，我们使用<strong class="kc io"> OOP </strong>表示数据，但是嵌套函数允许你使用<strong class="kc io"> MobX </strong>使用<strong class="kc io"> FP【函数范例】</strong>。</p><p id="d7c0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe mg mh mi mj b">makeAutoObservable</code> -是一个数学函数或清零函数，这是<strong class="kc io"> FP </strong>的主要标志。</p><div class="nx ny gp gr nz oa"><a rel="noopener  ugc nofollow" target="_blank" href="/mcrtip-1-difficult-about-simple-2df82ad79e52"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd io gy z fp of fr fs og fu fw im bi translated">MCRTIP #1 /简单的困难</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">MCRTIP 只是我关于编程思想的汇编。仅依我看。</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">blog.devgenius.io</p></div></div><div class="oj l"><div class="ok l ol om on oj oo jt oa"/></div></div></a></div><blockquote class="my mz na"><p id="aa19" class="ka kb nb kc b kd ke kf kg kh ki kj kk nc km kn ko nd kq kr ks ne ku kv kw kx ig bi translated">你可以在这篇文章中阅读更多关于数学函数的内容。</p></blockquote><h2 id="257b" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">PromakeAutoObservablegramming 范例对商店经理很重要。</h2><p id="283a" class="pw-post-body-paragraph ka kb in kc b kd nf kf kg kh ng kj kk kl nh kn ko kp ni kr ks kt nj kv kw kx ig bi translated">我不会谈论<strong class="kc io"> FP </strong>和<strong class="kc io"> OOP </strong>之间的区别以及哪个更好——让我们看看其他的状态管理器和他们选择的<strong class="kc io">编程范例</strong>。</p><p id="8f43" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> Redux: </strong></p><pre class="nk nl nm nn gt no mj np bn nq nr bi"><span id="c8b6" class="ns kz in mj b be nt nu l nv nw">import { createSlice, configureStore } from '@reduxjs/toolkit'<br/><br/>const counterSlice = createSlice({<br/>  name: 'counter',<br/>  initialState: {<br/>    value: 0<br/>  },<br/>  reducers: {<br/>    incremented: state =&gt; {<br/>      state.value += 1<br/>    }<br/>  }<br/>});<br/><br/>const { incremented, decremented } = counterSlice.actions<br/><br/>const store = configureStore({<br/>  reducer: counterSlice.reducer<br/>});<br/><br/><br/>store.subscribe(() =&gt; console.log(store.getState()));<br/>store.dispatch(incremented());</span></pre><blockquote class="my mz na"><p id="b522" class="ka kb nb kc b kd ke kf kg kh ki kj kk nc km kn ko nd kq kr ks ne ku kv kw kx ig bi translated"><em class="in"/><strong class="kc io"><em class="in">Redux</em></strong><em class="in">大概是最受欢迎的状态管理器和许多后辈学习的</em><strong class="kc io"><em class="in">React</em></strong><em class="in">和</em><strong class="kc io"><em class="in">Redux</em></strong><em class="in">。</em></p></blockquote><p id="5c00" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">有方法<code class="fe mg mh mi mj b">subscribe, dispatch</code>和明确的函数<code class="fe mg mh mi mj b">configureStore, createSlice</code>。换句话说，<strong class="kc io"> Redux </strong>使用了<strong class="kc io"> FP </strong>和<strong class="kc io"> OOP </strong>范例，我们可以用公式表达这种思想:</p><blockquote class="lr"><p id="a801" class="ls lt in bd lu lv lw lx ly lz ma kx dk translated">我们可以将 FP 和 OOP 范例结合成一个模型。</p></blockquote><h2 id="2c8b" class="ky kz in bd la lb op dn ld le oq dp lg kl or li lj kp os ll lm kt ot lo lp lq bi translated">我们可以选择的主要结论。</h2><ol class=""><li id="8d3c" class="mk ml in kc b kd nf kh ng kl ou kp ov kt ow kx mp mq mr ms bi translated"><strong class="kc io">反应 18 </strong>中的<strong class="kc io">类</strong>和<strong class="kc io">功能组件</strong>有区别，但没有那么严重。</li><li id="08e8" class="mk ml in kc b kd mt kh mu kl mv kp mw kt mx kx mp mq mr ms bi translated">您可以在同一个项目<strong class="kc io">中成功地将<strong class="kc io">功能范式</strong>用于<strong class="kc io">视图</strong>，将<strong class="kc io"> OOP </strong>用于<strong class="kc io">模型</strong>。</strong></li><li id="57c6" class="mk ml in kc b kd mt kh mu kl mv kp mw kt mx kx mp mq mr ms bi translated">这证明了使用<strong class="kc io"> OOP </strong>管理商店和使用<strong class="kc io"> FP </strong>改变商店行为和来自商店的表示数据的合理性。</li></ol></div></div>    
</body>
</html>