<html>
<head>
<title>A crash course on floating point numbers in a computer, Part I</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">计算机中浮点数的速成教程，第一部分</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/a-crash-course-on-floating-point-numbers-in-a-computer-part-i-a7a70f67a27?source=collection_archive---------2-----------------------#2020-10-15">https://blog.devgenius.io/a-crash-course-on-floating-point-numbers-in-a-computer-part-i-a7a70f67a27?source=collection_archive---------2-----------------------#2020-10-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/acd15a1ec70c7e7e0fba729746424855.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YWZEXC1zBZ3OjBHG"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">在天文学中，需要测量很大的距离，但一般不需要精确到毫米。照片由<a class="ae kc" href="https://unsplash.com/@sippakorn?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> sippakorn yamkasikorn </a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="f041" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">与整数不同，计算机中的浮点数系统不使用二进制补码来表示负数。然而，浮点数有一些细节使它们变得非常复杂。</p><p id="e5e0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">浮点数格式可能会让人们感到非常困惑，因为它们与整数格式相比，与我们对数字的理解相去甚远，我在<a class="ae kc" href="https://medium.com/@alonso.delarte/a-crash-course-on-integers-in-twos-complement-in-a-computer-d155734043a4" rel="noopener">的一篇早期文章</a>中对此进行了解释。</p><p id="6a5d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于一般的程序员来说，用二进制补码做白板计算，甚至当心算都不算太难。但是用浮点数做白板计算是相当困难的，通常需要计算器的帮助。</p><p id="3d3d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">即便如此，至少对浮点数的工作原理、它们的优点和缺点有一个基本的了解，可以帮助您在任何主流编程语言中使用浮点数时避免一些不愉快的意外。</p><p id="9618" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">浮点的反义词是定点。整数格式都是定点格式:放置“二进制点”是为了只表示整数，因此您可以想象计算机中的整数在结尾总是有一个隐含的“. 000……”。</p><p id="b32a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">整数中的最低有效位只能表示0 × 1或1 × 1，下一个最低有效位只能表示0 × 2或1 × 2，下一个最低有效位只能表示0 × 4或1 × 4，以此类推，直到到达无符号整数中最左边的位(我在上一篇文章中介绍了负数是如何表示的)。</p><p id="9f06" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">表示像7.25这样的数字的一种可能的定点系统是分配64位，并同意中间的一位表示0 × 1或1 × 1。左边的位对应于2、4、8、16、32等。右边的位对应于1/2、1/4、1/8、1/16、1/32等。</p><p id="fe21" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个定点系统可以表示小到1/4294967296的正数，如果没有符号，则可以表示大到42949672961/4294967296的正数。听起来范围很广。</p><p id="b639" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">问题是，科学计算需要的数字比这种定点系统的最小值和最大值小得多，也大得多。</p><p id="4ac7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">科学家估计宇宙包含4 × 10⁸⁰粒子。普朗克长度大约是1.6米除以10 ⁵.这两个数字都在上述定点系统的范围之外。</p><p id="fd60" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们可以说，对于一些数字来说，“二进制点”非常靠近左边，而对于一些数字来说非常靠近右边，会怎么样呢？或者在某些情况下在比特模式之外？</p><p id="7864" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就这样，浮点诞生了。位模式的一部分表示定点数，如1.7500152587890625，位模式的一部分表示指数，如14。那么我们就有了1.7500152587890625 × 2 ⁴ = 28672.25。</p><p id="d4fe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">电气和电子工程师协会(IEEE)于1985年对当今几乎所有计算机使用的浮点数系统进行了标准化，并于1990年“重新确认”和2008年进行了修订。</p><p id="efb2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">详细描述该标准的文档被称为IEEE 754。如果需要更具体的，可以参考“IEEE 754–1985”或者“IEEE 754–2008”。</p><p id="47e8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">图形专家可能会说整数格式是“无损的”(像PNG)，浮点格式是“有损的”(像JPEG——尽管JPEG也有无损版本；我持怀疑态度)。</p><p id="f2fc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如JPEG压缩可以通过牺牲原始图像的一些像素来用于任何图像一样，浮点可以通过牺牲一些精度来用于任何“实数”。虽然有些人的牺牲比其他人大得多。</p><p id="b34a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以进一步扩展类比:高JPEG压缩会产生一个非常小的文件，但图像质量可能会受到影响。低JPEG压缩会产生较大的文件(希望仍然小于原始图像文件)，但图像质量可能足够好，压缩后的图像与原始图像无法区分，至少对于人眼来说是如此。</p><p id="6beb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，有些位可以用浮点表示任何实数，但精度会受到影响。用几个比特，表示可能非常不准确。如果位数更多，这种表示可能会相当准确。</p><p id="1231" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们考虑到一个给定的任意整数要么可以用一个特定的位宽来表示，要么不能，这个类比就站不住脚了。</p><p id="ca1d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，65537远远超出了8位整数(有符号或无符号)的范围，它只是稍微超出了有符号16位整数的范围。当然，它很容易用32位整数表示，有符号或无符号。</p><p id="a2a5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在32位浮点(称为“单精度”)中，65537.0很容易以完美的精度拟合。在16位浮点(称为“半精度”)中，我们将不得不满足于65504.0，相差33.0。</p><p id="70f3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在8位浮点中(如果任何人有规律地使用它，它将被称为“四分之一精度”)，65537.0将作为正无穷大丢失。八位可能是理论最小位宽，十六位可能是实际最小位宽。</p><p id="d934" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">浮点最常用的位宽是前面提到的32位格式和64位格式(称为“双精度”)。对于本文，为了使示例更容易理解，我将主要使用16位。</p><p id="7fbb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">128位的“四倍精度”当然是可能的，但无论从理论上还是实践上来说，这都不是最大值。但是它倾向于用软件而不是硬件来实现。</p><p id="9678" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以也应该把浮点数想象成分成三组位:</p><ul class=""><li id="b6c3" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">符号位，总是在左边一位，正数为0，负数为1。</li><li id="2f8f" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">以2为基数的指数位表示2的幂。16位中有5位，32位中有8位，64位中有11位。</li><li id="c891" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">尾数位，也称为有效位。16位中有10位，32位中有23位，64位中有52位。这些位可以表示有限的一组无符号有理数中的数，作为一种定点系统。</li></ul><p id="d86f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">将符号位视为1的指数可能会有所帮助。请记住，(−1)⁰ = 1且(1)= 1。因此，我们将符号位表示的1的幂乘以指数位表示的2的幂，再乘以尾数位表示的有理数。</p><p id="28e6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，假设符号位打开表示1，指数位设置为表示2⁷，尾数位设置为表示3/2。则1×128×3/2 = 192。</p><p id="31ac" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们再做一个:符号位关闭以表示1，指数位设置为表示2的7次方，尾数位仍然设置为表示3/2。那么1 × 1/128 × 3/2 = 3/256 = 0.01171875。</p><p id="70dd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">很简单，对吧？这里有几条皱纹。</p><p id="8bc9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">也许最容易理解的一点是，在浮点运算中，不管位宽如何，0都有两种不同的表示:“正”0和“负”0。</p><p id="95e4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">16位浮点中“正”零的位模式是00000000 000000。16位浮点中“负”零的位模式是10000000 000000。</p><p id="0ffe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">0有两个不同的表示是二进制补码解决的问题之一。整数格式可以表示的每个数字都有一个明确的表示。</p><p id="d2e7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在有符号整数格式中，符号位开启而所有其它位关闭的位模式不对应于0，而是对应于位宽中可以表示的最小负数(例如，有符号16位整数为32768)。</p><p id="a007" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最低负数的绝对值刚好在整数格式的范围之外(例如，32768不能用有符号的16位整数表示)，但这是为没有两个零而付出的小小代价。</p><p id="5260" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">预计计算机会将浮点中的“正”零和“负”零视为相等，即使它们的位模式不同。</p><p id="f769" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">比如负零的平方根当然是零。如果像Intel 8087这样的浮点芯片有一条平方根指令，那么这条指令不会给出负数的结果，但它仍有望给出负零的正确结果。</p><p id="f647" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对比也比较复杂。在有符号整数格式中，符号位为on的数小于符号位为off的数，但这是唯一需要注意的。</p><p id="c5cf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">整数格式中最低负数的位模式对应于小于对应于1的无符号整数的无符号整数(例如，在无符号16位整数中，32768的位模式与32768相同，1的位模式与65535相同)。</p><p id="1b5a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但在浮点运算中，“负”零大于任何带符号位的数字(如0.875)，但其整数位模式小于任何负数。</p><p id="1cd0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这只是使浮点数比较复杂化的一个细节。我甚至还没有提到规范化(稍后我会提到)。</p><p id="45ad" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于人类来说，写出16位类型的位模式是乏味且容易出错的。将浮点数的位模式表示为无符号的十六进制整数通常更方便。</p><p id="3584" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是因为一个十六进制数字恰好对应四位:0对应0000，1对应0001，2对应0010，3对应0011，以此类推，E对应1110，F对应1111。</p><p id="3f9f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于本文的其余部分，我假设您已经知道十六进制。回到“正”和“负”零，我应该提到十六进制数字8对应于位模式1000。</p><p id="530c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们可以将16位浮点中“正”零的位模式写为0000，将“负”零的位模式写为8000，而不是写出16个零或单个1后跟15个零。</p><p id="62cd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，我仍然会用二进制写出指数位模式，就像16位浮点数的5个指数位。</p><p id="8f44" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在符号位之后，是指数位，它代表一个很小且非常有限的有理数。</p><p id="8f79" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">负指数意味着由尾数位表示的数字乘以2的非整数幂，如1/2、1/4、1/8、1/16、1/32等。</p><p id="bd9d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">作为指数的零意味着尾数位表示的数字乘以1。而正指数意味着由尾数位表示的数字乘以2的整数幂，如2、4、8、16、32等。</p><p id="50fb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">IEEE 754浮点格式不使用任何二进制补码。在16位浮点运算中，有五个指数位，11111并不意味着1(如果所有指数位都开启，这有一个特殊的含义，我将在后面解释)。</p><p id="648f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">指数位没有自己的符号位。因此指数位代表0或一个小的正整数。尽管事实证明所有指数位关闭也有特殊的含义。那么指数位只能代表小正整数？</p><p id="d5ac" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么似乎没有办法表示8(正指数但符号位开启)或0.125(负指数但符号位关闭)这样的数字。</p><p id="6e40" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这就是“偏见”概念的由来。偏差是从指数位代表的整数中减去的正整数(或者是加上的负数，如果你愿意这样想的话)。</p><p id="939a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">偏差取决于位宽。在16位浮点中，偏差为15，在一种特殊情况下为14。32位的偏差始终为127(除非在特殊情况下为126)，64位的偏差为1023(或特殊情况下为1022)。</p><p id="d448" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，在16位浮点中，指数位中的01010表示10(十)无偏差，5有偏差。</p><p id="f6f0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所有指数位关闭时的偏差相同，只有最低有效指数位开启时的偏差相同。所有指数位的偏差实际上无关紧要，我将在后面解释。</p><p id="5197" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为偏向是奇数，奇数偏向偶数指数，偶数偏向奇数指数，除了0，它偏向1偏向的相同偶数指数。</p><p id="e7b2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，在16位浮点中，00001偏向14，00000也偏向14。同样，在32位浮点中，00000001和00000000都偏向126；在64位浮点中，0000000001和000000000都偏向1022。</p><p id="259e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果之前不清楚，现在应该清楚了，整个浮点数系统对于人们的理解来说是相当混乱的，这也是一些较老的芯片无法进行浮点计算的部分原因。</p><p id="8a2a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">16位浮点中的指数位可以表示从14到15的指数。然后，如果符号位关闭，尾数位表示1，则16位浮点数可以小到1/16384，大到32768.0。</p><p id="9dd0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么…如果尾数位可以表示0，指数位可以表示至少八个不同的整数，为什么0没有至少十六个不同的表示呢？</p><p id="e5f3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">比如0000和8000是16位浮点中0的表示，那么0400，0800，0C00，…，7800，8000，8400，8800，8C00，…，F800不也应该是0的表示吗？</p><p id="7141" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有两种不同的零表示法已经够浪费的了。为了避免所有的冗余，并挤出多一位的精度，浮点标准包括了正常数和次正常数的概念，我将谈到这一点。</p><p id="7b36" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我前面提到过，浮点数的尾数位可以代表一个有限的有理数小集合中的任何一个定点数格式的数。</p><p id="4062" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">快速复习:有理数是一个整数除以一个非零整数的结果。即<em class="lp"> a </em> / <em class="lp"> b </em>是一个有理数，其中<em class="lp"> a </em>和<em class="lp"> b </em>都是整数，<em class="lp"> b </em> ≠ 0。例如，16/9是一个有理数。</p><p id="a832" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于π这样的无理数没有这样的表示，大概是3.14159，但是可以用22/7这样的有理数来近似。</p><p id="fffd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，在浮点运算中，许多看起来在范围内的有理数也必须近似，就像它们是无理数一样，因为分母限制为2的幂，分子根据分配给尾数位的位宽而受到限制。</p><p id="f403" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，1/3 = 1/4+1/16+1/64+1/256+1/1024+1/4096+…这意味着位模式0.010101010101…无限重复“01”。但是在计算机芯片上，我们没有无限多的位来处理。</p><p id="f8ba" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于16位浮点运算，我们只有10位来处理尾数位。像整数格式一样，尾数位代表一个定点数，但关键区别是2⁰的位在左边而不是右边。</p><p id="fe77" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么2⁰比特右边的比特代表具有负指数的2的幂，意味着分数幂:1/2、1/4、1/8、1/16等。</p><p id="a581" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些事实表明，为了表示1/3，我们必须满足于尾数位中的0.010101010，这表示1/4 + 1/16 + 1/64 = 21/64 = 0.328125。那是1/3的1/192，大约是0.0052083333333333333。</p><p id="f5fc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我看来，这是不可接受的不精确。仅仅能够将1/256相加就可以得到85/256 = 0.33203125。这是1/3的1/768，大约是0.0013020833333333333。我觉得这样更好。</p><p id="e853" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过将尾数位从0.010101010更改为1.010101010，我们可以得到1/256，从而接近4/3而不是1/3，并将指数位设置为2的2次方而不是2⁰，这意味着除以四分之一而不是乘以1。</p><p id="534b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">事实证明，对于几乎所有的数字来说，让尾数位表示大于或等于1的数字，并设置指数位以使尾数位达到期望的幅度更有意义。</p><p id="a986" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果尾数位几乎总是以1开始，为什么不省略它，并理解它是隐含的呢？这样，我们就能多一点精确。</p><p id="f92b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在1/3的例子中，它非常有用:一个隐含的“1”接下来是“0101010101”，这意味着我们得到了4/3的更好的近似值，即1 + 341/1024 = 1.3330078125，与1/3相差1/3072。我觉得好多了。位模式是3555。</p><p id="1d56" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是现在我们遇到了如何表示0.0的问题。如果总有一个隐含的“1”对于尾数位，尾数位无法表示0。</p><p id="f015" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">解决方案是得出“正常化”和“非正常化”(或“次正常化”)的数字。后者没有被“标准化”为在尾数位的前面隐含1位。</p><p id="03f7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">大多数数字，如0.875和1365/1024，都被“规范化”，在尾数位中包含隐含的前导1。但是“正”零和“负”零被“反规格化”以排除尾数位隐含的前导1。</p><p id="545e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当所有指数位关闭时，发生反规格化。然后，指数位不是表示比仅最低有效指数位为on时给出的指数小1的指数(16位浮点时为15，比14小1)，而是表示相同的指数(16位浮点时为14)。</p><p id="954d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">16位浮点中指数15的损失可以通过尾数位表示较小数字的能力来弥补。</p><p id="e51d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果没有反规格化机制，位模式0001将意味着1/32768×1 = 1/32768 = 0.000030517578125。</p><p id="2569" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">非规格化的16位浮点数中的尾数位可以仅表示1/1024，而不是表示1 + 1/1024。而1/16384×1/1024 = 1/16777216 = 0.00000005960464775390625，比1/32768 = 0.000030517578125小得多的数。</p><p id="963d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当然，如果所有尾数位都关闭，指数位偏向哪个并不重要。零乘以任何东西仍然是零。</p><p id="eb02" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在网上，你可以找到一些不同的工具，通过点开和点关来帮助你可视化浮点数。有些工具会显示数字何时被规范化或反规范化，有些则不会。</p><p id="0b98" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">H. Schmidt 的浮点转换器<a class="ae kc" href="https://www.h-schmidt.net/FloatConverter/IEEE754.html" rel="noopener ugc nofollow" target="_blank">显示了一个32位浮点数。尝试在“您输入的”框中输入3.14，然后按Enter或Tab键。它应该显示指数为2 (128)，尾数大约为1.57 (4781507)。</a></p><p id="a1c3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在试着输入“9.2321990039091357031360307 e-39”，它大约等于π除以2 ⁸.您应该看到指数变为2的126次方，括号中为“反规格化”，尾数为0.7853981256484985，也标记为“反规格化”。</p><p id="9d3b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所有指数位关闭。所有指数位的开启也有特殊的意义，但是总体位模式并不代表任何特定的数字。</p><p id="a0b2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果所有的指数位都是开的，但所有的尾数位都是关的，那么该值要么是正无穷大，要么是负无穷大，这取决于符号位。所以在16位浮点中，正无穷大是7C00，负无穷大是FC00。</p><p id="eaba" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是，如果所有指数位都关闭，但只有一个尾数位打开(符号位无关紧要)，则位模式表示特殊值“不是数字”，通常称为“NaN”</p><p id="94fd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一些算术运算给出的结果要么是不确定的，要么是一个虚数，比如数字<em class="lp"> i </em>使得<em class="lp">I</em>= 1。或者不那么迂腐地说，<em class="lp"> i </em>是1的主平方根(另一个是<em class="lp"> i </em>)。</p><p id="f520" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在施密特的转换器中，尝试点击所有的指数位。显示屏应该变为NaN。现在试着关掉尾数位。一旦关闭最后一个尾数位，显示将变为无穷大。</p><p id="c5d5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在16位浮点中，有两千多种不同的方式来表示NaN，从7C01到7FFF，从FC01到FFFF。在64位浮点中，多个NaN值的明显浪费要大得多，数量级为万亿。</p><p id="ae95" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">大概可以从NaN中恢复一些信息，尽管据说这依赖于硬件。这是我一直想知道的事情，我将在第二部分回到这一点。</p><p id="816d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae kc" href="https://medium.com/dev-genius/a-crash-course-on-floating-point-numbers-in-a-computer-part-ii-6fca16a0a321" rel="noopener">第二部</a>中的算术我就不太深入了。同样在第二部分，什么样的浮点数是好的和不好的，以及它们在主要编程语言中是如何使用的。</p></div></div>    
</body>
</html>