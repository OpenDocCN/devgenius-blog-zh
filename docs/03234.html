<html>
<head>
<title>A crash course on floating point numbers in a computer, Part I</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">计算机中浮点数的速成教程，第一部分</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/a-crash-course-on-floating-point-numbers-in-a-computer-part-i-a7a70f67a27?source=collection_archive---------2-----------------------#2020-10-15">https://blog.devgenius.io/a-crash-course-on-floating-point-numbers-in-a-computer-part-i-a7a70f67a27?source=collection_archive---------2-----------------------#2020-10-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/acd15a1ec70c7e7e0fba729746424855.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YWZEXC1zBZ3OjBHG"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">在天文学中，需要测量很大的距离，但一般不需要精确到毫米。照片由<a class="ae kc" href="https://unsplash.com/@sippakorn?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> sippakorn yamkasikorn </a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="f041" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">与整数不同，计算机中的浮点数系统不使用二进制补码来表示负数。然而，浮点数有一些细节使它们变得非常复杂。</p><p id="e5e0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">浮点数格式可能会让人们感到非常困惑，因为它们与整数格式相比，与我们对数字的理解相去甚远，我在<a class="ae kc" href="https://medium.com/@alonso.delarte/a-crash-course-on-integers-in-twos-complement-in-a-computer-d155734043a4" rel="noopener">的一篇早期文章</a>中对此进行了解释。</p><p id="6a5d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于一般的程序员来说，用二进制补码做白板计算，甚至当心算都不算太难。但是用浮点数做白板计算是相当困难的，通常需要计算器的帮助。</p><p id="3d3d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">即便如此，至少对浮点数的工作原理、它们的优点和缺点有一个基本的了解，可以帮助您在任何主流编程语言中使用浮点数时避免一些不愉快的意外。</p><p id="9618" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">浮点的反义词是定点。整数格式都是定点格式:放置“二进制点”是为了只表示整数，因此您可以想象计算机中的整数在结尾总是有一个隐含的“. 000……”。</p><p id="b32a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">整数中的最低有效位只能表示 0 × 1 或 1 × 1，下一个最低有效位只能表示 0 × 2 或 1 × 2，下一个最低有效位只能表示 0 × 4 或 1 × 4，以此类推，直到到达无符号整数中最左边的位(我在上一篇文章中介绍了负数是如何表示的)。</p><p id="9f06" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">表示像 7.25 这样的数字的一种可能的定点系统是分配 64 位，并同意中间的一位表示 0 × 1 或 1 × 1。左边的位对应于 2、4、8、16、32 等。右边的位对应于 1/2、1/4、1/8、1/16、1/32 等。</p><p id="fe21" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个定点系统可以表示小到 1/4294967296 的正数，如果没有符号，则可以表示大到 42949672961/4294967296 的正数。听起来范围很广。</p><p id="b639" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">问题是，科学计算需要的数字比这种定点系统的最小值和最大值小得多，也大得多。</p><p id="4ac7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">科学家估计宇宙包含 4 × 10⁸⁰粒子。普朗克长度大约是 1.6 米除以 10 ⁵.这两个数字都在上述定点系统的范围之外。</p><p id="fd60" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们可以说，对于一些数字来说，“二进制点”非常靠近左边，而对于一些数字来说非常靠近右边，会怎么样呢？或者在某些情况下在比特模式之外？</p><p id="7864" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就这样，浮点诞生了。位模式的一部分表示定点数，如 1.7500152587890625，位模式的一部分表示指数，如 14。那么我们就有了 1.7500152587890625 × 2 ⁴ = 28672.25。</p><p id="d4fe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">电气和电子工程师协会(IEEE)于 1985 年对当今几乎所有计算机使用的浮点数系统进行了标准化，并于 1990 年“重新确认”和 2008 年进行了修订。</p><p id="efb2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">详细描述该标准的文档被称为 IEEE 754。如果需要更具体的，可以参考“IEEE 754–1985”或者“IEEE 754–2008”。</p><p id="47e8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">图形专家可能会说整数格式是“无损的”(像 PNG)，浮点格式是“有损的”(像 JPEG——尽管 JPEG 也有无损版本；我持怀疑态度)。</p><p id="f2fc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如 JPEG 压缩可以通过牺牲原始图像的一些像素来用于任何图像一样，浮点可以通过牺牲一些精度来用于任何“实数”。虽然有些人的牺牲比其他人大得多。</p><p id="b34a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以进一步扩展类比:高 JPEG 压缩会产生一个非常小的文件，但图像质量可能会受到影响。低 JPEG 压缩会产生较大的文件(希望仍然小于原始图像文件)，但图像质量可能足够好，压缩后的图像与原始图像无法区分，至少对于人眼来说是如此。</p><p id="6beb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，有些位可以用浮点表示任何实数，但精度会受到影响。用几个比特，表示可能非常不准确。如果位数更多，这种表示可能会相当准确。</p><p id="1231" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们考虑到一个给定的任意整数要么可以用一个特定的位宽来表示，要么不能，这个类比就站不住脚了。</p><p id="ca1d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，65537 远远超出了 8 位整数(有符号或无符号)的范围，它只是稍微超出了有符号 16 位整数的范围。当然，它很容易用 32 位整数表示，有符号或无符号。</p><p id="a2a5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在 32 位浮点(称为“单精度”)中，65537.0 很容易以完美的精度拟合。在 16 位浮点(称为“半精度”)中，我们将不得不满足于 65504.0，相差 33.0。</p><p id="70f3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在 8 位浮点中(如果任何人有规律地使用它，它将被称为“四分之一精度”)，65537.0 将作为正无穷大丢失。八位可能是理论最小位宽，十六位可能是实际最小位宽。</p><p id="d934" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">浮点最常用的位宽是前面提到的 32 位格式和 64 位格式(称为“双精度”)。对于本文，为了使示例更容易理解，我将主要使用 16 位。</p><p id="7fbb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">128 位的“四倍精度”当然是可能的，但无论从理论上还是实践上来说，这都不是最大值。但是它倾向于用软件而不是硬件来实现。</p><p id="9678" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以也应该把浮点数想象成分成三组位:</p><ul class=""><li id="b6c3" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">符号位，总是在左边一位，正数为 0，负数为 1。</li><li id="2f8f" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">以 2 为基数的指数位表示 2 的幂。16 位中有 5 位，32 位中有 8 位，64 位中有 11 位。</li><li id="c891" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">尾数位，也称为有效位。16 位中有 10 位，32 位中有 23 位，64 位中有 52 位。这些位可以表示有限的一组无符号有理数中的数，作为一种定点系统。</li></ul><p id="d86f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">将符号位视为 1 的指数可能会有所帮助。请记住，(−1)⁰ = 1 且(1)= 1。因此，我们将符号位表示的 1 的幂乘以指数位表示的 2 的幂，再乘以尾数位表示的有理数。</p><p id="28e6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，假设符号位打开表示 1，指数位设置为表示 2⁷，尾数位设置为表示 3/2。则 1×128×3/2 = 192。</p><p id="31ac" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们再做一个:符号位关闭以表示 1，指数位设置为表示 2 的 7 次方，尾数位仍然设置为表示 3/2。那么 1 × 1/128 × 3/2 = 3/256 = 0.01171875。</p><p id="70dd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">很简单，对吧？这里有几条皱纹。</p><p id="8bc9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">也许最容易理解的一点是，在浮点运算中，不管位宽如何，0 都有两种不同的表示:“正”0 和“负”0。</p><p id="95e4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">16 位浮点中“正”零的位模式是 00000000 000000。16 位浮点中“负”零的位模式是 10000000 000000。</p><p id="0ffe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">0 有两个不同的表示是二进制补码解决的问题之一。整数格式可以表示的每个数字都有一个明确的表示。</p><p id="d2e7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在有符号整数格式中，符号位开启而所有其它位关闭的位模式不对应于 0，而是对应于位宽中可以表示的最小负数(例如，有符号 16 位整数为 32768)。</p><p id="a007" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最低负数的绝对值刚好在整数格式的范围之外(例如，32768 不能用有符号的 16 位整数表示)，但这是为没有两个零而付出的小小代价。</p><p id="5260" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">预计计算机会将浮点中的“正”零和“负”零视为相等，即使它们的位模式不同。</p><p id="f769" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">比如负零的平方根当然是零。如果像 Intel 8087 这样的浮点芯片有一条平方根指令，那么这条指令不会给出负数的结果，但它仍有望给出负零的正确结果。</p><p id="f647" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对比也比较复杂。在有符号整数格式中，符号位为 on 的数小于符号位为 off 的数，但这是唯一需要注意的。</p><p id="c5cf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">整数格式中最低负数的位模式对应于小于对应于 1 的无符号整数的无符号整数(例如，在无符号 16 位整数中，32768 的位模式与 32768 相同，1 的位模式与 65535 相同)。</p><p id="1b5a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但在浮点运算中，“负”零大于任何带符号位的数字(如 0.875)，但其整数位模式小于任何负数。</p><p id="1cd0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这只是使浮点数比较复杂化的一个细节。我甚至还没有提到规范化(稍后我会提到)。</p><p id="45ad" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于人类来说，写出 16 位类型的位模式是乏味且容易出错的。将浮点数的位模式表示为无符号的十六进制整数通常更方便。</p><p id="3584" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是因为一个十六进制数字恰好对应四位:0 对应 0000，1 对应 0001，2 对应 0010，3 对应 0011，以此类推，E 对应 1110，F 对应 1111。</p><p id="3f9f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于本文的其余部分，我假设您已经知道十六进制。回到“正”和“负”零，我应该提到十六进制数字 8 对应于位模式 1000。</p><p id="530c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们可以将 16 位浮点中“正”零的位模式写为 0000，将“负”零的位模式写为 8000，而不是写出 16 个零或单个 1 后跟 15 个零。</p><p id="62cd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，我仍然会用二进制写出指数位模式，就像 16 位浮点数的 5 个指数位。</p><p id="8f44" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在符号位之后，是指数位，它代表一个很小且非常有限的有理数。</p><p id="8f79" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">负指数意味着由尾数位表示的数字乘以 2 的非整数幂，如 1/2、1/4、1/8、1/16、1/32 等。</p><p id="bd9d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">作为指数的零意味着尾数位表示的数字乘以 1。而正指数意味着由尾数位表示的数字乘以 2 的整数幂，如 2、4、8、16、32 等。</p><p id="50fb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">IEEE 754 浮点格式不使用任何二进制补码。在 16 位浮点运算中，有五个指数位，11111 并不意味着 1(如果所有指数位都开启，这有一个特殊的含义，我将在后面解释)。</p><p id="648f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">指数位没有自己的符号位。因此指数位代表 0 或一个小的正整数。尽管事实证明所有指数位关闭也有特殊的含义。那么指数位只能代表小正整数？</p><p id="d5ac" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么似乎没有办法表示 8(正指数但符号位开启)或 0.125(负指数但符号位关闭)这样的数字。</p><p id="6e40" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这就是“偏见”概念的由来。偏差是从指数位代表的整数中减去的正整数(或者是加上的负数，如果你愿意这样想的话)。</p><p id="939a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">偏差取决于位宽。在 16 位浮点中，偏差为 15，在一种特殊情况下为 14。32 位的偏差始终为 127(除非在特殊情况下为 126)，64 位的偏差为 1023(或特殊情况下为 1022)。</p><p id="d448" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，在 16 位浮点中，指数位中的 01010 表示 10(十)无偏差，5 有偏差。</p><p id="f6f0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所有指数位关闭时的偏差相同，只有最低有效指数位开启时的偏差相同。所有指数位的偏差实际上无关紧要，我将在后面解释。</p><p id="5197" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为偏向是奇数，奇数偏向偶数指数，偶数偏向奇数指数，除了 0，它偏向 1 偏向的相同偶数指数。</p><p id="e7b2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，在 16 位浮点中，00001 偏向 14，00000 也偏向 14。同样，在 32 位浮点中，00000001 和 00000000 都偏向 126；在 64 位浮点中，0000000001 和 000000000 都偏向 1022。</p><p id="259e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果之前不清楚，现在应该清楚了，整个浮点数系统对于人们的理解来说是相当混乱的，这也是一些较老的芯片无法进行浮点计算的部分原因。</p><p id="8a2a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">16 位浮点中的指数位可以表示从 14 到 15 的指数。然后，如果符号位关闭，尾数位表示 1，则 16 位浮点数可以小到 1/16384，大到 32768.0。</p><p id="9dd0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么…如果尾数位可以表示 0，指数位可以表示至少八个不同的整数，为什么 0 没有至少十六个不同的表示呢？</p><p id="e5f3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">比如 0000 和 8000 是 16 位浮点中 0 的表示，那么 0400，0800，0C00，…，7800，8000，8400，8800，8C00，…，F800 不也应该是 0 的表示吗？</p><p id="7141" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有两种不同的零表示法已经够浪费的了。为了避免所有的冗余，并挤出多一位的精度，浮点标准包括了正常数和次正常数的概念，我将谈到这一点。</p><p id="7b36" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我前面提到过，浮点数的尾数位可以代表一个有限的有理数小集合中的任何一个定点数格式的数。</p><p id="4062" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">快速复习:有理数是一个整数除以一个非零整数的结果。即<em class="lp"> a </em> / <em class="lp"> b </em>是一个有理数，其中<em class="lp"> a </em>和<em class="lp"> b </em>都是整数，<em class="lp"> b </em> ≠ 0。例如，16/9 是一个有理数。</p><p id="a832" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于π这样的无理数没有这样的表示，大概是 3.14159，但是可以用 22/7 这样的有理数来近似。</p><p id="fffd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，在浮点运算中，许多看起来在范围内的有理数也必须近似，就像它们是无理数一样，因为分母限制为 2 的幂，分子根据分配给尾数位的位宽而受到限制。</p><p id="f403" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，1/3 = 1/4+1/16+1/64+1/256+1/1024+1/4096+…这意味着位模式 0.010101010101…无限重复“01”。但是在计算机芯片上，我们没有无限多的位来处理。</p><p id="f8ba" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于 16 位浮点运算，我们只有 10 位来处理尾数位。像整数格式一样，尾数位代表一个定点数，但关键区别是 2⁰的位在左边而不是右边。</p><p id="fe77" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么 2⁰比特右边的比特代表具有负指数的 2 的幂，意味着分数幂:1/2、1/4、1/8、1/16 等。</p><p id="a581" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些事实表明，为了表示 1/3，我们必须满足于尾数位中的 0.010101010，这表示 1/4 + 1/16 + 1/64 = 21/64 = 0.328125。那是 1/3 的 1/192，大约是 0.0052083333333333333。</p><p id="f5fc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我看来，这是不可接受的不精确。仅仅能够将 1/256 相加就可以得到 85/256 = 0.33203125。这是 1/3 的 1/768，大约是 0.0013020833333333333。我觉得这样更好。</p><p id="e853" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过将尾数位从 0.010101010 更改为 1.010101010，我们可以得到 1/256，从而接近 4/3 而不是 1/3，并将指数位设置为 2 的 2 次方而不是 2⁰，这意味着除以四分之一而不是乘以 1。</p><p id="534b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">事实证明，对于几乎所有的数字来说，让尾数位表示大于或等于 1 的数字，并设置指数位以使尾数位达到期望的幅度更有意义。</p><p id="a986" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果尾数位几乎总是以 1 开始，为什么不省略它，并理解它是隐含的呢？这样，我们就能多一点精确。</p><p id="f92b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在 1/3 的例子中，它非常有用:一个隐含的“1”接下来是“0101010101”，这意味着我们得到了 4/3 的更好的近似值，即 1 + 341/1024 = 1.3330078125，与 1/3 相差 1/3072。我觉得好多了。位模式是 3555。</p><p id="1d56" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是现在我们遇到了如何表示 0.0 的问题。如果总有一个隐含的“1”对于尾数位，尾数位无法表示 0。</p><p id="f015" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">解决方案是得出“正常化”和“非正常化”(或“次正常化”)的数字。后者没有被“标准化”为在尾数位的前面隐含 1 位。</p><p id="03f7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">大多数数字，如 0.875 和 1365/1024，都被“规范化”，在尾数位中包含隐含的前导 1。但是“正”零和“负”零被“反规格化”以排除尾数位隐含的前导 1。</p><p id="545e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当所有指数位关闭时，发生反规格化。然后，指数位不是表示比仅最低有效指数位为 on 时给出的指数小 1 的指数(16 位浮点时为 15，比 14 小 1)，而是表示相同的指数(16 位浮点时为 14)。</p><p id="954d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">16 位浮点中指数 15 的损失可以通过尾数位表示较小数字的能力来弥补。</p><p id="e51d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果没有反规格化机制，位模式 0001 将意味着 1/32768×1 = 1/32768 = 0.000030517578125。</p><p id="2569" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">非规格化的 16 位浮点数中的尾数位可以仅表示 1/1024，而不是表示 1 + 1/1024。而 1/16384×1/1024 = 1/16777216 = 0.00000005960464775390625，比 1/32768 = 0.000030517578125 小得多的数。</p><p id="963d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当然，如果所有尾数位都关闭，指数位偏向哪个并不重要。零乘以任何东西仍然是零。</p><p id="eb02" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在网上，你可以找到一些不同的工具，通过点开和点关来帮助你可视化浮点数。有些工具会显示数字何时被规范化或反规范化，有些则不会。</p><p id="0b98" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">H. Schmidt 的浮点转换器<a class="ae kc" href="https://www.h-schmidt.net/FloatConverter/IEEE754.html" rel="noopener ugc nofollow" target="_blank">显示了一个 32 位浮点数。尝试在“您输入的”框中输入 3.14，然后按 Enter 或 Tab 键。它应该显示指数为 2 (128)，尾数大约为 1.57 (4781507)。</a></p><p id="a1c3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在试着输入“9.2321990039091357031360307 e-39”，它大约等于π除以 2 ⁸.您应该看到指数变为 2 的 126 次方，括号中为“反规格化”，尾数为 0.7853981256484985，也标记为“反规格化”。</p><p id="9d3b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所有指数位关闭。所有指数位的开启也有特殊的意义，但是总体位模式并不代表任何特定的数字。</p><p id="a0b2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果所有的指数位都是开的，但所有的尾数位都是关的，那么该值要么是正无穷大，要么是负无穷大，这取决于符号位。所以在 16 位浮点中，正无穷大是 7C00，负无穷大是 FC00。</p><p id="eaba" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是，如果所有指数位都关闭，但只有一个尾数位打开(符号位无关紧要)，则位模式表示特殊值“不是数字”，通常称为“NaN”</p><p id="94fd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一些算术运算给出的结果要么是不确定的，要么是一个虚数，比如数字<em class="lp"> i </em>使得<em class="lp">I</em>= 1。或者不那么迂腐地说，<em class="lp"> i </em>是 1 的主平方根(另一个是<em class="lp"> i </em>)。</p><p id="f520" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在施密特的转换器中，尝试点击所有的指数位。显示屏应该变为 NaN。现在试着关掉尾数位。一旦关闭最后一个尾数位，显示将变为无穷大。</p><p id="c5d5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在 16 位浮点中，有两千多种不同的方式来表示 NaN，从 7C01 到 7FFF，从 FC01 到 FFFF。在 64 位浮点中，多个 NaN 值的明显浪费要大得多，数量级为万亿。</p><p id="ae95" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">大概可以从 NaN 中恢复一些信息，尽管据说这依赖于硬件。这是我一直想知道的事情，我将在第二部分回到这一点。</p><p id="816d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae kc" href="https://medium.com/dev-genius/a-crash-course-on-floating-point-numbers-in-a-computer-part-ii-6fca16a0a321" rel="noopener">第二部</a>中的算术我就不太深入了。同样在第二部分，什么样的浮点数是好的和不好的，以及它们在主要编程语言中是如何使用的。</p></div></div>    
</body>
</html>