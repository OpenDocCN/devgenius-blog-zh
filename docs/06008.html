<html>
<head>
<title>How to build SpringBoot API for eCommerce App using NoSQL Datastore — Elasticsearch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用NoSQL数据存储为电子商务应用程序构建SpringBoot API</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-to-build-springboot-api-for-ecommerce-app-using-nosql-datastore-elasticsearch-a8ba850c0a78?source=collection_archive---------2-----------------------#2021-12-04">https://blog.devgenius.io/how-to-build-springboot-api-for-ecommerce-app-using-nosql-datastore-elasticsearch-a8ba850c0a78?source=collection_archive---------2-----------------------#2021-12-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="30b4" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">典型产品搜索功能的系统开发权威指南</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/73084fd2f3ab34d3d0a01ed0ad15d302.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xD2mCk0DBjyV6PRLUqZ82A.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@grakozy?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上<a class="ae kv" href="https://unsplash.com/@grakozy?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Greg Rakozy </a>拍摄的照片</figcaption></figure><p id="4f56" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于电子商务来说，产品搜索是一项至关重要的功能。传统技术—关系数据库不够灵活，无法处理高级搜索功能和不断增长的请求量。因此，许多人转向替代解决方案，如NoSQL，以开发灵活和高性能的系统。</p><p id="18e7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">说到<a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/how-to-enable-powerful-full-text-search-for-your-apps-mysql-vs-elasticsearch-f35ac45f816e">全文搜索和强大的搜索功能</a>，Elasticsearch是一个很受欢迎的数据存储。它基于Lucene支持的分布式数据存储的设计，实现了高度可伸缩的架构。</p><p id="203a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，与Elasticsearch的集成不同于传统的关系数据库。例如，Elasticsearch是一个基于文档的数据库，其查询基于REST APIs，而关系数据库利用JDBC连接上的SQL语句。拥有基于SQL的应用程序开发技能的软件工程师在构建基于Elasticsearch的应用程序时，可能会遇到一个陡峭的学习曲线。</p><p id="b145" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">关键是要熟悉基本的REST APIs和Java query builder的使用。在本文中，我将向您展示产品搜索的典型用例，并演示如何用REST APIs和Java代码构建查询。示例代码将为Elasticsearch应用程序开发提供一个快速入门工具。</p><h1 id="75b9" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">电子商务网站中的典型产品查询</h1><p id="3664" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">对于典型的电子商务网站，以下查询是必备功能:</p><ul class=""><li id="7d1d" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated">按类别浏览产品</li><li id="d9b8" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">按关键字搜索产品</li><li id="3047" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">搜索相关产品</li></ul><p id="ab1d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，所有的查询应该允许客户通过相关性，价格或其他特定领域的搜索结果排序。此外，分页是网站的另一个重要功能，有助于记录导航。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nd"><img src="../Images/7e3a10056a1db9948cd24a41bd1e66db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RHNcq2xlYtTZV5VLSGa9mg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">产品搜索用例</figcaption></figure><h1 id="dabf" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">系统概况</h1><p id="2c54" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">为了实现用于产品查询的后端API，SpringBoot应用程序遵循了控制器-服务-存储库的典型设计模式。产品存储库负责访问Elasticsearch。Spring框架提供了一个实用程序类<code class="fe ne nf ng nh b"><strong class="ky ir">ReactiveElasticsearchTemplate</strong></code>，作为与Elasticsearch的REST APIs集成的“驱动程序”。该系统基于Spring Weblfux，支持非阻塞I/O操作。</p><p id="0ae9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我们将关注产品存储库的开发和用例的查询设置。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ni"><img src="../Images/6df4b27c081df855836879b838eff2b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RTddQGMlKQ5_aL01FxIFeA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">SpringBoot API系统概述</figcaption></figure><h1 id="3b96" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">开发环境设置</h1><h2 id="f258" class="nj lt iq bd lu nk nl dn ly nm nn dp mc lf no np me lj nq nr mg ln ns nt mi nu bi translated">设置弹性搜索+样本数据</h2><p id="50fa" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">首先，您需要设置一个Elasticsearch实例，并在您的本地环境中使用示例数据运行。无需经历复杂的安装步骤，您可以使用docker image轻松创建一个一次性实例。从这个GitHub存储库中获取源代码</p><div class="nv nw gp gr nx ny"><a href="https://github.com/gavinklfong/spring-online-supermarket" rel="noopener  ugc nofollow" target="_blank"><div class="nz ab fo"><div class="oa ab ob cl cj oc"><h2 class="bd ir gy z fp od fr fs oe fu fw ip bi translated">GitHub-gavinklfong/spring-Online-Supermarket:网上超市的SpringBoot演示</h2><div class="of l"><h3 class="bd b gy z fp od fr fs oe fu fw dk translated">该存储库包含Webflux SpringBoot应用程序的源代码，用于演示与…</h3></div><div class="og l"><p class="bd b dl z fp od fr fs oe fu fw dk translated">github.com</p></div></div><div class="oh l"><div class="oi l oj ok ol oh om kp ny"/></div></div></a></div><p id="8e9b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">进入<strong class="ky ir"> docker-compose </strong>文件夹。然后，您可以使用以下命令启动实例:</p><pre class="kg kh ki kj gt on nh oo op aw oq bi"><span id="3a8f" class="nj lt iq nh b gy or os l ot ou">docker compose up</span></pre><p id="52e1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦docker容器启动并运行，通过运行下面的命令导入示例产品数据。它启动Logstash并将JSON文件<code class="fe ne nf ng nh b">logstash-data/products.json</code>送入Elasticsearch。在数据导入过程中，控制台将向您显示产品记录。</p><pre class="kg kh ki kj gt on nh oo op aw oq bi"><span id="23cd" class="nj lt iq nh b gy or os l ot ou">docker run --rm -it \<br/>-v <strong class="nh ir">.</strong>/logstash-pipeline\:/usr/share/logstash/pipeline/ \<br/>-v <strong class="nh ir">.</strong>/logstash-data/products.json:/usr/share/logstash/data/products.json \<br/>--network docker-compose_default \<br/>logstash:7.14.2</span></pre><p id="f542" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Elasticsearch实例通过9200端口公开REST APIs。要验证Elasticsearch上的产品记录，请在Postman上触发这个HTTP请求，或者运行下面的CURL命令来检索所有产品记录。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ov ow l"/></div></figure><p id="aa57" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每个产品记录由一个唯一的id、名称、类别、价格、品牌和库存指标组成。类别是一个层次结构。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ox"><img src="../Images/6638ff565234cfdbd2194dc41dd99e59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_Cwox9D-kGPcC7RWZ59Z_A.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">使用Postman触发Elasticsearch REST API</figcaption></figure></div><div class="ab cl oy oz hu pa" role="separator"><span class="pb bw bk pc pd pe"/><span class="pb bw bk pc pd pe"/><span class="pb bw bk pc pd"/></div><div class="ij ik il im in"><h1 id="cace" class="ls lt iq bd lu lv pf lx ly lz pg mb mc jw ph jx me jz pi ka mg kc pj kd mi mj bi translated">Maven依赖性</h1><p id="044e" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">由于示例实现将基于Spring Weblfux，您需要以下SpringBoot Webflux启动器和数据访问来进行Elasticsearch</p><pre class="kg kh ki kj gt on nh oo op aw oq bi"><span id="5ff4" class="nj lt iq nh b gy or os l ot ou"><strong class="nh ir"><em class="pk">&lt;</em>dependency<em class="pk">&gt;<br/>  &lt;</em>groupId<em class="pk">&gt;</em></strong>org.springframework.boot<strong class="nh ir"><em class="pk">&lt;/</em>groupId<em class="pk">&gt;<br/>  &lt;</em>artifactId<em class="pk">&gt;</em></strong>spring-boot-starter-data-elasticsearch<strong class="nh ir"><em class="pk">&lt;/</em>artifactId<em class="pk">&gt;<br/>&lt;/</em>dependency<em class="pk">&gt;<br/>&lt;</em>dependency<em class="pk">&gt;<br/>  &lt;</em>groupId<em class="pk">&gt;</em></strong>org.springframework.boot<strong class="nh ir"><em class="pk">&lt;/</em>groupId<em class="pk">&gt;<br/>  &lt;</em>artifactId<em class="pk">&gt;</em></strong>spring-boot-starter-webflux<strong class="nh ir"><em class="pk">&lt;/</em>artifactId<em class="pk">&gt;<br/>&lt;/</em>dependency<em class="pk">&gt;</em></strong></span></pre><p id="8a0a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，该库提供的实用程序类对于测试Webflux请求非常有用</p><pre class="kg kh ki kj gt on nh oo op aw oq bi"><span id="5a07" class="nj lt iq nh b gy or os l ot ou"><strong class="nh ir"><em class="pk">&lt;</em>dependency<em class="pk">&gt;<br/>  &lt;</em>groupId<em class="pk">&gt;</em></strong>io.projectreactor<strong class="nh ir"><em class="pk">&lt;/</em>groupId<em class="pk">&gt;<br/>  &lt;</em>artifactId<em class="pk">&gt;</em></strong>reactor-test<strong class="nh ir"><em class="pk">&lt;/</em>artifactId<em class="pk">&gt;<br/>  &lt;</em>scope<em class="pk">&gt;</em></strong>test<strong class="nh ir"><em class="pk">&lt;/</em>scope<em class="pk">&gt;<br/>&lt;/</em>dependency<em class="pk">&gt;</em></strong></span></pre></div><div class="ab cl oy oz hu pa" role="separator"><span class="pb bw bk pc pd pe"/><span class="pb bw bk pc pd pe"/><span class="pb bw bk pc pd"/></div><div class="ij ik il im in"><h1 id="3edd" class="ls lt iq bd lu lv pf lx ly lz pg mb mc jw ph jx me jz pi ka mg kc pj kd mi mj bi translated">按类别列出产品</h1><p id="8c55" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">处理Elasticsearch的查询与SQL语句完全不同。Elasticsearch上的原生查询是通过REST API请求完成的。因此，第一步是在Java编码之前创建REST API查询。</p><p id="98b4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为产品类别采用分层格式，如<code class="fe ne nf ng nh b"><em class="pk">[Parent Category]/[Child category]</em></code> <em class="pk">。“</em>匹配短语前缀”查询对于查找具有指定前缀的类别的所有产品非常有用。例如，下面的REST API查询列出了“饮料/碳酸饮料”类别下的所有产品。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ov ow l"/></div></figure><p id="c0f3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要构建Java代码，首先需要将<code class="fe ne nf ng nh b"><strong class="ky ir">ReactiveElasticearchTemplate</strong></code>注入到产品存储库类中。我们不直接使用<code class="fe ne nf ng nh b"><strong class="ky ir">RectiveElasticsearchTemplate</strong></code>，而是引用它的实现接口<code class="fe ne nf ng nh b"><strong class="ky ir">ReactiveElasticsearchOperations</strong></code>。</p><p id="3189" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，使用<code class="fe ne nf ng nh b"><strong class="ky ir">NativeSearchQueryBuilder</strong></code>构造一个查询对象。这一步非常简单，因为其结构与REST API请求非常相似。</p><p id="8921" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Elasticsearch客户端是一个响应式客户端，这意味着它会立即返回一个Flux对象，而无需等待I/O操作。一旦收到Elasticsearch的回复，Flux将向用户返回一个搜索结果列表。您将能够从每个搜索命中的内容中获得产品。如果您是Spring Webflux的新手，那么您会发现这篇文章非常有用，因为它是Spring Webflux应用程序开发的介绍，并附有实际例子。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ov ow l"/></div></figure><h1 id="22ee" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">按关键字搜索</h1><p id="be64" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">关键字搜索是许多电子商务网站上最常用的功能。如果你不知道该看哪一类，这是找到目标产品的快捷方法。</p><p id="dd43" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以使用REST API中的“查询字符串”进行关键字搜索，它基本上是一个全文搜索功能。为了将搜索范围缩小到特定的数据字段，我们重点关注产品名称、类别和品牌。</p><p id="df76" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">产品名称的匹配更相关，因此我们强调使用语法“name^2”的产品名称字段，它指定了产品名称的权重，因此任何产品名称与关键字匹配的记录都将具有高相关性分数。</p><p id="0b7f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面的示例查询搜索带有通配符“hom*”的关键字</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ov ow l"/></div></figure><p id="eab9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面的示例结果显示，产品名称与关键字匹配的记录比类别与关键字匹配的记录得分更高。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ov ow l"/></div></figure><p id="564c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看看如何用Java代码实现查询。同样，同样的结构可以从REST API查询翻译成Java中的<code class="fe ne nf ng nh b"><strong class="ky ir">NativeSearchQuery</strong></code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ov ow l"/></div></figure><h1 id="e169" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">找出相关产品</h1><p id="f307" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">当我们浏览产品详情页面时，电子商务网站通常会显示与我们正在查看的产品相关的其他产品列表，以促进销售。但是，相关性没有一个通用的定义，它确实取决于业务需求。出于演示目的，相关产品必须满足这两个匹配条件</p><ol class=""><li id="d4f1" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr pl mv mw mx bi translated">产品名称匹配当前产品名称的关键字，并且</li><li id="281a" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr pl mv mw mx bi translated">类别前缀与当前产品的类别相匹配。</li></ol><p id="1eff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面的REST API查询展示了布尔查询的使用，布尔查询是多个匹配条件的容器。每个匹配条件都有一个<strong class="ky ir"> must </strong>子句，以确保搜索结果符合搜索标准。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ov ow l"/></div></figure><p id="4714" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">复合查询然后可以被翻译成Java代码中查询构造的方法调用</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ov ow l"/></div></figure></div><div class="ab cl oy oz hu pa" role="separator"><span class="pb bw bk pc pd pe"/><span class="pb bw bk pc pd pe"/><span class="pb bw bk pc pd"/></div><div class="ij ik il im in"><h1 id="5a2f" class="ls lt iq bd lu lv pf lx ly lz pg mb mc jw ph jx me jz pi ka mg kc pj kd mi mj bi translated">给我看看价格最低的匹配产品</h1><p id="3bba" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">如果搜索结果返回数百甚至数千条记录，那么识别正确的产品是一项挑战。一种快速的方法是按特定的数据字段(如价格)对结果进行升序排序。默认情况下，Elasticsearch按匹配分数降序排列查询结果。换句话说，与查询最相关的记录被放在结果列表的顶部。</p><p id="60fb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于REST API，可以通过指定排序字段和排序方向来完成排序</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ov ow l"/></div></figure><p id="c459" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在Java代码中，将<code class="fe ne nf ng nh b">withSorts() </code>方法中的排序信息指定为查询构造的一部分。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ov ow l"/></div></figure><h1 id="5667" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">给我几页的结果</h1><p id="7492" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">Elasicsearch支持按页检索记录。这可以通过将目标页码和页面大小分别设置为参数“from”和“size”来实现。下面的示例按类别检索第一页的产品(" from" = 0)，每页有5条记录。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ov ow l"/></div></figure><p id="3a5f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在Java代码中，将带有页码和页面大小的<code class="fe ne nf ng nh b"><strong class="ky ir">PageRequest</strong></code>对象传递给查询构建器，然后通过调用<code class="fe ne nf ng nh b">searchForPage()</code>方法提交查询。将返回一个SearchPage对象，它不仅包含产品列表，还包含下一页的参数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ov ow l"/></div></figure><p id="1227" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面的示例代码显示了如何从SearchPage对象中提取记录和分页信息</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ov ow l"/></div></figure></div><div class="ab cl oy oz hu pa" role="separator"><span class="pb bw bk pc pd pe"/><span class="pb bw bk pc pd pe"/><span class="pb bw bk pc pd"/></div><div class="ij ik il im in"><h1 id="4d4d" class="ls lt iq bd lu lv pf lx ly lz pg mb mc jw ph jx me jz pi ka mg kc pj kd mi mj bi translated">最后的想法</h1><p id="260e" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">Elasticsearch支持许多强大的查询，如模糊匹配、邻近查询、同义词短语查询等。详情请查看<a class="ae kv" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.html" rel="noopener ugc nofollow" target="_blank">官方指南</a>。Spring框架提供了实用程序类，使得与Elasticsearch的集成变得简单方便，因为我们可以简单地将REST API查询映射到Java代码中。除了原生查询构建器类，Spring框架还提供了其他方式，如字符串查询、标准查询和类似JPA的存储库接口。然而，在撰写本文时，原生查询是最好的方法，因为其他方法要么只支持有限的查询功能，要么不能很好地工作。</p><p id="99ce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从这个GitHub库获得完整的示例实现:</p><div class="nv nw gp gr nx ny"><a href="https://github.com/gavinklfong/spring-online-supermarket" rel="noopener  ugc nofollow" target="_blank"><div class="nz ab fo"><div class="oa ab ob cl cj oc"><h2 class="bd ir gy z fp od fr fs oe fu fw ip bi translated">GitHub-gavinklfong/spring-Online-Supermarket:网上超市的SpringBoot演示</h2><div class="of l"><h3 class="bd b gy z fp od fr fs oe fu fw dk translated">该存储库包含Webflux SpringBoot应用程序的源代码，用于演示与…</h3></div><div class="og l"><p class="bd b dl z fp od fr fs oe fu fw dk translated">github.com</p></div></div><div class="oh l"><div class="oi l oj ok ol oh om kp ny"/></div></div></a></div></div><div class="ab cl oy oz hu pa" role="separator"><span class="pb bw bk pc pd pe"/><span class="pb bw bk pc pd pe"/><span class="pb bw bk pc pd"/></div><div class="ij ik il im in"><p id="abc3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="pk">更多内容尽在</em><a class="ae kv" href="http://blog.devgenius.io" rel="noopener ugc nofollow" target="_blank"><em class="pk">blog . dev genius . io</em></a><em class="pk">。</em></p></div></div>    
</body>
</html>