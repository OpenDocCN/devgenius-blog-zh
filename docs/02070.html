<html>
<head>
<title>Hidden Treasure Chronicle Queue</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">藏宝编年史队列</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/hidden-treasure-chronicle-queue-49d766a4252a?source=collection_archive---------14-----------------------#2020-07-18">https://blog.devgenius.io/hidden-treasure-chronicle-queue-49d766a4252a?source=collection_archive---------14-----------------------#2020-07-18</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/24ad1f710f012df15cdb6c2739942051.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-v5MAwyvQ66SG83tVb_Xtg.jpeg"/></div></div></figure><p id="4528" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">编年史是个很酷的名字，对吧？这就像科幻电影的人工智能。给我找到铀！</p><p id="d8d2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但不幸的是，这只是一个队列，这也是一个很好的队列。</p></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><p id="e7da" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在我们的项目<em class="kt">(这是一个网络项目，我们从设备中获取数据并对其进行分析)</em>有一个需求，1000万个设备对象必须被混洗并发送以从设备中获取数据。它们必须被打乱，因为你不应该同时访问多个网络设备，这会导致过多的网络活动，影响设备的网络质量。</p><p id="3f67" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">很简单，只要拿到物品，然后洗牌就行了。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="54c9" class="lk ll in lg b gy lm ln l lo lp">Collections.<em class="kt">shuffle</em>(list);</span></pre><p id="2f9e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">没有。这样做你的堆会大得惊人。1000万对象确实很大，对象有30-35个属性。</p><p id="f66a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果我没记错，我们第一次尝试时，堆大小超过10GB，应用程序崩溃了。</p></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><p id="8160" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">那么1000万个数据，我怎样才能在不导致堆大小大幅增加的情况下对它们进行洗牌呢？</p><p id="818a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我开始研究。我想把它们存储在一个文件中，然后随机获取它们，这样会很快，而且堆是免费的。但是你怎么能这样做呢？好的，你把所有的对象一行一行的存储到一个文件中，但是你怎么能随机的获取它们呢？文件没有行号来获取像<em class="kt"> lines.get(1) </em>这样的数据，我想我试图找到一个随机的行，但我什么也找不到。</p><p id="13b6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我不想用db。Mongo <em class="kt">(我们正在使用)</em>已经做了太多的工作，处理起来太慢了，随机获取数据仍然是个问题。</p></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><p id="ee12" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在搜索东西后，我偶然发现了编年史队列。</p><p id="6f10" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当我第一次读到它的时候，我就想“哦，这是我一直想做的事情。存储在文件中，每一行都有索引，并且是在堆外的。就这样，我找到了我的解决方案。</p><p id="05bc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我不会讲太多细节，但我会写我是如何解决我的问题的。</p></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><p id="c34c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先，我们需要创建队列；</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="e745" class="lk ll in lg b gy lm ln l lo lp">try (SingleChronicleQueue queue = SingleChronicleQueueBuilder.<em class="kt">binary</em>("/list").build()) {<br/>...<br/>} catch (Exception e) {<br/>    e.printStackTrace();<br/>}</span></pre><p id="3ee8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这样做，就创建了一个名为<em class="kt">“list”</em>的文件，在这个文件中有一个队列文件。默认情况下，每天都会创建队列，因此队列名称默认为20200718 <em class="kt">(今天)</em>。您不需要知道您的队列名称。你的文件名<em class="kt">(列表)</em>才是重要的。</p><p id="9e9e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">创建队列后，我们需要一个写入器和读取器。为了读和写，我们有两节课。</p></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><p id="f07f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">要将我们的对象写入队列，我们需要创建一个appender。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="ce0a" class="lk ll in lg b gy lm ln l lo lp">final ExcerptAppender appender = queue.acquireAppender();</span></pre><p id="2b45" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下一步是将1000万个对象写入队列。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="2aa0" class="lk ll in lg b gy lm ln l lo lp">...<br/>try (final DocumentContext documentContext = appender.writingDocument()) {<br/>    documentContext.wire().write("values").marshallable(value);<br/>    indexes.add(documentContext.index());<br/>} catch (Exception e) {<br/>    e.printStackTrace();<br/>}<br/>...</span></pre><p id="1615" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在我们的队列中，我们有一个类似于mongo集合的键集合列表。您的文件名是您的数据库，您的集合命名您的键。在这种情况下，我们的列表值将存储在<em class="kt">“值”中。</em>marshalable函数接受对象，所以你可以写任何你想写的东西。</p><p id="3710" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你仔细看我的代码，有一个<em class="kt">索引</em>列表，我添加了<em class="kt"> documentContext.index()。</em>那么这是做什么呢？</p><p id="0f16" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我需要重新摆放我的物品，对吗？所以通过在队列中保存每个对象写的行索引，我要通过这个索引来访问。1000万个长值并不能容纳太多的堆大小。这样我就可以洗牌，一个一个的拿。</p></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><p id="b264" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在将我们的对象写入队列时，我注意到在kubernates中，我们的应用程序的ram快用完了。我在kubernates中看到，应用程序的ram增加到15 GB，我认为它会崩溃。但它没有，我也不明白。因为在此之前，如果我们的应用程序的内存达到10 GB，它会立即崩溃。</p><p id="f1ac" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">之后，我看到了应用程序的实际内存大小，它只是1.2 GB。我又没听懂。为什么在kubernates中显示15 GB，但应用程序的实际ram大小只有1.2GB</p><p id="d7a4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在我的理解中，当我尝试本地队列文件的大小接近15 GB时，历史队列将数据存储在堆外。在kubernates豆荚可能显示太多内存，因为这一点。但是在队列关闭且任务完成后，它会立即被丢弃。</p></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><p id="4d6c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们要创建我们的阅读课。裁缝。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="4836" class="lk ll in lg b gy lm ln l lo lp">final ExcerptTailer tailer = queue.createTailer();</span></pre><p id="da21" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们的1000万数据在队列中，我们创建了tailer，现在我们需要获取它们。但是首先我们需要打乱我们的索引列表来随机获取我们的数据。<em class="kt">(也许有更有效的洗牌方式，但这对我来说已经足够了)</em></p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="c7d4" class="lk ll in lg b gy lm ln l lo lp">...<br/>Collections.<em class="kt">shuffle</em>(indexes);</span><span id="8fa8" class="lk ll in lg b gy lq ln l lo lp">indexes.forEach(index -&gt; {<br/>    tailer.moveToIndex(index);<br/>    try (DocumentContext documentContext = tailer.readingDocument()) {<br/>        if (documentContext.isPresent()) {<em class="kt"><br/>            </em>Map values = documentContext.wire().read("values").object(Map.class);<br/>            System.<em class="kt">out</em>.println(values.get("value"));<br/>        }<br/>    } catch (Exception e) {<br/>        e.printStackTrace();<br/>    }<br/>});<br/>...</span></pre><p id="d927" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在打乱我们的索引列表后，我们一个接一个地去那个索引所指向的地方并获取我们的数据。</p><p id="e287" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如你所见，我们从键<em class="kt">(值)</em>中读取，在该文件的行中，我们需要通过Map.class获取对象。在该Map类中，有一个<em class="kt">“值”</em>键保存我们的数据。这样获得数据后，你可以把它发送到你喜欢的任何地方。</p></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><p id="b4f8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">就这么简单。</p><p id="2152" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这样我解决了我的堆问题和洗牌问题。</p><p id="2438" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你应该自己去看看，它们真的很好，有很多很酷的东西可以用。</p><p id="5df3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里是<a class="ae lr" href="https://github.com/OpenHFT/Chronicle-Queue" rel="noopener ugc nofollow" target="_blank"> Github </a>。</p></div></div>    
</body>
</html>