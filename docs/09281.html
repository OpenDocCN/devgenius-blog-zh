<html>
<head>
<title>Ahead-of-time compiled language</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">超前的编译语言</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/ahead-of-time-compiled-language-7ad82de34702?source=collection_archive---------10-----------------------#2022-08-11">https://blog.devgenius.io/ahead-of-time-compiled-language-7ad82de34702?source=collection_archive---------10-----------------------#2022-08-11</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="c38d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Rust 是一种提前编译的语言，这意味着你可以编译一个程序并把可执行文件给其他人，他们甚至可以在没有安装 Rust 的情况下运行它。如果你给某人一个<em class="ki">。rb </em>，<em class="ki">。py </em>，或<em class="ki">。js </em>文件，他们需要分别安装 Ruby、Python 或 JavaScript 实现。</p><p id="d85e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">重要**</p><p id="74a9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">评论里的知识比整篇文章都多</p><p id="35bd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">评论</p><ol class=""><li id="b610" class="kj kk in jm b jn jo jr js jv kl jz km kd kn kh ko kp kq kr bi translated">刚听说过“超前编译”语言这个术语。但这就是二进制文件和可执行文件的作用。但是它们是为非常特定的目标机器构建的，例如，如果我在 x86 机器- Windows 机器上编译二进制文件，它将在另一台相同的机器上运行良好。但是同样的二进制文件不能在 arm64-Linux 机器上运行。</li><li id="10ad" class="kj kk in jm b jn ks jr kt jv ku jz kv kd kw kh ko kp kq kr bi translated">如果我用 Linux 目标编译它并把它给 Windows 用户，那么这个人需要安装运行时 Linux。发行版是相关的，因为它将动态链接到特定版本的 glibc</li><li id="69d8" class="kj kk in jm b jn ks jr kt jv ku jz kv kd kw kh ko kp kq kr bi translated">除非你的目标是 musl。那么无论 glibc 版本如何，您都可以在任何 Linux 目标上运行。货物交叉是伟大的。</li><li id="80de" class="kj kk in jm b jn ks jr kt jv ku jz kv kd kw kh ko kp kq kr bi translated">然后发行不再是一个问题，但 Windows/Linux/Mac 仍然存在。</li><li id="3c64" class="kj kk in jm b jn ks jr kt jv ku jz kv kd kw kh ko kp kq kr bi translated">你好，MUSL 爱好者👋</li><li id="62db" class="kj kk in jm b jn ks jr kt jv ku jz kv kd kw kh ko kp kq kr bi translated">通常是这样，但不总是/完全正确。如果你编译🦀信任一个目标，然后你会得到一个字节码文件，它不能在任何平台上执行，但是需要一个合适的 WASM 运行时，比如 Wasmtime，Wasmi，Wasmer，WAMR，WaVM，WasmVM，或者十几个中的一个，或者内置在现代网络浏览器中的一个。</li><li id="c0cd" class="kj kk in jm b jn ks jr kt jv ku jz kv kd kw kh ko kp kq kr bi translated">用 Rust 瞄准 WASM 基本上遵循了与<a class="ae kx" href="https://www.linkedin.com/feed/hashtag/?keywords=java" rel="noopener ugc nofollow" target="_blank"> #Java </a>相同的原则:创建将由运行时 VM 执行的字节码工件。根据所选择的运行时，执行可以是解释的(最常见的)，实时编译的(JITC)，或者两者的混合。缺省情况下，Java 运行时通常主要使用 JITC，现在解释只是在边缘情况下的一种备用方法。</li><li id="625f" class="kj kk in jm b jn ks jr kt jv ku jz kv kd kw kh ko kp kq kr bi translated">WASM 和 JVM(或 C#)字节码之间的主要区别是，WASM 规范和环境至少要简单一个数量级。因为 I 不像 JVM、CLR 和大多数脚本语言那样，在标准库中有成千上万的类和方法。这就是为什么它更容易实现，因此它已经有过多的运行时。</li><li id="ae27" class="kj kk in jm b jn ks jr kt jv ku jz kv kd kw kh ko kp kq kr bi translated">诚然，如果以原生 CPU 为目标，如 x86–32/64、arm 7–8、RISC-V 等，Rust 是一种纯粹超前的编译语言。但是铁锈能做的不止这些。</li><li id="fedf" class="kj kk in jm b jn ks jr kt jv ku jz kv kd kw kh ko kp kq kr bi translated">显然，你不能给某人一个. rb 文件，然后期望它被运行。这就像给某人一个. rs 文件。文件与。rb 和。rs 扩展是用高级语言编写，旨在使人可读，而不是由机器执行。</li><li id="f704" class="kj kk in jm b jn ks jr kt jv ku jz kv kd kw kh ko kp kq kr bi translated">提前编译只是意味着代码在执行前被编译(编译成某种东西，可能是 C)，但并不意味着编译的结果是本机代码。</li><li id="8d30" class="kj kk in jm b jn ks jr kt jv ku jz kv kd kw kh ko kp kq kr bi translated">首先生成 java 字节码，然后在 JVM 中执行它的 java 编译器是超前编译器。即使 Java 字节码需要运行 JVM。</li><li id="0968" class="kj kk in jm b jn ks jr kt jv ku jz kv kd kw kh ko kp kq kr bi translated">与提前相反的是及时编译。代码在执行的同时被编译(就像 python 一样)。</li><li id="f146" class="kj kk in jm b jn ks jr kt jv ku jz kv kd kw kh ko kp kq kr bi translated">这些概念可能很复杂，有时甚至没有明确的界限来区分它们😂。当我研究这个概念时，我记得我认为将源代码翻译成 AST 可以被认为是一种编译形式。因此，每一个不直接执行源代码的编译器在某种意义上都是超前编译器。</li><li id="fa23" class="kj kk in jm b jn ks jr kt jv ku jz kv kd kw kh ko kp kq kr bi translated">说 rust 是一种“超前”的编译语言有点多余和误导。</li><li id="6b08" class="kj kk in jm b jn ks jr kt jv ku jz kv kd kw kh ko kp kq kr bi translated">基本上有编译和解释或“即时”(正如你所想的)语言，还有一些处理编译的字节码，但仍然需要解释。在我看来，没有真正的“实时”语言，只有“实时”编译器，例如 LuaJIT，它采用传统的编译语言，例如 Lua，并有效地解释它。</li><li id="6ec2" class="kj kk in jm b jn ks jr kt jv ku jz kv kd kw kh ko kp kq kr bi translated">“超前”编译意味着它不同于常规编译，但实际上并不是。这是多余的和误导性的，因为你是在与一个特定的术语“实时编译”相区别，这个术语已经被设计来与它的基础和互斥的对应术语“编译”相区别</li><li id="807f" class="kj kk in jm b jn ks jr kt jv ku jz kv kd kw kh ko kp kq kr bi translated">同样值得注意的是，二进制文件只能运行在为其构建的发行版和架构中。基于 arm 的 raspberry pi 不会运行针对我的 x86_64 桌面构建的 rust 二进制文件。</li></ol></div></div>    
</body>
</html>