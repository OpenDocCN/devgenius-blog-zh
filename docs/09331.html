<html>
<head>
<title>Synchronize Goroutine execution.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">同步 Goroutine 执行。</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/synchronize-go-routine-execution-101eb88d10ac?source=collection_archive---------6-----------------------#2022-08-15">https://blog.devgenius.io/synchronize-go-routine-execution-101eb88d10ac?source=collection_archive---------6-----------------------#2022-08-15</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="da96" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">用条件变量控制执行。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/12278e0d938e82e68a21e49d36e8cdfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*D6NdtoCgC-3dcXZP"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">图片由 Jorge Salvador 通过 Unsplash 提供</figcaption></figure><p id="6062" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">“在编程的上下文中，并发性是指将程序分解成可以彼此独立运行的部分的能力。”我写的大部分并发操作，某种程度上都依赖于一个共享变量。例如，当我在为一个视频游戏编写服务器时，我使用了一个映射来将一个用户的 ID 与一个连接相关联。这引发了一些运行时问题。当 2 个 Goroutines 试图在地图上写/读数据时，程序会崩溃。为了解决这个问题，我在代码中引入了锁。我注意到的一件事是并发读取不会使程序崩溃。在本文中，我将尝试同时读写地图。这将通过条件变量来完成。我的计划是在写操作发生时，停止执行所有从 map 中读取的 Goroutines。一旦写操作完成，所有其他 Goroutines 将同时恢复执行。</p><h1 id="3a04" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">同步。锁柜</h1><p id="170e" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">为了初始化一个条件变量，我必须定义一个满足接口<code class="fe mm mn mo mp b">sync.Locker</code>的类型。该类型必须有方法<code class="fe mm mn mo mp b">Lock</code>和<code class="fe mm mn mo mp b">Unlock</code>。下面是我的类型的定义:</p><pre class="kd ke kf kg gt mq mp mr ms aw mt bi"><span id="a8c3" class="mu lq in mp b gy mv mw l mx my">type LockType struct {<br/> LockCount       *atomic.Int32<br/> CompleteChannel chan bool<br/>}</span></pre><p id="758d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我用附加字段定义了<code class="fe mm mn mo mp b">LockType</code>,以跟踪并发操作的当前状态。目标是使用渠道作为沟通完成的手段。下面是我实现的接口<code class="fe mm mn mo mp b">sync.Locker</code>:</p><pre class="kd ke kf kg gt mq mp mr ms aw mt bi"><span id="0280" class="mu lq in mp b gy mv mw l mx my">func (l LockType) Lock() {<br/> fmt.Println("Lock")<br/> l.LockCount.Add(-1)</span><span id="8d78" class="mu lq in mp b gy mz mw l mx my"> if l.LockCount.Load() == 0 {<br/>   l.CompleteChannel &lt;- true<br/> }<br/>}</span><span id="f829" class="mu lq in mp b gy mz mw l mx my">func (l LockType) Unlock() {<br/> fmt.Println("Unlock")<br/> l.LockCount.Add(1)<br/>}</span></pre><p id="6c3e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">每调用一次<code class="fe mm mn mo mp b">Unlock</code>，<code class="fe mm mn mo mp b">LockCount</code>加 1。方法<code class="fe mm mn mo mp b">Lock</code>将减少<code class="fe mm mn mo mp b">LockCount</code>，当<code class="fe mm mn mo mp b">LockCount</code>达到 0 时，向传递的通道发送消息。现在，实现。</p><h1 id="d23c" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">实施</h1><p id="0618" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">我将从实例化我的类型开始。以下是执行此操作的代码:</p><pre class="kd ke kf kg gt mq mp mr ms aw mt bi"><span id="d3fa" class="mu lq in mp b gy mv mw l mx my">func main(){<br/> <strong class="mp io">waitchan</strong> := make(chan bool)<br/> counter := atomic.Int32{}<br/> counter.Store(0)</span><span id="02b6" class="mu lq in mp b gy mz mw l mx my"> locker := LockType{<br/>   LockCount:       &amp;counter,<br/>   CompleteChannel: waitchan,<br/> }</span><span id="e380" class="mu lq in mp b gy mz mw l mx my">  &lt;- waitchan</span><span id="d421" class="mu lq in mp b gy mz mw l mx my">  fmt.Println("Done")<br/>}</span></pre><p id="8018" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我将使用<code class="fe mm mn mo mp b">waitchain</code>来阻止程序退出。接下来，我将调用<code class="fe mm mn mo mp b">sync.NewCond</code>，我将传递变量<code class="fe mm mn mo mp b">locker</code>。这将返回一个条件变量。我还将初始化我将在这篇文章中使用的地图。以下是执行这些操作的代码:</p><pre class="kd ke kf kg gt mq mp mr ms aw mt bi"><span id="4a7f" class="mu lq in mp b gy mv mw l mx my">m := make(map[string]int)<br/>c := sync.NewCond(locker)</span></pre><h1 id="a65c" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">使用案例</h1><p id="c6a2" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">假设我有 4 个 Goroutines 需要并行执行。一个 Goroutine 负责用数据填充地图，其余 3 个将执行需要地图数据的操作。<code class="fe mm mn mo mp b">c</code>在下面的代码块中引用上面定义的条件变量。下面是负责用数据填充地图的 Goroutine 的代码:</p><pre class="kd ke kf kg gt mq mp mr ms aw mt bi"><span id="dead" class="mu lq in mp b gy mv mw l mx my">go func() {</span><span id="5245" class="mu lq in mp b gy mz mw l mx my">  fmt.Println("First")<br/>  m["foo"] = 100<br/>  time.Sleep(10 * time.Second)<br/>  c.<strong class="mp io">Broadcast</strong>()<br/>}()</span></pre><p id="82cc" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">方法<code class="fe mm mn mo mp b">BroadCast</code>将唤醒所有等待信号的 Goroutines。Goroutines 将通过调用<code class="fe mm mn mo mp b">c.Wait()</code>等待信号。以下是其他 3 个 Goroutines 的代码:</p><pre class="kd ke kf kg gt mq mp mr ms aw mt bi"><span id="87b7" class="mu lq in mp b gy mv mw l mx my">go func() {</span><span id="831d" class="mu lq in mp b gy mz mw l mx my">  c.Wait()<br/>  fmt.Println("Second", m["foo"])<br/>  <br/> }()</span><span id="276f" class="mu lq in mp b gy mz mw l mx my">go func() {</span><span id="fa33" class="mu lq in mp b gy mz mw l mx my">  c.Wait()<br/>  fmt.Println("third", m["foo"])</span><span id="29b6" class="mu lq in mp b gy mz mw l mx my">}()</span><span id="f3f8" class="mu lq in mp b gy mz mw l mx my">go func() {</span><span id="6e3c" class="mu lq in mp b gy mz mw l mx my">  c.Wait()<br/>  fmt.Println("fourth", m["foo"])</span><span id="62f7" class="mu lq in mp b gy mz mw l mx my">}()</span></pre><p id="8a14" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">下面是实际运行的代码:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi na"><img src="../Images/6af7fd6f22c7517c1736e79859c6a801.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*R1OJcYQ3POUt1-DD.gif"/></div></figure><p id="d2b0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如您所见，在第一个 Goroutine 完成之后，3 个 go routine 同时登录到控制台。</p><h1 id="6774" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">结论</h1><p id="f47b" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">条件变量是在不牺牲实际并发性的情况下控制资源访问的好方法。使用上面定义的用例，我通知其他 Goroutines 数据准备好了。我尝试用类型<code class="fe mm mn mo mp b">sync.Mutex</code>这样做，这导致每个 Goroutine 一次执行一个。这就是我写“牺牲实际并发性”时所指的。根据 Go 文档，条件变量是“等待或宣布事件发生的 goroutines 的集合点。”在上面给出的例子中，在地图数据被填充之后，一个事件被宣布。这将确保在存储数据时不会读取地图，因为这会导致运行时错误。你可以在下面找到这篇文章中使用的代码的链接。</p><h1 id="f1af" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">来源</h1><div class="nb nc gp gr nd ne"><a href="https://www.techopedia.com/definition/25146/programming-concurrency" rel="noopener  ugc nofollow" target="_blank"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd io gy z fp nj fr fs nk fu fw im bi translated">什么是编程并发？-来自 Techopedia 的定义</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">并发性——在编程的上下文中——是将程序分解成可以运行的部分的能力…</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">www.techopedia.com</p></div></div><div class="nn l"><div class="no l np nq nr nn ns km ne"/></div></div></a></div><div class="nb nc gp gr nd ne"><a href="https://github.com/cheikhshift/medium_examples/tree/main/goroutine" rel="noopener  ugc nofollow" target="_blank"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd io gy z fp nj fr fs nk fu fw im bi translated">medium _ examples/go routine at main cheikh shift/medium _ examples</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">中型文章的代码示例。在 GitHub 上创建一个帐户，为 cheikhshift/medium_examples 开发做贡献。</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">github.com</p></div></div><div class="nn l"><div class="nt l np nq nr nn ns km ne"/></div></div></a></div><div class="nb nc gp gr nd ne"><a href="https://pkg.go.dev/sync#Cond" rel="noopener  ugc nofollow" target="_blank"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd io gy z fp nj fr fs nk fu fw im bi translated">同步</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">包同步提供了基本的同步原语，如互斥锁。除了曾经和…</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">pkg.go.dev</p></div></div></div></a></div></div></div>    
</body>
</html>