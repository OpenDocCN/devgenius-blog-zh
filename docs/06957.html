<html>
<head>
<title>Does GitFlow fit in an Agile team?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GitFlow 适合敏捷团队吗？</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/does-gitflow-fit-in-an-agile-team-b3cb85fbdbc6?source=collection_archive---------12-----------------------#2022-02-14">https://blog.devgenius.io/does-gitflow-fit-in-an-agile-team-b3cb85fbdbc6?source=collection_archive---------12-----------------------#2022-02-14</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/069602116629b6980ba67fd699797653.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ULwj-RSjnDgt_lO_CgcSVA.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">图片来自穆罕默德·哈桑:“<a class="ae jz" href="https://pxhere.com/en/photo/1444193" rel="noopener ugc nofollow" target="_blank">https://pxhere.com/en/photo/1444193</a></figcaption></figure><p id="72e6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">无论你是在 CS 入门课程中构建一个团队项目，还是在一个经验丰富的 DevOps 团队中工作，建立有效的方法来合并不同的代码库并推出项目/功能是最重要的；简单来说，所有的软件开发者都需要某种<em class="ky">版本控制系统</em>和协同<em class="ky">工作流</em>。在 DevOps 世界里，你经常听到的两个短语是<em class="ky"> GitFlow </em>合并策略<em class="ky"> </em>和<em class="ky">敏捷</em>工作流。两者都承诺保持开发团队的适应性、通用性和长期可持续性。难怪您会经常看到这两者同时实现。然而，对这种模式的批评近年来越来越多，而且理由充分。所以我们问这个问题，“【GitFlow 真的适合敏捷团队吗？”。</p><h2 id="23bd" class="kz la in bd lb lc ld dn le lf lg dp lh kl li lj lk kp ll lm ln kt lo lp lq lr bi translated">敏捷工作流概述</h2><p id="5a41" class="pw-post-body-paragraph ka kb in kc b kd ls kf kg kh lt kj kk kl lu kn ko kp lv kr ks kt lw kv kw kx ig bi translated">总之，敏捷提倡<em class="ky">增量</em>和<em class="ky">迭代</em>开发。传统的项目生命周期是在最后一个阶段完成后才经历每个阶段(<em class="ky">设计/实现/测试/部署</em>),与之不同的是，敏捷提倡团队将项目分成更小的“片段”或任务，并经历每个片段的整个生命周期，不断推出功能，而不是一次性完成。</p><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lx"><img src="../Images/c942f79b1bf4287cc4c6dc7efc27f9cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mMgpqzuas0W23aO1xTcATg.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">图 1:敏捷项目生命周期与传统项目生命周期的对比"<a class="ae jz" href="https://www.trustradius.com/buyer-blog/difference-between-agile-vs-waterfall" rel="noopener ugc nofollow" target="_blank">https://www . trust radius . com/buyer-blog/difference-between-Agile-vs-fault</a>"</figcaption></figure><h2 id="65c1" class="kz la in bd lb lc ld dn le lf lg dp lh kl li lj lk kp ll lm ln kt lo lp lq lr bi translated">GitFlow 简评</h2><p id="2b17" class="pw-post-body-paragraph ka kb in kc b kd ls kf kg kh lt kj kk kl lu kn ko kp lv kr ks kt lw kv kw kx ig bi translated">在一个项目中处理不同特性的开发人员需要一种方法来将所有这些不同的源代码组合成一个代码库。此外，合并一个代码库不应该干扰其他部分(开发人员协作的恐怖故事永远不会停止！).GitFlow，正如它的创建者 Vincent Driessen 所描述的，是一个“分散但集中”的存储库设置。</p><p id="e6c6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">每个存储库至少有两个版本:在“主分支”上的版本和在“开发分支”上的版本。开发人员从不直接在主分支之外工作。此外，通过将开发分支上的代码版本复制到实际设计/实现源代码的新“功能分支”来创建新功能。一旦特性被测试和批准，所有反映在开发分支上的变更可以替换主分支并被部署。</p><p id="dfdc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这种直观的策略允许开发团队<strong class="kc io"> 1。</strong>跟踪项目时间表中的所有变更，<strong class="kc io"> 2。</strong>轻松回滚到先前版本代码库的更改，以及<strong class="kc io"> 3 .</strong>一次同时处理不同的功能。</p><p id="7fcd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ky">*如果您有兴趣了解更多关于 GitFlow 的信息，请查看 Vincent Driessen 的原创</em> <a class="ae jz" href="https://jhall.io/archive/2021/03/09/gitflow-is-anti-agile/" rel="noopener ugc nofollow" target="_blank"> <em class="ky">博客文章</em> </a> <em class="ky">解释 GitFlow 分支和合并策略** </em></p><h2 id="717e" class="kz la in bd lb lc ld dn le lf lg dp lh kl li lj lk kp ll lm ln kt lo lp lq lr bi translated">评论已经出来了，但还没有达成一致…</h2><p id="3574" class="pw-post-body-paragraph ka kb in kc b kd ls kf kg kh lt kj kk kl lu kn ko kp lv kr ks kt lw kv kw kx ig bi translated">在敏捷团队中使用 GitFlow 的问题与任何一个单独的策略都没有什么关系。两者的原理都相对简单，并且易于集成到现有的 DevOps 团队中。一些有声望的公司，像<a class="ae jz" href="https://www.atlassian.com/agile/software-development/git" rel="noopener ugc nofollow" target="_blank"> Atlassian </a>，发誓在他们的敏捷团队中使用 GitFlow。但这远不是一个行业标准。主要的问题是，GitFlow 在高层逻辑上与敏捷的轻量级和迭代过程相矛盾。</p><p id="9e65" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">看看 GitFlow 原型模型:</p><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mc"><img src="../Images/f309456419f0181d02393805b9c132b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*xHSSm8QVyWCKbNHa.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">图 2:文森特·德里森"<a class="ae jz" href="https://nvie.com/posts/a-successful-git-branching-model/" rel="noopener ugc nofollow" target="_blank">https://nvie.com/posts/a-successful-git-branching-model</a>/"</figcaption></figure><p id="8e60" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">乍一看，它是如何工作的并不十分明显，是吗？</p><h2 id="abd1" class="kz la in bd lb lc ld dn le lf lg dp lh kl li lj lk kp ll lm ln kt lo lp lq lr bi translated">GitFlow 令人困惑</h2><p id="760b" class="pw-post-body-paragraph ka kb in kc b kd ls kf kg kh lt kj kk kl lu kn ko kp lv kr ks kt lw kv kw kx ig bi translated">不清楚实施或部署的点在哪里。更不用说，你甚至可能花了一段时间才找到开发分支在哪里(它是黄色的分支)。随着特性和分支的增加，GitFlow 变得越来越复杂和混乱。古语有云:“亲<strong class="kc io">亲</strong>:<strong class="kc io">K</strong>eep<strong class="kc io">I</strong>t<strong class="kc io">S</strong>imple，<strong class="kc io"> S </strong> tupid”。随着应用程序变得更加复杂，DevOps 团队变得更加远程和自主，以及像<a class="ae jz" href="https://microservices.io/" rel="noopener ugc nofollow" target="_blank">微服务</a>这样的设计更加流行，GitFlow 的价值迅速下降。这很容易出错，而且很难看出敏捷方法适合在哪里。</p><h2 id="dff8" class="kz la in bd lb lc ld dn le lf lg dp lh kl li lj lk kp ll lm ln kt lo lp lq lr bi translated">GitFlow 对敏捷来说是矛盾的</h2><p id="467c" class="pw-post-body-paragraph ka kb in kc b kd ls kf kg kh lt kj kk kl lu kn ko kp lv kr ks kt lw kv kw kx ig bi translated">对于敏捷方法来说，团队的工作流程必须是增量的和迭代的。然而，GitFlow 违背了这些基本原则。如果您在* <em class="ky">图 2* </em>中跟踪 GitFlow 模型中的开发分支，您将会看到一个新的特性分支被添加到项目周期的开始。然后，在开发部门(所有的<strong class="kc io">开发人员都在这里工作)实施之前，它会经过一个完整的设计阶段，这样测试和错误修复就可以开始了。被批准的特性最终被部署并与主分支合并。</strong></p><p id="4cb9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">尽管这个过程听起来非常类似于敏捷，但它实际上是项目管理的瀑布方法<em class="ky">*参见图 1*。如果开发人员不断被鼓励去“完成”一个特性，保持持续的部署是非常困难的；合并这一特性意味着将开发分支上的所有变更手动推送到主分支进行部署。这种过程没有任何增量。</em></p><h2 id="810f" class="kz la in bd lb lc ld dn le lf lg dp lh kl li lj lk kp ll lm ln kt lo lp lq lr bi translated">如果 GitFlow 出来了，那里面是什么？</h2><p id="2a83" class="pw-post-body-paragraph ka kb in kc b kd ls kf kg kh lt kj kk kl lu kn ko kp lv kr ks kt lw kv kw kx ig bi translated">完全忽视 GitFlow 可能为时过早。正如本博客开头所述，一些公司发现这种类型的设置很有价值。然而，如果您的敏捷团队正在使用 GitFlow，并且之前的担忧引起了您的共鸣，那么下面是一些行业专业人士正在转向的替代方案:</p><p id="7e1d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">特征分支</strong></p><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div class="gh gi md"><img src="../Images/10febfa1754a3ae3da5256185fa2e197.png" data-original-src="https://miro.medium.com/v2/resize:fit:764/0*TFDBOgyL1U-BxnSD"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">图 3:“<a class="ae jz" href="https://docs.microsoft.com/en-us/azure/devops/repos/git/git-branching-guidance?view=azure-devops" rel="noopener ugc nofollow" target="_blank">https://docs . Microsoft . com/en-us/azure/devo PS/repos/git/git-branching-guidance？view=azure-devops </a></figcaption></figure><p id="5c14" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个策略将分支流程简化为两个分支:一个主流程和一个功能流程。在销毁分支并开始下一个功能之前，会创建、完成和部署一个功能。它坚持保持分支<em class="ky">短暂并且相互隔离</em>的原则(避免过程中的合并冲突)。</p><p id="42a1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这种策略的缺点是，在主分支被合并之前，您永远无法确定您的特性代码是否仍然与主分支兼容。它还需要开发人员之间更好的协调和依赖，以避免合并冲突，并决定以什么顺序实现哪些功能。</p><p id="4da8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">基于主干的开发</strong></p><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi me"><img src="../Images/b6c54960e3b5492606b65e9f4140955c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cZ7wphKdc8tyPsM3"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">图 4:"<a class="ae jz" href="https://launchdarkly.com/blog/introduction-to-trunk-based-development/" rel="noopener ugc nofollow" target="_blank">https://launch darky . com/blog/introduction-to-trunk-based-development/</a>"</figcaption></figure><p id="0c9e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对于经验丰富的 DevOps 团队来说，这种策略包括直接在主分支上进行变更，并在整个项目生命周期中不断地将小的变更或特性标志推送到主分支。在使用短命分支方面，它甚至比特性分支更好。此外，开发人员有更多的自由将不完整的特性合并到代码库中，满足了增量敏捷原则。</p><p id="37e7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">直接在主分支之外工作本身就有风险，所以初级开发人员可能不应该尝试基于主干的策略。不仅暴露了项目的生命线，而且很难配置一个在部署后对最终用户隐藏不完整特性的过程。开发人员也需要经验和更强的意识来组织特性标志，并在它们开始构建之前解决它们。</p><h2 id="3004" class="kz la in bd lb lc ld dn le lf lg dp lh kl li lj lk kp ll lm ln kt lo lp lq lr bi translated">有没有对每个人都有效的灵丹妙药？</h2><p id="1f11" class="pw-post-body-paragraph ka kb in kc b kd ls kf kg kh lt kj kk kl lu kn ko kp lv kr ks kt lw kv kw kx ig bi translated">不幸的是，没有“最佳分支策略”。无论您的团队实施什么策略，都高度依赖于您的特定需求。如果您正在选择要实施的策略，请记住以下问题:</p><ol class=""><li id="9fdf" class="mf mg in kc b kd ke kh ki kl mh kp mi kt mj kx mk ml mm mn bi translated">这种分支策略会解决什么问题？</li><li id="647b" class="mf mg in kc b kd mo kh mp kl mq kp mr kt ms kx mk ml mm mn bi translated">会产生什么问题？</li><li id="a288" class="mf mg in kc b kd mo kh mp kl mq kp mr kt ms kx mk ml mm mn bi translated">你的团队喜欢如何发布代码？<em class="ky">一天多次？一个月一次？准备好了吗？</em></li><li id="c3fd" class="mf mg in kc b kd mo kh mp kl mq kp mr kt ms kx mk ml mm mn bi translated">合并这个策略将如何改变你的团队的开发行为？</li></ol></div></div>    
</body>
</html>