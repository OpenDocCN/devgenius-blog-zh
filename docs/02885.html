<html>
<head>
<title>The Two Parts of Solving an Algorithm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">求解算法的两个部分</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/the-two-parts-of-solving-an-algorithm-ef95d3a9b811?source=collection_archive---------4-----------------------#2020-09-08">https://blog.devgenius.io/the-two-parts-of-solving-an-algorithm-ef95d3a9b811?source=collection_archive---------4-----------------------#2020-09-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/5f563923c3850f2704dd8e7c980fbcbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GTxgG3yznFGqyLeY"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">沃洛季米尔·赫里先科在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="0bf3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我记得在考虑软件开发时的一个影响是，我姐姐告诉我我会很擅长，因为我是一个“真正优秀的问题解决者”。我们喜欢玩脑筋急转弯和记忆相关的游戏，如Jackbox Games的“炸弹公司”。每当我在游戏中用我的记忆回忆或对复杂规则的理解给她留下深刻印象时，她都会坚持认为我可以很好地学习编程。根据她的经验，软件开发是“所有问题的解决”。现在，我是一名全栈web开发人员，并在leetcode上练习算法，我可以理解并欣赏她的想法。为了解决编码挑战，你必须使用两种基本技能。第一项技能是解决问题，比如理解问题的技术限制以及如何找到解决方案。第二是能够将这种理解转化为有效的、可执行的代码。</p><p id="b9b6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我的第一个模拟技术挑战涉及一个算法，它真正突出了编码的脑筋急转弯“解决问题”技能。内容如下:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="c23b" class="lk ll iq lg b gy lm ln l lo lp">Given any alphabetic string, determine if it is an anagram of a palindrome.</span></pre><p id="ce2c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">看到这个的那一刻，我觉得这是个很好玩的问题。澄清一下，变位词是一串按照新的顺序排列的字符，没有删除或添加任何额外的字符。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="5dc1" class="lk ll iq lg b gy lm ln l lo lp">An anagram of "cat" is "tac"</span></pre><p id="7022" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">回文是向前或向后阅读时顺序相同的一串字符。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="cb26" class="lk ll iq lg b gy lm ln l lo lp">An example of a palindrome is "racecar". It is spelt the same forwards and backwards.</span></pre><p id="c8ed" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我练习过询问两个字符串是否是变位词的问题，我的解决方案包括制作一个散列图，并确保每个字符在每个字符串中出现的次数相同。我还练习过一个问题，问一个字符串是否是变位词，我的解决方案涉及在字符串的两端使用指针，确保当它们移向中间时，每个字符都匹配，如果有奇数个字符，中间的可能是唯一的。这个问题增加了挑战的难度。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="880a" class="lk ll iq lg b gy lm ln l lo lp">"obb" is an anagram of a palindrome, because "bob" is an anagram of "obb" and "bob" is a palindrome.</span></pre><p id="8399" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们都在同一页上。能够流利地用任何语言编写代码都是无用的技能，除非你能理解如何解决问题。所以，不考虑软件或代码，你怎么知道任何字符串可能是回文的变位词呢？您可以将字符串重新排列成每一种可能的组合，看看它们前后读起来是否相同，但是如果字符串包含的字符多于几个，那就要花很长时间了。我们需要更实际地思考。</p><p id="e3f0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当你看下面的字符串时，你能多快看出它不是一个回文？</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="cea1" class="lk ll iq lg b gy lm ln l lo lp">"that"</span></pre><p id="6064" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可以很快看出‘that’不是一个回文，因为它的前后读起来不一样，因为只有一个“a”和一个“h”。你也可以看出“that”不可能是回文的变位词，因为不管怎样，在一个方向上“a”总是在“h”之前，而在另一个方向上“h”总是在“a”之前。</p><p id="ba8c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们批判性地思考，我们可以推断出一些回文的规则。为了使一个字符串向前和向后读起来一样，字符串一边的每个字符需要在另一边出现相同的次数。这意味着每个字符需要出现偶数次。有一个例外，如果回文的长度为奇数，那么可以有一个字符出现奇数次，并且位于回文的中间(就像“racecar”中的“e”)。</p><p id="aaab" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有了对我们问题中规则的理解，我们就能设计出一个解决方案。我们可以计算给定字符串中每个字符的出现次数，如果不止一个字符出现奇数次，我们知道该字符串不可能是回文的变位词。</p><p id="3965" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">既然我们已经完成了算法的“解决问题”部分，是时候使用我们的编码技能来翻译我们的解决方案了。当我得到这个提示时，下面的代码是我提交的解决方案。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="d4d3" class="lk ll iq lg b gy lm ln l lo lp">function isAnagramOfPalindrome(string){<br/>   let numOfChar = {}<br/>   for(let char of string){<br/>      numOfChar[char] ? numOfChar[char]++ : numOfChar[char] = 1<br/>   }<br/>   let containsLessThanOneOdd<br/>   for(let key in numOfChar){<br/>      if(numOfChar[key] % 2 === 1){<br/>        if(!containsLessThanOneOdd) containsLessThanOneOdd = true<br/>        else return false<br/>      }<br/>   }<br/>   return true<br/>}</span></pre><p id="5b68" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我写的解决方案中，我创建一个hash，遍历字符串，将字符串中的每个字符设置为hash中的一个键，并将它的值设置为1。如果这个字符再次出现，我就增加这个值。一旦我完成了这个任务，我就初始化一个变量。然后，我遍历我的散列，并在第一次遇到一个奇数值时将该变量赋为“true”。如果我遇到第二个奇数值，我返回false并结束这个过程。否则，我完成迭代并返回true。</p><p id="6c0b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我不能说这是最好的解决方案，但这是我想到的一个，而且很有效。我很自豪我有能力隔离问题中的一个条件，并利用它来开发一个可行的解决方案。我能真正理解为什么我姐姐如此坚定地认为批判性思维、记忆和解决问题的技能可以标志一个人很好地适应编程的能力。你需要这些技能来将问题分解到核心并设计出最佳的解决方案。如果你喜欢脑筋急转弯和谜题，那么一旦你学会了编码，你很可能会喜欢解算法。我希望这篇文章对如何应对编码挑战有深刻的见解。感谢阅读！</p></div></div>    
</body>
</html>