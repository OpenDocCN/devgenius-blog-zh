<html>
<head>
<title>Open Closed Principle | SOLID as a Rock</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">开闭原理|坚如磐石</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/open-closed-principle-solid-as-a-rock-aba6465ad9de?source=collection_archive---------1-----------------------#2020-05-11">https://blog.devgenius.io/open-closed-principle-solid-as-a-rock-aba6465ad9de?source=collection_archive---------1-----------------------#2020-05-11</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div class="gh gi jk"><img src="../Images/b2fff35b671417182eaf0b5092c6437c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*21onB5UocX8S7iW53ppXuA.png"/></div></figure><p id="dfec" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">这是关于固体如岩石设计原则的五部分系列的第二部分。坚实的设计原则，当结合在一起时，使程序员能够轻松地编写易于维护、重用和扩展的软件。<strong class="jt io">O</strong>pen-<strong class="jt io">C</strong>losed<strong class="jt io">P</strong>principle(OCP)是这个系列的第二个原则，我将在这里用<a class="ae kp" href="http://www.vishalchovatiya.com/21-new-features-of-modern-cpp-to-use-in-your-project/" rel="noopener ugc nofollow" target="_blank"> Modern C++ </a>中的一个极小的例子来讨论它，以及它的好处&amp;通用指南。</p><blockquote class="kq kr ks"><p id="ba3b" class="jr js kt jt b ju jv jw jx jy jz ka kb ku kd ke kf kv kh ki kj kw kl km kn ko ig bi translated"><em class="in"> /！\:原载@</em><a class="ae kp" href="http://www.vishalchovatiya.com/category/design-patterns/" rel="noopener ugc nofollow" target="_blank"><em class="in">www.vishalchovatiya.com</em></a><em class="in">。</em></p></blockquote><p id="f4c6" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">顺便说一句，如果你还没有浏览过我以前关于设计原则的文章，下面是快速链接:</p><ol class=""><li id="8e93" class="kx ky in jt b ju jv jy jz kc kz kg la kk lb ko lc ld le lf bi translated"><a class="ae kp" href="http://www.vishalchovatiya.com/single-responsibility-principle-in-cpp-solid-as-a-rock/" rel="noopener ugc nofollow" target="_blank"> <strong class="jt io"> S </strong> RP —单一责任原则</a></li><li id="dfd1" class="kx ky in jt b ju lg jy lh kc li kg lj kk lk ko lc ld le lf bi translated"><a class="ae kp" href="http://www.vishalchovatiya.com/open-closed-principle-in-cpp-solid-as-a-rock/" rel="noopener ugc nofollow" target="_blank"> <strong class="jt io"> O </strong> CP —开启/关闭原理</a></li><li id="b784" class="kx ky in jt b ju lg jy lh kc li kg lj kk lk ko lc ld le lf bi translated"><a class="ae kp" href="http://www.vishalchovatiya.com/liskovs-substitution-principle-in-cpp-solid-as-a-rock/" rel="noopener ugc nofollow" target="_blank">T25】LSP—利斯科夫替代原理</a></li><li id="ed1d" class="kx ky in jt b ju lg jy lh kc li kg lj kk lk ko lc ld le lf bi translated"><a class="ae kp" href="http://www.vishalchovatiya.com/interface-segregation-principle-in-cpp-solid-as-a-rock/" rel="noopener ugc nofollow" target="_blank"> <strong class="jt io"> I </strong> SP —界面偏析原理</a></li><li id="3729" class="kx ky in jt b ju lg jy lh kc li kg lj kk lk ko lc ld le lf bi translated"><a class="ae kp" href="http://www.vishalchovatiya.com/dependency-inversion-principle-in-cpp-solid-as-a-rock/" rel="noopener ugc nofollow" target="_blank"> <strong class="jt io"> D </strong> IP —依赖反转原理</a></li></ol><p id="0659" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">您在这一系列文章中看到的代码片段是简化的，而不是复杂的。所以你经常看到我不使用像<code class="fe ll lm ln lo b">override</code>、<code class="fe ll lm ln lo b">final</code>、<code class="fe ll lm ln lo b">public</code>(同时继承)这样的关键字，只是为了让代码紧凑&amp;可消耗(大部分时间)在单一标准屏幕尺寸。我也更喜欢<code class="fe ll lm ln lo b">struct</code>而不是<code class="fe ll lm ln lo b">class</code>，只是为了节省代码行，有时不写<code class="fe ll lm ln lo b">public:</code>，还会故意忽略<a class="ae kp" href="http://www.vishalchovatiya.com/part-3-all-about-virtual-keyword-in-c-how-virtual-destructor-works/" rel="noopener ugc nofollow" target="_blank">虚拟析构函数</a>，构造函数<a class="ae kp" href="http://www.vishalchovatiya.com/all-about-copy-constructor-in-cpp-with-example/" rel="noopener ugc nofollow" target="_blank">，复制构造函数</a>，前缀<code class="fe ll lm ln lo b">std::</code>，删除动态内存。我也认为自己是一个务实的人，希望用尽可能简单的方式，而不是标准的方式或使用术语来传达一个想法。</p><p id="3e80" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io"> <em class="kt">注:</em> </strong></p><ul class=""><li id="9186" class="kx ky in jt b ju jv jy jz kc kz kg la kk lb ko lp ld le lf bi translated">如果你是在这里被直接绊倒的，那么我建议你浏览一下<a class="ae kp" href="http://www.vishalchovatiya.com/what-is-design-pattern/" rel="noopener ugc nofollow" target="_blank">什么是设计模式？</a>一、哪怕是鸡毛蒜皮的小事。相信会鼓励你对这个话题进行更多的探索。</li><li id="c66f" class="kx ky in jt b ju lg jy lh kc li kg lj kk lk ko lp ld le lf bi translated">您在本系列文章中遇到的所有这些代码都是使用 C++20 编译的(尽管我在大多数情况下使用了 C++17 之前的现代 C++特性)。因此，如果你无法获得最新的编译器，你可以使用已经预装了 boost 库的<a class="ae kp" href="https://wandbox.org/" rel="noopener ugc nofollow" target="_blank">https://wandbox.org/</a>。</li></ul><h1 id="f816" class="lq lr in bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">目的</h1><blockquote class="kq kr ks"><p id="67a9" class="jr js kt jt b ju jv jw jx jy jz ka kb ku kd ke kf kv kh ki kj kw kl km kn ko ig bi translated"><em class="in">类应该对扩展开放，对修改关闭</em></p></blockquote><ul class=""><li id="a604" class="kx ky in jt b ju jv jy jz kc kz kg la kk lb ko lp ld le lf bi translated">这实际上意味着你应该能够扩展一个类的行为，而不用修改它。这可能对你来说很奇怪&amp;可能会提出一个问题，你如何在不修改类的情况下改变它的行为？</li><li id="577e" class="kx ky in jt b ju lg jy lh kc li kg lj kk lk ko lp ld le lf bi translated">但是这个在<a class="ae kp" href="http://www.vishalchovatiya.com/memory-layout-of-cpp-object/" rel="noopener ugc nofollow" target="_blank">面向对象设计</a>里面有很多答案像<a class="ae kp" href="http://www.vishalchovatiya.com/part-1-all-about-virtual-keyword-in-cpp-how-virtual-function-works-internally/" rel="noopener ugc nofollow" target="_blank">动态多态</a>、<a class="ae kp" href="http://www.vishalchovatiya.com/7-advanced-cpp-concepts-idiom-examples-you-should-know/#CRTP" rel="noopener ugc nofollow" target="_blank">静态多态</a>、模板等。</li></ul><h1 id="e958" class="lq lr in bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">违反了开闭原则</h1><pre class="mo mp mq mr gt ms lo mt mu aw mv bi"><span id="7152" class="mw lr in lo b gy mx my l mz na">enum class COLOR { RED, GREEN, BLUE };<br/>enum class SIZE { SMALL, MEDIUM, LARGE };</span><span id="cf50" class="mw lr in lo b gy nb my l mz na">struct Product {<br/>    string  m_name;<br/>    COLOR   m_color;<br/>    SIZE    m_size;<br/>};</span><span id="69b7" class="mw lr in lo b gy nb my l mz na">using Items = vector&lt;Product*&gt;;</span><span id="3bf0" class="mw lr in lo b gy nb my l mz na">#define ALL(C)  begin(C), end(C)</span><span id="bd5d" class="mw lr in lo b gy nb my l mz na">struct ProductFilter {<br/>    static Items by_color(Items items, const COLOR e_color) {<br/>        Items result;<br/>        for (auto &amp;i : items)<br/>            if (i-&gt;m_color == e_color)<br/>                result.push_back(i);<br/>        return result;<br/>    }<br/>    static Items by_size(Items items, const SIZE e_size) {<br/>        Items result;<br/>        for (auto &amp;i : items)<br/>            if (i-&gt;m_size == e_size)<br/>                result.push_back(i);<br/>        return result;<br/>    }<br/>    static Items by_size_and_color(Items items, const SIZE e_size, const COLOR e_color) {<br/>        Items result;<br/>        for (auto &amp;i : items)<br/>            if (i-&gt;m_size == e_size &amp;&amp; i-&gt;m_color == e_color)<br/>                result.push_back(i);<br/>        return result;<br/>    }<br/>};</span><span id="6e52" class="mw lr in lo b gy nb my l mz na">int main() {<br/>    const Items all{<br/>        new Product{"Apple", COLOR::GREEN, SIZE::SMALL},<br/>        new Product{"Tree", COLOR::GREEN, SIZE::LARGE},<br/>        new Product{"House", COLOR::BLUE, SIZE::LARGE},<br/>    };<br/>    for (auto &amp;p : ProductFilter::by_color(all, COLOR::GREEN))<br/>        cout &lt;&lt; p-&gt;m_name &lt;&lt; " is green\n";<br/>    for (auto &amp;p : ProductFilter::by_size_and_color(all, SIZE::LARGE, COLOR::GREEN))<br/>        cout &lt;&lt; p-&gt;m_name &lt;&lt; " is green &amp; large\n";<br/>    return EXIT_SUCCESS;<br/>}</span><span id="3141" class="mw lr in lo b gy nb my l mz na">/*<br/>Apple is green<br/>Tree is green<br/>Tree is green &amp; large<br/>*/</span></pre><ul class=""><li id="c909" class="kx ky in jt b ju jv jy jz kc kz kg la kk lb ko lp ld le lf bi translated">所以我们有一堆产品&amp;我们根据它的一些属性过滤了它。只要需求是固定的，上面的代码就没有任何问题(在软件工程中永远不会出现这种情况)。</li><li id="736e" class="kx ky in jt b ju lg jy lh kc li kg lj kk lk ko lp ld le lf bi translated">但是想象一下这种情况:您已经将代码发送给了客户。后来，需求发生了变化&amp;需要一些新的过滤器。在这种情况下，您再次需要修改类并添加新的过滤方法。</li><li id="1eb8" class="kx ky in jt b ju lg jy lh kc li kg lj kk lk ko lp ld le lf bi translated">这是一个有问题的方法，因为我们有 2 个属性(即颜色和大小)&amp;需要实现 3 个功能(即颜色、大小及其组合)，还有一个属性&amp;需要实现 8 个功能。你知道这是怎么回事了。</li><li id="f577" class="kx ky in jt b ju lg jy lh kc li kg lj kk lk ko lp ld le lf bi translated">你需要一遍又一遍地修改已实现的代码，这可能会破坏代码的其他部分。这不是一个可扩展的解决方案。</li><li id="170d" class="kx ky in jt b ju lg jy lh kc li kg lj kk lk ko lp ld le lf bi translated">开闭原则表明，您的系统应该对扩展开放，但对修改应该关闭。不幸的是，我们在这里所做的是修改现有的代码，这违反了 OCP。</li></ul><h1 id="53fe" class="lq lr in bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">开闭原理示例</h1><p id="e6c1" class="pw-post-body-paragraph jr js in jt b ju nc jw jx jy nd ka kb kc ne ke kf kg nf ki kj kk ng km kn ko ig bi translated">实现 OCP 的方法不止一种。在这里，我展示了流行的一个，即界面设计或抽象层次。这是我们的可扩展解决方案:</p><h1 id="5e51" class="lq lr in bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">增加可扩展性的抽象层次</h1><pre class="mo mp mq mr gt ms lo mt mu aw mv bi"><span id="b273" class="mw lr in lo b gy mx my l mz na">template &lt;typename T&gt;<br/>struct Specification {<br/>    virtual ~Specification() = default;<br/>    virtual bool is_satisfied(T *item) const = 0;<br/>};</span><span id="e43c" class="mw lr in lo b gy nb my l mz na">struct ColorSpecification : Specification&lt;Product&gt; {<br/>    COLOR e_color;<br/>    ColorSpecification(COLOR e_color) : e_color(e_color) {}<br/>    bool is_satisfied(Product *item) const { return item-&gt;m_color == e_color; }<br/>};</span><span id="63a7" class="mw lr in lo b gy nb my l mz na">struct SizeSpecification : Specification&lt;Product&gt; {<br/>    SIZE e_size;<br/>    SizeSpecification(SIZE e_size) : e_size(e_size) {}<br/>    bool is_satisfied(Product *item) const { return item-&gt;m_size == e_size; }<br/>};</span><span id="7363" class="mw lr in lo b gy nb my l mz na">template &lt;typename T&gt;<br/>struct Filter {<br/>    virtual vector&lt;T *&gt; filter(vector&lt;T *&gt; items, const Specification&lt;T&gt; &amp;spec) = 0;<br/>};</span><span id="7aa9" class="mw lr in lo b gy nb my l mz na">struct BetterFilter : Filter&lt;Product&gt; {<br/>    vector&lt;Product *&gt; filter(vector&lt;Product *&gt; items, const Specification&lt;Product&gt; &amp;spec) {<br/>        vector&lt;Product *&gt; result;<br/>        for (auto &amp;p : items)<br/>            if (spec.is_satisfied(p))<br/>                result.push_back(p);<br/>        return result;<br/>    }<br/>};</span><span id="2014" class="mw lr in lo b gy nb my l mz na">// ------------------------------------------------------------------------------------------------<br/>BetterFilter bf;<br/>for (auto &amp;x : bf.filter(all, ColorSpecification(COLOR::GREEN)))<br/>    cout &lt;&lt; x-&gt;m_name &lt;&lt; " is green\n";</span></pre><ul class=""><li id="46dc" class="kx ky in jt b ju jv jy jz kc kz kg la kk lb ko lp ld le lf bi translated">如你所见，我们不必修改<code class="fe ll lm ln lo b">BetterFilter</code>的<code class="fe ll lm ln lo b">filter</code>方法。现在它可以和各种<code class="fe ll lm ln lo b">specification</code>一起工作。</li></ul><h1 id="67d6" class="lq lr in bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">对于两个或多个组合规格</h1><pre class="mo mp mq mr gt ms lo mt mu aw mv bi"><span id="dbca" class="mw lr in lo b gy mx my l mz na">template &lt;typename T&gt;<br/>struct AndSpecification : Specification&lt;T&gt; {<br/>    const Specification&lt;T&gt; &amp;first;<br/>    const Specification&lt;T&gt; &amp;second;</span><span id="849a" class="mw lr in lo b gy nb my l mz na">    AndSpecification(const Specification&lt;T&gt; &amp;first, const Specification&lt;T&gt; &amp;second)<br/>    : first(first), second(second) {}</span><span id="a54d" class="mw lr in lo b gy nb my l mz na">    bool is_satisfied(T *item) const { <br/>        return first.is_satisfied(item) &amp;&amp; second.is_satisfied(item); <br/>    }<br/>};</span><span id="86bb" class="mw lr in lo b gy nb my l mz na">template &lt;typename T&gt;<br/>AndSpecification&lt;T&gt; operator&amp;&amp;(const Specification&lt;T&gt; &amp;first, const Specification&lt;T&gt; &amp;second) {<br/>    return {first, second};<br/>}</span><span id="c2eb" class="mw lr in lo b gy nb my l mz na">// -----------------------------------------------------------------------------------------------------</span><span id="3d66" class="mw lr in lo b gy nb my l mz na">auto green_things = ColorSpecification{COLOR::GREEN};<br/>auto large_things = SizeSpecification{SIZE::LARGE};</span><span id="c902" class="mw lr in lo b gy nb my l mz na">BetterFilter bf;<br/>for (auto &amp;x : bf.filter(all, green_things &amp;&amp;large_things))<br/>    cout &lt;&lt; x-&gt;m_name &lt;&lt; " is green and large\n";</span><span id="b834" class="mw lr in lo b gy nb my l mz na">// warning: the following will compile but will NOT work<br/>// auto spec2 = SizeSpecification{SIZE::LARGE} &amp;&amp;<br/>//              ColorSpecification{COLOR::BLUE};</span></pre><ul class=""><li id="f3c5" class="kx ky in jt b ju jv jy jz kc kz kg la kk lb ko lp ld le lf bi translated"><code class="fe ll lm ln lo b">SizeSpecification{SIZE::LARGE} &amp;&amp; ColorSpecification{COLOR::BLUE}</code>不起作用。有经验的 C++眼睛很容易就能认出原因。虽然临时对象创建在这里是一个提示。如果你这样做，你可能会得到如下的<a class="ae kp" href="http://www.vishalchovatiya.com/part-1-all-about-virtual-keyword-in-cpp-how-virtual-function-works-internally/" rel="noopener ugc nofollow" target="_blank">纯虚函数</a>的错误:</li></ul><pre class="mo mp mq mr gt ms lo mt mu aw mv bi"><span id="2f45" class="mw lr in lo b gy mx my l mz na">pure virtual method called<br/>terminate called without an active exception<br/>The terminal process terminated with exit code: 3</span></pre><ul class=""><li id="0740" class="kx ky in jt b ju jv jy jz kc kz kg la kk lb ko lp ld le lf bi translated">对于两个以上的规范，可以使用可变模板。</li></ul><h1 id="ae5a" class="lq lr in bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">开闭原则的好处</h1><h1 id="fe52" class="lq lr in bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">= &gt;扩展性</h1><p id="2966" class="pw-post-body-paragraph jr js in jt b ju nc jw jx jy nd ka kb kc ne ke kf kg nf ki kj kk ng km kn ko ig bi translated">“当一个程序的单一变化导致相关模块的一系列变化时，这个程序就会表现出我们认为是‘坏’设计的不良属性。程序变得脆弱、僵化、不可预测和不可重用。开闭原则以非常直接的方式解决了这个问题。它说你应该设计永不改变的模块。当需求发生变化时，您可以通过添加新代码来扩展这些模块的行为，而不是通过更改已经工作的旧代码。”罗伯特·马丁</p><h1 id="f276" class="lq lr in bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">= &gt;可维护性</h1><ul class=""><li id="27c0" class="kx ky in jt b ju nc jy nd kc nh kg ni kk nj ko lp ld le lf bi translated">这种方法的主要好处是接口引入了一个额外的抽象层次，支持松散耦合。一个接口的实现是相互独立的，不需要共享任何代码。</li><li id="d44d" class="kx ky in jt b ju lg jy lh kc li kg lj kk lk ko lp ld le lf bi translated">因此，您可以轻松应对客户不断变化的需求。在敏捷方法中非常有用。</li></ul><h1 id="92cc" class="lq lr in bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">= &gt;灵活性</h1><ul class=""><li id="6901" class="kx ky in jt b ju nc jy nd kc nh kg ni kk nj ko lp ld le lf bi translated">开闭原则也适用于插件和中间件架构。在这种情况下，您的基础软件实体就是您的应用程序核心功能。</li><li id="2747" class="kx ky in jt b ju lg jy lh kc li kg lj kk lk ko lp ld le lf bi translated">在插件的情况下，您有一个基础或核心模块，可以通过一个公共网关接口插入新的特性和功能。web 浏览器扩展就是一个很好的例子。</li><li id="ee28" class="kx ky in jt b ju lg jy lh kc li kg lj kk lk ko lp ld le lf bi translated">二进制兼容性也将在后续版本中保持不变。</li></ul><h1 id="7df5" class="lq lr in bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">尺度来制作开放封闭原理友好的软件</h1><ul class=""><li id="42ce" class="kx ky in jt b ju nc jy nd kc nh kg ni kk nj ko lp ld le lf bi translated">在 SRP 中，您对分解以及在代码中何处绘制封装边界做出判断。在 OCP 中，你判断在你的模块中什么是抽象的，留给模块的消费者去具体化，什么是具体的功能提供给你自己。</li><li id="0e01" class="kx ky in jt b ju lg jy lh kc li kg lj kk lk ko lp ld le lf bi translated">有许多设计模式可以帮助我们在不改变代码的情况下扩展代码。例如，<a class="ae kp" href="http://www.vishalchovatiya.com/decorator-design-pattern-in-modern-cpp/" rel="noopener ugc nofollow" target="_blank">装饰模式</a>帮助我们遵循开闭原则。此外，<a class="ae kp" href="http://www.vishalchovatiya.com/factory-design-pattern-in-modern-cpp/" rel="noopener ugc nofollow" target="_blank">工厂方法</a>、<a class="ae kp" href="http://www.vishalchovatiya.com/strategy-design-pattern-in-modern-cpp/" rel="noopener ugc nofollow" target="_blank">策略模式</a>或<a class="ae kp" href="http://www.vishalchovatiya.com/observer-design-pattern-in-modern-cpp/" rel="noopener ugc nofollow" target="_blank">观察者模式</a>可以用来设计一个应用程序，只需对现有代码做最小的改动，就可以轻松地进行更改。</li></ul><h1 id="6d48" class="lq lr in bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">结论</h1><p id="041b" class="pw-post-body-paragraph jr js in jt b ju nc jw jx jy nd ka kb kc ne ke kf kg nf ki kj kk ng km kn ko ig bi translated">请记住，课程永远不会完全关闭。总会有不可预见的变化需要修改一个类。但是，如果可以预见变更，如上文所示，即<code class="fe ll lm ln lo b">filters</code>，那么当这些变更请求滚滚而来时，您就有了一个应用 OCP 以适应未来的绝佳机会。</p><p id="bfac" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><a class="ae kp" href="http://www.vishalchovatiya.com/contact-2/" rel="noopener ugc nofollow" target="_blank">有什么建议，查询或者想说</a> <code class="fe ll lm ln lo b"><a class="ae kp" href="http://www.vishalchovatiya.com/contact-2/" rel="noopener ugc nofollow" target="_blank">Hi</a></code> <a class="ae kp" href="http://www.vishalchovatiya.com/contact-2/" rel="noopener ugc nofollow" target="_blank">？减轻压力，只需点击一下鼠标。</a> 🖱️</p></div></div>    
</body>
</html>