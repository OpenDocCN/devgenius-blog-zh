<html>
<head>
<title>How to Make a Lucky Draw in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用 Python 制作幸运抽奖</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-to-make-a-lucky-draw-in-python-b9735a50bbe1?source=collection_archive---------8-----------------------#2022-03-01">https://blog.devgenius.io/how-to-make-a-lucky-draw-in-python-b9735a50bbe1?source=collection_archive---------8-----------------------#2022-03-01</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="2554" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ki">同时保证随机性和公平性</em></p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/b838d46ec61b93fe590b63bec4e52c5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*c6pYMFbU8iWht7gz"/></div></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk translated">图片来自<a class="ae kz" href="https://www.microsoft.com/en-id/p/draw-lucky/9mv2tj823b1h?activetab=pivot:overviewtab" rel="noopener ugc nofollow" target="_blank">https://www.microsoft.com/en-id/p/draw-lucky/9mv2tj823b1h?active tab = pivot:overview tab</a></figcaption></figure><p id="ef1d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们都喜欢抽奖，尤其是当我们是幸运儿的时候。有许多关于一些周年聚会中的幸运抽奖被其他人质疑公平性的故事，甚至还有开发者在现场审查幸运抽奖代码的照片。</p><h1 id="3013" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">履行</h1><p id="7032" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">假设您有 10 个人参与抽奖，用 Python 制作抽奖的最简单方法是生成一个随机数，如下所示:</p><pre class="kk kl km kn gt md me mf mg aw mh bi"><span id="ac99" class="mi lb in me b gy mj mk l ml mm">import random<br/>lower_limit = 1<br/>upper_limit = 10<br/>result = random.randint(lower_limit, upper_limit)<br/>print(result)</span></pre><p id="bf6d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在上面的代码中，数字将从 1 和 10 中选择，包括 1 和 10。你需要事先给每个人分配一个号码，在我们的例子中，我们简单地使用群聊中的出现顺序，这是根据加入群的时间来确定的。</p><p id="7b14" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是这种方法有一个问题，除非你在所有 10 个人面前运行这段代码，否则不能保证你运行了多次并选择了最喜欢的结果来发布。</p><p id="b1ce" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一个可能的解决方案是在指定的时间运行上面的代码，这样你就不可能多次运行它，另外，当人们能够看到倒计时时，他们会更加兴奋。</p><p id="551a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以我们首先需要把一个给定的字符串解析成一个时间对象:</p><pre class="kk kl km kn gt md me mf mg aw mh bi"><span id="0934" class="mi lb in me b gy mj mk l ml mm">import datetime<br/>at_time = '16:00'<br/>at_time = datetime.datetime.strptime(at_time, '%H:%M').time()<br/>at_time = datetime.datetime.combine(datetime.datetime.now().date(), at_time)</span></pre><p id="b636" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">注意，我花了几个步骤才得到今天<code class="fe mn mo mp me b">16:00</code>的正确时间，因为<code class="fe mn mo mp me b">datetime.datetime.strptime(at_time, ‘%H:%M’)</code>实际上会返回<code class="fe mn mo mp me b">1900-1-1</code>的时间。</p><p id="8c30" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们还想知道现在是什么时间:</p><pre class="kk kl km kn gt md me mf mg aw mh bi"><span id="9197" class="mi lb in me b gy mj mk l ml mm">cur_time = datetime.datetime.fromtimestamp(int(datetime.datetime.now().timestamp()))</span></pre><p id="5349" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">代码<code class="fe mn mo mp me b">datetime.datetime.now()</code>实际上返回精确到微秒的当前时间，这在这种情况下是不必要的，因此为了简单起见，我们需要去掉小数部分。</p><p id="d711" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在我们可以将初始代码修改成这样:</p><pre class="kk kl km kn gt md me mf mg aw mh bi"><span id="f050" class="mi lb in me b gy mj mk l ml mm">import random<br/>import datetime<br/>import time</span><span id="818a" class="mi lb in me b gy mq mk l ml mm">lower_limit = 1<br/>upper_limit = 10</span><span id="5c8a" class="mi lb in me b gy mq mk l ml mm">at_time = '16:00'<br/>at_time = datetime.datetime.strptime(at_time, '%H:%M').time()<br/>at_time = datetime.datetime.combine(datetime.datetime.now().date(), at_time)</span><span id="e6d9" class="mi lb in me b gy mq mk l ml mm">cur_time = datetime.datetime.fromtimestamp(int(datetime.datetime.now().timestamp()))</span><span id="d0d3" class="mi lb in me b gy mq mk l ml mm">while cur_time&lt;at_time:<br/>    remain_sec = (at_time - cur_time).seconds<br/>    print(f'{remain_sec} seconds to go')<br/>    time.sleep(1)<br/>    cur_time = datetime.datetime.fromtimestamp(int(datetime.datetime.now().timestamp()))<br/>print('time up! here goes ...')<br/>result = random.randint(lower_limit, upper_limit)<br/>print(f'the winner is {result}!')</span></pre><h1 id="1e4a" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">结论和挑战</h1><p id="05ea" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">通过上面的练习，我们学到了两件事:</p><ol class=""><li id="4651" class="mr ms in jm b jn jo jr js jv mt jz mu kd mv kh mw mx my mz bi translated">复杂的问题通常有简单的解决方案，在这种情况下，定时解决方案既简单又优雅。</li><li id="0873" class="mr ms in jm b jn na jr nb jv nc jz nd kd ne kh mw mx my mz bi translated">Python 中的日期和时间操作可能非常棘手。</li></ol><p id="f464" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当然，上面的代码远非完美(也取决于你对完美的定义)，我们有几种方法可以改进它:</p><ol class=""><li id="57ce" class="mr ms in jm b jn jo jr js jv mt jz mu kd mv kh mw mx my mz bi translated">将其包装在一个函数中以简化调用。</li><li id="5707" class="mr ms in jm b jn na jr nb jv nc jz nd kd ne kh mw mx my mz bi translated">默认情况下，允许传递一个<code class="fe mn mo mp me b">in_min=1</code>来倒计时一分钟，而不是传递一个时间字符串，比如<code class="fe mn mo mp me b">16:00</code>。</li><li id="57e3" class="mr ms in jm b jn na jr nb jv nc jz nd kd ne kh mw mx my mz bi translated">不要使用<code class="fe mn mo mp me b">upper_limit</code>和<code class="fe mn mo mp me b">lower_limit</code>数字，允许传递一系列数字甚至名字作为参与者。</li><li id="39bf" class="mr ms in jm b jn na jr nb jv nc jz nd kd ne kh mw mx my mz bi translated">不是只产生一个赢家，而是允许一次产生多个赢家，产生的顺序很重要，以区分第一价格、第二价格、第三价格等。</li></ol><p id="5dd7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你感兴趣，我会把挑战留给用户，如果你愿意，在这里张贴你的答案或问题。</p></div></div>    
</body>
</html>