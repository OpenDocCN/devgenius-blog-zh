<html>
<head>
<title>Android networking and database caching (MVVM+Retrofit+Room+Flow)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android 网络和数据库缓存(MVVM+翻新+房间+流量)</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/android-networking-and-database-caching-in-2020-mvvm-retrofit-room-flow-35b4f897d46a?source=collection_archive---------0-----------------------#2020-06-11">https://blog.devgenius.io/android-networking-and-database-caching-in-2020-mvvm-retrofit-room-flow-35b4f897d46a?source=collection_archive---------0-----------------------#2020-06-11</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/7e4a999175d1e38d5ed6227dd406bd21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CYOGJK1XLZs1-V2ZtnQg5g.png"/></div></div></figure><div class=""/><p id="9978" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">MVVM 是安卓开发者的新宠。它提供了很多好处，如干净的架构、代码可维护性等。然而，巨大的权力伴随着巨大的责任。你必须维护网络、数据库等等。如果你想在一个地方处理所有这些事情，那么你会得到难看的代码。幸运的是，我们现在已经有了解决方案。在本文中，我将介绍我所面临的问题以及我的库将如何解决这些问题，因为它将帮助您编写简洁、干净的代码，并对您的代码有更多的控制。</p><p id="f64b" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我遇到的第一个问题是，如何在一个地方处理数据库和网络？如果网络调用失败，在哪里处理改造错误响应？如果网络调用失败，从哪里获取数据？等等。</p><p id="76a0" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">第二个问题是，我想使用最新的技术，所以我选择了 kotlin flow 而不是 livedata。那么如何用 flow 来组织所有这些东西呢？有什么办法处理这些事情吗？我决定为它写一个新的库。所以我是这样实现的。</p></div><div class="ab cl kt ku hr kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ig ih ii ij ik"><p id="87b5" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在我们开始探索之前，实现这个库必须满足三个要求:</p><ul class=""><li id="ffb1" class="la lb iy jx b jy jz kc kd kg lc kk ld ko le ks lf lg lh li bi translated">Dao 方法必须返回<code class="fe lj lk ll lm b">Flow&lt;ModelClass&gt;</code></li><li id="7fde" class="la lb iy jx b jy ln kc lo kg lp kk lq ko lr ks lf lg lh li bi translated">Api 方法必须返回<code class="fe lj lk ll lm b">Flow&lt;ApiResponse&lt;ModelClass&gt;&gt;</code></li><li id="2cc1" class="la lb iy jx b jy ln kc lo kg lp kk lq ko lr ks lf lg lh li bi translated">我们需要添加<em class="ls"> FlowCallAdapterFactory </em>作为改型生成器中的 CallAdapterFactory，让改型知道如何将响应转换成我们的<code class="fe lj lk ll lm b">Flow&lt;ApiResponse&lt;&gt;&gt;</code>包装器。(它是作为库的一部分实现的)</li></ul><p id="48c7" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们将认为我们的网络调用在任何时候都有三种状态:成功、错误或加载。所以我们需要创建一个如下的类。</p><figure class="lt lu lv lw gt ip"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="0707" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，我们将考虑我们 API 客户端(在本例中是<a class="ae lz" href="https://github.com/square/retrofit" rel="noopener ugc nofollow" target="_blank">改进</a>)将返回三个响应之一:</p><ul class=""><li id="06b8" class="la lb iy jx b jy jz kc kd kg lc kk ld ko le ks lf lg lh li bi translated">成功响应—当网络呼叫成功时</li><li id="25f7" class="la lb iy jx b jy ln kc lo kg lp kk lq ko lr ks lf lg lh li bi translated">错误响应—当网络调用失败时(包括改造引发的异常)</li><li id="2821" class="la lb iy jx b jy ln kc lo kg lp kk lq ko lr ks lf lg lh li bi translated">空响应—当成功响应没有正文(HTTP 204)时，我们将使用这个类</li></ul><p id="721d" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以我们的实现看起来像这样</p><figure class="lt lu lv lw gt ip"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="0fd1" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在是真正的瑰宝，网络资源文件</p><figure class="lt lu lv lw gt ip"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="7b42" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在 NetworkBoundResource 文件中，我们在函数内部传递一些函数(Kotlin 的高阶函数),这些函数将决定在特定情况下应该做什么。下面是我们在 networkBoundResource 函数中传递的每个类的快速解释:</p><ul class=""><li id="0873" class="la lb iy jx b jy jz kc kd kg lc kk ld ko le ks lf lg lh li bi translated"><em class="ls"> fetchFromLocal </em> —它影响来自本地数据库的数据</li><li id="911f" class="la lb iy jx b jy ln kc lo kg lp kk lq ko lr ks lf lg lh li bi translated"><em class="ls"> shouldFetchFromRemote </em> —它决定是否应该发出网络请求或使用本地持久数据(如果可用的话)(可选)</li><li id="5fe2" class="la lb iy jx b jy ln kc lo kg lp kk lq ko lr ks lf lg lh li bi translated"><em class="ls"> fetchFromRemote </em> —执行网络请求操作</li><li id="a5f3" class="la lb iy jx b jy ln kc lo kg lp kk lq ko lr ks lf lg lh li bi translated"><em class="ls"> processRemoteResponse </em> —在将模型类保存到数据库之前，处理网络响应的结果，如保存某些头值(可选)</li><li id="0e72" class="la lb iy jx b jy ln kc lo kg lp kk lq ko lr ks lf lg lh li bi translated"><em class="ls"> saveRemoteData </em> —将网络请求的结果保存到本地永久数据库</li><li id="f8eb" class="la lb iy jx b jy ln kc lo kg lp kk lq ko lr ks lf lg lh li bi translated"><em class="ls"> onFetchFailed </em> —它处理网络请求失败场景(非 HTTP 200..300 个响应、例外等)(可选)</li></ul><p id="3c99" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在当使用它时，这是存储库类的样子</p><figure class="lt lu lv lw gt ip"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="b7cf" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们的视图模型类看起来像这样，</p><figure class="lt lu lv lw gt ip"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="1920" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们可以在我们的 UI 中观察这个变量，并基于它驱动 UI。</p></div><div class="ab cl kt ku hr kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ig ih ii ij ik"><p id="43e0" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你不需要做所有这些花里胡哨的东西，因为它在 Github 上有库。您只需要在您的存储库和视图模型类中实现您的项目特定的代码。</p><p id="b79f" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您可以在 Github 上找到基于这个库构建的示例应用程序。</p><div class="im in gp gr io ma"><a href="https://github.com/hadiyarajesh/flower" rel="noopener  ugc nofollow" target="_blank"><div class="mb ab fo"><div class="mc ab md cl cj me"><h2 class="bd iz gy z fp mf fr fs mg fu fw ix bi translated">hadiyarajesh/花</h2><div class="mh l"><h3 class="bd b gy z fp mf fr fs mg fu fw dk translated">超级酷的 Android 库，轻松管理数据库缓存和网络。它帮助你处理所有的情况…</h3></div><div class="mi l"><p class="bd b dl z fp mf fr fs mg fu fw dk translated">github.com</p></div></div><div class="mj l"><div class="mk l ml mm mn mj mo iu ma"/></div></div></a></div><p id="0c41" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果这有助于你写出简洁明了的代码，请点击“鼓掌”按钮😃</p></div></div>    
</body>
</html>