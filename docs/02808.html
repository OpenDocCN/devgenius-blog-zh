<html>
<head>
<title>Composite Design Pattern in Modern C++</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">现代C++中的复合设计模式</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/composite-design-pattern-in-modern-c-8cb833f5e53a?source=collection_archive---------13-----------------------#2020-08-31">https://blog.devgenius.io/composite-design-pattern-in-modern-c-8cb833f5e53a?source=collection_archive---------13-----------------------#2020-08-31</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/cbe3436490e1738c6410a47365beb512.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-QSqCx8pgnkfq64M-fqQ3A.png"/></div></div></figure><p id="5690" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">GoF 将复合设计模式描述为“将对象组成一个树形结构来表示部分-整体层次结构。Composite让客户统一处理单个对象和对象的组合”。这对我来说似乎太复杂了。所以，我不想用树叶的术语。相反，我直接看到了在现代C++中实现复合设计模式的两三种不同方式。但简单来说，复合设计模式是一种结构化的设计模式，其目标<strong class="jx io"> <em class="ku">是以对待单个对象</em> </strong>的方式对待一组对象。</p><blockquote class="kv kw kx"><p id="2c0e" class="jv jw ku jx b jy jz ka kb kc kd ke kf ky kh ki kj kz kl km kn la kp kq kr ks ig bi translated"><em class="in"> /！\:本文已原创发表于我的</em> <a class="ae kt" href="http://www.vishalchovatiya.com/composite-design-pattern-in-modern-cpp/" rel="noopener ugc nofollow" target="_blank"> <em class="in">博客</em> </a> <em class="in">。如果你有兴趣接收我的最新文章，</em> <a class="ae kt" href="http://eepurl.com/gDNybv" rel="noopener ugc nofollow" target="_blank"> <em class="in">请报名参加我的简讯</em> </a> <em class="in">。</em></p></blockquote><p id="e38c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">顺便说一句，如果你还没有看过我关于结构设计模式的其他文章，下面是列表:</p><ol class=""><li id="99e9" class="lb lc in jx b jy jz kc kd kg ld kk le ko lf ks lg lh li lj bi translated"><a class="ae kt" href="http://www.vishalchovatiya.com/adapter-design-pattern-in-modern-cpp/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io">适配器</strong> </a></li><li id="aaf0" class="lb lc in jx b jy lk kc ll kg lm kk ln ko lo ks lg lh li lj bi translated"><a class="ae kt" href="http://www.vishalchovatiya.com/bridge-design-pattern-in-modern-cpp/" rel="noopener ugc nofollow" target="_blank">桥<strong class="jx io">桥</strong>桥</a></li><li id="10dc" class="lb lc in jx b jy lk kc ll kg lm kk ln ko lo ks lg lh li lj bi translated"><a class="ae kt" href="http://www.vishalchovatiya.com/composite-design-pattern-in-modern-cpp/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io">复合</strong> </a></li><li id="15e4" class="lb lc in jx b jy lk kc ll kg lm kk ln ko lo ks lg lh li lj bi translated"><a class="ae kt" href="http://www.vishalchovatiya.com/decorator-design-pattern-in-modern-cpp/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io">装饰者</strong> </a></li><li id="8e3f" class="lb lc in jx b jy lk kc ll kg lm kk ln ko lo ks lg lh li lj bi translated"><a class="ae kt" href="http://www.vishalchovatiya.com/facade-design-pattern-in-modern-cpp/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io">立面</strong> </a></li><li id="b647" class="lb lc in jx b jy lk kc ll kg lm kk ln ko lo ks lg lh li lj bi translated"><a class="ae kt" href="http://www.vishalchovatiya.com/flyweight-design-pattern-in-modern-cpp/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io">蝇量级</strong> </a></li><li id="c21c" class="lb lc in jx b jy lk kc ll kg lm kk ln ko lo ks lg lh li lj bi translated"><a class="ae kt" href="http://www.vishalchovatiya.com/proxy-design-pattern-in-modern-cpp/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io">代理</strong> </a></li></ol><p id="b93e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您在这一系列文章中看到的代码片段是简化的，而不是复杂的。所以你经常看到我不使用像<code class="fe lp lq lr ls b">override</code>、<code class="fe lp lq lr ls b">final</code>、<code class="fe lp lq lr ls b">public</code>(同时继承)这样的关键字，只是为了让代码紧凑&amp;可消耗(大多数时候)在单一标准屏幕尺寸。我也更喜欢<code class="fe lp lq lr ls b">struct</code>而不是<code class="fe lp lq lr ls b">class</code>，只是为了节省代码行，有时不写<code class="fe lp lq lr ls b">public:</code>，也故意忽略<a class="ae kt" href="http://www.vishalchovatiya.com/part-3-all-about-virtual-keyword-in-c-how-virtual-destructor-works/" rel="noopener ugc nofollow" target="_blank">虚析构函数</a>，构造函数<a class="ae kt" href="http://www.vishalchovatiya.com/all-about-copy-constructor-in-cpp-with-example/" rel="noopener ugc nofollow" target="_blank">，复制构造函数</a>，前缀<code class="fe lp lq lr ls b">std::</code>，删除动态内存。我也认为自己是一个务实的人，希望用尽可能简单的方式，而不是标准的方式或使用术语来传达一个想法。</p><p id="554b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> <em class="ku">注:</em> </strong></p><ul class=""><li id="a48c" class="lb lc in jx b jy jz kc kd kg ld kk le ko lf ks lt lh li lj bi translated">如果你是在这里被直接绊倒的，那么我建议你浏览一下<a class="ae kt" href="http://www.vishalchovatiya.com/what-is-design-pattern/" rel="noopener ugc nofollow" target="_blank">什么是设计模式？</a>第一，哪怕是微不足道的小事。相信会鼓励你对这个话题进行更多的探索。</li><li id="1996" class="lb lc in jx b jy lk kc ll kg lm kk ln ko lo ks lt lh li lj bi translated">您在这一系列文章中遇到的所有代码都是使用C++20编译的(尽管我在大多数情况下使用了C++17的现代C++特性)。因此，如果你没有最新的编译器，你可以使用已经预装了boost库的https://wandbox.org/。</li></ul><h1 id="88ea" class="lu lv in bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">目的</h1><blockquote class="kv kw kx"><p id="230a" class="jv jw ku jx b jy jz ka kb kc kd ke kf ky kh ki kj kz kl km kn la kp kq kr ks ig bi translated"><strong class="jx io">以统一的方式对待单个&amp;组对象。</strong></p></blockquote><figure class="mt mu mv mw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ms"><img src="../Images/2967fe15c82eef2074cf22437933a95e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*-dKuxaovN4U85Mv9.png"/></div></div></figure><ul class=""><li id="8a97" class="lb lc in jx b jy jz kc kd kg ld kk le ko lf ks lt lh li lj bi translated">那么它到底是什么，我们为什么需要它。我们知道，对象通常通过继承或组合来使用其他对象、字段、属性或成员。</li><li id="66ac" class="lb lc in jx b jy lk kc ll kg lm kk ln ko lo ks lt lh li lj bi translated">例如，在绘图应用程序中，您有一个<code class="fe lp lq lr ls b">Shape</code>(例如<code class="fe lp lq lr ls b">Circle</code>)可以在屏幕上绘制，但是您也可以有一组从集合<code class="fe lp lq lr ls b">Shape</code>继承而来的<code class="fe lp lq lr ls b">Shape</code>(例如<code class="fe lp lq lr ls b">vector&lt;Circle&gt;</code>)。</li><li id="9c27" class="lb lc in jx b jy lk kc ll kg lm kk ln ko lo ks lt lh li lj bi translated">它们有一些通用的API，你可以调用它们中的一个或者另一个，而不需要事先知道你是在处理单个元素还是整个集合。</li></ul><h1 id="4912" class="lu lv in bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">C++中的复合设计模式示例</h1><ul class=""><li id="2ad8" class="lb lc in jx b jy mx kc my kg mz kk na ko nb ks lt lh li lj bi translated">因此，如果你想到一个应用程序，如PowerPoint或任何类型的矢量绘图应用程序，你知道你可以绘制和拖动单个形状。</li><li id="a55c" class="lb lc in jx b jy lk kc ll kg lm kk ln ko lo ks lt lh li lj bi translated">但是您也可以将形状组合在一起。当您将几个形状组合在一起时，您可以将它们视为单个形状。所以你可以抓取整个东西，拖动它，调整它的大小等等。</li><li id="1bcc" class="lb lc in jx b jy lk kc ll kg lm kk ln ko lo ks lt lh li lj bi translated">因此，我们将围绕几种不同形状的想法实现复合设计模式。</li></ul><h1 id="7da0" class="lu lv in bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">经典复合设计模式</h1><pre class="mt mu mv mw gt nc ls nd ne aw nf bi"><span id="9918" class="ng lv in ls b gy nh ni l nj nk">struct Shape {<br/>    virtual void draw() = 0;<br/>};</span><span id="2279" class="ng lv in ls b gy nl ni l nj nk">struct Circle : Shape {<br/>    void draw() { cout &lt;&lt; "Circle" &lt;&lt; endl; }<br/>};</span><span id="0fc6" class="ng lv in ls b gy nl ni l nj nk">struct Group : Shape {<br/>    string              m_name;<br/>    vector&lt;Shape*&gt;      m_objects;</span><span id="16f1" class="ng lv in ls b gy nl ni l nj nk">    Group(const string &amp;n) : m_name{n} {}</span><span id="dc2f" class="ng lv in ls b gy nl ni l nj nk">    void draw() {<br/>        cout &lt;&lt; "Group " &lt;&lt; m_name.c_str() &lt;&lt; " contains:" &lt;&lt; endl;<br/>        for (auto &amp;&amp;o : m_objects)<br/>            o-&gt;draw();<br/>    }<br/>};</span><span id="be70" class="ng lv in ls b gy nl ni l nj nk">int main() {<br/>    Group root("root");<br/>    root.m_objects.push_back(new Circle);</span><span id="2e22" class="ng lv in ls b gy nl ni l nj nk">    Group subgroup("sub");<br/>    subgroup.m_objects.push_back(new Circle);</span><span id="f3ac" class="ng lv in ls b gy nl ni l nj nk">    root.m_objects.push_back(&amp;subgroup);<br/>    root.draw();</span><span id="f5a3" class="ng lv in ls b gy nl ni l nj nk">    return EXIT_SUCCESS;<br/>}<br/>/*<br/>Group root contains:<br/>Circle<br/>Group sub contains:<br/>Circle<br/>*/</span></pre><h1 id="fba1" class="lu lv in bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">使用奇怪重复出现的模板模式的复合设计模式(CRTP)</h1><ul class=""><li id="4cb3" class="lb lc in jx b jy mx kc my kg mz kk na ko nb ks lt lh li lj bi translated">正如你可能已经注意到的，机器学习现在是一个非常热门的话题。机器学习机制的一部分是使用神经网络，这就是我们现在要看的。</li></ul><pre class="mt mu mv mw gt nc ls nd ne aw nf bi"><span id="f790" class="ng lv in ls b gy nh ni l nj nk">struct Neuron {<br/>    vector&lt;Neuron*&gt;     in, out;<br/>    uint32_t            id;</span><span id="1248" class="ng lv in ls b gy nl ni l nj nk">    Neuron() {<br/>        static int id = 1;<br/>        this-&gt;id = id++;<br/>    }</span><span id="90ab" class="ng lv in ls b gy nl ni l nj nk">    void connect_to(Neuron &amp;other) {<br/>        out.push_back(&amp;other);<br/>        other.in.push_back(this);<br/>    }</span><span id="1924" class="ng lv in ls b gy nl ni l nj nk">    friend ostream &amp;operator&lt;&lt;(ostream &amp;os, const Neuron &amp;obj) {<br/>        for (Neuron *n : obj.in)<br/>            os &lt;&lt; n-&gt;id &lt;&lt; "\t--&gt;\t[" &lt;&lt; obj.id &lt;&lt; "]" &lt;&lt; endl;</span><span id="0d5d" class="ng lv in ls b gy nl ni l nj nk">        for (Neuron *n : obj.out)<br/>            os &lt;&lt; "[" &lt;&lt; obj.id &lt;&lt; "]\t--&gt;\t" &lt;&lt; n-&gt;id &lt;&lt; endl;</span><span id="bdbd" class="ng lv in ls b gy nl ni l nj nk">        return os;<br/>    }<br/>};</span><span id="0578" class="ng lv in ls b gy nl ni l nj nk">int main() {<br/>    Neuron n1, n2;<br/>    n1.connect_to(n2);<br/>    cout &lt;&lt; n1 &lt;&lt; n2 &lt;&lt; endl;<br/>    return EXIT_SUCCESS;<br/>}<br/>/* Output<br/>[1]    --&gt;    2<br/>1    --&gt;    [2]<br/>*/</span></pre><ul class=""><li id="f771" class="lb lc in jx b jy jz kc kd kg ld kk le ko lf ks lt lh li lj bi translated">正如你所看到的，我们有一个神经元结构，它与其他神经元有连接，这些神经元被建模为输入-输出神经元连接的指针向量。这是一个非常基本的实现，只要你只有单独的神经元，它就能很好地工作。现在有一件事我们还没有考虑到，当你有一个以上的神经元或神经元群连接时会发生什么。</li><li id="911f" class="lb lc in jx b jy lk kc ll kg lm kk ln ko lo ks lt lh li lj bi translated">假设我们决定做一个神经元层，现在一层神经元基本上就像一个集合。</li></ul><pre class="mt mu mv mw gt nc ls nd ne aw nf bi"><span id="1a9a" class="ng lv in ls b gy nh ni l nj nk">struct NeuronLayer : vector&lt;Neuron&gt; {<br/>    NeuronLayer(int count) {<br/>        while (count-- &gt; 0)<br/>            emplace_back(Neuron{});<br/>    }</span><span id="5995" class="ng lv in ls b gy nl ni l nj nk">    friend ostream &amp;operator&lt;&lt;(ostream &amp;os, NeuronLayer &amp;obj) {<br/>        for (auto &amp;n : obj)<br/>            os &lt;&lt; n;<br/>        return os;<br/>    }<br/>};</span><span id="a2f1" class="ng lv in ls b gy nl ni l nj nk">int main() {<br/>    NeuronLayer l1{1}, l2{2};<br/>    Neuron n1, n2;<br/>    n1.connect_to(l1);  // Neuron connects to Layer<br/>    l2.connect_to(n2);  // Layer connects to Neuron<br/>    l1.connect_to(l2);  // Layer connects to Layer<br/>    n1.connect_to(n2);  // Neuron connects to Neuron</span><span id="8177" class="ng lv in ls b gy nl ni l nj nk">    return EXIT_SUCCESS;<br/>}</span></pre><ul class=""><li id="576a" class="lb lc in jx b jy jz kc kd kg ld kk le ko lf ks lt lh li lj bi translated">现在，正如您可能已经猜到的那样，如果您要正面实现这个功能，您将总共有四个不同的功能。即</li></ul><pre class="mt mu mv mw gt nc ls nd ne aw nf bi"><span id="c91e" class="ng lv in ls b gy nh ni l nj nk">Neuron::connect_to(NeuronLayer&amp;)<br/>NeuronLayer::connect_to(Neuron&amp;)<br/>NeuronLayer::connect_to(NeuronLayer&amp;)<br/>Neuron::connect_to(Neuron&amp;)</span></pre><ul class=""><li id="5e33" class="lb lc in jx b jy jz kc kd kg ld kk le ko lf ks lt lh li lj bi translated">所以这是状态空间爆炸&amp;置换问题，这并不好，因为我们想要一个既能枚举层又能枚举单个神经元的函数。</li></ul><pre class="mt mu mv mw gt nc ls nd ne aw nf bi"><span id="5adf" class="ng lv in ls b gy nh ni l nj nk">template &lt;typename Self&gt;<br/>struct SomeNeurons {<br/>    template &lt;typename T&gt;<br/>    void connect_to(T &amp;other);<br/>};</span><span id="46b6" class="ng lv in ls b gy nl ni l nj nk">struct Neuron : SomeNeurons&lt;Neuron&gt; {<br/>    vector&lt;Neuron*&gt;     in, out;<br/>    uint32_t            id;</span><span id="7975" class="ng lv in ls b gy nl ni l nj nk">    Neuron() {<br/>        static int id = 1;<br/>        this-&gt;id = id++;<br/>    }</span><span id="25c6" class="ng lv in ls b gy nl ni l nj nk">    Neuron* begin() { return this; }<br/>    Neuron* end() { return this + 1; }<br/>};</span><span id="c26e" class="ng lv in ls b gy nl ni l nj nk">struct NeuronLayer : vector&lt;Neuron&gt;, SomeNeurons&lt;NeuronLayer&gt; {<br/>    NeuronLayer(int count) {<br/>        while (count-- &gt; 0)<br/>            emplace_back(Neuron{});<br/>    }<br/>};</span><span id="05fa" class="ng lv in ls b gy nl ni l nj nk">template &lt;typename Self&gt;<br/>template &lt;typename T&gt;<br/>void SomeNeurons&lt;Self&gt;::connect_to(T &amp;other) {<br/>    for (Neuron &amp;from : *static_cast&lt;Self *&gt;(this)) {<br/>        for (Neuron &amp;to : other) {<br/>            from.out.push_back(&amp;to);<br/>            to.in.push_back(&amp;from);<br/>        }<br/>    }<br/>}</span><span id="2456" class="ng lv in ls b gy nl ni l nj nk">template &lt;typename Self&gt;<br/>ostream &amp;operator&lt;&lt;(ostream &amp;os, SomeNeurons&lt;Self&gt; &amp;object) {<br/>    for (Neuron &amp;obj : *static_cast&lt;Self *&gt;(&amp;object)) {<br/>        for (Neuron *n : obj.in)<br/>            os &lt;&lt; n-&gt;id &lt;&lt; "\t--&gt;\t[" &lt;&lt; obj.id &lt;&lt; "]" &lt;&lt; endl;</span><span id="7439" class="ng lv in ls b gy nl ni l nj nk">        for (Neuron *n : obj.out)<br/>            os &lt;&lt; "[" &lt;&lt; obj.id &lt;&lt; "]\t--&gt;\t" &lt;&lt; n-&gt;id &lt;&lt; endl;<br/>    }<br/>    return os;<br/>}</span><span id="91cc" class="ng lv in ls b gy nl ni l nj nk">int main() {<br/>    Neuron n1, n2;<br/>    NeuronLayer l1{1}, l2{2};</span><span id="f219" class="ng lv in ls b gy nl ni l nj nk">    n1.connect_to(l1); // Scenario 1: Neuron connects to Layer<br/>    l2.connect_to(n2); // Scenario 2: Layer connects to Neuron<br/>    l1.connect_to(l2); // Scenario 3: Layer connects to Layer<br/>    n1.connect_to(n2); // Scenario 4: Neuron connects to Neuron</span><span id="bbf1" class="ng lv in ls b gy nl ni l nj nk">    cout &lt;&lt; "Neuron " &lt;&lt; n1.id &lt;&lt; endl &lt;&lt; n1 &lt;&lt; endl;<br/>    cout &lt;&lt; "Neuron " &lt;&lt; n2.id &lt;&lt; endl &lt;&lt; n2 &lt;&lt; endl;</span><span id="9579" class="ng lv in ls b gy nl ni l nj nk">    cout &lt;&lt; "Layer " &lt;&lt; endl &lt;&lt; l1 &lt;&lt; endl;<br/>    cout &lt;&lt; "Layer " &lt;&lt; endl &lt;&lt; l2 &lt;&lt; endl;</span><span id="13ca" class="ng lv in ls b gy nl ni l nj nk">    return EXIT_SUCCESS;<br/>}<br/>/* Output<br/>Neuron 1<br/>[1]    --&gt;    3<br/>[1]    --&gt;    2</span><span id="b573" class="ng lv in ls b gy nl ni l nj nk">Neuron 2<br/>4    --&gt;    [2]<br/>5    --&gt;    [2]<br/>1    --&gt;    [2]</span><span id="2d2e" class="ng lv in ls b gy nl ni l nj nk">Layer <br/>1    --&gt;    [3]<br/>[3]    --&gt;    4<br/>[3]    --&gt;    5</span><span id="cc5d" class="ng lv in ls b gy nl ni l nj nk">Layer <br/>3    --&gt;    [4]<br/>[4]    --&gt;    2<br/>3    --&gt;    [5]<br/>[5]    --&gt;    2<br/>*/</span></pre><ul class=""><li id="6104" class="lb lc in jx b jy jz kc kd kg ld kk le ko lf ks lt lh li lj bi translated">如你所见，在CRTP的帮助下，我们用一个<code class="fe lp lq lr ls b">SomeNeurons::connect_to</code>方法涵盖了所有四种不同的排列场景。和<code class="fe lp lq lr ls b">Neuron</code> &amp; <code class="fe lp lq lr ls b">NeuronLayer</code>都通过自己的模板化符合这个接口。</li><li id="5ac5" class="lb lc in jx b jy lk kc ll kg lm kk ln ko lo ks lt lh li lj bi translated"><strong class="jx io"> C </strong>精心<strong class="jx io">R</strong>ecurring<strong class="jx io">T</strong>emplate<strong class="jx io">P</strong>attern在这里派上了用场&amp;有非常直接的实现规则，即<strong class="jx io"> <em class="ku">分离出依赖类型的&amp;独立功能，并使用自引用模板</em> </strong>将类型 <em class="ku">独立功能与基类绑定。</em></li><li id="5c76" class="lb lc in jx b jy lk kc ll kg lm kk ln ko lo ks lt lh li lj bi translated">我已经写了一篇关于高级C++概念的文章，包括CRTP。</li></ul><h1 id="f8f5" class="lu lv in bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">复合设计模式的好处</h1><ol class=""><li id="c5bd" class="lb lc in jx b jy mx kc my kg mz kk na ko nb ks lg lh li lj bi translated">通过消除同构对象集合上的许多循环来降低代码复杂性。</li><li id="5d6d" class="lb lc in jx b jy lk kc ll kg lm kk ln ko lo ks lg lh li lj bi translated">这个实习生增加了代码的可维护性和可测试性，减少了破坏现有运行和测试代码的机会。</li><li id="6643" class="lb lc in jx b jy lk kc ll kg lm kk ln ko lo ks lg lh li lj bi translated">复合设计模式中描述的关系不是子类关系，而是集合关系。这意味着客户端/API用户不需要关心操作(如平移、旋转、缩放、绘图等)。)无论是单个<a class="ae kt" href="http://www.vishalchovatiya.com/inside-the-cpp-object-model/" rel="noopener ugc nofollow" target="_blank">对象</a>还是整个集合。</li></ol><h1 id="f858" class="lu lv in bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">常见问题汇总</h1><p id="caf5" class="pw-post-body-paragraph jv jw in jx b jy mx ka kb kc my ke kf kg nm ki kj kk nn km kn ko no kq kr ks ig bi translated"><strong class="jx io">我什么时候应该使用复合设计模式？</strong></p><p id="bcb3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">—您希望客户端能够忽略对象组和单个对象之间的差异。<br/> —当你发现你以同样的方式使用多个对象，并循环执行有点类似的动作时，那么复合是一个不错的选择。</p><p id="f963" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">复合设计模式的常见例子是什么？</strong></p><p id="e695" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">— File &amp; Folder(文件集合):这里File是一个单独的类。文件夹继承文件并保存文件集合。</p><p id="a0b8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">Decorator&amp;复合设计模式有什么区别？</strong></p><p id="9d8f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">—装饰者致力于增强界面。<br/> —组合用于统一单个&amp;对象组的接口。</p></div></div>    
</body>
</html>