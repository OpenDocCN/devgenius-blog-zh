<html>
<head>
<title>Your API is not RESTful: let me tell you why</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你的 API 不是 RESTful 的:让我告诉你为什么</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/your-api-is-not-restful-let-me-tell-you-why-98b32e9fdaa9?source=collection_archive---------0-----------------------#2022-08-25">https://blog.devgenius.io/your-api-is-not-restful-let-me-tell-you-why-98b32e9fdaa9?source=collection_archive---------0-----------------------#2022-08-25</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="0f6a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">REST 是<strong class="jm io">表象状态转移</strong>的缩写。REST 是一个软件架构，它有一些最佳实践，由<a class="ae ki" href="https://en.wikipedia.org/wiki/Roy_Fielding" rel="noopener ugc nofollow" target="_blank"> Roy T. Fielding </a>定义，用于创建 web 应用程序。</p><p id="54e9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">随着 web 服务的发展和 REST 的流行，我越来越多地听到开发人员说他们的 API 是 RESTful 的。</p><p id="779c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是他们是对的吗？他们的 API 是否遵循了 RESTful 所需的所有限制？</p><p id="57a6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">简短的回答是:<em class="kj">大概不是</em>。为了理解我为什么这样想，让我们先熟悉一些概念，然后你可以让我知道你是否同意我的观点。</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi kk"><img src="../Images/ddde3798919d2de6ddbcff2e9ff9ba29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_9dfjDwckxNtenFM"/></div></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">你看了标题后😅|照片由<a class="ae ki" href="https://unsplash.com/@lazizli?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">拉拉·阿兹利</a>在<a class="ae ki" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="1309" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">什么是宁静</h1><p id="cd84" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">与许多人认为的相反，<strong class="jm io"> REST 不一定是一种通信协议。</strong></p><p id="20d5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">由 Roy T. Fielding 在他的博士论文中创建，REST 是一种架构风格，换句话说，是在创建 web 服务的过程中必须遵循的一系列限制。</p><p id="e604" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">RESTful 将会是符合 Roy 定义的所有约束的 API。</p><p id="7e35" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这也是大多数 RESTful APIs 失败的地方，因为它们很难遵守所有这些约束，它们有不同的成熟度，我们将在后面讨论。</p><h2 id="6c58" class="md lb in bd lc me mf dn lg mg mh dp lk jv mi mj lo jz mk ml ls kd mm mn lw mo bi translated">RESTful API 的限制</h2><p id="0ff9" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">一个 API 成为 RESTful 的主要标准是:</p><ul class=""><li id="f812" class="mp mq in jm b jn jo jr js jv mr jz ms kd mt kh mu mv mw mx bi translated">统一界面</li><li id="68b2" class="mp mq in jm b jn my jr mz jv na jz nb kd nc kh mu mv mw mx bi translated">无国籍的</li><li id="ddab" class="mp mq in jm b jn my jr mz jv na jz nb kd nc kh mu mv mw mx bi translated">可缓冲的</li><li id="31af" class="mp mq in jm b jn my jr mz jv na jz nb kd nc kh mu mv mw mx bi translated">客户端-服务器</li><li id="ac54" class="mp mq in jm b jn my jr mz jv na jz nb kd nc kh mu mv mw mx bi translated">分层系统</li></ul><p id="f440" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果不遵循所有这些约束，您的 API 将不是 RESTful 的，它将只是 HTTP 协议之上的另一个 RPC 实现。</p><p id="cc19" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在所有这些约束中，有一个通常最少被满足的约束，即<strong class="jm io">统一接口</strong>。但是，这意味着什么呢？</p><p id="4079" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">实现统一接口意味着满足四个标准:</p><ul class=""><li id="0ba6" class="mp mq in jm b jn jo jr js jv mr jz ms kd mt kh mu mv mw mx bi translated"><strong class="jm io">基于资源:</strong>与常见的 RPC 相反，REST 试图处理资源而不是方法。如果你通过调用<code class="fe nd ne nf ng b">/posts/create?title=lorem</code>创建一篇文章，由于 url 中的方法处理，你<strong class="jm io">没有遵循 REST 模式</strong>。在这个场景中，您应该理想地对<code class="fe nd ne nf ng b">/post</code>路由进行 POST 调用。</li><li id="3c38" class="mp mq in jm b jn my jr mz jv na jz nb kd nc kh mu mv mw mx bi translated"><strong class="jm io">通过表示操纵资源:</strong>客户端通过表示(JSON、XML 等)访问资源。)包含足够的信息来在服务器上操作它，只要它有权限这样做。</li><li id="8a1a" class="mp mq in jm b jn my jr mz jv na jz nb kd nc kh mu mv mw mx bi translated"><strong class="jm io">自描述性消息:</strong>回复是自描述性的，包括足够的信息让客户知道如何使用它们。例如，使用 HTTP，您需要在头中包含一个 Content-Type 属性来描述所使用的表示类型。</li><li id="a41c" class="mp mq in jm b jn my jr mz jv na jz nb kd nc kh mu mv mw mx bi translated">超媒体作为应用状态的引擎(<strong class="jm io"> HATEOAS </strong>)。</li></ul><h2 id="63fe" class="md lb in bd lc me mf dn lg mg mh dp lk jv mi mj lo jz mk ml ls kd mm mn lw mo bi translated">HATEOAS 到底是什么意思？</h2><p id="1557" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">这是棘手的部分。很少有 API 能够适应的限制。“<strong class="jm io"> HATEOAS </strong>的意思表示与我们接下来要谈论的东西<strong class="jm io">万维网</strong>有许多相似之处。</p><p id="887d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">注意，对互联网上的网页的探索是在我们称之为“<em class="kj">路径</em>中完成的，我们有一个起点，从那里我们找到其他页面。</p><p id="7032" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">同样的逻辑也适用于 RESTful APIs。基本上，<strong class="jm io">你的 API 应该是一本打开的书</strong>，你不需要访问文档就知道，要添加一个用户到集合中，你需要一个对 URL /users 的 POST 请求。</p><p id="4a1c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">您应该能够通过 API 本身发现所有的资源操作。</strong></p><p id="3074" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你知道哪些 API 可以做到这一点？只需知道初始域(起点)和协议，您就可以使用哪些？</p><p id="22b2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">拥有列出所有可用资源和操作的文档并不是问题，问题是当向 API 的根发出请求时，您没有获得必要的超链接，这阻碍了我对数据和功能的探索。</p><p id="2c4b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">换句话说，这表明:<strong class="jm io">您的 API 可能不是 RESTful 的。</strong>这样就可以了。</p><h1 id="f38b" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">那么，REST 和 RESTful 有什么区别呢？</h1><p id="1cf0" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">如前所述，要让一个 API 被称为 RESTful，它需要一些特定的属性。</p><p id="1bc9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">所以 REST 和 RESTful APIs 之间的区别只是满足架构需求。</strong></p><p id="15b9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们可以说表述性状态转移(REST)是万维网架构的抽象。它是一种架构风格，由应用于系统中的组件、连接器和数据元素的一组协调的约束组成。</p><p id="5a24" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">REST 忽略了组件实现细节和协议语法，以便专注于组件的角色、它们与其他组件的交互约束以及它们对有意义的数据元素的解释。</p><h1 id="1176" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">互联网起源</h1><p id="70f0" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">蒂姆·伯纳斯·李(T21)说，“让万维网存在吧”。</p><p id="9feb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">那是 1989 年，虽然互联网已经存在，但它的潜力还没有被开发出来。</p><p id="c542" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后，万维网(T1)诞生了，这是一个信息系统，除了带来资源的唯一标识(统一资源定位符——URL)之外，还可以通过超级文本(T2)将它们联系起来。</p><p id="bc40" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">网络上可用的资源可以是任何媒体类型，然而，所谓的<em class="kj">网页</em>是以一种特定的格式编写的:<strong class="jm io">超文本标记语言</strong> (HTML)，这种标记语言能够通过超链接将不同的页面连接起来，从而在互联网上创建真正的网页。</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/131b70016c9cb286be5161c4164e2778.png" data-original-src="https://miro.medium.com/v2/resize:fit:992/0*2EjQz6KZRl7BiBmJ.gif"/></div></figure><p id="1c89" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是，要使这一切工作，需要一个通信协议。</p><p id="736c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这就是今天众所周知的超文本传输协议(HTTP)出现的时候。</p><p id="2247" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有趣的是，在当时，它只用于传输 HTML。和今天很不一样，不是吗？</p><p id="7f17" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在那之前，其他通信协议用于通过<strong class="jm io">远程过程调用</strong> (RPC)传输不同类型的数据，其中从其他机器请求服务，以便获得网络上的一些资源，而不必知道该网络的细节。</p><p id="c29a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">1998 年，Dave Winer 决定将网络与现有的服务结合起来，创建了网络服务。第一个是 XML-RPC。</p><h1 id="7111" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">什么是 web 服务，它是如何工作的？</h1><p id="549f" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">web 服务是一种允许应用程序之间独立通信的技术，不依赖于语言或操作系统。</p><p id="3ee9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">通常，这种通信是通过 XML 格式的文件进行的。因此，不管语言是什么，一切都被翻译成 XML。其中之一是 XML-RPC，它创建于 HTTP 协议之上。</p><p id="8a82" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">过了一段时间，XML-RPC 被洗礼成了另一个名字:<strong class="jm io">简单对象访问协议</strong> (SOAP)。</p><p id="36e9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后，它被归类为一种通信协议，在其较低级别的协议中使用 HTTP。</p><p id="6562" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">该协议在向利益相关者公开数据的能力方面非常强大。但是，尽管有它的名字，它一点也不简单。</p><p id="1c39" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> SOAP </strong>很快成为行业标准，并被大多数组织所使用。</p><p id="45b9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是，我们需要更好、更简单的解决方案。这就是 Web <strong class="jm io"> A </strong>应用<strong class="jm io"> P </strong>编程<strong class="jm io"> I </strong>接口(API)和<strong class="jm io"> Re </strong>表示<strong class="jm io">S</strong>state<strong class="jm io">T</strong>transfer(REST)出现的原因。</p><p id="c49f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">上下文明白了吗？现在跟我来看这篇文章的<strong class="jm io">转折。</strong></p><h1 id="ec0f" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">休息模式并不总是重要的</h1><p id="0a97" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">你的 API 是否 RESTful 并不重要。像大多数架构决策一样，他们并不总是以最好的方式解决问题。</p><p id="c3f9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">也许你正在开发一个<strong class="jm io">内部 API </strong>，在这里你可以控制客户端和服务器。在这种情况下，发现部分可能不会带来同样多的回报。</p><p id="089f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">决定权在你。</strong>在<strong class="jm io"> REST 架构</strong>中仍有许多东西可以利用，尽管你的 API 可能无法满足所有需求，但它可能在许多方面是兼容的，这里我们进入了一个叫做<em class="kj"> Richardson 成熟度模型</em>的东西。</p><h1 id="4cee" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">理查森成熟度模型</h1><p id="a997" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">正如我之前说过的，相对于 REST 架构最重要的规则，API 有不同的成熟度等级。</p><p id="f0cd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有一个简单的方法来定义这个级别:Richardson 成熟度模型。</p><p id="7b58" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这种方法预先假设了一些限制，因为其中一些是 web 架构所固有的，但是它仍然是对 API 进行分类的良好基础。</p><p id="f9ca" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">该模型有 4 个成熟度级别(0 是不符合任何规则的 API)，其他 3 个是:</p><ul class=""><li id="e23c" class="mp mq in jm b jn jo jr js jv mr jz ms kd mt kh mu mv mw mx bi translated"><strong class="jm io">资源:</strong>从那时起，可以在不同的端点上请求不同的资源。而不需要查询参数。</li><li id="654e" class="mp mq in jm b jn my jr mz jv na jz nb kd nc kh mu mv mw mx bi translated"><strong class="jm io"> HTTP 动词:</strong>在这里，<strong class="jm io">不同的 HTTP 方法</strong>被付诸实践，与 SOAP 协议中几乎独占使用 POST 相反。此外，每个动词都有其特定的效用:<strong class="jm io"> PUT </strong>用于更新，<strong class="jm io"> DELETE </strong>用于删除，<strong class="jm io"> GET </strong>用于获取，<strong class="jm io"> POST </strong>用于创建。在某些情况下，还会使用<strong class="jm io">补丁</strong>。</li><li id="51b3" class="mp mq in jm b jn my jr mz jv na jz nb kd nc kh mu mv mw mx bi translated"><strong class="jm io">超媒体:</strong>资源开始具有到相关资源的链接，以及在这些集合之上执行动作的链接，从这一点开始，API 自文档化并启用发现功能。</li></ul><p id="8484" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">每个级别都是下一个级别的条件，也就是说，API 要达到级别 3，必须先达到级别 2 和级别 1。您可以点击<a class="ae ki" href="https://martinfowler.com/articles/richardsonMaturityModel.html" rel="noopener ugc nofollow" target="_blank">此处</a>了解更多关于理查森成熟度模型的信息。</p><h1 id="5872" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">结论</h1><p id="b550" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">今天到此为止。我希望您理解我为什么为本文选择这个标题，以及为什么 RESTful 并不总是您的 API 所必须的。</p><p id="fe96" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">感谢阅读！在本平台关注我，阅读更多编程内容。祝您愉快，再见！👋</p></div></div>    
</body>
</html>