<html>
<head>
<title>Sample SpringBoot application on Knative — A Serverless platform</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Knative上的SpringBoot示例应用程序——一个无服务器平台</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/sample-springboot-application-on-knative-a-serverless-platform-33a4ed0f6551?source=collection_archive---------6-----------------------#2022-01-04">https://blog.devgenius.io/sample-springboot-application-on-knative-a-serverless-platform-33a4ed0f6551?source=collection_archive---------6-----------------------#2022-01-04</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/b0b90780e14d8a2755f655d037f5e4db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fDd29UAUexzqd9l_Q41HGA.png"/></div></div></figure><div class=""/><p id="86dc" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">今天我将解释一些有趣的话题“kna tive”——无服务器架构，以及我们如何在一个简单的SpringBoot应用程序中利用它。我不会讨论Knative的所有细节，但会集中讨论它的一些特性，以及我们如何在应用程序中简单地利用这些特性。</p><p id="4a15" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Knative无服务器环境帮助您将代码部署到Kubernetes。它为您提供了灵活性，在您的服务未被使用之前，不会消耗任何资源。基本上，你的代码只有在被消费的时候才会运行。有关Knative的更多详情，请参见下面的官方链接。</p><p id="0a55" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae kt" href="https://knative.dev/docs/" rel="noopener ugc nofollow" target="_blank">首页— Knative </a></p><p id="39a6" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们开始演示吧，这样我们会有一些真实的想法。虽然你可以找到几个样本，代码Knative与跳羚和Kubernetes。但是在这里，我试图用SpringBoot和Kubernetes集群来解释Knative的一些基本的和工作的例子。此外，尝试触及一些有趣的功能，如“缩放至零”、“自动缩放”、“修订”、“流量分配”等。</p><p id="b1c2" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">出于真正的演示目的，我将使用一个公开REST API并连接到mongo数据库的Spring Boot应用程序。这是一个非常简单的应用程序，部署在Kubernetes集群上</p><p id="d8ed" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">先决条件:</strong></p><p id="e42f" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">由于我用的笔记本电脑都是Windows 10，所以一些必备链接都是和Windows 10有关的。但是有些链接是通用的，你可以在你的Linux / Mac系统中使用它们。对于某些先决条件，您不必使用这些工具集。您也可以使用自己的工具集。如果你想使用我在这里提到的工具集，那也没问题。</p><p id="8ba3" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz"> Docker桌面:</strong></p><p id="1607" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae kt" href="https://docs.docker.com/desktop/windows/install/" rel="noopener ugc nofollow" target="_blank">在Windows上安装Docker桌面| Docker文档</a></p><p id="faa3" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">迷你库贝:</strong></p><p id="5786" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae kt" href="https://minikube.sigs.k8s.io/docs/start/" rel="noopener ugc nofollow" target="_blank">minikube start | minikube(k8s . io)</a></p><p id="db54" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz"> kubectl cli: </strong></p><p id="71ae" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae kt" href="https://kubernetes.io/docs/tasks/tools/" rel="noopener ugc nofollow" target="_blank">安装工具| Kubernetes </a></p><p id="2130" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">用于自动化的ska fold CLI:</p><p id="0288" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae kt" href="https://skaffold.dev/docs/install/" rel="noopener ugc nofollow" target="_blank">安装斯卡福德|斯卡福德</a></p><p id="8ef5" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">负载测试用JMeter:</strong></p><p id="3c4c" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae kt" href="https://jmeter.apache.org/" rel="noopener ugc nofollow" target="_blank">阿帕奇JMeter —阿帕奇JMeter</a></p><p id="4e34" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">Windows上的常用命令行界面:</strong></p><p id="63d1" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae kt" href="https://docs.openshift.com/container-platform/4.9/serverless/cli_tools/installing-kn.html" rel="noopener ugc nofollow" target="_blank">安装Knative CLI — CLI工具|无服务器| OpenShift容器平台4.9 </a></p><p id="d62d" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">在Kubernetes上安装Knative Serving:</strong></p><p id="0421" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在我们开始将SpringBoot应用程序部署到K8s集群并利用Knative特性之前，让我们在minikube集群中启用Knative服务组件。我们可以通过多种方式在集群中安装和配置Knative服务组件。请查看以下链接了解更多详情。</p><p id="42d0" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae kt" href="https://knative.dev/docs/getting-started/" rel="noopener ugc nofollow" target="_blank"> Knative快速入门— Knative </a></p><p id="66de" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我按照下面的步骤在我的终端安装了Knative Serving。在本文中，我只关注Knative服务组件。</p><p id="ee3d" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">启动Minikube: </strong></p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="5b28" class="ld le iy kz b gy lf lg l lh li">minikube start</span></pre><p id="0e68" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">(如果minikube的旧实例出现问题，您可以使用“minikube delete”删除minikube，并使用minikube start启动新集群)。</p><p id="2847" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">minikube成功启动后，打开另一个终端。请在该终端上执行命令“minikube tunnel ”,以便我们能够将外部IP用于kourier负载平衡器服务。</p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="9ce7" class="ld le iy kz b gy lf lg l lh li">minikube tunnel</span></pre><p id="8f85" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">Knative Serving的安装和配置:</strong></p><p id="94d1" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">1.选择要安装的Knative服务版本。我用的是1.0.0版本。</p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="3791" class="ld le iy kz b gy lf lg l lh li">export KNATIVE_VERSION=”1.0.0"</span></pre><p id="6863" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">2.在命名空间knative-serving中安装Knative Serving。安装Knative Service CRDs需要以下命令。</p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="ab29" class="ld le iy kz b gy lf lg l lh li">kubectl apply -f <a class="ae kt" href="https://github.com/knative/serving/releases/download/knative-v$%7BKNATIVE_VERSION%7D/serving-crds.yaml" rel="noopener ugc nofollow" target="_blank">https://github.com/knative/serving/releases/download/knative-v${KNATIVE_VERSION}/serving-crds.yaml</a></span></pre><p id="f89b" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">请确保满足所有CRD的所有条件。</p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="273d" class="ld le iy kz b gy lf lg l lh li">kubectl wait — for=condition=Established — all crd</span></pre><p id="1377" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">3.安装活动服务核心对象需要以下命令。</p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="7e99" class="ld le iy kz b gy lf lg l lh li">kubectl apply -f <a class="ae kt" href="https://github.com/knative/serving/releases/download/knative-v$%7bKNATIVE_VERSION%7d/serving-core.yaml" rel="noopener ugc nofollow" target="_blank">https://github.com/knative/serving/releases/download/knative-v${KNATIVE_VERSION}/serving-core.yaml</a></span></pre><p id="bb92" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">请确保满足所有条件。</p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="0e4f" class="ld le iy kz b gy lf lg l lh li">kubectl wait pod — timeout=-1s — for=condition=Ready -l ‘!job-name’ -n knative-serving &gt; /dev/null</span></pre><p id="99b2" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">4.选择要安装的Knative Net Kourier版本。对于这个例子，我使用的是版本1.0.0。</p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="894b" class="ld le iy kz b gy lf lg l lh li">export KNATIVE_NET_KOURIER_VERSION=”1.0.0"</span></pre><p id="7df6" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">5.在命名空间kourier-system中安装活动层kourier</p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="594e" class="ld le iy kz b gy lf lg l lh li">kubectl apply -f <a class="ae kt" href="https://github.com/knative/net-kourier/releases/download/knative-v$%7bKNATIVE_NET_KOURIER_VERSION%7d/kourier.yaml" rel="noopener ugc nofollow" target="_blank">https://github.com/knative/net-kourier/releases/download/knative-v${KNATIVE_NET_KOURIER_VERSION}/kourier.yaml</a></span></pre><p id="c42f" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">请确保满足所有条件。</p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="6829" class="ld le iy kz b gy lf lg l lh li">kubectl wait pod — timeout=-1s — for=condition=Ready -l ‘!job-name’ -n kourier-system</span><span id="75a0" class="ld le iy kz b gy lj lg l lh li">kubectl wait pod — timeout=-1s — for=condition=Ready -l ‘!job-name’ -n knative-serving</span></pre><p id="f3c3" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">6.让我们将环境变量EXTERNAL_IP设置为minikube集群的Worker节点的外部IP地址。</p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="738a" class="ld le iy kz b gy lf lg l lh li">EXTERNAL_IP=$(kubectl -n kourier-system get service kourier -o jsonpath=’{.status.loadBalancer.ingress[0].ip}’)</span><span id="1ef4" class="ld le iy kz b gy lj lg l lh li">echo EXTERNAL_IP=$EXTERNAL_IP</span></pre><p id="5465" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">7.让我们使用nip.io将环境变量KNATIVE_DOMAIN设置为DNS域</p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="4bc6" class="ld le iy kz b gy lf lg l lh li">KNATIVE_DOMAIN=”$EXTERNAL_IP.nip.io”</span><span id="9878" class="ld le iy kz b gy lj lg l lh li">echo KNATIVE_DOMAIN=$KNATIVE_DOMAIN</span></pre><p id="9b7a" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">请执行以下命令，以检查DNS是否正确解析。</p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="f78a" class="ld le iy kz b gy lf lg l lh li">dig $KNATIVE_DOMAIN</span></pre><p id="e73a" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">8.下一步是为被动服务配置DNS。</p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="0f16" class="ld le iy kz b gy lf lg l lh li">kubectl patch configmap -n knative-serving config-domain -p “{\”data\”: {\”$KNATIVE_DOMAIN\”: \”\”}}”</span></pre><p id="2f9c" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">9.现在我们需要配置Knative来使用Kourier。</p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="93c4" class="ld le iy kz b gy lf lg l lh li">kubectl patch configmap/config-network \<br/> — namespace knative-serving \<br/> — type merge \<br/> — patch ‘{“data”:{“ingress.class”:”kourier.ingress.networking.knative.dev”}}’</span></pre><p id="4e3f" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">10.验证Knative是否正确安装，所有pod是否都应处于运行状态，以及我们的kourier服务是否正确配置。在我的例子&lt; 127.0.0.1 &gt;中，它应该被分配一个外部IP。</p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="1510" class="ld le iy kz b gy lf lg l lh li"> kubectl get pods -n knative-serving<br/> kubectl get pods -n kourier-system<br/> kubectl get svc -n kourier-system</span></pre><figure class="ku kv kw kx gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi lk"><img src="../Images/71c870c875b4893ad9c75aac13eac53c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i5CpCUh_1C7FbnYJJ_uXZg.png"/></div></div></figure><figure class="ku kv kw kx gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi lk"><img src="../Images/9f66b039b1daf94699ebbf45521aedc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4cHnbzZ_5OB8Bshpqb2SRQ.png"/></div></div></figure><figure class="ku kv kw kx gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi lk"><img src="../Images/8b4eaa10b3a21dbf82cda3c113e8e061.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*00pxHKEokIf0k4RILj4Abw.png"/></div></div></figure><p id="ab47" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">将SpringBoot应用程序部署到Kubernetes集群。</strong></p><p id="13b8" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们已经准备好了环境。现在是时候部署应用程序并查看操作了。我们可以使用Knative CLI (kn)来管理和部署Knative上的应用程序。在本例中，我们将使用YAML清单进行部署。但是有时我们利用Knative CLI (kn)来检查和管理我们的Knative服务。</p><p id="2641" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们看看我们的应用程序代码，以及如何使用scaffold和利用Knative特性将该应用程序部署到K8s集群。</p><p id="4aaa" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因为我已经提到我们的应用程序是一个简单的Spring Boot REST应用程序，它有一个数据库连接。为了简单起见，我们使用了Mongo数据库，它在示例K8s集群中运行。下面是我们模型类的代码片段。这个模型类正在使用Mongo数据库中的“employee”集合。</p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="09d7" class="ld le iy kz b gy lf lg l lh li">@Document(collection = “employee”)<br/> @Getter<br/> @Setter<br/> @AllArgsConstructor<br/> @NoArgsConstructor</span><span id="37d4" class="ld le iy kz b gy lj lg l lh li">public class Employee {</span><span id="d775" class="ld le iy kz b gy lj lg l lh li">@Id<br/> private String id;<br/> private String firstName;<br/> private String lastName;<br/> private int age;<br/> private String address;</span><span id="d1ce" class="ld le iy kz b gy lj lg l lh li">}</span></pre><p id="37a5" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对于数据库集成，我们在应用程序中使用简单的Spring数据MongoDB。</p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="8f6f" class="ld le iy kz b gy lf lg l lh li">public interface EmployeeRepository extends CrudRepository &lt;Employee, String&gt;{</span><span id="297f" class="ld le iy kz b gy lj lg l lh li">Set&lt;Employee&gt; findByFirstNameAndLastName(String firstName, String lastName);<br/> Set&lt;Employee&gt; findByAge(int age);</span><span id="b600" class="ld le iy kz b gy lj lg l lh li">}</span></pre><p id="5459" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在本例中，REST端点仅用于保存和搜索雇员。任何人都可以为删除、更新等其他操作增强端点。下面是与端点关联的控制器类。</p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="bbbd" class="ld le iy kz b gy lf lg l lh li">@RestController<br/> @RequestMapping(“/employee”)</span><span id="226a" class="ld le iy kz b gy lj lg l lh li">public class EmployeeController {</span><span id="b7f8" class="ld le iy kz b gy lj lg l lh li">@Autowired<br/> private EmployeeService employeeService;</span><span id="0c5d" class="ld le iy kz b gy lj lg l lh li">@GetMapping(“/getEmployeeById”)<br/> public Optional&lt;Employee&gt; getEmployeeById(@RequestParam(“id”) String id){</span><span id="973b" class="ld le iy kz b gy lj lg l lh li">return employeeService.getEmployeeById(id);</span><span id="3e64" class="ld le iy kz b gy lj lg l lh li">}</span><span id="2121" class="ld le iy kz b gy lj lg l lh li">@PostMapping(“/saveEmployee”)<br/> public Employee saveEmployee(@RequestBody Employee employee){</span><span id="e170" class="ld le iy kz b gy lj lg l lh li">return employeeService.saveEmployee(employee);</span><span id="68a3" class="ld le iy kz b gy lj lg l lh li">}</span><span id="2e2b" class="ld le iy kz b gy lj lg l lh li">@GetMapping(“/getEmployeeByAge”)<br/> public Set&lt;Employee&gt; findByAge(@RequestParam(“age”) int age) {</span><span id="086e" class="ld le iy kz b gy lj lg l lh li">return employeeService.getEmployeeByAge(age);</span><span id="0a10" class="ld le iy kz b gy lj lg l lh li">}</span><span id="13d8" class="ld le iy kz b gy lj lg l lh li">@GetMapping(“/getAllEmployee”)<br/> public Iterable&lt;Employee&gt; findAll() {</span><span id="eefe" class="ld le iy kz b gy lj lg l lh li">return employeeService.getAllEmployee();</span><span id="df8a" class="ld le iy kz b gy lj lg l lh li">}</span><span id="4a5a" class="ld le iy kz b gy lj lg l lh li">}</span></pre><p id="f1a5" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下面是“application.yaml”文件的详细信息，我们在该文件中使用环境变量声明了数据库连接设置和凭据。</p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="cd92" class="ld le iy kz b gy lf lg l lh li">server:<br/>  port: 8096<br/>spring:<br/>  application:<br/>    name: springboot-knative-demo<br/>  data:<br/>    mongodb:<br/>      host: mongodb<br/>      port: 27017<br/>      username: ${MONGO_USERNAME}<br/>      password: ${MONGO_PASSWORD}<br/>      database: ${MONGO_DATABASE}<br/>      authentication-database: admin</span></pre><p id="7e2c" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">知识服务定义:</strong></p><p id="04df" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们已经完成了应用程序代码片段。让我们从无效服务定义YAML文件开始。它是主配置文件，您可以在其中定义您的服务定义。您还可以在此配置文件中定义自动缩放策略、流量、版本等。</p><p id="46ab" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Knative Serving为应用程序提供自动缩放，或<em class="ll">自动缩放</em>，以匹配传入的需求。这是默认情况下使用Knative Pod自动缩放器(KPA)提供的。您可以通过简单地使用注释来实现自动缩放。这里我们使用了注释‘auto scaling . knative . dev/target’。我们将该值设置为15(在任何给定时间，应用程序的每个副本可以处理的并发请求数)。请在给定的链接上查看有关Knative Serving autoscaling的更多详细信息。</p><p id="35ec" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae kt" href="https://knative.dev/docs/serving/autoscaling/" rel="noopener ugc nofollow" target="_blank">关于自动缩放— Knative </a></p><p id="c38e" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们还为数据库连接细节使用了Secret和ConfigMap。因为我们在将MongoDB部署到集群的过程中使用了ConfigMap和Secret。</p><p id="eed7" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">以下是无效服务定义文件。</p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="9adc" class="ld le iy kz b gy lf lg l lh li">apiVersion: serving.knative.dev/v1<br/>kind: Service<br/>metadata:<br/>  name: springboot-knative-demo<br/>spec:<br/>  template:<br/>    metadata:<br/>      annotations:<br/>        autoscaling.knative.dev/target: "15"<br/>      # This is the name of our new "Revision," it must follow the convention {service-name}-{revision-name}<br/>      name: springboot-knative-demo-final<br/>    spec:<br/>      containers:<br/>        - image: dockertestbaby/springboot-knative-demo<br/>          ports:<br/>            - containerPort: 8096<br/>          env:<br/>            - name: MONGO_DATABASE<br/>              valueFrom:<br/>                configMapKeyRef:<br/>                  name: mongodb<br/>                  key: database-name<br/>            - name: MONGO_USERNAME<br/>              valueFrom:<br/>                secretKeyRef:<br/>                  name: mongodb<br/>                  key: database-user<br/>            - name: MONGO_PASSWORD<br/>              valueFrom:<br/>                secretKeyRef:<br/>                  name: mongodb<br/>                  key: database-password<br/>  traffic:<br/>  - latestRevision: true<br/>    percent: 60<br/>  - revisionName: springboot-knative-demo-rev2<br/>    percent: 20<br/>  - revisionName: springboot-knative-demo-rev1<br/>    percent: 20</span></pre><p id="a478" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">用于部署的Skaffold配置</strong></p><p id="5afc" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里我们将使用Skaffold来实现部署的自动化。Skaffold是一个命令行工具，支持Kubernetes本地应用程序的持续开发。对于构建阶段，Skaffold支持不同的工具，如Dockerfile、Jib插件、云原生构建包等。在我们的演示中，我们将在构建阶段使用一个简单的docker文件。</p><p id="2edd" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">请查看位于项目根目录下的skaffold.yaml文件。想了解更多关于斯卡福德的信息，你可以点击下面的链接。</p><p id="6281" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae kt" href="https://skaffold.dev/docs/install/" rel="noopener ugc nofollow" target="_blank">安装斯卡福德|斯卡福德</a></p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="97a6" class="ld le iy kz b gy lf lg l lh li">apiVersion: skaffold/v2beta22<br/>kind: Config<br/>metadata:<br/>  name: springboot-knative-demo<br/>build:<br/>  artifacts:<br/>  - image: dockertestbaby/springboot-knative-demo<br/>  local:<br/>    push: true<br/>deploy:<br/>  kubectl:<br/>    manifests:<br/>    - kubernetes/mongodb-deployment.yaml<br/>    - kubernetes/app-knative-service.yaml</span></pre><p id="4d46" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下面是我们的应用程序的docker文件，Skaffold将使用这个docker文件来构建容器映像。</p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="9091" class="ld le iy kz b gy lf lg l lh li"> FROM openjdk:11.0.7-jre-slim-buster<br/> ARG JAR_FILE=target/*.jar<br/> COPY ${JAR_FILE} app.jar<br/> ENTRYPOINT [“java”,”-jar”,”/app.jar”]</span></pre><p id="63b5" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们可以开始部署我们的应用程序了。让我们执行命令“skaffold run”。它将构建我们的应用程序，创建并推送Docker映像，最后在Knative服务定义文件的帮助下将应用程序部署到Knative。</p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="b4fa" class="ld le iy kz b gy lf lg l lh li">skaffold run</span></pre><figure class="ku kv kw kx gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi lk"><img src="../Images/e8e5c79373112af7253185b16587671b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0CG72ViZTBvnaBqw1neynA.png"/></div></div></figure><p id="d1a7" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">部署验证:</strong></p><p id="a88d" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">是时候验证我们的部署了。让我们使用Knative CLI进行验证。请执行“kn服务列表”命令。您可以看到名为“springboot-knative-demo”的单一Knative服务。</p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="b2ce" class="ld le iy kz b gy lf lg l lh li">kn service list</span></pre><figure class="ku kv kw kx gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi lk"><img src="../Images/ee469a7b50aac58deefbb32634f48f4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*01BWFs6bmBSFa6JFoTK2aw.png"/></div></div></figure><p id="4baf" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们对我们的应用程序进行更多的修改。为此，我们需要改变我们的代码(关于不同的修订)。这里我创建了3个版本，它们指向同一个服务。在对你的源代码做了必要的修改后，你只需要执行‘ska fold run’。最终的源代码已经有了所有的修改。对于我们的例子，您需要从“rev1”、“rev2”开始，最后是“最终”版本。</p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="87de" class="ld le iy kz b gy lf lg l lh li">kn revision list</span></pre><figure class="ku kv kw kx gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi lk"><img src="../Images/63b61566a0ed312737a9d257c38f558c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7NA2RJhMSAC8-NfHcU2rMw.png"/></div></div></figure><p id="7476" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">另一个重要的特性是在多个版本之间划分流量。这是非常重要的，当你将处理蓝绿色，金丝雀部署。</p><p id="e5ce" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们看看在不同版本之间分配流量有多容易。为此，我们需要添加“交通”标签。我们可以定义分配给特定版本的负载百分比。在这里，我们将60%分配给最终版本，20%分配给版本2，20%分配给版本1。下面是代码片段。</p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="8aae" class="ld le iy kz b gy lf lg l lh li">apiVersion: serving.knative.dev/v1<br/>kind: Service<br/>metadata:<br/>  name: springboot-knative-demo<br/>spec:<br/>  template:<br/>    .<br/>    .<br/>    .<br/>    .<br/>  traffic:<br/>  - latestRevision: true<br/>    percent: 60<br/>  - revisionName: springboot-knative-demo-rev2<br/>    percent: 20<br/>  - revisionName: springboot-knative-demo-rev1<br/>    percent: 20</span></pre><p id="cb0e" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">让我们实现自动缩放和缩放到零:</strong></p><p id="6546" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">正如我们所知，Knative支持自动伸缩的默认“并发”目标，我们需要对我们的服务执行一些特定的加载，以便实现Knative服务的自动伸缩机制。</p><p id="0335" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们已经将并发目标级别设置为15。为了给我们的服务生成高负载/流量，我们可以使用不同的负载测试工具。在这个例子中，我们将使用JMeter向我们的服务发送一个并发请求。例如，我们将在JMeter中使用以下参数发送请求(用户数量= 50，上升周期= 2s，循环计数= 50)。</p><p id="32a7" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">有关JMeter的更多信息，请参见以下链接:</p><p id="0dee" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae kt" href="https://jmeter.apache.org/" rel="noopener ugc nofollow" target="_blank">阿帕奇JMeter —阿帕奇JMeter</a></p><p id="975b" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">创建一个JMeter测试计划和线程组:</strong></p><figure class="ku kv kw kx gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi lk"><img src="../Images/d84b6beb714c1c8b0a72120b6175d5d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uRmYNp2jvTSj5gB-mkGrwQ.png"/></div></div></figure><p id="b086" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">创建一个简单的HTTP请求:</strong></p><p id="266b" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">具有“/employee/getAllEmployee”终结点的HTTP GET请求。</p><figure class="ku kv kw kx gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi lk"><img src="../Images/efe7e5bbcad6a5a9972bbf8c36f6faa0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pEa6omaMdpDsLFQ-XPil2w.png"/></div></div></figure><p id="fc99" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">执行请求:</strong></p><p id="d77b" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一旦我们执行了来自JMeter的HTTP GET请求，那么在后端我们可以看到，由于Knative服务的自动伸缩特性，已经创建了更多的pod。对于我们的例子——</p><p id="d359" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">3 pods正在进行最终修订，处理60%的流量。</p><p id="10d9" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">2个pod运行rev1修订版，处理20%的流量。</p><p id="a8a2" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">1个pod正在运行rev2修订版，该版本处理20%的流量。</p><figure class="ku kv kw kx gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi lk"><img src="../Images/b5afa446a2bfabff9d60493627d1d6a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f3EHfBvuUW-CLOmc9OtFhw.png"/></div></div></figure><figure class="ku kv kw kx gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi lk"><img src="../Images/e3bae9872b1fb99d09fabe444161e74f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ckCFbvLwx93E73BOxUu1bA.png"/></div></div></figure><p id="d183" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">有时，如果您执行命令“kubectl get deployments”，那么您可以找到负责服务流量的就绪部署。</p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="adf9" class="ld le iy kz b gy lf lg l lh li">kubectl get deployments</span></pre><figure class="ku kv kw kx gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi lk"><img src="../Images/ee013b83f5d83c057f862a33f8b0b599.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jz7nEIwlLLTDomz3upAY1g.png"/></div></div></figure><p id="bb7a" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">结果:</strong></p><p id="6064" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">成功执行上述请求后，结果应该如下所示。</p><figure class="ku kv kw kx gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi lk"><img src="../Images/4e3fcb4590d97c4a64a4b3d77ae1e922.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SZW3M_mXorD7VH5xpcVtPA.png"/></div></div></figure><p id="794b" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">太好了！！！我们已经很好地检查了自动缩放功能，现在让我们探索另一个漂亮的功能。<strong class="jx iz">“扩展到零”</strong>—Knative无服务器平台/架构最漂亮的特性之一。让我们看看当没有流量进入服务时Knative的行为。你不需要担心那个。Knative将检测是否没有流量进入服务，它会自动将运行的pod数量减少到零。</p><p id="5ca9" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们在空闲状态下等待几分钟，不要向我们的服务发送任何请求。现在你可以看到吊舱处于终止状态。</p><figure class="ku kv kw kx gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi lk"><img src="../Images/2f50afbd379e1c1152636547136db580.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wgirWaMUib7njJMIFfDwNw.png"/></div></div></figure><p id="f443" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">几秒钟后，您可以看到集群中没有与我们的服务相关的pod在运行。</p><figure class="ku kv kw kx gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi lk"><img src="../Images/a95bda63fd931c1fe9720e57fb689c76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1qjcZjQLECwQmrPZ-dYOzg.png"/></div></div></figure><figure class="ku kv kw kx gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi lk"><img src="../Images/219832d1de7f1e8c3ad2602468f531f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q38hsNK9TO1TiOYkomGpDw.png"/></div></div></figure><p id="768b" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">清理部署:</strong></p><p id="4620" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们已经完成了演示。现在，是时候从集群中清理部署了。同样很简单，只需运行“skaffold delete”即可。它将从集群中删除/清理所有资源。</p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="0058" class="ld le iy kz b gy lf lg l lh li">skaffold delete</span></pre><figure class="ku kv kw kx gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi lk"><img src="../Images/48166fb2245e20dee15b72f99350f950.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-bgw7k-BxUPJCLJUbK7gmQ.png"/></div></div></figure><p id="0635" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">源代码:</strong></p><p id="7bfc" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你正在考虑工作代码，那么我们开始吧。</p><div class="im in gp gr io lm"><a href="https://github.com/koushikmgithub/springboot-knative-demo.git" rel="noopener  ugc nofollow" target="_blank"><div class="ln ab fo"><div class="lo ab lp cl cj lq"><h2 class="bd iz gy z fp lr fr fs ls fu fw ix bi translated">GitHub-koushikmgithub/spring boot-knative-demo:带有knative和…</h2><div class="lt l"><h3 class="bd b gy z fp lr fr fs ls fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="lu l"><p class="bd b dl z fp lr fr fs ls fu fw dk translated">github.com</p></div></div><div class="lv l"><div class="lw l lx ly lz lv ma iu lm"/></div></div></a></div><p id="881b" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">上链:</strong></p><p id="024b" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">太好了！！！我们已经完成了这篇文章。希望你喜欢它！！！。在本文中，我试图展示我们如何使用Skaffold和Dockerfile将Spring Boot应用程序作为一个Knative服务部署到minikube Kubernetes集群。我还试图触及Knative Serving的一些有趣的特性——比如自动缩放、缩放到零、带有简单注释的流量分布。</p><p id="6b10" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">随时欢迎您的评论/建议！！！。</p></div></div>    
</body>
</html>