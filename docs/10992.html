<html>
<head>
<title>C++ Constructor Destructor</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C++构造函数析构函数</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/c-constructor-destructor-d1ba42e03f33?source=collection_archive---------10-----------------------#2022-12-12">https://blog.devgenius.io/c-constructor-destructor-d1ba42e03f33?source=collection_archive---------10-----------------------#2022-12-12</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/97bbba197edd8dad4a9bc94134b1e856.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dAvNWctDYRTrAHpVtmp5lg.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">Garvin St. Villier 摄</figcaption></figure><p id="aa29" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在本文中，我们将探讨面向对象编程中构造函数和析构函数的概念。这些特殊的方法分别用于初始化和清理对象，在确保程序正常运行方面起着至关重要的作用。我们将深入研究构造函数和析构函数是如何工作的，并提供它们在 Java 和 C++等常见编程语言中的用法示例。到本文结束时，您将对这些重要的概念有一个基本的了解，并且能够自信地将它们结合到您自己的程序中。</p><p id="0a63" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">什么是构造函数？</strong></p><p id="a964" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在面向对象编程中，构造函数是一种特殊的方法，在创建对象时调用。它用于初始化对象并为其属性分配内存。构造函数通常与类同名，并且没有返回类型。</p><p id="72c9" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">构造函数可以是公共的吗？</strong></p><p id="d939" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">是的，构造函数可以被声明为 public。这意味着可以从类外部调用构造函数，从而允许其他代码创建该类的实例。当类打算用作独立对象而不是用作继承的基类时，通常使用公共构造函数。</p><pre class="kx ky kz la gt lb lc ld bn le lf bi"><span id="a838" class="lg lh in lc b be li lj l lk ll">#include&lt;iostream&gt;<br/>using namespace std;<br/><br/>class A{<br/>    public:<br/>        A(){<br/>            cout &lt;&lt; "constructor called";<br/>        }<br/>};<br/><br/>int main() {<br/>    A a;<br/>    return 0;<br/>}</span></pre><p id="20ea" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">构造函数可以私有吗？</strong></p><p id="9031" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">是的，构造函数可以被声明为私有的。这意味着构造函数只能从类本身内部调用。当类不打算用作独立对象而是用作继承的基类时，通常使用私有构造函数。在这种情况下，派生类可以使用<code class="fe lm ln lo lc b">base</code>关键字调用基类的私有构造函数来创建基类的实例。这允许派生类控制基类如何以及何时被实例化，并且可以用于实现单例模式，其中只允许创建一个类的一个实例。</p><pre class="kx ky kz la gt lb lc ld bn le lf bi"><span id="e555" class="lg lh in lc b be li lj l lk ll">#include &lt;iostream&gt;<br/>using namespace std;<br/><br/>class Singleton {<br/>   private:<br/>   static Singleton *instance;<br/>   int data;<br/> <br/>   Singleton() {<br/>      data = 0;<br/>   }<br/><br/>   public:<br/>   static Singleton *getInstance() {<br/>      if (!instance)<br/>      instance = new Singleton;<br/>      return instance;<br/>   }<br/><br/>   int getData() {<br/>      return this -&gt; data;<br/>   }<br/>   void setData(int data) {<br/>      this -&gt; data = data;<br/>   }<br/>};<br/><br/>Singleton *Singleton::instance = 0;<br/><br/>int main(){<br/>   Singleton *s = s-&gt;getInstance();<br/>   cout &lt;&lt; s-&gt;getData() &lt;&lt; endl;<br/>   s-&gt;setData(100);<br/>   cout &lt;&lt; s-&gt;getData() &lt;&lt; endl;<br/>   return 0;<br/>}</span></pre><p id="8229" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们还可以使用 friend 关键字声明一个私有构造函数。friend 关键字允许函数或类访问类的私有成员。在私有构造函数的情况下，这意味着友元函数或类可以调用私有构造函数，即使该类之外的其他代码无法访问它。</p><pre class="kx ky kz la gt lb lc ld bn le lf bi"><span id="e747" class="lg lh in lc b be li lj l lk ll">#include&lt;iostream&gt;<br/>using namespace std;<br/><br/>class A{<br/>    private:<br/>        A(){<br/>            cout &lt;&lt; "private constructor called";<br/>        }<br/>    friend int main();<br/>};<br/><br/>int main() {<br/>    A a;<br/>    return 0;<br/>}</span></pre><p id="0c73" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">构造函数可以被保护吗？</strong></p><p id="541d" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">是的，在 C++中，构造函数可以被标记为 protected。受保护的构造函数只能由类本身和从它继承的任何类访问。这意味着类及其派生类之外的代码不能直接调用受保护的构造函数。</p><pre class="kx ky kz la gt lb lc ld bn le lf bi"><span id="51ff" class="lg lh in lc b be li lj l lk ll">#include &lt;iostream&gt;<br/>using namespace std;<br/><br/>class Base {<br/>    protected:<br/>       Base() {<br/>           cout &lt;&lt; "Protected constructor called";<br/>       }<br/>};<br/><br/>class Derived: public Base {<br/>    public:<br/>       Derived() : Base() {}<br/>};<br/><br/><br/>int main(){<br/>   Derived d;<br/>   return 0;<br/>}</span></pre><p id="565a" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">什么是析构函数？</strong></p><p id="d910" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">析构函数是一个类的特殊成员函数，当该类的一个对象被销毁或超出范围时会被调用。析构函数与类同名，但前面有一个波浪号(~)。</p><p id="2aad" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">例如，如果一个类被命名为“Foo”，那么这个类的析构函数将被声明为“~Foo()”</p><p id="c067" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">析构函数的主要目的是释放类在其生存期内分配的所有资源。这可能包括内存、文件句柄和其他资源。析构函数是由语言运行库自动调用的，所以您不需要在代码中直接调用它们。</p><p id="c2b4" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">析构函数可以是公共的吗？</p><p id="70b8" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">是的，析构函数在 C++中可以被标记为 public。任何引用该类的对象的代码都可以访问公共析构函数，并且可以调用它来销毁该对象。</p><p id="a6b0" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">但是，需要注意的是，在大多数情况下，没有必要直接调用析构函数。当对象超出范围或被销毁时，语言运行库将自动调用析构函数。</p><p id="65fd" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">一般来说，只有在有特定原因的情况下，才应该将析构函数设置为公共的，比如需要为对象实现自定义的清理逻辑。在大多数情况下，最好将析构函数保留为默认值(它是私有的)，并让语言运行时在对象被销毁时处理其自动调用。</p><pre class="kx ky kz la gt lb lc ld bn le lf bi"><span id="9d0d" class="lg lh in lc b be li lj l lk ll">#include &lt;iostream&gt;<br/>using namespace std;<br/><br/>class A{<br/>    public:<br/>        ~A(){<br/>            cout &lt;&lt; "destructor is called";<br/>        }<br/>};<br/><br/>int main(){<br/>   A a;<br/>   return 0;<br/>}</span></pre><p id="0f74" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">析构函数可以是私有的吗？</strong></p><p id="599b" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">是的，析构函数在 C++中可以被标记为私有的。私有析构函数只能由类本身访问，不能由类外部的代码调用。</p><p id="e8e4" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在大多数情况下，最好将析构函数保留为私有，并让语言运行时在对象被销毁时处理其自动调用。这确保了只有在安全的情况下才调用析构函数，并且外部代码不能干扰对象的生存期。</p><p id="1cec" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">通常没有必要将析构函数设置为私有的，除非有特殊的原因，例如需要防止外部代码调用析构函数并干扰对象的生存期。</p><p id="788f" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">析构函数能被保护吗？</strong></p><p id="2c14" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">是的，析构函数在 C++中可以被标记为 protected。受保护的析构函数只能由类本身和从它继承的任何类访问。这意味着类及其派生类之外的代码不能直接调用受保护的析构函数。</p><p id="8606" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在大多数情况下，最好将析构函数保留为私有，并让语言运行时在对象被销毁时处理其自动调用。这确保了只有在安全的情况下才调用析构函数，并且外部代码不能干扰对象的生存期。</p><p id="4f1e" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">只有在有特定原因的情况下，才应该保护析构函数，例如，如果需要为对象及其派生类实现自定义清理逻辑。在大多数情况下，最好将析构函数保留为默认值(它是私有的)，并让语言运行时在对象被销毁时处理其自动调用。</p><p id="4216" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这是关于 c++的基础，构造函数和析构函数是一个很大的主题，不可能在一篇文章中完成。</p><p id="d0d9" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">亲自加入我的<a class="ae lp" href="https://discord.gg/UUXs24qtRz" rel="noopener ugc nofollow" target="_blank"> <strong class="kb io">不和谐服务器与我互动。</strong>T3】</a></p><p id="0508" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><em class="lq">如果你觉得这篇文章很有帮助，记得去</em>👉<strong class="kb io"> <em class="lq">跟着</em></strong><em class="lq"/><strong class="kb io"><em class="lq">拍手👏</em> </strong> <em class="lq">和</em> <strong class="kb io"> <em class="lq">合用</em> </strong> <em class="lq"> </em>👐和你的朋友一起吧！</p></div></div>    
</body>
</html>