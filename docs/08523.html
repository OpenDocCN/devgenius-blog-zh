<html>
<head>
<title>Kotlin Coroutines — What, Why &amp; How?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kotlin 协同程序——什么，为什么&amp;如何？</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/kotlin-coroutines-what-why-how-99529c951a2e?source=collection_archive---------2-----------------------#2022-06-22">https://blog.devgenius.io/kotlin-coroutines-what-why-how-99529c951a2e?source=collection_archive---------2-----------------------#2022-06-22</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><blockquote class="jk jl jm"><p id="16e3" class="jn jo jp jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ig bi translated">一个人要有合作的套路！</p></blockquote><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/5b8cd5c7cd54dfb83c28e3ecbcfce057.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QyjJJygHgiAOTtiD"/></div></div></figure><p id="2397" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ky ka kb kc kz ke kf kg la ki kj kk kl ig bi translated">术语<strong class="jq io"> <em class="jp">协程</em> </strong>现在是 Android 开发者或 Ktor 后端开发者日常生活的一部分。协同程序在异步编程领域引起了轰动。</p><p id="ed1e" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ky ka kb kc kz ke kf kg la ki kj kk kl ig bi translated">如果你是一个 Android 开发者，那么你一定非常重视这样一个事实:任何长时间运行或 CPU 密集型任务都不应该在我们亲爱的主应用程序线程上执行。我们已经有很多方法来防止这种情况，协程现在也是其中之一。</p><p id="b0ce" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ky ka kb kc kz ke kf kg la ki kj kk kl ig bi translated">在本文中，我们将对以下问题有一些基本的了解:</p><ul class=""><li id="21e3" class="lb lc in jq b jr js jv jw ky ld kz le la lf kl lg lh li lj bi translated">什么是协程&amp;它们做什么？</li><li id="27b1" class="lb lc in jq b jr lk jv ll ky lm kz ln la lo kl lg lh li lj bi translated">我们为什么要使用它们？</li><li id="d87c" class="lb lc in jq b jr lk jv ll ky lm kz ln la lo kl lg lh li lj bi translated">我们应该如何使用它们？</li></ul><blockquote class="jk jl jm"><p id="c2c1" class="jn jo jp jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ig bi translated">如果你还没有选择它们，是时候开始了。</p></blockquote></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><h1 id="6ed9" class="lw lx in bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">什么是协程&amp;它们做什么？</h1><p id="1264" class="pw-post-body-paragraph jn jo in jq b jr mu jt ju jv mv jx jy ky mw kb kc kz mx kf kg la my kj kk kl ig bi translated">任何挂起计算的实例都被称为协同例程，它也是 Android 中用来简化异步代码执行的并发设计模式。</p><blockquote class="jk jl jm"><p id="cdb1" class="jn jo jp jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ig bi translated">挂起的计算指的是与代码的其余部分同时处理一个代码。</p></blockquote><p id="53cb" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ky ka kb kc kz ke kf kg la ki kj kk kl ig bi translated">协程只是简单地获取一段代码，并同时执行它。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mz na l"/></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">示例 1</figcaption></figure><p id="3d37" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ky ka kb kc kz ke kf kg la ki kj kk kl ig bi translated">运行上面的代码将导致</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mz na l"/></div></figure><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi nf"><img src="../Images/6911b041902003f8b59bfd716270bafd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p9hr9NXxJpGCO2thZsIF1Q.jpeg"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">运行阻塞执行</figcaption></figure><p id="b811" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ky ka kb kc kz ke kf kg la ki kj kk kl ig bi translated">你可以看到<em class="jp"> runBlocking </em>是一个协程构建器，它为我们提供了一个协程作用域，在这个作用域中，我们可以同时执行一些代码和其余的代码。看吧！启动协程执行就是这么简单。</p><p id="e1d1" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ky ka kb kc kz ke kf kg la ki kj kk kl ig bi translated">runBlocking builder 是非协同程序代码和协同程序内部代码之间的桥梁。它阻塞主线程，直到它的所有子线程完成它们的执行。这就是为什么即使协程延迟了一秒钟，您最终也能看到主线程日志。</p><p id="7327" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ky ka kb kc kz ke kf kg la ki kj kk kl ig bi translated">让我们看另一个更详细的例子。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mz na l"/></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">示例 2</figcaption></figure><p id="2f2a" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ky ka kb kc kz ke kf kg la ki kj kk kl ig bi translated">运行上面的代码将导致</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mz na l"/></div></figure><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi ng"><img src="../Images/0172671c10e79ca01e3d78869bc65a1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qcJRtw-E3rE0xSC3Ku-5Ww.jpeg"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">带有启动协程执行的运行阻塞</figcaption></figure><p id="3304" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ky ka kb kc kz ke kf kg la ki kj kk kl ig bi translated">如果你仔细观察，我们现在已经添加了一个新的<strong class="jq io"> <em class="jp"> launch </em> </strong>块，它也是一个协程构建器。<strong class="jq io"> <em class="jp"> launch </em> </strong>协程生成器暂停其执行，并让父<strong class="jq io"> <em class="jp"> runBlocking </em> </strong>协程继续执行。但是正如我们提到的<strong class="jq io"><em class="jp">run blocking</em></strong>coroutine 将阻塞它的调用线程，直到它的所有子线程都完成，这就是为什么我们在示例 1 和 2 中都看到了主线程日志。</p><p id="5581" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ky ka kb kc kz ke kf kg la ki kj kk kl ig bi translated">打印主线程日志的总时间是 2 秒。因为 2 秒钟的启动程序块与运行阻塞程序块同时运行，因此 1 秒钟对它们来说是常见的，但不是连续的，并且<strong class="jq io"> <em class="jp">运行阻塞程序块</em> </strong>的执行在<strong class="jq io"> <em class="jp">启动</em> </strong>程序块执行之前停止。</p><p id="9a46" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ky ka kb kc kz ke kf kg la ki kj kk kl ig bi translated">看吧！在协程中启动和执行代码就是这么简单，这就是它的美妙之处。您可以尝试不同的场景来理解协程构建器的功能。</p></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><h1 id="2194" class="lw lx in bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">我们为什么要使用它们？</h1><p id="7c3d" class="pw-post-body-paragraph jn jo in jq b jr mu jt ju jv mv jx jy ky mw kb kc kz mx kf kg la my kj kk kl ig bi translated">正如我们在上面看到的，什么是协程，它们是如何以一种基本的方式工作的。它们甚至类似于传统的线，但并不相同。它们可以在一个线程中暂停执行，并在另一个线程中继续执行(我们将在后续文章中看到这一功能)。它们被多次称为轻量级线程。</p><p id="b440" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ky ka kb kc kz ke kf kg la ki kj kk kl ig bi translated">使用它们的一些主要好处如下:</p><p id="0571" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ky ka kb kc kz ke kf kg la ki kj kk kl ig bi translated"><strong class="jq io">内存高效或轻量级</strong></p><p id="c182" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ky ka kb kc kz ke kf kg la ki kj kk kl ig bi translated">我们可以在一个线程中运行许多协同程序，因为它支持挂起功能，不会阻塞运行它的线程。这反过来消耗更少的内存，因为线程的挂起更昂贵。</p><p id="bc86" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ky ka kb kc kz ke kf kg la ki kj kk kl ig bi translated"><strong class="jq io">结构化并发</strong></p><p id="291e" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ky ka kb kc kz ke kf kg la ki kj kk kl ig bi translated">协程为结构化并发提供支持，即协程中的任何异常或取消都通过层次结构传播，以便能够正确处理。我们将在本系列的后续文章中看到这一点。所以，如果你没有马上得到它，也不要担心。</p><p id="777e" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ky ka kb kc kz ke kf kg la ki kj kk kl ig bi translated"><strong class="jq io">内存泄露少</strong></p><p id="1692" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ky ka kb kc kz ke kf kg la ki kj kk kl ig bi translated">随着并发性在层次结构中传播，泄漏的可能性就越小。</p><p id="694c" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ky ka kb kc kz ke kf kg la ki kj kk kl ig bi translated"><strong class="jq io">同步编码</strong></p><p id="dc3b" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ky ka kb kc kz ke kf kg la ki kj kk kl ig bi translated">启动和运行一个协程几乎就像编写一个同步代码，这使得代码非常干净、易读并且不容易出错。</p><p id="c931" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ky ka kb kc kz ke kf kg la ki kj kk kl ig bi translated"><strong class="jq io">异步过程中更好的控制</strong></p><p id="f425" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ky ka kb kc kz ke kf kg la ki kj kk kl ig bi translated">在协同例程中执行异步计算在取消或超时、协同例程范围、上下文切换、主安全和并发性方面提供了更好的控制。</p><p id="4064" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ky ka kb kc kz ke kf kg la ki kj kk kl ig bi translated"><strong class="jq io">喷气背包支持</strong></p><p id="8a1c" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ky ka kb kc kz ke kf kg la ki kj kk kl ig bi translated">许多 Jetpack 库包括提供完整协程支持的扩展。有些库还提供了自己的协程作用域，您可以将其用于结构化并发。</p><p id="c410" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ky ka kb kc kz ke kf kg la ki kj kk kl ig bi translated"><strong class="jq io">测试支架</strong></p><p id="403a" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ky ka kb kc kz ke kf kg la ki kj kk kl ig bi translated">协程内置了对单元测试支持。虽然设置需要一些额外的注意。</p></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><h1 id="d95d" class="lw lx in bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">我们应该如何使用它们？</h1><p id="6803" class="pw-post-body-paragraph jn jo in jq b jr mu jt ju jv mv jx jy ky mw kb kc kz mx kf kg la my kj kk kl ig bi translated">至此，我们对协程有了基本的了解。现在让我们来解决协程的方式。那么我们如何使用它们呢？</p><p id="fab9" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ky ka kb kc kz ke kf kg la ki kj kk kl ig bi translated">协程总是在名为<strong class="jq io"> <em class="jp">协程上下文的上下文中执行。</em> </strong> CoroutineContext 是各种元素的集合，其中两个是<strong class="jq io"> <em class="jp">作业</em> </strong>和<strong class="jq io"> <em class="jp">调度员</em> </strong>。</p><h2 id="b96c" class="nh lx in bd ly ni nj dn mc nk nl dp mg ky nm nn mk kz no np mo la nq nr ms ns bi translated"><strong class="ak">工作</strong></h2><p id="c1a2" class="pw-post-body-paragraph jn jo in jq b jr mu jt ju jv mv jx jy ky mw kb kc kz mx kf kg la my kj kk kl ig bi translated"><strong class="jq io"> <em class="jp"> launch </em> </strong>协程构建器返回一个<strong class="jq io"> <em class="jp"> Job </em> </strong>对象，帮助我们在<em class="jp">维护我们的协程</em>的生命周期。我们可以使用这个作业对象取消协程。父作业的取消会立即取消其所有子作业，而子作业的失败会立即取消其父作业，从而取消其所有子作业。</p><h2 id="7f0a" class="nh lx in bd ly ni nj dn mc nk nl dp mg ky nm nn mk kz no np mo la nq nr ms ns bi translated">分配器</h2><p id="53ba" class="pw-post-body-paragraph jn jo in jq b jr mu jt ju jv mv jx jy ky mw kb kc kz mx kf kg la my kj kk kl ig bi translated">协程上下文包括一个协程调度程序，它告诉我们<em class="jp">协程使用哪个线程来执行</em>。如果在没有调度程序的情况下启动协程，那么它将在默认调度程序中运行。我们可以明确地提到协程上的调度程序。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mz na l"/></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">协程的调度程序类型</figcaption></figure><p id="568a" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ky ka kb kc kz ke kf kg la ki kj kk kl ig bi translated"><strong class="jq io"> <em class="jp">调度员。Main </em> : </strong>用于在 Android 主线程上运行协程。这包括与 UI 交互或更新实时数据。</p><p id="2b9e" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ky ka kb kc kz ke kf kg la ki kj kk kl ig bi translated"><strong class="jq io"> <em class="jp">调度员。IO </em> : </strong>用于在主线程之外执行 I/O 或网络操作。例如，在磁盘上读/写、从 api 获取数据等。</p><p id="5e69" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ky ka kb kc kz ke kf kg la ki kj kk kl ig bi translated"><strong class="jq io"> <em class="jp">调度员。默认</em> : </strong>这个调度程序被优化为在主线程之外执行 CPU 密集型工作。示例用例包括对列表排序和解析 JSON。</p><p id="f8c7" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ky ka kb kc kz ke kf kg la ki kj kk kl ig bi translated"><strong class="jq io"> <em class="jp">调度员。Unconfined </em> : </strong>这个调度程序在当前线程上下文中启动协程，直到被挂起。一旦它恢复，它就获取挂起函数所使用的线程的上下文。<em class="jp">这个调度器一般不应该在代码中使用。</em></p><p id="d01e" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ky ka kb kc kz ke kf kg la ki kj kk kl ig bi translated">因此，我们应该始终小心我们在哪个上下文中运行我们的协程，并且我们可以有效地使用它们。</p></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><p id="3e18" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ky ka kb kc kz ke kf kg la ki kj kk kl ig bi translated">嗯！这足以让我们了解协程的基础知识。我们将在本系列的后续文章中进一步讨论更多细节。但基本上，这是我们所能做的。</p><p id="f1b4" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ky ka kb kc kz ke kf kg la ki kj kk kl ig bi translated">目前就这些了！敬请期待！</p><p id="020b" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ky ka kb kc kz ke kf kg la ki kj kk kl ig bi translated">在 medium(如果内容对您有帮助)或<a class="ae nt" href="https://github.com/aqua30" rel="noopener ugc nofollow" target="_blank"> github </a>上关注我，并订阅电子邮件以同步了解更多关于 Android 的有趣话题。</p><p id="c944" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ky ka kb kc kz ke kf kg la ki kj kk kl ig bi translated">直到下一次…</p><p id="552c" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ky ka kb kc kz ke kf kg la ki kj kk kl ig bi translated">干杯！</p></div></div>    
</body>
</html>