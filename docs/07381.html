<html>
<head>
<title>Tutorials on Docker — Day 10</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Docker 教程—第 10 天</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/learn-docker-day-10-9ee75ddcc7ba?source=collection_archive---------7-----------------------#2022-03-20">https://blog.devgenius.io/learn-docker-day-10-9ee75ddcc7ba?source=collection_archive---------7-----------------------#2022-03-20</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="7489" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">Dockerfile 入门</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/847f86ad585222e74e1356f58a30c445.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*exhbnomBZnqU_kTq"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">图片由<a class="ae ks" href="https://unsplash.com/@agniveshaj" rel="noopener ugc nofollow" target="_blank"> Agnivesh Jayadeep </a></figcaption></figure><p id="ada6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们之前已经看到了如何在<a class="ae ks" href="https://medium.com/@narendra.techarticles/learn-docker-day-6-f0e2608b9063" rel="noopener"> Day 6 </a>中使用 Docker 容器构建图像。<a class="ae ks" href="https://medium.com/@narendra.techarticles/learn-docker-day-6-f0e2608b9063" rel="noopener"> </a>在这一部分，我们将看看构建 Docker 映像的第二种方法:使用 Dockerfiles。</p><p id="4bb8" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">docker 文件是一个包含如何创建图像的说明的文本文档。例如，指令可以是安装程序、添加源代码或指定在容器启动后运行哪个命令。</p><p id="08f1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">通过从 Docker 文件中读取指令，Docker 可以自动构建映像。每条指令都会给图像添加一个新层。换句话说，指令指定了在构建映像时应该做什么。</p><p id="3ad8" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们可以通过创建 docker 文件来开始这个过程。注意:docker 文件不能有任何扩展名，它们的名称必须以大写字母 d 命名。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi lp"><img src="../Images/9ade366a17a0ba6373be11f67ef8935d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JaS2yOLqnJmED9RdiY9cqQ.png"/></div></div></figure><p id="c34a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在我们有了 docker 文件，让我们来看看它。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi lq"><img src="../Images/5da57d2fe966ea54119af62e960abb5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1cj9senzZQcvO4LWOHmN2w.png"/></div></div></figure><p id="6210" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">Docker 按顺序运行 docker 文件中的指令，第一条指令必须是*FROM*来指定我们正在构建的<strong class="kv io">基础映像</strong>。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi lr"><img src="../Images/fcb5edfad75d1bea330ca18828b73ba0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5LQhH10H3LfRbEQDcf3xQQ.png"/></div></div></figure><p id="ac01" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如您所见，我们使用 node:14 作为我们的基本映像。所以 node:14 是 FROM 指令的参数。</p><p id="fea4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"> 指令中的<strong class="kv io"> <em class="ls">不区分大小写，但惯例规定它们是大写的，以便更容易与参数区分开来。</em></strong></p><p id="3b6f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们继续下一条指令，即<strong class="kv io"> <em class="ls"> WORKDIR </em> </strong>指令。此指令为其后的所有附加指令设置工作目录，包括 COPY、RUN、EXPOSE 和 CMD。它可以在同一个 Dockerfile 文件中多次使用。如果提供了相对路径，它将是上一条 WORKDIR 指令的相对路径。</p><p id="e34b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">接下来，我们将检查 Dockerfile 中的<strong class="kv io"> <em class="ls"> COPY </em> </strong>命令，该命令从源文件复制文件或目录，并将它们添加到目标路径的文件系统中。</p><p id="1098" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">Dockerfile 中的下一个命令是<strong class="kv io"> <em class="ls">运行</em> </strong>。使用 RUN 指令，将在当前图像之上的新层中执行命令，并提交结果。提交的映像将用于 docker 文件的下一步。</p><p id="5067" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在我们来看看 Dockerfile 中的下一个命令:<strong class="kv io"> <em class="ls"> EXPOSE。</em> </strong></p><p id="50af" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">Docker 的<strong class="kv io"> <em class="ls"> EXPOSE </em> </strong>指令指示 Docker 在运行时监听指定的网络端口。默认情况下，EXPOSE 指令不公开可从主机访问的容器端口。换句话说，它只让指定的端口可用于容器间的交互。</p><p id="d419" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">最后，让我们继续 docker 文件中的最后一个命令，即 CMD 命令。<strong class="kv io"> <em class="ls"> CMD </em> </strong>命令指定 Docker 容器启动时要执行的指令。在本例中，<strong class="kv io"> <em class="ls"> CMD </em> </strong>正在指示启动节点服务器。</p><p id="6a7e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这里有一个我们需要学习的新命令:<strong class="kv io"> <em class="ls"> docker build。— </em> </strong>该命令根据 Dockerfile 文件中的指令构建镜像。类型<strong class="kv io"> <em class="ls">码头工人建造。</em> </strong>入门。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi lt"><img src="../Images/7de1b8987598e8a784242c9e4480fcec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tGrCwhdg9RuxjPJqeSWF7A.png"/></div></div></figure><p id="3e81" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">所有步骤完成后，我们可以运行<strong class="kv io"> <em class="ls"> docker images </em> </strong>来确保我们构建的新映像创建成功。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi lu"><img src="../Images/5395ee96c22d4b22ffad00a87a057d51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*keMB2wIvX50dPsfH8ZQLqQ.png"/></div></div></figure><p id="abdb" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如您所见，我们刚刚构建的图像被标记为 none  ，因为我们在运行<strong class="kv io"> <em class="ls"> docker 构建时没有指定标记。</em> </strong>命令</p></div><div class="ab cl lv lw hr lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ig ih ii ij ik"><p id="1f2b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这篇文章暂时就说到这里。下一节将在后续文章中提到。</p></div></div>    
</body>
</html>