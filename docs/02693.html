<html>
<head>
<title>Waiting for Asynchronous Load in React Native</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">等待React Native中的异步加载</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/waiting-for-asynchronous-load-in-react-native-bc160f2389c7?source=collection_archive---------1-----------------------#2020-08-21">https://blog.devgenius.io/waiting-for-asynchronous-load-in-react-native-bc160f2389c7?source=collection_archive---------1-----------------------#2020-08-21</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="1608" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">使用Expo的应用组件有条件地渲染</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/3381ca5130e52b3e346c778b30b93445.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jfQlSFrJg0N5g_4a"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated"><a class="ae ks" href="https://unsplash.com/@kaip?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">凯·皮尔格</a>在<a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="db9f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">AppLoading是Expo提供的一个有用的组件，所以在遵循这个建议之前，请确保您正在使用Expo创建您的React原生应用程序。</p><h1 id="cd13" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">当应用程序派上用场时</h1><p id="9713" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">如果你的应用程序依赖于任何异步响应，AppLoading将对你有用。我的应用程序在“App.js”文件中使用AppLoading，因为我使用需要加载的字体。如果我的应用程序的组件立即渲染，他们可以尝试使用尚未加载的字体。在这里，我们可以使用AppLoading组件和某些道具来完成一些事情:</p><ul class=""><li id="edcb" class="mm mn in kv b kw kx kz la lc mo lg mp lk mq lo mr ms mt mu bi translated">保持加载屏幕，直到不同的组件准备好呈现</li><li id="5c98" class="mm mn in kv b kw mv kz mw lc mx lg my lk mz lo mr ms mt mu bi translated">启动异步加载</li><li id="f6b8" class="mm mn in kv b kw mv kz mw lc mx lg my lk mz lo mr ms mt mu bi translated">指定异步加载完成后要做什么</li></ul><h1 id="1c39" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">两个道具组合在一起</h1><p id="394a" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">所有用于应用的道具从技术上来说都是可选的，但是如果你提供了至少两个道具，使用起来会容易得多。这两个道具一起作用，不能缺一不可。</p><h2 id="0e2c" class="na lq in bd lr nb nc dn lv nd ne dp lz lc nf ng mb lg nh ni md lk nj nk mf nl bi translated">开始异步</h2><p id="f409" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">我们为这个道具传递了一个函数，这个函数在AppLoading一渲染就运行。该函数必须返回异步操作，因为它的伙伴属性依赖于响应。在我的AppLoading组件中，我将一个名为fetchFonts的函数传递给startAsync prop。以下是fetchFonts的外观:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nm"><img src="../Images/50ca8906d9afba88ec1896a6450f70e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cDEZqinqm8B7AxfDCVar7Q.png"/></div></div></figure><p id="a871" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">注意，fetchFonts()不是简单地调用<code class="fe nn no np nq b">Font.loadAsync()</code>，它实际上是返回它。这一点很重要，因为否则AppLoading组件就无法查看异步调用何时结束响应。当AppLoading看到异步操作已经完成时，它运行传递给onFinish prop的函数。</p><h2 id="92d7" class="na lq in bd lr nb nc dn lv nd ne dp lz lc nf ng mb lg nh ni md lk nj nk mf nl bi translated">onFinish</h2><p id="d385" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">onFinish也接收一个函数，这个函数在startAsync一结束就运行。在我的AppLoading组件中，我传递了一个匿名函数onFinish，该函数用一个新的布尔值更新状态变量。这将重新呈现应用程序组件，更新后的状态变量值将呈现应用程序的其余部分，而不是AppLoading组件。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nr"><img src="../Images/9c7da773799aa6396fc2813c8146f323.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JiAqvo4QUgyCj0LWH--OlQ.png"/></div></div></figure><h1 id="c648" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">这一切是如何结合在一起的</h1><p id="91ad" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">现在我们已经知道了AppLoading是如何与它的props一起工作的，是时候看看AppLoading组件是如何与我的功能性应用程序组件中的其他组件相适应的了。</p><p id="06fe" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">因为我的应用程序组件是一个功能组件，所以我使用钩子来创建一个名为fontLoaded的状态变量，该变量跟踪所有内容是否都已加载。这样，当值改变时，组件必须重新呈现，因此条件被重新评估，这将呈现应用程序的其余部分，而不是AppLoading组件。最初，我将fontLoaded设置为false。如果fontLoaded为false，则conditional被设置为返回AppLoading组件。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ns"><img src="../Images/4c960bb0b27a74499ef3c7378946e4b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kHe_NDiUUsiI8zhw7qZEsg.png"/></div></div></figure><p id="cd4d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">当异步加载完成时，传递给onFinish属性的匿名函数将会运行。这个匿名函数使用与FontLoaded状态变量一起创建的setFontLoaded函数。我们将布尔值<code class="fe nn no np nq b">true</code>传递给setFontLoaded，这样当组件重新呈现时，FontLoaded等于<code class="fe nn no np nq b">true</code>。</p><p id="b2e2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">当fontLoaded不等于true时，该组件仅返回AppLoading。我们现在跳过if语句的内容，返回应用程序的其余部分。</p><h1 id="4125" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">开始之前，请记住您的导入内容</h1><p id="11ab" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">如果您认为这在您自己的React本机应用程序中可能有用，那么在使用这些有用的工具之前，您需要在您的文件中导入一些东西:</p><ul class=""><li id="8e5c" class="mm mn in kv b kw kx kz la lc mo lg mp lk mq lo mr ms mt mu bi translated"><code class="fe nn no np nq b">import React, { useState } from ‘react’;</code> —使用JSX需要React，使用状态允许您在功能组件中创建状态变量</li><li id="5938" class="mm mn in kv b kw mv kz mw lc mx lg my lk mz lo mr ms mt mu bi translated"><code class="fe nn no np nq b">import { AppLoading } from ‘expo’;</code> — AppLoading是Expo提供的一个组件，您需要在使用前导入它</li></ul><div class="nt nu gp gr nv nw"><a href="https://docs.expo.io/versions/latest/sdk/app-loading/" rel="noopener  ugc nofollow" target="_blank"><div class="nx ab fo"><div class="ny ab nz cl cj oa"><h2 class="bd io gy z fp ob fr fs oc fu fw im bi translated">应用加载</h2><div class="od l"><h3 class="bd b gy z fp ob fr fs oc fu fw dk translated">一个React组件，告诉Expo如果它是第一个也是唯一一个呈现在…</h3></div><div class="oe l"><p class="bd b dl z fp ob fr fs oc fu fw dk translated">docs.expo.io</p></div></div></div></a></div></div></div>    
</body>
</html>