<html>
<head>
<title>RepeatOnLifecycle + SharedFlow hidden pitfall troubleshooting and handling</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">重复生命周期+共享流程隐藏陷阱故障排除和处理</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/repeatonlifecycle-sharedflow-hidden-pitfall-troubleshooting-and-handling-d22e7c16ab84?source=collection_archive---------5-----------------------#2022-07-21">https://blog.devgenius.io/repeatonlifecycle-sharedflow-hidden-pitfall-troubleshooting-and-handling-d22e7c16ab84?source=collection_archive---------5-----------------------#2022-07-21</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/d02880e965374f13ac17c196b0ff6b52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*AHY2l_aRXVLEoFXS"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">塞巴斯蒂安·贝德纳雷克在<a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><figure class="kb kc kd ke gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ka"><img src="../Images/ba51e751869e188d6614d107a9863bbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_5ONYWH-DbiSs3oVOs_avw.png"/></div></div></figure><h1 id="33a5" class="kf kg in bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">背景</h1><p id="7a9e" class="pw-post-body-paragraph ld le in lf b lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma ig bi translated"><a class="ae jz" href="https://medium.com/@kunminx/google-android-official-architecture-example-i-am-waiting-for-you-at-the-starting-line-b4752d97f283" rel="noopener">《Google Android 架构设计分析及改进建议》</a>上篇文章重点拆解了官方架构“领域层”的设计误区，并给出了改进建议——让 MVI-Dispatcher 作为事件处理者</p><p id="5cf2" class="pw-post-body-paragraph ld le in lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma ig bi translated">然而，一些朋友说，他们不仅想要 MVI-调度员，还想看看 MVI 在科特林手下的实践。</p><figure class="kb kc kd ke gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mg"><img src="../Images/f54b1b8daddc4c46e881d1fa4ec9eb0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SpAZzC5piOGSgPRBwH3SeA.jpeg"/></div></div></figure><p id="3342" class="pw-post-body-paragraph ld le in lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma ig bi translated">因此，这一次，我们带来了<a class="ae jz" href="https://github.com/KunMinX/MVI-Dispatcher-KTX" rel="noopener ugc nofollow" target="_blank">MVI-调度员-KTX </a>库和样本。以下故障排除陷阱故事:</p><h1 id="a365" class="kf kg in bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">共享流也错过结果？</h1><p id="4761" class="pw-post-body-paragraph ld le in lf b lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma ig bi translated">与 MVI-Dispatcher 相同，KTX 版本在示例模块中提供了一系列常规+强力测试，</p><p id="c7b9" class="pw-post-body-paragraph ld le in lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma ig bi translated">我们在 ComplexRequester 中安排了 4 组事件选项，事件 1 可以轮询通知事件 4 推回 UI，事件 2 可以延迟 200ms 后推回 UI，事件 3 可以直接推回 UI，</p><figure class="kb kc kd ke gt jo"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="47aa" class="pw-post-body-paragraph ld le in lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma ig bi translated">同时，我们通过 MainActivity 中的 output 函数注册观察 MVI-调度员-KTX，通过 input 函数发送事件 1、2、3 给 MVI-调度员-KTX。</p><figure class="kb kc kd ke gt jo"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="ca9a" class="pw-post-body-paragraph ld le in lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma ig bi translated">结果出乎意料:</p><pre class="kb kc kd ke gt mj mk ml mm aw mn bi"><span id="a77e" class="mo kg in mk b gy mp mq l mr ms">com.kunminx.purenote_ktx D/e: ---4 0<br/>com.kunminx.purenote_ktx D/e: ---4 1<br/>com.kunminx.purenote_ktx D/e: ---4 2<br/>com.kunminx.purenote_ktx D/e: ---4 3<br/>com.kunminx.purenote_ktx D/e: ---4 4<br/>com.kunminx.purenote_ktx D/e: ---4 5<br/>com.kunminx.purenote_ktx D/e: ---4 6<br/>com.kunminx.purenote_ktx D/e: ---4 7<br/>com.kunminx.purenote_ktx D/e: ---2<br/>com.kunminx.purenote_ktx D/e: ---2<br/>com.kunminx.purenote_ktx D/e: ---2<br/>com.kunminx.purenote_ktx D/e: ---2<br/>com.kunminx.purenote_ktx D/e: ---4 8<br/>com.kunminx.purenote_ktx D/e: ---4 9<br/>com.kunminx.purenote_ktx D/e: ---4 10<br/>com.kunminx.purenote_ktx D/e: ---4 11<br/>com.kunminx.purenote_ktx D/e: ---4 12</span></pre><p id="cf9b" class="pw-post-body-paragraph ld le in lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma ig bi translated">事件 3 推迟结果如何？</p><p id="ec90" class="pw-post-body-paragraph ld le in lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma ig bi translated">MVI-调度员在测试中没有这个问题，为什么 KTX 版本有？</p><p id="7a33" class="pw-post-body-paragraph ld le in lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma ig bi translated">所以继续玩日志观察:</p><figure class="kb kc kd ke gt jo"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="714b" class="pw-post-body-paragraph ld le in lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma ig bi translated">观察 KTX 版本的基类中的 SharedFlow 收集计时:</p><figure class="kb kc kd ke gt jo"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="2ca9" class="pw-post-body-paragraph ld le in lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma ig bi translated">继续输出结果:</p><pre class="kb kc kd ke gt mj mk ml mm aw mn bi"><span id="bc9a" class="mo kg in mk b gy mp mq l mr ms">com.kunminx.purenote_ktx D/---: activity.lifecycleScope.launch<br/>com.kunminx.purenote_ktx D/---: ResultTest3-sendResult<br/>com.kunminx.purenote_ktx D/---: ResultTest3-sendResult<br/>com.kunminx.purenote_ktx D/---: ResultTest3-sendResult<br/>com.kunminx.purenote_ktx D/---: activity.repeatOnLifecycle<br/>com.kunminx.purenote_ktx D/e: ---4 0<br/>com.kunminx.purenote_ktx D/e: ---4 1<br/>com.kunminx.purenote_ktx D/e: ---4 2<br/>com.kunminx.purenote_ktx D/e: ---4 3<br/>com.kunminx.purenote_ktx D/e: ---4 4</span></pre><p id="8e72" class="pw-post-body-paragraph ld le in lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma ig bi translated">寻找线索— sharedFlow.emit 事件 3 计时早于 activity.repeatOnLifecycle 计时，当 sharedFlow 集合丢失时，</p><p id="32eb" class="pw-post-body-paragraph ld le in lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma ig bi translated">因此，将 sharedFlow replay 值更改为 1 以验证:</p><figure class="kb kc kd ke gt jo"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="b9ed" class="pw-post-body-paragraph ld le in lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma ig bi translated">这次收到，确实是时机的问题，也就是 sharedFlow 不是人眼感知的“丢失事件”，而是它默认的 replay = 0，不会自动将缓存的数据推回订阅方。这种设计符合“事件”场景。</p><h1 id="b84c" class="kf kg in bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">为什么不是 StateFlow？</h1><p id="69e3" class="pw-post-body-paragraph ld le in lf b lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma ig bi translated">架构组件应该致力于消除意料之外的错误，而不是相反。</p><p id="bbbe" class="pw-post-body-paragraph ld le in lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma ig bi translated">“反应式编程”是理想模型，behavior subject/StateFlow/LiveData 都是过度设计，在“命令式编程”环境下容易滋生不可预测的错误，应该彻底去除或避免。</p><p id="a816" class="pw-post-body-paragraph ld le in lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma ig bi translated">例如，在这种情况下，如果您期望 replay = 1，则在 3 次发射后您只能接收 1 次，这不利于 MVI 多类型消息响应，因此修改 replay 的计划暂时通过。</p><pre class="kb kc kd ke gt mj mk ml mm aw mn bi"><span id="8ebb" class="mo kg in mk b gy mp mq l mr ms">com.kunminx.purenote_ktx D/---: activity.lifecycleScope.launch<br/>com.kunminx.purenote_ktx D/---: ResultTest3-sendResult<br/>com.kunminx.purenote_ktx D/---: ResultTest3-sendResult<br/>com.kunminx.purenote_ktx D/---: ResultTest3-sendResult<br/>com.kunminx.purenote_ktx D/---: activity.repeatOnLifecycle<br/>com.kunminx.purenote_ktx D/e: ---3<br/>com.kunminx.purenote_ktx D/e: ---4 0<br/>com.kunminx.purenote_ktx D/e: ---4 1<br/>com.kunminx.purenote_ktx D/e: ---4 2<br/>com.kunminx.purenote_ktx D/e: ---4 3<br/>com.kunminx.purenote_ktx D/e: ---4 4</span></pre><p id="6118" class="pw-post-body-paragraph ld le in lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma ig bi translated">我们做什么呢 repeatOnLifecycle 启动的回调相对于发出有延迟。其实在 Activity 中很容易解决，就是通过 View.post 计时，让 emit 在 MessageQueue 中顺序执行，从而保证计时正确，</p><p id="11f1" class="pw-post-body-paragraph ld le in lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma ig bi translated">但是 emit an event 也需要 View.post，显然容易忘记，造成一致性问题，而 MVI-Dispatcher-KTX 采用的是内聚设计，所以这里你不妨把 Activity 注入输入法，然后取里面的 decorView 自动完成 post …</p><figure class="kb kc kd ke gt jo"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="8f82" class="pw-post-body-paragraph ld le in lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma ig bi translated">这很好，但是每次输入都注入一个额外的活动，这是不是有点莫名其妙？</p><p id="bc02" class="pw-post-body-paragraph ld le in lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma ig bi translated">而如果我想在子类的 KTX 版本内部输入一个“副作用”呢？所以程序暂时通过。</p><p id="3707" class="pw-post-body-paragraph ld le in lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma ig bi translated">…还有其他方法吗？</p><p id="23d7" class="pw-post-body-paragraph ld le in lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma ig bi translated">是的，</p><p id="43bc" class="pw-post-body-paragraph ld le in lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma ig bi translated">考虑到“遗漏一个事件”的极端情况，常规操作如“从数据层取数据”由于操作耗时，不易遇到；</p><p id="706b" class="pw-post-body-paragraph ld le in lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma ig bi translated">如果在页面的 onCreate 链接末尾发送了一个 sealed.object 事件，很容易排在<code class="fe mt mu mv mk b">activity.repeatOnLifecycle(Lifecycle.State.STARTED)</code>之前，因为不花时间，错过了机会。</p><p id="8790" class="pw-post-body-paragraph ld le in lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma ig bi translated">所以这里你可以在每次输入时自动延迟 1 毫秒— —</p><p id="06bd" class="pw-post-body-paragraph ld le in lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma ig bi translated">默认设置为 1 毫秒，通过维护延迟映射来取消延迟，从而自动确定延迟:</p><figure class="kb kc kd ke gt jo"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="ebf9" class="pw-post-body-paragraph ld le in lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma ig bi translated">要查看的输出日志:</p><pre class="kb kc kd ke gt mj mk ml mm aw mn bi"><span id="6400" class="mo kg in mk b gy mp mq l mr ms">com.kunminx.purenote_ktx D/---: activity.lifecycleScope.launch<br/>com.kunminx.purenote_ktx D/---: activity.repeatOnLifecycle<br/>com.kunminx.purenote_ktx D/---: ResultTest3-sendResult<br/>com.kunminx.purenote_ktx D/e: ---3<br/>com.kunminx.purenote_ktx D/---: ResultTest3-sendResult<br/>com.kunminx.purenote_ktx D/e: ---3<br/>com.kunminx.purenote_ktx D/---: ResultTest3-sendResult<br/>com.kunminx.purenote_ktx D/e: ---3<br/>com.kunminx.purenote_ktx D/e: ---4 0<br/>com.kunminx.purenote_ktx D/e: ---4 1<br/>com.kunminx.purenote_ktx D/e: ---4 2<br/>com.kunminx.purenote_ktx D/e: ---4 3<br/>com.kunminx.purenote_ktx D/e: ---4 4</span></pre><p id="52d6" class="pw-post-body-paragraph ld le in lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma ig bi translated">到目前为止，已经收到了 3 个事件 3。</p><blockquote class="mw mx my"><p id="e817" class="ld le mz lf b lg mb li lj lk mc lm ln na md lq lr nb me lu lv nc mf ly lz ma ig bi translated"><em class="in">提示 2022.8.16: </em></p><p id="8929" class="ld le mz lf b lg mb li lj lk mc lm ln na md lq lr nb me lu lv nc mf ly lz ma ig bi translated">【V6.6 版以后，取消初始化延时设置，通过拦截实现“保证消费，只消费一次”的设置。详情见下文附注 2022.8.16。</p></blockquote><h1 id="d802" class="kf kg in bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">UnPeek-LiveData 怎么样？</h1><p id="a2c4" class="pw-post-body-paragraph ld le in lf b lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma ig bi translated">我们来看看<a class="ae jz" href="https://github.com/KunMinX/UnPeek-LiveData" rel="noopener ugc nofollow" target="_blank"> UnPeek-LiveData </a>的性能:</p><figure class="kb kc kd ke gt jo"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="1c25" class="pw-post-body-paragraph ld le in lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma ig bi translated">要查看的输出日志:</p><pre class="kb kc kd ke gt mj mk ml mm aw mn bi"><span id="1347" class="mo kg in mk b gy mp mq l mr ms">com.kunminx.unpeeklivedata D/----: hahaha</span></pre><p id="1f79" class="pw-post-body-paragraph ld le in lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma ig bi translated">鉴于 UnPeek-LiveData 的性能和 MVI-Dispatcher 中定长队列的内部维护，在原生 LiveData 中默认不存在“发送丢失事件”的问题。</p><h1 id="f55b" class="kf kg in bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">注 2022.08.16:</h1><h1 id="a9fa" class="kf kg in bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">实行“消费且只消费一次”</h1><p id="5b25" class="pw-post-body-paragraph ld le in lf b lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma ig bi translated">有朋友反映，在“关屏-开屏”场景下，开屏后无法响应屏幕时，推送最新数据。</p><p id="7fd0" class="pw-post-body-paragraph ld le in lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma ig bi translated">对于这个，我考虑过渠道，但是渠道只能用在一对一的场景，很难做到一对多。</p><p id="351d" class="pw-post-body-paragraph ld le in lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma ig bi translated">所以采用 replay + version + observerCount 的方法，统一消除“漏收定时”的问题。</p><p id="0a1f" class="pw-post-body-paragraph ld le in lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma ig bi translated">重放次数目前与缓存队列长度相同，可以根据实际业务需要，通过在相应的 MVI-调度器-KTX 子类中重写 initQueueMaxLength()来修改。</p><figure class="kb kc kd ke gt jo"><div class="bz fp l di"><div class="mh mi l"/></div></figure><h1 id="93d6" class="kf kg in bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">最后</h1><p id="8c7e" class="pw-post-body-paragraph ld le in lf b lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma ig bi translated">MVI-调度员-KTX +坑排的故事一直分享到现在。目前，MVI 调度员和 MVI 调度员 KTX 是在公共测试。欢迎测试和反馈:</p><p id="e2f5" class="pw-post-body-paragraph ld le in lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma ig bi translated">Github:MVI 调度员</p><p id="1b70" class="pw-post-body-paragraph ld le in lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma ig bi translated"><a class="ae jz" href="https://github.com/KunMinX/MVI-Dispatcher-KTX" rel="noopener ugc nofollow" target="_blank">Github:MVI-调度员-KTX </a></p><blockquote class="mw mx my"><p id="cc64" class="ld le mz lf b lg mb li lj lk mc lm ln na md lq lr nb me lu lv nc mf ly lz ma ig bi translated"><em class="in">许可:本文封面上的 Android 机器人是在谷歌原创和共享成果的基础上重新创作的，并按照</em> <a class="ae jz" href="https://creativecommons.org/licenses/by/3.0/" rel="noopener ugc nofollow" target="_blank"> <em class="in">知识共享</em> </a> <em class="in">归属 3.0 许可的条款使用。。</em></p></blockquote></div></div>    
</body>
</html>