<html>
<head>
<title>What is Big O notation and why you should care about it</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是大 O 符号，为什么你应该关心它</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/what-is-big-o-notation-and-why-you-should-care-about-it-fe09223e6536?source=collection_archive---------6-----------------------#2022-11-05">https://blog.devgenius.io/what-is-big-o-notation-and-why-you-should-care-about-it-fe09223e6536?source=collection_archive---------6-----------------------#2022-11-05</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/a77e07a33aa7393113679675127c5813.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AqrcGA6LAMprD66gl429Yg.png"/></div></div></figure><p id="755f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi kt translated">每个对编程有更深兴趣的人都可能遇到过“大 O 符号”的概念<strong class="jx io">。</strong> Big O 符号与数据结构和算法密切相关，这些数据结构和算法对于<strong class="jx io">创建高效可靠的软件至关重要</strong>。</p><h1 id="b82f" class="lc ld in bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">什么是大 O 记数法？</h1><p id="6eaf" class="pw-post-body-paragraph jv jw in jx b jy ma ka kb kc mb ke kf kg mc ki kj kk md km kn ko me kq kr ks ig bi translated">假设你开发了一个新的算法。你如何衡量它是否熟透了？显然，首先你要检查算法是否达到了预先设定的目标。但是接下来呢？</p><p id="f2c8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了衡量它是否真的好，你应该考虑这两个指标:</p><ul class=""><li id="c15f" class="mf mg in jx b jy jz kc kd kg mh kk mi ko mj ks mk ml mm mn bi translated">时间复杂度(执行算法需要多少时间)</li><li id="f0e2" class="mf mg in jx b jy mo kc mp kg mq kk mr ko ms ks mk ml mm mn bi translated">空间复杂度(你的算法占用了多少空间)</li></ul><p id="ed60" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">假设我们有一个整数列表，如下所示:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="6b4b" class="nc ld in my b gy nd ne l nf ng">nums = [1, 2, 3, 4, 5]</span></pre><p id="805f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们想在其中找到某个目标整数。</p><p id="73c3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们将迭代<strong class="jx io"> nums </strong>中的每个数字，并检查它是否等于 target。求解时间<strong class="jx io">取决于输入大小。</strong>按照惯例，输入的大小表示为变量<strong class="jx io"> n. </strong></p><figure class="mt mu mv mw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nh"><img src="../Images/95ab7f4d2af686f43970fa80778bd597.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1punCFSm_Ivwe4-TbRzaDA.png"/></div></div></figure><p id="c33c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> <em class="ni">大 O </em> </strong> <em class="ni">是衡量</em><strong class="jx io"><em class="ni"/></strong><em class="ni">随着</em> <strong class="jx io"> <em class="ni">输入大小</em> </strong> <em class="ni">的增长，我们的 agorithm 运行需要多少时间。</em></p><h1 id="8c5a" class="lc ld in bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">不同类型的 O</h1><h2 id="bb56" class="nc ld in bd le nj nk dn li nl nm dp lm kg nn no lq kk np nq lu ko nr ns ly nt bi translated">O(1)</h2><p id="7542" class="pw-post-body-paragraph jv jw in jx b jy ma ka kb kc mb ke kf kg mc ki kj kk md km kn ko me kq kr ks ig bi translated">O(1)意味着我们的算法在常数时间内运行。这是最好的情况，因为这意味着对于任何给定的输入，算法总是会立即返回输出。换句话说，该算法的时间复杂度不随输入大小而变化。</p><p id="8919" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">O(1)的例子:</p><figure class="mt mu mv mw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nu"><img src="../Images/67f82d59081c6160afdf3c8493602e04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Obs_KQhChF8ZPaA8ND-o0g.png"/></div></div><figcaption class="nv nw gj gh gi nx ny bd b be z dk translated">O(1)示例</figcaption></figure><p id="5ad2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">O(1)图上的复杂度:</p><figure class="mt mu mv mw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nh"><img src="../Images/5d347d95b28c4c7a5a53b1b900a29e0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VstL4i98I2BoOOyfNSNQaw.png"/></div></div><figcaption class="nv nw gj gh gi nx ny bd b be z dk translated">(1)在情节上</figcaption></figure><h2 id="2391" class="nc ld in bd le nj nk dn li nl nm dp lm kg nn no lq kk np nq lu ko nr ns ly nt bi translated">O(n)</h2><p id="89be" class="pw-post-body-paragraph jv jw in jx b jy ma ka kb kc mb ke kf kg mc ki kj kk md km kn ko me kq kr ks ig bi translated">O(n)复杂度出现在本文的初始示例中(在列表 num 中查找目标整数)。这种复杂性的特征是执行算法的时间与输入大小成比例增长，如<strong class="jx io"> n. </strong>所示</p><p id="8224" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">有一些 O(n)复杂度的例子:</p><figure class="mt mu mv mw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nz"><img src="../Images/a521f1f93f6cac3770f4671a762664fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J1obthQJ1ieCyBAzvmqwdQ.png"/></div></div><figcaption class="nv nw gj gh gi nx ny bd b be z dk translated">python 中的 O(n)示例</figcaption></figure><p id="0a13" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">重要的部分是:O(n) not 总是意味着迭代给定输入中的所有元素。有时，我们甚至可以在第一次迭代中找到解决方案(例如，看看上面的 python 代码，想象一下，不是 target = 4，而是 target = 1)。当我们谈论大 O 符号时，我们总是需要考虑最坏的情况。</p><p id="d9de" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果输入大小改变了怎么办？例如，我们的整数列表 nums 有 10 个以上的元素？大 O 等于 O(n + 10)吗？答案是否定的——增加或减去任何常数都不会改变它。还是 O(n)时间复杂度。</p><p id="b742" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在图上看起来是这样的:</p><figure class="mt mu mv mw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nh"><img src="../Images/afab4ce63b6863d6437028131b756167.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gX0JQCwpQzTVF53C0wHtXg.png"/></div></div><figcaption class="nv nw gj gh gi nx ny bd b be z dk translated">在地块上</figcaption></figure><h2 id="fe1c" class="nc ld in bd le nj nk dn li nl nm dp lm kg nn no lq kk np nq lu ko nr ns ly nt bi translated">O(n)</h2><p id="e3ec" class="pw-post-body-paragraph jv jw in jx b jy ma ka kb kc mb ke kf kg mc ki kj kk md km kn ko me kq kr ks ig bi translated">这种复杂还不是最糟糕的，但开始变得相当低效。O(n)的意思是对于任何给定的输入，时间复杂度等于输入大小的平方。实际上这意味着通常(但不总是！)在我们的代码<strong class="jx io">中有<strong class="jx io">嵌套循环</strong>。</strong></p><figure class="mt mu mv mw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi oa"><img src="../Images/98f7e79fccfef7a432d1af9a510dd3d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nNBmh7mNmmFkuYBFYyeE3w.png"/></div></div><figcaption class="nv nw gj gh gi nx ny bd b be z dk translated">python 中的 O(n)示例</figcaption></figure><p id="0545" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是它在图上的样子:</p><figure class="mt mu mv mw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nh"><img src="../Images/943a23c221a802bf35c15fa199690e09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9SW342kodYD84AzD9X8rCw.png"/></div></div><figcaption class="nv nw gj gh gi nx ny bd b be z dk translated">图中的 O(n)示例</figcaption></figure><h2 id="bded" class="nc ld in bd le nj nk dn li nl nm dp lm kg nn no lq kk np nq lu ko nr ns ly nt bi translated">o(登录)</h2><p id="b04b" class="pw-post-body-paragraph jv jw in jx b jy ma ka kb kc mb ke kf kg mc ki kj kk md km kn ko me kq kr ks ig bi translated">这种复杂度甚至比 O(n)还要好。这种特殊类型最常见的例子是二分搜索法:</p><figure class="mt mu mv mw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ca"><img src="../Images/35d1ad40558a0fe0234427cade2ac85e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HWsoHq53WFUypYPLhbCLng.png"/></div></div><figcaption class="nv nw gj gh gi nx ny bd b be z dk translated">python 中的 O(logn)示例</figcaption></figure><p id="c9de" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">二分搜索法以 O(logn)复杂度运行的原因是<strong class="jx io">在每一次迭代中，一半的可能元素被修剪。</strong></p><p id="1e0b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是它在图上的样子:</p><figure class="mt mu mv mw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nh"><img src="../Images/e55a32acad5cbcb9d771ca1906e16d53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2UK9L6oPVsNSS4WV1sqI8g.png"/></div></div><figcaption class="nv nw gj gh gi nx ny bd b be z dk translated">图中的 o(登录)</figcaption></figure><h2 id="1f7e" class="nc ld in bd le nj nk dn li nl nm dp lm kg nn no lq kk np nq lu ko nr ns ly nt bi translated">O(nlogn)</h2><p id="5d3b" class="pw-post-body-paragraph jv jw in jx b jy ma ka kb kc mb ke kf kg mc ki kj kk md km kn ko me kq kr ks ig bi translated">大多数内置排序函数的复杂度都是 O(nlogn)。例如<strong class="jx io">。Python 中的 sort()方法或 sorted()函数</strong>。O(nlogn)复杂度比 O(n)差，但比 O(n)好很多。下面是用 python 以优雅的递归方式编码的快速排序:</p><figure class="mt mu mv mw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ob"><img src="../Images/238c1ad47eff64f5492bf85cf90d2761.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QTQj5PCJM5DvkGkwzChLtQ.png"/></div></div><figcaption class="nv nw gj gh gi nx ny bd b be z dk translated">python 中的快速排序</figcaption></figure><p id="8702" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是它在图上的样子:</p><figure class="mt mu mv mw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nh"><img src="../Images/89613c4f7ba4624556702c8fa9e96bcc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M1WVLwdY8NJLgmdM15FRMw.png"/></div></div><figcaption class="nv nw gj gh gi nx ny bd b be z dk translated">图中的 O(nlogn)</figcaption></figure><h2 id="644b" class="nc ld in bd le nj nk dn li nl nm dp lm kg nn no lq kk np nq lu ko nr ns ly nt bi translated">O(n！)</h2><p id="80b0" class="pw-post-body-paragraph jv jw in jx b jy ma ka kb kc mb ke kf kg mc ki kj kk md km kn ko me kq kr ks ig bi translated">这是最低效的复杂性类型。</p><p id="fca8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">n！—阶乘是一个数学等式，n = 5 时看起来是这样的:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="417e" class="nc ld in my b gy nd ne l nf ng">5! = 5 * 4 * 3 * 2 * 1<br/>5! = 120</span></pre><p id="e6e0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但它仍然被用来寻找排列，并在所谓的旅行推销员问题中——我不打算详细解释这个特殊的问题，因为这是另一篇文章的全新主题。如果你感兴趣，最好从这里开始<a class="ae oc" href="https://en.wikipedia.org/wiki/Travelling_salesman_problem" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="ecc7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在图上看起来是这样的:</p><figure class="mt mu mv mw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nh"><img src="../Images/21088f2fa160ff7410de9000bfcf6bd6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35ekJ6X2sbxvRmC2h-V3Fw.png"/></div></div><figcaption class="nv nw gj gh gi nx ny bd b be z dk translated">O(n！)在剧情上</figcaption></figure><h1 id="9504" class="lc ld in bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">结论</h1><p id="4007" class="pw-post-body-paragraph jv jw in jx b jy ma ka kb kc mb ke kf kg mc ki kj kk md km kn ko me kq kr ks ig bi translated">知道什么是大 O，有哪些例子是绝对值得的。这是在现场工作面试中经常出现的问题之一。</p><p id="eae6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你对变得更好感兴趣，这里有一些我推荐的资源:</p><p id="0cfc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae oc" href="https://www.amazon.pl/Grokking-Algorithms-Illustrated-Programmers-Curious/dp/1617292230" rel="noopener ugc nofollow" target="_blank">Aditya Y Bhargava</a>的《grokking algorithms——一本适合想要理解数据结构和算法的初学者的优秀书籍(其中还有一章是关于大 O 的)</p><p id="3552" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">neet code——这是 youtube 频道，对 leetcode 问题进行了精彩的解释</p></div></div>    
</body>
</html>