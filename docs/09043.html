<html>
<head>
<title>Basics of Load Balancing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">负载平衡的基础</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/basics-of-load-balancing-f8a1abd97ece?source=collection_archive---------3-----------------------#2022-07-26">https://blog.devgenius.io/basics-of-load-balancing-f8a1abd97ece?source=collection_archive---------3-----------------------#2022-07-26</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="ed07" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">使系统更加可靠、可用和高效</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/d97cc35b75fe6527863f9ddc1d9beba6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*eVdMMsyrB7be8CDz"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">雷·哈灵顿在<a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="e66a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">分布式系统的一个重要方面是利用多台服务器的计算能力和资源来处理工作的能力。客户端访问了服务端点。系统计算出此时哪个服务器最适合服务这个请求，并将请求路由到那里。</p><p id="5eca" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在给定的时间点将客户端请求路由到最佳可用的服务器，以便最佳地利用可用的资源，这被称为负载平衡。</p><p id="e89d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">负载— </strong>一个服务器节点要处理的工作量(请求数、处理量)。</p><p id="4c11" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">平衡负载</strong> —通过在可用的服务器之间分配请求来确保没有一个节点过载，并且客户端获得最有效的结果。</p><p id="d1d2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们用一个故事来理解这一点。</p></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><h2 id="996c" class="lw lx in bd ly lz ma dn mb mc md dp me lc mf mg mh lg mi mj mk lk ml mm mn mo bi translated">独特的代码生成器——简单的 Rest 服务</h2><p id="f77b" class="pw-post-body-paragraph kt ku in kv b kw mp jo ky kz mq jr lb lc mr le lf lg ms li lj lk mt lm ln lo ig bi translated">我在做一个项目。一个用例需要逻辑来为每个给定的字符串内容生成唯一的代码。我开发了这个逻辑，并对它进行了彻底的测试。在使用了几个月之后，我想把它作为一个通用服务来使用。因此任何人都可以用它来为给定的字符串内容生成唯一的代码。</p><p id="0d69" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我开发了一个 rest 服务，并将其作为服务公开。现在任何人都可以通过点击 rest 服务来使用它。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/9afa81ca0c0fa8672341320dd4e786f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:934/format:webp/1*bO5iKG9hryFQj-1UuarXhg.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">公开的 Rest 服务</figcaption></figure></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><h2 id="ad72" class="lw lx in bd ly lz ma dn mb mc md dp me lc mf mg mh lg mi mj mk lk ml mm mn mo bi translated">人气伴随着更多的流量——需要更大的机器</h2><p id="b37c" class="pw-post-body-paragraph kt ku in kv b kw mp jo ky kz mq jr lb lc mr le lf lg ms li lj lk mt lm ln lo ig bi translated">服务在第一个月就收到了大量的点击。下个月点击率开始增加。有一天，服务器因大量请求而崩溃，消耗了大量资源。</p><p id="f159" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我通过增加机器配置和内存等方式解决了这个问题。成功了。在长时间停机后，<strong class="kv io">服务再次恢复以满足请求。</strong></p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/a5604c03c132c78142f3961e8f0c1ceb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1050/format:webp/1*IuLFsXRbK9zyb7I-9brUcg.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">具有更多内存和 CPU 的大型服务器</figcaption></figure></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><h2 id="8456" class="lw lx in bd ly lz ma dn mb mc md dp me lc mf mg mh lg mi mj mk lk ml mm mn mo bi translated"><strong class="ak">可伸缩性来自更多的机器，分布式系统</strong></h2><p id="61be" class="pw-post-body-paragraph kt ku in kv b kw mp jo ky kz mq jr lb lc mr le lf lg ms li lj lk mt lm ln lo ig bi translated">几天后，由于同样的原因，服务器再次崩溃。在同一台机器上增加更多的资源实际上是不可能的。</p><p id="79cc" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我发现唯一的解决办法是添加更多的机器，并在这些机器上安装服务。然而，客户端不应该知道后端的多台机器。客户端应该仍然到达同一个端点。</p><p id="8f69" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">解决方案是使用一个代理来公开端点，并让所有的服务器都支持这个代理。客户端将访问公开暴露的服务端点，该端点是代理的。系统有一个所有可用服务器的列表和一个将请求路由到这些服务器之一的逻辑(循环)。该请求将由所选的服务器提供服务，结果将返回给客户端。</p><p id="993f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这一切都发生了，甚至客户端都不知道后端有多台服务器。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/8fadd28a5363d767568aa9f8f40d6af7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1212/format:webp/1*T7h_VFpSNtn-cAldufTFgA.png"/></div></figure><p id="335e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这是在多个服务器之间平衡负载的基本实现。让我们称之为<strong class="kv io">负载平衡器，又名 LB </strong>。</p><p id="9b84" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在实现这个解决方案之后，独特的代码生成器服务在处理大量请求时变得更有弹性。它还使我能够根据流量随时添加(或减少)任意数量的服务器，而不会出现任何停机。</p></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><h2 id="c890" class="lw lx in bd ly lz ma dn mb mc md dp me lc mf mg mh lg mi mj mk lk ml mm mn mo bi translated"><strong class="ak">分布式系统带来复杂性</strong></h2><p id="7bf3" class="pw-post-body-paragraph kt ku in kv b kw mp jo ky kz mq jr lb lc mr le lf lg ms li lj lk mt lm ln lo ig bi translated">一些用例仍然存在问题。例如:</p><ul class=""><li id="dd91" class="mx my in kv b kw kx kz la lc mz lg na lk nb lo nc nd ne nf bi translated">一些请求可能携带非常庞大的字符串内容来生成唯一代码。服务器将需要大量的时间来处理。</li><li id="9ad0" class="mx my in kv b kw ng kz nh lc ni lg nj lk nk lo nc nd ne nf bi translated">一台服务器停机了一段时间。当它回来时，所有的负载都由其余的服务器管理。现在 LB 逻辑将在循环中路由请求。新服务器在重新加入后获得相同数量的请求，而不考虑现有服务器上的高负载。</li><li id="7412" class="mx my in kv b kw ng kz nh lc ni lg nj lk nk lo nc nd ne nf bi translated">还有更多…</li></ul><p id="cc8f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们开始分析解决这些问题。解决方案是在 LB 中添加一些智能逻辑，以便在路由流量时考虑服务器上的负载。</p><p id="3b4b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">上面的第一个用例可以通过维护 LB 上所有服务器的活动请求数量来解决。在决定将请求路由到哪里时，LB 可以选择请求最少的服务器。这个逻辑解决了第一个用例。</p><p id="dbe5" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">第二个用例的解决方案需要来自每台服务器的数据。例如，每台服务器消耗多少资源？为此，LB 需要公开每个服务器都可以不断调用的 API(就像心跳和关于服务器资源的信息)。</p><p id="131e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">LB 现在可以根据服务器资源状态做出明智的决策。考虑到活动请求的数量和最高的可用资源，它可以将请求路由到负担最小的服务器。这也解决了我们的第二个用例。</p><p id="394d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">第三个用例呢。还有更多…‘是的，对路由可能有几个这样的要求。每一个都需要特定的实现。</p><p id="b196" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这些处理不同负载平衡需求的不同实现被称为<strong class="kv io">负载平衡策略</strong>。一些通用的可以通过现成的标准 LB 实现来实现。至于其他，LB 供应商有机会向应用程序开发人员提供挂钩，这样他们可以引入更多的逻辑。</p></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><h2 id="05d8" class="lw lx in bd ly lz ma dn mb mc md dp me lc mf mg mh lg mi mj mk lk ml mm mn mo bi translated">常见的负载平衡策略</h2><p id="8864" class="pw-post-body-paragraph kt ku in kv b kw mp jo ky kz mq jr lb lc mr le lf lg ms li lj lk mt lm ln lo ig bi translated">一些最常见的 LB 策略是</p><ul class=""><li id="c2e7" class="mx my in kv b kw kx kz la lc mz lg na lk nb lo nc nd ne nf bi translated"><strong class="kv io">循环调度</strong> —请求按顺序路由到所有可用的服务器</li><li id="d8a2" class="mx my in kv b kw ng kz nh lc ni lg nj lk nk lo nc nd ne nf bi translated"><strong class="kv io">最少连接</strong> —请求被路由到具有最少活动连接的服务器。</li><li id="0fd9" class="mx my in kv b kw ng kz nh lc ni lg nj lk nk lo nc nd ne nf bi translated"><strong class="kv io">基于资源的</strong> —请求被路由到拥有最多可用资源的服务器。</li><li id="a2a4" class="mx my in kv b kw ng kz nh lc ni lg nj lk nk lo nc nd ne nf bi translated"><strong class="kv io">基于响应时间的</strong> —请求被路由到响应最快的服务器。</li><li id="0b0a" class="mx my in kv b kw ng kz nh lc ni lg nj lk nk lo nc nd ne nf bi translated"><strong class="kv io">权重驱动</strong> —可以根据每个服务器处理请求的能力为其分配权重。这是一个静态参数。</li><li id="5031" class="mx my in kv b kw ng kz nh lc ni lg nj lk nk lo nc nd ne nf bi translated">更多</li></ul><p id="528e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">为了理解这些概念，这些名字都很简单。网上有很多很好的文档，详细解释了这些和更多的策略。最好是参考 LB 厂商网站。</p><p id="3f0a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">所有这些实现都解决了这样一个用例，即通过多个服务器和一个高效的 LB 策略将请求路由到最佳可用服务器，来处理数百万个对唯一代码生成器的请求。</p></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><h2 id="ad65" class="lw lx in bd ly lz ma dn mb mc md dp me lc mf mg mh lg mi mj mk lk ml mm mn mo bi translated">负载平衡—粘性会话</h2><p id="c173" class="pw-post-body-paragraph kt ku in kv b kw mp jo ky kz mq jr lb lc mr le lf lg ms li lj lk mt lm ln lo ig bi translated">我们发现了另一个用例。同一用户不应被允许在一分钟内请求超过 20 次代码生成。这是为了避免黑客利用这项服务。</p><p id="2eee" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">为此，一个简单的解决方案是跟踪一个用户发送的所有请求。但是跨服务器跟踪它需要将这些信息存储在数据库中并跨节点访问，这带来了隔离、序列化等更复杂的问题。</p><p id="f74a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">一个可能的解决方案是 LB 是否能确保总是从一个用户向同一个服务器发送请求。这将需要 LB 从请求中识别用户会话信息，并维护会话和服务器的映射。这使得 LB 能够将活动会话的请求路由到第一次发起会话的同一服务器。</p><p id="1512" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">然后，我们可以在会话中存储所有统计数据。这解决了用例。</p><p id="5d67" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这就是通常所说的粘性会话 LB 策略。简而言之，这意味着将来自一个用户的所有请求都粘贴到首先发起会话的同一台服务器上。</p><blockquote class="nl nm nn"><p id="8306" class="kt ku no kv b kw kx jo ky kz la jr lb np ld le lf nq lh li lj nr ll lm ln lo ig bi translated">当应用程序通过添加更多服务器开始水平扩展时，粘性会话策略在 web 应用程序中被大量使用，但大多数情况下是通过在会话本身(有状态)中存储大量信息来开发的。</p></blockquote><p id="233d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这种策略看起来很酷，但也有它的缺点。它打破了将负载有效地分配给所有可用服务器的初衷。如果一个用户总是绑定到一个服务器，并且如果它产生大量负载，它就违背了负载平衡的整个目的。</p></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><h1 id="7261" class="ns lx in bd ly nt nu nv mb nw nx ny me jt nz ju mh jw oa jx mk jz ob ka mn oc bi translated">总结一下:</h1><p id="ac57" class="pw-post-body-paragraph kt ku in kv b kw mp jo ky kz mq jr lb lc mr le lf lg ms li lj lk mt lm ln lo ig bi translated">简单地说，负载平衡是一种考虑到系统用例在所有可用的服务器之间分配请求/负载的方法，因此系统可以高效地运行。</p><p id="28dc" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">负载均衡器就像一个交通警察，为高负载的混乱状态带来秩序。</p><p id="909f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">好处:</strong></p><ul class=""><li id="1d92" class="mx my in kv b kw kx kz la lc mz lg na lk nb lo nc nd ne nf bi translated">服务器高效运行，不会过载</li><li id="a650" class="mx my in kv b kw ng kz nh lc ni lg nj lk nk lo nc nd ne nf bi translated">跨所有服务器高效利用资源</li><li id="8b52" class="mx my in kv b kw ng kz nh lc ni lg nj lk nk lo nc nd ne nf bi translated">由于有多台服务器提供服务，因此对客户端请求的响应速度更快。</li><li id="dcb7" class="mx my in kv b kw ng kz nh lc ni lg nj lk nk lo nc nd ne nf bi translated">一个资源过载不会导致失败。</li><li id="a19b" class="mx my in kv b kw ng kz nh lc ni lg nj lk nk lo nc nd ne nf bi translated">更多冗余。无停机时间，最大限度减少失误。提高可用性。</li></ul><blockquote class="nl nm nn"><p id="e78c" class="kt ku no kv b kw kx jo ky kz la jr lb np ld le lf nq lh li lj nr ll lm ln lo ig bi translated">负载均衡器在现实世界中也可能承担扩展的责任，如 SSL 终止、数据解压缩、缓存以提高性能，以及应用增强的安全检查以避免 DDOS 类型的攻击。</p></blockquote></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><h1 id="0caa" class="ns lx in bd ly nt nu nv mb nw nx ny me jt nz ju mh jw oa jx mk jz ob ka mn oc bi translated">参考</h1><p id="dd5f" class="pw-post-body-paragraph kt ku in kv b kw mp jo ky kz mq jr lb lc mr le lf lg ms li lj lk mt lm ln lo ig bi translated">对系统设计感兴趣，请点击这里查看更多文章</p><p id="58f3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><a class="ae ks" rel="noopener ugc nofollow" target="_blank" href="/evolution-of-system-design-web-services-to-microservices-9d660506c93f"> <em class="no">系统设计的演进，Webservices 到微服务</em> </a></p><p id="d15a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><a class="ae ks" rel="noopener ugc nofollow" target="_blank" href="/evolution-of-system-design-microservices-benefits-6d0b2233f686"> <em class="no">系统设计进化，微服务受益</em> </a></p><p id="0fd0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们将围绕分布式系统和系统设计讨论更多的主题。</p><p id="1193" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在那之前，请继续关注，祝你学习愉快…</p></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><p id="0e6f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="no">喜欢看这个，请分享，鼓掌，关注类似的故事！</em></p><p id="face" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="no">如有任何建议，请随时通过</em><strong class="kv io"><em class="no">Linkedin</em></strong><em class="no">:</em><a class="ae ks" href="https://www.linkedin.com/in/mohitkgupta/" rel="noopener ugc nofollow" target="_blank"><em class="no">Mohit Gupta</em></a>联系我</p></div></div>    
</body>
</html>