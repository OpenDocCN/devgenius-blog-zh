<html>
<head>
<title>OAuth2 Authorization with React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 React 进行 OAuth2 授权</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/oauth2-authorization-with-react-df276f747d5a?source=collection_archive---------6-----------------------#2022-04-18">https://blog.devgenius.io/oauth2-authorization-with-react-df276f747d5a?source=collection_archive---------6-----------------------#2022-04-18</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/617f22bebba280cb9e56b2b9a328109e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*3246zB5zUBPhRGaQ.png"/></div></div></figure><blockquote class="jv jw jx"><p id="506f" class="jy jz ka kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><em class="in">如果你想在你的 React 项目中使用</em> <strong class="kb io"> <em class="in"> OAuth2 </em> </strong> <em class="in">授权可以使用我发布的包:</em><a class="ae kx" href="https://github.com/tasoskakour/react-use-oauth2" rel="noopener ugc nofollow" target="_blank"><em class="in">@ tasoskakour/React-use-oauth 2</em></a><em class="in">。</em></p></blockquote><h1 id="0139" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">什么是 OAuth2？</h1><p id="b5e8" class="pw-post-body-paragraph jy jz in kb b kc lw ke kf kg lx ki kj ly lz km kn ma mb kq kr mc md ku kv kw ig bi translated">OAuth2 是授权的行业标准协议。它为我们提供了 web 应用程序、桌面应用程序、移动电话和客厅设备的特定授权流程。你可以在这里阅读更多关于框架<a class="ae kx" href="https://oauth.net/2/" rel="noopener ugc nofollow" target="_blank">的内容。</a></p><h1 id="194b" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">我们在网络上的什么地方使用 OAuth2？</h1><p id="bc7c" class="pw-post-body-paragraph jy jz in kb b kc lw ke kf kg lx ki kj ly lz km kn ma mb kq kr mc md ku kv kw ig bi translated">OAuth2 协议的主要用途之一是与第三方提供商(如谷歌、脸书、苹果等)进行认证和授权。所谓的“社交登录”。我很确定你们中的大多数人过去都使用过 OAuth2(作为一个终端用户)的社交登录。</p><p id="504f" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj ly kl km kn ma kp kq kr mc kt ku kv kw ig bi translated">在下面的图片中，我们可以看到用户既可以通过传统的提供用户名和密码的方式手动登录(右侧)，也可以通过脸书/推特/谷歌登录(左侧)。通过选择与这些社交提供商之一登录，他们基本上是在与该提供商进行认证，并授权应用程序访问他们的社交账户的某些信息。例如，如果他们选择登录谷歌，在成功认证后，应用程序可能知道他们的谷歌电子邮件，个人资料照片和姓名。</p><figure class="me mf mg mh gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/3922dacffffadf7f090a29f8172cff4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*V0pLt-d3Bn4yQwjb.png"/></div></div></figure><p id="5b68" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj ly kl km kn ma kp kq kr mc kt ku kv kw ig bi translated">使用社交登录的一个好处就是简单。只需一次点击，甚至无需输入用户名和密码，我们就可以在几秒钟内开始使用应用程序。当然，我们需要确保这个应用程序是值得信任的，我们<strong class="kb io">总是需要注意这个应用程序最终会从我们的社交账户中收集什么信息。</strong></p><h1 id="bac9" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">OAuth2 授权类型</h1><p id="9627" class="pw-post-body-paragraph jy jz in kb b kc lw ke kf kg lx ki kj ly lz km kn ma mb kq kr mc md ku kv kw ig bi translated">最常见的 OAuth2 授权类型是<a class="ae kx" href="https://oauth.net/2/grant-types/authorization-code/" rel="noopener ugc nofollow" target="_blank">授权码</a>和<a class="ae kx" href="https://oauth.net/2/grant-types/implicit/" rel="noopener ugc nofollow" target="_blank">隐式流程</a>。</p><p id="90b0" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj ly kl km kn ma kp kq kr mc kt ku kv kw ig bi translated"><strong class="kb io"> OAuth 2.0 授权码授予</strong></p><p id="9b48" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj ly kl km kn ma kp kq kr mc kt ku kv kw ig bi translated">机密和公共客户端使用授权码授权类型来交换访问令牌的授权码。这个流程的步骤是:</p><p id="cfc5" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj ly kl km kn ma kp kq kr mc kt ku kv kw ig bi translated"><strong class="kb io"> 1) </strong>客户端(你的应用程序)构建并发送给用户一个授权 URL(例如对于 Google 来说是<code class="fe mi mj mk ml b">https://accounts.google.com/o/oauth2/v2/auth</code>),其格式如下:</p><pre class="me mf mg mh gt mm ml mn mo aw mp bi"><span id="034a" class="mq kz in ml b gy mr ms l mt mu">https://authorization-server.com/auth?<br/>response_type=code&amp;<br/>client_id=CLIENT_ID&amp;<br/>redirect_uri=REDIRECT_URI&amp;<br/>scope=photos&amp;<br/>state=1234zyx</span></pre><p id="e6a4" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj ly kl km kn ma kp kq kr mc kt ku kv kw ig bi translated"><strong class="kb io"> 2) </strong>用户看到授权提示，点击“允许”(或“拒绝”)。(可能会要求用户先进行身份验证)。</p><p id="2235" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj ly kl km kn ma kp kq kr mc kt ku kv kw ig bi translated"><strong class="kb io"> 3) </strong>用户被重定向到最初传递给第一步请求的<code class="fe mi mj mk ml b">redirect_uri</code>，以及<code class="fe mi mj mk ml b">code</code>和<code class="fe mi mj mk ml b">state</code>。该 URL 将采用以下形式:</p><pre class="me mf mg mh gt mm ml mn mo aw mp bi"><span id="8226" class="mq kz in ml b gy mr ms l mt mu">https://REDIRECT_URI.com/callback?<br/>code=AUTH_CODE_HERE&amp;<br/>state=1234zyx</span></pre><p id="7256" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj ly kl km kn ma kp kq kr mc kt ku kv kw ig bi translated"><strong class="kb io">注意:</strong><code class="fe mi mj mk ml b">state</code>参数必须与步骤 1 中最初生成的状态相匹配。这是为了减轻 CSRF 的攻击。在这里阅读更多<a class="ae kx" href="https://auth0.com/docs/secure/attack-protection/state-parameters" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="2d82" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj ly kl km kn ma kp kq kr mc kt ku kv kw ig bi translated">在这一步中，我们需要用一个实际的访问令牌来交换接收到的<code class="fe mi mj mk ml b">code</code>。为了实现这一点，我们需要向授权服务器的令牌端点发出 POST 请求，其形式如下所示(例如，对于 Google 来说，它是<code class="fe mi mj mk ml b">https://oauth2.googleapis.com/token</code>)。请注意，这个请求需要从我们的服务器发出，因为我们不能将<code class="fe mi mj mk ml b">CLIENT_SECRET</code>暴露给前端应用程序。</p><pre class="me mf mg mh gt mm ml mn mo aw mp bi"><span id="9b43" class="mq kz in ml b gy mr ms l mt mu">https://api.authorization-server.com/token<br/>grant_type=authorization_code&amp;<br/>code=AUTH_CODE_HERE&amp;<br/>redirect_uri=REDIRECT_URI&amp;<br/>client_id=CLIENT_ID&amp;<br/>client_secret=CLIENT_SECRET</span></pre><p id="ea6b" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj ly kl km kn ma kp kq kr mc kt ku kv kw ig bi translated">5)授权服务器回复访问令牌和到期时间:</p><pre class="me mf mg mh gt mm ml mn mo aw mp bi"><span id="0ee3" class="mq kz in ml b gy mr ms l mt mu">{<br/>"access_token":"RsT5OjbzRn430zqMLgV3Ia",<br/>"expires_in":3600<br/>}</span></pre><p id="b638" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj ly kl km kn ma kp kq kr mc kt ku kv kw ig bi translated"><strong class="kb io">注</strong>:授权代码流一般被认为是安全的。然而，通过使用 PKCE ( <a class="ae kx" href="https://tools.ietf.org/html/rfc7636" rel="noopener ugc nofollow" target="_blank"> RFC 7636 </a>)扩展，利用<code class="fe mi mj mk ml b">code_verifier</code>、<code class="fe mi mj mk ml b">code_challenge</code>和<code class="fe mi mj mk ml b">code_challenge_method</code>，它可以更加防弹。这个扩展超出了本文的范围。你可以在这里阅读更多关于它的信息。</p><p id="8727" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj ly kl km kn ma kp kq kr mc kt ku kv kw ig bi translated"><strong class="kb io">隐式流授予</strong></p><p id="c827" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj ly kl km kn ma kp kq kr mc kt ku kv kw ig bi translated">隐式流是 JavaScript 应用程序的简化 OAuth 流，其中访问令牌被立即返回，无需额外的授权码交换步骤。</p><p id="ad32" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj ly kl km kn ma kp kq kr mc kt ku kv kw ig bi translated">这意味着隐式流程的步骤是我们上面为授权代码授权编写的步骤 1-3。还有一个区别是重定向 URL 将在 hash (#)参数中包含<code class="fe mi mj mk ml b">access_token</code>,而不是在搜索(？)URL 的参数。它将具有以下形式:</p><pre class="me mf mg mh gt mm ml mn mo aw mp bi"><span id="bf2e" class="mq kz in ml b gy mr ms l mt mu">https://REDIRECT_URI.com/callback#<br/>access_token=ACCESS_TOKEN&amp;<br/>expires_in=3600&amp;<br/>token_type=Bearer&amp;<br/>state=1234zyx</span></pre><p id="80f7" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj ly kl km kn ma kp kq kr mc kt ku kv kw ig bi translated">如今，OAuth 2.0 标准推荐使用<em class="ka">授权码授权</em>而不是<em class="ka">隐式流</em>，这是由于在 HTTP 重定向中返回访问令牌的内在风险，而没有确认它已经被客户端接收。</p><p id="08d2" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj ly kl km kn ma kp kq kr mc kt ku kv kw ig bi translated">然而，大多数主要提供商仍然支持并允许应用程序使用<em class="ka">隐式流</em>。例如，在这里你可以阅读 Google 关于客户端 Web 应用程序 OAuth 2.0 的文档，它基本上使用了一个隐式流程。</p><h1 id="884b" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">React:用钩子实现 OAuth2</h1><p id="316e" class="pw-post-body-paragraph jy jz in kb b kc lw ke kf kg lx ki kj ly lz km kn ma mb kq kr mc md ku kv kw ig bi translated">在本节中，我们将创建一个名为<code class="fe mi mj mk ml b">useOAuth2</code>的 React 钩子，它将实现一个带有<strong class="kb io">授权码授权</strong>的<strong class="kb io"> OAuth2 </strong>。</p><blockquote class="jv jw jx"><p id="c84d" class="jy jz ka kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><em class="in">如果你想在你的 React 项目中使用</em><strong class="kb io"><em class="in">oauth 2</em></strong><em class="in">授权你可以使用我发布的包:</em><a class="ae kx" href="https://github.com/tasoskakour/react-use-oauth2" rel="noopener ugc nofollow" target="_blank"><em class="in">@ tasoskakour/React-use-oauth 2</em></a><em class="in">。</em></p></blockquote><p id="98f2" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj ly kl km kn ma kp kq kr mc kt ku kv kw ig bi translated">为了使授权更加用户友好，我们将利用一个弹出窗口；也就是说，对第三方的授权将随着重定向在弹出窗口中发生<strong class="kb io">。</strong></p><p id="4a7c" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj ly kl km kn ma kp kq kr mc kt ku kv kw ig bi translated"><strong class="kb io">第一步:准备挂钩</strong></p><p id="d09f" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj ly kl km kn ma kp kq kr mc kt ku kv kw ig bi translated">我们的钩子需要的道具是:</p><ul class=""><li id="2d26" class="mv mw in kb b kc kd kg kh ly mx ma my mc mz kw na nb nc nd bi translated"><strong class="kb io"> authorizeUrl </strong>:第三方授权 Url(例如对于 Google 是<code class="fe mi mj mk ml b"><a class="ae kx" href="https://accounts.google.com/o/oauth2/v2/auth)." rel="noopener ugc nofollow" target="_blank">https://accounts.google.com/o/oauth2/v2/auth</a></code> <a class="ae kx" href="https://accounts.google.com/o/oauth2/v2/auth)." rel="noopener ugc nofollow" target="_blank">)。</a></li><li id="4a49" class="mv mw in kb b kc ne kg nf ly ng ma nh mc ni kw na nb nc nd bi translated"><strong class="kb io"> clientId </strong>:应用程序的 OAuth2 客户端 Id。</li><li id="7d8c" class="mv mw in kb b kc ne kg nf ly ng ma nh mc ni kw na nb nc nd bi translated"><strong class="kb io"> redirectUri </strong>:确定用户完成授权流程后，第三方 API 服务器将用户重定向到哪里。在我们的实现中，将在<code class="fe mi mj mk ml b">redirectUri</code>上呈现一个弹出窗口。</li><li id="963c" class="mv mw in kb b kc ne kg nf ly ng ma nh mc ni kw na nb nc nd bi translated"><strong class="kb io">范围</strong> (string — <em class="ka">可选</em>):根据您的应用需求列出的范围。</li></ul><p id="fef7" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj ly kl km kn ma kp kq kr mc kt ku kv kw ig bi translated">让我们把这些道具放到钩子上，然后创建一个 UI 状态助手，它将包含<code class="fe mi mj mk ml b">{loading, error}</code>和一个名为<code class="fe mi mj mk ml b">getAuth</code>的函数。该函数将初始化授权流程，因此作为第一步，它需要将<code class="fe mi mj mk ml b">loading</code>设置为真并清除任何错误。</p><pre class="me mf mg mh gt mm ml mn mo aw mp bi"><span id="fc79" class="mq kz in ml b gy mr ms l mt mu">// useOAuth2.js<br/>import { useCallback, useState } from 'react'; <br/><br/>const useOAuth2 = (props) =&gt; {<br/>  const {<br/>      authorizeUrl,<br/>      clientId,<br/>      redirectUri,<br/>      scope = '',<br/>    } = props;<br/><br/>  const [{ loading, error }, setUI] = useState({ loading: false, error: null });<br/><br/>  const getAuth = useCallback(() =&gt; {<br/>      // 1. Init<br/>      setUI({<br/>        loading: true,<br/>        error: null,<br/>      });<br/>  })<br/>}</span></pre><p id="9f0a" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj ly kl km kn ma kp kq kr mc kt ku kv kw ig bi translated"><strong class="kb io">步骤 2:生成状态</strong></p><p id="231d" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj ly kl km kn ma kp kq kr mc kt ku kv kw ig bi translated">在构建授权 URL 之前，我们需要生成一个<code class="fe mi mj mk ml b">state</code>参数。需要这个参数来缓解<a class="ae kx" href="https://auth0.com/docs/secure/attack-protection/state-parameters" rel="noopener ugc nofollow" target="_blank"> CSRF 攻击</a>。此外，我们还可以在这里传递我们想要的任何其他状态信息，以便在重定向之后进行恢复。</p><p id="769f" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj ly kl km kn ma kp kq kr mc kt ku kv kw ig bi translated">为了生成状态，我们使用了<code class="fe mi mj mk ml b">window.crypto</code>函数。实现这一点的代码摘自这篇文章。</p><p id="617f" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj ly kl km kn ma kp kq kr mc kt ku kv kw ig bi translated">我们还需要将状态持久化到<code class="fe mi mj mk ml b">sessionStorage</code>，以便我们的弹出窗口能够在重定向发生后读取它(我们也可以将它持久化到<em class="ka"> cookies </em>或<em class="ka"> localStorage </em>)。</p><pre class="me mf mg mh gt mm ml mn mo aw mp bi"><span id="a628" class="mq kz in ml b gy mr ms l mt mu">// useOAuth2.js<br/>import { useCallback, useState } from 'react'; <br/><br/>const OAUTH_STATE_KEY = 'react-use-oauth2-state-key';<br/><br/>// https://medium.com/@dazcyril/generating-cryptographic-random-state-in-javascript-in-the-browser-c538b3daae50<br/>const generateState = () =&gt; {<br/>	const validChars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';<br/>	let array = new Uint8Array(40);<br/>	window.crypto.getRandomValues(array);<br/>	array = array.map((x: number) =&gt; validChars.codePointAt(x % validChars.length));<br/>	const randomState = String.fromCharCode.apply(null, array);<br/>	return randomState;<br/>};<br/><br/>const saveState = (state: string) =&gt; {<br/>	sessionStorage.setItem(OAUTH_STATE_KEY, state);<br/>};<br/><br/>const removeState = () =&gt; {<br/>	sessionStorage.removeItem(OAUTH_STATE_KEY);<br/>};<br/><br/>const useOAuth2 = (props) =&gt; {<br/>  const {<br/>      authorizeUrl,<br/>      clientId,<br/>      redirectUri,<br/>      scope = '',<br/>    } = props;<br/><br/>  const [{ loading, error }, setUI] = useState({ loading: false, error: null });<br/><br/>  const getAuth = useCallback(() =&gt; {<br/>      // 1. Init<br/>      setUI({<br/>        loading: true,<br/>        error: null,<br/>      });<br/><br/>      // 2. Generate and save state<br/>      const state = generateState();<br/>      saveState(state);<br/>  })<br/>}</span></pre><p id="7528" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj ly kl km kn ma kp kq kr mc kt ku kv kw ig bi translated"><strong class="kb io">第三步:打开弹出窗口</strong></p><p id="877b" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj ly kl km kn ma kp kq kr mc kt ku kv kw ig bi translated">现在我们将开始授权过程！</p><p id="3098" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj ly kl km kn ma kp kq kr mc kt ku kv kw ig bi translated">我们利用接受<code class="fe mi mj mk ml b">authorizeUrl, clientId, redirectUri, scope, state</code>参数的<code class="fe mi mj mk ml b">enhanceAuthorizeUrl</code>函数创建授权 URL，并打开一个指向该 URL 的<strong class="kb io">弹出窗口</strong>。为了更好地操作弹出窗口，我们利用<code class="fe mi mj mk ml b">useRef</code>来保存弹出窗口实例。</p><pre class="me mf mg mh gt mm ml mn mo aw mp bi"><span id="dd96" class="mq kz in ml b gy mr ms l mt mu">// useOAuth2.js<br/>import { useCallback, useState } from 'react'; <br/><br/>const OAUTH_STATE_KEY = 'react-use-oauth2-state-key';<br/>const POPUP_HEIGHT = 700;<br/>const POPUP_WIDTH = 600;<br/><br/>// https://medium.com/@dazcyril/generating-cryptographic-random-state-in-javascript-in-the-browser-c538b3daae50<br/>const generateState = () =&gt; {<br/>	const validChars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';<br/>	let array = new Uint8Array(40);<br/>	window.crypto.getRandomValues(array);<br/>	array = array.map((x) =&gt; validChars.codePointAt(x % validChars.length));<br/>	const randomState = String.fromCharCode.apply(null, array);<br/>	return randomState;<br/>};<br/><br/>const saveState = (state) =&gt; {<br/>	sessionStorage.setItem(OAUTH_STATE_KEY, state);<br/>};<br/><br/>const removeState = () =&gt; {<br/>	sessionStorage.removeItem(OAUTH_STATE_KEY);<br/>};<br/><br/>const openPopup = (url) =&gt; {<br/>	// To fix issues with window.screen in multi-monitor setups, the easier option is to<br/>	// center the pop-up over the parent window.<br/>	const top = window.outerHeight / 2 + window.screenY - POPUP_HEIGHT / 2;<br/>	const left = window.outerWidth / 2 + window.screenX - POPUP_WIDTH / 2;<br/>	return window.open(<br/>		url,<br/>		'OAuth2 Popup',<br/>		`height=${POPUP_HEIGHT},width=${POPUP_WIDTH},top=${top},left=${left}`<br/>	);<br/>};<br/><br/>const closePopup = (popupRef) =&gt; {<br/>	popupRef.current?.close();<br/>};<br/><br/>const enhanceAuthorizeUrl = (<br/>	authorizeUrl,<br/>	clientId,<br/>	redirectUri,<br/>	scope,<br/>	state<br/>) =&gt; {<br/>	return `${authorizeUrl}?response_type=code&amp;client_id=${clientId}&amp;redirect_uri=${redirectUri}&amp;scope=${scope}&amp;state=${state}`;<br/>};<br/><br/>const useOAuth2 = (props) =&gt; {<br/>  const {<br/>      authorizeUrl,<br/>      clientId,<br/>      redirectUri,<br/>      scope = '',<br/>    } = props;<br/><br/>  const popupRef = useRef();<br/>  const [{ loading, error }, setUI] = useState({ loading: false, error: null });<br/><br/>  const getAuth = useCallback(() =&gt; {<br/>      // 1. Init<br/>      setUI({<br/>        loading: true,<br/>        error: null,<br/>      });<br/><br/>      // 2. Generate and save state<br/>      const state = generateState();<br/>      saveState(state);<br/><br/>      // 3. Open popup<br/>      popupRef.current = openPopup(<br/>        enhanceAuthorizeUrl(authorizeUrl, clientId, redirectUri, scope, state)<br/>      );<br/>  })<br/>}</span></pre><p id="3826" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj ly kl km kn ma kp kq kr mc kt ku kv kw ig bi translated"><strong class="kb io">创建弹出组件</strong></p><p id="bfef" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj ly kl km kn ma kp kq kr mc kt ku kv kw ig bi translated">让我们暂时离开<code class="fe mi mj mk ml b">useOAuth2</code>钩子，让我们专注于<strong class="kb io">弹出</strong>实现。</p><p id="7d4c" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj ly kl km kn ma kp kq kr mc kt ku kv kw ig bi translated">现在我们处于这样一种状态，用户在一个弹出窗口中，并向第三方执行授权。之后，它们将被重定向到我们在初始请求中传递的<code class="fe mi mj mk ml b">redirect_uri</code>。</p><p id="f3d3" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj ly kl km kn ma kp kq kr mc kt ku kv kw ig bi translated">一个方便的做法是为那个<code class="fe mi mj mk ml b">redirect_uri</code>呈现带有反应路线的弹出窗口。例如，使<code class="fe mi mj mk ml b">redirect_uri</code>成为<code class="fe mi mj mk ml b">https://your-app.com/callback</code>，然后创建如下代码块所示的路线。这样，授权服务器将把我们重定向回<code class="fe mi mj mk ml b">redirect_uri</code>，它将只呈现我们的弹出组件。</p><pre class="me mf mg mh gt mm ml mn mo aw mp bi"><span id="aac7" class="mq kz in ml b gy mr ms l mt mu">// routes.js<br/>import { BrowserRouter, Route, Routes } from 'react-router-dom';<br/>import { OAuthPopup } from 'OAuth2Popup';<br/><br/>const Example = () =&gt; (<br/>	&lt;BrowserRouter&gt;<br/>		&lt;Routes&gt;<br/>			&lt;Route element={&lt;OAuthPopup /&gt;} path="/callback" /&gt;<br/>			&lt;Route element={&lt;Home /&gt;} path="/" /&gt;<br/>            {/* ... your other routes ... */}<br/>		&lt;/Routes&gt;<br/>	&lt;/BrowserRouter&gt;<br/>);</span></pre><p id="979e" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj ly kl km kn ma kp kq kr mc kt ku kv kw ig bi translated">现在让我们继续 Popup 组件。它需要处理三件事:</p><ol class=""><li id="1f2d" class="mv mw in kb b kc kd kg kh ly mx ma my mc mz kw nj nb nc nd bi translated">读取 URL 重定向参数<code class="fe mi mj mk ml b">code</code>和<code class="fe mi mj mk ml b">state</code>。如果出现错误，将会出现一个<code class="fe mi mj mk ml b">error</code>参数。</li><li id="61bc" class="mv mw in kb b kc ne kg nf ly ng ma nh mc ni kw nj nb nc nd bi translated">检查<code class="fe mi mj mk ml b">state</code>参数是否与最初发送给请求的参数相匹配；我们从<em class="ka">会话存储</em>中读取参数。</li><li id="639f" class="mv mw in kb b kc ne kg nf ly ng ma nh mc ni kw nj nb nc nd bi translated">向父窗口<a class="ae kx" href="https://developer.mozilla.org/en-US/docs/Web/API/Window/opener" rel="noopener ugc nofollow" target="_blank"> (window.opener) </a>反馈授权成功或失败。</li></ol><p id="999d" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj ly kl km kn ma kp kq kr mc kt ku kv kw ig bi translated">为了在<strong class="kb io">弹出框</strong>和它的<strong class="kb io">开启器</strong>之间建立通信，我们使用了<code class="fe mi mj mk ml b">window.opener.postMessage</code>函数，该函数向<strong class="kb io">开启器</strong>可以监听的窗口发送消息。</p><p id="5f3b" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj ly kl km kn ma kp kq kr mc kt ku kv kw ig bi translated">上面的步骤被翻译成下面的代码:</p><pre class="me mf mg mh gt mm ml mn mo aw mp bi"><span id="0d4b" class="mq kz in ml b gy mr ms l mt mu">// OAuth2Popup.jsx<br/>import { useEffect } from 'react';<br/>import { queryToObject } from './tools';<br/><br/>const OAUTH_STATE_KEY = 'react-use-oauth2-state-key';<br/>const OAUTH_RESPONSE = 'react-use-oauth2-response';<br/><br/>const checkState = (receivedState) =&gt; {<br/>	const state = sessionStorage.getItem(OAUTH_STATE_KEY);<br/>	return state === receivedState;<br/>};<br/><br/>const queryToObject = (query) =&gt; {<br/>	const parameters = new URLSearchParams(query);<br/>	return Object.fromEntries(parameters.entries());<br/>};<br/><br/>const OAuthPopup = (props) =&gt; {<br/>	const {<br/>		Component = (<br/>			&lt;div style={{ margin: '12px' }} data-testid="popup-loading"&gt;<br/>				Loading...<br/>			&lt;/div&gt;<br/>		),<br/>	} = props;<br/><br/>	// On mount<br/>	useEffect(() =&gt; {<br/>		const payload = queryToObject(window.location.search.split('?')[1]);<br/>		const state = payload &amp;&amp; payload.state;<br/>		const error = payload &amp;&amp; payload.error;<br/><br/>		if (!window.opener) {<br/>			throw new Error('No window opener');<br/>		}<br/><br/>		if (error) {<br/>			window.opener.postMessage({<br/>				type: OAUTH_RESPONSE,<br/>				error: decodeURI(error) || 'OAuth error: An error has occured.',<br/>			});<br/>		} else if (state &amp;&amp; checkState(state)) {<br/>			window.opener.postMessage({<br/>				type: OAUTH_RESPONSE,<br/>				payload,<br/>			});<br/>		} else {<br/>			window.opener.postMessage({<br/>				type: OAUTH_RESPONSE,<br/>				error: 'OAuth error: State mismatch.',<br/>			});<br/>		}<br/>	}, []);<br/><br/>	return Component;<br/>};<br/><br/>export default OAuthPopup;</span></pre><p id="8265" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj ly kl km kn ma kp kq kr mc kt ku kv kw ig bi translated"><strong class="kb io">步骤 4:收听弹出消息</strong></p><p id="fe67" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj ly kl km kn ma kp kq kr mc kt ku kv kw ig bi translated">让我们回到我们的<code class="fe mi mj mk ml b">useOAuth2</code>钩子。</p><p id="62db" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj ly kl km kn ma kp kq kr mc kt ku kv kw ig bi translated">打开弹出窗口后，我们需要注册一个<strong class="kb io">消息监听器</strong>到窗口，监听来自弹出窗口的任何消息。为了区别于所有其他窗口消息，弹出窗口将消息类型设置为<code class="fe mi mj mk ml b">react-use-oauth2-response</code>。</p><p id="5c51" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj ly kl km kn ma kp kq kr mc kt ku kv kw ig bi translated">如果弹出窗口返回一个错误，那么我们设置适当的 UI 状态，否则我们得到包含<code class="fe mi mj mk ml b">code</code>参数的消息有效负载。</p><p id="31f2" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj ly kl km kn ma kp kq kr mc kt ku kv kw ig bi translated">还有一种情况是，用户在完成授权之前强行关闭了弹出窗口。为了捕捉这一点，我们设置了一个时间间隔，定期检查弹出窗口是否被强制关闭，如果是，它会执行一些清理任务，如重置 UI，删除消息监听器等。</p><pre class="me mf mg mh gt mm ml mn mo aw mp bi"><span id="0d31" class="mq kz in ml b gy mr ms l mt mu">// useOAuth2.js<br/>import { useCallback, useState } from 'react'; <br/><br/>const OAUTH_STATE_KEY = 'react-use-oauth2-state-key';<br/>const POPUP_HEIGHT = 700;<br/>const POPUP_WIDTH = 600;<br/>const OAUTH_RESPONSE = 'react-use-oauth2-response';<br/><br/>// https://medium.com/@dazcyril/generating-cryptographic-random-state-in-javascript-in-the-browser-c538b3daae50<br/>const generateState = () =&gt; {<br/>	const validChars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';<br/>	let array = new Uint8Array(40);<br/>	window.crypto.getRandomValues(array);<br/>	array = array.map((x) =&gt; validChars.codePointAt(x % validChars.length));<br/>	const randomState = String.fromCharCode.apply(null, array);<br/>	return randomState;<br/>};<br/><br/>const saveState = (state) =&gt; {<br/>	sessionStorage.setItem(OAUTH_STATE_KEY, state);<br/>};<br/><br/>const removeState = () =&gt; {<br/>	sessionStorage.removeItem(OAUTH_STATE_KEY);<br/>};<br/><br/>const openPopup = (url) =&gt; {<br/>	// To fix issues with window.screen in multi-monitor setups, the easier option is to<br/>	// center the pop-up over the parent window.<br/>	const top = window.outerHeight / 2 + window.screenY - POPUP_HEIGHT / 2;<br/>	const left = window.outerWidth / 2 + window.screenX - POPUP_WIDTH / 2;<br/>	return window.open(<br/>		url,<br/>		'OAuth2 Popup',<br/>		`height=${POPUP_HEIGHT},width=${POPUP_WIDTH},top=${top},left=${left}`<br/>	);<br/>};<br/><br/>const closePopup = (popupRef) =&gt; {<br/>	popupRef.current?.close();<br/>};<br/><br/>const cleanup = (<br/>	intervalRef,<br/>	popupRef,<br/>	handleMessageListener<br/>) =&gt; {<br/>	clearInterval(intervalRef.current);<br/>	closePopup(popupRef);<br/>	removeState();<br/>	window.removeEventListener('message', handleMessageListener);<br/>};<br/><br/>const enhanceAuthorizeUrl = (<br/>	authorizeUrl,<br/>	clientId,<br/>	redirectUri,<br/>	scope,<br/>	state<br/>) =&gt; {<br/>	return `${authorizeUrl}?response_type=code&amp;client_id=${clientId}&amp;redirect_uri=${redirectUri}&amp;scope=${scope}&amp;state=${state}`;<br/>};<br/><br/>const useOAuth2 = (props) =&gt; {<br/>  const {<br/>      authorizeUrl,<br/>      clientId,<br/>      redirectUri,<br/>      scope = '',<br/>    } = props;<br/><br/>  const popupRef = useRef();<br/>  const [{ loading, error }, setUI] = useState({ loading: false, error: null });<br/><br/>  const getAuth = useCallback(() =&gt; {<br/>      // 1. Init<br/>      setUI({<br/>        loading: true,<br/>        error: null,<br/>      });<br/><br/>      // 2. Generate and save state<br/>      const state = generateState();<br/>      saveState(state);<br/><br/>      // 3. Open popup<br/>      popupRef.current = openPopup(<br/>        enhanceAuthorizeUrl(authorizeUrl, clientId, redirectUri, scope, state)<br/>      );<br/><br/>      // 4. Register message listener<br/>      async function handleMessageListener(message) {<br/>        try {<br/>          const type = message &amp;&amp; message.data &amp;&amp; message.data.type;<br/>          if (type === OAUTH_RESPONSE) {<br/>            const errorMaybe = message &amp;&amp; message.data &amp;&amp; message.data.error;<br/>            if (errorMaybe) {<br/>              setUI({<br/>                loading: false,<br/>                error: errorMaybe || 'Unknown Error',<br/>              });<br/>            } else {<br/>              const code = message &amp;&amp; message.data &amp;&amp; message.data.payload &amp;&amp; message.data.payload.code;<br/>              // ... Check next step to see what we'll do with the code<br/>            }<br/>          }<br/>        } catch (genericError) {<br/>          console.error(genericError);<br/>          setUI({<br/>            loading: false,<br/>            error: genericError.toString(),<br/>          });<br/>        } finally {<br/>          // Clear stuff ...<br/>          cleanup(intervalRef, popupRef, handleMessageListener);<br/>        }<br/>      }<br/>      window.addEventListener('message', handleMessageListener);<br/><br/>      // 4. Begin interval to check if popup was closed forcefully by the user<br/>      intervalRef.current = setInterval(() =&gt; {<br/>        const popupClosed = !popupRef.current || !popupRef.current.window || popupRef.current.window.closed;<br/>        if (popupClosed) {<br/>          // Popup was closed before completing auth...<br/>          setUI((ui) =&gt; ({<br/>            ...ui,<br/>            loading: false,<br/>          }));<br/>          console.warn('Warning: Popup was closed before completing authentication.');<br/>          clearInterval(intervalRef.current);<br/>          removeState();<br/>          window.removeEventListener('message', handleMessageListener);<br/>        }<br/>      }, 250);<br/><br/>      // Remove listener(s) on unmount<br/>      return () =&gt; {<br/>        window.removeEventListener('message', handleMessageListener);<br/>        if (intervalRef.current) clearInterval(intervalRef.current);<br/>      };<br/>    })<br/>}</span></pre><p id="c2f6" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj ly kl km kn ma kp kq kr mc kt ku kv kw ig bi translated"><strong class="kb io">步骤 5:用接入令牌交换代码</strong></p><p id="fb49" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj ly kl km kn ma kp kq kr mc kt ku kv kw ig bi translated">最后一步是将收到的<code class="fe mi mj mk ml b">code</code>与实际的<code class="fe mi mj mk ml b">access_token</code>进行交换。</p><p id="db80" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj ly kl km kn ma kp kq kr mc kt ku kv kw ig bi translated">为了实现这一点，我们需要一个服务器，因为我们不能将<code class="fe mi mj mk ml b">client_secret</code>暴露给前端应用程序。然后，我们的服务器将向第三方授权服务器<code class="fe mi mj mk ml b">/token</code>端点发出 POST 请求，以实际获取<code class="fe mi mj mk ml b">access_token</code>。</p><p id="8f54" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj ly kl km kn ma kp kq kr mc kt ku kv kw ig bi translated">例如，对于谷歌来说，这是<code class="fe mi mj mk ml b">https://oauth2.googleapis.com/token</code>。另请注意，每个提供商的规格可能有所不同。</p><p id="dcfa" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj ly kl km kn ma kp kq kr mc kt ku kv kw ig bi translated">我们需要创建的服务器路由非常简单。为了这个教程，我们将使用<a class="ae kx" href="https://github.com/fastify/fastify" rel="noopener ugc nofollow" target="_blank"> fastify </a>框架来实现它:</p><pre class="me mf mg mh gt mm ml mn mo aw mp bi"><span id="ca2f" class="mq kz in ml b gy mr ms l mt mu">// server.js<br/>import Fastify from 'fastify';<br/>import fetch from 'node-fetch';<br/><br/>const fastify = Fastify({<br/>	logger: true,<br/>});<br/><br/>const CLIENT_SECRET = process.env.CLIENT_SECRET;<br/>const AUTHORIZATION_SERVER_TOKEN_URL = process.env.AUTHORIZATION_SERVER_TOKEN_URL; // e.g https://oauth2.googleapis.com/token<br/><br/>fastify.post('/token', async (request, reply) =&gt; {<br/>	const { code, client_id, redirect_uri } = request.query;<br/><br/>	const data = await fetch(<br/>		`${AUTHORIZATION_SERVER_TOKEN_URL}?grant_type=authorization_code&amp;client_id=${client_id}&amp;client_secret=${CLIENT_SECRET}&amp;redirect_uri=${redirect_uri}&amp;code=${code}`,<br/>		{<br/>			method: 'POST',<br/>		}<br/>	);<br/><br/>	reply.send(await data.json());<br/>});<br/><br/>fastify.listen(3001, (error) =&gt; {<br/>	if (error) throw error;<br/>});</span><span id="98ed" class="mq kz in ml b gy nk ms l mt mu">// useOAuth2.js<br/>import { useCallback, useState } from 'react'; <br/><br/>const OAUTH_STATE_KEY = 'react-use-oauth2-state-key';<br/>const POPUP_HEIGHT = 700;<br/>const POPUP_WIDTH = 600;<br/>const OAUTH_RESPONSE = 'react-use-oauth2-response';<br/><br/>// https://medium.com/@dazcyril/generating-cryptographic-random-state-in-javascript-in-the-browser-c538b3daae50<br/>const generateState = () =&gt; {<br/>	const validChars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';<br/>	let array = new Uint8Array(40);<br/>	window.crypto.getRandomValues(array);<br/>	array = array.map((x) =&gt; validChars.codePointAt(x % validChars.length));<br/>	const randomState = String.fromCharCode.apply(null, array);<br/>	return randomState;<br/>};<br/><br/>const saveState = (state) =&gt; {<br/>	sessionStorage.setItem(OAUTH_STATE_KEY, state);<br/>};<br/><br/>const removeState = () =&gt; {<br/>	sessionStorage.removeItem(OAUTH_STATE_KEY);<br/>};<br/><br/>const openPopup = (url) =&gt; {<br/>	// To fix issues with window.screen in multi-monitor setups, the easier option is to<br/>	// center the pop-up over the parent window.<br/>	const top = window.outerHeight / 2 + window.screenY - POPUP_HEIGHT / 2;<br/>	const left = window.outerWidth / 2 + window.screenX - POPUP_WIDTH / 2;<br/>	return window.open(<br/>		url,<br/>		'OAuth2 Popup',<br/>		`height=${POPUP_HEIGHT},width=${POPUP_WIDTH},top=${top},left=${left}`<br/>	);<br/>};<br/><br/>const closePopup = (popupRef) =&gt; {<br/>	popupRef.current?.close();<br/>};<br/><br/>const cleanup = (<br/>	intervalRef,<br/>	popupRef,<br/>	handleMessageListener<br/>) =&gt; {<br/>	clearInterval(intervalRef.current);<br/>	closePopup(popupRef);<br/>	removeState();<br/>	window.removeEventListener('message', handleMessageListener);<br/>};<br/><br/>const enhanceAuthorizeUrl = (<br/>	authorizeUrl,<br/>	clientId,<br/>	redirectUri,<br/>	scope,<br/>	state<br/>) =&gt; {<br/>	return `${authorizeUrl}?response_type=code&amp;client_id=${clientId}&amp;redirect_uri=${redirectUri}&amp;scope=${scope}&amp;state=${state}`;<br/>};<br/><br/>const objectToQuery = (object) =&gt; {<br/>	return new URLSearchParams(object).toString();<br/>};<br/><br/>const formatExchangeCodeForTokenServerURL = (<br/>	serverUrl,<br/>	clientId,<br/>	code,<br/>	redirectUri<br/>) =&gt; {<br/>	return `${serverUrl}?${objectToQuery({<br/>		client_id: clientId,<br/>		code,<br/>		redirect_uri: redirectUri,<br/>	})}`;<br/>};<br/><br/>const useOAuth2 = (props) =&gt; {<br/>  const {<br/>      authorizeUrl,<br/>      clientId,<br/>      redirectUri,<br/>      scope = '',<br/>    } = props;<br/><br/>  const popupRef = useRef();<br/>  const [{ loading, error }, setUI] = useState({ loading: false, error: null });<br/><br/>  const getAuth = useCallback(() =&gt; {<br/>      // 1. Init<br/>      setUI({<br/>        loading: true,<br/>        error: null,<br/>      });<br/><br/>      // 2. Generate and save state<br/>      const state = generateState();<br/>      saveState(state);<br/><br/>      // 3. Open popup<br/>      popupRef.current = openPopup(<br/>        enhanceAuthorizeUrl(authorizeUrl, clientId, redirectUri, scope, state)<br/>      );<br/><br/>      // 4. Register message listener<br/>      async function handleMessageListener(message) {<br/>        try {<br/>          const type = message &amp;&amp; message.data &amp;&amp; message.data.type;<br/>          if (type === OAUTH_RESPONSE) {<br/>            const errorMaybe = message &amp;&amp; message.data &amp;&amp; message.data.error;<br/>            if (errorMaybe) {<br/>              setUI({<br/>                loading: false,<br/>                error: errorMaybe || 'Unknown Error',<br/>              });<br/>            } else {<br/>              const code = message &amp;&amp; message.data &amp;&amp; message.data.payload &amp;&amp; message.data.payload.code;<br/>              const response = await fetch(<br/>                formatExchangeCodeForTokenServerURL(<br/>                  'https://your-server.com/token',<br/>                  clientId,<br/>                  code,<br/>                  redirectUri<br/>                )<br/>              );<br/>              if (!response.ok) {<br/>                setUI({<br/>                  loading: false,<br/>                  error: "Failed to exchange code for token",<br/>                });<br/>              } else {<br/>                payload = await response.json();<br/>                setUI({<br/>                  loading: false,<br/>                  error: null,<br/>                });<br/>                setData(payload);<br/>                // Lines above will cause 2 rerenders but it's fine for this tutorial :-)<br/>              }<br/>            }<br/>          }<br/>        } catch (genericError) {<br/>          console.error(genericError);<br/>          setUI({<br/>            loading: false,<br/>            error: genericError.toString(),<br/>          });<br/>        } finally {<br/>          // Clear stuff ...<br/>          cleanup(intervalRef, popupRef, handleMessageListener);<br/>        }<br/>      }<br/>      window.addEventListener('message', handleMessageListener);<br/><br/>      // 4. Begin interval to check if popup was closed forcefully by the user<br/>      intervalRef.current = setInterval(() =&gt; {<br/>        const popupClosed = !popupRef.current || !popupRef.current.window || popupRef.current.window.closed;<br/>        if (popupClosed) {<br/>          // Popup was closed before completing auth...<br/>          setUI((ui) =&gt; ({<br/>            ...ui,<br/>            loading: false,<br/>          }));<br/>          console.warn('Warning: Popup was closed before completing authentication.');<br/>          clearInterval(intervalRef.current);<br/>          removeState();<br/>          window.removeEventListener('message', handleMessageListener);<br/>        }<br/>		  }, 250);<br/><br/>      // Remove listener(s) on unmount<br/>      return () =&gt; {<br/>        window.removeEventListener('message', handleMessageListener);<br/>        if (intervalRef.current) clearInterval(intervalRef.current);<br/>      };<br/>    })<br/>}</span></pre><h1 id="67e2" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">结束了</h1><p id="7d09" class="pw-post-body-paragraph jy jz in kb b kc lw ke kf kg lx ki kj ly lz km kn ma mb kq kr mc md ku kv kw ig bi translated">我希望你发现这篇文章信息丰富。🙂</p><p id="67fb" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj ly kl km kn ma kp kq kr mc kt ku kv kw ig bi translated">在接下来的文章中，我们将详细讨论如何使用 Google OAuth2 和 Google APIs 来获取用户信息。</p><p id="7ccc" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj ly kl km kn ma kp kq kr mc kt ku kv kw ig bi translated">敬请期待！</p></div><div class="ab cl nl nm hr nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ig ih ii ij ik"><p id="39dc" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj ly kl km kn ma kp kq kr mc kt ku kv kw ig bi translated"><em class="ka">原载于</em><a class="ae kx" href="https://tasoskakour.com/blog/react-use-oauth2" rel="noopener ugc nofollow" target="_blank"><em class="ka">https://tasoskakour.com</em></a><em class="ka">。</em></p></div></div>    
</body>
</html>