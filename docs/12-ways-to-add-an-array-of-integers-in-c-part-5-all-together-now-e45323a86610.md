# C#中添加整数数组的 12 种方法—第 5 部分:现在全部完成

> 原文：<https://blog.devgenius.io/12-ways-to-add-an-array-of-integers-in-c-part-5-all-together-now-e45323a86610?source=collection_archive---------4----------------------->

![](img/83dbca67bdb4fcb88058d5c862ed4514.png)

照片由[瑞阳张](https://www.pexels.com/@ruiyang-zhang-915467?utm_content=attributionCopyText&utm_medium=referral&utm_source=pexels)从[派克斯](https://www.pexels.com/photo/cars-driving-on-urban-highway-in-evening-3717242/?utm_content=attributionCopyText&utm_medium=referral&utm_source=pexels)

当我第一次开始这个系列的时候，我承诺用 C#总共有 12 种方法来添加整数数组。到目前为止，我已经交付了 10 个(加上一个 JavaScript 版本和一个 F#版本)。概括一下:

第 1 部分 : (1)一个简单的 for 循环，(2)一个使用 goto 的变体，以及(3)另一个使用指针的变体

[第二部分](https://medium.com/dev-genius/12-ways-to-add-an-array-of-integers-in-c-part-2-freeform-iteration-2f5c810a8e7b?source=friends_link&sk=ae3d73998d2e57811d3bea1374f7ddc7):(4)foreach 循环和(5)显式使用枚举器

[第三部分](https://medium.com/dev-genius/12-ways-to-add-an-array-of-integers-in-c-part-3-thinking-in-sets-e2f456454f88?source=friends_link&sk=4dff1c44cc446516161d65fe6e0fba26) : (6)可枚举。聚合和(7)可枚举。总和

[第 4 部分](https://medium.com/dev-genius/12-ways-to-add-an-array-of-integers-in-c-part-4-again-and-again-and-again-dddd86ec8ee?source=friends_link&sk=bab4198dd6fea824897b88af9e1d6af5):递归地，使用(8)个数组，(9)个 Linq，和(10)个指针

从那里还能去哪里？正如维兹尼所说(就在无意中毒死自己之前):“我才刚刚开始！”

不过，真的，我不是。我快没主意了。事实上，下一个是如此愚蠢，几乎不算数。但我要用它来引出更有趣的东西，所以请多包涵。

# 从队列中读取

这里有两个片段。

一点都不有趣，是吗？这在讨论扩展方法的编码面试(记住这是整个事情开始的地方)中是有用的。但除此之外，这只是一个更复杂的方法，来做我们在第一个版本中做的事情。

更糟糕的是，与其他方法相比，它实际上比较慢。这并不奇怪，因为它比其他的要复杂得多，没有真正的好处。

但是这会带来更好的结果吗？例如，如果我们用一个`ConcurrentQueue<T>`代替`Queue<T>`会怎么样？我们能否多线程化这个宝贝，让它在一半或更短的时间内运行起来？

# 并行使用并发队列

让我们试一试。

没问题！我们只需运行之前的队列示例，将它分成四个并行任务，然后看着它燃烧。那里的`Interlocked.Add`防止我们在加法上出错。

那么它真的有用吗？嗯，算是吧。我只能用我自己的笔记本电脑，它有两个不错的内核，但没有创下任何速度记录。但是从我目前的结果来看，这种方法非常慢。比平均速度慢 10 倍或更多。老实说，我不太清楚具体原因。对于将一个数字加到另一个数字这样的小操作来说，这可能需要太多的脚手架。对于运行时间更长、更复杂的操作，这种方法实际上可能行得通。

所以从技术上来说，这是我们的 12 种方式。但是为了防止有人认为第 8 和第 9 基本上是一样的——它们在某种程度上是一样的，但在某种程度上，这里的几乎所有东西都是同一件事情的不同版本——或者第 11 太荒谬了而无法计数，这里还有一个方法，实际上是对第 12 的一点改进。

# 使用矩形阵列并行

有多种方法可以提供对一系列事物的线程安全并发访问。

有很多，但总结一下:我们把一维数组重新排列成多维数组，然后并行处理所有的维度。它比并发队列版本更复杂，但性能也大大提高。事实上，在其他方法中，它略高于平均水平。遗憾的是，这并不是最快的，可能是因为安装成本的原因。

# 结论

那么这一切有什么意义呢？从表面上看，这是一种挖掘潜在团队成员对 C#语言的知识深度的方式，不管这有什么价值。更重要的是，谈论这些例子是一种衡量一个人对计算机编程如何工作的理解的广度和深度的方式。这些不同的方法展示了软件开发中的重要概念，而不仅仅是 C#。一个非常了解他们的人可能会对你的团队做出积极的贡献。一个对概念模糊不清，但能提出好问题并表现出真正兴趣的人，处于学习和成长的有利位置。

概括一下，下面是完整的列表:

(1) `for`循环:最普遍理解的，最快的

(2) `goto`:大约和`for`一样快，并不比它快多少，而且更令人困惑

(3)指针:挺快的，但不是最快的；没有做这件事的好理由

(4) `foreach`:另一种常见的解决方案，几乎和`for`一样快

(5) `Enumerator`:和`foreach`一样的基本思想，但是更复杂，也不会更快

(6) `Enumerable.Aggregate`:在 JavaScript 中很棒的一种做法(reduce)，但在 C#中就不那么好了；较慢的方法之一

(7) `Enumerable.Sum`:不是最快的，但是非常接近，也是最简单的。有时在大型数据集上失败。

(8)使用数组递归:由于尾部调用优化，这在 F#中是一个好主意，但在 C#中不是；较大数据集上的堆栈溢出，较小数据集上的一般性能

(9)使用 Linq 递归:与使用数组递归有相同的缺点，性能更差

(10)带指针的递归:令人惊讶的好性能，但是在大型数据集上仍然失败

(11a)排队:不必要的复杂和低于平均水平的性能

(11b)并发队列:令人惊讶的糟糕性能

(12)矩形阵列:性能一般，但复杂得多

谢谢你陪我走完这段旅程。你永远不会做我在这里描述的大部分东西，但是希望这里有一些技术，你会发现对更合适的应用程序有帮助。

还有其他建议吗？很想听听大家的意见。