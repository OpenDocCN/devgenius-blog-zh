<html>
<head>
<title>R for Haters: How To Extract Word/Number Inside Parentheses</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">R for Haters:如何提取括号内的单词/数字</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/r-for-haters-how-to-extract-word-number-inside-parentheses-c0fc775de9bc?source=collection_archive---------8-----------------------#2022-12-05">https://blog.devgenius.io/r-for-haters-how-to-extract-word-number-inside-parentheses-c0fc775de9bc?source=collection_archive---------8-----------------------#2022-12-05</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="4750" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在处理人员数据时，我有很多机会处理姓名和一个额外的括号，括号中包含出生年份、州或国家等信息。这些信息有时需要提取到一个单独的列中，以便我们可以用于进一步的数据分析。尽管有许多不同的情况，今天我们学习了在一对括号中提取所有内容的基本方法。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/460a14c50097e514460978f0cd5e3836.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yRhUdTcX14dM569CdqJJGA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">如何提取括号内的单词/数字</figcaption></figure></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h1 id="cec3" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">场景 1</h1><p id="bea4" class="pw-post-body-paragraph jk jl in jm b jn md jp jq jr me jt ju jv mf jx jy jz mg kb kc kd mh kf kg kh ig bi translated">这是一个数据框示例。此<strong class="jm io"> FULL_NAME </strong>列包含括号内带有额外出生年份的姓名。</p><pre class="kj kk kl km gt mi mj mk bn ml mm bi"><span id="518f" class="mn lg in mj b be mo mp l mq mr">library(dplyr)<br/>library(stringr)<br/>df &lt;- data.frame(<br/>FULL_NAME = c("Aleksander, Fraser (1990)","Eden, Connor (1980)",<br/>"Joao, Snider (2000)"), <br/>STATES = c("Ohio", "California", "Ontario"))</span></pre><p id="a313" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当从一对括号中提取数字时，我们可能会想到一种使用<em class="ms">正则表达式</em> ( <em class="ms"> regex </em>)的模式。花点时间想一个可能的方法来提取括号内的数字。你可以看到我们要提取的是左括号<strong class="jm io">后的数字</strong>和右括号前的数字<strong class="jm io">。你可能听说过<code class="fe mt mu mv mj b"><strong class="jm io">Lookahead/Lookbehind</strong></code>正则表达式。</strong></p><ul class=""><li id="a0d0" class="mw mx in jm b jn jo jr js jv my jz mz kd na kh nb nc nd ne bi translated"><code class="fe mt mu mv mj b"><strong class="jm io">Lookahead</strong>: <strong class="jm io">(?=)</strong></code> <strong class="jm io"> </strong>(要求 PERL = TRUE)，例如(？=yx):位置后跟“xy”</li><li id="b138" class="mw mx in jm b jn nf jr ng jv nh jz ni kd nj kh nb nc nd ne bi translated"><code class="fe mt mu mv mj b"><strong class="jm io">Lookbehind</strong>: <strong class="jm io">(?&lt;=)</strong></code> (PERL = TRUE)，例如(？&lt;= yx):“xy”之后的位置</li></ul><p id="8643" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在我们得到提取括号内数字的基本成分。逻辑是提取<code class="fe mt mu mv mj b"><strong class="jm io">(</strong></code>后面的数字</p><p id="9e3c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">前方还有<code class="fe mt mu mv mj b"><strong class="jm io">)</strong></code> <strong class="jm io">。我在这里输入一个新的行，这样你就不会混淆了。我们要寻找的是什么(用这个语法<code class="fe mt mu mv mj b"><strong class="jm io">(?&lt;=\\()</strong></code> <strong class="jm io">)。</strong>我们需要用<code class="fe mt mu mv mj b">\\</code>转义<code class="fe mt mu mv mj b"><strong class="jm io">(</strong></code> <strong class="jm io"> </strong>。下一步，我们需要用这个语法寻找在<code class="fe mt mu mv mj b"><strong class="jm io">)</strong></code>之前该怎么走<code class="fe mt mu mv mj b"><strong class="jm io">(?=\\))</strong></code>，我们还需要用<code class="fe mt mu mv mj b">\\</code>转义<code class="fe mt mu mv mj b"><strong class="jm io">)</strong></code> <strong class="jm io"> </strong>。</strong></p><p id="3514" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里是我们上面刚刚讨论的最后一个正则表达式:<code class="fe mt mu mv mj b"><strong class="jm io">“(?&lt;=\\()\\d+(?=\\))”</strong></code> <strong class="jm io">。你可能想知道<code class="fe mt mu mv mj b"><strong class="jm io">\\d+</strong></code>是什么意思？它将匹配括号内的数字至少<strong class="jm io"> 1 </strong>次。</strong></p><pre class="kj kk kl km gt mi mj mk bn ml mm bi"><span id="97f6" class="mn lg in mj b be mo mp l mq mr">Summary:<br/>(?&lt;=\\(): Look behind the open parenthesis<br/>(?=\\): Look ahead the close parenthesis<br/>\\d+: Match digits at least 1 time</span></pre><p id="5341" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">是时候写一个函数了，这样我们可以在未来的项目中重用。这个函数将提取括号内的数字，注意，这个模式对于我们上面作为样本数据的特定情况是有效的。如果您的情况不同，您可以调整正则表达式来获取您想要的内容。</p><pre class="kj kk kl km gt mi mj mk bn ml mm bi"><span id="a3c7" class="mn lg in mj b be mo mp l mq mr">#Function to extract number inside parentheses<br/>ex_num &lt;- function(data){<br/>  str_extract(data, "(?&lt;=\\()\\d+(?=\\))")<br/>}<br/><br/>df2 &lt;- df %&gt;%<br/>  mutate(YOB = ex_num(FULL_NAME))</span></pre><p id="df97" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">结果看起来像:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/93f6c45f893046a0cf8aafad755009f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:944/format:webp/1*lA0403kUKITH9JA3hFoQMQ.png"/></div></figure></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h1 id="152d" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">场景 2</h1><p id="6a37" class="pw-post-body-paragraph jk jl in jm b jn md jp jq jr me jt ju jv mf jx jy jz mg kb kc kd mh kf kg kh ig bi translated">在这种情况下，<strong class="jm io"> FULL_NAME </strong>列包括括号内的州和出生年份。您的任务是将状态提取到一个单独的列中，您将如何调整正则表达式来捕获它呢？</p><pre class="kj kk kl km gt mi mj mk bn ml mm bi"><span id="a990" class="mn lg in mj b be mo mp l mq mr">df &lt;- data.frame(<br/>FULL_NAME = c("Aleksander, Fraser (Ohio, 1990)",<br/>"Eden, Connor (California, 1980)","Joao, Snider (Ontario, 2000)"))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/d5620d15349e59f24148605f4416d169.png" data-original-src="https://miro.medium.com/v2/resize:fit:654/format:webp/1*Jz8b5ksN0tTa0305wQ6YQQ.png"/></div></figure><p id="5f2d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这种情况与场景 1 非常不同，场景 1 捕获括号内的数字。然而，在这种情况下，我们只想捕获州名。我们需要稍微修改一下正则表达式来捕捉它。对于<code class="fe mt mu mv mj b"><strong class="jm io">Lookahead</strong></code>部分，我们将<code class="fe mt mu mv mj b"><strong class="jm io">\\(</strong></code>改为<code class="fe mt mu mv mj b"><strong class="jm io">,</strong></code></p><pre class="kj kk kl km gt mi mj mk bn ml mm bi"><span id="2e5c" class="mn lg in mj b be mo mp l mq mr">ex_word &lt;- function(data){<br/>  str_extract(data, "(?&lt;=\\()\\w+(?=,)")<br/>}</span></pre><pre class="nm mi mj mk bn ml mm bi"><span id="e721" class="mn lg in mj b be mo mp l mq mr">Summary:<br/>(?&lt;=\\(): Look behind the open parenthesis<br/>(?=,): Look ahead the comma<br/>\\w+: Match word characters at least 1 time</span></pre><p id="8b24" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">正则表达式意味着我们在寻找从<strong class="jm io">左括号</strong>到<strong class="jm io">逗号</strong>之间的单词字符。下面是我们运行代码时的结果。</p><pre class="kj kk kl km gt mi mj mk bn ml mm bi"><span id="a4d9" class="mn lg in mj b be mo mp l mq mr">df2 &lt;- df %&gt;% <br/>  mutate(STATE = ex_word(FULL_NAME))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/6755772abdc465c2196e22b2d71f7596.png" data-original-src="https://miro.medium.com/v2/resize:fit:852/format:webp/1*0Ng2sheTYDgTAKNQ43brzA.png"/></div></figure></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><p id="2fa9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这一步，您可能会问如何将州和出生年份提取到两个独立的列中。这是一个很好的观点。我们应用与上面两个例子相同的原理。下面是如何将出生年份提取到另一列中。此模式将捕获括号中的年份</p><p id="a27e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe mt mu mv mj b"><strong class="jm io">(?&lt;=\\(\\w{1,20},\\s)\\d+(?=\\))</strong></code></p><p id="0179" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe mt mu mv mj b"><strong class="jm io">(?&lt;=\\(\\w{1,20},\\s)</strong></code> <strong class="jm io"> : </strong> <em class="ms">看左括号后面，单词字符长度从 1 到 20，一个逗号，一个空格。</em></p><ul class=""><li id="a704" class="mw mx in jm b jn jo jr js jv my jz mz kd na kh nb nc nd ne bi translated"><em class="ms">例如:亚历山大·弗雷泽</em> <code class="fe mt mu mv mj b"><strong class="jm io"><em class="ms">(Ohio,</em></strong><em class="ms"> </em></code> <em class="ms"> 1990) </em></li></ul><p id="b594" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你可能会奇怪为什么我们用<code class="fe mt mu mv mj b"><strong class="jm io">{1,20}</strong></code>而不是<code class="fe mt mu mv mj b"><strong class="jm io">+</strong></code> <strong class="jm io">。</strong>这是因为在 look back 中，如果我们使用<code class="fe mt mu mv mj b"><strong class="jm io">\\w+</strong></code>它将抛出下面的错误。因此，我们需要指定固定长度。(<em class="ms">由你决定，在这种情况下我就把它从 1 留到 20 </em>)</p><p id="83d9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe mt mu mv mj b">Look-Behind pattern matches must have a bounded maximum length</code></p><pre class="kj kk kl km gt mi mj mk bn ml mm bi"><span id="a703" class="mn lg in mj b be mo mp l mq mr">df2 &lt;- df %&gt;% <br/>  mutate(STATE = ex_paren(FULL_NAME),<br/>         YOB = str_extract(FULL_NAME, "(?&lt;=\\(\\w{1,20},\\s)\\d+(?=\\))"))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi no"><img src="../Images/94f1869f5cb2f3b98eb16f919d7fd27d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1006/format:webp/1*YURJ8wHKa3mUIogIeeD5iw.png"/></div></figure><p id="52e2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你需要一次又一次地重复同样的任务，你可以考虑写一个函数，但是如果不经常使用，你就直接写没有函数的代码。</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h1 id="cd32" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">其他解决方案</h1><p id="1098" class="pw-post-body-paragraph jk jl in jm b jn md jp jq jr me jt ju jv mf jx jy jz mg kb kc kd mh kf kg kh ig bi translated">俗话说“条条大路通罗马”。也就是说，我们有很多方法可以达到我们的目的。另一种简单的方法是，我们将把括号内的所有内容提取到另一列。在这一步，我们只能将单词或数字提取到两个独立的列中。</p><pre class="kj kk kl km gt mi mj mk bn ml mm bi"><span id="ff4d" class="mn lg in mj b be mo mp l mq mr">df &lt;- data.frame(<br/>FULL_NAME = c("Aleksander, Fraser (Ohio, 1990)",<br/>"Eden, Connor (California, 1980)","Joao, Snider (Ontario, 2000)"))<br/><br/>df2 &lt;- df %&gt;% <br/>  mutate(PAREN = str_extract(FULL_NAME, "(?&lt;=\\().*(?=\\))"),<br/>         STATE = str_extract(PAREN, "\\w+"),<br/>         YOB = str_extract(PAREN, "\\d+"))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi np"><img src="../Images/636b04f2fa7adee24777f5906f4ee617.png" data-original-src="https://miro.medium.com/v2/resize:fit:1264/format:webp/1*4yJetOpRqeOqqxboW1A2rQ.png"/></div></figure></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h1 id="8a36" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated"><strong class="ak">总结</strong>:</h1><p id="11fb" class="pw-post-body-paragraph jk jl in jm b jn md jp jq jr me jt ju jv mf jx jy jz mg kb kc kd mh kf kg kh ig bi translated">我们有很多方法来完成同样的任务。然而，在这篇文章中，我想尽可能地深入细节，以便你有更多的想法来解决同样的问题。当我们这样做的时候，我们学会了如何分析一个问题，并为每个特定的案例找出最佳的方法。如果你有任何想法或反馈，请随时告诉我。</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h1 id="323b" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">参考资料:</h1><p id="ea80" class="pw-post-body-paragraph jk jl in jm b jn md jp jq jr me jt ju jv mf jx jy jz mg kb kc kd mh kf kg kh ig bi translated">R Regex 备忘单:【wordpress.com】四列布局备忘单</p></div></div>    
</body>
</html>