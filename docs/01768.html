<html>
<head>
<title>Microservice Communication with Apache Kafka</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">与Apache Kafka的微服务通信</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/microservice-communication-with-apache-kafka-ae3ccb05a4b6?source=collection_archive---------8-----------------------#2020-07-11">https://blog.devgenius.io/microservice-communication-with-apache-kafka-ae3ccb05a4b6?source=collection_archive---------8-----------------------#2020-07-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/f7850fdc84fe947d0f8cd478d237734a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mszuBA2S71ULR2vMd5PxOA.png"/></div></div></figure><p id="4d81" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">微服务必须面对的挑战之一是沟通。但是有一种简单的方法可以带来最大的好处。使用Apache Kafka来交流微服务的最显著的好处之一是:</p><ul class=""><li id="5918" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">零数据包丢失。</li><li id="5c1c" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">非常高的吞吐量(单个微服务仅使用一个CPU就可以处理10mb/秒)。</li><li id="2499" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">实时处理。</li><li id="83bd" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">CPU限制的可扩展性(这意味着，如果您有一个微服务的两个实例，每个实例在一个CPU中运行，您的应用程序将扩展到处理20mb/秒，如果您有3个实例，您将扩展到处理30mb/秒，依此类推)。</li></ul><p id="18e6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于这个基准测试，我获得了10mb/秒的吞吐量，但是处理速度将主要取决于CPU能力、业务逻辑复杂性、数据等。</p><p id="9d4a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我用来生成基准的完整代码和项目位于这个GitHub repo:<a class="ae lk" href="https://github.com/alejandro-mosso/kafka-reactive-app.git" rel="noopener ugc nofollow" target="_blank">Kafka-reactive-app</a>。</p><h1 id="9b03" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">个案研究</h1><p id="91ac" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">我们的案例研究代表了一个数据管道，它接收股票运动，并将这些运动发送到一个反应角度应用程序。</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mo"><img src="../Images/5d84a0654cf66a9a2a9ed71de0fae24d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7qRebv0UKQ_B1OwvLK-p1g.jpeg"/></div></div></figure><p id="34e1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将关注数据是如何沿着我们的数据管道流动的。</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/93b3cb5e9499e3d16cc983948ea008ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:726/format:webp/1*nZvgMT1bjJTqdPDwa_jkJQ.jpeg"/></div></figure><p id="18ab" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">制作者</strong>:这是一个模拟微服务，生成CSV随机值来模拟一个源。该组件生成的所有记录都存储在一个主题中。</p><p id="e672" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">监听器</strong>:获取每条记录并执行数据类型验证。无效记录存储在不同的主题中。</p><p id="4662" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">登陆</strong>:将CSV转换成JSON。</p><p id="e3d4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">处理器</strong>:每条记录都被分支，在一个主题中存储股票价格，在另一个主题中存储股票信息。</p><p id="8ef2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> Messenger </strong>:这是一个web套接字，用于向Angular应用程序发送数据。</p><h1 id="28d2" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">设置您的环境:</h1><p id="a15c" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">要设置您的环境，只需使用这个<a class="ae lk" href="https://github.com/alejandro-mosso/kafka-reactive-app/blob/master/docker-compose.yml" rel="noopener ugc nofollow" target="_blank"> docker-compose.yml </a>文件运行“docker-compose up”。</p><p id="67df" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这将使用默认集群启动一个融合环境。一旦您的环境启动，转到<a class="ae lk" href="http://localhost:9021/" rel="noopener ugc nofollow" target="_blank"> http://localhost:9021/ </a>并创建以下主题:</p><ul class=""><li id="0b30" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">输入主题</li><li id="361e" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">着陆区</li><li id="ac27" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">着陆误差</li><li id="eb5c" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">中转区</li><li id="ba1b" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">股票价值</li><li id="c96f" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">库存比率</li><li id="5e78" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">库存比率不足</li><li id="7c7d" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">股票价格下跌</li></ul><h1 id="1d3b" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">1)以传统方式运行作业</h1><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/951386a7d4e6c2c28347d6e3761971a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:590/format:webp/1*PDwifHc2G0VSEUwiLuNX0g.png"/></div></figure><p id="69c2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，我们用java -jar以传统方式开始我们的生产者工作(在<a class="ae lk" href="https://github.com/alejandro-mosso/kafka-reactive-app/blob/master/producer/README.md" rel="noopener ugc nofollow" target="_blank"> REDME.md </a>文件中找到所有命令):</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/6ff3d26152cb2c7f0a200b36c9f62894.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/1*S0zbcfDOvhIj3_lS_TQgFA.png"/></div></figure><p id="d3fc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下图显示了该作业如何开始消耗CPU。我们可以看到，所有的CPU都使用了大约80%的总容量来处理一个任务。</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/c0be4112f1544f2f18aa9c9ad4a64962.png" data-original-src="https://miro.medium.com/v2/resize:fit:1154/format:webp/1*aOeXmL1KljD0B_7oUS1G2w.png"/></div></figure><p id="9f2c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这种方法下，我们得到了这样的数据生产吞吐量:</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/6addb3e2ca6aea181c30c49bf2361239.png" data-original-src="https://miro.medium.com/v2/resize:fit:984/format:webp/1*AQvZH__vaQYyOL0TRi_PKQ.png"/></div></figure><h1 id="99d5" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">2)使用无共享方法运行</h1><p id="6874" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">现在让我们看看这个作业在无共享架构下是如何工作的。Shared-nothing意味着我们的作业不会与任何其他进程共享CPU(这是Linux名称空间的主要特性，但不仅仅是隔离CPU，我们还可以隔离网络、磁盘、内存等)。</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div class="gh gi my"><img src="../Images/d3d56ff73335ac6911e7cbaa63c66358.png" data-original-src="https://miro.medium.com/v2/resize:fit:858/format:webp/1*CVmPcJSpF5IUcHdPxzNEzw.png"/></div></figure><p id="3b93" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">了解您的CPU架构非常重要。在我的例子中，我的CPU使用超线程，每个CPU有两个线程，这意味着如果我有4个物理CPU，我的操作系统将显示8个CPU，因此，如果我想使用单个物理CPU处理我的作业，我应该以这种方式运行我的作业:</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/1dca372dff66b76784fc76ee1edbc4dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:850/format:webp/1*vA6JGUIEjtHkFP0bO71BkA.png"/></div></figure><p id="d169" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您跟踪CPU，您应该会看到类似这样的内容:</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div class="gh gi na"><img src="../Images/f55f7ae1d41473cd462027ca5feb5351.png" data-original-src="https://miro.medium.com/v2/resize:fit:898/format:webp/1*WvmaIxOFMzUUURqxoz9I3A.png"/></div></figure><p id="3cb0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我没有让所有CPU都以大约80%的速度运行，而是只让一个CPU以100%的速度运行，并发性非常低，而且我的吞吐量稍微好一些:</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/3d07b20fab1fde5c8f474976f0a1ca2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:984/format:webp/1*PoP7LkyAbPd1VZk4JnbD4w.png"/></div></figure><h2 id="8692" class="nb lm iq bd ln nc nd dn lr ne nf dp lv kj ng nh lz kn ni nj md kr nk nl mh nm bi translated">传统方法与无共享</h2><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nn"><img src="../Images/f9cbdd0589e9f37ed8438d250c97475a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dbBLJFh1am2hX-b1B0iMuQ.png"/></div></div></figure><p id="d8a6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这非常有趣，因为使用单个CPU比使用所有CPU有更好的性能。如果你想更好地理解无共享是如何工作的，你应该读一读另一篇文章“<a class="ae lk" href="https://medium.com/swlh/lets-burn-it-with-shared-nothing-architecture-2662b02d50c9?source=friends_link&amp;sk=b130bc826537a3f20487ac3a963e354b" rel="noopener">让我们用无共享来烧掉它</a>”。</p><p id="e2b8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如我们在第一张图表中看到的，所有的CPU都在并发工作，试图将处理能力交给一个单独的任务。乍一看，这听起来很棒，但事实并非如此；在传统方法下，我们有一个严重的性能问题——每当CPU切换到并发处理单个任务时，它也会浪费时间:一个CPU会处理一小段时间，然后它会切换，下一个CPU会开始处理，依此类推。问题是，它给人的印象是所有的CPU都以总容量的80%工作，但我们有很多浪费。</p><p id="30c9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另一方面，当我们将进程绑定为仅使用一个CPU时，我们也减少了并发性，正如我们在第二个图表中看到的，数据生产率甚至有所提高，所有其他CPU看起来压力较小。</p><h1 id="6c7c" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">3)将吞吐量从600 KB/秒提高到10mb/秒</h1><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div class="gh gi no"><img src="../Images/86674e9f0a5e42f878d7bd0b6d589042.png" data-original-src="https://miro.medium.com/v2/resize:fit:586/format:webp/1*ESEH-orBPVouQhnNEKwiHw.png"/></div></figure><p id="9c7d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在生产者微服务中，我们没有任何复杂性，它只是一种持续产生价值的方法。我们管道中的下一个微服务是监听器:这个组件解析每个CSV记录，将其分成12个字段；然后，它验证每个字段的数据类型。与producer不同，listener确实有一些业务逻辑，并且在理论上，它应该需要更多的CPU来处理相同数量的数据。</p><p id="1718" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一段时间后，我们的制作人微服务已经生成了大约1000万条记录:</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi np"><img src="../Images/7cea51b660bd24970b4edd326f7f0f60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j_oAUudgm6iAPK0o4gr1XA.png"/></div></div></figure><p id="989e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们的侦听器组件将使用大约1000万条记录来拆分和验证它们。</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/1e96d086147057d079134709d887fa0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:854/format:webp/1*MPZYmHiGMOWm_YSecn_JNw.png"/></div></figure><p id="94f4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一旦我们启动监听器进程，我们的CPU表现如下:</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/16d1c7a26c9bfc64146b2f0218c8e4a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:796/format:webp/1*GhioJLFfqSv8OW6aErhHVQ.png"/></div></figure><p id="c7b8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这很奇怪，因为CPU看起来一点也不紧张，它只消耗了总CPU容量的60%。</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/5b4717e9ac04efc5101c0e7df4697c55.png" data-original-src="https://miro.medium.com/v2/resize:fit:938/format:webp/1*hhmUqARbSxfASMRFYlwzJA.png"/></div></figure><p id="12ed" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但更有趣的是吞吐量，这个比producer逻辑更复杂的作业有更好的性能。该图表显示监听器正在读取<strong class="ka ir">16mb/秒</strong>。</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/68d9cd08a9eb4157f894ab0af67efe5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:926/format:webp/1*pvTWzLukVsiowHwwK_2gog.png"/></div></figure><p id="a191" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在进行数据类型验证之后，工作是将<strong class="ka ir">10mb/秒</strong>写入着陆区主题。</p><p id="a082" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们在<strong class="ka ir"> 149.69秒</strong>内处理了1049万条记录。</p><p id="4008" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">那么，生产者微服务和听者微服务有什么区别呢？为什么听众比制作人有更好的表现？</p><p id="984f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Listener获得了显著的性能提升，因为这里我们使用了Apache Kafka流。</p><h1 id="c009" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">4)用Kafka主题和Kafka流进行数据转换</h1><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/f08df41face2e8369fbf9a887c2b3c1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:624/format:webp/1*PLAx1oYB_BJJQS7SSqG8zA.png"/></div></figure><p id="0940" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们做最后一个测试。现在我们想知道这个解决方案在进行数据转换时表现如何。</p><p id="8d27" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在管道中，下一个组件是“着陆”。这个微服务将CSV记录转换成JSON。</p><p id="f9aa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们正在读取大约990万条记录，因为验证流程拒绝了大约50万条记录。</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nv"><img src="../Images/dbebf0b4bef212573c5696d2d09ed28c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rOqoXHcNNirjVmeYGbSkNQ.png"/></div></div></figure><p id="c4be" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们再次开始我们的过程:</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/844e38361151e07c8822215f96e9438b.png" data-original-src="https://miro.medium.com/v2/resize:fit:838/format:webp/1*lN8-WatJhIR3B_ZF9n2Vug.png"/></div></figure><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/276fa3389762c80883c53e697d2c3c57.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/1*pwtnK_d49aksL4Yz0V0J9Q.png"/></div></figure><p id="b57f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">显然，读取吞吐量变慢了，现在我们正在读取<strong class="ka ir">6.25 MB/秒</strong>。</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/2400a353917080360e771a1d379de92e.png" data-original-src="https://miro.medium.com/v2/resize:fit:626/format:webp/1*RIu98YE8x8sO5dfWpfxJOA.png"/></div></figure><p id="3b84" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是该进程正在以更高的速度写入数据:<strong class="ka ir">15.01 MB/秒</strong>。</p><p id="11a3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们在输出中比在输入中有更高的吞吐量，这很容易解释，因为我们正在将CSV输入数据转换成JSON。JSON有额外的元数据，所以在输入和输出中我们都有990万条记录，但是在输出主题中数据的大小增加了，从917 MB增加到2.21 GB。</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nz"><img src="../Images/6728571f3c0fca64437f7fc4930c50ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gqkUIR9aXHH5LZVB5BBpYw.png"/></div></div></figure><p id="0921" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">整个过程花费了<strong class="ka ir"> 150.76秒</strong>来处理<strong class="ka ir">990万条</strong>记录，几乎与我们使用监听器验证<strong class="ka ir">1050万条</strong>记录中的数据类型的时间相同(<strong class="ka ir"> 149.69秒</strong>)。</p><h1 id="f8fb" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">结论</h1><p id="b829" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">为了获得最大的性能和可伸缩性，最好的组合是Kafka主题来传递微服务，Kafka流来处理数据。</p><p id="1a2b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你在没有微服务架构的情况下使用Kafka主题和Kafka流，你将错过无共享架构的好处。</p><p id="e4c6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">基本上，我提出了四种不同的场景和不同的结果:</p><p id="1968" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> 1)以传统方式运行作业:</strong> Quarkus在无共享架构之外运行。<br/> <strong class="ka ir"> 2)以无共享方式运行:</strong> Quarkus运行在无共享架构中。<br/> <strong class="ka ir"> 3)将你的吞吐量从600 KB/秒提升到10mb/秒:</strong> Quarkus + Kafka流运行在无共享架构中。<br/><strong class="ka ir">4)Kafka主题和Kafka流的数据转换:</strong>运行在无共享架构中的Quarkus + Kafka流。</p><p id="d86d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我邀请你进行你自己的测试，并在下面的评论区分享你的结果。</p></div></div>    
</body>
</html>