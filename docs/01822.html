<html>
<head>
<title>Swift: constraining protocol extensions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift:约束协议扩展</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/swift-constraining-protocol-extensions-e0152589b115?source=collection_archive---------29-----------------------#2020-07-12">https://blog.devgenius.io/swift-constraining-protocol-extensions-e0152589b115?source=collection_archive---------29-----------------------#2020-07-12</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/2cf9c368d01038999425fa1ebde192f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ARpFZa_2UBXMjaQZ-n8Qug.jpeg"/></div></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk translated">照片由<a class="ae ja" href="https://unsplash.com/@dbmartin00?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">大卫·布鲁克·马丁</a>在<a class="ae ja" href="/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><div class=""/><p id="0554" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">想象一下，我们需要用一个特殊的函数来扩展<code class="fe ky kz la lb b">Array</code>，这个函数将删除所有的重复项。这可以通过引用<code class="fe ky kz la lb b">Element</code>作为其内部值来实现。为了检查相等性，数组<code class="fe ky kz la lb b">Element</code>必须符合<code class="fe ky kz la lb b">Equatable</code>，这可以作为约束添加。将<code class="fe ky kz la lb b">Element</code>约束到<code class="fe ky kz la lb b">Equatable</code>意味着这个方法只适用于带有<code class="fe ky kz la lb b">Equatable</code>元素的数组。</p><pre class="lc ld le lf gt lg lb lh li aw lj bi"><span id="2f1a" class="lk ll jd lb b gy lm ln l lo lp">extension Array where Element: Equatable {<br/>   func unique() -&gt; [Element] {<br/>     // implementation<br/>   }<br/>}</span></pre><p id="da65" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这看起来是一个好的开始，但是更合理的做法是将这个扩展给予其他集合类型，而不仅仅是<code class="fe ky kz la lb b">Array</code>。使用这种方法，其他类型可以从此方法中受益，而不是扩展一个具体的类型。</p><pre class="lc ld le lf gt lg lb lh li aw lj bi"><span id="0ae5" class="lk ll jd lb b gy lm ln l lo lp">extension Collection where Element: Equatable {<br/>   func unique() -&gt; [Element] {<br/>     // implementation<br/>   }<br/>}</span></pre><p id="f0d3" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这种方法的问题可能是速度不够快，或者没有您所寻求的性能。这可以用<code class="fe ky kz la lb b">Hashable</code>代替<code class="fe ky kz la lb b">Equatable</code>来解决。<code class="fe ky kz la lb b">Hashable</code>是<code class="fe ky kz la lb b">Equatable</code>的子协议，这意味着 Swift 将选择最具体的分机进行工作。通过在<code class="fe ky kz la lb b">Collection</code>上定义两种方法，Swift 将选择最专业的一种。</p><p id="bca6" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您可以将关联类型约束到具体类型，而不是将它们约束到协议。假设我们有带有<code class="fe ky kz la lb b">likesCount</code>属性的<code class="fe ky kz la lb b">Picture</code> struct，它跟踪关注者喜欢一张图片的次数。</p><p id="3682" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在<code class="fe ky kz la lb b">Collection</code>可以扩展得到总点赞数。因为我们想将<code class="fe ky kz la lb b">Element</code>约束到<code class="fe ky kz la lb b">Picture</code>(具体类型)，所以可以使用<code class="fe ky kz la lb b">==</code>操作符。</p><pre class="lc ld le lf gt lg lb lh li aw lj bi"><span id="a091" class="lk ll jd lb b gy lm ln l lo lp">struct <!-- -->Picture: Hashable {<br/>   let likesCount: UInt<br/>}</span><span id="dc96" class="lk ll jd lb b gy lq ln l lo lp">extension Collection where Element == <!-- -->Picture<!-- --> {<br/>   var totalLikesCount: Int {<br/>      // implementation<br/>   }<br/>}</span></pre><p id="dc52" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">有了这个约束，无论<code class="fe ky kz la lb b">Collection</code>类型如何(只要它包含<code class="fe ky kz la lb b">Picture</code> s)，您都可以获得总的赞数。决定延期可能会很棘手。通常你可以在<code class="fe ky kz la lb b">Array</code>类型上有一个具体的扩展，但是如果这不令人满意，你可以扩展更低级的类型(在这个例子中是<code class="fe ky kz la lb b">Collection</code>)。如果这对你的情况还不够，你可以延长<code class="fe ky kz la lb b">Sequence</code>。</p></div></div>    
</body>
</html>