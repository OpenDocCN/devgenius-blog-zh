<html>
<head>
<title>Querying the Database in a Go Web App</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在 Go Web 应用程序中查询数据库</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/querying-the-database-in-a-go-web-app-21883d38fb82?source=collection_archive---------8-----------------------#2022-05-09">https://blog.devgenius.io/querying-the-database-in-a-go-web-app-21883d38fb82?source=collection_archive---------8-----------------------#2022-05-09</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="fb34" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">欢迎回到我的教程！上次，我们设置了 PostgreSQL 数据库的一个实例，并将其连接到我们的后端。这一次，我们将使用数据库并学习如何查询它。</p><h1 id="12ae" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">SQL 数据库快速介绍</h1><p id="e98f" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">尽管我们已经建立了数据库连接，但是您可能仍然不明白数据库是如何工作的。它就像我电脑上的文件浏览器吗？它是如何存储数据的？<em class="ll">查询</em>数据库意味着什么？我认为如果我们理解了数据库是如何工作的，SQL 语法会变得容易得多。</p><p id="6fe4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">PostgreSQL 就是所谓的<em class="ll"> SQL 数据库</em>的一个例子。SQL 数据库是一种以已定义的<em class="ll">模式</em>的格式存储数据的数据库。简单地说，这是一个美化了的电子表格，其中每个数据都存储为表中的一行。一个 SQL 数据库通常有几个定义数据格式的模式(表)。</p><p id="f29f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在我们的例子中，我们需要一个存储书籍数据的表。我们在 Go 中的结构定义如下:</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="e449" class="lv kj in lr b gy lw lx l ly lz">type BookData struct {<br/>    title string<br/>    author string<br/>    isbn string<br/>}</span></pre><p id="d3d1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">每本书都有标题、作者和 ISBN。我们数据库中的表看起来会像这样:</p><p id="398e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">标题作者 ISBN 泰坦之工具 Tim Ferriss 9781328683786 席特哈尔塔赫尔曼黑塞 9781529024043 原子习性 James Clear 9780735211292</p><p id="7669" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们将在本指南中重新定义模式和结构，以更好地满足我们的需求。</p><h1 id="5951" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">简单的 SQL 语法</h1><p id="7d31" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">现在我们知道了数据库是如何存储数据的，是时候学习如何使用它了。除非你使用 GUI 工具来简化操作，否则你将需要使用一种特殊的语言来操作数据库。即使你有一个 GUI 工具，知道如何使用 SQL 也是很好的。</p><p id="7184" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">SQL 是<em class="ll">结构化查询语言</em>的缩写，是操作数据库的主要方式。语法读起来像英语，所以很容易理解每行的意思。请求和编辑数据的行为被称为<em class="ll">查询</em>。</p><p id="9eec" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们从学习几个最重要的命令开始。此外，是的，习惯上使用全大写字母键入 SQL 命令，以将它们与数据区分开来。为了便于组织和阅读，您可以选择将查询语句分成多行。</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="8eef" class="lv kj in lr b gy lw lx l ly lz">CREATE DATABASE myDatabase;</span></pre><p id="0278" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">该命令创建一个数据库。我们已经在上一个教程中创建了数据库，所以我们可以跳过这一步。</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="e67f" class="lv kj in lr b gy lw lx l ly lz">CREATE TABLE myTable (<br/>    column1 dataType columnConstraints,<br/>    column2 dataType columnConstraints,<br/>    column3 dataType columnConstraints,<br/>    tableContrainsts<br/>);</span></pre><p id="718b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这就是如何创建像本教程第一部分中那样的表。</p><ul class=""><li id="9e1d" class="ma mb in jm b jn jo jr js jv mc jz md kd me kh mf mg mh mi bi translated">您选择表的名称。</li><li id="4684" class="ma mb in jm b jn mj jr mk jv ml jz mm kd mn kh mf mg mh mi bi translated">然后，您必须指定列名、数据类型和约束。</li></ul><p id="e4e0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">约束是分配给每列的选项。例如，<code class="fe mo mp mq lr b">NOT NULL</code>约束将强制该列具有非空值。一个<code class="fe mo mp mq lr b">PRIMARY KEY</code>约束将把该列指定为可以标识每一行的唯一值。</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="64ef" class="lv kj in lr b gy lw lx l ly lz">SELECT column1 FROM myTable WHERE condition;</span></pre><p id="29ec" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是从表中选择某些数据的方法。该命令是不言自明的:从满足条件的表中选择一列或一组列。</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="6352" class="lv kj in lr b gy lw lx l ly lz">INSERT INTO myTable (column1, column2, ...)<br/>VALUES (value1, value2, ...);</span></pre><p id="805a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是将数据插入特定列的方式。<code class="fe mo mp mq lr b">value1</code>被插入<code class="fe mo mp mq lr b">column1</code>，反之亦然。</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="ef59" class="lv kj in lr b gy lw lx l ly lz">UPDATE myTable<br/>SET column1 = value1, column2 = value2, ...<br/>WHERE condition;</span></pre><p id="37db" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这就是如何更新给定列中的现有值。</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="ff6b" class="lv kj in lr b gy lw lx l ly lz">DELETE myTable WHERE condition;</span></pre><p id="e15f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这就是删除符合条件的现有值的方法。</p><h1 id="45c0" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">备餐到位</h1><p id="b814" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">我们的数据库目前什么都没有。我们应该在后端做任何事情之前做好准备。让我们首先创建我们的表。</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="0dea" class="lv kj in lr b gy lw lx l ly lz">CREATE TABLE books (<br/>    isbn VARCHAR(13) PRIMARY KEY,<br/>    title VARCHAR(100) NOT NULL,<br/>    author VARCHAR(50) NOT NULL<br/>);</span></pre><p id="016f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个脚本创建了一个名为<code class="fe mo mp mq lr b">books</code>的表，该表包含列<code class="fe mo mp mq lr b">isbn</code>、<code class="fe mo mp mq lr b">title</code>和<code class="fe mo mp mq lr b">author</code>。</p><ul class=""><li id="b926" class="ma mb in jm b jn jo jr js jv mc jz md kd me kh mf mg mh mi bi translated"><code class="fe mo mp mq lr b">VARCHAR(length)</code>是最大长度的字符串使用的类型。<code class="fe mo mp mq lr b">VARCHAR(13)</code>将只接受不超过 13 个字符的字符串。我们将使用中间没有连字符的 ISBN 13，因此只分配 13 个字符听起来不错。</li><li id="dd10" class="ma mb in jm b jn mj jr mk jv ml jz mm kd mn kh mf mg mh mi bi translated"><code class="fe mo mp mq lr b">PRIMARY KEY</code>是应用于列的约束，用于在表中唯一标识一行。<code class="fe mo mp mq lr b">PRIMARY KEY</code>列中的所有项目必须是唯一的，不能为空。</li><li id="3a91" class="ma mb in jm b jn mj jr mk jv ml jz mm kd mn kh mf mg mh mi bi translated"><code class="fe mo mp mq lr b">NOT NULL</code>是一个约束，用于确保列中没有数据为空。</li></ul><p id="dd9c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">好了，我们创建了表。我们现在可以通过插入新行来播种数据库，但是我们将在后端这样做。如果您现在想添加一些书籍，可以继续使用以下脚本:</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="ccec" class="lv kj in lr b gy lw lx l ly lz">INSERT INTO books (isbn, title, author)<br/>VALUES ("9781328683786", "Teen Titans", "Tim Ferriss");</span><span id="d033" class="lv kj in lr b gy mr lx l ly lz">INSERT INTO books (isbn, title, author)<br/>VALUES ("9781529024043", "Siddhartha", "Herman Hesse");</span><span id="37ca" class="lv kj in lr b gy mr lx l ly lz">INSERT INTO books (isbn, title, author)<br/>VALUES ("9780735211292", "Atomic Habits", "James Clear");</span></pre><p id="77fa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">哎呀，我们在第一本书里打错了一个字。标题应该是<strong class="jm io">泰坦们的工具</strong>，而不是<strong class="jm io">少年泰坦</strong>！要解决这个问题，我们可以使用以下查询语句:</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="a362" class="lv kj in lr b gy lw lx l ly lz">UPDATE books<br/>SET title = "Tools of Titans"<br/>WHERE isbn = "9781328683786";</span></pre><p id="7681" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">很简单，对吧？</p><h1 id="2333" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">在 Go 中执行查询</h1><p id="d1f6" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">到目前为止，按照指南做得很好！现在我们将学习如何从我们的后端执行这些查询。让我们回到我们的代码。</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="f01b" class="lv kj in lr b gy lw lx l ly lz">// main.go<br/>package main</span><span id="0d58" class="lv kj in lr b gy mr lx l ly lz">import (<br/>    "database/sql"<br/>    "fmt"<br/>    "log"</span><span id="c101" class="lv kj in lr b gy mr lx l ly lz">    "github.com/gorilla/mux"<br/>    _"github.com/lib/pq"<br/>)</span><span id="8ef5" class="lv kj in lr b gy mr lx l ly lz">var DB *sql.DB</span><span id="8415" class="lv kj in lr b gy mr lx l ly lz">const (<br/>    HOST = "localhost"<br/>    PORT = 5432<br/>    USER = "jacob"<br/>    PASSWORD = "password"<br/>    DBNAME = "bookstoreDB"<br/>)</span><span id="b5e5" class="lv kj in lr b gy mr lx l ly lz">func main() {<br/>    connString := fmt.Sprintf(<br/>        "host=%s port=%d user=%s password=%s dbname=%s sslmode=disable",<br/>        HOST, PORT, USER, PASSWORD, DBNAME,<br/>    )</span><span id="a309" class="lv kj in lr b gy mr lx l ly lz">    DB, err := sql.Open("postgres", connString)<br/>    if err != nil {<br/>        log.Fatal(err)<br/>    }<br/>    defer DB.Close()</span><span id="126c" class="lv kj in lr b gy mr lx l ly lz">    // mux definition and route registration (from last tutorial)<br/>    r := mux.NewRouter()</span><span id="51e7" class="lv kj in lr b gy mr lx l ly lz">    r.HandleFunc("/", homeHandler)</span><span id="7b58" class="lv kj in lr b gy mr lx l ly lz">    booksSubR := r.PathPrefix("/books").Subrouter()</span><span id="fcc1" class="lv kj in lr b gy mr lx l ly lz">    booksSubR.HandleFunc("/all", AllHandler).Methods(http.MethodGet)<br/>    booksSubR.HandleFunc("/{isbn}", IspnHandler).Methods(http.MethodGet)<br/>    booksSubR.HandleFunc("/new", NewHandler).Methods(http.MethodPost)<br/>    booksSubR.HandleFunc("/update", UpdateHandler).Methods(http.MethodPut)<br/>    booksSubR.HandleFunc("/delete/{isbn}", DeleteIspnHandler).Methods(http.MethodDelete)</span><span id="b4c4" class="lv kj in lr b gy mr lx l ly lz">    log.Fatal(http.ListenAndServe(":8090", r))<br/>}</span></pre><p id="f0ac" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们应该定义到达相应端点时触发的处理程序。为了减少混乱，让我们创建一个名为<code class="fe mo mp mq lr b">controllers.go</code>的新文件，并在那里编写我们的控制器。如果你想知道，我会互换使用术语<em class="ll">控制器</em>和<em class="ll">操作者</em>。</p><p id="3b44" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在创建<code class="fe mo mp mq lr b">controllers.go</code>之前，我们需要创建一个反映数据库模式的已定义模型。这些模型应该放在<code class="fe mo mp mq lr b">models.go</code>里面。</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="d723" class="lv kj in lr b gy lw lx l ly lz">// models.go<br/>package main</span><span id="380a" class="lv kj in lr b gy mr lx l ly lz">type Book struct {<br/>    Isbn string `json:"isbn"`<br/>    Title string `json:"title"`<br/>    Author string `json:"author"`<br/>}</span></pre><p id="f55a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在我们已经定义了<code class="fe mo mp mq lr b">Book</code>，我们可以在我们的<code class="fe mo mp mq lr b">controllers.go</code>文件中使用它。</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="a17d" class="lv kj in lr b gy lw lx l ly lz">// controllers.go<br/>package main</span><span id="950c" class="lv kj in lr b gy mr lx l ly lz">import (<br/>    "database/sql"<br/>    "net/http"<br/>)</span><span id="f0bf" class="lv kj in lr b gy mr lx l ly lz">func AllHandler(w http.ResponseWriter, r *http.Request) {<br/>    var books = make([]Book, 0)</span><span id="a4ec" class="lv kj in lr b gy mr lx l ly lz">    results, err := DB.Query("SELECT * FROM books;")<br/>    if err != nil {<br/>        log.Println("failed to execute query", err)<br/>        w.WriteHeader(500)<br/>        return<br/>    }</span><span id="4c1c" class="lv kj in lr b gy mr lx l ly lz">    for results.Next() {<br/>        var b Book</span><span id="6a42" class="lv kj in lr b gy mr lx l ly lz">        err = results.Scan(&amp;b.isbn, &amp;b.title, &amp;b.author)<br/>        if err != nil {<br/>            log.Println("failed to scan", err)<br/>            w.WriteHeader(500)<br/>            return<br/>        }</span><span id="5c55" class="lv kj in lr b gy mr lx l ly lz">        books = append(books, b)<br/>    }</span><span id="1add" class="lv kj in lr b gy mr lx l ly lz">    json.NewEncoder(w).Encode(books)<br/>}</span><span id="cb92" class="lv kj in lr b gy mr lx l ly lz">// other handler definitions go here</span></pre><p id="9c63" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是一个控制器函数如何查询数据库、将结果解析为 JSON，然后将它们发送回用户的示例。</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="b1ee" class="lv kj in lr b gy lw lx l ly lz">var books = make([]Book, 0)</span></pre><p id="de63" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们创建一个<code class="fe mo mp mq lr b">Book</code>对象的切片。这用于存储查询结果。</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="2379" class="lv kj in lr b gy lw lx l ly lz">results, err := DB.Query("SELECT * FROM books;")<br/>if err != nil {<br/>    log.Println("failed to execute query", err)<br/>    w.WriteHeader(500)<br/>    return<br/>}</span></pre><p id="58dc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们以前没见过这个代码。这是执行查询的代码片段。</p><ul class=""><li id="0f8b" class="ma mb in jm b jn jo jr js jv mc jz md kd me kh mf mg mh mi bi translated">我们在<code class="fe mo mp mq lr b">main</code>函数中创建了<code class="fe mo mp mq lr b">DB</code>。我们在<code class="fe mo mp mq lr b">DB</code>上使用<code class="fe mo mp mq lr b">Query</code>方法来执行查询。</li><li id="12b0" class="ma mb in jm b jn mj jr mk jv ml jz mm kd mn kh mf mg mh mi bi translated">查询语句是一个字符串:<code class="fe mo mp mq lr b">SELECT * FROM books;</code>。星号表示我们想要从表<code class="fe mo mp mq lr b">books</code>中选择所有记录。</li><li id="d49f" class="ma mb in jm b jn mj jr mk jv ml jz mm kd mn kh mf mg mh mi bi translated">该方法返回类型为<code class="fe mo mp mq lr b">sql.Rows</code>的<code class="fe mo mp mq lr b">results</code>。这将逐行存储查询的结果。光有这些是不够的；我们需要将内容扫描到另一个变量中。</li><li id="4e5d" class="ma mb in jm b jn mj jr mk jv ml jz mm kd mn kh mf mg mh mi bi translated">如果有错误，我们用 HTTP 错误代码 500 来响应，这表示服务器端有问题。</li></ul><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="80d2" class="lv kj in lr b gy lw lx l ly lz">for results.Next() {<br/>    var b Book</span><span id="f256" class="lv kj in lr b gy mr lx l ly lz">    err = results.Scan(&amp;b.isbn, &amp;b.title, &amp;b.author)<br/>    if err != nil {<br/>        log.Println("failed to scan", err)<br/>        w.WriteHeader(500)<br/>        return<br/>    }</span><span id="a94c" class="lv kj in lr b gy mr lx l ly lz">    books = append(books, b)<br/>}</span></pre><p id="b2b4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是我们保存查询结果的地方。</p><ul class=""><li id="aad3" class="ma mb in jm b jn jo jr js jv mc jz md kd me kh mf mg mh mi bi translated"><code class="fe mo mp mq lr b">results.Next</code>遍历<code class="fe mo mp mq lr b">results</code>的行。因为我们查询了所有记录，所以有许多行需要迭代。</li><li id="ddbb" class="ma mb in jm b jn mj jr mk jv ml jz mm kd mn kh mf mg mh mi bi translated"><code class="fe mo mp mq lr b">results.Scan</code>将行数据扫描到目标目的地。这里，我们扫描到一个名为<code class="fe mo mp mq lr b">b</code>的<code class="fe mo mp mq lr b">Book</code>实例。</li><li id="a240" class="ma mb in jm b jn mj jr mk jv ml jz mm kd mn kh mf mg mh mi bi translated">一旦扫描完成，我们将<code class="fe mo mp mq lr b">b</code>附加到<code class="fe mo mp mq lr b">books</code>切片上。</li><li id="d431" class="ma mb in jm b jn mj jr mk jv ml jz mm kd mn kh mf mg mh mi bi translated">如果有错误，我们用 HTTP 错误代码 500 来响应，这表示服务器端有问题。</li></ul><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="e91a" class="lv kj in lr b gy lw lx l ly lz">json.NewEncoder(w).Encode(books)</span></pre><p id="5e54" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这很简单。它将<code class="fe mo mp mq lr b">books</code>片编码成 JSON，然后将其发送回用户。</p><h1 id="25d3" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">处理发布请求</h1><p id="dd4b" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">我们需要处理向数据库添加新书的请求。基本操作与上一个示例相同，但是查询方法会略有不同。</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="b88e" class="lv kj in lr b gy lw lx l ly lz">// controllers.go<br/>package main</span><span id="a108" class="lv kj in lr b gy mr lx l ly lz">import (<br/>    "database/sql"<br/>    "net/http"<br/>)</span><span id="a367" class="lv kj in lr b gy mr lx l ly lz">func NewHandler(w http.ResponseWriter, r *http.Request) {<br/>    var b Book</span><span id="e1ed" class="lv kj in lr b gy mr lx l ly lz">    err := json.NewDecoder(r.Body).Decode(&amp;b)<br/>    if err != nil {<br/>        log.Println("error while decoding r.Body", err)<br/>        w.WriteHeader(400)<br/>        return<br/>    }</span><span id="f8db" class="lv kj in lr b gy mr lx l ly lz">    queryStmt := `<br/>        INSERT INTO books (isbn, title, author)<br/>        VALUES ($1, $2, $3)<br/>        RETURNING isbn;<br/>    `<br/>    var isbn string<br/>    err := DB.QueryRow(queryStmt, &amp;b.isbn, &amp;b.title, &amp;b.author).Scan(&amp;isbn)<br/>    if err != nil {<br/>        log.Println("failed to execute query", err)<br/>        w.WriteHeader(500)<br/>        return<br/>    }</span><span id="6ac3" class="lv kj in lr b gy mr lx l ly lz">    log.Println("%s has been added to the database", isbn)<br/>}</span></pre><p id="2861" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">代码看起来类似于我们的第一个例子，但略有不同。</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="4f32" class="lv kj in lr b gy lw lx l ly lz">var b Book</span><span id="1a0f" class="lv kj in lr b gy mr lx l ly lz">err := json.NewDecoder(r.Body).Decode(&amp;b)<br/>if err != nil {<br/>    log.Println("error while decoding r.Body", err)<br/>    w.WriteHeader(400)<br/>    return<br/>}</span></pre><ul class=""><li id="06d2" class="ma mb in jm b jn jo jr js jv mc jz md kd me kh mf mg mh mi bi translated">因为用户将发送一个 JSON 对象作为请求体，所以我们需要以一种 Go-friendly 格式对它进行封送。</li><li id="88cb" class="ma mb in jm b jn mj jr mk jv ml jz mm kd mn kh mf mg mh mi bi translated">我们创建了一个名为<code class="fe mo mp mq lr b">b</code>的<code class="fe mo mp mq lr b">Book</code>实例，并将请求体解码给它。</li><li id="88c8" class="ma mb in jm b jn mj jr mk jv ml jz mm kd mn kh mf mg mh mi bi translated">如果出现错误，这意味着请求体无效，因此我们返回错误代码 400。</li></ul><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="4fea" class="lv kj in lr b gy lw lx l ly lz">queryStmt := `<br/>    INSERT INTO books (isbn, title, author)<br/>    VALUES ($1, $2, $3)<br/>    RETURNING isbn;<br/>`<br/>var isbn string<br/>err := DB.QueryRow(queryStmt, &amp;b.isbn, &amp;b.title, &amp;b.author).Scan(&amp;isbn)<br/>if err != nil {<br/>    log.Println("failed to execute query", err)<br/>    w.WriteHeader(500)<br/>    return<br/>}</span><span id="e670" class="lv kj in lr b gy mr lx l ly lz">log.Println("%s has been added to the database", isbn)</span></pre><p id="2ae1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这就是我们如何处理<code class="fe mo mp mq lr b">INSERT</code>语句或任何需要我们动态创建新查询语句的语句，比如<code class="fe mo mp mq lr b">UPDATE</code>。</p><ul class=""><li id="ccfc" class="ma mb in jm b jn jo jr js jv mc jz md kd me kh mf mg mh mi bi translated"><code class="fe mo mp mq lr b">queryStmt</code>是查询语句。关注第二行——它有<code class="fe mo mp mq lr b">$1, $2, $3</code>。这些是我们稍后将插入的数据的占位符。因为一个人的<code class="fe mo mp mq lr b">INSERT</code>语句会和其他人的不一样，所以我们不能只有一个静态的查询语句。在用户告诉我们之前，我们怎么知道他们想要添加什么书呢？</li><li id="25b8" class="ma mb in jm b jn mj jr mk jv ml jz mm kd mn kh mf mg mh mi bi translated">末尾的<code class="fe mo mp mq lr b">RETURNING isbn;</code>行将返回添加的图书的<code class="fe mo mp mq lr b">isbn</code>。这是需要保存的有用数据，我们可以用它来做任何我们想做的事情。</li><li id="932f" class="ma mb in jm b jn mj jr mk jv ml jz mm kd mn kh mf mg mh mi bi translated">根据查询语句，我们可以肯定地知道在查询之后只会返回一行。这就是为什么我们使用<code class="fe mo mp mq lr b">sql.QueryRow</code>而不是<code class="fe mo mp mq lr b">sql.Query</code>。</li><li id="a1b1" class="ma mb in jm b jn mj jr mk jv ml jz mm kd mn kh mf mg mh mi bi translated">在<code class="fe mo mp mq lr b">DB.QueryRow</code>中，我们传入我们的查询语句，并用数据替换<code class="fe mo mp mq lr b">$1, $2, $3</code>。顺序很重要，所以在我们的例子中，<code class="fe mo mp mq lr b">&amp;b.isbn</code>将替换<code class="fe mo mp mq lr b">$1</code>，反之亦然。<code class="fe mo mp mq lr b">&amp;b.isbn</code>、<code class="fe mo mp mq lr b">&amp;b.title</code>和<code class="fe mo mp mq lr b">&amp;b.author</code>是我们之前解码的<code class="fe mo mp mq lr b">b</code>的字段。</li><li id="db2e" class="ma mb in jm b jn mj jr mk jv ml jz mm kd mn kh mf mg mh mi bi translated">如果有错误，我们用 HTTP 错误代码 500 来响应，这表示服务器端有问题。</li></ul><p id="88d9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您将能够从这里了解如何编写其他控制器函数。祝你好运！查看这些资源来帮助您:</p><ul class=""><li id="a283" class="ma mb in jm b jn jo jr js jv mc jz md kd me kh mf mg mh mi bi translated"><a class="ae ms" href="https://pkg.go.dev/database/sql" rel="noopener ugc nofollow" target="_blank"> sql 包—数据库/sql — pkg.go.dev </a></li><li id="864f" class="ma mb in jm b jn mj jr mk jv ml jz mm kd mn kh mf mg mh mi bi translated"><a class="ae ms" href="https://www.postgresqltutorial.com" rel="noopener ugc nofollow" target="_blank"> PostgreSQL 教程</a></li></ul><h1 id="e878" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">结论</h1><p id="84a0" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">祝贺你完成这部分教程。我们现在已经有了一个非常基本的 REST API，并且正在运行。运行代码，启动你最喜欢的客户端(我的是 cURL 和 Postman)，然后开始测试！随意添加更多的控制器和扩展。在构建 API 方面有更高级的主题，但是对于学习目的来说，这已经足够了。我将很快进入更高级的话题，敬请关注！</p><p id="1a7b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你也可以在<a class="ae ms" href="https://dev.to/jpoly1219/querying-the-database-in-a-go-web-app-dm" rel="noopener ugc nofollow" target="_blank"> Dev.to </a>和<a class="ae ms" href="https://jpoly1219.github.io" rel="noopener ugc nofollow" target="_blank">我的个人网站</a>上阅读这个帖子。</p></div></div>    
</body>
</html>