<html>
<head>
<title>When Deno meets Wikidata</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">当德诺遇到维基数据</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/when-deno-meets-wikidata-302f8e5b6700?source=collection_archive---------23-----------------------#2020-06-20">https://blog.devgenius.io/when-deno-meets-wikidata-302f8e5b6700?source=collection_archive---------23-----------------------#2020-06-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="53c2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最近<a class="ae kl" href="https://deno.land/v1" rel="noopener ugc nofollow" target="_blank"> Deno 1.0 </a>发布了。我使用Javascript和<a class="ae kl" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank"> Node.js </a>已经有一段时间了。然而，我对Typescript的实验非常有限。Deno为Javascript和Typescript提供了一个安全的运行时。这篇文章是关于我用Deno和Typescript访问Wikidata的实验。如果你一直在关注我过去的一些作品，如<a class="ae kl" href="https://github.com/johnsamuelwrites/wdprop" rel="noopener ugc nofollow" target="_blank"> WDProp </a>或<a class="ae kl" href="https://github.com/johnsamuelwrites/WikiProvenance" rel="noopener ugc nofollow" target="_blank"> WikiProvenance </a>，你可能已经注意到这两个作品都是用普通的Javascript开发的，没有任何Node.js模块。然而，考虑到Typescript的静态类型，我想使用<a class="ae kl" href="https://deno.land/" rel="noopener ugc nofollow" target="_blank"> Deno </a>来访问Wikidata。而且前期开发体验还算顺利。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/8319c1103002b1779e5447afbfa5e1b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LwWemvE8agLxBhTz"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">萨姆·欧文在<a class="ae kl" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><h1 id="da7a" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">德诺</h1><p id="63fd" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">安装Deno很容易，可以在用户环境中本地安装。</p><pre class="kn ko kp kq gt mf mg mh mi aw mj bi"><span id="620b" class="mk ld iq mg b gy ml mm l mn mo">$ curl -fsSL https://deno.land/x/install/install.sh | sh ######################################################################## 100,0%##O#- # ######################################################################## 100,0% Archive: /home/john/.deno/bin/deno.zip inflating: deno Deno was installed successfully to /home/john/.deno/bin/deno</span></pre><p id="3c6f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">手动将<code class="fe mp mq mr mg b">deno</code>目录添加到我的<code class="fe mp mq mr mg b">$HOME/.bashrc</code>之后，我就可以开始使用它了。</p><pre class="kn ko kp kq gt mf mg mh mi aw mj bi"><span id="dafe" class="mk ld iq mg b gy ml mm l mn mo">export DENO_INSTALL="/home/john/.deno" export PATH="$DENO_INSTALL/bin:$PATH"</span></pre><p id="8367" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了确保我的更改得到考虑，我运行了</p><pre class="kn ko kp kq gt mf mg mh mi aw mj bi"><span id="047b" class="mk ld iq mg b gy ml mm l mn mo">$ source $HOME/.bashrc</span></pre><p id="2ff3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在撰写本文时，我安装了以下版本的Deno。</p><pre class="kn ko kp kq gt mf mg mh mi aw mj bi"><span id="6f42" class="mk ld iq mg b gy ml mm l mn mo">    $ deno --version<br/>      deno 1.1.0<br/>      v8 8.4.300<br/>      typescript 3.9.2</span></pre><p id="cb44" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我的第一个<code class="fe mp mq mr mg b">Hello World</code>程序是在<code class="fe mp mq mr mg b">hello.ts</code>文件中编写的</p><pre class="kn ko kp kq gt mf mg mh mi aw mj bi"><span id="dbf8" class="mk ld iq mg b gy ml mm l mn mo">console.log("Hello World!")</span></pre><p id="0048" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">执行它需要<code class="fe mp mq mr mg b">run</code>选项，我可以看到文件被编译，输出可以在终端上看到。</p><pre class="kn ko kp kq gt mf mg mh mi aw mj bi"><span id="3e91" class="mk ld iq mg b gy ml mm l mn mo">$ deno run hello.ts <br/>Compile file:///home/john/deno/hello.ts <br/>Hello World!</span></pre><p id="fa39" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这样我就可以用<code class="fe mp mq mr mg b">deno</code>运行我的打字稿程序了。</p><h1 id="da0d" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">维基数据</h1><p id="6eeb" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">我的下一个目标是利用简单的SPARQL查询并从<a class="ae kl" href="https://query.wikidata.org/" rel="noopener ugc nofollow" target="_blank"> Wikidata SPARQL端点</a>获取数据。例如，下面的SPARQL查询将给出来自Wikidata的10个人。</p><pre class="kn ko kp kq gt mf mg mh mi aw mj bi"><span id="eb6d" class="mk ld iq mg b gy ml mm l mn mo">SELECT ?item { ?item wdt:P31 wd:Q5 } LIMIT 10</span></pre><h1 id="cac8" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">Deno和Wikidata</h1><p id="3ca9" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">利用Wikidata SPARQL端点，我首先编写了下面的代码<code class="fe mp mq mr mg b">fetch.ts</code>。</p><pre class="kn ko kp kq gt mf mg mh mi aw mj bi"><span id="d1c7" class="mk ld iq mg b gy ml mm l mn mo">   const result = await fetch("https://query.wikidata.org/sparql?query=SELECT%20%3Fitem%20%7B%0A%20%20%3Fitem%20wdt%3AP31%20wd%3AQ5%0A%7D%0ALIMIT%2010&amp;format=json");<br/>   const data = await result.json();<br/>   console.log(data.results)</span></pre><p id="3cab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">继续上面显示的相同执行风格，然而一个简单的<code class="fe mp mq mr mg b">deno run</code>给出了以下错误:</p><pre class="kn ko kp kq gt mf mg mh mi aw mj bi"><span id="c211" class="mk ld iq mg b gy ml mm l mn mo">    $ deno run fetch.ts<br/>     Compile file:///home/john/deno/fetch.ts<br/>     error: Uncaught PermissionDenied: network access to "https://query.wikidata.org/sparql?query=SELECT%20%3Fitem%20%7B%0A%20%20%3Fitem%20wdt%3AP31%20wd%3AQ5%0A%7D%0ALIMIT%2010&amp;format=jsn", run again with the --allow-net flag<br/>        at unwrapResponse ($deno$/ops/dispatch_json.ts:43:11)<br/>        at Object.sendAsync ($deno$/ops/dispatch_json.ts:98:10)<br/>        at async fetch ($deno$/web/fetch.ts:265:27)<br/>        at async file:///home/john/contributions/deno/fetch.ts:1:16</span></pre><p id="1c1a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是<code class="fe mp mq mr mg b">deno</code>有趣的地方。与node不同，deno需要用户的许可才能连接到互联网。因此选项<code class="fe mp mq mr mg b">--allow-net</code>需要和<code class="fe mp mq mr mg b">deno run</code>一起使用来运行上面的文件。</p><pre class="kn ko kp kq gt mf mg mh mi aw mj bi"><span id="fcf2" class="mk ld iq mg b gy ml mm l mn mo">$ deno run --allow-net fetch.ts <br/>      {<br/>        bindings: [<br/>          { item: { type: "uri", value: "http://www.wikidata.org/entity/Q23" } },<br/>          { item: { type: "uri", value: "http://www.wikidata.org/entity/Q42" } },<br/>          { item: { type: "uri", value: "http://www.wikidata.org/entity/Q76" } },<br/>          { item: { type: "uri", value: "http://www.wikidata.org/entity/Q80" } },<br/>          { item: { type: "uri", value: "http://www.wikidata.org/entity/Q91" } },<br/>          { item: { type: "uri", value: "http://www.wikidata.org/entity/Q157" } },<br/>          { item: { type: "uri", value: "http://www.wikidata.org/entity/Q181" } },<br/>          { item: { type: "uri", value: "http://www.wikidata.org/entity/Q185" } },<br/>          { item: { type: "uri", value: "http://www.wikidata.org/entity/Q186" } },<br/>          { item: { type: "uri", value: "http://www.wikidata.org/entity/Q192" } }<br/>        ]<br/>      }</span></pre><p id="560b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下一个目标是利用函数，将调用Wikidata和打印结果的逻辑分开。首先，在文件<code class="fe mp mq mr mg b">wdqs.ts</code>中创建一个函数来查询Wikidata并处理适当的响应/错误。请注意，该函数已被声明为异步的，并且还被声明为导出的，即，它可以在其他类型脚本文件中使用。</p><pre class="kn ko kp kq gt mf mg mh mi aw mj bi"><span id="6cbe" class="mk ld iq mg b gy ml mm l mn mo">export async function query_wikidata(query: string){<br/>    let queryresults:object = [];<br/>    await fetch(query)<br/>    .then(response =&gt; {<br/>      if (!response.ok) {<br/>        throw new Error("Problem in obtaining a response");<br/>      }<br/>      return response.json();<br/>    })<br/>    .then(results =&gt; {<br/>      queryresults = results.results.bindings;<br/>    })<br/>    .catch(error =&gt; {<br/>      console.error('Error in calling Wikidata API', error);<br/>    });<br/>    return (queryresults);<br/>  }</span></pre><p id="daca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，这个函数被导入到另一个文件<code class="fe mp mq mr mg b">query.ts</code>中。参见导入函数<code class="fe mp mq mr mg b">query_wikidata()</code>的第一行。在这个文件中，SPARQL端点的URL作为输入传递。并且一旦获得结果，就获得了不同人类的维基数据标识符。</p><pre class="kn ko kp kq gt mf mg mh mi aw mj bi"><span id="4b80" class="mk ld iq mg b gy ml mm l mn mo">  import {query_wikidata} from "./wdqs.ts"<br/>  <br/>  let promise = query_wikidata("https://query.wikidata.org/sparql?query=SELECT%20%3Fitem%20%7B%0A%20%20%3Fitem%20wdt%3AP31%20wd%3AQ5%0A%7D%0ALIMIT%2010&amp;format=json")<br/>  promise.then(<br/>     (result: any) =&gt; {<br/>       for (let row of result) {<br/>         console.log(row.item.value)<br/>       }<br/>     });</span></pre><p id="3027" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，使用<code class="fe mp mq mr mg b">deno</code>运行新文件<code class="fe mp mq mr mg b">query.ts</code>。</p><pre class="kn ko kp kq gt mf mg mh mi aw mj bi"><span id="8c62" class="mk ld iq mg b gy ml mm l mn mo">$ deno run --allow-net query.ts <br/>  Compile file:///home/john/deno/query.ts<br/>  http://www.wikidata.org/entity/Q23<br/>  http://www.wikidata.org/entity/Q42<br/>  http://www.wikidata.org/entity/Q76<br/>  http://www.wikidata.org/entity/Q80<br/>  http://www.wikidata.org/entity/Q91<br/>  http://www.wikidata.org/entity/Q157<br/>  http://www.wikidata.org/entity/Q181<br/>  http://www.wikidata.org/entity/Q185<br/>  http://www.wikidata.org/entity/Q186<br/>  http://www.wikidata.org/entity/Q192</span></pre><p id="6dc0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我喜欢<code class="fe mp mq mr mg b">deno</code> <a class="ae kl" href="https://deno.land/manual/getting_started/permissions" rel="noopener ugc nofollow" target="_blank">在运行脚本之前询问用户权限</a>的方式。有像<code class="fe mp mq mr mg b">--allow-read</code>或<code class="fe mp mq mr mg b">--allow-net</code>这样的标志，确保没有这些标志<code class="fe mp mq mr mg b">deno</code>不会分别访问本地文件系统和本地环境。当前使用URL导入函数的方式(这里不讨论)非常有趣。我想在未来的Wikidata相关项目中进一步探索Typescript和Deno。</p></div><div class="ab cl ms mt hu mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ij ik il im in"><p id="30ed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mz">最初发布于</em><a class="ae kl" href="https://johnsamuel.info/en/programming/deno-wikidata.html" rel="noopener ugc nofollow" target="_blank"><em class="mz">https://John Samuel . info</em></a><em class="mz">。</em></p></div></div>    
</body>
</html>