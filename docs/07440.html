<html>
<head>
<title>GitOps for data — Hands-on with Jenkins, Snowflake and dbt on AWS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GitOps for data —在 AWS 上与 Jenkins、Snowflake 和 dbt 一起实践</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/gitops-flow-for-data-hands-on-with-jenkins-snowflake-and-dbt-on-aws-16258e575ec3?source=collection_archive---------7-----------------------#2022-03-25">https://blog.devgenius.io/gitops-flow-for-data-hands-on-with-jenkins-snowflake-and-dbt-on-aws-16258e575ec3?source=collection_archive---------7-----------------------#2022-03-25</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/57cc3709dbb599df06cfc490e03d0b10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*vXfFFqSOaFmwnWrU.png"/></div></div></figure><p id="507f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你有没有想过用 GitOps 和 Jenkins 一起部署数据管道？在这个实践教程中，我们将使用 AWS、Snowflake 和 dbt 在 Groovy 中创建我们自己的领域特定语言。</p><p id="3e67" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个想法是创建我们自己的抽象，开发者不需要理解 GitOps 流背后的复杂性。开发人员只需提供一个小的声明性数据管道文件。</p><p id="1695" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">不泄漏任何命令逻辑意味着我们可以在不影响现有 dbt 项目的情况下不断改进 GitOps 代码。</p><p id="5286" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">读者注意:如果你对 Jenkins、git、dbt 和 snowflake 有基本的了解，这篇文章可能才有意义。</strong></p><h1 id="f95a" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">GitOps 工作流程</h1><figure class="ls lt lu lv gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lr"><img src="../Images/2346190644ddb146122eba248ead791a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Q1q3ovhdX7zZWiaV.png"/></div></div></figure><p id="34ec" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们描述一个典型的数据管道开发工作流程:</p><p id="5365" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">客户要求在现有的数据产品中加入这一新的闪亮功能，这将使我们的公司如虎添翼。</p><p id="2d0b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">开发人员快速启动并从主分支(生产)创建一个特性分支。开发人员可能会召集一些同事，一起开始创建这个全新功能的第一个原型。</p><p id="f1b2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">开发人员现在创建一个拉取请求，由其他同事和客户审阅。在一些来回和一些代码变更之后，拉请求被评审者接受。</p><p id="caae" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后，开发人员将代码与主分支合并，并将代码部署到生产中。</p><blockquote class="lw"><p id="58b8" class="lx ly in bd lz ma mb mc md me mf ks dk translated"><strong class="ak">我们想让这个工作流程完全自动化！</strong></p></blockquote><p id="7000" class="pw-post-body-paragraph jv jw in jx b jy mg ka kb kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated">我们的 GitOps 流程应满足以下要求:</p><ul class=""><li id="b5e3" class="ml mm in jx b jy jz kc kd kg mn kk mo ko mp ks mq mr ms mt bi translated">每个开发分支都有自己的游乐场，主分支上的代码将投入生产。</li><li id="88ef" class="ml mm in jx b jy mu kc mv kg mw kk mx ko my ks mq mr ms mt bi translated">在进入生产之前，不允许直接提交给 master 来强制通过 pull 请求执行代码和客户审查。</li><li id="0050" class="ml mm in jx b jy mu kc mv kg mw kk mx ko my ks mq mr ms mt bi translated">每一次生产部署都应该标记一个新的版本号。</li><li id="2a1f" class="ml mm in jx b jy mu kc mv kg mw kk mx ko my ks mq mr ms mt bi translated">工作流应该由简单的 DSL 驱动，易于分析工程师学习。不需要每个开发人员都成为开发运营专家。</li><li id="dc76" class="ml mm in jx b jy mu kc mv kg mw kk mx ko my ks mq mr ms mt bi translated">每个分支都应该为数据产品的开发者和用户提供最新的文档</li></ul><h1 id="7e93" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">创建我们自己的 DSL</h1><p id="78b9" class="pw-post-body-paragraph jv jw in jx b jy mz ka kb kc na ke kf kg nb ki kj kk nc km kn ko nd kq kr ks ig bi translated">首先考虑如何使用你的代码总是明智的。所以首先我们要设计自己的<a class="ae ne" href="https://www.jetbrains.com/mps/concepts/domain-specific-languages/#:~:text=What%20are%20Domain%20Specific%20Languages,from%20the%20field%20or%20domain." rel="noopener ugc nofollow" target="_blank"> DSL(领域特定语言)</a>。我们希望让其他开发人员开始构建自己的数据管道变得尽可能简单。</p><p id="8e96" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">可以通过提供 Jenkinsfile 来配置数据管道。当代码被推送到 git repo 时，这个文件将被 Jenkins 获取。</p><pre class="ls lt lu lv gt nf ng nh ni aw nj bi"><span id="7c45" class="nk ku in ng b gy nl nm l nn no"><a class="ae ne" href="http://twitter.com/Library" rel="noopener ugc nofollow" target="_blank">@Library</a>('dbt-snowflake-jenkins-shared-library')</span><span id="8d0e" class="nk ku in ng b gy np nm l nn no">def acceptance = [<br/>  account: "&lt;your snowflake account&gt;",<br/>  database: "&lt;your snowflake database&gt;",<br/>  role: "&lt;your snowflake role&gt;",<br/>  warehouse: "&lt;your snowflake warehouse for the CI build&gt;",<br/>  schema: "&lt;your snowflake schema&gt;",<br/>]</span><span id="86f2" class="nk ku in ng b gy np nm l nn no">def production = [<br/>  account: "&lt;your snowflake account&gt;",<br/>  database: "&lt;your snowflake database&gt;",<br/>  role: "&lt;your snowflake role&gt;",<br/>  warehouse: "&lt;your snowflake warehouse for the CI build&gt;",<br/>  schema: "&lt;your snowflake schema&gt;",<br/>  containerConfig: [<br/>    imageName: "&lt;the name of the docker image for the daily refresh&gt;",<br/>    warehouse: "&lt;your snowflake warehouse for the daily refresh&gt;"<br/>  ],<br/>]</span><span id="b820" class="nk ku in ng b gy np nm l nn no">dbt.transform(acceptance, production) {<br/>  sh 'dbt seed'<br/>  sh 'dbt run'<br/>  sh 'dbt run-operation some_random_operation'  <br/>  sh 'dbt test'<br/>}</span></pre><p id="59ec" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">就是这样！我们首先需要加载我们的库(接下来我们将创建它)。然后，我们指定生产和验收数据库，并指定将用于每日刷新的容器。</p><p id="6e21" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在下一部分中，我们将指定在本地运行 dbt 项目时需要手动运行的所有命令。这些命令使用 Jenkins 作为 shell 命令执行</p><h1 id="291c" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">现在让我们创建库</h1><p id="f0bd" class="pw-post-body-paragraph jv jw in jx b jy mz ka kb kc na ke kf kg nb ki kj kk nc km kn ko nd kq kr ks ig bi translated">Jenkins 共享库是内置的<a class="ae ne" href="https://groovy-lang.org/" rel="noopener ugc nofollow" target="_blank"> Groovy </a>，这是一种基于 JVM 的语言，具有创建您自己的领域特定语言的良好特性。在<a class="ae ne" href="http://docs.groovy-lang.org/docs/latest/html/documentation/core-domain-specific-languages.html" rel="noopener ugc nofollow" target="_blank"> Groovy 文档</a>中，你可以读到更多关于它的内容，但是这里让我们保持简单。</p><p id="31e1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Jenkins 共享库的文件夹结构非常简单。您只需要提供一个 vars 文件夹和一个可选的 resources 文件夹。在 vars 文件夹中，我们将放置我们自己的构造并定义我们的 DSL 的行为。</p><p id="dc8f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">以下代码将放在 vars/dbt.groovy 下</p><pre class="ls lt lu lv gt nf ng nh ni aw nj bi"><span id="f5bc" class="nk ku in ng b gy nl nm l nn no">def transform(Map acceptance, Map production, Closure body) {<br/>  node('snowflake-dbt-agent') {<br/>    checkout scm<br/><br/>    stage('Build') {<br/>      deps()<br/>    }<br/>  }<br/><br/>  if (env.BRANCH_NAME != 'master') {<br/>    node('snowflake-dbt-agent') {<br/>      stage('Deploy to Development') {<br/>        unstash 'binary'<br/><br/>        runBuildAndSwap(acceptance, true, body)<br/>      }<br/>    }<br/><br/>    Boolean approved = askApprovalForAcceptanceDeployment()<br/>    if (!approved)<br/>      return<br/><br/>    node('snowflake-dbt-agent') {<br/>      stage('Deploy to Acceptance') {<br/>        unstash 'binary'<br/><br/>        runBuildAndSwap(acceptance, body)<br/><br/>        documentation.deployDocumentationWebsite(acceptance)<br/>      }<br/>    }<br/>  } else {<br/>    node('snowflake-dbt-agent') {<br/>      stage('Deploy to Production') {<br/>        unstash 'binary'<br/><br/>        runBuildAndSwap(production, body)<br/><br/>        documentation.deployDocumentationWebsite(production)<br/><br/>        if (production.containerConfig) {<br/>          container.setupContainer(production)<br/>        }<br/><br/>        String tag = semver.increment()<br/><br/>        if (production.containerConfig) {<br/>          container.publishContainer(production.containerConfig as Map, tag)<br/>        }<br/>      }<br/>    }<br/>  }<br/>}</span><span id="48b0" class="nk ku in ng b gy np nm l nn no">def deps() {<br/>  withDBT() {<br/>    withGitConfig {<br/>      if (fileExists('dbt_project.yml')) {<br/>        sh 'dbt --version'<br/>        sh 'dbt deps'<br/>      }<br/>      stash includes: '**', name: 'binary', useDefaultExcludes: false<br/>    }<br/>  }<br/>}<br/><br/>def withDBT(Closure body) {<br/>  withEnv(["DBT_PROFILES_DIR=$WORKSPACE"]) {<br/>    body()<br/>  }<br/>}<br/><br/>def withGitConfig(Closure body) {<br/>  withCredentials(<br/>    [<br/>      sshUserPrivateKey(<br/>        credentialsId: '9facfa3e-8ca0-4288-9156-b24a1e2cec6f',<br/>        keyFileVariable: 'SSH_KEY',<br/>        passphraseVariable: '',<br/>        usernameVariable: '')<br/>    ]<br/>  ) {<br/>    // just some hack to allow people to use https git urls in dbt packages<br/>    sh """<br/>      cp $SSH_KEY ~/.ssh/id_rsa<br/>      chmod 700 ~/.ssh/id_rsa<br/>      git config --global url.\"git@bitbucket.org:\".insteadOf https://bitbucket.org/<br/>    """<br/>    body()<br/>  }<br/>}</span><span id="4e2c" class="nk ku in ng b gy np nm l nn no">def runBuildAndSwap(Map environment, Boolean isDevBranch = false, Closure body) {<br/>  snowflake.withSnowflakeRoleSecurity(environment) {<br/>    if (isDevBranch) {<br/>      environment = snowflake.createDevelopmentEnvironmentConfig(environment)<br/>    }<br/>    snowflake.withSchemaSwap(environment) {<br/>      executeDBTCode(environment, body)<br/>    }<br/>  }<br/><br/>}<br/><br/>def executeDBTCode(Map environment, Closure body) {<br/>  withDBT() {<br/>    try {<br/>      body()<br/>    } finally {<br/>      // ensure log files are saved as artifact<br/>      archiveArtifacts '**/*.log'<br/>    }<br/>  }<br/>}<br/><br/>def askApprovalForAcceptanceDeployment() {<br/>  try {<br/>    timeout(time: 1, unit: "HOURS") {<br/>      input(message: 'Do you want to deploy this change in acceptance?', ok: 'Yes')<br/>    }<br/>  } catch (ignored) {<br/>    // don't mark this build as failed!<br/>    currentBuild.result = 'SUCCESS'<br/>    return false<br/>  }<br/>  return true<br/>}</span></pre><p id="3982" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以让我们解释一下我们正在做什么。在这个文件中，我们编写了开发人员在 Jenkinsfile 中描述的逻辑:</p><pre class="ls lt lu lv gt nf ng nh ni aw nj bi"><span id="42cd" class="nk ku in ng b gy nl nm l nn no">dbt.transform(acceptance, production) {<br/>  sh 'dbt seed'<br/>  sh 'dbt run'<br/>  sh 'dbt run-operation some_random_operation'  <br/>  sh 'dbt test'<br/>}</span></pre><p id="6449" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们将检查这是在哪个分支上执行的，主服务器将进入生产环境，而特性分支将进入分支环境。上述逻辑在相关环境中执行。</p><p id="66b9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">每次运行都将部署一个 dbt 文档网站，并有选择地将一个容器发布到容器注册中心，以便为主分支刷新数据。</p><figure class="ls lt lu lv gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nq"><img src="../Images/09ea307ce41b933f1ea4291236bcf308.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qC_otAWi-OuY_YLWhl0WSQ.png"/></div></div></figure><p id="d46f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当构建成功时，代码也可以被部署到验收环境中(因为我们的客户喜欢一个固定的数据库 URL 来进行测试，而不是总是为每个特性去另一个数据库)。这是通过<a class="ae ne" href="https://www.jenkins.io/doc/pipeline/steps/pipeline-input-step/" rel="noopener ugc nofollow" target="_blank">输入步骤</a>完成的。</p><h1 id="7c41" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">现在让我们看看雪花集成</h1><p id="5e1d" class="pw-post-body-paragraph jv jw in jx b jy mz ka kb kc na ke kf kg nb ki kj kk nc km kn ko nd kq kr ks ig bi translated">这段代码将放在 vars/雪花. groovy 下</p><pre class="ls lt lu lv gt nf ng nh ni aw nj bi"><span id="e434" class="nk ku in ng b gy nl nm l nn no">import groovy.json.JsonSlurper</span><span id="c585" class="nk ku in ng b gy np nm l nn no">Object executeQuery(String query, String outputFormat = "psql") {<br/>  query = query.replace("'", "\'\\\'\'")<br/>  query = query.replace('"', '\\\"')<br/>  database = "$SNOWFLAKE_TRANSFORM_DATABASE".replace('"', '\\\"')<br/>  def timing = outputFormat != "json"<br/>  def friendly = outputFormat != "json"<br/>  String output = sh(<br/>    script: "snowsql --private-key-path $SECRET_P8 -o exit_on_error=true -o output_format=$outputFormat -o timing=$timing -o friendly=$friendly -w $SNOWFLAKE_TRANSFORM_WAREHOUSE -a $SNOWFLAKE_ACCOUNT -u $SNOWFLAKE_USER -r $SNOWFLAKE_TRANSFORM_ROLE -d $database -s $SNOWFLAKE_TRANSFORM_SCHEMA -q '$query'",<br/>    returnStdout: true<br/>  ).trim()<br/>  if (outputFormat == "json") {<br/>    def jsonSlurper = new JsonSlurper()<br/>    return jsonSlurper.parseText(output)<br/>  }<br/>  echo output<br/>}</span><span id="8ed4" class="nk ku in ng b gy np nm l nn no">Object executeQueryAndFetchResult(String query) {<br/>  return executeQuery(query, "json")<br/>}</span><span id="2d0d" class="nk ku in ng b gy np nm l nn no">def executeQueryBatch(String file) {<br/>  database = "$SNOWFLAKE_TRANSFORM_DATABASE".replace('"', '\\\"')<br/>  sh "snowsql --private-key-path $SECRET_P8 -o exit_on_error=true -w $SNOWFLAKE_TRANSFORM_WAREHOUSE -a $SNOWFLAKE_ACCOUNT -u $SNOWFLAKE_USER -r $SNOWFLAKE_TRANSFORM_ROLE -d $database -s $SNOWFLAKE_TRANSFORM_SCHEMA -f $file"<br/>}</span><span id="3fe1" class="nk ku in ng b gy np nm l nn no">def withSnowflakeConfig(Map environment, Closure body) {<br/>  withCredentials(<br/>    [<br/>      file(credentialsId: 'b34d8331-8049-4aca-940f-587fe625dd68', variable: 'SECRET_P8'),<br/>      string(credentialsId: 'bee435f7-28e4-4f1f-a174-9c7066a1e288', variable: 'SECRET_PASSPHRASE')<br/>    ]) {<br/>    def config = [<br/>      // dbt<br/>      "DBT_PROFILES_DIR=$WORKSPACE",</span><span id="a8dc" class="nk ku in ng b gy np nm l nn no">      // snowflake db<br/>      "PRIVATE_KEY_PATH=$SECRET_P8",<br/>      "PRIVATE_KEY_PASSPHRASE=$SECRET_PASSPHRASE",<br/>      "SNOWFLAKE_ACCOUNT=${environment.account}",<br/>      'SNOWFLAKE_USER=JENKINS',<br/>      "SNOWFLAKE_TRANSFORM_DATABASE=\"${environment.database}\"",<br/>      "SNOWFLAKE_TRANSFORM_SCHEMA=${environment.schema}",<br/>      "SNOWFLAKE_TRANSFORM_ROLE=${environment.role}",<br/>      "SNOWFLAKE_TRANSFORM_WAREHOUSE=${environment.warehouse}"</span><span id="7dfe" class="nk ku in ng b gy np nm l nn no">      // snowsql<br/>      "SNOWSQL_PRIVATE_KEY_PASSPHRASE=$SECRET_PASSPHRASE",<br/>      "PATH=/home/jenkins/bin:$PATH",<br/>    ]<br/>    withEnv(config) {<br/>      body()<br/>    }<br/>  }<br/>}</span><span id="b674" class="nk ku in ng b gy np nm l nn no">def withDatabaseSwap(Map environment, Closure body) {<br/>  withSwap(environment, false, body)<br/>}</span><span id="5e26" class="nk ku in ng b gy np nm l nn no">def withSchemaSwap(Map environment, Closure body) {<br/>  withSwap(environment, true, body)<br/>}</span><span id="6ef4" class="nk ku in ng b gy np nm l nn no">def withSwap(Map environment, Boolean swapSchema, Closure body) {<br/>  def buildDatabase = "\"${environment.database}_$BUILD_NUMBER\""<br/>  def database = "\"${environment.database}\""<br/>  def schema = environment.schema as String</span><span id="e03f" class="nk ku in ng b gy np nm l nn no">  // creating the build database<br/>  createDatabaseAndSchema(buildDatabase, schema)</span><span id="488d" class="nk ku in ng b gy np nm l nn no">  // creating the target database<br/>  createDatabaseAndSchema(database, schema)</span><span id="a045" class="nk ku in ng b gy np nm l nn no">withEnv([<br/>    "SNOWFLAKE_TRANSFORM_DATABASE=$buildDatabase",<br/>    // if the schema will be swapped, the reader roles need access rights on the target database!<br/>    // if the database will be swapped, the reader roles need access rights on the build database!<br/>    "SNOWFLAKE_TRANSFORM_SWAP_DATABASE=${swapSchema ? database : buildDatabase}",<br/>  ]) {<br/>    if (swapSchema &amp;&amp; environment.role != "TRANSFORMER") {<br/>      throw new Exception("Schema swap is only supported with TRANSFORMER role")<br/>    }<br/>    try {<br/>      body()</span><span id="599a" class="nk ku in ng b gy np nm l nn no">      lock(resource: environment.database, inversePrecedence: true) {<br/>        if (!swapSchema)<br/>          executeQuery "ALTER DATABASE $database SWAP WITH $buildDatabase"<br/>        else {<br/>          executeQuery "ALTER SCHEMA $database.$schema SWAP WITH $buildDatabase.$schema"<br/>        }<br/>      }<br/>    } finally {<br/>      executeQuery "DROP DATABASE $buildDatabase"<br/>    }<br/>  }<br/>}</span><span id="da76" class="nk ku in ng b gy np nm l nn no">def withSnowflakeRoleSecurity(Map environment, Closure body) {<br/>  def readRole = "READ_${environment.database.toUpperCase()}_${environment.schema.toUpperCase()}"<br/>  def readPseudoRole = "${readRole}_PSEUDO"</span><span id="4e4a" class="nk ku in ng b gy np nm l nn no">withEnv([<br/>    "READER_ROLE=$readRole",<br/>    "READER_ROLE_PSEUDO=$readPseudoRole",<br/>  ]) {<br/>    withSnowflakeConfig(environment) {</span><span id="cc82" class="nk ku in ng b gy np nm l nn no">      setupSnowflakeSecurity(environment)</span><span id="9878" class="nk ku in ng b gy np nm l nn no">      executeQuery "CREATE ROLE IF NOT EXISTS $readPseudoRole"<br/>      executeQuery "CREATE ROLE IF NOT EXISTS $readRole"<br/>      executeQuery "GRANT ROLE $readPseudoRole TO ROLE $readRole"</span><span id="aee8" class="nk ku in ng b gy np nm l nn no">      body()<br/>    }<br/>  }<br/>}</span><span id="7c6d" class="nk ku in ng b gy np nm l nn no">def setupSnowflakeSecurity(Map environment) {<br/>  def role = environment.role</span><span id="a55f" class="nk ku in ng b gy np nm l nn no">  def warehouse = environment.warehouse</span><span id="4ef2" class="nk ku in ng b gy np nm l nn no">  withEnv([<br/>    "SNOWFLAKE_TRANSFORM_ROLE=ACCOUNTADMIN"<br/>  ]) {<br/>    executeQuery "CREATE ROLE IF NOT EXISTS $role"<br/>    executeQuery "CREATE WAREHOUSE IF NOT EXISTS $warehouse WITH WAREHOUSE_SIZE = XSMALL"<br/>    executeQuery "GRANT USAGE ON WAREHOUSE $warehouse TO ROLE $role"</span><span id="288d" class="nk ku in ng b gy np nm l nn no">    executeQuery "GRANT CREATE DATABASE ON ACCOUNT TO ROLE $role"<br/>    executeQuery "GRANT CREATE ROLE ON ACCOUNT TO ROLE $role"<br/>    executeQuery "GRANT EXECUTE TASK ON ACCOUNT TO ROLE $role"</span><span id="4ebb" class="nk ku in ng b gy np nm l nn no">    executeQuery "GRANT ROLE $role TO USER jenkins"<br/>    <br/>    if (environment.refresh_warehouse) {<br/>      def refreshWarehouse = environment.refresh_warehouse<br/>      executeQuery "CREATE WAREHOUSE IF NOT EXISTS $refreshWarehouse WITH WAREHOUSE_SIZE = XSMALL"<br/>      executeQuery "GRANT USAGE ON WAREHOUSE $refreshWarehouse TO ROLE $role"<br/>    }<br/>  }<br/>}</span><span id="30e1" class="nk ku in ng b gy np nm l nn no">def createDatabaseAndSchema(String database, String schema) {<br/>  // create the database of the environment<br/>  executeQuery "CREATE DATABASE IF NOT EXISTS $database"<br/>  executeQuery "CREATE SCHEMA IF NOT EXISTS $database.$schema"<br/>}</span><span id="07b1" class="nk ku in ng b gy np nm l nn no">def setupGrants(List&lt;String&gt; schemas, String role, Boolean includeViews = false) {<br/>  executeQuery "CREATE ROLE IF NOT EXISTS $role"<br/>  // in case it's database swap the database should be the build database, in case of the schema swap, access should already be granted<br/>  executeQuery "GRANT USAGE ON DATABASE $SNOWFLAKE_TRANSFORM_SWAP_DATABASE TO ROLE $role"<br/>  for (schema in schemas) {<br/>    executeQuery "GRANT USAGE ON SCHEMA $SNOWFLAKE_TRANSFORM_DATABASE.\"$schema\" TO ROLE $role"<br/>    executeQuery "GRANT SELECT ON ALL TABLES IN SCHEMA $SNOWFLAKE_TRANSFORM_DATABASE.\"$schema\" TO ROLE $role"<br/>    executeQuery "GRANT SELECT ON ALL VIEWS IN SCHEMA $SNOWFLAKE_TRANSFORM_DATABASE.\"$schema\" TO ROLE $role"<br/>  }<br/>}</span><span id="c7cd" class="nk ku in ng b gy np nm l nn no">def createDevelopmentEnvironmentConfig(Map environment) {<br/>  def branchSuffix = ''<br/>  if (env.BRANCH_NAME != 'master') {<br/>    branchSuffix = '_' + env.BRANCH_NAME<br/>  }<br/>  def clone = environment.clone()<br/>  clone["database"] = "${environment.database}${branchSuffix}"</span><span id="8af1" class="nk ku in ng b gy np nm l nn no">  return clone<br/>}</span></pre><p id="a441" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以我们先做一些可以在雪花上执行查询的辅助函数。</p><pre class="ls lt lu lv gt nf ng nh ni aw nj bi"><span id="6c30" class="nk ku in ng b gy nl nm l nn no">// execute a query without caring about the output<br/>executeQuery "CREATE ROLE IF NOT EXISTS $role"</span><span id="326f" class="nk ku in ng b gy np nm l nn no">// do something with the results of a <br/>echo executeQueryAndFetchResult "SELECT current_user()"</span></pre><p id="8c70" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是您将在 Jenkins 的日志中看到的内容:</p><figure class="ls lt lu lv gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nr"><img src="../Images/a6002c2380544cbd793723475b3059c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1tLneBO4HOzz6LcxpiHTzQ.png"/></div></div></figure><p id="c453" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后我们创建执行蓝绿色部署所需的所有逻辑。蓝绿色部署确保数据库永远不会处于不一致的状态。如果整个项目构建正确，并且所有测试都成功，那么所有数据都只在产品或特性分支上发布。发布是通过整个数据库或单个模式的原子交换来完成的。</p><figure class="ls lt lu lv gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ns"><img src="../Images/fb43026a7ab7878e427c42f083de4805.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Yb_UQ1JkWDpvpGwS.png"/></div></div></figure><h1 id="b09a" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">发布文档网站</h1><p id="10d1" class="pw-post-body-paragraph jv jw in jx b jy mz ka kb kc na ke kf kg nb ki kj kk nc km kn ko nd kq kr ks ig bi translated">这段代码将放在 vars/documentation.groovy 下。</p><pre class="ls lt lu lv gt nf ng nh ni aw nj bi"><span id="c318" class="nk ku in ng b gy nl nm l nn no">def deployDocumentationWebsite(Map environment) {<br/>  withCredentials([<br/>    [<br/>      $class: 'AmazonWebServicesCredentialsBinding',<br/>      accessKeyVariable: 'AWS_ACCESS_KEY_ID',<br/>      credentialsId: '2710c8d6-315b-45e3-8f92-7eb363e6e173',<br/>      secretKeyVariable: 'AWS_SECRET_ACCESS_KEY'<br/>    ]<br/>  ]) {<br/>    def cfnStack = libraryResource 'io/innover/jenkins_dbt_snowflake/cfn-doc-website.yml'<br/>    def documentationConfig = environment.documentationConfig<br/>    writeFile(file: "cfn-doc-website.yml", text: cfnStack)<br/>    def appName = documentationConfig.appName<br/>    def domainName = '&lt;your parent domain name here&gt;'<br/>    def fullDomainName = "${appName}.docs.dataplatform-onderwijs.vlaanderen.be"<br/>    def bucketName = "${appName}.docs"<br/>    cfnUpdate(<br/>      stack: "${appName}-documentation-website",<br/>      file: 'cfn-doc-website.yml',<br/>      params: [<br/>        DomainName       : domainName,<br/>        FullDomainName   : fullDomainName,<br/>        BucketName       : bucketName,<br/>        AcmCertificateArn: '&lt;your cerficate arn here&gt;'<br/>      ],<br/>      timeoutInMinutes: 30<br/>    )<br/>    s3Upload(file: 'target', bucket: bucketName, path: '')<br/>  }<br/>}</span></pre><p id="dfc6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">将您的 cloudformation 模板存储在 resources/io/innover/Jenkins _ dbt _ snow flake/cfn-doc-website . yml 中。在我们的示例中，我们使用 Cloudfront 网站，通过 IP 白名单和私有 S3 存储桶进行保护。</p><h1 id="71ec" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">发布用于每日刷新的容器</h1><p id="033d" class="pw-post-body-paragraph jv jw in jx b jy mz ka kb kc na ke kf kg nb ki kj kk nc km kn ko nd kq kr ks ig bi translated">然后，可以使用 AWS 步骤功能或气流 DAG 对该容器进行调度。</p><p id="e631" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">以下代码位于 vars/container.groovy 下。</p><pre class="ls lt lu lv gt nf ng nh ni aw nj bi"><span id="9946" class="nk ku in ng b gy nl nm l nn no">import groovy.json.JsonOutput</span><span id="5314" class="nk ku in ng b gy np nm l nn no">def setupContainer(Map environment) {<br/>  withCredentials([<br/>    [<br/>      $class: 'AmazonWebServicesCredentialsBinding',<br/>      accessKeyVariable: 'AWS_ACCESS_KEY_ID',<br/>      credentialsId: 'AWS_DATAPLATFORM_CREDENTIALS',<br/>      secretKeyVariable: 'AWS_SECRET_ACCESS_KEY'<br/>    ]) {<br/>    def cfnStack = libraryResource 'io/innoverio/jenkins_dbt_snowflake/cfn-nightly-refresh.yml'<br/>    Map containerConfig = environment.containerConfig as Map<br/>    def warehouse = containerConfig.warehouse<br/>    def imageName = containerConfig.imageName<br/>    def repo = "nightly-refresh/$<strong class="ng io">{</strong>imageName<strong class="ng io">}</strong>"<br/>    writeFile(file: "cfn-nightly-refresh.yml", text: cfnStack)<br/>    def secretJson = [<br/>      SNOWFLAKE_ACCOUNT            : "${environment.account}",<br/>      SNOWFLAKE_TRANSFORM_DATABASE : "${environment.database}",<br/>      SNOWFLAKE_TRANSFORM_ROLE     : "${environment.role}",<br/>      SNOWFLAKE_TRANSFORM_WAREHOUSE: "${warehouse}",<br/>      SNOWFLAKE_TRANSFORM_SCHEMA   : "${environment.schema}"<br/>    ]</span><span id="22f9" class="nk ku in ng b gy np nm l nn no">snowflake.withSnowflakeConfig(environment) {<br/>      withEnv([<br/>        "SNOWFLAKE_TRANSFORM_ROLE=ACCOUNTADMIN"<br/>      ]) {<br/>        snowflake.executeQuery "CREATE WAREHOUSE IF NOT EXISTS $warehouse WITH WAREHOUSE_SIZE = XSMALL"<br/>        snowflake.executeQuery "GRANT USAGE ON WAREHOUSE $warehouse TO ROLE ${environment.role}"<br/>      }<br/>    }</span><span id="4717" class="nk ku in ng b gy np nm l nn no">cfnUpdate(<br/>      stack: "${imageName}-nightly-refresh",<br/>      file: 'cfn-nightly-refresh.yml',<br/>      params: [<br/>        VPCToDeployIn        : '&lt;your vpc&gt;',<br/>        Subnet               : '&lt;your subnet(s)&gt;',<br/>        SecurityGroupName    : "securityGroup-${imageName}-nightly",<br/>        ClusterName          : "dbt-runner-${imageName}",<br/>        ECRRepositoryName    : repo,<br/>        Image                : "${repo}:latest",<br/>        SnowflakeSecretName  : "${imageName}-nightly-refresh-secret",<br/>        SnowflakeSecretString: JsonOutput.toJson(secretJson),<br/>        ScheduleExpression   : containerConfig.schedule ?: ''<br/>      ]<br/>    )<br/>  }<br/>}</span><span id="236d" class="nk ku in ng b gy np nm l nn no">def publishContainer(Map containerConfig, String tag) {<br/>  node('master') {<br/>    deleteDir()<br/>    unstash 'binary'<br/>    docker.withRegistry('<a class="ae ne" href="https://045879944372.dkr.ecr.eu-west-1.amazonaws.com'" rel="noopener ugc nofollow" target="_blank">&lt;registry url&gt;'</a>, '&lt;credentials id&gt;') {<br/>      def customImage = docker.build("ov-nightly-refresh/${containerConfig.imageName}")<br/>      customImage.push('latest')<br/>      customImage.push(tag)<br/>    }<br/>  }<br/>}</span></pre><p id="12b8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">同样，您应该创建自己的云形成模板，并将其放在 resources 文件夹下，以便将构建 docker 映像部署到您的 repo。您可以使用 AWS step 函数和 cron 调度轻松地在这里添加调度逻辑。</p><p id="809e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在我们的例子中，我们已经创建了跨越多个 dbt 项目的多个气流 Dag，并确保项目以正确的顺序执行。</p><h1 id="fbba" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">版本控制</h1><p id="7d39" class="pw-post-body-paragraph jv jw in jx b jy mz ka kb kc na ke kf kg nb ki kj kk nc km kn ko nd kq kr ks ig bi translated">最后，我们的共享库还支持 vars/semver.groovy 下的语义版本控制。</p><pre class="ls lt lu lv gt nf ng nh ni aw nj bi"><span id="85ec" class="nk ku in ng b gy nl nm l nn no">String increment() {<br/>  node('snowflake-dbt-agent') {<br/>    withCredentials([sshUserPrivateKey(credentialsId: '9facfa3e-8ca0-4288-9156-b24a1e2cec6f', keyFileVariable: 'SSH_KEY', passphraseVariable: '', usernameVariable: '')]) {<br/>      sh """<br/>        cp $SSH_KEY ~/.ssh/id_rsa<br/>        chmod 700 ~/.ssh/id_rsa<br/>        git config --global url.\"git@bitbucket.org:\".insteadOf https://bitbucket.org/<br/>      """<br/>      unstash 'binary'<br/>      sh 'semver-increment'<br/>      return sh (<br/>        script: 'git describe --abbrev=0 --tags',<br/>        returnStdout: true<br/>      ).trim()<br/>    }<br/>  }<br/>}</span></pre><p id="9f20" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">semver-increment 脚本将检查提交的版本是否包含标签，如果不包含，它将找到旧标签并根据<a class="ae ne" href="https://semver.org/" rel="noopener ugc nofollow" target="_blank"> semver 规范</a>增加补丁版本。上面的代码然后返回新的标签作为输出。</p><h1 id="12e1" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">创建一个詹金斯代理</h1><p id="4f07" class="pw-post-body-paragraph jv jw in jx b jy mz ka kb kc na ke kf kg nb ki kj kk nc km kn ko nd kq kr ks ig bi translated">要运行上述命令，我们需要创建一个 docker 容器，其中包含所有必需的组件(snowsql、dbt 和 semver)。</p><p id="5bdb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你可以在 Github 上看看<a class="ae ne" href="https://github.com/innoverio/jenkins-dbt-snowflake-agent" rel="noopener ugc nofollow" target="_blank">我们的代理</a>。</p><p id="01b9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">要配置 docker 代理，请看一下<a class="ae ne" href="https://www.jenkins.io/doc/book/using/using-agents/" rel="noopener ugc nofollow" target="_blank"> Jenkins 文档</a>。存在多种选择，在我们的例子中，我们通过 AWS Fargate 运行它们。</p><h1 id="b16f" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">发布库</h1><p id="cc34" class="pw-post-body-paragraph jv jw in jx b jy mz ka kb kc na ke kf kg nb ki kj kk nc km kn ko nd kq kr ks ig bi translated">在<a class="ae ne" href="https://www.jenkins.io/doc/book/pipeline/shared-libraries/" rel="noopener ugc nofollow" target="_blank"> jenkins docs </a>中，您可以找到如何在 jenkins 实例上发布您的共享库。</p><figure class="ls lt lu lv gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nt"><img src="../Images/d38b2748f42eb4d59cfa534181d605d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*KE5atJ2zhQHRgQk5.png"/></div></div></figure><p id="1faa" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这很简单，你只需要把你的 git repo url 放在那里，然后你就可以在 Jenkinsfile 中引用你的共享库了。</p><pre class="ls lt lu lv gt nf ng nh ni aw nj bi"><span id="5b1d" class="nk ku in ng b gy nl nm l nn no"><a class="ae ne" href="http://twitter.com/Library" rel="noopener ugc nofollow" target="_blank">@Library</a>('dbt-snowflake-jenkins-shared-library')</span></pre><h1 id="3c7d" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">我们完了！</h1><figure class="ls lt lu lv gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nu"><img src="../Images/10ccdf20ea37dff7768f58eddb589a73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JF_CAH5uyqVroH_nuJ-Dkw.png"/></div></div></figure><p id="eb32" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们一起为您的 GitOps 数据部署构建了这个简单的 Jenkins 共享库:</p><ul class=""><li id="c935" class="ml mm in jx b jy jz kc kd kg mn kk mo ko mp ks mq mr ms mt bi translated">每个开发分支都有自己的协作平台。</li><li id="10f7" class="ml mm in jx b jy mu kc mv kg mw kk mx ko my ks mq mr ms mt bi translated">团队中每个人都容易理解的简单 DSL 隐藏了 GitOps 工作流的复杂性。</li><li id="1013" class="ml mm in jx b jy mu kc mv kg mw kk mx ko my ks mq mr ms mt bi translated">进行蓝绿色部署，永远不要中断或破坏工作环境。</li><li id="9302" class="ml mm in jx b jy mu kc mv kg mw kk mx ko my ks mq mr ms mt bi translated">为每个开发分支建立一个最新的 dbt 文档网站</li><li id="e3a1" class="ml mm in jx b jy mu kc mv kg mw kk mx ko my ks mq mr ms mt bi translated">每个生产部署都使用语义版本标签进行标记</li></ul><p id="57f6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">请在评论中告诉我这个实践教程对你有什么帮助。</p></div></div>    
</body>
</html>