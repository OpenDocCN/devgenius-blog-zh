<html>
<head>
<title>Kotlin Coroutines, putting together the pieces</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">科特林 Coroutines，把碎片放在一起</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/kotlin-coroutines-putting-together-the-pieces-84c2e9e7015e?source=collection_archive---------4-----------------------#2022-03-02">https://blog.devgenius.io/kotlin-coroutines-putting-together-the-pieces-84c2e9e7015e?source=collection_archive---------4-----------------------#2022-03-02</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="0848" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">用一种能让这些概念持续的方式写作和想象</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/cdbbea42167ae07f0ef421a343030b8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*AwffEkJBdkv4RiV_"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">Clark Van Der Beken 在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="08dd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当我开始学习 Kotlin 中的协程时，我到处阅读了一些文章和教程，玩了一些例子，并认为我已经合理地掌握了它们是什么以及如何使用它们。</p><p id="e0cd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然而，像任何语言一样，Kotlin 在这方面发展得非常快，我错过了一些变化，所以当我最近遇到这些变化时，我意识到也许我应该回去彻底重温一下几个概念。</p><p id="69c0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有很多资料描述了协程和线程之间的区别，为什么你应该使用协程等等。我所缺少的，以及我将要尝试用这个小故事去做的，是把所有这些拼图放在一起，以一种适合我的思维过程的方式，写下来，画下来，也许对其他人也有用。</p><h1 id="6f1b" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">并发性与并行性</h1><p id="b527" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">是的，我需要想象或表达的一件事是并发性和并行性之间的区别。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mc"><img src="../Images/c6b6473fcf7e0209c95a1deb9e9aee40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1272/format:webp/1*ekuL_8Ko9fapK_Bo_DWjng.png"/></div></figure><p id="0411" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">CPU 的每个核心在给定时间只能执行 1 条指令/线程(说到物理核心，现代 CPU 也有逻辑核心或某种抽象，告诉操作系统实际上有比物理可用更多的核心)。然而，正如你们所知，笔记本电脑完全能够以一种似乎与我们这些可怜的人类并行的方式运行许多许多线程，因为切换发生得非常快。</p><p id="c10a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一般来说，并行执行意味着事情在完全相同的时间<strong class="jm io">运行，但是使用线程是我们在一个简单的应用程序中最接近它的方式。这并不完美，因为我们无法控制日程安排，但这已经足够好了😆</strong></p><p id="5552" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">另一方面，协程可以在同一个线程中执行，它们甚至不绑定到同一个线程。一个协程可以在线程 A 中启动，被挂起，然后在线程 C 中恢复，然后再次挂起，在线程 B 中恢复…你明白了。因为我们在一个线程中可能有 N 个协同程序，并且一次只能执行 1 个，所以我们讨论并发性，即执行时间重叠。</p><p id="d10e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这就是为什么在协程中我们可以延迟(100)而线程不会被阻塞。延迟是暂停计算的一个例子，其中线程只是让当前的协同程序冷却，继续执行可能另一个协同程序的指令，然后从同一位置继续。</p><h1 id="b7b9" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">协程层次和构建器</h1><p id="2122" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">第一次深入研究协程的层次结构时，很容易迷失方向，但是一旦你仔细观察，就不会那么可怕了。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi md"><img src="../Images/f940a121904fdb5a35937b9bd1d2ed2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GIb_JFU2UbW52mGJ8qL1eA.png"/></div></div></figure><p id="d695" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">AbstractCoroutine 下的所有东西都是我们用构建器创建的，右边 JobSupport 下的所有东西都可以简单地通过构造函数来创建。</p><p id="d521" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> BlockingCoroutine </strong>是一种不言自明的协程，它阻塞当前线程直到完成，所以它不应该在另一个协程中被调用，它应该在主函数和测试中使用。</p><p id="2d62" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">broadcast 协程</strong>是一个协程，它通过将值发送到广播通道来产生一个值流，然后由构建器返回。当协程完成时，或者在未捕获到异常的情况下，通道被关闭，这将随后导致订户尝试读取时出现异常。默认情况下，在第一个订户通过 broadcast channel . open subscription 出现之前，协同例程不会启动，因为 start 参数的值为 CoroutineStart。默认懒。这确保了第一订户不会错过任何发送的元素。但是，后来的订阅者可能会错过元素。这个 API 从 1.5.0 开始<strong class="jm io">就过时了</strong>。它将被 Flow.shareIn 运算符替换。(更多关于传入的信息)</p><p id="8b80" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">通道协同例程</strong>已被<strong class="jm io">弃用</strong>，但它的子类还没有……弃用。<strong class="jm io"> actor </strong>实现即将被<strong class="jm io">淘汰</strong>引入了复杂的 actor，但目前，它是一个协程，从其邮箱通道接收消息，并作为发送通道返回对其邮箱通道的引用，构建器的结果对象可用于将<em class="me">消息发送到该协程。<strong class="jm io"> producer </strong> one 是一个协程，通过将值发送到通道来产生一个值流，构建器的结果对象可用于`<em class="me">接收由该协程产生的`</em>元素。</em></p><p id="899c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">Deferred 协程</strong>是一个协程，它返回它未来的结果作为 Deferred 的实现。要注意的关键点是，它在失败时取消父作业，但是可以通过使用监督父作业(SupervisorJob 或 supervisorScope)来改变行为。</p><p id="5283" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">独立例程</strong>是一个协程，返回一个任务。这也将在失败时取消父作业，它与 DeferredCoroutine 非常相似，不同之处在于，当您执行 async()即 Dferred 时，您可以获得一个结果，而当您执行 launch()即 Standalone 时，它是一劳永逸的…就响应而言，您仍然可以取消和控制生命周期。</p><p id="9a5c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">scope routine</strong>的子类提供了在您提供的协程上下文中执行代码块的方法。</p><p id="0e1a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> ChildJob </strong>是父作业从其子作业接收的信息，以便它可以报告取消。</p><p id="d409" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> ParentJob </strong>是当父作业被父作业取消时，子作业从父作业接收的内容。</p><h1 id="efbf" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">分层取消</h1><pre class="kj kk kl km gt mf mg mh mi aw mj bi"><span id="cffa" class="mk la in mg b gy ml mm l mn mo">val scopedJob = <em class="me">CoroutineScope</em>(Dispatchers.Unconfined).<em class="me">launch </em><strong class="mg io">{<br/><br/>    </strong>val aJob = this.<em class="me">launch </em><strong class="mg io">{<br/>        </strong>val bJob = this.<em class="me">launch </em><strong class="mg io">{<br/>            </strong>while (true) {<br/>                delay(3_000)<br/>                b++<br/>            }<br/>        <strong class="mg io">}<br/>        </strong>bJob.invokeOnCompletion <strong class="mg io">{<br/>            </strong><em class="me">println</em>("B has completed at $b")<br/>        <strong class="mg io">}<br/>        </strong>while (true) {<br/>            delay(10_000)<br/>            a++<br/>        }<br/>    <strong class="mg io">}<br/>    </strong>aJob.invokeOnCompletion <strong class="mg io">{<br/>        </strong><em class="me">println</em>("A has completed at $a")<br/>    <strong class="mg io">}<br/>    </strong>while (true) {<br/>        delay(1_000)<br/>        scoped++<br/>    }<br/><strong class="mg io">}<br/><br/></strong>scopedJob.invokeOnCompletion <strong class="mg io">{<br/>    </strong><em class="me">println</em>("Scoped has completed at $scoped")<br/><strong class="mg io">}<br/><br/></strong>while (outer &lt; 9_000) {<br/>    delay(10)<br/>    outer++<br/>}<br/>scopedJob.cancel()<br/><em class="me">println</em>("End")</span><span id="ef16" class="mk la in mg b gy mp mm l mn mo"><em class="me">Completed at 10<br/>Scoped has completed at 108<br/>End</em></span></pre><p id="9a01" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一旦外部父代被取消，内部的整个层次结构也被取消，从层次结构树中最远的开始向上。</p><pre class="kj kk kl km gt mf mg mh mi aw mj bi"><span id="df79" class="mk la in mg b gy ml mm l mn mo"><em class="me">B has completed at 36<br/>A has completed at 10<br/>Scoped has completed at 108<br/>End<br/></em></span></pre><p id="bbaa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您可以将协程名称和作业作为参数传递给子协程创建，但这不会生效，也就是说，它不是实际运行的作业实例。</p><h1 id="8333" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">用于取消的实例</h1><pre class="kj kk kl km gt mf mg mh mi aw mj bi"><span id="e6c1" class="mk la in mg b gy ml mm l mn mo">val scopedJob = <em class="me">SupervisorJob</em>()<br/><em class="me">println</em>("Scoped job passed in $scopedJob")<br/><br/>val scope = <em class="me">CoroutineScope</em>(Dispatchers.Unconfined + scopedJob + CoroutineName("SCOPED"))<br/><em class="me">println</em>("Scope ${scope.coroutineContext}")<br/><br/>scope.<em class="me">launch</em>(CoroutineName("A")) <strong class="mg io">{<br/>    </strong>val aJob = <em class="me">SupervisorJob</em>()<br/>    <em class="me">println</em>("A job passed in $aJob")<br/>    <em class="me">println</em>("A scope: ${this.coroutineContext}")<br/><br/>    this.<em class="me">launch</em>(CoroutineName("B") + aJob) <strong class="mg io">{<br/>        </strong><em class="me">println</em>("B scope: ${this.coroutineContext}")<br/>    <strong class="mg io">}<br/>}</strong></span></pre><p id="2afc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">它实际上是启动时返回的内容，但是，两者都可以用来取消协程-`jobBReturned.cancel()`和` jobB.cancel()`将起作用。</p><pre class="kj kk kl km gt mf mg mh mi aw mj bi"><span id="c043" class="mk la in mg b gy ml mm l mn mo">Scoped job passed in SupervisorJobImpl{Active}<a class="ae ky" href="http://twitter.com/2ef1e4fa" rel="noopener ugc nofollow" target="_blank">@2ef1e4fa</a><br/>Scope [SupervisorJobImpl{Active}<a class="ae ky" href="http://twitter.com/2ef1e4fa" rel="noopener ugc nofollow" target="_blank">@2ef1e4fa</a>, CoroutineName(SCOPED), Dispatchers.Unconfined]</span><span id="732c" class="mk la in mg b gy mp mm l mn mo">Job A passed in JobImpl{Active}<a class="ae ky" href="http://twitter.com/27ddd392" rel="noopener ugc nofollow" target="_blank">@27ddd392</a><br/>A scope: [CoroutineName(A), StandaloneCoroutine{Active}<a class="ae ky" href="http://twitter.com/2be94b0f" rel="noopener ugc nofollow" target="_blank">@2be94b0f</a>, Dispatchers.Unconfined]</span><span id="d750" class="mk la in mg b gy mp mm l mn mo">Job B passed in JobImpl{Active}<a class="ae ky" href="http://twitter.com/d70c109" rel="noopener ugc nofollow" target="_blank">@d70c109</a><br/>B returned StandaloneCoroutine{Active}<a class="ae ky" href="http://twitter.com/47d384ee" rel="noopener ugc nofollow" target="_blank">@47d384ee</a><br/>B scope: [CoroutineName(B), StandaloneCoroutine{Active}<a class="ae ky" href="http://twitter.com/47d384ee" rel="noopener ugc nofollow" target="_blank">@47d384ee</a>, Dispatchers.Unconfined]</span></pre><h1 id="5cab" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated"><strong class="ak">广播</strong></h1><p id="a49b" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">这种精确的实现方式将很快被取代，但概念可能是相同的——使用一个“信道”来广播数据，许多用户从中读取数据。</p><pre class="kj kk kl km gt mf mg mh mi aw mj bi"><span id="b2db" class="mk la in mg b gy ml mm l mn mo">val bChannel: BroadcastChannel&lt;Int&gt; = <em class="me">CoroutineScope</em>(Dispatchers.Unconfined).<em class="me">broadcast </em><strong class="mg io">{<br/>    </strong>var a = 0<br/>    while (true) {<br/>        delay(10)<br/>        a++<br/>        this.channel.send(a)<br/>    }<br/><strong class="mg io">}<br/><br/></strong>delay(1000)<br/><br/><em class="me">CoroutineScope</em>(Dispatchers.Unconfined).<em class="me">launch</em><strong class="mg io">{ </strong>bChannel.consumeEach <strong class="mg io">{ </strong><em class="me">println</em>("in A $<strong class="mg io">it</strong>") <strong class="mg io">} }<br/></strong><em class="me">CoroutineScope</em>(Dispatchers.Unconfined).<em class="me">launch</em><strong class="mg io">{  </strong>bChannel.consumeEach <strong class="mg io">{ </strong><em class="me">println</em>("in B $<strong class="mg io">it</strong>") <strong class="mg io">} }<br/></strong>delay(1000)<br/><em class="me">CoroutineScope</em>(Dispatchers.Unconfined).<em class="me">launch</em><strong class="mg io">{ </strong>bChannel.consumeEach <strong class="mg io">{ </strong><em class="me">println</em>("in C $<strong class="mg io">it</strong>") <strong class="mg io">} }<br/><br/></strong>delay(1_000)<br/><br/>bChannel.cancel()</span></pre><p id="bddf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">第一个订户“激活”该频道，然后所有随后的订户只是从订阅点开始阅读。(通知 C 在 79 左右加入)</p><pre class="kj kk kl km gt mf mg mh mi aw mj bi"><span id="020d" class="mk la in mg b gy ml mm l mn mo"><em class="me">in A 1<br/>in B 1<br/>in A 2<br/>in B 2<br/>in A 3<br/>in B 3<br/>...<br/>in A 79<br/>in B 79<br/></em><strong class="mg io"><em class="me">in C 79</em></strong><em class="me"><br/>in A 80<br/>in B 80<br/>in C 80</em></span></pre><h2 id="3323" class="mk la in bd lb mq mr dn lf ms mt dp lj jv mu mv ln jz mw mx lr kd my mz lv na bi translated">生产和阅读</h2><pre class="kj kk kl km gt mf mg mh mi aw mj bi"><span id="d79c" class="mk la in mg b gy ml mm l mn mo">val rChannel: ReceiveChannel&lt;Int&gt; = <em class="me">CoroutineScope</em>(Dispatchers.Unconfined).<em class="me">produce </em><strong class="mg io">{<br/>    </strong>var a = 0<br/>    while (true) {<br/>        delay(10)<br/>        a++<br/>        this.channel.send(a)<br/>    }<br/><strong class="mg io">}<br/></strong>val sChannel: SendChannel&lt;Int&gt; = <em class="me">CoroutineScope</em>(Dispatchers.Unconfined).<em class="me">actor </em><strong class="mg io">{<br/>    </strong>while (true) {<br/>        val res = this.channel.receive()<br/>        <em class="me">println</em>(res)<br/>    }<br/><strong class="mg io">}<br/><br/></strong>delay(1000)<br/><br/>var b = 0<br/>var result = rChannel.receive()<br/>while (b &lt; 10) {<br/>    sChannel.send(result)<br/>    delay(20)<br/>    b++<br/>    result = rChannel.receive()<br/>}<br/>rChannel.cancel()</span></pre><p id="5e33" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我第一次读到 actor 时，我并没有把它们联系起来，但是像一个真正的 actor 一样，这种类型的协程打开了一个通向父级的通道，它可以在那里读取指令并对命令做出反应。</p><h1 id="2f7e" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">流</h1><p id="258a" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">这是一种替代广播协程和通道的 API。它提供了一种从一个异步运行的代码中返回多个值的方法，而不必在返回它们之前聚集整个项目集合(否则我们只是创建一个列表)。它更像是一个异步流，在你开始使用它之前，它什么也不做。也有立即活跃的热流，但在这两种情况下，这是一种在协程之间“发送”无界数据流的机制</p><p id="ae23" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">他们在 Kotlin 网站上给出的简单例子是使用一个基本的构建器</p><ul class=""><li id="ceda" class="nb nc in jm b jn jo jr js jv nd jz ne kd nf kh ng nh ni nj bi translated"><a class="ae ky" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flow.html" rel="noopener ugc nofollow" target="_blank">flow {…}</a>——从对<a class="ae ky" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-flow-collector/emit.html" rel="noopener ugc nofollow" target="_blank"> emit </a>()的连续调用中构造流</li></ul><pre class="kj kk kl km gt mf mg mh mi aw mj bi"><span id="1824" class="mk la in mg b gy ml mm l mn mo">fun simple() = <em class="me">flow </em><strong class="mg io">{<br/>    </strong><em class="me">println</em>("Flow started")<br/>    for (i in 1..3) {<br/>        delay(100)<br/>        emit(i)<br/>    }<br/><strong class="mg io">}<br/></strong>suspend fun test() {<br/>    val flow = <em class="me">simple</em>()<br/>    <em class="me">println</em>("Calling collect...")<br/>    flow.collect <strong class="mg io">{ </strong>value <strong class="mg io">-&gt; </strong><em class="me">println</em>(value) <strong class="mg io">}<br/>    </strong><em class="me">println</em>("Calling collect again...")<br/>    flow.collect <strong class="mg io">{ </strong>value <strong class="mg io">-&gt; </strong><em class="me">println</em>(value) <strong class="mg io">}<br/>    </strong><em class="me">println</em>("Calling collect...")<br/>    flow.collect <strong class="mg io">{ </strong>value <strong class="mg io">-&gt; </strong><em class="me">println</em>(value) <strong class="mg io">}<br/>    </strong><em class="me">println</em>("Calling collect again...")<br/>    flow.collect <strong class="mg io">{ </strong>value <strong class="mg io">-&gt; </strong><em class="me">println</em>(value) <strong class="mg io">}<br/></strong>}</span></pre><p id="6d32" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">更有趣的是，实例返回可以多次读取，并且从头开始:</p><pre class="kj kk kl km gt mf mg mh mi aw mj bi"><span id="79f5" class="mk la in mg b gy ml mm l mn mo">Calling collect...<br/>Flow started<br/>1<br/>2<br/>3<br/>Calling collect again...<br/>Flow started<br/>1<br/>2<br/>3<br/>Calling collect...<br/>Flow started<br/>1<br/>2<br/>3</span></pre><p id="1a0f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">除了这个简单的构建器，几乎没有其他的:</p><ul class=""><li id="95c5" class="nb nc in jm b jn jo jr js jv nd jz ne kd nf kh ng nh ni nj bi translated"><a class="ae ky" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flow-of.html" rel="noopener ugc nofollow" target="_blank"> flowOf </a>()从一组固定的值中创建一个流。</li><li id="929c" class="nb nc in jm b jn nk jr nl jv nm jz nn kd no kh ng nh ni nj bi translated"><a class="ae ky" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/as-flow.html" rel="noopener ugc nofollow" target="_blank"> asFlow() </a>扩展各种类型上的函数，将它们转换成流。</li><li id="6280" class="nb nc in jm b jn nk jr nl jv nm jz nn kd no kh ng nh ni nj bi translated"><a class="ae ky" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/channel-flow.html" rel="noopener ugc nofollow" target="_blank"> channelFlow { … } </a>从对<a class="ae ky" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-send-channel/send.html" rel="noopener ugc nofollow" target="_blank"> send </a>函数的潜在并发调用中构造流，它允许多个协程“添加”到流中</li><li id="e6fb" class="nb nc in jm b jn nk jr nl jv nm jz nn kd no kh ng nh ni nj bi translated"><a class="ae ky" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-mutable-state-flow/index.html" rel="noopener ugc nofollow" target="_blank"> MutableStateFlow </a>和<a class="ae ky" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-mutable-shared-flow/index.html" rel="noopener ugc nofollow" target="_blank"> MutableSharedFlow </a>定义相应的构造函数来创建一个<em class="me"> hot </em>流，一个可以直接更新的流。这些可用于共享状态或广播到多个收集器，以便分别获取所有发出的值。</li></ul><p id="d227" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">流量本身可以在这里填充更多的故事，但我的目标不是重复已经广泛可用的信息，也不是列出我知道或发现的所有可能的信息，所以我认为这就够了。👋</p></div></div>    
</body>
</html>