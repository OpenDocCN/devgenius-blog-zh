<html>
<head>
<title>Memory Alignment</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">内存对齐</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/memory-alignment-8760a5dfc4dc?source=collection_archive---------3-----------------------#2022-08-05">https://blog.devgenius.io/memory-alignment-8760a5dfc4dc?source=collection_archive---------3-----------------------#2022-08-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="562b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">今天我们要谈谈记忆对齐。在我们深入探讨之前，让我们从 Rust 中的一个实际例子开始，来说明为什么这是相关的:</p><pre class="kl km kn ko gt kp kq kr ks aw kt bi"><span id="2616" class="ku kv iq kq b gy kw kx l ky kz">use std::mem;</span><span id="2534" class="ku kv iq kq b gy la kx l ky kz">struct Member {<br/>    active: bool,<br/>    age: i32,<br/>}</span><span id="daec" class="ku kv iq kq b gy la kx l ky kz">fn main() {<br/>    println!("bool: {} bytes", mem::size_of::&lt;bool&gt;());<br/>    println!("i32: {} bytes", mem::size_of::&lt;i32&gt;());<br/>    println!("Member: {} bytes", mem::size_of::&lt;Member&gt;());<br/>}</span></pre><p id="1ca8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们定义了一个名为<code class="fe lb lc ld kq b">Member</code>的结构，它包含两个字段。然后我们打印所有类型的内存大小。rust 中一个<code class="fe lb lc ld kq b">bool</code>的大小是 1 个字节，32 位整数的大小是 4 个字节；因此，我们结构的总大小应该是 5 个字节，对吗？</p><pre class="kl km kn ko gt kp kq kr ks aw kt bi"><span id="a029" class="ku kv iq kq b gy kw kx l ky kz">➜ cargo run<br/>    Finished dev [unoptimized + debuginfo] target(s) in 0.00s<br/>     Running `target/debug/memory-alignment`<br/>bool: 1 bytes<br/>i32: 4 bytes<br/>Member: 8 bytes</span></pre><p id="7db7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是什么样的黑魔法...这多出来的三个字节从何而来？</p><h1 id="f23e" class="le kv iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">CPU 和内存</h1><p id="7158" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">为了理解这是如何工作的，我们需要理解 CPU 是如何读取内存的。CPU 将它想要读取的内存地址发送到地址总线。然后，它在控制总线上向存储器发送“读取”命令，最后，存储器将向数据总线发送数据。</p><figure class="kl km kn ko gt mh gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/ce3cfe7b52b62f7d3a2cfce2f53f208a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/format:webp/1*BhzZU-5ssSvXoATKWZXfXQ.png"/></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">系统总线概述(不包括 I/O)</figcaption></figure><p id="db29" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">传输的数据量通常与一个字(处理器专用的单位)的大小相同。在大多数 64 位 CPU 上，字长等于 8 字节(=64 位)，而在大多数 32 位 CPU 上，字长为 4 字节(=32 位)。未对齐的内存通常会降低性能，因为需要更多的 CPU 指令。这就是内存对齐发挥作用的地方。</p><h1 id="abe4" class="le kv iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">回到我们的代码</h1><p id="04db" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">还记得我们的<code class="fe lb lc ld kq b">Member</code>结构有 8 个字节的大小，而它的字段加起来只占 5 个字节吗？这是因为编译器会自动调整我们的内存。为此，它添加了三个额外字节的填充。</p><figure class="kl km kn ko gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi mo"><img src="../Images/4018c6fd5b863c7b8c421d097963a15e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xmo_1t_xbPteM_35homsCA.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">x86_64 上我们的结构的内存布局</figcaption></figure><p id="13ee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">填充量基于字段类型、结构大小和 CPU 属性(如单词大小)。</p><h1 id="2f01" class="le kv iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">字段顺序</h1><p id="5033" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">在 C、C++、Go 和其他可能的编程语言中，字段的顺序很重要，因为会使用额外的填充。然而，在 Rust 中，默认情况下，struct 字段将被重新排序，以获得尽可能小的大小。编译器被允许这样做，因为默认情况下，Rust <a class="ae mt" href="https://doc.rust-lang.org/reference/type-layout.html#the-default-representation" rel="noopener ugc nofollow" target="_blank">对 struct 类型不做任何保证</a>。</p><p id="e762" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了演示，我们可以使用 C 表示，它将使用与 C 语言互操作的类型布局。让我们向结构中添加另一个布尔字段:</p><pre class="kl km kn ko gt kp kq kr ks aw kt bi"><span id="05d2" class="ku kv iq kq b gy kw kx l ky kz">use std::mem;</span><span id="0437" class="ku kv iq kq b gy la kx l ky kz">#[repr(C)]<br/>struct Member {<br/>    active: bool,<br/>    age: i32,<br/>    admin: bool,<br/>}</span><span id="2b1d" class="ku kv iq kq b gy la kx l ky kz">fn main() {<br/>    println!("Member: {} bytes", mem::size_of::&lt;Member&gt;());<br/>}</span></pre><p id="f468" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lb lc ld kq b">repr(C)</code>属性启用 C 表示。这样，字段就不会被重新排序。让我们执行它来看看结果:</p><pre class="kl km kn ko gt kp kq kr ks aw kt bi"><span id="7fe0" class="ku kv iq kq b gy kw kx l ky kz">➜ cargo run<br/>   Compiling memory-alignment v0.1.0 <br/>    Finished dev [unoptimized + debuginfo] target(s) in 0.53s<br/>     Running `target/debug/memory-alignment`<br/>Member: 12 bytes</span></pre><p id="589d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们现在可以通过手动重新排序字段来“优化”我们的<code class="fe lb lc ld kq b">Member</code>结构。为了将内存大小恢复到 8 字节，我们必须将<code class="fe lb lc ld kq b">age</code>字段移动到 struct:</p><pre class="kl km kn ko gt kp kq kr ks aw kt bi"><span id="0a38" class="ku kv iq kq b gy kw kx l ky kz">use std::mem;</span><span id="6fc5" class="ku kv iq kq b gy la kx l ky kz">#[repr(C)]<br/>struct Member {<br/>    age: i32,<br/>    active: bool,<br/>    admin: bool,<br/>}</span><span id="3a5d" class="ku kv iq kq b gy la kx l ky kz">fn main() {<br/>    println!("Member: {} bytes", mem::size_of::&lt;Member&gt;());<br/>}</span></pre><p id="21f2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了验证这是否有预期的结果，我们需要再次执行我们的程序:</p><pre class="kl km kn ko gt kp kq kr ks aw kt bi"><span id="f773" class="ku kv iq kq b gy kw kx l ky kz">➜ cargo run<br/>   Compiling memory-alignment v0.1.0 <br/>    Finished dev [unoptimized + debuginfo] target(s) in 0.42s<br/>     Running `target/debug/memory-alignment`<br/>Member: 8 bytes</span></pre><p id="7c49" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了理解这是如何工作的，我们可以看看我们的<code class="fe lb lc ld kq b">Member</code>结构在重新排序字段之前和之后的内存布局。</p><figure class="kl km kn ko gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi mu"><img src="../Images/ed8370976e7ac5d66be88356d8cf4301.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I9D89ZYGZXeriWXVzzck2g.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">x86_64 上使用 C 表示的内存布局，包括排序字段和不排序字段</figcaption></figure><h1 id="eff5" class="le kv iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">工具作业</h1><p id="0224" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">如前所述，在使用 Rust 时，工具是不必要的，因为您很可能不需要手动重新排序字段。然而，当你使用 Go 时，你可以用<a class="ae mt" href="https://github.com/golangci/golangci-lint" rel="noopener ugc nofollow" target="_blank"> golangci-lint </a>配置<a class="ae mt" href="https://pkg.go.dev/golang.org/x/tools/go/analysis/passes/fieldalignment" rel="noopener ugc nofollow" target="_blank">字段对齐分析器</a>来警告“未优化”的结构。</p><p id="2efd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我不知道任何 C 或 C++的工具，所以如果你有任何建议，请告诉我。</p></div></div>    
</body>
</html>