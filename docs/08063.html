<html>
<head>
<title>Sharding in Golang with benchmarks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Golang 中的分片与基准</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/sharding-in-golang-with-benchmarks-e72e1b061657?source=collection_archive---------8-----------------------#2022-05-14">https://blog.devgenius.io/sharding-in-golang-with-benchmarks-e72e1b061657?source=collection_archive---------8-----------------------#2022-05-14</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="dbe0" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">关于数据库分片的快速回忆</h2></div><p id="ed26" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">分片数据库是一种机制，通过将数据库分成多个分区(类似于数据库分区机制)并将它们存储在几个实例或服务器中来加快查询或更新数据库的时间。</p><p id="1dff" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">建议在应用它之前总是先从其他方法开始，因为它会增加你的数据库的复杂性，比如连接性、一致性和向后兼容性。</p><p id="bfcc" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">碎片可以是逻辑的也可以是物理的。我画了下图来描述这一点</p><p id="8478" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">逻辑碎片与物理碎片</p><p id="2fc1" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><a class="ae ky" href="https://viewer.diagrams.net/?border=0&amp;tags=%7B%7D&amp;highlight=0000ff&amp;edit=_blank&amp;layers=1&amp;nav=1&amp;title=Untitled%20Diagram.drawio&amp;open=Uhttps%3A%2F%2Fdrive.google.com%2Fuc%3Fid%3D1CXWCBxd0aQfT5GSx5waiOBHxwWSj2J36%26export%3Ddownload" rel="noopener ugc nofollow" target="_blank">https://viewer.diagrams.net/?border=0&amp;tags = % 7B % 7D&amp;highlight = 0000 ff&amp;edit = _ blank&amp;layers = 1&amp;nav = 1&amp;title = Untitled % 20 diagram . draw io&amp;open = Uhttps % 3A % 2F % 2f drive . Google . com % 2 fuc % 3 FID % 3 dcxwcbxd 0 aqft 5 gsx 5 waioobhxwwsj2j 36% 26 export % 3d 下载</a></p><p id="e817" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">由于其复杂性，我们可以依靠第三方来处理，它作为一个池运行，应用程序只需连接到它，选择碎片的决定可以由池处理。我们称之为动态分片。</p><p id="5ce6" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">另一种方法是我们可以自己实现分片，使用一些算法来决定每个请求应该到达哪个分片。我们称之为算法分片。</p><p id="93c5" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">同样，请注意，我们需要确保无论我们使用什么方法，它都应该是一致的和向后兼容的，如果每次对于相同的请求，我们都使用不同的碎片，我们就无法得到想要的结果。为了向后兼容，当我们决定改变分片算法时，旧记录仍然可以以某种方式访问。</p><p id="e387" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这篇文章中，我将使用同样的分片思想来实现一个手工版本来形象化这个思想。</p><h1 id="e6a6" class="kz la in bd lb lc ld le lf lg lh li lj jt lk ju ll jw lm jx ln jz lo ka lp lq bi translated">实现示例</h1><p id="4027" class="pw-post-body-paragraph kc kd in ke b kf lr jo kh ki ls jr kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">实现应用于读写表单 map[key]值的算法分片，你可以把它看作一个键值数据库</p><p id="46c9" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">问题</strong>:</p><p id="c4b6" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我引用了 golang 博客中的一些建议:</p><blockquote class="lw lx ly"><p id="74e5" class="kc kd lz ke b kf kg jo kh ki kj jr kk ma km kn ko mb kq kr ks mc ku kv kw kx ig bi translated">“Go 的并发原语——<strong class="ke io">Go routines 和 channels</strong>——提供了一种优雅而独特的构造并发软件的方法。Go 鼓励使用通道在 goroutines 之间传递对数据的引用，而不是显式地使用锁来协调对共享数据的访问。<a class="ae ky" href="https://go.dev/blog/codelab-share" rel="noopener ugc nofollow" target="_blank">【ref】</a></p></blockquote><p id="30ee" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">和</p><blockquote class="lw lx ly"><p id="b263" class="kc kd lz ke b kf kg jo kh ki kj jr kk ma km kn ko mb kq kr ks mc ku kv kw kx ig bi translated"><a class="ae ky" href="https://go.dev/doc/faq#atomic_maps" rel="noopener ugc nofollow" target="_blank">"地图并发使用不安全</a>没有定义当你同时读写它们时会发生什么。如果您需要从并发执行的 goroutines 中读取和写入映射，那么这些访问必须通过某种同步机制来协调。保护地图的一个常见方法是使用<a class="ae ky" href="https://go.dev/pkg/sync/#RWMutex" rel="noopener ugc nofollow" target="_blank">同步。rw mutex</a><a class="ae ky" href="https://go.dev/blog/maps" rel="noopener ugc nofollow" target="_blank">【ref】</a></p></blockquote><p id="5389" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">事实上，并不总是可以使用 goroutine 和 channel，map 可能就是其中一种情况。</p><p id="1ea2" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们知道在并发中使用 map 时应该使用锁定机制。</p><p id="d24a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这种方法非常有效，但是:</p><p id="7b87" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">使用 RWMutex，只要没有写锁，任何进程都可以获取读锁，另一方面，只有当没有任何现有的提前读写锁时，才可能获取写锁，并且在任何提前锁被释放之前，获取额外锁的尝试将被阻止。</p><p id="161f" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当处理该资源的并发进程数量急剧增加时，获取锁可能会成为瓶颈。</p><p id="84cf" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">垂直分片将底层数据结构(map)分成多个可锁定的 map，有助于减少锁争用。</p><p id="e354" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">想法</strong></p><p id="dca2" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">分割 map 的机制应该是<strong class="ke io">一致的、向后兼容的和防冲突的。</strong></p><p id="601b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一种方法可以是我们采用密钥(校验和)输入的<strong class="ke io">散列，并根据碎片的数量进行模运算，以形成一个碎片密钥。对于每一个请求，我们将计算它并将数据存储到相应的 shard 中。</strong></p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="82ab" class="mm la in mi b gy mn mo l mp mq">hash := sha1.Sum([]byte(key))<br/>shard_key := hash[17] % numberOfShards // 17 is just an arbitrary number<br/>// Note that the size of checksum sha1 is 160 bits or 20 bytes, the arbitrary<br/>// should be lower than 20</span></pre><p id="6ce3" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">实施</strong></p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="8620" class="mm la in mi b gy mn mo l mp mq">// Define shard is a lockable map<br/>type Shard struct {<br/>	m map[string]interface{}<br/>	sync.RWMutex<br/>}<br/><br/>// ShardMap is a collection of shards, an abstraction for read/write data<br/>type ShardMap []*Shard<br/><br/>func makeShardMap(size int) ShardMap {<br/>	m := make([]*Shard, size)<br/>	for i := 0; i &lt; size; i++ {<br/>		s := Shard{m: make(map[string]interface{})}<br/>		m[i] = &amp;s<br/>	}<br/>	return m<br/>}<br/><br/>func (m ShardMap) getShardKey(key string) int {<br/>	hash := sha1.Sum([]byte(key))<br/>	return int(hash[17]) % len(m)<br/>}<br/><br/>func (m ShardMap) GetShard(key string) *Shard {<br/>	shard_key := m.getShardKey(key)<br/>	return m[shard_key]<br/>}<br/><br/>func (m ShardMap) Get(key string) (interface{}, bool) {<br/>	shard := m.GetShard(key)<br/>	shard.RLock()<br/>	defer shard.RUnlock()<br/>	v, ok := shard.m[key]<br/>	return v, ok<br/>}<br/><br/>func (m ShardMap) Set(key string, val interface{}) {<br/>	shard := m.GetShard(key)<br/>	shard.Lock()<br/>	defer shard.Unlock()<br/>	shard.m[key] = val<br/>}<br/><br/>func (m ShardMap) Delete(key string) {<br/>	shard := m.GetShard(key)<br/>	shard.Lock()<br/>	defer shard.Unlock()<br/>	if _, ok := shard.m[key]; ok {<br/>		delete(shard.m, key)<br/>	}<br/>}</span></pre><p id="aa9a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">test_shard.go</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="3f61" class="mm la in mi b gy mn mo l mp mq">func TestGetSetShard(t *testing.T) {<br/>	in := make(map[string]int)<br/>	sm := makeShardMap(20)<br/>	for i := 0; i &lt; 1000; i += 1 {<br/>		k := randomStr(10)<br/>		v := randomInt(0, 1000000)<br/>		in[k] = v<br/>		fmt.Println("shard key: ", sm.getShardKey(k))<br/>		sm.Set(k, v)<br/>	}<br/><br/>	for k, v := range in {<br/>		r, ok := sm.Get(k)<br/>		require.Equal(t, true, ok)<br/>		require.Equal(t, v, r)<br/>	}<br/>}<br/><br/>// Note that init() will always be called automatically before calling main()<br/>func init() {<br/>	rand.Seed(time.Now().UnixNano())<br/>}<br/>func randomStr(size int) string {<br/>	//Random string of character in ASCII subrange ['A'...'z'] (including '/', '?'...)<br/>	//Start index : 0<br/>	//End index: 'z' - 'A'<br/>	var str strings.Builder<br/>	for size &gt; 0 {<br/>		idx := rand.Intn('z' - 'A')<br/>		str.WriteRune(rune(idx + 'A'))<br/>		size -= 1<br/>	}<br/>	return str.String()<br/>}<br/><br/>func randomInt(min, max int) int {<br/>	return min + rand.Intn(max-min) + 1<br/>}</span></pre><p id="084f" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一切顺利，1000 把钥匙没有失败。但是它的性能如何呢？<br/>让我们制定一些基准。</p><h1 id="4963" class="kz la in bd lb lc ld le lf lg lh li lj jt lk ju ll jw lm jx ln jz lo ka lp lq bi translated"><strong class="ak">基准</strong></h1><p id="740b" class="pw-post-body-paragraph kc kd in ke b kf lr jo kh ki ls jr kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">我们将编写一个简单的程序，将 4000 个键和每个键大约 4kB (4000 字节)的数据大小写入单个映射，而不是映射的碎片。我们将允许多达 8000 个 goroutines 并发读/写</p><p id="e71b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">首先，我们使用单一地图创建一个版本</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="c967" class="mm la in mi b gy mn mo l mp mq">var wg sync.WaitGroup<br/><br/>type SimpleMap struct {<br/>	m map[string]interface{}<br/>	sync.RWMutex<br/>	sem chan int<br/>	buf chan []byte<br/>}<br/><br/>func makeSimpleMap() *SimpleMap {<br/>	var sm SimpleMap<br/>	sm = SimpleMap{<br/>		m:   make(map[string]interface{}),<br/>		sem: make(chan int, concurrentGoroutineLimit),<br/>		buf: make(chan []byte, numberOfKeys),<br/>	}<br/>	return &amp;sm<br/>}<br/><br/>func (sm *SimpleMap) Write(k string) {<br/>	sm.Lock()<br/>	defer wg.Done()<br/>	defer sm.Unlock()<br/>	sm.sem &lt;- 1<br/>	sm.m[k] = randomBytes(dataSize)<br/>	&lt;-sm.sem<br/>}<br/><br/>func (sm *SimpleMap) Read(k string) {<br/>	sm.RLock()<br/>	defer wg.Done()<br/>	defer sm.RUnlock()<br/>	sm.sem &lt;- 1<br/>	if v, ok := sm.m[k]; ok {<br/>		sm.buf &lt;- v.([]byte)<br/>	} else {<br/>		sm.buf &lt;- make([]byte, dataSize)<br/>	}<br/>	&lt;-sm.sem<br/>}</span></pre><p id="985d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一些助手随机生成密钥和索引。它需要时间。现在()。UnixNano 作为种子</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="e0ca" class="mm la in mi b gy mn mo l mp mq">func randomString(size int) string {<br/>	return randomBuffer(size).String()<br/>}<br/><br/>func randomBytes(size int) []byte {<br/>	return randomBuffer(size).Bytes()<br/>}<br/><br/>func randomBuffer(size int) *bytes.Buffer {<br/>	var buf bytes.Buffer<br/>	for size &gt; 0 {<br/>		idx := rand.Intn('z' - 'A')<br/>		buf.WriteRune(rune(idx + 'A'))<br/>		size -= 1<br/>	}<br/>	return &amp;buf<br/>}</span></pre><p id="10f4" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">简单映射的执行功能</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="db38" class="mm la in mi b gy mn mo l mp mq">func SimpleMapExecute(sm *SimpleMap) {<br/>	var keys [numberOfKeys]string<br/>	for i := 0; i &lt; numberOfKeys; i += 1 {<br/>		keys[i] = randomString(10)<br/>	}<br/>	start := time.Now()<br/>	for i := 0; i &lt; numberOfKeys; i += 1 {<br/>		wg.Add(2)<br/>		go func(key string) {<br/>			sm.Write(key)<br/>		}(keys[i])<br/><br/>		//Read from random key<br/>		idx := rand.Intn(numberOfKeys)<br/><br/>		go func(key string) {<br/>			sm.Read(key)<br/>		}(keys[idx])<br/>	}<br/>	wg.Wait()<br/>	elapsed := time.Since(start)<br/>	fmt.Println("Took: ", elapsed)<br/>}</span></pre><p id="2c8a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">地图碎片的执行功能</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="be76" class="mm la in mi b gy mn mo l mp mq">func ShardMapExecute(sm *ShardMap) {<br/>	var keys [numberOfKeys]string<br/>	for i := 0; i &lt; numberOfKeys; i += 1 {<br/>		keys[i] = randomString(10)<br/>	}<br/>	start := time.Now()<br/>	for i := 0; i &lt; numberOfKeys; i += 1 {<br/>		wg.Add(2)<br/>		data := randomBytes(dataSize)<br/>		go func(key string) {<br/>			defer wg.Done()<br/>			sm.Set(key, data)<br/>		}(keys[rand.Intn(numberOfKeys)])<br/><br/>		go func(key string) {<br/>			defer wg.Done()<br/>			if v, ok := sm.Get(key); ok {<br/>				Buf &lt;- v.([]byte)<br/>			} else {<br/>				Buf &lt;- make([]byte, dataSize)<br/>			}<br/>		}(keys[rand.Intn(numberOfKeys)])<br/>	}<br/>	wg.Wait()<br/>	elapsed := time.Since(start)<br/>	fmt.Println("Took: ", elapsed)<br/>}</span></pre><p id="8eba" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">准备运行参数</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="a6b8" class="mm la in mi b gy mn mo l mp mq">const (<br/>	numberOfKeys             = 4000<br/>	concurrentGoroutineLimit = 8000<br/>	dataSize                 = 2000<br/>)</span></pre><p id="9869" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最后，主要功能</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="9edd" class="mm la in mi b gy mn mo l mp mq">func main() {<br/>	simpleMode := flag.Bool("simple", false, "Run with simple map")<br/>	flag.Parse()<br/><br/>	if *simpleMode {<br/>		fmt.Println("Run with simple map")<br/>		sm := makeSimpleMap()<br/>		SimpleMapExecute(sm)<br/>	} else {<br/>		fmt.Println("Run with shard map")<br/>		shardMap := makeShardMap(20)<br/>		ShardMapExecute(&amp;shardMap)<br/>	}<br/><br/>}</span></pre><p id="0eb6" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们看看结果:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="31e3" class="mm la in mi b gy mn mo l mp mq">yenle@MacBook-Air-cua-Yen microservice_pattern % go run -race test2.go -simple<br/>Run with simple map<br/>Took:  9.01160475s<br/><br/>yenle@MacBook-Air-cua-Yen microservice_pattern % go run -race test2.go<br/>Run with shard map<br/>Took:  8.007320791s</span></pre><p id="037d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">哇，增强可以看到产卵😊</p><p id="6dce" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在尝试一些其他测试，我将运行 12000 个并发 goroutines，其中 6000 个用于写，6000 个用于读。(注意，我注释掉了上面的信号量，删除了 8000 的限制)。键的数量将减少到 3000 个键。</p><p id="ce17" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">稍微修改一下执行功能:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="86bf" class="mm la in mi b gy mn mo l mp mq">func SimpleMapExecute(sm *SimpleMap) {<br/>	var keys [numberOfKeys]string<br/>	for i := 0; i &lt; numberOfKeys; i += 1 {<br/>		keys[i] = randomString(10)<br/>	}<br/>	start := time.Now()<br/>	for i := 0; i &lt; numberOfKeys; i += 1 {<br/>		wg.Add(4) //create 4 goroutines for each iteration<br/>		go func(key string) {<br/>			sm.Write(key)<br/>		}(keys[rand.Intn(numberOfKeys)])<br/>		<br/>		go func(key string) {<br/>			sm.Write(key)<br/>		}(keys[rand.Intn(numberOfKeys)])<br/><br/>		go func(key string) {<br/>			sm.Read(key)<br/>		}(keys[rand.Intn(numberOfKeys)])<br/>		<br/>		go func(key string) {<br/>			sm.Read(key)<br/>		}(keys[rand.Intn(numberOfKeys)])<br/>	}<br/>	wg.Wait()<br/>	elapsed := time.Since(start)<br/>	fmt.Println("Took: ", elapsed)<br/>}</span></pre><p id="277f" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">和</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="c136" class="mm la in mi b gy mn mo l mp mq">func ShardMapExecute(sm *ShardMap) {<br/>	var keys [numberOfKeys]string<br/>	for i := 0; i &lt; numberOfKeys; i += 1 {<br/>		keys[i] = randomString(10)<br/>	}<br/>	start := time.Now()<br/>	for i := 0; i &lt; numberOfKeys; i += 1 {<br/>		wg.Add(4)  //create 4 goroutines for each iteration<br/>		data := randomBytes(dataSize)<br/>		go func(key string) {<br/>			defer wg.Done()<br/>			sm.Set(key, data)<br/>		}(keys[rand.Intn(numberOfKeys)])<br/>		<br/>		go func(key string) {<br/>			defer wg.Done()<br/>			sm.Set(key, data)<br/>		}(keys[rand.Intn(numberOfKeys)])<br/><br/>		go func(key string) {<br/>			defer wg.Done()<br/>			if v, ok := sm.Get(key); ok {<br/>				Buf &lt;- v.([]byte)<br/>			} else {<br/>				Buf &lt;- make([]byte, dataSize)<br/>			}<br/>		}(keys[rand.Intn(numberOfKeys)])<br/>		<br/>		go func(key string) {<br/>			defer wg.Done()<br/>			if v, ok := sm.Get(key); ok {<br/>				Buf &lt;- v.([]byte)<br/>			} else {<br/>				Buf &lt;- make([]byte, dataSize)<br/>			}<br/>		}(keys[rand.Intn(numberOfKeys)])<br/>	}<br/>	wg.Wait()<br/>	elapsed := time.Since(start)<br/>	fmt.Println("Took: ", elapsed)<br/>}</span><span id="db91" class="mm la in mi b gy mr mo l mp mq">const (<br/>	numberOfKeys             = 3000<br/>	concurrentGoroutineLimit = 8000<br/>	dataSize                 = 4000<br/>)</span></pre><p id="2b98" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">和结果:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="dc0a" class="mm la in mi b gy mn mo l mp mq">yenle@MacBook-Air-cua-Yen microservice_pattern % go run -race test2.go -simple<br/>Run with simple map<br/>Took:  14.156822542s<br/>yenle@MacBook-Air-cua-Yen microservice_pattern % go run -race test2.go        <br/>Run with shard map<br/>Took:  5.989326334s</span></pre><p id="775d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">瞧！巨大的不同😀</p><p id="de3c" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">再用 4000 把钥匙试试</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="5b11" class="mm la in mi b gy mn mo l mp mq">yenle@MacBook-Air-cua-Yen microservice_pattern % go run -race test2.go -simple<br/>Run with simple map<br/>Took:  19.437610875s<br/>yenle@MacBook-Air-cua-Yen microservice_pattern % go run -race test2.go        <br/>Run with shard map<br/>Took:  8.30976475s</span></pre><p id="65cd" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">两倍多的速度。</p><p id="b7c0" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">好了，最后一句话，如果你读到这里，谢谢😄帖子到现在都挺长的。</p><p id="a5d7" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">使用分片也是非常有趣和有效的，它不仅适用于读取/更新地图，还适用于任何需要大量 goroutines 并发运行的任务，但缺点是可能会增加更多的复杂性，并可能以某种方式导致死锁，我们需要在使用前仔细测试。</p><p id="ca36" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">希望这篇文章对你有所帮助。🙌</p></div><div class="ab cl ms mt hr mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ig ih ii ij ik"><p id="776c" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="lz">最初发表于</em><a class="ae ky" href="https://gist.github.com/Yenle9/6612281c69c86876d824b0374311222a" rel="noopener ugc nofollow" target="_blank"><em class="lz">【http://github.com】</em></a><em class="lz">。</em></p></div></div>    
</body>
</html>