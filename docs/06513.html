<html>
<head>
<title>My ELI5 For Basic React Concepts: Lifting State Up</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基本反应概念的我的ELI5:提升状态</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/my-eli5-for-basic-react-concepts-lifting-state-up-b4b9865a35c3?source=collection_archive---------8-----------------------#2022-01-13">https://blog.devgenius.io/my-eli5-for-basic-react-concepts-lifting-state-up-b4b9865a35c3?source=collection_archive---------8-----------------------#2022-01-13</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="2213" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">像大多数偶然发现这一点的人一样，我正在自学React和前端开发。虽然学习有时会令人难以置信地兴奋，但如果一开始就遇到障碍，感觉自己没有理解某个关键概念，那会令人沮丧。我的一部分想让火车继续前进，但我知道充分理解基础知识是至关重要的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1d1263c2de40595911e8ef9928b2efeb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x0d41ns8PTQZz4a3VbMrBg.png"/></div></div></figure><p id="e8e3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我一直在遵循由Maximilian Schwarzmüller在Udemy上写的“完整的反应指南”,并发现对我来说解决一些较难的概念的最好方法是写一步一步的指南，尽可能简单地分解。我分享这些，希望至少还有一个像我一样的白痴可以帮助到他们。</p><p id="07b3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我的第一次重大学习危机发生在第59课，关于<strong class="jm io">提升状态的讲座。</strong>查看评论，我不是一个人。让它变得如此困难的是所有这些部分相互反馈，使得很难跟踪什么在进行，在哪里进行以及为什么进行。我的头脑需要的是某种清晰的秩序。因此，我用Udemy课程的例子写了这个指南。</p><h1 id="8bb6" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">第一部分</h1><h2 id="8a7d" class="ls kv in bd kw lt lu dn la lv lw dp le jv lx ly li jz lz ma lm kd mb mc lq md bi translated">使用useState保存表单数据</h2><p id="105d" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">在这一步中，我们正在处理一个表单，并希望保存用户输入到对象中的任何数据，这样我们就可以在第二部分中将数据发送到父组件。</p><p id="8e8c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">第一步</strong></p><p id="51a8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在子组件中，选择要从中收集数据的HTML元素(如输入字段)并添加事件处理程序。事件处理程序是以“on”开头的特殊属性。在这个例子中，我们的事件处理程序将是<code class="fe mj mk ml mm b">onChange</code>。</p><pre class="kj kk kl km gt mn mm mo mp aw mq bi"><span id="dc30" class="ls kv in mm b gy mr ms l mt mu">&lt;input type=”text” onChange={}&gt;</span></pre><p id="5b6c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">第二步</strong></p><p id="9744" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们刚刚添加的事件处理程序想要接收一个函数。因此，我们将在return上方的同一个组件中创建一个箭头函数。根据不同的情况，有不同的方法来构建这些函数，现在，我们让它为空。</p><pre class="kj kk kl km gt mn mm mo mp aw mq bi"><span id="44f9" class="ls kv in mm b gy mr ms l mt mu">const titleChangedHandler = () =&gt; {};</span></pre><p id="2ecb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在最重要的是函数保存在一个变量中，并且在第一步中添加的事件处理程序指向这个函数。命名约定是以“Handler”结束变量名，所以我们将这个命名为<code class="fe mj mk ml mm b">titleChangedHandler</code>。</p><pre class="kj kk kl km gt mn mm mo mp aw mq bi"><span id="fe7b" class="ls kv in mm b gy mr ms l mt mu">&lt;input type="text" onChange={titleChangedHandler};</span></pre><p id="d4f1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">第三步</strong></p><p id="afff" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下一步是实现一个<code class="fe mj mk ml mm b">useState</code>挂钩。首先，我需要<code class="fe mj mk ml mm b">import 'useState from 'react'</code>，这样我就可以在这个组件中使用钩子。</p><p id="910a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">第四步</strong></p><p id="5866" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">接下来，为了实现useState，我使用数组析构创建了一个常量。第一个变量是我们的“状态变量”,它的值是在赋值操作符另一侧的useState的括号内确定的。所以我声明了一个状态变量，并设置了它的初始值(在本例中，是一个空字符串)，我将它命名为<code class="fe mj mk ml mm b">enteredTitle</code>。</p><pre class="kj kk kl km gt mn mm mo mp aw mq bi"><span id="654d" class="ls kv in mm b gy mr ms l mt mu">const [enteredTitle, ] = useState("")</span></pre><p id="3735" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">数组中的第二个变量是一个更新状态的函数。标准的命名约定是以“set”开始命名。这里我将其命名为<code class="fe mj mk ml mm b">setEnteredTitle</code>。</p><pre class="kj kk kl km gt mn mm mo mp aw mq bi"><span id="5e27" class="ls kv in mm b gy mr ms l mt mu">const [enteredTitle, setEnteredTitle] = useState("")</span></pre><p id="f08a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">第五步</strong></p><p id="b45f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">回到我在第二步中创建的箭头函数，我将在函数中使用<code class="fe mj mk ml mm b">setEnteredTitle</code>函数，并给它一个新值。</p><p id="2ca0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">将它放在这个箭头函数中意味着它将更新<code class="fe mj mk ml mm b">onChange</code>，因为这个函数是由我作为输入元素的属性放入的<code class="fe mj mk ml mm b">onChange</code>事件处理程序调用的。</p><p id="b5fb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以，我返回到空的<code class="fe mj mk ml mm b">titleChangedHandler</code>函数并填充它。</p><pre class="kj kk kl km gt mn mm mo mp aw mq bi"><span id="f091" class="ls kv in mm b gy mr ms l mt mu">const titleChangedHandler = (event) =&gt; {<br/>  setEnteredTitle(event.target.value);<br/>}; </span></pre><p id="bf0c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当发生变化时，我放入arrow函数的任何参数都会自动创建一个合成事件对象。</p><p id="5a00" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在event对象中有一个<code class="fe mj mk ml mm b">target</code>对象，它显示了一个键-值对的列表，这些键-值对表示发生变化的DOM元素(输入)的当前状态。<code class="fe mj mk ml mm b">value</code>属性(在<code class="fe mj mk ml mm b">target</code>属性内)保存事件发生时输入的当前值(在本例中为<code class="fe mj mk ml mm b">onChange</code>)。</p><p id="b878" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">第六步</strong></p><p id="8fa2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对所有表单元素重复这些步骤。</p><p id="6027" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">第七步</strong></p><p id="a1be" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果表单有一个带<code class="fe mj mk ml mm b">type="submit"</code>的按钮，那么在<code class="fe mj mk ml mm b">form</code>元素上我可以添加事件处理程序<code class="fe mj mk ml mm b">onSubmit</code>。</p><pre class="kj kk kl km gt mn mm mo mp aw mq bi"><span id="bd12" class="ls kv in mm b gy mr ms l mt mu">&lt;form onSubmit={}&gt;</span></pre><p id="daae" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">第八步</strong></p><p id="af20" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后我可以继续添加处理函数，我称它为<code class="fe mj mk ml mm b">submitHandler</code>，暂时保留为空。</p><pre class="kj kk kl km gt mn mm mo mp aw mq bi"><span id="96a2" class="ls kv in mm b gy mr ms l mt mu">const submitHandler = () =&gt; {};</span></pre><p id="d44d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">第九步</strong></p><p id="cae2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我回到表单元素，将<code class="fe mj mk ml mm b">onSubmit</code>事件处理程序指向处理程序函数。</p><pre class="kj kk kl km gt mn mm mo mp aw mq bi"><span id="d7bf" class="ls kv in mm b gy mr ms l mt mu">&lt;form onSubmit={submitHandler}&gt;</span></pre><p id="03ad" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">第十步</strong></p><p id="0980" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">需要记住的一件重要事情是，当提交表单时，默认的浏览器行为是刷新页面并向服务器(在本例中是react开发服务器)发送请求。但是这里我想做的是使用JavaScript处理表单提交，并手动使用我从表单中收集的数据，而不刷新apge。</p><p id="f090" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在React中实现这一点的方法是在<code class="fe mj mk ml mm b">submitHandler</code>函数中访问合成事件对象，并使用<code class="fe mj mk ml mm b">preventDefault()</code>方法，该方法阻止发送请求，因此我们可以继续使用JavaScript，而无需重新加载页面。</p><pre class="kj kk kl km gt mn mm mo mp aw mq bi"><span id="36c2" class="ls kv in mm b gy mr ms l mt mu">const submitHandler = (event) =&gt; {<br/>  event.preventDefault();</span></pre><p id="b1de" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">第11步</strong></p><p id="b50b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，在<code class="fe mj mk ml mm b">submitHandler</code>函数中，我想创建一个对象，包含单击提交按钮时表单中的所有数据，我将其命名为<code class="fe mj mk ml mm b">expenseData</code>。</p><p id="e06f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">它看起来会像这样:</p><pre class="kj kk kl km gt mn mm mo mp aw mq bi"><span id="cb56" class="ls kv in mm b gy mr ms l mt mu">const submitHandler = (event) =&gt; {<br/>  event.preventDefault();<br/>  const expenseData = {<br/>    title: enteredTitle,<br/>    amount: enteredAmount,<br/>    date: new Date(enteredDate),<br/>  };<br/>};</span></pre><p id="f6e2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在我有了一个当用户点击提交时创建的对象。但是我也希望当用户单击submit时表单被清空。我该怎么做？</p><p id="1d73" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">第12步</strong></p><p id="1269" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们可以通过使用<strong class="jm io">双向绑定</strong>将新值传递回输入。我们通过向输入元素添加<code class="fe mj mk ml mm b">value</code>属性来实现这一点。我想将值设置为<code class="fe mj mk ml mm b">enteredTitle</code>以将其反馈到状态中。</p><pre class="kj kk kl km gt mn mm mo mp aw mq bi"><span id="08bf" class="ls kv in mm b gy mr ms l mt mu">&lt;input type="text" <strong class="mm io">value={enteredTitle} </strong>onChange={titleChangedHandler}&gt;</span></pre><p id="2077" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">第十三步</p><p id="2145" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在我已经创建了输入和状态之间的双向绑定，我可以在提交时通过调用<code class="fe mj mk ml mm b">setEnteredTitle()</code>并将其设置为空字符串来清除输入字段，从而清除用户输入的内容。</p><p id="880b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这仅在<code class="fe mj mk ml mm b">value</code>道具已添加到输入中时有效，否则输入不能改变。因此，在<code class="fe mj mk ml mm b">submitHandler</code>函数中，在<code class="fe mj mk ml mm b">expenseData</code>对象之后，我将调用<code class="fe mj mk ml mm b">setEnteredTitle("");</code>并对其他输入字段进行同样的操作。</p><pre class="kj kk kl km gt mn mm mo mp aw mq bi"><span id="5897" class="ls kv in mm b gy mr ms l mt mu">const submitHandler = (event) =&gt; {<br/>  event.preventDefault();<br/>  const expenseData = {<br/>    title: enteredTitle,<br/>    amount: enteredAmount,<br/>    date: new Date(enteredDate),<br/>  };<br/>  <strong class="mm io">setEnteredTitle("");<br/>  setEnteredAmount("");<br/>  setEnteredDate("");<br/></strong>};</span></pre><h1 id="999e" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">第二部分</h1><h2 id="7449" class="ls kv in bd kw lt lu dn la lv lw dp le jv lx ly li jz lz ma lm kd mb mc lq md bi translated">提升数据</h2><p id="4f52" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">好了，到目前为止，我已经在我的子组件中构建了状态，我还收集了数据并将其保存在一个对象中，并且在按下提交按钮后清除了输入字段。下一步是将数据带到父元素，我将在那里使用它。</p><p id="40b2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">第一步</strong></p><p id="cb48" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在父组件中，转到正在渲染子组件的<code class="fe mj mk ml mm b">return</code>,添加一个新道具。我将道具命名为<code class="fe mj mk ml mm b">onSaveExpenseData</code>以明确道具的值是一个函数。</p><p id="c894" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">第二步</strong></p><p id="92d1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后，我照常工作，将处理程序变量声明为一个箭头函数。我还将传递给它一个参数，<code class="fe mj mk ml mm b">enteredExpenseData</code>，我将用它来收集子组件中的数据。</p><pre class="kj kk kl km gt mn mm mo mp aw mq bi"><span id="ec17" class="ls kv in mm b gy mr ms l mt mu">const saveExpenseDataHandler = (enteredExpenseData) =&gt; {}</span></pre><p id="32b3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">第三步</strong></p><p id="b583" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，回到子组件，我必须使用<code class="fe mj mk ml mm b">onSaveExpenseData</code>道具作为参数。因此，第一步是告诉<code class="fe mj mk ml mm b">ExpenseForm</code>函数接受道具。</p><pre class="kj kk kl km gt mn mm mo mp aw mq bi"><span id="a398" class="ls kv in mm b gy mr ms l mt mu">const ExpenseForm = <strong class="mm io">(props) =&gt; {</strong></span></pre><p id="8aaa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">第四步</strong></p><p id="c838" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，在<code class="fe mj mk ml mm b">submitHandler</code>上，我访问<code class="fe mj mk ml mm b">props.onSaveExpenseData</code>并执行它。</p><pre class="kj kk kl km gt mn mm mo mp aw mq bi"><span id="560e" class="ls kv in mm b gy mr ms l mt mu">const submitHandler = (event) =&gt; {<br/>  event.preventDefault();<br/>  const expenseData = {<br/>    title: enteredTitle,<br/>    amount: enteredAmount,<br/>    date: new Date(enteredDate),<br/>  };<br/>  <strong class="mm io">props.onSaveExpenseData();</strong></span><span id="9cf1" class="ls kv in mm b gy mv ms l mt mu">  setEnteredTitle("");<br/>  setEnteredAmount("");<br/>  setEnteredDate("");<strong class="mm io"><br/></strong>};</span></pre><p id="39a6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这就是奇迹发生的地方！！</p><p id="c9f0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们正在执行一个位于<strong class="jm io">父组件</strong>中的函数，因为函数的一个指针被<code class="fe mj mk ml mm b">onSaveExpenseData</code>属性传递给了子组件。</p><p id="8c8c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">这是一个非常重要的模式！</strong></p><p id="fd68" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">第五步</strong></p><p id="893e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当我调用<code class="fe mj mk ml mm b">submitHandler</code>函数中的<code class="fe mj mk ml mm b">onSaveExpenseData</code>时，我可以将<code class="fe mj mk ml mm b">expenseData</code>对象(我在上面生成的)作为参数传递。</p><pre class="kj kk kl km gt mn mm mo mp aw mq bi"><span id="d202" class="ls kv in mm b gy mr ms l mt mu">props.onSaveExpenseData(<strong class="mm io">expenseData</strong>);</span></pre><p id="dc47" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是给我一个<code class="fe mj mk ml mm b">expenseData</code>作为父组件的参数，在<code class="fe mj mk ml mm b">saveExpenseDataHandler</code>函数中。</p><p id="932c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，在父组件中:</p><pre class="kj kk kl km gt mn mm mo mp aw mq bi"><span id="3501" class="ls kv in mm b gy mr ms l mt mu">const saveExpenseDataHandler = (<strong class="mm io">enteredExpenseData</strong>) =&gt; {}</span></pre><p id="317d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe mj mk ml mm b"><strong class="jm io">enteredExpenseData</strong></code> <strong class="jm io">可以</strong>可以叫任何东西，它永远是我在子组件中设置<code class="fe mj mk ml mm b">onSaveExpenseData</code>的值为的<code class="fe mj mk ml mm b">expenseData</code>。</p><p id="95ea" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">道具名<code class="fe mj mk ml mm b">onSaveExpenseData</code>是我在子组件中使用的。这就是我如何在那里访问它，并把值设置为我想要提升的任何数据。当我想调出该信息并在父组件中使用它时，我就使用处理函数，在本例中是<code class="fe mj mk ml mm b">saveExpenseDataHandler</code>。在处理函数中，我可以传递一个参数，它将自动包含我刚刚在子组件中设置的数据。</p><h1 id="039a" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">结论</h1><p id="821d" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">希望这对某人有用。将这些步骤按逻辑顺序排列对我来说非常有用，这是我在谷歌上很难找到的。</p><p id="c066" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">总的来说，我是React和JS的新手，所以这篇文章中肯定会有一些语义错误，如果你注意到了，请在评论中指出来，这样我就可以修复它们。</p><p id="69de" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们继续学习。</p></div></div>    
</body>
</html>