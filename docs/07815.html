<html>
<head>
<title>State Pattern In Unity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">统一状态模式</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/state-pattern-in-unity-cd180f98c45?source=collection_archive---------5-----------------------#2022-04-25">https://blog.devgenius.io/state-pattern-in-unity-cd180f98c45?source=collection_archive---------5-----------------------#2022-04-25</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="4e6e" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">动画师控制器 FSM 和状态机行为</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi kc"><img src="../Images/0bb0a0866a3df7d19ea49d87fbab3cc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1252/format:webp/1*6L8c-uIdeX4z0e_pA7eSEg.png"/></div><figcaption class="kk kl gj gh gi km kn bd b be z dk translated">状态设计模式</figcaption></figure><p id="141d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">状态模式接近于一个<a class="ae lk" href="https://ktmarine1999.medium.com/finite-state-machines-in-unity-950b912ce844" rel="noopener">有限状态机</a>。状态模式通过使 FSM 更加面向对象和更加易读来改进它。上下文就是状态机本身，然后你就有了我们可能处于的状态，每个状态都是它自己的类。</p><p id="22ab" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在他们的书<em class="ll">中，设计模式:可重用面向对象软件</em>的元素，Erich Gamma，Richard Helm，Ralph Johnson 和 John Vlissides——<em class="ll">四人组</em>将状态模式的<em class="ll">意图</em>定义如下:</p><blockquote class="lm ln lo"><p id="fb92" class="ko kp ll kq b kr ks jo kt ku kv jr kw lp ky kz la lq lc ld le lr lg lh li lj ig bi translated">"允许对象在其内部状态改变时改变其行为。该对象将显示为改变其类别。</p></blockquote><h2 id="1815" class="ls lt in bd lu lv lw dn lx ly lz dp ma kx mb mc md lb me mf mg lf mh mi mj mk bi translated">定义</h2><ul class=""><li id="58d1" class="ml mm in kq b kr mn ku mo kx mp lb mq lf mr lj ms mt mu mv bi translated">上下文-将具体状态的实例作为当前状态进行维护。这就是状态机本身。</li><li id="0126" class="ml mm in kq b kr mw ku mx kx my lb mz lf na lj ms mt mu mv bi translated">抽象状态(State) —定义一个封装所有特定于状态的行为的接口。通常是接口，但也可以是抽象类或基类。</li><li id="7921" class="ml mm in kq b kr mw ku mx kx my lb mz lf na lj ms mt mu mv bi translated">具体状态—实施特定于特定上下文状态的行为。抽象状态的子类。</li></ul><h1 id="4037" class="nb lt in bd lu nc nd ne lx nf ng nh ma jt ni ju md jw nj jx mg jz nk ka mj nl bi translated">履行</h1><p id="63ed" class="pw-post-body-paragraph ko kp in kq b kr mn jo kt ku mo jr kw kx nm kz la lb nn ld le lf no lh li lj ig bi translated">我要看一看运动状态，这和我在 FSM 文章中使用的是同一个状态。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi np"><img src="../Images/67400d989e246c6d35501a12ace56b87.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*SHY4koLe7eaU26AculXTVA.png"/></div></figure><h2 id="ebf4" class="ls lt in bd lu lv lw dn lx ly lz dp ma kx mb mc md lb me mf mg lf mh mi mj mk bi translated">纯代码。</h2><p id="d42d" class="pw-post-body-paragraph ko kp in kq b kr mn jo kt ku mo jr kw kx nm kz la lb nn ld le lf no lh li lj ig bi translated">我要实现的第一件事是上下文。我将使用一个接口，这样在创建状态时就不会有循环引用。我是说，移动上下文必须有一个名为 Set State 的方法，它接收状态接口的参数。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/7e69e4d4f669e5b9e04d8c3fdbf7a8cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1264/format:webp/1*hT3Hh7o-FfJpJyQqEVg1Aw.png"/></div><figcaption class="kk kl gj gh gi km kn bd b be z dk translated">运动情境界面</figcaption></figure><p id="17fc" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">接下来，我创建运动抽象状态，我将再次为此使用一个接口。通常状态有一个入口、一个出口和更新逻辑方法。你可以在这里添加任何你想让所有状态共有的方法，比如更新物理。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi nr"><img src="../Images/e25d2e33d4b8b1318068e0153dcb688e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r4rsqOiybwyk6j7VLqbohQ.png"/></div></div></figure><p id="88f3" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在我可以完成上下文的实现了。这包含了我们当前所处的状态。当将状态设置为不同的状态时，我退出当前状态，将当前状态设置为新状态，我调用进入状态。在更新方法中，我调用了当前状态更新方法。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi nw"><img src="../Images/2af514cf55f7a8554c02e39e1df59907.png" data-original-src="https://miro.medium.com/v2/resize:fit:1394/format:webp/1*AtLyhqm8JAKYlXgJ93uFIA.png"/></div></div><figcaption class="kk kl gj gh gi km kn bd b be z dk translated">运动环境</figcaption></figure><p id="84b2" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在，我可以创建任何我希望能够更改的状态，并将逻辑放入状态本身。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/fe18792313d4b354bb3357a419c69c1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1292/format:webp/1*6D0UZ3gsbqygGo9kFpm72A.png"/></div><figcaption class="kk kl gj gh gi km kn bd b be z dk translated">接地状态</figcaption></figure><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/b332cbe2b28105a550a0ab94c3191186.png" data-original-src="https://miro.medium.com/v2/resize:fit:1266/format:webp/1*8eO8gou3kt8D289LNSac_w.png"/></div><figcaption class="kk kl gj gh gi km kn bd b be z dk translated">蹲伏状态</figcaption></figure><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi nz"><img src="../Images/47dd00195cc430921ee5798f1898fe6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TZTJ5T5kikbMp_cwjrRspA.png"/></div></div><figcaption class="kk kl gj gh gi km kn bd b be z dk translated">在空气状态下</figcaption></figure><p id="9641" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这比简单的 FSM 干净多了。如果我想添加一个新的状态，比方说游泳状态，我需要做的就是创建该状态，为游泳设置更新逻辑，我需要修改的唯一状态是我想转换到游泳状态的状态，我可以很容易地找到这些状态并添加新的逻辑。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi oa"><img src="../Images/b0e4251c9a8d58bc114608a5ccbbc53b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*lTNl22jZFG0LWj1NHes2qg.gif"/></div></div></figure><h2 id="0bd0" class="ls lt in bd lu lv lw dn lx ly lz dp ma kx mb mc md lb me mf mg lf mh mi mj mk bi translated">使用动画组件。</h2><p id="3421" class="pw-post-body-paragraph ko kp in kq b kr mn jo kt ku mo jr kw kx nm kz la lb nn ld le lf no lh li lj ig bi translated">通过使用 Unity 内置的 Animator 组件作为上下文和状态机行为(Unity 使用英式拼写行为)作为抽象状态，这可以进一步简化。</p><div class="ob oc gp gr od oe"><a href="https://docs.unity3d.com/Manual/AnimationOverview.html" rel="noopener  ugc nofollow" target="_blank"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd io gy z fp oj fr fs ok fu fw im bi translated">动画系统概述</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">Unity 有一个丰富而复杂的动画系统(有时被称为“Mecanim”)。它提供:简单的工作流程…</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">docs.unity3d.com</p></div></div><div class="on l"><div class="oo l op oq or on os ki oe"/></div></div></a></div><div class="ob oc gp gr od oe"><a href="https://docs.unity3d.com/ScriptReference/StateMachineBehaviour.html" rel="noopener  ugc nofollow" target="_blank"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd io gy z fp oj fr fs ok fu fw im bi translated">状态机行为</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">unity engine/Inherits from:ScriptableObject/建议更改感谢您帮助我们提高质量…</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">docs.unity3d.com</p></div></div><div class="on l"><div class="ot l op oq or on os ki oe"/></div></div></a></div><p id="3124" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">结合使用这些方法，我不必确保在状态上调用 Enter、Exit 或 Update 方法。单位为我处理所有这些。它还处理其他一些对您可能有用的消息。</p><p id="2863" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">第一步是设置动画控制器作为我的 FSM</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi ou"><img src="../Images/2176a675fc7040a96ce462ad74b5538b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*ftkoiv4uPBeiXlntgW329A.gif"/></div></div></figure><p id="771e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">然后，我向状态添加一个行为，我可以添加一个我已经创建的行为，也可以添加一个我已经创建的行为。我也可以有一个没有行为的状态。在这个例子中，我将为我所有的状态设置一个行为。</p><p id="4fad" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在我要做的就是为我的状态创建具体的状态(状态机行为)。然后我重写了输入和更新方法。进入、退出和更新有多种选择，请根据需要选择。需要注意的一点是 OnStateMachine(进入/退出)和 OnState(进入/退出)之间的区别。当然你也有 Ik 和 Move 方法。</p><ul class=""><li id="b4b9" class="ml mm in kq b kr ks ku kv kx ov lb ow lf ox lj ms mt mu mv bi translated">状态机进入时—转换到状态机时，在第一个更新帧时调用。当转换到状态机子状态时，不会调用这个函数。</li><li id="2adc" class="ml mm in kq b kr mw ku mx kx my lb mz lf na lj ms mt mu mv bi translated">状态机退出时—从状态机转换出来时，在第一个更新帧时调用。当转换到状态机子状态时，不会调用这个函数。</li><li id="ed51" class="ml mm in kq b kr mw ku mx kx my lb mz lf na lj ms mt mu mv bi translated">状态进入时—当状态机评估此状态时，在第一个更新帧上调用。</li><li id="9d95" class="ml mm in kq b kr mw ku mx kx my lb mz lf na lj ms mt mu mv bi translated">状态退出时—当状态机评估此状态时，在最后一个更新帧上调用。</li></ul><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi oy"><img src="../Images/90e04aad007fda7b102034ad4c137424.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Z_OaKPPYnw87et1a9fcMSw.gif"/></div></div><figcaption class="kk kl gj gh gi km kn bd b be z dk translated">创造接地行为</figcaption></figure><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi oz"><img src="../Images/c6ef221318b3f842a63c353e18658365.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*op_eIxorZ64ol3TQqCQxdg.png"/></div></div><figcaption class="kk kl gj gh gi km kn bd b be z dk translated">蛰伏状态行为。</figcaption></figure><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi pa"><img src="../Images/b380ad8c4d6318d9c7b5cbda6c5b0318.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_Kehc5fITw1YBUaTKhAkDw.png"/></div></div><figcaption class="kk kl gj gh gi km kn bd b be z dk translated">空气状态下的行为</figcaption></figure><p id="1f58" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">因为我的固定状态和蹲下状态是完全相同的代码，所以我可以对两者都使用固定行为。区别在于它们何时转换状态，这是由动画师控制器控制的。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi oy"><img src="../Images/7c1176eddea02aac763755fdcc95f1fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*BZuVlqCOPoUdmjUMzTI4xw.gif"/></div></div></figure><p id="ac66" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">你也可以为每个状态添加多个行为，例如，我有一个基于速度变量改变状态的运动状态，而不是固定状态，我可以将固定行为放在运动状态和蹲下状态上，因为这两种状态只有在角色固定时才会发生。然后放置一个移动行为。</p><h2 id="bcae" class="ls lt in bd lu lv lw dn lx ly lz dp ma kx mb mc md lb me mf mg lf mh mi mj mk bi translated">真实世界的例子。</h2><p id="7ebe" class="pw-post-body-paragraph ko kp in kq b kr mn jo kt ku mo jr kw kx nm kz la lb nn ld le lf no lh li lj ig bi translated">我的游戏中有一个角色有一个动画控制器和一个角色运动脚本。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi pb"><img src="../Images/3930b01d9b04c18d035d55d2167509d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:810/1*1Y6nJ_QoQR2BQl54z5uZfw.gif"/></div><figcaption class="kk kl gj gh gi km kn bd b be z dk translated">我游戏里的一个角色。</figcaption></figure><p id="972b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">动画师控制器由两个状态机组成，一个接地，一个在空中。地面状态机有一个附加的行为，跳转状态有一个附加的行为。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi pc"><img src="../Images/7b1a3586ed7b1aa9e70293312c7f982f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*qNviCqyuI0YTUpeejsz9mA.gif"/></div></div><figcaption class="kk kl gj gh gi km kn bd b be z dk translated">动画控制器</figcaption></figure><p id="ba01" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">当“固定”行为进入状态时，会将 y 速度设定为设定值。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi pd"><img src="../Images/642e4927d3b514415393a4defb75e830.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FwP5YT8-0idZCVjiDWnPVg.png"/></div></div><figcaption class="kk kl gj gh gi km kn bd b be z dk translated">玩家接地行为</figcaption></figure><p id="f102" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">“跳跃状态”行为控制角色使用的跳跃、跳跃的高度以及在 y 轴上移动的方向。如果它进入状态，当它退出状态时，它会重置所有东西。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi pe"><img src="../Images/5008a7200707dfdd4d12652c299c7423.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*8cxYqdFni0wFMrQN30LrQA.gif"/></div></div><figcaption class="kk kl gj gh gi km kn bd b be z dk translated">玩家跳跃状态行为</figcaption></figure><p id="2cd7" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">角色的移动基于给定的输入，它从 animator 状态机获得 Y 速度，并通过设置 is grounded boolean 告诉状态机角色是否被固定。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi pf"><img src="../Images/f0a466161c9662b6243f774ebc160463.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*cg2WtUamWj55ofEiAPJ0_g.gif"/></div></div><figcaption class="kk kl gj gh gi km kn bd b be z dk translated">角色移动脚本工作正在进行中。</figcaption></figure><h1 id="5549" class="nb lt in bd lu nc nd ne lx nf ng nh ma jt ni ju md jw nj jx mg jz nk ka mj nl bi translated">结论</h1><p id="cbca" class="pw-post-body-paragraph ko kp in kq b kr mn jo kt ku mo jr kw kx nm kz la lb nn ld le lf no lh li lj ig bi translated">状态模式使得实现复杂的状态机变得容易，这些状态机可以很容易地添加新的状态。</p><p id="8413" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">正确实施这也遵循所有坚实的原则。在示例代码中，我确实在技术上打破了接口隔离原则，在我的状态没有实际使用它们时，在接口中使用了 On Exit 和 On Enter 方法，如果我在游戏中完全实现它们，它们可能会有一些设置和清理代码，这样下次状态运行时就会有正确的本地值。单个状态(接地、空中、蹲下)可能会打破开闭原则，因为添加新的状态时，您可能需要修改这些类，以确保添加新的过渡，有几种方法可以解决这一问题，其中最简单的方法是使用 Unity 内置的动画系统。</p><p id="8f3a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">内置的 Animator 控制器实际上使用了状态机模式。动画控制器是上下文，添加到其中的状态是使用抽象状态的具体状态，有 3 种不同类型的状态和添加到状态机的子状态机。控制器所处的不同状态可以通过使用状态机行为来进一步扩展。您可以在游戏中有多种类型的角色使用同一个 Animator 控制器，即使角色上的动画有很大不同(使用覆盖控制器)。</p><p id="85e1" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这个项目的代码可以在我的 Git Hub 页面上找到。</p><p id="22cb" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><a class="ae lk" href="https://github.com/JamesLaFritz/Design-Patterns-For-Unity/tree/release-StateMachines" rel="noopener ugc nofollow" target="_blank">https://github . com/JamesLaFritz/Design-Patterns-For-Unity/tree/release-state machines</a></p></div></div>    
</body>
</html>