<html>
<head>
<title>Underrated Functional Python Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">被低估的 Python 函数</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/underrated-functional-python-functions-5f0044de2f7f?source=collection_archive---------6-----------------------#2020-11-15">https://blog.devgenius.io/underrated-functional-python-functions-5f0044de2f7f?source=collection_archive---------6-----------------------#2020-11-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/48e4e5327c22bad77669321568f4e7ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6D8RRVNge0uPfiRt"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">Emile Perron 在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="344f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Python 是目前最通用的编程语言之一。从声明式编程到面向对象编程，再到函数式编程，Python 融合了多种编程语言的方法。在本文中，我将重点介绍使用 Python 编写函数代码。</p><p id="2955" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当人们想到使用 Python 进行函数式编程时，他们大多会想到三个函数:<code class="fe lb lc ld le b">map</code> <code class="fe lb lc ld le b">filter</code> <code class="fe lb lc ld le b">reduce</code>。然而，有更多的功能在雷达下，您可以在各种用例中使用。这些函数不仅使您的代码更具功能性，还能让您以最有效的方式利用和操作数据结构。</p><p id="ad21" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Python 的<code class="fe lb lc ld le b">itertools</code>模块公开了许多函数，您可以使用这些函数以非常高效和高性能的方式迭代和操作数据结构，如列表和元组。</p><p id="61c1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是我将在本文中介绍的函数列表:</p><ul class=""><li id="f963" class="lf lg iq kf b kg kh kk kl ko lh ks li kw lj la lk ll lm ln bi translated">数数</li><li id="cf6c" class="lf lg iq kf b kg lo kk lp ko lq ks lr kw ls la lk ll lm ln bi translated">循环</li><li id="40fd" class="lf lg iq kf b kg lo kk lp ko lq ks lr kw ls la lk ll lm ln bi translated">链子</li><li id="95fa" class="lf lg iq kf b kg lo kk lp ko lq ks lr kw ls la lk ll lm ln bi translated">压缩</li></ul><p id="f85e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们从<code class="fe lb lc ld le b">count</code>开始吧。</p><h1 id="83ce" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">数数</h1><p id="67a2" class="pw-post-body-paragraph kd ke iq kf b kg mr ki kj kk ms km kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated"><code class="fe lb lc ld le b">count</code>返回一个可以循环的不定迭代器。它有两个可选参数:<code class="fe lb lc ld le b">start</code>和<code class="fe lb lc ld le b">step</code>。</p><p id="23ab" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">start</code>定义开始计数的数字，而<code class="fe lb lc ld le b">step</code>定义两个生成数字之间的增量。例如，<code class="fe lb lc ld le b">count(5,2)</code>将生成一个 in 迭代器，其中生成的数字将是:5、7、9、11、13、15 等等。</p><p id="0a6a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在处理数据密集型应用程序时，这个函数会很方便。假设您有一组连续的数据点，您想给它们一个自动递增的单调 ID。你可以这样做:</p><pre class="mw mx my mz gt na le nb nc aw nd bi"><span id="f7df" class="ne lu iq le b gy nf ng l nh ni">data_points = [(10, 20), (5, 7), (3, 4)]<br/>id_iterator = itertools.count(1,1)</span><span id="abc9" class="ne lu iq le b gy nj ng l nh ni">for point in data_points:<br/>	print(f'id: {next(id_iterator)}, payload: {point}')</span><span id="38bc" class="ne lu iq le b gy nj ng l nh ni"># Output:<br/># id: 1, payload: (10, 20)<br/># id: 2, payload: (5, 7)<br/># id: 3, payload: (3, 4)</span></pre><p id="a08b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如您所见，每个有效负载都有一个自动递增的 ID。你不需要知道你有多少个数据点。假设迭代器是无限的，你可以继续前进到下一个元素并将 ID 赋给下一个有效载荷。</p><p id="6535" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者，您可以使用迭代器进行循环。假设您想要无限循环所有偶数。</p><pre class="mw mx my mz gt na le nb nc aw nd bi"><span id="6c6f" class="ne lu iq le b gy nf ng l nh ni">even_number_generator = itertools.count(0,2)<br/>for even_number in even_number_generator:<br/>	time.sleep(2)<br/>	print(even_number)</span><span id="98df" class="ne lu iq le b gy nj ng l nh ni"># Output:<br/># 0, 2, 4, 6, 8, and so on</span></pre><p id="0c60" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以使用迭代器无限地遍历偶数的“列表”,这非常酷。只要你愿意，你可以退出这个循环。</p><h1 id="f56e" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">循环</h1><p id="4a16" class="pw-post-body-paragraph kd ke iq kf b kg mr ki kj kk ms km kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">接受一个 iterable，并返回一个迭代器，可以无限循环，每次当原来的 iterable 用完时，就从头开始。</p><p id="67f8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设您想将一组人平均分成两部分。</p><pre class="mw mx my mz gt na le nb nc aw nd bi"><span id="3a57" class="ne lu iq le b gy nf ng l nh ni">people = ["Ben", "Mike", "Jerry", "Amanda", "Jeremy"]<br/>sections = [1, 2]</span><span id="0f73" class="ne lu iq le b gy nj ng l nh ni">section_iterator = itertools.cycle(sections)</span><span id="c080" class="ne lu iq le b gy nj ng l nh ni">for person in people:<br/>	print(f'person: {person} , section: {next(section_iterator)}')</span><span id="d6f3" class="ne lu iq le b gy nj ng l nh ni"># Output:<br/># person: Ben , section: 1<br/># person: Mike , section: 2<br/># person: Jerry , section: 1<br/># person: Amanda , section: 2<br/># person: Jeremy , section: 1</span></pre><p id="b2b2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如您所见，当您完成将前两个人分配到第 1 和第 2 部分时，您正在循环并将下一个人再次分配到第 1 部分。</p><p id="0b90" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一个更复杂的例子是写入一个分片的数据库表。假设您有一个共享表，其中存放数据的碎片依赖于一个名为<code class="fe lb lc ld le b">partition</code>的字段，它可以是 1 或 2。您希望在两个分区之间平均分配写入。使用此功能，您可以轻松地在两个值之间循环，无需任何复杂的逻辑。</p><h1 id="7db1" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">链子</h1><p id="3273" class="pw-post-body-paragraph kd ke iq kf b kg mr ki kj kk ms km kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated"><code class="fe lb lc ld le b">chain</code>为您提供了一种高效的连续循环多个序列的方式。它接受您想要迭代的多个 iterables。下面是语法:</p><p id="4d64" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">chain(iterable_1, iterable_2, iterable_3)</code>(可变的迭代次数)</p><p id="249c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们考虑一个用例，您有三个不同的列表，并且您想要连续地迭代它们。这里有三个列表:</p><pre class="mw mx my mz gt na le nb nc aw nd bi"><span id="b74c" class="ne lu iq le b gy nf ng l nh ni">numbers_1 = [10, 20, 30, 40]<br/>numbers_2 = [50, 60, 70, 80]<br/>numbers_3 = [90, 100, 110, 120, 130]</span></pre><p id="9294" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">可以连续遍历它们的最基本的方法是使用三个循环:</p><pre class="mw mx my mz gt na le nb nc aw nd bi"><span id="368b" class="ne lu iq le b gy nf ng l nh ni">for num in numbers_1:<br/>	print(num)<br/>for num in numbers_2:<br/>	print(num)<br/>for num in numbers_3:<br/>	print(num)</span></pre><p id="fe58" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这段代码极其冗长，完全不符合 DRY 原则。</p><p id="8538" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是完成同样事情的另一种方式:</p><pre class="mw mx my mz gt na le nb nc aw nd bi"><span id="7ed9" class="ne lu iq le b gy nf ng l nh ni">combined = numbers_1 + numbers_2 + numbers_3 <br/>for num in combined:<br/>	print(num)</span></pre><p id="4952" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，这有很大的内存开销，因为你要从现有的列表中创建一个新的列表，这会使内存使用加倍。如果您的每个原始列表都是 30MB 的组合，那么您将创建另一个 30MB 的临时数据结构来进行迭代，这实际上使您的内存占用加倍。</p><p id="e837" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是使用<code class="fe lb lc ld le b">chain</code>的一个很好的用例</p><pre class="mw mx my mz gt na le nb nc aw nd bi"><span id="5e66" class="ne lu iq le b gy nf ng l nh ni">combined = itertools.chain(numbers_1, numbers_2, numbers_3)<br/>for num in combined:<br/>	print(num)</span></pre><p id="4f92" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用<code class="fe lb lc ld le b">chain</code>你可以让你的代码不那么冗长，并且以最有效的方式遍历这些列表。</p><p id="2e44" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当您处理非常大的数据结构，并且不希望复制它们只是为了连续迭代单独的数据结构时，这个函数非常方便。</p><h1 id="aff4" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">压缩</h1><p id="a3db" class="pw-post-body-paragraph kd ke iq kf b kg mr ki kj kk ms km kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated"><code class="fe lb lc ld le b">compress(data, selectors)</code></p><ul class=""><li id="6b83" class="lf lg iq kf b kg kh kk kl ko lh ks li kw lj la lk ll lm ln bi translated">包含主数据的主 iterable</li><li id="f1b3" class="lf lg iq kf b kg lo kk lp ko lq ks lr kw ls la lk ll lm ln bi translated"><code class="fe lb lc ld le b">selectors</code>是布尔的可迭代式。它定义了是否应该过滤掉<code class="fe lb lc ld le b">data</code> iterable 中相同位置(索引)的 and 元素。</li></ul><p id="b409" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在深入细节之前，让我们先看一个例子:</p><pre class="mw mx my mz gt na le nb nc aw nd bi"><span id="3d84" class="ne lu iq le b gy nf ng l nh ni">cities = ["Atlanta", "San Francisco", "Seattle", "Houston"]<br/>selectors = [True, True, False, False]</span><span id="800e" class="ne lu iq le b gy nj ng l nh ni">compressed_cities = itertools.compress(cities, selectors)<br/>for city in compressed_cities:<br/>	print(city)</span><span id="5bdc" class="ne lu iq le b gy nj ng l nh ni"># Output:<br/># Atlanta<br/># San Francisco</span></pre><p id="990d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">唯一保留的城市是那些在<code class="fe lb lc ld le b">selectors</code>列表中的相应索引中有<code class="fe lb lc ld le b">True</code>的城市。所以这个函数是根据您想要保留的元素来“压缩”列表，如在<code class="fe lb lc ld le b">selectors</code>列表中所定义的那样。</p><p id="5e84" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当数据或选择器列表用尽时，操作停止。</p><h1 id="2825" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">最后的想法</h1><p id="be06" class="pw-post-body-paragraph kd ke iq kf b kg mr ki kj kk ms km kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">这些是 Python 中一些最容易被忽略的函数，它们可以帮助您编写更多的函数代码，并帮助您更有效地处理数据结构。我认为如果你开始在你的用例中加入这些功能，你会受益匪浅。</p><p id="20e8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我知道人们用不同的方式学习，所以如果你更喜欢视觉学习，请随意查看我在 YouTube 上的视频，在这里你可以看到我如何使用这些功能。</p><p id="7618" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae kc" href="https://docs.python.org/3.7/library/itertools.html#itertool-functions" rel="noopener ugc nofollow" target="_blank">官方文件</a></p><p id="61d4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae kc" href="https://www.youtube.com/watch?v=Vf_ynFBhLLE&amp;t=864s" rel="noopener ugc nofollow" target="_blank"> YouTube 视频</a></p><p id="1cd7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可以通过我的个人网站<a class="ae kc" href="https://irtizahafiz.com" rel="noopener ugc nofollow" target="_blank">这里</a>联系我。</p></div></div>    
</body>
</html>