<html>
<head>
<title>Sorting Algorithm: Bubble vs Selection vs Insertion vs Merge, Which One Is The Best?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">排序算法:冒泡 vs 选择 vs 插入 vs 合并，哪个最好？</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/sorting-algorithm-bubble-selection-vs-insertion-vs-merge-which-one-is-the-best-c30ea1a58629?source=collection_archive---------5-----------------------#2022-12-17">https://blog.devgenius.io/sorting-algorithm-bubble-selection-vs-insertion-vs-merge-which-one-is-the-best-c30ea1a58629?source=collection_archive---------5-----------------------#2022-12-17</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="d93b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在本文中，我将通过比较每种排序算法来讨论排序算法。让我们开始吧！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e192bf5ea0af0ef9f840c08f3d67e54a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tPTHj3XXT41mMqsDELjtvw.png"/></div></div></figure><h1 id="e09c" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">冒泡排序</h1><p id="3f29" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">冒泡排序是比较索引 I 和 i+1 处的每个元素的排序算法之一。如果我们想对一个列表进行排序，这是我们首先会想到的算法。我们可以通过使用循环来实现冒泡排序。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lx"><img src="../Images/dccfbeeceafb85647be711e053d6160c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qit5e4i65APhFQel.gif"/></div></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk translated">冒泡排序动画</figcaption></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mc"><img src="../Images/ed03ae35bcf7d521809d1cbe395c49db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QoMyvMLUX74YUFx1"/></div></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk translated">冒泡排序实现</figcaption></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi md"><img src="../Images/656ef3ce9aa677d4a4754b047be78628.png" data-original-src="https://miro.medium.com/v2/resize:fit:508/0*OiZ_20YtKq4RiZgE"/></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk translated">输出</figcaption></figure><p id="9652" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">那么，冒泡排序的时间复杂度和空间复杂度是多少？下表解释了</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi me"><img src="../Images/3e1f9ad3d76bd3039901a93a8b8b4f24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qx2GeoHLu8Wkw-t26d8Flw.png"/></div></div></figure><p id="b347" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">冒泡排序的时间复杂度为 O(n ),这不是真正的高性能排序。原因是我们有一个嵌套循环来比较每个元素。因此，如果我们有 5 个元素，我们将有 25 个操作来排序一个列表。对于空间复杂性，冒泡排序的 O(1)非常有效，因为我们将结果存储在同一个数组中。</p><h1 id="81fa" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">选择排序</h1><p id="bd1f" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">选择排序是指我们找到/选择最低(如果是升序)或最高(如果是降序)的元素，它们的索引大于当前索引。然后我们交换元素。我们可以通过使用循环来实现选择排序。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/2955befdd7b4872b311df04a543010eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:798/0*KNmIgd5BO0JkIa6Q"/></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk translated">选择排序动画</figcaption></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mc"><img src="../Images/ce211cb883a174714a3a4746de62d450.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5YDWE6hmN7hPS4JJ"/></div></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk translated">选择排序实现</figcaption></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi md"><img src="../Images/656ef3ce9aa677d4a4754b047be78628.png" data-original-src="https://miro.medium.com/v2/resize:fit:508/0*OiZ_20YtKq4RiZgE"/></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk translated">输出</figcaption></figure><p id="a02e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">那么，选择排序的时间复杂度和空间复杂度是多少？下表解释了。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/fbc348e1c9c0ec627c8b9b119267fe5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1340/format:webp/1*xXom0qHgdRVogaJ8e4fMrQ.png"/></div></figure><p id="ab92" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">选择排序的时间复杂度与冒泡排序相同，因为我们比较每个元素。空间复杂度也是如此，因为我们将元素存储在同一个数组中。</p><h1 id="e51e" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">插入排序</h1><p id="8609" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">插入排序是指我们将元素插入到一个新数组中，并将它放在正确的位置。当数字非常确定地排序或者我们有小的数据集时，使用插入排序。我们可以通过使用循环来实现插入排序。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mh"><img src="../Images/81e71148a2152ae361e90b78c5f97b81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UqRlc1YP-CCybh_4.gif"/></div></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk translated">插入排序动画</figcaption></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mc"><img src="../Images/d948cfa70dd91ca5e954bdef1bb357d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_4VWdU6RAvbFI_jO"/></div></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk translated">插入排序实现</figcaption></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi md"><img src="../Images/656ef3ce9aa677d4a4754b047be78628.png" data-original-src="https://miro.medium.com/v2/resize:fit:508/0*OiZ_20YtKq4RiZgE"/></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk translated">输出</figcaption></figure><p id="1d23" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">插入排序的时间复杂度和空间复杂度是多少？下表解释了。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/ef3f84a0de8700e2b7806cd360d21832.png" data-original-src="https://miro.medium.com/v2/resize:fit:1332/format:webp/1*1BA_LTCSYnLq-9grmGIhhg.png"/></div></figure><p id="4363" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">选择排序的时间复杂度与冒泡排序相同，因为我们比较每个元素。空间复杂度是有条件的，如果我们把它存储在一个新的数组中，那么我们得到 O(n)，如果我们把它存储在同一个数组中，那么我们得到 O(1)。</p><h1 id="27c1" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">合并排序</h1><p id="295c" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">合并排序使用分而治之，就像在一棵树上，我们把数组分成更小的数组，并互相比较。我们可以通过使用递归来实现合并排序。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/c88e3e9ed273507523a9ea767f59b385.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/0*ydN023U4GOKGTjhk"/></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk translated">合并排序动画</figcaption></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mc"><img src="../Images/0207dcb4432ace69fabef3299e12ed97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kY4ET9ATfxp9JHRh"/></div></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk translated">合并排序实现</figcaption></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi md"><img src="../Images/656ef3ce9aa677d4a4754b047be78628.png" data-original-src="https://miro.medium.com/v2/resize:fit:508/0*OiZ_20YtKq4RiZgE"/></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk translated">输出</figcaption></figure><p id="92bb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">合并排序的时间复杂度和空间复杂度是多少？下表解释了。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/bed14b9044bbc5b6895691897331e9fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1326/format:webp/1*phQWx1FykYslNxLLqL2GZA.png"/></div></figure><p id="ea7f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">合并排序的时间复杂度是 O(n log(n))，比上面的其他排序算法更有效，因此如果我们想要实现一个排序算法，通常使用它。但是这里关键的一点是合并排序的空间复杂度是 O(n ),因为我们每次比较都要创建一个新的数组。此外，如果我们使用递归，那么我们将有很多函数调用，最坏的情况是我们将有一个堆栈溢出。</p><h1 id="84e3" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">结论</h1><p id="20af" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">因此，我们已经知道如何实现不同的排序算法及其性能。下表是各种排序算法之间的比较。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ml"><img src="../Images/a573f3618a8c2b747a6749ca0c2e80ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5RH95gnr5AXjrrjN8UtORg.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mm"><img src="../Images/7d5733c9cfa9991cd0306399718ddd36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5-gUQAe8vCt7FWVT"/></div></div></figure><p id="f919" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">通过查看大的 O cheatsheet，合并排序是我们拥有的最有效的排序算法，因为时间复杂度是 O(n log(n))，空间复杂度是 O(n)。还有更有效的排序算法，你可以在这里看到<a class="ae mn" href="https://www.toptal.com/developers/sorting-algorithms" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="dd95" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">选择使用哪种算法很重要。想象一下，如果我们在谷歌工作，我们必须实现一个排序算法来对网站进行排序。如果我们选择了错误的算法，那么公司可能会损失大量资金和资源。</p></div></div>    
</body>
</html>