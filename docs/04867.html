<html>
<head>
<title>Chained constructors in Java can help cut down on repetition</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java中的链式构造函数有助于减少重复</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/chained-constructors-in-java-can-help-cut-down-on-repetition-14669bb38b94?source=collection_archive---------12-----------------------#2021-05-13">https://blog.devgenius.io/chained-constructors-in-java-can-help-cut-down-on-repetition-14669bb38b94?source=collection_archive---------12-----------------------#2021-05-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/c54ae22c3d0cf52ebff2c747763a550a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VKOqlndrlp1eRxX5"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">劳拉·奥克尔在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="b578" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不要重复自己(干)是一个值得遵守的原则，在情理之中。Java以冗长著称，Java中的某些重复似乎是不可避免的。</p><p id="b506" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有时会出现的一种重复是构造函数验证冗余，在这种情况下，一个类中的几个构造函数会检查它们的参数是否具有相同的特征。</p><p id="6606" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当需要对类进行更改时，这种重复会导致严重的问题，程序员没有注意到某些重复的行没有一起更改。</p><p id="39c4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">构造函数链接至少有时可以帮助您避免这种重复的构造函数参数验证。这样，如果需要修改构造函数参数验证，只需要编辑一个构造函数。</p><p id="c3d9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">检查空参数是一种常见的构造函数验证。或者至少应该更频繁，因为这样可以帮助我们避免那些可怕的空指针异常。</p><p id="59ea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果一个不应该为null的构造函数参数<em class="lb">为</em> null，构造函数应该抛出一个<code class="fe lc ld le lf b">NullPointerException</code>。或者构造函数应该抛出<code class="fe lc ld le lf b">IllegalArgumentException</code>，这对你来说可能更有意义。</p><p id="668d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里重要的一点是:越早发现不正确的空值越好，并且越容易识别和解决问题。</p><p id="ea23" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">作为一个玩具的例子，考虑一个类，它有一个到三个相同类型的参数，这些参数填充了三个常量字段。</p><figure class="lg lh li lj gt jr"><div class="bz fp l di"><div class="lk ll l"/></div></figure><p id="eccc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当然，在实际项目中，我们会使用<code class="fe lc ld le lf b">Object</code>的特定子类作为参数和字段。这只是为了保持例子的简单。</p><p id="74c1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一个或两个常量字段可以为空，但第一个字段决不能为空。如果第二个字段为空，那么第三个字段也必须为空。这样，我们可以确保非空值不会隐藏在第三个字段中。</p><p id="a2c2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最好有只需要一两个参数的替代构造函数，这样调用者就不必为第二个或第三个参数填充空值。</p><figure class="lg lh li lj gt jr"><div class="bz fp l di"><div class="lk ll l"/></div></figure><p id="105a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是这并不能强制执行<code class="fe lc ld le lf b">a</code>不能为空的规则，也不能强制执行<code class="fe lc ld le lf b">b</code>只能在<code class="fe lc ld le lf b">c</code>也为空时为空的规则。</p><p id="5901" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">调用者可以向任何一个构造函数传递一个空值<code class="fe lc ld le lf b">a</code>，向两个或三个参数的构造函数传递一个空值<code class="fe lc ld le lf b">b</code>(但是因为两个参数的构造函数为<code class="fe lc ld le lf b">c</code>填充了一个空值，所以空值<code class="fe lc ld le lf b">b</code>只与三个参数的构造函数有关)。</p><p id="d977" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们实际编写任何参数验证之前，我们应该编写测试。这些测试将会相当重复。</p><p id="00e0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">干燥不适用于测试。最好覆盖所有的基础，再加上一些不必要的测试，而不是发现一些你认为不需要测试的东西变成了一个大问题。</p><p id="5bce" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你有JUnit 5，使用<code class="fe lc ld le lf b">assertThrows()</code>。否则使用Try-Catch，因为我们希望任何出现的空指针异常都有有用的非空消息(例如，“不允许参数A为空”)。</p><p id="604d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">用JUnit 4预期的异常属性测试异常消息相当麻烦，所以最好使用在JUnit 3中运行良好的Try-Catch方法。但这是假设你没有JUnit 5。</p><p id="90bd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于测试类，复制和粘贴测试是没问题的，只要确保根据需要测试的内容调整每个测试即可。</p><figure class="lg lh li lj gt jr"><div class="bz fp l di"><div class="lk ll l"/></div></figure><p id="3a44" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你更喜欢<code class="fe lc ld le lf b">IllegalArgumentException</code>而不是<code class="fe lc ld le lf b">NullPointerException</code>，那么相应地编写测试。</p><p id="8f7e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">运行测试，他们应该都失败了。</p><p id="c826" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让这些测试通过的最简单的方法是向三个构造函数中的每一个添加验证。</p><figure class="lg lh li lj gt jr"><div class="bz fp l di"><div class="lk ll l"/></div></figure><p id="c172" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这不是最小的，因为这不是通过测试的最简单的工作，但是这是通过所有测试的最明显的方法。验证所有测试现在都通过了。</p><p id="08e3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们为自己通过了所有的考试而感到自豪。但是我们不要忘记测试驱动开发周期的重构阶段。</p><p id="e447" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里只有一件事需要重构:重复。每个构造函数都在检查<code class="fe lc ld le lf b">a</code>是否为空，并抛出一个空指针异常，异常消息略有不同，如果<code class="fe lc ld le lf b">a</code>不为空，所有三个构造函数都在设置<code class="fe lc ld le lf b">fieldA = a</code>。</p><p id="4e60" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您的集成开发环境(IDE)可能无法捕捉所有的重复，因为它不是精确的重复。但这绝对违背了干燥原则。</p><p id="f930" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过将1个和2个参数的构造函数链接到3个参数的构造函数来重构重复。</p><figure class="lg lh li lj gt jr"><div class="bz fp l di"><div class="lk ll l"/></div></figure><p id="df33" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，单参数构造函数为<code class="fe lc ld le lf b">b</code>和<code class="fe lc ld le lf b">c</code>填充空值，并将其传递给三参数构造函数。同样，双参数构造函数为<code class="fe lc ld le lf b">c</code>填充null，并将其传递给三参数构造函数。</p><p id="a435" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所有验证都发生在3参数构造函数中。这样，异常消息更加一致。然而，更重要的是，如果我们需要对验证过程进行更改，我们可以在一个地方进行这些更改。</p><p id="564a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意，这不是一个完美的链接序列，因为单参数构造函数直接将内容传递给三参数构造函数，绕过了双参数构造函数。</p><p id="e235" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">也可以反方向链接，这样1参数构造函数是主构造函数，2参数和3参数构造函数直接或间接地链接到1参数构造函数。</p><p id="8f0d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">完美连锁是有时间和地点的。如果有必要的话，测试驱动的开发过程最终会将我们引向这样的安排，以便通过测试，或者在重构期间。</p><p id="879b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设这三个参数是GPS坐标。我们要求，如果提供两个非空参数，它们必须用于陆地上两个不同的点，如果提供三个非空参数，它们必须用于陆地上三个不同的点。</p><p id="54c2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">嗯，我想在这种情况下，我还是不愿意做一个完美的链接。这取决于项目的环境和要求。</p><p id="aeb7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在Scala中，不太需要构造函数链接，因为可选的参数语法更容易为调用者提供省略明显参数的选项。</p><p id="4ec6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">大多数Scala程序员倾向于在主构造函数中提供可选参数(Scala类中总是有一个主构造函数)。Scala中提供了辅助构造函数语法，包括链接构造函数的能力。但是也许我应该写一篇单独的文章。</p></div></div>    
</body>
</html>