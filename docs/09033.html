<html>
<head>
<title>Getting Start With Unit Test for an HTTP REST Application with Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Python 对 HTTP REST 应用程序进行单元测试</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/getting-start-unit-test-for-an-http-rest-application-with-python-c57810cc4e56?source=collection_archive---------16-----------------------#2022-07-25">https://blog.devgenius.io/getting-start-unit-test-for-an-http-rest-application-with-python-c57810cc4e56?source=collection_archive---------16-----------------------#2022-07-25</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><h1 id="0e59" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">介绍</h1><p id="9640" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">最近更新时间:2022 年 7 月</p><p id="d356" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">关于<a class="ae ll" href="https://developers.refinitiv.com/" rel="noopener ugc nofollow" target="_blank">路孚特开发者社区</a>的原文可从<a class="ae ll" href="https://developers.refinitiv.com/en/article-catalog/article/getting-start-unit-test-for-an-http-rest-application-with-python" rel="noopener ugc nofollow" target="_blank">这里</a>获得。</p><p id="d703" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">如今，应用程序更大、更复杂。为添加更多功能或修复错误而对源代码进行的一些更改可能会导致应用程序出现意外行为。开发人员不能再等待 QA 团队的测试结果了。他们需要定期进行单元测试，作为开发过程中不可或缺的一部分。</p><p id="da9a" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">单元测试是一种软件测试方法，帮助开发人员验证是否有任何更改破坏了代码。单元测试显著提高了代码质量，节省了在开发生命周期的早期发现软件缺陷的时间，并提高了部署速度。单元测试目前是现代敏捷软件开发实践的主要过程，如 CI/CD(持续集成/持续交付)、TDD(测试驱动开发)等。</p><p id="84f9" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">现代应用程序还需要连接到其他服务，如 API、数据库、数据存储等。单元测试也需要覆盖那些模块。这个示例项目展示了如何为执行 HTTP REST 操作的<a class="ae ll" href="https://www.python.org/" rel="noopener ugc nofollow" target="_blank"> Python </a>应用程序运行单元测试用例，HTTP REST 操作是当今应用程序功能中最基本的任务。通过单元测试，开发人员可以验证他们的代码是否可以在任何代码更新中通过 HTTP REST API 连接和使用内容。</p><p id="66cf" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">演示应用程序使用事实上的<a class="ae ll" href="https://requests.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank">请求</a>库连接到<a class="ae ll" href="https://developers.refinitiv.com/en/api-catalog/refinitiv-data-platform/refinitiv-data-platform-apis" rel="noopener ugc nofollow" target="_blank">路孚特数据平台(RDP)API</a>作为示例 HTTP REST APIs，并使用 Python 内置的<a class="ae ll" href="https://docs.python.org/3.9/library/unittest.html" rel="noopener ugc nofollow" target="_blank"> unittest </a>作为测试框架。</p><p id="c120" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated"><strong class="kk io">注意</strong>:本文没有涵盖 HTTP 操作和所有 RDP API 服务的所有测试用例。它旨在让读者了解如何对仅使用 Python 进行 HTTP 连接的应用程序进行单元测试。</p><h1 id="92e6" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">单元测试概述</h1><p id="113c" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated"><a class="ae ll" href="https://en.wikipedia.org/wiki/Unit_testing" rel="noopener ugc nofollow" target="_blank">单元测试</a>是最小的测试，主要检查应用程序的单个部分是否正确运行。它将应用程序分解成最小的、隔离的、可测试的组件，称为<em class="lm">单元</em>，然后单独测试它们。该单元主要是应用程序源代码中的函数或方法调用或过程。开发人员和 QA 可以通过向单元发送任何数据来测试每个单元，并查看它是否按预期运行。</p><p id="88e4" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">单元测试有助于开发人员隔离应用程序中的问题，这比将整个系统作为一个整体进行测试更容易、更快。这是集成测试之前开发过程中完成的第一级测试。这主要是由开发人员自动或手动完成的，以验证他们的代码。</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi ln"><img src="../Images/04963583cd0cd7205ca18bedffb7e17c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NbyGrItbSontd2GRogZIbQ.png"/></div></div></figure><p id="f185" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">您可以从以下资源中找到有关单元测试概念的更多详细信息:</p><ul class=""><li id="7b67" class="lz ma in kk b kl lg kp lh kt mb kx mc lb md lf me mf mg mh bi translated"><a class="ae ll" href="https://docs.python-guide.org/writing/tests/" rel="noopener ugc nofollow" target="_blank"> Python 指南:测试代码</a>文章。</li><li id="5d2a" class="lz ma in kk b kl mi kp mj kt mk kx ml lb mm lf me mf mg mh bi translated"><a class="ae ll" href="https://softwareengineering.stackexchange.com/questions/89064/how-and-when-to-use-unit-testing-properly" rel="noopener ugc nofollow" target="_blank">如何以及何时正确使用单元测试</a>帖子。</li></ul><h1 id="fe4b" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">Python 单元测试框架简介</h1><p id="9687" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated"><a class="ae ll" href="https://docs.python.org/3.9/library/unittest.html" rel="noopener ugc nofollow" target="_blank">单元测试</a>是一个 Python 构建的单元测试框架。它支持<strong class="kk io">测试用例</strong>(测试的单个单元)和<strong class="kk io">测试运行器</strong>(为运行测试用例而设计的特殊应用程序，并提供输出结果)。</p><p id="acad" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">单元测试框架有以下要求:</p><ol class=""><li id="d9d4" class="lz ma in kk b kl lg kp lh kt mb kx mc lb md lf mn mf mg mh bi translated">测试用例必须是该类的方法。</li><li id="3ad9" class="lz ma in kk b kl mi kp mj kt mk kx ml lb mm lf mn mf mg mh bi translated">该类必须定义为<code class="fe mo mp mq mr b">unittest.TestCase</code>类的子类。</li><li id="1dea" class="lz ma in kk b kl mi kp mj kt mk kx ml lb mm lf mn mf mg mh bi translated">在<code class="fe mo mp mq mr b">unittest.TestCase</code>类中使用一系列特殊的断言方法，而不是内置的断言语句。</li><li id="31ee" class="lz ma in kk b kl mi kp mj kt mk kx ml lb mm lf mn mf mg mh bi translated">方法名必须以字母<code class="fe mo mp mq mr b">test</code>开头，作为测试运行程序的命名约定。</li><li id="5bf7" class="lz ma in kk b kl mi kp mj kt mk kx ml lb mm lf mn mf mg mh bi translated">测试用例文件名必须以<code class="fe mo mp mq mr b">test_</code>开头，作为测试运行程序的命名约定。</li></ol><p id="b0e9" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">来自<a class="ae ll" href="https://docs.python.org/3.9/library/unittest.html" rel="noopener ugc nofollow" target="_blank"> unittest 官方页面</a>的示例:</p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="ab6a" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">要运行测试，只需运行以下命令:</p><pre class="lo lp lq lr gt mu mr mv mw aw mx bi"><span id="4e06" class="my jl in mr b gy mz na l nb nc">python -m unittest test_sample</span></pre><p id="c5ce" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">结果:</p><pre class="lo lp lq lr gt mu mr mv mw aw mx bi"><span id="0583" class="my jl in mr b gy mz na l nb nc">..<br/>----------------------------------------------------------------------<br/>Ran 2 tests in 0.000s</span><span id="74ed" class="my jl in mr b gy nd na l nb nc">OK</span></pre><p id="f9d0" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">您可以从以下资源中找到有关 unittest 框架的更多详细信息:</p><ul class=""><li id="59d4" class="lz ma in kk b kl lg kp lh kt mb kx mc lb md lf me mf mg mh bi translated">unittest 标准库文档。</li><li id="1fc8" class="lz ma in kk b kl mi kp mj kt mk kx ml lb mm lf me mf mg mh bi translated"><a class="ae ll" href="https://realpython.com/python-testing/" rel="noopener ugc nofollow" target="_blank">Python 测试入门</a>。</li></ul><h1 id="6265" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">什么是路孚特数据平台(RDP)API？</h1><p id="f45f" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated"><a class="ae ll" href="https://developers.refinitiv.com/en/api-catalog/refinitiv-data-platform/refinitiv-data-platform-apis" rel="noopener ugc nofollow" target="_blank">路孚特数据平台(RDP)API</a>通过易于使用的基于网络的 API 为开发者提供各种路孚特数据和内容。</p><p id="1170" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">RDP API 使开发人员能够无缝、全面地访问所有路孚特内容，如环境、社会和治理(ESG)、新闻、研究等，并通过单一界面与他们的内容混合、丰富、集成和分发数据，交付到他们需要的任何地方。RDP API 交付机制如下:</p><ul class=""><li id="f552" class="lz ma in kk b kl lg kp lh kt mb kx mc lb md lf me mf mg mh bi translated">请求—响应:RESTful web 服务(HTTP GET、POST、PUT 或 DELETE)</li><li id="1fe8" class="lz ma in kk b kl mi kp mj kt mk kx ml lb mm lf me mf mg mh bi translated">警报:传递是一种接收订阅的异步更新(警报)的机制。</li><li id="a29e" class="lz ma in kk b kl mi kp mj kt mk kx ml lb mm lf me mf mg mh bi translated">批量:交付大量有效负载，如整个场馆的日终定价数据。</li><li id="f62c" class="lz ma in kk b kl mi kp mj kt mk kx ml lb mm lf me mf mg mh bi translated">流式传输:实时传递消息。</li></ul><p id="907d" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">这个示例项目只关注请求-响应:RESTful web 服务交付方法。</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi ne"><img src="../Images/09cf443368785969a10af02ec7f658d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YgdBEX9sRbhZAm1UIpkEWA.png"/></div></div></figure><p id="ed3a" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">有关路孚特数据平台的更多详细信息，请参见以下 API 资源:</p><ul class=""><li id="2cac" class="lz ma in kk b kl lg kp lh kt mb kx mc lb md lf me mf mg mh bi translated"><a class="ae ll" href="https://developers.refinitiv.com/en/api-catalog/refinitiv-data-platform/refinitiv-data-platform-apis/quick-start" rel="noopener ugc nofollow" target="_blank">快速启动</a>页面。</li><li id="27aa" class="lz ma in kk b kl mi kp mj kt mk kx ml lb mm lf me mf mg mh bi translated"><a class="ae ll" href="https://developers.refinitiv.com/en/api-catalog/refinitiv-data-platform/refinitiv-data-platform-apis/tutorials" rel="noopener ugc nofollow" target="_blank">教程</a>页面。</li></ul><h1 id="2e26" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">RDP API 应用工作流</h1><p id="8e9b" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">路孚特数据平台授权检查基于 OAuth 2.0 规范。应用程序工作流的第一步是从 RDP 身份验证服务获取令牌，这将允许访问受保护的资源，即数据休息 API。</p><p id="83c3" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">API 需要以下访问凭据信息:</p><ul class=""><li id="5b9e" class="lz ma in kk b kl lg kp lh kt mb kx mc lb md lf me mf mg mh bi translated">用户名:用户名。</li><li id="1204" class="lz ma in kk b kl mi kp mj kt mk kx ml lb mm lf me mf mg mh bi translated">密码:与用户名关联的密码。</li><li id="3c27" class="lz ma in kk b kl mi kp mj kt mk kx ml lb mm lf me mf mg mh bi translated">客户端 ID:这也称为<code class="fe mo mp mq mr b">AppKey</code>，它是使用 App 密钥生成器生成的。这个唯一标识符是为用户或应用程序定义的，并且被认为是机密的(不在用户之间共享)。client_id 参数可以在请求正文中传递，也可以作为编码为 base64 的“授权”请求头传递。</li></ul><p id="22fc" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">一旦身份验证成功，该函数将获得 RDP 身份验证服务响应消息，并将以下 RDP 令牌信息保存在变量中。</p><ul class=""><li id="ac85" class="lz ma in kk b kl lg kp lh kt mb kx mc lb md lf me mf mg mh bi translated"><strong class="kk io"> access_token </strong>:用于调用 REST 数据 API 调用的令牌，如上所述。应用程序必须保留此凭据，以备 RDP API 进一步请求。</li><li id="2202" class="lz ma in kk b kl mi kp mj kt mk kx ml lb mm lf me mf mg mh bi translated"><strong class="kk io"> refresh_token </strong>:刷新令牌，用于在到期前获取更新后的接入令牌。应用程序必须保留此凭据以进行访问令牌续订。</li><li id="69b2" class="lz ma in kk b kl mi kp mj kt mk kx ml lb mm lf me mf mg mh bi translated"><strong class="kk io"> expires_in </strong>:访问令牌有效时间，以秒为单位。</li></ul><p id="0839" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">接下来，在应用程序从 RDP 身份验证服务收到访问令牌(和授权令牌)后，所有后续的 REST API 调用都将使用这个令牌来获取数据。请在以下资源中找到有关 RDP API 工作流程的更多详细信息:</p><ul class=""><li id="6f39" class="lz ma in kk b kl lg kp lh kt mb kx mc lb md lf me mf mg mh bi translated"><a class="ae ll" href="https://developers.refinitiv.com/en/api-catalog/refinitiv-data-platform/refinitiv-data-platform-apis/tutorials#introduction-to-the-request-response-api" rel="noopener ugc nofollow" target="_blank">RDP API:请求-响应 API 简介</a>页面。</li><li id="3b68" class="lz ma in kk b kl mi kp mj kt mk kx ml lb mm lf me mf mg mh bi translated"><a class="ae ll" href="https://developers.refinitiv.com/en/api-catalog/refinitiv-data-platform/refinitiv-data-platform-apis/tutorials#authorization-all-about-tokens" rel="noopener ugc nofollow" target="_blank">RDP API:授权—关于令牌的所有信息</a>页面。</li></ul><h1 id="a5a5" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">项目结构</h1><p id="e3b5" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">这个示例项目是一个 Python 控制台应用程序，它登录到 RDP 平台，然后分别从 RDP 的环境、社会和治理(ESG)服务和 Search Explore 服务请求公司的 ESG 数据和元信息。项目结构如下:</p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="ms mt l"/></div></figure><ul class=""><li id="5ce9" class="lz ma in kk b kl lg kp lh kt mb kx mc lb md lf me mf mg mh bi translated">app.py:主控制台应用程序。</li><li id="8b54" class="lz ma in kk b kl mi kp mj kt mk kx ml lb mm lf me mf mg mh bi translated">RDP _ controller/RDP _ http _ controller . py:主 HTTP 操作类。这是我们单元测试的聚焦类。</li><li id="9ade" class="lz ma in kk b kl mi kp mj kt mk kx ml lb mm lf me mf mg mh bi translated">tests/test _ rdp_http_controller.py:测试所有 RDP _ http _ controller . py 类的方法的主测试用例类。这是我们在这个项目中的焦点测试套件。</li><li id="29c1" class="lz ma in kk b kl mi kp mj kt mk kx ml lb mm lf me mf mg mh bi translated">tests/test_app.py:测试一些 app.py 方法的测试套件类。</li><li id="c006" class="lz ma in kk b kl mi kp mj kt mk kx ml lb mm lf me mf mg mh bi translated">测试/夹具:测试套件夹具/资源文件。</li></ul><h1 id="8ac0" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">单元测试 RDP API 认证</h1><p id="6950" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">让我们从使用 RDP 服务操作 HTTP 请求-响应消息的类开始。<code class="fe mo mp mq mr b">rdp_controller/rdp_http_controller.py</code>类使用请求库通过 RDP HTTP REST API 发送和接收数据。RDP 身份验证的代码如下所示。</p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="0269" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">上面的<code class="fe mo mp mq mr b">rdp_authentication()</code>方法只是创建请求消息有效负载，并将其作为 HTTP Post 请求发送给 RDP 验证服务。返回值可能如下所示</p><ul class=""><li id="255d" class="lz ma in kk b kl lg kp lh kt mb kx mc lb md lf me mf mg mh bi translated">如果身份验证成功，则向调用者返回 access_token、refresh_token 和 expires_in 信息。</li><li id="48ec" class="lz ma in kk b kl mi kp mj kt mk kx ml lb mm lf me mf mg mh bi translated">如果 URL 或凭据参数为空或没有，则向调用方引发 TypeError 异常。</li><li id="7103" class="lz ma in kk b kl mi kp mj kt mk kx ml lb mm lf me mf mg mh bi translated">如果身份验证失败，向调用者发出请求的 HTTPError 异常，并提供 HTTP 状态响应信息。</li></ul><p id="263f" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">让我们把<code class="fe mo mp mq mr b">rdp_authentication()</code>方法留在那里，继续测试用例。基本的测试用例场景是检查<code class="fe mo mp mq mr b">rdp_authentication()</code>方法是否可以处理有效的 RDP 登录和空参数场景。</p><p id="9784" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">测试类是<code class="fe mo mp mq mr b">tests\test_rdp_http_controller.py</code>文件(请注意一个<em class="lm">测试</em>文件夹)。它从一个<code class="fe mo mp mq mr b">.env.test</code>环境变量文件中加载测试配置，比如 RDP API URL。</p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="c177" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated"><code class="fe mo mp mq mr b">setUpClass()</code>是一个类方法，在所有测试之前，整个类只调用一次。该函数对于设置<em class="lm"> fixture </em>很有用，fixture 可以是样本数据、前提条件状态、上下文或运行测试所需的资源。我们初始化 RDPHTTPController 对象(作为<code class="fe mo mp mq mr b">app</code>类变量)和 RDP 基本 URL 字符串(作为<code class="fe mo mp mq mr b">base_URL</code>类变量)作为我们在这里的夹具。</p><p id="9706" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">注意:<code class="fe mo mp mq mr b">setUpClass()</code>方法的对应方法是<code class="fe mo mp mq mr b">tearDownClass()</code>，在类中的所有测试运行后调用。</p><p id="3841" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated"><code class="fe mo mp mq mr b">test_login_rdp_success()</code>是成功的 RDP 认证登录场景的测试用例。它只是将 RDP 身份验证服务 URL 和 RDP 凭证发送给<code class="fe mo mp mq mr b">rdp_authentication()</code>方法，并检查响应令牌信息。请注意，单元测试只关注 rdp_authentication()是否返回非空/零令牌信息。令牌内容验证将处于系统测试(或稍后)阶段。</p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="b5a1" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">请在<a class="ae ll" href="https://docs.python.org/3.9/library/unittest.html" rel="noopener ugc nofollow" target="_blank">单元测试框架</a>页面上查看关于支持的断言方法的更多详细信息。</p><p id="8d4b" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated"><code class="fe mo mp mq mr b">test_login_rdp_none_empty_params()</code>是一个测试用例，它检查<code class="fe mo mp mq mr b">rdp_authentication()</code>方法是否像预期的那样处理空参数或无参数(抛出 TypeError 异常，不向调用者返回令牌信息)。</p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="f4f4" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">测试运行结果的示例如下所示。</p><pre class="lo lp lq lr gt mu mr mv mw aw mx bi"><span id="cc4f" class="my jl in mr b gy mz na l nb nc">$&gt;tests&gt; python -m unittest test_rdp_http_controller<br/>.Authentication success<br/>.<br/>----------------------------------------------------------------------</span><span id="ca17" class="my jl in mr b gy nd na l nb nc">Ran 2 tests in 0.014s</span><span id="ede2" class="my jl in mr b gy nd na l nb nc">OK</span></pre><p id="f343" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">如果您在一个<code class="fe mo mp mq mr b">.env.test</code>文件中输入了无效的 RDP 凭证，一个测试运行程序会显示以下测试失败的结果(不要担心，我将在后面介绍失败的测试案例)。</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi nf"><img src="../Images/b7a23e553786ad6433ebd5c7979938a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*41k3Sn2tVs5_FIfxf7z5nA.png"/></div></div></figure><p id="8b6c" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">然而，上面的测试套件在每次运行时都会向 RDP API 发出 HTTP 请求。当开发人员更新了代码或配置后，每次运行测试套件时，向外部服务发送大量请求并不是一个好主意。</p><p id="2afd" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">单元测试用例应该能够独立运行，而不依赖于外部服务或 API。外部依赖给单元测试用例增加了不可控因素(如网络连接、数据可靠性等)。这些组件到组件的测试应该在集成测试阶段完成。</p><p id="f382" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">那么，我们如何在不向实际服务器发送任何 HTTP 请求消息的情况下对 HTTP 请求方法调用进行单元测试呢？幸运的是，开发人员可以用模拟对象来模拟 HTTP 请求和响应消息。</p><h1 id="6baa" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">用响应模仿 Python HTTP API 调用</h1><p id="dae5" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">mock 是一个伪造的对象，它被构造成在测试环境中看起来和行为上都像真实的数据。我们可以用一个模仿对象来模拟真实数据的各种场景，然后使用一个模仿库来欺骗系统，让它认为这个模仿是真实的。</p><p id="15b2" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">模仿的目的是隔离并关注被测试的代码，而不是外部依赖的行为或状态。通过模仿外部依赖，开发人员可以经常运行测试，而不会受到那些依赖的任何意外变化或不规则性的影响。如果开发人员必须测试获取大量数据的 HTTP 请求，模拟还可以帮助他们节省时间和计算资源。</p><p id="414a" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">这个示例项目使用了专门为模仿请求库而构建的<a class="ae ll" href="https://github.com/getsentry/responses" rel="noopener ugc nofollow" target="_blank"> Responses </a>库。</p><h1 id="28b5" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">向测试用例添加一个模拟对象</h1><p id="6f79" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">因此，我将从一个模拟对象开始，测试一个成功的 RDP 登录案例。首先，在<em class="lm"> tests/fixtures </em>文件夹中创建一个<em class="lm">rdp _ test _ auth _ fixture . JSON</em>fixture 文件，其中包含 RDP 认证成功响应消息的虚拟内容。</p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="9d9d" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">接下来，将<code class="fe mo mp mq mr b">setUpClass()</code>方法中的这个<em class="lm">RDP _ test _ auth _ fixture . JSON</em>文件加载到一个<code class="fe mo mp mq mr b">mock_valid_auth_json</code>类变量中。其他测试用例可以将这个模拟 json 对象用于虚拟访问令牌信息。</p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="9850" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">响应库允许开发人员向请求库注册模拟响应，并用<code class="fe mo mp mq mr b">responses.activate</code>装饰器覆盖测试方法。开发人员可以通过一个<code class="fe mo mp mq mr b">responses.add()</code>方法指定请求的端点 URL、HTTP 方法、状态响应、响应消息等。</p><p id="ac84" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">示例代码:</p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="3c61" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">上面的代码用<a class="ae ll" href="https://api.refinitiv.com/auth/oauth2/v1/token" rel="noopener ugc nofollow" target="_blank"><em class="lm">https://api.refinitiv.com/auth/oauth2/v1/token</em></a>URL 和 HTTP <em class="lm"> POST </em>方法设置了一个响应模拟对象。然后，请求库返回一个带有 HTTP 状态 200 和内容类型<em class="lm">应用程序/json </em>的<code class="fe mo mp mq mr b">mock_valid_auth_json</code> JSON 消息给所有 HTTP <em class="lm"> POST </em>请求消息到<a class="ae ll" href="https://api.refinitiv.com/auth/oauth2/v1/token" rel="noopener ugc nofollow" target="_blank"><em class="lm"/></a>URL 的应用程序，而不需要机器和实际 RDP 端点之间的任何网络操作。</p><h1 id="83e0" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">测试无效的 RDP 身份验证请求-响应</h1><p id="3c0a" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">这个模拟对象对于测试错误情况也很有用，比如无效登录。<code class="fe mo mp mq mr b">test_login_rdp_invalid()</code>方法是 RDP 认证登录失败场景的测试用例。我们为<a class="ae ll" href="https://api.refinitiv.com/auth/oauth2/v1/token" rel="noopener ugc nofollow" target="_blank"><em class="lm">https://api.refinitiv.com/auth/oauth2/v1/token</em></a>URL 和 HTTP <em class="lm"> POST </em>方法设置了一个响应模拟对象，带有预期的错误响应消息和状态(401 -未授权)。</p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="f192" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">一旦调用了<code class="fe mo mp mq mr b">rdp_authentication()</code>方法，测试用例将验证该方法是否引发了带有预期错误消息和状态的<code class="fe mo mp mq mr b">requests.exceptions.HTTPError</code>异常。测试用例还做出断言来检查方法是否没有向调用者返回令牌信息。</p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="2e49" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">有了 mocking，测试用例永远不需要向 RDP API 发送实际的请求消息，所以我们也可以为其他 RDP 服务测试更多的场景。</p><h1 id="8281" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">RDP API 数据请求的单元测试</h1><p id="9430" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">这让我们需要 RDP 原料药的数据。所有后续的 REST API 调用都通过如下所示的<em class="lm">授权</em> HTTP 请求消息头使用访问令牌来获取数据。</p><ul class=""><li id="f7c0" class="lz ma in kk b kl lg kp lh kt mb kx mc lb md lf me mf mg mh bi translated">表头:授权= <code class="fe mo mp mq mr b">Bearer &lt;RDP Access Token&gt;</code></li></ul><p id="729f" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">请注意<code class="fe mo mp mq mr b">Bearer</code>和<code class="fe mo mp mq mr b">RDP Access Token</code>值之间的间隔。</p><p id="ebd3" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">然后，应用程序根据感兴趣的服务创建 JSON 消息格式或 URL 查询参数的请求消息，并将其作为 HTTP 请求消息发送给服务端点。开发人员可以从路孚特数据平台的<a class="ae ll" href="https://api.refinitiv.com/" rel="noopener ugc nofollow" target="_blank"> API 游乐场页面</a>获得 RDP API 服务端点、HTTP 操作和参数——这是一个交互式文档网站，开发人员一旦拥有有效的路孚特数据平台帐户就可以访问。</p><p id="9814" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">示例控制台应用程序使用来自以下 RDP 服务的内容:</p><ul class=""><li id="b4a4" class="lz ma in kk b kl lg kp lh kt mb kx mc lb md lf me mf mg mh bi translated">ESG 服务<code class="fe mo mp mq mr b">/data/environmental-social-governance/&lt;version&gt;/views/scores-full</code>为消费者提供路孚特专有 ESG 分数全覆盖和完整历史的端点。</li><li id="5a72" class="lz ma in kk b kl mi kp mj kt mk kx ml lb mm lf me mf mg mh bi translated">Discovery Search 探索服务<code class="fe mo mp mq mr b">/discover/search/&lt;version&gt;/explore</code>基于搜索选项探索路孚特数据的端点。</li></ul><p id="b1b0" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">然而，这篇开发文章只涵盖了 ESG 服务测试用例。Discovery Search Explore 服务的测试用例与 ESG 的测试用例具有相同的测试逻辑。</p><h1 id="38f8" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">RDP ESG 服务的单元测试 HTTP 请求源代码</h1><p id="1183" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">现在让我来测试环境、社会和治理(ESG)服务端点。用于请求 ESG 数据的<code class="fe mo mp mq mr b">rdp_controller/rdp_http_controller.py</code>类中的代码如下所示。</p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="1982" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">上面的<code class="fe mo mp mq mr b">rdp_request_esg()</code>方法只是创建请求消息有效负载，并使用请求<code class="fe mo mp mq mr b">requests.get()</code>方法将其作为 HTTP GET 请求发送给 RDP ESG 服务。返回值可能如下所示</p><ul class=""><li id="4785" class="lz ma in kk b kl lg kp lh kt mb kx mc lb md lf me mf mg mh bi translated">如果请求成功(HTTP 状态为 200)，则以 JSON 消息格式返回响应数据。</li><li id="5c27" class="lz ma in kk b kl mi kp mj kt mk kx ml lb mm lf me mf mg mh bi translated">如果 URL 或访问令牌或 universe 值为空或无，则向调用方引发 TypeError 异常。</li><li id="b54c" class="lz ma in kk b kl mi kp mj kt mk kx ml lb mm lf me mf mg mh bi translated">如果请求失败，用 HTTP 状态响应信息向调用者引发请求的 HTTPError 异常。</li></ul><h1 id="9eea" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">测试有效的 RDP ESG 请求-响应</h1><p id="0b0b" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">第一个测试用例是请求成功场景。首先，我将创建一个包含有效 ESG 虚拟响应消息的 fixture 文件。一个文件是<em class="lm">测试/夹具</em>文件夹中的<em class="lm">RDP _ test _ ESG _ fixture . JSON</em>。</p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="1035" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">接下来，在 test_rdp_http_controller.py 文件中创建<code class="fe mo mp mq mr b">test_request_esg()</code>方法来测试最简单的测试用例，即成功的 ESG 数据请求-响应场景。这个方法用 HTTP <em class="lm"> GET </em>方法为 RDP <code class="fe mo mp mq mr b">https://api.refinitiv.com/data/environmental-social-governance/v2/views/scores-full</code>端点 URL 创建一个模拟对象。</p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="9ebe" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">当请求库接收到针对该 URL 的 HTTP GET 请求时，它会向应用程序返回一个模拟 ESG 数据 JSON 对象，该对象具有 HTTP 状态<em class="lm"> 200 </em>和内容类型<em class="lm"> application/json </em>。然后，<code class="fe mo mp mq mr b">test_request_esg()</code>方法验证响应数据是否在 JSON/ <a class="ae ll" href="https://docs.python.org/3.9/tutorial/datastructures.html#dictionaries" rel="noopener ugc nofollow" target="_blank">字典</a>类型中，并检查消息是否包含基本 ESG 字段。</p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="ms mt l"/></div></figure><h1 id="736e" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">测试使用过期令牌请求 RDP ESG 数据</h1><p id="1e26" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">这将我们带到一个最常见的 RDP API 故障场景，应用程序使用过期的访问令牌从 RDP 请求数据。<code class="fe mo mp mq mr b">test_request_esg_token_expire()</code>方法是使用 RDP ESG 服务测试这种情况的方法。</p><p id="5c97" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">第一步是创建一个 JSON 文件<code class="fe mo mp mq mr b">tests/rdp_test_token_expire_fixture.json</code>作为测试夹具，内容如下。</p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="ee71" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">所有 RDP 数据服务使用相同的令牌过期错误消息，所以我们加载这个 fixture 文件作为一个名为<code class="fe mo mp mq mr b">mock_token_expire_json</code>的类变量，在所有测试用例方法中使用。</p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="cc7f" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">令牌过期错误消息从 RDP 服务发送到具有 HTTP 错误状态的应用程序(401 — <strong class="kk io">截至 2022 年 7 月</strong>),<code class="fe mo mp mq mr b">test_request_esg_token_expire()</code>方法使用模拟对象模拟令牌过期错误消息和 HTTP 401 状态，如下所示。</p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="bbe7" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">接下来，这个测试用例验证<code class="fe mo mp mq mr b">rdp_request_esg()</code>方法是否用预期的错误消息和状态引发了<code class="fe mo mp mq mr b">requests.exceptions.HTTPError</code>异常。</p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="c561" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">另一个常见的 RDP API 失败场景是应用程序向 RDP 发送请求消息，而在 HTTP 请求头中没有访问令牌。然而，<em class="lm">访问令牌</em>是<code class="fe mo mp mq mr b">rdp_request_esg()</code>方法所需的参数之一。如果访问令牌不存在(无或为空)，该方法将引发 TypeError 异常，并且不向 RDP 发送 HTTP 请求消息。<code class="fe mo mp mq mr b">test_request_esg_none_empty()</code>方法是覆盖这个测试用例的方法。</p><h1 id="399d" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">测试使用无效项目请求 RDP ESG 数据</h1><p id="9c30" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">现在我们来看看其他常见的测试案例，如果用户从 RDP ESG 服务请求无效的商品名称数据，该怎么办？我们也可以使用模拟对象来模拟无效的项目请求-响应消息。</p><p id="6c3c" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">当 ESG 服务接收到带有无效项目名称的请求消息时，它将以下错误响应消息作为 HTTP Status <em class="lm"> 200 </em>(从 2022 年 7 月起<strong class="kk io"/>)返回给应用程序:</p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="2192" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated"><code class="fe mo mp mq mr b">test_request_esg_invalid_ric()</code>方法向请求库设置一个模拟无效项请求-响应消息，并检查<code class="fe mo mp mq mr b">rdp_request_esg()</code>方法是否如预期的那样返回带有 HTTP status <em class="lm"> 200 </em>的错误消息。</p><figure class="lo lp lq lr gt ls"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="34f3" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">关于用请求和响应库对 Python HTTP 代码进行单元测试，我要说的就是这些。</p><h1 id="c77f" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">先决条件</h1><p id="c1bf" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">这个演示项目需要下列依赖项。</p><ol class=""><li id="72f8" class="lz ma in kk b kl lg kp lh kt mb kx mc lb md lf mn mf mg mh bi translated">RDP 访问凭据。</li><li id="18f3" class="lz ma in kk b kl mi kp mj kt mk kx ml lb mm lf mn mf mg mh bi translated">Python <a class="ae ll" href="https://www.anaconda.com/distribution/" rel="noopener ugc nofollow" target="_blank"> Anaconda </a>或<a class="ae ll" href="https://docs.conda.io/en/latest/miniconda.html" rel="noopener ugc nofollow" target="_blank"> MiniConda </a>分发/包管理器。</li><li id="0648" class="lz ma in kk b kl mi kp mj kt mk kx ml lb mm lf mn mf mg mh bi translated"><a class="ae ll" href="https://docs.docker.com/get-docker/" rel="noopener ugc nofollow" target="_blank"> Docker 桌面/引擎</a>用 Docker 运行测试套件的应用。</li><li id="b59f" class="lz ma in kk b kl mi kp mj kt mk kx ml lb mm lf mn mf mg mh bi translated">互联网连接。</li></ol><p id="e41f" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">请联系您的路孚特代表，以帮助您访问 RDP 帐户和服务。您可以找到关于从租约设置的 RDP 访问凭据的更多详细信息，请参见<a class="ae ll" href="https://developers.refinitiv.com/en/article-catalog/article/getting-start-with-refinitiv-data-platform" rel="noopener ugc nofollow" target="_blank">路孚特数据平台</a>文章的<em class="lm">用户 ID </em>部分。</p><h1 id="cbe6" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">如何运行示例测试套件</h1><p id="fc8e" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">第一步是将示例项目文件夹解压缩或下载到您选择的目录中，然后根据您的偏好设置 Python 或 Docker 环境。</p><h1 id="4f82" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">在 Docker 中运行示例测试套件</h1><p id="1ff1" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">首先，在你的机器上启动一个 Docker 桌面或者 Docker 引擎。</p><p id="b1b6" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">然后打开控制台，转到<em class="lm">项目根目录</em>，运行下面的命令来构建 Docker 映像。</p><pre class="lo lp lq lr gt mu mr mv mw aw mx bi"><span id="876b" class="my jl in mr b gy mz na l nb nc">$&gt; docker build . -t python_unittest</span></pre><p id="fbeb" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">构建完成后，使用以下命令运行 Docker 容器:</p><pre class="lo lp lq lr gt mu mr mv mw aw mx bi"><span id="5b6d" class="my jl in mr b gy mz na l nb nc">$&gt; docker run -it --name python_unittest python_unittest</span></pre><p id="b34e" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">要停止和删除 Docker 容器，按下<em class="lm"> Ctrl+C </em>(或运行<em class="lm">Docker stop python _ unittest</em>)然后运行以下命令:</p><p id="9d14" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">$&gt; docker rm python_unittest</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi ng"><img src="../Images/7cf0ea63e7f47ae05eef74c63efe9caf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*SHRoyk0weDkE2ezp2qCqsA.gif"/></div></div></figure><p id="0717" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">这涵盖了如何运行一个示例测试套件。</p><h1 id="1a06" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">结论和下一步措施</h1><p id="859e" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">单元测试现在是现代和遗留应用软件开发生命周期的强制性过程。它有助于暴露应用程序一小部分的非故意行为，比试图在一个大的复杂阶段找到 bug 更快。它加速了整个反馈循环，并提高了项目团队之间的信任。单元测试还有助于提高应用程序源代码的质量，开发人员在重构源代码以获得更好的性能和更干净的代码时更有信心。作为这篇文章的作者，我也从这个项目中学到了很多。有很多错误处理程序或代码逻辑是我在开始编写单元测试用例之前从未想到过的。</p><p id="28de" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">这个示例项目演示了手动单元测试方法。然而，开发人员应该在每次对代码(或配置)进行更改时自动运行单元测试用例。最实用的技术是运行自动化单元测试，作为开发人员持续集成/持续交付(CI/CD)管道的一部分。开发人员也可以应用 TDD(测试驱动开发)方法，在为他们的项目编写新代码之前，编写并纠正失败的测试。</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi nh"><img src="../Images/8486dcd8541db81582b614337969fe17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UrwePHeMXSoZHz5aDUzo2A.png"/></div></div></figure><p id="ed11" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated"><a class="ae ll" href="https://docs.python.org/3.9/library/unittest.html" rel="noopener ugc nofollow" target="_blank"> unittest </a>框架和<a class="ae ll" href="https://github.com/getsentry/responses" rel="noopener ugc nofollow" target="_blank"> Responses </a> mocking 库是学习使用<a class="ae ll" href="https://www.python.org/" rel="noopener ugc nofollow" target="_blank"> Python </a>进行单元测试和构建一个简单测试套件来测试 HTTP 操作源代码的很好的起点。如果开发人员需要更高级的功能，他们可以探索其他 Python 单元测试框架，如<a class="ae ll" href="https://docs.pytest.org/en/7.1.x/" rel="noopener ugc nofollow" target="_blank"> pytest </a>、<a class="ae ll" href="https://github.com/nose-devs/nose2" rel="noopener ugc nofollow" target="_blank"> nose2 </a>或<a class="ae ll" href="https://github.com/doctest/doctest" rel="noopener ugc nofollow" target="_blank"> doctest </a>。</p><p id="369d" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">同时，<a class="ae ll" href="https://developers.refinitiv.com/en/api-catalog/refinitiv-data-platform/refinitiv-data-platform-apis" rel="noopener ugc nofollow" target="_blank">路孚特数据平台(RDP)API</a>通过易于使用的基于网络的 API 为开发者提供各种路孚特数据和内容。这些 API 很容易集成到任何支持 HTTP 协议和 JSON 消息格式的应用程序和平台中。</p><h1 id="c3df" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">参考</h1><p id="5578" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">这就是我的单元测试示例项目的结尾。有关详细信息，请查看以下资源:</p><ul class=""><li id="7d97" class="lz ma in kk b kl lg kp lh kt mb kx mc lb md lf me mf mg mh bi translated"><a class="ae ll" href="https://developers.refinitiv.com/en/api-catalog/refinitiv-data-platform/refinitiv-data-platform-apis" rel="noopener ugc nofollow" target="_blank">路孚特开发者社区</a>网站上的路孚特数据平台 API 页面。</li><li id="d05c" class="lz ma in kk b kl mi kp mj kt mk kx ml lb mm lf me mf mg mh bi translated"><a class="ae ll" href="https://api.refinitiv.com" rel="noopener ugc nofollow" target="_blank">路孚特数据平台 API 游乐场页面</a>。</li><li id="8146" class="lz ma in kk b kl mi kp mj kt mk kx ml lb mm lf me mf mg mh bi translated">路孚特数据平台 API:请求-响应 API 介绍。</li><li id="9e3b" class="lz ma in kk b kl mi kp mj kt mk kx ml lb mm lf me mf mg mh bi translated"><a class="ae ll" href="https://developers.refinitiv.com/en/api-catalog/refinitiv-data-platform/refinitiv-data-platform-apis/tutorials#authorization-all-about-tokens" rel="noopener ugc nofollow" target="_blank">路孚特数据平台 API:授权—关于令牌的一切</a>。</li><li id="2524" class="lz ma in kk b kl mi kp mj kt mk kx ml lb mm lf me mf mg mh bi translated">RDP 认证服务的限制和准则。</li><li id="c0f5" class="lz ma in kk b kl mi kp mj kt mk kx ml lb mm lf me mf mg mh bi translated"><a class="ae ll" href="https://developers.refinitiv.com/en/article-catalog/article/getting-start-with-refinitiv-data-platform" rel="noopener ugc nofollow" target="_blank">路孚特数据平台入门</a>文章。</li><li id="5bab" class="lz ma in kk b kl mi kp mj kt mk kx ml lb mm lf me mf mg mh bi translated"><a class="ae ll" href="https://docs.python.org/3/library/unittest.html" rel="noopener ugc nofollow" target="_blank"> Python unittest 框架官方页面</a>。</li><li id="243d" class="lz ma in kk b kl mi kp mj kt mk kx ml lb mm lf me mf mg mh bi translated"><a class="ae ll" href="https://github.com/getsentry/responses" rel="noopener ugc nofollow" target="_blank">回应库页面</a>。</li><li id="3f29" class="lz ma in kk b kl mi kp mj kt mk kx ml lb mm lf me mf mg mh bi translated">Python 指南:测试您的代码文章。</li><li id="29d2" class="lz ma in kk b kl mi kp mj kt mk kx ml lb mm lf me mf mg mh bi translated"><a class="ae ll" href="https://realpython.com/python-testing/" rel="noopener ugc nofollow" target="_blank">Python 测试入门</a>文章。</li><li id="bff6" class="lz ma in kk b kl mi kp mj kt mk kx ml lb mm lf me mf mg mh bi translated"><a class="ae ll" href="https://realpython.com/testing-third-party-apis-with-mocks/" rel="noopener ugc nofollow" target="_blank">在 Python </a>文章中嘲讽外部 API。</li><li id="3785" class="lz ma in kk b kl mi kp mj kt mk kx ml lb mm lf me mf mg mh bi translated"><a class="ae ll" href="https://www.digitalocean.com/community/tutorials/how-to-use-unittest-to-write-a-test-case-for-a-function-in-python" rel="noopener ugc nofollow" target="_blank">如何使用 unittest 为 Python 中的一个函数编写测试用例</a>文章。</li><li id="70f2" class="lz ma in kk b kl mi kp mj kt mk kx ml lb mm lf me mf mg mh bi translated"><a class="ae ll" href="https://auth0.com/blog/mocking-api-calls-in-python/" rel="noopener ugc nofollow" target="_blank">在 Python </a>文章中嘲讽 API 调用。</li><li id="9bad" class="lz ma in kk b kl mi kp mj kt mk kx ml lb mm lf me mf mg mh bi translated"><a class="ae ll" href="https://softwareengineering.stackexchange.com/questions/89064/how-and-when-to-use-unit-testing-properly" rel="noopener ugc nofollow" target="_blank">如何以及何时正确使用单元测试</a>帖子。</li><li id="6ef9" class="lz ma in kk b kl mi kp mj kt mk kx ml lb mm lf me mf mg mh bi translated">写有用的单元测试的 13 个技巧。</li></ul><p id="d5fd" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">有关路孚特数据平台 API 的任何问题，请使用<a class="ae ll" href="https://community.developers.refinitiv.com/" rel="noopener ugc nofollow" target="_blank">开发者社区 Q &amp; A 页面</a>上的<a class="ae ll" href="https://community.developers.refinitiv.com/spaces/231/index.html" rel="noopener ugc nofollow" target="_blank">RDP API 论坛</a>。</p><h1 id="d1b1" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">开源代码库</h1><p id="845c" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated"><a class="ae ll" href="https://github.com/Refinitiv-API-Samples/Article.RDP.Python.HTTP.UnitTest" rel="noopener ugc nofollow" target="_blank">路孚特-API-样品/物品。RDP.Python.HTTP.UnitTest </a></p></div></div>    
</body>
</html>