<html>
<head>
<title>Angular ideas and SonarQube rules.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">有角度的想法和 SonarQube 规则。</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/angular-ideas-and-sonarqube-rules-3f781f236bfe?source=collection_archive---------2-----------------------#2021-03-09">https://blog.devgenius.io/angular-ideas-and-sonarqube-rules-3f781f236bfe?source=collection_archive---------2-----------------------#2021-03-09</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="3b62" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">打字稿是一个无止境的工作过程…</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/10e0c9829197790faf6f0327b4726da7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_MzyRrvtSudak_DHxjIwTg.png"/></div></div></figure><p id="5831" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">JavaScript 奠定了前端开发的基础，但如今 Typescript 发展迅速。它变成了一种编译语言，SonarQube 和 Jenkins 这样的工具帮助我们构建项目，并过滤代码气味、错误、漏洞和其他不一致之处。</p><p id="11e1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">SonarQube 规则对于识别 html、css 和 typescript 错误行为非常有帮助，可以改进。通常我们有 0 条未覆盖的线和 0 个未覆盖的条件。但这还不足以取悦 SonarQube。它希望有很多测试代码覆盖率，例如 98%。</p><p id="36c3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">0.分解器</p><p id="bef7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">解析器类作为预检查层工作。它将在组件准备好之前获取数据和条件。想法是创建类 ServiceResolver，它将订阅您的服务函数，通过例子来说明。这可以用于数据映射或验证检查。如果出现错误，将停止导航到组件。</p><pre class="kj kk kl km gt ku kv kw kx aw ky bi"><span id="6634" class="kz la in kv b gy lb lc l ld le">export class ServiceResolver implements Resolve&lt;string&gt; {<br/>  constructor(private authService: AuthService) { }<br/>  resolve(route: ActivatedRouteSnapshot, state:RouterStateSnapshot): Observable&lt;string&gt; {<br/>    return this.authService.getToken()<br/>      .pipe( catchError(err =&gt; of(null)) );<br/>  }<br/>}</span></pre><p id="d91e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在测试过程中，我们需要为每个测试用例创建一个假的 ActivatedRoute，并将其传递给 resolver.resolve()方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="16ef" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您还需要在应用程序模块中定义 ServiceResolver 的用法:</p><pre class="kj kk kl km gt ku kv kw kx aw ky bi"><span id="7290" class="kz la in kv b gy lb lc l ld le">const routes: Routes = [<br/>{ path: 'users', component: UsersComponent, resolve: { users:  ServiceResolver } }<br/>];</span><span id="7c2f" class="kz la in kv b gy lh lc l ld le"><a class="ae li" href="http://twitter.com/NgModule" rel="noopener ugc nofollow" target="_blank">@NgModule</a>({<br/>  imports: [<br/>    RouterModule.forRoot(routes, {onSameUrlNavigation: "reload" })],<br/>  exports: [RouterModule]<br/>})<br/>export class AppRoutingModule { }</span></pre><ol class=""><li id="340f" class="lj lk in jm b jn jo jr js jv ll jz lm kd ln kh lo lp lq lr bi translated">深层拷贝</li></ol><p id="12b5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">创建源的深层副本，它应该是一个对象或数组。这个函数在内部使用，主要在变更检测代码中使用。它不是一个通用的复制功能。当一个对象与这个对象及其子对象(或孙对象等)一起被复制时。)值被赋予另一个值，原始值的子值不受任何影响。</p><pre class="kj kk kl km gt ku kv kw kx aw ky bi"><span id="8aba" class="kz la in kv b gy lb lc l ld le">let originalObject = {name: 'Olmer', phone: '00000000'};<br/>let copiedObject = Object.assign({}, originalObject);</span></pre><p id="b916" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对于具有嵌套属性的更复杂的对象，最好还是使用 deepCopy:</p><pre class="kj kk kl km gt ku kv kw kx aw ky bi"><span id="0e6b" class="kz la in kv b gy lb lc l ld le">this.pricesAndTariffs = deepCopy(ObjectPrices);</span></pre><p id="b4bf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有很多用于深度复制的库，比如:</p><p id="b07e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae li" href="https://github.com/ykdr2017/ts-deepcopy" rel="noopener ugc nofollow" target="_blank">https://github.com/ykdr2017/ts-deepcopy</a></p><p id="4004" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">2.ngOnChanges()或 get/set</p><p id="85c9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">请尝试在 Input()上使用 get，set，而不是 ngOnChanges。缺点:当 ngOnChanges 中有许多输入时，每个“如果”都必须检查。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="0699" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">2.属性指令</p><p id="d581" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当需要改变视图的外观或行为时使用它。只需实现一个属性指令，并在组件和模块之间共享它，以避免重复相同功能的代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="674a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">3.ngClass 允许选择使用类别。</p><p id="eea3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下面是通过类的多种方法</p><pre class="kj kk kl km gt ku kv kw kx aw ky bi"><span id="7a87" class="kz la in kv b gy lb lc l ld le">&lt;some-element [ngClass]="'first second'"&gt;...&lt;/some-element&gt;</span><span id="a012" class="kz la in kv b gy lh lc l ld le">&lt;some-element [ngClass]="['first', 'second']"&gt;...&lt;/some-element&gt;</span><span id="5b9c" class="kz la in kv b gy lh lc l ld le">&lt;some-element [ngClass]="{'first': true, 'second': true, 'third': false}"&gt;...&lt;/some-element&gt;</span><span id="9af0" class="kz la in kv b gy lh lc l ld le">&lt;some-element [ngClass]="stringExp|arrayExp|objExp"&gt;...&lt;/some-element&gt;</span><span id="cc48" class="kz la in kv b gy lh lc l ld le">&lt;some-element [ngClass]="{'class1 class2 class3' : true}"&gt;...&lt;/some-element&gt;</span></pre><p id="6fa2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">最好最简单的方法是:</strong></p><p id="d0b1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果学生为空，则禁用，否则不禁用。在按钮属性中使用它。如果您使用引导主题</p><pre class="kj kk kl km gt ku kv kw kx aw ky bi"><span id="7f7d" class="kz la in kv b gy lb lc l ld le">[ngClass]="{disabled: (students === null) ? true : false}"<br/></span></pre><p id="bd5e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用 ngClass 切换类</p><pre class="kj kk kl km gt ku kv kw kx aw ky bi"><span id="5368" class="kz la in kv b gy lb lc l ld le">&lt;button [ngClass]="{'active': selectedItem === 'item1'}" (click)="selectedItem = 'item1'"&gt;Button One&lt;/button&gt;<br/>&lt;button [ngClass]="{'active': selectedItem === 'item2'}" (click)="selectedItem = 'item2'"&gt;Button Two&lt;/button&gt;</span></pre><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="b89b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">4.尽可能使用 renderer addClass，removeClass。这将防止过多的变更检测检查。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="c382" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">5.错误处理程序。如何正确处理错误？</p><p id="a3b1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们可以将我们的错误句柄移动到单独的文件中，并在<code class="fe ls lt lu kv b">AppModule.</code>中注册它，只需用一个类<code class="fe ls lt lu kv b">MyErrorHandler.</code>添加<code class="fe ls lt lu kv b">@NgModule</code></p><p id="5c29" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">每个错误都将在模块的边界被拦截。通知用户有关问题并发送错误数据作为票据信息以供将来调查是有用的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="e69f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">6.空的和未定义的对象。</p><blockquote class="lv lw lx"><p id="ce4e" class="jk jl ly jm b jn jo jp jq jr js jt ju lz jw jx jy ma ka kb kc mb ke kf kg kh ig bi translated">Null 表示变量值已定义，但 null 没有值。<br/> Undefined 意味着变量值没有被定义；价值多少不得而知。</p></blockquote><p id="68c2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> typeof </strong>关键字是检查它的理想选择:</p><pre class="kj kk kl km gt ku kv kw kx aw ky bi"><span id="43ed" class="kz la in kv b gy lb lc l ld le">let user = {<br/> name: 'Olmer',<br/> email: 'info@olmer.ru'<br/>};<br/><br/>if (typeof user.phone === 'undefined') {<br/>  console.log(user.phone); // undefined, because no phone property<br/>}</span><span id="4c57" class="kz la in kv b gy lh lc l ld le">function hasUndefinedProperty(obj, prop){<br/>  return ((prop in obj) &amp;&amp; (typeof obj[prop] === 'undefined'));<br/>};<br/>hasUndefinedProperty(user, 'city');</span><span id="3f4a" class="kz la in kv b gy lh lc l ld le">or the most short syntax:<br/>function isUndefined(value) { return value === void 0; }</span></pre><p id="564a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> typeof </strong>也可以用来定义其他类型。举例来说:</p><pre class="kj kk kl km gt ku kv kw kx aw ky bi"><span id="576d" class="kz la in kv b gy lb lc l ld le">if (typeof prettyPrint !== 'function') {}<br/>if (typeof myStr === "string") {}</span></pre><p id="09fa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">7.Jasmine Karma 测试框架和“完成”功能。</p><div class="mc md gp gr me mf"><a href="https://angular.io/guide/testing-services" rel="noopener  ugc nofollow" target="_blank"><div class="mg ab fo"><div class="mh ab mi cl cj mj"><h2 class="bd io gy z fp mk fr fs ml fu fw im bi translated">有角的</h2><div class="mm l"><h3 class="bd b gy z fp mk fr fs ml fu fw dk translated">Angular 是一个构建移动和桌面 web 应用程序的平台。加入数百万开发者的社区…</h3></div><div class="mn l"><p class="bd b dl z fp mk fr fs ml fu fw dk translated">angular.io</p></div></div></div></a></div><pre class="kj kk kl km gt ku kv kw kx aw ky bi"><span id="948f" class="kz la in kv b gy lb lc l ld le">describe('ValueService', () =&gt; {<br/>  let service: ValueService;<br/>  beforeEach(() =&gt; { service = new ValueService(); });</span><span id="25fd" class="kz la in kv b gy lh lc l ld le">  it('#getObservableValue should return value from observable',<br/>    (done: DoneFn) =&gt; {<br/>    service.getObservableValue().subscribe(value =&gt; {<br/>      expect(value).toBe('observable value');<br/>      done();<br/>    });<br/>  });<br/>});</span></pre><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="1a59" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">8.同一元素上的*ngIf 和*ngFor 导致错误</p><p id="9d9d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Angular v2 不支持同一元素上的多个结构指令。<br/>作为一种变通方法，使用<code class="fe ls lt lu kv b">&lt;ng-container&gt; or &lt;ng-template&gt;</code>元素，它允许您为每个结构指令使用单独的元素。</p><pre class="kj kk kl km gt ku kv kw kx aw ky bi"><span id="00ad" class="kz la in kv b gy lb lc l ld le">&lt;tr *ngFor = "let item of list"&gt;<br/> &lt;ng-template [ngIf] = "item == ’snooker’"&gt;<br/> &lt;td&gt;Unusual choice&lt;/td&gt;<br/> &lt;/ng-template&gt;<br/>&lt;/tr&gt;<br/>export class Component{<br/>  const list = ['pool', 'snooker', 'carom ball', 'pyramid'].<br/>}</span></pre><p id="1482" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">9.错误类型错误:无法将对象“[object Object]”的只读属性“value”赋值。</p><p id="9788" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果变量为常量、可观察变量或只读状态，则变量变为只读。</p><p id="588f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您必须使用 Object.assign()方法来更改对象的值，如下所示:</p><pre class="kj kk kl km gt ku kv kw kx aw ky bi"><span id="ad5a" class="kz la in kv b gy lb lc l ld le">Object.assign(target, source);</span></pre><p id="5b33" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在赋值之前检查对象也是合理的。</p><pre class="kj kk kl km gt ku kv kw kx aw ky bi"><span id="6fb3" class="kz la in kv b gy lb lc l ld le">function isEmpty(str){<br/>    return !str || !/[^\s]+/.test(str); //number and string<br/>}</span></pre><p id="a1c6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">10.<strong class="jm io"> As </strong>关键字——像造型一样，告诉编译器变量的类型。</p><pre class="kj kk kl km gt ku kv kw kx aw ky bi"><span id="0f43" class="kz la in kv b gy lb lc l ld le">get topics(): FormArray {<br/>    const result: FormArray = this.form.get('posts');<br/>    return result;<br/>}<br/>//or we can do it this way: <br/>return this.form.get('posts') as FormArray;</span></pre><p id="56c1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">11.ViewChild —从视图中选择 html 元素。</p><p id="a005" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae li" href="http://twitter.com/ViewChild" rel="noopener ugc nofollow" target="_blank"> @ViewChild </a>查询在 AfterViewInit、ngOnInit 或构造函数之前运行。</p><pre class="kj kk kl km gt ku kv kw kx aw ky bi"><span id="b952" class="kz la in kv b gy lb lc l ld le">import { Component, ViewChild, AfterViewInit } from '<a class="ae li" href="http://twitter.com/angular/core" rel="noopener ugc nofollow" target="_blank">@angular/core</a>';<br/><a class="ae li" href="http://twitter.com/Component" rel="noopener ugc nofollow" target="_blank">@Component</a>({<br/>  selector: 'app',<br/>  template: `&lt;p #myText&gt; Lorem ipsum &lt;/p&gt;`<br/>})<br/>export class AppComponent implements OnInit, AfterViewInit  {<br/>  <a class="ae li" href="http://twitter.com/ViewChild" rel="noopener ugc nofollow" target="_blank">@ViewChild</a>('myText', {static: false}) text: HTMLElement;<br/>  ngOnInit() {}<br/>  ngAfterViewInit() {<br/>    console.log('myText', this.text);<br/>  }<br/>}</span></pre><p id="050a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">{static: false}表示 Angular 将在视图创建后查找元素。<br/> {static: true}当您的孩子使用具有预定义值的实例字段时，请使用它。</p><h1 id="9207" class="mo la in bd mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk bi translated">sonar cube——有用的工具，但有时很烦人。</h1><p id="c462" class="pw-post-body-paragraph jk jl in jm b jn nl jp jq jr nm jt ju jv nn jx jy jz no kb kc kd np kf kg kh ig bi translated">项目的一些情况和规则:</p><ol class=""><li id="e8c2" class="lj lk in jm b jn jo jr js jv ll jz lm kd ln kh lo lp lq lr bi translated">SonarQube 需要修复以下规则:当尝试设置自定义 HTML 标签的样式时，“意外的未知类型选择器<code class="fe ls lt lu kv b">card</code>”。</li></ol><p id="40a8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">想法很明确:不要直接使用有角度的<code class="fe ls lt lu kv b">card</code>选择器。创建自定义标签，定义类名并应用所需的样式。</p><p id="d466" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ls lt lu kv b">.card {<br/> margin: 0 15px 0px 15px;<br/> }</code></p><pre class="kj kk kl km gt ku kv kw kx aw ky bi"><span id="b6c4" class="kz la in kv b gy lb lc l ld le">&lt;card label='My card'<br/>               class="card"<br/>               imageUrl='../assets/icon.svg'<br/>               (clicked)="routeTo('myCard')"&gt;&lt;/card&gt;</span></pre><p id="63d2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">2.索纳库贝。更新此函数，使其实现与第行中的不同。</p><pre class="kj kk kl km gt ku kv kw kx aw ky bi"><span id="6e6f" class="kz la in kv b gy lb lc l ld le">&lt;card label='My card'<br/>               class="card"<br/>               imageUrl='../assets/icon.svg'<br/>               (clicked)="routeTo('myCard')"&gt;&lt;/card&gt;6. SonarQube. ‘Update this function so that its implementation is not identical to the one on line’</span><span id="5d96" class="kz la in kv b gy lh lc l ld le">private setupFormStatusChange() {<br/>  this.totalFG.statusChanges.subscribe(next =&gt; {<br/>    if (next === 'VALID') {<br/>      this.formStatusService.tabIsValid(Tab.Cargo);<br/>    }<br/>  });<br/>  this.detailsFG.statusChanges.subscribe(next =&gt; {<br/>    if (next === 'VALID') {<br/>      this.formStatusService.tabIsValid(Tab.Cargo);<br/>    }<br/>  });<br/>}</span></pre><p id="81bc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">解决方案:将受益人更新放入它自己的函数或方法中，并从两个地方调用它:</p><pre class="kj kk kl km gt ku kv kw kx aw ky bi"><span id="254b" class="kz la in kv b gy lb lc l ld le">private setupFormStatusChange() {<br/>  this.totalFG.statusChanges.subscribe(next =&gt; {<br/>    this.updateFormStatus(next);<br/>  });<br/>  this.detailsFG.statusChanges.subscribe(next =&gt; {<br/>    this.updateFormStatus(next);<br/>  });<br/>}<br/>private updateFormStatus(next: any) {<br/>  if (next === 'VALID') {<br/>    this.formStatusService.tabIsValid(Tab.Cargo);<br/>  }<br/>}</span></pre><p id="05c6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">3.Sonarqube 投诉“始终如一地使用退货”。</p><p id="0a8f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有时你什么都不会返回，并且会错过 return 关键字。我们必须看函数返回:它是布尔型还是其他类型？如果是布尔值，也要返回一个布尔值。否则，就返回 undefined。不会打破逻辑。</p><pre class="kj kk kl km gt ku kv kw kx aw ky bi"><span id="8808" class="kz la in kv b gy lb lc l ld le">  function quotationText(quotation: Quotation): string {<br/>    switch (quotation.status) {<br/>      case QuoteStatus.COMPLETED:<br/>        return "waiting for document processing";<br/>      case QuoteStatus.INACTIVE:<br/>        return "inactive";<br/>    }<br/>    return undefined;<br/>  }</span></pre><p id="cc4e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">4.声纳量子质量剖面探测到的“认知复杂性”气味</p><p id="d781" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当我们有很多<strong class="jm io"> if/else </strong>或者<strong class="jm io"> switch/cases </strong>的时候，就该这样重构了:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="ba3f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">5.SonarQube 属性</p><p id="9a7b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在模拟测试数据等情况下，有时有必要从声纳分析中排除一些类别。我们在项目根创建特殊文件<strong class="jm io"> sonar-project.properties </strong></p><pre class="kj kk kl km gt ku kv kw kx aw ky bi"><span id="e52c" class="kz la in kv b gy lb lc l ld le">sonar.host.url=http://mysonar:8080/<br/>sonar.language=ts<br/>file.encoding=UTF-8<br/>project.build.sourceEncoding=UTF-8<br/>sonar.sources=apps/<br/>sonar.exclusions= **/*.spec.ts</span></pre><p id="f004" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">棱角分明的后记:</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nq"><img src="../Images/7c9db28f1aea2767103bdb015c0c4284.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5Jm7HkRNSJ1GDI8cO5QklQ.png"/></div></div></figure><p id="f57d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">结论</strong></p><p id="162f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">充满细节和狡猾行为的棱角分明的世界。了解其中一些需要长时间的经验和耐心…</p><div class="mc md gp gr me mf"><a href="https://www.typescriptlang.org/docs/handbook/basic-types.html#void" rel="noopener  ugc nofollow" target="_blank"><div class="mg ab fo"><div class="mh ab mi cl cj mj"><h2 class="bd io gy z fp mk fr fs ml fu fw im bi translated">手册-基本类型</h2><div class="mm l"><h3 class="bd b gy z fp mk fr fs ml fu fw dk translated">学习 TypeScript 的第一步:基本类型。</h3></div><div class="mn l"><p class="bd b dl z fp mk fr fs ml fu fw dk translated">www.typescriptlang.org</p></div></div></div></a></div></div></div>    
</body>
</html>