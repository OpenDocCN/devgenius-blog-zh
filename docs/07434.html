<html>
<head>
<title>NodeJS and closing your MySQL connections — a study</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">NodeJS 和关闭 MySQL 连接——一项研究</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/nodejs-how-to-close-your-mysql-connections-and-why-a7cc7287132b?source=collection_archive---------1-----------------------#2022-03-25">https://blog.devgenius.io/nodejs-how-to-close-your-mysql-connections-and-why-a7cc7287132b?source=collection_archive---------1-----------------------#2022-03-25</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/f038d87452b6ac068ab50a863340abcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GD8MhpHCDy8X2J1F"/></div></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk translated">约翰·巴克利在<a class="ae ja" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><div class=""/><p id="176a" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了不填满最大连接数，跟踪数据库连接非常重要。如果你不小心，你将很容易达到极限，导致可怕的错误“太多的连接”,当你试图连接到你的 MySQL 服务器，并导致数据库服务器窒息。</p><p id="69b2" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这篇文章研究了在使用 npm 包<a class="ae ja" href="https://github.com/sidorares/node-mysql2" rel="noopener ugc nofollow" target="_blank"> mysql2 </a>时，糟糕的(和良好的)编码会如何影响连接到 MySQL 数据库服务器的线程数量</p><p id="ec50" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">MySQL 服务器的最大连接数由其变量“max_connection”决定，可以通过查询数据库服务器来读取:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="e79f" class="lh li jd ld b gy lj lk l ll lm">SHOW VARIABLES LIKE 'max_connections';</span></pre><p id="52d7" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">要检查连接了多少个线程，我们可以运行以下查询:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="6150" class="lh li jd ld b gy lj lk l ll lm">SHOW STATUS WHERE `variable_name` = 'Threads_connected';</span></pre><p id="4b25" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果我们在一个数据库服务器上，我们知道没有其他服务器与之连接，最好是在您自己的笔记本电脑上，我们可能会看到以下结果:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="acbb" class="lh li jd ld b gy lj lk l ll lm">Threads_connected 1</span></pre><p id="5474" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一个连接是你现在正在查找有多少个连接，所以你永远不会在这里看到 0。</p><p id="1eb0" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在我的例子中，我安装了一个本地 MySQL 服务器，所以做一些不好的实践例子是安全的。因此，如果你想自己尝试这些不好的做法，请确保你不要在生产服务器上这样做！</p><h2 id="474b" class="lh li jd bd ln lo lp dn lq lr ls dp lt kl lu lv lw kp lx ly lz kt ma mb mc md bi translated">创建连接</h2><p id="71c3" class="pw-post-body-paragraph ka kb jd kc b kd me kf kg kh mf kj kk kl mg kn ko kp mh kr ks kt mi kv kw kx ig bi translated">例如，下面的代码将创建 100 个连接，并使它们保持打开状态:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="f5a2" class="lh li jd ld b gy lj lk l ll lm">const mysql = require(‘mysql2’);</span><span id="0d70" class="lh li jd ld b gy mj lk l ll lm">for (let i = 0; i &lt; 100; i++) {<br/>  let connection = mysql.createConnection({<br/>    host: ‘localhost’,<br/>    user: ‘root’,<br/>  });<br/>}</span></pre><p id="1f0c" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们通过以下方式运行代码:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="5950" class="lh li jd ld b gy lj lk l ll lm">node your-file-name.js</span></pre><p id="4825" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在检查我们的线程数:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="68d6" class="lh li jd ld b gy lj lk l ll lm">Threads_connected 101</span></pre><p id="9011" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是因为当您创建一个连接时，它将一直保持打开状态，直到您将其关闭。要关闭一个连接，我们可以使用<em class="mk"> connection.end() </em>，所以让我们重新启动我们的 MySQL 服务器，以确保我们重置了所有连接，然后尝试下面的代码:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="4c53" class="lh li jd ld b gy lj lk l ll lm">const mysql = require(‘mysql2’);</span><span id="ff55" class="lh li jd ld b gy mj lk l ll lm">for (let i = 0; i &lt; 100; i++) {<br/>  let connection = mysql.createConnection({<br/>    host: ‘localhost’,<br/>    user: ‘root’,<br/>  });<br/>  connection.end();<br/>}</span></pre><p id="dc6b" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在检查我们的线程数:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="c8b0" class="lh li jd ld b gy lj lk l ll lm">Threads_connected 1</span></pre><p id="4176" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这意味着我们所有的 100 个连接都被关闭了，这当然要好得多。但是，如果您打算在一个请求中多次查询您的数据库，设置一个<strong class="kc je">池</strong>是最佳实践。</p><figure class="ky kz la lb gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi ml"><img src="../Images/2d1053b10e16ba219ee5d88d5eacf947.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lVqwXs5HrkiSbTCW"/></div></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk translated"><a class="ae ja" href="https://unsplash.com/@corybjork?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">科里·比约克</a>在<a class="ae ja" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h2 id="a292" class="lh li jd bd ln lo lp dn lq lr ls dp lt kl lu lv lw kp lx ly lz kt ma mb mc md bi translated">使用池</h2><p id="b886" class="pw-post-body-paragraph ka kb jd kc b kd me kf kg kh mf kj kk kl mg kn ko kp mh kr ks kt mi kv kw kx ig bi translated">那我们应该如何使用游泳池呢？让我们从如何不使用游泳池开始。如果我们重启我们的 MySQL 服务器，然后运行下面的代码:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="b213" class="lh li jd ld b gy lj lk l ll lm">const mysql = require(‘mysql2’);</span><span id="1eb6" class="lh li jd ld b gy mj lk l ll lm">for (let i = 0; i &lt; 100; i++) {<br/>  let pool = mysql.createPool({<br/>    host: ‘localhost’,<br/>    user: ‘root’,<br/>    connectionLimit: 10,<br/>  });<br/>}</span></pre><p id="1193" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如您所见，我们仍在循环一百次，但我们现在不是创建一个连接，而是创建一个池。池选项引入了一个新参数，<em class="mk"> connectionLimit </em>。默认情况下，它的值是 10，这意味着该池创建的连接不会超过这个限制。</p><p id="66a3" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在检查我们的线程数:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="6882" class="lh li jd ld b gy lj lk l ll lm">Threads_connected 1</span></pre><p id="61f7" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所以这比<em class="mk"> createConnection() </em>要好，对吗？是的，只要我们不使用我们的游泳池，那有什么好处呢？不好。</p><p id="35c0" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">要使用我们的池，我推荐通过<a class="ae ja" href="https://github.com/sidorares/node-mysql2#using-promise-wrapper" rel="noopener ugc nofollow" target="_blank">承诺包装器</a>来使用它(我实在看不出为什么不使用它)。</p><p id="9d66" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，让我们应用 promise 包装器，然后使用池进行查询，如下所示:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="2353" class="lh li jd ld b gy lj lk l ll lm">const mysql = require(‘mysql2’);</span><span id="24a6" class="lh li jd ld b gy mj lk l ll lm">for (let i = 0; i &lt; 100; i++) {<br/>  let pool = mysql<br/>    .createPool({<br/>      host: ‘localhost’,<br/>      user: ‘root’,<br/>      connectionLimit: 10,<br/>    })<br/>    .promise();<br/>  pool.query(‘SELECT 1’)<br/>    .then(res =&gt; {<br/>  });<br/>}</span></pre><p id="d761" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在检查我们的线程数:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="629c" class="lh li jd ld b gy lj lk l ll lm">Threads_connected 101</span></pre><p id="123f" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">换句话说，就像我们使用<em class="mk"> createConnection() </em>时一样糟糕。但是(您可能已经明白了)池的整个概念是创建一次，然后多次重用。因此，让我们将池的创建移到循环之外:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="9d31" class="lh li jd ld b gy lj lk l ll lm">const mysql = require(‘mysql2’);</span><span id="9c90" class="lh li jd ld b gy mj lk l ll lm">let pool = mysql<br/>  .createPool({<br/>    host: ‘localhost’,<br/>    user: ‘root’,<br/>    connectionLimit: 10,<br/>  })<br/>  .promise();</span><span id="87a9" class="lh li jd ld b gy mj lk l ll lm">for (let i = 0; i &lt; 100; i++) {<br/>  pool.query(‘SELECT 1’)<br/>    .then(res =&gt; {<br/>  });<br/>}</span></pre><p id="837f" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果我们重新启动我们的 MySQL 服务器，然后运行上面的代码，检查我们的连接线程数，现在的结果是:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="19b5" class="lh li jd ld b gy lj lk l ll lm">Threads_connected 11</span></pre><p id="961b" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这意味着，根据我们的选项参数<em class="mk"> connectionLimit </em>，我们的池使用了所有可用的连接，但是它们仍然保持开放，并且在我们的最大连接数中占据了插槽。</p><h2 id="5414" class="lh li jd bd ln lo lp dn lq lr ls dp lt kl lu lv lw kp lx ly lz kt ma mb mc md bi translated">结束池</h2><p id="4e9d" class="pw-post-body-paragraph ka kb jd kc b kd me kf kg kh mf kj kk kl mg kn ko kp mh kr ks kt mi kv kw kx ig bi translated">幸运的是，对于这个问题也有一个解决方案，它被称为<em class="mk"> pool.end() </em>，所以让我们通过这样做来尝试一下:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="ee33" class="lh li jd ld b gy lj lk l ll lm">const mysql = require(‘mysql2’);</span><span id="4d97" class="lh li jd ld b gy mj lk l ll lm">let pool = mysql<br/>  .createPool({<br/>    host: ‘localhost’,<br/>    user: ‘root’,<br/>    connectionLimit: 10,<br/>  })<br/>  .promise();</span><span id="6e70" class="lh li jd ld b gy mj lk l ll lm">for (let i = 0; i &lt; 100; i++) {<br/>  pool.query(‘SELECT 1’)<br/>    .then(res =&gt; {<br/>  });<br/>}<br/>pool.end();</span></pre><p id="42cb" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果我们运行这段代码，我们将得到一个错误，如<em class="mk">“池已关闭”</em>。(正如您可能会想到的)这是因为我们在异步查询完成之前关闭了池。</p><p id="e476" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">是时候引入<em class="mk"> async/await </em>功能了(仅在 Node.js 版本 8 或更新版本中可用)。要使用<em class="mk"> await </em>，我们需要遵循一些规则，正如 NodeJS 所说:</p><blockquote class="mm mn mo"><p id="2f3d" class="ka kb mk kc b kd ke kf kg kh ki kj kk mp km kn ko mq kq kr ks mr ku kv kw kx ig bi translated">await 只在异步函数和顶级模块体中有效。</p></blockquote><p id="762c" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，我将把我的代码包装在一个自调用的异步函数中，就像这样:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="5b5b" class="lh li jd ld b gy lj lk l ll lm">const mysql = require(‘mysql2’);</span><span id="9439" class="lh li jd ld b gy mj lk l ll lm">(async () =&gt; {<br/>  let pool = mysql<br/>    .createPool({<br/>      host: ‘localhost’,<br/>      user: ‘root’,<br/>      connectionLimit: 10,<br/>    })<br/>    .promise();<br/>  for (let i = 0; i &lt; 100; i++) {<br/>    let rows = await pool.query(‘SELECT 1’);<br/>  }<br/>  pool.end();<br/>})();</span></pre><p id="1633" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果我们现在重新启动我们的 MySQL 服务器并运行上面的代码，检查我们的线程数，结果如下:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="157c" class="lh li jd ld b gy lj lk l ll lm">Threads_connected 1</span></pre><h2 id="acb2" class="lh li jd bd ln lo lp dn lq lr ls dp lt kl lu lv lw kp lx ly lz kt ma mb mc md bi translated">达到我们的目标？</h2><p id="1dc7" class="pw-post-body-paragraph ka kb jd kc b kd me kf kg kh mf kj kk kl mg kn ko kp mh kr ks kt mi kv kw kx ig bi translated">我们终于做到了。我们查询数据库 a 100 次，没有在连接的线程中留下任何痕迹。这不是很好吗？好吧，让我们继续学习。</p><p id="dddb" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果您在本例中删除<em class="mk"> pool.end() </em>，然后运行它，那么检查我们的线程数将会显示:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="a087" class="lh li jd ld b gy lj lk l ll lm">Threads_connected 2</span></pre><p id="0960" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是因为我们从来没有并行运行查询，由于<em class="mk"> await </em>正在等待查询在下一个查询之前完成，所以即使根据<em class="mk"> connectionLimit </em>的值它有多达 10 个可用的连接，池也不会使用一个以上的连接。</p><p id="501d" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果您再次添加<em class="mk"> pool.end() </em>并重新运行您的代码，而不重启 MySQL 服务器，那么检查我们的线程数将会显示:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="cfc3" class="lh li jd ld b gy lj lk l ll lm">Threads_connected 1</span></pre><p id="3962" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是因为池使用了仍然保持打开的旧连接，然后在完成后关闭它。</p><p id="3892" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">那么，如果我们从来不使用一个以上的同时连接，为什么还要使用一个池呢？</p><p id="a71e" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">那么，如果我们不只是手动调用 node.js 文件，或者设置一个调用它的 cron 作业，而是创建一个应该能够同时处理请求的 REST API 呢？</p><h2 id="dd3f" class="lh li jd bd ln lo lp dn lq lr ls dp lt kl lu lv lw kp lx ly lz kt ma mb mc md bi translated">当使用 http 服务器时</h2><p id="0e3c" class="pw-post-body-paragraph ka kb jd kc b kd me kf kg kh mf kj kk kl mg kn ko kp mh kr ks kt mi kv kw kx ig bi translated">让我们通过在 Node.js 中设置一个最小的 http 服务器来研究这个问题，如下所示:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="8589" class="lh li jd ld b gy lj lk l ll lm">const mysql = require(‘mysql2’);<br/>const http = require(‘http’);<br/>const pool = mysql<br/> .createPool({<br/>  host: ‘localhost’,<br/>  user: ‘root’,<br/>  connectionLimit: 10,<br/> })<br/>  .promise();<br/>const server = http.createServer((req, res) =&gt; {<br/>  if (req.method != ‘GET’ || req.url != ‘/’) {<br/>    // exclude all other request (to favicon.ico etc)<br/>    res.end();<br/>    return;<br/>  }<br/>  // console.log(req.method, req.url);<br/>  (async () =&gt; {<br/>    for (let i = 0; i &lt; 100; i++) {<br/>      let rows = await dbPool.execute('SELECT 1');<br/>    }<br/>    pool.end();<br/>  })();<br/>  res.end();<br/>});<br/>server.listen(3000);</span></pre><p id="478b" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们浏览一下代码，这样我们就知道这里发生了什么。在顶部，我们需要来自节点本地库的 http 对象。</p><p id="9274" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后我们创建我们的池，这样只要我们的服务器在运行，它就可以在所有请求中使用。</p><p id="0082" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后我们创建一个 http 服务器。我们在服务器“内部”做的第一件事是过滤掉不需要的请求——因为我们希望能够在普通浏览器中测试我们的代码，当我们加载页面时，浏览器可能会执行额外的请求(例如检查 favicon.ico 等),我们希望确保我们的代码在这种情况下只执行一次。</p><p id="8463" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">那么您可能会认出我们之前的代码(需要使用<em class="mk"> res.end() </em>部分来告诉 Node.js 结束请求)。</p><p id="3be5" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最后，我们确保监听端口 3000。</p><p id="cf70" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了启动我们的服务器，我们像以前一样，在命令行中运行:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="a757" class="lh li jd ld b gy lj lk l ll lm">node your-file-name.js</span></pre><p id="0936" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这将启动我们的服务器，并让它对请求开放。</p><p id="fd63" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果我们重启 MySQL 服务器，然后打开浏览器，进入<a class="ae ja" href="http://localhost:3000," rel="noopener ugc nofollow" target="_blank"> http://localhost:3000，</a>，然后检查我们的连接，我们会看到:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="bade" class="lh li jd ld b gy lj lk l ll lm">Threads_connected 1</span></pre><p id="1d8d" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所以我们没有留下任何联系，这很好。至少看起来是这样。但是，如果我们再次重新加载我们的网页，我们得到错误“池是关闭的”。这是因为我们在第一个请求结束时关闭了我们的池。一个网页当然会管理多个请求，所以在这种情况下，我们不应该关闭我们的池，因为我们创建了它，所以只要它在运行，它就应该对整个应用程序/服务器可用。</p><p id="499c" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，让我们删除 pool.end()，这将留给我们最后的代码:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="9377" class="lh li jd ld b gy lj lk l ll lm">const mysql = require(‘mysql2’);<br/>const http = require(‘http’);<br/>const pool = mysql<br/> .createPool({<br/>  host: ‘localhost’,<br/>  user: ‘root’,<br/>  connectionLimit: 10,<br/> })<br/>  .promise();<br/>const server = http.createServer((req, res) =&gt; {<br/>  if (req.method != ‘GET’ || req.url != ‘/’) {<br/>    // exclude all other request (to favicon.ico etc)<br/>    res.end();<br/>    return;<br/>  }<br/>  // console.log(req.method, req.url);<br/>  (async () =&gt; {<br/>    for (let i = 0; i &lt; 100; i++) {<br/>      let rows = await dbPool.execute('SELECT 1');<br/>    }<br/>  })();<br/>  res.end();<br/>});<br/>server.listen(3000);</span></pre><p id="b4c3" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果我们现在:</p><ol class=""><li id="0c24" class="ms mt jd kc b kd ke kh ki kl mu kp mv kt mw kx mx my mz na bi translated">关闭我们的节点服务器(在命令行按下<em class="mk"> CTRL + C </em></li><li id="8bd6" class="ms mt jd kc b kd nb kh nc kl nd kp ne kt nf kx mx my mz na bi translated">通过<em class="mk"> node your-file-name.js </em>再次启动我们的节点服务器</li></ol><p id="7c5a" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后，我们可以在浏览器中多次重新加载我们的网页，在我们的示例中，活动连接永远不会超过 2 个。如果您同时执行查询(而不是 async/await ),您将永远不会使用超过 10 个连接(就像我们的<em class="mk"> connectionLimit </em>中那样)打开 MySQL 服务器。</p><p id="f3cd" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这项研究到此为止。请在下面的评论中提出意见和批评，这样我们都可以改进。</p></div></div>    
</body>
</html>