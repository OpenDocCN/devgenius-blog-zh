<html>
<head>
<title>Fuzzing Tests with Golang</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 Golang 进行模糊测试</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/fuzzing-tests-with-golang-b3d5433bb9ef?source=collection_archive---------5-----------------------#2022-05-09">https://blog.devgenius.io/fuzzing-tests-with-golang-b3d5433bb9ef?source=collection_archive---------5-----------------------#2022-05-09</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/4eff58d7fb1f90defc783168f44bf60e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8hqAhqOiD6xjGwqPeYGhfA.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated"><a class="ae jz" href="http://networkbit.ch/golang-fuzzing/" rel="noopener ugc nofollow" target="_blank">http://networkbit.ch/golang-fuzzing/</a></figcaption></figure><p id="0861" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">模糊化是一种自动化测试，它不断操纵测试程序的输入，以发现代码可能易受影响的问题，如<em class="ky">混乱、错误或数据竞争</em>。这些半随机数据突变可以发现现有单元测试可能遗漏的新代码覆盖，以及可能未被检测到的边缘错误。</p><p id="5f1e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">模糊者通常可以找到单元测试遗漏的 bug，因为单元测试只包含开发人员输入的值，所以估计这些值会产生错误。这个程序已经被恐慌、失败的断言、无限循环等等所困扰。fuzzing 不是使用一个小的、预定义的手动创建的输入集(像单元测试)，而是不断地用新的案例测试代码，以努力锻炼有问题的软件的所有方面。</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="733a" class="li lj in le b gy lk ll l lm ln">// Test function for Unit testing<br/>TestCalculateHighest(t *testing.T){}</span><span id="3174" class="li lj in le b gy lo ll l lm ln">// Fuzz function for fuzzing testing<br/>FuzzTestHTTPHandler(f *testing.F) {}</span></pre><p id="8556" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Fuzzing 的重点不是取代传统的测试，而是通过随机迭代被测代码的输入值来补充它们。Fuzzing 对于发现安全漏洞和弱点特别有价值，因为它可能会达到人们经常忽略的极端。</p><figure class="kz la lb lc gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lp"><img src="../Images/c9baa3bd83c87cf27ed0c5d32852798f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3P_EHRUOTNqDPXesKleOZQ.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">模糊测试流程。(<a class="ae jz" href="https://medium.com/a-journey-with-go/go-fuzz-testing-in-go-deb36abc971f" rel="noopener">https://medium . com/a-journey-with-go/go-fuzz-testing-in-go-deb 36 ABC 971 f</a>)</figcaption></figure><h2 id="5bef" class="li lj in bd lq lr ls dn lt lu lv dp lw kl lx ly lz kp ma mb mc kt md me mf mg bi translated"><strong class="ak">起毛材料</strong></h2><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="ef8e" class="li lj in le b gy lk ll l lm ln"><strong class="le io">func</strong> FuzzIsPalindrome(f <strong class="le io">*</strong>testing<strong class="le io">.</strong>F) {<br/>     f<strong class="le io">.</strong>Add("kayak")                          // seed corpus<br/>     f<strong class="le io">.</strong>Fuzz(<strong class="le io">func</strong>(t <strong class="le io">*</strong>testing<strong class="le io">.</strong>T, str <strong class="le io">string</strong>) { // fuzz target<br/>          t1 <strong class="le io">:=</strong> IsPalindrome(str)            // func that be tested<br/>          t2 <strong class="le io">:=</strong> reverse(str) <strong class="le io">==</strong> str          // check to tested func<br/>          <strong class="le io">if</strong> t1 <strong class="le io">!=</strong> t2 {<br/>             t<strong class="le io">.</strong>Fail()<br/>          }<br/>     })<br/>}</span></pre><p id="eb8e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe mh mi mj le b">Seed Corpus</code>，你应该认为是样本数据。这是模糊器将使用的数据，并改变为尝试的新输入。种子应该尽可能地反映函数的输入应该是什么样子，以便从模糊测试中获得最佳结果。</p><p id="7744" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">添加种子是由接受以下数据类型的<code class="fe mh mi mj le b">f.Add()</code>完成的。</p><ul class=""><li id="4e24" class="mk ml in kc b kd ke kh ki kl mm kp mn kt mo kx mp mq mr ms bi translated">字符串，[]字节，符文</li><li id="5653" class="mk ml in kc b kd mt kh mu kl mv kp mw kt mx kx mp mq mr ms bi translated">int，int8，int16，int32，int64</li><li id="902e" class="mk ml in kc b kd mt kh mu kl mv kp mw kt mx kx mp mq mr ms bi translated">uint，uint8，unit16，uint32，uint64</li><li id="db64" class="mk ml in kc b kd mt kh mu kl mv kp mw kt mx kx mp mq mr ms bi translated">浮动 32，浮动 64</li><li id="bcb4" class="mk ml in kc b kd mt kh mu kl mv kp mw kt mx kx mp mq mr ms bi translated">弯曲件</li></ul><p id="c5f6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您可以添加许多样本数据条目，只需确保样本种子与您的函数输入参数的顺序相同。</p><p id="3629" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">是时候介绍<code class="fe mh mi mj le b">Fuzz Target</code>了。<strong class="kc io">模糊目标</strong>是为每个种子或生成的语料库条目执行的函数。开始模糊化时，<code class="fe mh mi mj le b">f.Fuzz()</code>功能作为输入给出。这个函数是<code class="fe mh mi mj le b">fuzz target</code>，它应该检查错误，并触发函数我们 fuzzing 准备数据。Fuzz 的输入函数必须接受<code class="fe mh mi mj le b">testing.T</code>作为第一个参数，随后是添加到语料库的输入数据类型<strong class="kc io"> <em class="ky">，顺序与</em> </strong>相同。</p><p id="c2ef" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">起毛和常规测试有点不同。<strong class="kc io"> <em class="ky">默认行为是一直运行，直到出现错误</em> </strong>，因此您应该取消模糊器或等到出现错误。还有第三个选项，在设定时间后通过添加<code class="fe mh mi mj le b">-fuzztime</code>标志取消。所以跑 10 秒钟你会跑。</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="2c92" class="li lj in le b gy lk ll l lm ln">go test --fuzz=Fuzz -fuzztime=10s</span></pre><p id="5736" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当模糊化过程中出现错误时，它将取消失败的输入参数，并将其写入文件。例如:<code class="fe mh mi mj le b">testdata\fuzz\NameOfYourFuzz\inputID</code>。<br/>该文件指出哪个输入字符串导致了错误(<code class="fe mh mi mj le b">string(“Ó”)</code>):</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="65bc" class="li lj in le b gy lk ll l lm ln">$ cat testdata/fuzz/FuzzIsPalindrome/b102348c25c69890607f026bc3186f5faf9de089188791a75c97daf5fdd10caa<br/>go test fuzz v1<br/>string("Ó")<br/>$</span></pre><p id="3af3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">通过使用<code class="fe mh mi mj le b">t.Skip(“skip reason”)</code>，你可以跳过不正确的情况，这在模糊时会很有用。</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="4485" class="li lj in le b gy lk ll l lm ln"><strong class="le io">func</strong> FuzzIsPalindrome(f <strong class="le io">*</strong>testing<strong class="le io">.</strong>F) {<br/>     f<strong class="le io">.</strong>Add("kayak")<br/>     f<strong class="le io">.</strong>Fuzz(<strong class="le io">func</strong>(t <strong class="le io">*</strong>testing<strong class="le io">.</strong>T, str <strong class="le io">string</strong>) {<br/>          t1, err <strong class="le io">:=</strong> IsPalindrome(str)<br/>          if <!-- -->errors.Is(err, ErrNotAnythingImpossible)<!-- --> {<br/>             t.Skip("Only correct requests are intresting")  <br/>          }</span><span id="8456" class="li lj in le b gy lo ll l lm ln">          t2 <strong class="le io">:=</strong> reverse(str) <strong class="le io">==</strong> str<br/>          <strong class="le io">if</strong> t1 <strong class="le io">!=</strong> t2 {<br/>             t<strong class="le io">.</strong>Fail()<br/>          }<br/>     })<br/>}</span></pre><p id="87cf" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这可能没有意义，它只是用来向<code class="fe mh mi mj le b">t.skip()</code>展示它是写在我们的示例代码上的。</p><p id="a97d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">可以根据失败的模糊测试的结果编写一个新的单元测试，这个新的<code class="fe mh mi mj le b">unit test</code>可以用来调试模糊测试发现的问题，并为<code class="fe mh mi mj le b">Continuous integration(CI)</code>强化它们。</p><p id="1ee8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">起毛是有效的。go-fuzz 已经在 Go   <code class="fe mh mi mj le b">stdlib</code>中发现了<strong class="kc io"> <em class="ky"> 200+个 bug，当时 Go</em><code class="fe mh mi mj le b">stdlib</code>已经很成熟，由非常有经验的开发者编写，并在生产中使用多年。Fuzzing 已在 Chrome  </strong>中发现<strong class="kc io"><em class="ky">15000+bug；1<strong class="kc io"><em class="ky">FFMpeg 库中 500+bug</em></strong>；还有成千上万的。一般来说，fuzzing 会在第一次应用的代码中发现错误。</em></strong></p><h2 id="8cb8" class="li lj in bd lq lr ls dn lt lu lv dp lw kl lx ly lz kp ma mb mc kt md me mf mg bi translated">逐步模糊化</h2><ol class=""><li id="b0ea" class="mk ml in kc b kd my kh mz kl na kp nb kt nc kx nd mq mr ms bi translated"><strong class="kc io"> <em class="ky">定义 fuzz arguments: </em> </strong>你至少需要给出一个<code class="fe mh mi mj le b">fuzzing argument</code>，否则<code class="fe mh mi mj le b">go fuzzing</code>无法生成测试代码，所以即使我们没有好的输入，也需要定义一个对结果有影响的<code class="fe mh mi mj le b">fuzzing argument</code>。</li><li id="fdc7" class="mk ml in kc b kd mt kh mu kl mv kp mw kt mx kx nd mq mr ms bi translated"><strong class="kc io"> <em class="ky">如何编写 fuzzing 目标:</em> </strong>这一步重点是编写一个可验证的<code class="fe mh mi mj le b">fuzzing target</code>，根据给定的<code class="fe mh mi mj le b">fuzzing arguments</code>编写测试代码，生成数据来验证结果的正确性。</li><li id="0525" class="mk ml in kc b kd mt kh mu kl mv kp mw kt mx kx nd mq mr ms bi translated"><strong class="kc io"> <em class="ky">失败案例如何打印输入:</em> </strong>如果我们能把输入打印出来，形成一个简单的测试用例，那么我们就可以直接调试了。</li><li id="3416" class="mk ml in kc b kd mt kh mu kl mv kp mw kt mx kx nd mq mr ms bi translated"><strong class="kc io"> <em class="ky">编写一个新的测试用例:</em> </strong>基于失败案例的输出，我们应该修正代码，并用那个失败案例再次测试。</li></ol><h2 id="ec7c" class="li lj in bd lq lr ls dn lt lu lv dp lw kl lx ly lz kp ma mb mc kt md me mf mg bi translated">结论</h2><ul class=""><li id="ae70" class="mk ml in kc b kd my kh mz kl na kp nb kt nc kx mp mq mr ms bi translated">模糊化适用于 Go 基本数据类型。</li><li id="a510" class="mk ml in kc b kd mt kh mu kl mv kp mw kt mx kx mp mq mr ms bi translated">Fuzzing 对于检测我们看不到或预测不到的错误很有用，即使你的常规测试有很好的覆盖率。</li><li id="6d0e" class="mk ml in kc b kd mt kh mu kl mv kp mw kt mx kx mp mq mr ms bi translated">可以基于以下方面来检测故障:错误、混乱、要检查的辅助函数、函数返回值的属性等。</li><li id="e02c" class="mk ml in kc b kd mt kh mu kl mv kp mw kt mx kx mp mq mr ms bi translated">Fuzzing 产生测试数据文件，这些文件由测试获得，并且将成为您的源代码的一部分，以防止将来的回归。</li><li id="4eb2" class="mk ml in kc b kd mt kh mu kl mv kp mw kt mx kx mp mq mr ms bi translated">模糊化是不确定的。但是美妙之处在于它帮助你丰富你的确定性测试。</li></ul><h2 id="a436" class="li lj in bd lq lr ls dn lt lu lv dp lw kl lx ly lz kp ma mb mc kt md me mf mg bi translated">作者</h2><p id="068d" class="pw-post-body-paragraph ka kb in kc b kd my kf kg kh mz kj kk kl ne kn ko kp nf kr ks kt ng kv kw kx ig bi translated">奥莰·奥扎欣</p><p id="a113" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">领英—【https://www.linkedin.com/in/okan%C3%B6z%C5%9Fahin/ T2】</p><p id="585a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">电子邮件—okan.ozsahin@innology.com</p><h2 id="845c" class="li lj in bd lq lr ls dn lt lu lv dp lw kl lx ly lz kp ma mb mc kt md me mf mg bi translated">资源</h2><div class="nh ni gp gr nj nk"><a href="https://go.googlesource.com/proposal/+/master/design/draft-fuzzing.md" rel="noopener  ugc nofollow" target="_blank"><div class="nl ab fo"><div class="nm ab nn cl cj no"><h2 class="bd io gy z fp np fr fs nq fu fw im bi translated">设计草稿:一级模糊化</h2><div class="nr l"><h3 class="bd b gy z fp np fr fs nq fu fw dk translated">作者:凯蒂·霍克曼·golang.org/s/draft-fuzzing-design 这是最初的设计草稿，不是正式的围棋提议…</h3></div><div class="ns l"><p class="bd b dl z fp np fr fs nq fu fw dk translated">go.googlesource.com</p></div></div></div></a></div><div class="nh ni gp gr nj nk"><a href="https://go.dev/doc/fuzz/#suggestions" rel="noopener  ugc nofollow" target="_blank"><div class="nl ab fo"><div class="nm ab nn cl cj no"><h2 class="bd io gy z fp np fr fs nq fu fw im bi translated">Go Fuzzing-Go 编程语言</h2><div class="nr l"><h3 class="bd b gy z fp np fr fs nq fu fw dk translated">从 Go 1.18 开始，Go 在其标准工具链中支持模糊化。OSS-模糊支持本地 Go 模糊测试。尝试…</h3></div><div class="ns l"><p class="bd b dl z fp np fr fs nq fu fw dk translated">go.dev</p></div></div><div class="nt l"><div class="nu l nv nw nx nt ny jt nk"/></div></div></a></div><div class="nh ni gp gr nj nk"><a href="https://go.dev/doc/tutorial/fuzz" rel="noopener  ugc nofollow" target="_blank"><div class="nl ab fo"><div class="nm ab nn cl cj no"><h2 class="bd io gy z fp np fr fs nq fu fw im bi translated">教程:fuzzing 入门——Go 编程语言</h2><div class="nr l"><h3 class="bd b gy z fp np fr fs nq fu fw dk translated">本教程介绍了围棋模糊化的基础知识。使用 fuzzing，随机数据会针对您的测试运行，以尝试…</h3></div><div class="ns l"><p class="bd b dl z fp np fr fs nq fu fw dk translated">go.dev</p></div></div><div class="nt l"><div class="nz l nv nw nx nt ny jt nk"/></div></div></a></div><div class="nh ni gp gr nj nk"><a href="https://towardsdatascience.com/fuzzing-tests-in-go-96eb08b7694d" rel="noopener follow" target="_blank"><div class="nl ab fo"><div class="nm ab nn cl cj no"><h2 class="bd io gy z fp np fr fs nq fu fw im bi translated">围棋模糊测试</h2><div class="nr l"><h3 class="bd b gy z fp np fr fs nq fu fw dk translated">模糊化是一种自动为函数生成输入值来查找 bug 的技术</h3></div><div class="ns l"><p class="bd b dl z fp np fr fs nq fu fw dk translated">towardsdatascience.com</p></div></div><div class="nt l"><div class="oa l nv nw nx nt ny jt nk"/></div></div></a></div><div class="nh ni gp gr nj nk"><a href="https://faun.pub/best-practices-for-go-fuzzing-in-go-1-18-84eab46b70d8" rel="noopener  ugc nofollow" target="_blank"><div class="nl ab fo"><div class="nm ab nn cl cj no"><h2 class="bd io gy z fp np fr fs nq fu fw im bi translated">我在 Go fuzzing 上的最佳实践</h2><div class="nr l"><h3 class="bd b gy z fp np fr fs nq fu fw dk translated">作为程序员，我们经常希望我们的代码没有 bug！但事实是无 bug 只能被反证，不能…</h3></div><div class="ns l"><p class="bd b dl z fp np fr fs nq fu fw dk translated">faun.pub</p></div></div><div class="nt l"><div class="ob l nv nw nx nt ny jt nk"/></div></div></a></div></div></div>    
</body>
</html>