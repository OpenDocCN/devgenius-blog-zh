<html>
<head>
<title>Redis 6 server-assisted client-side caching with Golang</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Redis 6 使用 Golang 进行服务器辅助的客户端缓存</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/redis-6-server-assisted-client-side-caching-with-golang-1238ca1ceba8?source=collection_archive---------2-----------------------#2022-01-22">https://blog.devgenius.io/redis-6-server-assisted-client-side-caching-with-golang-1238ca1ceba8?source=collection_archive---------2-----------------------#2022-01-22</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="64a5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">大多数人使用 Redis 作为远程缓存存储，因为它很快。</p><p id="64af" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">从用户的角度来看，Redis 6 可以通过消除不必要的网络往返使速度更快。</p></div><div class="ab cl ki kj hr kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="ig ih ii ij ik"><h1 id="122e" class="kp kq in bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">服务器辅助的客户端缓存</h1><p id="e87c" class="pw-post-body-paragraph jk jl in jm b jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ig bi translated">技术很简单。Redis 6 将跟踪客户机请求的键，并在键值改变时通知客户机。</p><p id="1f38" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，客户机现在可以重用响应，而无需通过网络咨询 Redis，直到收到相应的失效通知。这个新特性被称为服务器辅助客户端缓存。</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi ls"><img src="../Images/38ec6aa7879ff0f337fb8849098b0811.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*392vjdFxWwzXytzmw8xd0A.png"/></div></div><figcaption class="me mf gj gh gi mg mh bd b be z dk translated">更多详情:【https://redis.io/topics/client-side-caching】T4</figcaption></figure><p id="cdb5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">虽然这种技术很简单，但它需要升级到新的 RESP3 协议，或者在 RESP2 发布/订阅通道上做一些手脚来接收通知。对于现有的客户端库来说，这两个选项都不容易实现。</p><p id="90a5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">距离 2020 年 Redis 6 发布已经快两年了。我发现在现有的 Golang 客户端库上使用这个强大的新特性仍然很困难。因此，我决定自己创建一个新的客户端实现。</p></div><div class="ab cl ki kj hr kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="ig ih ii ij ik"><h1 id="2997" class="kp kq in bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">Rueidis:一个快速 Golang Redis RESP3 客户端</h1><div class="mj mk gp gr ml mm"><a href="https://github.com/rueian/rueidis" rel="noopener  ugc nofollow" target="_blank"><div class="mn ab fo"><div class="mo ab mp cl cj mq"><h2 class="bd io gy z fp mr fr fs ms fu fw im bi translated">GitHub - rueian/rueidis:一个快速的 Golang Redis RESP3 客户端，可以自动流水线化并支持…</h2><div class="mt l"><h3 class="bd b gy z fp mr fr fs ms fu fw dk translated">一个快速的 Golang Redis RESP3 客户端，支持自动流水线操作和客户端缓存。</h3></div><div class="mu l"><p class="bd b dl z fp mr fr fs ms fu fw dk translated">github.com</p></div></div><div class="mv l"><div class="mw l mx my mz mv na mc mm"/></div></div></a></div><p id="24b5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">由于 RESP3 和自动流水线技术的简单性。新的客户端库通常比现有的客户端库具有更高的吞吐量。以下是我的 Macbook M1 Pro 上的基准对比。</p><figure class="lt lu lv lw gt lx gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi nb"><img src="../Images/65da2a144b2669efa8417f7900ef67ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yv1oleYXGar29HL5ufYv8Q.png"/></div></div><figcaption class="me mf gj gh gi mg mh bd b be z dk translated">全基准源代码:<a class="ae mi" href="https://github.com/rueian/rueidis-benchmark" rel="noopener ugc nofollow" target="_blank">https://github.com/rueian/rueidis-benchmark</a></figcaption></figure><p id="13a2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果缓存命中，服务辅助的客户端缓存表现非常好，因为没有网络通信。在我的笔记本电脑上，从客户端的内存缓存中检索一条记录平均需要大约 165 纳秒。</p><p id="ca5b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">即使没有客户端缓存，新的库也可以在本地基准测试中实现比现有库高 14 倍的吞吐量。参见<code class="fe nc nd ne nf b">parallelism(64)-key(16)-value(64)-10</code>案例。</p></div><div class="ab cl ki kj hr kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="ig ih ii ij ik"><h1 id="b0ee" class="kp kq in bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">去找 github.com/rueian/rueidis</h1><p id="6021" class="pw-post-body-paragraph jk jl in jm b jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ig bi translated">下面是一个如何在新的客户端库中使用服务器辅助客户端缓存的示例:</p><figure class="lt lu lv lw gt lx"><div class="bz fp l di"><div class="ng nh l"/></div><figcaption class="me mf gj gh gi mg mh bd b be z dk translated">省略了错误处理</figcaption></figure><p id="010d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe nc nd ne nf b">DoCache()</code>该方法使用服务器辅助的客户端缓存，它有 3 个参数:</p><ol class=""><li id="5959" class="ni nj in jm b jn jo jr js jv nk jz nl kd nm kh nn no np nq bi translated">支持 OpenTelemetry 跟踪的上下文。</li><li id="e78f" class="ni nj in jm b jn nr jr ns jv nt jz nu kd nv kh nn no np nq bi translated">Redis 命令，应该从命令构建器<code class="fe nc nd ne nf b">client.B()</code>中构建。</li><li id="d707" class="ni nj in jm b jn nr jr ns jv nt jz nu kd nv kh nn no np nq bi translated">客户端 TTL 与<code class="fe nc nd ne nf b">PTTL</code>结合使用，以确保客户端的 TTL 不比 Redis 端的 TTL 长。</li></ol><p id="ce40" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">此外，用户可以使用<code class="fe nc nd ne nf b">IsCacheHit()</code>来检查响应是否来自客户端内存。</p><p id="5438" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果启用了 OpenTelemetry 集成，还有两个指标可供用户观察缓存命中率，分别是<code class="fe nc nd ne nf b">rueidis_do_cache_hits</code>和<code class="fe nc nd ne nf b">rueidis_do_cache_miss</code>。</p></div><div class="ab cl ki kj hr kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="ig ih ii ij ik"><p id="249f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Rueidis 还支持其他功能，如 Redis 集群、发布/订阅、流、Lua、事务。</p><p id="784b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">还支持流行的 Redis 模块。比如:RedisBloom，RedisJSON，RediSearch，RedisTimeseries。</p><p id="4da5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">鲁伊迪斯几个月前刚刚出生，但我会继续让它变得更好。反馈，问题报告，公关，明星都很感谢。谢了。</p></div></div>    
</body>
</html>