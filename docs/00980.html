<html>
<head>
<title>BrightFuture (Golang Implementation of Java Future Interface)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">bright Future(Java Future接口的Golang实现)</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/brightfuture-golang-implementation-of-java-future-interface-b6e4ed55037c?source=collection_archive---------12-----------------------#2020-06-21">https://blog.devgenius.io/brightfuture-golang-implementation-of-java-future-interface-b6e4ed55037c?source=collection_archive---------12-----------------------#2020-06-21</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="ef62" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> <em class="ki">声明:</em> </strong> <em class="ki">这是我第一篇关于medium.com的文章。我试图让它变得非常简单，处于任何学习阶段的人都可以从这篇文章中获得最大收益。我希望你喜欢这个，快乐阅读！</em></p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi kj"><img src="../Images/5c99a639475ba2dc450b0c1fbed4ed25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/0*0o_pTjy3ukl6NCuK.png"/></div></figure><p id="3da7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在本文中，我将介绍如何从Golang中的包<em class="ki"> java.util.concurrent </em>、<strong class="jm io"> Future、</strong>中复制非常著名的JAVA接口的行为。未来表示一个<em class="ki">异步</em>计算的结果。在创建一个异步任务后，我们返回一个Future对象来处理这个任务的结果。因此，我们的代码可以继续进一步执行，而不是等待任务完成。一旦任务完成，我们就可以访问计算的结果。</p><p id="345c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们将了解什么是异步计算，以及我们为什么需要它。接下来，我们将定义一个<strong class="jm io"> Future </strong>接口和一个<strong class="jm io"> FutureTask </strong>接口的结构，这两个接口实现了Golang中接口的主要方法。我们还会讲围棋<strong class="jm io"> </strong>套路和通道的妙处。<strong class="jm io">那么……我们开始吧！</strong></p></div><div class="ab cl kr ks hr kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ig ih ii ij ik"><h2 id="cea5" class="ky kz in bd la lb lc dn ld le lf dp lg jv lh li lj jz lk ll lm kd ln lo lp lq bi translated">什么是异步计算？</h2><p id="efcc" class="pw-post-body-paragraph jk jl in jm b jn lr jp jq jr ls jt ju jv lt jx jy jz lu kb kc kd lv kf kg kh ig bi translated">异步计算是并行计算的一种形式，它允许任务独立于主线程运行。为了形象化，让我们看看这个案例:</p><p id="180e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Lovish编写了一个单线程数字加法引擎，它将用户输入的整数流相加，并在每五秒钟后显示更新后的总和。由于该应用程序是单线程的，用户输入数字，每隔五秒钟，引擎就会接收所有输入的数字，并将它们添加到当前总和中，并显示结果“</p><p id="540c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">那么你能发现这台发动机的缺陷吗？<strong class="jm io"> <em class="ki">思考两分钟！</em>T25】</strong></p><p id="ef82" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们可以看到，当我们等待用户输入时，单线程的加法引擎不能进行上下文切换。现在，如果我们的引擎在一个单独的线程中运行，它可以在服务器等待用户输入(<strong class="jm io"> I/O调用</strong>)时异步计算sum<strong class="jm io"><em class="ki"/></strong>，这样我们就可以优化时间使用。这就是所谓的异步计算。</p><h2 id="397b" class="ky kz in bd la lb lc dn ld le lf dp lg jv lh li lj jz lk ll lm kd ln lo lp lq bi translated">定义未来的界面</h2><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="lw lx l"/></div></figure><ul class=""><li id="32fb" class="ly lz in jm b jn jo jr js jv ma jz mb kd mc kh md me mf mg bi translated"><strong class="jm io"> get() </strong>方法将完成后的<strong class="jm io">结果</strong>对象返回给异步任务。</li><li id="1f4c" class="ly lz in jm b jn mh jr mi jv mj jz mk kd ml kh md me mf mg bi translated"><strong class="jm io"> getWithTimeout(持续时间。Duration ) </strong>行为方式与get()方法相同，只是如果任务执行时间超过指定时间，调用会返回超时错误。</li><li id="00d9" class="ly lz in jm b jn mh jr mi jv mj jz mk kd ml kh md me mf mg bi translated"><strong class="jm io"> isComplete() </strong>返回一个指示任务状态的<em class="ki">布尔值</em>。</li><li id="bf91" class="ly lz in jm b jn mh jr mi jv mj jz mk kd ml kh md me mf mg bi translated"><strong class="jm io"> isCancelled() </strong>返回一个<em class="ki">布尔值</em>，表明任务是否在完成前被取消</li><li id="0b17" class="ly lz in jm b jn mh jr mi jv mj jz mk kd ml kh md me mf mg bi translated"><strong class="jm io"> cancel() </strong>试图取消任务的执行</li></ul><p id="f98e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ki"> ( </em> <strong class="jm io"> <em class="ki">注</em> </strong> <em class="ki">:如果在任务完成之前调用get()或getWithTimeout()方法，则该方法被阻塞)</em></p><h2 id="e5c6" class="ky kz in bd la lb lc dn ld le lf dp lg jv lh li lj jz lk ll lm kd ln lo lp lq bi translated">构建未来的任务</h2><p id="ed4d" class="pw-post-body-paragraph jk jl in jm b jn lr jp jq jr ls jt ju jv lt jx jy jz lu kb kc kd lv kf kg kh ig bi translated">现在我们已经定义了我们的<strong class="jm io">未来</strong>接口的行为，我们将定义一个未来任务，帮助我们模仿一个未来<strong class="jm io">；)</strong></p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="lw lx l"/></div></figure><ul class=""><li id="e4ed" class="ly lz in jm b jn jo jr js jv ma jz mb kd mc kh md me mf mg bi translated"><strong class="jm io">成功:</strong>适用于异步任务的成功</li><li id="96e9" class="ly lz in jm b jn mh jr mi jv mj jz mk kd ml kh md me mf mg bi translated"><strong class="jm io">完成:</strong>如果异步任务执行完成，则为真</li><li id="029b" class="ly lz in jm b jn mh jr mi jv mj jz mk kd ml kh md me mf mg bi translated"><strong class="jm io">错误</strong>:保存执行过程中遇到的错误(如果有)</li><li id="627d" class="ly lz in jm b jn mh jr mi jv mj jz mk kd ml kh md me mf mg bi translated"><strong class="jm io">结果</strong>:保存结果对象</li><li id="2105" class="ly lz in jm b jn mh jr mi jv mj jz mk kd ml kh md me mf mg bi translated"><strong class="jm io"> interfaceChannel </strong>:保存一个<strong class="jm io"> <em class="ki">只接收</em> </strong>的通道，等待<strong class="jm io">结果</strong></li></ul><h2 id="3426" class="ky kz in bd la lb lc dn ld le lf dp lg jv lh li lj jz lk ll lm kd ln lo lp lq bi translated">结果对象的结构</h2><p id="1a90" class="pw-post-body-paragraph jk jl in jm b jn lr jp jq jr ls jt ju jv lt jx jy jz lu kb kc kd lv kf kg kh ig bi translated">你们中的一些人可能会想，这个我们在这篇文章中提到过六次的<strong class="jm io">结果</strong>对象是什么？这就是:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="2af8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">它将我们任务的完整结果保存在两个变量中:<strong class="jm io"> resultValue </strong>和<strong class="jm io"> error。</strong>我们将继续定义自定义错误，敬请关注<strong class="jm io"> :) </strong></p></div><div class="ab cl kr ks hr kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ig ih ii ij ik"><h2 id="ae52" class="ky kz in bd la lb lc dn ld le lf dp lg jv lh li lj jz lk ll lm kd ln lo lp lq bi translated">履行</h2><p id="9d21" class="pw-post-body-paragraph jk jl in jm b jn lr jp jq jr ls jt ju jv lt jx jy jz lu kb kc kd lv kf kg kh ig bi translated">接下来，既然我们已经构建了代码来定义行为，现在是时候为该行为提供实现了。所以这将是一个有点重的代码段<strong class="jm io"> :'D </strong>。我们将从实现我们的<strong class="jm io">未来</strong>接口的两个最重要的方法开始。<strong class="jm io">是的！</strong>我们说的是<strong class="jm io"> get() </strong>和<strong class="jm io"> getWithTimeout()。我们来看看:</strong></p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="968b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们函数的大部分实现都在一个方法中，这个方法就是<strong class="jm io"> getWithContext() </strong>所以让我们看看它是关于什么的。我们使用来自<strong class="jm io"><em class="ki">【golang.org/x/net/context</em></strong>的<strong class="jm io"> <em class="ki">上下文</em> </strong>包来传递我们请求的上下文，并据此进行处理。</p><p id="f144" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">包上下文定义了上下文类型，其中<strong class="jm io">携带截止日期</strong>、<strong class="jm io">取消信号</strong>，以及其他跨API边界和进程间的请求范围值。我们正在利用这个包来定义一个在特定时间限制后自动超时的上下文(根据我们的<strong class="jm io"> getWithTimeout() </strong>传递的参数值<strong class="jm io"> timeout </strong>)。</p><p id="0cb8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ki"> ( </em> <strong class="jm io"> <em class="ki">注</em> </strong> <em class="ki">:要了解go中上下文的更多信息，</em> <a class="ae mm" href="https://godoc.org/golang.org/x/net/context" rel="noopener ugc nofollow" target="_blank"> <em class="ki">请参考此处</em> </a> <em class="ki"> ) </em></p><p id="67cc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">了解选择块:</strong></p><ul class=""><li id="ce2a" class="ly lz in jm b jn jo jr js jv ma jz mb kd mc kh md me mf mg bi translated"><strong class="jm io">案例← ctx。Done() : </strong>这个代码块在请求的上下文过期时执行。在这种情况下，我们将抛出一个超时错误，我们的resultValue将为零。</li><li id="a823" class="ly lz in jm b jn mh jr mi jv mj jz mk kd ml kh md me mf mg bi translated"><strong class="jm io">Case←future task . interfaceChannel():</strong>当我们的任务完成执行并在interface channel上发送结果对象时，就会执行这段代码。</li></ul><p id="0612" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在我们来看看我们的<strong class="jm io"> FutureTask </strong>实现的其余方法:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="9360" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> isComplete()、isCancelled()和cancel() </strong>方法的实现很容易理解。</p></div><div class="ab cl kr ks hr kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ig ih ii ij ik"><h2 id="8169" class="ky kz in bd la lb lc dn ld le lf dp lg jv lh li lj jz lk ll lm kd ln lo lp lq bi translated">让我们创造未来！</h2><p id="3f74" class="pw-post-body-paragraph jk jl in jm b jn lr jp jq jr ls jt ju jv lt jx jy jz lu kb kc kd lv kf kg kh ig bi translated">现在是时候创造未来，利用<strong class="jm io">围棋套路的力量了！</strong></p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="dfe3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">return future()</strong>返回对FutureTask对象的引用。那么，这个函数是如何工作的呢？让我们仔细看看。</p><p id="9daa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">该函数以任务为函数参数，分配一个通道<strong class="jm io"> channelForExecution </strong>用于接收我们的<em class="ki"> async </em>任务的结果，然后创建一个FutureTask对象。然后，我们启动一个go例程，该例程运行我们的任务并将结果返回给通道。</p><p id="6ef2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们知道<strong class="jm io"> <em class="ki"> go例程</em> </strong>是go运行时管理的轻量级线程。因此，当我们启动go例程时，它与我们的代码并发运行，没有任何阻塞，因此我们的任务将并发执行。这就是围棋套路的美妙之处！！</p><p id="d1ca" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下面是我们的<strong class="jm io"> main </strong>方法，其中我们创建了两个FutureTask(s ),并使用<strong class="jm io"> get() </strong>和<strong class="jm io"> getWithTimeout() </strong>方法检索它们的结果:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="8085" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在结束本文之前，让我们看一下我们为这个实现创建的自定义错误:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="84c5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们创建了两个错误<strong class="jm io"> TimeoutError </strong>和<strong class="jm io"> InterruptError </strong>，我们已经在方法的实现过程中使用了它们。注意，这两个错误都通过提供<strong class="jm io"> Error() </strong>方法的实现来实现错误接口。</p></div><div class="ab cl kr ks hr kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ig ih ii ij ik"><h2 id="d133" class="ky kz in bd la lb lc dn ld le lf dp lg jv lh li lj jz lk ll lm kd ln lo lp lq bi translated">结论</h2><p id="1acd" class="pw-post-body-paragraph jk jl in jm b jn lr jp jq jr ls jt ju jv lt jx jy jz lu kb kc kd lv kf kg kh ig bi translated">所以，如果你已经做到了，祝贺你！现在你知道如何使用Golang从JAVA模仿未来接口了。这就是并发编程在Golang中最基本的样子，现在我们准备在此基础上进行构建。</p><p id="9b5d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">希望你喜欢这篇文章。请提供您的意见和评论。</p><p id="a270" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">要查看完整的代码，请查看我的github库<a class="ae mm" href="https://github.com/dart-vinay/BrightFuture" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><p id="a050" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">感谢阅读！</p><p id="ac4f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> <em class="ki">干杯！</em> </strong></p></div></div>    
</body>
</html>