<html>
<head>
<title>My First Data Structure: A very basic guide to Trees</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我的第一个数据结构:树的基本指南</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/my-first-data-structure-a-very-basic-guide-to-trees-f89c3e307195?source=collection_archive---------28-----------------------#2020-07-07">https://blog.devgenius.io/my-first-data-structure-a-very-basic-guide-to-trees-f89c3e307195?source=collection_archive---------28-----------------------#2020-07-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="c164" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">老实说:尽管这篇文章的名字是树，但树绝对不是我的第一个数据结构。也不应该是你的。然而，我将保持我的帖子的标题不变，以向您保证树绝对是一种像我们这样的初学者能够自己理解和实现的数据结构。话虽如此，我仍然建议在深入研究之前查看一下<a class="ae km" href="https://medium.com/@hopegiometti/my-first-data-structure-linked-lists-b2151538d0ce" rel="noopener">我在链表</a>上的帖子。</p><p id="2b4c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">既然我们已经解决了这个小小的免责声明，让我们直接开始吧！</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="ks kt l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">鲍勃·罗斯画树</figcaption></figure><p id="ea05" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">一(非常)基本概述</strong></p><p id="bd27" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">树是一种数据结构。</p><p id="9ea6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">什么？太基础？</p><p id="546c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好吧，让我再试一次。树是一种分层数据结构，它是单线的，以根开始，并有递减的子节点。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi ky"><img src="../Images/0564e9b2722914e3d964f9c41c8deff7.png" data-original-src="https://miro.medium.com/v2/resize:fit:440/format:webp/1*E0Skpz9baJXKsj2nWsUPWw.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">树形图</figcaption></figure><p id="5026" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如上图所示，树的根是 2，它的下行子节点是 7 和 5，它们又有自己的子节点，这些子节点又有自己的子节点，依此类推。</p><p id="3e8c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这可能看起来不太复杂，也不应该太复杂。这种类型的下降结构是你最熟悉的，并且可能每天都在使用。以你电脑上的文件为例。你会有一个像“文档”这样的文件夹，在这个文件夹里你可能会有更多的像“编码笔记”或“完全随机”这样的文件夹，在每个文件夹里你可能会有更多的文件夹等等。</p><p id="6150" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">二叉树</strong></p><p id="ab59" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在你已经对树的结构有了基本的了解，让我们来看看一种非常常见的树:二叉树。</p><p id="ca03" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要创建一个二叉树，我们必须遵循两个特定的规则。首先，每个节点最多可以有<em class="kl">和</em>两个子节点。第二，每个孩子只有一个父母。</p><p id="fd4a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">再看一下上面的图表。是二叉树吗？</p><p id="b0be" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然我们图中的树遵循我们的第二条规则(每个子节点只有一个父节点)，但它不遵循我们的第一条规则。值为 7 的节点有三个子节点，因此打破了只允许两个子节点的二叉树规则。</p><p id="da41" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是一个二叉树<em class="kl">如何能看起来像</em>的例子:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi lb"><img src="../Images/eebdf4063be9786ba9046f9c11a3581a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1376/format:webp/1*nF3uACmUN5fRdChA2dZ_PA.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">一棵完美的二叉树！</figcaption></figure><p id="3ad6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此图是我们称之为完美二叉树的一个例子，这意味着所有内部节点(也就是所有节点减去根节点和最低级别的节点)都有两个子节点，并且所有叶子都具有相同的深度/级别。完美的二叉树非常高效，并且具有一些对开发人员有用的属性。</p><p id="093f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">二分搜索法树</strong></p><p id="62ed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">二分搜索法树也可以被称为有序或排序二叉树，这对于它们的工作方式是有意义的。看一下这张图，看看你能否弄清楚 BST 是如何工作的:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi lc"><img src="../Images/25c714d3dbe90f8e4d806290deb86482.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/format:webp/1*PoNm6TxigbXLiEX31Winpg.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">二叉查找树</figcaption></figure><p id="51e5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们从树的顶端开始。在根节点 8 的左侧，我们可以看到子节点 3。在右边，我们可以看到子节点 10。现在，让我们再看一遍，但是这次从我们的子节点 3 开始。在左边，我们看到 1 的子节点。在右边，我们看到 6。你看出模式了吗？</p><p id="c7fb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">基本上，二叉查找树的规则是树中根节点右边的所有子节点必须大于当前节点，左边的所有子节点必须小于当前节点。</p><p id="0d88" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通常，二分搜索法树是一种非常有用的数据结构，因为它们通常比 O(n)*运行得更快，它们是有序的，并且它们具有灵活的大小。例如，与数组相比，BST 查找要快得多，因为与 O(n)相比，它通常需要 O(log N)。类似地，与哈希表相比，BST 是有序的，并且具有保留的关系。</p><p id="23c0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">*虽然 BST 很棒，可以被认为是非常有效和有用的数据结构，但它们确实有可能变得不平衡:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi ld"><img src="../Images/f46b02b6c42c4742b2b3fd8e894c0b7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1284/format:webp/1*YCWEjg515gqAjFojHioZ8Q.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">平衡树与不平衡树</figcaption></figure><p id="9a2f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你看一下不平衡二叉树，你可能会想起另一种数据结构:链表。链表实际上被认为是树，但与其他树不同，它们只有一条路径。此外，如果您熟悉链表，那么您可能会理解为什么 BST 会遇到一些运行时问题，因为许多链表操作的运行时为 O(n)。然而，最终有很多方法可以平衡树，使得不平衡的树的问题最小化。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="le kt l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">绘画和编码的好座右铭！</figcaption></figure><p id="fbb8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我希望您喜欢这个非常基本的树数据结构介绍。如果你很想看看树是如何工作的，你可以马上回来看看我自己实现的二叉查找树，或者试着自己实现一个！就像我一直说的，学习算法和数据结构最好的方法就是练习，所以请试一试！</p><p id="dac2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">祝你好运，编码愉快！</p></div></div>    
</body>
</html>