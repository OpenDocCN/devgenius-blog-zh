<html>
<head>
<title>Redis Topologies</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Redis拓扑</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/redis-topologies-d9e16a7fa8e0?source=collection_archive---------0-----------------------#2020-09-01">https://blog.devgenius.io/redis-topologies-d9e16a7fa8e0?source=collection_archive---------0-----------------------#2020-09-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="9e62" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Redis是一个开源的内存数据结构存储库，是现代架构中非常重要的一部分。在少数情况下，它被用作更一般的数据存储，但在缓存技术领域，它是一个明显的赢家</p><p id="00fe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Lyft最近分享了他们2020年Redis工作负载的更新数字(<a class="ae kl" href="https://www.youtube.com/watch?v=b9SiLhF9GaU" rel="noopener ugc nofollow" target="_blank"> youtube视频</a>):</p><ul class=""><li id="0902" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk kr ks kt ku bi translated">171个集群</li><li id="7b3e" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">大约3，600个实例</li><li id="8104" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">高峰时6500万QPS</li></ul><p id="750d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">令人印象深刻的是，Redis生态系统在核心技术保持简单的情况下发展了多少。Redis的创始人Salvatore Sanfilippo功不可没。</p><p id="6c39" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最小核心为设置场景的变化留下了很大的空间，在本文的范围内，我们将回顾不同的拓扑，每种拓扑都有自己的高可用性和数据安全特性。</p><p id="21ee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这篇文章是介绍性的。如果你对Redis非常有经验，你不会发现太多的新材料。但是如果你是新手，它可以帮助你浏览各种设置场景，这样你就可以更深入地了解。这也将为今后关于这一主题的写作奠定基础</p><h1 id="c579" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">复制设置</h1><figure class="lz ma mb mc gt md gh gi paragraph-image"><div class="gh gi ly"><img src="../Images/6c4cb188db2780aa06d7199c58fdf676.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/1*X3gonm-S-00QDBant1FjGA.jpeg"/></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk translated">Redis基本复制设置</figcaption></figure><p id="10f8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://redis.io/topics/replication" rel="noopener ugc nofollow" target="_blank"> Redis复制指南</a></p><p id="a475" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是一个非常简单的设置。有一个主服务器和一个或多个副本服务器。副本试图维护存储在主节点中的数据的精确副本</p><p id="7a48" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Redis复制是异步和非阻塞的。这意味着主机将继续处理传入的命令，因此对性能的潜在影响非常小</p><p id="8a20" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">好处:</strong></p><ul class=""><li id="b693" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk kr ks kt ku bi translated"><strong class="jp ir">提高了数据安全性</strong>，因此，如果一个主节点发生故障，您仍然可以在其他节点上保存数据</li><li id="b834" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated"><strong class="jp ir">读取可扩展性</strong>。您可以将读取工作负载分配给副本。但是请记住，在这种设置中没有一致性保证。(对于某些工作负载来说完全可以)</li><li id="128d" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated"><strong class="jp ir">*主机上的高性能/低延迟</strong>。通过这种设置，可以关闭主服务器上的磁盘持久性。但是要非常小心，并且阅读官方文件。(至少禁用自动重启)</li></ul><p id="e067" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然这种设置简单明了，但也有不足之处:</p><ul class=""><li id="ab6f" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk kr ks kt ku bi translated">不提供高可用性！！！</li><li id="ef0c" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">客户端应该知道拓扑结构，以获得读取可伸缩性。他们需要了解在哪里进行读写操作</li></ul><p id="4a98" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您没有知道将流量路由到哪里的智能客户端，HAProxy有一个非常旧的设置:</p><figure class="lz ma mb mc gt md"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="6f96" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它使用健康检查机制来ping Redis节点，以便它可以识别主节点并将流量定向到它</p><h1 id="4e74" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">雷迪斯哨兵报</h1><p id="4977" class="pw-post-body-paragraph jn jo iq jp b jq mm js jt ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk ij bi translated"><a class="ae kl" href="https://redis.io/topics/sentinel" rel="noopener ugc nofollow" target="_blank"> Redis哨兵指南</a></p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi mr"><img src="../Images/01bf91665e63a2ff55c10638d9076513.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LowXZQO-o-ieOSn956UfOw.jpeg"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk translated">Redis Sentinel设置</figcaption></figure><p id="f073" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Redis Sentinel建立在复制基础上，无需人工干预即可为Redis提供高可用性。</p><p id="37e2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Sentinel不断监视主服务器和副本服务器，并检查它们是否按预期工作。如果出现问题，它可以运行自动故障转移并提升不同的主节点。</p><p id="1977" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">除此之外，Sentinel还充当连接客户端的配置提供者(服务发现)。在故障转移过程中，客户端将获得主节点的更新地址。</p><p id="847d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">建议设置包括多个sentinel节点，因此，如果其中一些节点关闭，则具有容错特性。</p><p id="15c4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">哨兵节点合作，以便就集群的状态达成一致(例如，在检测到故障的情况下做什么)。</p><p id="de0b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">sentinel配置示例(sentinel.conf):</p><pre class="lz ma mb mc gt mw mx my mz aw na bi"><span id="486d" class="nb lb iq mx b gy nc nd l ne nf">sentinel monitor mymaster 127.0.0.1 6379 2<br/>sentinel down-after-milliseconds mymaster 60000<br/>sentinel failover-timeout mymaster 180000<br/>sentinel parallel-syncs mymaster 1</span></pre><p id="9b08" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在那里，它声明了一个哨兵节点监视具有法定人数<code class="fe ng nh ni mx b">2</code>的名为<code class="fe ng nh ni mx b">mymaster</code>的组</p><pre class="lz ma mb mc gt mw mx my mz aw na bi"><span id="907d" class="nb lb iq mx b gy nc nd l ne nf">sentinel monitor &lt;master-group-name&gt; &lt;ip&gt; &lt;port&gt; &lt;quorum&gt;</span></pre><p id="2bb4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不需要指定副本，它们将通过自动发现来识别。</p><p id="33d5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">好处</strong></p><ul class=""><li id="0406" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk kr ks kt ku bi translated"><strong class="jp ir">高可用性。</strong>该设置建立在Redis复制之上，支持自动故障转移</li><li id="df25" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">服务发现。Sentinels充当客户端的配置提供者，使它们能够感知拓扑</li></ul><p id="d657" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">缺陷</strong></p><ul class=""><li id="34c5" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk kr ks kt ku bi translated">通常，这种设置涉及许多具有不同角色的节点。(例如，5个节点:主节点、副本节点、3个哨兵节点)。因此，它带来了极大的复杂性，同时所有的写操作仍然指向单个主机</li><li id="b482" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">客户端驱动程序负责加载并实现Sentinel设置的路由机制。不是所有的司机都支持这一点</li></ul><h1 id="e27c" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">Redis集群</h1><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi nj"><img src="../Images/f8cf09478c88819c30154503319f3614.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*MVw2DrF8ZnOX-Irq.png"/></div></div></figure><p id="8f4f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是事情变得越来越有趣的地方。Redis集群于2015年推出，从3.0版本开始。它是第一个开箱即用的Redis体系结构，允许写入可伸缩性</p><p id="ada8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">亮点</strong>:</p><ul class=""><li id="de5d" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk kr ks kt ku bi translated">水平可伸缩。添加更多节点会增加容量</li><li id="3436" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">数据会自动分片</li><li id="ae41" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">容错的</li></ul><p id="8421" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了分发数据Redis集群有<strong class="jp ir">哈希槽</strong>的概念。总共有16384个哈希槽，集群中的每个节点负责其中的一个子集</p><p id="a584" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，当发送针对给定密钥的请求时，客户端会为该密钥计算一个哈希槽，并将其发送到适当的服务器。这意味着Redis集群客户端实现必须支持集群:</p><ul class=""><li id="3fb0" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk kr ks kt ku bi translated">定期更新哈希槽</li><li id="d95c" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">自己处理重定向(在集群拓扑发生变化和集群插槽暂时不同步的情况下)</li></ul><p id="be36" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">好处:</strong></p><ul class=""><li id="ac22" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk kr ks kt ku bi translated">更简单的操作(更少的移动部件)</li><li id="9c53" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">开箱即用的高可用性</li><li id="149f" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">水平可扩展性</li></ul><p id="bdac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">不足之处:</strong></p><ul class=""><li id="8a3b" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk kr ks kt ku bi translated">客户端需要更加复杂，并且自己同步集群状态</li><li id="2570" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">关于多键操作处理的警告(因为数据可能位于不同的节点上)</li></ul><p id="5c8b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Box的Ryan Luecke有一个关于迁移到Redis集群的很好的演讲(<a class="ae kl" href="https://www.youtube.com/watch?v=NymIgA7Wa78" rel="noopener ugc nofollow" target="_blank"> youtube视频</a>)。</p><h1 id="1f75" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">redis[单机版]带特使</h1><p id="ee5c" class="pw-post-body-paragraph jn jo iq jp b jq mm js jt ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk ij bi translated">(或旧时代的Twemproxy)</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi nk"><img src="../Images/4f54cf4971db00f29ec6523bdbef61d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KsFXli9mgeRHEVNhbrhKSQ.jpeg"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk translated">Redis与特使代理</figcaption></figure><p id="acd5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">(特使代理<a class="ae kl" href="https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/other_protocols/redis" rel="noopener ugc nofollow" target="_blank"> doc </a></p><p id="3849" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是我们在Whisk(【https://whisk.com】T4)运行的设置。我们非常喜欢它的操作简单性和良好的容错特性。</p><p id="06e2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，如果您计划将Redis用作持久性数据存储，这种设置并不合适，但它非常适合缓存，甚至对于速率限制之类的特性也足够好了</p><p id="0623" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我推荐看Lyft的视频(<a class="ae kl" href="https://www.youtube.com/watch?v=U4WspAKekqM" rel="noopener ugc nofollow" target="_blank"> youtube链接</a>)，因为它很好地解释了这个概念。</p><p id="ab34" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个想法和设置非常简单:</p><ul class=""><li id="7f33" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk kr ks kt ku bi translated">您有一堆独立的Redis节点，它们之间互不了解</li><li id="d329" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">在它们前面有一组特使代理，它们知道如何分配流量(一个键和一个Redis节点的关联)</li></ul><p id="74b0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这使您的操作非常简单。您的客户端可以将流量路由到任何特使节点，它将得到处理。在这种设置中，很容易容忍任何Redis或Envoy节点出现故障。在“Redis作为缓存”的场景中，最糟糕的事情是您需要重新计算一个键的值。</p><p id="d539" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于我们的特使代理在Kubernetes上运行，靠近应用程序服务，我们有一个非常可靠和快速的设置。几乎没有遇到任何问题</p><p id="98da" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Envoy执行<strong class="jp ir">基于散列的分区</strong>，在初始化或拓扑变化期间，Envoy为每个Redis节点计算并关联一个整数值。然后，当一个请求到来时，它将它的键散列为一个整数，并找到与之最匹配的节点</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/acfd4d28eb21d88969768d88528fd519.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/0*1jNmTGo6p61Fr15d"/></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk translated">图片来自Lyft演示:<a class="ae kl" href="https://www.slideshare.net/RedisLabs/redisconf18-2000-instances-and-beyond" rel="noopener ugc nofollow" target="_blank">https://www . slide share . net/redis labs/redis conf 18-2000-instances-and-beyond</a></figcaption></figure><p id="1dfe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">好处:</strong></p><ul class=""><li id="2ace" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk kr ks kt ku bi translated"><strong class="jp ir">操作简单。</strong>非常易于设置和维护。更少的移动部件</li><li id="dc25" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated"><strong class="jp ir">容错</strong>。您可以丢失/替换任何节点，影响极小</li><li id="f316" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated"><strong class="jp ir">水平可扩展性</strong>。横向扩展和添加更多服务器时几乎没有开销</li><li id="833f" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated"><strong class="jp ir">简单客户</strong>。只有负载平衡或良好可靠的连接到特使是必要的</li><li id="8d34" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated"><strong class="jp ir">曝光指标</strong>开箱</li></ul><p id="835a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">限制</strong></p><ul class=""><li id="81de" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk kr ks kt ku bi translated">仅适用于可能丢失一小部分数据是可以接受的特定使用情形(例如缓存)</li></ul><h1 id="6d09" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">摘要</h1><p id="9e2e" class="pw-post-body-paragraph jn jo iq jp b jq mm js jt ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk ij bi translated">我们概述了一些基本的Redis拓扑，每种都有不同的特征。各有利弊。这取决于你的场景。</p><p id="f58c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是如果你的场景是关于“尽力而为的缓存”，那么我强烈建议你考虑用Envoy来设置。否则，如果您需要数据的安全保证，Redis集群可能是一个不错的选择，它已经足够成熟，并且有成功的案例研究。</p><p id="e359" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在未来的一些文章中，我们可能会更深入地研究我们在Whisk上运行的Envoy设置，并且可能会考虑不同JVM驱动程序的一些性能比较。</p><h1 id="d88d" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">资源</h1><ul class=""><li id="766c" class="km kn iq jp b jq mm ju mn jy nm kc nn kg no kk kr ks kt ku bi translated">Redis复制指南—<a class="ae kl" href="https://redis.io/topics/replication" rel="noopener ugc nofollow" target="_blank">https://redis.io/topics/replication</a></li><li id="d905" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">Redis哨兵指南—【https://redis.io/topics/sentinel T2】</li><li id="7f96" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">瑞恩·吕克的《雷迪斯集群》——【https://www.youtube.com/watch?v=NymIgA7Wa78 T4】</li><li id="252a" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">红色集群图图里亚尔—<a class="ae kl" href="https://redis.io/topics/cluster-tutorial" rel="noopener ugc nofollow" target="_blank">https://redis.io/topics/cluster-tutorial</a></li><li id="348d" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">Lyft的Redis +特使—<a class="ae kl" href="https://www.youtube.com/watch?v=U4WspAKekqM" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=U4WspAKekqM</a></li><li id="d3cf" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">envoy Proxy Redis doc—<a class="ae kl" href="https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/other_protocols/redis" rel="noopener ugc nofollow" target="_blank">https://www . envoy Proxy . io/docs/envoy/latest/intro/arch _ overview/other _ protocols/Redis</a></li></ul></div></div>    
</body>
</html>