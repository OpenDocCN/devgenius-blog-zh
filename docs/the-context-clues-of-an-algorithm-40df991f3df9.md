# 算法的上下文线索

> 原文：<https://blog.devgenius.io/the-context-clues-of-an-algorithm-40df991f3df9?source=collection_archive---------8----------------------->

![](img/1d900981df67447ede8aebe038dff958.png)

安德烈斯·西蒙在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄的照片

我最近从我的编码挑战中学到的一个艰难的教训是，更多地关注描述中的上下文线索，而不是测试用例。

我认为一个全新的程序员在做他们的第一个编码挑战时，会很高兴看到这个问题只有两个测试用例，而且都很简单。现在我已经完成了几项挑战，没有比这更糟糕的了。当编码挑战自动化和虚拟化时，这真的只是一个问题，因为当你看到这样简单的测试用例时，它留给你许多问题，没有人来回答它们。我总是被赋予诸如 0

当一个问题从满足其约束的输入中寻求最大或最小解时，它通常利用贪婪算法，并寻找最优解。与此相关的常见算法包括硬币找零问题和效率问题，在硬币找零问题中，您必须找到最少的硬币才能达到某个值。效率问题通常有不同的主题，但是通常给你两个数组，分别表示事件的到达时间和停留时间，你必须找出没有重叠的情况下可以发生的事件的最大数量。这是我一次又一次遇到的问题，如果你正在接受编码挑战，我建议你练习一下。这些都是寻找最优解的问题，可以通过贪婪算法来解决。硬币兑换解决方案的示例如下:

需要注意的是，如果一个算法可以用贪婪方法求解，并不意味着它就是最佳解。

算法中出现的另一个上下文线索是“方法的数量”。这实际上是我写这篇博客的灵感，因为我非常失望，我错过了我练习了这么多的东西。如果一个问题要求你返回一个值可以达到或被操作的“方式的数量”,很有可能，解决算法的一个关键方面是斐波那契数列。提醒一下，斐波纳契数列通过将 n-1 和 n-2 的值相加来求解 n 的值。理解顺序不仅重要，还必须知道何时需要实现它。涉及这一序列的常见问题包括确定到达第 n 步的方法的数量，以及找到将整数解码为字符的方法的数量。让我们解决第二个问题。Numbers 可以对字母字符进行解码，如下所示:1 = A，2 =B… 26 = Z。返回给定数字输入字符串的解码方式的数量，例如。12 => 2，因为 1，2 = AB 或 12 = L。

正如你从第 9 行到第 18 行看到的，我们正在实现一个动态编程解决方案，包括一个带有制表的斐波那契风格的序列。奇怪的是，如果一个数字是 1 或 2，并且后面的数字小于 7，它可以解码 2 个不同的字符。如果你需要重温斐波那契的概念，请阅读我的博客文章[这里](https://medium.com/dev-genius/an-introduction-to-dynamic-programming-through-the-fibonacci-sequence-memoization-and-tabulation-67a8624be61a)。

![](img/67438d04b9434767c525106575886c52.png)

由[马库斯·温克勒](https://unsplash.com/@markuswinkler?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄

有很多其他的上下文线索可以帮助你解决一个算法，它们可以构成一个详尽的列表。事实是，正如你将在其他地方看到的那样，这需要练习。这并不意味着你应该去解决一千个 leetcode 问题，但更重要的是，研究你尝试的问题，寻找上下文线索和问题之间的相似性。给你一个排序的数组吗？如果有，为什么？是因为你需要分而治之，利用二分搜索法吗？你需要操作或反转一个字符串吗？两个指针会有帮助吗？如果有，你应该在开始和结束各有一个指针，还是需要使用滑动窗口？一旦你能根据上下文线索推断出你需要使用的方法，求解算法就会容易得多。