<html>
<head>
<title>Best of Modern JavaScript — Class Checks and Instantiation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">现代JavaScript的精华—类检查和实例化</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/best-of-modern-javascript-class-checks-and-instantiation-f36d441f37d0?source=collection_archive---------12-----------------------#2020-10-22">https://blog.devgenius.io/best-of-modern-javascript-class-checks-and-instantiation-f36d441f37d0?source=collection_archive---------12-----------------------#2020-10-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/0000790108f3611c6019a16400732819.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*G54liaD3Y7vavOY7"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">蒂姆·多弗勒在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="a8cd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">自2015年以来，JavaScript有了巨大的进步。</p><p id="c894" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在用起来比以前舒服多了。</p><p id="193a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将看看如何用JavaScript定义类。</p><h1 id="d142" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">课程详细信息</h1><p id="fe3b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">上课有很多细节。</p><p id="77d0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们扩展的值可以是任意的表达式。</p><p id="5c00" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以扩展一个调用函数产生的类:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="6f55" class="mn lc iq mj b gy mo mp l mq mr">class Foo extends combine(Foo, Bar) {}</span></pre><h1 id="9f0b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">检查</h1><p id="b36c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">当我们创建类时，JavaScript解释器会做一些检查。</p><p id="51a9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">类名不能是<code class="fe ms mt mu mj b">eval</code>或<code class="fe ms mt mu mj b">arguments</code>。</p><p id="7f91" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不允许重复的类名。</p><p id="cd38" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">名称<code class="fe ms mt mu mj b">constructor</code>可以用于普通方法，而不能用于getters、setters或generator方法。</p><p id="da32" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">类不能作为函数调用。</p><p id="e82e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果这样做，将会抛出一个TypeError。</p><p id="b816" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">原型方法不能用作构造函数。</p><p id="1f38" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们不能写这样的东西:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="8655" class="mn lc iq mj b gy mo mp l mq mr">class Foo {<br/>  bar() {}<br/>}</span><span id="f3d3" class="mn lc iq mj b gy mv mp l mq mr">new Foo.prototype.bar();</span></pre><p id="3af1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们运行它，我们将得到“未捕获的类型错误:Foo.prototype.bar不是构造函数”错误。</p><h1 id="fa35" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">属性描述符</h1><p id="f211" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">一个类<code class="fe ms mt mu mj b">Bar</code>的静态属性是可写和可配置的，但不是无数的。</p><p id="de0d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">Bar.prototype</code>不可写、不可枚举、不可配置。</p><p id="62f5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">Bar.prototype.constructor</code>不可写也不可枚举，但可以配置。</p><p id="2953" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">Bar.prototype</code>的属性是可写和可配置的，但不可枚举。</p><p id="1152" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这意味着我们可以动态更新许多属性。</p><h1 id="afe9" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">类有内部名称</h1><p id="df37" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">一个类有自己的<code class="fe ms mt mu mj b">name</code>属性来返回它的内部名称。</p><p id="4d2b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它的名字也可以用在类本身中。</p><p id="ec27" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="badc" class="mn lc iq mj b gy mo mp l mq mr">class Foo {<br/>  bar() {<br/>    console.log(Foo.baz);<br/>  }<br/>}</span><span id="6661" class="mn lc iq mj b gy mv mp l mq mr">Foo.baz = 1;</span></pre><p id="d998" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们引用了<code class="fe ms mt mu mj b">Foo</code>来获取静态属性。</p><p id="f52e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">即使我们将类赋给一个变量，也是如此。</p><p id="1fc9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="ef91" class="mn lc iq mj b gy mo mp l mq mr">const Bar = class Foo {<br/>  bar() {<br/>    console.log(Foo.baz);<br/>  }<br/>}</span><span id="fc57" class="mn lc iq mj b gy mv mp l mq mr">Bar.baz = 1;</span><span id="4369" class="mn lc iq mj b gy mv mp l mq mr">new Bar().bar();</span></pre><p id="acc1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么<code class="fe ms mt mu mj b">bar</code>方法调用仍然记录1。</p><p id="a00b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这意味着我们可以在内部引用它的原始名称。</p><h1 id="3970" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">子类</h1><p id="38a2" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们通过使用<code class="fe ms mt mu mj b">extends</code>关键字来创建子类。</p><p id="728b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于静态方法，它们由子类直接继承。</p><p id="2cbc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="5932" class="mn lc iq mj b gy mo mp l mq mr">class Person {<br/>  static logName() {<br/>    console.log(Person.name)<br/>  }<br/>}</span><span id="6bb5" class="mn lc iq mj b gy mv mp l mq mr">class Employee extends Person {</span><span id="f1ad" class="mn lc iq mj b gy mv mp l mq mr">}</span><span id="5db2" class="mn lc iq mj b gy mv mp l mq mr">console.log(Person.logName === Employee.logName)</span></pre><p id="f74f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后控制台日志会记录<code class="fe ms mt mu mj b">true</code>。</p><p id="7bd3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JavaScript类的原型是<code class="fe ms mt mu mj b">Function.prototype</code>。</p><p id="95b2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这意味着JavaScript类实际上是一个函数。</p><p id="14cc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以这样写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="20de" class="mn lc iq mj b gy mo mp l mq mr">class Person {<br/>  static logName() {<br/>    console.log(Person.name)<br/>  }<br/>}<br/><br/>console.log(Object.getPrototypeOf.call(Object, Person) === Function.prototype)</span></pre><p id="c35e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们调用<code class="fe ms mt mu mj b">Object.getPrototypeOf</code>方法来获得<code class="fe ms mt mu mj b">Person</code>类的原型。</p><p id="3f8c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们对照<code class="fe ms mt mu mj b">Function.prototype</code>进行检查。</p><p id="d8ca" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而这个日志<code class="fe ms mt mu mj b">true</code>。</p><p id="ad68" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们知道类是幕后的函数。</p><h1 id="7511" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">初始化实例</h1><p id="a635" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">通过编写以下代码初始化类实例:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="8b6a" class="mn lc iq mj b gy mo mp l mq mr">function Person(name) {<br/>  this.name = name;<br/>}</span></pre><p id="6d9c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在ES5中。</p><p id="99a8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在ES6中，基本构造函数是用<code class="fe ms mt mu mj b">super</code>方法创建的。</p><p id="a1ff" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这会触发父构造函数调用。</p><p id="c96d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在ES5中，当我们使用<code class="fe ms mt mu mj b">new</code>调用构造函数时，就会调用超级构造函数。</p><p id="818a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它通过函数调用来调用。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/78f5db1fbc41542c74ae4836af3f1786.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5iPTmz-zZJytFHq0"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@glenncarstenspeters?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">格伦·卡斯滕斯-彼得斯</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><h1 id="cf06" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="563a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">当我们创建类时，JavaScript解释器会做很多检查。</p><p id="cd69" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">还有，静态方法由子类继承，类是函数。</p></div></div>    
</body>
</html>