<html>
<head>
<title>Build Modern UIs with Compose, PageUiState and FlowState</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Compose、PageUiState 和 FlowState 构建现代用户界面</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/build-modern-uis-with-compose-pageuistate-and-flowstate-fcb2951ffa0?source=collection_archive---------2-----------------------#2022-04-07">https://blog.devgenius.io/build-modern-uis-with-compose-pageuistate-and-flowstate-fcb2951ffa0?source=collection_archive---------2-----------------------#2022-04-07</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/2e727e1ea06c0e4c05eca43d23da6493.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D_i2yK73D-xtpNoJg1C4ig.png"/></div></div></figure><p id="2ee3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">多年来，我们一直在开发和更新 android 的 UI 组件，为你的活动/片段提供一个单独的 XML 文件。这有很多缺点，比如视图组件与视图逻辑的解耦、UI 更新的困难、增加的代码行等等。</p><h2 id="1a21" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">什么是 Jetpack Compose？</h2><p id="5601" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">Jetpack 是一个为 Android 构建 UI 元素的工具包。有了它，你可以直接在 Kotlin 中编写你的 UI 组件和组件逻辑。它是声明性的，意味着你不必写逻辑是如何更新的，而只需提到更新了什么(我知道这一开始很复杂:P)</p><blockquote class="lr ls lt"><p id="8628" class="jv jw lu jx b jy jz ka kb kc kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ks ig bi translated">注意:本文假设您对 Jetpack Compose 有基本的了解。</p></blockquote><h2 id="a164" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">好酷！那么我们在构建什么，我为什么要继续阅读这篇文章呢？</h2><p id="619e" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">本文主要关注如何使用 twist :P 更新屏幕中的 UI 元素。我们将通过使用<strong class="jx io"> Jetpack Compose </strong>，一个名为<strong class="jx io"> StateFlow </strong>的 Kotlin 特性和一个名为<strong class="jx io"> PageUiState </strong>的概念来进行更新。</p><figure class="lz ma mb mc gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ly"><img src="../Images/7ae648fd8a91d6cb0e0856dbab078665.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*wBK4iLVZdKpbBWAXfXloDw.gif"/></div></div><figcaption class="md me gj gh gi mf mg bd b be z dk translated">要创建的应用程序</figcaption></figure><p id="a18c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">上面的 UI 由一个项目列表、一个加载初始列表的进度条和一个向列表添加随机项目的按钮组成。我们将通过使用<em class="lu">延迟</em>来模拟初始列表和列表更新通过一些外部源获取/更新。</p><ol class=""><li id="f740" class="mh mi in jx b jy jz kc kd kg mj kk mk ko ml ks mm mn mo mp bi translated"><strong class="jx io">创建一个空的合成项目</strong></li></ol><p id="258b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">打开你的安卓工作室。现在，从可用的初学者模板列表中，单击 Jetpack Compose。现在，您将看到一个空项目，其中只包含一个 MainActivity，它将是 app 的启动器活动。</p><p id="394c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">2.<strong class="jx io">添加依赖关系</strong></p><p id="0552" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">将以下依赖项添加到 build.gradle 文件中(应用程序级别)。</p><pre class="lz ma mb mc gt mq mr ms mt aw mu bi"><span id="5b8c" class="kt ku in mr b gy mv mw l mx my">plugins {<br/>   ....<br/>   ......... <br/>}</span><span id="72e8" class="kt ku in mr b gy mz mw l mx my">android {<br/>   ....<br/>   ......... <br/>}</span><span id="2e7d" class="kt ku in mr b gy mz mw l mx my">dependencies <strong class="mr io">{<br/><br/>    </strong>implementation 'androidx.core:core-ktx:1.7.0'<br/>    implementation "androidx.compose.ui:ui:$compose_version"<br/>    implementation "androidx.compose.material:material:$compose_version"<br/>    implementation "androidx.compose.ui:ui-tooling-preview:$compose_version"<br/>    implementation 'androidx.lifecycle:lifecycle-runtime-ktx:2.3.1'<br/>    implementation 'androidx.activity:activity-compose:1.3.1'<br/>    debugImplementation "androidx.compose.ui:ui-tooling:$compose_version"<br/>    implementation "androidx.activity:activity-ktx:1.4.0"<br/>    implementation "androidx.lifecycle:lifecycle-viewmodel-ktx:2.4.1"<br/>    implementation "androidx.lifecycle:lifecycle-viewmodel-compose:2.4.1"<br/><strong class="mr io">}</strong></span></pre><p id="b15a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">3.<strong class="jx io">创建一个视图模型，并将其与您的视图层链接。</strong></p><p id="958a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在<em class="lu"> src/viewmodels </em>下创建一个新的<strong class="jx io"> MainViewModel.kt </strong>文件，并添加以下内容。</p><pre class="lz ma mb mc gt mq mr ms mt aw mu bi"><span id="43bf" class="kt ku in mr b gy mv mw l mx my">class MainViewModel : ViewModel() {<br/>    private var _nextItem: String = getNextItem()</span><span id="4263" class="kt ku in mr b gy mz mw l mx my">    // gets a random string from a list of strings<br/>    private fun getNextItem(): String {<br/>        val randomItems = <em class="lu">listOf</em>(<br/>            "C", "C#", "Kotlin", "Ruby", "R", "Dart", "SQL"<br/>        )<br/>        val randomIndex = (randomItems.<em class="lu">indices</em>).<em class="lu">random</em>()<br/>        return randomItems[randomIndex]<br/>    }<br/><br/>}</span></pre><p id="85c9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">4.<strong class="jx io">创建一个页面状态</strong></p><p id="31ec" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">PageUiState 是一个数据类，它保存所有 UI 组件的状态，这些组件可能会在屏幕的整个生命周期中更新。</p><p id="baf9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">PageUiState 应该遵循的一些准则是:</p><ul class=""><li id="a8d4" class="mh mi in jx b jy jz kc kd kg mj kk mk ko ml ks na mn mo mp bi translated">所有属性都应该是 val 而不是 var。</li><li id="51cd" class="mh mi in jx b jy nb kc nc kg nd kk ne ko nf ks na mn mo mp bi translated">所有属性都应该有默认值</li><li id="0328" class="mh mi in jx b jy nb kc nc kg nd kk ne ko nf ks na mn mo mp bi translated">页面状态类可以命名为<screenname> UiState</screenname></li></ul><p id="1bda" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以让我们为我们的主屏幕创建一个页面状态。在<em class="lu"> src/uistates </em>下创建一个<strong class="jx io"> MainScreenUiState.kt </strong>文件，并添加以下内容。</p><pre class="lz ma mb mc gt mq mr ms mt aw mu bi"><span id="8432" class="kt ku in mr b gy mv mw l mx my">data class MainScreenUiState(<br/>    val isLoading: Boolean = true,<br/>    val itemList: List&lt;String&gt; = <em class="lu">emptyList</em>(),<br/>    val btnText: String = ""<br/>)</span></pre><p id="dafe" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在让我们来看看我们编写的每个属性:</p><ul class=""><li id="7a53" class="mh mi in jx b jy jz kc kd kg mj kk mk ko ml ks na mn mo mp bi translated">isLoading:进度条组件将使用该属性来决定它是否应该可见</li><li id="5d05" class="mh mi in jx b jy nb kc nc kg nd kk ne ko nf ks na mn mo mp bi translated">item list:lazy column 将使用该属性作为数据源来填充列表</li><li id="a575" class="mh mi in jx b jy nb kc nc kg nd kk ne ko nf ks na mn mo mp bi translated">btnText:这个属性将用于设置按钮内的文本，该按钮将项目添加到列表中</li></ul><p id="239c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">5.<strong class="jx io">添加一个状态流到你的视图模型</strong></p><p id="d649" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在让我们向 MainViewModel 添加一个状态流，它的默认值是 MainScreenUiState 的一个对象，并从我们的 UI 中观察它。</p><p id="b1cd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">将以下代码添加到您的<strong class="jx io"> MainViewModel </strong>中。</p><pre class="lz ma mb mc gt mq mr ms mt aw mu bi"><span id="aafb" class="kt ku in mr b gy mv mw l mx my">class MainViewModel : ViewModel() {<br/>    private val _uiState= <em class="lu">MutableStateFlow</em>(MainScreenUiState())<br/>    val uiState = _uiState.<em class="lu">asStateFlow</em>()<br/>    private var _nextItem: String = getNextItem()<br/><br/>    init {<br/>        <em class="lu">viewModelScope</em>.<em class="lu">launch </em><strong class="mr io">{<br/>            </strong>delay(2000)<br/>            _uiState.value = _uiState.value.copy(<br/>                isLoading = false,<br/>                itemList = <em class="lu">listOf</em>("Java","Python","Js", "Ts"),<br/>                btnText = "Add $_nextItem"<br/>            )<br/>        <strong class="mr io">}<br/>    </strong>}<br/><br/>    private fun getNextItem(): String {<br/>        val randomItems = <em class="lu">listOf</em>("C", "C#", "Kotlin", "Ruby", "R", "Dart", "SQL")<br/>        val randomIndex = (randomItems.<em class="lu">indices</em>).<em class="lu">random</em>()<br/>        return randomItems[randomIndex]<br/>    }<br/><br/>}</span></pre><p id="118c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在初始化程序块中，我们正在启动一个协程函数并将数据设置到我们的初始列表中。</p><p id="b8f4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">6.<strong class="jx io">创建 UI 并观察 UI 状态</strong></p><p id="14bb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">修改您的 MainScreen 函数以匹配以下代码行。</p><pre class="lz ma mb mc gt mq mr ms mt aw mu bi"><span id="af7e" class="kt ku in mr b gy mv mw l mx my">class MainActivity : ComponentActivity() {<br/>    override fun onCreate(savedInstanceState: Bundle?) {<br/>        super.onCreate(savedInstanceState)<br/>        <em class="lu">setContent </em><strong class="mr io">{<br/>            </strong><em class="lu">Blog3Theme </em><strong class="mr io">{<br/>                </strong><em class="lu">Surface</em>(modifier = Modifier.<em class="lu">fillMaxSize</em>(),<br/>                    color = MaterialTheme.colors.background) <strong class="mr io">{<br/>                    </strong><em class="lu">MainScreen</em>()<br/>                <strong class="mr io">}<br/>            }<br/>        }<br/>    </strong>}<br/>}<br/><br/>@Composable<br/>fun MainScreen(viewModel: MainViewModel = <em class="lu">viewModel</em>()) {<br/>    val uiState by viewModel.uiState.<em class="lu">collectAsState</em>()<br/>    <em class="lu">Column </em><strong class="mr io">{<br/>        </strong>if(uiState.isLoading) {<br/>            <em class="lu">LinearProgressIndicator</em>(modifier = Modifier.<em class="lu">fillMaxWidth</em>())<br/>        } else {<br/>            <em class="lu">LazyColumn</em>(Modifier.<em class="lu">weight</em>(1f))<strong class="mr io">{<br/>                </strong><em class="lu">items</em>(uiState.itemList) <strong class="mr io">{ </strong>item <strong class="mr io">-&gt;<br/>                    </strong><em class="lu">Text</em>(text = item)<br/>                <strong class="mr io">}<br/>            }<br/>            </strong><em class="lu">Button</em>(<br/>                onClick = (viewModel::addItem),<br/>                modifier = Modifier.<em class="lu">fillMaxWidth</em>().<em class="lu">padding</em>(16.<em class="lu">dp</em>)<br/>            ) <strong class="mr io">{<br/>                </strong><em class="lu">Text</em>(text = uiState.btnText)<br/>            <strong class="mr io">}<br/>        </strong>}<br/>    <strong class="mr io">}<br/></strong>}</span></pre><p id="fb2f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">不要担心解析<em class="lu"> viewModel::addItem </em>时的错误，我们将很快在我们的 viewModel 中添加这个方法。</p><p id="0767" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">通过使用'<em class="lu"> by viewModels()' </em>委托，将视图模型作为参数传递给 MainScreen composable 函数。</p><blockquote class="lr ls lt"><p id="66ae" class="jv jw lu jx b jy jz ka kb kc kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ks ig bi translated">注:此处<strong class="jx io"><em class="in">Blog3 主题</em> </strong> <em class="in"> </em>是由我提供的 app 名称(blog 3)生成的主题名称。它将根据您为项目提供的应用程序名称而有所不同。</p></blockquote><p id="e34d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">7.<strong class="jx io">添加方法更新按钮上的列表点击</strong></p><p id="733d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在让我们试着在点击按钮时更新列表。为此，我们将在 MainViewModel 中创建一个附加方法，并在按钮的 click 处理程序中传递对该方法的引用。</p><pre class="lz ma mb mc gt mq mr ms mt aw mu bi"><span id="12cd" class="kt ku in mr b gy mv mw l mx my">class MainViewModel : ViewModel() {</span><span id="bfc9" class="kt ku in mr b gy mz mw l mx my">    ....<br/>    ........</span><span id="6022" class="kt ku in mr b gy mz mw l mx my">    fun addItem() {<br/>        _uiState.value = _uiState.value.copy(isLoading = true)<br/><br/>        <em class="lu">viewModelScope</em>.<em class="lu">launch </em><strong class="mr io">{<br/>            </strong>delay(2000)<br/>            val itemToAdd = _nextItem<br/>            _nextItem = getNextItem()<br/>            _uiState.value = _uiState.value.copy(<br/>                isLoading = false,<br/>                itemList = _uiState.value.itemList.<em class="lu">toMutableList</em>().<em class="lu">apply </em><strong class="mr io">{ </strong>add(itemToAdd) <strong class="mr io">}</strong>,<br/>                btnText = "Add $_nextItem"<br/>            )<br/>        <strong class="mr io">}<br/>    </strong>}<br/>}</span></pre><p id="914c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在上面的代码片段中，注意我们最初是如何将<em class="lu"> isLoading </em>设置为<em class="lu"> true 的。</em>这将确保在用户界面上显示进度条。</p><p id="9964" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> <em class="lu">瞧！你完了！！</em>T25】</strong></p><p id="baa6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">尝试运行您的应用程序，看看一切看起来如何。这是一个关于如何以现代方式更新你的 compose ui 的基本实现，你可以在<strong class="jx io">主屏</strong>上添加额外的特性来学习和实验。</p><p id="1a63" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你喜欢这篇文章，可以分享一下。如果您有改进的建议或需要帮助，请留言。<em class="lu">一路平安！！</em></p></div></div>    
</body>
</html>