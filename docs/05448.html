<html>
<head>
<title>5 Exercises To Hone Your Secure Coding Skills</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">磨练您的安全编码技能的5个练习</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/5-exercises-to-hone-your-secure-coding-skills-7be9400dcf14?source=collection_archive---------2-----------------------#2021-08-12">https://blog.devgenius.io/5-exercises-to-hone-your-secure-coding-skills-7be9400dcf14?source=collection_archive---------2-----------------------#2021-08-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9787" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">让我们通过逐步构建身份验证逻辑来学习</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/29884b57c8767f2644c02f8b0dae11ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cdvLJZ1pFkuDSEDZXOBP5A.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">维多利亚·希斯在<a class="ae kv" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><p id="0bf7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">许多软件工程师主要关注于构建业务特性。但是，在增强应用逻辑的安全性上花了多少功夫呢？忽视保护您的应用程序的需要可能是毁灭性的，因为应用程序可能容易受到网络攻击。后果将是服务中断、数据丢失甚至经济损失。</p><p id="e723" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">事实是，许多安全漏洞是由于粗心的错误或没有适当保护的应用程序逻辑造成的。构建一个安全的应用程序并不困难。事实上，安全感知编程并不是一门火箭科学，如果你留心并更多地考虑代码逻辑中的安全控制，你可以获得这项技能并提升你的整体代码质量。</p><p id="0de6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，您将使用Java Spring Boot完成一系列有趣的编码练习，这些练习有助于您熟悉程序逻辑中的一些安全保护概念。</p><p id="bf73" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个示例应用程序提供了一个用户/密码验证逻辑。出于演示目的，逻辑内置于控制器中。通常情况下，应该使用Spring安全框架中的认证服务来实现。</p><p id="9e81" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面的身份验证逻辑从用户详细信息服务中检索用户记录，并验证用户id和密码。如何更好地保护这种登录逻辑？至少可以做5项改进来更好地保护系统。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><h2 id="ba7c" class="lu lv iq bd lw lx ly dn lz ma mb dp mc lf md me mf lj mg mh mi ln mj mk ml mm bi translated">GitHub知识库中的练习</h2><p id="0afc" class="pw-post-body-paragraph kw kx iq ky b kz mn jr lb lc mo ju le lf mp lh li lj mq ll lm ln mr lp lq lr ij bi translated">从这个GitHub存储库中获取源代码(<a class="ae kv" href="https://github.com/gavinklfong/authentication-code-exercises" rel="noopener ugc nofollow" target="_blank">https://GitHub . com/gavinklfong/authentic ation-code-exercises</a>)。<strong class="ky ir">主</strong>分支是整个练习的初始版本，您可以在每个分支中找到示例解决方案。总共5个练习有5个分支。比如分支<strong class="ky ir">练习-1 </strong>就是练习1的样本解。</p><h2 id="f63c" class="lu lv iq bd lw lx ly dn lz ma mb dp mc lf md me mf lj mg mh mi ln mj mk ml mm bi translated">关于示例应用程序</h2><p id="bc6d" class="pw-post-body-paragraph kw kx iq ky b kz mn jr lb lc mo ju le lf mp lh li lj mq ll lm ln mr lp lq lr ij bi translated">这是一个简单的Spring Boot应用程序，运行这个命令来启动应用程序。</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="324a" class="lu lv iq mt b gy mx my l mz na">mvn spring-boot:run</span></pre><p id="7d93" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">进入<a class="ae kv" href="http://localhost:8080" rel="noopener ugc nofollow" target="_blank"> http://localhost:8080 </a>，你会看到一个登陆页面。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nb"><img src="../Images/d67857c58879ecde9ed322b332582921.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j6NMNj1Sp2X7eGHY7ZGzIg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">示例应用程序—登录页面</figcaption></figure><p id="1802" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">转到登录页面，使用页面上提供的任何一个用户登录。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nc"><img src="../Images/baaa8aa59e422fff9f0f0a7375bf6b50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MkLkLgtZmsLE-bsqPrGATw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">示例应用程序—登录页面</figcaption></figure><p id="6ac4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">成功登录后，您将被重定向到一个安全页面。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nd"><img src="../Images/5fab047f4d5ced2062d02dbab38071e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*INxZRKAbi4EpgpIVxV-j4w.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">示例应用程序-安全页面</figcaption></figure><p id="99ad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您尝试在身份验证之前访问受保护的页面，将会看到403错误消息。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ne"><img src="../Images/62d4ab444511535a959b28ccd9accc88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t6-EeBdFy09MUDTYfGWXpQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">示例应用程序—禁止的错误</figcaption></figure></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><h1 id="84d9" class="nm lv iq bd lw nn no np lz nq nr ns mc jw nt jx mf jz nu ka mi kc nv kd ml nw bi translated">练习1 —如何保护持久性存储中的密码记录？</h1><p id="3fd4" class="pw-post-body-paragraph kw kx iq ky b kz mn jr lb lc mo ju le lf mp lh li lj mq ll lm ln mr lp lq lr ij bi translated">身份验证逻辑从用户服务中查找用户记录，并使用字符串比较来比较密码。显然，存储在用户服务中的密码是纯文本格式的。以明文形式存储敏感数据可以被任何有权访问数据的人轻易看到，这严重暴露了敏感数据泄露的风险。</p><p id="688e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将密码转换为哈希值是存储密码的标准且安全的方法，因为哈希是单向函数，这意味着没有办法将哈希值转换回原始文本内容。当然，利用强大的计算设备从散列值中导出原始内容是可行的，但是，如果采用强大的加密散列算法，这将需要数年时间。</p><p id="39fb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> Argon2 </strong>是强烈推荐的哈希函数，它是2025年密码哈希大赛的冠军。要实现密码散列，只需在Spring中定义一个密码编码器bean，然后它会自动注入到登录和用户注册等功能中。假设现有用户系统记录中的所有密码都已经迁移为哈希值，那么登录逻辑的增强就是使用编码器来验证用于身份验证的密码。</p><p id="e39c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">检查git分支<strong class="ky ir">练习-1 </strong>以获得使用密码编码器认证的示例实现。</p><p id="cd65" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是如何实现密码哈希的步骤:</p><ol class=""><li id="20fc" class="nx ny iq ky b kz la lc ld lf nz lj oa ln ob lr oc od oe of bi translated">将用户记录中的所有现有密码迁移到哈希值</li></ol><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi og"><img src="../Images/7c0ae1405b78f3f14ee8759f7752374f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ePO-2UfQaeJAgXwQ2b_hRw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">密码哈希值持久存储</figcaption></figure><p id="710b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">2.定义密码编码器。源代码比较显示了原始版本和新版本。我们在右侧的配置类中定义了密码编码器。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oh"><img src="../Images/6fb0aebeb420dcd187a2d58a7e87b1a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2x41MQBAUSLhb1VYe_bH4w.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">Argon2密码编码器定义</figcaption></figure><p id="ab68" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">3.添加对maven的依赖，因为Argon2密码编码器需要bouncycastle库。</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="5ccd" class="lu lv iq mt b gy mx my l mz na">&lt;dependency&gt;<br/>   &lt;groupId&gt;org.bouncycastle&lt;/groupId&gt;<br/>   &lt;artifactId&gt;bcprov-jdk15on&lt;/artifactId&gt;<br/>   &lt;version&gt;1.69&lt;/version&gt;<br/>&lt;/dependency&gt;</span></pre><p id="febc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">4.更新身份验证逻辑以使用编码器进行密码验证。右侧的更新版本使用编码器验证密码。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oi"><img src="../Images/0340914165bc8395932bbb1f094cdfb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hAiEuSr9DNucPpaJu1-Nmg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">密码编码器在认证逻辑中的应用</figcaption></figure></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><h1 id="9673" class="nm lv iq bd lw nn no np lz nq nr ns mc jw nt jx mf jz nu ka mi kc nv kd ml nw bi translated">练习2 —如何防范用户id被发现？</h1><h2 id="2857" class="lu lv iq bd lw lx ly dn lz ma mb dp mc lf md me mf lj mg mh mi ln mj mk ml mm bi translated">用户枚举</h2><p id="f7ad" class="pw-post-body-paragraph kw kx iq ky b kz mn jr lb lc mo ju le lf mp lh li lj mq ll lm ln mr lp lq lr ij bi translated">恶意用户的第一步是找到进入系统的方法。用户枚举是获取凭证的常用技术之一，它利用暴力攻击来发现并获取用户id和密码。换句话说，黑客通过运行一个计算机程序来实现攻击的自动化，该程序使用一组字典单词、公共用户id和密码来尝试登录数十万次甚至数百万次。黑客首先在你的系统记录中找出一个现有用户id的列表，然后发现每个用户id的密码。</p><p id="11ac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">黑客能够根据您的身份验证功能的系统响应来推断您的系统记录中是否存在用户id。因此，在为登录失败返回任何错误消息时要小心。</p><p id="8d53" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果输入的用户id不存在，示例应用程序将显示错误消息“找不到用户名”,如果用户记录存在且密码不匹配，则返回消息“密码错误”。该消息为恶意用户提供了有用的提示，以便他们可以建立已知用户的列表。</p><p id="7a4c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">错误消息—使用不存在的用户id登录</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oj"><img src="../Images/b294840b16b080b9ad17a43b66ec94fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HyHWQriCQ0mZrAqTxF4KLQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">找不到用户错误</figcaption></figure><p id="3c14" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">错误消息—密码错误</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oj"><img src="../Images/fb009907a48df82f264a0c2008b55d1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pkTjPCyfRwHG828AcPJTxQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">密码错误</figcaption></figure><p id="8561" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，解决方案是使错误信息更加通用。对于未知的用户id或错误的密码，系统应返回相同的错误消息“不正确的用户/密码”。你可以在git分支<strong class="ky ir">练习-2 </strong>中找到解决方法。下面右边的源代码是修改后的版本，带有一般错误信息。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ok"><img src="../Images/5dfac622adeb40b96eb0703b06116feb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*89txEO1fjdQOX8WE5P6r4g.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">练习2的示例解决方案</figcaption></figure><p id="a940" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，系统显示一条通用消息“不正确的用户/密码！”找不到用户或密码错误。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ol"><img src="../Images/c4827d9a025e2a0f04ed4534cbeae73c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pL3hxDTFjNU2WvcQQaqUQg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">一般登录错误消息</figcaption></figure></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><h1 id="903a" class="nm lv iq bd lw nn no np lz nq nr ns mc jw nt jx mf jz nu ka mi kc nv kd ml nw bi translated">练习3 —黑客还能推断出用户是否存在于您的系统中吗？如果有，如何预防？</h1><p id="e073" class="pw-post-body-paragraph kw kx iq ky b kz mn jr lb lc mo ju le lf mp lh li lj mq ll lm ln mr lp lq lr ij bi translated">随着错误消息的更新，恶意用户不再知道用户记录是否存在。他们还能通过其他方式质疑用户是否存在于你的系统中吗？</p><p id="4838" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">系统处理时间可能会以某种方式泄露内部身份验证过程。下面我们来看一下用户密码认证的流程图。系统首先根据输入的用户id获取用户记录，然后验证密码，最后为成功的身份验证建立登录会话。</p><p id="9af3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于错误情况，比如找不到用户记录或密码错误，系统简单地跳过其余处理并返回一个错误响应。因此，错误案例的平均响应时间比成功登录的过程更快。以下是每种可能结果的平均响应时间:</p><ul class=""><li id="bfec" class="nx ny iq ky b kz la lc ld lf nz lj oa ln ob lr om od oe of bi translated">登录失败(找不到用户):~ 1毫秒</li><li id="af2b" class="nx ny iq ky b kz on lc oo lf op lj oq ln or lr om od oe of bi translated">登录失败(密码不正确):~ 100毫秒</li><li id="7892" class="nx ny iq ky b kz on lc oo lf op lj oq ln or lr om od oe of bi translated">登录成功:~ 120毫秒</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi os"><img src="../Images/eea29a4bfffcd4cc1efe0efc2940f7cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_14YPOD4uHTPj5RF-NVWCw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">每个登录场景的平均处理时间</figcaption></figure><p id="b508" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于找不到用户而导致登录失败的响应时间比其他情况快得多。密码验证的哈希过程在很大程度上造成了响应时间的差异，因为它相对来说是一个CPU密集型过程。因此，只要观察响应时间，就不难确定用户id是否存在。</p><p id="d8e5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">检查git分支<strong class="ky ir">练习-3 </strong>，你会发现示例解决方案。要解决这个问题，建议的解决方案是添加一个虚拟步骤，以便在输入的用户id不存在时运行散列过程。在发送错误响应之前，虚拟步骤对输入的密码进行哈希处理，并与虚拟密码哈希进行匹配。</p><p id="93b7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">更新版本显示在下面源代码比较屏幕的右侧:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ot"><img src="../Images/03b09b4454065795747cfce887604343.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OM0wYgrdNJQaxLn8Gy6mGQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">练习3的示例解决方案</figcaption></figure><p id="ac30" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有了虚拟散列过程，下面的过程流程图显示了用户未发现错误和密码不正确两种情况下的相似响应时间。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi os"><img src="../Images/8512e1c427c2b1abb0a9f4d1feccc2fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WsYJLEvQMoiBxublMV3acA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">应用虚拟哈希过程后的平均响应时间</figcaption></figure></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><h1 id="36c8" class="nm lv iq bd lw nn no np lz nq nr ns mc jw nt jx mf jz nu ka mi kc nv kd ml nw bi translated">练习4-如何检测和跟踪可疑的恶意活动？</h1><p id="7a33" class="pw-post-body-paragraph kw kx iq ky b kz mn jr lb lc mo ju le lf mp lh li lj mq ll lm ln mr lp lq lr ij bi translated">没有系统日志，您如何对系统进行故障诊断？当涉及到日常系统支持时，系统日志是绝对重要的，但是，当他们构建系统逻辑时，没有多少开发人员注意日志记录。因此，由于缺乏信息，许多生产问题没有得到解决。</p><p id="fe42" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">身份验证逻辑的足够日志记录使得跟踪所有登录提交成为可能。例如，Splunk等企业数据平台支持的日志监控和警报触发。原则是通过为成功和失败案例编写系统日志来实现可追溯性，但是，请注意不要记录敏感数据，如个人信息或密码。</p><p id="1e1e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">查看git分支<strong class="ky ir">练习-4 </strong>，您可以看到带有日志记录的认证逻辑。右侧的代码比较显示了代码变化。虽然这3行代码非常简单，但它为我们提供了有用的信息，大大加快了故障诊断过程。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ou"><img src="../Images/16b6b88f9e2c7dc54e1a295e7ec4864c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wVrwUIhLpUI4gH1VlIpsRA.png"/></div></div></figure></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><h1 id="f19e" class="nm lv iq bd lw nn no np lz nq nr ns mc jw nt jx mf jz nu ka mi kc nv kd ml nw bi translated">练习5-如何防范自动攻击？</h1><p id="d163" class="pw-post-body-paragraph kw kx iq ky b kz mn jr lb lc mo ju le lf mp lh li lj mq ll lm ln mr lp lq lr ij bi translated">允许通过蛮力进行无限次数的登录尝试会增加安全漏洞的风险，因为攻击者迟早会在无数次试错之后获得有效的凭据。</p><p id="1b6e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然检测蛮力攻击并不难，但阻止这类攻击却很难。有效的方法是应用严格的密码策略并启用双因素身份验证，但是，实施和迁移所有现有凭据需要花费时间和精力。另一种方法是通过降低攻击速度来降低攻击效果，通常的做法是阻止可疑的IP地址或暂时锁定帐户。然而，黑客可以通过从不同IP范围的多台机器发起攻击，轻松绕过IP地址阻塞。此外，帐户锁定机制很容易被滥用，通过发起大规模攻击，导致锁定大量用户帐户，这将需要巨大的资源来审查和解锁帐户。</p><p id="bc47" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本练习中，我将分享一种通过在登录流中引入验证码来对付机器人攻击的便捷方法。这是减轻机器人攻击的一种快速简单的方法。这个示例解决方案采用了谷歌的reCAPTCHA服务版本2。</p><p id="243e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在验证码验证的登录流程中增加了一个额外的步骤。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ov"><img src="../Images/1eec01670a28dec286c35fecfee9b6e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*66v59rdHlbUXFKhLg7TQGQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">带有验证码验证的登录流程</figcaption></figure><p id="6af0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">登录屏幕上会添加一个复选框。用户需要单击登录提交的复选框。根据用户在屏幕上的活动，可能会提示用户一个带有图像列表的问题，用户需要通过选择正确的图像来完成该问题，以便在登录前通过验证码验证。在后台，小部件验证用户在屏幕上的活动，并从CAPTCHA服务获取令牌。提交请求后，身份验证逻辑将使用Google的REST API验证CAPTCHA令牌的真实性。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ow"><img src="../Images/2cf57df21ca730658aa6b8a6ed9844ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wbxtvi6F8KqiVDHtlmlMMw.png"/></div></div></figure><p id="f329" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，你需要在谷歌网站(<a class="ae kv" href="https://developers.google.com/recaptcha" rel="noopener ugc nofollow" target="_blank">https://developers.google.com/recaptcha</a>)上注册免费的验证码服务，然后在注册结束时，你将获得一套密钥和站点密钥。设置验证码小工具和令牌验证需要这些密钥。</p><p id="e1b5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">结帐git分支<strong class="ky ir">练习-5 </strong>，你会发现一个集成了谷歌reCAPTCHA服务的示例解决方案。修正案包括以下内容:</p><ul class=""><li id="c21d" class="nx ny iq ky b kz la lc ld lf nz lj oa ln ob lr om od oe of bi translated"><strong class="ky ir">登录屏幕</strong>——包括javascript库和用于Captcha小部件的HTML标签</li><li id="8a46" class="nx ny iq ky b kz on lc oo lf op lj oq ln or lr om od oe of bi translated"><strong class="ky ir">认证逻辑</strong> —使用Google reCAPTCHA服务的REST API来验证验证码令牌。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/1efb48e5d5dc6d3f6600a867a4efd027.png" data-original-src="https://miro.medium.com/v2/resize:fit:1282/format:webp/1*H05EqjoHuepeJlfRKeE2xw.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">带验证码验证的验证逻辑</figcaption></figure></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><h1 id="e5b7" class="nm lv iq bd lw nn no np lz nq nr ns mc jw nt jx mf jz nu ka mi kc nv kd ml nw bi translated">最后的想法</h1><p id="d52c" class="pw-post-body-paragraph kw kx iq ky b kz mn jr lb lc mo ju le lf mp lh li lj mq ll lm ln mr lp lq lr ij bi translated">安全编码是所有开发人员的一项基本技能，不管他们在为什么类型的系统工作。你不需要学习全日制学位或获得专业证书来获取知识。相反，您可以通过以下方式更好地保护您的系统:保护持久性存储中的敏感数据，通过系统日志提高系统可追溯性，以及通过深思熟虑的设计增强您的系统对外部各方的响应。构建身份验证逻辑的练习有助于您完成思考过程，从而在应用程序开发中建立安全思维。</p></div></div>    
</body>
</html>