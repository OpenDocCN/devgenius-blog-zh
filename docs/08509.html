<html>
<head>
<title>Async Rest Services With Messaging</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带消息传递的异步 Rest 服务</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/async-rest-services-with-messaging-5036723432fb?source=collection_archive---------5-----------------------#2022-06-20">https://blog.devgenius.io/async-rest-services-with-messaging-5036723432fb?source=collection_archive---------5-----------------------#2022-06-20</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><ul class=""><li id="c740" class="jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">如今，我们比以往任何时候都更加依赖数据来完成工作。应用程序、服务、软件、移动设备和其他元素结合在一起，形成了影响我们生活大部分领域的 web 服务。</li><li id="ad6d" class="jk jl in jm b jn kc jp kd jr ke jt kf jv kg jx jy jz ka kb bi translated">因此，为了处理彼此之间的数据流，程序员使用消息代理和类似的工具来交换信息和进行通信。</li><li id="f3c3" class="jk jl in jm b jn kc jp kd jr ke jt kf jv kg jx jy jz ka kb bi translated">消息代理是让应用程序、服务和系统进行通信和交换信息的软件模块。</li></ul><blockquote class="kh"><p id="bd8f" class="ki kj in bd kk kl km kn ko kp kq jx dk translated">消息代理通过在正式的消息传递协议之间转换消息来实现这一点，使相互依赖的服务能够直接相互通信。</p></blockquote><p id="2eb3" class="pw-post-body-paragraph kr ks in jm b jn kt ku kv jp kw kx ky jr kz la lb jt lc ld le jv lf lg lh jx ig bi translated"><strong class="jm io">为什么我们需要信息传递系统？</strong></p><ul class=""><li id="8155" class="jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">基本上，我们使用消息系统<strong class="jm io">可靠地将消息从发送者的设备转移到接收者的设备</strong>。消息传递的好处包括:远程通信。消息传递让我们能够分离应用程序来通信和传输数据。</li></ul><p id="36e1" class="pw-post-body-paragraph kr ks in jm b jn jo ku kv jp jq kx ky jr li la lb jt lj ld le jv lk lg lh jx ig bi translated"><strong class="jm io">什么是异步和同步程序？</strong></p><ul class=""><li id="e86d" class="jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">同步程序:使用阻塞调用的程序。为了在调用过程中不冻结，它必须有两个或更多的线程(这就是为什么它被称为同步的——线程是同步运行的)。</li><li id="1c1a" class="jk jl in jm b jn kc jp kd jr ke jt kf jv kg jx jy jz ka kb bi translated">异步程序:使用非阻塞调用的程序。它可以只有一个线程，但仍然保持交互。</li><li id="8bbb" class="jk jl in jm b jn kc jp kd jr ke jt kf jv kg jx jy jz ka kb bi translated">异步描述两个或多个事件/对象之间的关系，这些事件/对象在同一系统内交互，但不以预定的时间间隔发生，并且不一定依赖于彼此的存在才能发挥作用。</li><li id="fa6c" class="jk jl in jm b jn kc jp kd jr ke jt kf jv kg jx jy jz ka kb bi translated">但是我们大部分时间用来做微服务的协议是 HTTP，它是同步协议。所以只要你使用 HTTP 实现微服务，这就变成了同步。</li><li id="1ec4" class="jk jl in jm b jn kc jp kd jr ke jt kf jv kg jx jy jz ka kb bi translated">Kafka 和 RabbitMQ 是两个最受欢迎的消息代理<strong class="jm io">,它们在生产者和消费者之间传递消息。</strong></li></ul><h1 id="f20f" class="ll lm in bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated"><strong class="ak"> RabbitMQ: </strong></h1><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi mj"><img src="../Images/712dbf1634f955a5864c309f7accfe2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tjP-3j4CnMdQRL63t6W0Cw.png"/></div></div><figcaption class="mv mw gj gh gi mx my bd b be z dk translated">兔子 q</figcaption></figure><ul class=""><li id="f7e2" class="jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">RabbitMQ 使用独特的有界数据流。消息由生产者创建和发送，由消费者接收。这个代理最适合处理交易数据，比如订单形成和下单，以及用户请求。RabbitMQ 向用户发送消息。这些消息一经处理，将从队列中删除。</li></ul><blockquote class="kh"><p id="6c50" class="ki kj in bd kk kl km kn ko kp kq jx dk translated">RabbitMQ 的好处是能够灵活地路由消息。基于直接或正则表达式的路由允许消息连接特定的队列，而无需额外的代码。</p></blockquote><p id="a20e" class="pw-post-body-paragraph kr ks in jm b jn kt ku kv jp kw kx ky jr kz la lb jt lc ld le jv lf lg lh jx ig bi translated"><strong class="jm io"> RabbitMQ 消息代理由以下部分组成</strong>。</p><ol class=""><li id="9530" class="jk jl in jm b jn jo jp jq jr js jt ju jv jw jx mz jz ka kb bi translated">发送消息的生产者-用户应用程序</li><li id="1481" class="jk jl in jm b jn kc jp kd jr ke jt kf jv kg jx mz jz ka kb bi translated">exchange-将邮件推入队列。示例交换类型有<em class="na">直接、主题、标题和扇出。</em></li><li id="69d1" class="jk jl in jm b jn kc jp kd jr ke jt kf jv kg jx mz jz ka kb bi translated">队列——每个交换都包含缓冲区或类似缓冲区的东西来存储消息。</li><li id="c677" class="jk jl in jm b jn kc jp kd jr ke jt kf jv kg jx mz jz ka kb bi translated">接收消息的消费者用户应用程序</li></ol><p id="c603" class="pw-post-body-paragraph kr ks in jm b jn jo ku kv jp jq kx ky jr li la lb jt lj ld le jv lk lg lh jx ig bi translated">在 RabbitMQ 中，调度在某些情况下不能正常工作。</p><ul class=""><li id="6a9d" class="jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">默认情况下，RabbitMQ 会将每条消息按顺序发送给下一个消费者。<strong class="jm io"> </strong>这样每个消费者都会得到相同数量的消息。这种分发消息的方式称为循环调度。</li><li id="afed" class="jk jl in jm b jn kc jp kd jr ke jt kf jv kg jx jy jz ka kb bi translated">考虑一个有两个工人的情况，这些进来的工作将在这两个工人之间平均分配。所以假设一个接一个的工作负荷重，一个接一个的工作负荷轻，那么可能有一个工作人员一直处于工作负荷重的状态，而另一个可能处于自由状态。<br/>一个工人会一直重复忙碌，而另一个几乎什么也不做。</li><li id="fdeb" class="jk jl in jm b jn kc jp kd jr ke jt kf jv kg jx jy jz ka kb bi translated">就像 RabbitMQ 不知道任何关于它的事情，仍然会均衡地发送消息。它不关心消费者的未确认消息的数量。它只是冲动地将每第 n 条消息分派给第 n 个消费者。</li><li id="8f1e" class="jk jl in jm b jn kc jp kd jr ke jt kf jv kg jx jy jz ka kb bi translated">因此，可能会有这样的事件，一个可能空闲，而另一个可能堆积消息。</li></ul><blockquote class="nb nc nd"><p id="f09e" class="kr ks na jm b jn jo ku kv jp jq kx ky ne li la lb nf lj ld le ng lk lg lh jx ig bi translated">所以为了避免这种情况，RabbitMQ 有一个名为<strong class="jm io">的属性——公平调度</strong>。它有一个特性叫做预取。此预取值用于指定同时发送多少条消息。所以它一直等到消息处理结束。在这种情况下，当其他用户处于空闲状态时，一个用户可能不会堆积这些消息。</p><p id="dc49" class="kr ks na jm b jn jo ku kv jp jq kx ky ne li la lb nf lj ld le ng lk lg lh jx ig bi translated">因此，在这个消息处理过程中，可能会出现另一种可能性。</p></blockquote><ul class=""><li id="4789" class="jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">由于某些原因，在消息处理过程中，消费者可能会有一些损失，正在处理的消息可能不完整，那么数据将会丢失。为了确保数据不丢失，RabbitMQ 使用被称为<strong class="jm io"> ACK </strong>的消息确定。</li><li id="0d44" class="jk jl in jm b jn kc jp kd jr ke jt kf jv kg jx jy jz ka kb bi translated">所以这里 will consumer 从 RabbitMQ 收到一条消息并处理它，它反馈给 RabbitMQ，RabbitMQ 在收到反馈后从队列中删除这条消息。所以它会覆盖这个有损属性。</li></ul><p id="41c8" class="pw-post-body-paragraph kr ks in jm b jn jo ku kv jp jq kx ky jr li la lb jt lj ld le jv lk lg lh jx ig bi translated">现在让我们看看卡夫卡是如何做到这一点的。</p><h1 id="b2c2" class="ll lm in bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated"><strong class="ak">卡夫卡:</strong></h1><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi nh"><img src="../Images/2d5e73dcae942c45cb667da31460553f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KAQGBtCjEtPhvFqfdfBt_A.png"/></div></div></figure><ul class=""><li id="57ed" class="jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">在卡夫卡那里，我们有一个主题，所以这个信息的发表将会指向这个主题。</li><li id="e3b6" class="jk jl in jm b jn kc jp kd jr ke jt kf jv kg jx jy jz ka kb bi translated">不像 RabbitMQ 中使用的循环技术，Kafka 使用消费者群体来避免我们上面讨论的问题。消费者群体是一组消费者，他们合作消费来自某些主题的数据。所有主题的划分在组中的消费者之间进行。<br/> <br/> <br/> <strong class="jm io">想到一个题目名叫销售。</strong></li></ul><blockquote class="nb nc nd"><p id="107a" class="kr ks na jm b jn jo ku kv jp jq kx ky ne li la lb nf lj ld le ng lk lg lh jx ig bi translated">所以我们有一些隔板。同一销售主题的 P-0、P-1、P-2。当我们向 Kafka broker 发布消息时，它会遵循一种算法。<br/>该算法使用一个密钥，且它用我们拥有分区的数量来修改这个密钥。因此，它采用该值进行处理，并根据该值划分分区。因此，相同的客户消息总是传递到相同的分区。(如果我们使用客户编号作为关键字)。</p></blockquote><ul class=""><li id="7567" class="jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">所以在卡夫卡那里，这种秩序只存在于划分中，而不存在于主题中。</li><li id="ab2d" class="jk jl in jm b jn kc jp kd jr ke jt kf jv kg jx jy jz ka kb bi translated">因此，我们可以让消费者，我们可以让他们听每一个部分。所以，使这一组消费者是同一个组，然后消息将在同一个消费者组内传递。但是有一个限制。</li></ul><blockquote class="nb nc nd"><p id="99bf" class="kr ks na jm b jn jo ku kv jp jq kx ky ne li la lb nf lj ld le ng lk lg lh jx ig bi translated">如果我们有 3 个参与者，如果我们的消费者组有 4 个消费者，其中一个将是空闲的，因为它受限于我们拥有的分区数量。<br/>消费者组中的消费者数量应小于或等于我们拥有的分区数量。</p></blockquote><blockquote class="kh"><p id="4572" class="ki kj in bd kk kl km kn ko kp kq jx dk translated">所以以上讨论的观点是我们可以用 Kafka 和 RabbitMQ 做同样的工作，但重点是我们不一定要 Kafka 这样做。显然 rabbitMQ 的特性就足够了。但是可能会有一些处理/一些事件，我们可能需要卡夫卡来做。</p></blockquote><h2 id="e2a2" class="ni lm in bd ln nj nk dn lr nl nm dp lv jr nn no lz jt np nq md jv nr ns mh nt bi translated">理解卡夫卡的消费补偿:</h2><ul class=""><li id="b302" class="jk jl in jm b jn nu jp nv jr nw jt nx jv ny jx jy jz ka kb bi translated">消费者偏移量是一种跟踪 Kafka 主题接收消息的顺序的方法。它会一直保存，直到消息被发送给消费者，所以过一会儿消费者回来时，卡夫卡知道从哪里恢复发送过程。</li></ul></div></div>    
</body>
</html>