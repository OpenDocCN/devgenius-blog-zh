<html>
<head>
<title>Best of Modern JavaScript — Object-Oriented Programming</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">现代 JavaScript 的精华——面向对象编程</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/best-of-modern-javascript-object-oriented-programming-78984bd3f937?source=collection_archive---------4-----------------------#2020-09-12">https://blog.devgenius.io/best-of-modern-javascript-object-oriented-programming-78984bd3f937?source=collection_archive---------4-----------------------#2020-09-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/b069c3e82d51972540f6cd4e76cc684f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*S3DXiaBkWuRZllcN"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">由<a class="ae kc" href="https://unsplash.com/@aggriffith?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">亚当·格里菲斯</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="9172" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">自 2015 年以来，JavaScript 有了巨大的进步。</p><p id="c894" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在用起来比以前舒服多了。</p><p id="193a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究 JavaScript 的核心特性。</p><h1 id="c2aa" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><code class="fe lz ma mb mc b">No More apply()</code></h1><p id="3801" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">在 ES6 之前，我们必须使用<code class="fe lz ma mb mc b">apply</code>来调用一个以数组 spread 作为参数的函数。</p><p id="47ae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于 ES6 或更高版本，我们可以使用 spread 操作符，而不是调用函数。</p><p id="521f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为我们不必设置<code class="fe lz ma mb mc b">this</code>的值，所以这更容易。</p><p id="bb85" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="4b19" class="mq lc iq mc b gy mr ms l mt mu">Math.max.apply(Math, [3, 2, 1, 6])</span></pre><p id="eb1e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="cf59" class="mq lc iq mc b gy mr ms l mt mu">Math.max(...[3, 2, 1, 6])</span></pre><p id="7515" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这就简单多了，我们不用担心额外的争论。</p><p id="3035" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用<code class="fe lz ma mb mc b">push</code>方法，我们可以通过 ES5 或更高版本的<code class="fe lz ma mb mc b">apply</code>方法推送多个项目:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="13a6" class="mq lc iq mc b gy mr ms l mt mu">var arr1 = [1, 2];<br/>var arr2 = [3, 4];</span><span id="af97" class="mq lc iq mc b gy mv ms l mt mu">arr1.push.apply(arr1, arr2);</span></pre><p id="05fd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第一个参数是数组实例，我们将其设置为<code class="fe lz ma mb mc b">this</code>的值。</p><p id="9d8c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于 ES6，我们可以改为编写:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="d0a1" class="mq lc iq mc b gy mr ms l mt mu">const arr1 = [1, 2];<br/>const arr2 = [3, 4];<br/>arr1.push(...arr2);</span></pre><p id="ad5d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有了 spread 运算符，我们就不必再这样做了。</p><h1 id="bfa4" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><code class="fe lz ma mb mc b">concat() can be Replace by Spread</code></h1><p id="01c5" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">我们可以用 ES6 的 spread 操作符代替<code class="fe lz ma mb mc b">concat</code>。</p><p id="41ff" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不要用 ES5 写:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="dd45" class="mq lc iq mc b gy mr ms l mt mu">var arr1 = [1, 2];<br/>var arr2 = [3, 4];<br/>var arr3 = [5, 6];</span><span id="ccc7" class="mq lc iq mc b gy mv ms l mt mu">console.log(arr1.concat(arr2, arr3));</span></pre><p id="9bec" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="0a5c" class="mq lc iq mc b gy mr ms l mt mu">const arr1 = [1, 2];<br/>const arr2 = [3, 4];<br/>const arr3 = [5, 6];</span><span id="9b2f" class="mq lc iq mc b gy mv ms l mt mu">console.log([...arr1, ...arr2, ...arr3]));</span></pre><p id="0a2c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在 ES6 或更高版本中，我们使用 spread 运算符将所有 3 个数组合并到一起。</p><p id="e742" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">两个表达式都返回一个新数组，其中包含所有 3 个数组的元素。</p><h1 id="9087" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">对象文字中的函数表达式</h1><p id="cad3" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">在 ES6 或更高版本中，我们不再为对象方法写出<code class="fe lz ma mb mc b">function</code>关键字。</p><p id="60ca" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它有一个方便的语法来定义对象中的方法。</p><p id="eb5e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在 ES5 或更早的版本中，我们必须写:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="dcb4" class="mq lc iq mc b gy mr ms l mt mu">var obj = {<br/>  eat: function() {<br/>    //...<br/>  },<br/>  drink: function() {<br/>    this.eat();<br/>  },<br/>}</span></pre><p id="d133" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在对象中定义方法。</p><p id="3e60" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于 ES6 或更高版本，我们可以将其缩短为:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="3c5d" class="mq lc iq mc b gy mr ms l mt mu">const obj = {<br/>  eat() {<br/>    //...<br/>  },<br/>  drink() {<br/>    this.eat();<br/>  },<br/>}</span></pre><p id="08d0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们去掉了<code class="fe lz ma mb mc b">function</code>关键字和冒号，所以它更短了。</p><p id="828a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">他们做同样的事情。</p><h1 id="6467" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">类的构造函数</h1><p id="d316" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">ES6 为我们提供了一个方便的类语法来创建构造函数。</p><p id="1bb2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在 ES5 中，我们必须写:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="13f4" class="mq lc iq mc b gy mr ms l mt mu">function Person(name) {<br/>  this.name = name;<br/>}<br/>Person.prototype.greet = function() {<br/>  return 'Hello ' + this.name;<br/>};</span></pre><p id="a2a6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">实例方法是通过向<code class="fe lz ma mb mc b">prototype</code>属性添加一个属性来定义的。</p><p id="c287" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在 ES6 中，我们可以通过编写以下内容来使用类语法:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="831e" class="mq lc iq mc b gy mr ms l mt mu">class Person {<br/>  constructor(name) {<br/>    this.name = name;<br/>  }<br/>  greet() {<br/>    return `Hello ${this.name}`;<br/>  }<br/>}</span></pre><p id="6eb8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lz ma mb mc b">constructor</code>有构造函数内部的东西。</p><p id="6208" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而<code class="fe lz ma mb mc b">greet</code>仍然是<code class="fe lz ma mb mc b">Person</code>的<code class="fe lz ma mb mc b">prototype</code>属性中的方法。</p><p id="67a0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">只是写法不同而已。</p><h1 id="7c2b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">子类</h1><p id="cc92" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">用 ES5 创建子类很复杂。如果我们有超级构造函数和属性，那就更难了。</p><p id="a286" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要用 ES5 或更早版本创建父类和子类，我们编写:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="d10c" class="mq lc iq mc b gy mr ms l mt mu">function Person(name) {<br/>  this.name = name;<br/>}<br/>Person.prototype.greet = function() {<br/>  return 'Hello ' + this.name;<br/>};</span><span id="cfe4" class="mq lc iq mc b gy mv ms l mt mu">function Student(name, number) {<br/>  Person.call(this, name);<br/>  this.number = number;<br/>}<br/>Student.prototype = Object.create(Person.prototype);<br/>Student.prototype.constructor = Student;<br/>Student.prototype.describe = function() {<br/>  return Person.prototype.greet.call(this) + '-' + this.number;<br/>};</span></pre><p id="f598" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们以同样的方式创建<code class="fe lz ma mb mc b">Person</code>构造函数。</p><p id="2680" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后为了创建<code class="fe lz ma mb mc b">Student</code>子类，我们用<code class="fe lz ma mb mc b">call</code>方法调用<code class="fe lz ma mb mc b">Person</code>构造函数，用<code class="fe lz ma mb mc b">this</code>和<code class="fe lz ma mb mc b">name</code>调用父构造函数。</p><p id="7853" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们初始化<code class="fe lz ma mb mc b">Student</code>的实例数据。</p><p id="a7ed" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们通过用<code class="fe lz ma mb mc b">Person</code>的原型调用<code class="fe lz ma mb mc b">Object.create</code>来创建<code class="fe lz ma mb mc b">Student</code>的原型。</p><p id="4b03" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们将<code class="fe lz ma mb mc b">constructor</code>属性设置为<code class="fe lz ma mb mc b">Student</code>以获得正确的构造函数。</p><p id="c5ba" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们将实例方法添加到<code class="fe lz ma mb mc b">Student</code>类中。</p><p id="b285" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">很复杂，很难理解。</p><p id="5504" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用类语法，我们编写:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="68e8" class="mq lc iq mc b gy mr ms l mt mu">class Person {<br/>  constructor(name) {<br/>    this.name = name;<br/>  }<br/>  greet() {<br/>    return `Hello ${this.name}`;<br/>  }<br/>}</span><span id="9f20" class="mq lc iq mc b gy mv ms l mt mu">class Student extends Person {<br/>  constructor(name, number) {<br/>    super(name);<br/>    this.number = number;<br/>  }<br/>  describe() {<br/>    return `${Person.prototype.greet.call(this)}-'${this.number}`;<br/>  }<br/>}</span></pre><p id="e6c6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们所要做的就是使用<code class="fe lz ma mb mc b">extends</code>关键字来表明它是一个子类。</p><p id="f769" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并且我们调用<code class="fe lz ma mb mc b">super</code>来调用父构造函数。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/cc1e492969875435b77c839ac222fe70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*AJy7p27kEZUZjnIJ"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">席琳·艺伎回忆录·塔加米在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="6aa6" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="088b" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">使用 ES6 或更高版本，面向对象编程更容易。</p></div></div>    
</body>
</html>