<html>
<head>
<title>Object-Oriented JavaScript — Singletons and Decorators</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向对象的JavaScript——单件和装饰件</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/object-oriented-javascript-singletons-and-decorators-6ba1eb2654d0?source=collection_archive---------4-----------------------#2020-11-28">https://blog.devgenius.io/object-oriented-javascript-singletons-and-decorators-6ba1eb2654d0?source=collection_archive---------4-----------------------#2020-11-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/da3a8a45991dc17050a42a1f12b12d1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*PzrTyo5_vupSbBTF"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">马库斯·斯皮斯克在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="d38e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JavaScript部分是面向对象的语言。</p><p id="7b04" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要学习JavaScript，我们必须学习JavaScript的面向对象部分。</p><p id="6eb1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究一些基本的设计模式。</p><h1 id="5661" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">类单例</h1><p id="fe3e" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过将类实例存储在一个全局对象中来创建一个单例对象。</p><p id="31e1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="75eb" class="mn lc iq mj b gy mo mp l mq mr">function Foo() {<br/>  if (typeof globalFoo === "undefined") {<br/>    globalFoo = this;<br/>  }<br/>  return globalFoo;<br/>}</span></pre><p id="1dc1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以通过编写以下代码来创建一个<code class="fe ms mt mu mj b">Foo</code>实例:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="12e8" class="mn lc iq mj b gy mo mp l mq mr">const a = new Foo();<br/>const b = new Foo();<br/>console.log(a === b);</span></pre><p id="d6e6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">控制台日志应该记录<code class="fe ms mt mu mj b">true</code>，因为我们将现有的实例存储在一个全局变量中。</p><p id="8fe5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果不是<code class="fe ms mt mu mj b">undefined</code>，我们就退回去。</p><h1 id="d211" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">单一存储在构造函数的属性中</h1><p id="b6c1" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们知道不应该使用全局变量，所以我们可以将单例实例存储为构造函数的属性。</p><p id="8064" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">函数可以有属性，因为它们是对象。</p><p id="040c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="81c0" class="mn lc iq mj b gy mo mp l mq mr">function Foo() {<br/>  if (typeof Foo.instance === "undefined") {<br/>    Foo.instance = this;<br/>  }<br/>  return Foo.instance;<br/>}</span></pre><p id="e08c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">唯一的变化是我们将属性存储在实例中，而不是存储在全局变量中。</p><p id="4901" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们把它放在一个函数中，我们也可以把它存储在私有属性中。</p><p id="af29" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="4af0" class="mn lc iq mj b gy mo mp l mq mr">const Foo = (() =&gt; {<br/>  let instance;<br/>  return function() {<br/>    if (typeof instance === "undefined") {<br/>      instance = this;<br/>    }<br/>    return instance;<br/>  }<br/>})();</span></pre><p id="e4ac" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">做同样的事情。</p><p id="6fe6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样，我们就不会意外地将实例更改为其他内容。</p><h1 id="86d7" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">工厂模式</h1><p id="aa9a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">工厂模式是创造性的设计模式。</p><p id="5198" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它处理创建对象。</p><p id="89ed" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">工厂是一个功能，可以帮助我们用一个功能创建相似类型的对象。</p><p id="87b3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以通过编写以下代码来创建一个函数:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="6933" class="mn lc iq mj b gy mo mp l mq mr">const createElement = (type, url) =&gt; {<br/>  if (type === 'Image') {<br/>    return new Image(url);<br/>  }<br/>  if (type === 'Link') {<br/>    return new Link(url);<br/>  }<br/>  if (type === 'Text') {<br/>    return new Text(url);<br/>  }<br/>}</span></pre><p id="f5e5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们基于<code class="fe ms mt mu mj b">type</code>值返回构造函数实例。</p><p id="3287" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还采用了用于构造函数的<code class="fe ms mt mu mj b">url</code>。</p><h1 id="7751" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">装饰图案</h1><p id="bb09" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">装饰模式是一种结构模式。</p><p id="65de" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以使用这种模式来扩展对象的功能。</p><p id="9cb7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用这种模式，我们可以通过选择想要应用于对象的装饰器来扩展对象的功能。</p><p id="4494" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="75a1" class="mn lc iq mj b gy mo mp l mq mr">function Person(name) {<br/>  this.name = name;<br/>  this.say = function() {<br/>    console.log(this.name);<br/>  };<br/>}</span><span id="e0fb" class="mn lc iq mj b gy mv mp l mq mr">function DecoratedPerson(person, street, city) {<br/>  this.person = person;<br/>  this.person = person.name;<br/>  this.street = street;<br/>  this.city = city;<br/>  this.say = function() {<br/>    console.log(this.name, this.street, this.city);<br/>  };<br/>}</span></pre><p id="7461" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有两个构造函数<code class="fe ms mt mu mj b">Person</code>和<code class="fe ms mt mu mj b">DecoratedPerson</code>类。</p><p id="93f8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">Person</code>是我们用作<code class="fe ms mt mu mj b">DecoratedPerson</code>类基础的类。</p><p id="092b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">DecoratedPerson</code>类在<code class="fe ms mt mu mj b">Person</code>类的基础上增加了额外的属性。</p><p id="cd39" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样，我们保持<code class="fe ms mt mu mj b">DecoratedPerson</code>的接口与来自<code class="fe ms mt mu mj b">Person</code>的<code class="fe ms mt mu mj b">Person</code>构造函数相同。</p><p id="3ea1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是我们添加了更多<code class="fe ms mt mu mj b">DecoratedPerson</code>类独有的属性。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/15e5befc585539af9658e4f2d2738656.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DQ5SMoKMXB7BJp7M"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">由<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae kc" href="https://unsplash.com/@louishansel?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Louis Hansel @shotsoflouis </a>拍摄的照片</figcaption></figure><h1 id="9bc3" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="be55" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用类似语法的类创建单例对象。</p><p id="4e6b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">装饰模式让我们扩展构造函数的功能。</p></div></div>    
</body>
</html>