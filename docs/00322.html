<html>
<head>
<title>Understanding the difference between Double Equals vs. Triple Equals in Javascript.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解Javascript中两倍等于和三倍等于的区别。</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/understanding-the-difference-between-double-equals-vs-triple-equals-in-javascript-9dfc8c4c36df?source=collection_archive---------9-----------------------#2020-06-02">https://blog.devgenius.io/understanding-the-difference-between-double-equals-vs-triple-equals-in-javascript-9dfc8c4c36df?source=collection_archive---------9-----------------------#2020-06-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/92fb729994a8cb07c1ea1c85ebbb7d82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9rtvAXs6zDkZonlFXiorFQ.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://www.pexels.com/@serpstat-177219?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Serpstat </a>从<a class="ae kc" href="https://www.pexels.com/photo/apple-devices-books-business-coffee-572056/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Pexels </a>拍摄</figcaption></figure><p id="a290" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你不确定JavaScript中==和===的区别，你并不孤单。很多人仍然很难理解javascript中' == '和' === '之间的区别。</p><p id="53b7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，让我们来了解一下什么是二等和三等:</p><p id="98ac" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">双等号(==): </strong></p><blockquote class="lb lc ld"><p id="d5dc" class="kd ke le kf b kg kh ki kj kk kl km kn lf kp kq kr lg kt ku kv lh kx ky kz la ij bi translated">双相等的官方名称是抽象相等比较运算符或松散相等。它将比较两个元素，而不考虑它们的数据类型。它还会在执行比较之前将变量值转换为相同的类型。这就是所谓的<a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Glossary/Type_coercion" rel="noopener ugc nofollow" target="_blank">型强制</a>。</p></blockquote></div><div class="ab cl li lj hu lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="ij ik il im in"><p id="1082" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">三重等于(===): </strong></p><blockquote class="lb lc ld"><p id="6094" class="kd ke le kf b kg kh ki kj kk kl km kn lf kp kq kr lg kt ku kv lh kx ky kz la ij bi translated"><em class="iq">三重等于被称为严格相等比较运算符或恒等运算符，但它将通过值和数据类型来比较两个元素。严格运算符在执行比较之前不会将变量值转换为相同的类型，而是仅当两个变量的值和类型在比较中相同时才返回true。</em></p></blockquote><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="bdc0" class="ly lz iq lu b gy ma mb l mc md">console.log(10 == "10"); //true</span><span id="1c99" class="ly lz iq lu b gy me mb l mc md">console.log(10 === "10"); //false</span></pre><p id="e8b8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">注意:</strong>当使用双等号时，它返回true，因为在进行比较之前，字符串10被转换为数字10。而triple equals比较类型和值并返回false。</p><p id="df66" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们来看看这个例子:</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="d149" class="ly lz iq lu b gy ma mb l mc md">const myAge = 30;</span><span id="109c" class="ly lz iq lu b gy me mb l mc md">const yourAge= 30;</span><span id="109d" class="ly lz iq lu b gy me mb l mc md">console.log(myAge);  //30;</span><span id="f131" class="ly lz iq lu b gy me mb l mc md">console.log(yourAge);  //30;</span><span id="32f6" class="ly lz iq lu b gy me mb l mc md">console.log(myAge == yourAge); //true</span><span id="2a8a" class="ly lz iq lu b gy me mb l mc md">console.log(myAge === yourAge); //true<br/></span></pre><p id="2ac4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意，double equals和triple equals返回true，因为两个变量具有相同的数据类型和值，即30；</p><p id="4538" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们考虑另一个例子:</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="c675" class="ly lz iq lu b gy ma mb l mc md">const myAge = 30;</span><span id="1745" class="ly lz iq lu b gy me mb l mc md">const yourAge= "30";</span><span id="ee93" class="ly lz iq lu b gy me mb l mc md">console.log(myAge);  //30;</span><span id="bebf" class="ly lz iq lu b gy me mb l mc md">console.log(yourAge);  //30;</span><span id="abe4" class="ly lz iq lu b gy me mb l mc md">console.log(myAge == yourAge); //true</span><span id="22ff" class="ly lz iq lu b gy me mb l mc md">console.log(myAge === yourAge); //false</span></pre><p id="0d1b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意区别，这一次triple equals返回false。为什么，是因为myAge是一个值为30的整型变量，yourAge变量是一个字符串值为“30”的字符串变量。</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="137b" class="ly lz iq lu b gy ma mb l mc md">const fName= "Amy";</span><span id="b377" class="ly lz iq lu b gy me mb l mc md">const lName= "Cruz";</span><span id="e7a6" class="ly lz iq lu b gy me mb l mc md">console.log(fName);  //Amy;</span><span id="989d" class="ly lz iq lu b gy me mb l mc md">console.log(lName);  //Cruz;</span><span id="53f6" class="ly lz iq lu b gy me mb l mc md">console.log(fName == lName); //true</span><span id="566c" class="ly lz iq lu b gy me mb l mc md">console.log(fName === lName); //true</span></pre><p id="12e3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意，两倍等于和三倍等于是真的，因为它们都是相同的数据类型和值，都是字符串。</p><h1 id="5858" class="mf lz iq bd mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb bi translated">相等运算符和其他引用类型</h1><p id="0ebf" class="pw-post-body-paragraph kd ke iq kf b kg nc ki kj kk nd km kn ko ne kq kr ks nf ku kv kw ng ky kz la ij bi translated">到目前为止，我们一直在探索使用<a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Glossary/Primitive" rel="noopener ugc nofollow" target="_blank">原始类型</a>的等式运算符。</p><p id="43f4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像<a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array" rel="noopener ugc nofollow" target="_blank">数组</a>这样的引用类型呢？</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="b7c9" class="ly lz iq lu b gy ma mb l mc md">const num1 = [1,2,3];</span><span id="1555" class="ly lz iq lu b gy me mb l mc md">const num2 = [1,2,3];</span><span id="ea2b" class="ly lz iq lu b gy me mb l mc md">console.log(num1 ==  num2); // false</span><span id="9d8d" class="ly lz iq lu b gy me mb l mc md">console.log(num1 === num2); // false</span></pre><p id="1b10" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意:你不能像我们对基本类型那样比较两个有相同内容的数组。尽管数组内容相同，但它们的值本质上是不同的。这同样适用于对象和其他引用类型。</p><h1 id="106d" class="mf lz iq bd mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb bi translated">那么我应该用哪一个呢？</h1><p id="a481" class="pw-post-body-paragraph kd ke iq kf b kg nc ki kj kk nd km kn ko ne kq kr ks nf ku kv kw ng ky kz la ij bi translated"><strong class="kf ir">三倍等于优于两倍等于。</strong></p><p id="184f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一般情况下，建议使用“===”运算符，因为它从不进行类型转换，我们做的是精确比较，因此它总是产生正确的结果。</p><p id="abad" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">感谢阅读。😊😊😊😊</p></div></div>    
</body>
</html>