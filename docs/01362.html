<html>
<head>
<title>Event Binding in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React 中的事件绑定</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/event-binding-in-react-6b88dd56a0f5?source=collection_archive---------9-----------------------#2020-07-01">https://blog.devgenius.io/event-binding-in-react-6b88dd56a0f5?source=collection_archive---------9-----------------------#2020-07-01</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/4c35b75881b8fde05f1993799f8bee3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wg4xV3LhtWdiz-qkoy5LGQ.jpeg"/></div></div></figure><p id="8694" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">React 中的事件绑定可能很棘手。这不是 React 的错，要怪就怪 Javascript。在我的<a class="ae kt" href="https://medium.com/@shannonmakenna/lexical-scope-and-arrow-functions-in-javascript-4d67dafbbf59" rel="noopener">上一篇</a>文章中，我简要解释了 Javascript 中的<em class="ku">这个</em>关键字是什么意思，以及如何确保你引用的是你想要引用的对象。在本文中，我将专门讨论 React 中绑定事件的不同方式，以及每种方式的优缺点。</p><p id="ba39" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里，我的 App.js 有一个状态计数变量，它的值 I 将通过使用 increaseCount 函数增加，该函数将作为 button 元素的属性传递。</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="017b" class="le lf in la b gy lg lh l li lj">import React, { Component } from "react";</span><span id="5ebd" class="le lf in la b gy lk lh l li lj">class App extends Component {</span><span id="6d7f" class="le lf in la b gy lk lh l li lj">  constructor(props) {</span><span id="e46e" class="le lf in la b gy lk lh l li lj">  super(props);</span><span id="ac91" class="le lf in la b gy lk lh l li lj"><strong class="la io">  this.state = {</strong></span><span id="dc38" class="le lf in la b gy lk lh l li lj"><strong class="la io">    count: 0</strong></span><span id="21dc" class="le lf in la b gy lk lh l li lj"><strong class="la io">  }<br/></strong>}<br/>increaseCount() {</span><span id="01c8" class="le lf in la b gy lk lh l li lj">   this.setState(prevState =&gt; ({ count: prevState.count + 1 }));</span><span id="ba02" class="le lf in la b gy lk lh l li lj"> }</span><span id="abf1" class="le lf in la b gy lk lh l li lj">render() {</span><span id="58e3" class="le lf in la b gy lk lh l li lj">   return (</span><span id="a306" class="le lf in la b gy lk lh l li lj">     &lt;div className="App"&gt;<br/>       <strong class="la io"><em class="ku">&lt;button onClick = {this.increaseCount}&gt; <br/>         Count: {this.state.count}&lt;/button&gt;</em></strong><em class="ku"><br/>        </em><br/>     &lt;/div&gt;<br/>) </span><span id="90f7" class="le lf in la b gy lk lh l li lj">export default App;</span></pre><p id="6e41" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当你像上面那样调整这段代码时，你会得到一个类型错误“无法读取未定义的‘setState’的属性”。这是因为<em class="ku">这个</em>指的是窗口对象而不是类本身。因此，让我们通过绑定事件处理程序来解决这个问题。</p><h2 id="bdef" class="le lf in bd ll lm ln dn lo lp lq dp lr kg ls lt lu kk lv lw lx ko ly lz ma mb bi translated">在渲染函数中绑定</h2><p id="6a1f" class="pw-post-body-paragraph jv jw in jx b jy mc ka kb kc md ke kf kg me ki kj kk mf km kn ko mg kq kr ks ig bi translated">一种选择是在 render 方法中绑定事件处理程序。</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="ac24" class="le lf in la b gy lg lh l li lj"><em class="ku">render() {<br/> return(<br/>  &lt;button onClick =</em><strong class="la io"><em class="ku">{this.increaseCount.bind(this)}</em></strong><em class="ku">&gt;<br/>     Count: {this.state.count}<br/>  &lt;/button&gt;<br/> )<br/>}</em></span></pre><p id="b07a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">虽然此选项有效，但它会导致性能问题，因为每次状态更新都会导致应用程序组件重新呈现，并在每次呈现时生成一个全新的事件处理程序。对于一个事件处理程序来说，这可能不是问题，但是如果您有多个事件处理程序，您的性能将会降低。</p><h2 id="1169" class="le lf in bd ll lm ln dn lo lp lq dp lr kg ls lt lu kk lv lw lx ko ly lz ma mb bi translated">在 Render 方法中使用箭头函数</h2><p id="3e5b" class="pw-post-body-paragraph jv jw in jx b jy mc ka kb kc md ke kf kg me ki kj kk mf km kn ko mg kq kr ks ig bi translated">您可以使用箭头函数来调用 render 方法中的函数。请注意，我们正在<strong class="jx io">调用</strong>函数，因此语法如下(<em class="ku"> this.increaseCount()) </em></p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="4d64" class="le lf in la b gy lg lh l li lj"><em class="ku">render() {<br/> return(<br/>  &lt;button onClick = {() =&gt; this.increaseCount()}&gt; <br/>    Count:{this.state.count}&lt;/button&gt;<br/>}</em></span></pre><p id="3e72" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这种方法的缺点类似于第一种方法，即在每次重新渲染时创建一个新的事件处理程序。</p><h2 id="ef9c" class="le lf in bd ll lm ln dn lo lp lq dp lr kg ls lt lu kk lv lw lx ko ly lz ma mb bi translated">构造函数中的绑定</h2><p id="6db9" class="pw-post-body-paragraph jv jw in jx b jy mc ka kb kc md ke kf kg me ki kj kk mf km kn ko mg kq kr ks ig bi translated">常见且稳定的方法是在构造函数中绑定事件处理程序</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="cffe" class="le lf in la b gy lg lh l li lj">constructor(props) {</span><span id="fd1e" class="le lf in la b gy lk lh l li lj">  super(props);</span><span id="3ed0" class="le lf in la b gy lk lh l li lj">  this.state = {</span><span id="d9fa" class="le lf in la b gy lk lh l li lj">    count: 0<br/>  }<strong class="la io">;</strong><br/><strong class="la io"> <em class="ku">this.increaseCount = this.increaseCount.bind(this); </em></strong></span><span id="610b" class="le lf in la b gy lk lh l li lj">}</span></pre><p id="feb7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这种方法的好处是调用 render 方法不会为 onClick 生成新的处理程序，因此按钮元素不会被重新呈现。</p><h2 id="4837" class="le lf in bd ll lm ln dn lo lp lq dp lr kg ls lt lu kk lv lw lx ko ly lz ma mb bi translated">用箭头函数绑定</h2><p id="fbaa" class="pw-post-body-paragraph jv jw in jx b jy mc ka kb kc md ke kf kg me ki kj kk mf km kn ko mg kq kr ks ig bi translated">箭头函数是作为 ES7 类属性引入的，它们提供了绑定事件处理程序的最简单方式。</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="5ecd" class="le lf in la b gy lg lh l li lj">increaseCount = () =&gt; {</span><span id="bde7" class="le lf in la b gy lk lh l li lj">    this.setState(prevState =&gt; ({ count: prevState.count + 1 }));<br/>};</span><span id="39e5" class="le lf in la b gy lk lh l li lj"><em class="ku">render() {<br/> return(<br/>  &lt;button onClick = {this.increaseCount}&gt; <br/>    Count:{this.state.count}&lt;/button&gt;<br/>}</em></span></pre><p id="fd09" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后，该方法被分配给 render 方法中的 button onClick 属性。一旦组件被初始化，this.increaseCount 将永远不会改变，按钮也不会被呈现。</p><p id="bc21" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">结论</strong></p><p id="6bfd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">要在 React 中绑定事件处理程序，<strong class="jx io">最简单、最有效的方法</strong>是绑定箭头函数。因为这是一个新特性，所以在构造函数方法中使用绑定的代码并不少见。这是一个同样有效的选择。</p><p id="e6c0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">感谢阅读。希望这篇文章有所帮助。关于绑定事件处理程序的更详细的解释，我推荐阅读<a class="ae kt" href="https://www.freecodecamp.org/news/the-best-way-to-bind-event-handlers-in-react-282db2cf1530/" rel="noopener ugc nofollow" target="_blank">这篇</a> FreeCodeCamp 文章。</p></div></div>    
</body>
</html>