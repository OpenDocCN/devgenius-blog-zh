<html>
<head>
<title>How to combine Servant and React Admin, Part 4 : POSTing a new Comment</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何组合 Servant 和 React Admin，第 4 部分:发布新评论</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-to-combine-servant-and-react-admin-part-4-posting-a-new-comment-fe9bf9c72c40?source=collection_archive---------39-----------------------#2020-07-08">https://blog.devgenius.io/how-to-combine-servant-and-react-admin-part-4-posting-a-new-comment-fe9bf9c72c40?source=collection_archive---------39-----------------------#2020-07-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/101b8ac26b9335afd1b2a31775831635.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*L1sAO4Lp6fbLGioFRVa0lA.jpeg"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">邮箱，信用:克里斯蒂娜·特里普科维奇</figcaption></figure><h1 id="d175" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">概观</h1><p id="5756" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated"><a class="ae lu" href="https://propellant.tech/blogs/servant-and-react-admin-3/" rel="noopener ugc nofollow" target="_blank">继续我们的上一篇博客</a>，我们将向 API 添加一个 POST 方法，并从 React 使用它。我们将通过使用<code class="fe lv lw lx ly b">ReaderT</code>单子来跟踪添加的注释。</p><h1 id="8f5d" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">API 类型</h1><p id="db1a" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">让我们用 POST 方法扩展 API 类型:</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="9afd" class="mh jz iq ly b gy mi mj l mk ml">type WebApi<br/>   = "comments" :&gt; Get '[ JSON] (ListHeaders [Comment]) <br/>   :&lt;|&gt; "comments" :&gt; Capture "id" Int :&gt; Get '[ JSON] Comment<br/>   :&lt;|&gt; "comments" :&gt; ReqBody '[ JSON] NewComment :&gt; Post '[JSON] NoContent</span></pre><p id="a777" class="pw-post-body-paragraph kw kx iq ky b kz mm lb lc ld mn lf lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">没什么特别的，也许除了<code class="fe lv lw lx ly b">NewComment</code>型。此外，这里的新东西是我们通过使用<code class="fe lv lw lx ly b">ReqBody</code>来表达<code class="fe lv lw lx ly b">NewComment</code>应该作为 JSON 类型出现在请求的主体中。帖子不会返回任何内容。这可能看起来很奇怪，当没有内容被返回时，你必须以<code class="fe lv lw lx ly b">JSON</code>的形式指定内容类型。背后的原因在这里<a class="ae lu" href="https://github.com/haskell-servant/servant/issues/498" rel="noopener ugc nofollow" target="_blank">解释</a>，但基本上归结为没有内容的特殊情况。</p><p id="86bd" class="pw-post-body-paragraph kw kx iq ky b kz mm lb lc ld mn lf lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated"><code class="fe lv lw lx ly b">NewComment</code>型与<code class="fe lv lw lx ly b">Comment</code>型除 id 外基本相同。因为在我们的方法中，服务器是分发 id 的服务器，所以我们不能让 Web UI 指定它，所以它永远不会出现在发布的<code class="fe lv lw lx ly b">comment</code>中。<code class="fe lv lw lx ly b">NewComment</code>相当直白地这样指定:</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="2a95" class="mh jz iq ly b gy mi mj l mk ml">{-# LANGUAGE DeriveGeneric #-}<br/><br/>module NewComment where<br/><br/>import           Data.Aeson.Types           (FromJSON, ToJSON)<br/>import           GHC.Generics               (Generic)<br/><br/>newtype NewComment<br/>  = NewComment {content :: String}<br/>  deriving (Generic, Show)<br/><br/>instance ToJSON NewComment<br/><br/>instance FromJSON NewComment</span></pre><p id="4a1a" class="pw-post-body-paragraph kw kx iq ky b kz mm lb lc ld mn lf lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">注意，我们可以看到这里有重复。这样定义<code class="fe lv lw lx ly b">Comment</code>会更好:</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="d39b" class="mh jz iq ly b gy mi mj l mk ml">data Comment =<br/>  Comment<br/>    { id     :: Int<br/>    , payload :: NewComment<br/>    }</span></pre><p id="9b2f" class="pw-post-body-paragraph kw kx iq ky b kz mm lb lc ld mn lf lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">这将避免<code class="fe lv lw lx ly b">Comment</code>和<code class="fe lv lw lx ly b">NewComment</code>之间的重复。然而，这给了我们另一个问题。当我们只是派生出像这样定义的<code class="fe lv lw lx ly b">Comment</code>的<code class="fe lv lw lx ly b">JSON</code>实现时，它会创建一个嵌套的 JSON，结构如下:</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="eb3c" class="mh jz iq ly b gy mi mj l mk ml">{<br/> "id" : 42,<br/>  "payload" : {<br/>    "comment" : "this is my comment"<br/>  }<br/>}</span></pre><p id="fc4b" class="pw-post-body-paragraph kw kx iq ky b kz mm lb lc ld mn lf lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">React Admin 并不期望 JSON 以这种方式提供服务。我们可以通过自己实现<code class="fe lv lw lx ly b">toJSON</code>和<code class="fe lv lw lx ly b">fromJSON</code>来解决这个问题，而不是派生它，但是为了这个博客的目的，我们认为引入一个新的类型并吸收一点重复是很好的。</p><h1 id="cc3b" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">里德特</h1><p id="ff0d" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">使用 ReaderT monad 的想法是我第一次在 Michael Snoyman 的博客<a class="ae lu" href="https://tech.fpcomplete.com/blog/2017/06/readert-design-pattern" rel="noopener ugc nofollow" target="_blank">这里</a>上遇到的。这是一本列举利弊的好书。</p><p id="ba0c" class="pw-post-body-paragraph kw kx iq ky b kz mm lb lc ld mn lf lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">因此，让我们尝试向运行在 ReaderT monad 中的 API 类型添加一个 POST 方法。首先，我们需要添加变形金刚包</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="b5c8" class="mh jz iq ly b gy mi mj l mk ml">- transformers == 0.5.6.2</span></pre><p id="6853" class="pw-post-body-paragraph kw kx iq ky b kz mm lb lc ld mn lf lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">因为里德特住在那里。</p><p id="8582" class="pw-post-body-paragraph kw kx iq ky b kz mm lb lc ld mn lf lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">接下来，我们将声明我们的状态并将其包装在 ReaderT monad 中，如 Snoyman 文章中所解释的:</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="f959" class="mh jz iq ly b gy mi mj l mk ml">newtype State =<br/>  State<br/>    { comments :: TVar [Comment]<br/>    }<br/><br/>type AppM = ReaderT State Handler</span></pre><p id="d00b" class="pw-post-body-paragraph kw kx iq ky b kz mm lb lc ld mn lf lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">我们基本上扩展了处理程序 monad 的功能，也可以访问<code class="fe lv lw lx ly b">State</code>，State 包含一个可变的注释列表，受多线程保护。注意，在 Handler 上添加不同的 monad 对 web API 类型没有影响，这是应该的。</p><h1 id="6d02" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">使用我们的 AppM 单子</h1><p id="e4fc" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">目前，我们这样定义我们的服务器类型:</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="4ef9" class="mh jz iq ly b gy mi mj l mk ml">server :: Server WebApi<br/>server = listComments :&lt;|&gt; getComment</span></pre><p id="8ef6" class="pw-post-body-paragraph kw kx iq ky b kz mm lb lc ld mn lf lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">服务器在这里是简写为:</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="93d0" class="mh jz iq ly b gy mi mj l mk ml">type Server api = ServerT api Handler</span></pre><p id="0d27" class="pw-post-body-paragraph kw kx iq ky b kz mm lb lc ld mn lf lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">因此，当我们使用服务器类型时，我们选择使用默认的处理程序类型，这当然是有意义的。如果我们想选择自己的 monad 来运行它，我们需要使用 ServerT 来指定它，如下所示:</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="818a" class="mh jz iq ly b gy mi mj l mk ml">server :: ServerT WebApi AppM<br/>server = listComments :&lt;|&gt; getComment</span></pre><p id="54a0" class="pw-post-body-paragraph kw kx iq ky b kz mm lb lc ld mn lf lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">当我们试图编译它时，编译器不会特别高兴，因为我们在这里使用了服务器函数:</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="f773" class="mh jz iq ly b gy mi mj l mk ml">app :: Application<br/>app = corsConfig $ serve api server</span></pre><p id="f8d8" class="pw-post-body-paragraph kw kx iq ky b kz mm lb lc ld mn lf lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">它是这样定义的:</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="a32e" class="mh jz iq ly b gy mi mj l mk ml">serve :: (HasServer api '[]) =&gt; Proxy api -&gt; Server api -&gt; Application<br/>serve p = serveWithContext p EmptyContext</span></pre><p id="2f9c" class="pw-post-body-paragraph kw kx iq ky b kz mm lb lc ld mn lf lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">如你所见，这里的代码也引用了<code class="fe lv lw lx ly b">Server api</code>，默认情况下，它让我们在<code class="fe lv lw lx ly b">Handler</code>单子中运行。</p><h1 id="1f88" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">抬起来</h1><p id="e158" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">浏览文档时，我们注意到这个<a class="ae lu" href="https://hackage.haskell.org/package/servant-server-0.17/docs/Servant-Server.html#v:hoistServer" rel="noopener ugc nofollow" target="_blank"> hoistServer </a>函数:</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="a353" class="mh jz iq ly b gy mi mj l mk ml">HasServer api '[] =&gt; Proxy api -&gt; (forall x. m x -&gt; n x) -&gt; ServerT api m -&gt; ServerT api n</span></pre><p id="265c" class="pw-post-body-paragraph kw kx iq ky b kz mm lb lc ld mn lf lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">类型签名看起来有点令人生畏，但是我们可以看到，如果我们可以定义一个从我们的<code class="fe lv lw lx ly b">AppM</code>单子到<code class="fe lv lw lx ly b">Handler</code>单子的转换(因此是一个函数<code class="fe lv lw lx ly b">AppM a -&gt; Handler a</code>，我们可以对它调用<code class="fe lv lw lx ly b">hoistServer</code>，然后再次使用<code class="fe lv lw lx ly b">serve</code>来创建一个<code class="fe lv lw lx ly b">Application</code>，然后我们又回到了正轨。</p><p id="bf2c" class="pw-post-body-paragraph kw kx iq ky b kz mm lb lc ld mn lf lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">所以，我们的下一个挑战是为每个 a 创建一个接受一个<code class="fe lv lw lx ly b">AppM a</code>并从中生成一个<code class="fe lv lw lx ly b">Handler a</code>的函数。</p><p id="1899" class="pw-post-body-paragraph kw kx iq ky b kz mm lb lc ld mn lf lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">这可能不会立即显而易见，但我们可以为此使用<a class="ae lu" href="https://hackage.haskell.org/package/transformers-0.5.6.2/docs/Control-Monad-Trans-Reader.html#t:ReaderT" rel="noopener ugc nofollow" target="_blank"> runReaderT </a>。回忆:</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="72b3" class="mh jz iq ly b gy mi mj l mk ml">type AppM = ReaderT State Handler</span></pre><p id="d976" class="pw-post-body-paragraph kw kx iq ky b kz mm lb lc ld mn lf lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">以及<code class="fe lv lw lx ly b">runReaderT</code>的定义，这是一个为实现 ReaderT 类型类的任何东西定义的函数(我们的 AppM 就是这样做的<code class="fe lv lw lx ly b">AppM</code>):</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="ad9c" class="mh jz iq ly b gy mi mj l mk ml">runReaderT :: r -&gt; m a</span></pre><p id="9cf5" class="pw-post-body-paragraph kw kx iq ky b kz mm lb lc ld mn lf lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">其中 r 是我们的状态，m 是处理程序单子，我们非常接近一个将我们的<code class="fe lv lw lx ly b">AppM a</code>转换为<code class="fe lv lw lx ly b">Handler a</code>的函数。</p><p id="81d1" class="pw-post-body-paragraph kw kx iq ky b kz mm lb lc ld mn lf lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">如果我们这样定义我们的运行状态:</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="05b3" class="mh jz iq ly b gy mi mj l mk ml">runWithState :: State -&gt; AppM a -&gt; Handler a<br/>runWithState state appM = runReaderT appM state</span></pre><p id="1eb2" class="pw-post-body-paragraph kw kx iq ky b kz mm lb lc ld mn lf lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">一旦我们提供了一个初始状态，我们就有了转换函数。</p><p id="898a" class="pw-post-body-paragraph kw kx iq ky b kz mm lb lc ld mn lf lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">我们的服务器定义是这样的:</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="d187" class="mh jz iq ly b gy mi mj l mk ml">app :: Application<br/>app = corsConfig $ serve api server</span></pre><p id="0177" class="pw-post-body-paragraph kw kx iq ky b kz mm lb lc ld mn lf lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">收件人:</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="f90b" class="mh jz iq ly b gy mi mj l mk ml">app :: Application<br/>app = corsConfig $ serve api $ hoistServer api (runWithState undefined) serve</span></pre><p id="91eb" class="pw-post-body-paragraph kw kx iq ky b kz mm lb lc ld mn lf lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">我们的编译器又会开心了。当然，我们通过使用<code class="fe lv lw lx ly b">undefined</code>函数做了一点手脚，但是我觉得分两步做更好，这样你可以更清楚地看到转换的发生，你马上就会明白为什么了。</p><p id="e8d3" class="pw-post-body-paragraph kw kx iq ky b kz mm lb lc ld mn lf lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">因此，为了让它工作，我们需要在应用程序中传递一个初始状态。没什么大不了的，你只需要使用<a class="ae lu" href="http://hackage.haskell.org/package/stm-2.5.0.0/docs/Control-Concurrent-STM-TVar.html" rel="noopener ugc nofollow" target="_blank">事务变量</a>函数:</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="c9a3" class="mh jz iq ly b gy mi mj l mk ml">createInitialState :: IO State<br/>createInitialState = do<br/>  initalComments &lt;- atomically $ newTVar fixedComments<br/>  return $ State {comments = initalComments}</span></pre><p id="1e0b" class="pw-post-body-paragraph kw kx iq ky b kz mm lb lc ld mn lf lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">为此，您需要在 IO monad 中。幸运的是，应用程序的类型是应用程序，它是这样定义的:</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="491c" class="mh jz iq ly b gy mi mj l mk ml">type Application = Request -&gt; (Response -&gt; IO ResponseReceived) -&gt; IO ResponseReceived</span></pre><p id="9434" class="pw-post-body-paragraph kw kx iq ky b kz mm lb lc ld mn lf lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">所以我们在木卫一单子上运行。</p><p id="0eb4" class="pw-post-body-paragraph kw kx iq ky b kz mm lb lc ld mn lf lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">如果我们天真地像这样实现 app 函数:</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="fc50" class="mh jz iq ly b gy mi mj l mk ml">app :: Application<br/>app = do<br/>  initialState &lt;- createInitialState<br/>  corsConfig $ serve api (hoistServer api (runWithState initialState) server)</span></pre><p id="9760" class="pw-post-body-paragraph kw kx iq ky b kz mm lb lc ld mn lf lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">我们会让编译器向我们抱怨:</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="4671" class="mh jz iq ly b gy mi mj l mk ml">* Couldn't match type 'IO b0' with 'Network.Wai.Internal.Request -&gt; (Network.Wai.Internal.Response -&gt; IO Network.Wai.Internal.ResponseReceived) -&gt; IO Network.Wai.Internal.ResponseReceived' Expected type: Application Actual type: IO b0</span></pre><p id="f4d0" class="pw-post-body-paragraph kw kx iq ky b kz mm lb lc ld mn lf lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">这是因为我们认为我们在运行<code class="fe lv lw lx ly b">IO</code>单子，但我们没有，因为<code class="fe lv lw lx ly b">Application</code>是一个函数的简写。</p><p id="22f4" class="pw-post-body-paragraph kw kx iq ky b kz mm lb lc ld mn lf lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">如果我们这样定义 app 函数:</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="2de1" class="mh jz iq ly b gy mi mj l mk ml">app :: Application app req res = do initialState &lt;- createInitialState corsConfig (serve api (hoistServer api (runWithState initialState) server)) req res</span></pre><p id="95f6" class="pw-post-body-paragraph kw kx iq ky b kz mm lb lc ld mn lf lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">编译器又会高兴了。</p><p id="b57f" class="pw-post-body-paragraph kw kx iq ky b kz mm lb lc ld mn lf lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">我们可以这样定义它，使它更加明确:</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="7e1e" class="mh jz iq ly b gy mi mj l mk ml">createApplicationWithoutMiddleware :: State -&gt; Application<br/>createApplicationWithoutMiddleware initialState = serve api (hoistServer api (runWithState initialState) server)<br/><br/>app :: Application<br/>app req res = do<br/>  initialState &lt;- createInitialState<br/>  corsConfig (createApplicationWithoutMiddleware initialState) req res</span></pre><p id="dd97" class="pw-post-body-paragraph kw kx iq ky b kz mm lb lc ld mn lf lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated"><code class="fe lv lw lx ly b">corsConfig</code>函数的类型为<code class="fe lv lw lx ly b">Middleware</code>，定义如下:</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="5f2f" class="mh jz iq ly b gy mi mj l mk ml">type Middleware = Application -&gt; Application</span></pre><p id="8029" class="pw-post-body-paragraph kw kx iq ky b kz mm lb lc ld mn lf lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">因此，它接受一个应用程序，并返回给我们一个新的，与 CORS 的东西添加。然后，我们仍然必须应用我们匹配的请求元素和响应处理程序，并且我们的签名是正确的。</p><p id="ba28" class="pw-post-body-paragraph kw kx iq ky b kz mm lb lc ld mn lf lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">Pffw，我们还没到那一步。首先让我们的<code class="fe lv lw lx ly b">listComments</code>和<code class="fe lv lw lx ly b">getComment</code>函数在 AppM 单子中运行，因为它们仍然在<code class="fe lv lw lx ly b">Handler</code>单子中运行。</p><h1 id="9467" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">将 listComments 和 getComment 函数转换为 AppM monad</h1><p id="c65d" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">回想一下我们对 getComment 的定义是这样的:</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="6638" class="mh jz iq ly b gy mi mj l mk ml">getComment :: Int -&gt; AppM Comment<br/>getComment requestedId = <br/>  let maybeComment = L.find (\comment -&gt; Comment.id comment == requestedId) fixedComments<br/>   in maybe (throwError err404 {errBody = BSLazy.pack $ "Could not retrieve comment with id " ++ show requestedId}) return maybeComment</span></pre><p id="7638" class="pw-post-body-paragraph kw kx iq ky b kz mm lb lc ld mn lf lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">为了使用 TVar 中的状态，我们需要将其重构为:</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="c139" class="mh jz iq ly b gy mi mj l mk ml">getComment :: Int -&gt; AppM Comment<br/>getComment requestedId = do<br/>  commentsTransactionVar &lt;- asks comments<br/>  comments &lt;- liftIO $ readTVarIO commentsTransactionVar<br/>  let maybeComment = L.find (\comment -&gt; Comment.id comment == requestedId) comments<br/>   in maybe (throwError err404 {errBody = BSLazy.pack $ "Could not retrieve comment with id " ++ show requestedId}) return maybeComment</span></pre><p id="2216" class="pw-post-body-paragraph kw kx iq ky b kz mm lb lc ld mn lf lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">很简单，我们使用<a class="ae lu" href="https://hackage.haskell.org/package/transformers-0.5.6.2/docs/Control-Monad-Trans-Reader.html#v:asks" rel="noopener ugc nofollow" target="_blank"> asks </a>函数返回 TVar。commentsTransactionVar 的类型现在是:</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="3e36" class="mh jz iq ly b gy mi mj l mk ml">TVar [Comment]</span></pre><p id="5161" class="pw-post-body-paragraph kw kx iq ky b kz mm lb lc ld mn lf lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">现在我们利用<code class="fe lv lw lx ly b">readTVarIO</code>函数返回<code class="fe lv lw lx ly b">comments</code>，然后我们可以像以前一样继续。<code class="fe lv lw lx ly b">readTVarIO</code>函数在<code class="fe lv lw lx ly b">IO</code>中运行，所以我们需要提升它(因为我们的<code class="fe lv lw lx ly b">AppM</code>单子比<code class="fe lv lw lx ly b">IO</code>多)。</p><p id="9de5" class="pw-post-body-paragraph kw kx iq ky b kz mm lb lc ld mn lf lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated"><code class="fe lv lw lx ly b">listComments</code>功能非常相似:</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="1a9c" class="mh jz iq ly b gy mi mj l mk ml">listComments :: AppM (ListHeaders [Comment])<br/>listComments = do<br/>  commentsTransactionVar &lt;- asks comments<br/>  comments &lt;- liftIO $ readTVarIO commentsTransactionVar<br/>  return $ addHeader (List.length comments) comments</span></pre><p id="a27f" class="pw-post-body-paragraph kw kx iq ky b kz mm lb lc ld mn lf lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">好了，现在我们终于准备好实现我们的<code class="fe lv lw lx ly b">insertComment</code>函数了。</p><h1 id="616f" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">让我们最后实现 insertComment</h1><p id="2b48" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">你可以看到我们在<code class="fe lv lw lx ly b">listComments</code>和<code class="fe lv lw lx ly b">getComment</code>中使用 TVar 的方式，你可能会怀疑我们会以同样的方式使用它。问题是，如果我们首先原子地获取注释，更新它们，然后原子地写回它们，我们无法保证在我们的读和写之间，其他人没有执行写操作并使我们的操作无效。因此，我们将利用<code class="fe lv lw lx ly b">STM</code>并像这样自动运行整个操作:</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="9a82" class="mh jz iq ly b gy mi mj l mk ml">insertComment :: NewComment -&gt; AppM NoContent<br/>insertComment newComment = do<br/>  commentsTransactionVar &lt;- asks comments<br/>  liftIO $ atomically $ do<br/>    comments &lt;- readTVar commentsTransactionVar<br/>    let nextId = List.length comments + 1<br/>    let comment = fromNewComment nextId newComment<br/>    let updateComments = List.insert comment comments<br/>    writeTVar commentsTransactionVar updateComments<br/>  return NoContent</span></pre><p id="2ce2" class="pw-post-body-paragraph kw kx iq ky b kz mm lb lc ld mn lf lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">我们计算<code class="fe lv lw lx ly b">nextId</code>的方法有点笨拙，一旦我们允许删除，就会给我们带来麻烦。但是让我们假装我们现在不会那样做。</p><p id="30f8" class="pw-post-body-paragraph kw kx iq ky b kz mm lb lc ld mn lf lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">让我们稍微关注一下我们在这里做的事情，我们读取注释，创建一个新的注释，插入它并更新事务性变量，所有这些都是自动完成的。原子性取决于 Haskell 中的<a class="ae lu" href="http://hackage.haskell.org/package/stm-2.5.0.0/docs/Control-Monad-STM.html" rel="noopener ugc nofollow" target="_blank"> STM 实现。你可以把它想象成某种乐观锁，但是在数据库之外，只是在内存中。原子函数将重试，直到成功。如果有人在我们读取和写入 TVar 之间写了 TVar，它可能会失败，但它会重试。因此，重要的是不要在原子块中产生副作用，因为它们可能会被执行多次，以防我们的代码片段需要重试。通常不可能产生副作用，因为 STM 没有实现 MonadIO。你当然可以用 unsafeIO still 搬起石头砸自己的脚，但最好不要这样做。</a></p><p id="c8b0" class="pw-post-body-paragraph kw kx iq ky b kz mm lb lc ld mn lf lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">请注意，如果我们像这样实现我们的代码片段:</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="da3c" class="mh jz iq ly b gy mi mj l mk ml">insertCommentNotSoSafe :: NewComment -&gt; AppM NoContent<br/>insertCommentNotSoSafe newComment = do<br/>  commentsTransactionVar &lt;- asks comments<br/>  comments &lt;- liftIO $ readTVarIO commentsTransactionVar<br/>  let nextId = List.length comments + 1<br/>  let comment = fromNewComment nextId newComment<br/>  let updateComments = List.insert comment comments<br/>  liftIO $ atomically $ writeTVar commentsTransactionVar updateComments<br/>  return NoContent</span></pre><p id="d036" class="pw-post-body-paragraph kw kx iq ky b kz mm lb lc ld mn lf lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">我们仍然不会安全。我们可以有另一个 insert，例如在 TVar 中看到两个元素，在我们之前添加一个 id 为 3 的新元素，没有什么可以阻止我们插入 id 为 3 的第二个注释。</p><p id="750d" class="pw-post-body-paragraph kw kx iq ky b kz mm lb lc ld mn lf lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">注意，这不是处理 STM 的理想方式，我们将在下一篇博客中研究<a class="ae lu" href="http://hackage.haskell.org/package/stm-2.5.0.0/docs/Control-Concurrent-STM-TVar.html#v:stateTVar" rel="noopener ugc nofollow" target="_blank">state var</a>来更优雅地表达这一点。看到幕后发生的事情总是令人愉快的，这也是我们目前保留这个实现的原因。</p><p id="2963" class="pw-post-body-paragraph kw kx iq ky b kz mm lb lc ld mn lf lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">好了，我们终于更新了服务器，可以接收新的评论了，让我们回到 React-Admin。</p><h1 id="f7f4" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">反应-管理和发布</h1><p id="ae09" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我们将像这样创建我们的创建组件:</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="1006" class="mh jz iq ly b gy mi mj l mk ml">export const CommentsCreate = props =&gt; (<br/>    &lt;Create {...props}&gt;<br/>        &lt;SimpleForm&gt;<br/>            &lt;TextInput source="content" validate={required()}/&gt;<br/>        &lt;/SimpleForm&gt;<br/>    &lt;/Create&gt;<br/>)</span></pre><p id="278b" class="pw-post-body-paragraph kw kx iq ky b kz mm lb lc ld mn lf lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">我们只对<code class="fe lv lw lx ly b">comment</code>的内容感兴趣，而<code class="fe lv lw lx ly b">id</code>是由后端的 REST 服务器发出的。当然，<code class="fe lv lw lx ly b">content</code>是必填字段，因此有了<code class="fe lv lw lx ly b">validation-required</code>属性。我们可以像这样轻松地使用<code class="fe lv lw lx ly b">create</code>组件:</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="a63d" class="mh jz iq ly b gy mi mj l mk ml">const App = () =&gt; (<br/>    &lt;Admin dataProvider={dataProvider}&gt;<br/>        &lt;Resource name="comments" list={CommentsList} show={CommentsShow} create={CommentsCreate}/&gt;<br/>    &lt;/Admin&gt;<br/>);</span></pre><p id="b71f" class="pw-post-body-paragraph kw kx iq ky b kz mm lb lc ld mn lf lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">将该组件添加到<code class="fe lv lw lx ly b">Admin</code>组件的<code class="fe lv lw lx ly b">create</code>属性后，我们将在 UI 中看到一个创建链接:</p><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi mr"><img src="../Images/f5df36f8977565ba5887dce062a2c5e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Um2z40uPxijXXkdG.png"/></div></div></figure><p id="df77" class="pw-post-body-paragraph kw kx iq ky b kz mm lb lc ld mn lf lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">当我们点击它时，我们的<code class="fe lv lw lx ly b">Create-component</code>被触发，我们可以填写新的<code class="fe lv lw lx ly b">comments</code>，但是当我们试图保存时，我们将再次得到我们的网络错误。检查控制台证实了这一点，我们需要处理更多的 CORS 的东西。</p><h1 id="613b" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">重访 CORS</h1><p id="9cc2" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">要知道哪个请求被发起和拒绝，我们需要在浏览器中打开开发者工具上的网络选项卡，并尝试再次添加一个<code class="fe lv lw lx ly b">comment</code>。然后，我们将看到正在启动的请求是一个选项请求。这是 CORS 规范的一部分，对于每个帖子，我们首先验证是否允许我们发布，这是通过一个<code class="fe lv lw lx ly b">options</code>请求来完成的。那么，让我们回到我们的服务器，展开 CORS 配置。</p><p id="13a1" class="pw-post-body-paragraph kw kx iq ky b kz mm lb lc ld mn lf lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">允许的默认方法是 GET、HEAD 和 POST。选项不在其中，所以我们应该添加它。当我们检查 CORS 记录时，我们看到这些方法的类型是:</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="f404" class="mh jz iq ly b gy mi mj l mk ml">corsMethods ∷ ![HTTP.Method]</span></pre><p id="4b26" class="pw-post-body-paragraph kw kx iq ky b kz mm lb lc ld mn lf lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated"><code class="fe lv lw lx ly b">HTTP</code>是 http-types 包中的一个模块，我们必须先将它添加到我们的 package.yaml 中:</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="5007" class="mh jz iq ly b gy mi mj l mk ml">- http-types == 0.12.3</span></pre><p id="7590" class="pw-post-body-paragraph kw kx iq ky b kz mm lb lc ld mn lf lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">然后我们可以导入这个包，在这个例子中被限定为<code class="fe lv lw lx ly b">HttpTypes</code>，并将正确的方法添加到我们的 CORS 记录中:</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="07aa" class="mh jz iq ly b gy mi mj l mk ml">corsConfig :: Middleware<br/>corsConfig = cors (const $ Just policy)<br/>  where<br/>    policy =<br/>      simpleCorsResourcePolicy<br/>        { corsExposedHeaders = Just ["X-Total-Count"],<br/>          corsMethods = [HttpTypes.methodGet, HttpTypes.methodPost, HttpTypes.methodHead, HttpTypes.methodOptions]<br/>        }</span></pre><p id="7df1" class="pw-post-body-paragraph kw kx iq ky b kz mm lb lc ld mn lf lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">请记住，我们必须在这里添加默认的方法，并且在覆盖完整列表时覆盖<code class="fe lv lw lx ly b">simpleCorsResourcePolicy</code>的内容。加完这些方法，我们再来检查一下！</p><p id="d9b2" class="pw-post-body-paragraph kw kx iq ky b kz mm lb lc ld mn lf lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">嗯，还是老样子。也许我们现在应该检查错误响应。如果我们这样做，我们会看到这一点:</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="a8d4" class="mh jz iq ly b gy mi mj l mk ml">HTTP header requested in Access-Control-Request-Headers of CORS request is not supported; requested: content-type; supported are Accept, Accept-Language, Content-Language.</span></pre><p id="4ae4" class="pw-post-body-paragraph kw kx iq ky b kz mm lb lc ld mn lf lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">(注意，有时响应错误仅在您尝试在开发人员选项的网络选项卡中重新发送请求时显示。似乎是火狐的怪癖)</p><p id="8698" class="pw-post-body-paragraph kw kx iq ky b kz mm lb lc ld mn lf lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">根据<a class="ae lu" href="https://developer.mozilla.org/nl/docs/Web/HTTP/CORS" rel="noopener ugc nofollow" target="_blank"> Mozilla cors 文章</a>中对内容类型的简单 CORS 描述(与我们之前分享的内容相同)，如果内容类型是以下内容之一，则应该被允许:</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="8a30" class="mh jz iq ly b gy mi mj l mk ml">The only allowed values for the Content-Type header are: application/x-www-form-urlencoded multipart/form-data text/plain</span></pre><p id="69dd" class="pw-post-body-paragraph kw kx iq ky b kz mm lb lc ld mn lf lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">当我们检查请求时，我们看到标题的值为 text/html。好了，我们现在可以选择是为内容类型添加一个总括接受还是对其进行提炼。为了简单起见，我们将对 content-type 头进行一揽子接受。我们的 CORS 配置变成了:</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="da53" class="mh jz iq ly b gy mi mj l mk ml">import qualified Network.HTTP.Types as HttpTypes<br/>import Network.Wai (Middleware)<br/>import Network.Wai.Middleware.Cors<br/>  ( cors,<br/>    corsExposedHeaders,<br/>    corsMethods,<br/>    corsRequestHeaders,<br/>    simpleCorsResourcePolicy,<br/>  )<br/><br/>corsConfig :: Middleware<br/>corsConfig = cors (const $ Just policy)<br/>  where<br/>    policy =<br/>      simpleCorsResourcePolicy<br/>        { corsExposedHeaders = Just ["X-Total-Count"],<br/>          corsMethods = [HttpTypes.methodGet, HttpTypes.methodPost, HttpTypes.methodHead, HttpTypes.methodOptions],<br/>          corsRequestHeaders = [HttpTypes.hContentType]<br/>        }</span></pre><p id="d78f" class="pw-post-body-paragraph kw kx iq ky b kz mm lb lc ld mn lf lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">好吧，如果我们现在再试一次，它必须工作，不是吗，我们填写我们的内容，并按下保存按钮，看到…另一个错误。json 没有被定义。</p><h1 id="e99e" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">返回新创建的评论</h1><p id="fba6" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">这有点难，但这是 React 告诉我们它希望我们的响应包含 JSON 类型的主体的方式。这与 React 如何处理我们的响应的内部机制有关，但是它告诉我们它想要一个 JSON 响应体，而不仅仅是我们指定的<code class="fe lv lw lx ly b">NoContent</code>。哦，是的，记住，我们的 POST 方法不返回任何内容。在某种程度上，它不需要，但是 React-admin 希望新创建的<code class="fe lv lw lx ly b">comment</code>作为 JSON 返回。回到我们的 REST 服务器，这意味着一些变化。我们的帖子资源类型需要更改以返回<code class="fe lv lw lx ly b">comment</code>。</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="9ec8" class="mh jz iq ly b gy mi mj l mk ml">"comments" :&gt; ReqBody '[JSON] NewComment :&gt; Post '[JSON] Comment</span></pre><p id="e2f4" class="pw-post-body-paragraph kw kx iq ky b kz mm lb lc ld mn lf lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">我们的实现还需要返回<code class="fe lv lw lx ly b">comment</code>:</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="f488" class="mh jz iq ly b gy mi mj l mk ml">insertComment :: NewComment -&gt; AppM Comment<br/>insertComment newComment = do<br/>  commentsTransactionVar &lt;- asks comments<br/>  liftIO $ atomically $ do<br/>    comments &lt;- readTVar commentsTransactionVar<br/>    let nextId = List.length comments + 1<br/>    let comment = fromNewComment nextId newComment<br/>    let updateComments = List.insert comment comments<br/>    writeTVar commentsTransactionVar updateComments<br/>    return comment</span></pre><p id="4002" class="pw-post-body-paragraph kw kx iq ky b kz mm lb lc ld mn lf lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">当我们现在尝试它时，我们将看到插入过程工作正常，但是当我们尝试检索 id 3 时，它似乎不存在。奇怪。事实上，无论我们做什么，唯一得到回报的是我们的初始状态。</p><p id="a5c9" class="pw-post-body-paragraph kw kx iq ky b kz mm lb lc ld mn lf lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">哦该死的。回想一下，我们提到过初始化不应该在<code class="fe lv lw lx ly b">Application</code>类型内部完成，因为<code class="fe lv lw lx ly b">Application</code>是为每个请求运行的。确实如此。如果我们给 api 函数添加一个<code class="fe lv lw lx ly b">print</code>语句:</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="232c" class="mh jz iq ly b gy mi mj l mk ml">app :: Application<br/>app req res = do<br/>  print "create initial state"<br/>  initialState &lt;- createInitialState<br/>  corsConfig (createApplicationWithoutMiddleware initialState) req res</span></pre><p id="d3cd" class="pw-post-body-paragraph kw kx iq ky b kz mm lb lc ld mn lf lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">我们会注意到，这个 print 语句出现在每个请求中。愚蠢的我们。我们尽一切努力更新我们内部状态，然后每次都用基本状态覆盖它。好吧，让我们来解决这个问题:</p><pre class="lz ma mb mc gt md ly me mf aw mg bi"><span id="a596" class="mh jz iq ly b gy mi mj l mk ml">createInitialState :: IO State<br/>createInitialState = do<br/>  initalComments &lt;- atomically $ newTVar fixedComments<br/>  return $ State {comments = initalComments}</span><span id="523d" class="mh jz iq ly b gy mw mj l mk ml">app :: ServerT WebApi Handler -&gt; Application<br/>app initedServer =<br/>  corsConfig $ serve api initedServer</span><span id="78ed" class="mh jz iq ly b gy mw mj l mk ml">start :: Int -&gt; IO ()<br/>start port = do<br/>  initialState &lt;- createInitialState<br/>  let initedServer = hoistServer api (runWithState initialState) server<br/>  run port $ app initedServer</span></pre><p id="7901" class="pw-post-body-paragraph kw kx iq ky b kz mm lb lc ld mn lf lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated">现在我们在调用 run 函数之前初始化服务器。为每个请求运行我们的<code class="fe lv lw lx ly b">app</code>的是<code class="fe lv lw lx ly b">run</code>函数。如果我们现在添加一个<code class="fe lv lw lx ly b">comment</code>，我们将不再看到错误，我们将看到我们新创建的注释到达。</p><h1 id="9981" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">结论</h1><p id="b419" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">好吧，我们成功了。这是一项重要的工作，经过了组成我们应用程序的所有层，必须学习关于 Servant、CORS 和 React-Admin 的新知识。我们将在下一篇博客中继续做一些更简单的事情，删除一些东西。这个博客的代码可以在<a class="ae lu" href="https://gitlab.com/KasperJanssens/servant-blog/-/tags/v0.3" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p></div><div class="ab cl mx my hu mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="ij ik il im in"><p id="04a3" class="pw-post-body-paragraph kw kx iq ky b kz mm lb lc ld mn lf lg lh mo lj lk ll mp ln lo lp mq lr ls lt ij bi translated"><em class="ne">最初发布于</em><a class="ae lu" href="https://propellant.tech/blogs/servant-and-react-admin-4/" rel="noopener ugc nofollow" target="_blank"><em class="ne">https://propellant . tech</em></a><em class="ne">。</em></p></div></div>    
</body>
</html>