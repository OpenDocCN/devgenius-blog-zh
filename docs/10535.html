<html>
<head>
<title>1.1 Mazes In Golang</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">1.1 戈朗的迷宫</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/mazes-in-golang-bdd247c39a79?source=collection_archive---------1-----------------------#2022-11-09">https://blog.devgenius.io/mazes-in-golang-bdd247c39a79?source=collection_archive---------1-----------------------#2022-11-09</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="5c1b" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">递归和回溯-第 1 部分</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/dbb48df544b5b605f65d76b8ec3d7075.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zqotshR5lTGyKOLRze5PkA.png"/></div></div></figure><h2 id="9641" class="ko kp in bd kq kr ks dn kt ku kv dp kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">定义</h2><blockquote class="lk ll lm"><p id="d9a4" class="ln lo lp lq b lr ls jo lt lu lv jr lw lx ly lz ma mb mc md me mf mg mh mi mj ig bi translated"><strong class="lq io">数组:</strong> <em class="in">连续分配和收集同质元素。<br/> </em> <strong class="lq io"> 2D 数组:</strong> <em class="in">二维数组表示大小为[r×c]的矩阵，其中 r 表示行数，c 表示列数。</em></p></blockquote><h2 id="eebd" class="ko kp in bd kq kr ks dn kt ku kv dp kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">先决条件</h2><ul class=""><li id="8d55" class="mk ml in lq b lr mm lu mn kx mo lb mp lf mq mj mr ms mt mu bi translated">数组/ 2D 数组中的遍历。</li></ul></div><div class="ab cl mv mw hr mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ig ih ii ij ik"><h1 id="c4d6" class="nc kp in bd kq nd ne nf kt ng nh ni kw jt nj ju la jw nk jx le jz nl ka li nm bi translated">递归</h1><p id="8b5d" class="pw-post-body-paragraph ln lo in lq b lr mm jo lt lu mn jr lw kx nn lz ma lb no md me lf np mh mi mj ig bi translated"><strong class="lq io"> <em class="lp">问:什么是递归？</em> </strong> <br/> <em class="lp"> A. </em>递归是<strong class="lq io">就自身而言被定义的东西</strong>。在编程界，这个<strong class="lq io">东西</strong>是一个叫做递归函数的函数。</p><p id="8587" class="pw-post-body-paragraph ln lo in lq b lr ls jo lt lu lv jr lw kx ly lz ma lb mc md me lf mg mh mi mj ig bi translated"><strong class="lq io"> <em class="lp">问:什么是递归函数？</em></strong><em class="lp"><br/></em>a .<em class="lp"/>递归函数是通过调用自身的副本来解决问题的函数；因此就其本身而言。</p><p id="c46a" class="pw-post-body-paragraph ln lo in lq b lr ls jo lt lu lv jr lw kx ly lz ma lb mc md me lf mg mh mi mj ig bi translated"><strong class="lq io"> <em class="lp">问:我们如何中断这个函数调用？这不是无限通话吗</em>😕<em class="lp">…</em></strong><em class="lp"><br/>a .</em>这些函数旨在通过将较大的问题分解成较小的子问题来解决，直到问题得到解决或达到终止条件。让我们用一个例子来理解这一点。<br/> <strong class="lq io">对于 Eg. </strong>从<code class="fe nq nr ns nt b">A -&gt; B -&gt; C -&gt; D</code>有一条路径。问题说“我能从 A 点到 D 点吗？”<br/>所以我们可以问自己以下问题…</p><p id="fa33" class="pw-post-body-paragraph ln lo in lq b lr ls jo lt lu lv jr lw kx ly lz ma lb mc md me lf mg mh mi mj ig bi translated"><strong class="lq io">主要问题:</strong> <em class="lp">我能到达 A 点到 D 点吗？<br/> </em> <strong class="lq io">子问题 1: </strong> <em class="lp">我能到达 A 点到 C 点吗？<br/> </em> <strong class="lq io">子问题 2: </strong> <em class="lp">我能到达 A 点到 B 点吗？<br/> </em> <strong class="lq io">子问题 3: </strong> <em class="lp">我能到达 B 点到 C 点吗？<br/> </em> <strong class="lq io">子问题 4: </strong> <em class="lp">我能到达 C 点到 D 点吗？</em></p><p id="e967" class="pw-post-body-paragraph ln lo in lq b lr ls jo lt lu lv jr lw kx ly lz ma lb mc md me lf mg mh mi mj ig bi translated">每次我都问自己同一个问题，即两点之间是否存在路径。并且，每个问题的中间点数减少 1。如果我得到了这些问题的答案，我可以肯定地说，我们可以到达 d 点。现在关于走出环路的问题，很容易得出结论，当我们完成所有景点的旅行时，我们可以走出环路。如果我们达到 D，那就是成功，否则就是失败。</p><p id="db0a" class="pw-post-body-paragraph ln lo in lq b lr ls jo lt lu lv jr lw kx ly lz ma lb mc md me lf mg mh mi mj ig bi translated"><strong class="lq io"> <em class="lp">问:为什么要递归？</em> </strong> <em class="lp"> <br/> A. </em>简单的回答是，每当一个巨大的任务需要被分解成更小的任务时，我们可以借助递归；条件是，即使我们将任务分解成多个子任务，每个子任务的问题陈述保持不变。</p><h2 id="3b42" class="ko kp in bd kq kr ks dn kt ku kv dp kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">递归树</h2><blockquote class="lk ll lm"><p id="adc3" class="ln lo lp lq b lr ls jo lt lu lv jr lw lx ly lz ma mb mc md me mf mg mh mi mj ig bi translated">n<strong class="lq io">ote:</strong>T3】在递归下，我们要多次求解同一个子问题。这可以使用动态编程进一步优化(<strong class="lq io"><em class="in"/></strong><em class="in">)。</em></p></blockquote><p id="da0a" class="pw-post-body-paragraph ln lo in lq b lr ls jo lt lu lv jr lw kx ly lz ma lb mc md me lf mg mh mi mj ig bi translated">让我们用下面的问题来理解这一点</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/b5be9da2380ddfbff5ca749e091abb4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:544/format:webp/1*P_-8pna6tP3DQ3pXq0bGiQ.jpeg"/></div></figure><p id="0fa0" class="pw-post-body-paragraph ln lo in lq b lr ls jo lt lu lv jr lw kx ly lz ma lb mc md me lf mg mh mi mj ig bi translated"><strong class="lq io"> Q .打印从点 A (3，3)到 B(1，1)的所有可能路径数。<br/> Q .打印从 A 点(3，3)到 B 点(1，1)的所有可能路径。</strong></p><blockquote class="lk ll lm"><p id="0e54" class="ln lo lp lq b lr ls jo lt lu lv jr lw lx ly lz ma mb mc md me mf mg mh mi mj ig bi translated"><strong class="lq io">约束:</strong> <em class="in">为了简单起见，只有合法的步骤是向右移动和向下移动。</em></p></blockquote><p id="2d38" class="pw-post-body-paragraph ln lo in lq b lr ls jo lt lu lv jr lw kx ly lz ma lb mc md me lf mg mh mi mj ig bi translated"><strong class="lq io">分析:</strong>根据给定的约束条件，我们只有两种可能的选择，要么向右移动，要么向下移动。</p><p id="6d5a" class="pw-post-body-paragraph ln lo in lq b lr ls jo lt lu lv jr lw kx ly lz ma lb mc md me lf mg mh mi mj ig bi translated">由于一个矩阵是行和列的组合，我们可以在到达目的地时观察以下几点:<br/> <em class="lp"> 1 .每当我们向右移动时，我们就向下移动一列，即列值减一。例如(3，3)——&gt;(3，2) <br/> 2。类似地，每当我们向下移动时，我们就向下移动一行，即行值减一。例如(3，3)——&gt;(2，3) <br/> 3。当这个减量达到第 1 行和第 1 列时，我们就到达了目的地。<br/> 4。每当我们到达最后一列时，我们不能继续下一列，即列值为 1，我们需要停止递归。<br/> 5。每当我们到达最后一行时，我们不能继续下一行，即行值为 1，我们需要停止递归。</em></p><p id="6091" class="pw-post-body-paragraph ln lo in lq b lr ls jo lt lu lv jr lw kx ly lz ma lb mc md me lf mg mh mi mj ig bi translated"><strong class="lq io">目标 1: </strong>显示从源(3，3)到目的地(1，1)的所有可能的路径计数。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nv"><img src="../Images/944c2861fa4d518c21b30b07a3970f4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rou-jeYfDjXsBS4txZ59tA.jpeg"/></div></div></figure><p id="1b00" class="pw-post-body-paragraph ln lo in lq b lr ls jo lt lu lv jr lw kx ly lz ma lb mc md me lf mg mh mi mj ig bi translated">我们来评价一下条件:<br/> <em class="lp"> 1。每当我们到达 row:1 或 column:1 时，我们就可以得到路径的数量。当我们到达 row:1 或 column:1 时，有一条从该行到最后一个单元格(1，1)的路径。<br/> 2。我们需要避免超出行:1 或列:1，即在行:1 或列:1 终止函数调用。</em></p><p id="28e1" class="pw-post-body-paragraph ln lo in lq b lr ls jo lt lu lv jr lw kx ly lz ma lb mc md me lf mg mh mi mj ig bi translated"><strong class="lq io">目标 2: </strong>显示从源(3，3)到目的地(1，1)的所有可能路径。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nw"><img src="../Images/4285e786b87127250e1a4062f90b4d3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6IY6oxll9-ghonjnWh0nAQ.jpeg"/></div></div></figure><p id="8421" class="pw-post-body-paragraph ln lo in lq b lr ls jo lt lu lv jr lw kx ly lz ma lb mc md me lf mg mh mi mj ig bi translated">我们来评估一下条件:<br/> <em class="lp"> 1。我们需要遍历列，直到列:1，<br/> 2。我们需要遍历行，直到行变成行:1。<br/> 3。当我们到达最后一个单元格时，即(1，1)，我们需要避免超出行:1 和列:1，即行:1 和列:1 处的终止函数调用。我们可以打印整个路径。</em></p></div><div class="ab cl mv mw hr mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ig ih ii ij ik"><h1 id="2027" class="nc kp in bd kq nd ne nf kt ng nh ni kw jt nj ju la jw nk jx le jz nl ka li nm bi translated">密码</h1><p id="cc55" class="pw-post-body-paragraph ln lo in lq b lr mm jo lt lu mn jr lw kx nn lz ma lb no md me lf np mh mi mj ig bi translated">包有助于维护代码。它还提高了代码的可读性。go 中的本地包只不过是一个包含 go 文件的目录。这里我们有一个包含<code class="fe nq nr ns nt b">maze.go</code>文件的迷宫文件夹。</p><blockquote class="lk ll lm"><p id="ca37" class="ln lo lp lq b lr ls jo lt lu lv jr lw lx ly lz ma mb mc md me mf mg mh mi mj ig bi translated"><strong class="lq io">注意:</strong> <em class="in">一个包目录下的所有文件必须涉及相同的包名。</em></p></blockquote><pre class="kd ke kf kg gt nx nt ny nz aw oa bi"><span id="ff6a" class="ko kp in nt b gy ob oc l od oe">// Directory Structure<br/>.<br/>├── go.mod            // Mod File  <br/>├── main.go           // Main<br/>└── maze              // Package<br/>    └── intmaze.go</span></pre><h2 id="07d4" class="ko kp in bd kq kr ks dn kt ku kv dp kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">1.带进口的包装定义</h2><pre class="kd ke kf kg gt nx nt ny nz aw oa bi"><span id="f42d" class="ko kp in nt b gy ob oc l od oe">package maze</span><span id="007e" class="ko kp in nt b gy of oc l od oe">import "fmt"</span></pre><h2 id="c0f3" class="ko kp in bd kq kr ks dn kt ku kv dp kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">2.类型定义</h2><pre class="kd ke kf kg gt nx nt ny nz aw oa bi"><span id="40e9" class="ko kp in nt b gy ob oc l od oe">type MazeServicer interface {<br/>    RightDown()<br/>}</span><span id="798d" class="ko kp in nt b gy of oc l od oe">type maze struct {<br/>    rows int<br/>    cols int<br/>}</span></pre><h2 id="c57e" class="ko kp in bd kq kr ks dn kt ku kv dp kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">3.方法</h2><pre class="kd ke kf kg gt nx nt ny nz aw oa bi"><span id="c02f" class="ko kp in nt b gy ob oc l od oe">func (m *maze) RightDown() {<br/>    fmt.Println("Count:", countRightDown(m.rows, m.cols))<br/>    printPathRightDown("", m.rows, m.cols)<br/>}</span></pre><h2 id="47be" class="ko kp in bd kq kr ks dn kt ku kv dp kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">4.递归函数</h2><ul class=""><li id="9e9c" class="mk ml in lq b lr mm lu mn kx mo lb mp lf mq mj mr ms mt mu bi translated">统计从<code class="fe nq nr ns nt b">Point(3,3)</code>到<code class="fe nq nr ns nt b">Point(1,1)</code>的可用路径总数。</li></ul><pre class="kd ke kf kg gt nx nt ny nz aw oa bi"><span id="f09a" class="ko kp in nt b gy ob oc l od oe">func countRightDown(r, c int) int {<br/>    if r == 1 || c == 1 {<br/>        return 1<br/>    }<br/>    down := countRightDown(r-1, c)<br/>    right := countRightDown(r, c-1)<br/>    return down + right<br/>}</span></pre><ul class=""><li id="09e8" class="mk ml in lq b lr ls lu lv kx og lb oh lf oi mj mr ms mt mu bi translated">打印从<code class="fe nq nr ns nt b">Point(3,3)</code>到<code class="fe nq nr ns nt b">Point(1,1)</code>的所有可用路径。</li></ul><pre class="kd ke kf kg gt nx nt ny nz aw oa bi"><span id="3ba6" class="ko kp in nt b gy ob oc l od oe">func printPathRightDown(path string, r, c int) {<br/>    if r == 1 &amp;&amp; c == 1 {<br/>        fmt.Println(path)<br/>        return<br/>    }<br/>    if r &gt; 1 {<br/>        printPathRightDown(path+"D", r-1, c)<br/>    }<br/>    if c &gt; 1 {<br/>        printPathRightDown(path+"R", r, c-1)<br/>    }<br/>}</span></pre><h2 id="e867" class="ko kp in bd kq kr ks dn kt ku kv dp kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">5.构造器</h2><p id="43cc" class="pw-post-body-paragraph ln lo in lq b lr mm jo lt lu mn jr lw kx nn lz ma lb no md me lf np mh mi mj ig bi translated">用所需的行和列初始化迷宫指针(r，c)。返回迷宫指针。</p><pre class="kd ke kf kg gt nx nt ny nz aw oa bi"><span id="52ba" class="ko kp in nt b gy ob oc l od oe">func InitMaze(r, c int) MazeServicer {<br/>    return &amp;maze{<br/>        rows: r,<br/>        cols: c,<br/>    }<br/>}</span></pre><h1 id="5b14" class="nc kp in bd kq nd oj nf kt ng ok ni kw jt ol ju la jw om jx le jz on ka li nm bi translated">主要的</h1><pre class="kd ke kf kg gt nx nt ny nz aw oa bi"><span id="73ca" class="ko kp in nt b gy ob oc l od oe">package main</span><span id="fab8" class="ko kp in nt b gy of oc l od oe">import "dsa/maze"</span><span id="5470" class="ko kp in nt b gy of oc l od oe">func main() {<br/>    m := maze.InitMaze(3, 3)<br/>    m.RightDown()<br/>}</span><span id="4ca4" class="ko kp in nt b gy of oc l od oe">/*<br/>Count: 6<br/>DDRR<br/>DRDR<br/>DRRD<br/>RDDR<br/>RDRD<br/>RRDD<br/>*/</span></pre><p id="d4d5" class="pw-post-body-paragraph ln lo in lq b lr ls jo lt lu lv jr lw kx ly lz ma lb mc md me lf mg mh mi mj ig bi translated"><em class="lp">希望这篇文章有助于对 golang 中的递归有一个基本的了解。如有错误或进一步建议，请在下方评论。谢谢！</em></p></div></div>    
</body>
</html>