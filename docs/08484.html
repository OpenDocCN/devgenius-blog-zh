<html>
<head>
<title>It’s Ok to Fail: Expecting Test Failures in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">失败没关系:预期 Go 中的测试失败</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/its-ok-to-fail-expecting-test-failures-in-go-5b359a04415c?source=collection_archive---------5-----------------------#2022-06-18">https://blog.devgenius.io/its-ok-to-fail-expecting-test-failures-in-go-5b359a04415c?source=collection_archive---------5-----------------------#2022-06-18</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="879f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ki">当感觉不对劲的时候</em></p><p id="2806" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最近，我发现自己处于一种奇怪的情况，需要 Golang 中的一个单元测试失败才能认为它成功。虽然这对于语言来说是非常罕见的情况，但它给了我们一个机会来更好地理解测试框架是如何运行的，以及我们如何可能实现这一点。像往常一样…系好安全带，开始阅读。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/dd2779fd9b44b8ef8ccd7f3ecb88a537.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mAly_xSnBgYU5OwG2wglVw.jpeg"/></div></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk translated">照片由<a class="ae kz" href="https://unsplash.com/@tangcindy?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Cindy Tang </a>在<a class="ae kz" href="http://localhost:3000/collections/4492909/fail-faster?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="504d" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">问题是</h1><p id="f5fe" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">其他编程语言中的测试框架为开发人员提供了通知框架<em class="ki">测试失败是“没问题的”</em>的方法，这确实是测试被认为成功的预期行为。在 Golang 不是这样的。归根结底，这是由于该语言管理错误的方式，并期望开发人员来处理它们。为了更好地理解这个问题，下面是其他编程语言中的一些例子:</p><pre class="kk kl km kn gt md me mf mg aw mh bi"><span id="255d" class="mi lb in me b gy mj mk l ml mm">// Language: Java, Framework: JUnit 4,5</span><span id="b377" class="mi lb in me b gy mn mk l ml mm">import org.junit.Test<br/>....</span><span id="6fa0" class="mi lb in me b gy mn mk l ml mm">@Test(<strong class="me io">expected = NullPointerException.class</strong>) <br/>public void TestMethodWithNull() {     <br/>    String fullName = null;     <br/>    NameExtractor testCandidate = new NameExtractor();<br/>    String firstName = testCandidate.getFirstName(fullName)<br/>}</span><span id="5db0" class="mi lb in me b gy mn mk l ml mm">...</span><span id="f5a7" class="mi lb in me b gy mn mk l ml mm">// Language: Python 2,3, Framework: unittest</span><span id="52a8" class="mi lb in me b gy mn mk l ml mm">import unittest</span><span id="60d8" class="mi lb in me b gy mn mk l ml mm">class TestFailures(unittest.TestCase)</span><span id="724e" class="mi lb in me b gy mn mk l ml mm"> def test_method_with_error_1(self):<br/>   candidate = NameExtractor() <br/>   <strong class="me io">self.assertRaises(SomeError, candidate.get_first_name, None)</strong>:<br/> <br/> <strong class="me io">@unittest.expectFailure</strong> <br/> def test_method_with_error_2(self):<br/>   candidate = NameExtractor()<br/>   candidate.get_last_name(None)</span></pre><p id="22fa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了说明这个例子，我们使用了一个虚构的类<code class="fe mo mp mq me b">NameExtractor</code>,它的实现意味着从表示全名的给定字符串中提取名字和姓氏。在这两种语言中，该类的约定是在参数无效的情况下抛出异常或引发错误。</p><p id="c0f2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这些条款本质上是语法上的糖，两种语言中有等效的方法通过使用 catch 块来实现相同的目标，但上面是一种更优雅的处理方式，因为它不会污染您的测试。此外，如果您正在评估您的单元测试的覆盖率，而不仅仅是被测试的代码，那么使用 catch 块通常会影响这个度量。</p><p id="541d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe mo mp mq me b">NameExtractor</code>的 Golang 等效实现使用显式错误管理，如下所示:</p><pre class="kk kl km kn gt md me mf mg aw mh bi"><span id="ea4b" class="mi lb in me b gy mj mk l ml mm">// Language: Go</span><span id="412d" class="mi lb in me b gy mn mk l ml mm">type NameExtractor interface {</span><span id="eb4a" class="mi lb in me b gy mn mk l ml mm">  GetFirstName(fullName string) (string, error)<br/>  GetLastName(fullName string) (string, error)<br/>}</span><span id="c515" class="mi lb in me b gy mn mk l ml mm">type SimpleExtractor struct {<br/>  NameExtractor <br/>  ....<br/>}</span><span id="0929" class="mi lb in me b gy mn mk l ml mm">func (e *SimpleExtractor) GetFirstName(f string) (string, error) {<br/>   <br/>   if <strong class="me io">len(f) == 0</strong> {<br/>     return "", errors.New("Full name cannot be an empty string")<br/>   }<br/>   ....<br/>   return firstName, nil<br/>}</span><span id="c2aa" class="mi lb in me b gy mn mk l ml mm">func (e *SimpleExtractor) GetLastName(f string) (string, error) {<br/>   <br/>   if <strong class="me io">len(f) == 0</strong> {<br/>     return "", errors.New("Full name cannot be an empty string")<br/>   }<br/>   ....<br/>   return lastName, nil<br/>}</span><span id="faef" class="mi lb in me b gy mn mk l ml mm">// Testing code</span><span id="cbb6" class="mi lb in me b gy mn mk l ml mm">import "testing"<br/>import "github.com/stretchr/testify/assert"</span><span id="1a9b" class="mi lb in me b gy mn mk l ml mm">func TestGetFirstNameWithEmpty(t *testing.T) {</span><span id="6985" class="mi lb in me b gy mn mk l ml mm">    extractor := &amp;SimpleExtractor{ ... }<br/>    <strong class="me io">firstName, err := extractor.GetFirstName("")<br/>    assert.NotNil(t, err, "Error not returned on empty string")</strong><br/>    assert.Equal(t, 0, len(firstName), "First name should be empty")<br/>}</span><span id="631d" class="mi lb in me b gy mn mk l ml mm">func TestGetLastNameWithEmpty(t *testing.T) {</span><span id="4084" class="mi lb in me b gy mn mk l ml mm">    extractor := &amp;SimpleExtractor{ ... }<br/>    <strong class="me io">lastName, err := extractor.GetLastName("")<br/>    assert.NotNil(t, err, "Error not returned on empty string")</strong><br/>    assert.Equal(t, 0, len(lastName), "Last name should be empty")<br/>}</span></pre><p id="c5c9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">不管个人对异常作为一种语言特性有什么看法，我们总是可以将带有异常的代码翻译成具有显式错误管理的代码。因此，我们的函数将总是返回，并且通过良好的设计，我们将总是能够访问正常执行流程中的错误。因为错误管理在 Golang 中是显式的，所以没有必要将测试失败表示为积极的结果。…真的吗？</p><h1 id="f3bc" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">单元测试库的奇特案例</h1><p id="ea3e" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">除了例外，似乎没有必要将测试失败建模为成功的测试。事实证明，异常管理——虽然是最突出的——只是我们可以预期测试失败的原因之一。</p><p id="6248" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">另一个原因发生在支持单元测试开发的库的开发中。在这里，我们可以开发在特定条件下触发单元测试失败的能力。这些库的一个例子是<strong class="jm io">stretchr/evident/require</strong>。这公开了 twin 库<em class="ki">stretchr/evident/assert</em>的相同方法，但是它没有为测试记录失败，而是导致测试立即<em class="ki">失败</em>。按照 Golang 测试的说法，这意味着<strong class="jm io">要求</strong>方法最终在<code class="fe mo mp mq me b">testing.T</code>实现上调用<code class="fe mo mp mq me b">FailNow()</code>而不是<code class="fe mo mp mq me b">Fail()</code>。根据库文档(<a class="ae kz" href="https://pkg.go.dev/testing#T.FailNow" rel="noopener ugc nofollow" target="_blank"> FailNow() </a>和<a class="ae kz" href="https://pkg.go.dev/testing#T.Fail" rel="noopener ugc nofollow" target="_blank"> Fail() </a>):</p><p id="bdea" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ki"> "FailNow 将该函数标记为失败，</em> <strong class="jm io"> <em class="ki">通过调用 runtime 停止</em> </strong> <em class="ki">该函数的执行。Goexit(然后运行当前 goroutine 中的所有延迟调用)。”</em></p><p id="5eb9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ki">“失败”将功能标记为失败，但</em> <strong class="jm io"> <em class="ki">继续</em> </strong> <em class="ki">执行</em></p><p id="2a05" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">虽然对<code class="fe mo mp mq me b">Fail()</code>的调用仍然是可管理的，但是对<code class="fe mo mp mq me b">FailNow()</code>的调用会导致当前 go 例程的中断，从而产生类似于异常的行为和类似的结果。</p><p id="7abf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，如果我们开发最终调用<code class="fe mo mp mq me b">FailNow()</code>的测试库(如果你的库使用<em class="ki"> require </em>，这是肯定的)，我们如何测试正确的行为被实现了？这就需要将测试失败建模为成功的条件，或者类似的东西。</p><h2 id="34f6" class="mi lb in bd lc mr ms dn lg mt mu dp lk jv mv mw lo jz mx my ls kd mz na lw nb bi translated">FailNow()并且失败得更快！</h2><p id="2c01" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">在我们进入细节之前，让我们先花点时间解释一下为什么我们会在单元测试中使用像<em class="ki"> require </em>这样的东西。如果你的测试只包含一个断言，那么使用<em class="ki">require</em>vs .<em class="ki">assert</em>不会产生任何功能上的差异。无论如何，断言可能在方法体的末尾。当您的测试使用<em class="ki">多个断言</em>时，这种差异就开始发挥作用，其中一个断言是下面的必要前提。让我们看看下面的单元测试:</p><pre class="kk kl km kn gt md me mf mg aw mh bi"><span id="7d59" class="mi lb in me b gy mj mk l ml mm">import (<br/>  "testing"</span><span id="95c2" class="mi lb in me b gy mn mk l ml mm">  "github.com/stretchr/testify/require"<br/>  "github.com/stretchr/testify/assert"<br/>)</span><span id="f025" class="mi lb in me b gy mn mk l ml mm">func TestWithMultipleAssertions(t *testing.T) {</span><span id="7ba9" class="mi lb in me b gy mn mk l ml mm">  candidate := NewTestCandidate()</span><span id="7a72" class="mi lb in me b gy mn mk l ml mm">  entity := candidate.GetEntity("something")<br/>  require.NotNil(t, entity, "Returned entity should not be nil")<br/>  assert.Equal(t, "expected", entity.GetQuery(), "....")<br/>} </span></pre><p id="108a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在上面的场景中，带有 require 的第一个断言也验证了带有 assert 的第二个断言的前提条件，并使对实体的<code class="fe mo mp mq me b">GetQuery()</code>调用安全返回。如果实体为<code class="fe mo mp mq me b">nil</code>，在最后一次断言之前，测试以失败而终止。</p><p id="a322" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果我们将上面清单中的<em class="ki"> require </em>替换为<em class="ki"> assert </em>，并且调用<code class="fe mo mp mq me b">GetEntity()</code>返回<code class="fe mo mp mq me b">nil</code>，那么结果将是一个紧急错误，而不是测试失败。虽然我们认为这是可以接受的，但这更可能被解释为单元测试逻辑中的错误，而不是失败的测试。运行这种测试的自动化工具就是这种情况。</p><h1 id="ddd1" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">实施失败管理:管理你的期望</h1><p id="ac44" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">预期会调用<code class="fe mo mp mq me b">T.FailNow()</code>的被测代码提出了一个有趣的问题，即与普通测试相反:检测对<code class="fe mo mp mq me b">T.FailNow()</code>的调用，并将测试标记为成功；如果没有调用<code class="fe mo mp mq me b">T.FailNow()</code>，则触发失败。</p><p id="de51" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">后者相当容易实现:我们可以简单地在预计会导致失败的方法后添加一个对<code class="fe mo mp mq me b">T.FailNow()</code>的显式调用，如果这是 invoke，我们就知道测试失败了。真正的挑战是成功测试的检测，因为<code class="fe mo mp mq me b">T.FailNow()</code>调用<code class="fe mo mp mq me b">runtime.Goexit()</code>，这终止了测试中的代码，让我们没有钩子。</p><p id="3834" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">可以帮助我们实现这个目标的是隔离和控制被测试代码的执行，这样我们就可以“看到”它的失败，并且将正在执行的测试标记为成功(这仅仅意味着测试方法成功退出)。只有在与代表主测试方法的 go 例程不同的<em class="ki">go 例程</em>中执行测试代码时，这才是可能的。</p><p id="89c3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这正是 go testing 库执行测试并防止运行测试的主程序因调用<code class="fe mo mp mq me b">runtime.Goexit()</code>而意外终止的原因。如果你对细节感兴趣可以看看测试包的实现，特别是<a class="ae kz" href="https://github.com/golang/go/blob/master/src/testing/testing.go#L1460" rel="noopener ugc nofollow" target="_blank"> func (t *T) Run(name string，f(t *T)) bool </a>和<a class="ae kz" href="https://github.com/golang/go/blob/master/src/testing/testing.go#L1306" rel="noopener ugc nofollow" target="_blank"> func tRunner(t *T，fn func (t *T)) </a>。</p><p id="5a35" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们可以重用这个概念，并添加一些附加功能来改善开发人员的体验。</p><h2 id="9354" class="mi lb in bd lc mr ms dn lg mt mu dp lk jv mv mw lo jz mx my ls kd mz na lw nb bi translated">实现测试气泡</h2><p id="5532" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">我们希望尽可能少地破坏现有的开发人员编写单元测试的经验，并最终实现如下内容:</p><pre class="kk kl km kn gt md me mf mg aw mh bi"><span id="cd66" class="mi lb in me b gy mj mk l ml mm">func TestMethodWithFailNow(t *testing.T) {</span><span id="f1d5" class="mi lb in me b gy mn mk l ml mm">  candidate := StructUnderTest{}<br/>  <br/>  <strong class="me io">ExpectFailure</strong>(t, func(<strong class="me io">tt TestingT</strong>) {</span><span id="29ab" class="mi lb in me b gy mn mk l ml mm">     // this is expected to invoke T.FailNow() eventually<br/>     candidate.CallFailNow(tt, nil)<br/>  })</span><span id="132f" class="mi lb in me b gy mn mk l ml mm">  // if we get here this means that ExpectFailure has<br/>  // execute correctly and the test exits with success.<br/>}</span></pre><p id="9385" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里有三点需要注意:</p><ul class=""><li id="2c1a" class="nc nd in jm b jn jo jr js jv ne jz nf kd ng kh nh ni nj nk bi translated">期望调用的代码部分被隔离到一个函数中；</li><li id="7677" class="nc nd in jm b jn nl jr nm jv nn jz no kd np kh nh ni nj nk bi translated">该函数作为参数传递给<code class="fe mo mp mq me b">ExpectFailure</code>函数，该函数作为控制保护来验证故障；和</li><li id="6232" class="nc nd in jm b jn nl jr nm jv nn jz no kd np kh nh ni nj nk bi translated">这个函数有<code class="fe mo mp mq me b">TestingT</code>参数，顾名思义，它充当<code class="fe mo mp mq me b">testing.T</code>的代理，这样我们习惯的所有行为对我们都是可用的。</li></ul><p id="15f0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们放什么在<code class="fe mo mp mq me b">ExpectFailure</code>里变魔术，<code class="fe mo mp mq me b">TestingT</code>从哪里来？</p><p id="f2b6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe mo mp mq me b">TestingT</code>是一个包装<code class="fe mo mp mq me b">testing.T</code>结构的接口，提供的实现接口的结构需要能够注册<code class="fe mo mp mq me b">FailNow()</code>已被调用的事实，将该信息放在某个地方，然后调用真正的<code class="fe mo mp mq me b">T.FailNow()</code>来保存预期的行为。这是通过定义如下的<code class="fe mo mp mq me b">MockTestingT</code>结构来实现的:</p><pre class="kk kl km kn gt md me mf mg aw mh bi"><span id="d64b" class="mi lb in me b gy mj mk l ml mm">import (<br/>   "runtime"<br/>   "testing"</span><span id="31f0" class="mi lb in me b gy mn mk l ml mm">   "github.com/stretchr/testify/require"<br/>)</span><span id="40e9" class="mi lb in me b gy mn mk l ml mm">type MockTestingT struct {<br/>  FailNowCalled bool<br/>  t *testing.T</span><span id="927f" class="mi lb in me b gy mn mk l ml mm">  TestingT<br/>}</span><span id="6d85" class="mi lb in me b gy mn mk l ml mm">func (m *MockTestingT) FailNow() {<br/>  // register the method is called<br/>  <strong class="me io">m.FailNowCalled = true</strong><br/>  // exit, as normal behaviour<br/>  <strong class="me io">runtime.Goexit()</strong><br/>}</span><span id="c65d" class="mi lb in me b gy mn mk l ml mm">func (m *MockTestingT) Errorf(format string, args ...interface{}) {<br/>  t.Errorf(format, args)<br/>}</span></pre><p id="5d5e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe mo mp mq me b">ExpectFailure</code>需要隔离作为参数传递的函数的执行，以防止对<code class="fe mo mp mq me b">runtime.Goexit()</code>的调用过早终止执行，然后验证函数的执行是否有预期的结果。</p><pre class="kk kl km kn gt md me mf mg aw mh bi"><span id="de55" class="mi lb in me b gy mj mk l ml mm">import "sync"</span><span id="606c" class="mi lb in me b gy mn mk l ml mm">// include the listing above</span><span id="4fd8" class="mi lb in me b gy mn mk l ml mm">func ExpectFailure(t TestingT, func f(tt TestingT)) {</span><span id="d1d6" class="mi lb in me b gy mn mk l ml mm">  var wg sync.WaitGroup<br/>  <br/>  // create a mock structure for TestingT<br/>  mockT := &amp;MockTestingT{t: t}</span><span id="b730" class="mi lb in me b gy mn mk l ml mm">  // setup the barrier<br/>  <strong class="me io">wg.Add(1)</strong><br/>  // start a co-routine to execute the test function f<br/>  // and release the barrier at its end<br/>  <strong class="me io">go func() {<br/>     defer wg.Done()<br/>     f(mockT)<br/>  }</strong><br/>  <br/>  // wait for the barrier.<br/>  <strong class="me io">wg.Wait()</strong></span><span id="b59d" class="mi lb in me b gy mn mk l ml mm">  // verify fail now is invoked<br/>  <strong class="me io">require.True(t, mockT.FailNowCalled)</strong><br/>}</span></pre><p id="4fae" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">上面的两个清单让我们实现了我们所需要的。<code class="fe mo mp mq me b">MockTestingT</code>嵌入<a class="ae kz" href="https://github.com/stretchr/testify/blob/master/require/requirements.go#L4" rel="noopener ugc nofollow" target="_blank">要求。测试</a>(因此提供<code class="fe mo mp mq me b">testing.T</code>提供的方法)。模拟对象拦截对<code class="fe mo mp mq me b">FailNow()</code>的调用，并在失败前跟踪它的调用。</p><p id="a3a0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe mo mp mq me b">ExpectFailure</code>函数使用一个屏障来等待被测试函数的执行完成，然后验证它的终止是否是因为调用了<code class="fe mo mp mq me b">FailNow()</code>而发生的，从而给出了我们想要实现的反向行为。</p><h1 id="743b" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">包裹</h1><p id="5525" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">虽然 Golang 中预期测试失败的情况非常罕见，但启用这一功能让我们有机会了解标准测试框架实现的某些方面以及依赖它的一些库，如<code class="fe mo mp mq me b">require</code>和<code class="fe mo mp mq me b">assert</code>。通过理解我们想要解决的问题的本质，以及 Golang 提供给我们的并发性抽象的最少知识，我们已经演示了如何实现一种模式，这种模式尽可能接近 Java 或 Python 等语言中用于测试异常的模式。</p><p id="9f32" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">单元测试快乐！</p></div></div>    
</body>
</html>