# 游戏开发的第 94 天:协程如何在幕后工作？

> 原文：<https://blog.devgenius.io/day-94-of-game-dev-how-do-coroutines-work-behind-the-curtains-507f11b4d6a7?source=collection_archive---------3----------------------->

**目的:**更好地了解**协程**以及他们在幕后做什么。我假设它们在其他编程语言中的工作方式非常相似，但是在这里我将把重点放在 **C#/Unity** 上。

我确信如果你正在阅读这篇文章，你已经知道什么是**协程**。以防万一，这里有一个简单的定义和例子。

![](img/a15265ed53ac41fa810aa3a1b04bde17.png)

假设你想在特定的时间执行某个动作。您可以使用一个**协程**来指定执行一个动作需要多长时间。

![](img/3724618aca071621d7e78b801c9ae974.png)

在这个例子中，我正在初始化一个**协程**。启动时，它会等待 3 秒钟。然后它会把我的立方体颜色变成红色。

假设我们在 **Start()** 中调用这个**协程**，然后向控制台写一条消息。

![](img/9d0235df714f6c912150254c61b873cc.png)

我们应该期待什么？你可能会期望**协程**会运行，当它**完成后**移动到下一行代码(将消息写到控制台),就像我们在 Unity 中编写的大多数代码一样。让我们通过单击“播放”进行测试。

![](img/c9402e596d968222bd72cc89c47562e9.png)

在这里，我们实际上看到消息在**协程**完成之前被写入控制台。虽然是，但**协程**在**调试之前启动。Log** ，它不必完成就可以移到下一行代码。但是这实际上是如何工作的呢？为什么它能够与代码的其余部分“分开”运行？

要做到这一点，我们需要理解同步操作和异步操作的区别。

我们在 Unity 中最正确的代码是**同步**。

![](img/106779b2d6917b9dbb56d61b4732c3d4.png)

[演职员表:里卡多·科斯塔](https://www.outsystems.com/blog/posts/asynchronous-vs-synchronous-programming/)

当你想到这个的时候，你可能会想到多线程。

![](img/0fb1121383a6e4f1b68631a74e219093.png)

[演职员表:马修·马丁](https://www.guru99.com/cpu-core-multicore-thread.html)

将代码设置为多线程在游戏和软件工程的许多领域中非常常见。

回到主题:协程是否被设置为在一个单独的线程上运行，这就是为什么它们与 Unity 中的其他代码分开运行？

其实没有。

[根据 Unity API:](https://docs.unity3d.com/Manual/Coroutines.html)

> 然而，重要的是要记住协程不是线程。在协程内运行的同步操作仍然在主线程上执行。如果您想减少花费在主线程上的 CPU 时间，避免协程中的阻塞操作和任何其他脚本代码中的阻塞操作一样重要。如果你想在 Unity 中使用多线程代码，考虑一下 [C#作业系统](https://docs.unity3d.com/Manual/JobSystem.html)。

我讨论这个主题的原因是因为它是软件工程师理解的基础，并且是理解协程如何实现这一点的良好开端。

我读了很多关于这方面的不同文章，这里用英语总结了一下，尽管我建议四处看看，听听不同的声音，因为这是一个更深入的话题。

> **协程可以用很小的开销提供很高的并发性。多线程也可以提供并行性，但是存在阻塞和上下文切换。协程挂起线程，不阻塞它，以便它可以切换到另一个工作。** [**演职员表:高拉夫·戈亚尔**](https://medium.com/microsoft-mobile-engineering/kotlin-coroutines-1c8e009cb711)

基本上**协程**的工作方式与**异步操作**非常相似，两者各有利弊。**协程**可以被认为是**异步**，但不一定与**多线程**是一回事。

你会用**异步操作**或**协程**做什么？

[根据 Unity API:](https://docs.unity3d.com/Manual/Coroutines.html)

> 如果需要处理长时间的异步操作，比如等待 HTTP 传输、资产加载或文件 I/O 完成，最好使用协程。

我个人用它们来做计时器或其他我想触发的事件，然后运行 3 次。在最近的一个项目中，我使用了一个**协程**来实例化 3 次爆炸，每次在 0.75 秒后玩家失去所有生命。

不要强调这是一个很大的信息，因为这是一个很深的话题，我不可能在这里解释清楚。老实说，我只是最近才知道这些，这对我更好地理解一些非常重要的软件工程概念很有帮助。

***希望这篇文章对你有帮助！如果您有任何问题或想法，请随时发表评论。让我们制作一些令人敬畏的游戏！***