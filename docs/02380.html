<html>
<head>
<title>React Tips — Props, this Binding, and Side Effects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应提示——道具、绑定和副作用</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/react-tips-props-this-binding-and-side-effects-ff7e950415f2?source=collection_archive---------14-----------------------#2020-07-31">https://blog.devgenius.io/react-tips-props-this-binding-and-side-effects-ff7e950415f2?source=collection_archive---------14-----------------------#2020-07-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/6372d9c2cbf9381eb74813683e015ddb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2eexeL6O_O1Fc61R"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">Joshua J. Cotten 在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="9347" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">React是一个用于创建web应用程序和移动应用程序的流行库。</p><p id="f2a2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将了解一些编写更好的React应用程序的技巧。</p><h1 id="2494" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">有条件地将属性内联传递给组件</h1><p id="fc95" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过传入一个表达式作为prop值，有条件地将prop内联到一个组件。</p><p id="2700" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="f016" class="mn lc iq mj b gy mo mp l mq mr">&lt;Child {...(this.props.canEdit ? { editOptions : this.state.options } : undefined)} &gt;</span></pre><p id="f737" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们检查道具看它是否真实。</p><p id="1c62" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果是，那么我们把<code class="fe ms mt mu mj b">editOptions</code>道具传递给这个孩子。</p><p id="3f94" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">否则，我们就通过了<code class="fe ms mt mu mj b">undefined</code>。</p><p id="0b01" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们使用spread操作符将返回的对象分散到道具中。</p><h1 id="2af8" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">在React组件中使用一个或多个useEffect挂钩</h1><p id="4e63" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以随意使用<code class="fe ms mt mu mj b">useEffect</code>挂钩。</p><p id="7d73" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="f030" class="mn lc iq mj b gy mo mp l mq mr">useEffect(() =&gt; {<br/>  // run code<br/>  return () =&gt; {<br/>    // run clean up code<br/>  }<br/>}, []);</span><span id="5201" class="mn lc iq mj b gy mv mp l mq mr">useEffect(() =&gt; {<br/>  // run code when props.foo changes<br/>  return () =&gt; {<br/>     // run clean up code when props.foo changes<br/>  }<br/>}, [props.foo])</span></pre><p id="e072" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第一个<code class="fe ms mt mu mj b">useEffect</code>调用用于在组件加载时运行代码。</p><p id="94eb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们返回的函数在组件卸载时运行。</p><p id="1d62" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在第二个<code class="fe ms mt mu mj b">useEffect</code>调用中，当<code class="fe ms mt mu mj b">props.foo</code>改变时，我们运行代码。</p><p id="8cfa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当<code class="fe ms mt mu mj b">props.foo</code>改变时，返回的函数运行清理代码。</p><p id="704b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它对于触发任何副作用都很有用，比如API调用或者类似的事情。</p><h1 id="d7fa" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">将属性对象传递给子组件</h1><p id="e0dd" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用object spread操作符将对象的属性传递给子组件。</p><p id="4478" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="2855" class="mn lc iq mj b gy mo mp l mq mr">return &lt;Child {...props} /&gt;;</span></pre><p id="28a5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">props</code>对象中的所有属性将作为道具传入<code class="fe ms mt mu mj b">Child</code>。</p><h1 id="a321" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">避免将“this”绑定到每个方法</h1><p id="e096" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">通过使用类字段，我们可以避免将所有方法绑定到<code class="fe ms mt mu mj b">this</code>。</p><p id="49d4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这不是JavaScript语法的一部分，但它可以用于Babel或TypeScript。</p><p id="970a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以连接:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="7b0f" class="mn lc iq mj b gy mo mp l mq mr">class Foo extends React.Component {</span><span id="8365" class="mn lc iq mj b gy mv mp l mq mr">  onClick = () =&gt; {<br/>    console.log('clicked');<br/>  };</span><span id="5f54" class="mn lc iq mj b gy mv mp l mq mr">  onMouseOver = () =&gt; {<br/>    console.log('mouse over');<br/>  };</span><span id="30a2" class="mn lc iq mj b gy mv mp l mq mr">  render() {<br/>    return (<br/>      &lt;div<br/>        onClick={this.onClick}<br/>        onMouseOver={this.onMouseOver}<br/>      /&gt;<br/>    );<br/>  }</span><span id="664f" class="mn lc iq mj b gy mv mp l mq mr">}</span></pre><p id="bc1c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它还在第三阶段，所以它不是最终的。</p><h1 id="2943" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">反作用钩子中的推动方法</h1><p id="c0db" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们不能使用<code class="fe ms mt mu mj b">push</code>方法将一个项目追加到一个数组中，因为它返回被追加的项目并改变数组的位置。</p><p id="db3c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，我们必须返回一个新的数组，其中包含我们想要添加的项。</p><p id="1afb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="afe0" class="mn lc iq mj b gy mo mp l mq mr">const [array, setArray] = useState(initialArray);</span></pre><p id="b6e4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们写道:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="70e1" class="mn lc iq mj b gy mo mp l mq mr">setArray(oldArray =&gt; [...oldArray, newItem]);</span></pre><p id="1954" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们获取旧的数组，并返回一个新的数组，其中添加了条目。</p><p id="7ac5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用spread操作符将现有项目扩展到新数组中。</p><h1 id="0b94" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">PropTypes使用动态键检查对象</h1><p id="1f86" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">在验证props时，我们可以使用一个函数来检查带有动态键的对象。</p><p id="4ab8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="85f6" class="mn lc iq mj b gy mo mp l mq mr">someProp: (props, propName, componentName) =&gt; {<br/>  if (!/match/.test(props[propName])) {<br/>    return new Error('match prop doesn't exist');<br/>  }<br/>}</span></pre><p id="12cd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果<code class="fe ms mt mu mj b">someProp</code>的值匹配我们指定的正则表达式模式，我们检查<code class="fe ms mt mu mj b">someProp</code>的值。</p><p id="8f4b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果没有，那么我们抛出一个错误。</p><p id="6ac8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">props</code>拥有作为对象的道具。</p><p id="08d7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">propName</code>有道具的名字。</p><p id="ecca" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">componentName</code>有组件名。</p><h1 id="d8f1" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">反应属性类型:对象对形状</h1><p id="22f1" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe ms mt mu mj b">objectOf</code>方法让我们检查一个属性值是否属于某种类型。</p><p id="40d3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="c820" class="mn lc iq mj b gy mo mp l mq mr">number: PropTypes.objectOf(PropTypes.number)</span></pre><p id="8739" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">检查<code class="fe ms mt mu mj b">number</code>属性的值是否是一个对象。</p><p id="76a7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一方面，<code class="fe ms mt mu mj b">shape</code>让我们检查对象的结构。</p><p id="289c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="dabb" class="mn lc iq mj b gy mo mp l mq mr">styleObj: PropTypes.shape({<br/>  color: PropTypes.string,<br/>  fontSize: PropTypes.number<br/>}),</span></pre><p id="b668" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后<code class="fe ms mt mu mj b">styleObj</code>道具必须有<code class="fe ms mt mu mj b">color</code>属性，这是一个字符串。</p><p id="be7a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它应该有一个<code class="fe ms mt mu mj b">fontSize</code>属性，这是一个数字。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/be1c8ad5b8d8053f408c65a6bda43ec1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4eEO12vGjgyGuwU_"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://unsplash.com/@teddyosterblom?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Teddy sterblom</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="931c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="181a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">有各种方法来检查我们作为道具传入的对象的形状。</p><p id="6381" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过指定一个三元表达式，我们可以有选择地将属性传递给一个对象。</p><p id="add7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们可以在组件中多次使用<code class="fe ms mt mu mj b">useEffect</code>。</p><p id="94aa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">动态键也可以用prop-types包中的自定义函数来检查。</p></div></div>    
</body>
</html>