<html>
<head>
<title>Demystifying Temporal Dead Zone in Javascript?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">揭秘Javascript中的时态死区？</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/demystifying-temporal-dead-zone-in-javascript-e81103d5e41e?source=collection_archive---------5-----------------------#2021-10-08">https://blog.devgenius.io/demystifying-temporal-dead-zone-in-javascript-e81103d5e41e?source=collection_archive---------5-----------------------#2021-10-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/3984af53081cd911f5f487ad88448e12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qN_DJUFtMujelOol"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">阿菲夫·库苏马在<a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><blockquote class="ka kb kc"><p id="3f51" class="kd ke kf kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ig bi translated">在我们开始理解<strong class="kg io">时态死区</strong> e之前，你应该理解<strong class="kg io"> Javascript中的<a class="ae jz" href="https://rajeshi.medium.com/learn-hoisting-in-javascript-the-practical-way-a29741cf3eca" rel="noopener"> <strong class="kg io">提升</strong> </a>。</strong>你可以在<strong class="kg io">吊装</strong> <a class="ae jz" href="https://rajeshi.medium.com/learn-hoisting-in-javascript-the-practical-way-a29741cf3eca" rel="noopener"> <strong class="kg io">这里</strong> </a>查看我的帖子。</p></blockquote><h1 id="eba3" class="lc ld in bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">let vs var。</h1><p id="905d" class="pw-post-body-paragraph kd ke in kg b kh ma kj kk kl mb kn ko mc md kr ks me mf kv kw mg mh kz la lb ig bi translated">让我们看看下面的例子。</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="5143" class="mr ld in mn b gy ms mt l mu mv"><strong class="mn io">CODE:</strong><br/>console.log(fruit1);<br/>console.log(fruit2);</span><span id="03ae" class="mr ld in mn b gy mw mt l mu mv">var fruit1 = "apple";<br/>let fruit2 = "mango";<br/><strong class="mn io">OUTPUT:<br/></strong>undefined<strong class="mn io"><br/></strong>ReferenceError: Cannot access 'fruit2' before initialization</span></pre><p id="cdfd" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko mc kq kr ks me ku kv kw mg ky kz la lb ig bi translated">我们得到了未定义的“var ”,因为它被挂在执行上下文的内存组件中。类似地,“let”也被挂起，但是我们没有得到未定义的“ReferenceError”。</p><h1 id="3ed1" class="lc ld in bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">为什么让引用出错？</h1><p id="5294" class="pw-post-body-paragraph kd ke in kg b kh ma kj kk kl mb kn ko mc md kr ks me mf kv kw mg mh kz la lb ig bi translated">是，let被提升了，但是它被分配到不同的内存空间中，与var不同。我们可以说<strong class="kg io">让</strong>处于<strong class="kg io">时间死区</strong>。</p><h1 id="cc07" class="lc ld in bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">Javascript中的时间死区到底是什么？</h1><p id="bbe2" class="pw-post-body-paragraph kd ke in kg b kh ma kj kk kl mb kn ko mc md kr ks me mf kv kw mg mh kz la lb ig bi translated">在完全初始化之前，我们不能访问<strong class="kg io"> let </strong>变量。如果没有初始值给<strong class="kg io"> let </strong>声明，那么变量用<strong class="kg io"> undefined </strong>初始化，但是如果我们试图访问，它给出<strong class="kg io"> ReferenceError </strong>。只有当变量用一个值完全初始化时，我们才能访问它。let在初始化之前不允许访问的这种性质被称为在<strong class="kg io">时间死区</strong>中。</p><h1 id="3a72" class="lc ld in bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">一个时间死区的结束。</h1><p id="089a" class="pw-post-body-paragraph kd ke in kg b kh ma kj kk kl mb kn ko mc md kr ks me mf kv kw mg mh kz la lb ig bi translated">当变量用一个值初始化时，时间死区结束。让我们看看例子，更好地理解。</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="1fac" class="mr ld in mn b gy ms mt l mu mv"><strong class="mn io">CODE:<br/></strong>let fruit = "apple";<br/>console.log(fruit2);</span><span id="aac7" class="mr ld in mn b gy mw mt l mu mv"><strong class="mn io">OUTPUT:<br/></strong>apple</span></pre><p id="8532" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko mc kq kr ks me ku kv kw mg ky kz la lb ig bi translated">这里，我们成功地访问了<strong class="kg io"> let变量</strong>，因为我们在访问它之前用一个值初始化了它。所以它不在时间死区。但是如果我们可以在上面的行中有“console.log(fruit)”并在下面声明变量，那么由于时间死区，我们将得到作为ReferenceError的输出。</p><h1 id="b18c" class="lc ld in bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">Javascript中的执行流和时间死区(TDZ)。</h1><p id="2161" class="pw-post-body-paragraph kd ke in kg b kh ma kj kk kl mb kn ko mc md kr ks me mf kv kw mg mh kz la lb ig bi translated">让我们看更多的例子来获得一个深入的概念。</p><h2 id="49f4" class="mr ld in bd le mx my dn li mz na dp lm mc nb nc lq me nd ne lu mg nf ng ly nh bi translated">在时间死区外调用函数</h2><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="1715" class="mr ld in mn b gy ms mt l mu mv"><strong class="mn io">CODE:<br/></strong><em class="kf">// TDZ starts<br/></em>const sayHello = () =&gt; console.log(greet);</span><span id="a34d" class="mr ld in mn b gy mw mt l mu mv"><em class="kf">// Within the TDZ if we access </em>greet throws <em class="kf">`ReferenceError`</em></span><span id="d5ce" class="mr ld in mn b gy mw mt l mu mv">let greet = "hello";<em class="kf"> // End of TDZ</em></span><span id="c89c" class="mr ld in mn b gy mw mt l mu mv">sayHello();<em class="kf"> // called outside TDZ</em></span><span id="6be1" class="mr ld in mn b gy mw mt l mu mv"><strong class="mn io">OOUTPUT:<br/></strong>hello</span></pre><h2 id="57cb" class="mr ld in bd le mx my dn li mz na dp lm mc nb nc lq me nd ne lu mg nf ng ly nh bi translated">在时间死区内调用函数</h2><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="9aae" class="mr ld in mn b gy ms mt l mu mv"><strong class="mn io">CODE:<br/></strong><em class="kf">// TDZ starts at beginning of scope<br/></em>const sayHello = () =&gt; console.log(greet);</span><span id="aa26" class="mr ld in mn b gy mw mt l mu mv">sayHello();<em class="kf">// Accessing within the TDZ throws `ReferenceError`</em></span><span id="03f9" class="mr ld in mn b gy mw mt l mu mv">let greet = "hello";<em class="kf">// End of TDZ</em></span><span id="ff87" class="mr ld in mn b gy mw mt l mu mv"><strong class="mn io">OUTPUT:<br/></strong>ReferenceError</span></pre><p id="4dc8" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko mc kq kr ks me ku kv kw mg ky kz la lb ig bi translated">通过上面两个例子，我们可以得出这样的结论:变量的时间死区取决于执行的时间，而不是代码的编写顺序。</p><h1 id="def4" class="lc ld in bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">要记住的最后一个音符。</h1><p id="8f2a" class="pw-post-body-paragraph kd ke in kg b kh ma kj kk kl mb kn ko mc md kr ks me mf kv kw mg mh kz la lb ig bi translated"><strong class="kg io">变量</strong>在全局内存空间中被提升，在内存分配时被赋值<strong class="kg io">未定义</strong>。但是<strong class="kg io">字母</strong>被分配到单独的内存空间中，并且处于<strong class="kg io">时间死区</strong>中，直到它用<strong class="kg io">值</strong>完全初始化。</p><p id="594c" class="pw-post-body-paragraph kd ke in kg b kh ki kj kk kl km kn ko mc kq kr ks me ku kv kw mg ky kz la lb ig bi translated">是的，<strong class="kg io"> const </strong>也被分配到单独的内存空间中，并经过<strong class="kg io">时间死区</strong>，就像<strong class="kg io"> let </strong>一样。</p><h1 id="42d1" class="lc ld in bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">如果你想要更多这样的内容，请在媒体上关注我，订阅我的YouTube频道</h1><h1 id="37dd" class="lc ld in bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">有疑问吗？通过推特<a class="ae jz" href="https://twitter.com/izrajesh" rel="noopener ugc nofollow" target="_blank">联系我</a></h1></div></div>    
</body>
</html>