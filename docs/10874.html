<html>
<head>
<title>Socket Programming in C — Server</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C-Server 中的套接字编程</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/socket-programming-in-c-server-ca86486f6b49?source=collection_archive---------5-----------------------#2022-12-05">https://blog.devgenius.io/socket-programming-in-c-server-ca86486f6b49?source=collection_archive---------5-----------------------#2022-12-05</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/cdd7d90157f09b3bf73f8119926e213b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_9hVFKIFcmM1J4x_XsrX8w.png"/></div></div></figure><p id="c23d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">每天，我们都会向不同的服务器发送大量的请求，并收到相同的响应。但是你有没有想过这种交流是如何在引擎盖下进行的？？让我们去发现它！</p><p id="5a26" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">今天，有大量的框架用于开发服务器(基本上是后端 API ),如 Flask、Django、NodeJS 等。但大多数旧服务器都是使用 C 或 C++从头开始构建的。这一系列博客将指导您使用 C 语言实现服务器-客户端通信，这就是所谓的套接字编程。</p><p id="06b8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">构建一个大规模的服务器需要很多东西。不可能涵盖本系列中的所有内容，但这可能是您学习套接字编程的良好开端。</p><p id="4336" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在继续之前，我假设您已经对网络术语有了基本的了解，如服务器、客户机、请求、响应、协议(TCP/IP)等。</p></div><div class="ab cl kt ku hr kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ig ih ii ij ik"><h1 id="e3a8" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">创建一个套接字</h1><h2 id="ed3e" class="ly lb in bd lc lz ma dn lg mb mc dp lk kg md me lo kk mf mg ls ko mh mi lw mj bi translated">什么是插座？</h2><p id="f342" class="pw-post-body-paragraph jv jw in jx b jy mk ka kb kc ml ke kf kg mm ki kj kk mn km kn ko mo kq kr ks ig bi translated">套接字基本上是机器上的一个端点，用于在两个不同的进程之间进行通信。在我们的上下文中，在服务器和客户端进程之间。它用于在客户端和服务器之间发送和接收数据。</p><p id="ab70" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">第一步是使用如下参数的<strong class="jx io"> socket() </strong>函数创建一个套接字，<br/> <strong class="jx io"> domain </strong>:指定将用于通信的协议族。</p><p id="80f3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">网络中定义了多种协议。例如用于数据传输的互联网协议、用于网络问题处理的 ICMP 协议、用于地址解析的 ARP 等。在服务器-客户端通信中，进程之间的通信需要互联网协议(IPv4 或 IPv6)。</p><blockquote class="mp mq mr"><p id="6e06" class="jv jw ms jx b jy jz ka kb kc kd ke kf mt kh ki kj mu kl km kn mv kp kq kr ks ig bi translated">IPv4 的 AF_INET 或 IPv6 的 AF_INET 可用于域</p></blockquote><p id="65ea" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">类型</strong>:插座类型。它为套接字指定了通信的语义。例如，它可以是顺序字节流(对于 TCP 套接字)、数据报(对于 UDP 套接字)等。</p><blockquote class="mp mq mr"><p id="166f" class="jv jw ms jx b jy jz ka kb kc kd ke kf mt kh ki kj mu kl km kn mv kp kq kr ks ig bi translated">SOCK_STREAM 用于创建 TCP 套接字，SOCK_DGRAM 用于创建 UDP 套接字。</p></blockquote><p id="2c38" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">协议</strong>:从选择的协议族中指定一个特定的协议。</p><blockquote class="mp mq mr"><p id="4b6b" class="jv jw ms jx b jy jz ka kb kc kd ke kf mt kh ki kj mu kl km kn mv kp kq kr ks ig bi translated">如果通过 0，则采用默认协议，否则通过该协议的预定义的<a class="ae mw" href="https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml" rel="noopener ugc nofollow" target="_blank">号</a>。</p></blockquote><pre class="mx my mz na gt nb nc nd bn ne nf bi"><span id="56de" class="ng lb in nc b be nh ni l nj nk">int  sockfd;<br/>if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) &lt; 0)<br/>{<br/>   printf("Cannot create socket\n");<br/>   exit(0);<br/>}</span></pre><p id="b5e3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">socket()函数返回一个<a class="ae mw" href="https://www.computerhope.com/jargon/f/file-descriptor.htm" rel="noopener ugc nofollow" target="_blank">文件描述符</a>，它指向创建的套接字。</p><h1 id="cfff" class="la lb in bd lc ld nl lf lg lh nm lj lk ll nn ln lo lp no lr ls lt np lv lw lx bi translated">指定服务器属性</h1><p id="d971" class="pw-post-body-paragraph jv jw in jx b jy mk ka kb kc ml ke kf kg mm ki kj kk mn km kn ko mo kq kr ks ig bi translated">在创建套接字之后，需要指定服务器的几个属性，比如服务器将被托管的地址、服务器将提供服务的端口号等。</p><p id="a3b8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为此，使用了预定义的结构<strong class="jx io"> sockaddr_in </strong>。传递地址有两种方式，要么传递特定地址(32 位 IP 地址)，要么让 OS 自己决定地址(<strong class="jx io"> INADDR_ANY </strong>)。</p><blockquote class="mp mq mr"><p id="74b5" class="jv jw ms jx b jy jz ka kb kc kd ke kf mt kh ki kj mu kl km kn mv kp kq kr ks ig bi translated">当机器的 IP 地址未知时，使用特殊 IP 地址 INADDR_ANY。</p></blockquote><pre class="mx my mz na gt nb nc nd bn ne nf bi"><span id="c1d0" class="ng lb in nc b be nh ni l nj nk">struct sockaddr_in serv_addr;<br/>serv_addr.sin_family = AF_INET; // Protocol family<br/>serv_addr.sin_addr.s_addr = INADDR_ANY;<br/>serv_addr.sin_port = 6000; // 16-bit number</span></pre><h1 id="8687" class="la lb in bd lc ld nl lf lg lh nm lj lk ll nn ln lo lp no lr ls lt np lv lw lx bi translated">绑定插座</h1><p id="2548" class="pw-post-body-paragraph jv jw in jx b jy mk ka kb kc ml ke kf kg mm ki kj kk mn km kn ko mo kq kr ks ig bi translated">套接字准备好了，服务器属性也定义好了。现在是时候捆绑他们了。<br/>为此，使用了<strong class="jx io"> bind() </strong>函数，该函数将套接字文件描述符(<em class="ms">由 socket() </em>返回)、服务器属性结构和该结构的大小作为参数。</p><pre class="mx my mz na gt nb nc nd bn ne nf bi"><span id="dabb" class="ng lb in nc b be nh ni l nj nk">if (bind(sockfd, (struct sockaddr *)&amp;serv_addr, sizeof(serv_addr)) &lt; 0)<br/>{<br/>    printf("Unable to bind local address\n");<br/>    exit(0);<br/>}</span></pre><h1 id="2947" class="la lb in bd lc ld nl lf lg lh nm lj lk ll nn ln lo lp no lr ls lt np lv lw lx bi translated">倾听客户的心声</h1><p id="e420" class="pw-post-body-paragraph jv jw in jx b jy mk ka kb kc ml ke kf kg mm ki kj kk mn km kn ko mo kq kr ks ig bi translated">服务器几乎准备好监听客户机请求了。</p><p id="413f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对于 TCP 套接字，<strong class="jx io"> listen() </strong>函数告诉开始接受来自客户端的连接请求。它需要两个参数，socket FD 和在进一步的代码中接受任何请求之前可以考虑的连接数。</p><blockquote class="mp mq mr"><p id="31ba" class="jv jw ms jx b jy jz ka kb kc kd ke kf mt kh ki kj mu kl km kn mv kp kq kr ks ig bi translated">它基本上是 TCP 已经接受但在应用程序中尚未接受的连接。</p></blockquote><pre class="mx my mz na gt nb nc nd bn ne nf bi"><span id="ef91" class="ng lb in nc b be nh ni l nj nk">listen(sockfd,5);</span></pre><p id="c263" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，服务器已经准备好接受客户机请求。</p><figure class="mx my mz na gt jo gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/535640dbc8e278cad9d6dabfb1c90d05.png" data-original-src="https://miro.medium.com/v2/resize:fit:996/0*WRAu1VZxehOMefRF.gif"/></div><figcaption class="nr ns gj gh gi nt nu bd b be z dk translated">资料来源:tenor.com</figcaption></figure></div><div class="ab cl kt ku hr kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ig ih ii ij ik"><h1 id="5cb6" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">接受连接请求</h1><p id="e5ee" class="pw-post-body-paragraph jv jw in jx b jy mk ka kb kc ml ke kf kg mm ki kj kk mn km kn ko mo kq kr ks ig bi translated">系统调用<strong class="jx io"> accept() </strong>接受客户端连接。它阻塞服务器，直到客户端请求到来。accept()系统调用在作为参数传递的类型为<strong class="jx io"> sockaddr_in </strong>的结构中填充客户端的详细信息。该结构的长度记录在<strong class="jx io">斜面</strong>中。</p><p id="eca5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">它返回一个文件描述符，该描述符将用于与客户机的进一步通信。</p><pre class="mx my mz na gt nb nc nd bn ne nf bi"><span id="d33a" class="ng lb in nc b be nh ni l nj nk">clilen = sizeof(cli_addr);<br/>newsockfd = accept(sockfd, (struct sockaddr *)&amp;cli_addr, &amp;clilen);<br/>if (newsockfd &lt; 0)<br/>{<br/>  printf("Accept error\n");<br/>  exit(0);<br/>}</span></pre><p id="8d79" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一旦请求被接受，就会派生出一个子进程来处理这个请求。如果我们不派生一个进程来处理这个请求，那么服务器会一直忙于一次处理一个请求，并且不会接受其他请求，直到这个请求完成。</p><pre class="mx my mz na gt nb nc nd bn ne nf bi"><span id="63b9" class="ng lb in nc b be nh ni l nj nk">if (fork() == 0)<br/>{<br/>  close(sockfd);<br/>  /* Close the old socket FD, since all communications for this request<br/>  will be through the new socket FD. */<br/>  ...<br/>}</span></pre><h1 id="60f2" class="la lb in bd lc ld nl lf lg lh nm lj lk ll nn ln lo lp no lr ls lt np lv lw lx bi translated">发送和接收数据</h1><p id="a758" class="pw-post-body-paragraph jv jw in jx b jy mk ka kb kc ml ke kf kg mm ki kj kk mn km kn ko mo kq kr ks ig bi translated">所有这些东西的主要目的是在服务器和客户机之间传输数据。这可以借助<strong class="jx io"> send() </strong>和<strong class="jx io"> recv() </strong>功能来完成。</p><p id="dd04" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> send() </strong>:将数据发送给其他进程(即客户端)。<br/>它将进行通信的套接字 FD、要传输的数据、数据的最大大小和一个标志作为参数。</p><p id="7c9b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> recv() </strong>:接收来自其他进程(即来自客户端)的数据<br/>它也采用正在进行通信的套接字 FD、存储传入数据的指针、要接收的数据的最大大小以及一个标志作为参数。</p><p id="8a5f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="ms">例如，在连接请求被接受后，一个简单的字符串被发送到客户端，客户端也发送一个将被服务器接收的字符串。</em></p><pre class="mx my mz na gt nb nc nd bn ne nf bi"><span id="8fcb" class="ng lb in nc b be nh ni l nj nk">if (fork() == 0)<br/>{<br/>  close(sockfd);<br/>  /* Close the old socket since all communications<br/>  will be through the new socket. */<br/>  <br/>  // sending data<br/>  for (i = 0; i &lt; 100; i++)<br/>    buf[i] = '\0';<br/>  strcpy(buf, "Message from server");<br/>  send(newsockfd, buf, 100, 0);<br/>  <br/>  // receivinng data<br/>  for (i = 0; i &lt; 100; i++)<br/>    buf[i] = '\0';<br/>  recv(newsockfd, buf, 100, 0);<br/>  printf("%s\n", buf);<br/>  close(newsockfd);<br/>  exit(0);<br/>}<br/>close(newsockfd);</span></pre><blockquote class="mp mq mr"><p id="1ea1" class="jv jw ms jx b jy jz ka kb kc kd ke kf mt kh ki kj mu kl km kn mv kp kq kr ks ig bi translated">此外，我们需要关闭父服务器进程中新创建的套接字，以便其他请求可以使用它。</p></blockquote><p id="331d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">服务器基本上是不间断运行的程序。因此，为了实现这一特性，示例中将使用一个无限循环。</p><h1 id="8f96" class="la lb in bd lc ld nl lf lg lh nm lj lk ll nn ln lo lp no lr ls lt np lv lw lx bi translated">最终代码</h1><pre class="mx my mz na gt nb nc nd bn ne nf bi"><span id="1c03" class="ng lb in nc b be nh ni l nj nk">int sockfd, newsockfd; /* Socket descriptors */<br/>int clilen;<br/>struct sockaddr_in cli_addr, serv_addr;<br/>int i;<br/>char buf[100];<br/>if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) &lt; 0)<br/>{<br/>    printf("Cannot create socket\n");<br/>    exit(0);<br/>}<br/>struct sockaddr_in serv_addr;<br/>serv_addr.sin_family = AF_INET; // Protocol family<br/>serv_addr.sin_addr.s_addr = INADDR_ANY;<br/>serv_addr.sin_port = 6000; // 16-bit number<br/>if (bind(sockfd, (struct sockaddr *)&amp;serv_addr, sizeof(serv_addr)) &lt; 0)<br/>{<br/>    printf("Unable to bind local address\n");<br/>    exit(0);<br/>}<br/>listen(sockfd, 5);<br/><br/>while (1)<br/>{<br/>    clilen = sizeof(cli_addr);<br/>    newsockfd = accept(sockfd, (struct sockaddr *)&amp;cli_addr, &amp;clilen);<br/>    if (newsockfd &lt; 0)<br/>    {<br/>        printf("Accept error\n");<br/>        exit(0);<br/>    }<br/><br/>    if (fork() == 0)<br/>    {<br/>        close(sockfd);<br/>        /* Close the old socket since all communications<br/>        will be through the new socket. */<br/><br/>        // sending data<br/>        for (i = 0; i &lt; 100; i++)<br/>            buf[i] = '\0';<br/>        strcpy(buf, "Message from server");<br/>        send(newsockfd, buf, 100, 0);<br/><br/>        // receving data<br/>        for (i = 0; i &lt; 100; i++)<br/>            buf[i] = '\0';<br/>        recv(newsockfd, buf, 100, 0);<br/>        printf("%s\n", buf);<br/>        close(newsockfd);<br/>        exit(0);<br/>    }<br/>    close(newsockfd);<br/>}</span></pre></div><div class="ab cl kt ku hr kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ig ih ii ij ik"><p id="7ad4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">万岁！！服务器已准备好进行部署。编译并运行代码，查看您的服务器在指定的端口上运行。</p><p id="d5fa" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在本系列的下一个<a class="ae mw" href="https://yashpaneliya.medium.com/socket-programming-in-c-client-4408231f9e65" rel="noopener">部分</a>中，我将演示如何使用套接字创建客户机，以及如何处理来自浏览器的请求，这将使我们更好地理解整个服务器-客户机通信。</p><p id="f436" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你在本博客中发现任何问题或错误信息，请发表评论。这将有助于我和许多其他学习者理解这个概念。</p><p id="390b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你觉得这个博客有帮助，请表示感谢😄并与你的同事分享。</p><p id="65a9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">更了解我:【https://linktr.ee/yashpaneliya】T2</p></div></div>    
</body>
</html>