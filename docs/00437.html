<html>
<head>
<title>MultiPlatform development using Kotlin</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Kotlin 进行多平台开发</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/multiplatform-development-using-kotlin-2f9fbe3115ee?source=collection_archive---------14-----------------------#2020-06-07">https://blog.devgenius.io/multiplatform-development-using-kotlin-2f9fbe3115ee?source=collection_archive---------14-----------------------#2020-06-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/28d0b99ff00055492058199c9b0b12ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*trBqbslW4IropLwH"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">马克·赖歇尔在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="e0ea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我想体验一下 Kotlin 多平台开发，以理解在 Android 和 iOS 项目中采用这种方法的复杂性。为此，我想针对一个小用例，通过使用 Kotlin 多平台来解决这个问题。在这篇文章中，当你和我一起踏上这段旅程时，我将和你分享我的观察。</p><h2 id="9d61" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">先决条件</h2><ul class=""><li id="f0ab" class="lu lv iq kf b kg lw kk lx ko ly ks lz kw ma la mb mc md me bi translated">我假设你熟悉 Android 和 iOS 开发。</li><li id="37fc" class="lu lv iq kf b kg mf kk mg ko mh ks mi kw mj la mb mc md me bi translated">我假设您对 Kotlin &amp; Swift 有足够的了解，可以理解 DSL。</li></ul><p id="e352" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，我们将讨论这个问题，然后是这个问题的一个可能的解决方案，以及我们将如何使用多平台方法来解决 Android 和 iOS 的问题，最后展示我们如何在这两个平台上使用我们构建的内容。</p><h1 id="c36e" class="mk lc iq bd ld ml mm mn lg mo mp mq lj mr ms mt lm mu mv mw lp mx my mz ls na bi translated">1.概观</h1><p id="ba42" class="pw-post-body-paragraph kd ke iq kf b kg lw ki kj kk lx km kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">在快节奏的应用程序开发周期中，我们会遇到一些问题。我们将简要回顾一下，并定义一个我们想要实现的目标。</p><h2 id="ac04" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">1.1 问题</h2><p id="806d" class="pw-post-body-paragraph kd ke iq kf b kg lw ki kj kk lx km kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">在这一节中，我们将介绍四种可能产生瓶颈的场景。</p><p id="e967" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> 1.1.1 环境<br/> </strong>为了帮助理解环境问题，下图用红色表示非工作环境，用绿色表示工作环境。环境可以是开发、测试、UAT 或生产。鉴于我们的应用程序指向红色，如果这个问题与环境有关，而不是与应用程序中的代码路径有关，我们希望能够灵活地切换环境，而无需执行重建来进行分类。</p><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/12f62677810790eb54d91d3b4807c4f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1318/format:webp/1*Sp3X7huHLFtz3XBCVWpC_g.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">[1.1.1]环境</figcaption></figure><p id="52a9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> 1.1.2 特性<br/> </strong>为了了解与非工作特性相关的问题，下图显示了我们的应用程序由特性块和绿色的工作特性组成。相比之下，不工作的功能以红色显示。假设我们希望用红色标识有问题的特性，我们希望能够灵活地打开或关闭特性，而不需要执行重建来对问题进行分类。</p><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/52333fa2d446a884384f3924fec4d698.png" data-original-src="https://miro.medium.com/v2/resize:fit:1042/format:webp/1*qWhI5zM9pqOy8KROuFSv4Q.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">[1.1.2]功能</figcaption></figure><p id="ea7d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> 1.1.3 调整阈值<br/> </strong>考虑到我们想要调整应用程序中的时间间隔，以使它们表现更好或看起来更合适。下图显示了一个应用程序联系 API 并接收响应。如果我们的超时间隔太短，我们的应用程序很快就会停止侦听，另一方面，如果超时间隔太长，我们的应用程序会等待很长时间，当这种等待在应用程序的关键路径上时，我们会看到我们的应用程序的性能明显滞后。为了预测正确的值，我们希望能够灵活地调整超时值，以确定什么更适合我们的应用程序，而不必每次都重新构建我们的应用程序。</p><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/496b733c642316cdb09e8711136f3e82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/1*XpZwvWvgeFmtyY06bIDbfQ.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">[1.1.3]调谐阈值</figcaption></figure><p id="4c7c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> 1.1.4 动态值<br/> </strong>假设我们想要编辑一个配置值来快速测试更改，而不必重新构建我们的应用程序。为了说明这种情况，下图显示了我们的应用程序指向一个不存在的域 example.com，而我们希望执行快速检查，以确保新域 global.example.com 按预期工作。</p><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/7c882833ce45a7d03461576b07f054ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:982/format:webp/1*phHEgqrv1PilKnlr6nO0OQ.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">[1.1.4]动态值</figcaption></figure><h2 id="38c6" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">1.2 目标</h2><p id="88e6" class="pw-post-body-paragraph kd ke iq kf b kg lw ki kj kk lx km kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">考虑了上述问题后，让我们定义我们的目标，如下所示:</p><blockquote class="nm"><p id="91a9" class="nn no iq bd np nq nr ns nt nu nv la dk translated"><em class="nw">“鉴于应用程序有必要的代码。我们希望以最小的努力改变应用程序在设备上部署后的行为。”</em></p></blockquote><h1 id="f64c" class="mk lc iq bd ld ml mm mn lg mo mp mq lj mr nx mt lm mu ny mw lp mx nz mz ls na bi translated">2.解决办法</h1><p id="f2b8" class="pw-post-body-paragraph kd ke iq kf b kg lw ki kj kk lx km kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">考虑到我们的目标，我们希望在部署后能够灵活地编辑应用程序的配置。为此，我们将在应用程序的启动器中放置一个<strong class="kf ir">配置入口点</strong> (CEP)，这允许我们在加载主应用程序之前更新配置。为了举例说明这一点，下图显示了 launcher 有两个应用程序的入口点，绿色显示的是应用程序的主入口点<strong class="kf ir"/>(MEP)。相比之下，黄色部分允许我们在启动 MEP 之前自定义设置。</p><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/ffbcccc51587edc8aa0118850a184cb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:402/format:webp/1*bua6CtVDVT_eRMzgzFWB2Q.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">[2.0.1]解决方案概述</figcaption></figure><p id="578f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将使用多平台方法实现这个解决方案，为 Android 和 iOS 生成本地库。我们的库由三层组成，如下图所示:</p><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/14b235acc73e2660244955744e825f71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/1*lW1V3rrpkSu9sqkkX1uHbg.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">[2.0.2]解决方案架构</figcaption></figure><p id="05a2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">第一层</strong> —这一层包含数据模型和我们解决方案的逻辑。这一层的代码不依赖于其他两层，使用 Kotlin。这里的 Kotlin 代码可以在多种平台上本机编译使用，例如 Android、iOS、Windows、Mac、Linux、JavaScript 和 JVM。</p><p id="032a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">第二层</strong> —这一层包含特定于平台的实现，用于在我们的解决方案中保存配置值。这一层的代码依赖于<em class="oc">层一</em>而不依赖于<em class="oc">层三</em>。这一层包含针对 iOS 和 Android 的特定于平台的 Kotlin 代码。</p><p id="51d5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">第三层</strong> —这一层包含相应平台上的原生 UI 实现。这一层的代码依赖于<em class="oc">层二</em>和<em class="oc">层一</em>。在目标 Android 中，这一层包含 Android 布局文件和 UI 的相应 Kotlin 代码。在目标 iOS 上，这一层包含使用 UIKit 框架处理 UI 中配置状态更改的 Swift 代码。</p><p id="9910" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> <em class="oc">注:</em> </strong> <em class="oc">凡是在第二层的也可以在第三层，反之亦然。这是我们必须根据复杂性做出的决定。在这种情况下，与必须在第二层中完全完成 UI 层相比，在第二层中完全完成持久层要简单得多。因此决定将 UI 实现推到第三层。</em></p><h2 id="4532" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">2.1 DSL —第一层</h2><p id="3c38" class="pw-post-body-paragraph kd ke iq kf b kg lw ki kj kk lx km kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">为了在 iOS 和 Android 平台上有一个一致的配置编写方式，我们将使用 Kotlin Lambda 扩展来开发 DSL。在那些 DSL 的实现中，共享以下属性。</p><ul class=""><li id="0734" class="lu lv iq kf b kg kh kk kl ko od ks oe kw of la mb mc md me bi translated"><em class="oc">键</em> —启用配置中的值检索。</li><li id="ccad" class="lu lv iq kf b kg mf kk mg ko mh ks mi kw mj la mb mc md me bi translated"><em class="oc">描述</em> <strong class="kf ir"> </strong> —提供描述配置意图的选项。</li></ul><p id="c2ff" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> 2.1.1 使用 Choice DSL <br/> </strong>解决环境问题为了解决<em class="oc">环境【1 . 1 . 1】</em>中强调的问题，我们将开发一个 Choice DSL，如下所示。这个 DSL 给了我们从可用选项中选择一个项目的灵活性。在 Choice DSL 中，我们有以下内容:</p><ul class=""><li id="21e8" class="lu lv iq kf b kg kh kk kl ko od ks oe kw of la mb mc md me bi translated"><em class="oc"> currentChoiceIndex </em> —在配置中选择的默认项目的值。</li><li id="96c5" class="lu lv iq kf b kg mf kk mg ko mh ks mi kw mj la mb mc md me bi translated"><em class="oc">项目</em> —该配置中的可用选项。</li></ul><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="og oh l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">[2.1.1]选择 DSL ( <a class="ae kc" href="https://github.com/juliuscanute/multi-config/blob/master/app/src/commonMain/kotlin/com/juliuscanute/multiconfig/builder/ChoiceBuilder.kt" rel="noopener ugc nofollow" target="_blank"> <strong class="ak">实现</strong> </a>)</figcaption></figure><p id="302b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> 2.1.2 解决特性问题使用开关 DSL <br/> </strong>为了解决<em class="oc">特性【1.1.2】，</em>中突出显示的问题，我们将开发一个开关 DSL，如下所示。这个 DSL 给了我们打开或关闭特性的灵活性。在交换机 DSL 中，我们有以下内容:</p><ul class=""><li id="16e7" class="lu lv iq kf b kg kh kk kl ko od ks oe kw of la mb mc md me bi translated"><em class="oc">开关值</em> —开关真/假的当前值。</li></ul><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="og oh l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">[2.1.2]切换 DSL ( <a class="ae kc" href="https://github.com/juliuscanute/multi-config/blob/master/app/src/commonMain/kotlin/com/juliuscanute/multiconfig/builder/SwitchBuilder.kt" rel="noopener ugc nofollow" target="_blank"> <strong class="ak">实现</strong> </a>)</figcaption></figure><p id="bdee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> 2.1.3 使用范围 DSL 解决调谐阈值<br/> </strong>为了解决<em class="oc">调谐阈值【1 . 1 . 3】</em>，我们将开发一个范围 DSL，如下所示。这种 DSL 为我们提供了在指定的最小&amp;最大范围内调整数值的灵活性。在 DSL 系列中，我们有以下产品:</p><ul class=""><li id="530c" class="lu lv iq kf b kg kh kk kl ko od ks oe kw of la mb mc md me bi translated"><em class="oc">最小值</em> —该配置允许的最小值</li><li id="b379" class="lu lv iq kf b kg mf kk mg ko mh ks mi kw mj la mb mc md me bi translated"><em class="oc">最大值</em> —该配置中允许的最大值</li><li id="9f1d" class="lu lv iq kf b kg mf kk mg ko mh ks mi kw mj la mb mc md me bi translated"><em class="oc">当前值</em> —该配置的当前值</li></ul><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="og oh l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">2.1.3 范围 DSL( <a class="ae kc" href="https://github.com/juliuscanute/multi-config/blob/master/app/src/commonMain/kotlin/com/juliuscanute/multiconfig/builder/RangeBuilder.kt" rel="noopener ugc nofollow" target="_blank"> <strong class="ak">实现</strong> </a>)</figcaption></figure><p id="e043" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> 2.1.4 使用可编辑 DSL <br/> </strong>解决动态值为了解决<em class="oc">动态值【1 . 1 . 4】</em>，我们将开发一个可编辑 DSL，如下图所示。这个 DSL 让我们可以灵活地给我们的<em class="oc">核心内容</em>编辑一个给定值。</p><ul class=""><li id="d5be" class="lu lv iq kf b kg kh kk kl ko od ks oe kw of la mb mc md me bi translated"><em class="oc">当前值</em> —该配置的当前值</li></ul><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="og oh l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">[2.1.4]可编辑 DSL( <a class="ae kc" href="https://github.com/juliuscanute/multi-config/blob/master/app/src/commonMain/kotlin/com/juliuscanute/multiconfig/builder/EditableBuilder.kt" rel="noopener ugc nofollow" target="_blank"> <strong class="ak">实现</strong> </a>)</figcaption></figure><p id="36e8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> 2.1.5 AppConfig 和 Config DSL <br/> </strong>我们希望能够灵活地更改与应用程序相关的多种配置，并能够尝试不同的分组方式，以找到更适合我们应用程序的方式。为此，我们有 AppConfig &amp; Config DSL，如下所示。</p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="og oh l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">[2.1.5] AppConfig( <a class="ae kc" href="https://github.com/juliuscanute/multi-config/blob/master/app/src/commonMain/kotlin/com/juliuscanute/multiconfig/builder/ConfigurationBuilder.kt" rel="noopener ugc nofollow" target="_blank"> <strong class="ak">实现</strong></a>)&amp;Config DSL(<a class="ae kc" href="https://github.com/juliuscanute/multi-config/blob/master/app/src/commonMain/kotlin/com/juliuscanute/multiconfig/builder/ConfigurationBuilder.kt" rel="noopener ugc nofollow" target="_blank"><strong class="ak">实现</strong> </a>)</figcaption></figure><h2 id="6f84" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">2.2 持久性—第二层</h2><p id="1432" class="pw-post-body-paragraph kd ke iq kf b kg lw ki kj kk lx km kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">应用配置更改后，主应用程序的后续启动必须使用新配置。为此，持久层有两个职责，一个是加载现有配置，另一个是保存修改后的配置。对于这些职责，我们在第二层使用 Kotlin 编写了 Android 和 iOS 实现。</p><ul class=""><li id="fa14" class="lu lv iq kf b kg kh kk kl ko od ks oe kw of la mb mc md me bi translated">Android 使用<em class="oc"> SharedPreferences </em></li><li id="54ec" class="lu lv iq kf b kg mf kk mg ko mh ks mi kw mj la mb mc md me bi translated">iOS 使用<em class="oc"> NSUserDefaults </em></li></ul><p id="35d6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> 2.2.1 加载配置—第一层<br/> </strong>以下代码片段说明了已保存配置的加载。</p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="og oh l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">[2.2.1]负载配置(<a class="ae kc" href="https://github.com/juliuscanute/multi-config/blob/master/app/src/commonMain/kotlin/com/juliuscanute/multiconfig/model/ConfigurationGetterImplementation.kt" rel="noopener ugc nofollow" target="_blank">实现</a>)</figcaption></figure><p id="a231" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> 2.2.2 保存配置—第一层<br/> </strong>以下代码片段说明了如何保存更新的配置。</p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="og oh l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">[2.2.2]保存配置(<a class="ae kc" href="https://github.com/juliuscanute/multi-config/blob/master/app/src/commonMain/kotlin/com/juliuscanute/multiconfig/model/ConfigurationRepository.kt" rel="noopener ugc nofollow" target="_blank">实现</a>)</figcaption></figure><p id="2164" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> 2.2.3 设置期望—第一层<br/> </strong>从<em class="oc">【2 . 2 . 1】</em><em class="oc">【2 . 2 . 2】</em>中我们可以看出，第一层的代码是期望平台执行的操作的模板，用于设置。Kotlin native 有一种优雅的方式来做到这一点，如下所示。</p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="og oh l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">[2.2.3]设定期望值(<a class="ae kc" href="https://github.com/juliuscanute/multi-config/blob/master/app/src/commonMain/kotlin/com/juliuscanute/multiconfig/settings/Settings.kt" rel="noopener ugc nofollow" target="_blank">实施</a>)</figcaption></figure><p id="afc1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> 2.2.4 实际实现—第二层<br/> </strong>为了满足第一层的期望，我们必须在第二层提供相应的实际实现。Kotlin 有一个很好的方法来满足这种期望，如下图所示。</p><p id="7614" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="oc"> Android 实现<br/> </em>在 Android 中，我们使用<em class="oc"> SharedPreferences 来满足预期。</em></p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="og oh l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">[2.2.4] Android 持久性(<a class="ae kc" href="https://github.com/juliuscanute/multi-config/blob/master/app/src/androidMain/kotlin/com/juliuscanute/multiconfig/settings/Settings.kt" rel="noopener ugc nofollow" target="_blank">实现</a>)</figcaption></figure><p id="3378" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="oc"> iOS 实现<br/> </em>在 iOS 中，我们使用<em class="oc"> NSUserDefaults 来满足预期。</em></p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="og oh l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">[2.2.4] iOS 持久性(<a class="ae kc" href="https://github.com/juliuscanute/multi-config/blob/master/app/src/iosMain/kotlin/com/juliuscanute/multiconfig/settings/Settings.kt" rel="noopener ugc nofollow" target="_blank">实现</a>)</figcaption></figure><h2 id="c8cb" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">2.3 用户界面—第三层</h2><p id="098e" class="pw-post-body-paragraph kd ke iq kf b kg lw ki kj kk lx km kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">当我们通过 CEP 启动应用程序时，我们将用 DSL 编写的配置转换成与平台相对应的 UI 控件。我们已经用 Kotlin &amp; Swift 编写的 Android &amp; iOS 的本地实现介绍了这个逻辑。</p><p id="d3c9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了理解整个库是如何工作的，我们将看一个使用该库的示例应用程序。</p><p id="6b73" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意:第一层的代码比其他两层的代码越多，维护代码库就越容易。我们在第一层应用的改进对所有目标都有效。我们对所有这些层进行编码的目标是尽可能多地进入第一层。</p><h1 id="a7c5" class="mk lc iq bd ld ml mm mn lg mo mp mq lj mr ms mt lm mu mv mw lp mx my mz ls na bi translated">3.使用库构建应用程序</h1><p id="dbf0" class="pw-post-body-paragraph kd ke iq kf b kg lw ki kj kk lx km kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">在开发了我们库的所有三层之后，考虑我们已经向 Maven Central 和 CocoaPods 发布了 Android &amp; iOS 库。在下一节中，我们将在示例项目中使用已发布的库。</p><h1 id="56ac" class="mk lc iq bd ld ml mm mn lg mo mp mq lj mr ms mt lm mu mv mw lp mx my mz ls na bi translated">3.1 依赖性</h1><p id="4372" class="pw-post-body-paragraph kd ke iq kf b kg lw ki kj kk lx km kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">要在目标平台上本地使用这些库，请遵循下面所示的设置过程:</p><p id="0a62" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> 3.1.1 安卓依赖</strong></p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="og oh l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">[3.1.1] <a class="ae kc" href="https://github.com/juliuscanute/multi-config/blob/master/sampleAndroid/app/build.gradle" rel="noopener ugc nofollow" target="_blank"> build.gradle </a></figcaption></figure><p id="348f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> 3.1.2 iOS 依赖</strong></p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="og oh l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">【3 . 1 . 2】<a class="ae kc" href="https://github.com/juliuscanute/multi-config/blob/master/sampleios/Podfile" rel="noopener ugc nofollow" target="_blank">pod file</a></figcaption></figure><h1 id="14e2" class="mk lc iq bd ld ml mm mn lg mo mp mq lj mr ms mt lm mu mv mw lp mx my mz ls na bi translated">3.2 配置应用程序</h1><p id="8a96" class="pw-post-body-paragraph kd ke iq kf b kg lw ki kj kk lx km kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">示例项目有两种不同的配置，分别针对免费用户和高级用户，并且包含一个带有文本的视图，我们希望在启动之前配置其属性。下面列出了我们感兴趣的属性:</p><ul class=""><li id="da70" class="lu lv iq kf b kg kh kk kl ko od ks oe kw of la mb mc md me bi translated"><em class="oc">可见度</em></li><li id="466b" class="lu lv iq kf b kg mf kk mg ko mh ks mi kw mj la mb mc md me bi translated"><em class="oc">文本大小</em></li><li id="b2cc" class="lu lv iq kf b kg mf kk mg ko mh ks mi kw mj la mb mc md me bi translated"><em class="oc">当前文本</em></li><li id="8b92" class="lu lv iq kf b kg mf kk mg ko mh ks mi kw mj la mb mc md me bi translated"><em class="oc">文本颜色</em></li></ul><p id="1933" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> 3.2.1 Android 配置<br/> </strong>我们的示例项目的配置在 Android 中表示如下。</p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="og oh l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">【3 . 2 . 1】<a class="ae kc" href="https://github.com/juliuscanute/multi-config/blob/master/sampleAndroid/app/src/config/java/com/juliuscanute/sampleandroid/Configuration.kt" rel="noopener ugc nofollow" target="_blank">安卓 App 配置</a> ( <a class="ae kc" href="https://gist.github.com/juliuscanute/0651fca32f3c48974dbd1cc0ce400ceb.js" rel="noopener ugc nofollow" target="_blank">完整片段)</a></figcaption></figure><p id="5754" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> 3.2.2 iOS 配置<br/> </strong>我们的示例项目的配置在 iOS 中表示如下。</p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="og oh l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">[3.2.2] <a class="ae kc" href="https://github.com/juliuscanute/multi-config/blob/master/sampleios/sampleios/Configuration.swift" rel="noopener ugc nofollow" target="_blank"> iOS 应用配置</a> ( <a class="ae kc" href="https://gist.github.com/juliuscanute/71c25c9c2be8be961ab93cb650ded9d1.js" rel="noopener ugc nofollow" target="_blank">完整片段</a>)</figcaption></figure><h1 id="47bf" class="mk lc iq bd ld ml mm mn lg mo mp mq lj mr ms mt lm mu mv mw lp mx my mz ls na bi translated">3.3 初始化配置</h1><p id="5b59" class="pw-post-body-paragraph kd ke iq kf b kg lw ki kj kk lx km kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">我们可以在应用程序启动期间初始化我们的配置模块，如下所示。</p><p id="65cc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> 3.3.1 使用 UI 初始化 Android<br/></strong>对于 Android，我们将使用我们库的第二层中的上下文来处理共享偏好。另一方面，在更新配置之后，我们使用库的第三层上的 Intent 来启动 start 活动。</p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="og oh l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">[3.3.1] <a class="ae kc" href="https://github.com/juliuscanute/multi-config/blob/master/sampleAndroid/app/src/config/java/com/juliuscanute/sampleandroid/SampleApp.kt" rel="noopener ugc nofollow" target="_blank">使用 UI 初始化 Android</a></figcaption></figure><p id="2a1f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> 3.3.2 使用 UI <br/> </strong>初始化 iOS 对于 iOS，我们将使用我们库的第二层中的组名来初始化 NSUserDefaults。另一方面，在更新配置后，我们使用第三层中的控制器导航到应用程序的开始。</p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="og oh l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">[3.3.2] <a class="ae kc" href="https://github.com/juliuscanute/multi-config/blob/master/sampleios/sampleios/Configuration.swift" rel="noopener ugc nofollow" target="_blank">使用用户界面</a>初始化 iOS</figcaption></figure><h2 id="399d" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">3.4 使用当前配置值</h2><p id="a9cd" class="pw-post-body-paragraph kd ke iq kf b kg lw ki kj kk lx km kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">初始化我们的库后，我们可以在应用程序中的任何点获得更新的配置值，如下所示。我们可以使用配置 DSL 中定义的键来获取与配置相对应的值。</p><p id="f7e3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> 3.4.1 安卓使用</strong></p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="og oh l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">【3 . 4 . 1】<a class="ae kc" href="https://github.com/juliuscanute/multi-config/blob/master/sampleAndroid/app/src/main/java/com/juliuscanute/sampleandroid/MainActivity.kt" rel="noopener ugc nofollow" target="_blank">安卓使用</a></figcaption></figure><p id="aa78" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> 3.4.2 iOS 使用情况</strong></p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="og oh l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">【3 . 4 . 2】<a class="ae kc" href="https://github.com/juliuscanute/multi-config/blob/master/sampleios/sampleios/ConfigurationData.swift" rel="noopener ugc nofollow" target="_blank">iOS 用法</a></figcaption></figure><h1 id="fe7c" class="mk lc iq bd ld ml mm mn lg mo mp mq lj mr ms mt lm mu mv mw lp mx my mz ls na bi translated">4.结果</h1><p id="213b" class="pw-post-body-paragraph kd ke iq kf b kg lw ki kj kk lx km kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">显示我们的应用程序有两个入口点 MEP 和 CEP。在包含库的 Android 中，这是清单合并的结果。在 iOS 中，我们创建两个目标并将目标关联到同一个应用程序组，因此更新一个目标中的设置会反映到另一个目标中。</p><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/aeb438165f222cf835ab790a3446bcb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1296/format:webp/1*Inp7gc71pwzk97I-vRv9Hw.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">[4] Android 左侧，iOS 右侧— MEP 和 CEP</figcaption></figure><p id="4a88" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们使用 CEP 发布我们的应用。在发布期间，我们使用 DSL 来动态创建应用程序的 UI。在下图中，显示了 CEP 的起点。此处可见的每个项目都是应用于应用程序的配置的集合(如果选中)。在下图中，我们想要调整应用程序的高级配置。因此，我们点击它来进一步编辑配置。</p><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/ed3ca94f466fc8f30cfaebf95508a6e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1296/format:webp/1*SPan53w5MU8o58uFqbgx7Q.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">[4] Android 左，iOS 右—来自 DSL 的动态 UI</figcaption></figure><p id="b2f7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">进入高级配置后，我们将更新设置，如下所示:</p><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/0a8bb32d3139079aab9f95c204958492.png" data-original-src="https://miro.medium.com/v2/resize:fit:1296/format:webp/1*mj3Zslhbfjf5BA9jDSeeUA.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">[4] Android 左侧，iOS 右侧—更新配置值</figcaption></figure><p id="47d1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">更新配置后，通过点击 Launch PREMIUM 按钮或从启动器启动 MEP 来启动我们的 MEP，会有更新的配置值。</p><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/260142d4c5b22c93a7eb6ff30bcebfd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1296/format:webp/1*wwDVegCAHJY9pEjcrX1e6g.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">[4] Android 左侧，iOS 右侧—使用新配置加载</figcaption></figure><h1 id="11ed" class="mk lc iq bd ld ml mm mn lg mo mp mq lj mr ms mt lm mu mv mw lp mx my mz ls na bi translated">5.复活节彩色蛋</h1><p id="3459" class="pw-post-body-paragraph kd ke iq kf b kg lw ki kj kk lx km kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">我们在公共代码的第一层隐藏了一个复活节彩蛋，这在我们不需要第二层(持久性)和第三层(UI)的应用程序发布时会很有用。这是一个只读配置，在我们最终确定配置值后非常有用。</p><h2 id="eb00" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">5.1 安卓系统</h2><p id="967f" class="pw-post-body-paragraph kd ke iq kf b kg lw ki kj kk lx km kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">在 Android 中使用这个复活节彩蛋需要两步。</p><p id="6205" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> 5.1.1 依赖性<br/> </strong>我们必须在 Android 中单独打包非 UI 变体，因为我们想避免将 CEP 放在启动器上。由于清单合并，当我们依赖库的 UI 变体时，CEP 是自动配置的。</p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="og oh l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">[5.1.1] <a class="ae kc" href="https://github.com/juliuscanute/multi-config/blob/master/sampleAndroid/app/build.gradle" rel="noopener ugc nofollow" target="_blank">非 UI 依赖</a></figcaption></figure><p id="2e1b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> 5.1.2 初始化库<br/> </strong>你会发现初始化时缺少开始意图和上下文。</p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="og oh l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">[5.1.2] <a class="ae kc" href="https://github.com/juliuscanute/multi-config/blob/master/sampleAndroid/app/src/prod/java/com/juliuscanute/sampleandroid/SampleApp.kt" rel="noopener ugc nofollow" target="_blank">初始化库</a></figcaption></figure><h2 id="c0c8" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">5.2 iOS 初始化库</h2><p id="3203" class="pw-post-body-paragraph kd ke iq kf b kg lw ki kj kk lx km kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">你会发现组名和启动控制器在初始化时丢失了。</p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="og oh l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">[5.2] <a class="ae kc" href="https://github.com/juliuscanute/multi-config/blob/master/sampleios/sampleios/Configuration.swift" rel="noopener ugc nofollow" target="_blank">初始化库</a></figcaption></figure><h2 id="e8a6" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">5.3 输出</h2><p id="c30d" class="pw-post-body-paragraph kd ke iq kf b kg lw ki kj kk lx km kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">下图显示了应用程序开始使用库中没有持久层和 UI 层的 DSL。</p><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/39c9d39c2ebe0574acc1d0411cb0da5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1296/format:webp/1*hdHrKisv5q52goPPHhXiHg.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">[5]没有用户界面开始</figcaption></figure><p id="3fe9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们已经到达了多平台旅程的终点，在我们离开之前，我有一些评论。在撰写本文时，多平台还处于试验阶段。在它稳定之前，这里显示的实现允许我在测试环境中使用代码，并获得进一步扩展其用途的信心。</p><p id="4a14" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我进行这次旅行是因为我对能够使用 Kotlin 针对多个平台的提议感到兴奋。当我从 Swift 调用顶级 Kotlin 函数、Kotlin 对象和重载成员函数时，我感到惊讶了几次。但是，不用担心，您可以使用生成的框架头文件轻松找到自己的路。</p><p id="453f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这一点上，我们总结这一材料，希望它是有用的人谁采取多平台的冒险。然而，当我看着[5]上的插图时，我不禁思考一个事实:</p><blockquote class="nm"><p id="b769" class="nn no iq bd np nq nr ns nt nu nv la dk translated">虽然我们有分歧，但我们的本质是相同的。</p></blockquote><h1 id="7e27" class="mk lc iq bd ld ml mm mn lg mo mp mq lj mr nx mt lm mu ny mw lp mx nz mz ls na bi translated">参考</h1><ol class=""><li id="fac0" class="lu lv iq kf b kg lw kk lx ko ly ks lz kw ma la oj mc md me bi translated"><a class="ae kc" href="https://kotlinlang.org/docs/reference/building-mpp-with-gradle.html" rel="noopener ugc nofollow" target="_blank">https://kot linlang . org/docs/reference/building-MPP-with-grad le . html</a></li><li id="5a00" class="lu lv iq kf b kg mf kk mg ko mh ks mi kw mj la oj mc md me bi translated"><a class="ae kc" href="https://eladnava.com/publish-a-universal-binary-ios-framework-in-swift-using-cocoapods/" rel="noopener ugc nofollow" target="_blank">https://eladnava . com/publish-a-universal-binary-IOs-framework-in-swift-using-cocoapods/</a></li><li id="b104" class="lu lv iq kf b kg mf kk mg ko mh ks mi kw mj la oj mc md me bi translated"><a class="ae kc" href="https://github.com/bintray/gradle-bintray-plugin" rel="noopener ugc nofollow" target="_blank">https://github.com/bintray/gradle-bintray-plugin</a></li><li id="0afb" class="lu lv iq kf b kg mf kk mg ko mh ks mi kw mj la oj mc md me bi translated"><a class="ae kc" href="https://developer.apple.com/xcode/swiftui/" rel="noopener ugc nofollow" target="_blank">https://developer.apple.com/xcode/swiftui/</a></li><li id="cadf" class="lu lv iq kf b kg mf kk mg ko mh ks mi kw mj la oj mc md me bi translated"><a class="ae kc" href="https://developer.android.com/jetpack/compose" rel="noopener ugc nofollow" target="_blank">https://developer.android.com/jetpack/compose</a></li><li id="c168" class="lu lv iq kf b kg mf kk mg ko mh ks mi kw mj la oj mc md me bi translated"><a class="ae kc" href="https://kotlinlang.org/docs/reference/platform-specific-declarations.html" rel="noopener ugc nofollow" target="_blank">https://kot linlang . org/docs/reference/platform-specific-declarations . html</a></li><li id="dfdc" class="lu lv iq kf b kg mf kk mg ko mh ks mi kw mj la oj mc md me bi translated"><a class="ae kc" href="https://kotlinlang.org/docs/tutorials/native/apple-framework.html" rel="noopener ugc nofollow" target="_blank">https://kot linlang . org/docs/tutorials/native/apple-framework . html</a></li><li id="813f" class="lu lv iq kf b kg mf kk mg ko mh ks mi kw mj la oj mc md me bi translated"><a class="ae kc" href="https://kotlinlang.org/docs/reference/type-safe-builders.html" rel="noopener ugc nofollow" target="_blank">https://kot linlang . org/docs/reference/type-safe-builders . html</a></li><li id="ceb9" class="lu lv iq kf b kg mf kk mg ko mh ks mi kw mj la oj mc md me bi translated"><a class="ae kc" href="https://developer.android.com/training/data-storage/shared-preferences" rel="noopener ugc nofollow" target="_blank">https://developer . Android . com/training/data-storage/shared-preferences</a></li><li id="c646" class="lu lv iq kf b kg mf kk mg ko mh ks mi kw mj la oj mc md me bi translated"><a class="ae kc" href="https://developer.apple.com/documentation/foundation/nsuserdefaults" rel="noopener ugc nofollow" target="_blank">https://developer . apple . com/documentation/foundation/nsuserfaults</a></li><li id="d6ab" class="lu lv iq kf b kg mf kk mg ko mh ks mi kw mj la oj mc md me bi translated"><a class="ae kc" href="https://github.com/russhwolf/multiplatform-settings" rel="noopener ugc nofollow" target="_blank">https://github.com/russhwolf/multiplatform-settings</a></li><li id="e07b" class="lu lv iq kf b kg mf kk mg ko mh ks mi kw mj la oj mc md me bi translated"><a class="ae kc" href="https://github.com/Kotlin/kotlinx.serialization" rel="noopener ugc nofollow" target="_blank">https://github.com/Kotlin/kotlinx.serialization</a></li></ol></div></div>    
</body>
</html>