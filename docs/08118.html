<html>
<head>
<title>React Hook — useEvent</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React Hook —使用事件</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/react-hook-useevent-aa2bc203574d?source=collection_archive---------0-----------------------#2022-05-18">https://blog.devgenius.io/react-hook-useevent-aa2bc203574d?source=collection_archive---------0-----------------------#2022-05-18</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/d21b465efaf110278ac32a3c9a4c7905.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4_YvmRsMz2wfnlplKaJ6Tw.jpeg"/></div></div></figure><p id="ff07" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="kt">👉🏼在我的网站上看文章</em> <a class="ae ku" href="https://oukunanan.me/react/use-event-hook?utm_source=medium&amp;utm_medium=referal&amp;utm_campaign=use-event-hook" rel="noopener ugc nofollow" target="_blank"> <em class="kt">在这里看</em> </a> <em class="kt">👈🏼</em></p><h1 id="af95" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">TLDR</h1><p id="1918" class="pw-post-body-paragraph jv jw in jx b jy lt ka kb kc lu ke kf kg lv ki kj kk lw km kn ko lx kq kr ks ig bi translated">useEvent 钩子<strong class="jx io">将<em class="kt">保持函数引用，并且不会在重新呈现的<strong class="jx io"><em class="kt"/></strong>组件之间重新创建</em> </strong>。</p><h1 id="a43b" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">为什么使用事件？</h1><p id="c56d" class="pw-post-body-paragraph jv jw in jx b jy lt ka kb kc lu ke kf kg lv ki kj kk lw km kn ko lx kq kr ks ig bi translated">考虑下面的代码片段:</p><figure class="lz ma mb mc gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ly"><img src="../Images/13efa88db8096c5aa4c0c20ee7086f1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GwRiVxO-c14rxLjtYvKFCA.png"/></div></div></figure><p id="443f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们假设在内部用<strong class="jx io"> <em class="kt"> React.memo </em> </strong>包装了“SendButton ”,当“Parent”被重新呈现时，“SendButton”也被重新呈现。</p><p id="8ff4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> React.memo 在重新渲染之间做了</strong> <strong class="jx io"> <em class="kt">浅显的比较</em> </strong>会破坏记忆，因为 handleOnClick 函数在每次重新渲染上都有一个<strong class="jx io"> <em class="kt">唯一的函数引用。</em></strong></p><p id="4c24" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果“SendButton”包含嵌套的或许多组件，这可能会导致性能问题，因为它们将被重新呈现。</p><figure class="lz ma mb mc gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi md"><img src="../Images/ff80267d0cca6de96d6ffad8296e2b0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hfOrjN9mlGqMlFr1ba072g.png"/></div></div></figure><p id="f28c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">即使函数体是相同的，但每次重新呈现时，都会创建一个新的“handleOnClick”函数，并且每个函数都是唯一的。</p><h1 id="bf61" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">用 useCallback 求解</h1><figure class="lz ma mb mc gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi md"><img src="../Images/38fe238f949e560bfa7ef57a7efebce7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CQQhMOKS29rCNwiPh0Ztyg.png"/></div></div></figure><p id="4149" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们用<strong class="jx io"> <em class="kt"> useCallback </em> </strong>包装了“handleOnClick”。除非<strong class="jx io"> <em class="kt">消息</em> </strong>的依赖关系发生变化，否则不会构造新的函数，“发送按钮”也不会重新呈现。不过很容易解决🤓。</p><p id="4248" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">大概不会。考虑如果<strong class="jx io"> <em class="kt">消息经常改变</em> </strong>，“handleOnClick”在每个重新渲染的版本中都是唯一的。此外，我们不能删除依赖项的消息，因为 handleOnClick 需要最新的消息值。Goshhhhhhhh。</p><p id="f6f9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们做了几件事，但问题仍然存在。让我们来讨论一下<strong class="jx io">使用事件</strong>。</p><h1 id="b768" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">向 useEvent 问好</h1><figure class="lz ma mb mc gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi me"><img src="../Images/a2e33e7eaef226fb14c9bf99f7e9199a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vj_SYOJnbOv334tZECZtKg.png"/></div></div></figure><p id="2514" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="kt"> useEvent </em>接口类似于 useCallback，但是<strong class="jx io"> <em class="kt">不包含依赖列表</em> </strong>。“handleOnClick”总是相同的参考值，并且<em class="kt">消息</em>将总是反映当前值。</p><p id="2af8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这样一来，背“SendButton”就行了，因为 onClick 道具的功能永远是一样的。</p><h1 id="a182" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">使用事件的示例</h1><figure class="lz ma mb mc gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mf"><img src="../Images/487482fddf7dc9296d225ea6a3e83345.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tzczDKA5fQsNyHubOh6Izg.png"/></div></div></figure><p id="fbaa" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是一个有点做作的例子，但无论如何🥲.如你所见。我们使用<em class="kt">获取</em>来获取数据。如果成功，成功烤面包机被激活；否则，故障烤面包机被激活。而且，《烤面包机》要求使用<strong class="jx io"> <em class="kt">主题和消息作为自变量</em>。</strong></p><p id="ff2d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">问题是，一旦主题改变，我们必须重新运行 useEffect 并获取数据，因为 useEffect 有一个主题作为依赖项。这不是我们想要的。我们只想第一次安装该组件。请尝试使用 useEvent 挂钩来解决该问题。</p><figure class="lz ma mb mc gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi me"><img src="../Images/160172504154e91c850b5506839b6989.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_wB9pWgl2Ak96D3WgDpugQ.png"/></div></div></figure><p id="f516" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">它可以分为两个功能。<strong class="jx io"> <em class="kt"> onFetchSuccess，onFetchFailed </em> </strong>用 useEvent 钩子包装。结果。这些函数可以访问最新的<em class="kt">主题</em>值和 useEffect，无需添加主题作为依赖项。</p><h1 id="1323" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">什么时候不应该使用 useEvent？</h1><h2 id="9173" class="mg kw in bd kx mh mi dn lb mj mk dp lf kg ml mm lj kk mn mo ln ko mp mq lr mr bi translated">在渲染过程中调用函数</h2><p id="4cc7" class="pw-post-body-paragraph jv jw in jx b jy lt ka kb kc lu ke kf kg lv ki kj kk lw km kn ko lx kq kr ks ig bi translated">如果在渲染过程中调用了 use event<strong class="jx io"><em class="kt">，则会抛出异常</em> </strong>。在这种情况下，useCallback 仍然有效。</p><figure class="lz ma mb mc gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ms"><img src="../Images/f321ba08b2a7940ae9edfcdb7e4ee281.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4aR_wzQh4l2ATHAcWNNFoA.png"/></div></div></figure><h2 id="8ff0" class="mg kw in bd kx mh mi dn lb mj mk dp lf kg ml mm lj kk mn mo ln ko mp mq lr mr bi translated">并非所有的功能都是事件</h2><p id="8b4b" class="pw-post-body-paragraph jv jw in jx b jy lt ka kb kc lu ke kf kg lv ki kj kk lw km kn ko lx kq kr ks ig bi translated">考虑下面根据“搜索”过滤“成员”的代码片段</p><figure class="lz ma mb mc gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mt"><img src="../Images/db4c53b839293db0fcffd9e825d6d34d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a7z-Sn-gVQBzsW_bquE0tQ.png"/></div></div></figure><p id="2f6b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">是<strong class="jx io"> <em class="kt">不工作</em>。</strong>由于“更新成员”被标记为事件。useEffect 将不再依赖于“搜索”，“成员”将不再在搜索时更新。<em class="kt">所以请确保您正确地将该功能标记为事件</em>。</p><h1 id="f2b0" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">结论</h1><p id="aba9" class="pw-post-body-paragraph jv jw in jx b jy lt ka kb kc lu ke kf kg lv ki kj kk lw km kn ko lx kq kr ks ig bi translated">useEvent 可以解决重新验证太多 useCallback 的问题，或者回答这样一个问题(我是否应该到处使用 Callback？).如果你想进一步了解 useEvent。请检查 React Github 上的<a class="ae ku" href="https://github.com/reactjs/rfcs/blob/useevent/text/0000-useevent.md" rel="noopener ugc nofollow" target="_blank">官方 RFC。</a></p><p id="43cd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但与此同时，我写了这篇文章。在 React 的当前版本中，useEvent 钩子<em class="kt">不可用</em>。所以请密切关注下一次更新！感谢您的阅读。希望你喜欢。👋🏼</p></div></div>    
</body>
</html>