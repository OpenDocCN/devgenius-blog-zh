<html>
<head>
<title>How to Build and Run a NodeJS app with Docker &amp; GitHub Actions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用 Docker &amp; GitHub 操作构建和运行 NodeJS 应用程序</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-to-build-and-run-a-nodejs-app-with-docker-github-actions-59eb264dfef5?source=collection_archive---------0-----------------------#2021-06-25">https://blog.devgenius.io/how-to-build-and-run-a-nodejs-app-with-docker-github-actions-59eb264dfef5?source=collection_archive---------0-----------------------#2021-06-25</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="fcd2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用 GitHub 操作将 NodeJS 应用程序映像部署到 Docker Hub</p><blockquote class="ki kj kk"><p id="e7f0" class="jk jl kl jm b jn jo jp jq jr js jt ju km jw jx jy kn ka kb kc ko ke kf kg kh ig bi translated"><strong class="jm io">假设— </strong>在本教程演示中。我假设您对构建 NodeJs 应用程序有些熟悉，对 Docker 和 GitHub 操作有一些基本的基础知识。否则，首先检查以下内容:</p></blockquote><ul class=""><li id="21d2" class="kp kq in jm b jn jo jr js jv kr jz ks kd kt kh ku kv kw kx bi translated"><a class="ae ky" href="https://blog.usejournal.com/what-is-docker-in-simple-english-a24e8136b90b" rel="noopener ugc nofollow" target="_blank">什么是 Docker？【简单英语】</a></li><li id="f077" class="kp kq in jm b jn kz jr la jv lb jz lc kd ld kh ku kv kw kx bi translated"><a class="ae ky" href="https://blog.bitsrc.io/what-are-github-actions-and-how-to-use-them-e89904201a41" rel="noopener ugc nofollow" target="_blank">什么是 GitHub 动作以及如何使用它们</a></li></ul><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi le"><img src="../Images/5b449990527b6be046c0f76e6b8029fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vbBOtBw4saCBsXeFYfx7pQ.png"/></div></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">图片来源:<a class="ae ky" href="https://lab.github.com/githubtraining/github-actions:-write-docker-container-actions" rel="noopener ugc nofollow" target="_blank">lab.github.com</a></figcaption></figure><p id="4446" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这个演示中，我们将创建一个使用<a class="ae ky" href="https://expressjs.com/" rel="noopener ugc nofollow" target="_blank"> Express </a>框架的 nodeJS 演示应用程序。我们将构建 nodeJS 应用程序 docker 映像，并在 docker 容器中运行它以在本地测试它。</p><p id="839a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后，我们将为 CI/CD 设置一个 GitHub 操作作业，该作业构建 docker 映像并将其推送到<a class="ae ky" href="https://hub.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker Hub </a>供将来使用。</p><p id="7bf2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最后，我们将从 Docker Hub 存储库中提取存储的映像，并在本地构建另一个容器，以展示我们如何使用 Docker 重新创建和扩展应用程序。</p></div><div class="ab cl lu lv hr lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ig ih ii ij ik"><h1 id="a892" class="mb mc in bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">1.构建 NodeJS 应用程序</h1><blockquote class="ki kj kk"><p id="1df4" class="jk jl kl jm b jn jo jp jq jr js jt ju km jw jx jy kn ka kb kc ko ke kf kg kh ig bi translated">如果您已经有了 nodejs 应用程序，请跳过这一步！！</p></blockquote><p id="cfb3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们首先创建一个项目的目录，我将把我的命名为<code class="fe mz na nb nc b">node-demo</code>。我正在 GitHub 上创建一个 git repo，它将在我的计算机上克隆，如下所示:</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi nd"><img src="../Images/c850e95170dc71d245ebb21821b69671.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*WKz3JoAT6RZ8PQpzx5_SCQ.gif"/></div></div></figure><p id="73ae" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">接下来，在 EDI 上打开 repo，让我们创建应用程序的文件，以及所有需要的其他文件夹。我们需要创建的主要内容是:</p><ul class=""><li id="c68b" class="kp kq in jm b jn jo jr js jv kr jz ks kd kt kh ku kv kw kx bi translated">创建<code class="fe mz na nb nc b">app.js</code>文件，这将是应用程序的入口点。</li></ul><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi ne"><img src="../Images/5e55bcaedcce513c6c0a4c1c58304a58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4KiclLCF0wgoLW4-0wIhJg.png"/></div></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">图片来源:<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Learn/Server-side/Express_Nodejs/routes" rel="noopener ugc nofollow" target="_blank">developer.mozilla.org</a></figcaption></figure><ul class=""><li id="a908" class="kp kq in jm b jn jo jr js jv kr jz ks kd kt kh ku kv kw kx bi translated">"<strong class="jm io">路由</strong>"将支持的请求(以及请求 URL 中编码的任何信息)转发给适当的控制器功能。</li><li id="d93b" class="kp kq in jm b jn kz jr la jv lb jz lc kd ld kh ku kv kw kx bi translated"><strong class="jm io">控制器</strong>的功能是从模型中获取请求的数据，创建一个显示数据的 HTML 页面，并返回给用户在浏览器中查看。</li><li id="a59a" class="kp kq in jm b jn kz jr la jv lb jz lc kd ld kh ku kv kw kx bi translated">控制器用来呈现数据的页面或视图 (HTML 页面)——我们将把它用于主页。</li></ul><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi nd"><img src="../Images/70f9b78fbb6112e09803f0e22ae97a51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*fmQZuz1eulgkL8sLArUgpQ.gif"/></div></div></figure><p id="f3ed" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">初始化项目—这将创建 package.json 文件:</p><pre class="lf lg lh li gt nf nc ng nh aw ni bi"><span id="edb6" class="nj mc in nc b gy nk nl l nm nn">npm init</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi nd"><img src="../Images/693bb64b8010bb58e42d18cd793f8cb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*wBhYK-14U-wWN2e-2_ZW-Q.gif"/></div></div></figure><p id="797b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">安装运行应用程序所需的所有依赖项—我们将使用<a class="ae ky" href="https://expressjs.com/" rel="noopener ugc nofollow" target="_blank"> Express </a>框架— <a class="ae ky" href="https://babeljs.io/docs/en/babel-preset-env" rel="noopener ugc nofollow" target="_blank"> babel-preset-env </a>允许您使用最新的 JavaScript，而无需微观管理语法转换— <a class="ae ky" href="https://jestjs.io/" rel="noopener ugc nofollow" target="_blank"> Jest </a>是一个 JavaScript 测试框架，我们将使用它来测试 nodeJS 应用程序(添加了 _test_ folder 和<code class="fe mz na nb nc b">test.spec.js</code>文件)。</p><pre class="lf lg lh li gt nf nc ng nh aw ni bi"><span id="db8a" class="nj mc in nc b gy nk nl l nm nn">npm install express  <br/>npm install babel-cli<br/>npm install babel-preset<br/>npm install babel-preset-env  <br/>npm install jest</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi nd"><img src="../Images/b5aca61904e6b3dd6bc3ee0f28e45fa0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*ZnURGMpwGQzPhI3ZiQM19w.gif"/></div></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">安装依赖项并添加测试文件</figcaption></figure><p id="28b3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在让我们在主项目目录中打开<code class="fe mz na nb nc b">app.js</code>来定义项目的配置。我的<code class="fe mz na nb nc b">app.js</code>长这样:</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="no np l"/></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">请阅读评论，以了解每个部分或行做什么！</figcaption></figure><p id="6b46" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们在<code class="fe mz na nb nc b">./source/pages/home.html</code>中为这个演示项目建立一个 HTML 主页。我的看起来像这样:</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="13cc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">接下来，让我们在<code class="fe mz na nb nc b">./source/controllers/ontroller.js</code>中定义一些演示函数，这些函数将被传递到 route.js 文件中的每个路由或端点。我的<code class="fe mz na nb nc b">controller.js</code>长这样:</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="no np l"/></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">请阅读评论，以了解每个部分或行做什么！</figcaption></figure><p id="ecd0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个阶段的下一步是在<code class="fe mz na nb nc b">./source/routes/route.js</code>中设置端点，这些是将被传递到 app.js 文件中的 nodeJS 应用程序的路由端点。我的<code class="fe mz na nb nc b">route.js</code>长这样:</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="no np l"/></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">请阅读评论，以了解每个部分或行做什么！</figcaption></figure><p id="16ec" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最后但同样重要的是，让我们在<code class="fe mz na nb nc b">./source/_test_/test.spec.js</code>中添加一个测试函数，这是当<em class="kl">“test”</em>:“jest”运行时将运行的函数。这是在我们的 package.json 中定义的。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="99eb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，让我们通过运行以下命令来测试和启动 nodeJS 应用程序:</p><pre class="lf lg lh li gt nf nc ng nh aw ni bi"><span id="9502" class="nj mc in nc b gy nk nl l nm nn">npm test  <br/>npm start</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi nd"><img src="../Images/3102eb50b78c51d7d7919a03608ac1fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*BmZXsnKcSsOF-dWRRYegGw.gif"/></div></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">演示测试节点应用程序正在运行</figcaption></figure></div><div class="ab cl lu lv hr lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ig ih ii ij ik"><h1 id="6db7" class="mb mc in bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">2.设置 Docker-构建 NodeJS 应用程序 Docker 映像</h1><p id="e428" class="pw-post-body-paragraph jk jl in jm b jn nq jp jq jr nr jt ju jv ns jx jy jz nt kb kc kd nu kf kg kh ig bi translated">现在我们有了 nodeJS 应用程序。让我们设置 docker 构建上下文来构建 docker 映像。</p><blockquote class="ki kj kk"><p id="dbca" class="jk jl kl jm b jn jo jp jq jr js jt ju km jw jx jy kn ka kb kc ko ke kf kg kh ig bi translated"><strong class="jm io">创建 dockerignore </strong></p></blockquote><p id="d43f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们将从在项目的根目录中创建<code class="fe mz na nb nc b">.dockerignore</code>开始。<strong class="jm io"> dockerignore </strong>文件类似于 git 工具使用的 gitignore 文件。类似于。gitignore file，它允许您为文件和文件夹指定一种模式，在生成构建上下文时，这些文件和文件夹应该被<strong class="jm io"> Docker </strong>客户端<strong class="jm io">忽略</strong>。我的<code class="fe mz na nb nc b">.dockerignore</code>文件是这样的:</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="no np l"/></div></figure><blockquote class="ki kj kk"><p id="8393" class="jk jl kl jm b jn jo jp jq jr js jt ju km jw jx jy kn ka kb kc ko ke kf kg kh ig bi translated"><strong class="jm io">创建 Dockerfile </strong></p></blockquote><p id="4df0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Dockerfile 就像一个蓝图，它定义了 docker 映像将如何构建，并指定当映像在 docker 容器中运行时，我们的应用程序中将包含什么。我的<code class="fe mz na nb nc b">Dockerfile</code>文件是这样的:</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="no np l"/></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">请阅读评论，以了解每个部分或行做什么！</figcaption></figure><blockquote class="ki kj kk"><p id="dfb7" class="jk jl kl jm b jn jo jp jq jr js jt ju km jw jx jy kn ka kb kc ko ke kf kg kh ig bi translated"><strong class="jm io">构建应用程序 docker 映像</strong></p></blockquote><p id="e639" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在让我们使用<code class="fe mz na nb nc b"><a class="ae ky" href="https://docs.docker.com/engine/reference/commandline/build/" rel="noopener ugc nofollow" target="_blank">docker build</a></code>命令构建应用程序映像。带有<code class="fe mz na nb nc b">docker build</code>的<code class="fe mz na nb nc b">-t</code>旗帜将允许您为图像添加一个易于记忆的名称:</p><pre class="lf lg lh li gt nf nc ng nh aw ni bi"><span id="d7dd" class="nj mc in nc b gy nk nl l nm nn">docker build . -t <!-- -->your_dockerhub_username<!-- -->/nodejs-demo</span></pre><p id="a1ac" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在上面的命令中，我将我的图像标记为<code class="fe mz na nb nc b">yanndocker/nodejs-demo</code>。确保你用自己的 Docker Hub 用户名替换了<code class="fe mz na nb nc b">your_dockerhub_username</code>,并随意命名你的应用映像。这很重要，因为我们将把图像推送到 Docker Hub。docker 映像构建完成后，检查您的映像:</p><pre class="lf lg lh li gt nf nc ng nh aw ni bi"><span id="885a" class="nj mc in nc b gy nk nl l nm nn">docker images</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi nd"><img src="../Images/6b584f46b0c7b365823eed8c529bd8ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*YqAFgRzp5_uLtK0t5T_SOA.gif"/></div></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">构建 docker 图像—屏幕截图</figcaption></figure><blockquote class="ki kj kk"><p id="c4f4" class="jk jl kl jm b jn jo jp jq jr js jt ju km jw jx jy kn ka kb kc ko ke kf kg kh ig bi translated"><strong class="jm io">在容器中运行应用程序映像</strong></p></blockquote><p id="9462" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们用之前使用<code class="fe mz na nb nc b"><a class="ae ky" href="https://docs.docker.com/engine/reference/commandline/run/" rel="noopener ugc nofollow" target="_blank">docker run</a></code>构建的 app docker 映像创建一个容器:</p><pre class="lf lg lh li gt nf nc ng nh aw ni bi"><span id="d979" class="nj mc in nc b gy nk nl l nm nn">docker run --name nodejs-app-demo -it -d -p 3000:3000 yanndocker/nodejs-demo</span></pre><ul class=""><li id="b78e" class="kp kq in jm b jn jo jr js jv kr jz ks kd kt kh ku kv kw kx bi translated"><code class="fe mz na nb nc b">-p</code>:发布容器上的端口，并将其映射到主机上的端口。我使用主机上的端口<code class="fe mz na nb nc b">3000</code>,但是如果您有另一个进程在该端口上运行，可以随意修改。</li><li id="77f7" class="kp kq in jm b jn kz jr la jv lb jz lc kd ld kh ku kv kw kx bi translated"><code class="fe mz na nb nc b">-d</code>:这在后台运行容器。</li><li id="0807" class="kp kq in jm b jn kz jr la jv lb jz lc kd ld kh ku kv kw kx bi translated"><code class="fe mz na nb nc b">-it</code>以交互模式启动容器，允许您与容器的<code class="fe mz na nb nc b">/bin/bash</code>交互。</li><li id="11c0" class="kp kq in jm b jn kz jr la jv lb jz lc kd ld kh ku kv kw kx bi translated"><code class="fe mz na nb nc b">--name</code>:给容器起一个有意义的名字。</li></ul><p id="2d82" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有关这些标志如何工作的更多信息，请查阅<a class="ae ky" href="https://docs.docker.com/engine/reference/commandline/run/#:~:text=Attach%20to%20STDIN%2FSTDOUT%2FSTDERR,output%20and%20input%20as%20needed.&amp;text=This%20pipes%20data%20into%20a,only%20to%20the%20container's%20STDIN%20." rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> <em class="kl"> docker 文档</em> </strong> </a>。一旦您的容器启动并运行，您可以使用<code class="fe mz na nb nc b"><a class="ae ky" href="https://docs.docker.com/engine/reference/commandline/ps/" rel="noopener ugc nofollow" target="_blank">docker ps</a></code>来检查正在运行的容器列表:</p><pre class="lf lg lh li gt nf nc ng nh aw ni bi"><span id="46c9" class="nj mc in nc b gy nk nl l nm nn">docker ps</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi nd"><img src="../Images/64fdc33026a7d8caa49aeadfbe982504.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*a2GiHJzGGfvxT9lOBt7zOw.gif"/></div></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">演示从 docker 容器运行 NodeJS docker 映像</figcaption></figure><h1 id="4c06" class="mb mc in bd md me nv mg mh mi nw mk ml mm nx mo mp mq ny ms mt mu nz mw mx my bi translated">3.GitHub 操作 CI/CD &amp;将图像推送到 Docker Hub</h1><p id="d986" class="pw-post-body-paragraph jk jl in jm b jn nq jp jq jr nr jt ju jv ns jx jy jz nt kb kc kd nu kf kg kh ig bi translated">我们已经构建了我们的演示应用 docker 映像，并通过在本地容器中运行它进行了测试。我们现在将 CI/CD 设置为我们的项目，并将映像推送到 Docker Hub。</p><blockquote class="ki kj kk"><p id="301e" class="jk jl kl jm b jn jo jp jq jr js jt ju km jw jx jy kn ka kb kc ko ke kf kg kh ig bi translated"><strong class="jm io">设置 Github 动作 CI/CD </strong></p></blockquote><ul class=""><li id="151c" class="kp kq in jm b jn jo jr js jv kr jz ks kd kt kh ku kv kw kx bi translated">首先提交您在 EDI 上本地进行的所有更改，并将它们推送到 GitHub 上的远程 git repo</li><li id="e4fc" class="kp kq in jm b jn kz jr la jv lb jz lc kd ld kh ku kv kw kx bi translated">接下来，转到 GitHub repo 并添加 CI/CD 操作，如下所示:</li></ul><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi nd"><img src="../Images/3f50a8cb173d4f7bd9eab8b2a68a1772.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*tIAI-moKQ1QFBqzuFIIP6A.gif"/></div></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">添加 GitHub 操作任务—屏幕截图</figcaption></figure><ul class=""><li id="24b7" class="kp kq in jm b jn jo jr js jv kr jz ks kd kt kh ku kv kw kx bi translated">现在，在本地工作目录中提取新的更改，并使用以下内容修改 GitHub 操作作业:</li></ul><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="no np l"/></div></figure><blockquote class="ki kj kk"><p id="53b6" class="jk jl kl jm b jn jo jp jq jr js jt ju km jw jx jy kn ka kb kc ko ke kf kg kh ig bi translated"><strong class="jm io">导入注意——在将新定义的 Github 工作流推送到您的远程 git repo 之前，请确保您已经完成了以下工作:</strong></p></blockquote><ul class=""><li id="5ed0" class="kp kq in jm b jn jo jr js jv kr jz ks kd kt kh ku kv kw kx bi translated">将你的 Docker 用户名和令牌作为秘密添加到你的 GitHub repo 中</li><li id="4ab9" class="kp kq in jm b jn kz jr la jv lb jz lc kd ld kh ku kv kw kx bi translated">在 Docker Hub 上创建您的项目，您将在这里推送图像。</li></ul><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi nd"><img src="../Images/d97b365c2fb0d2b2441d1360d73c8227.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*zhzYNnLAYvfrDsaTzY16Pg.gif"/></div></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">这些步骤很重要，也是必需的，否则您的 CI/CD 管道将会失败。</figcaption></figure><p id="fe9e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在我们都准备好了！让我们继续提交更改，并将我们的代码推送到 GitHub repo 和 watch 以及 CI/CD pipeline 中进行操作:</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi nd"><img src="../Images/0e34c09e7dd91c854573e581cbe34382.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*1O2OhmZjKRGhDGXMTeo5sg.gif"/></div></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">演示 Github Action CI/CD 的运行——截图</figcaption></figure><p id="b5a5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">全部完成！！现在，您已经为 NodeJS 应用程序项目建立了一个完整的 CI/CD 管道，它将在每个代码提交和推送到 repo 时执行以下操作:</p><ul class=""><li id="c14a" class="kp kq in jm b jn jo jr js jv kr jz ks kd kt kh ku kv kw kx bi translated">构建并测试 nodejs 应用程序</li><li id="7b69" class="kp kq in jm b jn kz jr la jv lb jz lc kd ld kh ku kv kw kx bi translated">构建应用 docker 映像，通过在容器中运行它来测试它，并将该映像推送到您的 Docker Hub repo，以供将来使用、应用共享和部署到其他平台。</li></ul><blockquote class="ki kj kk"><p id="a162" class="jk jl kl jm b jn jo jp jq jr js jt ju km jw jx jy kn ka kb kc ko ke kf kg kh ig bi translated">余灿在我的<a class="ae ky" href="https://github.com/YannMjl/nodejs-demo-app" rel="noopener ugc nofollow" target="_blank"> github repo </a>上审查所有代码。如果你喜欢这个，你可能也会喜欢这个 tuto 的下一个:<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/how-to-deploy-to-kubernetes-heroku-using-docker-c2556a9584df">如何部署到 kubernetes-heroku-using-docker</a></p></blockquote></div></div>    
</body>
</html>