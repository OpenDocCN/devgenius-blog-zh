<html>
<head>
<title>Analyzing and Optimizing Database interactions with Django and pyodbc</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">分析和优化与 Django 和 pyodbc 的数据库交互</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/analyzing-and-optimizing-database-interactions-with-django-and-pyodbc-427ce491fa3?source=collection_archive---------11-----------------------#2022-03-05">https://blog.devgenius.io/analyzing-and-optimizing-database-interactions-with-django-and-pyodbc-427ce491fa3?source=collection_archive---------11-----------------------#2022-03-05</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="eefb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最近，我对我领导的基于 Django 的数据平台的数据库交互活动进行了一些调查，以发现需要优化的地方，并发现了一些令人惊讶的行为。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/62c980df694815a5e1d829f52d3984ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UsJNwOXl7Lft6x-VfkTjsg.jpeg"/></div></div></figure><p id="7b7d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有很多方法可以查看 Django 应用程序查询的 SQL 语句输出，比如配置<code class="fe ku kv kw kx b">django.db.backends</code>日志记录器或者使用<a class="ae ky" href="https://github.com/jazzband/django-debug-toolbar" rel="noopener ugc nofollow" target="_blank"> django-debug-toolbar </a>这样的工具。这将提供对您的应用程序的数据库交互行为的良好理解，以便隔离要优化的区域，然而这并不是故事的结尾。</p><h1 id="1030" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">SQL 之下</h1><p id="7227" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">Django ORM 查询产生的一个简单的参数化 SQL 语句(或者直接传递给<a class="ae ky" href="https://github.com/mkleehammer/pyodbc" rel="noopener ugc nofollow" target="_blank"> pyodbc </a>的<code class="fe ku kv kw kx b">execute()</code>方法)可能看起来像这样:</p><pre class="kj kk kl km gt mc kx md me aw mf bi"><span id="9928" class="mg la in kx b gy mh mi l mj mk">INSERT INTO person (first_name, last_name, date_of_birth, address) <br/>VALUES (?, ?, ?, ?); </span><span id="a326" class="mg la in kx b gy ml mi l mj mk">params=(‘John’, ‘Smith’, '1995-06-21', '123 Long Street')</span></pre><p id="3eee" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这应该只需要与数据库进行一次交互，对吗？不对。让我们潜入更深的地方。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mm"><img src="../Images/fbef3f5395d41a47a0a42cba80f35506.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZULTH3ddINHvH900AtYShQ.png"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">数据库查询流程图</figcaption></figure><p id="a2f5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">上面的流程图概括了使用 Django 和任何 ODBC 数据库后端进行数据库查询时所涉及的层。执行参数化 SQL 查询时，涉及多个步骤:</p><ol class=""><li id="15f4" class="mr ms in jm b jn jo jr js jv mt jz mu kd mv kh mw mx my mz bi translated">准备语句—这允许数据库服务器解析和编译语句，然后可以多次有效地重用该语句。这对应于<a class="ae ky" href="https://docs.microsoft.com/en-us/sql/odbc/reference/syntax/sqlprepare-function?view=sql-server-ver15" rel="noopener ugc nofollow" target="_blank"> SQLPrepare ODBC API 函数</a>。</li><li id="f89f" class="mr ms in jm b jn na jr nb jv nc jz nd kd ne kh mw mx my mz bi translated">绑定参数—参数值需要绑定到准备好的 SQL 语句中的参数标记。这对应于<a class="ae ky" href="https://docs.microsoft.com/en-us/sql/odbc/reference/syntax/sqlbindparameter-function?view=sql-server-ver15" rel="noopener ugc nofollow" target="_blank"> SQLBindParameter ODBC API 函数。</a></li><li id="6166" class="mr ms in jm b jn na jr nb jv nc jz nd kd ne kh mw mx my mz bi translated">执行查询-使用绑定的参数值执行准备好的语句。对应于<a class="ae ky" href="https://docs.microsoft.com/en-us/sql/odbc/reference/syntax/sqlexecute-function?view=sql-server-ver15" rel="noopener ugc nofollow" target="_blank"> SQLExecute ODBC API 函数</a>。</li><li id="c14a" class="mr ms in jm b jn na jr nb jv nc jz nd kd ne kh mw mx my mz bi translated">取消准备语句—当不再需要该语句时，应该从数据库服务器中释放其编译的资源。对应于<a class="ae ky" href="https://docs.microsoft.com/en-us/sql/odbc/reference/syntax/sqlfreehandle-function?view=sql-server-ver15" rel="noopener ugc nofollow" target="_blank"> SQLFreeHandle ODBC API 函数。</a></li></ol><p id="32a7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，一个简单的 SQL 查询实际上可以转化为与数据库的多次交互！</p><h1 id="b80e" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">深入挖掘</h1><p id="fbf0" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">理想情况下，当使用可能执行多次但具有不同参数值的参数化语句时，应该准备一次，然后语句句柄可以在每次后续执行中重复使用以提高效率。然而，<em class="nf"> pyodbc </em>仅在准备好的语句与<strong class="jm io">之前的</strong>语句相同时才重用该语句(一些扩展的准备好的语句缓存优化已经提出，但尚未实现)。</p><p id="9158" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，大多数情况下，每次执行查询都需要重复上述多步骤过程，即使在应用程序中经常重复使用该语句。幸运的是，在 MS SQLServer(可能还有其他数据库)中，一个 SQL 查询的准备和执行步骤实际上可以合并成一个与<code class="fe ku kv kw kx b">sp_prepexec </code> <a class="ae ky" href="https://docs.microsoft.com/en-us/sql/relational-databases/system-stored-procedures/sp-prepexec-transact-sql?view=sql-server-ver15" rel="noopener ugc nofollow" target="_blank">存储过程调用</a>的交互。您可以使用类似 SQLServer Profiler 的工具来查看与您的数据库进行了哪些交互。</p><p id="c2f4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">将参数绑定到准备好的语句需要提供要绑定的参数的 SQL 数据类型。正如作者在<a class="ae ky" href="https://github.com/mkleehammer/pyodbc/wiki/Binding-Parameters" rel="noopener ugc nofollow" target="_blank">这篇文章</a>中所描述的，<em class="nf"> pyodbc </em>经常可以使用提供的参数值的 Python 数据类型来推断适当的对应 SQL 类型，并将这些类型提供给<code class="fe ku kv kw kx b">SQLBindParameter </code> ODBC API 函数调用。</p><p id="6f38" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然而，这对于<code class="fe ku kv kw kx b">None</code>参数值来说是不可能的(即使值为 NULL，也仍然需要提供参数的 SQL 数据类型)。在这种情况下，<em class="nf"> pyodbc </em>需要向数据库执行一个额外的请求，以检索关于参数的 SQL 类型的元数据(使用<a class="ae ky" href="https://docs.microsoft.com/en-us/sql/odbc/reference/syntax/sqldescribeparam-function?view=sql-server-ver15" rel="noopener ugc nofollow" target="_blank">sqldescripeparam</a>ODBC API 函数)。在 SQLServer 中，这导致了一个额外的<code class="fe ku kv kw kx b">sp_describe_undeclared_parameters</code>过程调用，它占用的时间和数据库资源与下面执行实际数据操作的<code class="fe ku kv kw kx b">sp_prepexec</code>调用一样多。这最适用于<code class="fe ku kv kw kx b">INSERT </code>语句，因为<code class="fe ku kv kw kx b">IS NULL </code> SQL 子句应该在其他语句类型的<code class="fe ku kv kw kx b">WHERE </code>条件中使用(而不是将列等同于<code class="fe ku kv kw kx b">NULL </code>值)。</p><p id="4611" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这意味着包含<code class="fe ku kv kw kx b">None</code>参数值的参数化 SQL 语句可能需要额外的数据库交互，因此比不需要的语句要慢。</p><h1 id="0473" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">结果</h1><p id="fc9f" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">这项调查揭示了两种潜在的提高应用程序数据库交互性能的方法:</p><ol class=""><li id="9a49" class="mr ms in jm b jn jo jr js jv mt jz mu kd mv kh mw mx my mz bi translated">如果同一个 SQL 语句在您的应用程序中被多次重用(但是具有不同的参数值)，那么如果可能的话，请将它们一起批处理执行，这样就不需要每次都进行准备</li><li id="ec94" class="mr ms in jm b jn na jr nb jv nc jz nd kd ne kh mw mx my mz bi translated">尽可能避免插入 None 值——在 Django 的上下文中，这可能涉及到在保存之前寻找没有指定非 None 值的带有<code class="fe ku kv kw kx b">null=True</code>和<code class="fe ku kv kw kx b">default=None</code>的模型字段。</li></ol><p id="8af6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这些建议可能被认为是针对大容量查询的微优化，并且在大多数情况下，业务或应用程序逻辑需求应该优先考虑(与其他不适当的缺省值/空白值相比，最初保存字段中具有空值的模型/表条目可能更有意义)。</p><p id="9df5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">正如在<a class="ae ky" href="https://docs.djangoproject.com/en/4.0/topics/db/optimization/" rel="noopener ugc nofollow" target="_blank"> Django 文档</a>中所讨论的，还有其他方法可以优化数据库访问，这些方法可能会产生更大的影响，应该首先探索:</p><ul class=""><li id="f6e1" class="mr ms in jm b jn jo jr js jv mt jz mu kd mv kh ng mx my mz bi translated">当涉及模型关系时，在 Django 查询中添加<code class="fe ku kv kw kx b">select_related()</code>和<code class="fe ku kv kw kx b">prefetch_related()</code>调用</li><li id="4224" class="mr ms in jm b jn na jr nb jv nc jz nd kd ne kh ng mx my mz bi translated">使用<code class="fe ku kv kw kx b">bulk_create()</code>(或<em class="nf"> pyodbc </em> <code class="fe ku kv kw kx b">executemany()</code>)进行批量插入</li><li id="0e7c" class="mr ms in jm b jn na jr nb jv nc jz nd kd ne kh ng mx my mz bi translated">实现缓存(可以是视图级或查询级，使用类似于<a class="ae ky" href="https://github.com/noripyt/django-cachalot/blob/master/docs/index.rst" rel="noopener ugc nofollow" target="_blank"> django-cachalot </a>的东西)</li><li id="5973" class="mr ms in jm b jn na jr nb jv nc jz nd kd ne kh ng mx my mz bi translated">重构应用程序结构或逻辑，以减少数据库交互(例如执行完整的选择，并在内存中创建一个本地缓存来检查，而不是以后检查许多单独的目标选择)</li></ul><p id="d435" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我希望你喜欢这篇文章，也许对你自己的项目有所帮助！</p></div></div>    
</body>
</html>