<html>
<head>
<title>Cluster gone off, don’t worry Elastic got your data covered.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">群集关闭，不要担心弹性覆盖您的数据。</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/cluster-gone-off-dont-worry-elastic-got-your-data-covered-a1d7b90e6ea?source=collection_archive---------11-----------------------#2022-12-13">https://blog.devgenius.io/cluster-gone-off-dont-worry-elastic-got-your-data-covered-a1d7b90e6ea?source=collection_archive---------11-----------------------#2022-12-13</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/07d0a87037a04d96b5a3eef14855cf11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9G0VB2plhhn-hCzr7EE6zw.png"/></div></div></figure><p id="2979" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">本博客重点介绍<strong class="jx io"> <em class="kt">如何在弹性云上实现跨集群复制。</em>T3】</strong></p><p id="3beb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">数据可用性和灾难恢复是市场上任何用于生产的可靠数据存储库的两大支柱，Elasticsearch 在这些方面也不例外。</p><p id="ed28" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Elastic 使用的技术被称为<strong class="jx io">跨集群复制(CCR)。</strong>根据弹性最佳实践，在生产环境中处理有价值的敏感数据时，总是建议在两个不同的区域启动两个不同的集群，并在其中启用 CCR。</p><p id="814b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">通过在集群设置中启用 CCR，在后端使用 Elasticsearch 的应用程序将不会在托管具有所有主数据的弹性集群的任何数据中心发生不可预见的自然或人为灾难/中断事件时停机。</p><p id="4da9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在本博客后面解释跨集群复制时使用的一些技术术语是-</p><ol class=""><li id="8394" class="ku kv in jx b jy jz kc kd kg kw kk kx ko ky ks kz la lb lc bi translated"><strong class="jx io"> <em class="kt"> Leader index- </em> </strong>将保存主集群上所有主要数据的索引。</li><li id="6b36" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks kz la lb lc bi translated"><strong class="jx io"> <em class="kt">跟随者索引- </em> </strong>将在不同集群上复制的一个或多个索引，将保存来自领导者索引的所有数据。领导者和追随者索引之间的复制过程不仅发生在索引级别，也发生在碎片级别。</li></ol><p id="7170" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">跨集群复制可以有单向和双向设置，在本博客的演示中，它显示了前一种。</p><p id="74a4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">遵循下面解释的演示的先决条件:-</p><ol class=""><li id="647e" class="ku kv in jx b jy jz kc kd kg kw kk kx ko ky ks kz la lb lc bi translated"><strong class="jx io"> <em class="kt">你应该有一个 14 天的弹性云轨迹启用</em> </strong>来访问它这里是<a class="ae li" href="https://cloud.elastic.co/login" rel="noopener ugc nofollow" target="_blank">链接</a>。</li><li id="798b" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks kz la lb lc bi translated">请检查<a class="ae li" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/xpack-ccr.html#xpack-ccr" rel="noopener ugc nofollow" target="_blank">版本兼容性矩阵</a>，以确保包含追随者索引的集群必须运行与远程集群相同或更新的<strong class="jx io">版本的 Elasticsearch。为了便于演示，具有领导者和跟随者索引的两个集群的版本都保持为 8.5.0 版本</strong></li></ol><p id="c698" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">步骤 1- </strong>在 8.5.0 版本的两个不同区域中，创建两个不同的弹性集群，一个命名为 leader 集群，其中包含 leader 索引，另一个命名为 follower 集群，其中包含 follower 索引。两个集群的硬件配置保持相同。</p><figure class="lk ll lm ln gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lj"><img src="../Images/9cda7ee31fe92a4c28a500edf575952c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J4bBVkDaTlu2CyqD1LZiuQ.png"/></div></div></figure><figure class="lk ll lm ln gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lo"><img src="../Images/2bb7a75c38247cf0b965b2643e4965b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XmInC6rQ35EVcqAXAUj47g.png"/></div></div></figure><figure class="lk ll lm ln gt jo gh gi paragraph-image"><div class="gh gi lp"><img src="../Images/b6635f21d7c7fd7b33b33b52f6262bea.png" data-original-src="https://miro.medium.com/v2/resize:fit:824/format:webp/1*xiOtqQ8JUte0_KeXSTzQzw.png"/></div></figure><p id="088b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">步骤 2- </strong>转到跟随者集群，然后将领导者集群注册为远程集群。应能看到已连接的远程集群的状态，以验证连接是否已建立，详细过程如下面的 gif-所示</p><figure class="lk ll lm ln gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lq"><img src="../Images/c66648ae960c5205ac7848d98b7ca69a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*VvGcGvSob8B8zcCzMR5dGA.gif"/></div></div></figure><p id="2aa1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">步骤 3- </strong>创建一个名为 test inside leader index 的索引作为主索引，并通过定义该索引的适当映射和设置在其中插入一些随机数据。</p><pre class="lk ll lm ln gt lr ls lt bn lu lv bi"><span id="1d85" class="lw lx in ls b be ly lz l ma mb">#Create a test index<br/>PUT test<br/>{<br/>  "settings": {<br/>    "number_of_replicas": 1<br/>  },<br/>  "mappings": {<br/>    "properties": {<br/>      "name": {<br/>        "type": "text"<br/>      },<br/>      "age": {<br/>        "type": "integer"<br/>      }<br/>    }<br/>  }<br/>}<br/><br/># Now to insert a dummy document into test index inside leader cluster<br/><br/>POST test/_doc<br/>{<br/>  "name": "harry",<br/>  "age": 55<br/>}</span></pre><p id="0bf1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">步骤 4- </strong>在名为“跟随者集群”的集群上执行以下步骤-</p><p id="0484" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> <em class="kt">步骤 4.1- </em> </strong>单击堆栈管理，然后单击跨集群复制</p><p id="f93d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> <em class="kt">步骤 4.2- </em> </strong>在跨集群复制下点击跟随者索引。</p><p id="2e63" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> <em class="kt">步骤 4.3- </em> </strong>填写所需详细信息，给出远程集群和跟随者索引名称的详细信息。</p><p id="4c22" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> <em class="kt">步骤 4.4- </em> </strong>启用复制，然后检查创建的跟随者索引是否可见，这可以通过索引管理- &gt;索引进行检查，然后您可以在那里看到名为“test_follower”的跟随者索引。</p><p id="8a0e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这样做的详细过程显示在下面给出的 gif 中-</p><figure class="lk ll lm ln gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lq"><img src="../Images/9073100168c4e093f4f909402e62dbab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*dGfCPTQii0c8pVKLryCDMQ.gif"/></div></div></figure><p id="3220" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">步骤 5- </strong>另一种无需人工干预的创建追随者指数的方法是使用自动追随者模式。自动跟随模式的工作方式是，每次在遵循特定模式的领导者集群上创建领导者索引时，都会自动在跟随集群上创建其跟随者。这样做的详细过程如下所示-</p><p id="972a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> <em class="kt">步骤 5.1- </em> </strong>在从机集群上，在开发工具中运行该命令-</p><pre class="lk ll lm ln gt lr ls lt bn lu lv bi"><span id="0a90" class="lw lx in ls b be ly lz l ma mb">PUT /demo-001-follower/_ccr/follow<br/>{<br/>  "remote_cluster": "leader_cluster",<br/>  "leader_index": "demo-001",<br/>  "max_read_request_operation_count": 5120,<br/>  "max_outstanding_read_requests": 12,<br/>  "max_read_request_size": "32mb",<br/>  "max_write_request_operation_count": 5120,<br/>  "max_write_request_size": "9223372036854775807b",<br/>  "max_outstanding_write_requests": 9,<br/>  "max_write_buffer_count": 2147483647,<br/>  "max_write_buffer_size": "512mb",<br/>  "max_retry_delay": "500ms",<br/>  "read_poll_timeout": "1m"<br/>}</span></pre><p id="3ab2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> <em class="kt">步骤 5.2- </em> </strong>在主集群上，在开发工具中运行以下命令-</p><pre class="lk ll lm ln gt lr ls lt bn lu lv bi"><span id="6d1c" class="lw lx in ls b be ly lz l ma mb"># An index named demo-001 is created on the leader cluster<br/><br/>PUT demo-001 <br/>{<br/>  "settings": {<br/>    "number_of_replicas": 1<br/>  },<br/>  "mappings": {<br/>    "properties": {<br/>      "VehicleID": {<br/>        "type": "text"<br/>      },<br/>      "VehicleName": {<br/>        "type": "integer"<br/>      }<br/>    }<br/>  }<br/>}<br/><br/>POST demo-001/_doc<br/>{<br/>  "VehicleID": "88XYZ",<br/>  "type": 2<br/>}<br/><br/>GET demo-001/_search</span></pre><p id="8bda" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> <em class="kt">步骤 5.3- </em> </strong>在跟随者集群上，请查看堆栈管理下的索引管理，您应该能够看到名为“demo-001-跟随者”的索引</p><figure class="lk ll lm ln gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mc"><img src="../Images/6621035b1fa766ca9d7cc4ed3de5dd3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RnqP-Xhd1pCZ0WHat4p4zQ.png"/></div></div></figure><p id="9b55" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">除了复制数据用于灾难恢复之外，CCR 还有其他优势，即通过增加用户与集群的地理接近度来减少搜索延迟，并防止搜索量影响索引吞吐量。</p><p id="9408" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您刚刚看到了跨集群复制过程是如何以两种方式工作的，即分别通过跟随者索引和自动跟随者模式方法，还有助于在保存所有宝贵数据的数据中心发生停机或永久损坏时防止任何数据丢失。</p><p id="bad9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里有一个<a class="ae li" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/xpack-ccr.html#xpack-ccr" rel="noopener ugc nofollow" target="_blank">链接</a>到与 CCR 相关的 Elastic 的官方文档，供你探索更多。</p><p id="4bbe" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你喜欢我的博客，请喜欢，分享和评论我的博客，并提供宝贵的反馈，不要忘记关注我，在弹性技术栈上获得更多这样令人兴奋的内容。</p><p id="785d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">谢谢大家！</p></div></div>    
</body>
</html>