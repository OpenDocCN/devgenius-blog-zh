<html>
<head>
<title>Using Python’s built-in functions and libraries</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Python 的内置函数和库</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/using-pythons-built-in-functions-and-libraries-593983dd56cd?source=collection_archive---------14-----------------------#2020-06-21">https://blog.devgenius.io/using-pythons-built-in-functions-and-libraries-593983dd56cd?source=collection_archive---------14-----------------------#2020-06-21</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/e5f498f0cae2f02b4fb1e1b5e79f9fea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4AJb55XBQqAEDGPW"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">在<a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae jz" href="https://unsplash.com/@hiteshchoudhary?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Hitesh Choudhary </a>拍摄的照片</figcaption></figure><p id="35f3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我已经用 Python 编码一年多了，我一直在寻找更多的 Python 代码。我想分享一些我学到的有用的函数和库，并开始定期使用它们来编写简洁的 Pythonic 代码。我试图保持文章简短，但提供了更多信息的额外链接。</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h1 id="35fd" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">预赛</h1><p id="a651" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">你可以在 https://www.python.org/dev/peps/pep-0008/<a class="ae jz" href="https://www.python.org/dev/peps/pep-0008/" rel="noopener ugc nofollow" target="_blank">找到有用的风格指南和约定，比如命名约定，但是在这篇文章中，我想把重点放在编写更干净、更快速的代码上。</a></p><p id="4cdf" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">编写更多 Pythonic 代码的最典型方式可能是使用列表或字典理解，而不是 for 循环。例如，假设我们想列出前五个 2 的倍数。我们可以做</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="8f56" class="mr lg in mn b gy ms mt l mu mv">multiples = []<br/>for i in range(1, 6):<br/>    multiples.append(i * 2)</span></pre><p id="aed2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是在 Python 中，有一个使用列表理解的更加优雅和快速的版本</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="0cc0" class="mr lg in mn b gy ms mt l mu mv">multiples = [i * 2 for i in range(1, 6)]</span></pre><p id="bbd7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">类似地，假设我们有一个元组列表，每个元组包含一个人的姓名和年龄</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="558b" class="mr lg in mn b gy ms mt l mu mv">data = [('Alice', 20), ('Bob', 30), ('Charles', 40)]</span></pre><p id="32eb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们想把它转换成一个字典，名字作为键，年龄作为值。在 Python 中，我们可以通过字典理解简洁地做到这一点</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="78fb" class="mr lg in mn b gy ms mt l mu mv">data_dict = {name: age for name, age in data}</span></pre></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h1 id="057f" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">Python 的内置函数</h1><p id="49db" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">让我们先看一些 Python 内置函数的例子。</p><h2 id="cdb2" class="mr lg in bd lh mw mx dn ll my mz dp lp kl na nb lt kp nc nd lx kt ne nf mb ng bi translated">zip()</h2><p id="a077" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">让我们稍微改变一下上面的例子，试着从<em class="nh">数据</em>中分离出姓名和年龄到一个字典中:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="e6d7" class="mr lg in mn b gy ms mt l mu mv">data = [('Alice', 20), ('Bob', 30), ('Charles', 40)]<br/># turn into {'names': ['Alice', 'Bob', 'Charles'], 'ages': [20, 30, 40]}</span></pre><p id="b0f0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">要做到这一点，我们可以做到</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="2a30" class="mr lg in mn b gy ms mt l mu mv">names, ages = zip(*data)<br/>new_data = {'names': list(names), 'ages': list(ages)}</span></pre><p id="bcde" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">它甚至可以在一行中完成</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="2a38" class="mr lg in mn b gy ms mt l mu mv">new_data = {k: list(v) for k, v in zip(('names', 'ages'), zip(*data))}</span></pre><p id="ba38" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">尽管在这种情况下可读性差，速度也慢。</p><p id="f856" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">那么这是如何工作的呢？*将<em class="nh">数据</em>中的 3 个元组解包成 3 个独立的参数，传递给 Python 的内置<strong class="kc io"> zip </strong>函数。<em class="nh"> zip </em>函数获取 iterables 并将它们聚集在一个元组中。下面是一个稍微简单一点的使用 zip()的例子:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="68bf" class="mr lg in mn b gy ms mt l mu mv">a = [1, 2, 3]<br/>b = ['a', 'b', 'c']<br/>c = list(zip(a, b))  # gives [(1, 'a'), (2, 'b'), (3, 'c')]</span></pre><p id="dfeb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当然，我们还利用了<strong class="kc io"> list </strong>内置函数，该函数将<em class="nh"> zip </em>返回的元组转换为列表。</p><h2 id="b7a8" class="mr lg in bd lh mw mx dn ll my mz dp lp kl na nb lt kp nc nd lx kt ne nf mb ng bi translated">任意()和全部()</h2><p id="c451" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">假设我们有一个整数列表，想要检查其中是否有偶数。我们可以使用 for 循环，因为我们已经知道列表理解会更快</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="6201" class="mr lg in mn b gy ms mt l mu mv">integers = [1, 5, 7, 9, 11]  # some list of integers<br/>if [i for i in integers if i % 2 == 0]:<br/>    # do some stuff</span></pre><p id="971e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果列表中有内容，它评估为<em class="nh">真</em>，如果列表为空(即没有偶数)，那么它评估为<em class="nh">假</em>。另一种选择是使用内置的<strong class="kc io"> any </strong>函数，该函数接受一个 iterable，如果至少有一个元素为<em class="nh"> True </em>，则返回<em class="nh"> True </em></p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="6d9e" class="mr lg in mn b gy ms mt l mu mv">integers = [1, 5, 7, 9, 11]<br/>if any(i % 2 == 0 for i in integers):<br/>    # do some stuff</span></pre><p id="2d07" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这种方法更有效，因为我们不需要创建一个新的列表来检查它是否非空，而且可读性更好。</p><p id="71e2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果我们想检查所有的整数是否都是奇数，我们可以使用<strong class="kc io"> all </strong>函数</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="d938" class="mr lg in mn b gy ms mt l mu mv">if all(i % 2 == 1 for i in integers):<br/>    # do some stuff</span></pre><p id="2a71" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">只有当可迭代的所有元素都为<em class="nh">真</em>时，它才返回<em class="nh">真</em>。</p><h2 id="e76d" class="mr lg in bd lh mw mx dn ll my mz dp lp kl na nb lt kp nc nd lx kt ne nf mb ng bi translated">地图()</h2><p id="5d37" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">假设我们有一个整数列表，我们想列出这些整数的平方。例如<em class="nh">【1，2，3，4】</em>到<em class="nh">【1，4，9，16】</em>。最简单的方法是</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="c853" class="mr lg in mn b gy ms mt l mu mv">integers = [1, 2, 3, 4]<br/>squares = [i ** 2 for i in integers]</span></pre><p id="2254" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们也可以使用 Python 的<strong class="kc io"> map </strong>函数，它接受一个 iterable 和一个应用于 iterable 的每个元素的函数。</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="9715" class="mr lg in mn b gy ms mt l mu mv">squares = list(map(lambda x: x ** 2, integers))</span></pre><p id="0106" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里我们使用 Python 的<strong class="kc io"> lambda </strong>函数，它允许我们在一行中定义一个函数，而不是:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="3d02" class="mr lg in mn b gy ms mt l mu mv">def square(x):<br/>    return x ** 2<br/><br/>squares = list(map(square, integers))</span></pre><p id="2885" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">注意使用<em class="nh"> map </em>函数的好处是保持它作为一个迭代器。在这里，我将它包装在<em class="nh"> list </em>函数中，这样我们可以很容易地看到方块列表，但是最好使用<em class="nh"> map </em>来迭代方块。例如，我们可以使用内置的<strong class="kc io">求和</strong>函数对它们求和</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="3149" class="mr lg in mn b gy ms mt l mu mv">squares_sum = sum(map(lambda x: x ** 2, integers))  # gives 30</span></pre><p id="3ae0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这样做的好处是，我们不必创建一个新的列表对象来迭代哪一个更节省内存，速度更快。</p><h2 id="a036" class="mr lg in bd lh mw mx dn ll my mz dp lp kl na nb lt kp nc nd lx kt ne nf mb ng bi translated">已排序()</h2><p id="6ea7" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">回到这个例子，</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="420f" class="mr lg in mn b gy ms mt l mu mv">data = [('Alice', 20), ('Bob', 30), ('Charles', 40)]</span></pre><p id="d043" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">假设我们想按照人们的年龄降序排列元组列表。我们可以用 Python 的<strong class="kc io">排序</strong>函数做到这一点:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="74ae" class="mr lg in mn b gy ms mt l mu mv">sorted_data = sorted(data, key=lambda x: x[1], reverse=True)</span></pre><p id="42ef" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们再次看到使用了<em class="nh"> lambda </em>函数，它在这里选择每个元组中的第 2 个元素。反向标志用于按降序排序。</p><p id="b7f8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">内置函数的完整列表可以在 https://docs.python.org/3/library/functions.html<a class="ae jz" href="https://docs.python.org/3/library/functions.html" rel="noopener ugc nofollow" target="_blank">的文档中找到。现在让我们看看一些有用的库！</a></p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h1 id="7eb8" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">Python 库</h1><h2 id="f497" class="mr lg in bd lh mw mx dn ll my mz dp lp kl na nb lt kp nc nd lx kt ne nf mb ng bi translated">收集</h2><p id="b6fb" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">这个库增加了一些更有用的容器数据结构。我用得最多的是<strong class="kc io"> defaultdict </strong>。假设我们有一个包含姓名和 t 恤尺寸的元组列表:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="c9fc" class="mr lg in mn b gy ms mt l mu mv">data = [('Alice', 'S'), ('Bob', 'L'), ('Charles', 'M'), ('David', 'L'), ...]</span></pre><p id="8891" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们希望将这些名字按大小分组放入字典中。我们通常必须检查每个键是否已经存在于字典中，以避免键错误:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="dfb0" class="mr lg in mn b gy ms mt l mu mv">names_by_size = {}<br/>for name, size in data:<br/>    if size in names_by_size:<br/>        names_by_size[size].append(name)<br/>    else:<br/>        names_by_size[size] = [name]</span></pre><p id="dc2f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">使用<em class="nh"> defaultdict </em>我们可以指定值的数据结构，并忽略键检查</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="5733" class="mr lg in mn b gy ms mt l mu mv">from collections import defaultdict</span><span id="c45a" class="mr lg in mn b gy ni mt l mu mv">names_by_size = defaultdict(list)<br/>for name, size in data:<br/>    names_by_size[size].append(name)</span><span id="8c3e" class="mr lg in mn b gy ni mt l mu mv"># gives: defaultdict(&lt;class 'list'&gt;, {'S': ['Alice'], 'L': ['Bob', 'David'], 'M': ['Charles']})</span></pre><p id="34bf" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们甚至可以在<em class="nh">默认字典</em>中包含一个<em class="nh">默认字典</em>，并如下使用它</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="bbdd" class="mr lg in mn b gy ms mt l mu mv">some_dict = defaultdict(lambda: defaultdict(list))<br/>some_dict[key_1][key_2].append(value)</span></pre><p id="47f2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对于某些<em class="nh"> key_1，key_2，value </em>。</p><p id="f588" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">计数器</strong>是另一种有用的数据类型。假设我们想找出一个字母在列表中出现的次数。我们可以做</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="7fa3" class="mr lg in mn b gy ms mt l mu mv">from collections import Counter</span><span id="de3b" class="mr lg in mn b gy ni mt l mu mv">letters = ['a', 'b', 'c', 'a', 'b']<br/>letters_count = Counter(letters)  # gives  Counter({'a': 2, 'b': 2, 'c': 1})</span></pre><p id="3fcf" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">要从<em class="nh">计数器</em>中取回所有信件，我们可以这样做</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="be9d" class="mr lg in mn b gy ms mt l mu mv">letters_count.elements()</span></pre><p id="38f1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">并获得从最常见到最少的元素的排序列表</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="0e76" class="mr lg in mn b gy ms mt l mu mv">letters_count.most_common()</span></pre><p id="5a34" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">其他容器类型包括<strong class="kc io"> namedtuple </strong>、<strong class="kc io">dequee</strong>、<strong class="kc io"> OrderedDict </strong>以及一个我在撰写本文时才发现的容器<strong class="kc io"> ChainMap </strong>。<em class="nh">链式映射</em>对于存储多个字典很有用，例如，一次从字典中获取所有键或所有值。详见<a class="ae jz" href="https://www.geeksforgeeks.org/chainmap-in-python/" rel="noopener ugc nofollow" target="_blank">https://www.geeksforgeeks.org/chainmap-in-python/</a>。然而，如果我们只有两个字典<em class="nh"> a </em>和<em class="nh"> b </em>，我们可以使用</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="8049" class="mr lg in mn b gy ms mt l mu mv">combined_dict = {**a, **b}</span></pre><p id="01e4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">**的行为类似于*，但是它可以解包键和值。</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h2 id="26cf" class="mr lg in bd lh mw mx dn ll my mz dp lp kl na nb lt kp nc nd lx kt ne nf mb ng bi translated">itertools</h2><p id="a6f3" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">正如文档中所描述的，这个库具有“创建迭代器以实现高效循环的函数”。我们来举几个例子。</p><p id="7fe0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">假设我们有一个分数列表，每个分数对应于一个不同的人，我们想找出有多少种方法可以将两个人配对在一起，使他们的总分数大于 10。我们可以利用 itertools <strong class="kc io">组合</strong>函数:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="15e2" class="mr lg in mn b gy ms mt l mu mv">from itertools import combinations</span><span id="84a7" class="mr lg in mn b gy ni mt l mu mv">scores = [2, 4, 3, 6, 4, 5, 7]<br/>matches = 0<br/>for score_1, score_2 in combinations(scores, 2):<br/>    if score_1 + score_2 &gt; 10:<br/>        matches += 1</span></pre><p id="882e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">或者使用列表理解和内置的<strong class="kc io"> sum </strong>函数以更简洁、更快速的方式实现</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="7ba4" class="mr lg in mn b gy ms mt l mu mv">matches = sum([1 for score_1, score_2 in combinations(scores, 2) if score_1 + score_2 &gt; 10])</span></pre><p id="52c3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="nh">组合</em>函数查看 r 个唯一分数的所有组合(按位置而非值)，其中 r 是函数的第二个参数(在我们的示例中为 2)。例如</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="a476" class="mr lg in mn b gy ms mt l mu mv"># list(combinations('ABCD', 2)) -&gt; [('A', 'B'), ('A', 'C'), ('A', 'D'), ('B', 'C'), ('B', 'D'), ('C', 'D')]</span><span id="97b6" class="mr lg in mn b gy ni mt l mu mv"># list(combinations('ABCD', 3)) -&gt; [('A', 'B', 'C'), ('A', 'B', 'D'), ('A', 'C', 'D'), ('B', 'C', 'D')]</span></pre><p id="106f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果我们希望单个元素重复多次，我们可以使用<strong class="kc io">combinations _ with _ replacement</strong>函数，如果我们不在乎顺序，我们也可以使用<strong class="kc io"> permutations </strong>函数。</p><p id="5a47" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">另一个有用的功能是<strong class="kc io">链条</strong>。它接受 iterables 并返回一个迭代器，该迭代器依次返回每个 iterable 中的元素。例如</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="a990" class="mr lg in mn b gy ms mt l mu mv">from itertools import chain<br/># chain('ABC', 'DEF') -&gt; A B C D E F</span></pre><p id="1e7b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果我们有一个可迭代的列表，我们可以用*来解包它们，或者我们可以使用 chain.from_iterable 函数来代替</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="3608" class="mr lg in mn b gy ms mt l mu mv"># chain.from_iterable(['ABC', 'DEF']) -&gt; A B C D E F</span></pre><p id="2fb7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果我们有一个字典列表，并希望将它们合并成一个字典，这将非常有用。</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="4a1d" class="mr lg in mn b gy ms mt l mu mv">my_dicts = [{1: 2, 2: 3, 4: 5}, {6: 7, 8: 9, 4: 11}]<br/>combined = dict(chain.from_iterable(d.items() for d in my_dicts))</span></pre><p id="d697" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">与<em class="nh">链图</em>(前面提到过)不同，如果有重复的键，将使用后面的值。在最终的字典中，键 4 的值为 11。</p><p id="e55c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">看看这篇非常详细的文章<a class="ae jz" href="https://realpython.com/python-itertools/" rel="noopener ugc nofollow" target="_blank">https://realpython.com/python-itertools/</a>来了解更多关于 itertools 的信息。最重要的是这些函数返回的是迭代器而不是列表，这使得内存效率更高，速度更快。所以不要在他们身边放一个<em class="nh"> list() </em>除非你想看看他们回馈的是什么！</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h2 id="ecea" class="mr lg in bd lh mw mx dn ll my mz dp lp kl na nb lt kp nc nd lx kt ne nf mb ng bi translated">更多 _itertools</h2><p id="5324" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">该库是 itertools 库的扩展，需要与 pip(<em class="nh">pip install more-ITER tools</em>)一起安装。</p><p id="5ba7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果我们想把一个列表分割成大小相等的块，我们可以使用<strong class="kc io">分块</strong>函数</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="3091" class="mr lg in mn b gy ms mt l mu mv">from more_itertools import chunked</span><span id="1c12" class="mr lg in mn b gy ni mt l mu mv">my_list = [1, 2, 3, 4, 5, 6, 7, 8]<br/>chunks = list(chunked(my_list, 3))  # gives [[1, 2, 3], [4, 5, 6], [7, 8]]</span></pre><p id="8130" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">另一个有用的功能是<strong class="kc io">可窥视</strong>。当我们用迭代器包装一个迭代器时，它允许我们查看迭代器的下一个元素，而不用检索它。例如</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="cdab" class="mr lg in mn b gy ms mt l mu mv">from more_itertools import peekable</span><span id="45a3" class="mr lg in mn b gy ni mt l mu mv">p = peekable([1, 2])<br/>p.peek()  # gives 1 without retrieving it from the iterator<br/>next(p)  # gives 1 and retrieves it from the iterator so we are left with peekable([2])</span></pre><p id="e4d0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果我们只想在适当的时候检索元素，这是很有用的。我们可以传入一个默认值来返回，而不是在迭代器用尽时引发<strong class="kc io"> StopIteration </strong>(意味着所有元素都已被检索)。例如</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="a49c" class="mr lg in mn b gy ms mt l mu mv">p = peekable([])<br/>p.peek()  # Would raise StopIteration<br/>p.peek('iterator is empty')  # returns 'iterator is empty' </span></pre><p id="5fcc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在 https://more-itertools.readthedocs.io/en/stable/api.html<a class="ae jz" href="https://more-itertools.readthedocs.io/en/stable/api.html" rel="noopener ugc nofollow" target="_blank">你可以找到更多工具中的更多功能。</a></p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h1 id="1554" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">结论</h1><p id="4019" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">如果你做到了这一步，感谢你的阅读，并希望你学到了一些东西或刷新了你的记忆。这篇文章只是触及了 Python 的可能性的表面，但即使只是使用这里提到的函数和库，它也会大大改进您的代码。如果你找到了一个替代的/更好的方法，或者有一些你经常使用的其他函数/库，我没有包括在内，那么请留下评论，这样我们都可以从中受益！</p></div></div>    
</body>
</html>