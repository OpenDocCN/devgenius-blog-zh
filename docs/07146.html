<html>
<head>
<title>Auto-configuration with Spring Boot</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Spring Boot 自动配置</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/auto-configuration-with-spring-boot-29a45d1f6869?source=collection_archive---------10-----------------------#2022-03-01">https://blog.devgenius.io/auto-configuration-with-spring-boot-29a45d1f6869?source=collection_archive---------10-----------------------#2022-03-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/b5c1062e2d9ded899e14533c8aad3257.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hrkVMS_RyiggxZ7KmJBJRA.png"/></div></div></figure><p id="7189" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Spring Boot 不仅仅是一个应用程序生成器。它是一个可以让你进行超编程的工具；因此，避免编写不必要的代码，快速开始，最重要的是，关注应用程序的业务需求，同时保持非常灵活并尊重用户的选择。</p><p id="abee" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">今天，Spring Boot 代表了<strong class="ka ir"> Spring 栈</strong>的一个非常重要的部分，它之所以被强调是因为它是其他<strong class="ka ir"> Spring 框架</strong>的入口点。</p><p id="2390" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这篇文章中，我将介绍由“<a class="ae kw" href="https://twitter.com/snicoll" rel="noopener ugc nofollow" target="_blank">夏羽·尼科尔</a>”和“<a class="ae kw" href="https://twitter.com/bclozel" rel="noopener ugc nofollow" target="_blank">布莱恩·克洛泽尔</a>”主持的大学“掌握 Spring Boot 的超能力”的概况。</p><h1 id="3a7f" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">与 Spring Boot 的基本应用</h1><p id="3455" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">一个基本的应用如下。</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="88dc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里的<strong class="ka ir"> @SpringBootApplication </strong>相当于:</p><ul class=""><li id="b905" class="mg mh iq ka b kb kc kf kg kj mi kn mj kr mk kv ml mm mn mo bi translated">@SpringBootConfiguration</li><li id="2690" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv ml mm mn mo bi translated">@启用自动配置</li><li id="0666" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv ml mm mn mo bi translated">@ComponentScan</li></ul><h2 id="c81e" class="mu ky iq bd kz mv mw dn ld mx my dp lh kj mz na ll kn nb nc lp kr nd ne lt nf bi translated"><strong class="ak"> @ComponentScan </strong></h2><p id="9089" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">允许您扫描主包(包含配置类的包)和子包中的所有组件和派生组件。它将获取任何由<strong class="ka ir"> @Service </strong>、<strong class="ka ir"> @RestController </strong>、<strong class="ka ir"> @Configuration </strong>、<strong class="ka ir"> @Controller </strong>、<strong class="ka ir"> @Repository </strong>等标注的内容。</p><p id="c0d3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了防止某些组件被扫描，例如下面的情况，最好创建包含配置类的主目录，在下面，我们将添加应用程序的所有组件。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ng"><img src="../Images/d411c0e9bd6659f9ca6925531aa415c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F6ZZt0k4a3Z3y-iN4g4EnA.png"/></div></div></figure><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nh"><img src="../Images/c9cbdf14d0345bb5ae994351b452b0b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b72rtp7USeBJACFvkgvCJQ.png"/></div></div></figure><p id="fe15" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这种情况下，Stéphane 建议:“如果你把你的 Spring Boot 应用程序放在一个专用的包中，并在这个结构中添加你的组件，Spring Boot 将有一个一致的默认行为，它可以在其他情况下做出正确的决定。(通常在测试中)”</p><h1 id="3e14" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">启动时自动配置</h1><p id="0498" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated"><strong class="ka ir">基本配置</strong></p><p id="4828" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">自动配置是一个配置类(注释为<em class="ni"> @Configuration </em>),它不会被扫描，而是列在一个特殊的文件中(<strong class="ka ir">META-INF/spring . factories</strong>)</p><p id="d021" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过启用自动配置，Spring Boot 将尝试根据应用程序中定义的依赖关系来配置应用程序。</p><p id="0bbd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，如果在类路径中有一个对<strong class="ka ir"> HSQLDB </strong>的引用，并且没有建立连接的 Bean，Spring Boot 将能够配置一个内存中的数据库。</p><p id="74a9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此外，还可以添加您自己的自动配置。例如，我们有一个特定的库。你所要做的就是在<strong class="ka ir">META-INF/spring . factories .</strong>中添加配置文件的路径</p><pre class="ma mb mc md gt nj nk nl nm aw nn bi"><span id="66ec" class="mu ky iq nk b gy no np l nq nr">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\myspringbootapp.otmancr.autoconfigurations.MyAutoConfig</span></pre><p id="dddd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">到目前为止，我们已经看到了两种类型的配置，用户 bean 和自配置 bean。</p><ul class=""><li id="3448" class="mg mh iq ka b kb kc kf kg kj mi kn mj kr mk kv ml mm mn mo bi translated"><strong class="ka ir"> @ComponentScan : </strong>用户配置。</li><li id="369a" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv ml mm mn mo bi translated"><strong class="ka ir">@ enable Auto configuration:</strong>自动配置。</li></ul><p id="831a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">两点:</p><ul class=""><li id="1bf1" class="mg mh iq ka b kb kc kf kg kj mi kn mj kr mk kv ml mm mn mo bi translated">我们无法确定在哪种情况下我们可以贡献 Beans。</li><li id="2b09" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv ml mm mn mo bi translated">由于首先处理用户定义的任何内容，自动配置将覆盖用户配置。</li></ul><blockquote class="ns"><p id="d006" class="nt nu iq bd nv nw nx ny nz oa ob kv dk translated">在这种情况下，我们如何尊重为应用程序做出的决定？</p></blockquote><h2 id="4e92" class="mu ky iq bd kz mv oc dn ld mx od dp lh kj oe na ll kn of nc lp kr og ne lt nf bi translated">条件框架</h2><p id="31dc" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">Spring 4 带来了条件框架。这是不使用户配置过载的解决方案。</p><p id="3cec" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这由条件注释具体化:</p><ul class=""><li id="e98d" class="mg mh iq ka b kb kc kf kg kj mi kn mj kr mk kv ml mm mn mo bi translated"><strong class="ka ir">@ ConditionalOnMissingBean</strong>仅在 Bean 不存在时应用此定义，反过来是<strong class="ka ir"> @ConditionalOnBean。</strong></li><li id="3d74" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv ml mm mn mo bi translated"><strong class="ka ir">@ ConditionalOnMissingClass</strong>仅当类不在类路径中时才应用此配置，反之亦然@<strong class="ka ir">conditionalongclass</strong>。</li><li id="2d4c" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv ml mm mn mo bi translated"><strong class="ka ir">@ ConditionalOnWebApplication</strong>是 web 应用时适用，反过来是<strong class="ka ir">@ ConditionalOnNotWebApplication。</strong></li></ul><p id="6a8e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">条件求值的顺序是从最快到最慢(这不是声明的顺序)。</p><p id="c24a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">定义如下:</p><ol class=""><li id="5b44" class="mg mh iq ka b kb kc kf kg kj mi kn mj kr mk kv oh mm mn mo bi translated">@ ConditionalOnClass</li><li id="211b" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv oh mm mn mo bi translated">@ ConditionalOnMissingClass</li><li id="eded" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv oh mm mn mo bi translated">@ ConditionalOnRessource</li><li id="a67d" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv oh mm mn mo bi translated">@ConditionalOnJava</li><li id="340c" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv oh mm mn mo bi translated">@ConditionalOnWebApplication</li><li id="b760" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv oh mm mn mo bi translated">@ ConditionalOnNotWebApplication</li><li id="7ca8" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv oh mm mn mo bi translated">@ConditionalOnJndi</li><li id="c631" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv oh mm mn mo bi translated">@ConditionalOnProperty</li><li id="f7dc" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv oh mm mn mo bi translated">@ ConditionalOnExpression</li><li id="d66d" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv oh mm mn mo bi translated">@ ConditionalOnSingleCandidate</li><li id="6085" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv oh mm mn mo bi translated">@ ConditionalOnBean</li><li id="4b5f" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv oh mm mn mo bi translated">@ ConditionalOnMissingBean</li></ol><p id="f95b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这些条件可以在类和方法级别上声明，放在类上的条件首先被评估。</p><p id="00ff" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">也可以创建自己的条件，Spring Boot 提供了一个基类，<strong class="ka ir"> SpringbootCondition </strong>，它允许你提供一个报告(在这种情况下，调试模式必须是活动的)来帮助用户诊断加载的类。</p><h1 id="2056" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">结论</h1><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oi"><img src="../Images/65ce6c1a9fdeb9f6f381d1d14bc7364c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D20Hkt-IQ81J3HUcB-KeNg.png"/></div></div></figure><p id="38e3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">@ enable auto configuration</strong>将获取所有<code class="fe oj ok ol nk b">spring.factories</code>文件，<code class="fe oj ok ol nk b">spring.factories</code>将列出所有 auto-conf，每个 autoConf 包含注释。</p><p id="bbc9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果它只包含<strong class="ka ir">@配置</strong>并且所有条件都有效，则执行它。第二步是对方法上的<strong class="ka ir">@条件</strong>的验证。</p><h2 id="afbc" class="mu ky iq bd kz mv mw dn ld mx my dp lh kj mz na ll kn nb nc lp kr nd ne lt nf bi translated"><strong class="ak">要避免的陷阱</strong></h2><ol class=""><li id="ecf1" class="mg mh iq ka b kb lv kf lw kj om kn on kr oo kv oh mm mn mo bi translated">自动配置类的排序</li></ol><p id="eba7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，如果使用此订单验证 Beans，我们在创建它们时会遇到问题。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi op"><img src="../Images/795cdb408b2367e3667b6195cdbf5de2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R0Ej8yKXNbCapbrfqLXd7g.png"/></div></div></figure><p id="c667" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要解决这个问题→之前/之后自动确认</p><ul class=""><li id="bafa" class="mg mh iq ka b kb kc kf kg kj mi kn mj kr mk kv ml mm mn mo bi translated">@ auto configure after(JDBC auto configuration . class)data access configuration</li><li id="1979" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv ml mm mn mo bi translated">@ auto configure before(JDBC auto configuration . class)数据源配置</li><li id="6024" class="mg mh iq ka b kb mp kf mq kj mr kn ms kr mt kv ml mm mn mo bi translated">JDBC 自动配置</li></ul><p id="8bd5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">2.<strong class="ka ir">conditional class</strong>用在了错误的地方，运行时爆炸→将条件放在配置类上，以避免加载类。</p><p id="7ea4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于类级别的条件已经过验证，Boot 将尝试加载这个 Bean。因此出现了运行时异常，即 Gson 库丢失的情况。</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="56e6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于没有验证类级别的条件，所以在没有 Gson 库的情况下，Boot 不会更改 Bean。</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="8c84" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">3.由于用户配置和自动配置分两个阶段进行验证，因此用户配置类无法检测 Bean 是否丢失，因此无法使用这些条件。</p></div></div>    
</body>
</html>