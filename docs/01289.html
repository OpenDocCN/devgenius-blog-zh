<html>
<head>
<title>How to render different components based on screen size</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何根据屏幕大小呈现不同的组件</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-to-render-different-components-based-on-screen-size-66f602e86859?source=collection_archive---------16-----------------------#2020-06-29">https://blog.devgenius.io/how-to-render-different-components-based-on-screen-size-66f602e86859?source=collection_archive---------16-----------------------#2020-06-29</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/9aa6277cbbd8d9e240eb2f14075da2a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JqIHLd8XdFWvguzmApYQ3g.png"/></div></div></figure><div class=""/><h1 id="7c06" class="jv jw iy bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">介绍</h1><p id="ae9e" class="pw-post-body-paragraph kt ku iy kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">我最近偶然发现了一个我以前完全没有意识到非常棒的 JS Web API。</p><p id="fdea" class="pw-post-body-paragraph kt ku iy kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">那个 API 就是<a class="ae lw" href="https://developer.mozilla.org/en-US/docs/Web/API/Window/matchMedia" rel="noopener ugc nofollow" target="_blank"> Window.matchMedia() </a>。</p><p id="8ff7" class="pw-post-body-paragraph kt ku iy kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">使用它，您可以根据媒体查询检查窗口大小，并且您将得到一个布尔值:如果窗口大小与您的查询匹配，则为<code class="fe lx ly lz ma b">true</code>，否则为<code class="fe lx ly lz ma b">false</code>。</p><p id="1082" class="pw-post-body-paragraph kt ku iy kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">你可以设置一个监听器来动态检查窗口是否匹配你的查询。</p></div><div class="ab cl mb mc hr md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ig ih ii ij ik"><h1 id="d178" class="jv jw iy bd jx jy mi ka kb kc mj ke kf kg mk ki kj kk ml km kn ko mm kq kr ks bi translated">用例(不详尽)</h1><p id="eaa5" class="pw-post-body-paragraph kt ku iy kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">你可能想知道为什么我们要使用这个 API。</p><p id="f5f8" class="pw-post-body-paragraph kt ku iy kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">我们已经有 CSS 媒体查询来根据页面大小改变页面的样式。</p><p id="a226" class="pw-post-body-paragraph kt ku iy kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">但是在某些情况下，您需要根据组件的大小来呈现不同的组件，而 CSS 在这方面帮不了您。</p><p id="d032" class="pw-post-body-paragraph kt ku iy kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">有时，您希望断点两侧的视图之间的样式变化非常大，您可能会发现更简单的方法是拥有两个样式不同的不同组件，然后根据窗口大小呈现它们。</p><p id="1083" class="pw-post-body-paragraph kt ku iy kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">让我们看一个例子来理解它。</p></div><div class="ab cl mb mc hr md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ig ih ii ij ik"><h1 id="b625" class="jv jw iy bd jx jy mi ka kb kc mj ke kf kg mk ki kj kk ml km kn ko mm kq kr ks bi translated">普通 JavaScript 示例</h1><p id="64bd" class="pw-post-body-paragraph kt ku iy kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">我希望能够在一个苗条的项目中根据屏幕大小呈现不同的组件。</p><p id="e24d" class="pw-post-body-paragraph kt ku iy kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">如果你不熟悉 Svelte，那是一个 JS 框架，它在一个单独的。苗条的文件，将在被发送到浏览器之前被编译。</p><p id="96c1" class="pw-post-body-paragraph kt ku iy kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">因此，这种文件中的 CSS 和 JS 的作用域是一个 HTML 块。整体被称为一个苗条的组成部分，你可以通过周围…</p><p id="b791" class="pw-post-body-paragraph kt ku iy kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">该框架为 JS 增加了一些特性，但代码通常看起来像普通的 JS，而在 React 这样的框架中，由于代码的组织方式，它看起来不再像普通的 JS。</p><p id="e022" class="pw-post-body-paragraph kt ku iy kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">因此，我在这里给出的例子是一个用普通 JS 实现的例子，但是如果你想知道如何在 React 应用中实现该特性，请参见<a class="ae lw" href="https://github.com/ReactTraining/react-media" rel="noopener ugc nofollow" target="_blank"> react-media </a>。reddit 帖子中推荐了这个包。我读了文档，它看起来很酷。另外是由<a class="ae lw" href="https://github.com/ReactTraining/react-router" rel="noopener ugc nofollow" target="_blank"> react-router </a>的创作者制作的，一定要去看看。</p><p id="49b3" class="pw-post-body-paragraph kt ku iy kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">现在，让我们来看看这个例子:</p><p id="f469" class="pw-post-body-paragraph kt ku iy kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">首先，我将创建两个 navbar 组件来模拟我们在基于组件的框架中的情况:</p><figure class="mn mo mp mq gt ip"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="ef2f" class="pw-post-body-paragraph kt ku iy kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">这两个导航条的唯一区别是第二个导航条多了一个导航链接。</p><p id="8556" class="pw-post-body-paragraph kt ku iy kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">我们会说，我们想在桌面屏幕上呈现长导航条(<code class="fe lx ly lz ma b">Component2</code>)，但在移动设备上，由于屏幕的大小，我们决定删除一个导航链接(例如，我们可能会将该导航链接放在汉堡菜单中)。</p><p id="9c7f" class="pw-post-body-paragraph kt ku iy kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">所以对于移动视图，我们将渲染短导航条(<code class="fe lx ly lz ma b">Component1</code>)。</p><p id="8d00" class="pw-post-body-paragraph kt ku iy kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">为了呈现一个组件，我们将使用一个小助手在导航栏中注入 html:</p><figure class="mn mo mp mq gt ip"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="ee45" class="pw-post-body-paragraph kt ku iy kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">现在，假设我们的断点是 600px 的宽度:大于等于被认为是桌面视图，小于等于被认为是移动视图。</p><p id="228f" class="pw-post-body-paragraph kt ku iy kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">我们完全有能力使用<code class="fe lx ly lz ma b">Window.matchMedia()</code>:</p><figure class="mn mo mp mq gt ip"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="d49f" class="pw-post-body-paragraph kt ku iy kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">这里，我们将查询指定为<code class="fe lx ly lz ma b">window.matchMedia()</code>函数中的一个字符串，该函数返回一个类型为<code class="fe lx ly lz ma b">MediaQueryList</code>的对象。</p><p id="531c" class="pw-post-body-paragraph kt ku iy kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">在这个对象上，您可以访问 matches 属性，它是一个布尔值，告诉您当前的窗口大小是否与您的媒体查询相匹配。</p><p id="f9e1" class="pw-post-body-paragraph kt ku iy kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">很简单。</p><p id="7ae4" class="pw-post-body-paragraph kt ku iy kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">看起来是这样的:</p><figure class="mn mo mp mq gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi mt"><img src="../Images/4231091ef62c18c4281e2f046dbba37e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mezsawpwDGP7ep3Q1qMzzQ.png"/></div></div></figure><p id="28d3" class="pw-post-body-paragraph kt ku iy kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">在这个对象上，您可以访问属性<code class="fe lx ly lz ma b">matches</code>,这是一个布尔值，它告诉您当前的窗口大小是否与您的媒体查询匹配。</p><p id="9c46" class="pw-post-body-paragraph kt ku iy kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">然而，这个例子只适用于第一次渲染。</p><p id="f694" class="pw-post-body-paragraph kt ku iy kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">如果我们想动态调整布局，我们可以在返回的媒体查询列表上设置一个事件监听器，类型为<code class="fe lx ly lz ma b">change</code>:</p><figure class="mn mo mp mq gt ip"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="d965" class="pw-post-body-paragraph kt ku iy kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">所以在桌面上，它看起来像这样:</p><figure class="mn mo mp mq gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi mu"><img src="../Images/55db70f224839898b32fbe4b36104719.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YsSADPQoMueN_6lSr42YqQ.png"/></div></div></figure><p id="8591" class="pw-post-body-paragraph kt ku iy kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">在手机上:</p><figure class="mn mo mp mq gt ip gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/88598db053897de89f7b963f6bdcc333.png" data-original-src="https://miro.medium.com/v2/resize:fit:1076/format:webp/1*wEflfwtUQ_10djma_JYOPQ.png"/></div></figure><p id="1b15" class="pw-post-body-paragraph kt ku iy kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">完整代码见<a class="ae lw" href="https://codesandbox.io/s/windowmatchmedia-api-73p4x" rel="noopener ugc nofollow" target="_blank">此处</a>。</p></div><div class="ab cl mb mc hr md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ig ih ii ij ik"><h1 id="ae42" class="jv jw iy bd jx jy mi ka kb kc mj ke kf kg mk ki kj kk ml km kn ko mm kq kr ks bi translated">结论</h1><p id="0295" class="pw-post-body-paragraph kt ku iy kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">这就是这篇快速文章的全部内容。</p><p id="5b0a" class="pw-post-body-paragraph kt ku iy kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">我希望你发现了一个新的工具来添加到你的工具箱中，也许有一天你会需要它并使用它！</p><p id="e3c8" class="pw-post-body-paragraph kt ku iy kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">在此基础上，继续编码；)</p></div></div>    
</body>
</html>