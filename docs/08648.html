<html>
<head>
<title>How to implement JWT in Rust using Jwt_simple crate</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用 Jwt_simple crate 在 Rust 中实现 JWT</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-to-implement-jwt-in-rust-using-jwt-simple-crate-5dfce8f15b64?source=collection_archive---------9-----------------------#2022-06-30">https://blog.devgenius.io/how-to-implement-jwt-in-rust-using-jwt-simple-crate-5dfce8f15b64?source=collection_archive---------9-----------------------#2022-06-30</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="ac75" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当你在这里阅读这篇文章的时候，你一定已经熟悉了这样一个事实:rust 已经连续三年成为<a class="ae ki" href="https://stackoverflow.com/" rel="noopener ugc nofollow" target="_blank">栈溢出</a>中最受欢迎的编程语言。但是，你能在网上找到所有关于你的困惑的答案吗？尤其是那些愚蠢的，有时是最复杂的。我采访了一位有着超过 10 年开发经验的高级开发人员，他告诉我有时他也面临在 rust 中实现逻辑的问题。</p><p id="a860" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但这是为什么呢？我的个人观点——rust 是一种系统编程语言，就像每一种系统语言一样，rust 也有一个艰难的学习曲线，了解 Rust 的人不多，互联网上的 Rust 用户更少，答案和教程更少。但是 rust 仍然比其他语言好得多。为什么？<a class="ae ki" href="https://www.turing.com/blog/rust-is-the-most-popular-programming-language/#:~:text=Rust%20offers%20excellent%20documentation.,fast%20and%20safe%20by%20default." rel="noopener ugc nofollow" target="_blank">查看这里</a></p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi kj"><img src="../Images/fd9eb5ef11be023e56b70f4a7e14b265.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*tNX2tqc1JVlMIU7hr2K8DA.gif"/></div></figure><p id="fce1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在我们继续之前，我假设您熟悉基本的 rust 数据类型以及 rust 包管理器和 jwt 是如何工作的。</p><p id="9efa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们生锈吧！！</p><p id="1afd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">打开你最喜欢的目录，里面有你所有的 rust 代码，打开一个终端，输入“cargo new rust_jwt”。移动到新创建的文件夹，打开你最亲爱的代码编辑器(VS Code 是我的选择)，然后进入 cargo.toml 和这些依赖项。</p><pre class="kk kl km kn gt kr ks kt ku aw kv bi"><span id="c414" class="kw kx in ks b gy ky kz l la lb">//cargo.toml</span><span id="6228" class="kw kx in ks b gy lc kz l la lb">[dependencies]</span><span id="62d0" class="kw kx in ks b gy lc kz l la lb">jwt-simple = "0.10"<br/>serde = "1.0.115"</span></pre><p id="4b22" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我将带你了解它们。</p><p id="98c4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">首先，我们需要<a class="ae ki" href="https://crates.io/crates/jwt-simple" rel="noopener ugc nofollow" target="_blank"> jwt-simple </a>库来实现 jwt 令牌功能，比如验证和签名。</p><p id="1665" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">第二，我们需要 serde 来序列化和反序列化 rust 原生数据类型，以便将它们转换成 json 并解析回原生数据类型。</p><p id="ac51" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，在 src/main.rs 文件中粘贴以下代码</p><pre class="kk kl km kn gt kr ks kt ku aw kv bi"><span id="77c1" class="kw kx in ks b gy ky kz l la lb">//src/main.rs</span><span id="0c45" class="kw kx in ks b gy lc kz l la lb">use serde::{Serialize,Deserialize};<br/>use jwt_simple::prelude::*;</span><span id="d7d5" class="kw kx in ks b gy lc kz l la lb">fn main(){<br/>   <br/>  let key = HS256Key::generate();<br/>}</span></pre><p id="34fc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">HS256key 是一个 rust struct 类型，它创建一个 hs256 密钥和一个算法来创建和解析令牌。</p><p id="3e2d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是每次运行这个函数它都会生成一个新的 hs256 密钥，它使用一个内部随机函数来生成字节。</p><p id="c97e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但幸运的是，您还可以将键值存储到. txt 文件中的字节中，并从文件中检索它们。这样，你就可以确保每次函数执行时都有相同的键。</p><p id="59fe" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">以下是你可以做到的</p><p id="d6e9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">清除 main.rs 中的所有文件，粘贴这个文件，并在终端上粘贴“货物运行”,然后按 enter 键。</p><pre class="kk kl km kn gt kr ks kt ku aw kv bi"><span id="f6c8" class="kw kx in ks b gy ky kz l la lb">//src/main.rs<br/>use std::fs::File;<br/><br/>use jwt_simple::prelude::*;</span><span id="0a4f" class="kw kx in ks b gy lc kz l la lb">fn main(){</span><span id="1184" class="kw kx in ks b gy lc kz l la lb">let key = HS256Key::generate();<br/>     let byte_data = key.to_bytes();<br/>  <br/>     <!-- -->let f = File::create("key")<br/>     .expect("Unable to create  file");</span><span id="bd6a" class="kw kx in ks b gy lc kz l la lb">let mut f = BufWriter::new(f);<br/>     f.write_all(byte_data).expect("Unable to write data");<br/>}</span></pre><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi ld"><img src="../Images/b83c338dfa1cbf88819a47551275a0df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jmh04pOE20hcKAP-9OFYDg.png"/></div></div><figcaption class="li lj gj gh gi lk ll bd b be z dk translated">执行上述程序后，您必须在根文件夹中看到一个名为“key”的文件</figcaption></figure><p id="0c72" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">太好了！！现在你已经创建了你自己的 hs256 密匙，以字节数据的形式存储，它将在程序的生命周期中保持不变。</p><p id="18fd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，您可以从用于签名和验证的文件中导入一个密钥，而不是生成一个新的密钥。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi lm"><img src="../Images/84448fe5e1756a50f79e47f9a18af5bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*xxv3voNvsCHo93TChDLROQ.gif"/></div></div></figure><p id="49ec" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">到目前为止一切顺利。</p><p id="a7bc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在您已经将自己的密钥存储在一个文件中，您可以从该文件中导入它。现在在 main.rs 旁边创建一个新文件，它将使用定制的有效负载对 jwt 进行签名。</p><pre class="kk kl km kn gt kr ks kt ku aw kv bi"><span id="d675" class="kw kx in ks b gy ky kz l la lb">‘touch src/jwt_sign.rs’</span></pre><p id="32c5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在 jwt_sign.rs 文件中粘贴以下代码</p><pre class="kk kl km kn gt kr ks kt ku aw kv bi"><span id="75c1" class="kw kx in ks b gy ky kz l la lb">//jwt_sign.rs</span><span id="3ffa" class="kw kx in ks b gy lc kz l la lb">use jwt_simple::prelude::*;<br/>use std::io::BufReader;<br/>use std::fs::File;<br/>use serde::{Serialize,Deserialize};</span><span id="ff93" class="kw kx in ks b gy lc kz l la lb"><br/>//a custom payload with serialization must be made</span><span id="afc7" class="kw kx in ks b gy lc kz l la lb">#[derive(Serialize, Deserialize)]<br/>pub struct CustomClaim {<br/>email:String<br/>}</span><span id="9343" class="kw kx in ks b gy lc kz l la lb">pub fn create_jwt(email:String)-&gt;String {</span><span id="93f7" class="kw kx in ks b gy lc kz l la lb">let f = File::open("key").expect("error reading key file");</span><span id="7e9b" class="kw kx in ks b gy lc kz l la lb">let reader = BufReader::new(f);</span><span id="a71b" class="kw kx in ks b gy lc kz l la lb">let buffer = Vec::new();</span><span id="c3b8" class="kw kx in ks b gy lc kz l la lb">let key = HS256Key::from_bytes(&amp;buffer);</span><span id="bade" class="kw kx in ks b gy lc kz l la lb">let customclaim = CustomClaim{email:email};</span><span id="3ce8" class="kw kx in ks b gy lc kz l la lb">//duration of the time token will be valid for</span><span id="f38e" class="kw kx in ks b gy lc kz l la lb">let time = Duration::from_hours(1u64);</span><span id="00c7" class="kw kx in ks b gy lc kz l la lb">let claim = Claims::with_custom_claims(customclaim, time);</span><span id="a003" class="kw kx in ks b gy lc kz l la lb">let token = key.authenticate(claim).expect("fail to create token");</span><span id="d606" class="kw kx in ks b gy lc kz l la lb">token<br/>}</span></pre><p id="662f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">没有得到正确的代码？</p><p id="1ad4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当然我会带你穿过去</p><p id="c7a6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">首先，我们创建了一个包含有效负载信息的结构，它应该实现 serde serelize 特征，这样它就可以被解析成 json。然后，我们从“key”文件中读取字节，并从该字节数据中生成一个新的密钥。</p><p id="f619" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">请记住，我们只是使用电子邮件作为有效载荷。您可以通过修改 CustomClaim 结构来选择您想要的任何内容。</p><p id="a8c1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这将返回一个将“CustomClaims”作为一般数据的结构，它看起来像这样</p><pre class="kk kl km kn gt kr ks kt ku aw kv bi"><span id="af00" class="kw kx in ks b gy ky kz l la lb">pub struct JWTClaims&lt;CustomClaims&gt; {<br/>    pub issued_at: <a class="ae ki" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" rel="noopener ugc nofollow" target="_blank">Option</a>&lt;<a class="ae ki" href="https://docs.rs/jwt-simple/0.11.0/jwt_simple/prelude/type.UnixTimeStamp.html" rel="noopener ugc nofollow" target="_blank">UnixTimeStamp</a>&gt;,<br/>    pub expires_at: <a class="ae ki" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" rel="noopener ugc nofollow" target="_blank">Option</a>&lt;<a class="ae ki" href="https://docs.rs/jwt-simple/0.11.0/jwt_simple/prelude/type.UnixTimeStamp.html" rel="noopener ugc nofollow" target="_blank">UnixTimeStamp</a>&gt;,<br/>    pub invalid_before: <a class="ae ki" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" rel="noopener ugc nofollow" target="_blank">Option</a>&lt;<a class="ae ki" href="https://docs.rs/jwt-simple/0.11.0/jwt_simple/prelude/type.UnixTimeStamp.html" rel="noopener ugc nofollow" target="_blank">UnixTimeStamp</a>&gt;,<br/>    pub issuer: <a class="ae ki" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" rel="noopener ugc nofollow" target="_blank">Option</a>&lt;<a class="ae ki" href="https://doc.rust-lang.org/nightly/alloc/string/struct.String.html" rel="noopener ugc nofollow" target="_blank">String</a>&gt;,<br/>    pub subject: <a class="ae ki" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" rel="noopener ugc nofollow" target="_blank">Option</a>&lt;<a class="ae ki" href="https://doc.rust-lang.org/nightly/alloc/string/struct.String.html" rel="noopener ugc nofollow" target="_blank">String</a>&gt;,<br/>    pub audiences: <a class="ae ki" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" rel="noopener ugc nofollow" target="_blank">Option</a>&lt;<a class="ae ki" href="https://docs.rs/jwt-simple/0.11.0/jwt_simple/claims/enum.Audiences.html" rel="noopener ugc nofollow" target="_blank">Audiences</a>&gt;,<br/>    pub jwt_id: <a class="ae ki" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" rel="noopener ugc nofollow" target="_blank">Option</a>&lt;<a class="ae ki" href="https://doc.rust-lang.org/nightly/alloc/string/struct.String.html" rel="noopener ugc nofollow" target="_blank">String</a>&gt;,<br/>    pub nonce: <a class="ae ki" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" rel="noopener ugc nofollow" target="_blank">Option</a>&lt;<a class="ae ki" href="https://doc.rust-lang.org/nightly/alloc/string/struct.String.html" rel="noopener ugc nofollow" target="_blank">String</a>&gt;,<br/>    pub custom: CustomClaims,<br/>}</span></pre><p id="ad08" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您可以参考这个<a class="ae ki" href="https://docs.rs/jwt-simple/0.11.0/jwt_simple/claims/struct.JWTClaims.html" rel="noopener ugc nofollow" target="_blank">链接</a>来了解更多关于这个 struct 及其功能的信息，并根据需要向 struct 添加更多数据。</p><p id="0706" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在我们可以用“key.authenticate”来签署声明，它将返回一个字符串。</p><p id="cfd3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在在你的 main.rs 上调用 create_jwt 函数，用一些随机的电子邮件作为参数</p><pre class="kk kl km kn gt kr ks kt ku aw kv bi"><span id="10e5" class="kw kx in ks b gy ky kz l la lb">//src/main.rs</span><span id="5c0e" class="kw kx in ks b gy lc kz l la lb">mod jwt_sign;<br/>use jwt_sign::{create_jwt};</span><span id="8ea4" class="kw kx in ks b gy lc kz l la lb">use std::fs::File;<br/><br/>use jwt_simple::prelude::*;</span><span id="05c2" class="kw kx in ks b gy lc kz l la lb">fn main(){</span><span id="1c53" class="kw kx in ks b gy lc kz l la lb">     let key = HS256Key::generate();<br/>     let byte_data = key.to_bytes();<br/>  <br/>     <!-- -->let f = File::create("key")<br/>     .expect("Unable to create  file");</span><span id="9dce" class="kw kx in ks b gy lc kz l la lb">     let mut f = BufWriter::new(f);          </span><span id="0a0e" class="kw kx in ks b gy lc kz l la lb">     f.write_all(byte_data).expect("Unable to write data");<br/>     <br/>     print!("{}",create_jwt("someone@gmail.com".to_string());</span><span id="4d5f" class="kw kx in ks b gy lc kz l la lb">}</span></pre><p id="27f7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在运行 main.rs 或者你的项目二进制入口点后，你会看到一串随机字符，复制这个字符串并粘贴到<a class="ae ki" href="https://jwt.io/" rel="noopener ugc nofollow" target="_blank"> jwt.io </a></p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi ln"><img src="../Images/cedf30db990744b79a8aca395e4fa582.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oaaGO93i4Yvw9IJfXV6y5A.png"/></div></div><figcaption class="li lj gj gh gi lk ll bd b be z dk translated">这一定是输出。</figcaption></figure><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi lo"><img src="../Images/dc9a395cd76252a70a646c814d2ce525.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/1*Mwki5IOwuWSwBqT_sjVYYA.gif"/></div><figcaption class="li lj gj gh gi lk ll bd b be z dk translated">那是工作</figcaption></figure><p id="7b54" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一些提示</p><p id="efae" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae ki" href="https://crates.io/" rel="noopener ugc nofollow" target="_blank"> Crates.io </a>是一个快速增长的锈板条箱库，你几乎可以为你的工作找到许多板条箱。</p><p id="92a4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当你在你的项目中使用一些外部机箱时，仔细检查机箱的实现并阅读文档。你会了解很多关于板条箱及其内部工作，这将很容易融入你的项目。</p><p id="ae22" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">板条箱只是 Rust 项目的第三方库。</p></div></div>    
</body>
</html>