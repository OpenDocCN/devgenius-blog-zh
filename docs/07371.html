<html>
<head>
<title>How to secure your GraphQL API (Part 1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何保护您的 GraphQL API(第 1 部分)</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-to-secure-your-graphql-api-part-1-eb41f66ec07e?source=collection_archive---------6-----------------------#2022-03-19">https://blog.devgenius.io/how-to-secure-your-graphql-api-part-1-eb41f66ec07e?source=collection_archive---------6-----------------------#2022-03-19</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/926329209bb3cbb470fa426a6de54fb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PhnjSsECaofh7etxo7UQFA.jpeg"/></div></div></figure><p id="1c45" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">开发 GraphQL 后端的一个最关键的方面是创建一个<strong class="jx io">安全层</strong>,无论图形导航从哪里开始，它都会管理数据访问。</p><p id="59dd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">GraphQL 促进了连接数据模型的设计，您可以用具有多个入口点的图的形式公开该模型。每个查询允许用户从这些访问之一开始请求图的一部分，通常没有深度限制。</p><p id="5d8f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">试图在边界保护您的图，就像您在 REST 服务中可能做的那样，不是一个好策略。在每个查询和变异上添加一个安全层，您将结束在不同的解析器中复制相同的访问控制，可能会留下不安全的路径。这将是极其复杂、重复、维护不善和表现不佳的。</p><p id="14b2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一个更好的方法是根据图表来设计 ACL 策略，而不是针对它所公开的每个操作。</p></div><div class="ab cl kt ku hr kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ig ih ii ij ik"><h1 id="8d31" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">保护数据，不仅仅是运营</h1><p id="6d3f" class="pw-post-body-paragraph jv jw in jx b jy ly ka kb kc lz ke kf kg ma ki kj kk mb km kn ko mc kq kr ks ig bi translated">在数据访问层中实现安全策略对于任何后端开发来说都是一个有用的机会，这对于那些希望实现 GraphQL 后端的人来说几乎是必不可少的。</p><p id="a191" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这意味着您需要设计一个更复杂的数据访问层，它不仅关注从不同的数据源加载您需要的内容，还关注检查您的安全身份是否允许这样做。</p><p id="8bc9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果连接实体及其关系的解析由一个库来处理，就像<strong class="jx io">现代 ORMs </strong>的情况一样(像<a class="ae md" href="https://www.prisma.io/" rel="noopener ugc nofollow" target="_blank"> Prisma </a>、<a class="ae md" href="https://typeorm.io/#/" rel="noopener ugc nofollow" target="_blank"> TypeORM </a>或<a class="ae md" href="https://twinlogix.github.io/typetta/" rel="noopener ugc nofollow" target="_blank"> Typetta </a>，那么在这个过程中必须定义和应用<strong class="jx io">安全策略</strong>。</p><p id="ed7c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">定义对数据的访问权限以及数据定义本身要容易得多，然后认为对数据的每次访问都是自动安全的。回到 GraphQL 上下文，您应该定义谁可以访问图的每个部分，而不管他沿着什么路径到达那个部分。</p><p id="08c3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">要实现这一结果，您需要一个强大而灵活的安全模型及其在数据访问库上的实现。</p></div><div class="ab cl kt ku hr kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ig ih ii ij ik"><h1 id="0006" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">基本的安全模型</h1><p id="fd3c" class="pw-post-body-paragraph jv jw in jx b jy ly ka kb kc lz ke kf kg ma ki kj kk mb km kn ko mc kq kr ks ig bi translated">说到安全性，我们可以定义以下概念:</p><ul class=""><li id="e56e" class="me mf in jx b jy jz kc kd kg mg kk mh ko mi ks mj mk ml mm bi translated"><strong class="jx io">身份</strong>:这是请求访问数据的主体；它可以是系统的物理或逻辑用户、第三方应用程序、子系统、超级管理员等。</li><li id="c3cc" class="me mf in jx b jy mn kc mo kg mp kk mq ko mr ks mj mk ml mm bi translated"><strong class="jx io"> Resource </strong>:这代表了所有需要保护的东西，一个身份对这些东西的访问可以由一组规则决定。具体来说，资源是数据模型中每个实体的单独记录。</li><li id="f4c4" class="me mf in jx b jy mn kc mo kg mp kk mq ko mr ks mj mk ml mm bi translated"><strong class="jx io"> Permission </strong>:这是一个逻辑标识符，以唯一文本代码的形式表示一个或多个资源上允许的一组操作。</li><li id="e45b" class="me mf in jx b jy mn kc mo kg mp kk mq ko mr ks mj mk ml mm bi translated"><strong class="jx io">安全上下文</strong>:这是一组关于身份的信息，用于确定是否被授权执行某项操作。例如，安全上下文可以包含一组权限或一个复杂的数据结构，该数据结构定义了一组限于某些条件的权限。它通常与身份认证同时创建。</li><li id="1021" class="me mf in jx b jy mn kc mo kg mp kk mq ko mr ks mj mk ml mm bi translated"><strong class="jx io">安全域</strong>:代表一组资源分组规则，用于限制一个或多个权限的应用。安全域的一些示例可以是“引用用户 U1 的资源集”、“引用租户 T1 的资源集”等。安全域的概念有助于形成安全上下文，在安全上下文中，一个身份对不同的资源组具有不同的权限。</li><li id="682f" class="me mf in jx b jy mn kc mo kg mp kk mq ko mr ks mj mk ml mm bi translated"><strong class="jx io">安全策略</strong>:这是一组规则，根据请求访问的身份可用的权限集，确定授权或禁止访问特定资源。</li></ul><p id="58d4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下面是一个示例数据模型，显示了上面定义的所有概念:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="57af" class="nb lb in mx b gy nc nd l ne nf">type User {<br/> id: ID!<br/> firstName: String<br/> lastName: String<br/> permissions: []<br/>}</span><span id="1347" class="nb lb in mx b gy ng nd l ne nf">type UserPermission {<br/> userId: [ID!]<br/> permission: Permission!<br/>}</span><span id="9fae" class="nb lb in mx b gy ng nd l ne nf">enum Permissions {<br/> VIEW_POSTS<br/> MANAGE_POSTS<br/>}</span><span id="76c7" class="nb lb in mx b gy ng nd l ne nf">type Post {<br/> id: ID!<br/> userId: ID!<br/> content: String!<br/>}</span></pre><p id="81f3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">根据上面的模型，我们可以说每个用户是系统的一个<strong class="jx io">身份</strong>，其帖子是要保护的<strong class="jx io">资源</strong>。然后我们有两个<strong class="jx io">权限</strong>、<em class="nh"> VIEW_POSTS </em>和<em class="nh"> MANAGE_POSTS </em>，它们可以分配给用户并标识他们可以做什么。</p><p id="2d97" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在让我们假设系统中有两个用户，由以下两个用户配置定义:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="e83f" class="nb lb in mx b gy nc nd l ne nf">const mattia : User = {<br/> id: ‘1’,<br/> firstName: ‘Mattia’,<br/> lastName: ‘Minotti’,<br/> permissions: [<br/>  { permission: ‘MANAGE_POSTS’ }, <br/>  { permission: ‘VIEW_POSTS’ }<br/> ]<br/>}</span><span id="a895" class="nb lb in mx b gy ng nd l ne nf">const edoardo : User = {<br/> id: ‘2’,<br/> firstName: ‘Edoardo’,<br/> lastName: ‘Barbieri’,<br/> permissions: [<br/>  { permission: ‘MANAGE_POSTS’, userId: [‘2’]}, <br/>  { permission: ‘VIEW_POSTS’ }<br/> ]<br/>}</span></pre><p id="a419" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个配置表明用户<em class="nh"> Mattia </em>拥有阅读和管理所有系统帖子的权限，因为他的权限没有限制，而用户<em class="nh"> Edoardo </em>可以阅读所有系统帖子，但只能管理他自己制作的帖子。</p><p id="b1b3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">该示例隐式显示了应用于用户 Edoardo 的<em class="nh"> MANAGE_POSTS </em>权限的<strong class="jx io">安全域</strong>概念。事实上，它被分配给一组资源:id 为 2 的所有用户的帖子。</p><p id="99bd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，我们可以想象，对于两个用户中的每一个，相关的<strong class="jx io">安全上下文</strong>:</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="8fd9" class="nb lb in mx b gy nc nd l ne nf">const mattiaSecurityContext = {<br/> userId: ‘1’,<br/> permissions: {<br/> ‘MANAGE_POSTS’: true,<br/> ‘VIEW_POSTS’: true<br/> }<br/>}<br/>const edoardoSecurityContext = {<br/> userId: ‘2’,<br/> permissions: {<br/> ‘MANAGE_POSTS’: [{ userId: ‘2’ }],<br/> ‘VIEW_POSTS’: true<br/> }<br/>}</span></pre><p id="0a5f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">安全上下文只不过是身份信息的摘录，用于确定它是否可以访问资源。在这种情况下，每个权限都链接到一个安全域或值 true，这表示所有资源都没有域限制。</p><p id="ec25" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">安全层的最后一个组件是<strong class="jx io">安全策略</strong>。您想要保护的资源是 post 实体，因此您必须为该实体定义一个安全策略，该策略包含一组规则，这些规则决定了对它的授权或禁止访问。</p><pre class="ms mt mu mv gt mw mx my mz aw na bi"><span id="8d64" class="nb lb in mx b gy nc nd l ne nf">const postSecurityPolicy = {<br/> domain: {<br/>  userId: true<br/> },<br/> permissions: {<br/>  MANAGE_POSTS: {<br/>   create: true,<br/>   read: true,<br/>   update: true,<br/>   delete: true<br/>  },<br/>  VIEW_POSTS: {<br/>   create: false,<br/>   read: true,<br/>   update: false,<br/>   delete: false<br/>  }<br/> }<br/>}</span></pre><p id="2fec" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这样我们就定义了:所有拥有<em class="nh"> MANAGE_POSTS </em>权限的用户都可以对其安全域中的实体执行所有 CRUD 操作；所有拥有<em class="nh"> VIEW_POSTS </em>权限的用户只能读取其安全域内的实体。</p></div><div class="ab cl kt ku hr kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ig ih ii ij ik"><h1 id="56de" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">实现呢？</h1><p id="7014" class="pw-post-body-paragraph jv jw in jx b jy ly ka kb kc lz ke kf kg ma ki kj kk mb km kn ko mc kq kr ks ig bi translated">设计这种安全模型的下一步是使用现代 GraphQL 技术实现它。</p><p id="487b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">有很多 ORM 库，每一个都有它的优点和缺点，但是很少有一个结构化的安全方法。</p><p id="d8d2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在本博客的<a class="ae md" href="https://medium.com/p/70cd7e7f04f2" rel="noopener">下一部分</a>中，我们将探索一个名为<a class="ae md" href="https://twinlogix.github.io/typetta/" rel="noopener ugc nofollow" target="_blank"> Typetta </a>的非常新的 TypeScript ORM 库，它试图通过实现所描述的安全模型来解决上述问题。</p><p id="b6d2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">请继续关注我们，了解更多有趣的高级编码方法，如果你喜欢这个博客<strong class="jx io">，请为它鼓掌</strong>。</p></div></div>    
</body>
</html>