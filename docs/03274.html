<html>
<head>
<title>Laravel 8.x Database Seeders, Fakers, and Factories</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Laravel 8.x 数据库种子商、伪造者和工厂</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/laravel-8-x-database-seeders-fakers-and-factories-7cb759918124?source=collection_archive---------0-----------------------#2020-10-19">https://blog.devgenius.io/laravel-8-x-database-seeders-fakers-and-factories-7cb759918124?source=collection_archive---------0-----------------------#2020-10-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/2c4c4536fcf0ac4e3f6354fc9e41fb2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ip3TdGFfvshi4Whn3ZSYvA.jpeg"/></div></div></figure><p id="4dc4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您刚开始使用 Laravel，您首先会遇到的一些问题是:</p><ul class=""><li id="ea51" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">播种者，造假者，工厂有什么区别？</li><li id="5975" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">我应该使用它们吗？</li><li id="f790" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">我需要使用全部还是可以使用其中的一部分？</li><li id="80d0" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">我如何创建它们？</li></ul><p id="d2c4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你正在寻找这些问题的答案，我会假设你已经安装了 Laravel。如果你没有，也不知道怎么做，你可以按照我的另一篇文章中的步骤来做:</p><div class="lk ll gp gr lm ln"><a href="https://medium.com/dev-genius/setting-up-laravel-8-x-with-jetstream-auth-84bbeafc0cd3" rel="noopener follow" target="_blank"><div class="lo ab fo"><div class="lp ab lq cl cj lr"><h2 class="bd ir gy z fp ls fr fs lt fu fw ip bi translated">使用 JetStream Auth 设置 Laravel 8.x</h2><div class="lu l"><h3 class="bd b gy z fp ls fr fs lt fu fw dk translated">是时候用 Laravel 安装 JetStream 认证了。有时简单，有时不简单。</h3></div><div class="lv l"><p class="bd b dl z fp ls fr fs lt fu fw dk translated">medium.com</p></div></div><div class="lw l"><div class="lx l ly lz ma lw mb jw ln"/></div></div></a></div><h2 id="fca9" class="mc md iq bd me mf mg dn mh mi mj dp mk kj ml mm mn kn mo mp mq kr mr ms mt mu bi translated">工厂</h2><p id="1906" class="pw-post-body-paragraph jy jz iq ka b kb mv kd ke kf mw kh ki kj mx kl km kn my kp kq kr mz kt ku kv ij bi translated">根据 Laravel 的官方文档，“工厂是对 Laravel 的基本工厂类进行扩展并定义一个模型属性和定义方法的类。”就这么想吧。如果您曾经创建过一个模型，比如<em class="na">用户的</em>模型(App\Models\User)，您会知道当您使用<em class="na"> create() </em>方法时应该填充某些字段。</p><figure class="nb nc nd ne gt jr"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="dfd1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上面的例子中，我们向<em class="na">用户</em>模型提供了<em class="na">姓名</em>、<em class="na">电子邮件</em>和<em class="na">密码</em>字段，以填充<em class="na">用户</em>表。工厂会为我们定义一个标准的方法来做这件事。当您测试应用程序时，这非常有用。</p><p id="a238" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在您的测试中，您可能有数百个需要生成新用户的地方。如果你改变你的代码，你将不得不在数百个不同的地方改变它(例如，为你的用户添加<em class="na">角色</em>)。您只是创建一个测试用户，这样您就可以利用一个工厂来为您创建测试用户。</p><p id="9571" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Laravel 已经为我们创建了一个<em class="na">用户</em>工厂。它位于 database/factory/user factory . PHP 中。</p><figure class="nb nc nd ne gt jr"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="c77e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="na"> UserFactory </em>利用了 Faker，我们在这个例子中不会用到它。让我们修改<em class="na"> definition() </em>方法中的代码，使用静态名称和电子邮件。</p><figure class="nb nc nd ne gt jr"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="108d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可以看到<em class="na"> definition() </em>方法只是返回了一个数组…几乎就像我们在<em class="na">用户</em>模型中可以传递给<em class="na"> create() </em>方法的数组一样。</p><p id="e772" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要调用一个工厂，我们可以"<a class="ae nh" href="https://laravel.com/docs/8.x/database-testing#creating-models" rel="noopener ugc nofollow" target="_blank">在我们的雄辩模型上使用 Illuminate \ Database \口才\Factories\HasFactory trait 提供的静态工厂方法。</a>“在我们这里，<em class="na">User::factory()-&gt;make()</em>。<em class="na">用户</em>模型怎么知道应该用哪个工厂？它是在工厂的顶层定义的:</p><figure class="nb nc nd ne gt jr"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="24e5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了测试这一点，打开 tinker:</p><pre class="nb nc nd ne gt ni nj nk nl aw nm bi"><span id="f753" class="mc md iq nj b gy nn no l np nq">php artisan tinker</span></pre><p id="b002" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">运行 factory 命令:</p><pre class="nb nc nd ne gt ni nj nk nl aw nm bi"><span id="3d21" class="mc md iq nj b gy nn no l np nq">User::factory()-&gt;make();</span></pre><p id="04fc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您应该会得到类似如下的响应:</p><pre class="nb nc nd ne gt ni nj nk nl aw nm bi"><span id="6957" class="mc md iq nj b gy nn no l np nq">=&gt; App\Models\User {#3477<br/>     name: "Dino Cajic",<br/>     email: "<a class="ae nh" href="mailto:dinocajic@gmail.com" rel="noopener ugc nofollow" target="_blank">dinocajic@gmail.com</a>",<br/>     email_verified_at: "2020-10-19 14:58:29",<br/>   }</span></pre><p id="0c0d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就创建了<em class="na">用户</em>模型；它实际上并没有把它保存到数据库中。要保存到数据库，可以用<em class="na"> create() </em>代替<em class="na"> make() </em>。</p><pre class="nb nc nd ne gt ni nj nk nl aw nm bi"><span id="8b97" class="mc md iq nj b gy nn no l np nq">User::factory()-&gt;<strong class="nj ir">create()</strong>;</span></pre><p id="540c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以通过查看数据库中的<em class="na"> users </em>表来验证该用户是否存在。</p><p id="6ae0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">仅此而已。当您创建您的测试时，您可以使用 factory 命令在您需要的任何地方创建任何新的用户实例。</p><figure class="nb nc nd ne gt jr"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="0c4d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这种方法将创建一个新用户，每次使用相同的名称和电子邮件。如果你每次都想要一个随机的名字和一个唯一的电子邮件会怎么样？这就是 faker 的用武之地。</p><h2 id="aa6a" class="mc md iq bd me mf mg dn mh mi mj dp mk kj ml mm mn kn mo mp mq kr mr ms mt mu bi translated">赝品王中王</h2><p id="024f" class="pw-post-body-paragraph jy jz iq ka b kb mv kd ke kf mw kh ki kj mx kl km kn my kp kq kr mz kt ku kv ij bi translated">你可以开始自动使用<a class="ae nh" href="https://github.com/fzaninotto/Faker" rel="noopener ugc nofollow" target="_blank"> faker 库</a>。Faker PHP 库非常强大，使得生成随机的名字、电子邮件等变得非常容易。你可以阅读<a class="ae nh" href="https://github.com/fzaninotto/Faker" rel="noopener ugc nofollow" target="_blank"> Faker 文档</a>了解更多。</p><p id="97af" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们的例子中，我们只是想要一个随机的名字和一个唯一的电子邮件。我们可以将<em class="na">用户工厂</em>中的代码恢复到原始状态。</p><figure class="nb nc nd ne gt jr"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="e8ef" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以通过在<em class="na"> tinker </em>中运行相同的<em class="na"> factory()- &gt; make() </em>命令来测试以确保它能够工作。你可以任意多次运行这段代码，faker 每次都会产生新的用户。</p><pre class="nb nc nd ne gt ni nj nk nl aw nm bi"><span id="944e" class="mc md iq nj b gy nn no l np nq">php artisan tinker</span><span id="c63f" class="mc md iq nj b gy nr no l np nq"><strong class="nj ir">&gt;&gt;&gt; User::factory()-&gt;make();</strong><br/>=&gt; App\Models\User {#3477<br/>     name: "Mr. Milo Jast MD",<br/>     email: "<a class="ae nh" href="mailto:herzog.mose@example.org" rel="noopener ugc nofollow" target="_blank">herzog.mose@example.org</a>",<br/>     email_verified_at: "2020-10-19 15:13:31",<br/>   }<br/><strong class="nj ir">&gt;&gt;&gt; User::factory()-&gt;make();</strong><br/>=&gt; App\Models\User {#3476<br/>     name: "Carolanne Hettinger",<br/>     email: "<a class="ae nh" href="mailto:eladio62@example.org" rel="noopener ugc nofollow" target="_blank">eladio62@example.org</a>",<br/>     email_verified_at: "2020-10-19 15:13:34",<br/>   }</span></pre><p id="374c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你现在可以像以前一样，在任何你需要的时候使用你的 faker 工厂来生成随机用户。</p><figure class="nb nc nd ne gt jr"><div class="bz fp l di"><div class="nf ng l"/></div></figure></div><div class="ab cl ns nt hu nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ij ik il im in"><p id="28c7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你想产生 50 个用户呢？Laravel 也让这变得不痛不痒。我们再来看看 tinker 里的。</p><pre class="nb nc nd ne gt ni nj nk nl aw nm bi"><span id="5748" class="mc md iq nj b gy nn no l np nq">php artisan tinker</span><span id="f2c7" class="mc md iq nj b gy nr no l np nq">&gt;&gt;&gt; <strong class="nj ir">User::factory()-&gt;count(50)-&gt;make();</strong></span><span id="67a5" class="mc md iq nj b gy nr no l np nq">=&gt; Illuminate\Database\Eloquent\Collection {#3474<br/>     all: [<br/>       App\Models\User {#3479<br/>         name: "Geovanni Brakus",<br/>         email: "<a class="ae nh" href="mailto:xokuneva@example.com" rel="noopener ugc nofollow" target="_blank">xokuneva@example.com</a>",<br/>         email_verified_at: "2020-10-19 15:27:23",<br/>       },<br/>       App\Models\User {#3480<br/>         name: "Dr. Clara Nienow",<br/>         email: "<a class="ae nh" href="mailto:jerde.orval@example.net" rel="noopener ugc nofollow" target="_blank">jerde.orval@example.net</a>",<br/>         email_verified_at: "2020-10-19 15:27:23",<br/>       },<br/>       App\Models\User {#3481<br/>         name: "Prof. Stephon Ziemann IV",<br/>         email: "<a class="ae nh" href="mailto:sonia.mitchell@example.org" rel="noopener ugc nofollow" target="_blank">sonia.mitchell@example.org</a>",<br/>         email_verified_at: "2020-10-19 15:27:23",<br/>       },<br/>       App\Models\User {#3482<br/>         name: "Katrina O'Kon",<br/>         email: "<a class="ae nh" href="mailto:jessika.gaylord@example.org" rel="noopener ugc nofollow" target="_blank">jessika.gaylord@example.org</a>",<br/>         email_verified_at: "2020-10-19 15:27:23",<br/>       },<br/>       App\Models\User {#3483<br/>         name: "Marlen Rosenbaum",<br/>         email: "<a class="ae nh" href="mailto:hartmann.edwina@example.org" rel="noopener ugc nofollow" target="_blank">hartmann.edwina@example.org</a>",<br/>         email_verified_at: "2020-10-19 15:27:23",<br/>       },<br/>       ...</span></pre><p id="cfb8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">就这样，在已经链接的<em class="na"> count() </em>方法的帮助下，你有了 50 个新用户。您还可以通过使用<em class="na"> create() </em>方法来持久化数据。</p><pre class="nb nc nd ne gt ni nj nk nl aw nm bi"><span id="9f88" class="mc md iq nj b gy nn no l np nq">php artisan tinker</span><span id="8ff7" class="mc md iq nj b gy nr no l np nq">&gt;&gt;&gt; <strong class="nj ir">User::factory()-&gt;count(50)-&gt;create();</strong></span></pre><p id="fcc8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">检查数据库中的<em class="na"> users </em>表，确认您有 50 个新用户。</p><figure class="nb nc nd ne gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nz"><img src="../Images/34bd474ce9c3fc20477ef83c654bc59e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z21hG7W9TT_hP98ui4B_EA.png"/></div></div></figure><h2 id="42c4" class="mc md iq bd me mf mg dn mh mi mj dp mk kj ml mm mn kn mo mp mq kr mr ms mt mu bi translated">创建工厂和利用 Faker</h2><p id="b007" class="pw-post-body-paragraph jy jz iq ka b kb mv kd ke kf mw kh ki kj mx kl km kn my kp kq kr mz kt ku kv ij bi translated">到目前为止，我们已经研究了用户模型。让我们同时创建一个新的模型和工厂。</p><pre class="nb nc nd ne gt ni nj nk nl aw nm bi"><span id="eea7" class="mc md iq nj b gy nn no l np nq">php artisan make:model Car -mf</span><span id="1c7d" class="mc md iq nj b gy nr no l np nq"><em class="na">Model created successfully.<br/>Factory created successfully.<br/>Created Migration: 2020_10_19_154353_create_cars_table</em></span></pre><p id="6f5e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该命令将生成一个带有迁移(-m)和工厂(-f)的模型<em class="na">汽车</em>。首先，打开汽车迁移(database/migrations/create _ cars _ table…PHP)并定义汽车的<em class="na">品牌</em>和<em class="na">型号</em>。</p><figure class="nb nc nd ne gt jr"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="e5cb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">运行迁移。</p><pre class="nb nc nd ne gt ni nj nk nl aw nm bi"><span id="e1ca" class="mc md iq nj b gy nn no l np nq">php artisan migrate</span></pre><p id="43ee" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们已经用<em class="na">品牌</em>和<em class="na">型号</em>字段创建了汽车表，让我们填充这个表。我们必须使<em class="na"> make </em>和<em class="na"> model </em>字段可写，方法是转到我们的<em class="na"> Car </em>模型(App\Models\Car)并将这些字段添加到我们的<em class="na"> $fillable </em>属性中。</p><figure class="nb nc nd ne gt jr"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="7732" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">打开<em class="na"> CarFactory </em>(数据库/工厂/CarFactory.php)。</p><figure class="nb nc nd ne gt jr"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="2e74" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">定义是空的，准备好让我们填充。我们关心的只是<em class="na">制造</em>和<em class="na">型号</em>是字符串。我们可以用 faker 来帮助我们。</p><figure class="nb nc nd ne gt jr"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="3688" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们看看它是否有效。打开 tinker 并运行<em class="na">factory()-&gt;create()</em>命令来保存数据。</p><pre class="nb nc nd ne gt ni nj nk nl aw nm bi"><span id="de1b" class="mc md iq nj b gy nn no l np nq">php artisan tinker</span><span id="9a9a" class="mc md iq nj b gy nr no l np nq">&gt;&gt;&gt; <strong class="nj ir">Car::factory()-&gt;count(3)-&gt;create();</strong></span><span id="29ef" class="mc md iq nj b gy nr no l np nq">=&gt; Illuminate\Database\Eloquent\Collection {#3474<br/>     all: [<br/>       App\Models\Car {#3478<br/>         make: "delectus",<br/>         model: "commodi",<br/>         updated_at: "2020-10-19 16:02:35",<br/>         created_at: "2020-10-19 16:02:35",<br/>         id: 1,<br/>       },<br/>       App\Models\Car {#3479<br/>         make: "illo",<br/>         model: "voluptates",<br/>         updated_at: "2020-10-19 16:02:35",<br/>         created_at: "2020-10-19 16:02:35",<br/>         id: 2,<br/>       },<br/>       App\Models\Car {#3480<br/>         make: "qui",<br/>         model: "nostrum",<br/>         updated_at: "2020-10-19 16:02:35",<br/>         created_at: "2020-10-19 16:02:35",<br/>         id: 3,<br/>       },<br/>     ],<br/>   }</span></pre><p id="dab4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">检查数据库中的<em class="na">汽车</em>表，瞧，就在那里。</p><figure class="nb nc nd ne gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oa"><img src="../Images/c08304148e8f5a1556c9de437dce17ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:840/format:webp/1*gGG6TXNvZ2KzkI1RBYl5Uw.png"/></div></div></figure><h2 id="6dfe" class="mc md iq bd me mf mg dn mh mi mj dp mk kj ml mm mn kn mo mp mq kr mr ms mt mu bi translated">创建模型后创建工厂</h2><p id="6c34" class="pw-post-body-paragraph jy jz iq ka b kb mv kd ke kf mw kh ki kj mx kl km kn my kp kq kr mz kt ku kv ij bi translated">如果您在创建模型时忘记了创建工厂，您总是可以在事后创建它。</p><pre class="nb nc nd ne gt ni nj nk nl aw nm bi"><span id="bfa5" class="mc md iq nj b gy nn no l np nq">php artisan make:factory CarFactory --model=Car</span></pre><p id="82e9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="na"> - model </em>标志告诉<em class="na">汽车厂</em>这是哪个型号的。如果您忘记包含<em class="na"> -型号</em>标志，您将不得不修改<em class="na">汽车工厂</em>并手动包含该型号。</p></div><div class="ab cl ns nt hu nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ij ik il im in"><p id="a4a7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">到目前为止一切顺利。现在，您可以在一个地方创建假数据，并根据需要多次填充您的表。如果您想在开始测试/使用应用程序之前在数据库中填充一些数据，该怎么办？在开始使用应用程序之前，您可以对每个数据库表运行<em class="na">model name::factory()-&gt;count(20)-&gt;create()</em>。如果你有一打桌子呢？在每次测试之前，您必须运行十几个命令。如果你有几百张桌子呢？这就是播种者发挥作用的地方。</p><h2 id="e52d" class="mc md iq bd me mf mg dn mh mi mj dp mk kj ml mm mn kn mo mp mq kr mr ms mt mu bi translated">播种者</h2><p id="0945" class="pw-post-body-paragraph jy jz iq ka b kb mv kd ke kf mw kh ki kj mx kl km kn my kp kq kr mz kt ku kv ij bi translated">当您运行以下命令时，种子将填充您的数据库表:</p><pre class="nb nc nd ne gt ni nj nk nl aw nm bi"><span id="7ac2" class="mc md iq nj b gy nn no l np nq">// Can call multiple seeders<br/>php artisan db:seed</span></pre><p id="deec" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您也可以调用单个播种器:</p><pre class="nb nc nd ne gt ni nj nk nl aw nm bi"><span id="4d7b" class="mc md iq nj b gy nn no l np nq">php artisan db:seed --class=UserSeeder</span></pre><p id="1b83" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们创建一个播种机，看看这一切是如何联系在一起的。运行以下命令创建用户种子:</p><pre class="nb nc nd ne gt ni nj nk nl aw nm bi"><span id="84b9" class="mc md iq nj b gy nn no l np nq">php artisan make:seeder UserSeeder</span></pre><p id="86fc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Artisan 将在 database/seeders/user seeder . PHP 下生成一个名为<em class="na"> UserSeeder </em>的新类。</p><figure class="nb nc nd ne gt jr"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="e1c9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它只是一个带有空的<em class="na"> run() </em>方法的类。<em class="na"> run() </em>方法是我们添加所有代码来查看数据库的地方。让我们首先在不使用工厂的情况下填充<em class="na">用户</em>表。</p><figure class="nb nc nd ne gt jr"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="528a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如您可能猜到的那样，这将在 users 表中插入一条新记录。让我们调用播种器并验证数据是否持续:</p><pre class="nb nc nd ne gt ni nj nk nl aw nm bi"><span id="bbba" class="mc md iq nj b gy nn no l np nq">php artisan db:seed --class=UserSeeder</span></pre><p id="c39b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过检查数据库表，我可以验证新记录是否存在。</p><figure class="nb nc nd ne gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ob"><img src="../Images/b27dfe75fc08459feede3453d60eb020.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sH72CfBl_iPrypMWYNK-Sg.png"/></div></div></figure><p id="c746" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们又开始在多个地方添加代码了。如您所见，当发出<em class="na"> db:seed </em>命令时，<em class="na"> run() </em>方法只运行它内部的任何内容。那么为什么它不能直接运行我们的工厂命令呢？它可以，而且它会，只要我们想它多少次。</p><figure class="nb nc nd ne gt jr"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="cdb3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面的代码将在我们的数据库中存储 10 个新的随机条目(感谢 faker)。让我们再次运行相同的命令，并验证它们是否存在。</p><pre class="nb nc nd ne gt ni nj nk nl aw nm bi"><span id="2e6f" class="mc md iq nj b gy nn no l np nq">php artisan db:seed --class=UserSeeder</span></pre><figure class="nb nc nd ne gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oc"><img src="../Images/36a368ed7a50e279992c7bb1fd9362ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_afFMDBOhAYcaTx_MNc89w.png"/></div></div></figure><p id="782d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们为我们的<em class="na">汽车</em>模型创建另一个播种机，并利用我们之前创建的<em class="na">汽车工厂</em>。</p><pre class="nb nc nd ne gt ni nj nk nl aw nm bi"><span id="d546" class="mc md iq nj b gy nn no l np nq">php artisan make:seeder CarSeeder</span></pre><figure class="nb nc nd ne gt jr"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="f442" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以运行<em class="na"> db:seed </em>命令，用 50 个新条目填充<em class="na"> cars </em>表。</p><pre class="nb nc nd ne gt ni nj nk nl aw nm bi"><span id="8b01" class="mc md iq nj b gy nn no l np nq">php artisan db:seed --class=CarSeeder</span></pre><p id="0682" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">验证<em class="na">汽车</em>表包含 50 个新行。</p><figure class="nb nc nd ne gt jr gh gi paragraph-image"><div class="gh gi od"><img src="../Images/a8bd0214972968f78b76a0d73569372f.png" data-original-src="https://miro.medium.com/v2/resize:fit:936/format:webp/1*vlo19j_CGXOM0nYkljy2EA.png"/></div></figure></div><div class="ab cl ns nt hu nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ij ik il im in"><p id="4b86" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此时，您可能会看到用一个命令运行多个 seeders 的价值。如果你有 50 个种子，你不会想要运行 50 个不同的命令。幸运的是，Laravel 也解决了这个问题。</p></div><div class="ab cl ns nt hu nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ij ik il im in"><p id="562f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可能已经注意到了 Laravel 自动创建的另一个类，名为<em class="na">database seeder</em>(database/seeders/database seeder . PHP)。</p><figure class="nb nc nd ne gt jr"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="c5bd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以取消对代码的注释，直接从这里调用用户工厂，或者您可以使用<em class="na"> call() </em>方法调用每个种子。根据 Laravel 的文档，“使用 call 方法可以将数据库种子分解成多个文件，这样就不会有一个种子类变得过大。”</p><p id="d447" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们将我们的<em class="na"> UserSeeder </em>和<em class="na"> CarSeeder </em>传递给<em class="na"> call() </em>方法。<em class="na"> call() </em>方法接受一个数组作为参数，其中每个元素都是您想要调用的种子类。</p><figure class="nb nc nd ne gt jr"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="47f5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们现在可以使用下面的命令来调用<em class="na"> DatabaseSeeder </em>，它将依次调用我们指定的每个 Seeder:</p><pre class="nb nc nd ne gt ni nj nk nl aw nm bi"><span id="f3be" class="mc md iq nj b gy nn no l np nq"><strong class="nj ir">php artisan db:seed</strong></span><span id="ae32" class="mc md iq nj b gy nr no l np nq"><em class="na">Seeding: Database\Seeders\UserSeeder<br/>Seeded:  Database\Seeders\UserSeeder (26.58ms)<br/>Seeding: Database\Seeders\CarSeeder<br/>Seeded:  Database\Seeders\CarSeeder (14.14ms)<br/>Database seeding completed successfully.</em></span></pre><p id="fdb4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Artisan 将为我们提供消息，让我们知道一切进展顺利。您还可以验证数据库表是否已经被可视化地植入。</p><p id="060e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您的数据库表中已经有太多的数据，您总是可以在运行 seeder 之前清除它们。您可能每次都想这样做:</p><pre class="nb nc nd ne gt ni nj nk nl aw nm bi"><span id="a21c" class="mc md iq nj b gy nn no l np nq">php artisan migrate:fresh --seed</span></pre></div><div class="ab cl ns nt hu nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ij ik il im in"><p id="0869" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我希望这篇文章有助于为你揭开种子商、造假者和工厂的神秘面纱。</p></div><div class="ab cl ns nt hu nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ij ik il im in"><figure class="nb nc nd ne gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/d2b65058bd4e83f8d748fe48679b1857.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*-Qps00S-cqOvv3AW.jpeg"/></div></div></figure><p id="fdc4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">迪诺·卡希奇目前是<a class="ae nh" href="https://www.lsbio.com/" rel="noopener ugc nofollow" target="_blank"> LSBio(寿命生物科学公司)</a>、<a class="ae nh" href="https://absoluteantibody.com/" rel="noopener ugc nofollow" target="_blank">绝对抗体</a>、<a class="ae nh" href="https://www.kerafast.com/" rel="noopener ugc nofollow" target="_blank"> Kerafast </a>、<a class="ae nh" href="https://everestbiotech.com/" rel="noopener ugc nofollow" target="_blank">珠穆朗玛生物科技</a>、<a class="ae nh" href="https://www.nordicmubio.com/" rel="noopener ugc nofollow" target="_blank">北欧 MUbio </a>和<a class="ae nh" href="https://www.exalpha.com/" rel="noopener ugc nofollow" target="_blank"> Exalpha </a>的 IT 主管。他还担任我的自动系统的首席执行官。他有十多年的软件工程经验。他拥有计算机科学学士学位，辅修生物学。他的背景包括创建企业级电子商务应用程序、执行基于研究的软件开发，以及通过写作促进知识的传播。</p><p id="0215" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可以在<a class="ae nh" href="https://www.linkedin.com/in/dinocajic/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上联系他，在<a class="ae nh" href="https://instagram.com/think.dino" rel="noopener ugc nofollow" target="_blank"> Instagram </a>上关注他，或者<a class="ae nh" href="https://dinocajic.medium.com/subscribe" rel="noopener">订阅他的媒体刊物</a>。</p><p id="f5c5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">阅读 Dino Cajic(以及 Medium 上成千上万的其他作家)的每一个故事。你的会员费直接支持迪诺·卡吉克和你阅读的其他作家。你也可以在媒体上看到所有的故事。T3】</p></div></div>    
</body>
</html>