<html>
<head>
<title>Introducing the JavaScript Call Stack</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript 调用堆栈简介</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/introducing-the-javascript-call-stack-8981970438e5?source=collection_archive---------10-----------------------#2022-04-18">https://blog.devgenius.io/introducing-the-javascript-call-stack-8981970438e5?source=collection_archive---------10-----------------------#2022-04-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="279a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">JavaScript 调用堆栈的可视化指南</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/fafc373e37cb8e98178247d949f4c5a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uvSJtvcsljWBss6fQrT5GQ.jpeg"/></div></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="kr ks l"/></div></figure><h2 id="ca96" class="kt ku iq bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">什么是调用栈？</h2><p id="8540" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx lc ly lz ma lg mb mc md lk me mf mg mh ij bi translated">调用堆栈不仅是 JavaScript 的一个特性，也是许多其他编程语言的一个特性。当代码运行时，调用堆栈使 JavaScript 解释器(如何读取文件)能够跟踪它在代码中的位置以及哪个函数当前正在运行。如果有一个函数调用另一个函数，这就变得很有必要。</p><h2 id="5c38" class="kt ku iq bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">什么是堆栈？</h2><p id="43de" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx lc ly lz ma lg mb mc md lk me mf mg mh ij bi translated">在计算机科学中，栈是一种基本的数据结构。就像当你叠一些乐高积木或者你叠一些书时，最后放在堆叠上的东西会放在堆叠的最上面。它也成为第一个被移除的东西。调用堆栈以同样的方式工作。一个函数被推到调用堆栈上，稍后当一个值从一个函数返回时，它将被弹出调用堆栈。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mi"><img src="../Images/43cea142de3e79ea168fc797c2743a30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z3CKfW6QM4XiOJh9jy-0vQ.jpeg"/></div></div></figure><p id="74a5" class="pw-post-body-paragraph lp lq iq lr b ls mj jr lu lv mk ju lx lc ml lz ma lg mm mc md lk mn mf mg mh ij bi translated">如果我们有一个程序，当程序启动时有许多函数调用，那么解释器到达的第一个函数被添加到调用栈中。然后运行该函数，如果该函数调用另一个函数，则该函数被添加到调用堆栈的顶部。这个过程一直持续到其中一个函数返回某个值。发生这种情况时，该函数将从调用堆栈中移除。当前正在运行(或正在执行)的函数位于调用堆栈的顶部。让我们看一个例子。</p><h2 id="7fd8" class="kt ku iq bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">了解 JavaScript 调用栈？</h2><pre class="kg kh ki kj gt mo mp mq mr aw ms bi"><span id="d3a0" class="kt ku iq mp b gy mt mu l mv mw">const addOne = (value) =&gt; value + 1;</span><span id="084a" class="kt ku iq mp b gy mx mu l mv mw">const doubleValue = (value) =&gt; addOne(value) * 2;</span><span id="49e5" class="kt ku iq mp b gy mx mu l mv mw">const makeTotal = (a, b) =&gt; {<br/>  return doubleValue(a) + doubleValue(b);<br/>}</span><span id="c1fe" class="kt ku iq mp b gy mx mu l mv mw">makeTotal(10, 20);</span><span id="3a88" class="kt ku iq mp b gy mx mu l mv mw">//Returns ---&gt; 64</span></pre><p id="262a" class="pw-post-body-paragraph lp lq iq lr b ls mj jr lu lv mk ju lx lc ml lz ma lg mm mc md lk mn mf mg mh ij bi translated">在上面的代码示例中，我们创建了一个名为<em class="my"> addOne </em>的函数，它接受一个值，然后将该值加 1。我们创建第二个名为<em class="my"> doubleValue </em>的函数，它调用<em class="my"> addOne </em>函数并将返回值乘以 2。我们创建第三个函数，名为<em class="my"> makeTotal </em>。该函数使用参数<em class="my"> a </em>和<em class="my"> b </em>将来自<em class="my"> doubleValue </em>函数的返回值相加。然后我们继续调用<em class="my"> makeTotal </em>函数，传递参数 10 和 20。让我们使用 JavaScript 调用堆栈来一步一步了解这是如何工作的。</p><h2 id="e027" class="kt ku iq bd kv kw kx dn ky kz la dp lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">可视化调用堆栈</h2><p id="e464" class="pw-post-body-paragraph lp lq iq lr b ls lt jr lu lv lw ju lx lc ly lz ma lg mb mc md lk me mf mg mh ij bi translated">当我们调用<em class="my"> makeTotal </em>时，它被推入调用堆栈，如下图所示。10 成为参数<em class="my"> a </em>的值，20 成为参数<em class="my"> b </em>的值。<em class="my"> MakeTotal </em>通过调用带有参数<em class="my"> a </em>的函数<em class="my"> doubleValue </em>启动。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mi"><img src="../Images/d838a4cacdb2a9bb4e8279543e82797b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q26OZt_2-15izzlCoMNZiA.jpeg"/></div></div></figure><p id="4784" class="pw-post-body-paragraph lp lq iq lr b ls mj jr lu lv mk ju lx lc ml lz ma lg mm mc md lk mn mf mg mh ij bi translated">接下来，<em class="my"> makeTotal </em>用参数<em class="my"> a </em>(值 10)调用<em class="my"> doubleValue </em>函数。<em class="my"> MakeTotal </em>没有返回任何内容，因此它保留在调用堆栈中，并且<em class="my"> doubleValue </em>也被推送到调用堆栈中。如下图所示。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mi"><img src="../Images/6e23d5bc92b3214d2bcce4b3a7a4dcff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*atWLeYYLiampqTLU5GirDA.jpeg"/></div></div></figure><p id="8c04" class="pw-post-body-paragraph lp lq iq lr b ls mj jr lu lv mk ju lx lc ml lz ma lg mm mc md lk mn mf mg mh ij bi translated">函数<em class="my"> doubleValue </em>调用<em class="my"> addOne </em>函数，传递来自<em class="my"> makeTotal </em>函数(10)的 a 参数值参数。<em class="my"> doubleValue </em>函数还没有返回任何东西，所以它仍然保留在调用堆栈中。addOne<em class="my">函数也被添加到调用堆栈中。如下图所示。</em></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mi"><img src="../Images/a0090bf449adf4eb684b582b1e153d77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u6-Qi-Y_SXKru0a5CW8iwQ.jpeg"/></div></div></figure><p id="8873" class="pw-post-body-paragraph lp lq iq lr b ls mj jr lu lv mk ju lx lc ml lz ma lg mm mc md lk mn mf mg mh ij bi translated">函数<em class="my"> addOne </em>返回<em class="my">值</em>参数(10)加 1 的总和。由于该函数返回值，所以现在从调用堆栈中弹出，调用堆栈的当前状态如下图所示。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mi"><img src="../Images/6e23d5bc92b3214d2bcce4b3a7a4dcff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*atWLeYYLiampqTLU5GirDA.jpeg"/></div></div></figure><p id="0dc2" class="pw-post-body-paragraph lp lq iq lr b ls mj jr lu lv mk ju lx lc ml lz ma lg mm mc md lk mn mf mg mh ij bi translated">然后，函数<em class="my"> doubleValue </em>从<em class="my"> addOne </em>函数(11)获取返回值，并将其乘以 2。然后这个值被返回，因此<em class="my"> doubleValue </em>函数从调用堆栈中弹出，如下图所示。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mi"><img src="../Images/d838a4cacdb2a9bb4e8279543e82797b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q26OZt_2-15izzlCoMNZiA.jpeg"/></div></div></figure><p id="290a" class="pw-post-body-paragraph lp lq iq lr b ls mj jr lu lv mk ju lx lc ml lz ma lg mm mc md lk mn mf mg mh ij bi translated">函数<em class="my"> makeTotal </em>现在继续使用<em class="my"> b </em>参数(20)调用<em class="my"> doubleValue </em>，因此<em class="my"> doubleValue </em>再次被添加到调用堆栈中。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mi"><img src="../Images/86f0afbcc435fecca4074fe9606bda9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jGPXxxREZkLkOLEsX2JiQQ.jpeg"/></div></div></figure><p id="4a52" class="pw-post-body-paragraph lp lq iq lr b ls mj jr lu lv mk ju lx lc ml lz ma lg mm mc md lk mn mf mg mh ij bi translated"><em class="my"> doubleValue </em>函数继续调用<em class="my"> addOne </em>函数，因此它也被添加到调用堆栈中。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mi"><img src="../Images/839dbfd22fde619f838a24bd173058c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P5cSeXP8HtEkz8xICAta3w.jpeg"/></div></div></figure><p id="26bb" class="pw-post-body-paragraph lp lq iq lr b ls mj jr lu lv mk ju lx lc ml lz ma lg mm mc md lk mn mf mg mh ij bi translated"><em class="my"> addOne </em>函数返回<em class="my">值</em>参数和 1 相加的总和。当这个函数完成并返回一个值<em class="my">时，一个</em>从调用堆栈中弹出。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mi"><img src="../Images/86f0afbcc435fecca4074fe9606bda9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jGPXxxREZkLkOLEsX2JiQQ.jpeg"/></div></div></figure><p id="b792" class="pw-post-body-paragraph lp lq iq lr b ls mj jr lu lv mk ju lx lc ml lz ma lg mm mc md lk mn mf mg mh ij bi translated"><em class="my"> doubleValue </em>函数将<em class="my"> addOne </em>函数的输出相乘，然后返回一个值。这将从调用堆栈中弹出。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mi"><img src="../Images/d838a4cacdb2a9bb4e8279543e82797b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q26OZt_2-15izzlCoMNZiA.jpeg"/></div></div></figure><p id="04d3" class="pw-post-body-paragraph lp lq iq lr b ls mj jr lu lv mk ju lx lc ml lz ma lg mm mc md lk mn mf mg mh ij bi translated"><em class="my"> makeTotal </em>函数然后返回总数，留给我们一个空的调用堆栈。</p><p id="3b0c" class="pw-post-body-paragraph lp lq iq lr b ls mj jr lu lv mk ju lx lc ml lz ma lg mm mc md lk mn mf mg mh ij bi translated">我希望你喜欢这篇文章，请随时发表任何意见，问题或反馈，并关注我的更多内容！</p></div></div>    
</body>
</html>