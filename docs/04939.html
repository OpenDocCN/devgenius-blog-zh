<html>
<head>
<title>Java Spring Boot — REST APIs Integration Without Hassle</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java Spring Boot——轻松集成REST APIs</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/java-spring-boot-rest-apis-integration-without-hassle-f1130a92253d?source=collection_archive---------0-----------------------#2021-05-25">https://blog.devgenius.io/java-spring-boot-rest-apis-integration-without-hassle-f1130a92253d?source=collection_archive---------0-----------------------#2021-05-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ee7f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">让我们探索创建REST API客户端的不同方法</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/60f4f2f0f6b6579f3eccee4e1660b8a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zWPM9W-4iMbnfTCf"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">夏洛特·哈里逊在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="d8bd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在微服务架构时代，系统基本上是由多个独立的服务组成的。每个服务都是一个独立的单元，负责一个业务领域或逻辑。业务用例通过协调服务之间的输入和输出来执行。</p><p id="d08e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，您可以看到下图中的示例保险系统由许多服务组成。每个业务功能都由一个名为orchestrator的专用服务来处理，该服务集成并协调底层服务。当涉及到API集成的开发时，问题就出现了。因为为API消费构建代码需要花费精力，这意味着您将花费时间为所有服务构建客户端代码。更糟糕的是，如果这3个业务职能由不同的团队来处理，工作量可能会增加两倍。随着更多业务功能和服务的实现，总工作量可能会呈指数级增长。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ls"><img src="../Images/5d3b898b9ce5a5deadacfb411548ed03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1026/format:webp/1*YHv8Cx4wvR_FDdOkeWkncg.jpeg"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">基于服务的保险系统示例(我自己创建的图表)</figcaption></figure><p id="a2ce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除了编写构建API客户端的代码之外，还有其他选项可以加快开发速度并节省您的精力。因此，如果您掌握了为API集成创建客户端代码的方法，您就可以轻松有效地完成开发工作。在本文中，我将通过示例代码分享这些方法，这样您将找到适合您的开发的正确方法。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="8773" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">有哪些可用的方法？</h1><p id="846e" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">由于REST API的流行，大多数现代API都符合某些模式，比如HTTP方法和状态代码的使用。使用JSON作为通用数据格式，Gson和Jackson等流行的库可用于数据序列化/反序列化。</p><p id="5e70" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是一个API客户端的典型代码片段。第一个是通过客户id获取客户记录</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="c5a9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一个例子是通过产品id获取产品记录</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="61e5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这两个示例看起来很相似，唯一的区别只是URL路径和数据类型。您观察的API客户端代码越多，您就越能发现适用于其他方法类型(如PUT、POST和DELETE)的常见模式。</p><p id="0bd9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为什么不生成代码而每次都要写呢？也许，你可能有同样的想法。好消息是，在代码开发期间以源代码的形式或者在运行时以动态供应的形式生成API客户端是可行的。我将探索以下方法:</p><ul class=""><li id="d056" class="mz na iq ky b kz la lc ld lf nb lj nc ln nd lr ne nf ng nh bi translated">生成API客户端源代码</li><li id="6a20" class="mz na iq ky b kz ni lc nj lf nk lj nl ln nm lr ne nf ng nh bi translated">在运行时提供API客户端</li><li id="4cf6" class="mz na iq ky b kz ni lc nj lf nk lj nl ln nm lr ne nf ng nh bi translated">构建您自己的API客户端</li></ul><p id="c45d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当然，没有一种解决方案可以放之四海而皆准。选择适合您需求的方法取决于您。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="550a" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">生成API客户端源代码— OpenAPI生成器</h1><p id="092f" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">为了与其他系统集成，在实际编码之前，首先要做的就是达成系统接口协议。对于消费者和提供者来说，对系统如何交互和数据结构有一个共同的理解是必不可少的一步。</p><p id="1f19" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用<a class="ae kv" href="https://swagger.io/specification/" rel="noopener ugc nofollow" target="_blank"> OpenAPI定义</a>(原名Swagger)作为REST API的规范，多年来已经成为业界惯例。提供者使用OpenAPI定义来记录他们的API，open API定义为每个API操作指定了URL路径、HTTP方法、输入&amp;输出数据格式。</p><p id="b81a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于OpenAPI定义是YAML或JSON的格式，规范可由程序代码读取，社区中的人们创建了一个令人敬畏的命令行工具— <a class="ae kv" href="https://github.com/OpenAPITools/openapi-generator-cli" rel="noopener ugc nofollow" target="_blank"> OpenAPI生成器CLI </a>，旨在基于API规范生成基于API客户端的源代码。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nn"><img src="../Images/48a3f63256458051a206ffe746d21546.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cAfwRH436mlX92qp0yUAUQ.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">从OpenAPI定义生成API客户端源代码(自己画的图)</figcaption></figure><p id="0b25" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，下面的YAML API定义是2个API端点的规范:</p><ul class=""><li id="8b48" class="mz na iq ky b kz la lc ld lf nb lj nc ln nd lr ne nf ng nh bi translated">[GET] /customers/{customerId} —按记录Id提取客户记录</li><li id="46d3" class="mz na iq ky b kz ni lc nj lf nk lj nl ln nm lr ne nf ng nh bi translated">[POST]/客户—插入新的客户记录</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="44d8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要生成API客户端，您需要首先安装生成器CLI</p><pre class="kg kh ki kj gt no np nq nr aw ns bi"><span id="c837" class="nt mb iq np b gy nu nv l nw nx">npm install @openapitools/openapi-generator-cli</span></pre><p id="bc03" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后运行客户端代码生成命令行</p><pre class="kg kh ki kj gt no np nq nr aw ns bi"><span id="e341" class="nt mb iq np b gy nu nv l nw nx">openapi-generator-cli -i <strong class="np ir">&lt;OpenAPI definition file&gt;</strong> -g <strong class="np ir">&lt;generator&gt;</strong> -o <strong class="np ir">&lt;location of the generated source code&gt;</strong></span></pre><p id="7d49" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要用java生成源代码，可以为生成器参数指定“Java”。如果您更喜欢用其他语言生成的API客户机，您可以在generator参数中指定它。该工具支持多种编程语言，如javascript、go、ruby等。该命令行显示了受支持的生成器的完整列表。</p><pre class="kg kh ki kj gt no np nq nr aw ns bi"><span id="4fe0" class="nt mb iq np b gy nu nv l nw nx">openapi-generator-cli list</span></pre><p id="db5d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">生成的Java代码是一个独立的maven项目，它不仅包含源代码，还包含markdown格式的综合文档，并带有显示API客户端用法的示例。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ny"><img src="../Images/578b8c6c27297899f4eb0976b6a3554a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wkhYwneCt76zY7rfKMh_4Q.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">OpenAPI生成器CLI —生成的Maven项目</figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nz"><img src="../Images/0a8eef6297455b4ac6ada83cc9e101cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q3t30os2ISiq4Srw81zdxg.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">OpenAPI生成器CLI —生成的API文档</figcaption></figure><p id="bf30" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">代码生成器显然对API提供者有利，因为该工具可以通过提供不同编程语言的API客户端库来帮助他们推广API，而无需在编码方面付出努力。</p><p id="526a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从消费者的角度来看，代码生成器的使用节省了API客户端的开发工作。然而，生成的客户机只不过是HTTP协议处理的逻辑。它不提供配置的灵活性，如超时处理，否则，您将花费精力研究和修改源代码。此外，维护生成的代码会有点麻烦。</p><p id="cfdf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您正在寻找具有更多功能和与Spring Boot更好集成的API客户端，那么使用具有运行时供应的声明式API客户端将是一个更好的选择。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="a576" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">运行时API客户端供应— OpenFeign</h1><p id="eb53" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">另一个选择是在程序运行时提供API客户端，它利用开源项目<a class="ae kv" href="https://github.com/OpenFeign/feign" rel="noopener ugc nofollow" target="_blank"> OpenFeign </a>。这是一个强大的框架，最初是由网飞创建的。</p><p id="df3c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">API客户端被定义为带有注释的Java接口，然后OpenFeign framework将自动识别接口，并在应用程序启动期间根据注释中指定的配置提供实现。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/ad944ae4c5beeb2090ad0849a666b918.png" data-original-src="https://miro.medium.com/v2/resize:fit:1216/format:webp/1*OxQQklIx6knsupedN7Hq2g.jpeg"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">OpenFeign API客户端供应(图表由我自己创建)</figcaption></figure><p id="0c95" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Spring Boot提供了一个与OpenFeign的奇妙集成，使其对开发人员友好，具有自动配置能力和符合Spring编程模型的注释。</p><p id="6b81" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我向您展示如何使用OpenFeign进行Spring Boot应用程序开发。首先，您需要在Maven pom.xml中包含依赖关系</p><pre class="kg kh ki kj gt no np nq nr aw ns bi"><span id="5b7f" class="nt mb iq np b gy nu nv l nw nx">&lt;dependency&gt;<br/>  &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;<br/>  &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;<br/>&lt;/dependency&gt;</span></pre><p id="de7f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，通过添加annotation @EnableFeignClients来配置Spring Boot以启用OpenFeign的特性。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="4892" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好了，现在你可以马上定义一个API客户端了。定义API客户端的工作简单易行。参考下面的示例API客户端，API客户端有两个接口方法，分别使用GET和POST API进行客户记录检索和更新。</p><p id="6eb8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第一行的<strong class="ky ir"> <em class="ob"> @FeignClient </em> </strong>注释是声明它是一个OpenFeign API客户端。URL属性将您的客户端指向API端点。请注意，在启用了服务发现的环境(如Enreka)中，可以省略URL属性，因为OpenFeign API客户端能够通过名称自动查找API端点。</p><pre class="kg kh ki kj gt no np nq nr aw ns bi"><span id="c666" class="nt mb iq np b gy nu nv l nw nx"><a class="ae kv" href="http://twitter.com/FeignClient" rel="noopener ugc nofollow" target="_blank">@FeignClient</a>(name = "customer-srv", url = "<a class="ae kv" href="http://localhost:8103" rel="noopener ugc nofollow" target="_blank">http://localhost:8103</a>")<br/>public interface CustomerSrvClient {</span><span id="2103" class="nt mb iq np b gy oc nv l nw nx">  ....</span><span id="2264" class="nt mb iq np b gy oc nv l nw nx">}</span></pre><p id="604c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您习惯于使用Spring framework构建后端控制器，您可能会发现这些注释与后端API的注释非常相似。这就是Spring框架的魅力所在，Spring开发团队设计集成的方式是将相同的注释应用到OpenFeign客户端。因此，开发人员可以快速掌握用法并构建API客户端，而无需花费时间学习新的注释。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="969b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Spring在运行时使用<strong class="ky ir"> <em class="ob"> @Autowired </em> </strong>自动将OpenFeign API client的实现类注入到应用程序代码中，就好像一个原始组件一样。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><h2 id="fce9" class="nt mb iq bd mc od oe dn mg of og dp mk lf oh oi mm lj oj ok mo ln ol om mq on bi translated"><strong class="ak">高度可配置</strong></h2><p id="99e1" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">OpenFeign是高度可配置的，它的行为可以作为Spring Boot应用程序的一部分进行定制</p><ul class=""><li id="cb79" class="mz na iq ky b kz la lc ld lf nb lj nc ln nd lr ne nf ng nh bi translated">连接超时</li><li id="924e" class="mz na iq ky b kz ni lc nj lf nk lj nl ln nm lr ne nf ng nh bi translated">请求/响应时的数据压缩</li><li id="acbf" class="mz na iq ky b kz ni lc nj lf nk lj nl ln nm lr ne nf ng nh bi translated">底层HTTP客户端的选择— Apache HTTP客户端、Apache HTTP客户端5、OK HTTP客户端</li></ul><p id="e13d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您有兴趣了解更多信息，请参考<a class="ae kv" href="https://docs.spring.io/spring-cloud-openfeign/docs/current/reference/html/appendix.html" rel="noopener ugc nofollow" target="_blank">配置属性</a>列表。</p><h2 id="eaab" class="nt mb iq bd mc od oe dn mg of og dp mk lf oh oi mm lj oj ok mo ln ol om mq on bi translated"><strong class="ak">无功支援</strong></h2><p id="7b97" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">尽管Spring open在编写时假装是一个阻塞的客户端，但是Spring团队建议开源项目<a class="ae kv" href="https://github.com/Playtika/feign-reactive" rel="noopener ugc nofollow" target="_blank">假装反应</a>作为一种在Spring特性可用之前启用非阻塞API客户端的方式。</p><p id="3222" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">只需不到一分钟的时间，您就可以将现有的OpenFeign客户端转换为非阻塞客户端。首先，加入反应性佯maven依赖。</p><pre class="kg kh ki kj gt no np nq nr aw ns bi"><span id="8972" class="nt mb iq np b gy nu nv l nw nx">&lt;dependency&gt;<br/>  &lt;groupId&gt;com.playtika.reactivefeign&lt;/groupId&gt;<br/>  &lt;artifactId&gt;feign-reactor-spring-cloud-starter&lt;/artifactId&gt;<br/>  &lt;version&gt;3.0.0&lt;/version&gt;<br/>  &lt;type&gt;pom&lt;/type&gt;<br/>&lt;/dependency&gt;</span></pre><p id="6e06" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，将头标注从<strong class="ky ir"> <em class="ob"> @FeignClient </em> </strong>切换到<strong class="ky ir"><em class="ob">@ reactivefeign client</em></strong>。对于反应式实现，所有方法的返回数据类型都将包装在Flux / Mono中，而<strong class="ky ir"><em class="ob">@ request mapping</em></strong>注释保持不变。一切都结束了！</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="dfb8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用OpenFeign的API客户端实现是一种非常好的方法，与使用API客户端生成器相比，它提供了更多的灵活性和额外的特性。然而，它可能无法满足所有要求。例如，它不支持API响应和重试的缓存。因此，您最后的办法是构建自己的API客户端。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="c007" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">构建您自己的API客户端</h1><p id="0d23" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">如果API客户端生成器和OpenFeign不符合你的需求，那么编码API客户端是你唯一的选择。幸运的是，有现成的web客户端库可供您使用。我将演示流行的web客户端库——Spring Web Client和OK HTTP Client的使用。</p><h2 id="d7b8" class="nt mb iq bd mc od oe dn mg of og dp mk lf oh oi mm lj oj ok mo ln ol om mq on bi translated">Spring WebClient</h2><p id="8b0a" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">很长一段时间以来，<strong class="ky ir"> <em class="ob"> RestTemplate </em> </strong>一直是Spring框架中的标准web客户端，但是，请注意，对于新的开发不再推荐使用<strong class="ky ir"> <em class="ob"> RestTemplate </em> </strong>，因为Spring团队已经将他们的重点转移到一个名为<strong class="ky ir"> <em class="ob"> WebClient </em> </strong>的HTTP客户端的非阻塞版本。</p><p id="ecd4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="ob"> WebClient </em> </strong>的设计很直观，你很快就能学会它的用法。下面的示例代码展示了如何提交GET和POST请求。<strong class="ky ir"> <em class="ob"> WebClient </em> </strong>是一个使用Reactor Core API实现的非阻塞HTTP客户端，这意味着所有的返回数据都包装在Mono或Flux数据类型内。</p><p id="be36" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您的应用程序不支持异步进程，那么block()方法是一种将非阻塞进程转换为阻塞进程的方法，因为该方法会一直等到获得数据。</p><p id="2164" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于<strong class="ky ir"> <em class="ob"> WebClient </em> </strong>基于Reactor Core构建，支持重试等多种特性。下面的客户记录检索示例代码演示了重试的机制。使用reryWhen()语句，<strong class="ky ir"> <em class="ob"> WebClient </em> </strong>最多重试3次，时间间隔分别为3秒、6秒和9秒。可以访问<a class="ae kv" href="https://projectreactor.io/" rel="noopener ugc nofollow" target="_blank">网站</a>了解更多。</p><p id="7cba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> HTTP GET —获取客户记录</strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="ba8b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> HTTP POST —保存客户记录</strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><h2 id="3907" class="nt mb iq bd mc od oe dn mg of og dp mk lf oh oi mm lj oj ok mo ln ol om mq on bi translated">OK HTTP客户端</h2><p id="c96c" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">越来越多的人在谈到web客户端开发时，会谈到OK Http Client的使用。根据<a class="ae kv" href="https://www.mocklab.io/blog/which-java-http-client-should-i-use-in-2020/" rel="noopener ugc nofollow" target="_blank">对Java Http客户端库</a>的比较，似乎Http客户端提供了所有Java Http客户端中最多的特性。因此，它值得我们关注，这里是客户记录检索和提交的示例代码，供您快速参考</p><p id="638d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> HTTP GET —获取客户记录</strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="25bc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> HTTP POST —保存客户记录</strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="9406" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">最后的想法</h1><p id="a45c" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">REST API消费是现代系统中最常见的集成模式。除了为每个服务编写API客户端代码之外，代码生成和运行时供应是自动化API客户端创建的重要选项，可以节省您大量的开发工作。</p><p id="4aaa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于Spring Boot应用程序开发来说，使用OpenFeign是一个非常值得推荐的选择，因为它与框架的集成对开发人员来说非常友好。API客户端的创建非常简单，注释与Spring web控制器非常相似。尽管如此，OpenFeign client支持自动服务发现，使其成为云微服务部署的理想API客户端。</p></div></div>    
</body>
</html>