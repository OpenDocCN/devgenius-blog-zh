<html>
<head>
<title>Kotlin Reified types</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">科特林具体化类型</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/kotlin-reified-types-ff353f83d479?source=collection_archive---------3-----------------------#2021-07-15">https://blog.devgenius.io/kotlin-reified-types-ff353f83d479?source=collection_archive---------3-----------------------#2021-07-15</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="70aa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我的一些科特林具体化的泛型思想。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/16e54824ed7c6e4fe5335845cfe6f054.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L_-623bQ2ggby5OogDuqjQ.png"/></div></div></figure><p id="83b4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">具体化</strong>是一个过程，通过这个过程，一个关于应用程序的抽象概念被转化为一个显式的数据模型或其他用编程语言创建的对象。</p><p id="3a54" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们观察一个方法的想法，它接受 JSON 并将其转换成 object。我们需要传递该类，以便在运行时生成该类的字节码。</p><pre class="kj kk kl km gt ku kv kw kx aw ky bi"><span id="8604" class="kz la in kv b gy lb lc l ld le"><strong class="kv io">fun </strong>&lt;T&gt; createFromClass(jsonString: String): T {<br/>    // Error. Cannot use 'T' as reified type parameter<br/>    <strong class="kv io">return </strong>Gson().fromJson(jsonString, T::<strong class="kv io">class</strong>.<em class="lf">java</em>)<br/>}</span></pre><p id="8b05" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在泛型函数<code class="fe lg lh li kv b">createFromClass</code>内部，你不能访问类型 T，因为它只在编译时可用。Java 限制了哪些类型是<strong class="jm io">可具体化的</strong> <em class="lf"> — </em>，如果它们在运行时可用的话。在编译过程中，Java 会删除类型参数，但只有 Kotlin 中具体化的类型参数仍可用于类型比较并获取类对象。因此传递类&lt; T &gt;的开销将在函数中避免。</p><p id="3cc2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Inline 关键字允许避免创建函数的实例。编译器在调用该函数的任何地方复制该函数的实际主体。内联函数仅仅是我们想象中的函数。</p><pre class="kj kk kl km gt ku kv kw kx aw ky bi"><span id="c320" class="kz la in kv b gy lb lc l ld le">inline fun inlined(block: () -&gt; Unit) {<br/>    println("before")<br/>    block()<br/>    println("after")<br/>}<br/>fun main(args: Array&lt;String&gt;) {<br/>    inlined {<br/>       println("implement logic here")<br/>    }<br/>}</span></pre><p id="24c1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在 Java 字节码中是这样的:</p><pre class="kj kk kl km gt ku kv kw kx aw ky bi"><span id="ce4a" class="kz la in kv b gy lb lc l ld le">public class MyClass {<br/>    public static void main(String args[]) {<br/>        System.out.println("before");<br/>        System.out.println("implement logic here");<br/>        System.out.println("after");<br/>    }<br/>}</span></pre><p id="6ee3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">将<strong class="jm io">具体化</strong>用于实例 Of。这在 Java 中是不可能像这样检查类型的:</p><pre class="kj kk kl km gt ku kv kw kx aw ky bi"><span id="16d6" class="kz la in kv b gy lb lc l ld le">fun main(args: Array&lt;String&gt;) {<br/>    checkType&lt;String&gt;("test idea")<br/>}<br/>inline fun &lt;reified T&gt; checkType(param: Any) {<br/>    if (param is T) println("It is the type we are looking for.")<br/>    if (param.javaClass == T::class.java) println("Class matched.")<br/>}</span></pre><p id="82ea" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">具体化类型只能与内联函数结合使用。让我们看看具体化逻辑的最简单和最广泛的实现，借助 GSON 库将 JSON 反序列化为 object:</p><pre class="kj kk kl km gt ku kv kw kx aw ky bi"><span id="28aa" class="kz la in kv b gy lb lc l ld le">import com.google.gson.*<br/>fun main(args: Array&lt;String&gt;) {    <br/>    val jsonResponse = "{'name':'Alex', 'phone':'+372 xxxx'}"<br/>    val profile = jsonResponse.convertToObject&lt;MyProfile&gt;()<br/>    println("$profile.name")<br/>}<br/>data class MyProfile(val name: String, val phone: String)</span><span id="b5b5" class="kz la in kv b gy lj lc l ld le">inline fun &lt;reified T:Any&gt; String.convertToObject(): T{<br/>    val gson = Gson()<br/>    return gson.fromJson(this,T::class.java)<br/>}</span></pre><p id="00b3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">或者在杰克逊图书馆的帮助下，它非常简单易懂:</p><pre class="kj kk kl km gt ku kv kw kx aw ky bi"><span id="e0da" class="kz la in kv b gy lb lc l ld le">import com.fasterxml.jackson.module.kotlin<br/>fun main(args: Array&lt;String&gt;) {<br/>    val json = "{'fish': 'herring'}"<br/>    val result = json.toMyObject&lt;MyType&gt;()<br/>    println(result)<br/>}<br/>data class MyType(val fish: String)</span><span id="4355" class="kz la in kv b gy lj lc l ld le">inline fun &lt;reified T: Any&gt; String.toMyObject(): T {<br/>    val mapper = jacksonObjectMapper()<br/>    return mapper.readValue(this, T::class.java)<br/>}</span></pre><p id="8c54" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">具体化是一个有用的修饰语。例如，在 stdlib 的 filterIsInstance 中使用它来过滤特定类型的元素。</p><p id="487d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用具体化按类型筛选的示例。假设我们有类似的水果课。</p><pre class="kj kk kl km gt ku kv kw kx aw ky bi"><span id="d1f6" class="kz la in kv b gy lb lc l ld le">fun main(args: Array&lt;String&gt;) {<br/>    val fruits = listOf(Plum("tiger"), Cherry("leo"), Plum("wolf"))</span><span id="9b2e" class="kz la in kv b gy lj lc l ld le">    val result: List&lt;Plum&gt; = fruits.filterFruit&lt;Plum&gt;()<br/>    println("$result")<br/>    val resultType = fruits.filterIsInstance&lt;Cherry&gt;()<br/>    println("check instance: $resultType")<br/>    <br/>    val isPlum = result.isInstanceOf&lt;List&lt;Plum&gt;&gt;()<br/>    println("Is it a plum? $isPlum")<br/>}<br/>data class Plum(val name: String)<br/>data class Cherry(val name: String)</span><span id="247d" class="kz la in kv b gy lj lc l ld le">inline fun &lt;reified T&gt; List&lt;Any&gt;.filterFruit(): List&lt;T&gt; {<br/>    return this.filter { it is T }.map { it as T }<br/>}<br/>inline fun &lt;reified T&gt; Any.isInstanceOf(): Boolean = this is T</span></pre><p id="c262" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们实现密封类，使设计更清晰，检查类型。</p><p id="719b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当子类型可以分配给超类型时，协方差提供关键字<strong class="jm io"> out </strong>。它激励我们使用这种类型并保持类型安全</p><p id="34f4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">带有成功和失败状态输出的设计:</p><pre class="kj kk kl km gt ku kv kw kx aw ky bi"><span id="5f78" class="kz la in kv b gy lb lc l ld le">import java.util.*<br/>fun main(args: Array&lt;String&gt;) {<br/>    var arr = arrayOf(0, 1, 2, 3, 4, 5)  //,"string value"<br/>    var result = arr.average()    <br/>    when(result) {<br/>        is Success -&gt; println("status: succeeded")<br/>        is Failure -&gt; println("status: " + result.cause?.message)<br/>    }.exhaustive<br/>}<br/>inline fun &lt;reified T&gt; Array&lt;T&gt;.average() : Result&lt;Float&gt; {<br/>    if (T::class.java == Integer::class.java){<br/>        var sum = 0<br/>        for (item in this){<br/>            if (item is Int) sum += item<br/>        }<br/>        val result = (sum / this.size).toFloat()<br/>        println("result: $result")<br/>        return Success(result)<br/>    } else {<br/>        return Failure(IllegalArgumentException("$this does not conform to the number."))<br/>    }<br/>}<br/>sealed class Result&lt;out T: Any&gt;<br/>class Success&lt;out T: Any&gt;(val result: T) : Result&lt;T&gt;()<br/>class Failure(val cause: Exception? = null) : Result&lt;Nothing&gt;()<br/>val &lt;T&gt; T.exhaustive: T<br/>    get() = this</span></pre><p id="130e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">结论</strong> <br/>泛型在运行时并不那么有用，因为由于 JVM 字节码的限制，它们通常会在编译期间被删除(好在只有具体化的类型不会被删除)。具体化结合<strong class="jm io">内联</strong>函数在运行时生成类的字节码。我们可以用它来得到结果的类型状态。</p><p id="19dd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">有用链接</strong></p><div class="lk ll gp gr lm ln"><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/filter-is-instance.html" rel="noopener  ugc nofollow" target="_blank"><div class="lo ab fo"><div class="lp ab lq cl cj lr"><h2 class="bd io gy z fp ls fr fs lt fu fw im bi translated">filterIsInstance - Kotlin 编程语言</h2><div class="lu l"><h3 class="bd b gy z fp ls fr fs lt fu fw dk translated">返回一个列表，其中包含指定类型参数 r 的所有实例元素。</h3></div><div class="lv l"><p class="bd b dl z fp ls fr fs lt fu fw dk translated">kotlinlang.org</p></div></div><div class="lw l"><div class="lx l ly lz ma lw mb ks ln"/></div></div></a></div></div></div>    
</body>
</html>