<html>
<head>
<title>BigQuery Cost Monitoring and Insights for Cost-effective Pipelines</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">BigQuery 成本监控和对经济高效的管道的洞察</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/bigquery-cost-monitoring-and-insights-for-cost-effective-pipelines-ca14f8715082?source=collection_archive---------6-----------------------#2022-10-24">https://blog.devgenius.io/bigquery-cost-monitoring-and-insights-for-cost-effective-pipelines-ca14f8715082?source=collection_archive---------6-----------------------#2022-10-24</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/d8daa2172d591b33e286573322f76efc.png" data-original-src="https://miro.medium.com/v2/resize:fit:860/format:webp/1*HbgVL0uaWxN1cB3Xpe8gog.png"/></div></div></figure><p id="4122" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">BigQuery 是一个完全托管的无服务器数据仓库解决方案，它是灵活的、分布式的，有数百个连接器，允许以最小的努力将数据传输到 BigQuery。尽管有不同的提供商，如 Snowflake、Amazon Redshift 和 SAP Business Warehouse，但选择 BigQuery 是一个架构决策，成千上万的企业更喜欢将 BigQuery 作为其数据管道的数据仓库。除了 BigQuery 的优势，BigQuery 数据传输服务还提供了各种各样的来源来集成到 BigQuery，如谷歌产品(YouTube、谷歌分析、云资源)、一些 AWS 产品(Redshift、S3)和数百个第三方传输工具。尽管这些集成服务是免费的，但是将数据流式传输到 BigQuery 会产生运行持续查询的成本。除了这些自动查询之外，数据分析师、BI 开发人员、数据科学家以及外部资源也在使用 BigQuery 并运行手动查询。受<a class="ae kt" href="https://www.acceldata.io/blog/data-engineering-netflix-data-infrastructure" rel="noopener ugc nofollow" target="_blank">网飞保持基础设施成本效益的方法</a>的启发，我们可以在 BigQuery 上做同样的事情。</p></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><h1 id="4af8" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak">故事情节</strong></h1><p id="bfd4" class="pw-post-body-paragraph jv jw in jx b jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks ig bi translated">作为一名数据工程师，您负责监控 Google 云基础设施的成本，并且您观察到 BigQuery 的成本呈指数级增长。如果您的数据也呈指数级增长，那么这可能不是最大的问题，但我们不喜欢成本呈指数级增长，对吗？</p><p id="18ce" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">观察之后，你开始寻找降低成本的方法，并且你有了一些有用的想法。但是，我们如何确保我们的解决方案能够解决我们的问题呢？我们的成本高是因为手动查询还是自动化查询？有没有一个非优化视图，每次新数据来了，调用视图时，都要用千兆字节的处理量？每个表和视图对成本的贡献是多少？也许有些用户正在运行类似“SELECT * FROM x.t LIMIT 10”这样的查询正如我们所知，使用 LIMIT 并不能减少 BigQuery 中处理的总字节数。在采取任何行动之前，我们必须弄清楚每个查询运行的细节，并处理数据以选择最佳行动来优化我们的成本。谢天谢地，BigQuery 已经提供了一个 Python API，通过使用 BigQueryJobs 类，我们可以解决这个问题！我们将使用<a class="ae kt" href="https://github.com/egehanyorulmaz/BigQuery-Cost-Monitoring-and-Insights-with-Apache-airflow" rel="noopener ugc nofollow" target="_blank">我创建的 GitHub 库</a>。</p><p id="0412" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">通过利用 BigQuery 模块的<a class="ae kt" href="https://googleapis.dev/python/bigquery/latest/index.html" rel="noopener ugc nofollow" target="_blank"> Python 客户端，我们可以创建一个允许我们与 BigQuery 交互的客户端。使用这个客户机，您可以创建 ETL 管道，将数据提取或接收到 BigQuery。您在 BigQuery UI 中所做的一切，当然也可以在 Python 客户端中完成。</a></p><p id="002a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> 1- BigQuery 类</strong> <br/>用 JSON 文件的 google 凭证路径创建一个 BigQuery 客户端。</p><p id="5020" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">要使用这个存储库，我们必须做的就是在 SqlQueryManager.py 的 class 属性中替换我们的凭证，以便我们到 BigQuery 的连接得到正确的身份验证和授权。</p><figure class="me mf mg mh gt jo"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="1a80" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> 2- BigQueryJobs 类</strong> <br/>从 BigQuery 类继承而来，它使用客户端列出历史作业记录，并迭代作业以获得更多详细信息。</p><figure class="me mf mg mh gt jo"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="d571" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">使用<strong class="jx io"> get_all_job_details </strong>函数，我们可以提取以下信息:</p><ol class=""><li id="bcd0" class="mk ml in jx b jy jz kc kd kg mm kk mn ko mo ks mp mq mr ms bi translated">作业类型(查询或加载)</li><li id="51e2" class="mk ml in jx b jy mt kc mu kg mv kk mw ko mx ks mp mq mr ms bi translated">创建时间</li><li id="2a46" class="mk ml in jx b jy mt kc mu kg mv kk mw ko mx ks mp mq mr ms bi translated">用户电子邮件</li><li id="ea33" class="mk ml in jx b jy mt kc mu kg mv kk mw ko mx ks mp mq mr ms bi translated">询问</li><li id="0500" class="mk ml in jx b jy mt kc mu kg mv kk mw ko mx ks mp mq mr ms bi translated">查询运行时间</li><li id="504c" class="mk ml in jx b jy mt kc mu kg mv kk mw ko mx ks mp mq mr ms bi translated">查询运行的计费字节数</li></ol><p id="cecb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果我们看到一个具有以下格式的查询，那么我们可以理解它是 Google Data Studio 请求的自动查询。</p><figure class="me mf mg mh gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi my"><img src="../Images/990274ce8691f4c78782fdbb2289cf32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5X9RXv0oQBo51wjap_W9jw.png"/></div></div><figcaption class="mz na gj gh gi nb nc bd b be z dk translated">Google Data Studio 查询格式</figcaption></figure><p id="6c88" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">作为最佳实践，任何自动化操作都必须获得<a class="ae kt" href="https://cloud.google.com/iam/docs/service-accounts" rel="noopener ugc nofollow" target="_blank">服务帐户</a>的授权。因此，在一个设计良好的 Google 云架构中，您可能能够通过使用用户电子邮件列来区分查询。如果您看到一封以@system.gserviceaccount.com 结尾的电子邮件，那么您可以找到并过滤每个服务帐户运行的查询。</p><p id="8100" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">到目前为止的总结:</strong>我们可以使用 BigQuery 的 Python 客户端获得 BigQuery 中运行的所有查询的详细信息。通过使用用户电子邮件列、连续创建时间之间的时间、查询结构或者相同的查询之前是否运行，可以很容易地理解是谁执行了这些查询。</p></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><h2 id="6755" class="nd lc in bd ld ne nf dn lh ng nh dp ll kg ni nj lp kk nk nl lt ko nm nn lx no bi translated">计算每个表或视图的成本</h2><p id="135f" class="pw-post-body-paragraph jv jw in jx b jy lz ka kb kc ma ke kf kg mb ki kj kk mc km kn ko md kq kr ks ig bi translated">现在，我们有了原始数据，我们可以进一步分析它。然而，我们还没有将计费字节用于查询运行。要想出由表引起的成本，我们必须了解 SQL 查询中使用了哪些表。幸运的是，<a class="ae kt" href="https://pypi.org/project/sql-metadata/" rel="noopener ugc nofollow" target="_blank"> sql-metadata </a>模块为我们做了这项工作！使用 sql 元数据库，我们可以提取 SQL 查询中提到和使用的列或表。一个例子:</p><p id="d79e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> SQL 查询:</strong><code class="fe np nq nr ns b">SELECT * FROM table1 t1\ LEFT JOIN table2 t2\ ON t1.x=t2.x</code><br/><strong class="jx io">SQL _ 元数据解析器输出:</strong> <code class="fe np nq nr ns b">["table1", "table2"]</code></p><p id="88ad" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在<strong class="jx io"> parse_query </strong>函数中，我们提取查询中的表，这个函数由<strong class="jx io"> get_all_job_details </strong>迭代调用。此时，假设我们有一个使用 3 个表和 2 个视图的长查询。我们还有这个长查询的总计费字节数。使用统一的方法(假设每个表贡献相同数量的计费字节)，并用<a class="ae kt" href="https://cloud.google.com/skus/?currency=USD&amp;filter=bigquery+analysis" rel="noopener ugc nofollow" target="_blank">基于区域的分析成本</a>将字节转换成美元，我们可以得到每个表的粗略成本。更好的方法是使用 BigQuery 的模拟选项，并获得每个子查询的总计费字节数。然后，将总字节数除以子查询中的表数</p><p id="9de1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对于分析的最后一部分，我们所要做的就是自动化这一过程，并可视化随时间推移和每张表的成本。在存储库中，我已经开发了生产就绪的气流 DAG。在末尾添加一个摄取节点或电子邮件节点后，就可以开始收集数据了。对于分析部分，通过简单的按表分组和按成本排序，我们可以看到哪些表和/或视图是成本的主要来源。有了这种认识，我们可以开始优化和优先考虑我们的成本降低策略，并在 BigQuery 中拥有一个经济高效的数据基础设施。</p></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><blockquote class="nt nu nv"><p id="e808" class="jv jw nw jx b jy jz ka kb kc kd ke kf nx kh ki kj ny kl km kn nz kp kq kr ks ig bi translated">永远不要低估鼓掌激励作者的力量。:)</p></blockquote><h2 id="2d7d" class="nd lc in bd ld ne nf dn lh ng nh dp ll kg ni nj lp kk nk nl lt ko nm nn lx no bi translated"><strong class="ak">参考文献</strong></h2><ul class=""><li id="8701" class="mk ml in jx b jy lz kc ma kg oa kk ob ko oc ks od mq mr ms bi translated">网飞文章:<a class="ae kt" href="https://www.acceldata.io/blog/data-engineering-netflix-data-infrastructure" rel="noopener ugc nofollow" target="_blank">https://www . Accel data . io/blog/data-engineering-网飞-数据-基础设施</a></li><li id="bc89" class="mk ml in jx b jy mt kc mu kg mv kk mw ko mx ks od mq mr ms bi translated">图片:<a class="ae kt" href="https://flowygo.com/en/blog/bigquery-performance-optimization/" rel="noopener ugc nofollow" target="_blank">https://flowygo . com/en/blog/big query-performance-optimization/</a></li></ul><p id="4329" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae kt" href="https://googleapis.dev/python/bigquery/latest/index.html" rel="noopener ugc nofollow" target="_blank">https://googleapis.dev/python/bigquery/latest/index.html</a></p><p id="0767" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae kt" href="https://cloud.google.com/iam/docs/service-accounts" rel="noopener ugc nofollow" target="_blank">https://cloud.google.com/iam/docs/service-accounts</a></p><p id="62fb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae kt" href="https://cloud.google.com/skus/?currency=USD&amp;filter=bigquery%20analysis" rel="noopener ugc nofollow" target="_blank">https://cloud.google.com/skus/?currency=USD&amp;filter = big query % 20 analysis</a></p></div></div>    
</body>
</html>