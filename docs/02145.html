<html>
<head>
<title>React Tips — Wrappers, Render Props, and setState Errors</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应提示—包装器、渲染道具和设置状态错误</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/react-tips-wrappers-render-props-and-setstate-errors-b0fa061fb308?source=collection_archive---------22-----------------------#2020-07-20">https://blog.devgenius.io/react-tips-wrappers-render-props-and-setstate-errors-b0fa061fb308?source=collection_archive---------22-----------------------#2020-07-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/0d089a9eba0cdc1f80e6810fb68e9b2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RbKavVmNcpGK8atV"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">由<a class="ae kc" href="https://unsplash.com/@mysa21?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Mysaell Armendariz </a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="6938" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">React是一个用于创建web应用程序和移动应用程序的流行库。</p><p id="f2a2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将了解一些编写更好的React应用程序的技巧。</p><h1 id="f93a" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">修复“警告:setState(…):在现有状态转换期间无法更新”错误</h1><p id="4e59" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">为了修复这个错误，我们不应该在<code class="fe me mf mg mh b">render</code>方法中调用方法。</p><p id="c845" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，在构造函数中，我们将状态改变方法:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="1a8f" class="mq lc iq mh b gy mr ms l mt mu">this.handleButtonTrue = this.handleButtonChange.bind(this, true);<br/>this.handleButtonFalse = this.handleButtonChange.bind(this, false);</span></pre><p id="4eb6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后用我们的<code class="fe me mf mg mh b">render</code>方法。我们写道:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="d907" class="mq lc iq mh b gy mr ms l mt mu">&lt;Button onClick={this.handleButtonTrue}&gt;true&lt;/Button&gt;<br/>&lt;Button onClick={this.handleButtonFalse}&gt;false/Button&gt;</span></pre><h1 id="0ebf" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">何时使用React setState回调</h1><p id="29a4" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">当我们需要运行一些总是在状态改变后运行的代码时，我们应该使用React <code class="fe me mf mg mh b">setState</code>的回调。</p><p id="0e94" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="c9c1" class="mq lc iq mh b gy mr ms l mt mu">changeTitle(event) {<br/>  this.setState({ title: event.target.value }, () =&gt; {<br/>    this.validateTitle();<br/>  });</span><span id="48b9" class="mq lc iq mh b gy mv ms l mt mu">},<br/>validateTitle() {<br/>  if (this.state.title.length === 0) {<br/>    this.setState({ error: 'no blank title' });<br/>  }<br/>},</span></pre><p id="890a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们调用<code class="fe me mf mg mh b">setState</code>来改变<code class="fe me mf mg mh b">title</code>状态。</p><p id="246d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们运行<code class="fe me mf mg mh b">validateTitle</code>来验证<code class="fe me mf mg mh b">title</code>状态的最新值。</p><h1 id="d951" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">对日期对象进行适当验证</h1><p id="7429" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用<code class="fe me mf mg mh b">instanceof</code>方法验证日期对象是否作为道具传入。</p><p id="4cc2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="6faa" class="mq lc iq mh b gy mr ms l mt mu">PropTypes.instanceOf(Date)</span></pre><p id="cfe5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">来做验证。</p><h1 id="c6ac" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">在React组件外部访问Redux存储的最佳方式</h1><p id="5edc" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过导出从<code class="fe me mf mg mh b">createStore</code>返回的值来访问React组件外部的Redux存储。</p><p id="b0e9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以在任何我们喜欢的地方使用这个值。</p><p id="e15b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，在<code class="fe me mf mg mh b">store.js</code>中，我们写道:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="c999" class="mq lc iq mh b gy mr ms l mt mu">const store = createStore(myReducer);<br/>export store;</span></pre><p id="34b9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后在<code class="fe me mf mg mh b">app.js</code>中，我们写道:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="aae7" class="mq lc iq mh b gy mr ms l mt mu">import { store } from './store'<br/>store.dispatch(<br/>  //...<br/>)</span></pre><p id="86b4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们想使用多个商店，我们可以编写一个函数，如果商店不存在，就创建一个商店，并返回一个带有商店的承诺。</p><p id="bd32" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以利用这一点来得到商店。</p><h1 id="57a3" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">将一个组件包装到另一个组件中</h1><p id="883b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">为了让我们将一个组件包装在另一个组件中，我们创建了一个带有<code class="fe me mf mg mh b">children</code>属性的包装器组件</p><p id="7078" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="bdad" class="mq lc iq mh b gy mr ms l mt mu">const Wrapper = ({children}) =&gt; (<br/>  &lt;div&gt;<br/>    &lt;div&gt;header&lt;/div&gt;<br/>    &lt;div&gt;{children}&lt;/div&gt;<br/>    &lt;div&gt;footer&lt;/div&gt;<br/>  &lt;/div&gt;<br/>);</span><span id="a726" class="mq lc iq mh b gy mv ms l mt mu">const App = ({name}) =&gt; &lt;div&gt;Hello {name}&lt;/div&gt;;</span><span id="56aa" class="mq lc iq mh b gy mv ms l mt mu">const App = ({name}) =&gt; (<br/>  &lt;Wrapper&gt;<br/>    &lt;App name={name}/&gt;<br/>  &lt;/Wrapper&gt;<br/>);</span></pre><p id="ba8e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们创建一个接受<code class="fe me mf mg mh b">children</code>属性的<code class="fe me mf mg mh b">Wrapper</code>组件。</p><p id="594d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们创建一个<code class="fe me mf mg mh b">App</code>组件，并将其放入<code class="fe me mf mg mh b">Wrapper</code>组件中。</p><p id="6ae3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还可以使用渲染道具将组件传递给另一个组件。</p><p id="5798" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这意味着我们将整个<code class="fe me mf mg mh b">render</code>函数传递给另一个组件。</p><p id="809d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="0f16" class="mq lc iq mh b gy mr ms l mt mu">class Wrapper extends React.Component {<br/>  state = {<br/>    count: 0<br/>  };</span><span id="3fe9" class="mq lc iq mh b gy mv ms l mt mu">  increment = () =&gt; {<br/>    const { count } = this.state;<br/>    return this.setState({ count: count + 1 });<br/>  };</span><span id="d7fb" class="mq lc iq mh b gy mv ms l mt mu">  render() {<br/>    const { count } = this.state;</span><span id="541e" class="mq lc iq mh b gy mv ms l mt mu">  return (<br/>      &lt;div&gt;<br/>        {this.props.render({<br/>          increment: this.increment,<br/>          count: count<br/>        })}<br/>      &lt;/div&gt;<br/>    );<br/>  }<br/>}</span><span id="a3b1" class="mq lc iq mh b gy mv ms l mt mu">class App extends React.Component {<br/>  render() {<br/>    return (<br/>      &lt;Wrapper<br/>        render={({ increment, count }) =&gt; (<br/>          &lt;div&gt;<br/>            &lt;div&gt;<br/>              &lt;p&gt;{count}&lt;/p&gt;<br/>              &lt;button onClick={() =&gt; increment()}&gt;Increment&lt;/button&gt;<br/>            &lt;/div&gt;<br/>          &lt;/div&gt;<br/>        )}<br/>      /&gt;<br/>    );<br/>  }<br/>}</span></pre><p id="0211" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们创建了一个<code class="fe me mf mg mh b">Wrapper</code>，它采用一个<code class="fe me mf mg mh b">render</code>道具，该道具采用一个呈现组件的函数。</p><p id="ec9a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们为<code class="fe me mf mg mh b">App</code>中的<code class="fe me mf mg mh b">render</code>属性传入了一个值。</p><p id="6b25" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后在<code class="fe me mf mg mh b">Wrapper</code>内调用，对象为<code class="fe me mf mg mh b">increment</code>和<code class="fe me mf mg mh b">count</code>属性。</p><p id="aa21" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从<code class="fe me mf mg mh b">App</code>和<code class="fe me mf mg mh b">count</code>状态传入<code class="fe me mf mg mh b">increment</code>方法。</p><h1 id="7db5" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">在React中验证嵌套对象的属性类型</h1><p id="8432" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用<code class="fe me mf mg mh b">shape</code>方法验证嵌套对象bu的属性类型。</p><p id="aeca" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="841d" class="mq lc iq mh b gy mr ms l mt mu">import PropTypes from 'prop-types';</span><span id="586b" class="mq lc iq mh b gy mv ms l mt mu">propTypes: {<br/>  data: PropTypes.shape({<br/>    firstName: PropTypes.string.isRequired,<br/>    lastName: PropTypes.string<br/>  })<br/>}</span></pre><p id="0252" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用描述<code class="fe me mf mg mh b">data</code>道具结构的对象调用<code class="fe me mf mg mh b">PropTypes.shape</code>方法。</p><p id="1132" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有2个字符串，<code class="fe me mf mg mh b">isRequired</code>表示它是必需的。</p><h1 id="1731" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">如何在React中添加评论？</h1><p id="e6d8" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过将注释放在花括号中来添加注释。</p><p id="f1e7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="8cf5" class="mq lc iq mh b gy mr ms l mt mu">&lt;div&gt;<br/>  {/* button click */}<br/>  &lt;Button whenClicked={this.handleClick}&gt;click me &lt;/Button&gt;<br/>  &lt;List /&gt;<br/>&lt;/div&gt;</span></pre><p id="80db" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Out注释在花括号内。</p><p id="bb2a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们和普通的JavaScript注释一样。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/a9dbe8dc2f9bdf3671e22fc44e18b2e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Wfcaxyyk4noR_76R"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://unsplash.com/@joyceromero?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">乔伊斯·罗梅罗</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="5e50" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="ae6a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果我们把注释放在花括号中，我们可以添加注释。</p><p id="ce20" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们不应该在我们的<code class="fe me mf mg mh b">render</code>方法中调用<code class="fe me mf mg mh b">setState</code>。</p><p id="b058" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Redux存储可以在React组件外部访问。</p><p id="bf26" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过创建一个接受<code class="fe me mf mg mh b">children</code>属性的包装组件来嵌套子组件。</p><p id="f7e3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者我们可以在我们的组件中接受一个<code class="fe me mf mg mh b">render</code> prop来呈现组件。</p></div></div>    
</body>
</html>