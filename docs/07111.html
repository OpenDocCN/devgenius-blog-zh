<html>
<head>
<title>Out with Retrofit and in with KTor Client</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带改造的出去，带 KTor 客户端的进来</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/out-with-retrofit-and-in-with-ktor-client-e8b52f205139?source=collection_archive---------0-----------------------#2022-02-27">https://blog.devgenius.io/out-with-retrofit-and-in-with-ktor-client-e8b52f205139?source=collection_archive---------0-----------------------#2022-02-27</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/05eb29fa951eae7c9861b5ebfb8cba0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D32tLyI3KPJp6-0GGxdCTA.png"/></div></div></figure><p id="f540" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这篇文章中，让我们看看如何将所有网络呼叫从 Retrofit 迁移到 Kotlin KTor 客户端，以及它相对于前者提供的所有优势。</p><h2 id="8dd3" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">什么是 KTor 客户端，它与 Android 的改造有何不同？</h2><p id="6b3d" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">Ktor 客户机是一个 HTTP 客户机，可用于发出请求和处理响应。它的工作原理与翻新非常相似，但让它脱颖而出的是，它没有连接到任何 android 特定的东西，完全由 Kotlin 驱动。这意味着，在未来，如果你计划将你的 android 应用程序扩展为多平台应用程序，那么你就不需要绞尽脑汁去打网络电话了，Ktor 会处理它。</p><h2 id="ef3d" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">不错，它允许多平台功能，它还能做什么？</h2><ul class=""><li id="4299" class="lr ls in jx b jy lm kc ln kg lt kk lu ko lv ks lw lx ly lz bi translated">它完全是用科特林语写的..所以从配置客户端到处理响应的一切都很简洁</li><li id="4233" class="lr ls in jx b jy ma kc mb kg mc kk md ko me ks lw lx ly lz bi translated">它是即插即用的，意味着每个特性(身份验证、序列化等)都在它们自己的库中提供。因此，您不必导入一个包含您不需要的内容的大型库。</li><li id="b08f" class="lr ls in jx b jy ma kc mb kg mc kk md ko me ks lw lx ly lz bi translated">有一些很棒的异常处理程序。</li></ul><h2 id="6994" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated">我们开始吧</h2><blockquote class="mf mg mh"><p id="e391" class="jv jw mi jx b jy jz ka kb kc kd ke kf mj kh ki kj mk kl km kn ml kp kq kr ks ig bi translated">注意——这篇文章主要关注使用 KTor 客户端发出请求和处理响应，对于在 Android 中处理网络调用的健壮方法，请参考我的另一篇文章<a class="ae mm" href="https://medium.com/@hyzamzz/modern-network-calls-in-android-with-retrofit-coroutines-and-sealed-classes-8c9453a6b331" rel="noopener">这里</a>。</p><p id="cefb" class="jv jw mi jx b jy jz ka kb kc kd ke kf mj kh ki kj mk kl km kn ml kp kq kr ks ig bi translated">您还需要在<a class="ae mm" href="https://www.yelp.com/developers" rel="noopener ugc nofollow" target="_blank"> Yelp Developers </a>中创建一个开发者帐户，以获取将用于发送请求的 API 密钥</p></blockquote><ol class=""><li id="fbc8" class="lr ls in jx b jy jz kc kd kg mn kk mo ko mp ks mq lx ly lz bi translated"><strong class="jx io">添加眷属</strong></li></ol><p id="a460" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在 build.gradle(应用程序模块级别)文件中，添加以下更改</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="abcd" class="kt ku in mw b gy na nb l nc nd">plugins <strong class="mw io">{<br/>    ....</strong></span><span id="de4b" class="kt ku in mw b gy ne nb l nc nd">    id 'org.jetbrains.kotlin.plugin.serialization' version '1.5.31'<br/><strong class="mw io">}</strong></span><span id="3e05" class="kt ku in mw b gy ne nb l nc nd">....<br/>.........</span><span id="ef45" class="kt ku in mw b gy ne nb l nc nd">dependencies <strong class="mw io">{<br/><br/>    ....</strong><br/><br/>    implementation "io.ktor:ktor-client-core:1.6.7"<br/>    implementation "io.ktor:ktor-client-android:1.6.7"<br/>    implementation "io.ktor:ktor-client-serialization:1.6.7"<br/><strong class="mw io">}</strong></span></pre><ul class=""><li id="55c7" class="lr ls in jx b jy jz kc kd kg mn kk mo ko mp ks lw lx ly lz bi translated">客户端核心是我们的 Ktor 客户端的核心库。</li><li id="21b5" class="lr ls in jx b jy ma kc mb kg mc kk md ko me ks lw lx ly lz bi translated"><em class="mi"> client-android </em>是 android 特有的引擎库。如果您的项目在多平台中提供对 iOS 的支持，那么您也可以添加特定于 iOS 的引擎。</li><li id="3720" class="lr ls in jx b jy ma kc mb kg mc kk md ko me ks lw lx ly lz bi translated"><em class="mi">客户端序列化</em>带来了将我们的响应序列化为类对象的能力，反之亦然</li></ul><p id="f21a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> 2。配置客户端</strong></p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="a33b" class="kt ku in mw b gy na nb l nc nd">object KtorClient {<br/>    private const val AUTHORIZATION_HEADER = "Authorization"<br/>    private var API_KEY: String = "Your API Key here"<em class="mi"><br/><br/></em>    private val client = HttpClient(Android) <strong class="mw io">{<br/>        </strong><em class="mi">defaultRequest </em><strong class="mw io">{<br/>            </strong><em class="mi">header</em>(AUTHORIZATION_HEADER, "BEARER $API_KEY")<br/>        <strong class="mw io">}<br/>        </strong>install(JsonFeature) <strong class="mw io">{<br/>            </strong>serializer = KotlinxSerializer(<br/>kotlinx.serialization.json.<em class="mi">Json </em><strong class="mw io">{<br/>                </strong>isLenient = true<br/>                ignoreUnknownKeys = true<br/>                explicitNulls = false<br/>            <strong class="mw io">}</strong>)<br/>        <strong class="mw io">}<br/>    }<br/><br/>    </strong>val getInstance = client<br/>}</span></pre><p id="5cd6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这里，我创建了一个名为 KtorClient 的 Kotlin 对象。它有一个<strong class="jx io"> <em class="mi">客户端</em> </strong>属性，这是我们的 http 客户端。</p><ul class=""><li id="b476" class="lr ls in jx b jy jz kc kd kg mn kk mo ko mp ks lw lx ly lz bi translated"><em class="mi"> defaultRequest </em>确保 header 组件被传递给客户端发出的所有请求</li><li id="cbdb" class="lr ls in jx b jy ma kc mb kg mc kk md ko me ks lw lx ly lz bi translated"><em class="mi"> install(JsonFeature) </em>允许我们将响应序列化到 Kotlin 对象中</li></ul><p id="9c6d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> 3。设置响应模型类别</strong></p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="4c83" class="kt ku in mw b gy na nb l nc nd">import kotlinx.serialization.SerialName<br/>import kotlinx.serialization.Serializable<br/><br/>@Serializable<br/>data class SearchResponse(<br/>    @SerialName("businesses")<br/>    val businesses: List&lt;BusinessResponse&gt;,<br/><br/>    @SerialName("total")<br/>    val total: Int,<br/>) {<br/>    @Serializable<br/>    data class BusinessResponse(<br/>        @SerialName("id")<br/>        val id: String,<br/><br/>        @SerialName("name")<br/>        val name: String,<br/><br/>        @SerialName("image_url")<br/>        val imageUrl: String,<br/><br/>        @SerialName("is_closed")<br/>        val isClosed: Boolean,<br/><br/>        @SerialName("categories")<br/>        val categories: List&lt;BusinessCategoryResponse&gt;,<br/><br/>        @SerialName("price")<br/>        val price: String?,<br/><br/>        @SerialName("rating")<br/>        val rating: Float,<br/><br/>        @SerialName("phone")<br/>        val phone: String,<br/>    )<br/><br/>    @Serializable<br/>    data class BusinessCategoryResponse(<br/>        @SerialName("title")<br/>        val title: String,<br/>    )<br/>}</span></pre><ul class=""><li id="aedc" class="lr ls in jx b jy jz kc kd kg mn kk mo ko mp ks lw lx ly lz bi translated">@Serializable 注释帮助您序列化对 Kotlin 对象的 JSON 响应，反之亦然。</li><li id="cdae" class="lr ls in jx b jy ma kc mb kg mc kk md ko me ks lw lx ly lz bi translated">@SerialName 注释有助于在序列化发生时手动设置密钥名。</li></ul><p id="ad33" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> 4。创建 API 服务和服务实现</strong></p><p id="5feb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">与翻新不同的是，服务是为我们实现的，这里我们需要手动实现它。让我们看看如何</p><ul class=""><li id="6780" class="lr ls in jx b jy jz kc kd kg mn kk mo ko mp ks lw lx ly lz bi translated">创建一个名为 YelpAppServices.kt 的文件。这将提到我们计划设置的服务</li></ul><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="7a27" class="kt ku in mw b gy na nb l nc nd">interface YelpAppServices {<br/>    suspend fun search(<br/>        term: String = "burger",<br/>        location: String = "california",<br/>        limit: Int = 50,<br/>    ): SearchResponse<br/>}</span></pre><ul class=""><li id="8093" class="lr ls in jx b jy jz kc kd kg mn kk mo ko mp ks lw lx ly lz bi translated">创建一个名为 YelpAppServicesImpl.kt 的文件，这将为我们指定的服务提供实现</li></ul><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="2419" class="kt ku in mw b gy na nb l nc nd">object YelpAppServicesImpl : YelpAppServices {<br/>    private val httpClient by <em class="mi">lazy </em><strong class="mw io">{ </strong>KtorClient.getInstance <strong class="mw io">}<br/><br/>    </strong>override suspend fun search(term: String, location: String, limit: Int): SearchResponse {<br/>        return httpClient.get <strong class="mw io">{<br/>            </strong><em class="mi">url</em>("https://api.yelp.com/v3/businesses/search")<br/>            <em class="mi">parameter</em>("term", term)<br/>            <em class="mi">parameter</em>("location", location)<br/>            <em class="mi">parameter</em>("limit", limit)<br/>        <strong class="mw io">}<br/>    </strong>}<br/>}</span></pre><ul class=""><li id="6200" class="lr ls in jx b jy jz kc kd kg mn kk mo ko mp ks lw lx ly lz bi translated">在实现中，我们提供请求所指向的 URL</li><li id="9d3c" class="lr ls in jx b jy ma kc mb kg mc kk md ko me ks lw lx ly lz bi translated">我们还提供了发出请求的参数</li></ul><p id="570e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> 5。现在让我们从我们的存储库层调用我们的服务</strong></p><p id="fa1b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">创建一个 MainRepository.kt 并添加以下代码</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="45c6" class="kt ku in mw b gy na nb l nc nd">object MainRepository {<br/><br/>    suspend fun search(term: String? = null): <br/>         List&lt;BusinessResponse&gt; {<br/>        return try {<br/>            val response = <br/>                    YelpAppServicesImpl.search(term = term ?: "")<br/>            response.businesses<br/>        } catch (e: ClientRequestException) {<br/>            Timber.d("client exception" )<br/>            <em class="mi">emptyList()</em><br/>        } catch (e: IOException) {<br/>            Timber.d("no internet" )<br/>            <em class="mi">emptyList()</em><br/>        }<br/>    }<br/>}</span></pre><ul class=""><li id="6ab9" class="lr ls in jx b jy jz kc kd kg mn kk mo ko mp ks lw lx ly lz bi translated">ClientRequestException 是 KTor 提供的一个异常处理程序，用于处理 4XX 响应。类似的还有其他的处理程序，你可以在这里找到它们<a class="ae mm" href="https://ktor.io/docs/response-validation.html" rel="noopener ugc nofollow" target="_blank">。</a></li></ul><blockquote class="mf mg mh"><p id="05a6" class="jv jw mi jx b jy jz ka kb kc kd ke kf mj kh ki kj mk kl km kn ml kp kq kr ks ig bi translated">注意:为了文章的简单，如果有错误发生，我们用一个空列表来响应。确保您的响应包含适当的处理程序来处理这些情况。要了解更多，请阅读<a class="ae mm" href="https://medium.com/@hyzamzz/modern-network-calls-in-android-with-retrofit-coroutines-and-sealed-classes-8c9453a6b331" rel="noopener">这篇文章</a>。</p></blockquote><p id="e58f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> 6。通过视图模型</strong>向视图提供数据</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="f803" class="kt ku in mw b gy na nb l nc nd">class MainViewModel: ViewModel() {<br/>    private val _list = <br/>              MutableLiveData&lt;List&lt;BusinessResponse&gt;&gt;(<em class="mi">emptyList</em>())<br/>    private val list: LiveData&lt;List&lt;Business&gt;&gt; = _list<br/><br/>    fun search(term: String) {<br/>        <em class="mi">viewModelScope</em>.<em class="mi">launch</em>(Dispatchers.IO) <strong class="mw io">{<br/>            </strong>_list.postValue(MainRepository.search(term))<br/>        <strong class="mw io">}<br/>    </strong>}<br/>}</span></pre><p id="345b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，您可以在视图中观察列表并更新数据。</p><p id="a26c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">就是这样！</strong></p><p id="f66c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您已经成功创建了一个通过 Ktor 客户端与服务器通信的 android 应用程序。在他们的<a class="ae mm" href="https://ktor.io/docs/getting-started-ktor-client.html" rel="noopener ugc nofollow" target="_blank">官方文档</a>中了解更多关于 Ktor 客户端提供的所有特性。</p><p id="44a0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你觉得这篇文章对你有帮助，请分享并留下赞。<em class="mi">一路平安！</em></p></div></div>    
</body>
</html>