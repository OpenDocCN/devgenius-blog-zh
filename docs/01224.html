<html>
<head>
<title>Pruning your code — Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">修剪代码—第 2 部分</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/pruning-your-code-part-2-d32a2ef27e37?source=collection_archive---------12-----------------------#2020-06-27">https://blog.devgenius.io/pruning-your-code-part-2-d32a2ef27e37?source=collection_archive---------12-----------------------#2020-06-27</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="ff69" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi ki translated">在<a class="ae kr" href="https://medium.com/dev-genius/pruning-your-code-part-1-8ec0d27536db" rel="noopener">系列的第一部分</a>中，我们讨论了修剪代码的好处。我们还了解到过度修剪对你的软件有害。</p><p id="c523" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在第 2 部分中，我们将看一些条件的例子，以及如何用 OOP 设计和 JavaScript 来解决它们。</p><p id="1b80" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对于 OOP，我们也会看到我们的解决方案如何让我们更接近<strong class="jm io"> S.O.L.I.D 原则</strong>。</p><ul class=""><li id="efdd" class="ks kt in jm b jn jo jr js jv ku jz kv kd kw kh kx ky kz la bi translated">单一责任原则</li><li id="e035" class="ks kt in jm b jn lb jr lc jv ld jz le kd lf kh kx ky kz la bi translated">开/关原则</li><li id="a382" class="ks kt in jm b jn lb jr lc jv ld jz le kd lf kh kx ky kz la bi translated">利斯科夫替代原理</li><li id="e01d" class="ks kt in jm b jn lb jr lc jv ld jz le kd lf kh kx ky kz la bi translated">界面分离原理</li><li id="8669" class="ks kt in jm b jn lb jr lc jv ld jz le kd lf kh kx ky kz la bi translated">依赖注入原理</li></ul><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi lg"><img src="../Images/59de9b134ca252445995405d1765426a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CEEBrbiUYyERrpZCrQexCQ.jpeg"/></div></div></figure><h1 id="1ec4" class="ls lt in bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">何时修剪代码？</h1><p id="a6ff" class="pw-post-body-paragraph jk jl in jm b jn mq jp jq jr mr jt ju jv ms jx jy jz mt kb kc kd mu kf kg kh ig bi translated">然而，挑战在于如何发现需要修剪的分支——哪些条件语句应该被剪掉。</p><p id="3dad" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我喜欢根据两个标准来考虑修剪:</p><ul class=""><li id="f64f" class="ks kt in jm b jn jo jr js jv ku jz kv kd kw kh kx ky kz la bi translated">基于状态的行为</li><li id="b2a6" class="ks kt in jm b jn lb jr lc jv ld jz le kd lf kh kx ky kz la bi translated">重复条件</li></ul><h1 id="1825" class="ls lt in bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">基于状态的行为</h1><p id="a32d" class="pw-post-body-paragraph jk jl in jm b jn mq jp jq jr mr jt ju jv ms jx jy jz mt kb kc kd mu kf kg kh ig bi translated">基于状态的行为属于基于对象的<em class="mv">类型</em>或<em class="mv">值</em>选择行为的代码片段。</p><p id="5c33" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们考虑以下任务:</p><h2 id="40b3" class="mw lt in bd lu mx my dn ly mz na dp mc jv nb nc mg jz nd ne mk kd nf ng mo nh bi translated"><strong class="ak">型号 1 + 2 * 3 </strong></h2><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi lg"><img src="../Images/2780ce3318987af5727b13b8af7d50e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gBElvJe29nLHxEPQ0wlXsw.jpeg"/></div></div></figure><p id="dcc4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们现在将通过首先使用<em class="mv">条件</em>然后通过<em class="mv">多态</em>来对此建模。</p><p id="3775" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">用条件句建模:</strong></p><pre class="lh li lj lk gt ni nj nk nl aw nm bi"><span id="86d5" class="mw lt in nj b gy nn no l np nq"><strong class="nj io">class </strong>Node{<br/> <strong class="nj io">char </strong>operator;<br/> <strong class="nj io">double </strong>value;<br/> <strong class="nj io">Node </strong>left;<br/> <strong class="nj io">Node </strong>right;</span><span id="d963" class="mw lt in nj b gy nr no l np nq"><strong class="nj io"> double </strong>evaluate(){<br/>   <strong class="nj io">switch</strong>(operator){<br/>    case '#':return value;<br/>    case '+':return left.evaluate() + right.evaluate();<br/>    case '*':return left.evaluate() * right.evaluate();<br/>    case ... //All other operators.<br/>   }<br/> }<br/>}</span></pre><p id="f56b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">用多态性建模:</strong></p><pre class="lh li lj lk gt ni nj nk nl aw nm bi"><span id="9aeb" class="mw lt in nj b gy nn no l np nq"><strong class="nj io">abstract class </strong>Node{<br/>    <strong class="nj io">abstract double </strong>evaluate();<br/>}</span><span id="bde8" class="mw lt in nj b gy nr no l np nq"><strong class="nj io">class </strong>ValueNode <strong class="nj io">extends </strong>Node{<br/>    <strong class="nj io">double </strong>value;<br/>    <strong class="nj io">double </strong>evaluate(){<br/>        <strong class="nj io">return </strong>value;<br/>    }<br/>}</span><span id="f62c" class="mw lt in nj b gy nr no l np nq"><strong class="nj io">abstract class </strong>OpNode <strong class="nj io">extends </strong>Node{<br/>    <strong class="nj io">Node </strong>left;<br/>    <strong class="nj io">Node </strong>right;<br/>    <strong class="nj io">abstract double </strong>evaluate();<br/>}</span><span id="bc2c" class="mw lt in nj b gy nr no l np nq"><strong class="nj io">class </strong>AdditionNode <strong class="nj io">extends </strong>OpNode{<br/>    <strong class="nj io">double </strong>evaluate(){<br/>        <strong class="nj io">return </strong>left.evaluate() + right.evaluate();<br/>    }<br/>}</span><span id="88c4" class="mw lt in nj b gy nr no l np nq"><strong class="nj io">class </strong>MultiplicationNode <strong class="nj io">extends </strong>OpNode{<br/>    <strong class="nj io">double </strong>evaluate(){<br/>        <strong class="nj io">return </strong>left.evaluate() * right.evaluate();<br/>    }<br/>}</span></pre><h2 id="2a8e" class="mw lt in bd lu mx my dn ly mz na dp mc jv nb nc mg jz nd ne mk kd nf ng mo nh bi translated">另一个例子:</h2><p id="e476" class="pw-post-body-paragraph jk jl in jm b jn mq jp jq jr mr jt ju jv ms jx jy jz mt kb kc kd mu kf kg kh ig bi translated">存在三种鸟类，欧洲蓝、非洲蓝和挪威蓝。对于每种类型的鸟，你需要计算当前的速度。每种类型在计算速度的方式上都有所不同。</p><p id="77ce" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">让我们考虑一个利用<em class="mv">开关的解决方案——语句:</em> </strong></p><pre class="lh li lj lk gt ni nj nk nl aw nm bi"><span id="f1d4" class="mw lt in nj b gy nn no l np nq">class Bird {<br/>  //...<br/>  double getSpeed() {<br/>    switch (type) {<br/>      case EUROPEAN:<br/>        return getBaseSpeed();<br/>      case AFRICAN:<br/>        return getBaseSpeed() - getLoadFactor() * numberOfCoconuts;<br/>      case NORWEGIAN_BLUE:<br/>        return (isNailed) ? 0 : getBaseSpeed(voltage);<br/>    }<br/>    throw new RuntimeException("Should be unreachable");<br/>  }<br/>}</span></pre><p id="d8be" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">使用多态性解决:</strong></p><pre class="lh li lj lk gt ni nj nk nl aw nm bi"><span id="6ebc" class="mw lt in nj b gy nn no l np nq"><strong class="nj io">abstract class </strong>Bird {<br/>  //...<br/>  <strong class="nj io">abstract double </strong>getSpeed();<br/>}</span><span id="075d" class="mw lt in nj b gy nr no l np nq"><strong class="nj io">class </strong>European <strong class="nj io">extends </strong>Bird {<br/>  <strong class="nj io">double </strong>getSpeed() {<br/>    <strong class="nj io">return </strong>getBaseSpeed();<br/>  }<br/>}<br/><strong class="nj io">class </strong>African <strong class="nj io">extends </strong>Bird {<br/>  <strong class="nj io">double </strong>getSpeed() {<br/>    <strong class="nj io">return </strong>getBaseSpeed() - getLoadFactor() * numberOfCoconuts;<br/>  }<br/>}<br/><strong class="nj io">class </strong>NorwegianBlue <strong class="nj io">extends </strong>Bird {<br/>  <strong class="nj io">double </strong>getSpeed() {<br/>    <strong class="nj io">return </strong>(isNailed) ? 0 : getBaseSpeed(voltage);<br/>  }<br/>}</span><span id="4b8c" class="mw lt in nj b gy nr no l np nq">// When speed is required<br/>speed = bird.getSpeed();</span></pre><h2 id="d012" class="mw lt in bd lu mx my dn ly mz na dp mc jv nb nc mg jz nd ne mk kd nf ng mo nh bi translated">但是去掉条件句的意义是什么？</h2><p id="2d31" class="pw-post-body-paragraph jk jl in jm b jn mq jp jq jr mr jt ju jv ms jx jy jz mt kb kc kd mu kf kg kh ig bi translated">要理解在这种情况下删除条件的好处，应该考虑以下几点:</p><ul class=""><li id="2b92" class="ks kt in jm b jn jo jr js jv ku jz kv kd kw kh kx ky kz la bi translated">您现在可以在没有源代码的情况下添加新的行为</li><li id="1f03" class="ks kt in jm b jn lb jr lc jv ld jz le kd lf kh kx ky kz la bi translated">添加新功能不会导致每次都重新编译</li><li id="fa30" class="ks kt in jm b jn lb jr lc jv ld jz le kd lf kh kx ky kz la bi translated">因为关注点是分离的，所以可测试性和可读性得到了提高</li></ul><h1 id="6f4c" class="ls lt in bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">重复条件</h1><p id="abab" class="pw-post-body-paragraph jk jl in jm b jn mq jp jq jr mr jt ju jv ms jx jy jz mt kb kc kd mu kf kg kh ig bi translated">重复条件是指那些在代码中出现不止一次的条件语句。</p><h2 id="24e8" class="mw lt in bd lu mx my dn ly mz na dp mc jv nb nc mg jz nd ne mk kd nf ng mo nh bi translated">重复条件示例</h2><pre class="lh li lj lk gt ni nj nk nl aw nm bi"><span id="3d1e" class="mw lt in nj b gy nn no l np nq"><strong class="nj io">class </strong>Update(){<br/>    execute(){<br/>        <strong class="nj io">if</strong>(FLAG_i18n_ENABLED){<br/>            //DO A<br/>        }<strong class="nj io">else</strong>{<br/>            //DO B<br/>        }<br/>    }<br/>    <br/>    render(){<br/>        <strong class="nj io">if</strong>(FLAG_i18n_ENABLED){<br/>            //render A<br/>        }<strong class="nj io">else</strong>{<br/>            //render B<br/>        }<br/>    }<br/>}</span></pre><p id="8a63" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">通过用重复的 IF 语句解决问题，很明显测试解决方案并不那么简单。所有代码都将对<strong class="jm io"> FLAG_i18n_ENABLED </strong>具有全局依赖性。</p><pre class="lh li lj lk gt ni nj nk nl aw nm bi"><span id="8d62" class="mw lt in nj b gy nn no l np nq"><strong class="nj io">void </strong>testExecuteDoA{<br/>    FLAG_i18n_ENABLED = true;<br/>    <strong class="nj io">Update </strong>u = <strong class="nj io">new </strong>Update();<br/>    e.execute();<br/>    assertX();<br/>}</span><span id="02a9" class="mw lt in nj b gy nr no l np nq"><strong class="nj io">void </strong>testExecuteDoB{<br/>    FLAG_i18n_ENABLED = false;<br/>    <strong class="nj io">Update </strong>u = <strong class="nj io">new </strong>Update();<br/>    e.execute();<br/>    assertX();<br/>}</span></pre><h2 id="670b" class="mw lt in bd lu mx my dn ly mz na dp mc jv nb nc mg jz nd ne mk kd nf ng mo nh bi translated">我们如何解决这个问题？</h2><p id="24e2" class="pw-post-body-paragraph jk jl in jm b jn mq jp jq jr mr jt ju jv ms jx jy jz mt kb kc kd mu kf kg kh ig bi translated">我们可以通过以下方法轻松回避这个问题:</p><ul class=""><li id="f575" class="ks kt in jm b jn jo jr js jv ku jz kv kd kw kh kx ky kz la bi translated">用多态设计替换条件句</li><li id="8f56" class="ks kt in jm b jn lb jr lc jv ld jz le kd lf kh kx ky kz la bi translated">行为由对象的类型决定</li><li id="403f" class="ks kt in jm b jn lb jr lc jv ld jz le kd lf kh kx ky kz la bi translated">将条件的每个分支移动到重写方法或子类。使原来的方法变得抽象。</li></ul><h2 id="88c6" class="mw lt in bd lu mx my dn ly mz na dp mc jv nb nc mg jz nd ne mk kd nf ng mo nh bi translated">用多态设计解决问题:</h2><pre class="lh li lj lk gt ni nj nk nl aw nm bi"><span id="9865" class="mw lt in nj b gy nn no l np nq"><strong class="nj io">abstract class </strong>Update{//..}<br/><strong class="nj io">class </strong>I18NUpdate <strong class="nj io">extends </strong>Update{<br/>    execute(){<br/>        // Do A}<br/>    render(){<br/>        // Do A}<br/>}<br/><strong class="nj io">class </strong>NonI18NUpdate <strong class="nj io">extends </strong>Update{<br/>    execute(){<br/>        // Do B<br/>    } <br/>    render(){<br/>        // Do B<br/>    }<br/>}</span></pre><p id="e440" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">测试代码的各个方面现在已经大大简化了:</p><pre class="lh li lj lk gt ni nj nk nl aw nm bi"><span id="5a95" class="mw lt in nj b gy nn no l np nq"><strong class="nj io">void </strong>testExecuteDoA{<br/>    <strong class="nj io">Update </strong>u = <strong class="nj io">new </strong>I18NUpdate();<br/>    u.execute();<br/>    assertX();<br/>}</span><span id="1f6c" class="mw lt in nj b gy nr no l np nq"><strong class="nj io">void </strong>testExecuteDoB{<br/>    <strong class="nj io">Update </strong>u = <strong class="nj io">new </strong>NonI18NUpdate();<br/>    u.execute();<br/>    assertX();<br/>}</span></pre><p id="91b0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">显而易见，现在每条可能的路径都是独立的，可以单独测试。</p><p id="8d09" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是 IF 语句发生了什么变化呢？</p><p id="6591" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这种情况下，条件句是不能完全避免的。我们仍然需要知道要实例化该类的哪个版本。</p><p id="6f07" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们的好处是 IF 语句可以远离内联。此外，我们还开放了代码来利用依赖注入。</p><h2 id="a515" class="mw lt in bd lu mx my dn ly mz na dp mc jv nb nc mg jz nd ne mk kd nf ng mo nh bi translated">要理解这一点，必须从两方面考虑您的应用:</h2><ul class=""><li id="d7cd" class="ks kt in jm b jn mq jr mr jv ns jz nt kd nu kh kx ky kz la bi translated">一堆<strong class="jm io">物品</strong></li><li id="ee18" class="ks kt in jm b jn lb jr lc jv ld jz le kd lf kh kx ky kz la bi translated">桩<strong class="jm io">施工</strong></li></ul><p id="9285" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">对象堆</strong>负责你的业务逻辑、领域逻辑和抽象。</p><p id="020f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">构建的<strong class="jm io">堆</strong>负责构建对象，构建对象图(所有组件如何一起工作来解决定制问题)</p><p id="d43d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">工厂模式</strong>是一个对象的例子，它可以构造(构建)其他对象，让它与其他对象一起工作来解决问题。</p><p id="451d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在本例中，工厂模式将用于集中 IF 语句:</p><pre class="lh li lj lk gt ni nj nk nl aw nm bi"><span id="88b3" class="mw lt in nj b gy nn no l np nq"><strong class="nj io">class </strong>Factory{<br/>    <strong class="nj io">Consumer </strong>build(){<br/>        <strong class="nj io">Update </strong>u = FLAG_i18n_ENABLED ? <strong class="nj io">new </strong>I18NUpdate() : <br/>                   <strong class="nj io">new </strong>NonI18NUpdate();<br/>        <strong class="nj io">return </strong>u;<br/>    }<br/>}</span></pre><h2 id="3b17" class="mw lt in bd lu mx my dn ly mz na dp mc jv nb nc mg jz nd ne mk kd nf ng mo nh bi translated">有什么好处？</h2><ul class=""><li id="2856" class="ks kt in jm b jn mq jr mr jv ns jz nt kd nu kh kx ky kz la bi translated">所有的条件现在都在一个地方</li><li id="b04f" class="ks kt in jm b jn lb jr lc jv ld jz le kd lf kh kx ky kz la bi translated">删除了条件重复，从而产生了更可预测的代码</li><li id="a4c3" class="ks kt in jm b jn lb jr lc jv ld jz le kd lf kh kx ky kz la bi translated">关注点现已分离</li><li id="df3a" class="ks kt in jm b jn lb jr lc jv ld jz le kd lf kh kx ky kz la bi translated">移除了全局依赖，使得代码更易测试</li><li id="0470" class="ks kt in jm b jn lb jr lc jv ld jz le kd lf kh kx ky kz la bi translated">打开你的代码进行扩展，关闭它进行修改</li></ul><h1 id="a853" class="ls lt in bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">一些额外的例子</h1><h2 id="9034" class="mw lt in bd lu mx my dn ly mz na dp mc jv nb nc mg jz nd ne mk kd nf ng mo nh bi translated">示例 1</h2><p id="743b" class="pw-post-body-paragraph jk jl in jm b jn mq jp jq jr mr jt ju jv ms jx jy jz mt kb kc kd mu kf kg kh ig bi translated"><strong class="jm io"> <em class="mv">我们来数一下这个数组里有多少个整数是奇数:</em> </strong></p><pre class="lh li lj lk gt ni nj nk nl aw nm bi"><span id="1692" class="mw lt in nj b gy nn no l np nq"><strong class="nj io">const </strong>arrayOfIntegers = [1, 4, 5, 9, 0, -1, 5];</span><span id="97df" class="mw lt in nj b gy nr no l np nq"><strong class="nj io">let </strong>counter = 0;<br/>arrayOfIntegers.forEach((integer) =&gt; {<br/>    <strong class="nj io">const </strong>remainder = Math.abs(integer % 2);<br/>    if (remainder === 1) {<br/>        counter++;<br/>    }<br/>});<br/>console.log(counter);</span></pre><p id="466b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个例子可以改写如下:</p><pre class="lh li lj lk gt ni nj nk nl aw nm bi"><span id="92c0" class="mw lt in nj b gy nn no l np nq"><strong class="nj io">const </strong>arrayOfIntegers = [1, 4, 5, 9, 0, -1, 5];</span><span id="b2fb" class="mw lt in nj b gy nr no l np nq"><strong class="nj io">let </strong>counter = 0;<br/>arrayOfIntegers.forEach((integer) =&gt; {<br/>    <strong class="nj io">const </strong>remainder = Math.abs(integer % 2);<br/>    counter += remainder;<br/>});<br/>console.log(counter);</span></pre><h2 id="7a95" class="mw lt in bd lu mx my dn ly mz na dp mc jv nb nc mg jz nd ne mk kd nf ng mo nh bi translated">示例 2</h2><p id="0c02" class="pw-post-body-paragraph jk jl in jm b jn mq jp jq jr mr jt ju jv ms jx jy jz mt kb kc kd mu kf kg kh ig bi translated"><em class="mv">编写一个函数，它接受一个日期对象参数(比如 new Date())并返回字符串“周末”或“工作日”。</em></p><pre class="lh li lj lk gt ni nj nk nl aw nm bi"><span id="fbc7" class="mw lt in nj b gy nn no l np nq"><strong class="nj io">const </strong>weekendOrWeekday = (inputDate) =&gt; {<br/>    <strong class="nj io">const </strong>day = inputDate.getDay();<br/>    if (day === 0 || day === 6) {<br/>        <strong class="nj io">return </strong>'weekend';<br/>    }<br/>    <strong class="nj io">return </strong>'weekday';<br/>};</span><span id="0561" class="mw lt in nj b gy nr no l np nq">console.log(weekendOrWeekday(<strong class="nj io">new </strong>Date()));</span></pre><p id="bc84" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个例子可以改写如下:</p><pre class="lh li lj lk gt ni nj nk nl aw nm bi"><span id="76c9" class="mw lt in nj b gy nn no l np nq">weekendOrWeekday.labels = {<br/>    0: 'weekend',<br/>    6: 'weekend',<br/>    default: 'weekday'<br/>};<br/><strong class="nj io">const </strong>weekendOrWeekday = (inputDate) =&gt; {<br/>    <strong class="nj io">const </strong>day = inputDate.getDay();<br/>    <strong class="nj io">return </strong>weekendOrWeekday.labels[day] ||   weekendOrWeekday.labels['default'];<br/>};</span><span id="5322" class="mw lt in nj b gy nr no l np nq">console.log(weekendOrWeekday(<strong class="nj io">new </strong>Date()));</span></pre></div></div>    
</body>
</html>