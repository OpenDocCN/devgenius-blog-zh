<html>
<head>
<title>Binary (Lower Bound) Search in SQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SQL 中的二进制(下限)搜索</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/binary-lower-bound-search-in-sql-384cb0cc66fe?source=collection_archive---------9-----------------------#2022-12-24">https://blog.devgenius.io/binary-lower-bound-search-in-sql-384cb0cc66fe?source=collection_archive---------9-----------------------#2022-12-24</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="3623" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">我们探索了使用递归 cte 在声明性 SQL 中实现二分搜索法</h2></div><p id="d152" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">二分搜索法是一种在有序数组中定位数据的非常流行的(并且机器效率高的)技术。它通常用命令式编程语言来实现，如 C++、Java、Python 等。今天我们将探索二分搜索法在声明式 SQL 语法中的实现。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi ky"><img src="../Images/07a8fc6a591424e7f966a28c3121d798.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9DDh8FLSmMQu99fL"/></div></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk translated">叶夫根尼·切尔卡斯基在<a class="ae lo" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="4938" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">更具体地说，我们将看看 SQL 中的<a class="ae lo" href="https://en.cppreference.com/w/cpp/algorithm/lower_bound" rel="noopener ugc nofollow" target="_blank"> lower_bound() </a>函数的实现。<strong class="ke io"> lower_bound(value) </strong>返回排序输入范围中第一个元素的位置，在此之前可以插入<strong class="ke io">值</strong>以保持数据的排序。</p><p id="1b9c" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">上一篇文章:</strong> <a class="ae lo" href="https://medium.com/@dhruvbird/maximum-subarray-sum-using-sql-e1befa75d055" rel="noopener">使用 SQL 的最大子数组和</a></p><h1 id="8523" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">一个 C++实现</h1><p id="8152" class="pw-post-body-paragraph kc kd in ke b kf mh jo kh ki mi jr kk kl mj kn ko kp mk kr ks kt ml kv kw kx ig bi translated">这就是 lower_bound 在 C++中的实现方式(对于整数数组)。</p><pre class="kz la lb lc gt mm mn mo bn mp mq bi"><span id="d425" class="mr lq in mn b be ms mt l mu mv">// Returns a pointer into the array (begin, end) such that the pointer<br/>// points to the first position where target_value can be safely<br/>// inserted while preserving the sortedness of the range (begin, end+1).<br/>int* lower_bound(int *begin, int *end, int target_value) {<br/>  while (begin != end) {<br/>    int *m = begin + (end - begin) / 2;<br/>    if (target_value &lt;= *m) {<br/>      // Go Left<br/>      end = m;<br/>    } else {<br/>      // Go Right<br/>      begin = m + 1;<br/>    }<br/>  }<br/>  return begin;<br/>}</span></pre></div><div class="ab cl mw mx hr my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ig ih ii ij ik"><h1 id="18ed" class="lp lq in bd lr ls nd lu lv lw ne ly lz jt nf ju mb jw ng jx md jz nh ka mf mg bi translated">输入表模式</h1><p id="3d44" class="pw-post-body-paragraph kc kd in ke b kf mh jo kh ki mi jr kk kl mj kn ko kp mk kr ks kt ml kv kw kx ig bi translated">输入表有 2 列:</p><ol class=""><li id="ade8" class="ni nj in ke b kf kg ki kj kl nk kp nl kt nm kx nn no np nq bi translated"><strong class="ke io"> idx: </strong>数组元素索引(如果在 C++中使用数组，这就是你在数组中寻址元素的方式)。</li><li id="5ff3" class="ni nj in ke b kf nr ki ns kl nt kp nu kt nv kx nn no np nq bi translated"><strong class="ke io">值:</strong>存储的值。</li></ol><p id="1765" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">假设该表按<strong class="ke io">值</strong>字段排序(非降序)。</p><pre class="kz la lb lc gt mm mn mo bn mp mq bi"><span id="8ffa" class="mr lq in mn b be ms mt l mu mv">CREATE TABLE array_data(idx SERIAL PRIMARY KEY, value INTEGER NOT NULL);<br/><br/>-- Insert 1000 randomly generated values in non-decreasing sorted order<br/>-- into the table array_data.<br/>INSERT INTO array_data(idx, value)<br/><br/>WITH RECURSIVE ins_query(value, n) AS (<br/>  SELECT FLOOR(RANDOM() * 5000) + 1 AS value, 1000 AS n<br/>  <br/>  UNION ALL<br/>  <br/>  SELECT FLOOR(RANDOM() * 5000) + 1, n - 1<br/>  FROM ins_query<br/>  WHERE n - 1 &gt; 0<br/>)<br/><br/>SELECT<br/>  ROW_NUMBER() OVER (ORDER BY value ASC) AS idx,<br/>  value<br/>FROM ins_query<br/>ORDER BY idx ASC;</span></pre><p id="a7cf" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们使用一个<a class="ae lo" href="https://www.postgresql.org/docs/current/queries-with.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ke io">递归 CTE </strong> </a>(通用表表达式)来生成 1000 个随机值，并按排序顺序添加到表中。</p><p id="a33b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们将在下面看到更多使用递归 cte 来模拟 SQL 中的循环。</p><pre class="kz la lb lc gt mm mn mo bn mp mq bi"><span id="1e84" class="mr lq in mn b be ms mt l mu mv">SELECT * FROM array_data LIMIT 10;</span></pre><figure class="kz la lb lc gt ld gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/f24d019a03ced8bdf089f508ac3ff4fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:912/format:webp/1*eHrWTc_5Kb4A5p7AVPLU7A.png"/></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk translated">来自输入表 array_data 的 10 行样本(图片由作者提供)</figcaption></figure></div><div class="ab cl mw mx hr my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ig ih ii ij ik"><h1 id="371e" class="lp lq in bd lr ls nd lu lv lw ne ly lz jt nf ju mb jw ng jx md jz nh ka mf mg bi translated">第一个解决方案:使用 ORDER BY 和 LIMIT 的简单 SQL</h1><p id="36f3" class="pw-post-body-paragraph kc kd in ke b kf mh jo kh ki mi jr kk kl mj kn ko kp mk kr ks kt ml kv kw kx ig bi translated">我们可以用 SQL 相当有效地解决这个问题，因为我们已经在<strong class="ke io"> idx </strong>列上有了一个<strong class="ke io">主键</strong>索引。</p><pre class="kz la lb lc gt mm mn mo bn mp mq bi"><span id="477a" class="mr lq in mn b be ms mt l mu mv">SELECT<br/>  idx<br/>FROM array_data<br/>WHERE value &gt;= 181<br/>ORDER BY value ASC, idx ASC<br/>LIMIT 1;</span></pre><figure class="kz la lb lc gt ld gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/953db096daa3d42b079bd76969b428de.png" data-original-src="https://miro.medium.com/v2/resize:fit:130/format:webp/1*tJOD4RIy7PwhCHIYCftpZw.png"/></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk translated">第一个解决方案的查询结果(图片由作者提供)</figcaption></figure><p id="7ec1" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">估计开销:</strong>这个 1000 行的表的查询的估计开销是<a class="ae lo" href="https://explain.depesz.com/s/MZ8O" rel="noopener ugc nofollow" target="_blank"> 22 </a>。</p><p id="21d5" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们期望这个解决方案的预期复杂度是<strong class="ke io"> O(log n) </strong>，其中“n”是我们的表<strong class="ke io"> array_data </strong>中元素的数量。这是因为 PostgreSQL 的默认索引类型是 B 树。</p></div><div class="ab cl mw mx hr my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ig ih ii ij ik"><h1 id="5cec" class="lp lq in bd lr ls nd lu lv lw ne ly lz jt nf ju mb jw ng jx md jz nh ka mf mg bi translated">第二个解决方案:显式的二分搜索法式执行</h1><p id="6f7a" class="pw-post-body-paragraph kc kd in ke b kf mh jo kh ki mi jr kk kl mj kn ko kp mk kr ks kt ml kv kw kx ig bi translated">因为我们想看看我们能用 SQL 走多远，所以我们想显式地编写我们自己的搜索过程。</p><p id="141b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">从上面基于 C++的解决方案中汲取灵感，这就是我们的 SQL 代码的样子。</p><pre class="kz la lb lc gt mm mn mo bn mp mq bi"><span id="253a" class="mr lq in mn b be ms mt l mu mv">WITH RECURSIVE lower_bound(begin_idx, end_idx, target_value) AS (<br/>    VALUES (1, (SELECT 1 + COUNT(1) FROM array_data), 181)<br/>  UNION ALL<br/>    (<br/>      -- First, locate the mid point of the sorted range, and the<br/>      -- element at that location so that we can compare it with the<br/>      -- value being searched for. Later, we shall see how to decide<br/>      -- whether to go left or right in our search.<br/>      WITH element_at_idx AS (<br/>        SELECT<br/>          idx, value, target_value, begin_idx, end_idx,<br/>          -- is_complete is TRUE if the incoming range [begin, end) is empty.<br/>          -- If it's empty, we can exit the search.<br/>          CASE WHEN begin_idx = end_idx THEN TRUE ELSE FALSE END AS is_complete<br/>        FROM lower_bound INNER JOIN array_data<br/>        ON idx = (begin_idx + (end_idx - begin_idx) / 2)<br/>        LIMIT 1<br/>      ),<br/><br/>      -- Due to the nature of SQL, we need to compute both ranges<br/>      -- as if the value was found either on the left half of the<br/>      -- original range...<br/>      go_left AS (<br/>        SELECT<br/>          begin_idx, idx AS end_idx, target_value, is_complete<br/>        FROM element_at_idx<br/>        WHERE target_value &lt;= value<br/>        LIMIT 1<br/>      ),<br/>      <br/>      -- ... or on the right half of the original range.<br/>      go_right AS (<br/>        SELECT<br/>          idx + 1 AS begin_idx, end_idx, target_value, is_complete<br/>        FROM element_at_idx<br/>        WHERE target_value &gt; value<br/>        LIMIT 1<br/>      ),<br/>      <br/>      -- and then we need to pick the side on which the value<br/>      -- *actually* may lie by ignoring the incorrect side.<br/>      one_of_2 AS (<br/>        SELECT * FROM go_left<br/>        UNION ALL<br/>        SELECT * FROM go_right<br/>      )<br/>      <br/>      SELECT<br/>        begin_idx,<br/>        end_idx,<br/>        target_value<br/>      FROM one_of_2<br/>      -- We need to check is_complete (the incoming range) and not the<br/>      -- outgoing range since if we check the outgoing range and return<br/>      -- an empty result set, it will not be recorded in the output by<br/>      -- the recursive CTE, and we will be left with an ambiguous output<br/>      -- range.<br/>      WHERE is_complete = FALSE<br/>    )<br/>)<br/><br/>SELECT * FROM lower_bound;</span></pre><p id="c26e" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是查询输出的样子。其中<strong class="ke io"> begin_idx = end_idx </strong>的行的<strong class="ke io"> end_idx </strong>的值是我们的答案(与上面的查询相同)。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/b85505dc623032443f12a2f6fe5ab95a.png" data-original-src="https://miro.medium.com/v2/resize:fit:922/format:webp/1*-NqRfYuM19MfRjasnYIsjw.png"/></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk translated">第二个解决方案的查询结果(图片由作者提供)</figcaption></figure><p id="cd5b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如您所见，结果集中有 11 行。为了找到答案，我们递归了 O(log n) 次。在传统的编程语言中，数组访问需要花费<strong class="ke io"> O(1) </strong>时间，但是在 SQL 中，通过主键列定位表中的元素需要花费<strong class="ke io"> O(log n) </strong>(假设是 B 树索引)。下面的代码显示了数组访问在我们的代码中发生的位置。</p><pre class="kz la lb lc gt mm mn mo bn mp mq bi"><span id="f71a" class="mr lq in mn b be ms mt l mu mv">WITH element_at_idx AS (<br/>  SELECT<br/>    idx, value, target_value, begin_idx, end_idx,<br/>    -- is_complete is TRUE if the incoming range [begin, end) is empty.<br/>    -- If it's empty, we can exit the search.<br/>    CASE WHEN begin_idx = end_idx THEN TRUE ELSE FALSE END AS is_complete<br/>  FROM lower_bound INNER JOIN array_data<br/>  ON idx = (begin_idx + (end_idx - begin_idx) / 2)<br/>  LIMIT 1<br/>),</span></pre><p id="cfa1" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，我们解决方案的成本变成了<strong class="ke io"> O(log n) </strong>。</p><p id="e4c6" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">估计开销:</strong>这个 1000 行的表的查询的估计开销是<a class="ae lo" href="https://explain.depesz.com/s/HUUw" rel="noopener ugc nofollow" target="_blank"> 62 </a>。</p></div><div class="ab cl mw mx hr my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ig ih ii ij ik"><h1 id="cedf" class="lp lq in bd lr ls nd lu lv lw ne ly lz jt nf ju mb jw ng jx md jz nh ka mf mg bi translated">SQL 小提琴</h1><p id="93f9" class="pw-post-body-paragraph kc kd in ke b kf mh jo kh ki mi jr kk kl mj kn ko kp mk kr ks kt ml kv kw kx ig bi translated">这篇文章中所有解决方案的 SQL 链接可以在这里找到<a class="ae lo" href="http://sqlfiddle.com/#!17/400b0c/4" rel="noopener ugc nofollow" target="_blank">。</a></p></div><div class="ab cl mw mx hr my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ig ih ii ij ik"><h1 id="ba87" class="lp lq in bd lr ls nd lu lv lw ne ly lz jt nf ju mb jw ng jx md jz nh ka mf mg bi translated">学问</h1><p id="4902" class="pw-post-body-paragraph kc kd in ke b kf mh jo kh ki mi jr kk kl mj kn ko kp mk kr ks kt ml kv kw kx ig bi translated">以下是我在写这个解决方案时学到的东西:</p><ol class=""><li id="342f" class="ni nj in ke b kf kg ki kj kl nk kp nl kt nm kx nn no np nq bi translated">迭代有时可以被递归代替，就像 SQL 中的递归 cte 所支持的那样。</li><li id="b73a" class="ni nj in ke b kf nr ki ns kl nt kp nu kt nv kx nn no np nq bi translated">处理条件逻辑和早期回报是困难的。一种方法是计算条件逻辑中两个代码(所有)路径的值，然后删除不需要的部分。这需要小心地完成，因为您需要确保不需要的部分不会抛出某种异常并使查询崩溃。CPU 处理器通常做一些类似的事情，作为特定指令执行的一部分。从某种意义上说，我们也是在投机，然后从实际路径中选择结果。</li><li id="0c24" class="ni nj in ke b kf nr ki ns kl nt kp nu kt nv kx nn no np nq bi translated">当编写递归 cte 时，我们需要将中间表视为存储递归函数的所有参数，以及方法的中间变量和最终结果。</li></ol></div><div class="ab cl mw mx hr my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ig ih ii ij ik"><h1 id="756c" class="lp lq in bd lr ls nd lu lv lw ne ly lz jt nf ju mb jw ng jx md jz nh ka mf mg bi translated">参考</h1><ol class=""><li id="7b7b" class="ni nj in ke b kf mh ki mi kl nz kp oa kt ob kx nn no np nq bi translated"><a class="ae lo" href="https://www.endpointdev.com/blog/2020/10/postgresql-binary-search-correlated-data-cte/" rel="noopener ugc nofollow" target="_blank">使用 cte 对包含非索引相关数据的大型表进行二分搜索法</a></li></ol></div></div>    
</body>
</html>