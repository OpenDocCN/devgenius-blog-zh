<html>
<head>
<title>Getting started with Helm — Part I</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Helm 入门—第一部分</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/getting-started-with-helm-part-i-91a5f7c79ad6?source=collection_archive---------2-----------------------#2021-11-13">https://blog.devgenius.io/getting-started-with-helm-part-i-91a5f7c79ad6?source=collection_archive---------2-----------------------#2021-11-13</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><blockquote class="jk jl jm"><p id="1696" class="jn jo jp jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ig bi translated">当我第一次开始将应用程序部署到目标位置时，这都是手动的，有时需要花费几个小时来复制巨大的 tar 文件，如果必须在应用程序中进行任何更改，tar 文件会重新生成并重新复制到目标位置。有了<a class="ae km" href="https://helm.sh/" rel="noopener ugc nofollow" target="_blank"> Helm </a>作为软件包经理和<a class="ae km" href="https://kubernetes.io/" rel="noopener ugc nofollow" target="_blank"> kubernetes </a>作为部署引擎，这就像从马里奥视频游戏时代转移到最新的 PS5 主机游戏时代</p></blockquote><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi kn"><img src="../Images/aadf5b552e340a0b15eca9d3c69a8573.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Sc6NUJTIrLG6_0JXrWmu8A.jpeg"/></div></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">照片由<a class="ae km" href="https://unsplash.com/@syhussaini?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">赛义德·胡赛尼</a>在<a class="ae km" href="https://unsplash.com/s/photos/helm?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure></div><div class="ab cl ld le hr lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="ig ih ii ij ik"><h1 id="33af" class="lk ll in bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated"><strong class="ak">为什么要掌舵？</strong></h1><p id="0d69" class="pw-post-body-paragraph jn jo in jq b jr mi jt ju jv mj jx jy mk ml kb kc mm mn kf kg mo mp kj kk kl ig bi translated"><strong class="jq io"> <em class="jp">使用图表管理 kubernetes 应用</em> </strong>:您可能希望使用 kubernetes 作为云编排引擎部署的任何应用都可以使用 helm 图表来创建和维护。</p><p id="f441" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy mk ka kb kc mm ke kf kg mo ki kj kk kl ig bi translated"><strong class="jq io"> <em class="jp">提供存放打包图表的图表存储库:</em> </strong>为了存放应用图表，helm 在这里公开提供一个集中的位置<a class="ae km" href="https://artifacthub.io/packages/search?kind=0" rel="noopener ugc nofollow" target="_blank">，并且还提供在</a><a class="ae km" href="https://www.jfrog.com/confluence/display/JFROG/Kubernetes+Helm+Chart+Repositories" rel="noopener ugc nofollow" target="_blank"> JFrog </a>或 GCP 上私下存放存储库的设施。</p><p id="a033" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy mk ka kb kc mm ke kf kg mo ki kj kk kl ig bi translated"><strong class="jq io"> <em class="jp">提供 cli 以安装升级或删除任何版本:</em> </strong>供最终用户与<strong class="jq io"> Helm 交互，</strong>提供命令行客户端，负责本地图表开发、将图表上传到存储库、管理存储库以及管理现有版本的升级和卸载。</p><h1 id="43f0" class="lk ll in bd lm ln mq lp lq lr mr lt lu lv ms lx ly lz mt mb mc md mu mf mg mh bi translated">什么是头盔？</h1><p id="197a" class="pw-post-body-paragraph jn jo in jq b jr mi jt ju jv mj jx jy mk ml kb kc mm mn kf kg mo mp kj kk kl ig bi translated">在了解了我们为什么需要 helm 以及传统应用程序部署的历史之后，可以肯定地说 helm 是 kubernetes 的一个包管理器，用于从零开始安装应用程序或使用 Helm 图表升级现有的应用程序。</p><p id="45fd" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy mk ka kb kc mm ke kf kg mo ki kj kk kl ig bi translated">它还通过与存储图表的图表库交互来管理应用程序生命周期，以便在集群中安装和卸载图表。Helm 还管理已安装图表的发布周期。</p><p id="7730" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy mk ka kb kc mm ke kf kg mo ki kj kk kl ig bi translated">Helm 提供了一种通过在 Go 中模板化来<strong class="jq io">定制应用程序的方法，更多使用 Go 模板函数开发 helm 图表的技巧和诀窍可以在<a class="ae km" href="https://helm.sh/docs/howto/charts_tips_and_tricks/" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</strong></p></div><div class="ab cl ld le hr lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="ig ih ii ij ik"><h1 id="6e1d" class="lk ll in bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated"><strong class="ak">舵的关键部件</strong></h1><p id="5ce5" class="pw-post-body-paragraph jn jo in jq b jr mi jt ju jv mj jx jy mk ml kb kc mm mn kf kg mo mp kj kk kl ig bi translated">1.<strong class="jq io"> Helm chart — </strong> Helm chart 是一种将应用程序打包成名为<em class="jp"> charts </em>的格式的方法，该格式是一组文件的集合，这些文件描述了在 kubernetes 集群中成功部署应用程序所需的一组相关的 Kubernetes 资源。图表是作为特定目录树中的文件创建的。它们可以打包到版本化的归档文件中进行部署。</p><p id="2bf9" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy mk ka kb kc mm ke kf kg mo ki kj kk kl ig bi translated">2.<strong class="jq io"> Helm 库</strong> — Helm 库使用 Kubernetes 客户端库与 Kubernetes 通信。目前，该库使用 REST+JSON。它将信息储存在位于 Kubernetes 内部的秘密中。它不需要自己的数据库。</p><p id="84c9" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy mk ka kb kc mm ke kf kg mo ki kj kk kl ig bi translated">3.<strong class="jq io"> Helm 客户端(CLI)</strong>—Helm 客户端和库都是用 Go 编程语言编写的。Helm cli 负责本地图表开发、将图表上传到存储库、管理存储库以及管理现有版本的升级和卸载。我将在下一篇关于头盔的文章中详细介绍所有这些操作的头盔命令。</p><p id="ae8a" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy mk ka kb kc mm ke kf kg mo ki kj kk kl ig bi translated">4.<strong class="jq io">舵库</strong> —在这一点上，Github 中的官方<a class="ae km" href="https://github.com/helm/charts" rel="noopener ugc nofollow" target="_blank">舵图表库</a>已经过时，这是因为随着图表数量的增加，对其进行维护是维护者的一项重大任务。他们更倾向于通过 GitHub 版本提供工具和用于托管工件的页面来托管自己的图表报告。</p></div><div class="ab cl ld le hr lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="ig ih ii ij ik"><h1 id="6696" class="lk ll in bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated"><strong class="ak">舵图结构</strong></h1><p id="ac87" class="pw-post-body-paragraph jn jo in jq b jr mi jt ju jv mj jx jy mk ml kb kc mm mn kf kg mo mp kj kk kl ig bi translated">舵图被组织成一个目录中的文件集合。目录名是没有版本信息的图表的名称。</p><p id="06b6" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy mk ka kb kc mm ke kf kg mo ki kj kk kl ig bi translated">在这个目录中，Helm 将期望一个如下匹配的结构:</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/ce296f75ac652dad6346d3c42445333f.png" data-original-src="https://miro.medium.com/v2/resize:fit:812/format:webp/1*8mTm0YthclpLjyI6OXPwmg.png"/></div><figcaption class="kz la gj gh gi lb lc bd b be z dk translated">舵图结构</figcaption></figure><p id="85f1" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy mk ka kb kc mm ke kf kg mo ki kj kk kl ig bi translated">1.<strong class="jq io"> C <em class="jp"> hart.yaml </em></strong></p><p id="0f66" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy mk ka kb kc mm ke kf kg mo ki kj kk kl ig bi translated">2.<strong class="jq io"><em class="jp">values . yaml</em></strong><em class="jp">:</em>这个 YAML 文件包含用于在集群中生成 release 的键和值。这些值在资源清单中被替换。</p><p id="fbbf" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy mk ka kb kc mm ke kf kg mo ki kj kk kl ig bi translated">3.<strong class="jq io"><em class="jp">【config map . yaml</em></strong>:这个 YAML 文件是用来存储一个应用所需要的配置数据，比如数据库用户名，URL 等。</p><p id="3f8d" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy mk ka kb kc mm ke kf kg mo ki kj kk kl ig bi translated">4.<strong class="jq io"> <em class="jp"> secrets.yaml </em> </strong>:这个 yaml 文件以加密格式存储数据库密码。所有应用程序的敏感信息都可以存储在机密文件中。</p><p id="ab35" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy mk ka kb kc mm ke kf kg mo ki kj kk kl ig bi translated">5.<strong class="jq io"> <em class="jp"> deployment.yaml </em> </strong>:这个 yaml 文件用于创建或修改应用程序的窗格实例。部署文件是一个重要的 kubernetes 资源，它可以扩展副本单元的数量，以可控的方式部署更新的代码，或者在必要时回滚到早期的部署版本。</p></div><div class="ab cl ld le hr lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="ig ih ii ij ik"><p id="88f9" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy mk ka kb kc mm ke kf kg mo ki kj kk kl ig bi translated"><strong class="jq io"> <em class="jp">结论</em> </strong>:在这部分 1 中，我已经分享了<strong class="jq io"> <em class="jp">什么</em>、<em class="jp">为什么</em> </strong>的基础知识以及对掌舵图结构的见解。在下一篇文章第 2 部分中，我将讨论<strong class="jq io"><em class="jp"/></strong>部分，我将分享 kubernetes 生态系统中 helm 的架构，以及用于创建、管理、删除、升级和运行应用程序的 helm 图表的命令，从而涵盖应用程序从准备部署到整个生命周期的所有阶段。请务必阅读下一篇文章，并在下面的评论中让我知道对这篇文章的反馈。感谢你阅读这篇文章。希望对你有帮助。</p></div></div>    
</body>
</html>