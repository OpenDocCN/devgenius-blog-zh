<html>
<head>
<title>Spring Boot Security Configuration, practically explained — Part5: From WebSecurityConfigurerAdapter to SecurityFilterChain</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Spring Boot 安全配置实用讲解第五部分:从 WebSecurityConfigurerAdapter 到 SecurityFilterChain</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/spring-boot-security-configuration-practically-explained-part5-from-bfb87adc1a58?source=collection_archive---------0-----------------------#2022-12-19">https://blog.devgenius.io/spring-boot-security-configuration-practically-explained-part5-from-bfb87adc1a58?source=collection_archive---------0-----------------------#2022-12-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="4e80" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以一种简单易懂的方式，从过时的 WebSecurityConfigurerAdapter 传递到新的基于组件(基于 bean)的安全配置。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/9e8465a34b81bb43452995a5bd952f6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FQuuhA2lK7UWXG4HfRYKBw.png"/></div></div></figure><p id="e2f1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是我关于春季安全系列文章的第五篇。所有以前的帖子都讨论了基于扩展 WebSecurityConfigurerAdapter 的自定义类实现的示例自定义。然而，自从 Spring Security 5 . 7 . 0-M2 之后，广泛使用的 WebSecurityConfigurerAdapter 就不再是这样了，它已经被弃用了。</p><p id="a0a5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，在本文中，我们将看到如何在不使用 WebSecurityConfigurerAdapter 的情况下进行这样的安全定制。大多数情况下，我们将通过一个<strong class="jp ir"> SecurityFilterChain </strong> bean 来讨论<strong class="jp ir">定制安全配置</strong>，以及进一步的定制，例如添加一个<strong class="jp ir">过滤器</strong>和使用一个<strong class="jp ir">基于 DSL 的配置器</strong>。</p><blockquote class="kx ky kz"><p id="ec85" class="jn jo la jp b jq jr js jt ju jv jw jx lb jz ka kb lc kd ke kf ld kh ki kj kk ij bi translated">注意:由于 WebSecurityConfigurerAdapter 被广泛使用，即使没有恼人的警告(黄色下划线),仍然有人可以依赖它。阅读下面关于如何应对的帖子。</p></blockquote><div class="le lf gp gr lg lh"><a href="https://medium.com/@zzpzaf.se/spring-boot-security-the-websecurityconfigureradapter-is-not-the-case-anymore-e8af5cceef7e" rel="noopener follow" target="_blank"><div class="li ab fo"><div class="lj ab lk cl cj ll"><h2 class="bd ir gy z fp lm fr fs ln fu fw ip bi translated">Spring Boot 安全:WebSecurityConfigurerAdapter 不再是这样了</h2><div class="lo l"><h3 class="bd b gy z fp lm fr fs ln fu fw dk translated">当您想要使用最新版本的 Spring Boot 自定义您的安全配置时，请务必小心。</h3></div><div class="lp l"><p class="bd b dl z fp lm fr fs ln fu fw dk translated">medium.com</p></div></div><div class="lq l"><div class="lr l ls lt lu lq lv kv lh"/></div></div></a></div><h1 id="c2ae" class="lw lx iq bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">从 WebSecurityConfigurerAdapter 到 SecurityFilterChain</h1><p id="0261" class="pw-post-body-paragraph jn jo iq jp b jq mu js jt ju mv jw jx jy mw ka kb kc mx ke kf kg my ki kj kk ij bi translated">回到基于<strong class="jp ir">WebSecurityConfigurerAdapter 的抽象类的实现，</strong>回想一下，必须创建一个扩展它的自定义类，因此他/她必须通过覆盖它的两个重要契约方法来工作:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mz"><img src="../Images/ecbbcb9bac646e8e646a0b71f85e19bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*pgZtjwX4g2rpGfcs.png"/></div></div></figure><p id="349d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这两种方法只不过是允许我们定制适合我们项目需求的 Spring Boot 安全性的“<strong class="jp ir">配置器”。</strong></p><p id="d2fa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是一个非常简单的定制示例，用于在 HTTP 基本身份验证的基础上保护 REST API，并且只使用内存中的身份验证提供程序。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="2a40" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">WebSecurityConfigurerAdapter 的两个被覆盖的方法都用于在 Spring 安全上下文中形成必要的<strong class="jp ir">bean</strong>。</p><p id="a7a4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，注意当我们使用 WebSecurityConfigurerAdapter 时，只有 HttpSecurity 配置器必须被覆盖。另一个是 AuthenticationManager 的配置器(它实际上用于配置 AuthenticationManagerBuilder 以构建和返回 AuthenticationManager)，可以作为 bean (通过@Bean 注释的方法)实现<strong class="jp ir">，即使我们使用 WebSecurityConfigurerAdapter。结果绝对是一样的。因此，在前面代码示例的基础上，我们可以这样做:</strong></p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="0546" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">HttpSecurity 配置器负责保护我们的应用程序的 URL 路径和端点。在上面的例子中，我们保护“api/items”端点，我们这样做的方式是使用 HTTP 基本认证标准(通过一对用户名和密码)。</p><p id="7404" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，以@Bean 的形式提供 AuthenticationManager，使其对整个应用程序和任何通过 http 安全性保护的端点都是全局可用的。所以，上面例子中的认证管理器是一个<strong class="jp ir">全局</strong>认证管理器。然而，我们可以使它特定于我们的受保护端点，在这种情况下，它被认为是一个<strong class="jp ir">本地</strong>身份验证管理器。在这种情况下，我们只需“通知”HttpSecurity 配置器使用 bean 方法。为此，我们可以取消上面例子中注释行的注释。我们也可以从 authManager()方法中注释掉@Bean 注释。</p><h2 id="c74b" class="nc lx iq bd ly nd ne dn mc nf ng dp mg jy nh ni mk kc nj nk mo kg nl nm ms nn bi translated">过滤器链</h2><p id="c2cd" class="pw-post-body-paragraph jn jo iq jp b jq mu js jt ju mv jw jx jy mw ka kb kc mx ke kf kg my ki kj kk ij bi translated">Spring 实际处理 HttpSecurity 的方式是通过许多安全过滤器。实际上，它创建了一个安全过滤器链。运行应用程序时，仔细查看调试控制台中的输出:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mz"><img src="../Images/8ed1fff7294babd2692a21a23048c55d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*nZiqN9BA9Pud1r4i.png"/></div></div></figure><p id="a4cc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如您所看到的，Spring 框架接受了我们定制的安全配置中的设置，并将它们放入许多预定义的(默认)安全过滤器中。这些过滤器的列表实际上是由 Spring 管理的过滤器的有序列表，所有这些过滤器组成了一个<a class="ae no" href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/web/DefaultSecurityFilterChain.html" rel="noopener ugc nofollow" target="_blank">DefaultSecurityFilterChain</a>。(你可以在这里找到默认的过滤顺序<a class="ae no" href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/config/annotation/web/builders/HttpSecurity.html#addFilter(jakarta.servlet.Filter)" rel="noopener ugc nofollow" target="_blank">)。</a></p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mz"><img src="../Images/2f6579c0c42d14ed31ccc60079cdbd47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*jCk432eI6H_sSS64.png"/></div></div></figure><p id="2b87" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，Spring 支持的“新”安全方式是使用我们的自定义 http 安全过滤器(在安全过滤器链中)，而不是通过必须扩展 WebSecurityConfigurerAdapter 的类来配置它们。本质上，Spring 允许我们使用 bean 方法配置我们的 HttpSecurity，该方法构建并返回我们自定义的<a class="ae no" href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/web/SecurityFilterChain.html" rel="noopener ugc nofollow" target="_blank"> SecurityFilterChain </a>接口的实现。</p><p id="ae74" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">实际上，使用 SecurityFilterChain bean 并不是一种新方法。它从 Spring Security 的 3.1 版本开始就存在了，并被用来配置一个<a class="ae no" href="https://docs.spring.io/spring-security/reference/servlet/architecture.html#servlet-filterchainproxy" rel="noopener ugc nofollow" target="_blank"> FilterChainProxy </a> bean。(可以更深入的<a class="ae no" href="https://www.javadevjournal.com/spring-security/spring-security-filters/" rel="noopener ugc nofollow" target="_blank">这里</a>和<a class="ae no" href="https://docs.spring.io/spring-security/reference/servlet/architecture.html" rel="noopener ugc nofollow" target="_blank">这里</a>)。因此，人们甚至可以在 WebSecurityConfigurerAdapter 被弃用之前实现它。然而，现在似乎使用 SecurityFilterChain bean 成为官方推荐和支持的唯一方法。</p><p id="c635" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">[注意:由于我们将不再使用废弃的 WebSecurityConfigurerAdapter，您可以删除我们项目的 pom.xml 文件中任何以前版本的“spring-boot-starter-security”依赖项。而且我们可以把“spring-boot-starter-parent”升级到 2.7.6 版本(不是 3.0.0。还没)]。</p><p id="d33b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以在官方文档<a class="ae no" href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/config/annotation/web/builders/HttpSecurity.html#authenticationManager%25org.springframework.security.authentication.AuthenticationManager%29" rel="noopener ugc nofollow" target="_blank">这里</a>中找到实现这种安全过滤链 bean 的简单示例。该示例仅包含两个必需的 beans，一个用于 SecurityFilterChain，另一个提供内存中的 InMemoryUserDetailsManager/UserDetailsService。</p><p id="d599" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是，根据上面的最后一个示例，我们可以创建一个类似于下面的 CustomeSecurityConfiguration 类，这与我们之前所做的没有太大区别:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="d778" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，除了使用单独的 AuthenticationManager 方法作为@Bean 使其全局可用之外，它还允许我们在将来添加更多的身份验证提供者。</p><h1 id="7436" class="lw lx iq bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">将 AuthenticationProvider 与 UserDetailsService 和 PasswordEncoder 一起使用。</h1><p id="f71f" class="pw-post-body-paragraph jn jo iq jp b jq mu js jt ju mv jw jx jy mw ka kb kc mx ke kf kg my ki kj kk ij bi translated">正如您可能已经注意到的，我们没有使用<a class="ae no" href="https://docs.spring.io/spring-security/reference/servlet/authentication/passwords/in-memory.html" rel="noopener ugc nofollow" target="_blank"> inMemoryAuthentication </a>()给出任何用户详细信息，因此，我们还必须使用 UserDetailsService。这避免了我们遇到任何由 Spring Boot 默认设置引起的问题。例如，默认情况下，Spring Security(没有任何安全定制)创建一个 UserDetailsService bean，用户名为“user ”,随机生成的密码记录到控制台。因此，最小定制应该包括一个定制的 UserDetailsService。</p><p id="23c6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，更好的方法是设置一个<a class="ae no" href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/core/userdetails/UserDetailsService.html" rel="noopener ugc nofollow" target="_blank">用户详细信息服务</a>，以及一个<a class="ae no" href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/crypto/password/PasswordEncoder.html" rel="noopener ugc nofollow" target="_blank">密码编码</a>。下面，你可以找到这样一个例子，它使用了一个非常简单的<strong class="jp ir">内存</strong> UserDetailsService。</p><p id="5353" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还使用一个与<a class="ae no" href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/crypto/password/DelegatingPasswordEncoder.html" rel="noopener ugc nofollow" target="_blank">DelegatingPasswordEncoder</a>一起工作的 PasswordEncoder。</p><p id="6373" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里我们使用了已弃用的<a class="ae no" href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/crypto/password/NoOpPasswordEncoder.html" rel="noopener ugc nofollow" target="_blank"> NoOpPasswordEncoder </a>，只是为了<strong class="jp ir">演示</strong>的目的，所以您可以使用注释@SuppressWarnings("deprecated ")来取消警告。</p><p id="ed13" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，虽然可以使用任何<a class="ae no" href="https://docs.spring.io/spring-security/site/docs/6.0.0/api/org/springframework/security/authentication/AuthenticationProvider.html" rel="noopener ugc nofollow" target="_blank"> AuthenticationProvider </a>，但下面的示例使用了广泛使用的<a class="ae no" href="https://docs.spring.io/spring-security/site/docs/6.0.0/api/org/springframework/security/authentication/dao/DaoAuthenticationProvider.html" rel="noopener ugc nofollow" target="_blank">DaoAuthenticationProvider</a>，它接受并可用于 UserdetailsService 和任何 PasswordEncoder 的任何实现。综上所述，下面是整个例子:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="54d6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于最近的 Spring 安全版本提倡开发人员使用 lambdas(实际上是<a class="ae no" href="https://spring.io/blog/2019/11/21/spring-security-lambda-dsl" rel="noopener ugc nofollow" target="_blank"> DSL lambdas </a>)，下面的示例显示了如何使用 lambdas 重写上述 SecurityFilterChain bean 的 http 授权请求:</p><pre class="km kn ko kp gt np nq nr bn ns nt bi"><span id="e2bb" class="nu lx iq nq b be nv nw l nx ny">. . .<br/>        @Bean<br/>        public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {<br/>                http.authorizeRequests((athReqs) -&gt; athReqs.antMatchers("/api/items").hasRole("USER"))<br/>             .httpBasic()<br/>             //.and().authenticationManager(authManager(http))<br/>             ;    <br/>             return http.build();<br/>        }<br/>. . .</span></pre><p id="a580" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">到目前为止，一切顺利。我希望您已经理解了如何以“新的方式”开始实现 Spring Security。<br/>在此找到最终回购<a class="ae no" href="https://github.com/zzpzaf/restapidemo_in-memory_security_FilterChain_bean" rel="noopener ugc nofollow" target="_blank">。</a></p><h2 id="6da0" class="nc lx iq bd ly nd ne dn mc nf ng dp mg jy nh ni mk kc nj nk mo kg nl nm ms nn bi translated">本地身份验证管理器版本</h2><p id="9a59" class="pw-post-body-paragraph jn jo iq jp b jq mu js jt ju mv jw jx jy mw ka kb kc mx ke kf kg my ki kj kk ij bi translated">之前，我们已经讨论了全局和本地身份验证提供者。因此，如果有人想要实现一个<strong class="jp ir">本地</strong>身份验证管理器，下面的代码显示了先前的“CustomSecurityConfiguration”类的更新版本，其中我们将身份验证管理器用作本地身份验证管理器:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="na nb l"/></div></figure><h2 id="c50d" class="nc lx iq bd ly nd ne dn mc nf ng dp mg jy nh ni mk kc nj nk mo kg nl nm ms nn bi translated">附加代码:使用 CustomAuthebticationProvider 的安全配置“新方式”</h2><p id="37f5" class="pw-post-body-paragraph jn jo iq jp b jq mu js jt ju mv jw jx jy mw ka kb kc mx ke kf kg my ki kj kk ij bi translated">在我下面的前一篇文章中，我们使用了 CustomSecurityConfiguration 类来扩展 WebSecurityConfigurerAdapter。</p><div class="le lf gp gr lg lh"><a rel="noopener  ugc nofollow" target="_blank" href="/spring-boot-security-configuration-practically-explained-part4-custom-authentication-provider-7666bea0e13e"><div class="li ab fo"><div class="lj ab lk cl cj ll"><h2 class="bd ir gy z fp lm fr fs ln fu fw ip bi translated">Spring Boot 安全配置，实用讲解—第 4 部分:自定义身份验证提供者…</h2><div class="lo l"><h3 class="bd b gy z fp lm fr fs ln fu fw dk translated">摘要</h3></div><div class="lp l"><p class="bd b dl z fp lm fr fs ln fu fw dk translated">blog.devgenius.io</p></div></div><div class="lq l"><div class="nz l ls lt lu lq lv kv lh"/></div></div></a></div><p id="9073" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，这里的“额外代码”是 CustomSecurityConfiguration 类的更新版本，它遵循 SecurityFilterChain 和 been-only 方法，并且也使用仅带有 lambdas 的函数样式。在下面找到它:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="na nb l"/></div></figure><h1 id="c04b" class="lw lx iq bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">使用基于 DSL 的定制</h1><p id="673d" class="pw-post-body-paragraph jn jo iq jp b jq mu js jt ju mv jw jx jy mw ka kb kc mx ke kf kg my ki kj kk ij bi translated">在这篇文章中，最后但同样重要的一点是关于<a class="ae no" href="https://en.wikipedia.org/wiki/Domain-specific_language" rel="noopener ugc nofollow" target="_blank"> DSL </a>(特定领域语言)以及我们如何使用基于 DSL 的配置器。</p><h2 id="2f21" class="nc lx iq bd ly nd ne dn mc nf ng dp mg jy nh ni mk kc nj nk mo kg nl nm ms nn bi translated">DSL——带 Java 的特定领域语言</h2><p id="0ec5" class="pw-post-body-paragraph jn jo iq jp b jq mu js jt ju mv jw jx jy mw ka kb kc mx ke kf kg my ki kj kk ij bi translated">很可能，一个主要可以处理 DSL 和 Java 的领域是<a class="ae no" href="https://docs.spring.io/spring-integration/docs/current/reference/html/index.html" rel="noopener ugc nofollow" target="_blank"> Spring Integration </a>(例如消息传递)。尽管如此，基于 DSL 的定制似乎也获得了 Spring Security 的一些推广。</p><p id="5afd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一般来说，您应该知道，到目前为止，我们在安全性定制中遇到的 HTTPSecurity 配置器和构建器都是基于遵循 DSL 原则的实现类的。这种基于 DSL 的类通常使用函数式编程风格来调用，使得配置过程更加用户友好，并且更接近人类语言。此外，基于 DSL 的类/配置器允许我们执行的每个定制，通常会导致该配置器的更新实例，从而允许进一步的定制。</p><p id="4cb6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">深入 DSL 概念超出了本文的目标。任何人都可以在网上搜索，找到几十个相关的帖子。只是，为了您的方便，我选择了一些不错的文章，提供实际的例子来开始这个主题。这些是链接:</p><ul class=""><li id="6846" class="oa ob iq jp b jq jr ju jv jy oc kc od kg oe kk of og oh oi bi translated"><a class="ae no" href="https://medium.zenika.com/builder-pattern-a-first-step-to-dsl-1f5645d3ec84" rel="noopener ugc nofollow" target="_blank">https://medium . zenika . com/builder-pattern-a-first-step-to-DSL-1f 5645 d3c 84</a></li><li id="fd7b" class="oa ob iq jp b jq oj ju ok jy ol kc om kg on kk of og oh oi bi translated"><a class="ae no" href="https://medium.com/the-kotlin-primer/domain-specific-languages-867f2790a700" rel="noopener">https://medium . com/the-kot Lin-primer/domain-specific-languages-867 f 2790 a700</a></li><li id="a79a" class="oa ob iq jp b jq oj ju ok jy ol kc om kg on kk of og oh oi bi translated"><a class="ae no" href="https://www.infoworld.com/article/2077891/scripting-jvm-languages-creating-dsls-in-java-part-3-internal-and-external-dsls.html" rel="noopener ugc nofollow" target="_blank">https://www . infoworld . com/article/2077891/scripting-JVM-languages-creating-dsls-in-Java-part-3-internal-and-external-dsls . html</a></li><li id="aaff" class="oa ob iq jp b jq oj ju ok jy ol kc om kg on kk of og oh oi bi translated"><a class="ae no" href="https://www.javacodegeeks.com/2013/06/creating-internal-dsls-in-java-java-8-adopting-martin-fowlers-approach.html" rel="noopener ugc nofollow" target="_blank">https://www . javacodegeeks . com/2013/06/creating-internal-DSL-in-Java-Java-8-adopting-Martin-fowlers-approach . html</a></li></ul><p id="7b61" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在同一主题上，我还想提到一本非常有趣的书“<a class="ae no" href="https://www.manning.com/books/modern-java-in-action" rel="noopener ugc nofollow" target="_blank"> Modern Java in Action Lambdas，streams，functional and reactive programming</a>2018 年第二版，<a class="ae no" href="https://www.manning.com/" rel="noopener ugc nofollow" target="_blank"> Manning </a> publications”，特别是第十章:“使用 Lambdas 的特定领域语言”。</p><p id="8ce6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是，我认为在下面提供一些示例代码是一个好主意。</p><h2 id="0e55" class="nc lx iq bd ly nd ne dn mc nf ng dp mg jy nh ni mk kc nj nk mo kg nl nm ms nn bi translated">我们要做什么</h2><p id="d860" class="pw-post-body-paragraph jn jo iq jp b jq mu js jt ju mv jw jx jy mw ka kb kc mx ke kf kg my ki kj kk ij bi translated">基本上，按照官方示例<a class="ae no" href="https://docs.spring.io/spring-security/reference/servlet/configuration/java.html#jc-custom-dsls" rel="noopener ugc nofollow" target="_blank">这里</a>或<a class="ae no" href="https://spring.io/blog/2022/02/21/spring-security-without-the-websecurityconfigureradapter" rel="noopener ugc nofollow" target="_blank">这里</a>，我们将把我们的自定义配置器(=我们的自定义 DSL 类)应用到 SecurityFilterChain 的 HttpSecurity。作为一个基础，让我们使用我前面提到的帖子的更新回购，基于以前的“奖金代码”。在这里找到回购<a class="ae no" href="https://github.com/zzpzaf/restapidemo_mysql_jdbc-CustomAuthenticationProvider_FilterChain_demo_mysql_start" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="6657" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在继续定制 DSL 类之前，让我们首先制作一个定制的头过滤器。</p><h2 id="a83c" class="nc lx iq bd ly nd ne dn mc nf ng dp mg jy nh ni mk kc nj nk mo kg nl nm ms nn bi translated">自定义标题过滤器</h2><p id="bfc1" class="pw-post-body-paragraph jn jo iq jp b jq mu js jt ju mv jw jx jy mw ka kb kc mx ke kf kg my ki kj kk ij bi translated">正如我们已经说过的，Spring 实际上处理 HttpSecurity 的方式是通过许多安全过滤器。这意味着我们也可以添加自己的过滤器。例如，我们将使用一个定制的过滤器，它将一个定制的头添加到请求的返回响应中，允许我们通过返回的头提供更多的信息。</p><p id="ede4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">运行一个像我们开始的 repo 这样的项目，您可以在终端或调试控制台中看到 DefaultSecurityFilterChain 中应用的所有过滤器，并且您可能会注意到 BasicAuthenticationFilter。</p><pre class="km kn ko kp gt np nq nr bn ns nt bi"><span id="6a2f" class="nu lx iq nq b be nv nw l oo ny">o.s.s.web.DefaultSecurityFilterChain     : Will secure any request with [ <br/>org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter@501760bd, <br/>org.springframework.security.web.context.SecurityContextPersistenceFilter@55a1effd, <br/>org.springframework.security.web.header.HeaderWriterFilter@468057f5, <br/>org.springframework.security.web.csrf.CsrfFilter@2b1cf627, <br/>org.springframework.security.web.authentication.logout.LogoutFilter@330be2b0, <br/>org.springframework.security.web.authentication.www.BasicAuthenticationFilter@2af908d9, &lt;---<br/>org.springframework.security.web.savedrequest.RequestCacheAwareFilter@3050b83d, <br/>org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter@74ab6e3d, <br/>org.springframework.security.web.authentication.AnonymousAuthenticationFilter@5c1a251d, <br/>org.springframework.security.web.session.SessionManagementFilter@19c08f2c, <br/>org.springframework.security.web.access.ExceptionTranslationFilter@2819b1ad, <br/>org.springframework.security.web.access.intercept.FilterSecurityInterceptor@5504d510]</span></pre><p id="97cb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，使用 Postman，您可以查看带有响应的邮件头。在下面的例子中，您可以看到头的数量是 11:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mz"><img src="../Images/d9f715ccd15ab2b12e7fc20f4b659320.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*JmGvZYgpVQswoxNJ.png"/></div></div></figure><p id="734f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">基本上，可以通过实现基本的<a class="ae no" href="https://jakarta.ee/specifications/platform/9/apidocs/jakarta/servlet/filter" rel="noopener ugc nofollow" target="_blank"> Filter </a>接口或者扩展 Spring 提供的一个“现成的”实现类来定制过滤器。在我们的例子中，我们将扩展<a class="ae no" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/filter/GenericFilterBean.html" rel="noopener ugc nofollow" target="_blank"> GenericFilterBean </a>类(它当然实现了过滤器接口)。</p><p id="74d7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">主要工作是通过<strong class="jp ir">覆盖</strong>的<a class="ae no" href="https://jakarta.ee/specifications/platform/9/apidocs/jakarta/servlet/filter#doFilter(jakarta.servlet.ServletRequest,jakarta.servlet.ServletResponse,jakarta.servlet.FilterChain)" rel="noopener ugc nofollow" target="_blank"> doFilter() </a>方法来完成的，在该方法中，我们可以访问<a class="ae no" href="https://jakarta.ee/specifications/platform/9/apidocs/jakarta/servlet/servletrequest" rel="noopener ugc nofollow" target="_blank">请求</a>和<a class="ae no" href="https://jakarta.ee/specifications/platform/9/apidocs/jakarta/servlet/servletresponse" rel="noopener ugc nofollow" target="_blank">响应</a> servlet 对象，以及<a class="ae no" href="https://jakarta.ee/specifications/platform/9/apidocs/jakarta/servlet/filterchain" rel="noopener ugc nofollow" target="_blank">过滤器链</a>对象。因此，这个方法是设置自定义标题的合适位置。让我们将自定义过滤器的类命名为“CustomResponseHeaderFilter”。下面给出了示例代码:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="54ba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下一步是在我们的“CustomSecurityConfiguration”类的 SecurityFilterChain bean 中添加/应用它。我们可以将它添加到与 BasicAuthenticationFilter 相同的排序位置。因此，bean 的代码变成了:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="6e59" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">运行项目后，您可以在终端或调试控制台中检查输出:</p><pre class="km kn ko kp gt np nq nr bn ns nt bi"><span id="3f28" class="nu lx iq nq b be nv nw l oo ny"> o.s.s.web.DefaultSecurityFilterChain     : Will secure any request with [<br/>org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter@38524eae, <br/>org.springframework.security.web.context.SecurityContextPersistenceFilter@53eb7394, <br/>org.springframework.security.web.header.HeaderWriterFilter@31adeeb1, <br/>org.springframework.security.web.csrf.CsrfFilter@13708c79, <br/>org.springframework.security.web.authentication.logout.LogoutFilter@12941fd0, <br/>com.zzpzaf.restapidemo.Configuration.CustomResponseHeaderFilter@62729f4c, &lt;--------<br/>org.springframework.security.web.authentication.www.BasicAuthenticationFilter@7759829b, &lt;---<br/>org.springframework.security.web.savedrequest.RequestCacheAwareFilter@795e0fe5, <br/>org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter@2758be19, <br/>org.springframework.security.web.authentication.AnonymousAuthenticationFilter@4d6b8bf4, <br/>org.springframework.security.web.session.SessionManagementFilter@446f2c24, <br/>org.springframework.security.web.access.ExceptionTranslationFilter@c94d175, <br/>org.springframework.security.web.access.intercept.FilterSecurityInterceptor@cc46e58]</span></pre><p id="f378" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">同样，使用 Postman，您还可以检查我们的自定义标头现在是否已经添加到返回的标头中(现在数量是 12):</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mz"><img src="../Images/b34fe461fbf776951237904ccc466445.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*aEGBn9pmH0Hga4yR.png"/></div></div></figure><p id="345b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好的。我们做到了。现在让我们更进一步，看看我们如何使用一个定制的 DSL 类来做到这一点。</p><p id="3442" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以将自定义 DSL 类命名为“cuctomdslslhttpsecurityconfiguration”。这将是我们自己的定制<strong class="jp ir">配置器</strong>，它应该应用于 SecurityFilterChain bean 中的 HttpSecurity 配置，因此它应该扩展<a class="ae no" href="https://docs.spring.io/spring-security/site/docs/4.2.x/apidocs/org/springframework/security/config/annotation/web/configurers/AbstractHttpConfigurer.html" rel="noopener ugc nofollow" target="_blank"> AbstractHttpConfigurer </a>。</p><p id="718e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">按照官方示例<a class="ae no" href="https://docs.spring.io/spring-security/reference/servlet/configuration/java.html#jc-custom-dsls" rel="noopener ugc nofollow" target="_blank">这里的</a>，我们的定制 DSL 示例代码可以类似于下面的代码:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="2cb7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">主要工作是在 configure()方法中完成的，我们在其中设置并添加了一个过滤器，即 CustomResponseHeaderFilter 类。另外，请注意，我们使用了一个 setter 方法，该方法允许我们向下传递到 CustomResponseHeader 并设置头名称和头值。此外，正如您所看到的，我们使用了另一个 httpSecurity 配置，在 init()方法中使 HTTP 会话无状态。因此，没有必要在 SecurityFilterChain bean 的配置中这样做(就像我们之前所做的那样)。</p><p id="eaa7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们准备将 cuctomdslslhttpsecurityconfigure 类应用于 SecurityFilterChain bean。我们通过简单地“应用”它来做到这一点:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="c92f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">暂时就这样吧！<br/>你可以在这里找到最终回购<a class="ae no" href="https://github.com/zzpzaf/restapidemo_mysql_jdbc-CustomAuthenticationProvider_FilterChain_demo_mysql_final" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="25f1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我希望我能够让您对从 WebSecurityConfigurerAdapter 迁移到 SecurityFilterChain 有所了解，并体验如何使用自定义过滤器和基于 DSL 的自定义配置器。</p><p id="3d08" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">感谢阅读👏！敬请关注！</p></div></div>    
</body>
</html>