<html>
<head>
<title>How to speed up concurrent go routines with mutex by upto 50% ?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用互斥体将并发围棋例程的速度提高 50%？</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-to-speed-up-concurrent-go-routines-with-mutex-by-upto-50-51863bfbea8d?source=collection_archive---------1-----------------------#2022-11-11">https://blog.devgenius.io/how-to-speed-up-concurrent-go-routines-with-mutex-by-upto-50-51863bfbea8d?source=collection_archive---------1-----------------------#2022-11-11</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="53d9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们将讨论如何使用 RWMutex 而不是 Mutex 来大大提高性能。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3b8c9bcf2edba916b28a4da6cb5c8be1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MeQPWqy3H3CsxwssvrKOKw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图简介(制作于 draw.io，photopea)</figcaption></figure><h1 id="375a" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">介绍</h1><p id="2e90" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">多个线程同时访问同一个内存是不可取的。在 Golang 中，我们可以有几个不同的 goroutines，它们都可能访问相同的内存变量，这可能会导致竞争情况。互斥，互斥，以及等待组来避免竞争情况。可以使用 golang 的 Mutex 和 RWmutex。</p><h1 id="7364" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">互斥 v/s rw 互斥</h1><p id="6fa6" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">第一个中的互斥量是八个字节。RWMutex 是二十四个字节。来自<a class="ae mb" href="https://pkg.go.dev/sync#RWMutex" rel="noopener ugc nofollow" target="_blank">官方文档</a>:<em class="mc">rw mutex 是一个读/写互斥锁。锁可以由任意数量的读取器或单个写入器持有。RWMutex 的零值是一个解锁的互斥体</em>。</p><pre class="kj kk kl km gt md me mf mg aw mh bi"><span id="a55c" class="mi kz in me b gy mj mk l ml mm">// Mutex v/s RWMutex</span><span id="ef0d" class="mi kz in me b gy mn mk l ml mm">//Mutex<br/>type Mutex struct {<br/>    state int32<br/>    sema  uint32<br/>}</span><span id="f5e1" class="mi kz in me b gy mn mk l ml mm">// RWMutex </span><span id="f664" class="mi kz in me b gy mn mk l ml mm">type RWMutex struct {<br/>    w           Mutex  // held if there are pending writers<br/>    writerSem   uint32 // semaphore for writers to wait for completing readers<br/>    readerSem   uint32 // semaphore for readers to wait for completing writers<br/>    readerCount int32  // number of pending readers<br/>    readerWait  int32  // number of departing readers<br/>}</span></pre><p id="bad8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">简而言之，读者不需要彼此等待。他们只需要等待持有锁的作者。由于 just reading 函数不会改变文件内容，因此允许许多读者同时读取同一个文件以提高程序的性能是可以接受的。但是写改变了文件的内容，互斥访问是必需的；否则，就会出现过大的错误。同步。因此，RWMutex 适用于大量读取数据，并且通过同步节省了资源。互斥是时间。</p><p id="4b25" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">由 RWMutex 保护的每个写操作都是 O(readers)。</p><h1 id="73cc" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">标杆管理</h1><p id="5350" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">代码在采用英特尔 i5 芯片的 windows 系统上运行 10 次，性能作为完成并发读写操作的平均值。</p><p id="b3c1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">代码和输出:</p><pre class="kj kk kl km gt md me mf mg aw mh bi"><span id="8285" class="mi kz in me b gy mj mk l ml mm">package main</span><span id="f873" class="mi kz in me b gy mn mk l ml mm">import (<br/> "fmt"<br/> "math/rand"<br/> "sync"<br/> "time"<br/> //"os"<br/>)</span><span id="6991" class="mi kz in me b gy mn mk l ml mm">var a float64 = 0.0<br/>var b float64 = 0.0</span><span id="8438" class="mi kz in me b gy mn mk l ml mm">func done() {<br/> r := rand.New(rand.NewSource(99))<br/> lst1 := []int{}<br/> lst2 := []int{}<br/> lock1 := sync.Mutex{}<br/> lock2 := sync.RWMutex{}<br/> wtgrp1 := sync.WaitGroup{}<br/> wtgrp2 := sync.WaitGroup{}</span><span id="b76d" class="mi kz in me b gy mn mk l ml mm">for i := 0; i &lt; 10; i++ {<br/>  lst1 = append(lst1, i)<br/>  lst2 = append(lst2, i)<br/> }</span><span id="1acb" class="mi kz in me b gy mn mk l ml mm">// 1. spawn 1000 goroutines and synchronize through locks<br/> now1 := time.Now()<br/> for i := 0; i &lt; 1000; i++ {<br/>  wtgrp1.Add(1)<br/>  pos := r.Intn(10)<br/>  go func() {<br/>   defer wtgrp1.Done()<br/>   lock1.Lock()<br/>   defer lock1.Unlock()<br/>   goLst := []int{} // goLst, destroy automatically<br/>   // Process each element of lst1 randomly<br/>   for j := 0; j &lt; 1000; j++ {<br/>    goLst = append(goLst, lst1[pos])<br/>   }<br/>  }()<br/> }<br/> wtgrp1.Wait()<br/> diff1 := time.Now().Sub(now1)</span><span id="0feb" class="mi kz in me b gy mn mk l ml mm">// 2. spawn 1000 goroutines and synchronize through read-write locks<br/> now2 := time.Now()<br/> for i := 0; i &lt; 1000; i++ {<br/>  wtgrp2.Add(1)<br/>  pos := r.Intn(10)<br/>  go func() {<br/>   defer wtgrp2.Done()<br/>   lock2.RLock()<br/>   defer lock2.RUnlock()<br/>   goLst := []int{} // goLst, destroy automatically<br/>   // Process each element of lst2 randomly<br/>   for j := 0; j &lt; 1000; j++ {<br/>    goLst = append(goLst, lst1[pos])<br/>   }<br/>  }()<br/> }<br/> wtgrp2.Wait()<br/> diff2 := time.Now().Sub(now2)<br/> fmt.Println(diff1, "  ", diff2)<br/> a = a + float64(diff1)<br/> b = b + float64(diff2)</span><span id="d54e" class="mi kz in me b gy mn mk l ml mm">}</span><span id="72b4" class="mi kz in me b gy mn mk l ml mm">func main() {<br/> fmt.Println("Mutex   RWMutex")<br/> for i := 0; i &lt; 10; i++ {<br/>  done()<br/>  time.Sleep(2 * time.Second)<br/> }<br/> fmt.Println(a, "  ", b)<br/> fmt.Println(b / a)<br/> fmt.Println("Faster by : ", ((a-b)*100)/a, " %")</span><span id="4709" class="mi kz in me b gy mn mk l ml mm">}</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/5fd0a1bf9c4925b1d20c976db34c17da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/1*q56fBjpOTWYgBF7IoB5onw.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图一。Windows PC 上的输出</figcaption></figure><h1 id="5b41" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated"><strong class="ak">总而言之……</strong></h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/0c8a1b6c375547a2bcd7a653f3e7d702.png" data-original-src="https://miro.medium.com/v2/resize:fit:1380/format:webp/1*CpFaxp-di0poCwsZU2XqlQ.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图二。流程图</figcaption></figure><p id="7737" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当我们只有一个写入者时，RWmutex 应该用于等待组，以改变共享内存和多个读取者。</p></div></div>    
</body>
</html>