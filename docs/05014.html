<html>
<head>
<title>Writing Asynchronous Non-Blocking Rest API using JAVA.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 JAVA 编写异步非阻塞 Rest API。</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/writing-asynchronous-non-blocking-rest-api-using-java-a9ec54ecb243?source=collection_archive---------1-----------------------#2021-06-03">https://blog.devgenius.io/writing-asynchronous-non-blocking-rest-api-using-java-a9ec54ecb243?source=collection_archive---------1-----------------------#2021-06-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="6314" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">处理大流量，提高应用程序性能和响应能力</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/4edbec6be267c0bb82c7e3ad3c31c6ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P6Yg5mlQcNmi1vtQCpkyVg.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">图片来源—<a class="ae kv" href="http://www.pexels.com" rel="noopener ugc nofollow" target="_blank">www.pexels.com</a></figcaption></figure><p id="c034" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在来自客户端的 API 调用期间，服务器创建并分配该请求的线程。该线程等待并被指定，直到请求被提供给该客户端。<br/>每个服务器可以打开有限数量的线程，如果该数量超过，那么新的客户端请求将存储在该服务器的请求队列中。<br/>对于 Tomcat 服务器，它的默认线程数<code class="fe ls lt lu lv b">maxThreads </code>是 200，代表在任何给定时间允许运行的最大并发线程数。<br/>还有其他指标<code class="fe ls lt lu lv b">maxConnections</code>，表示服务器将接受和处理的并发连接的总数。任何额外的传入连接将被放置在队列中，直到有线程可用。<code class="fe ls lt lu lv b">NIO/NIO2</code>模式的默认值是 10000，<code class="fe ls lt lu lv b">APR/Native</code>是 8192。</p><p id="bc75" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一个指标是<code class="fe ls lt lu lv b">acceptCount</code>，它表示当没有可用的工作线程时，可以在操作系统级别的队列中等待的 TCP 请求的最大数量。默认值为 100。</p><p id="8b15" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于一个高流量的应用程序，如果一个请求需要很长时间，或者需要很长时间来服务，就会产生很大的问题。为了克服这个线程管理问题，我们可以使用异步编程。</p><p id="11e8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">根据<a class="ae kv" href="https://visualstudiomagazine.com/articles/2011/03/24/wccsp_asynchronous-programming.aspx#:~:text=Asynchronous%20programming%20is%20a%20means,its%20completion%2C%20failure%20or%20progress." rel="noopener ugc nofollow" target="_blank">visualstudiomagazine.com</a>，异步编程的定义是</p><blockquote class="lw"><p id="a043" class="lx ly iq bd lz ma mb mc md me mf lr dk translated">异步编程是并行编程的一种方式，其中一个工作单元独立于主应用程序线程运行，并通知调用线程其完成、失败或进度。</p></blockquote><h1 id="85c0" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">同步应用程序如何产生问题？</h1><p id="a441" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">对于同步应用程序，在请求过程中会产生什么问题？让我们来解决这个问题。下面是请求流程:</p><ul class=""><li id="c3e2" class="nd ne iq ky b kz la lc ld lf nf lj ng ln nh lr ni nj nk nl bi translated">请求通过一个监听端口到达 tomcat 服务器。Tomcat 服务器有其内部服务器配置，如<code class="fe ls lt lu lv b">maxThreads</code>、<code class="fe ls lt lu lv b">maxConnections</code>等。如果服务器当前超过了最大线程值，那么请求将在队列中等待。</li><li id="f310" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated">现在，服务器将该请求传递给应用程序，这意味着服务器为该请求分配一个新线程，并将该请求传递给应用程序。该线程一直等待，直到请求得到满足。</li><li id="55f6" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated">如果 API 花费了很长时间，那么该线程将等待它的响应。这里，tomcat 拥有 bt 默认 200 个线程，因此它一次最多可以服务 200 个请求。在这种情况下，客户端在 API 调用期间将面临严重的延迟。</li></ul><p id="ca0a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">今天我们将讨论如何使用<code class="fe ls lt lu lv b">CompletableFuture</code>来编写异步 REST API，以使 tomcat 自由地克服线程溢出问题？</p><p id="636e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要了解术语<code class="fe ls lt lu lv b">CompletableFuture</code>的详细内容，您可以查看<a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/details-implementation-of-java-asynchronous-programming-using-completable-future-949826bac6f3">这篇文章</a></p><h1 id="31c1" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw nr jx ms jz ns ka mu kc nt kd mw mx bi translated"><code class="fe ls lt lu lv b">CompletableFuture</code>用于异步编程</h1><p id="fb98" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">为了解决这个问题，您可以使用。<code class="fe ls lt lu lv b">CompletableFuture</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="a73d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们在这里做什么？我们正在做以下事情:</p><ul class=""><li id="7674" class="nd ne iq ky b kz la lc ld lf nf lj ng ln nh lr ni nj nk nl bi translated">简单端点是一个简单的<code class="fe ls lt lu lv b">GET</code>方法，它的返回类型是<code class="fe ls lt lu lv b">CompletableFuture&lt;String&gt;</code></li><li id="9a28" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated">在处理请求的过程中，它只是调用了方法<code class="fe ls lt lu lv b">processRequest</code>，其中只有一个<code class="fe ls lt lu lv b">Thread.sleep</code>持续了 10s。</li><li id="6333" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated">这两种方法都有一个进入和退出日志。</li></ul><p id="237b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从 browser/postman 调用端点后，它会在 10 秒后发送一个响应。下面给出了这个 API 调用的日志。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/852450671bfeae427b27047b0ac07e7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DNdgS3OSsNB126LPB_CYLQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">图片来源—作者</figcaption></figure><p id="82e7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里，</p><ul class=""><li id="2c03" class="nd ne iq ky b kz la lc ld lf nf lj ng ln nh lr ni nj nk nl bi translated">日志的第一行和第二行显示在<code class="fe ls lt lu lv b">nio-8080-exec-8</code>螺纹下。它还显示收到的请求和释放的 servlet 线程。这个线程来自非阻塞 IO，来自嵌入式服务器。</li><li id="74f4" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated">从日志的前 2 行可以看出，它是在执行<code class="fe ls lt lu lv b">CompletableFuture</code>部分下的<code class="fe ls lt lu lv b">processRequest</code>方法部分之前释放的。</li><li id="6aa5" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated">日志的最后两行用于<code class="fe ls lt lu lv b">CompletableFuture</code>零件。它正在处理<code class="fe ls lt lu lv b">onPool-worker-2</code>下的线程。这意味着它与 tomcat 线程是分开的，而这个线程来自 Spring。<code class="fe ls lt lu lv b">ForkJoinPool</code>。</li></ul><h1 id="c3ea" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw nr jx ms jz ns ka mu kc nt kd mw mx bi translated">思想的总结</h1><ul class=""><li id="b2bf" class="nd ne iq ky b kz my lc mz lf nx lj ny ln nz lr ni nj nk nl bi translated">Tomcat 服务器在收到客户端的调用后将请求传递给应用程序。</li><li id="859d" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated">应用程序通过<code class="fe ls lt lu lv b">CompletableFuture</code>将该任务分配给另一个线程。这个线程负责执行这个分配的任务，并通过 tomcat 连接响应客户端。</li><li id="5233" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated">应用程序立即释放 tomcat 分配的线程。这个被释放的线程将返回到 tomcat 线程池，并准备好服务新的 API 请求。</li><li id="62e3" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated">有了这种机制，tomcat 现在可以处理大流量。</li><li id="7234" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated">我们可以通过修改 tomcat <code class="fe ls lt lu lv b">server.xml</code>文件来接受更多的请求。</li></ul><p id="de21" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以微调<code class="fe ls lt lu lv b">server.xml</code>文件，使其能够处理大量的传入流量。这种微调是基于我们的服务器资源，如处理器能力、内核数量、RAM 等。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">代码致谢—作者</figcaption></figure><h1 id="7800" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw nr jx ms jz ns ka mu kc nt kd mw mx bi translated">最后的想法</h1><p id="9e08" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">为了减少服务器线程等待时间，您可以应用异步 API。此外，您可以尝试延迟结果或 Spring WebFlux。</p><p id="6878" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要写一个安全的 REST API，你可以看看这篇文章。</p></div></div>    
</body>
</html>