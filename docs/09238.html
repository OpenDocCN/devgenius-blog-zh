<html>
<head>
<title>Make the Labeled Range Slider interactive</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使带标签的范围滑块具有交互性</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/make-the-labeled-range-slider-interactive-516bdf6e5c25?source=collection_archive---------10-----------------------#2022-08-08">https://blog.devgenius.io/make-the-labeled-range-slider-interactive-516bdf6e5c25?source=collection_archive---------10-----------------------#2022-08-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/dc436567c47d58f491a1971aa14f079e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*nrSiVrstPhEjDM1H"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">Elia Pellegrini 在<a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="4210" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们<a class="ae jz" href="https://medium.com/@alex.frank84/draw-the-labeled-range-slider-3eb96e748e88" rel="noopener">创造了一个好看的 UI </a>，但是目前它还没什么用。我们仍然没有办法与它互动。让我们解决这个问题。</p><p id="478d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们的触摸手柄应该可以在工具栏上拖动，当点击它时可以立即定位，当交互完成时可以捕捉到最近的值。</p><h1 id="168a" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">移动它</h1><p id="cb66" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">在本系列的第 2 部分<a class="ae jz" href="https://betterprogramming.pub/touch-interactions-in-jetpack-compose-caf88adcae61" rel="noopener ugc nofollow" target="_blank">中，我们看到了如何使用手势检测器。我们可以使用<strong class="kc io">检测手势</strong>和<strong class="kc io">检测手势</strong>来实现这一点。但是，由于我们想在点击或拖动时做或多或少相同的事情，将手柄定位到触摸点，我们可以使用简单提到的<strong class="kc io"> awaitPointerEventScope </strong>来实现一个更灵活、更合适的触摸处理程序。</a></p><p id="ac1f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们可以将感兴趣的触摸状态定义为一个密封类。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="4312" class="mk kz in mg b gy ml mm l mn mo">sealed class TouchInteraction {<br/>    object NoInteraction : TouchInteraction()<br/>    object Up : TouchInteraction()<br/>    data class Move(val position: Offset) : TouchInteraction()<br/>}</span></pre><p id="8082" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对于我们来说，知道当前是否没有交互，应该将句柄移动到某个位置，并且用户举起了他们的手指就足够了。</p><p id="8cc2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后使用<strong class="kc io">指针输入</strong>修改器实现我们的触摸处理程序。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="894d" class="mk kz in mg b gy ml mm l mn mo">fun Modifier.touchInteraction(key: Any, block: (TouchInteraction) -&gt; Unit): Modifier =<br/>    pointerInput(key) {<br/>        forEachGesture {<br/>            awaitPointerEventScope {<br/>                do {<br/>                    val event: PointerEvent = awaitPointerEvent()</span><span id="b863" class="mk kz in mg b gy mp mm l mn mo">                    event.changes<br/>                        .forEach { pointerInputChange: PointerInputChange -&gt;<br/>                            if (pointerInputChange.positionChange() != Offset.Zero) pointerInputChange.consume()<br/>                        }</span><span id="d29a" class="mk kz in mg b gy mp mm l mn mo">                    block(TouchInteraction.Move(event.changes.first().position))<br/>                } while (event.changes.any { it.pressed })</span><span id="8c35" class="mk kz in mg b gy mp mm l mn mo">                block(TouchInteraction.Up)<br/>            }<br/>        }<br/>    }</span></pre><p id="07fc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们等待用户使用<strong class="kc io"> awaitPointerEventScope </strong>的触摸输入，当我们得到一个时，我们知道用户现在正在与我们标记的范围滑块交互。我们迭代事件，只要用户的手指停留在我们的可组合组件上，我们就获得事件的绝对位置，并将其作为<strong class="kc io"> TouchInteraction 传递。动</strong>事件自己动手。用户一抬起手指，我们就用<strong class="kc io"> TouchInteraction 来响应。向上</strong>让我们的用户界面有机会通过将手柄弹到最近的一步来做出反应。</p><p id="ad78" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在我们的 Composable 中，我们将<strong class="kc io">修饰符</strong>添加到画布中，添加三个状态变量来跟踪当前的交互状态，并添加逻辑来更新句柄的位置。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="6ade" class="mk kz in mg b gy ml mm l mn mo">var touchInteractionState by remember { mutableStateOf&lt;TouchInteraction&gt;(TouchInteraction.NoInteraction) }<br/>var moveLeft by remember { mutableStateOf(false) }<br/>var moveRight by remember { mutableStateOf(false) }<br/>...</span><span id="c53c" class="mk kz in mg b gy mp mm l mn mo">Canvas(<br/>    modifier = modifier<br/>        .touchInteraction(remember { MutableInteractionSource() }) {<br/>            touchInteractionState = it<br/>        }<br/>) {<br/>    ...<br/>}</span><span id="7726" class="mk kz in mg b gy mp mm l mn mo">when (val touchInteraction = touchInteractionState) {<br/>    is TouchInteraction.Move -&gt; {<br/>        val touchPositionX = touchInteraction.position.x<br/>        if (abs(touchPositionX - leftCirclePosition.x) &lt; abs(touchPositionX - rightCirclePosition.x)) {<br/>            leftCirclePosition = calculateNewLeftCirclePosition(touchPositionX, leftCirclePosition, rightCirclePosition, stepSpacing, stepXCoordinates.first())<br/>            moveLeft = true<br/>        } else {<br/>            rightCirclePosition = calculateNewRightCirclePosition(touchPositionX, leftCirclePosition, rightCirclePosition, stepSpacing, stepXCoordinates.last())<br/>            moveRight = true<br/>        }<br/>    }<br/>    is TouchInteraction.Up   -&gt; {<br/>        moveLeft = false<br/>        moveRight = false<br/>        touchInteractionState = TouchInteraction.NoInteraction<br/>    }<br/>    else                     -&gt; {<br/>        // nothing to do<br/>    }<br/>}</span></pre><p id="8f65" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们需要知道移动哪个把手。为此，我们查看触摸交互的 x 位置，计算左右手柄之间的距离，并移动交互最接近的手柄。当计算把手的新位置时，我们需要考虑把手不应该离开杆，并且两个把手在移动时不应该重叠。为了使它更清楚，让我们快速地看一下左手柄的更新位置的计算。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="1ad8" class="mk kz in mg b gy ml mm l mn mo">private fun calculateNewLeftCirclePosition(<br/>    touchPositionX: Float,<br/>    leftCirclePosition: Offset,<br/>    rightCirclePosition: Offset,<br/>    stepSpacing: Float,<br/>    firstStepXPosition: Float<br/>): Offset = when {<br/>    touchPositionX &lt; firstStepXPosition                    -&gt; leftCirclePosition.copy(x = firstStepXPosition)<br/>    touchPositionX &gt; (rightCirclePosition.x - stepSpacing) -&gt; leftCirclePosition<br/>    else                                                   -&gt; leftCirclePosition.copy(x = touchPositionX)<br/>}</span></pre><p id="a996" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们可以看到，根据触摸位置、另一个手柄的位置和步长的间距，以及本例中第一步的位置，我们可以计算出左手柄可以拥有的新位置。</p><figure class="mb mc md me gt jo gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/cd04c22879a8a3a98d73d2cf0b77032c.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/0*Yh5llxVOnanpeYBs.gif"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">带标签的范围滑块仍然缺少“吸附到值”功能</figcaption></figure><p id="30f4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">触摸滑块时手柄会移动，我们可以点击手柄立即跳转到的位置，我们甚至可以在两个手柄之间移动，而无需抬起手指。</p><h1 id="ea70" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">赶快</h1><p id="b3dc" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">手柄还没有达到我们想要的效果。在用户抬起手指后，以及当受控手柄改变时，它们应该捕捉到最近的步骤。为了实现这一点，我们更新了我们的触摸交互逻辑，找到最近的步长及其 x 坐标，并相应地更新手柄位置。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="eba7" class="mk kz in mg b gy ml mm l mn mo">is TouchInteraction.Move -&gt; {<br/>    val touchPositionX = touchInteraction.position.x<br/>    if (abs(touchPositionX - leftCirclePosition.x) &lt; abs(touchPositionX - rightCirclePosition.x)) {<br/>        leftCirclePosition = calculateNewLeftCirclePosition(touchPositionX, leftCirclePosition, rightCirclePosition, stepSpacing, stepXCoordinates.first())<br/>        moveLeft = true</span><span id="12c9" class="mk kz in mg b gy mp mm l mn mo">        if (moveRight) {<br/>            val (closestRightValue, _) = stepXCoordinates.getClosestNumber(rightCirclePosition.x)<br/>            rightCirclePosition = rightCirclePosition.copy(x = closestRightValue)<br/>            moveRight = false<br/>        }<br/>    } else {<br/>        rightCirclePosition = calculateNewRightCirclePosition(touchPositionX, leftCirclePosition, rightCirclePosition, stepSpacing, stepXCoordinates.last())<br/>        moveRight = true</span><span id="a0da" class="mk kz in mg b gy mp mm l mn mo">        if (moveLeft) {<br/>            val (closestRightValue, _) = stepXCoordinates.getClosestNumber(leftCirclePosition.x)<br/>            leftCirclePosition = leftCirclePosition.copy(x = closestRightValue)<br/>            moveLeft = false<br/>        }<br/>    }<br/>}<br/>is TouchInteraction.Up   -&gt; {<br/>    val (closestLeftValue, closestLeftIndex) = stepXCoordinates.getClosestNumber(leftCirclePosition.x)<br/>    val (closestRightValue, closestRightIndex) = stepXCoordinates.getClosestNumber(rightCirclePosition.x)<br/>    if (moveLeft) {<br/>        leftCirclePosition = leftCirclePosition.copy(x = closestLeftValue)<br/>        moveLeft = false<br/>    } else if (moveRight) {<br/>        rightCirclePosition = rightCirclePosition.copy(x = closestRightValue)<br/>        moveRight = false<br/>    }<br/>    touchInteractionState = TouchInteraction.NoInteraction<br/>}</span></pre><figure class="mb mc md me gt jo gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/41b3b125c0049f56ef94cd100dae13d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/0*BI8YQGiQY-AtZW8g.gif"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">带标签的范围滑块</figcaption></figure><p id="bd1a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，这看起来已经是我们想要达到的最终结果了:-)。但是还缺少一个小细节:我们仍然需要将更新后的范围反馈给调用者，这样他们就可以对此做出反应；-).</p><p id="6461" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这最后一步现在相当容易。我们将回调<strong class="kc io"> onRangeChanged </strong>作为参数添加到我们的 Composable 中。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="ad15" class="mk kz in mg b gy ml mm l mn mo">@Composable<br/>fun &lt;T : Number&gt; LabeledRangeSlider(<br/>    selectedLowerBound: T,<br/>    selectedUpperBound: T,<br/>    steps: List&lt;T&gt;,<br/>    onRangeChanged: (lower: T, upper: T) -&gt; Unit,<br/>    modifier: Modifier = Modifier,<br/>    sliderConfig: SliderConfig = SliderConfig()<br/>)</span></pre><p id="b341" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">并且每当用户用所选步骤的值抬起手指时简单地调用它。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="a7df" class="mk kz in mg b gy ml mm l mn mo">is TouchInteraction.Up   -&gt; {<br/>    val (closestLeftValue, closestLeftIndex) = stepXCoordinates.getClosestNumber(leftCirclePosition.x)<br/>    val (closestRightValue, closestRightIndex) = stepXCoordinates.getClosestNumber(rightCirclePosition.x)<br/>    if (moveLeft) {<br/>        leftCirclePosition = leftCirclePosition.copy(x = closestLeftValue)<br/>        onRangeChanged(steps[closestLeftIndex], steps[closestRightIndex])<br/>        moveLeft = false<br/>    } else if (moveRight) {<br/>        rightCirclePosition = rightCirclePosition.copy(x = closestRightValue)<br/>        onRangeChanged(steps[closestLeftIndex], steps[closestRightIndex])<br/>        moveRight = false<br/>    }<br/>    touchInteractionState = TouchInteraction.NoInteraction<br/>}</span></pre><h1 id="651d" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">结论</h1><figure class="mb mc md me gt jo gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/7c2a10f07208724353eba69cad9982cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/0*orgZ_qhEuVHsrmSg.gif"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">带有所选值表示的最终带标签的范围滑块</figcaption></figure><p id="7d60" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们做到了🎉。我们从头开始创建了我们自己的带标签的范围滑块，画出了我们自己需要的所有东西，并使它与各自的<strong class="kc io">修改器</strong> 🥳.交互</p><p id="d164" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">标签范围滑块的完整源代码可以在<a class="ae jz" href="https://github.com/a-frank/labeled-range-slider" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到。</p><p id="9b76" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我希望您喜欢阅读这个系列，并获得一些有益的启发:-)。</p></div></div>    
</body>
</html>