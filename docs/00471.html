<html>
<head>
<title>EKF for autonomous vehicles with outlier handling</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">具有异常处理的自主车辆的EKF</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/ekf-for-autonomous-vehicles-with-outlier-handling-d169dbae1949?source=collection_archive---------21-----------------------#2020-06-08">https://blog.devgenius.io/ekf-for-autonomous-vehicles-with-outlier-handling-d169dbae1949?source=collection_archive---------21-----------------------#2020-06-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/46e2d5bf53bdbd9975cd33bfde55b58a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3ZmbKu71Gw78i5-4"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">凯文·Ku在<a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="4e41" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">多亏了新冠肺炎，我所有的实习机会都没有了，给了我相当多的空闲时间。与此同时，Udacity为他们的自动驾驶汽车纳米学位项目提供了一个月的试用，所以我自然报名了。作为一名研究生，我熟悉该课程的大多数理论方面(尤其是估计和控制)，所以我想尝试使用C++(这在业界很常见)在良好的模拟器上实现一些东西，而不是我在大多数学术工作中使用的Matlab。</p><p id="8bb6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所以我选择从扩展卡尔曼滤波项目开始。由于有很多关于基本实现的帖子，为了简洁起见，我不会在这篇帖子中包括它们。这是香草EKF的样子:</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="ffc3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如你所见，性能相当不错。我们怎样才能做得更好？仔细观察表明，来自传感器的数据是不一致的。雷达上的蓝点比我们喜欢的分散得多。一种方法是完全消除异常值，即如果我们发现传感器读数对应于远离我们预测的估计值的点，我们跳过更新步骤，有效地丢弃截止值。从数学角度来说，我对创新的标准进行了限制。只有内曲线用于更新状态估计:5(激光新息范数截止)和2.7(雷达范数截止)</p><p id="8aad" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">以下是它们在Udacity提供的两个模拟实例上的性能:</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="lc ld l"/></div></figure><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="09db" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然而，这种方法的一个警告是，它假设汽车将遵循的轨迹知识，允许我们优化截止点，以产生最小的误差值。这在现实生活中很少可能，所以我想让算法“适应”传感器波动，并相应地调整其截止值。在谷歌搜索了一番后，我发现了一个叫做<a class="ae jz" href="https://arxiv.org/pdf/1904.00335" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io">创新饱和</strong> </a>的想法。在这里，他们的创新被限制在一定的范围内，而不是完全忽略假定的错误测量。这些饱和界限随着系统的发展而动态变化。考虑系统的以下状态空间模型:</p><figure class="ky kz la lb gt jo gh gi paragraph-image"><div class="gh gi le"><img src="../Images/f86fae384eba5e4b5854d83df98eb63c.png" data-original-src="https://miro.medium.com/v2/resize:fit:576/format:webp/1*t8lsgvgU9phP11Uoj0tI-g.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">假设一个线性系统。如果系统是非线性的，则使用近似线性模型</figcaption></figure><p id="09c1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对于这个系统，通常的KF方程稍微调整如下:</p><figure class="ky kz la lb gt jo gh gi paragraph-image"><div class="gh gi lf"><img src="../Images/b57f9e6340f9115e910b061fe2b14615.png" data-original-src="https://miro.medium.com/v2/resize:fit:1066/format:webp/1*Pg5dgUsSWW6aumSI9jGGow.png"/></div></figure><p id="9b5a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">注意更新方程式(上图第三个)。创新有一个术语“sat”。它是饱和函数，定义如下:</p><figure class="ky kz la lb gt jo gh gi paragraph-image"><div class="gh gi lg"><img src="../Images/f713cead1d9ad039b28a85fe94827d83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1016/format:webp/1*Yb4RoSOQyxCtZReWRTnUEw.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">饱和度限制了+-sqrt(σ_i)之间的值</figcaption></figure><p id="716d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对于每个I，饱和界限(σ)更新如下:</p><figure class="ky kz la lb gt jo gh gi paragraph-image"><div class="gh gi lh"><img src="../Images/08d019defa4fc91d51bb602beef642fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1134/format:webp/1*SqOqh3ZOltupX6fwqeSRbg.png"/></div></figure><p id="6cc2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">尽管它的稳定性的证明在数学上非常复杂(我们已经受够了！)，我尽量提供一个直观的理解。根据更新方程的性质，如果传感器偏差非常接近界限，界限将变得更窄。否则，他们会扩张。这种行为将继续，直到边界收敛到合理的数量。</p><p id="02ac" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">下面演示了后一种方法在Udacity模拟器中的行为。</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="lc ld l"/></div></figure><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="c976" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">请注意，在第一个数据集中，就在一开始，有一个读数导致汽车错误判断其位置。在朴素的离群值过滤中，由于调整了截止值，这一问题得到了解决。在第二种方法中，问题仍然存在。这是因为，我们的<strong class="kc io">初始估计是不可靠的</strong>，可能会偏离实际状态。因此，我们期待大的创新，并因此将饱和界限初始化为非常高的值。随着时间的推移，它们会自动收敛。在第二个数据集中，第二个算法表现更好，因为它更好地了解了使用什么创新来更新估计值。</p><p id="c050" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">关于代码结构的注释。最初的代码结构无法使用多个EKF实现。所以我从最初的KF类派生出了一个新的KF类。我修改了FusionEKF代码，以接受将要使用的KF实现的模板。这是<strong class="kc io">多态</strong>的一个例子，多态是<strong class="kc io"> OOP </strong>范例的核心原则。</p><p id="234d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果你喜欢它，请留下掌声或评论。谢谢！</p><p id="9fdc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Github链接:<a class="ae jz" href="https://github.com/laukikm/CarND-Extended-Kalman-Filter-Project" rel="noopener ugc nofollow" target="_blank">https://github . com/lau kikm/CarND-Extended-Kalman-Filter-Project</a></p></div></div>    
</body>
</html>