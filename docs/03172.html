<html>
<head>
<title>Git and GitHub for Aspiring Data Scientist</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向有抱负的数据科学家的 Git 和 GitHub</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/git-and-github-for-aspiring-data-scientist-ec68fca94e9b?source=collection_archive---------4-----------------------#2020-10-07">https://blog.devgenius.io/git-and-github-for-aspiring-data-scientist-ec68fca94e9b?source=collection_archive---------4-----------------------#2020-10-07</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/55bd50fada12f87c871fbdd5466b54f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RpdCB8ssHVk6dpHL31rKbA.jpeg"/></div></div></figure><p id="6f67" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> Git </strong>是一个<em class="kt">分布式版本控制系统</em>，用于在软件开发过程中跟踪源代码的变化。</p><p id="c608" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="kt">版本控制系统</em>是记录文件(代码)变更的软件。</p><p id="308e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">有 3 种类型的版本控制系统:</p><ol class=""><li id="9e82" class="ku kv in jx b jy jz kc kd kg kw kk kx ko ky ks kz la lb lc bi translated">本地版本控制系统(Local Version Control System)——开发人员在他们计算机上的数据库中跟踪他们的代码。</li><li id="2387" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks kz la lb lc bi translated"><strong class="jx io">集中式版本控制系统</strong>——开发人员在云中的数据库中跟踪他们的代码。</li></ol><ul class=""><li id="354e" class="ku kv in jx b jy jz kc kd kg kw kk kx ko ky ks li la lb lc bi translated">CVCS 只有一个存储库。</li><li id="9249" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks li la lb lc bi translated">在 CVCS，用户必须从服务器获得一个副本，进行修改并提交给主存储库。</li><li id="dc48" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks li la lb lc bi translated">在 CVCS 做早午餐很难。</li><li id="f3b4" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks li la lb lc bi translated">没有离线访问。</li><li id="ec1e" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks li la lb lc bi translated">CVCS 比较慢。</li></ul><p id="b056" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> 3 分布式版本控制系统</strong>——开发人员在他们的计算机和云上的数据库中跟踪他们的代码。</p><ul class=""><li id="1d8f" class="ku kv in jx b jy jz kc kd kg kw kk kx ko ky ks li la lb lc bi translated">DVCS 可以有许多仓库。</li><li id="85cd" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks li la lb lc bi translated">在 DVCS，每个用户都有自己的本地存储库和服务器上的存储库。</li><li id="7634" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks li la lb lc bi translated">在 DVCS 做早午餐更容易。</li><li id="fb0a" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks li la lb lc bi translated">可以在本地存储库中脱机访问。</li><li id="2975" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks li la lb lc bi translated">DVCS 更快。</li></ul><figure class="lk ll lm ln gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lj"><img src="../Images/0c8aa593428b2d37647dca4be31260fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CwqAcEz1iO-UBho5FkoWWw.png"/></div></div></figure><p id="1e5e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">DVCS 是为协调程序员之间的工作而设计的，但它也可以用来跟踪任何一组文件中的变化。其目标包括速度、数据完整性和对分布式非线性工作流的支持。</p><blockquote class="lo lp lq"><p id="c75f" class="jv jw kt jx b jy jz ka kb kc kd ke kf lr kh ki kj ls kl km kn lt kp kq kr ks ig bi translated">Git 是由 Linus Torvalds 创建的。</p></blockquote><p id="7afc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> GitHub，Inc. </strong>是一家美国跨国公司，使用 Git 为软件开发和版本控制提供托管服务。它提供了 Git 的分布式版本控制和源代码管理(SCM)功能，以及它自己的特性。它为每个项目提供了访问控制和几个协作特性，比如 bug 跟踪、特性请求、任务管理和 wikis。<br/>Github 的一些替代品有 Bitbucket、Source Forge、Gogs、AWS CodeCommit 等等。</p><blockquote class="lo lp lq"><p id="201e" class="jv jw kt jx b jy jz ka kb kc kd ke kf lr kh ki kj ls kl km kn lt kp kq kr ks ig bi translated">Git 是免费的开源软件。</p></blockquote><h2 id="cfc3" class="lu lv in bd lw lx ly dn lz ma mb dp mc kg md me mf kk mg mh mi ko mj mk ml mm bi translated"><strong class="ak">使用 Git 的步骤</strong></h2><p id="0cf3" class="pw-post-body-paragraph jv jw in jx b jy mn ka kb kc mo ke kf kg mp ki kj kk mq km kn ko mr kq kr ks ig bi translated">第一步。安装 git。</p><p id="b3c1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">第二步。创建一个目录，这是一个文件夹，我们将保持所有的代码，这个目录将被转换成本地回购，其中将包含三个部分。</p><ul class=""><li id="14e8" class="ku kv in jx b jy jz kc kd kg kw kk kx ko ky ks li la lb lc bi translated"><em class="kt">工作目录</em>或工作区是我们编写代码的地方。</li><li id="25eb" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks li la lb lc bi translated"><em class="kt">暂存区</em>是完成后我们保存代码的地方。</li><li id="0cff" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks li la lb lc bi translated">一个<em class="kt">本地存储库</em>是我们保存代码快照的地方。假设将来我们想看到代码，我们可以用自动创建的提交 id 来检索它。</li></ul><p id="0d60" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">第三步。git init- <em class="kt">。git </em>文件夹将被创建。</p><p id="6778" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们通过一个例子来理解这一点。假设我们有两个开发者，约翰·塞纳和岩石，他们都在同一个项目上工作。约翰上早班，罗克上晚班。因此，早上 John 来了，处理项目，然后将其推送到中央报告，当 Rock 晚上来时，他将提取代码(这将创建一个工作目录、本地报告和暂存区)，然后他可以从 John 离开的地方开始工作。一旦 Rock 完成了他的工作，他将把代码推送到中央报告，这样，当 John 早上来时，他可以从 Rock 离开的地方继续工作。在每次提交时，都会创建一个提交 ID，在这个 ID 的帮助下，他们可以跟踪在什么时候由谁做了什么更改。</p><blockquote class="lo lp lq"><p id="fac7" class="jv jw kt jx b jy jz ka kb kc kd ke kf lr kh ki kj ls kl km kn lt kp kq kr ks ig bi translated">GIT 只保存快照(即，只保存新文件中的更改，而不是整个文件)。</p></blockquote><figure class="lk ll lm ln gt jo gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/325e34e89bea4c816c9de23d49b0c098.png" data-original-src="https://miro.medium.com/v2/resize:fit:1330/format:webp/1*EGbCll6-hZDIhlKBB1_AIg.png"/></div></figure><p id="10bb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们必须在我们的系统中安装 Git，并在 Github 中创建一个帐户。</p><h2 id="8401" class="lu lv in bd lw lx ly dn lz ma mb dp mc kg md me mf kk mg mh mi ko mj mk ml mm bi translated">GIT 命令</h2><ul class=""><li id="e449" class="ku kv in jx b jy mn kc mo kg mt kk mu ko mv ks li la lb lc bi translated"><strong class="jx io"> <em class="kt"> git init </em> </strong>【创建本地存储库】</li><li id="3752" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks li la lb lc bi translated"><strong class="jx io"> <em class="kt"> git 状态</em> </strong>【给出工作目录和暂存区的状态】</li><li id="e8c7" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks li la lb lc bi translated"><strong class="jx io"> <em class="kt"> git 添加。</em> </strong>【将所有文件添加到暂存区】</li><li id="1eac" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks li la lb lc bi translated"><strong class="jx io"><em class="kt">【git commit-m " message】</em></strong>【保存本地回购中的变更快照】</li><li id="6372" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks li la lb lc bi translated"><strong class="jx io"> <em class="kt"> git 日志</em> </strong>【给出所有提交的历史】</li><li id="9375" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks li la lb lc bi translated"><strong class="jx io"><em class="kt">git show&lt;commit _ id&gt;</em></strong>【显示给定提交 id 中所做的更改】</li><li id="165c" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks li la lb lc bi translated"><strong class="jx io"> <em class="kt"> git 远程添加原点&lt;URL _ of _ github _ repo&gt;</em></strong>【添加本地回购到中央回购的连接】</li><li id="18f8" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks li la lb lc bi translated"><strong class="jx io"><em class="kt">git push-u origin master</em></strong>【将所有文件连同提交 id 发送至中央回购主分支】</li><li id="9594" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks li la lb lc bi translated"><strong class="jx io"><em class="kt">git pull-u origin master</em></strong>【合并中央回购的所有文件】</li><li id="7fc3" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks li la lb lc bi translated"><strong class="jx io"> <em class="kt"> git log -1 </em> </strong>【仅显示最后一次提交】</li><li id="df59" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks li la lb lc bi translated"><strong class="jx io"><em class="kt">git log-n&lt;limit&gt;</em></strong>【限制提交的显示】</li><li id="b240" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks li la lb lc bi translated"><strong class="jx io"/></li><li id="2196" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks li la lb lc bi translated"><strong class="jx io"><em class="kt">git log-p</em></strong><em class="kt"/>【显示每次提交的补丁以及它们的全部区别】</li><li id="cc2a" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks li la lb lc bi translated"><strong class="jx io"><em class="kt">git log—author = " name "</em></strong>【查找指定作者的提交】</li><li id="e050" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks li la lb lc bi translated"><strong class="jx io"><em class="kt">git log—grep = " message "</em></strong>【使用提交消息搜索提交】</li></ul><p id="ff70" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当我们想要添加一个新的特性或者在我们的项目中测试一些特性而不影响我们的主要代码时，我们创建我们的存储库的一个分支。每个任务可以有一个单独的分支，我们可以创建任意数量的分支。如果我们完成了分支中的代码，那么我们可以将它合并到主分支中。默认分支是主分支。</p><ul class=""><li id="e405" class="ku kv in jx b jy jz kc kd kg kw kk kx ko ky ks li la lb lc bi translated"><strong class="jx io"> <em class="kt"> git 分支</em> </strong>【显示我们所在的分支以及回购中的分支列表】</li><li id="3006" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks li la lb lc bi translated"><strong class="jx io"> <em class="kt"> git 分支 newbranch </em> </strong>【创建新的分支名 newbranch】</li><li id="724a" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks li la lb lc bi translated"><strong class="jx io"><em class="kt">git check out newbranch</em></strong>【切换到分支名称 new branch】</li><li id="b750" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks li la lb lc bi translated"><strong class="jx io"><em class="kt">git branch-d newbranch</em></strong>【删除分支名称 new branch】</li><li id="824f" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks li la lb lc bi translated"><strong class="jx io"> <em class="kt"> git 合并 newbranch </em> </strong>【将当前分支合并到 newbranch】</li></ul><p id="4da2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">合并分支后，数据不会从分支中删除，而是复制粘贴到给定/主分支中。</p><p id="88ae" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了临时存储我们的文件，我们使用 stash store。我们将这些文件存储在 stash 中，因为这些文件还没有准备好提交，我们希望清理我们的工作区域。</p><ul class=""><li id="1892" class="ku kv in jx b jy jz kc kd kg kw kk kx ko ky ks li la lb lc bi translated"><strong class="jx io"> <em class="kt"> git stash </em> </strong>【将文件放入 stash】</li><li id="645c" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks li la lb lc bi translated"><strong class="jx io"> <em class="kt"> git 存储列表</em> </strong>【给出存储内存中的文件列表】</li><li id="047f" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks li la lb lc bi translated"><strong class="jx io"> <em class="kt"> git stash pop </em> </strong>【将文件从 stash 拉至工作 repo】</li><li id="3d1f" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks li la lb lc bi translated"><strong class="jx io"><em class="kt">git stash apply stach { 0 }</em></strong>【将文件从 stash 拉到工作 repo】</li><li id="f72e" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks li la lb lc bi translated"><strong class="jx io"> <em class="kt"> git stash drop </em> </strong>【清空我们的 stash memory】</li><li id="cdf5" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks li la lb lc bi translated"><strong class="jx io"><em class="kt">git stash clear</em></strong>【清除我们的 stash 内存】</li><li id="bff3" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks li la lb lc bi translated"><strong class="jx io"> <em class="kt"> git 重置&lt; commit_id &gt; </em> </strong>【在暂存区重置】</li><li id="be2f" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks li la lb lc bi translated"><strong class="jx io"><em class="kt">git revert&lt;commit _ id&gt;</em></strong>【回滚到之前的提交】</li></ul><p id="d63a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们在提交之前使用 git reset，如果我们提交了更改，那么我们使用 revert。Revert 命令将使用以前的状态创建新的提交 id。</p><ul class=""><li id="e506" class="ku kv in jx b jy jz kc kd kg kw kk kx ko ky ks li la lb lc bi translated"><strong class="jx io"><em class="kt">git tag-a " tagname "-m ' message ' HEAD</em></strong>[将标记赋予当前头]</li><li id="4655" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks li la lb lc bi translated"><strong class="jx io"><em class="kt">git tag-a " tagname "-m ' message '&lt;commit _ id&gt;</em></strong>【将标记赋予给定的提交 id】</li><li id="8ad1" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks li la lb lc bi translated"><strong class="jx io"> <em class="kt"> git tag -l </em> </strong>【显示标签列表】</li><li id="1088" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks li la lb lc bi translated"><strong class="jx io"> <em class="kt"> git 显示“标记名”</em> </strong>【显示特定标记】</li><li id="9384" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks li la lb lc bi translated"><strong class="jx io"> <em class="kt"> git 标签-d </em> </strong> <strong class="jx io"> <em class="kt">【标记名】</em> </strong>【删除给定标签】</li><li id="471b" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks li la lb lc bi translated"><strong class="jx io"> <em class="kt"> git 克隆</em> </strong> <strong class="jx io"> <em class="kt"> &lt; git 项目 URL &gt; </em> </strong>【使用 URL 将 repo 克隆到本地目录】</li><li id="bc53" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks li la lb lc bi translated"><strong class="jx io"> <em class="kt"> git 克隆&lt; SSH &gt; </em> </strong>【使用 SSH 将回购克隆到本地目录】</li><li id="c310" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks li la lb lc bi translated"><strong class="jx io"> <em class="kt"> git clean -n </em> </strong>【显示所有将要删除的未跟踪文件，但不删除】</li><li id="5388" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks li la lb lc bi translated"><strong class="jx io"> <em class="kt"> git clean -f </em> </strong>【删除所有未跟踪的文件，文件夹和包含的文件除外。gitignore ]</li><li id="4ba4" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks li la lb lc bi translated"><strong class="jx io"> <em class="kt"> git clean -xm </em> </strong>【显示所有未跟踪的文件，包括。git 忽略将要删除的内容，但不要删除它们]</li><li id="4b3a" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks li la lb lc bi translated"><strong class="jx io"> <em class="kt"> git clean -xf </em> </strong>【删除所有未被跟踪的文件以及包含在。gitignore ]</li><li id="b52d" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks li la lb lc bi translated"><strong class="jx io">。gitignore </strong>是一个隐藏文件，它包含所有我们不想提交的文件名。</li></ul><p id="6f9c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我希望你对如何 git 有一些基本的概念。如果这篇文章对你有所帮助，请考虑给👏🏼并分享出来激励我。</p></div><div class="ab cl mw mx hr my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ig ih ii ij ik"><div class="lk ll lm ln gt nd"><a href="https://medium.com/swlh/confusion-matrix-in-machine-learning-920eda3d2cb6" rel="noopener follow" target="_blank"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd io gy z fp ni fr fs nj fu fw im bi translated">机器学习中的混淆矩阵</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">在这篇博客中，我将试着解释混淆矩阵的所有基本术语以及如何计算它们，用…</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">medium.com</p></div></div><div class="nm l"><div class="nn l no np nq nm nr jt nd"/></div></div></a></div><div class="ns nt gp gr nu nd"><a href="https://medium.com/analytics-vidhya/setup-and-crud-operations-in-mongodb-dd821c4621a" rel="noopener follow" target="_blank"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd io gy z fp ni fr fs nj fu fw im bi translated">MongoDB 中的设置和 CRUD 操作</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">在这篇文章中，我们将看到如何在 MongoDB 云服务中建立一个帐户，并使用 Pymongo 进行 CRUD 操作。</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">medium.com</p></div></div><div class="nm l"><div class="nv l no np nq nm nr jt nd"/></div></div></a></div></div><div class="ab cl mw mx hr my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ig ih ii ij ik"><p id="30e1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">参考—&gt; git-scm.com—&gt;维基百科</p></div></div>    
</body>
</html>