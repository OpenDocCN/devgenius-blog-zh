<html>
<head>
<title>Partial classes and methods</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">分部类和方法</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/partial-classes-and-methods-fa6da5d97cb8?source=collection_archive---------14-----------------------#2020-06-17">https://blog.devgenius.io/partial-classes-and-methods-fa6da5d97cb8?source=collection_archive---------14-----------------------#2020-06-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/e33bde0f5792d54c0917368eba609de7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lGTH0oP7DoIlGyAV"/></div></div></figure><div class=""/><p id="3cf4" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本文中，我将解释什么是分部类和分部方法，以及如何在 C#中实现它们。</p><p id="272e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在 C#中，用于标识类的标识符必须是唯一的；然而，当处理大型项目时，可能需要多个开发人员同时处理同一个类或方法。正因如此，微软引入了<strong class="ka jc">关键字 partial </strong>，并在 C# 2.0 中加入了这个新特性。</p><p id="1132" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">关键字 partial 允许<strong class="ka jc">将一个类定义</strong>拆分成同一个名称空间内的不同部分<strong class="ka jc">，这些部分将在应用程序编译时组合起来。</strong></p><p id="2f11" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要使用此功能，每个零件必须:</p><ul class=""><li id="025b" class="kw kx jb ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">使用<strong class="ka jc">部分</strong>关键字。</li><li id="3a46" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">在编译时可用。</li><li id="3e0b" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">拥有相同的访问修饰符(<strong class="ka jc"> public </strong>，<strong class="ka jc"> private </strong>，<strong class="ka jc"> protected </strong>和<strong class="ka jc"> internal </strong></li><li id="5a1f" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">与其他部分位于相同的名称空间中。</li></ul><p id="faec" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">同样值得一提的是:</p><ul class=""><li id="d3ab" class="kw kx jb ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">如果有一部分被声明为<strong class="ka jc">抽象</strong>，那么整个类型都被认为是抽象的。</li><li id="3f5f" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">如果有一部分被声明为<strong class="ka jc">密封的</strong>，那么整个类型都被认为是密封的。</li><li id="2d51" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">如果有一部分声明了一个基类，那么整个类型都会继承那个类(即使省略了基类的部分也会继承基类)。</li><li id="79ad" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">在一个部分中声明的任何类、结构或接口成员对所有其他部分都可用。</li></ul><p id="0856" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，如果我们考虑以下部分:</p><p id="2f6f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">partialclassfirstfile . cs</strong></p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="0ef6" class="lt lu jb lp b gy lv lw l lx ly">partial class Earth : Planet, IRotate<br/>{<br/>    public void CalcolateMass() { … }<br/>}</span></pre><p id="0bf1" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">partialclassecondfile . cs</strong></p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="9caa" class="lt lu jb lp b gy lv lw l lx ly">partial class Earth : IRevolve<br/>{<br/>    public void CalcolateSpeed() { … }<br/>}</span></pre><p id="4b31" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">编译结束后，等价的类是:</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="4da0" class="lt lu jb lp b gy lv lw l lx ly">class Earth : Planet, IRotate, IRevolve<br/>{<br/>    public void CalcolateMass() { … }<br/>    public void CalcolateSpeed() { … }<br/>}</span></pre><p id="128f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">partial 关键字也可以应用于方法。它的行为与类非常相似，事实上，一个类可以包含方法的签名，另一个部分可以提供它的实现。这两部分将在编译时合并。</p><p id="d8bb" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果没有提供实现，编译器将通过在编译时移除方法和所有调用来优化代码。</p><p id="dae4" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">提到分部方法很重要:</p><ul class=""><li id="f478" class="kw kx jb ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">必须返回<strong class="ka jc"> void </strong>。</li><li id="5b81" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">在或<strong class="ka jc"> ref </strong>中可以有<strong class="ka jc">，但不能有<strong class="ka jc"> out </strong>参数(必须分配<strong class="ka jc"> out </strong>参数，因为可能无法实现分部方法，所以不允许使用这种参数)。</strong></li><li id="b78a" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">是隐式<strong class="ka jc">私有的</strong>(因此不能是虚拟的)。</li><li id="c187" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">可以有<strong class="ka jc">静态</strong>和不安全<strong class="ka jc">修改器</strong>。</li><li id="08de" class="kw kx jb ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">可以是泛型。</li></ul><p id="afc2" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在下面的例子中，我们将在前面的代码中增加一些代码。</p><p id="3823" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">partialclassfirstfile . cs</strong></p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="f0f1" class="lt lu jb lp b gy lv lw l lx ly">partial class Earth : Planet, IRotate<br/>{<br/>    public void CalcolateMass() { … }<br/>    public partial void CalcolateVolume() { }<br/>    public partial void CalcolateForce() { }<br/>}</span></pre><p id="adfc" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">partialclassecondfile . cs</strong></p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="aeda" class="lt lu jb lp b gy lv lw l lx ly">partial class Earth : IRevolve<br/>{<br/>    public void CalcolateSpeed() { … }<br/>    public partial void CalcolateVolume() { … }<br/>}</span></pre><p id="a056" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这种情况下，在 PartialClassFisrtFile.cs 文件中实现的类 Earth 只声明 CalcolateVolume 和 CalcolateForce 的方法签名。虽然 CalcolateVolume 方法是在 PartialClassSecondFile.cs 文件中的相关类中实现的，但另一个方法不是，这意味着一旦编译结束，<em class="lz"> CalcolateForce </em>方法将被移除，最终的类将是:</p><pre class="lk ll lm ln gt lo lp lq lr aw ls bi"><span id="95f3" class="lt lu jb lp b gy lv lw l lx ly">class Earth : Planet, IRotate, IRevolve <br/>{<br/>    public void CalcolateMass() { … }<br/>    public void CalcolateVolume() { … }<br/>    public void CalcolateSpeed() { … }<br/>}</span></pre></div></div>    
</body>
</html>