<html>
<head>
<title>Higher-Order Component in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React 中的高阶分量</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/higher-order-component-in-react-2bed7b6053f0?source=collection_archive---------11-----------------------#2022-04-04">https://blog.devgenius.io/higher-order-component-in-react-2bed7b6053f0?source=collection_archive---------11-----------------------#2022-04-04</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/fda2ade2e3332c9629b026199d8a1fc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2fHewU1JLMCe3-l-YwBDEw.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">图片来自 morioh.com</figcaption></figure><p id="5394" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi kx translated"><span class="l ky kz la bm lb lc ld le lf di">一个</span>高阶组件简称为<strong class="kb io"/>是 React 中的一种高级技术，用于<strong class="kb io">复用组件逻辑</strong>。hoc 不是 React API 的一部分。它们是源于自然反应的模式，自然反应优先于遗传。</p><ul class=""><li id="4f32" class="lg lh in kb b kc kd kg kh kk li ko lj ks lk kw ll lm ln lo bi translated">高阶组件是一种函数，它采用原始组件，并通过向该组件添加附加功能来返回增强的组件。</li></ul><figure class="lq lr ls lt gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lp"><img src="../Images/2f9c776b5c9b7ab6affbc3b2e5047beb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4mGpCp7dl9QZHR3BxMOiAQ.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">示例即席语法</figcaption></figure><p id="88ab" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">以下是我们可能遇到的一些例子:</p><figure class="lq lr ls lt gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lu"><img src="../Images/e4fababade063cfe158a54c3eda76b3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P5ytRhkFdK5gM4JwNAqlUg.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">图片来自 smashing 杂志</figcaption></figure><p id="d19a" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">现在让我们继续讨论 react 中可用的<strong class="kb io">hoc</strong>类型，如下所示:</p><h2 id="9c7d" class="lv lw in bd lx ly lz dn ma mb mc dp md kk me mf mg ko mh mi mj ks mk ml mm mn bi translated">高阶元件的类型:</h2><p id="7f4a" class="pw-post-body-paragraph jz ka in kb b kc mo ke kf kg mp ki kj kk mq km kn ko mr kq kr ks ms ku kv kw ig bi translated">有两种主要类型的专用实现:</p><p id="8757" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">(一)。道具代理。</p><p id="88c2" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">㈡。继承倒置。</p><p id="76e5" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io"> <em class="mt">道具代理(ppHoc): </em> </strong></p><p id="81e1" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这有助于<strong class="kb io">添加/编辑</strong> <strong class="kb io">道具</strong>传递给组件。它只不过是一个函数 propsProxyHOC，接收一个组件作为参数，并返回一个新组件(包装的组件)。</p><p id="a47c" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">当我们返回包装好的组件时，我们还会传递 HOC 收到的道具。这就解释了这种类型的名称:<strong class="kb io"> props proxy </strong>。</p><figure class="lq lr ls lt gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mu"><img src="../Images/a6cc5683d39f93fc5cc28ba6b1842c7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ydI2IvK2fChlBUetez7oFg.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">Props 代理 HOC(标准实现)。</figcaption></figure><p id="dfeb" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">props 代理 hoc 在以下情况下很有用:</p><ol class=""><li id="4ad0" class="lg lh in kb b kc kd kg kh kk li ko lj ks lk kw mv lm ln lo bi translated">操纵道具</li><li id="a5c7" class="lg lh in kb b kc mw kg mx kk my ko mz ks na kw mv lm ln lo bi translated">抽象状态</li><li id="4aad" class="lg lh in kb b kc mw kg mx kk my ko mz ks na kw mv lm ln lo bi translated">用其他元素包装/组合包装的组件</li></ol><p id="dfd2" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io"> <em class="mt">继承反转(iiHOC): </em> </strong></p><p id="89f7" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在这种情况下，返回的类<strong class="kb io">扩展了</strong>包装的组件。叫做<strong class="kb io">继承</strong>T28】反转。</p><figure class="lq lr ls lt gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nb"><img src="../Images/5417446ddd6fe8592328b79c254f93f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vDmUOoTE-VRvXLobmzrROA.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">继承反转特设(标准实现)</figcaption></figure><p id="e162" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">继承反转通过<em class="mt">这个</em>提供了对包装组件实例的特殊访问，这意味着您可以使用状态、属性、组件生命周期和<strong class="kb io">甚至渲染方法</strong>。</p><p id="0571" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">继承反转 hoc 在下列情况下很有用:</p><ol class=""><li id="1875" class="lg lh in kb b kc kd kg kh kk li ko lj ks lk kw mv lm ln lo bi translated">渲染高劫持</li><li id="8071" class="lg lh in kb b kc mw kg mx kk my ko mz ks na kw mv lm ln lo bi translated">操纵状态</li></ol><p id="db6a" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io"> <em class="mt">带 HOCs 的好处:</em> </strong></p><p id="dd24" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">一、无代码重复。</p><p id="a70d" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">二。使代码更具可读性。</p><p id="852d" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">三。易于添加“功能”。</p><p id="a6d6" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">四。我们不会修改或改变组件。</p><h2 id="1a16" class="lv lw in bd lx ly lz dn ma mb mc dp md kk me mf mg ko mh mi mj ks mk ml mm mn bi translated">结论:</h2><ul class=""><li id="b152" class="lg lh in kb b kc mo kg mp kk nc ko nd ks ne kw ll lm ln lo bi translated">Hoc 用于组合组件以供代码重用。</li><li id="06be" class="lg lh in kb b kc mw kg mx kk my ko mz ks na kw ll lm ln lo bi translated">特设是一个纯粹的功能。它没有副作用，只返回一个新的组件。</li><li id="4c74" class="lg lh in kb b kc mw kg mx kk my ko mz ks na kw ll lm ln lo bi translated">我们可以跨 Redux、Router、Material UI 使用 HOCs。</li></ul><p id="e05b" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">参考资料:</p><p id="be49" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><a class="ae nf" href="https://reactjs.org/docs/higher-order-components.html" rel="noopener ugc nofollow" target="_blank">高阶组件—反应(reactjs.org)</a></p><p id="ea2a" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><a class="ae nf" href="https://www.tutorialspoint.com/reactjs/reactjs_higher_order_components.htm" rel="noopener ugc nofollow" target="_blank"> ReactJS —高阶组件(tutorialspoint.com)</a></p><p id="26d6" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">你觉得这篇文章中列出的策略有用吗？</p></div></div>    
</body>
</html>