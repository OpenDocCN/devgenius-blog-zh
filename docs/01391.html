<html>
<head>
<title>Data Binding with MVVM on iOS part 1: Data flows</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">iOS上MVVM的数据绑定第1部分:数据流</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/data-binding-in-ios-part-1-data-flows-in-mvc-3d182c065e4?source=collection_archive---------10-----------------------#2020-07-02">https://blog.devgenius.io/data-binding-in-ios-part-1-data-flows-in-mvc-3d182c065e4?source=collection_archive---------10-----------------------#2020-07-02</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="43ba" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Android提供数据绑定来监听模型的变化和更新绑定视图。这也是我爱Android开发胜过iOS开发的地方。在这个故事中，我将使用Swift KeyPath实现数据绑定，您可能会有更好的想法。欢迎评论。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/6dabf3f053ed9ada739417909dcc52d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*BKPHaxhJJCzVpxKM432BAA.png"/></div></figure><p id="6b61" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">从这个表单设计中，你可以很容易地发现有一个数据模型和相关的文本字段和选择按钮。在Android中用数据绑定很容易实现:一个<em class="kq"> </em> <strong class="jm io"> <em class="kq">数据类</em> </strong> <em class="kq">，一个在<strong class="jm io"> XML </strong>中用数据</em>声明<em class="kq"> </em>的布局，以及几个<strong class="jm io"> <em class="kq">绑定表达式</em> </strong> <em class="kq">。</em>就这样。生成的绑定类会处理剩下的事情。</p><p id="6d3a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">不过iOS好像有点缺点。在实现视图和模型的监听更新时，iOS开发者比android开发者更忙。</p></div><div class="ab cl kr ks hr kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ig ih ii ij ik"><h2 id="e789" class="ky kz in bd la lb lc dn ld le lf dp lg jv lh li lj jz lk ll lm kd ln lo lp lq bi translated">模型</h2><p id="d714" class="pw-post-body-paragraph jk jl in jm b jn lr jp jq jr ls jt ju jv lt jx jy jz lu kb kc kd lv kf kg kh ig bi translated">这里是纯用户模型。您可能会注意到字符串类型是可选的，与UITextField文本类型相同，用于在使用WritableKeyPath <user string="">时消除类型的转换。</user></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk translated">用户模型</figcaption></figure><h2 id="8fd2" class="ky kz in bd la lb lc dn ld le lf dp lg jv lh li lj jz lk ll lm kd ln lo lp lq bi translated">视图</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk translated">视图</figcaption></figure><h2 id="8c86" class="ky kz in bd la lb lc dn ld le lf dp lg jv lh li lj jz lk ll lm kd ln lo lp lq bi translated">MVVM的数据流</h2><p id="9bd3" class="pw-post-body-paragraph jk jl in jm b jn lr jp jq jr ls jt ju jv lt jx jy jz lu kb kc kd lv kf kg kh ig bi translated">在讨论数据绑定之前，让我们回顾一下模型-视图-视图模型中的数据流。</p><p id="9918" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">MVC或MVVM在现实世界中的数据流是复杂的。它从一个组件自由地流向另一个组件，没有任何限制。例如，viewmodel更新视图的外观和模型的属性；视图的子类更新它自己的模型；模型更新视图并通过<em class="kq"> didSet </em>或<em class="kq"> KVO </em>通知视图模型。</p><p id="e36e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这些流是自然的，但是复杂性带来了烦人的bug。那种系统只有聪明的开发人员才能维护。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mc"><img src="../Images/d75a256ec32c30c73ed91e8bfde0f0c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/1*taczrF-DETuLZNE-XEuAQQ.png"/></div></figure><p id="b0de" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">数据绑定的基本思想是保持视图表示和模型数据之间的一致性。视图的显示值应该始终与模型的数据相同。下图将复杂的流简化为两个流，它们都保证了视图和模型的一致性。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi md"><img src="../Images/57540dae30f173b3ee3eef9b92397f82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*43Av20I__ka7Jk455fwL6g.png"/></div></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk translated">MVVM的数据流</figcaption></figure><p id="22fa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在第一张图所示的人机交互中，如果我们把人物的移动看作数据源的开始，流程大致是这样的:交互&gt; iPhone系统&gt;视图&gt; viewmodel &gt;模型。下面的代码是这个流最常见的用法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk translated">viewmodel监听视图并相应地更新模型</figcaption></figure><p id="964b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">NChanged()方法反复重复，违背了DRY原则。在Swift KeyPath的帮助下，我将这些方法抽象为一个方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk translated">视图-&gt;标签-&gt;关键路径-&gt;模型</figcaption></figure><p id="791d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在第二个图中显示的其他场景中，viewmodel充当接口模式的接口，它是从外部系统更新视图和模型的唯一位置。为了保持一致性，如果viewmodel更新视图，它随后更新模型，如果viewmodel更新模型，它也更新视图。下面的代码就是关于这个流程的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk translated">记得更新他们两个</figcaption></figure><p id="1ed3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当更新视图或模型时，记住更新其他的并不容易。在Swift KeyPath的帮助下，我存储了如何成对更新模型和绑定视图的方法。viewmodel首先更新模型，然后更新视图。为了简化情况，不建议直接更新视图。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk translated">更新模式，自动更新视图</figcaption></figure></div><div class="ab cl kr ks hr kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ig ih ii ij ik"><h2 id="5d80" class="ky kz in bd la lb lc dn ld le lf dp lg jv lh li lj jz lk ll lm kd ln lo lp lq bi translated">摘要</h2><p id="f35a" class="pw-post-body-paragraph jk jl in jm b jn lr jp jq jr ls jt ju jv lt jx jy jz lu kb kc kd lv kf kg kh ig bi translated">数据流有很多种，只注意2种:</p><ul class=""><li id="2bcc" class="mi mj in jm b jn jo jr js jv mk jz ml kd mm kh mn mo mp mq bi translated">流程1，viewmodel监听的事件触发的数据，viewmodel将其传递给模型，流程:<strong class="jm io">View&gt;ViewModel&gt;Model</strong></li><li id="d9a9" class="mi mj in jm b jn mr jr ms jv mt jz mu kd mv kh mn mo mp mq bi translated">一个关键路径映射，用于减少重复代码，并帮助视图模型知道当事件触发时要更新哪个模型属性:<strong class="jm io">【视图Id: PartialKeyPath &lt;模型&gt;】</strong></li><li id="e590" class="mi mj in jm b jn mr jr ms jv mt jz mu kd mv kh mn mo mp mq bi translated">流程2，来自其他场景的数据，viewmodel先将其传递给模型，随后更新视图，流程:<strong class="jm io"> ViewModel &gt;模型和视图</strong></li><li id="6762" class="mi mj in jm b jn mr jr ms jv mt jz mu kd mv kh mn mo mp mq bi translated">保持视图呈现和模型属性一致性的关键路径映射:<strong class="jm io">【partial key path&lt;Model&gt;:weak view】</strong></li></ul></div><div class="ab cl kr ks hr kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ig ih ii ij ik"><p id="3b16" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在两个关键路径映射的帮助下，iOS中的数据绑定可以如下图所示实现。当视图改变时，模型会自动更新；当viewmodel更新模型时，视图也会相应地更新。这也是我爱iOS开发胜过安卓开发的地方。在第2部分的故事中，我将揭示DataDinding类的细节。享受Swift/Kotlin，敬请期待。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi mw"><img src="../Images/1e5eda4a083a38e940434c25b1ef5408.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LsqrVqnT__GpIsZu2yFKcw.png"/></div></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk translated">视图自动更新模型。并在视图模型更新模型时重新呈现视图</figcaption></figure><p id="ea5c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个故事的第二部分在这里，它是关于为什么选择KeyPath以及如何在集合中存储它们。</p><div class="mx my gp gr mz na"><a href="https://medium.com/@tonny/data-binding-in-ios-part-2-keypath-and-type-erasure-8f5a5d2d1571" rel="noopener follow" target="_blank"><div class="nb ab fo"><div class="nc ab nd cl cj ne"><h2 class="bd io gy z fp nf fr fs ng fu fw im bi translated">iOS中的数据绑定第2部分:关键路径和类型擦除</h2><div class="nh l"><h3 class="bd b gy z fp nf fr fs ng fu fw dk translated">这个故事是关于我如何用Swift KeyPath实现单向和双向数据绑定的。</h3></div><div class="ni l"><p class="bd b dl z fp nf fr fs ng fu fw dk translated">medium.com</p></div></div><div class="nj l"><div class="nk l nl nm nn nj no ko na"/></div></div></a></div></div></div>    
</body>
</html>