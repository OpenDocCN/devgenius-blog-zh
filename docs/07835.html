<html>
<head>
<title>Using Spread in JavaScript Objects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在 JavaScript 对象中使用跨页</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/using-spread-in-javascript-objects-6769966cb9fd?source=collection_archive---------10-----------------------#2022-04-26">https://blog.devgenius.io/using-spread-in-javascript-objects-6769966cb9fd?source=collection_archive---------10-----------------------#2022-04-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="89c8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">了解如何在对象中使用 ES6 扩展运算符</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/cc0615556b5bac0827aac6530b7a9827.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IrYbx0e3bF4ZBWZsPOMutA.jpeg"/></div></div></figure><p id="dc04" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我最近发表了两篇文章，介绍如何在<a class="ae kx" href="https://javascript.plainenglish.io/using-spread-in-arrays-bcfea95162c5" rel="noopener ugc nofollow" target="_blank">数组</a>和<a class="ae kx" href="https://javascript.plainenglish.io/how-to-use-spread-in-javascript-functions-5111cae3648f" rel="noopener ugc nofollow" target="_blank">函数</a>中使用 JavaScript spread 操作符。本文将介绍如何在 JavaScript 对象中使用 spread 操作符。</p><h2 id="2aee" class="ky kz iq bd la lb lc dn ld le lf dp lg jy lh li lj kc lk ll lm kg ln lo lp lq bi translated">在对象中引入扩散</h2><p id="674d" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">当我们在一个对象中使用 spread 操作符时，我们可以将属性从一个对象复制到另一个对象中，并且可以将不同的对象组合成一个目标对象。我们还可以进一步扩展目标对象，使其包含复制的对象和其他属性。让我们看一个例子。</p><pre class="km kn ko kp gt lw lx ly lz aw ma bi"><span id="2d88" class="ky kz iq lx b gy mb mc l md me">const alien = {<br/>  species: "Alien",<br/>  arms: 5<br/>};</span><span id="ed70" class="ky kz iq lx b gy mf mc l md me">const ufo = {<br/>  ...alien,<br/>  legs: 8<br/>};</span><span id="4d75" class="ky kz iq lx b gy mf mc l md me">console.log(ufo);</span><span id="4826" class="ky kz iq lx b gy mf mc l md me">//Returns ---&gt; {species: 'Alien', arms: 5, legs: 8}</span></pre><p id="e16f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上面的例子中，我们创建了一个对象文字，分配给一个名为<em class="mg">外星人</em>的变量。这个对象包含一个<em class="mg">物种</em>属性和一个<em class="mg">武器</em>属性。然后我们创建另一个对象文字，这次叫做<em class="mg"> ufo </em>。在<em class="mg"> ufo </em>对象中，我们使用 spread 操作符复制<em class="mg">外星人</em>对象。我们还添加了一个带有键<em class="mg">腿</em>的附加属性。当我们运行这段代码时，我们得到一个对象，它具有来自<em class="mg">外星人</em>对象的所有属性，以及额外的<em class="mg">腿</em>属性。</p><h2 id="81ec" class="ky kz iq bd la lb lc dn ld le lf dp lg jy lh li lj kc lk ll lm kg ln lo lp lq bi translated">冲突的属性</h2><p id="0675" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">当您对对象使用 spread 运算符时，有几件事情需要记住。当您扩散的对象和父对象具有冲突的属性时，值得记住的是该属性将被覆盖。属性的最终值将是程序运行时读取的最后一个值。让我们看看这个。</p><pre class="km kn ko kp gt lw lx ly lz aw ma bi"><span id="5c9e" class="ky kz iq lx b gy mb mc l md me">const alien = {<br/>  species: "Alien",<br/>  arms: 5,<br/>  feet: 9<br/>};</span><span id="3eba" class="ky kz iq lx b gy mf mc l md me">const ufo = {<br/>  ...alien,<br/>  legs: 8,<br/>  feet: 6<br/>};</span><span id="7418" class="ky kz iq lx b gy mf mc l md me">console.log(ufo);</span><span id="4aff" class="ky kz iq lx b gy mf mc l md me">//Returns ---&gt; {species: 'Alien', arms: 5, feet: 6, legs: 8}</span></pre><p id="0beb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上面的例子中，我们给两个对象都添加了一个<em class="mg">英尺</em>属性。在<em class="mg">外星人</em>的物体<em class="mg">的脚上</em>有 9 的数值。在<em class="mg">不明飞行物</em>中物体<em class="mg">的脚</em>的值为 6。当代码运行时，返回的对象具有值为 6 的属性<em class="mg">foots</em>。这是因为代码运行时<em class="mg"> ufo </em>是最后一个设置<em class="mg">脚</em>属性的对象。</p><h2 id="c7bd" class="ky kz iq bd la lb lc dn ld le lf dp lg jy lh li lj kc lk ll lm kg ln lo lp lq bi translated">复印副本</h2><p id="04ca" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">当您使用扩展操作符和对象时，可以复制复制的对象。让我们看一个例子。</p><pre class="km kn ko kp gt lw lx ly lz aw ma bi"><span id="f685" class="ky kz iq lx b gy mb mc l md me">const alien = {<br/>  species: "Alien",<br/>  arms: 5,<br/>  feet: 9<br/>};</span><span id="2fad" class="ky kz iq lx b gy mf mc l md me">const ufo = {<br/>  ...alien,<br/>  legs: 8,<br/>  feet: 6<br/>};</span><span id="2ca9" class="ky kz iq lx b gy mf mc l md me">const copiedUfo = {<br/>  ...ufo<br/>}</span><span id="f3cd" class="ky kz iq lx b gy mf mc l md me">console.log(copiedUfo);</span><span id="eef9" class="ky kz iq lx b gy mf mc l md me">//Returns ---&gt; {species: 'Alien', arms: 5, feet: 6, legs: 8}</span></pre><p id="1ab7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mg"> copiedUfo </em>对象简单地返回了一个<em class="mg"> ufo </em>对象的副本，所以当我们使用控制台日志为<em class="mg"> copiedUfo </em>对象返回相同的属性。不过这里值得注意的是，带有对象的 spread 操作符只对对象进行浅层复制(复制对象的地址)。这两个对象不会严格相等，因为它们是通过引用而不是通过值来存储的。</p><pre class="km kn ko kp gt lw lx ly lz aw ma bi"><span id="e4f7" class="ky kz iq lx b gy mb mc l md me">const alien = {<br/>  species: "Alien",<br/>  arms: 5,<br/>  feet: 9<br/>};</span><span id="0c8b" class="ky kz iq lx b gy mf mc l md me">const ufo = {<br/>  ...alien,<br/>  legs: 8,<br/>  feet: 6<br/>};</span><span id="0f05" class="ky kz iq lx b gy mf mc l md me">const copiedUfo = {<br/>  ...ufo<br/>}</span><span id="eac9" class="ky kz iq lx b gy mf mc l md me">console.log(ufo === copiedUfo);<br/>//Returns ---&gt; false</span></pre><p id="7c85" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，不会复制对象的嵌套实例。下面是一个浅层复制如何工作的例子。</p><pre class="km kn ko kp gt lw lx ly lz aw ma bi"><span id="b264" class="ky kz iq lx b gy mb mc l md me">const alien = {<br/>  species: "Alien",<br/>  arms: 5,<br/>  feet: 9<br/>};</span><span id="27c4" class="ky kz iq lx b gy mf mc l md me">const ufo = {<br/>  ...alien,<br/>  legs: 8,<br/>  feet: 6<br/>};</span><span id="3222" class="ky kz iq lx b gy mf mc l md me">const copiedUfo = {<br/>  ...ufo<br/>}</span><span id="02f1" class="ky kz iq lx b gy mf mc l md me">ufo.legs = 1</span><span id="1242" class="ky kz iq lx b gy mf mc l md me">console.log(copiedUfo);</span><span id="7adc" class="ky kz iq lx b gy mf mc l md me">//Returns ---&gt; {species: 'Alien', arms: 5, feet: 6, legs: 8}</span><span id="f70b" class="ky kz iq lx b gy mf mc l md me">console.log(ufo);<br/>//Returns ---&gt; {species: 'Alien', arms: 5, feet: 6, legs: 1}</span></pre><p id="e541" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我们更新<em class="mg"> ufo </em>对象上的<em class="mg"> legs </em>属性，并在控制台记录<em class="mg"> copiedUfo </em>对象时，我们可以看到<em class="mg"> ufo </em>对象的<em class="mg"> legs </em>属性没有受到影响，仍然是值 8。当我们从控制台注销 ufo 对象时，我们可以看到它现在是 1。然而，如果我们改变一个嵌套对象中的一个属性，两个对象都会改变。让我们看一看。</p><pre class="km kn ko kp gt lw lx ly lz aw ma bi"><span id="39a0" class="ky kz iq lx b gy mb mc l md me">const alien = {<br/>  species: "Alien",<br/>  arms: 5,<br/>  feet: 9<br/>};</span><span id="3732" class="ky kz iq lx b gy mf mc l md me">const ufo = {<br/>  ...alien,<br/>  legs: 8,<br/>  feet: 6,<br/>  journey: {<br/>    length: 9000<br/>  }<br/>};</span><span id="b140" class="ky kz iq lx b gy mf mc l md me">const copiedUfo = {<br/>  ...ufo<br/>}</span><span id="c966" class="ky kz iq lx b gy mf mc l md me">ufo.legs = 1<br/>ufo.journey.length = 10</span><span id="7842" class="ky kz iq lx b gy mf mc l md me">console.log(copiedUfo);</span><span id="9e75" class="ky kz iq lx b gy mf mc l md me">//Returns ---&gt; <br/> <em class="mg">{<br/>  species: 'Alien',<br/>  arms: 5,<br/>  feet: 6,<br/>  legs: 8,<br/>  journey: { length: 10 }<br/>}</em></span></pre><p id="99a3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上面的例子中，我们给包含一个对象的<em class="mg"> ufo </em>对象添加了一个<em class="mg">旅程</em>属性。对象内部是一个设置为 9000 的<em class="mg">长度</em>属性。在示例的最后，我们将其更改为 10。当代码运行时，我们可以看到虽然<em class="mg">腿</em>没有在<em class="mg">副本中发生变化，但是长度属性发生了变化。</em></p><h2 id="7f0a" class="ky kz iq bd la lb lc dn ld le lf dp lg jy lh li lj kc lk ll lm kg ln lo lp lq bi translated">不同的数据结构</h2><p id="4184" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">您只能将对象扩散到对象中，而不能将对象扩散到数组中。</p><pre class="km kn ko kp gt lw lx ly lz aw ma bi"><span id="d9c6" class="ky kz iq lx b gy mb mc l md me">const alien = {<br/>  species: "Alien",<br/>  arms: 5,<br/>  feet: 9<br/>};</span><span id="95e4" class="ky kz iq lx b gy mf mc l md me">const ourArray = [...alien];<br/>//Returns ---&gt; VM229:6 Uncaught TypeError: alien is not iterable<br/>    at &lt;anonymous&gt;:6:22</span></pre><p id="8bb7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以将一个对象分散到数组中的一个对象中</p><pre class="km kn ko kp gt lw lx ly lz aw ma bi"><span id="5fae" class="ky kz iq lx b gy mb mc l md me">const alien = {<br/>  species: "Alien",<br/>  arms: 5,<br/>  feet: 9<br/>};</span><span id="a90f" class="ky kz iq lx b gy mf mc l md me">const ourArray = [{...alien}];</span><span id="5c5b" class="ky kz iq lx b gy mf mc l md me">console.log(ourArray);</span><span id="dcab" class="ky kz iq lx b gy mf mc l md me">//Returns ---&gt; [{species: "Alien", arms: 5, feet: 9}]</span></pre><p id="f4c3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您也可以将一个数组扩展到一个对象中，但最终会得到基于元素索引的键值对。</p><pre class="km kn ko kp gt lw lx ly lz aw ma bi"><span id="9537" class="ky kz iq lx b gy mb mc l md me">const letters = ["a", "b", "c"];<br/>const alphabet = {...letters};</span><span id="fa65" class="ky kz iq lx b gy mf mc l md me">console.log(alphabet);</span><span id="bb2b" class="ky kz iq lx b gy mf mc l md me">//Returns ---&gt; {0: 'a', 1: 'b', 2: 'c'}</span></pre><p id="0585" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请随时发表任何评论、问题或反馈，并关注我以获取更多内容！</p><p id="51ce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我也有一个关于 ES6 的 Udemy 课程。</p></div></div>    
</body>
</html>