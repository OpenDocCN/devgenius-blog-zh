<html>
<head>
<title>Building a Wordle Solver</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建 Wordle 求解器</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/building-a-wordle-solver-629b2ac3e243?source=collection_archive---------7-----------------------#2022-01-24">https://blog.devgenius.io/building-a-wordle-solver-629b2ac3e243?source=collection_archive---------7-----------------------#2022-01-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/cd23c6c670e4814ca9fdff1d7ec35160.png" data-original-src="https://miro.medium.com/v2/resize:fit:1052/format:webp/1*RO6hNkHBokq-Yjf-rUJ7UA.png"/></div></figure><p id="8d87" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">不关心如何使用，只想使用它？试试这里:<a class="ae kt" href="https://wordle-cheater.netlify.app/" rel="noopener ugc nofollow" target="_blank"><em class="ks">https://wordle-cheater.netlify.app/</em></a></p><p id="4721" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这个游戏在互联网上掀起了风暴。它的简单规则和与朋友分享和竞争的能力(同时没有许多社交游戏的隐私损失)导致了一个胜利的组合。在我们的生活中，有时会有点混乱，我觉得这个简单的游戏非常令人耳目一新，在这个游戏中，我们在没有任何替代议程的情况下(至少在我看来)进行猜词比赛。我不是唯一一个也这么想的人。查看 Google trends<a class="ae kt" href="https://trends.google.com/trends/explore?q=wordle&amp;geo=US" rel="noopener ugc nofollow" target="_blank">中的单词“wordle ”,可以看到它在过去几周的爆炸性增长。</a></p><figure class="kv kw kx ky gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi ku"><img src="../Images/1a7899a91c3fc9057790cf0ed8a1b088.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DVCRy2JKH7J2cShU-eF91w.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">沃尔多在过去几周的爆炸性增长。</figcaption></figure><h2 id="a171" class="lh li iq bd lj lk ll dn lm ln lo dp lp kf lq lr ls kj lt lu lv kn lw lx ly lz bi translated">规则</h2><p id="b30c" class="pw-post-body-paragraph ju jv iq jw b jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr ij bi translated">对于那些还没有参与游戏的人来说，有必要重温一下游戏的基本概念。游戏的目标是在 6 次猜测中猜出秘密单词。秘密单词总是五个字符，你的每个猜测也是五个字符的单词。每次猜测后，系统会告诉您猜测中的哪些字母是单词正确位置中的正确字符，是单词中的字符但当前位置错误，还是单词中没有的字符(分别用绿色、黄色和灰色表示)。你使用的每个猜词也必须是游戏中已知的合法单词。每天你只能做一个谜题，这让我上瘾，但也避免了花所有时间玩游戏的陷阱。游戏的简单语义并不新鲜，它与游戏<a class="ae kt" href="https://www.pressmantoy.com/product/mastermind-2/" rel="noopener ugc nofollow" target="_blank">策划者</a>或游戏节目<a class="ae kt" href="https://www.imdb.com/title/tt0329871/" rel="noopener ugc nofollow" target="_blank">行话</a>的玩法非常相似。也就是说，有趣不一定是原创的。</p><p id="eaaa" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我已经玩了几个星期了，一直玩得很开心，但是我觉得开发一个简单的网站来帮助你猜测可能会很有趣。虽然这让游戏失去了很多乐趣，但它确实带来了几个小时的编码和解决面试式问题的乐趣。</p><h2 id="4f7d" class="lh li iq bd lj lk ll dn lm ln lo dp lp kf lq lr ls kj lt lu lv kn lw lx ly lz bi translated"><strong class="ak">背景信息</strong></h2><p id="8858" class="pw-post-body-paragraph ju jv iq jw b jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr ij bi translated">作为一个如此简单的游戏，它的大部分(如果不是全部)都是直接由前端代码驱动的。我们可以从这段前端代码中获得的关键信息是如何选择单词。游戏使用了两个单词的列表。第一个列表是一个大约 2315 个单词的列表，当天的答案可以从中选择。第二个列表约有 10，657 个单词，是合法猜测的附加单词列表(除了可能答案列表中的单词之外)，但不是谜题的可能答案。</p><h2 id="3509" class="lh li iq bd lj lk ll dn lm ln lo dp lp kf lq lr ls kj lt lu lv kn lw lx ly lz bi translated">环境</h2><p id="618b" class="pw-post-body-paragraph ju jv iq jw b jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr ij bi translated">Wordle 是一个在线游戏，让这个工具也能在线工作是有意义的。我过去做过一些角度编程，但听到了关于 Vue.js 的好消息，所以我决定尝试一下。我决定不要过于疯狂地分离组件，因为这是一个非常基本的用户界面，我主要想专注于处理代码，而不是界面代码。</p><h2 id="dced" class="lh li iq bd lj lk ll dn lm ln lo dp lp kf lq lr ls kj lt lu lv kn lw lx ly lz bi translated">第一相</h2><p id="62ca" class="pw-post-body-paragraph ju jv iq jw b jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr ij bi translated">对于这个应用程序的第一阶段，我决定这样做，以便您可以输入单词的已知部分(匹配字符、单词中未知位置的字符以及解决方法单词中没有的字符)，应用程序可以从可能的答案列表中产生一个符合该标准的可能答案列表。</p><p id="780d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">对于已知的字符，我们将让用户通过把字符放在他们所属的位置和“？”来提供他们所知道的对于他们不认识的角色。这似乎是一个使用正则表达式的合理地方，所以我们决定去那里。</p><pre class="kv kw kx ky gt mf mg mh mi aw mj bi"><span id="b13c" class="lh li iq mg b gy mk ml l mm mn">//pull in an array of each potential answer word<br/>import possibleAnswers from './possible-answers.json'</span><span id="e6a2" class="lh li iq mg b gy mo ml l mm mn">//...</span><span id="c96b" class="lh li iq mg b gy mo ml l mm mn">/*<br/>Called with each keydown event in the known character location input box, the known existing characters input box, or known non-existing characters input box. <br/>*/<br/>processOptions: function () {<br/>  // If there is no information in the current known input box, skip<br/>  if (this.current.length === 0) {<br/>    return<br/>  }</span><span id="4325" class="lh li iq mg b gy mo ml l mm mn">  // First we want to normalize to lowercase list our words list is<br/>  // and replace all '?' characters with '.' which is the single <br/>  // character wildcard in regular expressions<br/>  let regularExpressionString = <br/>               '^' + this.current.toLowerCase().replaceAll('?', '.')</span><span id="6dcb" class="lh li iq mg b gy mo ml l mm mn">  // If the user doesn't put in '?' for the remaining characters<br/>  regularExpressionString += '.*'</span><span id="9303" class="lh li iq mg b gy mo ml l mm mn">  let regularExpression = new RegExp(regularExpressionString)</span><span id="809b" class="lh li iq mg b gy mo ml l mm mn">  // Filter down to just the possible words<br/>  this.possibleWords = possibleAnswers.filter((value) =&gt; {<br/>    // Does it match our known information?<br/>    if (regularExpression.test(value)) {<br/>      // Does in include the characters we know exist?<br/>      if (this.includesCharacters(this.knownLetters.toLowerCase(), value)) {<br/>        /*<br/>          Filter down to words that don't include characters we know <br/>          don't exist or if we don't have any unknown letters.<br/>        */<br/>        return this.notIncludedLetters.length === 0 || this.doNotIncludesCharacters(this.notIncludedLetters.toLowerCase(), value)<br/>      }<br/>    }</span><span id="4748" class="lh li iq mg b gy mo ml l mm mn">    return false</span><span id="cf06" class="lh li iq mg b gy mo ml l mm mn">  })<br/>},</span><span id="66df" class="lh li iq mg b gy mo ml l mm mn">includesCharacters: function (charactersToInclude, targetValue) {<br/>  let tempNeededCharacters = charactersToInclude.split('')<br/>  let returnValue = true<br/>  tempNeededCharacters.forEach((character) =&gt; {<br/>    if (targetValue.indexOf(character) &lt; 0) {<br/>      returnValue = false<br/>    }<br/>  })</span><span id="d7ae" class="lh li iq mg b gy mo ml l mm mn">  return returnValue<br/>},</span><span id="2c92" class="lh li iq mg b gy mo ml l mm mn">doNotIncludesCharacters: function (charactersToNotInclude, targetValue) {<br/>  let tempNeededCharacters = charactersToNotInclude.split('')<br/>  let returnValue = true<br/>  <br/>  tempNeededCharacters.forEach((character) =&gt; {<br/>    if (targetValue.indexOf(character) &gt;= 0) {<br/>      returnValue = false<br/>    }<br/>  })</span><span id="ee07" class="lh li iq mg b gy mo ml l mm mn">return returnValue<br/>}</span><span id="4041" class="lh li iq mg b gy mo ml l mm mn">...</span></pre><p id="ab9c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们遵循的高级流程是将已知字符解析成正则表达式，然后根据该正则表达式测试所有可能的答案。然后，我们进一步过滤这个列表，只过滤出包含我们知道答案的字符的单词。最后，我们过滤掉包含我们知道不应该出现在答案中的字符的单词。</p><p id="6fae" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这给了我们很多选择。在将这个列表呈现到屏幕上之前，限制它可能是有用的，因为你可能会得到数百个可能的答案，这会极大地降低网站的速度。</p><p id="1be4" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这个阶段本身就很有帮助，在完成一系列困难的线索时会有帮助。也就是说，我想更进一步。</p><h2 id="b981" class="lh li iq bd lj lk ll dn lm ln lo dp lp kf lq lr ls kj lt lu lv kn lw lx ly lz bi translated">第二相</h2><p id="464b" class="pw-post-body-paragraph ju jv iq jw b jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr ij bi translated">我想完成的下一个阶段是，虽然第一阶段可以帮助你完成，但没有好的数据，它只能带你到这里。我想完成的下一步是建议可以猜测的单词，这些单词可以帮助过滤剩余的可用单词。让我们概括一下我们将如何实现这一目标。</p><p id="fbf1" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">首先，我们将获取可能的答案列表，并删除所有包含我们知道答案中有字母的单词，以及我们知道答案中没有的字母。因为我们的目标是发现答案中有哪些字母，所以我们希望关注那些我们不知道它们是否在答案中的新字母。</p><p id="cecf" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们的下一步将是收集潜在的过滤列表中每个字符出现的频率。</p><p id="854a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">接下来，我们对每个角色进行排名并给他们打分。我们将通过从最常用到最少使用的字符排序，然后从 26-1 分配分数来实现这一点。剩下的单词可能不包括所有的 26 个字符，但这只是意味着我们没有从 26 到 1 的字符，但这没关系。</p><p id="c8f4" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为了准备下一步，我们列出可能的猜测(可能的答案和允许的列表的组合)。我们可以提前生成可能的猜测列表，并存储或至少在页面加载时生成。</p><p id="0542" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">此时，我们遍历上一步准备好的列表，并为每个单词生成一个分数。该分数是基于在上述步骤中分配给每个角色的分数的总和。例如，如果我们有这样的分数:a = 26，b = 25，d = 24，t = 23，并且单词“bad”和“tad”存在于我们的潜在答案列表中，它们最终会有如下分数:bad = 75 (26 + 25 + 24)，tad = 72 (23 + 25 + 24)。</p><p id="be9b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">最后，我们将所有单词从最高分到最低分进行排序，然后取前 10 名并呈现给用户。没有必要显示很多单词，因为你越深入列表，猜测就越糟糕。</p><h2 id="856c" class="lh li iq bd lj lk ll dn lm ln lo dp lp kf lq lr ls kj lt lu lv kn lw lx ly lz bi translated">代码</h2><p id="83a9" class="pw-post-body-paragraph ju jv iq jw b jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr ij bi translated">这需要几个步骤，但是让我们看一下代码。</p><pre class="kv kw kx ky gt mf mg mh mi aw mj bi"><span id="900c" class="lh li iq mg b gy mk ml l mm mn">calculateGoodLetterWords: function () {<br/>  /*<br/>    remove words from the available answer words that include <br/>    letters we know about.<br/>  */</span><span id="ada7" class="lh li iq mg b gy mo ml l mm mn">  let wordsWithoutCharactersWeKnow = <br/>    this.filterOutWordsWithKnownAndUnknownLetters(possibleAnswers)</span><span id="b764" class="lh li iq mg b gy mo ml l mm mn">  // Gather a count of each character in available answer words<br/>  let characterMap = {}<br/>  wordsWithoutCharactersWeKnow.forEach((value) =&gt; {<br/>    value.split('').forEach((character) =&gt; {<br/>      characterMap[character] = (characterMap[character] | 0) + 1<br/>    })<br/>  })</span><span id="3cc9" class="lh li iq mg b gy mo ml l mm mn">  // Sort the characters in order of use.<br/>  let characterMapArray = []<br/>  for (const character in characterMap) {<br/>    characterMapArray.push({character: character,<br/>                            value: characterMap[character]})<br/>  }<br/>  let sortedCharacterMapArray = characterMapArray.sort((a, b) =&gt; {<br/>    return b.value - a.value<br/>  })</span><span id="b320" class="lh li iq mg b gy mo ml l mm mn">  /*<br/>    Assign a score to each character based on how many times it <br/>    appears in the available word list<br/>  */</span><span id="5fa7" class="lh li iq mg b gy mo ml l mm mn">  let currentScore = 26<br/>  let scoredCharacterMap = {}<br/>  for (let index in sortedCharacterMapArray) {<br/>    scoredCharacterMap[sortedCharacterMapArray[index].character] = currentScore<br/>  currentScore--<br/>  }</span><span id="2225" class="lh li iq mg b gy mo ml l mm mn">  /*<br/>    Remove words from the possible guess list that includes letters we <br/>    know about.<br/>  */</span><span id="7b6d" class="lh li iq mg b gy mo ml l mm mn">  let guessesWithoutCharactersWeKnow = <br/>    this.filterOutWordsWithKnownAndUnknownLetters(<br/>                                               this.possibleGuesses)<br/>  // Score each available word based on its character usage.<br/>  let scoredWordList = guessesWithoutCharactersWeKnow.map((value) =&gt; <br/>    {<br/>      let score = 0<br/>      let seenLetters = ''<br/>      value.split('').forEach((character) =&gt; {<br/>        // Don't double count scores for duplicate letters.<br/>        if (seenLetters.indexOf(character) &lt; 0) {<br/>          seenLetters += character<br/>          score += scoredCharacterMap[character]<br/>        }<br/>   })<br/>  <br/>   return {word: value, score: score}<br/>  })</span><span id="4c6c" class="lh li iq mg b gy mo ml l mm mn">  // Order words by score and return the top 10.<br/>  let orderedScoredWordList = scoredWordList.sort((a, b) =&gt; {<br/>    return b.score - a.score<br/>  }).map((value) =&gt; value.word)<br/>  .slice(0, 10)<br/>  <br/>  this.goodLetterGuesses = orderedScoredWordList<br/>},</span><span id="b584" class="lh li iq mg b gy mo ml l mm mn">filterOutWordsWithKnownAndUnknownLetters: function (words) {<br/>  return words.filter((value) =&gt; {<br/>    return <br/>      this.doNotIncludesCharacters(<br/>              this.notIncludedLetters.toLowerCase(), value) &amp;&amp;<br/>     this.doNotIncludesCharacters(this.knownLetters.toLowerCase(), value) &amp;&amp;<br/>     this.doNotIncludesCharacters(this.current.toLowerCase(), value)</span><span id="214c" class="lh li iq mg b gy mo ml l mm mn">    })<br/>  }<br/>}</span></pre><p id="6c9c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">把所有这些放在一起，我们就有了一个解决字谜的可靠工具。使用这两个功能，你可以在几个回合内解决任何问题。看它如何解谜是非常有趣的，因为它不是寻找每个字符去哪里，而是试图找出答案中的字符，并将选项限制在可猜测的选项数量内。</p><h2 id="5e84" class="lh li iq bd lj lk ll dn lm ln lo dp lp kf lq lr ls kj lt lu lv kn lw lx ly lz bi translated">少了什么</h2><p id="6c52" class="pw-post-body-paragraph ju jv iq jw b jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr ij bi translated">我认为最大的功能缺失是，它没有考虑到我们知道角色不存在的地方。虽然它考虑到了我们知道单词中有一个“S ”(举例来说),但它没有考虑到我们知道字符不会出现在哪里。这就是说，我不认为它会有很大帮助，用户界面可能很难让用户清楚如何输入这些信息。</p><h2 id="8aa0" class="lh li iq bd lj lk ll dn lm ln lo dp lp kf lq lr ls kj lt lu lv kn lw lx ly lz bi translated">摘要</h2><p id="2bc1" class="pw-post-body-paragraph ju jv iq jw b jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr ij bi translated">虽然这不是一个复杂的网站，但它很有趣。深入研究游戏是如何设计的，并考虑如何限制问题集的语义，这是一件令人愉快的事情。总而言之，我认为这是值得的。使用网站会让游戏失去很多乐趣，但解决方案的设计才是乐趣所在。这可能也不是解决这个问题的最佳方式，如果你有其他想法，如何更好地在源代码上打开 PR<a class="ae kt" href="https://github.com/kylec32/wordle-cheater" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><h2 id="a391" class="lh li iq bd lj lk ll dn lm ln lo dp lp kf lq lr ls kj lt lu lv kn lw lx ly lz bi translated">先前技术</h2><p id="7503" class="pw-post-body-paragraph ju jv iq jw b jx ma jz ka kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr ij bi translated">我不是第一个分析 Wordle 如何工作以及如何分解最有利的字母的人。其他一些伟大的作品可以在以下链接中找到:</p><ul class=""><li id="fc2f" class="mp mq iq jw b jx jy kb kc kf mr kj ms kn mt kr mu mv mw mx bi translated"><a class="ae kt" href="https://withoutbullshit.com/blog/wordle-revised-mathematical-analysis-of-the-first-guess" rel="noopener ugc nofollow" target="_blank"> Wordle:修正了第一次猜测的数学分析</a></li><li id="e9de" class="mp mq iq jw b jx my kb mz kf na kj nb kn nc kr mu mv mw mx bi translated"><a class="ae kt" href="https://github.com/gabeclasson/wordle-analysis" rel="noopener ugc nofollow" target="_blank">文字分析</a></li><li id="9749" class="mp mq iq jw b jx my kb mz kf na kj nb kn nc kr mu mv mw mx bi translated"><a class="ae kt" href="https://virtu.is/wordle-strategies-analysis-part-i/" rel="noopener ugc nofollow" target="_blank"> Wordle 策略分析</a></li></ul></div></div>    
</body>
</html>