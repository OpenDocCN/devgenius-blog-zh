# 高级 C# —自定义工作流引擎

> 原文：<https://blog.devgenius.io/advanced-c-custom-workflow-engine-a52ba44bb2c4?source=collection_archive---------0----------------------->

*根据您的需求进行构建*

![](img/74ef9cde8e971c3a2d15222570facbd3.png)

克莱顿·罗宾斯在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 拍摄的照片

创建工作流系统的原因有很多。可能是您的用户想要他们可以管理的自定义流。您可能希望为数据创建一个处理管道。或者简单到想要编写封装性更强、更易于管理的代码，跳过一些常见应用程序中需要的样板文件。

所有这些都是有效的用例(还有很多很多)。现实是，生活中的一切都围绕着“活动”展开。在工作中，在家里，甚至在我们的思想中，我们都在处理过程和程序。这些流程中的每一步或每一项活动，在您每次激活它们时，可能都是一样的。因此，当您可以创建一个工作流引擎来为您做这些事情时，为什么要重写代码，或者手动地做这些事情呢？

现在，你不能把它应用到生活中的任何事情上(很明显)。但是你可以用代码把复杂的主题转化成工作流引擎。好处是我们可以在代码中避免许多嵌套的或者可配置的`if-then`语句。你能想象编写一个动态的工作流，要求在我们的核心代码中直接检查每一步，其中有嵌套的 if 语句 5 深吗？这将是一场噩梦(当然，大多数开发人员不会这样做)。

但是回过头来看看你在 Web API 中创建的代码或服务。它可能是用某种工作流实现的吗？它的加工过程很复杂吗？你是否在多个地方使用管道的一部分，但是它是硬编码的，你必须在多个地方改变它？

工作流也更容易阅读，更长期。底层系统本身通常很复杂，但是利用框架很容易。这是我们节省时间的地方。

已经有很多很棒的工作流系统了。我的目标不是让这些过时，或者建议在这些框架上使用下面的方法。您应该调查这些，并确定哪一个最符合您的需求。每种方法的工作流程的想法非常不同，并有独特的优势和劣势

*   [工作流核心](https://github.com/danielgerlag/workflow-core):轻量级嵌入式工作流引擎定位。净标准
*   [Elsa Workflows](https://github.com/elsa-workflows/elsa-core) :支持在任何环境下执行工作流的库。NET 核心应用程序，并可以在代码中定义或使用可视化设计器。
*   [automatonymouss](https://github.com/MassTransit/Automatonymous):一个状态机库。NET 为事件、状态和活动提供了流畅的语法

还有很多比这更多的。这些只是我一起工作过并喜欢的。这将是您的选择，以决定这些是否对您的用例来说是多余的，或者是否具有您需要的特性。但是，如果没有，或有疑问，建立自己的满足您的需求！

让我们走一遍。

> 注意:我提到了工作流，并在 [C#简单接口:容器](/c-simple-interfaces-containers-f2980e76b2bd)中提供了一个非常相似的例子。本文将更全面地解释和实现。

# 活动

对于任何工作流，活动都是关键。我们希望根据特定条件执行一项或一组任务。复杂性不一定在于活动本身，而在于条件何时发挥作用，以及我们希望开发人员如何与引擎的契约进行交互。

让我们从定义活动本身的一些细节开始，

这组接口为我们提供了一个非常简单的活动框架，并将成为我们工作流系统的核心(尽管在本文后面会有所变化)。事实上，如果我们愿意，我们可以添加一些扩展，然后停止，如果这对您的需求足够好的话。

我们只添加了一个扩展类型`Then`，它将简单地一个接一个地运行一个活动。

## 处理活动

现在我们有了自己的活动，我们需要处理它们。有很多方法可以做到这一点，但我们将只为系统创建另一个接口和实现。

基本流道界面

然后是一个实现，

该服务基本上将遍历集合中的每个活动，并在一个循环中连续运行它们，直到完成，或者直到被活动本身取消。我们将基于类型创建一个活动，或者直接运行提供的实例。我们在这里没有执行任何优化，比如创建缓存活动，但是这可以很容易地添加。

> 注意:定制活动可以注入服务。这就是我用`ActivatorUtilities`的原因。它为我们提供这项服务。但是，这也意味着该活动必须向 DI 注册。

别忘了我们需要一个`IActivityCollection`的基本实现。

它不必比这复杂得多，尽管您可能希望对它进行一些定制。真的取决于你。

最后一点是我们如何使用这个简单的引擎。假设您有以下已定义的活动:

*   `ProcessDatabaseRecordsActivity`:进入数据库并处理任何可用的记录。
*   `DataWarehouseActivity`:获取数据库中的当前数据，并推送到数据仓库。
*   在流程结束时给你发电子邮件，告诉你流程已经成功完成。

您可以通过构造函数注入来定制这些活动，但是它们之间不传递数据。我们稍后会解决这个问题。

让我们展示一个简单的使用示例，

就是这样！我们已经创建了一个实际工作的基本工作流引擎。然而，我会第一个承认这还不是一个灵活的实现。这种方法存在一些问题:

1.  **数据不能在步骤**之间“共享”。如果我们不想要一个中心资源，比如一个数据库，来协调这些信息呢？
2.  **我们必须为哪怕是最简单的任务创建一个定制活动**。我们能不能找到一种方法，将 lambdas 用于非常基本的步骤，比如改变数据中的一个属性？
3.  我们没有任何类型的条件逻辑。我们如何在工作流中实现基于数据的`if-then`逻辑？

让我们来解决其中的一些问题。

# 传递数据和上下文对象

我见过三种在工作流程中的步骤之间共享数据的主要方法:

1.  **共享上下文对象**:创建一个单独的对象，所有步骤都可以看到该对象的任何变化。
2.  **成对输入/输出匹配**:每一步取一个特定的输入对象类型，输出一个特定的返回类型。这种方法要求输入与输出匹配，否则会出现阻抗不匹配。
3.  **全局基于步骤的数据**:每一步完成后，可以设置输出数据，后续步骤可以通过引用前一步的输出属性进行访问。在基于 UI 的界面中最有用，其中的步骤在设计中是众所周知的。

像其他事情一样，也有取舍。**在强类型语言中，共享上下文对象**是最容易实现的，但是在出现问题时，当试图确定谁在改变对象时，调试可能会很棘手。**成对输入/输出匹配**适用于 ETL 应用程序，在这种应用程序中，数据正在被转换，并且您想要控制步骤构建(想想函数式编程)。就可用用例而言，它的局限性要大得多，而且很大程度上可能会抵制变更。**全局基于步骤的数据**在基于 UI 的界面中非常有用，在这种界面中，用户希望直接访问数据，了解他们的流程，但对于动态工作流或基于代码的工作流则不太有用。

我将采用**共享上下文对象**方法，因为它简单且有多种用例。我相信它将在大多数开发者用例中提供最大的价值。

## 结构和合同的变化

我们需要对我们的活动定义进行一些调整，以使其工作。让我们展示添加了上下文的更改后的接口和结构。

然后改变的扩展，

我们需要集合本身的另一个实现，

不要走太远，一个简单的用法，

现在我们可以为我们的活动提供一个特定的上下文对象，只要该对象实现了`IActivityContext`。我们可以定制它，添加功能。任何事。然而，每组步骤在运行时只能有一个上下文对象(另一个限制)。

我想在这里暂停一下，谈谈这个问题。以前，我们不必在扩展方法中指定上下文。相反，它们非常简单明了。然而，扩展方法在这里有所欠缺。其实并不是扩展方法本身，而是方法泛型的本质。

在指定泛型时，不要陷入太深的混乱，您要么需要指定所有的泛型参数，要么一个都不指定(当它们可以被隐含时)。没有任何中间或部分支持。因此，在我们想要指定类型的情况下，我们会遇到一点问题。从可用性的角度来看，我真的不喜欢这样。

我们怎样才能做得更好？

## 集合生成器

我们将不得不创建一个特定的构建器接口。

暂时忽略这个接口的实现，现在让我们看看它的用法，

现在，我觉得这样更好。这也意味着我们之前为`Then`创建的扩展方法不再需要了。相反，我们将不得不使用构建器来获得我们想要的语法糖。这意味着，我们还必须在将来的扩展中使用它。因此，不是在`IActivityCollection`上扩展，大部分将在`IActivityCollectionBuilder`上。

## 对跑步者的更改

对于这个新结构，我们仍然没有一个带有上下文对象的运行程序。因此，为了完整起见，让我们创建它。

首先，界面需要改变，

然后我们的 runner 实现，

没有什么变化，除了我们现在必须传入一个上下文对象来运行活动。也许你想传入一个 creator lambda？或者，您的上下文对象是一个 DTO，您希望自动为您创建它。我们可以创建几个扩展方法来简化这一过程。

> 同样，这些是生活质量的延伸。它们不是必需的。

为了完整起见，我还将提供一个可以继承的基类`ActivityContext`。现在，它只会让你不必重新实现`Cancel`属性。但在你的情况下，可能不只是一处房产。

# 简单的任务

既然我们的工作流引擎已经有了一个核心框架，也许我们应该为简单的任务做一些生活质量的调整。例如，在一个步骤之后，您可能想要基于一些简单的逻辑改变您的上下文，或者甚至只是设置一个属性。让我们创建几个活动实现，以及相关的扩展方法，这将有助于我们解决这个问题。

首先是活动，

所有这些活动提供的是将在运行时执行的 lambda 的持有者。有些情况下，你会有一些同步代码，所以我们添加了一个`async`版本和一个`void`版本。

为了便于使用，我们创建了相关的扩展方法，

这些方法的使用非常简单，

有时候，在这个流程中定义定制逻辑是有意义的。然而，任何大于几行的内容都会降低可读性。所以当你使用它的时候要小心。无论哪种方式，它都有助于避免为简单任务创建大量定制活动的需要。

# 条件逻辑、循环和异常处理

工作流中的条件(有时称为决策点)如何？如果我们需要连续多次运行一个流程，该怎么办？或者我们如何处理异常？

尽管这些都是独特的情况，但我们将对它们使用类似的技术，我们创建一个聚合活动，并使用子构建器来扩展它们。

## 默认生成器

此时，我们还没有真正定义我们的构建器。之前只是假设。然而，我们现在需要定义它。

构建器为集合定义了一个私有类。有些情况下这不是我们想要的，但是我们允许这样做，以确保实现是我们想要的。但是，在某些情况下，可能需要自定义集合类型。在这种情况下，就需要某种形式的`IActivityCollectionFactory`。

其他一切，应该不言自明。我们为`Then`添加合适的方法。然后我们在构建期间返回集合。我确保我们替换了支持字段，这样构建器在这之后就不能再修改它了。

> 通常，我会将这个生成器设置为内部类。这保护了它的使用，也允许我只公开开发人员正确使用它所需的部分。这里，在我们的示例中，为了便于使用，它是公共的。但是，在需要公开类之前，总是尽量将类保持在内部。EN-CAP-sulation

## 我们会遇到一个小问题…

我们就要遇到障碍了。不幸的是，这需要一些重构。看，我们想要使用`IActivityCollection`作为我们活动的输入。但是，它是一个`ActivityDescriptor`的集合。这意味着活动的创建和运行会给我们带来一些痛苦，尤其是在运行时。我们可能有一辆`IActivity`来运行，但也可能没有。我们可能需要创建一个`Type`。为了创造这些类型，我们需要`IServiceProvider`。

越来越复杂了。

所以，也许，让我们创建一个活动来代替这个创建，允许我们只有一个继承了`IList<IActivity>`的`IActivityCollection`。

> 抱歉，如果你觉得我们在实现上反复无常。这就是重构的过程。我希望它能为我的过程提供一些水平的理解。

首先让我们更改集合接口，

我们简单地从`ActivityDescriptor<TContext>`换成`IActivity<TContext>`。不会比这更复杂。

我们必须改变我们的构建者来注入提供者。我们还需要在这里更改我们的集合实现(很高兴我们把它放在这里。几乎对用户隐藏了更改)。

构建器界面发生变化，

我们添加了一个`StartNew`方法，它将作为希望以干净的集合重新开始的子系统的工厂。

或许展示一下`ServiceProviderActivity`本身也不错，

我们的跑鞋也需要更换，

我们能够稍微简化这个类，去掉`GetActivity`部分。

现在说到用法，

这里最大的变化是使用了`DefaultActivityCollectionBuilder`并传入了`IServiceProvider`。此时，我们可以继续学习条件句。

## 条件逻辑

我们将创建一个非常简单的`If-Then-Else`条件逻辑活动。我们可以选择在同一个活动中只提供`If-Then`逻辑或`If-Then-Else`。

我们在做什么？我们传递两组活动和一个条件。条件将决定运行哪个集合。然后基于所述条件适当地运行收集。

你说，生活质量的改善在哪里？这些是下一个！

我们使用`Then`方法来创建条件活动。现在问题变成了对程序员来说这看起来像什么？让我们看看用法，

在我们处理完数据后，我们将检查是否成功设置了一个标志。如果我们成功，那么我们将运行一个成功的电子邮件活动，否则，失败。

## 环

我不会讨论各种循环的所有可能的实现，但我会展示一个，一个重复循环。

重复活动的目标是使用静态计数或基于上下文的属性多次运行同一组活动。

很简单。我们可以传入一个将基于上下文计算的函数，或者我们可以直接传入计数。让我们创建这些扩展，

最后，是用法，

我鼓励你添加任何其他可能有用的扩展。也许你只想通过一个活动。例如，你可以用一个扩展名来代替`count`和`IActivity<TContext>`。

## 异常处理

最后一个常见的问题是异常的处理。你可以自己在活动中做到这一点。但是，如果您想根据特定的异常情况改变路线，该怎么办呢？与最后两种方法类似，我们将为此创建一个特殊的活动。

先来展示一下活动，

我把它保持得有点简单。您为`try`子句和可选的`finally`子句传入一组活动。对于`catch`子句，我们使用了一个`Type`和活动集合的列表。在捕捉异常时，我们希望使用与真正的`try-catch`相似的逻辑。因此，我们在集合中找到第一个可赋值的异常。如果没有，那么我们再掷一次。

> 注意，最佳实践是我们应该为`CatchActivityCollection`提供一个接口。为了简洁起见，我省略了这一点。

让我们看看扩展，

最后是用法，

我承认，从可读性的角度来看，这可能更好。我认为我们可以找到一些方法来改善它，但希望你能明白。

# 结论和签署

嗯，那确实是很多代码。我们创建了一个简单的工作流引擎，可以用于无限的用例。然而，它也有一些缺点，

1.  **保存/加载**:很难从文件或数据库中动态保存/加载该结构。一切都是作为实例而不是描述符创建的。
2.  **配置限制**:配置仅限于可以注入到活动的构造函数中的内容。也许这没问题，但是动态改变配置可能是一个有用的特性。
3.  **缺少状态机**:这里没有真正使用状态机。理论上你可以用上下文对象运行一个状态机，但是如果你不想让所有的东西同时运行呢？如果您希望以后继续工作流，该怎么办？

这绝不是一个完美的工作流程系统。这个版本可以用在很多方面，但不是在每种情况下。至少我希望你学到了一些不同的技术，可以在设计下一个系统时使用。

如果你有任何想法或建议，请在下面评论。请务必**在 medium 上关注我**，因为我会一直发布新的话题！

下次见！