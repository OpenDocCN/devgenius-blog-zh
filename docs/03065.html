<html>
<head>
<title>Piping and Functors in Javascript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Javascript 中的管道和函子</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/piping-and-functors-in-javascript-f7ca276703c?source=collection_archive---------4-----------------------#2020-09-25">https://blog.devgenius.io/piping-and-functors-in-javascript-f7ca276703c?source=collection_archive---------4-----------------------#2020-09-25</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/5f9bcbcc682c4cab0fa9caf863a9029d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hvV7YIERDylqMqM48-iqTw.png"/></div></div></figure><p id="905b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">JavaScript 部分是一种函数式语言。</p><p id="b1a3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">学习 JavaScript，就要学习 JavaScript 的功能部分。</p><p id="4582" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在本文中，我将讨论 JavaScript 的管道函数和函子。</p><h1 id="4791" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">管</h1><p id="4357" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">您可以通过创建一个以函数数组作为参数的函数来创建一个<code class="fe lw lx ly lz b">pipe</code>函数。</p><p id="9c65" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">它返回一个带值的函数，你用它调用<code class="fe lw lx ly lz b">reduce</code>，用<code class="fe lw lx ly lz b">acc</code>调用<code class="fe lw lx ly lz b">fn</code>。</p><p id="191a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">例如，您可以写:</p><pre class="ma mb mc md gt me lz mf mg aw mh bi"><span id="482b" class="mi ku in lz b gy mj mk l ml mm">const compose = (...fns) =&gt;<br/>  (value) =&gt;<br/>  fns.reduceRight((acc, fn) =&gt; fn(acc), value)</span></pre><p id="03e0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">唯一的区别是你使用了<code class="fe lw lx ly lz b">reduceRight</code>而不是<code class="fe lw lx ly lz b">reduce</code>，这样你就不需要调用<code class="fe lw lx ly lz b">reverse</code>来应用所有的功能。</p><h1 id="0522" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">构图是联想的</h1><p id="89c5" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">组合是关联的，这意味着您可以重新排列操作的括号</p><p id="c76b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">例如:</p><pre class="ma mb mc md gt me lz mf mg aw mh bi"><span id="ef97" class="mi ku in lz b gy mj mk l ml mm">compose(f, compose(g, h)) == compose(compose(f, g), h)</span></pre><p id="5a91" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">返回<code class="fe lw lx ly lz b">true</code>。</p><h1 id="de64" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">函子</h1><p id="0827" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">Functor 是一个普通对象，它在运行 River each value 以生成新对象时实现函数<code class="fe lw lx ly lz b">map</code>。</p><p id="f5e0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">函子是一个在其中保存一些值的容器。</p><p id="738d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">例如，您可以写:</p><pre class="ma mb mc md gt me lz mf mg aw mh bi"><span id="d8ba" class="mi ku in lz b gy mj mk l ml mm">const Container = function(val) {<br/>  this.value = val;<br/>}</span></pre><p id="4045" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">创建您的容器。</p><p id="c777" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后您可以使用<code class="fe lw lx ly lz b">new</code>来调用<code class="fe lw lx ly lz b">Container</code>构造函数:</p><pre class="ma mb mc md gt me lz mf mg aw mh bi"><span id="ea78" class="mi ku in lz b gy mj mk l ml mm">let foo = new Container(3);</span></pre><p id="0f71" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您可以创建一个<code class="fe lw lx ly lz b">Container.of</code>属性来添加一个容器，让我们返回一个<code class="fe lw lx ly lz b">Container</code>实例:</p><pre class="ma mb mc md gt me lz mf mg aw mh bi"><span id="c7a6" class="mi ku in lz b gy mj mk l ml mm">const Container = function(val) {<br/>  this.value = val;<br/>}</span><span id="3a06" class="mi ku in lz b gy mn mk l ml mm">Container.of = function(value) {<br/>  return new Container(value);<br/>}</span></pre><p id="a94b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您添加了静态方法<code class="fe lw lx ly lz b">of</code>来返回一个<code class="fe lw lx ly lz b">Container</code>实例。</p><p id="dc0a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe lw lx ly lz b">of</code>方法只是为您提供了一种使用<code class="fe lw lx ly lz b">new</code>操作符创建<code class="fe lw lx ly lz b">Container</code>实例的替代方法。</p><p id="69cd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后您可以用<code class="fe lw lx ly lz b">of</code>方法创建一个<code class="fe lw lx ly lz b">Container</code>实例:</p><pre class="ma mb mc md gt me lz mf mg aw mh bi"><span id="ab5a" class="mi ku in lz b gy mj mk l ml mm">const nested = Container.of(Container.of(1));</span></pre><p id="c59f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后您将看到嵌套的<code class="fe lw lx ly lz b">Container</code>实例。</p><h1 id="c651" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">仿函数实现名为 map 的方法</h1><p id="0d04" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">函子实现了<code class="fe lw lx ly lz b">map</code>方法。</p><p id="9fd8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您可以通过将它添加到<code class="fe lw lx ly lz b">prototype</code>属性来将其作为实例方法添加:</p><pre class="ma mb mc md gt me lz mf mg aw mh bi"><span id="944c" class="mi ku in lz b gy mj mk l ml mm">const Container = function(val) {<br/>  this.value = val;<br/>}</span><span id="35f0" class="mi ku in lz b gy mn mk l ml mm">Container.of = function(value) {<br/>  return new Container(value);<br/>}</span><span id="5be3" class="mi ku in lz b gy mn mk l ml mm">Container.prototype.map = function(fn) {<br/>  return Container.of(fn(this.value));<br/>}</span></pre><p id="734f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后，您可以在创建一个<code class="fe lw lx ly lz b">Container</code>实例后使用<code class="fe lw lx ly lz b">map</code>方法。</p><p id="dd6c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">例如，您可以通过编写以下内容来使用它:</p><pre class="ma mb mc md gt me lz mf mg aw mh bi"><span id="b617" class="mi ku in lz b gy mj mk l ml mm">const squared = Container.of(3).map(a =&gt; a ** 2);</span></pre><p id="72e9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">那么<code class="fe lw lx ly lz b">squared</code>就是<code class="fe lw lx ly lz b">value</code>为 9 的<code class="fe lw lx ly lz b">Container</code>实例。</p><p id="3da7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">可以反复调用<code class="fe lw lx ly lz b">map</code>来重复一个操作。</p><p id="bdcb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这意味着你可以写:</p><pre class="ma mb mc md gt me lz mf mg aw mh bi"><span id="7a91" class="mi ku in lz b gy mj mk l ml mm">const squared = Container.of(3)<br/>  .map(square)<br/>  .map(square)<br/>  .map(square);</span></pre><p id="9d27" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">那么<code class="fe lw lx ly lz b">squared</code>就是一个<code class="fe lw lx ly lz b">Container</code>实例，其中<code class="fe lw lx ly lz b">value</code>为 6561。</p><p id="e29e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Functor 只是一个实现了<code class="fe lw lx ly lz b">map</code>方法的对象。</p><h1 id="b7e8" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">结论</h1><p id="51a9" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">函子是有值的普通对象。</p><p id="dfa2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">该对象有一个<code class="fe lw lx ly lz b">map</code>方法。</p><p id="7e00" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您可以通过管道函数来调用多个函数并获得返回值。</p><p id="6576" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">组合是关联的，所以你可以重新安排我们操作的括号。</p><p id="b60c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">今天就到这里，谢谢大家的关注。</p></div></div>    
</body>
</html>