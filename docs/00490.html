<html>
<head>
<title>Drawing with HTML and JavaScript : Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用HTML和JavaScript绘图:第1部分</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/drawing-with-html-and-javascript-part-1-d2ef829c084c?source=collection_archive---------40-----------------------#2020-06-08">https://blog.devgenius.io/drawing-with-html-and-javascript-part-1-d2ef829c084c?source=collection_archive---------40-----------------------#2020-06-08</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><figure class="gm go jp jq jr js gi gj paragraph-image"><div role="button" tabindex="0" class="jt ju di jv bf jw"><div class="gi gj jo"><img src="../Images/399417917d8023c06d2583984b946c40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GDHF7pfrjgSTpMvJ"/></div></div><figcaption class="jz ka gk gi gj kb kc bd b be z dk translated">Artem Sapegin 在<a class="ae kd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="1ae2" class="pw-post-body-paragraph ke kf ir kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">所以，你已经有了一个很棒的网站，但你不禁会想，还缺少一样东西可以让它变得更好？</p><p id="3396" class="pw-post-body-paragraph ke kf ir kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">画画！</p><p id="f6ac" class="pw-post-body-paragraph ke kf ir kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">使用canvas元素和一些JavaScript向网站添加绘图功能并不困难。我们将看看需要做些什么来开始，未来我们将对其进行扩展以使其变得更好。</p><p id="2be4" class="pw-post-body-paragraph ke kf ir kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">显然，您需要一个HTML页面。用样板文件创建一个空的HTML页面，当然，也可以选择一个已经准备好的页面来添加。</p><p id="e029" class="pw-post-body-paragraph ke kf ir kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">添加一个带有类似“myDrawing”的id属性的canvas元素。</p><blockquote class="lc ld le"><p id="736c" class="ke kf lf kg b kh ki kj kk kl km kn ko lg kq kr ks lh ku kv kw li ky kz la lb ik bi translated"><canvas id="”myDrawing”"> </canvas></p></blockquote><p id="8ec2" class="pw-post-body-paragraph ke kf ir kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">完成了吗？非常好。现在开始JavaScript。</p><p id="c03a" class="pw-post-body-paragraph ke kf ir kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">创建一个名为<strong class="kg is"> <em class="lf"> drawing.js </em> </strong>的新JavaScript文件</p><p id="01f1" class="pw-post-body-paragraph ke kf ir kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">让我们从一些我们需要的变量开始。</p><blockquote class="lc ld le"><p id="e427" class="ke kf lf kg b kh ki kj kk kl km kn ko lg kq kr ks lh ku kv kw li ky kz la lb ik bi translated">var drawCanvas = null<br/>var mouse pressed = false；<br/> var lastX，lastY<br/>var CTX；</p></blockquote><p id="d2ba" class="pw-post-body-paragraph ke kf ir kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">这些将存储画布元素本身。告诉我们鼠标是否被按下的布尔值。最后绘制的位置(lastX，lastY)和画布上下文。</p><p id="bafd" class="pw-post-body-paragraph ke kf ir kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">现在，添加一个新函数，我们将使用它来获取鼠标在绘图画布中的位置。</p><blockquote class="lc ld le"><p id="2d51" class="ke kf lf kg b kh ki kj kk kl km kn ko lg kq kr ks lh ku kv kw li ky kz la lb ik bi translated">函数get offset(){<br/>var rect = draw canvas . getboundingclientrect()；</p><p id="3ae8" class="ke kf lf kg b kh ki kj kk kl km kn ko lg kq kr ks lh ku kv kw li ky kz la lb ik bi translated">var offset = {<br/>top:rect . top+window . scrolly，<br/>left:rect . left+window . scrollx，<br/>}；<br/> <br/>返回偏移量；<br/> }</p></blockquote><p id="a2fe" class="pw-post-body-paragraph ke kf ir kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">该函数获取canvas元素的顶部和左侧点位置，然后考虑页面的滚动(如果相关的话),以给出canvas元素在页面中的正确左上位置(或偏移量)。我们需要这样做，因为我们必须告诉绘图代码从相对于画布左上角的正确位置开始绘制，而不是页面本身。</p><p id="2d87" class="pw-post-body-paragraph ke kf ir kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">现在，让我们创建一个函数来实际绘制一些东西。</p><blockquote class="lc ld le"><p id="ea86" class="ke kf lf kg b kh ki kj kk kl km kn ko lg kq kr ks lh ku kv kw li ky kz la lb ik bi translated">函数Draw(x，y，is down){<br/>if(is down){<br/>CTX . begin path()；<br/>CTX . stroke style = ' blue '；<br/>CTX . line width = 2；<br/>CTX . line join = " round "；<br/> ctx.moveTo(lastX，lastY)；<br/> ctx.lineTo(x，y)；<br/>CTX . close path()；<br/>CTX . stroke()；<br/>}<br/>lastX = x；lastY = y；<br/> }</p></blockquote><p id="cb00" class="pw-post-body-paragraph ke kf ir kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">正如你所看到的，这是一个进行实际绘图的函数。首先确认鼠标按下。有几个值得注意的事情，你可以看到很容易改变定制选项。</p><blockquote class="lc ld le"><p id="6b11" class="ke kf lf kg b kh ki kj kk kl km kn ko lg kq kr ks lh ku kv kw li ky kz la lb ik bi translated">ctx.strokeStyle = ' blue</p></blockquote><p id="d3f1" class="pw-post-body-paragraph ke kf ir kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">这将设置绘图的颜色。在这种情况下，蓝色，但任何有效的颜色都可以。在未来，我们将会考虑让用户能够设置它。</p><blockquote class="lc ld le"><p id="c112" class="ke kf lf kg b kh ki kj kk kl km kn ko lg kq kr ks lh ku kv kw li ky kz la lb ik bi translated">CTX . line width = 2；</p></blockquote><p id="48fa" class="pw-post-body-paragraph ke kf ir kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">这设置了我们将用来在画布上绘制的画笔的大小(以像素为单位)。2号相当好，而20号就太厚了。</p><p id="77ba" class="pw-post-body-paragraph ke kf ir kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">然后我们告诉它在我们的最后一个点和当前点之间绘制，然后将当前点更新为最后一个点。基本上，当你按住按钮并拖动鼠标时，它会画出数百条细线，最终形成一幅流畅的图画。</p><p id="a62b" class="pw-post-body-paragraph ke kf ir kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">这就是实际绘图的函数，但是我们还需要初始化它并设置一些事件处理程序，这样我们就可以使用这个函数在画布上绘图。</p><p id="c5a2" class="pw-post-body-paragraph ke kf ir kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">让我们创建一个初始化函数，我们可以调用它来激活这个绘图工具。</p><blockquote class="lc ld le"><p id="761f" class="ke kf lf kg b kh ki kj kk kl km kn ko lg kq kr ks lh ku kv kw li ky kz la lb ik bi translated">函数InitDrawingMode(el，width，height) {</p><p id="042b" class="ke kf lf kg b kh ki kj kk kl km kn ko lg kq kr ks lh ku kv kw li ky kz la lb ik bi translated">draw canvas = document . getelementbyid('+El)；<br/>CTX = draw canvas . get context(" 2d ")；<br/><br/>draw canvas . width = width；<br/>draw canvas . height = height；</p></blockquote><p id="a953" class="pw-post-body-paragraph ke kf ir kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">如您所见，我们的函数期望被传递canvas元素id的名称。我们可以让它自动检测，但这是一个简单的方法，允许我们指定和控制多个每页，如果我们想要的。</p><p id="f6d2" class="pw-post-body-paragraph ke kf ir kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">我们通过获取元素本身和画布的上下文来填充我们已经声明的一些初始变量，画布可以用于绘图。你会注意到我们要求的上下文是“2d”。</p><p id="6454" class="pw-post-body-paragraph ke kf ir kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">然后，我们设置画布框的精确宽度和高度。这是使绘图功能适当缩放所必需的。我们在这里传递我们想要的高度和宽度来进行控制，但是我们也可以在将来动态地得到它。</p><blockquote class="lc ld le"><p id="2d81" class="ke kf lf kg b kh ki kj kk kl km kn ko lg kq kr ks lh ku kv kw li ky kz la lb ik bi translated">draw canvas . addevent listener(' mousedown '，function(e)<br/>{<br/>var offset = get offset()；<br/>mouse pressed = true；<br/> Draw(e.pageX — offset.left，e.pageY — offset.top，false)；<br/> <br/> }，假)；</p></blockquote><p id="e1df" class="pw-post-body-paragraph ke kf ir kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">这是我们的第一个eventListener，它将捕获<strong class="kg is"> <em class="lf"> mousedown </em> </strong>事件。当按下鼠标按钮时会发生这种情况。如您所见，我们得到了画布元素的偏移量。然后我们将<strong class="kg is"> <em class="lf"> mousePressed </em> </strong>布尔值设置为true，因为鼠标被按下了。我们不想在初始压力下绘制，所以我们将false传递给draw函数。这意味着它将正确设置<strong class="kg is"> <em class="lf"> lastX </em> </strong>和<strong class="kg is"> <em class="lf"> lastY </em> </strong>而无需绘图。实际的绘图将来自我们的下一个事件处理程序。</p><blockquote class="lc ld le"><p id="cd8a" class="ke kf lf kg b kh ki kj kk kl km kn ko lg kq kr ks lh ku kv kw li ky kz la lb ik bi translated">draw canvas . addevent listener(' mousemove '，function(e)<br/>{<br/>if(mouse pressed){<br/>var offset = get offset()；<br/> Draw(e.pageX — offset.left，e.pageY — offset.top，true)；<br/> } <br/> <br/> }，假)；</p></blockquote><p id="359e" class="pw-post-body-paragraph ke kf ir kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">除了我们正在捕捉<strong class="kg is"> <em class="lf"> mousemove </em> </strong>事件，检查按钮是否被按下并实际进行绘制之外，情况几乎相同。</p><p id="8c51" class="pw-post-body-paragraph ke kf ir kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">我们还需要处理按钮不再被按下时的<strong class="kg is"> <em class="lf"> mouseup </em> </strong>事件。我们还想在鼠标离开画布区域时停止绘制。</p><blockquote class="lc ld le"><p id="6ec9" class="ke kf lf kg b kh ki kj kk kl km kn ko lg kq kr ks lh ku kv kw li ky kz la lb ik bi translated">draw canvas . addevent listener(' mouseup '，function(e)<br/>{<br/>mouse pressed = false；<br/> }，假)；<br/><br/>draw canvas . addevent listener(' mouseleave '，函数(e)<br/>{<br/>mousePressed = false；<br/> }，假)；</p></blockquote><p id="c41f" class="pw-post-body-paragraph ke kf ir kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">关闭我们的初始化功能。</p><blockquote class="lc ld le"><p id="295a" class="ke kf lf kg b kh ki kj kk kl km kn ko lg kq kr ks lh ku kv kw li ky kz la lb ik bi">}</p></blockquote><p id="bd8e" class="pw-post-body-paragraph ke kf ir kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">为了更好地衡量，我将在这里添加一个clear函数，该函数将清空画布并将其设置回空白以重新开始。尽管在这个阶段，您也可以通过单击刷新按钮来完成此操作。</p><blockquote class="lc ld le"><p id="3891" class="ke kf lf kg b kh ki kj kk kl km kn ko lg kq kr ks lh ku kv kw li ky kz la lb ik bi translated">函数clearDrawing() { <br/> //在清空画布的同时使用单位矩阵<br/> ctx.setTransform(1，0，0，1，0，0)；<br/> ctx.clearRect(0，0，ctx.canvas.width，CTX . canvas . height)；<br/> }</p></blockquote><p id="9727" class="pw-post-body-paragraph ke kf ir kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">应该就是这样了。在你的页面上包含JavaScript，然后调用我们创建的初始化函数来初始化和激活绘图。</p><blockquote class="lc ld le"><p id="7bb3" class="ke kf lf kg b kh ki kj kk kl km kn ko lg kq kr ks lh ku kv kw li ky kz la lb ik bi translated"><script src="”drawing.js”"> </script> <br/> &lt;脚本&gt;<br/>InitDrawingMode(' my drawing '，1280，720)；<br/>&lt;/脚本&gt;</p></blockquote><p id="08cb" class="pw-post-body-paragraph ke kf ir kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">如果一切顺利，现在您应该能够在页面上的画布内部进行绘制了。</p><p id="320c" class="pw-post-body-paragraph ke kf ir kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">给画布加个边框或者给页面背景换个颜色会有助于确保画布清晰可见。不过，现在我会把造型交给你。当我们做一些改进时，我们可能会在未来更多地关注造型。</p><p id="41bb" class="pw-post-body-paragraph ke kf ir kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">接下来，我们将看看如何制作它，这样我们就可以很容易地改变画笔的颜色和大小，并添加能够将您漂亮的绘画保存到服务器的功能。</p><p id="f69e" class="pw-post-body-paragraph ke kf ir kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">到时候见。</p><p id="2ce2" class="pw-post-body-paragraph ke kf ir kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ik bi translated">欢迎留下评论，看看我的其他教程。</p><figure class="lk ll lm ln gu js gi gj paragraph-image"><div role="button" tabindex="0" class="jt ju di jv bf jw"><div class="gi gj lj"><img src="../Images/10810f8a5bf7b9310f7aedce69a297f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6BF16BdLwl4rqe7hDeJKyg.png"/></div></div><figcaption class="jz ka gk gi gj kb kc bd b be z dk translated">我们创建的绘图工具的例子。</figcaption></figure></div></div>    
</body>
</html>