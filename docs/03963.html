<html>
<head>
<title>Design Pattern — State</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">设计模式—状态</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/design-pattern-state-e0ed37cd853a?source=collection_archive---------0-----------------------#2021-01-09">https://blog.devgenius.io/design-pattern-state-e0ed37cd853a?source=collection_archive---------0-----------------------#2021-01-09</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="dec5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">状态设计模式的深入探讨</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8b1226c67e7c068dafa73fb5fa95d472.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qS4KNDp192KPyk-K"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">安德斯·吉尔登在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="ae4e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">状态设计模式，另一种最常见的设计模式。当我们想在应用程序中表示某种状态时，就会用到它。</p><h1 id="4750" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">什么是状态设计模式？</h1><p id="b539" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">状态设计模式是四人帮(g of)提出的行为设计模式之一。这种模式与有限状态机(FSM)密切相关。它实际上可以被称为有限状态机的一个应用。</p><p id="3b14" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这种设计模式允许基于其内部状态变化的行为变化。</p><p id="ef96" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这种设计模式用于分离在不同状态下需要采取的动作。有一个存储应用程序状态的对象，而不是变量的组合。</p><p id="7806" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">状态设计模式遵循实体设计原则的开闭原则(我们将在以后详细讨论)。类是<em class="mc">关闭</em>进行更改，而<em class="mc">打开</em>进行扩展。</p><p id="af65" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">状态设计模式也将代码分开。它将状态的应用程序逻辑中的位置和内容分开。</p><h1 id="b855" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">例子</h1><p id="ae68" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">我在核心Java APIs中找不到状态设计模式的例子。然而，您可以想象所有类型应用程序都需要某种状态管理。所以使用状态设计模式是很常见的。你可以想到BoomBox。你按下<em class="mc">播放</em>按钮，音箱开始播放。您可以点击<em class="mc">停止</em>按钮停止播放。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi md"><img src="../Images/2bd2bad83d122296217d775a8d24195a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qTH9VViH4xu35MU4"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@elionj?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">埃利安·贾沙里</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="5bab" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你也可以想象一个台扇。有一根绳子，你拉它就能启动或停止。你拉一下绳子就可以启动风扇。你再拉一下就停下来了。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi me"><img src="../Images/17b79a6414531e830faaad13f4275c4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Fmm4yD5-yN-fgEm1"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@yechan0422?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">野禅公园</a>拍摄于<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></figcaption></figure><h1 id="8e92" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">状态图</h1><p id="9232" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">如上所述，状态设计模式松散地基于有限状态机的概念。FSM可以很容易地用状态图来表示。</p><blockquote class="mf mg mh"><p id="5581" class="jk jl mc jm b jn jo jp jq jr js jt ju mi jw jx jy mj ka kb kc mk ke kf kg kh ig bi translated">状态图是计算机科学和相关领域中用于描述系统行为的一种图表。</p></blockquote><p id="eea1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">状态图具有系统的有限数量的状态。这些用圆形或椭圆形表示。连接这些状态的箭头是从一个状态到另一个状态的转换。箭头上的标签是转换的条件。</p><p id="5dc4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对于上面提到的BoomBox示例，状态图可以绘制如下</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/1825a36e5f25d80adb1fa1202fa2cd47.png" data-original-src="https://miro.medium.com/v2/resize:fit:492/format:webp/1*ZDmyHDZbXHa1MIeFHZn9Bw.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">内置扬声器的状态图</figcaption></figure><h1 id="efa4" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">实现状态机</h1><p id="35bb" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">状态机的一个非常基本的实现如下—</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="0d06" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了运行前面提到的类，我们可以使用下面的代码—</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="928c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">上面代码的输出是—</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="ed52" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">从上面仔细看看BoomBox类。这是一个如何实现状态机的例子。这个例子实现了一个具有三种状态的状态机——播放、暂停和停止。要从一种状态转换到另一种状态，我们需要执行一些检查。因为不是所有的转换都被支持。你不能从玩耍到玩耍。有趣的是，这是正确的。在一个音箱上，如果你按了play，当它已经在播放的时候，什么都不会发生。状态限制的另一个例子是，如果BoomBox处于停止状态，如果您试图暂停它，将不会发生任何事情。上面的状态图可以证实这些限制。</p><p id="f89a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">上面显示的实现并不理想。<strong class="jm io">它实现了状态机，但没有实现状态设计模式</strong>。</p><h1 id="6a0a" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">为什么我们需要使用状态设计模式？</h1><ul class=""><li id="ed75" class="mo mp in jm b jn lx jr ly jv mq jz mr kd ms kh mt mu mv mw bi translated"><strong class="jm io">if-else语句网</strong> —在上面这样一个非常简单的状态机中，我们得到了一个if-else语句网。想象一下，当我们有更多的状态和更多的转换时。涵盖所有场景将会非常复杂。即使是代码也无法用这样一个简单的状态机读取。</li><li id="1050" class="mo mp in jm b jn mx jr my jv mz jz na kd nb kh mt mu mv mw bi translated"><strong class="jm io">解决方案不可扩展</strong> —我们的机器目前只有三种状态。当我们试图添加第四个和第五个时，我们将不得不重新评估我们的play()、pause() &amp; stop()方法。我们需要确保所有的组合都包括在内。再增加几个if-else条件。很快这就变得无法管理了。</li><li id="925f" class="mo mp in jm b jn mx jr my jv mz jz na kd nb kh mt mu mv mw bi translated"><strong class="jm io">违反设计原则</strong> —违反单责任&amp;开闭原则等设计原则。我们在BoomBox类中做了不止一件事，我们不能在不改变现有代码的情况下引入新的状态。</li></ul><h1 id="98a5" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">UML图</h1><p id="3ab9" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">在我看来，没有图表，任何技术讨论都是不完整的。下面是状态设计模式的一个简单表示。有一个接口叫State。这个接口有一些方法。接口中的方法将取决于我们试图实现的状态机。</p><p id="c2ae" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">考虑一下BoomBox的例子。BoomBox可以是我们下面的上下文类。状态接口有play()、pause() &amp; stop()这样的方法。暂停、播放和停止可以是状态接口的一种实现。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/b0126aaf60cb7d799a5f6b9c0270fae3.png" data-original-src="https://miro.medium.com/v2/resize:fit:700/format:webp/1*GyqfD1f7PG6zNqB0-SiEDw.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">状态设计模式的UML图</figcaption></figure><h1 id="49fb" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">状态设计模式的实现</h1><p id="4fe3" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">我们试图使用状态设计模式来实现上面提到的状态机。我们将保留BoomBox类，并根据状态设计模式的要求修改它。我们也将测试代码保留在void main中。让我们从介绍状态接口开始。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="fb0c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这些方法大致对应于BoomBox接口中的方法。尽管我们没有对接口编程，但是如果我们创建了一个BoomBox接口，我们会在那里找到这些方法。</p><p id="43a4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，我们的BoomBox示例可以处于三种状态之一——播放、暂停或停止。我们将在三个代表状态的类中实现这个接口。</p><h1 id="ff4f" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">状态1:状态播放</h1><p id="b8c1" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">一个状态将决定切换到另一个状态的命令是否可行。当我们得到一个改变状态的命令时，StatePlaying类将保存做什么的逻辑。例如，如果我们处于播放状态，当我们收到播放命令时，我们不想做任何事情。类似地，进入暂停或停止状态需要什么动作是在StatePlaying类中决定的。这同样适用于BoomBox的其他状态类。每个状态可能有不同的逻辑&amp;状态转换规则。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mm mn l"/></div></figure><h1 id="a026" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">状态2:状态暂停</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mm mn l"/></div></figure><h1 id="8b23" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">状态3:状态停止</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="6403" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在我们将修改BoomBox类以适应状态的变化。早期的实现是基于静态整数的，现在我们有了独立的状态类。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="35e9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">看看play()、pause()和stop()方法的代码。它只是在状态对象上调用一个同名的方法。<em class="mc">状态</em>保存当前状态对象。</p><p id="8d43" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">开始时，<em class="mc">状态</em>被初始化为停止状态对象(stateStop)。当BoomBox上的play方法被调用时，它调用停止状态对象上的play方法。</p><p id="3ca3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，看看StateStopped中play方法的实现。在那里，我们将BoomBox状态更新为正在播放，并记录“正在播放”。这很容易成为播放音箱的实际逻辑。</p><p id="53a6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在想象一下，如果我们在BoomBox上调用stop方法，并且我们已经处于停止状态。看看StateStopped中的stop()方法。看看我们是如何记录我们已经处于停止状态的消息的。这种逻辑是特定于状态的实现的一部分。</p><h1 id="6208" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">状态设计模式解决的问题</h1><p id="5f98" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">状态设计模式解决了两个主要问题—</p><ul class=""><li id="9691" class="mo mp in jm b jn jo jr js jv nd jz ne kd nf kh mt mu mv mw bi translated">当对象的内部状态改变时，它应该改变它的行为</li><li id="d9ea" class="mo mp in jm b jn mx jr my jv mz jz na kd nb kh mt mu mv mw bi translated">特定于状态的行为应该独立定义。也就是说，添加新状态不应该影响现有状态的行为</li></ul><h1 id="0367" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">状态设计模式的问题</h1><p id="60f9" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">下面列出了状态设计模式的一些问题。这些并不严重，使用状态设计模式利大于弊。</p><ul class=""><li id="6424" class="mo mp in jm b jn jo jr js jv nd jz ne kd nf kh mt mu mv mw bi translated"><strong class="jm io">使设计变得复杂</strong> —在一个小的状态机例子中，它通过引入几个新类使设计变得复杂。有时，只有一些int和几个if可以完成这项工作。但是如果我们使用状态模式，我们使用状态设计模式可能会矫枉过正。</li><li id="373e" class="mo mp in jm b jn mx jr my jv mz jz na kd nb kh mt mu mv mw bi translated"><strong class="jm io">需要知道所有的状态</strong>——尽管状态设计模式可以很好地扩展以适应越来越多的状态，但在开始实现之前，我们在设计阶段做好适当的准备并识别所有可能的状态总是很有帮助的。</li><li id="32a4" class="mo mp in jm b jn mx jr my jv mz jz na kd nb kh mt mu mv mw bi translated"><strong class="jm io">路由类</strong> —上下文类，比如在我们的例子中，BoomBox类变成了一个简单的路由类，没有任何自己的逻辑。所有的逻辑都驻留在特定于状态的类中。</li></ul><h1 id="eaee" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">摘要</h1><ul class=""><li id="50b5" class="mo mp in jm b jn lx jr ly jv mq jz mr kd ms kh mt mu mv mw bi translated">状态机的实现</li><li id="475c" class="mo mp in jm b jn mx jr my jv mz jz na kd nb kh mt mu mv mw bi translated">允许基于内部状态的不同行为</li><li id="d200" class="mo mp in jm b jn mx jr my jv mz jz na kd nb kh mt mu mv mw bi translated">添加新状态非常容易——可扩展状态</li><li id="b40d" class="mo mp in jm b jn mx jr my jv mz jz na kd nb kh mt mu mv mw bi translated">简化代码，降低圈复杂度</li><li id="5c9e" class="mo mp in jm b jn mx jr my jv mz jz na kd nb kh mt mu mv mw bi translated">涉及大量小班教学</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/110861a0f3791d0f9bd4dc66f74168a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*sqtbzaWy4BD516JU"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@katya?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">卡蒂亚·奥斯丁</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure></div><div class="ab cl nh ni hr nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ig ih ii ij ik"><p id="f39c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="mc">撰写&amp;编辑——维韦克·米塔尔</em></p><div class="no np gp gr nq nr"><a href="https://www.linkedin.com/in/vivekmittal06" rel="noopener  ugc nofollow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd io gy z fp nw fr fs nx fu fw im bi translated">Vivek Mittal —首席软件工程师— Nuance Communications | LinkedIn</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">我是一名经验丰富的软件工程师，在软件工程方面有超过10年的经验。我有广泛的…</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">www.linkedin.com</p></div></div><div class="oa l"><div class="ob l oc od oe oa of ks nr"/></div></div></a></div><h1 id="c598" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">附加阅读</h1><div class="no np gp gr nq nr"><a href="https://medium.com/dev-genius/software-design-patterns-1b41de14ab8b" rel="noopener follow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd io gy z fp nw fr fs nx fu fw im bi translated">软件设计模式</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">软件设计模式概述</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">medium.com</p></div></div><div class="oa l"><div class="og l oc od oe oa of ks nr"/></div></div></a></div><div class="no np gp gr nq nr"><a href="https://medium.com/dev-genius/design-pattern-singleton-fa0f676a5d16" rel="noopener follow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd io gy z fp nw fr fs nx fu fw im bi translated">设计模式—单例</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">最常见的设计模式——单一模式的详细讨论</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">medium.com</p></div></div><div class="oa l"><div class="oh l oc od oe oa of ks nr"/></div></div></a></div><div class="no np gp gr nq nr"><a href="https://medium.com/dev-genius/design-pattern-builder-1ad55ed26120" rel="noopener follow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd io gy z fp nw fr fs nx fu fw im bi translated">设计模式—构建器</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">Builder设计模式的详细讨论</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">medium.com</p></div></div><div class="oa l"><div class="oi l oc od oe oa of ks nr"/></div></div></a></div></div></div>    
</body>
</html>