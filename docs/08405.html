<html>
<head>
<title>Reactive Programming in Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java 中的反应式编程</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/reactive-programming-in-java-132278a8689?source=collection_archive---------2-----------------------#2022-06-13">https://blog.devgenius.io/reactive-programming-in-java-132278a8689?source=collection_archive---------2-----------------------#2022-06-13</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="0aec" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">期货 vs CompletableFutures 期货 vs rx Java vs react Java 流 9… </strong></p><p id="b21d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们深入探讨如何在同步请求处理期间执行“你的部分代码<strong class="jm io">异步</strong>”</p></div><div class="ab cl ki kj hr kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="ig ih ii ij ik"><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi kp"><img src="../Images/d9ca01ae092eaf21edaab52f29f368ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-p6oknfuzKhCmrB9JS1Lbw.jpeg"/></div></div></figure><p id="0318" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对于许多用例，当您必须执行一些计算密集型工作，或者进行网络调用或执行一些并行处理时，我们倾向于使用多线程。这里产生一些临时线程来处理较小的任务，并合并回主请求线程后处理。</p><p id="9b6d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一旦多线程出现，下一步就是如何处理并行处理过程中产生的数据。</p><p id="3614" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Java 支持多种结构。我们将简要介绍一下</p><h1 id="b790" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">期货</h1><p id="da8e" class="pw-post-body-paragraph jk jl in jm b jn lz jp jq jr ma jt ju jv mb jx jy jz mc kb kc kd md kf kg kh ig bi translated">Java5 (2004)中引入了期货。它们基本上是尚未完成的可执行操作结果的占位符。一旦操作完成，<code class="fe mf mg mh mi b">Future</code>将包含该结果。</p><p id="87fd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">例如，操作可以是提交给<a class="ae me" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ExecutorService.html" rel="noopener ugc nofollow" target="_blank"> ExecutorService </a>的<a class="ae me" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Runnable.html" rel="noopener ugc nofollow" target="_blank">可运行</a>或<a class="ae me" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Callable.html" rel="noopener ugc nofollow" target="_blank">可调用</a>实例。操作的提交者可以使用<code class="fe mf mg mh mi b">Future</code>对象来检查操作<a class="ae me" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Future.html#isDone--" rel="noopener ugc nofollow" target="_blank">是否是 Done() </a>，或者等待它完成使用<strong class="jm io">blocking</strong><a class="ae me" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Future.html#get-long-java.util.concurrent.TimeUnit-" rel="noopener ugc nofollow" target="_blank">get()</a>方法。</p><p id="4c0a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">样本:</p><pre class="kq kr ks kt gt mj mi mk ml aw mm bi"><span id="4ff8" class="mn lc in mi b gy mo mp l mq mr">public static class MyAsyncExecutor implements Callable&lt;Integer&gt; {<br/>    @Override<br/>    public Integer call() throws Exception {<br/>        Thread.sleep(1000);<br/>        return 1;<br/>    }<!-- --> <br/>}</span><span id="e1bc" class="mn lc in mi b gy ms mp l mq mr">public static void main(String[] args) throws Exception{<br/>    ExecutorService exec = Executors.newSingleThreadExecutor();<br/>    Future&lt;Integer&gt; future = exec.submit(new MyAsyncExecutor());</span><span id="18c9" class="mn lc in mi b gy ms mp l mq mr">    System.out.println(future.isDone()); // False - a non blocking call, prints false, if processing is not finished; and moves on to next statement.</span><span id="428e" class="mn lc in mi b gy ms mp l mq mr">    System.out.println(future.get());    // Blocking call - waits until the task is done, then prints 1<br/>}</span></pre><h1 id="3e48" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">CompletableFutures </h1><p id="b3d4" class="pw-post-body-paragraph jk jl in jm b jn lz jp jq jr ma jt ju jv mb jx jy jz mc kb kc kd md kf kg kh ig bi translated"><a class="ae me" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html" rel="noopener ugc nofollow" target="_blank"> CompletableFutures </a>在 Java 8 (2014)中引入。</p><p id="2273" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">事实上，它们是常规期货的进化，受谷歌的可列表期货的启发，是 T2 番石榴图书馆的一部分。它们是未来，也允许你把相关的任务串在一起。你可以用它们来告诉某个工作线程“去做某个任务 X，当你完成后，去做任务 Y，也就是依赖于 X 的结果”。使用 CompletableFutures，您可以对上一个操作的结果做一些事情，而不用实际阻塞一个线程来等待结果。</p><p id="562e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们看一个例子来理解这一点:</p><pre class="kq kr ks kt gt mj mi mk ml aw mm bi"><span id="87e2" class="mn lc in mi b gy mo mp l mq mr">public static class MyAsyncExecutor implements Supplier&lt;Integer&gt; {<br/>    @Override<br/>    public Integer get() {<br/>        try {<br/>            Thread.sleep(1000);<br/>        } catch (InterruptedException e) {<br/>            //Suppress: do nothing<br/>        }<br/>        return 1;<br/>    }<br/>}</span><span id="f86a" class="mn lc in mi b gy ms mp l mq mr">/**<br/> * Simple function: adds 1 to result<br/> */<br/>public static class PlusOne implements Function&lt;Integer, Integer&gt; {<br/>    @Override<br/>    public Integer apply(Integer x) {<br/>        return x + 1;<br/>    }<br/>}</span><span id="df71" class="mn lc in mi b gy ms mp l mq mr">public static void main(String[] args) throws Exception {<br/>    ExecutorService exec = Executors.newSingleThreadExecutor();<br/>    CompletableFuture&lt;Integer&gt; f = CompletableFuture.supplyAsync(new MyAsyncExecutor(), exec);</span><span id="37e1" class="mn lc in mi b gy ms mp l mq mr">    System.out.println(f.isDone()); // False - a non blocking call, prints false, if processing is not finished; and moves on to next statement.</span><span id="69bb" class="mn lc in mi b gy ms mp l mq mr">    CompletableFuture&lt;Integer&gt; f2 = f.thenApply(new PlusOne()); // Chaining another operation<!-- --> </span><span id="f3e9" class="mn lc in mi b gy ms mp l mq mr">    System.out.println(f2.get()); // Blocking call - waits until the all chained operations are finished, then prints 2<br/>}</span></pre><h1 id="4ebf" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak"> RxJava </strong></h1><p id="d88d" class="pw-post-body-paragraph jk jl in jm b jn lz jp jq jr ma jt ju jv mb jx jy jz mc kb kc kd md kf kg kh ig bi translated"><a class="ae me" href="https://github.com/ReactiveX/RxJava" rel="noopener ugc nofollow" target="_blank"> RxJava </a>是网飞创建的<a class="ae me" href="https://en.wikipedia.org/wiki/Reactive_programming" rel="noopener ugc nofollow" target="_blank">反应式编程</a>的库。乍一看，它似乎与 Java 8 的流相似。它确实是，除了更强大。</p><p id="9634" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">与期货类似，RxJava 可以用来链接一组同步或异步函数，以创建一个处理管道。</p><p id="7b88" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">与单一操作的期货不同，RxJava 处理一个或多个项目的<em class="mt">流</em>，包括具有无限数量项目的永无止境的连续流。得益于难以置信的丰富的操作符集，它也更加灵活和强大。</p><p id="2448" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Java 8 的流和 RxJava 的主要区别在于，Rx 有<a class="ae me" href="http://reactivex.io/documentation/operators/backpressure.html" rel="noopener ugc nofollow" target="_blank">背压</a>支持，这允许它处理这样的情况，其中你的处理管道的不同部分在不同的线程、<em class="mt">中以不同的速率</em>操作<em class="mt">。为了使其可配置和更容易使用，库中添加了许多排列。RxJava 的主要缺点是，尽管有坚实的文档，但由于传统 Java8 涉及的范式转变，它是一个学习的<strong class="jm io">挑战库。</strong></em></p><p id="fbb2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">由于这种复杂性，Rx 代码可能是调试的噩梦。尤其是在有多个线程的情况下，如果还涉及到背压，情况会变得更糟！</p><p id="f812" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有很多关于 Rx 使用模式的教程。官方的<a class="ae me" href="http://reactivex.io/documentation/observable.html" rel="noopener ugc nofollow" target="_blank">文档</a>和<a class="ae me" href="http://reactivex.io/RxJava/javadoc/" rel="noopener ugc nofollow" target="_blank"> Javadoc </a>也相当丰富。你也可以找到一些可靠的视频，比如来自网飞的<a class="ae me" href="https://www.youtube.com/watch?v=_t06LRX0DV0" rel="noopener ugc nofollow" target="_blank">这个</a>，它给出了 Rx 的 101 以及如何开始。还简单谈了一下 Rx 和 Futures 的区别。</p><h1 id="863e" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak">反应流</strong></h1><p id="5034" class="pw-post-body-paragraph jk jl in jm b jn lz jp jq jr ma jt ju jv mb jx jy jz mc kb kc kd md kf kg kh ig bi translated"><a class="ae me" href="https://community.oracle.com/docs/DOC-1006738" rel="noopener ugc nofollow" target="_blank">反应流</a>是在 Java 9 (2017)中引入的</p><p id="a50d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">反应流，又名<a class="ae me" href="https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/Flow.html" rel="noopener ugc nofollow" target="_blank">流 API </a>是由各种<a class="ae me" href="http://www.reactive-streams.org/" rel="noopener ugc nofollow" target="_blank">反应流</a>库实现的一组标准接口，如<a class="ae me" href="https://github.com/ReactiveX/RxJava/wiki/Reactive-Streams" rel="noopener ugc nofollow" target="_blank"> RxJava 2 </a>、<a class="ae me" href="http://doc.akka.io/docs/akka-stream-and-http-experimental/1.0-M2/stream-design.html" rel="noopener ugc nofollow" target="_blank"> Akka 流</a>和<a class="ae me" href="http://vertx.io/" rel="noopener ugc nofollow" target="_blank"> Vertx </a>。公共接口有助于标准化约定，并允许这些反应库互连，同时保留所有的核心。</p></div><div class="ab cl ki kj hr kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="ig ih ii ij ik"><p id="5914" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当谈到 Java 中的并发处理时，经典的<a class="ae me" href="https://jcip.net/" rel="noopener ugc nofollow" target="_blank">Java Concurrency in Practice(jcip.net)</a>总是我的首选参考。</p><p id="b290" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">快乐编码…</p><p id="361b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"># Java #并发#多线程#Future #CompletableFuture #Rx</p></div></div>    
</body>
</html>