<html>
<head>
<title>Java String and String Pooling</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java 字符串和字符串池</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/java-string-and-string-pooling-2ed4b4b39d31?source=collection_archive---------10-----------------------#2022-08-17">https://blog.devgenius.io/java-string-and-string-pooling-2ed4b4b39d31?source=collection_archive---------10-----------------------#2022-08-17</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><h1 id="0c70" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">线</h1><p id="00de" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">字符的集合称为字符串。字符串是不可变的，这意味着它不能被改变，在内部它存储在 char 数组中。String 属于 java.lang 包。</p><p id="e2e2" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">创建字符串的方法:</p><ol class=""><li id="11fe" class="ll lm in kk b kl lg kp lh kt ln kx lo lb lp lf lq lr ls lt bi translated"><strong class="kk io">字符串文字:</strong></li></ol><p id="f456" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">下面是创建字符串对象的最常见的方法。</p><p id="125b" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">字符串对象像在字符串池中一样存储在堆内存中。Java 字符串池就是存储在堆内存中的字符串集合。在创建每个字符串对象时，字符串池首先检查字符串池中是否存在相同的字符串。如果字符串池中存在字符串，它将返回引用，否则将创建一个新对象。</p><p id="6d3d" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">String str = "这是我的第一个博客"；</p><p id="841f" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated"><strong class="kk io"> 2。带新运算符的字符串:</strong></p><p id="3073" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">用 new 关键字定义的字符串不会检查该值是否存在于字符串池中。每次 new 关键字都会在字符串池中创建一个新的引用和新鲜对象。</p><p id="2b2f" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">String str = new String("这是我的第一篇博客")；</p><p id="8dfb" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">如下图所示，使用字符串文字的字符串创建值<strong class="kk io">和</strong>将在字符串池中创建。如果程序试图创建一个全新的字符串，其值为<strong class="kk io">，使用字符串文字的一个</strong>将指向字符串池中的相同字符串值。</p><p id="d006" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">使用与上述<strong class="kk io">和</strong>具有相同值的新运算符创建的字符串不会作为字符串池的一部分创建，将始终指向新位置。</p><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="gh gi lu"><img src="../Images/e3c0e43dc0d03c42da2faadd0793505f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wCUQlJV5YzApkT78dn7b_A.png"/></div></div></figure><h1 id="3584" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">String 类中重要且最常用的预定义方法:</h1><h2 id="4436" class="mg jl in bd jm mh mi dn jq mj mk dp ju kt ml mm jy kx mn mo kc lb mp mq kg mr bi translated">字符串长度:</h2><p id="4dad" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">字符串长度可以在 length()方法的帮助下确定，并返回字符数作为结果。</p><pre class="lv lw lx ly gt ms mt mu mv aw mw bi"><span id="85bb" class="mg jl in mt b gy mx my l mz na">String a = "three";<br/>System.out.println(a.length());</span><span id="9385" class="mg jl in mt b gy nb my l mz na"><strong class="mt io">OUTPUT:</strong> <br/>5</span></pre><h2 id="b7be" class="mg jl in bd jm mh mi dn jq mj mk dp ju kt ml mm jy kx mn mo kc lb mp mq kg mr bi translated">大写()和小写():</h2><p id="46d9" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">方法会将字符串转换成完整的小写和大写。</p><pre class="lv lw lx ly gt ms mt mu mv aw mw bi"><span id="8ab4" class="mg jl in mt b gy mx my l mz na">String a = "Three";<br/>System.out.println(a.toLowerCase());<br/>System.out.println(a.toUpperCase());</span><span id="607a" class="mg jl in mt b gy nb my l mz na"><strong class="mt io">OUTPUT:</strong><br/>three<br/>THREE</span></pre><h2 id="cf28" class="mg jl in bd jm mh mi dn jq mj mk dp ju kt ml mm jy kx mn mo kc lb mp mq kg mr bi translated">Equals()和 equalIgnoreCase():</h2><p id="53a1" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated"><strong class="kk io"> Equals() - &gt; </strong> equals 方法不忽略大小写，为我们提供了比较两个字符串并返回 true 和 false 结果的能力。</p><p id="ffef" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated"><strong class="kk io">equalIgnoreCase()-&gt;</strong>equals 方法忽略大小写，为我们提供了比较两个字符串并返回 true 和 false 结果的能力。</p><pre class="lv lw lx ly gt ms mt mu mv aw mw bi"><span id="c27f" class="mg jl in mt b gy mx my l mz na">String a = "ONE", b = "One";<br/>System.out.println(a.equals(b));<br/>System.out.println(a.equalsIgnoreCase(b));</span><span id="25d0" class="mg jl in mt b gy nb my l mz na"><strong class="mt io">OUTPUT:</strong><br/>False<br/>True</span></pre><h2 id="bca6" class="mg jl in bd jm mh mi dn jq mj mk dp ju kt ml mm jy kx mn mo kc lb mp mq kg mr bi translated">charAt():</h2><p id="f850" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">这将返回方法中传递的特定字符的第一个匹配项。</p><p id="2e1a" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">大多数时候，我们会弄不清第一个字符是在 charAt(0)还是 charAt(1)之间。这总是从零索引开始。</p><pre class="lv lw lx ly gt ms mt mu mv aw mw bi"><span id="c210" class="mg jl in mt b gy mx my l mz na">String a = "Hello World";<br/>System.out.println(a.charAt(6));</span><span id="7544" class="mg jl in mt b gy nb my l mz na"><strong class="mt io">OUTPUT:</strong>  <br/>W</span></pre><p id="527c" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">注意:Java 从零开始计数，它也计算空白。</p><h2 id="fa1e" class="mg jl in bd jm mh mi dn jq mj mk dp ju kt ml mm jy kx mn mo kc lb mp mq kg mr bi translated">indexOf()和 lastIndexOf():</h2><p id="7000" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated"><strong class="kk io"> indexOf() : </strong> indexOf 方法将返回单词的位置和第一次出现的位置。</p><p id="be37" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated"><strong class="kk io">lastIndexOf():</strong>lastIndexOf 方法将返回函数参数中给定的单词的位置和最后一次出现的位置。</p><pre class="lv lw lx ly gt ms mt mu mv aw mw bi"><span id="638b" class="mg jl in mt b gy mx my l mz na">String str = "the is my home. home sweat home";<br/>System.out.println("Index Of "+str.indexOf("home"));<br/>System.out.println("Last Index Of "+str.lastIndexOf("home"));</span><span id="e350" class="mg jl in mt b gy nb my l mz na"><strong class="mt io">OUTPUT:</strong><br/>Index Of 10<br/>Last Index Of 27</span></pre><h1 id="1389" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">字符串串联:</h1><p id="b55d" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">在 Java 中，运算符重载只能用于字符串。使用+(加)运算符，我们可以连接两个字符串。</p><pre class="lv lw lx ly gt ms mt mu mv aw mw bi"><span id="73a6" class="mg jl in mt b gy mx my l mz na">String a = "Hello ", b = "World";<br/>System.out.println(a + b);</span><span id="20e1" class="mg jl in mt b gy nb my l mz na"><strong class="mt io">OUTPUT:</strong><br/>Hello World</span></pre><h2 id="4347" class="mg jl in bd jm mh mi dn jq mj mk dp ju kt ml mm jy kx mn mo kc lb mp mq kg mr bi translated">Concat():</h2><p id="02cc" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">串联也可以借助于字符串预定义函数 concat()来完成。</p><pre class="lv lw lx ly gt ms mt mu mv aw mw bi"><span id="3fa5" class="mg jl in mt b gy mx my l mz na">String a = "Hello ", b = "World";<br/>System.out.println(a.concat(b));</span><span id="8f17" class="mg jl in mt b gy nb my l mz na"><strong class="mt io">OUTPUT:</strong>  <br/>Hello World</span></pre><h2 id="9839" class="mg jl in bd jm mh mi dn jq mj mk dp ju kt ml mm jy kx mn mo kc lb mp mq kg mr bi translated">包含():</h2><p id="3cfb" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">这个函数检查字符串是否包含子串。如果找到子串，它将返回 true，否则返回 false。这也将检查是否区分大小写。</p><pre class="lv lw lx ly gt ms mt mu mv aw mw bi"><span id="22b7" class="mg jl in mt b gy mx my l mz na">String a = "Hello World";<br/>        System.out.println("hello = "+a.contains("hello"));<br/>        System.out.println("Hello = "+a.contains("Hello"));</span><span id="bf4a" class="mg jl in mt b gy nb my l mz na">OUTPUT:<br/>        hello = false<br/>        Hello = true</span></pre><h2 id="11ac" class="mg jl in bd jm mh mi dn jq mj mk dp ju kt ml mm jy kx mn mo kc lb mp mq kg mr bi translated">endsWith():</h2><p id="e646" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">如果字符串以传递的子字符串结尾，将返回 true。</p><pre class="lv lw lx ly gt ms mt mu mv aw mw bi"><span id="4519" class="mg jl in mt b gy mx my l mz na">String a = "Hello World";<br/>System.out.println("World = "+ a.endsWith("World"));<br/>System.out.println("world = "+ a.endsWith("world"));</span><span id="faff" class="mg jl in mt b gy nb my l mz na">OUTPUT:<br/>World = true<br/>world = false</span></pre><h2 id="d59c" class="mg jl in bd jm mh mi dn jq mj mk dp ju kt ml mm jy kx mn mo kc lb mp mq kg mr bi translated">开始于():</h2><p id="b687" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">如果字符串以传递的子字符串开始，将返回 true。</p><pre class="lv lw lx ly gt ms mt mu mv aw mw bi"><span id="6d2a" class="mg jl in mt b gy mx my l mz na">String a = "Hello World";<br/>System.out.println("Hello = "+ a.startsWith("Hello"));<br/>System.out.println("hello = "+ a. startsWith("hello"));</span><span id="ba50" class="mg jl in mt b gy nb my l mz na">OUTPUT:<br/>Hello = true<br/>hello = false</span></pre><p id="bc82" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">我希望你发现这篇文章有趣且内容丰富。请分享给你的朋友来传播知识。</p><p id="3c90" class="pw-post-body-paragraph ki kj in kk b kl lg kn ko kp lh kr ks kt li kv kw kx lj kz la lb lk ld le lf ig bi translated">您可以关注我即将发布的博客<a class="ae nc" href="https://medium.com/@toimrank" rel="noopener">关注</a>。<br/>谢谢你！</p></div></div>    
</body>
</html>