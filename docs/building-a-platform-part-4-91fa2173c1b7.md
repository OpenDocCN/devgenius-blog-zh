# 构建平台:第 4 部分

> 原文：<https://blog.devgenius.io/building-a-platform-part-4-91fa2173c1b7?source=collection_archive---------7----------------------->

*实施和测试合同*

![](img/6c52889d94c265abb5efef63b5ef8171.png)

[伊尔德丰索·波罗](https://unsplash.com/@i_m_polo?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的照片

这篇文章可能包含附属链接，当你点击链接时，我可能会赚取一小笔佣金，而不会对你产生额外的费用。作为亚马逊的会员，我从合格的购买中获得收入。

# 系列目录

[第 0 部分:标准抽象层和定义平台](/building-a-platform-part-0-e2a8a5af62bb) [第 1 部分:一般化的类型和过程](/building-a-platform-part-1-cf543658bfe3)[第 2 部分:你的平台的架构](/building-a-platform-part-2-cc8998716246)
[第 3 部分:首先设计伟大的契约](/building-a-platform-part-3-7d63d2a3d9d9)
**第 4 部分:实现和测试契约**
第 5 部分:持续集成早期步骤
第 6 部分:演进平台
第 7 部分:可怕的文档细节

# 介绍

在第 3 部分中，我们设计了我们的合同和我们应该问的问题类型。我们讨论了常见的合同类型和工具，以帮助您解决细节问题。该设计侧重于投资回报(ROI)和构建功能的总成本。

在第 4 部分中，我们将介绍实现和测试我们的合同的想法。我们不会测试所有类型，但是希望我们可以提供一个坚实的框架，用本文中的方法来创建一个稳定的、高质量的平台。

记住，

> 代码契约是软件系统中两个实体或外部参与者之间的正式或非正式的协议。

我们将用 C#展示所有的例子。NET 6，因为这是我的首选语言。我们将使用 xUnit.NET 作为我们的测试框架。然而，从概念上来说，您选择的语言和测试框架将是一样的。

让我们开始吧。

# 测试优先开发

TDD，或测试驱动开发，是首先用下面的周期编写测试的实践，

![](img/7108f38d5aa84b74dd398bcd63a0f751.png)

[blog.cleancoder.com](https://blog.cleancoder.com/uncle-bob/2014/12/17/TheCyclesOfTDD.html)

1.  **红色**:创建失败的单元测试
2.  **绿色**:编写通过测试的产品代码。
3.  **重构**:清理你刚刚弄的乱七八糟的东西。

不要忘记 TDD 的 3 个法则([干净的编码者](https://blog.cleancoder.com/uncle-bob/2014/12/17/TheCyclesOfTDD.html))，

1.  在编写任何产品代码之前，您必须编写一个失败的测试。
2.  您不能编写超过足以失败(或编译失败)的测试。
3.  您不得编写超过足以使当前失败的测试通过的生产代码。

一般来说，这种方法非常有效。但是只有当你专注于固化的需求时，它才能很好地工作。如果没有很好地定义需求，这种方法可能会令人沮丧。然而，我认为当需求没有被很好地组织时，任何开发都是如此。它不一定是特定于 TDD 的。

这种方法通常从单元测试的角度来使用，所有编写的代码都应该有一个相关的测试。这是我最不同意的部分。相反，当我们执行测试时，我们应该关注我们的应用程序的行为(像 BDD)。它应该适用于平台的以下方面:

1.  **外部定义的契约** : Web 服务 API，库内定义良好的公开接口，等等。
2.  **复杂子系统**:平台中的任何系统，其逻辑或互连可能过于复杂，由于技术限制而变得脆弱。

我们不应该为我们拥有的每一个类编写测试，也不应该为我们拥有的每一个契约实现编写测试。而是应该只针对合同本身。我们应该对每个实现运行相同的测试，以确保它们恰当地遵守契约。这才是重点。

> 我们试图关注合同本身，而不是如何执行。这是用适当的测试覆盖您的平台的一个关键区别。

理解契约测试是一组更高层次的测试是很重要的。由于这个原因，你的测试用例的深度将决定你的测试覆盖你的程度。有些情况下，一些契约测试会被认为是“单元测试”，而有些情况下，它们会被认为是“集成测试”从我们应该测试什么的角度来看，这实际上并不重要，重要的是设置测试的潜在复杂性。

> 注意:任何脆弱的测试都应该避免，因为它们必须经常改变。这些通常是 UI 或动态系统 API 之类的契约。我不是说你不应该写。但是你越需要修改你的测试，它们就越没有价值。尽量减少自动化中的这些类型的测试，否则你会发现自己维护测试的次数比应该维护的次数要多。

## 测试合同行为

当编写这些合同时，我们正在测试合同本身的行为。我们从哪里得到这些行为？

从要求上来说当然。

但是如果你没有任何要求呢？或者定义不明确的需求。您有几个选择:

1.  回到源头(客户、BA 等)，固化他们。
2.  做出假设，明确标注。

我们在编写代码时都会做出假设。例如，当我们把一个 SQL 表放在一起时，你多久会随意地给一个`char` 列加上一个大小？

"嗯，我认为名字不会超过 64 个字符."

这些是我们做出的假设。然而，我们并不总是测试这些假设。相反，当企业不知道答案，而你被迫做出决定时，我建议所有这些都进入测试，并将其标记为假设。这将有助于您在将来出现问题时，找到您所做的任何可能不正确的假设。

所以，假设我们知道自己的需求。我们到底应该测试什么？每种类型的合同都有不同的类别，但是这里有一些你应该考虑的合同行为，

*   **管用吗？**所有的核心功能(快乐路径)需求都满足了吗？
*   **是否涵盖了所有的用例？**
*   **什么类型的错误(或异常)是预期的？如何将它们返回给呼叫者？**
*   **数据进入请求的前置条件**是什么？
*   **来自响应的数据的后置条件**是什么？
*   **系统的状态预计会如何变化？**
*   **参数的极值是否得到适当检查？**
*   **用户/呼叫者可以执行哪些变通方法来破坏您的功能？有检测这种情况的测试吗？**

这些有点笼统，但是当你在软件中定义合同协议和假设时，问这些问题是很重要的。对于您提供的每个答案，应该有一个单独的测试。

## 建议:使第一个实现最简单

不幸的是，你不能真正测试一个契约。根据定义，它只是一个关于实现的协议，就像标准文档一样。相反，您将总是测试契约的实现。出于这个原因，我建议您总是使您的第一个实现尽可能简单。

举个例子，

假设您正在为您的平台构建一个库。您已经设计了一个供其他开发人员使用的界面。您知道从 API 的角度来看他们会期望什么，但是您还没有实现这个接口。

第一个实现应该是什么？

这取决于服务的用例，

*   **数据存储库服务**:创建一个使用内部集合存储记录的内存实现。
    *参见* [*内存仓库:一个被遗忘的设计工具*](https://medium.com/dev-genius/in-memory-repositories-a-forgotten-design-tool-1613151b8491) *获取更深入的例子*
*   **硬件服务**:创建一个硬件设备的内存仿真器，可以在测试过程中设置它来“模拟”一个真实的硬件设备。
*   **业务逻辑服务**:创建一个“默认的”服务，该服务适当地实现了契约。这个可能会作为最终的实现而结束。

这些只是少数几个，但是可以在本地运行，实际上不需要运行任何服务、外部依赖或附加硬件。如果必须的话，模仿这个行为。您会发现这对于快速测试非常有价值，并且提供了对其他实现中所需内容的全面理解。

## 旁注:模拟框架

这些类型的实现可以完全取代像 [Moq](https://github.com/moq/moq) 这样的嘲讽框架。

事实上，我从来不使用嘲讽框架。我认为它可以让你在思维上变得懒惰。你必须在测试中重新实现你的逻辑，对我来说，这违背了你的初衷。我会一直建议避开它们。

相反，我建议你自己制造假货。再次尝试实现您自己的接口。实际上，你可能会对你必须实现多少方法才能让你的假工作感到沮丧。这是你的设计没有优化的明显标志。

例如，假设您有一个如下所示的界面，

我要求您用一个单独的内存实现来重新实现这个契约。然而，你真的不想写所有这些代码。这就是像 Moq 这样的框架有所帮助的地方。他们这样做是为了让你只需要在测试中实现你关心的那个。但这是一种测试这种契约的懒惰方法。

事实上，你不想这样做，因为这将需要更长的时间，这意味着接口可能太大了。如果合同看起来更像下面这样怎么办？

在这种情况下，我们只需要实现 4 个方法，而不是 7 个。这个接口也更加灵活。然而，这个契约的测试实际上并没有改变。例如，`FindByName`和`FindBySku`的测试现在被合并到了`Find`方法中。因此，测试将是相同的，但是调用不同的接口方法。

重新实现接口的价值在于，当你对设计感到失望时，你能感觉到，从而知道有些东西需要改变。

## 重构一切

与根本不进行任何测试相比，测试提供了许多有价值的优势，

*   **文档**针对本地规范的要求和假设
*   提供业务需求的自动化**验证**
*   在架构或代码重构期间建立信心

测试本质上提供了文档、验证和信心。有了这些，我们会对重构我们的代码库感到舒服。

现在，当我说重构时，我不是指改变契约。不，当我们重构时，我们改变了契约背后的架构和代码。这可能是公开可用的实现，也可能是对客户端隐藏的服务。我们肯定可以改变接口，只是不能改变外部契约，因为这会破坏我们的客户。相反，更改接口应该集中在内部或私有契约上。

但是我们真的不应该将重构局限于产品代码。我们也应该重构我们的测试。我并不是建议改变测试用例本身，而是根据需要编写干净的代码并在测试库中创建任何抽象。

> 请记住，测试只是系统的另一个视图，就像控制器、UI 元素、CLI 参数或调用服务一样。

重构你的测试和重构你的主要代码库一样重要。

# 实施测试示例

我认为是时候我们开始通过一个例子。由于 TDD 的本质，以及它所要求的逐步迭代过程，我在这里不会经历红绿重构的各个阶段，而是向您展示完成的代码。

## 示范合同示例—解析电话号码

假设我们有一个公开的公共模型，它将解析电话号码。这里的“契约”是我们希望将所有可能的电话号码解析成一种标准格式。以下是一些要求，

*   必须选择性地接受 1 至 3 位数的国家代码
*   如果存在国家代码，该号码必须以一个`+`符号为前缀
*   必须选择性地接受恰好 3 位数的区号
*   如果存在国家代码，则需要区号
*   必须要求区域设置代码正好为 3 位数字
*   必须要求数字正好是 4 位数
*   解析函数应该接受一个单独的`string`值作为输入，并将一个分段的电话号码返回到`CountryCode`、`AreaCode`、`Locale`和`Number`。

这是我们对这份合同的测试，

现在我们也可以将用例分离到桶中。然而，在这种情况下，这将是重复的代码，我觉得没有必要。总是尽量务实。

现在我们的实现，

不是最优雅的解决方案，但是测试通过了。如果你想，你可以很容易地改变这种方法，每次点击播放，以验证合同仍然满意。

我们没有对这里的要求做任何假设。但是如果你愿意，你可以创造一些。例如，如果传入一个`null`会发生什么？我们不负责那个案子。这对我们来说是一个假设，因为我们在合同中没有看到这个用例。

## 存储库合同示例

这个例子摘自文章[内存库:被遗忘的设计工具](https://medium.com/dev-genius/in-memory-repositories-a-forgotten-design-tool-1613151b8491)。让我们看看合同，

这份合同相当简单。标准存储库具有 CRUD 功能。仅此而已。现在，除了这个接口契约之外，我们还有一些需求，

*   每个产品必须有一个名称(不能为空)
*   产品名称可以重复
*   产品名称最多为 64 个字符
*   产品可以选择具有最多 256 个字符的描述

现在这里是我们只针对`AddAsync`方法的合同测试，

和实现，

在这里你可以看到我们完全实现了`AddAsync`功能，并附带了所有的先决条件，以确保与我们的合同兼容。

我通常会首先创建这个内存版本，以确保我完全解决了逻辑中的所有问题。一旦完成，我就可以开始我的“真正的”实现了。

> 请记住，我个人的方法是先在内存中构建整个代码库，然后再回头做一个数据库实现。我可以确保在投资于数据库结构的设计之前，系统已经过全面审查。

假设我的实际实现是一个 SQL Server 数据库，如下所示，

这个实现非常简单。只需在对代码执行一些检查后插入记录。

我如何重构我的测试类来适应新的实现？我做的第一件事是为我的测试创建一个基类。它将包含一个抽象方法，用于创建要测试的契约的具体实现。

然后，我简单地创建了两个继承的类，它们正确地设置了要测试的服务。

当您使用 xUnit.NET 点击 play 时，两组测试都将运行:一组在内存中运行，另一组在 SQL Server 中运行。

第一组测试在许多方面像“单元测试”，而第二组测试像“集成测试”然而，我们使用的是同一套测试用例。

理解这些“契约测试”与“单元测试”和“集成测试”之间的区别是很重要的请记住，我们正在进行的测试类型并不重要。重要的是我们在测试合同。

# 结论和签署

这篇文章的摘要很简单，

1.  测试您的外部合同和任何复杂的子系统
2.  从满足契约的最简单的实现开始
3.  在实现之间使用相同的测试

就是这样。

我没有看完所有类型的合同，但前提是一样的。对于 web 服务或 UI，您将希望首先执行到控制器或应用程序的内存连接，最好使用合适的内存存储库。一旦合同生效，您就可以使用您的“集成”服务再次进行测试，以获得更接近的端到端测试集。在这里你甚至不需要改变你的测试本身，只需要改变你的合同是如何设置的。

这种类型的测试是有益的原因是由于从“单元”测试到“端到端”测试的不必要的改变。只需更改设置，您就可以针对不同的环境。您可以在开发/ QA 部署中使用内存进行本地测试和 SQL Server 实现。

无论哪种方式，最困难的部分是确定你的合同。我们在第三部分中详细讨论了这一点。如果您还没有完全理解契约的概念，我建议您再看一遍那篇文章。

我希望这篇文章对测试您的平台有所帮助。下次见！