<html>
<head>
<title>How I made a chrome extension that uses vocal recognition to control DOM elements on a webpage.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我如何制作一个chrome扩展，使用声音识别来控制网页上的DOM元素。</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-i-made-a-chrome-extension-that-uses-vocal-recognition-to-control-dom-elements-on-a-webpage-a3a5cb19a584?source=collection_archive---------18-----------------------#2020-06-15">https://blog.devgenius.io/how-i-made-a-chrome-extension-that-uses-vocal-recognition-to-control-dom-elements-on-a-webpage-a3a5cb19a584?source=collection_archive---------18-----------------------#2020-06-15</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="8ceb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以最近我发表了我的第一个chrome扩展“orange”。它允许用户用他们的声音控制任何网页。“orange”与其他语音识别chrome扩展的区别在于，它允许用户录制自己的命令。这对于控制Spotify、网飞和Youtube等网站上音频和视频播放非常有用。</p><p id="8080" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae ki" href="https://chrome.google.com/webstore/detail/orange/ibamdegelmgihmnlomabhfkomnpdfjmc" rel="noopener ugc nofollow" target="_blank">链接到chrome商店的Chrome扩展模块</a></p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi kj"><img src="../Images/b61fe16437fae113cfde1bacdc2d5064.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*WMArnNup1h6S_NH8HAbKbg.png"/></div></figure><p id="2d87" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">从下拉列表中点击记录；那么网页上可控制的按钮将以橙色标出。一旦你点击一个按钮，你将被提示说出一个单词；这将是命令字。在说出你选择的任何单词后，你的控制事件被记录下来！点击开始激活您的麦克风，每当您说“橙色<command word="">”时，分机将触发您之前记录的事件。</command></p><p id="681b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这篇文章中，我将回顾我是如何产生这个想法的，以及我是如何编写代码的。我也会检查我认为需要改进的地方和未来的计划。</p></div><div class="ab cl kr ks hr kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ig ih ii ij ik"><p id="b5d8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以我第一次想到这个主意是在玩这个演示的时候:<a class="ae ki" href="https://www.google.com/intl/en/chrome/demos/speech.html" rel="noopener ugc nofollow" target="_blank">https://www.google.com/intl/en/chrome/demos/speech.html</a></p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ky kz l"/></div></figure><p id="bf2d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">web speech API背后的工程团队能够实时执行语音识别服务器端，这给我留下了深刻的印象。不容易的壮举！我想这个扩展应该能够处理除了语音到文本之外的动作。想法就是这样开始的。</p><p id="9232" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这些扩展如何工作的主要逻辑是一个简单的对象。对象的键是记录的命令字，那些键的值是记录的DOM元素(按钮)。记录事件存储这些值，然后开始事件返回它们。</p><pre class="kk kl km kn gt la lb lc ld aw le bi"><span id="818c" class="lf lg in lb b gy lh li l lj lk">{</span><span id="d97d" class="lf lg in lb b gy ll li l lj lk">[“command_word_1]: “button 1”,</span><span id="b62f" class="lf lg in lb b gy ll li l lj lk">[“command_word_2”]: “button 2”,</span><span id="c80b" class="lf lg in lb b gy ll li l lj lk">}</span></pre><p id="e719" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了防止DOM元素在不需要的时候被触发，我添加了检查字；橙色”。橙色这个词被选为一个内部笑话。没有其他东西和它押韵，这样就有希望避免任何识别错误。</p><p id="0d6c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">每当扩展看到单词“orange ”,然后下一个单词是主对象中的一个键，它就会知道调用记录的DOM元素。</p><pre class="kk kl km kn gt la lb lc ld aw le bi"><span id="f48e" class="lf lg in lb b gy lh li l lj lk">//Recorded commands<br/>const output = {</span><span id="d809" class="lf lg in lb b gy ll li l lj lk">['play']: “button 1”,</span><span id="600b" class="lf lg in lb b gy ll li l lj lk">['pause']: “button 2”,</span><span id="fb82" class="lf lg in lb b gy ll li l lj lk">}</span><span id="634f" class="lf lg in lb b gy ll li l lj lk">// Example input: ['', '', 'orange', 'play', '']</span><span id="6c5c" class="lf lg in lb b gy ll li l lj lk">//If the input includes 'orange' and the word after 'orange' is <br/>//a recorded command key, like "command_word_1", then the return //will have the command key value, "button 1"</span><span id="459b" class="lf lg in lb b gy ll li l lj lk">if (input.includes('orange')) {<br/>let return = output[command.indexOf('orange') + 1];<br/>}</span></pre><p id="4c2e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了管理语音识别输出的数据流，我使用了布尔值，它将根据popover菜单的输入进行设置。</p><pre class="kk kl km kn gt la lb lc ld aw le bi"><span id="ad6d" class="lf lg in lb b gy lh li l lj lk">let start = false;</span><span id="2777" class="lf lg in lb b gy ll li l lj lk">let record = false;</span><span id="3d6b" class="lf lg in lb b gy ll li l lj lk">let stop = true</span><span id="07e9" class="lf lg in lb b gy ll li l lj lk">if (popover.message === “start”){</span><span id="b28d" class="lf lg in lb b gy ll li l lj lk">stop = false</span><span id="3727" class="lf lg in lb b gy ll li l lj lk">start = true</span><span id="a38d" class="lf lg in lb b gy ll li l lj lk">....</span><span id="a1a1" class="lf lg in lb b gy ll li l lj lk">}</span><span id="06f6" class="lf lg in lb b gy ll li l lj lk">if(popover.message === “record”){</span><span id="0694" class="lf lg in lb b gy ll li l lj lk">start = false</span><span id="5d94" class="lf lg in lb b gy ll li l lj lk">record = true</span><span id="4e39" class="lf lg in lb b gy ll li l lj lk">stop = true</span><span id="6b2b" class="lf lg in lb b gy ll li l lj lk">...</span><span id="11c2" class="lf lg in lb b gy ll li l lj lk">}</span></pre><p id="c06e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一旦我有了基本的功能，我注意到我想用很多相同的词作为命令词，但用于不同的页面。我想为Spotify和Youtube调用“orange play”。因此，解决方法是将嵌套对象存储在父对象中，父对象的键由记录命令的页面的主机URL组成。现在，我可以为多个站点使用类似的命令，如“播放”和“暂停”。</p><pre class="kk kl km kn gt la lb lc ld aw le bi"><span id="b734" class="lf lg in lb b gy lh li l lj lk">//Updated recorded command object</span><span id="f3c6" class="lf lg in lb b gy ll li l lj lk">{</span><span id="b398" class="lf lg in lb b gy ll li l lj lk">   www.youtube.com : {</span><span id="9b50" class="lf lg in lb b gy ll li l lj lk">                        ['play']: “button 1”,</span><span id="e55d" class="lf lg in lb b gy ll li l lj lk">                     },</span><span id="11df" class="lf lg in lb b gy ll li l lj lk">   www.netflix.com : {</span><span id="2581" class="lf lg in lb b gy ll li l lj lk">                        ['command_word_1']: “button 1”,</span><span id="4715" class="lf lg in lb b gy ll li l lj lk">                     },<br/>}</span></pre></div><div class="ab cl kr ks hr kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ig ih ii ij ik"><p id="b0f3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">编写这个扩展的最大障碍是在扩展的每个范围之间传递数据。我有一个后台脚本，它运行声音识别实例并存储命令。还有一个与DOM交互的内容脚本，它充当每个动作的外部和入口点。内容和背景都在来回传递信息。当事件被记录在客户端时，客户端脚本将数据传递到后台。当一个命令被调用时，后台将数据传递给客户端。消息传递的方式是使用Chrome API。它最大的缺点是不能发送或接收整个DOM元素；我不得不满足于传递DOM元素类名的字符串变量。从那里，我可以根据事件存储或搜索类名。</p><p id="1561" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这导致了orange最大的局限性。它不能处理SVG Dom元素。大多数SVG元素都有相同的类名。所以如果我按类名搜索，我会得到多个结果。当然，现在任何元素都可以与其他元素共享类名，但是对于大多数主要网站，如Youtube、Spotify或网飞(orange与这些网站合作得很好)，单个DOM元素至少有一个特定的类名。</p></div><div class="ab cl kr ks hr kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ig ih ii ij ik"><p id="41e1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">接下来，我更想关注的一个领域是改进语音识别。如果音频输入有噪音，它会变得不太准确。因此，如果你正在播放音乐，并试图给“橙色”一个命令，那么它将很难识别这个命令。</p><p id="5b15" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一种解决方法可能是在发出命令时降低音量。这可能会稍微改善识别，但是首先识别命令仍然会有相同的限制。</p><p id="99c8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">另一种解决方法是过滤发送到识别实例的音频。因为我只关心识别人的声音，所以我可以计算出低于400赫兹的频率(人的声音会降低，但识别低于400赫兹的单词可能不会被错过)和高于10千赫兹的频率。这些只是非常粗略的估计，但主要思想是缩小输入音频的范围，只关注语音。此外，我已经看到一些令人印象深刻的技术，可以过滤掉所有频率的噪音，只留下改变的声音。可能有很多javascript来处理哈哈，但可能会有一个更智能的过滤器。</p></div><div class="ab cl kr ks hr kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ig ih ii ij ik"><p id="db9a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">无论如何，希望你觉得这本书有趣。如果你想聊聊这个扩展或者看看有什么可以改进的地方，请在下面留下你的评论。</p></div></div>    
</body>
</html>