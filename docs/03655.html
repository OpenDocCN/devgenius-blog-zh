<html>
<head>
<title>Protecting audio and music assets with Node and Javascript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Node和Javascript保护音频和音乐资产</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/protecting-audio-and-music-assets-with-node-and-javascript-5898683fa035?source=collection_archive---------0-----------------------#2020-11-30">https://blog.devgenius.io/protecting-audio-and-music-assets-with-node-and-javascript-5898683fa035?source=collection_archive---------0-----------------------#2020-11-30</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/0012aef27798db0effc1247219e46705.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*7Hdx54q8vrI5JFwx.jpg"/></div></div></figure><p id="a145" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在我之前的帖子中，我讨论了我最近为Bandcamp构建外部音乐播放器的小项目。我意识到，许多类似的网站和服务很容易被滥用于盗版内容，特别是有版权的音频、音乐和视频。在这篇文章中，我将讨论几种保护这些内容的策略。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div class="gh gi kt"><img src="../Images/70fdd83e0e650423e2c4019e9619face.png" data-original-src="https://miro.medium.com/v2/resize:fit:1348/format:webp/0*Lbvt1S_QLXnRp2Lj.png"/></div></figure><p id="b6db" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">获取mp3文件(和其他数字内容)通常可以通过查看在播放/使用特定内容时发出的HTTP请求来完成。在Bandcamp的例子中，我只需查看网络流量，找出大小为5.37MB的“mpeg”数据类型，然后通过复制粘贴GET URL，您就可以下载相应的mp3文件。</p><p id="2ca1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">今天，完全保护数字内容几乎是不可能的，总有一些方法可以获取它。但是安全系统的目的是让黑客/盗版者的生活变得非常痛苦。要么让过程变得非常漫长和/或复杂，希望他们放弃。</p><p id="db57" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一个非常基本但非常有效的方法是加密敏感资产。在Bandcamp的例子中，他们可以使用某个密钥在服务器端加密mp3内容，将其发送到客户端，然后让客户端的JavaScript代码解密并播放它。客户端仍然可以下载加密的mp3文件，但是如果没有正确的解密算法，它就是一个无用的文件。这种方法的有效性取决于我们隐藏和混淆解密函数的能力。</p><p id="3672" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在下面的代码中，我展示了完成所有这些工作的原型。</p><h1 id="78cc" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">NodeJS服务器代码</h1><pre class="ku kv kw kx gt lw lx ly lz aw ma bi"><span id="451a" class="mb kz in lx b gy mc md l me mf">"use strict";<br/>const express = require("express")<br/>const app = express()<br/>const { Readable } = require('stream')<br/>const fs = require('fs')</span><span id="4b74" class="mb kz in lx b gy mg md l me mf">app.get("/audio", function (req, res) {<br/>  res.setHeader('Access-Control-Allow-Origin','*')<br/>  xor_encrypt(res)<br/>})</span><span id="9bc0" class="mb kz in lx b gy mg md l me mf">function xor_encrypt(res) {<br/>  // read audio file to buffer<br/>  let buff = fs.readFileSync('./audio.mp3')</span><span id="742d" class="mb kz in lx b gy mg md l me mf">  // determine encryption key<br/>  let key = buff[buff.length-1]</span><span id="b2e9" class="mb kz in lx b gy mg md l me mf">  // encrypt buffer contents<br/>  buff = buff.map(x =&gt; x ^ key).map(x =&gt; ~x)</span><span id="2b41" class="mb kz in lx b gy mg md l me mf">  // store the encryption key as last element<br/>  buff[buff.length-1] = key</span><span id="9eef" class="mb kz in lx b gy mg md l me mf">  // transform buffer to stream<br/>  let readStream = Readable.from(buff)</span><span id="37f5" class="mb kz in lx b gy mg md l me mf">  // send stream to client<br/>  readStream.pipe(res)</span><span id="3deb" class="mb kz in lx b gy mg md l me mf">  readStream.on('end', () =&gt; {<br/>    res.status(200).send()<br/>  })<br/>}</span><span id="0137" class="mb kz in lx b gy mg md l me mf">app.use(express.static('.'))</span><span id="9e60" class="mb kz in lx b gy mg md l me mf">const serverHost =  "localhost"<br/>const serverPort =  3007<br/>app.listen(serverPort)</span></pre><h1 id="6344" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">JS客户端代码</h1><pre class="ku kv kw kx gt lw lx ly lz aw ma bi"><span id="b006" class="mb kz in lx b gy mc md l me mf">let curr_track = document.createElement('audio')</span><span id="6aeb" class="mb kz in lx b gy mg md l me mf">var oReq = new XMLHttpRequest()<br/>oReq.open("GET", 'http://localhost:3007/audio', true)<br/>oReq.responseType = "arraybuffer"</span><span id="a1e4" class="mb kz in lx b gy mg md l me mf">oReq.onload = function(oEvent) {<br/>  xor()<br/>}<br/>oReq.send()</span><span id="ea6e" class="mb kz in lx b gy mg md l me mf">function xor() {<br/>  // convert arrayBuffer to regular Array<br/>  const arr = oReq.response<br/>  var byteArray = new Uint8Array(arr)</span><span id="6043" class="mb kz in lx b gy mg md l me mf">  // obtain encryption key<br/>  let key = byteArray[byteArray.length - 1]</span><span id="350e" class="mb kz in lx b gy mg md l me mf">  // use key to decrypt contents<br/>  byteArray = byteArray.map(x =&gt; x ^ key).map(x =&gt; ~x)</span><span id="2ada" class="mb kz in lx b gy mg md l me mf">  // restore key<br/>  byteArray[byteArray.length - 1] = key</span><span id="7a1b" class="mb kz in lx b gy mg md l me mf">  // convert byteArray to Blob<br/>  const blob = new Blob([byteArray], { type: 'audio/mp3' })<br/>  // create playable URL from Blob object<br/>  const url = URL.createObjectURL(blob) // memory leak possible!</span><span id="c54c" class="mb kz in lx b gy mg md l me mf">  curr_track.src = url<br/>  curr_track.load()<br/>}</span><span id="e82a" class="mb kz in lx b gy mg md l me mf">// now you can bind 'curr_track.play()' to some click-event</span></pre><p id="8476" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">上面的代码包含了每个步骤的注释，所以它应该是不言自明的。加密方法依赖于简单而高效的按位运算符(xor和not)。</p><p id="e002" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在客户端代码中，<code class="fe mh mi mj lx b">url</code>变量指向一个表示mp3文件的临时内存Blob对象。如果你把这个<code class="fe mh mi mj lx b">url</code>打印到控制台，你会得到类似这样的东西:<br/> <code class="fe mh mi mj lx b">blob:http://localhost:3007/9a2ffb47-72af-4c58-a0f9-08b9a63b81d0</code> <br/>如果你复制粘贴到一个新的标签页，你就可以播放/下载解密的mp3曲目。只要你的网站窗口保持打开，这个Blob对象就存在于内存中，否则它会被垃圾收集；这也意味着创建许多Blobs会导致内存泄漏(但是有一个手动清理它们的方法)。</p><p id="62d1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这种加密策略效果很好，我们让用户下载mp3文件变得更加困难。一旦用户弄清楚解密函数是如何工作的，他们就可以自动操作它。或者通过调试/编辑JavaScript代码，他们可以类似地获得mp3文件。</p><p id="0ee0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">或者，不使用Blob对象，可以使用base64编码，但这和Blob解码和下载二进制内容一样简单。</p><p id="4a51" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">进一步的改进是随机使用许多不同的加密/解密方法(而不是一种)，但是同样需要某种标识符来确定客户端应该使用哪种方法。黑客/海盗再一次可以解决这个问题。</p><p id="6ffe" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">底线是，我们使用html5标记来播放曲目，更具体地说，是通过为其<code class="fe mh mi mj lx b">src</code>属性提供一个网址。为了提供更多的安全性，我们应该研究不同的方法和技术来播放音频，而不需要使用<code class="fe mh mi mj lx b">&lt;audio&gt;</code>标签。</p></div></div>    
</body>
</html>