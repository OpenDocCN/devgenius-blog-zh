<html>
<head>
<title>How to add resolver in angular</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在角度中添加旋转变压器</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-to-add-resolver-in-angular-7ca343f51452?source=collection_archive---------6-----------------------#2022-05-08">https://blog.devgenius.io/how-to-add-resolver-in-angular-7ca343f51452?source=collection_archive---------6-----------------------#2022-05-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="8e67" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">导航是影响 web 应用程序用户体验的一个重要方面。Resolver 就是这样一个工具，当用户从一条路线导航到另一条路线时，它通过预取一些数据来帮助我们改进导航。它可以被定义为通过在用户导航到特定组件之前加载数据来增强用户体验的平滑方法。在本文中，我们将了解如何在 angular 中添加旋变器。angular 的基础知识有助于更好地理解代码。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/308a51cebcbb429b69820a2f6d24ba74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U5kK2VMewNYmdX3ibEDeeQ.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">本杰明·达达在<a class="ae ky" href="https://unsplash.com/s/photos/webpage?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="155f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">首先，我们将创建一个角度应用程序。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi kz"><img src="../Images/d06560432102abb3c6387fcc511a3f7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6sIXyYH4XJCvPYZOu_78ZA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">创建新的角度应用程序</figcaption></figure><p id="dcd2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，我们将创建两条路线和两个要在这些路线上渲染的组件。让我们创建名为“第一”和“第二”的组件。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi la"><img src="../Images/7f235f1ea2354f552cb6776b18092108.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V4Sutfv0LjJXLtIxF5WvEw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">创建“第一个”组件</figcaption></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi la"><img src="../Images/f272a2895367552e4a795eff0e396003.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fPbF4FSa_9H9iurLheZWOg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">创建“第二个”组件</figcaption></figure><p id="25b9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在我们将添加路线。“第一个”组件将在“/”路线上呈现，而“第二个”组件将在“/第二个”路线上呈现。</p><p id="d8b8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在“app-routing.module.ts”中，我们这样声明我们的路由。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lb"><img src="../Images/6b6cb12010bdbe0dabce7e97d203f46d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6DYe8wlnizU9ijsAojakpg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">app-routing.module.ts</figcaption></figure><p id="725b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在我们的“第一”页上，我们只需有一个按钮将用户重定向到“第二”页。</p><p id="ae28" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们的“first.component.html”:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lb"><img src="../Images/2ce04b974153d2d879645a34e88eedff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8GEOC4SPBREmBOAROvtHPg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">first.component.html</figcaption></figure><p id="f8e5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们给我们的按钮添加一些样式。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lb"><img src="../Images/76a054d9d13f44e88d4ed57646d41155.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VsRewzkVpLHu4uEuB07rMw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">第一.组件. scss</figcaption></figure><p id="4abb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，我们到了主要部分。我们将添加一个服务，作为我们的“/秒”路由的解析器。首先，我们需要创建一个服务。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi la"><img src="../Images/e8bdde5608f24803f7479139a0a911e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9mivYDpi8iSuMctk2kFRNw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">resolver.service.ts</figcaption></figure><p id="d08d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">正如你所注意到的，这个服务已经使用了一个“injectable()”装饰器，我们不需要将这个服务作为对“app.module.ts”的依赖来注入。现在，我们的 resolverService 将实现“@angular/router”中的 Resolve 接口，我们还将“route”传递给 Resolve 方法，因为在大多数情况下，我们可能需要使用 route 中的一些参数从数据库中获取数据，例如订单 id 或用户 id。我们的解析器将简单地返回一个“hello world！”字符串。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lb"><img src="../Images/a9f04ec820be60204c934ccee3de11dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QK51AL_Hhc2IjiOG4qoMww.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">resolver.service.ts</figcaption></figure><p id="756e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，我们需要告诉我们的 app-routing.module.ts 使用此服务作为我们的“/second”路由的解析器，并将此服务返回的任何内容保存为一个键-值对，我们可以从“second”组件中的激活路由(激活路由出现在 angular/route 中，并提供对与组件关联的路由信息的访问)中获取该对。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lb"><img src="../Images/d26c1d7af0fbb742464cd56613fe6d0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RaCgsBboVteBGhxi6DtR3A.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">app-routing.module.ts</figcaption></figure><p id="972f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在我们都设置好了，让我们移动到第二个组件来获取解析器发送给我们的内容。我们将订阅激活路由中存在的数据，并从那里取出我们的“msg ”,它包含我们的解析器发送的内容。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lb"><img src="../Images/19f14c154d73bca8d4539f36a064bab2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*brHyGwFOK2RVj2cY2gXisQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">第二组件</figcaption></figure><p id="ae3b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您可以注意到，我们正在使用 ngOnInit()，它是一个生命周期挂钩，类似于 React 的 componentDidMount()并在控制台中打印接收到的数据。让我们看看实际情况。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi la"><img src="../Images/fae1f8c0b2c9b960fec348f2a67bad9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AuCeS6-y_utH59uqCr7x6A.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">第一页</figcaption></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi la"><img src="../Images/c32449105baee9b4f6b45eb41ef619cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2PaiSy4D7ULh0q3n6f1MKQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">第二页</figcaption></figure><p id="03c7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一旦我们的内容被加载，我们就在控制台中打印我们的数据。给定一个简单的字符串是非常少量的数据，我们不需要使用解析器来获取它。但是，如果我们需要为一个页面获取大量数据，并且不希望在数据加载之前将用户重定向到该页面，解析器可能会帮助我们。</p><p id="3f2e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">源代码:<a class="ae ky" href="https://github.com/Xebec19/fluffy-dollop" rel="noopener ugc nofollow" target="_blank">https://github.com/Xebec19/fluffy-dollop</a></p></div></div>    
</body>
</html>