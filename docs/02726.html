<html>
<head>
<title>Java Script: Let’s Talk React Basics</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java Script:让我们谈谈React基础知识</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/java-script-lets-talk-react-basics-322629bb6e62?source=collection_archive---------3-----------------------#2020-08-24">https://blog.devgenius.io/java-script-lets-talk-react-basics-322629bb6e62?source=collection_archive---------3-----------------------#2020-08-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/b1c3d7058848c1a5f33cdb1785552115.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FGFRP0QNXfTCOfGl3cRTDg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://abcntechnologies.com/wp-content/uploads/2019/12/reactjs.png" rel="noopener ugc nofollow" target="_blank">https://abcn technologies . com/WP-content/uploads/2019/12/react js . png</a></figcaption></figure><h1 id="ab14" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">什么是反应？</h1><p id="e8bc" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated"><a class="ae kc" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank"> React </a>是一个用于构建用户界面的JavaScript库。React是由脸书和Instagram开发的。React在<a class="ae kc" href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller" rel="noopener ugc nofollow" target="_blank"> MVC </a>(模型—视图—控制器)中处理视图。React是声明性的，而不是命令性的。<a class="ae kc" href="https://codeburst.io/declarative-vs-imperative-programming-a8a7c93d9ad2" rel="noopener" target="_blank">声明式</a>代码(如HTML)是一种表达<strong class="ld ir"><em class="lz"/></strong>做什么而不描述<strong class="ld ir"> <em class="lz">如何</em> </strong>的编程范式。</p><h1 id="2897" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated"><strong class="ak">为什么反应？</strong></h1><p id="31b0" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">React为您提供了与DOM交互的工具，比原始的JavaScript或jQuery更加简洁有效。HTML、CSS、JavaScript可以放在一个组件中，它们就像“超级强大”的HTML标签。它速度快，支持代码模块化和重用。</p><h1 id="5837" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated"><strong class="ak">反应概念</strong></h1><p id="9094" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">有许多<a class="ae kc" href="https://reactjs.org/docs/introducing-jsx.html" rel="noopener ugc nofollow" target="_blank">反应概念</a>都服务于重要性。为了保持这篇文章简洁明了，我们将讨论列出的基本原则。</p><ol class=""><li id="ec83" class="ma mb iq ld b le mc li md lm me lq mf lu mg ly mh mi mj mk bi translated">成分</li><li id="3177" class="ma mb iq ld b le ml li mm lm mn lq mo lu mp ly mh mi mj mk bi translated">JSX</li><li id="752c" class="ma mb iq ld b le ml li mm lm mn lq mo lu mp ly mh mi mj mk bi translated">渲染元素</li><li id="0380" class="ma mb iq ld b le ml li mm lm mn lq mo lu mp ly mh mi mj mk bi translated">功能vs类组件和道具</li><li id="b57c" class="ma mb iq ld b le ml li mm lm mn lq mo lu mp ly mh mi mj mk bi translated">状态和处理事件</li></ol><p id="f630" class="pw-post-body-paragraph lb lc iq ld b le mc lg lh li md lk ll lm mq lo lp lq mr ls lt lu ms lw lx ly ij bi translated">还有更多更深入的主要概念。这篇文章试图在高层次上总结一些主要概念。</p></div><div class="ab cl mt mu hu mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ij ik il im in"><h1 id="21b4" class="kd ke iq bd kf kg na ki kj kk nb km kn ko nc kq kr ks nd ku kv kw ne ky kz la bi translated"><strong class="ak"> React是基于组件的</strong></h1><p id="e8dc" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">组件是编写应用程序的基础。想象一下你的UI(一个网页应用程序)，它可以被分割成独立的、可重用的部分。孤立地考虑每一件作品。每一块都是一个<a class="ae kc" href="https://www.w3schools.com/react/react_components.asp" rel="noopener ugc nofollow" target="_blank"> <strong class="ld ir">组件</strong> </a> <strong class="ld ir"> </strong>如下图所示。</p><figure class="ng nh ni nj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nf"><img src="../Images/ddde061a1bce68ae2e1b9c104c8dfe92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hr4F71bW9V5M60oe2RKkqA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://cdn-media-1.freecodecamp.org/images/1*bvQNHjZOXcl-ds9A4AWYVg.png" rel="noopener ugc nofollow" target="_blank">https://cdn-media-1 . freecodecamp . org/images/1 * bvQNHjZOXcl-ds 9 a4 awy VG . png</a></figcaption></figure><p id="5840" class="pw-post-body-paragraph lb lc iq ld b le mc lg lh li md lk ll lm mq lo lp lq mr ls lt lu ms lw lx ly ij bi translated">每个组件都是一个JavaScript函数，向屏幕(DOM)返回(呈现)React元素。</p><h1 id="6c76" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">React需要JSX吗？</h1><p id="1cdd" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated"><a class="ae kc" href="https://reactjs.org/docs/jsx-in-depth.html" rel="noopener ugc nofollow" target="_blank"> JSX </a>是JavaScript的语法扩展。React使用这种语言来描述UI应该是什么样子。它看起来像HTML，但具有JavaScript的全部功能。请参见示例语法。</p><pre class="ng nh ni nj gt nk nl nm nn aw no bi"><span id="4dcb" class="np ke iq nl b gy nq nr l ns nt">const element = &lt;h1&gt;Hello, world!&lt;/h1&gt;;</span></pre><p id="52f5" class="pw-post-body-paragraph lb lc iq ld b le mc lg lh li md lk ll lm mq lo lp lq mr ls lt lu ms lw lx ly ij bi translated">使用React不需要JSX。然而，JSX使它非常方便。看出区别。</p><p id="c229" class="pw-post-body-paragraph lb lc iq ld b le mc lg lh li md lk ll lm mq lo lp lq mr ls lt lu ms lw lx ly ij bi translated">不使用JSX的代码:</p><pre class="ng nh ni nj gt nk nl nm nn aw no bi"><span id="91ce" class="np ke iq nl b gy nq nr l ns nt">class Hello extends React.Component {<br/>  render() {<br/>    return React.createElement('div', null, `Hello ${this.props.toWhat}`);<br/>  }<br/>}<br/><br/>ReactDOM.render(<br/>  React.createElement(Hello, {toWhat: 'World'}, null),<br/>  document.getElementById('root')<br/>);</span></pre><p id="073c" class="pw-post-body-paragraph lb lc iq ld b le mc lg lh li md lk ll lm mq lo lp lq mr ls lt lu ms lw lx ly ij bi translated">用JSX写的代码:</p><pre class="ng nh ni nj gt nk nl nm nn aw no bi"><span id="c25c" class="np ke iq nl b gy nq nr l ns nt">class Hello extends React.Component {<br/>  render() {<br/>    return &lt;div&gt;Hello {this.props.toWhat}&lt;/div&gt;;<br/>  }<br/>}<br/><br/>ReactDOM.render(<br/>  &lt;Hello toWhat="World" /&gt;,<br/>  document.getElementById('root')<br/>);</span></pre><p id="5879" class="pw-post-body-paragraph lb lc iq ld b le mc lg lh li md lk ll lm mq lo lp lq mr ls lt lu ms lw lx ly ij bi translated">尝试更多Babel在线工具<a class="ae kc" href="https://babeljs.io/repl/#?presets=react&amp;code_lz=GYVwdgxgLglg9mABACwKYBt1wBQEpEDeAUIogE6pQhlIA8AJjAG4B8AEhlogO5xnr0AhLQD0jVgG4iAXyJA" rel="noopener ugc nofollow" target="_blank">中的片段来欣赏JSX ES6语法。</a></p><p id="15c7" class="pw-post-body-paragraph lb lc iq ld b le mc lg lh li md lk ll lm mq lo lp lq mr ls lt lu ms lw lx ly ij bi translated">在JSX，任何有效JavaScript表达式都放在花括号内。默认情况下，React DOM在渲染之前会对JSX中嵌入的任何值进行转义。这防止了XSS的攻击。</p><h1 id="a048" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated"><strong class="ak">渲染元素</strong></h1><p id="aaf1" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">一个元素描述了在屏幕上看到的内容。React元素是普通对象，<a class="ae kc" href="https://reactjs.org/docs/react-dom.html#render" rel="noopener ugc nofollow" target="_blank"> React DOM </a>用它们来更新实际的DOM。元素是组成组件的东西。</p><p id="6e31" class="pw-post-body-paragraph lb lc iq ld b le mc lg lh li md lk ll lm mq lo lp lq mr ls lt lu ms lw lx ly ij bi translated">在HTML文件中，确定您想要放置react元素或组件的位置。例如，在HTML文件中有:</p><pre class="ng nh ni nj gt nk nl nm nn aw no bi"><span id="f85f" class="np ke iq nl b gy nq nr l ns nt">&lt;div id="app"&gt;&lt;/div&gt;</span></pre><p id="bff4" class="pw-post-body-paragraph lb lc iq ld b le mc lg lh li md lk ll lm mq lo lp lq mr ls lt lu ms lw lx ly ij bi translated">这个<code class="fe nu nv nw nl b">&lt;div&gt;</code>中的一切都将由React DOM管理。用just React构建的应用程序只有一个根DOM节点。如果将React集成到现有的应用程序中，可能会有不同的根DOM节点。</p><p id="4c53" class="pw-post-body-paragraph lb lc iq ld b le mc lg lh li md lk ll lm mq lo lp lq mr ls lt lu ms lw lx ly ij bi translated">要渲染React元素或组件，请使用<a class="ae kc" href="https://reactjs.org/docs/react-dom.html#render" rel="noopener ugc nofollow" target="_blank"> ReactDOM.render() </a>:</p><pre class="ng nh ni nj gt nk nl nm nn aw no bi"><span id="178b" class="np ke iq nl b gy nq nr l ns nt">ReactDOM.render(element, placeWeWantToPutElementOrComponent)</span><span id="b0e3" class="np ke iq nl b gy nx nr l ns nt">// example<br/>const element = &lt;h1&gt;Hello, world&lt;/h1&gt;;<br/>ReactDOM.render(element, document.getElementById('app'));</span></pre><p id="c8eb" class="pw-post-body-paragraph lb lc iq ld b le mc lg lh li md lk ll lm mq lo lp lq mr ls lt lu ms lw lx ly ij bi translated">React只更新必要的内容。React DOM将元素及其子元素与之前的元素进行比较，并且只应用必要的DOM更新。</p><h1 id="e32d" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated"><strong class="ak">功能vs类组件和道具</strong></h1><p id="9ff8" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">我们将在下一节讨论状态。功能组件和类组件之间的主要区别是:</p><ul class=""><li id="4d74" class="ma mb iq ld b le mc li md lm me lq mf lu mg ly ny mi mj mk bi translated">功能组件是无状态的(只是接受数据并将它们显示给UI)</li><li id="be86" class="ma mb iq ld b le ml li mm lm mn lq mo lu mp ly ny mi mj mk bi translated">类组件是有状态的(通过实现逻辑和状态变得更加复杂)</li></ul><p id="496f" class="pw-post-body-paragraph lb lc iq ld b le mc lg lh li md lk ll lm mq lo lp lq mr ls lt lu ms lw lx ly ij bi translated">让我们把第一个组件写成功能性的。下面是ES6语法中的一个简单的功能组件，展示了如何将React组件放入另一个组件中。</p><p id="7d1f" class="pw-post-body-paragraph lb lc iq ld b le mc lg lh li md lk ll lm mq lo lp lq mr ls lt lu ms lw lx ly ij bi translated"><strong class="ld ir">注意:组件名称总是以大写字母开头。</strong> React将小写字母的组件视为DOM标签<code class="fe nu nv nw nl b">&lt;div /&gt;</code>，<code class="fe nu nv nw nl b">&lt;Container /&gt;</code>代表一个组件。</p><p id="9cab" class="pw-post-body-paragraph lb lc iq ld b le mc lg lh li md lk ll lm mq lo lp lq mr ls lt lu ms lw lx ly ij bi translated">组件可以接受任意输入(称为“props”，代表属性)并返回一个React元素。这是一种将数据传递给组件的方式，使它们更具动态性和可重用性。属性是不可变的，一旦从父级传入就不能更改。</p><pre class="ng nh ni nj gt nk nl nm nn aw no bi"><span id="f801" class="np ke iq nl b gy nq nr l ns nt">const Component = () =&gt; (     <br/>  &lt;h1&gt;I am a child component!&lt;/h1&gt; <br/>);</span><span id="15e3" class="np ke iq nl b gy nx nr l ns nt">const Container = (props) =&gt; (<br/>&lt;div&gt;<br/>  &lt;h1&gt;I am parent {props.name} component!&lt;/h1&gt;<br/>  &lt;Component /&gt;<br/>&lt;/div&gt;<br/>);</span><span id="ce15" class="np ke iq nl b gy nx nr l ns nt">ReactDOM.render(&lt;Container name="Container" /&gt;, document.getElementById('app'));</span></pre><p id="78dd" class="pw-post-body-paragraph lb lc iq ld b le mc lg lh li md lk ll lm mq lo lp lq mr ls lt lu ms lw lx ly ij bi translated">我们可以用Java Script的ES6类将容器组件重写为类组件，以使事情更加动态。</p><pre class="ng nh ni nj gt nk nl nm nn aw no bi"><span id="2c86" class="np ke iq nl b gy nq nr l ns nt">class Container extends React.Component {<br/>  render() {<br/>    return (      <br/>      &lt;div&gt;<br/>        &lt;h1&gt;<br/>           I am the parent <!-- -->{this.props.name}<!-- --> <!-- -->component<!-- -->!<br/>        &lt;/h1&gt;<br/>       &lt;Component /&gt; <br/>     &lt;/div&gt;    <br/>    );  <br/>  }<br/>}</span><span id="1b7a" class="np ke iq nl b gy nx nr l ns nt">const Component = () =&gt; (     <br/>  &lt;h1&gt;I am a child component!&lt;/h1&gt; <br/>);</span><span id="a349" class="np ke iq nl b gy nx nr l ns nt">ReactDOM.render(&lt;Container name="Container" /&gt;, document.getElementById('app'));</span></pre><p id="b071" class="pw-post-body-paragraph lb lc iq ld b le mc lg lh li md lk ll lm mq lo lp lq mr ls lt lu ms lw lx ly ij bi translated">上面的例子:</p><figure class="ng nh ni nj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nz"><img src="../Images/0c9746c6679296e7b6f091ed666355c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_2i7MiXejYuNLF5e5fmNvQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">上面示例中的HTML呈现</figcaption></figure><ol class=""><li id="bc31" class="ma mb iq ld b le mc li md lm me lq mf lu mg ly mh mi mj mk bi translated"><code class="fe nu nv nw nl b">ReactDOM.render()</code>将<code class="fe nu nv nw nl b">&lt;Container name="Container" /&gt;</code>渲染到DOM中。容器组件有<code class="fe nu nv nw nl b">{name="Container"}</code>作为它的道具。</li><li id="7785" class="ma mb iq ld b le ml li mm lm mn lq mo lu mp ly mh mi mj mk bi translated"><code class="fe nu nv nw nl b">&lt;Container /&gt;</code>组件返回一个带有<code class="fe nu nv nw nl b">&lt;h1 &gt;</code>和内部<code class="fe nu nv nw nl b">&lt;Component /&gt;</code>的<code class="fe nu nv nw nl b">&lt;div &gt;</code></li><li id="474f" class="ma mb iq ld b le ml li mm lm mn lq mo lu mp ly mh mi mj mk bi translated">React DOM更新DOM来匹配这个</li></ol><p id="70c2" class="pw-post-body-paragraph lb lc iq ld b le mc lg lh li md lk ll lm mq lo lp lq mr ls lt lu ms lw lx ly ij bi translated">类组件必须有一个名为<code class="fe nu nv nw nl b">render()</code>的函数。从React的角度来看，上面的两个<code class="fe nu nv nw nl b">&lt;Container /&gt;</code>组件(函数和类)是等价的。你应该使用功能组件而不是类组件，除非你需要组件"<a class="ae kc" href="https://reactjs.org/docs/state-and-lifecycle.html" rel="noopener ugc nofollow" target="_blank">状态</a>"在后面的章节中讨论。状态让React组件改变它们的输出，以响应用户动作、网络响应和其他任何事情。</p><h1 id="88d6" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated"><strong class="ak">状态</strong></h1><p id="5c65" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">为了使应用程序具有交互性，我们的组件需要做的不仅仅是接收道具。类组件可以拥有关于它们当前状态的信息，这被称为存储在Java脚本对象中的状态。状态可用于更新和重新呈现数据更改。状态仅在类组件上可用。组件内部的关键字<code class="fe nu nv nw nl b">this</code>指的是它所在的组件。</p><p id="1dfc" class="pw-post-body-paragraph lb lc iq ld b le mc lg lh li md lk ll lm mq lo lp lq mr ls lt lu ms lw lx ly ij bi translated">下面这个简单的例子有一个<code class="fe nu nv nw nl b">ToDoList</code>组件，它的当前状态是NOT done(设置为false)。</p><pre class="ng nh ni nj gt nk nl nm nn aw no bi"><span id="12bd" class="np ke iq nl b gy nq nr l ns nt">class ToDoList extends React.Component {<br/>  constructor(props) {<br/>    super(props);<br/>    this.state = {<br/>      done: false,<br/>    };<br/>  }</span><span id="5ecb" class="np ke iq nl b gy nx nr l ns nt">  render() {<br/>    const status = this.state.done ? 'Good Work' : 'YOU HAVE WORK';<br/>    return (      <br/>      &lt;div&gt;<br/>        &lt;h1&gt;<br/>           {status}<br/>        &lt;/h1&gt;<br/>     &lt;/div&gt;    <br/>    );  <br/>  }<br/>}</span><span id="8c84" class="np ke iq nl b gy nx nr l ns nt">ReactDOM.render(&lt;Container name="Container" /&gt;, document.getElementById('app'));</span></pre><p id="dea2" class="pw-post-body-paragraph lb lc iq ld b le mc lg lh li md lk ll lm mq lo lp lq mr ls lt lu ms lw lx ly ij bi translated">一旦状态被初始化，更新状态的方法是使用<code class="fe nu nv nw nl b">setSate()</code>。不要直接修改状态。唯一可以分配<code class="fe nu nv nw nl b">this.state</code>的地方是构造函数。</p><p id="0ffc" class="pw-post-body-paragraph lb lc iq ld b le mc lg lh li md lk ll lm mq lo lp lq mr ls lt lu ms lw lx ly ij bi translated">让我们与组件交互，让它知道我们已经完成了<code class="fe nu nv nw nl b">ToDoList</code>并显示正确的状态。假设有一个按钮，我们可以点击通知这一变化。</p><h1 id="5b33" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">事件处理</h1><p id="bbc8" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">用React元素处理<a class="ae kc" href="https://reactjs.org/docs/handling-events.html" rel="noopener ugc nofollow" target="_blank">事件</a>类似于处理DOM元素上的事件。有一些不同。</p><ul class=""><li id="6843" class="ma mb iq ld b le mc li md lm me lq mf lu mg ly ny mi mj mk bi translated">React事件使用大小写，而不是小写</li><li id="8e73" class="ma mb iq ld b le ml li mm lm mn lq mo lu mp ly ny mi mj mk bi translated">在JSX中传递一个花括号内的函数作为事件处理程序，而不是一个字符串</li><li id="2e2f" class="ma mb iq ld b le ml li mm lm mn lq mo lu mp ly ny mi mj mk bi translated">不能返回false以防止默认行为，必须<code class="fe nu nv nw nl b">preventDefault()</code>显式</li><li id="08bf" class="ma mb iq ld b le ml li mm lm mn lq mo lu mp ly ny mi mj mk bi translated">Reference <a class="ae kc" href="https://reactjs.org/docs/events.html#clipboard-events" rel="noopener ugc nofollow" target="_blank">由React定义的合成事件</a>的引用</li><li id="7d5d" class="ma mb iq ld b le ml li mm lm mn lq mo lu mp ly ny mi mj mk bi translated">小心<code class="fe nu nv nw nl b">this</code>在JSX的回调。默认情况下，不绑定类方法。进入<code class="fe nu nv nw nl b">onClick</code>前记得绑定<code class="fe nu nv nw nl b">this.eventHandleMethod.bind(this)</code>或ES6箭头功能。</li></ul><p id="2675" class="pw-post-body-paragraph lb lc iq ld b le mc lg lh li md lk ll lm mq lo lp lq mr ls lt lu ms lw lx ly ij bi translated">让我们添加一种用户可以通过点击按钮与组件交互的方式。当他们单击按钮时，让我们用<code class="fe nu nv nw nl b">setSate()</code>将状态done更新为true，这样就更新了状态。</p><pre class="ng nh ni nj gt nk nl nm nn aw no bi"><span id="668b" class="np ke iq nl b gy nq nr l ns nt">class ToDoList extends React.Component {<br/>  constructor(props) {<br/>    super(props);<br/>    this.state = {<br/>      done: false,<br/>    };<br/>  }</span><span id="d3ea" class="np ke iq nl b gy nx nr l ns nt">  handleClick(event) {<br/>    <!-- -->if (!this.state.done) {<br/>      this.setState({ done: true });<br/>    } else {<br/>      this.setState({ done: false });<br/>    }<!-- --> <br/>  };</span><span id="3d79" class="np ke iq nl b gy nx nr l ns nt">  render() {<br/>    const status = this.state.done ? 'Good Work' : 'YOU HAVE WORK';<br/>    return (      <br/>      &lt;div&gt;<br/>        &lt;h1&gt;<br/>           {status}<br/>        &lt;/h1&gt;<br/>        &lt;button onClick={<!-- -->this.handleClick.bind(this)<!-- -->}&gt;<br/>           Done<br/>        &lt;/button&gt;<br/>      &lt;/div&gt;    <br/>    );  <br/>  }<br/>}</span><span id="3c93" class="np ke iq nl b gy nx nr l ns nt">ReactDOM.render(&lt;Container name="Container" /&gt;, document.getElementById('app'));</span></pre><p id="81be" class="pw-post-body-paragraph lb lc iq ld b le mc lg lh li md lk ll lm mq lo lp lq mr ls lt lu ms lw lx ly ij bi translated">现在，当用户单击这个完成按钮时，<code class="fe nu nv nw nl b">ToDoList</code>组件会更新新的状态，从而呈现一个新的状态来显示。</p><p id="c070" class="pw-post-body-paragraph lb lc iq ld b le mc lg lh li md lk ll lm mq lo lp lq mr ls lt lu ms lw lx ly ij bi translated">使用嵌套组件的道具和事件，我们可以在嵌套组件之间进行更多的交流。道具不一定只是信息，它们也可以是功能。我们还可以将参数传递给事件处理程序。还有其他资源可以展示这些简单的<a class="ae kc" href="https://reactjs.org/docs/handling-events.html" rel="noopener ugc nofollow" target="_blank">示例</a>。</p></div><div class="ab cl mt mu hu mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ij ik il im in"><p id="19bf" class="pw-post-body-paragraph lb lc iq ld b le mc lg lh li md lk ll lm mq lo lp lq mr ls lt lu ms lw lx ly ij bi translated">我希望这提供了React中一些基本概念的简单概述。这些概念有更多的深度，还有其他一些我没有讨论的强有力的概念。React的网站是我的资源，并有惊人的教程和指南，以进一步发现。</p><div class="oa ob gp gr oc od"><a href="https://reactjs.org/docs/getting-started.html" rel="noopener  ugc nofollow" target="_blank"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd ir gy z fp oi fr fs oj fu fw ip bi translated">开始行动-做出反应</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">用于构建用户界面的JavaScript库</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">reactjs.org</p></div></div><div class="om l"><div class="on l oo op oq om or jw od"/></div></div></a></div></div><div class="ab cl mt mu hu mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ij ik il im in"><p id="c8b1" class="pw-post-body-paragraph lb lc iq ld b le mc lg lh li md lk ll lm mq lo lp lq mr ls lt lu ms lw lx ly ij bi translated">我已经完成了第六周的黑客反应堆，我们用React制作了一个YouTube视频播放器。使用与YouTube的数据API的交互。我们接下来要做的是Redux/React。希望这个指南对外面的人有用！</p></div></div>    
</body>
</html>