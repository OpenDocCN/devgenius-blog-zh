<html>
<head>
<title>Golang’s most important feature is invisible</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Golang最重要的特点是隐形</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/golangs-most-important-feature-is-invisible-6be9c1e7249b?source=collection_archive---------1-----------------------#2022-01-15">https://blog.devgenius.io/golangs-most-important-feature-is-invisible-6be9c1e7249b?source=collection_archive---------1-----------------------#2022-01-15</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/c6b0de136a968498df75e2da33f7dff8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VfjL53hMMwU9gc9m921kmg.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">照片由<a class="ae jz" href="https://unsplash.com/@metriics?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">夏羽·加尼翁</a>在<a class="ae jz" href="https://unsplash.com/s/photos/threads?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="dc79" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">TLDR</strong>:Go标准运行时允许异步编码，同时给开发者一个简单的同步接口。</p><p id="c105" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我从事围棋专业工作已经有几年了，有一件事让我一再感到惊讶，那就是我认为围棋最重要的特性得到的关注是如此之少。</p><p id="6eea" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当被问及Go最重要的特性时，许多人会列出Go的简单性、C互操作性、编译速度和并发性。所有这些都是重要的特征，但我认为最重要的特征几乎是看不见的，可能非常微妙。</p><p id="726d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们从一个展示该特性的代码示例开始，看看您自己能否猜出来？</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="d317" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你看到了吗？那里没有很多代码。老实说，这段代码演示了我所说的特性，但是因为它是标准Go运行时的一部分，所以它是不可见的。为了更好地突出这个特性，让我们看一个用Java编写的类似代码的例子。</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="ff9b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">长得挺像的。。。但事实并非如此。忽略代码较长，一个好的IDE会抵消这些权衡。为了让这段代码像Go代码一样运行，你需要做很多额外的工作。你猜到了吗？</p><p id="8139" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我所说的特性是Go runtimes对阻塞goroutines的处理。当我第一次开始使用Go时，我认为goroutines是Java绿色线程的一个更有效的变体，但当我编写看起来像传统的阻塞I/O的代码时，我从来没有想到它实际上更类似于异步I/O。很明显，在进行阻塞调用时，Go能够更有效地调度工作。为了从Java中获得这种性能，你需要添加线程池、期货或其他一些异步库。</p><p id="f9bc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是不要相信我关于性能的话，让我们进行一个快速的性能测试。这些结果是使用Apache Bench运行的，并且是在具有充足预热时间的同一台机器上运行的。</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="lc ld l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">Apache Bench在Go Web服务器上运行</figcaption></figure><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="lc ld l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">Apache Bench在Java Web服务器上运行</figcaption></figure><p id="5e89" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">长话短说，Java版本达到每秒21K请求，而Go版本达到每秒36K请求。</p><p id="5b04" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当然，这是一个合成的例子，但与我经常使用的模式相差不远。一个网络请求进来，它被处理，路由到一些代码，这些代码工作，通常是另一个基于网络或磁盘的请求，然后结果被返回。在Go中，网络和磁盘上的所有阻塞都得到了非常高效的处理。在Java和大多数其他语言中，您也可以获得这种好处，但是它通常需要更多的代码、计划和测试。围棋几乎是免费的。这是非常强大的。</p><p id="e08d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在像C这样的语言中，你可以使用libevent这样的库来获得这种类型的行为。在Java中，你可以使用线程池和期货。在python中，你会依赖async/await。但是在Go中你可以免费得到它，你可以像写同步代码一样写代码，在任何时候发生阻塞，goroutine都可以被挂起，其他准备好工作的Go routine可以被调度。</p><p id="ccbd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所以，作为一个做很多这种模式工作的服务器工程师，我认为这是Go最强也是经常被误解的特性！</p><p id="a6d7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你怎么想呢?</p></div><div class="ab cl le lf hr lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="ig ih ii ij ik"><p id="947d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">要更深入地了解Java &amp; Go并发校验:</p><div class="ll lm gp gr ln lo"><a href="https://medium.com/@genchilu/javas-thread-model-and-golang-goroutine-f1325ca2df0c" rel="noopener follow" target="_blank"><div class="lp ab fo"><div class="lq ab lr cl cj ls"><h2 class="bd io gy z fp lt fr fs lu fu fw im bi translated">Java的线程模型和Golang Goroutine</h2><div class="lv l"><h3 class="bd b gy z fp lt fr fs lu fu fw dk translated">Golang最重要的特性之一是处理高并发的能力。而goroutine是基础…</h3></div><div class="lw l"><p class="bd b dl z fp lt fr fs lu fu fw dk translated">medium.com</p></div></div><div class="lx l"><div class="ly l lz ma mb lx mc jt lo"/></div></div></a></div></div></div>    
</body>
</html>