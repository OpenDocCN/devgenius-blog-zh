<html>
<head>
<title>Optimization of OpenGL ES vertex data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">OpenGL ES顶点数据的优化</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/optimization-of-opengl-es-vertex-data-b76927a63922?source=collection_archive---------13-----------------------#2020-07-12">https://blog.devgenius.io/optimization-of-opengl-es-vertex-data-b76927a63922?source=collection_archive---------13-----------------------#2020-07-12</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/f470e83cd618e08153c804b406e7e5bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yUC024OCoTAOM8PF"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">由<a class="ae jz" href="https://unsplash.com/@vantorin?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">尼基塔·万托林</a>在<a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="c726" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们的Android应用是动态壁纸，所以轻量级对它们来说非常重要。为了实现最佳性能、最小内存和功耗，我们不断通过减少资源大小和使用硬件支持的各种压缩来改进我们的应用。</p><p id="e16b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><a class="ae jz" href="https://play.google.com/store/apps/details?id=org.androidworks.livewallpaperbuddha" rel="noopener ugc nofollow" target="_blank"> 3D佛像动态壁纸</a>的最新更新引入了更紧凑的存储3D对象，以节省内存和提高性能。我们以同样的方式更新了它的<a class="ae jz" href="https://keaukraine.github.io/webgl-buddha/index.html" rel="noopener ugc nofollow" target="_blank"> WebGL演示</a>，在本文中，我们将描述这一优化的过程。</p><h1 id="ad24" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">OpenGL ES / WebGL中的紧凑数据类型</h1><p id="1edb" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">以前在我们的应用中，我们只使用浮动来存储所有的逐顶点信息——位置、法线、颜色等。这些是标准的32位IEEE-754浮点值，足够通用来保存从顶点坐标到颜色的任何类型的信息。</p><p id="ab24" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然而，并非所有类型的数据都需要32位浮点精度。和OpenGL ES 2.0/WebGL有其他不太精确但更紧凑的数据类型来代替32位浮点。</p><p id="03e9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">首先，OpenGL支持16位和8位有符号和无符号整数。那么整数值怎么代替浮点数呢？有两种选择——在着色器中按原样使用整数值，并将它们转换为浮点型，或者将其规格化。规范化意味着驱动程序/GPU执行从整数到浮点值的转换，顶点着色器接收准备使用的浮点值。规范化将整数值转换为范围[0，1]或[-1，1]，具体取决于它们是无符号整数还是有符号整数。规范化值的精度由源整数值的范围指定-源整数中的位数越多，精度就越高。</p><figure class="mc md me mf gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mb"><img src="../Images/af0f4716d0a31c6c4ce18f3f0de85b77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LVG0t8ebADKtlIemrvTXzw.png"/></div></div></figure><p id="ed11" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，例如，无符号字节值128将被规范化为0.5，有符号short -16383将被规范化为-0.5。你可以在这个OpenGL wiki页面上阅读更多关于规格化整数转换的内容。</p><p id="7aad" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">要使用规范化整数，必须将<code class="fe mg mh mi mj b">glVertexAttribPointer</code>的规范化参数设置为<code class="fe mg mh mi mj b">true</code>，着色器将接收规范化浮点。</p><p id="40e8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">存储在无符号字节中的典型值是颜色，因为颜色分量不需要超过1/256的精度，3或4个无符号字节分别存储RGB或RGBA颜色是最理想的。两个shorts可用于存储典型3D模型的UV坐标，假设它们在[0，1]范围内，并且在网格上不使用重复纹理。它们为这些需求提供了足够的精度——例如，无符号短整型将提供子纹理像素精度，即使对于维度为4096的纹理，因为它的精度是1/65536。</p><p id="c3ba" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">较新的OpenGL ES 3.0(以及基于它的WebGL 2)引入了新的紧凑数据类型:</p><ul class=""><li id="8a0c" class="mk ml in kc b kd ke kh ki kl mm kp mn kt mo kx mp mq mr ms bi translated">顶点数据的半浮点数—这些是16位IEEE-754浮点数。它们使用类似于<code class="fe mg mh mi mj b">GL_SHORT</code>的2个字节，但是它们的范围和精度不像标准化值那样有限。</li><li id="c46e" class="mk ml in kc b kd mt kh mu kl mv kp mw kt mx kx mp mq mr ms bi translated">4字节打包格式<code class="fe mg mh mi mj b">INT_2_10_10_10_REV</code>，包含4个可以规格化为浮点数的整数值。其中三个整数具有10位精度，一个只有2位精度。该格式在<a class="ae jz" href="https://www.khronos.org/registry/OpenGL/specs/es/3.0/es_spec_3.0.pdf" rel="noopener ugc nofollow" target="_blank"> OpenGL ES 3.0规范</a>的第2.9.2节中有描述。</li></ul><p id="4734" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在某些硬件上，规范化整数类型的使用可能不是免费的，可能需要几个额外的GPU周期来将值转换为浮点，然后再将它们输入到着色器中。然而，内存节省比额外的转换开销提供了更多的好处，因为它是逐顶点执行的。</p><h1 id="4891" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">步幅、偏移量和间距</h1><p id="0d8c" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">在我们的管道中，我们使用两步方法——首先生成顶点数据，然后进行压缩。首先，源OBJ和FBX文件被GPU阵列转换为随时可用的文件——顶点索引和交错顶点属性数据(步长)。下一步是将浮点值转换成更紧凑的数据类型。这是用运行在Node.js上的JavaScript编写的命令行实用程序完成的。你可以从GitHub 获得它<a class="ae jz" href="https://github.com/keaukraine/stride-compressor" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="7506" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了实现读取顶点数据的最佳缓存一致性，建议创建一定大小的步幅。然而，这取决于GPU的类型，因此对于最佳的总步幅大小，存在相当不同的建议:</p><ul class=""><li id="3fcb" class="mk ml in kc b kd ke kh ki kl mm kp mn kt mo kx mp mq mr ms bi translated">根据官方<a class="ae jz" href="https://developer.apple.com/library/archive/documentation/3DDrawing/Conceptual/OpenGLES_ProgrammingGuide/TechniquesforWorkingwithVertexData/TechniquesforWorkingwithVertexData.html" rel="noopener ugc nofollow" target="_blank">苹果iOS OpenGL ES文档</a>，步幅大小必须是4字节的倍数，才能达到最佳性能，减少驱动开销。显然这是由苹果芯片的架构造成的，它们基于Imagination Technologies PowerVR GPU。</li><li id="888e" class="mk ml in kc b kd mt kh mu kl mv kp mw kt mx kx mp mq mr ms bi translated">官方<a class="ae jz" href="https://cdn.imgtec.com/sdk-documentation/PowerVR.Performance+Recommendations.pdf" rel="noopener ugc nofollow" target="_blank"> PowerVR性能建议</a>文档含糊地指出，一些硬件可能会受益于16字节边界对齐的步长。</li><li id="e024" class="mk ml in kc b kd mt kh mu kl mv kp mw kt mx kx mp mq mr ms bi translated">ARM在其<a class="ae jz" href="https://developer.arm.com/docs/dui0555/a/optimization-checklist/ensure-your-application-is-not-cpu-bound/align-data" rel="noopener ugc nofollow" target="_blank">应用优化指南</a>中建议将数据对齐为8字节，以在Mali GPUs上获得最佳性能。</li><li id="9772" class="mk ml in kc b kd mt kh mu kl mv kp mw kt mx kx mp mq mr ms bi translated">对于高通Adreno GPUs的顶点数据对齐，没有官方建议。</li></ul><p id="c483" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们的工具按4字节排列数据以节省更多内存(在我们的应用程序中，我们不使用具有过多顶点的模型，因此访问顶点数据不是瓶颈)。</p><p id="09c5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">接下来，当您在交叉顶点数据中使用混合数据类型时，每个属性数据必须在跨距内正确对齐。这在<a class="ae jz" href="https://www.khronos.org/registry/OpenGL/specs/es/3.0/es_spec_3.0.pdf" rel="noopener ugc nofollow" target="_blank"> OpenGL ES 3.0规范</a>的第2.10.2节中有所说明——属性偏移量必须是相应数据类型大小的倍数。如果你不满足这个要求，Android和WebGL上的OpenGL ES的行为会有所不同。OpenGL ES不会产生任何错误，结果取决于硬件(可能还有驱动程序)——adre no GPU似乎可以处理这样的畸形数据而不会产生任何错误，而Mali GPUs却无法绘制任何东西。另一方面，WebGL实现检测未对齐的交错属性，您会在控制台中发现错误或警告。</p><p id="3a0e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Chrome给出以下错误:</p><blockquote class="my mz na"><p id="592f" class="ka kb nb kc b kd ke kf kg kh ki kj kk nc km kn ko nd kq kr ks ne ku kv kw kx ig bi translated">GL_INVALID_OPERATION:偏移量必须是传入数据类型的倍数。</p></blockquote><p id="90db" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Firefox会生成以下警告:</p><blockquote class="my mz na"><p id="0b4e" class="ka kb nb kc b kd ke kf kg kh ki kj kk nc km kn ko nd kq kr ks ne ku kv kw kx ig bi translated">WebGL警告:vertexAttribI？指针:“stride”和“byteOffset”必须满足“type”的对齐要求。</p></blockquote><p id="ad79" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们的工具可以添加空白填充字节来正确对齐任何数据类型。</p><p id="09a8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如前所述，OpenGL ES 3.0和WebGL 2支持特殊的打包<code class="fe mg mh mi mj b">INT_2_10_10_10_REV</code>结构，其中包含三个10位和一个2位有符号整数。这种数据类型提供了比byte稍好的精度，但只比3个单独的字节多占用1个字节。我们的工具可以将3个浮点数转换成这种打包的数据类型。请注意，即使你只使用这个结构中的3个组件，你也应该在使用它时为<code class="fe mg mh mi mj b">glVertexAttribPointer</code>指定大小4(在着色器中，你仍然可以使用<code class="fe mg mh mi mj b">vec3</code>制服，w组件将被忽略)。</p><p id="fdd6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里有三个不同的压缩和对齐步幅的例子。由32位浮点组成的每个步长的原始大小为40字节(10个浮点)-3个浮点用于顶点坐标，4个用于两组UV坐标(漫反射和光照贴图)，3个用于法线。以下是以三种不同方式压缩到每顶点16字节(比原始数据小60%)的相同数据的示例，而没有视觉上可感知的质量损失。</p><p id="4ba3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">原始步幅:</p><figure class="mc md me mf gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nf"><img src="../Images/ca0d80183e19293924f4c43dac0eea10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N8LkRgsEQoLhdV_7UL0j4A.png"/></div></div></figure><p id="221d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">压缩步幅的不同变体:</p><figure class="mc md me mf gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ng"><img src="../Images/0fcd5d7c4e4c112c9358ff21976d40b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-sBljKWNrDFh-0FjyTbrkw.png"/></div></div></figure><p id="92ed" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">数据类型的颜色代码:</p><figure class="mc md me mf gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nh"><img src="../Images/2e56aaf49cc0c831d0d6a3bd4d668a96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oBbzNgfS4SsP_gyGKZdf2w.png"/></div></div></figure><p id="2931" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在第一种情况下，法线不需要对齐，因为它们使用标准化的<code class="fe mg mh mi mj b">GL_UNSIGNED_BYTE</code>类型。第二种情况是将所有正常值打包到一个<code class="fe mg mh mi mj b">INT_2_10_10_10_REV</code>结构中，以获得更高的精度。请注意，这要求它与4个边界的倍数对齐。对于这种对齐，添加了2个未使用的填充字节，将法线偏移12。第一种情况的有用数据大小是13个字节，其中3个填充字节用于对齐总步幅大小，第二种情况使用14个字节，其中2个未使用的字节用于内部对齐。它们都适合16个字节(最接近4的倍数)，以便GPU更有效地获取整个步长。</p><p id="d36d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您可能希望交换某些属性以紧密适应数据，并消除使用内部空填充的必要性。一般来说，将最大的数据类型放在前面会使较小的数据类型更容易对齐。例如，在第三种情况下，打包法线存储在偏移量0处，因为这不会导致半浮点和其后的字节错位，所以不需要添加内部填充字节。</p><h1 id="e467" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">尺寸、性能和质量差异</h1><p id="286b" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">我们已经压缩了佛像模型的顶点数据，对位置使用半浮点，对漫射和光照贴图UV坐标使用无符号字节，对法线使用有符号字节。这导致未压缩(gzip之前)的数据大小从47 kB减少到18 kB。</p><p id="3ad2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">即使我们对UV坐标使用了最不精确的精度，这也足够了，因为在这个模型中我们没有使用大于256x256的纹理。而规格化的有符号字节对于法线来说就足够了。法线的测试可视化显示各种数据类型之间没有视觉差异，只有感知差异可以发现某些像素之间的微小差异。Medium不支持动画WebP，所以你可以使用这个<a class="ae jz" href="https://drive.google.com/file/d/1wTSQiQSS2HRPCSQkMShxuRgfcTrC11Ka/view?usp=sharing" rel="noopener ugc nofollow" target="_blank"> Google Drive链接</a>来预览它。</p><figure class="mc md me mf gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ni"><img src="../Images/21d6ccf3d5db56ef4fe395d6087103ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IoETmzyO6bKTnCiYPlxCJA.png"/></div></div></figure><p id="08f0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了准确测量优化如何影响内存使用，我们使用<a class="ae jz" href="https://developer.qualcomm.com/software/snapdragon-profiler" rel="noopener ugc nofollow" target="_blank">骁龙分析器</a>来捕获两个实时顶点数据指标的平均值。在谷歌Pixel 3上，我们得到了以下结果:</p><figure class="mc md me mf gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nj"><img src="../Images/7e206a9b268992b7fda50fdfb830b158.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fLsxUWdMstx3GecagghZKA.png"/></div></div></figure><p id="6d82" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是一个重大的变化，减少了应用程序的总内存消耗，也减少了总内存带宽。减少的GPU负载允许在动态壁纸上绘制更平滑的系统UI，并提高电池使用率。</p><h1 id="a6bb" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">结果</h1><p id="f2f1" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">你可以从<a class="ae jz" href="https://play.google.com/store/apps/details?id=org.androidworks.livewallpaperbuddha" rel="noopener ugc nofollow" target="_blank"> Google Play </a>获得更新的Android动态壁纸，在这里观看更新的直播<a class="ae jz" href="https://keaukraine.github.io/webgl-buddha/index.html" rel="noopener ugc nofollow" target="_blank"> WebGL演示，在这里</a>查看其<a class="ae jz" href="https://github.com/keaukraine/webgl-buddha" rel="noopener ugc nofollow" target="_blank">来源。</a></p></div></div>    
</body>
</html>