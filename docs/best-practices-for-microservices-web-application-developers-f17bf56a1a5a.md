# 微服务/ Web 应用程序开发人员的最佳实践

> 原文：<https://blog.devgenius.io/best-practices-for-microservices-web-application-developers-f17bf56a1a5a?source=collection_archive---------5----------------------->

![](img/5f6ed0ee37ffb3e9f74025d98f2d06db.png)

现在让我们深入了解一些最佳实践。这些最佳实践将指导您创建一个易于操作的安全系统。

# 设计

*   设计应该是领域驱动的。
*   尽可能去做一个新的设计。如果你的服务中有一些与你的服务无关的东西，那就全部去掉。因此，在这种情况下，我们不需要重新设计一切，但我们可以隔离，然后使我们的服务独立。

# 硬编码值

*   让我们假设两个服务 A 和 B。现在 A 正在调用 B。因此 A 有服务 B 的地址。在这种情况下，大多数开发人员对此进行硬编码。(可能是服务上的主机名/IP 地址)。现在服务 a 知道服务 B 在哪里。
*   问题出现在…

> 如果网络团队决定改变主机或他们决定改变网络地址。因为我们必须发送其他部署/需要改变代码，并在部署过程中做同样的事情。许多艰苦的工作..

*   为了避免这种情况，我们可以使用服务发现机制来发现第二个服务。(服务 B)

# 记录

*   由于没有在第一时间恢复问题，可能会出现相同错误记录两次的情况。最佳实践是，如果出现故障，立即返回，但不要记录日志。
*   我们必须记录堆栈跟踪以了解问题的部分。(地点详情)

让我们想一个场景。假设你收到一个分配 X 辆车给 Y 个客户的请求，那么在你把这个请求发送给你的服务层之前，你可以生成一个 ID。假设是 001。(为了更好地理解流程，它将被标记为服务启动)。为此，我们可以使用日志附加器。

*   请确保将调试警告错误信息记录在单独的类别和级别中，这样才有意义。(单独类别中的 log-debug-warn-error-info)。因此，当问题出现时，我们可以很容易地检查每个部分。

# 版本控制

*   **语义版本化**:是根据变更的严重程度分配版本号的实践。比如 v1。与 v1 相比，0.1 将只有很小的补丁。0.0 ;v1。
*   **强制升级**:让我们用一个场景来明确这个概念。以两个服务 A 和 B 为例。A 将调用服务 B。因此我们必须更新服务 B。因此在更新期间，我们必须更改数据库结构，以便服务结构会有所不同。所以当我们推这个新版本的服务 B 的时候，服务 A 就坏了。

**解决方案**:增加一个主版本号，并将其部署为一个单独的服务。现在你有一个 B 服务版本 1.00 和 B 服务版本 2.00。因此我们的流量仍然采取 1.00 版本。所以我们需要通知消费者，通知功能必须更新到此功能。因此，所有消费者都将迁移到 2.00 版本。

# 授权和认证机制

*   如果您的每个服务都试图验证用户，那么它会增加更多的延迟。

**解决方案:创建一个**独立的身份验证服务，当请求到达服务层时，它可以指向这个身份服务，如果成功，它可以指向相关的路径。在这里，我们已经强行转发到了特定的服务。在这种情况下，我们可以避免一些延迟，当然，在任何给定的时间，您都可以根据我们的要求更改验证过程或认证授权过程。

# 属国

*   我们应该避免对我们服务的任何依赖。假设有 3 个服务 A、B、C，我们应该能够分别部署 A 或 B 或 C，而不用担心破坏其他服务。

# 容错

*   由于存在多种服务，因此可能存在多种故障可能性。因此，在这种情况下，强烈建议拥有一个强大的容错机制，以避免排队并缩短故障时刻的响应时间。

# 证明文件

*   有必要用一种技术性的方式来写文档，并以更好的理解来吸引文档。因此，消费者可以查看这些文档并尝试一些服务。

参考: