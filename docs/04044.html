<html>
<head>
<title>Angular — Simple Understanding with RxJS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">角度—对 RxJS 的简单理解</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/angular-simple-understanding-with-rxjs-d5fbb4facb9f?source=collection_archive---------2-----------------------#2021-01-19">https://blog.devgenius.io/angular-simple-understanding-with-rxjs-d5fbb4facb9f?source=collection_archive---------2-----------------------#2021-01-19</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="2fcf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对角度的简单理解。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/bd70bac164a0e7b8f95b95a3fd1c77c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JBv7LO2dC6siN9JVBsBqWg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">用 RxJS 对角度的简单理解。</figcaption></figure><p id="8204" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这里，我们将第一次谈论对角度的简单理解，自从我写了一篇关于 ReactJS / React Native 的文章。</p><p id="3b3b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">首先，很抱歉，我几个月前还没有写文章，因为有很多事情要做，所以我没有时间写文章。不管怎样，这是我写的新文章！</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><p id="e0a4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">我知道，棱角分明很难学，但是嘿！这篇文章对 Angular 有一个简单的理解，让你在开始学习 Angular 的时候不会困惑或者挣扎。所以，让我们关注好的方面。</strong></p><h1 id="675b" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">遵循这篇文章的要求</h1><ol class=""><li id="98e7" class="md me in jm b jn mf jr mg jv mh jz mi kd mj kh mk ml mm mn bi translated">非常基础的 JavaScript(ES6)</li><li id="6693" class="md me in jm b jn mo jr mp jv mq jz mr kd ms kh mk ml mm mn bi translated">非常基本的类型脚本(可选)</li></ol><h1 id="9646" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">跟随这篇文章的必备工具</h1><h2 id="efa0" class="mt lg in bd lh mu mv dn ll mw mx dp lp jv my mz lt jz na nb lx kd nc nd mb ne bi translated">1.NodeJS</h2><p id="9ab0" class="pw-post-body-paragraph jk jl in jm b jn mf jp jq jr mg jt ju jv nf jx jy jz ng kb kc kd nh kf kg kh ig bi translated">重要的是 NodeJS 本身，因为 NodeJS 带有<strong class="jm io"> NPM </strong>，在这种情况下，我们将使用它来安装 ReactJS。你可以在这里下载<a class="ae ni" href="https://nodejs.org/en" rel="noopener ugc nofollow" target="_blank"> NodeJS </a>。我推荐安装<strong class="jm io"> LTS </strong>版本，我写这篇文章的时候用的是 v 14 . 15 . 0<em class="nj">。</em></p><h2 id="b8c6" class="mt lg in bd lh mu mv dn ll mw mx dp lp jv my mz lt jz na nb lx kd nc nd mb ne bi translated">2.文字编辑器</h2><p id="0080" class="pw-post-body-paragraph jk jl in jm b jn mf jp jq jr mg jt ju jv nf jx jy jz ng kb kc kd nh kf kg kh ig bi translated">有很多文本编辑器，我更喜欢使用<strong class="jm io"> VSCode </strong>，你可以在这里下载<a class="ae ni" href="https://code.visualstudio.com" rel="noopener ugc nofollow" target="_blank"> VSCode </a>。<br/>如果你想使用像<strong class="jm io"> Sublime Text </strong>或<strong class="jm io"> Atom、</strong>这样的文本编辑器，选择适合你的工具就可以了。</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h1 id="7601" class="lf lg in bd lh li nk lk ll lm nl lo lp lq nm ls lt lu nn lw lx ly no ma mb mc bi translated">我为什么写这篇文章</h1><p id="0e9f" class="pw-post-body-paragraph jk jl in jm b jn mf jp jq jr mg jt ju jv nf jx jy jz ng kb kc kd nh kf kg kh ig bi translated">胡达，你为什么写这篇文章？为什么你不再写一篇关于 React / React Native 或者 NodeJS 或者其他东西的文章呢？为什么是棱角分明的男人？！</p><p id="f9d4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">好吧，是这样的，几天后我有空闲时间。不知道为什么开始学棱角分明。所以我自己说，为什么你才开始写一篇关于棱角分明的文章？我是说，为什么不呢？开始学的时候很好奇别人说的很难学的 Angular。伙计。很辛苦哈哈哈。</p><p id="75e6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这就是为什么我创作了一篇有棱角的文章。似乎很有趣。</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h1 id="088c" class="lf lg in bd lh li nk lk ll lm nl lo lp lq nm ls lt lu nn lw lx ly no ma mb mc bi translated">什么是有角？</h1><p id="1f02" class="pw-post-body-paragraph jk jl in jm b jn mf jp jq jr mg jt ju jv nf jx jy jz ng kb kc kd nh kf kg kh ig bi translated">Angular 是 Google 开发的健壮前端或 JavaScript 框架之一，我应该说 Angular 的意思是，它和其他框架一样。和 React 或者 Vue 一样。但是，有角的区别比任何其他框架都大:</p><ol class=""><li id="aab0" class="md me in jm b jn jo jr js jv np jz nq kd nr kh mk ml mm mn bi translated">基本代码。</li><li id="7fa0" class="md me in jm b jn mo jr mp jv mq jz mr kd ms kh mk ml mm mn bi translated">复杂代码。</li><li id="c419" class="md me in jm b jn mo jr mp jv mq jz mr kd ms kh mk ml mm mn bi translated">使用依赖注入。</li><li id="752d" class="md me in jm b jn mo jr mp jv mq jz mr kd ms kh mk ml mm mn bi translated">使用 TypeScript。</li><li id="c2c1" class="md me in jm b jn mo jr mp jv mq jz mr kd ms kh mk ml mm mn bi translated">MVC 模式。</li><li id="19c4" class="md me in jm b jn mo jr mp jv mq jz mr kd ms kh mk ml mm mn bi translated">CLI。</li></ol><p id="aa3e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Angular 的用途是，和另一个前端框架一样，但是和另一个框架最大的不同，它内置了<strong class="jm io">类型脚本</strong>和<strong class="jm io"> CLI </strong>。我假设你知道 CLI 是，那么什么是 TypeScript？TypeScript 是一种使用静态类型的 Javascript，如 Java、Golang 等。这就是 Angular 比其他任何框架都更健壮的原因，因为它的代码更加结构化。</p><p id="4bad" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您可以访问下面的 Angular 和 TypeScript 文档:</p><p id="21d6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">棱角分明的文件</strong>:</p><div class="ns nt gp gr nu nv"><a href="https://angular.io/guide/setup-local" rel="noopener  ugc nofollow" target="_blank"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd io gy z fp oa fr fs ob fu fw im bi translated">有角的</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">Angular 是一个构建移动和桌面 web 应用程序的平台。加入数百万开发者的社区…</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">angular.io</p></div></div></div></a></div><p id="f71a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">打字稿</strong>:</p><div class="ns nt gp gr nu nv"><a href="https://www.typescriptlang.org/" rel="noopener  ugc nofollow" target="_blank"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd io gy z fp oa fr fs ob fu fw im bi translated">任意比例的输入 JavaScript。</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">TypeScript 通过向语言中添加类型来扩展 JavaScript。TypeScript 通过以下方式加速您的开发体验…</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">www.typescriptlang.org</p></div></div><div class="oe l"><div class="of l og oh oi oe oj ks nv"/></div></div></a></div></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h1 id="b8eb" class="lf lg in bd lh li nk lk ll lm nl lo lp lq nm ls lt lu nn lw lx ly no ma mb mc bi translated">我们开始吧</h1><p id="3926" class="pw-post-body-paragraph jk jl in jm b jn mf jp jq jr mg jt ju jv nf jx jy jz ng kb kc kd nh kf kg kh ig bi translated">好吧，那么我们要构建什么样的应用程序呢？我们将使用 Angular 构建一个简单的 todo 应用程序，让您简单并完全理解。我们将使用一个名为<a class="ae ni" href="https://jsonplaceholder.typicode.com/" rel="noopener ugc nofollow" target="_blank"> JSON Typicode </a>的假 rest API。</p><p id="6cd3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我假设您已经安装了 NodeJS。</p><h2 id="c114" class="mt lg in bd lh mu mv dn ll mw mx dp lp jv my mz lt jz na nb lx kd nc nd mb ne bi translated"><strong class="ak"> 1。安装角度 CLI </strong></h2><p id="de9c" class="pw-post-body-paragraph jk jl in jm b jn mf jp jq jr mg jt ju jv nf jx jy jz ng kb kc kd nh kf kg kh ig bi translated">首先，您需要使用 NPM 安装<strong class="jm io"> Angular CLI，</strong>下面是您必须在终端/命令提示符下运行的代码:</p><pre class="kj kk kl km gt ok ol om on aw oo bi"><span id="af1f" class="mt lg in ol b gy op oq l or os">npm install -g @angular/cli</span></pre><p id="a67f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">上面的命令将在您的本地计算机上全局安装 Angular CLI。</p><h2 id="74d8" class="mt lg in bd lh mu mv dn ll mw mx dp lp jv my mz lt jz na nb lx kd nc nd mb ne bi translated">2.使用 Angular CLI 创建新项目</h2><p id="ad9f" class="pw-post-body-paragraph jk jl in jm b jn mf jp jq jr mg jt ju jv nf jx jy jz ng kb kc kd nh kf kg kh ig bi translated">成功安装 Angular CLI 后，您必须创建一个新项目。创建新项目的命令非常简单，命令如下:</p><pre class="kj kk kl km gt ok ol om on aw oo bi"><span id="109a" class="mt lg in ol b gy op oq l or os">ng new project-name-here</span></pre><p id="48bd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">上面的代码，会把 Angular 安装在你当前的目录下，确保你把它安装在你想要的正确的目录下。成功创建新项目后，您可以在文本编辑器中打开它。成功创建新项目后，结果如下。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/931b1086455e4497811cfeea8a028853.png" data-original-src="https://miro.medium.com/v2/resize:fit:630/format:webp/1*n8GO85FRXz9TOQXLb503AA.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">angular v11.0.4 的全新项目</figcaption></figure><p id="2f9a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是你的项目目录，看起来很复杂，而且很多，我要重复一下正在发生的事情。</p><ol class=""><li id="419c" class="md me in jm b jn jo jr js jv np jz nq kd nr kh mk ml mm mn bi translated"><strong class="jm io"> e2e </strong>，包含单元测试的文件夹。</li><li id="7fbf" class="md me in jm b jn mo jr mp jv mq jz mr kd ms kh mk ml mm mn bi translated"><strong class="jm io"> src </strong>，一个常用文件夹，包含一个文件和 app 的文件夹(我们重点看这个)。</li><li id="7912" class="md me in jm b jn mo jr mp jv mq jz mr kd ms kh mk ml mm mn bi translated"><strong class="jm io">资产</strong>，包含样式、图像或您拥有的其他资产的文件夹。</li></ol><p id="aec3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一旦你阅读了这篇文章，我会解释其他的事情。因此，确保像项目一样在正确的目录下打开终端/命令提示符。您可以使用下面的命令启动应用程序:</p><pre class="kj kk kl km gt ok ol om on aw oo bi"><span id="ac7c" class="mt lg in ol b gy op oq l or os">// Start the common server<br/>ng serve</span><span id="7810" class="mt lg in ol b gy ou oq l or os">// Start the common server by opening automatically in the browser<br/>ng serve --open</span></pre><p id="3968" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">默认情况下，它将在本地主机的 4200 端口打开。这是你创建的 fresh 应用的截图。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ov"><img src="../Images/150fc763f39e978e10d06f5acbbb28de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o5isgN962dS5n4idABgAiA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">全新项目 Angular 版本 11.0.4</figcaption></figure><h2 id="89ba" class="mt lg in bd lh mu mv dn ll mw mx dp lp jv my mz lt jz na nb lx kd nc nd mb ne bi translated"><strong class="ak"> 3。开始制作 Todo App </strong></h2><p id="5046" class="pw-post-body-paragraph jk jl in jm b jn mf jp jq jr mg jt ju jv nf jx jy jz ng kb kc kd nh kf kg kh ig bi translated">好的，确保你没有错过第一步和第二步。在这里，我们将打开代码并清除应用程序，以启动我们将要构建的 Todo 应用程序。</p><p id="b858" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以，打开<strong class="jm io">src/app/app . component . html</strong>中的文件，清除里面的代码，就像下图这样。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ow"><img src="../Images/5c6d89e822cd360fb33fcc3e6140ea79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*B_hd7T5I7nHr37tdUMW68A.gif"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">清除 src/app/app.component.html 的代码</figcaption></figure><p id="254e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你清除这些代码，然后打开浏览器，它会变得干净，变成一个空白页，因为你去掉了默认的 HTML 代码。</p><h2 id="1a34" class="mt lg in bd lh mu mv dn ll mw mx dp lp jv my mz lt jz na nb lx kd nc nd mb ne bi translated">4.开始创建一些组件<strong class="ak">。</strong></h2><p id="f6e4" class="pw-post-body-paragraph jk jl in jm b jn mf jp jq jr mg jt ju jv nf jx jy jz ng kb kc kd nh kf kg kh ig bi translated">以下是我们将要创建的组件:</p><ol class=""><li id="2022" class="md me in jm b jn jo jr js jv np jz nq kd nr kh mk ml mm mn bi translated"><strong class="jm io"> todos </strong>组件，包含我们的主要应用程序代码。</li><li id="8ab0" class="md me in jm b jn mo jr mp jv mq jz mr kd ms kh mk ml mm mn bi translated"><strong class="jm io"> todo-create </strong>组件，包含我们创建 todo 的表单。</li><li id="6f5e" class="md me in jm b jn mo jr mp jv mq jz mr kd ms kh mk ml mm mn bi translated"><strong class="jm io"> todo-item </strong>组件，包含我们的待办事项列表。</li></ol><p id="6f54" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">好的，我们如何创建这个组件？Angular 提供了自动创建组件的命令。下面是您想要运行来创建上面这些组件的命令:</p><pre class="kj kk kl km gt ok ol om on aw oo bi"><span id="df74" class="mt lg in ol b gy op oq l or os">// Generate todos component<br/>ng generate component components/todos</span><span id="4ae5" class="mt lg in ol b gy ou oq l or os">// Generate todo-create component<br/>ng generate component components/todo-create</span><span id="032a" class="mt lg in ol b gy ou oq l or os">// Generate todo-item component<br/>ng generate component components/todo-item</span></pre><p id="f5bc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这三个命令将生成你的组件，如果成功，它将输出这个结果到你的终端。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/af9c417cb5ed01ce78c74fbea92a204d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1228/format:webp/1*gY9-k7RXaYlpzeS_8ghE-Q.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">组件生成</figcaption></figure><p id="fdd1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">该命令将自动创建您的组件，并在其中创建一些文件。Angular 将被放置在<strong class="jm io"> src/app/components </strong>文件夹中，angular 将提供包含 4 个文件、HTML、测试、TypeScript 和组件 CSS 的文件夹。<strong class="jm io">我们在这里将重点放在 HTML 和 TypeScript 上，不需要理会 CSS 和测试文件</strong>。</p><p id="88b8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下面是新创建的组件截图:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oy"><img src="../Images/254177c6c91654d942965b4b336449f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QPct6CHI1FbomuWb-qBtag.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">CLI 新生成的组件。</figcaption></figure><p id="79ae" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你注意到上图中突出显示的代码了吗？突出显示的代码是指用于组件的 TypeScript 装饰器。您可以在 TypeScript 文档中了解更多信息。</p><p id="d1dc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你注意到前面图像中终端的蓝色了吗？据说<strong class="jm io">更新</strong>。这意味着当你运行一个生成组件的命令时，它将创建文件并更新入口点，入口点文件在这个例子中被命名为<strong class="jm io"> app.module.ts </strong>在<strong class="jm io"> src/app </strong>文件夹中。</p><p id="60c2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你可以看到入口点(<strong class="jm io"> app.module.ts) </strong>文件，看起来会是这样的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oz"><img src="../Images/71de865e15a75456cd9e6eee12cb5a70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Se8YiIxkEuJ70Q6f81uI_A.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">入口点文件<strong class="bd lh"> src/app/app.module.ts </strong></figcaption></figure><p id="9643" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">上面的图片，就是你的名为<strong class="jm io"> app.module.ts </strong>的入口点。这意味着，你的核心代码，或者我应该说的核心角。你可以看到在我们创建组件后，angular 自动在<strong class="jm io"> app.module.ts </strong>文件中注册我们的组件，准确地说是在<strong class="jm io">声明</strong>键中。你也不需要为在你的应用中注册组件而烦恼。我希望你没有被这一步弄糊涂。</p><h2 id="15ef" class="mt lg in bd lh mu mv dn ll mw mx dp lp jv my mz lt jz na nb lx kd nc nd mb ne bi translated"><strong class="ak"> 5。为应用程序创建核心文件(必读)。</strong></h2><p id="6717" class="pw-post-body-paragraph jk jl in jm b jn mf jp jq jr mg jt ju jv nf jx jy jz ng kb kc kd nh kf kg kh ig bi translated">正如我之前所说，Angular 有一个复杂的代码环境，用于与用户、服务器或组件进行交互。</p><p id="8274" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了简单起见，我缩短了我的句子，并解释了 Angular 中您将面临的常见事情。</p><ol class=""><li id="faac" class="md me in jm b jn jo jr js jv np jz nq kd nr kh mk ml mm mn bi translated"><strong class="jm io">服务</strong></li></ol><p id="351f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了与服务器和组件交互，angular 有一个名为 service 的文件。<strong class="jm io"> </strong>这个服务文件，包含了我们的 app 逻辑，比如和服务器交互，和状态交互，或者和组件交互。好的，如何创建服务？CLI 提供了它，下面是命令:</p><pre class="kj kk kl km gt ok ol om on aw oo bi"><span id="7a36" class="mt lg in ol b gy op oq l or os">ng generate service services/todo</span></pre><p id="9a78" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">上面的命令将在<strong class="jm io"> src/app/services </strong>文件夹中生成一个名为<strong class="jm io"> todo.service.ts. </strong>的服务文件</p><p id="6eb9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下面是该文件的代码:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/d0b48671475e37916134d54ff1c29e1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1340/format:webp/1*WqeP1dRN9YMs_cfNQJkx6A.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">Angular CLI 新生成的服务</figcaption></figure><p id="6d58" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> 2。型号</strong></p><p id="859d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你需要一个模型来表示你从服务器上得到的数据，你<strong class="jm io">必须</strong>使用这个模型，因为为了代码的一致性和开发的目的(使调试更容易)。</p><p id="906d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如何创建模型？遗憾的是，Angular 没有提供用于生成模型的 CLI，但代码真的很简单，在<strong class="jm io"> src/app/models </strong>文件夹内制作一个名为<strong class="jm io"> todo.model.ts </strong>的文件(先创建 models 文件夹)。代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pb pc l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="ak"> todo.model.ts </strong></figcaption></figure><p id="cf76" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">上面的代码非常简单，只是创建了一个可以在构造函数中赋值的类。顺便说一下，我为这个模型创建了两种编写代码的方法。</p><p id="500f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> 3。HTTP </strong>和<strong class="jm io">表单模块</strong>。</p><p id="687c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了与服务器进行交互，你需要向服务器发送请求，angular 提供了<strong class="jm io"> HTTP </strong>(不是 Axios 或 fetch API)，它就像另一个常见的 HTTP 库，如 Axios 或 fetch API，但它是内置的 Angular。</p><p id="6d69" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">什么是<strong class="jm io">表单模块</strong>？在 Angular 中，如果你有一个与表单交互的组件，比如文本输入，复选框等。您必须将角度模块注册到应用程序。</p><p id="b161" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">那两个怎么用？转到<strong class="jm io"> src/app </strong>文件夹中的入口点文件(<strong class="jm io"> app.module.ts) </strong>。</p><p id="f9c8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">将代码更新如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pb pc l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">更新后的<strong class="ak"> app.module.ts </strong></figcaption></figure><p id="e820" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我从 angular 注册了<strong class="jm io"> FormsModule </strong>和<strong class="jm io"> HttpClientModule </strong>，并将它们放在 imports 数组中。就像与表单和 HTTP 请求交互一样简单(与服务器交互)。</p><p id="2c85" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在你成功地实现了上面的三个步骤后，你可以进入下一步。</p><h2 id="d103" class="mt lg in bd lh mu mv dn ll mw mx dp lp jv my mz lt jz na nb lx kd nc nd mb ne bi translated">6.准备与服务器和组件交互的服务</h2><p id="2c63" class="pw-post-body-paragraph jk jl in jm b jn mf jp jq jr mg jt ju jv nf jx jy jz ng kb kc kd nh kf kg kh ig bi translated">在这一步中，我们将使我们的服务工作，您可以在实现它之后看到服务的工作。我会解释我们服务的每一个细节。</p><p id="2c62" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以，打开<strong class="jm io"> src/app/services </strong>文件夹内的<strong class="jm io"> todo.service.ts </strong>。将您的代码更新成这样。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pb pc l"/></div></figure><p id="a9d8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我猜，当你看到这些代码时，你已经迷惑了。我知道，我也经历过那个阶段。好的，我要迭代上面发生的事情，我也写一些注释，这样你们就能完全理解代码中发生了什么。</p><ol class=""><li id="a6e0" class="md me in jm b jn jo jr js jv np jz nq kd nr kh mk ml mm mn bi translated"><strong class="jm io">导入声明</strong></li></ol><p id="fa2a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">首先</strong>，我们导入一些来自 rxjs 的函数，包括:</p><ul class=""><li id="179f" class="md me in jm b jn jo jr js jv np jz nq kd nr kh pd ml mm mn bi translated"><strong class="jm io">可观察的</strong>，用于返回一些承诺基数。</li><li id="f162" class="md me in jm b jn mo jr mp jv mq jz mr kd ms kh pd ml mm mn bi translated"><strong class="jm io"> BehaviorSubject </strong>，用于观察某个状态是否从服务器更新。</li><li id="aeaf" class="md me in jm b jn mo jr mp jv mq jz mr kd ms kh pd ml mm mn bi translated"><strong class="jm io"> throwError </strong>，用于将错误返回给客户端或者应该说是组件。</li></ul><p id="579d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">二、</strong>导入 rxjs 运算符，什么是 rxjs 运算符？如果你看了我之前的一篇关于<a class="ae ni" href="https://medium.com/dev-genius/reactjs-simple-understanding-redux-with-redux-saga-f635e273e24a?source=friends_link&amp;sk=7117848b8bcc90b3921a64ab3b2ef7b9" rel="noopener"><strong class="jm io">react js——用 Redux Saga </strong> </a>简单理解 Redux 的文章，你就会看到两者的相似之处。这就像 rxjs 必须与我们从服务器接收的数据进行交互的一堆函数。我们在该应用中使用的功能有:</p><ul class=""><li id="8143" class="md me in jm b jn jo jr js jv np jz nq kd nr kh pd ml mm mn bi translated"><strong class="jm io">映射，</strong>用于映射来自服务器的数据。</li><li id="e4ca" class="md me in jm b jn mo jr mp jv mq jz mr kd ms kh pd ml mm mn bi translated"><strong class="jm io"> catchError </strong>，用于当我们开始向服务器发出请求时，从服务器捕捉错误。</li></ul><blockquote class="pe pf pg"><p id="c9c5" class="jk jl nj jm b jn jo jp jq jr js jt ju ph jw jx jy pi ka kb kc pj ke kf kg kh ig bi translated"><strong class="jm io">注:</strong>你看<strong class="jm io"> pipe() </strong>函数那个包装<strong class="jm io"> map </strong>和<strong class="jm io"> catchError </strong>对吗？它来自<strong class="jm io"> Observable </strong>，因为我们从 Angular 导入的<strong class="jm io"> HttpClient </strong>，正在返回一个<strong class="jm io"> Observable </strong>。因此，我们可以在实际呈现到用户/组件之前修改请求。这个<strong class="jm io">管道()</strong>用于链接多个操作符，就像我们使用<strong class="jm io">映射</strong>和<strong class="jm io">捕捉错误</strong>一样。尽管如此，<strong class="jm io"> pipe() </strong>还是会返回一个<strong class="jm io">可观测值</strong>。</p></blockquote><p id="a829" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">第三个</strong>，从 Angular it-self 导入<strong class="jm io"> HttpClient </strong>，如果你之前已经读过我的话，我们在<strong class="jm io"> app.module.ts </strong>(我们的 Entrpypoint)中导入<strong class="jm io"> HttpClientModule </strong>，这样我们就可以使用所有 HTTP 请求与服务器进行交互。这个<strong class="jm io"> HttpClient </strong>你可以开始工作了，当你把<strong class="jm io"> HttpClient </strong>这样注入到构造函数中:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oy"><img src="../Images/717543b3d17d3aecf9d6bb2d1811279d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ub7liVwFOU9XKY9qhjzpiw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">将模块注入服务。</figcaption></figure><p id="f78e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> 2。内部服务代码</strong></p><p id="20fd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你看我们做了三个方法，<strong class="jm io"> getTodos，createTodos，</strong>和<strong class="jm io"> deleteTodos </strong>。这三种方法将在我们的组件中使用，以便与用户和服务器进行交互。正如你所看到的，我定义了那些将返回一个<strong class="jm io"> Observable </strong> <code class="fe pk pl pm ol b"><strong class="jm io">:Observable&lt;any&gt;</strong></code>的函数，这样组件就可以在整个组件中发送异步数据，我会在后面解释这一点。</p><p id="2702" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你注意到这个状态了吗？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pn"><img src="../Images/c2f5f5c5ffb2699d7150a7bd31647fd6.png" data-original-src="https://miro.medium.com/v2/resize:fit:910/format:webp/1*gcuzT5UgIM1aOv6AkGBdNA.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">用于分配 Todo 数组的行为主题</figcaption></figure><p id="7691" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个呢？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi po"><img src="../Images/15c73aa0c2a872824d1f8b2fe515f690.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eX6GLxgLBxx9qWsYPK94Ig.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">使用 next()为 BehaviorSubject 赋值</figcaption></figure><p id="3f5d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一、为什么要用<strong class="jm io">行为主体</strong>？如果我们不使用 BehaviorSubject，如果服务器有任何状态改变，状态不会改变，它将保持在以前的状态。用于更新<strong class="jm io">行为主题</strong>中的状态，稍后将会解释。</p><p id="57ec" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对于价值本身，这里有正确的事情来分配价值和从<strong class="jm io">行为主体</strong>获得价值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pb pc l"/></div></figure><p id="6125" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">而这个<strong class="jm io">行为主体</strong>返回<strong class="jm io">可观察。</strong></p><blockquote class="pe pf pg"><p id="cf2f" class="jk jl nj jm b jn jo jp jq jr js jt ju ph jw jx jy pi ka kb kc pj ke kf kg kh ig bi translated"><strong class="jm io">注意</strong>:顺便说一下，代码是自我解释的。</p></blockquote><h2 id="979e" class="mt lg in bd lh mu mv dn ll mw mx dp lp jv my mz lt jz na nb lx kd nc nd mb ne bi translated">7.准备组件</h2><p id="e75a" class="pw-post-body-paragraph jk jl in jm b jn mf jp jq jr mg jt ju jv nf jx jy jz ng kb kc kd nh kf kg kh ig bi translated">首先，你可以看到当你创建一个组件时，你会注意到你的 TypeScript 组件文件中的这三样东西。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pp"><img src="../Images/cd307329fbf17209dab47b3bdad4a866.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xUnJaQ5W9Lx5u5XNIhwDgw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">组件中的核心内容</figcaption></figure><p id="f3b8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">图像是不言自明的，我在那里创建了一些评论。请注意这三件事。</p><p id="123e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">好的，我假设，你有三个组件(todos，todo-create，todo-item)。</p><ol class=""><li id="cb7d" class="md me in jm b jn jo jr js jv np jz nq kd nr kh mk ml mm mn bi translated"><strong class="jm io">造型</strong></li></ol><p id="cb06" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在我们与组件交互之前，确保首先使用我创建的样式更新您的样式。将这段代码复制到位于<strong class="jm io"> styles.css </strong>的全局样式文件中，这个文件可以在<strong class="jm io"> src </strong>文件夹中找到。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pb pc l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">src/styles.css 中的样式</figcaption></figure><p id="7bed" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> 2。更新 app.component.html</strong></p><p id="26ec" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">之后，打开你的主 HTML 文件，在第三步我们清除默认 HTML，命名为<strong class="jm io">app.component.html</strong>，位于<strong class="jm io"> src/app </strong>文件夹。</p><p id="e201" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让你的<strong class="jm io">app.component.html</strong>变成这样。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pb pc l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">app.component.html</figcaption></figure><p id="648e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">它将呈现 todos.component.html。</p><p id="aff2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> 3。更新 Todos 组件文件</strong></p><p id="9d8b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在更新您的主 HTML 之后，您可以更新您的 todos 组件，这个 Todo 应用程序的父组件。</p><p id="d7d8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">更新位于<strong class="jm io">src/app/components/todos</strong>文件夹中的<strong class="jm io"> todos.component.ts </strong>。代码就在下面:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pb pc l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">已更新 todos.component.ts</figcaption></figure><p id="5c7d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">好的，我在代码中写了一些注释，你也可以阅读，但是我将解释 todo 组件的类型脚本文件中的主要内容。</p><ol class=""><li id="2408" class="md me in jm b jn jo jr js jv np jz nq kd nr kh mk ml mm mn bi translated">你注意到我<code class="fe pk pl pm ol b">import { Subscription } from ‘rxjs'</code>订阅用于观察组件中运行的一些可观察的东西，在这种情况下，从服务器获取所有待办事项，在某些情况下，你有另一个页面需要导航。当你导航到另一个页面时，你想销毁之前的异步请求，为什么？这是为了提高性能，如果你不破坏之前的异步请求或订阅，<strong class="jm io">每次你再次进入那个页面，你会被一遍又一遍地渲染，直到你的内存满了</strong>(当你硬刷新页面时不受影响)但是，我推荐这一步以获得更好的性能。这就是我们使用订阅的原因。我正在编写一些代码来销毁/取消订阅<strong class="jm io">ngOnDestroy</strong>(Angular life cycle)中的订阅</li><li id="f811" class="md me in jm b jn mo jr mp jv mq jz mr kd ms kh mk ml mm mn bi translated"><strong class="jm io">当服务器有任何请求时，如何自动更新状态？</strong>例如当你创建一个待办事项或者删除待办事项时？因为答案就在下面:</li></ol><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pq"><img src="../Images/e1174bc84a417b14d582c938d75abe8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:788/format:webp/1*p0I7Gy1nngYIch6hG8CV8g.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">每次服务器发生变化时更新状态</figcaption></figure><p id="0a77" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我已经突出显示了上面图片中的代码，就是这样，当服务器有任何变化时，你不用再费心去更新状态了。因为，如果看到<strong class="jm io"> todo.service.js </strong>中的代码。在每种方法中，每当我们发出请求，比如获取、创建和删除数据时，我们都会更新<strong class="jm io">行为主题</strong>。</p><p id="ad07" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下面是我们将数据更新到<strong class="jm io"> todo.service.ts </strong>中的<strong class="jm io"> BehaviorSubject </strong>的例子，因为我在下图中突出显示了代码。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pr"><img src="../Images/46fcd797e230ef8f8aa9d63f202addcc.png" data-original-src="https://miro.medium.com/v2/resize:fit:934/format:webp/1*dWcZdRqdd5jbwobIJ8LTBA.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">使用 next()更新<strong class="bd lh">行为主题</strong>值</figcaption></figure><p id="1de5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">每次，当成功向服务器订阅数据时，我们会给<strong class="jm io">行为主体</strong>分配一个新值，这就是为什么你不需要再费心操纵组件的状态。</p><p id="9518" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对于 HTML，很简单，更新位于<strong class="jm io">src/app/components/todos</strong>文件夹中的<strong class="jm io">todo.component.html</strong>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pb pc l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">todos.component.html</figcaption></figure><p id="0200" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">主要的事情是，Angular 为 HTML 提供了一个指令，在这个例子中，is，<strong class="jm io"> *ngFor </strong>用于在 HTML 中循环数据。</p><p id="cba9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在<code class="fe pk pl pm ol b">&lt;app-todo-item&gt;</code>标签处，我们使用<code class="fe pk pl pm ol b">[todo]="todo"</code>传递一个绑定到它的对象，并使用<code class="fe pk pl pm ol b">(removeTodo)="removeTodo($event)"</code>绑定一个事件处理程序。您可以在<a class="ae ni" href="https://angular.io/guide/binding-syntax" rel="noopener ugc nofollow" target="_blank">角度数据绑定</a>处检查角度数据绑定。</p><p id="241d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> 4。更新待办事项组件文件</strong></p><p id="0b34" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">还和我在一起吗？坚强点，我们离完成应用越来越近了！</p><p id="ab9c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在<strong class="jm io">src/app/components/todo-item</strong>文件夹内的<strong class="jm io"> todo-item.component.ts </strong>文件中。将代码更新成这样。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pb pc l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">todo-item.componen.ts</figcaption></figure><p id="c4ee" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在我们将对象绑定从父组件(<strong class="jm io">todos.component.html)</strong>传递到<code class="fe pk pl pm ol b">&lt;app-todo-item&gt;</code>标签之后，您会看到。我们使用 Angular 的<strong class="jm io">输入</strong>和<strong class="jm io">输出</strong>接受绑定。为了发出从父节点传递来的对象，我们简单地调用<code class="fe pk pl pm ol b">this.removeTodo.emit(todoId)</code>，这将从父节点调用函数并删除 todo。另外，我在代码中放了一些注释，这样你就知道代码中实际做了什么。</p><blockquote class="pe pf pg"><p id="7e29" class="jk jl nj jm b jn jo jp jq jr js jt ju ph jw jx jy pi ka kb kc pj ke kf kg kh ig bi translated"><strong class="jm io">注意</strong>:如果您不想从子组件发出事件，<strong class="jm io">我建议将您的服务注入到子组件</strong>中，以减少从子组件发出事件。如果你有很多事件要从父组件绑定到子组件，那会很麻烦。</p></blockquote><p id="7f62" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是 todo-item.component.html 的 HTML 格式。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pb pc l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">todo-item.component.html</figcaption></figure><p id="d880" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> 5。更新待办事项创建组件文件</strong></p><p id="2267" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最后！您所需要做的就是更新您的 todo-create 组件文件！</p><p id="3a3d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">好的，打开<strong class="jm io">src/app/components/todo-create</strong>文件夹中的<strong class="jm io">todo-create . component . ts</strong>文件，将文件更新为这样。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pb pc l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">todo-create.component.ts</figcaption></figure><p id="cadf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这只是一个简单的 TypeScript 文件，但是我们在其中注入了<strong class="jm io"> todo.service.ts </strong>，以便订阅创建新的 todo 到服务器。</p><p id="3fa7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对于 HTML，打开<strong class="jm io">src/app/components/todo-create</strong>文件夹内的<strong class="jm io">todo-create.component.html</strong>文件。这是代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pb pc l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">todo-create.component.html</figcaption></figure><p id="0735" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对于<strong class="jm io">todo-create-. component . HTML</strong>的简单 HTML，我们注意到我们必须接受创建 todo 的标题，对吗？为此，我们使用两种方式从 Angular 绑定名为<strong class="jm io"> [(ngModel)] </strong>，即接受其中的一些变量，在这种情况下，我们将<strong class="jm io">标题命名为</strong>，而这种<strong class="jm io">标题</strong>从两种方式绑定的形式中，我们在 TypeScript 文件中接受。请注意，这个<strong class="jm io"> [(ngModel)] </strong>就像 keyup 一样，看着输入的每一个变化。只看代码的注释，我在 TypeScript 文件 tho 里写注释。</p><h2 id="25ce" class="mt lg in bd lh mu mv dn ll mw mx dp lp jv my mz lt jz na nb lx kd nc nd mb ne bi translated">8.决赛成绩</h2><p id="5a36" class="pw-post-body-paragraph jk jl in jm b jn mf jp jq jr mg jt ju jv nf jx jy jz ng kb kc kd nh kf kg kh ig bi translated">我建议你通过重新运行<strong class="jm io"> ng serve </strong>来重启 Angular dev 服务器。这是应用程序的最终结果。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ps"><img src="../Images/cdac6c4b7876c08243bda6833c991473.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*iieRMe23zCDbZUf2zcucNg.gif"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">角度待办事项应用程序</figcaption></figure><p id="2f6f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">它在界面 XD 中很难看，但是，我们在这里关注的是 Angular。如果你读过我以前的一篇关于<a class="ae ni" href="https://medium.com/dev-genius/reactjs-manage-your-state-nicely-with-context-1ed3090a6a46?source=friends_link&amp;sk=6e3cf720a3cc5cfe3da5df10141a95b4" rel="noopener"> <strong class="jm io"> ReactJS 的文章——用上下文</strong> </a>很好地管理你的状态。您将看到我们创建了相同的应用程序，但现在，当然是使用 Angular。</p><p id="2274" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你不希望得到和我一样的结果，请确保你仔细阅读了我写的每一步。</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h1 id="6deb" class="lf lg in bd lh li nk lk ll lm nl lo lp lq nm ls lt lu nn lw lx ly no ma mb mc bi translated">结论</h1><p id="478f" class="pw-post-body-paragraph jk jl in jm b jn mf jp jq jr mg jt ju jv nf jx jy jz ng kb kc kd nh kf kg kh ig bi translated">在你读完这篇文章后，我希望你了解有棱角的自我。也许你不会理解，没关系。事情是这样的，Angular 是对我来说最难学的<strong class="jm io">前端框架，当我阅读 Angular 的文档，做一些研究时，我挣扎了很久。嘿，如果你不断尝试，你就会明白发生了什么。</strong></p><p id="808f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我知道，很多事情在我刚刚写的代码中没有解释，对此我很抱歉。我只是在解释你在真实 app 中可能面临的核心东西。</p><p id="5644" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果您仍然不清楚应该使用什么样的前端框架，Angular、React 还是 Vue？这取决于你，只是用那个匹配到你和你的情况。</p><p id="2f12" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我应该说，这个 Angular 框架是健壮的，并使你的代码更加结构化，因为 Angular 有许多项目模式，代码比任何其他前端框架都更健壮。但是，<strong class="jm io">你需要更多的时间来学习这个棱角</strong>。</p><p id="955a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以核心的事情是，如果你在学习棱角分明的时候挣扎了很多。请保持耐心，继续学习！</p><p id="b6a0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是我们刚刚构建的 Angular Todo 应用程序的代码。</p><div class="ns nt gp gr nu nv"><a href="https://github.com/hudaprs/medium_angular" rel="noopener  ugc nofollow" target="_blank"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd io gy z fp oa fr fs ob fu fw im bi translated">hudaprs/中等角度</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">此项目是使用 Angular CLI 版本 11.0.4 生成的。为开发服务器运行 ng serve。导航到…</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">github.com</p></div></div><div class="oe l"><div class="pt l og oh oi oe oj ks nv"/></div></div></a></div><p id="df96" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你还有困惑，请在讨论中留下评论。</p><p id="82c7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下一篇文章再见！生活真美好！</p></div></div>    
</body>
</html>