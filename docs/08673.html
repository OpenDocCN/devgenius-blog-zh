<html>
<head>
<title>How HTTP Protocol Works?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">HTTP 协议是如何工作的？</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-http-protocol-works-6c3636302316?source=collection_archive---------4-----------------------#2022-07-02">https://blog.devgenius.io/how-http-protocol-works-6c3636302316?source=collection_archive---------4-----------------------#2022-07-02</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="a2da" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">HTTP 是一种请求-响应协议，允许用户进行数据通信。所以在 HTTP 中有两个分支。</p><ol class=""><li id="3aa8" class="ki kj in jm b jn jo jr js jv kk jz kl kd km kh kn ko kp kq bi translated"><strong class="jm io">持续连接</strong></li><li id="515a" class="ki kj in jm b jn kr jr ks jv kt jz ku kd kv kh kn ko kp kq bi translated"><strong class="jm io">非</strong> - <strong class="jm io">持续连接</strong></li></ol><h1 id="41a3" class="kw kx in bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated"><strong class="ak">非持久连接</strong></h1><ul class=""><li id="23c3" class="ki kj in jm b jn lu jr lv jv lw jz lx kd ly kh lz ko kp kq bi translated">非持久性 HTTP 主要是 HTTP 1.0</li><li id="60be" class="ki kj in jm b jn kr jr ks jv kt jz ku kd kv kh lz ko kp kq bi translated">RTT 往返时间是指从服务器收到响应时向发送请求的持续时间。</li><li id="da4a" class="ki kj in jm b jn kr jr ks jv kt jz ku kd kv kh lz ko kp kq bi translated">非持久连接的连接时间为 2RTT(往返时间)+ <em class="ma">文件传输时间</em>。这里首先使用 RTT 在服务器和客户端之间建立连接。</li><li id="878d" class="ki kj in jm b jn kr jr ks jv kt jz ku kd kv kh lz ko kp kq bi translated">第二个 RTT:这里用于接受请求并返回对象。这里发生是单个对象传输。</li><li id="c43f" class="ki kj in jm b jn kr jr ks jv kt jz ku kd kv kh lz ko kp kq bi translated">举个例子，假设服务器说我们需要 10 个文件，然后当我们加载 html 页面时，它有 10 个 javascripts。<br/>现在我们需要向服务器发出 10 个不同的请求，以便<br/>获取这些文件。</li></ul><h1 id="4d2e" class="kw kx in bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">持续连接</h1><ul class=""><li id="5f75" class="ki kj in jm b jn lu jr lv jv lw jz lx kd ly kh lz ko kp kq bi translated">在事务完成后保持打开的 TCP 连接被称为<em class="ma">持久</em>连接。持久连接在事务之间保持打开，直到客户机或服务器决定关闭它们。</li><li id="6488" class="ki kj in jm b jn kr jr ks jv kt jz ku kd kv kh lz ko kp kq bi translated">它的思想是使用单个 TCP 连接来发送和接收多个 HTTP 请求/响应，而不是为每个请求/响应对打开一个新的连接。</li><li id="7063" class="ki kj in jm b jn kr jr ks jv kt jz ku kd kv kh lz ko kp kq bi translated">持久性 HTTP 又有两个部分:<strong class="jm io">有隧道和无隧道。</strong></li><li id="0d06" class="ki kj in jm b jn kr jr ks jv kt jz ku kd kv kh lz ko kp kq bi translated">默认情况下，HTTP 1.1 主要采用隧道技术。</li><li id="ae5f" class="ki kj in jm b jn kr jr ks jv kt jz ku kd kv kh lz ko kp kq bi translated">因此，当我们创建连接并发送消息，然后得到响应时。因此，事务结束时，服务器或客户端都可以关闭连接。</li></ul></div><div class="ab cl mb mc hr md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ig ih ii ij ik"><p id="bf6f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们看看这是如何工作的。</p><p id="fe3d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里我们有基于 Express 的程序。</p><p id="f6d5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> server.js </strong></p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="mn mo l"/></div></figure><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi mp"><img src="../Images/f3064ca1033fe83ca01c50eea378f8c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D3FFpB3_FyuiKiTQ2mY_1w.png"/></div></div></figure><ul class=""><li id="4ed5" class="ki kj in jm b jn jo jr js jv kk jz kl kd km kh lz ko kp kq bi translated">在程序中，我们有一个称为“等待”的端点。得到响应后，它将发送“工作完成”消息。</li><li id="9cc9" class="ki kj in jm b jn kr jr ks jv kt jz ku kd kv kh lz ko kp kq bi translated">这在端口 8196 上运行。</li><li id="e4f7" class="ki kj in jm b jn kr jr ks jv kt jz ku kd kv kh lz ko kp kq bi translated">让我们运行这个程序，并在 Wireshark-loopback 流量捕获接口上进行监控。</li><li id="8960" class="ki kj in jm b jn kr jr ks jv kt jz ku kd kv kh lz ko kp kq bi translated">所以当我们发送这个请求:<a class="ae mw" href="http://localhost:8191/wait" rel="noopener ugc nofollow" target="_blank"><strong class="jm io">http://localhost:8196/wait</strong></a><strong class="jm io"/>我们可以看到如下。</li></ul><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi mp"><img src="../Images/309fcd1a84c5533e71651496fac82dd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mbIcEJL23Rkl404yEXUKnw.png"/></div></div></figure><ul class=""><li id="9be2" class="ki kj in jm b jn jo jr js jv kk jz kl kd km kh lz ko kp kq bi translated">这里可以看到标准的 TCP 握手。</li></ul><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi mx"><img src="../Images/5947ee57d51ca9fefbf961e3b7193517.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NICS6lEs4AwGDsSYntaQ9A.jpeg"/></div></div></figure><ul class=""><li id="1bd2" class="ki kj in jm b jn jo jr js jv kk jz kl kd km kh lz ko kp kq bi translated">因此，在这里您可以看到如何发送请求并获得响应</li></ul><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi my"><img src="../Images/67d9d93aa24a855707084bce472f67c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TR2JWV0SzVBdvuZ2JQzR6g.jpeg"/></div></div></figure><ul class=""><li id="4518" class="ki kj in jm b jn jo jr js jv kk jz kl kd km kh lz ko kp kq bi translated">现在，服务器响应客户端，通知它将关闭这个连接(FIN)。然后客户端向服务器确认。但是客户端没有关闭连接。</li></ul><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi mz"><img src="../Images/7deb54ebead38ee5528d7b0b21021a3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jK3hM9EtYxAbhRS49rX95w.jpeg"/></div></div></figure><ul class=""><li id="c620" class="ki kj in jm b jn jo jr js jv kk jz kl kd km kh lz ko kp kq bi translated">所以过了一会儿客户端发送保活。</li></ul><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi na"><img src="../Images/5ea603aeae1619079bb4033937a53e25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OWSqPlgZ8tF-8dmzzGdVkA.jpeg"/></div></div></figure><ul class=""><li id="9acc" class="ki kj in jm b jn jo jr js jv kk jz kl kd km kh lz ko kp kq bi translated">因此，当客户端发送保活时，服务器发送重置数据包(RST)。(因为在服务器关闭连接后，客户端试图与服务器连接)。</li></ul><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi nb"><img src="../Images/8eb9477bdbbd9e849dce7b5100f9b37a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wg1fqqdBrTsawqniAsKMKw.jpeg"/></div></div></figure></div><div class="ab cl mb mc hr md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ig ih ii ij ik"><ul class=""><li id="b24b" class="ki kj in jm b jn jo jr js jv kk jz kl kd km kh lz ko kp kq bi translated">让我们看另一个例子。</li><li id="48e4" class="ki kj in jm b jn kr jr ks jv kt jz ku kd kv kh lz ko kp kq bi translated">在这里，我们检查在得到响应后发送另一个请求会发生什么。所以我们我们陆续发送这个请求:<a class="ae mw" href="http://localhost:8191/wait" rel="noopener ugc nofollow" target="_blank"><strong class="jm io">http://localhost:8196/wait</strong></a><strong class="jm io"/>。</li></ul><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi mp"><img src="../Images/07ceb8a9e1cf1e367912c9c1fd19f48f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kOy5VjQQKa9C9zNhibB_8A.png"/></div></div></figure><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi nc"><img src="../Images/391c2ef78569b09a8d2191fa9bd57373.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Kj86u02WxaJV0StdkielUw.png"/></div></div></figure><ul class=""><li id="add7" class="ki kj in jm b jn jo jr js jv kk jz kl kd km kh lz ko kp kq bi translated">如你所见，我们的请求从客户端传到了服务器。</li></ul><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi nd"><img src="../Images/6820c266cf311a71e231ddcc8d5c3b13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R_WTNM2O2Xi1gGmu4kAtPg.jpeg"/></div></div></figure><ul class=""><li id="5374" class="ki kj in jm b jn jo jr js jv kk jz kl kd km kh lz ko kp kq bi translated">现在，您可以看到客户端正在向响应发送 ACK。客户端发送请求。服务器确认它。服务器发送响应，然后客户端确认它。</li></ul><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi my"><img src="../Images/67d9d93aa24a855707084bce472f67c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TR2JWV0SzVBdvuZ2JQzR6g.jpeg"/></div></div></figure><ul class=""><li id="2511" class="ki kj in jm b jn jo jr js jv kk jz kl kd km kh lz ko kp kq bi translated">所以在我们发送另一个请求后，同样的事情会循环发生。</li><li id="16d4" class="ki kj in jm b jn kr jr ks jv kt jz ku kd kv kh lz ko kp kq bi translated">此外，您可以看到这里没有任何 FIN 标志。因为我们在这里做的是保持与后端的对话，所以后端不会试图关闭连接。这就是<strong class="jm io">持续连接</strong>的意思。</li><li id="d414" class="ki kj in jm b jn kr jr ks jv kt jz ku kd kv kh lz ko kp kq bi translated">我们只发送一次同步数据包来保持这个过程。</li></ul></div><div class="ab cl mb mc hr md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ig ih ii ij ik"><ul class=""><li id="9741" class="ki kj in jm b jn jo jr js jv kk jz kl kd km kh lz ko kp kq bi translated">现在让我们看另一个有一些小变化的演示。</li><li id="7b42" class="ki kj in jm b jn kr jr ks jv kt jz ku kd kv kh lz ko kp kq bi translated">这里我们发送请求:<a class="ae mw" href="http://localhost:8191/wait" rel="noopener ugc nofollow" target="_blank"><strong class="jm io">http://localhost:8196/wait</strong></a><strong class="jm io">。过了一会儿，服务器会关闭连接，然后我也会关闭浏览器。</strong></li></ul><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi mp"><img src="../Images/aac07b1ffd035f36eec1cafd6058e2a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DBvA5BzRMB7qkzVdcfxd_A.png"/></div></div></figure><ul class=""><li id="1906" class="ki kj in jm b jn jo jr js jv kk jz kl kd km kh lz ko kp kq bi translated">在这里，您可以看到服务器关闭了连接(FIN)。然后客户端确认关闭。在那之后，因为我关闭了浏览器，我的服务器和客户端的连接也关闭了</li></ul><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi ne"><img src="../Images/f0b7b16c6d6dc90c25a644d6a45f67a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZmfK5v6g9l3A6AYLVf1oMQ.jpeg"/></div></div></figure></div><div class="ab cl mb mc hr md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ig ih ii ij ik"><ul class=""><li id="1d12" class="ki kj in jm b jn jo jr js jv kk jz kl kd km kh lz ko kp kq bi translated">让我们看另一个用例。</li></ul><blockquote class="nf ng nh"><p id="74e4" class="jk jl ma jm b jn jo jp jq jr js jt ju ni jw jx jy nj ka kb kc nk ke kf kg kh ig bi translated">等待新的承诺((resolve) =&gt; setTimeout(resolve，60000))；</p></blockquote><ul class=""><li id="28b1" class="ki kj in jm b jn jo jr js jv kk jz kl kd km kh lz ko kp kq bi translated">将此添加到代码中。现在请求来了，等待 60 秒，然后它会做出响应。</li></ul><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="mn mo l"/></div></figure><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi mp"><img src="../Images/2917e4e555241b7fbc0658c2d52cf0c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vtr0q77UmB7wfjXvvQAGcw.png"/></div></div></figure><ul class=""><li id="d46d" class="ki kj in jm b jn jo jr js jv kk jz kl kd km kh lz ko kp kq bi translated">因此，在我们发送请求后，服务器对此进行确认。现在服务器正在等待响应，所以服务器将在 60 秒后响应。</li></ul><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi mp"><img src="../Images/ccb4b92941a3b0e113aae01b8a234acb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Tm_wu5i7c4_c73VA2QR58g.png"/></div></div></figure><ul class=""><li id="4975" class="ki kj in jm b jn jo jr js jv kk jz kl kd km kh lz ko kp kq bi translated">所以你可以在 45 秒后看到这里。(24 秒到 69 秒)它向服务器发送 keep-alive 报头。因为服务器没有响应。从客户端来看，我们正在等待服务器。因此服务器需要做出响应。</li><li id="8f88" class="ki kj in jm b jn kr jr ks jv kt jz ku kd kv kh lz ko kp kq bi translated">所以一分钟后服务器会有反应。</li></ul><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi mp"><img src="../Images/fec32eefedabcf37a0214416f326a74b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q5bCPkp48iUIb2Ob-07gKQ.png"/></div></div></figure><ul class=""><li id="dfee" class="ki kj in jm b jn jo jr js jv kk jz kl kd km kh lz ko kp kq bi translated">因此，一分钟后(在得到响应-119 s: 179 s 后)，您可以看到服务器正试图通过发送 FIN 来关闭连接。</li></ul><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi nl"><img src="../Images/1a49730c3ee4cde7be8f9dc65bf81267.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QRi6iOtH-nOEuIMdw40O1Q.png"/></div></div></figure></div><div class="ab cl mb mc hr md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ig ih ii ij ik"><ul class=""><li id="cee4" class="ki kj in jm b jn jo jr js jv kk jz kl kd km kh lz ko kp kq bi translated">让我们看另一个用例。</li><li id="2869" class="ki kj in jm b jn kr jr ks jv kt jz ku kd kv kh lz ko kp kq bi translated">现在我们发送请求，等待服务器响应。然后我们去后端，杀死服务器。(关闭终端)。</li></ul><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi nm"><img src="../Images/450aa9ddbf1ce88613c4bd2de067f3c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rYSa7A49CoxIUNc2_wSFxQ.png"/></div></div></figure><ul class=""><li id="c48a" class="ki kj in jm b jn jo jr js jv kk jz kl kd km kh lz ko kp kq bi translated">这里我们向服务器发送请求。但是服务器关闭了连接。(杀服务器)。此后，您可以看到客户端正在尝试启动一个新的连接，因为连接已关闭。(客户端同意服务器关闭连接，但要求建立新的连接。)</li></ul><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi nn"><img src="../Images/1c96bb071b7756ef2a839eb541bb04fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rrRwcuDzjo4jvmfnWvm5UA.png"/></div></div></figure><ul class=""><li id="81c0" class="ki kj in jm b jn jo jr js jv kk jz kl kd km kh lz ko kp kq bi translated">但是现在服务器发送复位包，因为没有人从服务器端响应。</li><li id="6029" class="ki kj in jm b jn kr jr ks jv kt jz ku kd kv kh lz ko kp kq bi translated">这里你可以看到 keep-alive 报头有多重要，以及客户端如何在 HTTP 协议上保持与服务器的连接。</li></ul><p id="774c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">参考:</strong></p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="no mo l"/></div></figure></div></div>    
</body>
</html>