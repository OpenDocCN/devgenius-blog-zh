<html>
<head>
<title>Reasons for your unreliable mobile Tests</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你的移动测试不可靠的原因</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/reasons-for-your-unreliable-mobile-tests-4fb700b78d4c?source=collection_archive---------15-----------------------#2020-07-03">https://blog.devgenius.io/reasons-for-your-unreliable-mobile-tests-4fb700b78d4c?source=collection_archive---------15-----------------------#2020-07-03</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div class="gh gi jk"><img src="../Images/fce7fb175e33a1aec3079defcf3436d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*FrJor_XETyTtdFSrQq1MzQ.jpeg"/></div><figcaption class="jr js gj gh gi jt ju bd b be z dk translated">一个测试自动化工程师在早上…</figcaption></figure><p id="75bf" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">通常当运行一个测试自动化套件时，最大的担心是有不可靠的测试。开始时，商业兴趣很高，期望也很明确。随着时间的推移，从一个 sprint 到另一个 sprint，稳定性成为一个更大的问题，直到它们被放弃，QA 求助于“只是手动检查，以确保”，从而导致工作量的更大增加，危及项目的时间表。避免这些陷阱应该有助于您使您的移动测试成为一个成功的故事，并帮助您从一个舒适的位置开发您的服务，而不是失败的期望。</p><h1 id="ae34" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated"><strong class="ak">使命陈述</strong></h1><p id="490a" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">要清楚你在测试什么！人们倾向于混淆他们测试的目标，使其成为依赖于 UI 可视化、网络条件、性能测试和黑盒安全测试的弗兰肯斯坦怪物。</p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div class="gh gi lw"><img src="../Images/61bea0f14dde5c6ec22c77f417ec2253.png" data-original-src="https://miro.medium.com/v2/resize:fit:610/format:webp/1*PkQvyPyJtWZt1aK8EWOjeg.png"/></div></figure><p id="afd0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">大约 90%的不可靠测试都源于动态内容及其对 UI 视图层次结构的影响。由 Espresso、XCUITest 和 Appium 提供的测试自动化本身被定义为仅进行<strong class="jx io"> <em class="mb">功能测试。</em> </strong>是的，我已经可以听到你说<em class="mb">“你可以实现视觉测试和性能检查！”。你肯定可以。但是不要将</em> <strong class="jx io"> <em class="mb">多个评估</em> </strong> <em class="mb">混合成一个测试用例！测试应该只验证一件事，尽可能在你的测试设计中有一个清晰的任务陈述。一旦稳定了纯功能，就可以添加验证 UI、性能或前端安全性的套件。所以说:<strong class="jx io">片状测试是不一致的测试设计的一个很好的指示器。</strong></em></p><h1 id="1a5a" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated"><strong class="ak">第三方供应</strong></h1><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi mc"><img src="../Images/c73952d6017dddc9af45b112f3cba122.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QO0piAA26xB_ZiWbwHfNxw.png"/></div></div></figure><p id="5a30" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">像<a class="ae mh" href="http://www.appium.io" rel="noopener ugc nofollow" target="_blank"> Appium </a>、<a class="ae mh" href="https://github.com/google/EarlGrey" rel="noopener ugc nofollow" target="_blank"> Earl Grey </a>或<a class="ae mh" href="https://testproject.io/" rel="noopener ugc nofollow" target="_blank"> TestProject </a>这样的开源测试软件的兴起令人难以置信。然而，哪里有软件，哪里就有缺陷，因此，第三方软件会多次交付不一致的结果。注意你将要选择的工具的当前问题。</p><p id="52b6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Appium 正在使用一系列依赖项，包括 Selenium 和著名的<a class="ae mh" href="https://github.com/appium/WebDriverAgent" rel="noopener ugc nofollow" target="_blank">脸书·WDA</a>，它们本身是开放项目，需要一些时间来适应新的操作系统版本。所以小心行事，学徒！</p><h1 id="576c" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">可测试性造就更聪明的测试工程师</h1><p id="28b5" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">想象一下，测试一个移动应用程序，它使用带有 a-sync 服务器的弹出窗口来进行跟踪。最初，测试会消除对话。到目前为止一切顺利。但是，当稍后收到回调时，它会奇迹般地重新打开弹出窗口，而且它会将弹出窗口与智能手机的许可弹出窗口混淆。第一种解决方案是在导航的同时期待不同的弹出窗口，但这将需要大量几乎没有使用过的代码。尝试后退一步观察剥落问题。您可以对任何 Ajax 调用使用 loading spinner，并且只在调用完成时继续。处理所有应用程序权限应该通过 adb 在“之前”挂钩中完成。</p><p id="e1c6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在你的应用中建立可测试性不仅仅是给你的导航项目分配 id。这样，可测试性可以极大地提高可用性，因为它给用户更多关于实际发生的上下文。用户可以理解加载微调器，但是由于延迟的弹出窗口，用户往往会对随机出现的弹出窗口感到烦恼。</p><h1 id="7258" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated"><strong class="ak">前提条件和拆卸</strong></h1><p id="ed84" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">能够设置和清理您的前提条件是测试自动化工程师工作的 80%。如前所述，您没有测试数据的可靠性，所以在您的测试设计中考虑这一点。有时，您必须在模拟数据和实时数据之间找到最佳平衡点，以充分利用您的套件。这需要相当多的<strong class="jx io">领域知识。</strong>有时，你可以使用像<a class="ae mh" href="http://sinatrarb.com/testing.html" rel="noopener ugc nofollow" target="_blank"> Sinatra </a>或<a class="ae mh" href="http://wiremock.org/" rel="noopener ugc nofollow" target="_blank"> Wiremock </a>这样的工具来重新创建应用的后端，只是为了获得可靠的前提条件，并能够在测试结束时丢弃后端的实例。这是游戏的一部分:在你的时间表中考虑这些努力。</p><h1 id="b861" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated"><strong class="ak">适当的测试</strong></h1><p id="76b2" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">仅仅因为你能，并不意味着你应该！测试金字塔是一个多维对象，智能手机应用程序(或任何前端应用程序)不是测试 API 的地方。在开始缓慢的移动测试之前，调整您的管道来运行后端服务的健康检查，以避免混淆。</p><p id="3233" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">此外，在每次提交时运行完整的套件 100%只会给开发人员的测试带来麻烦。选择有助于验证正在运行的开发状态的综合冒烟套件。</p><p id="136a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">尝试在以下两者之间取得最佳折衷:</p><ul class=""><li id="00a4" class="mi mj in jx b jy jz kc kd kg mk kk ml ko mm ks mn mo mp mq bi translated">高风险特征</li><li id="5ce7" class="mi mj in jx b jy mr kc ms kg mt kk mu ko mv ks mn mo mp mq bi translated">高用户负载的功能</li><li id="872f" class="mi mj in jx b jy mr kc ms kg mt kk mu ko mv ks mn mo mp mq bi translated">难以手动测试</li></ul><h1 id="f26d" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated"><strong class="ak">编码最佳实践也适用于 QA</strong></h1><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div class="gh gi jk"><img src="../Images/1e5acf215e68319206fe3aae797f4012.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*rtsXyaQcCuO4yfpcUJi_aA.jpeg"/></div><figcaption class="jr js gj gh gi jt ju bd b be z dk translated"><a class="ae mh" href="https://cheezburger.com/8944133/17-coding-memes-for-the-frustrated-software-engineer" rel="noopener ugc nofollow" target="_blank">https://cheezburger . com/8944133/17-为沮丧的软件工程师编码迷因</a></figcaption></figure><p id="5f05" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">作为质量保证，我们不会超越基本的编码原则，如 KISS(保持简单愚蠢)，DRY(不要重复自己)等。</p><p id="cd61" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">测试自动化是一个支持软件，所以你最好把它当作支持软件来对待。不要轻易用//TODO 偷工减料:这会损害稳定性，会使它无法适应不断变化的特性。有一个反对运动，主张代码生成解决方案的“开火并忘记”本质，我个人不认为它们必须自相矛盾。使用低代码工具创建测试套件，需要像编写代码一样小心。最终，您会生成代码；不管你看不看。</p><h1 id="1814" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated"><strong class="ak">要求开发人员进行审核</strong></h1><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/49c7676e6e620e2d6816d27001803dd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*2mqCeyuLrdk42DayMpaNRQ.png"/></div></figure><p id="0ab3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">并且:</p><blockquote class="mx my mz"><p id="ea24" class="jv jw mb jx b jy jz ka kb kc kd ke kf na kh ki kj nb kl km kn nc kp kq kr ks ig bi translated"><strong class="jx io">“总是这样编码，就好像最终维护<strong class="jx io">你的代码</strong>的那个人</strong>将会是<strong class="jx io">一个知道你住在哪里的</strong>暴力精神病患者”——stack overflow</p></blockquote><h1 id="705f" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated"><strong class="ak">一个 Bug 最好的藏身之处是一个脆弱的测试</strong></h1><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi nd"><img src="../Images/c29c111f84187ea04e6cc1a871f16fbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XrFtDCjRx5tfBnfaV75f5g.jpeg"/></div></div></figure><p id="09b8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">有时候，一个不可靠的测试实际上可以从错误中找到根源。智能手机——尤其是安卓手机——有很多形状和形式。bug 不必在每台设备上每次都 100%可重现。你确定你没有发现永远难以捉摸的“<em class="mb">”5%可再生的三星 Bug-the-devs-never-find，因为他们倾向于在像素上编码的手机？</em></p><p id="fffe" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你对上面提到的所有其他方面都有信心，不要认为一个不可靠的测试会自动成为测试问题。<strong class="jx io">和你的开发人员讨论一下吧！</strong></p><p id="d4b3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这应该有助于您稳定您的测试套件。你还有其他的建议吗？</p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/786a97f295e9026e92598ebee2b7d7aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1376/format:webp/1*Km2E8S8iZa4lCMuNyUDwNA.jpeg"/></div></figure><p id="29e0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Mathias Strziga   <em class="mb">从 2020 年初开始在 Appsfactory 担任质量保证总监。致力于建立更强大、更有灵感的测试团队。他在 intive 担任团队领导和测试自动化工程师。此外，他是一个巨大的美国车迷，除了测试，喜欢环游世界，和他的孩子一起玩。</em></p></div></div>    
</body>
</html>