<html>
<head>
<title>Blackjack Game Logic Basics — Built With React Hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">21点游戏逻辑基础——用React挂钩构建</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/blackjack-game-logic-basics-built-with-react-hooks-8e7e41fbbb87?source=collection_archive---------1-----------------------#2020-10-05">https://blog.devgenius.io/blackjack-game-logic-basics-built-with-react-hooks-8e7e41fbbb87?source=collection_archive---------1-----------------------#2020-10-05</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/3730a5b39a45e14d66b54979fd5f82f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0Mrjd9a8sISAJB7xlXyuHQ.png"/></div></div></figure><p id="b0ad" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在我决定转行到科技行业并成为一名软件工程师之前，我在一家赌场做了几年的桌上游戏经销商。我学习了所有主要的游戏，包括骰子、轮盘、二十一点、百家乐，也学习了“嘉年华”风格的游戏。</p><p id="2c6d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">自然，我觉得这将是一个很好的练习，通过如何开发一个21点游戏。这篇文章将会分解一些需要的游戏逻辑，但不会深入任何关于样式的细节。我最熟悉React，最近开始在我的状态管理和生命周期方法类型事件中使用钩子，所以我用它来构建我的应用程序。</p><p id="38b9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在我们开始之前，对于那些不太了解21点的人，这里有一个游戏进展的解释:</p><p id="39df" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="kt"> —面牌以10计值，号牌以其号码计值，a可计值为1或11。</em></p><ol class=""><li id="d6f6" class="ku kv in jx b jy jz kc kd kg kw kk kx ko ky ks kz la lb lc bi translated">玩家和发牌者都收到两张牌，发牌者保留一张面朝下的牌，直到轮到他/她。</li><li id="42ae" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks kz la lb lc bi translated">庄家检查黑杰克，这是一张与任何10点(21点)的牌配对的a。如果庄家有21点，玩家立即失去他们的赌注，除非他们也有21点。如果玩家有21点，而庄家没有，赌注的支付比例是3比2，也就是说，是原始赌注的1.5倍。(如果庄家亮出王牌，赌场里还有一种叫做21点保险的东西，但我没有把它包括在我的应用程序里)</li><li id="dff0" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks kz la lb lc bi translated">如果没有21点，现在轮到玩家了，他们可以选择击打、停留或加倍。击中，意思是在他们的手上加一张牌，停留，意思是保持他们当前的分数，加倍，意思是在原始赌注加倍后只拿一张牌。实际的21点游戏也允许玩家拆分成对的牌，比如两张8，但是我还没有添加这个功能。</li><li id="c3dc" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks kz la lb lc bi translated">玩家的目标是获得21分，尽管在某些情况下，最好保持在一个较低的数字，不要冒“破产”(超过21分)的风险，因为庄家也有机会破产，这使玩家也赢了。</li><li id="c265" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks kz la lb lc bi translated">如果玩家没有破产，而是留了下来，庄家会露出他们面朝下的牌，并在必要时抽牌，直到他们获得17分或更高的分数(大多数赌场在他们有所谓的“软17”时会让他们的庄家击中，这意味着他们手中有一张仍然可以被估价为1或11的a，我的应用程序保留在所有17分上)。</li><li id="b051" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks kz la lb lc bi translated">如果庄家数超过21，他/她立即支付给每个还有一手牌的玩家，但如果庄家没有破产，他/她将玩家数与庄家数进行比较，并相应地支付或接受赌注。</li><li id="533d" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks kz la lb lc bi translated">玩家在失败后获得奖金/下一注，循环再次开始。</li></ol><p id="034a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">差不多就是这样——尽可能短，尽可能接近21分而不超过，希望庄家要么得分比你低，要么破产。</p><p id="3ca8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">直入主题，我认为开始的一个好方法是创建一个数组，将每张扑克牌作为一个字符串，并将其设置为一个变量。</p><pre class="li lj lk ll gt lm ln lo lp aw lq bi"><span id="48e7" class="lr ls in ln b gy lt lu l lv lw">const deckOfCards = [<br/>  "A of Hearts", "2 of Hearts", "3 of Hearts", <br/>  "4 of Hearts", "5 of Hearts", "6 of Hearts", <br/>  "7 of Hearts", "8 of Hearts", "9 of Hearts",<br/>  "10 of Hearts", "J of Hearts", "Q of Hearts",<br/>  "K of Hearts",<br/>  "A of Clubs", "2 of Clubs", "3 of Clubs",<br/>  "4 of Clubs", "5 of Clubs", "6 of Clubs", <br/>  "7 of Clubs", "8 of Clubs", "9 of Clubs", <br/>  "10 of Clubs", "J of Clubs", "Q of Clubs",<br/>  "K of Clubs", <br/>  "A of Diamonds", "2 of Diamonds", "3 of Diamonds", <br/>  "4 of Diamonds", "5 of Diamonds", "6 of Diamonds", <br/>  "7 of Diamonds", "8 of Diamonds", "9 of Diamonds", <br/>  "10 of Diamonds", "J of Diamonds", "Q of Diamonds", <br/>  "K of Diamonds", <br/>  "A of Spades", "2 of Spades", "3 of Spades", <br/>  "4 of Spades","5 of Spades", "6 of Spades", <br/>  "7 of Spades", "8 of Spades", "9 of Spades", <br/>  "10 of Spades", "J of Spades", "Q of Spades", <br/>  "K of Spades"<br/>]</span></pre><p id="4a49" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我使用regex查找字符串开头的字母或数字，并确定cards值，并使用switch语句来确定哪个图像应该用于哪个卡。</p><p id="b3c9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">接下来，我把它做成两副牌，用我导入的‘lodash’洗牌函数洗牌，在这里找到了<a class="ae lx" href="https://lodash.com/docs/4.17.15#shuffle" rel="noopener ugc nofollow" target="_blank"/>。</p><pre class="li lj lk ll gt lm ln lo lp aw lq bi"><span id="2dd8" class="lr ls in ln b gy lt lu l lv lw">const twoDecks = [...deckOfCards, ...deckOfCards]</span><span id="fcd5" class="lr ls in ln b gy ly lu l lv lw">const shuffledDoubleDeck = shuffle(twoDecks)</span></pre><p id="e915" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我有了一个由两副牌组成的混洗阵列，下一步是在一手牌开始时将混洗的牌设置为状态变量。下面是我在应用程序中使用的所有状态，请记住，我的21点应用程序允许玩家下注，然后击中，翻倍或停留，但为了简单起见，目前不包括分裂的能力。当某些事件发生和条件满足时，许多逻辑在于改变这些状态变量，但是稍后会有更多关于这一点以及如何使用<code class="fe lz ma mb ln b">useEffect</code>钩子的内容。要了解更多关于React钩子的知识，你可以在这里访问文档<a class="ae lx" href="https://reactjs.org/docs/hooks-intro.html" rel="noopener ugc nofollow" target="_blank"/>。</p><pre class="li lj lk ll gt lm ln lo lp aw lq bi"><span id="4801" class="lr ls in ln b gy lt lu l lv lw">const [randomizedDecks, setRandomizedDecks] = useState([])<br/>const [chipCount, setChipCount] = useState(1000)<br/>const [betAmount, setBetAmount] = useState(0)<br/>const [lockedBet, setLockedBet] = useState(0)<br/>const [previousBet, setPreviousBet] = useState(0)<br/>const [dealersCards, setDealersCards] = useState([])<br/>const [dealerCount, setDealerCount] = useState(0)<br/>const [playersCards, setPlayersCards] = useState([])<br/>const [playerCount, setPlayerCount] = useState(0)<br/>const [isBlackjack, setIsBlackJack] = useState(false)<br/>const [isPlayerBusted, setIsPlayerBusted] = useState(false)<br/>const [didDouble, setDidDouble] = useState(false)<br/>const [isDealersTurn, setIsDealersTurn] = useState(false)<br/>const [isDealerBusted, setIsDealerBusted] = useState(false)<br/>const [isHandComplete, setIsHandComplete] = useState(true)<br/>const [winner, setWinner] = useState("")</span></pre><p id="10e0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对于那些只想快速复习一下<code class="fe lz ma mb ln b">useState</code>钩子的人来说，析构变量的左边有两个部分；第一部分是变量名，我们将调用它来检索我们的当前状态，第二部分是一个函数，它允许我们将状态设置为一个新值(惯例是使用变量名并添加前缀“set-”)。在右边，我们调用<code class="fe lz ma mb ln b">useState</code>钩子，并传递给它一个我们选择的参数，它将成为默认值。</p><p id="cab1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，我将简要回顾每一行状态，并概述它在应用程序中的用法(我试图尽可能按顺序排列):</p><blockquote class="mc md me"><p id="ef3a" class="jv jw kt jx b jy jz ka kb kc kd ke kf mf kh ki kj mg kl km kn mh kp kq kr ks ig bi translated"><code class="fe lz ma mb ln b">const [randomizedDecks, setRandomizedDecks] = useState([])</code> <br/>这是每手新牌开始时洗牌后的一副“牌”存放的地方。</p><p id="d6ba" class="jv jw kt jx b jy jz ka kb kc kd ke kf mf kh ki kj mg kl km kn mh kp kq kr ks ig bi translated"><code class="fe lz ma mb ln b">const [chipCount, setChipCount] = useState(1000)</code> <br/>玩家的运行筹码总数，默认设置为1000，我觉得这是一个合适的起始金额。</p><p id="5cc2" class="jv jw kt jx b jy jz ka kb kc kd ke kf mf kh ki kj mg kl km kn mh kp kq kr ks ig bi translated"><code class="fe lz ma mb ln b">const [betAmount, setBetAmount] = useState(0)</code></p><p id="6173" class="jv jw kt jx b jy jz ka kb kc kd ke kf mf kh ki kj mg kl km kn mh kp kq kr ks ig bi translated"><code class="fe lz ma mb ln b">const [lockedBet, setLockedBet] = useState(0)</code> <br/>当玩家点击“下注”按钮时，会将<code class="fe lz ma mb ln b">lockedBet</code>的金额放在桌上，这手牌现在可以开始了。</p><p id="0ccc" class="jv jw kt jx b jy jz ka kb kc kd ke kf mf kh ki kj mg kl km kn mh kp kq kr ks ig bi translated"><code class="fe lz ma mb ln b">const [previousBet, setPreviousBet] = useState(0)</code> <br/>一旦这手牌开始，<code class="fe lz ma mb ln b">lockedBet</code>就变成了<code class="fe lz ma mb ln b">previousBet</code>，它允许我创建一个“相同下注”按钮，让玩家可以毫不费力地开始下一手牌，下注金额完全相同。</p><p id="78bf" class="jv jw kt jx b jy jz ka kb kc kd ke kf mf kh ki kj mg kl km kn mh kp kq kr ks ig bi translated"><code class="fe lz ma mb ln b">const [dealersCards, setDealersCards] = useState([])</code> <br/>一个包含所有庄家牌的数组，最初从两张开始，如前所述，其中一张牌面朝下。</p><p id="48ea" class="jv jw kt jx b jy jz ka kb kc kd ke kf mf kh ki kj mg kl km kn mh kp kq kr ks ig bi translated"><code class="fe lz ma mb ln b">const [dealerCount, setDealerCount] = useState(0)</code> <br/>与<code class="fe lz ma mb ln b">dealersCards</code>相关的分数，在逻辑中很多地方用来决定谁是赢家，如果有的话。</p><p id="3142" class="jv jw kt jx b jy jz ka kb kc kd ke kf mf kh ki kj mg kl km kn mh kp kq kr ks ig bi translated">包含所有玩家牌的数组，从两张开始。</p><p id="32d4" class="jv jw kt jx b jy jz ka kb kc kd ke kf mf kh ki kj mg kl km kn mh kp kq kr ks ig bi translated"><code class="fe lz ma mb ln b">const [playerCount, setPlayerCount] = useState(0)</code> <br/>与<code class="fe lz ma mb ln b">playersCards</code>相关的分数，在逻辑中很多地方用来决定谁是赢家，如果有的话。</p><p id="e933" class="jv jw kt jx b jy jz ka kb kc kd ke kf mf kh ki kj mg kl km kn mh kp kq kr ks ig bi translated"><code class="fe lz ma mb ln b">const [isBlackjack, setIsBlackJack] = useState(false)</code> <br/>存储一个布尔值，记录是否发生了21点。与<code class="fe lz ma mb ln b">winner</code>状态结合使用，确定哪手牌是21点。</p><p id="28e1" class="jv jw kt jx b jy jz ka kb kc kd ke kf mf kh ki kj mg kl km kn mh kp kq kr ks ig bi translated"><code class="fe lz ma mb ln b">const [isPlayerBusted, setIsPlayerBusted] = useState(false)</code> <br/>如果没有21点，我们将存储这个布尔值，以跟踪玩家是否在击中时被终结。</p><p id="e147" class="jv jw kt jx b jy jz ka kb kc kd ke kf mf kh ki kj mg kl km kn mh kp kq kr ks ig bi translated"><code class="fe lz ma mb ln b">const [didDouble, setDidDouble] = useState(false)</code></p><p id="0816" class="jv jw kt jx b jy jz ka kb kc kd ke kf mf kh ki kj mg kl km kn mh kp kq kr ks ig bi translated">这个布尔值通知我们的应用程序该轮到谁了。在玩家停留或加倍时，我们调用此函数将<code class="fe lz ma mb ln b">isDealersTurn</code>设置为<code class="fe lz ma mb ln b">true</code>，表示不再轮到玩家，然后庄家根据需要抽牌。</p><p id="7389" class="jv jw kt jx b jy jz ka kb kc kd ke kf mf kh ki kj mg kl km kn mh kp kq kr ks ig bi translated"><code class="fe lz ma mb ln b">const [isDealerBusted, setIsDealerBusted] = useState(false)</code> <br/>如果庄家得分超过21，那么我们将<code class="fe lz ma mb ln b">isDealerBusted</code>设置为<code class="fe lz ma mb ln b">true</code>以表示庄家输了，最终触发支付序列。</p><p id="a63b" class="jv jw kt jx b jy jz ka kb kc kd ke kf mf kh ki kj mg kl km kn mh kp kq kr ks ig bi translated"><code class="fe lz ma mb ln b">const [isHandComplete, setIsHandComplete] = useState(true)</code> <br/>一个通用的总括，如果一个获胜的事件发生，例如，21点，或破坏，我们将这个布尔值翻转到<code class="fe lz ma mb ln b">true</code>，这样我们就可以用它来知道我们应该显示哪些元素，以及何时显示。</p></blockquote><p id="be70" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我不会遍历所有的逻辑，因为我在这里链接了Github库<a class="ae lx" href="https://github.com/tfunk2/doubledeck-blackjack" rel="noopener ugc nofollow" target="_blank"/>,供任何想要查看它的人使用(有点乱，但它是有效的！)，但是我想至少展示一个我使用过的<code class="fe lz ma mb ln b">useEffect</code>钩子的例子，因为它们对于基于特定的状态变化使某些事件发生是必不可少的——我将在下面更详细地解释。</p><p id="3e55" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先，让我们来看看我现在拥有的一个工作版本，看看一些不同的状态是如何影响应用程序的。我制作这个图表是为了帮助更好地理解每个状态是如何被使用的，但是并没有突出显示所有用来制作它的状态。这是一手牌完成后您可能会看到的屏幕:</p><figure class="li lj lk ll gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mi"><img src="../Images/eec86da9c4d801b6617182d19301e002.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Aud1hzXodLBkEwFSaa2jPw.png"/></div></div></figure><p id="ae37" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe lz ma mb ln b">useEffect</code>挂钩的使用非常类似于<code class="fe lz ma mb ln b">componentDidMount</code>或<code class="fe lz ma mb ln b">componentDidUpdate</code>生命周期方法，在很多情况下，我将它用作事件链。下面是一个我可能使用的空useEffect钩子的例子:</p><pre class="li lj lk ll gt lm ln lo lp aw lq bi"><span id="2890" class="lr ls in ln b gy lt lu l lv lw">useEffect(() =&gt; {<br/>  // logic and conditions go here<br/>}, [dealerCount]) </span></pre><p id="aacf" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">注意我是如何在数组中使用<code class="fe lz ma mb ln b">dealerCount</code>作为第二个参数的？我把它放在一个数组中，因为如果我们愿意，我们可以把一个以上的状态放进去。通过把<code class="fe lz ma mb ln b">dealerCount</code>放在那里，我是说当<code class="fe lz ma mb ln b">dealerCount</code>状态改变时，我想运行一些我指定的代码。一个因和“果”。</p><p id="c80f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是直接取自我的应用程序的完整示例:</p><pre class="li lj lk ll gt lm ln lo lp aw lq bi"><span id="d5ea" class="lr ls in ln b gy lt lu l lv lw">useEffect(() =&gt; {</span><span id="424e" class="lr ls in ln b gy ly lu l lv lw">  if(dealerCount &gt; 21) {<br/>    setIsDealerBusted(true)<br/>    setWinner("player")<br/>    setIsHandComplete(true)<br/>  }</span><span id="8a52" class="lr ls in ln b gy ly lu l lv lw">  if(dealerCount &gt;= 17 &amp;&amp; dealerCount &lt; 22 &amp;&amp; isDealersTurn) {<br/>    if(dealerCount &gt; playerCount) {<br/>      setWinner("dealer")<br/>      setIsHandComplete(true)<br/>    }</span><span id="edb1" class="lr ls in ln b gy ly lu l lv lw">    if(dealerCount &lt; playerCount &amp;&amp; !isPlayerBusted) {<br/>      setWinner("player")<br/>      setIsHandComplete(true)<br/>    }</span><span id="ebaf" class="lr ls in ln b gy ly lu l lv lw">    if(dealerCount === playerCount &amp;&amp; !isPlayerBusted) {<br/>      setWinner("push")<br/>      setIsHandComplete(true)<br/>    }<br/>  }</span><span id="b508" class="lr ls in ln b gy ly lu l lv lw">  if(dealerCount &lt; 17 &amp;&amp; isDealersTurn &amp;&amp; !isPlayerBusted) {<br/>    setTimeout(() =&gt; {<br/>      dealerHitAgain()<br/>    }, 500);<br/>  }<br/>}, [dealerCount])</span></pre><p id="62f0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我认为这读起来很容易，因为州名被完全写了出来！我个人不像其他人那样介意更长的变量名，因为这有助于我理解逻辑，并回到几个月前编写的代码，轻松地从我停止的地方继续。</p><p id="6cbe" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个<code class="fe lz ma mb ln b">useEffect</code>通过设置其他变量的状态启动了另一个事件链，这些变量在我用来控制游戏流程的其他<code class="fe lz ma mb ln b">useEffect</code>钩子中指定。</p><p id="2d08" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">举个例子，如果<code class="fe lz ma mb ln b">dealerCount</code>小于<code class="fe lz ma mb ln b">17</code>，并且它<code class="fe lz ma mb ln b">isDealersTurn</code><em class="kt"/>玩家还没有被终结，我用了一个<code class="fe lz ma mb ln b">setTimeout</code>函数来延迟<code class="fe lz ma mb ln b">dealerHitAgain()</code>辅助函数，你猜对了，这个函数是给庄家的手增加一张牌，因此，“庄家又打了”。</p><p id="25be" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">那么这有什么用呢？因为它增加了一张卡，<code class="fe lz ma mb ln b">dealerCount</code>也再次改变，我们又回到了同一个<code class="fe lz ma mb ln b">useEffect</code>里面。除了这一次，庄家的分数到了<code class="fe lz ma mb ln b">23</code>，这符合不同的条件，并将<code class="fe lz ma mb ln b">isDealerBusted</code>设置为<code class="fe lz ma mb ln b">true</code>，同时将赢家设置为<code class="fe lz ma mb ln b">“player”</code>，将<code class="fe lz ma mb ln b">isHandComplete</code>设置为<code class="fe lz ma mb ln b">true</code>，因为这手牌正式结束，庄家被终结，玩家获胜。</p><p id="eb09" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">既然玩家已经赢了，那么当设置了<code class="fe lz ma mb ln b">winner</code>时，我创建的<code class="fe lz ma mb ln b">useEffect</code>就生效了。这个链条还在继续，有许多条件要求制造21点，并且创建这个应用程序的很多工作都是反复试验，看看什么会以什么方式运行(开始时扯头发)。然而，最终，修修补补是不可取的，我认为是我在这个记事本上写的东西帮助我的大脑将所有这些联系在一起:</p><figure class="li lj lk ll gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mj"><img src="../Images/a69008dd6cd6a224bb8b1bbc79d29b9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oN63yZF6rgYrI2i089AVYw.jpeg"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">我知道有点潦草的笔迹！</figcaption></figure><p id="adcd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一旦我有了一个明确的攻击计划，创造了所有必要的状态，并一点一点地遵循我的计划，一切都变得更加顺利。如果事情以我没有预料到的方式进行，因为我有一个更有条理的方法，我能够更快地解决问题，用我的逻辑解决任何问题。</p><p id="10d3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是我过去4天工作的高潮！</p><p id="acfb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="kt">请在设置上选择高清！SD是默认的，至少对我来说是这样，但它并不公平！</em></p><figure class="li lj lk ll gt jo"><div class="bz fp l di"><div class="mo mp l"/></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">高滚子状态，上了18800，不算太差！</figcaption></figure><p id="5c6c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">有趣的是，一点额外的计划能让你走这么远。我希望这篇文章对你有价值，并帮助你了解更多关于21点逻辑或21点的一般知识，并且理想情况下，你也了解了如何使用React Hooks构建这样的应用程序。感谢您的宝贵时间，祝您黑客生涯愉快！</p></div></div>    
</body>
</html>