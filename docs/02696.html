<html>
<head>
<title>Understanding the Kubectl Apply Command</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解 Kubectl Apply 命令</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/understanding-the-kubectl-apply-command-f1d56527be01?source=collection_archive---------4-----------------------#2020-08-21">https://blog.devgenius.io/understanding-the-kubectl-apply-command-f1d56527be01?source=collection_archive---------4-----------------------#2020-08-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="29dd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这篇文章中，我们将探索<strong class="jp ir"> kubectl apply </strong>命令是如何在内部工作的。这将让你更好地理解 kubernetes 是如何工作的，并让你成为一名出色的 DevOps 工程师。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/8dd8087ee7d35c2a762fb3ed049eb093.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*rF2J1Q_LIOpwFRSJ.jpg"/></div></div></figure><p id="25e1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通常，kubectl apply 命令用于以声明的方式创建和更新对象。</p><p id="297a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，要更新/创建 nginx.yaml 中定义的对象:</p><pre class="km kn ko kp gt kx ky kz la aw lb bi"><span id="073f" class="lc ld iq ky b gy le lf l lg lh">kubectl apply -f nginx.yaml</span></pre><p id="5537" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="li">提醒一下，前面的命令展示了如何使用 apply 命令以声明的方式创建和更新 kubernetes 对象。</em></p></div><div class="ab cl lj lk hu ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="ij ik il im in"><p id="fff6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了理解 apply 命令的内部原理，让我们先后退一步，理解对象是如何在 kubernetes 中创建的:</p><p id="bda1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以 YAML 文件中定义的下列 POD 对象为例:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="0860" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在创建对象:</p><pre class="km kn ko kp gt kx ky kz la aw lb bi"><span id="0ede" class="lc ld iq ky b gy le lf l lg lh">kubectl create -f nginx.yaml</span></pre><p id="bd87" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">重要提示</strong>:在后台，会在 kubernetes 中额外生成一个动态配置文件。这个新文件类似于我们在本地创建的文件。但是，它包含有关对象状态的更多信息:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="7d64" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">上面的文件是 kubernetes 集群上对象的实时配置。</strong></p><p id="94be" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如上所述，kubernetes 将 status 字段附加到配置文件中，以便跟踪关于对象的信息。</p><p id="e3c0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是 kubernetes 如何在内部存储关于一个对象的信息，<strong class="jp ir">而不管它是以何种方式创建的(声明式还是命令式)</strong>。</p><h1 id="5b86" class="ls ld iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">返回到应用命令</h1><p id="317f" class="pw-post-body-paragraph jn jo iq jp b jq mp js jt ju mq jw jx jy mr ka kb kc ms ke kf kg mt ki kj kk ij bi translated">执行 apply 命令时，会考虑簿记中的以下 3 个文件。</p><ul class=""><li id="70c4" class="mu mv iq jp b jq jr ju jv jy mw kc mx kg my kk mz na nb nc bi translated">一个<strong class="jp ir">本地配置文件</strong>(开发者定义)</li><li id="32e2" class="mu mv iq jp b jq nd ju ne jy nf kc ng kg nh kk mz na nb nc bi translated">kubernetes 上的一个<strong class="jp ir">活动对象定义</strong>(由 kubernetes 创建的附加 YAML 文件)</li><li id="ebbe" class="mu mv iq jp b jq nd ju ne jy nf kc ng kg nh kk mz na nb nc bi translated"><strong class="jp ir">最后应用的配置</strong>。(新)</li></ul><p id="5dff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可能已经注意到，列出的前两个文件是我们之前讨论过的，第三个文件是 apply 命令特有的。</p><p id="caa8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每当我们运行应用命令<strong class="jp ir">时，所有的三个文件都被比较，以确定在活动对象上要做什么改变</strong></p><h1 id="0a1d" class="ls ld iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">有关应用的配置文件的更多信息</h1><p id="f746" class="pw-post-body-paragraph jn jo iq jp b jq mp js jt ju mq jw jx jy mr ka kb kc ms ke kf kg mt ki kj kk ij bi translated">本地对象配置文件<strong class="jp ir">的 YAML 版本</strong>被转换为 JSON 格式，然后被存储为<strong class="jp ir">最后应用的</strong>配置。</p><p id="802b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">按照我们之前的例子:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="lq lr l"/></div></figure><h1 id="67d6" class="ls ld iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">kubernetes 如何利用这些文件？</h1><p id="e7e2" class="pw-post-body-paragraph jn jo iq jp b jq mp js jt ju mq jw jx jy mr ka kb kc ms ke kf kg mt ki kj kk ij bi translated">例如:假设我们将本地配置文件<strong class="jp ir">中的 image 字段从 1.18 更新为 1.19，然后像以前一样运行 apply 命令。</strong></p><p id="38a4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将改变后的图像域与<strong class="jp ir">实时配置</strong>中的值进行比较，如果有差异，则用新值更新实时配置。</p><p id="6ace" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在任何改变之后，最后应用的<strong class="jp ir">JSON 文件总是被更新。</strong></p><p id="aabf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此时你可能会问自己:JSON 应用配置文件的目的是什么？</p><p id="33dd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最好用一个例子来说明这一点:</p><p id="36a3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们假设一个字段被删除了，比方说，label 中的 type 字段在我们的<strong class="jp ir">本地配置文件</strong>中被删除了。当我们运行 kubectl apply 命令时，我们看到最后一个<strong class="jp ir">应用的配置</strong>有一个标签，但是它不存在于<strong class="jp ir">本地配置</strong>中。</p><p id="fa21" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这意味着该字段需要从<strong class="jp ir">实时配置</strong>(由 kubernetes 生成的 YAML 文件)中删除。</p><p id="1e17" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，如果一个字段存在于<strong class="jp ir">实时配置</strong>中，而不存在于<strong class="jp ir">本地</strong>或<strong class="jp ir">最后应用的</strong>配置中，那么它将保持原样。</p><p id="8918" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是如果某个字段在<strong class="jp ir">本地文件</strong>中丢失，并且存在于最后一个<strong class="jp ir">应用的配置</strong>中，这意味着在之前的步骤中该字段已被移除。</p><p id="b78f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">总之:新添加的<strong class="jp ir">应用配置文件</strong>帮助 kubernetes 找出已经从<strong class="jp ir">本地文件</strong>中删除的字段。</p><p id="f19e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们刚才讨论的内容可以在 kubernetes is 文档页面中详细参考。</p><h1 id="3748" class="ls ld iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">包扎</h1><ul class=""><li id="e09d" class="mu mv iq jp b jq mp ju mq jy ni kc nj kg nk kk mz na nb nc bi translated">我们学习了 kubectl apply 命令使用的三组文件</li><li id="2bf4" class="mu mv iq jp b jq nd ju ne jy nf kc ng kg nh kk mz na nb nc bi translated">本地文件存储在我们的本地系统中。</li><li id="b4c5" class="mu mv iq jp b jq nd ju ne jy nf kc ng kg nh kk mz na nb nc bi translated"><strong class="jp ir">活动对象配置</strong>在 kubernetes 内存中。</li></ul><h2 id="bd0a" class="lc ld iq bd lt nl nm dn lx nn no dp mb jy np nq mf kc nr ns mj kg nt nu mn nv bi translated">但是存储了最后应用的配置的 JSON 文件在哪里呢？</h2><p id="9938" class="pw-post-body-paragraph jn jo iq jp b jq mp js jt ju mq jw jx jy mr ka kb kc ms ke kf kg mt ki kj kk ij bi translated">它作为一个名为<strong class="jp ir">last applied configuration</strong>的注释存储在 kubernetes 集群上的活动对象配置中。</p><blockquote class="nw nx ny"><p id="cc95" class="jn jo li jp b jq jr js jt ju jv jw jx nz jz ka kb oa kd ke kf ob kh ki kj kk ij bi translated">所以请记住，这只有在您使用 apply 命令时才能完成，kubectl create 或 replace 命令不会像解释的那样存储最后应用的配置。</p></blockquote><p id="087f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用 apply 命令后，无论何时进行更改，apply 命令都会比较所有三个部分。</p><ol class=""><li id="9220" class="mu mv iq jp b jq jr ju jv jy mw kc mx kg my kk oc na nb nc bi translated"><strong class="jp ir">本地</strong>定义文件。</li><li id="5ed3" class="mu mv iq jp b jq nd ju ne jy nf kc ng kg nh kk oc na nb nc bi translated"><strong class="jp ir">活</strong>对象配置文件。</li><li id="6195" class="mu mv iq jp b jq nd ju ne jy nf kc ng kg nh kk oc na nb nc bi translated">存储的<strong class="jp ir">最后一次</strong>应用的配置</li></ol></div><div class="ab cl lj lk hu ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="ij ik il im in"><p id="3c7d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="li">原载于</em><a class="ae od" href="https://luispreciado.blog/posts/kubernetes/core-concepts/kubectl-apply" rel="noopener ugc nofollow" target="_blank"><em class="li">https://luispreciado . blog</em></a><em class="li">。</em></p></div></div>    
</body>
</html>