<html>
<head>
<title>Best Practices of Software Engineering. Part 3. Autotests.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">软件工程最佳实践。第三部分。自动测试。</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/best-practices-of-software-engineering-part-3-autotests-d74c13086742?source=collection_archive---------7-----------------------#2020-05-30">https://blog.devgenius.io/best-practices-of-software-engineering-part-3-autotests-d74c13086742?source=collection_archive---------7-----------------------#2020-05-30</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/e9711b1ba275399d7aafe1fab0742867.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yEwPmJPvI4NPcAGm__kIbw.jpeg"/></div></div></figure><p id="5ca4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在本文中，是时候讨论测试自动化了。当我们试图自动化测试过程时，我们不能忽视它们。所以现在，我将谈论测试自动化，以及一般的测试，但是将集中在系统测试上。</p><p id="4da7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">随着项目的增长，它可能开始变成一个无法控制的怪物。产品中的缺陷数量越来越多，测试和发布的时间也越来越长。同时，市场竞争越来越激烈，需要越来越快的产品发布。因此，你需要加快产品开发的速度。但是，如何做到这一点而不出现质量漏洞呢？</p><p id="9410" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对于如何增加<a class="ae kt" href="https://medium.com/@kirillmedvednykov/best-practices-of-software-engineering-part-2-velocity-metrics-692c401acb4b" rel="noopener">上市时间</a>，你有不同的选择，其中之一是帮助你的 QA 自动化他的工作。例如，您可以自动化“回归测试”，重要的“端到端”场景，或者测试的“前提条件流程”。这并不意味着单元测试或功能测试不重要，我只是想向您展示一个总体情况。每种测试类型都将帮助您控制代码的质量。不同的是，不同类型的测试将控制不同类型的错误，并将对您的产品和钱包产生不同的影响。</p><h1 id="b7aa" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">自动测试的类型</h1><p id="5833" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">让我们看看自动测试的类型，并尝试理解它们的优缺点。</p><p id="e1ac" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">单元测试。</strong>这是测试产品代码、模块、类或功能，与代码的其余部分隔离开来。</p><p id="1dda" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Pluses:</p><ul class=""><li id="2803" class="lx ly in jx b jy jz kc kd kg lz kk ma ko mb ks mc md me mf bi translated">书写简单快捷。它们只需要很少的写作时间，而且入门门槛很低。</li><li id="164b" class="lx ly in jx b jy mg kc mh kg mi kk mj ko mk ks mc md me mf bi translated">错误定位。错误发生在哪里是显而易见的，不需要调试代码来查找错误。</li><li id="2536" class="lx ly in jx b jy mg kc mh kg mi kk mj ko mk ks mc md me mf bi translated">易于维护。如果测试代码中有什么变化，在测试中很容易修复。</li><li id="e02a" class="lx ly in jx b jy mg kc mh kg mi kk mj ko mk ks mc md me mf bi translated">不需要基础设施来运行测试。你不一定需要詹金斯或其他特殊管道等特殊工作。您可以在本地机器上运行它。</li><li id="ce2c" class="lx ly in jx b jy mg kc mh kg mi kk mj ko mk ks mc md me mf bi translated">代码质量。帮助您控制代码的质量，提高代码的可读性和低复杂性。我将在我的下一篇文章中详细讨论这一点。</li></ul><p id="3c4d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">减</p><ul class=""><li id="8fbc" class="lx ly in jx b jy jz kc kd kg lz kk ma ko mb ks mc md me mf bi translated">漫长的回报。为了感受这些测试的真实影响，必须有大量的测试。仅仅因为有这么多，这些测试的效果将随着时间的推移而被感受到。</li><li id="005e" class="lx ly in jx b jy mg kc mh kg mi kk mj ko mk ks mc md me mf bi translated">对于测试，必须有高质量的代码。如果你有某种非常复杂的遗留代码，那么用单元测试覆盖这些代码几乎是不可能的。但另一方面，这也是一个优势。如果你写单元测试，你的代码会更好。这一点与这个列表中的最后一个加号相反。</li></ul><p id="f0b5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">整合测试。</strong>测试系统中协同工作的几个类/模块。</p><p id="94ee" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Pluses:</p><ul class=""><li id="8257" class="lx ly in jx b jy jz kc kd kg lz kk ma ko mb ks mc md me mf bi translated">测试处理时间短。通常它们通过的速度比单元测试慢，但是在你需要的时候运行一次还是可以的。</li><li id="5134" class="lx ly in jx b jy mg kc mh kg mi kk mj ko mk ks mc md me mf bi translated">可接受的误差定位。它们并没有将错误显示为模块化的，但是可能出现错误的代码量仍然非常有限。</li></ul><p id="8685" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">缺点:</p><ul class=""><li id="bb23" class="lx ly in jx b jy jz kc kd kg lz kk ma ko mb ks mc md me mf bi translated">比单元测试更复杂。测试比单元测试更难编写和维护。但是，他们的门槛仍然很低。</li><li id="49ad" class="lx ly in jx b jy mg kc mh kg mi kk mj ko mk ks mc md me mf bi translated">基础设施。可能需要基础设施来运行测试。这意味着这需要时间。</li></ul><p id="7b36" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">系统测试。</strong>整体测试程序。</p><p id="2dfd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Pluses:</p><ul class=""><li id="fab5" class="lx ly in jx b jy jz kc kd kg lz kk ma ko mb ks mc md me mf bi translated">测试很快就有回报。少量的测试发现了许多错误。即使一个测试也能够发现一堆缺陷，并且这种测试的效果立即可见。</li><li id="15d7" class="lx ly in jx b jy mg kc mh kg mi kk mj ko mk ks mc md me mf bi translated">测试的行为就像用户一样。像 Selenium 这样的工具可以在你的网站上模拟用户的旅程，启动浏览器，加载页面，按下按钮等等。</li></ul><p id="60b8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">缺点:</p><ul class=""><li id="1c76" class="lx ly in jx b jy jz kc kd kg lz kk ma ko mb ks mc md me mf bi translated">错误定位错误。例如:你为某个系统的注册用户写了一个测试，结果失败了。错在哪里？可能是:表单验证、orm 问题、数据库中不正确的数据类型、电子邮件发送问题等。</li><li id="a3a9" class="lx ly in jx b jy mg kc mh kg mi kk mj ko mk ks mc md me mf bi translated">很好的准备时间。对于系统测试，一次测试运行 20 分钟可视为正常速度。而且，可能需要十几次或更多次这样的测试。当然，您可以并行化测试，但是这将比功能测试或单元测试花费更多的处理时间，并且会增加支持成本。</li><li id="60a2" class="lx ly in jx b jy mg kc mh kg mi kk mj ko mk ks mc md me mf bi translated">这是一个完整的软件产品。通常，这样的测试是作为独立的项目编写的，需要独立的支持专家、特殊任务、工作流程等。</li></ul><h1 id="f49e" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">我什么时候需要写自动测试？</h1><p id="2966" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">在我看来，如果不止一个开发人员在你的项目上工作，你需要使用自动化。但是为了更深入的理解，我已经添加了一些要点来帮助你理解什么时候开始做自动化。</p><ul class=""><li id="84f9" class="lx ly in jx b jy jz kc kd kg lz kk ma ko mb ks mc md me mf bi translated">大量的手工测试和缺乏时间进行回归测试。对于该指标，请参考<a class="ae kt" href="https://medium.com/@kirillmedvednykov/best-practices-of-software-engineering-part-2-velocity-metrics-692c401acb4b" rel="noopener">手动测试时间</a> (MTT)度量。</li><li id="8598" class="lx ly in jx b jy mg kc mh kg mi kk mj ko mk ks mc md me mf bi translated">很多时间花在准备测试上，例如，生成测试数据或设置环境。</li><li id="32fb" class="lx ly in jx b jy mg kc mh kg mi kk mj ko mk ks mc md me mf bi translated">一个有几个团队的大型项目，其中一个程序员可能会破坏另一个程序员的代码。</li><li id="438d" class="lx ly in jx b jy mg kc mh kg mi kk mj ko mk ks mc md me mf bi translated">生产中由于人为因素造成的大量错误。这将有助于衡量“在生产服务器上发现的问题率”</li><li id="24da" class="lx ly in jx b jy mg kc mh kg mi kk mj ko mk ks mc md me mf bi translated">在引入误差、检测误差和校正误差之间有一段很长的时间。</li></ul><h1 id="11f4" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">如何理解要自动化什么？</h1><p id="324e" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">经常发生的情况是，对系统进行全面的回归测试是不合理的昂贵。这就提出了下面的问题:为了在发布成本和产品质量之间取得平衡，应该检查什么？要解决这个问题，你需要有明确的产品需求。我不建议在没有它的情况下开始自动化测试过程。即使是最简单或最差的质量需求也将有助于确定功能的数量，手动测试需要多少时间，以及需要自动测试覆盖的功能。这些需求将有助于选择哪些测试对自动化至关重要。</p><p id="726a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">例如，你可以有 20 个需求，每个需求包含 10-20 个测试。手工测试可能要花费大量的时间来完成这样一个范围的测试，以进行全面的回归。对于一个项目来说，这可能是不合理的昂贵，尤其是如果你正在开发一些 web 项目，并且每周发布一次或两次。在这种情况下，您可以将测试分成几个组(例如:高优先级、中优先级、低优先级)，并决定在每次发布之前需要通过哪些测试组。此外，您可以将最不稳定模块中的测试添加到必需测试列表中。找到不稳定的模块可以帮助度量“缺陷密度”,这是我在上一篇文章中谈到的。</p><p id="eee7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">根据上面的例子，如果您用自动测试覆盖了所有重要的功能，您可以显著地加快通过回归测试的过程。但是，同样值得理解的是，自动测试也是要花钱的。开发测试并维护它们的正常工作需要时间，尤其是如果它们是系统测试的话。因此，你不应该给自己设定自动测试 100%覆盖的目标，任何地方你都需要用常识来指导。</p><h1 id="96c1" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">如何高效评估？</h1><p id="31b6" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">为了理解这一点，有必要测量这样的指标:自动测试发现的 bug 的数量，自动测试的需求覆盖率是多少，以及它们节省了多少时间或金钱。使用这些指标，你将有机会计算自动测试的投资回报率。它字面上显示了多少钱，如果它真的帮助你。</p><p id="637c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">作为一个例子，我将向你展示我们如何在我当前的项目中评估测试覆盖率。我们使用吉拉的 xRay 插件，它帮助我们管理产品需求，并查看每个版本的测试覆盖率。当我们运行测试时，我们会在吉拉自动创建一个文本执行问题，并将自动测试的结果链接到那里。然后这个 TextExecution 会自动链接到部署任务。因此，通过任何部署票证的链接，我们都可以看到报告。</p><figure class="mm mn mo mp gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ml"><img src="../Images/7fee6ac9607d9a25b2969ff344c4ea1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jGzZra5QPG5UuG9l"/></div></div></figure><p id="7053" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">此报告显示测试覆盖的需求数量和内容、运行的测试以及失败的测试数量。同样在这个报告中，您可以看到更详细的信息。</p><figure class="mm mn mo mp gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mq"><img src="../Images/50c8899ac7ad332e1822f97f454718b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NigNKVU8pCf58HJB"/></div></div></figure><p id="7067" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这种方法帮助我们评估被测试功能的数量，并估计我们需要多少时间来完成一个完整的回归，以及我们需要多少时间来自动化整个项目。</p><h1 id="ef9f" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">监控测试</h1><p id="78eb" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">同样在我们的项目中，我们使用在真实项目上运行的“监控测试”。他们几乎不对项目做任何更改，也不删除或添加任何东西。事实上，它们的功能就像真实系统的冒烟测试:检查数据一致性，REST Api 的可用性，如果调度任务及时工作，用户可以登录到系统，访问权限正确分配给他，等等。这些测试有助于我们在一些事件发生后立即了解问题，也有助于发布产品的新版本，并控制生产服务器上是否一切正常。</p><p id="b9ed" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">需要注意的是:每个产品都是特定的，需要不同的产品测试策略。测试方法中没有灵丹妙药。</p></div><div class="ab cl mr ms hr mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ig ih ii ij ik"><h2 id="0246" class="my kv in bd kw mz na dn la nb nc dp le kg nd ne li kk nf ng lm ko nh ni lq nj bi translated">软件工程的最佳实践</h2><ol class=""><li id="b13d" class="lx ly in jx b jy ls kc lt kg nk kk nl ko nm ks nn md me mf bi translated"><a class="ae kt" href="https://medium.com/@kirillmedvednykov/best-practices-of-software-engineering-part-1-goals-4457a907e756" rel="noopener">目标</a></li><li id="6e3f" class="lx ly in jx b jy mg kc mh kg mi kk mj ko mk ks nn md me mf bi translated"><a class="ae kt" href="https://medium.com/@kirillmedvednykov/best-practices-of-software-engineering-part-2-velocity-metrics-692c401acb4b" rel="noopener">速度指标</a></li><li id="73e7" class="lx ly in jx b jy mg kc mh kg mi kk mj ko mk ks nn md me mf bi translated"><a class="ae kt" href="https://medium.com/@kirillmedvednykov/best-practices-of-software-engineering-part-3-autotests-d74c13086742" rel="noopener">自动测试</a></li><li id="346e" class="lx ly in jx b jy mg kc mh kg mi kk mj ko mk ks nn md me mf bi translated"><a class="ae kt" href="https://medium.com/@kirillmedvednykov/best-practices-of-software-engineering-part-4-automation-eaf795b9a8d8" rel="noopener">自动化</a></li><li id="e16a" class="lx ly in jx b jy mg kc mh kg mi kk mj ko mk ks nn md me mf bi translated"><a class="ae kt" href="https://medium.com/dev-genius/best-practices-of-software-engineering-part-5-code-quality-164e9c87d6db" rel="noopener">代码质量</a></li></ol></div></div>    
</body>
</html>