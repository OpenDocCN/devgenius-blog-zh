<html>
<head>
<title>Tell-don’t-ask, please!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">告诉-不要问，求你了！</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/tell-dont-ask-please-3cab41e7907b?source=collection_archive---------4-----------------------#2022-11-25">https://blog.devgenius.io/tell-dont-ask-please-3cab41e7907b?source=collection_archive---------4-----------------------#2022-11-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="f9a8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们做面向对象编程(OOP 语言)是因为我们使用了 OOP 语言中一些奇特的东西吗？。我不这么认为，你可以用 Java 写代码，而根本不用 OOP。关键是封装。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/1f9ec8dde87856a72e6b0de5f3d6ba85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MNJFCsxJycOUCAjQ3n-CKg.jpeg"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated"><a class="ae lb" href="https://pixabay.com/es/illustrations/c%c3%a9lulas-nerviosas-neuronas-2213009/" rel="noopener ugc nofollow" target="_blank"> pixabay </a></figcaption></figure><blockquote class="lc ld le"><p id="0c0f" class="jn jo lf jp b jq jr js jt ju jv jw jx lg jz ka kb lh kd ke kf li kh ki kj kk ij bi translated">在面向对象编程(OOP)中，<strong class="jp ir">封装</strong>指的是将数据与操作该数据的方法捆绑在一起，或者限制对某个对象组件的直接访问。封装用于隐藏类中结构化数据对象的值或状态，防止客户端以可能暴露隐藏的实现细节或违反方法维护的状态不变性的方式直接访问它们。<br/> <a class="ae lb" href="https://en.wikipedia.org/wiki/Encapsulation_(computer_programming)" rel="noopener ugc nofollow" target="_blank">维基百科</a></p></blockquote><p id="141e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在 OOP 中牢记这个定义，我们应该减少使用<strong class="jp ir">getter</strong>。如果您不使用 getters，但是您有记录或类似的概念来轻松访问对象内部的属性，这也适用。<br/> Getters 是一种在对象本身之外显示对象值的方法。getters 的效果就像离心力一样，逻辑被移到了应该包含它的类之外。</p><p id="0935" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们用这个例子来说一下:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi lj"><img src="../Images/b2e812a05e955ad68f467e87ebc07be4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0ReahLX7LLuE7o3Esr1khQ.png"/></div></div></figure><p id="91e6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我的 getters 已经移动了逻辑来计算“PositionDirectionService”中的新位置。这就是我们所说的贫血模型，领域类没有逻辑，而逻辑在一个纯粹虚构的类中。</p><p id="e765" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们用<strong class="jp ir">告诉不要问</strong>来重构这段代码:</p><blockquote class="lc ld le"><p id="bd3b" class="jn jo lf jp b jq jr js jt ju jv jw jx lg jz ka kb lh kd ke kf li kh ki kj kk ij bi translated">告诉别人不要问是一个原则，它帮助人们记住面向对象是关于将数据和操作这些数据的函数捆绑在一起。它提醒我们，我们应该告诉对象做什么，而不是向对象请求数据并对数据进行操作。这鼓励将行为移入一个对象，以配合数据。<br/>马丁·福勒<a class="ae lb" href="https://www.martinfowler.com/bliki/TellDontAsk.html" rel="noopener ugc nofollow" target="_blank"/></p></blockquote><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi lk"><img src="../Images/bade3180ee304ada713040e924cfe8f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1308/format:webp/1*wDXo7UlsQthxUnRgys24qg.png"/></div></figure><p id="92ac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了移除 getters，我必须在负责计算新位置(位置和向量)的类中创建一个方法。在我看来，向量可以应用于位置，所以我创建了一个方法来应用于<strong class="jp ir">位置</strong>向量<strong class="jp ir">向量</strong>然后我调用<strong class="jp ir">向量</strong>来计算新的<strong class="jp ir"> x </strong>和<strong class="jp ir"> y </strong>而不会向外界公开这些值。我没有破坏封装，我还把方法转移到包含数据的类中。</p><blockquote class="lc ld le"><p id="3279" class="jn jo lf jp b jq jr js jt ju jv jw jx lg jz ka kb lh kd ke kf li kh ki kj kk ij bi translated"><strong class="jp ir">信息专家</strong>(也称为<strong class="jp ir">专家</strong>或<strong class="jp ir">专家原则</strong>)是一个原则，用于确定在哪里委派责任，例如方法、计算字段等等。</p><p id="2017" class="jn jo lf jp b jq jr js jt ju jv jw jx lg jz ka kb lh kd ke kf li kh ki kj kk ij bi translated">使用信息专家的原则，分配职责的一般方法是查看给定的职责，确定履行职责所需的信息，然后确定信息存储的位置。</p><p id="bd6c" class="jn jo lf jp b jq jr js jt ju jv jw jx lg jz ka kb lh kd ke kf li kh ki kj kk ij bi translated">这将导致将责任放在具有完成它所需的最多信息的类上。<br/> <a class="ae lb" href="https://en.wikipedia.org/wiki/GRASP_(object-oriented_design)" rel="noopener ugc nofollow" target="_blank">掌握信息的专家</a></p></blockquote><h2 id="2548" class="ll lm iq bd ln lo lp dn lq lr ls dp lt jy lu lv lw kc lx ly lz kg ma mb mc md bi translated">那么所有的吸气剂都是坏的？</h2><p id="d89d" class="pw-post-body-paragraph jn jo iq jp b jq me js jt ju mf jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated">简短回答否:</p><blockquote class="lc ld le"><p id="b98c" class="jn jo lf jp b jq jr js jt ju jv jw jx lg jz ka kb lh kd ke kf li kh ki kj kk ij bi translated">非常非常简短的总结:使用访问器来获取对象的状态是可以的，只要不使用结果在对象之外做决定。任何完全基于一个对象的状态的决定都应该在对象本身的“内部”做出。</p><p id="aebd" class="jn jo lf jp b jq jr js jt ju jv jw jx lg jz ka kb lh kd ke kf li kh ki kj kk ij bi translated">对<a class="ae lb" href="https://en.wikipedia.org/wiki/Law_of_Demeter" rel="noopener ugc nofollow" target="_blank">定律</a>的澄清。</p><p id="2533" class="jn jo lf jp b jq jr js jt ju jv jw jx lg jz ka kb lh kd ke kf li kh ki kj kk ij bi translated"><a class="ae lb" href="https://wiki.c2.com/?TellDontAsk" rel="noopener ugc nofollow" target="_blank">https://wiki.c2.com/?TellDontAsk</a></p></blockquote><p id="7395" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">只是澄清一下，如果你在想，我如何用 Java 的 Jackson 库来绘制 JSON？。<br/>答案是使用<strong class="jp ir"> getters </strong>“但那不是你的决定，那是创建杰克逊库的人的决定。不要做出超出你控制范围的决定来决定你代码中的一切。同样的事情也发生在任何其他工具、库或框架上。</p><p id="1d58" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">仅仅因为一个绘制 JSON 的库或一个框架将概念应用到一种没有这个概念的语言中来解决它们的问题，不要将这个决定也移到你的领域代码中。<br/>例如在 Java 中，没有工件来表示 JSON，所以多个库使用类作为一种固定的字典，但是那些不是我们的领域类。那些类是耦合到我们正在使用的库或框架的工件，请不要在你的域内移动它们。</p><p id="8e12" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以 Java 为例，任何框架如 JPA、Hibernate 甚至 Quarkus 或 Springboot 都是如此，请编写一个薄薄的层来使用它们，在那些你需要使用它们的地方。</p><p id="5105" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你不知道如何避免这一点，请看看我以前的帖子，关于六边形架构的<a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/the-whys-of-hexagonal-architecture-1ccca8476c86?sk=8d8e99e381ae473c001fd80c348fa5f8">Why ' s</a>。</p><p id="be2d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">分层架构可以帮助您避免将这些决策传递给代码的其余部分。他们是为了避免被别人的决定蚕食，利用他们。</p><h2 id="798d" class="ll lm iq bd ln lo lp dn lq lr ls dp lt jy lu lv lw kc lx ly lz kg ma mb mc md bi translated">重构</h2><p id="898a" class="pw-post-body-paragraph jn jo iq jp b jq me js jt ju mf jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated">我想强调的是，我并不是说您必须在没有 getters 的情况下从一开始就创建代码。抽象不是一件容易找到的事情，我更倾向于推荐像你通常做的那样编写代码。有些小步骤可以帮助你很容易地发现问题。您可以:</p><ul class=""><li id="29d3" class="mj mk iq jp b jq jr ju jv jy ml kc mm kg mn kk mo mp mq mr bi translated">提取方法用很少的代码行，更少的<a class="ae lb" href="https://en.wikipedia.org/wiki/Cognitive_load" rel="noopener ugc nofollow" target="_blank">认知负荷</a>。</li><li id="5e98" class="mj mk iq jp b jq ms ju mt jy mu kc mv kg mw kk mo mp mq mr bi translated">如果您看到该方法只由您的类使用，并且只使用传递的参数(不要对该类的属性做任何事情)，可能该方法不在正确的类中。</li><li id="afbf" class="mj mk iq jp b jq ms ju mt jy mu kc mv kg mw kk mo mp mq mr bi translated">然后看一下方法，是调用 getters 用参数的值做一个计算吗？。</li><li id="d123" class="mj mk iq jp b jq ms ju mt jy mu kc mv kg mw kk mo mp mq mr bi translated">然后问自己<br/>这个 getter 为什么在这里？<br/>我该怎么做才能去掉它？</li></ul><p id="2e44" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有时候答案就是运用“<strong class="jp ir">告诉不要问”</strong>原则。</p></div></div>    
</body>
</html>