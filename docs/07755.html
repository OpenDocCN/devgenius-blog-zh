<html>
<head>
<title>NodeJS with ExpressJS and TypeScript part 2.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有 ExpressJS 和 TypeScript 的 NodeJS 第 2 部分。</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/nodejs-with-expressjs-and-typescript-part-2-37db5ba9270c?source=collection_archive---------2-----------------------#2022-04-21">https://blog.devgenius.io/nodejs-with-expressjs-and-typescript-part-2-37db5ba9270c?source=collection_archive---------2-----------------------#2022-04-21</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="04ac" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在第二部分中，我们将了解如何增加 nodemon 的开发时间，以便不必每次在我们的服务器中进行更改时都进行编译，因为现在如果我们在代码中进行更改，我们必须中断服务器的执行并重新编译以启动它，然后为了加快速度，我们将使用 nodemon，这是一种工具，它会在每次检测到代码中的更改时自动重新启动服务器，而无需编译。</p><p id="8e31" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">要安装 nodemos，我们必须执行以下命令:</p><pre class="ki kj kk kl gt km kn ko kp aw kq bi"><span id="ebf4" class="kr ks in kn b gy kt ku l kv kw">npm i -D nodemon</span></pre><p id="c9be" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">记住 nodemon 是为了加速开发，所以我们只作为开发依赖项来安装。</p><p id="abd5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在我们有了 nodemon，我们将执行:</p><pre class="ki kj kk kl gt km kn ko kp aw kq bi"><span id="90f8" class="kr ks in kn b gy kt ku l kv kw">nodemon npx ./src/index.ts</span></pre><p id="58dd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这将在不生成生产代码的情况下启动我们的服务器，当我们做出更改时，服务器将自动重启。</p><p id="8917" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当我的服务器启动时，我将更改控制台消息</p><pre class="ki kj kk kl gt km kn ko kp aw kq bi"><span id="2518" class="kr ks in kn b gy kt ku l kv kw">app.listen(8000, () =&gt; {<br/>  console.log('Server on port 8000!');<br/>});</span></pre><p id="3664" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后，我们将看到以下控制台输出:</p><pre class="ki kj kk kl gt km kn ko kp aw kq bi"><span id="8075" class="kr ks in kn b gy kt ku l kv kw">❯ npx nodemon ./src/index.ts<br/>[nodemon] 2.0.15<br/>[nodemon] to restart at any time, enter `rs`<br/>[nodemon] viewing path(s): *.*<br/>[nodemon] seeing extensions: ts,json<br/>[nodemon] starting `ts-node ./src/index.ts`<br/>The application is listening on port 8000!<br/>[nodemon] rebooting due to changes...<br/>[nodemon] starting `ts-node ./src/index.ts`<br/>Server on port 8000!</span></pre><p id="229d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果我们能在发展中走得更快，现在就完成了。</p><p id="1078" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最后，我将在我的 package.json 中创建一个脚本:</p><pre class="ki kj kk kl gt km kn ko kp aw kq bi"><span id="37de" class="kr ks in kn b gy kt ku l kv kw">"hyphens": {<br/>    "build": "npx tsc --project ./",<br/>    "start": "node ./build/index.js",<br/>    "dev": "nodemon ./src/index.ts",<br/>    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"<br/>  },</span></pre><p id="6913" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如你所见，我已经创建了 dev 命令，它只有 nodemon，我们不使用 npx。</p><p id="ff3b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">npx:这个命令允许您在类似于通过 npm run 运行它的上下文中，从 npm 包(无论是本地安装的还是远程获得的)运行任意命令，所以当您在包中创建脚本时。json 不再需要前置 npx。</p><h1 id="e3ea" class="kx ks in bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">查询参数</h1><p id="3ba7" class="pw-post-body-paragraph jk jl in jm b jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh ig bi translated">查询参数是可选的键值对，出现在？在 URL 中。例如，下面的 URL 有两个查询参数，rating 和 page，分别具有值 ASC 和 2:</p><p id="643d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae lz" href="http://example.com/articles?sort=ASC&amp;page=2" rel="noopener ugc nofollow" target="_blank">http://example.com/articles?sort=ASC&amp;page = 2</a></p><p id="f416" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这个 url 中，我们看到有两个查询参数，它们的名称分别是“sort”和“page”。您可以发送许多查询参数，但是它们必须用“&amp;”分隔，并且要用“=”赋值</p><p id="4fb8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">查询参数允许将额外的应用程序状态序列化到 URL 中，否则这些状态将无法放入 URL 路径中。).查询参数的常见用例包括呈现分页集合中的当前页码、筛选条件或排序条件。</p><p id="6194" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在 web 开发中，查询参数在 URL 中使用，如上所述，但是它们也可以在检索数据的 API 请求中使用。Ember 将它们视为两个不同的概念。</p><h1 id="ecbe" class="kx ks in bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">通过查询参数的动态响应</h1><p id="bbf1" class="pw-post-body-paragraph jk jl in jm b jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh ig bi translated">现在我们将看到如何在我们创建的 get 类型的端点中返回由请求的参数发送的字符串。</p><p id="3b91" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">以前我们只返回 hello world，但现在我们将返回用户通过示例查询参数提供给我们的名称:</p><pre class="ki kj kk kl gt km kn ko kp aw kq bi"><span id="cd35" class="kr ks in kn b gy kt ku l kv kw"><a class="ae lz" href="http://localhost:8000?name=jordan" rel="noopener ugc nofollow" target="_blank">http://localhost:8000?name=jordan</a></span></pre><p id="6893" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们的答案应该是:</p><pre class="ki kj kk kl gt km kn ko kp aw kq bi"><span id="e738" class="kr ks in kn b gy kt ku l kv kw">hello jordan</span></pre><p id="4f15" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们看看我们如何能做它。</p><p id="e88a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在我们的端点中，我们有一个回调函数，它接受一个请求(Request)和一个响应(Response)。</p><p id="faa9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们将 req(请求)打印到控制台:</p><pre class="ki kj kk kl gt km kn ko kp aw kq bi"><span id="9e47" class="kr ks in kn b gy kt ku l kv kw">app.get('/', (req: Request, res: Response) =&gt; {<br/>  console.log(req);<br/>  res.send('Hello World');<br/>});</span></pre><p id="0e13" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在让我们用下面的查询参数重新加载我们的服务器页面:</p><pre class="ki kj kk kl gt km kn ko kp aw kq bi"><span id="b122" class="kr ks in kn b gy kt ku l kv kw"><a class="ae lz" href="http://localhost:8000?name=jordan" rel="noopener ugc nofollow" target="_blank">http://localhost:8000?name=jordan</a></span></pre><p id="b9ac" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们看看控制台:</p><pre class="ki kj kk kl gt km kn ko kp aw kq bi"><span id="ce7b" class="kr ks in kn b gy kt ku l kv kw">baseUrl: '',<br/>  originalUrl: '/?name=jordan',<br/>  _parsedUrl: Url {<br/>    protocol: null,<br/>    slashes: null,<br/>    auth: null,<br/>    host: null,<br/>    port: null,<br/>    hostname: null,<br/>    hash: null,<br/>    search: '?name=jordan',<br/>    query: 'name=jordan',<br/>    pathname: '/',<br/>    path: '/?name=jordan',<br/>    href: '/?name=jordan',<br/>    _raw: '/?name=jordan'<br/>  },<br/>  params: {},<br/>  query: { name: 'jordan' },<br/>  res: &lt;ref *3&gt; ServerResponse {<br/>    _events: [Object: null prototype] { finish: [Function: bound resOnFinish] },<br/>    _eventsCount: 1,<br/>    _maxListeners: undefined,<br/>    outputData: [],<br/>    outputSize: 0,</span></pre><p id="ce77" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这只是那个巨大物体的一小部分，但是让我们看看对我们很重要的一部分，因为我们有有价值的信息。</p><p id="481e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如您所见，我们有基本 url，因为它不显示任何内容，我们有 href、原始 url，我们还有查询参数:</p><pre class="ki kj kk kl gt km kn ko kp aw kq bi"><span id="3659" class="kr ks in kn b gy kt ku l kv kw">query: { name: 'jordan' },</span></pre><p id="6a30" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这意味着我们可以通过以下方式访问它:</p><pre class="ki kj kk kl gt km kn ko kp aw kq bi"><span id="7134" class="kr ks in kn b gy kt ku l kv kw">res.query.name</span></pre><p id="eba5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">那么我们已经有了练习的答案，我们只需要验证，因为查询参数是可选的，所以我们将在端点中做一个 if，如下所示:</p><pre class="ki kj kk kl gt km kn ko kp aw kq bi"><span id="2967" class="kr ks in kn b gy kt ku l kv kw">app.get('/', (req: Request, res: Response) =&gt; {<br/>  if (req.query.name) {<br/>    res.send(`Hello ${req.query.name}`);<br/>  } else {<br/>    res.send('Hello guest');<br/>  }<br/>});</span></pre><p id="7c0e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在我们可以用 res.json({message : "message"})在 json 中回答同样的问题</p><p id="706a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了在我们的练习中实现它，应该:</p><pre class="ki kj kk kl gt km kn ko kp aw kq bi"><span id="4893" class="kr ks in kn b gy kt ku l kv kw">app.get('/', (req: Request, res: Response) =&gt; {<br/>  if (req.query.name) {<br/>    // res.send(`Hello ${req.query.name}`); send response type text<br/>    res.json({ message: `Hello ${req.query.name}` }); //send response type json<br/>  } else {<br/>    // res.send('Hello guest'); send response type text<br/>    res.json({ message: 'Hello guest' }); //send response type json<br/>  }<br/>});</span></pre><p id="3f04" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这将做的是，如果你不发送一个名字，它会回复“你好客人”</p><p id="2de7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们看看结果如何:<br/>带有查询参数:</p><figure class="ki kj kk kl gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi ma"><img src="../Images/5411352af1fa44de148ef1eb2c597a31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*b_ngPLY0qQnF_sLg.png"/></div></div></figure><p id="31af" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">不带查询参数:</p><figure class="ki kj kk kl gt mb gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/2253bdfbab394d9593c81e3be3920bf0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/0*922ASwahYYIH6pxA.png"/></div></figure><p id="1a7b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你想知道为什么我回答 json 的时候我的浏览器是这个样子，那是因为这个扩展:<a class="ae lz" href="https://chrome.google.com/webstore/detail/json-viewer/gbmdgpbipfallnflgajpaliibnhdgobh/related?hl=es" rel="noopener ugc nofollow" target="_blank"> json viewer </a></p><h1 id="0a53" class="kx ks in bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">挑战</h1><p id="78d1" class="pw-post-body-paragraph jk jl in jm b jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh ig bi translated">作为一个挑战，我希望你发送更多的属性，并在响应中以 json 的形式发送它们。在评论中留下你的解决方案比看起来要容易得多。</p><p id="3eda" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">记住你不知道用户可以提交什么属性，看到你的回答我很激动。</p><p id="eb55" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在下一篇博客中，我们将看到如何响应用户指定数量的数组，我们还将看到 posts 动词。</p><p id="8705" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，如果您有任何问题或建议，请发表评论。记得迎接挑战，向自己展示你可以。</p><p id="0f2c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你可以从<a class="ae lz" href="https://github.com/jordanrjdev/express-typescript" rel="noopener ugc nofollow" target="_blank">库</a>访问代码。</p></div></div>    
</body>
</html>