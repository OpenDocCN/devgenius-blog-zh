<html>
<head>
<title>5 Best Practices To Get Familiar With Java Generics</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">熟悉 Java 泛型的 5 个最佳实践</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/5-best-practices-to-get-familiar-with-java-generics-25b10e27a3c?source=collection_archive---------1-----------------------#2022-10-06">https://blog.devgenius.io/5-best-practices-to-get-familiar-with-java-generics-25b10e27a3c?source=collection_archive---------1-----------------------#2022-10-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="b4bb" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">软件工程之旅</h2><div class=""/><div class=""><h2 id="e112" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">Java 开发人员的最佳实践</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/4ac5b8149e91e317971485d4f5804b1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*A1nbUBIq-Koq84xu"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">来自 unsplash.com<a class="ae le" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank">的<a class="ae le" href="https://unsplash.com/@ikukevk" rel="noopener ugc nofollow" target="_blank">凯文·Ku</a>的照片</a></figcaption></figure><h1 id="f560" class="lf lg iq bd lh li lj lk ll lm ln lo lp kf lq kg lr ki ls kj lt kl lu km lv lw bi translated">概观</h1><p id="62eb" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">J2SE 5 中引入了 Java 泛型编程来处理类型安全对象。它通过在编译时检测错误使代码稳定。</p><p id="32f6" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">以下是 Java 泛型的一些优点:</p><p id="6440" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">- <strong class="lz ja">类型安全:</strong>我们只能在泛型中保存一种类型的对象。它不允许存储其他对象。</p><p id="bea7" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">- <strong class="lz ja">不需要类型转换:</strong>不需要对对象进行类型转换。</p><p id="bed0" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">- <strong class="lz ja">编译时检查:</strong>它是在编译时检查的，所以在运行时不会出现问题。</p><p id="356c" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">现在，让我们转到最佳实践的细节，通过本文的内容来熟悉 Java 泛型。</p><h1 id="bafe" class="lf lg iq bd lh li lj lk ll lm ln lo lp kf lq kg lr ki ls kj lt kl lu km lv lw bi translated">#1 带接口的泛型</h1><p id="b30e" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">在第一个练习中，我想提到泛型是如何与 Java 中的接口一起工作的。使用带有接口的泛型有助于使我们的代码可读性更好，易于维护，并保持 Java 中的接口原则。</p><p id="bdd3" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">现在我们将通过例子来看看它是如何工作的。</p><p id="56ab" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">首先，我们将定义两个对象 Person 和 Book 如下:</p><p id="fada" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated"><strong class="lz ja">Person.java</strong></p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="1414" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated"><strong class="lz ja">Book.java</strong></p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="ab9b" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">假设我们有两个对象:Person 和 Book，如下所示。我们希望立即处理这些对象的 CRUD(创建、检索、更新、删除)。我将展示在 Java 中使用和不使用泛型的情况下我是如何做到的。</p><p id="9f01" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated"><strong class="lz ja">没有泛型的 PersonCrud】</strong></p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="a4d5" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated"><strong class="lz ja">没有泛型的 BookCrud</strong></p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="4a0d" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated"><strong class="lz ja">主类</strong></p><p id="6073" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">正如你在上面的例子中看到的，当我们想要使用 Person 或 Book 的 CRUD 函数时，我们必须为它的对象创建一个实例。如果我们想改变具体的对象来使用它的 CRUD，这对我们来说是不灵活的。现在，让我们看看泛型和接口在这种情况下是如何帮助我们的。</p><p id="7247" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated"><strong class="lz ja">IGeneric.java</strong></p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="6c27" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated"><strong class="lz ja">PersonCrud.java 与仿制药</strong></p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="d782" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated"><strong class="lz ja">BookCrud.java 与仿制药</strong></p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="65c6" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated"><strong class="lz ja">GenericCrud.java</strong></p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="228f" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated"><strong class="lz ja">主类</strong></p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="88c1" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">你可以在主类中看到，我使用了一个构造函数和 set 函数来轻松地改变我们的具体对象，它可以准确地引用我们想要使用的具体对象的 CRUD。这里的泛型帮助我们轻松地将依赖注入概念应用于对象，在这种情况下，如果没有泛型，情况可能会导致更严重的问题。</p><h1 id="f42a" class="lf lg iq bd lh li lj lk ll lm ln lo lp kf lq kg lr ki ls kj lt kl lu km lv lw bi translated">#2 具有抽象类的泛型</h1><p id="e579" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">与接口类似，Java 中的泛型也可以应用于抽象类。对抽象类使用泛型还有助于使我们的代码可读性更强，易于维护。此外，在抽象类中应用泛型可以帮助我们减少源代码的可重复性。</p><p id="1c6b" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">我们仍然使用 Person 和 Book 对象作为带有 abstract 的示例代码。现在，让我们从 Person 和 Book 的处理类的一些函数(add、remove、addByIndex 和 getAll)开始。下面的例子将展示在没有泛型的情况下它是如何工作的。</p><p id="3443" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated"><strong class="lz ja">HandlingPersonWithoutGenerics.java</strong></p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="0c0a" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">HandlingBookWithoutGenerics.java<strong class="lz ja"/></p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="01f5" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">通过上面的例子，我们可以看到两个处理类之间的属性和方法是相似的。在这种情况下应用泛型将有助于我们减少代码行数，使代码更具可读性。让我们看看我们用这个例子实现了什么。</p><p id="2b8c" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">【AbstractGeneric.java T4】</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="0507" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated"><strong class="lz ja">HandlingPerson.java</strong></p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="48ff" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated"><strong class="lz ja">HandlingBook.java</strong></p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="9a06" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated"><strong class="lz ja">主类</strong></p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="bf8c" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">在 main 类中，我调用了对 Book 和 Person 的处理，这些类中没有任何实现，因为抽象类帮助了我们。在这里应用泛型不仅帮助我们减少 LOC，还帮助我们将一些最佳实践和设计模式应用到我们的代码中。继续阅读下一部分，看看泛型在 Java 中是如何做到的。</p><h1 id="c386" class="lf lg iq bd lh li lj lk ll lm ln lo lp kf lq kg lr ki ls kj lt kl lu km lv lw bi translated">#3 仿制药子类型</h1><p id="e5d4" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">具有泛型的子类型有助于我们在抽象类中使用已知的属性和方法更灵活地应用泛型。让我们用下面的代码浏览一下这个例子，以便更接近这个概念。</p><p id="247e" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">使用 Person 和 Book 类，但是在这种情况下，我们知道这些对象中的每一个都有 identify 字段，因此我们将创建一个包含 id 列的超对象。很快，我们的对象就变成了这样:</p><p id="32ab" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated"><strong class="lz ja">Identifier.java</strong></p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="0be5" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated"><strong class="lz ja">Person.java</strong></p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="cbf3" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated"><strong class="lz ja">Book.java</strong></p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="cfdb" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">我们将再次使用抽象泛型类和处理类。您可以看到，我们可以使用 identify 字段添加更多功能，例如 getMaxId 方法。此外，将子类型与泛型一起使用还有助于我们将依赖注入原则应用于对象的抽象，我们将把它应用于泛型处理类。查看它如何与下面的代码一起工作:</p><p id="64b3" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated"><strong class="lz ja">AbstractGeneric.java</strong></p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="78e7" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated"><strong class="lz ja">HandlingPerson.java</strong></p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="1a42" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated"><strong class="lz ja">HandlingBook.java</strong></p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="3671" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated"><strong class="lz ja">GenericHandling.java</strong></p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="0677" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated"><strong class="lz ja">主类</strong></p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="56cf" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">有了泛型子类型，我们可以更灵活地应用泛型，也可以将一些编程原则、设计模式应用到我们的代码中。这也可以应用于接口，而不是上面的示例代码和方法。</p><h1 id="6b60" class="lf lg iq bd lh li lj lk ll lm ln lo lp kf lq kg lr ki ls kj lt kl lu km lv lw bi translated">#4 泛型方法</h1><p id="586c" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">除了申请接口和抽象类，java 泛型也可以申请方法。对这些方法的应用清楚地向我们展示了泛型的优势，如类型安全和编译时检查。我们也可以通过使用泛型子类型来应用于具有已知属性的对象，如第 3 部分。让我们通过例子来找出:</p><p id="b9d7" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">在这个例子中，我们将使用三个对象:Identify、Book 和 Person 作为第 3 部分。</p><p id="087a" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated"><strong class="lz ja">GenericMethods.java</strong></p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="my mz l"/></div></figure><h1 id="9d87" class="lf lg iq bd lh li lj lk ll lm ln lo lp kf lq kg lr ki ls kj lt kl lu km lv lw bi translated">#5 泛型上限通配符</h1><p id="fae8" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">这一部分可能有点类似于第 3 部分，因为其行为特征非常相似。</p><p id="c17c" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">然而，使用通配符会限制泛型的灵活性，而不是像第 3 部分那样使用子类型。如果您希望代码更短，并且只对已知属性应用函数，您可以使用上限通配符。在示例代码中，我们使用三个对象:Identify、Book 和 Person 作为第 3 部分。现在，请看下面的细节:</p><p id="3a80" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">AbstractGeneric.java<strong class="lz ja"/></p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="9b9e" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated">【HandlingBook.java T4】</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="01bf" class="pw-post-body-paragraph lx ly iq lz b ma mt ka mc md mu kd mf mg mv mi mj mk mw mm mn mo mx mq mr ms ij bi translated"><strong class="lz ja">GenericUpperBoundWildCards.java</strong></p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="my mz l"/></div></figure><h1 id="304f" class="lf lg iq bd lh li lj lk ll lm ln lo lp kf lq kg lr ki ls kj lt kl lu km lv lw bi translated">摘要</h1><p id="eb48" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">在整篇文章中，我向您介绍了使用 Java 泛型的最佳实践。通过使用 Java 泛型还有许多其他方法来处理它，但是我认为通过上面的实践，您可以从您的实际项目需求中得到其他想法。希望这个内容对你有帮助。谢谢大家！</p></div></div>    
</body>
</html>