<html>
<head>
<title>Airflow cross-dag dependency</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">气流跨 dag 依赖性</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/airflow-cross-dag-dependency-b127dd3b69d8?source=collection_archive---------3-----------------------#2022-09-17">https://blog.devgenius.io/airflow-cross-dag-dependency-b127dd3b69d8?source=collection_archive---------3-----------------------#2022-09-17</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/234273c960cbc73df0d9f5e80cb53c9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XJzXnUzybsBZ1dFnzZUcUQ.png"/></div></div></figure><div class=""/><p id="bc87" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">基于其他一些 DAG 的状态启动 DAG 运行</p><p id="1e4c" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">随着数据网格采用的增加，我们看到了数据系统所有权的分散。同时，我们还需要创建数据的整体视图。因此，不同的 Dag 需要知道其他 Dag 的状态，以便生成其他 Dag 的运行。</p><p id="3581" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Airflow 为我们提供了三种创建跨 dag 依赖性的本机方法。</p><blockquote class="kt ku kv"><p id="1d29" class="jv jw kw jx b jy jz ka kb kc kd ke kf kx kh ki kj ky kl km kn kz kp kq kr ks ig bi translated">基于推的— TriggerDagRunOperator <br/>基于拉的— ExternalTaskSensor <br/>跨环境—气流 API (SimpleHttpOperator)</p></blockquote><figure class="lb lc ld le gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi la"><img src="../Images/99c53db51cc8102b0c9ed7b0d3eb15f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E07yWiaE4tTlCzEXAko9fg.png"/></div></div></figure><h1 id="a69d" class="lf lg iy bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">TriggerDagRunOperator</h1><p id="916b" class="pw-post-body-paragraph jv jw iy jx b jy md ka kb kc me ke kf kg mf ki kj kk mg km kn ko mh kq kr ks ig bi translated">该操作符允许您在一个 DAG 中有一个任务，该任务触发在<strong class="jx iz">相同气流环境</strong>中另一个 DAG 的执行。这增加了创建复杂管线的灵活性。</p><p id="7ddf" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">要注意的重要配置</strong></p><blockquote class="kt ku kv"><p id="6acf" class="jv jw kw jx b jy jz ka kb kc kd ke kf kx kh ki kj ky kl km kn kz kp kq kr ks ig bi translated">conf —将数据发送到调用的 DAG <br/> execution_date —可以不同，但通常与调用 DAG <br/> reset_dag_run 保持相同(设置为 True，这允许在同一日期多次运行，重试场景)</p><p id="2155" class="jv jw kw jx b jy jz ka kb kc kd ke kf kx kh ki kj ky kl km kn kz kp kq kr ks ig bi translated">wait_for_completion —如果希望仅在调用的 DAG 完成时触发下行流任务，请将此项设置为 true<br/>allowed _ States—提供对应于成功(成功，跳过)的状态列表<br/> failed_states —提供对应于失败的状态列表<strong class="jx iz"><em class="iy"><br/></em></strong>poke _ interval—如果 wait_for_completion 设置为 true，请将此项设置为合理的值</p></blockquote><p id="c0ef" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在此方法中，我们修改 DAG 并设置此依赖关系。如果我们不能修改现有的 DAG，可能代码库被不同的团队拥有。这并不意味着我们不能在这些 Dag 之间创建依赖关系。我们的下一个方法描述了如何通过改变下游 DAG 而不是上游 DAG 来实现这一点。</p><h1 id="4d3e" class="lf lg iy bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">外部任务传感器</h1><p id="35c8" class="pw-post-body-paragraph jv jw iy jx b jy md ka kb kc me ke kf kg mf ki kj kk mg km kn ko mh kq kr ks ig bi translated">该传感器将查找另一个 DAG/任务过去的执行情况，并根据其状态处理其 DAG 中的下游任务。ExternalSensor 将匹配那些共享相同<strong class="jx iz">瞬间</strong>的外部 Dag。换句话说，两个 Dag 需要具有相同的计划间隔。如果不是这种情况，则需要通过<code class="fe mi mj mk ml b">execution_deta </code>或<code class="fe mi mj mk ml b">execution_date_fn</code>来调整时间表。</p><p id="369d" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">需要注意的重要配置:</strong></p><blockquote class="kt ku kv"><p id="43d6" class="jv jw kw jx b jy jz ka kb kc kd ke kf kx kh ki kj ky kl km kn kz kp kq kr ks ig bi translated">external_task_id—如果您希望 DAG 整体完成，请将此项设置为 none<br/>execution _ delta—可以为下游 DAG 提供不同的计划(而非)<br/> execution_date_fn(如果 DAG 之间的执行日期不同，请设置此项)<br/> check_for_existence —始终将其设置为 True。</p></blockquote><p id="f19c" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">ExternalTaskSensor 将只接收与正在检测的“任务/DAG”相对应的成功或失败状态，而不接收任何输出值。如果我们需要根据任务中计算的值做出决策，我们需要添加<em class="kw">branch pythonooperator。</em></p><p id="dec2" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">上述的<code class="fe mi mj mk ml b">TriggerDagRunOperator</code>和<code class="fe mi mj mk ml b">ExternalTaskSensor</code>方法设计用于在相同的气流环境中使用 Dag。如果我们需要在两个不同的气流安装中运行的 Dag 之间设置这种依赖关系，我们需要使用气流 API。Airflow API 通过 REST 端点公开平台功能。</p><h1 id="80af" class="lf lg iy bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">气流 API</h1><p id="a937" class="pw-post-body-paragraph jv jw iy jx b jy md ka kb kc me ke kf kg mf ki kj kk mg km kn ko mh kq kr ks ig bi translated">我们可以使用 Airflow API(在 Airflow 2.0+版本中稳定)通过向<code class="fe mi mj mk ml b">DAGRuns</code>端点发出 POST 请求来触发 DAG 运行。为此，我们可以利用 SimpleHttpOperator。</p><h2 id="b095" class="mm lg iy bd lh mn mo dn ll mp mq dp lp kg mr ms lt kk mt mu lx ko mv mw mb mx bi translated">SimpleHttpOperator</h2><p id="3aef" class="pw-post-body-paragraph jv jw iy jx b jy md ka kb kc me ke kf kg mf ki kj kk mg km kn ko mh kq kr ks ig bi translated">该操作符用于调用 HTTP 请求并获得响应。</p><p id="1ab3" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">需要注意的重要配置:</strong></p><blockquote class="kt ku kv"><p id="d888" class="jv jw kw jx b jy jz ka kb kc kd ke kf kx kh ki kj ky kl km kn kz kp kq kr ks ig bi translated">endpoint—'/API/v1/DAGs/<dag-id>/Dag runs '<br/>data—可以有 execution_date <br/> http_con_id 这样的关键字的 JSON 不同环境的连接详细信息</dag-id></p></blockquote><p id="cb62" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在上述三种方法中，dag 之间有一种直接耦合。这不是一个理想的解决方案。这个问题也可以从不同的角度来看，其中依赖性解析和 DAG 触发可以从两个系统中抽象到一个集中的系统中。这个中央系统有三个组成部分:</p><ol class=""><li id="feca" class="my mz iy jx b jy jz kc kd kg na kk nb ko nc ks nd ne nf ng bi translated">DependencyRuleEngine —用于注册依赖关系。如果我们在 DAG 文档中提到上游— DAG_ID &amp; TASK_ID，则可以自动执行</li><li id="48f0" class="my mz iy jx b jy nh kc ni kg nj kk nk ko nl ks nd ne nf ng bi translated">DependencyEvaluation:将用 dag 和 dag-task 对的状态进行响应。可以连接到后端的气流数据库来获取这些信息。</li><li id="a5c2" class="my mz iy jx b jy nh kc ni kg nj kk nk ko nl ks nd ne nf ng bi translated">Executor:这将在一个时间表触发给定依赖项的 DAG 执行。(用于回填支撑)</li></ol><p id="0e9e" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对最后一部分的想法持开放态度。</p><p id="6701" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">谢谢！！！</p></div></div>    
</body>
</html>