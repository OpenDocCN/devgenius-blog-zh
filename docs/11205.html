<html>
<head>
<title>Simple Interactive Chess GUI in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 中简单的交互式象棋 GUI</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/simple-interactive-chess-gui-in-python-c6d6569f7b6c?source=collection_archive---------0-----------------------#2022-12-25">https://blog.devgenius.io/simple-interactive-chess-gui-in-python-c6d6569f7b6c?source=collection_archive---------0-----------------------#2022-12-25</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="5206" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">欢迎来到我的 Python 象棋教程系列的第 1 部分！在本教程中，我们将探索如何在 Python 中设置一个交互式 GUI。在第 2 部分中，我们将介绍一个简单的最小最大算法 AI。让我们开始吧！</p><p id="3af2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">第二部分:<a class="ae ki" href="https://medium.com/dev-genius/simple-min-max-chess-ai-in-python-2910a3602641" rel="noopener">https://medium . com/dev-genius/simple-min-max-chess-ai-in-python-2910 a 3602641</a></p><p id="f85f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">第三部:https://link.medium.com/UzqUcdVzbwb</p><p id="c222" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">(另外，如果您只是想获得代码，并运行块 1、块 2 中的复制和粘贴代码以及块 3 中的适当主函数)</p></div><div class="ab cl kj kk hr kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="ig ih ii ij ik"><pre class="kq kr ks kt gt ku kv kw bn kx ky bi"><span id="c493" class="kz la in kv b be lb lc l ld le"># importing required librarys<br/>import pygame<br/>import chess<br/>import math<br/><br/><br/>#initialise display<br/>X = 800<br/>Y = 800<br/>scrn = pygame.display.set_mode((X, Y))<br/>pygame.init()<br/><br/>#basic colours<br/>WHITE = (255, 255, 255)<br/>GREY = (128, 128, 128)<br/>YELLOW = (204, 204, 0)<br/>BLUE = (50, 255, 255)<br/>BLACK = (0, 0, 0)<br/><br/>#initialise chess board<br/>b = chess.Board()<br/><br/>#load piece images<br/>pieces = {'p': pygame.image.load('b_pawn.png').convert(),<br/>          'n': pygame.image.load('b_knight.png').convert(),<br/>          'b': pygame.image.load('b_bishop.png').convert(),<br/>          'r': pygame.image.load('b_rook.png').convert(),<br/>          'q': pygame.image.load('b_queen.png').convert(),<br/>          'k': pygame.image.load('b_king.png').convert(),<br/>          'P': pygame.image.load('w_pawn.png').convert(),<br/>          'N': pygame.image.load('w_knight.png').convert(),<br/>          'B': pygame.image.load('w_bishop.png').convert(),<br/>          'R': pygame.image.load('w_rook.png').convert(),<br/>          'Q': pygame.image.load('w_queen.png').convert(),<br/>          'K': pygame.image.load('w_king.png').convert(),<br/>          <br/>          }</span></pre><p id="3ad7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们的第一个代码块是显示器的初始设置。我们初始化我们的屏幕窗口，Pygame，基本颜色，来自象棋模块的棋盘，并为每个棋子加载我们的图像。</p><p id="e8dc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了简单起见，我们从这篇维基百科文章【https://en.wikipedia.org/wiki/Chess_piece<a class="ae ki" href="https://en.wikipedia.org/wiki/Chess_piece" rel="noopener ugc nofollow" target="_blank"/>中提取了简单的棋子图像，并将其重新缩放至 100x100。这种重新缩放是不必要的，但是它将为显示定义我们的 X 和 Y 变量。作为一个棋盘是 8x8，我们的 X 和 Y 变量分别是 800，800。</p></div><div class="ab cl kj kk hr kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="ig ih ii ij ik"><pre class="kq kr ks kt gt ku kv kw bn kx ky bi"><span id="8b1d" class="kz la in kv b be lb lc l ld le">def update(scrn,board):<br/>    '''<br/>    updates the screen basis the board class<br/>    '''<br/>    <br/>    for i in range(64):<br/>        piece = board.piece_at(i)<br/>        if piece == None:<br/>            pass<br/>        else:<br/>            scrn.blit(pieces[str(piece)],((i%8)*100,700-(i//8)*100))<br/>    <br/>    for i in range(7):<br/>        i=i+1<br/>        pygame.draw.line(scrn,WHITE,(0,i*100),(800,i*100))<br/>        pygame.draw.line(scrn,WHITE,(i*100,0),(i*100,800))<br/><br/>    pygame.display.flip()</span></pre><p id="54c6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们的第二个代码块是我们的更新函数，它将根据<em class="lf">国际象棋的输入更新我们的显示。板</em>类。我们扫描棋盘上的每一个方格，如果找到一个棋子，我们就把它放进去。然后我们简单地在上面画一个网格。看起来是这样的:</p><figure class="kq kr ks kt gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi lg"><img src="../Images/d86654f5b7a4a6fa03055497c743a9df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rDlI0na6k1QQIivI1lGZGA.png"/></div></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk translated">给定国际象棋的初始设置时更新函数。</figcaption></figure></div><div class="ab cl kj kk hr kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="ig ih ii ij ik"><pre class="kq kr ks kt gt ku kv kw bn kx ky bi"><span id="9aba" class="kz la in kv b be lb lc l ld le">def main(BOARD):<br/><br/>    '''<br/>    for human vs human game<br/>    '''<br/>    #make background black<br/>    scrn.fill(BLACK)<br/>    #name window<br/>    pygame.display.set_caption('Chess')<br/>    <br/>    #variable to be used later<br/>    index_moves = []<br/><br/>    status = True<br/>    while (status):<br/>        #update screen<br/>        update(scrn,BOARD)<br/><br/>        for event in pygame.event.get():<br/>     <br/>            # if event object type is QUIT<br/>            # then quitting the pygame<br/>            # and program both.<br/>            if event.type == pygame.QUIT:<br/>                status = False<br/><br/>            # if mouse clicked<br/>            if event.type == pygame.MOUSEBUTTONDOWN:<br/>                #remove previous highlights<br/>                scrn.fill(BLACK)<br/>                #get position of mouse<br/>                pos = pygame.mouse.get_pos()<br/><br/>                #find which square was clicked and index of it<br/>                square = (math.floor(pos[0]/100),math.floor(pos[1]/100))<br/>                index = (7-square[1])*8+(square[0])<br/>                <br/>                # if we are moving a piece<br/>                if index in index_moves: <br/>                    <br/>                    move = moves[index_moves.index(index)]<br/>                    <br/>                    BOARD.push(move)<br/><br/>                    #reset index and moves<br/>                    index=None<br/>                    index_moves = []<br/>                    <br/>                    <br/>                # show possible moves<br/>                else:<br/>                    #check the square that is clicked<br/>                    piece = BOARD.piece_at(index)<br/>                    #if empty pass<br/>                    if piece == None:<br/>                        <br/>                        pass<br/>                    else:<br/>                        <br/>                        #figure out what moves this piece can make<br/>                        all_moves = list(BOARD.legal_moves)<br/>                        moves = []<br/>                        for m in all_moves:<br/>                            if m.from_square == index:<br/>                                <br/>                                moves.append(m)<br/><br/>                                t = m.to_square<br/><br/>                                TX1 = 100*(t%8)<br/>                                TY1 = 100*(7-t//8)<br/><br/>                                <br/>                                #highlight squares it can move to<br/>                                pygame.draw.rect(scrn,BLUE,pygame.Rect(TX1,TY1,100,100),5)<br/>                        <br/>                        index_moves = [a.to_square for a in moves]<br/>     <br/>    # deactivates the pygame library<br/>        if BOARD.outcome() != None:<br/>            print(BOARD.outcome())<br/>            status = False<br/>            print(BOARD)<br/>    pygame.quit()<br/><br/>def main_one_agent(BOARD,agent,agent_color):<br/>    <br/>    '''<br/>    for agent vs human game<br/>    color is True = White agent<br/>    color is False = Black agent<br/>    '''<br/>    <br/>    #make background black<br/>    scrn.fill(BLACK)<br/>    #name window<br/>    pygame.display.set_caption('Chess')<br/>    <br/>    #variable to be used later<br/>    index_moves = []<br/><br/>    status = True<br/>    while (status):<br/>        #update screen<br/>        update(scrn,BOARD)<br/>        <br/>     <br/>        if BOARD.turn==agent_color:<br/>            BOARD.push(agent(BOARD))<br/>            scrn.fill(BLACK)<br/><br/>        else:<br/><br/>            for event in pygame.event.get():<br/>         <br/>                # if event object type is QUIT<br/>                # then quitting the pygame<br/>                # and program both.<br/>                if event.type == pygame.QUIT:<br/>                    status = False<br/><br/>                # if mouse clicked<br/>                if event.type == pygame.MOUSEBUTTONDOWN:<br/>                    #reset previous screen from clicks<br/>                    scrn.fill(BLACK)<br/>                    #get position of mouse<br/>                    pos = pygame.mouse.get_pos()<br/><br/>                    #find which square was clicked and index of it<br/>                    square = (math.floor(pos[0]/100),math.floor(pos[1]/100))<br/>                    index = (7-square[1])*8+(square[0])<br/>                    <br/>                    # if we have already highlighted moves and are making a move<br/>                    if index in index_moves: <br/>                        <br/>                        move = moves[index_moves.index(index)]<br/>                        #print(BOARD)<br/>                        #print(move)<br/>                        BOARD.push(move)<br/>                        index=None<br/>                        index_moves = []<br/>                        <br/>                    # show possible moves<br/>                    else:<br/>                        <br/>                        piece = BOARD.piece_at(index)<br/>                        <br/>                        if piece == None:<br/>                            <br/>                            pass<br/>                        else:<br/><br/>                            all_moves = list(BOARD.legal_moves)<br/>                            moves = []<br/>                            for m in all_moves:<br/>                                if m.from_square == index:<br/>                                    <br/>                                    moves.append(m)<br/><br/>                                    t = m.to_square<br/><br/>                                    TX1 = 100*(t%8)<br/>                                    TY1 = 100*(7-t//8)<br/><br/>                                    <br/>                                    pygame.draw.rect(scrn,BLUE,pygame.Rect(TX1,TY1,100,100),5)<br/>                            #print(moves)<br/>                            index_moves = [a.to_square for a in moves]<br/>     <br/>    # deactivates the pygame library<br/>        if BOARD.outcome() != None:<br/>            print(BOARD.outcome())<br/>            status = False<br/>            print(BOARD)<br/>    pygame.quit()<br/><br/>def main_two_agent(BOARD,agent1,agent_color1,agent2):<br/>    '''<br/>    for agent vs agent game<br/>    <br/>    '''<br/>  <br/>    #make background black<br/>    scrn.fill(BLACK)<br/>    #name window<br/>    pygame.display.set_caption('Chess')<br/>    <br/>    #variable to be used later<br/><br/>    status = True<br/>    while (status):<br/>        #update screen<br/>        update(scrn,BOARD)<br/>        <br/>        if BOARD.turn==agent_color1:<br/>            BOARD.push(agent1(BOARD))<br/><br/>        else:<br/>            BOARD.push(agent2(BOARD))<br/><br/>        scrn.fill(BLACK)<br/>            <br/>        for event in pygame.event.get():<br/>     <br/>            # if event object type is QUIT<br/>            # then quitting the pygame<br/>            # and program both.<br/>            if event.type == pygame.QUIT:<br/>                status = False<br/>     <br/>    # deactivates the pygame library<br/>        if BOARD.outcome() != None:<br/>            print(BOARD.outcome())<br/>            status = False<br/>            print(BOARD)<br/>    pygame.quit()</span></pre><p id="6475" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们最后的代码块是包含 3 个“主”函数的剩余代码块:</p><ul class=""><li id="2ed3" class="ls lt in jm b jn jo jr js jv lu jz lv kd lw kh lx ly lz ma bi translated"><strong class="jm io"> main </strong> =两边都要用鼠标输入</li><li id="092f" class="ls lt in jm b jn mb jr mc jv md jz me kd mf kh lx ly lz ma bi translated"><strong class="jm io"> main_one_agent </strong> =其中一侧用鼠标输入</li><li id="a81d" class="ls lt in jm b jn mb jr mc jv md jz me kd mf kh lx ly lz ma bi translated"><strong class="jm io"> main_two_agent </strong> =双方都被代理控制的情况</li></ul><p id="933c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您现在可能想知道代理函数应该是什么样子。它只是一个接受表单<em class="lf"> chess 的一个输入的函数。棋盘</em>类并输出一个合法棋步形成<em class="lf">棋步。移动</em>类。</p><p id="36cd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这些主要功能中有很多事情正在进行，所以我希望评论能有所帮助(如果没有，给我发消息/评论)。以下是游戏中期显示的一个示例:</p><figure class="kq kr ks kt gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi lg"><img src="../Images/7ae9143df37a232fb9c9302f9cf888ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kGJqzy4cQUvGh5jTlFy9bQ.png"/></div></div></figure><p id="aaf2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最后注意:由于我们使用 python 的象棋模块，所有类型的合法移动都包括在内(阉割，顺便说一句),并有适当的规则。</p></div></div>    
</body>
</html>