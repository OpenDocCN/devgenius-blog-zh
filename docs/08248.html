<html>
<head>
<title>Experimenting Node.js native Fetch API using TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 TypeScript 试验 Node.js 原生提取 API</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/experimenting-node-js-native-fetch-api-using-typescript-c5275f8a7592?source=collection_archive---------1-----------------------#2022-05-30">https://blog.devgenius.io/experimenting-node-js-native-fetch-api-using-typescript-c5275f8a7592?source=collection_archive---------1-----------------------#2022-05-30</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="b0a7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如何使用 TypeScript 使用节点原生 Fetch API？</p><h1 id="c71a" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">介绍</h1><p id="90d7" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">关于<a class="ae ll" href="https://developers.refinitiv.com/" rel="noopener ugc nofollow" target="_blank">路孚特开发者社区</a>的原始文章可从<a class="ae ll" href="https://developers.refinitiv.com/en/article-catalog/article/testing-node-native-fetch-api-with-rdp-tyepscript" rel="noopener ugc nofollow" target="_blank">这里</a>获得。</p><p id="cddc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae ll" href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API" rel="noopener ugc nofollow" target="_blank">获取 API </a>提供了一个使用 Promise 跨网络异步获取资源的接口。Fetch API 被前端 web 开发人员广泛使用了一段时间，但<a class="ae ll" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank"> Node.js </a>只是在 2022 年 2 月 Node 版本 17.5.0 中为后端开发人员添加了这个 API 作为实验性功能。</p><p id="5496" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个示例项目展示了如何使用 Node.js 实验性原生获取 API 和作为示例 HTTP REST APIs 的<a class="ae ll" href="https://developers.refinitiv.com/en/api-catalog/refinitiv-data-platform/refinitiv-data-platform-apis" rel="noopener ugc nofollow" target="_blank">路孚特数据平台(RDP)API</a>。应用程序源代码用<a class="ae ll" href="https://www.typescriptlang.org" rel="noopener ugc nofollow" target="_blank">类型脚本</a>语言实现，然后使用<a class="ae ll" href="https://hub.docker.com/_/node" rel="noopener ugc nofollow" target="_blank">节点 Docker 映像</a>在<a class="ae ll" href="https://www.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker </a>和<a class="ae ll" href="https://code.visualstudio.com/docs/remote/containers" rel="noopener ugc nofollow" target="_blank"> devcontainer </a>等受控环境中运行应用程序。这有助于避免在试验这个特性时搞乱您的本地开发环境。</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi lm"><img src="../Images/7b1943a5f8f50ce29a42e16238881637.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8C2sYHBHG1LR3XTplHMNRg.jpeg"/></div></div></figure><p id="71a7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">注意</strong>:请注意，此演示项目仅用于开发和概念验证。原生获取 API 仍是一项实验性功能(<strong class="jm io">截至 2022 年 5 月</strong>)，不建议用于生产。</p><h1 id="80cc" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">节点本机获取 API 概述</h1><p id="f01c" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">JavaScript <a class="ae ll" href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API" rel="noopener ugc nofollow" target="_blank"> Fetch API </a>是用于执行异步 HTTP 请求的<a class="ae ll" href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest" rel="noopener ugc nofollow" target="_blank"> XMLHttpRequest </a> API 的现代继承者。如今，大多数现代 web 浏览器都支持该 API。它让开发人员使用 JavaScript <a class="ae ll" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="noopener ugc nofollow" target="_blank"> Promise </a>实现 HTTP 请求代码，这比 XMLHttpRequest 的回调地狱要简单得多。示例代码如下:</p><p id="9576" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">获取 API 示例代码:</p><figure class="ln lo lp lq gt lr"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="d86a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">虽然前端 JavaScript web 开发人员自 2015 年以来一直在使用 Fetch API，但该 API 尚未包含在<a class="ae ll" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank"> Node.js </a>运行时环境中。后端 JavaScript 开发人员需要使用其他库，如<a class="ae ll" href="https://www.npmjs.com/package/request" rel="noopener ugc nofollow" target="_blank">弃用的请求模块</a>、<a class="ae ll" href="https://www.npmjs.com/package/postman-request" rel="noopener ugc nofollow" target="_blank"> postman-request </a>、<a class="ae ll" href="https://www.npmjs.com/package/axios" rel="noopener ugc nofollow" target="_blank"> Axios </a>、<a class="ae ll" href="https://www.npmjs.com/package/node-fetch" rel="noopener ugc nofollow" target="_blank"> Node Fetch 模块</a>等，在节点服务器环境下发出带有承诺的 HTTP 请求。</p><p id="4124" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">简介在<a class="ae ll" href="https://nodejs.org/en/blog/release/v17.5.0/" rel="noopener ugc nofollow" target="_blank">节点版本 17.5.0 </a>中，<strong class="jm io">原生获取 API </strong>现在作为<strong class="jm io">实验特性</strong>可用(感谢<a class="ae ll" href="https://undici.nodejs.org/#/" rel="noopener ugc nofollow" target="_blank"> Undici </a>)。默认情况下，<a class="ae ll" href="https://nodejs.org/en/blog/release/v18.0.0/" rel="noopener ugc nofollow" target="_blank">节点版本 18.0.0 </a>也在全局范围内启用这个实验性的获取 API。后端 JavaScript 开发人员不再需要安装额外的类似 fetch 的模块。前端开发人员将熟悉 Node.js 中的服务器端 HTTP 请求代码。</p><p id="828c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">来自<a class="ae ll" href="https://nodejs.org/en/blog/release/v18.0.0/" rel="noopener ugc nofollow" target="_blank">节点官方页面</a>的示例代码:</p><figure class="ln lo lp lq gt lr"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="6f4b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">要运行这个内置 API，您可以运行本机 Fetch 代码，如下例所示:</p><p id="2438" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">节点版本 18.0.0:</p><pre class="ln lo lp lq gt ma mb mc md aw me bi"><span id="2b91" class="mf kj in mb b gy mg mh l mi mj">$&gt; node app.js</span></pre><p id="12d2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">节点版本 17 . 5 . 0–17.9 . x:</p><pre class="ln lo lp lq gt ma mb mc md aw me bi"><span id="37fb" class="mf kj in mb b gy mg mh l mi mj">$&gt; node --experimental-fetch app.js</span></pre><p id="a931" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个示例项目主要关注节点版本 18.0.0。</p><h1 id="9099" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">什么是路孚特数据平台(RDP)API？</h1><p id="edac" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">继续我们的例子 HTTP REST APIs，<a class="ae ll" href="https://developers.refinitiv.com/en/api-catalog/refinitiv-data-platform/refinitiv-data-platform-apis" rel="noopener ugc nofollow" target="_blank">路孚特数据平台(RDP)API</a>。RDP API 通过易于使用的基于 Web 的 API 为开发人员提供各种路孚特数据和内容。</p><p id="b06b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">RDP API 使开发人员能够无缝、全面地访问所有路孚特内容，如历史定价、环境、社会和治理(ESG)、新闻、研究等，并与他们的内容混合，通过单一界面丰富、集成和分发数据，随时随地提供给他们需要的地方。RDP API 交付机制如下:</p><ul class=""><li id="aedd" class="mk ml in jm b jn jo jr js jv mm jz mn kd mo kh mp mq mr ms bi translated">请求—响应:RESTful web 服务(HTTP GET、POST、PUT 或 DELETE)</li><li id="36f3" class="mk ml in jm b jn mt jr mu jv mv jz mw kd mx kh mp mq mr ms bi translated">警报:传递是一种接收订阅的异步更新(警报)的机制。</li><li id="9fa7" class="mk ml in jm b jn mt jr mu jv mv jz mw kd mx kh mp mq mr ms bi translated">批量:交付大量有效负载，如整个场馆的日终定价数据。</li><li id="a27a" class="mk ml in jm b jn mt jr mu jv mv jz mw kd mx kh mp mq mr ms bi translated">流式传输:实时传递消息。</li></ul><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi my"><img src="../Images/09cf443368785969a10af02ec7f658d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YgdBEX9sRbhZAm1UIpkEWA.png"/></div></div></figure><p id="d346" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个示例项目只关注请求-响应:RESTful web 服务交付方法。</p><p id="ce6e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有关路孚特数据平台的更多详细信息，请参见以下 API 资源:</p><ul class=""><li id="0e5a" class="mk ml in jm b jn jo jr js jv mm jz mn kd mo kh mp mq mr ms bi translated"><a class="ae ll" href="https://developers.refinitiv.com/en/api-catalog/refinitiv-data-platform/refinitiv-data-platform-apis/quick-start" rel="noopener ugc nofollow" target="_blank">快速启动</a>页面。</li><li id="9f80" class="mk ml in jm b jn mt jr mu jv mv jz mw kd mx kh mp mq mr ms bi translated"><a class="ae ll" href="https://developers.refinitiv.com/en/api-catalog/refinitiv-data-platform/refinitiv-data-platform-apis/tutorials" rel="noopener ugc nofollow" target="_blank">教程</a>页面。</li><li id="530d" class="mk ml in jm b jn mt jr mu jv mv jz mw kd mx kh mp mq mr ms bi translated"><a class="ae ll" href="https://developers.refinitiv.com/en/api-catalog/refinitiv-data-platform/refinitiv-data-platform-apis/tutorials#introduction-to-the-request-response-api" rel="noopener ugc nofollow" target="_blank">RDP API:请求-响应 API 简介</a>页面。</li><li id="6f34" class="mk ml in jm b jn mt jr mu jv mv jz mw kd mx kh mp mq mr ms bi translated"><a class="ae ll" href="https://developers.refinitiv.com/en/api-catalog/refinitiv-data-platform/refinitiv-data-platform-apis/tutorials#authorization-all-about-tokens" rel="noopener ugc nofollow" target="_blank">RDP API:授权—关于令牌的所有信息</a>页面。</li></ul><h1 id="d5d2" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">应用程序开发细节示例</h1><p id="ebf8" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">示例应用程序源代码分为两个类型脚本文件:</p><ul class=""><li id="ec72" class="mk ml in jm b jn jo jr js jv mm jz mn kd mo kh mp mq mr ms bi translated">主文件<code class="fe mz na nb mb b">rdp_nodefetch.ts</code>:该文件包含应用主和连接逻辑。</li><li id="9034" class="mk ml in jm b jn mt jr mu jv mv jz mw kd mx kh mp mq mr ms bi translated">类型别名文件<code class="fe mz na nb mb b">rdp_types.ts</code>:该文件包含 RDP 授权、新闻和发现符号服务 JSON 消息的所有类型别名。</li></ul><h1 id="2c91" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">RDP API 应用工作流</h1><p id="6cc7" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">路孚特数据平台授权检查基于 OAuth 2.0 规范。应用程序工作流的第一步是从 RDP 身份验证服务获取令牌，这将允许访问受保护的资源，即数据休息 API。</p><p id="0318" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">API 需要以下访问凭据信息:</p><ul class=""><li id="07a2" class="mk ml in jm b jn jo jr js jv mm jz mn kd mo kh mp mq mr ms bi translated">用户名:用户名。</li><li id="6b33" class="mk ml in jm b jn mt jr mu jv mv jz mw kd mx kh mp mq mr ms bi translated">密码:与用户名关联的密码。</li><li id="3f3e" class="mk ml in jm b jn mt jr mu jv mv jz mw kd mx kh mp mq mr ms bi translated">客户端 ID:这也称为<code class="fe mz na nb mb b">AppKey</code>，它是使用 App 密钥生成器生成的。这个唯一标识符是为用户或应用程序定义的，并且被认为是机密的(不在用户之间共享)。client_id 参数可以在请求正文中传递，也可以作为编码为 base64 的“授权”请求头传递。</li></ul><p id="3157" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">接下来，在应用程序从 RDP 身份验证服务收到访问令牌(和授权令牌)后，所有后续的 REST API 调用都将使用这个令牌来获取数据。请在以下资源中找到有关 RDP API 工作流程的更多详细信息:</p><ul class=""><li id="3118" class="mk ml in jm b jn jo jr js jv mm jz mn kd mo kh mp mq mr ms bi translated"><a class="ae ll" href="https://developers.refinitiv.com/en/api-catalog/refinitiv-data-platform/refinitiv-data-platform-apis/tutorials#introduction-to-the-request-response-api" rel="noopener ugc nofollow" target="_blank">RDP API:请求-响应 API 简介</a>页面。</li><li id="8cb4" class="mk ml in jm b jn mt jr mu jv mv jz mw kd mx kh mp mq mr ms bi translated"><a class="ae ll" href="https://developers.refinitiv.com/en/api-catalog/refinitiv-data-platform/refinitiv-data-platform-apis/tutorials#authorization-all-about-tokens" rel="noopener ugc nofollow" target="_blank">RDP API:授权——关于令牌的所有信息</a>页面。</li></ul><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/e29ca2bd3e6886a8f154153c6a9b537b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1348/format:webp/1*a1h5R4AsOYOWXRP6uPs1AQ.png"/></div></figure><h1 id="1615" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">代码类型别名示例</h1><p id="9df3" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">Type Aliases 是<a class="ae ll" href="https://www.typescriptlang.org/docs/handbook/2/objects.html" rel="noopener ugc nofollow" target="_blank"> TypeScript 对象类型</a>的一种，它帮助开发人员在实现时对他们的变量和数据进行类型检查，以避免最终 JavaScript 应用程序中的数据类型错误。</p><p id="636d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个示例项目定义了 RDP API 的 JSON 请求消息(用于身份验证和符号发现服务)的所有类型别名，以及应用程序在<code class="fe mz na nb mb b">rdp_types.ts</code>文件中使用的对象。</p><figure class="ln lo lp lq gt lr"><div class="bz fp l di"><div class="ly lz l"/></div></figure><h1 id="f97a" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">RDP API 认证</h1><h2 id="8bb5" class="mf kj in bd kk nd ne dn ko nf ng dp ks jv nh ni kw jz nj nk la kd nl nm le nn bi translated">RDP API 验证类型别名</h2><p id="5ff7" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">首先，我们在主应用程序<code class="fe mz na nb mb b">rdp_nodefetch.ts</code>文件中导入和创建 API 端点和凭证所需的所有类型、对象和变量。</p><figure class="ln lo lp lq gt lr"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="54aa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">请注意，API 端点和凭证将在运行时通过环境变量分配给应用程序。</p><h2 id="8591" class="mf kj in bd kk nd ne dn ko nf ng dp ks jv nh ni kw jz nj nk la kd nl nm le nn bi translated">使用获取 API 发送身份验证请求</h2><p id="c5d5" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">然后，我们创建一个名为<code class="fe mz na nb mb b">authenRDP</code>的函数，向 RDP 身份验证令牌服务发送登录请求消息。该函数从<code class="fe mz na nb mb b">RDP_AuthToken_Type</code>类型创建 JSON 请求消息，然后通过节点本地获取 API 将其作为 HTTP POST 消息发送到 RDP。</p><figure class="ln lo lp lq gt lr"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="5bf3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一旦身份验证成功，该函数将获得 RDP 身份验证服务响应消息，并将以下 RDP 令牌信息保存在变量中。</p><ul class=""><li id="e194" class="mk ml in jm b jn jo jr js jv mm jz mn kd mo kh mp mq mr ms bi translated"><strong class="jm io"> access_token </strong>:用于调用 REST 数据 API 调用的令牌，如上所述。应用程序必须保留此凭据，以备 RDP API 进一步请求。</li><li id="0b30" class="mk ml in jm b jn mt jr mu jv mv jz mw kd mx kh mp mq mr ms bi translated"><strong class="jm io"> refresh_token </strong>:刷新令牌，用于在到期前获取更新后的访问令牌。应用程序必须保留此凭据以进行访问令牌续订。</li><li id="959a" class="mk ml in jm b jn mt jr mu jv mv jz mw kd mx kh mp mq mr ms bi translated"><strong class="jm io"> expires_in </strong>:访问令牌有效时间，以秒为单位。</li></ul><p id="5f8a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">请注意 Node.js 可能会显示<strong class="jm io">experimental warning:Fetch API 是一个实验性的特性。此功能可能会随时改变</strong>警告消息，因为应用程序当前正在使用实验功能。</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi no"><img src="../Images/b32e233ac463f9571a9031f27f65f497.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RQU1nz4oV5LNDhrRQV8RvQ.png"/></div></div></figure><h2 id="1eab" class="mf kj in bd kk nd ne dn ko nf ng dp ks jv nh ni kw jz nj nk la kd nl nm le nn bi translated">RDP 代币更新</h2><p id="1f6a" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">在会话到期之前，应用程序需要发送刷新授权请求消息来获取新的访问令牌。让我们修改<code class="fe mz na nb mb b">authenRDP()</code>函数来支持刷新授权请求。</p><figure class="ln lo lp lq gt lr"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="41a0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，示例应用程序用一个<code class="fe mz na nb mb b">authenRDP()</code>函数支持 RDP API 的密码授权和刷新授权场景。您可以在下一篇文章中找到关于密码和刷新授权限制的更多详细信息。</p><ul class=""><li id="c7a5" class="mk ml in jm b jn jo jr js jv mm jz mn kd mo kh mp mq mr ms bi translated"><a class="ae ll" href="https://developers.refinitiv.com/en/article-catalog/article/limitations-and-guidelines-for-the-rdp-authentication-service" rel="noopener ugc nofollow" target="_blank">RDP 认证服务的限制和指南</a>文章。</li></ul><p id="2491" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这包括了认证部分。</p><h1 id="37c7" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">请求 RDP 原料药数据</h1><p id="8fff" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">这让我们需要 RDP 原料药的数据。所有后续的 REST API 调用都通过如下所示的<em class="np">授权</em> HTTP 请求消息头使用访问令牌来获取数据。</p><ul class=""><li id="08eb" class="mk ml in jm b jn jo jr js jv mm jz mn kd mo kh mp mq mr ms bi translated">标题:</li><li id="b25b" class="mk ml in jm b jn mt jr mu jv mv jz mw kd mx kh mp mq mr ms bi translated">授权= <code class="fe mz na nb mb b">Bearer &lt;RDP Access Token&gt;</code></li></ul><p id="fa22" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">请注意<code class="fe mz na nb mb b">Bearer</code>和<code class="fe mz na nb mb b">RDP Access Token</code>值之间的间距<em class="np">。</em></p><p id="8c52" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后，应用程序根据感兴趣的服务创建 JSON 消息格式或 URL 查询参数的请求消息，并将其作为 HTTP 请求消息发送给服务端点。开发人员可以从路孚特数据平台的<a class="ae ll" href="https://api.refinitiv.com/" rel="noopener ugc nofollow" target="_blank"> API 游乐场页面</a>获得 RDP API 服务端点、HTTP 操作和参数——这是一个交互式文档网站，开发人员一旦拥有有效的路孚特数据平台帐户就可以访问。</p><p id="ea94" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">此项目涵盖以下 RDP API 服务:</p><ul class=""><li id="78e5" class="mk ml in jm b jn jo jr js jv mm jz mn kd mo kh mp mq mr ms bi translated">在标识符之间导航的发现符号服务<code class="fe mz na nb mb b">/lookup</code>端点。</li><li id="020b" class="mk ml in jm b jn mt jr mu jv mv jz mw kd mx kh mp mq mr ms bi translated">新闻服务<code class="fe mz na nb mb b">/headlines</code>操作。</li></ul><h1 id="7b12" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">RDP API 符号发现服务</h1><h2 id="7007" class="mf kj in bd kk nd ne dn ko nf ng dp ks jv nh ni kw jz nj nk la kd nl nm le nn bi translated">使用获取 API 发送符号系统请求</h2><p id="ac8a" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">本示例使用发现符号系统服务将符号从代码标识符转换为标识符、标识符和。我将首先为符号 JSON 请求消息导入<code class="fe mz na nb mb b">PDP_Symbology_Req_Type</code>类型别名，并在主<code class="fe mz na nb mb b">rdp_nodefetch.ts</code>文件中创建一个名为<code class="fe mz na nb mb b">requestSymbol()</code>的函数。该函数创建 JSON 请求消息，通过节点本地获取 API 将其发送到 RDP，然后以 JSON 消息格式返回响应数据。</p><figure class="ln lo lp lq gt lr"><div class="bz fp l di"><div class="ly lz l"/></div></figure><h2 id="0926" class="mf kj in bd kk nd ne dn ko nf ng dp ks jv nh ni kw jz nj nk la kd nl nm le nn bi translated">显示符号系统数据</h2><p id="6fd3" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">下一步是以可读格式显示输入的符号系统数据。应用程序使用<a class="ae ll" href="https://nodejs.org/docs/latest-v18.x/api/console.html#consoletabletabulardata-properties" rel="noopener ugc nofollow" target="_blank"> console.table() </a>函数以表格格式将数据打印到控制台。</p><p id="9a77" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们首先为名为<code class="fe mz na nb mb b">symbologyTable</code>的符号表对象创建新的类型别名。该对象保存必要的输出数据，这些数据是来自响应 JSON 消息的<code class="fe mz na nb mb b">identifierType</code>、<code class="fe mz na nb mb b">value</code>、<code class="fe mz na nb mb b">name</code>和<code class="fe mz na nb mb b">status</code>字段。</p><figure class="ln lo lp lq gt lr"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="0a8d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最后，我们创建一个<code class="fe mz na nb mb b">displaySymbology()</code>函数来构造<code class="fe mz na nb mb b">symbologyTable</code>对象，然后将它传递给<code class="fe mz na nb mb b">console.table()</code>函数。</p><figure class="ln lo lp lq gt lr"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="dd28" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用<code class="fe mz na nb mb b">symbologyTable</code>对象的<code class="fe mz na nb mb b">console.table()</code>结果如下:</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi nq"><img src="../Images/14d4dfc414394baba6838b0e6d446006.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GVUpIkoUIIRfJFUYaCWMuw.png"/></div></div></figure><p id="9a78" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这包括了符号数据转换部分。</p><h1 id="e1fc" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">RDP 新闻通讯社</h1><h2 id="0b88" class="mf kj in bd kk nd ne dn ko nf ng dp ks jv nh ni kw jz nj nk la kd nl nm le nn bi translated">使用获取 API 发送新闻请求</h2><p id="1fca" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">现在我们来看 RDP 新闻服务代码。让我首先创建一个名为<code class="fe mz na nb mb b">getNewsHeadlines</code>的函数，用本地获取 API 向 RDP 新闻服务发送 HTTP GET 请求消息。一旦该函数接收到来自 RDP 的响应数据，它将以 JSON 消息格式返回该数据。</p><figure class="ln lo lp lq gt lr"><div class="bz fp l di"><div class="ly lz l"/></div></figure><h2 id="2ded" class="mf kj in bd kk nd ne dn ko nf ng dp ks jv nh ni kw jz nj nk la kd nl nm le nn bi translated">显示新闻标题数据</h2><p id="4884" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">转而以可读表格格式显示输入的新闻标题数据。首先，我将为名为<code class="fe mz na nb mb b">newsHeadlinesTable</code>的新闻标题表对象创建新的类型别名。该对象保存来自响应 JSON 消息的必要输出数据，即<code class="fe mz na nb mb b">storyId</code>和<code class="fe mz na nb mb b">title</code>(标题文本)字段。</p><figure class="ln lo lp lq gt lr"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="2db9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最后，我们创建一个<code class="fe mz na nb mb b">displayNewsHeadlines()</code>函数来构造<code class="fe mz na nb mb b">newsHeadlinesTable</code>对象，然后将它传递给<code class="fe mz na nb mb b">console.table()</code>函数。</p><figure class="ln lo lp lq gt lr"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="c6fe" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用<code class="fe mz na nb mb b">newsHeadlineData</code>对象的<code class="fe mz na nb mb b">console.table()</code>结果如下:</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi nr"><img src="../Images/8653e72e383ea5711090486fd502518f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BHAUFhmk5IzKb3gaPIo0mQ.png"/></div></div></figure><p id="cbed" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这涵盖了所有的节点原生 Fetch API 与 RDP HTTP REST API 应用程序开发使用 TypeScript。</p><h1 id="1758" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">先决条件</h1><p id="08f5" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">此演示项目需要以下依赖软件。</p><ol class=""><li id="cdd6" class="mk ml in jm b jn jo jr js jv mm jz mn kd mo kh ns mq mr ms bi translated">RDP 访问凭据。</li><li id="d8f3" class="mk ml in jm b jn mt jr mu jv mv jz mw kd mx kh ns mq mr ms bi translated"><a class="ae ll" href="https://code.visualstudio.com/" rel="noopener ugc nofollow" target="_blank"> Visual Studio 代码</a>编辑器。</li><li id="7247" class="mk ml in jm b jn mt jr mu jv mv jz mw kd mx kh ns mq mr ms bi translated"><a class="ae ll" href="https://docs.docker.com/get-docker/" rel="noopener ugc nofollow" target="_blank"> Docker 桌面/引擎</a>应用。</li><li id="de30" class="mk ml in jm b jn mt jr mu jv mv jz mw kd mx kh ns mq mr ms bi translated"><a class="ae ll" href="https://aka.ms/vscode-remote/download/extension" rel="noopener ugc nofollow" target="_blank"> VS 代码—远程开发扩展包</a></li><li id="713b" class="mk ml in jm b jn mt jr mu jv mv jz mw kd mx kh ns mq mr ms bi translated">互联网连接。</li></ol><p id="7d9e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">请联系您的路孚特代表，以帮助您访问 RDP 帐户和服务。您可以找到关于从租约设置的 RDP 访问凭证的更多详细信息，请参见<a class="ae ll" href="https://developers.refinitiv.com/en/article-catalog/article/getting-start-with-refinitiv-data-platform" rel="noopener ugc nofollow" target="_blank">路孚特数据平台</a>文章的<em class="np">用户 ID </em>部分。</p><h1 id="0a9f" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">如何运行示例</h1><p id="68aa" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">第一步是将示例项目文件夹从<a class="ae ll" href="https://github.com/Refinitiv-API-Samples/Article.RDP.TypeScript.Node.FetchAPI" rel="noopener ugc nofollow" target="_blank"> GitHub 库</a>解压或下载到您选择的目录中，然后按照下面的步骤操作。</p><h1 id="91cc" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">作为 VS 代码 DevContainer 运行</h1><p id="b3b5" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">首先，进入项目的<em class="np">。devcontainer </em>文件夹，并用以下内容创建一个文件名<code class="fe mz na nb mb b">.env.devcontainer</code>。</p><pre class="ln lo lp lq gt ma mb mc md aw me bi"><span id="256f" class="mf kj in mb b gy mg mh l mi mj">RDP_BASE_URL=https://api.refinitiv.com<br/>RDP_AUTH_URL=/auth/oauth2/v1/token<br/>RDP_AUTH_REVOKE_URL=/auth/oauth2/v1/revoke<br/>RDP_SYMBOLOGY_URL=/discovery/symbology/v1/lookup</span><span id="07af" class="mf kj in mb b gy nt mh l mi mj">RDP_USERNAME=&lt;RDP UserName&gt;<br/>RDP_PASSWORD=&lt;RDP Password&gt;<br/>RDP_APP_KEY=&lt;RDP Client_ID&gt;</span></pre><p id="b474" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">接下来，在您的机器上启动 Docker 桌面或 Docker 引擎。</p><p id="5c58" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">进入下一步，安装<a class="ae ll" href="https://aka.ms/vscode-remote/download/extension" rel="noopener ugc nofollow" target="_blank"> VS 代码—远程开发扩展包</a>。</p><p id="9dcf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后用 VS 代码打开项目文件夹，按<code class="fe mz na nb mb b">F1</code>键选择<strong class="jm io"> Remote-Containers:在容器中重新打开</strong>命令。</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi nu"><img src="../Images/b3b5e2fc118e34d794e2eb786e678e24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ooQqyuNAVN5ixEAyESAY0Q.png"/></div></div></figure><p id="3e0a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一旦构建完成，VS 代码自动连接到容器，automatics 为开发人员初始化项目。</p><p id="b63c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，VS 代码已经为 devcontainer 中的 RDP 类型脚本原生获取 API 示例做好了准备。开发人员可以通过按下<code class="fe mz na nb mb b">F5</code>按钮或者从 VS 代码菜单中选择<em class="np">运行</em>然后<em class="np">开始调试</em>选项来构建和运行该示例。</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi nv"><img src="../Images/fddffc568239ed3b711e75bd4fdb4bf2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*35FtwNMZDoTxCz5mS2rL4w.gif"/></div></div></figure><p id="b626" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果您想手动运行 Docker 容器的例子，请遵循<a class="ae ll" href="https://github.com/Refinitiv-API-Samples/Article.RDP.TypeScript.Node.FetchAPI#running-as-a-manual-docker-container" rel="noopener ugc nofollow" target="_blank"> GitHub 仓库</a>上的步骤。</p><h1 id="7d19" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">摘要</h1><p id="5356" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">Node.js 上的原生 Fetch API 的出现对所有开发人员来说都是好消息。这个内置的 API 提高了 JavaScript/TypeScript 开发人员的跨平台熟悉度，他们不再需要对前端(web 浏览器)和后端(Node.js) HTTP 请求代码使用不同的方法。这有助于简化项目并降低管理第三方 HTTP 请求/获取模块的复杂性。</p><p id="a654" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">同时，<a class="ae ll" href="https://developers.refinitiv.com/en/api-catalog/refinitiv-data-platform/refinitiv-data-platform-apis" rel="noopener ugc nofollow" target="_blank">路孚特数据平台(RDP)API</a>通过一个易于使用的基于网络的 API 为开发者提供各种路孚特数据和内容。这些 API 很容易集成到任何支持 HTTP 协议和 JSON 消息格式的应用程序和平台中。</p><p id="3173" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我再次提醒你，这个演示项目旨在开发和概念验证的目的。原生获取 API 仍是一项实验性功能(截至 2022 年 4 月的<strong class="jm io">，不建议<strong class="jm io">用于生产</strong>。</strong></p><h1 id="f4da" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">参考</h1><p id="b160" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">有关详细信息，请查看以下资源:</p><ul class=""><li id="377b" class="mk ml in jm b jn jo jr js jv mm jz mn kd mo kh mp mq mr ms bi translated"><a class="ae ll" href="https://developers.refinitiv.com/en/api-catalog/refinitiv-data-platform/refinitiv-data-platform-apis" rel="noopener ugc nofollow" target="_blank">路孚特开发者社区</a>网站上的路孚特数据平台 API 页面。</li><li id="01d6" class="mk ml in jm b jn mt jr mu jv mv jz mw kd mx kh mp mq mr ms bi translated"><a class="ae ll" href="https://api.refinitiv.com" rel="noopener ugc nofollow" target="_blank">路孚特数据平台 API 游乐场页面</a>。</li><li id="7d12" class="mk ml in jm b jn mt jr mu jv mv jz mw kd mx kh mp mq mr ms bi translated"><a class="ae ll" href="https://developers.refinitiv.com/en/api-catalog/refinitiv-data-platform/refinitiv-data-platform-apis/tutorials#introduction-to-the-request-response-api" rel="noopener ugc nofollow" target="_blank">路孚特数据平台 API:请求-响应 API 简介</a>。</li><li id="d2c6" class="mk ml in jm b jn mt jr mu jv mv jz mw kd mx kh mp mq mr ms bi translated"><a class="ae ll" href="https://developers.refinitiv.com/en/api-catalog/refinitiv-data-platform/refinitiv-data-platform-apis/tutorials#authorization-all-about-tokens" rel="noopener ugc nofollow" target="_blank">路孚特数据平台 API:授权——关于令牌的一切</a>。</li><li id="7a05" class="mk ml in jm b jn mt jr mu jv mv jz mw kd mx kh mp mq mr ms bi translated"><a class="ae ll" href="https://developers.refinitiv.com/en/article-catalog/article/limitations-and-guidelines-for-the-rdp-authentication-service" rel="noopener ugc nofollow" target="_blank">RDP 认证服务的限制和指南</a>文章。</li><li id="dbff" class="mk ml in jm b jn mt jr mu jv mv jz mw kd mx kh mp mq mr ms bi translated"><a class="ae ll" href="https://developers.refinitiv.com/en/article-catalog/article/getting-start-with-refinitiv-data-platform" rel="noopener ugc nofollow" target="_blank">路孚特数据平台入门</a>文章。</li><li id="ec60" class="mk ml in jm b jn mt jr mu jv mv jz mw kd mx kh mp mq mr ms bi translated"><a class="ae ll" href="https://nodejs.org/en/blog/release/v18.0.0/" rel="noopener ugc nofollow" target="_blank">节点版本 18.0.0 </a>页面。</li><li id="d618" class="mk ml in jm b jn mt jr mu jv mv jz mw kd mx kh mp mq mr ms bi translated"><a class="ae ll" href="https://www.typescriptlang.org/docs/handbook/compiler-options.html" rel="noopener ugc nofollow" target="_blank">打字稿 TSC </a>页。</li><li id="f6f5" class="mk ml in jm b jn mt jr mu jv mv jz mw kd mx kh mp mq mr ms bi translated"><a class="ae ll" href="https://www.typescriptlang.org/docs/handbook/intro.html" rel="noopener ugc nofollow" target="_blank">打字手册</a>页。</li><li id="4a20" class="mk ml in jm b jn mt jr mu jv mv jz mw kd mx kh mp mq mr ms bi translated"><a class="ae ll" href="https://blog.logrocket.com/fetch-api-node-js/" rel="noopener ugc nofollow" target="_blank">Fetch API 终于要来 Node.js </a>博文了。</li><li id="ad25" class="mk ml in jm b jn mt jr mu jv mv jz mw kd mx kh mp mq mr ms bi translated"><a class="ae ll" href="https://sdtimes.com/softwaredev/node-js-18-available-with-fetch-api-enabled-by-default/" rel="noopener ugc nofollow" target="_blank"> Node.js 18 默认启用 Fetch API 可用</a>新闻。</li><li id="7ec8" class="mk ml in jm b jn mt jr mu jv mv jz mw kd mx kh mp mq mr ms bi translated"><a class="ae ll" href="https://code.visualstudio.com/docs/remote/containers" rel="noopener ugc nofollow" target="_blank"> VS 代码:在容器内部开发</a>页面。</li><li id="0744" class="mk ml in jm b jn mt jr mu jv mv jz mw kd mx kh mp mq mr ms bi translated"><a class="ae ll" href="https://code.visualstudio.com/docs/remote/containers-tutorial" rel="noopener ugc nofollow" target="_blank"> VS 代码:容器中的远程开发教程</a>页面。</li></ul><p id="3706" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有关路孚特数据平台 API 的任何问题，请使用<a class="ae ll" href="https://community.developers.refinitiv.com/" rel="noopener ugc nofollow" target="_blank">开发者社区 Q &amp; A 页面</a>上的<a class="ae ll" href="https://community.developers.refinitiv.com/spaces/231/index.html" rel="noopener ugc nofollow" target="_blank">RDP API 论坛</a>。</p><h1 id="099f" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">开源代码库</h1><p id="ab33" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated"><a class="ae ll" href="https://github.com/Refinitiv-API-Samples/Article.RDP.TypeScript.Node.FetchAPI" rel="noopener ugc nofollow" target="_blank">路孚特-API-样品/物品。RDP . typescript . node . fetchapi</a></p></div></div>    
</body>
</html>