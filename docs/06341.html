<html>
<head>
<title>How to Build High Performance API Client Using Reactive Feign</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用 Reactive Feign 构建高性能 API 客户端</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-to-build-high-performance-api-client-using-reactive-feign-bae4b5053d12?source=collection_archive---------1-----------------------#2022-01-01">https://blog.devgenius.io/how-to-build-high-performance-api-client-using-reactive-feign-bae4b5053d12?source=collection_archive---------1-----------------------#2022-01-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="eb94" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">反应式伪装的权威指南——客户端选项、日志、拦截器、响应状态、重试策略和单元测试</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/2eff6b0f9a10fb9923bbb9e4844fc34f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-iTRplgD10witX2t"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@rohankrishnann?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">罗汉</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><p id="33d1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Spring Webflux 是一个面向未来的技术堆栈，因为它有效地利用了计算资源并实现了非阻塞 I/O。我在上一篇文章中的<a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/is-spring-webflux-a-myth-4526c2f92413">测试结果证明，在繁重的工作负载下，Spring Webflux 大大优于 Spring Servlet(阻塞技术)。如果你想知道如何构建 Spring Webflux 应用程序，你会发现这篇文章很有用。</a></p><p id="2d0d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，仅仅因为使用 Spring Webflux 并不意味着如果 I/O 进程(如访问数据库和与系统中的外部 API 集成)仍然基于阻塞技术，性能增益就有保证。例如，系统图说明了与第三方 API 服务的典型 API 集成。API 客户机向端点发送一个请求，并保持线程直到收到响应。结果，整个过程被阻塞，直到收到响应。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ls"><img src="../Images/40c65b8f103f7097ef6d63fa3ab10fe3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WlGUu2Y_VvXE5z1jMHV8Yw.png"/></div></div></figure><p id="38e3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">毫无疑问，在端到端流程中应用无阻塞至关重要，这样才能享受到反应式技术的好处。</p><h2 id="27a1" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lf mc md me lj mf mg mh ln mi mj mk ml bi translated">创建 API 客户端的快速方法</h2><p id="6475" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">OpenFeign 是一个流行的 API 客户端开发框架。您需要的是定义 API 客户端的接口，然后框架会神奇地为您处理剩下的事情。</p><p id="43f3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，这是用于外币汇率检索和预订的 API 客户端。只有接口定义。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="be25" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在幕后，框架基于配置生成实现，并将它们注入到您的业务逻辑中。OpenFeign 的使用极大地提高了生产率，实现了快速开发。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mt"><img src="../Images/7cc2d183af1e359d1f3311accd4a49c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/1*hlqr2G2pmUE0u_o4EueoWw.png"/></div></div></figure><h2 id="4979" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lf mc md me lj mf mg mh ln mi mj mk ml bi translated">假装被动的客户</h2><p id="9394" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">尽管 OpenFeign 的使用很普遍，但在撰写本文时，OpenFeign 项目和 Spring Cloud OpenFeign 都不支持响应式客户端。同时，Spring 框架团队推荐了一个开源项目<a class="ae kv" href="https://github.com/Playtika/feign-reactive" rel="noopener ugc nofollow" target="_blank">Fei-reactive</a>，直到 Fei-reactive 客户端作为 Spring 核心项目的一部分得到支持。在本文中，我将向您展示如何使用 feign reactive 框架创建 API 客户端。</p></div><div class="ab cl mu mv hu mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="ij ik il im in"><h1 id="3028" class="nb lu iq bd lv nc nd ne ly nf ng nh mb jw ni jx me jz nj ka mh kc nk kd mk nl bi translated">属国</h1><p id="6827" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">将这个 starter 添加到 maven 依赖项中，它提供了一种方便的方法来包含 feign reactive 所需的所有依赖项。</p><pre class="kg kh ki kj gt nm nn no np aw nq bi"><span id="03a6" class="lt lu iq nn b gy nr ns l nt nu"><strong class="nn ir"><em class="nv">&lt;</em>dependency<em class="nv">&gt;<br/>  &lt;</em>groupId<em class="nv">&gt;</em></strong>com.playtika.reactivefeign<strong class="nn ir"><em class="nv">&lt;/</em>groupId<em class="nv">&gt;<br/>  &lt;</em>artifactId<em class="nv">&gt;</em></strong>feign-reactor-spring-cloud-starter<strong class="nn ir"><em class="nv">&lt;/</em>artifactId<em class="nv">&gt;<br/>  &lt;</em>version<em class="nv">&gt;</em></strong>3.1.5<strong class="nn ir"><em class="nv">&lt;/</em>version<em class="nv">&gt;<br/>  &lt;</em>type<em class="nv">&gt;</em></strong>pom<strong class="nn ir"><em class="nv">&lt;/</em>type<em class="nv">&gt;<br/>&lt;/</em>dependency<em class="nv">&gt;</em></strong></span></pre><h1 id="2ae1" class="nb lu iq bd lv nc nw ne ly nf nx nh mb jw ny jx me jz nz ka mh kc oa kd mk nl bi translated">API 客户端定义</h1><p id="f51f" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">feign reactive 的接口定义和注释的使用类似于 OpenFeign。熟悉 OpenFeign 的开发者可以很快学会 feign reactive。</p><p id="8c6c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">外汇 API 客户端的反应式版本与基于 OpenFeign 的版本完全相同，除了第一个注释是<code class="fe ob oc od nn b">@ReactiveFeignClient</code>而不是<code class="fe ob oc od nn b">@FeignClient</code>。</p><p id="8593" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">API 客户端的系统行为可以通过在配置类中定义相关的 beans 来定制，我们将在下面的小节中详细介绍配置。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><h1 id="e7c3" class="nb lu iq bd lv nc nw ne ly nf nx nh mb jw ny jx me jz nz ka mh kc oa kd mk nl bi translated">Spring WebClient 选项</h1><p id="ec22" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">Reactive Feign 附带了基于 Spring Reactive WebClient 的默认实现。该框架允许我们调整 WebClient 的超时配置。下面的示例配置指定了 2 秒超时</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="5071" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">事实上，Reactive Feign 支持使用 application.yml 进行配置。application.yml 下面的 YAML 也有同样的作用。但是，为了便于维护，强烈建议在 application.yml 和配置类之间收集拆分配置，将所有设置集中在一个配置类中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><h1 id="9ae3" class="nb lu iq bd lv nc nw ne ly nf nx nh mb jw ny jx me jz nz ka mh kc oa kd mk nl bi translated">记录</h1><p id="17cf" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">要记录 API 请求和响应，请使用 configuration 类中的默认 reactive logger 为 Reactive Logger 侦听器定义一个 bean。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="3530" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将 API 客户端的日志记录级别设置为 TRACE</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="03a8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，将为每个请求记录请求和响应，包括头和主体</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><h1 id="539c" class="nb lu iq bd lv nc nw ne ly nf nx nh mb jw ny jx me jz nz ka mh kc oa kd mk nl bi translated">使用拦截器添加 API 密钥头</h1><p id="8483" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">Feign Reactive 允许对 API 请求进行某些定制，比如插入公共请求字段。典型的例子是为 API 键添加一个头。虽然给每个方法添加头很繁琐，但是我们可以使用拦截器使它对 API 调用透明。</p><p id="796f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个 API 客户端在每个方法中都有一个 API 键头</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="546d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不是在每个客户机方法中添加头，而是在配置类中定义拦截器 bean，它自动为所有请求插入 X-API-KEY 头。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><h1 id="de23" class="nb lu iq bd lv nc nw ne ly nf nx nh mb jw ny jx me jz nz ka mh kc oa kd mk nl bi translated">自定义特定响应状态的行为</h1><p id="e2ca" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">每当遇到否定响应时，无论是客户端拒绝、服务器错误还是 404，feign 客户端都会抛出一个 feign 异常。</p><p id="0723" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以改变特定响应状态的行为。这个例子配置了<code class="fe ob oc od nn b">ReactiveStatusHandler</code>,如果遇到服务器错误 500，客户端抛出<code class="fe ob oc od nn b">RetryableException</code>,客户端将重试操作。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><h1 id="4278" class="nb lu iq bd lv nc nw ne ly nf nx nh mb jw ny jx me jz nz ka mh kc oa kd mk nl bi translated">重试策略</h1><p id="3f55" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">在出现超时等错误的情况下，我们可以指示假装的客户端自动重试请求。下面的示例代码将最大重试次数设置为 3，每次重试间隔为 2 秒。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><h1 id="d0a4" class="nb lu iq bd lv nc nw ne ly nf nx nh mb jw ny jx me jz nz ka mh kc oa kd mk nl bi translated">虚拟客户端的单元测试</h1><p id="60cb" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">可以使用 WireMock 作为存根 API 服务器来测试 Feign client。下面的示例代码将 WireMock 服务器作为静态类对象启动，然后将 WireMock 服务器的 url 注入到系统属性中。随着系统属性的更新，feign 客户机连接到存根 API 服务器。</p><p id="9d9d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">单元测试很简单，它定义存根 API，调用 feign 客户端，然后进行结果验证。</p><p id="9b14" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/how-to-test-spring-boot-microservice-independently-using-wiremock-d269d20fa626">如果你想了解更多关于 WireMock 的信息，这篇文章</a>是一个很好的参考</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><h1 id="03ba" class="nb lu iq bd lv nc nw ne ly nf nx nh mb jw ny jx me jz nz ka mh kc oa kd mk nl bi translated">验证请求重试次数</h1><p id="3bf1" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">要模拟故障并验证 feign 客户端的重试能力有点棘手。幸运的是，WireMock 支持带有预定义延迟的响应，用于模拟超时和有状态行为。</p><p id="9fd0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为第一次尝试和第二次尝试创建一个固定延迟为 30 秒的慢速 API 存根。然后，设置存根以快速响应第三次尝试。假设虚拟客户端遇到超时，第二次重试应该正在进行。</p><p id="94c5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面的示例代码展示了如何创建具有有状态行为的 WireMock 存根</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure></div><div class="ab cl mu mv hu mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="ij ik il im in"><h1 id="11b6" class="nb lu iq bd lv nc nd ne ly nf ng nh mb jw ni jx me jz nj ka mh kc nk kd mk nl bi translated">结论</h1><p id="cfc2" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">如果 I/O 进程仍然基于阻塞技术，Spring Webflux 对性能提升没有贡献。Reactive Feign 是实现非阻塞 API 客户端的最佳选择。它是 OpenFeign 的一个反应式版本，支持创建 API 客户端，而无需编写实现代码。只需定义接口和配置，就可以毫不费力地开发 API 客户端。</p><p id="a551" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">参考这个<a class="ae kv" href="https://github.com/gavinklfong/spring-investment-platform" rel="noopener ugc nofollow" target="_blank"> GitHub 项目</a>获取样例 Forex API 客户端的源代码</p></div></div>    
</body>
</html>