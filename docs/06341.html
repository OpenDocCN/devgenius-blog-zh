<html>
<head>
<title>How to Build High Performance API Client Using Reactive Feign</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Reactive Feign构建高性能API客户端</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-to-build-high-performance-api-client-using-reactive-feign-bae4b5053d12?source=collection_archive---------1-----------------------#2022-01-01">https://blog.devgenius.io/how-to-build-high-performance-api-client-using-reactive-feign-bae4b5053d12?source=collection_archive---------1-----------------------#2022-01-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="eb94" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">反应式伪装的权威指南——客户端选项、日志、拦截器、响应状态、重试策略和单元测试</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/2eff6b0f9a10fb9923bbb9e4844fc34f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-iTRplgD10witX2t"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@rohankrishnann?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">罗汉</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><p id="33d1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Spring Webflux是一个面向未来的技术堆栈，因为它有效地利用了计算资源并实现了非阻塞I/O。我在上一篇文章中的<a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/is-spring-webflux-a-myth-4526c2f92413">测试结果证明，在繁重的工作负载下，Spring Webflux大大优于Spring Servlet(阻塞技术)。如果你想知道如何构建Spring Webflux应用程序，你会发现这篇文章很有用。</a></p><p id="2d0d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，仅仅因为使用Spring Webflux并不意味着如果I/O进程(如访问数据库和与系统中的外部API集成)仍然基于阻塞技术，性能增益就有保证。例如，系统图说明了与第三方API服务的典型API集成。API客户机向端点发送一个请求，并保持线程直到收到响应。结果，整个过程被阻塞，直到收到响应。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ls"><img src="../Images/40c65b8f103f7097ef6d63fa3ab10fe3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WlGUu2Y_VvXE5z1jMHV8Yw.png"/></div></div></figure><p id="38e3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">毫无疑问，在端到端流程中应用无阻塞至关重要，这样才能享受到反应式技术的好处。</p><h2 id="27a1" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lf mc md me lj mf mg mh ln mi mj mk ml bi translated">创建API客户端的快速方法</h2><p id="6475" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">OpenFeign 是一个流行的API客户端开发框架。您需要的是定义API客户端的接口，然后框架会神奇地为您处理剩下的事情。</p><p id="43f3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，这是用于外币汇率检索和预订的API客户端。只有接口定义。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="be25" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在幕后，框架基于配置生成实现，并将它们注入到您的业务逻辑中。OpenFeign的使用极大地提高了生产率，实现了快速开发。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mt"><img src="../Images/7cc2d183af1e359d1f3311accd4a49c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/1*hlqr2G2pmUE0u_o4EueoWw.png"/></div></div></figure><h2 id="4979" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lf mc md me lj mf mg mh ln mi mj mk ml bi translated">假装被动的客户</h2><p id="9394" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">尽管OpenFeign的使用很普遍，但在撰写本文时，OpenFeign项目和Spring Cloud OpenFeign都不支持响应式客户端。同时，Spring框架团队推荐了一个开源项目<a class="ae kv" href="https://github.com/Playtika/feign-reactive" rel="noopener ugc nofollow" target="_blank">Fei-reactive</a>，直到Fei-reactive客户端作为Spring核心项目的一部分得到支持。在本文中，我将向您展示如何使用feign reactive框架创建API客户端。</p></div><div class="ab cl mu mv hu mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="ij ik il im in"><h1 id="3028" class="nb lu iq bd lv nc nd ne ly nf ng nh mb jw ni jx me jz nj ka mh kc nk kd mk nl bi translated">属国</h1><p id="6827" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">将这个starter添加到maven依赖项中，它提供了一种方便的方法来包含feign reactive所需的所有依赖项。</p><pre class="kg kh ki kj gt nm nn no np aw nq bi"><span id="03a6" class="lt lu iq nn b gy nr ns l nt nu"><strong class="nn ir"><em class="nv">&lt;</em>dependency<em class="nv">&gt;<br/>  &lt;</em>groupId<em class="nv">&gt;</em></strong>com.playtika.reactivefeign<strong class="nn ir"><em class="nv">&lt;/</em>groupId<em class="nv">&gt;<br/>  &lt;</em>artifactId<em class="nv">&gt;</em></strong>feign-reactor-spring-cloud-starter<strong class="nn ir"><em class="nv">&lt;/</em>artifactId<em class="nv">&gt;<br/>  &lt;</em>version<em class="nv">&gt;</em></strong>3.1.5<strong class="nn ir"><em class="nv">&lt;/</em>version<em class="nv">&gt;<br/>  &lt;</em>type<em class="nv">&gt;</em></strong>pom<strong class="nn ir"><em class="nv">&lt;/</em>type<em class="nv">&gt;<br/>&lt;/</em>dependency<em class="nv">&gt;</em></strong></span></pre><h1 id="2ae1" class="nb lu iq bd lv nc nw ne ly nf nx nh mb jw ny jx me jz nz ka mh kc oa kd mk nl bi translated">API客户端定义</h1><p id="f51f" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">feign reactive的接口定义和注释的使用类似于OpenFeign。熟悉OpenFeign的开发者可以很快学会feign reactive。</p><p id="8c6c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">外汇API客户端的反应式版本与基于OpenFeign的版本完全相同，除了第一个注释是<code class="fe ob oc od nn b">@ReactiveFeignClient</code>而不是<code class="fe ob oc od nn b">@FeignClient</code>。</p><p id="8593" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">API客户端的系统行为可以通过在配置类中定义相关的beans来定制，我们将在下面的小节中详细介绍配置。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><h1 id="e7c3" class="nb lu iq bd lv nc nw ne ly nf nx nh mb jw ny jx me jz nz ka mh kc oa kd mk nl bi translated">Spring WebClient选项</h1><p id="ec22" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">Reactive Feign附带了基于Spring Reactive WebClient的默认实现。该框架允许我们调整WebClient的超时配置。下面的示例配置指定了2秒超时</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="5071" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">事实上，Reactive Feign支持使用application.yml进行配置。application.yml下面的YAML也有同样的作用。但是，为了便于维护，强烈建议在application.yml和配置类之间收集拆分配置，将所有设置集中在一个配置类中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><h1 id="9ae3" class="nb lu iq bd lv nc nw ne ly nf nx nh mb jw ny jx me jz nz ka mh kc oa kd mk nl bi translated">记录</h1><p id="17cf" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">要记录API请求和响应，请使用configuration类中的默认reactive logger为Reactive Logger侦听器定义一个bean。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="3530" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将API客户端的日志记录级别设置为TRACE</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="03a8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，将为每个请求记录请求和响应，包括头和主体</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><h1 id="539c" class="nb lu iq bd lv nc nw ne ly nf nx nh mb jw ny jx me jz nz ka mh kc oa kd mk nl bi translated">使用拦截器添加API密钥头</h1><p id="8483" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">Feign Reactive允许对API请求进行某些定制，比如插入公共请求字段。典型的例子是为API键添加一个头。虽然给每个方法添加头很繁琐，但是我们可以使用拦截器使它对API调用透明。</p><p id="796f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个API客户端在每个方法中都有一个API键头</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="546d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不是在每个客户机方法中添加头，而是在配置类中定义拦截器bean，它自动为所有请求插入X-API-KEY头。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><h1 id="de23" class="nb lu iq bd lv nc nw ne ly nf nx nh mb jw ny jx me jz nz ka mh kc oa kd mk nl bi translated">自定义特定响应状态的行为</h1><p id="e2ca" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">每当遇到否定响应时，无论是客户端拒绝、服务器错误还是404，feign客户端都会抛出一个feign异常。</p><p id="0723" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以改变特定响应状态的行为。这个例子配置了<code class="fe ob oc od nn b">ReactiveStatusHandler</code>,如果遇到服务器错误500，客户端抛出<code class="fe ob oc od nn b">RetryableException</code>,客户端将重试操作。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><h1 id="4278" class="nb lu iq bd lv nc nw ne ly nf nx nh mb jw ny jx me jz nz ka mh kc oa kd mk nl bi translated">重试策略</h1><p id="3f55" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">在出现超时等错误的情况下，我们可以指示假装的客户端自动重试请求。下面的示例代码将最大重试次数设置为3，每次重试间隔为2秒。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><h1 id="d0a4" class="nb lu iq bd lv nc nw ne ly nf nx nh mb jw ny jx me jz nz ka mh kc oa kd mk nl bi translated">虚拟客户端的单元测试</h1><p id="60cb" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">可以使用WireMock作为存根API服务器来测试Feign client。下面的示例代码将WireMock服务器作为静态类对象启动，然后将WireMock服务器的url注入到系统属性中。随着系统属性的更新，feign客户机连接到存根API服务器。</p><p id="9d9d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">单元测试很简单，它定义存根API，调用feign客户端，然后进行结果验证。</p><p id="9b14" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/how-to-test-spring-boot-microservice-independently-using-wiremock-d269d20fa626">如果你想了解更多关于WireMock的信息，这篇文章</a>是一个很好的参考</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><h1 id="03ba" class="nb lu iq bd lv nc nw ne ly nf nx nh mb jw ny jx me jz nz ka mh kc oa kd mk nl bi translated">验证请求重试次数</h1><p id="3bf1" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">要模拟故障并验证feign客户端的重试能力有点棘手。幸运的是，WireMock支持带有预定义延迟的响应，用于模拟超时和有状态行为。</p><p id="9fd0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为第一次尝试和第二次尝试创建一个固定延迟为30秒的慢速API存根。然后，设置存根以快速响应第三次尝试。假设虚拟客户端遇到超时，第二次重试应该正在进行。</p><p id="94c5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面的示例代码展示了如何创建具有有状态行为的WireMock存根</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure></div><div class="ab cl mu mv hu mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="ij ik il im in"><h1 id="11b6" class="nb lu iq bd lv nc nd ne ly nf ng nh mb jw ni jx me jz nj ka mh kc nk kd mk nl bi translated">结论</h1><p id="cfc2" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">如果I/O进程仍然基于阻塞技术，Spring Webflux对性能提升没有贡献。Reactive Feign是实现非阻塞API客户端的最佳选择。它是OpenFeign的一个反应式版本，支持创建API客户端，而无需编写实现代码。只需定义接口和配置，就可以毫不费力地开发API客户端。</p><p id="a551" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">参考这个<a class="ae kv" href="https://github.com/gavinklfong/spring-investment-platform" rel="noopener ugc nofollow" target="_blank"> GitHub项目</a>获取样例Forex API客户端的源代码</p></div></div>    
</body>
</html>