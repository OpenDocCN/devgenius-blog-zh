<html>
<head>
<title>Chatbot Driven Development</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">聊天机器人驱动的开发</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/chatbot-driven-development-fbb4392ff5b4?source=collection_archive---------10-----------------------#2022-12-06">https://blog.devgenius.io/chatbot-driven-development-fbb4392ff5b4?source=collection_archive---------10-----------------------#2022-12-06</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="8268" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">用 OpenAI 的 ChatGPT 分享我的编码实验</h2></div><p id="c2f0" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi ky translated">你可能听说过<a class="ae lh" href="https://openai.com/blog/chatgpt/" rel="noopener ugc nofollow" target="_blank"> ChatGPT </a>，它自发布以来人气飙升，已经<a class="ae lh" href="https://twitter.com/sama/status/1599668808285028353?s=20&amp;t=i1HtKPGeYadE397wB6bX9Q" rel="noopener ugc nofollow" target="_blank">突破一百万用户</a>。人们用这个工具做一些绝对令人惊讶的事情，比如在里面建一个<a class="ae lh" href="https://twitter.com/317070/status/1599152176344928256?s=20&amp;t=yW4LjC4-7IY8RyiQ_FYtaA" rel="noopener ugc nofollow" target="_blank">虚拟机</a>或者<a class="ae lh" href="https://www.theguardian.com/technology/2022/dec/04/ai-bot-chatgpt-stuns-academics-with-essay-writing-skills-and-usability" rel="noopener ugc nofollow" target="_blank">写学术论文</a>。</p><p id="9fd7" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我也不能错过尝试的机会。目前，我正在学习 Rust 编程语言(而且觉得很神奇！)，并构建小项目来实践。如果我用人工智能助手来促进我的学习会怎么样？我们已经有了像<a class="ae lh" href="https://github.com/features/copilot" rel="noopener ugc nofollow" target="_blank"> Copilot </a>或<a class="ae lh" href="https://blog.replit.com/ai" rel="noopener ugc nofollow" target="_blank"> Ghostwriter </a>这样的专用工具来帮助编写代码。但是也许有可能更进一步，用一个通用的聊天机器人来构建软件，它可以给我们反馈并帮助我们改进。</p><p id="3e9a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">事实上，使用自然语言来构建代码并不是一个新的想法。OpenAI 之前发布了一个<a class="ae lh" href="https://beta.openai.com/codex-javascript-sandbox" rel="noopener ugc nofollow" target="_blank"> JavaScript playground </a>，允许用户使用文本命令构建 web 应用。然而，由于使用了大型语言模型，ChatGPT 并不局限于任何特定的编程语言，而且功能更加强大。</p><p id="02b6" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这篇文章中，我将分享我使用 ChatGPT 构建一个简单的 Rust HTTP 客户端的经验，该客户端向…一个 OpenAI 模型发送请求！这是一个非常基本的概念验证，甚至不是一个 MVP。但是它应该让您对 ChatGPT 的能力有所了解。我们开始吧！</p><blockquote class="li lj lk"><p id="f48e" class="kc kd ll ke b kf kg jo kh ki kj jr kk lm km kn ko ln kq kr ks lo ku kv kw kx ig bi translated">在这里你可以找到这篇文章中创建的代码。</p></blockquote><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi lp"><img src="../Images/a25be1ce439c2f1fe0fd0d91884ffe2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iKmYrnJM14w2yDu39z8FGw.png"/></div></div><figcaption class="mb mc gj gh gi md me bd b be z dk translated">我情不自禁地为这篇文章生成了一张封面图片，并且使用了<a class="ae lh" href="https://openai.com/dall-e-2/" rel="noopener ugc nofollow" target="_blank"> OpenAI 模型</a>。</figcaption></figure><h1 id="36a3" class="mf mg in bd mh mi mj mk ml mm mn mo mp jt mq ju mr jw ms jx mt jz mu ka mv mw bi translated">0.介绍</h1><p id="33e9" class="pw-post-body-paragraph kc kd in ke b kf mx jo kh ki my jr kk kl mz kn ko kp na kr ks kt nb kv kw kx ig bi translated">我使用以下格式规则来组织文章。</p><ul class=""><li id="c7b2" class="nc nd in ke b kf kg ki kj kl ne kp nf kt ng kx nh ni nj nk bi translated">我发布到聊天室的所有文本片段都以<strong class="ke io"> <em class="ll">我开始。</em> </strong></li><li id="3ce9" class="nc nd in ke b kf nl ki nm kl nn kp no kt np kx nh ni nj nk bi translated">在某些情况下，我不仅写了纯文本，还写了小代码片段来引导对话。在这种情况下，我用降价式的三个反勾号将代码段包装起来。</li><li id="02a1" class="nc nd in ke b kf nl ki nm kl nn kp no kt np kx nh ni nj nk bi translated">从模型接收的响应以<strong class="ke io"> <em class="ll"> ChatGPT </em> </strong>开始。</li><li id="d638" class="nc nd in ke b kf nl ki nm kl nn kp no kt np kx nh ni nj nk bi translated">在某些(大多数)情况下，这些回答被编辑以排除用简单英语写的过于冗长的片段或缩短重复的片段，并且只保留最相关的部分。</li><li id="9885" class="nc nd in ke b kf nl ki nm kl nn kp no kt np kx nh ni nj nk bi translated">我和 GPT 的信息都是用斜体字写的。文本的其余部分以普通字体书写(就像这个介绍一样),以包含附加的注释。</li><li id="d1e0" class="nc nd in ke b kf nl ki nm kl nn kp no kt np kx nh ni nj nk bi translated">在某些地方，我使用<code class="fe nq nr ns nt b">[sentenses in square brackets]</code>来添加“内嵌”评论，也就是说，它不是来自聊天的一字不差的消息。</li><li id="a2f0" class="nc nd in ke b kf nl ki nm kl nn kp no kt np kx nh ni nj nk bi translated">最后，当我使用聊天机器人时，它不是很稳定，所以，我不得不从头开始对话几次，或者使用之前创建的片段重新生成答案。</li></ul><h1 id="b694" class="mf mg in bd mh mi mj mk ml mm mn mo mp jt mq ju mr jw ms jx mt jz mu ka mv mw bi translated">I .编写 API 客户端</h1><p id="e9ed" class="pw-post-body-paragraph kc kd in ke b kf mx jo kh ki my jr kk kl mz kn ko kp na kr ks kt nb kv kw kx ig bi translated"><strong class="ke io"> <em class="ll">我:</em> </strong> <em class="ll">我需要你帮我写一个 Rust 程序。参见要求:</em></p><ol class=""><li id="1b30" class="nc nd in ke b kf kg ki kj kl ne kp nf kt ng kx nu ni nj nk bi translated">该程序是一个简单的 CLI 客户端，用于打开基于 AI GPT 的模型。</li><li id="2f05" class="nc nd in ke b kf nl ki nm kl nn kp no kt np kx nu ni nj nk bi translated"><em class="ll">程序将一个字符串作为提示，向 API 发出请求。</em></li><li id="7e33" class="nc nd in ke b kf nl ki nm kl nn kp no kt np kx nu ni nj nk bi translated"><em class="ll">它从 env 变量或。env 文件(如果存在)。</em></li><li id="ff6d" class="nc nd in ke b kf nl ki nm kl nn kp no kt np kx nu ni nj nk bi translated"><em class="ll">如果没有提供 API 密钥/令牌，它会要求验证。</em></li><li id="ff23" class="nc nd in ke b kf nl ki nm kl nn kp no kt np kx nu ni nj nk bi translated">程序可以使用任何你认为有助于达到要求结果的板条箱。</li></ol><p id="6c12" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io"> <em class="ll"> ChatGPT: </em> </strong> <code class="fe nq nr ns nt b">[phrases in plain English are omitted]</code></p><pre class="lq lr ls lt gt nv nt nw bn nx ny bi"><span id="43f1" class="nz mg in nt b be oa ob l oc od">use std::env;<br/><br/>// Import the OpenAI API client crate<br/>use openai::Client;<br/><br/>// Read the API credentials from environment variables<br/>let api_key = env::var("OPENAI_API_KEY").expect("OPENAI_API_KEY must be set");<br/><br/>// Create a new client with the API key<br/>let client = Client::new(api_key);<br/><br/>// Prompt the user for input<br/>println!("Enter a prompt:");<br/>let mut prompt = String::new();<br/>stdin().read_line(&amp;mut prompt)?;<br/><br/>// Use the client to make a request to the API<br/>let response = client.completions(prompt, None, None, None)?;<br/><br/>// Print the response<br/>println!("{:?}", response);</span></pre><p id="e9a0" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io"> <em class="ll">我:</em> </strong> <em class="ll">好吧，就说我没有</em> <code class="fe nq nr ns nt b"><em class="ll">openai</em></code> <em class="ll">板条箱吧。为我写一个简单的实现，用</em> <code class="fe nq nr ns nt b"><em class="ll">reqwest</em></code> <em class="ll">板条箱代替。</em></p><p id="1298" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io"><em class="ll">ChatGPT:</em></strong>T4】</p><pre class="lq lr ls lt gt nv nt nw bn nx ny bi"><span id="7be3" class="nz mg in nt b be oa ob l oc od">use std::env;<br/><br/>// Import the reqwest crate<br/>use reqwest;<br/><br/>// Read the API credentials from environment variables<br/>let api_key = env::var("OPENAI_API_KEY").expect("OPENAI_API_KEY must be set");<br/><br/>// Prompt the user for input<br/>println!("Enter a prompt:");<br/>let mut prompt = String::new();<br/>stdin().read_line(&amp;mut prompt)?;<br/><br/>// Build the request URL with the prompt and API key<br/>let url = format!("https://api.openai.com/v1/completions/models/davinci/versions/1?prompt={}&amp;api_key={}", prompt, api_key);<br/><br/>// Send the request and parse the JSON response<br/>let response: serde_json::Value = reqwest::get(url)?.json()?;<br/><br/>// Print the response<br/>println!("{:?}", response);</span></pre><p id="a39e" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io"> <em class="ll"> Me: </em> </strong> <em class="ll">请将创建好的线条隐藏在专用客户端对象后面。它可能看起来如下:</em></p><pre class="lq lr ls lt gt nv nt nw bn nx ny bi"><span id="1513" class="nz mg in nt b be oa ob l oc od">pub struct Client {<br/>    /// add any fields you deem necessary<br/>}<br/>impl Client {<br/>    pub fn authenticate(&amp;mut self) {<br/>        /// does API authentication if not authenticated yet<br/>    }<br/>    pub fn prompt(&amp;self, message: &amp;String) -&gt; OpenAIResult {<br/>        /// implement the request and return result as a dedicated result structure<br/>    }<br/>    /// any other methods you might need<br/>}</span></pre><p id="76a8" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io"> <em class="ll"> ChatGPT: </em> </strong></p><pre class="lq lr ls lt gt nv nt nw bn nx ny bi"><span id="3835" class="nz mg in nt b be oa ob l oc od">use std::env;<br/>use std::error::Error;<br/><br/>// Import the reqwest crate<br/>use reqwest;<br/><br/>// Import the serde_json crate<br/>use serde_json;<br/><br/>// Define a result type for the API response<br/>type OpenAIResult = Result&lt;serde_json::Value, Box&lt;dyn Error&gt;&gt;;<br/><br/>// Define the Client struct<br/>pub struct Client {<br/>    api_key: String,<br/>    authenticated: bool,<br/>}<br/><br/>impl Client {<br/>    // Implement the authenticate method<br/>    pub fn authenticate(&amp;mut self) {<br/>        if !self.authenticated {<br/>            // Read the API key from environment variables<br/>            self.api_key = env::var("OPENAI_API_KEY").expect("OPENAI_API_KEY must be set");<br/>            self.authenticated = true;<br/>        }<br/>    }<br/><br/>    // Implement the prompt method<br/>    pub fn prompt(&amp;self, message: &amp;String) -&gt; OpenAIResult {<br/>        // Build the request URL with the prompt and API key<br/>        let url = format!("https://api.openai.com/v1/completions/models/davinci/versions/1?prompt={}&amp;api_key={}", message, self.api_key);<br/><br/>        // Send the request and parse the JSON response<br/>        let response: serde_json::Value = reqwest::get(url)?.json()?;<br/><br/>        // Return the response<br/>        Ok(response)<br/>    }<br/>}</span></pre><p id="f180" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io"> <em class="ll">我:</em> </strong> <em class="ll">编辑一下你的解决方案。不要使用任何硬编码的字符串，而是将它们放入全局变量和/或动态构造。</em></p><p id="81e2" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io"> <em class="ll"> ChatGPT: </em> </strong></p><pre class="lq lr ls lt gt nv nt nw bn nx ny bi"><span id="1eac" class="nz mg in nt b be oa ob l oc od">use std::env;<br/>use std::error::Error;<br/><br/>// Import the reqwest crate<br/>use reqwest;<br/><br/>// Import the serde_json crate<br/>use serde_json;<br/><br/>// Define a result type for the API response<br/>type OpenAIResult = Result&lt;serde_json::Value, Box&lt;dyn Error&gt;&gt;;<br/><br/>// Define global variables for the API endpoint and model<br/>const API_ENDPOINT: &amp;str = "https://api.openai.com/v1/completions/models/";<br/>const MODEL: &amp;str = "davinci";<br/>const MODEL_VERSION: &amp;str = "1";<br/><br/>// Define the Client struct<br/>pub struct Client {<br/>    api_key: String,<br/>    authenticated: bool,<br/>}<br/><br/>impl Client {<br/>    // Implement the authenticate method<br/>    pub fn authenticate(&amp;mut self) {<br/>        if !self.authenticated {<br/>            // Read the API key from environment variables<br/>            self.api_key = env::var("OPENAI_API_KEY").expect("OPENAI_API_KEY must be set");<br/>            self.authenticated = true;<br/>        }<br/>    }<br/><br/>    // Implement the prompt method<br/>    pub fn prompt(&amp;self, message: &amp;String) -&gt; OpenAIResult {<br/>        // Build the request URL with the prompt, model, and API key<br/>        let url = format!("{}{}/versions/{}?prompt={}&amp;api_key={}", API_ENDPOINT, MODEL, MODEL_VERSION, message, self.api_key);<br/><br/>        // Send the request and parse the JSON response<br/>        let response: serde_json::Value = reqwest::get(url)?.json()?;<br/><br/>        // Return the response<br/>        Ok(response)<br/>    }<br/>}</span></pre><p id="21d7" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io"> <em class="ll">我:</em> </strong> <em class="ll">写一系列命令，我需要执行这些命令来设置你上面创建的项目。</em></p><p id="650a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io"> <em class="ll"> ChatGPT: </em> </strong> <code class="fe nq nr ns nt b">[returns a response with lots of text between commands]</code></p><p id="6a3e" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io"> <em class="ll">我:</em> </strong> <em class="ll">对于上面你给我的答案，去掉所有用英文写的“纯文本”，创建一个单独的代码片段，作为 bash 命令的序列，来实现结果。</em></p><p id="a0b3" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">下面是一系列 bash 命令，您可以使用它们在 Rust 中为基于 OpenAI GPT 的模型建立一个简单的 CLI 客户端项目。</p><pre class="lq lr ls lt gt nv nt nw bn nx ny bi"><span id="45ae" class="nz mg in nt b be oa ob l oc od"># Install the Rust programming language<br/>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh<br/><br/># Create a new project directory and navigate to it<br/>mkdir openai-client<br/>cd openai-client<br/><br/># Initialize a new Rust project with cargo<br/>cargo init<br/><br/># Edit the Cargo.toml file and add the reqwest and serde_json crates as dependencies<br/>echo '[dependencies]' &gt;&gt; Cargo.toml<br/>echo 'reqwest = "0.10"' &gt;&gt; Cargo.toml<br/>echo 'serde_json = "1.0"' &gt;&gt; Cargo.toml<br/><br/># Create a new file named src/main.rs<br/>touch src/main.rs<br/><br/># Copy the code for the Client struct into src/main.rs<br/>echo 'use std::env;<br/>use std::error::Error;<br/><br/>// Import the reqwest crate<br/>use reqwest;<br/><br/>// Import the serde_json crate<br/>use serde_json;<br/><br/>// Define a result type for the API response<br/>type OpenAIResult = Result&lt;serde_json::Value, Box&lt;dyn Error&gt;&gt;;<br/><br/>// Define global variables for the API endpoint and model<br/>const API_ENDPOINT: &amp;str = "https://api.openai.com/v1/completions/models/";<br/>const MODEL: &amp;str = "davinci";<br/>const MODEL_VERSION: &amp;str = "1";<br/><br/>// Define the Client struct<br/>pub struct Client {<br/>    api_key: String,<br/>    authenticated: bool,<br/>}<br/><br/>impl Client {<br/>    // Implement the authenticate method<br/>    pub fn authenticate(&amp;mut self) {<br/>        if !self.authenticated {<br/>            // Read the API key from environment variables<br/>            self.api_key = env::var("OPENAI_API_KEY").expect("OPENAI_API_KEY must be set");<br/>            self.authenticated = true;<br/>        }<br/>    }<br/><br/>    // Implement the prompt method<br/>    pub fn prompt(&amp;self, message: &amp;String) -&gt; OpenAIResult {<br/>        // Build the request URL with the prompt, model, and API key<br/>        let url = format!("{}{}/versions/{}?prompt={}&amp;api_key={}", API_ENDPOINT, MODEL, MODEL_VERSION, message, self.api_key);<br/><br/>        // Send the request and parse the JSON response<br/>        let response: serde_json::Value = reqwest::get(url)?.json()?;<br/><br/>        // Return the response<br/>        Ok(response)<br/>    }<br/>}' &gt;&gt; src/main.rs<br/><br/># Build and run the project<br/>cargo run</span></pre><p id="722e" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io"> <em class="ll">我:</em> </strong> <em class="ll">差不多了！但是，您创建的</em> <code class="fe nq nr ns nt b"><em class="ll">main.rs</em></code> <em class="ll">文件无效。它不具备</em> <code class="fe nq nr ns nt b"><em class="ll">main</em></code> <em class="ll">功能。请编辑您创建的代码片段，使其包含一个基本的 main 函数，该函数从 args 获取用户提示，并向 API 发送请求。</em></p><p id="6889" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io"> <em class="ll"> ChatGPT: </em> </strong> <code class="fe nq nr ns nt b">[updates the script adding main function; showing the updated part only]</code></p><pre class="lq lr ls lt gt nv nt nw bn nx ny bi"><span id="cf68" class="nz mg in nt b be oa ob l oc od">... // [the rest of the code goes above]<br/><br/>// Define the main function<br/>fn main() {<br/>    // Create a new client<br/>    let mut client = Client {<br/>        api_key: "".to_string(),<br/>        authenticated: false,<br/>    };<br/><br/>    // Authenticate the client<br/>    client.authenticate();<br/><br/>    // Read the prompt from command-line arguments<br/>    let args: Vec&lt;String&gt; = env::args().collect();<br/>    if args.len() &lt; 2 {<br/>        eprintln!("Usage: openai-client &lt;prompt&gt;");<br/>        process::exit(1);<br/>    }<br/>    let prompt = &amp;args[1];<br/><br/>    // Use the client to make a request to the API<br/>    let response = client.prompt(prompt).unwrap();<br/><br/>    // Print the response<br/>    println!("{:?}", response);<br/>}</span></pre><p id="044d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io"> <em class="ll">我:</em> </strong> <em class="ll">现在，还有一件事。请创建一个</em> <code class="fe nq nr ns nt b"><em class="ll">Client::new</em></code> <em class="ll">来创建一个客户端，其</em> <code class="fe nq nr ns nt b"><em class="ll">api_key</em></code> <em class="ll">字符串为空，并且</em> <code class="fe nq nr ns nt b"><em class="ll">false</em></code> <em class="ll">字段的值为</em> <code class="fe nq nr ns nt b"><em class="ll">authenticated</em></code> <em class="ll">字段，并使用它来代替创建客户端的实例。因此，更新后的行应该如下所示:</em></p><pre class="lq lr ls lt gt nv nt nw bn nx ny bi"><span id="c502" class="nz mg in nt b be oa ob l oc od">let mut client = Client::new();</span></pre><p id="091d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io"> <em class="ll"> ChatGPT: </em> </strong> <code class="fe nq nr ns nt b">[unfortunately, this time, the conversation stopped abruptly; the snippet was trimmed half-way, and the model was thinking indefinitely without any further outout; so, I left the snippet as is]</code></p></div><div class="ab cl oe of hr og" role="separator"><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj"/></div><div class="ig ih ii ij ik"><p id="cbf4" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">哦，真令人印象深刻！该模型准确地跟踪对话，并根据请求对代码进行适当的修改。关键时刻:在本地复制粘贴代码，添加一个缺少的主函数，并尝试运行它！</p><pre class="lq lr ls lt gt nv nt nw bn nx ny bi"><span id="1dc3" class="nz mg in nt b be oa ob l oc od">chmod +x create_client.sh<br/>./create_client.sh</span></pre><blockquote class="ol"><p id="762b" class="om on in bd oo op oq or os ot ou kx dk translated">我们到了吗？嗯，不完全是…</p></blockquote><pre class="ov ow ox oy oz nv nt nw bn nx ny bi"><span id="3d5e" class="nz mg in nt b be oa ob l oc od">error[E0433]: failed to resolve: use of undeclared crate or module `process`<br/>  --&gt; src/main.rs:62:9<br/>   |<br/>62 |         process::exit(1);<br/>   |         ^^^^^^^ use of undeclared crate or module `process`<br/><br/>error[E0277]: the trait bound `std::string::String: IntoUrl` is not satisfied<br/>   --&gt; src/main.rs:40:56<br/>    |<br/>40  |         let response: serde_json::Value = reqwest::get(url)?.json()?;<br/>    |                                           ------------ ^^^ expected an implementor of trait `IntoUrl`<br/>    |                                           |<br/>    |                                           required by a bound introduced by this call<br/>    |<br/>    = note: required because of the requirements on the impl of `IntoUrl` for `std::string::String`<br/>note: required by a bound in `reqwest::get`<br/>   --&gt; [...].cargo/registry/src/github.com-1ecc6299db9ec823/reqwest-0.10.10/src/lib.rs:256:21<br/>    |<br/>256 | pub async fn get&lt;T: IntoUrl&gt;(url: T) -&gt; crate::Result&lt;Response&gt; {<br/>    |                     ^^^^^^^ required by this bound in `reqwest::get`<br/>help: consider borrowing here<br/>    |<br/>40  |         let response: serde_json::Value = reqwest::get(&amp;url)?.json()?;<br/>    |                                                        +<br/><br/>error[E0277]: the `?` operator can only be applied to values that implement `Try`<br/>  --&gt; src/main.rs:40:43<br/>   |<br/>40 |         let response: serde_json::Value = reqwest::get(url)?.json()?;<br/>   |                                           ^^^^^^^^^^^^^^^^^^ the `?` operator cannot be applied to type `impl Future&lt;Output = Result&lt;Response, reqwest::Error&gt;&gt;`<br/>   |<br/>   = help: the trait `Try` is not implemented for `impl Future&lt;Output = Result&lt;Response, reqwest::Error&gt;&gt;`<br/><br/>Some errors have detailed explanations: E0277, E0433.<br/>For more information about an error, try `rustc --explain E0277`.<br/>error: could not compile `openai-client` due to 3 previous errors</span></pre><p id="b9d4" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你可能已经注意到了，这个片段不太正确。</p><ol class=""><li id="0d90" class="nc nd in ke b kf kg ki kj kl ne kp nf kt ng kx nu ni nj nk bi translated">生成的 bash 脚本使用<code class="fe nq nr ns nt b">&gt;&gt;</code>操作符将创建的代码附加到<code class="fe nq nr ns nt b">main.rs</code>中，而不是使用<code class="fe nq nr ns nt b">&gt;</code>从头开始创建文件。(所以，你最后得到了<em class="ll">两个</em>主函数。)</li><li id="3217" class="nc nd in ke b kf nl ki nm kl nn kp no kt np kx nu ni nj nk bi translated">它还向我手动修复的 TOML 文件中写入了一个额外的<code class="fe nq nr ns nt b">[dependencies]</code>行，以便让<code class="fe nq nr ns nt b">cargo run</code>工作。</li><li id="eb21" class="nc nd in ke b kf nl ki nm kl nn kp no kt np kx nu ni nj nk bi translated">漏掉了包括<code class="fe nq nr ns nt b">std::process</code>。</li><li id="187e" class="nc nd in ke b kf nl ki nm kl nn kp no kt np kx nu ni nj nk bi translated">依赖版本很重要:<code class="fe nq nr ns nt b">reqwest=0.10</code>默认使用异步 API，因此不能与 ChatGPT 生成的代码一起工作。可能的解决方案:用<code class="fe nq nr ns nt b">#[tokio::main]</code>修饰主函数，使其异步，或者降级版本使用同步 API。</li><li id="bf07" class="nc nd in ke b kf nl ki nm kl nn kp no kt np kx nu ni nj nk bi translated">最后，它应该使用<code class="fe nq nr ns nt b">&amp;url</code>而不仅仅是<code class="fe nq nr ns nt b">url</code>。</li></ol><p id="3acc" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我在尝试运行生成的脚本和监听编译器时发现了这些错误，并在编辑器中一个接一个地修复它们。但除此之外，它看起来很有道理！并且，准确地遵循说明。</p><p id="0e13" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果我们能让机器人帮我们修复 bug 呢？我们来试试吧！</p><h1 id="8e69" class="mf mg in bd mh mi mj mk ml mm mn mo mp jt mq ju mr jw ms jx mt jz mu ka mv mw bi translated">二。修复 bug</h1><p id="d5c9" class="pw-post-body-paragraph kc kd in ke b kf mx jo kh ki my jr kk kl mz kn ko kp na kr ks kt nb kv kw kx ig bi translated"><strong class="ke io"> <em class="ll">我:</em> </strong> <em class="ll">我有一个锈程序，不能编译。我会给你看我程序的内容，还有错误。请告诉我哪里有错误，并生成一个新的文件(或文件)与更新的内容，我可以用来成功地编译代码。</em></p><p id="07de" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ll">下面是我的源代码:</em> <code class="fe nq nr ns nt b">[copy-pasted main.rs script that doesn't compile]</code></p><p id="7b9b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ll">下面是我的错误:</em> <code class="fe nq nr ns nt b">[copy-pasted error output coming from the Rust compiler]</code></p><p id="ec9f" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io"><em class="ll">ChatGPT:</em></strong><em class="ll">代码中没有定义</em> <code class="fe nq nr ns nt b"><em class="ll">process</em></code> <em class="ll">模块。</em> <code class="fe nq nr ns nt b"><em class="ll">process</em></code> <em class="ll">模块是</em> <code class="fe nq nr ns nt b"><em class="ll">std::process</em></code> <em class="ll">机箱的一部分，需要在文件开头导入。另外，第 40 行的</em> <code class="fe nq nr ns nt b"><em class="ll">url</em></code> <em class="ll">变量是一个</em> <code class="fe nq nr ns nt b"><em class="ll">String</em></code> <em class="ll">，需要将其转换为</em> <code class="fe nq nr ns nt b"><em class="ll">Url</em></code> <em class="ll">类型，以便作为参数传递给</em> <code class="fe nq nr ns nt b"><em class="ll">reqwest::get</em></code> <em class="ll">方法。</em></p><p id="4d14" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ll">下面是代码的更新版本，编译时不会出错:</em></p><pre class="lq lr ls lt gt nv nt nw bn nx ny bi"><span id="4aa1" class="nz mg in nt b be oa ob l oc od">use std::env;<br/>use std::error::Error;<br/>use std::process;<br/><br/>// [same as before]<br/><br/>impl Client {<br/>    // Implement the authenticate method<br/>    pub fn authenticate(&amp;mut self) { ... }<br/><br/>    // Implement the prompt method<br/>    pub fn prompt(&amp;self, message: &amp;String) -&gt; OpenAIResult {<br/>        // Build the request URL with the prompt, model, and API key<br/>        let url = format!("{}{}/versions/{}?prompt={}&amp;api_key={}", API_ENDPOINT, MODEL, MODEL_VERSION, message, self.api_key);<br/><br/>        // Convert the URL to a `Url` type and send the request<br/>        let url: reqwest::Url = url.parse()?;<br/>        let response: serde_json::Value = reqwest::get(url)?.json()?;<br/><br/>        // Return the response<br/>        Ok(response)<br/>    }<br/>}<br/><br/>// [same as before]</span></pre></div><div class="ab cl oe of hr og" role="separator"><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj"/></div><div class="ig ih ii ij ik"><p id="589b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">它捕捉到了<code class="fe nq nr ns nt b">std::process</code>的问题，也对<code class="fe nq nr ns nt b">url</code>变量做了一些修改。有用吗？</p><pre class="lq lr ls lt gt nv nt nw bn nx ny bi"><span id="56ac" class="nz mg in nt b be oa ob l oc od">   Compiling openai-client v0.1.0 (...)<br/>error[E0277]: the `?` operator can only be applied to values that implement `Try`<br/>  --&gt; src/main.rs:42:43<br/>   |<br/>42 |         let response: serde_json::Value = reqwest::get(url)?.json()?;<br/>   |                                           ^^^^^^^^^^^^^^^^^^ the `?` operator cannot be applied to type `impl Future&lt;Output = Result&lt;Response, reqwest::Error&gt;&gt;`<br/>   |<br/>   = help: the trait `Try` is not implemented for `impl Future&lt;Output = Result&lt;Response, reqwest::Error&gt;&gt;`<br/><br/>For more information about this error, try `rustc --explain E0277`.<br/>error: could not compile `openai-client` due to previous error</span></pre><p id="3105" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">还没有！让我们要求一个解决方案…</p></div><div class="ab cl oe of hr og" role="separator"><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj"/></div><div class="ig ih ii ij ik"><p id="8c21" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io"> <em class="ll">我:</em> </strong> <em class="ll">嗯，片段还是失败。这一次，错误是:[复制粘贴上面的错误] </em></p><p id="f6cd" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io"><em class="ll">ChatGPT:</em></strong><em class="ll">该错误消息表明</em> <code class="fe nq nr ns nt b"><em class="ll">?</em></code> <em class="ll">运算符不能与</em> <code class="fe nq nr ns nt b"><em class="ll">impl Future&lt;Output = Result&lt;Response, reqwest::Error&gt;&gt;</em></code> <em class="ll">类型的值一起使用。在 Rust 中，</em> <code class="fe nq nr ns nt b"><em class="ll">?</em></code> <em class="ll">运算符只能应用于实现</em> <code class="fe nq nr ns nt b"><em class="ll">Try</em></code> <em class="ll">特征的值。</em></p><p id="b231" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ll"/><code class="fe nq nr ns nt b"><em class="ll">reqwest::get</em></code><em class="ll">方法返回一个</em> <code class="fe nq nr ns nt b"><em class="ll">Future</em></code> <em class="ll">，它是一个对象，表示一个可能还不可用的值。为了将</em> <code class="fe nq nr ns nt b"><em class="ll">?</em></code> <em class="ll">运算符与</em> <code class="fe nq nr ns nt b"><em class="ll">reqwest::get</em></code> <em class="ll">方法的结果一起使用，必须使用</em> <code class="fe nq nr ns nt b"><em class="ll">await</em></code> <em class="ll">关键字将</em> <code class="fe nq nr ns nt b"><em class="ll">Future</em></code> <em class="ll">转换为</em> <code class="fe nq nr ns nt b"><em class="ll">Result</em></code> <em class="ll">。</em></p><p id="6a32" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ll">下面是代码的更新版本，编译时不会出错:</em></p><pre class="lq lr ls lt gt nv nt nw bn nx ny bi"><span id="abac" class="nz mg in nt b be oa ob l oc od">use std::env;<br/>use std::error::Error;<br/>use std::process;<br/><br/>// Import the reqwest crate<br/>use reqwest;<br/><br/>// Import the serde_json crate<br/>use serde_json;<br/><br/>// Define a result type for the API response<br/>type OpenAIResult = Result&lt;serde_json::Value, Box&lt;dyn Error&gt;&gt;;<br/><br/>// Define global variables for the API endpoint and model<br/>const API_ENDPOINT: &amp;str = "https://api.openai.com/v1/completions/models/";<br/>const MODEL: &amp;str = "davinci";<br/>const MODEL_VERSION: &amp;str = "1";<br/><br/>// Define the Client struct<br/>pub struct Client {<br/>    api_key: String,<br/>    authenticated: bool,<br/>}<br/><br/>impl Client {<br/>    // Implement the authenticate method<br/>    pub fn authenticate(&amp;mut self) {<br/>        if !self.authenticated {<br/>            // Read the API key from environment variables<br/>            self.api_key = env::var("OPENAI_API_KEY").expect("OPENAI_API_KEY must be set");<br/>            self.authenticated = true;<br/>        }<br/>    }<br/><br/>    // Implement the prompt method<br/>    pub async fn prompt(&amp;self, message: &amp;String) -&gt; OpenAIResult {<br/>        // Build the request URL with the prompt, model, and API key<br/>        let url = format!("{}{}/versions/{}?prompt={}&amp;api_key={}", API_ENDPOINT, MODEL, MODEL_VERSION, message, self.api_key);<br/><br/>        // Convert the URL to a `Url` type and send the request<br/>        let url: reqwest::Url = url.parse()?;<br/>        let response: serde_json::Value = reqwest::get(url).await?.json().await?;<br/><br/>        // Return the response<br/>        Ok(response)<br/>    }<br/>}<br/><br/>// Define the main function<br/>#[tokio::main]<br/>async fn main() {<br/>    // Create a new client<br/>    let mut client = Client {<br/>        api_key: "".to_string(),<br/>        authenticated: false,<br/>    };<br/><br/>    // Authenticate the client<br/>    client.authenticate();<br/><br/>    // Read the prompt from command-line arguments<br/>    let args: Vec&lt;String&gt; = env::args().collect();<br/>    if args.len() &lt; 2 {<br/>        eprintln!("Usage: openai-client &lt;prompt&gt;");<br/>        process::exit(1);<br/>    }<br/>    let prompt = &amp;args[1];<br/><br/>    // Use the client to make a request to the API<br/>    let response = client.prompt(prompt).await.unwrap();<br/><br/>    // Print the response<br/>    println!("{:?}", response);<br/>}</span></pre><p id="b9ec" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ll">注</em> <code class="fe nq nr ns nt b">[it is defintely wanted to add some comment, but stopped here.]</code></p></div><div class="ab cl oe of hr og" role="separator"><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj"/></div><div class="ig ih ii ij ik"><p id="c6e4" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是很好的进步！这一次，代码片段使用了异步 API，编译错误的数量减少了。然而，代码仍然不工作，因为我们还需要对 TOML 文件添加一些修正。(也许我也应该把文件的内容传递给机器人？)</p><pre class="lq lr ls lt gt nv nt nw bn nx ny bi"><span id="e153" class="nz mg in nt b be oa ob l oc od">[dependencies]<br/>tokio = { version = "0.2", features = ["full"] }<br/>reqwest = { version = "0.10", features = ["json"] }</span></pre><p id="2343" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">否则，代码片段这次成功编译！但是真的管用吗？</p><pre class="lq lr ls lt gt nv nt nw bn nx ny bi"><span id="46ac" class="nz mg in nt b be oa ob l oc od">Object {"error": Object {"code": Null, "message": String("Invalid URL (GET /v1/completions/models/davinci/versions/1)"), "param": Null, "type": String("invalid_request_error")}}</span></pre><p id="aa21" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">显然，端点和/或参数是错误的。让我们再一次寻求帮助！这一次，我们使用文档中<a class="ae lh" href="https://beta.openai.com/docs/api-reference/making-requests" rel="noopener ugc nofollow" target="_blank">的一个例子来提示这个模型。</a></p><h1 id="2dc5" class="mf mg in bd mh mi mj mk ml mm mn mo mp jt mq ju mr jw ms jx mt jz mu ka mv mw bi translated">三。发送请求</h1><p id="bbe8" class="pw-post-body-paragraph kc kd in ke b kf mx jo kh ki my jr kk kl mz kn ko kp na kr ks kt nb kv kw kx ig bi translated"><strong class="ke io"> <em class="ll"> Me </em> </strong> <em class="ll">:我用下面的代码片段做一个打开 AI API 的请求。</em></p><pre class="lq lr ls lt gt nv nt nw bn nx ny bi"><span id="dd37" class="nz mg in nt b be oa ob l oc od">const API_ENDPOINT: &amp;str = "https://api.openai.com/v1/completions/models/";<br/>const MODEL: &amp;str = "davinci";<br/>const MODEL_VERSION: &amp;str = "1";<br/><br/>pub async fn prompt(&amp;self, message: &amp;String) -&gt; OpenAIResult {<br/>    // Build the request URL with the prompt, model, and API key<br/>    let url = format!("{}{}/versions/{}?prompt={}&amp;api_key={}", API_ENDPOINT, MODEL, MODEL_VERSION, message, self.api_key);<br/><br/>    // Convert the URL to a `Url` type and send the request<br/>    let url: reqwest::Url = url.parse()?;<br/>    let response: serde_json::Value = reqwest::get(url).await?.json().await?;<br/><br/>    // Return the response<br/>    Ok(response)<br/>}</span></pre><p id="01bf" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ll">但是，它失败了，并显示错误:</em></p><pre class="lq lr ls lt gt nv nt nw bn nx ny bi"><span id="aa63" class="nz mg in nt b be oa ob l oc od">Object {"error": Object {"code": Null, "message": String("Invalid URL (GET /v1/completions/models/davinci/versions/1)"), "param": Null, "type": String("invalid_request_error")}}</span></pre><p id="2413" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ll">我猜是参数或者网址，或者两者都是错的。你能给我看一下正确配置的代码片段吗？这是一个使用</em> <code class="fe nq nr ns nt b"><em class="ll">curl</em></code> <em class="ll">来查询 API 的 bash 脚本，并且工作正常。</em></p><pre class="lq lr ls lt gt nv nt nw bn nx ny bi"><span id="de95" class="nz mg in nt b be oa ob l oc od">curl https://api.openai.com/v1/completions \<br/>-H "Content-Type: application/json" \<br/>-H "Authorization: Bearer YOUR_API_KEY" \<br/>-d '{"model": "text-davinci-003", "prompt": "Say this is a test", "temperature": 0, "max_tokens": 7}'</span></pre><p id="92ad" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ll">请修改我的代码，以实现与上面显示的</em> <code class="fe nq nr ns nt b"><em class="ll">curl</em></code> <em class="ll">相同的请求。</em></p><p id="7880" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io"><em class="ll">ChatGPT:</em></strong><em class="ll">您的代码试图使用</em> <code class="fe nq nr ns nt b"><em class="ll">GET</em></code> <em class="ll"> HTTP 方法向 OpenAI API 发出请求，这是不正确的。您提供的</em> <code class="fe nq nr ns nt b"><em class="ll">curl</em></code> <em class="ll">命令使用了</em> <code class="fe nq nr ns nt b"><em class="ll">POST</em></code> <em class="ll">方法，这是发送带有正文的请求时使用的正确方法。</em></p><p id="a43d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ll">要修复您的代码，您需要将</em> <code class="fe nq nr ns nt b"><em class="ll">reqwest::get</em></code> <em class="ll">调用改为</em> <code class="fe nq nr ns nt b"><em class="ll">reqwest::Client::post</em></code> <em class="ll">，并将请求体作为参数传递给</em> <code class="fe nq nr ns nt b"><em class="ll">post</em></code> <em class="ll">方法。您还需要在请求中设置</em> <code class="fe nq nr ns nt b"><em class="ll">Content-Type</em></code> <em class="ll">和</em> <code class="fe nq nr ns nt b"><em class="ll">Authorization</em></code> <em class="ll">头，如</em> <code class="fe nq nr ns nt b"><em class="ll">curl</em></code> <em class="ll">命令所示。</em></p><p id="8b7a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ll">这是你的代码的更新版本，应该可以工作:</em></p><pre class="lq lr ls lt gt nv nt nw bn nx ny bi"><span id="c87f" class="nz mg in nt b be oa ob l oc od">const API_ENDPOINT: &amp;str = "https://api.openai.com/v1/completions";<br/>const MODEL: &amp;str = "text-davinci-003";<br/>const MODEL_VERSION: &amp;str = "1";<br/><br/>pub async fn prompt(&amp;self, message: &amp;String) -&gt; OpenAIResult {<br/>    // Build the request body with the prompt, model, and temperature<br/>    let request_body = json!({<br/>        "prompt": message,<br/>        "model": MODEL,<br/>        "temperature": 0,<br/>        "max_tokens": 7,<br/>    });<br/><br/>    // Build the request URL with the model and version<br/>    let url = format!("{}/models/{}/versions/{}", API_ENDPOINT, MODEL, MODEL_VERSION);<br/><br/>    // Convert the URL to a `Url` type and send the request<br/>    let url: reqwest::Url = url.parse()?;<br/>    let client = reqwest::Client::new();<br/>    let response: serde_json::Value = client.post(url)<br/>        .header("Content-Type", "application/json")<br/>        .header("Authorization", format!("Bearer {}", self.api_key))<br/>        .json(&amp;request_body)<br/>        .send()<br/>        .await?<br/>        .json()<br/>        .await?;<br/><br/>    // Return the response<br/>    Ok(response)<br/>}</span></pre></div><div class="ab cl oe of hr og" role="separator"><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj"/></div><div class="ig ih ii ij ik"><p id="4098" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">干得好，非常接近！对应该改变什么的解释也很棒。(这是一个将命令或代码片段从一种语言或工具映射到另一种语言或工具的好工具。)让它工作的一个编辑是实际替换所请求的 URL。因为模型仍然坚持使用错误的链接。我们应该使用下面的 URL。</p><pre class="lq lr ls lt gt nv nt nw bn nx ny bi"><span id="3421" class="nz mg in nt b be oa ob l oc od">let url = String::from(API_ENDPOINT);</span></pre><p id="9f1a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">修复并重新编译后，输出如下:</p><pre class="lq lr ls lt gt nv nt nw bn nx ny bi"><span id="c2ef" class="nz mg in nt b be oa ob l oc od">&gt; OPENAI_API_KEY="&lt;your-key&gt;" cargo run -- "Hello, Davinci"<br/><br/>Object {"choices": <br/>    Array [Object {<br/>        "finish_reason": String("length"), <br/>        "index": Number(0), <br/>        "logprobs": Null, <br/>        "text": String("\n\nHello! How can I")}<br/>     ], <br/>     "created": Number(1670342922), <br/>     "id": String("cmpl-6KUmowybKJ9NVIboliVpD2yaPeIv7"), <br/>     "model": String("text-davinci-003"), <br/>     "object": String("text_completion"), <br/>     "usage": Object {<br/>         "completion_tokens": Number(7), <br/>         "prompt_tokens": Number(5), <br/>         "total_tokens": Number(12)<br/>     }<br/>}</span></pre><blockquote class="ol"><p id="5ccb" class="om on in bd oo op oq or os ot ou kx dk translated">有用！🎉</p></blockquote><p id="eab9" class="pw-post-body-paragraph kc kd in ke b kf pa jo kh ki pb jr kk kl pc kn ko kp pd kr ks kt pe kv kw kx ig bi translated">现在，是时候做一些重构来使代码更干净，并用 CLI 选项替换硬编码的参数了。而且，我们有一个助手随时准备帮助我们…</p><h1 id="32f6" class="mf mg in bd mh mi mj mk ml mm mn mo mp jt mq ju mr jw ms jx mt jz mu ka mv mw bi translated">四。清理</h1><p id="50c3" class="pw-post-body-paragraph kc kd in ke b kf mx jo kh ki my jr kk kl mz kn ko kp na kr ks kt nb kv kw kx ig bi translated"><strong class="ke io"> <em class="ll"> Me: </em> </strong> <em class="ll">在下面的代码中，去掉</em> <code class="fe nq nr ns nt b"><em class="ll">Client::authenticate</em></code> <em class="ll">方法。创建一个新的静态方法</em> <code class="fe nq nr ns nt b"><em class="ll">Client::new</em></code> <em class="ll">，该方法实现认证逻辑并返回一个</em> <code class="fe nq nr ns nt b"><em class="ll">Result</em></code> <em class="ll">对象，该对象包含一个新创建的客户端(如果带有密钥的环境变量存在)，否则返回 error。同样，重构</em> <code class="fe nq nr ns nt b"><em class="ll">prompt</em></code> <em class="ll">方法以接受</em> <code class="fe nq nr ns nt b"><em class="ll">request_body</em></code> <em class="ll">作为参数。请不要在回答中包含任何文本，只包含更新后的代码片段。</em></p><p id="3cc3" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe nq nr ns nt b">[copy-pasted the so far created code as the previously started conversation was lost]</code></p><p id="a4a7" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io"> <em class="ll"> ChatGPT: </em> </strong></p><pre class="lq lr ls lt gt nv nt nw bn nx ny bi"><span id="b48d" class="nz mg in nt b be oa ob l oc od">pub struct Client {<br/>    api_key: String,<br/>}<br/><br/>impl Client {<br/>    // Implement the new method<br/>    pub fn new() -&gt; Result&lt;Client, Box&lt;dyn std::error::Error&gt;&gt; {<br/>        // Read the API key from environment variables<br/>        let api_key = env::var("OPENAI_API_KEY")?;<br/>        Ok(Client{ api_key })<br/>    }<br/><br/>    // Implement the prompt method<br/>    pub async fn prompt(&amp;self, request_body: &amp;serde_json::Value) -&gt; OpenAIResult {<br/>        // Build the request URL with the model and version<br/>        let url = String::from(API_ENDPOINT);<br/>    <br/>        // Convert the URL to a `Url` type and send the request<br/>        let url: reqwest::Url = url.parse()?;<br/>        let client = reqwest::Client::new();<br/>        let response: serde_json::Value = client.post(url)<br/>            .header("Content-Type", "application/json")<br/>            .header("Authorization", format!("Bearer {}", self.api_key))<br/>            .json(request_body)<br/>            .send()<br/>            .await?<br/>            .json()<br/>            .await?;<br/>    <br/>        // Return the response<br/>        Ok(response)<br/>    }<br/>}</span></pre><p id="1894" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io"> <em class="ll">我:</em> </strong> <em class="ll">太棒了！现在，创建一个新的异步 main 函数，该函数从 CLI 读取请求体值，并使用客户端发出请求。如果缺少任何参数，则终止程序。</em></p><p id="4c10" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">ChatGPT:T42】</strong></p><pre class="lq lr ls lt gt nv nt nw bn nx ny bi"><span id="e7a4" class="nz mg in nt b be oa ob l oc od">use structopt::StructOpt;<br/><br/>#[derive(StructOpt, Debug)]<br/>struct Cli {<br/>    // The prompt to generate text for<br/>    #[structopt(short = "p", long = "prompt")]<br/>    prompt: String,<br/><br/>    // The model to use for text generation<br/>    #[structopt(short = "m", long = "model")]<br/>    model: String,<br/><br/>    // The temperature to use for text generation<br/>    #[structopt(short = "t", long = "temperature")]<br/>    temperature: f64,<br/><br/>    // The maximum number of tokens to generate<br/>    #[structopt(short = "x", long = "max_tokens")]<br/>    max_tokens: usize,<br/>}<br/><br/>#[tokio::main]<br/>async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {<br/>    // Parse CLI arguments<br/>    let args = Cli::from_args();<br/><br/>    // Create a new client instance<br/>    let client = Client::new()?;<br/><br/>    // Build the request body<br/>    let request_body = json!({<br/>        "prompt": &amp;args.prompt,<br/>        "model": &amp;args.model,<br/>        "temperature": args.temperature,<br/>        "max_tokens": args.max_tokens,<br/>    });<br/><br/>    // Generate text using the prompt<br/>    let response = client.prompt(&amp;request_body).await?;<br/><br/>    // Print the response<br/>    println!("{}", response);<br/><br/>    Ok(())<br/>}</span></pre><p id="d4e4" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io"> <em class="ll">我:</em> </strong> <em class="ll">我应该用什么版本的</em> <code class="fe nq nr ns nt b"><em class="ll">structopt</em></code> <em class="ll">板条箱才能让上面的片段工作？</em></p><p id="f2fa" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io"><em class="ll">ChatGPT:</em></strong><em class="ll">你应该使用最新版本的</em> <code class="fe nq nr ns nt b"><em class="ll">structopt</em></code> <em class="ll">机箱。为此，您需要更新您的</em> <code class="fe nq nr ns nt b"><em class="ll">Cargo.toml</em></code> <em class="ll">文件中的版本号，如下所示:</em></p><pre class="lq lr ls lt gt nv nt nw bn nx ny bi"><span id="1870" class="nz mg in nt b be oa ob l oc od">[dependencies]<br/>structopt = "^0.3.12"</span></pre><p id="f976" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ll">这将使用与</em> <code class="fe nq nr ns nt b"><em class="ll">0.3.12</em></code> <em class="ll">版本兼容的</em> <code class="fe nq nr ns nt b"><em class="ll">structopt</em></code> <em class="ll">板条箱的最新版本。</em></p><p id="163d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ll">或者，您可以使用最新版本的</em> <code class="fe nq nr ns nt b"><em class="ll">structopt</em></code> <em class="ll">板条箱，无需指定版本号，如下:</em></p><pre class="lq lr ls lt gt nv nt nw bn nx ny bi"><span id="e177" class="nz mg in nt b be oa ob l oc od">[dependencies]<br/>structopt = "*"</span></pre><p id="63dc" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ll">这将使用最新版本的</em> <code class="fe nq nr ns nt b"><em class="ll">structopt</em></code> <em class="ll">板条箱可用在</em> <a class="ae lh" href="https://crates.io/" rel="noopener ugc nofollow" target="_blank"> <em class="ll">板条箱. io </em> </a> <em class="ll">上。但是，如果在新版本中引入了重大更改，这可能会导致兼容性问题。</em></p></div><div class="ab cl oe of hr og" role="separator"><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj"/></div><div class="ig ih ii ij ik"><p id="255b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">好的，这个看起来比上一个版本好一点。我特别喜欢关于使用哪种板条箱以及有哪些选项的解释。</p><p id="05ef" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，让我们检查它是否仍然工作。</p><pre class="lq lr ls lt gt nv nt nw bn nx ny bi"><span id="22db" class="nz mg in nt b be oa ob l oc od">&gt; cargo run -- -p 'hello, openai!' -m text-davinci-003 -t 0 -x 12<br/><br/>{<br/>    "choices": [{<br/>        "finish_reason":"stop",<br/>        "index":0,"logprobs":null,<br/>        "text":"\n\nHi there!"<br/>    }],<br/>    "created":1670360311,<br/>    "id":"cmpl-6KZJHJ8vW8CB5LyTE0C2hfMv7DY6z",<br/>    "model":"text-davinci-003",<br/>    "object":"text_completion",<br/>    "usage":{"completion_tokens":5,"prompt_tokens":5,"total_tokens":10}<br/>}</span></pre><p id="9149" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">太棒了。</p><h1 id="cf1d" class="mf mg in bd mh mi mj mk ml mm mn mo mp jt mq ju mr jw ms jx mt jz mu ka mv mw bi translated">动词 （verb 的缩写）结尾部分</h1><p id="269b" class="pw-post-body-paragraph kc kd in ke b kf mx jo kh ki my jr kk kl mz kn ko kp na kr ks kt nb kv kw kx ig bi translated">人工智能领域的发展速度令人印象深刻。每个月(甚至每周！)带来了新的发展，比如强大的新模型的发布，这些模型可以有效地玩<a class="ae lh" href="https://techcrunch.com/2022/12/01/now-ai-can-outmaneuver-you-at-both-stratego-and-diplomacy/?guccounter=1&amp;guce_referrer=aHR0cHM6Ly93d3cuZ29vZ2xlLmNvbS8&amp;guce_referrer_sig=AQAAAEZvoiFQiW6I3q77eFPrthoj02eDMH2xoPfD15tf8SyGBzLhkV0AOle55NqPyFZbliqVC0NI5N_LW8AB9LshgIaE6-8TFoONqA0Ze39TiWt5hxw0g6_IlrY3QGPNy2FFywXhS0o1-MxahhxGZ0383QiebjVt1jr7ylVG39XYrS0q" rel="noopener ugc nofollow" target="_blank">复杂的棋盘游戏</a>，或者推动<a class="ae lh" href="https://www.nature.com/articles/s41586-022-05172-4" rel="noopener ugc nofollow" target="_blank">新算法</a>的发现。近年来取得的进展确实令人瞩目，想到这些进展的潜在应用令人兴奋。随着人工智能研究的不断发展，我们可以期待在未来看到更多令人兴奋的发展。</p><p id="ba3a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当然，这些进步也有局限性。一个最重要的限制是，有时这些模型产生的答案非常<em class="ll">合理</em>，但不完全正确。它们可能需要对提示进行(微小的)编辑或重新措辞。此外，虽然 Rust 等语言拥有编译器和 linters 等工具，可以验证代码的正确性并检查漏洞，但将这些检查应用于其他用途并不容易，如<a class="ae lh" href="https://www.technologyreview.com/2022/11/18/1063487/meta-large-language-model-ai-only-survived-three-days-gpt-3-science/" rel="noopener ugc nofollow" target="_blank">解释科学</a>或<a class="ae lh" href="https://www.theverge.com/2022/12/5/23493932/chatgpt-ai-generated-answers-temporarily-banned-stack-overflow-llms-dangers" rel="noopener ugc nofollow" target="_blank">回答 StackOverflow 上的编码问题</a>。有时，大型语言模型(LLM)容易变得<a class="ae lh" href="https://twitter.com/itstimconnors/status/1599544717943123969?s=20&amp;t=Hwc370nJT2eQH66Wrpwjkg" rel="noopener ugc nofollow" target="_blank">非常自信，但自相矛盾，而且大错特错</a>。</p><p id="0816" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然而，这些工具和模型在每次迭代中都在不断改进。很难相信，就在几年前，做我们在这篇文章中讨论的事情似乎还是纯粹的科幻小说。看到人工智能研究将在未来把我们带到哪里，令人兴奋。</p></div><div class="ab cl oe of hr og" role="separator"><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj"/></div><div class="ig ih ii ij ik"><p id="225b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe nq nr ns nt b">[Parts of this post were edited with ChatGPT's assistance ;)]</code></p></div><div class="ab cl oe of hr og" role="separator"><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj"/></div><div class="ig ih ii ij ik"><p id="4dbd" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你喜欢这篇文章吗？不要犹豫，给它鼓掌！还有，你可以在 <a class="ae lh" href="https://twitter.com/devforfu" rel="noopener ugc nofollow" target="_blank"> <em class="ll"> Twitter </em> </a> <em class="ll">或</em><a class="ae lh" href="https://www.linkedin.com/in/ilia-zaitsev" rel="noopener ugc nofollow" target="_blank"><em class="ll">LinkedIn</em></a><em class="ll">上找到我，如果你有任何问题，或者访问</em> <a class="ae lh" href="https://iliazaitsev.me/" rel="noopener ugc nofollow" target="_blank"> <em class="ll">我的网站</em> </a> <em class="ll">查看我在互联网上的其他帖子。</em></p></div></div>    
</body>
</html>