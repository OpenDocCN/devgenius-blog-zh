<html>
<head>
<title>F.I.R.S.T Principles of Unit Testing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">F.单元测试的原则</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/first-principles-of-unit-testing-5b6c452ccb7d?source=collection_archive---------10-----------------------#2020-06-08">https://blog.devgenius.io/first-principles-of-unit-testing-5b6c452ccb7d?source=collection_archive---------10-----------------------#2020-06-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><h2 id="c85d" class="il im in bd b dl io ip iq ir is it dk iu translated" aria-label="kicker paragraph">首先在Swift中提升您的测试</h2><div class=""/><div class=""><h2 id="87e7" class="pw-subtitle-paragraph jt iw in bd b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk dk translated">改进单元测试的原则和技术</h2></div><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/7726349309597927ccf43f32e8383187.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*X4yMUhUAuMtAsgDl"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">在<a class="ae lb" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae lb" href="https://unsplash.com/@austindistel?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Austin Distel </a>拍摄的照片</figcaption></figure><p id="447d" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">创建单元测试是开发生命周期和我日常编码工作的重要部分。编写好的单元测试将会改变你编写产品代码的方式。</p><p id="80d7" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">编写好的测试用例有很多好处，但是，以我个人处理不同类型的项目和实现的经验，我们通常会为生产代码而不是单元测试阅读和实现很多好的约束和原则，你最不希望的事情就是在单元测试中出现问题，我们有足够多的bug要解决。</p><p id="a258" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">今天我将谈论F.I.R.S.T原则。第一个缩写代表:[F]fast，[I]solated，[R]epeatable，[S]self-validating，[T]imely。让我来解释和介绍这些伟大的概念。我将努力使这些概念适应Swift，因此我将添加一些工具来实现我们的目标。</p><p id="4736" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi ly translated"><span class="l lz ma mb bm mc md me mf mg di">最后，我们真的需要尽可能地让我们的测试更快，否则它们会减慢我们的CI工具，因此我们的开发和部署时间会受到影响。关键是以实现代码的同样精神来实现小单元测试。你可以用<strong class="le ix"> <em class="mh">单责</em> </strong>从<strong class="le ix"><em class="mh"/></strong>的概念来达到这个目的。</span></p><p id="ed45" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">我们必须知道集成测试和单元测试的区别。单元测试不通过网络进行通信，通常也不会进行像查询数据库这样的长时间操作，单元测试是特定的任务，每个任务只负责一项工作。我们可以将依赖留在注入模仿之后(<strong class="le ix"> <em class="mh">依赖注入</em></strong>——这就是为什么我们应该使用<strong class="le ix"> <em class="mh">固体</em> </strong>原则来编写代码)，用于文件、API响应、数据库和任何种类的依赖。</p><p id="f483" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">其他补充技术是让<strong class="le ix"><em class="mh">UITests</em></strong><strong class="le ix"><em class="mh">不选中</em> </strong>以使单元测试运行得更快，并评估禁用<strong class="le ix"> <em class="mh">主机应用程序</em> </strong>对<strong class="le ix"> <em class="mh"> </em> </strong>业务和演示逻辑测试的单元测试项目设置，但对逻辑测试保留该设置。</p><p id="421b" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">您还应该考虑为测试 (在Xcode 10和更高版本中可用)激活<strong class="le ix"> <em class="mh">并行特性。这个特性让我们可以在同一个模拟器的多个克隆中执行多个测试。这个特性只对小的测试用例类有效，否则你的类不会被并行化。同样，为了实现这一点，我们将利用<strong class="le ix"> <em class="mh"> SOLID </em> </strong>使用<strong class="le ix"> <em class="mh">接口隔离原则</em> </strong>，从大的XCTestCase转移到较小的XCTestCase。</em></strong></p><p id="61d9" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">最后但同样重要的是，你应该总是考虑使用<strong class="le ix"> <em class="mh">静态分派</em> </strong>，即使是在单元测试类中。这可能是一个关键因素，不仅使我们的测试更快，而且使我们的开发时间更短，改进我们的应用程序，使整个开发周期更快。</p><p id="cb01" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">如果你需要对我们的API调用注入一些响应，我真的推荐<a class="ae lb" href="https://github.com/AliSoftware/OHHTTPStubs" rel="noopener ugc nofollow" target="_blank">ohhttpsubs</a>，这个库可以让你伪造从JSON文件中删除的API调用响应。</p><div class="mi mj gp gr mk ml"><a href="https://github.com/AliSoftware/OHHTTPStubs" rel="noopener  ugc nofollow" target="_blank"><div class="mm ab fo"><div class="mn ab mo cl cj mp"><h2 class="bd ix gy z fp mq fr fs mr fu fw iw bi translated">AliSoftware/ohhttpsubs</h2><div class="ms l"><h3 class="bd b gy z fp mq fr fs mr fu fw dk translated">OHHTTPStubs是一个设计用来非常容易地处理网络请求的库。它可以帮助你:用假的测试你的应用…</h3></div><div class="mt l"><p class="bd b dl z fp mq fr fs mr fu fw dk translated">github.com</p></div></div><div class="mu l"><div class="mv l mw mx my mu mz kv ml"/></div></div></a></div><p id="bf10" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">记住这个原则和单元测试的真正价值是获得关于我们应用的快速反馈。</p><p id="9e33" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi ly translated">独立或隔离意味着我们所有的单元测试必须是相互独立的。在测试之间创建依赖关系可能会导致误报或试图找出某些测试用例失败原因的问题。</p><p id="11cc" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">在Xcode中，我们可以通过打开我们方案的测试设置并点击<em class="mh">选项</em>按钮来激活<strong class="le ix"> <em class="mh">随机化</em> </strong>执行顺序(在Xcode 10及更高版本中可用)。通过这样做，Xcode将总是随机执行我们的测试。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi na"><img src="../Images/ce83fb93a3e6a4d9c14248e490d91b7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9We2CJFm6HRQ-2RxynEfhA.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">随机化和平行特征</figcaption></figure><p id="f1fc" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">以随机的顺序运行测试也意味着我们的被测系统(<strong class="le ix"><em class="mh">【SUT】</em></strong>)也应该从它的依赖关系中<strong class="le ix"/>分离出来，我们可以遵循前面描述的技术原理。</p><p id="2590" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">另一方面，每次我们创建一个<strong class="le ix"> <em class="mh">单元</em> </strong>测试(高亮显示单元)时我们应该遵循3A的规则，<strong class="le ix"> <em class="mh">排列</em> </strong>，<strong class="le ix"> <em class="mh">，</em> </strong>和<strong class="le ix"> <em class="mh">断言</em> </strong>(常见的方式还是用于TDD)或者其他规则<strong class="le ix"> <em class="mh">给出</em> </strong>，<strong class="le ix"> <em class="mh">时</em></strong></p><p id="8d62" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated"><strong class="le ix"> <em class="mh">安排</em> </strong>的意思是为你的测试用例建立必要的状态，这里是所有的数据和依赖，模拟或假人应该被提供给测试的地方。这些变量应该独立于任何环境。</p><p id="d74b" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated"><strong class="le ix"> <em class="mh"> Act </em> </strong>是您必须调用被测方法/属性的地方。我们必须为单元测试调用这个方法/属性，不要与<strong class="le ix"> <em class="mh">集成测试</em> </strong>混淆。</p><p id="eb3d" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated"><strong class="le ix"> <em class="mh">断言</em> </strong>逻辑结果/期望。在任何时候，一个单元测试应该只断言一个逻辑结果，多个物理断言可以是这个物理断言的一部分，只要它们都作用于同一个对象的状态。</p><p id="f5cc" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">记住，这个原则的真正价值是能够在任何时间以任何顺序运行任何测试。</p><p id="404d" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">你可以考虑给BDD(行为驱动开发)一个机会。这个主题不是本文的一部分，我将在以后的文章中讨论BDD。看看这些用Swift实现BDD的伟大框架。</p><div class="mi mj gp gr mk ml"><a href="https://github.com/Quick/Nimble" rel="noopener  ugc nofollow" target="_blank"><div class="mm ab fo"><div class="mn ab mo cl cj mp"><h2 class="bd ix gy z fp mq fr fs mr fu fw iw bi translated">快速/敏捷</h2><div class="ms l"><h3 class="bd b gy z fp mq fr fs mr fu fw dk translated">使用Nimble来表达Swift或Objective-C表达式的预期结果。灵感来自雪松。目录…</h3></div><div class="mt l"><p class="bd b dl z fp mq fr fs mr fu fw dk translated">github.com</p></div></div><div class="mu l"><div class="nb l mw mx my mu mz kv ml"/></div></div></a></div><div class="mi mj gp gr mk ml"><a href="https://github.com/Quick/Quick" rel="noopener  ugc nofollow" target="_blank"><div class="mm ab fo"><div class="mn ab mo cl cj mp"><h2 class="bd ix gy z fp mq fr fs mr fu fw iw bi translated">快/快</h2><div class="ms l"><h3 class="bd b gy z fp mq fr fs mr fu fw dk translated">Quick是一个用于Swift和Objective-C的行为驱动的开发框架。</h3></div><div class="mt l"><p class="bd b dl z fp mq fr fs mr fu fw dk translated">github.com</p></div></div><div class="mu l"><div class="nc l mw mx my mu mz kv ml"/></div></div></a></div><div class="mi mj gp gr mk ml"><a href="https://github.com/Ahmed-Ali/Cucumberish" rel="noopener  ugc nofollow" target="_blank"><div class="mm ab fo"><div class="mn ab mo cl cj mp"><h2 class="bd ix gy z fp mq fr fs mr fu fw iw bi translated">艾哈迈德·阿里/库库伯里什</h2><div class="ms l"><h3 class="bd b gy z fp mq fr fs mr fu fw dk translated">Cucumberish是一个用于行为驱动开发(BDD)的测试自动化框架。它的灵感来自于令人惊奇的…</h3></div><div class="mt l"><p class="bd b dl z fp mq fr fs mr fu fw dk translated">github.com</p></div></div><div class="mu l"><div class="nd l mw mx my mu mz kv ml"/></div></div></a></div><p id="1e60" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi ly translated">可重复的，我们所有的单元测试应该是可重复的和确定的，这意味着如果我们多次运行一个测试用例，即使我们改变环境条件，如模拟器、操作系统版本、API环境和其他类型的外部依赖，它也应该产生相同的结果。正如您所注意到的，这条原则与前面的原则相辅相成，引导我们实现更快、更独立的技术，比如让SUT要求的所有输入参数都预定义和硬编码。</p><p id="fac0" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">一个很好的例子是当我们输入一个来自keychain或用户默认值的值时。为了实现我们的隔离和可重复原则，我们可以使用内存键值存储服务，代替键值提供者作为输入。如你所见，依赖注入永远是我们最好的朋友。</p><p id="f145" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">记住，让我重复一遍，这个原则的真正价值是获得真实的反馈，不管外部环境如何，也不管你在哪里运行测试用例。</p><p id="498e" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi ly translated">elf验证意味着，我们的测试应该是自我验证的，在运行之前，不能有人工解释结果或人工安排步骤。</p><p id="694e" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi ly translated"><span class="l lz ma mb bm mc md me mf mg di"> T </span>代表<strong class="le ix">彻底</strong>但是<strong class="le ix">T5】实行测试驱动开发的开发人员也将其拼写为适时<strong class="le ix">适时</strong>。</strong></p><p id="b8b5" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated"><strong class="le ix">彻底的</strong>意味着当我们实现一个单元测试时，我们应该考虑愉快的路径和负面或边缘场景。我们必须为使用有效输入的快乐路径创建一个单元测试，为使用无效输入的失败情况创建另一个单元测试(这个例子只考虑一个快乐路径和一个失败路径，您必须尽可能地考虑每条路径)。我们还应该考虑为有最小值和最大值这样范围的情况创建额外的单元测试。</p><p id="0cea" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated"><strong class="le ix">彻底原则</strong>的真正价值是试图覆盖每一个用例场景，涵盖安全性、大值、范围值、非法输入和行为等。不要用测试覆盖率的值来指导你的单元测试，100%的覆盖率并不意味着你的测试覆盖了可能的边缘场景和未来的问题。</p><p id="0f10" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated"><strong class="le ix">适时</strong>意味着你可以在任何时候编写单元测试，甚至是在发布特性之后，但是最好是在开发特性的时候创建单元测试。如果你练习TDD，这是你编码程序的一部分。</p><p id="9159" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">当你在特性中工作时，编写测试将会给你一个侧面路径的概念，它将会让你映射和准备需要被注入的依赖项。在发布特性之前编写测试还会让您更加确信该特性会按预期工作，并减少在生产中引入bug的机会。</p><p id="2eef" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">您可以考虑在评审过程中使用规则或指导方针，或者使用自动化工具(CI)来拒绝没有足够测试的代码。我不建议围绕单元测试创建一个严格的规则，比如要求特定的覆盖率，但是我也不会让开发过程没有单元测试。</p><h1 id="11f6" class="ne nf in bd ng nh ni nj nk nl nm nn no kc np kd nq kf nr kg ns ki nt kj nu nv bi translated">结论</h1><p id="c42d" class="pw-post-body-paragraph lc ld in le b lf nw jx lh li nx ka lk ll ny ln lo lp nz lr ls lt oa lv lw lx ig bi translated">这些原则帮助您将测试提升到下一个水平。需要TDD、BDD、SOLID和其他伟大原则和技术来改进你的单元测试和所有代码，做出改变，继续阅读和学习。</p><p id="a99b" class="pw-post-body-paragraph lc ld in le b lf lg jx lh li lj ka lk ll lm ln lo lp lq lr ls lt lu lv lw lx ig bi translated">希望你喜欢这篇文章，并找到它的帮助。感谢你的阅读，如果你想改变，这里有我的文章。</p><div class="mi mj gp gr mk ml"><a href="https://medium.com/better-programming/solid-swift-by-examples-part-one-35018d53d3e6" rel="noopener follow" target="_blank"><div class="mm ab fo"><div class="mn ab mo cl cj mp"><h2 class="bd ix gy z fp mq fr fs mr fu fw iw bi translated">稳固和单一责任原则</h2><div class="ms l"><h3 class="bd b gy z fp mq fr fs mr fu fw dk translated">坚固的雨燕</h3></div><div class="mt l"><p class="bd b dl z fp mq fr fs mr fu fw dk translated">medium.com</p></div></div><div class="mu l"><div class="ob l mw mx my mu mz kv ml"/></div></div></a></div><h1 id="7a2d" class="ne nf in bd ng nh ni nj nk nl nm nn no kc np kd nq kf nr kg ns ki nt kj nu nv bi translated">参考</h1><div class="mi mj gp gr mk ml"><a href="https://xp123.com/articles/3a-arrange-act-assert/" rel="noopener  ugc nofollow" target="_blank"><div class="mm ab fo"><div class="mn ab mo cl cj mp"><h2 class="bd ix gy z fp mq fr fs mr fu fw iw bi translated">3A -安排、行动、断言</h2><div class="ms l"><h3 class="bd b gy z fp mq fr fs mr fu fw dk translated">一些单元测试是集中的，其他的就像一个连续的句子。我们如何创建集中的和交流的测试…</h3></div><div class="mt l"><p class="bd b dl z fp mq fr fs mr fu fw dk translated">xp123.com</p></div></div></div></a></div><div class="mi mj gp gr mk ml"><a href="https://cucumber.io" rel="noopener  ugc nofollow" target="_blank"><div class="mm ab fo"><div class="mn ab mo cl cj mp"><h2 class="bd ix gy z fp mq fr fs mr fu fw iw bi translated">面向团队的BDD测试和协作工具| Cucumber</h2><div class="ms l"><h3 class="bd b gy z fp mq fr fs mr fu fw dk translated">很简单。无论是开源还是商用，我们的协作工具都将提升您的工程团队的绩效…</h3></div><div class="mt l"><p class="bd b dl z fp mq fr fs mr fu fw dk translated">cucumber.io</p></div></div><div class="mu l"><div class="oc l mw mx my mu mz kv ml"/></div></div></a></div><div class="mi mj gp gr mk ml"><a href="https://dannorth.net/introducing-bdd/" rel="noopener  ugc nofollow" target="_blank"><div class="mm ab fo"><div class="mn ab mo cl cj mp"><h2 class="bd ix gy z fp mq fr fs mr fu fw iw bi translated">BDD简介</h2><div class="ms l"><h3 class="bd b gy z fp mq fr fs mr fu fw dk translated">历史:这篇文章最早出现在2006年3月的Better Software杂志上。翻译链接在…的末尾</h3></div><div class="mt l"><p class="bd b dl z fp mq fr fs mr fu fw dk translated">dannorth.net</p></div></div><div class="mu l"><div class="od l mw mx my mu mz kv ml"/></div></div></a></div><div class="mi mj gp gr mk ml"><a href="https://martinfowler.com/bliki/GivenWhenThen.html" rel="noopener  ugc nofollow" target="_blank"><div class="mm ab fo"><div class="mn ab mo cl cj mp"><h2 class="bd ix gy z fp mq fr fs mr fu fw iw bi translated">布利基:给我什么</h2><div class="ms l"><h3 class="bd b gy z fp mq fr fs mr fu fw dk translated">Given-When-Then是一种表示测试的风格——或者如它的拥护者所说——使用…</h3></div><div class="mt l"><p class="bd b dl z fp mq fr fs mr fu fw dk translated">martinfowler.com</p></div></div><div class="mu l"><div class="oe l mw mx my mu mz kv ml"/></div></div></a></div><div class="mi mj gp gr mk ml"><a href="https://github.com/net-a-porter-mobile/XCTest-Gherkin" rel="noopener  ugc nofollow" target="_blank"><div class="mm ab fo"><div class="mn ab mo cl cj mp"><h2 class="bd ix gy z fp mq fr fs mr fu fw iw bi translated">移动电话/XCTest-小黄瓜</h2><div class="ms l"><h3 class="bd b gy z fp mq fr fs mr fu fw dk translated">在net-a-porter，我们传统上使用Cucumber和Appium进行UI测试，这两个工具工作得很好，并且…</h3></div><div class="mt l"><p class="bd b dl z fp mq fr fs mr fu fw dk translated">github.com</p></div></div><div class="mu l"><div class="of l mw mx my mu mz kv ml"/></div></div></a></div><div class="mi mj gp gr mk ml"><a href="https://developer.apple.com/videos/play/wwdc2017/414/" rel="noopener  ugc nofollow" target="_blank"><div class="mm ab fo"><div class="mn ab mo cl cj mp"><h2 class="bd ix gy z fp mq fr fs mr fu fw iw bi translated">可测性工程- WWDC 2017 -视频-苹果开发者</h2><div class="ms l"><h3 class="bd b gy z fp mq fr fs mr fu fw dk translated">单元测试是持续验证您的代码工作正常的必要工具。探索设计技巧…</h3></div><div class="mt l"><p class="bd b dl z fp mq fr fs mr fu fw dk translated">developer.apple.com</p></div></div><div class="mu l"><div class="og l mw mx my mu mz kv ml"/></div></div></a></div><div class="mi mj gp gr mk ml"><a href="https://academy.realm.io/posts/cmdu-michael-may-testing-untested-app/" rel="noopener  ugc nofollow" target="_blank"><div class="mm ab fo"><div class="mn ab mo cl cj mp"><h2 class="bd ix gy z fp mq fr fs mr fu fw iw bi translated">测试未经测试的应用程序</h2><div class="ms l"><h3 class="bd b gy z fp mq fr fs mr fu fw dk translated">在这个CMD+U会议现场编码演示中，Michael May展示了开始测试没有现有代码的技术…</h3></div><div class="mt l"><p class="bd b dl z fp mq fr fs mr fu fw dk translated">学院.领域. io</p></div></div><div class="mu l"><div class="oh l mw mx my mu mz kv ml"/></div></div></a></div></div></div>    
</body>
</html>