<html>
<head>
<title>Build a JSON Body-Parsing Middleware in Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在 Node.js 中构建一个 JSON 主体解析中间件</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/build-a-json-body-parsing-middleware-in-node-js-14f7d7ca9bb?source=collection_archive---------1-----------------------#2022-12-07">https://blog.devgenius.io/build-a-json-body-parsing-middleware-in-node-js-14f7d7ca9bb?source=collection_archive---------1-----------------------#2022-12-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="c8d8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">🚀<a class="ae kl" href="https://learnbackend.dev/books/build-layered-microservices" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">打造分层微服务</strong> </a>这本书出来了！现在就在 learnbackend.dev 上购买你自己的副本。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/7d2d03b93511d292085ec17b39f19e0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0Xzj-O3uRQ_uiOcLzbCPXA.jpeg"/></div></div></figure><p id="85e3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在 Express 中，中间件是一种特殊类型的功能，允许在传入的 HTTP 请求到达控制器之前拦截它们。它可以用于各种各样的事情，比如记录请求、验证头、解析有效负载等等。</p><p id="7d80" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本文中，您将学习如何构建一个 JSON 主体解析中间件，该中间件模仿 Express 提供的中间件的行为。</p><h1 id="8c19" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">Express JSON 主体解析中间件</h1><p id="d72f" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">Express 提供的<code class="fe mb mc md me b">json()</code>内置中间件函数使用 JSON 有效负载解析传入的请求。它在<code class="fe mb mc md me b">request</code>对象(即<code class="fe mb mc md me b">req.body</code>)上添加一个新的包含解析数据的<code class="fe mb mc md me b">body</code>对象，或者添加一个空对象(<code class="fe mb mc md me b">{}</code>)，如果没有要解析的主体、<code class="fe mb mc md me b">Content-Type</code>不匹配(即<code class="fe mb mc md me b">application/json</code>)或者出现错误。</p><pre class="kn ko kp kq gt mf me mg bn mh mi bi"><span id="0283" class="mj kz iq me b be mk ml l mm mn">const { json } = require('express');<br/><br/>app.post('/', json(), (req, res) =&gt; {<br/>  console.log(req.body);<br/>  // ...<br/>});</span></pre><h1 id="a971" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">中间件框架</h1><p id="8ac1" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">让我们首先创建一个名为<code class="fe mb mc md me b">parseJSON</code>的中间件函数，它:</p><ul class=""><li id="1696" class="mo mp iq jp b jq jr ju jv jy mq kc mr kg ms kk mt mu mv mw bi translated">向包含空对象的请求对象添加新的<code class="fe mb mc md me b">body</code>属性。</li><li id="61bf" class="mo mp iq jp b jq mx ju my jy mz kc na kg nb kk mt mu mv mw bi translated">调用<code class="fe mb mc md me b">next()</code>处理程序，该处理程序将请求转发给中间件堆栈的下一个组件。</li></ul><pre class="kn ko kp kq gt mf me mg bn mh mi bi"><span id="85c4" class="mj kz iq me b be mk ml l mm mn">function parseJSON(req, res, next) {<br/>  req.body = {};<br/>  next();<br/>}</span></pre><h1 id="6fe9" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">验证有效负载编码</h1><p id="724f" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">现在，让我们通过将请求对象的<code class="fe mb mc md me b">headers</code>属性中包含的<code class="fe mb mc md me b">Content-Type</code>头的值与 JSON 媒体类型(也称为 MIME 类型)进行匹配来验证有效负载编码，JSON 媒体类型是<code class="fe mb mc md me b">application/json</code>。</p><pre class="kn ko kp kq gt mf me mg bn mh mi bi"><span id="5d4b" class="mj kz iq me b be mk ml l mm mn">function parseJSON(req, res, next) {<br/>  req.body = {};<br/><br/>  if (req.headers['content-type'] === 'application/json') {<br/>    // ...<br/>  }<br/><br/>  next();<br/>}</span></pre><h1 id="2548" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">收集有效载荷块</h1><p id="bbfd" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">由于 HTTP 消息的内容在某些情况下可能非常庞大，如图像或视频，因此通常会被分解成几个数据块，一个接一个地发送。</p><p id="5773" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了收集这些数据块，我们必须设置两个独立的事件监听器:</p><ul class=""><li id="232c" class="mo mp iq jp b jq jr ju jv jy mq kc mr kg ms kk mt mu mv mw bi translated">一个将监听一个<code class="fe mb mc md me b">data</code>事件，并将接收到的块连接到前一个。</li><li id="3ed7" class="mo mp iq jp b jq mx ju my jy mz kc na kg nb kk mt mu mv mw bi translated">一个将监听表示数据流结束的<code class="fe mb mc md me b">end</code>事件。</li></ul><pre class="kn ko kp kq gt mf me mg bn mh mi bi"><span id="17a9" class="mj kz iq me b be mk ml l mm mn">function parseJSON(req, res, next) {<br/>  req.body = {};<br/><br/>  if (req.headers['content-type'] === 'application/json') {<br/>    let data = '';<br/><br/>    req.on('data', chunk =&gt; {<br/>      data += chunk;<br/>    });<br/><br/>    req.on('end', () =&gt; {<br/>      // ...<br/>    });<br/>  }<br/><br/>  next();<br/>}</span></pre><h1 id="1615" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">解析有效负载</h1><p id="153e" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">一旦接收到所有的原始数据，我们需要解析它，这意味着将它转换成应用程序可以处理的格式。在 JavaScript 中，可以使用内置的<code class="fe mb mc md me b">JSON.parse()</code>方法将 JSON 字符串转换成数据对象。</p><pre class="kn ko kp kq gt mf me mg bn mh mi bi"><span id="c15f" class="mj kz iq me b be mk ml l mm mn">function parseJSON(req, res, next) {<br/>  req.body = {};<br/><br/>  if (req.headers['content-type'] === 'application/json') {<br/>    let data = '';<br/><br/>    req.on('data', chunk =&gt; {<br/>      data += chunk;<br/>    });<br/><br/>    req.on('end', () =&gt; {<br/>      req.body = JSON.parse(data);<br/>    });<br/>  }<br/><br/>  next();<br/>}</span></pre><h1 id="c780" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">改变函数的流程</h1><p id="e2f6" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">由于事件监听器本质上是异步的——由于它们使用回调函数——我们需要稍微改变中间件函数的流程，以确保在接收到所有数据之前不会调用<code class="fe mb mc md me b">next()</code>处理程序。</p><p id="e883" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为此，让我们:</p><ul class=""><li id="7f30" class="mo mp iq jp b jq jr ju jv jy mq kc mr kg ms kk mt mu mv mw bi translated">将现有的调用转移到<code class="fe mb mc md me b">else</code>语句中的<code class="fe mb mc md me b">next()</code>,这样只有在<code class="fe mb mc md me b">Content-Type</code>头与预期的 MIME 类型不匹配时才会被调用。</li><li id="b5e7" class="mo mp iq jp b jq mx ju my jy mz kc na kg nb kk mt mu mv mw bi translated">在负责处理<code class="fe mb mc md me b">end</code>事件的事件监听器的回调函数中添加另一个对<code class="fe mb mc md me b">next()</code>的调用，这样它只在数据被解析后被调用。</li></ul><pre class="kn ko kp kq gt mf me mg bn mh mi bi"><span id="3e7d" class="mj kz iq me b be mk ml l mm mn">function parseJSON(req, res, next) {<br/>  req.body = {};<br/><br/>  if (req.headers['content-type'] === 'application/json') {<br/>    let data = '';<br/><br/>    req.on('data', chunk =&gt; {<br/>      data += chunk;<br/>    });<br/><br/>    req.on('end', () =&gt; {<br/>      req.body = JSON.parse(data);<br/>      next();<br/>    });<br/>  } else {<br/>    next();<br/>  }<br/>}</span></pre><h1 id="b865" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">处理解析错误</h1><p id="c3df" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">如果出现格式错误的数据，默认情况下，内置的<code class="fe mb mc md me b">JSON.parse()</code>将抛出一个<code class="fe mb mc md me b">SyntaxError</code>，如果处理不当，将导致应用程序崩溃。为了解决这个问题，我们可以添加一个<code class="fe mb mc md me b">try…catch</code>块来捕捉错误并调用<code class="fe mb mc md me b">next()</code>处理程序。</p><pre class="kn ko kp kq gt mf me mg bn mh mi bi"><span id="e78f" class="mj kz iq me b be mk ml l mm mn">function parseJSON(req, res, next) {<br/>  req.body = {};<br/><br/>  if (req.headers['content-type'] === 'application/json') {<br/>    let data = '';<br/><br/>    req.on('data', chunk =&gt; {<br/>      data += chunk;<br/>    });<br/><br/>    req.on('end', () =&gt; {<br/>      try {<br/>        req.body = JSON.parse(data);<br/>        next();<br/>      } catch(error) {<br/>        next();<br/>      }<br/>    });<br/>  } else {<br/>    next();<br/>  }<br/>}</span></pre><p id="cb7c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">或者，我们可以通过使用一个<code class="fe mb mc md me b">finally</code>语句来避免重复并以一种更优雅的方式处理错误，无论是否抛出错误，该语句都会被调用。</p><pre class="kn ko kp kq gt mf me mg bn mh mi bi"><span id="7401" class="mj kz iq me b be mk ml l mm mn">function parseJSON(req, res, next) {<br/>  req.body = {};<br/><br/>  if (req.headers['content-type'] === 'application/json') {<br/>    let data = '';<br/><br/>    req.on('data', chunk =&gt; {<br/>      data += chunk;<br/>    });<br/><br/>    req.on('end', () =&gt; {<br/>      try {<br/>        req.body = JSON.parse(data);<br/>      } catch(error) {<br/>        // Ignore the error<br/>      } finally {<br/>        next();<br/>      }<br/>    });<br/>  } else {<br/>    next();<br/>  }<br/>}</span></pre><h1 id="199f" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">测试中间件</h1><p id="9257" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">让我们从导出<code class="fe mb mc md me b">parseJSON()</code>中间件函数开始。</p><pre class="kn ko kp kq gt mf me mg bn mh mi bi"><span id="eb6e" class="mj kz iq me b be mk ml l mm mn">function parseJSON(req, res, next) {<br/>  // ...<br/>}<br/><br/>module.exports = parseJSON;</span></pre><p id="fca2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">并将其导入到 minimal Express 应用程序中。</p><pre class="kn ko kp kq gt mf me mg bn mh mi bi"><span id="bdf9" class="mj kz iq me b be mk ml l mm mn">const express = require('express');<br/>const parseJSON = require('./parseJSON');<br/><br/>const app = express();<br/><br/>app.post('/', parseJSON, (req, res) =&gt; {<br/>  console.log(req.body);<br/>  res.sendStatus(200);<br/>});<br/><br/>app.listen(3000);</span></pre><p id="a1e7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了验证中间件的行为符合预期，我们现在可以使用<code class="fe mb mc md me b">cURL</code>来发送:</p><p id="abe5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">带有无效<code class="fe mb mc md me b">Content-Type</code>标头的请求；其中应该输出一个空对象(即<code class="fe mb mc md me b">{}</code>)。</p><pre class="kn ko kp kq gt mf me mg bn mh mi bi"><span id="037d" class="mj kz iq me b be mk ml l mm mn">curl -X POST -H 'Content-Type: text/plain' -d '{"name":"John"}' 127.0.0.1:3000</span></pre><p id="bb40" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">具有无效负载的请求；其中应该输出一个空对象(即<code class="fe mb mc md me b">{}</code>)。</p><pre class="kn ko kp kq gt mf me mg bn mh mi bi"><span id="a7da" class="mj kz iq me b be mk ml l mm mn">curl -X POST -H 'Content-Type: application/json' -d 'name=John' 127.0.0.1:3000</span></pre><p id="3570" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">具有有效<code class="fe mb mc md me b">Content-Type</code>报头和有效有效载荷的请求；它应该输出一个填充的对象(即<code class="fe mb mc md me b">{ name: 'John' }</code>)。</p><pre class="kn ko kp kq gt mf me mg bn mh mi bi"><span id="18d0" class="mj kz iq me b be mk ml l mm mn">curl -X POST -H 'Content-Type: application/json' -d '{"name":"John"}' 127.0.0.1:3000</span></pre><h1 id="8d32" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">下一步是什么？</h1><p id="f8eb" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">👉你喜欢这种内容？在<a class="ae kl" href="https://learnbackend.dev/" rel="noopener ugc nofollow" target="_blank"> https://learnbackend.dev </a>查看《如何使用 Express framework 构建生产就绪的分层认证微服务》一书<a class="ae kl" href="https://learnbackend.dev/books/build-layered-microservices" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">构建分层微服务</strong> </a>，该书从第一行代码到最后一行文档都符合开发实践和软件架构方面的行业标准。</p></div></div>    
</body>
</html>