<html>
<head>
<title>Finite Automata: Simulate a DFA in Python 🐍</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">有限自动机:用Python模拟一个DFA🐍</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/finite-automata-implement-a-dfa-in-python-64dc3d7005d9?source=collection_archive---------3-----------------------#2022-01-07">https://blog.devgenius.io/finite-automata-implement-a-dfa-in-python-64dc3d7005d9?source=collection_archive---------3-----------------------#2022-01-07</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="8a71" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">有限自动机及其类型、模拟和应用。</h2></div><p id="341e" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在我们的日常生活中，我们会遇到各种基于状态的系统。这些系统根据给它们的一系列输入产生一个输出。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi ky"><img src="../Images/f003314e562f9aa04df4f7f75de157e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ATekKIyMj5veEDkDy8EwwA.png"/></div></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk translated">交通灯的一个可能的状态图</figcaption></figure><p id="fea7" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一些实例包括交通灯、电梯、自动售货机。这样，系统在逻辑上可以表示为<strong class="ke io"> <em class="lo">有限自动机</em> </strong>。</p><h1 id="ffa7" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated"><strong class="ak">目录</strong></h1><blockquote class="mh mi mj"><p id="8a90" class="kc kd lo ke b kf kg jo kh ki kj jr kk mk km kn ko ml kq kr ks mm ku kv kw kx ig bi translated">-什么是有限自动机？</p><p id="a0cd" class="kc kd lo ke b kf kg jo kh ki kj jr kk mk km kn ko ml kq kr ks mm ku kv kw kx ig bi translated">-有限自动机的类型。</p><p id="b6bb" class="kc kd lo ke b kf kg jo kh ki kj jr kk mk km kn ko ml kq kr ks mm ku kv kw kx ig bi translated">- DFA实现。</p><p id="ec34" class="kc kd lo ke b kf kg jo kh ki kj jr kk mk km kn ko ml kq kr ks mm ku kv kw kx ig bi translated">-有限自动机的应用。</p></blockquote><h1 id="df76" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">什么是有限自动机？</h1><p id="fc63" class="pw-post-body-paragraph kc kd in ke b kf mn jo kh ki mo jr kk kl mp kn ko kp mq kr ks kt mr kv kw kx ig bi translated">有限自动机(也叫有限状态自动机)是一种抽象机器，由有限个状态组成。他们一次只能处于其中一种状态。当给定输入时，状态发生变化。并且，根据当前状态和输入，机器转换到新状态。</p><p id="a0d6" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">有限自动机是<strong class="ke io">形式上定义</strong>为5元组(<em class="lo"> Q </em>，σ，<em class="lo"> δ </em>，<em class="lo"> q </em> 0，<em class="lo"> F </em>)，其中，</p><ul class=""><li id="31fb" class="ms mt in ke b kf kg ki kj kl mu kp mv kt mw kx mx my mz na bi translated"><em class="lo"> Q </em>是<strong class="ke io">状态</strong>的有限集</li><li id="74f8" class="ms mt in ke b kf nb ki nc kl nd kp ne kt nf kx mx my mz na bi translated">σ是输入符号的有限集合(称为<strong class="ke io">字母</strong></li><li id="b057" class="ms mt in ke b kf nb ki nc kl nd kp ne kt nf kx mx my mz na bi translated"><em class="lo"> δ </em>是一个<strong class="ke io">过渡</strong>函数</li><li id="725e" class="ms mt in ke b kf nb ki nc kl nd kp ne kt nf kx mx my mz na bi translated"><em class="lo"> q0 </em>是<strong class="ke io">开始状态</strong></li><li id="405c" class="ms mt in ke b kf nb ki nc kl nd kp ne kt nf kx mx my mz na bi translated"><em class="lo"> F </em>是<strong class="ke io">接受状态</strong>的有限集</li></ul><figure class="kz la lb lc gt ld gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/8f5e3349335b26472301453430f8df08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*3MZqgm93Y2OBCFR7.png"/></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk translated">自动机的类型(来源:<a class="ae nh" href="https://en.wikipedia.org/wiki/Finite-state_machine" rel="noopener ugc nofollow" target="_blank">维基百科</a>)</figcaption></figure><h2 id="0abc" class="ni lq in bd lr nj nk dn lv nl nm dp lz kl nn no mb kp np nq md kt nr ns mf nt bi translated">有限自动机的类型</h2><ol class=""><li id="ae09" class="ms mt in ke b kf mn ki mo kl nu kp nv kt nw kx nx my mz na bi translated">确定性有限自动机</li><li id="ffe1" class="ms mt in ke b kf nb ki nc kl nd kp ne kt nf kx nx my mz na bi translated">非确定性有限自动机(NDFA或NFA)</li></ol><h2 id="06cf" class="ni lq in bd lr nj nk dn lv nl nm dp lz kl nn no mb kp np nq md kt nr ns mf nt bi translated">作为DFA的自动售货机</h2><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi ny"><img src="../Images/5dfa06460535069d57f920fbace5c575.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9t97TFbj079qeHkj-wn6DQ.png"/></div></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk translated">自动售货机DFA ( <a class="ae nh" href="https://www.cs.ucdavis.edu/~rogaway/classes/120/spring13/eric-dfa.pdf" rel="noopener ugc nofollow" target="_blank">来源</a>)</figcaption></figure><p id="ecfd" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">自动售货机的功能可以表示为DFA。这里，状态指的是进入自动售货机的钱数，即<strong class="ke io"><em class="lo"/></strong><em class="lo">。</em></p><p id="6ae5" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">增加更多的钱更新状态。一旦有足够的余额，就可以购买物品。这也伴随着一种状态变化，即从余额中减去项目的价格。</p></div><div class="ab cl nz oa hr ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="ig ih ii ij ik"><h1 id="3faa" class="lp lq in bd lr ls og lu lv lw oh ly lz jt oi ju mb jw oj jx md jz ok ka mf mg bi translated">DFA实现</h1><p id="57a4" class="pw-post-body-paragraph kc kd in ke b kf mn jo kh ki mo jr kk kl mp kn ko kp mq kr ks kt mr kv kw kx ig bi translated">我们将创建一个简单的DFA实现，这样我们就可以构造DFA并根据输入字符串测试它们。</p><h2 id="7ef9" class="ni lq in bd lr nj nk dn lv nl nm dp lz kl nn no mb kp np nq md kt nr ns mf nt bi translated">声明和定义变量</h2><p id="d80d" class="pw-post-body-paragraph kc kd in ke b kf mn jo kh ki mo jr kk kl mp kn ko kp mq kr ks kt mr kv kw kx ig bi translated">由于DFA是使用五元组(<em class="lo"> Q </em>，σ，<em class="lo"> δ </em>，<em class="lo"> q </em> 0，<em class="lo"> F </em>)定义的，我们需要将它们作为变量存储在我们的程序中。</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="fe27" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">状态(<em class="lo"> Q) </em>、字母(<em class="lo">σ)</em>和接受状态(<em class="lo"> F) </em>的集合被存储为字符串列表。</p><p id="1d16" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">转换函数(<em class="lo"> δ </em>)是一个映射的字典</p><pre class="kz la lb lc gt on oo op oq aw or bi"><span id="423a" class="ni lq in oo b gy os ot l ou ov">(current_state, current_input) ➔ <strong class="oo io">next_state</strong></span><span id="a9e6" class="ni lq in oo b gy ow ot l ou ov">e.g.<br/>    (q0, 0) ➔ q1<br/>    (q1, 1) ➔ q2</span></pre><p id="a97d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">获取前四个变量的输入很简单，需要进行一些字符串拆分。但是对于转移函数，我们需要生成<em class="lo">Q</em>×σ的所有可能组合。然后，获取每个人的输入。</p><p id="a974" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为此，我们保留了两个嵌套的<code class="fe ox oy oz oo b">for</code>循环，一个用于状态<em class="lo"> Q </em>，另一个用于字母σ。如果用户输入“.”<em class="lo">(句点)</em>作为输入，过渡将被存储为<code class="fe ox oy oz oo b">None</code>。这表明DFA已经达到失效或被拒绝的状态。</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="ol om l"/></div></figure><h2 id="da18" class="ni lq in bd lr nj nk dn lv nl nm dp lz kl nn no mb kp np nq md kt nr ns mf nt bi translated">完成和运行DFA</h2><p id="33fc" class="pw-post-body-paragraph kc kd in ke b kf mn jo kh ki mo jr kk kl mp kn ko kp mq kr ks kt mr kv kw kx ig bi translated">我们的DFA现在几乎完成了！剩下的最后一部分是获取输入字符串。</p><p id="df1a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了运行DFA，我们将<code class="fe ox oy oz oo b"><strong class="ke io">current state</strong></code>初始化为<em class="lo">开始状态</em>。然后，我们根据输入字符更新<code class="fe ox oy oz oo b"><strong class="ke io">current state</strong></code>,直到</p><ul class=""><li id="5818" class="ms mt in ke b kf kg ki kj kl mu kp mv kt mw kx mx my mz na bi translated">输入字符串终止，DFA结束接受状态(DFA <strong class="ke io">接受</strong>字符串)</li><li id="2b4a" class="ms mt in ke b kf nb ki nc kl nd kp ne kt nf kx mx my mz na bi translated">DFA达到死状态或结束于不接受状态(DFA <strong class="ke io">拒绝</strong>字符串)</li></ul><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="ol om l"/></div></figure><h2 id="b197" class="ni lq in bd lr nj nk dn lv nl nm dp lz kl nn no mb kp np nq md kt nr ns mf nt bi translated">输出</h2><p id="ce41" class="pw-post-body-paragraph kc kd in ke b kf mn jo kh ki mo jr kk kl mp kn ko kp mq kr ks kt mr kv kw kx ig bi translated">我们将使用我们的程序测试以下DFA</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/65c408a3faf47fd90c19731965a705be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*kVzLOItLohGyYDxA.png"/></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk translated">接受3的倍数的二进制数的DFA(来源:<a class="ae nh" href="https://en.wikipedia.org/wiki/Deterministic_finite_automaton" rel="noopener ugc nofollow" target="_blank">维基百科</a></figcaption></figure><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi pa"><img src="../Images/d926364726979ebb43a84ea5b0b2e347.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ShOyy_hhBpiD3s4Y13-Uow.png"/></div></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk translated">DFA接受的字符串“11”</figcaption></figure><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi pa"><img src="../Images/c903c8c0033a65ffc874a0426a09b3f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TezQWwJmxJWUMbMgkr3KwQ.png"/></div></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk translated">DFA接受的字符串“1001”</figcaption></figure></div><div class="ab cl nz oa hr ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="ig ih ii ij ik"><h1 id="f1c9" class="lp lq in bd lr ls og lu lv lw oh ly lz jt oi ju mb jw oj jx md jz ok ka mf mg bi translated">应用程序</h1><h2 id="789d" class="ni lq in bd lr nj nk dn lv nl nm dp lz kl nn no mb kp np nq md kt nr ns mf nt bi translated">正则表达式</h2><p id="e3e0" class="pw-post-body-paragraph kc kd in ke b kf mn jo kh ki mo jr kk kl mp kn ko kp mq kr ks kt mr kv kw kx ig bi translated">被有限自动机接受的语言称为<strong class="ke io">正则语言</strong>。正则表达式是用来描述正则语言的模式。</p><p id="6890" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">正则表达式定义了正则语言的结构。因此，它可以用来识别/验证给定的字符串是否遵循正式语言的规则。正则表达式<strong class="ke io">转换成有限自动机</strong>进行验证和识别。</p><blockquote class="mh mi mj"><p id="0ffa" class="kc kd lo ke b kf kg jo kh ki kj jr kk mk km kn ko ml kq kr ks mm ku kv kw kx ig bi translated"><strong class="ke io">邮件的正则表达式</strong> : <em class="in"> ^[a-zA-Z0-9+_.-]+@[a-zA-Z0-9。-]+$ </em></p></blockquote><p id="0b09" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">今天，几乎每种编程语言都提供了对正则表达式的本地支持。此外，许多<strong class="ke io">验证系统</strong>使用正则表达式。</p><h2 id="e932" class="ni lq in bd lr nj nk dn lv nl nm dp lz kl nn no mb kp np nq md kt nr ns mf nt bi translated">编译器的词法分析</h2><p id="c184" class="pw-post-body-paragraph kc kd in ke b kf mn jo kh ki mo jr kk kl mp kn ko kp mq kr ks kt mr kv kw kx ig bi translated">编译过程的第一阶段是词法分析。这里，源程序被标记化了。源程序可以有不同类型的标记，如标识符、运算符等。</p><pre class="kz la lb lc gt on oo op oq aw or bi"><span id="3c14" class="ni lq in oo b gy os ot l ou ov">def square(n):              -&gt; <em class="lo">keywords: def, return</em><br/>    return n*n              -&gt; <em class="lo">identifiers: n</em><br/>                            -&gt; <em class="lo">operators: *</em><br/>                            -&gt; <em class="lo">separators: :</em></span></pre><p id="9e99" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">设计了每种标记类型的正则表达式。然后将它们合并在一起，创建一个语言解析器。解析器然后被用来构建DFA。生成的DFA被称为<strong class="ke io">词法分析器</strong>。在词法分析中使用DFAs使得它变得简单而有效。</p><h1 id="9035" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">结论</h1><p id="0a78" class="pw-post-body-paragraph kc kd in ke b kf mn jo kh ki mo jr kk kl mp kn ko kp mq kr ks kt mr kv kw kx ig bi translated">有限自动机是灵活的系统，允许我们解析各种不同的语言。但是，由于<strong class="ke io"> <em class="lo">缺乏无限记忆</em> </strong>，他们无法识别像<a class="ae nh" href="https://en.wikipedia.org/wiki/Dyck_language" rel="noopener ugc nofollow" target="_blank">戴克语</a>这样的语言。所以，像<strong class="ke io">下推自动机</strong>、线性有界自动机、<strong class="ke io">图灵</strong> <strong class="ke io">机器</strong>这样更强大的自动机是必要的。</p><p id="9103" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是，有限自动机仍然有自己的优势。它们具有较低的处理开销，并且操作简单。因为这些原因，它们是<strong class="ke io"> <em class="lo">仍然被广泛使用的</em> </strong>。今天，它们的应用范围从网络协议、人工智能到视频游戏。</p><h2 id="fa60" class="ni lq in bd lr nj nk dn lv nl nm dp lz kl nn no mb kp np nq md kt nr ns mf nt bi translated">参考</h2><ol class=""><li id="ed3f" class="ms mt in ke b kf mn ki mo kl nu kp nv kt nw kx nx my mz na bi translated"><a class="ae nh" href="https://www.cs.ucdavis.edu/~rogaway/classes/120/spring13/eric-dfa.pdf" rel="noopener ugc nofollow" target="_blank">https://www . cs . UC Davis . edu/~ rogaway/classes/120/spring 13/Eric-DFA . pdf</a></li><li id="25ac" class="ms mt in ke b kf nb ki nc kl nd kp ne kt nf kx nx my mz na bi translated"><a class="ae nh" href="https://www.cl.cam.ac.uk/teaching/1011/RLFA/LectureNotes.pdf" rel="noopener ugc nofollow" target="_blank">https://www . cl . cam . AC . uk/teaching/1011/RLFA/lecture notes . pdf</a></li><li id="6677" class="ms mt in ke b kf nb ki nc kl nd kp ne kt nf kx nx my mz na bi translated">https://www . tutorialspoint . com/checking-for-valid-email-address-using-regular-expressions-in-Java</li></ol></div></div>    
</body>
</html>