<html>
<head>
<title>Better JavaScript — Prototypes and Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">更好的 JavaScript——原型和函数</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/better-javascript-prototypes-and-functions-18364da5913a?source=collection_archive---------5-----------------------#2020-10-16">https://blog.devgenius.io/better-javascript-prototypes-and-functions-18364da5913a?source=collection_archive---------5-----------------------#2020-10-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/f2f2bf540340594c608965ee467f911e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8zFQYruRvwMefjOk"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@veri_ivanova?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">维里·伊万诺娃</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="6c81" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像任何类型的应用程序一样，JavaScript 应用程序也必须写得很好。</p><p id="9a1d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">否则，我们以后会遇到各种各样的问题。</p><p id="96a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究改进 JavaScript 代码的方法。</p><h1 id="56cb" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">闭包比字符串更适合封装代码</h1><p id="1d3e" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们不应该在字符串中使用代码。</p><p id="e338" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们需要运行代码，我们应该把它们放在一个函数中。</p><p id="2eab" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有了<code class="fe me mf mg mh b">repeat</code>函数，我们就不应该写这样的代码:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="4e96" class="mq lc iq mh b gy mr ms l mt mu">function repeat(n, action) {<br/>  for (let i = 0; i &lt; n; i++) {<br/>    eval(action);<br/>  }<br/>}</span></pre><p id="cb51" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于安全性、性能和范围问题，总是不好。</p><p id="22e9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，我们应该写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="2750" class="mq lc iq mh b gy mr ms l mt mu">function repeat(n, action) {<br/>  for (let i = 0; i &lt; n; i++) {<br/>    action();<br/>  }<br/>}</span></pre><p id="d909" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以通过写来使用它:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="62c0" class="mq lc iq mh b gy mr ms l mt mu">const start = [];<br/>repeat(1000, () =&gt; {<br/>  start.push(Date.now());<br/>});</span></pre><p id="c61d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们传入了一个回调函数，以便在函数中运行<code class="fe me mf mg mh b">action</code>。</p><p id="deb5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">代码不应出现在字符串中。</p><p id="40dc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，它应该接受一个回调函数并运行它。</p><h1 id="9c06" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">不要依赖函数的 toString 方法</h1><p id="ce9a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe me mf mg mh b">toString</code>方法并不总是返回函数的源代码。</p><p id="4167" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于我们创建的函数，它确实会在大多数情况下返回源代码。</p><p id="0f24" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以如果我们有:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="9820" class="mq lc iq mh b gy mr ms l mt mu">(function(x) {<br/>  return x + 2;<br/>}).toString();</span></pre><p id="648d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="c0d6" class="mq lc iq mh b gy mr ms l mt mu">"function(x) {<br/>  return x + 2;<br/>}"</span></pre><p id="70ba" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">结果。</p><p id="fe42" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们在内置的本地对象上使用<code class="fe me mf mg mh b">toString</code>方法，那么我们将看不到函数的源代码。</p><p id="5dfa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="db33" class="mq lc iq mh b gy mr ms l mt mu">Math.max.toString()</span></pre><p id="6e94" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="9b7f" class="mq lc iq mh b gy mr ms l mt mu">"function max() { [native code] }"</span></pre><p id="e603" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们做一些事情，比如调用函数<code class="fe me mf mg mh b">bind</code>:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="1a85" class="mq lc iq mh b gy mr ms l mt mu">(function(x) {<br/>  return x + 2;<br/>}).bind(16).toString();</span></pre><p id="a6ab" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="3cbb" class="mq lc iq mh b gy mr ms l mt mu">"function(){return n.apply(e,t||arguments)}"</span></pre><p id="35f7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们在字符串中没有得到任何有意义的东西。</p><p id="b5cb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们不能依赖<code class="fe me mf mg mh b">toString</code>总是返回一个函数的源代码。</p><h1 id="3eb1" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">避免非标准堆栈检查属性</h1><p id="7084" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们不应该使用像<code class="fe me mf mg mh b">arguments.callee</code>这样的属性来获取调用另一个函数的函数。</p><p id="2df2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">即使属性存在，我们也不应该在属性上使用<code class="fe me mf mg mh b">caller</code>属性来获取调用该函数的函数。</p><p id="b911" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些不是标准的，应该避免。</p><p id="d853" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们应该编写这样的代码:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="a565" class="mq lc iq mh b gy mr ms l mt mu">function revealCaller() {<br/>  return revealCaller.caller;<br/>}</span></pre><p id="0d2a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些在 ES5 严格模式中都是不允许的，所以这是启用它的一个好处。</p><p id="c598" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们有:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="2050" class="mq lc iq mh b gy mr ms l mt mu">function foo() {<br/>  "use strict";<br/>  return foo.caller;<br/>}</span></pre><p id="9fe1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们得到“未捕获的类型错误:“调用者”、“被调用者”和“参数”属性不能在严格模式函数或对它们的调用的参数对象上访问”。</p><h1 id="db4f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">获取 prototype、getPrototypeOf 和 __proto__ 之间的区别</h1><p id="fe64" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">这些物体是相互分离的。</p><p id="282d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">prototype</code>和<code class="fe me mf mg mh b">__proto__</code>都是获取一个对象的原型并设置。</p><p id="7178" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而<code class="fe me mf mg mh b">getPrototypeOf</code>是获取对象原型的方法。</p><p id="e108" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">__proto__</code>已经成为一个标准，所以我们可以像<code class="fe me mf mg mh b">prototype</code>一样使用它。</p><p id="e06f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">prototype</code>通常用于举例说明方法。</p><p id="1301" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以通过编写以下代码来创建构造函数:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="af6d" class="mq lc iq mh b gy mr ms l mt mu">function Person(name) {<br/>  this.name = name;<br/>}</span><span id="ead7" class="mq lc iq mh b gy mv ms l mt mu">Person.prototype.toString = function() {<br/>  return `Person ${this.name}`;<br/>};</span></pre><p id="3035" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">toString</code>是构造函数的实例方法。</p><p id="3d3c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="cdd3" class="mq lc iq mh b gy mr ms l mt mu">const person = new Person("james");</span></pre><p id="e20c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">创建一个新的<code class="fe me mf mg mh b">Person</code>实例。</p><p id="9026" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">__proto__</code>属性可以像常规属性一样使用，所以我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="16b9" class="mq lc iq mh b gy mr ms l mt mu">person.__proto__</span></pre><p id="7bf7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">来得到这个物体的原型。</p><p id="4c03" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也可以给它赋值，并把它作为一个对象的属性。</p><p id="8e70" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">Object.getPrototypeOf</code>可以用来得到一个对象的原型，所以我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="9a8d" class="mq lc iq mh b gy mr ms l mt mu">Object.getPrototypeOf(person)</span></pre><p id="0495" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">得到原型。</p><p id="c1b3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">原型是一个对象从其继承的 JavaScript 对象。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/ebc5a3a17c5ea4122e43b68c4f399af5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jcIkEYk4MTGj2T8H"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">亚历克斯·哈维的照片🤙🏻 on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></figcaption></figure><h1 id="5bc4" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="4496" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们不应该在代码中以字符串的形式运行代码。</p><p id="773a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，我们不应该在代码中使用<code class="fe me mf mg mh b">caller</code>和<code class="fe me mf mg mh b">callee</code>。</p><p id="1bd1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过各种方式获取和设置对象原型。</p></div></div>    
</body>
</html>