<html>
<head>
<title>Caching Strategy 101</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">缓存策略 101</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/caching-strategy-101-3bc974d2a6cd?source=collection_archive---------3-----------------------#2022-06-12">https://blog.devgenius.io/caching-strategy-101-3bc974d2a6cd?source=collection_archive---------3-----------------------#2022-06-12</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="6caf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这篇博客是我们从零开始讨论 101 个<strong class="jm io"> </strong>概念的系列文章的一部分，读者的入门知识有限。这篇文章属于<strong class="jm io"> <em class="ki">中级</em> </strong>系列，因为它涉及理解<strong class="jm io">缓存策略的</strong>，该策略主要用于优化对业务数据的读取访问，以获得更好的端到端用户延迟。</p><p id="1bc5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">101 系列中的一些早期博客如下:</p><p id="efbc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae kj" rel="noopener ugc nofollow" target="_blank" href="/cors-101-72b462396deb"><strong class="jm io">CORS 101</strong></a><strong class="jm io"><br/></strong><a class="ae kj" rel="noopener ugc nofollow" target="_blank" href="/circuit-breaker-pattern-101-be2d7fdb656"><strong class="jm io">断路器 101 </strong> <br/> </a> <a class="ae kj" rel="noopener ugc nofollow" target="_blank" href="/priority-queues-101-40eb4f6f5ee9"> <strong class="jm io">优先级队列 101 </strong> </a> <a class="ae kj" rel="noopener ugc nofollow" target="_blank" href="/async-communication-101-b04d5c95333a"> <strong class="jm io"> <br/>异步通信 101</strong></a><strong class="jm io"><br/></strong><a class="ae kj" rel="noopener ugc nofollow" target="_blank" href="/database-design-101-7c019d69b97f"><strong class="jm io">数据库设计 101 </strong> </a></p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div class="gh gi kk"><img src="../Images/b850e176d49e5c50ba38b942448082cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1326/format:webp/1*1xRY2F3tKU3RZoh6tFEc5A.jpeg"/></div></figure><h1 id="3abb" class="ks kt in bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">什么是缓存？</h1><p id="ae31" class="pw-post-body-paragraph jk jl in jm b jn lq jp jq jr lr jt ju jv ls jx jy jz lt kb kc kd lu kf kg kh ig bi translated">正如在早先的博客— <a class="ae kj" rel="noopener ugc nofollow" target="_blank" href="/caching-101-634ef4f8ed1b"> <strong class="jm io">缓存 101 </strong> </a>中所解释的，缓存是一个过程，通过该过程，通过在被称为缓存的存储位置(<strong class="jm io"> <em class="ki">【本地/远程】</em> </strong>)存储多个副本来优化对数据<strong class="jm io"> <em class="ki">(文件、图像、脚本等)</em> </strong> <em class="ki"> </em>的读访问。为了更好地理解缓存工作的基本原理，建议重温以前的博客。在这种情况下，我们将讨论将缓存作为业务应用程序整体架构的一部分来实现的常见设计模式。</p><h1 id="09d0" class="ks kt in bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">缓存命中和缓存未命中</h1><p id="d224" class="pw-post-body-paragraph jk jl in jm b jn lq jp jq jr lr jt ju jv ls jx jy jz lt kb kc kd lu kf kg kh ig bi translated">所有读取事件都可以根据要获取的键在整个应用程序设计中的位置分为两种类型</p><ul class=""><li id="fe07" class="lv lw in jm b jn jo jr js jv lx jz ly kd lz kh ma mb mc md bi translated"><strong class="jm io">缓存命中</strong> —数据驻留在本地/远程缓存服务器中，这种情况下避免了对数据库服务器的冗余调用。</li><li id="99b7" class="lv lw in jm b jn me jr mf jv mg jz mh kd mi kh ma mb mc md bi translated"><strong class="jm io">缓存未命中- </strong>数据仅驻留在数据库服务器中，因此应用程序必须进行额外的网络调用来获取数据。根据所选择的缓存策略，可以通过多种方式将数据更新回缓存服务器。</li></ul><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi mj"><img src="../Images/4dd7619328e6610bab7b3e46c6c28399.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lYVUNWRDS0YgJVvXyUEYJg.jpeg"/></div></div></figure><h1 id="5da0" class="ks kt in bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">缓存策略</h1><p id="9909" class="pw-post-body-paragraph jk jl in jm b jn lq jp jq jr lr jt ju jv ls jx jy jz lt kb kc kd lu kf kg kh ig bi translated">根据数据何时加载到高速缓存中，即在读取操作之前预填充，还是在运行时发生<strong class="jm io">高速缓存未命中事件</strong>，我们有不同的设计策略。我们将讨论最常见的原则，因为总体设计中的实际实现是以下原则的变体和组合。</p><h2 id="177d" class="mo kt in bd ku mp mq dn ky mr ms dp lc jv mt mu lg jz mv mw lk kd mx my lo mz bi translated">缓存备用模式</h2><figure class="kl km kn ko gt kp gh gi paragraph-image"><div class="gh gi na"><img src="../Images/82490322162d3bce3497f8d4a1df5423.png" data-original-src="https://miro.medium.com/v2/resize:fit:1262/format:webp/1*qgDEePP0kh_ZOb2zuNpr_w.jpeg"/></div></figure><h2 id="ca96" class="mo kt in bd ku mp mq dn ky mr ms dp lc jv mt mu lg jz mv mw lk kd mx my lo mz bi translated"><strong class="ak">顺序流程</strong></h2><ol class=""><li id="a89f" class="lv lw in jm b jn lq jr lr jv nb jz nc kd nd kh ne mb mc md bi translated">应用程序检查缓存服务器中的读取数据。如果存在，则发生<strong class="jm io">缓存命中</strong>事件。</li><li id="b49e" class="lv lw in jm b jn me jr mf jv mg jz mh kd mi kh ne mb mc md bi translated">在<strong class="jm io">缓存未命中</strong>事件的情况下，从数据库中读取数据以查询业务流。</li><li id="67fc" class="lv lw in jm b jn me jr mf jv mg jz mh kd mi kh ne mb mc md bi translated">读操作后，应用程序使用写操作将数据更新回缓存服务器。</li></ol><p id="6901" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在上述惰性加载模式的变体中，高速缓存服务器代替应用服务器负责在高速缓存未命中的情况下填充数据，并且被称为<a class="ae kj" href="https://vijayt.com/post/cache-aside-vs-read-through-cache/" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io">读通高速缓存。</strong>T11】</a></p><h2 id="6726" class="mo kt in bd ku mp mq dn ky mr ms dp lc jv mt mu lg jz mv mw lk kd mx my lo mz bi translated">用例</h2><p id="1a6b" class="pw-post-body-paragraph jk jl in jm b jn lq jp jq jr lr jt ju jv ls jx jy jz lt kb kc kd lu kf kg kh ig bi translated">缓存预留技术主要用于<strong class="jm io">读取繁重的工作负载</strong>，在这种情况下，整个系统可以承受缓存故障和停机。使用延迟加载缓存策略可以改善<em class="ki">数据库创建和更新操作</em>的整体写入延迟，主要用于具有频繁写入操作的应用程序设计。</p><p id="6f96" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然而，使用这种实现的主要缺点是初始客户的第一次缓存未命中和降低的读取性能。</p><h2 id="4352" class="mo kt in bd ku mp mq dn ky mr ms dp lc jv mt mu lg jz mv mw lk kd mx my lo mz bi translated">直写模式</h2><figure class="kl km kn ko gt kp gh gi paragraph-image"><div class="gh gi na"><img src="../Images/54c0a0b900bc6cf4941703196e30769d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1262/format:webp/1*MD-m7EplOfODFgTnAIHbbw.jpeg"/></div></figure><h2 id="314a" class="mo kt in bd ku mp mq dn ky mr ms dp lc jv mt mu lg jz mv mw lk kd mx my lo mz bi translated"><strong class="ak">顺序流程</strong></h2><ol class=""><li id="44fc" class="lv lw in jm b jn lq jr lr jv nb jz nc kd nd kh ne mb mc md bi translated">应用程序检查缓存服务器中的读取数据。如果存在，则发生<strong class="jm io">缓存命中</strong>事件。</li><li id="2c78" class="lv lw in jm b jn me jr mf jv mg jz mh kd mi kh ne mb mc md bi translated">在<strong class="jm io">缓存更新</strong>事件的情况下，应用程序从外部源读取数据并首先更新缓存。</li><li id="dcb9" class="lv lw in jm b jn me jr mf jv mg jz mh kd mi kh ne mb mc md bi translated">更新缓存操作后，相同的数据副本被写回数据库，以与数据库保持一致——事实的来源。</li></ol><p id="2dcc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">写缓存有变化— <a class="ae kj" href="https://www.geeksforgeeks.org/differentiate-between-write-through-and-write-back-methods/" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io">回写缓存</strong> </a> <strong class="jm io">、</strong>其中<strong class="jm io"> </strong>数据库更新发生在额外的延迟之后，以避免写操作中的延迟。<a class="ae kj" href="https://shahriar.svbtle.com/Understanding-writethrough-writearound-and-writeback-caching-with-python" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io">写绕缓存</strong> </a> <strong class="jm io">，</strong>其中只有读取数据的子集被更新回缓存，而不是整个数据集。</p><h2 id="e75f" class="mo kt in bd ku mp mq dn ky mr ms dp lc jv mt mu lg jz mv mw lk kd mx my lo mz bi translated">用例</h2><p id="c0b4" class="pw-post-body-paragraph jk jl in jm b jn lq jp jq jr lr jt ju jv ls jx jy jz lt kb kc kd lu kf kg kh ig bi translated"><strong class="jm io">直写缓存</strong>建议用于对数据集进行非频繁写入更新的业务用例。考虑到额外的<em class="ki">往返延迟</em>，这种缓存类型建议将直写缓存与<strong class="jm io">读缓存</strong>配对，以平衡最终用户的<em class="ki">可靠性和性能需求</em>。</p><h1 id="5a54" class="ks kt in bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">摘要</h1><p id="f7db" class="pw-post-body-paragraph jk jl in jm b jn lq jp jq jr lr jt ju jv ls jx jy jz lt kb kc kd lu kf kg kh ig bi translated">缓存为额外的系统设计层提供服务，以提高整体<em class="ki">应用性能</em>，因此对于克服网络传输瓶颈至关重要。如果数据集很小，数据结构简单，并且对业务流程不重要，还建议在应用服务器上使用内存缓存。对于<strong class="jm io">大规模分布式系统</strong>，不是坚持一个适合所有<strong class="jm io">的缓存策略</strong>,<em class="ki">功能架构</em>应该是灵活的，允许缓存的多种变化，这取决于整个时间段内读写操作的频率。</p><p id="0463" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ki">如需反馈，请留言至</em><strong class="jm io"><em class="ki">Amit[dot]894[at]Gmail[dot]com</em></strong><em class="ki">或联系</em><a class="ae kj" href="https://about.me/amit_raj" rel="noopener ugc nofollow" target="_blank"><em class="ki">https://about.me/amit_raj</em></a><em class="ki">的任何链接。</em></p></div></div>    
</body>
</html>