<html>
<head>
<title>Algorithms: What is Recursion?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">算法:什么是递归？</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/algorithms-what-is-recursion-ddaac64e2e03?source=collection_archive---------18-----------------------#2020-06-06">https://blog.devgenius.io/algorithms-what-is-recursion-ddaac64e2e03?source=collection_archive---------18-----------------------#2020-06-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="4014" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">什么是递归？这不是一个真正的算法，而是一些算法中使用的方法！在计算机科学和所有编码领域，递归是一种为了解决问题而重复执行步骤的方法。你可能会想，这和迭代有什么不同。可以把迭代看作是建立一个解决方案的过程，而递归把一个问题分解成更小的实例来得到解决方案。换句话说，把递归看作是一种把问题简化成更小的子问题的方法。这里有一个使用俄罗斯娃娃的视觉例子。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi kl"><img src="../Images/1edbffa36a56e48873ed7587dddfbce4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*5fHaKD8bipE6T_gjkKVVPg.png"/></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">图片来自维基百科</figcaption></figure><p id="7793" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你打开一个，里面有足够多的娃娃，直到另一个装不下为止。</p><p id="01a6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么这一切和算法有什么关系呢？递归是算法中常用的方法。我实际上已经在一篇博客文章中介绍了一个使用递归的算法，但是我们将在这篇文章的后面讨论它！我们先来看一些例子。</p><pre class="km kn ko kp gt kx ky kz la aw lb bi"><span id="d4b1" class="lc ld iq ky b gy le lf l lg lh">function addUpTo(array, index) {<br/> if (index &gt; 0) {<br/>  return addUpTo(array, (index-1)) + array[index]<br/> } else {<br/>   return array[index]<br/> }<br/>}</span></pre><p id="95f5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里，我们有一个函数，它将数组中的数字从它的开始处相加，或者将一个索引0加到您决定在数组的“终点”处使用的任何索引。例如，如果你有一个[1，2，3，4，5]的数组，并放入一个索引2，它会加上1，2，3，得出总数为6。如果你把指数设为1，它会把1和2相加，得出最终答案3。</p><p id="7451" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如此处所示，该函数在索引大于0的情况下调用自身进行重复。索引减1，以便遍历每个索引。</p><p id="192a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们来分解一下这看起来是什么样子，以便更好地理解递归是如何工作的。让我们使用我在下面提供的数组和索引。</p><pre class="km kn ko kp gt kx ky kz la aw lb bi"><span id="3219" class="lc ld iq ky b gy le lf l lg lh">let a = [1,2,3,4,5]</span><span id="e3da" class="lc ld iq ky b gy li lf l lg lh">addUpTo(a, 4)</span></pre><p id="1f48" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们更深入地研究递归，这就是这个函数的样子。这就是为什么我用一套俄罗斯娃娃作为视觉例子。这个特定的函数继续下去，直到指数为0，这可以比作一套俄罗斯娃娃，直到最后一个娃娃不能包含另一个娃娃在里面。</p><pre class="km kn ko kp gt kx ky kz la aw lb bi"><span id="4cf9" class="lc ld iq ky b gy le lf l lg lh">addUpTo( [1, 2, 3, 4, 5], 4)<br/> addUpTo( [1, 2, 3, 4, 5], 3)<br/>  addUpTo( [1, 2, 3, 4, 5], 2)<br/>   addUpTo( [1, 2, 3, 4, 5], 1)<br/>    addUpTo( [1, 2, 3, 4, 5], 0)</span></pre><p id="8474" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们用另一个算法来举例吧！</p><pre class="km kn ko kp gt kx ky kz la aw lb bi"><span id="e427" class="lc ld iq ky b gy le lf l lg lh">function isPalindrome(myString) {<br/> if (myString[0] === myString[(myString.length - 1)] &amp;&amp; myString.length &gt; 1) {<br/>  isPalindrome(myString.slice(1, (myString.length - 1)))<br/>   return true<br/> } else {<br/>   return false<br/> }<br/>}</span></pre><p id="7d38" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个函数检查你输入的字符串是否是回文。(回文是一个单词，如果你把它反过来，它的拼写完全相同)。如果你看第二行，类似于前面提到的算法，该条件将一直存在，直到每个元素(在这个上下文中是字母)都被遍历，并且直到该条件被满足，该函数将继续调用自己(因此是递归)。</p><p id="5fb6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们更深入地看看第一个条件的前半部分。该函数检查第一个和最后一个字母是否相同。如果没有，很简单，这不是一个回文。有趣的是第一个条件的后半部分。第一个条件的后半部分只是确保字符串仍然存在。</p><p id="c85a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们看看第三行。对于这一部分，函数继续调用自己，检查字符串的第一个字母，并重用长度减一的索引值。</p><p id="96a6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">还记得我说过，递归实际上被用在我之前写过的一个算法中吗？那是<a class="ae lj" href="https://medium.com/@jonathan_wong/algorithms-merge-sort-638679180288" rel="noopener">合并排序算法</a>！</p><pre class="km kn ko kp gt kx ky kz la aw lb bi"><span id="e3c7" class="lc ld iq ky b gy le lf l lg lh">function mergeSort(array) {<br/> let midPoint = array.length/2<br/> let firstHalf = array.slice(0, midPoint)<br/> let secondHalf = array.slice(midPoint, array.length)<br/> <br/> if (array.length &lt; 2) {<br/>  return array<br/> } else {<br/>   return (merge(mergeSort(firstHalf), mergeSort(secondHalf)))<br/> }<br/>};function merge(array1, array2) {<br/> let sorted = []<br/> while (array1.length &gt; 0 &amp;&amp; array2.length &gt; 0) {<br/>  if (array1[0] &gt; array2[0]) {<br/>   sorted.push(findMinAndRemoveSorted(array2))<br/>  } else {<br/>    sorted.push(findMinAndRemoveSorted(array1))<br/>  }<br/> }<br/> return sorted.concat(array1).concat(array2)<br/>}function findMinAndRemoveSorted(array) {<br/> return array.shift()<br/>}</span></pre><p id="1971" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你仔细看，递归实际上在第一个函数的else条件中使用了两次<strong class="jp ir"/>！类似于前面解释的两个例子，函数被调用，直到满足一个条件。如果你想了解这个算法的更多信息，请查看我的<a class="ae lj" href="https://medium.com/@jonathan_wong/algorithms-merge-sort-638679180288" rel="noopener">上一篇博文</a>！</p><p id="3fc7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">总之，把递归和算法想象成一个算法调用它自己并减少一个数组/字符串/等等，直到满足一个条件并返回解决方案。如果你注意到在我提到的所有例子中，算法中使用的数组和字符串在某种程度上被“简化”了，从而解决了问题。</p></div></div>    
</body>
</html>