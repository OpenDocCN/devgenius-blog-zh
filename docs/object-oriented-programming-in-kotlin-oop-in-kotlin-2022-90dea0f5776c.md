# Kotlin 中的面向对象编程[kot Lin 中的 OOP—2022]

> 原文：<https://blog.devgenius.io/object-oriented-programming-in-kotlin-oop-in-kotlin-2022-90dea0f5776c?source=collection_archive---------1----------------------->

![](img/b02f14d70b8326e17f2526560ca38b90.png)

> **内容:-**

1.  ***类*** *和* ***对象*** *。*
2.  ***构造函数*** *:-默认，参数化，主，次。*
3.  ***多态*** *:-运行时和编译时。*
4.  ***继承*** *:-继承的类型。*
5.  *为什么不允许多重继承？→* ***钻石问题***
6.  ***界面***
7.  *类的类型:* ***数据*** *类，* ***枚举*** *类，* ***密封*** *类，* ***单体*** *类，* ***抽象***
8.  ***抽象*** *。*
9.  ***封装*** *:-包，访问修饰符*
10.  *抽象类****VS****接口*

> **面向对象编程** (OOP)就是创建一个模板(不占用宇宙中任何空间)和那些模板的对象(占用空间)。

示例:-

1.  假设我们要造一辆汽车，那么首先我们要做一个名为 ***的设计类*** 和名为 ***的真实汽车对象*** 。

![](img/4ac274f54dc02f42f2bb759492f6331a.png)

**类:-**

这是一辆汽车的 ***蓝图*** ，不占用宇宙空间。

![](img/efd01e140522a134a7d4036a595a3c9a.png)

**对象** :-

这是 ***真正的*** 车，它占据宇宙空间。

我们在编程中应用的类似概念是创建蓝图，然后从这些蓝图中创建产品。

> ***在 Kotlin 中创建类和对象:-***

![](img/e9467dbc8c9593a94f4eedcda0e1b2df.png)![](img/8fdbfca261a20a048d03635a3ddc86d6.png)

输出:-

![](img/7b50e91c69cb93a103e5b515ad3c04dd.png)

> 2. ***构造函数:-*** 在上面的程序中，我们在创建对象后访问并分配内存给变量，但是如果我们想在创建对象时这样做，我们就使用构造函数。

2.1. ***默认构造函数*** :-

![](img/d32c8c1b743cbf9b2f5685285a24d628.png)

***init*** 调用:- ***init*** 是一种构造函数，我们在创建对象时调用它-self。让我们通过使用 init 来计算一个类创建的对象的数量来理解。在这里，我们将使用 ***伴随对象***:——这意味着*项* *对所有对象都是通用的，并且只能由类*访问。

![](img/47b6c2a13d1f54a8637ef0628579980e.png)

***伴侣对象:-***

![](img/e15946f37ec3ded43a17e7c726fac555.png)

在上面的例子中，n 变量只能被类访问，而不能被它的对象访问。

这里，当我们试图使用类对象访问类变量时，它给出了错误。

2.2 ( *参数化)* ***一级建造师*** :-

![](img/0b9cf39bfdababff4d08d2f334917fdf.png)

2.3 ***二级建造师*** :-

***注意*** :- *val* 或 *var* 不允许出现在二级构造函数参数中。

![](img/7da59270231160add64bc1bd213cea5f.png)

在这里， ***油耗*** 是我们想在某些车上拥有的附加值。**比如**:——对于**奥迪**我们没有 ***油耗*** 所以我们叫一级构造师，对于**宝马**我们有 ***油耗*** 所以我们叫二级构造师。

注意:-如果主构造函数没有默认值，则次构造函数必须使用“ ***this*** ”调用主构造函数。

因此，在上面的代码中，我们从次要构造函数调用主要构造函数来获取剩余的值。

> ***3。多态性:-***

***3.1 编译时多态性:-*** 当我们有不同类型的构造函数，它们具有相同的名称，但是:-

**一个**。**不同的参数列表**。

→ *重要* :-在主构造函数中，参数中的所有属性都必须初始化。

![](img/70149f4d2c6e70f950d299a3db52d5d7.png)![](img/5511256153aab7de4718aaa4aa51f186.png)

输出:-注意[每次都会调用 init 块]

**B .主要论点+附加论点。**

![](img/8697d5e587e350da1e4e9bf7e2b5fcdf.png)![](img/06756454cb367cf804a35fa5882fb1c2.png)

输出

***3.2 运行时多态性:-***

在理解这一点之前，我们需要理解**继承**。

> ***4。继承:-*** *表示继承其子节点中的父属性，子节点除了父属性之外还可以有其他属性。*

![](img/07e3aaf0d361cadff63fea45a1a2b6f1.png)

***一些关键词*** :-

1.  ***open*** →要继承任何类，我们必须使它开放，因为在 Kotlin 中，默认情况下每个类都是公共的和最终的。
2.  ***超级*** →它调用我们当前所在班级的上层。
3.  ***覆盖*** →用于从子类改变/覆盖父类的任何函数或变量的功能。
4.  ***private*** →用于使任何项目只能在该类中访问。

![](img/7c4ecacdc2b3c9c9ddfe411c0be38aa5.png)

创建父类→哺乳动物

![](img/667c147f1d15c827864e261a509a3150.png)

创建子类→人类

![](img/c5653c2555951cce3c66be5e6a16b99c.png)

对象制作→ main()

![](img/b1cdad4f582013304c8235275842b77c.png)![](img/9e6c960a7ff1fa3f213880814632d7c5.png)

输出

**3.2** 。 ***运行时多态性:——所以我们理解了继承***

在上面的例子中，我们从主函数[代码中的第 28 行]调用了“***”human . eating()***，所以在运行时它开始搜索“***”eating()***”。所以在运行时，它首先在子类中搜索，但是因为它不在子类中，所以它转到父类。同样，“***. human . breathing()***”是在运行时搜索它在子类中找到的。因此我们得到相应的输出。这是运行时多态性。

***继承的类型:-***

1.  单一等级 :-表示男孩等级继承自人类等级。

![](img/cea7b74f263294090624ac02f3c6577d.png)

2.**多级** :-表示顶级类继承自学生类，学生类继承自男孩类，男孩类继承自人类类。

![](img/c36ceb05e224d891dbef0ea9d0694caa.png)

3.**倍数** :-表示人类类继承自男孩和女孩两个类。

注意:- *在 KOTLIN* 中不允许【原因在本故事的后续部分】。

![](img/2afc234adac596354260b85c4f6cfc1c.png)

4.**等级** :-男孩类和女孩类都继承自人类类。

![](img/5e2aaeedaaaa1257b260316bca018c7f.png)

> **5*。*** ***为什么*** ***不允许多重继承*** *？→* **钻石问题**
> 
> Java 或 Kotlin 中不允许多重继承:-对于多重继承，他们(语言 Java、Kotlin 的创建者)告诉我们使用**接口**。这个问题也称为钻石问题

```
 **Class A**{ 
            fun **demo**(){} 
        } **Class B**{ 
            fun **demo**(){}
        } **Class C** : **A()**, **B()**{ 
            ***override*** fun **demo**(){} 
        }
```

在这里，**编译器**搞不清楚该调用 ***demo()*** 的 ***Class A*** 或 ***Class B*** 的哪个函数，所以 Kotlin 防止用类进行多重继承。这是钻石问题。

> **6*。接口:-*** *用于存储属性的定义。*

→界面的所有内容都是抽象的、开放的、公共的。
→如果现场变量(val，var)无法初始化。
→功能在界面中可能有也可能没有主体部分。
→无法创建对象。
→允许多重继承。

要创建接口:-

```
interface <NAME> { 
     //variables
     //functions 
}
```

![](img/98482853f5928c3515357817930cb058.png)![](img/faa2d9a25138f631b9169b85f912040c.png)

Main() :-

![](img/a76434db6287717587df2f3fabcad3dd.png)

***允许不同类型的继承:-***

```
****Class C1() {}
    Class C2() {}
    interface I1() {}
    interface I2() {}****// Allowed -> One class + multiple interface
    Class test2() : C1() , I1(), I2() {}****// Allowed -> multiple interface
    Class test3() : I1() , I2() {}****
```

> ****7。课程类型:-****

1.  *****数据*** *类:-帮助我们保存数据的类。***

**![](img/e21aa7b770749d925eafb55f1836b101.png)****![](img/84272cec8bada42295d6efe89b9cac71.png)**

**[链接 _ 图片](https://www.canva.com/design/DAE2QjYRpP0/iCejAxB3JgLDhFhyN2Uxiw/view?utm_content=DAE2QjYRpP0&utm_campaign=designshare&utm_medium=link&utm_source=publishsharelink)**

***规则:-*
1。数据类必须在参数
2 中有一项。数据类必须有所有参数必须定义 var 或 val
3。数据类不能是抽象的、开放的、密封的或内部的**

***2。****Enum****Class:-用于保存一组常量。***

**→枚举类中的每个常量都是对象。
→枚举类只能从接口继承，不能从类继承。**

**![](img/3a0a6018fc36000d6652fb9abdd62c3f.png)**

**我们也可以在枚举类中有构造函数:-**

**![](img/2a4ceb46d1ea729674a3e41686ccaa7a.png)**

**我们只能继承 Enum 类中的接口，覆盖 Enum 类对象的**中接口的抽象函数和变量:-****

**![](img/b850bb1500bab1682a19fd09e646efab.png)****![](img/db89edd595d2ad84913d8e865e6c6f22.png)**

***3。* ***密封*** *类:-当我们有有限的一组值时，我们使用这个。***

**我们正在开设一个网站🌐我们试图打开它，这样我们可以面对三种情况 1。正在加载 2。错误 3 .成功。所以我们不能有任何其他价值。因此，我们使用密封类，因为我们有三个值，所以把它密封在包中，这样就不会有其他值添加到包中。**

**→密封类只能在创建它的文件中继承。
→无法创建对象。**

**![](img/537d092c9dbbd9cb0ae4773524f40497.png)**

**输出:-**

**![](img/558ab64ffe19ccccde59e4c83cb22c28.png)**

*****4。Singleton*** *类:像 Java 中的 static***

**1.在整个应用程序中只能创建一个对象。
2。不允许使用主构造函数和第二构造函数。
3。函数参数不能用 var 或 val 初始化，即 fun name(val name) - >错误。
4。我们使用类名本身直接访问变量和方法。**

**![](img/c984be71be659c05548e1add1cd03644.png)**

*****5。抽象*** *类:-当我们声明一个抽象类时，我们必须在它的子类中有声明部分。***

**→抽象类可以有普通的和抽象的方法和字段。我们不能创建抽象类的对象。抽象变量只能使用它的子类来访问。**

**![](img/e38b6c679e8a8f8d50f3ba6745e063b4.png)****![](img/3edf5c8e5787b86184fa0c0654909054.png)**

**输出:-**

**![](img/946ddef2a789ea53f09f47d230fce803.png)**

***6。* ***嵌套*** *类:类内的类是嵌套类。***

**![](img/bb07fe8c7987ca87bc5388ee87a42f8e.png)**

**7.**内部嵌套**类:-在嵌套类中，我们不能访问外部类的项目。但是当我们在嵌套类前添加“内部”时，我们就可以访问它们了。**

**![](img/5b10c8c4fda2cbba20801508758a0430.png)**

****这里不能从嵌套类中访问外部类的“年龄”变量。****

**用“内部”嵌套:-**

**![](img/260d1f733d29156aa82c5141308cc73e.png)**

**这里，外部类的“年龄”变量可以从内部嵌套类中访问。**

****注** :-**

**调用“具有内部的嵌套类”:-当“*内部*”具有嵌套类时，我们必须具有外部类的构造函数。但是我们在正常的内部课程中没有。**

**![](img/41157ce8e2d382902c09478c69b929d9.png)**

> ****8。摘要:-****

**这意味着只使用函数而看不到它的内部实现。**

**例如:- println() →我们只看到它用它来打印，我们没有看到它的内部实现，它如何在内部工作等等。这就是抽象。**

> ****9*9。封装*** *:-访问修饰符***

1.  ****Public** :-默认情况下，这些类型的变量和函数随处可用。**
2.  **私有的:这些类型的变量和函数只在文件中可见。**
3.  ****内部** :-这些类型的变量和函数只在同一个模块内可见，即同一个项目。**
4.  ****受保护的** :-这些类型的变量和函数与 Private 相同，并且在它的子类中可见。**

> ****10*。抽象类 VS 接口*****

**![](img/416c20a5ae633a871cd91ab1e7c5b0fc.png)**

**感谢阅读…希望你的概念已经清楚。**