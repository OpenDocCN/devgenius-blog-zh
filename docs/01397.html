<html>
<head>
<title/>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1/>
<blockquote>原文：<a href="https://blog.devgenius.io/python-tutorial-learn-iterator-and-generator-in-5-min-4a26f06090ce?source=collection_archive---------16-----------------------#2020-07-02">https://blog.devgenius.io/python-tutorial-learn-iterator-and-generator-in-5-min-4a26f06090ce?source=collection_archive---------16-----------------------#2020-07-02</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/cb29d598c22249b28c1d65729f098b99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*GVh6M_P4YTn4wghT.jpeg"/></div></div></figure><p id="00fa" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">今天，我们要学习一些关于生成器和迭代器的知识。</p><p id="216a" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">当我第一次学习生成器和迭代器的时候，我并没有太在意它们。我只是觉得这是一种实现或处理数据的新方式。对于获取数据的方法，我们知道一个就足够了。但是在我后来使用Python和学习使用TensorFlow的过程中，我发现迭代器和生成器被用在了那么多地方，或者是直接使用，或者是借用了思想。</p><p id="2a64" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">所以如果你想成为一名优秀的Python程序员，了解迭代器和生成器是很有必要的。</p><p id="2249" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">让我们先从迭代器开始。</p><h2 id="b449" class="jv jw iy bd jx jy jz dn ka kb kc dp kd ji ke kf kg jm kh ki kj jq kk kl km kn bi translated">迭代器</h2><p id="fcce" class="pw-post-body-paragraph iw ix iy iz b ja ko jc jd je kp jg jh ji kq jk jl jm kr jo jp jq ks js jt ju ig bi translated">迭代器的概念并不是Python独有的，在C++和Java中都有，并且在所有语言中的用法都是相似的。主要用来解决一个问题:如何在复杂场景下轻松获取数据？</p><p id="56f6" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">让我们假设一个场景，我们从某个数据源获得一批数据。我们需要前一万行来生成结果。之后，我们应该将结果发送给另一个服务。</p><p id="5ecd" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">这条管道看似简单，但有两个隐藏的问题。第一，很容易如果第一步我们需要的数据行是实心的，如果是动态值呢？</p><p id="483d" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">显然，我们需要变量来记录数据的行数和状态，这会增加代码的复杂性。此外，如果数量非常大，也会对内存造成巨大的压力。</p><p id="3acc" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">另一个问题是用户需要关心数据的细节。例如，如果我们从数据中构建一个多叉树，用户需要自己实现迭代算法，当然他需要知道数据结构的细节。</p><p id="1771" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">迭代器就是为了解决这些问题而产生的，我们可以把迭代器传递给数据的用户。用户可以从迭代器中获取数据，而不需要传递大量的数据，也不需要知道数据结构的细节。</p><h2 id="1900" class="jv jw iy bd jx jy jz dn ka kb kc dp kd ji ke kf kg jm kh ki kj jq kk kl km kn bi translated">集合中的迭代器</h2><p id="e7e0" class="pw-post-body-paragraph iw ix iy iz b ja ko jc jd je kp jg jh ji kq jk jl jm kr jo jp jq ks js jt ju ig bi translated">我们首先从简单的例子开始了解迭代器的用法。我们都知道List、Tuple和Dict是Python中的三个经典集合。它们都是可迭代的对象，我们可以用关键字‘ITER’创建一个迭代器。</p><p id="d396" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">让我们看一个例子:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="b891" class="jv jw iy ky b gy lc ld l le lf">arr = [1, 3, 4, 5, 9]<br/><br/>it = iter(arr)<br/><br/>print(next(it)) # 1<br/>print(next(it)) # 3</span></pre><p id="2601" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">我们首先创建一个数组，并用iter创建一个迭代器来读取它。有了迭代器之后，我们可以通过使用' next '来获取集合中的下一个元素。</p><p id="a06e" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">这就像链接数组中的指针，我们第一次调用' next '函数时，它返回第一个元素。我们再次调用它，它返回第二个，每次我们调用它，它都会移动到下一个元素。</p><p id="1cd8" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">数组中有5个元素，如果我们调用' next '超过5次，就会导致StopIteration异常。</p><p id="e9ec" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">我们也可以通过使用for循环来迭代元素。</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="a8ad" class="jv jw iy ky b gy lc ld l le lf">for i in it:<br/>    print(i)</span></pre><h2 id="b0cf" class="jv jw iy bd jx jy jz dn ka kb kc dp kd ji ke kf kg jm kh ki kj jq kk kl km kn bi translated">自定义迭代器</h2><p id="3860" class="pw-post-body-paragraph iw ix iy iz b ja ko jc jd je kp jg jh ji kq jk jl jm kr jo jp jq ks js jt ju ig bi translated">迭代器的主要用途是我们可以根据需要创建自己的迭代器。我们可以为一个类实现一个__ <strong class="iz lg"> iter__ </strong>函数或__ <strong class="iz lg"> next__ </strong>函数，使其可迭代。</p><p id="1877" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">其中，__ <strong class="iz lg"> iter__ </strong>函数用于创建一个迭代器。而__ <strong class="iz lg"> next__ </strong>函数用于迭代元素。我来试着解释一下，Python中有两个关于迭代器的概念，一个是‘可迭代对象’，另一个是‘迭代器’。</p><p id="ef23" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">当我们使用' iter '创建迭代器时，它会调用类的函数' __iter__ '。所以' __iter__ '函数是迭代器的初始化器。对于迭代器，我们可以使用“__next__”函数或for循环来迭代元素。它是通过调用“__next__”函数来实现的。每次我们调用' __next__ '函数，都会返回迭代器的一个元素。</p><p id="9dc9" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">你可能会对这两个概念之间的关系感到非常困惑。很正常，你只需要提醒iterable对象是迭代器的超集。由于迭代器，我们只能迭代元素。</p><p id="a95f" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">让我们举个例子:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="c7bf" class="jv jw iy ky b gy lc ld l le lf">class MyList(object):<br/> <br/>    def __init__(self, num):<br/>        self.data = num      <br/>         <br/>    def __iter__(self):<br/>        return MyListIterator(self.data) <br/> <br/>class MyListIterator(object):<br/>    def __init__(self, data):<br/>        self.data = data         <br/>        self.now = 0             <br/> <br/>    def __iter__(self):<br/>        return self               <br/>        <br/>    def __next__(self):              <br/>        while self.now &lt; self.data:<br/>            self.now += 1<br/>            return self.now - 1  <br/>        raise StopIteration</span></pre><p id="a520" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">对于我的列表，它是一个可迭代类，但不是迭代器类。因为它只有__ <strong class="iz lg"> iter__ </strong>功能。在we的__ <strong class="iz lg"> iter__ </strong>函数中，返回MyListIterator的一个实例。MyListeIterator是一类迭代器，因为它同时具有__ <strong class="iz lg"> iter__ </strong>和__ <strong class="iz lg"> next__ </strong>函数。这两者对于迭代器类都是必要的。</p><p id="02f6" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">让我们来看看用法:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="b755" class="jv jw iy ky b gy lc ld l le lf">my_list = MyList(5)              # have an iterable object<br/>my_list_iter = iter(my_list)     # have an iterator</span></pre><p id="547f" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">我们通过调用' iter '函数得到一个迭代器，我们可以通过迭代器迭代元素:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="b2cb" class="jv jw iy ky b gy lc ld l le lf">for i in my_list_iter:<br/>    print(i)</span></pre><p id="2c3a" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">但是我们也可以通过使用my_list来获取元素:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="9212" class="jv jw iy ky b gy lc ld l le lf">for i in my_list:<br/>    print(i)</span></pre><p id="26f4" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">这就是为什么？</p><p id="34c6" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">因为我们在for-loop中迭代它，所以它会先通过my_list创建一个迭代器，然后迭代刚刚创建的迭代器。如果我们使用' next '函数调用一个iterable对象，它会给出一个异常。</p><figure class="kt ku kv kw gt ip gh gi paragraph-image"><div class="ab gu cl lh"><img src="../Images/188ae5fb8b18b0c088b7d85d54209007.png" data-original-src="https://miro.medium.com/v2/format:webp/1*k3JEmx7mUlzlJxbD9o-F3Q.jpeg"/></div></figure><h2 id="e5a5" class="jv jw iy bd jx jy jz dn ka kb kc dp kd ji ke kf kg jm kh ki kj jq kk kl km kn bi translated">发电机</h2><p id="2a67" class="pw-post-body-paragraph iw ix iy iz b ja ko jc jd je kp jg jh ji kq jk jl jm kr jo jp jq ks js jt ju ig bi translated">生成器是迭代器的一个类似概念。区别在于迭代器是用来迭代集合或数据的，而生成器是用来生成数据的，它是一个数据生成工具。</p><p id="db19" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">让我们看一个简单的例子，我们都知道斐波纳契数列从第三个数字开始，它等于前两个数字之和。如果我们想得到一百万个斐波那契数列，用传统的方法，我们需要初始化一个长度为一百万的数组，然后一个接一个地计算它们。显然，这将花费大量的时间和内存。</p><p id="3bec" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">但是，如果我们使用生成器，我们只需要实现数据生成的逻辑，每次我们需要数据时，我们可以调用生成器来获取它。这将节省大量的内存和计算资源。</p><p id="e3cb" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">让我们看看如何定义一个生成器。</p><h2 id="940b" class="jv jw iy bd jx jy jz dn ka kb kc dp kd ji ke kf kg jm kh ki kj jq kk kl km kn bi translated">用括号创建</h2><p id="c2e6" class="pw-post-body-paragraph iw ix iy iz b ja ko jc jd je kp jg jh ji kq jk jl jm kr jo jp jq ks js jt ju ig bi translated">创建发电机的最简单方法非常简单。在Python中，我们通常用括号创建数组。</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="d501" class="jv jw iy ky b gy lc ld l le lf">arr = [i * 3 for i in range(10)]</span></pre><p id="f80b" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">如果我们用圆括号代替括号，我们将得到一个简单的生成器。</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="0764" class="jv jw iy ky b gy lc ld l le lf">g = (i * 3 for i in range(10))<br/><br/>print(next(g))</span></pre><p id="be3f" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">但是可能有一个困惑。我们这样做有什么意义？生成器与列表有何不同？</p><p id="0f3c" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">实际上，它们确实有区别。如果我们创建一个数组，Python将运行括号中的for循环，并将结果插入数组。但是在生成器里就不一样了，虽然我们用for-loop，Python并没有结束for-loop，只有当我们调用' next '函数的时候才会触发它循环一次。</p><p id="7d6e" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">让我们看一个例子，这是一个数组和一个生成器。</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="988d" class="jv jw iy ky b gy lc ld l le lf">g = (i for i in range(1000000000))<br/>g = [i for i in range(1000000000)]</span></pre><p id="174c" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">您可以一个一个地运行它们，并注意所用时间的差异。</p><h2 id="700c" class="jv jw iy bd jx jy jz dn ka kb kc dp kd ji ke kf kg jm kh ki kj jq kk kl km kn bi translated">创建类似函数的生成器</h2><p id="4577" class="pw-post-body-paragraph iw ix iy iz b ja ko jc jd je kp jg jh ji kq jk jl jm kr jo jp jq ks js jt ju ig bi translated">上面描述的方法很简单，但不太实用，因为我们想要构造数据的方式通常很复杂，并且很难以这种形式实现。</p><p id="456f" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">Python为我们提供了另一种创建生成器的方法，虽然有点复杂，但也更强大。</p><p id="9bfe" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">代码如下:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="f4c4" class="jv jw iy ky b gy lc ld l le lf">def gtr(n):<br/>    for i in range(n):<br/>        yield i</span></pre><p id="4e4a" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">看起来我们定义了一个函数，但是它返回的结果不是一个值，而是一个生成器。</p><p id="fc5e" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">如果你自己尝试，你会得到一个生成器的实例。</p><figure class="kt ku kv kw gt ip gh gi paragraph-image"><div class="gh gi li"><img src="../Images/cdb8e15b680139f39c7c94cae967e9ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:992/format:webp/0*UoqaEKONnCRAjX4Q.jpg"/></div></figure><p id="d93e" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">并且在生成器的定义中，我们使用了一个新的关键字:‘yield’而不是return。收益率和回报率非常相似，但又有些不同。</p><p id="a361" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">这是一样的，当我们执行时，yield和return都会将结果返回给调用者。例如，在上面的代码中我们写了' yield i '，当我们运行它时，将接收它返回的I。</p><p id="44a5" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">不同之处在于，当我们再次执行时，生成器将从上次返回的yield语句继续执行。所以通常，我们会在生成器中使用一个循环，每次返回一个结果。</p><p id="6f67" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">例如:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="70db" class="jv jw iy ky b gy lc ld l le lf">def test():<br/>    n = 0<br/>    while True:<br/>        if n &lt; 3:<br/>            yield n<br/>            n += 1<br/>        else:<br/>            yield 10<br/>            <br/>            <br/>if __name__ == '__main__':<br/>    t = test()<br/>    for i in range(10):<br/>        print(next(t))</span></pre><p id="fc8c" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">如果我们执行上面的代码，我们将得到的前三个数字是0、1和2，之后我们将得到10。如果你能理解这个例子，说明你已经知道yield的用法了。</p><h2 id="37d8" class="jv jw iy bd jx jy jz dn ka kb kc dp kd ji ke kf kg jm kh ki kj jq kk kl km kn bi translated">从...屈服</h2><p id="cd1e" class="pw-post-body-paragraph iw ix iy iz b ja ko jc jd je kp jg jh ji kq jk jl jm kr jo jp jq ks js jt ju ig bi translated">下一步是引入‘yield from’，其用法与‘yield’类似，也用在生成器中，下次将从返回的位置继续。</p><p id="c53b" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">但是' yield '只是返回它后面的结果，而' yield from '返回另一个生成器的结果。</p><p id="176b" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">我们举一个经典的例子:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="e275" class="jv jw iy ky b gy lc ld l le lf">def g1():     <br/>     yield range(5)<br/>def g2():<br/>     yield from range(5)<br/><br/>it1 = g1()<br/>it2 = g2()<br/>for x in it1:<br/>    print(x)<br/><br/>for x in it2:<br/>    print(x)</span></pre><p id="9789" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">打印出来的结果是一样的，但是逻辑完全不同。在第一个生成器g1中，当我们执行“next(it1)”时，它将返回“range(5)”作为结果。</p><p id="c38c" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">和生成器g2，它返回来自生成器“range(5)”的值。因此，如果我们运行“next(it2)”，它将返回0。</p><p id="fa47" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">总之，“yield from”可以在迭代器或生成器执行“next”函数后返回结果。</p><p id="85aa" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">最后，让我们看看如何使用yield from来迭代二叉树。</p><p id="4ddc" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">首先我们定义了树节点的类，在类中我们实现了一个迭代函数来迭代它。由于我们在函数中使用了‘yield from ’,所以返回的函数类型是generator。而‘yield from’将返回另一个生成器的结果，所以它的工作方式就像迭代中的递归函数。</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="676e" class="jv jw iy ky b gy lc ld l le lf">class Node:<br/>    # definition of tree node<br/>    def __init__(self, key):<br/>        self.key = key<br/>        self.lchild = None<br/>        self.rchild = None<br/>        self.iterated = False<br/>        self.father = None<br/><br/>    def iterate(self):<br/>        if self.lchild is not None:<br/>            yield from self.lchild.iterate()<br/>        yield self.key<br/>        if self.rchild is not None:<br/>            yield from self.rchild.iterate()</span></pre><p id="47b4" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">然后我们定义了树的类别。我们还提供了一个迭代函数。在iterate函数中，我们只是通过递归调用，调用节点根的iterate函数来迭代整个树。</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="ebbc" class="jv jw iy ky b gy lc ld l le lf">class Tree:<br/><br/>    def __init__(self):<br/>        # procedure of initializing a tree<br/>        self.root = Node(4)<br/>        self.root.lchild = Node(3)<br/>        self.root.lchild.father = self.root<br/>        self.root.rchild = Node(5)<br/>        self.root.rchild.father = self.root<br/>        self.root.lchild.lchild = Node(1)<br/>        self.root.lchild.lchild.father = self.root.lchild<br/>        self.root.rchild.rchild = Node(7)<br/>        self.root.rchild.rchild.father = self.root.rchild<br/><br/>    def iterate(self):<br/>        yield from self.root.iterate()</span></pre><p id="10d5" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">有了‘yield from’，我们可以很容易地使用递归思想在树上实现迭代器。对于下游用户来说使用起来很方便。他们不需要知道数据结构的细节。</p><p id="dd15" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">这是文章的结尾，上面提到的概念是相似的，我想许多初学者可能会感到困惑。</p><p id="d4b6" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">可以理解的是，迭代器和生成器以相同的方式遍历元素，通过调用' next '来获得下面的元素。当我们在函数中使用' yield '时，它会返回一个生成器。也就是说，我们使用生成器来创建数据，并以迭代器的形式使用生成的数据。</p><p id="dbc7" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">我希望你们都能理解迭代器和生成器的用法，它们在Python中非常重要和有用。</p><p id="4206" class="pw-post-body-paragraph iw ix iy iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ig bi translated">本文到此为止，祝你有一个伟大的Python之旅。</p></div></div>    
</body>
</html>