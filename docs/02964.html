<html>
<head>
<title>Slack Clone with React | Semantic UI | GraphQL | PostgresSQL (PART 3)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有React |语义UI | GraphQL | PostgresSQL的Slack克隆(第3部分)</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/slack-clone-with-react-semantic-ui-graphql-postgressql-part-3-f42515446c80?source=collection_archive---------11-----------------------#2020-09-15">https://blog.devgenius.io/slack-clone-with-react-semantic-ui-graphql-postgressql-part-3-f42515446c80?source=collection_archive---------11-----------------------#2020-09-15</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="4b6c" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">之前，我们设置了我们的Graphql服务器。你可以在这里找到那篇文章。</h2></div><figure class="ke kf kg kh gt ki gh gi paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="gh gi kd"><img src="../Images/d314b898fe904b16398f9f545130dee7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*t4iLLLpblLCZ-ES3"/></div></div><figcaption class="kp kq gj gh gi kr ks bd b be z dk translated">Volodymyr Hryshchenko 在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="714a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">今天，我们将着手启动我们的数据库。</p><p id="06d8" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我建议看我上一篇文章的安装视频，看看如何启动Postgres服务器。然后，我将通过一个名为Postico的GUI应用程序创建数据库，而不是通过命令行。然而，这只是我的一个偏好。您可以继续观看视频来学习命令行方式。</p><h1 id="8f87" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">启动服务器并创建数据库</h1><p id="3ac9" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">仅供参考:在与数据库交互时，一定要运行Postgres服务器。默认情况下，这些是他们给你的数据库。</p><figure class="ke kf kg kh gt ki gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/19742a5bc6264176a79f59236f91b9ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1192/0*xksEN38g4mrRB9oJ"/></div></figure><h1 id="8b46" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">使用Postico与数据库交互</h1><p id="5451" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">当您第一次开始时，它会要求您连接到您试图使用的数据库/服务器。只需按照这些指示，连接到你在Postgres上运行的同一个服务器。完成后，创建一个名为Chat的数据库。我点击了下面的“+数据库”按钮来创建一个新的。</p><figure class="ke kf kg kh gt ki gh gi paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="gh gi mn"><img src="../Images/d2304a00f056ccefce8b2ffd81bde666.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RlO57BBWI8hqLm0S"/></div></div></figure><p id="9ed8" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">当它在顶部显示“已连接”时，那是您连接到的数据库。</p><h1 id="f3dd" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">在项目中配置我们的数据库。</h1><p id="d7da" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">既然我们已经设置了数据库，现在是时候在项目中配置所有这些了。在根项目文件夹的终端中，运行命令</p><pre class="ke kf kg kh gt mo mp mq mr aw ms bi"><span id="7e2b" class="mt lq in mp b gy mu mv l mw mx">npx sequelize init</span></pre><p id="f317" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">该命令将创建一个config文件夹，其中有一个<code class="fe my mz na mp b">config.json</code>文件，该文件包含一些默认的数据库连接信息，您需要更改这些信息，以便与您之前创建的数据库相匹配。它应该看起来像这样</p><pre class="ke kf kg kh gt mo mp mq mr aw ms bi"><span id="3382" class="mt lq in mp b gy mu mv l mw mx">/** config/config.js */<br/>{<br/>  "development": {<br/>    "username": "ajeas",<br/>    "password": "",<br/>    "database": "chat",<br/>    "host": "127.0.0.1",<br/>    "dialect": "postgres"<br/>  },<br/>  "test": {<br/>    "username": "root",<br/>    "password": null,<br/>    "database": "database_test",<br/>    "host": "127.0.0.1",<br/>    "dialect": "postgres"<br/>  },<br/>  "production": {<br/>    "username": "root",<br/>    "password": null,<br/>    "database": "database_production",<br/>    "host": "127.0.0.1",<br/>    "dialect": "postgres"<br/>  }<br/>}</span></pre><p id="264a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">“用户名”将是你的名字，默认密码是一个空字符串，“数据库”将是聊天，并确保使“方言”Postgres(告诉我们使用哪个数据库，如果你想，你可以放一个不同的，如MySQL。但是，我们现在使用Postgres)忽略测试和生产。</p><h1 id="0c98" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">使用序列创建模型(表)</h1><p id="d591" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">配置完数据库信息后，就该通过命令行创建我们的第一个模型了。运行这段代码来生成一个用户模型(代表一个注册用户)。</p><pre class="ke kf kg kh gt mo mp mq mr aw ms bi"><span id="527e" class="mt lq in mp b gy mu mv l mw mx">npx sequelize model:generate --name User --attributes username:string,email:string,password:string</span></pre><p id="7176" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这将用我们需要指定数据类型的<code class="fe my mz na mp b">username</code>、<code class="fe my mz na mp b">email</code>和<code class="fe my mz na mp b">password</code>字段(列)创建我们的用户模型(表)，这就是为什么我们在最后添加了<code class="fe my mz na mp b">:string</code>。你的模型应该是这样的</p><pre class="ke kf kg kh gt mo mp mq mr aw ms bi"><span id="e48b" class="mt lq in mp b gy mu mv l mw mx">const { Model } = require("sequelize");<br/>module.exports = (sequelize, DataTypes) =&gt; {<br/>  class User extends Model {<br/>    /**<br/>     * Helper method for defining associations.<br/>     * This method is not a part of Sequelize lifecycle.<br/>     * The `models/index` file will call this method automatically.<br/>     */<br/>    static associate() {<br/>      // define association here</span><span id="54c1" class="mt lq in mp b gy nb mv l mw mx">    }<br/>  }<br/>  User.init(<br/>    {<br/>      username: DataTypes.STRING,<br/>      email: DataTypes.STRING,<br/>      password: DataTypes.STRING<br/>    },<br/>    {<br/>      sequelize,<br/>      modelName: "User"<br/>    }<br/>  );<br/>  return User;<br/>};</span></pre><p id="b528" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">它还将创建一个迁移文件夹和一个代表我们在数据库中的表结构的<code class="fe my mz na mp b">xxxxxxxx-create-user.js</code>文件。每次创建模型时，都会在migrations文件夹中附加一个迁移文件。(还创建了一个我们在本系列中不会用到的seeder文件夹，所以现在可以忽略它。)</p><p id="3479" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在我们进入其他部分之前，让我们在启动服务器时连接到数据库。添加这是<code class="fe my mz na mp b">server.js</code>文件</p><pre class="ke kf kg kh gt mo mp mq mr aw ms bi"><span id="8337" class="mt lq in mp b gy mu mv l mw mx">/** add this */<br/>const { sequelize } = require("./models");</span><span id="21d5" class="mt lq in mp b gy nb mv l mw mx">server.listen(4000, () =&gt; {<br/>  console.log(`🚀 Server ready at port 4000`);<br/>  // Connecting to Database</span><span id="bf26" class="mt lq in mp b gy nb mv l mw mx">/** add this */<br/>  sequelize<br/>    .authenticate()<br/>    .then(() =&gt; {<br/>      console.log("database connected");<br/>    })<br/>    .catch(err =&gt; console.log(err));<br/>});</span></pre><p id="a34e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">它使用序列和我们的<code class="fe my mz na mp b">config.js</code>文件连接到我们的数据库。重启服务器(<code class="fe my mz na mp b">npm run dev</code>)，现在你应该在终端中看到这个</p><figure class="ke kf kg kh gt ki gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/b9af60da07e737497ea860eb4f739fec.png" data-original-src="https://miro.medium.com/v2/resize:fit:702/0*PgMVlYhCRlxJ017I"/></div></figure><p id="3c89" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在，让我们创建我们需要的其他模型。运行与之前相同的命令，创建一个<code class="fe my mz na mp b">Team</code>、<code class="fe my mz na mp b">Channel</code>、<code class="fe my mz na mp b">Message</code>模型</p><p id="60a7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">仅供参考:这些命令将在模型文件夹中为您创建文件</p><pre class="ke kf kg kh gt mo mp mq mr aw ms bi"><span id="3f98" class="mt lq in mp b gy mu mv l mw mx">npx sequelize model:generate --name Team --attributes name:string</span><span id="6f0d" class="mt lq in mp b gy nb mv l mw mx">npx sequelize model:generate --name Channel --attributes name:string,public:boolean</span><span id="a26e" class="mt lq in mp b gy nb mv l mw mx">npx sequelize model:generate --name Message --attributes text:string</span></pre><p id="866d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">您的所有模型应该看起来与用户模型图像相似。在将模型迁移到数据库之前。我们需要在他们之间建立关系。</p><h1 id="8ee1" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">模型关系(关联)</h1><p id="6f6e" class="pw-post-body-paragraph kt ku in kv b kw mh jo ky kz mi jr lb lc mj le lf lg mk li lj lk ml lm ln lo ig bi translated">我们将使用<code class="fe my mz na mp b">belongsToMany</code>和<code class="fe my mz na mp b">belongsTo</code>关系，我们必须在每个模型文件中手动完成。</p><p id="cb5c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">“一个<strong class="kv io">用户</strong>可以属于slack中的许多团队”，这将使他们通过一个名为<code class="fe my mz na mp b">member</code>(我们将在后面创建)的不同表链接在一起，该表向<code class="fe my mz na mp b">member</code>表添加了一个外键。(仅供参考，我对关系数据库和关系还是新手。所以我用我能理解的最好的方式来解释:)。</p><pre class="ke kf kg kh gt mo mp mq mr aw ms bi"><span id="1bac" class="mt lq in mp b gy mu mv l mw mx">/** User model */<br/>static associate({ Team }) {<br/>  // define association here<br/>  this.belongsToMany(Team, {<br/>     through: "member",<br/>     foreignKey: "userId"<br/>  });<br/>}</span></pre><p id="8195" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">“一个<strong class="kv io">团队</strong>可以属于许多用户，它属于一个特定的用户”，用不同的外键链接到同一个<code class="fe my mz na mp b">member</code>表。<code class="fe my mz na mp b">belongsTo</code>没有创建另一个表，它只是向<code class="fe my mz na mp b">team</code>添加了一个外键。外键<code class="fe my mz na mp b">owner</code>将是拥有团队的用户(模型)的“id”。</p><pre class="ke kf kg kh gt mo mp mq mr aw ms bi"><span id="ed80" class="mt lq in mp b gy mu mv l mw mx">/** Team model */<br/>static associate({ User }) {<br/>   // define association here<br/>   this.belongsToMany(User, { through: "member", foreignKey:       "teamId"});<br/>   this.belongsTo(User, { foreignKey: "owner" });<br/>}</span></pre><p id="0f55" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">“一个<strong class="kv io">消息</strong>属于一个频道，它属于一个用户”，给消息添加两个外键。外键<code class="fe my mz na mp b">channelId</code>将是消息所属通道的“id ”,外键<code class="fe my mz na mp b">userId</code>将是创建该消息的用户(模型)的“id”。</p><pre class="ke kf kg kh gt mo mp mq mr aw ms bi"><span id="28ba" class="mt lq in mp b gy mu mv l mw mx">/** Message model */<br/>static associate({ Channel, User }) {<br/>   // define association here<br/>   this.belongsTo(Channel, { foreignKey: "channelId" });<br/>   this.belongsTo(User, { foreignKey: "userId" });<br/>}</span></pre><p id="20d9" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">最后，我们的渠道模型。“一个渠道属于一个团队”，因为没有团队我们无法创建渠道<code class="fe my mz na mp b">teamId</code>外键是该渠道所属团队(模型)的“id”。</p><pre class="ke kf kg kh gt mo mp mq mr aw ms bi"><span id="7d57" class="mt lq in mp b gy mu mv l mw mx">/** Channel model */<br/>static associate({ Team }) {<br/>   // define association here<br/>   this.belongsTo(Team, { foreignKey: "teamId" });<br/>}</span></pre><p id="d73c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在，让我们将它迁移到数据库中，这样它将具有相同的结构。运行此命令进行迁移。</p><pre class="ke kf kg kh gt mo mp mq mr aw ms bi"><span id="7d4d" class="mt lq in mp b gy mu mv l mw mx">npx sequelize db:migrate</span></pre><p id="885f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果一切顺利，您应该会在终端上看到一条类似于<code class="fe my mz na mp b">xxxxxxxxxxx-create-user.js migrated</code>的消息以及其他迁移文件。</p><p id="2c44" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">确保连接到您的聊天数据库，check-in Postico，您现在应该可以看到添加了所有外键的所有表。</p><figure class="ke kf kg kh gt ki gh gi paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="gh gi nd"><img src="../Images/2e8dea1a55a51ca7f2e795c848a345b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jlErn5ug8BPr-We7"/></div></div></figure><p id="df14" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">到目前为止，您的文件夹结构应该是这样的</p><figure class="ke kf kg kh gt ki gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/3dfe1002b97149f60299cb7e9d46f03a.png" data-original-src="https://miro.medium.com/v2/resize:fit:404/0*5S5SXwkXENDeA26z"/></div></figure><p id="da32" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这是所有这一个乡亲，请随时让我知道，如果你在这个过程中有任何问题，这是一个很大的工作量，所以我很乐意帮助如果你卡住了。干杯！</p></div></div>    
</body>
</html>