<html>
<head>
<title>Handling asynchronous nature in NodeJS/JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">处理 NodeJS/JavaScript 中的异步特性</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/handling-asynchronous-nature-in-nodejs-javascript-66471aef6dae?source=collection_archive---------2-----------------------#2021-12-18">https://blog.devgenius.io/handling-asynchronous-nature-in-nodejs-javascript-66471aef6dae?source=collection_archive---------2-----------------------#2021-12-18</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/></div><div class="ab cl jk jl hr jm" role="separator"><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp"/></div><div class="ig ih ii ij ik"><figure class="js jt ju jv gt jw gh gi paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="gh gi jr"><img src="../Images/7e9942c5d74dcbac55b4a5f6e24641da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G9EvGrvubis0SwaQ7C-LIg.jpeg"/></div></div></figure><p id="5191" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">如果您来自 JavaScript 或 NodeJS 背景，您肯定会遇到诸如同步、异步、阻塞、非阻塞等术语。在进入主要话题之前，最好对这些概念有一个扎实的了解。</p><p id="4157" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">同步意味着阻塞。因此，它会等到任务完成后再继续下一个任务。异步意味着非阻塞。它不会等到完成一项任务后再进入另一项任务。</p><p id="53ff" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">JavaScript 本质上是同步的。但是有一些东西具有异步行为，比如 API 调用、setTimeout、DOM 事件(单击、鼠标悬停、滚动……)。假设您请求一个昂贵的数据库调用。JavaScript 是单线程的，所以它一次只能做一件事。因此，如果这是同步的，那么在响应来自数据库调用之前，您将不能做任何事情。</p><p id="16c3" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">那 NodeJS 呢？它还是单线程和异步的，非常适合数据密集型应用。因为 NodeJS 不会等待一个任务完成后再继续下一个任务，所以这个线程将可以为另一个客户机服务。</p><p id="67b8" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">为了深入了解异步代码的行为，让我们看一个例子。</p><figure class="js jt ju jv gt jw"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="9fa4" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">你对上面代码片段的输出有什么看法？如下图。</p><pre class="js jt ju jv gt ld le lf lg aw lh bi"><span id="79b7" class="li lj in le b gy lk ll l lm ln">Start<br/>End<br/>Inside timeout</span></pre><p id="9483" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">是的。这是命令。未开始、内部超时和结束。</p><p id="74e9" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">如果延迟设置为 0 毫秒。它会按正确的顺序运行吗？不完全是。输出将是相同的。那么，这里发生了什么？我们去幕后看看发生了什么事。</p><figure class="js jt ju jv gt jw gh gi paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="gh gi lo"><img src="../Images/1affd0b4cc65988e3617411a59752613.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*rWNun2XnsEGzodRcx8Z0uA.gif"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk translated">代码执行的流程</figcaption></figure><ul class=""><li id="f283" class="lt lu in kf b kg kh kk kl ko lv ks lw kw lx la ly lz ma mb bi translated">首先，代码将执行 console.log('Start ')。一旦完成，就从堆栈中弹出。</li><li id="4a1e" class="lt lu in kf b kg md kk me ko mf ks mg kw mh la ly lz ma mb bi translated"><em class="mc">然后下一行，setTimeout。如前所述，它显示了异步行为。因此，它将被推送到 Web APIs(我们可以说 NodeJS 的 c++ API)。</em></li><li id="8b9d" class="lt lu in kf b kg md kk me ko mf ks mg kw mh la ly lz ma mb bi translated"><em class="mc">然后 JavaScript 会执行 console . log(‘End’)。一旦完成，它也会从堆栈中移除。</em></li><li id="c400" class="lt lu in kf b kg md kk me ko mf ks mg kw mh la ly lz ma mb bi translated"><em class="mc">setTimeot 延迟 1 秒。所以 1 秒钟后，它会被推送到任务队列。</em></li><li id="b9c1" class="lt lu in kf b kg md kk me ko mf ks mg kw mh la ly lz ma mb bi translated"><em class="mc">这就是事件循环发挥作用的地方。事件循环的工作是监视堆栈和任务队列。一旦堆栈变空，它将获取队列的第一个并放入堆栈</em></li></ul><p id="67d9" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">现在你知道为什么它不改变顺序了，即使我们对 setTimeout 设置了零延迟！</p><p id="bb73" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">直到现在，异步行为听起来还不错。为什么我们需要处理这个？</p><p id="5dc2" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">可能会有这样的情况，我们需要等待一个任务完成后才能继续下一个任务。假设你有两个功能。第一个函数将从 API 获取数据，第二个函数需要第一个函数的几个数据。如果第一个函数需要一些时间才能得到响应，那该怎么办？代码将转到第二个函数，但是第一个函数仍然没有返回数据。这就是问题发生的地方。</p><p id="045e" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">让我们看一个例子。</p><p id="9620" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">这里我们要为下面的等式中给定的<em class="mc"> x，</em>找到<em class="mc"> y </em>。</p><pre class="js jt ju jv gt ld le lf lg aw lh bi"><span id="9e8f" class="li lj in le b gy lk ll l lm ln"><strong class="le io"><em class="mc">                          y = 2x + 1</em></strong></span></pre><p id="15ff" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">为此，我们使用两个函数，一个用于乘法，另一个用于加法。假设乘法需要 2 秒，加法需要 1 秒完成。实际上，执行这些操作只需要几毫秒，但这只是为了突出问题。无论如何，在进行真实世界的 API 调用、数据库请求等时，您可能会遇到这个问题。</p><figure class="js jt ju jv gt jw"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="bebc" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">你觉得输出怎么样？</p><p id="4020" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">它会显示“未定义”。大家知道原因是<em class="mc"> console.log(result) </em>没有等到<strong class="kf io"><em class="mc">multiply y2()</em></strong>和<strong class="kf io"><em class="mc">add 1()</em></strong><em class="mc"/>函数返回值。那么，我们如何缓解这个问题呢？这里我们有三种方法。</p><ol class=""><li id="b54b" class="lt lu in kf b kg kh kk kl ko lv ks lw kw lx la mi lz ma mb bi translated">回调函数</li><li id="7e4c" class="lt lu in kf b kg md kk me ko mf ks mg kw mh la mi lz ma mb bi translated">承诺</li><li id="0d9f" class="lt lu in kf b kg md kk me ko mf ks mg kw mh la mi lz ma mb bi translated">异步等待</li></ol><p id="29d1" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">让我们看看如何使用这些。</p><h2 id="b8ed" class="li lj in bd mj mk ml dn mm mn mo dp mp ko mq mr ms ks mt mu mv kw mw mx my mz bi translated">复试</h2><figure class="js jt ju jv gt jw"><div class="bz fp l di"><div class="lb lc l"/></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk translated">回调方法</figcaption></figure><p id="8971" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">这里，我们将一个函数(称为回调函数)作为参数传递给<em class="mc">multiply y2()</em><strong class="kf io"><em class="mc"/></strong>和<em class="mc"> add1() </em>函数。一旦输出被返回，我们就在回调函数体中得到结果。</p><p id="283e" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">但是，当我们有多个依赖回调时，这似乎并不好。因为它创建了一个嵌套在另一个内部的嵌套回调，这并不太干净和可读。这叫回调地狱。</p><h2 id="e23b" class="li lj in bd mj mk ml dn mm mn mo dp mp ko mq mr ms ks mt mu mv kw mw mx my mz bi translated">承诺</h2><figure class="js jt ju jv gt jw"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="5ea2" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">这里我们在两个函数中返回一个<strong class="kf io">承诺</strong>。这就是我们通常对承诺的定义。</p><pre class="js jt ju jv gt ld le lf lg aw lh bi"><span id="538e" class="li lj in le b gy lk ll l lm ln"><strong class="le io">new Promise((resolve, reject) =&gt; {<br/>  if (err) reject()<br/>  resolve()<br/>}).then(() =&gt; {<br/></strong> <em class="mc"> // Will execute once task is resolved (resolve)</em><strong class="le io"><br/>}).catch(() =&gt; {<br/></strong>  <em class="mc">// will exectue if an error occurred (reject)</em><strong class="le io"><br/>})</strong></span></pre><p id="9c3f" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">Promise 对象以一个函数(它被称为 executor 函数)作为参数。一旦任务完成，它就进入模块。如果出错，则进入<strong class="kf io">捕捉</strong>模块。</p><p id="bab8" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">如你所见，这种编写代码的方式比使用回调要干净得多。我们可以根据需要链接 n 个 then 块。</p><h2 id="578b" class="li lj in bd mj mk ml dn mm mn mo dp mp ko mq mr ms ks mt mu mv kw mw mx my mz bi translated">异步等待</h2><figure class="js jt ju jv gt jw"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="fd4d" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">这是一种更清洁的方式。它看起来几乎像同步代码。我们需要做的是将<strong class="kf io"> await </strong>关键字放在函数之前。但是你只能在异步函数中使用 await。因此 calculate_y()函数应该是一个异步函数。</p><p id="6f92" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">您可以在这里找到工作示例。</p><p id="7f92" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated"><a class="ae na" href="https://github.com/Kanchana46/callback-promises-async-await.git" rel="noopener ugc nofollow" target="_blank">https://github . com/kanchana 46/callback-promises-async-await . git</a></p><p id="8614" class="pw-post-body-paragraph kd ke in kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">这都是关于处理异步的性质。编码快乐！。</p></div></div>    
</body>
</html>