<html>
<head>
<title>Functional JavaScript — Functional Array Methods</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">函数 JavaScript —函数数组方法</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/functional-javascript-functional-array-methods-cad38965488f?source=collection_archive---------4-----------------------#2020-11-17">https://blog.devgenius.io/functional-javascript-functional-array-methods-cad38965488f?source=collection_archive---------4-----------------------#2020-11-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/e1ca261ce6bac44f1a5fe5b1ef79d794.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GoExYAzqp3xTEUA7"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@madhatterzone?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Manja Vitolic </a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="5cf0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JavaScript 部分是一种函数式语言。</p><p id="7b04" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要学习 JavaScript，我们必须学习 JavaScript 的功能部分。</p><p id="6eb1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将看看如何创建我们自己的数组方法。</p><h1 id="8d79" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">concatAll</h1><p id="2357" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以创建自己的<code class="fe me mf mg mh b">concatAll</code>方法，将所有嵌套的数组连接成一个大数组。</p><p id="bf1a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="ee23" class="mq lc iq mh b gy mr ms l mt mu">const concatAll = (arrays) =&gt; {<br/>  let results = []<br/>  for (const array of arrays) {<br/>    results = [...results, ...array];<br/>  }<br/>  return results;<br/>}</span></pre><p id="61f4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们只是将所有数组的数组条目展开，然后返回结果数组。</p><p id="3c26" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以用它来取消嵌套数组。</p><p id="48ce" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="15f0" class="mq lc iq mh b gy mr ms l mt mu">const arr = concatAll([<br/>  [1, 2, 3],<br/>  [4, 5, 6],<br/>  [7, 8, 9]<br/>]);</span></pre><p id="7ac4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么<code class="fe me mf mg mh b">arr</code>就是:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="0df3" class="mq lc iq mh b gy mr ms l mt mu">[1, 2, 3, 4, 5, 6, 7, 8, 9]</span></pre><h1 id="e890" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">缩减功能</h1><p id="7d6a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">Reduce 是一个函数，它允许我们将数组中的条目合并成一个值。</p><p id="b344" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要创建我们自己的<code class="fe me mf mg mh b">reduce</code>函数，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="2248" class="mq lc iq mh b gy mr ms l mt mu">const reduce = (array, fn) =&gt; {<br/>  let accumlator = 0;<br/>  for (const a of array) {<br/>    accumlator = fn(accumlator, a)<br/>  }<br/>  return accumlator;<br/>}</span></pre><p id="bc43" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">reduce</code>函数采用一个<code class="fe me mf mg mh b">array</code>和一个<code class="fe me mf mg mh b">fn</code>函数。</p><p id="2fe7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">array</code>是我们循环遍历的数组，用于组合来自<code class="fe me mf mg mh b">array</code>的值，并将其指定为<code class="fe me mf mg mh b">accumulator</code>的值。</p><p id="cbdf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">fn</code>返回一个值，通过一些运算将<code class="fe me mf mg mh b">accumulator</code>和<code class="fe me mf mg mh b">a</code>值合并为一个值。</p><p id="a00c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦我们遍历了数组，我们就返回<code class="fe me mf mg mh b">accumulator</code>值。</p><p id="34d4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以用它来添加数组中的数字，方法是:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="0beb" class="mq lc iq mh b gy mr ms l mt mu">const sum = reduce([1, 2, 3, 4, 5], (acc, val) =&gt; acc + val)</span></pre><p id="a4ae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们传入一个数字数组和一个回调函数来将数组的条目组合在一起。</p><p id="34d9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么<code class="fe me mf mg mh b">sum</code>就是 15，因为我们把所有的数字加在了一起。</p><p id="7208" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过接受<code class="fe me mf mg mh b">accumulator</code>的初始值，我们可以使<code class="fe me mf mg mh b">reduce</code>函数更加健壮。</p><p id="3ae6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="d9bd" class="mq lc iq mh b gy mr ms l mt mu">const reduce = (array, fn, initialValue) =&gt; {<br/>  let accumlator = initialValue;<br/>  for (const a of array) {<br/>    accumlator = fn(accumlator, a)<br/>  }<br/>  return accumlator;<br/>}</span></pre><p id="0e7b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将<code class="fe me mf mg mh b">initialValue</code>指定为<code class="fe me mf mg mh b">accumulator</code>的初始值。</p><p id="80bb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样，我们不需要假设我们总是在处理数字数组。</p><h1 id="a1c9" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">拉链阵列</h1><p id="6a69" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以将多个数组压缩成一个。</p><p id="dae5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用自己的函数为每个数组创建条目。</p><p id="bf4a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后把它放入我们返回的数组中。</p><p id="d0b8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们只循环到最短数组的长度，所以返回的数组也将与最短数组的长度相同。</p><p id="b858" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="4557" class="mq lc iq mh b gy mr ms l mt mu">const zip = (leftArr, rightArr, fn) =&gt; {<br/>  let index, results = [],<br/>    length = Math.min(leftArr.length, rightArr.length);<br/>  for (index = 0; index &lt; length; index++) {<br/>    results.push(fn(leftArr[index], rightArr[index]));<br/>  }<br/>  return results;<br/>}</span></pre><p id="2e53" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用<code class="fe me mf mg mh b">leftArr</code>、<code class="fe me mf mg mh b">rightArr</code>和<code class="fe me mf mg mh b">fn</code>参数创建了一个<code class="fe me mf mg mh b">zip</code>函数。</p><p id="89ff" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">leftArr</code>和<code class="fe me mf mg mh b">rightArr</code>是数组，<code class="fe me mf mg mh b">fn</code>是函数。</p><p id="b2c8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们循环通过最短的长度，也就是<code class="fe me mf mg mh b">length</code>。</p><p id="5156" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在循环体中，我们将压缩的条目推送到<code class="fe me mf mg mh b">results</code>数组。</p><p id="ad99" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦我们这样做了，我们就返回<code class="fe me mf mg mh b">results</code>。</p><p id="6ef1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以用它来写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="1da6" class="mq lc iq mh b gy mr ms l mt mu">const zipped = zip([1, 2, 3, 4], ['foo', 'bar', 'baz'], (a, b) =&gt; `${a} - ${b}`)</span></pre><p id="ac06" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有一个回调函数将左右两边的条目组合成一个字符串。</p><p id="a2d2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么<code class="fe me mf mg mh b">zipped</code>就是:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="c0a1" class="mq lc iq mh b gy mr ms l mt mu">["1 - foo", "2 - bar", "3 - baz"]</span></pre><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/1e640ed545142c7460d497ecb0f2f220.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4wkUBIbCn90ONy7y"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">Benjamin Sow 在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="8e82" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="496b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以取消嵌套数组并将它们与我们自己的函数压缩在一起。</p></div></div>    
</body>
</html>