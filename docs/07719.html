<html>
<head>
<title>Dive into JavaScript Closures.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">深入研究 JavaScript 闭包。</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/javascript-closures-lets-dive-in-73e235952a83?source=collection_archive---------8-----------------------#2022-04-18">https://blog.devgenius.io/javascript-closures-lets-dive-in-73e235952a83?source=collection_archive---------8-----------------------#2022-04-18</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/eb05b6c5513c277adb14662462553a59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r5pkN5pGwWJFR9z0dhamqQ.png"/></div></div></figure><p id="4b35" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">闭包是 javascript 世界中最重要的概念之一，同时也是一个令人困惑的关键字。</p><ol class=""><li id="005d" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated">在函数创建时，每次创建函数时都会创建闭包。</li><li id="be5e" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">它允许从内部函数访问外部函数。</li></ol><p id="9059" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们试着深入这个概念，理解闭包到底是什么，它在哪里起作用。</p><p id="ab34" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae lh" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures" rel="noopener ugc nofollow" target="_blank"> MDN </a>的定义说“一个<strong class="jx io"> <em class="li">闭包</em> </strong>是一个<strong class="jx io">函数</strong>和一个<strong class="jx io">词法环境</strong>的组合，其中<strong class="jx io">函数</strong>被<strong class="jx io">声明为</strong>”</p><blockquote class="lj lk ll"><p id="c328" class="jv jw li jx b jy jz ka kb kc kd ke kf lm kh ki kj ln kl km kn lo kp kq kr ks ig bi translated">闭包是指一个函数能够记住并访问它的词法范围，即使它是在它的词法范围之外被调用的。</p></blockquote><p id="6733" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这里，我们需要理解“词法范围”。</p><p id="0c71" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> <em class="li">词法作用域说明如何在嵌套函数中解析变量名。</em> </strong></p><p id="4182" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们勾勒出一个基本的闭包。</p><figure class="lq lr ls lt gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lp"><img src="../Images/cacb7f5741a6b5b09002e521121b2897.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1diI2woiTSNIC28KEkPCPw.png"/></div></div><figcaption class="lu lv gj gh gi lw lx bd b be z dk translated">基本闭包</figcaption></figure><p id="a50f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe ly lz ma mb b">outerFunc()</code>创建一个名为<code class="fe ly lz ma mb b">outer</code>的局部变量和一个名为<code class="fe ly lz ma mb b">innerFunc()</code>的函数。<code class="fe ly lz ma mb b">innerFunc()</code>函数是一个内部函数，定义在<code class="fe ly lz ma mb b">outerFunc()</code>内部，只能在<code class="fe ly lz ma mb b">outerFunc()</code>函数体内使用。注意<code class="fe ly lz ma mb b">innerFunc()</code>函数没有自己的局部变量。</p><p id="c849" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是，由于内部函数可以访问外部函数的变量，<code class="fe ly lz ma mb b">innerFunc()</code>可以访问父函数<code class="fe ly lz ma mb b">outerFunc()</code>中声明的变量<code class="fe ly lz ma mb b">outer</code>。</p><p id="d1f5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是一个<strong class="jx io"> <em class="li">词法</em> <em class="li">作用域</em> </strong>的例子，描述了函数嵌套时解析器如何解析变量名。单词<strong class="jx io"> <em class="li">词法</em> </strong>指的是<strong class="jx io">词法作用域</strong>使用 l <strong class="jx io">位置，即在源代码中声明变量的位置，来确定该变量在哪里可用</strong>。</p><figure class="lq lr ls lt gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mc"><img src="../Images/88b6418bbc55f5ec1f6f067eed2c9440.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bCabadTXRmy6pY8zene29Q.png"/></div></div></figure><p id="3e96" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在一些编程语言中，函数中的局部变量只在函数执行期间存在。一旦<code class="fe ly lz ma mb b">outerFunc()</code>完成执行，您可能会认为外部变量将不再可访问。</p><p id="5d82" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然而，因为代码仍然像预期的那样工作，所以在 JavaScript 中显然不是这样。</p><p id="c91c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">原因是 JavaScript 创建了一个“闭包”。在上面的例子中，myFunc 是对执行 myFunc 时创建的 innerFunc 实例的引用。</p><p id="fa33" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">innerFunc 的实例维护一个对其词法环境的引用，其中存在变量名“outer”。由于这个原因，当调用 myFunc 时，变量“outer”仍然可用。</p><p id="e6cb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们举一个稍微复杂一点的例子。</p><figure class="lq lr ls lt gt jo gh gi paragraph-image"><div class="gh gi md"><img src="../Images/0407d12ec949a48bca1522ce7fc02095.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*mR_Wq8k_wWImwsMVoLLexw.png"/></div></figure><p id="caf0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你能猜出这段代码是怎么回事吗？</p><p id="89c1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当您尝试调用 add5()方法时，它引用了匿名函数，该函数接受参数“y”，但 makeAdder()接受参数“x”。那么，这个词法范围是如何产生的。</p><p id="e1ea" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们明白这一点。</p><p id="266a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你看到 add5()和 add10()方法创建了一个闭包。</p><p id="143d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果您尝试控制台 add5 方法，它将显示如下。</p><pre class="lq lr ls lt gt me mb mf mg aw mh bi"><span id="e9ea" class="mi mj in mb b gy mk ml l mm mn">function(y) {<br/>  window.runnerWindow.proxyConsole.log(y)<br/>  return x + y;<br/>}</span></pre><p id="130e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">匿名函数在闭包创建的外部作用域中仍然保存“x”的值。</p><figure class="lq lr ls lt gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mo"><img src="../Images/1326214add64eda9ed737ad5a981ae9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s1YeXUGeWkUOI2hp-Jjn-w.png"/></div></div></figure><p id="34f7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我希望到目前为止，您可能已经开始理解“闭包”这个概念有多复杂，但同时它也很有趣。</p><p id="9604" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们来谈谈开发人员在理解闭包时最常犯的错误。</p><p id="e2ff" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们将回答一个关于“闭包”概念的最常见的面试问题，即典型的 for 循环示例。</p><figure class="lq lr ls lt gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mp"><img src="../Images/d6fd2bfb818e728ee68ecbda1b4f3ffd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dYwcsI2m8D9EbasY_QjF8Q.png"/></div></div></figure><p id="a56a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">乍一看，如果你是第一次学习“闭包”，你会得到的答案大多是这样的。</p><figure class="lq lr ls lt gt jo gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/721186968e2cda54b352fa9811e0b4d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:816/format:webp/1*dB14XLVLEzViMrzsIS-iqA.png"/></div></figure><p id="2ff7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是，实际上你会得到什么样的。</p><figure class="lq lr ls lt gt jo gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/260e6bde4b15528b5f16cc893c0fa984.png" data-original-src="https://miro.medium.com/v2/resize:fit:1028/format:webp/1*We4-NII-EWwRBRjgW9pzuw.png"/></div></figure><p id="379a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，我们要思考的是为什么？</p><p id="7e6e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下面说几个可能的解决方案。</p><ol class=""><li id="b22f" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated">使用“<strong class="jx io"> let </strong>关键字。</li></ol><figure class="lq lr ls lt gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ms"><img src="../Images/70899d1ba2b65acfcf7768204890416a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bquOQ1LG4zF7m3iwkEEjfw.png"/></div></div><figcaption class="lu lv gj gh gi lw lx bd b be z dk translated">使用 let 关键字</figcaption></figure><p id="0f9f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">使用 let 关键字，每个闭包都会绑定块范围的变量，这意味着不需要额外的闭包</p><p id="35d1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">2.利用<strong class="jx io">的生命</strong>。</p><figure class="lq lr ls lt gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mt"><img src="../Images/3a49e8250c994d982ef88e3629d2e72e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gqfClYu7EUKxQQafcD0WjA.png"/></div></div><figcaption class="lu lv gj gh gi lw lx bd b be z dk translated">利用生命</figcaption></figure><p id="76d9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你看到，我们正在使用一个 IIFE 函数，它接受一个参数“index ”,在每次迭代中保存“I”的当前值。</p><p id="f99b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">仔细分析 IIFE 块，setTimeout()函数即使在执行了使用“闭包”创建的“index”值之后，仍然保存该值。</p><p id="dd44" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这就是使用“结束”的魔力。</p><p id="6ee2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">3.返回<strong class="jx io"> </strong>一个<strong class="jx io">【函数】</strong>就像一个<strong class="jx io">【闭包】</strong></p><figure class="lq lr ls lt gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mu"><img src="../Images/5ec14e2c5b4969302244ca8a13cf2f91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HJ2NvbWcvG9HKupablMK-w.png"/></div></div><figcaption class="lu lv gj gh gi lw lx bd b be z dk translated">返回一个函数</figcaption></figure><p id="00b2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果您理解上面的示例，这里的解决方案是不言自明的，setTimeout()函数在每次迭代中都保存当前值。因为我们也用 IIFE 返回一个函数，它打印出想要的输出。</p><p id="7700" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们再举一个封闭的例子。</p><figure class="lq lr ls lt gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mv"><img src="../Images/a6c708c482ee3a1eabdf59c7e53e2aca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wEZ35da6-6gUuAOhfn2iFg.png"/></div></div></figure><p id="586a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我猜，现在你能够做出什么样的输出？</p><figure class="lq lr ls lt gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mw"><img src="../Images/3b2abf75814c1591120542672a618c61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V8A6VH5qfAixbiIqlt-vDw.png"/></div></div></figure><p id="0bfd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你的回答是以上，那么让我们明白是怎么回事？</p><p id="4831" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你的答案是 1234。我猜，你是在正确的轨道上。</p><p id="0dfd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以，让我们试着理解代码块中发生了什么。</p><p id="e5ee" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">永远记住这一点。</p><blockquote class="lj lk ll"><p id="2211" class="jv jw li jx b jy jz ka kb kc kd ke kf lm kh ki kj ln kl km kn lo kp kq kr ks ig bi translated"><strong class="jx io"> <em class="in">闭包——它是在创建函数时创建的，而不是在调用函数时创建的。</em>T13】</strong></p></blockquote><p id="f35e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们看看当我们在第 13 行调用 getItems[0]()时，让我们开始执行代码块。</p><p id="a83c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在第 2 行初始化一个空数组。</p><p id="ea84" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后第 3 行的 for 循环，变量“I”被提升。换句话说,“I”变量是在 for 循环之外声明的，然后该变量在每次迭代中发生变异。</p><p id="cef3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对于每次迭代，我们都将一个匿名函数推送到数组中。您可以将一个值、一个对象或一个函数推送到数组中。如果我们将 I 推送到数组中，我们会将迭代时 I 的值推送到数组中。</p><p id="c086" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当我们将一个匿名函数推送到数组时，匿名函数将在调用时返回“I”的值。在调用时，循环应该已经运行了。</p><p id="3c86" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">到循环完成时，“I”将等于 5，这是因为 for 循环中的增量表达式的工作方式。</p><p id="5973" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">唯一剩下的问题是 getItems 数组中的每个匿名函数如何在每次迭代中访问 I 的值？</p><p id="71ee" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">明确的答案是在每次迭代时绑定“I”的值，并且在创建时而不是调用时绑定？？？</p><p id="1646" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">想想当我们执行匿名函数时会发生什么。</p><ol class=""><li id="8605" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated">我们从全局范围调用一个匿名函数。</li><li id="70c1" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">第 1 行的 addItems 是一个外部函数，它返回一组内部函数，因为返回的 Items 数组包含一组匿名函数，这些函数实际上是 addItems 函数中的一组内部函数</li><li id="a9cf" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">items 数组中的每个内部函数都在访问 addItems 函数范围内的 I 变量</li><li id="8e27" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">在调用每个内部函数时，addItems 函数不再存在，但是每个内部函数都保持对 addItems 范围内的 I 变量的访问</li></ol><p id="6f9c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，上述所有的关闭条件都已满足。</p><p id="cd58" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，剩下的部分就是在每次迭代中唯一地绑定“I”变量。</p><p id="1f8f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们可以使用“let”关键字和生活来解决。</p><p id="7dae" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> <em class="li">使用“让”关键字。</em> </strong></p><figure class="lq lr ls lt gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mx"><img src="../Images/6ea121faa655eea1fcfd70ed0ae070cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bSKDxyJVC-CzEuI8ctl6mA.png"/></div></div></figure><p id="d509" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> <em class="li">利用</em> </strong></p><figure class="lq lr ls lt gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi my"><img src="../Images/0824b4dbd6a0b410e33c37fd929535e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xRO2ckISaPSt8TMk3Kt_dg.png"/></div></div></figure><p id="9a13" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">通过在 IIFE 中包装每个 items.push，我们可以确保 j 变量的作用域是这个函数的私有范围，因此，j 变量在每次迭代中都有唯一的绑定。</p><p id="dbad" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">希望上面的例子对你理解“闭包”有很大帮助。</p><p id="e821" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">决定闭包的两个重要特征。</p><blockquote class="lj lk ll"><p id="ea1d" class="jv jw li jx b jy jz ka kb kc kd ke kf lm kh ki kj ln kl km kn lo kp kq kr ks ig bi translated"><strong class="jx io">调用外部包装函数，创建封闭范围。</strong></p><p id="3475" class="jv jw li jx b jy jz ka kb kc kd ke kf lm kh ki kj ln kl km kn lo kp kq kr ks ig bi translated"><strong class="jx io">包装函数的返回值必须包括对至少一个内部函数的引用，该内部函数在包装器的私有内部范围上具有闭包。</strong></p></blockquote><p id="f4a5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们看看“闭包”的一些实际应用。</p><ol class=""><li id="a668" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated">封装——模拟私有方法</li><li id="12b4" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">常见的 web 示例，如“向页面添加按钮以调整文本大小”。</li><li id="6099" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">模块模式和显示模块模式</li><li id="7e02" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">闭包可以用来提高函数的内存效率和性能——例如，确保大型数组/对象只初始化一次。</li><li id="49ff" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">闭包是函数式编程的基本概念。HOF，没有闭包就不可能有 currying。</li><li id="8e8c" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">Init 函数——闭包可以用来确保一个函数只被调用一次。</li></ol><p id="d3dd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我希望这篇文章能够澄清大多数关于“结束”的误解。如果你真的喜欢这篇文章，请跟我来。</p><p id="52a4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">快乐编码。不断学习。继续探索。</p></div></div>    
</body>
</html>