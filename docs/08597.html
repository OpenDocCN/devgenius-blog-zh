<html>
<head>
<title>Nondeterministic Sudoku Solver</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">非确定性数独求解器</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/nondeterministic-sudoku-solver-1922a7ebfa3d?source=collection_archive---------18-----------------------#2022-06-26">https://blog.devgenius.io/nondeterministic-sudoku-solver-1922a7ebfa3d?source=collection_archive---------18-----------------------#2022-06-26</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="17ad" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">利用<code class="fe ki kj kk kl b">amb</code>特殊形式解决球拍/方案中的数独</p></div><div class="ab cl km kn hr ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ig ih ii ij ik"><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div class="gh gi kt"><img src="../Images/a4b43d49e7e4f99f32401e14867cdfed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*nkYJD2kbfjzS8bOc8k-9-A.gif"/></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">使用 amb 形式和逻辑编程风格解决数独</figcaption></figure><p id="0ab9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">附带的代码可以在<a class="ae lf" href="https://github.com/ericbreyer/NondeterministicSudoku" rel="noopener ugc nofollow" target="_blank">这里找到</a></p><h1 id="5da3" class="lg lh in bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">灵感</h1><p id="8961" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">我看到了这个视频，在视频中我被介绍给了 Amb 的接线员。它立即看起来像黑魔法，所以我研究了它的工作原理和实现。</p><h1 id="f0b4" class="lg lh in bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">Amb</h1><p id="0942" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated"><code class="fe ki kj kk kl b">amb</code>是模糊选择(nondeterminism)运算符。它接受一个可能性列表，并评估出一个允许程序成功的选项。在实践中，“amb”通常从左到右尝试其选项，但理论上，评估顺序并不重要，因此“不确定性”。<br/> <br/> <code class="fe ki kj kk kl b">assert</code>，有时也是<code class="fe ki kj kk kl b">require</code>，定义了程序必须满足的谓词。如果断言失败，程序的当前分支被放弃，新的<code class="fe ki kj kk kl b">amb</code>形式的可能性被尝试，直到断言成立。</p><figure class="ku kv kw kx gt ky"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="6efd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是我选择使用的<code class="fe ki kj kk kl b">amb</code>的实现。<br/>它定义了两个延续，一个成功(sk)和一个失败(fk)。成功延续是为了将<code class="fe ki kj kk kl b">amb</code>的下一个可能性传递给。创建失败延续是为了在尝试路径之前捕获程序的状态。如果程序在这种可能性下失败了，它会放弃一切，将程序恢复到这个时间点，准备好继续进行下一个可能性的尝试(注意<code class="fe ki kj kk kl b">...</code>，为每个可能性创建一个<code class="fe ki kj kk kl b">call/cc</code> / <code class="fe ki kj kk kl b">fk</code>“块”以允许<code class="fe ki kj kk kl b">amb</code>在从失败中返回后尝试下一个可能性)。<br/> <br/>由于在调用前一个<code class="fe ki kj kk kl b">amb</code>的失败之前尝试<code class="fe ki kj kk kl b">amb</code>的所有可能性的性质，为<code class="fe ki kj kk kl b">amb</code>表单寻找一组有效选项的实际底层逻辑是深度优先搜索。在确定这种策略解决问题的效率时，理解这一点很有用(尽管迭代或传统的递归深度优先搜索可能比所有<code class="fe ki kj kk kl b">call/cc</code>开销<code class="fe ki kj kk kl b">amb</code>所需的更有效)。<br/> <br/>进一步阅读和实现我查阅了:<br/>-<a class="ae lf" href="http://community.schemewiki.org/?amb" rel="noopener ugc nofollow" target="_blank">http://community.schemewiki.org/?amb</a><br/>-<a class="ae lf" href="http://www.sfu.ca/~tjd/383summer2019/scheme-amb.html" rel="noopener ugc nofollow" target="_blank">http://www.sfu.ca/~tjd/383summer2019/scheme-amb.html</a><br/>-<a class="ae lf" href="http://wiki.c2.com/?AmbSpecialForm" rel="noopener ugc nofollow" target="_blank">http://wiki.c2.com/?AmbSpecialForm</a><br/>-<a class="ae lf" href="https://gist.github.com/Liudx1985/11308921" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/Liudx1985/11308921</a></p><h1 id="b2bd" class="lg lh in bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">逻辑编程</h1><p id="583e" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">逻辑编程是一种编程风格，其中程序员:<br/> 1。陈述关于问题域的事实(比如数独方块的可能值)2。做出关于域的事实的断言(方块中的数字必须满足数独约束)<br/> 3。查询或提出问题，关于领域的事实(给出一个有效的数独)<br/> <br/>这是一个声明性的而不是命令性的编程范例:告诉计算机<strong class="jm io">做什么</strong>而不是<strong class="jm io">如何做</strong>。<br/> <br/> <code class="fe ki kj kk kl b">amb</code>适合这种风格。<br/> - <code class="fe ki kj kk kl b">amb</code>语句是关于领域的事实<br/> - <code class="fe ki kj kk kl b">assert</code>语句是关于领域的断言<br/> -询问变量值是一个查询</p><h1 id="b91f" class="lg lh in bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">解决数独</h1><p id="acc9" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">这种风格应该使解决数独变得简单。它字面上叫做逻辑谜题。理论上，我们只需要用<code class="fe ki kj kk kl b">(amb 1 2 3 4 5 6 7 8 9)</code>、<code class="fe ki kj kk kl b">assert</code>填充所有的空白方格，让每一行都有唯一的数字，等等。，然后要求登板。这是可行的，但需要很长时间。首先声明所有的‘AMB’然后断言将搜索许多不需要搜索的死角(并且不会在适当的 DFS 算法中)。更好的方法是一个一个地走。</p><figure class="ku kv kw kx gt ky"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="09ad" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一个方块一个方块地检查和断言，减少了在永远不可能工作的路径中的大量搜索，就好像方块不工作，它永远不会进一步搜索。一次声明所有的<code class="fe ki kj kk kl b">amb</code>总是从可能性树的最底层开始搜索，并把它变成一个更暴力的算法。<br/> <br/>然后我们只需要在每一个未解的方块上运行这个函数。逻辑编程还在这里:<br/> 1。首先声明平方必须是整数 1-9 <br/> 2。然后断言它必须满足数独规则<br/> 3。我们在解决每一个方块<br/> <br/>后查询最终的棋盘，这是解决一个数独游戏所需的全部算法。剩下的代码是以正确的格式构建数独板，应用<code class="fe ki kj kk kl b">solveSquare</code>，并创建一个 GUI。我觉得<code class="fe ki kj kk kl b">amb</code>很吸引人，感觉仍然像魔术一样。你只需要告诉程序你想要什么，它就会创造和毁灭宇宙，让时间倒流，直到它神奇地产生一个有效的结果。</p></div><div class="ab cl km kn hr ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ig ih ii ij ik"><h1 id="8b43" class="lg lh in bd li lj ml ll lm ln mm lp lq lr mn lt lu lv mo lx ly lz mp mb mc md bi translated">关于作者</h1><p id="8d04" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">Eric Breyer 是莱斯大学的计算机科学本科生。你可以在他的<a class="ae lf" href="http://www.ericbreyer.com/" rel="noopener ugc nofollow" target="_blank">网站</a>以及<a class="ae lf" href="https://github.com/ericbreyer" rel="noopener ugc nofollow" target="_blank"> GitHub </a>和<a class="ae lf" href="https://www.linkedin.com/in/eric-breyer/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上找到他。</p></div></div>    
</body>
</html>