<html>
<head>
<title>My Recipe for a Rock-Solid System Design</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我的坚如磐石的系统设计秘诀</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/my-recipe-for-a-rock-solid-system-design-d1ff3d63cb55?source=collection_archive---------0-----------------------#2020-06-01">https://blog.devgenius.io/my-recipe-for-a-rock-solid-system-design-d1ff3d63cb55?source=collection_archive---------0-----------------------#2020-06-01</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/62efe6496675b40e7ac35ba3bf877156.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wUB2pRL2FmeA2acPlZepwQ.jpeg"/></div></div></figure><p id="4810" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">系统架构的一个重要方面是跨类和包有效地组织功能。</p><p id="e117" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一个有太多函数的类(例如神类)可能会频繁地被改变，结果是不稳定的。此外，该类的任何客户端也会不稳定。</p><p id="8d6a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">另一方面，将功能划分到太多的类中会导致一个不切实际的、支离破碎的系统，这个系统设计过度并且难以理解。</p><p id="8aec" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，决定哪些功能应该打包在一起将对系统未来的可维护性产生重大影响。</p><p id="234e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是我们如何将正确的功能组合在一起呢？</p><h1 id="23bf" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">非软件系统的工作原理</h1><p id="995c" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">让我们对电梯系统进行逆向工程:</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi gj"><img src="../Images/e51292cefd3910d9ab11f5203661eb3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NcH1iu-tLYxJ8hrCoDjUPA.jpeg"/></div></div></figure><p id="1de0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个系统显然有几个功能组合在一起:</p><ul class=""><li id="f63f" class="ma mb in jx b jy jz kc kd kg mc kk md ko me ks mf mg mh mi bi translated"><em class="mj">订单升降机(移动方向:移动方向)</em></li><li id="f64f" class="ma mb in jx b jy mk kc ml kg mm kk mn ko mo ks mf mg mh mi bi translated"><em class="mj">getCurrentCabinFloor()//显示电梯在几楼。</em></li></ul><p id="625c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但在电梯轿厢内，还有其他功能:</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi gj"><img src="../Images/2c5a8ac2072a25d46ff37ba7e7e3da39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TVknJ0HDVmFhYmcahIXkTg.jpeg"/></div></div></figure><p id="3609" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，系统中有一个额外的独立接口:</p><ul class=""><li id="4dda" class="ma mb in jx b jy jz kc kd kg mc kk md ko me ks mf mg mh mi bi translated"><em class="mj">选择楼层(floorNum: Int) </em></li><li id="63fd" class="ma mb in jx b jy mk kc ml kg mm kk mn ko mo ks mf mg mh mi bi translated"><em class="mj"> openDoor() </em></li><li id="1318" class="ma mb in jx b jy mk kc ml kg mm kk mn ko mo ks mf mg mh mi bi translated"><em class="mj"> closeDoor() </em></li><li id="130d" class="ma mb in jx b jy mk kc ml kg mm kk mn ko mo ks mf mg mh mi bi translated"><em class="mj"> alert() </em></li></ul><p id="bd6b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">每部电梯都应进行维护和配置，因此将有各种功能用于这些目的:</p><ul class=""><li id="585d" class="ma mb in jx b jy jz kc kd kg mc kk md ko me ks mf mg mh mi bi translated"><em class="mj">settimebeforeclosedoom(时间:长)</em></li><li id="7c13" class="ma mb in jx b jy mk kc ml kg mm kk mn ko mo ks mf mg mh mi bi translated"><em class="mj">activate()//开启电梯服务</em></li><li id="c15a" class="ma mb in jx b jy mk kc ml kg mm kk mn ko mo ks mf mg mh mi bi translated"><em class="mj">deactivate()//关闭电梯服务</em></li></ul><p id="c000" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这些功能将何去何从？是否应该将它们添加到以前的接口中？</p><p id="9261" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当然不是！<br/>应限制电梯服务的用户使用仅供电梯操作员使用的功能。</p><p id="6fdd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">操作员通常会有自己的界面来控制这些功能。</p><p id="e35a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">换句话说，在电梯系统中，功能是基于<strong class="jx io">参与者</strong>和<strong class="jx io">用例</strong>进行分组的</p><p id="a3d4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">演员</strong>是:</p><ul class=""><li id="2b71" class="ma mb in jx b jy jz kc kd kg mc kk md ko me ks mf mg mh mi bi translated"><em class="mj">来电者</em></li><li id="1350" class="ma mb in jx b jy mk kc ml kg mm kk mn ko mo ks mf mg mh mi bi translated"><em class="mj">乘客</em></li><li id="6b2e" class="ma mb in jx b jy mk kc ml kg mm kk mn ko mo ks mf mg mh mi bi translated"><em class="mj">操作员</em></li></ul><p id="48ca" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">使用案例包括:</p><ul class=""><li id="bfb6" class="ma mb in jx b jy jz kc kd kg mc kk md ko me ks mf mg mh mi bi translated"><em class="mj">呼叫电梯</em></li><li id="c7ef" class="ma mb in jx b jy mk kc ml kg mm kk mn ko mo ks mf mg mh mi bi translated"><em class="mj">选择楼层</em></li><li id="08dc" class="ma mb in jx b jy mk kc ml kg mm kk mn ko mo ks mf mg mh mi bi translated"><em class="mj">配置电梯</em></li></ul><p id="e19f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，这些功能被分为以下接口:</p><ul class=""><li id="644c" class="ma mb in jx b jy jz kc kd kg mc kk md ko me ks mf mg mh mi bi translated"><strong class="jx io"><em class="mj">ElevatorBookingService</em></strong><em class="mj"><br/>+order elevator()<br/>+getCurrentCabinFloor()</em></li><li id="1d2c" class="ma mb in jx b jy mk kc ml kg mm kk mn ko mo ks mf mg mh mi bi translated"><strong class="jx io"> <em class="mj">电梯轿厢服务</em></strong><em class="mj"><br/>+选择楼层()<br/>+开门()<br/>+关门()<br/>+警戒()</em></li><li id="9bf6" class="ma mb in jx b jy mk kc ml kg mm kk mn ko mo ks mf mg mh mi bi translated"><strong class="jx io"><em class="mj">ElevatorOperatorService</em></strong><em class="mj"><br/>+activate()<br/>+deactivate()<br/>+setTimeBeforeClose()</em></li></ul><p id="f55e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">根据角色，为每个用例提取一个专用接口可以确保使用系统的每个参与者<strong class="jx io">只依赖于它需要的功能。</strong></p><p id="1b92" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在物理世界中可以找到许多类似的例子，如电话系统、汽车等等。</p><p id="8a23" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">适用于所有这些系统界面的原则是:</p><ul class=""><li id="7904" class="ma mb in jx b jy jz kc kd kg mc kk md ko me ks mf mg mh mi bi translated">同一个参与者一起使用的功能被打包在同一个组件接口中。</li><li id="2b8b" class="ma mb in jx b jy mk kc ml kg mm kk mn ko mo ks mf mg mh mi bi translated">使用<strong class="jx io">特定</strong>系统接口的演员应该<strong class="jx io"> </strong>利用这个<strong class="jx io">整体</strong>接口。</li></ul><p id="2ef9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这两个原则的结合确保了系统中的每个参与者只依赖于它所需要的。这种分离减少了系统易受错误使用类型和角色间冗余依赖的影响。</p><p id="c234" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果这些原则适用于几个系统工程学科——软件系统是个例外吗？</p><h1 id="1a23" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">基于组件的系统设计算法</h1><p id="d5b6" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">如果你正在寻找的是一个具有符合你的<strong class="jx io">特定系统需求的组件分离技术的系统——</strong>我已经编了一个<strong class="jx io">算法来设计一个系统</strong>，<strong class="jx io">确保</strong>这个属性。</p><p id="320f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">该算法基于弗劳恩霍夫实验软件工程研究所提出的<a class="ae mp" href="https://link.springer.com/chapter/10.1007/978-3-540-85289-6_4" rel="noopener ugc nofollow" target="_blank"> KobrA方法</a>。</p><ol class=""><li id="71e1" class="ma mb in jx b jy jz kc kd kg mc kk md ko me ks mq mg mh mi bi translated"><em class="mj">创建一个空函数列表‘L’</em></li><li id="f7ab" class="ma mb in jx b jy mk kc ml kg mm kk mn ko mo ks mq mg mh mi bi translated"><em class="mj">对于</em> <strong class="jx io"> <em class="mj">系统分析中确定的每个用例</em></strong><em class="mj">:<br/>对于用例</em> <strong class="jx io"> <em class="mj">中的每个动作由一个参与者</em> </strong> <em class="mj"> : <br/>给‘L’添加一个适当的函数‘f’(如果它还不存在</em><em class="mj">)</em></li><li id="02ca" class="ma mb in jx b jy mk kc ml kg mm kk mn ko mo ks mq mg mh mi bi translated"><em class="mj">对于‘L’中的每个函数‘f’:<br/>如果有一个接口‘I’，为其添加‘f’会保留相同的</em> <strong class="jx io"> <em class="mj">使用actors</em></strong><em class="mj"/><strong class="jx io"><em class="mj">group</em></strong><em class="mj">然后将‘f’添加到‘I’。<br/>否则:创建一个新的接口‘I’并添加‘f’到其中。</em></li><li id="9d65" class="ma mb in jx b jy mk kc ml kg mm kk mn ko mo ks mq mg mh mi bi translated"><em class="mj">检查所有创建的接口和功能，并根据每个接口包含的内容提供有意义的名称</em></li></ol><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/236dacdee40e7de212e7f221793285d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/format:webp/1*FFC7dXq4gWdyZgfp1GZjsg.jpeg"/></div></figure><h1 id="a31f" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">例子</h1><p id="92db" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">让我们分析一个典型的Android闹钟应用程序的一部分:</p><p id="1559" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="mj">用例名称:</em> <strong class="jx io"> <em class="mj">创建新警报</em> </strong> <em class="mj"> <br/>已知参与者:alarm configuration presenter<br/>序列流程:</em></p><ol class=""><li id="2d1e" class="ma mb in jx b jy jz kc kd kg mc kk md ko me ks mq mg mh mi bi translated"><em class="mj">执行者向系统提供一份带有报警描述的请求表</em></li><li id="20dc" class="ma mb in jx b jy mk kc ml kg mm kk mn ko mo ks mq mg mh mi bi translated"><em class="mj">系统保存报警。</em></li></ol><p id="3397" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="mj">用例名称:</em> <strong class="jx io"> <em class="mj">删除一个报警</em> </strong> <em class="mj"> <br/>已知参与者:AlarmConfigurationPresenter，alarmslistppresenter<br/>序列流程:</em></p><ol class=""><li id="4e5c" class="ma mb in jx b jy jz kc kd kg mc kk md ko me ks mq mg mh mi bi translated"><em class="mj">行动者提供了其希望删除的系统警告。</em></li><li id="f2db" class="ma mb in jx b jy mk kc ml kg mm kk mn ko mo ks mq mg mh mi bi translated"><em class="mj">系统搜索是否有此类危言耸听。如果找到→删除它。</em></li></ol><p id="c4ae" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="mj">用例名称:</em> <strong class="jx io"> <em class="mj">获取保存的报警</em> </strong> <em class="mj"> <br/>已知动作者:AlarmsListPresenter <br/>序列流程:</em></p><ol class=""><li id="3b99" class="ma mb in jx b jy jz kc kd kg mc kk md ko me ks mq mg mh mi bi translated"><em class="mj">参与者请求从系统中列出所有报警</em></li><li id="c035" class="ma mb in jx b jy mk kc ml kg mm kk mn ko mo ks mq mg mh mi bi translated"><em class="mj">系统执行搜索并返回所有报警列表</em></li></ol><p id="a76b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="mj">用例名称:</em> <strong class="jx io"> <em class="mj">切换报警激活</em> </strong> <em class="mj"> <br/>已知参与者:AlarmConfigurationPresenter，AlarmsListPresenter <br/>序列流程:</em></p><ol class=""><li id="ef73" class="ma mb in jx b jy jz kc kd kg mc kk md ko me ks mq mg mh mi bi translated"><em class="mj">行动者请求系统激活或停用报警</em></li><li id="32aa" class="ma mb in jx b jy mk kc ml kg mm kk mn ko mo ks mq mg mh mi bi translated"><em class="mj">系统根据操作者的请求安排或取消警报。</em></li></ol><h1 id="214d" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">应用算法</h1><p id="3b4b" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated"><strong class="jx io">步骤1 &amp; 2 </strong>(演员执行的所有动作列表):</p><p id="9ae0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> <em class="mj">乐趣</em></strong><em class="mj">addNewAlarm(request:add request)<br/></em><strong class="jx io"><em class="mj">乐趣</em> </strong> <em class="mj"> deleteAlarm(杞人忧天)<br/> </em> <strong class="jx io"> <em class="mj">乐趣</em></strong><em class="mj">getAllAlarms():List&lt;杞人忧天信息&gt; <br/> </em> <strong class="jx io"> <em class="mj">乐趣</em> </strong>激活</p><p id="69f7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">步骤3 </strong>(按演员组合分组划分界面):</p><ul class=""><li id="60c5" class="ma mb in jx b jy jz kc kd kg mc kk md ko me ks mf mg mh mi bi translated"><em class="mj">component interface 1<br/></em><strong class="jx io"><em class="mj">actors:</em></strong><em class="mj">alarm configuration presenter<br/></em><strong class="jx io"><em class="mj">fun</em></strong><em class="mj">addNewAlarm(request:add request)</em></li><li id="69e9" class="ma mb in jx b jy mk kc ml kg mm kk mn ko mo ks mf mg mh mi bi translated"><em class="mj">component interface 2<br/></em><strong class="jx io"><em class="mj">演员:</em></strong><em class="mj">alarmslist presenter<br/></em><strong class="jx io"><em class="mj">趣味</em></strong><em class="mj">getAllAlarms():List&lt;alarm info&gt;</em></li><li id="17a3" class="ma mb in jx b jy mk kc ml kg mm kk mn ko mo ks mf mg mh mi bi translated"><em class="mj">component interface 3<br/></em><strong class="jx io"><em class="mj">actor:</em></strong><em class="mj">alarm configuration presenter，AlarmsListPresenter<br/></em><strong class="jx io"><em class="mj">fun</em></strong><em class="mj">activate alarm(alargid:String)<br/></em><strong class="jx io"><em class="mj">fun</em></strong><em class="mj">deactivate alarm(alarm:String)【T122</em></li></ul><p id="bb20" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">步骤4 </strong>(根据分离上下文重新评估所有命名):</p><ul class=""><li id="6ea1" class="ma mb in jx b jy jz kc kd kg mc kk md ko me ks mf mg mh mi bi translated"><strong class="jx io"><em class="mj">AlarmsRegistryService</em></strong><em class="mj"><br/></em><strong class="jx io"><em class="mj">fun</em></strong><em class="mj">注册(请求:RegisterAlarmRequest) </em></li><li id="46ea" class="ma mb in jx b jy mk kc ml kg mm kk mn ko mo ks mf mg mh mi bi translated"><strong class="jx io"><em class="mj">alarmstoreservice</em></strong><em class="mj"><br/></em><strong class="jx io"><em class="mj">fun</em></strong><em class="mj">getAllAlarms():List&lt;alarm info&gt;</em></li><li id="4c99" class="ma mb in jx b jy mk kc ml kg mm kk mn ko mo ks mf mg mh mi bi translated"><strong class="jx io"><em class="mj">alarmsmaintenance service</em></strong><em class="mj"><br/></em><strong class="jx io"><em class="mj">fun</em></strong><em class="mj">activate(id:String)<br/></em><strong class="jx io"><em class="mj">fun</em></strong><em class="mj">deactivate(杞人忧天:String)<br/></em><strong class="jx io"><em class="mj">fun</em></strong><em class="mj">delete(杞人忧天:String) </em></li></ul><p id="0828" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我喜欢这种方法的原因是，在应用算法之前，我真的无法预测我最终会得到这些组件。</p><p id="4eaa" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们有了每个用户<strong class="jx io">依赖于整个组件的组件；</strong>没有用户可以访问未使用的功能。</p><p id="ef4b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">仔细观察生成的接口——这种分离非常有意义。以<em class="mj">AlarmsRegistryService:<br/></em>为例，与报警注册相关的用例不应访问影响现有报警的功能。<br/>此外，随着系统的发展，可能会出现与报警登记相关的额外功能和数据模型；因为它们将与<em class="mj"> register() </em>函数<em class="mj">、</em>一起使用，所以它们可以合理地依赖于<em class="mj"> AlarmsRegistryService </em>。</p><p id="049c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">有人可能会说，这种类型的界面分离对于未来的产品需求来说过于间接和敏感。例如——直接从AlarmsListPresenter <em class="mj">创建新警报。</em>没错，就是这样。但是，因为每个组件<strong class="jx io"> </strong>都是专门为其用例设计的<strong class="jx io">——哪些用例可能受到影响</strong>将会非常清楚<strong class="jx io">。所以，会很容易改变。此外，并没有真正的方法来设计一个系统，以适应未来所有可能的需求；试图这样做可能会导致一个复杂的、过度工程化的系统。</strong></p><p id="3c58" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这种设计技术的另一个好的“副作用”是，从这种建模中出现的结构倾向于清楚地反映业务领域结构，这使得开发人员和其他业务涉众使用同一种语言。这与当<strong class="jx io">主要</strong>关注软件层、架构模式或特定框架规则时出现的结构形成对比。</p><p id="94c7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后，设计算法确保对于相同的系统分析——<strong class="jx io">将进行相同的设计</strong>；在一个由几个程序员组成的团队中工作在同一个代码库上，这可以节省时间并提高一致性。</p><p id="b9ea" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">就像一首好歌的歌词和旋律在不断变化的音效和流派的边缘悬而未决一样，声音代码质量也在不断变化的技术和框架的边缘。</p><p id="cf97" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们一起创造伟大音乐的未来！</p></div></div>    
</body>
</html>