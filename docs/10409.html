<html>
<head>
<title>Metal-cpp Tutorial 3: Shader Argument Buffer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Metal-cpp 教程 3:着色器参数缓冲区</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/metal-cpp-tutorial-3-shader-argument-buffer-68b2271c97ed?source=collection_archive---------9-----------------------#2022-10-31">https://blog.devgenius.io/metal-cpp-tutorial-3-shader-argument-buffer-68b2271c97ed?source=collection_archive---------9-----------------------#2022-10-31</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/></div><div class="ab cl jk jl hr jm" role="separator"><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp"/></div><div class="ig ih ii ij ik"><h1 id="7551" class="jr js in bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">介绍</h1><p id="d863" class="pw-post-body-paragraph kp kq in kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">在本教程中，我们将看看如何创建一个参数缓冲区，为顶点着色器提供一种间接引用 GPU 上的数据缓冲区的方法。</p><h1 id="e1e7" class="jr js in bd jt ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk lr km kn ko bi translated">着色器代码</h1><p id="4a95" class="pw-post-body-paragraph kp kq in kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">让我们来看看一些示例金属着色器代码。</p><figure class="ls lt lu lv gt lw"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="1b28" class="pw-post-body-paragraph kp kq in kr b ks lz ku kv kw ma ky kz la mb lc ld le mc lg lh li md lk ll lm ig bi translated">在这个着色器程序中，顶点着色器函数(第 14 行)的第一个参数采用一个指向 GPU 上的<em class="me"> VertexData </em>对象的指针，该对象包含指向 GPU 上的位置和颜色数据的缓冲区的指针，后面是一个属性说明符，该说明符指定我们传入的参数缓冲区中包含数据的索引。这里的想法是，当我们开始有更多的输入时，我们可以保持我们的参数列表较小；随着我们开发更复杂的功能。</p><h1 id="2d40" class="jr js in bd jt ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk lr km kn ko bi translated">重构</h1><p id="4536" class="pw-post-body-paragraph kp kq in kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">让我们看看更新后的<em class="me">渲染器</em>类。</p><figure class="ls lt lu lv gt lw"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="9e92" class="pw-post-body-paragraph kp kq in kr b ks lz ku kv kw ma ky kz la mb lc ld le mc lg lh li md lk ll lm ig bi translated">我们添加了两个新的数据成员，它们是指向一个着色器程序(第 15 行)和一个金属缓冲对象的指针，该对象的目的是存储参数数据(第 17 行)。在我们的<code class="fe mf mg mh mi b">BuildShader()</code>函数中，我们将创建的着色器程序存储在 shaderLibrary 变量中。</p><p id="d67c" class="pw-post-body-paragraph kp kq in kr b ks lz ku kv kw ma ky kz la mb lc ld le mc lg lh li md lk ll lm ig bi translated">让我们来看看我们新的<code class="fe mf mg mh mi b">BuildBuffer()</code>函数:</p><figure class="ls lt lu lv gt lw"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="5f4c" class="pw-post-body-paragraph kp kq in kr b ks lz ku kv kw ma ky kz la mb lc ld le mc lg lh li md lk ll lm ig bi translated">从第 46 行开始，我们得到了指向金属顶点着色器函数“object”的指针。在第 48 行，我们创建了一个<em class="me"> MTL::ArgumentEncoder </em>对象，该对象将数据编码到顶点着色器函数中参数索引为 0 的参数中。在第 51 行，我们创建了一个金属缓冲区来存储参数。<code class="fe mf mg mh mi b">encodedLength()</code>函数根据参数的内存需求和类型返回一个大小。在第行中，我们首先将参数缓冲区绑定到我们将要写入数据的编码器对象。然后在第 56 行和第 58 行，我们对各自的颜色和位置数据缓冲区的引用进行编码，并设置偏移量和索引(应该与 id 匹配。在第 61 行，我们告诉 GPU 缓冲区已经被修改。最后，我们将不再需要的对象释放到内存池中。</p><p id="4bd5" class="pw-post-body-paragraph kp kq in kr b ks lz ku kv kw ma ky kz la mb lc ld le mc lg lh li md lk ll lm ig bi translated">现在让我们看看我们的 update <code class="fe mf mg mh mi b">Draw()</code>函数，它包含了新的变化。</p><figure class="ls lt lu lv gt lw"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="21df" class="pw-post-body-paragraph kp kq in kr b ks lz ku kv kw ma ky kz la mb lc ld le mc lg lh li md lk ll lm ig bi translated">我们新的 draw 函数比之前的实现小了一点。在第 16 行，我们将前面创建的参数缓冲区绑定到缓冲区参数表上的索引 0，从偏移量 0 开始。在第 18 行和第 20 行，我们将指向位置和颜色金属缓冲区的指针传递给<code class="fe mf mg mh mi b">useResouce()</code>函数，该函数将告诉 GPU 绑定这些缓冲区。</p><h1 id="f3b1" class="jr js in bd jt ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk lr km kn ko bi translated">结论</h1><p id="c56d" class="pw-post-body-paragraph kp kq in kr b ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">如果您正确地执行了所有操作，您应该得到以下输出:</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi mj"><img src="../Images/4af129f389b41152604208ce4a1e6031.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y52X6TcgFLV1qXENuvcRyg.png"/></div></div></figure><p id="769b" class="pw-post-body-paragraph kp kq in kr b ks lz ku kv kw ma ky kz la mb lc ld le mc lg lh li md lk ll lm ig bi translated">像往常一样，查看<a class="ae mq" href="https://github.com/lilAbi/Metal-cpp-Tutorial-3-Shader-Argument-Buffer" rel="noopener ugc nofollow" target="_blank">项目库</a>以获取更多信息。</p></div></div>    
</body>
</html>