<html>
<head>
<title>Go Concurrency testing in CPU constrained environments</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在 CPU 受限的环境中进行并发测试</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/go-concurrency-testing-in-cpu-constrained-environments-8788052b7560?source=collection_archive---------5-----------------------#2022-02-22">https://blog.devgenius.io/go-concurrency-testing-in-cpu-constrained-environments-8788052b7560?source=collection_archive---------5-----------------------#2022-02-22</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="1d51" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们探讨一些复杂的 go 并发编程错误和竞争条件。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/49f6b3deae18118959365bca057d1a48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hxsSiXxyCayTmryr"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上<a class="ae ky" href="https://unsplash.com/@laurentmedia?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">给</a>拍照</figcaption></figure><p id="7f93" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在将 go 应用程序的 CI/CD 管道从基于 VM 的 jenkins 部署迁移到基于 kubernetes 的 Jenkins 部署时，我遇到了一个问题，即现有的单元测试会挂起，直到 10 分钟超时。单元测试通过了基于 VM 的 Jenkins 工人和本地。但是它在 kubernetes 的 Jenkins 工人身上一直失败。我没有参与这个 kubernetes Jenkins 集群的设置，老实说，我没有太关注它。但是我确实记得在组织的其他地方，他们对在 Kubernetes 上运行的所有东西分配资源限制非常严格。<br/>这恰好非常重要。</p><h2 id="0084" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">设置</h2><p id="ebdd" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">单元测试是为了测试一些并发代码。被测试的逻辑是代码是否会通过信道发送消息。<br/>测试设置如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="94f1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">单元测试实例化了一个 go 例程来侦听“<em class="lz">GetQueueMetadataUpdateChannel()</em>的返回通道。当它得到那个消息时，它会沿着`<em class="lz"> resultCh </em>'把它发送出去。为什么是间接的？<br/>由于通道不是缓冲通道，并且代码正在执行<a class="ae ky" href="https://gobyexample.com/non-blocking-channel-operations" rel="noopener ugc nofollow" target="_blank">非阻塞发送</a>，测试必须启动一些东西来侦听“<em class="lz">GetQueueMetadataUpdateChannel()</em>”通道。<br/>测试的下一部分调用了一些代码，这些代码将在更新通道上生成一条消息。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="89d2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">“<em class="lz"> QueueRequest() </em>”方法导致在上述更新通道上发送消息。在调用`<em class="lz"> QueueRequest() </em>之后，我们阻塞，等待结果通道上的消息。现在，暂停一下，看看你是否能发现问题？<br/>提示，它每次都在我的笔记本电脑上工作。</p><h2 id="8464" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">发生了什么</h2><p id="1db2" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">在一次罕见的耐心较量中，我决定让挂起的 jenkins 作业运行很长时间，直到某个超时。从日志中我可以看到运行`<em class="lz"> go 测试。/… </em>`一直工作到一个特定的单元测试。超时输出实际上非常有用。<br/>第一条消息:</p><blockquote class="ma mb mc"><p id="4297" class="jk jl lz jm b jn jo jp jq jr js jt ju md jw jx jy me ka kb kc mf ke kf kg kh ig bi translated">死机:10m0s 后测试超时</p></blockquote><p id="2e50" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">接下来是大量的 goroutine 堆栈跟踪。最后一个是我需要看到的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="b2a7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">堆栈跟踪中的第 61 行是 gist1 中的第 7 行。所以代码阻止了发送。这让我很困惑，但我知道这与`<em class="lz"> QueueRequest() </em>'调用的时间有关。我的假设是 jenkins 环境必须运行在单个 CPU 内核或 CPU 受限的环境中。在 Jenkins 中，CPU 必须忙于处理“<em class="lz"> QueueRequest() </em>”中的代码，永远没有时间执行 go 例程代码。<br/>如果是这种情况，我应该能够在本地复制它——请记住，我不知道这个 Jenkins 集群的设置，也无权探索它。我运行了两个测试:首先，我将一个`<em class="lz"> go 测试</em>`运行限制在一个 CPU 内核上。<br/>然后我试着用`<em class="lz">—CPU = 1</em>`用 docker 模拟了`<em class="lz"> resources.limits.cpu: 1 </em>`的等价物。<br/>注意:`<em class="lz"> —在 docker 或等效的 kubernetes 配置中，CPU = 1</em>`意味着在理想情况下，你的容器每秒将获得 1 个 CPU 秒。下面的截图也将证明这一点。<br/>第一次测试:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="842f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">果然，我把单元测试挂了。<br/>您可以看到只有一个内核处于活动状态:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mg"><img src="../Images/a799197a17ed0c5aff80402a4fe9bf18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ESmFO0fDUZ8NXwOyPSs0uA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">安装依赖项时，容器 CPU 处于最大利用率</figcaption></figure><p id="355a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">原谅错别字；图像上的上述标签应为“CPU sets-CPU ”,而不是“CPU sets-CPU”。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mh"><img src="../Images/d5e3597e8ba9e628cf95e1f0dbae2d48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ND1GrvM2aASq_BK4yeUiAw.png"/></div></div></figure><p id="5daf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">接下来，我尝试设置 1 个 CPU 共享的限制:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="2b07" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">同样的悬挂行为。<br/>在这里，您可以看到容器使用了所有 4 个内核，但每个 CPU 仅用了`. 25 `到`. 3 `秒。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mi"><img src="../Images/1143c160733f36bc7607877f13de2a54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z6z1UatR6T1VxKYhGY-uoQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">CPU 使用率下降，但是单元测试挂起</figcaption></figure><p id="3267" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后，仅仅为了进行一个健全性测试，我尝试给容器 2 个 CPU，它通过了。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lx ly l"/></div></figure><h2 id="6bdc" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">修复</h2><p id="5da8" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">下面是我为提高代码的持久性以处理 CPU 受限环境而做的更改。</p><p id="6d9a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这些变化是为了</p><ul class=""><li id="5f46" class="mj mk in jm b jn jo jr js jv ml jz mm kd mn kh mo mp mq mr bi translated">创建一个错误通道，</li><li id="abd9" class="mj mk in jm b jn ms jr mt jv mu jz mv kd mw kh mo mp mq mr bi translated">使结果通道被缓冲，</li><li id="cf52" class="mj mk in jm b jn ms jr mt jv mu jz mv kd mw kh mo mp mq mr bi translated">并让单元测试在检查结果通道时检查错误通道。</li></ul><p id="9284" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我天真地尝试了这段代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="db39" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">那不行，还有很多问题:<br/> <a class="ae ky" href="https://go.dev/ref/spec#Select_statements" rel="noopener ugc nofollow" target="_blank"> ` <em class="lz">选择</em>`语句是非确定性的！！！在这种情况下，我们需要使用嵌套的 select 语句。另外，在我没有预料到的时候，` close()'被调用了！<br/> `close()`使从 a 通道的接收返回类型的零值，而不是阻塞(</a><a class="ae ky" href="https://go.dev/ref/spec#Close" rel="noopener ugc nofollow" target="_blank">源</a>)。<br/>结果是 goroutine 填满了错误通道，然后 select 将阻塞。</p><p id="7104" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">此外，执行线程直接进入`<em class="lz"> QueueRequest() </em>`调用，从未让 go 例程开始它的 for 循环。这导致“<em class="lz"> QueueRequest() </em>”调用在测试中的 go 例程获得 CPU 时间之前终止了更新通道。<br/>由于`<em class="lz"> QueueRequest() </em>`关闭了没有接收方的通道，一旦 go 例程开始，它就从更新通道返回一个零值消息。</p><p id="6834" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">以下是实际的解决方案:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="2452" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这不是很漂亮，但让我们走过它。<br/>首先，我们检查更新通道是否仍然打开。<br/>接下来，我们尝试沿着结果通道发送消息。如果失败，我们将进入默认情况。<br/>注意:`<em class="lz"> select </em>`的不确定性是指如果结果通道有一个监听器，错误通道有一个监听器，那么它会随机选择任一种情况。这导致 select 有时选择发送错误消息，有时将更新发送到结果通道。<br/>我们通过在“<em class="lz"> default </em>”分支中嵌套另一个非阻塞发送来解决这个问题。如果没有一个监听器监听“errCh<em class="lz">errCh</em>”,那么我们将会恐慌，因为这是一种意想不到的行为。最后，我们必须让单元测试线程休眠一毫秒。这给了 go 调度程序时间来实际启动 go 例程。所发生的情况是，单元测试将到达 go 例程，但是单元测试线程将继续消耗整个 CPU 周期，因此执行在单元测试线程上进行到“<em class="lz"> QueueRequest() </em>”。一旦`<em class="lz"> QueueRequest() </em>`在更新通道上进行非阻塞发送，它将发现通道没有侦听器，并关闭它(注意，这是它们的编码方式，不是 golang 特有的)。执行将返回到单元测试，在那里我们从结果通道中选择一条消息。显然不会有，所以单元测试会永远挂起。</p><h2 id="1556" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">结论</h2><p id="2476" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">我们在这里学到了两件有趣的事情。<br/>当用`<em class="lz"> go func() {}() </em>初始化 go 程序时，该程序不会立即执行。相反，调用线程保持执行优先级，直到它暂停(睡眠、阻塞 IO 等。).只有这样，go 例程中的代码才会得到执行。这样措辞的话，似乎有点显而易见。但是在编写代码时，我很容易忽略这一点，特别是考虑到在多核机器上，go 例程确实与单元测试的线程并行执行。<br/>其次，我们了解了 go 并发性的一些细微差别，这些差别在 golang 介绍材料中没有解释(我在看你，Go by example:)。`<em class="lz">选择</em>`是非确定性的。此外，在 go 中使用`<em class="lz"> close() </em>`通道意味着您仍然可以从它那里“接收”消息，它只是返回零值，而不会阻塞。这似乎是一件特别容易绊倒的事情。<br/>教训是，当有疑问时，使用接收的 2 变量形式:`<em class="lz"> msg，open := &lt; -ch </em>`。</p><p id="660b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你怎么想呢?我能换一种方式解决这个问题吗？有问题吗？我总是很高兴有一个对话，所以评论或伸出手！</p></div></div>    
</body>
</html>