<html>
<head>
<title>Create First Microservice using Spring Boot</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Spring Boot 创建首个微服务</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/create-first-microservice-using-spring-boot-1994cd78bbdf?source=collection_archive---------4-----------------------#2022-02-19">https://blog.devgenius.io/create-first-microservice-using-spring-boot-1994cd78bbdf?source=collection_archive---------4-----------------------#2022-02-19</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/25816a2c6adfb5143597e5cc09df4ffe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eKSgXCeDjIGpkacGFfGzqw.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated"><a class="ae jz" href="https://unsplash.com/@kieran_wood?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">基兰·伍德</a>在<a class="ae jz" href="https://unsplash.com/s/photos/puzzle?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="a8f2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">读完标题后，你可能想知道什么是微服务，以及它与整体 Java 程序的不同之处。如果我们研究微服务的定义。基本上，微服务是一种架构。</p><figure class="kz la lb lc gt jo gh gi paragraph-image"><div class="gh gi ky"><img src="../Images/74c2a0f15315ac87d226a1fd90042206.png" data-original-src="https://miro.medium.com/v2/resize:fit:1098/format:webp/0*tlxgOG5dLrdJWYJ5.jpg"/></div></figure><blockquote class="ld le lf"><p id="82ad" class="ka kb lg kc b kd ke kf kg kh ki kj kk lh km kn ko li kq kr ks lj ku kv kw kx ig bi translated"><strong class="kc io">微服务(或微服务架构)是一种云原生架构方法，其中单个应用由许多松散耦合且可独立部署的较小组件或服务组成</strong></p></blockquote><p id="b6f2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">那么为什么是微服务而不是使用 monolith 程序呢？</p><ul class=""><li id="79ee" class="lk ll in kc b kd ke kh ki kl lm kp ln kt lo kx lp lq lr ls bi translated"><strong class="kc io"> <em class="lg">更容易构建和维护应用</em> </strong> —微服务的关键原则是简单。当应用程序被分割成一组更小的、可组合的片段时，它们变得更容易构建和维护。管理代码也变得不那么痛苦，因为每个微服务实际上是一个独立的代码块。服务可以使用不同的编程语言、数据库和软件环境来实现。这允许独立地部署、重建、重新部署和管理每个服务。</li><li id="4bdf" class="lk ll in kc b kd lt kh lu kl lv kp lw kt lx kx lp lq lr ls bi translated"><strong class="kc io"> <em class="lg">提高生产力和速度— </em> </strong>因为有了微服务，每个开发团队可以只看自己正在构建的具体服务，而不用担心整个源代码。这将随着交付速度提高团队的生产力。</li><li id="c3c5" class="lk ll in kc b kd lt kh lu kl lv kp lw kt lx kx lp lq lr ls bi translated"><strong class="kc io"> <em class="lg">微服务可独立扩展— </em> </strong>随着应用需求的增加，使用微服务更容易扩展。您可以将资源增加到最需要的微服务，而不是扩展整个应用。这也意味着扩展速度更快，通常也更具成本效益。</li><li id="b666" class="lk ll in kc b kd lt kh lu kl lv kp lw kt lx kx lp lq lr ls bi translated"><strong class="kc io"> <em class="lg">微服务通过故障隔离减少停机时间— </em> </strong>如果某个特定的微服务出现故障，您可以将故障隔离到单个服务，并防止会导致应用崩溃的级联故障。这种故障隔离意味着，即使其中一个模块出现故障，您的关键应用程序也可以继续运行。</li></ul><p id="b11b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所以现在我们知道了为什么通常所有的大组织更喜欢微服务，而不是维护一个大的组合源代码。让我们尝试使用 Spring Boot 开发一个微服务，这是一个非常流行的 Java 框架，用于开发企业应用程序。</p></div><div class="ab cl ly lz hr ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ig ih ii ij ik"><h2 id="3d33" class="mf mg in bd mh mi mj dn mk ml mm dp mn kl mo mp mq kp mr ms mt kt mu mv mw mx bi translated">项目描述</h2><p id="847a" class="pw-post-body-paragraph ka kb in kc b kd my kf kg kh mz kj kk kl na kn ko kp nb kr ks kt nc kv kw kx ig bi translated">我们要开发的是一个微服务，为加州的旅游应用程序创建 RESTful APIs🗻。我们开始吧，</p><h2 id="6635" class="mf mg in bd mh mi mj dn mk ml mm dp mn kl mo mp mq kp mr ms mt kt mu mv mw mx bi translated">创建项目</h2><p id="7e92" class="pw-post-body-paragraph ka kb in kc b kd my kf kg kh mz kj kk kl na kn ko kp nb kr ks kt nc kv kw kx ig bi translated">在 Spring 生态系统中，你可以找到很多依赖关系。为此，我们需要依赖于</p><ul class=""><li id="6f16" class="lk ll in kc b kd ke kh ki kl lm kp ln kt lo kx lp lq lr ls bi translated">Web，其中包括 Tomcat 和 Spring MVC</li><li id="db1f" class="lk ll in kc b kd lt kh lu kl lv kp lw kt lx kx lp lq lr ls bi translated">Rest 存储库通过 REST APIs 公开 Spring 数据存储库</li><li id="2248" class="lk ll in kc b kd lt kh lu kl lv kp lw kt lx kx lp lq lr ls bi translated">Java 持久性 API</li><li id="41a9" class="lk ll in kc b kd lt kh lu kl lv kp lw kt lx kx lp lq lr ls bi translated">H2 内存数据库</li></ul><p id="5291" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">使用<a class="ae jz" href="https://start.spring.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="lg">Spring Initializer</em></strong></a><strong class="kc io"><em class="lg">可以轻松创建一个 Spring 项目。</em> </strong>进入 spring initializer 网页，选择 project 作为 Maven 项目，对于语言选择 Java，填充项目元数据，选择 packaging as JAR，选择你正在开发的 Java 版本。然后添加依赖项，</p><ul class=""><li id="bc8d" class="lk ll in kc b kd ke kh ki kl lm kp ln kt lo kx lp lq lr ls bi translated">Spring MVC</li><li id="8e8f" class="lk ll in kc b kd lt kh lu kl lv kp lw kt lx kx lp lq lr ls bi translated">REST 存储库</li><li id="a082" class="lk ll in kc b kd lt kh lu kl lv kp lw kt lx kx lp lq lr ls bi translated">春季数据 JPA</li><li id="d786" class="lk ll in kc b kd lt kh lu kl lv kp lw kt lx kx lp lq lr ls bi translated">H2 数据库</li></ul><p id="3058" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最后，单击 generate，它将下载一个 zip 文件，该文件使用您的<code class="fe nd ne nf ng b">pom.xml</code>文件中指向的依赖项创建了您的项目结构。</p><figure class="kz la lb lc gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nh"><img src="../Images/f55147f982ccbb555fab836f3b7970e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iNOLy5xX14y9QgfcuCP4nA.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">Spring initializer 项目示例详细信息</figcaption></figure><h2 id="2443" class="mf mg in bd mh mi mj dn mk ml mm dp mn kl mo mp mq kp mr ms mt kt mu mv mw mx bi translated">项目结构</h2><figure class="kz la lb lc gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nh"><img src="../Images/b63d115e51208f2384f038dfed928e19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KDJStviTj8VY-JLR9fVEdw.png"/></div></div></figure><p id="3592" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">正如你在上面的图片中看到的，有几个文件，如果我们检查<code class="fe nd ne nf ng b">pom.xml</code>文件，我们可以看到我们在 Spring 初始化器中添加的依赖项。</p><p id="aeea" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们看看<code class="fe nd ne nf ng b">CaliforniaApplication.java</code>的文件。</p><figure class="kz la lb lc gt jo"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="39f9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个<code class="fe nd ne nf ng b">CaliforniaApplication.java</code>文件有一个<code class="fe nd ne nf ng b">main</code>方法，还有一个<code class="fe nd ne nf ng b">@SpringBootApplication</code>注释。添加这个注释意味着我们告诉 JVM 这是微服务启动的地方，方法就在那里，所以它不像打包的 war 文件，所以我们可以实际控制 web 应用程序的启动和停止。</p><blockquote class="ld le lf"><p id="724c" class="ka kb lg kc b kd ke kf kg kh ki kj kk lh km kn ko li kq kr ks lj ku kv kw kx ig bi translated"><code class="fe nd ne nf ng b">@SpringBootApplication</code>注释用于标记声明一个或多个<code class="fe nd ne nf ng b">@Bean</code>方法的配置类，同时触发<code class="fe nd ne nf ng b">auto-configuration</code>和组件扫描。这和用<code class="fe nd ne nf ng b">@Configuration, @EnableAutoConfiguration and @ComponentScan</code>注释声明一个类是一样的。</p></blockquote><h2 id="d5e7" class="mf mg in bd mh mi mj dn mk ml mm dp mn kl mo mp mq kp mr ms mt kt mu mv mw mx bi translated">正在启动 Spring Boot 服务器</h2><p id="8235" class="pw-post-body-paragraph ka kb in kc b kd my kf kg kh mz kj kk kl na kn ko kp nb kr ks kt nc kv kw kx ig bi translated">当您运行 main 方法时，您可以看到 Spring 应用程序正在启动。要更改服务器正在启动的端口，您可以转到<code class="fe nd ne nf ng b">application.properties</code>文件并添加一个新属性<code class="fe nd ne nf ng b">server.port=8081</code></p><figure class="kz la lb lc gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nk"><img src="../Images/035f12c9955311909cae2c5710d154bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J3s2aChryXacl6igStUaJA.png"/></div></div></figure><p id="0b59" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">要检查服务器是否工作，请转到<a class="ae jz" href="http://localhost:8081/profile" rel="noopener ugc nofollow" target="_blank">http://localhost:8081/profile</a>，您可以看到如下内容:</p><figure class="kz la lb lc gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nh"><img src="../Images/5fd4eab5e2d436685761d9e51441c06c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1QWluZL0h9U3X6eSCevznQ.png"/></div></div></figure><h2 id="eb7d" class="mf mg in bd mh mi mj dn mk ml mm dp mn kl mo mp mq kp mr ms mt kt mu mv mw mx bi translated"><strong class="ak">开发项目</strong></h2><p id="426a" class="pw-post-body-paragraph ka kb in kc b kd my kf kg kh mz kj kk kl na kn ko kp nb kr ks kt nc kv kw kx ig bi translated">现在我们准备开发 Tour California restful web 服务。首先，让我们检查将要构建的 restful web 服务的类图</p><figure class="kz la lb lc gt jo gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/8431e422ef6026e6e31688c7426b6c94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1016/format:webp/1*ENI54AJKFYqJkyGbm5f5GQ.png"/></div></figure><h2 id="c9e0" class="mf mg in bd mh mi mj dn mk ml mm dp mn kl mo mp mq kp mr ms mt kt mu mv mw mx bi translated"><strong class="ak"> <em class="nm"> 1。创建模型</em> </strong></h2><p id="bf0b" class="pw-post-body-paragraph ka kb in kc b kd my kf kg kh mz kj kk kl na kn ko kp nb kr ks kt nc kv kw kx ig bi translated">首先，创建一个新的包并将其命名为<em class="lg">模型</em>，并在其中创建这些业务对象</p><figure class="kz la lb lc gt jo"><div class="bz fp l di"><div class="ni nj l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">Tour.java</figcaption></figure><figure class="kz la lb lc gt jo"><div class="bz fp l di"><div class="ni nj l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">TourPackage.java</figcaption></figure><figure class="kz la lb lc gt jo"><div class="bz fp l di"><div class="ni nj l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">Difficulty.java-枚举类</figcaption></figure><figure class="kz la lb lc gt jo"><div class="bz fp l di"><div class="ni nj l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">Region.java-枚举类</figcaption></figure><p id="2658" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">正如你在<code class="fe nd ne nf ng b">Tour.java</code>和<code class="fe nd ne nf ng b">TourPackage.java</code>文件中看到的，这里使用了一些注释。让我们看看他们的意思。这些注释在 Java 持久 API 中使用。作为一种规范，</p><blockquote class="ld le lf"><p id="e5a7" class="ka kb lg kc b kd ke kf kg kh ki kj kk lh km kn ko li kq kr ks lj ku kv kw kx ig bi translated">Java Persistence API 与持久性有关，持久性泛指 Java 对象比创建它们的应用程序进程更长寿的任何机制。</p></blockquote><ul class=""><li id="a5a0" class="lk ll in kc b kd ke kh ki kl lm kp ln kt lo kx lp lq lr ls bi translated"><strong class="kc io"> <em class="lg"> @Entity — </em> </strong>用@Entity 标注你所有的实体 beans。</li><li id="6e42" class="lk ll in kc b kd lt kh lu kl lv kp lw kt lx kx lp lq lr ls bi translated"><strong class="kc io"> <em class="lg"> @Column </em> </strong> —使用@Column 注释指定列映射。</li><li id="d161" class="lk ll in kc b kd lt kh lu kl lv kp lw kt lx kx lp lq lr ls bi translated"><strong class="kc io"> <em class="lg"> @Id </em> </strong> —使用@Id 标注 Id 列。</li><li id="47f0" class="lk ll in kc b kd lt kh lu kl lv kp lw kt lx kx lp lq lr ls bi translated"><strong class="kc io"><em class="lg">@ generated value</em></strong>—让数据库生成(自动递增)id 列。</li><li id="8aaf" class="lk ll in kc b kd lt kh lu kl lv kp lw kt lx kx lp lq lr ls bi translated"><strong class="kc io"> <em class="lg"> @OneToOne — </em> </strong>对于共享同一个主键的实体，我们可以用@OneToOne 将它们关联起来。</li><li id="148d" class="lk ll in kc b kd lt kh lu kl lv kp lw kt lx kx lp lq lr ls bi translated"><strong class="kc io"> <em class="lg"> @ManyToOne — </em> </strong>对于与一个实体有多种关系的实体，例如在我们的项目中，一个 TourPacakge 由多个 tour 组成。</li><li id="d03b" class="lk ll in kc b kd lt kh lu kl lv kp lw kt lx kx lp lq lr ls bi translated"><strong class="kc io"><em class="lg">@ Enumerated</em></strong>—通过这种方式，我们可以指示 JPA 提供者将枚举转换为它的序号或字符串值。</li></ul><h2 id="86e3" class="mf mg in bd mh mi mj dn mk ml mm dp mn kl mo mp mq kp mr ms mt kt mu mv mw mx bi translated"><strong class="ak"> <em class="nm"> 2。创建资源库</em> </strong></h2><p id="48a2" class="pw-post-body-paragraph ka kb in kc b kd my kf kg kh mz kj kk kl na kn ko kp nb kr ks kt nc kv kw kx ig bi translated">创建一个新的包名<em class="lg">存储库</em>并创建项目所需的存储库</p><figure class="kz la lb lc gt jo"><div class="bz fp l di"><div class="ni nj l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">TourRepository.java</figcaption></figure><figure class="kz la lb lc gt jo"><div class="bz fp l di"><div class="ni nj l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">TourPackageRepository.java</figcaption></figure><blockquote class="ld le lf"><p id="d86a" class="ka kb lg kc b kd ke kf kg kh ki kj kk lh km kn ko li kq kr ks lj ku kv kw kx ig bi translated">我们正在为我们拥有的两个实体创建存储库，并且我们还扩展了<code class="fe nd ne nf ng b">CrudRepository</code>接口，这是一个 Spring 数据接口，用于对特定类型的存储库进行通用 CRUD 操作。它提供了几种现成的与数据库交互的方法。扩展<code class="fe nd ne nf ng b">CrudRepository&lt;T, ID&gt;</code>时需要定义<code class="fe nd ne nf ng b"><em class="in">T-entity, ID-the type of your ID column in Entity</em></code> <em class="in">。</em></p></blockquote><p id="df6d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在上面的代码中，使用了一些注释。让我们看看它们是什么，</p><ul class=""><li id="4709" class="lk ll in kc b kd ke kh ki kl lm kp ln kt lo kx lp lq lr ls bi translated"><strong class="kc io"><em class="lg">@ RepositoryRestResource—</em></strong>用于设置公共存储库接口上的选项—它将根据正在扩展的存储库类型(crud Repository/PagingAndSortingRepository/etc)自动创建适当的端点</li><li id="b475" class="lk ll in kc b kd lt kh lu kl lv kp lw kt lx kx lp lq lr ls bi translated"><strong class="kc io"><em class="lg">@ Repository—</em></strong><em class="lg">@ Component</em>注释的专门化，用于表示该类提供了对对象进行存储、检索、更新、删除和搜索操作的机制。</li></ul><h2 id="4a2f" class="mf mg in bd mh mi mj dn mk ml mm dp mn kl mo mp mq kp mr ms mt kt mu mv mw mx bi translated">3.创建服务</h2><p id="8260" class="pw-post-body-paragraph ka kb in kc b kd my kf kg kh mz kj kk kl na kn ko kp nb kr ks kt nc kv kw kx ig bi translated">创建一个名为<em class="lg"> service </em>的新包，并在其中创建项目所需的服务。</p><figure class="kz la lb lc gt jo"><div class="bz fp l di"><div class="ni nj l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">TourService.java</figcaption></figure><figure class="kz la lb lc gt jo"><div class="bz fp l di"><div class="ni nj l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">TourPackageService.java</figcaption></figure><p id="8ed3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在上面的代码中，使用了一些注释。让我们看看它们是什么，</p><ul class=""><li id="a1c3" class="lk ll in kc b kd ke kh ki kl lm kp ln kt lo kx lp lq lr ls bi translated"><strong class="kc io"> <em class="lg"> @Service </em> </strong> —这是<strong class="kc io">用于提供一些业务功能</strong>的类。当使用基于注释的配置和类路径扫描时，Spring context 将自动检测这些类。</li><li id="c276" class="lk ll in kc b kd lt kh lu kl lv kp lw kt lx kx lp lq lr ls bi translated"><strong class="kc io"> <em class="lg"> @Autowired </em> </strong> —该注释提供了对在何处以及如何完成自动连线的更细粒度的控制。就像<em class="lg"> @Required </em>注释、构造函数、具有任意名称和/或多个参数的属性或方法一样，<em class="lg"> @Autowired </em>注释可用于在 setter 方法上自动连接 bean。</li></ul><p id="0dac" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">正如你在上面的代码中看到的，我们正在使用之前创建的存储库接口来使用已经在<code class="fe nd ne nf ng b">CrudRepository</code>中开发的方法，比如<code class="fe nd ne nf ng b">findById(),findAll()</code>。基本上，我们使用服务向外部屏蔽存储库，并在<em class="lg">业务层</em>中使用我们想要的逻辑。</p><h2 id="b497" class="mf mg in bd mh mi mj dn mk ml mm dp mn kl mo mp mq kp mr ms mt kt mu mv mw mx bi translated">4.数据库设置</h2><p id="d652" class="pw-post-body-paragraph ka kb in kc b kd my kf kg kh mz kj kk kl na kn ko kp nb kr ks kt nc kv kw kx ig bi translated">在我们的项目中，为了看到 API 正在工作，我们需要在数据库中有一些数据。这里我们使用的是 h2 内存数据库。因此，让我们首先向<code class="fe nd ne nf ng b">application.properties</code>添加一些配置，在这里我们可以访问内存数据库。</p><pre class="kz la lb lc gt nn ng no np aw nq bi"><span id="cba3" class="mf mg in ng b gy nr ns l nt nu">spring.h2.console.enabled=true<br/>spring.datasource.url=jdbc:h2:mem:tourcalifornia<br/>spring.datasource.driverClassName=org.h2.Driver<br/>spring.datasource.username=admin<br/>spring.datasource.password=admin<br/>spring.jpa.database-platform=org.hibernate.dialect.H2Dialect<br/><br/>spring.jpa.hibernate.ddl-auto=create-drop</span></pre><p id="4a3c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在从主方法所在的<code class="fe nd ne nf ng b">CaliforniaApplication.java</code>开始，我们可以实现接口<code class="fe nd ne nf ng b">CommandLineRunner</code>，这是一个简单的 Spring Boot 接口，带有一个运行方法。加载应用程序上下文后，Spring Boot 将自动调用实现该接口的所有 bean 的 run 方法。</p><p id="c6aa" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">首先，我们向我们的<code class="fe nd ne nf ng b">application.properties</code>文件添加一个属性来读取<code class="fe nd ne nf ng b">ExploreCalifornia.json</code>文件</p><pre class="kz la lb lc gt nn ng no np aw nq bi"><span id="a497" class="mf mg in ng b gy nr ns l nt nu">ec.importfile=ExploreCalifornia.json</span></pre><p id="7fb6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后我们添加一些代码来读取 JSON 文件，并将它们添加到数据库的<code class="fe nd ne nf ng b">CaliforniaApplication.java </code>文件中。我们可以在 spring 中使用@value 来导入文件名。</p><ul class=""><li id="7c6b" class="lk ll in kc b kd ke kh ki kl lm kp ln kt lo kx lp lq lr ls bi translated"><strong class="kc io"> <em class="lg"> @Value </em> </strong> —该注释提供了一种将属性值注入组件的便捷方式。对于属性可能不存在的情况，提供合理的缺省值也非常有用</li></ul><figure class="kz la lb lc gt jo"><div class="bz fp l di"><div class="ni nj l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">CaliforniaApplication.java</figcaption></figure><p id="e415" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们需要为<code class="fe nd ne nf ng b">TourPackageRepository.java</code>文件添加一个新方法，因为我们使用了</p><pre class="kz la lb lc gt nn ng no np aw nq bi"><span id="2dd5" class="mf mg in ng b gy nr ns l nt nu">TourPackage tourPackage = tourPackageRepository.findByName(tourPackageName).orElseThrow(() -&gt;<br/>        new RuntimeException("Tour package does not exist: " + tourPackageName));</span></pre><p id="fd40" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，让我们将<code class="fe nd ne nf ng b">Optional&lt;TourPackage&gt; findByName(String name);</code>添加到<code class="fe nd ne nf ng b">TourPackageRepository.java</code>文件中。</p><figure class="kz la lb lc gt jo"><div class="bz fp l di"><div class="ni nj l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">更新的 TourRepository.java</figcaption></figure><p id="367e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们重新启动服务器，并转到 h2 数据库控制台所在的<a class="ae jz" href="http://localhost:8081/h2-console/" rel="noopener ugc nofollow" target="_blank">http://localhost:8081/H2-console/</a>URL。</p><figure class="kz la lb lc gt jo gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/fe6ee6899f5494cca9ed749678139f32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*DflB6Mk9VCI3_m4JPCV0Qw.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">h2 登录控制台</figcaption></figure><p id="c001" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后添加您在<code class="fe nd ne nf ng b">application.properties</code>中配置的用户名、密码、JDBC 网址，登录 h2 控制台。看到填充到表格中的数据可以运行一个简单的查询，如<code class="fe nd ne nf ng b">SELECT * from TOUR;</code></p><figure class="kz la lb lc gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nw"><img src="../Images/4b175fc893e080573f16b7112de4f31b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ujy99BUtxjUXl8T73pofow.png"/></div></div></figure><p id="bdb6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">或者我们实际上可以在浏览器中访问<a class="ae jz" href="http://localhost:8081/tours/" rel="noopener ugc nofollow" target="_blank">http://localhost:8081/tours/</a>并查看数据(因为我们在存储库中添加了<em class="lg">@ RepositoryRestResource</em>，所以我们可以在存储库中运行 GET/POST/PUT/DELETE 命令)。</p><figure class="kz la lb lc gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nx"><img src="../Images/effafbe3b6e0eb8505ea715cfb131765.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cSSlJHKu4pDJNEJ3m3aHEg.png"/></div></div></figure><p id="b8ed" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果您不希望数据像这样暴露，您需要在您的存储库中添加<code class="fe nd ne nf ng b">@RepositoryRestResource(exported = false)</code>。</p><h2 id="085b" class="mf mg in bd mh mi mj dn mk ml mm dp mn kl mo mp mq kp mr ms mt kt mu mv mw mx bi translated">5.创建控制器</h2><p id="845a" class="pw-post-body-paragraph ka kb in kc b kd my kf kg kh mz kj kk kl na kn ko kp nb kr ks kt nc kv kw kx ig bi translated">创建一个名为<em class="lg">控制器</em>的新包，并在其中创建项目所需的控制器。</p><figure class="kz la lb lc gt jo"><div class="bz fp l di"><div class="ni nj l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">TourController.java</figcaption></figure><p id="07b3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在上面的代码中，使用了一些注释。让我们看看它们是什么，</p><ul class=""><li id="b03b" class="lk ll in kc b kd ke kh ki kl lm kp ln kt lo kx lp lq lr ls bi translated"><strong class="kc io"><em class="lg">@ rest Controller</em></strong>—<em class="lg">@ rest Controller</em>结合了<em class="lg"> @Controller </em>和<em class="lg"> @ResponseBody </em></li><li id="1843" class="lk ll in kc b kd lt kh lu kl lv kp lw kt lx kx lp lq lr ls bi translated"><strong class="kc io"><em class="lg">@ request mapping</em></strong>—该注释标记了<em class="lg"> @Controller </em>类中的请求处理程序方法；可以使用<br/> - path 或其别名、名称和值进行配置:该方法映射到哪个 URL<br/>-method:兼容的 HTTP 方法<br/> - params:根据 HTTP 参数的存在、不存在或值过滤请求<br/> - headers:根据 HTTP 头的存在、不存在或值过滤请求<br/> - consumes:该方法可以在 HTTP 请求正文中使用哪些媒体类型<br/> - produces:该方法可以在 HTTP 响应正文中产生哪些媒体类型</li><li id="a987" class="lk ll in kc b kd lt kh lu kl lv kp lw kt lx kx lp lq lr ls bi translated"><strong class="kc io"><em class="lg">@ request body—</em></strong>将 HTTP 请求的主体映射到一个对象。</li><li id="caeb" class="lk ll in kc b kd lt kh lu kl lv kp lw kt lx kx lp lq lr ls bi translated"><strong class="kc io"><em class="lg">@ path variable—</em></strong>这个注释表示一个方法参数被绑定到一个 URI 模板变量。</li><li id="42ce" class="lk ll in kc b kd lt kh lu kl lv kp lw kt lx kx lp lq lr ls bi translated"><strong class="kc io"><em class="lg">【@ request param—</em></strong>该注释用于访问 HTTP 请求参数</li><li id="20c1" class="lk ll in kc b kd lt kh lu kl lv kp lw kt lx kx lp lq lr ls bi translated"><strong class="kc io"><em class="lg">@ POST mapping</em></strong>—<em class="lg">@ Controller</em>注释类中的<em class="lg"> @PostMapping </em>注释方法处理与给定 URI 表达式匹配的 HTTP POST 请求</li><li id="b85b" class="lk ll in kc b kd lt kh lu kl lv kp lw kt lx kx lp lq lr ls bi translated"><strong class="kc io"><em class="lg">@ GET mapping</em></strong>—<em class="lg">@ Controller</em>注释类中的<em class="lg"> @GetMapping </em>注释方法处理与给定 URI 表达式匹配的 HTTP GET 请求</li><li id="f3f6" class="lk ll in kc b kd lt kh lu kl lv kp lw kt lx kx lp lq lr ls bi translated">@Controller 注释类中的<strong class="kc io"><em class="lg">@ PUT mapping—</em></strong><em class="lg">@ PUT mapping</em>注释方法处理与给定 URI 表达式匹配的 HTTP PUT 请求</li><li id="dea0" class="lk ll in kc b kd lt kh lu kl lv kp lw kt lx kx lp lq lr ls bi translated"><strong class="kc io"><em class="lg">@ DELETE mapping—</em></strong><em class="lg">@ Controller</em>注释类中的<em class="lg"> @DeleteMapping </em>注释方法处理与给定 URI 表达式匹配的 HTTP 删除请求</li><li id="685d" class="lk ll in kc b kd lt kh lu kl lv kp lw kt lx kx lp lq lr ls bi translated"><strong class="kc io"><em class="lg">@ PATCH mapping—</em></strong><em class="lg">@ Controller</em>注释类中的<em class="lg"> @PatchMapping </em>注释方法处理与给定 URI 表达式匹配的 HTTP 补丁请求</li><li id="8d79" class="lk ll in kc b kd lt kh lu kl lv kp lw kt lx kx lp lq lr ls bi translated"><strong class="kc io"><em class="lg">@ exception handler</em></strong>—使用这个注释我们可以声明一个定制的错误处理方法。当请求处理程序方法抛出任何指定的异常时，Spring 调用这个方法。</li><li id="0b9b" class="lk ll in kc b kd lt kh lu kl lv kp lw kt lx kx lp lq lr ls bi translated"><strong class="kc io"><em class="lg">@ ResponseStatus</em></strong>—如果我们用这个注释来注释一个请求处理程序方法，使用这个注释我们可以指定期望的响应的 HTTP 状态。我们可以用 code 参数声明状态代码，或者它是一个别名，value 参数</li></ul><h2 id="0892" class="mf mg in bd mh mi mj dn mk ml mm dp mn kl mo mp mq kp mr ms mt kt mu mv mw mx bi translated"><strong class="ak"> 6。测试 API</strong></h2><p id="2b23" class="pw-post-body-paragraph ka kb in kc b kd my kf kg kh mz kj kk kl na kn ko kp nb kr ks kt nc kv kw kx ig bi translated">为了测试 API，我们可以使用<a class="ae jz" href="https://www.postman.com/" rel="noopener ugc nofollow" target="_blank"> Postman </a>。你可以从<a class="ae jz" href="https://www.getpostman.com/collections/dfc841f2e6a5663e6038" rel="noopener ugc nofollow" target="_blank">这里</a>获得邮差集锦。</p><figure class="kz la lb lc gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ny"><img src="../Images/e03fe61b0c9a87f42992d118035fcbd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z-Kb-Q2UE8u0z7xfJIpXSg.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">在邮递员中通过 id 测试获得旅游</figcaption></figure><p id="b95a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你可以在这里找到完整的代码<a class="ae jz" href="https://github.com/maneeshaindrachapa/Tour-California-SpringBoot-Sample-Application" rel="noopener ugc nofollow" target="_blank"/>。</p><div class="nz oa gp gr ob oc"><a href="https://github.com/maneeshaindrachapa/Tour-California-SpringBoot-Sample-Application" rel="noopener  ugc nofollow" target="_blank"><div class="od ab fo"><div class="oe ab of cl cj og"><h2 class="bd io gy z fp oh fr fs oi fu fw im bi translated">GitHub-maneeshaindrachapa/Tour-California-spring boot-Sample-Application:这是一个示例…</h2><div class="oj l"><h3 class="bd b gy z fp oh fr fs oi fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="ok l"><p class="bd b dl z fp oh fr fs oi fu fw dk translated">github.com</p></div></div><div class="ol l"><div class="om l on oo op ol oq jt oc"/></div></div></a></div><p id="795d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这就是了。这就是你如何使用 Spring Boot 开发微服务。这只是春天生态系统的一小部分。在另一篇博文中，让我们看看如何保护 API，以及接下来我们可以对 springs 做些什么。如果你喜欢这个，请给我买一杯<a class="ae jz" href="https://ko-fi.com/maneeshaindrachapa" rel="noopener ugc nofollow" target="_blank">☕️</a>咖啡</p></div><div class="ab cl ly lz hr ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ig ih ii ij ik"><h2 id="e77d" class="mf mg in bd mh mi mj dn mk ml mm dp mn kl mo mp mq kp mr ms mt kt mu mv mw mx bi translated">参考</h2><div class="nz oa gp gr ob oc"><a href="https://docs.spring.io/spring-data/commons/docs/current/api/org/springframework/data/repository/CrudRepository.html" rel="noopener  ugc nofollow" target="_blank"><div class="od ab fo"><div class="oe ab of cl cj og"><h2 class="bd io gy z fp oh fr fs oi fu fw im bi translated">CrudRepository (Spring 数据核心 2.6.2 API)</h2><div class="oj l"><h3 class="bd b gy z fp oh fr fs oi fu fw dk translated">针对特定类型的存储库的通用 CRUD 操作的接口。</h3></div><div class="ok l"><p class="bd b dl z fp oh fr fs oi fu fw dk translated">docs.spring.io</p></div></div></div></a></div><div class="nz oa gp gr ob oc"><a href="https://docs.spring.io/spring-data/jpa/docs/1.5.0.RELEASE/reference/html/jpa.repositories.html" rel="noopener  ugc nofollow" target="_blank"><div class="od ab fo"><div class="oe ab of cl cj og"><h2 class="bd io gy z fp oh fr fs oi fu fw im bi translated">2.JPA 存储库</h2><div class="oj l"><h3 class="bd b gy z fp oh fr fs oi fu fw dk translated">Spring Data 的 JPA 模块包含一个自定义名称空间，允许定义存储库 beans。它还包含…</h3></div><div class="ok l"><p class="bd b dl z fp oh fr fs oi fu fw dk translated">docs.spring.io</p></div></div></div></a></div><div class="nz oa gp gr ob oc"><a href="https://spring.io/quickstart" rel="noopener  ugc nofollow" target="_blank"><div class="od ab fo"><div class="oe ab of cl cj og"><h2 class="bd io gy z fp oh fr fs oi fu fw im bi translated">Spring 快速入门指南</h2><div class="oj l"><h3 class="bd b gy z fp oh fr fs oi fu fw dk translated">使用 start.spring.io 创建一个“web”项目。在“依赖项”对话框中，搜索并添加“web”依赖项作为…</h3></div><div class="ok l"><p class="bd b dl z fp oh fr fs oi fu fw dk translated">spring.io</p></div></div><div class="ol l"><div class="or l on oo op ol oq jt oc"/></div></div></a></div><div class="nz oa gp gr ob oc"><a href="https://solace.com/blog/microservices-advantages-and-disadvantages/" rel="noopener  ugc nofollow" target="_blank"><div class="od ab fo"><div class="oe ab of cl cj og"><h2 class="bd io gy z fp oh fr fs oi fu fw im bi translated">微服务的优点和缺点:你需要知道的一切</h2><div class="oj l"><h3 class="bd b gy z fp oh fr fs oi fu fw dk translated">对于那些研究微服务以及他们如何帮助他们的组织的人来说，并不缺少很好的资源…</h3></div><div class="ok l"><p class="bd b dl z fp oh fr fs oi fu fw dk translated">solace.com</p></div></div><div class="ol l"><div class="os l on oo op ol oq jt oc"/></div></div></a></div><p id="6f4e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><a class="ae jz" href="https://skelia.com/articles/5-major-benefits-microservice-architecture/" rel="noopener ugc nofollow" target="_blank">https://skelia . com/articles/5-major-benefits-microservice-architecture/</a></p><p id="b79f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">https://www.baeldung.com/spring-bean-annotations<a class="ae jz" href="https://www.baeldung.com/spring-bean-annotations" rel="noopener ugc nofollow" target="_blank"/></p><p id="6af7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">【https://www.baeldung.com/spring-boot-h2-database T4】</p></div></div>    
</body>
</html>