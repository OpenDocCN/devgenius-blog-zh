<html>
<head>
<title>PHP: Using “when” and “unless” in your own classes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">PHP:在自己的类中使用“when”和“unless”</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/php-using-when-and-unless-in-your-own-classes-97035c81a0da?source=collection_archive---------1-----------------------#2020-06-22">https://blog.devgenius.io/php-using-when-and-unless-in-your-own-classes-97035c81a0da?source=collection_archive---------1-----------------------#2020-06-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e8fb" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">再见，街区里有新来的孩子。</h2></div><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/b93c5039e1b31c5f1fb62d605dafbcfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*TCTGyOmJqP7yJ7Y8"/></div></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk translated">由<a class="ae kz" href="https://unsplash.com/@serjosoza?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> sergio souza </a>在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="6205" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">有时，对象周围的逻辑取决于一个条件。比方说，如果一个变量是<code class="fe kf kg kh ki b">true</code>，我们需要改变它的状态，否则不做任何事情<code class="fe kf kg kh ki b">false</code>。</p><pre class="kk kl km kn gt lw ki lx ly aw lz bi"><span id="e565" class="ma mb iq ki b gy mc md l me mf">$transport-&gt;setPackage($package);</span><span id="9691" class="ma mb iq ki b gy mg md l me mf">if ($express) {<br/>    $transport-&gt;setExpressDelivery();<br/>}</span><span id="429b" class="ma mb iq ki b gy mg md l me mf">$transport-&gt;send();</span></pre><p id="ff24" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">通过在对象实例上使用<code class="fe kf kg kh ki b">when()</code>和<code class="fe kf kg kh ki b">unless()</code>方法帮助器，有一种<em class="mh">简洁的</em>方式来压缩这些代码行。行为看起来会是这样的:</p><pre class="kk kl km kn gt lw ki lx ly aw lz bi"><span id="9962" class="ma mb iq ki b gy mc md l me mf">$transport-&gt;setPackage($package)<br/>    -&gt;when($express, [$transport, 'setExpressDelivery'])<br/>    -&gt;send();</span></pre><p id="6aac" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">并且它应该允许使用<code class="fe kf kg kh ki b">Closure</code>的更复杂的逻辑:</p><pre class="kk kl km kn gt lw ki lx ly aw lz bi"><span id="8b88" class="ma mb iq ki b gy mc md l me mf">$transport-&gt;setPackage($package)<br/>    -&gt;unless($isSmallPackage, function ($transport) {<br/>        $transport-&gt;setNormalDelivery();<br/>        $transport-&gt;setBigPackageHandling();<br/>    })<br/>    -&gt;send();</span></pre><p id="b4c4" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">对于一些人来说，用<code class="fe kf kg kh ki b">if</code>打破流程可能是标准的，也更容易理解，但是我个人喜欢可理解的、表达流畅的方法，这样其他开发人员就可以阅读并理解它。</p><h1 id="38df" class="mi mb iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">何时以及除非</h1><p id="f0f6" class="pw-post-body-paragraph la lb iq lc b ld mz jr lf lg na ju li lj nb ll lm ln nc lp lq lr nd lt lu lv ij bi translated">为了做到这一点，我们可以创建一个简单的特征，这样我们就可以在任何我们想要的东西上使用助手。这些方法将接受条件，如果它的计算结果为<code class="fe kf kg kh ki b">true</code>，则调用一个<code class="fe kf kg kh ki b">callable</code>。对于<code class="fe kf kg kh ki b">unless</code>，我们可以只调用<code class="fe kf kg kh ki b">when()</code>，但是条件会翻转:</p><pre class="kk kl km kn gt lw ki lx ly aw lz bi"><span id="72bc" class="ma mb iq ki b gy mc md l me mf">&lt;?php</span><span id="3b9e" class="ma mb iq ki b gy mg md l me mf">trait Conditionable<br/>{<br/>    public function when($condition, $callable)<br/>    {<br/>        if ($condition) {<br/>            $callable($this, $condition);<br/>        }</span><span id="3cf4" class="ma mb iq ki b gy mg md l me mf">        return $this;<br/>    }</span><span id="c7b4" class="ma mb iq ki b gy mg md l me mf">    public function unless($condition, $callable)<br/>    {<br/>       return $this-&gt;when(!$condition, $callable);<br/>    }<br/>}</span></pre><p id="af98" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">而瓦拉，我们完全可以做到以上这样的事情。由于它接收了一个<code class="fe kf kg kh ki b">callable</code>，我们甚至可以从其他地方调用公共静态方法，因为我们可以这样做。</p><pre class="kk kl km kn gt lw ki lx ly aw lz bi"><span id="a74d" class="ma mb iq ki b gy mc md l me mf">$transport-&gt;when($express, [Courier::class, 'setExpress'])</span></pre><p id="54cb" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">当然这是<em class="mh">的延伸</em>，但是这允许有条件地调用你在代码中使用的实例的任何方法，而不是给你的对象中的每个方法添加一个条件。</p><p id="70bb" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">例如，假设一个类有许多可条件化的方法。</p><pre class="kk kl km kn gt lw ki lx ly aw lz bi"><span id="a8a5" class="ma mb iq ki b gy mc md l me mf">class Foo<br/>{<br/>    public function whenFooDoBar() {}<br/>    public function whenQuzDoQux() {}<br/>    public function whenQuuzDoQuux() {}<br/>    public function whenCorgeDoGrault() {}<br/>}</span></pre><p id="ffbc" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">不用在每个方法中编程编码条件，您可以直接使用 trait，从方法本身中保存条件逻辑。</p><pre class="kk kl km kn gt lw ki lx ly aw lz bi"><span id="4588" class="ma mb iq ki b gy mc md l me mf">class Foo<br/>{<br/>    use Conditionable;</span><span id="67ee" class="ma mb iq ki b gy mg md l me mf">    public function doBar() {}<br/>    public function doQux() {}<br/>    public function doQuux() {}<br/>    public function doGrault() {}<br/>}</span></pre></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><p id="db09" class="pw-post-body-paragraph la lb iq lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">你可以在我的<a class="ae kz" href="https://github.com/DarkGhostHunter/Laratraits" rel="noopener ugc nofollow" target="_blank">拉拉训练包</a>里找到这个特性和其他帮助者。如果你发现在你的项目中有用的东西，给它一个机会。</p><div class="nl nm gp gr nn no"><a href="https://github.com/DarkGhostHunter/Laratraits" rel="noopener  ugc nofollow" target="_blank"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd ir gy z fp nt fr fs nu fu fw ip bi translated">黑暗幽灵之旅</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">Laratraits 是一个 Laravel 包，包含有用的特征和一些类，可以和你的模型、控制器一起使用</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">github.com</p></div></div><div class="nx l"><div class="ny l nz oa ob nx oc kt no"/></div></div></a></div></div></div>    
</body>
</html>