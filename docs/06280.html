<html>
<head>
<title>Build a Go KV Cache from Scratch in 20 minutes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在 20 分钟内从头构建一个 Go KV 缓存</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/build-a-go-kv-cache-from-scratch-in-20-minutes-a13616a4929f?source=collection_archive---------8-----------------------#2021-12-27">https://blog.devgenius.io/build-a-go-kv-cache-from-scratch-in-20-minutes-a13616a4929f?source=collection_archive---------8-----------------------#2021-12-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="c500" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">缓存似乎是几乎每一个程序或产品的必需品，我们可以在每个角落看到它，就像在 web、数据库、应用程序中，甚至在云中。它之所以有意义，是因为它带来了效率。这就像当你和那些燃烧卡路里的问题纠缠在一起时，把你最喜欢的零食放在桌子上快速拿起。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/c848c13b4f41a0a83e9fdaaf81f2a50c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*SmRFD8qYAWiJzD2X"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated"><a class="ae lb" href="https://unsplash.com/photos/C1fMH2Vej8A" rel="noopener ugc nofollow" target="_blank">布鲁克·拉克</a></figcaption></figure><p id="4422" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们已经讨论了使用<code class="fe lc ld le lf b">sync.Pool</code>优化 kv 缓存的主题，并深入探讨了缓存设计。那么，今天是关于弄脏我们的手。在 20 分钟内，我们将从头开始实施一个可靠且可用的本地 kv 缓存。</p><h1 id="affb" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">千伏缓存的基本元素</h1><p id="0f41" class="pw-post-body-paragraph jn jo iq jp b jq me js jt ju mf jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated">您是否列出了在实现键值缓存时应该考虑的因素？如果没有，请记下。</p><ul class=""><li id="0d76" class="mj mk iq jp b jq jr ju jv jy ml kc mm kg mn kk mo mp mq mr bi translated"><strong class="jp ir">储存</strong>。通常，最常用的数据结构是<code class="fe lc ld le lf b">map[string]Element{}</code>，其中字符串是关键，而元素包含<code class="fe lc ld le lf b">value</code>信息。</li><li id="6c9e" class="mj mk iq jp b jq ms ju mt jy mu kc mv kg mw kk mo mp mq mr bi translated"><strong class="jp ir">元素</strong>。最简单的元素至少应该包含值和过期时间。值类型通常为<code class="fe lc ld le lf b">interface{}</code>，可根据场景替换为<code class="fe lc ld le lf b">string</code>、<code class="fe lc ld le lf b">int</code>或其他特定类型，以加快速度。</li><li id="86c8" class="mj mk iq jp b jq ms ju mt jy mu kc mv kg mw kk mo mp mq mr bi translated"><strong class="jp ir">并发</strong>。除非是线程特定的映射，否则缓存必须考虑并发访问。像其他高级语言一样，Go 也提供了一个线程安全的映射(<code class="fe lc ld le lf b">sync.map</code>)。当然，将<code class="fe lc ld le lf b">map</code>和<code class="fe lc ld le lf b">sync.RWMutex</code>结合起来可以实现同样的功能，提供更多的灵活性，有助于更好地理解 Go。</li><li id="b538" class="mj mk iq jp b jq ms ju mt jy mu kc mv kg mw kk mo mp mq mr bi translated"><strong class="jp ir">容量</strong>。如果您想在 Kubernetes Pod 中运行缓存，请提前设置缓存大小。否则，它可能会消耗太多内存，并由于内存限制而导致整个 pod 被逐出。</li><li id="bcfb" class="mj mk iq jp b jq ms ju mt jy mu kc mv kg mw kk mo mp mq mr bi translated"><strong class="jp ir">删除已到期的</strong>。及时释放过期密钥可以提高缓存利用率、节省开销并提高性能。</li><li id="e7c2" class="mj mk iq jp b jq ms ju mt jy mu kc mv kg mw kk mo mp mq mr bi translated"><strong class="jp ir"> GC 调谐</strong>。它与 Go 相关，并减少了 GC 对缓存的影响。<code class="fe lc ld le lf b">sync.Pool</code>可用于进一步优化。</li><li id="0bf2" class="mj mk iq jp b jq ms ju mt jy mu kc mv kg mw kk mo mp mq mr bi translated"><strong class="jp ir"> API 设计</strong>。缓存具有<code class="fe lc ld le lf b">Put</code>、<code class="fe lc ld le lf b">Get</code>、<code class="fe lc ld le lf b">Remove</code>、<code class="fe lc ld le lf b">Flush</code>4 个基本功能，并对其他方法开放以获得更好的支持。</li></ul><h1 id="7667" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">缓存实现</h1><p id="3f1f" class="pw-post-body-paragraph jn jo iq jp b jq me js jt ju mf jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated">考虑到这些因素，我们现在将设计我们的缓存。</p><p id="0219" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们暂停一下，解读一下这些步骤。首先简单两步。</p><ul class=""><li id="540b" class="mj mk iq jp b jq jr ju jv jy ml kc mm kg mn kk mo mp mq mr bi translated">定义所有的类型和函数。</li></ul><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mx my l"/></div></figure><ul class=""><li id="94b2" class="mj mk iq jp b jq jr ju jv jy ml kc mm kg mn kk mo mp mq mr bi translated">定义默认参数，并在<code class="fe lc ld le lf b">New</code>功能中使用它们。</li></ul><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="4b4d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后是<code class="fe lc ld le lf b">put</code>方法。在为 map 设置键和值之前，还有一些额外的工作要做。</p><ul class=""><li id="b424" class="mj mk iq jp b jq jr ju jv jy ml kc mm kg mn kk mo mp mq mr bi translated">获取并设置密钥的过期时间。</li><li id="1bfa" class="mj mk iq jp b jq ms ju mt jy mu kc mv kg mw kk mo mp mq mr bi translated">获取并设置密钥的上次访问时间。</li></ul><p id="343b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在缓存已满，但无法删除过期密钥来为新密钥腾出空间的情况下，我们需要引入一些额外的收回策略。</p><p id="05f4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae lb" href="https://en.wikipedia.org/wiki/Cache_replacement_policies#Least_recently_used_(LRU)" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> LRU </strong> </a>，最近最少用户，是我们在这种情况下应用的:最近没有被访问的键将被消除。但是，需要注意的是，对史料并不友好。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mz"><img src="../Images/09490851d707d186c03b8d182184198b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-U5RbQAbwO0priFKuOGS0g.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">LRU，来自<a class="ae lb" href="https://en.wikipedia.org/wiki/Cache_replacement_policies#/media/File:Lruexample.png" rel="noopener ugc nofollow" target="_blank">维基</a></figcaption></figure><p id="8109" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">还有一些其他驱逐策略，例如，</p><ul class=""><li id="8f1b" class="mj mk iq jp b jq jr ju jv jy ml kc mm kg mn kk mo mp mq mr bi translated"><strong class="jp ir"> LFU </strong>，最不常用，剔除使用频率低的按键。潜在的问题是，如果这些键在短时间内被频繁访问，它们将在缓存中保留很长时间，尽管将来不会被访问。</li><li id="07af" class="mj mk iq jp b jq ms ju mt jy mu kc mv kg mw kk mo mp mq mr bi translated"><strong class="jp ir"> FIFO </strong>，先进先出，最新的留下。它的缺点和 LFU 的一样。</li><li id="cce2" class="mj mk iq jp b jq ms ju mt jy mu kc mv kg mw kk mo mp mq mr bi translated"><a class="ae lb" href="https://en.wikipedia.org/wiki/Adaptive_replacement_cache#:~:text=From%20Wikipedia%2C%20the%20free%20encyclopedia%20Adaptive%20Replacement%20Cache,pages%20plus%20a%20recent%20eviction%20history%20for%20both." rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">圆弧</strong> </a>，自适应替换缓存。作为 LRU 的高级版本，它通过集成 LFU 和 LRU、4 个队列和消耗更多内存来实现更高性能的缓存。</li></ul><p id="4619" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，还有其他算法，如双队列，MRU 等。</p><p id="74ad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，让我们看看<code class="fe lc ld le lf b">sync.Pool</code>。只有当存储的对象将被立即使用时，才需要这种选择加入功能。否则，在<code class="fe lc ld le lf b">Get</code>中运行之前，池中的对象将被频繁替换。但这是我们未来需要改进缓存的一个特性。</p><p id="d56b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lc ld le lf b">Put</code>循序渐进，功法尽在不言中。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="1934" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后你会发现<code class="fe lc ld le lf b">Get</code>函数已经在你的口袋里了:只需从<code class="fe lc ld le lf b">pool</code>和<code class="fe lc ld le lf b">map</code>中获取结果，并更新上次访问时间和到期时间。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="a4e4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来要做的是构建一个自动清理器，启动一个 goroutine 来定期清理过期时间小于当前时间的密钥。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="9587" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">同时，在前面的<code class="fe lc ld le lf b">New</code>方法中增加下面两行。</p><pre class="km kn ko kp gt na lf nb nc aw nd bi"><span id="6152" class="ne lh iq lf b gy nf ng l nh ni">go c.cleaner.Run(c)<br/>runtime.SetFinalizer(c, stopCleaner)</span></pre><p id="5841" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">到目前为止，缓存功能基本完成，是时候进行测试了👉<a class="ae lb" href="https://github.com/slaise/go_localcache/blob/f95c94f760784826693c20bc7450b9af5033f679/cache_test.go#L5" rel="noopener ugc nofollow" target="_blank">单元测试</a>。</p><h1 id="cfc0" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">性能比较</h1><p id="111d" class="pw-post-body-paragraph jn jo iq jp b jq me js jt ju mf jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated">迫不及待地将我们构建的缓存与 Github 的完美缓存进行性能比较，我以<a class="ae lb" href="https://github.com/patrickmn/go-cache" rel="noopener ugc nofollow" target="_blank"> go-cache </a>和<a class="ae lb" href="https://github.com/hashicorp/golang-lru" rel="noopener ugc nofollow" target="_blank"> hashicorp-lrucache </a>为例，编写了一个<a class="ae lb" href="https://github.com/patrickmn/go-cache" rel="noopener ugc nofollow" target="_blank">基准测试</a>测试，比较访问效率。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="55ff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">结果符合我的预期。我们的缓存比那些成熟的开源缓存要慢。但是当它只花费我们 20 分钟的时候，我们还能期待什么。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nj"><img src="../Images/2dd3876b070844e3e86dc8aaf3df26a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ppYcb5MLuclf-vZL"/></div></div></figure><p id="12aa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个结果给了我一个提示:T1 这么快肯定有原因。好了，我下一篇文章的主题找到了！</p><h1 id="814f" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">改进的方法</h1><p id="8744" class="pw-post-body-paragraph jn jo iq jp b jq me js jt ju mf jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated">我们的缓存比较慢，但是我们可以做些事情来加快它的速度。那怎么做？</p><p id="f50b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最重要的因素是并发和缓存大小，这两个因素相互影响:并发越大，元素越多，内存占用越大，缓存越慢。因此，降低并发性是第一要务。</p><p id="8ebe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里我们需要一个着色方法，将一个缓存映射分成多个，以降低并发的可能性，并缩小每个缓存的大小。毫无疑问，<code class="fe lc ld le lf b">hash</code>最常用于着色，因为</p><ul class=""><li id="f321" class="mj mk iq jp b jq jr ju jv jy ml kc mm kg mn kk mo mp mq mr bi translated">哈希结果离散率高，也就是随机性高。</li><li id="a983" class="mj mk iq jp b jq ms ju mt jy mu kc mv kg mw kk mo mp mq mr bi translated">哈希可以避免产生过多的内存分配，减轻垃圾收集带来的压力。</li><li id="9158" class="mj mk iq jp b jq ms ju mt jy mu kc mv kg mw kk mo mp mq mr bi translated">哈希算法超高效。</li></ul><p id="45d4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">很容易得出结论，哈希方法的速度决定了着色算法的效率，因为键是通过 hash(key)分配给不同的缓存的。</p><p id="5ba8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么问题就在于选择哪种算法。<a class="ae lb" href="https://en.wikipedia.org/wiki/MD5" rel="noopener ugc nofollow" target="_blank"> MD5 </a>和<a class="ae lb" href="https://www.simplilearn.com/tutorials/cyber-security-tutorial/sha-256-algorithm" rel="noopener ugc nofollow" target="_blank"> SHA-256 </a>是最常见的哈希算法，<a class="ae lb" href="https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function" rel="noopener ugc nofollow" target="_blank"> FNV </a>和<a class="ae lb" href="https://doc.riot-os.org/group__sys__hashes__djb2.html" rel="noopener ugc nofollow" target="_blank"> DJB2 </a>各有千秋。如果你正纠结于这些选项，那么就做一个基准比较。</p><p id="0b5a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，添加更多的方法，如直接访问<code class="fe lc ld le lf b">string</code>和直接存储<code class="fe lc ld le lf b">int</code>，或者优化<code class="fe lc ld le lf b">sync.Pool</code>的使用，也是改善我们缓存的方法。</p><h1 id="a393" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">结束了</h1><p id="03ff" class="pw-post-body-paragraph jn jo iq jp b jq me js jt ju mf jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated">我们有各种各样的开源缓存，这让我们不用自己写，而且效率更高。但是当你喝完一杯咖啡后，你会有什么感觉呢？实践让我们变得更好。我们的手越脏，我们就是越好的开发者。在优化 kv 缓存的意愿的驱使下，我开始了哈希和阴影研究。</p><p id="aa2c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">参见<a class="ae lb" href="https://github.com/slaise/go_localcache" rel="noopener ugc nofollow" target="_blank">源代码</a>这里。</p><p id="7624" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">感谢阅读！</p></div></div>    
</body>
</html>