<html>
<head>
<title>Is Typescript lying to you?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Typescript在骗你吗？</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/is-typescript-lying-to-you-a2761f6bef4?source=collection_archive---------3-----------------------#2020-10-03">https://blog.devgenius.io/is-typescript-lying-to-you-a2761f6bef4?source=collection_archive---------3-----------------------#2020-10-03</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="d2d4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你有没有想过为什么使用Typescript有时会让你如此头疼？我指的不是偶尔需要付出巨大努力来满足TS编译器的事实。不，我的意思是偶尔完美的工作代码在没有<em class="ki">的情况下停止工作，这是一个容易识别的</em>原因。你的API代码是<em class="ki">臭名昭著的嫌疑犯</em>之一，不是吗？</p><p id="7b13" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我经历过很多次——我的API一改变，我就开始注意到奇怪的错误或不寻常的应用程序行为。归根结底，不能保证TS类型在运行时与JS类型相同。到目前为止，Typescript还没有以经典意义上的“类型”为特色。</p><p id="fc8c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Typescript包含<strong class="jm io">类型注释</strong>，而不是我们习惯于传统静态类型语言的真实类型。</p><p id="8455" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">机制“<strong class="jm io">不是类型，而是类型注释</strong>”代表了Typescript和Java或C#的本质区别。由于TS类型通常在编译后被剥离，所以没有对TS类型的运行时支持。</p><p id="b052" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">事实上，这就是TS失去其美丽和实用性的地方。</p><p id="f75b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">例如，我喜欢C#中的反射。我认为这是一个新的魔术水平的便捷工具。没有这样的基础设施支持，动态语言就不能提供可靠的运行时串行化器。缺少了这部分功能，您的应用程序就包含了一个重要的<strong class="jm io">黑洞</strong>，在那里您的应用程序行为可能会被破坏。</p><p id="0ccb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一个经典的例子是API调用；您有这样的代码:</p><pre class="kj kk kl km gt kn ko kp kq aw kr bi"><span id="a095" class="ks kt in ko b gy ku kv l kw kx">interface User{<br/>   Age: number;<br/>}</span></pre><p id="11b8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对于服务器上有缺陷的数据，您可能很快就会得到一个“形状”像用户的对象，但是Age属性可能被设置为字符串、未定义的对象，甚至是一个复杂的对象。</p><p id="48bf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> C#序列化器防止这些类型的错误，但是ts(单独使用JS运行时)不能做到这一点。</strong>这是我对TS最大的担忧。由于来自外界的坏数据，它经常对你撒谎。在静态编程中，运行时的行为就像你的<em class="ki">礼貌的朋友</em>，它会阻止坏数据感染应用程序的其余部分。在JS中，运行时就像一个不喜欢你的敌人，不断地试图破坏你的代码、努力，甚至你的个人生活:)。</p><h2 id="34ca" class="ks kt in bd ky kz la dn lb lc ld dp le jv lf lg lh jz li lj lk kd ll lm ln lo bi translated"><strong class="ak">帮助JS运行时</strong></h2><p id="1ccf" class="pw-post-body-paragraph jk jl in jm b jn lp jp jq jr lq jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh ig bi translated">为了支持Typescript，您必须站在运行时的角度考虑问题。这通常意味着创建或找到工具来支持代码中的“类型”。</p><p id="d133" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">从你的APIA生成类型脚本类是一个很好的例子。理想的解决方案似乎是有一个OpenAPI格式的API。然后，您可以使用这些软件包:</p><p id="9aa7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae lu" href="https://openapi-generator.tech/" rel="noopener ugc nofollow" target="_blank">https://open API-generator . tech</a></p><p id="3a2e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">或者</p><p id="5ad9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">【https://github.com/manifoldco/swagger-to-ts T2】号</p><p id="d03d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在建立了这个工具之后，您就能够定期同步您的API和Typescript生成的类。我相信找到一种方法将你的API和你的Typescript类更紧密地联系起来，将会在未来给你<em class="ki">带来巨大的好处</em>。</p><p id="0dbb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> 2)集成测试</strong></p><p id="d1d9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是另一个提示。创建集成测试来检查您的API最近是否没有改变。简单地<strong class="jm io">做任何静态类型运行时免费为你做的事情</strong>。</p><p id="6387" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">只需使用您最喜欢的测试运行程序，编写执行API调用的测试，并做出断言，以确定API是否没有被修改。</p><p id="d2ec" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">例如，在JEST中你可以使用:</p><pre class="kj kk kl km gt kn ko kp kq aw kr bi"><span id="e9bc" class="ks kt in ko b gy ku kv l kw kx">const entity = await fetch(‘yourApi/getUser’)<br/>const userModel = {<br/>  Age:expect.nullOrAny(number),<br/>  Name:expect.nullOrAny(string)<br/>}<br/>expect(entity).toEqual(expect.objectContaining(userModel));</span></pre><p id="543e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">3)过分严格</p><p id="160e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一种不同且细致的方法建议将API类/接口中的所有属性注释为可选。然后，您必须在代码中的任何地方检查它们的值。这似乎是一个非常费力的过程，你写了许多可能不必要的“如果”然而，考虑到罕见的边缘情况，我想这可能是有帮助的——但这仍然不是我喜欢的方式。而且，它没有解决<strong class="jm io">类型不匹配</strong>。</p><p id="c7b8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">4)拥有带有实验性元数据API的串行化器</p><p id="237a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当我说没有办法在运行时拥有TS类型时，我并没有说得很准确。我进行了一个小实验，用我的TS类和Typescript中的实验性反射创建了我自己的“序列化程序”。然而，这只是一个概念，还没有在我的任何项目中使用过。</p><p id="e909" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">事情是这样的:</p><pre class="kj kk kl km gt kn ko kp kq aw kr bi"><span id="ac9a" class="ks kt in ko b gy ku kv l kw kx">import ‘reflect-metadata’<br/>function prop(target : any, key : string) {<br/>   var t = Reflect.getMetadata(“design:type”, target, key);<br/>   console.log(`${key} type: ${t.name}`);<br/>}</span><span id="5465" class="ks kt in ko b gy lv kv l kw kx">export class User {<br/>  @prop age: number;<br/>  @prop name: string;<br/>}</span><span id="1c8c" class="ks kt in ko b gy lv kv l kw kx">let user = new User();</span><span id="6204" class="ks kt in ko b gy lv kv l kw kx">console.log(Reflect.getMetadata(‘design:type’, user, “age”).name == “Number” ); //returns true</span><span id="522d" class="ks kt in ko b gy lv kv l kw kx">console.log(Reflect.getMetadata(‘design:type’, user, “age”).name == “String” ); //returns true</span></pre><p id="fe8f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用该代码，您可以检查对象的字段是否具有正确的类型。这段代码仅仅展示了一个片段来说明这个概念，我将在以后的文章中详细阐述我自己的序列化器。</p><p id="75d7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我还怀疑TS中的反射过去和现在都相当有限，而且不知何故与装饰者奇怪地结合在一起。另一个困扰我的问题是，它目前只是一个Typescript特性。因此，举例来说，如果你像我一样使用Babel编译器，它没有内置支持。<br/> <em class="ki">不过，还有一个</em> <a class="ae lu" href="https://github.com/leonardfactory/babel-plugin-transform-typescript-metadata#readme" rel="noopener ugc nofollow" target="_blank"> <em class="ki">的变通办法</em> </a> <em class="ki">，当然是:)。</em></p><p id="909a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在我看来，JS运行时静态类型化的时机还没有到来。然而，我坚信这将是TS/JS世界中的另一件大事。</p><p id="57d7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">概括一下<em class="ki">，</em>是的，Typescript倾向于对你撒谎，但它不是故意这样做的。显然，我觉得这是网络发展不可避免的事实。为了获得更多的支持，您必须稍微模拟一下运行时。构建一个小的基础设施来增强您在javascript中的<em class="ki">静态类型</em> <em class="ki">努力</em>可能总是有用的，值得一试。</p></div></div>    
</body>
</html>