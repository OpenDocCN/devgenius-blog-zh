<html>
<head>
<title>Dynamic Slack Notifications</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">动态时差通知</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/dynamic-slack-notifications-5fb3c1716689?source=collection_archive---------8-----------------------#2021-12-16">https://blog.devgenius.io/dynamic-slack-notifications-5fb3c1716689?source=collection_archive---------8-----------------------#2021-12-16</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div class="gh gi jk"><img src="../Images/c5f5eba916cc8741859413e79ebd9c73.png" data-original-src="https://miro.medium.com/v2/resize:fit:702/format:webp/1*x61HfV4-KP0OsdlfsgtBFA.png"/></div></figure><p id="518b" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">声明:这只是一个简短的帖子，有些人可能会觉得有用，其他人可能会称之为噱头。是什么东西:)</p><h1 id="c0d7" class="kp kq in bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated"><strong class="ak">【问题】</strong></h1><p id="2bc8" class="pw-post-body-paragraph jr js in jt b ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk lr km kn ko ig bi translated">我与之交互的许多自动化或我创建的工具都以某种形式集成到Slack中。无论工具是由Slack触发还是自动化向Slack发送通知，Slack都以某种形式存在。我见过的最常见的模式是，当任务开始时发送通知，当任务以“通过/失败”等状态结束时发送通知。这些通知通常被发送到一个专用通道，在大多数情况下已经足够了，但是如果我们想要更细粒度的通知呢？例如，一个部署过程由多个持续时间不同的任务组成。在这种情况下，我们可以在每个任务开始和结束时发送一个通知。这可能会很快失去控制，感觉就像我们在向频道发送垃圾邮件。单个部署流程可能会将多个通知发送到主通道或线程中。松弛溢出。</p><h1 id="4223" class="kp kq in bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated"><strong class="ak">《解决方案》</strong></h1><p id="00e3" class="pw-post-body-paragraph jr js in jt b ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk lr km kn ko ig bi translated">如果我们可以只发送一条消息，然后在任务完成时更新这条消息，会怎么样？我们可以，而且使用Slack API实际上非常简单。下面的例子可以从任何地方调用；从CI/CD管道，从Lambda，从容器化工具…</p><p id="11c9" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">重要的部分是初始消息模板和初始消息的时间戳。我们的模板包含每个任务状态的占位符。一个部署过程可能有5个任务；任务[1–5]。我们的模板将为每个任务准备一个占位符。使用Slack API，我们发送初始消息并存储时间戳。现在，当每个任务开始、停止、暂停、失败时，我们可以用新的状态更新初始消息。</p><p id="82b6" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">包含3项任务的流程的初始消息模板示例:</p><p id="1dcc" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">模板= " " "</p><p id="437e" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">将服务$service $version部署到暂存:$ instance *<br/><br/>*步骤:* <br/> <br/> 1 .*构建可部署的服务* $(第1类。$instance.status) <br/> 2。*健全性检查可部署* $(第2类。$instance.status) <br/> 3。*部署服务* $(第3类。$instance.status) <br/>" " "</p><p id="33a9" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">当我们发送这个初始模板时，每个$instance.status文件的内容可以包含一个表情符号或一个字符串，如“尚未开始”。重要的部分是我们在发送这个模板后存储时间戳(ts)值。</p><p id="c7d1" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io">curl-s-H " Content-type:application/JSON "--data ' { " channel ":" $ channel " '，" blocks":[{"type":"section "，" text":{"type":"mrkdwn "，" text ":" ' " $ template " ' " } }]'-H " Authorization:Bearer $ auth _ token "</strong><a class="ae ls" href="https://slack.com/api/chat.postMessage" rel="noopener ugc nofollow" target="_blank"><strong class="jt io">https://slack.com/api/chat.postMessage</strong></a>&gt;【instance . response . JSON</p><p id="4f14" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">' ts = $(cat $ instance . response . JSON | jq-r '。ts ')<br/>echo " *]写时间戳:$ts到。$instance.slack.ts文件"<br/> echo $ts &gt;。$instance.slack.ts </p><p id="1fa4" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">此时，我们已经向Slack发送了一条消息，通知用户已经启动了一个流程。随着自动化流程的运行以及每个任务的开始、停止、暂停和失败，我们会更新任务状态，更新有效负载变量，并使用时间戳值重新发送它:</p><p id="78b7" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io">curl-s-H " Content-type:application/JSON "--data ' { " ts ":" $ ts " '，" channel ":" $ channel " '，" blocks":[{"type":"section "，" text":{"type":"mrkdwn "，" text ":" " $ template " ' " } }]'-H " Authorization:Bearer $ auth _ token "</strong><a class="ae ls" href="https://slack.com/api/chat.update" rel="noopener ugc nofollow" target="_blank"><strong class="jt io">https://slack.com/api/chat.update</strong></a></p><p id="9b32" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">这给人一种单一动态时差消息的印象，该消息随着每项任务的完成而更新。这种方法的好处是，当一个任务失败时，用户现在可以确定任务失败的位置。这对于长期运行的流程来说也很棒，因为它显示了流程的实时进度。</p><h1 id="5253" class="kp kq in bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">摘要</h1><p id="aa0f" class="pw-post-body-paragraph jr js in jt b ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk lr km kn ko ig bi translated">就是这样。这可能是一个噱头，但我发现它很有用，我使用的工具的用户似乎也喜欢这种方法。如果你决定使用它并且需要一些帮助，就在Twitter上给我发消息:"<a class="lt lu ep" href="https://medium.com/u/619edccbd9b7?source=post_page-----5fb3c1716689--------------------------------" rel="noopener" target="_blank"> @ </a> tomwillfixit "。感谢阅读。</p></div></div>    
</body>
</html>