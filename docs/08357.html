<html>
<head>
<title>Learning More About Prototype Pollution</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解原型污染的更多信息</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/learning-more-about-prototype-pollution-8ba42638f22d?source=collection_archive---------3-----------------------#2022-06-08">https://blog.devgenius.io/learning-more-about-prototype-pollution-8ba42638f22d?source=collection_archive---------3-----------------------#2022-06-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/96c507105c916856dd6eef92ce367a3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fFvnsSaTogNLAVHg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">米卡·鲍梅斯特在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="4809" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated"><strong class="ak">简介</strong></h1><p id="4208" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">现在几乎所有的 web 应用程序都使用 JavaScript，无论是在前端还是后端，尤其是在 NodeJS 和 Express、VueJS 等框架开发之后。</p><p id="288b" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">从安全的角度来看，我们在导入可能导致远程代码执行或任何其他漏洞的恶意库、依赖项或有害函数时应该小心。讨论所有这些功能以及如何利用它们，这本身就可以写成一本书，网上也有很多资料。为了这篇博文，我们将讨论一个不太为人知的漏洞，它可以导致权限提升，绕过安全控制，在极端情况下，甚至可以远程执行代码。这种脆弱性被称为原型污染。</p><h1 id="92d1" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated"><strong class="ak">对象</strong></h1><p id="d636" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">JavaScript 是一种基于原型的面向对象编程(OOP)语言。所以 JavaScript 里的一切<strong class="ld ir">都是对象。</strong>但也有例外。以下<strong class="ld ir">六个</strong>的东西不算物体。它们是空、未定义、字符串、数字、布尔和符号。</p><p id="8445" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">也就是说，你定义的每个对象都有特定的属性和方法。有些是预定义的，有些是我们为用例创建的。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="3092" class="mn ke iq mj b gy mo mp l mq mr">function pet(petname, age, color) {</span><span id="7914" class="mn ke iq mj b gy ms mp l mq mr">this.age = age;</span><span id="909e" class="mn ke iq mj b gy ms mp l mq mr">this.petname = petname;</span><span id="c949" class="mn ke iq mj b gy ms mp l mq mr">this.color = color;</span><span id="41d5" class="mn ke iq mj b gy ms mp l mq mr">}</span><span id="4823" class="mn ke iq mj b gy ms mp l mq mr">var pet1 = new pet (“magic”, 3,” white”);</span></pre><p id="b079" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">我为对象 pet1 创建了 3 个属性。分别是<strong class="ld ir">年龄，宠物名，颜色</strong>。所以，我们可以说 pet1 是一个对象，这三个都是它的属性。</p><h1 id="3bf4" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated"><strong class="ak">原型</strong></h1><p id="e371" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">如果我输入我的对象的名字 pet1，后面跟一个点作为<strong class="ld ir"> pet1。</strong>在我的控制台(浏览器开发工具)中，会显示各种属性。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/b3450396d0672f7caa7392af9cc36768.png" data-original-src="https://miro.medium.com/v2/resize:fit:884/format:webp/1*-gu_HlVGLbf_zdW-gFzquw.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">原型</figcaption></figure><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="3f31" class="mn ke iq mj b gy mo mp l mq mr"><strong class="mj ir">For example</strong>,</span><span id="dc81" class="mn ke iq mj b gy ms mp l mq mr">__defineGetter__</span><span id="ccf3" class="mn ke iq mj b gy ms mp l mq mr">__defineSetter__</span><span id="f1d8" class="mn ke iq mj b gy ms mp l mq mr">__lookupGetter__</span><span id="16b8" class="mn ke iq mj b gy ms mp l mq mr">__lookupSetter__</span><span id="47b2" class="mn ke iq mj b gy ms mp l mq mr">__proto__</span></pre><p id="ca4a" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">这些是每个对象都有的内置 JavaScript 属性。</p><p id="c91a" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">这些内置属性被称为原型。这个原型本身就是一个物体，所以这个原型会有自己的原型，使得所谓的 <strong class="ld ir"> <em class="mu">原型链</em> </strong> <em class="mu">。当我们到达一个它自己的原型为 null 的原型时，这个链就结束了。— Mozilla</em></p><p id="1c81" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">如果在对象本身中找不到属性会怎么样？在对象的原型中查找属性。同样，如果在原型中找不到，那么在对象原型的原型中寻找。这种情况一直持续到找到属性或者返回未定义的属性。</p><p id="a8ce" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">要访问特定对象的结构，我们可以通过以下方式来完成:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="cfe5" class="mn ke iq mj b gy mo mp l mq mr">pet.__proto__.__proto__</span><span id="42e5" class="mn ke iq mj b gy ms mp l mq mr">pet1.__proto__.__proto__</span></pre><p id="3ca7" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">注意:原型属性可以被添加、修改甚至删除。比如以我们的宠物函数/类为例。如果我们希望添加一个返回“Hello kitty”的函数<strong class="ld ir"> tempFunc </strong>，可以这样实现:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="745d" class="mn ke iq mj b gy mo mp l mq mr">pet.prototype.tempFunc = function() { return “Hello kitty”}</span></pre><p id="6bb1" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">正如您所看到的，我们不需要像在其他 OOP 编程语言中那样再次声明 pet 函数。这就是事情开始变得可怕的地方。</p><p id="fe58" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">既然我们已经将 pet1 声明为 pet 类型的对象，那么通过继承，tempFunc 在默认情况下也将是 pet1 的函数/属性。</p><p id="b3bf" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated"><strong class="ld ir">调用 pet1.tempFunc 将返回“Hello kitty”</strong></p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/d64c9111a990071afd362ac5323d48a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FtPELhlBTQTq0UKlE04jXw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">被污染的物体</figcaption></figure><p id="4e49" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">我们也可以修改默认的内置函数。例如，让我们考虑一下<strong class="ld ir"> toString() </strong>函数。这用于转换提供给类型字符串的值。但是我们可以改变它的行为。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="f17b" class="mn ke iq mj b gy mo mp l mq mr">For example,</span><span id="9de9" class="mn ke iq mj b gy ms mp l mq mr">pet.prototype.toString = function() { return “I’ve changed the default function”}```</span><span id="7347" class="mn ke iq mj b gy ms mp l mq mr">Now if you call, pet1.toString(), it would return <br/><strong class="mj ir">I’ve changed the default function</strong></span></pre><h1 id="9bfa" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated"><strong class="ak">原型污染</strong></h1><p id="1b39" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">您声明或实例化的每个对象都属于 Object 类型。这也意味着如果你污染了对象类型(本身),默认情况下每个声明的对象都会被污染。简而言之，这就是原型污染。</p><p id="0592" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">我们看到了如何改变一个特定的函数，如果我们改变了原始的函数/类(pet ),那么该类型的任何实例化的对象都将被修改(pet1)。</p><p id="a2ca" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">但是如果我们改变对象类型本身，默认情况下每个对象都会改变。</p><p id="e15b" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">举个例子，</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="21a3" class="mn ke iq mj b gy mo mp l mq mr">Object.prototype.sayHello= function(){ return “hello!”} </span></pre><p id="6348" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">如果我们调用，<strong class="ld ir"> pet1.sayHello() </strong>，尽管我们没有在 pet 或 pet1 上定义任何这类函数，我们仍然会得到一个输出"<strong class="ld ir"> hello </strong>！"。<strong class="ld ir">这是因为我们修改了原始对象类型。</strong></p><p id="88bc" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated"><em class="mu">让我们借助一个例子来理解恶意。这个例子摘自</em><a class="ae kc" href="https://snyk.io/" rel="noopener ugc nofollow" target="_blank"><em class="mu">Synk</em></a><em class="mu">。</em></p><p id="d801" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">考虑一个域 api.startup.io。它们是:</p><ol class=""><li id="cc53" class="mw mx iq ld b le lz li ma lm my lq mz lu na ly nb nc nd ne bi translated">api.startup.io/users/:UserID</li><li id="3329" class="mw mx iq ld b le nf li ng lm nh lq ni lu nj ly nb nc nd ne bi translated">api.startup.io/users/:UserID/role</li></ol><p id="d7de" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">UserID 是用户在网站上注册时提供给每个用户的唯一用户 ID。第一个端点接受一个 POST 请求，该请求包含一个名为 about 的字段。在该字段中，用户可以输入最能描述他的任何内容。</p><p id="d0dc" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">第二个端点是/role。在这里，用户可以打印他的用户角色。默认情况下，提供的用户角色是来宾角色。</p><p id="a5c6" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">让我们在 curl 请求的帮助下看看这些是如何工作的。用户是 1337，它接受内容类型的 JSON。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="abea" class="mn ke iq mj b gy mo mp l mq mr">curl -H <strong class="mj ir">"Content-Type: application/json"</strong> -X <strong class="mj ir">POST</strong> -d '{"about": "Database sanitization expert"}'<a class="ae kc" href="https://api.startup.io/users/1337" rel="noopener ugc nofollow" target="_blank"> https://api.startup.io/users/1337</a></span></pre><p id="3d8a" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">生成的输出是:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="8ef1" class="mn ke iq mj b gy mo mp l mq mr"><strong class="mj ir">{name: “Robert”, surname: “Tables”, about: “Database sanitization expert”}</strong></span></pre><p id="0288" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">如果该 API 没有针对攻击进行适当的保护，用户可能会提升他的权限。</p><p id="9db6" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">获取用户角色。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="d8d9" class="mn ke iq mj b gy mo mp l mq mr">curl -X <strong class="mj ir">GET</strong> <a class="ae kc" href="https://api.startup.io/users/1337/role" rel="noopener ugc nofollow" target="_blank">https://api.startup.io/users/1337/role</a></span><span id="bff8" class="mn ke iq mj b gy ms mp l mq mr"><strong class="mj ir">{“role”: “user”}</strong></span></pre><p id="91d5" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">现在我们知道了属性的名称，我们可以沿着对象层次结构向上爬，并更改用户角色，前提是没有设置适当的安全控制。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="0c18" class="mn ke iq mj b gy mo mp l mq mr">curl -H "Content-Type: application/json" -X POST -d '{"about": {"__proto__": {"role": "admin"}}}'<a class="ae kc" href="https://api.startup.io/users/1337" rel="noopener ugc nofollow" target="_blank"> https://api.startup.io/users/1337</a></span></pre><p id="9c7f" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated"><strong class="ld ir">注意</strong> : <em class="mu">正如我们之前讨论过的，我们可以使用 Object_name 沿着对象层次向上爬。</em><strong class="ld ir"><em class="mu">_ _ proto _ _</em></strong><em class="mu">，Object_name。</em><strong class="ld ir"><em class="mu">_ _ proto _ _</em></strong><em class="mu">。</em><strong class="ld ir"><em class="mu"/>_ _ proto _ _</strong></p><p id="5c6d" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">现在，如果我们向 https://api.startup.io/users/1337/role 的<a class="ae kc" href="https://api.startup.io/users/1337/role" rel="noopener ugc nofollow" target="_blank"><strong class="ld ir"/></a><strong class="ld ir">发出 GET 请求，我们将得到 admin 作为响应。</strong></p><h1 id="6b90" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated"><strong class="ak">结论</strong></h1><p id="1d29" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">在这篇博文中，我们讨论了为什么 JS 是一种 OOP 语言，原型如何被修改和利用，以及什么是原型污染。</p><p id="323d" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">这只是如何利用它的一个方面。原型污染还会导致对远程代码执行的 DoS 攻击。</p><p id="ebce" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">在 CVE-2019–7609(<a class="ae kc" href="https://research.securitum.com/prototype-pollution-rce-kibana-cve-2019-7609/" rel="noopener ugc nofollow" target="_blank">基巴纳</a>)可以找到一个这样的例子原型对 RCE 的污染。</p><p id="890a" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">旧版本的 Lodash 也容易受到原型污染。</p></div></div>    
</body>
</html>