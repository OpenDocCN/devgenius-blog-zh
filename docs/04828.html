<html>
<head>
<title>C++20 Coroutine: Compiler’s Point Of View</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C++20 协同程序:编译器的观点</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/c-20-coroutine-compilers-point-of-view-dc1da4f8f8e0?source=collection_archive---------4-----------------------#2021-05-10">https://blog.devgenius.io/c-20-coroutine-compilers-point-of-view-dc1da4f8f8e0?source=collection_archive---------4-----------------------#2021-05-10</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/1c91bbfbf3d1e1f8512c8c66fa6294d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GeY7O-y3_QrIQPq1E_s0PA.png"/></div></div></figure><p id="64bf" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">除了<a class="ae kt" href="https://en.cppreference.com/w/cpp/language/modules" rel="noopener ugc nofollow" target="_blank">模块</a>、<a class="ae kt" href="https://en.cppreference.com/w/cpp/ranges" rel="noopener ugc nofollow" target="_blank">范围</a>、&amp;、<a class="ae kt" href="https://en.cppreference.com/w/cpp/concepts" rel="noopener ugc nofollow" target="_blank">概念</a>之外，协程是 C++20 标准引入的主要特性之一。你看我打开它有多开心。我已经在我的上一篇文章中设定了这个主题的基线，在那篇文章中，我们看到了执行的暂停-恢复是如何工作的！通过这篇文章“C++20 协程:幕后”,我们将看到编译器如何创造神奇的&amp;标准库帮助它的基本基础设施，使 C++20 协程更加复杂(然而更复杂)&amp;可伸缩/可定制。</p><blockquote class="ku kv kw"><p id="e72a" class="jv jw kx jx b jy jz ka kb kc kd ke kf ky kh ki kj kz kl km kn la kp kq kr ks ig bi translated"><em class="in"> /！\:本文原载于</em> <a class="ae kt" href="http://www.vishalchovatiya.com/cpp20-coroutine-under-the-hood/" rel="noopener ugc nofollow" target="_blank"> <em class="in">我的博客</em> </a> <em class="in">。</em></p></blockquote><p id="2d83" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在任何时候，你都觉得有一些术语不为你所知。请继续往下读。我为它增加了一个特殊的章节。</p><h1 id="c7fd" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">一般来说协程是什么？</h1><figure class="ma mb mc md gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lz"><img src="../Images/3f2b1f905339b74745717da0eac1a53d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*yXgbVkpyafxXvmfE.png"/></div></div></figure><ul class=""><li id="bf33" class="me mf in jx b jy jz kc kd kg mg kk mh ko mi ks mj mk ml mm bi translated">更多信息请参考我之前的文章【C 语言中的 T21】协程。</li></ul><h1 id="75aa" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">什么是 C++20 协程？</h1><ul class=""><li id="ab53" class="me mf in jx b jy mn kc mo kg mp kk mq ko mr ks mj mk ml mm bi translated">一种功能</li></ul><ol class=""><li id="b4c5" class="me mf in jx b jy jz kc kd kg mg kk mh ko mi ks ms mk ml mm bi translated">包含关键字<code class="fe mt mu mv mw b">co_await</code>、<code class="fe mt mu mv mw b">co_yield </code>和/或<code class="fe mt mu mv mw b">co_return</code>。</li><li id="808f" class="me mf in jx b jy mx kc my kg mz kk na ko nb ks ms mk ml mm bi translated">使用指定承诺的返回类型。</li></ol><ul class=""><li id="f4ef" class="me mf in jx b jy jz kc kd kg mg kk mh ko mi ks mj mk ml mm bi translated">从更高的抽象层次来看，C++20 协同例程包括:</li></ul><p id="5315" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">承诺</strong></p><ul class=""><li id="197a" class="me mf in jx b jy jz kc kd kg mg kk mh ko mi ks mj mk ml mm bi translated">定义总体协程行为。</li><li id="3fa8" class="me mf in jx b jy mx kc my kg mz kk na ko nb ks mj mk ml mm bi translated">充当调用者之间的沟通者&amp;称为协程。</li></ul><p id="421f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">获奖者</strong></p><ul class=""><li id="08c0" class="me mf in jx b jy jz kc kd kg mg kk mh ko mi ks mj mk ml mm bi translated">控制暂停和恢复行为。</li></ul><p id="6816" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">协程手柄</strong></p><ul class=""><li id="d3d7" class="me mf in jx b jy jz kc kd kg mg kk mh ko mi ks mj mk ml mm bi translated">控制执行行为。</li></ul><h1 id="f80a" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">为什么您甚至需要协程？</h1><ul class=""><li id="a6b5" class="me mf in jx b jy mn kc mo kg mp kk mq ko mr ks mj mk ml mm bi translated">我已经在我之前的文章<a class="ae kt" href="http://www.vishalchovatiya.com/coroutine-in-c-language/" rel="noopener ugc nofollow" target="_blank">C 语言协程</a>中提到了这一点。</li><li id="b11a" class="me mf in jx b jy mx kc my kg mz kk na ko nb ks mj mk ml mm bi translated">然而，如果你仍然想理解用例对协程的需求，那么请参考<a class="ae kt" href="http://www.vishalchovatiya.com/iterator-design-pattern-in-modern-cpp/" rel="noopener ugc nofollow" target="_blank">现代 C++迭代器设计模式</a>。</li><li id="6744" class="me mf in jx b jy mx kc my kg mz kk na ko nb ks mj mk ml mm bi translated">或者你可以直接看到本文<a class="ae kt" href="http://www.vishalchovatiya.com/cpp20-coroutine-under-the-hood/#Generating_Integer_Sequence_Using_C20_Coroutine" rel="noopener ugc nofollow" target="_blank">使用协程</a>生成整数序列一节。</li></ul><h1 id="b7b0" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">用实例理解 C++20 协同程序</h1><ul class=""><li id="ee10" class="me mf in jx b jy mn kc mo kg mp kk mq ko mr ks mj mk ml mm bi translated">理论够了。我们来谈谈代码。</li></ul><h1 id="40c6" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">挂起协程</h1><ul class=""><li id="e70d" class="me mf in jx b jy mn kc mo kg mp kk mq ko mr ks mj mk ml mm bi translated">下面是一个蹩脚的 C++20 协程的最小的例子。但是对于步伐缓慢且代码不那么混乱的初学者来说，这是一个非常好的起点。</li></ul><pre class="ma mb mc md gt nc mw nd ne aw nf bi"><span id="e3f2" class="ng lc in mw b gy nh ni l nj nk">#include &lt;coroutine&gt;<br/>#include &lt;iostream&gt;</span><span id="5e46" class="ng lc in mw b gy nl ni l nj nk">struct HelloWorldCoro {<br/>    struct promise_type { // compiler looks for `promise_type`<br/>        HelloWorldCoro get_return_object() { return this; }    <br/>        std::suspend_always initial_suspend() { return {}; }        <br/>        std::suspend_always final_suspend() { return {}; }<br/>    };</span><span id="84d1" class="ng lc in mw b gy nl ni l nj nk">    HelloWorldCoro(promise_type* p) : m_handle(std::coroutine_handle&lt;promise_type&gt;::from_promise(*p)) {}<br/>    ~HelloWorldCoro() { m_handle.destroy(); }</span><span id="e68c" class="ng lc in mw b gy nl ni l nj nk">    std::coroutine_handle&lt;promise_type&gt;      m_handle;<br/>};</span><span id="bc3d" class="ng lc in mw b gy nl ni l nj nk">HelloWorldCoro print_hello_world() {<br/>    std::cout &lt;&lt; "Hello ";<br/>    co_await std::suspend_always{};<br/>    std::cout &lt;&lt; "World!" &lt;&lt; std::endl;<br/>}</span><span id="036e" class="ng lc in mw b gy nl ni l nj nk">int main() {<br/>    HelloWorldCoro mycoro = print_hello_world();</span><span id="24bc" class="ng lc in mw b gy nl ni l nj nk">    mycoro.m_handle.resume();<br/>    mycoro.m_handle(); // Equal to mycoro.m_handle.resume();<br/>    return EXIT_SUCCESS;<br/>}<br/>// g++-10 -std=c++20 -fcoroutines -fno-exceptions -o myapp Main.cpp</span></pre><ul class=""><li id="23a7" class="me mf in jx b jy jz kc kd kg mg kk mh ko mi ks mj mk ml mm bi translated">协程可以通过<code class="fe mt mu mv mw b">std::coroutine_handle</code>的恢复成员函数或者通过调用<code class="fe mt mu mv mw b">std::coroutine_handle</code>对象的函数调用操作符来恢复。</li><li id="9e5e" class="me mf in jx b jy mx kc my kg mz kk na ko nb ks mj mk ml mm bi translated">正如我前面提到的，C++20 协同程序包括:</li></ul><p id="6497" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">承诺即</strong> <a class="ae kt" href="https://en.cppreference.com/w/cpp/coroutine/coroutine_traits" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io">承诺 _ 类型</strong> </a></p><ul class=""><li id="bbe6" class="me mf in jx b jy jz kc kd kg mg kk mh ko mi ks mj mk ml mm bi translated">包含特殊方法的类型，如 get_return_object()、initial_suspend()、final_suspend()等。编译器在协程转换中使用的。因此，它控制整个协程行为。</li></ul><p id="2dd7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> Awaiter 即</strong><a class="ae kt" href="https://en.cppreference.com/w/cpp/coroutine/suspend_always" rel="noopener ugc nofollow" target="_blank"><strong class="jx io">STD::suspend _ alwait</strong></a></p><ul class=""><li id="4618" class="me mf in jx b jy jz kc kd kg mg kk mh ko mi ks mj mk ml mm bi translated">总是挂起协程的空类。</li><li id="40d1" class="me mf in jx b jy mx kc my kg mz kk na ko nb ks mj mk ml mm bi translated">您可以在这里看到这种类型<a class="ae kt" href="https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/include/std/coroutine#L313" rel="noopener ugc nofollow" target="_blank">的 GCC 实现。</a></li></ul><p id="b268" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">协程句柄即</strong> <a class="ae kt" href="https://en.cppreference.com/w/cpp/coroutine/coroutine_handle" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> std::协程 _ 句柄</strong> </a></p><ul class=""><li id="f369" class="me mf in jx b jy jz kc kd kg mg kk mh ko mi ks mj mk ml mm bi translated">用于恢复、销毁或检查协程生命周期的协程处理程序。</li><li id="878e" class="me mf in jx b jy mx kc my kg mz kk na ko nb ks mj mk ml mm bi translated">编译器将上述<code class="fe mt mu mv mw b">print_hello_world</code>协程转换为:</li></ul><pre class="ma mb mc md gt nc mw nd ne aw nf bi"><span id="aa77" class="ng lc in mw b gy nh ni l nj nk">HelloWorldCoro print_hello_world() {<br/>    __HelloWorldCoro_ctx* __context = new __HelloWorldCoro_ctx{};<br/>    auto __return = __context-&gt;_promise.get_return_object();<br/>    co_await __context-&gt;_promise.initial_suspend();</span><span id="1e26" class="ng lc in mw b gy nl ni l nj nk">    std::cout &lt;&lt; "Hello ";<br/>    co_await std::suspend_always{ };<br/>    std::cout &lt;&lt; "World!" &lt;&lt; std::endl;</span><span id="747b" class="ng lc in mw b gy nl ni l nj nk">__final_suspend_label:<br/>    co_await __context-&gt;_promise.final_suspend();<br/>    delete __context;<br/>    return __return;<br/>}</span></pre><ul class=""><li id="77ac" class="me mf in jx b jy jz kc kd kg mg kk mh ko mi ks mj mk ml mm bi translated">如您所见，编译器首先创建上下文(即协同程序状态)对象。大概是这样的:</li></ul><pre class="ma mb mc md gt nc mw nd ne aw nf bi"><span id="74e5" class="ng lc in mw b gy nh ni l nj nk">struct __HelloWorldCoro_ctx {<br/>    HelloWorldCoro::promise_type _promise;<br/>    // storage for argument passed to coroutine<br/>    // storage for local variables<br/>    // storage for representation of the current suspension point<br/>};</span><span id="7bcf" class="ng lc in mw b gy nl ni l nj nk">// Standard doesn't define such type, rather compilers choose the type that suits its implementation.</span></pre><ul class=""><li id="9dc9" class="me mf in jx b jy jz kc kd kg mg kk mh ko mi ks mj mk ml mm bi translated">如图所示，在这个上下文对象的帮助下，它借助 promise 的方法<code class="fe mt mu mv mw b">get_return_object()</code>创建了名为<code class="fe mt mu mv mw b">__return</code>的<code class="fe mt mu mv mw b">HelloWorldCoro</code>对象。</li><li id="e868" class="me mf in jx b jy mx kc my kg mz kk na ko nb ks mj mk ml mm bi translated">最后，对<code class="fe mt mu mv mw b">co_await</code>语句的一个更高层次的转换，协程应该是这样的:</li></ul><pre class="ma mb mc md gt nc mw nd ne aw nf bi"><span id="6ffc" class="ng lc in mw b gy nh ni l nj nk">HelloWorldCoro print_hello_world() {<br/>    __HelloWorldCoro_ctx* __context = new __HelloWorldCoro_ctx{};<br/>    auto __return = __context-&gt;_promise.get_return_object();<br/>    {<br/>        auto&amp;&amp; awaiter = std::suspend_always{};<br/>        if (!awaiter.await_ready()) {<br/>            awaiter.await_suspend(std::coroutine_handle&lt;&gt; p); <br/>            // compiler added suspend/resume hook<br/>        }<br/>        awaiter.await_resume();<br/>    }</span><span id="8c5d" class="ng lc in mw b gy nl ni l nj nk">    std::cout &lt;&lt; "Hello ";<br/>    {<br/>        auto&amp;&amp; awaiter = std::suspend_always{};<br/>        if (!awaiter.await_ready()) {<br/>            awaiter.await_suspend(std::coroutine_handle&lt;&gt; p); <br/>            // compiler added suspend/resume hook<br/>        }<br/>        awaiter.await_resume();<br/>    }<br/>    std::cout &lt;&lt; "World!" &lt;&lt; std::endl;</span><span id="e930" class="ng lc in mw b gy nl ni l nj nk">__final_suspend_label:<br/>    {<br/>        auto&amp;&amp; awaiter = std::suspend_always{};<br/>        if (!awaiter.await_ready()) {<br/>            awaiter.await_suspend(std::coroutine_handle&lt;&gt; p); <br/>            // compiler added suspend/resume hook<br/>        }<br/>        awaiter.await_resume();<br/>    }<br/>    return __return;<br/>}</span></pre><ul class=""><li id="c272" class="me mf in jx b jy jz kc kd kg mg kk mh ko mi ks mj mk ml mm bi translated">你可以看到我们的<code class="fe mt mu mv mw b">HelloWorldCoro::promise_type::initial_suspend()</code> \ &amp; <code class="fe mt mu mv mw b">HelloWorldCoro::promise_type::final_suspend()</code>返回<code class="fe mt mu mv mw b">std::suspend_always</code>。</li><li id="7c9a" class="me mf in jx b jy mx kc my kg mz kk na ko nb ks mj mk ml mm bi translated">Whose，方法<code class="fe mt mu mv mw b">std::suspend_always::await_ready()</code>反过来总是返回<code class="fe mt mu mv mw b">false</code>。</li><li id="c8f0" class="me mf in jx b jy mx kc my kg mz kk na ko nb ks mj mk ml mm bi translated">所以我们的协程每次遇到<code class="fe mt mu mv mw b">co_await</code>都会暂停。</li></ul><h1 id="2004" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">从协程中返回值</h1><pre class="ma mb mc md gt nc mw nd ne aw nf bi"><span id="23ff" class="ng lc in mw b gy nh ni l nj nk">#include &lt;coroutine&gt;<br/>#include &lt;iostream&gt;<br/>#include &lt;cassert&gt;</span><span id="7a23" class="ng lc in mw b gy nl ni l nj nk">struct HelloWorldCoro {<br/>    struct promise_type {<br/>        int m_value;</span><span id="2d3d" class="ng lc in mw b gy nl ni l nj nk">        HelloWorldCoro get_return_object() { return this; }<br/>        std::suspend_always initial_suspend() { return {}; }<br/>        std::suspend_always final_suspend() { return {}; }</span><span id="21c8" class="ng lc in mw b gy nl ni l nj nk">        void return_value(int val) { m_value = val; }<br/>    };</span><span id="980c" class="ng lc in mw b gy nl ni l nj nk">    HelloWorldCoro(promise_type* p) : m_handle(std::coroutine_handle&lt;promise_type&gt;::from_promise(*p)) {}<br/>    ~HelloWorldCoro() { m_handle.destroy(); }</span><span id="f2cf" class="ng lc in mw b gy nl ni l nj nk">    std::coroutine_handle&lt;promise_type&gt;      m_handle;<br/>};</span><span id="b92f" class="ng lc in mw b gy nl ni l nj nk">HelloWorldCoro print_hello_world() {<br/>    std::cout &lt;&lt; "Hello ";<br/>    co_await std::suspend_always{ };<br/>    std::cout &lt;&lt; "World!" &lt;&lt; std::endl;</span><span id="1459" class="ng lc in mw b gy nl ni l nj nk">    co_return -1;<br/>}<br/></span><span id="0a2b" class="ng lc in mw b gy nl ni l nj nk">int main() {<br/>    HelloWorldCoro mycoro = print_hello_world();</span><span id="9d90" class="ng lc in mw b gy nl ni l nj nk">    mycoro.m_handle.resume();<br/>    mycoro.m_handle.resume();<br/>    assert(mycoro.m_handle.promise().m_value == -1);<br/>    return EXIT_SUCCESS;<br/>}</span></pre><ul class=""><li id="1cbb" class="me mf in jx b jy jz kc kd kg mg kk mh ko mi ks mj mk ml mm bi translated">要从协程返回值，您需要向 promise 类型提供<code class="fe mt mu mv mw b">return_value()</code>方法。换句话说，编译器希望名为<code class="fe mt mu mv mw b">return_value</code>的方法带有适当的参数。</li><li id="3801" class="me mf in jx b jy mx kc my kg mz kk na ko nb ks mj mk ml mm bi translated">并且，如果您不将其提供给 promise type，系统将提示您以下错误:</li></ul><pre class="ma mb mc md gt nc mw nd ne aw nf bi"><span id="3413" class="ng lc in mw b gy nh ni l nj nk">Main.cpp:27:5: error: no member named ‘return_value’ in ‘std::__n4861::__coroutine_traits_impl&lt;HelloWorldCoro, void&gt;::promise_type’ {aka ‘HelloWorldCoro::promise_type’}<br/>    27 |     co_return -1;<br/>       |     ^~~~~~~~~</span></pre><ul class=""><li id="f73e" class="me mf in jx b jy jz kc kd kg mg kk mh ko mi ks mj mk ml mm bi translated">这个<code class="fe mt mu mv mw b">return_value()</code>方法然后被编译器用来转换<code class="fe mt mu mv mw b">co_return</code>语句，如下所示:</li></ul><pre class="ma mb mc md gt nc mw nd ne aw nf bi"><span id="934d" class="ng lc in mw b gy nh ni l nj nk">HelloWorldCoro print_hello_world() {<br/>    __HelloWorldCoro_ctx* __context = new __HelloWorldCoro_ctx{};<br/>    auto __return = __context-&gt;_promise.get_return_object();<br/>    co_await __context-&gt;_promise.initial_suspend();</span><span id="c9b8" class="ng lc in mw b gy nl ni l nj nk">    std::cout &lt;&lt; "Hello ";<br/>    co_await std::suspend_always{ };<br/>    std::cout &lt;&lt; "World!" &lt;&lt; std::endl;</span><span id="6852" class="ng lc in mw b gy nl ni l nj nk">    __context-&gt;_promise.return_value(-1);<br/>    goto __final_suspend_label;</span><span id="d405" class="ng lc in mw b gy nl ni l nj nk">__final_suspend_label:<br/>    co_await __context-&gt;_promise.final_suspend();<br/>    delete __context;<br/>    return __return;<br/>}</span></pre><ul class=""><li id="2d4d" class="me mf in jx b jy jz kc kd kg mg kk mh ko mi ks mj mk ml mm bi translated">您可能已经注意到，<code class="fe mt mu mv mw b">co_return</code>转换是普通的，编译器只是将返回值传递给 promise 对象&amp;跳转到最后的 suspend 标签。</li><li id="b501" class="me mf in jx b jy mx kc my kg mz kk na ko nb ks mj mk ml mm bi translated">我就不再展开<code class="fe mt mu mv mw b">co_await</code>语句了。否则代码会变得很乱。但是，现在，你可以猜猜那里会有什么。</li></ul><h1 id="f190" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">从协程中产生一个值</h1><pre class="ma mb mc md gt nc mw nd ne aw nf bi"><span id="61e8" class="ng lc in mw b gy nh ni l nj nk">#include &lt;coroutine&gt;<br/>#include &lt;iostream&gt;<br/>#include &lt;cassert&gt;</span><span id="b64d" class="ng lc in mw b gy nl ni l nj nk">struct HelloWorldCoro {<br/>    struct promise_type {<br/>        int m_val;</span><span id="78f5" class="ng lc in mw b gy nl ni l nj nk">        HelloWorldCoro get_return_object() { return this; } <br/>        std::suspend_always initial_suspend() { return {}; } <br/>        std::suspend_always final_suspend() { return {}; } </span><span id="91e9" class="ng lc in mw b gy nl ni l nj nk">        std::suspend_always yield_value(int val) {<br/>            m_val = val; <br/>            return {};<br/>        }<br/>    };</span><span id="f7f3" class="ng lc in mw b gy nl ni l nj nk">    HelloWorldCoro(promise_type* p) : m_handle(std::coroutine_handle&lt;promise_type&gt;::from_promise(*p)) {}<br/>    ~HelloWorldCoro() { m_handle.destroy(); }</span><span id="2b75" class="ng lc in mw b gy nl ni l nj nk">    std::coroutine_handle&lt;promise_type&gt;      m_handle;<br/>};</span><span id="89a6" class="ng lc in mw b gy nl ni l nj nk">HelloWorldCoro print_hello_world() {<br/>    std::cout &lt;&lt; "Hello ";<br/>    co_yield 1;<br/>    std::cout &lt;&lt; "World!" &lt;&lt; std::endl;<br/>}</span><span id="f265" class="ng lc in mw b gy nl ni l nj nk">int main() {<br/>    HelloWorldCoro mycoro = print_hello_world();</span><span id="686d" class="ng lc in mw b gy nl ni l nj nk">    mycoro.m_handle.resume();<br/>    assert(mycoro.m_handle.promise().m_val == 1);<br/>    mycoro.m_handle.resume();<br/>    return EXIT_SUCCESS;<br/>}</span></pre><ul class=""><li id="c2da" class="me mf in jx b jy jz kc kd kg mg kk mh ko mi ks mj mk ml mm bi translated">正如我们在从协程返回值时所做的那样，要从协程中产生任何东西，您需要向返回适当类型的 promise_type 提供 yield_value()方法。</li><li id="bbec" class="me mf in jx b jy mx kc my kg mz kk na ko nb ks mj mk ml mm bi translated">编译器再次将协程转换为:</li></ul><pre class="ma mb mc md gt nc mw nd ne aw nf bi"><span id="7cdd" class="ng lc in mw b gy nh ni l nj nk">HelloWorldCoro print_hello_world() {<br/>    __HelloWorldCoro_ctx* __context = new __HelloWorldCoro_ctx{};<br/>    auto __return = __context-&gt;_promise.get_return_object();<br/>    co_await __context-&gt;_promise.initial_suspend();</span><span id="f44d" class="ng lc in mw b gy nl ni l nj nk">    std::cout &lt;&lt; "Hello ";<br/>    co_await __context-&gt;_promise.yield_value(1);<br/>    std::cout &lt;&lt; "World!" &lt;&lt; std::endl;</span><span id="1656" class="ng lc in mw b gy nl ni l nj nk">__final_suspend_label:<br/>    co_await __context-&gt;_promise.final_suspend();<br/>    delete __context;<br/>    return __return;<br/>}</span></pre><ul class=""><li id="7a6a" class="me mf in jx b jy jz kc kd kg mg kk mh ko mi ks mj mk ml mm bi translated">可以看到<code class="fe mt mu mv mw b">co_yield</code>语句转换成了<code class="fe mt mu mv mw b">co_await</code>考虑承诺的方法(即<code class="fe mt mu mv mw b">yield_value()</code>)调用作为表达式。这将返回<code class="fe mt mu mv mw b">std::suspend_always</code>,因此我们的协程将被挂起，然后产生一个值。</li></ul><h1 id="c3fe" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">用 C++20 协同程序生成整数序列</h1><ul class=""><li id="67c6" class="me mf in jx b jy mn kc mo kg mp kk mq ko mr ks mj mk ml mm bi translated">那么，我们已经理解了协程的编译器转换，让我们用协程做一些有意义的事情。</li></ul><pre class="ma mb mc md gt nc mw nd ne aw nf bi"><span id="3578" class="ng lc in mw b gy nh ni l nj nk">#include &lt;coroutine&gt;<br/>#include &lt;iostream&gt;<br/>#include &lt;cassert&gt;</span><span id="0785" class="ng lc in mw b gy nl ni l nj nk">struct Generator {<br/>    struct promise_type {<br/>        int m_val;</span><span id="0783" class="ng lc in mw b gy nl ni l nj nk">        Generator get_return_object() { return this; }<br/>        std::suspend_never initial_suspend() { return {}; }<br/>        std::suspend_always final_suspend() { return {}; }</span><span id="f8d0" class="ng lc in mw b gy nl ni l nj nk">        std::suspend_always yield_value(int val) {<br/>            m_val = val; <br/>            return {};<br/>        }<br/>    };</span><span id="9a36" class="ng lc in mw b gy nl ni l nj nk">    /* ---------------------------- Iterator Implementation ----------------------------- */<br/>    struct iterator {<br/>        bool operator!=(const iterator&amp; rhs) { return not m_h_ptr-&gt;done(); }<br/>        iterator&amp; operator++() { <br/>            m_h_ptr-&gt;resume(); <br/>            return *this; <br/>        }<br/>        int operator*() { return m_h_ptr-&gt;promise().m_val; }</span><span id="e7bd" class="ng lc in mw b gy nl ni l nj nk">        std::coroutine_handle&lt;promise_type&gt; *m_h_ptr;<br/>    };</span><span id="4374" class="ng lc in mw b gy nl ni l nj nk">    iterator begin() { return iterator{&amp;m_handle}; }<br/>    iterator end() { return iterator{nullptr}; }<br/>    /* ---------------------------------------------------------------------------------- */</span><span id="c049" class="ng lc in mw b gy nl ni l nj nk">    Generator(promise_type* p) : m_handle(std::coroutine_handle&lt;promise_type&gt;::from_promise(*p)) {}<br/>    ~Generator() { m_handle.destroy(); }</span><span id="912f" class="ng lc in mw b gy nl ni l nj nk">    std::coroutine_handle&lt;promise_type&gt;      m_handle;<br/>};<br/></span><span id="0784" class="ng lc in mw b gy nl ni l nj nk">Generator range(uint32_t start, uint32_t end) {<br/>    while(start != end)<br/>        co_yield start++;<br/>}</span><span id="a6ab" class="ng lc in mw b gy nl ni l nj nk">int main() {<br/>    for (auto &amp;&amp;no : range(0, 10)) {  // Isn't this look like Python !<br/>        std::cout&lt;&lt; no &lt;&lt;std::endl;<br/>    }<br/>    return EXIT_SUCCESS;<br/>}</span></pre><ul class=""><li id="47f3" class="me mf in jx b jy jz kc kd kg mg kk mh ko mi ks mj mk ml mm bi translated">上述代码的<code class="fe mt mu mv mw b">range()</code>函数将根据需要在每次迭代中生成整数。而不是生成&amp;返回预计算序列。</li><li id="e2f5" class="me mf in jx b jy mx kc my kg mz kk na ko nb ks mj mk ml mm bi translated">对于其余的代码，我建议您耐心地花些时间。在它周围玩耍。</li><li id="12fa" class="me mf in jx b jy mx kc my kg mz kk na ko nb ks mj mk ml mm bi translated">而且，如果你在想为什么我们需要在<code class="fe mt mu mv mw b">Generator</code>中实现<code class="fe mt mu mv mw b">iterator</code>，那么请学习一下<a class="ae kt" href="https://cppinsights.io/lnk?code=I2luY2x1ZGUgPGNzdGRpbz4KCmludCBtYWluKCkKewogICAgY29uc3QgY2hhciBhcnJbXXsyLDQsNiw4LDEwfTsKCiAgICBmb3IoY29uc3QgY2hhciYgYyA6IGFycikKICAgIHsKICAgICAgcHJpbnRmKCJjPSVjXG4iLCBjKTsKICAgIH0KfQ==&amp;std=cpp17&amp;rev=1.0" rel="noopener ugc nofollow" target="_blank">如何在 C++中使用基于范围的</a> <code class="fe mt mu mv mw b"><a class="ae kt" href="https://cppinsights.io/lnk?code=I2luY2x1ZGUgPGNzdGRpbz4KCmludCBtYWluKCkKewogICAgY29uc3QgY2hhciBhcnJbXXsyLDQsNiw4LDEwfTsKCiAgICBmb3IoY29uc3QgY2hhciYgYyA6IGFycikKICAgIHsKICAgICAgcHJpbnRmKCJjPSVjXG4iLCBjKTsKICAgIH0KfQ==&amp;std=cpp17&amp;rev=1.0" rel="noopener ugc nofollow" target="_blank">for</a></code> <a class="ae kt" href="https://cppinsights.io/lnk?code=I2luY2x1ZGUgPGNzdGRpbz4KCmludCBtYWluKCkKewogICAgY29uc3QgY2hhciBhcnJbXXsyLDQsNiw4LDEwfTsKCiAgICBmb3IoY29uc3QgY2hhciYgYyA6IGFycikKICAgIHsKICAgICAgcHJpbnRmKCJjPSVjXG4iLCBjKTsKICAgIH0KfQ==&amp;std=cpp17&amp;rev=1.0" rel="noopener ugc nofollow" target="_blank">循环！</a>。</li></ul><h1 id="acf5" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">C++20 协程术语</h1><ul class=""><li id="b7ef" class="me mf in jx b jy mn kc mo kg mp kk mq ko mr ks mj mk ml mm bi translated">这一部分应该放在文章的开头。然而，我相信，在你理解协程如何在幕后工作之前，你将无法将 C++20 协程术语上的点连接起来(或者不会理解数据类型命名约定)。</li><li id="7810" class="me mf in jx b jy mx kc my kg mz kk na ko nb ks mj mk ml mm bi translated">至此，您已经能够编写 C++协程了&amp;您可以忽略这一部分。但是你将很难与其他 C++开发人员交流。如果你这样做。</li></ul><h1 id="102a" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">值得称赞的</h1><ul class=""><li id="02bf" class="me mf in jx b jy mn kc mo kg mp kk mq ko mr ks mj mk ml mm bi translated">支持<code class="fe mt mu mv mw b">co_await</code>操作符的类型称为可适应类型。</li><li id="de16" class="me mf in jx b jy mx kc my kg mz kk na ko nb ks mj mk ml mm bi translated">C++20 引入了一个新的一元运算符<code class="fe mt mu mv mw b">co_await</code>，它可以应用于表达式。例如:</li></ul><pre class="ma mb mc md gt nc mw nd ne aw nf bi"><span id="d47c" class="ng lc in mw b gy nh ni l nj nk">struct dummy { // Awaitable<br/>    std::suspend_always operator co_await(){ return {}; }<br/>};</span><span id="e448" class="ng lc in mw b gy nl ni l nj nk">HelloWorldCoro print_hello_world() {<br/>    std::cout &lt;&lt; "Hello ";<br/>    co_await dummy{}; <br/>    std::cout &lt;&lt; "World!" &lt;&lt; std::endl;<br/>}</span></pre><h1 id="25c0" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">获奖人</h1><pre class="ma mb mc md gt nc mw nd ne aw nf bi"><span id="27f4" class="ng lc in mw b gy nh ni l nj nk">struct my_awaiter {<br/>    bool await_ready() { return false; } <br/>    void await_suspend(std::coroutine_handle&lt;&gt;) {} <br/>    void await_resume() {}<br/>};</span><span id="de47" class="ng lc in mw b gy nl ni l nj nk">HelloWorldCoro print_hello_world() {<br/>    std::cout &lt;&lt; "Hello ";<br/>    co_await my_awaiter{};<br/>    std::cout &lt;&lt; "World!" &lt;&lt; std::endl;<br/>}</span></pre><ul class=""><li id="a1eb" class="me mf in jx b jy jz kc kd kg mg kk mh ko mi ks mj mk ml mm bi translated">一个 Awaiter 类型是一个实现三个特殊方法的类型，这三个方法作为一个<code class="fe mt mu mv mw b">co_await</code>表达式的一部分被调用:<code class="fe mt mu mv mw b">await_ready()</code>、<code class="fe mt mu mv mw b">await_suspend()</code>和<code class="fe mt mu mv mw b">await_resume()</code>。例如，标准库定义了琐碎的 awaiters，即<a class="ae kt" href="https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/include/std/coroutine#L313" rel="noopener ugc nofollow" target="_blank">STD::suspend _ always</a>&amp;<a class="ae kt" href="https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/include/std/coroutine#L322" rel="noopener ugc nofollow" target="_blank">STD::suspend _ never</a>。</li><li id="dfe6" class="me mf in jx b jy mx kc my kg mz kk na ko nb ks mj mk ml mm bi translated">请注意，一个类型既可以是可接受类型，也可以是接受类型。</li></ul><h1 id="71a9" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><code class="fe mt mu mv mw b">co_await</code></h1><ul class=""><li id="df45" class="me mf in jx b jy mn kc mo kg mp kk mq ko mr ks mj mk ml mm bi translated"><code class="fe mt mu mv mw b">co_await</code>是一个一元运算符，它挂起协程并将控制权返回给调用者。它的操作数是一个表达式，其类型必须定义运算符<code class="fe mt mu mv mw b">co_await</code>，或者是一个变量。</li></ul><pre class="ma mb mc md gt nc mw nd ne aw nf bi"><span id="2449" class="ng lc in mw b gy nh ni l nj nk">struct dummy { }; // Awaitable</span><span id="4d69" class="ng lc in mw b gy nl ni l nj nk">struct HelloWorldCoro {<br/>    struct promise_type {<br/>        // . . .<br/>        auto await_transform(const dummy&amp;) {<br/>            return std::suspend_always{};<br/>        }<br/>    };<br/>    // . . .<br/>};</span><span id="38f5" class="ng lc in mw b gy nl ni l nj nk">HelloWorldCoro print_hello_world() {<br/>    std::cout &lt;&lt; "Hello ";<br/>    co_await dummy{}; <br/>    std::cout &lt;&lt; "World!" &lt;&lt; std::endl;<br/>}</span></pre><h1 id="5696" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">承诺</h1><ul class=""><li id="96a6" class="me mf in jx b jy mn kc mo kg mp kk mq ko mr ks mj mk ml mm bi translated">一种严格命名为<code class="fe mt mu mv mw b"><em class="kx">promise_type</em></code>的类型。</li><li id="c392" class="me mf in jx b jy mx kc my kg mz kk na ko nb ks mj mk ml mm bi translated">promise 对象用在协程内部。协程通过这个对象提交它的结果或异常。</li><li id="6423" class="me mf in jx b jy mx kc my kg mz kk na ko nb ks mj mk ml mm bi translated">承诺类型由编译器使用<a class="ae kt" href="https://en.cppreference.com/w/cpp/coroutine/coroutine_traits" rel="noopener ugc nofollow" target="_blank"> std::coroutine_traits </a>从协程的返回类型中确定。</li></ul><h1 id="dd0b" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">协程句柄</h1><ul class=""><li id="8f91" class="me mf in jx b jy mn kc mo kg mp kk mq ko mr ks mj mk ml mm bi translated">用于恢复协程执行或销毁协程框架的协程句柄。它还使用<code class="fe mt mu mv mw b">std::coroutine_handle::done()</code>方法指示协程的状态。</li></ul><h1 id="c8ba" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">协同状态</h1><ul class=""><li id="8c1c" class="me mf in jx b jy mn kc mo kg mp kk mq ko mr ks mj mk ml mm bi translated">协程状态(称为上下文对象)是编译器生成的、堆分配的(除非分配被优化掉)对象，它包含</li><li id="c4b0" class="me mf in jx b jy mx kc my kg mz kk na ko nb ks mj mk ml mm bi translated">承诺对象。</li><li id="c6ff" class="me mf in jx b jy mx kc my kg mz kk na ko nb ks mj mk ml mm bi translated">参数(全部按值复制)。</li><li id="201d" class="me mf in jx b jy mx kc my kg mz kk na ko nb ks mj mk ml mm bi translated">局部变量。</li><li id="f8d9" class="me mf in jx b jy mx kc my kg mz kk na ko nb ks mj mk ml mm bi translated">表示当前的暂停点，这样 resume 就知道在哪里继续，destroy 就知道范围内有哪些局部变量。</li></ul><h1 id="e5cb" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">协程如何被执行！</h1><ul class=""><li id="cc4c" class="me mf in jx b jy mn kc mo kg mp kk mq ko mr ks mj mk ml mm bi translated">啊…！真正的魔术时间到了！</li><li id="266d" class="me mf in jx b jy mx kc my kg mz kk na ko nb ks mj mk ml mm bi translated">现在，我们看到了编译器如何用协程关键字<code class="fe mt mu mv mw b">co_await</code>、<code class="fe mt mu mv mw b">co_yield</code>、&amp;、<code class="fe mt mu mv mw b">co_return</code>施展魔法。让我们了解它是如何执行的。</li><li id="10b3" class="me mf in jx b jy mx kc my kg mz kk na ko nb ks mj mk ml mm bi translated">但是，在我们前进之前，让我澄清几点:</li><li id="bbea" class="me mf in jx b jy mx kc my kg mz kk na ko nb ks mj mk ml mm bi translated">C++标准不关心实现，而是只统计行为。因此协程的实现完全依赖于编译器和库作者。要了解这一点，您可以检查<code class="fe mt mu mv mw b">std::coroutine_handle::resume()</code>的<a class="ae kt" href="https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/include/std/coroutine#L126" rel="noopener ugc nofollow" target="_blank">库实现</a>，它使用了 GCC 编译器提供的<a class="ae kt" href="https://raw.githubusercontent.com/mirrors/gcc/master/gcc/builtins.def" rel="noopener ugc nofollow" target="_blank"> __builtin_coro_resume </a>。证明库&amp;编译器是紧耦合的。</li><li id="dbc7" class="me mf in jx b jy mx kc my kg mz kk na ko nb ks mj mk ml mm bi translated">话虽如此，但在我的职业生涯中，我没有写过任何 C++库或编译器。虽然我已经为专有架构编写/移植了核心 C 库。因此，无论您在本节中看到什么，都只是为了直观地了解如何实现协程。根据我的研究和直觉。</li><li id="3dff" class="me mf in jx b jy mx kc my kg mz kk na ko nb ks mj mk ml mm bi translated">我认为有两种方法可以做到这一点:</li></ul><h1 id="1034" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">假设 1</h1><ul class=""><li id="ccbc" class="me mf in jx b jy mn kc mo kg mp kk mq ko mr ks mj mk ml mm bi translated">例如，如果您将协程定义为:</li></ul><pre class="ma mb mc md gt nc mw nd ne aw nf bi"><span id="c58c" class="ng lc in mw b gy nh ni l nj nk">HelloWorldCoro print_hello_world(int a) {<br/>    int b = 10;<br/>    co_await std::suspend_always{};<br/>    a = 10;<br/>    int c = 10;<br/>    co_await std::suspend_always{};<br/>    co_return a + b + c;<br/>}</span></pre><ul class=""><li id="e520" class="me mf in jx b jy jz kc kd kg mg kk mh ko mi ks mj mk ml mm bi translated">然后，操作可分为 3 个不同的部分，由 2 个悬挂点(即<code class="fe mt mu mv mw b">co_await &lt;expr&gt;</code>)分隔，如下所示</li></ul><ol class=""><li id="bd0d" class="me mf in jx b jy jz kc kd kg mg kk mh ko mi ks ms mk ml mm bi translated"><code class="fe mt mu mv mw b">int b = 10;</code></li><li id="283d" class="me mf in jx b jy mx kc my kg mz kk na ko nb ks ms mk ml mm bi translated"><code class="fe mt mu mv mw b">a = 10; int c = 10;</code></li><li id="1c45" class="me mf in jx b jy mx kc my kg mz kk na ko nb ks ms mk ml mm bi translated"><code class="fe mt mu mv mw b">co_return a + b + c;</code></li></ol><ul class=""><li id="3203" class="me mf in jx b jy jz kc kd kg mg kk mh ko mi ks mj mk ml mm bi translated">考虑到这些暂停点，编译器基本上</li><li id="d7b5" class="me mf in jx b jy mx kc my kg mz kk na ko nb ks mj mk ml mm bi translated">将您的协程重写为有点像函数的形式。</li><li id="1d8f" class="me mf in jx b jy mx kc my kg mz kk na ko nb ks mj mk ml mm bi translated">并创建所有局部变量的副本作为协程状态对象的数据成员。</li><li id="cb8b" class="me mf in jx b jy mx kc my kg mz kk na ko nb ks mj mk ml mm bi translated">您可以假设协程状态对象布局为:</li></ul><pre class="ma mb mc md gt nc mw nd ne aw nf bi"><span id="83b9" class="ng lc in mw b gy nh ni l nj nk">struct print_hello_world {</span><span id="e33a" class="ng lc in mw b gy nl ni l nj nk">    print_hello_world(int a_) : a{a}{} // Coroutine state object with coroutine arguments</span><span id="7e32" class="ng lc in mw b gy nl ni l nj nk">    void _s1(){ // Before suspension point 1 operations<br/>        int b = 10;</span><span id="aa6d" class="ng lc in mw b gy nl ni l nj nk">        sp = 1; // switching call back based on suspension point<br/>    } </span><span id="dec3" class="ng lc in mw b gy nl ni l nj nk">    void _s2(){ // Operations b/w suspension point 1 &amp; 2 <br/>        a = 10;<br/>        int c = 10;</span><span id="a3c3" class="ng lc in mw b gy nl ni l nj nk">        sp = 2;<br/>    } </span><span id="de3a" class="ng lc in mw b gy nl ni l nj nk">    void _s3(){ // Operations after suspension point 2 <br/>        promise.return_value(a + b + c);  // After execution, coro_done = true;</span><span id="5125" class="ng lc in mw b gy nl ni l nj nk">        coro_done = true;<br/>    } </span><span id="bb74" class="ng lc in mw b gy nl ni l nj nk">    int a, b, c; // Local variables</span><span id="cb67" class="ng lc in mw b gy nl ni l nj nk">    promise_type&amp; promise;</span><span id="3857" class="ng lc in mw b gy nl ni l nj nk">    void (*s_cb)[] = {_s1, _s2, _s3}; // suspension point callbacks <br/>    int sp{0}; // current suspension point(sp)<br/>    bool coro_done{false};<br/>};</span></pre><ul class=""><li id="0c39" class="me mf in jx b jy jz kc kd kg mg kk mh ko mi ks mj mk ml mm bi translated">现在，当您调用协程时，您基本上是在创建一个协程状态对象，其参数与协程相似。</li></ul><pre class="ma mb mc md gt nc mw nd ne aw nf bi"><span id="3fab" class="ng lc in mw b gy nh ni l nj nk">auto mycoro = print_hello_world(5);</span><span id="b49b" class="ng lc in mw b gy nl ni l nj nk">// transform into</span><span id="c022" class="ng lc in mw b gy nl ni l nj nk">print_hello_world    mycoro(5);</span></pre><ul class=""><li id="63be" class="me mf in jx b jy jz kc kd kg mg kk mh ko mi ks mj mk ml mm bi translated">您可能已经猜到，由于将协程重写为微小的函数，我们不再需要挂起机制。和恢复可以实现为:</li></ul><pre class="ma mb mc md gt nc mw nd ne aw nf bi"><span id="a5d4" class="ng lc in mw b gy nh ni l nj nk">void std::coroutine_handle::resume() { <br/>    if(not print_hello_world::coro_done)<br/>        print_hello_world::s_cb[sp]();<br/>}</span></pre><ul class=""><li id="a77b" class="me mf in jx b jy jz kc kd kg mg kk mh ko mi ks mj mk ml mm bi translated">因此，当您调用 resume 时，您基本上是从一个协程状态对象中调用特定于暂停点的小函数(技术上来说是它的方法)。这意味着创建两个堆栈帧，即<code class="fe mt mu mv mw b">std::coroutine_handle::resume()</code> &amp; <code class="fe mt mu mv mw b">print_hello_world::_sX()</code>，其中<code class="fe mt mu mv mw b">X</code>代表悬挂点编号。因此不需要单独的堆栈&amp;使用与调用者相同的堆栈。这就是为什么 C++20 协同程序比无堆栈协同程序快。</li><li id="b87b" class="me mf in jx b jy mx kc my kg mz kk na ko nb ks mj mk ml mm bi translated">我同意上面的例子是不可编译的，不包括边缘情况&amp;不考虑定制的(即一个 waiter 对象)协程行为。但是，凭借我们刚刚建立的直觉，您可以轻松地创建协程的心理模型&amp;参见编译器视角。</li><li id="78cd" class="me mf in jx b jy mx kc my kg mz kk na ko nb ks mj mk ml mm bi translated">为了测试您的直觉能力，想象一下<strong class="jx io">如何在 for 循环中为包含</strong> <code class="fe mt mu mv mw b"><strong class="jx io">co_await</strong></code> <strong class="jx io">表达式的协程创建微小的函数？</strong></li></ul><h1 id="14f9" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">假设 2</h1><ul class=""><li id="31fa" class="me mf in jx b jy mn kc mo kg mp kk mq ko mr ks mj mk ml mm bi translated">另一种实现暂停-恢复的常用方法是借助<a class="ae kt" href="http://www.vishalchovatiya.com/coroutine-in-c-language/" rel="noopener ugc nofollow" target="_blank">上下文切换 API</a>。比如在<code class="fe mt mu mv mw b">co_wait &lt;expr&gt;</code>语句的扩展中，我已经提到了下面的注释“<em class="kx">编译器增加了挂起/恢复钩子</em>”。</li></ul><pre class="ma mb mc md gt nc mw nd ne aw nf bi"><span id="129c" class="ng lc in mw b gy nh ni l nj nk">{<br/>    auto&amp;&amp; awaiter = std::suspend_always{};<br/>    if (!awaiter.await_ready()) {<br/>        awaiter.await_suspend(std::coroutine_handle&lt;&gt; p); <br/>        // compiler added suspend/resume hook<br/>    }<br/>    awaiter.await_resume();<br/>}</span></pre><ul class=""><li id="42c8" class="me mf in jx b jy jz kc kd kg mg kk mh ko mi ks mj mk ml mm bi translated">这是你的编译器用<a class="ae kt" href="http://www.vishalchovatiya.com/coroutine-in-c-language/" rel="noopener ugc nofollow" target="_blank">上下文切换 API</a>向你的代码添加秘密调料的地方。如果你已经通读了我之前的帖子<a class="ae kt" href="http://www.vishalchovatiya.com/coroutine-in-c-language/" rel="noopener ugc nofollow" target="_blank">C 语言的协程</a>，我想剩下的就很容易想象了。</li></ul><h1 id="68f6" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">协程相关关键字的编译器转换</h1><pre class="ma mb mc md gt nc mw nd ne aw nf bi"><span id="6bba" class="ng lc in mw b gy nh ni l nj nk">co_return x;</span><span id="7925" class="ng lc in mw b gy nl ni l nj nk">// transforms into</span><span id="aa20" class="ng lc in mw b gy nl ni l nj nk">__promise.return_value(x);<br/>goto __final_suspend_label;</span><span id="e5e5" class="ng lc in mw b gy nl ni l nj nk">co_await y;</span><span id="83f3" class="ng lc in mw b gy nl ni l nj nk">// transforms into</span><span id="ca2c" class="ng lc in mw b gy nl ni l nj nk">auto&amp;&amp; __awaitable = y;<br/>if (__awaitable.await_ready()) {<br/>    __awaitable.await_suspend();<br/>    // ...suspend/resume point...<br/>}<br/>__awaitable.await_resume();</span><span id="48a0" class="ng lc in mw b gy nl ni l nj nk">co_yield z;</span><span id="2799" class="ng lc in mw b gy nl ni l nj nk">// transforms into</span><span id="2ef5" class="ng lc in mw b gy nl ni l nj nk">co_await __promise.yield_value(z);</span></pre><h1 id="7058" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">常见问题临别赠言</h1><ul class=""><li id="9a79" class="me mf in jx b jy mn kc mo kg mp kk mq ko mr ks mj mk ml mm bi translated">不仅仅是这样，还有很多事情我们还没有探索，比如异常处理、协程调用协程等等。</li><li id="043f" class="me mf in jx b jy mx kc my kg mz kk na ko nb ks mj mk ml mm bi translated">我观察到 C++20 协程的一个不寻常之处是，即使你没有从协程返回任何东西，你也必须指定返回类型。在我看来，这个协程看起来不寻常&amp;反直觉。</li></ul><p id="c63a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">无栈满协程是什么意思？</strong></p><p id="9314" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">—堆栈完整协程需要一个单独的堆栈来执行。<br/> —无堆栈协同程序使用与调用者相同的堆栈。</p><p id="ec06" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">线程间的区别&amp;协程？</strong></p><p id="88e0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">—协程是关于你的<em class="kx">编程模型</em>，线程是关于你的<em class="kx">执行模型</em>。<br/> —协同例程仍然可以在没有调度器开销的情况下进行并发处理，它只是管理上下文切换本身。<br/> —另一个好处是更低的内存使用量。在线程模型中，每个线程都需要分配自己的堆栈，因此内存使用量会随着线程数量的增加而线性增长。</p><p id="82b7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">“协程就像轻量级线程”是什么意思？</strong></p><p id="61df" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">—首先，协程和线程是不同的实体。因为协程可以是无栈的&amp;不需要操作系统的干预，所以与线程相比，它占用的内存更少，执行速度更快。对于 C++，如果你使用<a class="ae kt" href="http://www.vishalchovatiya.com/cpp20-coroutine-under-the-hood/#Hypothesis_1" rel="noopener ugc nofollow" target="_blank">假设 1 </a>，它甚至会更快。</p><p id="6810" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">C++协程怎么会是无栈的？</p><p id="ffe4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">—这个已经在<a class="ae kt" href="http://www.vishalchovatiya.com/cpp20-coroutine-under-the-hood/#Hypothesis_1" rel="noopener ugc nofollow" target="_blank">假设 1 </a>中回答了。还是再来一次。<br/> —编译器将这个动态分配的协程帧的句柄“返回”给协程的调用者。<br/> —当调用者调用<code class="fe mt mu mv mw b">std::coroutine_handle::resume()</code>方法时，将创建<code class="fe mt mu mv mw b">std::coroutine_handle::resume()</code>的堆栈帧，该堆栈帧恢复协程，同时在动态分配的协程帧上处理所有协程数据。这就是 C++中协程无堆栈的方式。因为它只在当前堆栈中执行。而不是单独的协程堆栈。</p></div></div>    
</body>
</html>