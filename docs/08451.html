<html>
<head>
<title>Elementary operations in PyCUDA</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">PyCUDA 中的基本运算</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/elementary-operations-in-pycuda-5cb8d0b72161?source=collection_archive---------11-----------------------#2022-06-15">https://blog.devgenius.io/elementary-operations-in-pycuda-5cb8d0b72161?source=collection_archive---------11-----------------------#2022-06-15</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/ff967817b9496045c8a03e1ab67c4f0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*JtWpDuwNRLWY1EtP.jpg"/></div></div></figure><p id="4337" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">PyCUDA 是一个 Python 编程环境，提供对 NVIDIA 的 CUDA 并行计算 API 的直接访问。它既可以在 python 计算流程中插入手工制作的 CUDA 内核，也可以通过跳过 CUDA 内核的编程细节并使用高级 python 编程风格来执行操作。</p><p id="71b6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">具体来说，PyCUDA 提供了一种非常简单的方法来执行数组/矩阵初始化，而无需使用 CUDA 内核、CPU/GPU 内存移动以及数学运算，并且它可以轻松地推导出感兴趣的数组/矩阵的信息，从而简化您的编程工作。</p><p id="fbd0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">尽管如此，当你使用这些工具时，要考虑到简单是有代价的，所以不要忘记阅读文章末尾的免责声明。</p><p id="584b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们看看 PyCUDA 中基本操作的一些相关特性。更多信息可以从 PyCUDA 的 GPU 阵列中获得。这篇文章的目的是概述什么是一次性的，一些功能/技术细节将被跳过。</p><p id="ed35" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> CPU/GPU 内存移动</strong></p><p id="ea76" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">使用<code class="fe ku kv kw kx b">to_gpu()</code>方法可以将 numpy 数组从 CPU 转移到 GPU。与此相反，由于使用了<code class="fe ku kv kw kx b">get()</code>方法，可以将一个数组从 GPU 移动到 CPU。在下面的示例中，在 CPU 上创建了一个 numpy 数组，将其复制到 GPU，然后在新的数组中移动回 CPU。</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="147b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">阵列/矩阵初始化</strong></p><p id="78d4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">数组/矩阵初始化的语法类似于 numpy-work，在某些方面，它类似于 Matlab 的语法。</p><p id="7b47" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">要在 GPU 上初始化一个数组，我们有以下几种可能:<code class="fe ku kv kw kx b">pycuda.gpuarray.empty</code>和<code class="fe ku kv kw kx b">pycuda.gpuarray.zeros</code>，它们分别创建一个空数组和一个填充零的数组，将它们的维度指定为<code class="fe ku kv kw kx b">shape</code>，类型指定为<code class="fe ku kv kw kx b">dtype</code>。</p><p id="a4a4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">或者，我们也可以使用<code class="fe ku kv kw kx b">pycuda.gpuarray.empty_like</code>、<code class="fe ku kv kw kx b">pycuda.gpuarray.zeros_like</code>和<code class="fe ku kv kw kx b">pycuda.gpuarray.ones_like</code>，通过从一个已经定义的对象继承属性，分别生成一个空数组、一个零填充数组和一个一填充数组。通过这三个函数，程序员仍然有可能通过<code class="fe ku kv kw kx b">dtype</code>相对于数组已被建模的对象改变类型。</p><p id="1ebc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe ku kv kw kx b">pycuda.gpuarray.arange</code>函数也是可用的，它创建了一个数组，其中填充了以某个<code class="fe ku kv kw kx b">step</code>间隔开的数字，从初始数字<code class="fe ku kv kw kx b">start</code>开始，到最终数字<code class="fe ku kv kw kx b">stop</code>结束。</p><p id="6ae5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后，我们提到了用指定的数字填充整个数组的<code class="fe ku kv kw kx b">fill</code>方法。</p><p id="e2dc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下面是提到的可能性的完整示例:</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="683e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">基本的和复杂的数学运算</strong></p><p id="8539" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">尤其有用的是元素式操作。例如，我们可以从由<code class="fe ku kv kw kx b">pycuda.gpuarray.zeros</code>设置的<code class="fe ku kv kw kx b">0</code>数组中创建一个<code class="fe ku kv kw kx b">1</code>数组，并对一个标量求和:</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="83f7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">或者，我们可以从两个数组开始创建一个复数数组，一组用于幅度，一组用于相位:</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="05fa" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这种情况下，如果我们也想提取实部和虚部，我们可以使用<code class="fe ku kv kw kx b">real</code>和<code class="fe ku kv kw kx b">imag</code>方法，或者，如果我们想计算复共轭，我们可以使用<code class="fe ku kv kw kx b">conj()</code>或<code class="fe ku kv kw kx b">conjugate()</code>方法:</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="aa9d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">应该注意的是，<code class="fe ku kv kw kx b">conj</code>的自变量代表将操作的输出分配给的数组。如果没有指定这样的参数，那么输出被分配给一个新分配的数组。相反，如果<code class="fe ku kv kw kx b">conj</code>的自变量与执行运算的数组一致，则复共轭就地发生。</p><p id="c5af" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">不过，我们可以使用<code class="fe ku kv kw kx b">__pow__</code>方法计算实数或复数的幂:</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="bcf1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">或者使用<code class="fe ku kv kw kx b">__abs__</code>方法计算绝对值:</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="c464" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">PyCUDA 还公开了由<code class="fe ku kv kw kx b">pycuda.cumath.sin</code>、<code class="fe ku kv kw kx b">pycuda.cumath.cos</code>、<code class="fe ku kv kw kx b">pycuda.cumath.tan</code>、<code class="fe ku kv kw kx b">pycuda.cumath.sinh</code>、<code class="fe ku kv kw kx b">pycuda.cumath.cosh</code>和<code class="fe ku kv kw kx b">pycuda.cumath.tanh</code>实现的复杂数组上的三角和双曲三角元素运算，以及其他基本数学运算，如<code class="fe ku kv kw kx b">pycuda.cumath.exp</code>、<code class="fe ku kv kw kx b">pycuda.cumath.log</code>和<code class="fe ku kv kw kx b">pycuda.cumath.sqrt</code>:</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="eff2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">相反，其他操作是在实数组上定义的。它们包括<code class="fe ku kv kw kx b">pycuda.cumath.asin</code>、<code class="fe ku kv kw kx b">pycuda.cumath.acos</code>、<code class="fe ku kv kw kx b">pycuda.cumath.atan</code>、<code class="fe ku kv kw kx b">pycuda.cumath.log10</code>、<code class="fe ku kv kw kx b">pycuda.cumath.fabs</code>、<code class="fe ku kv kw kx b">pycuda.cumath.ceil</code>和<code class="fe ku kv kw kx b">pycuda.cumath.floor</code>:</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="87a3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">条件运算</strong></p><p id="6034" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">元素条件操作表示非常有用的操作，可以一个元素一个元素地执行，<code class="fe ku kv kw kx b">if...then...else</code>条件或元素最大值或最小值。具体来说，PyCUDA 公开了<code class="fe ku kv kw kx b">pycuda.gpuarray.if_positive</code>，它根据特定的条件选择第一个数组或另一个数组的元素。下面是一个例子:</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="61d2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">阵列加扰</strong></p><p id="3818" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">由于<code class="fe ku kv kw kx b">pycuda.gpuarray.take</code>，也可以根据一组或一个子集的索引对数组进行重新排序:</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="b964" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">铸造和形状处理</strong></p><p id="2a9d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对数组的类型和形状的操作可以通过用于类型转换的<code class="fe ku kv kw kx b">astype</code>或通过改变数组形状的<code class="fe ku kv kw kx b">reshape</code>、展平数组的<code class="fe ku kv kw kx b">ravel</code>和删除长度尺寸的<code class="fe ku kv kw kx b">1</code>来实现。</p><p id="6aca" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">作为铅字铸造的例子报道如下:</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="f48c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">此外，<code class="fe ku kv kw kx b">reshape</code>可以如下使用:</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="ddf0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">而<code class="fe ku kv kw kx b">ravel</code>为:</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="747d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后，这里有一个使用<code class="fe ku kv kw kx b">squeeze</code>的例子:</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="edd0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">削减量</strong></p><p id="b94e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">PyCUDA 能够以非常简单的方式执行归约操作。实现的归约操作有 sum ( <code class="fe ku kv kw kx b">pycuda.gpuarray.sum</code>)、max ( <code class="fe ku kv kw kx b">pycuda.gpuarray.max</code>)、min ( <code class="fe ku kv kw kx b">pycuda.gpuarray.min</code>)和 dot ( <code class="fe ku kv kw kx b">pycuda.gpuarray.dot</code>)，后者为<em class="le">非埃尔米特</em>。子集阵列的减少也是可以预见的。这里有一个例子:</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="37f9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">其他有用的浮点运算</strong></p><p id="2d10" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">还有其他有用的浮点运算可用。它们包括返回两个数组除法的浮点余数的<code class="fe ku kv kw kx b">pycuda.cumath.fmod</code>和返回数组的(fractional_part，integer_part)元组的<code class="fe ku kv kw kx b">pycuda.cumath.modf</code>:</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="7b2a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">阵列信息</strong></p><p id="20a3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">PyCUDA 还提供了返回 GPU 阵列即时信息的方法。这些是:</p><ul class=""><li id="97a8" class="lf lg in jx b jy jz kc kd kg lh kk li ko lj ks lk ll lm ln bi translated"><code class="fe ku kv kw kx b">shape</code>:相当于 Matlab 的大小；</li><li id="7d33" class="lf lg in jx b jy lo kc lp kg lq kk lr ko ls ks lk ll lm ln bi translated"><code class="fe ku kv kw kx b">dtype</code>:返回存储元素的类型；</li><li id="7aa9" class="lf lg in jx b jy lo kc lp kg lq kk lr ko ls ks lk ll lm ln bi translated"><code class="fe ku kv kw kx b">size</code>:元素总数；</li><li id="3727" class="lf lg in jx b jy lo kc lp kg lq kk lr ko ls ks lk ll lm ln bi translated"><code class="fe ku kv kw kx b">mem_size</code>:包括可能填充的元素总数；</li><li id="ff38" class="lf lg in jx b jy lo kc lp kg lq kk lr ko ls ks lk ll lm ln bi translated"><code class="fe ku kv kw kx b">nbytes</code>:数组占用的字节数；</li><li id="c3d7" class="lf lg in jx b jy lo kc lp kg lq kk lr ko ls ks lk ll lm ln bi translated"><code class="fe ku kv kw kx b">strides</code>:包含跨越每个维度的字节数的元组；对于二维矩阵，第一个数字是下一行要遍历的字节数，而第二个数字是下一列要遍历的字节数；</li><li id="ea51" class="lf lg in jx b jy lo kc lp kg lq kk lr ko ls ks lk ll lm ln bi translated"><code class="fe ku kv kw kx b">ptr</code>:数组指针；</li><li id="c289" class="lf lg in jx b jy lo kc lp kg lq kk lr ko ls ks lk ll lm ln bi translated"><code class="fe ku kv kw kx b">flags.c_contiguous</code>:行主排序为真；</li><li id="411e" class="lf lg in jx b jy lo kc lp kg lq kk lr ko ls ks lk ll lm ln bi translated"><code class="fe ku kv kw kx b">flags.f_contiguous</code>:列专业排序为真；</li><li id="a84a" class="lf lg in jx b jy lo kc lp kg lq kk lr ko ls ks lk ll lm ln bi translated"><code class="fe ku kv kw kx b">flags.forc</code>:适用于任何订单；</li><li id="b49c" class="lf lg in jx b jy lo kc lp kg lq kk lr ko ls ks lk ll lm ln bi translated"><code class="fe ku kv kw kx b">__cuda_array_interface__</code>:返回包含数组信息的结构。</li></ul><p id="8c88" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后，甚至可以在 GPU 阵列上直接使用<code class="fe ku kv kw kx b">print</code>来可视化子阵列的内容。</p><p id="95cf" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下面是一个例子:</p><figure class="ky kz la lb gt jo"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="7bf6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">免责声明</strong></p><p id="1dfd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在 PyCUDA 中执行数组之间的操作非常简单，因为通常可以使用自然的数学语法。PyCUDA 将代表美国开发用于 GPU 执行的 CUDA 内核。然而，虽然这使编程变得简单，但并不总是高效的。必须记住，启动 CUDA 内核是昂贵的，良好的编程实践是尽可能将操作整合到单个内核中，以减少启动次数并利用操作的中间结果。</p><p id="53d7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">PyCUDA 是一个很好的工具，可以轻松获得 GPU 的速度。然而，只有手工操作才能实现最佳性能。</p><p id="dad9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> GitHub </strong></p><p id="cff5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">示例代码可在<a class="ae kt" href="https://github.com/vitalitylearning2021/PyCUDA/tree/main/elementaryOperations" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获得。</p></div></div>    
</body>
</html>