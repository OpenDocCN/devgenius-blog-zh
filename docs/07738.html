<html>
<head>
<title>Day 14 of Game Dev: How to Spawn Enemies using Coroutines in Unity!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">游戏开发的第 14 天:如何在 Unity 中使用协程产生敌人！</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/day-14-of-game-dev-how-to-spawn-enemies-using-coroutines-in-unity-b37b9b071910?source=collection_archive---------8-----------------------#2022-04-19">https://blog.devgenius.io/day-14-of-game-dev-how-to-spawn-enemies-using-coroutines-in-unity-b37b9b071910?source=collection_archive---------8-----------------------#2022-04-19</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="c2d6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">目的:</strong>设置一个<strong class="jm io">协程</strong>每 5 秒产生一个敌人。</p><p id="5fb2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae ki" href="https://docs.unity3d.com/ScriptReference/Coroutine.html" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io">协程官方统一 API</strong></a></p><p id="b8c6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">注意，老实说，我在理解一个<strong class="jm io">协程</strong>是做什么的以及如何从<strong class="jm io"> API </strong>中使用它时遇到了一些麻烦，所以我会推荐一些 YouTube 视频或一些可能对你更好的东西。大多数情况下,<strong class="jm io"> Unity API </strong>很容易理解，但是请记住,<strong class="jm io"> Unity </strong>上有大量的资源！</p><p id="dba2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在我的 2D 银河射击游戏中，我想每 5 秒钟产生一个敌人。在实际设置<strong class="jm io">协程</strong>代码之前，我想做一些事情。如果您只想要<strong class="jm io">协程</strong>代码，那么现在跳到粗体标题为“<strong class="jm io">设置协程代码！”</strong></p><p id="6fc1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们考虑一下。如果我需要一些代码来管理正在繁殖的敌人，我需要这些代码吗？在播放器上？在敌人身上？</p><p id="9c60" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">好吧，<strong class="jm io"> OOP </strong> ( <strong class="jm io">面向对象编程</strong>)的一个最佳实践是使用一个编程模型<strong class="jm io"> C# </strong>使你的所有脚本模块化，这意味着每个脚本服务于一个目的。因此<strong class="jm io">玩家脚本</strong>处理与玩家相关的一切，而<strong class="jm io">敌人脚本</strong>处理与敌人相关的一切，仅此而已。将代码模块化的做法使得阅读、调试等变得更加容易，因为一切都更有条理。如果播放器有问题，你不必去看每个脚本，因为你知道所有与播放器相关的代码都在<strong class="jm io">播放器脚本</strong>中。请记住，这是一个最佳实践，但并不总是 100%可以实现，因为不同的脚本会相互引用，并且可能会出现其他特定的情况，但这确实比什么都不做更有条理。</p><p id="a724" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">回到我们可能希望产卵代码被设置的地方:如果这个产卵代码被连接到一个特定的敌人，那么我们实际上只能在敌人在场景中的时候从那个脚本中调用任何东西。也就是说，如果我们杀死了一个有产卵脚本的敌人，代码就不能被调用了。将代码放入<strong class="jm io">播放器</strong>或<strong class="jm io">敌人脚本</strong>中是没有意义的。</p><p id="58bf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">请记住，从<strong class="jm io"> MonoBehaviour </strong>继承的脚本只有在附加到场景中的游戏对象时才能工作或调用它的任何代码。</p><p id="325c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果我们做一个不会被破坏的空游戏对象，在这个对象上放一个新的脚本，代码是用来繁殖敌人的，会怎么样？然后，我们都实现了一种模块化的设置方法，因为只有该脚本将负责管理游戏对象(在这种情况下是敌人)的生成，并且由于空的游戏对象将始终在场景中，它还将处理我们之前遇到的问题，即场景中的什么对象需要附加脚本。</p><p id="edf9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因为这种产生游戏对象的方法在 Unity 中很常见，所以我会走这条路，做一个空的游戏对象<strong class="jm io"/>，并把它叫做<strong class="jm io"> SpawnManager </strong>。我还将创建一个名为<strong class="jm io"> SpawnManager </strong>的脚本，并将该脚本附加到<strong class="jm io">空游戏对象</strong>。为了便于组织，我将把现在称为<strong class="jm io"> SpawnManager </strong>的空游戏对象设置为场景中的 0，0，0 位置。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi kj"><img src="../Images/cbf5c5a3d32e4f641296587b2a496011.png" data-original-src="https://miro.medium.com/v2/resize:fit:1086/1*6wo8z5DnNHKMsKJO8Y1KIA.gif"/></div></figure><p id="86dc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">现在进入设置协程代码！</strong></p><p id="922f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在<strong class="jm io"> SpawnManager </strong>脚本中，我需要创建一个类型为<strong class="jm io"> IEnumerator() </strong>的方法，我将其命名为<strong class="jm io"> SpawnEnemies() </strong>。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi kr"><img src="../Images/4bbff6bc8bfb4f8c0e8e3677dea52749.png" data-original-src="https://miro.medium.com/v2/resize:fit:526/format:webp/1*PWxj9EtLKQHAfRvet3wZaA.png"/></div></figure><p id="81c7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在<strong class="jm io"> SpawnEnemies() </strong>方法中，我想设置一个“<strong class="jm io"> while 循环</strong>”。因此，如果一个条件为真，那么一个"<strong class="jm io"> if 语句</strong>"调用一些代码，但是当一个条件为真时，一个"<strong class="jm io"> while 循环</strong>"调用代码。这使得<strong class="jm io"> while 循环</strong>更适合倒计时或数字之类的东西，因为它更容易阅读，而且就是为此而设计的。</p><p id="2db5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">小心，你可能会意外地制造一个无限循环，导致<strong class="jm io"> Unity </strong>崩溃。在使用<strong class="jm io"> while 循环</strong>之前，确保查看<strong class="jm io"> while 循环</strong>以及什么是无限循环。你需要设置一个<strong class="jm io"> while 循环</strong>来离开或结束循环，这样就不会使<strong class="jm io"> Unity </strong>或你的应用程序崩溃。</p><p id="18fb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这种情况下，由于<strong class="jm io"> while 循环</strong>嵌套在<strong class="jm io">协程</strong>内，我们可以使<strong class="jm io"> while 循环</strong>成为一个“无限”循环，因为它的条件总是真。虽然这通常会导致崩溃，如果<strong class="jm io"> while 循环</strong>在这个<strong class="jm io">协程之外，</strong>因为它在<strong class="jm io">协程</strong>之内。这是因为无论<strong class="jm io"> while 循环</strong>是否嵌套在<strong class="jm io">协程</strong>中，都需要<strong class="jm io"> </strong>一个<strong class="jm io"> yield 语句</strong>。这意味着你必须时常停止<strong class="jm io">协程</strong>，使得<strong class="jm io"> while 循环</strong>也停止，因为它嵌套在<strong class="jm io">协程</strong>中。</p><p id="72ea" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当你学习如何使用一个<strong class="jm io">协程</strong>时，你会更明白我的意思，所以不要紧张。</p><p id="cc10" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">那么我想让循环做什么呢？我想让它每 5 秒产生一个敌人。我将使用<strong class="jm io"> Instantiate() </strong>来生成它们，在生成 1 之后，我将放入一个<strong class="jm io">协程</strong>需要的<strong class="jm io">产出语句</strong>。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi ks"><img src="../Images/1efb82f9385e767118caf79e825e76e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1234/1*S3j6BwxplU-OqDyI66-Jfw.gif"/></div></figure><p id="e871" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">正如你可能注意到的，在那个<strong class="jm io"> WaitForSeconds()方法</strong>中，我加入了 5，因为我想每 5 秒钟产生一个新的敌人。<strong class="jm io">yield return new WaitForSeconds()</strong>是我刚才说的<strong class="jm io"> yield 语句</strong>，它的基本意思是在那一行停止代码，等待 5 秒钟再调用它。</p><p id="13b0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最后，我们实际上不得不称这个<strong class="jm io">为协程</strong>。到目前为止，它只是一个从未被调用过的方法。因为我不想每一帧都启动这个<strong class="jm io">协程</strong>，所以我不会从<strong class="jm io"> Update() </strong>中调用<strong class="jm io"> SpawnEnemies() </strong>。我将从<strong class="jm io"> Start() </strong>开始调用它。</p><p id="81eb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">调用<strong class="jm io">协程</strong>有不同的语法方式，但我将使用的方式和我见过的大多数开发人员使用的方式是这样的:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi kt"><img src="../Images/33d70c20ba9597ff10331591a42f0afd.png" data-original-src="https://miro.medium.com/v2/resize:fit:686/1*bb20IH9_nNSlHUZ_yfov_g.gif"/></div></figure><p id="e183" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我使用<strong class="jm io"> StartCoroutine() </strong>方法调用了我想要的特定<strong class="jm io">协同程序</strong>(在一个项目中很可能有多个)。</p><p id="fcac" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当游戏开始时，将调用<strong class="jm io">协程</strong>并运行方法中的所有代码，包括实例化一个敌人，让步 5 秒并重新开始。</p><p id="1d3d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我将为这个产卵特性添加更多的东西，比如在 while 循环中停止产卵的条件，但是当涉及到<strong class="jm io">协程</strong>时，几乎涵盖了如何使用、生成和调用一个！有许多变化和情况可以设置一个<strong class="jm io">协程</strong>，但这应该让你开始！</p><p id="6313" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">我希望这能帮到你，有什么问题尽管问！</strong></p></div></div>    
</body>
</html>