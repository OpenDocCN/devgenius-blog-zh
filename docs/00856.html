<html>
<head>
<title>C Programming Hacks 01: Memory Efficient Struct Design</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">c 编程技巧 01:内存高效的结构设计</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/c-programming-hacks-01-memory-efficient-struct-design-8e7252c2b986?source=collection_archive---------2-----------------------#2020-06-18">https://blog.devgenius.io/c-programming-hacks-01-memory-efficient-struct-design-8e7252c2b986?source=collection_archive---------2-----------------------#2020-06-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b9a0" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在 C 语言中声明结构时应该避免的一个常见错误</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/22fd766eb578b5ba3485d1d099de6bd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-5fh5IJxZq0oTH2Y"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@ricaros?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">丹尼尔·里卡洛斯</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="2ab2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们经常在 C 中声明和使用结构(或 structs ),主要是因为它在处理数据方面提供了灵活性。<a class="ae kv" href="http://www2.cs.uregina.ca/~hilder/cs833/Other%20Reference%20Materials/The%20C%20Programming%20Language.pdf" rel="noopener ugc nofollow" target="_blank"><em class="ls">Kernighan 的 C 编程语言&amp; Ritchie </em> </a> <em class="ls"> </em>将结构定义为:</p><blockquote class="lt lu lv"><p id="b965" class="kw kx ls ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">结构是一个或多个变量的集合，这些变量可能是不同类型的，为了处理方便，它们被组合在一个名字下</p></blockquote><p id="956c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我们的重点不是如何定义、声明和初始化结构。如果您已经熟悉了结构，并且有兴趣学习如何以高效的方式使用它们，那么您已经找到了合适的文章。让我们开始讨论吧！！</p><p id="0166" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">考虑下面的结构。</p><pre class="kg kh ki kj gt lz ma mb mc aw md bi"><span id="a78f" class="me mf iq ma b gy mg mh l mi mj"><strong class="ma ir">struct </strong>Node1 {<br/>    uint8_t num1;<br/>    uint64_t num2;<br/>    uint8_t num3;<br/>} node1;</span></pre><p id="b738" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你期望节点 1 的大小是多少？10 字节(1 + 8 + 1)，小学数学！！！可惜这个<strong class="ky ir">错了</strong>。</p><pre class="kg kh ki kj gt lz ma mb mc aw md bi"><span id="1e09" class="me mf iq ma b gy mg mh l mi mj">printf("Size of node1: %zu \n", <strong class="ma ir">sizeof</strong>(node1));</span></pre><p id="5858" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个 printf 语句显示实际大小是 24 字节(在 64 位系统中)。等一下！！！这怎么可能？？要理解这一点，我们首先应该了解内存对齐和填充是如何工作的。</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="17dc" class="mr mf iq bd ms mt mu mv mw mx my mz na jw nb jx nc jz nd ka ne kc nf kd ng nh bi translated"><strong class="ak">对齐和填充</strong></h1><p id="38e5" class="pw-post-body-paragraph kw kx iq ky b kz ni jr lb lc nj ju le lf nk lh li lj nl ll lm ln nm lp lq lr ij bi translated">处理器在一条指令中获取和处理的数据量称为“字长”。简单地说，处理器将一次读取一个单词。在 32 位系统中，字长为 32 位(4 字节)，类似地，在 64 位系统中，字长为 64 位(8 字节)。我们将在 64 位系统的基础上进行余下的讨论。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nn"><img src="../Images/84a71a6dd322d31a6ac992214d135b0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fpBLpO2_a1syR3Ef1CWZbw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">图 1: 24 字节内存</figcaption></figure><p id="78da" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看一下图 1。每个方块代表 1 个字节的内存。为简单起见，内存地址命名为 0–23。由于我们处理的是 64 位系统，处理器将一起读取内存位置 0–7(蓝色段)，一起读取 8–15(黄色段)，一起读取 16–23(绿色段)。假设，如果我们像这样声明一个整数:</p><pre class="kg kh ki kj gt lz ma mb mc aw md bi"><span id="b518" class="me mf iq ma b gy mg mh l mi mj">int var;</span></pre><p id="f4dd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一般来说，<code class="fe no np nq ma b">int</code>数据类型需要 32 位或 4 个字节。您可以为<code class="fe no np nq ma b">var</code>分配 0 到 23 之间的内存。一些可能性如下。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nr"><img src="../Images/da1dd61aead48e23b76816ac64d9a2d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cbVpO0cjX9wE2kfLRvglKQ.png"/></div></div></figure><p id="9a41" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里一个明显但重要的观察结果是，对齐 2、3 和 4 迫使处理器在两个周期内提取我们的<code class="fe no np nq ma b">var</code>(处理器应该在一个周期内提取蓝色段，在下一个周期内提取黄色段)，而对齐 1 和 5 只需要一个周期(对齐 1 只需要蓝色段，对齐 5 只需要黄色段)。因此，很明显，对齐 1 和 5 提高了效率。等等！！这和我们的问题有什么关系？</p><p id="647b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">原来系统不是随机分配内存，而是有数据对齐要求。C 语言中的变量以这样一种方式分配内存，即它们从一个是其大小倍数的内存地址开始。例如，1 字节长的<code class="fe no np nq ma b">char</code>可以从任何地方开始，2 字节长的<code class="fe no np nq ma b">short</code>应该从 2 的倍数的存储器地址开始，4 字节长的<code class="fe no np nq ma b">int</code>应该从 4 的倍数的存储器地址开始，等等。如果考虑对齐 1 和 5，分配的内存从 4 和 8 开始，它们是 4 的倍数。</p><p id="e301" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们必须了解什么是填充，为什么需要它以及它是如何工作的。现在我们知道内存分配有一个对齐要求。为了确保这种对齐要求，系统使用填充。填充只是插入空字节(有时让它们为空)。如果我们回到我们的<code class="fe no np nq ma b">struct Node1</code>例子，</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ns"><img src="../Images/c69ebdf34a865842fd6bef95850fd7bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ift1H3JjO2eb4JXltuGS-w.png"/></div></div></figure><p id="1b44" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是实际内存分配的样子。更清楚地说，如果我们看一下我们的<code class="fe no np nq ma b">struct</code>声明，实际发生的是，</p><pre class="kg kh ki kj gt lz ma mb mc aw md bi"><span id="67e0" class="me mf iq ma b gy mg mh l mi mj"><strong class="ma ir">struct </strong>Node1 {<br/>    uint8_t num1;<br/>    <strong class="ma ir">char </strong>padding[7];     //padding<br/>    uint64_t num2;<br/>    uint8_t num3;<br/>    <strong class="ma ir">char </strong>padding[7];     //padding<br/>}</span></pre><p id="6bcb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是它消耗 24 字节内存而不是 10 字节内存的原因。</p><p id="213e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，我们可以解决这个问题，将消耗的内存从 24 字节减少到 16 字节。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/4934689a53ca38e894c8ea085dd4ae93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p8EijWONGrAs4912J43cnw.png"/></div></div></figure><pre class="kg kh ki kj gt lz ma mb mc aw md bi"><span id="ba30" class="me mf iq ma b gy mg mh l mi mj"><strong class="ma ir">struct </strong>Node1 {<br/>    uint8_t num1;<br/>    uint8_t num3;<br/>    <strong class="ma ir">char </strong>padding[6];<br/>    uint64_t num2;<br/>}</span></pre><p id="5f6d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个例子中，我们只节省了一个字节，与这个时代的典型机器的可用内存量(通常包含千兆字节的内存)相比，这是微不足道的。但是，当结构有大量变量和/或创建大量结构变量时，可以节省大量内存。此外，并非所有系统都有千兆字节的内存。尤其是使用嵌入式系统的人，不得不用很少的内存来管理。我将在另一篇文章中讨论这种应用。</p><p id="9eb2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">希望这篇文章有帮助！！！</p></div></div>    
</body>
</html>