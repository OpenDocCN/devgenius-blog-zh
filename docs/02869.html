<html>
<head>
<title>Develop Scalable &amp; Maintainable React JS Application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">开发可扩展和可维护的 React JS 应用程序</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/develop-scalable-maintainable-react-js-application-dac56192e111?source=collection_archive---------8-----------------------#2020-09-06">https://blog.devgenius.io/develop-scalable-maintainable-react-js-application-dac56192e111?source=collection_archive---------8-----------------------#2020-09-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/1ac29aa558d277630164c6aadc586158.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HYbaU0OAKCu3c-wu"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@clemhlrdt?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">克莱门特·H</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="7daa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">大约两年前，我开始开发 React 应用程序。这一切都是从一个经典的 todo 应用程序开始的，很快又出现了另一个经典的基于网络的天气应用程序。很快我意识到为什么 React 越来越受欢迎，我开始喜欢它的简单。</p><p id="279d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从那以后，我使用 React JS 开发了十几个 web 应用程序。从探索框架不同方面的宠物项目到拥有近百万日常用户的更复杂的应用程序，我使用 React 开发各种规模的项目。</p><p id="8466" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不管项目的规模有多大，总有一套实践可以确保应用程序经得起时间的考验，并且随着时间的推移很容易扩展和维护。在本文中，我将介绍这些良好的实践。</p><h1 id="56d1" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">具有单一职责的组件</h1><p id="457c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">每个 React 组件应该只有一个责任。</p><p id="62d3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这使得组件非常模块化，并有助于保持代码库干燥。保持组件的模块化使您能够将较小的组件组合成较大的组件。它还让您在整个应用程序中保持 UI 的一致性。</p><p id="a1c0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，表单中的输入字段、行动号召按钮、横幅、标题等可以有单独的组件。在应用程序的不同部分，您可以重用这些组件，保持整个应用程序的独特和有意识的感觉。</p><p id="92b8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">单一责任组件也非常容易测试。副作用很少甚至没有。您可以单独测试它们的功能。随着应用程序的增长，这变得非常重要。在实现新特性时，很容易开始膨胀组件。这使得组件与特性的耦合非常紧密，并且随着时间的推移，事情变得越来越复杂，难以进行可靠的测试。</p><p id="fd5d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">设计具有单一职责的组件也使得代码库更容易阅读。这使您可以更精确地命名组件。理解每个组件实际上在做什么变得非常容易，这反过来让您可以用更少的努力来构建更大的组件。</p><h1 id="de8a" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">独立的逻辑和表示组件</h1><p id="b4fd" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">分离逻辑和表示组件降低了代码库的整体复杂性。</p><p id="b116" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">逻辑组件包含所有复杂的业务逻辑和状态管理。它们从外部 API 检索数据，并将数据发送到数据库或任何其他外部服务。逻辑组件与正确执行业务逻辑和管理状态有关。他们不担心渲染什么，怎么渲染。</p><p id="0a38" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一方面，表示组件只负责在屏幕上正确地呈现 UI 元素。他们通过 props 接收必须呈现的数据，并相应地呈现出来。他们不关心<em class="me">渲染什么</em>。他们只关心<em class="me">渲染什么</em>。</p><p id="4a34" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这有助于实现单一责任。这也使您的组件更加模块化，因为您可以在表示组件之间移动，而不用担心底层的业务逻辑。每当您必须设计一个新特性时，您可以将业务逻辑隔离在它自己的组件中，然后使用现有的表示组件来显示您想要的内容。</p><p id="bee3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这给我们带来的最大好处是将业务逻辑从 UI 呈现中分离出来，这使得事情更加模块化并且更容易测试。</p><h1 id="7857" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">全局状态管理</h1><p id="31fa" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">全局状态管理是 React 中最热门的话题之一。有多种状态管理框架，如 Redux 和 ContextAPI。</p><p id="a308" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">然而，这并不意味着您必须在每个应用程序中使用状态管理工具。</strong></p><p id="2d70" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我只使用本地状态管理开发了多个复杂的应用程序。如果组件设计得很仔细，并且最终没有非常深入的测试树，那么不使用复杂的状态管理工具也可以。</p><p id="38ab" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像 Redux 或 ContextAPI 这样的工具会增加代码的复杂性。当你实现新的特性时，这使得测试变得更加困难，并且增加了开销。</p><p id="677a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，这并不意味着你不应该考虑状态管理。您应该在前进的过程中评估需求，而不是从状态管理开始。当然，您可能会遇到必须使用状态管理工具的情况。但这可以等到真正有必要的时候。否则，您最终会将状态管理工具的复杂性添加到可以轻松处理本地状态的应用程序中。</p><h1 id="b7ba" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用 PropTypes 进行类型检查</h1><p id="81d9" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">随着应用程序的增长，如果不加强组件的特性，就会有引入更多 bug 的风险。</p><p id="2ce1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可以用 React 的原生<code class="fe mf mg mh mi b">PropTypes</code>来做到这一点。</p><p id="1cbe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于组件的每一个属性，您可以强制执行从类型到是否需要到一些基本验证的所有内容。以下是一些重要的强制措施:</p><ul class=""><li id="8b1d" class="mj mk iq kf b kg kh kk kl ko ml ks mm kw mn la mo mp mq mr bi translated">强制类型如<code class="fe mf mg mh mi b">PropTypes.bool</code> <code class="fe mf mg mh mi b">PropTypes.array</code></li><li id="ead1" class="mj mk iq kf b kg ms kk mt ko mu ks mv kw mw la mo mp mq mr bi translated">一个类的实例<code class="fe mf mg mh mi b">PropTypes.instanceof(Player)</code></li><li id="bed5" class="mj mk iq kf b kg ms kk mt ko mu ks mv kw mw la mo mp mq mr bi translated">枚举<code class="fe mf mg mh mi b">PropTypes.oneOf(['US', 'CA'])</code></li><li id="b6f8" class="mj mk iq kf b kg ms kk mt ko mu ks mv kw mw la mo mp mq mr bi translated">需要道具<code class="fe mf mg mh mi b">PropTypes.number.isRequired</code></li><li id="9dcf" class="mj mk iq kf b kg ms kk mt ko mu ks mv kw mw la mo mp mq mr bi translated">强制对象内的属性</li></ul><p id="2e58" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最初，描述每个道具的属性似乎很乏味，但是你以后会感谢自己的。</p><p id="020b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">给你。这些是您可以用来更好地维护和扩展 React 应用程序的一些良好实践。在你了解这些实践之后，马上实施它们并不容易。这需要时间和实践，但是随着时间的推移，你会越来越好地设计基于这些基本实践的 react 应用程序。</p></div></div>    
</body>
</html>