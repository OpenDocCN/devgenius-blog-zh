# 高级 C# —通用 SQL 表结构

> 原文：<https://blog.devgenius.io/advanced-c-common-sql-table-structures-bb7f7149b887?source=collection_archive---------4----------------------->

*并构建一个框架来使用它们*

![](img/1f6c7d4ad5e017c0cc6c49c7bd8be9da.png)

由 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上 [Ruchindra Gunasekara](https://unsplash.com/@ruchindra?utm_source=medium&utm_medium=referral) 拍摄的照片

在本文中，我们将介绍一个经过深思熟虑的 SQL 表设计，它可以提高 C#的效率。我们将通过确保利用公共数据元素并围绕这些元素构建一个 C#框架，使用公共 SQL 语句共享代码来实现这一收益。

这篇文章将分为以下几个部分:

1.  问题陈述
2.  模型设计
3.  表格结构和设计
4.  属性用法
5.  服务定义
6.  基本的添加和获取实现
7.  SQL 语句构建器框架
8.  高级搜索

我们开始吧！

> **注意**:这个项目我们需要两个 NuGet 包: [Dapper](https://www.nuget.org/packages/Dapper/) 和 [Dapper。贡献](https://www.nuget.org/packages/Dapper.Contrib/)

# 问题陈述

我们的目标是建立一个简单的库存系统。然而，我们想要一个通用的库存系统，一个允许对项目进行分类和添加自定义属性的系统。类别本身可以有类别和属性。这提供了一种向客户实现添加一些层次结构的方法，并在某些场景中利用类别作为“标签”。

我们将只创建两个模型:类别和产品(但是可以创建更多)。我们希望利用相同的底层存储库类，并尽可能多地重用 SQL 和代码。为了使与 SQL 的交互更容易一些，我们将利用 [Dapper](https://github.com/DapperLib/Dapper) micro-ORM 的 CRUD 功能和语法优势来执行 SQL。

# 模型设计

最重要的是。让我们用 C#设计我们的数据模型。

## 基本实例

我们希望每个实例都有一个公共的信息子集。一个通用的模型将允许我们创建一个通用的表结构并构建一个高效的系统。让我们使用下面的类作为我们系统中所有实体的基础。

这个模型相当简单:

*   **InstanceId** :实体的标识符
*   **名称**:实体的唯一名称
*   **描述**:实体的可选描述
*   **SystemOwned** :一个标志，指示这个实例是属于我们的代码还是用户定义的(对于在我们的结构上构建模块很有用)
*   **类别**:实例的关联类别
*   **CreatedTimestamp** :实体第一次创建的时间
*   **CustomAttributes** :与该实例相关联的任何自定义属性。

您会注意到这个模型的一些属性，这些属性在将来会变得很方便。这些是 Dapper 专有的，允许我们在 Dapper 中使用内置的 CRUD 方法。`[Key]`用于定义系统的主键，而`[Computed]`表示我们不应该在更新时包含该属性(参见 [Dapper。Contrib](https://github.com/DapperLib/Dapper.Contrib) )。

接下来我们将继续定义`CategoryCollection`，

为了简单起见，我在这段代码中省略了一些实现细节(比如`IEquatable`和`Equals` / `GetHasCode()`实现)。这个类的目的是保存与实例相关联的类别。

我们还应该定义`CustomAttributes`，

同样，省略了许多通常在生产中使用的助手函数和覆盖。

现在我们有了基线，让我们创建我们特定的数据模型。

## 类别实例

一个类别可以作为我们系统中任何实体的“标签”。类别本身也可以应用“标签”。这为我们如何构建更高层次的库存系统提供了很大的灵活性。例如，我们可能有不同类型的产品:库存、原材料或组装产品。每一个都是 Category 的一个单独的实例。

然而，我们也可以使用类别来告诉系统一组更具层次结构的产品。例如，如果我们出售交易卡(像神奇宝贝)会怎么样。神奇宝贝是游戏，但是卡牌被分解成游戏集(XY，双重危机等)。在这种情况下，一个单独的卡片(一个产品)可能有两个类别:神奇宝贝(游戏)和双重危机(游戏集)。然后游戏集《双重危机》会有一个神奇宝贝的类别，给我们一个卡片游戏的链接。

这种类型的结构对于许多类型的库存系统来说是非常灵活的。

## 产品实例

产品被定义为可以被盘点和跟踪的实体。像类别一样，它可以有关联的“标签”和自定义属性。但是，我们将添加两个额外的属性，这两个属性对于我们的产品类型来说更加具体一些:`ProductImageUris`和`ValidSkus`。这些用于系统的其他部分，用于特定的客户案例。

这些附加属性被设计为字符串的集合。让我们展示这个定义，

> `StringCollection`、`CustomAttributes`和`CategoryCollection`可以很容易地成为`List<string>`、`Dictionary<string, string>`和`List<CategoryCollectionEntry>`，但是这些类型并没有表达类型的意图。意图在阅读代码时很有帮助。另外，我们希望这些类型成为我们 Dapper 设置中的目标。

# 表格结构和设计

现在我们有了模型，让我们创建我们的表。每个实体都需要一组三个表:实例表、类别表和属性表。这些表的核心结构实际上是相同的。

## 类别实例

实例表

类别表

属性表

最后两个表是一组标准的链接表，其中每个类别可以有任意数量的其他类别。每个类别可以有任意数量的自定义属性。主键用于提供链接表的唯一性。

## 产品实例

实例表

类别表

属性表

这些表格之间有一些不同之处。

1.  产品的名称不需要是唯一的。通过经验，产品可以有相同的名称，但有不同的制造商。
2.  产品在类型为`VARCHAR(MAX)`的表格中有附加属性。我通常不会在设计中容忍这种情况，但是对于我们的用例来说，这是可行的。

> 应该注意的是，我们在本文中使用 SQL Server 来根据提供的数据拒绝插入。例如，如果您试图创建一个同名的类别，SQL 将拒绝它。然而，对于产品来说，它不会。

## 用户定义的表类型

为了有效地将这些信息输入到系统中，我们将需要 SQL Server 中的两个 UDTT。特别是，我们将想要上传`CategoryCollection`和`CustomAttributes`的数据。

> 参见我的文章[高级 C# — SQL Server 批量上传](/advanced-c-sql-server-bulk-upload-57ad6be6e6a1)获得更详细的解释。

用于上传自定义属性的自定义属性列表 UDTT

用于上载 CategoryCollection 的整数列表 UDTT

有了这两种类型，我们将能够用一条`INSERT`语句上传一个实体。

# 属性用法

我们的每个模型都有不同的关联表。是的，这些表非常相似。然而，我们需要以某种方式将这些表告知我们的存储库服务。我更喜欢让这些定义尽可能接近模型。

为此，我们将使用属性。我们将使用 Dapper 中的一个现有属性。名为`TableAttribute`的 Contrib 并创建一个名为`PropertyTableAttribute`的自定义属性。

`TableAttribute`讲述衣冠楚楚。Contrib 什么表执行 CRUD 操作(见[特殊属性](https://github.com/DapperLib/Dapper.Contrib#special-attributes))。默认情况下，表名将是被复数化的实体的名称。然而，我们正在使用模式，我们需要通过使用这个属性来定制匹配。

第二个属性`PropertyTableAttribute`用于为类别和定制属性定义其他表。

然后，我们将根据我们创建的表，用这些属性来修饰我们的每个模型。

# 服务定义

现在我们已经定义了我们的模型和表，是时候定义我们的服务了。

## 服务接口

存储库接口将被称为`IInstanceRepository`。除了`AddAsync`、`GetAsync`和`FindAsync`之外，我们将省略所有其他 CRUD 操作。

接口定义

## SQL Server 实现

我们将使用 SQL Server 创建一个实现，利用 Dapper 和一个定制的`ISqlExecutor`(参见文章 [C#提示:SQL Executor 服务](/c-problem-sql-executor-service-deb459132a50)了解更多细节)。

SQL 执行器接口

SQL 执行器实现

这个班发生了很多事情。我们可以单独写一整篇文章。然而，现在最好的办法可能是学习这门课，然后向我提问。

需要注意的要点如下:

*   在构造函数中，我们提取属性并将结果存储在本地属性中。这个类应该是单例的，因此是一次性成本。
*   当编写类别和定制属性时，我们使用先前定义的 UDTT，并使用`.ToSqlParameter()`扩展生成一个定制参数(用于 Dapper)。
*   我使用了一种简化的方法来覆盖类别和自定义属性，首先删除所有相关的行，然后再将它们添加回去。这不是最好的性能，可以进一步优化。
*   在`GenerateFindQuery`方法中，我们使用一个通用的过滤查询来首先找到实例标识符。然后，我们基于这些结果执行几个`SELECT`查询，以返回多个结果集。我发现从索引的角度来看，这是非常高效的。
*   正在连接 SQL。当开发这样的代码时，我们必须非常谨慎，以确保没有用户数据在没有参数化的情况下出现在 SQL 中。

这里使用了最后一个类(还没有提到)。而这就是`InstanceReader`类。这个类用于从`Get`或`Find`查询中获取结果，并创建具体的实例。该类定义如下。

在本文中，我不会详细讨论这个类，但是为了完整起见，我想把它包括进来。

# 基本的添加和获取实现

既然我们已经为共享实例创建了核心框架，我们应该实现存储库中的功能。本节我们将只关注`AddAsync`和`GetAsync`功能。我们需要在我们的高级搜索框架中增加一些东西。

## `Task<int> AddAsync(TInstance instance)`

该功能用于将实例添加到系统中。

我们利用衣冠楚楚。Contrib 方法`InsertAsync`如其文档中所述。它自动参数化属性并将记录插入表中。为了使这一工作如这里所示，我们必须将我们的记录属性名与数据库列名相匹配。由于我们这样做了，数据被无缝地添加。

接下来，我们使用上一节定义的执行器编写属性和类别。

如果你足够仔细的话，到目前为止，我还遗漏了一些东西。这个函数对于我们创建的所有简单参数都非常有用。但是在`ProductInstance`类中定义的特殊的`StringCollection`属性呢？

对于无缝转换的`InsertAsync`函数，我们必须“教”它在这些情况下做什么。在系统初始化的某个时候，我们必须为 Dapper 的`SqlMapper`类添加一个`StringCollection`的类型处理程序。

这里不涉及太多细节，只需知道我们的字符串集合将被转换成一个 JSON 字符串，然后可以存储在`VARCHAR(MAX)`字段中。根据我们的需要，我们也可以把它改成一个简单的逗号分隔的列表。

## 任务<ienumerable>> get async(params int[]instance ids)</ienumerable>

get 函数用于从系统中批量检索实例。我这样定义它，是因为从多个实例到一个带有扩展的实例比反过来更容易。有了我们用来查询的高效方法，我们就不必为大列表中的少量实例牺牲性能。

在这个方法中，我们只是提供了一个过滤器来选择所有提供的实例 id。当我们进行高级搜索时，过滤器的使用将变得更加明显。

# SQL 语句构建器框架

我是一个 SQL 人。我不太喜欢太多的黑盒实现。这就是为什么我选择不使用实体框架或其他 ORM 来为您生成 SQL 语句。反而是喜欢自己喜欢的控制力和优化方式的能力。

然而，当我们开始处理复杂的查询时，我们确实会遇到一些重大的障碍。为了应对这个问题，我构建了一组简单的类来减轻我在过滤和生成报告时的痛苦。

让我们来看看这些类。

Where 子句生成器

这个类允许我在假定`AND`操作的情况下快速构建一个 where 子句。

这个类允许我快速将`JOIN`表添加到我的查询中。

最后，是数据透视表。我的查询出现了一个问题，由于我做的搜索太简单，自定义属性搜索提供了错误的结果。我利用了一些基本的内部连接，并在这些连接上对每个属性进行了过滤。但是，如果我想搜索一个具有两个匹配属性的产品，就会失败。相反，我将获得任何具有 1 个或两个属性值的实例(充当 or 操作)。

为了让它工作，我需要创建一个数据透视表，允许使用多个属性进行`AND`操作。这个课程稍微减轻了这种痛苦。

# 高级搜索

现在我们在`FindAsync(ExactMatchQuery)`方法。该方法的目标是基于提供给函数的各种可选属性进行搜索。让我们先展示代码，然后再浏览一遍。

这里发生了很多事情，有很多复杂的 SQL 逻辑。然而，这里是算法的公正之处:

1.  我们首先为像`Categories`、`ExceptionCategories`和`CategoryIds`这样的属性创建子查询连接。我们使用子查询是因为在实例级定义了不同的链接表。
2.  然后我们开始`WHERE`子句。我们根据查询中设置了哪些属性来添加自定义的`WhereClause`类。`if`检查决定我们何时向类中添加一个条目。
3.  由于`CustomAttributes`的复杂性，我们检查了这个需求，并相应地形成了数据透视表。如果我们不需要属性来进行搜索，我们会针对这个场景进行优化。
4.  然后，我们创建过滤查询。记住，我们试图拉回的只是实例 id。我们将查询的其余部分(提取真实数据)抽象到了`ISqlExecutor<TInstance>`实现中。
5.  最后，我们为 SQL 添加参数并运行查询。

该查询的结果是找到的实例的集合。这种灵活的查询方法允许我通过向 query 添加更多可选属性来轻松添加新的过滤功能，同时轻松地将实现添加为新的`if`语句。

# 结论和签署

咻。太多了。

这段代码相当复杂。你可能会问这种复杂程度是否值得努力。我应该说代码库并不是这样开始的。随着我不断地重构，重构，再重构，它最终在这里结束。最初，所有的实现都被完全分离出来，增加了 1000 多行代码。你可以看到系统中有很多实体使用相似的属性。但是当我继续重构的时候，我注意到了很多相似之处，并且能够将这行代码减少将近一半。

但是，这种复杂性值得吗？我猜这取决于你的视角。我再也不用碰这些代码了。事实上，在这一点上，添加一个新的实体类型是一个惯例问题。只要我从`Instance`继承并给类添加了适当的属性，我就不必接触这些代码。在这方面，我在内部构建了一个可重用的框架。这就是优势所在。但是，如果您发现自己经常编辑这些代码，那么这种复杂性可能不值得您付出努力。在几个月的距离之后，处理这些代码确实需要很大的认知负荷。但是我会让你来判断这个代码是否值得。

我希望你能在这篇文章中找到一些有用的技巧。如有疑问，欢迎在下方评论。另外，如果你喜欢这篇文章，请在 medium 上关注我。它鼓励我继续写作！

下次见！