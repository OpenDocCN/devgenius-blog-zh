<html>
<head>
<title>Nude Models — Part I : Setters</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">裸体模特第一部分:模特</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/nude-models-part-i-setters-77ac784a91f3?source=collection_archive---------8-----------------------#2020-07-19">https://blog.devgenius.io/nude-models-part-i-setters-77ac784a91f3?source=collection_archive---------8-----------------------#2020-07-19</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="d781" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">可靠的数据结构及其有争议的(写)访问。</h2></div><p id="bcd1" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">使用对象作为数据结构是一种既定的实践，它产生了许多与软件的可维护性和发展相关的问题，并且误用了50年前提出的优秀概念。在这第一部分我们将反思对 <strong class="ke io"> <em class="ky">写</em> </strong> <em class="ky">这些对象的访问。</em></p><p id="9868" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在他1972年的经典论文<a class="ae kz" href="https://www.win.tue.nl/~wstomv/edu/2ip30/references/criteria_for_modularization.pdf" rel="noopener ugc nofollow" target="_blank"/><a class="ae kz" href="https://en.wikipedia.org/wiki/David_Parnas" rel="noopener ugc nofollow" target="_blank">中，David Parnas </a>为现代软件工程定义了一个新颖且基础的概念:<strong class="ke io"> </strong> <a class="ae kz" href="https://en.wikipedia.org/wiki/Information_hiding" rel="noopener ugc nofollow" target="_blank"> <strong class="ke io">信息隐藏。</strong> </a></p><p id="b769" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">规则很简单:</p><blockquote class="la"><p id="ddb4" class="lb lc in bd ld le lf lg lh li lj kx dk translated">如果我们隐藏我们的实现，我们可以根据需要多次修改它。</p></blockquote><figure class="lk ll lm ln lo lp gh gi paragraph-image"><div class="ab gu cl lq"><img src="../Images/29ce7d44d82e8a2e892572ea5bf5260b.png" data-original-src="https://miro.medium.com/v2/format:webp/1*0lgIOJpakJ4qF6vMYhw_Sw.jpeg"/></div><figcaption class="lt lu gj gh gi lv lw bd b be z dk translated">在<a class="ae kz" href="https://unsplash.com/s/photos/hide?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae kz" href="https://unsplash.com/@ratushny?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Dmitry Ratushny </a>拍摄的照片</figcaption></figure><p id="b01a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在帕纳斯的论文之前，没有关于信息访问的明确规则，深入数据结构并不是一种有问题的做法，这种做法会惩罚任何具有可怕连锁反应的变化。</p><p id="e787" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们看看如何建模一个笛卡尔点:</p><figure class="lx ly lz ma gt lp"><div class="bz fp l di"><div class="mb mc l"/></div><figcaption class="lt lu gj gh gi lv lw bd b be z dk translated">点结构</figcaption></figure><p id="6e73" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">任何操纵这些点的软件组件都将耦合到将值保存为笛卡尔<em class="ky"> x </em>和<em class="ky"> y </em>坐标(<strong class="ke io">意外实现</strong>)。</p><p id="84be" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因为它只是一个没有操作的数据结构，所以根据每个程序员的标准，属性的语义会有所不同。</p><div class="md me gp gr mf mg"><a href="https://codeburst.io/coupling-the-one-and-only-software-design-problem-869e293a9f04" rel="noopener follow" target="_blank"><div class="mh ab fo"><div class="mi ab mj cl cj mk"><h2 class="bd io gy z fp ml fr fs mm fu fw im bi translated">耦合:唯一的软件设计问题</h2><div class="mn l"><h3 class="bd b gy z fp ml fr fs mm fu fw dk translated">对我们软件的所有故障进行根本原因分析，会发现一个有多种伪装的单一罪魁祸首。</h3></div><div class="mo l"><p class="bd b dl z fp ml fr fs mm fu fw dk translated">codeburst.io</p></div></div><div class="mp l"><div class="mq l mr ms mt mp mu lr mg"/></div></div></a></div><p id="de2a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，如果我们想将点的<strong class="ke io">意外</strong>实现更改为其极坐标模拟:</p><figure class="lx ly lz ma gt lp"><div class="bz fp l di"><div class="mb mc l"/></div><figcaption class="lt lu gj gh gi lv lw bd b be z dk translated">极点</figcaption></figure><figure class="lx ly lz ma gt lp gh gi paragraph-image"><div class="ab gu cl lq"><img src="../Images/75af7c811e9c1b82b12d0048da123d4e.png" data-original-src="https://miro.medium.com/v2/format:webp/1*2LFkZMEg-SR893gs1JmWag.png"/></div><figcaption class="lt lu gj gh gi lv lw bd b be z dk translated">同一点可以用两种不同的方式来表示</figcaption></figure><figure class="lx ly lz ma gt lp gh gi paragraph-image"><div class="ab gu cl lq"><img src="../Images/ee7bef189ee14e9276296900d18d46bc.png" data-original-src="https://miro.medium.com/v2/format:webp/1*574RfUh6NqfsdTKpoJUS9A.png"/></div><figcaption class="lt lu gj gh gi lv lw bd b be z dk translated">极坐标表示(√2，π/8)等价于笛卡尔坐标(1，1)</figcaption></figure><p id="2034" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">既然是现实世界中的<strong class="ke io">同一点</strong>，那么在我们的双射中<strong class="ke io">必然</strong>由同一个物体来表示。</p><div class="md me gp gr mf mg"><a href="https://codeburst.io/the-one-and-only-software-design-principle-5328420712af" rel="noopener follow" target="_blank"><div class="mh ab fo"><div class="mi ab mj cl cj mk"><h2 class="bd io gy z fp ml fr fs mm fu fw im bi translated">唯一的软件设计原则</h2><div class="mn l"><h3 class="bd b gy z fp ml fr fs mm fu fw dk translated">如果我们在一个单一的规则上建立我们的整个范式，我们可以保持它的简单并做出优秀的模型。</h3></div><div class="mo l"><p class="bd b dl z fp ml fr fs mm fu fw dk translated">codeburst.io</p></div></div><div class="mp l"><div class="mv l mr ms mt mp mu lr mg"/></div></div></a></div><p id="271a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">双射总是依赖于我们试图建模的方面的<strong class="ke io">主观性</strong>。为了画多边形，笛卡尔(1，1)点和极坐标(√2，π/8)点是同一点。</p><p id="cdcd" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果我们正在编写<a class="ae kz" href="https://www.wolframalpha.com/" rel="noopener ugc nofollow" target="_blank"> Wolfram </a>语义，那么尝试表示几种可能的数学表示的情况会有所不同。在这种情况下,<strong class="ke io">是问题的一部分，因此它们将由不同的</strong>对象来建模。</p><h2 id="e0e2" class="mw mx in bd my mz na dn nb nc nd dp ne kl nf ng nh kp ni nj nk kt nl nm nn no bi translated">解决办法很简单。隐藏内部表示。</h2><p id="904f" class="pw-post-body-paragraph kc kd in ke b kf np jo kh ki nq jr kk kl nr kn ko kp ns kr ks kt nt kv kw kx ig bi translated">正如Parnas所预测的，许多代码可维护性问题通过<strong class="ke io">将决策</strong>封装在定义它们的模块中得以解决。这就是这篇宏伟论文的全部内容。</p><h2 id="41b7" class="mw mx in bd my mz na dn nb nc nd dp ne kl nf ng nh kp ni nj nk kt nl nm nn no bi translated">进化的下一步</h2><p id="fb63" class="pw-post-body-paragraph kc kd in ke b kf np jo kh ki nq jr kk kl nr kn ko kp ns kr ks kt nt kv kw kx ig bi translated">随着面向对象编程的到来，封装和信息隐藏的概念被发挥到了极致。我们不再讨论封装在一个<strong class="ke io">模块</strong>中，而是在同一个<strong class="ke io">对象</strong>中。</p><p id="e402" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">回到前面的例子，我们从:</p><figure class="lx ly lz ma gt lp"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="61e1" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">朝向代表性的改变:</p><figure class="lx ly lz ma gt lp"><div class="bz fp l di"><div class="mb mc l"/></div></figure><blockquote class="la"><p id="4ab5" class="lb lc in bd ld le nu nv nw nx ny kx dk translated">一个好的设计是对象与责任(<strong class="ak">接口</strong>)而不是表现相结合。</p></blockquote><p id="c908" class="pw-post-body-paragraph kc kd in ke b kf nz jo kh ki oa jr kk kl ob kn ko kp oc kr ks kt od kv kw kx ig bi translated">因此，如果我们定义一个好的点<strong class="ke io">接口</strong>，它们可以任意改变它们的表示(甚至在运行时)，而不会传播任何连锁反应。</p><figure class="lx ly lz ma gt lp"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="529c" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当表现形式改变时…</p><figure class="lx ly lz ma gt lp"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="c900" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">…一切都继续正常工作。</p><h2 id="f035" class="mw mx in bd my mz na dn nb nc nd dp ne kl nf ng nh kp ni nj nk kt nl nm nn no bi translated">算法和数据</h2><p id="16b4" class="pw-post-body-paragraph kc kd in ke b kf np jo kh ki nq jr kk kl nr kn ko kp ns kr ks kt nt kv kw kx ig bi translated">如果我们用旧规则工作:</p><blockquote class="oe of og"><p id="65fc" class="kc kd ky ke b kf kg jo kh ki kj jr kk oh km kn ko oi kq kr ks oj ku kv kw kx ig bi translated">程序=算法+数据结构</p></blockquote><p id="181d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">…然后我们可以用<em class="ky">设置器</em>和<em class="ky">获取器</em>构建优秀的软件。</p><p id="1790" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">本文假设我们渴望用声明性对象来构建模型，其中实现隐藏在对象的责任后面。</p><p id="14c8" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这些责任在这些对象和现实世界之间的映射上是相同的。</p><div class="md me gp gr mf mg"><a href="https://codeburst.io/what-is-software-9a78c1172cf9" rel="noopener follow" target="_blank"><div class="mh ab fo"><div class="mi ab mj cl cj mk"><h2 class="bd io gy z fp ml fr fs mm fu fw im bi translated">软件有什么问题？</h2><div class="mn l"><h3 class="bd b gy z fp ml fr fs mm fu fw dk translated">软件正在吞噬世界。我们这些工作、生活和热爱软件的人通常不会停下来思考它的…</h3></div><div class="mo l"><p class="bd b dl z fp ml fr fs mm fu fw dk translated">codeburst.io</p></div></div><div class="mp l"><div class="ok l mr ms mt mp mu lr mg"/></div></div></a></div><h2 id="75af" class="mw mx in bd my mz na dn nb nc nd dp ne kl nf ng nh kp ni nj nk kt nl nm nn no bi translated">乘方；错综复杂、纠缠不清；内卷</h2><p id="8ca7" class="pw-post-body-paragraph kc kd in ke b kf np jo kh ki nq jr kk kl nr kn ko kp ns kr ks kt nt kv kw kx ig bi translated">尽管上面的例子中列出了一些好处，但当前的技术水平向我们展示了许多与耦合和纹波效应相关的问题。大多数是由使用<em class="ky">设置器</em>和<em class="ky">获取器</em>(或者简单地说:访问器)的根深蒂固的习惯产生的。</p><figure class="lx ly lz ma gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="om on di oo bf op"><div class="gh gi ol"><img src="../Images/de7259b4c44b782ffacbdce91cbc5879.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*PFDr9RbBQxY6YS5h"/></div></div><figcaption class="lt lu gj gh gi lv lw bd b be z dk translated">Johannes Plenio 在<a class="ae kz" href="https://unsplash.com/s/photos/evolution?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="8e76" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们把setters和getters作为独立的问题来看。</p><h2 id="2581" class="mw mx in bd my mz na dn nb nc nd dp ne kl nf ng nh kp ni nj nk kt nl nm nn no bi translated">安装员</h2><p id="6e20" class="pw-post-body-paragraph kc kd in ke b kf np jo kh ki nq jr kk kl nr kn ko kp ns kr ks kt nt kv kw kx ig bi translated">改变对象的内部状态违反了不变性原则。这是不鼓励的，因为在现实世界中，对象的本质不会发生变化。</p><div class="md me gp gr mf mg"><a href="https://codeburst.io/the-evil-powers-of-mutants-f803281ef82e" rel="noopener follow" target="_blank"><div class="mh ab fo"><div class="mi ab mj cl cj mk"><h2 class="bd io gy z fp ml fr fs mm fu fw im bi translated">变种人的邪恶力量</h2><div class="mn l"><h3 class="bd b gy z fp ml fr fs mm fu fw dk translated">变异就是进化。它是由查尔斯·达尔文爵士提出的，我们在软件行业中使用它。但是有些事情是…</h3></div><div class="mo l"><p class="bd b dl z fp ml fr fs mm fu fw dk translated">codeburst.io</p></div></div><div class="mp l"><div class="oq l mr ms mt mp mu lr mg"/></div></div></a></div><blockquote class="la"><p id="fce1" class="lb lc in bd ld le nu nv nw nx ny kx dk translated">唯一允许写入属性的方法是原子初始化。从那时起，变量应该是只读的。</p></blockquote><p id="4beb" class="pw-post-body-paragraph kc kd in ke b kf nz jo kh ki oa jr kk kl ob kn ko kp oc kr ks kt od kv kw kx ig bi translated">如果我们忠实于双射，我们会注意到从来没有形式为<strong class="ke io"> <em class="ky"> setAttribute </em> </strong>的消息..()在现实世界中。这些是程序员使用的实现技巧，它们破坏了好的模型。</p><blockquote class="oe of og"><p id="9da0" class="kc kd ky ke b kf kg jo kh ki kj jr kk oh km kn ko oi kq kr ks oj ku kv kw kx ig bi translated">我们永远无法从名称上向业务专家解释这些方法有什么责任。</p></blockquote><p id="e2ba" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们把多边形想象成一个数据结构。</p><figure class="lx ly lz ma gt lp"><div class="bz fp l di"><div class="mb mc l"/></div></figure><blockquote class="oe of og"><p id="6433" class="kc kd ky ke b kf kg jo kh ki kj jr kk oh km kn ko oi kq kr ks oj ku kv kw kx ig bi translated">让我们假设多边形至少有三个顶点。</p></blockquote><p id="c20b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">作为一个数据结构，我们不能强加这样的限制。</p><p id="67af" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">使用我们惊人的自动代码生成IDE，我们添加了<em class="ky">设置器</em>和<em class="ky">获取器</em>。</p><figure class="lx ly lz ma gt lp"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="3dbf" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们尝试在构造函数中添加对顶点数量的约束:</p><figure class="lx ly lz ma gt lp"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="4562" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">从现在开始，将不可能创建少于三条边的多边形，从而实现与欧几里得几何的真实世界的双射。</p><p id="bc48" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">除非我们用我们的二传手…</p><p id="73a1" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">没有什么可以阻止我们运行这段代码:</p><figure class="lx ly lz ma gt lp"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="8df6" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">此时，我们有两个选择:</p><ol class=""><li id="c515" class="or os in ke b kf kg ki kj kl ot kp ou kt ov kx ow ox oy oz bi translated">在构造器和设置器中复制业务逻辑。</li><li id="9840" class="or os in ke b kf pa ki pb kl pc kp pd kt pe kx ow ox oy oz bi translated">永久消除setter，支持不变性</li></ol><p id="667c" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在接受重复代码的情况下，当我们的限制增加时，涟漪效应开始扩散。例如，如果我们把前提条件变得更强:</p><blockquote class="oe of og"><p id="a5d3" class="kc kd ky ke b kf kg jo kh ki kj jr kk oh km kn ko oi kq kr ks oj ku kv kw kx ig bi translated">让我们假设多边形至少有三个不同的顶点。</p></blockquote><p id="afdd" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">根据我们的设计原则，正确的答案是第二个。</p><h1 id="187e" class="pf mx in bd my pg ph pi nb pj pk pl ne jt pm ju nh jw pn jx nk jz po ka nn pp bi translated">不变量验证的重复或缺失逻辑</h1><p id="e742" class="pw-post-body-paragraph kc kd in ke b kf np jo kh ki nq jr kk kl nr kn ko kp ns kr ks kt nt kv kw kx ig bi translated">许多对象都有不变量来保证它们的内聚性和表示的有效性，以维持真实世界的双射。允许部分设置(一个属性)将迫使我们在不止一个地方控制<strong class="ke io">中的表示不变量，生成<strong class="ke io">重复代码</strong>，这在修改一个引用并忽略其他引用时总是容易出错。</strong></p><h1 id="7afc" class="pf mx in bd my pg ph pi nb pj pk pl ne jt pm ju nh jw pn jx nk jz po ka nn pp bi translated">无控制生成的代码</h1><p id="9d49" class="pw-post-body-paragraph kc kd in ke b kf np jo kh ki nq jr kk kl nr kn ko kp ns kr ks kt nt kv kw kx ig bi translated">许多开发环境为我们提供了自动生成setters和getters的可能性。这导致新一代程序员认为这是一个好的设计实践，产生了难以纠正的恶习。</p><div class="md me gp gr mf mg"><a href="https://codeburst.io/lazyness-ii-code-wizards-18cc5672b642" rel="noopener follow" target="_blank"><div class="mh ab fo"><div class="mi ab mj cl cj mk"><h2 class="bd io gy z fp ml fr fs mm fu fw im bi translated">懒惰II:代码向导</h2><div class="mn l"><h3 class="bd b gy z fp ml fr fs mm fu fw dk translated">代码生成器完成了我们的艰苦工作。但是我们不再需要它们了。</h3></div><div class="mo l"><p class="bd b dl z fp ml fr fs mm fu fw dk translated">codeburst.io</p></div></div><div class="mp l"><div class="pq l mr ms mt mp mu lr mg"/></div></div></a></div><p id="780a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这种设施传播了问题，拥有这种工具给人的感觉是这是一种公认的做法。</p><h1 id="2b08" class="pf mx in bd my pg ph pi nb pj pk pl ne jt pm ju nh jw pn jx nk jz po ka nn pp bi translated">推荐</h1><ul class=""><li id="5fe6" class="or os in ke b kf np ki nq kl pr kp ps kt pt kx pu ox oy oz bi translated">不要使用<em class="ky">设定器</em>。这样做没有充分的理由。</li><li id="d829" class="or os in ke b kf pa ki pb kl pc kp pd kt pe kx pu ox oy oz bi translated">拥有名为<strong class="ke io"><em class="ky">setsometh</em>…()</strong>的方法是一种代码味道。</li><li id="990e" class="or os in ke b kf pa ki pb kl pc kp pd kt pe kx pu ox oy oz bi translated">没有公共属性。实际上，它就像是有<em class="ky">设置器</em>和<em class="ky">吸气器</em>。</li><li id="9459" class="or os in ke b kf pa ki pb kl pc kp pd kt pe kx pu ox oy oz bi translated">没有公共静态属性。除了上面提到的，这些类应该是无状态的，这是一个<em class="ky">代码气味</em>显示了一个被用作全局变量的类。</li><li id="2eba" class="or os in ke b kf pa ki pb kl pc kp pd kt pe kx pu ox oy oz bi translated">避免<a class="ae kz" href="https://en.wikipedia.org/wiki/Anemic_domain_model" rel="noopener ugc nofollow" target="_blank">贫血的对象</a>(只包含属性没有责任的对象)。这是一个<em class="ky">代码气味</em>暗示双射体上有一些丢失的对象。</li></ul><div class="md me gp gr mf mg"><a href="https://medium.com/dev-genius/code-smell-01-anemic-models-f9fb5a1323b3" rel="noopener follow" target="_blank"><div class="mh ab fo"><div class="mi ab mj cl cj mk"><h2 class="bd io gy z fp ml fr fs mm fu fw im bi translated">代码气味01——贫血模型</h2><div class="mn l"><h3 class="bd b gy z fp ml fr fs mm fu fw dk translated">你的对象是一堆没有行为的公共属性。</h3></div><div class="mo l"><p class="bd b dl z fp ml fr fs mm fu fw dk translated">medium.com</p></div></div><div class="mp l"><div class="pv l mr ms mt mp mu lr mg"/></div></div></a></div><div class="md me gp gr mf mg"><a href="https://mcsee.medium.com/code-smell-28-setters-5b0e764049aa" rel="noopener follow" target="_blank"><div class="mh ab fo"><div class="mi ab mj cl cj mk"><h2 class="bd io gy z fp ml fr fs mm fu fw im bi translated">气味代码28 —设定器</h2><div class="mn l"><h3 class="bd b gy z fp ml fr fs mm fu fw dk translated">初级程序员做的第一个练习。ide、教程和高级开发人员不断教他们这种反模式。</h3></div><div class="mo l"><p class="bd b dl z fp ml fr fs mm fu fw dk translated">mcsee.medium.com</p></div></div><div class="mp l"><div class="pw l mr ms mt mp mu lr mg"/></div></div></a></div><h1 id="8dc3" class="pf mx in bd my pg ph pi nb pj pk pl ne jt pm ju nh jw pn jx nk jz po ka nn pp bi translated">结论</h1><p id="d597" class="pw-post-body-paragraph kc kd in ke b kf np jo kh ki nq jr kk kl nr kn ko kp ns kr ks kt nt kv kw kx ig bi translated">使用setters会产生耦合并阻止我们的计算机系统的渐进发展。对于本文所陈述的论点，我们应该尽可能地限制它的使用。</p><h1 id="1487" class="pf mx in bd my pg ph pi nb pj pk pl ne jt pm ju nh jw pn jx nk jz po ka nn pp bi translated">吸气剂</h1><p id="5e90" class="pw-post-body-paragraph kc kd in ke b kf np jo kh ki nq jr kk kl nr kn ko kp ns kr ks kt nt kv kw kx ig bi translated">和setters一样，getters是不被鼓励的。在本文中，我们将深入探讨这一主题:</p><div class="md me gp gr mf mg"><a href="https://medium.com/dev-genius/nude-models-part-ii-getters-b039e5ad3427" rel="noopener follow" target="_blank"><div class="mh ab fo"><div class="mi ab mj cl cj mk"><h2 class="bd io gy z fp ml fr fs mm fu fw im bi translated">裸体模特第二部分:吸气剂</h2><div class="mn l"><h3 class="bd b gy z fp ml fr fs mm fu fw dk translated">旧的可靠数据结构及其有争议的(读)访问。</h3></div><div class="mo l"><p class="bd b dl z fp ml fr fs mm fu fw dk translated">medium.com</p></div></div><div class="mp l"><div class="px l mr ms mt mp mu lr mg"/></div></div></a></div></div><div class="ab cl py pz hr qa" role="separator"><span class="qb bw bk qc qd qe"/><span class="qb bw bk qc qd qe"/><span class="qb bw bk qc qd"/></div><div class="ig ih ii ij ik"><p id="1f37" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这一系列文章的部分目标是为软件设计的辩论和讨论提供空间。</p><div class="md me gp gr mf mg"><a href="https://medium.com/@mcsee/object-design-checklist-47c63d351352" rel="noopener follow" target="_blank"><div class="mh ab fo"><div class="mi ab mj cl cj mk"><h2 class="bd io gy z fp ml fr fs mm fu fw im bi translated">目标设计清单</h2><div class="mn l"><h3 class="bd b gy z fp ml fr fs mm fu fw dk translated">这是已经发表的软件设计文章的索引。</h3></div><div class="mo l"><p class="bd b dl z fp ml fr fs mm fu fw dk translated">medium.com</p></div></div><div class="mp l"><div class="qf l mr ms mt mp mu lr mg"/></div></div></a></div><p id="be16" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们期待着对这篇文章的评论和建议。</p><p id="090a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这篇文章还有西班牙语版本<a class="ae kz" href="https://medium.com/dise%C3%B1o-de-software/information-showing-chapter-i-setters-138deb558e5d" rel="noopener">点击这里</a>。</p></div></div>    
</body>
</html>