<html>
<head>
<title>LeetCode 556. Next Greater Element III</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">LeetCode 556。下一个更大的元素 III</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/leetcode-556-next-greater-element-iii-37916a42510c?source=collection_archive---------10-----------------------#2022-10-09">https://blog.devgenius.io/leetcode-556-next-greater-element-iii-37916a42510c?source=collection_archive---------10-----------------------#2022-10-09</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="8e51" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">问题陈述</h2></div><p id="0d57" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">给定一个正整数 n，找出整数 n 中位数完全相同且大于 n 的最小整数，如果不存在这样的正整数，返回-1。</p><p id="7b16" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">请注意，返回的整数应该适合 32 位整数，如果有一个有效答案，但它不适合 32 位整数，则返回-1。</p><p id="ceb9" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">例 1: </strong></p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="ae0d" class="lh li in ld b gy lj lk l ll lm">Input: n = 12<br/>Output: 21</span></pre><p id="6349" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">例二:</strong></p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="154d" class="lh li in ld b gy lj lk l ll lm">Input: n = 21<br/>Output: -1</span></pre></div><div class="ab cl ln lo hr lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ig ih ii ij ik"><h2 id="41cc" class="lh li in bd lu lv lw dn lx ly lz dp ma kl mb mc md kp me mf mg kt mh mi mj mk bi translated">处理这个问题</h2><p id="435c" class="pw-post-body-paragraph kc kd in ke b kf ml jo kh ki mm jr kk kl mn kn ko kp mo kr ks kt mp kv kw kx ig bi translated">起初，这个问题对我来说很难，不知道如何开始。</p><p id="e256" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">观察 1: </strong></p><p id="cfa6" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">首先，如果你看到返回的整数必须是 32 位的。因此该值必须在[0，2147483648]的范围内</p><p id="d8f0" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">观察 2: </strong></p><p id="f566" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果我想找到下一个更大的数字，那么所有的数字都必须遵循从数字末尾开始的递增顺序。</p><p id="488d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是，这里输入的是数字，现在如何迭代数字呢？所以我认为将要使用的数据类型必须是字符串数据类型。</p><p id="34ba" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，我们按照递增的顺序进行，如果我们发现一个元素没有遵循这个顺序，我们将获取这个元素。</p><p id="fa13" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们这样做是因为我们想找到下一个更大的元素。如果所有数字都像 4321 一样按升序排列，那么我们就找不到下一个由相同数字组成的更大的数字。</p><p id="7b95" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们考虑下面的例子，看看</p><figure class="ky kz la lb gt mr gh gi paragraph-image"><div class="ab gu cl ms"><img src="../Images/d62e2c9a231734ec1e59e9fa7f957f5b.png" data-original-src="https://miro.medium.com/v2/format:webp/1*dTy5UjiN4guh9UBOte3-sQ.png"/></div></figure><p id="2b93" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所以在这里直到 4，所有的都是按照递增的顺序，但是当我们得到 2 的时候顺序被打破了，因为 2 &lt;4 and not following the sequence a&gt; b&gt;c&gt; … &gt;z。</p><p id="502b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所以，我们将去掉“2 ”,现在的问题是找到下一个元素，用谁来替换这个“2”。答案将是下一个比“2”更大的元素，即 3。</p><p id="c49a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了获得下一个更大的元素，我们将利用哈希表。所以，3 会过来，2 会弹出。</p><figure class="ky kz la lb gt mr gh gi paragraph-image"><div class="ab gu cl ms"><img src="../Images/db5650d6a05888085c6729183bf85a94.png" data-original-src="https://miro.medium.com/v2/format:webp/1*qAiLGQtIYFtQQmrm476Aiw.png"/></div></figure><p id="8a97" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，问题是把“2”放在哪里。关于这一点我想了很多，我们可以把它放在最后，因为所有的顺序都是递增的，或者我们可以和 3 交换，或者放在“3”旁边。但是没有一个解决方案会带来答案。</p><p id="b133" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">观察结果 3: </strong></p><p id="5f43" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所以，在想了很多之后，我想出了一个模式，下一个元素必须是有序的，并且是升序排列的。</p><figure class="ky kz la lb gt mr gh gi paragraph-image"><div class="ab gu cl ms"><img src="../Images/8be8b6a3dd7032931be824bc3c8748c1.png" data-original-src="https://miro.medium.com/v2/format:webp/1*NYaBSpn_MxwGrB1khNRnbw.png"/></div></figure><p id="1e3d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，所有的元素，包括我们存储在 temp 中的元素，都必须被排序。所以对元素排序后，我们得到的答案是</p><figure class="ky kz la lb gt mr gh gi paragraph-image"><div class="ab gu cl ms"><img src="../Images/55c96ec4fa6d459c322c03958d7f5830.png" data-original-src="https://miro.medium.com/v2/format:webp/1*HaG54mPYDJ-lgzABSo0Glw.png"/></div></figure><p id="ea56" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是下一个大于 12443322 的元素</p><p id="bac4" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">实现如下</strong></p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="87bd" class="lh li in ld b gy lj lk l ll lm">class Solution(object):<br/>    def nextGreaterElement(self, n):<br/>        """<br/>        :type n: int<br/>        :rtype: int<br/>        """<br/>        MAX = 2147483648<br/>        if n&gt;MAX:<br/>            return -1<br/>        str_n = list(str(n))<br/><br/>        hash_table = {}<br/><br/>        max_flag = -1<br/><br/>        p1 = len(str_n)-1<br/><br/><br/>        def get_next_bigger(hash_table, value, max_value):<br/>            for v in range(value+1, max_value+1):<br/>                if v in hash_table:<br/>                    return hash_table[v]<br/>                else:<br/>                    continue<br/>            print("Value not found in table debug")<br/>            return -1<br/><br/>        while p1 &gt;= 0:<br/><br/>            value = int(str_n[p1])<br/><br/>            hash_table[value] = p1<br/><br/>            if value &gt;= max_flag:<br/>                max_flag = value<br/>                p1 -= 1<br/>            elif value &lt; max_flag:<br/>                p2 = get_next_bigger(hash_table, value, max_flag)<br/>                <br/>                str_n[p2], str_n[p1] = str_n[p1], str_n[p2] ##core logic 1<br/>                str_prefix = str_n[0:p1+1]  <br/>                str_suffix = sorted(str_n[p1+1::])  ##Core logic 2<br/>                n = int("".join(str_prefix+str_suffix))<br/>                if n&gt;=MAX:<br/>                    print(n)<br/>                    return -1<br/>                return n<br/><br/>        return -1</span></pre><figure class="ky kz la lb gt mr gh gi paragraph-image"><div class="ab gu cl ms"><img src="../Images/355a3d10d61c1407c69172df6d206f4a.png" data-original-src="https://miro.medium.com/v2/format:webp/1*k3GEygx9MiWTjIA1wzjL5Q.png"/></div></figure><p id="9c74" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">建议的解决方案比所有解决方案快 76%。</p></div><div class="ab cl ln lo hr lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ig ih ii ij ik"><h2 id="4e7d" class="lh li in bd lu lv lw dn lx ly lz dp ma kl mb mc md kp me mf mg kt mh mi mj mk bi translated">结论</h2><p id="4b6c" class="pw-post-body-paragraph kc kd in ke b kf ml jo kh ki mm jr kk kl mn kn ko kp mo kr ks kt mp kv kw kx ig bi translated">总之，问题是三步走的方法，</p><p id="aa32" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">(1)找到不遵循递增顺序模式的元素。<br/> (2)使用哈希表将该元素替换为下一个更大的元素。<br/> (3)对剩余的数组进行排序，所有的元素都会出现在正确的位置。</p><h2 id="a92d" class="lh li in bd lu lv lw dn lx ly lz dp ma kl mb mc md kp me mf mg kt mh mi mj mk bi translated">分析复杂性</h2><p id="5928" class="pw-post-body-paragraph kc kd in ke b kf ml jo kh ki mm jr kk kl mn kn ko kp mo kr ks kt mp kv kw kx ig bi translated">找到第一个坏元素所花费的时间是 O(n ),排序将花费 O(n log n)。因此总的时间复杂度是 O(n + nlog n)。为什么加法？因为我们不是每次都执行排序，而是在找到坏元素后才执行排序。</p><p id="29fe" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">空间复杂度是 O(10 ),其中在最坏的情况下，散列表将包含从 0 到 9 的 10 个数字。</p></div><div class="ab cl ln lo hr lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ig ih ii ij ik"><p id="d74a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">谢谢大家！</p></div></div>    
</body>
</html>