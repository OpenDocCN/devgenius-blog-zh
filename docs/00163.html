<html>
<head>
<title>Essential of “Codable” in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift中“可编码”的本质</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/essential-of-codable-in-swift-18c83718d010?source=collection_archive---------0-----------------------#2020-04-12">https://blog.devgenius.io/essential-of-codable-in-swift-18c83718d010?source=collection_archive---------0-----------------------#2020-04-12</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/8ab15d357bd4165385fba2e1814b824a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c8g76YcyVFZlDJs79XQj6Q.jpeg"/></div></div></figure><p id="6041" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">iOS应用程序开发人员几乎每天都与<code class="fe kt ku kv kw b">JSON</code>打交道，因为大多数iOS应用程序都与远程API通信。</p><p id="db36" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我知道你们中的大多数人会和<code class="fe kt ku kv kw b">JSONSerialization</code>一起处理<code class="fe kt ku kv kw b">Encoding</code>，和<code class="fe kt ku kv kw b">Decoding</code>一起处理<code class="fe kt ku kv kw b">JSON</code>的数据。</p><p id="a3af" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我看到一些开发人员正在编写映射器方法来将他们的<code class="fe kt ku kv kw b">JSON</code>映射到<code class="fe kt ku kv kw b">Model</code>。</p><pre class="kx ky kz la gt lb kw lc ld aw le bi"><span id="00a3" class="lf lg in kw b gy lh li l lj lk">struct User {<br/>  let id: Int<br/>  let name: String<br/>  <br/>  init?(dictionary: [String: Any]) {<br/>    guard let id = dictionary["id"] as? Int else { return nil }<br/>    guard let name = dictionary["user_name"] as? String else { return nil }<br/>    <br/>    self.id = id<br/>    self.name = name<br/>  }<br/>}</span></pre><p id="9981" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这不是一种将<code class="fe kt ku kv kw b">JSON</code>映射到<code class="fe kt ku kv kw b">Model</code>的便捷方式，而且还需要编写大量样板代码，这一点也不好玩！</p><p id="f9ee" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> Swift 4 </strong>引入<code class="fe kt ku kv kw b">Codable</code>帮助你轻松完成<code class="fe kt ku kv kw b">Encoding</code>和<code class="fe kt ku kv kw b">Decoding.</code></p><p id="5052" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">可编码的</strong>就是<code class="fe kt ku kv kw b">typealias</code>，它是由<code class="fe kt ku kv kw b">Encodable</code>和<code class="fe kt ku kv kw b">Decodable</code>两个协议组成</p><pre class="kx ky kz la gt lb kw lc ld aw le bi"><span id="fe62" class="lf lg in kw b gy lh li l lj lk">public typealias Codable = Decodable &amp; Encodable</span></pre><p id="6abf" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">可解码</strong>是一个协议，顾名思义就是要求<code class="fe kt ku kv kw b">Decode</code>你的<code class="fe kt ku kv kw b">JSON </code>到你的<code class="fe kt ku kv kw b">Model</code>。</p><pre class="kx ky kz la gt lb kw lc ld aw le bi"><span id="9fbc" class="lf lg in kw b gy lh li l lj lk">public protocol Decodable {<br/>    init(from decoder: Decoder) throws<br/>}</span></pre><p id="9b13" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">可编码</strong>是一个协议，需要<code class="fe kt ku kv kw b">Encode</code>你的<code class="fe kt ku kv kw b">Model</code>到<code class="fe kt ku kv kw b">JSON</code>。</p><pre class="kx ky kz la gt lb kw lc ld aw le bi"><span id="256d" class="lf lg in kw b gy lh li l lj lk">public protocol Encodable {<br/>    func encode(to encoder: Encoder) throws<br/>}</span></pre><p id="653c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在本教程中，我将向你展示如何使用<code class="fe kt ku kv kw b"><strong class="jx io">Codable</strong></code>到<code class="fe kt ku kv kw b">Encode</code>和<code class="fe kt ku kv kw b">Decode</code>到<code class="fe kt ku kv kw b">JSONs</code>和从<code class="fe kt ku kv kw b">Model</code>来回。</p><p id="55f7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我相信在这个故事的结尾，你会喜欢使用<code class="fe kt ku kv kw b">Codable</code>(如果你还没有使用它的话)。因为它需要更少的样板代码，并提高了代码的可读性。</p><p id="ca2a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当<strong class="jx io">解码</strong> <code class="fe kt ku kv kw b">JSON</code>到<code class="fe kt ku kv kw b">Model</code>时，我会经历一些我已经遇到的场景，这最终会帮助你在遇到这种情况时很好地处理它。</p><h2 id="8e9c" class="lf lg in bd ll lm ln dn lo lp lq dp lr kg ls lt lu kk lv lw lx ko ly lz ma mb bi translated">1.简单使用代码</h2><p id="6826" class="pw-post-body-paragraph jv jw in jx b jy mc ka kb kc md ke kf kg me ki kj kk mf km kn ko mg kq kr ks ig bi translated">在处理简单的<code class="fe kt ku kv kw b">JSON</code>数据时，使用<code class="fe kt ku kv kw b">Codable</code>是如此简单。</p><p id="c774" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您只需确认<code class="fe kt ku kv kw b">type</code>的<code class="fe kt ku kv kw b">Codable</code>协议。你需要确保你的<code class="fe kt ku kv kw b">JSON</code>中的<code class="fe kt ku kv kw b">key</code>与你的<code class="fe kt ku kv kw b">type.</code>中的<code class="fe kt ku kv kw b">Property</code>名完全匹配</p><figure class="kx ky kz la gt jo"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="d6a1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">它将<code class="fe kt ku kv kw b">Decode</code>你的<code class="fe kt ku kv kw b">JSON</code>到<code class="fe kt ku kv kw b">Country</code>，并打印下面的结果。</p><pre class="kx ky kz la gt lb kw lc ld aw le bi"><span id="e0c2" class="lf lg in kw b gy lh li l lj lk">Country name = United States of America<br/>Country capital = Washington, D.C.<br/>Country sub region = Northern America<br/>Country borders = ["CAN", "MEX"]<br/>Country population = 323947000.0</span></pre><h2 id="7ba5" class="lf lg in bd ll lm ln dn lo lp lq dp lr kg ls lt lu kk lv lw lx ko ly lz ma mb bi translated">2.在您的<code class="fe kt ku kv kw b">Model</code>中重命名属性</h2><p id="3575" class="pw-post-body-paragraph jv jw in jx b jy mc ka kb kc md ke kf kg me ki kj kk mf km kn ko mg kq kr ks ig bi translated">很明显，我们不会总是喜欢相同的<em class="mj">属性</em>名称，因为我们在<code class="fe kt ku kv kw b">JSON</code>中进行检索。</p><p id="217c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe kt ku kv kw b">Codable</code>提供了一种方便的方法，可以在您选择的模型中保存属性名，并将其从<code class="fe kt ku kv kw b">JSON</code>映射到右侧<code class="fe kt ku kv kw b">key</code>。</p><p id="5dcb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您的<code class="fe kt ku kv kw b">type</code>需要实现<code class="fe kt ku kv kw b">enum CodingKeys: String, CodingKey</code>,在这个枚举中，您可以提到正确的<code class="fe kt ku kv kw b">key</code>来映射您重命名的属性，然后<code class="fe kt ku kv kw b">Codable</code>就会为您完成。</p><figure class="kx ky kz la gt jo"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="1e4e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">它会将<code class="fe kt ku kv kw b">altSpellings</code>键从<code class="fe kt ku kv kw b">JSON</code>映射到<code class="fe kt ku kv kw b">Country</code>的<code class="fe kt ku kv kw b">alternateSpellings</code>。它将按如下方式打印。</p><pre class="kx ky kz la gt lb kw lc ld aw le bi"><span id="6eec" class="lf lg in kw b gy lh li l lj lk">Country alternate spellings: ["US", "USA", "United States of America"]</span></pre><h2 id="d1be" class="lf lg in bd ll lm ln dn lo lp lq dp lr kg ls lt lu kk lv lw lx ko ly lz ma mb bi translated">3.将snake-case JSON键转换为模型中的camelCase属性</h2><p id="fa79" class="pw-post-body-paragraph jv jw in jx b jy mc ka kb kc md ke kf kg me ki kj kk mf km kn ko mg kq kr ks ig bi translated">有时我们会从远程API接收到<code class="fe kt ku kv kw b">JSON</code>，其中包含写在<code class="fe kt ku kv kw b">snake-case</code>中的<code class="fe kt ku kv kw b">key</code>名称</p><p id="6e7f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Swift编码惯例建议使用<code class="fe kt ku kv kw b">camelCase</code>属性名。</p><p id="3a3b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以我们需要将我们的snake-case JSON映射到camelCase属性名。我们可以用<code class="fe kt ku kv kw b">enum CodingKeys: String, CodingKey</code>实现，如<strong class="jx io">场景#2中所建议的。</strong></p><p id="cea2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然而，使用<code class="fe kt ku kv kw b">keyDecodingStrategy</code>有一种快速简单的方法可以实现这一点。</p><p id="ffdc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你只需要将你的<code class="fe kt ku kv kw b">keyDecodingStrategy</code>设置为<code class="fe kt ku kv kw b">convertFromSnakeCase</code>，剩下的工作会自动完成。它会将你所有的<code class="fe kt ku kv kw b">snake-case</code> JSON <code class="fe kt ku kv kw b">key</code>转换成<code class="fe kt ku kv kw b">camelCase</code>属性。</p><figure class="kx ky kz la gt jo"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="96af" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在本例中，<code class="fe kt ku kv kw b">JSON</code>中的<code class="fe kt ku kv kw b">calling_codes</code>将映射到<code class="fe kt ku kv kw b">Country</code>中的<code class="fe kt ku kv kw b">callingCodes</code>，并按如下所示打印输出。</p><pre class="kx ky kz la gt lb kw lc ld aw le bi"><span id="c263" class="lf lg in kw b gy lh li l lj lk">Country calling codes = ["1"]</span></pre><h2 id="c888" class="lf lg in bd ll lm ln dn lo lp lq dp lr kg ls lt lu kk lv lw lx ko ly lz ma mb bi translated">4.将日期字符串从JSON转换为Swift日期</h2><p id="9438" class="pw-post-body-paragraph jv jw in jx b jy mc ka kb kc md ke kf kg me ki kj kk mf km kn ko mg kq kr ks ig bi translated">我们经常在<code class="fe kt ku kv kw b">JSON</code>中收到各种记录的<code class="fe kt ku kv kw b">date</code>，通常，同一应用程序的所有远程API都使用相同的<code class="fe kt ku kv kw b">dateFormat</code>。</p><p id="1748" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然而，我们需要在所有需要使用<code class="fe kt ku kv kw b">Date</code>的地方将<code class="fe kt ku kv kw b">date(String)</code>从<code class="fe kt ku kv kw b">JSON</code>转换成Swift <code class="fe kt ku kv kw b">Date</code>。</p><p id="7bcd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">相反，您可以使用<code class="fe kt ku kv kw b">dateDecodingStrategy</code>轻松地将<code class="fe kt ku kv kw b">date(String)</code>转换为<code class="fe kt ku kv kw b">Date</code>，而只使用<code class="fe kt ku kv kw b">decoding</code> <code class="fe kt ku kv kw b">JSON</code>。</p><p id="0327" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你只需要将<code class="fe kt ku kv kw b">dateDecodingStrategy</code>设置为<code class="fe kt ku kv kw b">.formatted(DateFormatter()) </code>，它会为你做休息。您可以将<code class="fe kt ku kv kw b">dateFormat</code>设置为<code class="fe kt ku kv kw b">DateFormatter</code>的实例，然后您可以将相同的<code class="fe kt ku kv kw b">dateFormatter</code>用于<code class="fe kt ku kv kw b">dateDecodingStrategy</code>。</p><figure class="kx ky kz la gt jo"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="4e9f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在本例中，它会将“1776–07–04”映射到<code class="fe kt ku kv kw b">let independanceDay: Date</code>。它将输出如下。</p><pre class="kx ky kz la gt lb kw lc ld aw le bi"><span id="a13e" class="lf lg in kw b gy lh li l lj lk">Country Independance Day = 1776-07-04</span></pre><h2 id="92f6" class="lf lg in bd ll lm ln dn lo lp lq dp lr kg ls lt lu kk lv lw lx ko ly lz ma mb bi translated">5.只使用必需的属性，忽略JSON中的rest</h2><p id="e161" class="pw-post-body-paragraph jv jw in jx b jy mc ka kb kc md ke kf kg me ki kj kk mf km kn ko mg kq kr ks ig bi translated">经常发生的情况是，您只需要3-4个字段，而您会从<code class="fe kt ku kv kw b">JSON</code>收到许多不必要的<code class="fe kt ku kv kw b">keys</code>。</p><p id="dc70" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您可以通过不在您的<code class="fe kt ku kv kw b">Model</code>中声明来忽略来自<code class="fe kt ku kv kw b">JSON</code>的不需要的属性。</p><figure class="kx ky kz la gt jo"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="f416" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在上面的例子中，我们在模型中只声明了2个属性，忽略了rest。它将输出如下。</p><pre class="kx ky kz la gt lb kw lc ld aw le bi"><span id="caff" class="lf lg in kw b gy lh li l lj lk">Country name = United States of America<br/>Country capital = Washington, D.C.</span></pre><p id="d4bc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你使用<code class="fe kt ku kv kw b">enum CodingKeys: String, CodingKey</code>来同时重命名一个或多个属性，那么你可以忽略不需要的属性，如下所示。</p><figure class="kx ky kz la gt jo"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="7e80" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">上面的例子将只使用big JSON中的3个属性，同时它将把<code class="fe kt ku kv kw b">JSON</code>中的<code class="fe kt ku kv kw b">altSpellings</code>重命名为<code class="fe kt ku kv kw b">Country</code>中的<code class="fe kt ku kv kw b">alternateSpellings</code>。它将输出如下。</p><pre class="kx ky kz la gt lb kw lc ld aw le bi"><span id="d064" class="lf lg in kw b gy lh li l lj lk">Country name = United States of America<br/>Country capital = Washington, D.C.<br/>Country alternate spellings = ["US", "USA", "United States of America"]</span></pre><h2 id="4980" class="lf lg in bd ll lm ln dn lo lp lq dp lr kg ls lt lu kk lv lw lx ko ly lz ma mb bi translated">6.处理可选财产</h2><p id="c181" class="pw-post-body-paragraph jv jw in jx b jy mc ka kb kc md ke kf kg me ki kj kk mf km kn ko mg kq kr ks ig bi translated">显而易见，远程API会给我们发送一些可选的属性。</p><p id="134d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们可以使用<code class="fe kt ku kv kw b">Codable</code>将相应的属性声明为<code class="fe kt ku kv kw b">optional.</code>来轻松解决这个问题</p><figure class="kx ky kz la gt jo"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="f803" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在上面的例子中，<code class="fe kt ku kv kw b">phoneNumber</code>是一个可选的属性，无论<code class="fe kt ku kv kw b">phoneNumber</code>是否出现，它都能很好地<code class="fe kt ku kv kw b">decodes</code>出来。它将输出如下。</p><pre class="kx ky kz la gt lb kw lc ld aw le bi"><span id="4efc" class="lf lg in kw b gy lh li l lj lk">Eric phone number = +1 12312312<br/>Ronaldo phone number = Not Available</span></pre><h2 id="1d73" class="lf lg in bd ll lm ln dn lo lp lq dp lr kg ls lt lu kk lv lw lx ko ly lz ma mb bi translated">7.处理深度嵌套的JSON</h2><p id="6af1" class="pw-post-body-paragraph jv jw in jx b jy mc ka kb kc md ke kf kg me ki kj kk mf km kn ko mg kq kr ks ig bi translated">当使用复杂的远程API或任何公共的远程API时，您会得到嵌套很深的JSON作为响应，它有很多您不需要使用的属性。</p><p id="d464" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">嗯，而<code class="fe kt ku kv kw b">decoding</code>比如<code class="fe kt ku kv kw b">JSON</code>，你需要通过实现<code class="fe kt ku kv kw b">Decodable</code>的<code class="fe kt ku kv kw b"> init(from decoder: Decoder) throws </code>方法来编写一些自定义实现。</p><p id="df00" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这个方法中，你可以从<code class="fe kt ku kv kw b">decoder</code>中查询你感兴趣的<code class="fe kt ku kv kw b">nestedContainer</code>，然后你可以从这个<code class="fe kt ku kv kw b">nestedContainer</code>中查询你感兴趣的<code class="fe kt ku kv kw b">property</code>。</p><figure class="kx ky kz la gt jo"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="774e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在上面的例子中，我们用许多属性深度嵌套了JSON，然而，我们只对<code class="fe kt ku kv kw b">name</code>和<code class="fe kt ku kv kw b">city</code>感兴趣。</p><p id="b882" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">虽然<code class="fe kt ku kv kw b">name</code>很容易解码，但是<code class="fe kt ku kv kw b">city</code>很难解码。</p><p id="2aaf" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">由于城市保存在<code class="fe kt ku kv kw b">JSON</code>的最深处，我们需要从<code class="fe kt ku kv kw b">decoder</code>查询<code class="fe kt ku kv kw b">contactInformation</code>作为<code class="fe kt ku kv kw b">nestedContainer</code>。然后，我们需要将<code class="fe kt ku kv kw b">contactInformation</code>中的<code class="fe kt ku kv kw b">mailingAddress</code>查询为<code class="fe kt ku kv kw b">nestedContainer</code>。最后，我们可以从<code class="fe kt ku kv kw b">contactInformation</code>查询<code class="fe kt ku kv kw b">city</code>。</p><pre class="kx ky kz la gt lb kw lc ld aw le bi"><span id="1885" class="lf lg in kw b gy lh li l lj lk">Employee name = Eric<br/>Employee city = New York City</span></pre><p id="66af" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">到目前为止，这就是我想分享给Codable的全部内容。</p><blockquote class="mk ml mm"><p id="7c4a" class="jv jw mj jx b jy jz ka kb kc kd ke kf mn kh ki kj mo kl km kn mp kp kq kr ks ig bi translated"><strong class="jx io">建议</strong>:</p><p id="5c50" class="jv jw mj jx b jy jz ka kb kc kd ke kf mn kh ki kj mo kl km kn mp kp kq kr ks ig bi translated">请在您的<code class="fe kt ku kv kw b">Model</code>中仅声明基本属性。<strong class="jx io">不要</strong>在你的<code class="fe kt ku kv kw b">Model</code>中声明<em class="in">非必要</em>属性，尽管它即将进入<code class="fe kt ku kv kw b">JSON</code>。</p><p id="5f47" class="jv jw mj jx b jy jz ka kb kc kd ke kf mn kh ki kj mo kl km kn mp kp kq kr ks ig bi translated">通过在你的<code class="fe kt ku kv kw b">Model</code>中声明<em class="in">非必要的</em>属性，你正在依赖那些你根本用不上的东西。</p><p id="bbe0" class="jv jw mj jx b jy jz ka kb kc kd ke kf mn kh ki kj mo kl km kn mp kp kq kr ks ig bi translated">如果您这样做了，如果远程API在JSON响应中更新/删除了那些不重要的属性，那么您将来会受到影响。这可以通过不在模型中声明来避免。</p></blockquote><p id="338b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">提示:</strong>你可以使用<a class="ae mq" href="https://app.quicktype.io" rel="noopener ugc nofollow" target="_blank"> https://app.quicktype.io </a>将你的JSON转换成可编码模型。这将为您节省大量时间来声明所有属性和您的模型。</p><p id="6771" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">我会不断更新这个故事，因为我遇到了使用Codable的不同场景和最佳实践。</strong></p><p id="12e5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我希望你喜欢阅读这个故事，并发现它是有帮助的。如果您有任何问题/意见，请告诉我。</p></div></div>    
</body>
</html>