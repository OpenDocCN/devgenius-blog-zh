<html>
<head>
<title>Journey of JavaScript code.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript代码之旅。</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/journey-of-javascript-code-daa7b5d9da96?source=collection_archive---------4-----------------------#2021-12-16">https://blog.devgenius.io/journey-of-javascript-code-daa7b5d9da96?source=collection_archive---------4-----------------------#2021-12-16</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/bbbab6fc99628470add15052bb51d73c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H-25KB7EbSHjv70HXrdl6w.png"/></div></div></figure><p id="63e9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">JS代码的执行分为三个阶段。</p><ul class=""><li id="0acf" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated">从语法上分析</li><li id="c665" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">汇编</li><li id="ed17" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">执行</li></ul><h1 id="642f" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">从语法上分析</h1><p id="45f6" class="pw-post-body-paragraph jv jw in jx b jy mf ka kb kc mg ke kf kg mh ki kj kk mi km kn ko mj kq kr ks ig bi translated">在解析阶段，代码被分解成标记，语法解析器将这些标记转换成抽象语法树(AST)。</p><p id="f734" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">AST被字节码生成器用来形成字节码，字节码又被解释器用来运行代码。</p><p id="773d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">有两种类型的解析器，它们是懒惰解析器和渴望解析器。</p><p id="73a3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">急切解析器做以下事情:</p><ul class=""><li id="3760" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated">用于解析我们想要编译的函数</li><li id="ee5c" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">构建AST</li><li id="9477" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">构建范围</li><li id="6f7b" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">查找所有语法错误</li></ul><p id="94ca" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">惰性解析器做以下事情:</p><ul class=""><li id="19d1" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated">用于跳过我们不想编译的函数</li><li id="6736" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">找到一组有限的错误</li></ul><p id="bfd5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">举个例子，IIFE将由一个急切的解析器解析，而其他函数由一个懒惰的解析器解析。惰性解析器解析一个函数的函数体，当这个函数被调用时，它将被解析并在以后编译。</p><h1 id="c26d" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">汇编</h1><p id="bacc" class="pw-post-body-paragraph jv jw in jx b jy mf ka kb kc mg ke kf kg mh ki kj kk mi km kn ko mj kq kr ks ig bi translated">在编译阶段，当然是完成代码编译。但是还有更多。JavaScript运行时有自己的JIT(即时)编译实现。</p><h2 id="6ec5" class="mk li in bd lj ml mm dn ln mn mo dp lr kg mp mq lv kk mr ms lz ko mt mu md mv bi translated">JIT(实时)编译</h2><p id="3200" class="pw-post-body-paragraph jv jw in jx b jy mf ka kb kc mg ke kf kg mh ki kj kk mi km kn ko mj kq kr ks ig bi translated">JIT所做的是，一旦代码开始运行，它就能够在运行时优化它。</p><p id="ac99" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">每个现代浏览器和运行时都使用自己的JIT编译器。与java等其他语言提前编译不同，JS在执行时就完成了编译。</p><p id="4274" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">JavaScript设计了解释语言。解释器是一种逐行执行代码的东西，它不知道下一行会发生什么。</p><p id="7d9b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一般来说，现代浏览器会有两个编译器:基准编译器和优化编译器。如果代码的某个部分被重复运行，它将被传递给一个优化编译器，该编译器将优化该代码以加快运行速度。优化编译器使用以前看到的类型信息(不要改变类型！)</p><figure class="mx my mz na gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mw"><img src="../Images/3cca6e44ffadce4cd3aa3e8f8d50037b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k05vV1sVZo4Fwl13RsZeFw.png"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">重用的函数被标记为“热”</figcaption></figure><figure class="mx my mz na gt jo"><div class="bz fp l di"><div class="nf ng l"/></div></figure><h1 id="8e0b" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">执行</h1><p id="5ede" class="pw-post-body-paragraph jv jw in jx b jy mf ka kb kc mg ke kf kg mh ki kj kk mi km kn ko mj kq kr ks ig bi translated">编译和执行阶段实际上是同时进行的。当解释器试图一行一行地执行代码时，编译器同时也在试图优化代码(JIT for you！)</p><p id="9b12" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">执行分两个阶段完成:</p><ul class=""><li id="09d7" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated">内存分配阶段</li><li id="01d0" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">代码执行阶段</li></ul><pre class="mx my mz na gt nh ni nj nk aw nl bi"><span id="bb93" class="mk li in ni b gy nm nn l no np">var n = 2; // 1</span><span id="dcc5" class="mk li in ni b gy nq nn l no np">function square(n) { // 2<br/> var ans = n * n; // 3<br/> return ans; // 4<br/>} // 5</span><span id="eeb0" class="mk li in ni b gy nq nn l no np">var squareofTwo = sqaure(n); // 6</span></pre><p id="ff83" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们看一下上面的代码例子，在内存执行阶段内存是分配给变量和函数的。在这种情况下，我们有两个变量n，squareofTwo和一个函数square。变量将被赋予未定义的值，函数将被分配内存。</p><p id="bf0c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在变量的状态是，</p><pre class="mx my mz na gt nh ni nj nk aw nl bi"><span id="53dd" class="mk li in ni b gy nm nn l no np"><br/>num = undefined<br/>squareofTwo = undefined</span></pre><h2 id="6551" class="mk li in bd lj ml mm dn ln mn mo dp lr kg mp mq lv kk mr ms lz ko mt mu md mv bi translated">执行上下文</h2><p id="ab2c" class="pw-post-body-paragraph jv jw in jx b jy mf ka kb kc mg ke kf kg mh ki kj kk mi km kn ko mj kq kr ks ig bi translated">上例中的内存分配发生在全局执行上下文中。每当进行新的函数调用时，就会创建另一个执行上下文。在上面的例子中，每当函数square被调用时，新的执行上下文将被创建，并具有新的内存分配阶段和代码执行阶段。</p><p id="c29c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在向前看，</p><ul class=""><li id="2881" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated">在代码执行阶段，在第1行，值2被赋给一个变量。跳过第2、3、4行。</li><li id="6ff3" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">在第6行调用该函数时，将生成正方形并创建一个新的执行上下文。</li><li id="f778" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">内存将被分配给变量和，其值未定义，在代码执行阶段，将计算和的值并进行分配。</li><li id="3648" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">第4行将把控制权返回给全局执行上下文，值4将被赋给变量squareofTwo。</li></ul><p id="a382" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这就是JavaScript代码的执行方式。这个例子很小，但是您可以将这种思路应用于任何代码片段，并且您将有一个很好的代码执行的心理模型。</p><p id="7790" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我提到的谈话和文章将在下面提到，</p><figure class="mx my mz na gt jo"><div class="bz fp l di"><div class="nr ng l"/></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">从语法上分析</figcaption></figure><figure class="mx my mz na gt jo"><div class="bz fp l di"><div class="nr ng l"/></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">汇编</figcaption></figure><figure class="mx my mz na gt jo"><div class="bz fp l di"><div class="nr ng l"/></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk translated">执行</figcaption></figure><p id="da19" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae ns" href="https://blog.bitsrc.io/the-jit-in-javascript-just-in-time-compiler-798b66e44143" rel="noopener ugc nofollow" target="_blank">https://blog . bitsrc . io/the-JIT-in-JavaScript-just-in-time-compiler-798 b66e 44143</a></p><p id="dd8d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我希望这是一本好书。感谢阅读！直到下次👋</p></div></div>    
</body>
</html>