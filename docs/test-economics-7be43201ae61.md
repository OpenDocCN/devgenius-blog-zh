# 测试经济学

> 原文：<https://blog.devgenius.io/test-economics-7be43201ae61?source=collection_archive---------3----------------------->

多年来，测试对于保持质量至关重要。但是同样的事情测试两次是没有价值的。理想情况下，当您在代码中引入一个 bug 时，应该只有一个测试失败。

![](img/4fef3b2b04827e45f3da07f8dd1f6490.png)

测试是我们创建的第二个程序，用来检查我们想要创建的第一个主要的东西。这两个程序之间有一种信任关系，一方检查另一方。这个互相核对部分的过程就像会计上的[复式记账](http://blog.cleancoder.com/uncle-bob/2017/12/18/Excuses.html)。

我通常做 [TDD](/inverted-scientist-method-aka-tdd-e7848c3fd982?sk=b6234b6d1a4170a8939d9aebcea25157) 并且我以一种在我的测试中描述用户所有期望的行为的方式来做。测试对我来说是推动我的设计的一个很好的方式，我使用测试反馈来理解如何构建东西。所以我试图为每个独特的行为编写一个[测试来创建](/unit-tests-c70618dc1e25?sk=de16c7a7bec6fa068728441e55365c97)。我不想为了同样的事情维护很多测试。这就是为什么我喜欢由外向内的 TDD，因为它帮助我覆盖了所有的东西，除了一次。

TDD 不是为了用大量的测试来测试同样的事情，也不是为了 100%的覆盖率。它用于创建基于您想要为用户定义的行为的代码，并在测试中保持这些行为。

## 测试权衡

测试就像胶水，他们修补他们测试的东西。如果你的测试被固定在你的领域逻辑的内部部分，如果你想重构的话，你会有麻烦，因为你需要重写你的测试。这是[耦合](/gravity-in-software-5fdf9d243a62?sk=d7302760b4db40f3677a20c51d08802d)的定义，如果你改变你的 SUT(被测服务)你将需要改变你的测试，反之亦然。
这就是我更喜欢将测试与我想要创建的用户行为相结合的原因，这有助于我在不改变测试的情况下重构内部部分([六角形架构](/the-whys-of-hexagonal-architecture-1ccca8476c86?sk=8d8e99e381ae473c001fd80c348fa5f8))。

改变测试也是有风险的，测试是你代码的守护者，改变这些守护者的意义是不可预知的。比起集成或 e2e 测试，我更喜欢单元测试。

所有这些测试的权衡影响了我的设计，我想创造一些容易测试的东西。除此之外，我讨厌维护代码两次，我讨厌发现一个单元测试失败，而发现另外三四个测试也失败。我认为那是重复演示，我有太多相同的测试，那是浪费时间。

这个问题的简单答案是创建更高层次的测试(集成或 e2e ),将每个测试映射到一个验收标准。我不喜欢这种方法，原因有几个:

*   太长的测试套件往往不允许人们运行测试，并使更改变得乏味。
*   持续几个小时的测试会鼓励人们做[批改变](/batching-1e23cc939710?sk=e4244dcaaa7cdd2ea676f07c6f0314d3)。
*   E2E 或集成测试很难编写，它们需要大量的管道工作。
*   E2E 测试通常很难单独测试，所以我们通常针对[长期环境](/long-lived-environments-93f097786aa6?sk=84eba6ba390918a6a9a89fff6454e3b4)进行测试。
*   长期环境比我们的测试用得更多，所以我们倾向于改变测试所需的数据，使它们变得不可靠。
*   [片状剥落](/flakiness-in-tests-b586c056e0a8?sk=22ad01266811dbe0f43f4aa997ac26e1)是测试的大敌。我不想维护一个古怪的测试套件。

考虑到这一点，我在编写单元测试时施加压力，不是将每个测试与我正在使用的语言或范例的一个单元联系起来，而是与我想要创建的行为联系起来。我喜欢创建[社交单元测试](https://martinfowler.com/bliki/UnitTest.html)，其中要测试的单元是行为，所以我在我的领域中创建入口点，并为我的代码部分创建[测试替身](https://martinfowler.com/bliki/TestDouble.html)，这将帮助我与外部丑陋的基础设施世界进行交互(六角形架构[中的次级端口](https://en.wikipedia.org/wiki/Hexagonal_architecture_(software)))。

但是我不会用单元测试来测试所有的东西，[我不喜欢模仿我不拥有的类型](https://marcingryszko.medium.com/effective-test-doubles-part-2-b73e92b64a40)。所以我尝试使用集成测试来测试我的二级端口(基础设施)的实现。例如，我尝试使用我的数据库的真实连接器和内存数据库中的真实连接器来检查我的 SQL 查询是否在做我想做的事情。

所以我创建了测试替身来在我的单元测试中轻松检查我的领域正在做正确的事情。我正在为我的端口添加假设，模拟描述了我的端口(适配器)的实现需要如何表现。所以我的集成测试需要证明这些假设，这很重要，如果我改变一个测试 double，我也必须改变集成测试，如果我改变集成测试，我需要改变 mock。遵循这条规则，我们将永远安全。

在同一个代码库中，没有必要用 e2e 测试再次测试，因为它已经按照链式法则进行了测试。如果将来我们改变模拟，我的领域的测试将会失败。
如果我们改变基础设施中的行为，我的集成测试将会失败。
所以我们被覆盖，我不能做的是改变一部分而不是另一部分，我必须记住这一点，模拟和真正的代码是在一个合同中。双方都需要履行合同。

我可以用这种方式在同一个代码库(服务)中测试几乎所有的东西，但是服务之间的事情更棘手。您不能在代码库之间编写单元测试，并且在客户端和服务器之间维护契约的两个部分更加困难。一种方法是使用契约测试。
正如我之前说过的，测试就像胶水，所以契约测试会修复你的服务器行为。服务器服务的外部 API 将更难更改。如果你正在创建一个[分布式整体](/distributed-monolith-1d2d9f86a68f?sk=7b489fa66af30f9946142485df6784d6)，维护所有这些测试将会很困难，也许你需要改变你的架构。也许我们必须以这样一种方式来设计我们的服务，它们之间不需要太多的交流，这样在那些连接点引入错误的风险就低了。为什么有大量的内部公共 API？。

E2E 是最后一颗子弹，他们应该是检查事情是否在一起工作的最后选择。我不喜欢他们，我尽量避开他们。甚至我认为他们制造的问题比好处多。

如果我们从经济学的角度考虑，所有这些症状都需要时间，所以你的公司需要钱:

*   长测试套件。
*   重复测试。
*   古怪的测试。
*   生产前的长期环境。

快速的测试可以省钱，它们覆盖了你几乎所有的代码(超过 90%)，它们覆盖了用户的所有行为，它们可以快速地告诉你你犯了什么错误。

不要因为覆盖率而写测试，不要因为你不相信其他低水平的测试而写测试，写测试来持久化你不希望随着时间的推移而丢失的行为，以你最小化要维护的测试的方式写测试，但是你要为用户覆盖所有的行为。