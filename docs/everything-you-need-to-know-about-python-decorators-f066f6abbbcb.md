# python Decorators——你需要知道的一切

> 原文：<https://blog.devgenius.io/everything-you-need-to-know-about-python-decorators-f066f6abbbcb?source=collection_archive---------13----------------------->

这是一个关于 Python decorators 的结构、目的和实际应用的内容丰富的教程，提供了大量的程序代码示例。

![](img/a13db5fb9349857cc129146e095412bb.png)

作者插图

在这篇装饰者指南中，我们将回顾它们是什么，如何创建和使用它们。根据定义，装饰器是一个函数，它接受另一个函数并扩展后者的行为，而不显式地改变它。在本教程中，我们将尝试理解这意味着什么以及它是如何实现的。

# 1.先决条件—功能

在我们开始理解 decorators 之前，让我们先谈一点对他们的理解很重要的函数的属性。

## 1.1.将函数作为参数传递

在 Python 中，函数可以像任何其他对象一样作为参数传递和使用。考虑以下三个函数:

这里的`say_hello()` 和`be_awersome()` 是接收一个字符串变量名的普通函数。函数`greet_john()` 接收另一个函数作为参数，例如，`say_hello()`或`be_awesome()`:

当作为参数传递时，函数名不带括号，只传递对函数的引用。直到函数被调用`greet_john()`，函数本身才被执行。

## 1.2.内部功能

定义在其他函数内部的函数称为内部函数。具有两个内部函数的函数示例:

函数被调用`parent()`会发生什么？停下来想想。输出如下所示:

请注意，内部函数的定义顺序并不重要。只有当函数被调用时，打印才会发生。

在调用父函数之前，不会定义内部函数。也就是说，它们是局部受限的`parent()`，只存在于其中，作为局部变量。当在边界外调用函数`first_child()`，`parent()`时，我们会得到一个错误:

## 1.3.从函数返回函数

Python 允许将函数用作返回值。以下示例返回外部函数`parent()`的内部函数之一:

语句`return`返回对函数的引用，也就是说，函数的名字是不带括号指定的(否则将返回函数执行的结果)。

在给定的例子中，`first`和`second`是变量，其中对本地函数`first_child()`和`second_child()`的引用被写成`parent()`。现在`first` it `second`可以作为普通函数使用，尽管它们指向的函数不能直接访问:

注意，在前面关于内部函数的部分中，我们没有访问`first_child()`的权限。在上一个例子中，我们收到了每个函数的链接，以后可以调用它们。

# 2.简单的装饰者💅

## 2.1.总体思路:运用函数知识

既然我们已经看到了 Python 中的函数就像任何其他对象一样，那么我们就更容易理解 decorators 的“魔力”了。让我们用一个假的例子来说明这个想法:

你知道叫`say_where()`会发生什么吗？

为了理解发生了什么，让我们回头看看前面的例子。我们只是运用了目前为止所学的一切。装饰发生在最后一行:

我们将函数`my_decorator()`的引用传递给函数`say_whee`。B `my_decorator()`有一个内部函数`wrapper()`在`return`外部函数语句中被引用。因此，我们将`my_decorator()`一个*链接*作为一个参数传递给一个函数，并接收一个返回到其包装函数的链接。

现在的名字`say_whee`指向内部函数`wrapper`:

然而，它`wrapper()`包含对原始`say_whee()`的引用，并在两次调用`print()`之间调用该函数。

> **简单来说:**
> 
> 装饰者包装一个函数，改变它的行为。

让我们添加扬声器。考虑说明装饰者动态行为的第二个例子。让我们让我们的函数尖叫“万岁！”只有在白天。

装饰函数`say_whee()`只有在 8:00 到 22:00 之间运行时`"Whee!"`才会输出(为了检查行为上的差异，“扭转箭头”)⏰).

## 2.2.一点句法糖！🍭

坦白说，我们装饰的方式看起来很尴尬。在上一个例子中，我们使用了这个名字三次`say_whee`:在定义原始函数的时候，在传递对函数的引用的时候，`not_during_the_night()`，以及在覆盖这个名字来创建对装饰器的引用的时候。

为了不做这种无聊的事，在 Python 中你可以使用符号`@`创建一个装饰器。以下代码相当于我们看到的第一个示例:

也就是说，在函数定义之前的指令`@my_decorator,`是等同于指令`say_whee = my_decorator(say_whee)`的`say_whee()`。

## 2.3.重用装饰者

像任何其他函数一样，装饰器可以放在一个单独的模块中，用于各种目的。例如，创建一个包含以下内容的文件`decorators.py`:

现在我们从模块中导入函数，并将它用作装饰器。通过调用修饰函数，我们得到原始函数被执行两次:

# 结论

恭喜你，你已经到达文章的结尾了！🎖️

现在你知道了:

*   如何创建函数和类装饰器？
*   如何将参数传递给 decorators 并从中返回值。
*   为什么装修工要用@ functools.wraps。
*   如何使用嵌套装饰器？

装修工的定义没有什么魔力。通常，一切都旨在创建一个充当包装器的函数或类。为了传递参数，通常使用符号`*args`和`**kwargs`。而符号`@`的使用只是语法糖，方便了 decorators 的调用。

装饰者可以非常方便地修改函数和类的行为，为它们的处理创建额外的逻辑。此外，这种修改模式很容易使用嵌套的装饰器相互叠加。要删除装饰，只需删除提到装饰者的那一行。

要更深入地了解 decorator，请查看历史 [PEP 318](https://www.python.org/dev/peps/pep-0318/) ，以及 [Python decorator wiki 页面](https://wiki.python.org/moin/PythonDecorators)。

第三方[装饰器](https://realpython.com/primer-on-python-decorators/)模块也将帮助你创建你自己的装饰器。它的[文档](https://github.com/micheles/decorator/blob/master/docs/documentation.md)包含了更多使用 decorators 的例子。