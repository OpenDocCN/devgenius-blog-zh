<html>
<head>
<title>Types transformations with Typescript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Typescript进行类型转换</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/types-transformations-with-typescript-167d807adf25?source=collection_archive---------2-----------------------#2021-05-21">https://blog.devgenius.io/types-transformations-with-typescript-167d807adf25?source=collection_archive---------2-----------------------#2021-05-21</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="5ad9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">关于类型用法的一些实用想法。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/857bf10b9c4f82296f4c9d122dd8f660.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*GfG342CVgXK45Hb17a99nQ.png"/></div></figure><p id="ff72" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Typescript有一些附加的保留关键字，允许基于其他类型设置新类型。流传最广的是推断、省略、挑选、记录。</p><p id="ff10" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们从头开始。</p><p id="1e70" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">Typescript中的泛型— </strong>它是依赖于另一个类型的类型。例如，我们有一个类型位置。我们用某个参数&lt; T &gt;对其进行参数化。</p><p id="fee0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们写许多类型参数，用逗号分隔。我们在调用它时添加必要的值。</p><pre class="kj kk kl km gt kq kr ks kt aw ku bi"><span id="4a88" class="kv kw in kr b gy kx ky l kz la">interface Coordinate&lt;Lat, Lng, Title&gt; {<br/>  latitude: Lat;<br/>  longitude: Lng;<br/>  label: Title;<br/>}<br/>const myLocation: Coordinate&lt;number, number, string&gt; = {<br/>  latitude: 59.436962,<br/>  longitude: 24.753574,<br/>  label: 'Tallinn',<br/>};<br/>console.log(myLocation);</span></pre><p id="3e33" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">类型关系。<br/>例如，对于字符串类型，我们有这样的依赖关系:</p><p id="9340" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">未知(任何类型的超类型)-&gt;字符串-&gt;从不(任何类型的子类型)。</p><p id="6613" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">包含所有可能的值-&gt;字符串-&gt;不会或不应该有值</p><p id="b690" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">借助关键字“extends ”,我们可以通过超类型来限制参数。例如，我们使用带有1个参数的泛型类型。并让它成为string的子类型。</p><pre class="kj kk kl km gt kq kr ks kt aw ku bi"><span id="64d8" class="kv kw in kr b gy kx ky l kz la">function getBilliards&lt;T extends string&gt;(s: T): [T] {<br/>  return [s];<br/>}<br/>// argument of this type is assignable to parameter of type &lt;...&gt;<br/>const result = getBilliards&lt;'carom' | 'snooker' | 'pool'&gt;('carom');<br/>console.log(result); // ["carom"]</span></pre><p id="dec0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">条件类型—它类似于类型的三元运算符。</p><p id="7caa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">条件修剪对于缩小联合类型也很有用。标准库包括从联合类型中移除了<code class="fe lb lc ld kr b">null</code>和<code class="fe lb lc ld kr b">undefined</code>的<code class="fe lb lc ld kr b">NonNullable&lt;T&gt;</code>类型。</p><pre class="kj kk kl km gt kq kr ks kt aw ku bi"><span id="3db2" class="kv kw in kr b gy kx ky l kz la">type MyNonNullable&lt;T&gt; = T extends null | undefined ? never : T;<br/>const result: MyNonNullable&lt;1&gt; = 1;<br/>console.log(result);<br/>const resultStr: MyNonNullable&lt;'lorem ipsum'&gt; = 'lorem ipsum';<br/>console.log(resultStr);</span><span id="e5a2" class="kv kw in kr b gy le ky l kz la">type MyNonNullable&lt;T&gt; = T extends null | undefined ? T : never;<br/>const result3: MyNonNullable&lt;null&gt; = null;<br/>console.log(result3);</span></pre><p id="453b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">“从不”、“未知”和“任何”是有意义的运算符:</p><ol class=""><li id="5e23" class="lf lg in jm b jn jo jr js jv lh jz li kd lj kh lk ll lm ln bi translated">“从不”用于表示从未发生的事情。尤其是在条件类型中删除不需要的情况。</li><li id="092b" class="lf lg in jm b jn lo jr lp jv lq jz lr kd ls kh lk ll lm ln bi translated">“未知”包含所有可能的值，但它可能有任何类型。</li><li id="dc6b" class="lf lg in jm b jn lo jr lp jv lq jz lr kd ls kh lk ll lm ln bi translated">“任何”是非常特殊的情况。如果你不需要检查属性类型或者你不知道它(当从第三方库获取数据时)，" any "将不会检查它们的类型存在。</li></ol><p id="8344" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">generics and never conditional type:infer fetch type or不应该是值。</p><pre class="kj kk kl km gt kq kr ks kt aw ku bi"><span id="88b2" class="kv kw in kr b gy kx ky l kz la">type ListItem&lt;T extends any[]&gt; = T extends (infer X)[] ? X : never;<br/>type stringItems = ListItem&lt;string[]&gt;;</span><span id="b09c" class="kv kw in kr b gy le ky l kz la">const result: stringItems = '1';<br/>const result2: stringItems = 2; //number is not assignable to string<br/>console.log(result);</span><span id="9139" class="kv kw in kr b gy le ky l kz la">type typesItem = ListItem&lt;[string, number]&gt;;<br/>const different: typesItem = 'Lorem Ipsum';<br/>console.log(different);<br/>const different2: typesItem = 1.618034;<br/>console.log(different2);</span></pre><ol class=""><li id="4f10" class="lf lg in jm b jn jo jr js jv lh jz li kd lj kh lk ll lm ln bi translated"><strong class="jm io">推断</strong></li></ol><p id="1214" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用<code class="fe lb lc ld kr b">infer</code>，编译器确保你已经显式声明了所有类型变量<em class="lt"/>。</p><pre class="kj kk kl km gt kq kr ks kt aw ku bi"><span id="858a" class="kv kw in kr b gy kx ky l kz la">type R = { a: number };<br/>type MyType&lt;T&gt; = T extends infer R ? R : never;<br/>  // infer new variable R from T</span><span id="f321" class="kv kw in kr b gy le ky l kz la">type T1 = MyType&lt;{b: string}&gt;;    // T1 is { b: string; }</span><span id="748d" class="kv kw in kr b gy le ky l kz la">const result: T1 = {<br/>    b: 'Alex'<br/>}<br/>console.log(result);    //string</span></pre><p id="8eb6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">没有<code class="fe lb lc ld kr b">infer</code>，编译器不会知道，你是否想要引入一个额外的类型变量<code class="fe lb lc ld kr b">R</code>，或者<code class="fe lb lc ld kr b">R</code>只是一个偶然的输入错误。</p><pre class="kj kk kl km gt kq kr ks kt aw ku bi"><span id="be16" class="kv kw in kr b gy kx ky l kz la">interface Billiard {<br/>    pool: string<br/>}</span><span id="c1ac" class="kv kw in kr b gy le ky l kz la">type MyBilliard&lt;T&gt; = T extends Billiard2 ? 'snooker' : 'caromball'; // mistake: Billiard2 not declared yet</span><span id="d19d" class="kv kw in kr b gy le ky l kz la">type MyBilliard&lt;T&gt; = T extends infer Billiard ? Billiard : never;<br/>type AnotherBilliard&lt;T&gt; = T extends Billiard ? Billiard : never;</span><span id="048f" class="kv kw in kr b gy le ky l kz la">type myPool = MyBilliard&lt;{lengthTable: number}&gt;<br/>type myPool2 = AnotherBilliard&lt;{pool: string}&gt; // assign string only</span><span id="a258" class="kv kw in kr b gy le ky l kz la">// try use properties<br/>const result: myPool = {<br/>    lengthTable: 360<br/>}<br/>console.log(result);</span><span id="8cd5" class="kv kw in kr b gy le ky l kz la">const result2: myPool2 = {<br/>    pool: 'Pyramid'<br/>}<br/>console.log(result2);</span></pre><p id="6f07" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">检查函数类型:如果T类型扩展了一个函数，ReturnType将推断函数结果的类型，否则将返回never类型。</p><pre class="kj kk kl km gt kq kr ks kt aw ku bi"><span id="8d38" class="kv kw in kr b gy kx ky l kz la">type MyReturnType&lt;T&gt; = T extends (...args: unknown[]) =&gt; infer R ? R : never;<br/>function getMobile() {<br/>  return {<br/>    platform: "default",<br/>    version: "1.0",<br/>  };<br/>}<br/>type Mobile = MyReturnType&lt;typeof getMobile&gt;;<br/>const result: Mobile = {<br/>  platform: "Android",<br/>  version: "2.0"<br/>};<br/>console.log(result);</span></pre><p id="985c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> 2。省略</strong></p><p id="fc77" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">从3.5版本的Typescript开始，我们有了标准的省略关键字。以前的版本允许通过选择和排除关键字的组合来实现省略行为。</p><p id="090b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Omit <t k="">通过从T中选取所有属性然后删除k来创建一个类型。换句话说，Omit是一个通用的实用程序类型，它删除k中指定的T的键。映射DTO是使用Omit的常用位置。</t></p><pre class="kj kk kl km gt kq kr ks kt aw ku bi"><span id="2826" class="kv kw in kr b gy kx ky l kz la">interface Fish{ <br/>    property1?: string; <br/>    property2?: string; <br/>    property3?: string; <br/>}<br/>// omit single property <br/>type Fisher = Omit&lt;Fish, 'property3'&gt;;</span><span id="5535" class="kv kw in kr b gy le ky l kz la">// omit multiple properties<br/>type Fisher = Omit&lt;Fish, 'property2' | 'property3'&gt;;</span><span id="b930" class="kv kw in kr b gy le ky l kz la">const result: Fisher = {property2: 'fish'}; //not assignable to type</span><span id="dfbb" class="kv kw in kr b gy le ky l kz la">const resultWorks: Fisher= {property1: 'fisher'};<br/>console.log(resultWorks);</span></pre><p id="1b7a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">另一个带有挑选和省略逻辑的示例:随时添加新属性</p><pre class="kj kk kl km gt kq kr ks kt aw ku bi"><span id="81af" class="kv kw in kr b gy kx ky l kz la">interface Fisher {<br/>    fullname: string;<br/>    email: string;<br/>}<br/>interface FisherNew extends Pick&lt;Fisher, 'email'&gt; { }<br/> <br/>type MyFisher = Omit&lt;Fisher, keyof FisherNew&gt; &amp; { // Fisher only<br/>    experience: number;<br/>} <br/>const result: MyFisher = {<br/>    experience: 10,<br/>    fullname: 'Alex',<br/>    //email: '' // does not exist in type MyFisher<br/>}<br/>console.log(result);</span></pre><p id="12b8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> 3。选择</strong> —当需要重用一个类型中的属性时</p><p id="f089" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Pick节省了我们为了复制现有类型的属性而创建新类型的时间。</p><p id="64fb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe lb lc ld kr b">Pick</code>做与<code class="fe lb lc ld kr b">Omit</code>相反的事。Pick &lt; T，K &gt;通过从T中选取一组属性K来构造一个类型</p><pre class="kj kk kl km gt kq kr ks kt aw ku bi"><span id="30c2" class="kv kw in kr b gy kx ky l kz la">interface User {<br/>  id: number;<br/>  name: string;<br/>  phone: string;<br/>  age: number;<br/>}<br/><br/>type Person = Pick&lt;User, 'id' | 'name'&gt;;</span><span id="f474" class="kv kw in kr b gy le ky l kz la">const myPerson: Person = {<br/>  id: number;<br/>  name: string;<br/>  phone: string; //error<br/>}</span><span id="7926" class="kv kw in kr b gy le ky l kz la">// or we can declare type manually without using a Pick keyword<br/>type Person = {<br/>  id: number;<br/>  name: string;<br/>}</span></pre><p id="c903" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> 4。Partial </strong> —使所提供接口的所有属性都是可选的</p><p id="520b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">它将对象的所有属性设置为可选，并允许您只考虑更新的键。</p><pre class="kj kk kl km gt kq kr ks kt aw ku bi"><span id="c264" class="kv kw in kr b gy kx ky l kz la">interface Profile {<br/>  id: number,<br/>  username: string,<br/>  phone: string<br/>}</span><span id="0c95" class="kv kw in kr b gy le ky l kz la">const updateWithPartial: Partial&lt;Profile&gt; = {<br/>  username: 'Alex'<br/>};</span><span id="89e0" class="kv kw in kr b gy le ky l kz la">const instance: Profile = {<br/>  id: 1,<br/>  username: 'my Name',<br/>  phone: '(+xxx) xxxx xxx xxx'<br/>};<br/></span></pre><p id="6e51" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> 5。Readonly </strong> —处理不可变数据。</p><p id="8e63" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">像<strong class="jm io"> readonly </strong>和<strong class="jm io"> const </strong>这样的关键字是使用属性的另一种情况:<strong class="jm io"> readonly </strong>用于类属性，<strong class="jm io"> const </strong>用于变量。</p><p id="db8e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Readonly逻辑非常简单:接受它接收的类型，并将它的所有属性标记为只读。如果重新分配返回类型的属性，这将导致引发编译错误。</p><pre class="kj kk kl km gt kq kr ks kt aw ku bi"><span id="c2ce" class="kv kw in kr b gy kx ky l kz la">interface Work{<br/>  start: Date,<br/>  end: Date, <br/>  comments: string<br/>  status: boolean<br/>}<br/>interface State {<br/>  myWork: Readonly&lt;Work&gt;[]<br/>}<br/>const task: Readonly&lt;State&gt; = {<br/>  myWork: [<br/>    { status: false, comments: 'What has been done?' },<br/>  ]<br/>};</span><span id="1d5f" class="kv kw in kr b gy le ky l kz la">//task.myWork[0].status = true; // impossible, due to a read-only</span><span id="cdfa" class="kv kw in kr b gy le ky l kz la">// ability to change it:<br/>const myNewWork = {<br/>  myWork: [<br/>    <!-- -->{...task.myWork[0], status: true }, ...task.myWork.slice(1)<br/>  <!-- -->]<br/>};<br/>console.log(myNewWork);</span></pre><p id="a975" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> 6。记录</strong> —在构造配置类型时非常有用。</p><p id="e15b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">记录允许您从联合中创建新的类型。联合中的值用作新类型的属性。</p><pre class="kj kk kl km gt kq kr ks kt aw ku bi"><span id="8d3c" class="kv kw in kr b gy kx ky l kz la">type SampleProps = Record&lt;'property1' | 'property2', Cat&gt;;</span><span id="730a" class="kv kw in kr b gy le ky l kz la">// in other words, it is the same as:<br/>type SampleProps = {<br/>  property1: Cat;<br/>  property2: Cat;<br/>}</span></pre><p id="6ef2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">带枚举的示例:</p><pre class="kj kk kl km gt kq kr ks kt aw ku bi"><span id="0c6f" class="kv kw in kr b gy kx ky l kz la">enum Billiard {<br/>    Pool, Snooker, Carom, Pyramid<br/>}<br/>function getBilliardName(c: Billiard): string {<br/>  const getNames: Record&lt;Billiard, string&gt; = {<br/>    [Billiard.Pool]: 'American Pool',<br/>    [Billiard.Snooker]: 'English Snooker',<br/>    [Billiard.Carom]: 'French Carom ball',<br/>    [Billiard.Pyramid]: 'Russian Pyramid'<br/>  }<br/>  return getNames[c] || '';<br/>}<br/>getBilliardName('Pyramid');</span></pre><p id="43dc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">另一个购物例子:</p><pre class="kj kk kl km gt kq kr ks kt aw ku bi"><span id="0aa8" class="kv kw in kr b gy kx ky l kz la">type ProductId = string;<br/>type Status = 'preOrder' | 'inStock' | 'soldOut';<br/>interface Availability {<br/>    availability: Status;<br/>    amount: number;<br/>};</span><span id="2d6f" class="kv kw in kr b gy le ky l kz la">const x: Record&lt;ProductId, Availability&gt; = {<br/>    '1001': { availability: 'inStock', amount: 5},<br/>    '1002': { availability: 'preOrder', amount: 10 },<br/>    '1003': { availability: 'soldOut', amount: 17},<br/>};<br/>console.log(x['1002']);</span></pre><p id="6657" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">结论</strong>:</p><p id="9ea7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">实用程序类型只是让我们的代码更干净，可读性更好。它可以使应用程序更加结构化，简化我们的工作并减少工作量。肯定是不可能用JavaScript实现的。</p><div class="lu lv gp gr lw lx"><a href="https://www.typescriptlang.org/docs/handbook/utility-types.html" rel="noopener  ugc nofollow" target="_blank"><div class="ly ab fo"><div class="lz ab ma cl cj mb"><h2 class="bd io gy z fp mc fr fs md fu fw im bi translated">文档-实用程序类型</h2><div class="me l"><h3 class="bd b gy z fp mc fr fs md fu fw dk translated">TypeScript提供了几种实用工具类型来促进常见的类型转换。这些实用程序可用…</h3></div><div class="mf l"><p class="bd b dl z fp mc fr fs md fu fw dk translated">www.typescriptlang.org</p></div></div><div class="mg l"><div class="mh l mi mj mk mg ml ko lx"/></div></div></a></div><div class="lu lv gp gr lw lx"><a href="https://www.typescriptlang.org/play" rel="noopener  ugc nofollow" target="_blank"><div class="ly ab fo"><div class="lz ab ma cl cj mb"><h2 class="bd io gy z fp mc fr fs md fu fw im bi translated">TS Playground——探索TypeScript和JavaScript的在线编辑器</h2><div class="me l"><h3 class="bd b gy z fp mc fr fs md fu fw dk translated">Playground让你以一种安全和可共享的方式在线编写类型脚本或JavaScript。</h3></div><div class="mf l"><p class="bd b dl z fp mc fr fs md fu fw dk translated">www.typescriptlang.org</p></div></div></div></a></div></div></div>    
</body>
</html>