<html>
<head>
<title>How to GraphQL in Deno</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Deno中绘制SQL</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-to-graphql-in-deno-e7c1f681ccc0?source=collection_archive---------7-----------------------#2020-06-11">https://blog.devgenius.io/how-to-graphql-in-deno-e7c1f681ccc0?source=collection_archive---------7-----------------------#2020-06-11</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/32f4fdc7d35e111fd5a0682545d6ed60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GCfILbs6mdMqY9cHxdZyHQ.png"/></div></div></figure><p id="3500" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">2020年春天，Ryan Dahl发布了Deno 1.0.0。发布之后，Deno在网络社区引起了很大的轰动。那么什么是Deno呢？现在回想起来，Deno正是Ryan在构建Node时所希望完成。在安全性、包管理和Typescript支持等方面都有所改进。</p><p id="283d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">继续讨论文章的主题。Deno中的GraphQL。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi kt"><img src="../Images/6ea70d5d4905a35d235b32dc8069dfd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SIcXsX1IxOqhrr6XWdWUWA.png"/></div></div></figure><p id="f053" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们所有的进口来自Oak，它是Deno的一个web服务器框架。熟悉Express in Node的人使用Oak会有宾至如归的感觉。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ky"><img src="../Images/fe477561fa1f65586f462bc991703258.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2xzOFuKJykuUFB9_ruyGAw.png"/></div></div></figure><p id="8353" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们通过使用描述模式的模板字符串调用gql函数来创建我们的GraphQL模式。该模式指定了一个带有名称和图像的恐龙。请注意，图像只是一个字符串，因为它使用了表情符号。该模式指定了两个查询。一个用于获取所有恐龙，另一个用于搜索特定恐龙。最后，模式指定了添加单个恐龙的突变。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi kz"><img src="../Images/1f8635d27b5a1fdf79af5d8e2ea1ab8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D55uzeNrwkreHtpOc3R5SQ.png"/></div></div></figure><p id="a606" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对于本教程，我们将数据保存在一个变量中。因此，重新启动服务器将重置数据。但是对于尝试Oak和GraphQL来说效果很好。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi la"><img src="../Images/8536f49e1722381b900873a4547b1c32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tedQYxV8_MRz_JcaruzmNw.png"/></div></div></figure><p id="88fa" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">接下来是实现我们的三个解析器。在我们的解析器中，dino数组被搜索、返回或扩展。在最后一种情况下，我们不返回数据，而是返回一个布尔值来指示。请参见架构中的ResolveType。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi la"><img src="../Images/c962867b91f1a3c956a73ab437020037.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YXSzhdESbP-kpzslaa6Cyw.png"/></div></div></figure><p id="26e4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在剩下的就是启动我们的服务器。我们首先将我们的模式(类型变量)和解析器传递给Oaks applyGraphQL函数，然后从调用中获取GraphQLService。如示例所示，我们将其传递给Oak应用程序实例。</p><p id="c25e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后，我们开始监听端口8080上的GraphQL POST请求！</p><p id="de35" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，我们可以在端口8080上向/graphql发送有效负载:</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lb"><img src="../Images/188e1afa3cd33ecb82b864da3272c010.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2-B5pdR5X3edGJ09xF8Y3w.png"/></div></div></figure><p id="a9cf" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">就是这样！祝你黑客生涯愉快，欢迎提问或评论。</p></div><div class="ab cl lc ld hr le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ig ih ii ij ik"><p id="15df" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">本确切教程视频:<br/>【https://www.youtube.com/watch?v=Rc_HhL55JZM T2】</p><p id="2f6a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">代码:<a class="ae lj" href="https://gist.github.com/danba340/ce04651f8fc14bcb974fb4b940d95bdd" rel="noopener ugc nofollow" target="_blank"><em class="lk">https://gist . github . com/danba 340/ce 04651 f8fc 14 BCB 974 FB 4b 940d 95 BDD</em></a></p><p id="f97c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">推特:<a class="ae lj" href="https://twitter.com/BarelyDaniel" rel="noopener ugc nofollow" target="_blank"><em class="lk">https://twitter.com/BarelyDaniel</em></a></p></div></div>    
</body>
</html>