<html>
<head>
<title>1 Common mistake developers make when learning ReactJs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">1开发人员在学习ReactJs时常犯的错误</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/what-you-should-know-about-props-drilling-tips-to-plan-your-app-structure-well-67b4ffaa2448?source=collection_archive---------2-----------------------#2021-07-18">https://blog.devgenius.io/what-you-should-know-about-props-drilling-tips-to-plan-your-app-structure-well-67b4ffaa2448?source=collection_archive---------2-----------------------#2021-07-18</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="c65f" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">指导更好地反应道具规划</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/23408c5b12c6407cc95f6cc74075187d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*T425Pn0WcwF9zU9-"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">在<a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae ks" href="https://unsplash.com/@felipepelaquim?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">felipelaquim</a>拍摄的照片</figcaption></figure><p id="bda1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在像React这样的Javascript框架中，术语props对应于传递给组件的变量。web应用程序中的组件是网页的构建块。Web应用程序可以包含数百个组件，其中的数据可以通过Props跨组件共享。</p></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><h1 id="50e1" class="lw lx in bd ly lz ma mb mc md me mf mg jt mh ju mi jw mj jx mk jz ml ka mm mn bi translated">为什么道具演练是一个问题</h1><p id="b2d1" class="pw-post-body-paragraph kt ku in kv b kw mo jo ky kz mp jr lb lc mq le lf lg mr li lj lk ms lm ln lo ig bi translated">这篇文章将带你了解道具训练在反应中可能引起的一些问题。</p><p id="0c2c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们看下面的例子:</p><pre class="kd ke kf kg gt mt mu mv mw aw mx bi"><span id="228f" class="my lx in mu b gy mz na l nb nc">const App = () =&gt; {<br/> ....<br/> const [count, setCount] = useState();<br/> ....<br/> return (&lt;div&gt;<br/>   &lt;Component1 count={count}/&gt;<br/> &lt;/div&gt;);<br/>}</span><span id="d765" class="my lx in mu b gy nd na l nb nc">const Component1 = ({count}) =&gt; &lt;div&gt;<br/> &lt;Component2 count={count}/&gt;<br/> ... some more stuff <br/>&lt;/div&gt;</span><span id="272b" class="my lx in mu b gy nd na l nb nc">const Component2 = ({count}) =&gt; &lt;div&gt;<br/> &lt;Component3 count={count}/&gt;<br/> ... some more stuff<br/>&lt;/div&gt;</span><span id="2978" class="my lx in mu b gy nd na l nb nc">const Component3 = ({count}) =&gt; &lt;div&gt;<br/> // do something with count<br/>&lt;/div&gt;</span></pre><p id="bbda" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="ne"> Props drilling </em>在本例中也称为(<em class="ne"> threading </em>)是当Component3需要访问状态变量count时，我们将该Props从&lt; app &gt;向下传递到&lt; Component1 &gt;并一直向下传递到&lt; Component3 &gt;。</p><p id="8861" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">尽管道具训练有助于保持单一的真相来源，因此是有益的，但它也会引发许多问题。</p></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><h1 id="c73b" class="lw lx in bd ly lz ma mb mc md me mf mg jt mh ju mi jw mj jx mk jz ml ka mm mn bi translated"><strong class="ak">让我们来看看道具训练可能引起的一些问题</strong></h1><blockquote class="nf ng nh"><p id="d77e" class="kt ku ne kv b kw kx jo ky kz la jr lb ni ld le lf nj lh li lj nk ll lm ln lo ig bi translated"><a class="ae ks" href="https://reactjs.org/docs/components-and-props.html" rel="noopener ugc nofollow" target="_blank">在React中，默认情况下，当你的组件的状态或者道具改变时，你的组件会重新渲染。</a></p></blockquote><p id="2729" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这意味着如果count更新，订阅它的每个组件都将重新呈现。了解这一点应该让我们思考我们应用程序的整个结构，并质疑在应用程序级别定义计数的必要性。当我们将道具向下传递给不需要它的组件，只是为了让它们在树中进一步向下传递给需要它的孩子，从而导致整个树重新渲染时，这甚至会变得更成问题。</p><p id="9045" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们来看看这个片段</p><pre class="kd ke kf kg gt mt mu mv mw aw mx bi"><span id="6285" class="my lx in mu b gy mz na l nb nc">const App = () =&gt; {<br/> ....<br/> <br/> ....<br/> return (&lt;div&gt;<br/>   &lt;Component1/&gt;<br/>  &lt;/div&gt;);<br/>}</span><span id="c7c8" class="my lx in mu b gy nd na l nb nc">const Component1 = () =&gt; &lt;div&gt;<br/> &lt;Component2 /&gt;<br/> ... some more stuff <br/>&lt;/div&gt;</span><span id="bb4c" class="my lx in mu b gy nd na l nb nc">const Component2 = () =&gt; &lt;div&gt;<br/> &lt;Component3 /&gt;<br/> ... some more stuff<br/>&lt;/div&gt;</span><span id="f43b" class="my lx in mu b gy nd na l nb nc">const Component3 = () =&gt; {<br/> const [setCount,count] = useState();<br/> return (&lt;div&gt;<br/>  // do something with count<br/> &lt;/div&gt;)<br/>}</span></pre><p id="1665" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">React的行为会和这个结构一样吗？显然，它只会在每次计数更新时重新渲染<component3>。</component3></p></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><h1 id="3b7f" class="lw lx in bd ly lz ma mb mc md me mf mg jt mh ju mi jw mj jx mk jz ml ka mm mn bi translated">让我们来看另一个道具演练<strong class="ak">问题</strong></h1><p id="acdc" class="pw-post-body-paragraph kt ku in kv b kw mo jo ky kz mp jr lb lc mq le lf lg mr li lj lk ms lm ln lo ig bi translated">在上面的例子中，钻道具可能不是问题(性能方面),因为应用程序相当小。然而，随着应用程序的增长，我们可能会偶然发现一些用例，使我们的应用程序性能下降，或者使我们的编码更加耗时。</p><p id="9a8b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> 1-重命名道具</strong>变得更加困难，因为我们需要手动找到每个订户的道具并重命名，这可能需要一些时间。如果应用程序非常复杂和庞大，这可能会很乏味和有压力。</p><p id="e492" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> 2-重构组件</strong>或改变它们的结构肯定会使跟踪转发的属性变得更加困难，从而导致一些问题，如可读性更差的代码和未使用的属性，使组件不必要地重新呈现。</p><h1 id="fa7b" class="lw lx in bd ly lz nl mb mc md nm mf mg jt nn ju mi jw no jx mk jz np ka mm mn bi translated"><strong class="ak">会有什么样的工作？</strong></h1><p id="f25d" class="pw-post-body-paragraph kt ku in kv b kw mo jo ky kz mp jr lb lc mq le lf lg mr li lj lk ms lm ln lo ig bi translated">道具钻取<strong class="kv io">的发生是有原因的</strong>，通常当开发人员设计他们的应用程序结构时，他们错过了规划应用程序的依赖注入，换句话说，他们没有考虑如何将这些数据提供给他们指定的UI容器，导致一个混乱的组件结构和一个流传下来的道具线程。</p><p id="d46d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这里有一些<strong class="kv io">提示</strong>，我发现有助于避免陷入这个问题，<br/>仔细考虑你的应用程序，将你的数据分成两部分:</p><p id="8970" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> A. </strong> <strong class="kv io"> UI相关数据</strong>，像<code class="fe nq nr ns mu b">isToggled shouldPopUp isActive</code>之类的东西，这些东西应该放在离它们的UI消费者很近的地方，当我们发现自己在许多组件之间共享一个道具的时候，这是我们的组件树结构没有被很好地设计的一个迹象，我们总是可以利用像<a class="ae ks" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank"> React Context API </a>这样的概念来控制我们的应用程序的依赖注入和优化应用程序结构。</p><p id="4d80" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> B. </strong>我们可以利用像Flux这样的状态管理概念，一个著名的工具是Redux。上下文Api在这里是部分有用的，因为这两个概念都可以很好地服务于这个用例。</p><h1 id="56bc" class="lw lx in bd ly lz nl mb mc md nm mf mg jt nn ju mi jw no jx mk jz np ka mm mn bi translated"><strong class="ak">结论</strong></h1><p id="e9c4" class="pw-post-body-paragraph kt ku in kv b kw mo jo ky kz mp jr lb lc mq le lf lg mr li lj lk ms lm ln lo ig bi translated">在开始写代码之前规划你的应用程序，肯定会有助于减少在重构上花费的时间和精力。向下传递道具在向下传递3级时被认为是钻取，这是无计划UI结构的标志。</p></div></div>    
</body>
</html>