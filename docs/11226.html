<html>
<head>
<title>Machine Learning Algorithm Series: Graph Kernel Algorithm with Python, Julia, and R code examples</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">机器学习算法系列:带有 Python、Julia 和 R 代码示例的图核算法</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/machine-learning-algorithm-series-graph-kernel-algorithm-with-python-and-julia-code-examples-a212c928bd1d?source=collection_archive---------5-----------------------#2022-12-26">https://blog.devgenius.io/machine-learning-algorithm-series-graph-kernel-algorithm-with-python-and-julia-code-examples-a212c928bd1d?source=collection_archive---------5-----------------------#2022-12-26</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/c04fb33f7f7635f3e2e9be438d0f1c96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_HNc6fKIZigcvgCs"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">照片由<a class="ae jz" href="https://unsplash.com/@alpridephoto?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">андрейсизов</a>在<a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="234b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">图核算法是一种机器学习技术，可用于分析和比较图形。这些算法通过计算两个图之间的相似性度量来运行，然后可以使用该度量来对图进行分类或聚类，或者对图进行预测。</p><p id="194c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">图核算法的一个常见应用是在生物信息学领域，其中它们用于分析蛋白质-蛋白质相互作用网络和基因调控网络分析、自然语言处理和计算机视觉。</p><p id="52c4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">有几种不同的方法来计算图的相似性，方法的选择将取决于应用程序的具体要求。我将尝试解释一些常见的方法。</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h1 id="7367" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">图表编辑距离</h1><p id="061b" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">此度量计算将一个图形转换为另一个图形所需的图形编辑操作(如添加或删除边)的最小数量。这种方法适用于比较具有相似结构但节点或边的数量可能不同的图。</p><p id="59b9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">以下是如何使用 Python 和<code class="fe mi mj mk ml b">networkx</code>库计算两个图形之间的图形编辑距离的示例:</p><pre class="mm mn mo mp gt mq ml mr bn ms mt bi"><span id="2a0f" class="mu lg in ml b be mv mw l mx my">import networkx as nx<br/><br/>def graph_edit_distance(G1, G2):<br/>  # Create a mapping between the nodes of G1 and G2<br/>  mapping = {}<br/>  for node1 in G1.nodes():<br/>    min_distance = float('inf')<br/>    min_node = None<br/>    for node2 in G2.nodes():<br/>      distance = nx.shortest_path_length(G1, node1, node2)<br/>      if distance &lt; min_distance:<br/>        min_distance = distance<br/>        min_node = node2<br/>    mapping[node1] = min_node<br/>  # Calculate the number of graph edit operations needed to transform G1 into G2<br/>  num_deletions = len(G1.nodes()) - len(mapping)<br/>  num_additions = len(G2.nodes()) - len(mapping)<br/>  num_substitutions = 0<br/>  for node1, node2 in mapping.items():<br/>    if G1.degree(node1) != G2.degree(node2):<br/>      num_substitutions += 1<br/>  distance = num_deletions + num_additions + num_substitutions<br/>  return distance<br/><br/># Example usage<br/>G1 = nx.complete_graph(5)<br/>G2 = nx.path_graph(5)<br/>distance = graph_edit_distance(G1, G2)<br/>print(distance)  # Output: 5</span></pre><p id="51ab" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">下面是一个在 Julia 中使用<code class="fe mi mj mk ml b">LightGraphs</code>库的等价例子:</p><pre class="mm mn mo mp gt mq ml mr bn ms mt bi"><span id="acc7" class="mu lg in ml b be mv mw l mx my">using LightGraphs<br/><br/>function graph_edit_distance(G1, G2)<br/>  # Create a mapping between the nodes of G1 and G2<br/>  mapping = Dict{Int,Int}()<br/>  for node1 in nodes(G1)<br/>    min_distance = Inf<br/>    min_node = nothing<br/>    for node2 in nodes(G2)<br/>      distance = dijkstra_shortest_path(G1, node1, node2)<br/>      if distance &lt; min_distance<br/>        min_distance = distance<br/>        min_node = node2<br/>      end<br/>    end<br/>    mapping[node1] = min_node<br/>  end<br/>  # Calculate the number of graph edit operations needed to transform G1 into G2<br/>  num_deletions = length(nodes(G1)) - length(mapping)<br/>  num_additions = length(nodes(G2)) - length(mapping)<br/>  num_substitutions = 0<br/>  for (node1, node2) in mapping<br/>    if degree(G1, node1) != degree(G2, node2)<br/>      num_substitutions += 1<br/>    end<br/>  end<br/>  distance = num_deletions + num_additions + num_substitutions<br/>  return distance<br/>end<br/><br/># Example usage<br/>G1 = complete_graph(5)<br/>G2 = path_graph(5)<br/>distance = graph_edit_distance(G1, G2)<br/>println(distance)  # Output: 5<br/></span></pre><p id="ad5a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最后，这里是一个如何使用 R <code class="fe mi mj mk ml b">igraph</code>库计算两个图形之间的图形编辑距离的例子:</p><pre class="mm mn mo mp gt mq ml mr bn ms mt bi"><span id="7e43" class="mu lg in ml b be mv mw l mx my">library(igraph)<br/><br/>graph_edit_distance &lt;- function(G1, G2) {<br/>  # Create a mapping between the nodes of G1 and G2<br/>  mapping &lt;- integer(vcount(G1))<br/>  for (node1 in 1:vcount(G1)) {<br/>    distances &lt;- shortest.paths(G1, node1, to=V(G2))<br/>    min_distance &lt;- min(distances)<br/>    min_node &lt;- which(distances == min_distance)[1]<br/>    mapping[node1] &lt;- min_node<br/>  }<br/>  # Calculate the number of graph edit operations needed to transform G1 into G2<br/>  num_deletions &lt;- vcount(G1) - length(mapping)<br/>  num_additions &lt;- vcount(G2) - length(mapping)<br/>  num_substitutions &lt;- 0<br/>  for (node1 in 1:length(mapping)) {<br/>    if (degree(G1, node1) != degree(G2, mapping[node1])) {<br/>      num_substitutions &lt;- num_substitutions + 1<br/>    }<br/>  }<br/>  distance &lt;- num_deletions + num_additions + num_substitutions<br/>  return(distance)<br/>}<br/><br/># Example usage<br/>G1 &lt;- graph.full(5)<br/>G2 &lt;- graph.ring(5)<br/>distance &lt;- graph_edit_distance(G1, G2)<br/>print(distance)  # Output: 5<br/></span></pre><blockquote class="mz na nb"><p id="831e" class="ka kb nc kc b kd ke kf kg kh ki kj kk nd km kn ko ne kq kr ks nf ku kv kw kx ig bi translated">请注意，图表编辑距离的这种实现类似于前面示例中提供的实现，但可能在某些细节上有所不同，例如节点映射的计算方式和图表编辑操作的计数方式。</p></blockquote></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h1 id="e6d8" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">图形光谱距离</h1><p id="0320" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">这种度量基于相邻矩阵的特征值计算两个图之间的距离。这种方法适用于比较具有相似结构和节点数量的图，并且对图的连通性的变化很敏感。</p><p id="807e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">下面是一个如何使用 Python <code class="fe mi mj mk ml b">numpy</code>和<code class="fe mi mj mk ml b">scipy</code>库计算两个图之间的图谱距离的示例:</p><pre class="mm mn mo mp gt mq ml mr bn ms mt bi"><span id="df2f" class="mu lg in ml b be mv mw l mx my">import numpy as np<br/>from scipy.linalg import eigh<br/><br/>def graph_spectral_distance(G1, G2):<br/>  # Calculate the eigenvalues of the adjacency matrices of G1 and G2<br/>  adjacency_matrix1 = nx.adjacency_matrix(G1).toarray()<br/>  adjacency_matrix2 = nx.adjacency_matrix(G2).toarray()<br/>  eigenvalues1, _ = eigh(adjacency_matrix1)<br/>  eigenvalues2, _ = eigh(adjacency_matrix2)<br/>  # Calculate the spectral distance between the eigenvalue spectra<br/>  distance = np.linalg.norm(eigenvalues1 - eigenvalues2)<br/>  return distance<br/><br/># Example usage<br/>G1 = nx.complete_graph(5)<br/>G2 = nx.path_graph(5)<br/>distance = graph_spectral_distance(G1, G2)<br/>print(distance)  # Output: approximately 5.916</span></pre><p id="8e4c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">下面是一个在 Julia 中使用<code class="fe mi mj mk ml b">LinearAlgebra</code>库的等价例子:</p><pre class="mm mn mo mp gt mq ml mr bn ms mt bi"><span id="3112" class="mu lg in ml b be mv mw l mx my">using LinearAlgebra<br/><br/>function graph_spectral_distance(G1, G2)<br/>  # Calculate the eigenvalues of the adjacency matrices of G1 and G2<br/>  adjacency_matrix1 = adjacency_matrix(G1).data<br/>  adjacency_matrix2 = adjacency_matrix(G2).data<br/>  eigenvalues1 = eigen(adjacency_matrix1).values<br/>  eigenvalues2 = eigen(adjacency_matrix2).values<br/>  # Calculate the spectral distance between the eigenvalue spectra<br/>  distance = norm(eigenvalues1 - eigenvalues2)<br/>  return distance<br/>end<br/><br/># Example usage<br/>G1 = complete_graph(5)<br/>G2 = path_graph(5)<br/>distance = graph_spectral_distance(G1, G2)<br/>println(distance)  # Output: approximately 5.916</span></pre><p id="a142" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里是一个在 R 中使用<code class="fe mi mj mk ml b">igraph</code>库的例子:</p><pre class="mm mn mo mp gt mq ml mr bn ms mt bi"><span id="224c" class="mu lg in ml b be mv mw l mx my">library(igraph)<br/><br/>graph_spectral_distance &lt;- function(G1, G2) {<br/>  # Calculate the eigenvalues of the adjacency matrices of G1 and G2<br/>  adjacency_matrix1 &lt;- get.adjacency(G1)<br/>  adjacency_matrix2 &lt;- get.adjacency(G2)<br/>  eigenvalues1 &lt;- eigen(adjacency_matrix1)$values<br/>  eigenvalues2 &lt;- eigen(adjacency_matrix2)$values<br/>  # Calculate the spectral distance between the eigenvalue spectra<br/>  distance &lt;- norm(eigenvalues1 - eigenvalues2)<br/>  return(distance)<br/>}<br/><br/># Example usage<br/>G1 &lt;- graph.full(5)<br/>G2 &lt;- graph.ring(5)<br/>distance &lt;- graph_spectral_distance(G1, G2)<br/>print(distance)  # Output: approximately 5.916</span></pre></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h1 id="e1b1" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">图形卷积核</h1><p id="f59b" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">该度量通过对图邻接矩阵应用卷积运算来计算两个图之间的相似性。这种方法适用于比较具有相似结构的图，并可用于学习下游任务(如分类和回归)的图级特征，并可与基于核的学习算法(如支持向量机)结合使用。</p><p id="4425" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">以下是如何使用 Python 和<code class="fe mi mj mk ml b">pygsp</code>库计算图形卷积核的示例:</p><pre class="mm mn mo mp gt mq ml mr bn ms mt bi"><span id="f200" class="mu lg in ml b be mv mw l mx my">import pygsp<br/>import numpy as np<br/><br/>def graph_convolutional_kernel(G1, G2, sigma=1):<br/>  # Calculate the graph Laplacian matrices of G1 and G2<br/>  lap1 = pygsp.graphs.Graph(G1).L<br/>  lap2 = pygsp.graphs.Graph(G2).L<br/>  # Apply the convolutional operation to the Laplacian matrices<br/>  kernel = np.exp(-sigma * lap1).dot(np.exp(-sigma * lap2))<br/>  return kernel<br/><br/># Example usage<br/>G1 = nx.complete_graph(5)<br/>G2 = nx.path_graph(5)<br/>kernel = graph_convolutional_kernel(G1, G2)<br/>print(kernel)  # Output: approximately 0.135</span></pre><p id="4191" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">下面是一个在 Julia 中使用<code class="fe mi mj mk ml b">LightGraphs</code>和<code class="fe mi mj mk ml b">SymPy</code>库的等价例子:</p><pre class="mm mn mo mp gt mq ml mr bn ms mt bi"><span id="401b" class="mu lg in ml b be mv mw l mx my">using LightGraphs, SymPy<br/><br/>function graph_convolutional_kernel(G1, G2, sigma=1)<br/>  # Calculate the graph Laplacian matrices of G1 and G2<br/>  lap1 = laplacian_matrix(G1)<br/>  lap2 = laplacian_matrix(G2)<br/>  # Apply the convolutional operation to the Laplacian matrices<br/>  kernel = exp(-sigma * lap1) * exp(-sigma * lap2)<br/>  return kernel<br/>end<br/><br/># Example usage<br/>G1 = complete_graph(5)<br/>G2 = path_graph(5)<br/>kernel = graph_convolutional_kernel(G1, G2)<br/>println(kernel)  # Output: approximately 0.135</span></pre><p id="ad7f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里是一个在 R 中使用<code class="fe mi mj mk ml b">igraph</code>和<code class="fe mi mj mk ml b">expm</code>库的例子:</p><pre class="mm mn mo mp gt mq ml mr bn ms mt bi"><span id="93ee" class="mu lg in ml b be mv mw l mx my">library(igraph)<br/>library(expm)<br/><br/>graph_convolutional_kernel &lt;- function(G1, G2, sigma=1) {<br/>  # Calculate the graph Laplacian matrices of G1 and G2<br/>  lap1 &lt;- laplacian(G1, normalized=TRUE)<br/>  lap2 &lt;- laplacian(G2, normalized=TRUE)<br/>  # Apply the convolutional operation to the Laplacian matrices<br/>  kernel &lt;- expm(-sigma * lap1) %*% expm(-sigma * lap2)<br/>  return(kernel)<br/>}<br/><br/># Example usage<br/>G1 &lt;- graph.full(5)<br/>G2 &lt;- graph.ring(5)<br/>kernel &lt;- graph_convolutional_kernel(G1, G2)<br/>print(kernel)  # Output: approximately 0.135</span></pre><blockquote class="mz na nb"><p id="737a" class="ka kb nc kc b kd ke kf kg kh ki kj kk nd km kn ko ne kq kr ks nf ku kv kw kx ig bi translated">请注意，图卷积核的这种实现只是一种可能的方法，还有许多其他方法来定义和计算图核。</p></blockquote></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><p id="3974" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一旦计算出相似性度量，就可以在各种机器学习任务中使用它。例如，它可以用作支持向量机(SVMs)或其他基于核的学习算法中的核函数。它还可以用于图聚类算法，如 k-means 或层次聚类，以将相似的图分组在一起。</p><p id="bc56" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">除了这些传统的应用之外，图核算法还被用于最近的领域，例如图神经网络(GNNs)。gnn 是一种深度学习模型，直接对图形结构的数据进行操作，可以学习以端到端的方式从图形中提取特征。图核算法可以用于向 GNNs 提供输入，或者测量网络学习的不同图表示之间的相似性。</p><p id="da18" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">总之，图核算法是分析和比较图结构数据的强大工具，在生物信息学、社会网络分析和自然语言处理等领域具有广泛的应用。随着机器学习领域的不断发展，这些算法可能会在各种领域发挥越来越重要的作用。</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h1 id="9063" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">书籍建议</h1><p id="2de3" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">我最近有机会阅读了 Kasper Riesen 的“使用图形编辑距离的结构模式识别:近似算法和应用”，我不得不说，这真是一次令人大开眼界的经历。作为一个对计算机视觉和模式识别领域感兴趣的人，我立即被这本书对图形编辑距离及其各种应用的关注所吸引。</p><figure class="mm mn mo mp gt jo gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/ef992f649c7a8a910f5e479a7b3f1160.png" data-original-src="https://miro.medium.com/v2/resize:fit:1356/format:webp/1*mjD_XF4LLQ7dAfixrptxBQ.jpeg"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">具有图形编辑距离的结构模式识别:近似算法和应用。ISBN-13: 9783319272511</figcaption></figure><p id="66bb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">总的来说，我强烈推荐“带有图形编辑距离的结构模式识别”给任何对计算机视觉、模式识别或图论感兴趣的人。这是一本写得很好、内容丰富、引人入胜的书，为在这些领域工作的任何人提供了有价值的见解和实用工具。所以，如果你想了解更多关于图形编辑距离及其在结构模式识别中的作用，这本书绝对值得一读！</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><p id="b68f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">机器学习算法将继续…</p><p id="73c1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">感谢您阅读本文！对于任何建议，请留下评论！</p><p id="a966" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><a class="ae jz" href="https://www.linkedin.com/in/mertdemir0" rel="noopener ugc nofollow" target="_blank"> Linkedin </a> <a class="ae jz" href="https://www.mertdemir.org" rel="noopener ugc nofollow" target="_blank">网站</a> <a class="ae jz" href="https://www.github.com/mertdemir0" rel="noopener ugc nofollow" target="_blank"> Github </a></p><p id="75c7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">电子邮件:info@mertdemir.org</p></div></div>    
</body>
</html>