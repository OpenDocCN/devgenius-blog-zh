<html>
<head>
<title>What does it mean for a class to be immutable in Java?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java 中一个类不可变是什么意思？</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/what-does-it-mean-for-a-class-to-be-immutable-in-java-e3cd3886678c?source=collection_archive---------2-----------------------#2021-04-07">https://blog.devgenius.io/what-does-it-mean-for-a-class-to-be-immutable-in-java-e3cd3886678c?source=collection_archive---------2-----------------------#2021-04-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/0ca9ba8a0eb601f81fa32b4a2c7e5a0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JF5AG5q0ptaG02SBJhT7RQ.png"/></div></div></figure><p id="360d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当您想到 Java 中的不变性时，应该想到一组核心概念。</p><p id="6f4f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本文中，我将列举一些要点，希望您能更好地理解在 Java 中如何实现不可变。</p><h1 id="2c94" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">不可变意味着它的状态不能改变</h1><p id="aa69" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">Java 中高层次的不变性本质上意味着它在英语中的不变性。换句话说，Java 里不可变的东西是不能变的。</p><p id="b6b1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在 Java 中，这意味着不可变对象的内容或状态不能被改变。语言不允许。</p><h1 id="22be" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">该类应被声明为最终类</h1><p id="5d19" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">这样做的原因是因为在 Java 中，类是可以扩展的。类声明中的关键字<code class="fe lz ma mb mc b">final</code>使得类<em class="md">不能被</em>扩展。换句话说，改变不了。</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mi mj l"/></div></figure><h1 id="faa4" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">类中的所有字段都必须有 private 关键字</h1><p id="cb9c" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">这意味着不再简单地声明变量，<code class="fe lz ma mb mc b">private</code>关键字需要放在变量之前。</p><p id="0e96" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这使得变量不能被直接访问。直接访问的能力会将不变性置于危险之中，因为这样访问者就可以更改它。</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mi mj l"/></div></figure><h1 id="1c2f" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">类中的所有字段都必须有<code class="fe lz ma mb mc b">final</code>关键字</h1><p id="b272" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">这意味着所有字段或数据成员前面都必须有关键字<code class="fe lz ma mb mc b">final</code>和前面部分的<code class="fe lz ma mb mc b">private</code>。</p><p id="800b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe lz ma mb mc b">final</code>使得一旦变量的值被声明，就不能改变。这与类声明中的<code class="fe lz ma mb mc b">final</code>是同一个关键字，工作原理也差不多。</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mi mj l"/></div></figure><h1 id="a566" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">类中的所有字段都必须用执行深度复制的构造函数进行初始化</h1><p id="b849" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">这并不像听起来那么糟糕。</p><p id="af11" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在类中，您只需创建一个构造函数(将类名及其数据成员作为参数)，将数据成员分配给它的<code class="fe lz ma mb mc b">this</code>值:</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="863b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这使得数据成员不会被对象引用意外修改。</p><h1 id="d0cc" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">所有 getter 方法都需要执行可变对象的深度复制</h1><p id="2b25" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">当 getters 在类中时，它们必须使用 Java 中的<code class="fe lz ma mb mc b">clone()</code>对任何可变的对象执行深度复制。</p><p id="f2be" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们看看我作为例子使用的<code class="fe lz ma mb mc b">Dog</code>类会是什么样子。</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="b4fd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">嗯。这看起来没什么不同。</p><p id="d037" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里的问题是<code class="fe lz ma mb mc b">String</code>在 Java 中已经是一个默认不可变的对象。你不必担心深度复制它，因为根据 Java 的定义，它是不可更改的。</p><p id="7e7a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">嗯，它<em class="md">可以</em>，但是如果你改变它的值，Java 会创建一个新的对象在后台存储新的值。原始<em class="md">对象</em>从不改变。</p><p id="3733" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">无论如何，回到<code class="fe lz ma mb mc b">String</code>是不可变的。Java 里还有什么是默认不可变的？</p><h2 id="69f5" class="mk kx iq bd ky ml mm dn lc mn mo dp lg kj mp mq lk kn mr ms lo kr mt mu ls mv bi translated">字符串、整数、布尔和包装类是不可变的</h2><p id="4146" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">在 Java 中，有许多包装类:</p><ul class=""><li id="1dd6" class="mw mx iq ka b kb kc kf kg kj my kn mz kr na kv nb nc nd ne bi translated"><code class="fe lz ma mb mc b">String</code></li><li id="f7a8" class="mw mx iq ka b kb nf kf ng kj nh kn ni kr nj kv nb nc nd ne bi translated"><code class="fe lz ma mb mc b">Integer</code></li><li id="bb43" class="mw mx iq ka b kb nf kf ng kj nh kn ni kr nj kv nb nc nd ne bi translated"><code class="fe lz ma mb mc b">Boolean</code></li><li id="055f" class="mw mx iq ka b kb nf kf ng kj nh kn ni kr nj kv nb nc nd ne bi translated"><code class="fe lz ma mb mc b">Character</code></li><li id="eaa7" class="mw mx iq ka b kb nf kf ng kj nh kn ni kr nj kv nb nc nd ne bi translated"><code class="fe lz ma mb mc b">Short</code></li><li id="fe1f" class="mw mx iq ka b kb nf kf ng kj nh kn ni kr nj kv nb nc nd ne bi translated"><code class="fe lz ma mb mc b">Float</code></li><li id="6df1" class="mw mx iq ka b kb nf kf ng kj nh kn ni kr nj kv nb nc nd ne bi translated"><code class="fe lz ma mb mc b">Double</code></li><li id="bc7b" class="mw mx iq ka b kb nf kf ng kj nh kn ni kr nj kv nb nc nd ne bi translated"><code class="fe lz ma mb mc b">Long</code></li><li id="78e9" class="mw mx iq ka b kb nf kf ng kj nh kn ni kr nj kv nb nc nd ne bi translated"><code class="fe lz ma mb mc b">Byte</code></li></ul><p id="8ee4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在 Java 中，这些都被认为是不可变的，所以你不需要担心在你创建的任何不可变类中深度复制它们。</p><h1 id="f3ad" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">不可变类不能有 setters</h1><p id="0868" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">你在可变类中看到的 setter 方法不能出现在不可变类中。毕竟，我们在 Java 中对不可变的定义依赖于不能被改变的对象。设置不能改变的东西是没有意义的，因此你可以很容易地记住，当涉及到不可变的类时，setters 应该被排除在外。</p><div class="nk nl gp gr nm nn"><a href="https://tremaineeto.medium.com/membership" rel="noopener follow" target="_blank"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd ir gy z fp ns fr fs nt fu fw ip bi translated">通过我的推荐链接加入媒体</h2><div class="nu l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">tremaineeto.medium.com</p></div></div><div class="nw l"><div class="nx l ny nz oa nw ob jw nn"/></div></div></a></div></div></div>    
</body>
</html>