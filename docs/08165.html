<html>
<head>
<title>React Context API: Getting Started</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React 上下文 API:入门</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/react-context-api-getting-started-6f396866bbfe?source=collection_archive---------8-----------------------#2022-05-22">https://blog.devgenius.io/react-context-api-getting-started-6f396866bbfe?source=collection_archive---------8-----------------------#2022-05-22</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="95f9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">React 的上下文 API 是 React 内置的一个方便的工具，它允许您以一种简单明了的方式在组件之间共享您的状态。例如:</p><ul class=""><li id="bc6a" class="ki kj in jm b jn jo jr js jv kk jz kl kd km kh kn ko kp kq bi translated">当您的状态在父组件中定义，但在深度嵌套的组件中需要时。或者，</li><li id="4fa3" class="ki kj in jm b jn kr jr ks jv kt jz ku kd kv kh kn ko kp kq bi translated">您可能有许多组件都需要的状态，导致需要多次重复代码</li></ul><p id="289c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Context 允许您神奇地将数据传输到任何需要的地方，而不需要钻取(通过许多组件传递数据，只是为了将数据传递到一个深度嵌套的组件)。</p><p id="68f5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">context API 经常被比作<code class="fe kw kx ky kz b">Redux.</code> Redux，然而，它是一个更健壮的状态管理库，提供了许多功能来帮助管理您的状态，包括但不限于 Redux devtools，以及修改您的状态的简单方法。Redux 也在幕后使用了上下文 API。这并不意味着你只能使用其中的一个。在同一个应用程序中使用 Context API 和 Redux 的 react 应用程序很常见，但用于不同的状态需求。</p><p id="c114" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">本文是关于如何开始使用功能组件的上下文 API。你只需要知道反应的基本原理就可以了。</p><p id="8205" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">假设我们有一个非常简单的应用程序，TodoManager，其代码库如下:</p><figure class="lb lc ld le gt lf gh gi paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="gh gi la"><img src="../Images/6dd9f512ba7bab27ed3a69bfd8cd47d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0yNCEnEaoeU9fG0pw9rq3g.png"/></div></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk translated">React 中的支柱钻孔示例</figcaption></figure><p id="1c08" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在代码中，我有三个组件。App 是顶级父组件。List 用于呈现待办事项列表。Todo 处理单个 todo 将如何显示。</p><p id="339d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在<code class="fe kw kx ky kz b">App</code>父组件中，定义了两个状态，<code class="fe kw kx ky kz b">color</code>和<code class="fe kw kx ky kz b">done.</code>这两个状态在列表组件中不是必需的，但在<code class="fe kw kx ky kz b">Todo</code>组件中是必需的。目前，我们使用 prop-drilling 将这些状态片段传递给中间的所有组件，只是为了将该状态传递给底层组件。这可能很难管理，尤其是如果代码库很大并且逻辑更复杂的话。这就是<code class="fe kw kx ky kz b">context</code>的用武之地。我们可以重构上面的应用程序，这样我们就不必通过不必要的组件传递<code class="fe kw kx ky kz b">done</code>和<code class="fe kw kx ky kz b">color</code>。相反，我们将在需要的地方直接消费它们。</p></div><div class="ab cl lq lr hr ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ig ih ii ij ik"><h1 id="d8d9" class="lx ly in bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">如何使用上下文</h1><p id="5fc1" class="pw-post-body-paragraph jk jl in jm b jn mv jp jq jr mw jt ju jv mx jx jy jz my kb kc kd mz kf kg kh ig bi translated">下面是使用 react 的上下文 API 时要遵循的步骤。</p><h2 id="7ee8" class="na ly in bd lz nb nc dn md nd ne dp mh jv nf ng ml jz nh ni mp kd nj nk mt nl bi translated">第一步。创建上下文</h2><p id="031f" class="pw-post-body-paragraph jk jl in jm b jn mv jp jq jr mw jt ju jv mx jx jy jz my kb kc kd mz kf kg kh ig bi translated">这是通过<code class="fe kw kx ky kz b">createContext</code>函数实现的，该函数接受一个可选的默认值。在本例中，我为<code class="fe kw kx ky kz b">color</code>信息构建了一个上下文。默认值为蓝色。</p><figure class="lb lc ld le gt lf gh gi paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="gh gi nm"><img src="../Images/c14f08c6c2b1c984e3b7a4dd948199be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nhAPgDIW7IVK2cN7cZqAlQ.png"/></div></div></figure><p id="8e75" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">CreateContext 确实如其名。它还返回包含两个关键部分的 object:<code class="fe kw kx ky kz b">Provider</code>和<code class="fe kw kx ky kz b">Consumer</code>。这些将在下面的章节中讨论。</p><h2 id="d986" class="na ly in bd lz nb nc dn md nd ne dp mh jv nf ng ml jz nh ni mp kd nj nk mt nl bi translated">第二步:利用上下文</h2><p id="9486" class="pw-post-body-paragraph jk jl in jm b jn mv jp jq jr mw jt ju jv mx jx jy jz my kb kc kd mz kf kg kh ig bi translated">有了上面创建的上下文，现在我们可以在实际需要<code class="fe kw kx ky kz b">color</code>的子组件中使用上下文。</p><p id="5e27" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这样，代码看起来像这样:</p><figure class="lb lc ld le gt lf gh gi paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="gh gi nn"><img src="../Images/712b88b0ee4f71923f46fc1eb3945aba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0mwNdmzfbf7qJuI3Qb1Myg.png"/></div></div></figure><p id="5efb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">请注意，我不再将<code class="fe kw kx ky kz b">color</code>传递给<code class="fe kw kx ky kz b">List</code>。<code class="fe kw kx ky kz b">Todo</code>组件现在直接调用<code class="fe kw kx ky kz b">useContext</code>来访问上下文值。</p><p id="51c2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe kw kx ky kz b">useContext</code>是一个方便的钩子，允许任何组件访问颜色上下文值。</p><p id="b820" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">此刻，所有的任务都有一个颜色<code class="fe kw kx ky kz b">blue</code>，这是我们指定的默认值。您可以将默认值视为一个后备选项。当消费组件(在本例中为 Todo)没有包装在<code class="fe kw kx ky kz b">Provider</code>组件中时，React 将使用这个值。因此，默认值当前是静态的，不能从上下文文件外部更改。</p><h1 id="d43d" class="lx ly in bd lz ma no mc md me np mg mh mi nq mk ml mm nr mo mp mq ns ms mt mu bi translated">提供商和消费者</h1><p id="fb9a" class="pw-post-body-paragraph jk jl in jm b jn mv jp jq jr mw jt ju jv mx jx jy jz my kb kc kd mz kf kg kh ig bi translated">您将使用上下文值的<code class="fe kw kx ky kz b">child components</code>包装在<code class="fe kw kx ky kz b">Provider</code>组件中。这允许子节点订阅上下文值。这意味着当上下文值改变时，子元素会自动更新。<code class="fe kw kx ky kz b">Provider</code>组件接受一个<code class="fe kw kx ky kz b">value</code>属性，该属性定义了您希望与消费的子组件共享的数据。</p><figure class="lb lc ld le gt lf gh gi paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="gh gi nm"><img src="../Images/49b6b644b65a523e48a432d4f13b7254.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L4MHh40E4bUahWB8TfFOTw.png"/></div></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk translated">使用提供程序组件</figcaption></figure><p id="3fe7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因为我们用提供者组件包装了<code class="fe kw kx ky kz b">List</code>组件，所以<code class="fe kw kx ky kz b">List</code>的任何子组件现在都可以访问 ColorContext 中的任何值。</p><p id="c795" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">提醒一下，这是<code class="fe kw kx ky kz b">Todo</code>组件的样子:</p><figure class="lb lc ld le gt lf gh gi paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="gh gi nt"><img src="../Images/892ec1ddfa19cf6f82f53730259d0159.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Dk_uqc4j2oWGTi0srqasYQ.png"/></div></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk translated">消费语境</figcaption></figure><p id="9d66" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，todos 根据<code class="fe kw kx ky kz b">done</code>的值在绿色和黑色之间切换，这是由顶级 App 组件确定的。</p><p id="953b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对于提供者如何工作，一个简单的心理模型是考虑 CSS 继承。如果有一个顶级的<code class="fe kw kx ky kz b">div</code>包装在其他元素周围，那么这些元素就会呈现在顶级 div 中定义的任何颜色。每当您更改 div 颜色时，它内部的元素也会更改以匹配它们的父 div。</p><h2 id="0631" class="na ly in bd lz nb nc dn md nd ne dp mh jv nf ng ml jz nh ni mp kd nj nk mt nl bi translated">旁注…</h2><p id="6422" class="pw-post-body-paragraph jk jl in jm b jn mv jp jq jr mw jt ju jv mx jx jy jz my kb kc kd mz kf kg kh ig bi translated">我们之前提到过<code class="fe kw kx ky kz b">Consumer</code>组件。这是消费上下文的“遗留”方式。不使用方便的<code class="fe kw kx ky kz b">useContext</code>，代码应该是这样的:</p><figure class="lb lc ld le gt lf gh gi paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="gh gi nt"><img src="../Images/9fd15324e2cd867f8c119517071ab5ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-QtNBrmYByy5MkHA0n13Cg.png"/></div></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk translated">使用消费者组件</figcaption></figure><p id="943c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您用<code class="fe kw kx ky kz b">ColorContext.Consumer</code>包装代码，然后使用<code class="fe kw kx ky kz b">renderProps</code>从上下文提供者中“提取”值。然而，这是一种古老的做事方式，你应该使用<code class="fe kw kx ky kz b">useContext.</code></p></div><div class="ab cl lq lr hr ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ig ih ii ij ik"><h1 id="30ff" class="lx ly in bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">上下文 API 和自定义挂钩</h1><p id="5fb1" class="pw-post-body-paragraph jk jl in jm b jn mv jp jq jr mw jt ju jv mx jx jy jz my kb kc kd mz kf kg kh ig bi translated">我最喜欢的使用上下文 API 的方式是通过一个定制的钩子。在每个需要上下文值的地方调用<code class="fe kw kx ky kz b">useContext()</code>都很好，但是我更喜欢调用一次，并在子组件中使用自定义钩子，正如我们将看到的。</p><p id="a1d2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在 React 中，定制钩子的全部目的是避免重复你自己。当您有一些在不同组件中不断重复的状态逻辑时，您知道是时候将它放入一个自定义钩子中了。这使得您的代码更整洁，更易于维护，因为您的状态逻辑是在一个地方定义的，因此易于修改和/或维护。</p><p id="5d5e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在前面的代码中，我们仍然通过列表组件将<code class="fe kw kx ky kz b">done</code>状态“钻取”到 Todo。我们将改变这一事实。</p><h2 id="d90f" class="na ly in bd lz nb nc dn md nd ne dp mh jv nf ng ml jz nh ni mp kd nj nk mt nl bi translated">步骤 1:创建一个“增强的”提供者组件</h2><p id="156a" class="pw-post-body-paragraph jk jl in jm b jn mv jp jq jr mw jt ju jv mx jx jy jz my kb kc kd mz kf kg kh ig bi translated">在 ColorContext.js 文件中，我将创建一个定制的 provider 组件。提供者组件现在将处理<code class="fe kw kx ky kz b">color</code>和<code class="fe kw kx ky kz b">done</code>状态，以及我将来可能添加的任何其他状态。因此，我将把它从<code class="fe kw kx ky kz b">ColorContext</code>重命名为<code class="fe kw kx ky kz b">StatusContext</code>，因为它现在处理的不仅仅是颜色方面。</p><figure class="lb lc ld le gt lf gh gi paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="gh gi nu"><img src="../Images/30aa0d713f094c39a369e3a9632989a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q3v9_ir4E2_YqaKMrpaUAg.png"/></div></div></figure><p id="db3e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我已经声明了我的状态片段和它们的逻辑，然后通过调用真正的<code class="fe kw kx ky kz b">Provider</code>组件并将这些状态和处理程序传递到<code class="fe kw kx ky kz b">value</code> prop 中来返回它们。</p><h2 id="6699" class="na ly in bd lz nb nc dn md nd ne dp mh jv nf ng ml jz nh ni mp kd nj nk mt nl bi translated">步骤 2:用提供者包装必要的孩子</h2><p id="8059" class="pw-post-body-paragraph jk jl in jm b jn mv jp jq jr mw jt ju jv mx jx jy jz my kb kc kd mz kf kg kh ig bi translated">在我们的例子中，甚至父组件<code class="fe kw kx ky kz b">App</code>也依赖于上下文，因为它拥有<code class="fe kw kx ky kz b">done</code>复选框。因此，我将调用条目文件 index.js 中的提供者。</p><figure class="lb lc ld le gt lf gh gi paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="gh gi nu"><img src="../Images/10a6809bdcd78150cd65b9232967a2a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PTeVaWcB6lADayovRO_-mw.png"/></div></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk translated">用提供者包装应用程序组件</figcaption></figure><p id="6a0f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，我们在<code class="fe kw kx ky kz b">StatusProvider</code>组件中返回的所有内容在整个应用程序中都是可用的。此时，您可以通过调用子级中的 useContext 来读取上下文值。一种更简单、更干净的方法是为此定义一个自定义钩子。</p><figure class="lb lc ld le gt lf gh gi paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="gh gi nv"><img src="../Images/823a35f4669c39d1629f27d738a23a6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lHeciBGa7Px0vpXYrYfmfQ.png"/></div></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk translated">上下文自定义挂钩</figcaption></figure><p id="c612" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这也允许您进行一些错误处理。如果您忘记用<code class="fe kw kx ky kz b">StatusProvider</code>包装子组件，然后仍然从任何子组件中调用<code class="fe kw kx ky kz b">useCount hook</code>，您将在控制台中得到以下错误:</p><figure class="lb lc ld le gt lf gh gi paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="gh gi nw"><img src="../Images/a3ca4466c6e37d6b864343c5431be919.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WJpn8HtjwrBI9seftRBfXw.png"/></div></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk translated">上下文错误消息</figcaption></figure><h2 id="3dd3" class="na ly in bd lz nb nc dn md nd ne dp mh jv nf ng ml jz nh ni mp kd nj nk mt nl bi translated">步骤 3:使用自定义挂钩</h2><p id="4d52" class="pw-post-body-paragraph jk jl in jm b jn mv jp jq jr mw jt ju jv mx jx jy jz my kb kc kd mz kf kg kh ig bi translated">现在访问上下文值很容易。用<code class="fe kw kx ky kz b">StatusProvider</code>包装<code class="fe kw kx ky kz b">App</code>组件保证了您可以从 react 应用程序中的任何地方访问上下文值。如果您的上下文值是整个应用程序都需要的值，这可能会很方便。例如，诸如用户是否登录、他们的用户名等认证值。</p><p id="97da" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们组件的最终状态:</p><figure class="lb lc ld le gt lf gh gi paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="gh gi nx"><img src="../Images/1b73c9b3e1df2d5e7828c1c9f1fb2841.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zgplc2TCpag_zBWCwgRhiA.png"/></div></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk translated">App.js 中的自定义挂钩</figcaption></figure><p id="1bd9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe kw kx ky kz b">useStatus</code>钩子返回一个包含三个值的对象，<code class="fe kw kx ky kz b">done,</code> <code class="fe kw kx ky kz b">color,</code>和<code class="fe kw kx ky kz b">handleDone.</code>只要需要这些值，我们就调用钩子和<a class="ae ny" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment" rel="noopener ugc nofollow" target="_blank">析构函数</a>我们需要的任何属性。</p><h1 id="017d" class="lx ly in bd lz ma no mc md me np mg mh mi nq mk ml mm nr mo mp mq ns ms mt mu bi translated">结论</h1><p id="675f" class="pw-post-body-paragraph jk jl in jm b jn mv jp jq jr mw jt ju jv mx jx jy jz my kb kc kd mz kf kg kh ig bi translated">在本文中，我们讨论了如何用<code class="fe kw kx ky kz b">createContext </code>创建上下文，以及如何用<code class="fe kw kx ky kz b">context.Provider</code>向孩子提供上下文。我们还看到了如何使用<code class="fe kw kx ky kz b">useContext </code> hook 或遗留<code class="fe kw kx ky kz b">context.Consumer</code>组件来使用上下文。最后，我们看了如何使用带有自定义钩子的上下文。</p></div></div>    
</body>
</html>