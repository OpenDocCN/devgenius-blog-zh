<html>
<head>
<title>Object-Oriented Programming in Kotlin [OOP in Kotlin — 2022]</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kotlin 中的面向对象编程[kot Lin 中的 OOP—2022]</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/object-oriented-programming-in-kotlin-oop-in-kotlin-2022-90dea0f5776c?source=collection_archive---------1-----------------------#2022-01-26">https://blog.devgenius.io/object-oriented-programming-in-kotlin-oop-in-kotlin-2022-90dea0f5776c?source=collection_archive---------1-----------------------#2022-01-26</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/b02f14d70b8326e17f2526560ca38b90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zgRPfOuJ2vUaNGN3ngP-PQ.jpeg"/></div></div></figure><blockquote class="jv jw jx"><p id="bed4" class="jy jz ka kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">内容:- </strong></p></blockquote><ol class=""><li id="2c1f" class="kx ky in kb b kc kd kg kh kz la lb lc ld le kw lf lg lh li bi translated"><strong class="kb io"> <em class="ka">类</em> </strong> <em class="ka">和</em> <strong class="kb io"> <em class="ka">对象</em> </strong> <em class="ka">。</em></li><li id="7b78" class="kx ky in kb b kc lj kg lk kz ll lb lm ld ln kw lf lg lh li bi translated"><strong class="kb io"> <em class="ka">构造函数</em> </strong> <em class="ka"> :-默认，参数化，主，次。</em></li><li id="5525" class="kx ky in kb b kc lj kg lk kz ll lb lm ld ln kw lf lg lh li bi translated"><strong class="kb io"> <em class="ka">多态</em> </strong> <em class="ka"> :-运行时和编译时。</em></li><li id="ec25" class="kx ky in kb b kc lj kg lk kz ll lb lm ld ln kw lf lg lh li bi translated"><strong class="kb io"> <em class="ka">继承</em> </strong> <em class="ka"> :-继承的类型。</em></li><li id="7032" class="kx ky in kb b kc lj kg lk kz ll lb lm ld ln kw lf lg lh li bi translated"><em class="ka">为什么不允许多重继承？→ </em> <strong class="kb io"> <em class="ka">钻石问题</em> </strong></li><li id="68dc" class="kx ky in kb b kc lj kg lk kz ll lb lm ld ln kw lf lg lh li bi translated"><strong class="kb io"> <em class="ka">界面</em> </strong></li><li id="1901" class="kx ky in kb b kc lj kg lk kz ll lb lm ld ln kw lf lg lh li bi translated"><em class="ka">类的类型:</em> <strong class="kb io"> <em class="ka">数据</em> </strong> <em class="ka">类，</em> <strong class="kb io"> <em class="ka">枚举</em> </strong> <em class="ka">类，</em> <strong class="kb io"> <em class="ka">密封</em> </strong> <em class="ka">类，</em> <strong class="kb io"> <em class="ka">单体</em> </strong> <em class="ka">类，</em> <strong class="kb io"> <em class="ka">抽象</em></strong></li><li id="26a8" class="kx ky in kb b kc lj kg lk kz ll lb lm ld ln kw lf lg lh li bi translated"><strong class="kb io"> <em class="ka">抽象</em> </strong> <em class="ka">。</em></li><li id="0750" class="kx ky in kb b kc lj kg lk kz ll lb lm ld ln kw lf lg lh li bi translated"><strong class="kb io"> <em class="ka">封装</em> </strong> <em class="ka"> :-包，访问修饰符</em></li><li id="1809" class="kx ky in kb b kc lj kg lk kz ll lb lm ld ln kw lf lg lh li bi translated"><em class="ka">抽象类</em><strong class="kb io"><em class="ka">VS</em></strong><em class="ka">接口</em></li></ol></div><div class="ab cl lo lp hr lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ig ih ii ij ik"><blockquote class="jv jw jx"><p id="fdd1" class="jy jz ka kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">面向对象编程</strong> (OOP)就是创建一个模板(不占用宇宙中任何空间)和那些模板的对象(占用空间)。</p></blockquote><p id="1309" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kz kl km kn lb kp kq kr ld kt ku kv kw ig bi translated">示例:-</p><ol class=""><li id="7a55" class="kx ky in kb b kc kd kg kh kz la lb lc ld le kw lf lg lh li bi translated">假设我们要造一辆汽车，那么首先我们要做一个名为<strong class="kb io"> <em class="ka">的设计类</em> </strong>和名为<strong class="kb io"> <em class="ka">的真实汽车对象</em> </strong>。</li></ol><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lv"><img src="../Images/4ac274f54dc02f42f2bb759492f6331a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m7wc8L2eafHq38urbOjJTQ.jpeg"/></div></div></figure><p id="0181" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kz kl km kn lb kp kq kr ld kt ku kv kw ig bi translated"><strong class="kb io">类:- </strong></p><p id="0848" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kz kl km kn lb kp kq kr ld kt ku kv kw ig bi translated">这是一辆汽车的<strong class="kb io"> <em class="ka">蓝图</em> </strong>，不占用宇宙空间。</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ma"><img src="../Images/efd01e140522a134a7d4036a595a3c9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4lZ9H6dz-ObJ9zM_"/></div></div></figure><p id="a604" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kz kl km kn lb kp kq kr ld kt ku kv kw ig bi translated"><strong class="kb io">对象</strong> :-</p><p id="c648" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kz kl km kn lb kp kq kr ld kt ku kv kw ig bi translated">这是<strong class="kb io"> <em class="ka">真正的</em> </strong>车，它占据宇宙空间。</p></div><div class="ab cl lo lp hr lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ig ih ii ij ik"><p id="4d3d" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kz kl km kn lb kp kq kr ld kt ku kv kw ig bi translated">我们在编程中应用的类似概念是创建蓝图，然后从这些蓝图中创建产品。</p><blockquote class="jv jw jx"><p id="3e11" class="jy jz ka kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io"> <em class="in">在 Kotlin 中创建类和对象:- </em> </strong></p></blockquote><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mb"><img src="../Images/e9467dbc8c9593a94f4eedcda0e1b2df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sWobHmL38li4Fby-Syuw2Q.jpeg"/></div></div></figure><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mc"><img src="../Images/8fdbfca261a20a048d03635a3ddc86d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F6cuMt7XbGqg8JSQ1ombIA.jpeg"/></div></div></figure><p id="7fbd" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kz kl km kn lb kp kq kr ld kt ku kv kw ig bi translated">输出:-</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi md"><img src="../Images/7b50e91c69cb93a103e5b515ad3c04dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2J0seUtgGuGbZamvWk9feg.jpeg"/></div></div></figure></div><div class="ab cl lo lp hr lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ig ih ii ij ik"><blockquote class="jv jw jx"><p id="2483" class="jy jz ka kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">2.<strong class="kb io"> <em class="in">构造函数:- </em> </strong>在上面的程序中，我们在创建对象后访问并分配内存给变量，但是如果我们想在创建对象时这样做，我们就使用构造函数。</p></blockquote><p id="3336" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kz kl km kn lb kp kq kr ld kt ku kv kw ig bi translated">2.1.<strong class="kb io"> <em class="ka">默认构造函数</em> </strong> :-</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi me"><img src="../Images/d32c8c1b743cbf9b2f5685285a24d628.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EeqGb3aF8I1yWJR8Kcesrw.png"/></div></div></figure><p id="59fd" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kz kl km kn lb kp kq kr ld kt ku kv kw ig bi translated"><strong class="kb io"> <em class="ka"> init </em> </strong>调用:- <strong class="kb io"> <em class="ka"> init </em> </strong>是一种构造函数，我们在创建对象时调用它-self。让我们通过使用 init 来计算一个类创建的对象的数量来理解。在这里，我们将使用<strong class="kb io"> <em class="ka">伴随对象</em></strong>:——这意味着<em class="ka">项</em> <em class="ka">对所有对象都是通用的，并且只能由类</em>访问。</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mf"><img src="../Images/47b6c2a13d1f54a8637ef0628579980e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vu2LxADBtW7G_9lgMrsfLA.png"/></div></div></figure><p id="f500" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kz kl km kn lb kp kq kr ld kt ku kv kw ig bi translated"><strong class="kb io"> <em class="ka">伴侣对象:- </em> </strong></p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mg"><img src="../Images/e15946f37ec3ded43a17e7c726fac555.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RYo4T01AMGgdVzgdiQbVcg.png"/></div></div></figure><p id="1ab6" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kz kl km kn lb kp kq kr ld kt ku kv kw ig bi translated">在上面的例子中，n 变量只能被类访问，而不能被它的对象访问。</p><p id="0a3a" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kz kl km kn lb kp kq kr ld kt ku kv kw ig bi translated">这里，当我们试图使用类对象访问类变量时，它给出了错误。</p><p id="b8e8" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kz kl km kn lb kp kq kr ld kt ku kv kw ig bi translated">2.2 ( <em class="ka">参数化)</em> <strong class="kb io"> <em class="ka">一级建造师</em> </strong> :-</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mh"><img src="../Images/0b9cf39bfdababff4d08d2f334917fdf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5Y16n23zdOAjMzD4q6eryQ.jpeg"/></div></div></figure><p id="8ca2" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kz kl km kn lb kp kq kr ld kt ku kv kw ig bi translated">2.3 <strong class="kb io"> <em class="ka">二级建造师</em> </strong> :-</p><p id="397f" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kz kl km kn lb kp kq kr ld kt ku kv kw ig bi translated"><strong class="kb io"> <em class="ka">注意</em> </strong> :- <em class="ka"> val </em>或<em class="ka"> var </em>不允许出现在二级构造函数参数中。</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mi"><img src="../Images/7da59270231160add64bc1bd213cea5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TYbsUtw1To1YH3s52tWzzw.png"/></div></div></figure><p id="8dfd" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kz kl km kn lb kp kq kr ld kt ku kv kw ig bi translated">在这里，<strong class="kb io"> <em class="ka">油耗</em> </strong>是我们想在某些车上拥有的附加值。<strong class="kb io">比如</strong>:——对于<strong class="kb io">奥迪</strong>我们没有<strong class="kb io"> <em class="ka">油耗</em> </strong>所以我们叫一级构造师，对于<strong class="kb io">宝马</strong>我们有<strong class="kb io"> <em class="ka">油耗</em> </strong>所以我们叫二级构造师。</p><p id="fe17" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kz kl km kn lb kp kq kr ld kt ku kv kw ig bi translated">注意:-如果主构造函数没有默认值，则次构造函数必须使用“<strong class="kb io"> <em class="ka"> this </em> </strong>”调用主构造函数。</p><p id="c5b9" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kz kl km kn lb kp kq kr ld kt ku kv kw ig bi translated">因此，在上面的代码中，我们从次要构造函数调用主要构造函数来获取剩余的值。</p></div><div class="ab cl lo lp hr lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ig ih ii ij ik"><blockquote class="jv jw jx"><p id="8235" class="jy jz ka kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io"> <em class="in"> 3。多态性:- </em> </strong></p></blockquote><p id="4fbd" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kz kl km kn lb kp kq kr ld kt ku kv kw ig bi translated"><strong class="kb io"> <em class="ka"> 3.1 编译时多态性:- </em> </strong>当我们有不同类型的构造函数，它们具有相同的名称，但是:-</p><p id="5a65" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kz kl km kn lb kp kq kr ld kt ku kv kw ig bi translated"><strong class="kb io">一个</strong>。<strong class="kb io">不同的参数列表</strong>。</p><p id="9635" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kz kl km kn lb kp kq kr ld kt ku kv kw ig bi translated">→ <em class="ka">重要</em> :-在主构造函数中，参数中的所有属性都必须初始化。</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mj"><img src="../Images/70149f4d2c6e70f950d299a3db52d5d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eiVb6Q9TR9rUI2C7CfBirA.png"/></div></div></figure><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mk"><img src="../Images/5511256153aab7de4718aaa4aa51f186.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7yUoi0mN45RJeozbqceo_w.jpeg"/></div></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">输出:-注意[每次都会调用 init 块]</figcaption></figure><p id="10ed" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kz kl km kn lb kp kq kr ld kt ku kv kw ig bi translated"><strong class="kb io"> B .主要论点+附加论点。</strong></p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mp"><img src="../Images/8697d5e587e350da1e4e9bf7e2b5fcdf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cUt1Y8FRuTvmtOKn4KZk2Q.jpeg"/></div></div></figure><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mq"><img src="../Images/06756454cb367cf804a35fa5882fb1c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9-1X7hdW8tzzZ_Bq_Xukbg.jpeg"/></div></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">输出</figcaption></figure><p id="9ef1" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kz kl km kn lb kp kq kr ld kt ku kv kw ig bi translated"><strong class="kb io"> <em class="ka"> 3.2 运行时多态性:- </em> </strong></p><p id="40ec" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kz kl km kn lb kp kq kr ld kt ku kv kw ig bi translated">在理解这一点之前，我们需要理解<strong class="kb io">继承</strong>。</p></div><div class="ab cl lo lp hr lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ig ih ii ij ik"><blockquote class="jv jw jx"><p id="bcc2" class="jy jz ka kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io"> <em class="in"> 4。继承:- </em> </strong> <em class="in">表示继承其子节点中的父属性，子节点除了父属性之外还可以有其他属性。</em></p></blockquote><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/07e3aaf0d361cadff63fea45a1a2b6f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*wYRW7PZIuIcCHbqxCXEHKQ.png"/></div></figure><p id="90bd" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kz kl km kn lb kp kq kr ld kt ku kv kw ig bi translated"><strong class="kb io"> <em class="ka">一些关键词</em> </strong> :-</p><ol class=""><li id="4ee7" class="kx ky in kb b kc kd kg kh kz la lb lc ld le kw lf lg lh li bi translated"><strong class="kb io"> <em class="ka"> open </em> </strong> →要继承任何类，我们必须使它开放，因为在 Kotlin 中，默认情况下每个类都是公共的和最终的。</li><li id="5b61" class="kx ky in kb b kc lj kg lk kz ll lb lm ld ln kw lf lg lh li bi translated"><strong class="kb io"> <em class="ka">超级</em> </strong> →它调用我们当前所在班级的上层。</li><li id="4af5" class="kx ky in kb b kc lj kg lk kz ll lb lm ld ln kw lf lg lh li bi translated"><strong class="kb io"> <em class="ka">覆盖</em> </strong> →用于从子类改变/覆盖父类的任何函数或变量的功能。</li><li id="96cb" class="kx ky in kb b kc lj kg lk kz ll lb lm ld ln kw lf lg lh li bi translated"><strong class="kb io"> <em class="ka"> private </em> </strong> →用于使任何项目只能在该类中访问。</li></ol><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/7c4ecacdc2b3c9c9ddfe411c0be38aa5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*HZrR8OVqWA0XOOwNRPPuHQ.png"/></div></figure><p id="62e4" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kz kl km kn lb kp kq kr ld kt ku kv kw ig bi translated">创建父类→哺乳动物</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ms"><img src="../Images/667c147f1d15c827864e261a509a3150.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Oio1OS-XykaBK7aacOzjaQ.png"/></div></div></figure><p id="5063" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kz kl km kn lb kp kq kr ld kt ku kv kw ig bi translated">创建子类→人类</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mt"><img src="../Images/c5653c2555951cce3c66be5e6a16b99c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bsQkgzSOluVs8SmJgQFxPg.png"/></div></div></figure><p id="d90d" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kz kl km kn lb kp kq kr ld kt ku kv kw ig bi translated">对象制作→ main()</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mu"><img src="../Images/b1cdad4f582013304c8235275842b77c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CaE8JDw7RMq9EpZ7CT-Fag.jpeg"/></div></div></figure><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mv"><img src="../Images/9e6c960a7ff1fa3f213880814632d7c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ml3oH1Ra0rHEyMIO8ua8_A.jpeg"/></div></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">输出</figcaption></figure><p id="37a9" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kz kl km kn lb kp kq kr ld kt ku kv kw ig bi translated"><strong class="kb io"> 3.2 </strong>。<strong class="kb io"> <em class="ka">运行时多态性:——所以我们理解了继承</em> </strong></p><p id="d1a5" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kz kl km kn lb kp kq kr ld kt ku kv kw ig bi translated">在上面的例子中，我们从主函数[代码中的第 28 行]调用了“<strong class="kb io"><em class="ka">”human . eating()</em></strong>，所以在运行时它开始搜索“<strong class="kb io"><em class="ka">”eating()</em></strong>”。所以在运行时，它首先在子类中搜索，但是因为它不在子类中，所以它转到父类。同样，“<strong class="kb io"><em class="ka">. human . breathing()</em></strong>”是在运行时搜索它在子类中找到的。因此我们得到相应的输出。这是运行时多态性。</p><p id="8e19" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kz kl km kn lb kp kq kr ld kt ku kv kw ig bi translated"><strong class="kb io"> <em class="ka">继承的类型:- </em> </strong></p><ol class=""><li id="0a87" class="kx ky in kb b kc kd kg kh kz la lb lc ld le kw lf lg lh li bi translated">单一等级 :-表示男孩等级继承自人类等级。</li></ol><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mw"><img src="../Images/cea7b74f263294090624ac02f3c6577d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nxXy7Asv3L0uLQoyKocUig.png"/></div></div></figure><p id="1c41" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kz kl km kn lb kp kq kr ld kt ku kv kw ig bi translated">2.<strong class="kb io">多级</strong> :-表示顶级类继承自学生类，学生类继承自男孩类，男孩类继承自人类类。</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/c36ceb05e224d891dbef0ea9d0694caa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0QzcNXHdgP_0Dt7y6MA2ZA.png"/></div></div></figure><p id="f84f" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kz kl km kn lb kp kq kr ld kt ku kv kw ig bi translated">3.<strong class="kb io">倍数</strong> :-表示人类类继承自男孩和女孩两个类。</p><p id="8fc9" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kz kl km kn lb kp kq kr ld kt ku kv kw ig bi translated">注意:- <em class="ka">在 KOTLIN </em>中不允许【原因在本故事的后续部分】。</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mw"><img src="../Images/2afc234adac596354260b85c4f6cfc1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EYA4f0ut__RcGzD6u7u5dQ.png"/></div></div></figure><p id="e7c6" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kz kl km kn lb kp kq kr ld kt ku kv kw ig bi translated">4.<strong class="kb io">等级</strong> :-男孩类和女孩类都继承自人类类。</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mw"><img src="../Images/5e2aaeedaaaa1257b260316bca018c7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X8phDOr9xh3SWZCwC9IPPw.png"/></div></div></figure></div><div class="ab cl lo lp hr lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ig ih ii ij ik"><blockquote class="jv jw jx"><p id="524b" class="jy jz ka kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">5<em class="in">。</em> </strong> <strong class="kb io"> <em class="in">为什么</em> </strong> <em class="in"> </em> <strong class="kb io"> <em class="in">不允许多重继承</em> </strong> <em class="in">？→ </em> <strong class="kb io"> <em class="in"> </em>钻石问题</strong></p><p id="49b8" class="jy jz ka kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">Java 或 Kotlin 中不允许多重继承:-对于多重继承，他们(语言 Java、Kotlin 的创建者)告诉我们使用<strong class="kb io">接口</strong>。这个问题也称为钻石问题</p></blockquote><pre class="lw lx ly lz gt mx my mz na aw nb bi"><span id="ab3b" class="nc nd in my b gy ne nf l ng nh">        <strong class="my io">Class A</strong>{ <br/>            fun <strong class="my io">demo</strong>(){} <br/>        }</span><span id="c030" class="nc nd in my b gy ni nf l ng nh">        <strong class="my io">Class B</strong>{ <br/>            fun <strong class="my io">demo</strong>(){}<br/>        }</span><span id="279a" class="nc nd in my b gy ni nf l ng nh">       <strong class="my io"> Class C </strong>: <strong class="my io">A()</strong>, <strong class="my io">B()</strong>{ <br/>            <strong class="my io"><em class="ka">override </em></strong>fun <strong class="my io">demo</strong>(){} <br/>        }</span></pre><p id="29b6" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kz kl km kn lb kp kq kr ld kt ku kv kw ig bi translated">在这里，<strong class="kb io">编译器</strong>搞不清楚该调用<strong class="kb io"> <em class="ka"> demo() </em> </strong>的<strong class="kb io"> <em class="ka"> Class A </em> </strong>或<strong class="kb io"> <em class="ka"> Class B </em> </strong>的哪个函数，所以 Kotlin 防止用类进行多重继承。这是钻石问题。</p></div><div class="ab cl lo lp hr lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ig ih ii ij ik"><blockquote class="jv jw jx"><p id="9a00" class="jy jz ka kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">6<em class="in">。接口:- </em> </strong> <em class="in">用于存储属性的定义。</em></p></blockquote><p id="90c7" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kz kl km kn lb kp kq kr ld kt ku kv kw ig bi translated">→界面的所有内容都是抽象的、开放的、公共的。<br/>→如果现场变量(val，var)无法初始化。<br/>→功能在界面中可能有也可能没有主体部分。<br/>→无法创建对象。<br/>→允许多重继承。</p><p id="7e2a" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kz kl km kn lb kp kq kr ld kt ku kv kw ig bi translated">要创建接口:-</p><pre class="lw lx ly lz gt mx my mz na aw nb bi"><span id="93d8" class="nc nd in my b gy ne nf l ng nh">interface &lt;NAME&gt; { <br/>     //variables<br/>     //functions <br/>}</span></pre><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/98482853f5928c3515357817930cb058.png" data-original-src="https://miro.medium.com/v2/resize:fit:1142/format:webp/1*Xca_ntgRDVLAxLSkk6nqYA.png"/></div></figure><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nk"><img src="../Images/faa2d9a25138f631b9169b85f912040c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*waXpO4Zegu3sQLO9651gaQ.png"/></div></div></figure><p id="640b" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kz kl km kn lb kp kq kr ld kt ku kv kw ig bi translated">Main() :-</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nl"><img src="../Images/a76434db6287717587df2f3fabcad3dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SnRG9o5u5LqxYma4sRyPJw.jpeg"/></div></div></figure><p id="8baa" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kz kl km kn lb kp kq kr ld kt ku kv kw ig bi translated"><strong class="kb io"> <em class="ka">允许不同类型的继承:-</em></strong><em class="ka"/><strong class="kb io"><em class="ka"/></strong></p><pre class="lw lx ly lz gt mx my mz na aw nb bi"><span id="eda3" class="nc nd in my b gy ne nf l ng nh"><strong class="my io">Class C1() {}<br/>    Class C2() {}<br/>    interface I1() {}<br/>    interface I2() {}</strong></span><span id="200d" class="nc nd in my b gy ni nf l ng nh"><strong class="my io">// Allowed -&gt; One class + multiple interface<br/>    Class test2() : C1() , I1(), I2() {}</strong></span><span id="0971" class="nc nd in my b gy ni nf l ng nh"><strong class="my io">// Allowed -&gt; multiple interface<br/>    Class test3() : I1() , I2() {}</strong></span></pre></div><div class="ab cl lo lp hr lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ig ih ii ij ik"><blockquote class="jv jw jx"><p id="738e" class="jy jz ka kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io"> 7。课程类型:- </strong></p></blockquote><ol class=""><li id="853c" class="kx ky in kb b kc kd kg kh kz la lb lc ld le kw lf lg lh li bi translated"><strong class="kb io"> <em class="ka">数据</em> </strong> <em class="ka">类:-帮助我们保存数据的类。</em></li></ol><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/e21aa7b770749d925eafb55f1836b101.png" data-original-src="https://miro.medium.com/v2/resize:fit:1370/format:webp/1*WgSnAVP5-ECRzapkujvy7g.jpeg"/></div></figure><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mw"><img src="../Images/84272cec8bada42295d6efe89b9cac71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mMdLLViDFW4KDX8-NQMaaQ.png"/></div></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated"><a class="ae nn" href="https://www.canva.com/design/DAE2QjYRpP0/iCejAxB3JgLDhFhyN2Uxiw/view?utm_content=DAE2QjYRpP0&amp;utm_campaign=designshare&amp;utm_medium=link&amp;utm_source=publishsharelink" rel="noopener ugc nofollow" target="_blank">链接 _ 图片</a></figcaption></figure><p id="d027" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kz kl km kn lb kp kq kr ld kt ku kv kw ig bi translated"><em class="ka">规则:- </em> <br/> 1。数据类必须在参数<br/> 2 中有一项。数据类必须有所有参数必须定义 var 或 val <br/> 3。数据类不能是抽象的、开放的、密封的或内部的</p><p id="2154" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kz kl km kn lb kp kq kr ld kt ku kv kw ig bi translated"><em class="ka"> 2。</em><strong class="kb io"><em class="ka">Enum</em></strong><em class="ka">Class:-用于保存一组常量。</em></p><p id="8a7d" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kz kl km kn lb kp kq kr ld kt ku kv kw ig bi translated">→枚举类中的每个常量都是对象。<br/> →枚举类只能从接口继承，不能从类继承。</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi no"><img src="../Images/3a0a6018fc36000d6652fb9abdd62c3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0sCujxdAEjqquoohM6qsVg.png"/></div></div></figure><p id="3f41" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kz kl km kn lb kp kq kr ld kt ku kv kw ig bi translated">我们也可以在枚举类中有构造函数:-</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi np"><img src="../Images/2a4ceb46d1ea729674a3e41686ccaa7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y7rtTBNjOQI1yP47yPYZRA.png"/></div></div></figure><p id="a5c2" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kz kl km kn lb kp kq kr ld kt ku kv kw ig bi translated">我们只能继承 Enum 类中的接口，覆盖 Enum 类对象的<strong class="kb io"><em class="ka"/></strong><em class="ka">中接口的抽象函数和变量:-</em></p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nq"><img src="../Images/b850bb1500bab1682a19fd09e646efab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YeW8d4tICW8iNdAtQEeR7Q.png"/></div></div></figure><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mi"><img src="../Images/db89edd595d2ad84913d8e865e6c6f22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f76G6qy3FkBbxoCJyGZoLQ.jpeg"/></div></div></figure><p id="261f" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kz kl km kn lb kp kq kr ld kt ku kv kw ig bi translated"><em class="ka"> 3。</em> <strong class="kb io"> <em class="ka">密封</em> </strong> <em class="ka">类:-当我们有有限的一组值时，我们使用这个。</em></p><p id="9e13" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kz kl km kn lb kp kq kr ld kt ku kv kw ig bi translated">我们正在开设一个网站🌐我们试图打开它，这样我们可以面对三种情况 1。正在加载 2。错误 3 .成功。所以我们不能有任何其他价值。因此，我们使用密封类，因为我们有三个值，所以把它密封在包中，这样就不会有其他值添加到包中。</p><p id="29dd" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kz kl km kn lb kp kq kr ld kt ku kv kw ig bi translated">→密封类只能在创建它的文件中继承。<br/>→无法创建对象。</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nr"><img src="../Images/537d092c9dbbd9cb0ae4773524f40497.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s5iAmMghCrYEDjfzLvStXA.png"/></div></div></figure><p id="2dbe" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kz kl km kn lb kp kq kr ld kt ku kv kw ig bi translated">输出:-</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/558ab64ffe19ccccde59e4c83cb22c28.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*WqGrZwuzjXrYlcZqQi7nUA.jpeg"/></div></figure><p id="670c" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kz kl km kn lb kp kq kr ld kt ku kv kw ig bi translated"><strong class="kb io"> <em class="ka"> 4。Singleton </em> </strong> <em class="ka">类:像 Java 中的 static</em></p><p id="3aee" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kz kl km kn lb kp kq kr ld kt ku kv kw ig bi translated">1.在整个应用程序中只能创建一个对象。<br/> 2。不允许使用主构造函数和第二构造函数。<br/> 3。函数参数不能用 var 或 val 初始化，即 fun name(val name) - &gt;错误。<br/> 4。我们使用类名本身直接访问变量和方法。</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nt"><img src="../Images/c984be71be659c05548e1add1cd03644.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eQAnt8nReg9q30CViDqF0A.jpeg"/></div></div></figure><p id="8034" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kz kl km kn lb kp kq kr ld kt ku kv kw ig bi translated"><strong class="kb io"> <em class="ka"> 5。抽象</em> </strong> <em class="ka">类:-当我们声明一个抽象类时，我们必须在它的子类中有声明部分。</em></p><p id="68ee" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kz kl km kn lb kp kq kr ld kt ku kv kw ig bi translated">→抽象类可以有普通的和抽象的方法和字段。我们不能创建抽象类的对象。抽象变量只能使用它的子类来访问。</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nu"><img src="../Images/e38b6c679e8a8f8d50f3ba6745e063b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*atmRcLK4io4w2gYMDkBYrQ.jpeg"/></div></div></figure><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nv"><img src="../Images/3edf5c8e5787b86184fa0c0654909054.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vM38M7oxt247Jj7AJpc_Ng.jpeg"/></div></div></figure><p id="de43" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kz kl km kn lb kp kq kr ld kt ku kv kw ig bi translated">输出:-</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nw"><img src="../Images/946ddef2a789ea53f09f47d230fce803.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V-mgLYn3V3hsEWTD3ca3Cw.jpeg"/></div></div></figure><p id="6aea" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kz kl km kn lb kp kq kr ld kt ku kv kw ig bi translated"><em class="ka"> 6。</em> <strong class="kb io"> <em class="ka">嵌套</em> </strong> <em class="ka">类:类内的类是嵌套类。</em></p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nx"><img src="../Images/bb07fe8c7987ca87bc5388ee87a42f8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kgQt7ezs8Bpkfsc5FipoKA.jpeg"/></div></div></figure><p id="9bc0" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kz kl km kn lb kp kq kr ld kt ku kv kw ig bi translated">7.<strong class="kb io">内部嵌套</strong>类:-在嵌套类中，我们不能访问外部类的项目。但是当我们在嵌套类前添加“内部”时，我们就可以访问它们了。</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ny"><img src="../Images/5b10c8c4fda2cbba20801508758a0430.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OCf-nQhgc23zeZm3eSQbSw.png"/></div></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated"><strong class="bd nz">这里不能从嵌套类中访问外部类的“年龄”变量。</strong></figcaption></figure><p id="8008" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kz kl km kn lb kp kq kr ld kt ku kv kw ig bi translated">用“内部”嵌套:-</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/260d1f733d29156aa82c5141308cc73e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1356/format:webp/1*CJL5fXTMsebf53tiloYXTQ.png"/></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">这里，外部类的“年龄”变量可以从内部嵌套类中访问。</figcaption></figure><p id="35d8" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kz kl km kn lb kp kq kr ld kt ku kv kw ig bi translated"><strong class="kb io">注</strong> :-</p><p id="a06d" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kz kl km kn lb kp kq kr ld kt ku kv kw ig bi translated">调用“具有内部的嵌套类”:-当“<em class="ka">内部</em>”具有嵌套类时，我们必须具有外部类的构造函数。但是我们在正常的内部课程中没有。</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/41157ce8e2d382902c09478c69b929d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1316/format:webp/1*vSEqNC2qwXzSVofGrUDMbA.png"/></div></figure></div><div class="ab cl lo lp hr lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ig ih ii ij ik"><blockquote class="jv jw jx"><p id="52e9" class="jy jz ka kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io"> 8。摘要:- </strong></p></blockquote><p id="9f5b" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kz kl km kn lb kp kq kr ld kt ku kv kw ig bi translated">这意味着只使用函数而看不到它的内部实现。</p><p id="45ec" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kz kl km kn lb kp kq kr ld kt ku kv kw ig bi translated">例如:- println() →我们只看到它用它来打印，我们没有看到它的内部实现，它如何在内部工作等等。这就是抽象。</p></div><div class="ab cl lo lp hr lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ig ih ii ij ik"><blockquote class="jv jw jx"><p id="676e" class="jy jz ka kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">9<em class="in">9。封装</em> </strong> <em class="in"> :-访问修饰符</em></p></blockquote><ol class=""><li id="7206" class="kx ky in kb b kc kd kg kh kz la lb lc ld le kw lf lg lh li bi translated"><strong class="kb io"> Public </strong> :-默认情况下，这些类型的变量和函数随处可用。</li><li id="0623" class="kx ky in kb b kc lj kg lk kz ll lb lm ld ln kw lf lg lh li bi translated">私有的:这些类型的变量和函数只在文件中可见。</li><li id="6ef0" class="kx ky in kb b kc lj kg lk kz ll lb lm ld ln kw lf lg lh li bi translated"><strong class="kb io">内部</strong> :-这些类型的变量和函数只在同一个模块内可见，即同一个项目。</li><li id="18f5" class="kx ky in kb b kc lj kg lk kz ll lb lm ld ln kw lf lg lh li bi translated"><strong class="kb io">受保护的</strong> :-这些类型的变量和函数与 Private 相同，并且在它的子类中可见。</li></ol></div><div class="ab cl lo lp hr lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ig ih ii ij ik"><blockquote class="jv jw jx"><p id="865a" class="jy jz ka kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">10<em class="in">。抽象类 VS 接口</em> </strong></p></blockquote><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi oc"><img src="../Images/416c20a5ae633a871cd91ab1e7c5b0fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UmT3lOYH62cyepYhJZ88RQ.png"/></div></div></figure></div><div class="ab cl lo lp hr lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ig ih ii ij ik"><p id="bc04" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kz kl km kn lb kp kq kr ld kt ku kv kw ig bi translated">感谢阅读…希望你的概念已经清楚。</p></div></div>    
</body>
</html>