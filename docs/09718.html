<html>
<head>
<title>How to Write Good Unit Tests?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何写出好的单元测试？</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-to-write-good-unit-tests-a5bb376210bb?source=collection_archive---------4-----------------------#2022-09-07">https://blog.devgenius.io/how-to-write-good-unit-tests-a5bb376210bb?source=collection_archive---------4-----------------------#2022-09-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f0d8" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">编写良好的单元测试的十个标志</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/171d6836f4af2b181d7fdeeaea44d593.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4beftXq3sfyB-UhM"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">费伦茨·阿尔马西在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="7308" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi ls translated">欢迎来到现代和负责任的编程世界。在这个世界里，单元测试是应用程序的基础。</p><p id="bb47" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mb">单元测试</em>防止代码重构期间的回归。它们允许您通过模拟各种场景来验证代码的正确性。</p><p id="1fa0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mb">单元测试</em>是<strong class="ky ir">必不可少的</strong>。你不会是碰巧写的吧？你必须开始，相信我。随着时间的推移，你会体会到他们给项目带来的价值。</p><blockquote class="mc"><p id="07c0" class="md me iq bd mf mg mh mi mj mk ml lr dk translated">不要混淆“单元测试”和“端到端”测试。单元测试中没有浏览器模拟，即$browser-&gt;visit()</p></blockquote><p id="d397" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">虽然编写好的测试是一门艺术。这并不容易，通常需要牺牲，即维护额外的代码。</p><p id="b257" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在许多项目中，通常不可能正确地测试代码，因为当项目足够大时，许多编程问题很难克服。技术债务对于重构代码来说可能代价太高。</p></div><div class="ab cl mr ms hu mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ij ik il im in"><p id="c909" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如何识别写得好的单元测试？这里有一个简单的清单来回答这个问题:</p><ol class=""><li id="9f35" class="my mz iq ky b kz la lc ld lf na lj nb ln nc lr nd ne nf ng bi translated">他们将真实的对象(存根)作为依赖注入到被测试的类中，而不是模仿(即<em class="mb"> InMemoryRepository </em>来拯救)</li><li id="efd8" class="my mz iq ky b kz nh lc ni lf nj lj nk ln nl lr nd ne nf ng bi translated">他们在<strong class="ky ir">测试下独立地</strong>测试类，并且不需要外部服务(框架、容器等)。)</li><li id="dc67" class="my mz iq ky b kz nh lc ni lf nj lj nk ln nl lr nd ne nf ng bi translated">它们非常快，只需要几毫秒就能运行</li><li id="5052" class="my mz iq ky b kz nh lc ni lf nj lj nk ln nl lr nd ne nf ng bi translated">它们<strong class="ky ir">与时间无关</strong>，也就是说，不会在几天或几小时内中断</li><li id="60ed" class="my mz iq ky b kz nh lc ni lf nj lj nk ln nl lr nd ne nf ng bi translated">它们<strong class="ky ir">独立</strong>和<strong class="ky ir">不与其他测试</strong>耦合，即改变测试顺序不会使测试变红</li><li id="dea8" class="my mz iq ky b kz nh lc ni lf nj lj nk ln nl lr nd ne nf ng bi translated">重构被测试类的内部细节不应该让测试变红</li><li id="3b83" class="my mz iq ky b kz nh lc ni lf nj lj nk ln nl lr nd ne nf ng bi translated">它们<strong class="ky ir">不测试不必要的“逻辑”</strong>，即设置器、精确日志消息等。</li><li id="306a" class="my mz iq ky b kz nh lc ni lf nj lj nk ln nl lr nd ne nf ng bi translated">他们<strong class="ky ir">专注于测试被测类的行为</strong>，而<strong class="ky ir">不是实现</strong></li><li id="806c" class="my mz iq ky b kz nh lc ni lf nj lj nk ln nl lr nd ne nf ng bi translated">它们是可重复的、确定的，每次都会产生相同的结果</li><li id="e35f" class="my mz iq ky b kz nh lc ni lf nj lj nk ln nl lr nd ne nf ng bi translated">它们易于维护和理解，具有描述性的方法名称，作为测试代码的原因的名称</li></ol></div><div class="ab cl mr ms hu mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ij ik il im in"><p id="9415" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您在单元测试中遇到上面列表中的任何问题，这是测试质量可能很差的明显迹象。脆弱的测试是一种负担。有价值的测试带给你信心和每个编程项目需要的质量。</p></div><div class="ab cl mr ms hu mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ij ik il im in"><p id="5cfa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可能有兴趣阅读以下出版物:</p><div class="nm nn gp gr no np"><a href="https://medium.com/@dotcom.software/unit-testing-closures-the-right-way-b982fc833bfa" rel="noopener follow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd ir gy z fp nu fr fs nv fu fw ip bi translated">单元测试闭包“正确的方法”</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">关于如何在 PHP 中对闭包进行单元测试的反向出版物</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">medium.com</p></div></div><div class="ny l"><div class="nz l oa ob oc ny od kp np"/></div></div></a></div></div></div>    
</body>
</html>