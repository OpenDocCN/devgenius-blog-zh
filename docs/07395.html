<html>
<head>
<title>How Slices Work in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">围棋中切片的工作原理</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-slices-work-in-go-fbc772514001?source=collection_archive---------13-----------------------#2022-03-21">https://blog.devgenius.io/how-slices-work-in-go-fbc772514001?source=collection_archive---------13-----------------------#2022-03-21</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="e97f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Go 为我们提供了一种使用切片对相似数据进行分组的方法。我想这是一个相当陌生的术语。至少我还没见过 slice 这个术语在其他语言中使用。能够很好地使用切片很重要，但是理解它在幕后是如何工作的也很重要。我认为了解内部运作是乐趣的一半。在这篇文章中，我将解释围棋中切片的工作原理。</p><h1 id="c30f" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">但是首先，让我们看看数组。</h1><p id="fe93" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">我们从数组开始的原因是切片是使用数组实现的。数组基本上是固定大小的容器。</p><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="7cfb" class="lu kj in lq b gy lv lw l lx ly">myArray := [3]int{0, 1, 2}</span></pre><p id="d898" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您在方括号内指定数组的大小，决定元素的数据类型，并将元素写在花括号内。您也可以让编译器通过这样做来找出数组的长度:</p><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="8844" class="lu kj in lq b gy lv lw l lx ly">myArray := [...]string{"apple", "banana"}</span></pre><p id="7f64" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果不指定长度，将改为创建切片。一旦创建了数组，就不能更改其大小。</p><p id="80a0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，您已经可以看到数组更加原始，不像 Python 列表那样功能丰富。我来自 Python 背景，就像一个被宠坏的新手 dev，想要找到一些更有用的东西。我立刻开始寻找更强大的东西。</p><h1 id="c186" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">看，切片的创造。</h1><p id="12dd" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">切片比数组强大得多，因为它们具有动态特性。简单来说，切片就像橡皮筋。它会根据您的需要不断扩展。如果橡皮筋很硬，不能拉伸，它就不会很有用。</p><p id="732b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这类似于 C++开发人员可以同时使用数组和向量，但会选择使用向量来实现其动态性。</p><p id="0fef" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">以下是一些初始化切片的方法。</p><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="5a4b" class="lu kj in lq b gy lv lw l lx ly">// method 1: use make() and specify type, length, and capacity.<br/>mySlice := make([]int, 4, 4)<br/>// assign values to each index.<br/>mySlice[0] = 0<br/>mySlice[1] = 1<br/>mySlice[2] = 2<br/>mySlice[3] = 3<br/><br/>// method 2: declare a struct literal.<br/>mySlice := []int{0, 1, 2, 3}<br/><br/>// method 3: create an empty slice and append to it<br/>mySlice := []int{}<br/>mySlice = append(mySlice, 0, 1, 2, 3)</span></pre><p id="02da" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">切片很好，因为您可以在创建后更改它们的大小。当您需要存储未知数量的数据时，这尤其方便。切片还支持切片(duh ),它允许您对给定的切片进行切片。</p><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="9427" class="lu kj in lq b gy lv lw l lx ly">mySlice := []int{0, 1, 2, 3}<br/>piece := mySlice[1:3]</span><span id="e056" class="lu kj in lq b gy lz lw l lx ly">[1 2]</span></pre><p id="4808" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，我们已经看到了可用性方面的重大改进。但是当我第一次看到这个的时候，我不禁想知道这是怎么回事。</p><h1 id="effd" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">这是如何工作的？这是什么魔法？</h1><p id="e7ae" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">所以在表面之下，切片是一个包含指向底层数组的指针的头。如果你看一下 go 的<code class="fe ma mb mc lq b">reflect</code>包，就可以看到<code class="fe ma mb mc lq b">SliceHeader</code>的定义:</p><pre class="ll lm ln lo gt lp lq lr ls aw lt bi"><span id="eb2b" class="lu kj in lq b gy lv lw l lx ly">type SliceHeader struct {<br/>    Data uintptr<br/>    Len int<br/>    Cap int<br/>}</span></pre><p id="83d3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，因为它本质上是一个阵列，所以一个片不能超出其容量。当我们说“扩展切片”时，我们实际上并不是指在现有的基础上增加更多容量。相反，正是这种幕后逻辑允许切片“增长”。</p><ul class=""><li id="643e" class="md me in jm b jn jo jr js jv mf jz mg kd mh kh mi mj mk ml bi translated">它将检查当前长度是否等于容量。</li><li id="9a7f" class="md me in jm b jn mm jr mn jv mo jz mp kd mq kh mi mj mk ml bi translated">如果追加超额容量，将创建两倍于原始存储片容量的新存储片。</li><li id="c96e" class="md me in jm b jn mm jr mn jv mo jz mp kd mq kh mi mj mk ml bi translated">原始切片将被复制到新切片上。</li><li id="292d" class="md me in jm b jn mm jr mn jv mo jz mp kd mq kh mi mj mk ml bi translated">新元素将被附加在末尾。</li><li id="9553" class="md me in jm b jn mm jr mn jv mo jz mp kd mq kh mi mj mk ml bi translated">将返回结果切片。</li></ul><figure class="ll lm ln lo gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi mr"><img src="../Images/957b724f324147dd9bfcb702473f8cc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KAX8pVj--hbFCVUgtxsq6g.png"/></div></div></figure><p id="7ede" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">切片也很容易:</p><ul class=""><li id="42fd" class="md me in jm b jn jo jr js jv mf jz mg kd mh kh mi mj mk ml bi translated">它将指向<em class="mz">相同的</em>底层数组中的新位置。</li><li id="bf86" class="md me in jm b jn mm jr mn jv mo jz mp kd mq kh mi mj mk ml bi translated">长度和容量将被调整。</li></ul><figure class="ll lm ln lo gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi mr"><img src="../Images/0c2405c1d7a52d3c38ee82888701e07f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*98k2NGVBb4KRbfnf7Sp1DA.png"/></div></div></figure><p id="de70" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以我们现在明白了切片是如何在引擎盖下工作的。很酷，不是吗？</p><h1 id="d0b8" class="ki kj in bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">结论</h1><p id="2a44" class="pw-post-body-paragraph jk jl in jm b jn lg jp jq jr lh jt ju jv li jx jy jz lj kb kc kd lk kf kg kh ig bi translated">您可以将切片视为数组的包装，以赋予它们超能力。在大多数情况下，您应该尝试使用切片而不是数组。然而，当您知道自己在做什么时，数组可能是一个不错的选择。如果您需要一些必须通过值传递，或者被散列或序列化的东西，您应该在切片上使用数组。然而，在大多数情况下，坚持切片是正确的方法。</p><p id="2715" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">谢谢你的阅读！你可以在<a class="ae na" href="https://dev.to/jpoly1219/how-slices-work-in-go-47nc" rel="noopener ugc nofollow" target="_blank"> Dev 上阅读这篇文章。到</a>和<a class="ae na" href="https://jpoly1219.github.io" rel="noopener ugc nofollow" target="_blank">我的个人网站</a>。</p></div></div>    
</body>
</html>