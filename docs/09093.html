<html>
<head>
<title>Snackbars in Jetpack Compose</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Jetpack 撰写中的 Snackbars</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/snackbars-in-jetpack-compose-d1b553224dca?source=collection_archive---------5-----------------------#2022-07-29">https://blog.devgenius.io/snackbars-in-jetpack-compose-d1b553224dca?source=collection_archive---------5-----------------------#2022-07-29</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/deee23bf769d9ed8b41f6a3ba5ae75bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7PB71CrkE78PJpCHTb0uzQ.png"/></div></div></figure><p id="89b6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在本文中，我们将了解 Android 中的 Snackbar 是什么，以及在 Jetpack Compose 中实现它的不同方法。我们还将简要介绍 Kotlin 中的<strong class="jx io">流</strong>，以及在实现 Snackbar 时使用哪个流。</p><p id="0343" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="kt">注意:本文假设您对 Jetpack Compose 有一些基本的经验。</em></p><h2 id="e680" class="ku kv in bd kw kx ky dn kz la lb dp lc kg ld le lf kk lg lh li ko lj lk ll lm bi translated">什么是小吃店？</h2><p id="97f7" class="pw-post-body-paragraph jv jw in jx b jy ln ka kb kc lo ke kf kg lp ki kj kk lq km kn ko lr kq kr ks ig bi translated">一个<a class="ae ls" href="https://material.io/components/snackbars/android" rel="noopener ugc nofollow" target="_blank"> Snackbar </a>是一个 UI 组件，显示一个带有消息文本的浮动覆盖图。它可能包含也可能不包含动作按钮，这取决于实现。它主要用于向不需要复杂 UI 的用户显示简短的通用消息。</p><h2 id="ea39" class="ku kv in bd kw kx ky dn kz la lb dp lc kg ld le lf kk lg lh li ko lj lk ll lm bi translated">基本项目设置</h2><ul class=""><li id="e178" class="lt lu in jx b jy ln kc lo kg lv kk lw ko lx ks ly lz ma mb bi translated">在 Android 中创建一个空的合成项目。在预先创建的<strong class="jx io"> MainActivity.kt </strong>中，删除<em class="kt">问候语</em>撰写函数，使文件如下</li></ul><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="b143" class="ku kv in mh b gy ml mm l mn mo">class MainActivity : ComponentActivity() {<br/>    override fun onCreate(savedInstanceState: Bundle?) {<br/>        super.onCreate(savedInstanceState)<br/>        <em class="kt">setContent </em><strong class="mh io">{<br/>            </strong><em class="kt">SnackBarTutTheme </em><strong class="mh io">{<br/>                </strong><em class="kt">Scaffold</em> <strong class="mh io">{<br/>                    </strong><em class="kt">Column</em>(<br/>                        Modifier.<em class="kt">fillMaxSize</em>(),<br/>                        verticalArrangement = Arrangement.Center,<br/>                        horizontalAlignment = Alignment.CenterHorizontally<br/>                    ) <strong class="mh io">{<br/>                        </strong><em class="kt">Button</em>(onClick = {}) <strong class="mh io">{<br/>                            </strong><em class="kt">Text</em>(text = "Show SnackBar")<br/>                        <strong class="mh io">}<br/>                    }<br/>                }<br/>            }<br/>        }<br/>    </strong>}<br/>}</span></pre><p id="c791" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这将为您提供以下 UI，这是一个位于屏幕中央的简单按钮。</p><figure class="mc md me mf gt jo gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/881183fd25de90c2a081c9916ffbb247.png" data-original-src="https://miro.medium.com/v2/resize:fit:1352/format:webp/1*ORc75f2ZRT8a7eXfruOqlw.png"/></div></figure><p id="186b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">目前，我们的按钮不做任何事情。我们将在课程接近尾声时解决这个问题，因为我们将学习如何在单击按钮时显示 Snackbar。</p><h2 id="5861" class="ku kv in bd kw kx ky dn kz la lb dp lc kg ld le lf kk lg lh li ko lj lk ll lm bi translated">使用 StateFlow 实现 Snackbar</h2><ul class=""><li id="5fd0" class="lt lu in jx b jy ln kc lo kg lv kk lw ko lx ks ly lz ma mb bi translated">创建一个名为<strong class="jx io"> SnackbarViewModel.kt </strong>的文件，并向其中添加以下代码。</li></ul><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="23f4" class="ku kv in mh b gy ml mm l mn mo">class SnackBarScreenViewModel : ViewModel() {<br/><br/>    private val _isMessageShown = <em class="kt">MutableStateFlow</em>(false)<br/>    val isMessageShownFlow = _isMessageShown.<em class="kt">asStateFlow</em>()<br/><br/>    fun setMessageShown() {<br/>        <em class="kt">viewModelScope</em>.<em class="kt">launch </em><strong class="mh io">{<br/>            </strong>_isMessageShown.emit(true)<br/>        <strong class="mh io">}<br/>    </strong>}<br/>}</span></pre><p id="21d0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们来分析一下上面的代码:</p><ul class=""><li id="2293" class="lt lu in jx b jy jz kc kd kg mq kk mr ko ms ks ly lz ma mb bi translated">我们已经添加了<strong class="jx io"> _isMessageShown </strong>属性。这是一个私有变量，它创建一个初始值设置为 false 的 MutableStateFlow。StateFlow 是一个热流，这意味着不管是否有人在收集它，它都会发出值。</li><li id="6dfc" class="lt lu in jx b jy mt kc mu kg mv kk mw ko mx ks ly lz ma mb bi translated"><strong class="jx io"> isMessageShown </strong>是一个公共属性，暴露在我们的视野中进行观察。使用<em class="kt"> asStateFlow() </em>将可变状态流转换为只读不可变状态流，这确保了视图不会发出任何值，并且 SnackBarScreenViewModel 是事件的唯一生产者。</li><li id="69a4" class="lt lu in jx b jy mt kc mu kg mv kk mw ko mx ks ly lz ma mb bi translated"><strong class="jx io">setmessageshowed</strong>是一个将<em class="kt">_ is messageshown</em>StateFlow 的值更新为 true 并发出新值供 UI 收集的函数。</li></ul><p id="ef93" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在让我们更新一下<strong class="jx io"> MainActivity。Kt </strong>观察这个状态流，并在它为真时显示一个 Snackbar。更新主活动。Kt 看起来像下面的代码。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="68dd" class="ku kv in mh b gy ml mm l mn mo">class MainActivity : ComponentActivity() {<br/>    override fun onCreate(savedInstanceState: Bundle?) {<br/>        super.onCreate(savedInstanceState)<br/>        <em class="kt">setContent </em><strong class="mh io">{<br/>            </strong><em class="kt">SnackBarTutTheme </em><strong class="mh io">{<br/>                </strong>val viewModel: SnackBarScreenViewModel by <em class="kt">viewModels</em>()<br/>                val scaffoldState = <em class="kt">rememberScaffoldState</em>()<br/><br/>                <em class="kt">LaunchedEffect</em>(Unit) <strong class="mh io">{<br/>                    </strong>viewModel.isMessageShownFlow.collectLatest <strong class="mh io">{<br/>                        </strong>if (<strong class="mh io">it</strong>) {<br/>                            scaffoldState.snackbarHostState.showSnackbar(<br/>                                message = "Hello World",<br/>                                duration = SnackbarDuration.<em class="kt">Short<br/>                            </em>)<br/>                        }<br/>                    <strong class="mh io">}<br/>                }<br/><br/>                </strong><em class="kt">Scaffold </em><strong class="mh io">{<br/>                    </strong><em class="kt">Column</em>(<br/>                        Modifier.<em class="kt">fillMaxSize</em>(),<br/>                        verticalArrangement = Arrangement.Center,<br/>                        horizontalAlignment = Alignment.CenterHorizontally<br/>                    ) <strong class="mh io">{<br/>                        </strong><em class="kt">Button</em>(onClick = viewModel::setMessageShown) <strong class="mh io">{<br/>                            </strong><em class="kt">Text</em>(text = "Show SnackBar")<br/>                        <strong class="mh io">}<br/>                    }<br/>                }<br/>            }<br/>        }<br/>    </strong>}<br/>}</span></pre><p id="d40f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们分析一下上面的代码</p><ul class=""><li id="09ba" class="lt lu in jx b jy jz kc kd kg mq kk mr ko ms ks ly lz ma mb bi translated"><strong class="jx io"> viewModel </strong>是通过委托检索 SnackBarScreenViewModel 实例的变量。</li><li id="6340" class="lt lu in jx b jy mt kc mu kg mv kk mw ko mx ks ly lz ma mb bi translated"><strong class="jx io"> scaffoldState </strong>是一个变量，它提供了一个脚手架状态上下文，该上下文稍后将用于创建一个 SnackbarHost。ScaffoldState 有助于提供确定在何处绘制 Snackbar 覆盖图的上下文。</li><li id="1ff5" class="lt lu in jx b jy mt kc mu kg mv kk mw ko mx ks ly lz ma mb bi translated">LaunchedEffect 提供了一个协程作用域，我们可以在其中执行所有导致副作用的代码。在我们的例子中，我们将收集器连接到我们的 isMessageShownFlow 流。这确保了每当发出一个新值时，它都在这里被收集，并显示一个 Snackbar。通过提供<em class="kt">单元</em>作为<em class="kt"> LaunchedEffect </em>的参数，我们确保收集器只连接到流一次，即当可组合组件最初被呈现时。</li><li id="8a02" class="lt lu in jx b jy mt kc mu kg mv kk mw ko mx ks ly lz ma mb bi translated"><strong class="jx io"> showSnackbar </strong>是 SnackbarHost 公开的一个函数。此功能显示屏幕上当前活动的脚手架内的零食条。目前我们为它提供两个参数:<em class="kt">消息</em>和<em class="kt">持续时间。</em></li></ul><p id="5b4a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，每当我们单击按钮时，它都会调用我们的<em class="kt">视图模型</em>中的<em class="kt">setmessageshowed()</em>函数。然后，这将更新我们的 ui 收集的状态，以显示 Snackbar。</p><h2 id="e788" class="ku kv in bd kw kx ky dn kz la lb dp lc kg ld le lf kk lg lh li ko lj lk ll lm bi translated">好的，它起作用了..那么问题出在哪里？</h2><p id="f251" class="pw-post-body-paragraph jv jw in jx b jy ln ka kb kc lo ke kf kg lp ki kj kk lq km kn ko lr kq kr ks ig bi translated">当你第一次点击这个按钮时，它按预期显示，但是当你再次点击它时会发生什么呢？也尝试改变设备的方向，你可以看到 snackbar 得到显示，即使没有点击按钮。那么为什么会出现这种情况呢？</p><p id="d39f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先，如果提供给 stateflow 的新的更新值与以前的值相同，那么它简单地拒绝发出新值。这解释了为什么 snackbar 只是第一次出现。第二，每当设备经历方向改变时，Stateflow 再次发出当前值，导致每次旋转设备时显示 snackbar。</p><h2 id="caf6" class="ku kv in bd kw kx ky dn kz la lb dp lc kg ld le lf kk lg lh li ko lj lk ll lm bi translated">分享给救援🦸🏻</h2><p id="308e" class="pw-post-body-paragraph jv jw in jx b jy ln ka kb kc lo ke kf kg lp ki kj kk lq km kn ko lr kq kr ks ig bi translated">SharedFlow 也是一个热流，但是它解决了上述两个问题:每当更新流值时它都发出，而当设备旋转时它不发出当前值。</p><ul class=""><li id="7723" class="lt lu in jx b jy jz kc kd kg mq kk mr ko ms ks ly lz ma mb bi translated">修改<strong class="jx io">SnackBarScreenViewModel</strong>使其看起来像下面的代码</li></ul><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="6d2d" class="ku kv in mh b gy ml mm l mn mo">class SnackBarScreenViewModel : ViewModel() {<br/><br/>//  private val _isMessageShown = MutableStateFlow(false)<br/>//  val isMessageShownFlow = _isMessageShown.asStateFlow()<br/><br/>    private val _isMessageShown = <em class="kt">MutableSharedFlow</em>&lt;Boolean&gt;()<br/>    val isMessageShownFlow = _isMessageShown.<em class="kt">asSharedFlow</em>()<br/><br/><br/>    fun setMessageShown() {<br/>        <em class="kt">viewModelScope</em>.<em class="kt">launch </em><strong class="mh io">{<br/>            </strong>_isMessageShown.emit(true)<br/>        <strong class="mh io">}<br/>    </strong>}<br/>}</span></pre><p id="2eaf" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们分析一下上面的代码:</p><ul class=""><li id="7437" class="lt lu in jx b jy jz kc kd kg mq kk mr ko ms ks ly lz ma mb bi translated">我们已经将我们的<strong class="jx io"> _isMessageShown </strong>从一个 MutableStateFlow 转换成了一个<em class="kt"> MutableSharedFlow </em>，并将值的类型指定为 Boolean。</li><li id="7a29" class="lt lu in jx b jy mt kc mu kg mv kk mw ko mx ks ly lz ma mb bi translated">我们还使用<em class="kt"> asSharedFlow </em>()函数将<strong class="jx io">is messageshownsharedflow</strong>转换为只读的 SharedFlow，以便通过 ui 进行观察。</li></ul><p id="7fe3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在尝试运行应用程序。这一次，它会在你每次点击按钮时工作，不会不必要地在每次设备旋转时显示 Snackbar。</p><p id="016b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">瞧，就是这样。希望你对小吃和流动有了比你开始时更好的理解。如果你有任何疑问，请不吝赐教。下次再见，<em class="kt">一路平安！🦄</em></p></div></div>    
</body>
</html>