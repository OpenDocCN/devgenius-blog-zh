<html>
<head>
<title>Terraform: Staying DRY when using count conditionals</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">地形:使用计数条件时保持干燥</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/terraform-staying-dry-when-using-count-conditionals-2c4f6c15a4ac?source=collection_archive---------3-----------------------#2020-07-04">https://blog.devgenius.io/terraform-staying-dry-when-using-count-conditionals-2c4f6c15a4ac?source=collection_archive---------3-----------------------#2020-07-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/9b1f86f302ab3e94eccd2790f1f2bc2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8At87rilzPZ1p6p1"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@sanasaidi?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">萨纳·赛迪</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="fa29" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">技术领域的每个人都听说过“保持干燥”这个词或它的一些变体。写代码的时候，保持干爽的意思是:“不要重复自己”。如果您发现自己将代码片段复制到应用程序的多个部分，可以考虑制作一个:类、方法/函数、变量、常量等…</p><p id="c74b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们都理解上面的内容，但是当涉及到 Terraform 中跨多个资源的<code class="fe lb lc ld le b">count</code>条件语句时，我经常看到以下两种情况:</p><h2 id="9a19" class="lf lg iq bd lh li lj dn lk ll lm dp ln ko lo lp lq ks lr ls lt kw lu lv lw lx bi translated">让我们处处重复自己</h2><pre class="ly lz ma mb gt mc le md me aw mf bi"><span id="410e" class="lf lg iq le b gy mg mh l mi mj">count = var.variableA == "" || var.variableB == "" ? 0 : 1<br/>count = var.variableA == "" || var.variableB == "" ? 0 : 1<br/>count = var.variableA == "" || var.variableB == "" ? 0 : 1<br/>count = var.variableA == "" || var.variableB == "" ? 0 : 1</span></pre><p id="3da8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这正是我们试图用干来防止的事情。它是:</p><ul class=""><li id="4eb7" class="mk ml iq kf b kg kh kk kl ko mm ks mn kw mo la mp mq mr ms bi translated">写起来很乏味</li><li id="4465" class="mk ml iq kf b kg mt kk mu ko mv ks mw kw mx la mp mq mr ms bi translated">更难阅读</li><li id="65d9" class="mk ml iq kf b kg mt kk mu ko mv ks mw kw mx la mp mq mr ms bi translated">更难维护</li></ul><p id="94f7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当然，在这种情况下，重复并不是世界末日，但是让我们尽可能地提高效率。</p><h2 id="0dc3" class="lf lg iq bd lh li lj dn lk ll lm dp ln ko lo lp lq ks lr ls lt kw lu lv lw lx bi translated">2)选择一个切换特征的任意变量(当还需要其他变量时)</h2><pre class="ly lz ma mb gt mc le md me aw mf bi"><span id="ccf6" class="lf lg iq le b gy mg mh l mi mj">count = var.ssh_pub_key == "" ? 0 : 1<br/>count = var.ssh_pub_key == "" ? 0 : 1<br/>count = var.ssh_pub_key == "" ? 0 : 1<br/>count = var.ssh_pub_key == "" ? 0 : 1<br/>count = var.ssh_pub_key == "" ? 0 : 1<br/>count = var.ssh_pub_key == "" ? 0 : 1<br/>count = var.ssh_pub_key == "" ? 0 : 1</span></pre><p id="a3cc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种方法似乎比第一种更好，但可以说是更差。这种方法大大降低了代码的可读性。这些事情中的一个或者全部都会发生:</p><ul class=""><li id="7a31" class="mk ml iq kf b kg kh kk kl ko mm ks mn kw mo la mp mq mr ms bi translated">有人会定义单个变量，运行 terraform，它会出错，因为没有定义<code class="fe lb lc ld le b">variableB</code>。</li><li id="ff10" class="mk ml iq kf b kg mt kk mu ko mv ks mw kw mx la mp mq mr ms bi translated">有人会定义单变量，运行 terraform，有些资源会因为没有定义<code class="fe lb lc ld le b">variableC</code>而无法正确命名或配置。</li><li id="52de" class="mk ml iq kf b kg mt kk mu ko mv ks mw kw mx la mp mq mr ms bi translated">有人必须阅读自述文件，并从那里获得他们需要的所有信息(假设有自述文件)。</li><li id="6786" class="mk ml iq kf b kg mt kk mu ko mv ks mw kw mx la mp mq mr ms bi translated">有人将不得不仔细检查代码，并找出需要的其他变量。</li></ul><p id="784b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于显而易见的原因，上述所有场景都不太好。应该有人能够接管你的代码，并理解正在发生的事情。</p><p id="e472" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有些人可能会说:</p><ul class=""><li id="2998" class="mk ml iq kf b kg kh kk kl ko mm ks mn kw mo la mp mq mr ms bi translated">“您的代码有一些开销是合理的”</li><li id="2c49" class="mk ml iq kf b kg mt kk mu ko mv ks mw kw mx la mp mq mr ms bi translated">“一个人必须记住某些事情是合理的”</li></ul><p id="d941" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我会反驳:“有人建立和使用模式是合理的”。不过，以上并不是一种模式，这是一种记忆游戏，每次在代码库中使用这种方法，它都会变得更加复杂。</p><p id="6718" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另外，当代码需要更新时，6 个月后会发生什么？你又看了一遍发现？碰到所有的绊脚石，然后你终于能够开始生产？</p></div><div class="ab cl my mz hu na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ij ik il im in"><h1 id="4d57" class="nf lg iq bd lh ng nh ni lk nj nk nl ln nm nn no lq np nq nr lt ns nt nu lw nv bi translated">保持干燥</h1><p id="7959" class="pw-post-body-paragraph kd ke iq kf b kg nw ki kj kk nx km kn ko ny kq kr ks nz ku kv kw oa ky kz la ij bi translated">在这些情况下，怎样做才能在保持逻辑性和可读性的同时成为一个干衣机？</p><p id="2d3f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通常，当您在 Terraform 中跨多个资源使用<code class="fe lb lc ld le b">count</code>条件语句时，您试图做两件事之一:</p><ol class=""><li id="8c54" class="mk ml iq kf b kg kh kk kl ko mm ks mn kw mo la ob mq mr ms bi translated">确保定义了所有必要的变量</li><li id="6617" class="mk ml iq kf b kg mt kk mu ko mv ks mw kw mx la ob mq mr ms bi translated">确保所有必要的变量都有正确的值。</li></ol><p id="a5a2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这两种情况都可以在 Terraform 中使用局部变量轻松解决。</p><h2 id="a20b" class="lf lg iq bd lh li lj dn lk ll lm dp ln ko lo lp lq ks lr ls lt kw lu lv lw lx bi translated">确保定义了所有必要的变量</h2><p id="e977" class="pw-post-body-paragraph kd ke iq kf b kg nw ki kj kk nx km kn ko ny kq kr ks nz ku kv kw oa ky kz la ij bi translated">在您想要检查所有先决条件变量都已定义的情况下，我们可以利用 Terraform 的<code class="fe lb lc ld le b"><a class="ae kc" href="https://www.terraform.io/docs/configuration/functions/contains.html" rel="noopener ugc nofollow" target="_blank">contains</a></code> <a class="ae kc" href="https://www.terraform.io/docs/configuration/functions/contains.html" rel="noopener ugc nofollow" target="_blank">函数</a>。这个函数将遍历一个列表，检查是否有任何元素包含特定的值。</p><p id="44ef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是我们的使用案例中的情况:</p><pre class="ly lz ma mb gt mc le md me aw mf bi"><span id="fad1" class="lf lg iq le b gy mg mh l mi mj">locals {<br/>  is_feature_enabled = contains([<br/>    var.variableA,<br/>    var.variableB,<br/>    var.variableC<br/>  ],<br/>  "") ? 0 : 1<br/>}</span></pre><p id="e58d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个例子中，我们寻找一个定义为<code class="fe lb lc ld le b">""</code>的空字符串。如果找到了空字符串，<code class="fe lb lc ld le b">contains</code>将返回<code class="fe lb lc ld le b">true</code>，变量的值被设置为<code class="fe lb lc ld le b">0</code>。如果函数返回<code class="fe lb lc ld le b">false</code>，没有变量是空的，我们可以继续。</p><h2 id="51d9" class="lf lg iq bd lh li lj dn lk ll lm dp ln ko lo lp lq ks lr ls lt kw lu lv lw lx bi translated">确保所有必要的变量都有正确的值。</h2><p id="b1b0" class="pw-post-body-paragraph kd ke iq kf b kg nw ki kj kk nx km kn ko ny kq kr ks nz ku kv kw oa ky kz la ij bi translated">在这种情况下，我们所要做的就是将逻辑从<code class="fe lb lc ld le b">count </code>语句移到一个局部变量中。</p><pre class="ly lz ma mb gt mc le md me aw mf bi"><span id="6873" class="lf lg iq le b gy mg mh l mi mj">locals {<br/>  is_feature_enabled =  var.variableA != "" &amp;&amp; var.variableB == "randomValue" ? 1: 0<br/>}</span></pre><p id="9c4c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这看起来不如使用<code class="fe lb lc ld le b">contains</code>函数好，但至少它是在一个地方定义的，而不是在代码库中的多个地方。</p></div><div class="ab cl my mz hu na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ij ik il im in"><p id="3550" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦使用任何一种方法定义了局部变量，就可以在参考资料中多次引用它。</p><pre class="ly lz ma mb gt mc le md me aw mf bi"><span id="d9f5" class="lf lg iq le b gy mg mh l mi mj">resource "aws_lambda_permission" "test" {<br/>  count = local.is_feature_enabled == 1 ? 1 : 0<br/>  ...<br/>}</span><span id="b8b0" class="lf lg iq le b gy oc mh l mi mj">resource "aws_lambda_function" "test" {<br/>  count = local.is_feature_enabled == 1 ? 1 : 0<br/>  ...<br/>}</span><span id="c697" class="lf lg iq le b gy oc mh l mi mj">resource "aws_cloudwatch_log_group" "test" {<br/>  count = local.is_feature_enabled == 1 ? 1 : 0<br/>  ...<br/>}</span></pre><h2 id="92f9" class="lf lg iq bd lh li lj dn lk ll lm dp ln ko lo lp lq ks lr ls lt kw lu lv lw lx bi translated">额外的东西</h2><p id="479b" class="pw-post-body-paragraph kd ke iq kf b kg nw ki kj kk nx km kn ko ny kq kr ks nz ku kv kw oa ky kz la ij bi translated">我上面所有的例子和参考都使用了<code class="fe lb lc ld le b">count</code>原语。这个逻辑也适用于<code class="fe lb lc ld le b">for_each</code>。</p><pre class="ly lz ma mb gt mc le md me aw mf bi"><span id="84ba" class="lf lg iq le b gy mg mh l mi mj">for_each = local.is_feature_enabled == 1 &amp;&amp; var.listA != [] ? var.listA : []</span></pre><p id="fb4b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你会注意到，除了<code class="fe lb lc ld le b">local.is_feature_enabled</code>，我还会检查<code class="fe lb lc ld le b">var.listA</code>是否为空。这是为了演示在您拥有可选资源的情况下，可以添加额外的逻辑。</p><h1 id="b6a8" class="nf lg iq bd lh ng od ni lk nj oe nl ln nm of no lq np og nr lt ns oh nu lw nv bi translated">结论</h1><p id="d441" class="pw-post-body-paragraph kd ke iq kf b kg nw ki kj kk nx km kn ko ny kq kr ks nz ku kv kw oa ky kz la ij bi translated">我希望这篇文章展示了两种在陆地上保持干燥的方法。保持干燥可以提高可读性、可维护性和有效性。</p></div><div class="ab cl my mz hu na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ij ik il im in"><p id="c979" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="oi">为了获得无限的故事，你也可以考虑</em> <a class="ae kc" href="https://blog.rhel.solutions/membership" rel="noopener ugc nofollow" target="_blank"> <em class="oi">注册</em> </a> <em class="oi">成为中等会员，只需 5 美元。如果你使用</em> <a class="ae kc" href="https://blog.rhel.solutions/membership" rel="noopener ugc nofollow" target="_blank"> <em class="oi">我的链接</em> </a> <em class="oi">注册，我会收到一小笔佣金(不需要你额外付费)。</em></p></div></div>    
</body>
</html>