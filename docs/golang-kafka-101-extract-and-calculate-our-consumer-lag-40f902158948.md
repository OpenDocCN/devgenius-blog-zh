# 戈朗·卡夫卡 101:提取并计算我们的消费滞后

> 原文：<https://blog.devgenius.io/golang-kafka-101-extract-and-calculate-our-consumer-lag-40f902158948?source=collection_archive---------5----------------------->

我们的[系列](https://medium.com/@javiersotodev/series-intro-to-managing-golang-kafka-consumer-lag-41b36d3a14b9)的第二部分，用最重要的自定义指标管理我们的 Golang Kafka 消费者:消费者滞后。在这里，我们将解释和展示代码部分，以计算和公开我们的服务的消费者滞后

![](img/b3aa01dd69d0034f154b09ebcbeafeca.png)

# TL；速度三角形定位法(dead reckoning)

从本质上来说，代码就像一个本地计算器，用于运行特定的消费者实例，并为其分配特定的分区。我们计算最高偏移量(产生的最后一条消息)和消费者的当前偏移量之间的差值，这个差值就是我们所说的消费者延迟或积压。这些信息随后通过端点公开，以便动态访问。

# 介绍

在这篇文章中，我将从技术上解释不同的方法和代码片段，这些方法和代码片段用于计算和暴露我们的消费者滞后，为我们未来的步骤做准备。

1.  [简介:管理 Golang Kafka 消费滞后](https://javiersotodev.medium.com/series-intro-to-managing-golang-kafka-consumer-lag-41b36d3a14b9)
2.  提取并计算我们的消费者滞后
3.  构建和使用我们的定制 HPA
4.  深入了解我们的 Kubernetes 控制器

# 戈朗卡夫卡消费者的问题

在与 Golang 和它的 Confluence Kafka 软件包一起工作了几年之后，我可以肯定地说，毕竟它提供了令人惊奇的东西，而且实现起来又快又容易；它缺少 Java Kafka 消费者提供的开箱即用的基本要素之一:指标。

尽管有多种方法来聚集和导出这些指标，但是您确实需要对软件包有广泛的了解，以便针对具体情况。这是我为自己的用例所做的研究，这也是我与大家分享的原因。我们工程师互相帮助，使我们的生活更容易。

# 第一步

作为一个经验法则，每次我编码时，我组织我的初步模型并创建结构。我们将有两个简单的结构来表示我们所有的消费者滞后信息。

# 我们的“计算器”

我们的计算器很简单，我们将创建一个名为“Backlog”的函数来计算我们的滞后，该函数将返回我们的“lag”对象，并在发生错误时返回一个错误。在我们的函数中，我们将执行一个两步过程:

*   通过 Kafka 包中的方法获取我们的主题/分区信息
*   从分配的分区获取水印偏移，使用产生的最高偏移(highOffset)和提交的最后偏移(offset)计算我们的滞后。我们将它保存到我们的结构中，并将每个分区的延迟添加到 totalLag 变量中

# 暴露我们的度量

太好了！我们已经为滞后计算器添加了逻辑，现在是时候使用它了。为此，我们将通过路由器暴露它。在这种情况下，我将[围棋](https://github.com/go-chi/chi)用于我们的路由器:

# 次要方法

另一种展示/可视化我们的度量的方法是通过卡夫卡事件。尽管这个方法不能手动触发，但是可以通过日志导出器以恒定的方式将其导出为 ELK 堆栈(这就是我们使用它的方式)。

为此，您需要稍微更改一下 Kafka 消费者的配置，并正确处理事件:

在这个函数中，我们通过从 stats 事件中检索的信息来计算延迟:

# 包扎

在这一点上，我们已经暴露了我们的消费者滞后，并准备好被利用，但是有一个问题，这将只显示消费者(或消费者组)的特定实例的消费者滞后。这意味着，如果您有 10 个 pods/consumer 实例在运行和阅读，您必须逐个点击它们并合计滞后，以获得该组的完整消费者滞后。你不要担心，因为我已经找到了一个解决方案，这将需要更多的设置与另一个服务:我们的 Kubernetes 控制器。

下一篇文章将关注我们为 Golang Kafka 消费者定制的 HPA！(终于知道了)