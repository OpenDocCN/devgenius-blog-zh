<html>
<head>
<title>Build your own DSL with Go &amp; HCL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Go &amp; HCL 构建您自己的 DSL</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/build-your-own-dsl-with-go-hcl-602c92ce24c0?source=collection_archive---------3-----------------------#2022-02-07">https://blog.devgenius.io/build-your-own-dsl-with-go-hcl-602c92ce24c0?source=collection_archive---------3-----------------------#2022-02-07</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><blockquote class="jk jl jm"><p id="01f4" class="jn jo jp jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ig bi translated">DSL 代表特定领域语言</p></blockquote><p id="c711" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy km ka kb kc kn ke kf kg ko ki kj kk kl ig bi translated">Kubernetes、Docker compose、Jenkins CI、Gitlab CI 或 Ansible 等工具的主要目标是可以通过配置定制它们的行为。它们就像一个黑匣子，根据输入(YAML/JSON 描述符)，会产生不同的输出。</p><p id="3d26" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy km ka kb kc kn ke kf kg ko ki kj kk kl ig bi translated">属于 HashiCorp 的其他工具，如 Terraform、Vault 或 Nomad 使用 HCL 而不是 YAML 和 JSON。HCL 代表 HashiCorp 配置语言，它比 JSON 或 YAML 更强大，因为它提供了机制。来实现动态配置文件，我们将在后面看到。HCL 的一些优点列举如下:</p><ul class=""><li id="68ed" class="kp kq in jq b jr js jv jw km kr kn ks ko kt kl ku kv kw kx bi translated">即使对非技术人员来说，阅读(和写作)也很容易。</li><li id="bf58" class="kp kq in jq b jr ky jv kz km la kn lb ko lc kl ku kv kw kx bi translated">正如我们将要做的，实现定制 DSL 并不是火箭科学，因为解析、验证和许多东西都是现成的。</li><li id="b7a8" class="kp kq in jq b jr ky jv kz km la kn lb ko lc kl ku kv kw kx bi translated">已经提供了一堆现有的功能。</li><li id="341d" class="kp kq in jq b jr ky jv kz km la kn lb ko lc kl ku kv kw kx bi translated">像 HashiCorp 这样的知名公司正在进行这个项目，Terraform、Nomad 和 Vault 等优秀产品都使用 HCL。这意味着 Ops 社区已经习惯了使用这种语法。</li></ul><p id="44e8" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy km ka kb kc kn ke kf kg ko ki kj kk kl ig bi translated">另一方面，要实现一个基于 HCL 的定制 DSL，你需要<strong class="jq io">了解 Go。但是我认为如果你正在阅读这篇文章，你已经具备了所需的知识。</strong></p><h1 id="051c" class="ld le in bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">HCL 看起来怎么样？</h1><p id="b5f5" class="pw-post-body-paragraph jn jo in jq b jr mb jt ju jv mc jx jy km md kb kc kn me kf kg ko mf kj kk kl ig bi translated">图-1 中的三列代表相同的信息。这是 K8s 配置的一个例子。</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi mg"><img src="../Images/14909f00caadc9c096108c073eb61d6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i9H6KCFSZZgSzbZE8gIjHA.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">图 HCL、JSON 中的相同 K8s 配置。还有 YAML</figcaption></figure><p id="f9f1" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy km ka kb kc kn ke kf kg ko ki kj kk kl ig bi translated">查看图 1 后，我们可以确定最佳语法是 YAML 提供的，因为这个文件是最短的。但是…请记住 K8s 是一个动态工具，但是它的配置是<code class="fe mw mx my mz b">static.</code>我的意思是 Kubernetes 的配置需要以一种非常特定的格式编写，并且没有创建动态配置的余地。</p><h1 id="d3fa" class="ld le in bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">HCL 示例</h1><p id="e2b6" class="pw-post-body-paragraph jn jo in jq b jr mb jt ju jv mc jx jy km md kb kc kn me kf kg ko mf kj kk kl ig bi translated">我认为一个很好的展示是用于定义持续集成(CI)或持续部署管道的 DSL。让我们看看下面的 HCL 脚本。</p><p id="e874" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy km ka kb kc kn ke kf kg ko ki kj kk kl ig bi translated">example.hcl</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi na"><img src="../Images/b1ae10201e38db4616356638648b7e0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*blmkHH7PAFWhWVWRMjOoig.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">图 2 —我们的 DSL 使用示例</figcaption></figure><p id="4e44" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy km ka kb kc kn ke kf kg ko ki kj kk kl ig bi translated">即使您以前没有见过这个 DSL，您也知道这个脚本的目的，对吗？管道包含几个作业:第一个似乎运行 Python 脚本，第二个似乎运行 Python 脚本，后来它通过 Slack 发送通知。我们必须识别 HCL 脚本中的某些部分。图 3 的目的是帮助我们识别这些部分。</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi nb"><img src="../Images/b4e0290499427c75c3169e3554aa2406.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qsLZE_oK8DK-i3tqebUpZA.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">图 3 HCL 脚本中部件的标识</figcaption></figure><ul class=""><li id="8296" class="kp kq in jq b jr js jv jw km kr kn ks ko kt kl ku kv kw kx bi translated"><strong class="jq io">变量:</strong>变量包含在 HCL 上下文中。HCL 上下文用于评估块中其他变量的值和属性值。</li><li id="d95f" class="kp kq in jq b jr ky jv kz km la kn lb ko lc kl ku kv kw kx bi translated"><strong class="jq io">块:</strong>块由名称(必需)、标签(可选)、属性(可选)和子块(可选)组成。</li><li id="0ebc" class="kp kq in jq b jr ky jv kz km la kn lb ko lc kl ku kv kw kx bi translated"><strong class="jq io">属性:</strong>有可选的和必需的属性，它们总是被定义在一个块中。</li><li id="6589" class="kp kq in jq b jr ky jv kz km la kn lb ko lc kl ku kv kw kx bi translated"><strong class="jq io">(自定义)函数:</strong>函数使我们能够将编程操作的结果赋给变量。虽然已经有一些默认提供的函数，我们学习如何实现新的函数。</li></ul><p id="b967" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy km ka kb kc kn ke kf kg ko ki kj kk kl ig bi translated">关于我们例子中的 DSL，我们可以陈述如下:</p><ul class=""><li id="7f75" class="kp kq in jq b jr js jv jw km kr kn ks ko kt kl ku kv kw kx bi translated">有三个区块:<code class="fe mw mx my mz b">job</code>、<code class="fe mw mx my mz b">python</code>和<code class="fe mw mx my mz b">slack</code></li><li id="8bb3" class="kp kq in jq b jr ky jv kz km la kn lb ko lc kl ku kv kw kx bi translated">块<code class="fe mw mx my mz b">job</code>可以包含类型<code class="fe mw mx my mz b">python</code>和<code class="fe mw mx my mz b">slack</code>的子块。</li><li id="a24f" class="kp kq in jq b jr ky jv kz km la kn lb ko lc kl ku kv kw kx bi translated">块<code class="fe mw mx my mz b">job</code>有两个标签:第一个标签用于定义作业的名称，第二个标签用于添加简要描述。</li><li id="68e4" class="kp kq in jq b jr ky jv kz km la kn lb ko lc kl ku kv kw kx bi translated">块<code class="fe mw mx my mz b">python</code>只有一个标签，即要执行的 python 脚本的名称。</li><li id="9777" class="kp kq in jq b jr ky jv kz km la kn lb ko lc kl ku kv kw kx bi translated">块<code class="fe mw mx my mz b">python</code>有一个可选属性<code class="fe mw mx my mz b">root_dir</code>。</li><li id="87b9" class="kp kq in jq b jr ky jv kz km la kn lb ko lc kl ku kv kw kx bi translated">块<code class="fe mw mx my mz b">slack</code>有两个属性:<code class="fe mw mx my mz b">channel</code>和<code class="fe mw mx my mz b">message</code>。</li></ul><h1 id="ceca" class="ld le in bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">编码</h1><p id="3141" class="pw-post-body-paragraph jn jo in jq b jr mb jt ju jv mc jx jy km md kb kc kn me kf kg ko mf kj kk kl ig bi translated">首先，我们需要定义与我们想要的 DSL 相匹配的 HCL 模式。我们将遵循自下而上的方法。这意味着我们将从不包含其他子块的块开始。对于每个块，我们需要定义块 ID(块的名称)、带有标签的数组和 BodySchema(可以包含的属性和块)</p><h2 id="9f92" class="nc le in bd lf nd ne dn lj nf ng dp ln km nh ni lr kn nj nk lv ko nl nm lz nn bi translated">dsl/schema.go</h2><p id="e188" class="pw-post-body-paragraph jn jo in jq b jr mb jt ju jv mc jx jy km md kb kc kn me kf kg ko mf kj kk kl ig bi translated"><a class="ae no" href="https://github.com/ivancorrales/hcl-by-example/blob/main/dsl/schema.go" rel="noopener ugc nofollow" target="_blank">源代码</a></p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi np"><img src="../Images/7b912a6eb01fb23e0ff0eaaaebccefc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1208/format:webp/1*7HHQaH6XovOoi66gRFPtfg.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">图 4 —块的模式定义</figcaption></figure><p id="6772" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy km ka kb kc kn ke kf kg ko ki kj kk kl ig bi translated">HCL 定义用于将输入文件解析为内部 HCL 结构(通用结构)，并将用于验证解析后的文件。</p><p id="02ff" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy km ka kb kc kn ke kf kg ko ki kj kk kl ig bi translated">不要忘记上面例子中出现的<code class="fe mw mx my mz b">random(10)</code>函数。这个函数的实现如图 5 所示。</p><h2 id="9af3" class="nc le in bd lf nd ne dn lj nf ng dp ln km nh ni lr kn nj nk lv ko nl nm lz nn bi translated">dsl/functions.go</h2><p id="a70a" class="pw-post-body-paragraph jn jo in jq b jr mb jt ju jv mc jx jy km md kb kc kn me kf kg ko mf kj kk kl ig bi translated"><a class="ae no" href="https://github.com/ivancorrales/hcl-by-example/blob/main/dsl/functions.go" rel="noopener ugc nofollow" target="_blank">源代码</a></p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi nq"><img src="../Images/851e7f168ebb3fd253b628501022745c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6soMZZdGYVwh54oS1J3YNg.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">图 5—自定义函数 random(int)的实现</figcaption></figure><p id="3fc3" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy km ka kb kc kn ke kf kg ko ki kj kk kl ig bi translated">如果您想查看更多自定义功能的实现，请访问<a class="ae no" href="https://github.com/wesovilabs/orion/tree/master/functions" rel="noopener ugc nofollow" target="_blank">此链接</a>。我在建造<a class="ae no" href="https://wesovilabs.github.io/orion/spec/actions/print/" rel="noopener ugc nofollow" target="_blank">猎户座</a>的时候创造了几个。</p><p id="7374" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy km ka kb kc kn ke kf kg ko ki kj kk kl ig bi translated">我们刚刚定义了模式(HCL 结构)，但是我们应该将我们自己的 DSL 建模成更友好的结构。此外，我们希望执行脚本中的内容，而不仅仅是解析它们。查看图 6 中的代码，您将意识到所有的结构都实现了一个带有以下签名的方法<code class="fe mw mx my mz b">Run(*hcl.context) error.</code>。脚本的执行将遵循自顶向下的方法。之所以有接口<code class="fe mw mx my mz b">Step</code>是因为我们需要保持<code class="fe mw mx my mz b">job</code>块中步骤的顺序(它可以包含<code class="fe mw mx my mz b">python</code>和<code class="fe mw mx my mz b">slack`)</code></p><h2 id="8054" class="nc le in bd lf nd ne dn lj nf ng dp ln km nh ni lr kn nj nk lv ko nl nm lz nn bi translated">dsl/model.go</h2><p id="9506" class="pw-post-body-paragraph jn jo in jq b jr mb jt ju jv mc jx jy km md kb kc kn me kf kg ko mf kj kk kl ig bi translated"><a class="ae no" href="https://github.com/ivancorrales/hcl-by-example/blob/main/dsl/model.go" rel="noopener ugc nofollow" target="_blank">源代码</a></p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi nr"><img src="../Images/460a17e7bd24ac49b2ca1beea071ebf3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*28TinsJUEwVGIUnVJmyAAw.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">图 6 —模块的模型实现</figcaption></figure><p id="b60a" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy km ka kb kc kn ke kf kg ko ki kj kk kl ig bi translated">我们几乎完成了，我们只需要实现将 HCL 结构转换成我们的实现的代码。</p><h2 id="a768" class="nc le in bd lf nd ne dn lj nf ng dp ln km nh ni lr kn nj nk lv ko nl nm lz nn bi translated">DSL/解码器. go</h2><p id="ed65" class="pw-post-body-paragraph jn jo in jq b jr mb jt ju jv mc jx jy km md kb kc kn me kf kg ko mf kj kk kl ig bi translated"><a class="ae no" href="https://github.com/ivancorrales/hcl-by-example/blob/main/dsl/decoder.go" rel="noopener ugc nofollow" target="_blank">源代码</a></p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi ns"><img src="../Images/0f8282c9515dea0b7dea6b45d36ed04c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p9AprtC2NuygD4AGZeP7gQ.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">图 7—根文件的解码器</figcaption></figure><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi nt"><img src="../Images/8cf84fd278f653fc2b2beae49e85b225.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W-N6LTQKO6f7-K2ymK8MgQ.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">图 8 —块作业、python 和 slack 的解码器</figcaption></figure><p id="1eb8" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy km ka kb kc kn ke kf kg ko ki kj kk kl ig bi translated">为了运行代码，我们可以实现一个基本的 main 函数，如图 9 所示。</p><h2 id="8095" class="nc le in bd lf nd ne dn lj nf ng dp ln km nh ni lr kn nj nk lv ko nl nm lz nn bi translated">main.go</h2><p id="a9ee" class="pw-post-body-paragraph jn jo in jq b jr mb jt ju jv mc jx jy km md kb kc kn me kf kg ko mf kj kk kl ig bi translated"><a class="ae no" href="https://github.com/ivancorrales/hcl-by-example/blob/main/main.go" rel="noopener ugc nofollow" target="_blank">源代码</a></p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi nu"><img src="../Images/aa6741879080c8b098cb9cad956dd52a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EaGsyVHVc8f0MQMr1SDdeQ.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">图 9 —主要功能</figcaption></figure><p id="1294" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy km ka kb kc kn ke kf kg ko ki kj kk kl ig bi translated">要运行这个示例，您只需要传递示例文件。</p><blockquote class="jk jl jm"><p id="c187" class="jn jo jp jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ig bi translated">去主路，去</p></blockquote><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi nv"><img src="../Images/cdbc965ed4aca3dbbed525c86c5ad526.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YNK2mya1YhYk2VartXjAwQ.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">图 10 —的输出</figcaption></figure><p id="51cc" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy km ka kb kc kn ke kf kg ko ki kj kk kl ig bi translated">有几个工具利用了 HCL，但关键是你可以创建自己的 DSL，并构建像 Terraform 或 Nomad 这样伟大的东西。</p><p id="1fca" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy km ka kb kc kn ke kf kg ko ki kj kk kl ig bi translated">我也鼓励你去看一看<a class="ae no" href="https://github.com/wesovilabs/orion" rel="noopener ugc nofollow" target="_blank">猎户座</a>。这是我创建的一个个人项目，我学到了很多关于 HCL 的知识。</p><p id="511c" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy km ka kb kc kn ke kf kg ko ki kj kk kl ig bi translated"><a class="ae no" href="https://github.com/ivancorrales/hcl-by-example" rel="noopener ugc nofollow" target="_blank">这个库的完整代码可以从 Github 下载</a></p><div class="nw nx gp gr ny nz"><a href="https://github.com/ivancorrales/hcl-by-example" rel="noopener  ugc nofollow" target="_blank"><div class="oa ab fo"><div class="ob ab oc cl cj od"><h2 class="bd io gy z fp oe fr fs of fu fw im bi translated">GitHub-ivancorrales/HCl-示例</h2><div class="og l"><h3 class="bd b gy z fp oe fr fs of fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="oh l"><p class="bd b dl z fp oe fr fs of fu fw dk translated">github.com</p></div></div><div class="oi l"><div class="oj l ok ol om oi on mq nz"/></div></div></a></div><figure class="mh mi mj mk gt ml gh gi paragraph-image"><a href="https://www.buymeacoffee.com/ivancorrales"><div class="gh gi oo"><img src="../Images/2093d0f16d94a8942508624035f676b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QCQqlZr6doDP-cszzpaSpw.png"/></div></a></figure></div></div>    
</body>
</html>