<html>
<head>
<title>Music Recommendation System Using Sentence Transformers, Faiss with DVC.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">音乐推荐系统使用句子变压器，Faiss 与 DVC。</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/music-recommendation-system-using-sentence-transformers-faiss-with-dvc-60508ccdc5d0?source=collection_archive---------18-----------------------#2022-12-12">https://blog.devgenius.io/music-recommendation-system-using-sentence-transformers-faiss-with-dvc-60508ccdc5d0?source=collection_archive---------18-----------------------#2022-12-12</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="ddce" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated"><strong class="ak">引言。</strong></h2></div><p id="f410" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这篇文章中，我将讲述如何使用另一个 MLops 框架<strong class="ke io"> DVC </strong>来执行数据版本、代码版本、代码可再现性、模型注册和实验跟踪。我已经创建了一个基本的音乐推荐系统，它使用<strong class="ke io">语句转换器</strong>来计算嵌入矩阵，使用<strong class="ke io"> Faiss </strong>来执行相似性搜索。这篇文章的主要目的是让我们深入了解如何使用 DVC。</p><h2 id="3390" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">DVC。</h2><p id="a798" class="pw-post-body-paragraph kc kd in ke b kf lr jo kh ki ls jr kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">DVC 是一个机器学习项目的开源版本控制系统。但是我对称它为版本控制系统有相当大的分歧，因为我认为它不是一个完整的版本控制系统，稍后会讨论这个问题。</p><ul class=""><li id="1566" class="lw lx in ke b kf kg ki kj kl ly kp lz kt ma kx mb mc md me bi translated">DVC 可以做其他 MLops 框架能够做的事情:模型、代码、数据版本、模型注册、代码可复制性等。</li><li id="0041" class="lw lx in ke b kf mf ki mg kl mh kp mi kt mj kx mb mc md me bi translated">如果有人对 git 命令有基本的了解，就可以很容易理解 DVC 是如何工作的。</li></ul><p id="a0e0" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">DVC 是如何工作的？</strong></p><p id="b1d5" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们通过一个例子来理解这一点，我在情感分析任务上训练了我的模型，在训练时，我使用了<strong class="ke io"> DVCLive </strong>来跟踪实验，一旦我的模型被训练，DVC<strong class="ke io">就会为这个实验创建一个具有不同情节的 HTML 文件。结果是模型的大小约为<strong class="ke io"> 2.3GB </strong>，数据集大小约为<strong class="ke io"> 200MB。</strong>现在，为了存储模型和数据，并对其进行版本化，我们可以使用 GitHub，但问题是数据集和模型的大小。DVC 通过允许添加远程存储提供了解决方案，远程存储可以是 Dagshub、云存储、GoogleDrive 等。DVC 在 GitHub 和你的远程存储器之间建立了一个链接，在 Github 中保存哈希键，在远程位置保存与哈希键对应的数据，所以现在每当有人需要获取数据时，它只需检查我们在 Github 中创建的标签，然后使用 DVC pull 命令获取与哈希键相关的相应文件。因此，如果我们理解这一点，我们可以说 DVC 实际上是聪明地利用 GitHub 来执行所有的版本控制任务，所以这就是为什么我之前说 DVC 实际上没有做版本控制，而 Github 负责版本控制，DVC 做所有的繁重工作。</strong></p><h2 id="e417" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">句子变形金刚&amp; Faiss。</h2><p id="0ac2" class="pw-post-body-paragraph kc kd in ke b kf lr jo kh ki ls jr kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">SentenceTransformers 是一个 Python 框架，用于最先进的句子、文本和图像嵌入。它提供了一个不同的微调模型，可以很容易地用来计算嵌入。FAISS(脸书人工智能相似性搜索)是一个库，允许人们快速搜索彼此相似的多媒体文档的嵌入。它解决了针对基于散列的搜索而优化的传统查询搜索引擎的局限性，并提供了更多可扩展的相似性搜索功能。</p><h2 id="835c" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">数据集详细信息。</h2><p id="28b0" class="pw-post-body-paragraph kc kd in ke b kf lr jo kh ki ls jr kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">本实验使用的数据集是取自 Kaggle 的<strong class="ke io"> Spotify 百万首歌曲数据集</strong>，可从以下链接下载:</p><blockquote class="mk ml mm"><p id="d858" class="kc kd mn ke b kf kg jo kh ki kj jr kk mo km kn ko mp kq kr ks mq ku kv kw kx ig bi translated"><a class="ae mr" href="https://www.kaggle.com/code/notshrirang/music-recommender-using-pair-similarities/data" rel="noopener ugc nofollow" target="_blank">https://www . ka ggle . com/code/not shri rang/music-recommender-using-pair-similarities/data</a></p></blockquote><figure class="mt mu mv mw gt mx gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi ms"><img src="../Images/ccdb286fb48e27ea44493a9ae941175d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JJCOYjiMuFCCwi3eME2mhg.png"/></div></div></figure><p id="607a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">该数据集包含歌曲名称、艺术家姓名、歌曲链接和歌词。该数据集可用于推荐歌曲和对歌曲进行分类或聚类。我已经用它在我们的案例中构建了一个推荐系统，但是您可以尝试不同的用例。</p><h2 id="0dcb" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">实施细节。</h2><p id="47e2" class="pw-post-body-paragraph kc kd in ke b kf lr jo kh ki ls jr kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">我构建了两个不同的 py 文件，一个用于数据集的预处理，另一个是主文件，它接受输入查询并推荐前 5 首歌曲。</p><p id="74ac" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">预处理。</strong></p><pre class="mt mu mv mw gt ne nf ng bn nh ni bi"><span id="0cf2" class="nj kz in nf b be nk nl l nm nn">import pandas as pd<br/>import string<br/>import re <br/>from config import CONFIG<br/><br/>class PREPROCESS:<br/>    def __init__(self) -&gt; None:<br/>        df = pd.read_csv(CONFIG.DATA_FILE)<br/>        df["prepText"] = df["text"].apply(self.cleanString)<br/>        df = df[["artist", "song", "prepText"]]<br/>        df["allText"] = df["artist"]+" "+df["song"] + " "+df["prepText"]<br/>        # save the file <br/>        df.to_csv(CONFIG.REFRACTOR_FILE_PATH, index=False)<br/>    <br/>    def cleanString(self,sentence):<br/>        sentence = sentence.translate(str.maketrans("","", string.punctuation)).strip().lower()<br/>        sentence = re.sub(r"https?://\s+", "", sentence)<br/>        sentence = re.sub(r"\b\d+\b",  "", sentence)<br/>        sentence = re.sub(r" +"," ",sentence).replace("\n", " ").replace("\r", "").replace("\r\n", "")<br/>        sentence = re.sub("\s+", " ", sentence)<br/>        return sentence    <br/><br/><br/><br/>PREPROCESS()</span></pre><p id="301c" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是一个非常基本的预处理文件，由类<strong class="ke io">预处理</strong>组成，负责通过删除链接、标点、数字等来清理句子。数据清理后，我们将<em class="mn">艺术家、歌曲、prepText </em>组合在一起，保存在<strong class="ke io"> allText </strong>中。</p><p id="0a83" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">推荐制。</strong></p><pre class="mt mu mv mw gt ne nf ng bn nh ni bi"><span id="1468" class="nj kz in nf b be nk nl l nm nn">class findEmbedding:<br/>    def __init__(self) -&gt; None:<br/>        self.df = pd.read_csv(CONFIG.REFRACTOR_FILE_PATH)<br/>        self.model = SentenceTransformer('all-MiniLM-L6-v2')<br/>        embeddings = self.computeEmbeddings()<br/>        # let's check if the folder exist <br/>        if not os.path.isdir(CONFIG.SAVE_EMBEDDINGS):<br/>            os.mkdir(CONFIG.SAVE_EMBEDDINGS)<br/>        #save the embedding file.<br/>        PATH = os.path.join(CONFIG.SAVE_EMBEDDINGS, "embedding.npy")<br/>        with open( PATH, "wb") as fp:<br/>            np.save(fp, embeddings)<br/><br/>    def computeEmbeddings(self):<br/>        sentences = self.df["allText"].values<br/>        # let's compute the embeddding<br/>        embeddings = []<br/>        for sentence in tqdm(sentences):<br/>            embeddings.append(self.model.encode(sentence))<br/>        return np.array(embeddings)<br/><br/>class recmmSystem:<br/>    def __init__(self) -&gt; None:<br/>        self.model = SentenceTransformer('all-MiniLM-L6-v2')<br/>        self.df = pd.read_csv(CONFIG.REFRACTOR_FILE_PATH)<br/>        PATH = os.path.join(CONFIG.SAVE_EMBEDDINGS, "embedding.npy")<br/>        embeddings = np.load(PATH)<br/>        dimension = embeddings.shape[1]<br/>        quantize = faiss.IndexFlatL2(dimension)<br/>        self.index = faiss.IndexIVFFlat(quantize, dimension, 50)<br/><br/>        if not self.index.is_trained:<br/>            self.index.train(embeddings)<br/>        <br/>        if self.index.is_trained:<br/>            # let's add this <br/>            self.index.add(embeddings)<br/><br/>        print("Total Number of embeddings index {}".format(self.index.ntotal))<br/>    <br/>    def nearestNeighbour(self, query, k):<br/>        # we can now search <br/>        queryEmbeddings = self.model.encode([query])<br/>        D, I = self.index.search(queryEmbeddings, k)<br/>        # let's get the index result <br/>        artist_songs = dict()<br/>        allRelatable = self.df.iloc[I[0]]<br/>        for index, rows in allRelatable.iterrows():<br/>            artist_songs[rows["artist"]] = rows["song"]<br/>        <br/>        print("Query: ", query)<br/>        pprint(artist_songs)</span></pre><p id="ae12" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我构建了两个类:</p><ol class=""><li id="4e71" class="lw lx in ke b kf kg ki kj kl ly kp lz kt ma kx no mc md me bi translated"><strong class="ke io"> findEmbedding: </strong>这个类负责计算列名<strong class="ke io"> allText 上的嵌入，</strong>它使用 SentenceTransformers 来计算文本的嵌入。使用的型号是<strong class="ke io">全小型 L6 v2。</strong>所有计算的嵌入都存储在一个 NumPy 文件中，该文件将使用<strong class="ke io"> DVC、</strong>保存在远程位置，我们将在本文后面看到。</li><li id="e8e3" class="lw lx in ke b kf mf ki mg kl mh kp mi kt mj kx no mc md me bi translated"><strong class="ke io"> recmmSystem: </strong>这是推荐系统的大脑，这个类负责使用<strong class="ke io"> FAISS、</strong>创建搜索索引，该索引用于在方法<strong class="ke io">nereastnighborhood</strong>中对给定的查询执行搜索。</li></ol><h2 id="dd12" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">用于版本控制的 DVC/Github。</h2><p id="ce29" class="pw-post-body-paragraph kc kd in ke b kf lr jo kh ki ls jr kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">到目前为止，我们讨论了两个名为预处理和推荐的文件。运行这两个文件将节省两件事:</p><ol class=""><li id="3862" class="lw lx in ke b kf kg ki kj kl ly kp lz kt ma kx no mc md me bi translated"><strong class="ke io"> refactor.csv: </strong>这是预处理后的数据集。</li><li id="0438" class="lw lx in ke b kf mf ki mg kl mh kp mi kt mj kx no mc md me bi translated"><strong class="ke io"> embedding.npy: </strong>嵌入文件由<strong class="ke io"> SentenceTransformers </strong>使用<strong class="ke io"> refactor.csv </strong>文件中的数据计算得出。</li></ol><p id="1a9d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如前所述，我们可以使用 GitHub 进行版本控制，使用 DVC 进行繁重的工作。所以这个想法是告诉 Github 只跟踪重文件的散列键，比如<strong class="ke io">refactor . CSV&amp;embeddings . npy，</strong>，让<strong class="ke io"> DVC </strong>在远程位置<strong class="ke io">存储重文件。</strong>我们需要遵循一些命令:</p><ol class=""><li id="163f" class="lw lx in ke b kf kg ki kj kl ly kp lz kt ma kx no mc md me bi translated">创建 GitHub 存储库。</li><li id="63cd" class="lw lx in ke b kf mf ki mg kl mh kp mi kt mj kx no mc md me bi translated">克隆存储库。</li></ol><blockquote class="mk ml mm"><p id="4554" class="kc kd mn ke b kf kg jo kh ki kj jr kk mo km kn ko mp kq kr ks mq ku kv kw kx ig bi translated"><strong class="ke io"> git 克隆 https </strong></p></blockquote><p id="b60a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">3.克隆的存储库最初将是空的，我们将所有我们希望<strong class="ke io"> DVC/Github </strong>跟踪的文件移到存储库中。</p><p id="4d83" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">4.我们去仓库里面吧。</p><blockquote class="mk ml mm"><p id="9806" class="kc kd mn ke b kf kg jo kh ki kj jr kk mo km kn ko mp kq kr ks mq ku kv kw kx ig bi translated"><strong class="ke io">光盘储存库名称</strong></p></blockquote><p id="a398" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">5.让我们决定你想为 DVC 使用哪个远程存储，在我的例子中，我使用<strong class="ke io"> DagsHub </strong>来存储大文件，GitHub 来跟踪小文件。人们也可以使用 google drive。</p><p id="eae9" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">6.一旦我们决定了要为 DVC 使用哪个远程存储位置，我们就可以开始这个过程。</p><p id="2b1c" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在进入下一步之前，记得按照上述步骤进行:</p><ol class=""><li id="ae1e" class="lw lx in ke b kf kg ki kj kl ly kp lz kt ma kx no mc md me bi translated">让我们初始化<strong class="ke io"> DVC，</strong>并添加远程位置，在我的例子中，我使用 DagsHub。</li></ol><pre class="mt mu mv mw gt ne nf ng bn nh ni bi"><span id="74bc" class="nj kz in nf b be nk nl l nm nn">dvc init<br/>dvc remote add origin https://dagshub.com/Anurich/DVC.dvc<br/>dvc remote modify origin - local auth basic<br/>dvc remote modify origin - local user username<br/>dvc remote modify origin - local password your_token</span></pre><p id="fb7c" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">2.如果您正在使用 Google Drive，我们可以简单地做到:</p><pre class="mt mu mv mw gt ne nf ng bn nh ni bi"><span id="7246" class="nj kz in nf b be nk nl l nm nn">dvc init dvc<br/>remote add -d storage gdrive://driverFolder</span></pre><p id="c2c8" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">3.开始时，我们说过运行两个不同的文件<strong class="ke io">预处理和推荐</strong>将生成两个工件<strong class="ke io"> refactor.csv 和 embedding.npy </strong>。我们可以使用<strong class="ke io"> DVC 运行</strong> CLI 命令来运行这两个<strong class="ke io"> <em class="mn"> py </em> </strong>文件。</p><pre class="mt mu mv mw gt ne nf ng bn nh ni bi"><span id="285f" class="nj kz in nf b be nk nl l nm nn">dvc run -n dataPreprocessing -d filepath -o outputpath python3 preprocessing.py<br/>dvc run -n recommd -d filepath -o outputpath python3 recommendation.py</span></pre><ul class=""><li id="a875" class="lw lx in ke b kf kg ki kj kl ly kp lz kt ma kx mb mc md me bi translated"><strong class="ke io"> -n: </strong>我们要为这次运行指定的名称。</li><li id="9d59" class="lw lx in ke b kf mf ki mg kl mh kp mi kt mj kx mb mc md me bi translated"><strong class="ke io"> -d: </strong>指定当前运行的文件依赖于哪个文件。</li><li id="57fa" class="lw lx in ke b kf mf ki mg kl mh kp mi kt mj kx mb mc md me bi translated"><strong class="ke io"> -o: </strong>输出文件的名称。</li></ul><p id="1a7a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">4.运行上面显示的命令后，<strong class="ke io"> DVC </strong>将创建两个不同的文件<strong class="ke io"> dvc.lock、dvc.yaml、</strong>，并通过将它们添加到<strong class="ke io"> .gitignore. </strong>中告诉 GitHub 不要跟踪这两个文件的输出</p><p id="bd9d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">5.所有这些步骤都将通过运行<strong class="ke io"> DVC </strong>运行命令自动完成，我们只需要使用下面的命令将其添加到 GitHub。</p><pre class="mt mu mv mw gt ne nf ng bn nh ni bi"><span id="2076" class="nj kz in nf b be nk nl l nm nn">git add dvc.lock dvc.yaml .gitignore<br/># We can also do this way<br/>git add .</span></pre><p id="c73c" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">6.下一步是使用<strong class="ke io"> GitHub </strong>提交，使用标签，跟随标签我们现在可以将文件推送到<strong class="ke io"> GitHub </strong>和<strong class="ke io"> DVC </strong>。<strong class="ke io"> DVC </strong>将包含大文件，而<strong class="ke io"> GitHub </strong>将只包含那些大文件的哈希密钥，以及那些<strong class="ke io"> DVC </strong>没有跟踪的文件。</p><pre class="mt mu mv mw gt ne nf ng bn nh ni bi"><span id="6fa0" class="nj kz in nf b be nk nl l nm nn">Git commit -m "v1.1"<br/>Git tag "v1.1"<br/># now we push<br/>Git push -u origin main<br/>dvc push -r origin</span></pre><p id="0595" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">7.现在，我们可以在不同版本之间切换，并从 DVC 远程存储位置提取存储的文件。</p><pre class="mt mu mv mw gt ne nf ng bn nh ni bi"><span id="f95a" class="nj kz in nf b be nk nl l nm nn">git checkout v1.1<br/>dvc pull</span></pre><p id="757d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io"> DVC 再现性。</strong></p><p id="1af9" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">运行<strong class="ke io"> DVC </strong>运行命令创建了两个文件，分别是<strong class="ke io"> dvc.lock，dvc.yaml. </strong>在进入 DVC 的再现性特性之前，让我们先了解一下这些文件。</p><p id="aabd" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io"> dvc.lock </strong></p><pre class="mt mu mv mw gt ne nf ng bn nh ni bi"><span id="2f9b" class="nj kz in nf b be nk nl l nm nn">schema: '2.0'<br/>stages:<br/>  dataPreprocessing:<br/>    cmd: python3 src/preprocessing.py<br/>    deps:<br/>    - path: dataset/spotify_millsongdata.csv<br/>      md5: 43362926568f939553de657b8be80d79<br/>      size: 74864162<br/>    outs:<br/>    - path: dataset/refactor.csv<br/>      md5: 54052d04458ccb02c462db552f0cb77c<br/>      size: 125596291<br/>  ComputeEmbeddings:<br/>    cmd: python3 src/recommendationSystem.py<br/>    deps:<br/>    - path: dataset/refactor.csv<br/>      md5: 54052d04458ccb02c462db552f0cb77c<br/>      size: 125596291<br/>    outs:<br/>    - path: embeddings/<br/>      md5: 6bdddf35b4ffcb060cad65a59cdd8bf4.dir<br/>      size: 88550528<br/>      nfiles: 1</span></pre><p id="ca13" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">dvc.lock 文件包含两个阶段，每个阶段显示使用<strong class="ke io"> DVC </strong>运行命令时我们分配给文件的名称。在每个阶段，它显示三种不同的 YAML 阵列:</p><ul class=""><li id="9d44" class="lw lx in ke b kf kg ki kj kl ly kp lz kt ma kx mb mc md me bi translated"><strong class="ke io"> cmd : </strong>这是我们在<strong class="ke io"> DVC </strong>运行命令期间传递的<strong class="ke io">命令</strong>来运行相应的文件。</li><li id="ebb7" class="lw lx in ke b kf mf ki mg kl mh kp mi kt mj kx mb mc md me bi translated"><strong class="ke io"> deps : </strong>表示依赖，即当前运行的文件依赖于哪个文件。它由列表名<strong class="ke io">路径</strong>和对应的哈希值组成。哈希值用于从远程位置提取数据。</li><li id="61fd" class="lw lx in ke b kf mf ki mg kl mh kp mi kt mj kx mb mc md me bi translated"><strong class="ke io"> outs : </strong>它是输出目录的路径，当前运行文件的输出将存储在这个目录中。它也有自己的哈希值。</li></ul><p id="182c" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io"> DVC </strong>正在使用文件的哈希值跟踪文件。我们可以使用这个哈希值来提取原始文件。</p><p id="87b8" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io"> dvc.yaml </strong></p><pre class="mt mu mv mw gt ne nf ng bn nh ni bi"><span id="ecff" class="nj kz in nf b be nk nl l nm nn">stages:<br/>  dataPreprocessing:<br/>    cmd: python3 src/preprocessing.py<br/>    deps:<br/>    - dataset/spotify_millsongdata.csv<br/>    outs:<br/>    - dataset/refactor.csv<br/>  ComputeEmbeddings:<br/>    cmd: python3 src/recommendationSystem.py<br/>    deps:<br/>    - dataset/refactor.csv<br/>    outs:<br/>    - embeddings/</span></pre><p id="c692" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">该文件也由<strong class="ke io"> DVC </strong>运行命令生成。该文件显示了完整的管道和执行顺序。它以 YAML 格式存储了我们在 DVC 运行期间传递的所有命令。现在，一旦我们从<strong class="ke io"> DVC </strong>运行中获得这些文件，我们就不需要重写<strong class="ke io"> DVC </strong>运行命令，我们可以简单地做:</p><blockquote class="mk ml mm"><p id="71b5" class="kc kd mn ke b kf kg jo kh ki kj jr kk mo km kn ko mp kq kr ks mq ku kv kw kx ig bi translated"><strong class="ke io"> dvc 再现</strong></p></blockquote><p id="71a5" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">只有在以前从未运行过或者文件中发生了任何更改的情况下，此命令才会重新运行整个管道。如果<strong class="ke io"> DVC </strong>发现该进程已经执行并且该文件内没有新的添加或者没有新的参数添加<strong class="ke io"> DVC </strong>将不会执行这些文件。<strong class="ke io"> DVC </strong>的这个特性<strong class="ke io"> </strong>非常有用，因为它省去了一次不必要的运行。</p><p id="a422" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="mn">访问 GitHub 获取完整代码:</em><a class="ae mr" href="https://github.com/Anurich/DVC" rel="noopener ugc nofollow" target="_blank">https://github.com/Anurich/DVC</a></p><h2 id="70f3" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">结论</h2><p id="c713" class="pw-post-body-paragraph kc kd in ke b kf lr jo kh ki ls jr kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">在本文中，我们看到了如何使用<strong class="ke io"> DVC/Github </strong>对数据进行版本控制，以及如何重现完整的管道。我们还讨论了用于计算嵌入和搜索前 k 个结果的语句转换器 Faiss。总的来说，这篇文章的主要内容是我们如何使用<strong class="ke io"> DVC/Github </strong>对工件进行版本控制。</p></div></div>    
</body>
</html>