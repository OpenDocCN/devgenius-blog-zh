<html>
<head>
<title>Assemble Multi Sources into Single ScrollView With Better Performance and Predefined UI Order</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将多个源组合到单个滚动视图中，具有更好的性能和预定义的用户界面顺序</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/assemble-multi-sources-into-single-scrollview-with-better-performance-and-predefined-ui-order-5202aa57a83f?source=collection_archive---------15-----------------------#2020-07-15">https://blog.devgenius.io/assemble-multi-sources-into-single-scrollview-with-better-performance-and-predefined-ui-order-5202aa57a83f?source=collection_archive---------15-----------------------#2020-07-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="d9a4" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">一页上各种模块的架构</h2></div><blockquote class="kf kg kh"><p id="f658" class="ki kj kk kl b km kn jr ko kp kq ju kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">感谢我的同事，和的帮助，重构了我们的项目并准备了分享文章。购物应用的登录页面充满了各种模块，这些模块来自不同的API。本文介绍了这种架构如何工作，以及如何提高性能和可重用性。</p></blockquote><h1 id="f497" class="lg lh iq bd li lj lk ll lm ln lo lp lq jw lr jx ls jz lt ka lu kc lv kd lw lx bi translated">介绍</h1><p id="15bc" class="pw-post-body-paragraph ki kj iq kl b km ly jr ko kp lz ju kr ma mb ku kv mc md ky kz me mf lc ld le ij bi translated">购物应用的登录页面充满了各种模块，这些模块来自不同的API。将这些回复的组件组装到一个页面中需要时间来等待所有这些API响应。也许app可能会查询第一个API，显示依赖的模块，请求下一个API并显示，一个接一个。</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi mg"><img src="../Images/034cd27cdd0b7f98f835efcaa4311b38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*e8zsepEU6rMqo_DV"/></div></div></figure><p id="9840" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ma kt ku kv mc kx ky kz me lb lc ld le ij bi translated">我们提出了一种架构，使得登陆页面最初查询所有API，当每个API响应时，直接显示相应的模块。这些模块将按照预先定义的顺序显示，例如，<em class="kk">横幅</em>总是在顶部，然后是<em class="kk">频道</em>模块，而<em class="kk">推荐</em>模块每次都在底部。</p><p id="dace" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ma kt ku kv mc kx ky kz me lb lc ld le ij bi translated">此外，使用这种架构，对这些模块进行重新排序、删除不推荐使用的模块以及添加新模块要简单得多。此外，我们可以非常方便地在其他页面中重用这些组件。</p><h1 id="c4d3" class="lg lh iq bd li lj lk ll lm ln lo lp lq jw lr jx ls jz lt ka lu kc lv kd lw lx bi translated">体系结构</h1><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi ms"><img src="../Images/c7f810df18141e206e966e804245879f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lMi1rWwu3WGkND2J"/></div></div></figure><p id="75d3" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ma kt ku kv mc kx ky kz me lb lc ld le ij bi translated">页面将根据它希望的模块将需求设置到配置中，包括它们的显示顺序。在ViewModel接收到配置之后，它生成相关的任务并并行请求数据。当任何任务完成时，它会将UI模型传递回ViewModel，ViewModel会根据配置设置对所有收到的UI模型进行排序，然后将排序后的UI模型交给DelegateAdapter。DalegateAdapter中有许多AdapterDelegates。每个AdapterDelegate将处理一种UI模型，并把它变成页面需要呈现的模块。</p><h2 id="d31c" class="mt lh iq bd li mu mv dn lm mw mx dp lq ma my mz ls mc na nb lu me nc nd lw ne bi translated">页</h2><p id="8f2a" class="pw-post-body-paragraph ki kj iq kl b km ly jr ko kp lz ju kr ma mb ku kv mc md ky kz me mf lc ld le ij bi translated">页面通常负责显示模块和处理UI事件。Page初始化Config、ViewModel和DelegationAdapter，将它需要的模块和模块的顺序注册到Config中，并将Config传递给ViewModel。然后Page通知ViewModel执行任务并从DelegationAdapter更新UI。</p><h2 id="1fff" class="mt lh iq bd li mu mv dn lm mw mx dp lq ma my mz ls mc na nb lu me nc nd lw ne bi translated">配置</h2><p id="5743" class="pw-post-body-paragraph ki kj iq kl b km ly jr ko kp lz ju kr ma mb ku kv mc md ky kz me mf lc ld le ij bi translated">Config正在记录所需的模块和显示顺序。当被传递到ViewModel时，ViewModel将根据配置文件中声明的模块创建任务来获取数据。</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi mg"><img src="../Images/72aed5e25d5335acf80a47b87653baf6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*m5GGrxz1jq-XKi39"/></div></div></figure><p id="55c0" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ma kt ku kv mc kx ky kz me lb lc ld le ij bi translated">在这个体系结构中，单独分离配置是必不可少的。通过修改配置，很容易对模块进行重新排序或重组流，而无需对页面进行大量更改或考虑API响应的返回顺序。</p><h2 id="6a8b" class="mt lh iq bd li mu mv dn lm mw mx dp lq ma my mz ls mc na nb lu me nc nd lw ne bi translated">视图模型</h2><p id="d09d" class="pw-post-body-paragraph ki kj iq kl b km ly jr ko kp lz ju kr ma mb ku kv mc md ky kz me mf lc ld le ij bi translated">ViewModel是这个架构中的数据处理中心。最初，它根据Config中所需的模块创建相应的任务。ViewModel还维护一个集合来保存当前的UI模型。当从任务接收任何UI模型时，集合将根据配置中定义的显示顺序聚合当前UI模型和新UI模型。</p><p id="9495" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ma kt ku kv mc kx ky kz me lb lc ld le ij bi translated">ViewModel从Page接收UI事件，并执行任务以并行获取UI模型。当它从任务中获取UI模型时，集合将汇总这些模型。最后，ViewModel将UI模型的有序列表传递给DelegationAdapter以更新模块。</p><h2 id="1720" class="mt lh iq bd li mu mv dn lm mw mx dp lq ma my mz ls mc na nb lu me nc nd lw ne bi translated">委派适配器</h2><p id="1938" class="pw-post-body-paragraph ki kj iq kl b km ly jr ko kp lz ju kr ma mb ku kv mc md ky kz me mf lc ld le ij bi translated">DelegationAdapter是页面和视图模型之间的桥梁。它观察来自ViewModel的UI模型流，并将相应的模块输出到页面，页面更新UI。本质上，DelegationAdapter是一个调度程序，它将UI模型转发给相应的AdapterDelegate。</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi mg"><img src="../Images/6c8054ba3106616188b458a90db28643.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4XHSnCQbZxD6GEZL"/></div></div></figure><p id="0f77" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ma kt ku kv mc kx ky kz me lb lc ld le ij bi translated">当ViewModel发出UI模型的有序列表时，DelegationAdapter会将每个UI模型分派给AdapterDelegate。该适配器委托处理UI模型类型上的铰链。之后，AdapterDelegate将处理UI模型并将其转换为模块。</p><h2 id="cdf3" class="mt lh iq bd li mu mv dn lm mw mx dp lq ma my mz ls mc na nb lu me nc nd lw ne bi translated">AdapterDelegate</h2><p id="c0d3" class="pw-post-body-paragraph ki kj iq kl b km ly jr ko kp lz ju kr ma mb ku kv mc md ky kz me mf lc ld le ij bi translated">佩奇需要的模块有很多种。为了避免单个处理程序过于复杂，我们将复杂性分成不同的AdapterDelegates。一个AdapterDelegate只负责一种类型的模块。它接收UI模型，膨胀模块布局，并绑定UI模型来处理模块的UI表示。</p><p id="dccc" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ma kt ku kv mc kx ky kz me lb lc ld le ij bi translated">通过解耦的好处，应用程序不仅可以在登录页面上使用每个AdapterDelegate，还可以在其他页面上使用。它通过可重用的AdapterDelegates避免了样板代码，并确保相同的模块在不同的页面上具有相同的外观。</p><h2 id="f519" class="mt lh iq bd li mu mv dn lm mw mx dp lq ma my mz ls mc na nb lu me nc nd lw ne bi translated">工作</h2><p id="9d3e" class="pw-post-body-paragraph ki kj iq kl b km ly jr ko kp lz ju kr ma mb ku kv mc md ky kz me mf lc ld le ij bi translated">Task执行异步操作从存储库中获取数据，并在后台线程中将其转换为相应的UI模型。然后将UI模型转移到ViewModel中。这些任务应该是独立且不相关的。如果多个任务使用相同的数据，或者任务需要另一个任务的数据，应用程序应该通过以下建议来优化这些任务:</p><p id="52e3" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ma kt ku kv mc kx ky kz me lb lc ld le ij bi translated">1.)将那些任务转换成单个任务，查询所有必要的数据，共同转换成多个UI模型。</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi mg"><img src="../Images/747f1aed733fc79bb9d1419d477ebdd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Uygo3m40cfesVG1c"/></div></div></figure><p id="aea4" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ma kt ku kv mc kx ky kz me lb lc ld le ij bi translated">2.)储存库层(或网络层，例如OKHTTP或AFNetworking)将缓存复制的数据，以便在查询相同的数据时没有额外的网络连接。</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi mg"><img src="../Images/99ec35b317443772150cfab0d89a3675.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0He5Zap8K7aiETDT"/></div></div></figure><h2 id="62a0" class="mt lh iq bd li mu mv dn lm mw mx dp lq ma my mz ls mc na nb lu me nc nd lw ne bi translated">用户界面模型</h2><p id="696a" class="pw-post-body-paragraph ki kj iq kl b km ly jr ko kp lz ju kr ma mb ku kv mc md ky kz me mf lc ld le ij bi translated">每种UI模型对应于页面上的一种模块类型。UI模型保留了AdapterDelegate创建或更新模块所需的所有信息和字段。UI模型来自Task，通过DelegationAdapter到达AdapterDelegate。</p><p id="bb84" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ma kt ku kv mc kx ky kz me lb lc ld le ij bi translated">使用UI模型代替API数据模型还有另一个好处，即可重用性。例如，一个模块存在于多个页面上，但是该模块需要的数据来自每个页面上的不同来源。通过将不同的API数据转换为同一个UI模型，我们可以重用AdapterDelegate，并在需要调整模块的UI时最小化需要修改的代码量。</p><h1 id="85fc" class="lg lh iq bd li lj lk ll lm ln lo lp lq jw lr jx ls jz lt ka lu kc lv kd lw lx bi translated">优势</h1><h2 id="1d87" class="mt lh iq bd li mu mv dn lm mw mx dp lq ma my mz ls mc na nb lu me nc nd lw ne bi translated">轻松的A/B测试和动态调整</h2><p id="8558" class="pw-post-body-paragraph ki kj iq kl b km ly jr ko kp lz ju kr ma mb ku kv mc md ky kz me mf lc ld le ij bi translated">如果我们想要对不同顺序的模块进行A/B测试，我们只需要根据存储桶创建两个单独的配置对象。那么流将在不同的桶中不同地呈现。</p><p id="2f67" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ma kt ku kv mc kx ky kz me lb lc ld le ij bi translated">由于我们分离了显示顺序和API响应序列，我们可以轻松地将显示逻辑从应用程序提取到远程配置，以便PM可以根据业务需求动态地更改模块的顺序。这将给予项目经理和销售人员更大的灵活性来制定商业策略，并在与供应商谈判时拥有更大的权力。</p><h2 id="9f2e" class="mt lh iq bd li mu mv dn lm mw mx dp lq ma my mz ls mc na nb lu me nc nd lw ne bi translated">更好的性能</h2><p id="8e42" class="pw-post-body-paragraph ki kj iq kl b km ly jr ko kp lz ju kr ma mb ku kv mc md ky kz me mf lc ld le ij bi translated">在这种架构中，我们可以并行调用多个API，从而显著减少呈现整个流的等待时间。登陆页的冷启动时间在改善，给用户带来了更好的体验。</p><h2 id="a2bf" class="mt lh iq bd li mu mv dn lm mw mx dp lq ma my mz ls mc na nb lu me nc nd lw ne bi translated">可重用性改进</h2><p id="6125" class="pw-post-body-paragraph ki kj iq kl b km ly jr ko kp lz ju kr ma mb ku kv mc md ky kz me mf lc ld le ij bi translated">此外，AdapterDelegates可以在我们想要显示同一个模块的任何地方重用。有了它的好处，我们不需要维护重复的代码，可以通过模块封装UI显示逻辑。</p><h1 id="b472" class="lg lh iq bd li lj lk ll lm ln lo lp lq jw lr jx ls jz lt ka lu kc lv kd lw lx bi translated">成就</h1><p id="d504" class="pw-post-body-paragraph ki kj iq kl b km ly jr ko kp lz ju kr ma mb ku kv mc md ky kz me mf lc ld le ij bi translated">主登陆页面显示所有模块，包括<em class="kk">横幅</em>、<em class="kk">频道</em>、<em class="kk">公告</em>、<em class="kk">目标</em>等。其他子登陆页面丢弃<em class="kk">宣布</em>、<em class="kk">目标</em>，以及部分模块。在我们的架构中，我们可以注销子登陆页面不需要的模块。</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi nf"><img src="../Images/f0a5ab0d2e76ae21c571a07cb6903453.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WpQq8aKfou1HBRZr"/></div></div></figure><p id="ce9e" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr ma kt ku kv mc kx ky kz me lb lc ld le ij bi translated">再比如，购物app在两个不同的页面显示<em class="kk">推荐</em>模块，我们可以使用同一个AdapterDelegate，只需要在两个页面的配置中注册这个模块。然后，推荐模块将出现在这些页面上。</p><h1 id="0adb" class="lg lh iq bd li lj lk ll lm ln lo lp lq jw lr jx ls jz lt ka lu kc lv kd lw lx bi translated">参考</h1><p id="1866" class="pw-post-body-paragraph ki kj iq kl b km ly jr ko kp lz ju kr ma mb ku kv mc md ky kz me mf lc ld le ij bi translated">[1]委托适配器<br/>T15】https://github.com/sockeqwe/AdapterDelegates</p></div></div>    
</body>
</html>