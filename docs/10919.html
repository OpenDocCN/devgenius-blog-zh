<html>
<head>
<title>You Don’t Know How to Tune JVM</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你不知道如何调优 JVM</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/you-dont-know-how-to-tune-jvm-75cb99b5649?source=collection_archive---------2-----------------------#2022-12-07">https://blog.devgenius.io/you-dont-know-how-to-tune-jvm-75cb99b5649?source=collection_archive---------2-----------------------#2022-12-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="b7c5" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">软件工程之旅</h2><div class=""/><div class=""><h2 id="a62d" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">为了学习如何调优 JVM 以获得更好的性能，软件工程师必须了解这些调优技术。</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ko"><img src="../Images/fb8b8b3a3ce5287ae0dc32e574617492.png" data-original-src="https://miro.medium.com/v2/resize:fit:572/0*U96wCLMJYshUHgBT"/></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">图片来自 hcltech.com</figcaption></figure><h1 id="7aa4" class="la lb iq bd lc ld le lf lg lh li lj lk kf ll kg lm ki ln kj lo kl lp km lq lr bi translated">概观</h1><p id="bf65" class="pw-post-body-paragraph ls lt iq lu b lv lw ka lx ly lz kd ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">JVM 调优和 Java 性能优化是应用程序生命周期中的重要活动。它们最大限度地提高应用程序性能，并增加本地硬件或云计算资源的吞吐量</p><p id="2e3c" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">Java 虚拟机调优是调整默认参数以匹配我们的应用程序需求的过程。这包括简单的调整，如堆的大小，通过选择正确的垃圾收集器来使用优化版本的 getters。</p><h1 id="71c8" class="la lb iq bd lc ld le lf lg lh li lj lk kf ll kg lm ki ln kj lo kl lp km lq lr bi translated">JVM 调优前需要了解的因素</h1><p id="ece5" class="pw-post-body-paragraph ls lt iq lu b lv lw ka lx ly lz kd ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">在深入 JVM 调优过程之前，让我们先熟悉一些与 JVM 调优相关的关键概念。</p><h1 id="f723" class="la lb iq bd lc ld le lf lg lh li lj lk kf ll kg lm ki ln kj lo kl lp km lq lr bi translated">JVM 主要参数</h1><p id="59c4" class="pw-post-body-paragraph ls lt iq lu b lv lw ka lx ly lz kd ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">JVM 参数或 JVM 自变量是改变 Java 虚拟机行为的特定于 Java 的值。</p><p id="b209" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">谈到 JVM 调优，有几个重要参数您应该知道，因为在配置、调优和提高 JVM 的整体性能时，您会遇到这些参数。</p><h1 id="7ccc" class="la lb iq bd lc ld le lf lg lh li lj lk kf ll kg lm ki ln kj lo kl lp km lq lr bi translated">堆内存</h1><p id="235d" class="pw-post-body-paragraph ls lt iq lu b lv lw ka lx ly lz kd ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">无论您做什么，当谈到 JVM 性能时，您很可能会达到必须初始化堆内存的程度。</p><p id="c325" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">当设置 JVM 内存的最小和最大堆大小时，您可能想考虑将它们设置为相同的值。这样，您的堆就不必调整大小，节省了宝贵的 CPU 周期。</p><h1 id="d975" class="la lb iq bd lc ld le lf lg lh li lj lk kf ll kg lm ki ln kj lo kl lp km lq lr bi translated">碎片帐集</h1><p id="22b8" class="pw-post-body-paragraph ls lt iq lu b lv lw ka lx ly lz kd ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">垃圾收集是 JVM 释放 Java 堆中未使用的 Java 对象的过程。Java 堆是 Java 程序的对象所在的地方。它是活对象、死对象和空闲内存的存储库。当一个对象不再能从正在运行的程序中的任何指针到达时，它被认为是“垃圾”并准备好被收集。</p><p id="57c1" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">JVM 有四种垃圾收集器实现:</p><ul class=""><li id="e698" class="mt mu iq lu b lv mo ly mp mb mv mf mw mj mx mn my mz na nb bi translated">串行垃圾收集器</li><li id="1b31" class="mt mu iq lu b lv nc ly nd mb ne mf nf mj ng mn my mz na nb bi translated">并行垃圾收集器</li><li id="0f84" class="mt mu iq lu b lv nc ly nd mb ne mf nf mj ng mn my mz na nb bi translated">CMS 垃圾收集器</li><li id="9997" class="mt mu iq lu b lv nc ly nd mb ne mf nf mj ng mn my mz na nb bi translated">G1 垃圾收集器</li></ul><p id="4310" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">前两个垃圾收集器专用于年轻一代堆空间，而 CMS 和 G1 垃圾收集器专用于老一代堆空间。</p><h1 id="4ce7" class="la lb iq bd lc ld le lf lg lh li lj lk kf ll kg lm ki ln kj lo kl lp km lq lr bi translated">GC 日志记录</h1><p id="496c" class="pw-post-body-paragraph ls lt iq lu b lv lw ka lx ly lz kd ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">垃圾收集性能与 JVM 和 app 性能密切相关。当垃圾收集器无法清除内存时，它会越来越多地工作，最终导致全局事件，甚至出现内存不足的情况。我们希望尽可能避免这种情况。为了做到这一点，我们需要能够观察 JVM 垃圾收集器正在做什么。监控 GC 性能的最好方法之一是查看 GC 日志。</p><p id="d907" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">您可以使用以下命令记录 GC 活动:</p><pre class="kp kq kr ks gt nh ni nj bn nk nl bi"><span id="7971" class="nm lb iq ni b be nn no l np nq">-XX:+UseGCLogFileRotation<br/>-XX:NumberOfGCLogFiles=&lt;number of log files&gt;<br/>-XX:GCLogFileSize=&lt;file size&gt;[unit]<br/>-Xloggc:/path/to/gc.log</span></pre><h1 id="d787" class="la lb iq bd lc ld le lf lg lh li lj lk kf ll kg lm ki ln kj lo kl lp km lq lr bi translated">如何进行 JVM 性能调优</h1><p id="f7cc" class="pw-post-body-paragraph ls lt iq lu b lv lw ka lx ly lz kd ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">一旦您了解了上述所有内容，下面是执行 JVM 调优需要采取的步骤:</p><h2 id="71f7" class="nr lb iq bd lc ns nt dn lg nu nv dp lk mb nw nx lm mf ny nz lo mj oa ob lq iw bi translated">测量内存占用</h2><p id="06a8" class="pw-post-body-paragraph ls lt iq lu b lv lw ka lx ly lz kd ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">要确定内存使用情况，首先需要知道活动数据的大小。活动数据的大小是自应用程序进入稳定阶段以来被活动数据占用的 Java 堆的数量。</p><h2 id="247f" class="nr lb iq bd lc ns nt dn lg nu nv dp lk mb nw nx lm mf ny nz lo mj oa ob lq iw bi translated">应用阶段:稳定与启动</h2><p id="2526" class="pw-post-body-paragraph ls lt iq lu b lv lw ka lx ly lz kd ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">活动数据必须在稳定状态下测量，而不是在启动阶段。在启动阶段，JVM 加载并启动 app 的主要模块和数据；因此，JVM 参数还不稳定。</p><p id="1c09" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">另一方面，稳定阶段意味着一个应用程序已经运行了一段时间，并进行了压力测试。更具体地说，当应用程序在生产环境中达到满足业务峰值要求的工作负载，并在达到峰值后保持稳定时，它就处于稳定阶段。只有这样，每个 JVM 性能参数才处于稳定状态。</p><h2 id="6ea6" class="nr lb iq bd lc ns nt dn lg nu nv dp lk mb nw nx lm mf ny nz lo mj oa ob lq iw bi translated">如何确定内存占用</h2><p id="4c7b" class="pw-post-body-paragraph ls lt iq lu b lv lw ka lx ly lz kd ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">请确保使用默认的 JVM 参数执行测试，因为它允许您查看应用程序在稳定阶段需要多少内存。完整的 GC</p><p id="356e" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">一旦应用程序在稳定状态下运行，您必须根据平均旧的和永久的占用率来估计内存占用，您可以在稳定状态期间看到完整的 GC 日志。您还可以使用最长的完整 GC 进行估计。</p><p id="e2bd" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">GC 日志是收集有意义的丰富数据来帮助调优的最佳方式之一。启用 GC 日志不会影响性能。因此，您甚至可以在生产环境中使用它们来检测问题。</p><p id="6533" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">使用以下命令行打开完整的 GC 日志:</p><pre class="kp kq kr ks gt nh ni nj bn nk nl bi"><span id="8b0a" class="nm lb iq ni b be nn no l np nq">-XX:+PrintGC -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -Xloggc:&lt;filename&gt;</span></pre><p id="d265" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">但是，如果没有完整的 GC 日志可用，您可以使用监视工具来调用它们，或者使用以下命令来启用它们:</p><pre class="kp kq kr ks gt nh ni nj bn nk nl bi"><span id="dfb8" class="nm lb iq ni b be nn no l np nq">jmap -histo:live pid</span></pre><p id="48f8" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">无论哪种方式，您都会获得类似于以下内容的信息:</p><pre class="kp kq kr ks gt nh ni nj bn nk nl bi"><span id="e256" class="nm lb iq ni b be nn no l np nq">0.134: [GC (Allocation Failure) [PSYoungGen: 65536K-&gt;10720K(76288K)] 65536K-&gt;40488K(251392K), 0.0190287 secs] [Times: user=0.13 sys=0.04, real=0.02 secs]<br/>0.193: [GC (Allocation Failure) [PSYoungGen: 71912K-&gt;10752K(141824K)] 101680K-&gt;101012K(316928K), 0.0357512 secs] [Times: user=0.27 sys=0.06, real=0.04 secs]<br/>0.374: [GC (Allocation Failure) [PSYoungGen: 141824K-&gt;10752K(141824K)] 232084K-&gt;224396K(359424K), 0.0809666 secs] [Times: user=0.58 sys=0.12, real=0.08 secs]<br/>0.455: [Full GC (Ergonomics) [PSYoungGen: 10752K-&gt;0K(141824K)] [ParOldGen: 213644K-&gt;215361K(459264K)] 224396K-&gt;215361K(601088K), [Metaspace: 2649 K-&gt;2649K(1056768K)], 0.4409247 secs] [Times: user=3.46 sys=0.02, real=0.44 secs]<br/>0.984: [GC (Allocation Failure) [PSYoungGen: 131072K-&gt;10752K(190464K)] 346433K-&gt;321225K(649728K), 0.1407158 secs] [Times: user=1.28 sys=0.08, real=0.14 secs]<br/>1.168: [GC (System.gc()) [PSYoungGen: 60423K-&gt;10752K(190464K)] 370896K-&gt;368961K(649728K), 0.0676498 secs] [Times: user=0.53 sys=0.05, real=0.06 secs]<br/>1.235: [Full GC (System.gc()) [PSYoungGen: 10752K-&gt;0K(190464K)] [ParOldGen: 358209K-&gt;368152K(459264K)] 368961K-&gt;368152K(649728K), [Metaspace: 2652K-&gt;2652K(1056768K)], 1.1751101 secs] [Times: user=10.64 sys=0.05, real=1.18 secs]<br/>2.612: [Full GC (Ergonomics) [PSYoungGen: 179712K-&gt;0K(190464K)] [ParOldGen: 368152K-&gt;166769K(477184K)] 547864K-&gt;166769K(667648K), [Metaspace: 2659K-&gt;2659K(1056768K)], 0.2662589 secs] [Times: user=2.14 sys=0.00, real=0.27 secs]</span></pre><p id="ab16" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">我们可以看到 JVM 版本 8 执行的几个操作。让我们看一下这里的一行，它描述了通过使用 System.gc()方法从我们的测试代码中有意执行的完整 GC 事件:</p><pre class="kp kq kr ks gt nh ni nj bn nk nl bi"><span id="17ea" class="nm lb iq ni b be nn no l np nq">1.235: [Full GC (System.gc()) [PSYoungGen: 10752K-&gt;0K(190464K)] [ParOldGen: 358209K-&gt;368152K(459264K)] 368961K-&gt;368152K(649728K), [Metaspace: 2652K-&gt;2652K(1056768K)], 1.1751101 secs] [Times: user=10.64 sys=0.05, real=1.18 secs]</span></pre><p id="5e71" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">如您所见，在描述完整 GC 事件的一行中包含了大量信息。除了事件类型之外，我们还可以看到年轻代空间中发生了什么[PSYoungGen:10752k-&gt; 0K(190464k)]，老代空间中发生了什么，[ParOldGen:358209k-&gt; 368152k(459264k)]，内存的元空间区域中发生了什么[元空间:2652K-&gt;2652K(1056768K)]，总内存差 368961K-&gt;36815</p><p id="304c" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">关于年轻代垃圾收集器工作的信息告诉我们，在年轻代垃圾收集事件之后，空间从 10752K 下降到 0K，总分配的年轻代空间是 190464K。</p><p id="6304" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">老一代垃圾收集器开始时使用 358209K 的内存，工作结束后使用 368152K。分配给老一代空间的总内存是 459264K。这意味着这个 GC 周期没有释放太多的老一代空间。</p><p id="ef40" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">在整个垃圾收集完成后，我们从最初的 368961K 内存开始使用 368152K 内存，整个内存空间占用了 649728K。</p><p id="bd3f" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">内存的元空间区域以相同的内存使用量 2652K 开始和结束，整个区域占用 1056768K。</p><p id="098c" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">最后，JVM 用了 1.18 秒来执行整个垃圾收集操作。user=10.64 部分告诉我们在操作系统内核之外的用户模式代码中花费的 CPU 时间。sys=0.05 部分是 CPU 在进程本身的内核中花费的时间，这意味着 CPU 执行系统相关调用所花费的时间。</p><p id="067a" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">正如您所看到的，单个垃圾收集器日志行可以让我们深入了解发生了什么，释放了多少内存，以及整个操作花费了多长时间。</p><h2 id="4319" class="nr lb iq bd lc ns nt dn lg nu nv dp lk mb nw nx lm mf ny nz lo mj oa ob lq iw bi translated">延迟调整</h2><p id="47d5" class="pw-post-body-paragraph ls lt iq lu b lv lw ka lx ly lz kd ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">一旦确定了内存占用，下一步就是延迟调整。在这个阶段，堆内存大小和延迟不能满足应用程序的要求。因此，需要根据 app 的实际需求进行新的调试。您可能需要再次调整堆大小，确定 GC 持续时间和频率，并决定是否需要切换到另一个垃圾收集器。</p><h2 id="86e5" class="nr lb iq bd lc ns nt dn lg nu nv dp lk mb nw nx lm mf ny nz lo mj oa ob lq iw bi translated">确定系统延迟要求</h2><p id="2b24" class="pw-post-body-paragraph ls lt iq lu b lv lw ka lx ly lz kd ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">之前，我们提到过绩效目标，但是我们没有为它们设定值。这些目标是您在调优后需要满足的系统延迟要求。有助于实现这一目标的指标有:</p><ul class=""><li id="e6f4" class="mt mu iq lu b lv mo ly mp mb mv mf mw mj mx mn my mz na nb bi translated">可接受的平均次要 GC 频率，您将把它与次要 GC 的数量进行比较。</li><li id="68ef" class="mt mu iq lu b lv nc ly nd mb ne mf nf mj ng mn my mz na nb bi translated">可接受的最大完整 GC 暂停，您可以将它与最长的完整 GC 周期进行比较。</li><li id="3fe0" class="mt mu iq lu b lv nc ly nd mb ne mf nf mj ng mn my mz na nb bi translated">可接受的最大完全 GC 暂停频率，您将把它与完全 GC 的最高频率进行比较。</li><li id="7bd5" class="mt mu iq lu b lv nc ly nd mb ne mf nf mj ng mn my mz na nb bi translated">可接受的平均次要 GC 暂停时间，您可以将它与次要 GC 持续时间进行比较。</li></ul><p id="11f1" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">您可以通过分别优化年轻一代和老一代的规模来获得这些数据。您可以在我们的垃圾收集调优指南中了解更多信息。</p><h2 id="dbfe" class="nr lb iq bd lc ns nt dn lg nu nv dp lk mb nw nx lm mf ny nz lo mj oa ob lq iw bi translated">吞吐量调整</h2><p id="bf9f" class="pw-post-body-paragraph ls lt iq lu b lv lw ka lx ly lz kd ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">在 JVM 性能调优的最后一步，我们对目前得到的结果进行吞吐量测试，然后根据需要进行细微的调整。</p><p id="f3ed" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">基于测试和整体应用需求，一个应用应该有一个设定的吞吐量指标。当达到或超过这个目标时，您可以停止优化。</p><p id="65dc" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">但是，如果在优化之后，您仍然不能达到吞吐量目标，那么您需要重新评估吞吐量需求和当前吞吐量之间的差距。如果差距在 20%左右，您可以更改参数、增加内存并再次调试应用程序。但是如果差距大于 20%，就需要把吞吐量目标作为吞吐量目标来审核，设计可能不符合整个 Java 应用的要求。</p><p id="871c" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">对于垃圾收集，吞吐量调优有两个目的:最小化传递到旧区域的对象数量，减少整个 GC 执行时间或停止世界事件。这些会导致低吞吐量。</p><h1 id="f8f1" class="la lb iq bd lc ld le lf lg lh li lj lk kf ll kg lm ki ln kj lo kl lp km lq lr bi translated">增强 Java Web 应用程序性能的配置</h1><ul class=""><li id="a85f" class="mt mu iq lu b lv lw ly lz mb oc mf od mj oe mn my mz na nb bi translated">转移到最新稳定的 Java 版本。</li><li id="fc99" class="mt mu iq lu b lv nc ly nd mb ne mf nf mj ng mn my mz na nb bi translated">正确确定 Java 堆内存的大小。</li><li id="56c8" class="mt mu iq lu b lv nc ly nd mb ne mf nf mj ng mn my mz na nb bi translated">设置初始 Java 堆大小。</li><li id="e052" class="mt mu iq lu b lv nc ly nd mb ne mf nf mj ng mn my mz na nb bi translated">选择正确的垃圾收集算法。</li><li id="c3cb" class="mt mu iq lu b lv nc ly nd mb ne mf nf mj ng mn my mz na nb bi translated">调整垃圾收集器。</li><li id="2deb" class="mt mu iq lu b lv nc ly nd mb ne mf nf mj ng mn my mz na nb bi translated">确保 Web 容器的线程池大小正确。</li></ul><h1 id="e833" class="la lb iq bd lc ld le lf lg lh li lj lk kf ll kg lm ki ln kj lo kl lp km lq lr bi translated">该调音了！</h1><p id="c912" class="pw-post-body-paragraph ls lt iq lu b lv lw ka lx ly lz kd ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">JVM 性能调优是一个复杂的过程，需要系统的方法和对期望的性能结果的清晰想法，正如您在本 JVM 调优指南中注意到的。默认的 JVM 调优在提高应用程序性能方面做得很好，并确保它在大多数情况下都是稳定的。另一方面，根据您的应用程序如何处理所需的工作负载，基本的初始 JVM 参数可能不够。在这种情况下，您必须对您的应用程序进行基准测试，并调整 JVM 以达到一组合适的参数。</p><h1 id="6c8b" class="la lb iq bd lc ld le lf lg lh li lj lk kf ll kg lm ki ln kj lo kl lp km lq lr bi translated">结论</h1><p id="ca6d" class="pw-post-body-paragraph ls lt iq lu b lv lw ka lx ly lz kd ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">通过这篇文章，我认为您可以了解如何调优 JVM 以获得更好的性能。最后，我想感谢你阅读我的文章。</p></div></div>    
</body>
</html>