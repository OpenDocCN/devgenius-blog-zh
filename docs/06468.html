<html>
<head>
<title>JavaScript arrow functions vs regular functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript 箭头函数与常规函数</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/arrow-functions-vs-regular-functions-bad0e41b48c4?source=collection_archive---------10-----------------------#2022-01-10">https://blog.devgenius.io/arrow-functions-vs-regular-functions-bad0e41b48c4?source=collection_archive---------10-----------------------#2022-01-10</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="fd1a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ki">本文将深入探讨 ES6 箭头函数和常规函数的区别</em></p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi kj"><img src="../Images/3b81ce0d45ca860be14d0bce18220894.png" data-original-src="https://miro.medium.com/v2/resize:fit:1054/format:webp/1*eM7CGvuiV1PWxLg84f9ilA.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">箭头函数语法</figcaption></figure><p id="4aa8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">ES6(也称为 ES2015)为 JavaScript 开发人员带来了使用箭头功能的能力。</p><p id="7bb8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以，不要像这样写函数表达式</p><pre class="kk kl km kn gt kv kw kx ky aw kz bi"><span id="4a12" class="la lb in kw b gy lc ld l le lf">const sayHi = function(name) {<br/>   return `Hi ${name}`;<br/>}</span></pre><p id="bf98" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们可以只写</p><pre class="kk kl km kn gt kv kw kx ky aw kz bi"><span id="9abd" class="la lb in kw b gy lc ld l le lf">const sayHi = (name) =&gt; {<br/>    return `Hi ${name}`;<br/>}</span></pre><p id="e4e3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，正如我们在上面看到的，箭头函数为我们提供了一个更短的语法来编写函数，这是一个很大的好处。我们甚至可以简化上面的箭头函数语法，去掉 name 参数周围的括号，因为我们只使用了一个参数(如果我们使用了多个参数，我们必须保留它们)</p><pre class="kk kl km kn gt kv kw kx ky aw kz bi"><span id="36bb" class="la lb in kw b gy lc ld l le lf">const sayHi = name =&gt; { <br/>   return `Hi ${name}`;<br/>}</span></pre><p id="6f30" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">箭头函数的另一个好处是，如果它包含一个表达式，我们可以省略函数的花括号，然后表达式被隐式返回，而不需要使用<strong class="jm io"> return </strong>关键字(这种函数实际上被称为内联箭头函数)</p><pre class="kk kl km kn gt kv kw kx ky aw kz bi"><span id="c9a2" class="la lb in kw b gy lc ld l le lf">const sayHi = name =&gt; `Hi ${name}`;</span></pre><p id="a0fd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在一个常规的 JavaScript 函数中，<code class="fe lg lh li kw b">this</code>值可以是动态的，并且取决于调用函数的方式。有 4 种不同类型的调用类型:</p><p id="ca1e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">1.regular——<code class="fe lg lh li kw b">this</code>值是全局对象(或者如果打开了严格模式，则是未定义的)</p><pre class="kk kl km kn gt kv kw kx ky aw kz bi"><span id="b83d" class="la lb in kw b gy lc ld l le lf">function sayHi() {<br/>   console.log(this); // this is the global object<br/>}<br/>sayHi();</span></pre><p id="1b6b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">2.函数-<strong class="jm io"/><code class="fe lg lh li kw b">this</code>值是包含该方法的对象。</p><pre class="kk kl km kn gt kv kw kx ky aw kz bi"><span id="16aa" class="la lb in kw b gy lc ld l le lf">const wrapper = {<br/>  sayHi() {<br/>    console.log(this); // this is the wrapper object<br/>  }<br/>};<br/>wrapper.sayHi()</span></pre><p id="4691" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">3.间接——<strong class="jm io"/><code class="fe lg lh li kw b">this</code>值是包含该方法的对象(以<code class="fe lg lh li kw b">call </code>或<code class="fe lg lh li kw b">apply</code>为例)</p><pre class="kk kl km kn gt kv kw kx ky aw kz bi"><span id="ebc5" class="la lb in kw b gy lc ld l le lf">const person = { age: 24, name: 'john' };<br/>function sayHi() {<br/>  console.log(this); // this is the person object<br/>}<br/>sayHi.call(person);</span></pre><p id="8c41" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">4.构造函数——<code class="fe lg lh li kw b">this</code>值是通过<code class="fe lg lh li kw b">new</code>关键字创建的实例。</p><pre class="kk kl km kn gt kv kw kx ky aw kz bi"><span id="0ede" class="la lb in kw b gy lc ld l le lf">function sayHi() {<br/>  console.log(this); // this is the instance of sayHi<br/>}<br/>new sayHi();</span></pre><p id="cd62" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">另一方面，arrow 函数不定义自己的执行上下文。这意味着它在哪里执行并不重要，arrow 函数中的<code class="fe lg lh li kw b">this</code>值总是等于外部函数中的相同值。这也意味着，与常规函数相反，使用<code class="fe lg lh li kw b">call</code>或<code class="fe lg lh li kw b">apply</code>对箭头函数的间接调用不起作用。</p><pre class="kk kl km kn gt kv kw kx ky aw kz bi"><span id="03e0" class="la lb in kw b gy lc ld l le lf">function sayHi(){<br/> console.log(this.age);<br/>}</span><span id="a58c" class="la lb in kw b gy lj ld l le lf">sayHi(); // logs undefined, this is the global object</span><span id="43e2" class="la lb in kw b gy lj ld l le lf">const person = { age : 34 };<br/>sayHi.call(person); // logs 34, call allows binding the this value</span><span id="4c7b" class="la lb in kw b gy lj ld l le lf">const sayHi2 = () =&gt; console.log(this.age); </span><span id="b928" class="la lb in kw b gy lj ld l le lf">sayHi2.call(person); // logs undefined, call/apply doesn't work!</span></pre><p id="58ff" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，常规函数中的<code class="fe lg lh li kw b">this</code>值是动态的，就像我们上面看到的一样，它的值取决于调用的类型，而箭头函数中的<code class="fe lg lh li kw b">this</code>值将总是相同的，并且将等于外部函数，因为它是词汇绑定的。</p><pre class="kk kl km kn gt kv kw kx ky aw kz bi"><span id="5970" class="la lb in kw b gy lc ld l le lf">let person = { <br/>  arrowHi:() =&gt; { <br/>    console.log(this); <br/>  },<br/>  regularHi(){ <br/>    console.log(this); <br/>  } <br/>};</span><span id="1d18" class="la lb in kw b gy lj ld l le lf">person.arrowHi(); // logs the global object<br/>person.regularHi(); // logs person object</span></pre><p id="e871" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因为<code class="fe lg lh li kw b">this</code>在 arrow 函数中进行了词法解析，所以我们实际上不能将它用作构造函数。</p><pre class="kk kl km kn gt kv kw kx ky aw kz bi"><span id="339c" class="la lb in kw b gy lc ld l le lf">function Car(brand) {<br/> this.brand = brand;<br/>}</span><span id="484d" class="la lb in kw b gy lj ld l le lf">const reno = new Car(‘Reno’);<br/>console.log(reno instanceof Car); // true</span><span id="a749" class="la lb in kw b gy lj ld l le lf">const Car2 = (brand) =&gt; {<br/> this.brand = brand;<br/>};</span><span id="0aa3" class="la lb in kw b gy lj ld l le lf">const reno2 = new Car2(‘Reno’); // error — Uncaught TypeError: Car2 is not a constructor</span></pre><p id="f8e2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">常规函数和箭头函数的另一个区别是方法在类中的工作方式。在简单的情况下，它们的工作是一样的，但是如果我们需要提供一个方法作为异步事件的回调，比如<code class="fe lg lh li kw b">setTimeout</code>或者网络请求，事情就不那么简单了..</p><pre class="kk kl km kn gt kv kw kx ky aw kz bi"><span id="9d16" class="la lb in kw b gy lc ld l le lf">class Person {<br/>  constructor(age) {<br/>    this.age = age;<br/>  }<br/>  sayAge() {<br/>    console.log(“this person age is “ + this.age);<br/>  }<br/>  sayAge2 = () =&gt; console.log(“this person age is “ + this.age);<br/>}</span><span id="1bd4" class="la lb in kw b gy lj ld l le lf">const person = new Person(34);<br/>person.sayAge(); // "this person age is 34"<br/>person.sayAge2(); // "this person age is 34"</span><span id="9a21" class="la lb in kw b gy lj ld l le lf">setTimeout(person.sayAge, 1000); // "this person age is undefined"</span><span id="932c" class="la lb in kw b gy lj ld l le lf">// we can actually fix that with bind, but this is an extra overhead</span><span id="8fac" class="la lb in kw b gy lj ld l le lf">setTimeout(person.sayAge.bind(person), 1000);// "this person age is 34"</span></pre><p id="aacd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">与常规函数相比，arrow 函数将<code class="fe lg lh li kw b">this</code>在词汇上绑定到类实例，这实际上可以帮助我们解决上面看到的问题。</p><pre class="kk kl km kn gt kv kw kx ky aw kz bi"><span id="a6f4" class="la lb in kw b gy lc ld l le lf">class Person2 {<br/>  constructor(age) {<br/>    this.age = age;<br/>  }<br/>  sayAge = () =&gt; {<br/>    console.log("this person age is " + this.age);<br/>  }<br/>}</span><span id="2ff7" class="la lb in kw b gy lj ld l le lf">const person2 = new Person2(34);<br/>person2.sayAge(); // "this person age is 34"<br/>setTimeout(person2.sayAge, 1000); // "this person age is 34"</span></pre><p id="958f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我希望这篇文章能帮助你理解箭头函数和常规函数的区别，以及在哪里明智地使用它们。如果你觉得这篇文章有帮助，我会很感激下面的一些掌声(:</p><p id="08c5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您也可以关注我以获得更多类似的文章(:</p></div></div>    
</body>
</html>