<html>
<head>
<title>What the heck is Container Queries?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">容器查询到底是什么？</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/what-the-heck-is-container-queries-30fcf66f6d6a?source=collection_archive---------12-----------------------#2022-12-24">https://blog.devgenius.io/what-the-heck-is-container-queries-30fcf66f6d6a?source=collection_archive---------12-----------------------#2022-12-24</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/3a325548199ed1e9a4471a641eef7caa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VIbTmqN6CAZHcNfgFbNjZg.jpeg"/></div></div></figure><div class=""/><p id="347c" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">随着时间的推移，CSS 在许多方面都发生了变化。想想看，在浮动的帮助下管理内容，然后在媒体查询的帮助下以堆叠的方式显示内容，在媒体查询中，必须编写大量的 css 来管理整个页面元素，这在内容丰富时变得很麻烦。</p><p id="e42b" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">根据视窗大小管理媒体查询，元素必须放在屏幕上。尽管如此，许多网站仍然根据其布局的视口大小(宽度/高度)来管理元素。</p><p id="e289" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，考虑这样一种情况，在这种情况下，你不必完全依赖于视窗大小，而是可以信任你所在的父元素。把立场风格想成“相对”类比。T3】</p><p id="ae93" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这就是容器查询所做的。</p><p id="f384" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">根据 MDN 定义，CSS 容器查询…</p><blockquote class="ku kv kw"><p id="d2f8" class="jv jw kt jx b jy jz ka kb kc kd ke kf kx kh ki kj ky kl km kn kz kp kq kr ks ig bi translated"><strong class="jx iz"> CSS 包容提供了一种方法来隔离页面的各个部分，并向浏览器声明这些部分在样式和布局方面独立于页面的其余部分。</strong></p></blockquote><p id="3468" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">问:什么是 CSS 遏制？</p><p id="b393" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">CSS 包含通过将页面的子树(子部分)与页面的其余部分隔离开来，来提高页面性能。这样做，如果浏览器明白页面的一部分是独立的，就可以更好的优化。</p><p id="8bbb" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">它还指示元素是否应该显示所有内容，以及是否在屏幕外也显示内容。</p><p id="115f" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在让我们把注意力集中在容器查询上。</p><p id="17a1" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你正在做一个响应式设计，我们经常使用<strong class="jx iz">媒体查询</strong>来改变基于<strong class="jx iz">视窗</strong>的页面布局。我们将常见的 HTML 元素分组为可重用的组件，这些组件根据页面中的可用空间具有特定的布局。</p><p id="db0e" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当涉及到<strong class="jx iz">容器查询</strong>时，它允许我们查看容器大小，并根据它们的<strong class="jx iz">容器</strong>而不是视口的大小对内容应用样式。</p><p id="5458" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们试着深入探讨细节。</p><p id="d656" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">基本的容器查询编写如下。</p><figure class="lb lc ld le gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi la"><img src="../Images/b3c7646b3cc041fa30d0c26baa6978ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xngmSIkUsLf3dFBEep17WQ.png"/></div></div></figure><p id="defa" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">集装箱类型</strong>有 3 种。</p><ol class=""><li id="f4d3" class="lf lg iy jx b jy jz kc kd kg lh kk li ko lj ks lk ll lm ln bi translated"><strong class="jx iz"> <em class="kt">尺寸——查询将基于</em> </strong> <a class="ae lo" href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Logical_Properties/Basic_concepts#block_and_inline_dimensions" rel="noopener ugc nofollow" target="_blank"> <strong class="jx iz"> <em class="kt">的内联和块</em> </strong> </a> <strong class="jx iz"> <em class="kt">容器的尺寸。它适用于容器的布局、样式和大小。</em>T29】</strong></li><li id="8f27" class="lf lg iy jx b jy lp kc lq kg lr kk ls ko lt ks lk ll lm ln bi translated"><strong class="jx iz"> <em class="kt"> inline-size —查询将基于</em></strong><a class="ae lo" href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Logical_Properties/Basic_concepts#block_and_inline_dimensions" rel="noopener ugc nofollow" target="_blank"><strong class="jx iz"><em class="kt">inline</em></strong></a><strong class="jx iz"><em class="kt">容器的尺寸。它适用于元素的布局、样式和内联大小包含。</em>T13】</strong></li><li id="5a87" class="lf lg iy jx b jy lp kc lq kg lr kk ls ko lt ks lk ll lm ln bi translated"><strong class="jx iz"> <em class="kt">正常-该元素不是任何容器大小查询的查询容器，但仍是容器样式查询的查询容器。</em> </strong></li></ol><p id="675e" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">通常，在大多数情况下，我们使用内嵌大小的容器类型。</p><p id="0d91" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz"> <em class="kt"> CSS 容器单位。</em> </strong></p><ol class=""><li id="247e" class="lf lg iy jx b jy jz kc kd kg lh kk li ko lj ks lk ll lm ln bi translated"><strong class="jx iz"> <em class="kt"> cqw —查询容器宽度的 1%。</em>T25】</strong></li><li id="7796" class="lf lg iy jx b jy lp kc lq kg lr kk ls ko lt ks lk ll lm ln bi translated"><strong class="jx iz"> <em class="kt"> cqh —查询容器高度的 1%。</em>T29】</strong></li><li id="a852" class="lf lg iy jx b jy lp kc lq kg lr kk ls ko lt ks lk ll lm ln bi translated"><strong class="jx iz"> <em class="kt"> cqi —查询容器内联大小的 1%。</em> </strong></li><li id="af6e" class="lf lg iy jx b jy lp kc lq kg lr kk ls ko lt ks lk ll lm ln bi translated"><strong class="jx iz"> <em class="kt"> cqb —查询容器块大小的 1%。</em> </strong></li><li id="67bb" class="lf lg iy jx b jy lp kc lq kg lr kk ls ko lt ks lk ll lm ln bi translated"><strong class="jx iz"><em class="kt">cqmin——cqi/cqb 中的较小值。</em>T41】</strong></li><li id="ab31" class="lf lg iy jx b jy lp kc lq kg lr kk ls ko lt ks lk ll lm ln bi translated"><strong class="jx iz"><em class="kt">CQ max——cqi/cqb 中的较大值。</em>T45】</strong></li></ol><p id="9f29" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在本文中，我们将关注使用容器查询和 flexbox 的响应式设计。</p><p id="1a58" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最初，我们将尝试使用 flexbox 的设计。</p><figure class="lb lc ld le gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi lu"><img src="../Images/a5a2ee5fbf0784d6d171fb6a5ab7003f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P1Wx-PU6Z5yNScLunSTR0g.png"/></div></div></figure><p id="4462" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最终设计将如下。</p><figure class="lb lc ld le gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi lv"><img src="../Images/9c54376fbf192c16979ddc9ff3e0b3e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XBM_WEjICK7UUXDIH-ooHA.png"/></div></div></figure><p id="e3a5" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们看看在上面的例子中我们在做什么。</p><p id="342b" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们试着看看这个设计的 HTML 代码。</p><figure class="lb lc ld le gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi lw"><img src="../Images/fbe15bc9ffb1ea20ffebb5763a59ffd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IwRPUb4_SDD32bxS3b0QPg.png"/></div></div></figure><p id="46e9" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们有一个容器类型为“inline-size”的 card 类和一个将应用 css 设计的容器名。</p><figure class="lb lc ld le gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi lx"><img src="../Images/8860b2950a9d8df57862e9260b24549e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S3n4EMVcPFGiNNKHVWRRsA.png"/></div></div></figure><p id="a148" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们看看如何基于容器大小而不是视口来改变主容器的方向。</p><p id="4c3c" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">主容器的默认 css 如下。</p><figure class="lb lc ld le gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi ly"><img src="../Images/c4ce2c6f68fe58636c28fa9554597f44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mslGbc1_pRdCN1-drvSHBQ.png"/></div></div></figure><p id="3a39" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，让我们看看如果使用容器查询，我们如何改变方向。</p><figure class="lb lc ld le gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi lz"><img src="../Images/ba7a54b49d4727d60ee92c21969d7219.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dxrAE7OqsDzX-uAU17Bo7g.png"/></div></div></figure><p id="f2e5" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">继续，现在让我们看看放在卡片容器中的内容。</p><p id="9854" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是我们卡片内容样式的默认 css。随着本文的深入，在容器查询的帮助下，这种情况将会改变。</p><p id="de43" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在此之前，让我们看看卡容器是什么样子的。如果你熟悉 flexbox，这是有意义的。</p><figure class="lb lc ld le gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi ma"><img src="../Images/5c655efe11f43c18cb44803e33106549.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ob3KNiji-iEU8AoOsgSksQ.png"/></div></div></figure><p id="1d72" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">默认情况下，we 以 0.5 雷姆的间隔堆叠一个在另一个下面的元素；</p><p id="a237" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是我们的卡看起来像上面的容器 css。</p><figure class="lb lc ld le gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi mb"><img src="../Images/c1f448bc0ddfc45cd46f1a27182095f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Nhbhjafc1FZiD7d7JLJnlw.png"/></div></div></figure><p id="3e6f" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，如果我们看到卡片内容“Lorem Ipsum”描述和“你喜欢吗？”按钮在水平方向(x 轴)。</p><figure class="lb lc ld le gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi mc"><img src="../Images/ac5248367cde7a36718fcf5c01400ea2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NLoKCHGWWdqB8AVialRzmw.png"/></div></div></figure><p id="d272" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，让我们尝试使用容器查询来适应这个内容显示。</p><figure class="lb lc ld le gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi md"><img src="../Images/c8c6d12388c668a27ebb4f6de9db2184.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OeEhuJwBru81Ugc4H5LemA.png"/></div></div></figure><p id="2d53" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果屏幕尺寸小于 850px，这就是卡片式的朝向。</p><figure class="lb lc ld le gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi me"><img src="../Images/8423fa2a51e62e3d7857a5cd817a8cc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hc8En7CRTS9vZ6SjUSPTqw.png"/></div></div></figure><p id="a2bc" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">假设，如果页面上有多个 HMTL 元素，我们仍然可以关注页面的特定部分，并根据卡片容器改变方向。这是容器查询最好的部分。我们并不关心整个页面。</p><p id="645f" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这也是事实，在一个普通的 HTML 页面上，并不是每个部分都是必需的，我们可以专注于页面的特定部分。</p><p id="efa0" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我希望，现在它是有意义的，你如何利用容器查询和使用它。</p><p id="9d2a" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">注意:容器查询的用例可以用于元素的任何定位。</strong></p><p id="c6f2" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz"> <em class="kt">容器的回退查询。</em> </strong></p><p id="0067" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="kt">如果浏览器还不支持容器查询，可以使用</em> <code class="fe mf mg mh mi b"><a class="ae lo" href="https://developer.mozilla.org/en-US/docs/Web/CSS/grid" rel="noopener ugc nofollow" target="_blank"><em class="kt">grid</em></a></code> <em class="kt">和</em> <code class="fe mf mg mh mi b"><a class="ae lo" href="https://developer.mozilla.org/en-US/docs/Web/CSS/flex" rel="noopener ugc nofollow" target="_blank"><em class="kt">flex</em></a></code> <em class="kt">为该页面使用的卡片组件创建类似的效果。下面的例子使用一个</em> <code class="fe mf mg mh mi b"><a class="ae lo" href="https://developer.mozilla.org/en-US/docs/Web/CSS/grid-template-columns" rel="noopener ugc nofollow" target="_blank"><em class="kt">grid-template-columns</em></a></code> <em class="kt">声明为卡片组件创建一个两列布局。</em></p><p id="133d" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后，附上链接来玩玩。</p><p id="308a" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae lo" href="https://codesandbox.io/s/sweet-fog-vojyrn" rel="noopener ugc nofollow" target="_blank">https://codesandbox.io/s/sweet-fog-vojyrn</a></p><p id="a7df" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我希望，你喜欢读这篇文章。</p><p id="1bbc" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">请关注我的相关文章，它可能会对您的 web 开发之旅有所帮助。</p></div></div>    
</body>
</html>