<html>
<head>
<title>Build Or Clone — A Federated API — Pt. 1: The Gateway ++</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建或克隆—一个联合 API — Pt。1:网关++</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/build-or-clone-a-federated-api-pt-1-the-gateway-ad75dad21459?source=collection_archive---------6-----------------------#2022-02-18">https://blog.devgenius.io/build-or-clone-a-federated-api-pt-1-the-gateway-ad75dad21459?source=collection_archive---------6-----------------------#2022-02-18</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="7f0b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">大家好，感谢加入我所说的“构建或克隆”所以你可以和我一起建，或者克隆完成的回购！我们正在创建一个全功能的阿波罗联合 API。这是第 1 部分——Gateway++。</p><p id="5f1a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">今天，我想分享我在过去几个月里一直在做的一个项目的一部分——一个比一般的教程/入门回购更有吸引力的 Apollo 网关。</p><p id="e3e7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">除了将一般的 graphql 请求定向到子图之外，网关还有多种职责。无论您是选择自己构建还是克隆最终结果作为起点，这个网关都履行了在创建自己的网关时可能会被忽略的职责。</p><p id="6b28" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，如果你有兴趣学习一点关于回购、网关的责任或者如何编写网关代码，请继续阅读！</p><p id="f10b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对于那些只想克隆功能完整的最终结果回购的人，请跳到底部了解如何操作。我制作它是为了让人们可以把它作为他们自己的门户的一个开端，或者只是按原样运行！</p><p id="2555" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们启动网关。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/341f7847622939e17364d94ec9a69778.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HgEyJh8cv_a4yP_LAYsT4Q.jpeg"/></div></div></figure><h1 id="e370" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">阿波罗之门——我们正在建造的</h1><p id="aa90" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">网关是联合架构中微服务 API 的入口点。所有对 API 的请求都需要通过网关，这意味着这个小服务有很多责任。</p><p id="74bb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了从用户的微服务中获取用户，客户机将把请求发送给网关，然后网关将找到到达用户服务的方法来完成请求。</p><h2 id="b4c3" class="lx kv in bd kw ly lz dn la ma mb dp le jv mc md li jz me mf lm kd mg mh lq mi bi translated">好处</h2><p id="2607" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">与直接查询外部服务相反，使用网关提供了相当多的好处。</p><ol class=""><li id="8d35" class="mk ml in jm b jn jo jr js jv mm jz mn kd mo kh mp mq mr ms bi translated">单一端点—无论有多少服务，客户端只需知道一个单一端点和服务器位置。</li><li id="7d5a" class="mk ml in jm b jn mt jr mu jv mv jz mw kd mx kh mp mq mr ms bi translated">全局上下文—可以在网关级别将全局上下文添加到所有请求中。键入的自定义数据现在可以传递给所有微服务。</li><li id="5945" class="mk ml in jm b jn mt jr mu jv mv jz mw kd mx kh mp mq mr ms bi translated">全局授权——现在可以在网关级别全局解析授权，而不必在每个微服务上解析授权。</li></ol><h2 id="bffe" class="lx kv in bd kw ly lz dn la ma mb dp le jv mc md li jz me mf lm kd mg mh lq mi bi translated">责任</h2><p id="3d6f" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">这意味着网关也将有相当多的推断出的<em class="mj">职责</em>。</p><ol class=""><li id="bb29" class="mk ml in jm b jn jo jr js jv mm jz mn kd mo kh mp mq mr ms bi translated">将请求传递给正确的子图</li><li id="854c" class="mk ml in jm b jn mt jr mu jv mv jz mw kd mx kh mp mq mr ms bi translated">类型检查传入的 GraphQL 请求</li><li id="8035" class="mk ml in jm b jn mt jr mu jv mv jz mw kd mx kh mp mq mr ms bi translated">处理授权</li><li id="1f2f" class="mk ml in jm b jn mt jr mu jv mv jz mw kd mx kh mp mq mr ms bi translated">将上下文附加到请求</li><li id="1a6d" class="mk ml in jm b jn mt jr mu jv mv jz mw kd mx kh mp mq mr ms bi translated">处理文件上传请求(为什么现代应用程序不接受文件上传？)</li><li id="5100" class="mk ml in jm b jn mt jr mu jv mv jz mw kd mx kh mp mq mr ms bi translated">提供上传的文件/静态资产</li></ol><p id="e9d2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">希望你明白了！建立一个网关来做我们需要它为现代 API 做的事情是很重要的。</p><p id="a908" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，我们将为一个 API 构建一个网关，来处理上述的 6 个<em class="mj">责任</em>和 3 个<em class="mj">利益</em>。</p><h1 id="c4f9" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">正在设置</h1><h2 id="b753" class="lx kv in bd kw ly lz dn la ma mb dp le jv mc md li jz me mf lm kd mg mh lq mi bi translated">创建和初始化</h2><p id="a863" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">为项目创建网关目录，并用 npm 初始化。</p><pre class="kj kk kl km gt my mz na nb aw nc bi"><span id="bc74" class="lx kv in mz b gy nd ne l nf ng">mkdir gateway-tutorial<br/>cd gateway-tutorial<br/>npm init -y</span></pre><p id="2c60" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下面的例子将使用 typescript，但是设置它超出了本文的范围。确保按照您喜欢的方式设置您的 tsconfig。</p><p id="80da" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">完成后，让我们创建<code class="fe nh ni nj mz b">src</code>文件和入口点。</p><pre class="kj kk kl km gt my mz na nb aw nc bi"><span id="5e05" class="lx kv in mz b gy nd ne l nf ng">mkdir src<br/>touch server.ts</span></pre><h1 id="4cda" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">入口点— Server.ts</h1><h2 id="3a73" class="lx kv in bd kw ly lz dn la ma mb dp le jv mc md li jz me mf lm kd mg mh lq mi bi translated">快速设置</h2><p id="c6c9" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">网关将需要能够接受 GraphQL 请求以及对静态资产的请求(RESTful 请求)。</p><p id="dd7e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了处理快速设置，我们需要几个包。</p><pre class="kj kk kl km gt my mz na nb aw nc bi"><span id="4d41" class="lx kv in mz b gy nd ne l nf ng">npm i express cors</span></pre><p id="dea6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Express 将非常适合处理静态资产的服务。首先为一个简单的 express 应用程序创建样板文件。</p><pre class="kj kk kl km gt my mz na nb aw nc bi"><span id="54ad" class="lx kv in mz b gy nd ne l nf ng">// server.ts</span><span id="68a7" class="lx kv in mz b gy nk ne l nf ng">import { express } from "express";<br/>import cors from "cors";</span><span id="8a58" class="lx kv in mz b gy nk ne l nf ng">const app = express();<br/>app.use(cors());<br/>app.use(express.json());</span><span id="0197" class="lx kv in mz b gy nk ne l nf ng">const port = 5000;</span><span id="a6df" class="lx kv in mz b gy nk ne l nf ng">app.listen(port, () =&gt; console.log(`GATEWAY ====&gt; UP ON PORT ${port}`));</span></pre><h2 id="c59e" class="lx kv in bd kw ly lz dn la ma mb dp le jv mc md li jz me mf lm kd mg mh lq mi bi translated">创建网关</h2><p id="0384" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">我们将能够用<code class="fe nh ni nj mz b">@apollo/gateway</code>包创建网关。</p><p id="f6d3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个<code class="fe nh ni nj mz b">@the-devoyage/micro-auth-helpers</code>包提供了助手函数来生成上下文、传递消息头、解析授权状态等等。从 GitHub 注册表安装这个包，如下所示，或者查看<a class="ae nl" href="https://github.com/The-Devoyage/micro-auth-helpers/packages/1244493" rel="noopener ugc nofollow" target="_blank">微认证助手文档</a>。</p><p id="4be7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="mj">务必将范围添加到您的</em> <code class="fe nh ni nj mz b"><em class="mj">.npmrc</em></code> <em class="mj">中，并登录 GitHub 注册表。</em></p><pre class="kj kk kl km gt my mz na nb aw nc bi"><span id="2bc3" class="lx kv in mz b gy nd ne l nf ng">## Login to GitHub registry<br/>npm login --registry=https://npm.pkg.github.com</span><span id="8b0e" class="lx kv in mz b gy nk ne l nf ng">## Tell NPM where to find `@the-devoyage` packages. <br/>echo <a class="ae nl" href="http://twitter.com/the" rel="noopener ugc nofollow" target="_blank">@the</a>-devoyage:registry=<a class="ae nl" href="https://npm.pkg.github.com" rel="noopener ugc nofollow" target="_blank">https://npm.pkg.github.com</a> &gt;&gt; .npmrc</span><span id="3242" class="lx kv in mz b gy nk ne l nf ng">## Install The Packages<br/>npm i @apollo/gateway @the-devoyage/micro-auth-helpers</span></pre><p id="8fab" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后创建网关</p><pre class="kj kk kl km gt my mz na nb aw nc bi"><span id="c3f8" class="lx kv in mz b gy nd ne l nf ng">// server.ts</span><span id="750c" class="lx kv in mz b gy nk ne l nf ng">import { ApolloGateway } from "@apollo/gateway";<br/>import { Helpers } from "@the-devoyage/micro-auth-helpers";<br/>import { readFileSync } from "fs";<br/>// ...imports</span><span id="532e" class="lx kv in mz b gy nk ne l nf ng">// Express Setup...</span><span id="353f" class="lx kv in mz b gy nk ne l nf ng">const supergraphSdl = readFileSync("./supergraph.graphql").toString();</span><span id="6a98" class="lx kv in mz b gy nk ne l nf ng">const gateway = new ApolloGateway({<br/>  supergraphSdl: supergraphSdl ?? "",<br/>  buildService({ url }) {<br/>    const dataSource = new Helpers.Gateway.ContextDataSource({ url });<br/>    return dataSource;<br/>  },<br/>});</span></pre><p id="3630" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe nh ni nj mz b">supergraphSdl</code>是整个 API 中所有类型的模式。从根本上说，它定义了在您的网关中可以或不可以发生什么。这将在接下来的步骤中使用 Rover CLI 生成，所以现在不要担心实际的文件——只需确保像上面一样阅读它。</p><p id="3ddf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在新的<code class="fe nh ni nj mz b">ApolloGateway</code>实例中，<code class="fe nh ni nj mz b">buildService</code>函数允许我们将数据添加到请求的 outgoing to 子图中。这意味着我们可以生成全局<code class="fe nh ni nj mz b">context</code>——源自网关但被传递给所有连接的子图的数据。</p><p id="e538" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您可以从包<code class="fe nh ni nj mz b">@apollo/gateway</code>中扩展<code class="fe nh ni nj mz b">RemoteGraphQLDataSource</code>，以创建您自己的全局上下文——或者—<code class="fe nh ni nj mz b">@the-devoyage/micro-auth-helpers</code>包通过助手<code class="fe nh ni nj mz b">ContextDataSource</code>帮助我们完成这项工作，如上面的代码示例所示。</p><p id="1ab7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">除了帮助我们创建全局上下文，<code class="fe nh ni nj mz b">ContextDataSource</code>助手还使用<code class="fe nh ni nj mz b">graphql-upload</code>包通过 GraphQL 请求将文件上传功能扩展到外部 API。这个我们下面就讲！</p><h2 id="f266" class="lx kv in bd kw ly lz dn la ma mb dp le jv mc md li jz me mf lm kd mg mh lq mi bi translated">创建并启动 Apollo 服务器</h2><p id="685c" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">是时候创建 Apollo 服务器了，我们需要另外几个包来完成这个任务。</p><pre class="kj kk kl km gt my mz na nb aw nc bi"><span id="1031" class="lx kv in mz b gy nd ne l nf ng">npm i apollo-server-express graphql-upload dotenv</span></pre><p id="80e6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">并创建服务器:</p><pre class="kj kk kl km gt my mz na nb aw nc bi"><span id="5cf0" class="lx kv in mz b gy nd ne l nf ng">// server.ts</span><span id="7d62" class="lx kv in mz b gy nk ne l nf ng">import { Helpers } from "@the-devoyage/micro-auth-helpers";<br/>import { ApolloServer } from "apollo-server-express";<br/>import { graphqlUploadExpress } from "graphql-upload";<br/>import dotenv from "dotenv";<br/>// ...imports</span><span id="45a9" class="lx kv in mz b gy nk ne l nf ng">// ...Express Setup</span><span id="fd8b" class="lx kv in mz b gy nk ne l nf ng">// ...Gateway Setup</span><span id="baad" class="lx kv in mz b gy nk ne l nf ng">dotenv.config(); // Get Environment Variables</span><span id="f665" class="lx kv in mz b gy nk ne l nf ng">// Create and Start Apollo Server</span><span id="5ccb" class="lx kv in mz b gy nk ne l nf ng">let apolloServer;</span><span id="6077" class="lx kv in mz b gy nk ne l nf ng">async function startServer() {<br/>  apolloServer = new ApolloServer({<br/>    gateway,<br/>    context: ({ req }) =&gt;<br/>      Helpers.Gateway.GenerateContext({<br/>        headers: ["Authorization"],<br/>        req,<br/>        secretOrPublicKey: process.env.JWT_ENCRYPTION_KEY,<br/>      }),<br/>  });<br/>  await apolloServer.start();<br/>  app.use(graphqlUploadExpress());<br/>  apolloServer.applyMiddleware({ app });<br/>}</span><span id="f0ed" class="lx kv in mz b gy nk ne l nf ng">startServer();</span><span id="83fc" class="lx kv in mz b gy nk ne l nf ng">// Start Express Server</span><span id="bde7" class="lx kv in mz b gy nk ne l nf ng">app.listen(port, () =&gt; console.log(`GATEWAY ====&gt; UP ON PORT ${port}`));</span></pre><p id="86ec" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">异步功能允许我们等待<code class="fe nh ni nj mz b">apolloServer</code>的开始，应用<code class="fe nh ni nj mz b">graphql-upload</code>中间件，最后将快速应用应用到<code class="fe nh ni nj mz b">apolloServer</code>。</p><p id="0953" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe nh ni nj mz b">GenerateContext</code>助手将允许我们为服务器创建一个上下文，更重要的是，auth context。</p><p id="2361" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">用这个助手生成上下文的第一种方法是挑选传入请求的头，用作网关服务器中的上下文。这非常有用，因为我们将需要检查 JWT 的<code class="fe nh ni nj mz b">Authorization</code>头，以向服务器授权。要选择一个头作为上下文，将它添加到<code class="fe nh ni nj mz b">headers</code>数组中，就像我对上面的<code class="fe nh ni nj mz b">Authorization</code>所做的那样。</p><p id="e451" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">助手的巧妙之处在于它做的比它引导的多一点。在我们的例子中，因为我们使用了一个 JWT 和一个<code class="fe nh ni nj mz b">Authorization</code>头，它还将解码 JWT 有效载荷并将结果添加到上下文中。我们只需提供<code class="fe nh ni nj mz b">JWT_ENCRYPTION_KEY</code>，作为函数的参数。</p><p id="cea8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，简单地通过使用<code class="fe nh ni nj mz b">GenerateContext</code>和<code class="fe nh ni nj mz b">ContextDataSource</code>，我们能够为我们的 API 创建一个全局<code class="fe nh ni nj mz b">auth</code>上下文。</p><pre class="kj kk kl km gt my mz na nb aw nc bi"><span id="5e3e" class="lx kv in mz b gy nd ne l nf ng">// Global Context</span><span id="b3b0" class="lx kv in mz b gy nk ne l nf ng">export interface Context extends Record&lt;string, any&gt; {<br/>  auth: AuthContext;<br/>  // ...other custom context!<br/>}</span><span id="d28d" class="lx kv in mz b gy nk ne l nf ng">export interface AuthContext {<br/>  payload: Payload;<br/>  isAuth: boolean;<br/>  error?: string;<br/>}</span></pre><p id="cb3f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">检查包本身:</p><div class="nm nn gp gr no np"><a href="https://github.com/The-Devoyage/micro-auth-helpers/packages/1244493" rel="noopener  ugc nofollow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd io gy z fp nu fr fs nv fu fw im bi translated">将微身份验证助手打包到-devo yage/微身份验证助手</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">这是一组函数，可以简化在联邦环境中处理身份验证和授权的过程…</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">github.com</p></div></div><div class="ny l"><div class="nz l oa ob oc ny od ks np"/></div></div></a></div><p id="3f53" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是我写的一篇文章，概述了这个包的特性:</p><div class="nm nn gp gr no np"><a rel="noopener  ugc nofollow" target="_blank" href="/apollo-federation-how-do-request-travel-through-a-federated-architecture-e4a4da54f46d"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd io gy z fp nu fr fs nv fu fw im bi translated">Apollo 联邦:请求如何通过联邦架构？</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">通过联合 Apollo 架构的网络请求之旅非常有趣——了解流程，同时…</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">blog.devgenius.io</p></div></div><div class="ny l"><div class="oe l oa ob oc ny od ks np"/></div></div></a></div><h2 id="5a95" class="lx kv in bd kw ly lz dn la ma mb dp le jv mc md li jz me mf lm kd mg mh lq mi bi translated">处理静态文件请求</h2><p id="fb8b" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">接下来，我们需要确保 restful 请求仍然可以通过网关服务器，即使客户端请求的是图像之类的文件。</p><p id="136c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">网关将需要接收请求，并将其代理到将处理该请求的适当服务器。</p><p id="1af5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">首先，安装代理软件:</p><pre class="kj kk kl km gt my mz na nb aw nc bi"><span id="a3ee" class="lx kv in mz b gy nd ne l nf ng">npm i http-proxy-middleware </span></pre><p id="4c58" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">创建处理代理的路由:</p><pre class="kj kk kl km gt my mz na nb aw nc bi"><span id="7c6b" class="lx kv in mz b gy nd ne l nf ng">// server.ts<br/>import { createProxyMiddleware } from "http-proxy-middleware";<br/>// ...imports</span><span id="75fd" class="lx kv in mz b gy nk ne l nf ng">// Express Setup...</span><span id="568e" class="lx kv in mz b gy nk ne l nf ng">app.use(<br/>    process.env.MEDIA_SERVING_ROUTE ?? "/public",<br/>    createProxyMiddleware({<br/>      target: process.env.MEDIA_SERVER_URL,<br/>      changeOrigin: false,<br/>    })<br/>  );</span></pre><p id="ee9f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们可以使用环境变量，而不是硬编码路由和服务器位置。这将允许您在生产和开发环境之间切换路由或服务器 URL。</p><p id="aa39" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，发往环境变量中指定的端点的所有网关请求都将被重定向到指定的服务器，在那里我们可以处理图像的查找和提供。</p><h1 id="6e6a" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">启动服务器</h1><p id="26b8" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">用 nodemon 启动服务器，或者如果愿意的话，通过创建一个 npm 脚本来启动服务器，或者尝试一下传统的方法——如果使用 typescript，不要忘记首先编译它。</p><pre class="kj kk kl km gt my mz na nb aw nc bi"><span id="aaf9" class="lx kv in mz b gy nd ne l nf ng">node server.js</span></pre><p id="13d6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们应该看到服务器活跃起来，网关现在可以开始接收请求了！</p><pre class="kj kk kl km gt my mz na nb aw nc bi"><span id="d7a7" class="lx kv in mz b gy nd ne l nf ng">GATEWAY ====&gt; UP ON PORT 5000</span></pre><p id="6196" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">网关已经启动，但还没那么有用，因为没有超级图来启用类型检查或路由。</p><p id="4485" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">从教程的这一部分开始，您将需要一些联邦子图来继续运行。如果你手头缺少子图，那就抓紧了——这是 5 部分系列的第 1 部分！下周我们将创建一个账户子图。如果你感兴趣，一定要跟着去。</p><h1 id="5742" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">安装漫游者并生成一个超级图</h1><p id="2b35" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">首先，从<a class="ae nl" href="https://www.apollographql.com/docs/rover/getting-started" rel="noopener ugc nofollow" target="_blank"> Apollo Docs </a>中选择您的安装方法来安装 Rover CLI。下面我用 curl 来做:</p><pre class="kj kk kl km gt my mz na nb aw nc bi"><span id="e5a5" class="lx kv in mz b gy nd ne l nf ng">curl -sSL https://rover.apollo.dev/nix/latest | sh</span></pre><p id="5e89" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在创建一个配置文件，保存到项目的根目录。这个文件将告诉网关关于每个服务的信息。我把我的叫做<code class="fe nh ni nj mz b">supergraph-config.yaml</code>。</p><pre class="kj kk kl km gt my mz na nb aw nc bi"><span id="1b9a" class="lx kv in mz b gy nd ne l nf ng">subgraphs:<br/>  accounts:<br/>    routing_url: <a class="ae nl" href="http://localhost:5001" rel="noopener ugc nofollow" target="_blank">http://localhost:5001</a> <br/>    schema:<br/>      subgraph_url: <a class="ae nl" href="http://localhost:5001" rel="noopener ugc nofollow" target="_blank">http://localhost:5001</a> <br/>  users:<br/>    routing_url: <a class="ae nl" href="http://localhost:5002" rel="noopener ugc nofollow" target="_blank">http://localhost:5002</a><br/>    schema:<br/>      subgraph_url: <a class="ae nl" href="http://localhost:5002" rel="noopener ugc nofollow" target="_blank">http://localhost:5002</a><br/>  meida:<br/>    routing_url: <a class="ae nl" href="http://localhost:5006/graphql" rel="noopener ugc nofollow" target="_blank">http://localhost:5006/graphql</a><br/>    schema:<br/>      subgraph_url: <a class="ae nl" href="http://localhost:5006/graphql" rel="noopener ugc nofollow" target="_blank">http://localhost:5006/graphql</a><br/>  mailer:<br/>    routing_url: <a class="ae nl" href="http://mailer:5008/graphql" rel="noopener ugc nofollow" target="_blank">http://mailer:5008/graphql</a><br/>    schema:<br/>      subgraph_url: <a class="ae nl" href="http://localhost:5008/graphql" rel="noopener ugc nofollow" target="_blank">http://localhost:5008/graphql</a></span></pre><p id="6b1f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当所有子图都在运行时，我们现在可以使用 Rover CLI 来生成一个超级图。</p><pre class="kj kk kl km gt my mz na nb aw nc bi"><span id="e891" class="lx kv in mz b gy nd ne l nf ng">rover supergraph compose --config ./supergraph-config.yaml &gt; supergraph.graphql</span></pre><p id="2b22" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果所有的类型检查都成功，它将输出保存到我们上面定义的文件中，<code class="fe nh ni nj mz b">supergraph.graphql.</code></p><h2 id="9bf2" class="lx kv in bd kw ly lz dn la ma mb dp le jv mc md li jz me mf lm kd mg mh lq mi bi translated">重启网关并庆祝</h2><p id="096c" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">就这样，我们就要完成了。每当子图类型改变时，都需要重新生成超图，并且每当超图重新生成时，都需要重新启动网关。</p><p id="484b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一旦网关重启，您应该能够查询子图了！</p><h1 id="cf8f" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">网关—存储库</h1><p id="0c61" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">嘿！您刚刚构建了一个健壮的网关来处理各种请求场景…或者等等，您是那个跳到底层的人吗！不管怎样，看看这个网关！</p><ul class=""><li id="5f5b" class="mk ml in jm b jn jo jr js jv mm jz mn kd mo kh of mq mr ms bi translated">类型检查所有子图</li><li id="6365" class="mk ml in jm b jn mt jr mu jv mv jz mw kd mx kh of mq mr ms bi translated">使用 Rover CLI/supergraph 将 graphql 请求路由到正确的子图</li><li id="9e02" class="mk ml in jm b jn mt jr mu jv mv jz mw kd mx kh of mq mr ms bi translated">从各种来源生成网关上下文，如请求头、jwt 或自定义数据</li><li id="6c19" class="mk ml in jm b jn mt jr mu jv mv jz mw kd mx kh of mq mr ms bi translated">全局上下文—上下文被发送到所有外部微服务</li><li id="6939" class="mk ml in jm b jn mt jr mu jv mv jz mw kd mx kh of mq mr ms bi translated">为每个请求自动创建一个类型化的授权上下文</li><li id="c8ef" class="mk ml in jm b jn mt jr mu jv mv jz mw kd mx kh of mq mr ms bi translated">代理往来于外部微服务器的 restful 请求，从文件存储微服务请求静态资产。</li><li id="51d5" class="mk ml in jm b jn mt jr mu jv mv jz mw kd mx kh of mq mr ms bi translated">它将 graphql 请求中的文件传递给子图——用于<code class="fe nh ni nj mz b">graphql-upload</code></li></ul><h2 id="4131" class="lx kv in bd kw ly lz dn la ma mb dp le jv mc md li jz me mf lm kd mg mh lq mi bi translated">克隆存储库</h2><p id="6628" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">我把这个库做成了双重用途——把它作为一个入门模板来定制你自己的网关，或者启动它并把它作为你下一个项目的现成网关，它将满足大多数需求。</p><p id="afbe" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae nl" href="https://basetools.io/checkout/XGUVNNGr" rel="noopener ugc nofollow" target="_blank">购买权限</a> —我使用 Basetools 为我的 git 回购协议添加了一个付费墙！一旦您的交易通过，您将收到一封电子邮件，要求您作为合作者加入回购。这意味着你可以随心所欲地克隆它，随心所欲地使用它。您还可以访问所有未来版本！</p><p id="43e5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">不想购买？没关系——成为关注者并给我发消息，我也会将你添加为合作者以获得这种类型的支持！</p></div><div class="ab cl og oh hr oi" role="separator"><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol"/></div><div class="ig ih ii ij ik"><p id="1c7d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">感谢您阅读这篇关于创建 Apollo 网关的教程。我希望它能帮助你开始你的下一个项目！</p><p id="27bc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">请继续关注，因为 4 graphql federated micro services 还有 4 个教程/回购即将推出！我们将建立一个帐户微服务，一个用户微服务，一个文件上传微服务，最后是一个自动化的电子邮件微服务！</p></div></div>    
</body>
</html>