<html>
<head>
<title>Flutter State Management with Provider</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">提供者的颤振状态管理</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/flutter-state-management-with-provider-5a57eca108f1?source=collection_archive---------0-----------------------#2022-06-03">https://blog.devgenius.io/flutter-state-management-with-provider-5a57eca108f1?source=collection_archive---------0-----------------------#2022-06-03</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="d03d" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated"><strong class="ak">介绍提供者及其用途(动态主题变化、反例、购物车功能示例等)。)</strong></h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/93231ea54993002e41df12d7c348b9cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:604/format:webp/1*VuALlvkEdAzT4rKyYwpF1A.png"/></div></div></figure></div><div class="ab cl ko kp hr kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="ig ih ii ij ik"><p id="a345" class="pw-post-body-paragraph kv kw in kx b ky kz jo la lb lc jr ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated"><em class="lr">颤振中的状态管理类型。</em></p><ul class=""><li id="1823" class="ls lt in kx b ky kz lb lc le lu li lv lm lw lq lx ly lz ma bi translated">供应者</li><li id="0c88" class="ls lt in kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">Riverpod</li><li id="a4a5" class="ls lt in kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">设置状态</li><li id="568b" class="ls lt in kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">InheritedWidget &amp; InheritedModel</li><li id="f650" class="ls lt in kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">Redux</li><li id="9b5e" class="ls lt in kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">鱼还原</li><li id="24a3" class="ls lt in kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">阻塞/接收</li><li id="d0ee" class="ls lt in kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">GetIt</li><li id="dd31" class="ls lt in kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">MobX</li><li id="c503" class="ls lt in kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">颤动命令</li><li id="17c3" class="ls lt in kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">粘合剂</li><li id="f9cb" class="ls lt in kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">GetX</li><li id="e9aa" class="ls lt in kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">状态 _ 重建者</li><li id="5fe3" class="ls lt in kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">三重模式(分段状态模式)。</li></ul></div><div class="ab cl ko kp hr kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="ig ih ii ij ik"><h1 id="4bd2" class="mg mh in bd mi mj mk ml mm mn mo mp mq jt mr ju ms jw mt jx mu jz mv ka mw mx bi translated">颤振是什么状态？</h1><p id="7fc1" class="pw-post-body-paragraph kv kw in kx b ky my jo la lb mz jr ld le na lg lh li nb lk ll lm nc lo lp lq ig bi translated">Flutter 中的“状态”指的是存储在小部件中的数据，可以根据当前操作进行修改。应用程序的状态可以在应用程序启动时或页面重新加载时更新或完全改变。</p><p id="17e6" class="pw-post-body-paragraph kv kw in kx b ky kz jo la lb lc jr ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">这意味着小部件需要处理从用户那里获取的数据，并在它们之间传递数据以执行一个或多个操作。Flutter 还可以使用状态向用户显示信息片段。</p></div><div class="ab cl ko kp hr kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="ig ih ii ij ik"><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/fddfd4eadd010ef432c6b1d72b770855.png" data-original-src="https://miro.medium.com/v2/resize:fit:636/format:webp/1*SBI7-cpLCaFRHwnY36ljiw.png"/></div></figure><h1 id="5ceb" class="mg mh in bd mi mj ne ml mm mn nf mp mq jt ng ju ms jw nh jx mu jz ni ka mw mx bi translated">什么是提供商？</h1><p id="f27f" class="pw-post-body-paragraph kv kw in kx b ky my jo la lb mz jr ld le na lg lh li nb lk ll lm nc lo lp lq ig bi translated">Remi Rousselet 创建的提供者包<a class="ae nj" href="https://pub.dev/packages/provider" rel="noopener ugc nofollow" target="_blank">旨在尽可能干净地处理状态。在 Provider 中，小部件监听状态的变化，并在得到通知后立即更新。</a></p><p id="a349" class="pw-post-body-paragraph kv kw in kx b ky kz jo la lb lc jr ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">因此，当出现状态更改时，不是重建整个小部件树，而是只更改受影响的小部件，从而减少工作量，使应用程序运行得更快、更流畅。</p></div><div class="ab cl ko kp hr kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="ig ih ii ij ik"><h1 id="de04" class="mg mh in bd mi mj mk ml mm mn mo mp mq jt mr ju ms jw mt jx mu jz mv ka mw mx bi translated">提供者的状态管理</h1><p id="d480" class="pw-post-body-paragraph kv kw in kx b ky my jo la lb mz jr ld le na lg lh li nb lk ll lm nc lo lp lq ig bi translated">回想一下我们之前讨论过的关于提供者的内容:小部件监听变化并在有重建时相互通知。一旦状态发生变化，这个特定的小部件就会重新构建，而不会影响树中的其他小部件。</p><p id="ec48" class="pw-post-body-paragraph kv kw in kx b ky kz jo la lb lc jr ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">三个主要组件使这一切成为可能:Flutter 中的<code class="fe nk nl nm nn b">ChangeNotifier</code>类、<code class="fe nk nl nm nn b">ChangeNotifierProvider</code>(主要用于我们的示例应用程序)和<code class="fe nk nl nm nn b">Consumer</code>小部件。</p><p id="8b81" class="pw-post-body-paragraph kv kw in kx b ky kz jo la lb lc jr ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">从<code class="fe nk nl nm nn b">ChangeNotifier</code>类观察到的任何状态变化都会导致监听小部件重新构建。提供商包提供了不同类型的提供商，下面列出了其中一些:</p><ul class=""><li id="8f0b" class="ls lt in kx b ky kz lb lc le lu li lv lm lw lq lx ly lz ma bi translated"><code class="fe nk nl nm nn b">Provider</code>不管值类型如何，该类接受一个值并公开它</li><li id="1975" class="ls lt in kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated"><code class="fe nk nl nm nn b">ListenableProvider</code>是用于 listenable 对象的特定提供程序。它会监听，然后要求依赖于它并受状态变化影响的小部件在任何时候调用监听器时进行重建</li><li id="2d82" class="ls lt in kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated"><code class="fe nk nl nm nn b">ChangeNotifierProvider</code>与<code class="fe nk nl nm nn b">ListenableProvider</code>类似，但针对<code class="fe nk nl nm nn b">ChangeNotifier</code>对象，需要时自动调用<code class="fe nk nl nm nn b">ChangeNotifier.dispose</code></li><li id="c8ab" class="ls lt in kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated"><code class="fe nk nl nm nn b">ValueListenableProvider</code>监听一个<code class="fe nk nl nm nn b">ValueListenable</code>并公开该值</li><li id="1d73" class="ls lt in kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated"><code class="fe nk nl nm nn b">StreamProvider</code>监听流，公开发出的最新值，并要求依赖于流的小部件进行重建</li><li id="b196" class="ls lt in kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated"><code class="fe nk nl nm nn b">FutureProvider</code>接受一个<code class="fe nk nl nm nn b">Future</code>类，并在未来完成时根据它更新小部件</li><li id="de29" class="ls lt in kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated"><code class="fe nk nl nm nn b">consumer</code>一个提供者包小部件，它对 ChangeNotifier 的更改做出反应，并调用构建方法来应用模型更新。不需要 UI 的所有部分都使用来自提供者<strong class="kx io">、</strong>的状态数据，因此需要重新构建。可能任何屏幕的 50%的用户界面都不需要重建，在我们的例子中不是这样。因此，Consumer 是一个小部件，它允许您在 UI 的特定部分观察 ChangeNotifier 的状态变化，因此只有观察到的 UI 部分会被重新呈现。</li></ul><blockquote class="no np nq"><p id="1913" class="kv kw lr kx b ky kz jo la lb lc jr ld nr lf lg lh ns lj lk ll nt ln lo lp lq ig bi translated"><strong class="kx io">让我们看看如何在提供商中实现消费者。</strong></p></blockquote><p id="e3fa" class="pw-post-body-paragraph kv kw in kx b ky kz jo la lb lc jr ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated"><strong class="kx io">使用以下扩展方法读取值</strong></p><ol class=""><li id="ea54" class="ls lt in kx b ky kz lb lc le lu li lv lm lw lq nu ly lz ma bi translated"><strong class="kx io">context . watch</strong>&lt;T&gt;()让小部件监听 T 上的变化。</li><li id="92e4" class="ls lt in kx b ky mb lb mc le md li me lm mf lq nu ly lz ma bi translated"><strong class="kx io"> context.read </strong></li><li id="5af0" class="ls lt in kx b ky mb lb mc le md li me lm mf lq nu ly lz ma bi translated"><strong class="kx io"> context.select </strong> &lt; T，R &gt;选择器允许你在一个提供者中选择一个特定的值来监听。然后，当且仅当选择的值改变时，由选择器的构建器方法返回的小部件将重新构建。</li></ol><p id="5936" class="pw-post-body-paragraph kv kw in kx b ky kz jo la lb lc jr ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">也可以使用静态方法 Provider.of <taskproviders> (context)，它的行为类似于 watch。</taskproviders></p><p id="f8f3" class="pw-post-body-paragraph kv kw in kx b ky kz jo la lb lc jr ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">当 listen 参数设置为 false(如在 Provider.of <taskproviders> (context，listen: false))时，它的行为类似于 read。</taskproviders></p><p id="1850" class="pw-post-body-paragraph kv kw in kx b ky kz jo la lb lc jr ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">值得注意的是，当值改变时，context.read <t>()不会重新构建小部件，并且它不能在 StatelessWidget.build/State.build.内部调用。另一方面，它可以在这些方法之外自由调用。</t></p><blockquote class="no np nq"><p id="e07e" class="kv kw lr kx b ky kz jo la lb lc jr ld nr lf lg lh ns lj lk ll nt ln lo lp lq ig bi translated"><strong class="kx io">让我们看看如何在提供者中实现上述方法。</strong></p></blockquote><p id="88cf" class="pw-post-body-paragraph kv kw in kx b ky kz jo la lb lc jr ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated"><strong class="kx io">代理供应商</strong></p><p id="d8b2" class="pw-post-body-paragraph kv kw in kx b ky kz jo la lb lc jr ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">ProxyProvider 是一个提供程序，它将来自其他提供程序的多个值组合成一个新对象，然后将结果发送给该提供程序。它基本上将一个更改的值注入到另一个提供者中。每当使用一个以上的提供者并且一个提供者的值依赖于另一个提供者时，我们就使用 ProxyProvider。每当它所依赖的一个提供者也更新时，另一个提供者就更新它的值。</p><p id="bb6d" class="pw-post-body-paragraph kv kw in kx b ky kz jo la lb lc jr ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">即:我们有两个提供者:人和工作。一个<strong class="kx io">任务</strong>需要一个人进行初始化。在这种情况下，<strong class="kx io">作业</strong>就是<em class="lr">代理</em>。这意味着工作是你可能想要接触的对象，但是它的价值依赖于<strong class="kx io">人</strong></p><blockquote class="no np nq"><p id="fdcb" class="kv kw lr kx b ky kz jo la lb lc jr ld nr lf lg lh ns lj lk ll nt ln lo lp lq ig bi translated">让我们看看如何实现代理提供者。</p></blockquote><p id="ef93" class="pw-post-body-paragraph kv kw in kx b ky kz jo la lb lc jr ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated"><strong class="kx io">未来供应商:</strong></p><p id="7130" class="pw-post-body-paragraph kv kw in kx b ky kz jo la lb lc jr ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">顾名思义，FutureProvider 提供了一个<strong class="kx io">未来值</strong>，当获取该值的小部件已经可以使用时，这个值可能还没有准备好。这与 Flutter 中的<strong class="kx io">未来职业有很大关系。</strong></p><p id="5dcc" class="pw-post-body-paragraph kv kw in kx b ky kz jo la lb lc jr ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">这与其他供应商有很大的不同。由于提供的值可能需要一段时间才能出现，因此它不能为 null。这就是为什么 FutureProvider 有一个必需的参数<strong class="kx io">“initial data”</strong>，这是一个小部件可以使用的初始值，直到它获得正确的提供值。一旦数据准备就绪，FutureProvider 就与后代小部件通信，以重新构建并使用新值。</p><h1 id="5491" class="mg mh in bd mi mj ne ml mm mn nf mp mq jt ng ju ms jw nh jx mu jz ni ka mw mx bi translated">入门指南</h1><blockquote class="no np nq"><p id="8869" class="kv kw lr kx b ky kz jo la lb lc jr ld nr lf lg lh ns lj lk ll nt ln lo lp lq ig bi translated">从一个普通的计数器例子开始。</p></blockquote><p id="12ed" class="pw-post-body-paragraph kv kw in kx b ky kz jo la lb lc jr ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">首先创建一个新项目，并将这一行添加到您的<code class="fe nk nl nm nn b">pubspec.yaml</code>文件中的 dependencies 块:<a class="ae nj" href="https://pub.dev/packages/provider" rel="noopener ugc nofollow" target="_blank"> <strong class="kx io"> provider </strong> </a></p><pre class="kd ke kf kg gt nv nn nw nx aw ny bi"><span id="af09" class="nz mh in nn b gy oa ob l oc od">dependencies:<br/> provider: <strong class="nn io"><em class="lr">Letest dependencies</em></strong></span></pre><blockquote class="no np nq"><p id="f2a8" class="kv kw lr kx b ky kz jo la lb lc jr ld nr lf lg lh ns lj lk ll nt ln lo lp lq ig bi translated">运行<code class="fe nk nl nm nn b">pub get</code>命令获得包的本地副本:</p></blockquote><pre class="kd ke kf kg gt nv nn nw nx aw ny bi"><span id="0e92" class="nz mh in nn b gy oa ob l oc od">flutter pub get</span></pre><blockquote class="no np nq"><p id="9155" class="kv kw lr kx b ky kz jo la lb lc jr ld nr lf lg lh ns lj lk ll nt ln lo lp lq ig bi translated">创建一个扩展“<em class="in">change notifier”</em>的提供者类</p></blockquote><pre class="kd ke kf kg gt nv nn nw nx aw ny bi"><span id="d07a" class="nz mh in nn b gy oa ob l oc od">class CounterProvider(Your Class Name) extends ChangeNotifier {}</span></pre><blockquote class="no np nq"><p id="383a" class="kv kw lr kx b ky kz jo la lb lc jr ld nr lf lg lh ns lj lk ll nt ln lo lp lq ig bi translated">为代码添加逻辑</p></blockquote><pre class="kd ke kf kg gt nv nn nw nx aw ny bi"><span id="c64c" class="nz mh in nn b gy oa ob l oc od">class CounterProvider(Your Class Name) extends ChangeNotifier {</span><span id="da17" class="nz mh in nn b gy oe ob l oc od">int _count = 0;</span><span id="0d7b" class="nz mh in nn b gy oe ob l oc od">int get <em class="lr">getCountValue</em> =&gt; _count;</span><span id="394d" class="nz mh in nn b gy oe ob l oc od">//for Increment counter</span><span id="01ae" class="nz mh in nn b gy oe ob l oc od">void <em class="lr">incrementCounter</em>() {</span><span id="8c96" class="nz mh in nn b gy oe ob l oc od">     _count++;</span><span id="a8cf" class="nz mh in nn b gy oe ob l oc od"><em class="lr">     notifyListeners</em>();</span><span id="d67e" class="nz mh in nn b gy oe ob l oc od">  }</span><span id="acc6" class="nz mh in nn b gy oe ob l oc od">//for Decrement counter</span><span id="fac1" class="nz mh in nn b gy oe ob l oc od">void <em class="lr">decrementCounter</em>() {</span><span id="3ca4" class="nz mh in nn b gy oe ob l oc od">    _count--;</span><span id="442d" class="nz mh in nn b gy oe ob l oc od"><em class="lr">    notifyListeners</em>();</span><span id="f266" class="nz mh in nn b gy oe ob l oc od">}</span><span id="b643" class="nz mh in nn b gy oe ob l oc od">//for reset counter</span><span id="173f" class="nz mh in nn b gy oe ob l oc od">void <em class="lr">resetCounter</em>() {</span><span id="e8c5" class="nz mh in nn b gy oe ob l oc od">    _count = 0;</span><span id="cdc2" class="nz mh in nn b gy oe ob l oc od"><em class="lr">    notifyListeners</em>();</span><span id="4244" class="nz mh in nn b gy oe ob l oc od"> }</span><span id="adf7" class="nz mh in nn b gy oe ob l oc od">}</span></pre><p id="1ad5" class="pw-post-body-paragraph kv kw in kx b ky kz jo la lb lc jr ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated"><strong class="kx io"><em class="lr">notify listeners 在 Flutter 中做什么？</em> </strong></p><p id="8c26" class="pw-post-body-paragraph kv kw in kx b ky kz jo la lb lc jr ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">notifyListeners 方法空安全</p><p id="26df" class="pw-post-body-paragraph kv kw in kx b ky kz jo la lb lc jr ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">每当对象改变时调用这个方法，<strong class="kx io">通知任何客户端对象可能已经改变</strong>。在此迭代过程中添加的侦听器将不会被访问。在此迭代中移除的侦听器在被移除后将不会被访问。</p><blockquote class="no np nq"><p id="0c62" class="kv kw lr kx b ky kz jo la lb lc jr ld nr lf lg lh ns lj lk ll nt ln lo lp lq ig bi translated">将提供者添加到<strong class="kx io"> <em class="in"> main.dart </em> </strong>文件中</p></blockquote><pre class="kd ke kf kg gt nv nn nw nx aw ny bi"><span id="a3ae" class="nz mh in nn b gy oa ob l oc od">void <em class="lr">main</em>() {</span><span id="2711" class="nz mh in nn b gy oe ob l oc od"><em class="lr">runApp</em>(</span><span id="c736" class="nz mh in nn b gy oe ob l oc od">MultiProvider(</span><span id="7e21" class="nz mh in nn b gy oe ob l oc od"> providers: [</span><span id="c015" class="nz mh in nn b gy oe ob l oc od">  ChangeNotifierProvider(</span><span id="3023" class="nz mh in nn b gy oe ob l oc od">    create: (context) =&gt; CounterProvider(),</span><span id="9caa" class="nz mh in nn b gy oe ob l oc od">  ),</span><span id="d235" class="nz mh in nn b gy oe ob l oc od">  ChangeNotifierProvider(</span><span id="8c0b" class="nz mh in nn b gy oe ob l oc od">    create: (context) =&gt; TimerInfo(),</span><span id="a763" class="nz mh in nn b gy oe ob l oc od">  ),</span><span id="19b1" class="nz mh in nn b gy oe ob l oc od">  ChangeNotifierProvider(</span><span id="ed27" class="nz mh in nn b gy oe ob l oc od">    create: (context) =&gt; SalaryProvider(),</span><span id="80d2" class="nz mh in nn b gy oe ob l oc od">  ),</span><span id="962e" class="nz mh in nn b gy oe ob l oc od">  ChangeNotifierProvider(</span><span id="bd3e" class="nz mh in nn b gy oe ob l oc od">    create: (context) =&gt; ThemeProvider(),</span><span id="1280" class="nz mh in nn b gy oe ob l oc od">  ),</span><span id="5486" class="nz mh in nn b gy oe ob l oc od">  ChangeNotifierProvider(</span><span id="397b" class="nz mh in nn b gy oe ob l oc od">    create: (context) =&gt; ItemProvider(),</span><span id="af56" class="nz mh in nn b gy oe ob l oc od">  ),</span><span id="1921" class="nz mh in nn b gy oe ob l oc od"> ],</span><span id="5ebf" class="nz mh in nn b gy oe ob l oc od">    child: MyApp(),</span><span id="a3b0" class="nz mh in nn b gy oe ob l oc od">   ),</span><span id="ddf9" class="nz mh in nn b gy oe ob l oc od"> );</span><span id="c201" class="nz mh in nn b gy oe ob l oc od">}</span></pre><blockquote class="no np nq"><p id="2f24" class="kv kw lr kx b ky kz jo la lb lc jr ld nr lf lg lh ns lj lk ll nt ln lo lp lq ig bi translated">从提供程序类获取数据。</p></blockquote><pre class="kd ke kf kg gt nv nn nw nx aw ny bi"><span id="8dc7" class="nz mh in nn b gy oa ob l oc od">class CounterScreen extends StatefulWidget {</span><span id="407e" class="nz mh in nn b gy oe ob l oc od"><em class="lr">const</em> CounterScreen({Key? key}) : super(key: key);</span><span id="f387" class="nz mh in nn b gy oe ob l oc od">@override</span><span id="8e96" class="nz mh in nn b gy oe ob l oc od">_CounterScreenState <em class="lr">createState</em>() =&gt; _CounterScreenState();</span><span id="457f" class="nz mh in nn b gy oe ob l oc od">}</span><span id="7362" class="nz mh in nn b gy oe ob l oc od">class _CounterScreenState extends State&lt;CounterScreen&gt; {</span><span id="3f78" class="nz mh in nn b gy oe ob l oc od">@override</span><span id="bce5" class="nz mh in nn b gy oe ob l oc od">Widget <em class="lr">build</em>(BuildContext context) {</span><span id="97d3" class="nz mh in nn b gy oe ob l oc od"><em class="lr"> return</em> Scaffold(</span><span id="63f3" class="nz mh in nn b gy oe ob l oc od">  appBar: AppBar(),</span><span id="bdb8" class="nz mh in nn b gy oe ob l oc od">  body: SafeArea(</span><span id="4bb7" class="nz mh in nn b gy oe ob l oc od">   child: Center(</span><span id="e59e" class="nz mh in nn b gy oe ob l oc od">     child: Column(</span><span id="b31e" class="nz mh in nn b gy oe ob l oc od">        mainAxisAlignment: MainAxisAlignment.center,</span><span id="152e" class="nz mh in nn b gy oe ob l oc od">          children: [</span><span id="cc58" class="nz mh in nn b gy oe ob l oc od">            Consumer&lt;CounterProvider&gt;(</span><span id="76fc" class="nz mh in nn b gy oe ob l oc od">              builder: (context, value, child) {</span><span id="bd81" class="nz mh in nn b gy oe ob l oc od"><em class="lr">                return</em> Text(</span><span id="9200" class="nz mh in nn b gy oe ob l oc od">                  value.getCountValue.<em class="lr">toString</em>(),</span><span id="6798" class="nz mh in nn b gy oe ob l oc od">                  style: TextStyle(fontSize: 30),</span><span id="f3fd" class="nz mh in nn b gy oe ob l oc od">                );</span><span id="a3d3" class="nz mh in nn b gy oe ob l oc od">              },</span><span id="a0c2" class="nz mh in nn b gy oe ob l oc od">           ),</span><span id="5abd" class="nz mh in nn b gy oe ob l oc od">      ],</span><span id="97b5" class="nz mh in nn b gy oe ob l oc od">    ),</span><span id="5969" class="nz mh in nn b gy oe ob l oc od">  ),</span><span id="c068" class="nz mh in nn b gy oe ob l oc od">),</span><span id="46dd" class="nz mh in nn b gy oe ob l oc od">floatingActionButton:  FloatingActionButton(</span><span id="05c7" class="nz mh in nn b gy oe ob l oc od">     onPressed: () {</span><span id="87b2" class="nz mh in nn b gy oe ob l oc od">      context.<em class="lr">read</em>&lt;CounterProvider&gt;().<em class="lr">incrementCounter</em>();</span><span id="1a3c" class="nz mh in nn b gy oe ob l oc od">       },</span><span id="f066" class="nz mh in nn b gy oe ob l oc od">      child: Icon(Icons.add),</span><span id="c84e" class="nz mh in nn b gy oe ob l oc od">     ), </span><span id="8a24" class="nz mh in nn b gy oe ob l oc od">   );</span><span id="dca6" class="nz mh in nn b gy oe ob l oc od"> }</span><span id="7a06" class="nz mh in nn b gy oe ob l oc od">}</span></pre><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi of"><img src="../Images/a0eab6665e03741aaf2e81437b16d8a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:574/format:webp/1*rlPVcxSj9Yd1IAr1HzvE8g.png"/></div></figure><h2 id="6f9d" class="nz mh in bd mi og oh dn mm oi oj dp mq le ok ol ms li om on mu lm oo op mw oq bi translated">从 GitHub repo 获取源代码:<a class="ae nj" href="https://github.com/inamhusain/flutter_provider_example.git" rel="noopener ugc nofollow" target="_blank">源代码</a></h2><p id="0d6b" class="pw-post-body-paragraph kv kw in kx b ky my jo la lb mz jr ld le na lg lh li nb lk ll lm nc lo lp lq ig bi translated">点击查看<a class="ae nj" href="https://pub.dev/packages/provider" rel="noopener ugc nofollow" target="_blank">更多更新</a>。</p></div></div>    
</body>
</html>