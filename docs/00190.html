<html>
<head>
<title>How to Make a Custom LinkedList?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何制作自定义LinkedList？</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-to-make-a-custom-linkedlist-3deee9d5d9e4?source=collection_archive---------0-----------------------#2020-05-01">https://blog.devgenius.io/how-to-make-a-custom-linkedlist-3deee9d5d9e4?source=collection_archive---------0-----------------------#2020-05-01</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/0cd48defabc4f0311e788577fcd605c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cS6lfvXUS6hqbK1kGkbewg.png"/></div></div></figure><p id="3155" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">数据结构被认为是你作为软件开发人员编写的每个程序的核心，也是你每次技术面试的主要部分。在这篇文章中，我们将讨论最常见的数据结构，链表，它与普通数组的速度比较，并创建您自己的自定义链表，以便更好地理解它的工作。</p><p id="72f9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">一些背景检查:让我们来谈谈它是什么，它的性能比普通数组好在哪里。</strong></p><p id="0d73" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">要回答这个问题，我们必须知道它看起来像什么，链表与数组非常相似，唯一的区别是元素不是存储在连续的内存块中，它们可以出现在计算机内存中的任何随机位置。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div class="gh gi kt"><img src="../Images/0171a1de9964b44ae1a5910a0b459162.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*y3yvHQKcIuXUxKYwyyfIsw.png"/></div></figure><p id="6bb3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">元素可以存储在内存中的任何地方，为了遍历列表，我们需要每个条目(称为节点)的地址。</p><p id="0895" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个地址与实际数据(整数、字符串或任何您想要的东西)一起存储在每个节点中。链表中的每个节点都有一个指向下一个节点的地址(在双向链表中也有一个指向上一个节点的地址)。</p><p id="308a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">那么，怎么比正常列表好呢？</p><p id="cd99" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这取决于你的程序做得最多的是什么，是列表修改优先于你，还是从列表中检索数据优先于你。</p><ol class=""><li id="b51b" class="ky kz in jx b jy jz kc kd kg la kk lb ko lc ks ld le lf lg bi translated">如果您的程序经常从列表中检索数据，那么您可以使用普通数组。我们知道项目的索引，使用索引从数组中获取数据通常比在链表中更快。O(1)如果你在java中使用数组列表。(恒定的时间复杂度，这是最好的)。<br/>链表就不一样了，因为在这种情况下你不知道条目的索引，你必须从头开始遍历，直到找到你要找的条目。(O(n)，如果项目在列表的最后，这是最坏的情况)。</li><li id="18f6" class="ky kz in jx b jy lh kc li kg lj kk lk ko ll ks ld le lf lg bi translated">如果你的程序更侧重于列表修改，链表是你正确的选择。<br/>linked list的操作比ArrayList的操作<strong class="jx io">快</strong>，因为它使用双向链表，所以在内存中不需要移位。</li></ol></div><div class="ab cl lm ln hr lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="ig ih ii ij ik"><h1 id="285c" class="lt lu in bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">如何创建自己的链表？</h1><p id="58a1" class="pw-post-body-paragraph jv jw in jx b jy mr ka kb kc ms ke kf kg mt ki kj kk mu km kn ko mv kq kr ks ig bi translated">在这里找到源代码:<a class="ae mw" href="https://github.com/yudi43/Data-Structures-Implementations/tree/master/LinkedList-Implementation/src" rel="noopener ugc nofollow" target="_blank">https://github . com/yudi 43/Data-Structures-Implementations/tree/master/linked list-Implementation/src</a></p><p id="6b06" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们专注于创建一个单链表，以便更清楚地了解它是如何工作的以及它是什么。我在这里使用Java来实现它，但是你可以在你选择的语言中应用相同的概念。</p><p id="42e1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们制作的链表将具有以下功能:</p><ul class=""><li id="c1f5" class="ky kz in jx b jy jz kc kd kg la kk lb ko lc ks mx le lf lg bi translated">向列表中添加元素。</li><li id="1540" class="ky kz in jx b jy lh kc li kg lj kk lk ko ll ks mx le lf lg bi translated">在列表开头添加元素。</li><li id="dae3" class="ky kz in jx b jy lh kc li kg lj kk lk ko ll ks mx le lf lg bi translated">在列表的某个特定索引处添加元素。</li><li id="bfcd" class="ky kz in jx b jy lh kc li kg lj kk lk ko ll ks mx le lf lg bi translated">从特定索引中删除元素。</li><li id="621a" class="ky kz in jx b jy lh kc li kg lj kk lk ko ll ks mx le lf lg bi translated">显示列表。</li></ul><p id="394a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在整篇文章中，请记住链表是一个节点列表，一个节点包含下一个元素的<strong class="jx io">数据</strong>和<strong class="jx io">地址</strong>。</p><p id="755e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">注意:因为我们在这里使用的是java，所以地址不是指针，而只是对另一个节点对象的引用。</p><p id="1462" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们将需要三个基本类来实现和测试我们的自定义链表。</p><ul class=""><li id="d7f6" class="ky kz in jx b jy jz kc kd kg la kk lb ko lc ks mx le lf lg bi translated">Runner类:它包含了我们将要测试我们编写的代码的main方法。</li><li id="b58b" class="ky kz in jx b jy lh kc li kg lj kk lk ko ll ks mx le lf lg bi translated">CustomLinkedList类:实际的链表类，你在这里的原因。</li><li id="3eeb" class="ky kz in jx b jy lh kc li kg lj kk lk ko ll ks mx le lf lg bi translated">节点类:基本项目，基本上是我们一直在处理/操作的东西。</li></ul><h2 id="f77e" class="my lu in bd lv mz na dn lz nb nc dp md kg nd ne mh kk nf ng ml ko nh ni mp nj bi translated">跑步者类别:</h2><p id="5e3b" class="pw-post-body-paragraph jv jw in jx b jy mr ka kb kc ms ke kf kg mt ki kj kk mu km kn ko mv kq kr ks ig bi translated">Runner类只不过是一个保存主要函数的类，如下所示:</p><pre class="ku kv kw kx gt nk nl nm nn aw no bi"><span id="b722" class="my lu in nl b gy np nq l nr ns"><strong class="nl io">public class Runner {<br/>    public static void main(String[] args) {<br/>        CustomLinkedList list = new CustomLinkedList();<br/>    <br/>        //Below are some examples of what we will be doing here... </strong></span><span id="2ac1" class="my lu in nl b gy nt nq l nr ns"><strong class="nl io">        list.insert(12);<br/>        list.insert(43);<br/>        list.insertAtStart(191);<br/>        list.insertAt(2, 2222);<br/>        list.deleteAt(2);<br/>        list.show();<br/>    }<br/>}</strong></span></pre><h2 id="ca3c" class="my lu in bd lv mz na dn lz nb nc dp md kg nd ne mh kk nf ng ml ko nh ni mp nj bi translated">节点类:</h2><p id="c483" class="pw-post-body-paragraph jv jw in jx b jy mr ka kb kc ms ke kf kg mt ki kj kk mu km kn ko mv kq kr ks ig bi translated">如前所述，节点对象保存两样东西，数据本身和下一个节点的地址。(它只不过是另一个节点对象)，如下所示:</p><pre class="ku kv kw kx gt nk nl nm nn aw no bi"><span id="a953" class="my lu in nl b gy np nq l nr ns"><strong class="nl io">public class Node {<br/>    int data; //Data in the current node<br/>    Node next; //Reference for the next node<br/><br/>    //Constructor which takes an int value which is stored as the    data in this Node object.<br/>    Node(int data) {<br/>        this.data = data;<br/>    }<br/>}</strong></span></pre><h2 id="7746" class="my lu in bd lv mz na dn lz nb nc dp md kg nd ne mh kk nf ng ml ko nh ni mp nj bi translated">CustomLinkedList类:</h2><p id="2da2" class="pw-post-body-paragraph jv jw in jx b jy mr ka kb kc ms ke kf kg mt ki kj kk mu km kn ko mv kq kr ks ig bi translated">这个类的对象只包含一个名为“head”的实例变量，这是链表中的第一项。使用这个头，我们可以遍历整个列表，因为每个下一项都有一个指向它的下一项的地址，最后一项的下一项是null。</p><p id="4dd6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个类的基本结构如下所示:</p><pre class="ku kv kw kx gt nk nl nm nn aw no bi"><span id="0770" class="my lu in nl b gy np nq l nr ns"><strong class="nl io">public class CustomLinkedList {<br/>    Node head;<br/>}</strong></span></pre><p id="1a8f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">它里面会有很多函数，我们会一个一个的讨论。</p><p id="69d7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">插入(int数据)；(</strong>向列表添加元素<strong class="jx io"> ) </strong> <br/>如何处理:我们需要在列表的末尾添加一个元素，除了列表为空的情况。我们遍历列表直到结束(直到我们在某个节点中发现null作为地址),并将其地址设置为我们想要添加的新节点。该函数如下所示:</p><pre class="ku kv kw kx gt nk nl nm nn aw no bi"><span id="d384" class="my lu in nl b gy np nq l nr ns"><strong class="nl io">public void insert(int data) {<br/>    Node newNode = new Node(data);<br/>    if(head == null) {<br/>        head = newNode;<br/>    }else {<br/>        Node currentNode = head;<br/>        while(currentNode.next != null) {<br/>            currentNode= currentNode.next;<br/>        }<br/>        currentNode.next = newNode;<br/>    }<br/>}</strong></span></pre></div><div class="ab cl lm ln hr lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="ig ih ii ij ik"><p id="1420" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">insertAtStart(int data)；(</strong>在列表开始处添加元素<strong class="jx io"> ) </strong></p><p id="576a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如何处理:这里我们只需要处理一种情况，即新节点成为链表的头。我们可以这样做:</p><pre class="ku kv kw kx gt nk nl nm nn aw no bi"><span id="5657" class="my lu in nl b gy np nq l nr ns"><strong class="nl io">public void insertAtStart(int data) {<br/>    Node newNode = new Node(data);<br/><br/>    newNode.next = head;<br/>    head = newNode;<br/>}</strong></span></pre><p id="9d08" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们将头节点设置为新节点的下一个节点，并将新节点设置为新头节点。</p></div><div class="ab cl lm ln hr lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="ig ih ii ij ik"><p id="7325" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">insertAt(int index)；(</strong>在列表的某个特定索引处添加元素<strong class="jx io"> ) </strong></p><p id="a611" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如何处理:这样想，如果你想把一个元素放在索引1，新元素将出现在索引0和索引1的元素之间。(索引0处的项目将停留在索引0处，而索引1处的项目将移动到索引2，以便为新元素腾出空间)。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/c3373aab4afe83cb4c53b7552eee8461.png" data-original-src="https://miro.medium.com/v2/resize:fit:566/format:webp/1*bxMpEevHsYZ9i1ojAp9j4Q.png"/></div></figure><p id="1362" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，我们需要遍历列表，直到到达index-1位置的元素，因为新的项目将紧随其后。到达这个位置后，我们将该元素的next属性设置为新节点，并将新节点的next属性设置为index，well，index(给定输入)处的项。下面的函数将使它变得清晰。</p><pre class="ku kv kw kx gt nk nl nm nn aw no bi"><span id="df9f" class="my lu in nl b gy np nq l nr ns"><strong class="nl io">public void insertAt(int index, int data) {<br/>    if(index == 0){<br/>        insertAtStart(data); //We already have a function to do this.<br/>    }else{<br/>        Node newNode = new Node(data);<br/><br/>        Node </strong>currentNode <strong class="nl io">= head;<br/>        for(int </strong>i <strong class="nl io">= 0; </strong>i <strong class="nl io">&lt; index - 1; </strong>i<strong class="nl io">++) {<br/>            </strong>currentNode <strong class="nl io">= </strong>currentNode<strong class="nl io">.next;<br/>        }<br/>        newNode.next = </strong>currentNode<strong class="nl io">.next;<br/>        </strong>currentNode<strong class="nl io">.next = newNode;<br/>    }<br/>}</strong></span></pre></div><div class="ab cl lm ln hr lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="ig ih ii ij ik"><p id="aa2f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">delete at(int index)；</strong>从特定索引中删除元素。</p><figure class="ku kv kw kx gt jo gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/a0e6ff0eae1bc49759da234124f3843d.png" data-original-src="https://miro.medium.com/v2/resize:fit:608/format:webp/1*TOIpD7x-Ikf2rcyQnd3gyQ.jpeg"/></div></figure><p id="9081" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如何处理:要删除某个给定索引处的元素，我们需要转到index-1位置，并将该节点的next设置为给定索引上的下一个元素。通过这样做，我们可以绕过图中所示的地址，并且该索引处的项目符合垃圾收集的条件，下面的函数可以做到这一点:</p><pre class="ku kv kw kx gt nk nl nm nn aw no bi"><span id="48a7" class="my lu in nl b gy np nq l nr ns"><strong class="nl io">public void deleteAt(int index) {<br/>    if(index == 0) {<br/>        head = head.next;<br/>    }else{<br/>        Node </strong>currentNode <strong class="nl io">= head;<br/>        for(int </strong>i <strong class="nl io">= 0; </strong>i <strong class="nl io">&lt; index - 1; </strong>i<strong class="nl io">++) {<br/>            </strong>currentNode <strong class="nl io">= </strong>currentNode<strong class="nl io">.next;<br/>        }<br/>        </strong>currentNode<strong class="nl io">.next = </strong>currentNode<strong class="nl io">.next.next;<br/>    }<br/>}</strong></span></pre></div><div class="ab cl lm ln hr lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="ig ih ii ij ik"><p id="0114" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">秀()；</strong>显示列表:</p><p id="d707" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后，一个功能来测试我们做了什么，如果它的工作！</p><p id="e2e0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们只是遍历列表并打印里面的每个元素。</p><pre class="ku kv kw kx gt nk nl nm nn aw no bi"><span id="5c9f" class="my lu in nl b gy np nq l nr ns"><strong class="nl io">public void show() {<br/>    Node </strong>currentNode <strong class="nl io">= head;<br/>    if(</strong>currentNode <strong class="nl io">== null){<br/>        System.<em class="nw">out</em>.println("Linked list is empty");<br/>    }<br/>    else {<br/>        while(</strong>currentNode <strong class="nl io">!= null) {<br/>            System.<em class="nw">out</em>.print(</strong>currentNode<strong class="nl io">.</strong>data <strong class="nl io">+ " ");<br/>            </strong>currentNode <strong class="nl io">= </strong>currentNode<strong class="nl io">.next;<br/>        }<br/>    }<br/>}</strong></span></pre></div><div class="ab cl lm ln hr lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="ig ih ii ij ik"><h2 id="a3ba" class="my lu in bd lv mz na dn lz nb nc dp md kg nd ne mh kk nf ng ml ko nh ni mp nj bi translated">现在，让我们做一些测试！</h2><p id="ec03" class="pw-post-body-paragraph jv jw in jx b jy mr ka kb kc ms ke kf kg mt ki kj kk mu km kn ko mv kq kr ks ig bi translated">转到Runner类中的main方法，用我们刚刚做的东西玩一玩。</p><p id="c692" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下面是示例测试，控制台输出在函数调用旁边的注释中。</p><pre class="ku kv kw kx gt nk nl nm nn aw no bi"><span id="3ea8" class="my lu in nl b gy np nq l nr ns"><strong class="nl io">public class Runner {<br/>    public static void main(String[] args) {<br/>        CustomLinkedList list = new CustomLinkedList();<br/>        list.insert(12); //12<br/>        list.insert(43); //12 43<br/>        list.insertAtStart(191); //191 12 43<br/>        list.insertAt(2, 2222); //191 12 2222 43<br/>        list.deleteAt(2); //191 12 43<br/>        list.show();<br/>    }<br/>}</strong></span></pre><p id="8a48" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">恭喜，你刚刚做了一个链表。现在你已经准备好回答技术招聘人员最常问的问题，“你能给我做一个链表吗？”</p><p id="47e5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这里找到源代码:<a class="ae mw" href="https://github.com/yudi43/Data-Structures-Implementations/tree/master/LinkedList-Implementation/src" rel="noopener ugc nofollow" target="_blank">https://github . com/yudi 43/Data-Structures-Implementations/tree/master/linked list-Implementation/src</a></p><p id="8294" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">觉得有用？分享，按下拍手按钮。</p><p id="dead" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">别忘了你可以按那个按钮50次。</p><p id="72b0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">谢谢你，祝你愉快。编码快乐！</p></div></div>    
</body>
</html>