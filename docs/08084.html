<html>
<head>
<title>Kafka on Kubernetes: Using Strimzi — Part 5 (Security)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">库伯内特斯上的卡夫卡:使用斯特里姆齐——第五部分(安全)</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/kafka-on-kubernetes-using-strimzi-part-5-security-fc878178cd04?source=collection_archive---------4-----------------------#2022-05-16">https://blog.devgenius.io/kafka-on-kubernetes-using-strimzi-part-5-security-fc878178cd04?source=collection_archive---------4-----------------------#2022-05-16</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div class="gh gi jk"><img src="../Images/2d576b55db0a6fe6231220efbde8cffa.png" data-original-src="https://miro.medium.com/v2/resize:fit:930/format:webp/1*lVgF8q-hoYg993YLLOotCg.png"/></div><figcaption class="jr js gj gh gi jt ju bd b be z dk translated">来源—<a class="ae jv" href="http://joyreactor.com/post/4708653" rel="noopener ugc nofollow" target="_blank">http://joyreactor.com/post/4708653</a></figcaption></figure><p id="7605" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">欢迎来到这个系列的第五部分，<strong class="jy io">库伯内特斯上的卡夫卡:使用</strong> <a class="ae jv" href="https://strimzi.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jy io"> Strimzi </strong> </a> <strong class="jy io">。</strong>到目前为止，我们已经在<a class="ae jv" href="https://medium.com/@singh.amarendra/kafka-on-kubernetes-using-strimzi-part-1-83d74564135e" rel="noopener">第 1 部分</a>中看到了 Strimzi 基础知识，在<a class="ae jv" href="https://medium.com/@singh.amarendra/kafka-on-kubernetes-using-strimzi-part-2-71a8ba8e9605" rel="noopener">第 2 部分</a>中使用 Strimzi 在 Kubernetes 上创建了 Kafka 集群设置，在<a class="ae jv" href="https://medium.com/@singh.amarendra/kafka-on-kubernetes-using-strimzi-part-3-configuration-options-f8aa027e9ba0" rel="noopener">第 3 部分</a>中讨论了在集群生产就绪时的重要配置和建议。在<a class="ae jv" href="https://medium.com/@singh.amarendra/kafka-on-kubernetes-using-strimzi-part-4-scalability-59da50575fec" rel="noopener">上一节</a>中，我们已经了解了如何使用 KEDA 轻松扩展消费者。</p><p id="417c" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">在本节中，我们将讨论一个非常重要的方面- <a class="ae jv" href="https://en.wikipedia.org/wiki/Security" rel="noopener ugc nofollow" target="_blank">安全性</a>。由于 Kafka 是一个流媒体平台，我们处理大量数据，这些数据本质上也可能是敏感的，因此这变得非常重要。</p><figure class="kv kw kx ky gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi ku"><img src="../Images/681f21cda6bff054dd7a8e5993c3492c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aDX_nbe9OMzqYOdJRuPFKw.png"/></div></div><figcaption class="jr js gj gh gi jt ju bd b be z dk translated">来源— <a class="ae jv" href="https://fastnforward.blog/introduction-to-kafka-security/" rel="noopener ugc nofollow" target="_blank"> fastnforward.blog </a></figcaption></figure><p id="b4bb" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">概括地说，任何应用程序/平台/系统的安全性都可以通过以下三个方面来验证</p><ul class=""><li id="340a" class="ld le in jy b jz ka kd ke kh lf kl lg kp lh kt li lj lk ll bi translated"><a class="ae jv" href="https://www.investopedia.com/terms/e/encryption.asp#:~:text=Encryption%20is%20a%20means%20of,makes%20the%20original%20information%20unreadable." rel="noopener ugc nofollow" target="_blank"> <strong class="jy io">加密</strong> </a> —数据是在交换过程中加密还是在静止状态下加密</li><li id="c7ab" class="ld le in jy b jz lm kd ln kh lo kl lp kp lq kt li lj lk ll bi translated"><a class="ae jv" href="https://en.wikipedia.org/wiki/Authentication" rel="noopener ugc nofollow" target="_blank"> <strong class="jy io">认证</strong> </a> —是否只允许通过认证的用户进入系统</li><li id="661b" class="ld le in jy b jz lm kd ln kh lo kl lp kp lq kt li lj lk ll bi translated"><a class="ae jv" href="https://en.wikipedia.org/wiki/Authorization" rel="noopener ugc nofollow" target="_blank"> <strong class="jy io">授权</strong></a>——只有授权用户才能访问应用程序/系统的不同部分</li></ul><p id="6d4f" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">如果以上所有方面都符合安全标准，我们可以说我们的平台是安全的。但事情并没有就此结束，安全性是任何系统的关键要求，我们应该定期重新审视安全标准/策略。</p><p id="6ab9" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">现在让我们看看 Strimzi 提供了哪些选项来保护 Kubernetes 上的 Kafka 集群</p><p id="9097" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi lr translated"><span class="l ls lt lu bm lv lw lx ly lz di">E</span><strong class="jy io">ncryption:</strong>strim zi 支持<a class="ae jv" href="https://en.wikipedia.org/wiki/Transport_Layer_Security" rel="noopener ugc nofollow" target="_blank">传输层安全(TLS) </a>，一种加密通信的协议。</p><p id="606e" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">对于以下之间的通信，通信总是加密的:</p><ul class=""><li id="0326" class="ld le in jy b jz ka kd ke kh lf kl lg kp lh kt li lj lk ll bi translated">卡夫卡经纪人</li><li id="45a3" class="ld le in jy b jz lm kd ln kh lo kl lp kp lq kt li lj lk ll bi translated">动物园管理员节点</li><li id="dfbe" class="ld le in jy b jz lm kd ln kh lo kl lp kp lq kt li lj lk ll bi translated">运营商和卡夫卡经纪人</li><li id="af46" class="ld le in jy b jz lm kd ln kh lo kl lp kp lq kt li lj lk ll bi translated">操作员和 ZooKeeper 节点</li><li id="998e" class="ld le in jy b jz lm kd ln kh lo kl lp kp lq kt li lj lk ll bi translated">卡夫卡出口商</li></ul><p id="0dc2" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">为了配置客户端和代理之间的安全通信，我们可以设置<a class="ae jv" href="https://en.wikipedia.org/wiki/Transport_Layer_Security" rel="noopener ugc nofollow" target="_blank"> CA(认证中心)</a>。TLS 证书颁发机构(CA)颁发证书来验证组件的身份。Strimzi 根据 CA 证书验证组件的证书。</p><ul class=""><li id="02a9" class="ld le in jy b jz ka kd ke kh lf kl lg kp lh kt li lj lk ll bi translated">Strimzi 组件根据<em class="ma">集群 CA </em>认证中心(CA)进行验证</li><li id="2ee8" class="ld le in jy b jz lm kd ln kh lo kl lp kp lq kt li lj lk ll bi translated">Kafka 客户端根据<em class="ma">客户端 CA </em>认证机构(CA)进行验证</li></ul><p id="372b" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi lr translated"><span class="l ls lt lu bm lv lw lx ly lz di"> A </span> <strong class="jy io">认证:</strong> Kafka 监听器使用认证来确保到 Kafka 集群的安全客户端连接。</p><p id="db12" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">支持的身份验证机制:</p><ul class=""><li id="c605" class="ld le in jy b jz ka kd ke kh lf kl lg kp lh kt li lj lk ll bi translated"><a class="ae jv" href="https://en.wikipedia.org/wiki/Mutual_authentication" rel="noopener ugc nofollow" target="_blank">相互 TLS </a>客户机验证(在启用了 TLS 加密的监听器上)</li><li id="f0e1" class="ld le in jy b jz lm kd ln kh lo kl lp kp lq kt li lj lk ll bi translated"><a class="ae jv" href="https://strimzi.io/docs/0.12.1/#con-scram-sha-authentication-using-uo" rel="noopener ugc nofollow" target="_blank"> SASL 紧急停堆——SHA-512</a></li><li id="21b3" class="ld le in jy b jz lm kd ln kh lo kl lp kp lq kt li lj lk ll bi translated"><a class="ae jv" href="https://strimzi.io/blog/2019/10/25/kafka-authentication-using-oauth-2.0/" rel="noopener ugc nofollow" target="_blank"> OAuth 2.0 基于令牌的认证</a></li><li id="e305" class="ld le in jy b jz lm kd ln kh lo kl lp kp lq kt li lj lk ll bi translated">自定义身份验证</li></ul><p id="f75d" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">User Operator 管理 TLS 和 SCRAM 身份验证的用户凭据，但不管理 OAuth 2.0。例如，通过 User 操作符，您可以创建一个代表需要访问 Kafka 集群的客户端的用户，并将 TLS 指定为身份验证类型。</p><p id="c9ef" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">使用 OAuth 2.0 基于令牌的身份验证，应用程序客户端可以访问 Kafka 代理，而无需暴露帐户凭证。授权服务器处理访问授权和访问查询。</p><p id="300c" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">自定义身份验证允许任何类型的 kafka 支持的身份验证。它可以提供更多的灵活性，但也增加了复杂性。</p><p id="5fce" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">在大多数情况下，相互 TLS 就足够了。在 mutual TLS 中，客户端和服务器的真实性得到验证。下面是我们如何在 Kafka 资源中轻松配置相互 TLS -</p><pre class="kv kw kx ky gt mb mc md me aw mf bi"><span id="7383" class="mg mh in mc b gy mi mj l mk ml">...<br/>spec:<br/>  kafka:<br/>    version: 2.8.0<br/>    replicas: 3<br/>    listeners:<br/>      ...<br/>     <strong class="mc io"> tls:<br/>        authentication:<br/>          type: tls<br/>...</strong></span></pre><p id="e77e" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">当我们部署 Strimzi Kafka 集群并启用身份验证时，它会创建一个<em class="ma">Kafka-cluster-ca-certificate</em>作为 Kubernetes secret。这是可用于验证服务器的群集 CA 证书。</p><p id="4dfd" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi lr translated"><span class="l ls lt lu bm lv lw lx ly lz di"> A </span> <strong class="jy io">授权</strong> : Kafka 集群使用授权来控制特定客户或用户在 Kafka brokers 上被允许的操作。</p><p id="2cc9" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">支持的授权机制:</p><ul class=""><li id="c56f" class="ld le in jy b jz ka kd ke kh lf kl lg kp lh kt li lj lk ll bi translated">简单授权</li><li id="52ae" class="ld le in jy b jz lm kd ln kh lo kl lp kp lq kt li lj lk ll bi translated">OAuth 2.0 授权(如果您使用 OAuth 2.0 基于令牌的身份验证)</li><li id="6d41" class="ld le in jy b jz lm kd ln kh lo kl lp kp lq kt li lj lk ll bi translated"><a class="ae jv" href="https://strimzi.io/blog/2020/08/05/using-open-policy-agent-with-strimzi-and-apache-kafka/" rel="noopener ugc nofollow" target="_blank">开放保单代理(OPA)授权</a></li><li id="b44d" class="ld le in jy b jz lm kd ln kh lo kl lp kp lq kt li lj lk ll bi translated">自定义授权</li></ul><p id="cd39" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">简单授权使用默认的 Kafka 授权插件<strong class="jy io"> AclAuthorizer </strong>。AclAuthorizer 使用访问控制列表(ACL)来定义哪些用户可以访问哪些资源。</p><p id="bbdb" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">下面是我们如何创建一个简单的 Kafka 用户并向其添加所需的权限-</p><pre class="kv kw kx ky gt mb mc md me aw mf bi"><span id="301e" class="mg mh in mc b gy mi mj l mk ml">apiVersion: kafka.strimzi.io/v1beta2<br/>kind: KafkaUser<br/>metadata:<br/>  name: my-user<br/>  labels:<br/>    strimzi.io/cluster: my-cluster<br/>spec:<br/>  authentication:<br/>    type: tls<br/>  <strong class="mc io">authorization:<br/>    type: simple (1)</strong><br/>    acls:<br/>      - resource:<br/>          type: topic <strong class="mc io">(2)</strong><br/>          name: my-topic<br/>          patternType: literal<br/>        operation: Read<br/>      - resource:<br/>          type: topic<br/>          name: my-topic <strong class="mc io">(3)</strong><br/>          patternType: literal<br/>        operation: Describe <strong class="mc io">(4)</strong><br/>      - resource:<br/>          type: group<br/>          name: my-group<br/>          patternType: prefix <strong class="mc io">(5)</strong><br/>        operation: Read</span></pre><ol class=""><li id="1736" class="ld le in jy b jz ka kd ke kh lf kl lg kp lh kt mm lj lk ll bi translated">为 Kafka 集群启用授权</li><li id="7e32" class="ld le in jy b jz lm kd ln kh lo kl lp kp lq kt mm lj lk ll bi translated">为<strong class="jy io">类型=主题</strong>添加 ACL，其他类型有<strong class="jy io">组</strong>、<strong class="jy io">簇</strong>等。</li><li id="f9eb" class="ld le in jy b jz lm kd ln kh lo kl lp kp lq kt mm lj lk ll bi translated">资源的名称，即主题名称、组名称等。</li><li id="6354" class="ld le in jy b jz lm kd ln kh lo kl lp kp lq kt mm lj lk ll bi translated">对资源的允许操作，如读取、写入、描述、创建、更改等。</li><li id="9195" class="ld le in jy b jz lm kd ln kh lo kl lp kp lq kt mm lj lk ll bi translated">资源名称上支持的模式类型。它可能是<strong class="jy io">文字</strong>或<strong class="jy io">前缀</strong>之一</li></ol><p id="d0bc" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">OAuth 2.0 和 OPA 从授权服务器提供基于策略的控制。用于授予 Kafka 代理上的资源访问权限的安全策略和权限在授权服务器中定义。</p><p id="5aec" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">URL 用于连接到授权服务器，并验证允许或拒绝客户端或用户请求的操作。用户和客户端与授权服务器中创建的策略相匹配，这些策略允许用户在 Kafka 代理上执行特定的操作。</p><h1 id="38f8" class="mn mh in bd mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj bi translated"><strong class="ak">访问卡夫卡:</strong></h1><p id="41e5" class="pw-post-body-paragraph jw jx in jy b jz nk kb kc kd nl kf kg kh nm kj kk kl nn kn ko kp no kr ks kt ig bi translated">现在，让我们了解如何限制 Kafka 仅从 Kubernetes 集群访问，以及如果我们希望从集群外部访问它，有哪些选项可用，但在此之前，让我们了解 Kafka 发现协议-</p><figure class="kv kw kx ky gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi np"><img src="../Images/6e4f8aa69c1bbe868aaff79c9198633f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oJorvPNE0sEFDGyN9nzzuw.png"/></div></div><figcaption class="jr js gj gh gi jt ju bd b be z dk translated"><a class="ae jv" href="https://strimzi.io/blog/2019/04/17/accessing-kafka-part-1/" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure><p id="4d8f" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">这是发现协议的工作原理-</p><p id="7fb2" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">1-经过认证的 Kafka 客户端在第一次连接期间连接到任何代理<br/> 2-代理返回所有主题/分区等的元数据。获得所需分区的详细信息后，客户端打开一个到特定代理的新连接。即使客户端需要连接到第一个代理，它也会终止现有的连接(#1)并启动与该代理的新连接。</p><p id="5d30" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">Kubernetes 服务只能用于初始连接——它将把客户端带到集群中的一个代理，在那里它可以获取元数据。但是随后的连接不能通过该服务完成，因为它会将连接随机路由到集群中的一个代理，而不是将它引导到一个特定的代理。Strimzi 是如何处理这个问题的？</p><blockquote class="nq nr ns"><p id="b3cc" class="jw jx ma jy b jz ka kb kc kd ke kf kg nt ki kj kk nu km kn ko nv kq kr ks kt ig bi translated">在代理配置中使用<strong class="jy io"> advertised.listeners </strong>选项，允许客户端直接连接到代理</p></blockquote><h2 id="ec8a" class="mg mh in bd mo nw nx dn ms ny nz dp mw kh oa ob na kl oc od ne kp oe of ni og bi translated"><strong class="ak">从同一个 Kubernetes 集群内部连接:</strong></h2><p id="1103" class="pw-post-body-paragraph jw jx in jy b jz nk kb kc kd nl kf kg kh nm kj kk kl nn kn ko kp no kr ks kt ig bi translated">斯特瑞姆兹用<strong class="jy io">的 statefullset</strong>来管理卡夫卡经纪人。我们可以使用 Kubernetes headless 服务给每个 pod 一个稳定的 DNS 名称。Strimzi 使用这些 DNS 名称作为 Kafka 经纪人的广告地址。对于 Strimzi 来说:</p><ul class=""><li id="39b0" class="ld le in jy b jz ka kd ke kh lf kl lg kp lh kt li lj lk ll bi translated">初始连接是使用常规的 Kubernetes 服务来获取元数据的。</li><li id="a73c" class="ld le in jy b jz lm kd ln kh lo kl lp kp lq kt li lj lk ll bi translated">随后的连接使用由另一个无头 Kubernetes 服务提供给 pod 的 DNS 名称打开。下图显示了一个名为 my-cluster 的 Kafka 集群示例。</li></ul><figure class="kv kw kx ky gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi oh"><img src="../Images/d285efe80c4344b8836de486ee2c01b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7RHemsH11a-XsSSyG2KjAw.png"/></div></div><figcaption class="jr js gj gh gi jt ju bd b be z dk translated"><a class="ae jv" href="https://strimzi.io/blog/2019/04/17/accessing-kafka-part-1/" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure><p id="8616" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">监听器配置客户端如何连接到 Kafka 集群。通过为每个侦听器指定唯一的名称和端口，可以配置多个侦听器。内部侦听器(用于从 Kubernetes 内部访问集群)是使用内部类型指定的。</p><pre class="kv kw kx ky gt mb mc md me aw mf bi"><span id="f2bd" class="mg mh in mc b gy mi mj l mk ml"># ...<br/>listeners:<br/># ...<br/>  - name: tls<br/>    port: 9093<br/>   <strong class="mc io"> type: internal</strong><br/>    tls: true<br/># ...</span></pre><h2 id="64f3" class="mg mh in bd mo nw nx dn ms ny nz dp mw kh oa ob na kl oc od ne kp oe of ni og bi translated">从 Kubernetes 集群外部连接:</h2><p id="3b4a" class="pw-post-body-paragraph jw jx in jy b jz nk kb kc kd nl kf kg kh nm kj kk kl nn kn ko kp no kr ks kt ig bi translated">外部监听器(用于从 Kubernetes 外部访问集群)。还可以为侦听器启用 TLS 加密。</p><p id="5030" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">对于外部类型，type 的值可以是下列值之一:</p><p id="6f0b" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated"><strong class="jy io">路由- </strong>使用 OpenShift 路由和默认 HAProxy 路由器<br/><strong class="jy io">负载平衡器- </strong>使用负载平衡器服务<br/><strong class="jy io">节点端口- </strong>使用 Kubernetes 节点上的端口(外部访问)<br/><strong class="jy io">入口- </strong>使用 Kubernetes 入口和用于 Kubernetes 的 NGINX 入口控制器。</p><p id="ffc6" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">这是我们如何在卡夫卡中配置它-</p><pre class="kv kw kx ky gt mb mc md me aw mf bi"><span id="8e18" class="mg mh in mc b gy mi mj l mk ml"># ...<br/>listeners:<br/># ...<br/>  - name: external<br/>    port: 9094<br/>    type: <strong class="mc io">route/nodeport/loadbalancer/ingress (any one of them)</strong><br/>    tls: true<br/># ...</span></pre><p id="77db" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">下图描述了所需的服务，以及<strong class="jy io">类型=负载平衡器</strong>的通信流程</p><figure class="kv kw kx ky gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi oi"><img src="../Images/b26a5bc0c45c71c9a296259c3ce76a43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*105m3n-LCSuorETSG9Gh0Q.png"/></div></div><figcaption class="jr js gj gh gi jt ju bd b be z dk translated"><a class="ae jv" href="https://strimzi.io/blog/2019/05/13/accessing-kafka-part-4/" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure><p id="ff3b" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated"><strong class="jy io">结论:</strong>在本节中，我们探讨了 Strimzi 提供的保护 Kafka 集群和通信的各种选项。我们已经了解了如何将访问限制在集群内部(如果只有内部服务在访问 Kafka，这将是一个典型的用例),或者我们如何安全地将其扩展到外部访问。Strimzi 提供了一些保护这些东西的标准方法，还提供了添加定制安全设置的方法。</p><p id="582c" class="pw-post-body-paragraph jw jx in jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ig bi translated">在本系列的下一节，也是最后一节，我们将讨论一个重要的话题——监控。</p></div></div>    
</body>
</html>