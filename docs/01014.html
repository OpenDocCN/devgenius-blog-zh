<html>
<head>
<title>Monorepo Learnings</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Monorepo 学习</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/monorepo-learnings-dbd2a83d5279?source=collection_archive---------2-----------------------#2020-06-22">https://blog.devgenius.io/monorepo-learnings-dbd2a83d5279?source=collection_archive---------2-----------------------#2020-06-22</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="cb0e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ki">从 monorepo 风格代码库中获得的经验教训</em></p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi kj"><img src="../Images/ac72612a9f2fe1ca37841b38909afbe2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/1*r5VzKS7gQibR_qodANsZrg.jpeg"/></div></figure><p id="1ae7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我总是对作为组织代码库的一种方式的<strong class="jm io"> monorepo </strong>感兴趣。众所周知，谷歌、脸书、Twitter 或 Dropbox 等互联网巨头将它们的全部代码存储在一个存储库中。如果他们这样做了，那就一定是正确的，对吗？六个月前，我得到了一份工作，公司的大部分代码都存放在一个存储库中，我也有机会亲自体验一下。</p><h1 id="ef2a" class="kr ks in bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">什么是 monorepo？</h1><p id="366c" class="pw-post-body-paragraph jk jl in jm b jn lp jp jq jr lq jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh ig bi translated">Monorepo(或 monolithic repository)是一种在单个代码树中存储两个或更多独立或松散耦合的应用程序或服务的源代码的方法。这是常见的多回购方法的替代方法，在多回购方法中，每个项目都位于一个单独的代码库中。</p><p id="4adc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Monorepo 是一个被广泛讨论，但多少有些争议的话题。它有强烈的支持者和激烈的敌人。我花了一段时间来决定我是喜欢还是讨厌它。由于我倾向于<strong class="jm io"> DevOps </strong>，我花了一点时间在 monorepo 工具上。它帮助我明确了我的理解并做了一些观察。</p><h1 id="c399" class="kr ks in bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">为什么是 monorepo？</h1><p id="1c28" class="pw-post-body-paragraph jk jl in jm b jn lp jp jq jr lq jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh ig bi translated">将所有源代码放在一个位置会带来一系列潜在的好处:</p><p id="7d4b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">代码共享和协作</strong></p><p id="3416" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">每个人都看得到所有东西，一个团队可以贡献给另一个团队的代码。它消除了团队和项目之间的人为界限。</p><p id="3c26" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">大规模重构</strong></p><p id="e10b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">将所有的代码放在一个地方使得代码的逐步重构和重组变得更加简单。没有隐藏的依赖关系，一旦重构完成，系统将继续运行。此外，多个项目可以自动更改。</p><p id="b033" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">第一方依赖管理</strong></p><p id="d988" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对基本库和共享代码的更改会立即通过依赖链传播。无需派生代码或支持多个版本。</p><p id="8d86" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">第三方依赖管理</strong></p><p id="bf95" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当你需要解决一个库的问题时。一个安全漏洞，很容易找到它的所有事件并进行同步升级。此外，monorepos 自然会导致人们将第三方依赖的版本数量最小化为一个。</p><p id="790f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">统一代码访问</strong></p><p id="2f10" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Linters、CVE 扫描器和其他源代码报告工具可以一劳永逸地应用。</p><p id="9a14" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">共享测试策略</strong></p><p id="cc0d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一起测试多个组件更容易，因为不需要从不同的存储库中提取源代码或工件。</p><h1 id="0d6e" class="kr ks in bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">Monorepo 陷阱</h1><p id="82f1" class="pw-post-body-paragraph jk jl in jm b jn lp jp jq jr lq jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh ig bi translated">好处不是免费的。有权衡，有风险。</p><h1 id="353e" class="kr ks in bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">Monorepo 并不意味着单一管道</h1><p id="0527" class="pw-post-body-paragraph jk jl in jm b jn lp jp jq jr lq jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh ig bi translated">锁步发布是当你必须一起部署两个或更多的服务以确保系统保持运行时的一种情况。一个服务正在对一个契约进行向后不兼容的更改，因此它迫使它的所有消费者相应地更新。</p><p id="3c16" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在一个多回购世界中，一个服务往往有自己的 CI/CD 管道。从设计上来说，它迫使你将构建工件视为独立的可交付成果，因为每一个都可以有独特的发布节奏。如果有 API 的消费者，新版本需要注意向后兼容性(即通过使用<a class="ae lu" href="https://martinfowler.com/bliki/ParallelChange.html" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"/></a>的伸缩模式)。</p><p id="b656" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在 monorepo 中，所有的资源都在一个树中，很容易一次构建和部署所有的服务。然而，仅仅因为事情一前一后地变化，并不意味着它们都是同一件事。因此，如果一个 monorepo 绑定到一个构建管道，它很快就会成为一个争论点。构建时间越来越长，一个团队引入的问题会阻碍其他团队。每个人最终都在等待绿色建筑，这导致了很多挫折。</p><p id="6a54" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">应该避免这种情况。从事 monorepo 的团队应该自由决定他们项目的发布节奏，并且应该拥有他们的交付管道。定义、拥有部署边界并独立交付软件是团队的责任。Monorepo 模型不是不进行向后兼容 API 更改的借口。</p><blockquote class="lv lw lx"><p id="fc24" class="jk jl ki jm b jn jo jp jq jr js jt ju ly jw jx jy lz ka kb kc ma ke kf kg kh ig bi translated">“谷歌为 2.5 万名开发者提供单一回购。在这种情况下，有数百个独立的可构建/可部署的东西。每一种都有自己的发布节奏。一些在每次提交时进入 prod(持续部署风格)。其他人有每日、每周或每月的节奏。——<a class="ae lu" href="https://paulhammant.com/2017/03/25/repositories-vs-release-cadences/" rel="noopener ugc nofollow" target="_blank">保罗·哈曼特</a></p></blockquote><h1 id="7ef4" class="kr ks in bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">政治、所有权和基于主干的开发</h1><p id="b0d2" class="pw-post-body-paragraph jk jl in jm b jn lp jp jq jr lq jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh ig bi translated">Monorepo 风格只能在透明和协作的工程文化中工作。每个人都可以看到，甚至改变一切。它不适合高度政治化的环境。你不能隐瞒事情。您必须定期协作共享代码和库升级。团队需要准备好接受<a class="ae lu" href="http://wiki.c2.com/?CollectiveCodeOwnership" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io">集体代码所有权</strong> </a>或者至少在一定程度上。如果 autonomy 是这种情况，您可以鼓励团队将回购中的项目视为他们的迷你回购。GitHub 风格的<em class="ki"> CODEOWNERS </em> file，定义了拥有存储库中特定文件或路径的用户或组，可以对此有所帮助。</p><p id="d230" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">monorepo 模型迫使团队以<a class="ae lu" href="https://trunkbaseddevelopment.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io">基于主干的开发</strong> </a>风格工作。没有发布分支，软件从主干中构建和部署。任何复杂的分支策略在这里都行不通。</p><h1 id="3fe9" class="kr ks in bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">工具作业</h1><p id="c98c" class="pw-post-body-paragraph jk jl in jm b jn lp jp jq jr lq jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh ig bi translated">monorepo 越大，就越难合作。5 个服务的 Monorepo 不需要任何特殊的工具。500 项服务的单一回购需要适当的工具投资。这可能代价高昂。Google、Twitter 或 Dropbox 在可伸缩性和生产力工具上投入了大量资金来支持这种模式。然而，并不是每家公司都像谷歌一样，可以投入大量资金使其完美运行。另一方面，大公司不断开源他们的成果或贡献现有的免费工具，所以每个人都可以利用它。不要忘记在提交模型之前做研究，并保持将现有项目逐步滚动到 monorepo 中，解决出现的可伸缩性问题。</p><p id="c006" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">值得记住的常用工具和技术有:</p><ul class=""><li id="0084" class="mb mc in jm b jn jo jr js jv md jz me kd mf kh mg mh mi mj bi translated">通过扩展/收缩(即<a class="ae lu" href="https://trunkbaseddevelopment.com/expanding-contracting-monorepos/" rel="noopener ugc nofollow" target="_blank">https://trunkbaseddevelopment . com/expanding-contracting-mono repos</a></li><li id="f69b" class="mb mc in jm b jn mk jr ml jv mm jz mn kd mo kh mg mh mi mj bi translated">提高 git 性能<a class="ae lu" href="https://dropbox.tech/application/speeding-up-a-git-monorepo-at-dropbox-with--200-lines-of-code" rel="noopener ugc nofollow" target="_blank">https://Dropbox . tech/application/用 200 行代码加速 git-monorepo-at-Dropbox</a></li><li id="0ea7" class="mb mc in jm b jn mk jr ml jv mm jz mn kd mo kh mg mh mi mj bi translated">使用 monorepo 专用的构建工具，如<a class="ae lu" href="https://bazel.build" rel="noopener ugc nofollow" target="_blank"> Bazel </a>、<a class="ae lu" href="https://buck.build" rel="noopener ugc nofollow" target="_blank"> Buck </a>或<a class="ae lu" href="https://www.pantsbuild.org" rel="noopener ugc nofollow" target="_blank"> Pants </a></li></ul><h1 id="c7c4" class="kr ks in bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">分享太多</h1><p id="6dfa" class="pw-post-body-paragraph jk jl in jm b jn lp jp jq jr lq jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh ig bi translated">在多方回购方式中，界定界限更容易。随着变化越来越痛苦，你会越来越深思熟虑。另一方面，也有因为开销太大而没有做正确的事情的风险。</p><p id="ff13" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然而，在单一回购模式中，存在过度分享的风险。公共库很容易成为代码的垃圾场。这通常会导致糟糕的代码健康，并增加构建成本(共享代码中的每一个小变化都会触发所有依赖项目的构建)。单片代码库绝不意味着单片软件设计。需要保持对稳定的、经过深思熟虑的 API 和紧凑的专用库的激励。对代码短句、依赖分析工具以及工程技术的投资是必不可少的。</p><h1 id="c1c7" class="kr ks in bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">摘要</h1><p id="94ce" class="pw-post-body-paragraph jk jl in jm b jn lp jp jq jr lq jt ju jv lr jx jy jz ls kb kc kd lt kf kg kh ig bi translated">尽管简化的重构和简单的共享代码管理是引入 monorepo 概念的重要原因，但它并不是灵丹妙药。它带来了许多好处，但是如果它降低了团队快速和独立移动的能力，它也可能很快变成令人厌恶的反模式。对工具的投资以及健康的 DevOps 文化是必须的。</p></div><div class="ab cl mp mq hr mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ig ih ii ij ik"><p id="e1aa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">感谢大卫·丹顿、马特·麦克唐纳和·谢的评论、更正和讨论。</p></div></div>    
</body>
</html>