<html>
<head>
<title>Functional programming with Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift 函数式编程</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/functional-programming-with-swift-f119b52d7214?source=collection_archive---------0-----------------------#2018-11-20">https://blog.devgenius.io/functional-programming-with-swift-f119b52d7214?source=collection_archive---------0-----------------------#2018-11-20</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/db8162c934fe6880ee6f0013370f49e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VEnL5az6oDxiALKNcCNNtg.png"/></div></div></figure><p id="0263" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我希望当我第一次用谷歌搜索术语<a class="ae kt" href="https://en.wikipedia.org/wiki/Functional_programming" rel="noopener ugc nofollow" target="_blank">函数式编程</a>或者简称 FP 的时候也是这么简单。我努力阅读各种文章和博客来理解 FP，并且我仍然通过每天在我的代码中使用它来学习它是如何工作的。</p><p id="584d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在我们理解函数式编程之前，让我们看看非函数式编程是如何工作的。</p><p id="b3ad" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我知道许多读者可能会跳过这一部分，认为他们知道什么是非函数式编程，因为他们早上醒来去办公室，坐在椅子上，盯着它的脸。</p><p id="b7be" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但如果你愿意读的话，我会告诉你 FP 和非 FP 的一个基本区别(当然后者用‘non’做前缀。咄！).当我们谈到非浮点或命令式编程时。</p><p id="8c90" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们假设给你一个任务，在 swift 中创建一个简单的代码来对一组字符串进行排序，你会怎么做呢？</p><figure class="ku kv kw kx gt jo"><div class="bz fp l di"><div class="ky kz l"/></div></figure><p id="cfdf" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们看到了什么，我们创建了一个函数来排序字符串数组。此外，我们在函数中创建了一个变量来存储结果排序列表。</p><figure class="ku kv kw kx gt jo"><div class="bz fp l di"><div class="ky kz l"/></div></figure><p id="3d32" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在你会认为这就是我们用任何语言写程序时所做的，我们创建一些文字，作为常量，和一些变量，随着程序的进行，它们的状态会改变。</p><p id="e83b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是我们有没有想过在多线程环境中使用变量会有一些副作用？当我们编写程序时，我们经常会遇到这样的情况:我们需要处理多个线程访问一个函数，并改变变量的状态，从而导致错误的输出。如果我说我们可以用函数式编程来克服这个所谓的“副作用”呢？</p><blockquote class="la lb lc"><p id="0246" class="jv jw ld jx b jy jz ka kb kc kd ke kf le kh ki kj lf kl km kn lg kp kq kr ks ig bi translated"><strong class="jx io"> <em class="in">注意:</em> </strong> <em class="in">在我们继续之前，我会推荐你多读一些关于 swift 闭包和一点泛型的内容。</em></p></blockquote><p id="8fc3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">说够了，什么是解决上述问题的函数式编程方法？</p><p id="b107" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果我告诉你，我可以把上面的代码减少到 4 行代码，并且仍然得到相同的结果，甚至不需要创建一个变量。(<strong class="jx io">神奇！是吗？</strong>)</p><h1 id="024e" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">函数编程方法</h1><figure class="ku kv kw kx gt jo"><div class="bz fp l di"><div class="ky kz l"/></div></figure><p id="d3c7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> Dafaq！那是什么？</strong> <br/>嗯，这就是 swift 的<a class="ae kt" href="https://docs.swift.org/swift-book/LanguageGuide/Closures.html" rel="noopener ugc nofollow" target="_blank">闭包</a>的魔力，这里我们只是使用了 Swift 标准库的内置函数</p><figure class="ku kv kw kx gt jo"><div class="bz fp l di"><div class="ky kz l"/></div></figure><p id="9136" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">基本上，<code class="fe mf mg mh mi b">.sorted()</code>是在一个数组上调用的，它将一个函数作为参数(闭包),并返回一个满足闭包中声明的谓词的新元素数组。或者我们可以说闭包获取一个数组元素并返回一个<code class="fe mf mg mh mi b">Bool</code>值，这个值是基于闭包中定义的谓词的<code class="fe mf mg mh mi b">true</code>或<code class="fe mf mg mh mi b">false</code>。</p><p id="0ce3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果我能把上面的实现减少到只有一行代码，而输出和效率是一样的，会怎么样呢？</p><figure class="ku kv kw kx gt jo"><div class="bz fp l di"><div class="ky kz l"/></div></figure><p id="a8b8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">欢迎来到强大的世界，<strong class="jx io">函数式编程</strong>。</p><h1 id="f33c" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">函数式编程概念</h1><p id="69c6" class="pw-post-body-paragraph jv jw in jx b jy mj ka kb kc mk ke kf kg ml ki kj kk mm km kn ko mn kq kr ks ig bi translated">让我们快速地看看它们对于函数式编程意味着什么</p><h1 id="5046" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">1.一阶和高阶函数</h1><p id="33cb" class="pw-post-body-paragraph jv jw in jx b jy mj ka kb kc mk ke kf kg ml ki kj kk mm km kn ko mn kq kr ks ig bi translated">一种编程语言据说有<strong class="jx io">一级函数</strong>如果它允许下面</p><ul class=""><li id="72b9" class="mo mp in jx b jy jz kc kd kg mq kk mr ko ms ks mt mu mv mw bi translated">接受一个或多个函数作为参数的函数。</li><li id="57c2" class="mo mp in jx b jy mx kc my kg mz kk na ko nb ks mt mu mv mw bi translated">将函数作为函数的结果返回</li><li id="d66c" class="mo mp in jx b jy mx kc my kg mz kk na ko nb ks mt mu mv mw bi translated">将一个函数赋给一个变量，并将它们存储在数据结构中。</li></ul><p id="b32e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">高阶函数</strong>是满足至少一个上述条件的函数。</p><p id="39d3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，如果您可以创建一个函数，并将一个函数作为参数传递给该函数，或者您可以将一个函数赋给一个变量，以后再使用它，或者您可以将一个函数作为函数的结果返回，那么您的编程语言就是函数式编程范式。我们可以用 Swift 编程语言完成所有这些工作。</p><h1 id="7c3e" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">2.纯函数</h1><p id="c3d0" class="pw-post-body-paragraph jv jw in jx b jy mj ka kb kc mk ke kf kg ml ki kj kk mm km kn ko mn kq kr ks ig bi translated">纯函数通常是对内存或 I/O 没有副作用的函数或表达式。因此，如果一个函数返回一个不被使用的结果，那么它可以被删除而不影响表达式。与<a class="ae kt" href="https://en.wikipedia.org/wiki/Referential_transparency" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io">密切相关的参照透明度</strong> </a></p><h1 id="78ba" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">3.递归</h1><p id="db1f" class="pw-post-body-paragraph jv jw in jx b jy mj ka kb kc mk ke kf kg ml ki kj kk mm km kn ko mn kq kr ks ig bi translated">递归是一种问题解决技术，其解决方案依赖于同一问题的较小实例的解决方案。编程语言中的迭代/循环是通过递归实现的，在这里，函数递归地调用自己，直到得到结果。</p><h1 id="791e" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">4.对透明性有关的</h1><p id="6e30" class="pw-post-body-paragraph jv jw in jx b jy mj ka kb kc mk ke kf kg ml ki kj kk mm km kn ko mn kq kr ks ig bi translated">如果一个函数或表达式的求值对相同的输入没有副作用，就说它是引用透明的。引用透明的编程语言没有赋值语句，所以变量的值一旦定义就不会改变。</p><p id="9f81" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">举个小例子<code class="fe mf mg mh mi b"><strong class="jx io">x = x + 10</strong></code>无论何时执行都会改变 x 的状态。所以这个声明不是透明的。</p><h1 id="d65d" class="lh li in bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">其他 Swift 功能-</h1><p id="cf44" class="pw-post-body-paragraph jv jw in jx b jy mj ka kb kc mk ke kf kg ml ki kj kk mm km kn ko mn kq kr ks ig bi translated"><code class="fe mf mg mh mi b">.filter()</code>、<code class="fe mf mg mh mi b">.map()</code>、<code class="fe mf mg mh mi b">.compactMap()</code>、<code class="fe mf mg mh mi b">.sorted()</code>是 Swift 中您可以使用和展示您的功能方法的一些其他方法。</p><p id="ee6e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe mf mg mh mi b">.filter()</code>基本上是用来迭代一个数组，返回一个满足提供谓词(闭包)的数组。</p><p id="c486" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当我们需要从一个数组中取出一个元素，对其应用一个函数或变换，并将其添加到一个新的数组中时，可以使用<code class="fe mf mg mh mi b">.map()</code>。参见下面的例子</p><figure class="ku kv kw kx gt jo"><div class="bz fp l di"><div class="ky kz l"/></div></figure><p id="b64c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">//输出</p><pre class="ku kv kw kx gt nc mi nd ne aw nf bi"><span id="d817" class="ng li in mi b gy nh ni l nj nk">["1", "3", "6", "2", "0", "5"]</span></pre><p id="62bf" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe mf mg mh mi b">.compactMap()</code>类似于<code class="fe mf mg mh mi b">.map()</code>，此外它忽略零值。</p><figure class="ku kv kw kx gt jo"><div class="bz fp l di"><div class="ky kz l"/></div></figure><p id="ef83" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">//输出</p><pre class="ku kv kw kx gt nc mi nd ne aw nf bi"><span id="c84a" class="ng li in mi b gy nh ni l nj nk">[1, 3, 6, 2, 5]</span></pre><p id="b6a4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">等待终于结束了，让我们创建自己的功能表达式。</strong></p><figure class="ku kv kw kx gt jo"><div class="bz fp l di"><div class="ky kz l"/></div></figure><p id="e4da" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">带输出</p><pre class="ku kv kw kx gt nc mi nd ne aw nf bi"><span id="29a3" class="ng li in mi b gy nh ni l nj nk">6<br/>8</span></pre><p id="178a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这就是这篇文章的全部内容，请在下面的评论中让我知道你的功能编程代码。</p></div><div class="ab cl nl nm hr nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ig ih ii ij ik"><p id="ee63" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="ld">原载于 2018 年 7 月 17 日</em><a class="ae kt" href="http://siddharthpaneri.in/" rel="noopener ugc nofollow" target="_blank"><em class="ld">http://siddharthpaneri . in</em></a><em class="ld">。</em></p></div></div>    
</body>
</html>