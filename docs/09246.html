<html>
<head>
<title>K8s — Why Use Job Instead of Pod Directly?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">K8s —为什么直接使用作业而不是 Pod？</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/k8s-why-use-job-instead-of-pod-directly-48cf4e24a0df?source=collection_archive---------2-----------------------#2022-08-09">https://blog.devgenius.io/k8s-why-use-job-instead-of-pod-directly-48cf4e24a0df?source=collection_archive---------2-----------------------#2022-08-09</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><div class=""><h2 id="9871" class="pw-subtitle-paragraph jo iq ir bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated">每天一点 K8s 知识！</h2></div><figure class="kg kh ki kj gu kk gi gj paragraph-image"><div class="ab gv cl kl"><img src="../Images/c33a9b4a0e178d87878bbaf64c1a20e2.png" data-original-src="https://miro.medium.com/v2/format:webp/1*2FWCslv8CGekTLMvxzFJIQ.png"/></div></figure><p id="4da3" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">在我的上一篇文章中，我们学习了 Pod，这是 K8s 的核心对象，“<a class="ae lk" rel="noopener ugc nofollow" target="_blank" href="/k8s-core-concept-pod-8af4fe19f7a6">K8s——核心概念:Pod </a>”。我们还了解到，因为 Pods 比容器更能代表实际的应用程序，K8s 不在容器级别编排服务，而是使用 Pods 作为集群中调度操作和维护的最小单元。</p><p id="8146" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">我们还看到了 K8s 的资源对象关系图，Pod 是中心，扩展了许多其他资源对象，代表了不同的业务。让我们再看看:</p><figure class="kg kh ki kj gu kk gi gj paragraph-image"><div class="ab gv cl kl"><img src="../Images/dcee5403a8aaa0a07f1d051d9c338e26.png" data-original-src="https://miro.medium.com/v2/format:webp/1*srDlqvFseK3suk0jX3SWkg.png"/></div></figure><p id="065a" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">您可能会问这样一个问题:Pod 的功能已经足够完整了，为什么要定义这些额外的对象？为什么不在 Pod 中添加一些功能来处理业务需求呢？</p><p id="6052" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">这个问题反映了谷歌对大规模计算集群管理的深刻思考。今天，我们来谈谈 K8s 基于 Pod 的设计概念，从最简单的两个对象开始——Job 和 CronJob。</p><h1 id="9efa" class="ll lm ir bd ln lo lp lq lr ls lt lu lv jx lw jy lx ka ly kb lz kd ma ke mb mc bi translated">为什么不直接使用豆荚呢</h1><p id="c3dd" class="pw-post-body-paragraph ko kp ir kq b kr md js kt ku me jv kw kx mf kz la lb mg ld le lf mh lh li lj ik bi translated">现在您应该知道 K8s 使用 RESTful API，它将集群中的各种业务抽象成 HTTP 资源对象。然后在这个层次上，我们可以使用面向对象的方法来解决问题。</p><p id="3cae" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">如果你有一些编程经验，你知道面向对象编程(OOP)，它把所有的东西都当作高度内聚的对象，并强调对象之间相互通信以完成任务。</p><p id="642d" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">面向对象设计有很多基本原则，我认为其中两个更恰当地描述了 K8s 对象设计，一个是“<strong class="kq is">单一责任”</strong>，另一个是“<strong class="kq is">组合优先于继承</strong>”。</p><p id="d69a" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated"><strong class="kq is">单一责任</strong>表示目标只专注于做好一件事，不要贪得无厌。保持足够小的粒度更便于重用和管理。</p><p id="3d73" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated"><strong class="kq is">组合胜于继承</strong>“意味着在运行时应该尽可能多地连接对象以保持松散的耦合，而不是硬编码对象之间的关系。</p><p id="7c7f" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">应用这两个原则，我们将非常清楚地看到 k8 的资源对象。因为 Pod 已经是一个相对完整的对象，专门负责管理容器，那么我们就不应该再盲目地为它扩展函数，而是要保持它的独立性，容器外的函数需要定义其他的函数对象，将 Pod 作为它的成员之一“组成”它。</p><h1 id="487b" class="ll lm ir bd ln lo lp lq lr ls lt lu lv jx lw jy lx ka ly kb lz kd ma ke mb mc bi translated">为什么选择工作/CronJob</h1><p id="6d07" class="pw-post-body-paragraph ko kp ir kq b kr md js kt ku me jv kw kx mf kz la lb mg ld le lf mh lh li lj ik bi translated">在我之前的文章中，我们运行了两个 pod:<code class="fe mi mj mk ml b">Nginx</code>和<code class="fe mi mj mk ml b">busybox</code>，它们代表了 K8s 中的两种主要业务类型。一种是像<code class="fe mi mj mk ml b">Nginx</code>这样长期运行的“线上业务”，一种是像<code class="fe mi mj mk ml b">busybox</code>这样短期运行的“线下业务”。</p><p id="3fbe" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">这里有很多“在线商务”类型的应用，如<code class="fe mi mj mk ml b">Nginx</code>、<code class="fe mi mj mk ml b">Node.js</code>、<code class="fe mi mj mk ml b">MySQL</code>、<code class="fe mi mj mk ml b">Redis</code>等。他们一旦在跑，基本上就不会停下来，也就是一直在线。</p><p id="cf1f" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">而“离线商务”应用并不少见。它们一般不直接服务于外部用户，只对内部用户有意义，比如日志分析、数据建模、视频转码等。“线下业务”的特点是必须退出，不会无限期运行，所以调度策略很不一样。</p><p id="64f4" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">这些业务特性不一定与容器管理相关。如果由 Pod 实施，则承担了不必要的义务，违反了“单一责任”。因此，我们应该把这部分功能单独交给另一个对象来实现，让这个对象来控制吊舱的运行并完成额外的工作。</p><p id="4971" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">“线下商业”也可以分为两种。一种是“临时任务”，跑完就完了，下次有需要的时候再重新安排；另一种是“定时任务”，不需要太多干预就可以按时周期性运行。</p><p id="cb9f" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">对应 K8s，“临时任务”是 API 对象<strong class="kq is"> Job </strong>，“定时任务”是 API 对象<strong class="kq is"> CronJob </strong>。使用这两个对象，您可以在 K8s 中安排和管理任何离线业务。</p><p id="c47c" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">至此，你应该很清楚为什么 K8s 有<strong class="kq is"> Job </strong>和<strong class="kq is"> CronJob </strong>对象了。</p><h1 id="46ad" class="ll lm ir bd ln lo lp lq lr ls lt lu lv jx lw jy lx ka ly kb lz kd ma ke mb mc bi translated">用 YAML 描述工作</h1><p id="cc0e" class="pw-post-body-paragraph ko kp ir kq b kr md js kt ku me jv kw kx mf kz la lb mg ld le lf mh lh li lj ik bi translated">让我们先来看一个 YAML 工作的例子:</p><pre class="kg kh ki kj gu mm ml mn mo aw mp bi"><span id="8035" class="mq lm ir ml b gz mr ms l mt mu">apiVersion: batch/v1<br/>kind: Job<br/>metadata:<br/>  name: echo-job</span><span id="f80c" class="mq lm ir ml b gz mv ms l mt mu">spec:<br/>  template:<br/>    <strong class="ml is">spec:<br/>      restartPolicy: OnFailure<br/>      containers:<br/>      - image: busybox<br/>        name: echo-job<br/>        imagePullPolicy: IfNotPresent<br/>        command: ["/bin/echo"]<br/>        args: ["hello", "world"]</strong></span></pre><blockquote class="mw mx my"><p id="9272" class="ko kp mz kq b kr ks js kt ku kv jv kw na ky kz la nb lc ld le nc lg lh li lj ik bi translated">注意，你总是可以使用<code class="fe mi mj mk ml b">kubectl explain job</code>或<code class="fe mi mj mk ml b">kubectl create job echo-job --dry-run=client -oyaml</code>来生成一个 YAML 样板文件。</p></blockquote><p id="5107" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">从上面的 YAML 中，你会注意到对<strong class="kq is">工作</strong>的描述与 Pod 非常相似，但有一点点不同。主要区别是在“spec”字段，有一个额外的模板字段，然后是另一个“spec”，有点奇怪。</p><p id="1e04" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">它实际上在作业对象中应用了合成模式。模板字段定义了一个<strong class="kq is">“应用模板”</strong>，其中嵌入了一个 Pod，因此作业可以从该模板创建一个 Pod。</p><p id="a5ca" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">而且因为这个 Pod 是在作业的管理和控制下，不直接处理<code class="fe mi mj mk ml b">apiserver</code>，所以不需要重复<code class="fe mi mj mk ml b">apiVersion</code>之类的“头字段”。它只需要定义关键规范并清楚地描述与容器相关的信息。它可以说是一个“无头”的荚状物体。</p><p id="122e" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">为了帮助您理解，我重新组织了作业对象，并使用不同的颜色来区分字段，这样您就可以很容易地看到，在这个“echo-job”中并没有太多的附加功能，只是 Pod 做了一个简单的包装:</p><figure class="kg kh ki kj gu kk gi gj paragraph-image"><div class="gi gj nd"><img src="../Images/3fc65fc58d7f8df17ed1c5d839b7c50a.png" data-original-src="https://miro.medium.com/v2/resize:fit:940/format:webp/1*jgK09iNrkOL2cR7Q13QQnA.png"/></div></figure><p id="47c9" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">一般来说，这里的 Pod 定义非常简单，在容器中写入名称和图像，执行命令<code class="fe mi mj mk ml b">/bin/echo</code>，输出“hello world”。</p><p id="df67" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">但是由于 Job 业务的特殊性，我们还需要在 spec 中增加一个额外的字段<code class="fe mi mj mk ml b">restartPolicy</code>来确定 Pod 运行失败时的策略。</p><p id="9350" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">现在让我们创建作业对象并运行这个简单的离线作业，再次使用<code class="fe mi mj mk ml b">kubectl apply</code>:</p><pre class="kg kh ki kj gu mm ml mn mo aw mp bi"><span id="277b" class="mq lm ir ml b gz mr ms l mt mu">$ kubectl apply -f job.yml</span><span id="a7d0" class="mq lm ir ml b gz mv ms l mt mu">$ kubectl get job<br/>NAME             COMPLETIONS         DURATION     AGE<br/>echo-job         1/1                 2s           75s</span><span id="3c21" class="mq lm ir ml b gz mv ms l mt mu">$ kubectl get pod<br/>NAME             READY    STATUS       RESTARTS       AGE<br/>echo-job-pb5de   0/1      Completed    0              80s</span></pre><p id="b31b" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">可以看到，由于 Pod 是由作业管理的，所以不会重复重启和报错，而是显示为<code class="fe mi mj mk ml b">Completed</code>表示任务完成，作业也会列出已经运行成功的作业数量。这里只有一个工作，所以是<code class="fe mi mj mk ml b">1/1</code>。</p><p id="2e8b" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">还可以看到，Pod 是自动关联一个名称的，使用的是作业的名称(echo-job)加上一个随机字符串(pb5de)，当然这也是作业管理的“功劳”，省去了我们手动定义的麻烦，所以我们可以使用命令<code class="fe mi mj mk ml b">kubectl logs</code>得到 Pod 的运行结果:</p><pre class="kg kh ki kj gu mm ml mn mo aw mp bi"><span id="66d4" class="mq lm ir ml b gz mr ms l mt mu">$ kubectl logs echo-job-pb5de<br/>hello world</span></pre><p id="825a" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">以下是控制离线作业的几个重要字段。有关其他更详细的信息，请参考工作文档:</p><ul class=""><li id="0718" class="ne nf ir kq b kr ks ku kv kx ng lb nh lf ni lj nj nk nl nm bi translated"><strong class="kq is"> activeDeadlineSeconds </strong>，设置 Pod 运行的超时时间。</li><li id="9e36" class="ne nf ir kq b kr nn ku no kx np lb nq lf nr lj nj nk nl nm bi translated"><strong class="kq is"> backoffLimit </strong>，设置 Pod 重试失败的次数。</li><li id="17ce" class="ne nf ir kq b kr nn ku no kx np lb nq lf nr lj nj nk nl nm bi translated"><strong class="kq is">完成</strong>，作业需要运行多少个 pod 才能完成，默认为 1。</li><li id="4671" class="ne nf ir kq b kr nn ku no kx np lb nq lf nr lj nj nk nl nm bi translated"><strong class="kq is">与完成相关的并行度</strong>表示允许并发运行的 pod 数量，以避免过度使用资源。</li></ul><h1 id="ac94" class="ll lm ir bd ln lo lp lq lr ls lt lu lv jx lw jy lx ka ly kb lz kd ma ke mb mc bi translated">用 YAML 描述克朗乔布</h1><p id="364b" class="pw-post-body-paragraph ko kp ir kq b kr md js kt ku me jv kw kx mf kz la lb mg ld le lf mh lh li lj ik bi translated">学完“临时任务”的 Job 对象，再学“定时任务”的 CronJob 对象就比较容易了。我直接使用命令<code class="fe mi mj mk ml b">kubectl create</code>创建一个 CronJob 模板。</p><p id="28da" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">应该注意两点。一是因为 CronJob 的名字有点长，K8s 提供了简写<code class="fe mi mj mk ml b">cj</code>，使用命令<code class="fe mi mj mk ml b">kubectl api-resources</code>也可以看到；其次，CronJob 需要定期运行，因此我们还需要在命令行上指定参数— schedule。</p><pre class="kg kh ki kj gu mm ml mn mo aw mp bi"><span id="3083" class="mq lm ir ml b gz mr ms l mt mu">$ kubectl create cj echo-cj --image=busybox --schedule="" --dry-run=client -o yaml</span></pre><p id="2d21" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">然后我们编辑这个 YAML 样板文件来生成 CronJob 对象:</p><pre class="kg kh ki kj gu mm ml mn mo aw mp bi"><span id="5325" class="mq lm ir ml b gz mr ms l mt mu">apiVersion: batch/v1<br/>kind: CronJob<br/>metadata:<br/>  name: echo-cj</span><span id="c4bb" class="mq lm ir ml b gz mv ms l mt mu">spec:<br/>  schedule: '*/1 * * * *'<br/>  jobTemplate:<br/>    spec:<br/>      template:<br/>        spec:<br/>          restartPolicy: OnFailure<br/>          containers:<br/>          - image: busybox<br/>            name: echo-cj<br/>            imagePullPolicy: IfNotPresent<br/>            command: ["/bin/echo"]<br/>            args: ["hello", "world"]</span></pre><p id="d6f6" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">我们仍然关注它的 spec 字段，您会发现它在一行中有三个级别的 spec 嵌套:</p><ul class=""><li id="aeb6" class="ne nf ir kq b kr ks ku kv kx ng lb nh lf ni lj nj nk nl nm bi translated">第一个规范是 CronJob 自己的对象规范声明</li><li id="ad77" class="ne nf ir kq b kr nn ku no kx np lb nq lf nr lj nj nk nl nm bi translated">第二个规范属于“jobTemplate”，它定义了一个作业对象。</li><li id="6f11" class="ne nf ir kq b kr nn ku no kx np lb nq lf nr lj nj nk nl nm bi translated">第三个规范属于“模板”，它定义了作业中运行的 pod。</li></ul><figure class="kg kh ki kj gu kk gi gj paragraph-image"><div class="ab gv cl kl"><img src="../Images/c33a9b4a0e178d87878bbaf64c1a20e2.png" data-original-src="https://miro.medium.com/v2/format:webp/1*2FWCslv8CGekTLMvxzFJIQ.png"/></div></figure><p id="1c4b" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">CronJob 除了定义 Job 对象的“<strong class="kq is"> jobTemplate </strong>”字段之外，还有一个新的字段“schedule”，用来定义周期性运行任务的规则。</p><p id="c6c1" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">它使用标准的 Cron 语法，指定分钟、小时、天、月和周，与 Linux 上的 crontab 相同。例如，这里我指定每分钟运行一次。关于格式的具体含义，可以在课后参考 Kubernetes 官网文档。</p><p id="d7be" class="pw-post-body-paragraph ko kp ir kq b kr ks js kt ku kv jv kw kx ky kz la lb lc ld le lf lg lh li lj ik bi translated">除了名称不同，CronJob 和 Job 的用法基本相同，使用<code class="fe mi mj mk ml b">kubectl apply</code>创建 CronJob，使用<code class="fe mi mj mk ml b">kubectl get cj</code>、<code class="fe mi mj mk ml b">kubectl get pod</code>查看状态:</p><pre class="kg kh ki kj gu mm ml mn mo aw mp bi"><span id="6fa3" class="mq lm ir ml b gz mr ms l mt mu">$ kubectl apply -f cronjob.yml<br/>$ kubectl get cj<br/>$ kubectl get pod</span></pre><h1 id="fed9" class="ll lm ir bd ln lo lp lq lr ls lt lu lv jx lw jy lx ka ly kb lz kd ma ke mb mc bi translated">结论</h1><ul class=""><li id="037c" class="ne nf ir kq b kr md ku me kx ns lb nt lf nu lj nj nk nl nm bi translated">Pod 是 Kubernetes 中最小的调度单元，但是为了保持其独立性，不应该向它添加多余的功能。</li><li id="d7ad" class="ne nf ir kq b kr nn ku no kx np lb nq lf nr lj nj nk nl nm bi translated">K8es 为线下业务提供了两个 API 对象，Job 和 CronJob，分别处理“临时任务”和“定时任务”。</li><li id="769a" class="ne nf ir kq b kr nn ku no kx np lb nq lf nr lj nj nk nl nm bi translated">Job 的关键字段是<code class="fe mi mj mk ml b">spec.template</code>，它定义了用于运行业务的 Pod 模板。其他重要的领域包括完成、并行等。</li><li id="b6c5" class="ne nf ir kq b kr nn ku no kx np lb nq lf nr lj nj nk nl nm bi translated">CronJob 的关键字段是<code class="fe mi mj mk ml b">spec.jobTemplate</code>和<code class="fe mi mj mk ml b">spec.schedule</code>，分别定义了作业模板和定时操作的规则。</li></ul></div></div>    
</body>
</html>