<html>
<head>
<title>Spring — A Faster Way To Build Production-Ready API in a Well- Defined Structure</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">spring——一种在定义良好的结构中构建生产就绪API的更快方法</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/spring-a-faster-way-to-build-production-ready-api-in-a-well-defined-structure-5b1730fa81dd?source=collection_archive---------0-----------------------#2021-02-24">https://blog.devgenius.io/spring-a-faster-way-to-build-production-ready-api-in-a-well-defined-structure-5b1730fa81dd?source=collection_archive---------0-----------------------#2021-02-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f6b1" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">以可维护且一致的结构构建您的应用程序</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f584c6c56555a9b6ac0785180fd09700.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6_Pjcj4FKqFirF6n"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的<a class="ae kv" href="https://unsplash.com/@thisisengineering?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> ThisisEngineering RAEng </a></figcaption></figure><p id="b112" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">编码是一项艺术工作。有多种编码风格可以实现相同的逻辑。即使您的代码完美地满足了业务需求，如果您在没有适当组织的情况下以一种随意的方式进行编程，事情也会变糟。你可能要花费10倍的努力来构建新的特性，或者对混乱的代码结构进行故障排除。</p><p id="656f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">事实上，实现一个一致的、高度可维护的系统是非常简单的。一旦你掌握了系统设计的关键概念和成熟框架的使用，你将能够毫不费力地交付一个生产就绪的系统。</p><p id="7eea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我将向您展示系统设计的关键概念，以及如何使用Spring Framework快速开发API。为了使分享更有趣，我的演练将基于外汇交易的一个用例。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h2 id="03ab" class="lz ma iq bd mb mc md dn me mf mg dp mh lf mi mj mk lj ml mm mn ln mo mp mq mr bi translated"><strong class="ak">为什么框架？</strong></h2><p id="8bce" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">谈到软件工程，软件框架是一个必不可少的工具。它基本上体现了一组高度可重用的组件和通用结构，目的是使应用程序能够快速开发。因此，开发团队可以专注于业务逻辑开发，而无需构建那些常见的功能，如数据转换、验证、数据访问等。</p><p id="ef6a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于这个原因，许多公司痴迷于软件框架的使用，甚至开发他们自己的内部框架来努力提高生产力。</p><p id="b1d0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Spring是事实上的框架，在Java技术领域被广泛采用。我想说它是一个成熟的框架，因为它具有一整套系统功能，无论您要构建什么样的系统，从简单的API服务到具有批处理作业和复杂集成的企业系统，您都可以在框架中找到您需要的一切。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="75f8" class="mx ma iq bd mb my mz na me nb nc nd mh jw ne jx mk jz nf ka mn kc ng kd mq nh bi translated">关于使用案例</h1><p id="ebad" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">让我们来看看这个用例，它是一个外币贸易服务。由于货币价格的持续波动，客户只有在完成交易过账后才被告知准确的汇率。有些人不愿意在交易前不知道成本的情况下进行交易。为了提供更好的客户体验，一些金融机构允许客户保留汇率，以便客户在提交交易之前充分了解汇率。当然，出于风险管理的考虑，此类费率预订仅在短期内有效。此外，对于不同账户等级的客户，将提供不同的优惠利率。</p><p id="4cff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面的用例图显示了外汇交易服务的简化版，有4个功能:</p><ul class=""><li id="f6e0" class="ni nj iq ky b kz la lc ld lf nk lj nl ln nm lr nn no np nq bi translated">检索最新的外汇汇率</li><li id="99cd" class="ni nj iq ky b kz nr lc ns lf nt lj nu ln nv lr nn no np nq bi translated">账面汇率</li><li id="19ec" class="ni nj iq ky b kz nr lc ns lf nt lj nu ln nv lr nn no np nq bi translated">过帐外汇交易。它包括价格预订，因为客户需要在提交交易前进行有效的价格预订。</li><li id="db00" class="ni nj iq ky b kz nr lc ns lf nt lj nu ln nv lr nn no np nq bi translated">检索客户的外汇交易列表</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/cb84e16b84d88f8ea5333e9f57d086d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:942/format:webp/1*CTleSegVjFLHcl8K9z9MVQ.jpeg"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">使用案例——外汇交易服务(我自己创建的图表)</figcaption></figure><h1 id="d903" class="mx ma iq bd mb my nx na me nb ny nd mh jw nz jx mk jz oa ka mn kc ob kd mq nh bi translated"><strong class="ak">高层次设计</strong></h1><p id="5eb3" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">基于职责分离的设计实践，我们将有两个服务分别管理汇率和贸易交易。因此，客户将与他们互动，以达成外汇交易:</p><ol class=""><li id="2218" class="ni nj iq ky b kz la lc ld lf nk lj nl ln nm lr oc no np nq bi translated"><strong class="ky ir">保留外汇汇率</strong> —客户首先向汇率服务发送预订请求，汇率服务将从汇率提供商的API获取最新汇率，然后根据客户的等级和金额提供汇率。</li><li id="f6ec" class="ni nj iq ky b kz nr lc ns lf nt lj nu ln nv lr oc no np nq bi translated"><strong class="ky ir">外汇交易提交</strong> —通过汇率预订，客户可以向交易服务提交外汇交易。但是，谁知道费率预订是否真实有效呢？因此，作为交易处理的一部分，交易服务将要求价格服务验证预订。</li></ol><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi od"><img src="../Images/c925d07228f62ec9458ea53cd9028ed3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1122/format:webp/1*TnzsNdTDcs0GXM5QRN6_5A.jpeg"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">高级设计(我自己创建的图表)</figcaption></figure><h1 id="897d" class="mx ma iq bd mb my nx na me nb ny nd mh jw nz jx mk jz oa ka mn kc ob kd mq nh bi translated"><strong class="ak">应用架构</strong></h1><p id="d2e5" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">接下来，让我们深入技术设计。</p><p id="9a37" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">无论使用何种语言和技术，拥有一个定义良好的架构都是至关重要的。为了方便或快捷的捷径而随意编码和混淆逻辑的诱惑有时很难抵制，但是，如果你想象一下在没有一致结构的情况下维护和调试代码是多么痛苦，你就不会屈服于这种诱惑。</p><blockquote class="oe"><p id="46f4" class="of og iq bd oh oi oj ok ol om on lr dk translated"><em class="oo">优秀软件结构的关键是清晰的责任定义和单向依赖</em></p></blockquote></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h2 id="c50f" class="lz ma iq bd mb mc md dn me mf mg dp mh lf mi mj mk lj ml mm mn ln mo mp mq mr bi translated">关键组件</h2><p id="2fc4" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">通常，您可以简单地将系统逻辑分为三种类型组件:</p><ul class=""><li id="e565" class="ni nj iq ky b kz la lc ld lf nk lj nl ln nm lr nn no np nq bi translated"><strong class="ky ir">控制器</strong> —它向HTTP通道公开业务逻辑，因此所有与HTTP相关的处理都驻留在该组件中，例如从HTTP请求到对象的转换、将结果格式化为HTTP响应、产品HTTP状态等。</li><li id="61a4" class="ni nj iq ky b kz nr lc ns lf nt lj nu ln nv lr nn no np nq bi translated"><strong class="ky ir">服务</strong> —这是业务逻辑的“核心”部分。除了分支逻辑和计算，服务组件还编排各种服务和存储库。</li><li id="9142" class="ni nj iq ky b kz nr lc ns lf nt lj nu ln nv lr nn no np nq bi translated"><strong class="ky ir">存储库</strong> —该组件是持久数据存储的接口。它主要抽象出底层数据技术的实现细节。</li></ul><h2 id="1bd2" class="lz ma iq bd mb mc md dn me mf mg dp mh lf mi mj mk lj ml mm mn ln mo mp mq mr bi translated">组件依赖性</h2><p id="e64b" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">通过关键组件的角色设置，您将在下图中看到组件之间清晰的依赖关系。显然，依赖是单向的，这样的依赖设置对于一个高度可维护的系统是至关重要的。如果你修改了一个组件，你可以很快发现并追踪任何影响。例如，如果您对控制器进行任何更改，服务和存储库组件肯定不会受到影响。因此，它极大地减少了您为将来的任何增强和故障排除而调查系统的时间和精力。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi op"><img src="../Images/4ac1a601da50c20f513ccca7046685b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1256/format:webp/1*Q85iBUu7Ype7ivxewjJ8BQ.jpeg"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">整体应用程序架构(我自己创建的图表)</figcaption></figure><p id="e8f3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们将系统设计应用于外汇交易用例时，我们会将控制器、服务和存储库安装到如下结构中</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oq"><img src="../Images/4851f80948de86761fae0f0d63d4c340.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D_6jX8J1R7sicsiSQROXVA.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">细节组件设计(自己创建的图表)</figcaption></figure><p id="1050" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">说明它如何用于外汇交易提交的用例。您可以在下图中看到组件之间的数据流</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi or"><img src="../Images/2895e3f215bfec6a3b1cef3ebe3b2c35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b0ijUurVKcGl4PMEJ8UHqA.jpeg"/></div></div></figure><p id="8142" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">API网关的实现不在这里讨论，因为它被认为是基础设施的一部分。您可以在云上配置一个，如AWS API gateway。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="f613" class="mx ma iq bd mb my mz na me nb nc nd mh jw ne jx mk jz nf ka mn kc ng kd mq nh bi translated"><strong class="ak">代码结构一目了然</strong></h1><p id="67f0" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">在下面的示例代码中，您将看到为什么使用Spring framework可以如此快速地完成开发。您可以专注于编写业务逻辑，而框架会为您处理大部分其他事情。</p><p id="efcc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以参考我的GitHub存储库，获取我的示例实现的完整源代码:</p><div class="os ot gp gr ou ov"><a href="https://github.com/gavinklfong/reactive-spring-forex-trade" rel="noopener  ugc nofollow" target="_blank"><div class="ow ab fo"><div class="ox ab oy cl cj oz"><h2 class="bd ir gy z fp pa fr fs pb fu fw ip bi translated">gavinklfong/无功-弹簧-外汇-贸易</h2><div class="pc l"><h3 class="bd b gy z fp pa fr fs pb fu fw dk translated">反应式Spring Boot-外汇交易。为gavinklfong/reactive-spring-forex-trade的发展做出贡献，创造一个…</h3></div><div class="pd l"><p class="bd b dl z fp pa fr fs pb fu fw dk translated">github.com</p></div></div><div class="pe l"><div class="pf l pg ph pi pe pj kp ov"/></div></div></a></div><h2 id="9d81" class="lz ma iq bd mb mc md dn me mf mg dp mh lf mi mj mk lj ml mm mn ln mo mp mq mr bi translated">spring web flux——异步非阻塞操作的能力</h2><p id="7cac" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">示例实现是使用Spring WebFlux构建的，它是支持异步非阻塞操作的Spring框架的一部分。它现在是一种流行的技术。</p><p id="fc90" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你已经有了Spring MVC的经验，这对你来说是个好消息，因为尽管Spring WebFlux的底层引擎与最初的Spring MVC明显不同，但学习Spring WebFlux并不困难。你会发现相同的注释可以应用于WebFlux和MVC。</p><p id="ded6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">简而言之，WebFlux的主要区别在于所有的请求和响应都使用Mono &amp; Flux数据类型，并采用发布者&amp;订阅者模型的反应式管道进行编码。关于Project Reactor的有用资源，可以参考下面的链接:</p><p id="ec08" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://projectreactor.io/learn" rel="noopener ugc nofollow" target="_blank">https://projectreactor.io/learn</a></p><p id="b233" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，我的示例实现将非阻塞操作应用于控制器和服务，而数据库访问仍然使用传统的阻塞技术。由于Spring JPA/Hibernate技术目前只支持同步阻塞I/O。如果您对实现端到端的完全非阻塞操作感兴趣，那么您可以查看Spring Data R2DBC，它实现了非阻塞数据访问。</p><div class="os ot gp gr ou ov"><a href="https://spring.io/projects/spring-data-r2dbc" rel="noopener  ugc nofollow" target="_blank"><div class="ow ab fo"><div class="ox ab oy cl cj oz"><h2 class="bd ir gy z fp pa fr fs pb fu fw ip bi translated">春季数据R2DBC</h2><div class="pc l"><h3 class="bd b gy z fp pa fr fs pb fu fw dk translated">PostgresqlConnectionFactory connection factory = new…</h3></div><div class="pd l"><p class="bd b dl z fp pa fr fs pb fu fw dk translated">spring.io</p></div></div><div class="pe l"><div class="pk l pg ph pi pe pj kp ov"/></div></div></a></div><h2 id="347f" class="lz ma iq bd mb mc md dn me mf mg dp mh lf mi mj mk lj ml mm mn ln mo mp mq mr bi translated"><strong class="ak">控制器</strong></h2><p id="60e1" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">控制器负责向API公开业务服务，并处理所有与HTTP协议相关的系统逻辑。它不应该有任何核心业务逻辑。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oq"><img src="../Images/02e3dea33a343a6991743fb6aecbb30f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n38UNvmADHcFowZv0grSbg.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">详细部件设计——控制器(我自己制作的图表)</figcaption></figure><p id="32aa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">控制器的程序代码非常简单明了，你只需为API Url的定义、Http方法和验证应用注释，然后Spring framework就会为你完成这项工作。您将要编写的代码只是将服务组件连接到HTTP请求和响应。</p><p id="591b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">贸易交易控制器<strong class="ky ir"> <em class="pl"> </em> </strong>示例代码有两种方法分别用于贸易交易检索和提交。有几行代码用于调用服务组件的功能。与HTTP方法映射、数据转换和验证相关的复杂系统逻辑由诸如“@GetMapping”、“PostMapping”、“Valid”、“RequestBody”、“RequestParam”之类的批注来处理。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pm pn l"/></div></figure><h2 id="520a" class="lz ma iq bd mb mc md dn me mf mg dp mh lf mi mj mk lj ml mm mn ln mo mp mq mr bi translated"><strong class="ak">服务</strong></h2><p id="c1c2" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">由于业务逻辑驻留在这个组件中，您可能会将大部分时间花在服务组件上。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oq"><img src="../Images/c864ab07cbcbf4b67bd8cb71245dde1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Sewt-CHr1fZX7GFhTd1whw.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">详细组件设计—服务(我自己创建的图表)</figcaption></figure><p id="e932" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">事实上，各种服务的编排是许多面向服务环境中的常见模式。每个服务负责特定领域的逻辑，为了完成业务功能，您可能需要与存储库交互并与服务集成。</p><p id="3aef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，下面的示例代码显示了外汇交易过账。它通过从客户存储库中检索数据并调用函数调用对服务进行评级来进行验证，然后生成交易记录并保存到存储库中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pm pn l"/></div></figure><h2 id="87e5" class="lz ma iq bd mb mc md dn me mf mg dp mh lf mi mj mk lj ml mm mn ln mo mp mq mr bi translated"><strong class="ak">储存库</strong></h2><p id="25a6" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">存储库是数据访问的系统逻辑。根据持久性存储的选择，您可能需要为SQL查询、无SQL查询或平面文件访问编写代码。在这个例子中，所有持久数据都存储在关系数据库中，使用Spring Data framework进行数据访问。Spring Data JPA和Hibernate非常强大，允许轻松实现数据访问，而无需为大多数常见场景编写一个SQL查询。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oq"><img src="../Images/ec7eb7388e98776302d1933e3f402454.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Mh4eCfh7pa2Aa89vti9M4Q.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">详细组件设计—存储库(我自己创建的图表)</figcaption></figure><p id="41ea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Trade Deal Repository只有一个接口方法定义，框架会在运行时自动生成数据库查询，而保存、删除、更新和检索等其他常见操作也由框架的父接口<strong class="ky ir"> <em class="pl"> CrudRepository </em> </strong>自动提供</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pm pn l"/></div></figure><p id="48a0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不要忘记数据库模式和约束的设置，使用数据模型类中的框架注释来定义数据库表——代理键、表约束和一对多/多对多之类的关系</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pm pn l"/></div></figure><h1 id="3bf4" class="mx ma iq bd mb my nx na me nb ny nd mh jw nz jx mk jz oa ka mn kc ob kd mq nh bi translated"><strong class="ak">最后的想法</strong></h1><p id="c5a7" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">编码不是整个软件开发过程的重要部分，而架构和系统设计起着至关重要的作用。一个高度可维护的软件应用程序意味着一个定义良好的结构，具有清晰的职责分离和组件间的单向依赖。有了一个伟大的设计，再加上Spring这样一个了不起的框架，编码工作就变得流畅而愉快了。然后你将有很大的机会成功交付高质量的软件产品。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="fb23" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您想知道如何在这个应用程序架构上实现测试，那么您可以参考下面的文章以获得详细信息</p><div class="os ot gp gr ou ov"><a href="https://medium.com/dev-genius/java-spring-the-best-practice-of-modern-software-quality-assurance-e5aa66466627" rel="noopener follow" target="_blank"><div class="ow ab fo"><div class="ox ab oy cl cj oz"><h2 class="bd ir gy z fp pa fr fs pb fu fw ip bi translated">Java Spring——现代软件质量保证的最佳实践</h2><div class="pc l"><h3 class="bd b gy z fp pa fr fs pb fu fw dk translated">确保软件质量的全面指南</h3></div><div class="pd l"><p class="bd b dl z fp pa fr fs pb fu fw dk translated">medium.com</p></div></div><div class="pe l"><div class="po l pg ph pi pe pj kp ov"/></div></div></a></div></div></div>    
</body>
</html>