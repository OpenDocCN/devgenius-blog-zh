# 钩子的力量:第一部分

> 原文：<https://blog.devgenius.io/on-the-power-of-react-hooks-49094e76709c?source=collection_archive---------4----------------------->

![](img/bc1614cff98c1aa8d606677ddcab9e1d.png)

Lynda Hinton 在 [Unsplash](https://unsplash.com/s/photos/hook?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上拍摄的照片

作为一个将大部分时间花在 Android 平台上的开发人员，切换到 React-Native 让我开始欣赏“React 的方式”。在 Android-Land 中，即使构建一个简单的列表也需要创建许多类(ListAdapter、CustomView、CustomViewModel、data object……)。在 React 中，声明一个返回 FlatList 的函数很简单，它通过 props 接受数据集。

(几乎)所有需要在 React 上显示的列表。

通过一个简单的函数呈现每个项目的想法让我印象深刻，因为它很简单。我是说，那不是很美吗？

然而，尽管我很喜欢这种反应方式，但有些事情总是让我不太舒服。每当我不得不复制一个场景，在这个场景中，我必须保持本地状态，对生命周期事件做出反应，或者只是运行一些副作用，我都发现自己在挠头。

我知道，我知道，我们有阶级成分！Redux！全能的传奇！但是你看，我们回到我们留在绿色机器人领域的所有样板文件…

幸运的是，从版本`16.8`开始，React 团队已经引入了一项出色的功能——钩子！

# 开大音量。

让我们考虑一个简单的场景，我们想要播放一些声音来响应用户事件。在过去，我们会写一个甜蜜的小故事(或者 Thunk，如果你对这类事情感兴趣的话……)来收听我们的活动，并给我们宝贵的音频服务打电话。让我们想想所有移动的部分。

我们需要:

*   为我们的`action`创建一个[切片](https://redux-toolkit.js.org/api/createSlice)。
*   从我们的组件中调度`action`。
*   用一个 [Thunk](https://github.com/reduxjs/redux-thunk) 来增加动作/写一个 [Saga](https://github.com/redux-saga/redux-saga) 来监听事件
*   从`saga`中调用我们的`play`函数。

虽然这看起来很简单，但是这种方法存在一些问题。

首先，因为有许多移动的部件，所以有很大的出错空间。然后，很难概括这样的设置。如果我们必须对另一个事件做出反应，我们需要重新编写这些内容。最后但并非最不重要的是，音频回放可能会占用大量内存，因此我们必须竭尽全力防止内存泄漏，并拥有快速的加载时间。

虽然这是对 Android 方式的改进，但我们仍然有相当多的样板文件要处理。

# 胡克前来救援。

让我们看看如何只用香草反应和钩子来处理这个问题。没有重复，没有传奇，没有样板。下面是我们希望从我们钟爱的组件中实现的功能:

*   我们想要预加载音频文件。
*   我们想在屏幕外释放内存。
*   我们希望在给定的时间播放我们的声音(比如，当用户按下按钮时)。

很好，我们开始吧。

## 我们的组件。

我们从简单开始。只是一个按钮:

一个隐藏着音乐天赋的按钮。

我们现在想在`mount`上加载我们的音频文件，并在`onMount`上释放内存。假设我们已经有了一个`loadPlayer`函数，它将一个`file`加载到内存中并返回一个`player`接口。我们将使用`useRef`来保存我们的`player`实例，使用`useEffect`来对生命周期事件做出反应。

有音乐天赋的巴顿。

简单吧？现在我们只需要连接`onPress`来播放我们的声音，我们就好了！让我们开始吧。

这是作为音乐家成名的巴顿。

在 20 行中，我们有一个通话按钮！这是基于 Redux 方法的一大进步。然而，如果我们想进行对话，我们需要重新编写大部分代码。如果能再利用一部分不是很好吗？

# 拉皮条钩。

> 有时，我们希望在组件之间重用一些有状态逻辑。传统上，这个问题有两种流行的解决方案:[高阶组件](https://reactjs.org/docs/higher-order-components.html)和[渲染道具](https://reactjs.org/docs/render-props.html)。定制挂钩允许您这样做，但是不需要向树中添加更多的组件。

这就是事情变得有趣的地方。React 文档鼓励我们使用定制钩子来全面重用代码。让我们看看如何提取这个功能，并在其他组件中重用它。

按照文档的建议，我们可以将两个钩子移动到一个自定义钩子中，并将`ref`暴露给我们的主机组件。

钩在瓶子里…

不错！我们的钩子现在在内存中加载一个任意的音频文件，将其播放器绑定到生命周期，并允许我们随意播放这样的文件。让我们看看如何在组件内部使用它。

金属按钮。强大，但有点粗糙。

如果你想更进一步，我想让 API 表面尽可能薄，所以我建议不要从钩子中暴露出`ref`,而是返回一个函数数组供我们的组件使用。像这样:

我们组件的舞台装备。

下面是如何在我们的组件内部使用它。

一个低保真极简按钮。

我们现在已经实现了我们的目标。我们有一个简单、可重用和高效的钩子来播放来自任何 React 组件的音频。

# 结尾部分

我们已经看到钩子有多么强大，以及 React 生态系统目前已经达到的成熟程度。我认为，无论是在成熟度还是开发者经验方面，它现在都有能力与本土生态系统竞争。

这是我穿越 React Hooks 之旅的第一部分。你可以在这里找到[第二部分](https://medium.com/@accounts_32070/on-the-power-of-hooks-part-2-8de86630648c)，在那里找到[第三部分](https://medium.com/@accounts_32070/on-the-power-of-hooks-part-3-78d79cc2a110)。