# JavaScript 中的这个

> 原文：<https://blog.devgenius.io/this-in-javascript-f66d1c8396f9?source=collection_archive---------3----------------------->

![](img/34dc0b43f14133ddd921032e6261319a.png)

这个关键字是最令人困惑的事情之一，它让 JavaScript 开发人员头疼不已。在我看来，大多数开发人员解释**这个**关键字就像解释它在其他语言如 Java 中的行为一样。嗯，在 JavaScript 中，**这个**在其他语言中的工作方式是它的一个用例。在这篇博文中，我将揭示 JavaScript 中与 **this** 关键字相关的所有规则。

在全局执行上下文中，**这个**值等于窗口对象。这对于 JavaScript 中的严格和非严格模式是一样的。

然而，对于一个函数的执行上下文来说，**这个**关键字的值取决于一个函数是如何被调用的。在 JavaScript 中，可以用 4 种不同的方式调用函数。

## **方法 1:普通函数调用**

在这个场景中，**这个**值等于**全局对象，**哪个是浏览器中的**窗口**，使用 NodeJS **时等于**全局**。**

但是，如果我们使用**严格模式，未定义的**会被记录到控制台。通过将指令`"use strict"`放在文件或函数的开头来启用严格模式。

## **方法 2:方法调用**

当一个对象的方法被调用时，**这个**等于拥有该方法的对象。在下面的例子中，**这个**值等于用来调用它的对象， **obj** 。

## **方法 3:间接调用**

JavaScript 中的函数就像对象一样。它们更具体地被称为**可调用对象**。函数在其原型中定义了这两种方法；**调用**和**应用**。使用这些方法，我们可以设置**这个**的值。当使用**调用**和**应用**方法调用函数时，**这个**值等于提供给这些函数的第一个参数。在下面的例子中，**这个**等于物体， **obj，**两种情况都是如此。

## **方法 4:构造函数调用**

当用 **new** 关键字调用构造函数时，在这种情况下，**这个**值等于**新创建的实例。**

# **这在箭头功能中**

与常规函数相比， **this** 关键字在箭头函数中的表现非常不同。箭头函数没有自己的**执行上下文。**实际上，**这个**是从外部封闭函数或上下文继承而来的。举个例子，

在上面的例子中，**这个**继承自全局执行上下文。这个**值等于浏览器中全局执行上下文中的窗口对象。让我们看另一个例子。**

到目前为止，我们已经确定箭头函数没有自己的执行上下文。因此，在上面的例子中，**这个**值等于封闭上下文，它是全局执行上下文。因此，**这个**值等于窗口对象。window 对象没有任何 **name** 属性，导致上例中的输出为 **undefined** 。

# 修复绑定问题

考虑这个例子，

为什么我们会得到未定义的输出？原来我们已经失去了这个到 **obj** 对象的绑定。注意在**第 8 行**上，我们没有调用函数 **printName** 。我们将它的引用存储在一个变量中，供以后使用。调用一个函数和在变量中存储它的引用是两回事。所以当我们调用第 9 行**上的函数时，**我们得到**未定义的**作为输出。由于没有指定对象，绑定到 **obj** 对象的 **this** 丢失。导致**这个**等于**全局对象**。由于全局对象中没有 **name** 属性，我们在控制台上得到 **undefined** 。

我们如何保留 **printName** 函数的 **this** 绑定，使得 **this** 的值总是 **obj** 对象，无论我们何时何地调用 **printName** 函数？

在函数的原型中使用 **bind** 方法可以很容易地解决这个问题。 **bind** 方法返回一个新函数，其中 **this** 关键字设置为指定值。与**调用**和**应用**方法不同，该功能不会被立即调用。因此我们在后面使用由**绑定**方法返回的函数。

**bind** 方法固定**print name 函数到 **obj** 对象的这个**绑定。

我希望这篇文章对你有所帮助。感谢阅读。:)

我们来连线:
[LinkedIn](https://www.linkedin.com/in/rabi-siddique-b6b4971a0/)
[Twitter](https://twitter.com/rabisiddique234)