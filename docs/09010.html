<html>
<head>
<title>The Complete JS Notes #13 🧵 Arrays</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">完整的 JS Notes #13 🧵阵列</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/the-complete-js-notes-12-6788b076c65?source=collection_archive---------12-----------------------#2022-07-24">https://blog.devgenius.io/the-complete-js-notes-12-6788b076c65?source=collection_archive---------12-----------------------#2022-07-24</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/0cadccdba565c196c5c7a22a18f396f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xllM4gkYYwN1j1QGuCEHTQ.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">由<a class="ae jz" href="https://unsplash.com/s/photos/funny?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上<a class="ae jz" href="https://unsplash.com/@charlesdeluvio?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> charlesdeluvio </a>拍摄的照片</figcaption></figure><p id="8bcc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ky">欢迎阅读我的 JavaScript 笔记的下一篇文章。</em></p><p id="2e1e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ky">在本文中我们将讨论:</em> <strong class="kc io"> <em class="ky">数组函数，filter，reduce，find，findIndex，some，every，flat，flatmap，sort，Array.from() </em> </strong></p><p id="75e0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ky">所有内容摘自 Jonas Schmedtmann 的惊人课程</em> <a class="ae jz" href="https://www.udemy.com/course/the-complete-javascript-course/" rel="noopener ugc nofollow" target="_blank"> <em class="ky">完整的 JavaScript 课程 2022:从零到专家！</em> </a></p><p id="edba" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">请购买课程以了解内容，这只是我对课程的总结笔记。</p></div><div class="ab cl kz la hr lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="ig ih ii ij ik"><figure class="lh li lj lk gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lg"><img src="../Images/f00625b7e45d0e2897f32e196776b204.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W1rXJOwEZ871TwTBrMicJg.png"/></div></div></figure></div><div class="ab cl kz la hr lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="ig ih ii ij ik"><h1 id="85fb" class="ll lm in bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">该过滤方法</h1><pre class="lh li lj lk gt mj mk ml mm aw mn bi"><span id="b309" class="mo lm in mk b gy mp mq l mr ms">const deposit = movement.filter(function (mov) {</span><span id="6c05" class="mo lm in mk b gy mt mq l mr ms">return mov &gt; 0;</span><span id="e114" class="mo lm in mk b gy mt mq l mr ms">});</span></pre><p id="b73b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果我们用 map()做同样的声明，我们将得到一个布尔数组。</p><p id="f274" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们可以使用箭头函数</p><pre class="lh li lj lk gt mj mk ml mm aw mn bi"><span id="2c74" class="mo lm in mk b gy mp mq l mr ms">const withdrawals = movement.filter(mov =&gt; mov &lt; 0);</span></pre><h1 id="2c60" class="ll lm in bd ln lo mu lq lr ls mv lu lv lw mw ly lz ma mx mc md me my mg mh mi bi translated">该简化方法</h1><p id="2fbb" class="pw-post-body-paragraph ka kb in kc b kd mz kf kg kh na kj kk kl nb kn ko kp nc kr ks kt nd kv kw kx ig bi translated">最大的区别在于 reduce 方法。因为它带了一个别人没有累加器的参数。它总是成为第一个参数，其他通常的参数都跟随它</p><p id="cc40" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们还必须给累加器一个初始值。在我们的例子中，它是 0</p><pre class="lh li lj lk gt mj mk ml mm aw mn bi"><span id="e7f1" class="mo lm in mk b gy mp mq l mr ms">const balance = movement.reduce(function (accumulator, current, idx, arr) {</span><span id="0f27" class="mo lm in mk b gy mt mq l mr ms">return accumulator + current;</span><span id="7114" class="mo lm in mk b gy mt mq l mr ms">}, 0);</span></pre><p id="1504" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们也可以使用累加器以一种<strong class="kc io">性感</strong>的方式找到数组中的最大数字</p><pre class="lh li lj lk gt mj mk ml mm aw mn bi"><span id="cab2" class="mo lm in mk b gy mp mq l mr ms">const max = movement.reduce((acc, mov) =&gt; (acc &lt; mov ? mov : acc), 0);</span></pre><h1 id="6777" class="ll lm in bd ln lo mu lq lr ls mv lu lv lw mw ly lz ma mx mc md me my mg mh mi bi translated">链接方法的魔力</h1><pre class="lh li lj lk gt mj mk ml mm aw mn bi"><span id="d845" class="mo lm in mk b gy mp mq l mr ms">const euroToUSD = 1.1;</span><span id="c0bb" class="mo lm in mk b gy mt mq l mr ms">const totalDepositsUSD = movement</span><span id="8c9d" class="mo lm in mk b gy mt mq l mr ms">.filter(mov =&gt; mov &gt; 0)</span><span id="5d66" class="mo lm in mk b gy mt mq l mr ms">.map(mov =&gt; mov * euroToUSD)</span><span id="3660" class="mo lm in mk b gy mt mq l mr ms">.reduce((acc, mov) =&gt; acc + mov, 0);</span></pre><p id="8734" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们可以把所有这些方法联系在一起</p><p id="f508" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">写€的标志=&gt; alt + 0128</p><p id="ca9b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">使用右边的数字和左边的 alt。</p><p id="a5f8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">使用链接时有两条规则需要注意</p><ul class=""><li id="4ccf" class="ne nf in kc b kd ke kh ki kl ng kp nh kt ni kx nj nk nl nm bi translated">链接是昂贵的，如果你有一个使用许多地图的大数组，会降低你的应用程序的速度。你需要在一个 map 调用中优化和做很多事情。</li><li id="e4b1" class="ne nf in kc b kd nn kh no kl np kp nq kt nr kx nj nk nl nm bi translated">你不应该使用改变原始数组的函数，比如 reverse()就是这样一个函数，你不应该使用这种东西。</li></ul><h1 id="c01f" class="ll lm in bd ln lo mu lq lr ls mv lu lv lw mw ly lz ma mx mc md me my mg mh mi bi translated">查找方法</h1><pre class="lh li lj lk gt mj mk ml mm aw mn bi"><span id="b1da" class="mo lm in mk b gy mp mq l mr ms">movements.find((mov) =&gt; mov &lt; 0);</span></pre><p id="0f43" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">它的语法类似于 filter。filter 的区别在于 find 方法返回满足条件的第一个元素。</p><p id="6498" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Filter 返回一个新数组，而 find 只返回一个元素</p><pre class="lh li lj lk gt mj mk ml mm aw mn bi"><span id="b08c" class="mo lm in mk b gy mp mq l mr ms">const accnt = accounts.find(acc =&gt; acc.owner === ‘Jessica Davis’);</span></pre><h1 id="cd0f" class="ll lm in bd ln lo mu lq lr ls mv lu lv lw mw ly lz ma mx mc md me my mg mh mi bi translated">实现登录</h1><pre class="lh li lj lk gt mj mk ml mm aw mn bi"><span id="67f5" class="mo lm in mk b gy mp mq l mr ms">let currentAccount;</span><span id="f0a9" class="mo lm in mk b gy mt mq l mr ms">btnLogin.addEventListener(‘click’, function (e) {</span><span id="f342" class="mo lm in mk b gy mt mq l mr ms">e.preventDefault();</span><span id="7cf6" class="mo lm in mk b gy mt mq l mr ms">currentAccount = accounts.find(</span><span id="dd47" class="mo lm in mk b gy mt mq l mr ms">account =&gt; account.username === inputLoginUsername.value</span><span id="7262" class="mo lm in mk b gy mt mq l mr ms">);</span><span id="9567" class="mo lm in mk b gy mt mq l mr ms">console.log(currentAccount);</span><span id="72c9" class="mo lm in mk b gy mt mq l mr ms">});</span></pre><p id="3799" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在窗体中总是使用防止默认。</p><p id="db4d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如何使用 js 将不透明度从 0 更改为 1？</p><pre class="lh li lj lk gt mj mk ml mm aw mn bi"><span id="12d0" class="mo lm in mk b gy mp mq l mr ms">containerApp.style.opacity = 1;</span></pre><p id="25ca" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们可以进行双重赋值，因为赋值是从左到右进行的</p><pre class="lh li lj lk gt mj mk ml mm aw mn bi"><span id="4872" class="mo lm in mk b gy mp mq l mr ms">inputLoginUsername.value = inputLoginPin.value = “”;</span></pre><p id="75b2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">好了，我们在输入值之后，把输入字段清理干净了。然而，我们的光标仍然有焦点，这看起来很难看，如何避免它？</p><pre class="lh li lj lk gt mj mk ml mm aw mn bi"><span id="b5bb" class="mo lm in mk b gy mp mq l mr ms">inputLoginPin.blur()</span></pre><p id="7d1b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">htmlElement.blur()从 html 元素中移除焦点</p><h1 id="ea60" class="ll lm in bd ln lo mu lq lr ls mv lu lv lw mw ly lz ma mx mc md me my mg mh mi bi translated">实施转移</h1><h1 id="08d1" class="ll lm in bd ln lo mu lq lr ls mv lu lv lw mw ly lz ma mx mc md me my mg mh mi bi translated">查找索引方法</h1><pre class="lh li lj lk gt mj mk ml mm aw mn bi"><span id="808d" class="mo lm in mk b gy mp mq l mr ms">const idx = accounts.findIndex(</span><span id="1cba" class="mo lm in mk b gy mt mq l mr ms">acc =&gt; acc.username === currentAccount.username</span><span id="308d" class="mo lm in mk b gy mt mq l mr ms">);</span></pre><p id="8751" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">它像 find()一样工作，但是它不返回元素，而是返回索引</p><p id="1605" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个方法和数组方法<strong class="kc io"> indexOf() </strong>很像</p><pre class="lh li lj lk gt mj mk ml mm aw mn bi"><span id="6ea4" class="mo lm in mk b gy mp mq l mr ms">[3, 5, 7, 10].indexOf(3);</span></pre><p id="3a63" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这里，indexOf 检查数组中是否存在 3，如果正确，则返回索引。</p><p id="f5ed" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然而，在 findIndex 中，我们可以在数组中进行更复杂的搜索。</p><h1 id="2763" class="ll lm in bd ln lo mu lq lr ls mv lu lv lw mw ly lz ma mx mc md me my mg mh mi bi translated">如何删除数组中的一个元素？</h1><pre class="lh li lj lk gt mj mk ml mm aw mn bi"><span id="682c" class="mo lm in mk b gy mp mq l mr ms">accounts.splice(idx, 1);</span></pre><p id="a2df" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">就这样。</p><h1 id="6676" class="ll lm in bd ln lo mu lq lr ls mv lu lv lw mw ly lz ma mx mc md me my mg mh mi bi translated">一些和所有</h1><pre class="lh li lj lk gt mj mk ml mm aw mn bi"><span id="a62d" class="mo lm in mk b gy mp mq l mr ms">movement.includes(-130)</span></pre><p id="6ae8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们用 includes 来检查数组中的确切元素，但大多数时候我们想检查不同的条件</p><pre class="lh li lj lk gt mj mk ml mm aw mn bi"><span id="93fb" class="mo lm in mk b gy mp mq l mr ms">movement.some(mov =&gt; mov &gt; 199 &amp;&amp; mov &lt; 201)</span></pre><p id="d9ac" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们可以使用 some 来检查我们想要的所有条件，它会返回一个布尔值。</p><p id="b027" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">正如你所能猜到的，每个元素都满足条件</p><pre class="lh li lj lk gt mj mk ml mm aw mn bi"><span id="9923" class="mo lm in mk b gy mp mq l mr ms">movement.every(mov =&gt; typeof mov === ‘number’</span></pre><p id="36da" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们可以创建一个函数，并将其用作所有接受返回 true false 的函数的数组方法的回调函数</p><pre class="lh li lj lk gt mj mk ml mm aw mn bi"><span id="98f3" class="mo lm in mk b gy mp mq l mr ms">const movement = [200, 450, -400, 3000, -650, -130, 70, 1300];</span><span id="138b" class="mo lm in mk b gy mt mq l mr ms">const deposit = movement =&gt; movement &gt; 0;</span><span id="24df" class="mo lm in mk b gy mt mq l mr ms">console.log(movement.some(deposit));</span><span id="33eb" class="mo lm in mk b gy mt mq l mr ms">console.log(movement.every(deposit));</span><span id="261f" class="mo lm in mk b gy mt mq l mr ms">console.log(movement.filter(deposit));</span></pre><figure class="lh li lj lk gt jo gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/066616eaf4841a15b8cedec2d133ad44.png" data-original-src="https://miro.medium.com/v2/resize:fit:604/format:webp/1*fMq1-EGSM8or14uOSlXLOg.png"/></div></figure><h1 id="badc" class="ll lm in bd ln lo mu lq lr ls mv lu lv lw mw ly lz ma mx mc md me my mg mh mi bi translated">平面和平面地图</h1><p id="78eb" class="pw-post-body-paragraph ka kb in kc b kd mz kf kg kh na kj kk kl nb kn ko kp nc kr ks kt nd kv kw kx ig bi translated">平面和地图是 ecmaScript 2019 语言中添加的新功能</p><pre class="lh li lj lk gt mj mk ml mm aw mn bi"><span id="2b66" class="mo lm in mk b gy mp mq l mr ms">const arr = [[1, 2, 3], [4, 5, [6]], 7, 8];</span><span id="d4b1" class="mo lm in mk b gy mt mq l mr ms">console.log(arr.flat());</span><span id="a995" class="mo lm in mk b gy mt mq l mr ms">//returns</span><span id="6e90" class="mo lm in mk b gy mt mq l mr ms">[1, 2, 3, 4, 5, Array(1), 7, 8]</span></pre><p id="1c4a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Flat 不处理比默认参数(默认参数为 1)中的第二级更深的数组</p><p id="415e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">要处理更深的数组，请更改参数</p><pre class="lh li lj lk gt mj mk ml mm aw mn bi"><span id="b30f" class="mo lm in mk b gy mp mq l mr ms">console.log(arr.flat(2));</span><span id="0a66" class="mo lm in mk b gy mt mq l mr ms">//returns</span><span id="2b47" class="mo lm in mk b gy mt mq l mr ms">[1, 2, 3, 4, 5, 6, 7, 8]</span></pre><p id="379e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">假设我们想把所有账户的所有变动相加，然后求和，该怎么做呢？</p><ol class=""><li id="ea91" class="ne nf in kc b kd ke kh ki kl ng kp nh kt ni kx nt nk nl nm bi translated">使用 map 并制作一个数组的数组</li><li id="bb1f" class="ne nf in kc b kd nn kh no kl np kp nq kt nr kx nt nk nl nm bi translated">使用平板，形成一个大阵列</li><li id="e489" class="ne nf in kc b kd nn kh no kl np kp nq kt nr kx nt nk nl nm bi translated">使用 reduce 并进行求和</li></ol><figure class="lh li lj lk gt jo gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/bbd102caed95549afda8737d08e6889d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1086/format:webp/1*t1xTpz9CD4-3DuK5KVsL8A.png"/></div></figure><p id="1c2f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">实际上，使用贴图然后扁平化是很常见的，他们为此做了一个特殊的数组方法，这比使用贴图和扁平化更有效</p><pre class="lh li lj lk gt mj mk ml mm aw mn bi"><span id="ebfb" class="mo lm in mk b gy mp mq l mr ms">const overall = accounts</span><span id="b5ad" class="mo lm in mk b gy mt mq l mr ms">.flatMap(acc =&gt; acc.movements)</span><span id="a54f" class="mo lm in mk b gy mt mq l mr ms">.reduce((acc, value) =&gt; acc + value, 0);</span></pre><p id="1331" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">它和地图一样，实际上只是在最后的单位。</p><p id="6a60" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">请注意，平面地图只能深入 1 层。</p><h1 id="cdbf" class="ll lm in bd ln lo mu lq lr ls mv lu lv lw mw ly lz ma mx mc md me my mg mh mi bi translated">排序数组</h1><pre class="lh li lj lk gt mj mk ml mm aw mn bi"><span id="98aa" class="mo lm in mk b gy mp mq l mr ms">//strings</span><span id="099c" class="mo lm in mk b gy mt mq l mr ms">const arr = [‘b’, ‘d’, ‘c’, ‘a’];</span><span id="7776" class="mo lm in mk b gy mt mq l mr ms">console.log(arr.sort());</span><span id="76e8" class="mo lm in mk b gy mt mq l mr ms">console.log(arr);</span><span id="afed" class="mo lm in mk b gy mt mq l mr ms"> — — — — — — — — -</span><span id="e2bd" class="mo lm in mk b gy mt mq l mr ms">[“a”, “b”, “c”, “d”]</span><span id="32ba" class="mo lm in mk b gy mt mq l mr ms">[“a”, “b”, “c”, “d”]</span></pre><p id="901b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们在使用 sort 时需要小心，因为它<strong class="kc io">改变了</strong>原始数组。</p><pre class="lh li lj lk gt mj mk ml mm aw mn bi"><span id="a86e" class="mo lm in mk b gy mp mq l mr ms">//numbers</span><span id="1217" class="mo lm in mk b gy mt mq l mr ms">const movement = [200, 450, -400, 3000, -650, -130, 70, 1300];</span><span id="9f10" class="mo lm in mk b gy mt mq l mr ms">console.log(movement);</span><span id="0367" class="mo lm in mk b gy mt mq l mr ms">console.log(movement.sort());</span><span id="2bfa" class="mo lm in mk b gy mt mq l mr ms"> — — — — — — — — — — -</span><span id="2081" class="mo lm in mk b gy mt mq l mr ms">[200, 450, -400, 3000, -650, -130, 70, 1300]</span><span id="4fb4" class="mo lm in mk b gy mt mq l mr ms">[-130, -400, -650, 1300, 200, 3000, 450, 70]</span></pre><p id="09ee" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">看起来根本没排序。事实上，的确如此，但方式不同。</p><p id="83e0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">默认情况下，sort 方法只对字符串进行排序，所以这里它将元素返回给字符串，然后对其进行排序。</p><p id="6a4e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果你想对数字进行排序，你必须使用回调函数</p><pre class="lh li lj lk gt mj mk ml mm aw mn bi"><span id="6966" class="mo lm in mk b gy mp mq l mr ms">console.log(movement);</span><span id="af37" class="mo lm in mk b gy mt mq l mr ms">// return &lt; 0, [a, b] keeps the order</span><span id="9996" class="mo lm in mk b gy mt mq l mr ms">// return &gt; 0, [b, a] switches</span><span id="d6c8" class="mo lm in mk b gy mt mq l mr ms">movement.sort((a, b) =&gt; {</span><span id="00dc" class="mo lm in mk b gy mt mq l mr ms">if (a &gt; b) return 1;</span><span id="ce02" class="mo lm in mk b gy mt mq l mr ms">if (b &gt; a) return -1;</span><span id="61a6" class="mo lm in mk b gy mt mq l mr ms">});</span><span id="13ef" class="mo lm in mk b gy mt mq l mr ms">console.log(movement);</span><span id="4095" class="mo lm in mk b gy mt mq l mr ms"> — — — — — — — — — — — -</span><span id="ee44" class="mo lm in mk b gy mt mq l mr ms">[200, 450, -400, 3000, -650, -130, 70, 1300]</span><span id="a664" class="mo lm in mk b gy mt mq l mr ms">[-650, -400, -130, 70, 200, 450, 1300, 3000]</span></pre><p id="3ef6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">有用！所以我们在这里做的是:</p><p id="cb36" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">sort 方法有一个接受 2 个参数的回调函数，这些参数表示 a:一个元素，b:a 元素旁边的一个元素</p><p id="6062" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果排序回调方法返回的结果是负数，这意味着您应该保持顺序</p><p id="10ba" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果返回值是正的，这意味着您应该切换它并寻找下一个元素。</p><p id="1bcd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这样的工作只是他妈的排序。</p><p id="3c99" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果我们想按降序排序，我们需要做的就是改变 1。</p><pre class="lh li lj lk gt mj mk ml mm aw mn bi"><span id="d6be" class="mo lm in mk b gy mp mq l mr ms">movement.sort((a, b) =&gt; {</span><span id="dac8" class="mo lm in mk b gy mt mq l mr ms">if (a &gt; b) return -1;</span><span id="0828" class="mo lm in mk b gy mt mq l mr ms">if (b &gt; a) return 1;</span><span id="f85d" class="mo lm in mk b gy mt mq l mr ms">});</span></pre><p id="f1a9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这也适用于琴弦。</p><p id="5696" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在简单数学的帮助下，我们可以使这个操作变得非常简单</p><p id="9afd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果 a 大于 b，这意味着 a-b 总是正的，我们可以用这个返回正的值。</p><pre class="lh li lj lk gt mj mk ml mm aw mn bi"><span id="7466" class="mo lm in mk b gy mp mq l mr ms">movement.sort((a, b) =&gt; a — b);</span><span id="7d18" class="mo lm in mk b gy mt mq l mr ms"> — — — — — — </span><span id="ea40" class="mo lm in mk b gy mt mq l mr ms">[-650, -400, -130, 70, 200, 450, 1300, 3000]</span></pre><p id="0d6d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">通过一个简单的符号开关，我们也可以进行降序排列</p><pre class="lh li lj lk gt mj mk ml mm aw mn bi"><span id="3e77" class="mo lm in mk b gy mp mq l mr ms">movement.sort((a, b) =&gt; -a + b);</span><span id="3c36" class="mo lm in mk b gy mt mq l mr ms"> — — — — — — — </span><span id="d545" class="mo lm in mk b gy mt mq l mr ms">[3000, 1300, 450, 200, 70, -130, -400, -650]</span></pre><h1 id="9cfd" class="ll lm in bd ln lo mu lq lr ls mv lu lv lw mw ly lz ma mx mc md me my mg mh mi bi translated">创建和填充数组的更多方法</h1><p id="d308" class="pw-post-body-paragraph ka kb in kc b kd mz kf kg kh na kj kk kl nb kn ko kp nc kr ks kt nd kv kw kx ig bi translated">到目前为止，我们已经学会了创建这样的数组:</p><figure class="lh li lj lk gt jo gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/1706140f492a6426c73463381ddec902.png" data-original-src="https://miro.medium.com/v2/resize:fit:1172/format:webp/1*DKz-ZUC4lBNpn-S6jvUrYQ.png"/></div></figure><p id="a50b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你认为这个数组会返回什么:</p><pre class="lh li lj lk gt mj mk ml mm aw mn bi"><span id="7aaa" class="mo lm in mk b gy mp mq l mr ms">const a = new Array(7);</span><span id="dda5" class="mo lm in mk b gy mt mq l mr ms"> — — — — — — — — — — — </span><span id="b4ee" class="mo lm in mk b gy mt mq l mr ms">[empty × 7]</span></pre><p id="76ba" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您可能希望使用 map 等方法用值填充这个数组。然而它不允许</p><pre class="lh li lj lk gt mj mk ml mm aw mn bi"><span id="6270" class="mo lm in mk b gy mp mq l mr ms">console.log(a.map(() =&gt; 5));</span><span id="a239" class="mo lm in mk b gy mt mq l mr ms"> — — — — — — — — — — — — </span><span id="90f7" class="mo lm in mk b gy mt mq l mr ms">[empty × 7]</span></pre><p id="6562" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">除了一个重要的方法之外，它对任何事情都没有用:</p><pre class="lh li lj lk gt mj mk ml mm aw mn bi"><span id="e526" class="mo lm in mk b gy mp mq l mr ms">a.fill(13);</span></pre><p id="ecbe" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是我们可以做更多的事情，我们可以用一个数字来填充它，就像用切片法一样</p><pre class="lh li lj lk gt mj mk ml mm aw mn bi"><span id="8ea1" class="mo lm in mk b gy mp mq l mr ms">a.fill(1, 3);</span><span id="cc75" class="mo lm in mk b gy mt mq l mr ms"> — — — — — — — </span><span id="9aab" class="mo lm in mk b gy mt mq l mr ms">[empty × 3, 1, 1, 1, 1]</span><span id="8768" class="mo lm in mk b gy mt mq l mr ms">also</span><span id="b8ce" class="mo lm in mk b gy mt mq l mr ms">a.fill(1, 3, 5);</span></pre><p id="6b1c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们甚至可以对非空数组使用 fill 方法</p><pre class="lh li lj lk gt mj mk ml mm aw mn bi"><span id="fbc8" class="mo lm in mk b gy mp mq l mr ms">const arr = [1, 2, 3, 4, 5, 6];</span><span id="e879" class="mo lm in mk b gy mt mq l mr ms">arr.fill(23, 3, 5);</span><span id="b123" class="mo lm in mk b gy mt mq l mr ms"> — — — — — — — — -</span><span id="37e0" class="mo lm in mk b gy mt mq l mr ms">[1, 2, 3, 23, 23, 6]</span></pre><p id="219b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">还有一种方法是创建一个空数组并填充它。</p><p id="a8e0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">它叫做<strong class="kc io"> Array.from() </strong></p><pre class="lh li lj lk gt mj mk ml mm aw mn bi"><span id="f390" class="mo lm in mk b gy mp mq l mr ms">const y = Array.from({ length: 7 }, () =&gt; 1);</span><span id="f09d" class="mo lm in mk b gy mt mq l mr ms">console.log(y);</span><span id="a0f8" class="mo lm in mk b gy mt mq l mr ms"> — — — — — — — -</span><span id="a773" class="mo lm in mk b gy mt mq l mr ms">[1, 1, 1, 1, 1, 1, 1]</span></pre><p id="fed4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们可以像使用 map()一样使用的回调函数<strong class="kc io"/></p><pre class="lh li lj lk gt mj mk ml mm aw mn bi"><span id="8ac2" class="mo lm in mk b gy mp mq l mr ms">const z = Array.from({ length: 7 }, (current, idx) =&gt; idx + 1);</span><span id="2556" class="mo lm in mk b gy mt mq l mr ms">console.log(z);</span><span id="805f" class="mo lm in mk b gy mt mq l mr ms"> — — — — — — — </span><span id="bb23" class="mo lm in mk b gy mt mq l mr ms">[1, 2, 3, 4, 5, 6, 7]</span></pre><p id="cfd4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们可以使用丢弃参数，以便其他程序员能够理解它</p><pre class="lh li lj lk gt mj mk ml mm aw mn bi"><span id="4ee8" class="mo lm in mk b gy mp mq l mr ms">const z = Array.from({ length: 7 }, (_, idx) =&gt; idx + 1);</span></pre><p id="d4a2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个 Array.from 结构实际上是为了将不同的 iterables 转换成数组，这样他们就可以使用 Array 方法。</p><p id="00e2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对于集合和映射，很容易说和做，但是对于节点数组，例如，我们需要这个方法。</p><figure class="lh li lj lk gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nw"><img src="../Images/000745583b7c8b2c67e13fdba689becf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IaTinluYYxGF67Ns4UclRg.png"/></div></div></figure></div><div class="ab cl kz la hr lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="ig ih ii ij ik"><p id="ab5c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><a class="ae jz" href="https://medium.com/@barisbll/the-complete-js-notes-1-36ea76e326b3" rel="noopener"> <em class="ky">见本 js 注释线程第一条！</em> </a></p><p id="8778" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><a class="ae jz" rel="noopener ugc nofollow" target="_blank" href="/the-complete-js-notes-11-d9df3de726ed"> <em class="ky">见本 js 注释线程前一篇！</em> </a></p><p id="8aa5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><a class="ae jz" href="https://medium.com/@barisbll/the-complete-js-notes-14-numbers-33fa369fbb77" rel="noopener"> <em class="ky">参见本 js 笔记的下一篇帖子！</em> </a></p></div><div class="ab cl kz la hr lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="ig ih ii ij ik"><p id="b7b2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><a class="ae jz" href="https://twitter.com/barisbll_dev" rel="noopener ugc nofollow" target="_blank"> <em class="ky">在推特上关注我的甜蜜内容</em> </a> <em class="ky"> </em>😘</p><p id="a24e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ky">阅读我和许多其他伟大的科技博客在</em> <a class="ae jz" href="https://blog.devgenius.io/" rel="noopener ugc nofollow" target="_blank"> <em class="ky">开发天才</em> </a></p></div></div>    
</body>
</html>