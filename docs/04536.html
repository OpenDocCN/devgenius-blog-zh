<html>
<head>
<title>Create a React Fill Line Chart with Navigation with the Visx Library</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Visx 库创建带导航的 React 填充折线图</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/create-a-react-fill-line-chart-with-navigation-with-the-visx-library-a03e082f474f?source=collection_archive---------5-----------------------#2021-03-30">https://blog.devgenius.io/create-a-react-fill-line-chart-with-navigation-with-the-visx-library-a03e082f474f?source=collection_archive---------5-----------------------#2021-03-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/46fe1157350cf4a060d049c16aa79316.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0tQEIy7RyMA9WlVK"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">维多利亚博物馆在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="abb1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Visx 是一个库，让我们可以轻松地将图形添加到 React 应用程序中。</p><p id="5429" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将了解如何使用它向 React 应用程序添加带导航的填充折线图。</p><h1 id="86d6" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">安装所需的软件包</h1><p id="cb1c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们必须安装一些模块。</p><p id="61e8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，我们运行:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="89df" class="mn lc iq mj b gy mo mp l mq mr">npm i @visx/axis @visx/brush @visx/curve @visx/gradient @visx/group @visx/mock-data @visx/pattern @visx/responsive @visx/scale @visx/shape</span></pre><p id="8e2b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">安装软件包。</p><h1 id="4761" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">创建图表</h1><p id="04ad" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过添加模块提供的项目来创建图表。</p><p id="7bc9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们使用来自<code class="fe ms mt mu mj b">@visx/mock-data</code>模块的数据。</p><p id="f1d8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，为了创建底部带有导航图表的填充折线图，我们编写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="5e2b" class="mn lc iq mj b gy mo mp l mq mr">import React, { useRef, useState, useMemo } from "react";<br/>import { scaleTime, scaleLinear } from "@visx/scale";<br/>import appleStock from "@visx/mock-data/lib/mocks/appleStock";<br/>import { Brush } from "@visx/brush";<br/>import { PatternLines } from "@visx/pattern";<br/>import { LinearGradient } from "@visx/gradient";<br/>import { max, extent } from "d3-array";<br/>import { AxisBottom, AxisLeft } from "@visx/axis";<br/>import { AreaClosed } from "@visx/shape";<br/>import { Group } from "@visx/group";<br/>import { curveMonotoneX } from "@visx/curve";</span><span id="d281" class="mn lc iq mj b gy mv mp l mq mr">const stock = appleStock.slice(1000);<br/>const brushMargin = { top: 10, bottom: 15, left: 50, right: 20 };<br/>const chartSeparation = 30;<br/>const PATTERN_ID = "brush_pattern";<br/>const GRADIENT_ID = "brush_gradient";<br/>export const accentColor = "#f6acc8";<br/>export const background = "#584153";<br/>export const background2 = "#af8baf";<br/>const selectedBrushStyle = {<br/>  fill: `url(#${PATTERN_ID})`,<br/>  stroke: "white"<br/>};</span><span id="1bcf" class="mn lc iq mj b gy mv mp l mq mr">const getDate = (d) =&gt; new Date(d.date);<br/>const getStockValue = (d) =&gt; d.close;<br/>const axisColor = "#fff";<br/>const axisBottomTickLabelProps = {<br/>  textAnchor: "middle",<br/>  fontFamily: "Arial",<br/>  fontSize: 10,<br/>  fill: axisColor<br/>};<br/>const axisLeftTickLabelProps = {<br/>  dx: "-0.25em",<br/>  dy: "0.25em",<br/>  fontFamily: "Arial",<br/>  fontSize: 10,<br/>  textAnchor: "end",<br/>  fill: axisColor<br/>};</span><span id="6acd" class="mn lc iq mj b gy mv mp l mq mr">function AreaChart({<br/>  data,<br/>  gradientColor,<br/>  width,<br/>  yMax,<br/>  margin,<br/>  xScale,<br/>  yScale,<br/>  hideBottomAxis = false,<br/>  hideLeftAxis = false,<br/>  top,<br/>  left,<br/>  children<br/>}) {<br/>  if (width &lt; 10) return null;<br/>  return (<br/>    &lt;Group left={left || margin.left} top={top || margin.top}&gt;<br/>      &lt;LinearGradient<br/>        id="gradient"<br/>        from={gradientColor}<br/>        fromOpacity={1}<br/>        to={gradientColor}<br/>        toOpacity={0.2}<br/>      /&gt;<br/>      &lt;AreaClosed<br/>        data={data}<br/>        x={(d) =&gt; xScale(getDate(d)) || 0}<br/>        y={(d) =&gt; yScale(getStockValue(d)) || 0}<br/>        yScale={yScale}<br/>        strokeWidth={1}<br/>        stroke="url(#gradient)"<br/>        fill="url(#gradient)"<br/>        curve={curveMonotoneX}<br/>      /&gt;<br/>      {!hideBottomAxis &amp;&amp; (<br/>        &lt;AxisBottom<br/>          top={yMax}<br/>          scale={xScale}<br/>          numTicks={width &gt; 520 ? 10 : 5}<br/>          stroke={axisColor}<br/>          tickStroke={axisColor}<br/>          tickLabelProps={() =&gt; axisBottomTickLabelProps}<br/>        /&gt;<br/>      )}<br/>      {!hideLeftAxis &amp;&amp; (<br/>        &lt;AxisLeft<br/>          scale={yScale}<br/>          numTicks={5}<br/>          stroke={axisColor}<br/>          tickStroke={axisColor}<br/>          tickLabelProps={() =&gt; axisLeftTickLabelProps}<br/>        /&gt;<br/>      )}<br/>      {children}<br/>    &lt;/Group&gt;<br/>  );<br/>}</span><span id="cfab" class="mn lc iq mj b gy mv mp l mq mr">function BrushChart({<br/>  compact = false,<br/>  width,<br/>  height,<br/>  margin = {<br/>    top: 20,<br/>    left: 50,<br/>    bottom: 20,<br/>    right: 20<br/>  }<br/>}) {<br/>  const brushRef = useRef(null);<br/>  const [filteredStock, setFilteredStock] = useState(stock);</span><span id="d9a8" class="mn lc iq mj b gy mv mp l mq mr">  const onBrushChange = (domain) =&gt; {<br/>    if (!domain) return;<br/>    const { x0, x1, y0, y1 } = domain;<br/>    const stockCopy = stock.filter((s) =&gt; {<br/>      const x = getDate(s).getTime();<br/>      const y = getStockValue(s);<br/>      return x &gt; x0 &amp;&amp; x &lt; x1 &amp;&amp; y &gt; y0 &amp;&amp; y &lt; y1;<br/>    });<br/>    setFilteredStock(stockCopy);<br/>  };</span><span id="0eb5" class="mn lc iq mj b gy mv mp l mq mr">  const innerHeight = height - margin.top - margin.bottom;<br/>  const topChartBottomMargin = compact<br/>    ? chartSeparation / 2<br/>    : chartSeparation + 10;<br/>  const topChartHeight = 0.8 * innerHeight - topChartBottomMargin;<br/>  const bottomChartHeight = innerHeight - topChartHeight - chartSeparation;<br/>  const xMax = Math.max(width - margin.left - margin.right, 0);<br/>  const yMax = Math.max(topChartHeight, 0);<br/>  const xBrushMax = Math.max(width - brushMargin.left - brushMargin.right, 0);<br/>  const yBrushMax = Math.max(<br/>    bottomChartHeight - brushMargin.top - brushMargin.bottom,<br/>    0<br/>  );<br/>  const dateScale = useMemo(<br/>    () =&gt;<br/>      scaleTime({<br/>        range: [0, xMax],<br/>        domain: extent(filteredStock, getDate)<br/>      }),<br/>    [xMax, filteredStock]<br/>  );<br/>  const stockScale = useMemo(<br/>    () =&gt;<br/>      scaleLinear({<br/>        range: [yMax, 0],<br/>        domain: [0, max(filteredStock, getStockValue) || 0],<br/>        nice: true<br/>      }),<br/>    [yMax, filteredStock]<br/>  );<br/>  const brushDateScale = useMemo(<br/>    () =&gt;<br/>      scaleTime({<br/>        range: [0, xBrushMax],<br/>        domain: extent(stock, getDate)<br/>      }),<br/>    [xBrushMax]<br/>  );<br/>  const brushStockScale = useMemo(<br/>    () =&gt;<br/>      scaleLinear({<br/>        range: [yBrushMax, 0],<br/>        domain: [0, max(stock, getStockValue) || 0],<br/>        nice: true<br/>      }),<br/>    [yBrushMax]<br/>  );</span><span id="f653" class="mn lc iq mj b gy mv mp l mq mr">  const initialBrushPosition = useMemo(<br/>    () =&gt; ({<br/>      start: { x: brushDateScale(getDate(stock[50])) },<br/>      end: { x: brushDateScale(getDate(stock[100])) }<br/>    }),<br/>    [brushDateScale]<br/>  );</span><span id="adda" class="mn lc iq mj b gy mv mp l mq mr">  const handleClearClick = () =&gt; {<br/>    if (brushRef?.current) {<br/>      setFilteredStock(stock);<br/>      brushRef.current.reset();<br/>    }<br/>  };</span><span id="79a4" class="mn lc iq mj b gy mv mp l mq mr">  const handleResetClick = () =&gt; {<br/>    if (brushRef?.current) {<br/>      const updater = (prevBrush) =&gt; {<br/>        const newExtent = brushRef.current.getExtent(<br/>          initialBrushPosition.start,<br/>          initialBrushPosition.end<br/>        );</span><span id="da81" class="mn lc iq mj b gy mv mp l mq mr">        const newState = {<br/>          ...prevBrush,<br/>          start: { y: newExtent.y0, x: newExtent.x0 },<br/>          end: { y: newExtent.y1, x: newExtent.x1 },<br/>          extent: newExtent<br/>        };</span><span id="c9c2" class="mn lc iq mj b gy mv mp l mq mr">        return newState;<br/>      };<br/>      brushRef.current.updateBrush(updater);<br/>    }<br/>  };</span><span id="5182" class="mn lc iq mj b gy mv mp l mq mr">  return (<br/>    &lt;div&gt;<br/>      &lt;svg width={width} height={height}&gt;<br/>        &lt;LinearGradient<br/>          id={GRADIENT_ID}<br/>          from={background}<br/>          to={background2}<br/>          rotate={45}<br/>        /&gt;<br/>        &lt;rect<br/>          x={0}<br/>          y={0}<br/>          width={width}<br/>          height={height}<br/>          fill={`url(#${GRADIENT_ID})`}<br/>          rx={14}<br/>        /&gt;<br/>        &lt;AreaChart<br/>          hideBottomAxis={compact}<br/>          data={filteredStock}<br/>          width={width}<br/>          margin={{ ...margin, bottom: topChartBottomMargin }}<br/>          yMax={yMax}<br/>          xScale={dateScale}<br/>          yScale={stockScale}<br/>          gradientColor={background2}<br/>        /&gt;<br/>        &lt;AreaChart<br/>          hideBottomAxis<br/>          hideLeftAxis<br/>          data={stock}<br/>          width={width}<br/>          yMax={yBrushMax}<br/>          xScale={brushDateScale}<br/>          yScale={brushStockScale}<br/>          margin={brushMargin}<br/>          top={topChartHeight + topChartBottomMargin + margin.top}<br/>          gradientColor={background2}<br/>        &gt;<br/>          &lt;PatternLines<br/>            id={PATTERN_ID}<br/>            height={8}<br/>            width={8}<br/>            stroke={accentColor}<br/>            strokeWidth={1}<br/>            orientation={["diagonal"]}<br/>          /&gt;<br/>          &lt;Brush<br/>            xScale={brushDateScale}<br/>            yScale={brushStockScale}<br/>            width={xBrushMax}<br/>            height={yBrushMax}<br/>            margin={brushMargin}<br/>            handleSize={8}<br/>            innerRef={brushRef}<br/>            resizeTriggerAreas={["left", "right"]}<br/>            brushDirection="horizontal"<br/>            initialBrushPosition={initialBrushPosition}<br/>            onChange={onBrushChange}<br/>            onClick={() =&gt; setFilteredStock(stock)}<br/>            selectedBoxStyle={selectedBrushStyle}<br/>          /&gt;<br/>        &lt;/AreaChart&gt;<br/>      &lt;/svg&gt;<br/>      &lt;button onClick={handleClearClick}&gt;Clear&lt;/button&gt;&amp;nbsp;<br/>      &lt;button onClick={handleResetClick}&gt;Reset&lt;/button&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span><span id="354c" class="mn lc iq mj b gy mv mp l mq mr">export default function App() {<br/>  return (<br/>    &lt;div className="App"&gt;<br/>      &lt;BrushChart width="500" height="300" /&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><p id="3b4a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们使用<code class="fe ms mt mu mj b">appleStock</code>模拟数据来创建图表。</p><p id="ca80" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们只是从<code class="fe ms mt mu mj b">appleStock</code>数组中获取前 1000 个条目并渲染它们。</p><p id="0ee8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">brushMargin</code>是图表的页边距。</p><p id="81b2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们为颜色声明其他变量，比如为填充颜色声明<code class="fe ms mt mu mj b">accentColor</code>。</p><p id="7f85" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">background</code>和<code class="fe ms mt mu mj b">background2</code>为渐变色。</p><p id="29f5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">getDate</code>让我们从 x 轴的数据中获取日期。</p><p id="9fb2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">getStockValue</code>返回 y 轴的值。</p><p id="6aad" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们用填充的折线图创建<code class="fe ms mt mu mj b">AreaChart</code>组件。</p><p id="d50e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们使用<code class="fe ms mt mu mj b">axisBottomTickLabelProps</code>对象来设置 x 轴的样式。</p><p id="ba2c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用<code class="fe ms mt mu mj b">axisLeftTickLabelProps</code>对 y 轴做同样的操作。</p><p id="9833" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe ms mt mu mj b">AreaChart</code>组件中，我们添加了带有渐变的<code class="fe ms mt mu mj b">LinearGradient</code>组件，用于填充折线图。</p><p id="bbda" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">AreaClosed</code>在直线和 x 轴之间填充。</p><p id="190e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">AxisBottom</code>有 x 轴。<code class="fe ms mt mu mj b">scale</code>具有 x 轴刻度。<code class="fe ms mt mu mj b">top</code>设置 x 轴位置。</p><p id="bbd9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">AxisLeft</code>具有 y 轴。</p><p id="3053" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们创建<code class="fe ms mt mu mj b">BrushChart</code>组件来创建一个图表，让我们通过拖动它来导航填充的折线图。</p><p id="940d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有 th <code class="fe ms mt mu mj b">onBrushChange</code>函数来改变填充的折线图的位置。</p><p id="8f7b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们设置了<code class="fe ms mt mu mj b">innerHeight</code>、<code class="fe ms mt mu mj b">topChartBottomMargin</code>等。设置 x 轴和 y 轴的边距、高度和最大值。</p><p id="bc0c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用<code class="fe ms mt mu mj b">dateScale</code>、<code class="fe ms mt mu mj b">stockScale</code>、<code class="fe ms mt mu mj b">brushDateScale</code>和<code class="fe ms mt mu mj b">brushStockScale</code>来设置画笔图表的比例。</p><p id="959c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将<code class="fe ms mt mu mj b">initialBrushPosition</code>设置为一个值来设置笔刷图表的初始位置。</p><p id="21fd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们点击清除按钮时，我们也有<code class="fe ms mt mu mj b">handleClearClick</code>来清除画笔。</p><p id="a0ea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">handleResetClick</code>重置刷子位置。</p><p id="c1cf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们通过将 2 个<code class="fe ms mt mu mj b">AreaCharts</code>放在一起，将填充的折线图放在画笔图上。</p><p id="1374" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第一个用于主折线图，第二个用于导航。</p><p id="1f88" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">Brush</code>组件让我们拖动第二个折线图来导航第一个折线图。</p><h1 id="90f8" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="01ad" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过在 React 应用程序中使用画笔添加多个折线图来创建带导航的填充折线图。</p></div></div>    
</body>
</html>