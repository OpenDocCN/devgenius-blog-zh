<html>
<head>
<title>Every Thing About Stack Data Structure 😮</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于栈数据结构的一切😮</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/every-thing-about-stack-data-structure-f98b0130a0bd?source=collection_archive---------41-----------------------#2020-07-08">https://blog.devgenius.io/every-thing-about-stack-data-structure-f98b0130a0bd?source=collection_archive---------41-----------------------#2020-07-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="87bf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">本文包括括号平衡||数组中堆栈||链表中的堆栈||代码||以及更多解释。</strong></p><blockquote class="ki kj kk"><p id="885e" class="jk jl kl jm b jn jo jp jq jr js jt ju km jw jx jy kn ka kb kc ko ke kf kg kh ig bi translated">堆栈是一种线性数据结构，它遵循特定的操作执行顺序。</p></blockquote><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi kp"><img src="../Images/8a7bf0e6ee66e8ca8dabaf2eb7112868.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Rvm6FT5ihbAoZrEl"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">在<a class="ae lf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上<a class="ae lf" href="https://unsplash.com/@ffstop?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">的照片</a></figcaption></figure><p id="d60a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi lg translated">把书架想象成一摞书，假设你有6本书，你把它们放在桌子上，最后一本书放在上面，如果你想从书架上拿走一本书，它将是你书架上的第一本。因为它遵循后进先出法。</p><h1 id="dddf" class="lp lq in bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">为什么是Stack？</h1><p id="bac9" class="pw-post-body-paragraph jk jl in jm b jn mn jp jq jr mo jt ju jv mp jx jy jz mq kb kc kd mr kf kg kh ig bi translated"><strong class="jm io">让我们看看它的一些应用，我们用它的地方:</strong></p><h2 id="674e" class="ms lq in bd lr mt mu dn lv mv mw dp lz jv mx my md jz mz na mh kd nb nc ml nd bi translated">表达式评估</h2><blockquote class="ki kj kk"><p id="e6d9" class="jk jl kl jm b jn jo jp jq jr js jt ju km jw jx jy kn ka kb kc ko ke kf kg kh ig bi translated">想象一下，你给了一个表达式，你要求对它求值，然后存储在一个堆栈中。</p></blockquote><h2 id="28ba" class="ms lq in bd lr mt mu dn lv mv mw dp lz jv mx my md jz mz na mh kd nb nc ml nd bi translated">括号检查</h2><blockquote class="ki kj kk"><p id="70d1" class="jk jl kl jm b jn jo jp jq jr js jt ju km jw jx jy kn ka kb kc ko ke kf kg kh ig bi translated">假设你给了一个表达式为(54*6(5+7)+(90+6))，你要检查这个表达式是否有效。这里我们再次使用堆栈。<strong class="jm io">代码将在本文</strong>中</p></blockquote><h2 id="e7db" class="ms lq in bd lr mt mu dn lv mv mw dp lz jv mx my md jz mz na mh kd nb nc ml nd bi translated">递归函数</h2><blockquote class="ki kj kk"><p id="8a26" class="jk jl kl jm b jn jo jp jq jr js jt ju km jw jx jy kn ka kb kc ko ke kf kg kh ig bi translated">当你应用递归函数时，递归系统是基于一个叫做调用栈的栈。</p></blockquote><h1 id="01a4" class="lp lq in bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">收藏，关系，运营？</h1><p id="2c02" class="pw-post-body-paragraph jk jl in jm b jn mn jp jq jr mo jt ju jv mp jx jy jz mq kb kc kd mr kf kg kh ig bi translated">正如定义告诉它的那样，这种数据结构是基于项目和关系的集合之上的。有两种主要操作<strong class="jm io">弹出</strong>和<strong class="jm io">推动</strong>。Push是将一个项目添加到栈顶，POP是移除最后添加的顶层元素。因为它是基于后进先出的数据结构。我们将在本文后面看到代码示例。</p><h1 id="cd8f" class="lp lq in bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">在哪种数据结构中可以实现堆栈？</h1><p id="b5c9" class="pw-post-body-paragraph jk jl in jm b jn mn jp jq jr mo jt ju jv mp jx jy jz mq kb kc kd mr kf kg kh ig bi translated">你可以在数组和链表上实现堆栈。我们来了解一下哪个更好，为什么。假设你已经创建了一个大小为5的数组，其中有4个元素，你正在执行push操作，那么你的数组将会变满，不能再放入更多的元素，这是使用stack with array的最大缺点。当你使用链表时，它们会动态增加大小。</p><p id="413f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> <em class="kl">我们将看到使用堆栈</em> </strong>的数据结构的实现</p><h1 id="a136" class="lp lq in bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">使用数组堆栈(列表)</h1><p id="bcd3" class="pw-post-body-paragraph jk jl in jm b jn mn jp jq jr mo jt ju jv mp jx jy jz mq kb kc kd mr kf kg kh ig bi translated">现在，我们将用python实现代码，并使用array for Stack解释这些代码:</p><pre class="kq kr ks kt gt ne nf ng nh aw ni bi"><span id="c881" class="ms lq in nf b gy nj nk l nl nm">class Stack:<br/>  def __init__(self):<br/>    self.stack = []</span></pre><p id="009a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在上面的代码中，我们创建了一个空堆栈。现在我们将在同一个类中添加其他require操作方法。</p><pre class="kq kr ks kt gt ne nf ng nh aw ni bi"><span id="ef32" class="ms lq in nf b gy nj nk l nl nm">  def isEmpty(self):<br/>    return self.stack == []<br/>  <br/>  def push(self,ele):<br/>    self.stack.append(ele)</span><span id="626e" class="ms lq in nf b gy nn nk l nl nm">  def pop(self):<br/>    if not self.isEmpty():<br/>      return self.stack.pop()<br/>    else:<br/>      return -1<br/>  def peek(self):<br/>    if not self.isEmpty():<br/>      return self.stack[-1]<br/>    else:<br/>      return -1</span></pre><p id="0f18" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">isEmpty方法不检查堆栈是否为空，而push方法将一项追加到堆栈的末尾。Pop将首先检查列表是否为空，如果列表为空，它将返回-1，如果不是，它将删除最后一个元素。Peek将只显示最后一个元素。</p><p id="7fab" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在我们将创建一个实例，并在控制台中使用上述方法:</p><pre class="kq kr ks kt gt ne nf ng nh aw ni bi"><span id="292e" class="ms lq in nf b gy nj nk l nl nm">s = Stack()</span><span id="43f6" class="ms lq in nf b gy nn nk l nl nm">while True:<br/>  print("push")<br/>  print("pop")<br/>  print("peek")<br/>  do = input("What action you want to perform?")<br/>  if do == 'push':<br/>    ele = int(input("Enter the element which you want to push"))<br/>    s.push(ele)<br/>  elif do == 'pop':<br/>    ele = s.pop()<br/>    if ele == -1:<br/>      print("Stack is empty")<br/>    else:<br/>      print("Deleted element form Stack is = {0}".format(ele))<br/>  elif do == 'peek':<br/>    ele = s.peek()<br/>    if ele == -1:<br/>      print("Stack is empty")<br/>    else:  <br/>      print("Top of the stack element is = {}".format(ele))</span><span id="d20d" class="ms lq in nf b gy nn nk l nl nm">   else:<br/>     break</span></pre><p id="8498" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在上面的代码中，我们要求用户输入，并根据他们的输入给他们操作。</p><h1 id="cd19" class="lp lq in bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">使用链表堆栈</h1><p id="f500" class="pw-post-body-paragraph jk jl in jm b jn mn jp jq jr mo jt ju jv mp jx jy jz mq kb kc kd mr kf kg kh ig bi translated">现在，我们将使用堆栈的链表来实现python中的代码及其解释:</p><pre class="kq kr ks kt gt ne nf ng nh aw ni bi"><span id="7699" class="ms lq in nf b gy nj nk l nl nm">class Node:<br/>    def __init__(self,value):<br/>        self.value = value<br/>        self.next = None</span><span id="cec4" class="ms lq in nf b gy nn nk l nl nm">class Stack:<br/>    def __init__(self):<br/>        self.head = None<br/>    <br/>    def push(self,value):<br/>        if self.head is None:<br/>            self.head = Node(value)<br/>        else:<br/>            new_Node = Node(value)<br/>            new_Node.next = self.head<br/>            self.head = new_Node<br/>        <br/>    def pop(self):<br/>        if self.head is None:<br/>            return -1<br/>        else:<br/>            poppedEle = self.head.value<br/>            self.head = self.head.next<br/>            return poppedEle<br/>    def peek(self):<br/>        if self.head is None:<br/>            return -1<br/>        else:<br/>            peekEle = self.head.value<br/>            return peekEle<br/>s = Stack()</span><span id="6c62" class="ms lq in nf b gy nn nk l nl nm">while True:<br/>    print("push")<br/>    print("pop")<br/>    print("peek")<br/>    #print("display") if you wanna diplay your stack, travel the linked list.<br/>    do = input("What action you want to perform")<br/>    if do == 'push':<br/>        ele = int(input("Enter the element you want to push"))<br/>        s.push(ele)<br/>    elif do == 'pop':<br/>        ele = s.pop()<br/>        if ele == -1:<br/>            print("Stack is empty")<br/>        else:<br/>            print("Deleted element is = {0}".format(ele))<br/>    elif do == 'peek':<br/>        ele = s.peek()<br/>        if ele == -1:<br/>            print("Stack is empty")<br/>        else:<br/>            print("Peek element is : {}".format(ele))<br/>    else:<br/>        break</span></pre><p id="af62" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在上面的代码中，我们首先创建一个节点，然后是堆栈。在我们的堆栈中，我们执行所有需要的操作，并通过请求用户在控制台中发出命令来调用实例。</p><h1 id="195a" class="lp lq in bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">如何使用堆栈检查括号？</h1><p id="2a4c" class="pw-post-body-paragraph jk jl in jm b jn mn jp jq jr mo jt ju jv mp jx jy jz mq kb kc kd mr kf kg kh ig bi translated">堆栈是检查等式是否正确的最好方法。假设一个表达式为{5+(5 *3 ) / 4}，这个等式是对的，因为它是用相等且正确的大括号顺序排列的。但是{5 + (5 *4} /4不是一个正确的值，那么如何使用stack进行检查呢？</p><p id="3172" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在让我们为它编码:</p><pre class="kq kr ks kt gt ne nf ng nh aw ni bi"><span id="860b" class="ms lq in nf b gy nj nk l nl nm">class Parentheses:</span><span id="0adb" class="ms lq in nf b gy nn nk l nl nm">  def __init__(self):<br/>    self.stack = []</span><span id="3ec2" class="ms lq in nf b gy nn nk l nl nm">  def __init__(self,exp):<br/>    for i in range(len(exp)):<br/>      if exp[i] == '(' or exp[i] == '{' or exp[i] == '[': <br/>        self.stack.append(exp[i])<br/>        continue<br/>      <br/>      if len(self.stack) == 0:<br/>        return False<br/>    <br/>      if exp[i] == '(':<br/>        char = self.stack.pop()<br/>        if char != ')':<br/>          return False</span><span id="ec33" class="ms lq in nf b gy nn nk l nl nm">      if exp[i] == '{':<br/>        char = self.stack.pop()<br/>        if char != '}':<br/>          return False</span><span id="af75" class="ms lq in nf b gy nn nk l nl nm">      if exp[i] == '[':<br/>        char = self.stack.pop()<br/>        if char != ']':<br/>          return False</span><span id="5ea9" class="ms lq in nf b gy nn nk l nl nm">    if len(self.stack):<br/>      return False<br/>    else:<br/>      return True<br/>            <br/>            <br/>p = Parentheses()<br/>expre = input("Enter the expression")<br/>if p.check(expre):<br/>    print("Given expression is balanced")<br/>else:<br/>    print("Given expression is unbalanced")</span></pre><p id="a7a1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在上面的代码中，我们从用户那里获取一个字符串表达式，然后检查我们的条件，你可以很容易地理解上面的代码。</p></div><div class="ab cl no np hr nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="ig ih ii ij ik"><h1 id="e8b4" class="lp lq in bd lr ls nv lu lv lw nw ly lz ma nx mc md me ny mg mh mi nz mk ml mm bi translated">来源</h1><p id="b7c9" class="pw-post-body-paragraph jk jl in jm b jn mn jp jq jr mo jt ju jv mp jx jy jz mq kb kc kd mr kf kg kh ig bi translated">我的LinkedIn:-<a class="ae lf" href="https://www.linkedin.com/in/my-pro-file" rel="noopener ugc nofollow" target="_blank"><strong class="jm io">linkedin.com/in/my-pro-file</strong>T3】</a></p><h1 id="d408" class="lp lq in bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">您可能感兴趣的主题:</h1><ul class=""><li id="0ca5" class="oa ob in jm b jn mn jr mo jv oc jz od kd oe kh of og oh oi bi translated"><strong class="jm io">链表:</strong><a class="ae lf" href="https://medium.com/swlh/all-about-singly-linked-list-d69836814ace" rel="noopener">https://medium . com/swlh/all-about-single-Linked-List-d 69836814 ace</a></li><li id="43fa" class="oa ob in jm b jn oj jr ok jv ol jz om kd on kh of og oh oi bi translated"><strong class="jm io">合并排序</strong>:<a class="ae lf" href="https://medium.com/swlh/title-1692d9fb5ced" rel="noopener">https://medium.com/swlh/title-1692d9fb5ced</a></li><li id="d9b6" class="oa ob in jm b jn oj jr ok jv ol jz om kd on kh of og oh oi bi translated"><strong class="jm io">插入排序</strong>:<a class="ae lf" href="https://medium.com/dev-genius/insertion-sort-program-in-swift-31740a454573" rel="noopener">https://medium . com/dev-genius/Insertion-Sort-program-in-swift-31740 a 454573</a></li><li id="8b65" class="oa ob in jm b jn oj jr ok jv ol jz om kd on kh of og oh oi bi translated"><strong class="jm io">计数排序</strong>:<a class="ae lf" href="https://medium.com/@mdcode2021/counting-sort-algorithm-c32d71f2cc79" rel="noopener">https://medium . com/@ MD code 2021/Counting-Sort-algorithm-c 32d 71 F2 cc 79</a></li><li id="0d4b" class="oa ob in jm b jn oj jr ok jv ol jz om kd on kh of og oh oi bi translated"><strong class="jm io">选择排序</strong>:<a class="ae lf" href="https://medium.com/@mdcode2021/line-by-line-selection-sort-algorithm-explained-in-c-dd49638b15e" rel="noopener">https://medium . com/@ MD code 2021/line-by-line-Selection-Sort-algorithm-explained-in-c-DD 49638 b15e</a></li></ul></div></div>    
</body>
</html>