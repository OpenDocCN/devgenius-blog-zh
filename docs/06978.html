<html>
<head>
<title>How can you force react components to rerender without calling the set state?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在不调用 set 状态的情况下强制 react 组件重新呈现？</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-can-you-force-react-components-to-rerender-without-calling-the-set-state-ea0352cc6e8d?source=collection_archive---------13-----------------------#2022-02-15">https://blog.devgenius.io/how-can-you-force-react-components-to-rerender-without-calling-the-set-state-ea0352cc6e8d?source=collection_archive---------13-----------------------#2022-02-15</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/84243d75ba03fcbaa709527a09860a4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Cmw_ECO1UAYJ0RDjAC_n_g.jpeg"/></div></div></figure><p id="4151" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">每当 React 组件的道具或状态发生一些变化时，react 组件会自行重新渲染。简单地从代码中的随机位置更新状态，会导致用户界面(UI)元素自动重新呈现。</p><p id="913b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在类组件中，您可以选择调用 force update 来强制重新呈现。然而，在函数组件中，没有强制更新的机会，因为没有对等物，但是您可以选择在 useState 钩子的帮助下设计一种强制更新的方法。必须尝试并避免强制更新，因为它偏离了反应思维模式。React 文档列举了一些何时可以使用强制更新的例子。</p><p id="0c5b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">默认情况下，当组件的状态或属性发生变化时，组件将重新呈现。但是，如果存在隐式更改，如对象内部深层数据的更改，而对象本身也没有更改，或者如果您的渲染方法依赖于另一个数据，您可以选择告诉 React 只需通过调用 force update 来重新运行渲染。</p><h1 id="661c" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">强制更新:</h1><p id="c41f" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">然而，有人提出了一个想法，对于深度嵌套的对象，强制更新是必要的。在不可变数据源的帮助下，跟踪变化变得很便宜。变化总是会导致新的对象。因此，我们只需要检查对象引用是否已经改变。您甚至可以使用库不可变 JS 来将不可变数据对象实现到应用程序中。</p><p id="29d7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">通常，您必须尽量避免使用强制更新，并且应该只从这里读取。道具还有这个。呈现中的状态。这使得 react 组件变得“纯粹”,应用程序变得更加容易，同时也非常高效。更改要重新呈现的元素键将会起作用。您必须通过 state 在元素上设置 key prop，然后在您想要更新时将状态设置为具有新的键。</p><p id="be7e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">通过这样做，发生了一个变化，然后你需要重置这个键。setState ({key: Math。random })；您必须注意，这将帮助您替换正在更改密钥的元素。例如，当上传图像后，您希望重置一个文件输入字段时，它会非常有用。</p><h1 id="cb47" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">检查您的代码:</h1><p id="a3ec" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">此外，您必须注意，如果您正在使用强制更新，您可能想要检查您的代码，并检查是否有任何其他方法来做同样的事情。更改密钥)将完全替换该元素。如果您更新密钥以带来所需的更改，您可能会在代码中的某个地方遇到问题。因此利用数学。随机 n 键可以帮助您在每次渲染时重新创建元素。不建议以这种方式更新键，因为 react 使用键来有效地确定重新渲染事物的最佳可能方式。</p><p id="b1ed" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">React 开发人员努力解决应用程序中不必要的重新渲染组件。当一个组件不断在后台更新其数据，从而导致整体性能发生变化时，我们都经历过这种情况。</p><h1 id="ae9f" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">渲染的快速说明:</h1><p id="a017" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">React 的 createElement 函数有助于根据给定的元素类型创建和返回新元素。所有的更新都会在需要的时候自动完成。现在让我们看看重新渲染是如何在类以及功能组件中工作的。</p><p id="0b88" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下面是一些重新渲染 React 组件的方法。</p><p id="0e24" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">状态发生变化时重新渲染组件:</strong></p><p id="5154" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">每当 React 组件状态改变时，React 必须运行 render 方法。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="4e78" class="mf ku in mb b gy mg mh l mi mj">import React from 'react'<br/>export default class App extends React.Component {<br/> componentDidMount() {<br/>   this.setState({});<br/> }<br/> render() {<br/>   console.log('render() method')<br/>  return &lt;p&gt;Hi!&lt;p&gt;;<br/>}<br/>}</span></pre><p id="4ba5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在上面提到的例子中，组件安装时的状态被更新。<br/>你甚至可以选择重新呈现一个事件组件，例如，一个点击事件。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="b324" class="mf ku in mb b gy mg mh l mi mj">import React from "react";<br/> <br/>export default class App extends React.Component {<br/> state = {<br/>   mssg: ""<br/> };<br/> <br/> handleClick = () =&gt; {<br/>   this.setState({ mssg: "Hi there!" });<br/> };<br/> <br/> render() {<br/>   console.log("render() method");<br/>   return (<br/>     &lt;&gt;</span></pre><p id="fe13" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">{this.state.mssg}</p><p id="35b4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi">&lt;/&gt; ); } }</p><h2 id="d28f" class="mf ku in bd kv mk ml dn kz mm mn dp ld kg mo mp lh kk mq mr ll ko ms mt lp mu bi translated">输出:</h2><p id="19f2" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">说点什么</p><p id="984a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这两个输出看起来有点像这样:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="aff4" class="mf ku in mb b gy mg mh l mi mj">render() method <br/>render() method</span></pre><p id="0634" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">道具改变时重新渲染组件</strong></p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="86aa" class="mf ku in mb b gy mg mh l mi mj">import React from 'react'<br/> <br/>class Child extends React.Component {<br/> render() {<br/>   console.log('Child component: render()');<br/>   return<br/>}<br/>}</span></pre><p id="c6d3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在上面的例子中，<Child/>组件没有状态。但是，它有一个自定义属性，即它接受的消息。</p><p id="2b0e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当点击按钮时，它将更新<child/>组件，渲染生命周期将再次运行。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="7b89" class="mf ku in mb b gy mg mh l mi mj">Child component: render() <br/>Child component: render()</span></pre><p id="b627" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">用关键道具重新渲染:</strong></p><p id="9072" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您可以更改 key prop 的值，这将使 React 卸载并再次重新装载组件，并经历渲染生命周期。</p><p id="d66c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">强制重新渲染:</strong></p><p id="5174" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">非常不鼓励这种方法，也不推荐这种方法。你应该总是使用道具和状态来进行新的渲染。</p><p id="bea9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然而，这是你可以做的。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="bc9c" class="mf ku in mb b gy mg mh l mi mj">import React from 'react'<br/> <br/>export default class App extends React. Component {<br/> handleClick = () =&gt; {<br/>   // force a re-render<br/>   this.forceUpdate();<br/> };<br/> render() {<br/>   console.log('App component: render()')<br/>   return (<br/>     &lt;&gt;<br/>     &lt;/&gt;<br/>   );<br/> }<br/>}</span></pre><h2 id="e7e6" class="mf ku in bd kv mk ml dn kz mm mn dp ld kg mo mp lh kk mq mr ll ko ms mt lp mu bi translated">输出:</h2><p id="a520" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">说点什么</p><h1 id="357c" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">结论:</h1><p id="d946" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">你必须尝试使用上述资源，包括不同的例子和案例，使你的重新渲染计数。如果需要重新渲染 React 组件，应该始终更新组件状态和属性。</p><p id="3bbf" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">尝试避免使用关键道具进行重新渲染，因为这会使渲染变得更加复杂。尽管有一些奇怪的用例需要它。但是，您必须记住，不要使用强制更新来导致重新渲染。</p><p id="fa9b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">有任何疑问吗？或者需要 ReactJS 的任何服务？从 Bosc Tech 雇佣 react js 开发人员<a class="ae mv" href="https://bosctechlabs.com/hire-react-developer/" rel="noopener ugc nofollow" target="_blank">。今天就从我们的专家那里获得免费咨询！</a></p><p id="3558" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">内容来源:</strong><a class="ae mv" href="https://bosctechlabs.com/force-react-components-to-rerender-without-calling-set-state/" rel="noopener ugc nofollow" target="_blank">https://bosctechlabs . com/force-react-components-to-re render-without-calling-set-state/</a></p></div></div>    
</body>
</html>