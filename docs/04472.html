<html>
<head>
<title>Anemic Domain Model Anti-pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">贫血领域模型反模式</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/anemic-domain-model-anti-pattern-973de1af0c23?source=collection_archive---------1-----------------------#2021-03-21">https://blog.devgenius.io/anemic-domain-model-anti-pattern-973de1af0c23?source=collection_archive---------1-----------------------#2021-03-21</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/2023e1ac2c8cc77465025d4f18343284.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9Rryx6MJZ4qNlOBL"/></div></div></figure><h1 id="a608" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">封装—面向对象</h1><blockquote class="kt"><p id="bb59" class="ku kv in bd kw kx ky kz la lb lc ld dk translated">在面向对象编程(OOP)中，<strong class="ak">封装</strong>指的是将数据与对该数据进行操作的方法捆绑在一起，或者限制对某个对象组件的直接访问</p></blockquote><p id="6691" class="pw-post-body-paragraph le lf in lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma ld ig bi translated">在面向对象和封装之前，对象中的数据通常由其他实体访问。例如，要计算Kotlin中vector类的大小:</p><p id="19eb" class="pw-post-body-paragraph le lf in lg b lh mb lj lk ll mc ln lo lp md lr ls lt me lv lw lx mf lz ma ld ig bi translated"><em class="mg"> &lt;我选择Kotlin进行演示，因为它的语法不太冗长。然而，这种反模式同样适用于OOP &gt; </em>之后的所有语言</p><figure class="mh mi mj mk gt jo"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="c02f" class="pw-post-body-paragraph le lf in lg b lh mb lj lk ll mc ln lo lp md lr ls lt me lv lw lx mf lz ma ld ig bi translated">main函数通过像getters和setters这样的<em class="mg">访问函数来访问Vector类的字段。</em></p><p id="0454" class="pw-post-body-paragraph le lf in lg b lh mb lj lk ll mc ln lo lp md lr ls lt me lv lw lx mf lz ma ld ig bi translated"><em class="mg">(在<a class="ae mn" href="https://kotlinlang.org/" rel="noopener ugc nofollow" target="_blank"> Kotlin </a>，<em class="mg"> vector.x </em>中的</em>调用<em class="mg"> vector </em>类的自动生成的<em class="mg"> getX() </em>函数，该函数返回x的值。</p><p id="2b2e" class="pw-post-body-paragraph le lf in lg b lh mb lj lk ll mc ln lo lp md lr ls lt me lv lw lx mf lz ma ld ig bi translated">在这种模式下，调用者方法会因逻辑而变得臃肿，而且经常会导致重复，因为每个调用者方法都有自己的逻辑副本。</p><p id="f0ca" class="pw-post-body-paragraph le lf in lg b lh mb lj lk ll mc ln lo lp md lr ls lt me lv lw lx mf lz ma ld ig bi translated">如果这些方法是用面向对象的原则编写的，它应该是这样的</p><figure class="mh mi mj mk gt jo"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="6b01" class="pw-post-body-paragraph le lf in lg b lh mb lj lk ll mc ln lo lp md lr ls lt me lv lw lx mf lz ma ld ig bi translated">计算量级的逻辑已被移到Vector类中，更接近于数据。所有调用方法需要做的就是调用<em class="mg"> calculateMagnitude </em>函数来获得向量的大小。它不需要知道相同的逻辑。此外，由于避免了代码重复，对幅度计算逻辑的任何更改(如向vector类添加新维度)都将更容易进行，因为逻辑的代码封装在<em class="mg"> vector </em>类中。</p><h1 id="9d87" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">贫血领域模型反模式</h1><p id="e94b" class="pw-post-body-paragraph le lf in lg b lh mo lj lk ll mp ln lo lp mq lr ls lt mr lv lw lx ms lz ma ld ig bi translated">让我们来看看驾照门户的后端代码。门户有一个前端，当用户第一次登录时，它会问候用户。如果客户是成年人(18岁以上)，它将获取客户的驾照。</p><p id="00da" class="pw-post-body-paragraph le lf in lg b lh mb lj lk ll mc ln lo lp md lr ls lt me lv lw lx mf lz ma ld ig bi translated">通常有一个<em class="mg">服务</em>类来保存上述业务逻辑，并编排数据库和前端之间的数据。如果遵循贫血域模型，其代码如下</p><figure class="mh mi mj mk gt jo"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="a2bc" class="pw-post-body-paragraph le lf in lg b lh mb lj lk ll mc ln lo lp md lr ls lt me lv lw lx mf lz ma ld ig bi translated"><em class="mg">客户</em>数据类保存数据，而<em class="mg">客户服务</em>类拥有业务逻辑。但是很明显，检查客户是否是成年人的逻辑在服务中是“散乱的”,并且被需要它的不同功能所重复。此外，如果有更多的服务类需要检查，这些类中的逻辑也会被复制。</p><p id="7f64" class="pw-post-body-paragraph le lf in lg b lh mb lj lk ll mc ln lo lp md lr ls lt me lv lw lx mf lz ma ld ig bi translated">但是，如果将客户特定的逻辑移到客户数据类中，由于代码的模块化，CustomerService类会更精简。</p><figure class="mh mi mj mk gt jo"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="f17e" class="pw-post-body-paragraph le lf in lg b lh mb lj lk ll mc ln lo lp md lr ls lt me lv lw lx mf lz ma ld ig bi translated">这将通过将特定于域对象的逻辑限制到相应的类来确保封装，并且服务类的责任也将被限制到业务逻辑的编排。</p><p id="b9ad" class="pw-post-body-paragraph le lf in lg b lh mb lj lk ll mc ln lo lp md lr ls lt me lv lw lx mf lz ma ld ig bi translated"><strong class="lg io">参考文献:</strong></p><p id="eae8" class="pw-post-body-paragraph le lf in lg b lh mb lj lk ll mc ln lo lp md lr ls lt me lv lw lx mf lz ma ld ig bi translated"><a class="ae mn" href="https://www.infoworld.com/article/2075271/encapsulation-is-not-information-hiding.html" rel="noopener ugc nofollow" target="_blank">https://www . infoworld . com/article/2075271/encapsulation-is-not-information-hiding . html</a></p><div class="mt mu gp gr mv mw"><a href="https://www.martinfowler.com/bliki/AnemicDomainModel.html" rel="noopener  ugc nofollow" target="_blank"><div class="mx ab fo"><div class="my ab mz cl cj na"><h2 class="bd io gy z fp nb fr fs nc fu fw im bi translated">bliki: AnemicDomainModel</h2><div class="nd l"><h3 class="bd b gy z fp nb fr fs nc fu fw dk translated">这是一种已经存在了很长时间的反模式，但似乎有了特别的突破…</h3></div><div class="ne l"><p class="bd b dl z fp nb fr fs nc fu fw dk translated">www.martinfowler.com</p></div></div><div class="nf l"><div class="ng l nh ni nj nf nk jt mw"/></div></div></a></div><div class="mt mu gp gr mv mw"><a href="https://danielrusnok.medium.com/what-is-anemic-domain-model-and-why-it-can-be-harmful-2677b1b0a79a" rel="noopener follow" target="_blank"><div class="mx ab fo"><div class="my ab mz cl cj na"><h2 class="bd io gy z fp nb fr fs nc fu fw im bi translated">什么是贫血型糖尿病？为什么它会有害？</h2><div class="nd l"><h3 class="bd b gy z fp nb fr fs nc fu fw dk translated">贫血领域模型是软件开发中的一种常见方法，许多人甚至不知道他们正在使用它…</h3></div><div class="ne l"><p class="bd b dl z fp nb fr fs nc fu fw dk translated">danielrusnok.medium.com</p></div></div><div class="nf l"><div class="nl l nh ni nj nf nk jt mw"/></div></div></a></div><div class="mt mu gp gr mv mw"><a href="https://medium.com/@ahmed.badeir/anemic-model-vs-rich-model-fce9df58d09e" rel="noopener follow" target="_blank"><div class="mx ab fo"><div class="my ab mz cl cj na"><h2 class="bd io gy z fp nb fr fs nc fu fw im bi translated">贫血模型与富裕模型</h2><div class="nd l"><h3 class="bd b gy z fp nb fr fs nc fu fw dk translated">软件开发中最常见的反模式之一是“贫血模型”,在这篇文章中，我将解释…</h3></div><div class="ne l"><p class="bd b dl z fp nb fr fs nc fu fw dk translated">medium.com</p></div></div><div class="nf l"><div class="nm l nh ni nj nf nk jt mw"/></div></div></a></div><div class="mt mu gp gr mv mw"><a href="https://blog.latenightdev.net/rich-domain-models-for-the-win-696ddade1319" rel="noopener  ugc nofollow" target="_blank"><div class="mx ab fo"><div class="my ab mz cl cj na"><h2 class="bd io gy z fp nb fr fs nc fu fw im bi translated">丰富的领域模型赢得胜利！</h2><div class="nd l"><h3 class="bd b gy z fp nb fr fs nc fu fw dk translated">帮自己一个忙:现在停止编写贫血的领域模型</h3></div><div class="ne l"><p class="bd b dl z fp nb fr fs nc fu fw dk translated">blog.latenightdev.net</p></div></div><div class="nf l"><div class="nn l nh ni nj nf nk jt mw"/></div></div></a></div></div></div>    
</body>
</html>