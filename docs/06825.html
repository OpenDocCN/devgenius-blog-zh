<html>
<head>
<title>A Curious Tale of Late Initialisation Options — Part III</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一个关于后期初始化选项的奇怪故事——第三部分</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/a-curious-tale-of-late-initialisation-options-part-iii-e92d9f2abd79?source=collection_archive---------19-----------------------#2022-02-05">https://blog.devgenius.io/a-curious-tale-of-late-initialisation-options-part-iii-e92d9f2abd79?source=collection_archive---------19-----------------------#2022-02-05</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="8fa5" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">使用 Kotlin 的后期初始化选项导航内存泄漏和线程安全</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/cc1286ae303f15eb0e46345d1112388a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YT4DyM6q0bq9UyXs"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">照片由<a class="ae ks" href="http://guerrillabuzz.com/" rel="noopener ugc nofollow" target="_blank"> GuerrillaBuzz Crypto PR </a>在<a class="ae ks" href="https://unsplash.com/@theshubhamdhage?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></figcaption></figure><p id="be52" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在本系列的最后一部分，我将重构<code class="fe lp lq lr ls b">Behaviour</code>接口及其实现，并将更改和错误修复合并到我们在第二部分中编写的<a class="ae ks" href="https://bendaniel10.medium.com/a-curious-tale-of-late-initialisation-options-part-ii-339a85e08961" rel="noopener">代码中。</a></p><h2 id="6a3e" class="lt lu in bd lv lw lx dn ly lz ma dp mb lc mc md me lg mf mg mh lk mi mj mk ml bi translated">解决方案:API 返工、错误修复</h2><p id="7275" class="pw-post-body-paragraph kt ku in kv b kw mm jo ky kz mn jr lb lc mo le lf lg mp li lj lk mq lm ln lo ig bi translated">重要的事情先来。让我们更新一下<code class="fe lp lq lr ls b">Behaviour</code>接口，并添加分离单个<code class="fe lp lq lr ls b">Item</code>的功能。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="7ca3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">实现也将被更新，以从项目中删除行为。但在此之前，让我们重新思考我们的方法。</p><p id="7bc2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">本系列从找出最安全和最不痛苦的方法开始，将在<code class="fe lp lq lr ls b">onAttach(item)</code>方法中收到的<code class="fe lp lq lr ls b">item</code>保留在<code class="fe lp lq lr ls b">Behaviour</code>的单例实例上。我们选择将该属性保留为可空属性，并在分离行为时清除它。</p><p id="5110" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果我们不需要来保留<code class="fe lp lq lr ls b">item</code>作为一个属性呢？我们是否可以将收到的<code class="fe lp lq lr ls b">item</code>下行传递给任何需要知道它在做什么的方法？我想这个会有用的。</p><p id="b521" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">其次，我们需要将一个附加的<code class="fe lp lq lr ls b">item</code>关联到具体的<code class="fe lp lq lr ls b">apiCallThread</code>。这样我们可以确保无论何时<code class="fe lp lq lr ls b">Behaviour</code>从<code class="fe lp lq lr ls b">item</code>上拆下，正确的<code class="fe lp lq lr ls b">apiCallThread</code>都会被中断。我认为我们可以使用一个<code class="fe lp lq lr ls b">ConcurrentHashMap&lt;Int, Thread&gt;()</code>来处理这个映射；这个 Map 实现支持并发的写和读。</p><p id="88bd" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这是更新的解决方案:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="bf70" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在我们唯一的财产就是<code class="fe lp lq lr ls b">apiCallThreadsMap</code>。这是帮助我们将附加的<code class="fe lp lq lr ls b">item</code>关联到特定的<code class="fe lp lq lr ls b">apiCallThread</code>的图。</p><p id="dc8a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">请注意，<code class="fe lp lq lr ls b">item</code>正在向下游传递给任何需要它的人。这反映在新的<code class="fe lp lq lr ls b">echo(item)</code>方法签名和<code class="fe lp lq lr ls b">then: (item: Item) -&gt; Unit</code> lamda 中。这样做的一个好处是，我们不需要以安全的方式访问<code class="fe lp lq lr ls b">item.name</code>，因为它不再是可空类型。</p><p id="71cb" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们使用破坏代码的最后一个片段来测试更新后的代码。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mr ms l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">机械臂故意不分离，进一步阅读:)</figcaption></figure><p id="e1a4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这是输出:</p><pre class="kd ke kf kg gt mu ls mv mw aw mx bi"><span id="cb1c" class="lt lu in ls b gy my mz l na nb">Calling API for Robot arm from Thread-0<br/>Calling API for Robot face from Thread-1<br/>Detaching Item(name=Robot face) from main, interrupted Thread-1<br/>Interrupted, fun ...echo(Item)... not called from Thread-1<br/>Attaching, Robot arm from Thread-0</span></pre><p id="605c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">忠太🎉。现在效果很好。开发人员可以随时附加和分离单个项目。此外，不会覆盖任何线程。</p><p id="ceb2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们用 3 个项目再次尝试代码，并在不同的时间间隔分离所有项目。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="8d27" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在，我们甚至在拆下之前连接的一个<code class="fe lp lq lr ls b">item</code>后再连接一个。代码应该运行良好(剧透，确实如此)。</p><pre class="kd ke kf kg gt mu ls mv mw aw mx bi"><span id="5d66" class="lt lu in ls b gy my mz l na nb">Calling API for Robot arm from Thread-0<br/>Calling API for Robot face from Thread-1<br/>Detaching Item(name=Robot face) from main, interrupted Thread-1<br/>Detaching Item(name=Robot arm) from main, interrupted Thread-0<br/>Detaching Item(name=Robot wing) from main, interrupted Thread-2<br/>Calling API for Robot wing from Thread-2<br/>Interrupted, fun ...echo(Item)... not called from Thread-0<br/>Interrupted, fun ...echo(Item)... not called from Thread-1<br/>Interrupted, fun ...echo(Item)... not called from Thread-2</span></pre><p id="9a3b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">咻。</p></div><div class="ab cl nc nd hr ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="ig ih ii ij ik"><p id="7692" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我发现在设计 API 时应该考虑多少事情是很有趣的。我用了一个简单的例子来说明这一点，我们已经看到了为了适应许多重要的情况，代码被调整得多么健壮。</p><p id="fa9f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我从这次经历中得到的主要收获是:</p><ul class=""><li id="dcb2" class="nj nk in kv b kw kx kz la lc nl lg nm lk nn lo no np nq nr bi translated">仅在绝对必要时使用属性</li><li id="f95e" class="nj nk in kv b kw ns kz nt lc nu lg nv lk nw lo no np nq nr bi translated">任何形式的并发都可能暴露一段代码中丑陋的部分，在编写任何 API 时要记住这一点</li><li id="5426" class="nj nk in kv b kw ns kz nt lc nu lg nv lk nw lo no np nq nr bi translated">不要忘记清理资源。了解您在内部使用的 API 的生命周期，并在将它们设置为 null 之前清理它们的实例</li><li id="87d2" class="nj nk in kv b kw ns kz nt lc nu lg nv lk nw lo no np nq nr bi translated">阅读文档</li></ul><p id="6f5b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">谢谢你跟随我经历这个思考过程。我真的希望你能从中吸取一些东西。</p><p id="5b9f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">✌之二🏽。</p></div></div>    
</body>
</html>