<html>
<head>
<title>Send information from Databricks to Airflow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将信息从数据块发送到气流</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/send-information-from-databricks-to-airflow-810a7d49ff81?source=collection_archive---------2-----------------------#2022-12-12">https://blog.devgenius.io/send-information-from-databricks-to-airflow-810a7d49ff81?source=collection_archive---------2-----------------------#2022-12-12</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/8d9d5e75315cd3f25415c48c6efff5fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5LiWJglzy0fY9HQbAJU54w.png"/></div></div></figure><h1 id="6ac0" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">从数据块到气流</h1><p id="d20a" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">有时，我们需要将 Databricks 作业的输出发送到 Airflow，并采取行动(或不采取行动)，根据此 Databricks 作业上发生的情况分支 dag 的后续步骤。</p><p id="9940" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">我已经寻找，我已经阅读了许多文件，我找不到比这个更好的解决方案。所以开始了。</p><h2 id="3f57" class="lw jw in bd jx lx ly dn kb lz ma dp kf le mb mc kj li md me kn lm mf mg kr mh bi translated">退出方法</h2><p id="b323" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">仍然是在<a class="ae mi" href="https://docs.databricks.com/notebooks/notebook-workflows.html" rel="noopener ugc nofollow" target="_blank"> dbutils </a>库中，您可以选择从笔记本中退出，并不完全是一个错误，即使它是意想不到的。因此，您可以使用下面的场景和选项来避免在运行时出现“失败”状态，而不是引发错误:</p><p id="db60" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">案例:您的作业运行来转换数据批次，这个特定的小批次带有一个完整的空列。嗯，这是有可能发生的。这不是错误。如果你用微型手表工作，这只是一件很随意的事情。让我们假设这不值得为您的业务规则发出警告，(并且仍然需要出现在日志中)。所以你可以用这种方式轻轻放下你的死刑:</p><pre class="mj mk ml mm gt mn mo mp bn mq mr bi"><span id="23a6" class="ms jw in mo b be mt mu l mv mw">dbutils.notebook.exit('received the x null column')</span></pre><p id="5796" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">在 exit 函数中，您可以发送一条消息。在这种情况下，您的跑步将作为成功退出。你的信息会出现在日志上。</p><p id="1a81" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">碰巧…</p><ul class=""><li id="6d1d" class="mx my in kv b kw lr la ls le mz li na lm nb lq nc nd ne nf bi translated">你有且只有一个<strong class="kv io">一个</strong> <strong class="kv io">对象</strong>可以通过 exit 方法发送。一个数字，一个字符串，一个布尔，一个字典等。因此，您可以发送/使用:</li></ul><p id="e936" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">-exit(1)<br/>-exit(' string message ')<br/>-exit(False)<br/>-exit(dictionary)<br/>或者 exit(dataframe？？我还是没考)</p><ul class=""><li id="a669" class="mx my in kv b kw lr la ls le mz li na lm nb lq nc nd ne nf bi translated">但实际上这个<strong class="kv io">唯一的</strong>对象将强制成为一个字符串。Databricks <strong class="kv io">将把这个对象转换成一个字符串。似乎他们已经鼓励我们以字符串形式发送了:</strong></li></ul><figure class="mj mk ml mm gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ng"><img src="../Images/dbe344c2949eea654e9c37705241e5a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ux2mlVzYxmk6No4iv9NHGw.png"/></div></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk translated">“使用 dbutils.notebook.exit()[…]，只能返回<strong class="bd jx">一个字符串</strong>”。来源:<a class="ae mi" href="https://docs.databricks.com/notebooks/notebook-workflows.html" rel="noopener ugc nofollow" target="_blank">https://docs . databricks . com/notebooks/notebook-workflows . html</a></figcaption></figure><p id="90cb" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">嗯，不是这样的。我发了一个 json，number，bool，Databricks 没有抱怨。他们只是把我的信息转换成一个字符串，不管它以前是什么。<em class="nl">所以当你在你的 airflow 作业</em>中处理这个输出时，你需要注意它，无论你发送什么，当它到达 Airflow 时，它将是一个字符串。</p><h2 id="db05" class="lw jw in bd jx lx ly dn kb lz ma dp kf le mb mc kj li md me kn lm mf mg kr mh bi translated">正在检索退出消息</h2><p id="c798" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">为了检索 Databricks 作业的输出，您需要向 Databricks API 发出 GET 请求。为此，有一个“操作符”(这个操作符实际上可以处理 Databricks 的 API 支持的几乎所有类型的请求)。</p><p id="4670" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">为了获得运行的输出，我们需要来自作业 jun 的唯一信息，即它的 RUN_ID。每个 Databricks 操作符(submit、run 等)都有一个参数，指定它是否应该推送包含该作业的 run_id 和 url_page 的 xcoms。url_page 是包含整个运行的 url(您可以通过 UI 获得这个 URL，并读取输出/日志/输入 JSON/日期和时间/持续时间等)。run_id 是曾经在数据块上运行的每个作业的唯一 id，它标识每个单独的运行。</p><p id="0971" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">此代码片段显示了一个 SubmitRunOperator，它触发一个名为 GDP-2073 的笔记本，将一个字典传递给 base_parameters 作为作业要使用的信息，并将 do_xcom_push 设置为 True:</p><pre class="mj mk ml mm gt mn mo mp bn mq mr bi"><span id="76ce" class="ms jw in mo b be mt mu l mv mw">from airflow.providers.databricks.operators.databricks import DatabricksSubmitRunOperator<br/>from dag_validation_conciliacao.templates.variables import variable_validation<br/><br/>run_validation_for_boleto = DatabricksSubmitRunOperator(<br/>        task_id=f'validation_boleto', <br/>        existing_cluster_id=DATABRICKS_DEFAULT_CLUSTER_ID,<br/>        databricks_conn_id="iguazu_databricks",<br/>        notebook_task = {<br/>            'notebook_path': '/Users/minhadona/GDP-2073',<br/>            'base_parameters': variable_validation['boleto'] # https://docs.databricks.com/dev-tools/api/2.0/jobs.html#jobsnotebooktask<br/>                                },<br/>        do_xcom_push = True<br/>        )</span></pre><p id="5ca3" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">运行成功后，单击您提交的 Databricks 操作符任务，并找到它的 Xcoms:</p><figure class="mj mk ml mm gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nm"><img src="../Images/d593fc23969aa13e3c4f551cc6c0ebdc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e95NEE1b-8Um2GP0t8m8tQ.jpeg"/></div></div></figure><p id="c790" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">您可以看到该任务已经创建了两个 xcom:<strong class="kv io">run _ id</strong>和<strong class="kv io"> run_page_url </strong>。</p><figure class="mj mk ml mm gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nm"><img src="../Images/1ce2ba3f22661cc76ad907dfc118880f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2IGp21D9dzod-1y2joeGSA.jpeg"/></div></div></figure><p id="a880" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">如果您复制并粘贴此 URL，您将在每次单元执行此运行(以及由 base_parameters 获得的参数)后找到带有代码+日志的数据块页面 UI:</p><figure class="mj mk ml mm gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nn"><img src="../Images/0067e17b26ec85b319a0fc6f3ff74a67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZYRbgXUiAUAEfsPSoLlTkA.png"/></div></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk translated">实例化 DatabricksSubmit 运算符时 base_parameters 参数收到的运行 ID 和参数</figcaption></figure><p id="0fb9" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">附注:你也可以看到 URL 包含了 run_id:</p><figure class="mj mk ml mm gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi no"><img src="../Images/6ca9ffac276e3a23cddaa8f62befec0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*irFPbAmtx3qzUTpxF_yv5g.png"/></div></div></figure><h2 id="e404" class="lw jw in bd jx lx ly dn kb lz ma dp kf le mb mc kj li md me kn lm mf mg kr mh bi translated">数据块提供程序:数据块钩子</h2><p id="56f3" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">为了获得这个笔记本的输出(exit 对象)，我们将向这个 run  URL 发出一个请求<strong class="kv io"> <em class="nl">。为此，您可以通过调用<a class="ae mi" href="https://airflow.apache.org/docs/apache-airflow-providers-databricks/1.0.0/_api/airflow/providers/databricks/hooks/databricks/index.html#airflow.providers.databricks.hooks.databricks.DatabricksHook._do_api_call" rel="noopener ugc nofollow" target="_blank"> <em class="nl"> _do_api_call </em> </a>方法，使用<strong class="kv io">请求库</strong>来操作数据块 API 端点或<strong class="kv io">自己的数据块钩子库</strong>。</em></strong></p><p id="014e" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">唯一需要的参数是 run_id。这正是因为<strong class="kv io"> run_id 是</strong>一个已执行的笔记本/python 作业的唯一标识符。如下面的代码所示:</p><pre class="mj mk ml mm gt mn mo mp bn mq mr bi"><span id="e5f9" class="ms jw in mo b be mt mu l mv mw">from airflow import DAG<br/>from airflow.providers.databricks.hooks.databricks import DatabricksHook<br/>from airflow.decorators import task<br/><br/>@task(task_id=f'get_result_validation_boleto', retries=2)<br/>    def get_result_boleto(ti=None):<br/>            run_id = ti.xcom_pull('validation_boleto', key='run_id') # pull the run_id pushed from another task<br/>            print(f'|run_id|: {run_id}')<br/>            run_page_url = ti.xcom_pull('validation_boleto', key='run_page_url')<br/>            print(f'|run_page_url|: {run_page_url}')<br/>            databricks_hook = DatabricksHook(databricks_conn_id="CONNECTION_ID_TO_YOUR_DATABRICKS")<br/>            result = databricks_hook._do_api_call(("GET", f"api/2.0/jobs/runs/get-output?run_id={run_id}"), {} )<br/>            print(f'|result|: {result}')<br/>            output_run = result["notebook_output"]["result"]<br/>            print(f'|output_run|: {output_run}\n |output_run_type|: {type(output_run)}') #always string<br/>            import json <br/>            output_run = json.loads(output_run) # now the string will be pushed as json to a xcom<br/>            print(f'|output_run max_timestamp|: {output_run["max_timestamp"]["0"]}')<br/>            ti.xcom_push(key=f'databricks_output_validation_boleto',value = output_run) <br/>    get_result_boleto = get_result_boleto()</span></pre><p id="940b" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">这段代码检索笔记本输出，将其转换为 json(它被转换为 string)并使用键<em class="nl">data bricks _ output _ validation _ boleto</em>推送到另一个 Xcom，这样我们就可以在下一个任务中使用它了！</p><p id="b27e" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">通过点击这个<em class="nl">get _ result _ validation _ boleto</em>任务，我们将能够看到作为 json 推送的 XCOM(它是使用我想要作为 Databricks 笔记本上的输出发送的 dataframe 生成的，因此下一步将取决于<em class="nl"> count_of_rows </em>列的值)。</p><figure class="mj mk ml mm gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi np"><img src="../Images/b5242b617b4216a010bcee8c65c08a5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UXW3ohqP3GdvZxjKvhrppw.png"/></div></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk translated">向 Databricks run_id 发出 GET 请求并接收通过 dbutils.exit()方法传递的值作为答案后，推送的 Xcom。</figcaption></figure><p id="ad96" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">因此，如果你迭代一个字典，对于每个键，你通过 base_parameters，一个新的任务被创建，因此一个新的作业运行将…嗯…用新获得的参数运行。这个新的运行将有一个惟一的 run_id，下一个也是，下一个也是……对于每个运行，您可以使用这个方法来检索 Databricks 输出，评估或推送到可用于其他任务的新 Xcoms。</p><h2 id="6ca3" class="lw jw in bd jx lx ly dn kb lz ma dp kf le mb mc kj li md me kn lm mf mg kr mh bi translated">我是这样把表作为 json 发送回去的:</h2><figure class="mj mk ml mm gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nq"><img src="../Images/4cb1175a2e06794e1435a499db4417df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XS192akUNYXWjg0c2PS5bQ.png"/></div></div></figure><p id="28f1" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">我们的目的是简单地将这个 json 文件转换成 Pandas dataframe，然后返回到 Airflow，这样我们就可以操作/查阅甚至通过电子邮件发送这个最后的小表格。</p></div></div>    
</body>
</html>