<html>
<head>
<title>AWS Lambda Caching? Why? and How?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">AWS Lambda 缓存？为什么？又是怎么做到的？</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/aws-lambda-caching-why-and-how-bd3c2d500c?source=collection_archive---------0-----------------------#2022-08-03">https://blog.devgenius.io/aws-lambda-caching-why-and-how-bd3c2d500c?source=collection_archive---------0-----------------------#2022-08-03</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/b964375827aff84d0f54b6050cc1fbcd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Tkbh-VHPrkZYq2fcPwHffA.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">使用 Lambda 缓存</figcaption></figure><p id="c93a" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi kx translated"><span class="l ky kz la bm lb lc ld le lf di">W</span>T2】hy？</p><p id="58f6" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">AWS Lambda 中的缓存策略是我在编写代码时不常考虑的，特别是当需求集中在执行一个原子任务时，众所周知，运行 Lambda 函数的成本很低，通常不超过几秒钟就可以满足调用请求。</p><p id="dd04" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">对 Lambda 生命周期的误解以及 Lambda 依赖第三方数据的情况可能会导致一些性能问题。</p><p id="5d2b" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">例如，我遇到了一个场景，Lambda 每次需要向<em class="lg"> confluent Kafka </em>主题发布<em class="lg"> Avro </em>消息时，都必须从<em class="lg"> confluent Kafka registry </em>获取一些 Avro 模式，由于在代码中保存模式是一个糟糕的做法，因为模式可能随时发生变化，这将要求我们在所有环境中重新部署 Lambda，我想到了一种可以缓存模式，并定期刷新这些模式并将它们从模式注册表中取出的方法。</p><p id="ac2a" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">促使我探索 Lambda 函数的缓存选项的两个原因是:</p><ul class=""><li id="4126" class="lh li in kb b kc kd kg kh kk lj ko lk ks ll kw lm ln lo lp bi translated">调用 AWS 帐户之外的另一个服务的成本，在那里我们运行 lambda 函数。</li><li id="7c78" class="lh li in kb b kc lq kg lr kk ls ko lt ks lu kw lm ln lo lp bi translated">对被叫服务的配额限制(在某些情况下，你被限制在每秒一定数量的呼叫)。</li></ul><p id="8611" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi kx translated"><span class="l ky kz la bm lb lc ld le lf di">H</span>T12】ow？</p><p id="76b1" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">根据<strong class="kb io"> <em class="lg"> CloudGuru </em> </strong>的分析，“<em class="lg"> AWS Lambda 通常会在 45-60 分钟的不活动状态后终止功能，尽管空闲功能有时可以提前很多时间终止，以释放其他客户所需的资源。”</em></p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lv"><img src="../Images/edf424aede1fe5cb98dc7816324903d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uc-V-1D03an2J9PuOMMpjQ.png"/></div></div></figure><p id="3b40" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这意味着 Lambda 将处于<strong class="kb io"> <em class="lg"> warm </em> </strong>状态，并准备好接收调用，它不会在处理一个事件后立即消失，所以如果 Lambda 经常被调用，考虑缓存是一个好主意。以下是一些可用的选项，可以帮助您提高性能并最大限度地减少服务时间:</p><blockquote class="ma"><p id="c901" class="mb mc in bd md me mf mg mh mi mj kw dk translated">Lambda 运行时环境中的缓存</p></blockquote><p id="c3a0" class="pw-post-body-paragraph jz ka in kb b kc mk ke kf kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw ig bi translated">这个选项是最容易实现的，开发人员不需要特意设置任何基础设施，或者使用其他库。</p><p id="126e" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">通过在处理程序范围之外定义一个<strong class="kb io">全局</strong>变量<em class="lg">，并在 Lambda 第一次被调用时初始化它，只要 Lambda 还活着<em class="lg"/>，你就可以访问变量值。</em></p><p id="eeb1" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在下面的代码中，我在<em class="lg">处理程序</em>作用域之外的<strong class="kb io">全局</strong>作用域中定义了<em class="lg">模式</em>，并使用<em class="lg"> fetch_schema() </em>函数在<strong class="kb io"> <em class="lg"> null </em> </strong>的情况下初始化模式，或者如果不是第一次调用 Lambda，则返回<strong class="kb io"> <em class="lg">缓存的</em> </strong>模式。</p><pre class="lw lx ly lz gt mp mq mr ms aw mt bi"><span id="3371" class="mu mv in mq b gy mw mx l my mz">import json<br/><br/>schema = ""<br/><br/>def lambda_handler(event, context):<br/><strong class="mq io">    global schema<br/></strong>    schema = fetch_schema()<br/>    return {<br/>        'statusCode': 200,<br/>        'body': json.dumps('Hello from Lambda!')<br/>    }<br/>    <br/>def fetch_schema():<br/><strong class="mq io">    global schema<br/></strong>    print("Schema is : "+ schema)<br/>    if not schema:<br/>        # call schema registery and fetch schema <br/>        schema = fetch_schema_by_id_from_registry()<br/>    return schema <br/>        <br/><br/>def fetch_schema_by_id_from_registry():<br/>    print("Getting schema Id thru SchemaRegistryClient")<br/>    return "hey there"</span></pre><blockquote class="ma"><p id="4a0e" class="mb mc in bd md me na nb nc nd ne kw dk translated">2)缓存工具 python 库</p></blockquote><p id="c9b9" class="pw-post-body-paragraph jz ka in kb b kc mk ke kf kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw ig bi translated">第二个选项也很容易实现，但是你必须使用<strong class="kb io"> <em class="lg"> Cachetools </em> </strong>库来管理 Lambda 中的缓存。</p><blockquote class="nf ng nh"><p id="a75f" class="jz ka lg kb b kc kd ke kf kg kh ki kj ni kl km kn nj kp kq kr nk kt ku kv kw ig bi translated">这个模块提供了各种记忆集合和装饰器，包括 Python 标准库的<a class="ae nl" href="http://docs.python.org/3/library/functools.html#functools.lru_cache" rel="noopener ugc nofollow" target="_blank"> @lru_cache </a>函数装饰器的变体。对于本模块来说，<em class="in">缓存</em>是一个固定最大大小的<a class="ae nl" href="http://docs.python.org/dev/glossary.html#term-mutable" rel="noopener ugc nofollow" target="_blank">可变</a>映射<a class="ae nl" href="http://docs.python.org/dev/glossary.html#term-mapping" rel="noopener ugc nofollow" target="_blank">。当缓存已满时，即通过添加另一个项目，缓存将超过其最大大小，缓存必须基于合适的</a><a class="ae nl" href="http://en.wikipedia.org/wiki/Cache_algorithms" rel="noopener ugc nofollow" target="_blank">缓存算法</a>选择要丢弃的项目。<br/>来源:<a class="ae nl" href="https://pypi.org/project/cachetools/" rel="noopener ugc nofollow" target="_blank">https://pypi.org/project/cachetools/</a></p></blockquote><pre class="lw lx ly lz gt mp mq mr ms aw mt bi"><span id="371b" class="mu mv in mq b gy mw mx l my mz">import json<br/>from cachetools import cached, LRUCache, TTLCache<br/><br/><br/>def lambda_handler(event, context):<br/>    schemaId = event['schemaId']<br/>    schema = fetch_schema(schemaId)<br/>    return {<br/>        'statusCode': 200,<br/>        'body': json.dumps('Hello from Lambda!')<br/>    }<br/><br/><strong class="mq io">@cached(cache=TTLCache(maxsize=1024, ttl=600))<br/></strong>def fetch_schema(schemaId):<br/>    return fetch_schema_by_id_from_registry()<br/><br/><br/>def fetch_schema_by_id_from_registry():<br/>    print("Getting schema Id thru SchemaRegistryClient")<br/>    return "hey there"</span></pre><blockquote class="ma"><p id="c120" class="mb mc in bd md me na nb nc nd ne kw dk translated">3) Lambda 缓存 python 库</p></blockquote><p id="f406" class="pw-post-body-paragraph jz ka in kb b kc mk ke kf kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw ig bi translated"><em class="lg"> lambda-cache </em>帮助你从一个调用到另一个调用缓存 lambda 函数中的数据。它利用 lambda 函数的<a class="ae nl" href="https://docs.aws.amazon.com/lambda/latest/dg/runtimes-context.html" rel="noopener ugc nofollow" target="_blank">执行上下文</a>的内部存储器来跨多个调用存储数据，这:</p><ul class=""><li id="28c5" class="lh li in kb b kc kd kg kh kk lj ko lk ks ll kw lm ln lo lp bi translated">减少后端系统的负载</li><li id="5295" class="lh li in kb b kc lq kg lr kk ls ko lt ks lu kw lm ln lo lp bi translated">减少 lambda 的执行时间</li><li id="11bb" class="lh li in kb b kc lq kg lr kk ls ko lt ks lu kw lm ln lo lp bi translated">保证函数在缓存过期后引用最新数据</li></ul><h2 id="c4d2" class="mu mv in bd nm nn no dn np nq nr dp ns kk nt nu nv ko nw nx ny ks nz oa ob oc bi translated">使用 Lambda 缓存库提供了 3 个选项:</h2><ul class=""><li id="c720" class="lh li in kb b kc od kg oe kk of ko og ks oh kw lm ln lo lp bi translated">缓存单个参数</li><li id="e860" class="lh li in kb b kc lq kg lr kk ls ko lt ks lu kw lm ln lo lp bi translated">机密管理器中的缓存</li><li id="f106" class="lh li in kb b kc lq kg lr kk ls ko lt ks lu kw lm ln lo lp bi translated">S3 的缓存</li></ul><pre class="lw lx ly lz gt mp mq mr ms aw mt bi"><span id="d7d3" class="mu mv in mq b gy mw mx l my mz">@ssm.cache(parameter='/production/app/var1', max_age_in_seconds=30)<br/>@ssm.cache(parameter='/production/app/var2', max_age_in_seconds=60)<br/>def handler(event, context):<br/>  var1 = getattr(context,'var1')<br/>  var2 = getattr(context,'var2')<br/>  response = do_something(var)<br/>    return response</span></pre><blockquote class="ma"><p id="63aa" class="mb mc in bd md me na nb nc nd ne kw dk translated">比较不同的数据存储选项</p></blockquote><p id="77f3" class="pw-post-body-paragraph jz ka in kb b kc mk ke kf kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw ig bi translated">AWS 网站上的下表提供了不同数据存储选项之间的比较，正如您可以在(1)中看到的，它被认为是最快的，因为数据被缓存在 Lambda 函数中，但有大小限制。(2)如果您担心文件大小，S3 更合适，但是它比选项(1)慢，因为 Lambda 必须从 S3 请求数据。</p><p id="df45" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">因此，要选择一个缓存选项，您必须考虑您的情况:<br/> 1)我是否有一个大文件要缓存？还是小的？— <strong class="kb io">内存</strong>T3】2)数据/文件多久更改一次？— <strong class="kb io">频率</strong> <br/> 3)如果需要，我如何恢复缓存？— <strong class="kb io">缓存控制</strong></p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi oi"><img src="../Images/5bab6557f440e81d997a16a1ed5574cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ncUblO-qkP7TaBwDbxXRzA.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">来源:<a class="ae nl" href="https://aws.amazon.com/blogs/compute/choosing-between-aws-lambda-data-storage-options-in-web-apps/" rel="noopener ugc nofollow" target="_blank">https://AWS . Amazon . com/blogs/compute/choosing-between-AWS-lambda-data-storage-options-in-we B- apps/</a></figcaption></figure></div></div>    
</body>
</html>