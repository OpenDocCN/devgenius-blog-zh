<html>
<head>
<title>Data Engineering Design Patterns</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据工程设计模式</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/data-engineering-design-patterns-91dabc9abb90?source=collection_archive---------0-----------------------#2022-08-19">https://blog.devgenius.io/data-engineering-design-patterns-91dabc9abb90?source=collection_archive---------0-----------------------#2022-08-19</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="95ea" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">一些想法放在一起</h2></div><p id="2b8a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在以前关于数据工程的博客中，我讨论了 ETL、ELT 和 CDC 设计模式，在这个博客中，我将讨论一些我在行业中见过的设计模式。</p><h1 id="805a" class="ky kz in bd la lb lc ld le lf lg lh li jt lj ju lk jw ll jx lm jz ln ka lo lp bi translated">数据传送</h1><h2 id="7e40" class="lq kz in bd la lr ls dn le lt lu dp li kl lv lw lk kp lx ly lm kt lz ma lo mb bi translated">零拷贝数据传输</h2><p id="f8b3" class="pw-post-body-paragraph kc kd in ke b kf mc jo kh ki md jr kk kl me kn ko kp mf kr ks kt mg kv kw kx ig bi translated">系统级—零拷贝是指不需要应用程序，直接将数据从磁盘文件拷贝到网卡设备。</p><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi mh"><img src="../Images/1bfacb885bf8df81a26ae6e1f7aef657.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bmUONRU9_xZW1nbOU0bpXw.png"/></div></div></figure><p id="bf7a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在新方法中，避免了多重上下文切换。<code class="fe mt mu mv mw b"><em class="mx">transferTo</em></code>在 Java 中使用 Linux 系统的<code class="fe mt mu mv mw b"><em class="mx">sendfile()</em></code> <em class="mx">。</em>这种方法<em class="mx"> </em>现在已经在 NGINX 和<strong class="ke io"> </strong> KAFKA <strong class="ke io"> <em class="mx">中作为一种支持的数据传输技术被广泛使用。</em> </strong></p><p id="c8b1" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">元数据级别</strong> —该零拷贝是指需要克隆或替换时，数据的元数据而不是实际数据的拷贝。这是基于解耦存储和计算的基础之上的。计算是指通过元数据而不是直接通过数据进行存储。为微分区保留元数据，因此在更新的情况下，只更新某些特定的元数据。</p><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi my"><img src="../Images/a410ad6d48be0b4b442ec751778606e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O2BtcW8MrEAyktui7FUmXg.png"/></div></div></figure><p id="e7a8" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">队列 n 路数据传输</strong></p><p id="a7f4" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">多个应用程序使用相同的数据。源不是将数据发送到多个系统，而是将数据发送到队列/主题，然后消费者分别使用这些数据。</p><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi mz"><img src="../Images/f520f24ebd9494e600a57b7fc81a6199.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U9Y9kA1ivKvLXXuE1i-4aA.png"/></div></div></figure><h1 id="abce" class="ky kz in bd la lb lc ld le lf lg lh li jt lj ju lk jw ll jx lm jz ln ka lo lp bi translated">数据建模</h1><p id="d3fa" class="pw-post-body-paragraph kc kd in ke b kf mc jo kh ki md jr kk kl me kn ko kp mf kr ks kt mg kv kw kx ig bi translated">随着各种数据源和消费模式的增加，一个好的数据建模策略对成功非常关键。</p><h2 id="825b" class="lq kz in bd la lr ls dn le lt lu dp li kl lv lw lk kp lx ly lm kt lz ma lo mb bi translated">正常化</h2><ul class=""><li id="7fe3" class="na nb in ke b kf mc ki md kl nc kp nd kt ne kx nf ng nh ni bi translated">模拟数据源</li><li id="4af4" class="na nb in ke b kf nj ki nk kl nl kp nm kt nn kx nf ng nh ni bi translated">删除冗余</li><li id="6e2e" class="na nb in ke b kf nj ki nk kl nl kp nm kt nn kx nf ng nh ni bi translated">基于存储效率的设计</li><li id="27cb" class="na nb in ke b kf nj ki nk kl nl kp nm kt nn kx nf ng nh ni bi translated">通常与数据集市一起使用</li><li id="d96c" class="na nb in ke b kf nj ki nk kl nl kp nm kt nn kx nf ng nh ni bi translated">涉及很多连接</li></ul><h2 id="3620" class="lq kz in bd la lr ls dn le lt lu dp li kl lv lw lk kp lx ly lm kt lz ma lo mb bi translated">反规格化</h2><ul class=""><li id="7c3d" class="na nb in ke b kf mc ki md kl nc kp nd kt ne kx nf ng nh ni bi translated">也称为维度建模</li><li id="8e13" class="na nb in ke b kf nj ki nk kl nl kp nm kt nn kx nf ng nh ni bi translated">基于消费/业务需求的设计</li><li id="959b" class="na nb in ke b kf nj ki nk kl nl kp nm kt nn kx nf ng nh ni bi translated">星形模式与雪花模式</li><li id="fd53" class="na nb in ke b kf nj ki nk kl nl kp nm kt nn kx nf ng nh ni bi translated">维度—表示可能性</li><li id="cdb5" class="na nb in ke b kf nj ki nk kl nl kp nm kt nn kx nf ng nh ni bi translated">事实表——代表可能性的实现</li><li id="6418" class="na nb in ke b kf nj ki nk kl nl kp nm kt nn kx nf ng nh ni bi translated">缓慢变化的尺寸</li></ul><h2 id="93d9" class="lq kz in bd la lr ls dn le lt lu dp li kl lv lw lk kp lx ly lm kt lz ma lo mb bi translated">数据仓库</h2><ul class=""><li id="eb72" class="na nb in ke b kf mc ki md kl nc kp nd kt ne kx nf ng nh ni bi translated">中枢——代表核心业务概念及其元数据</li><li id="b50e" class="na nb in ke b kf nj ki nk kl nl kp nm kt nn kx nf ng nh ni bi translated">链接—表示中枢之间的关系</li><li id="170a" class="na nb in ke b kf nj ki nk kl nl kp nm kt nn kx nf ng nh ni bi translated">卫星-背景/描述性值，变化类似于 II 型 SCD</li><li id="a42d" class="na nb in ke b kf nj ki nk kl nl kp nm kt nn kx nf ng nh ni bi translated">原始层、业务层和表示层</li><li id="94b4" class="na nb in ke b kf nj ki nk kl nl kp nm kt nn kx nf ng nh ni bi translated">适合莱克豪斯模式</li></ul><h2 id="3a7c" class="lq kz in bd la lr ls dn le lt lu dp li kl lv lw lk kp lx ly lm kt lz ma lo mb bi translated">宽表</h2><ul class=""><li id="1cc7" class="na nb in ke b kf mc ki md kl nc kp nd kt ne kx nf ng nh ni bi translated">宽非规范化表</li><li id="897d" class="na nb in ke b kf nj ki nk kl nl kp nm kt nn kx nf ng nh ni bi translated">也称为一张大桌子</li><li id="a7e2" class="na nb in ke b kf nj ki nk kl nl kp nm kt nn kx nf ng nh ni bi translated">矩阵化将事实和维度表连接成一个 OBT</li><li id="3817" class="na nb in ke b kf nj ki nk kl nl kp nm kt nn kx nf ng nh ni bi translated">示例-大查询</li></ul><h1 id="0063" class="ky kz in bd la lb lc ld le lf lg lh li jt lj ju lk jw ll jx lm jz ln ka lo lp bi translated">自动化数据管道</h1><ul class=""><li id="0833" class="na nb in ke b kf mc ki md kl nc kp nd kt ne kx nf ng nh ni bi translated">使用 Liquibase 或 Flyway 作为数据库对象的光盘方法。</li><li id="b39f" class="na nb in ke b kf nj ki nk kl nl kp nm kt nn kx nf ng nh ni bi translated">将气流和 DBT 等工具用于管道和转换，作为代码。</li></ul><h1 id="7cae" class="ky kz in bd la lb lc ld le lf lg lh li jt lj ju lk jw ll jx lm jz ln ka lo lp bi translated">仓库</h1><h2 id="4507" class="lq kz in bd la lr ls dn le lt lu dp li kl lv lw lk kp lx ly lm kt lz ma lo mb bi translated">星形模式上的并行加载</h2><p id="93e7" class="pw-post-body-paragraph kc kd in ke b kf mc jo kh ki md jr kk kl me kn ko kp mf kr ks kt mg kv kw kx ig bi translated">在能够加载任何事实表之前顺序加载维度表是星型模式的瓶颈之一。</p><ul class=""><li id="b1e6" class="na nb in ke b kf kg ki kj kl no kp np kt nq kx nf ng nh ni bi translated">维度表的 varchar(32)代理键</li><li id="8c17" class="na nb in ke b kf nj ki nk kl nl kp nm kt nn kx nf ng nh ni bi translated">禁用外键约束</li><li id="7e25" class="na nb in ke b kf nj ki nk kl nl kp nm kt nn kx nf ng nh ni bi translated">计算临时区域中维度表的密钥的 MD5 哈希</li><li id="ec04" class="na nb in ke b kf nj ki nk kl nl kp nm kt nn kx nf ng nh ni bi translated">并行加载维度和事实表</li><li id="2e7f" class="na nb in ke b kf nj ki nk kl nl kp nm kt nn kx nf ng nh ni bi translated">重新启用外键约束</li></ul><h2 id="1ef1" class="lq kz in bd la lr ls dn le lt lu dp li kl lv lw lk kp lx ly lm kt lz ma lo mb bi translated">事实表子集设置</h2><p id="15bb" class="pw-post-body-paragraph kc kd in ke b kf mc jo kh ki md jr kk kl me kn ko kp mf kr ks kt mg kv kw kx ig bi translated">基于大型事实表的访问模式，我们可以创建第二个事实表，它只包含具有过滤数据的子集。我们可以在填充较大的事实表的同一批中填充较小的事实表。</p><h1 id="5493" class="ky kz in bd la lb lc ld le lf lg lh li jt lj ju lk jw ll jx lm jz ln ka lo lp bi translated">数据结构</h1><h2 id="784d" class="lq kz in bd la lr ls dn le lt lu dp li kl lv lw lk kp lx ly lm kt lz ma lo mb bi translated">梅达莲湖屋建筑</h2><p id="eec1" class="pw-post-body-paragraph kc kd in ke b kf mc jo kh ki md jr kk kl me kn ko kp mf kr ks kt mg kv kw kx ig bi translated">medallion 架构分层组织数据。每一层表示存储在湖边小屋中的不同质量的数据。每一层都连续提高后续层中的数据质量。</p><blockquote class="nr ns nt"><p id="f236" class="kc kd mx ke b kf kg jo kh ki kj jr kk nu km kn ko nv kq kr ks nw ku kv kw kx ig bi translated">青铜级—原始(原样，增量)<br/>白银级—干净的&amp;符合要求(经过验证)<br/>黄金级—随时可以消费数据(丰富)</p></blockquote></div></div>    
</body>
</html>