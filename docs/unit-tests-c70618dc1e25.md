# 单元测试

> 原文：<https://blog.devgenius.io/unit-tests-c70618dc1e25?source=collection_archive---------1----------------------->

定义集成和单元测试之间的界限并不容易。我想在这里提出我的看法。

![](img/4902cec8129aeb7d0955a95a7c090ff8.png)

图片由 [Pixabay](https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=408364) 提供

我在[的博客](https://medium.com/dev-genius/why-testing-and-how-d7cf96c7223f)上写了这个话题，但是一些人告诉我他们不清楚单位的概念。在开始之前，我想区分单元测试和集成测试。
在我看来，最大的不同是单元测试通常不需要任何基础设施来执行。例如，不需要在内存中启动数据库。它们只取决于语言和我们使用的测试框架。我的第二个问题是，与集成测试相比，在单元测试中找到一个 bug 是多么容易。

它们差别不大，但却有重大影响:

*   单元测试比集成测试快几倍。
*   单元测试不与你的代码，你写的代码之外的任何东西耦合。
*   单元测试告诉我们错误在哪里。

## 为什么测试套件的响应时间很重要？

现在让我们想象两个团队:

*   团队“集成”他们代码库中的 600 个集成测试。他们的集成测试平均每次持续 1 秒钟。
*   团队“单元”在他们的代码库中有 600 个单元测试。他们的单元测试平均持续 0.1 秒。

团队“集成”需要等待 10 分钟才能通过测试，但是团队“单元”只需要 1 分钟。你认为这对两个团队执行测试套件的频率有什么影响？
是的，团队“单元”会比团队“集成”更频繁地执行测试。我们知道，有了频繁而快速的反馈，修复 bug 的[成本](https://azevedorafaela.com/2018/04/27/what-is-the-cost-of-a-bug/)就更低了。

单元测试可以很好地扩展，在你的系统中从 600 个测试扩展到 1200 个测试对你的构建时间来说不是一个大问题。

## 测试和耦合

另一方面，我们说过单元测试没有耦合到您应用程序中需要的基础设施。但是为什么这是一个问题呢？。

在应用程序中与供应商合作就像接受他们的条件。现在，根据供应商的重要性和规模，你将成为客户或囚犯。去年，软件行业开始采用干净的架构来避免这些问题。但是我们没有意识到我们的测试也在那里，并且是我们代码库的一部分，对我们的生产代码有效的东西对我们的测试代码也有效。

如果我们的大部分测试与我们控制之外的第三方库耦合，我们设计低耦合系统的所有努力都将付诸东流。我们的测试是一切仍在工作的保证，如果它们与基础设施相结合，那么改变基础设施就会改变我们的测试。当我们试图在重构的同时改变测试时，很容易引入新的错误。

如果我们需要改变大量的测试，那么引入的错误数量将会很高。如果你的大多数测试是单元测试，这不是一个大问题。

## 那么为什么要讨论集成和单元测试呢？

与单元测试相比，集成测试有一个好处，这个好处与这样一个事实有关，即集成测试是用真实组件测试应用程序行为的黑盒测试。这使得开发人员有可能在不改变任何测试的情况下，在行为的中途重构他们的代码。

但是等等，实际上这是单元测试可以实现的。问题是我们为我们的单位选择的边界。

## 单元和行为

让我们试着用一个例子来说明这个问题。
假设我们想在员工微服务中开发一个 rest 服务，给员工发送圣诞礼物。
我们将以这种方式开发我们的新功能:

*   主计长给我们所有在职员工发了一份圣诞礼物。
*   员工服务，从我们的员工库中检索所有在职员工，并为每个员工发送一份礼物。
*   雇员存储库，它负责与我们的雇员数据库进行对话。
*   礼品仓库，将礼品发送给我们的员工。另一个休息服务。

这是支持我们行为测试的设计，现在我们有几个选项来测试它。

*   我们可以用内存数据库和 rest 模拟服务器创建一个集成测试来模拟我们的基础设施。在这种情况下，我们的测试与内存数据库和 rest 模拟服务器相耦合。对于 rest 模拟服务器，我们需要假设它是如何工作的:使用哪些命令，预期的结果等等。
    因此，在测试我们服务的测试中，我们高度耦合到这个第三方系统。
*   我们可以用集成测试来测试我们的基础设施(控制器、员工库、礼物库)，用单元测试来测试我们的领域(服务)。在这种情况下，我们的基础设施在我们的测试中与其相应的技术相耦合，但是我们的领域在我们的测试中没有与我们的基础设施相耦合。
*   其他人

在第二种情况下，我们用单元测试来测试我们的领域，这些单元测试有清晰的边界，我们的存储库。那些存储库必须被测试替身所取代。但是等等，测试替身不是免费的，他们在假设我们真正的合作者会如何表现。我们不会谈论这个，但这是通过[合同测试](https://blog.thecodewhisperer.com/permalink/getting-started-with-contract-tests)的起点。
控制器将通过集成测试进行测试，对 EmployeesService 的调用将被嘲笑，这样我们就可以通过集成测试来测试我们的基础设施，而不是我们的领域。同样的事情也发生在我们的存储库上，它们将会在没有领域的集成测试中被测试。

现在想象一下，作为一项新的要求，我们需要将礼物的价格发送给我们的税务系统。此时，我们已经意识到，为了调用我们的税务系统，我们必须进行一些复杂的计算，因此我们创建了将进行这些计算的税务类，现在我们的员工服务具有:

*   员工信息库。
*   礼物仓库。
*   在调用税库之前进行一些计算的税。

## 我们测试中的影响

为了在我们的设计中引入 Tax，我们决定将其作为合作者，这一决定将对我们的测试产生影响:

*   我们可以为雇员服务中的测试模拟 Tax，并为 Tax 添加新的测试。
*   我们可以试着用真正的税收来测试我们员工的服务。

第一个决定的效果是在税收和我们的员工服务之间创建一个边界。

```
class EmployeeService{
   private Tax tax;
   ...
   public EmployeeService(Tax tax, ....){
       this.tax = tax;
       ...
   }
   public void sendGifts(){
     ...
     tax.informGift(a,b,c);
     ...  
   }
}
```

按照第一种方法测试 EmployeeService:

```
class EmployeeServiceTest { @Test
    public void sendGifts(){
       Tax tax= mock(Task.class);
       **when(tax.informGift(a,b,c)).thenReturn(expectedResult);**       EmployeeService service = new EmployeeService(tax, ...);
       service.sendGifts(); //myAssertions 
    }
}
```

为了测试 EmployeeServiceTest.sendGifts，我们假设 informGift 的行为方式(when 部分)，如果这些假设不正确，那么我们将引入错误。现在，如果我们改变 Tax.informGift 的方法签名，那么我们将不得不改变我们的 test doubles，但这也适用于我的 test doubles(when)所做的任何假设。
这样，对我领域内部行为的任何重构都会影响我测试中的许多部分。**我的测试通过我创建的测试替身**耦合到税收。在某种程度上，雇员服务中的测试促使我不要重构任何税务内部的东西。

在第二个选项中，要测试 EmployeeService:

```
class EmployeeServiceTest { @Test
    public void sendGifts(){
       Tax tax= new Tax(...) EmployeeService service = new EmployeeService(tax, ...);
       service.sendGifts(); //myAssertions 
    }
}
```

在这个选项中，我们在员工服务测试中没有关于税收的假设。**所以本例中我的单位就是我要测试的行为**，EmployeeService 和 Tax 两者一起。在第二个选项中，更改 Tax.informGift 中的签名或任何假设对我的单元测试来说都不是问题。Tax.informGift 对我的测试是隐藏的。
第二种方法的风险是创建一个[集成测试](https://blog.thecodewhisperer.com/permalink/integrated-tests-are-a-scam)，集成测试的结果是测试用例的爆炸。

## 测试爆炸

为了解释这一点，在我们的示例中想象一下，我们需要 5 个测试来测试 Tax.informGift，另外 5 个测试来测试 EmployeeService.sendGifts 中的代码。这是将我们的测试一分为二的唯一原因，5 个用于 EmployeeService，5 个用于 Tax。因此，在 EmployeeService.sendGifts 测试中，我们将模拟 Tax.informGift 来避免这种爆炸。

当我们开始编写测试时，我们总是可以从第二种方法开始，但是我们只需要意识到测试的爆炸。如果我们开始看到这种爆炸，就回到第一种方法来测试特定的行为。[实际上，这只是对传统 TDD 方法的描述](https://martinfowler.com/articles/mocksArentStubs.html#ClassicalAndMockistTesting)。TDD 没有说任何关于单元测试和集成测试的事情，使用单元测试或集成测试的原因是基于我在本文开始时解释的。

单元测试对那些我们可以很容易改变的东西(我们的领域)是有好处的。集成测试对于我们不能改变的事情(例如 sql 语言)是有益的。让我们把它们放在正确的地方。

因此作为推论，单元测试中不只有一个单元。它映射了你的系统定义的每一个高级行为，不需要任何类型的基础设施，也不会产生[测试爆炸，](https://blog.thecodewhisperer.com/permalink/integrated-tests-are-a-scam)这意味着你的行为之间的单元可以不同。