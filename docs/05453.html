<html>
<head>
<title>Embedded Linux 101</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">嵌入式 Linux 101</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/embedded-linux-101-247ec7239970?source=collection_archive---------2-----------------------#2021-08-13">https://blog.devgenius.io/embedded-linux-101-247ec7239970?source=collection_archive---------2-----------------------#2021-08-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/7ce3eb0cd82943b9bbfa6a0afc99b7d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gGu1AGvkiNPmUHboH7g2Ew.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">tux:Linux 的吉祥物</figcaption></figure><p id="230a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">嵌入式 Linux 开发的入门非常令人困惑。有大量的术语，并且有一个与深入源代码和使用嵌入式 Linux 生态系统中常用的各种工具和框架相关的陡峭的学习曲线。这个简短的指南将介绍一些关键的背景知识，这些知识是该领域的新来者需要尽快开始掌握的。</p><h1 id="6294" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">什么是 Linux？</h1><p id="4086" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">Linux 是一个很像 MacOS 或 Windows 的操作系统。内核是 Linux 操作系统的一部分，它提供了对运行操作系统的硬件的抽象。它处理 I/O 操作、内存管理、线程、进程管理等等。Linux 的另一部分是引导装载程序。<strong class="ke ir">引导程序</strong>负责在机器开机时将内核加载到内存中，从而启动操作系统。</p><h1 id="b737" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">什么是嵌入式开发？</h1><p id="c792" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">广义地说，<strong class="ke ir">嵌入式系统</strong>，也被称为信息物理系统，是一个“在现实世界中运行”的软件和硬件系统通常，这意味着它附着在传感器和致动器上，这些传感器和致动器为它提供信息，并允许它与周围的物体进行交互。嵌入式设备推动着物联网(IoT)、工业自动化、机器人等领域的发展。</p><p id="e28d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">片上系统(SoC) </strong>是嵌入式系统的核心部件。这些芯片不仅包括 CPU，还包括内部子系统和其他电路，使其能够连接到其他外围设备。开发人员从芯片制造商那里购买 SoC，并构建一个<strong class="ke ir">板</strong>，其中包括 SoC 以及开发人员希望用于其最终设备的任何外设。</p><h1 id="1f7c" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">什么是嵌入式 Linux 开发？</h1><p id="3856" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">简而言之，嵌入式 Linux 开发是使 Linux 内核与 SOC 和不同的板一起工作的工程。虽然嵌入式系统通常只运行一个应用程序，但内核提供的好处可能会超过功耗、存储和计算成本，因为应用程序的执行环境看起来就像嵌入式系统只是一台普通的 PC。这使得运行需要网络连接或 GUI 等功能的复杂应用程序变得更加容易。</p><p id="7b3d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">嵌入式 Linux 开发需要配置 Linux 内核/引导加载程序，以便他们知道主板上存在的硬件，编写外围设备驱动程序，以便内核/引导加载程序可以使用硬件，并添加到文件系统。<strong class="ke ir">驱动程序</strong>是特定于硬件外设的代码，内核可以用它来与外设交互。<strong class="ke ir">文件系统</strong>是设备可以使用的所有文件，包括程序。</p><h1 id="c64a" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">内核</h1><p id="be5a" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">为了让内核正常工作，它必须知道主板上有什么硬件，它可以在哪里使用内存映射 IO 访问硬件，以及它应该有什么功能和外设驱动程序。</p><p id="55d3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">一个<strong class="ke ir">设备树</strong>是一个描述外设及其在电路板上布局的数据结构。这包括指定可以在哪个内存地址找到外设，以及驱动程序可以用来控制外设的其他信息。内核读取内置在内核映像中的设备树，以便它可以正确地与硬件交互。这允许相同的驱动程序用于不同的外设，并且允许相同的内核代码用于非常不同的主板。有关如何构建设备树的更多信息，请参见<a class="ae md" href="https://elinux.org/Device_Tree_Usage" rel="noopener ugc nofollow" target="_blank">设备树使用指南</a>。</p><p id="dfa4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">由于开发人员购买的 SOC 不附带任何外设，因此他们必须决定每个外设的连接位置。对于一些 SoC，不同的引脚被复用在一起，因为一个 SoC 可能支持比用户可能添加到电路板的外设更多的外设。在这种情况下，一个<strong class="ke ir">引脚控制器</strong>决定每个引脚的用途。这称为<strong class="ke ir">引脚多路复用</strong>，由于特定引脚多路复用设置对于确定电路板布局至关重要，因此它们包含在器件树中。</p><p id="9926" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">除了硬件，嵌入式 Linux 开发者还需要配置内核的软件特性。一个<strong class="ke ir">内核模块</strong>是内核的一个组件，比如设备驱动或者内核特性，可以被内核使用。构建内核时，<strong class="ke ir"> defconfig </strong>是一组变量，用于决定包含哪些模块以及如何包含它们。模块可以构建到内核映像中，这意味着它们总是被加载，或者它们可以在运行时被动态加载。defconfig 中的变量在内核源代码中显示为宏，它们也被编译代码的 Makefiles 使用。defconfig 中的新变量可以使用<strong class="ke ir"> Kconfig </strong>来指定，这是一种指定配置之间依赖关系的宏语言。可以使用<strong class="ke ir"> menuconfig </strong>编辑 defconfig，这是一个 GUI，允许用户添加和删除 defconfig 中的变量，同时仍然遵循 Kconfig 中指定的依赖关系。</p><p id="bb9c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">为了将内核移植到新的主板上，必须</p><ol class=""><li id="89a8" class="me mf iq ke b kf kg kj kk kn mg kr mh kv mi kz mj mk ml mm bi translated">创建描述板的设备树(如果适用，包括 PinMux 信息)</li><li id="5615" class="me mf iq ke b kf mn kj mo kn mp kr mq kv mr kz mj mk ml mm bi translated">创建一个 defconfig，描述哪些模块应该构建到内核映像中，哪些应该动态加载。</li></ol><h1 id="1d78" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">引导加载程序</h1><p id="3a98" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">有多种用于嵌入式 Linux 的引导加载程序。一个常见的就是<a class="ae md" href="https://github.com/u-boot/u-boot" rel="noopener ugc nofollow" target="_blank"> U 型靴</a>。</p><p id="1dda" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">SoC 内部的 ROM 通常从存储器(SD 卡、闪存等)加载引导程序，因此它可以开始执行，最终加载内核。实际的引导流程取决于 SoC，可能涉及不同的固件和其他程序，这些都是启动 U-Boot 过程的一部分。其中一个程序叫做<strong class="ke ir">二级程序加载器(SPL) </strong>，是 U-Boot 的缩小版，其目的是为 U-Boot 的完整版运行准备硬件。</p><p id="2022" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">和内核一样，U-Boot 也是通过 defconfigs 和设备树来配置的。U-Boot 的 defconfig 的创建方式与内核 defconfig 的创建方式相同。然而，虽然内核可以有动态加载的模块，但所有 U-Boot 模块都内置在映像中。通常，U-Boot 的设备树比内核要小得多，因为 U-Boot 不需要访问板上的所有硬件；它只需要访问在引导过程中使用的硬件。</p><p id="2bc7" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">由于内核需要加载到 RAM 中，U-Boot 的部分工作是准备 RAM 和内核正常运行所需的任何其他外设。这意味着 U-Boot 会将值写入不同的寄存器，以确保硬件配置正确。这是由每个外围设备 U-Boot 需要配置的驱动程序完成的，驱动程序经常使用的数据来自设备树。根据引导流程，在引导过程中可能会使用多个设备树。</p><p id="8ead" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">为了将 U-Boot 移植到新主板，必须</p><ol class=""><li id="fb06" class="me mf iq ke b kf kg kj kk kn mg kr mh kv mi kz mj mk ml mm bi translated">创建描述板的设备树(如果适用，包括 PinMux 信息)</li><li id="931d" class="me mf iq ke b kf mn kj mo kn mp kr mq kv mr kz mj mk ml mm bi translated">创建一个 defconfig 来配置 U-Boot 并将任何必要的驱动程序添加到构建中</li><li id="c141" class="me mf iq ke b kf mn kj mo kn mp kr mq kv mr kz mj mk ml mm bi translated">编写 C 代码，使用驱动程序来配置主板硬件，并为内核做准备</li></ol><h1 id="365e" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">文件系统</h1><p id="fa0a" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">因为嵌入式 Linux 设备运行的是 Linux，它们的文件系统是<a class="ae md" href="https://www.linux.com/training-tutorials/linux-filesystem-explained/" rel="noopener ugc nofollow" target="_blank"> Linux 文件系统</a>。然而，除了 Linux 文件系统附带的最基本的文件和程序之外，嵌入式 Linux 开发人员还希望将他们自己的文件和程序添加到文件系统中。这包括设备将运行的主要应用程序、支持主要应用程序所需的任何库，以及开发人员希望在他们的设备上安装的任何其他东西。这些通常被称为<strong class="ke ir">用户空间包</strong>，因为它们是给用户使用的，而不是给内核使用的。</p><p id="23f3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">要修改根文件系统，可以从标准的根文件系统开始，然后添加或删除文件和包。然而，这很耗时，所以文件系统配置最容易通过嵌入式 Linux 构建系统来完成。</p><h1 id="ac04" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">构建嵌入式 Linux</h1><p id="2dda" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">由于嵌入式 Linux 有如此多的配置步骤，因此有许多开源项目旨在简化构建嵌入式 Linux 发行版的过程。一个例子是<a class="ae md" href="https://www.yoctoproject.org/software-overview/" rel="noopener ugc nofollow" target="_blank"> Yocto 项目</a>。</p><p id="76d1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">Yocto 使用<a class="ae md" href="http://www.openembedded.org/wiki/Main_Page" rel="noopener ugc nofollow" target="_blank"> OpenEmbedded </a>构建系统来构建和配置 Linux。它可以编译引导装载程序、内核，并配置文件系统。<strong class="ke ir">菜谱</strong>描述了如何构建每个包以及在哪里安装。配方的一部分指定了包的源代码所在的位置(远程或本地代码存储库)，并且可以应用开发人员编写的补丁。配方被放置在<strong class="ke ir">层</strong>中，因此来自较高优先级层的包的配方可以覆盖来自较低优先级层的相同包的配方。芯片供应商提供称为<strong class="ke ir">板支持包(BSP)层的层，</strong>开发者可以使用这些层为他们的 SOC 开发嵌入式 Linux。</p><h1 id="2e1f" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">结论</h1><p id="7191" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">理解 Linux 内核、引导装载程序和文件系统，以及如何在高层次上配置它们，是开始使用嵌入式 Linux 开发应用程序的第一步。有关更多信息和指导，请参阅以下资源:</p><ul class=""><li id="fac8" class="me mf iq ke b kf kg kj kk kn mg kr mh kv mi kz ms mk ml mm bi translated"><a class="ae md" href="https://www.linux.com/what-is-linux/" rel="noopener ugc nofollow" target="_blank">什么是 Linux </a></li><li id="7b91" class="me mf iq ke b kf mn kj mo kn mp kr mq kv mr kz ms mk ml mm bi translated"><a class="ae md" href="https://www.kernel.org/doc/html/latest/kbuild/kconfig-language.html" rel="noopener ugc nofollow" target="_blank"> Kconfig </a></li><li id="88d1" class="me mf iq ke b kf mn kj mo kn mp kr mq kv mr kz ms mk ml mm bi translated"><a class="ae md" href="https://elinux.org/Device_Tree_Usage" rel="noopener ugc nofollow" target="_blank">设备树指南</a></li><li id="9ccc" class="me mf iq ke b kf mn kj mo kn mp kr mq kv mr kz ms mk ml mm bi translated"><a class="ae md" href="https://elinux.org/images/2/2a/Schulz-how-to-support-new-board-u-boot-linux.pdf" rel="noopener ugc nofollow" target="_blank"> U 形引导板端口导轨</a></li><li id="8937" class="me mf iq ke b kf mn kj mo kn mp kr mq kv mr kz ms mk ml mm bi translated"><a class="ae md" href="https://www.linux.com/training-tutorials/linux-filesystem-explained/" rel="noopener ugc nofollow" target="_blank"> Linux 文件系统</a></li><li id="b0bc" class="me mf iq ke b kf mn kj mo kn mp kr mq kv mr kz ms mk ml mm bi translated"><a class="ae md" href="https://www.yoctoproject.org/software-overview/" rel="noopener ugc nofollow" target="_blank"> Yocto 项目</a></li><li id="2ba7" class="me mf iq ke b kf mn kj mo kn mp kr mq kv mr kz ms mk ml mm bi translated"><a class="ae md" href="http://www.openembedded.org/wiki/Main_Page" rel="noopener ugc nofollow" target="_blank"> OpenEmbedded </a></li><li id="e981" class="me mf iq ke b kf mn kj mo kn mp kr mq kv mr kz ms mk ml mm bi translated"><a class="ae md" href="https://www.youtube.com/watch?v=zNLYanJAQ3s" rel="noopener ugc nofollow" target="_blank">yo CTO 项目入门</a></li></ul><p id="c053" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这篇文章的灵感很大程度上来自于我在德州仪器实习期间不得不深入嵌入式 Linux 开发，尽管我之前在这个领域没有任何经验。非常感谢我的团队帮助我学会如何找到路。</p></div></div>    
</body>
</html>