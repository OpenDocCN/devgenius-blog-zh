<html>
<head>
<title>Spring Boot Threads Wihtout In Heap Queue</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">堆队列中没有Spring Boot线程</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/spring-boot-with-java-threads-wihtout-in-heap-queue-f85949c6bcfd?source=collection_archive---------12-----------------------#2020-07-16">https://blog.devgenius.io/spring-boot-with-java-threads-wihtout-in-heap-queue-f85949c6bcfd?source=collection_archive---------12-----------------------#2020-07-16</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/b067a2baa756f9694f82976b14ebb411.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RmvasSkOHKCF_lGRG_O33A.jpeg"/></div></div></figure><p id="95b3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在我早期的开发生涯中，我从来不需要任何线程，主要是我的开发项目是小而快速的小过程，不需要任何线程操作。</p><p id="f64e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是进了大公司之后，我最需要！</p></div><div class="ab cl kt ku hr kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ig ih ii ij ik"><p id="c5db" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先，我开始用小线程，你知道像做两个工作在同一时间的事情。像这样的线程使用；</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="990a" class="lj lk in lf b gy ll lm l ln lo">new Thread(() -&gt; {<br/>    //<em class="lp">TODO<br/></em>}).start();</span></pre><p id="8367" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是最简单的用例。打开一个新线程，发送一些todo并启动它。它走自己的路，你走自己的路。</p></div><div class="ab cl kt ku hr kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ig ih ii ij ik"><p id="cdf8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是如果你想做一项复杂的工作，那就有点困难了。</p><p id="081e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">假设您有一个包含100k个对象的列表，需要尽可能快地处理和完成。在这种情况下，我们需要更有效地使用线程。</p><p id="96d4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">第一种方法是:</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="99c7" class="lj lk in lf b gy ll lm l ln lo">Executor executor = Executors.<em class="lp">newFixedThreadPool</em>(10);<br/>executor.execute(() -&gt; {<br/>    //<em class="lp">TODO<br/></em>});<br/><br/>while (true){<br/>    if(...) ...<br/>}</span></pre><p id="5bd7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">创建一个包含10个线程的线程池，同时处理10个数据。(在这种情况下，当您发送所有100k个对象时，它存储在一个无限大小的队列中，等待线程获取数据并处理它。这可能会导致堆大小增加。当你使用这种方法时，你需要小心。)</p><p id="24a8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">发送完所有的对象列表后，你可以等待并检查是否所有的对象都被处理并完成<em class="lp">(通过并发hashmap，你可以存储对象状态并在while循环中检查它们是否完成)</em>。如果不需要等待和检查，可以忽略while循环。</p><p id="69bb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果我的对象很小，我的最大列表数是100k，有时我会使用这种方法。但是有更有效的方法可以做到这一点。因为在这种情况下，您无法控制队列大小，这会导致堆问题。</p></div><div class="ab cl kt ku hr kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ig ih ii ij ik"><p id="aa13" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">还有第二种方法，我主要在我们的大数据项目中使用这种方法。</p><figure class="la lb lc ld gt jo gh gi paragraph-image"><div class="gh gi lq"><img src="../Images/f35c3185df81d8f8df7d25bc921d4c25.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*QV88GQbI0NQ4yB5S-yeY9w.png"/></div></figure><p id="d24d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">有了Spring Boot，我们的工作变得更加容易，我喜欢和豆子一起工作。</p></div><div class="ab cl kt ku hr kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ig ih ii ij ik"><p id="fe45" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先，您需要创建一个线程池bean</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="f711" class="lj lk in lf b gy ll lm l ln lo">@Bean<br/>public ThreadPoolTaskExecutor taskExecutor() {<br/>    ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();<br/>    executor.setCorePoolSize(50);<br/>    executor.setMaxPoolSize(50);<br/>    executor.setQueueCapacity(10);<br/>    executor.setThreadNamePrefix("Thread-");<br/>    executor.initialize();<br/>    return executor;<br/>}</span></pre><p id="6c0f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我建议不要使用超过<em class="lp">你的服务器的核心大小，如果你想你可以增加一倍，但要小心cpu的使用。</em></p><p id="826e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如您所见，我的线程池容量是10，仅仅是10。所以在你发送了60个对象之后<em class="lp">(如果线程没有完成)</em>我的队列将会满了，它不能再处理更多的对象了。</p><p id="7329" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你试图发送它，它会得到一个异常，你的数据将会丢失。我们如何防止这种情况发生？</p></div><div class="ab cl kt ku hr kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ig ih ii ij ik"><p id="92ff" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在我们的项目中，我们使用RabbitMQ <em class="lp">(它可以是任何消息队列，但rabbit是我最喜欢使用的)</em>来发送和接收数百万的数据。所以在我的兔子处理器方法中，我使用了这个。</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="1a0f" class="lj lk in lf b gy ll lm l ln lo">while(true) {<br/>    try {<br/>        taskExecutor.submit(() -&gt; {<br/>            //TODO<br/>        });<br/>        break;<br/>    } catch (TaskRejectedException e) {<br/>        try {<br/>            Thread.<em class="lp">sleep</em>(50);<br/>        } catch (InterruptedException ex) {<br/>            ex.printStackTrace();<br/>        }<br/>    }<br/>}</span></pre><p id="78fb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这个部分中，我的数据还没有提交给线程，如果线程正在工作，线程池已满，就会出现异常。</p><p id="8e62" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了防止你的数据丢失并等待线程处理，它处于一个无限的<em class="lp"> (kinda) </em> while循环<em class="lp">(最后有一点50毫秒的等待时间，以防止你的应用程序每毫秒试图发送数据，并防止太多的cpu使用，通常处理时间可以约150毫秒。在这种情况下，我们的while循环3次)</em>。当我的one数据在循环中等待时，我的其他99k对象在兔子队列中等待被应用程序使用。</p><p id="37c9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这样，我们的应用程序堆将保持稳定，不会因为消耗线程池队列中的所有对象而随时间增加。</p></div></div>    
</body>
</html>