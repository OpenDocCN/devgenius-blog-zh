<html>
<head>
<title>SSO Authentication for Applications in Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes 中应用程序的 SSO 认证</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/sso-authentication-for-applications-in-kubernetes-aedc3c189d89?source=collection_archive---------2-----------------------#2022-10-19">https://blog.devgenius.io/sso-authentication-for-applications-in-kubernetes-aedc3c189d89?source=collection_archive---------2-----------------------#2022-10-19</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/6b4904e44bb1b56021405d414fb8557d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Gt1BQvURX6Sx5-lhO7kUFA.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">对 unsplash.com 的礼貌</figcaption></figure><h1 id="5809" class="jz ka in bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">介绍</h1><p id="8718" class="pw-post-body-paragraph kx ky in kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">这篇文章是关于使用 SSO 认证和授权来保护应用程序和入口的。入口可以用用户名和密码保护。如果许多团队在一个有许多应用程序的集群上工作，最好使用带 RBAC(基于角色的访问控制)的 SSO 认证机制。这使得生活更加轻松，因为允许/拒绝访问的组可以轻松配置。</p><h1 id="7562" class="jz ka in bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">当前设置</h1><p id="4840" class="pw-post-body-paragraph kx ky in kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">我有一个 Traefik 入口控制器，有很多入口。我想使用 GitHub 作为 OIDC 提供商。</p><h1 id="dbb4" class="jz ka in bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">先决条件</h1><p id="dab6" class="pw-post-body-paragraph kx ky in kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">为了理解和遵循本文档，我假设读者对使用<code class="fe lv lw lx ly b">helm</code>部署应用程序有所了解，并且当对应用程序的<code class="fe lv lw lx ly b">values.yaml</code>文件进行更改时，假设图表版本使用新值进行了升级。</p><h1 id="b385" class="jz ka in bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">DEX 作为 OIDC 提供商</h1><p id="f5d1" class="pw-post-body-paragraph kx ky in kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">有许多可用的 OIDC 提供商，但我选择了 Dex，因为</p><ul class=""><li id="b538" class="lz ma in kz b la mb le mc li md lm me lq mf lu mg mh mi mj bi translated">它与 Kubernetes 无关，我可以使用 Dex 来保护我的应用程序或所有入侵。</li><li id="85ae" class="lz ma in kz b la mk le ml li mm lm mn lq mo lu mg mh mi mj bi translated">其功能丰富</li><li id="4e9b" class="lz ma in kz b la mk le ml li mm lm mn lq mo lu mg mh mi mj bi translated">它有许多插件，可以与许多 OIDC 提供商集成，并可以像一个中心一样在集群中进行身份验证和授权。</li></ul><p id="176e" class="pw-post-body-paragraph kx ky in kz b la mb lc ld le mc lg lh li mp lk ll lm mq lo lp lq mr ls lt lu ig bi translated">因此，我将使用 Dex 作为集群内的 OIDC 提供者，并在 Dex 上为 OIDC 配置 GitHub 插件，而不是直接使用 GitHub 进行 OIDC 配置。</p><p id="92b3" class="pw-post-body-paragraph kx ky in kz b la mb lc ld le mc lg lh li mp lk ll lm mq lo lp lq mr ls lt lu ig bi translated">对于可以直接与 OIDC 提供者通信的应用程序，可以通过在应用程序配置本身中添加 OIDC 配置来进行保护。这太酷了。但是不酷的是不支持 OIDC 配置的入口或应用程序。所以让我们来看看如何做到这一点。</p><h1 id="6cca" class="jz ka in bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">创建 GitHub OAuth 应用程序</h1><p id="a92f" class="pw-post-body-paragraph kx ky in kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">重要的事情先来</p><p id="a8bc" class="pw-post-body-paragraph kx ky in kz b la mb lc ld le mc lg lh li mp lk ll lm mq lo lp lq mr ls lt lu ig bi translated">进入 github.com &gt;你的个人资料&gt;设置&gt;开发者设置&gt; OAuth 应用&gt;新建 OAuth 应用</p><figure class="mt mu mv mw gt jo gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/dd5c13d07e10703307f4fbcc4c09bdd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1244/format:webp/1*kpmL8zwUoMilKhKBb85hmg.png"/></div></figure><p id="cdcb" class="pw-post-body-paragraph kx ky in kz b la mb lc ld le mc lg lh li mp lk ll lm mq lo lp lq mr ls lt lu ig bi translated">这个<code class="fe lv lw lx ly b">Application Name</code>、<code class="fe lv lw lx ly b">Homepage URL</code>、<code class="fe lv lw lx ly b">Application Description</code>可以是任何东西。重要的是<code class="fe lv lw lx ly b">Authorization callback URL</code>。这应该是将要部署的 Dex 的 url。</p><p id="580c" class="pw-post-body-paragraph kx ky in kz b la mb lc ld le mc lg lh li mp lk ll lm mq lo lp lq mr ls lt lu ig bi translated">当注册应用程序时，会生成一个<code class="fe lv lw lx ly b">ClientID</code>和一个<code class="fe lv lw lx ly b">ClientSecret</code>。在一个安全的地方拷贝这个。</p><p id="1973" class="pw-post-body-paragraph kx ky in kz b la mb lc ld le mc lg lh li mp lk ll lm mq lo lp lq mr ls lt lu ig bi translated">现在让我们在 Kubernetes 中创建一个秘密来存储 Dex 将使用的凭证</p><figure class="mt mu mv mw gt jo"><div class="bz fp l di"><div class="mx my l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">dex-github-secret.yaml</figcaption></figure><p id="9a7f" class="pw-post-body-paragraph kx ky in kz b la mb lc ld le mc lg lh li mp lk ll lm mq lo lp lq mr ls lt lu ig bi translated">并在集群中应用它</p><pre class="mt mu mv mw gt mz ly na nb aw nc bi"><span id="3d1c" class="nd ka in ly b gy ne nf l ng nh">kubectl apply -f dex-github-secret.yaml</span></pre><h1 id="3b42" class="jz ka in bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">Dex 是 OIDC 的应用提供商，可以与 OIDC 对话</h1><p id="2d05" class="pw-post-body-paragraph kx ky in kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">我的集群中有 GitOps 的 ArgoCD。ArgoCD 可以直接与 OIDC 提供商对话。因此，我将配置 ArgoCD 以使用 Dex 作为 OIDC。授权工作流是这样的</p><figure class="mt mu mv mw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ni"><img src="../Images/d40e18d71d68d21453cf970a0237eb90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7oztBfRa4YRoacVvfFNHew.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">支持 OIDC 的应用程序的 DEX 工作流</figcaption></figure><ol class=""><li id="011a" class="lz ma in kz b la mb le mc li md lm me lq mf lu nj mh mi mj bi translated">用户请求应用程序 ArgoCD</li><li id="fadb" class="lz ma in kz b la mk le ml li mm lm mn lq mo lu nj mh mi mj bi translated">ArgoCD 将 auth 请求转发给已配置的 OIDC 提供程序，即 Dex。</li><li id="7030" class="lz ma in kz b la mk le ml li mm lm mn lq mo lu nj mh mi mj bi translated">Dex 将检查令牌是否已经存在。因为没有，所以它会将请求发送到已配置的 OIDC 连接器。</li><li id="3726" class="lz ma in kz b la mk le ml li mm lm mn lq mo lu nj mh mi mj bi translated">GitHub OAuth 应用程序对请求中的用户进行身份验证，并将反馈返回给 OAuth 应用程序中配置的<code class="fe lv lw lx ly b">Authorization Callback URL</code>,即 Dex url</li><li id="ac0e" class="lz ma in kz b la mk le ml li mm lm mn lq mo lu nj mh mi mj bi translated">Dex 验证响应，并为通过<code class="fe lv lw lx ly b">staticClients</code>中配置的<code class="fe lv lw lx ly b">RedirectURI</code>请求的客户端创建签名的 ID 令牌。</li><li id="7f38" class="lz ma in kz b la mk le ml li mm lm mn lq mo lu nj mh mi mj bi translated">ArgoCD 现在将转发使用有效令牌验证的请求资源</li></ol><p id="4874" class="pw-post-body-paragraph kx ky in kz b la mb lc ld le mc lg lh li mp lk ll lm mq lo lp lq mr ls lt lu ig bi translated">这是用简单的术语解释的工作流程。在现实中，有很多事情正在发生，如认证和签名的 ID 令牌或 JWT 令牌的创建等等。为此，我建议多了解一下 OIDC 认证是如何工作的。或者等我写一篇关于它的文章；)</p><p id="7881" class="pw-post-body-paragraph kx ky in kz b la mb lc ld le mc lg lh li mp lk ll lm mq lo lp lq mr ls lt lu ig bi translated">现在让我们部署 Dex。由于我使用 Kubernetes，我会更喜欢通过头盔图部署。所以我的<code class="fe lv lw lx ly b">values.yaml</code>会是这样的:</p><figure class="mt mu mv mw gt jo"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="6465" class="pw-post-body-paragraph kx ky in kz b la mb lc ld le mc lg lh li mp lk ll lm mq lo lp lq mr ls lt lu ig bi translated"><code class="fe lv lw lx ly b">storage</code>部分提到在哪里存储令牌，我使用 kubernetes 集群进行存储。并使用 Github 连接器。</p><p id="266e" class="pw-post-body-paragraph kx ky in kz b la mb lc ld le mc lg lh li mp lk ll lm mq lo lp lq mr ls lt lu ig bi translated">如果<code class="fe lv lw lx ly b">loadAllGroups</code>为<code class="fe lv lw lx ly b">true</code>，那么任何登录 GitHub 的人都可以通过授权。这里我告诉 Dex 只授权来自<code class="fe lv lw lx ly b">myorg</code>的用户以及属于团队<code class="fe lv lw lx ly b">myteam1</code>和<code class="fe lv lw lx ly b">myteam2</code>的用户。如果我不提供团队配置，那么组织<code class="fe lv lw lx ly b">myteam</code>的任何成员都可以被授权。</p><blockquote class="nk nl nm"><p id="becc" class="kx ky nn kz b la mb lc ld le mc lg lh no mp lk ll np mq lo lp nq mr ls lt lu ig bi translated">需要注意的一点是，如果这个 Oauth 应用程序是个人用户创建的，那么这个应用程序应该由组织授权。首次使用时，Github 会要求您向组织发送请求以批准请求。</p></blockquote><p id="fe71" class="pw-post-body-paragraph kx ky in kz b la mb lc ld le mc lg lh li mp lk ll lm mq lo lp lq mr ls lt lu ig bi translated">在<code class="fe lv lw lx ly b">staticClients</code>部分，我为 ArgoCD 添加了一个。<code class="fe lv lw lx ly b">id</code>和<code class="fe lv lw lx ly b">secret</code>分别作为<code class="fe lv lw lx ly b">oidc.config </code>中的<code class="fe lv lw lx ly b">clientID</code>和<code class="fe lv lw lx ly b">clientSecret</code></p><p id="c212" class="pw-post-body-paragraph kx ky in kz b la mb lc ld le mc lg lh li mp lk ll lm mq lo lp lq mr ls lt lu ig bi translated">关于 Github 连接器的更多配置，请点击查看<a class="ae nr" href="https://dexidp.io/docs/connectors/github/" rel="noopener ugc nofollow" target="_blank"/></p><p id="a4f8" class="pw-post-body-paragraph kx ky in kz b la mb lc ld le mc lg lh li mp lk ll lm mq lo lp lq mr ls lt lu ig bi translated">让我们部署 Dex</p><pre class="mt mu mv mw gt mz ly na nb aw nc bi"><span id="68d7" class="nd ka in ly b gy ne nf l ng nh">kubectl apply -f dex-github-secret.yaml</span><span id="1e44" class="nd ka in ly b gy ns nf l ng nh">helm repo add dex <a class="ae nr" href="https://charts.dexidp.io" rel="noopener ugc nofollow" target="_blank">https://charts.dexidp.io</a><br/>helm install --generate-name --wait dex/dex -n dex -f values.yaml<!-- --> </span></pre><p id="8380" class="pw-post-body-paragraph kx ky in kz b la mb lc ld le mc lg lh li mp lk ll lm mq lo lp lq mr ls lt lu ig bi translated">当 Dex 准备就绪时，配置 ArgoCD 配置以添加 OIDC 提供程序。我在这里就不解释了。一个 TL；DR；编辑配置图<code class="fe lv lw lx ly b">argocd-cm</code>，添加 OIDC 配置并尝试登录。如果配置正确，那么 OIDC 配置应该可以工作。</p><h1 id="778d" class="jz ka in bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">Dex 作为 OIDC 供应商提供不能与 OIDC 对话的应用程序</h1><p id="01d3" class="pw-post-body-paragraph kx ky in kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">现在，让我们看看如何在不支持 OIDC 的应用程序中使用 Dex。我们有两个选择。</p><h2 id="04bc" class="nd ka in bd kb nt nu dn kf nv nw dp kj li nx ny kn lm nz oa kr lq ob oc kv od bi translated">选项 1: Traefik 转发授权</h2><p id="5731" class="pw-post-body-paragraph kx ky in kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">Traefik Forward Auth 是一个简单的 SSO/Oauth 身份验证工具，用于 Traefik 作为入口控制器。</p><p id="ba63" class="pw-post-body-paragraph kx ky in kz b la mb lc ld le mc lg lh li mp lk ll lm mq lo lp lq mr ls lt lu ig bi translated">请求工作流将如下所示:</p><figure class="mt mu mv mw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi oe"><img src="../Images/dd5fd1340540245d286172b93cbe0563.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kgHnBOb7itenlIxHMRdtRg.jpeg"/></div></div></figure><ol class=""><li id="f27c" class="lz ma in kz b la mb le mc li md lm me lq mf lu nj mh mi mj bi translated">用户对 Traefik 入口控制器应用程序的请求</li><li id="5346" class="lz ma in kz b la mk le ml li mm lm mn lq mo lu nj mh mi mj bi translated">Traefik 通过在 Traefik 上配置的中间件将请求重定向到 Traefik Forward Auth</li><li id="8e3d" class="lz ma in kz b la mk le ml li mm lm mn lq mo lu nj mh mi mj bi translated">Traefik Forward Auth 将请求转发给 Dex</li><li id="99e8" class="lz ma in kz b la mk le ml li mm lm mn lq mo lu nj mh mi mj bi translated">Dex 将重定向请求转发给 GitHub</li><li id="e192" class="lz ma in kz b la mk le ml li mm lm mn lq mo lu nj mh mi mj bi translated">GitHub 接受登录并将 auth 请求发送给 Dex</li><li id="bb67" class="lz ma in kz b la mk le ml li mm lm mn lq mo lu nj mh mi mj bi translated">Dex 将请求重定向到 Traefik Forward Auth</li><li id="5f43" class="lz ma in kz b la mk le ml li mm lm mn lq mo lu nj mh mi mj bi translated">Traefik Forward Auth 检查来自 Dex 的响应，并根据响应发送 200/403</li><li id="f820" class="lz ma in kz b la mk le ml li mm lm mn lq mo lu nj mh mi mj bi translated">然后，Traefik 将用户请求发送到请求的资源或应用程序。</li></ol><h2 id="bb49" class="nd ka in bd kb nt nu dn kf nv nw dp kj li nx ny kn lm nz oa kr lq ob oc kv od bi translated">配置 Traefik 转发授权</h2><p id="858c" class="pw-post-body-paragraph kx ky in kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">在创建 Traefik Forward Auth 之前，我们需要在 Dex 中添加一个静态客户端部分。我们已经为 ArgoCD 做了同样的事情。因此，将以下内容附加到 Dex 的<code class="fe lv lw lx ly b">values.yaml</code>文件的<code class="fe lv lw lx ly b">staticClients</code>部分:</p><pre class="mt mu mv mw gt mz ly na nb aw nc bi"><span id="5192" class="nd ka in ly b gy ne nf l ng nh">- id: traefik-fwd-auth<br/>  name: Traefik Forward Auth OIDC Dex App<br/>  redirectURIs:<br/>  - <a class="ae nr" href="https://auth.verdictcyber.com/_oauth" rel="noopener ugc nofollow" target="_blank">https://auth.mydomain.com/_oauth</a><br/>  secret: random-secret</span></pre><p id="784f" class="pw-post-body-paragraph kx ky in kz b la mb lc ld le mc lg lh li mp lk ll lm mq lo lp lq mr ls lt lu ig bi translated"><code class="fe lv lw lx ly b">redirectURIs</code>应该是 Traefik Forward Auth 的入口 url，它将很快配置。</p><p id="fbcd" class="pw-post-body-paragraph kx ky in kz b la mb lc ld le mc lg lh li mp lk ll lm mq lo lp lq mr ls lt lu ig bi translated">Traefik Forward Auth helm 图表的值如下:</p><figure class="mt mu mv mw gt jo"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="6c72" class="pw-post-body-paragraph kx ky in kz b la mb lc ld le mc lg lh li mp lk ll lm mq lo lp lq mr ls lt lu ig bi translated">所以我在这里设定</p><ul class=""><li id="f1ff" class="lz ma in kz b la mb le mc li md lm me lq mf lu mg mh mi mj bi translated"><code class="fe lv lw lx ly b">default</code> oidc 提供商</li><li id="5928" class="lz ma in kz b la mk le ml li mm lm mn lq mo lu mg mh mi mj bi translated"><code class="fe lv lw lx ly b">oidc</code>一节包含了 OIDC 的信息传递经过。<code class="fe lv lw lx ly b">issuerUrl</code>是配置好的 Dex 应用 URL。此处添加了<code class="fe lv lw lx ly b">clientID</code>和<code class="fe lv lw lx ly b">clientSecret</code>，这应该与您在<code class="fe lv lw lx ly b">staticClients</code>部分提供的完全相同</li><li id="08ee" class="lz ma in kz b la mk le ml li mm lm mn lq mo lu mg mh mi mj bi translated"><code class="fe lv lw lx ly b">cookie.insecure</code>到<code class="fe lv lw lx ly b">true</code>，以便允许来自非 https 域的 cookie，因为我在 traefik 上有 ssl 终端。这里可以提供一个随机的<code class="fe lv lw lx ly b">secret</code>。这将作为秘密存储在安装 Traefik Forward Auth 的名称空间中。<code class="fe lv lw lx ly b">domain</code>应该是域的值</li><li id="ab02" class="lz ma in kz b la mk le ml li mm lm mn lq mo lu mg mh mi mj bi translated"><code class="fe lv lw lx ly b">authHost</code>很重要，因为这是 Traefik Forward Auth 为验证而配置的主机名</li><li id="816a" class="lz ma in kz b la mk le ml li mm lm mn lq mo lu mg mh mi mj bi translated"><code class="fe lv lw lx ly b">middleware.enabled</code>设置为<code class="fe lv lw lx ly b">true</code>将自动创建一个中间件。这个中间件包含关于授权 url 和指向的服务的信息。</li><li id="74a3" class="lz ma in kz b la mk le ml li mm lm mn lq mo lu mg mh mi mj bi translated">一个用于 Traefik 转发授权的<code class="fe lv lw lx ly b">ingress</code></li></ul><blockquote class="nk nl nm"><p id="207a" class="kx ky nn kz b la mb lc ld le mc lg lh no mp lk ll np mq lo lp nq mr ls lt lu ig bi translated">最初的舵图在安装时可能会有问题，因为我有一些问题。所以最好复制这个图表，并根据您的要求修改它。对我来说，问题在于入口配置，因为我使用的是最新的 kubernetes 版本，而这个版本已经过时了。</p></blockquote><h2 id="fdfe" class="nd ka in bd kb nt nu dn kf nv nw dp kj li nx ny kn lm nz oa kr lq ob oc kv od bi translated">部署 Traefik 转发授权</h2><pre class="mt mu mv mw gt mz ly na nb aw nc bi"><span id="2627" class="nd ka in ly b gy ne nf l ng nh">helm repo add itscontained <a class="ae nr" href="https://charts.itscontained.io" rel="noopener ugc nofollow" target="_blank">https://charts.itscontained.io</a><br/>helm install itscontained/traefik-forward-auth -n traefik -f values.yaml</span></pre><p id="505f" class="pw-post-body-paragraph kx ky in kz b la mb lc ld le mc lg lh li mp lk ll lm mq lo lp lq mr ls lt lu ig bi translated">安装后，通过添加注释来修改未经身份验证的入口:</p><pre class="mt mu mv mw gt mz ly na nb aw nc bi"><span id="41a8" class="nd ka in ly b gy ne nf l ng nh">traefik.ingress.kubernetes.io/router.middlewares: traefik-traefik-forward-auth@kubernetescrd</span></pre><p id="1909" class="pw-post-body-paragraph kx ky in kz b la mb lc ld le mc lg lh li mp lk ll lm mq lo lp lq mr ls lt lu ig bi translated">注释的值将采用格式<code class="fe lv lw lx ly b">&lt;namespace&gt;-traefik-forward-auth@kubernetescrd</code>。如果命名空间或<code class="fe lv lw lx ly b">kubernetescrd</code>被省略，那么这个 auth 将不起作用。</p><p id="06ed" class="pw-post-body-paragraph kx ky in kz b la mb lc ld le mc lg lh li mp lk ll lm mq lo lp lq mr ls lt lu ig bi translated">尝试登录，如果一切正常，那么你应该通过 Dex 重定向到 GitHub，如果认证有效，那么你将被授权访问入口</p><h2 id="3727" class="nd ka in bd kb nt nu dn kf nv nw dp kj li nx ny kn lm nz oa kr lq ob oc kv od bi translated">选项 2:oauth 2-代理</h2><p id="71d3" class="pw-post-body-paragraph kx ky in kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">Oauth2-Proxy 是一个反向代理，它使用提供商(Google、GitHub 和其他提供商)提供身份验证，通过电子邮件、域或组来验证帐户。</p><p id="bd3a" class="pw-post-body-paragraph kx ky in kz b la mb lc ld le mc lg lh li mp lk ll lm mq lo lp lq mr ls lt lu ig bi translated">Oauth2-Proxy 的身份验证工作流如下所示:</p><figure class="mt mu mv mw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi of"><img src="../Images/2ba76e40c945b8a31eb4d29e3ef2acc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ydrDoyfwHjVN8UbwF_BNMw.jpeg"/></div></div></figure><ol class=""><li id="bf75" class="lz ma in kz b la mb le mc li md lm me lq mf lu nj mh mi mj bi translated">用户请求应用程序跟踪</li><li id="09be" class="lz ma in kz b la mk le ml li mm lm mn lq mo lu nj mh mi mj bi translated">Traefik 将请求转发到请求的入口，即 Oauth2 代理</li><li id="ca2b" class="lz ma in kz b la mk le ml li mm lm mn lq mo lu nj mh mi mj bi translated">oauth 2-代理将请求重定向到其 OIDC 提供商 Dex</li><li id="4882" class="lz ma in kz b la mk le ml li mm lm mn lq mo lu nj mh mi mj bi translated">Dex 将请求重定向到其 OIDC 提供商 GitHub</li><li id="9560" class="lz ma in kz b la mk le ml li mm lm mn lq mo lu nj mh mi mj bi translated">GitHub 接受登录并通过回调 URL 将请求转发给 Dex</li><li id="2fdd" class="lz ma in kz b la mk le ml li mm lm mn lq mo lu nj mh mi mj bi translated">Dex 通过重定向 URL 将请求转发给 Oauth2-Proxy</li><li id="542c" class="lz ma in kz b la mk le ml li mm lm mn lq mo lu nj mh mi mj bi translated">oauth 2-代理授权请求并将请求发送到配置的上游 URL</li></ol><p id="cc35" class="pw-post-body-paragraph kx ky in kz b la mb lc ld le mc lg lh li mp lk ll lm mq lo lp lq mr ls lt lu ig bi translated">Traefik Forward Auth 和 Oauth2-Proxy 之间的区别在于，Traefik Forward Auth 和应用程序入口的入口是分开的。在 Oauth2-Proxy 中，应用入口指向 Oauth2-Proxy，因为它充当应用的代理</p><h2 id="0c5f" class="nd ka in bd kb nt nu dn kf nv nw dp kj li nx ny kn lm nz oa kr lq ob oc kv od bi translated">配置 oauth 2-代理</h2><p id="652b" class="pw-post-body-paragraph kx ky in kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">首先是 DEX 上的静态客户端。因此，在<code class="fe lv lw lx ly b">staticClients</code>部分添加以下内容作为索引<code class="fe lv lw lx ly b">values.yaml</code></p><pre class="mt mu mv mw gt mz ly na nb aw nc bi"><span id="fa94" class="nd ka in ly b gy ne nf l ng nh">- id: oauth2-proxy-oidc<br/>  name: Oauth2-Proxy OIDC Dex App<br/>  redirectURIs:<br/>  - https://myapp.mydomain.com/oauth2/callback<br/>  secret: random-secret</span></pre><p id="607e" class="pw-post-body-paragraph kx ky in kz b la mb lc ld le mc lg lh li mp lk ll lm mq lo lp lq mr ls lt lu ig bi translated">示例应用程序的 Oauth2-Proxy 的值为:</p><figure class="mt mu mv mw gt jo"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="dd3c" class="pw-post-body-paragraph kx ky in kz b la mb lc ld le mc lg lh li mp lk ll lm mq lo lp lq mr ls lt lu ig bi translated">所以有:</p><ul class=""><li id="d83e" class="lz ma in kz b la mb le mc li md lm me lq mf lu mg mh mi mj bi translated">OIDC 配置的<code class="fe lv lw lx ly b">config</code>部分，在 Dex <code class="fe lv lw lx ly b">staticClients</code>部分提供</li><li id="5030" class="lz ma in kz b la mk le ml li mm lm mn lq mo lu mg mh mi mj bi translated"><code class="fe lv lw lx ly b">ingress</code>带 tls 配置。请注意，我使用的是通配符 dns 证书，作为秘密存储在所有名称空间中。</li><li id="2acb" class="lz ma in kz b la mk le ml li mm lm mn lq mo lu mg mh mi mj bi translated"><code class="fe lv lw lx ly b">extraArgs</code>，添加更多配置。像<code class="fe lv lw lx ly b">oidc-issuer-url</code>、<code class="fe lv lw lx ly b">redirect-url</code>、<code class="fe lv lw lx ly b">allowed-group</code>、<code class="fe lv lw lx ly b">upstream</code>。在<code class="fe lv lw lx ly b">upstream</code>中，我们配置如果 auth 成功，将请求发送到哪里。这里它指向一个名为<code class="fe lv lw lx ly b">myapp</code>的 kubernetes <code class="fe lv lw lx ly b">service</code>，运行在端口<code class="fe lv lw lx ly b">8080</code>的<code class="fe lv lw lx ly b">default</code>名称空间中</li></ul><h2 id="3856" class="nd ka in bd kb nt nu dn kf nv nw dp kj li nx ny kn lm nz oa kr lq ob oc kv od bi translated">部署 oauth 2-代理</h2><pre class="mt mu mv mw gt mz ly na nb aw nc bi"><span id="1c76" class="nd ka in ly b gy ne nf l ng nh">helm repo add oauth2-proxy https://oauth2-proxy.github.io/manifests<br/>helm install my-release oauth2-proxy/oauth2-proxy -n default -f values.yaml</span></pre><p id="eeba" class="pw-post-body-paragraph kx ky in kz b la mb lc ld le mc lg lh li mp lk ll lm mq lo lp lq mr ls lt lu ig bi translated">如果一切正常，那么 url <code class="fe lv lw lx ly b"><a class="ae nr" href="https://myapp.mydomain.com" rel="noopener ugc nofollow" target="_blank">https://myapp.mydomain.com</a></code>将显示 Oauth2-Proxy 的屏幕，然后重定向到 Dex，Dex 将重定向到 GitHub，然后重定向到应用程序。</p><h1 id="cf5a" class="jz ka in bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">重要的问题是。Traefik Forward Auth 或 Oauth2-Proxy？</h1><p id="d4d1" class="pw-post-body-paragraph kx ky in kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">让我们看看为什么 Oauth2-Proxy 在这种情况下不理想。当有多个入口需要保护时，您将需要相同数量的 Oauth2 代理舵图表，这不是一个好主意，因为这样将会到处都是 Oauth2 代理。</p><p id="6a97" class="pw-post-body-paragraph kx ky in kz b la mb lc ld le mc lg lh li mp lk ll lm mq lo lp lq mr ls lt lu ig bi translated">虽然 Oauth2-Proxy 可以用作所有入口的中央身份验证系统，这意味着一个实例可以用于所有身份验证。当你有<strong class="kz io"> NGINX </strong>作为你的入口控制器时，这将非常好的工作。然后正常部署 Oauth2-Proxy，将<code class="fe lv lw lx ly b">reverse-proxy</code>设置为<code class="fe lv lw lx ly b">false </code>，然后移除<code class="fe lv lw lx ly b">upstream</code>参数，并从上面的配置中设置类似于<code class="fe lv lw lx ly b">oauth.mydomain.com</code>的主机名。也将它部署在类似<code class="fe lv lw lx ly b">security</code>的名称空间中</p><p id="f4aa" class="pw-post-body-paragraph kx ky in kz b la mb lc ld le mc lg lh li mp lk ll lm mq lo lp lq mr ls lt lu ig bi translated">然后在应用入口添加以下注释</p><pre class="mt mu mv mw gt mz ly na nb aw nc bi"><span id="4ea1" class="nd ka in ly b gy ne nf l ng nh">apiVersion: networking.k8s.io/v1<br/>kind: Ingress<br/>metadata:<br/>  name: myapp<br/>  annotations:<br/>    kubernetes.io/ingress.class: nginx<br/>    nginx.ingress.kubernetes.io/auth-signin: <a class="ae nr" href="https://oauth.example.com/oauth2/start" rel="noopener ugc nofollow" target="_blank">https://oauth.mydomain.com/oauth2/start</a><br/>    nginx.ingress.kubernetes.io/auth-url: <a class="ae nr" href="http://oauth2-proxy.security.svc.cluster.local/oauth2/auth" rel="noopener ugc nofollow" target="_blank">http://oauth2-proxy.security.svc.cluster.local/oauth2/auth</a><br/>...</span></pre><ul class=""><li id="3681" class="lz ma in kz b la mb le mc li md lm me lq mf lu mg mh mi mj bi translated"><code class="fe lv lw lx ly b">auth-sigin</code>将任何需要的登录重定向到 oauth 2-代理入口。</li><li id="4be3" class="lz ma in kz b la mk le ml li mm lm mn lq mo lu mg mh mi mj bi translated"><code class="fe lv lw lx ly b">auth-url</code>注释可以通过其服务在内部访问 Oauth2-Proxy 来验证提交的令牌</li></ul><p id="883b" class="pw-post-body-paragraph kx ky in kz b la mb lc ld le mc lg lh li mp lk ll lm mq lo lp lq mr ls lt lu ig bi translated">遗憾的是，此注释不能用于 Traefik 入口控制器。这就是为什么 Traefik Forward Auth 在这种情况下是最好的。</p><h1 id="1bb1" class="jz ka in bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">我们可以两个都用吗？</h1><p id="9f38" class="pw-post-body-paragraph kx ky in kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">是的，两者兼而有之很好，因为会有这样的用例。例如，您是平台工程团队的一员，您创建了 Traefik Forward Auth，以便客户使用此中间件来保护他们的入口，并且只允许客户提供的组进行访问。现在，在这个集群中，如果您作为团队的一员需要部署某个东西，例如 Prometheus，并通过您自己的组(而不是客户组)暴露入口并保护它，那么 Oauth2-Proxy 的一个实例将在这里完成这个任务，而没有太多的复杂性</p><p id="03c0" class="pw-post-body-paragraph kx ky in kz b la mb lc ld le mc lg lh li mp lk ll lm mq lo lp lq mr ls lt lu ig bi translated">此外，在集群中运行 3 到 5 个以上的 Oauth2-Proxy 实例也是不明智的，除非这对您合适。对我来说，这将是一个丑陋的解决方案</p><h1 id="2a1d" class="jz ka in bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">结论</h1><p id="3593" class="pw-post-body-paragraph kx ky in kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">作为 OIDC 提供商，Dex 是一个非常酷的工具。可以将所有 OIDC 提供商集成到集群中的一个中心，并使用每个提供商特定的配置进行身份验证。使用 Traefik Forward Auth 或 Oauth2-Proxy 为不支持内置 OIDC 配置的入口或应用程序增加了更多的安全性。这里的最佳选择是 Traefik Forward Auth，因为在我的设置中，我将 Traefik 作为入口控制器。还应该注意的是，如果我使用 NGINX 入口控制器，我将根本无法使用 Traefik Forward Auth，因为由于中间件配置的原因，它需要 Traefik。</p><p id="841a" class="pw-post-body-paragraph kx ky in kz b la mb lc ld le mc lg lh li mp lk ll lm mq lo lp lq mr ls lt lu ig bi translated">我希望你喜欢这篇文章，并理解在你的设置中使用它的概念</p><p id="d19a" class="pw-post-body-paragraph kx ky in kz b la mb lc ld le mc lg lh li mp lk ll lm mq lo lp lq mr ls lt lu ig bi translated">让我知道你的意见，如果你有其他的选择，我会很乐意尝试，并记录下来！！</p></div></div>    
</body>
</html>