<html>
<head>
<title>Java Synchronization- part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java 同步——第 2 部分</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/java-synchronization-part-2-2101e9620017?source=collection_archive---------20-----------------------#2020-06-28">https://blog.devgenius.io/java-synchronization-part-2-2101e9620017?source=collection_archive---------20-----------------------#2020-06-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/6a3265b0b4298677843525200c3b2e03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Nqaz98QjbFA44baGdyn5LA.jpeg"/></div></div></figure><div class=""/><h1 id="e514" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">竞态条件</h1><p id="5580" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">欢迎回到 JAVA 同步！希望你看过我之前的<a class="ae lu" href="https://medium.com/@sachinthahewawasam_20059/java-synchronization-part-1-abcabac56cf7" rel="noopener">文章</a>。</p><p id="5141" class="pw-post-body-paragraph kw kx jb ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">说起<strong class="ky jc">的种族状况，</strong>是什么？当我们必须同时访问某些数据时，就会出现竞争情况。好吧，那么并发访问数据是什么意思？这仅仅意味着两个不同的线程可能会读取同一个变量或同一个 Java 类中定义的同一个字段，甚至是同一个数组。让我们以这个流行的设计模式“Singleton”为例，看看这里的竞争条件是如何发生的。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="21c8" class="mj jz jb mf b gy mk ml l mm mn">public class Singleton{<br/>    private static Singleton <em class="mo">instance</em>;<br/>    private Singleton() {}<br/>    public static Singleton getInstance() {<br/>        if(<em class="mo">instance </em>== null) {<br/>            <em class="mo">instance </em>= new Singleton();<br/>        }<br/>        return <em class="mo">instance</em>;<br/>    }<br/>}</span></pre><p id="37a5" class="pw-post-body-paragraph kw kx jb ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">两个线程正在尝试执行此代码块。考虑这样一种情况，线程 1 (T1)在“if”块中暂停，然后 T2 启动并继续运行，并完成“if”块，创建“静态单例实例”，然后 T1 启动并销毁由 T2 创建的“静态单例实例”。</p><blockquote class="mp mq mr"><p id="7edb" class="kw kx mo ky b kz lv lb lc ld lw lf lg ms lx lj lk mt ly ln lo mu lz lr ls lt ij bi translated">那么，如何才能防止这种情况发生呢？正是<strong class="ky jc">同步</strong>防止了一个代码块同时被多个线程执行。</p></blockquote><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="2d32" class="mj jz jb mf b gy mk ml l mm mn">public class Singleton{<br/>    private static Singleton <em class="mo">instance</em>;<br/>    private Singleton() {}<br/>    public static synchronized Singleton getInstance() {<br/>        if(<em class="mo">instance </em>== null) {<br/>            <em class="mo">instance </em>= new Singleton();<br/>        }<br/>        return <em class="mo">instance</em>;<br/>    }<br/>}</span></pre><p id="6a71" class="pw-post-body-paragraph kw kx jb ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">所以同步会拯救世界，对吗？是的，会的。现在让我们通过一个图表来看看它的作用。也就是；<strong class="ky jc">同步</strong>键如何保护方法。</p><p id="8f7d" class="pw-post-body-paragraph kw kx jb ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">这里我提供了一些图像，以便更好的可视化。“人”将代表一个线程。看看这个人是如何索要钥匙并进入方法的，以及他们在离开之前是如何归还钥匙的。以便其他人(即线程)必须等待获取密钥。很简单的机制，对吧？</p><div class="ma mb mc md gt ab cb"><figure class="mv is mw mx my mz na paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><img src="../Images/4616c03c4744ee7103aa5e35e1dd5adc.png" data-original-src="https://miro.medium.com/v2/resize:fit:998/format:webp/1*qFyyqX4ijt3ycVDZyjJAXg.jpeg"/></div></figure><figure class="mv is nb mx my mz na paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><img src="../Images/f6e5568301714f1a63956d3333c65ff5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/1*g9bOGF9pk3yV03CYaAPWAw.jpeg"/></div></figure></div><div class="ab cb"><figure class="mv is nc mx my mz na paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><img src="../Images/adbca2396179aa3f2dcadbf5f900911f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1014/format:webp/1*2r2FG0UnItIrLbK2cFSM9A.jpeg"/></div></figure><figure class="mv is nd mx my mz na paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><img src="../Images/4e568502b36d7f4d94bc1632fe2cecc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:988/format:webp/1*fjTS5ybamgp36z7W-IAgVQ.jpeg"/></div></figure></div><p id="c30d" class="pw-post-body-paragraph kw kx jb ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">事实上，我已经解释过，我们需要一个对象来保存同步工作的密钥。在上面的例子中，我们将 synchronized 关键字放在了<strong class="ky jc">公共静态方法上。那么在这种情况下，JVM 用什么来处理锁呢？它的<strong class="ky jc"> Singleton.class </strong>对象。同样，在非静态方法的同步中，它使用它所在的特定实例作为同步对象。</strong></p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="617e" class="mj jz jb mf b gy mk ml l mm mn">public synchronized String getName() {<br/>        return <em class="mo">this.name</em>;<br/>    }</span></pre><h1 id="041c" class="jy jz jb bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">让我们使用一个显式对象来进行同步</h1><p id="3570" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我们可以使用一个显式对象来进行同步，如下面的代码块所示。可以，只有对象类本身就够了。我想你已经知道原因了。我们可以不同步“getName()”方法，而是在这个方法中使用 synchronized 块，并将这个 key 对象作为这个 synchronized 关键字的参数传递。请记住，这总是一个好主意！</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="d086" class="mj jz jb mf b gy mk ml l mm mn">public class Organization {<br/>    private final Object key = new Object();<br/>    public String getName() {<br/>        synchronized(key) {<br/>            //do something<br/>        }<br/>    }<br/>}</span></pre></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><h1 id="693b" class="jy jz jb bd ka kb nl kd ke kf nm kh ki kj nn kl km kn no kp kq kr np kt ku kv bi translated">同步多个方法</h1><p id="e3f9" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">假设我们有一个包含两个同步方法“getName()”和“getMarks()”的学生类。JVM 使用的锁对象是学生对象本身。所以当一个特定的线程想要执行" getName()" <strong class="ky jc">，</strong>时，它会取锁对象，从而防止另一个线程同时执行" getName()" <strong class="ky jc">，</strong>方法。因为我们没有在方法的同步上声明任何显式对象，所以将使用相同的对象键。现在你可以理解，为了同时(独立地)执行这两个方法，我们需要在<strong class="ky jc">学生</strong>类中创建两个锁对象，并同步来自这两个锁的两个代码块(两个不同的对象)。</p><p id="5f00" class="pw-post-body-paragraph kw kx jb ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">现在假设我们有两个<strong class="ky jc">学生</strong>类的实例，<strong class="ky jc">学生 1，</strong>和<strong class="ky jc">学生 2。</strong>同步多个方法将使用两个键锁定对象。</p><figure class="ma mb mc md gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nq"><img src="../Images/636bf193e70e2b5784f2819fc1f54c4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2pu_0uKhbH7btluBCxY9ZA.png"/></div></div></figure><p id="4f4d" class="pw-post-body-paragraph kw kx jb ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">对于执行" getName()" <strong class="ky jc"> Studnet1 </strong>对象的线程，不阻止线程执行<strong class="ky jc"> Studnet2 </strong>对象中的" getMask()"。</p><figure class="ma mb mc md gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nr"><img src="../Images/2053b1f84764972d4e52b580f7058d94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eM98LJqdIndg_YcR6KuF8w.png"/></div></div></figure><p id="d7fb" class="pw-post-body-paragraph kw kx jb ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">并且不会干扰另一个线程执行<strong class="ky jc"> Student2 </strong>对象中相同的“getName()”方法。我认为这些图片非常有助于理解这一点。</p><figure class="ma mb mc md gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ns"><img src="../Images/0af52d8df2a6b674e3afceb250b0098d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vZLTBvJln2Jqbd2U3KUefA.png"/></div></div></figure><p id="695c" class="pw-post-body-paragraph kw kx jb ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">那么，如果我们想防止两个线程在所有的<strong class="ky jc"> Student </strong>类实例中同时执行这个“getName()”方法呢？</p><blockquote class="mp mq mr"><p id="bc20" class="kw kx mo ky b kz lv lb lc ld lw lf lg ms lx lj lk mt ly ln lo mu lz lr ls lt ij bi translated">现在你很清楚我们需要一个不绑定到我们的学生类的任何实例的锁对象。，而是对类本身对吗？那么它必须是类的静态字段。</p></blockquote><figure class="ma mb mc md gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nt"><img src="../Images/3ef7c57816bf5fb6a14e3efc6592789a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eWyhqfGJvfKNPW-ScC7HWg.png"/></div></div></figure><p id="6e44" class="pw-post-body-paragraph kw kx jb ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">到目前为止，您可以理解执行<strong class="ky jc">Student 1 "</strong>getName()"同时持有键的线程将阻止其他线程执行<strong class="ky jc"> Student2 </strong>实例中的<strong class="ky jc"> Student </strong>类的方法。</p><figure class="ma mb mc md gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nu"><img src="../Images/82173680e269196318a84f15fdee2efe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-QK7kLNXec2L3V0zLNLXCg.png"/></div></div></figure></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><h1 id="797a" class="jy jz jb bd ka kb nl kd ke kf nm kh ki kj nn kl km kn no kp kq kr np kt ku kv bi translated">锁是“可重入”的吗？</h1><p id="0cec" class="pw-post-body-paragraph kw kx jb ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">再想想我们有两个<strong class="ky jc">学生</strong>类的实例，有多个<strong class="ky jc">同步的</strong>块。</p><blockquote class="mp mq mr"><p id="159f" class="kw kx mo ky b kz lv lb lc ld lw lf lg ms lx lj lk mt ly ln lo mu lz lr ls lt ij bi translated">同样的钥匙一定能打开同样的锁，对吗？</p></blockquote><figure class="ma mb mc md gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nv"><img src="../Images/aa2fe19379163c18ae24c89b78cd2efa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_jtPfjEKLkurRz4jf1IdyQ.png"/></div></div></figure><p id="303a" class="pw-post-body-paragraph kw kx jb ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">这两个实例中的“方法 1()”和“方法 3()”由同一个<strong class="ky jc">红色锁</strong>保护，您需要完全相同的<strong class="ky jc">红色钥匙</strong>。同样“方法 4()”和“方法 1()”。因此，在<strong class="ky jc"> Studnet1 </strong>对象中运行“method1()”的线程获得了密钥，并且在某个时候，它将进入<strong class="ky jc"> Studnet2 </strong>实例中的同步“method3()”。因为它已经持有正确的密钥，所以运行另一个方法是受欢迎的。</p><blockquote class="mp mq mr"><p id="af05" class="kw kx mo ky b kz lv lb lc ld lw lf lg ms lx lj lk mt ly ln lo mu lz lr ls lt ij bi translated">当一个线程持有一个锁时，它可以进入一个与它持有的锁同步的块。</p></blockquote></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><p id="c575" class="pw-post-body-paragraph kw kx jb ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">感谢您阅读本博客！你有什么改进这篇文章的建议，请告诉我你的回复。</p></div></div>    
</body>
</html>