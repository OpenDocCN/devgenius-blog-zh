<html>
<head>
<title>How to tackle stale cached responses?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何处理陈旧的缓存响应？</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-to-tackle-stale-cached-responses-615fb15281b?source=collection_archive---------13-----------------------#2022-02-05">https://blog.devgenius.io/how-to-tackle-stale-cached-responses-615fb15281b?source=collection_archive---------13-----------------------#2022-02-05</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="0080" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在本文中，我将讨论我们缓存的不同类型的响应，以及数据变得陈旧的可能性和避免这种情况的不同方法。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/5966a12a2d964d4016fe0a9ac1d91211.png" data-original-src="https://miro.medium.com/v2/resize:fit:820/format:webp/1*OVShrXr8Zj9rVEbq0MSkQw.png"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">Spring Boot 的 Redis 缓存</figcaption></figure><p id="80ad" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">首先，让我们了解存储在缓存中的不同类型的响应，以及它变得陈旧的可能性。</p><ol class=""><li id="2d21" class="ku kv in jm b jn jo jr js jv kw jz kx kd ky kh kz la lb lc bi translated">一生中很少改变的反应。这些是曾经计算过的很少改变的反应。这些类型的数据是真实的，如电影类型，一些旧比赛的足球比分，发明家和发明等。</li><li id="972a" class="ku kv in jm b jn ld jr le jv lf jz lg kd lh kh kz la lb lc bi translated"><strong class="jm io">仅依赖于数据库的响应</strong>。这些是仅依赖于数据库的响应，我们不做任何服务端消息传递/处理。这些响应的刷新率将取决于数据库更新的频率。</li><li id="46d7" class="ku kv in jm b jn ld jr le jv lf jz lg kd lh kh kz la lb lc bi translated"><strong class="jm io">依赖于数据库和服务端代码</strong>的响应。这些是响应，我们从数据库中获取数据，进行一些处理，然后发送响应。这些响应的刷新率不仅取决于数据库刷新的频率，还取决于您部署新版本服务的频率。</li></ol><p id="bf34" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们不必担心第一种反应。因此，在下一节中，让我们讨论如何处理第二种和第三种情况下的陈旧数据。</p></div><div class="ab cl li lj hr lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="ig ih ii ij ik"><h2 id="fb2d" class="lp lq in bd lr ls lt dn lu lv lw dp lx jv ly lz ma jz mb mc md kd me mf mg mh bi translated">仅依赖于数据库的响应</h2><p id="b216" class="pw-post-body-paragraph jk jl in jm b jn mi jp jq jr mj jt ju jv mk jx jy jz ml kb kc kd mm kf kg kh ig bi translated">在这种情况下，因为响应只依赖于数据库。我们必须首先了解数据库刷新的频率。无论是每月、每天还是每小时。根据这一点，我们可以决定缓存刷新的频率。不一定要完全一样。我们必须明白我们可以做出多大的妥协，因为如果我们开始非常频繁地刷新缓存响应，那么我们的缓存命中率将会下降。</p><p id="33a9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一旦我们得出一个数字，我们就可以通过设置<code class="fe mn mo mp mq b">TTL</code>(生存时间)来刷新我们的缓存。让我们看看当我们使用 Redis 进行缓存时，如何在 Spring Boot 做到这一点。</p><pre class="kj kk kl km gt mr mq ms mt aw mu bi"><span id="508e" class="lp lq in mq b gy mv mw l mx my"><a class="ae mz" href="http://twitter.com/Bean" rel="noopener ugc nofollow" target="_blank">@Bean</a><br/>public CacheManager cacheManager<br/>    (RedisConnectionFactory connectionFactory) {<br/> <br/>    RedisCacheConfiguration defaultCacheConfig =               RedisCacheConfiguration.defaultCacheConfig();<br/>    defaultCacheConfig.disableCachingNullValues();</span><span id="2288" class="lp lq in mq b gy na mw l mx my">Map&lt;String, RedisCacheConfiguration&gt; cacheConfigurations = new   HashMap&lt;&gt;();<br/>    // APPNAME_CACHE_KEY* these are cache keys. <br/>    // You can define it as constants and use it in the config <br/>    // and also in your annotations.<br/>    // appNameCache* are the number of seconds, <br/>    // minutes or hours you want to set your TTL. <br/>    // You can define it in your application properties<br/>    // or tomcat properties. <br/>    cacheConfigurations.put(<br/>        APPNAME_CACHE_KEY1,defaultCacheConfig.entryTtl(<br/>            Duration.ofSeconds(appNameCache1)<br/>        )<br/>    );<br/>    cacheConfigurations.put(<br/>        APPNAME_CACHE_KEY2,defaultCacheConfig.entryTtl(<br/>            Duration.ofMinutes(appNameCache2)<br/>        )<br/>    );<br/>    cacheConfigurations.put(<br/>        APPNAME_CACHE_KEY3,defaultCacheConfig.entryTtl(<br/>            Duration.ofHours(appNameCache3)<br/>        )<br/>    );<br/>    return RedisCacheManager<br/>        .builder(connectionFactory)<br/>        .cacheDefaults(defaultCacheConfig)<br/>        .withInitialCacheConfigurations(cacheConfigurations)<br/>        .build();<br/>}</span></pre><h2 id="845f" class="lp lq in bd lr ls lt dn lu lv lw dp lx jv ly lz ma jz mb mc md kd me mf mg mh bi translated">依赖于数据库和服务端代码的响应</h2><p id="9e1f" class="pw-post-body-paragraph jk jl in jm b jn mi jp jq jr mj jt ju jv mk jx jy jz ml kb kc kd mm kf kg kh ig bi translated">在这种情况下，响应不仅依赖于数据库，还依赖于服务端代码。因此，我们必须做我们在第二种情况下正在做的事情，但除此之外，我们还必须考虑我们部署新版本代码的频率。有时服务的新版本会引入对 UI 有害的突破性变化。</p><p id="a0ab" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">基本上有两种方法可以解决这个问题。</p><ol class=""><li id="0132" class="ku kv in jm b jn jo jr js jv kw jz kx kd ky kh kz la lb lc bi translated">每当我们部署新的服务代码时，我们都需要手动清除缓存。我们甚至可以将这一步添加到 CI / CD 管道中，以便它可以清除缓存。</li><li id="738c" class="ku kv in jm b jn ld jr le jv lf jz lg kd lh kh kz la lb lc bi translated">第二种方法是将我们的应用程序版本添加到我们的缓存键中，在这种情况下，我们不需要做任何事情，缓存键本身会处理应用程序版本问题。</li></ol><p id="ccc6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们看看如何在《春靴》中完成第二部分。</p><pre class="kj kk kl km gt mr mq ms mt aw mu bi"><span id="0c34" class="lp lq in mq b gy mv mw l mx my"># In your application.yml just add this to get the project version<br/>app:<br/>    version: '<a class="ae mz" href="http://twitter.com/project" rel="noopener ugc nofollow" target="_blank">@project</a>.version@'</span><span id="7f47" class="lp lq in mq b gy na mw l mx my">// Then inside your controller. You can get the version like this <br/>// using @Value annotation<br/>@Value("${app.version}")<br/>private String appVersion;</span><span id="2578" class="lp lq in mq b gy na mw l mx my">// Then you can pass the app version to the service method which you // want to cache. <br/>@Cacheable(<br/>    cacheNames = APPNAME_CACHE_KEY1, <br/>    key = "{ #arg1,#appVersion}", unless = "#result == null"<br/>)<br/>ClassName getResponse(final String arg1,final String appVersion);</span></pre></div><div class="ab cl li lj hr lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="ig ih ii ij ik"><p id="a9df" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果您想了解更多关于 Redis 缓存的内容，可以浏览这些</p><ol class=""><li id="75c3" class="ku kv in jm b jn jo jr js jv kw jz kx kd ky kh kz la lb lc bi translated"><a class="ae mz" rel="noopener ugc nofollow" target="_blank" href="/multilevel-redis-caching-to-improve-performance-8603f0ea146f">https://blog . dev genius . io/multi level-redis-caching-to-improve-performance-8603 f0ea 146 f</a></li><li id="9776" class="ku kv in jm b jn ld jr le jv lf jz lg kd lh kh kz la lb lc bi translated">https://www.baeldung.com/spring-boot-redis-cache<a class="ae mz" href="https://www.baeldung.com/spring-boot-redis-cache" rel="noopener ugc nofollow" target="_blank"/></li><li id="ecd6" class="ku kv in jm b jn ld jr le jv lf jz lg kd lh kh kz la lb lc bi translated"><a class="ae mz" href="https://docs.spring.io/spring-data/redis/docs/current/api/org/springframework/data/redis/cache/RedisCacheConfiguration.html" rel="noopener ugc nofollow" target="_blank">https://docs . spring . io/spring-data/redis/docs/current/API/org/spring framework/data/redis/cache/rediscacheconfiguration . html</a></li><li id="5c27" class="ku kv in jm b jn ld jr le jv lf jz lg kd lh kh kz la lb lc bi translated"><a class="ae mz" href="https://docs.spring.io/spring-data/data-redis/docs/current/api/index.html?org/springframework/data/redis/core/TimeToLive.html" rel="noopener ugc nofollow" target="_blank">https://docs . spring . io/spring-data/data-redis/docs/current/API/index . html？org/spring framework/data/redis/core/time tolive . html</a></li></ol></div></div>    
</body>
</html>