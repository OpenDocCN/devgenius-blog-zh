<html>
<head>
<title>Sorting Algo’s in Python #Python Series-10</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python #Python 系列-10 中的排序算法</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/sorting-algos-in-python-python-series-10-32b1587f2ee7?source=collection_archive---------7-----------------------#2022-09-13">https://blog.devgenius.io/sorting-algos-in-python-python-series-10-32b1587f2ee7?source=collection_archive---------7-----------------------#2022-09-13</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="93d0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi ki translated"><span class="l kj kk kl bm km kn ko kp kq di">作为编程概念中的</span> for，排序算法及其应用在面试、竞争性编程和开发方面发挥着重要作用。因此，对于有抱负的软件开发人员来说，理清排序背后的概念非常重要。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/102793a56a6b094cb0b04d6840d6bef3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fyROVD8TCrRmxvKj"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">由<a class="ae lh" href="https://unsplash.com/@thetechnomaid?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">索菲·埃尔维斯</a>在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="a300" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">那么，什么是排序？为什么实际上需要它？</p><p id="2d7f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我从给你挑战的角度来解释你。我需要你教室里第三高的人。你怎么找到这个？。例如，假设你们班有 35 名学生，需要找出你们班第三高的人。你会怎么做？</p><p id="0fc3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我所做的只是让我的同学站成一排，然后通过比较其他同学的身高，根据他们的身高重新排列。那正好叫“<strong class="jm io">排序</strong>”。你根据身高重新排列/分类了你的同学。</p><p id="e70e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在程序设计语言中，排序是按升序/降序排列数字，或者按字母顺序排列字符，等等。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi li"><img src="../Images/cc19b3ab6b973ad3612d82da34abe1ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:494/format:webp/1*UKdhA7Ptz21JNd5evh7n4g.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">未排序列表到排序列表</figcaption></figure><p id="b9ed" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，你明白什么是排序了。</p></div><div class="ab cl lj lk hr ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="ig ih ii ij ik"><p id="6096" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在编程界，我们很少有排序算法是相当有名的，也是技术面试中经常被问到的。</p><blockquote class="lq lr ls"><p id="ed38" class="jk jl lt jm b jn jo jp jq jr js jt ju lu jw jx jy lv ka kb kc lw ke kf kg kh ig bi translated"><strong class="jm io"> <em class="in">选择排序、插入排序、冒泡排序、合并排序、快速排序</em> </strong></p></blockquote><p id="ec6f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">每种排序算法都有自己的优缺点。一旦我们理解了每种排序算法的工作原理，我们将在后面讨论。</p><blockquote class="lq lr ls"><p id="7608" class="jk jl lt jm b jn jo jp jq jr js jt ju lu jw jx jy lv ka kb kc lw ke kf kg kh ig bi translated"><strong class="jm io">注意:</strong>所有排序算法的最终结果都是一样的，唯一的区别是它们如何排序。</p></blockquote><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi lx"><img src="../Images/36e4db7bf56e29ba0ec712a58b1367f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:996/1*jLzsj1430ffTezGBi6WceQ.gif"/></div></figure></div><div class="ab cl lj lk hr ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="ig ih ii ij ik"><p id="0fd2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">选择排序算法</strong></p><p id="34c6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这种排序数字的方法太天真了。所以，我给你 7 个数字，它们随机排列，你的工作是按升序排列。你会怎么做？</p><p id="b6f3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你取第一个数字，并与其他元素比较，如果元素小于第一个数字，你只需更新变量中的小值索引，这样做，直到你到达列表的末尾。这样，我们得到了最小的元素，现在你只需要用第一个元素的变量索引值来交换它。对下一个元素做完全相同的操作。当你第六次继续这个过程时，你就完成了列表的排序。</p><p id="3fb6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在对元素的第一次迭代中，你得到第一个最小的元素索引，然后把它和第 0 个索引交换。</p><p id="78d3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在对元素的第二次迭代中，你得到第二个最小的元素索引，并与第一个索引交换。</p><p id="92b3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当你完成第 6 次迭代时，你的列表已经排序了，因为在第 7 次迭代时，没有元素可以和第 6 次索引进行比较。</p><p id="30db" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一般来说，对于 n 个元素。你迭代(n-1)次。</p><p id="7944" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们深入研究选择排序算法的 Python 代码</p><pre class="ks kt ku kv gt ly lz ma mb aw mc bi"><span id="08db" class="md me in lz b gy mf mg l mh mi">def selection_sort(my_list):<br/>    if len(my_list) == 1:<br/>        return my_list<br/>    for i in range(len(my_list) - 1):<br/>        smallest_value_index = i<br/>        # for comparing all elements next to i<br/>        for j in range(i + 1, len(my_list)):<br/>            if my_list[smallest_value_index] &gt; my_list[j]:<br/>                smallest_value_index = j<br/><br/>        # At this point, I got the smallest value that can fit in index-i<br/>        my_list[i], my_list[smallest_value_index] = my_list[smallest_value_index], my_list[i]<br/><br/><br/>if __name__ == "__main__":<br/>    my_list = [5, 4, 3, 1, 7, 2, 6]<br/>    selection_sort(my_list)<br/>    print(my_list)</span></pre></div><div class="ab cl lj lk hr ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="ig ih ii ij ik"><p id="49bc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">冒泡排序算法</strong></p><p id="a4b8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">用简单的话来定义冒泡排序，在一个列表中，比较当前元素和下一个元素。如果当前元素大于下一个元素，你交换这些元素，否则你只需在其他元素上继续这个过程。就是这样。</p><p id="c770" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在冒泡排序中要注意的要点是，在一次完整的迭代中，最后一个元素将到达它的正确位置(意味着最高值元素到达它的索引)。在第二次迭代中，你不需要迭代直到最后一个元素在每次迭代中都到达它的索引。</p><p id="00c2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在第一次迭代时；[5，4，3，1，7，2，6] → [4，3，1，5，2，6，<strong class="jm io"> 7 </strong></p><p id="fc27" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在第二次迭代时:[4，3，1，5，2，6，7] [1，3，2，4，5，<strong class="jm io"> 6，7] </strong></p><p id="41bc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">将有 7 个元素，将有 6 次迭代。那么，对于 n 个元素，将有(n-1)个元素。</p><p id="a5ab" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了更好地理解，让我们看看冒泡排序算法 Python 代码</p><pre class="ks kt ku kv gt ly lz ma mb aw mc bi"><span id="5ae3" class="md me in lz b gy mf mg l mh mi">def bubble_sort(my_list):<br/>    if len(my_list) == 1:<br/>        return my_list<br/><br/>    length = len(my_list)<br/>    for i in range(length - 1):<br/>        j = 0<br/>        end_index = length - i - 1<br/>        while j &lt; end_index:<br/>            if my_list[j] &gt; my_list[j + 1]:<br/>                my_list[j], my_list[j + 1] = my_list[j + 1], my_list[j]<br/>            j = j + 1<br/>        print(my_list)<br/><br/><br/>if __name__ == "__main__":<br/>    my_list = [5, 4, 3, 1, 7, 2, 6]<br/>    bubble_sort(my_list)<br/>    print(my_list)</span></pre></div><div class="ab cl lj lk hr ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="ig ih ii ij ik"><p id="9937" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">插入排序算法</strong></p><p id="432f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这种算法也很简单，但理解和编码起来相当棘手。我们来详细了解一下 algo。</p><p id="b088" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在插入排序中，我们将考虑两个部分，一个→排序部分，另一个→未排序部分。首先，在 7 个元素中，让我们考虑仅第 0 个索引元素被排序，并且从第 1 到第 6 个索引作为未排序的索引。</p><p id="7cb4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们从第 1 个索引开始迭代，因为第 0 个索引被视为排序部分。现在，我们迭代未排序部分中的每个元素，并将它们放在排序列表中的正确位置。</p><p id="9995" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在列表中[5，4，3，1，7，2，6]。已排序部分为[5]，未排序部分= [4，3，1，7，2，6]。我们迭代未排序列表中的每个元素。假设未排序部分中的 4 与排序部分中的元素进行比较。As 4 &lt; 5, 5 is moved to next element position and 4 sits in 0th index</p><p id="8214" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">As result of 1st Iteration: Sorted part: [4,5] , Unsorted part: [3,1,7,2,6]</p><p id="fa30" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">As result of 2nd Iteration: Sorted part: [3,4,5] , Unsorted part: [1, 7, 2, 6]</p><p id="4ac7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">As result of 3rd Iteration: Sorted part: [1,3,4,5] , Unsorted part: [7,2,6]</p><p id="c6af" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">As result of 4th Iteration: Sorted part: [1,3,4,5,7] , Unsorted part: [2,6]</p><p id="79c9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">As result of 5th Iteration: Sorted part: [1,3,4,5,7] , Unsorted part: [2,6]</p><p id="e07c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">As result of 5th Iteration: Sorted part: [1,2,3,4,5,7] , Unsorted part: [6]</p><p id="ec21" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">As result of 6th Iteration: Sorted part: [1,2,3,4,5,6,7] , Unsorted part: []</p><p id="36a0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">The list is sorted. We move till the final element in the list and put them on the correct index in sorted list.</p><p id="25df" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Here is your</p><pre class="ks kt ku kv gt ly lz ma mb aw mc bi"><span id="b3ad" class="md me in lz b gy mf mg l mh mi">def insertion_sort(my_list):<br/>    if len(my_list) == 1:<br/>        return my_list<br/>    length = len(my_list)<br/>    for i in range(1,length):<br/>        current_element = my_list[i]<br/>        j = i - 1<br/>        while j &gt;= 0:<br/>            if my_list[j]&gt;current_element:<br/>                my_list[j+1] = my_list[j]<br/>                j = j - 1<br/>            else:<br/>                break<br/>        my_list[j+1] = current_element<br/><br/><br/>if __name__ == "__main__":<br/>    my_list = [5, 4, 5, 1, 7, 2, 6]<br/>    insertion_sort(my_list)<br/>    print(my_list)</span></pre><p id="6cfb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">As, the next two sorting algorithms (<strong class="jm io">归并排序</strong> &amp; <strong class="jm io">快速排序</strong>处理递归。在下一篇文章中，我们将看到递归是如何工作的，以及递归过程背后的工作原理，然后我们将使用合并和快速排序算法…</p><p id="d4ab" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在那之前，祝编程愉快😉。我的<strong class="jm io">大</strong>感谢人们欣赏我以前的文章，如果你错过了这个系列，你可以查看这个<a class="ae lh" href="https://medium.com/@psmohammedali" rel="noopener"> <strong class="jm io">链接</strong> </a>，在那里你可以以初学者友好的方式阅读我以前的 8+篇关于 python 基本概念的文章。</p></div></div>    
</body>
</html>