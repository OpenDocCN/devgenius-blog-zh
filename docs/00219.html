<html>
<head>
<title>Liskov’s Substitution Principle | SOLID as a Rock</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利斯科夫的替代原理|坚如磐石</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/liskovs-substitution-principle-solid-as-a-rock-1cc5bdcee16e?source=collection_archive---------3-----------------------#2020-05-18">https://blog.devgenius.io/liskovs-substitution-principle-solid-as-a-rock-1cc5bdcee16e?source=collection_archive---------3-----------------------#2020-05-18</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div class="gh gi jk"><img src="../Images/132b479bb8bc71f75c4abceafe285b59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*Xq8wk71JXIQ9WxJYH-BxrQ.png"/></div></figure><p id="d6c4" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">所以你知道一般如何编码，了解面向对象编程，学过C++，完成了至少一门软件开发课程(如果你还没有，这些文章不适合你)。如果你知道至少一种编程语言，你可以很容易地编写软件，但是你的代码好吗？还能做得更好吗？它干净吗(这到底是什么意思)？你的建筑好吗？你应该使用不同的吗？设计模式呢？这些是我刚开始工作时遇到的一些问题，回答这些问题帮助我提升到了专业水平。这就是为什么我写了这些系列坚实的岩石设计原则。<strong class="jt io"> L </strong>伊斯科夫的<strong class="jt io">S</strong>substitution<strong class="jt io">P</strong>c++原理是我将在这里讨论的这个系列的第二个原理。</p><blockquote class="kq kr ks"><p id="5992" class="jr js kt jt b ju jv jw jx jy jz ka kb ku kd ke kf kv kh ki kj kw kl km kn ko ig bi translated"><em class="in"> /！\:原载@</em><a class="ae kp" href="http://www.vishalchovatiya.com/category/design-patterns/" rel="noopener ugc nofollow" target="_blank"><em class="in">www.vishalchovatiya.com</em></a><em class="in">。</em></p></blockquote><p id="9071" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">顺便说一句，如果你还没有浏览过我以前关于设计原则的文章，下面是快速链接:</p><ol class=""><li id="6572" class="kx ky in jt b ju jv jy jz kc kz kg la kk lb ko lc ld le lf bi translated"><a class="ae kp" href="http://www.vishalchovatiya.com/single-responsibility-principle-in-cpp-solid-as-a-rock/" rel="noopener ugc nofollow" target="_blank"> <strong class="jt io"> S </strong> RP —单一责任原则</a></li><li id="5852" class="kx ky in jt b ju lg jy lh kc li kg lj kk lk ko lc ld le lf bi translated"><a class="ae kp" href="http://www.vishalchovatiya.com/open-closed-principle-in-cpp-solid-as-a-rock/" rel="noopener ugc nofollow" target="_blank"> <strong class="jt io"> O </strong> CP —开启/关闭原理</a></li><li id="60f4" class="kx ky in jt b ju lg jy lh kc li kg lj kk lk ko lc ld le lf bi translated"><a class="ae kp" href="http://www.vishalchovatiya.com/liskovs-substitution-principle-in-cpp-solid-as-a-rock/" rel="noopener ugc nofollow" target="_blank">T25】LSP—利斯科夫替代原理</a></li><li id="bc71" class="kx ky in jt b ju lg jy lh kc li kg lj kk lk ko lc ld le lf bi translated"><a class="ae kp" href="http://www.vishalchovatiya.com/interface-segregation-principle-in-cpp-solid-as-a-rock/" rel="noopener ugc nofollow" target="_blank"> <strong class="jt io"> I </strong> SP —界面偏析原理</a></li><li id="96c9" class="kx ky in jt b ju lg jy lh kc li kg lj kk lk ko lc ld le lf bi translated"><a class="ae kp" href="http://www.vishalchovatiya.com/dependency-inversion-principle-in-cpp-solid-as-a-rock/" rel="noopener ugc nofollow" target="_blank"> <strong class="jt io"> D </strong> IP —依赖反转原理</a></li></ol><p id="43bc" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">您在这一系列文章中看到的代码片段是简化的，而不是复杂的。所以你经常看到我不使用像<code class="fe ll lm ln lo b">override</code>、<code class="fe ll lm ln lo b">final</code>、<code class="fe ll lm ln lo b">public</code>(同时继承)这样的关键字，只是为了让代码紧凑&amp;可消耗(大部分时间)在单一标准屏幕尺寸。我也更喜欢<code class="fe ll lm ln lo b">struct</code>而不是<code class="fe ll lm ln lo b">class</code>，只是为了节省代码行，有时不写<code class="fe ll lm ln lo b">public:</code>，还会故意忽略<a class="ae kp" href="http://www.vishalchovatiya.com/part-3-all-about-virtual-keyword-in-c-how-virtual-destructor-works/" rel="noopener ugc nofollow" target="_blank">虚拟析构函数</a>，构造函数<a class="ae kp" href="http://www.vishalchovatiya.com/all-about-copy-constructor-in-cpp-with-example/" rel="noopener ugc nofollow" target="_blank">，复制构造函数</a>，前缀<code class="fe ll lm ln lo b">std::</code>，删除动态内存。我也认为自己是一个务实的人，希望用尽可能简单的方式，而不是标准的方式或使用术语来传达一个想法。</p><p id="8754" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><strong class="jt io"> <em class="kt">注:</em> </strong></p><ul class=""><li id="7488" class="kx ky in jt b ju jv jy jz kc kz kg la kk lb ko lp ld le lf bi translated">如果你是在这里被直接绊倒的，那么我建议你浏览一下<a class="ae kp" href="http://www.vishalchovatiya.com/what-is-design-pattern/" rel="noopener ugc nofollow" target="_blank">什么是设计模式？</a>一、哪怕是鸡毛蒜皮的小事。相信会鼓励你对这个话题进行更多的探索。</li><li id="ff35" class="kx ky in jt b ju lg jy lh kc li kg lj kk lk ko lp ld le lf bi translated">您在本系列文章中遇到的所有这些代码都是使用C++20编译的(尽管我在大多数情况下使用了C++17之前的现代C++特性)。因此，如果你无法获得最新的编译器，你可以使用已经预装了boost库的<a class="ae kp" href="https://wandbox.org/" rel="noopener ugc nofollow" target="_blank">https://wandbox.org/</a>。</li></ul><h1 id="47ae" class="lq lr in bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">目的</h1><blockquote class="kq kr ks"><p id="1498" class="jr js kt jt b ju jv jw jx jy jz ka kb ku kd ke kf kv kh ki kj kw kl km kn ko ig bi translated"><strong class="jt io">在不改变程序正确性的情况下，子类型必须可以替换它们的基本类型</strong></p></blockquote><ul class=""><li id="7362" class="kx ky in jt b ju jv jy jz kc kz kg la kk lb ko lp ld le lf bi translated">如果我在C++的上下文中解决这个问题，这实际上意味着使用指向基类的指针/引用的函数必须能够被它的派生类替换。</li><li id="89d1" class="kx ky in jt b ju lg jy lh kc li kg lj kk lk ko lp ld le lf bi translated">Liskov替换原则围绕着确保正确使用继承。</li></ul><h1 id="6893" class="lq lr in bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">违反了利斯科夫替代原理</h1><ul class=""><li id="7ccc" class="kx ky in jt b ju mo jy mp kc mq kg mr kk ms ko lp ld le lf bi translated">说明LSP的一个伟大而传统的例子是，有时在自然语言中听起来正确的东西在代码中并不完全有效。</li><li id="4dd2" class="kx ky in jt b ju lg jy lh kc li kg lj kk lk ko lp ld le lf bi translated">在数学中，一个<code class="fe ll lm ln lo b">Square</code>就是一个<code class="fe ll lm ln lo b">Rectangle</code>。事实上，它是一个矩形的特化。“是A”让你想用继承来建模。然而，如果在代码中你让<code class="fe ll lm ln lo b">Square</code>从<code class="fe ll lm ln lo b">Rectangle</code>派生，那么<code class="fe ll lm ln lo b">Square</code>应该可以在你期望<code class="fe ll lm ln lo b">Rectangle</code>的任何地方使用。这导致了如下一些奇怪的行为:</li></ul><pre class="mt mu mv mw gt mx lo my mz aw na bi"><span id="3f12" class="nb lr in lo b gy nc nd l ne nf">struct Rectangle {<br/>    Rectangle(const uint32_t width, const uint32_t height) : m_width{width}, m_height{height} {}</span><span id="3c91" class="nb lr in lo b gy ng nd l ne nf">    uint32_t get_width() const { return m_width; }<br/>    uint32_t get_height() const { return m_height; }</span><span id="d22a" class="nb lr in lo b gy ng nd l ne nf">    virtual void set_width(const uint32_t width) { this-&gt;m_width = width; }<br/>    virtual void set_height(const uint32_t height) { this-&gt;m_height = height; }</span><span id="371c" class="nb lr in lo b gy ng nd l ne nf">    uint32_t area() const { return m_width * m_height; }</span><span id="8fcd" class="nb lr in lo b gy ng nd l ne nf">protected:<br/>    uint32_t m_width, m_height;<br/>};</span><span id="08b9" class="nb lr in lo b gy ng nd l ne nf">struct Square : Rectangle {<br/>    Square(uint32_t size) : Rectangle(size, size) {}<br/>    void set_width(const uint32_t width) override { this-&gt;m_width = m_height = width; }<br/>    void set_height(const uint32_t height) override { this-&gt;m_height = m_width = height; }<br/>};</span><span id="e38e" class="nb lr in lo b gy ng nd l ne nf">void process(Rectangle &amp;r) {<br/>    uint32_t w = r.get_width();<br/>    r.set_height(10);</span><span id="be09" class="nb lr in lo b gy ng nd l ne nf">    assert((w * 10) == r.area()); // Fails for Square &lt;--------------------<br/>}</span><span id="422c" class="nb lr in lo b gy ng nd l ne nf">int main() {<br/>    Rectangle r{5, 5};<br/>    process(r);<br/>    Square s{5};<br/>    process(s);<br/>    return EXIT_SUCCESS;<br/>}</span></pre><ul class=""><li id="1e51" class="kx ky in jt b ju jv jy jz kc kz kg la kk lb ko lp ld le lf bi translated">正如你在上面看到的，我们已经在<code class="fe ll lm ln lo b">void process(Rectangle &amp;r)</code>函数中违反了Liskovs的替换原则。因此<code class="fe ll lm ln lo b">Square</code>不是<code class="fe ll lm ln lo b">Rectangle</code>的有效替代。</li><li id="fb19" class="kx ky in jt b ju lg jy lh kc li kg lj kk lk ko lp ld le lf bi translated">如果你从设计的角度来看，从<code class="fe ll lm ln lo b">Rectangle</code>继承<code class="fe ll lm ln lo b">Square</code>的想法不是一个好主意。因为<code class="fe ll lm ln lo b">Square</code>没有高度&amp;宽度，而是有边的尺寸/长度。</li></ul><h1 id="c7af" class="lq lr in bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">利斯科夫的替代原理举例</h1><h1 id="f327" class="lq lr in bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">不太好</h1><pre class="mt mu mv mw gt mx lo my mz aw na bi"><span id="69eb" class="nb lr in lo b gy nc nd l ne nf">void process(Rectangle &amp;r) {<br/>    uint32_t w = r.get_width();<br/>    r.set_height(10);</span><span id="0e7b" class="nb lr in lo b gy ng nd l ne nf">    if (dynamic_cast&lt;Square *&gt;(&amp;r) != nullptr)<br/>        assert((r.get_width() * r.get_width()) == r.area());<br/>    else<br/>        assert((w * 10) == r.area());<br/>}</span></pre><ul class=""><li id="848e" class="kx ky in jt b ju jv jy jz kc kz kg la kk lb ko lp ld le lf bi translated">经常指示LSP违规的一个常见代码味道是多态代码块中出现的<a class="ae kp" href="http://www.vishalchovatiya.com/cpp-type-casting-with-example-for-c-developers/" rel="noopener ugc nofollow" target="_blank">类型检查</a>代码。</li><li id="636c" class="kx ky in jt b ju lg jy lh kc li kg lj kk lk ko lp ld le lf bi translated">例如，如果在类型为<code class="fe ll lm ln lo b">Foo</code>的对象集合上有一个<code class="fe ll lm ln lo b">std::for_each</code>循环，并且在这个循环中，有一个检查来查看<code class="fe ll lm ln lo b">Foo</code>是否实际上是<code class="fe ll lm ln lo b">Bar</code>(<code class="fe ll lm ln lo b">Foo</code>的一个子类型)，那么这几乎肯定是LSP违规。相反，你应该确保<code class="fe ll lm ln lo b">Bar</code>在所有方面都可以替代<code class="fe ll lm ln lo b">Foo</code>，没有必要包含这样的检查。</li></ul><h1 id="fccc" class="lq lr in bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">做这件事的好方法</h1><pre class="mt mu mv mw gt mx lo my mz aw na bi"><span id="259b" class="nb lr in lo b gy nc nd l ne nf">void process(Rectangle &amp;r) {<br/>    uint32_t w = r.get_width();<br/>    r.set_height(10);</span><span id="fdf7" class="nb lr in lo b gy ng nd l ne nf">    if (r.is_square())<br/>        assert((r.get_width() * r.get_width()) == r.area());<br/>    else<br/>        assert((w * 10) == r.area());<br/>}</span></pre><ul class=""><li id="7913" class="kx ky in jt b ju jv jy jz kc kz kg la kk lb ko lp ld le lf bi translated">不需要为<code class="fe ll lm ln lo b">Square</code>创建单独的类。相反，您可以简单地检查<code class="fe ll lm ln lo b">Rectangle</code>类中的<code class="fe ll lm ln lo b">bool</code>标志来验证<code class="fe ll lm ln lo b">Square</code>属性。尽管这不是推荐的方式。</li></ul><h1 id="0be1" class="lq lr in bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">使用正确的继承层次结构</h1><pre class="mt mu mv mw gt mx lo my mz aw na bi"><span id="bc39" class="nb lr in lo b gy nc nd l ne nf">struct Shape {<br/>    virtual uint32_t area() const = 0;<br/>};</span><span id="516d" class="nb lr in lo b gy ng nd l ne nf">struct Rectangle : Shape {<br/>    Rectangle(const uint32_t width, const uint32_t height) : m_width{width}, m_height{height} {}</span><span id="da51" class="nb lr in lo b gy ng nd l ne nf">    uint32_t get_width() const { return m_width; }<br/>    uint32_t get_height() const { return m_height; }</span><span id="f35b" class="nb lr in lo b gy ng nd l ne nf">    virtual void set_width(const uint32_t width) { this-&gt;m_width = width; }<br/>    virtual void set_height(const uint32_t height) { this-&gt;m_height = height; }</span><span id="767c" class="nb lr in lo b gy ng nd l ne nf">    uint32_t area() const override { return m_width * m_height; }</span><span id="e31c" class="nb lr in lo b gy ng nd l ne nf">private:<br/>    uint32_t m_width, m_height;<br/>};</span><span id="8604" class="nb lr in lo b gy ng nd l ne nf">struct Square : Shape {<br/>    Square(uint32_t size) : m_size(size) {}<br/>    void set_size(const uint32_t size) { this-&gt;m_size = size; }<br/>    uint32_t area() const override { return m_size * m_size; }</span><span id="57f4" class="nb lr in lo b gy ng nd l ne nf">private:<br/>    uint32_t m_size;<br/>};</span><span id="44f2" class="nb lr in lo b gy ng nd l ne nf">void process(Shape &amp;s) {<br/>    // Use polymorphic behaviour only i.e. area()<br/>}</span></pre><h1 id="58dd" class="lq lr in bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">使用工厂模式</h1><ul class=""><li id="0c4c" class="kx ky in jt b ju mo jy mp kc mq kg mr kk ms ko lp ld le lf bi translated">尽管如此，还是需要创建或更改来处理<code class="fe ll lm ln lo b">Shape</code>，那么你应该尝试使用<a class="ae kp" href="http://www.vishalchovatiya.com/7-advanced-cpp-concepts-idiom-examples-you-should-know/#Virtual-Constructor" rel="noopener ugc nofollow" target="_blank">虚拟构造器</a> &amp; <a class="ae kp" href="http://www.vishalchovatiya.com/prototype-design-pattern-in-modern-cpp/" rel="noopener ugc nofollow" target="_blank">虚拟复制构造器</a>即<a class="ae kp" href="http://www.vishalchovatiya.com/factory-design-pattern-in-modern-cpp/" rel="noopener ugc nofollow" target="_blank">工厂模式</a>。</li></ul><pre class="mt mu mv mw gt mx lo my mz aw na bi"><span id="8847" class="nb lr in lo b gy nc nd l ne nf">struct ShapeFactory {<br/>    static Shape CreateRectangle(uint32_t width, uint32_t height);<br/>    static Shape CreateSquare(uint32_t size);<br/>};</span></pre><h1 id="f239" class="lq lr in bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">利斯科夫替代原理的好处</h1><h1 id="8dc1" class="lq lr in bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">= &gt;兼容性</h1><ul class=""><li id="2d58" class="kx ky in jt b ju mo jy mp kc mq kg mr kk ms ko lp ld le lf bi translated">它支持多个版本和补丁之间的二进制兼容性。换句话说，它使客户端代码免受影响。</li></ul><h1 id="797d" class="lq lr in bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">= &gt;类型安全</h1><ul class=""><li id="1b5a" class="kx ky in jt b ju mo jy mp kc mq kg mr kk ms ko lp ld le lf bi translated">这是用继承处理类型安全的最简单的方法，因为类型在继承时不允许<em class="kt">改变</em>。</li></ul><h1 id="b4d4" class="lq lr in bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">= &gt;可维护性</h1><ul class=""><li id="3cac" class="kx ky in jt b ju mo jy mp kc mq kg mr kk ms ko lp ld le lf bi translated">遵循LSP的代码松散地相互依赖&amp;鼓励代码的可重用性。</li><li id="c5ef" class="kx ky in jt b ju lg jy lh kc li kg lj kk lk ko lp ld le lf bi translated">遵循LSP的代码是做出正确抽象的代码。</li></ul><h1 id="769b" class="lq lr in bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">尺度来制作利斯科夫替代原理友好软件</h1><ul class=""><li id="322c" class="kx ky in jt b ju mo jy mp kc mq kg mr kk ms ko lp ld le lf bi translated">在大多数对<a class="ae kp" href="http://www.vishalchovatiya.com/memory-layout-of-cpp-object/" rel="noopener ugc nofollow" target="_blank">面向对象编程</a>的介绍中，继承被讨论为与被继承对象的“是-A”关系。然而，这是必要的，但还不够。更恰当的说法是，如果一个对象总是与被继承的对象有“可替换”的关系，那么它可以被设计为从另一个对象继承。</li><li id="433e" class="kx ky in jt b ju lg jy lh kc li kg lj kk lk ko lp ld le lf bi translated">使用抽象基类的全部意义在于，将来你可以编写一个新的<a class="ae kp" href="http://www.vishalchovatiya.com/inside-the-cpp-object-model/" rel="noopener ugc nofollow" target="_blank">子类</a> &amp;插入到现有的、工作的、经过测试的代码中。一个崇高的目标，但如何实现呢？首先，从分解你的问题空间--领域开始。其次，用简单的英语表达你的契约/接口/ <a class="ae kp" href="http://www.vishalchovatiya.com/part-1-all-about-virtual-keyword-in-cpp-how-virtual-function-works-internally/" rel="noopener ugc nofollow" target="_blank">虚方法</a>。</li></ul><h1 id="7d80" class="lq lr in bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">结束语</h1><p id="499b" class="pw-post-body-paragraph jr js in jt b ju mo jw jx jy mp ka kb kc nh ke kf kg ni ki kj kk nj km kn ko ig bi translated">不要误解我，我喜欢SOLID和它所提倡的方法。但这只是其基础中更深层原则的一种形式。上面的例子清楚地表明了这个原则的目的，即<strong class="jt io"> <em class="kt">松耦合&amp;确保正确的继承</em> </strong>。</p><p id="2354" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">现在，走出去，让你的子类可交换，感谢<a class="ae kp" href="https://en.wikipedia.org/wiki/Barbara_Liskov" rel="noopener ugc nofollow" target="_blank"> <strong class="jt io">芭芭拉·利斯科夫</strong> </a>博士，感谢他如此有用的原理。</p><p id="aa34" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><a class="ae kp" href="http://www.vishalchovatiya.com/contact-2/" rel="noopener ugc nofollow" target="_blank">有什么建议，查询或者想说</a> <code class="fe ll lm ln lo b"><a class="ae kp" href="http://www.vishalchovatiya.com/contact-2/" rel="noopener ugc nofollow" target="_blank">Hi</a></code> <a class="ae kp" href="http://www.vishalchovatiya.com/contact-2/" rel="noopener ugc nofollow" target="_blank">？减轻压力，只需点击一下鼠标。</a> 🖱️</p></div></div>    
</body>
</html>