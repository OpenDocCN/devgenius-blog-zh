<html>
<head>
<title>How Can You Solve This Java Multithreading Interview Problem?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何解决这个 Java 多线程面试问题？</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-can-you-solve-this-java-multithreading-interview-problem-8e6ec53fab27?source=collection_archive---------1-----------------------#2022-07-16">https://blog.devgenius.io/how-can-you-solve-this-java-multithreading-interview-problem-8e6ec53fab27?source=collection_archive---------1-----------------------#2022-07-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4280" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">方案</h2></div><p id="e16c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设我们有两个线程。在<em class="lb"> Thread1 </em>中，我们将整数字段“<em class="lb"> count </em>”加 1。在<em class="lb"> Thread2 </em>中，如果我们看到计数大于 1，我们将打印行“t2 running”。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="lh li l"/></div></figure><p id="64e8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们循环这个<em class="lb"> run() </em>方法 100 次，每次我们打印第 n 个循环时，输出如下:</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi lj"><img src="../Images/67127a9b42605fb40761ff6b56616136.png" data-original-src="https://miro.medium.com/v2/resize:fit:724/format:webp/1*IvLGfu6Ic5Qi5T97M4DxGQ.png"/></div></figure><p id="c76d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在某些循环中(如 91，97)，不打印<em class="lb">线程 2 </em>中的字符串。这是因为不能保证<em class="lb">线程 1 </em>总是在<em class="lb">线程 2 </em>之前执行。</p><p id="142a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">现在，您可以对代码进行哪些更改，以便始终打印<em class="lb"> Thread2 </em>字符串？</strong></p><p id="3704" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以下是一些限制条件:</p><ol class=""><li id="3ed7" class="lm ln iq kh b ki kj kl km ko lo ks lp kw lq la lr ls lt lu bi translated">不要使用<em class="lb"> Thread.sleep() </em>或任何类似的工具轻松脱身:)</li><li id="d959" class="lm ln iq kh b ki lv kl lw ko lx ks ly kw lz la lr ls lt lu bi translated">您不能修改<em class="lb">逻辑 1 </em>和<em class="lb">逻辑 2 的零件。然而，你可以在逻辑之上或之下添加代码。</em></li></ol><p id="bd78" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们暂停 5 秒钟。</p><p id="1257" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">…你有什么解决办法吗？</p><h2 id="86a7" class="ma mb iq bd mc md me dn mf mg mh dp mi ko mj mk ml ks mm mn mo kw mp mq mr ms bi translated">也许这个？</h2><p id="0d00" class="pw-post-body-paragraph kf kg iq kh b ki mt jr kk kl mu ju kn ko mv kq kr ks mw ku kv kw mx ky kz la ij bi translated">有些人可能会说，让我们为锁机制创建一个对象。我们可以使用对象<strong class="kh ir">等待通知</strong>机制让<em class="lb">线程 2 </em>先等待。线程 1 完成增量后，让它通知<em class="lb">线程 2 </em>进一步执行。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="lh li l"/></div></figure><p id="806f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">经过测试，在我运行该方法的 100 次中，<strong class="kh ir">只有 5 次</strong>在我的机器上返回“t2 running”字符串。</p><h2 id="1d87" class="ma mb iq bd mc md me dn mf mg mh dp mi ko mj mk ml ks mm mn mo kw mp mq mr ms bi translated">为什么会这样呢？</h2><p id="f342" class="pw-post-body-paragraph kf kg iq kh b ki mt jr kk kl mu ju kn ko mv kq kr ks mw ku kv kw mx ky kz la ij bi translated">这是因为在大多数情况下，甚至在<em class="lb">线程 2 </em>开始<em class="lb">等待()</em>之前，<em class="lb">线程 1 </em>已经调用了<em class="lb">通知()</em>。当<em class="lb"> Thread1 </em>通知时，没有线程在等待队列中！当<em class="lb"> Thread2 </em>开始执行时，它进入一个无休止的 wait()状态。</p><h2 id="7d41" class="ma mb iq bd mc md me dn mf mg mh dp mi ko mj mk ml ks mm mn mo kw mp mq mr ms bi translated">如何才能提高？</h2><p id="8086" class="pw-post-body-paragraph kf kg iq kh b ki mt jr kk kl mu ju kn ko mv kq kr ks mw ku kv kw mx ky kz la ij bi translated">在上面的代码中，我们基本上需要注意一件事——确保<em class="lb">线程 2 </em>在<em class="lb">线程 1 </em>通知之前等待。你怎么做到的？</p><p id="219a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">方法之一是使用<strong class="kh ir"> <em class="lb"> FutureTask </em> </strong>。我们可以定义一个定制的 FutureTask，在本例中，是创建一个<em class="lb">可调用的</em>对象，该对象在被调用时将返回一个字符串“MyTask”。</p><p id="25c0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<em class="lb"> Thread1 </em>中，我们将要求 FutureTask 对象获得结果。在<em class="lb">线程 2 </em>中，我们将运行任务。这样，<em class="lb"> Thread1 </em>只能在<em class="lb"> Thread2 </em>运行任务并进入<em class="lb"> synchronized </em>块的等待状态后增加计数值。更新计数后，<em class="lb"> Thread1 </em>通知<em class="lb"> Thread2 </em>继续执行打印字符串。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="lh li l"/></div></figure><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi my"><img src="../Images/32bf1e374fcc5ef3f018653ecce52f06.png" data-original-src="https://miro.medium.com/v2/resize:fit:940/format:webp/1*OpWWtZWkQImEovhx0-QgaQ.png"/></div></figure><p id="ba9d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们再次运行程序 100 次，看看每个调用是否能够返回“t2 running”字符串。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi mz"><img src="../Images/913aa95601907046c7f6a76fb754323a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IkAozSkJYXasdB7Xzh36WQ.png"/></div></div></figure><p id="45f5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以看到，在 FutureTask 和 synchronized lock 的帮助下，所有 100 个循环都打印了<em class="lb"> Thread2 </em>字符串。</p><p id="6b12" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当然，解决这个问题的可能性更多。例如，可以使用阻塞队列来代替 FutureTask 或信号量。欢迎在下面留下你的答案。</p></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><p id="8c0d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我希望这篇文章对你有所帮助。如果你像我一样，渴望学习 Java 和更多关于后端工程的知识，请关注我的频道，了解我在日常工作和生活中获得的灵感。</p><blockquote class="nl nm nn"><p id="692c" class="kf kg lb kh b ki kj jr kk kl km ju kn no kp kq kr np kt ku kv nq kx ky kz la ij bi translated"><strong class="kh ir"> <em class="iq">阅读更多:</em> </strong> <em class="iq"> <br/> </em> <a class="ae nr" rel="noopener ugc nofollow" target="_blank" href="/a-case-about-java-static-keyword-during-my-job-53cebb6af597"> <em class="iq">一个关于 Java 静态关键字在职期间的案例</em></a><em class="iq"><br/></em><a class="ae nr" href="https://medium.com/geekculture/how-to-auto-generate-repetitive-java-code-to-save-your-time-c89a57652e90" rel="noopener"><em class="iq">如何自动生成重复的 Java 代码以节省您的时间</em> </a></p><p id="7ef5" class="kf kg lb kh b ki kj jr kk kl km ju kn no kp kq kr np kt ku kv nq kx ky kz la ij bi translated"><strong class="kh ir"> <em class="iq">获取连接:</em></strong><em class="iq"><br/></em><a class="ae nr" href="https://www.linkedin.com/in/daini-wang-5127b2182" rel="noopener ugc nofollow" target="_blank"><em class="iq">我的 LinkedIn </em> </a></p></blockquote></div></div>    
</body>
</html>