<html>
<head>
<title>MySQL Parent-Child replication principle</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">MySQL 父子复制原则</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/mysql-parent-child-replication-principle-4001c96e6891?source=collection_archive---------16-----------------------#2022-07-04">https://blog.devgenius.io/mysql-parent-child-replication-principle-4001c96e6891?source=collection_archive---------16-----------------------#2022-07-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="2715" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">MySQL 高可用性</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/ca9dea2967b51b20ab1379d682b2a0c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dnAC1dDFpboFb3rB"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">本·科尔德在<a class="ae lb" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="125b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="lc">为什么需要亲子复制？</em> </strong></p><ul class=""><li id="da89" class="ld le iq jp b jq jr ju jv jy lf kc lg kg lh kk li lj lk ll bi translated">读写分离，增强 MySQL 数据库的可用性。</li><li id="f0d1" class="ld le iq jp b jq lm ju ln jy lo kc lp kg lq kk li lj lk ll bi translated">对数据进行热备份。</li><li id="bb6c" class="ld le iq jp b jq lm ju ln jy lo kc lp kg lq kk li lj lk ll bi translated">结构的扩展。业务量越来越大，I/O 访问频率太高，单机无法满足。此时进行多数据库存储，降低磁盘 I/O 访问频率，提高单机 I/O 性能。</li></ul><p id="7082" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="lc">什么是 MySQL 亲子复制？</em>T11】</strong></p><p id="26d8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">MySQL 父子复制意味着数据可以从 MySQL 数据库服务器父节点复制到一个或多个子节点。</p><p id="2db2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">MySQL 默认采用异步复制方式，这样子节点就不必访问父服务器来更新自己的数据，数据更新可以在远程连接上进行，子节点可以复制父数据库中的所有数据库或者某个特定的数据库，或者某个特定的表。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi lr"><img src="../Images/177c9f4471caf1cda21cc195431876c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ijWgoyydCCBMuo0s3mfvTQ.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">图片来源:作者</figcaption></figure></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="d5a0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="lc"> MySQL 亲子复制原理。</em>T15】</strong></p><p id="09b3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在多源复制中，每个复制源打开一个复制通道，这是一个长链接。</p><p id="9172" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每个复制源都有自己的 IO 线程、一个或多个点 SQL 线程和 realy 日志。</p><p id="3752" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">复制源收到事务时，会将其添加到中继日志中，然后通过 SQL 线程执行。相关的官方文件如下:</p><blockquote class="lz ma mb"><p id="f7ca" class="jn jo lc jp b jq jr js jt ju jv jw jx mc jz ka kb md kd ke kf me kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="iq">在 MySQL 多源复制中，一个副本打开多个复制通道，每个复制源服务器一个。复制通道代表事务从源流向副本的路径。</em>T19】</strong></p><p id="8a37" class="jn jo lc jp b jq jr js jt ju jv jw jx mc jz ka kb md kd ke kf me kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="iq">每个复制通道都有自己的接收方(I/O)线程，一个或多个应用方(SQL)线程，以及中继日志。</em> </strong></p><p id="d130" class="jn jo lc jp b jq jr js jt ju jv jw jx mc jz ka kb md kd ke kf me kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="iq">当来自源的事务被通道的接收器线程接收时，它们被添加到通道的中继日志文件，并被传递到通道的应用器线程。</em> </strong></p><p id="8d3f" class="jn jo lc jp b jq jr js jt ju jv jw jx mc jz ka kb md kd ke kf me kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="iq">这使得每个通道能够独立工作。</em> </strong></p></blockquote><p id="aa5c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">父子复制应该分为<strong class="jp ir">第一次连接</strong>建立和<strong class="jp ir">增量数据</strong>同步过程。</p><p id="7158" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">第一次连接。</strong></p><p id="989e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">备用数据库 B 和主数据库 a 之间保持长连接</p><p id="7fb1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">主库 A 内部有一个 io_thread 线程，专门服务于备用库 b 的这个长连接。</p><p id="7dc1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">事务日志同步的完整过程如下:</p><ol class=""><li id="5926" class="ld le iq jp b jq jr ju jv jy lf kc lg kg lh kk mf lj lk ll bi translated">在备用数据库 B 上使用<code class="fe mg mh mi mj b">change master</code>命令来设置主数据库 A 的 IP、端口、用户名、密码，以及从哪里开始请求<code class="fe mg mh mi mj b">binlog</code>，其中包含文件名和日志偏移量。</li></ol><pre class="km kn ko kp gt mk mj ml mm aw mn bi"><span id="e209" class="mo mp iq mj b gy mq mr l ms mt">CHANGE MASTER TO MASTER_HOST='192.168.56.104',MASTER_USER='root',MASTER_PASSWORD='qwer_123',MASTER_LOG_FILE='mysql-bin.000001',MASTER_LOG_POS=154;</span></pre><p id="9ba3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2.在备用数据库 b 上执行<code class="fe mg mh mi mj b">start slave</code>命令，此时备用数据库将启动两个线程，图中的<code class="fe mg mh mi mj b">io_thread</code>和<code class="fe mg mh mi mj b">sql_thread</code>。</p><p id="4ac1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">其中，<code class="fe mg mh mi mj b">io_thread</code>负责与主库建立连接。</p><p id="7580" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">3.主数据库 A 验证用户名和密码后，开始根据备用数据库 B 传递的位置在本地读取<code class="fe mg mh mi mj b">binlog</code>，并发送给备用数据库 B。</p><p id="038c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">4.备用数据库 B 得到<code class="fe mg mh mi mj b">binlog</code>后，将其写入中继日志(relay log)。</p><p id="249a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">5.备用数据库的<code class="fe mg mh mi mj b">sql_thread</code>读取中继日志，解析日志中的命令，并重放它们以供执行。</p><p id="f14c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">增量同步。</strong></p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mu"><img src="../Images/6ca4050242f0ea3a88637c96938e9c9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y2PX8la78OJ7M6qt4WVEbg.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">图片来源:作者</figcaption></figure><ol class=""><li id="40f1" class="ld le iq jp b jq jr ju jv jy lf kc lg kg lh kk mf lj lk ll bi translated">客户端发起更新请求，MySQL 服务器接收请求。</li><li id="3e4f" class="ld le iq jp b jq lm ju ln jy lo kc lp kg lq kk mf lj lk ll bi translated">生成与修改后的数据行相对应的撤消日志。</li><li id="2afe" class="ld le iq jp b jq lm ju ln jy lo kc lp kg lq kk mf lj lk ll bi translated">更新成功写入存储器。</li><li id="d115" class="ld le iq jp b jq lm ju ln jy lo kc lp kg lq kk mf lj lk ll bi translated">InnoDB 生成一个重做日志，目前正处于准备阶段。</li><li id="b1e9" class="ld le iq jp b jq lm ju ln jy lo kc lp kg lq kk mf lj lk ll bi translated">服务器层生成<code class="fe mg mh mi mj b">binlog</code>，提交事务时持久化<code class="fe mg mh mi mj b">binlog</code>。此时，<code class="fe mg mh mi mj b">binlog</code>可以开始同步到子库。</li><li id="b752" class="ld le iq jp b jq lm ju ln jy lo kc lp kg lq kk mf lj lk ll bi translated">重做日志进行磁盘持久化，并将更新执行的新结果返回给客户机(默认异步复制)。</li><li id="7554" class="ld le iq jp b jq lm ju ln jy lo kc lp kg lq kk mf lj lk ll bi translated">主库发送生成的<code class="fe mg mh mi mj b">binlog</code>数据。</li><li id="0a31" class="ld le iq jp b jq lm ju ln jy lo kc lp kg lq kk mf lj lk ll bi translated">库的 io_thread 处理 parent 传来的数据，保存为中继日志。子库服务器将检测父二进制日志在特定时间间隔内是否已经改变。如果有变化，它将启动一个 I/OThread 请求父二进制事件。</li><li id="cb29" class="ld le iq jp b jq lm ju ln jy lo kc lp kg lq kk mf lj lk ll bi translated">SQL 线程读取中继日志，解析日志，在子库中回放执行，数据同步完成。最后，I/OThread 和 SQLThread 将进入睡眠状态，等待下一次唤醒。</li></ol><p id="42ab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"><em class="lc">MySQL 怎么知道</em> </strong> <code class="fe mg mh mi mj b"><strong class="jp ir"><em class="lc">binlog</em></strong></code> <strong class="jp ir"> <em class="lc">是完整的？</em>T15】</strong></p><p id="3164" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">孩子在解析时如何知道一个事务已经完成？因为一个事务的<code class="fe mg mh mi mj b">binlog</code>有一个完整的格式；<code class="fe mg mh mi mj b">statement</code>格式中的<code class="fe mg mh mi mj b">binlog</code>最后会有一个<code class="fe mg mh mi mj b">COMMIT</code>标签；<code class="fe mg mh mi mj b">row</code>格式的<code class="fe mg mh mi mj b">binlog</code>末尾会有一个<code class="fe mg mh mi mj b">XID event</code>。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="8bab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="lc">感谢您阅读本文。</em></p><p id="03f7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="lc">敬请期待更多。</em></p></div></div>    
</body>
</html>