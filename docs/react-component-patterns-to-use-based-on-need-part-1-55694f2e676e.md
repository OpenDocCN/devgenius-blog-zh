# 根据需要使用组件模式(第 1 部分)

> 原文：<https://blog.devgenius.io/react-component-patterns-to-use-based-on-need-part-1-55694f2e676e?source=collection_archive---------1----------------------->

设计模式是“软件设计中常见问题的通用可重复解决方案”。随着 React 的发展，模式来了又去。引入 React 挂钩后，大多数基于类的模式已经过时了。编写可维护和可伸缩的 React 代码的新方法有哪些？

![](img/30f0d98fbd623c8aea96983c92abbc91.png)

在重温 modern React 时，我觉得最好是 ***首先关注我们的需求，然后应用一个模式*** ，而不是传统的学习一个模式，然后了解它有意义的用例的方法。我还承担了 ***的额外职责，将新模式与旧模式*** 进行比较，如果它们存在的话，这样我们就可以理解为什么它们不再被广泛使用了。

当然，我们不需要在模式上绞尽脑汁，简单地把我们的 UI 和逻辑分成更小的组件，这些组件只有一个职责。这适用于简单的项目，但是对于涉及到层次结构、分组、增强、交互、定制等组件的大型项目来说，说起来容易做起来难。这就是模式最终变得重要的原因！

这一系列的短文是我根据需要接近新的反应模式的方法。这是一本对初学者友好的指南，对经验丰富的 React 开发人员也有好处。

我们最常见的需求是什么？我在下面列出了六个问题:

1.  我们的组件中有逻辑吗？
2.  **许多组件是否应该遵循层次结构？**
3.  **我们是在给多个组件发送同一套道具吗？**
4.  **我们是否有需要重置的状态？**
5.  用户应该对组件的行为有更多的控制权吗？
6.  还有其他杂项需求吗？

在第一部分中，我们将讨论组件中的处理逻辑。

# 我们的组件中有逻辑吗？

在 React Hooks 出现之前，处理组件内部的逻辑是一项稍微复杂的任务。通常，逻辑涉及存储数据，因此，我们的组件必须是有状态的。早些时候，这意味着开发人员将使用必须基于类的智能组件！只有处理纯表示的哑组件是基于功能的。

使用钩子，如果我们的用例只是处理有状态逻辑，我们就不需要构建类组件。我主要指的是`**useState**`挂钩及其好处。

*   使用钩子，我们的逻辑是**隔离的**，而使用`setState`内部类组件则不是这样
*   钩子可以在组件之间重用，因为它们本质上只是函数
*   因为它们是可重用的，所以它们可以**共享有状态逻辑** ( *但是不能共享状态本身！*)使用它们的组件之间
*   我们还可以创建**定制钩子来增强有状态逻辑**以满足我们的需求！
*   React 钩子也有望**减少你的包大小**，因此，这也是一个性能上的胜利！

在进行任何重构之前，让我们先来看看一个有点臃肿的组件:

上面的组件显示“Hello”和一个“Enter”按钮。它记录了一个事件以及一些关于单击按钮的平台的元数据。

这个组件有几个潜在的问题。首先，它不仅显示一条消息和一个按钮，还包含记录事件的逻辑。日志是如此常见的实用工具，以至于将它的逻辑放在单个组件之外并使其可重用是有意义的。

第二，组件违反了**单一责任原则(SRP)** ，因为它有不止一个更改的原因，即日志和消息更改也将要求我们更新组件。理想情况下，一个功能或一个组件应该只有一个责任。

我们可以通过将逻辑层从表示中抽象出来，使用钩子来分离我们的关注点:

使用定制的`useLogger`钩子，我们取出注销`Greeting`组件的逻辑。它公开了一个`logger`方法，并在内部管理在记录事件细节时使用的元属性。我们已经看到钩子使得我们的逻辑可以重用，因为它们是函数。

尽管组件生命周期方法和钩子不应该在功能上等价，但出于大多数实际目的，我们可以用`useEffect`钩子来代替它们。

现在让我们将 React 钩子与其他一些模式进行比较，并得出我们是否还需要使用它们的结论！

## **比较 React 挂钩和 H.O.Cs**

React 中以前流行的模式被称为**高阶组件(H.O.C)** 。它用于增强另一个组件的功能。

**高阶分量是接受一个分量并返回一个新分量的函数。**

按照惯例，hoc 通常以`with`关键字为前缀。

这种方法对于分离关注点是很好的，但是它也有一些缺陷。

**总部的弊端**:

*   我们被迫继续使用**类组件**
*   渲染树将有**更深的嵌套**
*   我们需要维护一份增强组件的合同，以便使用由 H.O.C .注入的道具

出于这些原因，我们可以**将所有 H . O.Cs .重构为钩子**:

1.  当你看到一个 H.O.C .时，考虑创建一个**定制钩子**来返回 H.O.C .注入到目标组件的道具。例:`logger`方法
2.  使用`useEffect`方法处理总部生命周期方法中的逻辑
3.  编辑目标组件以使用新的钩子，而不是期望从 H.O.C .获得某些属性

## **将 React 挂钩与容器呈递器模式进行比较**

容器-呈现者模式的基本思想是将一个组件分成两部分:

*   一个用于演示(*事情看起来怎么样)*
*   一个用于逻辑(*事物如何运作)。早先，这必须是有状态的，因此，你需要在钩子之前使用一个类组件。*

容器通常用于*获取数据*，而演示者则负责显示数据。

容器呈现器是一个很好的模式，因为它分离了关注点。然而，钩子也可以做同样的事情！我们可以有一个钩子像容器一样提取数据——但是我们不需要维护一个新的类组件！因此，由于在 H . O.Cs .上使用钩子的类似原因，我们也可以在容器上使用钩子！

容器呈现器模式的一个示例如下:

钩子可以做同样的事情:

`useMessages`定制钩子处理数据获取的逻辑。接下来，您必须将这个定制挂钩插入到您的 presenter 组件中。您可以从 Dan Abramov 的这篇文章中了解更多关于容器的知识。

## 比较 React 挂钩与渲染道具

渲染道具并没有完全过时。在钩子可以替代的所有模式中，这种模式可能是最不合理的，因为它仍然非常有用。

在没有先了解*复合组件*的情况下，渲染道具解释起来有点困难。我将在本系列的后续部分中详细解释这种模式，但在这里将对其进行总结。

复合组件帮助我们将单个组件分解成多个组件，以维护单一责任原则( **SRP** )，这本质上帮助我们编写更易维护的代码&提高灵活性。

使用复合模式的一个很好的例子是当您可以将一个组件分解为父组件和子组件时。例如:`Menu`(父母)、`MenuButton` & `MenuItem`(子女)

```
// Concept:
<Parent {...parentProps}>
    <Child {...childProps} />
    <Child {...childProps} />
</Parent>// Application:
<Menu hideButtons>
  <MenuButton text="Exit" action={() => {...}} />
  <MenuButton text="Settings" action={() => {...}} />
  <MenuItem text="News" />
  <MenuItem text="Serials" />
  <MenuItem text="Sports" />
</Menu>
```

这种模式有一个**缺点**！父节点和子节点通过直接访问或上下文 API 紧密耦合。父组件需要创建一个上下文，子组件需要知道它并在内部使用它。虽然这没什么，但在某些情况下，这被视为*不纯*。这样做的纯粹方式是简单地期望子组件中的某些道具。

保持事物的纯粹性: **render props 模式允许我们传递一个函数**而不是组件给父对象。该函数将接收参数，并可以使用这些参数以纯粹的方式呈现其他组件。

让我们回到最初的问题:*钩子是否应该取代渲染道具？*

React 文档是这样建议的:*“通常，渲染道具和高阶组件只渲染一个子元素。我们认为钩子是服务于这个用例的一种更简单的方式。这两种模式都有自己的位置(例如，虚拟 scroller 组件可能有 renderItem prop，或者可视化容器组件可能有自己的 DOM 结构)。但在大多数情况下，钩子就足够了，可以帮助减少在树上筑巢。”*

因此，底线是如果你只渲染一个孩子，钩子可以代替渲染道具，也就是说它们可以共存。钩子为状态管理提供了一个简单的解决方案，并减少了渲染树中的嵌套。如果你想以一种纯粹的方式渲染更多的孩子，并且在组件之间有松散的耦合，那么渲染道具仍然是一条路要走！

# 摘要

*   通过首先考虑我们的组件的需求，更容易考虑使用反应模式
*   通过询问我们将要构建的组件类型，我们可以清楚地识别这些需求
*   React 挂钩是一个很好的使用模式，因为它们是独立的，包含可重用的有状态逻辑，消除了渲染树中的嵌套，并减少了包的大小
*   我们总是可以将高阶组件(H.O.C)重构为一个定制的钩子。`useEffect`钩子负责替换类生命周期方法
*   钩子可以做与容器呈现者模式相同的事情。我们可以将容器转换成一个定制的钩子，让演示者使用它，而不是被渲染树中的容器所包装
*   渲染道具和钩子可以共存，尽管钩子对于简单的用例来说已经足够了

# 进一步阅读

如果你喜欢这篇文章，我计划很快写下它的第二部分。这些将集中于组件之间的交互、状态管理、处理多个道具和控制反转。我将主要关注剩下的五个问题，作为我们选择模式的需要。