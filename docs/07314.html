<html>
<head>
<title>Floating Point Round Off Errors in Geometric Algorithms</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">几何算法中的浮点舍入误差</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/floating-point-round-off-errors-in-geometric-algorithms-a8779662904b?source=collection_archive---------10-----------------------#2022-03-14">https://blog.devgenius.io/floating-point-round-off-errors-in-geometric-algorithms-a8779662904b?source=collection_archive---------10-----------------------#2022-03-14</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/507ea25845005acf5a8c15614aadfd22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vDm3g-lInr2AVJll7azSaw.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">吃菠菜，打造你的凸包——水手大力水手。</figcaption></figure><h1 id="fb78" class="jz ka in bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">几何算法中的浮点精度</h1><p id="dff7" class="pw-post-body-paragraph kx ky in kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">大多数几何算法是为精确的实数运算而设计的；用浮点运算替换它们可能会导致这些实现失败。不幸的是，没有关于几何算法中什么会出错以及为什么出错的文档。这篇文章的其余部分讨论了用浮点运算执行几何算法时会出现什么问题。</p><p id="26d1" class="pw-post-body-paragraph kx ky in kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ig bi translated">为了使解释简单，考虑给定点集<code class="fe ma mb mc md b">S</code>的凸包算法，该点集是可以包含<code class="fe ma mb mc md b">S</code>所有点的最小多边形；<code class="fe ma mb mc md b">S</code>的极值点是凸包多边形的顶点；凸包内部的所有点都被简单地丢弃了。</p><p id="7c5b" class="pw-post-body-paragraph kx ky in kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ig bi translated">通常，由浮点实现计算的凸包可能会遗漏一些极值点，计算非凸多边形，或者算法可能会永远运行。</p><h1 id="b5f9" class="jz ka in bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">增量式平面凸包算法</h1><p id="a784" class="pw-post-body-paragraph kx ky in kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">凸包增量算法保持目前所见点的当前凸包(<code class="fe ma mb mc md b">CH</code>)。最初，在<code class="fe ma mb mc md b">S</code>中选择三个不共线的点形成一个凸包。然后，它会逐个考虑其余的点。当考虑一个点<code class="fe ma mb mc md b">r</code>时，首先确定<code class="fe ma mb mc md b">r</code>是否在当前凸包多边形之外。如果没有，<code class="fe ma mb mc md b">r</code>被丢弃。否则，通过形成从<code class="fe ma mb mc md b">r</code>到<code class="fe ma mb mc md b">CH</code>的切线来更新凸包。该算法以逆时针顺序将当前外壳保持为其极值点的循环列表<code class="fe ma mb mc md b">L = (v0, v1,. . .,vk−1)</code>，其中线段<code class="fe ma mb mc md b">(vi, vi+1)</code>是当前外壳的边缘。</p><h1 id="2e43" class="jz ka in bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">单步失败</h1><p id="e47f" class="pw-post-body-paragraph kx ky in kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">违反算法正确性的一个实例。考虑一个点的序列:<code class="fe ma mb mc md b">p1, p2, p3, . . .</code>，使得前三个点形成一个逆时针的三角形，并且一些后面的点的插入导致一个正确性属性的违反(因为浮点)。导致违规的示例总是涉及几乎或真正共线的点；明确地说，足够不共线的点不会引起任何问题。尽管这些示例看起来不现实，但它主要取决于容许舍入误差的要求，因为点集可能包含近似共线的点或真正共线的点，这些点通过转换为浮点表示法变得近似共线。</p><h1 id="5288" class="jz ka in bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">浮动方向的几何图形</h1><p id="63ac" class="pw-post-body-paragraph kx ky in kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">平面上的三个点<code class="fe ma mb mc md b">p = (px, py)</code>、<code class="fe ma mb mc md b">q = (qx, qy)</code>、<code class="fe ma mb mc md b">r = (rx, ry)</code>位于同一条直线上或形成左转或右转。</p><p id="47a9" class="pw-post-body-paragraph kx ky in kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ig bi translated">三联体<code class="fe ma mb mc md b">(p, q, r)</code>的方向由下式定义:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="e120" class="mm ka in md b gy mn mo l mp mq">orientation(p,q,r) = sign((qx − px)(ry − py)−(qy − py)(rx − px)).</span></pre><p id="ff14" class="pw-post-body-paragraph kx ky in kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ig bi translated">然而，对于浮点运算，由于可能的舍入误差，<code class="fe ma mb mc md b">float_orient</code>的结果有三种可能与正确的方向不同:</p><ul class=""><li id="bd36" class="mr ms in kz b la lv le lw li mt lm mu lq mv lu mw mx my mz bi translated">舍入为零:将<code class="fe ma mb mc md b">+</code>或<code class="fe ma mb mc md b">−</code>误分类为<code class="fe ma mb mc md b">0</code></li><li id="ec3e" class="mr ms in kz b la na le nb li nc lm nd lq ne lu mw mx my mz bi translated">扰动零点:将<code class="fe ma mb mc md b">0</code>误分类为<code class="fe ma mb mc md b">+</code>或<code class="fe ma mb mc md b">−</code></li><li id="5c59" class="mr ms in kz b la na le nb li nc lm nd lq ne lu mw mx my mz bi translated">符号倒置:将<code class="fe ma mb mc md b">+</code>误分类为<code class="fe ma mb mc md b">−</code>，反之亦然。</li></ul><p id="27aa" class="pw-post-body-paragraph kx ky in kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ig bi translated"><code class="fe ma mb mc md b">float_orient</code>，换句话说，三相点分为左转、右转或共线。</p><h1 id="aec3" class="jz ka in bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">失败 1:当前外壳之外的点看不到当前凸包的边缘</h1><p id="48da" class="pw-post-body-paragraph kx ky in kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">考虑一组点:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="c973" class="mm ka in md b gy mn mo l mp mq">p1 = (7.3000000000000194, 7.3000000000000167) <br/>p2 = (24.000000000000068, 24.000000000000071) <br/>p3 = (24.00000000000005, 24.000000000000053) <br/>p4 = (0.50000000000001621, 0.5000000000)<br/>p5 = (8, 4) <br/>p6 = (4, 9) <br/>p7 = (15, 27) <br/>p8 = (26, 25) <br/>p9 = (19, 11)</span></pre><p id="3690" class="pw-post-body-paragraph kx ky in kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ig bi translated">方向:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="e6c6" class="mm ka in md b gy mn mo l mp mq">float_orient(p1, p2, p3) &gt; 0 <br/>float_orient(p1, p2, p4) &gt; 0 <br/>float_orient(p2, p3, p4) &gt; 0 <br/>float_orient(p3, p1, p4) &gt; 0 (??)</span></pre><figure class="me mf mg mh gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nf"><img src="../Images/e9dbb43e4b55f54f9a1539d338339cc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Qb4oazaVjljZp6Sm.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">图 1:计算机凸包</figcaption></figure><p id="3a72" class="pw-post-body-paragraph kx ky in kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ig bi translated">上图显示了计算出的凸包，其中一个明显极端的点被排除在凸包之外；<code class="fe ma mb mc md b">p1 ≈ (17, 17), p2 ≈ (24, 24) ≈ p3</code></p><p id="3522" class="pw-post-body-paragraph kx ky in kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ig bi translated">前四点几乎位于直线上:y = x，<code class="fe ma mb mc md b">float_orient</code>显示上述结果。如<code class="fe ma mb mc md b">(??)</code>所示，上次评估有误。几何上，这些评估意味着<code class="fe ma mb mc md b">p4</code>看不到三角形<code class="fe ma mb mc md b">(p1, p2, p3)</code>的边。然后，点<code class="fe ma mb mc md b">p5, . . . , p9</code>被正确识别为极值点，并被添加到船体。然而，该算法从未从考虑<code class="fe ma mb mc md b">p4</code>时产生的错误中恢复过来，并且计算结果与正确的船体相差很大。</p><h1 id="fd16" class="jz ka in bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">失败 2:当前外壳内的一点看到当前外壳的边缘</h1><p id="ebd6" class="pw-post-body-paragraph kx ky in kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">取一个逆时针的三角形(最初)，选择三角形内的第四个点，但非常靠近其中一条边。存在符号反转的可能性。例如，考虑一组点:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="1cb7" class="mm ka in md b gy mn mo l mp mq">p1 = (27.643564356435643, −21.881188118811881 ) <br/>p2 = (83.366336633663366, 15.544554455445542 ) <br/>p3 = ( 4.0, 4.0 ) <br/>p4 = (73.415841584158414, 8.8613861386138595)</span></pre><p id="7007" class="pw-post-body-paragraph kx ky in kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ig bi translated">方向:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="9eed" class="mm ka in md b gy mn mo l mp mq">float orient(p1, p2, p3) &gt; 0 <br/>float orient(p1, p2, p4) &lt; 0 (??) <br/>float orient(p2, p3, p4) &gt; 0 <br/>float orient(p3, p1, p4) &gt; 0</span></pre><p id="1959" class="pw-post-body-paragraph kx ky in kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ig bi translated">凸包被正确初始化为<code class="fe ma mb mc md b">(p1, p2, p3)</code>。点 p4 位于当前凸包内，但算法错误地认为<code class="fe ma mb mc md b">p4</code>可以看到边缘<code class="fe ma mb mc md b">(p1, p2)</code>，因此将凸包更改为<code class="fe ma mb mc md b">(p1, p4, p2, p3)</code>，一个略微非凸的多边形。</p><h1 id="4be9" class="jz ka in bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">失败 3:当前外壳之外的点看到了凸包的所有边缘</h1><p id="4426" class="pw-post-body-paragraph kx ky in kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">考虑一组点:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="2a17" class="mm ka in md b gy mn mo l mp mq">p1 = ( 200.0, 49.200000000000003) <br/>p2 = ( 100.0, 49.600000000000001) <br/>p3 = (−233.33333333333334, 50.93333333333333 ) <br/>p4 = ( 166.66666666666669, 49.333333333333336)</span></pre><p id="f4d5" class="pw-post-body-paragraph kx ky in kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ig bi translated">方向:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="dd45" class="mm ka in md b gy mn mo l mp mq">float orient(p1, p2, p3) &gt; 0 <br/>float orient(p1, p2, p4) &lt; 0 <br/>float orient(p2, p3, p4) &lt; 0 <br/>float orient(p3, p1, p4) &lt; 0 (??)</span></pre><figure class="me mf mg mh gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ng"><img src="../Images/fdd120c96931a10ea341e1785103d237.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*cvuBjnXRzN6KprfR.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">图 2:故障 3 的示意图:点 p4 看到三角形的所有边(p1，p2，p3)</figcaption></figure><p id="4519" class="pw-post-body-paragraph kx ky in kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ig bi translated">前三个点形成一个逆时针方向的三角形，根据<code class="fe ma mb mc md b">float_orient</code>，算法认为<code class="fe ma mb mc md b">p4</code>可以看到三角形的所有边。</p><h1 id="99f0" class="jz ka in bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">失败 4:当前外壳之外的点看到一组不连续的边</h1><p id="6ffb" class="pw-post-body-paragraph kx ky in kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">考虑一组点:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="4f8b" class="mm ka in md b gy mn mo l mp mq">p1 = (0.50000000000001243, 0.50000000000000189) <br/>p2 = (0.50000000000001243, 0.50000000000000333) <br/>p3 = (24.00000000000005, 24.000000000000053) <br/>p4 = (24.000000000000068, 24.000000000000071) <br/>p5 = (17.300000000000001, 17.300000000000001)</span></pre><p id="a08d" class="pw-post-body-paragraph kx ky in kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ig bi translated">方向:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="cfb4" class="mm ka in md b gy mn mo l mp mq">float_orient(p1, p4, p5) &lt; 0 (??) <br/>float_orient(p4, p3, p5) &gt; 0 <br/>float_orient(p3, p2, p5) &lt; 0 <br/>float_orient(p2, p1, p5) &gt; 0</span></pre><p id="b4f4" class="pw-post-body-paragraph kx ky in kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ig bi translated">插入前三个点，然后插入第四个点<code class="fe ma mb mc md b">p4</code>，得到凸四边形<code class="fe ma mb mc md b">(p1, p4, p3, p2)</code>，这是正确的。最后一点，<code class="fe ma mb mc md b">p5</code>，只看到边缘<code class="fe ma mb mc md b">(p3, p2)</code>，其他三个都看不到。然而，<code class="fe ma mb mc md b">float_orient</code>使得<code class="fe ma mb mc md b">p5</code>也能看到边缘<code class="fe ma mb mc md b">(p1, p4)</code>。可见边和不可见边的子序列不连续。由于错误分类的边<code class="fe ma mb mc md b">(p1, p4)</code>首先出现，该算法在该边插入<code class="fe ma mb mc md b">p5</code>，不移除其他顶点，并返回一个具有自相交的多边形。</p><h1 id="bc15" class="jz ka in bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">外卖</h1><p id="8519" class="pw-post-body-paragraph kx ky in kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">如上所述，算法可能会因为舍入误差而失败，以用浮点运算简单实现的凸包算法为例。</p><p id="1ce8" class="pw-post-body-paragraph kx ky in kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ig bi translated">和往常一样，C++代码的参考，以及由于舍入误差而失败的凸算法的变体和如何防止它可以在这里找到:<a class="ae nh" href="https://github.com/addu390/rounding-errors" rel="noopener ugc nofollow" target="_blank">https://github.com/addu390/rounding-errors</a></p><p id="2aa8" class="pw-post-body-paragraph kx ky in kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ig bi translated">作为扩展，考虑使用精确浮点(<code class="fe ma mb mc md b">MP_Float</code>)来尝试 CGAL 库。</p><p id="b422" class="pw-post-body-paragraph kx ky in kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ig bi translated">最后，帖子总结了[1]和[2]。这是我作为助教在开发 CSCI 6105 实验室指令时偶然发现的。</p></div><div class="ab cl ni nj hr nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="ig ih ii ij ik"><h1 id="238e" class="jz ka in bd kb kc np ke kf kg nq ki kj kk nr km kn ko ns kq kr ks nt ku kv kw bi translated">参考资料:</h1><blockquote class="nu nv nw"><p id="66b5" class="kx ky nx kz b la lv lc ld le lw lg lh ny lx lk ll nz ly lo lp oa lz ls lt lu ig bi translated">[1]《凸包计算中的鲁棒性问题》，ww wisg . cs . uni-magdeburg . de .<a class="ae nh" href="http://wwwisg.cs.uni-magdeburg.de/ag/ClassroomExample/#Kettner2008" rel="noopener ugc nofollow" target="_blank">http://ww wisg . cs . uni-magdeburg . de/ag/class room example/# kett ner 2008</a>(2022 年 3 月 11 日访问)。</p><p id="4a26" class="kx ky nx kz b la lv lc ld le lw lg lh ny lx lk ll nz ly lo lp oa lz ls lt lu ig bi translated">[2] L. Kettner，K. Mehlhorn，S. Pion，S. Schirra 和 C. Yap，“几何计算中鲁棒性问题的课堂示例”，《计算几何》，第 40 卷，第 1 期，第 61-78 页，2008 年 5 月，doi:10.1016/j . com geo . 2007 . 06 . 003</p><p id="f677" class="kx ky nx kz b la lv lc ld le lw lg lh ny lx lk ll nz ly lo lp oa lz ls lt lu ig bi translated">[3]《浮点指南—精确类型》，浮点 GUI . de .<a class="ae nh" href="https://floating-point-gui.de/formats/exact/" rel="noopener ugc nofollow" target="_blank">https://floating-point-gui.de/formats/exact/</a>(2022 年 3 月 11 日访问)。</p></blockquote></div></div>    
</body>
</html>