<html>
<head>
<title>Learn Functional Programming Design from Redux</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">向 Redux 学习函数式编程设计</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/learn-fp-design-from-redux-95cc21479086?source=collection_archive---------7-----------------------#2020-08-04">https://blog.devgenius.io/learn-fp-design-from-redux-95cc21479086?source=collection_archive---------7-----------------------#2020-08-04</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/c1a5154a977930d8eefbc21eda0d2888.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*NnazMpzj6gYMYzFX.png"/></div></div></figure><p id="e14a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在我着眼于 Redux 源代码之前，我天真地认为 OOP 作为一种编程范式比 FP(函数式编程)优越。但这是不对的。正如我们所知，FP 致力于形成一个易于理解和清晰的工作流，没有那些模糊的抽象对象和关系。它更接近人类的程序性思维方式。</p><p id="0d84" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">访问<a class="ae kt" href="https://pitayan.com/posts/redux-fp-design/?ref=medium" rel="noopener ugc nofollow" target="_blank">Pitayan.com</a>阅读原文。</p><div class="ku kv gp gr kw kx"><a href="https://pitayan.com/posts/redux-fp-design/?ref=medium" rel="noopener  ugc nofollow" target="_blank"><div class="ky ab fo"><div class="kz ab la cl cj lb"><h2 class="bd io gy z fp lc fr fs ld fu fw im bi translated">向 Redux - Pitayan 学习 FP 设计</h2><div class="le l"><h3 class="bd b gy z fp lc fr fs ld fu fw dk translated">在我着眼于 Redux 源代码之前，我天真地认为 OOP 比 FP(函数式编程)更好…</h3></div><div class="lf l"><p class="bd b dl z fp lc fr fs ld fu fw dk translated">pitayan.com</p></div></div><div class="lg l"><div class="lh l li lj lk lg ll jt kx"/></div></div></a></div><p id="53e8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在<code class="fe lm ln lo lp b">React</code>已经有钩子可以正确处理“状态”事件，而不需要<a class="ae kt" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank">重复</a>。对<a class="ae kt" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux </a>的需求可能会下降，但它的代码库仍然值得学习。尤其是对于那些想在函数式编程上有所启发的人。所以，我想从一个好的例子中学习从来都不是一个坏主意，即使它是“过时的”(一点也不)。</p><p id="f057" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当我开始阅读<a class="ae kt" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux </a>源代码时，我立刻感受到了我熟悉的编程语言的这种陌生用法的力量。这感觉就像用火把照亮画来探索一个古老的洞穴，发现了巨大的秘密。</p><p id="a114" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了更多地了解 Redux 从 FP 中获益，我研究了<a class="ae kt" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux </a>源代码并创建了它的迷你版本。</p><blockquote class="lq lr ls"><p id="807c" class="jv jw lt jx b jy jz ka kb kc kd ke kf lu kh ki kj lv kl km kn lw kp kq kr ks ig bi translated"><em class="in">永远不要害怕多此一举。</em></p></blockquote><h1 id="a85f" class="lx ly in bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated"><a class="ae kt" href="https://pitayan.com/#recap-how-redux-works" rel="noopener ugc nofollow" target="_blank">回顾 Redux 的工作原理</a></h1><p id="417d" class="pw-post-body-paragraph jv jw in jx b jy mv ka kb kc mw ke kf kg mx ki kj kk my km kn ko mz kq kr ks ig bi translated"><a class="ae kt" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux </a>有 4 个基本要点:</p><ol class=""><li id="1a7c" class="na nb in jx b jy jz kc kd kg nc kk nd ko ne ks nf ng nh ni bi translated">为数据创建一个存储，并让视图订阅它</li><li id="e88f" class="na nb in jx b jy nj kc nk kg nl kk nm ko nn ks nf ng nh ni bi translated">视图调度一个提交更改的操作</li><li id="eae0" class="na nb in jx b jy nj kc nk kg nl kk nm ko nn ks nf ng nh ni bi translated">缩减器根据动作类型改变状态</li><li id="e57a" class="na nb in jx b jy nj kc nk kg nl kk nm ko nn ks nf ng nh ni bi translated">最后返回新的状态并触发视图改变</li></ol><p id="4817" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是解释<a class="ae kt" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux </a>如何工作的经典图表:</p><figure class="np nq nr ns gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi no"><img src="../Images/2a3c9dad4493879cf6d98dddcf911912.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*TKnzdk1rzqytqkIU.jpg"/></div></div></figure><p id="baa9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">从上图中，很容易找到关键词:<code class="fe lm ln lo lp b">actionstorereducerviewsubscribe</code>和<code class="fe lm ln lo lp b">dispatch</code>。其次是处理这些关键词之间的关系。</p><h1 id="6dfc" class="lx ly in bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated"><a class="ae kt" href="https://pitayan.com/#redux-approach-comparison-fp-vs-oop" rel="noopener ugc nofollow" target="_blank"> Redux 方法比较:FP vs OOP </a></h1><p id="40b7" class="pw-post-body-paragraph jv jw in jx b jy mv ka kb kc mw ke kf kg mx ki kj kk my km kn ko mz kq kr ks ig bi translated"><a class="ae kt" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux </a>的用法举例</p><pre class="np nq nr ns gt nt lp nu nv aw nw bi"><span id="e0c0" class="nx ly in lp b gy ny nz l oa ob">const store = createStore(<br/>  combineReducers({<br/>    one: oneReducer,<br/>    two: twoReducer<br/>  }),<br/>  applyMiddleware(ReduxThunk, ReduxLogger)<br/>);</span></pre><p id="41e2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">想象一下，如果我们在 OOP 中这样做，它可能看起来像这样:</p><p id="a6ac" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">(以下只是我的想象。不是老<a class="ae kt" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux </a>表现如何)</p><pre class="np nq nr ns gt nt lp nu nv aw nw bi"><span id="ec16" class="nx ly in lp b gy ny nz l oa ob">const store = new Store();<br/>store.setReducers({<br/>  one: oneReducer,<br/>  two: twoReducer<br/>});<br/>store.setMiddlewares({<br/>  ReduxThunk,<br/>  ReduxLogger<br/>});</span></pre><p id="abd3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">那么，有什么区别呢？在我看来，这两种方法都很好。</p><p id="fabf" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">FP 在没有副作用的情况下很好地将功能组合在一起。返回值是一致的，这使得程序在执行期间或之后的返回是可预见的。</p><p id="8cdf" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">OOP 构建了一个坚实的结构，定义了数据模型应该包含的所有属性。这使得修改或配置数据模型变得很容易。</p><p id="42fb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在<a class="ae kt" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux </a>中，<code class="fe lm ln lo lp b">reduers</code>和<code class="fe lm ln lo lp b">middlewares</code>通常只定义一次。这意味着，我们不需要更新这些属性的能力，也不希望它们在运行时被改变。至于 FP 方法，它使用了<code class="fe lm ln lo lp b">closure</code>技术，这种技术消除了暴露内部属性的可能性。通过一些奇妙的 FP 技术(curry、compose、pipe)，它甚至使程序比 OOP 更易于阅读。</p><p id="504a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我认为 FP 应该是最适合这种情况的。当然，我这里说的 FP 和 Haskell 这种真正的函数式编程相差甚远。但是至少在 Javascript 中使用 FP 技术的想法是可以遵循的。</p><figure class="np nq nr ns gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi oc"><img src="../Images/716440103ac3e8d56eae870980bc9967.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*39WJJbBwqt36uiZ5.jpg"/></div></div></figure><h1 id="6e92" class="lx ly in bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated"><a class="ae kt" href="https://pitayan.com/#wonderful-redux-fp-design" rel="noopener ugc nofollow" target="_blank">精彩的 Redux FP 设计</a></h1><p id="92fe" class="pw-post-body-paragraph jv jw in jx b jy mv ka kb kc mw ke kf kg mx ki kj kk my km kn ko mz kq kr ks ig bi translated">在 Redux 中，根本没有类(在更早的版本中，曾经是基于<code class="fe lm ln lo lp b">Class</code>)。它的所有核心 API 要么返回值，要么返回函数(函数工厂)。这正是 FP 所期望的函数行为:</p><blockquote class="lq lr ls"><p id="b9f5" class="jv jw lt jx b jy jz ka kb kc kd ke kf lu kh ki kj lv kl km kn lw kp kq kr ks ig bi translated"><em class="in">纯无副作用。</em></p></blockquote><ul class=""><li id="c11b" class="na nb in jx b jy jz kc kd kg nc kk nd ko ne ks od ng nh ni bi translated">createStore:返回新的<code class="fe lm ln lo lp b">Object</code> {获取状态，分派，订阅}</li><li id="07cf" class="na nb in jx b jy nj kc nk kg nl kk nm ko nn ks od ng nh ni bi translated">combineReducers:返回新的<code class="fe lm ln lo lp b">Function</code></li><li id="8b3b" class="na nb in jx b jy nj kc nk kg nl kk nm ko nn ks od ng nh ni bi translated">applyMiddleware:返回新的<code class="fe lm ln lo lp b">Function</code></li></ul><p id="5d04" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了以一种简单的方式解释 Redux 设计，我只实现了上面 API 的核心部分。由于最新版本的核心理念没有太大变化，所以我是基于非常原始版本的<a class="ae kt" href="https://github.com/reduxjs/redux/tree/v1.0.1/src" rel="noopener ugc nofollow" target="_blank"> Redux v1.0.1 </a>写的源代码。因为我相信第一个相关的版本是最全面的。</p><p id="78a9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们看一看。</p><h2 id="0c2d" class="nx ly in bd lz oe of dn md og oh dp mh kg oi oj ml kk ok ol mp ko om on mt oo bi translated"><a class="ae kt" href="https://pitayan.com/#createstore" rel="noopener ugc nofollow" target="_blank">创造商店</a></h2><p id="6f92" class="pw-post-body-paragraph jv jw in jx b jy mv ka kb kc mw ke kf kg mx ki kj kk my km kn ko mz kq kr ks ig bi translated">定义了那些可以在组件中使用的 API。更像是<code class="fe lm ln lo lp b">setter</code>和<code class="fe lm ln lo lp b">getter</code></p><ul class=""><li id="ef0d" class="na nb in jx b jy jz kc kd kg nc kk nd ko ne ks od ng nh ni bi translated">getState</li><li id="af51" class="na nb in jx b jy nj kc nk kg nl kk nm ko nn ks od ng nh ni bi translated">派遣</li><li id="b4df" class="na nb in jx b jy nj kc nk kg nl kk nm ko nn ks od ng nh ni bi translated">订阅</li></ul><pre class="np nq nr ns gt nt lp nu nv aw nw bi"><span id="001a" class="nx ly in lp b gy ny nz l oa ob">export default function createStore (reducer, enhancer) {<br/>  if (enhancer) {<br/>    return enhancer(createStore)(reducer);<br/>  }</span><span id="708e" class="nx ly in lp b gy op nz l oa ob">  let currentState;<br/>  // Redux now uses a shallow copy `nextListeners` via `ensureCanMutateNextListeners()`<br/>  // to prevent bugs in the middle of `dispatch`<br/>  let currentListeners = [];</span><span id="2e58" class="nx ly in lp b gy op nz l oa ob">  function getState () {<br/>    return currentState;<br/>  }</span><span id="b084" class="nx ly in lp b gy op nz l oa ob">  // Register callbacks to execute after changes<br/>  function subscribe (listener) {<br/>    currentListeners.push(listener);</span><span id="d000" class="nx ly in lp b gy op nz l oa ob">    return () =&gt; {<br/>      // empty listeners<br/>      const index = currentListeners.indexOf(listener);<br/>      currentListeners.splice(index, 1);<br/>    };<br/>  }</span><span id="84c8" class="nx ly in lp b gy op nz l oa ob">  function dispatch (action) {<br/>    currentState = reducer(currentState, action);<br/>    // state changes, notify to invoke callbacks<br/>    currentListeners.forEach(listener =&gt; listener());<br/>  }</span><span id="6bca" class="nx ly in lp b gy op nz l oa ob">  // Initialize Redux by calling a virtual reducer<br/>  dispatch({ type: "MY-MINI-REDUX" });</span><span id="be6b" class="nx ly in lp b gy op nz l oa ob">  return {<br/>    getState,<br/>    dispatch,<br/>    subscribe<br/>  };<br/>}</span></pre><h2 id="3d48" class="nx ly in bd lz oe of dn md og oh dp mh kg oi oj ml kk ok ol mp ko om on mt oo bi translated"><a class="ae kt" href="https://pitayan.com/#combinereducers" rel="noopener ugc nofollow" target="_blank">联合收割机减速器</a></h2><p id="43cd" class="pw-post-body-paragraph jv jw in jx b jy mv ka kb kc mw ke kf kg mx ki kj kk my km kn ko mz kq kr ks ig bi translated">返回一个可以返回新状态的新函数。不能再纯洁了。</p><pre class="np nq nr ns gt nt lp nu nv aw nw bi"><span id="fe67" class="nx ly in lp b gy ny nz l oa ob">// This is just a helper function to map through the Object<br/>function mapValues(obj, fn) {<br/>  return Object.keys(obj).reduce((result, key) =&gt; {<br/>    result[key] = fn(obj[key], key);<br/>    return result;<br/>  }, {});<br/>}</span><span id="7a29" class="nx ly in lp b gy op nz l oa ob">export default function combineReducers (reducers) {<br/>  return function combination (state = {}, action) {<br/>    // Official Redux uses `pick` on filtering reducers.<br/>    // Let's trust reducers are functions here<br/>    return mapValues(reducers, (reducer, key) =&gt; reducer(state[key], action))<br/>  };<br/>}</span></pre><h2 id="4f3b" class="nx ly in bd lz oe of dn md og oh dp mh kg oi oj ml kk ok ol mp ko om on mt oo bi translated"><a class="ae kt" href="https://pitayan.com/#applymiddleware" rel="noopener ugc nofollow" target="_blank">应用中间件</a></h2><p id="705c" class="pw-post-body-paragraph jv jw in jx b jy mv ka kb kc mw ke kf kg mx ki kj kk my km kn ko mz kq kr ks ig bi translated">我个人认为<code class="fe lm ln lo lp b">applyMiddleware</code> API 是 Redux 最神奇的部分。它提供了应用第三方插件的最佳解决方案。</p><p id="33a7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">源代码中的 FP <code class="fe lm ln lo lp b">compose</code>在我的理解中对应的是 Math 的<a class="ae kt" href="https://en.wikipedia.org/wiki/Associative_property" rel="noopener ugc nofollow" target="_blank">结合律</a>。</p><blockquote class="lq lr ls"><p id="3043" class="jv jw lt jx b jy jz ka kb kc kd ke kf lu kh ki kj lv kl km kn lw kp kq kr ks ig bi translated"><em class="in">(</em>x<em class="in">∫(</em>y<em class="in">∫</em>z<em class="in">)=</em>x<em class="in">∫</em>y<em class="in">∫</em>z</p></blockquote><p id="40b3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe lm ln lo lp b">applyMiddleware</code>的用法实际上是一种<code class="fe lm ln lo lp b">pipe</code>的形式，它允许我们注入返回 store 对象的增强函数。这与最典型的例子是注释/装饰器的<code class="fe lm ln lo lp b">Aspect Oriented Programming</code>非常相似。</p><pre class="np nq nr ns gt nt lp nu nv aw nw bi"><span id="860d" class="nx ly in lp b gy ny nz l oa ob">// Combine the functions<br/>// a(b(c())) =&gt; compose(a, b, c)<br/>function compose(...funcs) {<br/>  return funcs.reduceRight((composed, f) =&gt; f(composed));<br/>}</span><span id="1a17" class="nx ly in lp b gy op nz l oa ob">export default function applyMiddleware(...middlewares) {<br/>  return next =&gt; (reducer, initialState) =&gt; {<br/>    const store = next(reducer, initialState);<br/>    let dispatch = store.dispatch;<br/>    const middlewareAPI = {<br/>      getState: store.getState,<br/>      dispatch: action =&gt; dispatch(action)<br/>    };<br/>    const chain = middlewares.map(middleware =&gt; middleware(middlewareAPI));</span><span id="5815" class="nx ly in lp b gy op nz l oa ob">    // Enhance the `dispatchers` by applying middlewares to each of them<br/>    dispatch = compose(...chain, store.dispatch);</span><span id="2f46" class="nx ly in lp b gy op nz l oa ob">    return {<br/>      ...store,<br/>      dispatch<br/>    };<br/>  };<br/>}</span></pre><h1 id="4e75" class="lx ly in bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated"><a class="ae kt" href="https://pitayan.com/#redux-middlewares" rel="noopener ugc nofollow" target="_blank"> Redux 中间件</a></h1><p id="4a2c" class="pw-post-body-paragraph jv jw in jx b jy mv ka kb kc mw ke kf kg mx ki kj kk my km kn ko mz kq kr ks ig bi translated"><a class="ae kt" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux </a>有一些著名的中间件，比如<a class="ae kt" href="https://github.com/reduxjs/redux-thunk" rel="noopener ugc nofollow" target="_blank"> redux-thunk </a>和【Redux-logger(<a class="ae kt" href="https://github.com/LogRocket/redux-logger" rel="noopener ugc nofollow" target="_blank">https://github.com/LogRocket/redux-logger</a>)。这些是使用<code class="fe lm ln lo lp b">applyMiddleware</code> API 增强功能的好例子。此外，他们的代码库小得惊人。核心部分只有几行代码。</p><p id="9b78" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所有的中间件都是<code class="fe lm ln lo lp b">curry</code>函数。</p><blockquote class="lq lr ls"><p id="8aa0" class="jv jw lt jx b jy jz ka kb kc kd ke kf lu kh ki kj lv kl km kn lw kp kq kr ks ig bi translated"><em class="in">funcA =&gt;funcB =&gt;funcC</em></p><p id="4fe9" class="jv jw lt jx b jy jz ka kb kc kd ke kf lu kh ki kj lv kl km kn lw kp kq kr ks ig bi translated"><em class="in"> funcB = funcA() </em></p><p id="021f" class="jv jw lt jx b jy jz ka kb kc kd ke kf lu kh ki kj lv kl km kn lw kp kq kr ks ig bi translated"><em class="in"> funcC = funcB() </em></p></blockquote><p id="d7ca" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当我需要在代码块中使用其他上下文时，这非常有用。作为例子，很容易发现<code class="fe lm ln lo lp b">next</code>和<code class="fe lm ln lo lp b">action</code>被作为上下文传递，以帮助处理一些复杂的情况。</p><h2 id="70f5" class="nx ly in bd lz oe of dn md og oh dp mh kg oi oj ml kk ok ol mp ko om on mt oo bi translated"><a class="ae kt" href="https://pitayan.com/#redux-thunk" rel="noopener ugc nofollow" target="_blank"> Redux Thunk </a></h2><p id="05b4" class="pw-post-body-paragraph jv jw in jx b jy mv ka kb kc mw ke kf kg mx ki kj kk my km kn ko mz kq kr ks ig bi translated"><code class="fe lm ln lo lp b">redux-thunk</code>允许使用函数作为<code class="fe lm ln lo lp b">dispatch</code>参数，这样我就可以在“分派”之前做正确的事情。</p><pre class="np nq nr ns gt nt lp nu nv aw nw bi"><span id="2cb7" class="nx ly in lp b gy ny nz l oa ob">// without redux-thunk<br/>dispatch({ type: 'action', payload: 'value' })</span><span id="aa40" class="nx ly in lp b gy op nz l oa ob">// with redux-thunk<br/>// the dispatch is wrapped up by a new function<br/>dispatch(function (dispatch, getState) {<br/>  console.log('redux-thunk')<br/>  dispatch({ type: 'action', payload: 'value' })<br/>})</span></pre><p id="faef" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里是核心:</p><pre class="np nq nr ns gt nt lp nu nv aw nw bi"><span id="bd8c" class="nx ly in lp b gy ny nz l oa ob">// Allow passing function to dispatch<br/>export default function thunk({ dispatch, getState }) {<br/>  return next =&gt; action =&gt; {<br/>    if (typeof action === "function") {<br/>      return action(dispatch, getState);<br/>    }</span><span id="9c77" class="nx ly in lp b gy op nz l oa ob">    return next(action);<br/>  };<br/>}</span></pre><h2 id="e168" class="nx ly in bd lz oe of dn md og oh dp mh kg oi oj ml kk ok ol mp ko om on mt oo bi translated"><a class="ae kt" href="https://pitayan.com/#redux-logger" rel="noopener ugc nofollow" target="_blank"> Redux 记录器</a></h2><p id="7f29" class="pw-post-body-paragraph jv jw in jx b jy mv ka kb kc mw ke kf kg mx ki kj kk my km kn ko mz kq kr ks ig bi translated">很容易猜到这个中间件是做什么的。它只是输出状态变化。</p><pre class="np nq nr ns gt nt lp nu nv aw nw bi"><span id="f4aa" class="nx ly in lp b gy ny nz l oa ob">// Output the previous and current state in console<br/>export default function logger({ getState }) {<br/>  return next =&gt; action =&gt; {<br/>    console.log("======== Redux Logger ========");<br/>    console.log("Action Type: ", action.type);<br/>    const prevState = getState();<br/>    console.log("Prev: ", prevState);</span><span id="fff7" class="nx ly in lp b gy op nz l oa ob">    const returnValue = next(action);</span><span id="5a0e" class="nx ly in lp b gy op nz l oa ob">    const nextState = getState();<br/>    console.log("Next: ", nextState);<br/>    console.log("==============================");<br/>    return returnValue;<br/>  };<br/>}</span></pre><h1 id="cc5d" class="lx ly in bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated"><a class="ae kt" href="https://pitayan.com/#a-demo-app" rel="noopener ugc nofollow" target="_blank">一款演示应用</a></h1><p id="e701" class="pw-post-body-paragraph jv jw in jx b jy mv ka kb kc mw ke kf kg mx ki kj kk my km kn ko mz kq kr ks ig bi translated">我实现了 redux 的迷你版本和一个小的计数器应用程序来演示这些功能。该应用程序将做四个算术运算:加，减，乘，除。单击操作按钮后，数字会发生变化。同时，<code class="fe lm ln lo lp b">multiply</code>和<code class="fe lm ln lo lp b">divide</code>将有 300 毫秒的延迟，这是由一个定制的中间件(一个迷你 redux-thunk)实现的。</p><p id="7f99" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">“mini-redux”的存储库链接:</strong></p><p id="49c0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae kt" href="https://github.com/daiyanze/mini-redux" rel="noopener ugc nofollow" target="_blank">https://github.com/daiyanze/mini-redux</a></p><p id="931f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">演示 App 链接:</strong></p><p id="6c5c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae kt" href="https://daiyanze.com/mini-redux/build/index.html" rel="noopener ugc nofollow" target="_blank">https://daiyanze.com/mini-redux/build/index.html</a></p><figure class="np nq nr ns gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi oq"><img src="../Images/1f82049fc4ee3f45904b2aa440755f5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Vpg_bISi9Q86S6IJ.png"/></div></div></figure><p id="e93a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">该应用程序有一个子组件:<code class="fe lm ln lo lp b">MiniReduxComp</code>。在我的 mini-redux 中，我没有创建上下文提供者来触发更新。相反，我订阅组件中的存储更改，并使用<code class="fe lm ln lo lp b">forceUpdate</code>对更改做出反应。</p><p id="778a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我还应用了自定义中间件<code class="fe lm ln lo lp b">redux-thunk</code>和<code class="fe lm ln lo lp b">redux-logger</code>来丰富功能。</p><pre class="np nq nr ns gt nt lp nu nv aw nw bi"><span id="1347" class="nx ly in lp b gy ny nz l oa ob">import React, { Component } from 'react';<br/>import store from '../store'</span><span id="7138" class="nx ly in lp b gy op nz l oa ob">export default class MiniReduxComp extends Component {</span><span id="01ab" class="nx ly in lp b gy op nz l oa ob">  componentDidMount() {<br/>    this.unsubscribe = store.subscribe(() =&gt; this.forceUpdate());<br/>  }</span><span id="6fe9" class="nx ly in lp b gy op nz l oa ob">  componentWillUnmount() {<br/>    this.unsubscribe &amp;&amp; this.unsubscribe();<br/>  }</span><span id="9b10" class="nx ly in lp b gy op nz l oa ob">  plus = () =&gt; store.dispatch({ type: "PLUS" })</span><span id="c502" class="nx ly in lp b gy op nz l oa ob">  minus = () =&gt; store.dispatch({ type: 'MINUS' })</span><span id="9972" class="nx ly in lp b gy op nz l oa ob">  multiply = () =&gt; store.dispatch((dispatch, getState) =&gt; {<br/>    setTimeout(() =&gt; {<br/>      dispatch({ type: 'MULTIPLY' })<br/>    }, 300)<br/>  })</span><span id="8166" class="nx ly in lp b gy op nz l oa ob">  divide = () =&gt; store.dispatch((dispatch, getState) =&gt; {<br/>    setTimeout(() =&gt; {<br/>      dispatch({ type: 'DIVIDE' })<br/>    }, 300)<br/>  })</span><span id="4cc5" class="nx ly in lp b gy op nz l oa ob">  render() {<br/>    return (<br/>      &lt;div&gt;<br/>        &lt;h4&gt;Plus / Minus 1&lt;/h4&gt;</span><span id="7a3c" class="nx ly in lp b gy op nz l oa ob">        &lt;p&gt;{store.getState().count}&lt;/p&gt;</span><span id="7a61" class="nx ly in lp b gy op nz l oa ob">        &lt;button onClick={this.plus}&gt;+1&lt;/button&gt;<br/>        &lt;button onClick={this.minus}&gt;-1&lt;/button&gt;</span><span id="e886" class="nx ly in lp b gy op nz l oa ob">        &lt;br /&gt;<br/>        &lt;br /&gt;</span><span id="a693" class="nx ly in lp b gy op nz l oa ob">        &lt;h4&gt;Multiply / Divide 2 (0.3s delay)&lt;/h4&gt;<br/>        &lt;p&gt;{store.getState().double}&lt;/p&gt;</span><span id="7cf8" class="nx ly in lp b gy op nz l oa ob">        &lt;button onClick={this.multiply}&gt;x2&lt;/button&gt;<br/>        &lt;button onClick={this.divide}&gt;/2&lt;/button&gt;<br/>      &lt;/div&gt;<br/>    );<br/>  }<br/>}</span></pre><h1 id="48ea" class="lx ly in bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated"><a class="ae kt" href="https://pitayan.com/#conclusion" rel="noopener ugc nofollow" target="_blank">结论</a></h1><p id="68bf" class="pw-post-body-paragraph jv jw in jx b jy mv ka kb kc mw ke kf kg mx ki kj kk my km kn ko mz kq kr ks ig bi translated">我认为在现代 web 开发中，OOP 仍然是主流。然而，我们可以看到，有一些开源项目混合了编程范式，并交付了非常合格的框架(例如<a class="ae kt" href="https://nestjs.com/" rel="noopener ugc nofollow" target="_blank"> nest.js </a>)。感谢<code class="fe lm ln lo lp b">React</code>社区，计划生育现在是发展必需品的一部分。</p><p id="d216" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">好了，Redux 向下钻取到此为止。希望你也能很好地理解<a class="ae kt" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux </a>中的 FP 设计。如果你觉得这篇文章很棒，请分享到社交网络上。</p><p id="4fcb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">感谢阅读！</p><h1 id="df15" class="lx ly in bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated"><a class="ae kt" href="https://pitayan.com/#references" rel="noopener ugc nofollow" target="_blank">参考文献</a></h1><ul class=""><li id="4fb2" class="na nb in jx b jy mv kc mw kg or kk os ko ot ks od ng nh ni bi translated"><a class="ae kt" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank">https://redux.js.org</a></li><li id="8e57" class="na nb in jx b jy nj kc nk kg nl kk nm ko nn ks od ng nh ni bi translated"><a class="ae kt" href="https://github.com/reduxjs/redux" rel="noopener ugc nofollow" target="_blank">https://github.com/reduxjs/redux</a></li><li id="a7ed" class="na nb in jx b jy nj kc nk kg nl kk nm ko nn ks od ng nh ni bi translated">【https://en.wikipedia.org/wiki/Distributive_property T2】号</li><li id="2f29" class="na nb in jx b jy nj kc nk kg nl kk nm ko nn ks od ng nh ni bi translated">【https://en.wikipedia.org/wiki/Associative_property T4】</li><li id="be4b" class="na nb in jx b jy nj kc nk kg nl kk nm ko nn ks od ng nh ni bi translated"><a class="ae kt" href="https://medium.com/javascript-scene/10-tips-for-better-redux-architecture-69250425af44" rel="noopener">https://medium . com/JavaScript-scene/10-tips-for-better-redux-architecture-69250425 af 44</a></li><li id="4d5e" class="na nb in jx b jy nj kc nk kg nl kk nm ko nn ks od ng nh ni bi translated"><a class="ae kt" href="https://code-cartoons.com/a-cartoon-intro-to-redux-3afb775501a6?source=search_post---------3" rel="noopener ugc nofollow" target="_blank">https://code-卡通. com/a-卡通-intro-to-redux-3afb775501a6？source=search_post - 3 </a></li></ul></div><div class="ab cl ou ov hr ow" role="separator"><span class="ox bw bk oy oz pa"/><span class="ox bw bk oy oz pa"/><span class="ox bw bk oy oz"/></div><div class="ig ih ii ij ik"><p id="5593" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">原本在<a class="ae kt" href="https://pitayan.com/?ref=medium" rel="noopener ugc nofollow" target="_blank">Pitayan.com</a></p><p id="3899" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae kt" href="https://pitayan.com/posts/redux-fp-design/?ref=medium" rel="noopener ugc nofollow" target="_blank">https://pitayan.com/posts/redux-fp-design/</a></p><div class="ku kv gp gr kw kx"><a href="https://pitayan.com/posts/redux-fp-design/?ref=medium" rel="noopener  ugc nofollow" target="_blank"><div class="ky ab fo"><div class="kz ab la cl cj lb"><h2 class="bd io gy z fp lc fr fs ld fu fw im bi translated">向 Redux - Pitayan 学习 FP 设计</h2><div class="le l"><h3 class="bd b gy z fp lc fr fs ld fu fw dk translated">在我着眼于 Redux 源代码之前，我天真地认为 OOP 比 FP(函数式编程)更好…</h3></div><div class="lf l"><p class="bd b dl z fp lc fr fs ld fu fw dk translated">pitayan.com</p></div></div><div class="lg l"><div class="lh l li lj lk lg ll jt kx"/></div></div></a></div></div></div>    
</body>
</html>