<html>
<head>
<title>Python — WebSocket Introduction and Implementation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python — WebSocket 简介和实现</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/python-websocket-introduction-and-implementation-b2bb996558fb?source=collection_archive---------0-----------------------#2022-11-17">https://blog.devgenius.io/python-websocket-introduction-and-implementation-b2bb996558fb?source=collection_archive---------0-----------------------#2022-11-17</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><div class=""><h2 id="c74c" class="pw-subtitle-paragraph jo iq ir bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated">什么是 WebSocket，如何用 Python 实现？</h2></div><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj kg"><img src="../Images/40cea0fd08d48abc264e3e4de8d3c147.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6LAtp47ttRGowLSvsSoHqA.png"/></div></div></figure><p id="5913" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">WebSocket 是 HTML5 提供的一种网络技术，用于浏览器和服务器之间的全双工通信。这是一种先进的技术，它使得开启一种双向互动交流成为可能。</p><p id="7ef5" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">使用 WebSocket API，您可以向远程服务器发送消息并接收事件驱动的响应，而不必轮询服务器以获得回复。与非持久性协议 HTTP 相比，WebSocket 是一种用于持久性网络通信的协议。</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj lo"><img src="../Images/44b6c8d875070b94258cf3a1cace6e5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XlbuEf7X2QPVCDeA3Qerag.png"/></div></div></figure><p id="e5cf" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">如上图所示，它不仅允许客户端请求服务器，还允许服务器主动向客户端推送数据。是一种<strong class="ku is">真正的</strong>双向平等对话，属于一种服务器推送技术。</p><h1 id="a687" class="lp lq ir bd lr ls lt lu lv lw lx ly lz jx ma jy mb ka mc kb md kd me ke mf mg bi translated">WebSocket 功能</h1><ul class=""><li id="eff8" class="mh mi ir ku b kv mj ky mk lb ml lf mm lj mn ln mo mp mq mr bi translated">基于 TCP 协议，服务器端的实现相对容易。</li><li id="0376" class="mh mi ir ku b kv ms ky mt lb mu lf mv lj mw ln mo mp mq mr bi translated">与 HTTP 协议兼容性好。默认端口也是 80 和 443，握手阶段使用 HTTP 协议，握手过程中不容易屏蔽，可以通过各种 HTTP 代理服务器。</li><li id="8e8c" class="mh mi ir ku b kv ms ky mt lb mu lf mv lj mw ln mo mp mq mr bi translated">数据格式相对轻量，性能开销小，通信高效。</li><li id="23e4" class="mh mi ir ku b kv ms ky mt lb mu lf mv lj mw ln mo mp mq mr bi translated">文本和二进制数据都可以发送。</li><li id="8c12" class="mh mi ir ku b kv ms ky mt lb mu lf mv lj mw ln mo mp mq mr bi translated">没有同源限制，客户端可以与任何服务器通信。</li><li id="09c6" class="mh mi ir ku b kv ms ky mt lb mu lf mv lj mw ln mo mp mq mr bi translated">协议标识符为<code class="fe mx my mz na b">ws</code>(如果加密则为<code class="fe mx my mz na b">wss</code>)，服务器 URL 为 URL，例如:<code class="fe mx my mz na b">ws(s)://test.com:80/some/path</code></li></ul><h1 id="a081" class="lp lq ir bd lr ls lt lu lv lw lx ly lz jx ma jy mb ka mc kb md kd me ke mf mg bi translated">为什么选择 WebSocket</h1><h2 id="bc58" class="nb lq ir bd lr nc nd dn lv ne nf dp lz lb ng nh mb lf ni nj md lj nk nl mf nm bi translated">无国籍的</h2><p id="08e6" class="pw-post-body-paragraph ks kt ir ku b kv mj js kx ky mk jv la lb nn ld le lf no lh li lj np ll lm ln ik bi translated">在 Web 应用程序体系结构上下文中，HTTP 是在客户机/服务器模型中使用的请求-响应协议，在这种模型中，客户机向服务器提交 HTTP 请求，服务器用请求的资源进行响应。</p><p id="737d" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">然而，HTTP 协议是无状态的，也就是说，它将每个请求视为唯一和独立的单元。无状态协议有一些优点，例如，服务器不需要保存关于会话的信息，因此不需要存储数据。</p><p id="cc9f" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">这也意味着关于请求的冗余信息在每个 HTTP 请求和响应中被发送，比如使用 cookies 来验证用户状态。</p><p id="71a6" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">随着客户机和服务器之间交互的增加，HTTP 协议在客户机和服务器之间通信所需的信息量也在迅速增加。</p><h2 id="f60a" class="nb lq ir bd lr nc nd dn lv ne nf dp lz lb ng nh mb lf ni nj md lj nk nl mf nm bi translated">半双工</h2><p id="7743" class="pw-post-body-paragraph ks kt ir ku b kv mj js kx ky mk jv la lb nn ld le lf no lh li lj np ll lm ln ik bi translated">另一个缺点是 HTTP 也是半双工协议，即同一时刻的信息流只能是单向的:客户端向服务器发送请求，服务器响应请求。这种半双工协议使得通信效率较低。</p><h2 id="baae" class="nb lq ir bd lr nc nd dn lv ne nf dp lz lb ng nh mb lf ni nj md lj nk nl mf nm bi translated">客户端初始化</h2><p id="d88d" class="pw-post-body-paragraph ks kt ir ku b kv mj js kx ky mk jv la lb nn ld le lf no lh li lj np ll lm ln ik bi translated">同时，HTTP 协议有一个缺陷:通信只能由客户端发起。因此，如果服务器发生状态变化，它将无法通知客户端。</p><h2 id="f802" class="nb lq ir bd lr nc nd dn lv ne nf dp lz lb ng nh mb lf ni nj md lj nk nl mf nm bi translated">变通办法</h2><p id="cde8" class="pw-post-body-paragraph ks kt ir ku b kv mj js kx ky mk jv la lb nn ld le lf no lh li lj np ll lm ln ik bi translated">为了提高 HTTP 协议的通信效率，实现了以下方法:</p><ul class=""><li id="0d65" class="mh mi ir ku b kv kw ky kz lb nq lf nr lj ns ln mo mp mq mr bi translated"><strong class="ku is">轮询</strong>:每隔一段时间，就会发出一个请求，询问服务器是否有新的信息。</li><li id="b9ed" class="mh mi ir ku b kv ms ky mt lb mu lf mv lj mw ln mo mp mq mr bi translated"><strong class="ku is">长轮询</strong>:客户端向服务器请求信息，并在设定的时间内保持连接。</li><li id="87f2" class="mh mi ir ku b kv ms ky mt lb mu lf mv lj mw ln mo mp mq mr bi translated"><strong class="ku is">流技术</strong>:客户端发送请求，服务器发送并维护一个持续更新并保持开放的开放响应。</li></ul><p id="3bc7" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">然而，上述方法都没有提供接近实时的通信，并且它们还引入了大量额外的和不必要的报头数据和延迟。</p><p id="5cc0" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">于是，<a class="ae nt" href="https://en.wikipedia.org/wiki/Michael_Carter_(entrepreneur)" rel="noopener ugc nofollow" target="_blank">米迦勒·卡特</a> a 一群人提出了 WebSocket，这是一种天然的全双工、双向、单套接字连接，解决了 HTTP 协议不适合实时通信的问题。</p><h1 id="4d42" class="lp lq ir bd lr ls lt lu lv lw lx ly lz jx ma jy mb ka mc kb md kd me ke mf mg bi translated">WebSocket 握手</h1><p id="06df" class="pw-post-body-paragraph ks kt ir ku b kv mj js kx ky mk jv la lb nn ld le lf no lh li lj np ll lm ln ik bi translated">典型的 HTTP 握手如下所示:</p><pre class="kh ki kj kk gu nu na nv nw aw nx bi"><span id="8b21" class="nb lq ir na b gz ny nz l oa ob">GET / HTTP/2<br/>Host: google.com<br/>user-agent: curl/7.79.1<br/>accept: */*<br/>HTTP/2 301<br/>location: <a class="ae nt" href="https://www.google.com/" rel="noopener ugc nofollow" target="_blank">https://www.google.com/</a><br/>content-type: text/html; charset=UTF-8<br/>date: Mon, 03 Oct 2022 17:50:02 GMT<br/>expires: Wed, 02 Nov 2022 17:50:02 GMT<br/>cache-control: public, max-age=2592000<br/>server: gws<br/>content-length: 220<br/>x-xss-protection: 0<br/>x-frame-options: SAMEORIGIN</span></pre><p id="57aa" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">虽然 WebSocket 本身也是一个新的应用层协议，但是它不能独立于 HTTP 而存在。具体来说，我们在客户机上构建一个 WebSocket 实例，并将其与需要连接的服务器地址绑定。当客户端连接到服务器时，它将向服务器发送类似于以下内容的 http 消息:</p><pre class="kh ki kj kk gu nu na nv nw aw nx bi"><span id="f7e4" class="nb lq ir na b gz ny nz l oa ob"><em class="oc">Host: 127.0.0.1:8081<br/></em><strong class="na is"><em class="oc">Upgrade: websocket<br/>Connection: Upgrade<br/></em></strong><em class="oc">Sec-WebSocket-Key: 1wX9ZDz+x2c+7PoKBhr+eA==<br/>Sec-WebSocket-Version: 13<br/>Sec-WebSocket-Extensions: permessage-deflate; client_max_window_bits<br/>User-Agent: Python/3.10 websockets/10.3</em></span></pre><p id="b123" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">您可以看到，这是一个 HTTP get 请求消息。请注意，消息中有一个升级标头。它的作用是告诉服务器，通信协议需要切换到 WebSocket。如果服务器支持 WebSocket 协议，则该协议会切换到 WebSocket，同时会向客户端发送类似以下内容的响应头:</p><pre class="kh ki kj kk gu nu na nv nw aw nx bi"><span id="9da7" class="nb lq ir na b gz ny nz l oa ob"><strong class="na is"><em class="oc">Upgrade: websocket<br/>Connection: Upgrade</em></strong><em class="oc"><br/>Sec-WebSocket-Accept: yBKlMEVMvp6dGL6qj4OH/T6zd5o=<br/>Sec-WebSocket-Extensions: permessage-deflate; server_max_window_bits=12; client_max_window_bits=12<br/>Date: Mon, 03 Oct 2022 18:29:32 GMT<br/>Server: Python/3.10 websockets/10.3</em></span></pre><p id="f885" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">您可以看到返回的状态代码是 101，表明该协议被转换为 WebSocket。上面的过程是使用 HTTP 通信来完成的，这种通信称为 WebSocket 协议握手。此后，客户端和服务器建立 WebSocket 连接，随后的通信基于 WebSocket。</p><h1 id="5c37" class="lp lq ir bd lr ls lt lu lv lw lx ly lz jx ma jy mb ka mc kb md kd me ke mf mg bi translated">WebSocket Python 实现</h1><p id="6ade" class="pw-post-body-paragraph ks kt ir ku b kv mj js kx ky mk jv la lb nn ld le lf no lh li lj np ll lm ln ik bi translated">现在您已经了解了 WebSocket 的工作原理，让我们尝试使用 Python 实现一个 WebSocket 服务器。</p><h2 id="2cc1" class="nb lq ir bd lr nc nd dn lv ne nf dp lz lb ng nh mb lf ni nj md lj nk nl mf nm bi translated">安装 websockets 库</h2><p id="b5cb" class="pw-post-body-paragraph ks kt ir ku b kv mj js kx ky mk jv la lb nn ld le lf no lh li lj np ll lm ln ik bi translated">我们需要先安装<code class="fe mx my mz na b">websockets</code> Python 库:</p><pre class="kh ki kj kk gu nu na nv nw aw nx bi"><span id="92af" class="nb lq ir na b gz ny nz l oa ob">$ pip install websockets<br/>Collecting websockets<br/>  Downloading websockets-10.3-cp310-cp310-manylinux_2_5_x86_64.manylinux1_x86_64.manylinux_2_12_x86_64.manylinux2010_x86_64.whl (111 kB)<br/>     ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 111.5/111.5 kB 1.9 MB/s eta 0:00:00<br/>Installing collected packages: websockets<br/>Successfully installed websockets-10.3web_server.py</span></pre><h2 id="1362" class="nb lq ir bd lr nc nd dn lv ne nf dp lz lb ng nh mb lf ni nj md lj nk nl mf nm bi translated">计算机网络服务器</h2><pre class="kh ki kj kk gu nu na nv nw aw nx bi"><span id="7ce3" class="nb lq ir na b gz ny nz l oa ob">import asyncio<br/>import websockets</span><span id="1a32" class="nb lq ir na b gz od nz l oa ob">async def handler(ws, path):<br/>    data = await ws.recv()<br/>    reply = f"Data received: {data}"<br/>    await ws.send(reply)</span><span id="7bbc" class="nb lq ir na b gz od nz l oa ob">if __name__ == "__main__":<br/>    start_server = websockets.serve(handler, "127.0.0.1", 8081)<br/>    asyncio.get_event_loop().run_until_complete(start_server)<br/>    asyncio.get_event_loop().run_forever()</span></pre><h2 id="dfc8" class="nb lq ir bd lr nc nd dn lv ne nf dp lz lb ng nh mb lf ni nj md lj nk nl mf nm bi translated">客户</h2><pre class="kh ki kj kk gu nu na nv nw aw nx bi"><span id="e68f" class="nb lq ir na b gz ny nz l oa ob">import asyncio<br/>import websockets</span><span id="3a40" class="nb lq ir na b gz od nz l oa ob">async def connect():<br/>    async with websockets.connect("ws://127.0.0.1:8081/") as websocket:<br/>        await websocket.send("hello world")<br/>        print(f"Reuqest headers:\n{websocket.request_headers}")<br/>        response = await websocket.recv()<br/>        print(f"Response headers:\n{websocket.response_headers}")<br/>        print(response)</span><span id="d7e5" class="nb lq ir na b gz od nz l oa ob">if __name__ == "__main__":<br/>    asyncio.get_event_loop().run_until_complete(connect())</span></pre><p id="4dbf" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">作为服务器运行:</p><pre class="kh ki kj kk gu nu na nv nw aw nx bi"><span id="fba3" class="nb lq ir na b gz ny nz l oa ob">$ python web_server.py <br/></span></pre><p id="15c4" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">作为客户:</p><pre class="kh ki kj kk gu nu na nv nw aw nx bi"><span id="6027" class="nb lq ir na b gz ny nz l oa ob">$ python web_client.py <br/><br/><em class="oc">Reuqest headers:<br/>Host: 127.0.0.1:8081<br/>Upgrade: websocket<br/>Connection: Upgrade<br/>Sec-WebSocket-Key: 1wX9ZDz+x2c+7PoKBhr+eA==<br/>Sec-WebSocket-Version: 13<br/>Sec-WebSocket-Extensions: permessage-deflate; client_max_window_bits<br/>User-Agent: Python/3.10 websockets/10.3</em></span><span id="5d0a" class="nb lq ir na b gz od nz l oa ob"><em class="oc">Response headers:<br/>Upgrade: websocket<br/>Connection: Upgrade<br/>Sec-WebSocket-Accept: yBKlMEVMvp6dGL6qj4OH/T6zd5o=<br/>Sec-WebSocket-Extensions: permessage-deflate; server_max_window_bits=12; client_max_window_bits=12<br/>Date: Mon, 03 Oct 2022 18:29:32 GMT<br/>Server: Python/3.10 websockets/10.3</em></span><span id="6d34" class="nb lq ir na b gz od nz l oa ob"><em class="oc">Data received: hello world</em></span></pre></div></div>    
</body>
</html>