<html>
<head>
<title>A Standard &amp; Complete CI/CD Pipeline for Most Python Projects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">适用于大多数 Python 项目的标准且完整的 CI/CD 管道</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/a-standard-complete-ci-cd-pipeline-for-most-python-projects-263602a05b2f?source=collection_archive---------0-----------------------#2021-01-22">https://blog.devgenius.io/a-standard-complete-ci-cd-pipeline-for-most-python-projects-263602a05b2f?source=collection_archive---------0-----------------------#2021-01-22</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><h2 id="0868" class="il im in bd b dl io ip iq ir is it dk iu translated" aria-label="kicker paragraph">编程；编排</h2><div class=""/><div class=""><h2 id="02ac" class="pw-subtitle-paragraph jt iw in bd b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk dk translated">对于大多数 Python 项目来说，这是您能找到的最完整的(也是标准的)CI/CD 管道。现在花更多的时间维护你的项目，而不是修复 CI/CD 问题。</h2></div><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/f6cf062d26b10f303d6026b1aca93f6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J5V76PSAEc9IzYDooSHxBg.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">托管和使用 GitHub 服务以获得平和的心态|来源— Somraj Saha(作者)</figcaption></figure><p id="fef2" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">你是否曾经花费大量时间修补 CI/CD 工具，而不是为你的 Python 项目编写代码？</p><p id="2f4b" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">我确实做了！有时<a class="ae lx" href="https://python-poetry.org/" rel="noopener ugc nofollow" target="_blank">诗歌</a>由于虚拟环境无法安装依赖项。或者其他时候，由于某些原因，依赖关系不会缓存。最重要的是，CI/CD 工具很难调试 dude 来掩盖错误消息。</p><p id="5ac8" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">因此，我分享这个 GitHub 动作工作流，我在我的大多数 Python 项目中都使用它。它开箱即用，无需任何修补&amp;让您走上发布项目的正确道路。工作流程非常简单，但并没有在维护最佳编码标准所需的一些最主要的 CI/CD 原则上妥协。保持它的最小化也意味着，您可以自由地在它的基础上进行进一步的改变和改进。</p><p id="6d8e" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">也就是说，以下是您从该工作流程中获得的内容，开箱即用，无需任何更改:</p><ul class=""><li id="ee43" class="ly lz in ld b le lf lh li lk ma lo mb ls mc lw md me mf mg bi translated">林挺&amp;将所有 PRs &amp;上的<code class="fe mh mi mj mk b">Pylint</code>、<code class="fe mh mi mj mk b">Black</code>、&amp;、<code class="fe mh mi mj mk b">isort</code>的代码格式化推送到远程存储库。</li><li id="053e" class="ly lz in ld b le ml lh mm lk mn lo mo ls mp lw md me mf mg bi translated">在合并 PR 之前，运行集成测试套件来捕捉任何重大变更。</li><li id="1545" class="ly lz in ld b le ml lh mm lk mn lo mo ls mp lw md me mf mg bi translated">缓存依赖项以加快工作流执行时间。</li><li id="68fd" class="ly lz in ld b le ml lh mm lk mn lo mo ls mp lw md me mf mg bi translated">上传覆盖报告到<a class="ae lx" href="https://about.codecov.io/" rel="noopener ugc nofollow" target="_blank"> CodeCov </a>用于后续的覆盖报告。</li></ul><p id="a096" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">因此，如您所见，该工作流并没有做太多事情，但确保了最低限度的 CI/CD 原则得到遵守。最重要的是，您很快就会看到，您可以在此基础上进行构建。</p><h1 id="cba5" class="mq mr in bd ms mt mu mv mw mx my mz na kc nb kd nc kf nd kg ne ki nf kj ng nh bi translated">关于工作流程</h1><p id="0625" class="pw-post-body-paragraph lb lc in ld b le ni jx lg lh nj ka lj lk nk lm ln lo nl lq lr ls nm lu lv lw ig bi translated">Python 的包管理场景并不值得称道(<strong class="ld ix">来源</strong>:<a class="ae lx" href="https://news.ycombinator.com/item?id=19989188" rel="noopener ugc nofollow" target="_blank"/>&amp;<a class="ae lx" href="https://news.ycombinator.com/item?id=10000479" rel="noopener ugc nofollow" target="_blank">【2】</a>)。再加上那些打包问题，由于 virtualenv 的需求，设置 CI/CD 工具也相当复杂(至少在 GitHub Actions 上)。因此，我在互联网上搜索，为 Python 项目找到了最佳的 CI/CD 设置。虽然即时可用的诗歌对于本地开发来说是一个很好的 CLI 工具，但是它并不适合 CI/CD 平台。有了诗歌，你可以管理本地的 virtualenvs，就像从你的终端上发布你的项目一样简单！</p><p id="5776" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">但那是体力劳动。作为开发人员，我们经常提交&amp;定期推送至远程存储库。重复的手工任务容易出错，因此增加了 bug 或破坏项目变更的机会。因此，我的目标是在不花费太多时间设置 CI/CD 工具的情况下解决这个问题。</p><p id="17e7" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">目标是使设置尽可能简单和最小化，但应符合 CI/CD 原则的现代标准。</p><p id="b923" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">换句话说，设置应该能够执行林挺和/或格式化任务，运行测试套件，生成覆盖报告，并将报告上传到 CodeCov。这些是任务，设置<strong class="ld ix">应该至少有</strong>。因此，极简主义的原则被铭记在心。</p><p id="6eaf" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">我还假设大多数项目都托管在 GitHub 仓库中，所以设置只对具有 GitHub 动作的<strong class="ld ix">起作用。如果你想使用其他 CI/CD 平台，如<a class="ae lx" href="https://www.travis-ci.com/" rel="noopener ugc nofollow" target="_blank">Travis CI</a>/<a class="ae lx" href="https://circleci.com/" rel="noopener ugc nofollow" target="_blank">circle CI</a>，那么你可能会想去别处看看。</strong></p><p id="c0b4" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">也就是说，您可以将下面共享的代码片段复制到项目的<code class="fe mh mi mj mk b">.github</code>目录下一个恰当命名的<code class="fe mh mi mj mk b">&lt;NAME-OF-THE-WORKFLOW&gt;.yml</code>中。例如，我通常将文件命名为<code class="fe mh mi mj mk b">test_suite.yml</code>。GitHub 可以从那里自动识别你的工作流文件。一旦您将提交推送到远程存储库，工作流就应该启动了。您可以在<code class="fe mh mi mj mk b">https://github.com/&lt;GITHUB-USERNAME&gt;/&lt;PROJECT-NAME&gt;/actions?query=workflow%3A%22Test+Suite%22</code>访问它。</p><p id="e2b1" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">也就是说，这里是 CI/CD 管道的代码片段。随意复制+粘贴。😉</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nn no l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">适合大多数 Python 项目的标准 CI/CD 管道</figcaption></figure><h1 id="083a" class="mq mr in bd ms mt mu mv mw mx my mz na kc nb kd nc kf nd kg ne ki nf kj ng nh bi translated">工作流程的简要概述</h1><p id="c6cb" class="pw-post-body-paragraph lb lc in ld b le ni jx lg lh nj ka lj lk nk lm ln lo nl lq lr ls nm lu lv lw ig bi translated">如果你像我一样不耐烦，想浏览一下这篇文章，你应该知道以下几点:</p><ul class=""><li id="0ca3" class="ly lz in ld b le lf lh li lk ma lo mb ls mc lw md me mf mg bi translated">工作流在 PR &amp; push 事件上执行。当有人制作公关时，<code class="fe mh mi mj mk b">Test Suite</code>工作流就会运行。当您将本地提交推送到远程存储库时，也会发生同样的情况。</li><li id="7b44" class="ly lz in ld b le ml lh mm lk mn lo mo ls mp lw md me mf mg bi translated">该工作流由两个作业组成:<code class="fe mh mi mj mk b">linter</code> &amp; <code class="fe mh mi mj mk b">test</code>。后者依赖于前者。因此，如果<code class="fe mh mi mj mk b">linter</code>失败，将跳过<code class="fe mh mi mj mk b">test</code>的执行。</li><li id="49a4" class="ly lz in ld b le ml lh mm lk mn lo mo ls mp lw md me mf mg bi translated"><code class="fe mh mi mj mk b">linter</code>运行在 Ubuntu 虚拟机上&amp;为林挺&amp;安装<code class="fe mh mi mj mk b">Pylint</code>、<code class="fe mh mi mj mk b">Black</code>、<code class="fe mh mi mj mk b">isort</code>格式化代码。它们也被缓存以减少执行时间。</li><li id="156f" class="ly lz in ld b le ml lh mm lk mn lo mo ls mp lw md me mf mg bi translated"><code class="fe mh mi mj mk b">test</code>分别运行在一台 MacOS、一台 Ubuntu &amp;一台 Windows VM 与 Python 版本- <code class="fe mh mi mj mk b">3.8</code> &amp; <code class="fe mh mi mj mk b">3.9</code>。请注意，这些运行是并行发生的，与彼此的执行状态无关。</li><li id="75fa" class="ly lz in ld b le ml lh mm lk mn lo mo ls mp lw md me mf mg bi translated"><code class="fe mh mi mj mk b">test</code>作业还会缓存&amp;安装存储在<code class="fe mh mi mj mk b">.venv</code>目录下的 virtualenv。然后用 PyTest 运行测试套件，PyTest 会生成一个<code class="fe mh mi mj mk b">coverage.xml</code>报告并上传到 CodeCov。</li></ul><p id="862c" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">因此，正如您所看到的，即使工作流尽可能保持最小化，它仍然完成了很多任务。事实上，这些任务中的大部分对于保持项目的最低质量标准是必不可少的。</p><p id="711b" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">无论如何，在简要概述了工作流的作用之后，让我们更深入地看看每一行代码是为了什么而编写的。下一节将尽可能详细地描述它。</p><h1 id="6e15" class="mq mr in bd ms mt mu mv mw mx my mz na kc nb kd nc kf nd kg ne ki nf kj ng nh bi translated">对工作流程的深入解释</h1><p id="0725" class="pw-post-body-paragraph lb lc in ld b le ni jx lg lh nj ka lj lk nk lm ln lo nl lq lr ls nm lu lv lw ig bi translated">文件的顶部是<code class="fe mh mi mj mk b">name: Test Suite</code>键值对。它描述了 GitHub 在其 web UI 中显示的工作流的名称。接下来的一行，<code class="fe mh mi mj mk b">on: [pull_request, push]</code> pair 描述了应该触发工作流的事件。</p><p id="bb7a" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated"><code class="fe mh mi mj mk b">jobs:</code>部分描述了应该并行运行的不同任务(没有必要，稍后会详细介绍)。作为一个极简主义者，这个工作流程描述了两个工作:a <code class="fe mh mi mj mk b">linter</code> &amp; a <code class="fe mh mi mj mk b">test</code>。作业的名称有意保持自描述性。正如前面提到的，当一些代码被推送到存储库或者 PR 被创建时，<code class="fe mh mi mj mk b">linter</code>执行林挺操作。而<code class="fe mh mi mj mk b">test</code>作业在推的代码或 PR 中启动一系列测试。</p><p id="baa2" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">也就是说，每个作业都必须被分配一个操作系统，该操作系统被分配了<code class="fe mh mi mj mk b">runs-on:</code>关键字。虽然这些<a class="ae lx" href="https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions#jobsjob_idstrategymax-parallel" rel="noopener ugc nofollow" target="_blank">作业并行运行</a>，但是它们可以相互依赖。因此，如果相关作业由于某些原因而提前失败，它们也可以在完成之前停止。</p><p id="5156" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">现在是有趣的部分。<code class="fe mh mi mj mk b">steps:</code>键描述了要执行的工作流程/命令。因此，<code class="fe mh mi mj mk b">linter</code>作业首先执行一个<a class="ae lx" href="https://github.com/actions/checkout" rel="noopener ugc nofollow" target="_blank"> Git Checkout </a>，然后在后续步骤中设置一个适当的 Python 版本。</p><p id="23a7" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">接下来的几个步骤涉及到缓存依赖项以减少工作流执行时间。<a class="ae lx" href="https://github.com/actions/cache" rel="noopener ugc nofollow" target="_blank">动作/缓存</a>动作加载之前缓存的依赖项。它还使用签名的密钥来标识正确的缓存。</p><p id="6006" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">如果依赖项没有从缓存中加载，那么<code class="fe mh mi mj mk b">pip</code>安装<code class="fe mh mi mj mk b">Black</code>、<code class="fe mh mi mj mk b">Pylint</code>、&amp;、<code class="fe mh mi mj mk b">isort</code>用于林挺。</p><p id="ddd3" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">任务的最后一步是执行前面提到的林挺格式化工具。<code class="fe mh mi mj mk b">Pylint, Black &amp; isort</code>有合理的缺省值，因此它们的传递没有任何附加的参数。</p><p id="78bd" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">最后来到<code class="fe mh mi mj mk b">test</code>工作。你很快就会看到，这份工作在一定程度上反映了上一份<code class="fe mh mi mj mk b">linter</code>工作。</p><p id="cfa2" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">立即使用<code class="fe mh mi mj mk b">needs:</code>键，该作业被称为依赖于<code class="fe mh mi mj mk b">linter</code>作业的完成。因此，<code class="fe mh mi mj mk b">test</code>不会并行执行，但如果<code class="fe mh mi mj mk b">linter</code>失败，也不会执行。使用<code class="fe mh mi mj mk b">fail-fast: true</code>对启用快速失效选项。</p><p id="cc62" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">除了上述策略之外，该作业还被设置为在具有多个 Python 版本的多个操作系统平台上运行。这是用<code class="fe mh mi mj mk b">matrix:</code>键设定的，其中<code class="fe mh mi mj mk b">os</code> &amp; <code class="fe mh mi mj mk b">python-version</code>有其值。<code class="fe mh mi mj mk b">os</code> &amp; <code class="fe mh mi mj mk b">python-version</code>值分别接受 OS&amp;Python 版本的一个数组。</p><p id="6602" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">下一行设置工作流应该运行的虚拟环境的默认 shell。</p><p id="2e98" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">如前所述，每个工作流都必须使用<code class="fe mh mi mj mk b">runs-on</code>关键字分配一个操作系统来运行。用于<code class="fe mh mi mj mk b">test</code>任务的<code class="fe mh mi mj mk b">runs-on</code>键接受一个变量，该变量将遍历在<code class="fe mh mi mj mk b">matrix.os</code>下设置的每个值。因此，允许工作流为不同的操作系统&amp; Python 版本运行后续步骤的多个实例！</p><p id="2ec8" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">接下来的两个步骤与<code class="fe mh mi mj mk b">linter</code>开始它的执行过程非常相似，但是有一个警告。基于在<code class="fe mh mi mj mk b">matrix.python-version</code>下设置的值，每个 OS 实例也将有一个 Python 实例。</p><p id="af0a" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">现在，工作流使用<code class="fe mh mi mj mk b">[snok/install-poetry](https://github.com/snok/install-poetry)</code>动作安装诗歌，而不是像在<code class="fe mh mi mj mk b">linter</code>中那样安装<code class="fe mh mi mj mk b">pip</code>。它将 poem 配置为在项目目录中设置 virtualenvs，然后可以在下一步中轻松地缓存它。</p><p id="b543" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">缓存操作缓存整个 virtualenv，而不是依赖项。因此，只有当缓存的<code class="fe mh mi mj mk b">.venv</code>没有恢复时，poem 才会安装依赖项。</p><p id="84d0" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">随后，<code class="fe mh mi mj mk b">.venv</code>被激活&amp; <code class="fe mh mi mj mk b">pytest</code>然后运行测试套件。传递给<code class="fe mh mi mj mk b">pytest</code>的参数确保了调试&amp;的最大详细程度，以根目录中的<code class="fe mh mi mj mk b">.xml</code>文件格式报告输出。生成的报告然后使用<code class="fe mh mi mj mk b"><a class="ae lx" href="https://github.com/codecov/codecov-action" rel="noopener ugc nofollow" target="_blank">codecov/codecov-action</a></code>将文件上传到<a class="ae lx" href="https://about.codecov.io/" rel="noopener ugc nofollow" target="_blank"> CodeCov </a>。</p><p id="51fc" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">CodeCov 动作接受一个 API 令牌，您必须将它复制并作为一个<a class="ae lx" href="https://docs.github.com/en/actions/reference/encrypted-secrets" rel="noopener ugc nofollow" target="_blank"> Secret </a>环境变量传入。CodeCov 令牌可以在<code class="fe mh mi mj mk b">https://codecov.io/gh/&lt;GITHUB-USERNAME&gt;/&lt;PROJECT-NAME&gt;</code>找到(针对 GitHub 上托管的项目)。最后，在最后，CodeCov 操作被设置为失败，如果它出错。</p><p id="c5e6" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">最辉煌的工作流程并不像听起来那么简单。如果您的项目是开源的，那么生产级软件应该按照以下标准进行彻底的测试和格式化，这就带来了它的复杂性。即便如此，仍然有很大的空间来进一步改进和改变。下一节将探讨如何进一步构建这个工作流。</p><h1 id="7132" class="mq mr in bd ms mt mu mv mw mx my mz na kc nb kd nc kf nd kg ne ki nf kj ng nh bi translated">进一步改进的空间</h1><p id="c0bb" class="pw-post-body-paragraph lb lc in ld b le ni jx lg lh nj ka lj lk nk lm ln lo nl lq lr ls nm lu lv lw ig bi translated">正如其他无数次提到的，管道保持极简，目的是:<em class="np">为进一步的变化和/或改进留有余地</em>。</p><p id="8c9b" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">根据个人需求，还可以做出更多的改变/改进。我能想到的一些改进是:</p><ul class=""><li id="257c" class="ly lz in ld b le lf lh li lk ma lo mb ls mc lw md me mf mg bi translated">启用一个<code class="fe mh mi mj mk b">release</code>事件，在其中测试、格式化、linted、构建&amp;包，然后用诗歌上传到 PyPi。</li><li id="6b4c" class="ly lz in ld b le ml lh mm lk mn lo mo ls mp lw md me mf mg bi translated">考虑到可伸缩性，linters 和代码格式化程序可以并行运行，而不是顺序运行。</li><li id="abee" class="ly lz in ld b le ml lh mm lk mn lo mo ls mp lw md me mf mg bi translated">在<code class="fe mh mi mj mk b">release</code>时标记并更新一个<code class="fe mh mi mj mk b">CHANGELOG.md</code>文件。</li></ul><p id="2db5" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">还有很多。可能性是无限的&amp;只受项目和个人维护者需求的限制。</p><p id="a2e2" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">但总而言之，这里分享的代码应该足以满足 GitHub 上的大多数开源 Python 项目。</p><p id="50e1" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">如果你觉得我错过了什么，那么在<a class="ae lx" href="https://twitter.com/Jarmosan" rel="noopener ugc nofollow" target="_blank">推特</a>、<a class="ae lx" href="mailto:somraj.mle@gmail.com" rel="noopener ugc nofollow" target="_blank">电子邮件</a>和/或<a class="ae lx" href="https://github.com/Jarmos-san/Jarmos-san/discussions/categories/q-a" rel="noopener ugc nofollow" target="_blank">上联系我，问我任何事情</a>。</p><p id="ce8c" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated"><a class="ae lx" href="https://jarmos.ck.page/newsletter" rel="noopener ugc nofollow" target="_blank"> <strong class="ld ix">订阅</strong>我的简讯</a> &amp;获取直接发送到您收件箱的个性化内容或文章更新！</p></div></div>    
</body>
</html>