<html>
<head>
<title>Using models to bind data to GTK4 custom widgets in Rust</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用模型将数据绑定到 Rust 中的 GTK4 定制小部件</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/using-models-to-bind-data-to-gtk4-custom-widgets-in-rust-379dd9d1bf4d?source=collection_archive---------5-----------------------#2022-03-29">https://blog.devgenius.io/using-models-to-bind-data-to-gtk4-custom-widgets-in-rust-379dd9d1bf4d?source=collection_archive---------5-----------------------#2022-03-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/efc5a046263892a94acd13a719b828b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WKC0iV0YgteeJ6Hf"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://guerrillabuzz.com/" rel="noopener ugc nofollow" target="_blank"> GuerrillaBuzz Crypto PR </a>在<a class="ae kc" href="https://unsplash.com/photos/gC_aoAjQl2Q" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="e98b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">到目前为止，编写我们的 libadwaita RSS 阅读器已经是一个相当长的旅程了。我们学习了<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/using-template-files-in-rust-for-a-gtk4-libadwaita-ui-8322694cbc3c">模板</a>、<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/bundling-templates-into-resources-in-rust-for-the-gtk4-ui-eb387a7918bf">资源</a>、<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/using-the-libadwaita-leaflet-widget-for-a-responsive-gtk4-ui-in-rust-73bbc2f4025">响应</a>和<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/refactoring-gtk4-ui-templates-in-rust-68cbef1a1778">自定义</a>小部件和<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/adding-properties-to-custom-gtk4-widgets-in-rust-67d4bbed8b08">属性</a>。当我们准备处理点击事件和实际的 RSS 数据时，我们需要一个缺失的要素:数据模型。我们想要分配我们的<code class="fe lb lc ld le b">FeedList</code>和<code class="fe lb lc ld le b">ArticleList</code>实际数据。现在我们在模板文件中这样做:在<code class="fe lb lc ld le b">article-list.ui</code>和<code class="fe lb lc ld le b">feed-list.ui</code>中，但那只是硬编码的数据。我们希望为这些小部件数组分配实际值，这些值可以在应用程序使用过程中改变。和往常一样，你可以在<a class="ae kc" href="https://github.com/raduzaharia-medium/gtk-rss-reader-models" rel="noopener ugc nofollow" target="_blank"> github </a>上找到代码。</p><p id="1897" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如我们上次看到的<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/adding-properties-to-custom-gtk4-widgets-in-rust-67d4bbed8b08">，GTK4 实现了一种 MVC:它有视图、模型和控制器。视图就是小部件。<code class="fe lb lc ld le b">FeedList</code>和<code class="fe lb lc ld le b">ArticleList</code>是窗口小部件，我们的<code class="fe lb lc ld le b">ListBox</code>也是，我们在它们中使用它们来显示数据行。<code class="fe lb lc ld le b">ListBox</code>可以通过调用它的<code class="fe lb lc ld le b">bind_model</code>函数来接收数据模型。让我们看看它是怎么做的。</a></p><h2 id="8ab5" class="lf lg iq bd lh li lj dn lk ll lm dp ln ko lo lp lq ks lr ls lt kw lu lv lw lx bi translated">列表框数据模型</h2><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ly"><img src="../Images/74bd91b172a086335f963bd181ced000.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HQg3xf1mfH5r2T9S"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@thomasbormans?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">托马斯·博尔曼斯</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="da6c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">ListBox</code>小部件允许几种类型的数据模型。它们都包含正常的日常数据，但它们也定义了<code class="fe lb lc ld le b">ListBox</code>中允许的选择类型。您可以选择单项或多项。你也可以完全没有选择。注意这种类型的交互是如何链接到<code class="fe lb lc ld le b">ListBox</code>数据模型的。这种情况发生在所有的 GTK 部件上。数据模型不仅仅是简单的数据，它们还定义了小部件行为的各个方面。</p><p id="1bcd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在决定选择模型后，我们准备用数据填充它，并用<code class="fe lb lc ld le b">bind_model</code>函数将它分配给<code class="fe lb lc ld le b">ListBox</code>。但是选择模型不允许任何类型的数据。物品必须是 GTK <code class="fe lb lc ld le b">GObjects</code>。所以我们必须从那里开始:我们需要为<code class="fe lb lc ld le b">FeedList</code>小部件创建一个数据模型，它将把<code class="fe lb lc ld le b">ListBox</code>与类型为<code class="fe lb lc ld le b">GObject</code>的项目绑定在一起。我们就叫它<code class="fe lb lc ld le b">FeedItem</code>。是的，我们必须为<code class="fe lb lc ld le b">ArticleList</code>做同样的事情。</p><h2 id="9f8d" class="lf lg iq bd lh li lj dn lk ll lm dp ln ko lo lp lq ks lr ls lt kw lu lv lw lx bi translated"><code class="fe lb lc ld le b">The FeedItem</code></h2><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi md"><img src="../Images/373fe0f71a3e4c30a07852b5c9eac568.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uMtaQ2IiMlngkA59x3Qvzg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">更新的项目结构—注意 article_item 和 feed_item</figcaption></figure><p id="b355" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">数据模型看起来就像小部件，但是它们没有扩展小部件或其他类。但是它们有一个<code class="fe lb lc ld le b">template.rs</code>并且它们需要<code class="fe lb lc ld le b">ObjectImpl</code>函数。让我们看看<code class="fe lb lc ld le b">mod.rs</code>是什么样子的:</p><pre class="lz ma mb mc gt me le mf mg aw mh bi"><span id="645e" class="lf lg iq le b gy mi mj l mk ml">mod template;</span><span id="2271" class="lf lg iq le b gy mm mj l mk ml">use glib::{wrapper, Object};<br/>use template::FeedItemTemplate;</span><span id="b244" class="lf lg iq le b gy mm mj l mk ml">wrapper! {<br/>  pub struct FeedItem(ObjectSubclass&lt;FeedItemTemplate&gt;);<br/>}</span><span id="051f" class="lf lg iq le b gy mm mj l mk ml">impl FeedItem {<br/>  pub fn new(name: &amp;str, url: &amp;str) -&gt; Self {<br/>    Object::new(&amp;[("name", &amp;name), ("url", &amp;url)])<br/>      .expect("Failed to create `FeedItem`.")<br/>  }<br/>}</span></pre><p id="0562" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">与小部件一样，<code class="fe lb lc ld le b">FeedItem</code>被包装在启用了<code class="fe lb lc ld le b">ObjectSubclass</code>语法的<code class="fe lb lc ld le b">wrapper!</code>宏中。子类是<code class="fe lb lc ld le b">FeedItemTemplate</code>，我们稍后会看到。我们剩下的就是接收提要名称及其 URL 的构造函数<code class="fe lb lc ld le b">new</code>。<code class="fe lb lc ld le b">FeedItemTemplate</code>包含更多实施细节:</p><pre class="lz ma mb mc gt me le mf mg aw mh bi"><span id="209e" class="lf lg iq le b gy mi mj l mk ml">use glib::{<br/>  object_subclass,<br/>  once_cell::sync::Lazy,<br/>  subclass::{object::ObjectImpl, types::ObjectSubclass},<br/>  ParamFlags, ParamSpec, ParamSpecString, ToValue, Value,<br/>};<br/>use std::cell::Cell;</span><span id="3a70" class="lf lg iq le b gy mm mj l mk ml">#[derive(Default)]<br/>pub struct FeedItemTemplate {<br/>  name: Cell&lt;String&gt;,<br/>  url: Cell&lt;String&gt;,<br/>}</span><span id="2036" class="lf lg iq le b gy mm mj l mk ml">#[object_subclass]<br/>impl ObjectSubclass for FeedItemTemplate {<br/>  const NAME: &amp;'static str = "FeedItem";<br/>  type Type = super::FeedItem;<br/>}</span><span id="8f41" class="lf lg iq le b gy mm mj l mk ml">impl ObjectImpl for FeedItemTemplate {<br/>  fn properties() -&gt; &amp;'static [ParamSpec] {<br/>    static PROPERTIES: Lazy&lt;Vec&lt;ParamSpec&gt;&gt; = Lazy::new(|| {<br/>      vec![<br/>        ParamSpecString::new("name", "name", "The name of the RSS <br/>          feed", Some(""), ParamFlags::READWRITE)<br/>        ParamSpecString::new("url", "url", "The url of the RSS <br/>          feed", Some(""), ParamFlags::READWRITE),]<br/>    });<br/>    PROPERTIES.as_ref()<br/>  }</span><span id="320c" class="lf lg iq le b gy mm mj l mk ml">  fn set_property(&amp;self, _obj: &amp;Self::Type, _id: usize, value: &amp;Value, pspec: &amp;ParamSpec) {<br/>    match pspec.name() {<br/>      "name" =&gt; {<br/>        let name_string = value.get()<br/>          .expect("The value needs to be of type `String`.");<br/>        self.name.replace(name_string);<br/>      }<br/>      "url" =&gt; {<br/>        let url_string = value.get()<br/>          .expect("The value needs to be of type `String`.");<br/>        self.url.replace(url_string);<br/>      }<br/>      _ =&gt; unimplemented!(),<br/>    }<br/>  }</span><span id="e630" class="lf lg iq le b gy mm mj l mk ml">fn property(&amp;self, _obj: &amp;Self::Type, _id: usize, pspec: &amp;ParamSpec) -&gt; Value {<br/>    match pspec.name() {<br/>      "name" =&gt; {<br/>        let result = self.name.take();<br/>        <br/>        self.name.set(result.clone());<br/>        result.to_value()<br/>      }<br/>      "url" =&gt; {<br/>        let result = self.url.take();</span><span id="284d" class="lf lg iq le b gy mm mj l mk ml">        self.url.set(result.clone());<br/>        result.to_value()<br/>      }<br/>      _ =&gt; unimplemented!(),<br/>    }<br/>  }<br/>}</span></pre><p id="f860" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该结构保存数据定义:<code class="fe lb lc ld le b">url</code>和<code class="fe lb lc ld le b">name</code>。接下来我们看到一些熟悉的东西:上一篇文章中的属性实现，当时我们向小部件添加了属性。那完全一样，是同一个概念。就像 GTK <code class="fe lb lc ld le b">Widget</code>也会是一只<code class="fe lb lc ld le b">GObject</code>。你瞧，是的:<code class="fe lb lc ld le b">ObjectImpl</code>是<code class="fe lb lc ld le b">GObject</code>的一部分，而<code class="fe lb lc ld le b">Widget</code>扩展了它。</p><p id="b026" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">类型是相当挑剔的。你必须消费它来获取它的价值，所以我们用<code class="fe lb lc ld le b">take</code>来做，但是我们必须用<code class="fe lb lc ld le b">set</code>把价值放回去。这使得我们的属性 getter 有点尴尬，但它就是这样。</p><p id="f806" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好了，带有 getters 和 setters 的两个属性:这就是我们的<code class="fe lb lc ld le b">FeedItem</code>的全部内容。当然，我们也需要创建一个包含文章标题和摘要的<code class="fe lb lc ld le b">ArticleItem</code>。</p><h2 id="224e" class="lf lg iq bd lh li lj dn lk ll lm dp ln ko lo lp lq ks lr ls lt kw lu lv lw lx bi translated">将模型应用于列表框</h2><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mn"><img src="../Images/de03dd6da2ebe2192e4b7ac8db3d92a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*T_5mpEN_s-Eo-Jlf"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">Susan Q Yin 在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="0340" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">FeedList</code>包含了<code class="fe lb lc ld le b">ListBox</code>并且它是唯一能够与之对话的，所以我们必须添加一个新的函数来允许它将来自外部的模型绑定到内部的<code class="fe lb lc ld le b">ListBox</code>。我们将在<code class="fe lb lc ld le b">FeedList</code>的<code class="fe lb lc ld le b">mod.rs</code>中通过更新其实现来做到这一点:</p><pre class="lz ma mb mc gt me le mf mg aw mh bi"><span id="db72" class="lf lg iq le b gy mi mj l mk ml">impl FeedList {<br/>  pub fn new() -&gt; Self {<br/>    glib::Object::new(&amp;[])<br/>      .expect("Failed to create an instance of FeedList")<br/>  }</span><span id="fa53" class="lf lg iq le b gy mm mj l mk ml">  pub fn set_model(&amp;self, model: Vec&lt;FeedItem&gt;) {<br/>    let template = FeedListTemplate::from_instance(self);<br/>    let list_store_model = ListStore::new(FeedItem::static_type());</span><span id="58af" class="lf lg iq le b gy mm mj l mk ml">    for element in model {<br/>      list_store_model.append(&amp;element);<br/>    }</span><span id="4c2c" class="lf lg iq le b gy mm mj l mk ml">    let selection_model = SingleSelection::new(Some(&amp;list_store_model));</span><span id="930d" class="lf lg iq le b gy mm mj l mk ml">    template.list_box.bind_model(Some(&amp;selection_model), |x| {<br/>      let name: String = x.property("name");<br/>      let action_row = ActionRow::builder().title(&amp;name).build();<br/>      let result = action_row.ancestor(Widget::static_type());</span><span id="a11e" class="lf lg iq le b gy mm mj l mk ml">      result.unwrap()<br/>    });<br/>  }<br/>}</span></pre><p id="fae1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们这里已经有了<code class="fe lb lc ld le b">new</code>函数，我们添加了<code class="fe lb lc ld le b">set_model</code>。这将接收到<code class="fe lb lc ld le b">model</code>，它只是一个<code class="fe lb lc ld le b">FeedItem</code>的数组。请注意在那之后我们是如何做的，正如我们在文章开头所说的:我们创建了<code class="fe lb lc ld le b">ListStore</code>模型、<code class="fe lb lc ld le b">SingleSelection</code>模型，然后我们将它绑定到<code class="fe lb lc ld le b">list_box</code>。但是这里有一点故事。看看<code class="fe lb lc ld le b">bind_model</code>不仅需要数据，还需要一个回调来指示<code class="fe lb lc ld le b">ListBox</code>如何创建类型为<code class="fe lb lc ld le b">ActionRow</code>的项目。</p><p id="79b1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在剩下的就是从主窗口初始化发送模型到<code class="fe lb lc ld le b">FeedList</code>和<code class="fe lb lc ld le b">ArticleList</code>(现在):</p><pre class="lz ma mb mc gt me le mf mg aw mh bi"><span id="3f0c" class="lf lg iq le b gy mi mj l mk ml">impl ObjectImpl for MainWindowTemplate {<br/>  fn constructed(&amp;self, obj: &amp;Self::Type) {<br/>    self.parent_constructed(obj);</span><span id="7637" class="lf lg iq le b gy mm mj l mk ml">    let feed_model = vec![<br/>      FeedItem::new("The Verge", "https://www.theverge.com/rss/index.xml"),<br/>      FeedItem::new("Ars Technica", "https://feeds.arstechnica.com/arstechnica/features"),<br/>      FeedItem::new("Hacker News", "https://news.ycombinator.com/rss"),<br/>    ];</span><span id="f8c4" class="lf lg iq le b gy mm mj l mk ml">    self.feed_list.set_model(feed_model);</span><span id="9f0a" class="lf lg iq le b gy mm mj l mk ml">    let article_model = vec![<br/>      ArticleItem::new("The Verge - Article 1", "Article 1 summary placed in a handy label widget"),<br/>      ArticleItem::new("The Verge - Article 2", "Article 2 summary placed in a handy label widget"),<br/>      ArticleItem::new("The Verge - Article 3", "Article 3 summary placed in a handy label widget"),<br/>      ArticleItem::new("The Verge - Article 4", "Article 4 summary placed in a handy label widget"),<br/>    ];</span><span id="53e7" class="lf lg iq le b gy mm mj l mk ml">    self.article_list.set_model(article_model);<br/>  }<br/>}</span></pre><p id="99bb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里没什么特别的。不过有一点，<code class="fe lb lc ld le b">article_list</code>的<code class="fe lb lc ld le b">set_model</code>有点古怪。当您绑定模型以将摘要放入小部件的扩展中时，您必须正确配置<code class="fe lb lc ld le b">ExpanderRow</code>:</p><pre class="lz ma mb mc gt me le mf mg aw mh bi"><span id="b4b2" class="lf lg iq le b gy mi mj l mk ml">template.list_box.bind_model(Some(&amp;selection_model), |x| {<br/>  let title: String = x.property("title");<br/>  let summary: String = x.property("summary");</span><span id="a8fb" class="lf lg iq le b gy mm mj l mk ml">  let expander_content = &amp;Label::builder()<br/>    .label(&amp;summary)<br/>    .halign(Align::Start)<br/>    .margin_top(24)<br/>    .margin_bottom(24)<br/>    .margin_start(12)<br/>    .margin_end(12)<br/>    .build();<br/>  let expander_content_widget = expander_content<br/>    .ancestor(Widget::static_type());</span><span id="42a7" class="lf lg iq le b gy mm mj l mk ml">  let expander_row = ExpanderRow::builder().title(&amp;title).build();<br/>  let expander_row_widget = expander_row<br/>    .ancestor(Widget::static_type());</span><span id="fe80" class="lf lg iq le b gy mm mj l mk ml">  expander_row.add_row(&amp;expander_content_widget.unwrap());<br/>  expander_row_widget.unwrap()<br/>});</span></pre><p id="bb09" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你看一下<code class="fe lb lc ld le b">article-list.ui</code>，标签对象的所有属性都来自我们的模板。然后我们有对<code class="fe lb lc ld le b">expander_row</code>的额外<code class="fe lb lc ld le b">add_row</code>调用，它将<code class="fe lb lc ld le b">Label</code>添加为扩展子节点。</p></div><div class="ab cl mo mp hu mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ij ik il im in"><p id="a0b1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是另一篇文章的结尾。和往常一样，代码在 github 上，可以随时查看。也可以在评论区随意提问，尤其是当你发现文章缺乏解释的时候。谢谢你和我一起学习这个教程。只多了两个部分:<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/event-handling-for-gtk4-widgets-in-rust-d3c3f89b092f">处理点击事件</a>和读取实际的 RSS 数据。下次见！</p></div></div>    
</body>
</html>