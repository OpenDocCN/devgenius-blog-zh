<html>
<head>
<title>Power Set Algorithm with Recursion or Bits</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">递归或位幂集算法</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/power-set-algorithm-with-recursion-or-bits-cc3ffcfc0daa?source=collection_archive---------2-----------------------#2020-09-24">https://blog.devgenius.io/power-set-algorithm-with-recursion-or-bits-cc3ffcfc0daa?source=collection_archive---------2-----------------------#2020-09-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/322ec85d21ed0e87140c6c7fa482afba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*0nYzSI66v0Cng7BreoOJgA.jpeg"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated"><a class="ae jy" href="http://clipart-library.com/clipart/182935.htm" rel="noopener ugc nofollow" target="_blank">http://clipart-library.com/clipart/182935.htm</a></figcaption></figure><h1 id="1563" class="jz ka iq bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">什么是动力集？</h1><p id="8102" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">一个<a class="ae jy" href="https://www.mathsisfun.com/sets/power-set.html" rel="noopener ugc nofollow" target="_blank">幂集</a>是一个集合的所有子集的集合，包括空集和集合本身。JavaScript中的一个<a class="ae jy" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set" rel="noopener ugc nofollow" target="_blank">集合</a>是值的集合。集合中的一个值只能出现一次(没有重复的值)；它在该系列中独一无二。对于一个给定的集合，一个幂集，我们可以有不同的方式来选择值，包括选择无或全部。电源集解决方案不得包含重复的子集。</p><p id="a57c" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">对于集合{a，b，c}，下面列出了这个集合的幂集。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div class="gh gi ma"><img src="../Images/d9ba9b8be3557d843d84e7e8fb1e78fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:506/format:webp/1*vPO0MqYip6RAstQ9nCi-8A.png"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated"><a class="ae jy" href="https://www.mathsisfun.com/sets/power-set.html" rel="noopener ugc nofollow" target="_blank">https://www.mathsisfun.com/sets/power-set.html</a></figcaption></figure><h1 id="f754" class="jz ka iq bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">幂集中有多少个子集？</h1><p id="33cc" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">有n个元素的集合有2^n子集。在我们的例子中，集合{a，b，c}有3个元素，因此这个集合应该有2 = 8个子集。</p><p id="5765" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">让我们考虑一个有n个元素的集合{__，__，__，__ … __}。为了创建可能为空的每个子集，我们遍历集合中的每个值，并选择每个值为不存在或存在。因此，每个元素有两个选项，放入或不放入。可能的子集总数为:</p><p id="c240" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">2 * 2 *……* 2 = 2 ^ n</p><p id="473f" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">因为集合中的每个值可以存在于子集中，也可以不存在，所以可以使用二进制数(位！因为它既可以不存在<strong class="kz ir"> 0 </strong>也可以存在<strong class="kz ir"> 1 </strong> —我喜欢把它想象成打开或关闭一个电灯开关，无论那个值是打开还是关闭)。我们稍后将讨论这个问题。让我们从另一个直观的解决方案开始。</p><h1 id="cfd1" class="jz ka iq bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">递归</h1><p id="6960" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">想法是一样的，如果集合中有n个元素，每个元素有两个选择，要么包含在子集中，要么不包含在子集中。有了这个想法，我们可以形成一个递归的解决方案。</p><p id="1d93" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">这是一种回溯方法。递归函数有两个参数，一个子集字符串和当前索引。有一个外部结果数组存储创建的每个子集。输入字符串被循环，一个接一个的固定字符被添加到每个子集并递归。这将从前一个子集开始生成所有子集。如果当前索引等于输入的长度或大小，则不需要迭代，递归结束。随着每个子集的创建，结果数组不断更新。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi mf"><img src="../Images/a4becc1f0a23679480a96bef5ac4c8cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*stMWsSt0Es4ciJ-GmPc_Dg.png"/></div></div></figure><pre class="mb mc md me gt mk ml mm mn aw mo bi"><span id="9b11" class="mp ka iq ml b gy mq mr l ms mt">var powerSet = function (str) {<br/>  let results = [];</span><span id="8c61" class="mp ka iq ml b gy mu mr l ms mt">  let findSubSets = (string, index) =&gt; {<br/>    results.push(string);<br/>    for (let i = index; i &lt; str.length; i++) {<br/>      helper(string + str[i], i + 1);<br/>    }<br/>  };</span><span id="5494" class="mp ka iq ml b gy mu mr l ms mt">  findSubSets("", 0);<br/>  return results;<br/>};</span><span id="9db5" class="mp ka iq ml b gy mu mr l ms mt">powerSet('abc'); // ['', 'a',  'ab', 'abc', 'ac', 'b', 'bc', 'c']</span></pre><p id="02a8" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">这个解决方案的时间复杂度是O(2^n).</p><h1 id="5973" class="jz ka iq bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">用二进制位掩码映射</h1><p id="d7c5" class="pw-post-body-paragraph kx ky iq kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated">可以通过生成0到2^n-1之间的二进制数来找到幂集，其中n是给定集合的大小。当序列中有“1”时，这意味着将相应的值放入该子集。</p><pre class="mb mc md me gt mk ml mm mn aw mo bi"><span id="de3d" class="mp ka iq ml b gy mq mr l ms mt">a b c<br/>1 1 1  // 'abc'</span><span id="9f8c" class="mp ka iq ml b gy mu mr l ms mt">a b c<br/>1 0 1 // 'ac'</span></pre><p id="c1a7" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">参见下面的例子，如果有“110”，则用1个<strong class="kz ir"> a </strong>，1个<strong class="kz ir"> b </strong>和0个<strong class="kz ir"> c </strong>来替换，从而得到子集{a，b}。对于全零，这对应于一个空集，而全一对应于整个输入集。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi mv"><img src="../Images/4569fdb6039a693d73c538e2e2736a48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9AQE11XRbb3J3KrIq5URjA.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated"><a class="ae jy" href="https://www.mathsisfun.com/sets/power-set.html" rel="noopener ugc nofollow" target="_blank">https://www.mathsisfun.com/sets/power-set.html</a></figcaption></figure><p id="7521" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">使用逐位运算符，我们可以在二进制级别上进行运算。使用&lt;&lt; zero fill left shift operator, this operator will push in one or more zeros from the right and the left most bits fall off. The following fun with bits will get us the power set size. The power set can be though of counting from 0 unit 2^n-1.</p><pre class="mb mc md me gt mk ml mm mn aw mo bi"><span id="33fe" class="mp ka iq ml b gy mq mr l ms mt">1 &lt;&lt; str.length // is equivalent to 2^n</span><span id="7669" class="mp ka iq ml b gy mu mr l ms mt">ex. str = 'abc'<br/>1 &lt;&lt; str.length<br/>1 &lt;&lt; 3 = 8 // 8 in binary is 1000 (3 zeros pushed in from right)<br/>2^n = 2^3 = 8 // Power Set size</span></pre><p id="93dc" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">With the power set size known, we can use the Bitwise AND (<strong class="kz ir"> &amp; ) </strong>运算符。仅当两位都为1时，按位AND才返回1。</p><p id="8ee8" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi">0 &amp; 0 = 0</p><p id="0a1f" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi">0 &amp; 1 = 0</p><p id="88ef" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi">1 &amp; 0 = 0</p><p id="22b7" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi">1 &amp; 1 = 1</p><p id="091d" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">按位AND let 's映射所有子集并返回幂集。</p><p id="02f6" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">下表显示了从0到2^n-1的映射(i =外环)。每个二进制集合都有一个针对字符串0到n的索引位置的按位AND运算(我们的内部循环)。内部循环对于找出当前迭代计数中的每个二进制数字是必要的。如果这个AND运算的结果是“1 ”,那么相应的字母将放在它的位置上，并作为一个子集添加。</p><p id="71f7" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">下表显示了<strong class="kz ir">(I-幂集大小)</strong>外循环和我们的内循环<strong class="kz ir">(j-输入大小)</strong>以及如何计算相应的位操作以确定是否将相应的字母添加到下一个子集中。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi mw"><img src="../Images/198ae8e22b3ad22967eeef7ab067db8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*owTaEcENGvUV6i0IMO6v7w.png"/></div></div></figure><pre class="mb mc md me gt mk ml mm mn aw mo bi"><span id="5ce8" class="mp ka iq ml b gy mq mr l ms mt">var powerSet = function (str) {<br/>  const results = [];</span><span id="eeb4" class="mp ka iq ml b gy mu mr l ms mt">  for (let i = 0; i &lt; 1 &lt;&lt; str.length; i++) {<br/>    let subset = "";<br/>    for (let j = 0; j &lt; str.length; j++) {<br/>      if (i &amp; (1 &lt;&lt; j)) {<br/>        subset += str[j];<br/>      }<br/>    }<br/>    results.push(subset);<br/>  }<br/>  return results;<br/>};</span></pre><p id="6674" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">时间复杂度为O(n * 2^n).这是一个很好的解决方案，因为它简化了思想，并验证了没有解决方案丢失，但时间复杂度比早期的递归解决方案慢。</p></div><div class="ab cl mx my hu mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="ij ik il im in"><p id="836a" class="pw-post-body-paragraph kx ky iq kz b la lv lc ld le lw lg lh li lx lk ll lm ly lo lp lq lz ls lt lu ij bi translated">希望这有助于理解如何用两种不同的方法解决幂集算法！</p></div></div>    
</body>
</html>