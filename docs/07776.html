<html>
<head>
<title>When Life Gives you Lemons: An Introduction to Linked Lists</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">当生活给你柠檬:链表介绍</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/when-life-gives-you-lemons-an-introduction-to-linked-lists-d45a42dc9b1e?source=collection_archive---------9-----------------------#2022-04-22">https://blog.devgenius.io/when-life-gives-you-lemons-an-introduction-to-linked-lists-d45a42dc9b1e?source=collection_archive---------9-----------------------#2022-04-22</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/7fb45519ad3aed6a6e79787351580cef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wSB69d5THizZSt-6MrBQ8g.png"/></div></div></figure><p id="152d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">渴望了解链表吗？你来对地方了——这篇文章是对<strong class="jx io">链表数据结构</strong>的介绍——它们是什么，它们与数组相比如何，以及如何在 JavaScript 中创建和操作它们。</p><h1 id="7bb8" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">什么是链表？</h1><p id="8d67" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">链表是一种线性数据结构，其中每个元素(节点)都存储了<strong class="jx io">数据</strong>和指向内存中下一个节点位置的方向(<strong class="jx io">指针</strong>或引用)。</p><p id="419e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">链表有三种不同的风格:</strong></p><ol class=""><li id="ce60" class="lw lx in jx b jy jz kc kd kg ly kk lz ko ma ks mb mc md me bi translated">单链表🍋</li><li id="7f46" class="lw lx in jx b jy mf kc mg kg mh kk mi ko mj ks mb mc md me bi translated">双向链表🍒</li><li id="941a" class="lw lx in jx b jy mf kc mg kg mh kk mi ko mj ks mb mc md me bi translated">循环链表🍑</li></ol><p id="fcae" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">这篇文章将关注单链表，</strong>但是你可以阅读更多关于双向链表和循环链表的内容🍒<a class="ae mk" href="https://www.geeksforgeeks.org/doubly-linked-list/" rel="noopener ugc nofollow" target="_blank">此处</a>🍒和🍑<a class="ae mk" href="https://www.geeksforgeeks.org/circular-linked-list/" rel="noopener ugc nofollow" target="_blank">此处</a>🍑。</p><figure class="mm mn mo mp gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ml"><img src="../Images/b63caf5fe157c7bf0531fb14ffde57e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Itn6QdSqFGiYJ76RZBZhUw.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">链表图的剖析</figcaption></figure><p id="38ac" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">链表中的<strong class="jx io">第一个节点</strong>称为<strong class="jx io">头</strong>，是链表的入口点。</p><p id="adef" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">链表中的最后一个节点<strong class="jx io">叫做<strong class="jx io">尾</strong>，它指向<strong class="jx io">空。</strong></strong></p><figure class="mm mn mo mp gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/7fb45519ad3aed6a6e79787351580cef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wSB69d5THizZSt-6MrBQ8g.png"/></div></div></figure><p id="02e8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">上图的链表有五个节点，每个节点存储数据(在本例中，是柠檬水配方的指令)和指向下一个节点位置的指针。</p><figure class="mm mn mo mp gt jo gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/8faaf08d6b165b72cb4bb885ff33b4e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*oW9hL1ai2Cv1_yQhPL-Uag.png"/></div></figure><h2 id="70d1" class="mv ku in bd kv mw mx dn kz my mz dp ld kg na nb lh kk nc nd ll ko ne nf lp ng bi translated"><strong class="ak">让我们根据柠檬水的配方创建一个简单的链表:</strong></h2><pre class="mm mn mo mp gt nh ni nj nk aw nl bi"><span id="c5ed" class="mv ku in ni b gy nm nn l no np">class Node {</span><span id="576c" class="mv ku in ni b gy nq nn l no np">   constructor(<em class="nr">data</em>, <em class="nr">next</em> = null) {</span><span id="007c" class="mv ku in ni b gy nq nn l no np"><em class="nr">     this</em>.data = <em class="nr">data</em>;</span><span id="58f7" class="mv ku in ni b gy nq nn l no np"><em class="nr">     this</em>.next = <em class="nr">next</em>;</span><span id="14ef" class="mv ku in ni b gy nq nn l no np">   }</span><span id="2752" class="mv ku in ni b gy nq nn l no np">}</span><span id="79fd" class="mv ku in ni b gy nq nn l no np">const step5 = <strong class="ni io">new</strong> <em class="nr">Node</em>("Serve Lemonade");</span><span id="f930" class="mv ku in ni b gy nq nn l no np">const step4 = <strong class="ni io">new</strong> <em class="nr">Node</em>("Mix with Water", step5);</span><span id="383e" class="mv ku in ni b gy nq nn l no np">const step3 = <strong class="ni io">new</strong> <em class="nr">Node</em>("Add Sugar", step4);</span><span id="8ae4" class="mv ku in ni b gy nq nn l no np">const step2 = <strong class="ni io">new</strong> <em class="nr">Node</em>("Squeeze Lemons", step3);</span><span id="2062" class="mv ku in ni b gy nq nn l no np">const step1 = <strong class="ni io">new</strong> <em class="nr">Node</em>("Life Gives Lemons", step2);</span></pre><p id="a0e7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">每个节点对象用两个属性实例化:<em class="nr">数据</em>，和<em class="nr">下一个</em> <strong class="jx io"> <em class="nr"> </em> </strong>(指针)。</p><p id="76ea" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果我们打印第一个节点，可以看到每个对象<strong class="jx io">的<em class="nr"> next </em>属性包含了</strong>链表中的后续节点(嵌套结构)。</p><figure class="mm mn mo mp gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ns"><img src="../Images/9fe1451effc7e4a0bd51cab0d844cb4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9hJuCBFTmXISp2Yf7tPeZg.png"/></div></div></figure><p id="bc74" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">注意最后一个(尾部)节点的 next 属性的值为<strong class="jx io"> null </strong>。食谱已经完成；没有更多的步骤！这意味着是时候放松一下，喝点柠檬水了😎🍹️.</p><h1 id="4824" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated"><strong class="ak">链表遍历</strong></h1><p id="0d3d" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated"><em class="nr">在制作食谱时，我们从头开始，每次都按照相同的顺序完成步骤——否则，我们可能会以一些漂亮的</em> <a class="ae mk" href="https://zelda.fandom.com/wiki/Dubious_Food" rel="noopener ugc nofollow" target="_blank"> <em class="nr">可疑的食物</em> </a> <em class="nr">而告终！</em>😱</p><p id="d689" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">像数组一样，我们可以遍历列表来访问每个节点的值:</p><pre class="mm mn mo mp gt nh ni nj nk aw nl bi"><span id="ceba" class="mv ku in ni b gy nm nn l no np">function makeLemonade() {</span><span id="3e36" class="mv ku in ni b gy nq nn l no np">  let step = step1;</span><span id="ae07" class="mv ku in ni b gy nq nn l no np">  while (step != null) {</span><span id="0145" class="mv ku in ni b gy nq nn l no np">   console.log(step.data);</span><span id="4f2f" class="mv ku in ni b gy nq nn l no np">   step = step.next;</span><span id="a699" class="mv ku in ni b gy nq nn l no np">  }</span><span id="95b0" class="mv ku in ni b gy nq nn l no np">}</span><span id="447a" class="mv ku in ni b gy nq nn l no np">makeLemonade();</span></pre><p id="2f1c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">运行上面的代码打印出每个节点的<em class="nr">数据</em>，从<strong class="jx io">头</strong>开始，到<strong class="jx io">尾</strong>结束</p><div class="mm mn mo mp gt ab cb"><figure class="nt jo nu nv nw nx ny paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><img src="../Images/b6f692e3064a1298596ee69ef51ba67d.png" data-original-src="https://miro.medium.com/v2/resize:fit:776/format:webp/1*6-T6UFdriiVC9hEi-gfQnQ.png"/></div></figure><figure class="nt jo nz nv nw nx ny paragraph-image"><img src="../Images/ea69a0c268a3e84475e0c8ed95b467db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1088/format:webp/1*jQtXvB9NTyUNdvSygSKSlQ.png"/><figcaption class="mq mr gj gh gi ms mt bd b be z dk oa di ob oc translated">日志打印输出包含每个节点的数据</figcaption></figure></div><figure class="mm mn mo mp gt jo"><div class="bz fp l di"><div class="od oe l"/></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">啊，真提神！</figcaption></figure><p id="9180" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">链表的缺点是我们必须从头部开始按顺序访问节点(不能随机访问节点)🙅🏻‍♀️).这使得搜索效率比数组低得多——如果你选择使用链表，就告别二进制搜索吧。</p><h1 id="d993" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">插入和删除节点</h1><p id="5339" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated"><em class="nr">介绍全新改良的✨strawberry 柠檬水 recipe✨！</em></p><figure class="mm mn mo mp gt jo gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/f2af7dae761dc2291221ca2571ff9461.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*zk0pyvJeWO86fxS5n0FYcA.png"/></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">真是一团糟！</figcaption></figure><p id="c4b9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在我试图在中间添加另一个步骤后，我的食谱(如上图)看起来不那么热门了——没有足够的空间来编写新的步骤，我必须重新编号后续步骤，看起来我必须从头开始重新编写整个东西。这就是当我们试图插入/删除数组时可能发生的情况——它可能需要完全重新组织内存中的数据结构。</p><p id="3958" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">与数组不同，链表节点存储在不连续的内存中(不都在同一个位置)，它们的长度在创建时没有定义。这使得链表成为一个很好的选择，如果你需要从你的数据集中进行插入/删除的话。</p><figure class="mm mn mo mp gt jo gh gi paragraph-image"><div class="gh gi of"><img src="../Images/d99946b056b4b8282eeee49c604120f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*OkZg5Rj-BZsDyOJ1vf8sVg.png"/></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">内存存储的可视化—数组和链表</figcaption></figure><p id="e0fc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">虽然链表确实比数组占用更多的内存(因为我们需要存储数据和一个指针，而不仅仅是数据)，但是链表的内存使用比数组更加<em class="nr">灵活</em>和<em class="nr">高效</em>。</p><p id="5917" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">链表在添加/删除节点方面也比数组有优势——我们需要做的只是添加数据并调整指针以适应我们的需要。这意味着我们可以很容易地在列表中的任何地方插入节点，而数组只允许在头部/尾部插入。</p><h2 id="9b88" class="mv ku in bd kv mw mx dn kz my mz dp ld kg na nb lh kk nc nd ll ko ne nf lp ng bi translated">🍓插入节点🍓</h2><p id="e706" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">我们开始喝草莓柠檬水吧，好吗？</p><p id="b87e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们需要给链表添加一些功能——让我们从创建一个名为<code class="fe og oh oi ni b">LinkedList</code>的新类开始，它包含了我们与链表对象交互所需的所有方法。</p><pre class="mm mn mo mp gt nh ni nj nk aw nl bi"><span id="cb4b" class="mv ku in ni b gy nm nn l no np">class LinkedList {</span><span id="7ab6" class="mv ku in ni b gy nq nn l no np">   constructor() {</span><span id="4fb7" class="mv ku in ni b gy nq nn l no np"><em class="nr">   this</em>.head = null</span><span id="092f" class="mv ku in ni b gy nq nn l no np">}</span></pre><p id="263c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">LinkedList 对象将使用 head 属性进行实例化，该属性保存 head 节点对象(在这种情况下，还没有节点被添加到链表中，因此值为 null)。</p><p id="b608" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">接下来，我将定义一个带两个参数的方法:将在新节点之前到达的节点(也称为前一个节点)和新节点的数据。</p><pre class="mm mn mo mp gt nh ni nj nk aw nl bi"><span id="3ee4" class="mv ku in ni b gy nm nn l no np">insertAfter(<em class="nr">prevNode</em>, <em class="nr">data</em>) {</span><span id="9ecc" class="mv ku in ni b gy nq nn l no np">   const newNode = <strong class="ni io">new</strong> <em class="nr">Node</em>(<em class="nr">data</em>, <em class="nr">prevNode</em>.next);</span><span id="1212" class="mv ku in ni b gy nq nn l no np"><em class="nr">   prevNode</em>.next = newNode;</span><span id="c744" class="mv ku in ni b gy nq nn l no np">}</span></pre><p id="fbc4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这个函数中，我们将实例化一个新的节点对象，传入我们节点的数据和一个指针 previous node's <em class="nr"> next。</em></p><p id="0c2f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后我们将前一个节点的 next 设置为指向我们的新节点。</p><p id="6990" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后，我们将增加 LinkedList 对象的长度。</p><p id="7481" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">这是一大堆单词——看看下面的图片来帮助想象刚刚发生了什么:</strong></p><figure class="mm mn mo mp gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/6df19af01aa7abb91bede6b2048131de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M4vWcXGNIqjTYUY4aQr1og.png"/></div></div></figure><p id="eba2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果我们需要在链表的末尾添加一个步骤，我们可以简单地将空值传递给新节点的参数</p><p id="e2dd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果我们需要在链表的开头添加一个步骤呢？这个过程看起来有点不同:</p><pre class="mm mn mo mp gt nh ni nj nk aw nl bi"><span id="f690" class="mv ku in ni b gy nm nn l no np">insertAtBeginning(<em class="nr">data</em>) {</span><span id="f795" class="mv ku in ni b gy nq nn l no np">   const newNode = <strong class="ni io">new</strong> <em class="nr">Node</em>(<em class="nr">data</em>, <em class="nr">this</em>.head);</span><span id="307d" class="mv ku in ni b gy nq nn l no np"><em class="nr">   this</em>.head = newNode;</span><span id="b7af" class="mv ku in ni b gy nq nn l no np">}</span></pre><p id="9449" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您会注意到这个方法只有一个参数，而不是两个，因为在这种情况下没有前一个节点。</p><p id="92a7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后我们将我们的新节点的下一个设置为当前的头节点，然后将我们的新节点设置为链表的头节点。</p><h2 id="418e" class="mv ku in bd kv mw mx dn kz my mz dp ld kg na nb lh kk nc nd ll ko ne nf lp ng bi translated">🦷删除节点🦷</h2><p id="7774" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated"><em class="nr">此时，你可能会想“我们在柠檬水里加糖和草莓糖浆？？你没听说过龋齿吗？!"</em></p><p id="e307" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="nr">我也很重视我的口腔健康——我们最好省去“加糖”这一步</em></p><p id="a144" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">要从链表中删除一个节点，我们需要:</strong> <br/> 1。找到目标节点及其前一个节点(如果有！)<br/> 2。改变前一个节点的下一个以绕过目标节点<br/> 3。从内存中删除目标节点</p><p id="8ebb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们将使用 LinkedList 类中的另一个方法来解决这个问题——这个方法将接受一个表示我们要删除的节点的数据<em class="nr">的参数。</em></p><p id="8df2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">看一下代码，我们将讨论下面的步骤。</p><pre class="mm mn mo mp gt nh ni nj nk aw nl bi"><span id="4105" class="mv ku in ni b gy nm nn l no np">removeValue(<em class="nr">value</em>) {</span><span id="1e38" class="mv ku in ni b gy nq nn l no np">   let prevNode = null;</span><span id="1e08" class="mv ku in ni b gy nq nn l no np">   let currentNode = <em class="nr">this</em>.head;</span><span id="8700" class="mv ku in ni b gy nq nn l no np">   while (currentNode) {</span><span id="955a" class="mv ku in ni b gy nq nn l no np">     if (currentNode.data === <em class="nr">value</em>) {</span><span id="b900" class="mv ku in ni b gy nq nn l no np">       if (prevNode) {</span><span id="c0fd" class="mv ku in ni b gy nq nn l no np">         prevNode.next = currentNode.next;</span><span id="2ad3" class="mv ku in ni b gy nq nn l no np">       } else {</span><span id="7f9f" class="mv ku in ni b gy nq nn l no np"><em class="nr">         this</em>.head = currentNode.next;</span><span id="fa99" class="mv ku in ni b gy nq nn l no np">        }</span><span id="0542" class="mv ku in ni b gy nq nn l no np">       currentNode = null;</span><span id="f4f5" class="mv ku in ni b gy nq nn l no np">       return true</span><span id="98ad" class="mv ku in ni b gy nq nn l no np">     }</span><span id="b810" class="mv ku in ni b gy nq nn l no np">  prevNode = currentNode;</span><span id="22fe" class="mv ku in ni b gy nq nn l no np">  currentNode = currentNode.next;</span><span id="7185" class="mv ku in ni b gy nq nn l no np">  }</span><span id="f93d" class="mv ku in ni b gy nq nn l no np">}</span></pre><p id="0d6f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们首先为当前节点和前一个节点定义变量——我们稍后会用到这两个变量。</p><p id="5881" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">从头开始，我们遍历链表。当当前节点的值等于我们正在搜索的值时，我们或者:</p><ol class=""><li id="87a5" class="lw lx in jx b jy jz kc kd kg ly kk lz ko ma ks mb mc md me bi translated">设置前一个节点的<em class="nr"> next </em>指向当前节点的<em class="nr"> next </em></li><li id="c1e7" class="lw lx in jx b jy mf kc mg kg mh kk mi ko mj ks mb mc md me bi translated">如果当前节点是头部，我们将头部设置为当前节点的<em class="nr">的下一个</em></li></ol><p id="50a0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后我们删除当前节点并退出循环。</p><p id="93fa" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">又来了，很多话。这里有一个视觉:</strong></p><figure class="mm mn mo mp gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/bd45e815bd47d0b59b9428a59257a64e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*diPk8KTy9PLswzgeS2xIlw.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">从链表中删除节点的可视化</figcaption></figure><h1 id="1f09" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">其他有用的方法</h1><p id="a94e" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">这里还有一些方法可以添加到您的链表工具包中:</p><h2 id="cbde" class="mv ku in bd kv mw mx dn kz my mz dp ld kg na nb lh kk nc nd ll ko ne nf lp ng bi translated">移除所有节点</h2><pre class="mm mn mo mp gt nh ni nj nk aw nl bi"><span id="6039" class="mv ku in ni b gy nm nn l no np">clearList(){</span><span id="abca" class="mv ku in ni b gy nq nn l no np"><em class="nr">  this</em>.head = null;</span><span id="4c45" class="mv ku in ni b gy nq nn l no np">}</span></pre><h2 id="90c3" class="mv ku in bd kv mw mx dn kz my mz dp ld kg na nb lh kk nc nd ll ko ne nf lp ng bi translated">返回节点的索引</h2><pre class="mm mn mo mp gt nh ni nj nk aw nl bi"><span id="eea8" class="mv ku in ni b gy nm nn l no np">findIndex(data) {</span><span id="598e" class="mv ku in ni b gy nq nn l no np">   let index = 0;</span><span id="2d35" class="mv ku in ni b gy nq nn l no np">   let currentNode = <em class="nr">this</em>.head;</span><span id="c970" class="mv ku in ni b gy nq nn l no np">   while (currentNode) {</span><span id="b28e" class="mv ku in ni b gy nq nn l no np">     if (currentNode.data === data) return index;</span><span id="7acc" class="mv ku in ni b gy nq nn l no np">     node = node.next;</span><span id="e4ce" class="mv ku in ni b gy nq nn l no np">     index += 1;</span><span id="8832" class="mv ku in ni b gy nq nn l no np">   }</span><span id="8e18" class="mv ku in ni b gy nq nn l no np">}</span></pre><h2 id="0631" class="mv ku in bd kv mw mx dn kz my mz dp ld kg na nb lh kk nc nd ll ko ne nf lp ng bi translated">返回第一个节点</h2><pre class="mm mn mo mp gt nh ni nj nk aw nl bi"><span id="c3eb" class="mv ku in ni b gy nm nn l no np">getFirst() {</span><span id="e8de" class="mv ku in ni b gy nq nn l no np">  return <em class="nr">this</em>.head;</span><span id="84cd" class="mv ku in ni b gy nq nn l no np">}</span></pre><h2 id="b779" class="mv ku in bd kv mw mx dn kz my mz dp ld kg na nb lh kk nc nd ll ko ne nf lp ng bi translated">返回最后一个节点</h2><pre class="mm mn mo mp gt nh ni nj nk aw nl bi"><span id="451f" class="mv ku in ni b gy nm nn l no np">getLast() {</span><span id="7ddf" class="mv ku in ni b gy nq nn l no np"> let lastNode = <em class="nr">this</em>.head;</span><span id="d155" class="mv ku in ni b gy nq nn l no np">    if (lastNode) {</span><span id="d88f" class="mv ku in ni b gy nq nn l no np">      while (lastNode.next) {</span><span id="2404" class="mv ku in ni b gy nq nn l no np">       lastNode = lastNode.next;</span><span id="dd81" class="mv ku in ni b gy nq nn l no np">      }<br/>  }</span><span id="42a3" class="mv ku in ni b gy nq nn l no np">  return lastNode;</span><span id="d1bb" class="mv ku in ni b gy nq nn l no np">}</span></pre><h2 id="78e0" class="mv ku in bd kv mw mx dn kz my mz dp ld kg na nb lh kk nc nd ll ko ne nf lp ng bi translated">求链表的长度</h2><pre class="mm mn mo mp gt nh ni nj nk aw nl bi"><span id="d41a" class="mv ku in ni b gy nm nn l no np">listLength() {</span><span id="85c5" class="mv ku in ni b gy nq nn l no np">   let currentNode = head;<br/>   let length = 0;</span><span id="19b5" class="mv ku in ni b gy nq nn l no np">   while<!-- --> <!-- -->(currentNode !== null) {</span><span id="b4fd" class="mv ku in ni b gy nq nn l no np">    length++;</span><span id="1ff1" class="mv ku in ni b gy nq nn l no np">    currentNode = currentNode.next;</span><span id="0d6e" class="mv ku in ni b gy nq nn l no np">   }</span><span id="16d5" class="mv ku in ni b gy nq nn l no np"><strong class="ni io">  </strong>return<!-- --> length<!-- -->;</span><span id="bac5" class="mv ku in ni b gy nq nn l no np">}</span></pre><h1 id="1286" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">摘要</h1><ul class=""><li id="a62f" class="lw lx in jx b jy lr kc ls kg oj kk ok ko ol ks om mc md me bi translated">链表是由非连续存储的节点组成的<strong class="jx io">线性数据结构</strong></li><li id="0f13" class="lw lx in jx b jy mf kc mg kg mh kk mi ko mj ks om mc md me bi translated">每个节点包含<strong class="jx io">数据+指向下一个节点的指针</strong></li><li id="1f42" class="lw lx in jx b jy mf kc mg kg mh kk mi ko mj ks om mc md me bi translated">与数组相比，链表允许更加灵活和有效的内存使用</li><li id="6a9b" class="lw lx in jx b jy mf kc mg kg mh kk mi ko mj ks om mc md me bi translated">与数组相比，链表添加/删除节点要容易得多</li></ul><p id="8ba3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在你知道为什么链表仅仅是热情的表现了，希望在你下一次编码面试中出现时，你会更有信心！</p><figure class="mm mn mo mp gt jo"><div class="bz fp l di"><div class="on oe l"/></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">感谢阅读！</figcaption></figure><h1 id="db4e" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">参考</h1><ul class=""><li id="687a" class="lw lx in jx b jy lr kc ls kg oj kk ok ko ol ks om mc md me bi translated">阿里·斯皮特尔，<a class="ae mk" href="https://dev.to/aspittel/thank-u-next-an-introduction-to-linked-lists-4pph" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io">谢谢你，下一篇:链表介绍</strong> </a></li><li id="c549" class="lw lx in jx b jy mf kc mg kg mh kk mi ko mj ks om mc md me bi translated">比尔·沃特斯，<a class="ae mk" href="https://medium.com/swlh/beginners-guide-to-the-linked-list-data-structure-in-nodejs-dcf8d2f655e2" rel="noopener"><strong class="jx io">Nodejs 中的链表数据结构入门</strong> </a></li><li id="3e92" class="lw lx in jx b jy mf kc mg kg mh kk mi ko mj ks om mc md me bi translated">极客为极客，<a class="ae mk" href="https://www.geeksforgeeks.org/data-structures/linked-list/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io">链表数据结构</strong> </a></li><li id="5ae3" class="lw lx in jx b jy mf kc mg kg mh kk mi ko mj ks om mc md me bi translated">莎拉·奇马·阿东沃，<a class="ae mk" href="https://www.freecodecamp.org/news/implementing-a-linked-list-in-javascript/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io">如何在 Javascript 中实现一个链表</strong> </a></li><li id="1d3d" class="lw lx in jx b jy mf kc mg kg mh kk mi ko mj ks om mc md me bi translated">Shubhangi Raj Atrawal，<a class="ae mk" href="https://codeburst.io/linked-lists-in-javascript-es6-code-part-1-6dd349c3dcc3" rel="noopener" target="_blank"><strong class="jx io">JavaScript 中的链表(ES6 代码)</strong> </a></li></ul></div></div>    
</body>
</html>