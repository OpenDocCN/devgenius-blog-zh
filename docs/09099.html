<html>
<head>
<title>Getting Started with Code Coverage: Using CodeCov</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">代码覆盖率入门:使用 CodeCov</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/getting-started-with-code-coverage-using-codecov-b40f4fe1c91c?source=collection_archive---------11-----------------------#2022-07-29">https://blog.devgenius.io/getting-started-with-code-coverage-using-codecov-b40f4fe1c91c?source=collection_archive---------11-----------------------#2022-07-29</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="37e8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">100%的代码覆盖率是可靠性和代码质量的衡量标准吗？</p><p id="94f8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">好吧，我本来没打算回答这个问题，但无论如何我会的。然而，在这篇文章中，我将主要带你了解如何利用一个叫做<strong class="jm io"> CodeCov </strong>的工具。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi kj"><img src="../Images/aba585f1ea616b09737fe6ea240c7169.png" data-original-src="https://miro.medium.com/v2/resize:fit:832/format:webp/1*ept-BaRlCuf2seDvvnosNw.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://codecov.io/" rel="noopener ugc nofollow" target="_blank"> CodeCov.io </a></figcaption></figure><p id="ae54" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">CodeCov 是一个覆盖解决方案平台，允许你可视化你的代码覆盖报告。CodeCov 提供了深入的覆盖率见解，并计算每个文件的命中率。它很容易与 GitHub 和 GitLab 集成。CodeCov 还同步所有的存储库(公共的和私有的)。当然，您必须在第一次手动将 CodeCov 安装到您的存储库中，我将在下面带您了解这一点。</p><p id="2fb1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是首先:</p><blockquote class="kw kx ky"><p id="e067" class="jk jl ki jm b jn jo jp jq jr js jt ju kz jw jx jy la ka kb kc lb ke kf kg kh ig bi translated">较高的代码覆盖率是否意味着可靠且经过测试的代码库？</p></blockquote><p id="da68" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在我看来，一个<strong class="jm io"> <em class="ki">高的</em> </strong>覆盖率意味着覆盖率报告的入口点已经达到了代码行的最高命中率。通过<em class="ki">入口点</em>，我指的是您用来运行一个覆盖报告的指令集。在大多数情况下，<strong class="jm io">测试</strong>是大多数覆盖率报告的入口点。测试是用来尝试模拟一个执行代码库的环境。因此，代码覆盖率的百分比越高，就表示您的入口点命中了大量的代码行。它衡量的是可靠性、安全性还是兼容性？不一定——这是了解代码库测试覆盖范围的一个指标。因此，让我们设置 codecov 并把事情放在正确的位置。</p></div><div class="ab cl lc ld hr le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ig ih ii ij ik"><h1 id="edd1" class="lj lk in bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">入门指南</h1><p id="ee17" class="pw-post-body-paragraph jk jl in jm b jn mh jp jq jr mi jt ju jv mj jx jy jz mk kb kc kd ml kf kg kh ig bi translated">假设您有一个正在进行的项目，其中有您想要可视化的单元测试。可视化描述了单元测试实际命中了多少代码行。在这个例子中，我将使用<strong class="jm io"> Python </strong>和两个主库，<a class="ae kv" href="https://pypi.org/project/coverage/" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> Coverage </strong> </a>和<a class="ae kv" href="https://pypi.org/project/codecov/" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> CodeCov </strong> </a>。为了使这更容易，我也将使用这个<a class="ae kv" href="https://github.com/ibrahimroshdy/continuous_integration" rel="noopener ugc nofollow" target="_blank">示例项目</a>，我建议在此之前阅读下面的这篇文章。</p><div class="mm mn gp gr mo mp"><a rel="noopener  ugc nofollow" target="_blank" href="/continuous-integration-github-1130217cc2e9"><div class="mq ab fo"><div class="mr ab ms cl cj mt"><h2 class="bd io gy z fp mu fr fs mv fu fw im bi translated">使用 GitHub 快速设置持续集成</h2><div class="mw l"><h3 class="bd b gy z fp mu fr fs mv fu fw dk translated">在 GitHub 上使用持续集成之前你需要知道的所有事情。这是你使用 GitHub 的指南…</h3></div><div class="mx l"><p class="bd b dl z fp mu fr fs mv fu fw dk translated">blog.devgenius.io</p></div></div><div class="my l"><div class="mz l na nb nc my nd kp mp"/></div></div></a></div><p id="545c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">CodeCov 可视化和洞察力可以自动化到您的开发过程中。然而，您将需要持续的集成管道来自动生成您的覆盖报告并将它们上传到 CodeCov——并且还包括一个覆盖徽章。</p><h2 id="692b" class="ne lk in bd ll nf ng dn lp nh ni dp lt jv nj nk lx jz nl nm mb kd nn no mf np bi translated">要求</h2><ol class=""><li id="95e4" class="nq nr in jm b jn mh jr mi jv ns jz nt kd nu kh nv nw nx ny bi translated">现有的 GitHub 存储库</li><li id="e642" class="nq nr in jm b jn nz jr oa jv ob jz oc kd od kh nv nw nx ny bi translated">CodeCov 帐户</li></ol><p id="89f3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用上面的<a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/continuous-integration-github-1130217cc2e9">文章</a>中提到的<a class="ae kv" href="https://github.com/ibrahimroshdy/continuous_integration" rel="noopener ugc nofollow" target="_blank">持续集成</a>回购，我将写下将 CodeCov 集成到回购上的步骤。</p><h2 id="a09d" class="ne lk in bd ll nf ng dn lp nh ni dp lt jv nj nk lx jz nl nm mb kd nn no mf np bi translated">覆盖范围演练</h2><p id="0bf3" class="pw-post-body-paragraph jk jl in jm b jn mh jp jq jr mi jt ju jv mj jx jy jz mk kb kc kd ml kf kg kh ig bi translated">添加使用诗歌所需的两个主要 python 库，(当然你可以使用 pip，但是你真的应该检查一下<a class="ae kv" href="https://python-poetry.org/" rel="noopener ugc nofollow" target="_blank">诗歌</a>)</p><pre class="kk kl km kn gt oe of og oh aw oi bi"><span id="7571" class="ne lk in of b gy oj ok l ol om">poetry add coverage codecov</span></pre><p id="48a9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后使用<code class="fe on oo op of b">coverage</code>我现在将运行<code class="fe on oo op of b">simple_loop.py</code></p><pre class="kk kl km kn gt oe of og oh aw oi bi"><span id="bafc" class="ne lk in of b gy oj ok l ol om">coverage run simple_loop.py</span></pre><p id="3b57" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ki">"</em><a class="ae kv" href="https://pypi.org/project/coverage/" rel="noopener ugc nofollow" target="_blank"><em class="ki">coverage . py</em></a><em class="ki">测量代码覆盖率，通常在测试执行期间。它使用 Python 标准库中提供的代码分析工具和跟踪挂钩来确定哪些行是可执行的，哪些行已经被执行了。”</em></p><p id="0359" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这会生成一系列将由 CodeCov 使用的文件。</p><p id="933a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">要创建 CodeCov 帐户，请访问<a class="ae kv" href="https://about.codecov.io/" rel="noopener ugc nofollow" target="_blank"> CodeCov.io </a>并使用<a class="ae kv" href="https://app.codecov.io/login/gh?utm_department=marketing&amp;utm_source=direct" rel="noopener ugc nofollow" target="_blank"> GitHub </a>登录。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="or os di ot bf ou"><div class="gh gi oq"><img src="../Images/09e13fa2e7505d64ff340ab6df4e6116.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PqaGMmWDehHMWp836YM2eQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">图 1:用 GitHub 登录 CodeCov.io</figcaption></figure><p id="52a8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">登录后，您需要手动设置需要 CodeCov 使用的 repo。我已经使用图 2 右上方的<strong class="jm io"> <em class="ki">未设置</em> </strong>按钮完成了这一步。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="or os di ot bf ou"><div class="gh gi ov"><img src="../Images/ee3736a83add5ccb56928975e63ec22c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0Y7saR2YS-jvC-S1r_TQgw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">图二。CodeCov 上的持续集成报告</figcaption></figure><p id="83f6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以现在，我指示 CodeCov 设置一个令牌，并允许从我的 GitHub 帐户集成，特别是回购。只要您单击 CodeCov.io Repo 部分中的项目链接，就可以获得这些信息，您将看到类似下面图 3 中的内容。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="or os di ot bf ou"><div class="gh gi ow"><img src="../Images/a4b234c02b319e8b0231a295db55459b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*osxglrJWM1sR0hMhd3CI-A.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">图 3: CodeCov 设置[令牌]</figcaption></figure><p id="5af5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">回到项目，现在可以使用<code class="fe on oo op of b">codecov</code>库上传提交文件，并使用<code class="fe on oo op of b">codecov_token</code>指定项目。沿着图 3 中的红线找到您的<em class="ki">令牌。</em></p><pre class="kk kl km kn gt oe of og oh aw oi bi"><span id="4455" class="ne lk in of b gy oj ok l ol om">codecov --token={codecode_token}</span></pre></div><div class="ab cl lc ld hr le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ig ih ii ij ik"><h1 id="fa67" class="lj lk in bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">带有 GitHub 工作流的 CodeCov</h1><p id="4999" class="pw-post-body-paragraph jk jl in jm b jn mh jp jq jr mi jt ju jv mj jx jy jz mk kb kc kd ml kf kg kh ig bi translated">嗯，你不应该在本地手动运行<code class="fe on oo op of b">coverage</code>和<code class="fe on oo op of b">codecov</code>，记住这应该在你的管道或者工作流中的测试用例上运行。因此，这应该被集成到您的测试管道或者您的持续集成工作流程中的测试阶段。以<strong class="jm io"> GitHub </strong>工作流为例，我将创建一个定制的工作流文件，其中包含一个运行 coverage 和 codecov 的作业。</p><p id="0cd0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">首先，您需要将该令牌作为存储库秘密存储在 GitHub 存储库设置中的“操作”下的“秘密”下。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="or os di ot bf ou"><div class="gh gi ox"><img src="../Images/2c6c12292b49e4776257783f0cc9eb1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Msbn2RKrPmtmSX8Kq9e7MA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">图 4: GitHub 回购操作秘密</figcaption></figure><p id="7db5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">其次，添加一个运行 coverage 和 codecov 命令的工作流作业。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="oy oz l"/></div></figure><p id="fc1d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最后，现在每个推送都会触发一个名为<a class="ae kv" href="https://github.com/ibrahimroshdy/continuous_integration/actions/workflows/codecov.yml" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io">代码覆盖【Code cov】</strong></a><strong class="jm io"/>的工作流，该工作流只负责使用<code class="fe on oo op of b">coverage</code>运行<code class="fe on oo op of b">simple_loop.py</code> python 文件，并使用图 4 中的秘密令牌将覆盖数据上传到 CodeCov.io。点击查看<code class="fe on oo op of b">continuous_integration</code>回购<a class="ae kv" href="https://app.codecov.io/gh/ibrahimroshdy/continuous_integration" rel="noopener ugc nofollow" target="_blank">的 codecov 公开报告。</a></p><h2 id="f064" class="ne lk in bd ll nf ng dn lp nh ni dp lt jv nj nk lx jz nl nm mb kd nn no mf np bi translated">覆盖率作为衡量标准</h2><p id="b03b" class="pw-post-body-paragraph jk jl in jm b jn mh jp jq jr mi jt ju jv mj jx jy jz mk kb kc kd ml kf kg kh ig bi translated">让我们以<code class="fe on oo op of b">simple_loop.py</code>上的报道为例来理解到底发生了什么。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="oy oz l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">100%覆盖率 simple_loop.py</figcaption></figure><p id="879c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">运行<code class="fe on oo op of b">coverage run simple_loop.py</code>将执行 python 脚本，从第 4 行的导入开始，然后是 main 函数，最后用<code class="fe on oo op of b">simple_loop_func(1000000)</code>函数调用最后一行。从技术上来说，代码行的覆盖率是 100%。为了了解这个<em class="ki">值</em>是如何减少的，我添加了另一个函数，目的是被忽略。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="oy oz l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">88.89%覆盖率 simple_loop.py</figcaption></figure><p id="da7f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">嗯，<code class="fe on oo op of b">simple_loop.py</code>包含两个功能。一个功能<code class="fe on oo op of b">simple_loop_func(number)</code>打印出一个进度条，另一个用于忽略功能<code class="fe on oo op of b">__ignored_func()</code>。不调用<code class="fe on oo op of b">__ignored_func()</code>的函数不会降低覆盖率的命中率，codecov 上的结果看起来会像<a class="ae kv" href="https://app.codecov.io/gh/ibrahimroshdy/continuous_integration/blob/main/simple_loop.py" rel="noopener ugc nofollow" target="_blank">中的</a>:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="or os di ot bf ou"><div class="gh gi pa"><img src="../Images/801f57f912294271f751d7d90ac12e55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VMUazHZvW1LLqy7S6fJk3A.png"/></div></div></figure><blockquote class="pb"><p id="4124" class="pc pd in bd pe pf pg ph pi pj pk kh dk translated">现在你可以试着回答这个问题:" 100%的代码覆盖率是衡量可靠性和代码质量的标准吗？”。</p></blockquote><p id="eca8" class="pw-post-body-paragraph jk jl in jm b jn pm jp jq jr pn jt ju jv po jx jy jz pp kb kc kd pq kf kg kh ig bi translated">使用覆盖库调用直接脚本的唯一意图是复制一个测试单元或一系列测试指令的行为。CodeCov 为多达 5 个用户提供了一个免费的包，它还提供了一个徽章，上面有你的覆盖率和你的文件的 SVG 图。</p><h1 id="786f" class="lj lk in bd ll lm pr lo lp lq ps ls lt lu pt lw lx ly pu ma mb mc pv me mf mg bi translated">谢谢！</h1></div></div>    
</body>
</html>