<html>
<head>
<title>Who’s who?: real-time face recognition</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">谁是谁？:实时人脸识别</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/whos-who-real-time-face-recognition-241c7b69cff3?source=collection_archive---------12-----------------------#2022-07-06">https://blog.devgenius.io/whos-who-real-time-face-recognition-241c7b69cff3?source=collection_archive---------12-----------------------#2022-07-06</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="3003" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">如何将图像流导入 Deephaven IDE</h2></div><p id="6a6b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">杰里迈亚·程</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi ky"><img src="../Images/2d06d857873d594870ec6e2a3ab90b88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*awFTBebidHVkoEpZpiOrRg.jpeg"/></div></div></figure><p id="5f41" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">面部识别技术是一个强大的工具——计算机视觉可以通过扫描一个人的面部来识别他。每当你的手机识别朋友来帮助你整理照片时，或者如果你需要面部扫描来进入你的绝密实验室时，你都会遇到这种情况。更严重的是，面部识别技术为执法和监控专家提供了重要的用途。我们会把这个留给专业人士。</p><p id="2a88" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这篇博客中，我使用 Deephaven 强大的实时分析工具，在电影<em class="lk">复仇者联盟 4：终局之战</em>中实时实现了面部识别。我们将向您展示如何轻松地将数据吸收到一个平台中，在这个平台上，您可以即时操作、分析和学习这些数据。</p><p id="814a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">下面是我们如何做到的，通过三个简单的步骤:</p><ol class=""><li id="e7cd" class="ll lm in ke b kf kg ki kj kl ln kp lo kt lp kx lq lr ls lt bi translated">建立一个卡夫卡流。为此我们喜欢<a class="ae lu" href="https://redpanda.com/" rel="noopener ugc nofollow" target="_blank">小熊猫</a>。</li><li id="54c9" class="ll lm in ke b kf lv ki lw kl lx kp ly kt lz kx lq lr ls lt bi translated">创建主题。</li><li id="9a92" class="ll lm in ke b kf lv ki lw kl lx kp ly kt lz kx lq lr ls lt bi translated">运行面部识别脚本。</li></ol><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="44b0" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是一个有趣的例子，但我的工作流可以应用于许多其他用例。我将带您了解设置<a class="ae lu" href="https://en.wikipedia.org/wiki/Facial_recognition_system" rel="noopener ugc nofollow" target="_blank">面部识别</a>机制以及通过<a class="ae lu" href="https://redpanda.com/" rel="noopener ugc nofollow" target="_blank"> Redpanda </a>将图像流数据导入 Deephaven 的过程。请继续关注其他详细介绍在 Deephaven IDE 中分析图像数据的步骤的文章。</p><h1 id="d56d" class="mc md in bd me mf mg mh mi mj mk ml mm jt mn ju mo jw mp jx mq jz mr ka ms mt bi translated">认识复仇者联盟</h1><p id="f873" class="pw-post-body-paragraph kc kd in ke b kf mu jo kh ki mv jr kk kl mw kn ko kp mx kr ks kt my kv kw kx ig bi translated">在这个演示中，我面对着电影《复仇者联盟》的网络摄像头。我们可以看到，随着电影的播放，所有的角色都被打上了标记。在我的 Deephaven 会话中，在左上角，一个流表记录了所有角色第一次出场的出席情况。在左下方，有三个图表:</p><ol class=""><li id="43d2" class="ll lm in ke b kf kg ki kj kl ln kp lo kt lp kx lq lr ls lt bi translated"><code class="fe mz na nb nc b">Top leading character</code>比较所有主要角色的总出场次数。</li><li id="c8d2" class="ll lm in ke b kf lv ki lw kl lx kp ly kt lz kx lq lr ls lt bi translated"><code class="fe mz na nb nc b">Show-up times of each character</code>显示每个角色的总出现时间(以分钟为单位)。</li><li id="cf12" class="ll lm in ke b kf lv ki lw kl lx kp ly kt lz kx lq lr ls lt bi translated"><code class="fe mz na nb nc b">Number of times each pair of characters hanging out</code>追踪哪些角色比其他角色更频繁地出现在一起。在这里，我基本上是在追踪人物之间的关系。</li></ol><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi nd"><img src="../Images/89e955f605b6c8cd87ff8edddc112b20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HSlvGDHyIZH2UPAkSWqMKA.png"/></div></div></figure><p id="c885" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">下面，我给出了关于我是如何做到这一点的一般细节，并为您提供了根据自己的目的定制代码的指导。</p><h1 id="ffa5" class="mc md in bd me mf mg mh mi mj mk ml mm jt mn ju mo jw mp jx mq jz mr ka ms mt bi translated">计算机视觉和面部识别<a class="ae lu" href="https://docs-staging.deephaven.io/deploy-preview/0174c2e6ed28c96bd088cb08b56153d4345f7d09/blog/2022/07/05/real-time-face-recognition/#computer-vision-and-facial-recognition" rel="noopener ugc nofollow" target="_blank"> </a></h1><p id="520d" class="pw-post-body-paragraph kc kd in ke b kf mu jo kh ki mv jr kk kl mw kn ko kp mx kr ks kt my kv kw kx ig bi translated">现在，我将带您完成设置一个程序的步骤，该程序检测电影中的角色，然后输出这些角色的名字以及他们出现在屏幕上的时间。</p><p id="3522" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了训练人脸识别模型，我们需要建立一个人脸数据库，其中包含我们想要识别的所有角色的人脸/图像。有很多方法可以做到这一点——在这里，我们只是从互联网上抓取所有角色的图像。</p><p id="5da3" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一旦图像数据库准备好，使用<a class="ae lu" href="https://face-recognition.readthedocs.io/en/latest/face_recognition.html" rel="noopener ugc nofollow" target="_blank">人脸识别</a>和<a class="ae lu" href="https://pypi.org/project/opencv-python/" rel="noopener ugc nofollow" target="_blank"> Open_CV </a>软件包开发算法。</p><p id="6b35" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">示例代码如下所示:</p><pre class="kz la lb lc gt ne nc nf ng aw nh bi"><span id="9836" class="ni md in nc b gy nj nk l nl nm">cap = cv2.VideoCapture(0)<br/>name_re=set()<br/>while True:<br/>    """capture the pics from webcam, doing face encoding, face detection and face comparion, return the most matched face name<br/>    draw rectangle around all the faces, and all the information"""<br/>    degree=0.25<br/>    ret, img = cap.read()<br/>    # resize the image tp 0.25 of the orginal one ## make it faster<br/>    imgS = cv2.resize(img,(0,0),None,degree,degree)<br/>    imgS = cv2.cvtColor(imgS, cv2.COLOR_BGR2RGB)<br/>    # find the face location in the resized image<br/>    facesCurFrame = face_recognition.face_locations(imgS)<br/>    # encoding the img<br/>    encodesCurFrame = face_recognition.face_encodings(imgS,facesCurFrame)</span></pre><p id="91ee" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe mz na nb nc b">facesCurFrame = face_recognition.face_locations(imgS)</code>在网络摄像头捕捉到图像后运行。它实现了一个训练有素的 HOG 算法，该算法测量图像局部的梯度方向，以检测人脸的形状。</p><p id="1a34" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">下一步是对从图像中检测到的每张脸进行编码，并将其翻译成计算机可读的语言。我们使用深度学习模型为每张脸生成 128 个独特的测量值。<code class="fe mz na nb nc b">face_recognition.face_encodings()</code>做所有的重活。</p><p id="6b98" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一旦图像经过处理，我们需要在数据库中找到最相似的一个。我们使用<a class="ae lu" href="https://en.wikipedia.org/wiki/Cosine_similarity" rel="noopener ugc nofollow" target="_blank">余弦距离</a>来计算来自网络摄像头(或电影)的人脸之间的距离！)与我们数据库中的人脸进行比较，然后输出距离最小的人脸的名称。到最后，我们应该有一个数据流，包括第一次出现的时间和角色的名字。</p><pre class="kz la lb lc gt ne nc nf ng aw nh bi"><span id="3894" class="ni md in nc b gy nj nk l nl nm">for encode_Face,face_Loc in zip(encodesCurFrame,facesCurFrame):<br/>    matches = face_recognition.compare_faces(encodeListKnown,encode_Face)<br/>    faceDis = face_recognition.face_distance(encodeListKnown,encode_Face)<br/>    print(faceDis)<br/>    matchIndex = np.argmin(faceDis)<br/>    if faceDis[matchIndex]&lt;0.5:<br/>        name = person_name[matchIndex].upper()<br/>    else:<br/>        name=re.sub(r'[^a-zA-Z]', '', name)</span></pre><h1 id="bd4f" class="mc md in bd me mf mg mh mi mj mk ml mm jt mn ju mo jw mp jx mq jz mr ka ms mt bi translated">使用 Redpanda <a class="ae lu" href="https://docs-staging.deephaven.io/deploy-preview/0174c2e6ed28c96bd088cb08b56153d4345f7d09/blog/2022/07/05/real-time-face-recognition/#set-up-a-kafka-stream-using-redpanda" rel="noopener ugc nofollow" target="_blank"> </a>设置 Kafka 流</h1><p id="c1b5" class="pw-post-body-paragraph kc kd in ke b kf mu jo kh ki mv jr kk kl mw kn ko kp mx kr ks kt my kv kw kx ig bi translated">实时数据存储和访问在这里成为一个问题。我们如何存储数据以便于访问？而且，不同的数据流如何分别存储，新数据进来时，表如何自动刷新？</p><h2 id="1d98" class="ni md in bd me nn no dn mi np nq dp mm kl nr ns mo kp nt nu mq kt nv nw ms nx bi translated">卡夫卡<a class="ae lu" href="https://docs-staging.deephaven.io/deploy-preview/0174c2e6ed28c96bd088cb08b56153d4345f7d09/blog/2022/07/05/real-time-face-recognition/#kafka" rel="noopener ugc nofollow" target="_blank"> </a></h2><p id="f591" class="pw-post-body-paragraph kc kd in ke b kf mu jo kh ki mv jr kk kl mw kn ko kp mx kr ks kt my kv kw kx ig bi translated">卡夫卡满足了我们所有的需求。<a class="ae lu" href="https://kafka.apache.org/" rel="noopener ugc nofollow" target="_blank"> Kafka </a>可以将不同的数据存储到单独的主题中。有了主题名和键值，我们可以轻松地实时发布和消费数据。Redpanda，一个基于 Kafka 构建的服务器，结合 Deephaven 是一个强大的工具。</p><p id="d405" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">要启动服务器，请运行以下代码:</p><pre class="kz la lb lc gt ne nc nf ng aw nh bi"><span id="6881" class="ni md in nc b gy nj nk l nl nm"><em class="lk">git</em> clone https://github.com/deephaven-examples/cv_stream.git<br/>cd cv_stream<br/><em class="lk">docker-compose</em> up -d</span></pre><p id="9298" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这为 Redpanda 和 Deephaven 构建了容器。要访问该流并体验 Deephaven 的所有分析工具，请导航到<a class="ae lu" href="http://localhost:10000/ide" rel="noopener ugc nofollow" target="_blank">http://localhost:10000/ide</a>。</p><h1 id="c67b" class="mc md in bd me mf mg mh mi mj mk ml mm jt mn ju mo jw mp jx mq jz mr ka ms mt bi translated">创建主题<a class="ae lu" href="https://docs-staging.deephaven.io/deploy-preview/0174c2e6ed28c96bd088cb08b56153d4345f7d09/blog/2022/07/05/real-time-face-recognition/#create-topics" rel="noopener ugc nofollow" target="_blank"> </a></h1><p id="797d" class="pw-post-body-paragraph kc kd in ke b kf mu jo kh ki mv jr kk kl mw kn ko kp mx kr ks kt my kv kw kx ig bi translated">服务器启动后，我们需要为要生成和消费的数据创建主题。什么都可以，但是我们选择了“角色出席”和“角色关系”。运行:</p><pre class="kz la lb lc gt ne nc nf ng aw nh bi"><span id="228f" class="ni md in nc b gy nj nk l nl nm"><em class="lk">docker</em> exec -it redpanda-1 rpk topic create character_attendance --brokers=localhost:9092<br/><em class="lk">docker</em> exec -it redpanda-1 rpk topic create character_relation --brokers=localhost:9092</span></pre><p id="c38e" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">要检查现有主题，请运行:</p><pre class="kz la lb lc gt ne nc nf ng aw nh bi"><span id="e1ce" class="ni md in nc b gy nj nk l nl nm"><em class="lk">docker</em> exec -it redpanda-1 rpk cluster info</span></pre><h1 id="3b71" class="mc md in bd me mf mg mh mi mj mk ml mm jt mn ju mo jw mp jx mq jz mr ka ms mt bi translated">运行人脸识别脚本<a class="ae lu" href="https://docs-staging.deephaven.io/deploy-preview/0174c2e6ed28c96bd088cb08b56153d4345f7d09/blog/2022/07/05/real-time-face-recognition/#run-the-face-recognition-script" rel="noopener ugc nofollow" target="_blank"> </a></h1><p id="15e3" class="pw-post-body-paragraph kc kd in ke b kf mu jo kh ki mv jr kk kl mw kn ko kp mx kr ks kt my kv kw kx ig bi translated">现在你已经知道面部识别模型是如何工作的了，下面是你可以自己尝试的完整脚本。</p><p id="6284" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">要运行这个脚本，首先在本地机器上安装<code class="fe mz na nb nc b">Kafka-python</code>、<code class="fe mz na nb nc b">face_recognition</code>和<code class="fe mz na nb nc b">opencv-pyth</code>，并使用一个简单的<code class="fe mz na nb nc b">pip install</code>:</p><pre class="kz la lb lc gt ne nc nf ng aw nh bi"><span id="a04e" class="ni md in nc b gy nj nk l nl nm">pip <em class="lk">install</em> Kafka-python face_recognition opencv-python</span></pre><p id="4b7c" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后:</p><pre class="kz la lb lc gt ne nc nf ng aw nh bi"><span id="bced" class="ni md in nc b gy nj nk l nl nm"># this python file analyzes the stream data<br/># all the packages used for the project<br/>import re<br/>import cv2<br/>import numpy as np<br/>import face_recognition<br/>import os<br/>from datetime import datetime<br/>from kafka import KafkaProducer<br/>import json<br/>#from confluent_kafka import Producer<br/>topic_name1 = 'character_relation'<br/>topic_name2="character_attendance"<br/>def json_serializer(data):<br/>    return json.dumps(data).encode("utf-8")<br/>producer=KafkaProducer(bootstrap_servers=["localhost:9092"],value_serializer=json_serializer)<br/>person_name=[]<br/>images=[]<br/># loop through the images, and processing<br/>for pic in os.listdir("images"):<br/>    if pic.endswith("png") or pic.endswith("jpg"):<br/>        img=cv2.imread("images/{}".format(pic))<br/>        name=os.path.splitext(pic)[0]<br/>        images.append(img)<br/>        person_name.append(name)<br/>print(person_name)<br/>def encoding(images):<br/>    """encoding the all the images, and find the 128 measurements for the face"""<br/>    images_encoding=[]<br/>    #loop all the images<br/>    for image in images:<br/>        try:<br/>            img=cv2.cvtColor(image,cv2.COLOR_BGR2RGB)<br/>            encode = face_recognition.face_encodings(img)[0]<br/>            images_encoding.append(encode)<br/>        except:<br/>            pass<br/>    return images_encoding<br/>encodeListKnown = encoding(images)<br/>print('Encoding Complete')<br/># record the pic got by webcam<br/>cap = cv2.VideoCapture(0)<br/>name_re=set()<br/>while True:<br/>    """capture the pics from webcam, doing face encoding, face detection and face comparion, return the most matched face name<br/>    draw rectangle around all the faces, and all the information"""<br/>    degree=0.25<br/>    ret, img = cap.read()<br/>    # resize the image tp 0.25 of the orginal one ## make it faster<br/>    imgS = cv2.resize(img,(0,0),None,degree,degree)<br/>    imgS = cv2.cvtColor(imgS, cv2.COLOR_BGR2RGB)<br/>    # find the face location in the resized image<br/>    facesCurFrame = face_recognition.face_locations(imgS)<br/>    # encoding the img<br/>    encodesCurFrame = face_recognition.face_encodings(imgS,facesCurFrame)<br/>    format= cv2.FONT_HERSHEY_COMPLEX<br/>    for encode_Face,face_Loc in zip(encodesCurFrame,facesCurFrame):<br/>        matches = face_recognition.compare_faces(encodeListKnown,encode_Face)<br/>        faceDis = face_recognition.face_distance(encodeListKnown,encode_Face)<br/>        print(faceDis)<br/>        matchIndex = np.argmin(faceDis)<br/>        if faceDis[matchIndex]&lt;0.5:<br/>            name = person_name[matchIndex].upper()<br/>            name=re.sub(r'[^a-zA-Z]', '', name)<br/>            y1,x2,y2,x1 = face_Loc<br/>            # scale back the location<br/>            #scale_back=1/degree<br/>            y1, x2, y2, x1 = y1*4,x2*4,y2*4,x1*4<br/>            # draw rectangle on the image<br/>            cv2.rectangle(img,(x1,y1),(x2,y2),(0,255,0),2)<br/>            cv2.putText(img,name,(x1+6,y2-6),format,1,(255,255,255),2)<br/>            json_dic={"name":name}<br/>            print(json_dic)<br/>            producer.send(topic_name1, json_dic)<br/>            print("yes")<br/>            if name not in name_re:<br/>                name_re.add(name)<br/>                producer.send(topic_name2, json_dic)<br/>    cv2.imshow('Webcam',img)<br/>    if cv2.waitKey(20) &amp; 0xFF == ord('q'):<br/>        break<br/>cap.release()<br/>cv2.destroyAllWindows()</span></pre><p id="9711" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe mz na nb nc b">producer=KafkaProducer(bootstrap_servers=["localhost:9092"],value_serializer=json_serializer</code>帮助建立与本地服务器的连接，这样数据就可以存储在本地，供 Redpanda 以后访问。</p><p id="bcf0" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe mz na nb nc b">producer.send(topic_name, json_dic)</code>数据流生成后，将数据发送到服务器。</p><h1 id="683c" class="mc md in bd me mf mg mh mi mj mk ml mm jt mn ju mo jw mp jx mq jz mr ka ms mt bi translated">试试看<a class="ae lu" href="https://docs-staging.deephaven.io/deploy-preview/0174c2e6ed28c96bd088cb08b56153d4345f7d09/blog/2022/07/05/real-time-face-recognition/#try-it-out" rel="noopener ugc nofollow" target="_blank"> </a></h1><p id="d013" class="pw-post-body-paragraph kc kd in ke b kf mu jo kh ki mv jr kk kl mw kn ko kp mx kr ks kt my kv kw kx ig bi translated">如果你用这个项目和博客帖子作为与 Deephaven 合作的基线，我们很乐意听到它。让我们知道你在我们的<a class="ae lu" href="https://github.com/deephaven/deephaven-core/discussions" rel="noopener ugc nofollow" target="_blank"> Github 讨论</a>或我们的<a class="ae lu" href="https://deephaven.io/slack" rel="noopener ugc nofollow" target="_blank"> Slack 社区</a>中提出了什么。</p><div class="ny nz gp gr oa ob"><a href="https://github.com/deephaven-examples/cv_stream" rel="noopener  ugc nofollow" target="_blank"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd io gy z fp og fr fs oh fu fw im bi translated">GitHub-deephaven-examples/cv _ stream:使用 OpenCV 和 deep haven 结合实时计算机…</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">通过 Redpanda/Kafka 将本地出勤或关系数据拉入 Deephaven。Redpanda 是一个开源的…</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">github.com</p></div></div><div class="ok l"><div class="ol l om on oo ok op li ob"/></div></div></a></div></div></div>    
</body>
</html>