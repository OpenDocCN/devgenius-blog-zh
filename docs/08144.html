<html>
<head>
<title>Python — Can You Explain How “for loop” Works?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">python——你能解释一下“for 循环”是如何工作的吗？</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/python-can-you-explain-how-for-loop-works-d9d8618f39f1?source=collection_archive---------3-----------------------#2022-05-20">https://blog.devgenius.io/python-can-you-explain-how-for-loop-works-d9d8618f39f1?source=collection_archive---------3-----------------------#2022-05-20</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><div class=""><h2 id="c61b" class="pw-subtitle-paragraph jo iq ir bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated">用于循环深潜的 Python</h2></div><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj kg"><img src="../Images/9ad181b21eac7387b99262dffc55fb73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35ScVh5D_GhwaKW0kDwsCA.png"/></div></div></figure><p id="5d5b" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated"><code class="fe lo lp lq lr b">for ... in</code>语句可能是 Python 编程中使用最多的语句。用于<code class="fe lo lp lq lr b">iterate</code>覆盖容器对象中的元素，可以是<code class="fe lo lp lq lr b">lists</code>、<code class="fe lo lp lq lr b">tuples</code>、<code class="fe lo lp lq lr b">dictionaries</code>、<code class="fe lo lp lq lr b">sets</code>、<code class="fe lo lp lq lr b">files</code>，甚至可以是自定义的类或函数，比如:</p><p id="e6a3" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">在<code class="fe lo lp lq lr b">list</code>上:</p><pre class="kh ki kj kk gu ls lr lt lu aw lv bi"><span id="fa65" class="lw lx ir lr b gz ly lz l ma mb">&gt;&gt;&gt; for element in [1, 2, 3, 4]:<br/>...    print(element)<br/>...<br/>1<br/>2<br/>3<br/>4</span></pre><p id="1388" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">在<code class="fe lo lp lq lr b">tuples</code>上:</p><pre class="kh ki kj kk gu ls lr lt lu aw lv bi"><span id="74d6" class="lw lx ir lr b gz ly lz l ma mb">&gt;&gt;&gt; <strong class="lr is">for</strong> element <strong class="lr is">in</strong> ("a", "b", 30):<br/>...     print(element)<br/>...<br/>a<br/>b<br/>30</span></pre><p id="a993" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">在文件上:</p><pre class="kh ki kj kk gu ls lr lt lu aw lv bi"><span id="a374" class="lw lx ir lr b gz ly lz l ma mb">&gt;&gt;&gt; <strong class="lr is">for</strong> line <strong class="lr is">in</strong> open("requirement.txt"):<br/>...     print(line, end="")<br/>...<br/>Fabric==1.12.0<br/>Markdown==2.6.7</span></pre><p id="a925" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">你可能会问为什么这么多不同类型的对象支持<code class="fe lo lp lq lr b">for</code>语句，还有哪些类型的对象可以用在<code class="fe lo lp lq lr b">for</code>语句中？在回答这个问题之前，我们需要了解一下 for 循环背后的执行原理。</p><h1 id="c8b2" class="mc lx ir bd md me mf mg mh mi mj mk ml jx mm jy mn ka mo kb mp kd mq ke mr ms bi translated">For 循环</h1><p id="0101" class="pw-post-body-paragraph ks kt ir ku b kv mt js kx ky mu jv la lb mv ld le lf mw lh li lj mx ll lm ln ik bi translated">for 循环是对一个容器进行迭代的过程，<strong class="ku is">什么是迭代？迭代是从一个容器对象中一个接一个地读取元素，直到容器中不再有元素。</strong>那么，哪些对象支持迭代运算呢？任何物体都可以？首先，尝试自定义一个类，看看它是否有效:</p><pre class="kh ki kj kk gu ls lr lt lu aw lv bi"><span id="44f0" class="lw lx ir lr b gz ly lz l ma mb">&gt;&gt;&gt; <strong class="lr is">class</strong> <strong class="lr is">MyTest</strong>:<br/>...     <strong class="lr is">def</strong> <strong class="lr is">__init__</strong>(self, num):<br/>...         self.num = num<br/>...<br/>&gt;&gt;&gt; <strong class="lr is">for</strong> i <strong class="lr is">in</strong> MyTest(10):<br/>...     print(i)<br/>...<br/>Traceback (most recent call last):<br/>  File "&lt;stdin&gt;", line 1, <strong class="lr is">in</strong> &lt;module&gt;<br/>TypeError: 'MyTest' object <strong class="lr is">is</strong> <strong class="lr is">not</strong> iterable</span></pre><p id="010d" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">错误堆栈日志非常明确的告诉我们<code class="fe lo lp lq lr b">MyTest</code>类不是<code class="fe lo lp lq lr b">iterable</code>对象，所以不能用于迭代。什么样的物体叫做<code class="fe lo lp lq lr b">iterable</code>？</p><p id="f489" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">在 Python 中，<strong class="ku is"> Iterable 对象需要实现</strong> <code class="fe lo lp lq lr b"><strong class="ku is">__iter__</strong></code> <strong class="ku is">方法并返回一个迭代器。迭代器只需要实现</strong> <code class="fe lo lp lq lr b"><strong class="ku is">__next__</strong></code> <strong class="ku is">方法</strong>。现在让我们验证为什么列表支持迭代:</p><pre class="kh ki kj kk gu ls lr lt lu aw lv bi"><span id="f2aa" class="lw lx ir lr b gz ly lz l ma mb">&gt;&gt;&gt; x = [1,2,3]<br/>&gt;&gt;&gt; l= x.__iter__() <em class="my"># l is iterable</em><br/>&gt;&gt;&gt; l<br/>&lt;list_iterator object at 0x100f32198&gt;<br/><br/>&gt;&gt;&gt; l.__next__()   # l is a iterator<br/>1<br/>&gt;&gt;&gt; l.__next__()<br/>2<br/>&gt;&gt;&gt; l.__next__()<br/>3<br/>&gt;&gt;&gt; l.__next__()<br/>Traceback (most recent call last):<br/>  File "&lt;stdin&gt;", line 1, <strong class="lr is">in</strong> &lt;module&gt;<br/>StopIteration</span></pre><p id="09ef" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">从测试结果来看，list 是一个<code class="fe lo lp lq lr b">iterable</code>对象，因为它实现了<code class="fe lo lp lq lr b">__iter__</code>方法；iterator 对象(list_iterator) <em class="my">是</em>，因为它实现了<code class="fe lo lp lq lr b">__next__</code>方法<em class="my">。</em></p><p id="b3a3" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">我们看到它一直调用<em class="my">的 __next__ </em>方法，实际上是迭代获取容器中的元素，直到容器中不再有元素抛出<code class="fe lo lp lq lr b">StopIteration</code>异常。</p><p id="7398" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">那么<code class="fe lo lp lq lr b">for</code>语句是如何循环的呢？：</p><ol class=""><li id="fa0e" class="mz na ir ku b kv kw ky kz lb nb lf nc lj nd ln ne nf ng nh bi translated">首先判断对象是否是一个<code class="fe lo lp lq lr b">iterable</code>对象，如果不是，直接报错，抛出一个<code class="fe lo lp lq lr b">TypeError</code>异常。如果是，它调用<code class="fe lo lp lq lr b">__iter__</code>方法并返回一个<code class="fe lo lp lq lr b">iterator</code>。</li><li id="5324" class="mz na ir ku b kv ni ky nj lb nk lf nl lj nm ln ne nf ng nh bi translated">继续调用<code class="fe lo lp lq lr b">iterator</code>的<code class="fe lo lp lq lr b">__next__</code>方法，每次依次返回<code class="fe lo lp lq lr b">iterator</code>中的一个值。</li><li id="0159" class="mz na ir ku b kv ni ky nj lb nk lf nl lj nm ln ne nf ng nh bi translated">在迭代结束时，如果没有更多的元素，就会抛出异常<code class="fe lo lp lq lr b">StopIteration</code>。这个异常将由 Python 自己处理，不会向开发人员公开。</li></ol><p id="d2ea" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">整个流程如下所示:</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj nn"><img src="../Images/411966c164a4e568b1e26a7851438db9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1230/format:webp/1*zco00JtBFQt_fr9DJdfkrg.png"/></div></div></figure><p id="8066" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">对于<code class="fe lo lp lq lr b">tuples</code>、<code class="fe lo lp lq lr b">dictionaries</code>、<code class="fe lo lp lq lr b">strings</code>也是如此。理解了 for 的执行原理后，我们就可以实现自己的迭代器用于 for 循环了。</p><p id="a97d" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">之前的<code class="fe lo lp lq lr b">MyTest</code>类报告了一个错误，因为它没有在迭代器协议中实现这两个方法。现在继续改进:</p><pre class="kh ki kj kk gu ls lr lt lu aw lv bi"><span id="b59c" class="lw lx ir lr b gz ly lz l ma mb"><strong class="lr is">class</strong> <strong class="lr is">MyTest</strong>:<br/>    <strong class="lr is">def</strong> <strong class="lr is">__init__</strong>(self, num):<br/>        self.i = 0<br/>        self.num = num<br/><br/>    <strong class="lr is">def</strong> <strong class="lr is">__iter__</strong>(self):<br/>        <strong class="lr is">return</strong> self<br/><br/>    <strong class="lr is">def</strong> <strong class="lr is">__next__</strong>(self):<br/>        <strong class="lr is">if</strong> self.i &lt; self.num:<br/>            i = self.i<br/>            self.i += 1<br/>            <strong class="lr is">return</strong> i<br/>        <strong class="lr is">else</strong>:<br/>            <strong class="lr is">raise</strong> StopIteration()</span></pre><p id="4f05" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">因为实现了<code class="fe lo lp lq lr b">__next__</code>方法，<code class="fe lo lp lq lr b">MyTest</code>本身已经是一个迭代器，所以对象本身是<code class="fe lo lp lq lr b">__iter__</code>返回的。现在在 for 循环中尝试一下:</p><pre class="kh ki kj kk gu ls lr lt lu aw lv bi"><span id="4d2c" class="lw lx ir lr b gz ly lz l ma mb"><strong class="lr is">for</strong> i <strong class="lr is">in</strong> MyTest(3):<br/>    print(i)</span><span id="b9ab" class="lw lx ir lr b gz no lz l ma mb"><em class="my"># Output</em><br/>1<br/>2<br/>3</span></pre><p id="c8a6" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated"><strong class="ku is">for 循环的本质是不断调用迭代器</strong> <code class="fe lo lp lq lr b"><strong class="ku is">__next__</strong></code> <strong class="ku is">的方法，直到发生 StopIteration 异常退出循环</strong>。所以任何<code class="fe lo lp lq lr b">iterable</code>都可以用在 for 循环中。</p><h1 id="b048" class="mc lx ir bd md me mf mg mh mi mj mk ml jx mm jy mn ka mo kb mp kd mq ke mr ms bi translated">中断并继续</h1><p id="4446" class="pw-post-body-paragraph ks kt ir ku b kv mt js kx ky mu jv la lb mv ld le lf mw lh li lj mx ll lm ln ik bi translated">使用<code class="fe lo lp lq lr b">break</code>语句，我们可以在循环完所有项目之前停止循环:</p><pre class="kh ki kj kk gu ls lr lt lu aw lv bi"><span id="4ec1" class="lw lx ir lr b gz ly lz l ma mb">fruits = ["apple", "banana", "cherry"]<br/>for x in fruits:<br/>    print(x)<br/>    if x == "banana":<br/>      break</span><span id="b908" class="lw lx ir lr b gz no lz l ma mb"># Output<br/>apple<br/>banana</span></pre><p id="7174" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">使用<code class="fe lo lp lq lr b">continue</code>语句，我们可以停止循环的当前迭代，并继续下一个:</p><pre class="kh ki kj kk gu ls lr lt lu aw lv bi"><span id="1070" class="lw lx ir lr b gz ly lz l ma mb">fruits = ["apple", "banana", "cherry"]<br/>for x in fruits:<br/>    if x == "banana":<br/>        continue<br/>    print(x)</span><span id="301b" class="lw lx ir lr b gz no lz l ma mb"># Output<br/>apple<br/>cherry</span></pre><p id="6168" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">您也可以在<code class="fe lo lp lq lr b">for</code>循环中使用<code class="fe lo lp lq lr b">else</code>关键字来指定循环结束时要执行的代码块:</p><pre class="kh ki kj kk gu ls lr lt lu aw lv bi"><span id="c2e0" class="lw lx ir lr b gz ly lz l ma mb">for x in range(10):<br/>    print(x)<br/>else:<br/>    print("Finished!")</span><span id="c9a5" class="lw lx ir lr b gz no lz l ma mb"># Output<br/>0<br/>1<br/>2<br/>3<br/>4<br/>5<br/>6<br/>7<br/>8<br/>9<br/>finished!</span></pre><p id="e35c" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated"><strong class="ku is">注意:</strong>如果循环被<code class="fe lo lp lq lr b">break</code>语句停止或者<code class="fe lo lp lq lr b">for</code>循环出现异常，则<code class="fe lo lp lq lr b">else</code>块不会被执行。</p><h1 id="ace8" class="mc lx ir bd md me mf mg mh mi mj mk ml jx mm jy mn ka mo kb mp kd mq ke mr ms bi translated">小贴士:对于 vs While</h1><p id="d342" class="pw-post-body-paragraph ks kt ir ku b kv mt js kx ky mu jv la lb mv ld le lf mw lh li lj mx ll lm ln ik bi translated"><code class="fe lo lp lq lr b">while</code>和<code class="fe lo lp lq lr b">for</code>是 Python 中常用的两个实现循环的关键字，它们的运行效率其实是有差距的。如果您执行以下代码:</p><pre class="kh ki kj kk gu ls lr lt lu aw lv bi"><span id="416b" class="lw lx ir lr b gz ly lz l ma mb">import timeit<br/><br/><br/>def while_loop(n=100_000_000):<br/>    i = 0<br/>    s = 0<br/>    while i &lt; n:<br/>        s += i<br/>        i += 1<br/>    return s<br/><br/><br/>def for_loop(n=100_000_000):<br/>    s = 0<br/>    for i in range(n):<br/>        s += i<br/>    return s<br/><br/><br/>def main():<br/>    print('while loop\t\t', timeit.timeit(while_loop, number=1))<br/>    print('for loop\t\t', timeit.timeit(for_loop, number=1))<br/><br/><br/>if __name__ == '__main__':<br/>    main()<br/><em class="my"># =&gt; while loop               4.718853999860585</em><br/><em class="my"># =&gt; for loop                 3.211570399813354</em></span></pre><p id="c1ff" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">你可以看到<code class="fe lo lp lq lr b">for</code>循环比<code class="fe lo lp lq lr b">while</code>循环快 1.5 秒。区别主要在两者的机制上。</p><p id="2f0d" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">在每个循环中，<code class="fe lo lp lq lr b">while</code>做两个操作:</p><ul class=""><li id="a755" class="mz na ir ku b kv kw ky kz lb nb lf nc lj nd ln np nf ng nh bi translated">变量的边界检查和递增。也就是说，每次执行循环时，while 都会进行边界检查(<code class="fe lo lp lq lr b">while i &lt; n</code>)和自动增量计算(<code class="fe lo lp lq lr b">i +=1</code>)。这两步都是显式的纯 Python 代码。</li><li id="cb65" class="mz na ir ku b kv ni ky nj lb nk lf nl lj nm ln np nf ng nh bi translated"><code class="fe lo lp lq lr b">for</code>循环不需要进行边界检查和自动递增操作，也没有添加显式的 Python 代码(纯 Python 代码比低级 C 代码效率低)。当循环次数足够多时，效率差距明显。</li></ul><p id="7fda" class="pw-post-body-paragraph ks kt ir ku b kv kw js kx ky kz jv la lb lc ld le lf lg lh li lj lk ll lm ln ik bi translated">一般来说，如果您只是迭代一个已知的集合，找到满足条件的元素，并执行适当的操作，那么使用<code class="fe lo lp lq lr b">for</code>循环会更简洁。但是如果需要不断重复某些操作，直到满足某个条件，并且没有特定的集合要遍历，那么一般会使用一个<code class="fe lo lp lq lr b">while</code>循环。</p></div></div>    
</body>
</html>