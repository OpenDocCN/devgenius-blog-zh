<html>
<head>
<title>C# Tip: SQL Executor Service — Extending Functionality</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C#提示:SQL Executor 服务—扩展功能</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/c-tip-sql-executor-service-extending-functionality-edad1c554f?source=collection_archive---------12-----------------------#2022-02-15">https://blog.devgenius.io/c-tip-sql-executor-service-extending-functionality-edad1c554f?source=collection_archive---------12-----------------------#2022-02-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="6ea4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">如何在不改变原有类的情况下增加功能</em></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/e035d941ee8ed60bfdb7f71d2ed2dc27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*0szHlufaajgPZntB.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">样品依赖性注入</figcaption></figure><h1 id="ad06" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">系列目录</h1><p id="62ff" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated"><a class="ae mf" rel="noopener ugc nofollow" target="_blank" href="/c-problem-sql-executor-service-deb459132a50">第 1 部分:SQL 执行器服务</a> <br/> <a class="ae mf" href="https://medium.com/dev-genius/c-tip-sql-executor-service-dependency-injection-4455efb453b0" rel="noopener">第 2 部分:依赖注入</a> <br/> <strong class="jp ir">第 3 部分:扩展功能</strong></p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><p id="62a5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在第 1 部分中，我描述了一个可以用来执行 SQL 命令的简单接口。它最明显的用途是从代码中删除一些样板文件，避免大量的<code class="fe mn mo mp mq b">using</code>语句、打开连接等。但这只是其效用的冰山一角。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="7251" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在第 2 部分中，我通过依赖注入来注入服务，并添加了一个允许共享事务的作用域版本。当您希望单个 ASP.NET 请求中的所有 SQL 语句在出错时回滚时，尤其是跨存储库时，这证明是有用的。</p><p id="258c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在第 3 部分中，我将介绍使用这种设计为不同用例扩展功能的一般方法。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="6258" class="lc ld iq bd le lf mt lh li lj mu ll lm ln mv lp lq lr mw lt lu lv mx lx ly lz bi translated">介绍</h1><p id="c278" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">像这样的界面的美在于它的简单。大约一周前，有人对这个特定的界面做了如下评论:</p><blockquote class="my mz na"><p id="905f" class="jn jo kl jp b jq jr js jt ju jv jw jx nb jz ka kb nc kd ke kf nd kh ki kj kk ij bi translated">我不知道这种方法有什么好处。所以我们有了 Dapper 的包装？它只是 IDbConnection 的一个扩展。</p></blockquote><p id="f94d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另一个评论是，</p><blockquote class="my mz na"><p id="ece8" class="jn jo kl jp b jq jr js jt ju jv jw jx nb jz ka kb nc kd ke kf nd kh ki kj kk ij bi translated">我认为这里没有什么特别的价值，只是一种避免写样板文件的方法。只需注入服务+看起来很酷:)</p></blockquote><p id="c2c3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些评论完全没有错。事实上，我很感激它们的诞生。对我来说，这意味着我没有真正传达创建这个界面可以实现的全部内容，以及它如何在未来节省您的精力。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><p id="e658" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">记得第一次看到类似这个的界面。我的第一反应是，“哇…我怎么没想到呢？”实际上，我对自己没有早点简化生活感到沮丧。我的意思是，我写 SQL 已经很多年了，我总是厌倦样板文件，但是我能做什么呢？然后我沿着这些线看到了一些东西，一个灯泡熄灭了。</p><p id="701d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">公平地说，这可能是一个更通用的接口。它可能应该看起来更像这样，</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="aa0f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里我使用接口<code class="fe mn mo mp mq b">IDbConnection</code>和<code class="fe mn mo mp mq b">IDbTransaction</code>来代替。但老实说，在当时，这真的没有给我增加任何价值。我没有写公共图书馆。</p><p id="db9f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">无论如何，我在这个界面中看到的是样板文件的移除和轻松切换 SQL 实现的能力(如<code class="fe mn mo mp mq b">ScopedTransactionSqlExecutor</code>或<code class="fe mn mo mp mq b">NonTransactionSqlServerExecutor</code>)。但这并不是它所能提供的价值和节约的全部。</p><p id="41a5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">先说装修，搭个实例。</p><h1 id="b67e" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">扩展功能</h1><p id="676b" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">我是装饰者模式的超级粉丝。我喜欢它，因为您可以通过使用主类周围的包装器来动态改变类的行为。这在跨领域问题突出的情况下尤其有用。</p><p id="365f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在 SQL 案例中，如果我们开始遇到性能问题，该怎么办？我们如何从代码的角度来衡量查询的性能？</p><p id="9400" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于装饰，我们只需创建一个包装类，</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="3415" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将另一个<code class="fe mn mo mp mq b">ISqlExecutor</code>注入这个类(修饰类)和一个记录器，它将执行度量的编写。从那里，每个方法将启动一个秒表，运行该方法，并记录结果。</p><p id="f7d0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个界面的一个缺点是无法看到正在运行的 SQL 语句。如果不重新创建界面驱动设计的 Dapper T7，我们就无法轻松拦截这些查询。我们必须创建一个自定义的<code class="fe mn mo mp mq b">IDbConnection</code>和<code class="fe mn mo mp mq b">IDbTransaction</code>，并使用它们来代理调用。然后我们可以获得最后一次调用的细节和此时的参数。但是这种复杂性现在真的没有必要。相反，我们简单地包括堆栈跟踪。这将允许我们定位代码，它应该通知正在执行的 SQL。</p><blockquote class="my mz na"><p id="c581" class="jn jo kl jp b jq jr js jt ju jv jw jx nb jz ka kb nc kd ke kf nd kh ki kj kk ij bi translated">如果有人想看到这个拦截器的实现，请在评论中告诉我:)</p></blockquote><p id="07b4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦创建了类，我们只需将它注入到 DI 容器中。我们可以通过使用 NuGet 包让我们的生活变得更简单，</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="ec54" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，用在<code class="fe mn mo mp mq b">Program.cs</code>中，</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="d5ff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">仅此而已。性能指标现在将被记录到您的日志文件中。我将由您来决定是否进行配置。</p><h1 id="ed3a" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">其他使用案例</h1><h2 id="c342" class="ne ld iq bd le nf ng dn li nh ni dp lm jy nj nk lq kc nl nm lu kg nn no ly np bi translated">异常处理</h2><p id="1350" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">我遇到的另一个常见用例是异常处理。尽管我并不特别同意在存储库或服务类中捕捉异常，但除非有非常好的理由，否则对于一些开发人员来说这是一个用例。</p><p id="fc45" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里有一个我们可以使用的可能实现，</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="50d4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们做了一些类似于性能度量的事情，并且包装了一个我们想要捕捉异常的执行器。</p><p id="4838" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后我们可以添加一个扩展方法，</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="dfe4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些小实现的好处在于，我们可以在我们的系统中构建它们。我们不局限于一个。我们可以让许多不同的元素相互缠绕，构建一个更复杂的系统。让我们展示一下这个在<code class="fe mn mo mp mq b">Program.cs</code>中可能会是什么样子，</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="40a5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个设置基本上创建了以下内容，</p><pre class="kn ko kp kq gt nq mq nr ns aw nt bi"><span id="8231" class="ne ld iq mq b gy nu nv l nw nx">new HandleExceptionsSqlExecutor(<br/>   new LogPerformanceSqlExecutor(<br/>      new ScopedTransactionSqlExecutor(...)<br/>   )<br/>)</span></pre><p id="fac8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">根据顺序，我们可以先处理异常，然后记录性能。如果你愿意的话，你可以在外面再加一个表演用的，然后拥有两个。</p><p id="b388" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">关键是，我们在更高的水平上工作。我们不需要写原始代码。相反，我们将我们的类组合在一起形成功能，就好像它是一种更高级的语言。</p><h2 id="ade4" class="ne ld iq bd le nf ng dn li nh ni dp lm jy nj nk lq kc nl nm lu kg nn no ly np bi translated">租户选择</h2><p id="ecd1" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">如果您有一个更复杂的场景，比如一个多租户应用程序，其中每个数据库包含不同租户的数据，该怎么办？这个界面的美妙之处在于，我们可以创建另一个可以隐式切换租户连接的实现。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="d45f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就像它真正需要的那样简单。<code class="fe mn mo mp mq b">ITenantOptions</code>是一个有作用域的服务，它将确定哪个租户通过<code class="fe mn mo mp mq b">Authorization</code>头或其他 HTTP 头生成请求。然后，它会查找选项，并将它们注入到执行程序中。</p><p id="ab60" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们需要创建一个<code class="fe mn mo mp mq b">ISqlExecutorFactory</code>,但是创建起来很简单，</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="f202" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，在我们的存储库中，我们不必弄清楚如何注入适当的连接字符串(假设您的<code class="fe mn mo mp mq b">ISqlExecutor</code>也被注入了作用域)。这将由一个为我们解决问题的服务来处理。对我来说，这使得思考特定的存储库代码变得更加容易。我不需要担心我是否找对了房客。相反，让我在这里做一个假设，只做我能做的最好的 SQL 代码，而不去考虑细节。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="c391" class="lc ld iq bd le lf mt lh li lj mu ll lm ln mv lp lq lr mw lt lu lv mx lx ly lz bi translated">结论和签署</h1><p id="2956" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">我写这篇文章只是为了回应这些评论，因为我觉得没有充分解释所有的好处。如果 Dapper 是一个更加基于界面的设计，这实际上就没有必要了。不幸的是，事实并非如此。因此，我创建了这个接口来为我的代码提供一定程度的灵活性，这是我通常使用传统方法(直接使用<code class="fe mn mo mp mq b">SqlConnection</code>)无法实现的</p><p id="fba7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们在编写 SQL 时小心谨慎，不使用专有关键字，您也可以使用这种方法来允许按租户连接到不同的数据库引擎，甚至允许更容易地转换到不同的引擎(在从 MySQL 转换到 SQL Server 的情况下)。我只需要这样做一次，但确实节省了很多时间。</p><p id="a55a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里有很多用例，但我希望这有助于阐明这样的设计可以带来的丰富性。我们可以以多种方式使用它，以多种方式扩展它，并解决真正的跨领域问题。</p><p id="8f3f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后一点，这个界面可能并不完美。可能有比我在这里介绍的方法更好的方法。最后，我希望为您提供一个工具，在您作为开发人员成长的过程中，您可以利用它来创建更有效的编码结构，以便将来更容易地修改。</p><p id="522a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下次见！</p></div></div>    
</body>
</html>