<html>
<head>
<title>Async Recursive Functions in Rust</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Rust 中的异步递归函数</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/async-recursive-functions-in-rust-dce0a1134fed?source=collection_archive---------8-----------------------#2022-12-03">https://blog.devgenius.io/async-recursive-functions-in-rust-dce0a1134fed?source=collection_archive---------8-----------------------#2022-12-03</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="469d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">不能在 Rust out of the box 中创建递归异步函数是非常令人困惑的。但是也有解决方案，我喜欢在本文中讨论。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c002659aa529b47fb1261926ca6973d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9M0r1R5U1LCuAbFuJwE51w.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Fibonacci_number" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Fibonacci_number</a></figcaption></figure><p id="41a0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最近，有人问我递归函数是如何工作的，我举了一个众所周知的例子:递归生成斐波那契数。</p><p id="1d05" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你已经理解了这个理论并且有了一些创建函数的经验，那么它的实现是非常容易的。</p><p id="c1bb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">以下是我的解决方案:</p><pre class="kj kk kl km gt kz la lb bn lc ld bi"><span id="eedb" class="le lf in la b be lg lh l li lj">fn fibo(n: u64) -&gt; u64 {<br/>    match n {<br/>        0 =&gt; 0,<br/>        1 =&gt; 1,<br/>        _ =&gt; fibo(n - 1) + fibo(n - 2),<br/>    }<br/>}<br/><br/>fn calculate_sync(n: u64) {<br/>    println!("The fibonacci number of n = {} is {}.", n, fibo(n));<br/>}<br/><br/>fn main() {<br/>    calculate_sync(10);<br/>}</span></pre><p id="a07e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">(对于 Rust 初学者，我在这里不深入研究模式匹配功能。但是您可以通过 if 语句模拟模式匹配。读作<em class="lk">如果零，那么零，等等。</em>)</p><p id="a264" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对我在低挂水果上的成功充满信心，我有信心以异步方式重写这个问题。</p><p id="0d61" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是:“电脑说不行”，我现在如履薄冰。</p><h1 id="9ef0" class="ll lf in bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">现在递归的方法</h1><p id="b652" class="pw-post-body-paragraph jk jl in jm b jn mi jp jq jr mj jt ju jv mk jx jy jz ml kb kc kd mm kf kg kh ig bi translated">如您所见，使其异步的逻辑结论是直截了当的:</p><pre class="kj kk kl km gt kz la lb bn lc ld bi"><span id="d05c" class="le lf in la b be lg lh l li lj">async fn async_fibo(n: u64) -&gt; u64 {<br/>    match n {<br/>        0 =&gt; 0,<br/>        1 =&gt; 1,<br/>        _ =&gt; async_fibo(n - 1).await + async_fibo(n - 2).await,<br/>    }<br/>}</span></pre><p id="a962" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是这产生了一个错误:</p><pre class="kj kk kl km gt kz la lb bn lc ld bi"><span id="75ed" class="le lf in la b be lg lh l li lj">error[E0733]: recursion in an `async fn` requires boxing<br/>  --&gt; src/main.rs:10:32<br/>   |<br/>10 | async fn async_fibo(n: u64) -&gt; u64 {<br/>   |                                ^^^ recursive `async fn`<br/>   |<br/>   = note: a recursive `async fn` must be rewritten to return a boxed `dyn Future`<br/>   = note: consider using the `async_recursion` crate: https://crates.io/crates/async_recursion<br/><br/>For more information about this error, try `rustc --explain E0733`.<br/>error: could not compile `fibonacci` due to previous error</span></pre><p id="396f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是因为 async 关键字将函数定义移动到一个 future 定义中，而这个 future 是一个 trait 对象，具有动态大小。这是由编译器在内部完成的，对于初学者来说，<em class="lk">异步 fn </em>总是<em class="lk">或者别的什么</em>令人困惑。(Rust 充满了所有这些类型的快捷键和语法糖。)因此，不能开箱即用，需要使其静态化。正如错误消息所暗示的，您必须将它包装到一个<a class="ae ky" href="https://doc.rust-lang.org/std/boxed/struct.Box.html" rel="noopener ugc nofollow" target="_blank"> Box </a>中，因为 Box 容器是固定大小的<a class="ae ky" href="https://medium.com/@romeo-disca/smart-pointers-in-rust-158046006f15" rel="noopener">智能指针</a>并且在函数签名中只允许固定大小的构造。</p><p id="0b88" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">那么，下一步该怎么办呢？摆弄这种定义是一个兔子洞。幸运的是，有相当好的解决方案。</p><h1 id="8921" class="ll lf in bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">期货箱</h1><p id="25d4" class="pw-post-body-paragraph jk jl in jm b jn mi jp jq jr mj jt ju jv mk jx jy jz ml kb kc kd mm kf kg kh ig bi translated">期货创造给了你处理这个问题的功能。</p><p id="1c08" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">以下是如何操作的链接:</p><div class="mn mo gp gr mp mq"><a href="https://rust-lang.github.io/async-book/07_workarounds/04_recursion.html" rel="noopener  ugc nofollow" target="_blank"><div class="mr ab fo"><div class="ms ab mt cl cj mu"><h2 class="bd io gy z fp mv fr fs mw fu fw im bi translated">Rust 中的异步编程</h2><div class="mx l"><h3 class="bd b gy z fp mv fr fs mw fu fw dk translated">在内部，async fn 创建一个状态机类型，包含每个等待的子未来。</h3></div><div class="my l"><p class="bd b dl z fp mv fr fs mw fu fw dk translated">rust-lang.github.io</p></div></div></div></a></div><p id="4a3f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">把它重新组织成我们的斐波那契问题，我们必须导入这个箱子来让它工作。</p><p id="0067" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在解决方案看起来是这样的:</p><pre class="kj kk kl km gt kz la lb bn lc ld bi"><span id="3fc0" class="le lf in la b be lg lh l li lj">/// https://rust-lang.github.io/async-book/07_workarounds/04_recursion.html<br/>use futures::future::{BoxFuture, FutureExt};<br/>fn async_fibo(n: u64) -&gt; BoxFuture&lt;'static, u64&gt; {<br/>    async move {<br/>        match n {<br/>            0 =&gt; 0,<br/>            1 =&gt; 1,<br/>            _ =&gt; async_fibo(n - 1).await + async_fibo(n - 2).await,<br/>        }<br/>    }.boxed()<br/>}</span></pre><p id="2585" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">不用说，你还需要导入一个像<a class="ae ky" href="https://tokio.rs/" rel="noopener ugc nofollow" target="_blank"> tokio </a>这样的异步运行时作为依赖。</p><pre class="kj kk kl km gt kz la lb bn lc ld bi"><span id="7db8" class="le lf in la b be lg lh l li lj">#[tokio::main]<br/>async fn main() {<br/>    let n = 10;<br/>   println!("The fibonacci number of n = {} is {}.", n, async_fibo(n).await);<br/>}</span></pre><p id="b141" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但这变得更容易了。</p><h1 id="eb9f" class="ll lf in bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">异步递归箱</h1><p id="1d93" class="pw-post-body-paragraph jk jl in jm b jn mi jp jq jr mj jt ju jv mk jx jy jz ml kb kc kd mm kf kg kh ig bi translated">有了这个机箱，我们就不需要像 futures 机箱那样给我们的应用程序提供太多额外的代码，我们可以保持我们直观的、从上面第一次尝试的方法。</p><pre class="kj kk kl km gt kz la lb bn lc ld bi"><span id="1c0c" class="le lf in la b be lg lh l li lj">use async_recursion::async_recursion;<br/>#[async_recursion]<br/>async fn async_fibo(n: u64) -&gt; u64 {<br/>    match n {<br/>        0 =&gt; 0,<br/>        1 =&gt; 1,<br/>        _ =&gt; async_fibo(n - 1).await + async_fibo(n - 2).await,<br/>    }<br/>}</span></pre><p id="9779" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">也就是说，对于这个异步函数递归问题，我们有最好的解决方案。</p><h1 id="7bbf" class="ll lf in bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">结论</h1><p id="cc0a" class="pw-post-body-paragraph jk jl in jm b jn mi jp jq jr mj jt ju jv mk jx jy jz ml kb kc kd mm kf kg kh ig bi translated">当编译器弹出一个初学者无法理解的神秘消息时，这个问题空间给了我们如何处理这种不愉快的编程体验的见解。</p><p id="d6fd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最好的方法是一直谷歌它，因为其他人可能已经提出了你的问题的解决方案并记录下来。</p><p id="56be" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">别忘了在短暂休息后，带着全新的思维去接近谷歌。挫折是学习一门新编程语言的主要原因，尤其是 Rust。</p><p id="5443" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">到回购:<a class="ae ky" href="https://github.com/rusticus-io/async-recursion" rel="noopener ugc nofollow" target="_blank">https://github.com/rusticus-io/async-recursion</a></p></div></div>    
</body>
</html>