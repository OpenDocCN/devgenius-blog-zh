<html>
<head>
<title>Working with JSON Web Tokens in Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在 Node.js 中使用 JSON Web 令牌</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/working-with-json-web-tokens-in-node-js-49d3bb83459c?source=collection_archive---------6-----------------------#2022-12-16">https://blog.devgenius.io/working-with-json-web-tokens-in-node-js-49d3bb83459c?source=collection_archive---------6-----------------------#2022-12-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="8097" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">🚀<a class="ae kl" href="https://learnbackend.dev/books/build-layered-microservices" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">打造分层微服务</strong> </a>这本书出来了！现在就在<a class="ae kl" href="https://learnbackend.dev/books/build-layered-microservices" rel="noopener ugc nofollow" target="_blank"> learnbackend.dev </a>购买你自己的副本。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/2182ad04bef8ff43013a9ec8b0c358c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P6zqF6gPBl7YZ3VLrwOpGw.jpeg"/></div></div></figure><p id="ffda" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">JSON Web 令牌<strong class="jp ir">通常缩写为 JWT(读作“jot”)是一个紧凑的、自包含的和数字签名的令牌，它使用 JSON 格式在各方之间传输信息。</strong></p><p id="4984" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">除了它的加密方法之外，使它受欢迎的是 JSON 格式的使用，例如，它比 XML 更紧凑，这使得它更容易在 web 上操作，并且通常更容易使用，因为 JSON 解析器在大多数编程语言中非常常见。</p><p id="b480" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本文中，您将了解如何使用<code class="fe ky kz la lb b">jsonwebtoken</code>包对 Node.js 中的<strong class="jp ir">签名</strong>和<strong class="jp ir">解码</strong> JSON web 令牌。</p><h1 id="cf54" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">JWT 的解剖</h1><p id="589d" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">一个<strong class="jp ir"> JWT </strong>由三部分组成:头部<strong class="jp ir">头部</strong>、<strong class="jp ir">有效载荷</strong>和<strong class="jp ir">签名</strong>，各部分之间用一个点字符隔开。</p><pre class="kn ko kp kq gt mf lb mg bn mh mi bi"><span id="3e70" class="mj ld iq lb b be mk ml l mm mn">header.payload.signature</span></pre><h2 id="6e1a" class="mo ld iq bd le mp mq dn li mr ms dp lm jy mt mu lq kc mv mw lu kg mx my ly mz bi translated">JWT 头球</h2><p id="9dee" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">头部是一个由两个字段组成的<code class="fe ky kz la lb b">Base64Url</code>编码对象:令牌的类型<strong class="jp ir">和签名算法</strong>。</p><pre class="kn ko kp kq gt mf lb mg bn mh mi bi"><span id="e55b" class="mj ld iq lb b be mk ml l mm mn">{<br/>  "typ": "JWT",<br/>  "alg": "HS256"<br/>}</span></pre><h2 id="650d" class="mo ld iq bd le mp mq dn li mr ms dp lm jy mt mu lq kc mv mw lu kg mx my ly mz bi translated">JWT 有效载荷</h2><p id="a958" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">有效载荷也是一个<code class="fe ky kz la lb b">Base64Url</code>编码的对象，包含关于一个实体(通常是一个用户)的信息片段，以及称为<strong class="jp ir">声明</strong>的附加数据，可以有三种类型:</p><ul class=""><li id="7cd5" class="na nb iq jp b jq jr ju jv jy nc kc nd kg ne kk nf ng nh ni bi translated"><strong class="jp ir">注册声明</strong>是非强制性的预定义声明，可以指定这些声明来确保与第三方或外部应用程序的互操作性，例如令牌的颁发者或其过期时间。</li><li id="b248" class="na nb iq jp b jq nj ju nk jy nl kc nm kg nn kk nf ng nh ni bi translated"><strong class="jp ir">公开声明</strong>通常是通用的非敏感信息，如用户全名或电子邮件地址。</li><li id="06e3" class="na nb iq jp b jq nj ju nk jy nl kc nm kg nn kk nf ng nh ni bi translated"><strong class="jp ir">私有声明</strong>通常是应用特定的敏感信息，如内部用户 ID。</li></ul><pre class="kn ko kp kq gt mf lb mg bn mh mi bi"><span id="07a3" class="mj ld iq lb b be mk ml l mm mn">{<br/>  "exp": 1638298179,            // registered<br/>  "name": "John Doe",           // public<br/>  "email": "johndoe@mail.net",  // public<br/>  "internal_id": "admin1234"    // private<br/>}</span></pre><h2 id="883d" class="mo ld iq bd le mp mq dn li mr ms dp lm jy mt mu lq kc mv mw lu kg mx my ly mz bi translated">JWT 签名</h2><p id="d597" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">最后，通过使用报头中指定的算法、秘密值以及编码报头和有效载荷的点连接值的组合来创建<strong class="jp ir">签名</strong>。</p><pre class="kn ko kp kq gt mf lb mg bn mh mi bi"><span id="e648" class="mj ld iq lb b be mk ml l mm mn">HmacSHA256(<br/>  secret,<br/>  base64url(header) + '.' + base64url(payload)<br/>)</span></pre><h1 id="f6af" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">jsonwebtoken 包</h1><p id="b791" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">在 Node.js 中操作 jwt 最流行的包是<code class="fe ky kz la lb b">jsonwebtoken</code>，可以使用下面的命令安装:</p><pre class="kn ko kp kq gt mf lb mg bn mh mi bi"><span id="a66c" class="mj ld iq lb b be mk ml l mm mn">$ npm install --save jsonwebtoken</span></pre><h2 id="f473" class="mo ld iq bd le mp mq dn li mr ms dp lm jy mt mu lq kc mv mw lu kg mx my ly mz bi translated">签署新的 JWT</h2><p id="a37c" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">为了生成(即签名)一个新的 JSON web 令牌，我们可以使用顶级的<code class="fe ky kz la lb b">sign()</code>方法，它有三个参数:</p><ul class=""><li id="b53e" class="na nb iq jp b jq jr ju jv jy nc kc nd kg ne kk nf ng nh ni bi translated">一个<strong class="jp ir">有效载荷</strong>，它是我们想要发送给客户端的数据(例如用户 ID)。</li><li id="98a9" class="na nb iq jp b jq nj ju nk jy nl kc nm kg nn kk nf ng nh ni bi translated">一个<strong class="jp ir">秘密</strong>或一个<strong class="jp ir">私有密钥</strong>，它或者是一个字符串(例如“myJWTSecret”)或者是一个 PEM 文件，可以使用诸如<code class="fe ky kz la lb b">ssh-keygen</code>之类的工具生成。</li><li id="9a40" class="na nb iq jp b jq nj ju nk jy nl kc nm kg nn kk nf ng nh ni bi translated">一个非强制的<strong class="jp ir">选项</strong>对象，它包含额外的或元数据，如算法、到期日期或令牌的颁发者(参见声明)。</li></ul><pre class="kn ko kp kq gt mf lb mg bn mh mi bi"><span id="e68f" class="mj ld iq lb b be mk ml l mm mn">const jwt = require('jsonwebtoken');<br/><br/>const payload = {<br/>  name: "John"<br/>};<br/>const secret = "mysecret";<br/>const token = jwt.sign(payload, secret);<br/><br/>console.log(token);</span></pre><p id="2bf5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">运行上述脚本，将产生以下输出:</p><pre class="kn ko kp kq gt mf lb mg bn mh mi bi"><span id="7e2f" class="mj ld iq lb b be mk ml l mm mn">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1lIjoiSm9obiIsImlhdCI6MTY1OTAwODQxMH0.w-z_Ht5B4PLQFUQJhymbERqudUboCVtmM24t2y-UjsE</span></pre><h2 id="ad23" class="mo ld iq bd le mp mq dn li mr ms dp lm jy mt mu lq kc mv mw lu kg mx my ly mz bi translated">定义截止日期</h2><p id="177c" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">通过互联网等网络传输的每一条信息都有可能被窃取。因此，通常建议为 JWT 定义一个到期日期，这样，被盗的令牌不会授予攻击者对受保护资源的无限访问权。</p><p id="e05e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第一种方法是在<code class="fe ky kz la lb b">payload</code>对象中定义一个<code class="fe ky kz la lb b">exp</code>声明，它包含从纪元(1970 年 1 月 1 日)开始到到期日的秒数。</p><pre class="kn ko kp kq gt mf lb mg bn mh mi bi"><span id="cef7" class="mj ld iq lb b be mk ml l mm mn">const jwt = require('jsonwebtoken');<br/><br/>const payload = {<br/>  name: "John",<br/>  exp: Math.floor(Date.now() / 1000) + (60 * 60)  // 1h<br/>};<br/>const secret = "mysecret";<br/>const token = jwt.sign(payload, secret);</span></pre><p id="d111" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第二种方法是在<code class="fe ky kz la lb b">options</code>对象上添加一个<code class="fe ky kz la lb b">expiresIn</code>字段，其中包含描述时间跨度的字符串。</p><pre class="kn ko kp kq gt mf lb mg bn mh mi bi"><span id="9d68" class="mj ld iq lb b be mk ml l mm mn">const jwt = require('jsonwebtoken');<br/><br/>const payload = {<br/>  name: "John"<br/>};<br/>const secret = "mysecret";<br/>const options = {<br/>  expiresIn: "1h"<br/>};<br/>const token = jwt.sign(payload, secret, options);</span></pre><h2 id="b329" class="mo ld iq bd le mp mq dn li mr ms dp lm jy mt mu lq kc mv mw lu kg mx my ly mz bi translated">解码 JWT</h2><p id="6b41" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">要解码一个 JSON web 令牌，我们可以使用模块导出的顶级<code class="fe ky kz la lb b">verify()</code>方法，它有三个参数:</p><ul class=""><li id="bf49" class="na nb iq jp b jq jr ju jv jy nc kc nd kg ne kk nf ng nh ni bi translated">一个<strong class="jp ir">令牌</strong>，它是要解码的 JSON web 令牌。</li><li id="12a4" class="na nb iq jp b jq nj ju nk jy nl kc nm kg nn kk nf ng nh ni bi translated">一个<strong class="jp ir">秘密</strong>或一个<strong class="jp ir">公开密钥</strong>，它或者是一个字符串(例如“myJWTSecret”)或者是一个 PEM 文件，可以使用诸如<code class="fe ky kz la lb b">ssh-keygen</code>之类的工具生成。</li><li id="77d6" class="na nb iq jp b jq nj ju nk jy nl kc nm kg nn kk nf ng nh ni bi translated">一个非强制性的<strong class="jp ir">选项</strong>对象执行额外的令牌验证。</li></ul><pre class="kn ko kp kq gt mf lb mg bn mh mi bi"><span id="2d9a" class="mj ld iq lb b be mk ml l mm mn">const jwt = require('jsonwebtoken');<br/><br/>const token = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1lIjoiSm9obiIsImlhdCI6MTY1OTAwODQxMH0.w-z_Ht5B4PLQFUQJhymbERqudUboCVtmM24t2y-UjsE";<br/>const secret = "mysecret";<br/>const payload = jwt.decode(token, secret);<br/><br/>console.log(payload);</span></pre><p id="e66b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">运行上述脚本，将产生以下输出:</p><pre class="kn ko kp kq gt mf lb mg bn mh mi bi"><span id="75dc" class="mj ld iq lb b be mk ml l mm mn">{ name: 'John', iat: 1659008410 }</span></pre><h1 id="a52b" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">下一步是什么？</h1><p id="0bfb" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">👉你喜欢这种内容？查看 https://learnbackend.dev 上的书籍<a class="ae kl" href="https://learnbackend.dev/books/build-layered-microservices" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">Build Layered micro services</strong></a>了解如何使用 Express framework 构建生产就绪的分层认证微服务，从第一行代码到最后一行文档，该服务在开发实践和软件架构方面符合行业标准。</p></div></div>    
</body>
</html>