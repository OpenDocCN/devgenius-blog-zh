<html>
<head>
<title>How To Make A Perfect Class In Singleton Design Pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在单例设计模式下创建一个完美的类</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-to-make-a-perfect-class-in-singleton-design-pattern-edc4a9b5935e?source=collection_archive---------1-----------------------#2021-05-17">https://blog.devgenius.io/how-to-make-a-perfect-class-in-singleton-design-pattern-edc4a9b5935e?source=collection_archive---------1-----------------------#2021-05-17</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><div class=""><h2 id="3072" class="pw-subtitle-paragraph jo iq ir bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated">有三种方法可以破坏你的单例类，你必须知道如何防止它。</h2></div><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj kg"><img src="../Images/b24adacf18474afe3e394b3d09c797af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5pDG97_UhEhnv-iQwBUC4g.jpeg"/></div></div><figcaption class="ks kt gk gi gj ku kv bd b be z dk translated">在<a class="ae kw" href="https://unsplash.com/s/photos/broken-walls?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上<a class="ae kw" href="https://unsplash.com/@kiwihug?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Kiwihug </a>拍摄的照片</figcaption></figure><p id="f8fa" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">如果你在一个面向对象的系统中工作，那么你必须使用T4设计模式中的一种，正如四人组(g of)在他们的书《设计模式——可重用面向对象软件的元素》(1994年)中提出的。单例设计模式就是我们在应用程序中广泛使用的一种设计模式。单体设计模式属于创造性设计模式家族。</p><h1 id="3cc8" class="lu lv ir bd lw lx ly lz ma mb mc md me jx mf jy mg ka mh kb mi kd mj ke mk ml bi translated">为什么首先要使用单例模式？</h1><p id="d76f" class="pw-post-body-paragraph kx ky ir kz b la mm js lc ld mn jv lf lg mo li lj lk mp lm ln lo mq lq lr ls ik bi translated">Singleton类背后的主要思想是只创建一个对象，不允许进一步创建对象，从而控制对象创建过程。当您想要控制数据库连接、缓存、日志记录等资源时，这很方便。</p><p id="ad48" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">例如，可以使用Singleton代替类的单个实例，因为日志类通常需要被项目中的每个类反复使用。如果每个类都使用这个日志类，依赖注入就变得很麻烦。</p><h1 id="d574" class="lu lv ir bd lw lx ly lz ma mb mc md me jx mf jy mg ka mh kb mi kd mj ke mk ml bi translated">单一模式&amp;打破它们的方法</h1><p id="e89e" class="pw-post-body-paragraph kx ky ir kz b la mm js lc ld mn jv lf lg mo li lj lk mp lm ln lo mq lq lr ls ik bi translated">使用单例模式的全部目的是创建一个对象，并防止进一步的对象创建。理想情况下，创建单例类的最简单方法是将构造函数设为私有，并创建一个公共静态方法来提供创建新实例的单一入口点。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="mr ms l"/></div></figure><p id="ded6" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">但是，存在一些漏洞，通过这些漏洞您可以创建多个实例。如果发生这种情况，那么使用单例模式的整个目的就失败了。</p><p id="4d3f" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">有三种方法可以打破单一模式。</p><h1 id="4a9d" class="lu lv ir bd lw lx ly lz ma mb mc md me jx mf jy mg ka mh kb mi kd mj ke mk ml bi translated">使用反射API</h1><p id="6ced" class="pw-post-body-paragraph kx ky ir kz b la mm js lc ld mn jv lf lg mo li lj lk mp lm ln lo mq lq lr ls ik bi translated">反射API用于在运行时检查或修改方法、类和接口的行为。使用这种方法，您可以在运行时调用方法，而不考虑与它们一起使用的访问说明符。因此，使用反射API，您可以创建额外的对象。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="mr ms l"/></div></figure><h2 id="46df" class="mt lv ir bd lw mu mv dn ma mw mx dp me lg my mz mg lk na nb mi lo nc nd mk ne bi translated">反射API的解决方案</h2><p id="3cde" class="pw-post-body-paragraph kx ky ir kz b la mm js lc ld mn jv lf lg mo li lj lk mp lm ln lo mq lq lr ls ik bi translated">有几种方法可以防止单例模式被破坏。其中一个解决方案是，如果实例已经存在，就在构造函数中抛出一个运行时异常。这将阻止您创建另一个实例。</p><p id="a77d" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">另一个最佳解决方案是简单地使用枚举，因为java确保枚举值只被实例化一次。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="mr ms l"/></div></figure><h1 id="51a0" class="lu lv ir bd lw lx ly lz ma mb mc md me jx mf jy mg ka mh kb mi kd mj ke mk ml bi translated">使用可克隆的接口</h1><p id="0dc5" class="pw-post-body-paragraph kx ky ir kz b la mm js lc ld mn jv lf lg mo li lj lk mp lm ln lo mq lq lr ls ik bi translated">如果Singleton类实现了Cloneable接口，那么<em class="lt"> clone() </em>也会被覆盖。使用这个<em class="lt"> clone()，</em>您可以在Singleton类中创建对象的副本(或克隆)，这将打破Singleton模式。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="mr ms l"/></div></figure><h2 id="22cc" class="mt lv ir bd lw mu mv dn ma mw mx dp me lg my mz mg lk na nb mi lo nc nd mk ne bi translated">可克隆界面的解决方案</h2><p id="5ad2" class="pw-post-body-paragraph kx ky ir kz b la mm js lc ld mn jv lf lg mo li lj lk mp lm ln lo mq lq lr ls ik bi translated">为了防止使用Cloneable接口破坏单例模式，您需要覆盖clone方法并返回相同的实例，这将确保克隆的对象与原始对象相同。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="mr ms l"/></div></figure><h1 id="da62" class="lu lv ir bd lw lx ly lz ma mb mc md me jx mf jy mg ka mh kb mi kd mj ke mk ml bi translated">使用反序列化</h1><p id="dc1e" class="pw-post-body-paragraph kx ky ir kz b la mm js lc ld mn jv lf lg mo li lj lk mp lm ln lo mq lq lr ls ik bi translated">使用序列化，可以将字节流的对象保存到文件中。因此，当反序列化同一个类时，将创建该类的一个新实例，然后将其实例变量设置为已序列化的值。所以，如果类是单例的，那么使用反序列化，可以创建新的对象。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="mr ms l"/></div></figure><h2 id="9bad" class="mt lv ir bd lw mu mv dn ma mw mx dp me lg my mz mg lk na nb mi lo nc nd mk ne bi translated">反序列化的解决方案</h2><p id="f192" class="pw-post-body-paragraph kx ky ir kz b la mm js lc ld mn jv lf lg mo li lj lk mp lm ln lo mq lq lr ls ik bi translated">您可以通过覆盖<em class="lt"> readResolve() </em>并返回同一个实例来防止破坏单例模式。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="mr ms l"/></div></figure><p id="b567" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">这是打破单例模式的三种方式，以及如何防止它的解决方案。单一模式是所有设计模式中最容易实现的，但是它也有自己的优缺点。尽管如此，Singleton仍然是采访中讨论最多的设计模式之一。</p></div><div class="ab cl nf ng hv nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ik il im in io"><p id="ed81" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">如果你喜欢读这篇文章，你可能也会发现下面的文章值得你花时间去读。</p><div class="nm nn gq gs no np"><a href="https://python.plainenglish.io/design-patterns-that-every-software-developer-must-know-ac71f575e68" rel="noopener  ugc nofollow" target="_blank"><div class="nq ab fp"><div class="nr ab ns cl cj nt"><h2 class="bd is gz z fq nu fs ft nv fv fx iq bi translated">每个软件开发人员都必须知道的设计模式</h2><div class="nw l"><h3 class="bd b gz z fq nu fs ft nv fv fx dk translated">这些久经考验的解决方案提高了编程效率。</h3></div><div class="nx l"><p class="bd b dl z fq nu fs ft nv fv fx dk translated">python .平原英语. io</p></div></div><div class="ny l"><div class="nz l oa ob oc ny od kq np"/></div></div></a></div><div class="nm nn gq gs no np"><a rel="noopener  ugc nofollow" target="_blank" href="/features-that-every-developer-must-know-about-spring-boot-c1c0d7f1c0a8"><div class="nq ab fp"><div class="nr ab ns cl cj nt"><h2 class="bd is gz z fq nu fs ft nv fv fx iq bi translated">每个开发人员都必须知道的关于Spring Boot的特性</h2><div class="nw l"><h3 class="bd b gz z fq nu fs ft nv fv fx dk translated">该框架通常被称为“类固醇上的弹簧”，的确如此。</h3></div><div class="nx l"><p class="bd b dl z fq nu fs ft nv fv fx dk translated">blog.devgenius.io</p></div></div><div class="ny l"><div class="oe l oa ob oc ny od kq np"/></div></div></a></div></div></div>    
</body>
</html>