<html>
<head>
<title>Memory Allocation in C++</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C++中的内存分配</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/memory-allocation-in-c-2520c266ad0b?source=collection_archive---------0-----------------------#2020-07-31">https://blog.devgenius.io/memory-allocation-in-c-2520c266ad0b?source=collection_archive---------0-----------------------#2020-07-31</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="ec3d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ki">c++中的静态内存分配和动态内存分配。</em></p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/ecc625489a7ef0129826f6e7ecc9db88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*JLgmmZjQi-6obsJ2"/></div></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk translated"><a class="ae kz" href="https://unsplash.com/@annadyakov1999?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">安娜·季娅科娃</a>在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="2e4a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">每个变量使用计算机内存空间来存储它的值。</p><p id="79db" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当我们使用术语<strong class="jm io">分配</strong>时，我们表示该变量已经在计算机内存上被给定了一个空间。</p><p id="2d41" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> Deallocations </strong>表示空间已经被计算机回收，现在无法访问该变量。</p><p id="3d30" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">本文解释了在 C++编程语言中，如何将这些内存分配给变量。</p></div><div class="ab cl la lb hr lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ig ih ii ij ik"><p id="939b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">记忆分为两部分。第一个叫做<strong class="jm io">堆栈内存</strong>，另一个叫做<strong class="jm io">堆内存</strong>。</p><blockquote class="lh li lj"><p id="f69a" class="jk jl ki jm b jn jo jp jq jr js jt ju lk jw jx jy ll ka kb kc lm ke kf kg kh ig bi translated"><em class="in">堆栈内存</em>存储函数调用中声明的变量，通常比堆内存小。</p><p id="3167" class="jk jl ki jm b jn jo jp jq jr js jt ju lk jw jx jy ll ka kb kc lm ke kf kg kh ig bi translated"><em class="in">堆内存</em>用于动态内存分配，一般大于堆栈内存。</p></blockquote></div><div class="ab cl la lb hr lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ig ih ii ij ik"><p id="b735" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">C++中的内存分配有两种方法。</p><p id="013b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">其中之一是<strong class="jm io"> <em class="ki">静态内存分配</em> </strong>，也称为编译时分配。</p><p id="e788" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">另一种叫做<strong class="jm io"> <em class="ki">动态内存分配</em> </strong>，也就是运行时分配。</p></div><div class="ab cl la lb hr lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ig ih ii ij ik"><h1 id="a0a1" class="ln lo in bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">静态内存分配</h1><blockquote class="ml"><p id="ff93" class="mm mn in bd mo mp mq mr ms mt mu kh dk translated">在静态内存分配中，变量的大小和存储位置在编译时是固定的。</p></blockquote><p id="1283" class="pw-post-body-paragraph jk jl in jm b jn mv jp jq jr mw jt ju jv mx jx jy jz my kb kc kd mz kf kg kh ig bi translated">让我们使用下面的代码来看看静态内存分配是如何发生的。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="632a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">上面的代码中有三个变量，<strong class="jm io"> x </strong>是一个整数变量，<strong class="jm io"> ch </strong>是一个字符变量，<strong class="jm io"> a </strong>是一个整数数组。</p><p id="5571" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在静态内存分配中，编译器会计算这些变量需要多少内存，并确定这些变量的存储位置。</p><p id="cd0c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">想象一个如下的符号表，</p><blockquote class="lh li lj"><p id="1331" class="jk jl ki jm b jn jo jp jq jr js jt ju lk jw jx jy ll ka kb kc lm ke kf kg kh ig bi translated">答— -&gt; 0</p><p id="6cbd" class="jk jl ki jm b jn jo jp jq jr js jt ju lk jw jx jy ll ka kb kc lm ke kf kg kh ig bi translated">ch —-&gt; 401</p><p id="bd66" class="jk jl ki jm b jn jo jp jq jr js jt ju lk jw jx jy ll ka kb kc lm ke kf kg kh ig bi translated">x — -&gt;402</p></blockquote><p id="446b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用这样的表，变量的存储位置就被保存了。但是，实际的物理内存是<strong class="jm io">而不是</strong>在编译时分配给变量的。</p><blockquote class="ml"><p id="e8c1" class="mm mn in bd mo mp mq mr ms mt mu kh dk translated">实际的物理内存只在运行时分配。</p></blockquote><p id="a01f" class="pw-post-body-paragraph jk jl in jm b jn mv jp jq jr mw jt ju jv mx jx jy jz my kb kc kd mz kf kg kh ig bi translated">关于静态内存分配其他一些要点如下:</p><ol class=""><li id="6051" class="nc nd in jm b jn jo jr js jv ne jz nf kd ng kh nh ni nj nk bi translated">静态内存分配<strong class="jm io">略快于动态内存分配</strong>。</li><li id="e025" class="nc nd in jm b jn nl jr nm jv nn jz no kd np kh nh ni nj nk bi translated">这种类型的内存分配不太灵活。</li><li id="5a0f" class="nc nd in jm b jn nl jr nm jv nn jz no kd np kh nh ni nj nk bi translated">内存的分配和释放是由编译器自己完成的。</li></ol></div><div class="ab cl la lb hr lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ig ih ii ij ik"><h1 id="19d8" class="ln lo in bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">动态存储分配</h1><blockquote class="ml"><p id="adf8" class="mm mn in bd mo mp mq mr ms mt mu kh dk translated">动态内存分配允许您在程序执行期间定义内存需求。</p></blockquote><p id="842b" class="pw-post-body-paragraph jk jl in jm b jn mv jp jq jr mw jt ju jv mx jx jy jz my kb kc kd mz kf kg kh ig bi translated">动态内存分配使用特殊类型的内存，称为<strong class="jm io">堆内存。</strong>不要把这和堆数据结构混淆。</p><p id="de31" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在动态内存分配中，<strong class="jm io"> new </strong>关键字用于<strong class="jm io">分配</strong>内存，<strong class="jm io"> delete </strong>关键字用于<strong class="jm io">释放</strong>内存。</p><p id="cc8b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">与静态内存分配不同，内存的分配和释放应该由程序员来完成。这意味着程序员需要编写代码来分配和释放内存。</p><p id="9534" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> <em class="ki"> new </em> </strong>关键字返回已经分配给<strong class="jm io"> <em class="ki">堆内存</em> </strong>上的变量的地址。这发生在程序执行期间。</p><p id="301c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们看看如何在运行时使用下面的代码动态分配内存。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="d1f9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在上面的代码中，有一个变量<strong class="jm io"> n </strong>是整型变量<strong class="jm io"> arr </strong>是整型指针。这两个变量都存储在内存的静态部分。</p><p id="44b8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是在程序执行过程中，根据<em class="ki"> n </em>的值，<strong class="jm io">new<em class="ki">new</em>new</strong>关键字返回数组已经分配的内存在堆上的物理地址。</p><p id="004d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">请仔细阅读上述声明，以了解该程序的工作。</p><blockquote class="lh li lj"><p id="c3f0" class="jk jl ki jm b jn jo jp jq jr js jt ju lk jw jx jy ll ka kb kc lm ke kf kg kh ig bi translated"><strong class="jm io"> <em class="in"> arr </em> </strong>指向数组存储的地址。这里所说的地址是由<strong class="jm io"> <em class="in"> new </em> </strong>关键字返回的地址。</p></blockquote><p id="ac98" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">关于动态内存分配，需要注意的其他一些要点如下:</p><ol class=""><li id="8f65" class="nc nd in jm b jn jo jr js jv ne jz nf kd ng kh nh ni nj nk bi translated">动态内存分配的好处在于<strong class="jm io"> <em class="ki">重用</em> </strong>的内存是可能的。</li><li id="b0e8" class="nc nd in jm b jn nl jr nm jv nn jz no kd np kh nh ni nj nk bi translated">内存泄漏是可能的。程序员在将内存重新分配给另一个变量时需要小心。</li><li id="34ca" class="nc nd in jm b jn nl jr nm jv nn jz no kd np kh nh ni nj nk bi translated">编译器不帮助分配和释放。程序员需要分配和释放内存。</li></ol></div><div class="ab cl la lb hr lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ig ih ii ij ik"><p id="f9f7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是 C++中的内存分配。感谢你的阅读，我希望你有一个好的阅读。祝你愉快！</p></div></div>    
</body>
</html>