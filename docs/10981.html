<html>
<head>
<title>DWITE ’09 R6 #5 — Air Travel Planning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">DWITE’09 R6 第 5 期—航空旅行规划</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/dwite-09-r6-5-air-travel-planning-b6c57103457d?source=collection_archive---------17-----------------------#2022-12-11">https://blog.devgenius.io/dwite-09-r6-5-air-travel-planning-b6c57103457d?source=collection_archive---------17-----------------------#2022-12-11</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="4ec5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了解决这个问题，我将不得不引入两个新概念。数据结构和贝尔曼-福特算法。</p><p id="58f9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然而，在我开始解释这些概念之前，我想让你尝试一下你自己解决这个问题的方法。我将给出一些解决这个问题的提示:给你一个带权边的有向图，要求你找出单源最短路径。</p><p id="1ad0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在让我们开始讨论这些概念。我们将从数据结构开始。这些在 C++中是真实存在的，你可以如下初始化它们:</p><pre class="kj kk kl km gt kn ko kp bn kq kr bi"><span id="591a" class="ks kt in ko b be ku kv l kw kx">struct type_name {<br/>member_type1 member_name1;<br/>member_type2 member_name2;<br/>member_type3 member_name3;<br/>};</span></pre><p id="e87d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这允许你创建一个新的数据结构。在这个数据结构中，您可以定义变量，这些变量是 member_nameX，其类型为 member_type。基本上，它允许您将一堆不同的数据结构组合在一起，以简化您的代码。对于这个问题，我们将使用这个来帮助制作我们的图表。我们将创建一个名为 Edge 的结构，它有 3 个变量，to、from 和 cost。这将描述从两个地方去的费用。我们需要使用这个，因为没有其他(据我所知)数据结构可以让你轻松地存储 3 种类型，特别是考虑到我们使用两个字符串和一个整数。该结构的代码如下所示:</p><pre class="kj kk kl km gt kn ko kp bn kq kr bi"><span id="1924" class="ks kt in ko b be ku kv l kw kx">struct Edge {<br/>  string to, from;<br/>  int cost;<br/>};</span></pre><p id="3c4e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在我们已经有了结构，我们必须做算法。对于这个问题，我决定使用贝尔曼福特算法，因为它更容易理解，它有一个快速的实现和略快于 Dijkstra 的时间复杂度。我们首先创建一个 hash_map 结构，它将存储从源点到该点的距离。在这种情况下，收到输入后，我们将立即将该节点的值设置为 INT_MAX，这样就可以清楚地看到您还没有访问过它，并且它的值不能进入最短路径。我们将把图形表示为边的数组(向量)。注意边上的大写 E，因为我们将使用新的数据结构。</p><p id="9901" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后是贝尔曼-福特算法。我们首先将源节点的“成本”设置为 0。然后我们循环所有的成本，然后通过边嵌套一个循环，并找到最小距离。请允许我详细说明。你遍历所有的成本，并根据它是否在图中找到一个更便宜的成本来最小化它。让我们看看这个算法的伪代码:</p><pre class="kj kk kl km gt kn ko kp bn kq kr bi"><span id="7ee3" class="ks kt in ko b be ku kv l kw kx">costs = {place:cost}<br/>array = [Edge, Edge... Edge]<br/>Loop through all the costs:<br/>    Loop through the edges:<br/>        cost[current_edge.to] = min(costs[current_edge.from] + current_edge.cost, costs[current_edge.to])<br/>The algorithm consists of several phases. Each phase scans through all edges of the graph, and the algorithm tries to produce relaxation along each edge  $(a,b)$  having weight  $c$ . Relaxation along the edges is an attempt to improve the value  $d[b]$  using value  $d[a] + c$ . In fact, it means that we are trying to improve the answer for this vertex using edge  $(a,b)$  and current response for vertex  $a$ .</span></pre><p id="c471" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">总而言之，该算法由几个“阶段”组成。每个阶段扫描图的所有边，算法尝试沿着权重为 C 的每条边(a，b)产生松弛。沿着边的松弛是尝试使用价值成本[a] + c 来改善价值成本[b]。实际上，这意味着我们正在尝试使用边(a，b)和顶点 a 的当前响应来改善该顶点的答案。现在让我们用 C++编写一个解决方案:</p><pre class="kj kk kl km gt kn ko kp bn kq kr bi"><span id="0d55" class="ks kt in ko b be ku kv l kw kx">#include &lt;vector&gt;<br/>#include &lt;math.h&gt;<br/>#include &lt;iostream&gt;<br/>#include &lt;bitset&gt;<br/>#include &lt;cstdio&gt;<br/>#include &lt;algorithm&gt;<br/>#include &lt;map&gt;<br/>#include &lt;string&gt;<br/>#include &lt;queue&gt;<br/>#include &lt;set&gt;<br/>#include &lt;climits&gt;<br/>#include &lt;unordered_map&gt;<br/>#include &lt;stack&gt;<br/>#include &lt;cmath&gt;<br/>#include &lt;iomanip&gt;<br/>#include &lt;list&gt;<br/>#include &lt;numeric&gt;<br/>#include &lt;random&gt;<br/><br/>using namespace std;<br/>#define PI 3.14159265358979323851<br/><br/>#define endl "\n"<br/>#define ll long long<br/>char _;<br/>#define scan(x) do{while((x=getchar())&lt;'0'); for(x-='0'; '0'&lt;=(_=getchar()); x=(x&lt;&lt;3)+(x&lt;&lt;1)+_-'0');}while(0)<br/><br/>struct Edge {<br/> string from;<br/> string to;<br/> int cost;<br/>};<br/><br/><br/>int main()<br/>{<br/> for (int www = 0; www &lt; 5; www++) {<br/>  int N;<br/>  cin &gt;&gt; N;<br/>  map&lt;string, int&gt; costs;<br/>  vector&lt;Edge&gt; edges;<br/>  for (int i = 0; i &lt; N; i++) {<br/>   string S1, S2;<br/>   int cost;<br/>   cin &gt;&gt; S1 &gt;&gt; S2 &gt;&gt; cost;<br/>   Edge New;<br/>   New.from = S1;<br/>   New.to = S2;<br/>   New.cost = cost;<br/>   edges.push_back(New);<br/>   costs[S1] = INT_MAX;<br/>   costs[S2] = INT_MAX;<br/>  }<br/>  costs["YYZ"] = 0;<br/>  for (int i = 0; i &lt; costs.size(); i++) {<br/>   for (Edge e : edges) {<br/>    int cost = min(costs[e.from] + e.cost, costs[e.to]);<br/>    costs[e.to] = cost;<br/>   }<br/>  }<br/>  cout &lt;&lt; costs["SEA"] &lt;&lt; endl;<br/><br/> }<br/>}</span></pre><p id="13bf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我希望这能帮助你更好地理解这个问题。请随意对你希望看到的其他问题发表评论，并留下赞。</p></div></div>    
</body>
</html>