<html>
<head>
<title>Airflow — Deferrable Operators</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">气流—可延迟的操作者</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/airflow-deferrable-operators-5a7c90aaa14f?source=collection_archive---------5-----------------------#2022-08-24">https://blog.devgenius.io/airflow-deferrable-operators-5a7c90aaa14f?source=collection_archive---------5-----------------------#2022-08-24</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/b0637ac77eda278d1146c7077f55469c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DUOaCDVzHj8TBknuARLGFg.jpeg"/></div></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk translated">图片来源谷歌</figcaption></figure><div class=""/><p id="970b" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">通过在任务空闲时释放工作人员来节省资源</p><p id="d08d" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">气流以工人的概念运作。为了管理任务，它还提供了像槽、池和优先级这样的概念。当一个任务运行时，它会占用一个工作线程。传感器和操作员在运行的整个过程中会占用一个完整的工作插槽，而不管其空闲状态如何。假设我们在一个集群上提交一个 spark 作业，该作业可能需要 70 分钟才能完成，因此在整个 70 分钟内，SparkOperator 会消耗一个 worker 槽。这是一种资源浪费，因为气流除了等待 spark 任务完成之外什么也不做。类似的事情也发生在传感器上。他们继续寻找成功的事件，但是实际的工作在寻找间隔期间只发生一次。休息所有的时间，它只是无所事事。</p><blockquote class="kx ky kz"><p id="c402" class="jz ka la kb b kc kd ke kf kg kh ki kj lb kl km kn lc kp kq kr ld kt ku kv kw ig bi translated">因此，如果实际的工作是在气流之外完成的，那么任务就会闲置，等待完成信号。</p></blockquote><figure class="lf lg lh li gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi le"><img src="../Images/64919305c4b7fabaa4f09f88d38ac1d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*68mLDPihaA4PDVL2oazz2Q.png"/></div></div></figure><p id="3ca8" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">传感器有两种运行模式。1.戳&amp; 2。重新计划模式，在重新计划模式中，传感器会自我杀死，并在下一次戳计划中再次活着回来。但是在 Airflow 2.1 之前，我们没有办法优化空闲的工作人员。</p><p id="c66d" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在 Airflow 2.2 中，增加了一种新的操作符，称为 Deferrable Operator。这些可推迟的操作符比智能传感器更受欢迎。</p><figure class="lf lg lh li gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi lj"><img src="../Images/064fcc87d16c4ebcf30c598e64bc0385.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GdWRfJqUOi47JAcn0slQ-A.png"/></div></div></figure><h2 id="57a7" class="lk ll jc bd lm ln lo dn lp lq lr dp ls kk lt lu lv ko lw lx ly ks lz ma mb mc bi translated">可推迟的操作员</h2><p id="2a97" class="pw-post-body-paragraph jz ka jc kb b kc md ke kf kg me ki kj kk mf km kn ko mg kq kr ks mh ku kv kw ig bi translated">可延迟的操作符挂起自己并释放工作线程。他们把检查和采取行动的工作交给触发器。一旦操作员推迟了他们自己，他们就进入了一个叫做<strong class="kb jd">推迟的新状态。</strong>在此状态下，操作员将被停止并从其工作插槽中移除。一旦触发器找到其成功的条件检查，它将按照操作员定义的特定方法恢复操作员。</p><h2 id="1dbb" class="lk ll jc bd lm ln lo dn lp lq lr dp ls kk lt lu lv ko lw lx ly ks lz ma mb mc bi translated">触发器</h2><p id="6e8a" class="pw-post-body-paragraph jz ka jc kb b kc md ke kf kg me ki kj kk mf km kn ko mg kq kr ks mh ku kv kw ig bi translated">触发器是一小段异步 python 代码，可以快速连续地评估条件。由于占用空间小，数千个这样的小任务可以在一个单亲进程中运行。这个单亲进程被称为触发器服务。</p><h2 id="c6c3" class="lk ll jc bd lm ln lo dn lp lq lr dp ls kk lt lu lv ko lw lx ly ks lz ma mb mc bi translated">触发器服务</h2><p id="91ec" class="pw-post-body-paragraph jz ka jc kb b kc md ke kf kg me ki kj kk mf km kn ko mg kq kr ks mh ku kv kw ig bi translated">类似于调度程序服务，触发器服务运行一个事件循环。这里的不同之处在于，这是一个 aysncio 事件循环。当条件满足时，此流程运行触发器并发出任务恢复的信号。</p><p id="7516" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">可推迟操作符的新流程如下所示。</p><blockquote class="kx ky kz"><p id="9356" class="jz ka la kb b kc kd ke kf kg kh ki kj lb kl km kn lc kp kq kr ld kt ku kv kw ig bi translated"><strong class="kb jd">运行→延迟→触发→排队</strong></p></blockquote><p id="0312" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">要使用可推迟操作符，我们需要满足某些先决条件。</p><ul class=""><li id="8fb8" class="mi mj jc kb b kc kd kg kh kk mk ko ml ks mm kw mn mo mp mq bi translated">Python 3.7+(由于 asyncio)</li><li id="9360" class="mi mj jc kb b kc mr kg ms kk mt ko mu ks mv kw mn mo mp mq bi translated">气流版本 2.2 以上</li><li id="9c92" class="mi mj jc kb b kc mr kg ms kk mt ko mu ks mv kw mn mo mp mq bi translated">触发气流装置中的服务启动和运行</li><li id="868e" class="mi mj jc kb b kc mr kg ms kk mt ko mu ks mv kw mn mo mp mq bi translated">操作员必须通过调用触发器来推迟自己。<code class="fe mw mx my mz b">self.defer(trigger, method_name, kwargs, timeout)</code>。一旦触发完成，<code class="fe mw mx my mz b">method_name</code>将成为恢复点。</li></ul><pre class="lf lg lh li gt na mz nb nc aw nd bi"><span id="1a3f" class="lk ll jc mz b gy ne nf l ng nh">from datetime import timedelta<br/><br/>from airflow.sensors.base import BaseSensorOperator<br/>from airflow.triggers.temporal import TimeDeltaTrigger<br/><br/><br/><strong class="mz jd">class</strong> WaitOneHourSensor(BaseSensorOperator):<br/>    <strong class="mz jd">def</strong> execute(self, context):<br/>        self.defer(trigger=TimeDeltaTrigger(timedelta(hours=1)), method_name="execute_complete")<br/><br/>    <strong class="mz jd">def</strong> execute_complete(self, context, event=<strong class="mz jd">None</strong>):<br/>        <em class="la"># We have no more work to do here. Mark as complete.</em><br/>        <strong class="mz jd">return</strong></span></pre><p id="195a" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><code class="fe mw mx my mz b">BaseTrigger</code>位于<code class="fe mw mx my mz b">airflow.triggers.base.BaseTrigger</code>，<code class="fe mw mx my mz b">TriggerEvent</code>位于<code class="fe mw mx my mz b">airflow.triggers.base.TriggerEvent</code>。</p><ul class=""><li id="2078" class="mi mj jc kb b kc kd kg kh kk mk ko ml ks mm kw mn mo mp mq bi translated">触发器是操作员将遵从的核心或定制代码。</li><li id="2d35" class="mi mj jc kb b kc mr kg ms kk mt ko mu ks mv kw mn mo mp mq bi translated">触发器必须是可序列化的，因为它保存在数据库中。</li></ul><pre class="lf lg lh li gt na mz nb nc aw nd bi"><span id="6e85" class="lk ll jc mz b gy ne nf l ng nh">import asyncio<br/><br/>from airflow.triggers.base import BaseTrigger, TriggerEvent<br/>from airflow.utils import timezone<br/><br/><br/><strong class="mz jd">class </strong>DateTimeTrigger(BaseTrigger):<br/><br/>    <strong class="mz jd">def</strong> __init__(self, moment):<br/>        super().__init__()<br/>        self.moment = moment<br/><br/>    <strong class="mz jd">def</strong> serialize(self):<br/>        <strong class="mz jd">return</strong> ("airflow.triggers.temporal.DateTimeTrigger", {"moment": self.moment})<br/><br/>    <strong class="mz jd">async</strong> <strong class="mz jd">def</strong> run(self):<br/>        <strong class="mz jd">while</strong> self.moment &gt; timezone.utcnow():<br/>            <strong class="mz jd">await</strong> asyncio.sleep(1)<br/>        <strong class="mz jd">yield</strong> TriggerEvent(self.moment)</span></pre><h2 id="ca9f" class="lk ll jc bd lm ln lo dn lp lq lr dp ls kk lt lu lv ko lw lx ly ks lz ma mb mc bi translated">提供商提供的运算符</h2><ul class=""><li id="9215" class="mi mj jc kb b kc md kg me kk ni ko nj ks nk kw mn mo mp mq bi translated">databricksubmitrundeferrableoperator</li><li id="5fa3" class="mi mj jc kb b kc mr kg ms kk mt ko mu ks mv kw mn mo mp mq bi translated">BigQueryInsertJobOperator</li><li id="5348" class="mi mj jc kb b kc mr kg ms kk mt ko mu ks mv kw mn mo mp mq bi translated">GCSToBigQueryOperator</li><li id="6280" class="mi mj jc kb b kc mr kg ms kk mt ko mu ks mv kw mn mo mp mq bi translated">SnowflakeOperatorAsync(来自天文学家)</li></ul><h2 id="7216" class="lk ll jc bd lm ln lo dn lp lq lr dp ls kk lt lu lv ko lw lx ly ks lz ma mb mc bi translated">可延迟运算符的优势</h2><ul class=""><li id="9097" class="mi mj jc kb b kc md kg me kk ni ko nj ks nk kw mn mo mp mq bi translated">减少资源消耗—可延迟的操作员可以减少在高并发期间运行任务所需的工作人员/K8s Pod 数量。</li><li id="ea35" class="mi mj jc kb b kc mr kg ms kk mt ko mu ks mv kw mn mo mp mq bi translated">故障恢复能力—触发器服务在 HA 模式下运行，正常重启，不会出现故障。在基础设施故障的情况下，触发器通过查看数据库来恢复该过程。</li><li id="ea95" class="mi mj jc kb b kc mr kg ms kk mt ko mu ks mv kw mn mo mp mq bi translated">离事件驱动的 Dag 更近了一步</li></ul><h2 id="8719" class="lk ll jc bd lm ln lo dn lp lq lr dp ls kk lt lu lv ko lw lx ly ks lz ma mb mc bi translated">警告</h2><ul class=""><li id="52aa" class="mi mj jc kb b kc md kg me kk ni ko nj ks nk kw mn mo mp mq bi translated">不是所有事情都可以推迟。</li><li id="0304" class="mi mj jc kb b kc mr kg ms kk mt ko mu ks mv kw mn mo mp mq bi translated">UI 中不存在触发日志</li></ul><p id="68fb" class="pw-post-body-paragraph jz ka jc kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">流水线作业快乐！！！</p></div></div>    
</body>
</html>