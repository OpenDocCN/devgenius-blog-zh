<html>
<head>
<title>Microservices with Circuit Breaker pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">断路器模式的微服务</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/microservices-with-circuit-breaker-pattern-5fef166e4cc4?source=collection_archive---------2-----------------------#2022-07-17">https://blog.devgenius.io/microservices-with-circuit-breaker-pattern-5fef166e4cc4?source=collection_archive---------2-----------------------#2022-07-17</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><ul class=""><li id="30f5" class="jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">这里我们将讨论如何用断路器模式保护/创建可持续服务。</li></ul><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/f12386854f947b1ad0d7b98548900460.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cNQlLOVPGse-9qZYWbdyRA.png"/></div></div></figure><ul class=""><li id="a48a" class="jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">正如我们在上一篇<a class="ae ko" href="https://medium.com/@imilamaheshan30/design-patterns-for-microservices-1399eea583b7" rel="noopener">文章</a>中所讨论的，我们已经提到了 4 种不同的服务，所以当我们有多个服务时，这些服务很可能有多个后端。所以我们可以创建一个类似聚合器的模式来调用这些服务。</li><li id="e1f5" class="jk jl in jm b jn kp jp kq jr kr jt ks jv kt jx jy jz ka kb bi translated">服务的可用性:我们通常说服务是 99.999%的正常运行时间得到保证。</li></ul><p id="b8da" class="pw-post-body-paragraph ku kv in jm b jn jo kw kx jp jq ky kz jr la lb lc jt ld le lf jv lg lh li jx ig bi translated"><strong class="jm io">但是…… </strong></p><blockquote class="lj lk ll"><p id="bcf7" class="ku kv lm jm b jn jo kw kx jp jq ky kz ln la lb lc lo ld le lf lp lg lh li jx ig bi translated">99.999%的运行时间意味着 0.001 的停机时间。</p><p id="fcab" class="ku kv lm jm b jn jo kw kx jp jq ky kz ln la lb lc lo ld le lf lp lg lh li jx ig bi translated">这意味着每年有 5.256 分钟的停机时间。(525600 分钟*0.001=5.25 分钟)</p><p id="01e7" class="ku kv lm jm b jn jo kw kx jp jq ky kz ln la lb lc lo ld le lf lp lg lh li jx ig bi translated">但是在微服务架构中有多个服务，假设我们有 100 个服务，那么将有(100*5.25 分钟=525 分钟)525 分钟的停机时间，这是不可接受的。</p></blockquote><p id="1855" class="pw-post-body-paragraph ku kv in jm b jn jo kw kx jp jq ky kz jr la lb lc jt ld le lf jv lg lh li jx ig bi translated"><strong class="jm io">让我们看看中断服务的情况有哪些:</strong></p><ul class=""><li id="bfb5" class="jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">假设我们有 5 个不同的微服务，我们通过 web 服务器调用它。我们有 5 个服务，当我们收到请求时，这意味着一个服务分配一个线程来调用后端(个人信息服务)。</li></ul><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi lq"><img src="../Images/0820b5348df715cbecbb2cfb92cd5079.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6H_IQJAifZO2gfg8fdp1MQ.png"/></div></div></figure><ul class=""><li id="8f9e" class="jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">这里个人信息服务使用一个线程。所以一个线程被分配给该服务。现在服务有点延迟-线程正在等待，直到超时。</li><li id="18cd" class="jk jl in jm b jn kp jp kq jr kr jt ks jv kt jx jy jz ka kb bi translated">一个线程等待很好。那将是相当长的等待时间。但是，如果许多线程都要等待超时，那该怎么办呢？</li></ul><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi lr"><img src="../Images/235f813883a86eef4ee83a5777093e78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XwqYBRiL5PNeUpdbKhnP6A.png"/></div></div></figure><ul class=""><li id="9027" class="jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">如果服务是高需求服务，当它将有更多的请求。因此线程池中的线程一个接一个地等待。同时，其他空闲线程可以分配给其他服务。</li></ul><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ls"><img src="../Images/4a75a49f83c2fa24a2cf49f86c4cb8b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TB2Os3u2chnHUQaWaQvlFg.png"/></div></div></figure><blockquote class="lj lk ll"><p id="2742" class="ku kv lm jm b jn jo kw kx jp jq ky kz ln la lb lc lo ld le lf lp lg lh li jx ig bi translated">因此此后所有的线程都将被阻塞。</p><p id="aa25" class="ku kv lm jm b jn jo kw kx jp jq ky kz ln la lb lc lo ld le lf lp lg lh li jx ig bi translated">现在，进入此服务的剩余线程将被排队。web 服务仍在尝试处理队列中的所有请求。结果，此 web 服务器将永远无法恢复，因为当它处理队列时，会有越来越多的请求进入。这将导致服务中断。所以服务会下线。</p></blockquote><p id="a243" class="pw-post-body-paragraph ku kv in jm b jn jo kw kx jp jq ky kz jr la lb lc jt ld le lf jv lg lh li jx ig bi translated"><strong class="jm io">解决方案:</strong></p><blockquote class="lj lk ll"><p id="0133" class="ku kv lm jm b jn jo kw kx jp jq ky kz ln la lb lc lo ld le lf lp lg lh li jx ig bi translated">断路器模式</p></blockquote><ul class=""><li id="26cf" class="jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">假设您已经定义了阈值，它应该在 200 毫秒内响应。</li><li id="bed0" class="jk jl in jm b jn kp jp kq jr kr jt ks jv kt jx jy jz ka kb bi translated">如果大量请求(假设 75%)达到上限(150 到 200 之间)，这意味着现在服务正在缓慢失败。</li><li id="fea1" class="jk jl in jm b jn kp jp kq jr kr jt ks jv kt jx jy jz ka kb bi translated">因此，如果发生次数超过 200 毫秒，这是您为该服务设置的最大阈值。</li><li id="2adc" class="jk jl in jm b jn kp jp kq jr kr jt ks jv kt jx jy jz ka kb bi translated">如果它超过了你可以配置的次数，那么这个代理知道服务不再响应，所以下一个访问服务的请求将会失败。(断开代理和服务之间的连接)这意味着它不会等待。</li></ul><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi lt"><img src="../Images/4102eea9067502f886e831dc019b3e56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6MVNFJduMbflFv3WFBel3g.png"/></div></div></figure><ul class=""><li id="07e1" class="jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">假设我们有 30 秒的暂停。如果每个请求都试图命中服务而不考虑其失败，所有来自消费者的请求将等待 30 秒。最终循环结束，一切都将超时。但是在这 30 秒的时间内，服务 a 将尝试注册到达消费者的剩余资源。那些人正在排队等候。</li><li id="187c" class="jk jl in jm b jn kp jp kq jr kr jt ks jv kt jx jy jz ka kb bi translated">现在，断路器模式所做的是，如果故障超过给定阈值，它将根本不会尝试运行服务。它将回切到消费者，说服务 a 不可用。</li></ul><p id="6c32" class="pw-post-body-paragraph ku kv in jm b jn jo kw kx jp jq ky kz jr la lb lc jt ld le lf jv lg lh li jx ig bi translated">因此，让我们看看它将如何连接回来…</p><ul class=""><li id="126b" class="jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">它确实在后台，在 ping 请求中。当该响应时间回到正常阈值时，它将再次接通该电路。</li><li id="18a4" class="jk jl in jm b jn kp jp kq jr kr jt ks jv kt jx jy jz ka kb bi translated">这意味着剩余的使用<strong class="jm io">服务 A </strong>的请求将直接发送到<strong class="jm io">服务 A。</strong>在失败期间，使用<strong class="jm io">服务 A、</strong>的所有记录都将返回错误消息。</li><li id="ecc1" class="jk jl in jm b jn kp jp kq jr kr jt ks jv kt jx jy jz ka kb bi translated">所以现在没有排队。当服务备份时，它将消耗新的流量。</li></ul><p id="563c" class="pw-post-body-paragraph ku kv in jm b jn jo kw kx jp jq ky kz jr la lb lc jt ld le lf jv lg lh li jx ig bi translated">参考:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="e1cf" class="pw-post-body-paragraph ku kv in jm b jn jo kw kx jp jq ky kz jr la lb lc jt ld le lf jv lg lh li jx ig bi translated">请继续关注我的博客，下一篇文章将讨论使用代理模式的微服务。</p></div></div>    
</body>
</html>