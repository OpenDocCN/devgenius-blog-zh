<html>
<head>
<title>Object-Oriented JavaScript — Inheritance and Copying Objects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向对象的 JavaScript —继承和复制对象</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/object-oriented-javascript-inheritance-and-copying-objects-439bbba1a6aa?source=collection_archive---------5-----------------------#2020-11-18">https://blog.devgenius.io/object-oriented-javascript-inheritance-and-copying-objects-439bbba1a6aa?source=collection_archive---------5-----------------------#2020-11-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/68c1c8bafaeebc77eac521ee2711e81e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Uq52tDb_AYEHZ6yJ"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@louishansel?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">路易斯·汉瑟@shotsoflouis </a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="ffab" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JavaScript 部分是面向对象的语言。</p><p id="7b04" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要学习 JavaScript，我们必须学习 JavaScript 的面向对象部分。</p><p id="6eb1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这篇文章中，我们将看看复制对象。</p><h1 id="f41d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">深层拷贝</h1><p id="3915" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过将对象的属性从源对象递归复制到目标对象来深度复制对象。</p><p id="21d3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="a122" class="mn lc iq mj b gy mo mp l mq mr">function deepCopy(source, target = {}) {<br/>  for (const key in source) {<br/>    if (source.hasOwnProperty(key)) {<br/>      if (typeof source[key] === 'object') {<br/>        target[key] = Array.isArray(source[key]) ? [] : {};<br/>        deepCopy(source[key], target[key]);<br/>      } else {<br/>        target[key] = source[key];<br/>      }<br/>    }<br/>  }<br/>  return target;<br/>}</span></pre><p id="ffc1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们循环通过<code class="fe ms mt mu mj b">source</code>的每个键。</p><p id="8e08" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们检查每一处房产是否是自有房产。</p><p id="2150" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们检查<code class="fe ms mt mu mj b">source[key]</code>对象是否是一个对象。</p><p id="a41f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果<code class="fe ms mt mu mj b">source[key]</code>是一个数组，那么我们创建一个数组，然后进行复制。</p><p id="eeab" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果它是一个对象，那么我们递归地调用<code class="fe ms mt mu mj b">deepCopy</code>进行复制。</p><p id="0f93" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">否则，我们将来自<code class="fe ms mt mu mj b">source</code>的值赋给<code class="fe ms mt mu mj b">target</code>。</p><p id="9c81" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦这些都完成了，我们就返回<code class="fe ms mt mu mj b">target</code>。</p><p id="a14b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以通过写来使用它:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="885f" class="mn lc iq mj b gy mo mp l mq mr">const foo = {<br/>  a: 1,<br/>  b: {<br/>    c: 2<br/>  }<br/>}<br/>const bar = deepCopy(foo, {});</span><span id="501b" class="mn lc iq mj b gy mv mp l mq mr">console.log(bar);</span></pre><p id="2725" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">deepCopy</code>将把所有自己的属性从<code class="fe ms mt mu mj b">foo</code>递归复制到<code class="fe ms mt mu mj b">bar</code>。</p><p id="38ba" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以<code class="fe ms mt mu mj b">bar</code>是:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="42d0" class="mn lc iq mj b gy mo mp l mq mr">{<br/>  "a": 1,<br/>  "b": {<br/>    "c": 2<br/>  }<br/>}</span></pre><p id="4833" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">Array.isArray</code>不管上下文如何，让我们检查某个东西是否是数组。</p><h1 id="11f0" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用 object()方法</h1><p id="742d" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以创建一个<code class="fe ms mt mu mj b">object</code>函数来创建一个返回构造函数实例的函数。</p><p id="55b5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个建议来自道格拉斯·克洛克福特，它使得设置原型变得容易，因为它采用了原型对象。</p><p id="a995" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="9986" class="mn lc iq mj b gy mo mp l mq mr">function object(proto) {<br/>  function F() {}<br/>  F.prototype = proto;<br/>  return new F();<br/>}</span></pre><p id="97b1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用<code class="fe ms mt mu mj b">proto</code>属性创建了<code class="fe ms mt mu mj b">object</code>函数。</p><p id="41ec" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们将它设置为<code class="fe ms mt mu mj b">F</code>的<code class="fe ms mt mu mj b">prototype</code>。</p><p id="80b6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们返回一个<code class="fe ms mt mu mj b">F</code>的实例。</p><p id="2ecc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这与<code class="fe ms mt mu mj b">Object.create</code>不同，因为我们有一个构造函数的实例。</p><p id="6c12" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以通过书写来使用它:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="4c4e" class="mn lc iq mj b gy mo mp l mq mr">const obj = object({<br/>  foo: 1<br/>});</span></pre><p id="2cc1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么<code class="fe ms mt mu mj b">obj</code>将从我们传入的对象中继承。</p><h1 id="9b1b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">混合原型继承和复制属性</h1><p id="6377" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以混合原型继承和复制属性。</p><p id="fe92" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为此，我们可以通过编写以下代码来扩展<code class="fe ms mt mu mj b">object</code>函数:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="fc7a" class="mn lc iq mj b gy mo mp l mq mr">function object(proto, moreProps) {<br/>  function F() {}<br/>  F.prototype = proto;<br/>  const f = new F();<br/>  return {<br/>    f,<br/>    ...moreProps<br/>  };<br/>}</span><span id="3171" class="mn lc iq mj b gy mv mp l mq mr">const obj = object({<br/>  foo: 1<br/>}, {<br/>  bar: 2<br/>});</span></pre><p id="d963" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们向<code class="fe ms mt mu mj b">object</code>函数添加了一个<code class="fe ms mt mu mj b">moreProps</code>参数，这允许我们通过向它传递第二个参数来添加更多的属性。</p><p id="4970" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">moreProps</code>是传入我们返回的对象，以便我们返回新的对象。</p><p id="80fd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，<code class="fe ms mt mu mj b">obj</code>是<code class="fe ms mt mu mj b">{f: F, bar: 2}</code>，因为我们继承了<code class="fe ms mt mu mj b">F.prototype</code>和<code class="fe ms mt mu mj b">moreProps</code>。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/1b043ac626d5510987811f44321bed6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uRh6bl41PwGCDgb0"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@louishansel?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Louis Hansel @shotsoflouis </a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="09fb" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="55c0" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以将原型继承与复制属性相结合，以获得我们想要的对象的所有属性。</p><p id="7027" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">深度复制可以通过将属性从源对象递归复制到目标对象来完成。</p></div></div>    
</body>
</html>