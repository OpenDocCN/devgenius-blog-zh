<html>
<head>
<title>Game Design with Component Pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于组件模式的游戏设计</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/game-design-with-component-pattern-2e79c9a62221?source=collection_archive---------6-----------------------#2020-07-30">https://blog.devgenius.io/game-design-with-component-pattern-2e79c9a62221?source=collection_archive---------6-----------------------#2020-07-30</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="d000" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">如何创建数字游戏对象的属性</h2></div><p id="f2fa" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是游戏设计与编程模式系列的第三篇文章，着眼于编程的游戏设计方面。试试 <a class="ae kz" href="https://ovenfresh.itch.io/a-game-designers-thoughts-on-programming-patterns" rel="noopener ugc nofollow" target="_blank"> <em class="ky">中的例题实验互动补充</em> </a> <em class="ky">！</em></p><figure class="lb lc ld le gt lf gh gi paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="gh gi la"><img src="../Images/4e8086f1ce7bcc1a8b51b3f66d1cf11f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LZBXTvJJ5g8bV29f"/></div></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk translated">游戏对象的基本积木| Unsplash: @jonathanborba</figcaption></figure><p id="16e7" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">是什么格局？</strong></p><p id="d02a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在面向对象编程中，继承是如何减少重复代码和实现子类对象的主要部分。继承说，如果A从B继承，那么对象A就是对象B。当我们有长的继承链时，这可能会变得混乱，其中A是B，B是C，C是D，等等。组件模式通过将类的属性转化为自身的整体对象来解决这个问题。这些可以是值、方法等。在我们的例子中，A <strong class="ke io">有一个</strong> B、C和D。对象B、C和D以及它们的相关属性成为名义组件。</p><p id="6d6e" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这种模式很普遍。像Unity这样的流行游戏开发引擎将组件的思想嵌入到他们的框架中。因此，即使它不是一个游戏设计工具，它也是当代游戏开发实践的必要组成部分。</p><p id="6acf" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">我如何使用它</strong></p><figure class="lb lc ld le gt lf gh gi paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="gh gi lq"><img src="../Images/737c595ad60f3d16b36274b850fcbb46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*d1wMNFDkzTo5PfmqXo9p7Q.gif"/></div></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk translated">UI让我们选择将哪些组件合并到单个对象中。</figcaption></figure><p id="fc09" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在组件实验中，我创建了一个场景，在这个场景中，用户可以点击鼠标来创建带有可定制组件的对象实例。单击屏幕上的任意位置，系统会在该位置生成一个新对象，该对象包含从UI框中选择的组件。“对象A”是广义的“已创建对象”,它的所有相关属性都是组件，您可以在框中进行选择。在该框中，可以选择网格类型、移动行为和装饰组件。我挑选的两个装饰是色调变换的随机颜色和脉动的随机尺寸。这些选项中的每一个都作为在屏幕上创建对象的不同组件来实现。只需定制组件即可！每一个被创建的对象最终都会消失，因为有一个生命周期组件会倒计时直到它消失。</p><p id="0fd8" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">设计印象</strong></p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="lr ls l"/></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk translated">在这里，组件生命周期的整个概念包含在一个类描述中。它通过设计使自己保持独立。</figcaption></figure><p id="597f" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当被认为是类似的属性时，组件可以是任何东西，从输入控制器、人工智能行为、变色模式，甚至是形状和大小。“属性”这个词几乎让人觉得太小了，因为组件可以宽泛地涵盖几个属性。当考虑数字实体的构造时，组件模式提供了一种结构来考虑这些实体所具有的不同方面。使用这种结构使人们能够组织如何设计实体本身，为它们提供整洁的可编程筒仓。也就是说，属性是对象设计和系统实现的核心概念，所以组件模式对于游戏设计系统也是至关重要的。</p><p id="9aa1" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">前进</strong></p><p id="0ed8" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">使用组件结构，每一个新类都像是一个小对象世界的新构建块。我的特定实现并不复杂，但是我能够快速地制作不同的组件并混合和匹配它们。该模式将属性从实体的固有部分中分离出来，让它们成为实体所拥有的东西。组件创造了一种与数字游戏设计属性交互的组合方式。易用性激发了我作为设计师的创造力，感觉就像是我在模拟原型中做的实验。</p><p id="1243" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">往期:</strong> <a class="ae kz" href="https://medium.com/dev-genius/game-design-with-programming-patterns-flyweight-6914f1cc4772" rel="noopener"> <strong class="ke io">轻量级</strong> </a></p><p id="8d40" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">接下来:</strong> <a class="ae kz" href="https://medium.com/dev-genius/game-design-with-observer-pattern-3368561f40f5" rel="noopener"> <strong class="ke io">观察者</strong> </a></p><p id="19f6" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">代码</strong>:<a class="ae kz" href="https://github.com/jasonzli/game-programming-study" rel="noopener ugc nofollow" target="_blank">https://github.com/jasonzli/game-programming-study</a></p><p id="0580" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">参考:</strong>游戏编程模式，<em class="ky"> Nystrom，Robert 2014</em><a class="ae kz" href="http://gameprogrammingpatterns.com/command.html" rel="noopener ugc nofollow" target="_blank"><em class="ky">http://gameprogrammingpatterns.com/</em></a></p></div></div>    
</body>
</html>