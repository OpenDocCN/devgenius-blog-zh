<html>
<head>
<title>Graphs In Golang</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">戈兰语图</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/graphs-in-golang-45f7ce31fd3f?source=collection_archive---------0-----------------------#2022-12-10">https://blog.devgenius.io/graphs-in-golang-45f7ce31fd3f?source=collection_archive---------0-----------------------#2022-12-10</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="79ff" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">图形数据结构的实现</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi kc"><img src="../Images/f3c474249b8577ba40af33ad2fdaa6b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1222/format:webp/1*5uhmVd1pxU-JzTzGBRGHhg.png"/></div></figure><h2 id="0f68" class="kk kl in bd km kn ko dn kp kq kr dp ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">定义</h2><blockquote class="lg lh li"><p id="9f42" class="lj lk ll lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated"><strong class="lm io">图</strong> : <em class="in">与数组不同，图是由顶点和边组成的非线性数据结构。</em></p><p id="e37e" class="lj lk ll lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated"><strong class="lm io"> <em class="in">有向图</em> </strong> <em class="in">:提到两个节点关联的图是这样的:</em><strong class="lm io"><em class="in">A-&gt;B</em></strong><em class="in">只提到</em> <code class="fe mg mh mi mj b"><em class="in">Point-A</em></code> <em class="in">和</em> <code class="fe mg mh mi mj b"><em class="in">Point-B</em></code> <em class="in">之间有一条边，其中</em> <strong class="lm io"> A 能到达 B 而 B 不能到达</strong> <em class="in">。这种图叫做有向图。</em></p><p id="49d2" class="lj lk ll lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated"><strong class="lm io"> <em class="in">无向图</em> </strong> <em class="in">:提到两个节点关联的图是这样的:</em><strong class="lm io"><em class="in">A-&gt;B</em></strong><em class="in">提到</em><code class="fe mg mh mi mj b"><em class="in">Point-A</em></code><code class="fe mg mh mi mj b"><em class="in">Point-B</em></code><em class="in">之间有一条边，其中</em> <strong class="lm io"> A 可以到达 B &amp; B 也可以到达 A</strong><em class="in">。这种图叫做无向图。</em></p></blockquote><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/478e89f1fd9171cbb24f912dd51cf176.png" data-original-src="https://miro.medium.com/v2/resize:fit:1044/format:webp/1*VrETiC5MaUFL6h_8BW4TxA.png"/></div></figure><h2 id="fd1c" class="kk kl in bd km kn ko dn kp kq kr dp ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">方法</h2><ol class=""><li id="de9c" class="ml mm in lm b ln mn lq mo kt mp kx mq lb mr mf ms mt mu mv bi translated">AddEdge:这个方法负责添加一条从<code class="fe mg mh mi mj b">Point-A</code>到<code class="fe mg mh mi mj b">Point-B</code>的有向边。</li><li id="b13f" class="ml mm in lm b ln mw lq mx kt my kx mz lb na mf ms mt mu mv bi translated">AddVertex:这个方法负责向图中添加一个顶点/节点。</li></ol><blockquote class="lg lh li"><p id="5109" class="lj lk ll lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">下面我们有一个有向图的实现:</p></blockquote><pre class="kd ke kf kg gt nb mj nc bn nd ne bi"><span id="9d06" class="nf kl in mj b be ng nh l ni nj">package datastructures<br/><br/>import "fmt"<br/><br/>// Graph structure<br/>type Graph struct {<br/> vertices []*Vertex<br/>}<br/><br/>// Adjacent Vertex<br/>type Vertex struct {<br/> key      int<br/> adjacent []*Vertex<br/>}<br/><br/>// AddVertext will add a vertex to a graph<br/>func (g *Graph) AddVertex(vertex int) error {<br/> if contains(g.vertices, vertex) {<br/>  err := fmt.Errorf("Vertex %d already exists", vertex)<br/>  return err<br/> } else {<br/>  v := &amp;Vertex{<br/>   key: vertex,<br/>  }<br/>  g.vertices = append(g.vertices, v)<br/> }<br/> return nil<br/>}<br/><br/>// AddEdge will add ad endge from a vertex to a vertex<br/>func (g *Graph) AddEdge(to, from int) error {<br/> toVertex := g.getVertex(to)<br/> fromVertex := g.getVertex(from)<br/> if toVertex == nil || fromVertex == nil {<br/>  return fmt.Errorf("Not a valid edge from %d ---&gt; %d", from, to)<br/> } else if contains(fromVertex.adjacent, toVertex.key) {<br/>  return fmt.Errorf("Edge from vertex %d ---&gt; %d already exists", fromVertex.key, toVertex.key)<br/> } else {<br/>  fromVertex.adjacent = append(fromVertex.adjacent, toVertex)<br/>  return nil<br/> }<br/>}<br/><br/>// getVertex will return a vertex point if exists or return nil<br/>func (g *Graph) getVertex(vertex int) *Vertex {<br/> for i, v := range g.vertices {<br/>  if v.key == vertex {<br/>   return g.vertices[i]<br/>  }<br/> }<br/> return nil<br/>}<br/><br/>func contains(v []*Vertex, key int) bool {<br/> for _, v := range v {<br/>  if v.key == key {<br/>   return true<br/>  }<br/> }<br/> return false<br/>}<br/><br/>func (g *Graph) Print() {<br/> for _, v := range g.vertices {<br/>  fmt.Printf("%d : ", v.key)<br/>  for _, v := range v.adjacent {<br/>   fmt.Printf("%d ", v.key)<br/>  }<br/>  fmt.Println()<br/> }<br/>}<br/><br/>func PrintEgDirectedGraph() {<br/> g := &amp;Graph{}<br/> g.AddVertex(1)<br/> g.AddVertex(2)<br/> g.AddVertex(3)<br/> g.AddEdge(1, 2)<br/> g.AddEdge(2, 3)<br/> g.AddEdge(1, 3)<br/> g.AddEdge(3, 1)<br/> g.Print()<br/>}<br/><br/>/* <br/>// Call In Main:: datastructures.PrintEgDirectedGraph()<br/>// Output:<br/>// 1 : 3 <br/>// 2 : 1 <br/>// 3 : 2 1 <br/>*/<br/></span></pre><p id="7455" class="pw-post-body-paragraph lj lk in lm b ln lo jo lp lq lr jr ls kt lu lv lw kx ly lz ma lb mc md me mf ig bi translated"><em class="ll">希望这篇文章有助于理解 golang 中的图形。如有错误或进一步建议，请在下方评论。谢谢！</em></p></div></div>    
</body>
</html>