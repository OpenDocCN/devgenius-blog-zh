<html>
<head>
<title>Node.js Tips — Non-Module Libraries, Blobs, setTimeout, and More</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js 提示—非模块库、Blobs、setTimeout 等等</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/node-js-tips-non-module-libraries-blobs-settimeout-and-more-6f9591d2c18e?source=collection_archive---------27-----------------------#2020-07-15">https://blog.devgenius.io/node-js-tips-non-module-libraries-blobs-settimeout-and-more-6f9591d2c18e?source=collection_archive---------27-----------------------#2020-07-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/a44fd085ced224f62c7e77696f6275ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Aj8eDU8AioPMrKa9"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@webaliser?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">ярославалексеенко</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></figcaption></figure><p id="8019" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像任何类型的应用程序一样，当我们编写节点应用程序时，有一些困难的问题需要解决。</p><p id="96a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究一些编写节点应用程序时常见问题的解决方案。</p><h1 id="0e22" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">setTimeout 和 Node.js</h1><p id="fac2" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe me mf mg mh b">setTimeout</code>运行前等待最少毫秒数。</p><p id="6402" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这不是一个保证。</p><p id="4f4e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">传递 0，非负数将导致它在节点中等待最少毫秒数。</p><p id="5b4a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="70e5" class="mq lc iq mh b gy mr ms l mt mu">setTimeout(() =&gt; {<br/>  console.log('hello');<br/>}, 100)</span></pre><p id="b6bf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，在运行回调之前，我们至少等待 100ms。</p><h1 id="491a" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">文件和文件夹的 Node.js 项目命名约定</h1><p id="295e" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">一个典型的节点项目有一个用于脚本、助手和二进制文件的<code class="fe me mf mg mh b">/bin</code>文件夹。</p><p id="5ff4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">/lib</code>为 app。</p><p id="623b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">/config</code>为配置。</p><p id="d18a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">/public</code>为公共文件。</p><p id="4804" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以及用于测试的<code class="fe me mf mg mh b">/test</code>。</p><h1 id="3207" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">包括 Node.js 中另一个文件的 JavaScript 类定义</h1><p id="3f3f" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以导出该类，并将其导入到另一个文件中。</p><p id="512f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><p id="0ec2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">person.js</code></p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="5f16" class="mq lc iq mh b gy mr ms l mt mu">class Person {<br/>  //...<br/>}</span><span id="fc93" class="mq lc iq mh b gy mv ms l mt mu">module.exports = Person;</span></pre><p id="4d96" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后在另一个文件中，我们写:</p><p id="0f68" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">app.js</code></p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="7826" class="mq lc iq mh b gy mr ms l mt mu">const Person = require('./person');<br/>const person = new Person();</span></pre><p id="de24" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们使用<code class="fe me mf mg mh b">require</code>来请求<code class="fe me mf mg mh b">person</code>模块，然后实例化我们导入的类。</p><p id="da22" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，我们可以对 ES 模块做同样的事情。</p><p id="e041" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><p id="82c6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">person.js</code></p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="467f" class="mq lc iq mh b gy mr ms l mt mu">export default class Person {}</span></pre><p id="fe46" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">app.js</code></p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="804f" class="mq lc iq mh b gy mr ms l mt mu">import Person from './person';<br/>const person = new Person();</span></pre><p id="a035" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们导入<code class="fe me mf mg mh b">person</code>模块，并以同样的方式使用它。</p><p id="b81d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">导出必须是一个<code class="fe me mf mg mh b">default</code>导出，这样我们就可以导入没有花括号的类。</p><h1 id="abe5" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">运行节点脚本时，更改当前 Shell 上下文中的工作目录</h1><p id="cba0" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">要更改节点脚本中的工作目录，我们可以使用<code class="fe me mf mg mh b">process.chdir</code>方法。</p><p id="569c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="d6f5" class="mq lc iq mh b gy mr ms l mt mu">const process = require('process');<br/>process.chdir('../');</span></pre><p id="f260" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">向上移动一个目录。</p><h1 id="9870" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">将普通 Javascript 库加载到 Node.js 中</h1><p id="6158" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果我们想加载不是模块的 JavaScript 库，我们可以使用<code class="fe me mf mg mh b">vm</code>模块。</p><p id="fe64" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="a908" class="mq lc iq mh b gy mr ms l mt mu">const vm = require("vm");<br/>const fs = require("fs");<br/>module.exports = (path, context) =&gt; {<br/>  context = context || {};<br/>  const data = fs.readFileSync(path);<br/>  vm.runInNewContext(data, context, path);<br/>  return context;<br/>}</span></pre><p id="0ca4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用要导出的函数读入脚本文件，并用<code class="fe me mf mg mh b">vm.runInNewContext</code>运行它。</p><p id="87ba" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">data</code>有脚本文件。<code class="fe me mf mg mh b">path</code>是文件路径。</p><p id="1759" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">context</code>是脚本运行的上下文，是全局对象。</p><p id="6deb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以使用<code class="fe me mf mg mh b">execfile</code>来运行文件:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="ebb7" class="mq lc iq mh b gy mr ms l mt mu">const execfile = require("execfile");<br/>const context = execfile("example.js", { globalVar: 42 });<br/>console.log(context.foo());<br/>context.globalVar = 100;</span></pre><p id="4f46" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">example.js</code>是一个包含以下内容的文件:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="d585" class="mq lc iq mh b gy mr ms l mt mu">function foo() {<br/>  return 'bar';<br/>}</span></pre><p id="5a85" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们应该从控制台日志中获取<code class="fe me mf mg mh b">'bar'</code>，因为<code class="fe me mf mg mh b">foo</code>是一个全局函数。</p><p id="78ea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">globalVar</code>是一个全局变量。</p><h1 id="7dfa" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">Node.js 中的 ES6 变量导入名称</h1><p id="1520" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用 import by name 来写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="ad1f" class="mq lc iq mh b gy mr ms l mt mu">const import = async () =&gt; {<br/>  try {<br/>    const module = await import('./path/module');<br/>  }  catch (error) {<br/>    console.error('import failed');<br/>  }<br/>}</span></pre><p id="b64d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们使用返回承诺的<code class="fe me mf mg mh b">import</code>函数。</p><p id="fdc1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它可以用来通过我们传入的路径字符串导入 ES 模块。</p><p id="8188" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果成功，它将解析到模块。</p><h1 id="6354" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">用 JavaScript 将 Blob 转换成文件</h1><p id="4cd2" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用几种方法在 JavaScript 中将 blob 转换成文件。</p><p id="44bf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以将 blob 传递给<code class="fe me mf mg mh b">File</code>构造函数。</p><p id="870a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="9d58" class="mq lc iq mh b gy mr ms l mt mu">const file = new File([blob], "name");</span></pre><p id="9a97" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">其中<code class="fe me mf mg mh b">blob</code>是 blob 实例，<code class="fe me mf mg mh b">'name'</code>是文件名。</p><p id="5e9d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以传入更多的参数:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="8ba2" class="mq lc iq mh b gy mr ms l mt mu">const file = new File([blob], "name", { lastModified: 1534584790000 });</span></pre><p id="418c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用第三个参数中的时间戳设置<code class="fe me mf mg mh b">lastModfiied</code>日期。</p><p id="818a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还可以设置 blob 的<code class="fe me mf mg mh b">lastModifiedDate</code>属性。</p><p id="e718" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="b8a9" class="mq lc iq mh b gy mr ms l mt mu">const blobToFile = (blob, fileName) =&gt; {<br/>  blob.lastModifiedDate = new Date();<br/>  blob.name = fileName;<br/>  return blob;<br/>}</span></pre><p id="427f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们在<code class="fe me mf mg mh b">blob</code>上设置了<code class="fe me mf mg mh b">lastModifiedDate</code>，这是一个<code class="fe me mf mg mh b">Blob</code>实例，用于设置最后修改日期，</p><p id="82cd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">blob.name</code>设置文件名。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/da4f4000ee501cb5b128baa4c782b879.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IqaX24j6VYioEXXy"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">Jacques Bopp 在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="0e7a" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="eb2f" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们以各种方式设置 blob 或文件的修改日期。</p><p id="112e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">setTimeout</code>不保证延迟时间。</p><p id="c7b0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以用模块导出类。</p><p id="7068" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在节点应用中加载非模块 JavaScript 库需要一些努力。</p></div></div>    
</body>
</html>