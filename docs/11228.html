<html>
<head>
<title>Longest Increasing Subsequence of an array in SQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SQL 中数组的最长递增子序列</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/longest-increasing-subsequence-of-an-array-in-sql-3202888c637f?source=collection_archive---------7-----------------------#2022-12-26">https://blog.devgenius.io/longest-increasing-subsequence-of-an-array-in-sql-3202888c637f?source=collection_archive---------7-----------------------#2022-12-26</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="e9d2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最长递增子序列问题要求你在一个整数数组中找到元素的最长子序列，使得它们的值从左到右严格递增。这个问题在命令式编程语言(如 C++、Java、Python 等)中有一个众所周知的 O(n log n)解决方案。我们纯粹在声明式 SQL 中探索一个解决方案，并介绍一些知识和新技术。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/10244dc8f404c5066178b49dc7c86729.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*KflwXt3P3TQ59Tjx"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">蒂姆·埃文斯在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="13be" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">上一篇:</strong><a class="ae ky" href="https://medium.com/@dhruvbird/binary-lower-bound-search-in-sql-384cb0cc66fe" rel="noopener">SQL 中的二进制(下界)搜索</a></p></div><div class="ab cl kz la hr lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="ig ih ii ij ik"><h1 id="bdf1" class="lg lh in bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">问题陈述和在线报道</h1><p id="6a44" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">这个问题在编程界非常流行，在网上也有广泛的报道。这里有一些资源可以让你更熟悉这个问题，如果你还不熟悉的话。</p><ol class=""><li id="d7f5" class="mj mk in jm b jn jo jr js jv ml jz mm kd mn kh mo mp mq mr bi translated"><a class="ae ky" href="https://www.geeksforgeeks.org/longest-increasing-subsequence-dp-3/" rel="noopener ugc nofollow" target="_blank"> Geeksforgeeks </a></li><li id="6199" class="mj mk in jm b jn ms jr mt jv mu jz mv kd mw kh mo mp mq mr bi translated"><a class="ae ky" href="https://leetcode.com/problems/longest-increasing-subsequence/" rel="noopener ugc nofollow" target="_blank"> Leetcode </a></li><li id="906c" class="mj mk in jm b jn ms jr mt jv mu jz mv kd mw kh mo mp mq mr bi translated"><a class="ae ky" href="https://www.interviewbit.com/blog/longest-increasing-subsequence/" rel="noopener ugc nofollow" target="_blank">采访位</a></li></ol></div><div class="ab cl kz la hr lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="ig ih ii ij ik"><h1 id="fab5" class="lg lh in bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">输入表模式</h1><p id="de6d" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">输入表有 2 列:</p><ol class=""><li id="c14f" class="mj mk in jm b jn jo jr js jv ml jz mm kd mn kh mo mp mq mr bi translated"><strong class="jm io"> idx: </strong>数组元素索引(如果在 C++中使用数组，这就是你在数组中寻址元素的方式)。</li><li id="3a2e" class="mj mk in jm b jn ms jr mt jv mu jz mv kd mw kh mo mp mq mr bi translated"><strong class="jm io"> i: </strong>存储值。</li></ol><pre class="kj kk kl km gt mx my mz bn na nb bi"><span id="31a6" class="nc lh in my b be nd ne l nf ng">CREATE TABLE input_data(idx SERIAL PRIMARY KEY, i INTEGER);<br/><br/>INSERT INTO input_data(i) VALUES<br/>(10), (22), (9), (33), (21), (50), (41), (60), (80);</span></pre><p id="b9a8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下面是该表的外观。</p><pre class="kj kk kl km gt mx my mz bn na nb bi"><span id="1fb3" class="nc lh in my b be nd ne l nf ng">SELECT * FROM input_data;</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/9d87958b78dc5d901e45c2960ffecd58.png" data-original-src="https://miro.medium.com/v2/resize:fit:918/format:webp/1*3oQjUUZIXPReBOIqreBPMQ.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">input_data 表的内容(图片由作者提供)</figcaption></figure></div><div class="ab cl kz la hr lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="ig ih ii ij ik"><h1 id="577a" class="lg lh in bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">最长增长子序列</h1><p id="76ee" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">该序列的最长递增子序列长度为 6，其中之一如下:</p><pre class="kj kk kl km gt mx my mz bn na nb bi"><span id="a416" class="nc lh in my b be nd ne l nf ng">10, 22, 33, 50, 60, 80</span></pre><p id="e46a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">还有另一个同样长度的递增序列，看起来像这样:</p><pre class="kj kk kl km gt mx my mz bn na nb bi"><span id="48eb" class="nc lh in my b be nd ne l nf ng">10, 22, 33, 41, 60, 80</span></pre><p id="956b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">可能有一个以上的数字递增子序列，因此它们都是最长的递增子序列。即最长的递增子序列可能不是唯一的。</p></div><div class="ab cl kz la hr lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="ig ih ii ij ik"><h1 id="6e6e" class="lg lh in bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">两种解决方案的共同之处</h1><p id="a853" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">以下两种解决方案都严重依赖于<a class="ae ky" href="https://www.postgresql.org/docs/current/queries-with.html" rel="noopener ugc nofollow" target="_blank">递归 cte</a>(公共表表达式)。如果您不熟悉这个概念，请考虑在提供的链接中阅读它。</p></div><div class="ab cl kz la hr lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="ig ih ii ij ik"><h1 id="ee31" class="lg lh in bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">第一种解决方案:O(n⁴日志 n)</h1><p id="d6f4" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">我们解决这个问题的第一次尝试是从长度为 1 的<strong class="jm io"> "n" </strong>序列(只有一个元素)开始，并尝试在每一步将长度加倍。收敛到最终解需要<strong class="jm io"> O(log n) </strong>步。然而，在每一步，都有<strong class="jm io"> O(n ) </strong>行需要考虑，每一行都需要与<strong class="jm io"> O(n ) </strong>行匹配，因此在最终的复杂度中有<strong class="jm io"> O(n⁴) </strong>项。考虑的每一行都有以下各列:</p><ol class=""><li id="34ed" class="mj mk in jm b jn jo jr js jv ml jz mm kd mn kh mo mp mq mr bi translated"><strong class="jm io"> idx1 </strong>:子序列的起始索引</li><li id="52f5" class="mj mk in jm b jn ms jr mt jv mu jz mv kd mw kh mo mp mq mr bi translated"><strong class="jm io"> idx2 </strong>:子序列的结束索引</li><li id="0e25" class="mj mk in jm b jn ms jr mt jv mu jz mv kd mw kh mo mp mq mr bi translated"><strong class="jm io"> i1 </strong>:子序列的开始元素</li><li id="837a" class="mj mk in jm b jn ms jr mt jv mu jz mv kd mw kh mo mp mq mr bi translated"><strong class="jm io"> i2 </strong>:子序列的结束元素</li><li id="59f2" class="mj mk in jm b jn ms jr mt jv mu jz mv kd mw kh mo mp mq mr bi translated"><strong class="jm io">lis _ length</strong>:idx 1 和 idx2 之间的元素构成的递增子序列的长度</li><li id="2500" class="mj mk in jm b jn ms jr mt jv mu jz mv kd mw kh mo mp mq mr bi translated">iters :收敛到最终解的剩余迭代次数</li></ol><p id="109c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">合并 2 个序列的规则(假设 LHS 序列在位置上在 RHS 序列之前)很简单:</p><ol class=""><li id="e18c" class="mj mk in jm b jn jo jr js jv ml jz mm kd mn kh mo mp mq mr bi translated">2 个 LIS 序列是否使得 LHS 序列的最后一个元素与 RHS 序列的第一个元素相同，在这种情况下，LIS 长度为 LIS(LHS)+LIS(RHS)-1(由于重叠元素)，或者</li><li id="7457" class="mj mk in jm b jn ms jr mt jv mu jz mv kd mw kh mo mp mq mr bi translated">这两个 LIS 序列是否使得 LHS 序列的最后一个元素是&lt; the first element of the RHS sequence, in which case the LIS length is LIS(LHS) + LIS(RHS) (due to no overlapping element).</li></ol><p id="ceb1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">The SQL code for this solution is shown below.</p><pre class="kj kk kl km gt mx my mz bn na nb bi"><span id="186e" class="nc lh in my b be nd ne l nf ng">WITH RECURSIVE base_table AS (<br/>  SELECT idx AS idx1, idx AS idx2, i AS i1, i AS i2, 1 AS lis_length,<br/>    (SELECT CEIL(LOG(COUNT(1)) / LOG(2.0)) + 2 FROM input_data) AS iters<br/>  FROM input_data<br/>),<br/><br/>lis_table(idx1, idx2, i1, i2, lis_length, iters) AS (<br/>  SELECT<br/>    *<br/>  FROM base_table<br/><br/>  UNION ALL<br/>  <br/>  (<br/>    WITH snapshot AS (<br/>      SELECT * FROM lis_table<br/>    )<br/><br/>    SELECT<br/>      lhs.idx1 AS idx1,<br/>      rhs.idx2 AS idx2,<br/>      lhs.i1 AS i1,<br/>      rhs.i2 AS i2,<br/>      MAX(<br/>        lhs.lis_length + rhs.lis_length + (<br/>          CASE WHEN lhs.idx2 = rhs.idx1 THEN -1 ELSE 0 END<br/>        )<br/>      ) AS lis_length,<br/>      lhs.iters - 1 AS iters<br/>    FROM snapshot lhs INNER JOIN snapshot rhs<br/>    ON (lhs.idx2 = rhs.idx1) OR (lhs.idx2 &lt; rhs.idx1 AND lhs.i2 &lt; rhs.i1)<br/>    -- Stop the recursion (by returning an empty table) when iters = 0<br/>    WHERE lhs.iters &gt; 0<br/>    GROUP BY 1, 2, 3, 4, 6<br/>  )<br/>)<br/><br/>-- We display the top 8 candidates to show that there can be<br/>-- potentially a different number of sequences with the same<br/>-- length (number of elements).<br/>SELECT idx1, idx2, i1, i2, lis_length FROM lis_table<br/>GROUP BY 1, 2, 3, 4, 5<br/>ORDER BY lis_length DESC<br/>LIMIT 8;<br/></span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/824114b9555cbae033eeaf42d8be5d8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:950/format:webp/1*Q_JRpEZ-zY3FapxkhlNmqg.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">Output of the query for the first solution which runs in time O(n⁴ log n) (Image by author)</figcaption></figure><p id="063f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">估计成本:</strong>对于一个 9 行的表，该查询的估计成本是<a class="ae ky" href="https://explain.depesz.com/s/Ayvi" rel="noopener ugc nofollow" target="_blank"> 104M </a>。</p></div><div class="ab cl kz la hr lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="ig ih ii ij ik"><h1 id="97e0" class="lg lh in bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">第二种解决方案:O(n)</h1><p id="8a84" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">这个问题更常见的解决方案是从后向前查看输入序列中的每个元素，并尝试查看正在考虑的元素是否可以扩展在正在考虑的元素之后开始的现有 LIS 序列之一。</p><p id="bb26" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">例如，如果您正在考虑输入数组中索引<strong class="jm io"> x </strong>处的元素，那么您将检查是否有从索引<strong class="jm io"> [x+1】处开始的 LIS..n] </strong>，并尝试将其全部扩展。然后根据索引<strong class="jm io"> x </strong>记录最长的序列。</p><p id="f16e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">递归表(lis_table)的模式如下所示:</p><ol class=""><li id="ebe6" class="mj mk in jm b jn jo jr js jv ml jz mm kd mn kh mo mp mq mr bi translated"><strong class="jm io"> idx </strong>:数组元素的索引</li><li id="0f1f" class="mj mk in jm b jn ms jr mt jv mu jz mv kd mw kh mo mp mq mr bi translated"><strong class="jm io"> i </strong>:数组元素的值</li><li id="25a1" class="mj mk in jm b jn ms jr mt jv mu jz mv kd mw kh mo mp mq mr bi translated"><strong class="jm io"> lis_length </strong>:从索引 idx 处的数组元素开始的 lis 长度</li><li id="2135" class="mj mk in jm b jn ms jr mt jv mu jz mv kd mw kh mo mp mq mr bi translated"><strong class="jm io"> current_idx </strong>:下一次递归迭代中要处理的元素的索引。当<strong class="jm io"> current_idx = idx — 1 </strong>时，将处理索引<strong class="jm io"> idx </strong>处的元素。</li></ol><p id="3187" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最后，我们只显示在任何给定迭代中更新的那些行。由于只有当<strong class="jm io"> current_idx = idx — 1 </strong>时才会更新一行，所以我们只在最终结果中显示那些行。</p><pre class="kj kk kl km gt mx my mz bn na nb bi"><span id="b72a" class="nc lh in my b be nd ne l nf ng">WITH RECURSIVE with_last_idx AS (<br/>  SELECT idx, i, MAX(idx) OVER () AS last_idx<br/>  FROM input_data<br/>),<br/><br/>with_lis_length AS (<br/>  SELECT<br/>    idx,<br/>    i,<br/>    CASE WHEN idx = last_idx THEN 1 ELSE 0 END AS lis_length,<br/>    last_idx - 1 AS current_idx<br/>  FROM with_last_idx<br/>),<br/><br/>lis_table(idx, i, lis_length, current_idx) AS (<br/>  SELECT * FROM with_lis_length<br/>  <br/>  UNION ALL<br/>  <br/>  (<br/>    -- We can't run an OUTER JOIN on a table that is participating<br/>    -- in a recursive CTE, so we take a point in time snapshot and<br/>    -- use that instead.<br/>    WITH lis_with_tag AS (<br/>      SELECT<br/>        idx,<br/>        i,<br/>        lis_length,<br/>        current_idx,<br/>        -- When the incoming table's current_idx is 0, it means that we're<br/>        -- going to process the row with idx = 0 in this iteration. Such a<br/>        -- row is not part of the original input, so we mark this process<br/>        -- as complete and tag is_complete = TRUE so that we don't consider<br/>        -- this result of this iteration in the final result.<br/>        --<br/>        -- We need to be careful and ensure that we are able to process<br/>        -- this round without an error or exception.<br/>        CASE WHEN current_idx = 0 THEN TRUE ELSE FALSE END AS is_complete <br/>      FROM lis_table<br/>    ),<br/><br/>    -- First extract the row containing the element that we are going<br/>    -- to attempt to add to the LIS.<br/>    row_to_process AS (<br/>      SELECT<br/>        idx,<br/>        i,<br/>        lis_length,<br/>        current_idx,<br/>        is_complete <br/>      FROM lis_with_tag<br/>      WHERE idx = current_idx<br/>    ),<br/><br/>    -- Then extract the result of the rows that are expected to be unchanged.<br/>    rest_of_the_rows AS (<br/>      SELECT<br/>        idx,<br/>        i,<br/>        lis_length,<br/>        current_idx - 1 AS current_idx,<br/>        is_complete <br/>      FROM lis_with_tag<br/>      WHERE idx &lt;&gt; current_idx<br/>    ),<br/><br/>    -- The wavefront is the set of possible extensions of the LIS<br/>    -- due to the element in the table row_to_process.<br/>    wavefront AS (<br/>      SELECT<br/>        lhs.idx,<br/>        lhs.i,<br/>        MAX(COALESCE(rhs.lis_length + 1, 0)) AS lis_length,<br/>        lhs.current_idx - 1 AS current_idx,<br/>        lhs.is_complete<br/>      FROM row_to_process lhs LEFT JOIN (<br/>        SELECT * FROM rest_of_the_rows WHERE idx &gt; current_idx<br/>      ) rhs<br/>      ON lhs.i &lt; rhs.i<br/>      GROUP BY lhs.idx, lhs.i, lhs.current_idx, lhs.is_complete<br/>    ),<br/><br/>    -- Now UNION the unchanged rows with the new row that<br/>    -- potentially extends the LIS.<br/>    unioned AS (<br/>      SELECT * FROM wavefront<br/>      UNION ALL<br/>      SELECT * FROM rest_of_the_rows<br/>    )<br/>    <br/>    SELECT idx, i, lis_length, current_idx FROM unioned<br/>    WHERE is_complete = FALSE<br/>  )<br/>) <br/><br/>SELECT * FROM lis_table<br/>-- Only keep rows that were processed in that iteration.<br/>WHERE idx - 1 = current_idx<br/>ORDER BY idx ASC, current_idx ASC;</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/a304cc1bbcf8b27fc386df9125d91961.png" data-original-src="https://miro.medium.com/v2/resize:fit:1208/format:webp/1*h5WA7v5Oeb2wkinMsuTRpQ.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">运行第二个解决方案的查询所打印的结果(图片由作者提供)</figcaption></figure><p id="e523" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">LIS 显示有 6 个元素，从数字 10 开始。橙色圆圈中的数字是参与长度为 6 的 LIS 的数字。</p><h2 id="ce3a" class="nk lh in bd li nl nm dn lm nn no dp lq jv np nq lu jz nr ns ly kd nt nu mc nv bi translated">实现此解决方案的替代方法</h2><p id="79dd" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">这个解决方案的一个特点是递归 CTE 表既包含要处理的行(索引)，也包含已经处理的行(从末尾开始)。我们可以实现这个解决方案，使这个表只包含已经处理的行，而不是未处理的行。这将涉及到从单独的表中获取新行。最终的解仍然是 O(n)，但是常数会更低，因为我们不会在每一步都复制“n”行，而是在递归步骤中复制 1，2，3，…，n 行。</p><h1 id="38fb" class="lg lh in bd li lj nw ll lm ln nx lp lq lr ny lt lu lv nz lx ly lz oa mb mc md bi translated">SQL 小提琴</h1><p id="ca28" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">这篇文章中所有解决方案的 SQL 链接可以在<a class="ae ky" href="http://sqlfiddle.com/#!17/8efd5/33" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p></div><div class="ab cl kz la hr lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="ig ih ii ij ik"><h1 id="6e35" class="lg lh in bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">结论</h1><p id="a4b2" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">实施这个解决方案后，我学到的一件事是如何从功能上考虑解决方案。即在一个不能更新任何状态，而只能添加或聚集现有状态的世界中。更新可以被认为是一个行添加，然后是具有相同键的行的聚合。在<a class="ae ky" href="https://www.scylladb.com/glossary/sstable/" rel="noopener ugc nofollow" target="_blank">表</a>(数据库系统的一种流行存储格式)中利用了相同的概念，其中更新和删除作为插入处理，而行数据作为包含相同行键的不同级别的各种<a class="ae ky" href="https://stackoverflow.com/questions/2576012/what-is-an-sstable" rel="noopener ugc nofollow" target="_blank">表</a>定期合并在一起而聚集。</p></div></div>    
</body>
</html>