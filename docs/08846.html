<html>
<head>
<title>Data Preprocessing of Steam Dataset</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Steam 数据集的数据预处理</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/data-preprocessing-of-steam-dataset-8522524a7c72?source=collection_archive---------10-----------------------#2022-07-14">https://blog.devgenius.io/data-preprocessing-of-steam-dataset-8522524a7c72?source=collection_archive---------10-----------------------#2022-07-14</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="170c" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">从原始数据和脏数据到干净数据</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/b11007479aa6f7b7c6a5e7ddc70f54f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*71TTPkOJaZrLAD9z4EEoDw.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">照片由<a class="ae ks" href="https://unsplash.com/@mbaumi" rel="noopener ugc nofollow" target="_blank"> <strong class="bd kt">米卡鲍梅斯特</strong> </a> <strong class="bd kt">上</strong><a class="ae ks" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank"><strong class="bd kt">Unsplash</strong></a></figcaption></figure><p id="323a" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">在我的上一篇文章中，我对使用 Python、Scrapy 和 VS 代码收集的 Steam 数据集进行了分析。在我进行分析之前，数据仍然是原始的，有许多缺失值、错误的数据类型等。在本文中，我将展示如何清理和预处理用于分析的数据</p><h1 id="4204" class="lq lr in bd kt ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">导入库并加载数据集</h1><p id="884a" class="pw-post-body-paragraph ku kv in kw b kx mh jo kz la mi jr lc ld mj lf lg lh mk lj lk ll ml ln lo lp ig bi translated">首先，我导入了预处理和分析数据所需的所有库。</p><pre class="kd ke kf kg gt mm mn mo mp aw mq bi"><span id="b573" class="mr lr in mn b gy ms mt l mu mv">import pandas as pd <strong class="mn io">#to read the file and manipulate data</strong><br/>import numpy as np <strong class="mn io">#powerful libary to do mathematical equation</strong><br/>import matplotlib.pyplot as plt <strong class="mn io">#basic data visualization</strong><br/>import seaborn as sns <strong class="mn io">#visualization style based on matplotlib</strong><br/>import re <strong class="mn io">#regular expression to filter strings</strong></span><span id="17a6" class="mr lr in mn b gy mw mt l mu mv">raw = pd.read_csv('steam_games.csv') #<br/>raw.sample(5)</span></pre><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mx"><img src="../Images/b7b9719db859d8df8bd971e38bf157d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-SDw9GUOgPZw5-3emg0LTQ.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">数据集的样本</figcaption></figure><h1 id="a64f" class="lq lr in bd kt ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">数据理解</h1><p id="9e88" class="pw-post-body-paragraph ku kv in kw b kx mh jo kz la mi jr lc ld mj lf lg lh mk lj lk ll ml ln lo lp ig bi translated">在我开始对数据进行预处理之前，我必须先了解数据。通过理解数据，我可以决定需要为每一列(或特性)做哪种预处理。</p><pre class="kd ke kf kg gt mm mn mo mp aw mq bi"><span id="92a1" class="mr lr in mn b gy ms mt l mu mv">raw.info()</span></pre><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi my"><img src="../Images/f101a067c7bd64600c7497af484c5f21.png" data-original-src="https://miro.medium.com/v2/resize:fit:696/format:webp/1*T8oQ0ka41qy5XBjY20AUjA.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">数据集信息</figcaption></figure><ul class=""><li id="632d" class="mz na in kw b kx ky la lb ld nb lh nc ll nd lp ne nf ng nh bi translated">几乎所有的特征都在<code class="fe ni nj nk mn b">object </code>中，尽管其中一些实际上是<code class="fe ni nj nk mn b">integer,</code>我将纠正每个特征的数据类型</li><li id="ec88" class="mz na in kw b kx nl la nm ld nn lh no ll np lp ne nf ng nh bi translated"><code class="fe ni nj nk mn b">url</code>、<code class="fe ni nj nk mn b">image</code>、<code class="fe ni nj nk mn b">discount_rate</code>、<code class="fe ni nj nk mn b">discounted_price</code>、<code class="fe ni nj nk mn b">description, processor</code>和<code class="fe ni nj nk mn b">graphic_card </code>将不会在此数据分析中使用，因此我将删除所有这些特性</li><li id="4a74" class="mz na in kw b kx nl la nm ld nn lh no ll np lp ne nf ng nh bi translated"><code class="fe ni nj nk mn b">release_date</code>:提取月份和年份</li><li id="f0fa" class="mz na in kw b kx nl la nm ld nn lh no ll np lp ne nf ng nh bi translated"><code class="fe ni nj nk mn b">original_price</code>:更改数据类型(提取价格)</li><li id="e449" class="mz na in kw b kx nl la nm ld nn lh no ll np lp ne nf ng nh bi translated"><code class="fe ni nj nk mn b">text_reviews :</code>提取评分(<code class="fe ni nj nk mn b">user_rating</code>)和总用户评论(<code class="fe ni nj nk mn b">total_reviews</code>)</li><li id="15a2" class="mz na in kw b kx nl la nm ld nn lh no ll np lp ne nf ng nh bi translated"><code class="fe ni nj nk mn b">language :</code>提取支持的语言数量(<code class="fe ni nj nk mn b">language</code></li><li id="ba6c" class="mz na in kw b kx nl la nm ld nn lh no ll np lp ne nf ng nh bi translated"><code class="fe ni nj nk mn b">metacriticts :</code>缺少太多值。该功能将被删除</li></ul><h1 id="b1d0" class="lq lr in bd kt ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">检查重复的行</h1><p id="7822" class="pw-post-body-paragraph ku kv in kw b kx mh jo kz la mi jr lc ld mj lf lg lh mk lj lk ll ml ln lo lp ig bi translated">重复的数据会给出错误的分析，这就是为什么我们必须首先删除它们。让我们使用这个简单的代码来检查数据集</p><pre class="kd ke kf kg gt mm mn mo mp aw mq bi"><span id="99fc" class="mr lr in mn b gy ms mt l mu mv">raw.duplicated().any()<strong class="mn io">#This will return boolean value</strong></span></pre><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/dd08f385d0937eeb6037aa9cfbf2c675.png" data-original-src="https://miro.medium.com/v2/resize:fit:438/format:webp/1*3u8zX4YT3gtMP7L1r0Ie5Q.png"/></div></figure><p id="7623" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">它返回<code class="fe ni nj nk mn b">False</code>，这意味着没有重复的行。但是，如果确实有重复的行，我们可以使用下面的代码来删除它</p><pre class="kd ke kf kg gt mm mn mo mp aw mq bi"><span id="688b" class="mr lr in mn b gy ms mt l mu mv">raw.drop_duplicates(inplace=True)</span></pre><h1 id="217c" class="lq lr in bd kt ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated"><strong class="ak">移除未使用的列</strong></h1><p id="4662" class="pw-post-body-paragraph ku kv in kw b kx mh jo kz la mi jr lc ld mj lf lg lh mk lj lk ll ml ln lo lp ig bi translated">不是每个列都可以用于分析，例如，我们不能从<code class="fe ni nj nk mn b">url </code>和<code class="fe ni nj nk mn b">image</code>中提取任何信息。因此，我们将删除一些不会在此分析中使用的列。我总是试图为每一步设置检查点，这就是为什么我会在进行任何更改之前创建一个包含原始数据集副本的新变量。</p><pre class="kd ke kf kg gt mm mn mo mp aw mq bi"><span id="a53e" class="mr lr in mn b gy ms mt l mu mv">df_drop = raw.copy()<br/>drop = ['url','image','discount_rate','discounted_price','description','metacriticts','processor','graphic_card'] <br/>df_drop = df_drop.drop(labels=drop,axis=1)</span></pre><h1 id="9798" class="lq lr in bd kt ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">数据提取和格式化</h1><h2 id="9db5" class="mr lr in bd kt nr ns dn lv nt nu dp lz ld nv nw mb lh nx ny md ll nz oa mf ob bi translated">提取月份和年份</h2><p id="572d" class="pw-post-body-paragraph ku kv in kw b kx mh jo kz la mi jr lc ld mj lf lg lh mk lj lk ll ml ln lo lp ig bi translated">我们提取的第一个特征将是来自<code class="fe ni nj nk mn b">release_date. </code>的<code class="fe ni nj nk mn b">month</code>和<code class="fe ni nj nk mn b">year</code>，未处理的发布日期看起来像这个<code class="fe ni nj nk mn b">25 Mar, 2015</code>，使用<code class="fe ni nj nk mn b">pandas.Series.str.findall('(\d+)')</code>我们可以提取所有的数字，但是正如我们可以看到的，除了年份之外还有另一个数字，它是日期数字，这意味着它将返回一个列表而不是单个元素。这就是为什么我将创建另一个函数来提取有 4 个数字的元素。</p><pre class="kd ke kf kg gt mm mn mo mp aw mq bi"><span id="a257" class="mr lr in mn b gy ms mt l mu mv">def extract_year(x): <strong class="mn io">#function to extract year from list of numbers</strong><br/>    year = None<br/>    if type(x) == list:<br/>        for i in x:<br/>            if len(i) == 4:<br/>                year = i<br/>                return year<br/>            else: <br/>                year = None<br/>        return year<br/>    else:<br/>        year = x<br/>    return year</span><span id="0b14" class="mr lr in mn b gy mw mt l mu mv">df_extract = df_drop.copy()</span><span id="3cf2" class="mr lr in mn b gy mw mt l mu mv">df_extract['year'] = df_extract['release_date'].str.findall('(\d+)').apply(lambda x: extract_year(x)).astype(float)</span></pre><p id="f3dc" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">为了提取月份，我们将使用<code class="fe ni nj nk mn b">pandas.Series.str.findall(“[a-zA-Z]+”).str[0]</code>。它将从字符串对象中提取所有的字母。有些行具有不同的格式，例如，它们没有写出月份的缩写，如 Jan、Feb 和 Mar，而是写出整个单词，如 August 和 June，我们必须更改该值，以便所有行都具有相同的格式。我们将使用<code class="fe ni nj nk mn b">pandas.DataFrame.replace() it </code>来修复错误的值。然后我们还必须将没有发布日期的行更改为<code class="fe ni nj nk mn b">None</code>。我们要做的最后一件事是删除原来的<code class="fe ni nj nk mn b">release_date </code>列。</p><pre class="kd ke kf kg gt mm mn mo mp aw mq bi"><span id="0a06" class="mr lr in mn b gy ms mt l mu mv">df_extract['month'] = df_extract['release_date'].str.findall("[a-zA-Z]+").str[0]</span><span id="273f" class="mr lr in mn b gy mw mt l mu mv">df_extract['month'] = df_extract['month'].replace(['August','June'],['Aug','Jun'])</span><span id="9ae8" class="mr lr in mn b gy mw mt l mu mv">month = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec']</span><span id="d345" class="mr lr in mn b gy mw mt l mu mv">df_extract.loc[~df_extract['month'].isin(month),'month'] = None<br/>df_extract = df_extract.drop('release_date', axis=1) <br/></span></pre><h2 id="b51e" class="mr lr in bd kt nr ns dn lv nt nu dp lz ld nv nw mb lh nx ny md ll nz oa mf ob bi translated">提取用户评级和总评论</h2><p id="e8e3" class="pw-post-body-paragraph ku kv in kw b kx mh jo kz la mi jr lc ld mj lf lg lh mk lj lk ll ml ln lo lp ig bi translated">我们进行的第二次提取将是<code class="fe ni nj nk mn b">user_rating_all</code>和<code class="fe ni nj nk mn b">total_review_all</code>。原列<code class="fe ni nj nk mn b">whole_reviews </code>长这样<code class="fe ni nj nk mn b">86% of the 469,045 user reviews for this game are positive</code>。像前面的提取一样，我们将使用<code class="fe ni nj nk mn b">pandas.Series.str.findall(‘(\d+)’) </code>，但是我们必须首先使用<code class="fe ni nj nk mn b">pandas.DataFrame.replace(',', '')</code>删除评论数量中的逗号</p><pre class="kd ke kf kg gt mm mn mo mp aw mq bi"><span id="f3c8" class="mr lr in mn b gy ms mt l mu mv">df_extract_2 = df_extract.copy()<br/>df_extract_2['whole_reviews'] = df_extract_2['whole_reviews'].str.replace(',','')<br/>df_extract_2['user_rating_all'] = df_extract_2['whole_reviews'].str.findall('(\d+)').str[0].astype(float)<br/>df_extract_2['total_review_all'] = df_extract_2['whole_reviews'].str.findall('(\d+)').str[1].astype(float)<br/>df_extract_2 = df_extract_2.drop('whole_reviews',axis=1)</span></pre><h2 id="752c" class="mr lr in bd kt nr ns dn lv nt nu dp lz ld nv nw mb lh nx ny md ll nz oa mf ob bi translated">提取支持的语言数量</h2><p id="2b89" class="pw-post-body-paragraph ku kv in kw b kx mh jo kz la mi jr lc ld mj lf lg lh mk lj lk ll ml ln lo lp ig bi translated">接下来，我们将提取游戏或<code class="fe ni nj nk mn b">supported_language</code>支持的语言数量。<code class="fe ni nj nk mn b">language </code>的原列是这样的<code class="fe ni nj nk mn b">English,Simplified Chinese</code>。我们使用的方法是使用<code class="fe ni nj nk mn b">pandas.Series.str.split(',')</code>将值分割成一个列表，然后计算列表中元素的数量。</p><pre class="kd ke kf kg gt mm mn mo mp aw mq bi"><span id="e78c" class="mr lr in mn b gy ms mt l mu mv">df_extract_3 = df_extract_2.copy()<br/>df_extract_3['supported_language'] = df_extract_3['language'].str.split(',').apply(lambda x: len(x) if type(x) == list else x)<br/>df_extract_3 = df_extract_3.drop('language',axis=1)<br/></span></pre><h2 id="5a1f" class="mr lr in bd kt nr ns dn lv nt nu dp lz ld nv nw mb lh nx ny md ll nz oa mf ob bi translated">提取价格</h2><p id="20a2" class="pw-post-body-paragraph ku kv in kw b kx mh jo kz la mi jr lc ld mj lf lg lh mk lj lk ll ml ln lo lp ig bi translated">列<code class="fe ni nj nk mn b">original_price</code>的原始值是这样的，<code class="fe ni nj nk mn b">Rp 108 999.</code>我们将删除所有的字母和空格，然后将数据类型更改为<code class="fe ni nj nk mn b">float</code>。但是因为 float 不能处理丢失的值，所以我们把丢失的值变成了<code class="fe ni nj nk mn b">0</code>。</p><pre class="kd ke kf kg gt mm mn mo mp aw mq bi"><span id="d988" class="mr lr in mn b gy ms mt l mu mv">df_price = df_extract_3.copy()<br/>df_price[‘price’] = df_price[‘original_price’].str.lower().str.replace(r’\D’,’’).astype(int,errors=’ignore’)<br/>df_price.loc[df_price[‘price’]==’’,’price’] = 0<br/>df_price[‘price’] = df_price[‘price’].astype(float)<br/>df_price = df_price.drop(‘original_price’,axis=1)<br/>df_price.sample(5)</span></pre><h2 id="0f5c" class="mr lr in bd kt nr ns dn lv nt nu dp lz ld nv nw mb lh nx ny md ll nz oa mf ob bi translated">提取年龄评级</h2><p id="cb3f" class="pw-post-body-paragraph ku kv in kw b kx mh jo kz la mi jr lc ld mj lf lg lh mk lj lk ll ml ln lo lp ig bi translated"><code class="fe ni nj nk mn b">rating</code>的初始值是一个图片 URL，看起来像这个<code class="fe ni nj nk mn b"><a class="ae ks" href="https://store.akamai.steamstatic.com/public/shared/images/game_ratings/PEGI/16.png" rel="noopener ugc nofollow" target="_blank">https://store.akamai.steamstatic.com/public/shared/images/game_ratings/PEGI/16.png</a>.</code>，从那个字符串中，我们可以去掉所有的字母和符号，得到<code class="fe ni nj nk mn b">age_rating</code>。</p><pre class="kd ke kf kg gt mm mn mo mp aw mq bi"><span id="c2e1" class="mr lr in mn b gy ms mt l mu mv">df_pegi = df_price.copy()<br/>df_pegi['age_rating'] = df_pegi['rating'].str.replace(r'\D','')<br/>df_pegi = df_pegi.drop('rating',axis=1)<br/></span></pre><h2 id="5fba" class="mr lr in bd kt nr ns dn lv nt nu dp lz ld nv nw mb lh nx ny md ll nz oa mf ob bi translated">制作新列(Windows、Mac、Linux 和 VR)</h2><p id="4a06" class="pw-post-body-paragraph ku kv in kw b kx mh jo kz la mi jr lc ld mj lf lg lh mk lj lk ll ml ln lo lp ig bi translated">对于 OS 和 VR 可用性，我们将创建一个具有布尔值的新列。使用<code class="fe ni nj nk mn b">numpy.where</code>我们可以创建 4 个新列。例如，如果游戏支持 Windows，则<code class="fe ni nj nk mn b">windows</code>的值为“1 ”,否则为“0”。原始值是这样的<code class="fe ni nj nk mn b">Windows, Mac OS, Linux</code></p><pre class="kd ke kf kg gt mm mn mo mp aw mq bi"><span id="e498" class="mr lr in mn b gy ms mt l mu mv">df_platform = df_pegi.copy()<br/>df_platform['windows'] = np.where(df_platform['platforms'].str.contains('Windows',na=False), 1, 0)<br/>df_platform['mac'] = np.where(df_platform['platforms'].str.contains('Mac OS',na=False), 1, 0)<br/>df_platform['linux'] = np.where(df_platform['platforms'].str.contains('Linux',na=False), 1, 0)<br/>df_platform['VR'] = np.where(df_platform['platforms'].str.contains('VR Supported',na=False), 1, 0)<br/>df_platform = df_platform.drop('platforms',axis=1)<br/></span></pre><h2 id="8a1c" class="mr lr in bd kt nr ns dn lv nt nu dp lz ld nv nw mb lh nx ny md ll nz oa mf ob bi translated">重新映射列 RAM 的值</h2><p id="1f68" class="pw-post-body-paragraph ku kv in kw b kx mh jo kz la mi jr lc ld mj lf lg lh mk lj lk ll ml ln lo lp ig bi translated">列<code class="fe ni nj nk mn b">ram</code>的值变化太大，这就是为什么我们必须检查每个不同的值并正确标记它们。例如，一些值看起来像这样<code class="fe ni nj nk mn b">6 gb </code>和<code class="fe ni nj nk mn b">6000 mb</code>，尽管它们看起来不同，但它们实际上是相同的，这就是为什么我们必须将它们标记在一起。我不会把所有的代码都放在这里，因为它很长，但是如果有人想看完整的代码，我会给出 GitHub 回购的链接</p><p id="fd72" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated"><code class="fe ni nj nk mn b">df_ram = df_platform.copy()<br/>df_ram.loc[df_ram[‘ram’].str.lower().str.contains(‘8 gb|8000 mb|８ gb|8gb|8.0 gb|8\+ gb’, na=False),’ram’] = ‘8 GB’<br/>df_ram.loc[df_ram[‘ram’].str.lower().str.contains(‘4 gb|4096 mb|4000 mb|4gb|４ gb|4.00 gb|4g|4 ram gb’, na=False),’ram’] = ‘4 GB’<br/>df_ram.loc[df_ram[‘ram’].str.lower().str.contains(‘2 gb|2048|2000 mb|2gb|1536 mb|2.0 gb|2000 gb|２ gb|1.5gb|2.0gb|2g’, na=False),’ram’] = ‘2 GB’<br/>df_ram.loc[df_ram[‘ram’].str.lower().str.contains(‘1 gb|1024|1000 mb|1gb|800 mb|750 mb|1280 mb|700 mb|900 mb|１ gb|1\+’, na=False),’ram’] = ‘1 GB’</code></p><p id="998b" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">这是我在数据分析之前做的一些预处理。完整的代码可以在这里访问<a class="ae ks" href="https://github.com/triesonyk/data-analysis-steam-games" rel="noopener ugc nofollow" target="_blank">。</a></p></div></div>    
</body>
</html>