<html>
<head>
<title>Securing backend deployments</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">保护后端部署</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/securing-backend-deployments-9e57b93b93a0?source=collection_archive---------18-----------------------#2022-09-26">https://blog.devgenius.io/securing-backend-deployments-9e57b93b93a0?source=collection_archive---------18-----------------------#2022-09-26</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="620c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">以安全的方式部署后端服务器可能并不总是清晰的。许多开发人员倾向于忘记重要的步骤，这可能导致生产阶段的漏洞。在本文中，我将整理一份清单，这是我在几年的后端开发中收集到的。</p><p id="85d1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ki">免责声明:我绝不是网络安全专家。这仅仅是一个最佳实践的列表，是我长期收集的</em></p><h2 id="497a" class="kj kk in bd kl km kn dn ko kp kq dp kr jv ks kt ku jz kv kw kx kd ky kz la lb bi translated">开放端口</h2><p id="5607" class="pw-post-body-paragraph jk jl in jm b jn lc jp jq jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh ig bi translated">在生产过程中打开不适当的端口可能会给黑客留下访问资源的入口，从而存储您的部署。一个好的经验法则是关闭生产服务器中所有不是 80 (http)和 443 (https)的端口。这同样适用于数据库服务器，在那里只有生产后端的资源应该能够连接。所有其他连接都需要被阻止。</p><h2 id="f1bf" class="kj kk in bd kl km kn dn ko kp kq dp kr jv ks kt ku jz kv kw kx kd ky kz la lb bi translated">环境变量</h2><p id="6a71" class="pw-post-body-paragraph jk jl in jm b jn lc jp jq jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh ig bi translated">无论您是对接后端，还是直接部署到 linux 服务器，您都需要隐藏所有敏感信息。如果黑客获得了对您的资源的访问权，您不希望他们获得对您的数据库或 AWS 凭证的访问权。因此，请确保将所有敏感密钥安全地放在环境变量或配置文件中。</p><h2 id="9878" class="kj kk in bd kl km kn dn ko kp kq dp kr jv ks kt ku jz kv kw kx kd ky kz la lb bi translated">调试设置</h2><p id="f8c2" class="pw-post-body-paragraph jk jl in jm b jn lc jp jq jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh ig bi translated">这是一个显而易见的问题，但是你会惊讶于有多少人在生产中忘记关闭调试。这样的错误可能会让黑客看到某些端点的错误日志，从而发现漏洞。请仔细检查您的调试设置。</p><h2 id="c6c0" class="kj kk in bd kl km kn dn ko kp kq dp kr jv ks kt ku jz kv kw kx kd ky kz la lb bi translated">防止 SQL 注入</h2><p id="598a" class="pw-post-body-paragraph jk jl in jm b jn lc jp jq jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh ig bi translated">对于大多数“内置电池”的后端框架，您会得到一个内置的 ORM(对象关系映射器)。这包括 Rails、Django 或任何使用类似 Prisma 的 Javascript 框架。这些框架内置了 SQL 注入预防措施。但是，在某些边缘情况下，您会希望使用原始 SQL 查询来提高大型数据集的性能。在这种情况下，确保您的字符串插入是防注入的。</p><h2 id="f19b" class="kj kk in bd kl km kn dn ko kp kq dp kr jv ks kt ku jz kv kw kx kd ky kz la lb bi translated">过期的 JWT 代币</h2><p id="6074" class="pw-post-body-paragraph jk jl in jm b jn lc jp jq jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh ig bi translated">虽然不太可能，但让你的 JWT 代币持续太久会让黑客窃取代币。当您的 JWT 令牌持续时间很短时，黑客可能会窃取令牌，然后发现它们已经过期。</p><h2 id="abc6" class="kj kk in bd kl km kn dn ko kp kq dp kr jv ks kt ku jz kv kw kx kd ky kz la lb bi translated">TFA</h2><p id="cc23" class="pw-post-body-paragraph jk jl in jm b jn lc jp jq jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh ig bi translated">将 TFA 应用到您的后端可能会增加生产成本，因为大多数提供商，如 Twilio，按授权收费。然而，这是过去十年中在安全方面最重要的进步之一。黑客可以窃取你的用户密码，但很难找回 TFA 代码。</p><h2 id="63ff" class="kj kk in bd kl km kn dn ko kp kq dp kr jv ks kt ku jz kv kw kx kd ky kz la lb bi translated">将 HTTP 重定向到 HTTPS</h2><p id="7b7a" class="pw-post-body-paragraph jk jl in jm b jn lc jp jq jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh ig bi translated">这又是一个显而易见的问题，因为 HTTPS 已经默认了很长时间，确保我们的请求被加密。不太明显的是，您的应用程序可能配置不正确，允许用户意外地通过 HTTP 发送请求。这可能导致密码和用户名易受攻击。在 Django，这将看起来像<code class="fe lh li lj lk b">SECURE_SSL_REDIRECT=True</code></p><h2 id="cdf3" class="kj kk in bd kl km kn dn ko kp kq dp kr jv ks kt ku jz kv kw kx kd ky kz la lb bi translated">加密 Cookies</h2><p id="25e8" class="pw-post-body-paragraph jk jl in jm b jn lc jp jq jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh ig bi translated">与常规请求类似，您的 cookies 也可能不加密发送。这很糟糕。如果黑客获取了用户的 cookies，他们就可以找到方法窃取他们的帐户凭证。在生产中，确保<code class="fe lh li lj lk b">CSRF_COOKIE_SECURE=True</code>等设置。还要确保你的 cookies 有一个明确的有效期。</p><h2 id="7a0c" class="kj kk in bd kl km kn dn ko kp kq dp kr jv ks kt ku jz kv kw kx kd ky kz la lb bi translated">正确配置 CSP</h2><p id="4878" class="pw-post-body-paragraph jk jl in jm b jn lc jp jq jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh ig bi translated">正确配置 CSP 主要适用于 Django、Rails 或 Redwood 等 SSR 框架。这不适用于基于 REST 的后端，如 Express 或 Django Rest 框架。如果您的 CSP 设置不正确，黑客可能会将不安全的脚本注入您的网页。为了确保没有恶意内容被注入，永远不要使用' unsafe-eval '，并指定您的外部内容。</p><h2 id="99e0" class="kj kk in bd kl km kn dn ko kp kq dp kr jv ks kt ku jz kv kw kx kd ky kz la lb bi translated">HSTS</h2><p id="4afe" class="pw-post-body-paragraph jk jl in jm b jn lc jp jq jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh ig bi translated">HSTS 代表 HTTP 严格传输安全。这是一种防止中间人攻击的策略机制。配置这种东西可能会令人头痛，因为您必须确保您的证书是有序的。同样，大多数“含电池”都带有某种 HSTS 政策。您的工作是正确配置它们。</p><h2 id="3b02" class="kj kk in bd kl km kn dn ko kp kq dp kr jv ks kt ku jz kv kw kx kd ky kz la lb bi translated">诺斯尼夫</h2><p id="3b66" class="pw-post-body-paragraph jk jl in jm b jn lc jp jq jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh ig bi translated">将 NOSNIFF 应用于所有安全内容类型可以防止 MIME 类型嗅探。当将 NOSNIFF 添加到请求头中时，它将阻止接受可能执行恶意代码的 MIME 可执行文件。</p><h2 id="ac70" class="kj kk in bd kl km kn dn ko kp kq dp kr jv ks kt ku jz kv kw kx kd ky kz la lb bi translated">指定 CORS 起源</h2><p id="2472" class="pw-post-body-paragraph jk jl in jm b jn lc jp jq jr ld jt ju jv le jx jy jz lf kb kc kd lg kf kg kh ig bi translated">如果没有 CORS 报头，攻击者就可以访问未经验证的内容。如果实施不当，CORS 可能会泄露 API 密钥或其他敏感信息。通过为您的前端指定端口和特定域，您可以避免 CORS 攻击。浏览器 SOP 将阻止从其他资源加载脚本。更多详情请看这篇 Medium 文章:<a class="ae ll" href="https://medium.com/@ehayushpathak/security-risks-of-cors-e3f4a25c04d7" rel="noopener">https://Medium . com/@ ehayushpaak/security-risks-of-CORS-E3 F4 a 25 c 04d 7</a></p><p id="ebef" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">没有一个后端是真正安全的，因为总会有恶意入侵服务器的方法。甚至企业后端也不断遭受各种方式的数据泄露。然而，使用这些经验法则，您可以大大降低攻击的风险。这些仅仅是我长期以来收集的一些规则。</p></div></div>    
</body>
</html>