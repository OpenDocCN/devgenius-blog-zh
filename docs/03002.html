<html>
<head>
<title>Javascript Mistakes You May Be Making</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">您可能会犯的 Javascript 错误</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/javascript-mistakes-you-may-be-making-b316a0352c37?source=collection_archive---------6-----------------------#2020-09-19">https://blog.devgenius.io/javascript-mistakes-you-may-be-making-b316a0352c37?source=collection_archive---------6-----------------------#2020-09-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/1535dbbb7e938f174d4d7a78eb9933a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rE3mUWHSHhZE8GVPVgvzqA.jpeg"/></div></div></figure><p id="5509" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">今天我要谈谈你在 Javascript 项目中可能会犯的常见错误。</p><p id="1a95" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Javascript 是世界上最流行的语言之一，但是在编写代码时，由于误解或忽略我们已经知道的东西，仍然很容易出错。</p><h1 id="ccc4" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated"><strong class="ak">未定义和空值</strong></h1><p id="63be" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">Javascript 对于非值既有<code class="fe lz ma mb mc b">undefined</code>又有<code class="fe lz ma mb mc b">null</code>。然而，这两者之间有相当多的不同之处。<code class="fe lz ma mb mc b">undefined</code>意味着变量可能已经被声明了，但是没有给它设置任何东西。变量也可以被显式设置为<code class="fe lz ma mb mc b">undefined.</code><code class="fe lz ma mb mc b">undefined</code>变量的类型，当用<code class="fe lz ma mb mc b">typeof</code>操作符检查类型时，会显示类型<code class="fe lz ma mb mc b">undefined</code>。不返回任何东西的函数返回<code class="fe lz ma mb mc b">undefined</code>。另一方面，<code class="fe lz ma mb mc b">null</code>值必须由返回<code class="fe lz ma mb mc b">null</code>的函数显式设置，或者直接设置为变量。当你检查一个设置了<code class="fe lz ma mb mc b">null</code>值的对象时，你会看到如果一个变量有<code class="fe lz ma mb mc b">null</code>值，那么它的类型就是<code class="fe lz ma mb mc b">object</code>。</p><p id="1dd4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">出于这个原因，当您将变量值设置为非值时，尽可能坚持使用<code class="fe lz ma mb mc b">undefined</code>会更容易。这减少了混淆，我们只需要检查变量的类型是否是<code class="fe lz ma mb mc b">undefined</code>就可以知道它是否是<code class="fe lz ma mb mc b">undefined</code>。对于<code class="fe lz ma mb mc b">null</code>和<code class="fe lz ma mb mc b">undefined</code>来说，这比进行两次检查要少得多。</p><p id="e13f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要编写返回<code class="fe lz ma mb mc b">undefined</code>的函数，您不必像这样做:</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="99e2" class="ml kx iq mc b gy mm mn l mo mp">const f = () =&gt; {}</span></pre><p id="0716" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">设置一个被赋予其他值的变量给<code class="fe lz ma mb mc b">undefined</code>:</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="2be7" class="ml kx iq mc b gy mm mn l mo mp">x = undefined;</span></pre><p id="9462" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">检查属性值是否为<code class="fe lz ma mb mc b">undefined</code>:</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="ec61" class="ml kx iq mc b gy mm mn l mo mp">typeof obj.prop === 'undefined'</span></pre><p id="2542" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">或者</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="524c" class="ml kx iq mc b gy mm mn l mo mp">obj.prop === undefined</span></pre><p id="84fc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">检查变量是否为<code class="fe lz ma mb mc b">undefined</code>:</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="00ec" class="ml kx iq mc b gy mm mn l mo mp">typeof x === 'undefined'</span></pre><p id="696d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一个没有被自动赋值的声明变量的值是<code class="fe lz ma mb mc b">undefined</code>。</p><p id="c3b7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果需要检查<code class="fe lz ma mb mc b">null</code>:</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="f45b" class="ml kx iq mc b gy mm mn l mo mp">obj.prop === null</span></pre><p id="b416" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">或者</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="e684" class="ml kx iq mc b gy mm mn l mo mp">x === null</span></pre><p id="17a8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于变量。因为<code class="fe lz ma mb mc b">null</code>的数据类型是<code class="fe lz ma mb mc b">object</code>，所以不能使用<code class="fe lz ma mb mc b">typeof</code>运算符来检查<code class="fe lz ma mb mc b">null</code>。</p><h1 id="9903" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">加法和串联</h1><p id="47af" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">在 Javascript 中，<code class="fe lz ma mb mc b">+</code>操作符既用于将两个数字相加，也用于将字符串连接在一起。因为 Javascript 是一种动态语言，所以在应用操作之前，操作数会自动转换为相同的类型。例如:</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="5bc6" class="ml kx iq mc b gy mm mn l mo mp">let x = 1 + 1;</span></pre><p id="a900" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">那么你会得到 2，因为它们的类型相同。如您所料，<code class="fe lz ma mb mc b">+</code>操作用于加法。但是，如果您有以下表达式:</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="7853" class="ml kx iq mc b gy mm mn l mo mp">let x = 1 + '1';</span></pre><p id="0234" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">那么您将得到<code class="fe lz ma mb mc b">'11' </code>，因为在应用<code class="fe lz ma mb mc b">+</code>操作之前，第一个操作数将被强制转换成一个字符串。<code class="fe lz ma mb mc b">+</code>操作将用于连接而不是加法。当您在多个变量上使用<code class="fe lz ma mb mc b">+</code>操作符时，这使得知道类型变得更加困难。在这种情况下:</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="16dc" class="ml kx iq mc b gy mm mn l mo mp">let x = 1;  <br/>let y = 2;  <br/>let z = x + y;</span></pre><p id="67f1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你会得到 3，因为<code class="fe lz ma mb mc b">x</code>和<code class="fe lz ma mb mc b">y</code>都是数字。</p><p id="fb4b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">相反，如果我们有:</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="c830" class="ml kx iq mc b gy mm mn l mo mp">let x = 1;  <br/>let y = '2';  <br/>let z = x + y;</span></pre><p id="5b6c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后你会得到<code class="fe lz ma mb mc b">'12'</code>因为<code class="fe lz ma mb mc b">y</code>是字符串，所以会用<code class="fe lz ma mb mc b">+</code>运算符来代替串联。为了解决这个问题，我们应该在使用之前将所有的操作数转换成数字。这意味着我们应该将上面的代码重写为以下代码:</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="17ca" class="ml kx iq mc b gy mm mn l mo mp">let x = 1;  <br/>let y = '2';  <br/>let z = Number(x) + Number(y);</span></pre><p id="6cf8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于我们使用工厂函数<code class="fe lz ma mb mc b">Number</code>将两个操作数转换为数字，因此变量<code class="fe lz ma mb mc b">z</code>将为 3。<code class="fe lz ma mb mc b">Number</code>函数接受任何对象并返回一个数字，如果它能被解析成一个数字，否则返回<code class="fe lz ma mb mc b">NaN</code>。另一种方法是使用<code class="fe lz ma mb mc b">new Number(...).valueof()</code>功能，如下所示:</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="16c1" class="ml kx iq mc b gy mm mn l mo mp">let x = 1;  <br/>let y = '2';  <br/>let z = new Number(x).valueOf() + new Number(y).valueOf();</span></pre><p id="7b56" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为<code class="fe lz ma mb mc b">new Number(...)</code>是创建<code class="fe lz ma mb mc b">object</code>类型的构造函数，所以您希望使用<code class="fe lz ma mb mc b">valueof</code>函数将其转换回原始类型，以确保我们得到的是一个数字类型。一个简单的方法是:</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="a54c" class="ml kx iq mc b gy mm mn l mo mp">let x = 1;  <br/>let y = '2';  <br/>let z = +x + +y;</span></pre><p id="6d38" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">单个操作数前面的<code class="fe lz ma mb mc b">+</code>符号会尝试将单个操作数转换为数字，如果不能转换为数字，则转换为<code class="fe lz ma mb mc b">NaN</code>。它和<code class="fe lz ma mb mc b">Number</code>功能做同样的事情。您还可以将变量转换为特定类型的数字。<code class="fe lz ma mb mc b">Number</code>对象有一个将字符串或对象转换成整数的<code class="fe lz ma mb mc b">parseInt</code>函数和一个将字符串或对象转换成浮点数的<code class="fe lz ma mb mc b">parseFloat</code>函数。<code class="fe lz ma mb mc b">parseInt</code>将需要转换为数字的对象作为第一个参数。它还将基数作为可选的第二个参数，这是数学数字系统的基础。如果字符串以<code class="fe lz ma mb mc b">0x</code>开头，那么基数将设置为 16。如果字符串以任何其他字符开头，那么基数将被设置为 10。</p><p id="9e7e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可以这样使用它们:</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="2263" class="ml kx iq mc b gy mm mn l mo mp">let x = 1;  <br/>let y = '2';  <br/>let z = Number.parseInt(x) + Number.parseInt(y)</span></pre><p id="d1e4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您也可以使用<code class="fe lz ma mb mc b">parseFloat</code>代替<code class="fe lz ma mb mc b">parseInt</code>，如下所示:</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="e24c" class="ml kx iq mc b gy mm mn l mo mp">let x = 1;  <br/>let y = '2';  <br/>let z = Number.parseFloat(x) + Number.parseFloat(y)</span></pre><h1 id="bfff" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">将语句返回到多行</h1><p id="c1da" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">JavaScript 在最后关闭一个语句，所以一行代码被认为是不同的。例如，如果您有:</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="722f" class="ml kx iq mc b gy mm mn l mo mp">const add = (a, b) =&gt; {  <br/>  return  <br/>  a + b;  <br/>}</span></pre><p id="8f50" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您在运行<code class="fe lz ma mb mc b">a + b</code>之前运行了结束函数执行的<code class="fe lz ma mb mc b">return</code>语句，然后运行<code class="fe lz ma mb mc b">console.log(add(1, 2));</code>，您将得到<code class="fe lz ma mb mc b">undefined</code>。因此，<code class="fe lz ma mb mc b">a + b</code>永远不会在这个功能中运行。要解决这个问题，您要么将所有的<code class="fe lz ma mb mc b">return</code>语句放在一行中，要么用括号将您想要返回的内容括起来。例如:</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="b75c" class="ml kx iq mc b gy mm mn l mo mp">const add = (a, b) =&gt; {  <br/>  return a + b;  <br/>}</span></pre><p id="9a5c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您运行<code class="fe lz ma mb mc b">console.log(add(1, 2));</code>，它将记录 3，因为您实际上是在函数中返回计算结果。你也可以写:</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="e554" class="ml kx iq mc b gy mm mn l mo mp">const add = (a, b) =&gt; {  <br/>  return (  <br/>    a + b  <br/>  );  <br/>}</span></pre><p id="45cc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这对于返回可能长于一行的表达式很方便。如果我们运行<code class="fe lz ma mb mc b">console.log(add(1, 2));</code>，也会记录 3。对于箭头函数，您也可以编写:</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="ff59" class="ml kx iq mc b gy mm mn l mo mp">const add = (a, b) =&gt; (a + b)</span></pre><p id="8755" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">得到同样的结果。这也适用于单行箭头函数。</p><p id="0f1e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在 JavaScript 中，如果语句不完整，比如:</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="3fbd" class="ml kx iq mc b gy mm mn l mo mp">const power = (a) =&gt; {  <br/>  const  <br/>    power = 10;  <br/>  return a ** 10;  <br/>}</span></pre><p id="b87c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在函数内部，JavaScript 解释器将运行第一行和第二行来获得完整的语句。所以:</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="c08f" class="ml kx iq mc b gy mm mn l mo mp">const  <br/>  power = 10;</span></pre><p id="68bb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，对于像<code class="fe lz ma mb mc b">return</code>语句这样的完整语句，JavaScript 解释器会将它们视为单独的行。所以:</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="43dd" class="ml kx iq mc b gy mm mn l mo mp">return   <br/>  a ** 10;</span></pre><p id="61a1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不等同于:</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="cca3" class="ml kx iq mc b gy mm mn l mo mp">return a ** 10;</span></pre><h1 id="03b8" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">结论</h1><p id="6b65" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">即使 JavaScript 是一种友好的语言，在编写 JavaScript 代码时仍然很容易出错。当你不熟悉 JavaScript 时，很容易混淆<code class="fe lz ma mb mc b">undefined</code>和<code class="fe lz ma mb mc b">null</code>。由于 JavaScript 的动态类型特性，像<code class="fe lz ma mb mc b">+</code>操作符这样可以做多件事的操作符很容易被转换成我们不期望的类型，并产生错误的结果。此外，如果语句本身可以是完整的，那么如果你希望两行在一起，它们就不应该写在自己的行中。</p><p id="8753" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">今天到此为止。</p><p id="19cd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">感谢您的关注，敬请关注。</p><p id="aefe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">编码快乐！</p></div></div>    
</body>
</html>