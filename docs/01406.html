<html>
<head>
<title>Why the Dagger Needs a New Hilt</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么匕首需要新的刀柄</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/why-the-dagger-needs-a-new-hilt-e6ed7012b228?source=collection_archive---------25-----------------------#2020-07-02">https://blog.devgenius.io/why-the-dagger-needs-a-new-hilt-e6ed7012b228?source=collection_archive---------25-----------------------#2020-07-02</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/eda313d16383ee2e8dbf59063587d193.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*om-_lsw_18ixFvpiWPIrjw.jpeg"/></div></div></figure><p id="245e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在我做程序员的第五年，我终于明白了<a class="ae kt" href="https://en.wikipedia.org/wiki/Dependency_injection#:~:text=In%20software%20engineering%2C%20dependency%20injection,object%20is%20called%20a%20service." rel="noopener ugc nofollow" target="_blank">依赖注入</a>是怎么回事，以及我为什么需要它。不久之后，我意识到没有阿迪框架走这条路是不切实际的。我发现了匕首并决定使用它。这是我遵循指南时的最初想法:</p><blockquote class="ku"><p id="2605" class="kv kw in bd kx ky kz la lb lc ld ks dk translated">什么是组件？？！！我只想使用我的模块中的类！</p></blockquote><p id="c894" class="pw-post-body-paragraph jv jw in jx b jy le ka kb kc lf ke kf kg lg ki kj kk lh km kn ko li kq kr ks ig bi translated">我认为Dagger的困惑来源于它除了是阿迪框架之外，还指示了一种额外的架构方法:<a class="ae kt" href="https://en.wikipedia.org/wiki/Component-based_software_engineering" rel="noopener ugc nofollow" target="_blank">基于组件的应用程序开发</a>。</p><h2 id="446e" class="lj lk in bd ll lm ln dn lo lp lq dp lr kg ls lt lu kk lv lw lx ko ly lz ma mb bi translated">通过现实生活中的例子理解组件</h2><p id="1708" class="pw-post-body-paragraph jv jw in jx b jy mc ka kb kc md ke kf kg me ki kj kk mf km kn ko mg kq kr ks ig bi translated">人体是一个复杂的系统。它包含数百万种功能和数万亿个细胞。但是它也可以被描述为具有清晰边界的少量离散的独立器官。由于这一点，医生可以为特定的器官提供正确的治疗，甚至替换它。</p><figure class="mi mj mk ml gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mh"><img src="../Images/3a8b85a21dac115911ee9f9b71d066e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wO5tUT-nnQPmicsM6HxWmw.jpeg"/></div></div></figure><p id="1475" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这种模式无处不在:大系统被分成许多小的离散部分，每个部分都有自己的功能。</p><p id="c1ec" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Android应用程序是一个软件系统。软件能从其类的描述中被理解吗？<br/>当然不是！一个普通的软件项目会有数千个类。我们将不得不使用一个额外的抽象层，它不是Java或Kotlin的一部分。</p><h2 id="5977" class="lj lk in bd ll lm ln dn lo lp lq dp lr kg ls lt lu kk lv lw lx ko ly lz ma mb bi translated">软件成分</h2><p id="2dba" class="pw-post-body-paragraph jv jw in jx b jy mc ka kb kc md ke kf kg me ki kj kk mf km kn ko mg kq kr ks ig bi translated">一个<a class="ae kt" href="https://simplicable.com/new/software-components#:~:text=Software%20components%20are%20parts%20of,interchangeable%20parts%20of%20a%20machine." rel="noopener ugc nofollow" target="_blank">软件组件</a>是封装在一个接口后面的一堆功能，它创建了一个清晰的边界，定义了组件的内部或外部。<br/>一个组件通常由几个类组成，这些类为了达到某个目的而结合在一起。其中有些类可能是其公共API的一部分，有些可能是其实现的内部部分:</p><figure class="mi mj mk ml gt jo"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="1923" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这个特定的例子中:<code class="fe mo mp mq mr b">LocationManager</code> <em class="ms">、</em> <code class="fe mo mp mq mr b">LocationListener</code> <em class="ms">、</em>和<code class="fe mo mp mq mr b">Location</code>是由<code class="fe mo mp mq mr b">LocationManager</code>组件<strong class="jx io">、</strong>公开的API，但是在内部使用的实现可能有更多的类。</p><h2 id="f636" class="lj lk in bd ll lm ln dn lo lp lq dp lr kg ls lt lu kk lv lw lx ko ly lz ma mb bi translated">好的。那么匕首和它有什么关系呢？</h2><p id="8f29" class="pw-post-body-paragraph jv jw in jx b jy mc ka kb kc md ke kf kg me ki kj kk mf km kn ko mg kq kr ks ig bi translated">当你的代码被恰当地组织成组件时——类并不只是漂浮在项目的模块空间中，等待被抓取。阶级根本就不应该是第<a class="ae kt" href="https://en.wikipedia.org/wiki/First-class_citizen" rel="noopener ugc nofollow" target="_blank">第一公民</a>！它们只是组件的构建模块。</p><p id="4d23" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">带着这种想法，Dagger的API提供了一种机制来<strong class="jx io">构建组件而不是类。</strong></p><p id="0b51" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我个人认为，通过组件封装代码是一条可行之路，但是让它成为DI框架API的一部分无疑会让Dagger更难理解。</p><p id="7bbf" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果这还不够，既然Android不让你实例化<code class="fe mo mp mq mr b">Activity</code> / <code class="fe mo mp mq mr b">Service</code> <em class="ms"> </em>组件，Dagger就没法建了。所以对于android构造来说，<strong class="jx io">标注了</strong> <code class="fe mo mp mq mr b"><strong class="jx io">@Component</strong></code> <strong class="jx io">的接口并不是真正的组件</strong>。这只是在调用<code class="fe mo mp mq mr b">onCreate()</code> <em class="ms"> </em>期间应该注入自身的“真实”组件的内部内容:</p><figure class="mi mj mk ml gt jo"><div class="bz fp l di"><div class="mm mn l"/></div></figure><h2 id="96cc" class="lj lk in bd ll lm ln dn lo lp lq dp lr kg ls lt lu kk lv lw lx ko ly lz ma mb bi translated">那么《剑柄》有什么变化？</h2><p id="cfc7" class="pw-post-body-paragraph jv jw in jx b jy mc ka kb kc md ke kf kg me ki kj kk mf km kn ko mg kq kr ks ig bi translated">Google理解这些概念上的差距，但是想要提供一个向后兼容的解决方案。因此，在Hilt中，他们在Dagger的API之上创建了一个额外的抽象层，由<strong class="jx io">为您创建这些组件</strong>:</p><figure class="mi mj mk ml gt jo"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="8afa" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">不用创建Dagger组件，你只需要扩展<code class="fe mo mp mq mr b">ComponentActivity</code> <em class="ms">，</em>添加<code class="fe mo mp mq mr b">@AndroidEntryPoint</code>，并在模块定义中指定它可以“安装”到哪个组件类型中。</p><figure class="mi mj mk ml gt jo"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="ef5c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以最后，组件真的是组件，事情是有意义的。</p><h2 id="a578" class="lj lk in bd ll lm ln dn lo lp lq dp lr kg ls lt lu kk lv lw lx ko ly lz ma mb bi translated">结论</h2><p id="82bf" class="pw-post-body-paragraph jv jw in jx b jy mc ka kb kc md ke kf kg me ki kj kk mf km kn ko mg kq kr ks ig bi translated">如果你已经在使用匕首——用剑柄代替它不会给你额外的超能力。如果你是DI框架的新手——Hilt可能更容易集成。考虑到剑柄会在匕首之上增加额外的<a class="ae kt" href="https://www.techyourchance.com/dagger-hilt/" rel="noopener ugc nofollow" target="_blank">注释处理，这可能会减慢你的建造时间</a>。通过理解Dagger的“组件”哲学和陷阱，您可以避免它。</p><p id="646b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你喜欢我的解释，那么你也会发现我建议的定义应用组件的方法是有用的。</p></div></div>    
</body>
</html>