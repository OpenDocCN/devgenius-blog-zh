<html>
<head>
<title>Branching Strategies in VCS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">VCS的分支战略</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/branching-strategies-in-vcs-f50caec2603?source=collection_archive---------14-----------------------#2020-07-09">https://blog.devgenius.io/branching-strategies-in-vcs-f50caec2603?source=collection_archive---------14-----------------------#2020-07-09</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/32b3dc16300d538995cfac75c1bec745.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Owqay6l4kFy5LeEI"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">罗曼·布尔基在<a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="07f5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">“选择正确的分支合并策略…”</p><p id="9806" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">无论您使用什么版本控制工具，正确的分支策略都有助于开发团队轻松协作，同时不允许一个开发人员的破坏性或代码破坏影响另一个开发人员。</p><p id="ac81" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">以下是可以探索的策略。</p><h2 id="a471" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">基于主干的开发(无分支)</h2><p id="23bf" class="pw-post-body-paragraph ka kb in kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">顾名思义，只有一个主干，所有开发都在这里进行。这意味着所有开发人员都在同一个分支上工作，当变更被测试并准备好时，开发人员将他们的代码推送到中央存储库。</p><p id="ebcc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> <em class="lw">对小型组织</em> </strong>有效，或者那些具有强大内部测试实践的组织发现这种策略是有用的，因为它降低了复杂性并鼓励开发组织集中解决问题。</p><p id="78ba" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">它有自己的风险，比如一个被推的缺陷可能会停止所有的进展，直到主干被修复，导致不必要的变动或延迟。</p><h2 id="0fec" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">释放分支</h2><p id="0e6c" class="pw-post-body-paragraph ka kb in kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">发布分支是指一个发布包含在一个分支中的想法。每个版本都会创建一个分支(例如，“1.1开发分支”或“2.1版本”类型)，并且在下一个版本发布之前完成的所有工作都将在这个分支中进行。</p><p id="cdbe" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这种策略<strong class="kc io"> <em class="lw">大多用在落水和混战</em> </strong>过程中。如果有更多的人在同一个发布上工作，发布分支可能会变得笨拙，难以管理。除非你有非常小的发布周期，比如说少于两周:发布分支保持后期开发，发布延迟，长测试周期，和集成多个特性的挑战。</p><h2 id="6445" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">特征分支</h2><p id="577a" class="pw-post-body-paragraph ka kb in kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">特性分支通常与特性标志相结合来启用/禁用产品中的向后兼容特性，用于收集一系列用户故事，这些故事可以合并到一个主特性中，并作为一个完整的特性进行部署。这使得向连续交付过程的转移变得更加容易，并且，如果与toggles一起使用，也很容易决定何时向最终用户公开新的特性。</p><p id="4228" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这种方法减少了交付和测试周期时间。由于对小型快速发布的需求，需要一个<strong class="kc io"> <em class="lw">成熟的软件开发生命周期</em> </strong>来实现特性分支。因此，为了有效地使用这种策略，您的组织必须拥有最少的可行功能集。如果没有小版本的规则和经验，趋势将是构建大的、复杂的特性，类似于版本分支。</p><h2 id="d2fd" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">故事或任务分支</h2><p id="d18f" class="pw-post-body-paragraph ka kb in kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">这种策略直接将用户故事与源代码的变化联系起来。这是最低级别的分支，执行的每个问题都有自己的分支，通常与某个userStoryId相关联。</p><p id="9465" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因为敏捷主要围绕用户故事工作，这种类型的模型<strong class="kc io"> <em class="lw">对于拥有成熟敏捷开发过程</em> </strong>的组织来说是理想的，它清楚地将故事分解成足够小的可发布的功能集。这给了发布经理完全的灵活性和可见性，关于什么样的故事可以和什么样的发布一起进行，对发布进入生产的频率没有限制。</p><h1 id="471d" class="lx kz in bd la ly lz ma ld mb mc md lg me mf mg lj mh mi mj lm mk ml mm lp mn bi translated">合并策略</h1><p id="d9d9" class="pw-post-body-paragraph ka kb in kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">分支是短暂的分组，这使得它们易于在开发中协作。频繁地(和自动地)合并代码的能力对于避免长时间的/繁重的、昂贵的合并冲突是至关重要的。</p><p id="f5a8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">从您的分支中合并代码有三种常见的策略。</p><h2 id="db0a" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">手动代码审查和合并</h2><p id="d1ad" class="pw-post-body-paragraph ka kb in kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">最简单的合并策略之一。在合并到主分支之前，手动编码审查和测试。这可能是构建功能 的<strong class="kc io"> <em class="lw">初始阶段，但它可能会受到人为错误和延迟的困扰。</em></strong></p><h2 id="f383" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">最小连续积分</h2><p id="4b02" class="pw-post-body-paragraph ka kb in kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">最常见的<strong class="kc io"> <em class="lw">用于小型开发项目</em> </strong>，这种策略涉及到使用一个构建编排工具，比如Jenkins，来编译和测试源代码。通常这包括实现一系列的质量检查，或者不需要人工干预的机制来定量地执行质量，以防止没有通过测试的代码被合并到master中。通过所有质量检查的代码被自动合并到主分支。</p><p id="5133" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果你的组织有复杂的或者长时间运行的测试套件，这个策略可能不适合你。大的反馈周期会导致瓶颈，并引入更高频率的合并冲突。</p><h2 id="f80e" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">具有质量关口的持续集成管道</h2><p id="fa37" class="pw-post-body-paragraph ka kb in kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">这种策略利用集成分支——或者映射到开发生命周期管道中的阶段的分支——质量检查，以及来自构建流程编排工具的自动合并，以确保在管道中的特定阶段容易识别错误和缺陷，并且不会合并到主流程中。</p><p id="a81f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个策略对于使用各种测试类型 来确保质量的<strong class="kc io"> <em class="lw">组织很有帮助，比如单元测试、功能测试、回归测试、性能测试和安全测试。这有利于尽早清除容易发现的问题，使手工测试更加高效和有效。</em></strong></p><p id="020f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在实践中，我们可以使用与管道阶段相对应的开发、测试、试运行/预生产等分支。随着代码通过所需的测试并进入管道中的下一阶段，每个分支都会进行相应的合并。这使我们能够识别任何极限情况、多个特性集成之间的竞争条件，并在它们被部署到生产中之前隔离它们。</p></div><div class="ab cl mo mp hr mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ig ih ii ij ik"><h1 id="da78" class="lx kz in bd la ly mv ma ld mb mw md lg me mx mg lj mh my mj lm mk mz mm lp mn bi translated">关闭</h1><p id="27f2" class="pw-post-body-paragraph ka kb in kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">正如我们所见，这里没有放之四海而皆准的方法，领先的最佳实践是利用故事分支，在您的持续集成管道中自动合并您的质量检查门。</p><figure class="nb nc nd ne gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi na"><img src="../Images/333e3b2a73d9003e06fb6142ae1674e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ln6cZcNRGu5IdSGJ.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">VCS Git的推荐做法</figcaption></figure><p id="0fcf" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">上面是示例Git-flow和推荐的测试实践，分为三个阶段:构建和集成、质量保证以及阶段化和预生产。每一个阶段都有一系列的质量检查关口，以允许进行定性决策。例如，QA阶段要求特性、系统、集成和冒烟测试全部通过，以便进入下一阶段。</p><p id="59f9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为开发组织创建分支-合并策略有两个主要的好处:</p><ol class=""><li id="9d19" class="nf ng in kc b kd ke kh ki kl nh kp ni kt nj kx nk nl nm nn bi translated">您有一个策略，允许快速变更的集成，同时仍然执行机制来确保质量，这消除了快速移动的混乱，并为您的开发团队提供了方向</li><li id="4f27" class="nf ng in kc b kd no kh np kl nq kp nr kt ns kx nk nl nm nn bi translated">将变更分成小的、离散的单元有助于鼓励独立地测试变更，增加在软件开发生命周期的早期识别错误和缺陷的机会</li></ol><p id="e259" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">团队应该采用最合适的分支-合并策略，依靠现有的资源和来自他们构建编排工具的插件。随着时间的推移，团队可以迭代地增加质量关口，采用更小范围的分支，减少发布规模和周期时间，从而更快地将特性投入生产。</p><p id="4b00" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">第一步是决定哪种分支合并策略在文化和技术上适合你的组织。</p></div></div>    
</body>
</html>