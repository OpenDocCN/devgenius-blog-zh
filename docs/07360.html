<html>
<head>
<title>NodeJS Express Middleware</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">NodeJS 快速中间件</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/nodejs-express-middleware-2815cd93a73d?source=collection_archive---------6-----------------------#2022-03-18">https://blog.devgenius.io/nodejs-express-middleware-2815cd93a73d?source=collection_archive---------6-----------------------#2022-03-18</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="9cf2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Express 应用程序本质上是一系列中间件功能调用。“我认为这是一个有趣的说法，它实际上是如何工作的？</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/2c1632c56b801bd53bac4da45a691315.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hJgmTVTTyY88tBLcYL4Hdg.png"/></div></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk translated">NodeJS Express 中间件调用—程序代码</figcaption></figure><h1 id="fcf8" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">快速路由</h1><p id="364c" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">路由是我们在 express 中学习的第一件事，它看起来像这样:</p><pre class="kk kl km kn gt mc md me mf aw mg bi"><span id="ec65" class="mh la in md b gy mi mj l mk ml">const express = require('express')<br/>const app = express()</span><span id="3e28" class="mh la in md b gy mm mj l mk ml">app.get('*', (req, res) =&gt; res.send('hello world'))</span><span id="c6eb" class="mh la in md b gy mm mj l mk ml">app.listen(3000, () =&gt;<br/>  console.log(<br/>    'Server is running on: <a class="ae mn" href="http://localhost:3000" rel="noopener ugc nofollow" target="_blank">http://localhost:3000</a>'<br/>  )<br/>)</span></pre><p id="d618" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们学到第二件事是，这就是你如何声明 GET 请求路径。</p><p id="844e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后，我们学习 POST 请求，它们看起来像这样。</p><pre class="kk kl km kn gt mc md me mf aw mg bi"><span id="8109" class="mh la in md b gy mi mj l mk ml">const express = require('express')<br/>const app = express()</span><span id="1e70" class="mh la in md b gy mm mj l mk ml">app.get('*', (req, res) =&gt; res.send('hello world'))<br/>app.post('/user', (req, res) =&gt; {<br/>  /* Logic to add user */<br/>})</span><span id="ceb1" class="mh la in md b gy mm mj l mk ml">app.listen(3000, () =&gt;<br/>  console.log(<br/>    'Server is running on: <a class="ae mn" href="http://localhost:3000" rel="noopener ugc nofollow" target="_blank">http://localhost:3000</a>'<br/>  )<br/>)</span></pre><p id="6fdf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后我们想，好吧，这些是路线，路线是由 app.get 或 app.post 等声明的…</p><p id="6d4f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是当我们看到这样的代码示例时，我们会感到困惑。</p><pre class="kk kl km kn gt mc md me mf aw mg bi"><span id="11e2" class="mh la in md b gy mi mj l mk ml">const express = require('express')<br/>const routes = require('./routes')<br/>const app = express()</span><span id="a35c" class="mh la in md b gy mm mj l mk ml">app.use('/', routes.index)</span><span id="4d3f" class="mh la in md b gy mm mj l mk ml">app.listen(3000, () =&gt;<br/>  console.log(<br/>    'Server is running on: <a class="ae mn" href="http://localhost:3000" rel="noopener ugc nofollow" target="_blank">http://localhost:3000</a>'<br/>  )<br/>)</span></pre><p id="fe77" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我对这个 app.use 的想法是，这不是一条路线，因为它没有使用 app.get 或 app.post 或任何其他类似的东西。那是什么呢？</p><p id="aa84" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们不需要这个问题的答案，我们需要回答这个问题:这个中间件到底是什么？它在哪里？</p><h1 id="4e06" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">快速中间件</h1><p id="2d8e" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">既然 express 只是一系列的中间件，那我们就做一个<strong class="jm io"> <em class="ki">只有</em> </strong>有中间件的 app 吧。</p><pre class="kk kl km kn gt mc md me mf aw mg bi"><span id="2da6" class="mh la in md b gy mi mj l mk ml">const express = require('express');<br/>const app = express();</span><span id="1e05" class="mh la in md b gy mm mj l mk ml"><em class="ki">// Express is just a series of middleware<br/>// calls, hmmm...<br/>// Here, only middleware is registered<br/>// nothing like app.get(/* ... params */)<br/>// or app.post(/* ... params */)<br/>// but when we open<br/>// http://localhost:3000 in browser,<br/>// then look at the console<br/>// the output is:<br/>// First middleware GET<br/>// Second middleware GET</em></span><span id="45ea" class="mh la in md b gy mm mj l mk ml">app.use(<br/>  (<em class="ki">req</em>, <em class="ki">res</em>, next) =&gt; {<br/>    const method = req.method<br/>    console.log('First middleware', method);<br/>    return next();<br/>  }, (<em class="ki">req</em>, <em class="ki">res</em>, next) =&gt; {<br/>    const method = req.method<br/>    console.log('Second middleware', method);<br/>    return next();<br/>  }<br/>);</span><span id="01f2" class="mh la in md b gy mm mj l mk ml">app.listen(3000, () =&gt;<br/>  console.log(<br/>    'Server started on: <a class="ae mn" href="http://localhost:3000" rel="noopener ugc nofollow" target="_blank">http://localhost:3000</a>'<br/>  )<br/>);</span></pre><p id="4975" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在我们一个 app，浏览器一打开，这些中间件就跑了。我们没有路由，但是中间件在运行。</p><p id="54dc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这很有趣，因为如果没有声明路由，服务器如何知道处理哪些路由？很简单，处理所有请求，或者用一种恰当的方式来表达，对每个请求运行非路由处理程序。</p><p id="890d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在浏览器中打开下一个 URL:</p><ul class=""><li id="4c76" class="mo mp in jm b jn jo jr js jv mq jz mr kd ms kh mt mu mv mw bi translated"><a class="ae mn" href="http://localhost:3000" rel="noopener ugc nofollow" target="_blank"> http://localhost:3000 </a></li><li id="3741" class="mo mp in jm b jn mx jr my jv mz jz na kd nb kh mt mu mv mw bi translated"><a class="ae mn" href="http://localhost:3000/asd" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/ASD</a></li><li id="91dc" class="mo mp in jm b jn mx jr my jv mz jz na kd nb kh mt mu mv mw bi translated"><a class="ae mn" href="http://localhost:3000/asd/dfg" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/ASD/dfg</a></li></ul><p id="e952" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对于其中的每一个，我们都有这样的输出:</p><pre class="kk kl km kn gt mc md me mf aw mg bi"><span id="4962" class="mh la in md b gy mi mj l mk ml">First middleware GET<br/>Second middleware GET</span></pre><p id="6849" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这太神奇了，这意味着我们甚至不用处理请求就可以访问<strong class="jm io">请求</strong>和<strong class="jm io">响应</strong>对象。</p><p id="1435" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下面是通过中间件对<strong class="jm io"> <em class="ki">【路由处理器】</em> </strong>的模拟。</p><pre class="kk kl km kn gt mc md me mf aw mg bi"><span id="0bd4" class="mh la in md b gy mi mj l mk ml">const express = require('express');<br/>const app = express();</span><span id="0601" class="mh la in md b gy mm mj l mk ml"><em class="ki">// Express is just a series of middleware<br/>// calls, hmmm...<br/>// Here, only middleware is registered<br/>// nothing like app.get(/* ... params */)<br/>// or app.post(/* ... params */)<br/>// but when we open<br/>// http://localhost:3000 in browser,<br/>// then look at the console<br/>// the output is:<br/>// First middleware GET<br/>// Second middleware GET</em></span><span id="6fa0" class="mh la in md b gy mm mj l mk ml">app.use(<br/>  (<em class="ki">req</em>, <em class="ki">res</em>, next) =&gt; {<br/>    const method = req.method<br/>    console.log('First middleware', method);<br/>    return next();<br/>  }, (<em class="ki">req</em>, <em class="ki">res</em>, next) =&gt; {<br/>    const method = req.method<br/>    console.log('Second middleware', method);<br/>    return next();<br/>  }, (req, res, next) =&gt; {<br/>    res.send(<br/>      `Hello from ${req.method} <br/>      request to ${req.url}`<br/>    )<br/>  }<br/>);</span><span id="26d5" class="mh la in md b gy mm mj l mk ml">app.listen(3000, () =&gt;<br/>  console.log(<br/>    'Server started on: <a class="ae mn" href="http://localhost:3000" rel="noopener ugc nofollow" target="_blank">http://localhost:3000</a>'<br/>  )<br/>);</span></pre><p id="ac4a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果我转到<a class="ae mn" href="http://localhost:3000/asd" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/ASD</a>，我会看到<strong class="jm io"><em class="ki">“Hello from GET request to/ASD”</em></strong>，然后如果我转到控制台，我会看到:</p><pre class="kk kl km kn gt mc md me mf aw mg bi"><span id="62c3" class="mh la in md b gy mi mj l mk ml">First middleware GET<br/>Second middleware GET</span></pre><h1 id="1d49" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">结论</h1><p id="8a12" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">在 express 中，要扩展功能，只需添加中间件。如果我们需要每个请求的通用行为，这就是我们需要的。</p><p id="62ee" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">完整的例子可以在<a class="ae mn" href="https://github.com/srele96/sk-experiments/tree/develop/nodejs-express-middleware" rel="noopener ugc nofollow" target="_blank">https://github . com/srele 96/sk-experiments/tree/develop/nodejs-express-middleware</a>找到。</p></div></div>    
</body>
</html>