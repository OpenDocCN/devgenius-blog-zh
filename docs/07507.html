<html>
<head>
<title>GraphQL with Node.js: A Beginner’s Guide</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有 Node.js 的 GraphQL:初学者指南</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/graphql-with-node-js-a-beginners-guide-e5e9add51e14?source=collection_archive---------7-----------------------#2022-03-31">https://blog.devgenius.io/graphql-with-node-js-a-beginners-guide-e5e9add51e14?source=collection_archive---------7-----------------------#2022-03-31</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div class="gh gi jk"><img src="../Images/34aae13d1a4a6190396a49c4f6f33c62.png" data-original-src="https://miro.medium.com/v2/resize:fit:858/format:webp/1*YnTantyqOey7VzlevWtaeQ.png"/></div><figcaption class="jr js gj gh gi jt ju bd b be z dk translated">带有 Node.js 的 GraphQL</figcaption></figure><p id="4afa" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="kt">很长一段时间，我在 GraphQL 上工作，但是是在 DotNet 里。我打算使用 Node.js 与 GraphQL 一起工作，所以我做了一些研究，读了一些文章，把它们放在一起，它工作了。因此，我决定为像我一样想用 node.js 学习 GraphQL 的人做一个循序渐进的指南</em></p><h1 id="0d19" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">要求你所需要的，得到它！</h1><p id="98e2" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">向您的 API 发送一个 GraphQL 查询，得到您所需要的，不多也不少。GraphQL 查询总是返回可预测的结果。使用 GraphQL 的应用程序快速而稳定，因为它们控制着自己获得的数据，而不是服务器。</p><h1 id="8b61" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">入门指南</h1><p id="cb9d" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">如果你还没有，<a class="ae lx" href="https://nodejs.org/en/download/" rel="noopener ugc nofollow" target="_blank">下载并安装 Node.js </a>。安装后，让我们从目录结构开始。</p><p id="2f7f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">该项目分为两个目录，一个用于客户端，一个用于服务器。我选择将这两个项目都放在项目根目录中，但是如果您愿意，也可以将它分成两个不同的项目。</p><p id="3e95" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">📁项目<br/> ├──📁客户<br/> └──📁计算机网络服务器</p><p id="856d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们现在将在服务器目录中启动项目。在您的终端中，导航到服务器文件夹并执行 npm init 来填充项目信息并生成 package.json 文件。</p><p id="4174" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们的服务器将配置有<a class="ae lx" href="https://github.com/graphql/graphql-js" rel="noopener ugc nofollow" target="_blank"> GraphQL.js </a>和<a class="ae lx" href="https://github.com/apollographql/apollo-server" rel="noopener ugc nofollow" target="_blank"> Apollo 服务器</a>。GraphQL.js 将提供两个关键特性:</p><p id="312f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="kt"> 1。创建一个类型模式，我们将在下面的步骤中完成。<br/> 2。使用这种模式来处理查询。</em></p><h1 id="38b9" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated"><strong class="ak"> <em class="ly">如何定义模式:</em> </strong></h1><p id="0555" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">任何 GraphQL 服务器实现都依赖于 GraphQL 模式。它使用由数据源生成的类型和字段的层次结构来定义数据的形式。它还指定了哪些查询和变化是可用的，允许客户机知道可以请求或提供什么数据。</p><p id="e80d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">例如，如果我们想制作一个草图应用程序，我们最基本的模式(通常在 schema.graphql 文件中定义)将包括两种对象类型:草图和艺术家，如下所示:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="02e5" class="mi kv in me b gy mj mk l ml mm">type Sketch<br/>{ <br/>title: String<br/>artist: [Artist]<br/>}</span><span id="9479" class="mi kv in me b gy mn mk l ml mm">type Artist<br/>{<br/>name: String<br/>sketch: [Sketch]<br/>}</span></pre><p id="a185" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后，可用的查询将由查询类型定义:getSketches 和 getArtists，每个查询返回匹配类型的列表。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="47d5" class="mi kv in me b gy mj mk l ml mm">getSketches: [Sketch] type Query</span><span id="36be" class="mi kv in me b gy mn mk l ml mm">type Query <br/>{<br/>getSketches: [Sketch]<br/>getArtists: [Artist]<br/>}</span></pre><p id="855a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们的模式将只有一种查询类型，它将返回一个字符串，以使事情尽可能简单。</p><p id="4376" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">状态:字符串:类型查询</p><p id="05e3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了设计一个 GraphQL 模式并围绕它构建一个接口，我们可以使用任何编程语言，但是正如我前面提到的，我们将利用 Apollo 服务器来执行 GraphQL 查询。</p><p id="d08c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，在服务器目录下，我们创建一个新的 server.js 文件来描述模式。</p><p id="7b87" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">📁项目<br/> ├──📁客户<br/> └──📁服务器<br/> └──📄server.js</p><p id="c045" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在运行 npm install apollo-server 来安装 apollo-server。</p><p id="1020" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了解析模式，我们需要从 apollo-server 导入标记函数 gql:然后创建一个 typeDefs 常量，这是 Graphql 代码的抽象语法树。var gql = require(' Apollo-server ')；</p><p id="41aa" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">字符串是 GraphQL 服务器接收查询进行处理时最常见的格式。这个字符串必须被标记化并处理成机器可读的表示形式。抽象语法树是这种结构的名称。</p><p id="fedb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">AST Explorer 是一个在线工具，如果您想了解更多关于抽象语法树的知识，它可以让您作为解析器检查由所选语言形成的语法树。</p><p id="776b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">server.js 文件如下所示:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="543c" class="mi kv in me b gy mj mk l ml mm">const { gql } = require(‘apollo-server’);<br/>const typeDefs = gql<br/>type Query {<br/>status: String<br/>};</span></pre><h1 id="8290" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated"><strong class="ak">如何在你的代码中包含解析函数</strong></h1><p id="1805" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">既然我们已经定义了模式，我们将需要解析器来响应客户端对该数据的请求。</p><p id="98f0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">解析器是管理每个模式字段的数据的功能。例如，您可以通过从后端数据库或第三方 API 检索数据来将数据交付给客户端。</p><p id="6142" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">它们必须与模式的类型定义相匹配。在我们的示例中，我们只有一个类型定义 Query，它返回一个字符串状态，因此我们将为 status 字段构造一个解析器，如下所示:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="23f8" class="mi kv in me b gy mj mk l ml mm">const resolvers = {<br/>Query: {<br/>status: () =&gt; ‘Hello GQL Server!👋’,<br/>},<br/>};</span></pre><h1 id="54bf" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated"><strong class="ak">如何安装和配置服务器:</strong></h1><p id="aab5" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">我们在同一个 server.js 文件中定义并构建一个新的 ApolloServer 对象，将模式(typeDefs)和解析器作为参数传递。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="7cc2" class="mi kv in me b gy mj mk l ml mm">const { ApolloServer, gql } = require(‘apollo-server’);<br/>const server = new ApolloServer({ typeDefs, resolvers });</span></pre><p id="3182" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后，使用 listen 方法在 params 中指定的端口上启动服务器。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="d311" class="mi kv in me b gy mj mk l ml mm">server.listen({ port: 3000 }).then(serverInfo =&gt; <br/>console.log(`Server running at ${serverInfo.url}`));</span></pre><p id="17d9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们还可以在登录时<strong class="jx io">析构</strong>server info URL。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="ecfd" class="mi kv in me b gy mj mk l ml mm">server.listen({ port: 3000 }).then(({ url }) =&gt; <br/>console.log(`Server running at ${url}`));</span></pre><p id="f8a7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">server.js 文件现在应该是这样的:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="0176" class="mi kv in me b gy mj mk l ml mm">const { ApolloServer, gql } = require(‘apollo-server’);<br/>const typeDefs = gql.type Query <br/>{<br/>status: String<br/>};<br/>const resolvers = {<br/>Query: {<br/>status: () =&gt; ‘GQL Server!👋’,<br/>},<br/>};<br/>const server = new ApolloServer({ typeDefs, resolvers });<br/>server.listen({ port: 3000 }).then(({ url }) =&gt; <br/>console.log(`Server running at ${url}`));</span></pre><p id="212b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，如果我们运行 node server/server.js，我们将最终启动并运行我们的 GraphQL 服务器！🎉</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="8018" class="mi kv in me b gy mj mk l ml mm">You can go and check it out on <a class="ae lx" href="http://localhost:9000/" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/</a><br/>~/graphql-server<br/>&gt; node server/server.js<br/>Server running at <a class="ae lx" href="http://localhost:9000/" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/</a></span></pre><p id="9c0d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果您曾经处理过 RESTful 请求，您会发现这是一个类似邮递员的接口。只是你不需要下载或配置任何东西，因为它已经包含在 Apollo 中了！</p><h1 id="5304" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">如何设置客户端？</h1><p id="25f6" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">既然我们的服务器已经启动并运行，让我们把注意力集中在客户机上。首先，我们将在客户端子目录中创建一个 client.html 文件。</p><p id="8628" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">index.html 文件将有标准的 HTML 元素以及一个加载头(h1 &gt;)。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="62f4" class="mi kv in me b gy mj mk l ml mm">h1&gt;Loading…/h1&gt; to display something to the user while we request data from the server</span><span id="6082" class="mi kv in me b gy mn mk l ml mm">&lt;!DOCTYPE html&gt;<br/>&lt;html lang=”en”&gt;<br/>&lt;head&gt;&lt;meta charset=”UTF-8" /&gt;<br/>&lt;meta name=”viewport” content=”width=device-width, initial-scale=1.0" /&gt;<br/>&lt;title&gt;GQL Server&lt;/title&gt;<br/>&lt;/head&gt;<br/>&lt;body&gt;<br/>&lt;h1&gt;Loading…&lt;/h1&gt;<br/>&lt;script src=”app.js”&gt;&lt;/script&gt;<br/>&lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="bfe6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">如何从服务器访问数据？</strong></p><p id="0c66" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先，我们在同一个客户机文件夹中创建一个 app.js 文件，我们将在这个文件夹中编写从服务器获取数据的客户机逻辑。</p><p id="46b2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">📁项目<br/> ├──📁客户<br/> | └──📄client.html<br/>|└──📄└──📁服务器<br/> └──📄server.js</p><p id="237c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们将服务器 URL 设置为发出请求的 URL。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="47de" class="mi kv in me b gy mj mk l ml mm">const GRAPHQL_URL = ‘http://localhost:3000/';</span></pre><p id="de13" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后，为了从服务器获取状态，我们定义了异步函数 fetchStatus()。为了发出 HTTP 请求，我们将利用 fetch API，默认情况下，它会生成一个承诺，我们可以异步订阅和检索响应。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="e0d3" class="mi kv in me b gy mj mk l ml mm">async function fetchStatus() <br/>{<br/>const response = await fetch(GRAPHQL_URL, {<br/>method: ‘POST’,<br/>headers: <br/>{<br/>‘content-type’: ‘application/json’,<br/>},<br/>body: JSON.stringify({<br/>query: `query <br/>{<br/>status<br/>}<br/>`,<br/>}),<br/>});<br/>const responseBody = await response.json();<br/>console.log(responseBody);<br/>}</span></pre><p id="1f33" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">请求的方法是 POST，这一点需要记住。如果我们习惯使用 RESTful，这可能会令人困惑，因为 RESTful 的一个类似请求(我们只想从服务器获取信息)通常是用 get 方法发出的。</p><p id="a41b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">问题是在使用 GraphQL 时，我们总是以查询作为有效负载(主体)来发送 POST 请求。</p><p id="af30" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后，我们调用 fetchStatus()方法。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="196b" class="mi kv in me b gy mj mk l ml mm">const GRAPHQL_URL = ‘http://localhost:3000/';<br/>async function fetchStatus() <br/>{<br/>const response = await fetch(GRAPHQL_URL, {<br/>method: ‘POST’,<br/>headers: <br/>{<br/>‘content-type’: ‘application/json’,<br/>},<br/>body: JSON.stringify({<br/>query: `query <br/>{<br/>status<br/>}<br/>`,<br/>}),<br/>});<br/>const responseBody = await response.json();<br/>console.log(responseBody);<br/>}<br/>fetchStatus();</span></pre><p id="3c9f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果您在浏览器中打开该文件并查看开发人员工具中的控制台，您可以看到我们从查询中获得了状态数据。希望有帮助。</p><p id="856b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">参考资料:</strong><br/>T3】https://graphql.org/<br/>https://reindex.io/</p><p id="8a6e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">此外，我很想知道你对我能做些什么在这方面产生更好的影响的想法？</p></div></div>    
</body>
</html>