# “链表”简介

> 原文：<https://blog.devgenius.io/introduction-into-linked-lists-41fdc5bd3f31?source=collection_archive---------12----------------------->

链表是线性分组的数据集。它们由包含数据和指针的节点组成。我们将关注单链表，其节点包含数据和指向下一个节点的指针。但是，请记住，还有双向链表和循环链表。在这个故事中，我们将用爱莉安娜·格兰德的“谢谢你，下一个”来谈论*链表数据结构*。如果你还没有看过这首歌的音乐视频，请在我们开始之前暂停一下。

首先，我们将定义几个术语，以便将来不会有误解:

*   **指针**包含存储某些数据的内存区域的地址(对于指针，也允许空值)；
*   **引用**不像指针，必须始终指向一个特定的地址；
*   数据结构是一种分组信息的方式，可以在任何编程语言中实现。

在本文中，我们将使用以下列表:

![](img/14d15121e639d52a8935f8dbb58cf40c.png)

在这个图中，我们看到五个不同的节点，每个节点都包含某种数据。前四个是歌手在歌词中列出前任的顺序:

> *原以为我会和* ***肖恩***
> *但他并不般配*
> *写了一些关于* ***里基***
> *现在我听着笑着*
> *甚至差点结婚*
> *和为了* ***皮特***

最后一个结是 Ariana 本人:

> *此外，我遇到了另一个人*
> *我们正在进行更好的讨论*
> *我知道他们说我进展太快了*
> *但这个人是最后一个*
> 因为*她的名字是****Ari***
> *我很擅长这个(很擅长这个)*

*除了数据之外，每个节点都包含一个指向下一个节点的指针。阿丽亚娜总是以同样的顺序列出前任，在最后提到自己。当我们遍历链表的节点时，同样的顺序也适用。我们从头节点开始，移动到下一个节点，以此类推，直到结束。在单链表中，我们不能后退或者跳到随机选择的节点，我们必须坚持一个方向。*

*![](img/46116ba41f52083794ea136e750b8af0.png)*

*创建单链表最简单的方法是逐个创建和链接节点:*

*[一个类似于](https://github.com/aspittel/coding-cheat-sheets/blob/master/data_structures/linked_lists.md)的 Python 代码的例子。*

*如果我们显示节点`Sean`的内容，我们会看到它包含作为数据的名称，以及到下一个节点`Ricky`的链接。在属性`next`的帮助下，我们可以按顺序遍历所有节点。*

*![](img/9860cf9e5c120bbbb34031261337216f.png)*

*此外，我们在列表的末尾看到一个空指针。Ariana 声称自己是一个自给自足的人，因此下列节点不存在，她的节点不包含相应的链接。*

*链表相对于数组有一定的优势(它们是线性数据结构的主要替代品)。数组通常存储在一个单独的内存块中，这使得使用一个快速的公式来索引`start_of_array_in_memory + space_allocated_for_each_array_item * index_of_item_we_want`成为可能。当您需要获取特定索引处的对象时，这是非常有效的。但是，当删除或添加元素时，算法的效率会降低，因为所有数据都必须移动到另一个内存块。不能保证在数组的开头或结尾之前，内存中会有新对象的空间。要将一个对象插入一个数组的中间或者从那里移除它，同样的逻辑也起作用——您必须移动大量数据来获得空闲空间或者填充空隙。*

*![](img/b02e2998f8ddf2977125270d9937e472.png)*

*与数组不同，链表不需要将数据存储在一个连续的内存块中。这使得在列表的开头添加和删除项目变得更加容易。指针包含对任何内存位置的引用，添加新节点时不必移动大量数据。*

*搜索一个链表，在中间添加一个对象，然后删除这样的条目，效率要低得多。我们必须从头节点一直走到我们需要的节点。*

*链表的另一个缺点是它们需要更多的内存，因为除了数据之外，它们还存储指针。*

*让我们看一下实现所描述的操作的代码。我们将在链表的开头插入一个对象，并使用它的索引删除另一个对象，以显示对它的必要操作。*

*如果阿丽亚娜不再那么感激他，这就是从我们的链接列表中删除`Ricky`的样子:*

*![](img/af322f43c08bd9efc0970f28e339098f.png)*

*所有红色物体都被移除。*

*另外两种有用的方法是— `search`和`iterate`:*

*所以我们知道在链表中保存 Ariana 的前任列表是对这种数据结构的很好的利用。毕竟，我们总是按照相同的顺序列出它们，唱着“谢谢你，下一个”！例如，它们也非常适合于形成任务队列。因此，打印机一次打印一页，但我们希望添加额外的任务，而不是发送文档一次打印一页。当我们创建一个任务列表时，我们总是将新的对象添加到队列的末尾，然后打印列表中的第一个对象。同样的，浏览器的后退按钮或者编辑器的撤销功能也是有效的。为了实现这些功能，软件通常使用基于链表的堆栈或队列数据结构。*