<html>
<head>
<title>Next.JS — Implementing Static Site Generation and Server Side Rendering</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">下一个。JS —实现静态站点生成和服务器端呈现</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/next-js-static-site-generation-and-server-side-rendering-explained-bc9cae0885c6?source=collection_archive---------3-----------------------#2021-12-09">https://blog.devgenius.io/next-js-static-site-generation-and-server-side-rendering-explained-bc9cae0885c6?source=collection_archive---------3-----------------------#2021-12-09</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/f9555e5c7c69c267fcd2b7364cd1763a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WTDLSdAW-rUoX1AwKiJ78Q.png"/></div></div></figure><p id="16ec" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi kt translated"><span class="l ku kv kw bm kx ky kz la lb di">在</span>这篇文章中，我们来看看Next.js框架提供的内置渲染技术——<strong class="jx io">SSG(静态站点生成)和SSR(服务器端渲染)</strong>。通过示例和代码片段，我们还可以看到如何实现这两种渲染方法<strong class="jx io"> </strong>以及在开发应用程序时选择哪种类型的渲染。</p><p id="8b02" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">请阅读本文的第一部分，在那里我解释了Next.js框架的主要优点、内置特性、应用程序设置、文件夹结构和基于文件的路由。</p><div class="lc ld gp gr le lf"><a href="https://medium.com/geekculture/next-js-application-setup-and-file-based-routing-cbb0b70d514c" rel="noopener follow" target="_blank"><div class="lg ab fo"><div class="lh ab li cl cj lj"><h2 class="bd io gy z fp lk fr fs ll fu fw im bi translated">下一个。JS—应用程序设置和基于文件的路由(第1部分)</h2><div class="lm l"><h3 class="bd b gy z fp lk fr fs ll fu fw dk translated">当涉及到前端应用程序开发时，我们通常会更多地考虑优化以改进应用程序…</h3></div><div class="ln l"><p class="bd b dl z fp lk fr fs ll fu fw dk translated">medium.com</p></div></div><div class="lo l"><div class="lp l lq lr ls lo lt jt lf"/></div></div></a></div></div><div class="ab cl lu lv hr lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ig ih ii ij ik"><h1 id="8365" class="mb mc in bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated"><strong class="ak">next . js上的预渲染</strong></h1><p id="526a" class="pw-post-body-paragraph jv jw in jx b jy mz ka kb kc na ke kf kg nb ki kj kk nc km kn ko nd kq kr ks ig bi translated">默认情况下，Next.js为每个页面提供预渲染。这意味着Next.js框架在服务器端而不是客户端生成标记。因为服务器已经呈现了标记，所以我们不想扔掉它并重新创建所有的DOM元素。相反，我们希望“水合”静态标记，使其具有交互性。</p></div><div class="ab cl lu lv hr lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ig ih ii ij ik"><h1 id="c3ce" class="mb mc in bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">Next.js上的静态站点生成</h1><p id="cb3a" class="pw-post-body-paragraph jv jw in jx b jy mz ka kb kc na ke kf kg nb ki kj kk nc km kn ko nd kq kr ks ig bi translated">使用静态生成，页面内容是在构建时生成的。这意味着页面内容只创建一次，然后在每次请求时重用。页面内容现在驻留在服务器上，框架不再需要生成页面。这是为什么呢？如果页面是静态的(意味着它的内容不会改变)，那么它可以被CDN(内容交付网络)缓存并快速提供。每次请求时，浏览器都会更快地呈现页面。这非常适合内容不经常改变的页面。</p><p id="0c37" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，让我们看看如何在Next.js上实现<em class="ne">静态站点生成</em>！</p><h2 id="e263" class="nf mc in bd md ng nh dn mh ni nj dp ml kg nk nl mp kk nm nn mt ko no np mx nq bi translated">使用“getStaticProps”方法</h2><p id="8653" class="pw-post-body-paragraph jv jw in jx b jy mz ka kb kc na ke kf kg nb ki kj kk nc km kn ko nd kq kr ks ig bi translated">在Next.js中，可以静态地生成页面，可以提取数据也可以不提取数据。如果页面需要获取外部数据进行预渲染，Next.js允许您从同一个文件中调用一个名为<code class="fe nr ns nt nu b">getStaticProps</code>的<code class="fe nr ns nt nu b">export</code>函数。这个函数在构建时被调用，让您在预渲染时将获取的数据传递给页面的<code class="fe nr ns nt nu b">props</code>。</p><p id="6405" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们看看例子。我需要使用一个API获取外部数据(货币列表)来显示全球的货币列表。</p><figure class="nv nw nx ny gt jo"><div class="bz fp l di"><div class="nz oa l"/></div></figure></div><div class="ab cl lu lv hr lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ig ih ii ij ik"><h1 id="85ab" class="mb mc in bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">Next.js中的服务器端呈现</h1><p id="d8e8" class="pw-post-body-paragraph jv jw in jx b jy mz ka kb kc na ke kf kg nb ki kj kk nc km kn ko nd kq kr ks ig bi translated">如果您希望在用户请求之前预先呈现页面，而您的页面显示频繁更新的数据，并且页面内容在每次请求时都会发生变化，该怎么办呢？在这种情况下，我们可以跳过预渲染(SSG ),直接进行服务器端渲染。SSR有助于在服务器上呈现JavaScript，而不是将负担放在用户代理(浏览器)上，使内容在被请求时快速且容易地被访问。</p><p id="c8da" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Next.js还提供了一种服务器端渲染的方法。要使用SSR，您需要在页面中导出<code class="fe nr ns nt nu b">getServerSideProps</code>。</p><h2 id="c897" class="nf mc in bd md ng nh dn mh ni nj dp ml kg nk nl mp kk nm nn mt ko no np mx nq bi translated">使用“getServerSideProps”方法</h2><p id="7ffe" class="pw-post-body-paragraph jv jw in jx b jy mz ka kb kc na ke kf kg nb ki kj kk nc km kn ko nd kq kr ks ig bi translated">只有在需要预先呈现一个在请求时必须获取数据的页面时，才应该使用<code class="fe nr ns nt nu b">getServerSideProps</code>。到达第一个字节的时间(<a class="ae ob" href="https://web.dev/time-to-first-byte/" rel="noopener ugc nofollow" target="_blank"> TTFB </a>)会比<code class="fe nr ns nt nu b">getStaticProps</code>慢，因为服务器必须计算每个请求的结果。</p><p id="c81c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们看看例子。我需要获取SpaceX发射的所有航天飞机，并显示列表。</p><figure class="nv nw nx ny gt jo"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="45b0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在上面的代码片段中，<code class="fe nr ns nt nu b">getServerSideProps</code>在请求时被调用，它的参数<code class="fe nr ns nt nu b">context</code>包含特定于请求的参数。</p></div><div class="ab cl lu lv hr lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ig ih ii ij ik"><p id="a26e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你的应用程序/产品依赖于SEO 并且你的网站包含大量的<strong class="jx io">公共内容</strong>，那么静态网站生成(SSG) 是很棒的<strong class="jx io">。它也是经典CMS的一个很好的替代，性能和开发者体验会很好。</strong></p><p id="4352" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果您正在构建一个类似于电子商务网站的应用程序，或者任何B2C应用程序，在这些应用程序中，性能和页面加载应该更快，并且大部分页面都有外部数据读取，我建议在您的应用程序中使用SSR。由于内容是从服务器呈现的，所以TTFB在SSR中可能会慢一些，但是一旦应用程序被加载，性能就会变得平稳。</p></div><div class="ab cl lu lv hr lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ig ih ii ij ik"><p id="51a8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这就是Next.js中的SSG和SSR实现！查看Next.js中的SSR和SSG实现<a class="ae ob" href="https://github.com/vinayds21/NextJS-Application" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io">工作代码</strong> </a>，以及部署在vercel上的<a class="ae ob" href="https://next-js-application.vercel.app/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io">生产应用</strong> </a>。</p></div><div class="ab cl lu lv hr lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ig ih ii ij ik"><p id="687a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="ne">更多内容尽在</em><a class="ae ob" href="http://blog.devgenius.io" rel="noopener ugc nofollow" target="_blank"><em class="ne">blog . dev genius . io</em></a><em class="ne">。</em></p></div></div>    
</body>
</html>