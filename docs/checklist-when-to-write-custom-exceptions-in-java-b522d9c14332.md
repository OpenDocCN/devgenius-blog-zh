# 清单:何时用 Java 编写定制异常

> 原文：<https://blog.devgenius.io/checklist-when-to-write-custom-exceptions-in-java-b522d9c14332?source=collection_archive---------15----------------------->

![](img/1d772843bc664cca3189e62a7d0ede2f.png)

照片由 [Ibrahim Boran](https://unsplash.com/@ibrahimboran?utm_source=medium&utm_medium=referral) 在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄

Java 允许我们编写定制的异常。假设您希望在`com.example`包中有一个名为`MyCustomException`的异常。

就这么简单。仅仅通过扩展`RuntimeException`(或者`Exception`，如果我们需要这是一个被检查的异常)，我们就有了一个新的定制异常，可以像任何“标准”异常一样被抛出和捕获。

然而，这感觉不太对，我觉得那些空牙套有些不对劲，你可能也觉得不对劲。在 Scala 中，我们可以完全省略空括号，以及备受指责的分号。

这就引出了一个问题:我们为什么要编写一个“空”异常呢？为什么我们应该写一个定制的异常类，什么时候写？

我有一份清单。如果以下三个条件都成立，则需要在 Java 项目中编写自定义异常:

*   Java 开发工具包(JDK)和任何可用于您的项目的第三方库都没有为您需要处理的确切异常场景提供异常。
*   你需要给异常构造函数提供一个或多个特定类型的对象(`String`对于异常消息不算)。
*   您需要提供一种特定的方法来从异常中恢复，包括特定的类或接口。

也许第二点和第三点可以折叠成一个点。我们稍后会再讨论这个问题。

显然，如果 JDK 提供了一个异常类，它的意思和所做的正是您需要它的意思和所做的，那么您就没有必要重新发明那个轮子。

例如，假设对于`Fraction`类，您需要一个异常来表示发生了下溢或上溢(例如，分母变得比类设计处理的要大)。

这看起来像是一个明显的`ArithmeticException`的例子，因为它来自`java.lang`包，所以不需要导入。

但是，注意`ArithmeticException`只有两个构造函数:一个带有异常消息的`String`参数，另一个没有参数，用于空异常消息。

如果您想传递导致溢出的两个`Fraction`实例呢？这可能是自定义异常的一个合理原因，比如`FractionArithmeticException`。

但是`FractionArithmeticException`会提供什么具体的恢复方法呢？那些恢复过程难道不需要与`Fraction`类紧密耦合吗？

因此，也许你会得出结论，普通的老`ArithmeticException`对`Fraction`来说已经足够了，希望这些溢出问题只会在开发中出现，最终用户永远不会看到它们。

让我们转向更有可能被最终用户看到的东西。假设我们正在为一家银行开发一个程序，该银行主要处理美元业务，但也有一些用欧元结算的 VIP 账户。

您可能知道，JDK 提供了`java.util.Currency`，它表示美元和欧元等货币，但不表示美元或欧元的具体金额，如 89.47 美元或 78.95€。

绝对不要为此使用浮点数。也不要使用`BigDecimal`，尽管这比浮点原语好得多。

我们可以使用第三方库，但是由于某种原因，我们假想的项目经理坚持让我们从头开始创建自己的`CurrencyAmount`类。

所以我们做了整个测试驱动开发(TDD)步骤，从一个`CurrencyAmount`类构造函数开始，它接受一个数值类型的参数和一个`Currency`实例。

`Currency`实例可以是对应于传统政府支持的货币的任何实例，该货币具有特定面值的实际纸币和硬币。我们说的是美元、欧元、法郎等。

但是`Currency`与贵金属相对应的实例，如黄金(XAU)和白银(XAG)，应该被拒绝，但有例外。对于`IllegalArgumentException`来说，这似乎是一个明确的案例。

随着我们继续 TDD 过程，我们可以使用我们的`CurrencyAmount`类来加减相同货币的金额，例如$110.25 + $73.58。

如果货币不匹配，例如 183.83-18.99€，该怎么办？根据我们现在的项目，这将给出 164.84 美元或 164.84€，这两者几乎总是错的。

我们需要一个异常，表示“货币不匹配，也许您应该将一种货币转换成另一种货币。”由于 JDK 没有提供表示货币金额的类，所以它不需要提供这样的异常。

此外，我们希望该异常提供两种不同的恢复方式:要么将 *A* 金额转换为 *B* 的货币，要么将 *B* 金额转换为 *A* 的货币。这些可以分别称为`convertAmountAToBCurrency()`和`convertAmountBToACurrency()`。

在本例中，183.83 美元可能会兑换成 162.29€(根据汇率可能有上下浮动)，或者更有可能的是，18.99€会兑换成 21.51 美元(假设汇率与之前的兑换相同)。

在银行用例中，银行可能选择征收某种货币转换费。这将进入我们的不匹配货币异常的 Catch 块。

为了提供转换函数，异常构造函数必须接受两个`CurrencyAmount`实例。因此清单的所有三点都满足了，我们将编写一个新的定制异常，它比`MyCustomException`在花括号之间有更多的内容。

但是，请注意第二点，关于构造函数的一点，似乎是第三点的自然结果，需要提供一些特定的恢复方法。

我想不出清单的第二点或第三点是正确的，而另一点是错误的。你能想到这样的情况吗？请让我知道。

因此，也许我们可以将清单简化为两点:

*   没有现有的可用例外意味着或做我们需要的，和
*   我们需要提供一些具体的恢复方法

如果清单上的两点都满足了，那么我们可以并且应该编写一个定制的异常，它意味着并且做我们需要的事情，并且提供一些从异常中恢复的方法。

有了这个清单，你就不必担心“空”或“YAGNI”异常类。“YAGNI”代表“你不需要它”但是，如果满足了清单中的两点，那么是的，您将需要那个自定义异常，并且您应该编写它。