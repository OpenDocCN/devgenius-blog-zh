<html>
<head>
<title>Top 7 most expected JS features in recent years</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">近年来最受期待的 7 大 JS 特性</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/top-7-most-expected-js-features-in-recent-years-54b8ef775182?source=collection_archive---------6-----------------------#2020-08-29">https://blog.devgenius.io/top-7-most-expected-js-features-in-recent-years-54b8ef775182?source=collection_archive---------6-----------------------#2020-08-29</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/421f52763b8900905c63b8bddec05e05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*bF9h0NCtdCNtXMJ9.jpg"/></div></div></figure><p id="17bb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">自从 ECMAScript 2015 发布以来，在 JS 中跟踪新特性变得越来越困难。</p><p id="2480" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在本文中，我想谈谈社区最期待的 7 个特性。</p><p id="5672" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们潜水吧！</p><h1 id="9fad" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">1.动态导入</h1><p id="b5d8" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">这个函数增加了一个<code class="fe lw lx ly lz b">import(specifier)</code>句法形式，在很多方面都像一个函数(见下文)。它返回所请求模块的模块命名空间对象的承诺，该对象是在获取、实例化和评估所有模块的依赖关系以及模块本身之后创建的。</p><p id="62f3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这里您可以看到<code class="fe lw lx ly lz b">import()</code>如何在一个非常简单的单页应用程序中通过导航实现延迟加载模块:</p><figure class="ma mb mc md gt jo"><div class="bz fp l di"><div class="me mf l"/></div></figure><ul class=""><li id="1eef" class="mg mh in jx b jy jz kc kd kg mi kk mj ko mk ks ml mm mn mo bi translated"><code class="fe lw lx ly lz b">import()</code>可以从脚本中使用，而不仅仅是从模块中。</li><li id="1ac7" class="mg mh in jx b jy mp kc mq kg mr kk ms ko mt ks ml mm mn mo bi translated">如果<code class="fe lw lx ly lz b">import()</code>用于一个模块中，则它可以在任何位置、任何级别出现，而不是被吊起。</li><li id="e8cc" class="mg mh in jx b jy mp kc mq kg mr kk ms ko mt ks ml mm mn mo bi translated"><code class="fe lw lx ly lz b">import()</code>接受任意字符串(这里显示了运行时确定的模板字符串)，而不仅仅是静态字符串。</li><li id="f208" class="mg mh in jx b jy mp kc mq kg mr kk ms ko mt ks ml mm mn mo bi translated">模块中<code class="fe lw lx ly lz b">import()</code>的存在不会建立依赖关系，在评估包含模块之前必须提取并评估该依赖关系。</li></ul><p id="7cc0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">多看:<a class="ae mu" href="https://github.com/tc39/proposal-dynamic-import" rel="noopener ugc nofollow" target="_blank">https://github.com/tc39/proposal-dynamic-import</a></p><h1 id="ecce" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">2.异步函数</h1><p id="69b4" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">有一种特殊的语法可以以更舒适的方式处理承诺，称为“异步/等待”。函数前的“async”一词有一个简单的含义:函数总是返回一个承诺。其他值会自动包装在已解决的承诺中。关键字<code class="fe lw lx ly lz b">await</code>使 JavaScript 等待，直到承诺实现并返回结果。</p><figure class="ma mb mc md gt jo"><div class="bz fp l di"><div class="me mf l"/></div></figure><h2 id="a852" class="mv ku in bd kv mw mx dn kz my mz dp ld kg na nb lh kk nc nd ll ko ne nf lp ng bi translated">错误处理</h2><p id="3278" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">如果承诺正常达成，则<code class="fe lw lx ly lz b">await promise</code>返回结果。但在被拒绝的情况下，它会抛出错误，就像有一条<code class="fe lw lx ly lz b">throw</code>语句一样。在现实生活中，承诺可能需要一段时间才会被拒绝。在这种情况下，在<code class="fe lw lx ly lz b">await</code>抛出错误之前会有一段延迟。我们可以使用<code class="fe lw lx ly lz b">try..catch</code>捕捉到这个错误，就像常规的<code class="fe lw lx ly lz b">throw</code>一样:</p><figure class="ma mb mc md gt jo"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="9613" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">多看:<a class="ae mu" href="https://github.com/tc39/ecmascript-asyncawait" rel="noopener ugc nofollow" target="_blank">https://github.com/tc39/ecmascript-asyncawait</a></p><h1 id="8ea6" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">3.异步迭代器</h1><h2 id="3d0b" class="mv ku in bd kv mw mx dn kz my mz dp ld kg na nb lh kk nc nd ll ko ne nf lp ng bi translated">异步迭代器和异步 iterables</h2><p id="0f89" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">异步迭代器很像迭代器，除了它的<code class="fe lw lx ly lz b">next()</code>方法返回一个对<code class="fe lw lx ly lz b">{ value, done }</code>的承诺。如上所述，我们必须为迭代器结果对返回一个承诺，因为迭代器的下一个值和“完成”状态在迭代器方法返回时都是未知的。</p><figure class="ma mb mc md gt jo"><div class="bz fp l di"><div class="me mf l"/></div></figure><h2 id="c340" class="mv ku in bd kv mw mx dn kz my mz dp ld kg na nb lh kk nc nd ll ko ne nf lp ng bi translated">异步迭代语句:<code class="fe lw lx ly lz b">for</code> - <code class="fe lw lx ly lz b">await</code> - <code class="fe lw lx ly lz b">of</code></h2><p id="6573" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">引入了一个<code class="fe lw lx ly lz b">for-of</code>迭代语句的变体，它迭代异步可迭代对象。</p><figure class="ma mb mc md gt jo"><div class="bz fp l di"><div class="me mf l"/></div></figure><h2 id="9db8" class="mv ku in bd kv mw mx dn kz my mz dp ld kg na nb lh kk nc nd ll ko ne nf lp ng bi translated">异步发电机功能</h2><p id="c2b1" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">异步生成器函数类似于生成器函数，但有以下区别:</p><ul class=""><li id="f0e0" class="mg mh in jx b jy jz kc kd kg mi kk mj ko mk ks ml mm mn mo bi translated">当被调用时，异步生成器函数返回一个对象，一个<em class="nh">异步生成器</em>，其方法(<code class="fe lw lx ly lz b">next</code>、<code class="fe lw lx ly lz b">throw</code>和<code class="fe lw lx ly lz b">return</code>)返回对<code class="fe lw lx ly lz b">{ value, done }</code>的承诺，而不是直接返回<code class="fe lw lx ly lz b">{ value, done }</code>。这将自动生成返回的异步生成器对象<em class="nh">异步迭代器</em>。</li><li id="2555" class="mg mh in jx b jy mp kc mq kg mr kk ms ko mt ks ml mm mn mo bi translated">允许使用<code class="fe lw lx ly lz b">await</code>表达式和<code class="fe lw lx ly lz b">for</code> - <code class="fe lw lx ly lz b">await</code> - <code class="fe lw lx ly lz b">of</code>语句。</li><li id="81a5" class="mg mh in jx b jy mp kc mq kg mr kk ms ko mt ks ml mm mn mo bi translated">修改了<code class="fe lw lx ly lz b">yield*</code>的行为，以支持对异步可迭代对象的委托。</li></ul><figure class="ma mb mc md gt jo"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="61ab" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后，该函数返回一个异步生成器对象，该对象可由前面的示例中所示的<code class="fe lw lx ly lz b">for</code> - <code class="fe lw lx ly lz b">await</code> - <code class="fe lw lx ly lz b">of</code>使用。</p><p id="1f4a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">更多阅读:<a class="ae mu" href="https://github.com/tc39/proposal-async-iteration" rel="noopener ugc nofollow" target="_blank">https://github.com/tc39/proposal-async-iteration</a></p><h1 id="ba73" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">4.对象静止/扩散属性</h1><p id="42d9" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">ECMAScript 6 为数组析构赋值引入了<a class="ae mu" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment" rel="noopener ugc nofollow" target="_blank"> rest 元素</a>，为数组文字引入了<a class="ae mu" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator" rel="noopener ugc nofollow" target="_blank"> spread 元素</a>。</p><p id="e51e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个特性为对象析构赋值引入了类似的<a class="ae mu" href="https://github.com/tc39/proposal-object-rest-spread/blob/master/Rest.md" rel="noopener ugc nofollow" target="_blank"> rest 属性</a>，为对象字面量引入了<a class="ae mu" href="https://github.com/tc39/proposal-object-rest-spread/blob/master/Spread.md" rel="noopener ugc nofollow" target="_blank"> spread 属性</a>。</p><h2 id="a725" class="mv ku in bd kv mw mx dn kz my mz dp ld kg na nb lh kk nc nd ll ko ne nf lp ng bi translated">剩余属性</h2><p id="9d1c" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">Rest 属性收集剩余的自己的可枚举属性键，这些键还没有被析构模式挑选出来。这些键和它们的值被复制到一个新的对象上。</p><figure class="ma mb mc md gt jo"><div class="bz fp l di"><div class="me mf l"/></div></figure><h2 id="d627" class="mv ku in bd kv mw mx dn kz my mz dp ld kg na nb lh kk nc nd ll ko ne nf lp ng bi translated">传播属性</h2><p id="6bb8" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">在对象初始化器中传播属性将自己的可枚举属性从提供的对象复制到新创建的对象上。</p><figure class="ma mb mc md gt jo"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="fc25" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">更多阅读:<a class="ae mu" href="https://github.com/tc39/proposal-object-rest-spread" rel="noopener ugc nofollow" target="_blank">https://github.com/tc39/proposal-object-rest-spread</a></p><h1 id="a8e3" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">5.可选链接</h1><p id="739e" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">可选的链接操作符拼写为<code class="fe lw lx ly lz b">?.</code>。它可能出现在三个位置:</p><figure class="ma mb mc md gt jo"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="9068" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果<code class="fe lw lx ly lz b">?.</code>运算符左侧的操作数计算结果为 undefined 或 null，则表达式计算结果为 undefined。否则，正常触发目标属性访问、方法或函数调用。</p><figure class="ma mb mc md gt jo"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="aec4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">更多阅读:【https://github.com/tc39/proposal-optional-chaining T21】</p><h1 id="3d5c" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">6.无效合并</h1><p id="5949" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">如果<code class="fe lw lx ly lz b">??</code>运算符左侧的表达式计算结果为 undefined 或 null，则返回其右侧的表达式。</p><figure class="ma mb mc md gt jo"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="43c4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">更多阅读:<a class="ae mu" href="https://github.com/tc39/proposal-nullish-coalescing" rel="noopener ugc nofollow" target="_blank">https://github.com/tc39/proposal-nullish-coalescing</a></p><h1 id="c602" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">7.BigInt</h1><p id="b045" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated"><code class="fe lw lx ly lz b">BigInt</code>是一个原语，它提供了一种表示大于 253 的整数的方法，253 是 Javascript 可以用<code class="fe lw lx ly lz b">Number</code>原语可靠表示的最大数字</p><figure class="ma mb mc md gt jo"><div class="bz fp l di"><div class="me mf l"/></div></figure><h2 id="2528" class="mv ku in bd kv mw mx dn kz my mz dp ld kg na nb lh kk nc nd ll ko ne nf lp ng bi translated">句法</h2><p id="944f" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">通过将<code class="fe lw lx ly lz b">n</code>追加到整数的末尾或者通过调用构造函数来创建<code class="fe lw lx ly lz b">BigInt</code>。</p><figure class="ma mb mc md gt jo"><div class="bz fp l di"><div class="me mf l"/></div></figure><h2 id="cf05" class="mv ku in bd kv mw mx dn kz my mz dp ld kg na nb lh kk nc nd ll ko ne nf lp ng bi translated">经营者</h2><p id="298c" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">你可以用<code class="fe lw lx ly lz b">+</code>、<code class="fe lw lx ly lz b">*</code>、<code class="fe lw lx ly lz b">-</code>、<code class="fe lw lx ly lz b">**</code>和<code class="fe lw lx ly lz b">%</code>搭配<code class="fe lw lx ly lz b">BigInt</code> s，就像搭配<code class="fe lw lx ly lz b">Number</code> s 一样。</p><figure class="ma mb mc md gt jo"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="baab" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe lw lx ly lz b">/</code>操作符也像预期那样处理整数。但是，由于这些是<code class="fe lw lx ly lz b">BigInt</code>而不是<code class="fe lw lx ly lz b">BigDecimal</code>的，这个操作将向 0 舍入，也就是说，它不会返回任何小数。</p><h2 id="c4bb" class="mv ku in bd kv mw mx dn kz my mz dp ld kg na nb lh kk nc nd ll ko ne nf lp ng bi translated">比较和条件句</h2><p id="3462" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">一个<code class="fe lw lx ly lz b">BigInt</code>并不严格等于一个<code class="fe lw lx ly lz b">Number</code>，但它是宽松的。</p><figure class="ma mb mc md gt jo"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="17c9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">更多阅读:<a class="ae mu" href="https://github.com/tc39/proposal-bigint" rel="noopener ugc nofollow" target="_blank">https://github.com/tc39/proposal-bigint</a></p></div><div class="ab cl ni nj hr nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="ig ih ii ij ik"><p id="d9cb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你可以在这里阅读更多关于 2015 年以来所有新功能的信息<a class="ae mu" href="https://github.com/tc39/proposals/blob/master/finished-proposals.md" rel="noopener ugc nofollow" target="_blank">https://github . com/tc39/proposals/blob/master/finished-proposals . MD</a></p><p id="d995" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">P.S .如果你想知道最期待的特性——请阅读我的下一篇文章！</p></div></div>    
</body>
</html>