<html>
<head>
<title>Cache Your Functions in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在 Python 中缓存函数</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/cache-your-functions-in-python-95f8591caa07?source=collection_archive---------0-----------------------#2022-11-16">https://blog.devgenius.io/cache-your-functions-in-python-95f8591caa07?source=collection_archive---------0-----------------------#2022-11-16</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="b72e" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">Python 中缓存的简单演示</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/f2ce8b9e5a958e0d753aaa01ce000393.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*11VMSnN9MynV-k0_4C_l0g.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">照片由<a class="ae ks" href="https://unsplash.com/@daisy278?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">冯阮</a>在<a class="ae ks" href="https://unsplash.com/s/photos/memory?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="6f99" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">缓存是将经常需要的数据存储在离请求者更近的地方。因此，我们提高了获取信息的速度。</p><p id="0fda" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">举一个现实生活中的例子，你在一个大图书馆里做研究。你有一门物理相关的课程，你需要经常参考牛顿的数学原理。当你需要这本书的时候，要么你去书所在的书架，打开书，找到相关的地方，拿着你的笔记，回到你的书桌。或者，你可以把这本书拿走，放在你正在工作的桌子上，甚至可以把相关章节影印下来随身携带。第二种方式不是更合理吗？在这里，藏书楼是你放书的包或桌子。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi lp"><img src="../Images/f8a8843f326dd06ed2e7d450dd6f75cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:880/format:webp/1*5ez_Ao01zBXHnaQU1oo5pA.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">来源:<a class="ae ks" href="https://en.wikipedia.org/wiki/Philosophiæ_Naturalis_Principia_Mathematica" rel="noopener ugc nofollow" target="_blank">维基百科</a></figcaption></figure><p id="3db7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">缓存是一种优化技术。我们将经常使用的数据存储在可以更快更便宜地访问的内存区域。</p><p id="f752" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">缓存过程带来了速度，但大小有限。我们不能永远缓存数据。例如，在图书馆的例子中，我们可以放在桌子上的书的数量是有限的。</p><p id="ba26" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">由于这个限制，在缓存过程中明智地行动是必要的。为此，已经开发了缓存策略。根据情况所需的条件，可以优选任何技术。我们来考察一些策略。</p><ul class=""><li id="13f9" class="lq lr in kv b kw kx kz la lc ls lg lt lk lu lo lv lw lx ly bi translated">FIFO - First-In / First-Out:在 FIFO 逻辑中，当容量变满时，存储的第一个数据将是第一个被丢弃的数据。考虑一个存储从 A 到 g 的字母的数组，让这个数组满负荷。当 H 来的时候，我们丢弃 a，我们得到 H。如果对传入数据的访问更重要，可以使用这种策略。</li><li id="d101" class="lq lr in kv b kw lz kz ma lc mb lg mc lk md lo lv lw lx ly bi translated">后进先出:像堆栈数据结构一样，后进先出。如果访问最旧的数据更重要，可以使用这种类型。</li><li id="21fe" class="lq lr in kv b kw lz kz ma lc mb lg mc lk md lo lv lw lx ly bi translated">MRU -最近使用的:任何最近使用的数据都会被清除。如果重新访问的可能性随着数据使用日期的变老而增加，则可以使用它。</li><li id="35b5" class="lq lr in kv b kw lz kz ma lc mb lg mc lk md lo lv lw lx ly bi translated">LFU -最不常用:最不常用的数据被驱逐。保留经常访问的数据非常重要。</li><li id="5b71" class="lq lr in kv b kw lz kz ma lc mb lg mc lk md lo lv lw lx ly bi translated">LRU -最近最少使用:最近最少使用的数据被驱逐。最近使用的数据更有可能被重新访问。</li></ul><h2 id="11d7" class="me mf in bd mg mh mi dn mj mk ml dp mm lc mn mo mp lg mq mr ms lk mt mu mv mw bi translated">Python 实现</h2><p id="6021" class="pw-post-body-paragraph kt ku in kv b kw mx jo ky kz my jr lb lc mz le lf lg na li lj lk nb lm ln lo ig bi translated">让我们看看如何在 Python 中实现<strong class="kv io"> LRU 缓存</strong>。</p><p id="d671" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们有一个简单的函数叫做<em class="nc"> foo </em>。我放了一个 print 语句来表示这个函数在被调用时被执行。</p><pre class="kd ke kf kg gt nd ne nf bn ng nh bi"><span id="a2de" class="ni mf in ne b be nj nk l nl nm">def foo(x: int, y: int) -&gt; int:<br/>    print(f"executing foo with x: {x} y: {y}")<br/>    return x ** y<br/><br/>foo(3,4) <br/><br/>#executing foo with x: 3 y: 4<br/>#Out: 81</span></pre><p id="f06a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在，让我们使用 Python 的<em class="nc"> functools </em>包中的<em class="nc"> lru_cache </em>装饰器。如果你不知道什么是室内设计师，你可以看看下面的文章。</p><div class="nn no gp gr np nq"><a href="https://python.plainenglish.io/how-to-use-python-decorators-8e861f03007b" rel="noopener  ugc nofollow" target="_blank"><div class="nr ab fo"><div class="ns ab nt cl cj nu"><h2 class="bd io gy z fp nv fr fs nw fu fw im bi translated">Python Decorators 的内部</h2><div class="nx l"><h3 class="bd b gy z fp nv fr fs nw fu fw dk translated">用简单的例子解释装饰者</h3></div><div class="ny l"><p class="bd b dl z fp nv fr fs nw fu fw dk translated">python .平原英语. io</p></div></div><div class="nz l"><div class="oa l ob oc od nz oe km nq"/></div></div></a></div><p id="15c4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">总之…我把装饰器放在了<em class="nc"> foo </em>函数的顶部。然后，反复多次调用<em class="nc"> foo </em>函数。正如你所注意到的，它只是第一次执行这个函数。该函数被缓存。</p><pre class="kd ke kf kg gt nd ne nf bn ng nh bi"><span id="2de0" class="ni mf in ne b be nj nk l nl nm">from functools import lru_cache<br/><br/>@lru_cache<br/>def foo(x: int, y: int) -&gt; int:<br/>    print(f"executing foo with x: {x} y: {y}")<br/>    return x ** y<br/><br/>print(foo(3,4))<br/>print(foo(3,4))<br/>print(foo(3,4))<br/>print(foo(3,4))<br/>print(foo(3,4))<br/>print(foo(3,4))<br/>print(foo(3,4))<br/><br/>"""<br/>executing foo with x: 3 y: 4<br/>81<br/>81<br/>81<br/>81<br/>81<br/>81<br/>81<br/><br/>"""</span></pre><p id="679e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我已经更改了传递的值。它首先用新值执行它，然后缓存它。</p><pre class="kd ke kf kg gt nd ne nf bn ng nh bi"><span id="d664" class="ni mf in ne b be nj nk l nl nm">print(foo(3,4))<br/>print(foo(3,4))<br/><br/>print(foo(3,5))<br/>print(foo(3,5))<br/><br/>"""<br/>executing foo with x: 3 y: 4<br/>81<br/>81<br/><br/>executing foo with x: 3 y: 5<br/>243<br/>243<br/><br/>"""</span></pre><p id="2239" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们可以定义缓存的最大大小。</p><pre class="kd ke kf kg gt nd ne nf bn ng nh bi"><span id="a38b" class="ni mf in ne b be nj nk l nl nm">@lru_cache(maxsize=2)<br/>def foo(x: int, y: int) -&gt; int:<br/>    print(f"executing foo with x: {x} y: {y}")<br/>    return x ** y</span></pre><p id="66bf" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在，只有 2 个值将被缓存。并且当容量已满时，最近最少使用的值将被清除。</p><pre class="kd ke kf kg gt nd ne nf bn ng nh bi"><span id="9928" class="ni mf in ne b be nj nk l nl nm">print(foo(3,4))<br/>#executing foo with x: 3 y: 4<br/>#81<br/>print(foo(3,5))<br/>#executing foo with x: 3 y: 5<br/>#243<br/><br/>print(foo(3,4))<br/>#81<br/>print(foo(3,5))<br/>#243</span></pre><p id="558e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在再介绍一个；</p><pre class="kd ke kf kg gt nd ne nf bn ng nh bi"><span id="4279" class="ni mf in ne b be nj nk l nl nm">print(foo(2,4))<br/>#executing foo with x: 2 y: 4<br/>#16</span></pre><p id="8189" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">最近最少使用的一个被驱逐:<em class="nc"> print(foo(3，4)) </em></p><pre class="kd ke kf kg gt nd ne nf bn ng nh bi"><span id="3b0e" class="ni mf in ne b be nj nk l nl nm">print(foo(3,5))<br/>#243 &lt;- still from cache<br/><br/>print(foo(3,4))<br/>#executing foo with x: 3 y: 4 &lt;- executed again because it was evicted before<br/>#81</span></pre><p id="e76e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">考虑一个非常昂贵的操作，它每次都返回与另一个用例相同的输出。可以缓存。</p><pre class="kd ke kf kg gt nd ne nf bn ng nh bi"><span id="fec4" class="ni mf in ne b be nj nk l nl nm">@lru_cache(maxsize=1)<br/>def expensive_operation() -&gt; str:<br/>    print("$$$$$$$$$$$")<br/>    return "I am an expensive result"<br/><br/><br/>print(expensive_operation())<br/>print(expensive_operation())<br/>print(expensive_operation())<br/>print(expensive_operation())<br/>print(expensive_operation())<br/><br/>"""<br/>$$$$$$$$$$$<br/>I am an expensive result<br/>I am an expensive result<br/>I am an expensive result<br/>I am an expensive result<br/>I am an expensive result<br/>"""</span></pre><p id="2606" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">您可以使用<em class="nc"> __wrapped__ </em>访问缓存的原始函数</p><pre class="kd ke kf kg gt nd ne nf bn ng nh bi"><span id="3cda" class="ni mf in ne b be nj nk l nl nm">@lru_cache(maxsize=2)<br/>def foo(x: int, y: int) -&gt; int:<br/>    print(f"executing foo with x: {x} y: {y}")<br/>    return x ** y<br/><br/>print(foo(3,4))<br/><br/>og = foo.__wrapped__<br/>print(og)<br/><br/>print(og(3,4))<br/><br/>"""<br/>executing foo with x: 3 y: 4<br/>81<br/>&lt;function foo at 0x7fec2874aca0&gt;<br/>executing foo with x: 3 y: 4<br/>81<br/>"""</span></pre><p id="e351" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">一个经典的例子是斐波那契函数:</p><pre class="kd ke kf kg gt nd ne nf bn ng nh bi"><span id="e6d8" class="ni mf in ne b be nj nk l nl nm">def calculate_fibonacci(n: int) -&gt; int:<br/>    print("Calculating fibonacci value for ", n)<br/>    if n == 0 or n == 1:<br/>        return 1<br/>    return calculate_fibonacci(n-1) + calculate_fibonacci(n-2)<br/><br/>calculate_fibonacci(5)<br/><br/>"""<br/>Calculating fibonacci value for  5<br/>Calculating fibonacci value for  4<br/>Calculating fibonacci value for  3<br/>Calculating fibonacci value for  2<br/>Calculating fibonacci value for  1<br/>Calculating fibonacci value for  0<br/>Calculating fibonacci value for  1<br/>Calculating fibonacci value for  2<br/>Calculating fibonacci value for  1<br/>Calculating fibonacci value for  0<br/>Calculating fibonacci value for  3<br/>Calculating fibonacci value for  2<br/>Calculating fibonacci value for  1<br/>Calculating fibonacci value for  0<br/>Calculating fibonacci value for  1<br/>"""</span></pre><p id="fab8" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">一个递归函数…为了计算 n=5 的值，由于斐波纳契数列的性质，它被反复执行。</p><pre class="kd ke kf kg gt nd ne nf bn ng nh bi"><span id="549e" class="ni mf in ne b be nj nk l nl nm"><br/>@lru_cache(maxsize=16)<br/>def calculate_fibonacci(n: int) -&gt; int:<br/>    print("Calculating fibonacci value for ", n)<br/>    if n == 0 or n == 1:<br/>        return 1<br/>    return calculate_fibonacci(n-1) + calculate_fibonacci(n-2)<br/><br/>calculate_fibonacci(5)<br/><br/>"""<br/>Calculating fibonacci value for  5<br/>Calculating fibonacci value for  4<br/>Calculating fibonacci value for  3<br/>Calculating fibonacci value for  2<br/>Calculating fibonacci value for  1<br/>Calculating fibonacci value for  0<br/>"""</span></pre><p id="5032" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们比较一个大数字的计算时间:</p><pre class="kd ke kf kg gt nd ne nf bn ng nh bi"><span id="26cb" class="ni mf in ne b be nj nk l nl nm">start = time.time()<br/>calculate_fibonacci(35)<br/>print(time.time()-start)<br/><br/>"""<br/>without caching: 31.114999055862427 <br/>with caching: 0.00023484230041503906<br/>"""</span></pre><p id="ec47" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">最后，让我们创建一个自定义函数，为 API 请求缓存 JSON 格式的数据。</p><pre class="kd ke kf kg gt nd ne nf bn ng nh bi"><span id="6b70" class="ni mf in ne b be nj nk l nl nm">import json<br/>import requests<br/><br/>def fetch_api_data(url: str, json_path: str, update_cache: bool = False):<br/>    """<br/>    url: request url address<br/>    json_path: the path of the json file<br/>    update_cache: a boolean for update operation<br/>    """<br/>    if update_cache:<br/>        #if we are updating, current will be none<br/>        #so it will create a new json<br/>        cached_data = None<br/>    else:<br/>        try:<br/>            with open(json_path, 'r') as file:<br/>                cached_data = json.load(file)<br/>                print("Data has been collected from local cache!\n")<br/>        except(FileNotFoundError, json.JSONDecodeError) as e:<br/>            print(f"Some error occured when the JSON file is being read: {e}\n")<br/>            cached_data = None<br/>            <br/>    #if there is not a cached data available<br/>    if not cached_data:<br/>        #fetch request data<br/>        print("getting new data from url\n")<br/>        cached_data = requests.get(url).json()<br/>        with open(json_path, 'w') as file:<br/>            print("Creating a new cache JSON file\n")<br/>            json.dump(cached_data, file)<br/>    <br/>    return cached_data<br/><br/>url = "https://dummyjson.com/comments"<br/>json_path = "cachefile.json"<br/>data = fetch_api_data(url, json_path)<br/>print(data)<br/><br/>"""<br/>Some error occured when the JSON file is being read: [Errno 2] No such file or directory: 'cachefile.json'<br/><br/>getting new data from url<br/><br/>Creating a new cache JSON file<br/><br/>{'comments': [{'id': 1, 'body': 'This is some awesome thinking!', .......<br/>"""<br/><br/>#SECOND CALL<br/>data = fetch_api_data(url, json_path)<br/>print(data)<br/>"""<br/>Data has been collected from local cache!<br/><br/>{'comments': [{'id': 1, 'body': 'This ........<br/>"""</span></pre><p id="b3a6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果有一个存储缓存数据的 JSON 文件，该函数将读取该文件并返回数据。如果 JSON 文件不存在，或者被请求更新，或者读取时出现错误，它会通过从 URL 请求数据来收集数据，并将其写入新的 JSON 文件。</p><p id="163a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">因此，缓存是加速数据检索的一种重要的优化方法。多亏了缓存，我们可以实现更快更高效的应用。</p><p id="188d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">目前就这些。感谢阅读。</p><h2 id="d3fc" class="me mf in bd mg mh mi dn mj mk ml dp mm lc mn mo mp lg mq mr ms lk mt mu mv mw bi translated">阅读更多内容…</h2><div class="nn no gp gr np nq"><a href="https://python.plainenglish.io/how-to-use-python-decorators-8e861f03007b" rel="noopener  ugc nofollow" target="_blank"><div class="nr ab fo"><div class="ns ab nt cl cj nu"><h2 class="bd io gy z fp nv fr fs nw fu fw im bi translated">Python Decorators 的内部</h2><div class="nx l"><h3 class="bd b gy z fp nv fr fs nw fu fw dk translated">用简单的例子解释装饰者</h3></div><div class="ny l"><p class="bd b dl z fp nv fr fs nw fu fw dk translated">python .平原英语. io</p></div></div><div class="nz l"><div class="oa l ob oc od nz oe km nq"/></div></div></a></div><div class="nn no gp gr np nq"><a href="https://towardsdev.com/keep-loggin-loggin-loggin-loggin-in-python-f7c0c3088795" rel="noopener  ugc nofollow" target="_blank"><div class="nr ab fo"><div class="ns ab nt cl cj nu"><h2 class="bd io gy z fp nv fr fs nw fu fw im bi translated">继续登录，登录，登录，用 Python 登录</h2><div class="nx l"><h3 class="bd b gy z fp nv fr fs nw fu fw dk translated">快速发现 Python 中的日志记录</h3></div><div class="ny l"><p class="bd b dl z fp nv fr fs nw fu fw dk translated">towardsdev.com</p></div></div><div class="nz l"><div class="of l ob oc od nz oe km nq"/></div></div></a></div><div class="nn no gp gr np nq"><a href="https://python.plainenglish.io/test-driven-development-in-python-49fa22cb95d4" rel="noopener  ugc nofollow" target="_blank"><div class="nr ab fo"><div class="ns ab nt cl cj nu"><h2 class="bd io gy z fp nv fr fs nw fu fw im bi translated">Python 中的测试驱动开发</h2><div class="nx l"><h3 class="bd b gy z fp nv fr fs nw fu fw dk translated">关于 TDD 和 Python 实现的细节</h3></div><div class="ny l"><p class="bd b dl z fp nv fr fs nw fu fw dk translated">python .平原英语. io</p></div></div><div class="nz l"><div class="og l ob oc od nz oe km nq"/></div></div></a></div><div class="nn no gp gr np nq"><a href="https://levelup.gitconnected.com/unit-test-with-pytest-d6f53919a19a" rel="noopener  ugc nofollow" target="_blank"><div class="nr ab fo"><div class="ns ab nt cl cj nu"><h2 class="bd io gy z fp nv fr fs nw fu fw im bi translated">使用 PyTest 的单元测试</h2><div class="nx l"><h3 class="bd b gy z fp nv fr fs nw fu fw dk translated">使用 PyTest 介绍 Python 中的单元测试</h3></div><div class="ny l"><p class="bd b dl z fp nv fr fs nw fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="nz l"><div class="oh l ob oc od nz oe km nq"/></div></div></a></div><h2 id="fa37" class="me mf in bd mg mh mi dn mj mk ml dp mm lc mn mo mp lg mq mr ms lk mt mu mv mw bi translated">来源</h2><p id="eb6d" class="pw-post-body-paragraph kt ku in kv b kw mx jo ky kz my jr lb lc mz le lf lg na li lj lk nb lm ln lo ig bi translated"><a class="ae ks" href="https://realpython.com/lru-cache-python/" rel="noopener ugc nofollow" target="_blank">https://realpython.com/lru-cache-python/</a></p><p id="f4bf" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><a class="ae ks" href="https://www.mathsisfun.com/numbers/fibonacci-sequence.html" rel="noopener ugc nofollow" target="_blank">https://www.mathsisfun.com/numbers/fibonacci-sequence.html</a></p><p id="a2d9" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><a class="ae ks" href="https://www.fortinet.com/resources/cyberglossary/what-is-caching" rel="noopener ugc nofollow" target="_blank">https://www . fortinet . com/resources/cyber glossary/what-is-caching</a></p><p id="ce50" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><a class="ae ks" href="https://docs.python.org/3/library/functools.html" rel="noopener ugc nofollow" target="_blank">https://docs.python.org/3/library/functools.html</a></p><p id="05cb" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">https://www.youtube.com/watch?v=K0Q5twtYxWY<a class="ae ks" href="https://www.youtube.com/watch?v=K0Q5twtYxWY" rel="noopener ugc nofollow" target="_blank"/></p><p id="1525" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">https://www.youtube.com/watch?v=0_ievUF0L_E<a class="ae ks" href="https://www.youtube.com/watch?v=0_ievUF0L_E&amp;t=27s" rel="noopener ugc nofollow" target="_blank">t = 27s</a></p><p id="6519" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><a class="ae ks" href="https://www.youtube.com/watch?v=kErCTr9dwlk" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=kErCTr9dwlk</a></p></div></div>    
</body>
</html>