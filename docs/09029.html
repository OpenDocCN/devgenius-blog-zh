<html>
<head>
<title>SQL Window function</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SQL 窗口函数</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/sql-window-function-d39858e52784?source=collection_archive---------12-----------------------#2022-07-25">https://blog.devgenius.io/sql-window-function-d39858e52784?source=collection_archive---------12-----------------------#2022-07-25</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/953ce2c82bde78c33f6a03268ba7b916.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oGfo0AHY1ItLWQhirqp-8A.jpeg"/></div></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk translated"><a class="ae ja" href="https://unsplash.com/@mooo3721?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> R 莫</a>在<a class="ae ja" href="https://unsplash.com/s/photos/window?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><div class=""/><p id="9095" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">剖析窗口功能</p><p id="d96c" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">窗口函数是 SQL 的一个强大功能，它允许用户对查询中的行集执行计算和分析。</p><p id="1941" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">窗口函数基于滑动窗口框架计算结果。窗口框架是与当前行相关的一组行。这种关系是，对于窗口定义中由<strong class="kc je">子句</strong>划分的所有项，所有行都具有相同的<strong class="kc je">值</strong>。在每个<strong class="kc je">分区</strong>内单独评估窗框。Partition By 子句将行细分为多个组。</p><figure class="kz la lb lc gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi ky"><img src="../Images/6ee37b95c1390d3ce1fbd47e5a78c9f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Gud8oXe6TnbGgrzl8qOFwg.png"/></div></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk translated">划分依据</figcaption></figure><figure class="kz la lb lc gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi ld"><img src="../Images/6aa82c7c15e7533552d3eae4bb4ebba7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EmJlGbm54plXPGy2W2jWNw.png"/></div></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk translated">窗口和范围</figcaption></figure><h2 id="bd9b" class="le lf jd bd lg lh li dn lj lk ll dp lm kl ln lo lp kp lq lr ls kt lt lu lv lw bi translated">句法</h2><pre class="kz la lb lc gt lx ly lz ma aw mb bi"><span id="92bf" class="le lf jd ly b gy mc md l me mf">SELECT &lt;column list&gt;,<br/>    <strong class="ly je">&lt;window_function&gt; OVER (<br/>        PARTITION BY &lt;&gt;<br/>        ORDER BY &lt;&gt;<br/>        &lt;window_frame&gt;<br/>    ) window_alias</strong><br/>FROM &lt;table_name&gt;</span><span id="6e7a" class="le lf jd ly b gy mg md l me mf">OR</span><span id="f9e3" class="le lf jd ly b gy mg md l me mf">SELECT &lt;column list&gt; <strong class="ly je">OVER &lt;window_definition_name&gt;</strong><br/>FROM &lt;table_name&gt;<br/><strong class="ly je">WINDOW window_definition_name AS (<br/>    PARTITION BY &lt;&gt;<br/>    ORDER BY &lt;&gt;<br/>    &lt;window_frame&gt;<br/>)</strong></span></pre><h2 id="e35a" class="le lf jd bd lg lh li dn lj lk ll dp lm kl ln lo lp kp lq lr ls kt lt lu lv lw bi translated">例子</h2><pre class="kz la lb lc gt lx ly lz ma aw mb bi"><span id="8727" class="le lf jd ly b gy mc md l me mf">SELECT city, month,<br/>    SUM(amount) OVER (<br/>        PARTITION BY city<br/>        ORDER BY month<br/>        RANGE UNBOUNDED PRECEDING<br/>    ) as total_sale<br/>FROM Sales;</span><span id="d5c5" class="le lf jd ly b gy mg md l me mf">OR</span><span id="bf8a" class="le lf jd ly b gy mg md l me mf">SELECT city, month, SUM(amount) OVER window_definition_name<br/>FROM Sales<br/>WINDOW window_definition_name AS (<br/>    PARTITION BY city<br/>    ORDER BY month<br/>    RANGE UNBOUNDED PRECEDING<br/>)</span></pre><p id="0634" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">上述窗口功能理解如下:</p><figure class="kz la lb lc gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi mh"><img src="../Images/d7ec714fe7592d06e9e47a4c321fa0f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hYU-xjxV-IJQ_v3eQ6B_aQ.png"/></div></div></figure><p id="edb1" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">窗口函数在运算符整体逻辑顺序中的位置:</p><figure class="kz la lb lc gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi mi"><img src="../Images/1059b505dedd184d91b0c233983b735b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Oxgqd3IbSAgX6gFPDCeb2Q.png"/></div></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk translated">运算符的逻辑顺序</figcaption></figure><p id="8b96" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，从上面我们知道，窗口函数是在 select 部分运行之前应用的。此时，数据库服务器已经完成了评估查询所需的所有步骤，包括连接、过滤、分组和排序，并且结果集已经完成，可以返回给调用者。当结果集仍保存在内存中时，窗口函数将应用于该结果集。</p><p id="f60e" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">与聚合函数不同，窗口函数不会折叠行。</p><figure class="kz la lb lc gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi mj"><img src="../Images/076e7c7e5e7c0eeb03b11f02afc3f19c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WrHVeQ4wbWs2AN-aVdG8HA.png"/></div></div></figure><p id="84b1" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在窗口规范中，我们可以提供三种不同的框架条款:</p><blockquote class="mk ml mm"><p id="cda0" class="ka kb mn kc b kd ke kf kg kh ki kj kk mo km kn ko mp kq kr ks mq ku kv kw kx ig bi translated"><strong class="kc je"/>之间的行—与分区<br/> <strong class="kc je">范围</strong>中的当前行相距 N 的行—基于其与当前行相比的值的行。<br/> <strong class="kc je">组</strong> —统计窗口内所有绑定行的组数(在 Postgres 中)</p></blockquote><p id="8a6f" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="mn">【无界】前|当前行|【无界】后</em></p><p id="639e" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们可以使用以下窗口功能:</p><h2 id="5eb8" class="le lf jd bd lg lh li dn lj lk ll dp lm kl ln lo lp kp lq lr ls kt lt lu lv lw bi translated">聚合函数</h2><p id="e36c" class="pw-post-body-paragraph ka kb jd kc b kd mr kf kg kh ms kj kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">计数、最大值、最小值、总和、AVG</p><h2 id="84d5" class="le lf jd bd lg lh li dn lj lk ll dp lm kl ln lo lp kp lq lr ls kt lt lu lv lw bi translated">排名功能</h2><p id="b2f3" class="pw-post-body-paragraph ka kb jd kc b kd mr kf kg kh ms kj kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">行数，等级，密度等级</p><h2 id="4da7" class="le lf jd bd lg lh li dn lj lk ll dp lm kl ln lo lp kp lq lr ls kt lt lu lv lw bi translated">分布函数</h2><p id="6edf" class="pw-post-body-paragraph ka kb jd kc b kd mr kf kg kh ms kj kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">DIST CUME 的百分排名</p><h2 id="99f6" class="le lf jd bd lg lh li dn lj lk ll dp lm kl ln lo lp kp lq lr ls kt lt lu lv lw bi translated">位置函数</h2><p id="898c" class="pw-post-body-paragraph ka kb jd kc b kd mr kf kg kh ms kj kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">提前期、延迟期、第 n 个值、第一个值、最后一个值</p><p id="a63c" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">超前/滞后函数的语法。</p><p id="4439" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe mw mx my ly b">LEAD | LAG ( expression, offset, deafult_value) OVER</code></p><p id="1f72" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这两个函数在进行 YoY 和 QoQ 比较时非常有用。</p><h2 id="7e76" class="le lf jd bd lg lh li dn lj lk ll dp lm kl ln lo lp kp lq lr ls kt lt lu lv lw bi translated">分析函数</h2><p id="f396" class="pw-post-body-paragraph ka kb jd kc b kd mr kf kg kh ms kj kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">恩蒂莱</p><blockquote class="mk ml mm"><p id="0057" class="ka kb mn kc b kd ke kf kg kh ki kj kk mo km kn ko mp kq kr ks mq ku kv kw kx ig bi translated"><em class="jd">注意:我们不能在 where 子句中使用窗口函数来过滤数据。</em></p></blockquote><h1 id="fc86" class="mz lf jd bd lg na nb nc lj nd ne nf lm ng nh ni lp nj nk nl ls nm nn no lv np bi translated">问题</h1><p id="6f60" class="pw-post-body-paragraph ka kb jd kc b kd mr kf kg kh ms kj kk kl mt kn ko kp mu kr ks kt mv kv kw kx ig bi translated">185。部门前三名薪资</p><p id="f8b3" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc je">员工表</strong></p><pre class="kz la lb lc gt lx ly lz ma aw mb bi"><span id="75da" class="le lf jd ly b gy mc md l me mf">+--------------+---------+<br/>| Column Name  | Type    |<br/>+--------------+---------+<br/>| id           | int     |<br/>| name         | varchar |<br/>| salary       | int     |<br/>| departmentId | int     |<br/>+--------------+---------+</span></pre><p id="1fd5" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc je">部门表</strong></p><pre class="kz la lb lc gt lx ly lz ma aw mb bi"><span id="2b6b" class="le lf jd ly b gy mc md l me mf">+-------------+---------+<br/>| Column Name | Type    |<br/>+-------------+---------+<br/>| id          | int     |<br/>| name        | varchar |<br/>+-------------+---------+</span></pre><p id="68e8" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一家公司的高管感兴趣的是，看看公司各个部门中谁赚的钱最多。一个部门的<strong class="kc je">高收入者</strong>是指在该部门的<strong class="kc je">前三名中拥有独特</strong>薪水的员工。编写一个 SQL 查询来查找每个部门中<strong class="kc je">的高收入者</strong>的雇员。以任意顺序返回结果表<strong class="kc je"/>。</p><p id="76ab" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">例子</p><pre class="kz la lb lc gt lx ly lz ma aw mb bi"><span id="c0c7" class="le lf jd ly b gy mc md l me mf"><strong class="ly je">Input:</strong> <br/>Employee table:<br/>+----+-------+--------+--------------+<br/>| id | name  | salary | departmentId |<br/>+----+-------+--------+--------------+<br/>| 1  | Joe   | 85000  | 1            |<br/>| 2  | Henry | 80000  | 2            |<br/>| 3  | Sam   | 60000  | 2            |<br/>| 4  | Max   | 90000  | 1            |<br/>| 5  | Janet | 69000  | 1            |<br/>| 6  | Randy | 85000  | 1            |<br/>| 7  | Will  | 70000  | 1            |<br/>+----+-------+--------+--------------+<br/>Department table:<br/>+----+-------+<br/>| id | name  |<br/>+----+-------+<br/>| 1  | IT    |<br/>| 2  | Sales |<br/>+----+-------+<br/><strong class="ly je">Output:</strong> <br/>+------------+----------+--------+<br/>| Department | Employee | Salary |<br/>+------------+----------+--------+<br/>| IT         | Max      | 90000  |<br/>| IT         | Joe      | 85000  |<br/>| IT         | Randy    | 85000  |<br/>| IT         | Will     | 70000  |<br/>| Sales      | Henry    | 80000  |<br/>| Sales      | Sam      | 60000  |<br/>+------------+----------+--------+<br/><strong class="ly je">Explanation:</strong> <br/>In the IT department:<br/>- Max earns the highest unique salary<br/>- Both Randy and Joe earn the second-highest unique salary<br/>- Will earns the third-highest unique salary<br/><br/>In the Sales department:<br/>- Henry earns the highest salary<br/>- Sam earns the second-highest salary<br/>- There is no third-highest salary as there are only two employees</span></pre><p id="db09" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">解决方案:</p><p id="627c" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们首先给部门内的所有工资分配一个等级。我们通过使用如下窗口函数来实现这一点:</p><pre class="kz la lb lc gt lx ly lz ma aw mb bi"><span id="2f93" class="le lf jd ly b gy mc md l me mf">SELECT <br/>    departmentId, name, salary, <br/>    DENSE_RANK() OVER (PARTITION BY departmentId ORDER BY Salary desc) as r<br/>FROM Employee</span></pre><p id="e5ab" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">上述查询的输出如下:</p><pre class="kz la lb lc gt lx ly lz ma aw mb bi"><span id="ef22" class="le lf jd ly b gy mc md l me mf">+--------------+-------+--------+----+<br/>| departmentId | name  | salary | r  |<br/>+--------------+-------+--------+----+<br/>| 1            | Max   | 90000  | 1  |<br/>| 1            | Joe   | 85000  | 2  |<br/>| 1            | Randy | 60000  | 2  |<br/>| 1            | Will  | 90000  | 3  |<br/>| 1            | Janet | 69000  | 4  |<br/>| 2            | Henry | 85000  | 1  |<br/>| 2            | Sam   | 70000  | 2  |<br/>+--------------+-------+--------+----+</span></pre><p id="fa94" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一旦我们有了这个结果，我们就过滤掉等级&lt; 4 (1，2，3)的行。</p><pre class="kz la lb lc gt lx ly lz ma aw mb bi"><span id="49b3" class="le lf jd ly b gy mc md l me mf">WITH ranked_salary_for_each_dept AS (<br/>    SELECT departmentId, name, salary, <strong class="ly je">DENSE_RANK() OVER (PARTITION BY departmentId ORDER BY Salary desc)</strong> as r<br/>    FROM Employee<br/>) <br/>select d.Name as "Department", a.Name as "Employee", a.Salary as "Salary"<br/>from ranked_salary_for_each_dept a <br/>join Department d on a.departmentId = d.Id<br/>where a.r &lt; 4</span></pre><p id="8345" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">快乐开窗！！</p></div></div>    
</body>
</html>