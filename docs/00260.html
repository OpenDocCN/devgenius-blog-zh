<html>
<head>
<title>On the power of Hooks: Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">钩子的力量:第一部分</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/on-the-power-of-react-hooks-49094e76709c?source=collection_archive---------4-----------------------#2020-05-28">https://blog.devgenius.io/on-the-power-of-react-hooks-49094e76709c?source=collection_archive---------4-----------------------#2020-05-28</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/bc1614cff98c1aa8d606677ddcab9e1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PW7IN4IAunOikQ_wqap9gA.jpeg"/></div></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk translated">Lynda Hinton 在<a class="ae ja" href="https://unsplash.com/s/photos/hook?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><div class=""/><p id="e69c" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">作为一个将大部分时间花在Android平台上的开发人员，切换到React-Native让我开始欣赏“React的方式”。在Android-Land中，即使构建一个简单的列表也需要创建许多类(ListAdapter、CustomView、CustomViewModel、data object……)。在React中，声明一个返回FlatList的函数很简单，它通过props接受数据集。</p><figure class="ky kz la lb gt ip"><div class="bz fp l di"><div class="lc ld l"/></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk translated">(几乎)所有需要在React上显示的列表。</figcaption></figure><p id="e657" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">通过一个简单的函数呈现每个项目的想法让我印象深刻，因为它很简单。我是说，那不是很美吗？</p><p id="666c" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然而，尽管我很喜欢这种反应方式，但有些事情总是让我不太舒服。每当我不得不复制一个场景，在这个场景中，我必须保持本地状态，对生命周期事件做出反应，或者只是运行一些副作用，我都发现自己在挠头。</p><p id="e2c7" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我知道，我知道，我们有阶级成分！Redux！全能的传奇！但是你看，我们回到我们留在绿色机器人领域的所有样板文件…</p><p id="cfb0" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">幸运的是，从版本<code class="fe le lf lg lh b">16.8</code>开始，React团队已经引入了一项出色的功能——钩子！</p><h1 id="629c" class="li lj jd bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">开大音量。</h1><p id="728d" class="pw-post-body-paragraph ka kb jd kc b kd mg kf kg kh mh kj kk kl mi kn ko kp mj kr ks kt mk kv kw kx ig bi translated">让我们考虑一个简单的场景，我们想要播放一些声音来响应用户事件。在过去，我们会写一个甜蜜的小故事(或者Thunk，如果你对这类事情感兴趣的话……)来收听我们的活动，并给我们宝贵的音频服务打电话。让我们想想所有移动的部分。</p><p id="0fe5" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们需要:</p><ul class=""><li id="fb1a" class="ml mm jd kc b kd ke kh ki kl mn kp mo kt mp kx mq mr ms mt bi translated">为我们的<code class="fe le lf lg lh b">action</code>创建一个<a class="ae ja" href="https://redux-toolkit.js.org/api/createSlice" rel="noopener ugc nofollow" target="_blank">切片</a>。</li><li id="7c9b" class="ml mm jd kc b kd mu kh mv kl mw kp mx kt my kx mq mr ms mt bi translated">从我们的组件中调度<code class="fe le lf lg lh b">action</code>。</li><li id="8bf9" class="ml mm jd kc b kd mu kh mv kl mw kp mx kt my kx mq mr ms mt bi translated">用一个<a class="ae ja" href="https://github.com/reduxjs/redux-thunk" rel="noopener ugc nofollow" target="_blank"> Thunk </a>来增加动作/写一个<a class="ae ja" href="https://github.com/redux-saga/redux-saga" rel="noopener ugc nofollow" target="_blank"> Saga </a>来监听事件</li><li id="b80c" class="ml mm jd kc b kd mu kh mv kl mw kp mx kt my kx mq mr ms mt bi translated">从<code class="fe le lf lg lh b">saga</code>中调用我们的<code class="fe le lf lg lh b">play</code>函数。</li></ul><p id="1491" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">虽然这看起来很简单，但是这种方法存在一些问题。</p><p id="f788" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">首先，因为有许多移动的部件，所以有很大的出错空间。然后，很难概括这样的设置。如果我们必须对另一个事件做出反应，我们需要重新编写这些内容。最后但并非最不重要的是，音频回放可能会占用大量内存，因此我们必须竭尽全力防止内存泄漏，并拥有快速的加载时间。</p><p id="bf54" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">虽然这是对Android方式的改进，但我们仍然有相当多的样板文件要处理。</p><h1 id="acb3" class="li lj jd bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">胡克前来救援。</h1><p id="36f8" class="pw-post-body-paragraph ka kb jd kc b kd mg kf kg kh mh kj kk kl mi kn ko kp mj kr ks kt mk kv kw kx ig bi translated">让我们看看如何只用香草反应和钩子来处理这个问题。没有重复，没有传奇，没有样板。下面是我们希望从我们钟爱的组件中实现的功能:</p><ul class=""><li id="0204" class="ml mm jd kc b kd ke kh ki kl mn kp mo kt mp kx mq mr ms mt bi translated">我们想要预加载音频文件。</li><li id="c771" class="ml mm jd kc b kd mu kh mv kl mw kp mx kt my kx mq mr ms mt bi translated">我们想在屏幕外释放内存。</li><li id="8240" class="ml mm jd kc b kd mu kh mv kl mw kp mx kt my kx mq mr ms mt bi translated">我们希望在给定的时间播放我们的声音(比如，当用户按下按钮时)。</li></ul><p id="5046" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">很好，我们开始吧。</p><h2 id="c4b5" class="mz lj jd bd lk na nb dn lo nc nd dp ls kl ne nf lw kp ng nh ma kt ni nj me nk bi translated">我们的组件。</h2><p id="8db1" class="pw-post-body-paragraph ka kb jd kc b kd mg kf kg kh mh kj kk kl mi kn ko kp mj kr ks kt mk kv kw kx ig bi translated">我们从简单开始。只是一个按钮:</p><figure class="ky kz la lb gt ip"><div class="bz fp l di"><div class="lc ld l"/></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk translated">一个隐藏着音乐天赋的按钮。</figcaption></figure><p id="87c0" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们现在想在<code class="fe le lf lg lh b">mount</code>上加载我们的音频文件，并在<code class="fe le lf lg lh b">onMount</code>上释放内存。假设我们已经有了一个<code class="fe le lf lg lh b">loadPlayer</code>函数，它将一个<code class="fe le lf lg lh b">file</code>加载到内存中并返回一个<code class="fe le lf lg lh b">player</code>接口。我们将使用<code class="fe le lf lg lh b">useRef</code>来保存我们的<code class="fe le lf lg lh b">player</code>实例，使用<code class="fe le lf lg lh b">useEffect</code>来对生命周期事件做出反应。</p><figure class="ky kz la lb gt ip"><div class="bz fp l di"><div class="lc ld l"/></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk translated">有音乐天赋的巴顿。</figcaption></figure><p id="5e15" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">简单吧？现在我们只需要连接<code class="fe le lf lg lh b">onPress</code>来播放我们的声音，我们就好了！让我们开始吧。</p><figure class="ky kz la lb gt ip"><div class="bz fp l di"><div class="lc ld l"/></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk translated">这是作为音乐家成名的巴顿。</figcaption></figure><p id="61c1" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在20行中，我们有一个通话按钮！这是基于Redux方法的一大进步。然而，如果我们想进行对话，我们需要重新编写大部分代码。如果能再利用一部分不是很好吗？</p><h1 id="cebf" class="li lj jd bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">拉皮条钩。</h1><blockquote class="nl nm nn"><p id="6878" class="ka kb no kc b kd ke kf kg kh ki kj kk np km kn ko nq kq kr ks nr ku kv kw kx ig bi translated">有时，我们希望在组件之间重用一些有状态逻辑。传统上，这个问题有两种流行的解决方案:<a class="ae ja" href="https://reactjs.org/docs/higher-order-components.html" rel="noopener ugc nofollow" target="_blank">高阶组件</a>和<a class="ae ja" href="https://reactjs.org/docs/render-props.html" rel="noopener ugc nofollow" target="_blank">渲染道具</a>。定制挂钩允许您这样做，但是不需要向树中添加更多的组件。</p></blockquote><p id="8d55" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这就是事情变得有趣的地方。React文档鼓励我们使用定制钩子来全面重用代码。让我们看看如何提取这个功能，并在其他组件中重用它。</p><p id="2c0e" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">按照文档的建议，我们可以将两个钩子移动到一个自定义钩子中，并将<code class="fe le lf lg lh b">ref</code>暴露给我们的主机组件。</p><figure class="ky kz la lb gt ip"><div class="bz fp l di"><div class="lc ld l"/></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk translated">钩在瓶子里…</figcaption></figure><p id="f321" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">不错！我们的钩子现在在内存中加载一个任意的音频文件，将其播放器绑定到生命周期，并允许我们随意播放这样的文件。让我们看看如何在组件内部使用它。</p><figure class="ky kz la lb gt ip"><div class="bz fp l di"><div class="lc ld l"/></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk translated">金属按钮。强大，但有点粗糙。</figcaption></figure><p id="8510" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果你想更进一步，我想让API表面尽可能薄，所以我建议不要从钩子中暴露出<code class="fe le lf lg lh b">ref</code>,而是返回一个函数数组供我们的组件使用。像这样:</p><figure class="ky kz la lb gt ip"><div class="bz fp l di"><div class="lc ld l"/></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk translated">我们组件的舞台装备。</figcaption></figure><p id="b809" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">下面是如何在我们的组件内部使用它。</p><figure class="ky kz la lb gt ip"><div class="bz fp l di"><div class="lc ld l"/></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk translated">一个低保真极简按钮。</figcaption></figure><p id="97d5" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们现在已经实现了我们的目标。我们有一个简单、可重用和高效的钩子来播放来自任何React组件的音频。</p><h1 id="bdbe" class="li lj jd bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">结尾部分</h1><p id="8cf2" class="pw-post-body-paragraph ka kb jd kc b kd mg kf kg kh mh kj kk kl mi kn ko kp mj kr ks kt mk kv kw kx ig bi translated">我们已经看到钩子有多么强大，以及React生态系统目前已经达到的成熟程度。我认为，无论是在成熟度还是开发者经验方面，它现在都有能力与本土生态系统竞争。</p></div><div class="ab cl ns nt hr nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ig ih ii ij ik"><p id="923c" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是我穿越React Hooks之旅的第一部分。你可以在这里找到<a class="ae ja" href="https://medium.com/@accounts_32070/on-the-power-of-hooks-part-2-8de86630648c" rel="noopener">第二部分</a>，在那里找到<a class="ae ja" href="https://medium.com/@accounts_32070/on-the-power-of-hooks-part-3-78d79cc2a110" rel="noopener">第三部分</a>。</p></div></div>    
</body>
</html>