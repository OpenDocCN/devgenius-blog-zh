<html>
<head>
<title>Programmatic schema management</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编程模式管理</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/programmatic-schema-management-1b5efd180e68?source=collection_archive---------6-----------------------#2022-11-10">https://blog.devgenius.io/programmatic-schema-management-1b5efd180e68?source=collection_archive---------6-----------------------#2022-11-10</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="f869" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">文章首发@ own your data . ai。</p><p id="1821" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在<a class="ae ki" href="https://ownyourdata.ai/wp/traditional-vs-modern-analytics-data-processing-part-1/" rel="noopener ugc nofollow" target="_blank">上一篇关于传统与现代数据处理的文章</a>中，我讨论了依赖自动模式发现时可能遇到的问题。我仍然认为这对于实验来说是一个非凡的特性，但是对于生产(面向用户)应用程序来说，我相信模式应该得到管理，数据契约应该到位。</p><h1 id="cbfa" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">作为代码的模式管理</h1><p id="590a" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">在 Python 应用程序开发中，web 框架在数据库模型和数据库迁移的帮助下提供模式管理特性。开发人员不需要编写 SQL 来定义他们的数据库对象，他们不需要连接到生产环境来部署他们的更改(当然，部署时可能出现的问题除外)。通过这一过程，应用团队实现了:</p><ul class=""><li id="0edf" class="lm ln in jm b jn jo jr js jv lo jz lp kd lq kh lr ls lt lu bi translated">作为代码的模式管理</li><li id="7d60" class="lm ln in jm b jn lv jr lw jv lx jz ly kd lz kh lr ls lt lu bi translated">作为 CI/CD 一部分的模式管理</li></ul><p id="e194" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果不是代码，什么是表模式？我认为模式是基础设施，而不是数据资产。两者的主要区别在于，基础设施由部署管道管理，而数据资产由执行管道管理。</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div class="gh gi ma"><img src="../Images/86785b10d6a7b1844928620dd36323a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*A0NpkntPGPGat5ZyWzUphQ.jpeg"/></div></figure><p id="82d6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在现代数据平台设置中，我们经常会看到数据的完全刷新包括:</p><ul class=""><li id="514b" class="lm ln in jm b jn jo jr js jv lo jz lp kd lq kh lr ls lt lu bi translated">重新定义模式</li><li id="c1c3" class="lm ln in jm b jn lv jr lw jv lx jz ly kd lz kh lr ls lt lu bi translated">重新加载数据</li></ul><p id="53a1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">通过在运行时重新定义模式，将会丢失模式的所有重要历史元数据。时间旅行特征变得不可用，因为对象创建的元数据被覆盖。因此，我认为模式(面向用户的应用程序)应该在部署时而不是运行时进行管理。</p><p id="3697" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">那么如何管理这个模式呢？</p><h1 id="e77c" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">DDL 脚本</h1><p id="5d0f" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">在任何数据平台中，模式都是通过数据定义语言来管理的，数据定义语言包含“创建”、“替换”、“更改”、“删除”等命令。标准流程是这样的，数据工程师用 DDL 创建一个 SQL 脚本，并打包它以便部署。在部署时，脚本通常是手动执行的，并且涉及到大量的复制/粘贴工作(或者使用内部工具来避免这种手动操作)。一个这样的 DDL 脚本是:</p><pre class="mb mc md me gt mi mj mk ml aw mm bi"><span id="e9a9" class="mn kk in mj b gy mo mp l mq mr">create table raw_orders_managed(<br/>    id integer primary key,<br/>    order_timestamp timestamp not null,<br/>    customer_id integer not null,<br/>    order_status varchar(10) not null,<br/>    order_amount decimal(10,2) not null,<br/>    order_currency varchar(3) not null,<br/>    products jsonb,<br/>    inserted_datetime timestamp not null default current_timestamp <br/>);</span></pre><h1 id="4c7d" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">作为代码的模式—地形</h1><p id="22b3" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">如果你已经在云上工作，你可以使用 terraform 来管理你的基础设施组件作为代码。对于任何云提供商，您都可以轻松找到定义表格所需的模块，请查看附录中的链接。</p><h1 id="2324" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">模式作为代码— Python</h1><p id="3fe9" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">如果您作为软件工程师和数据工程师使用 Python，那么您一定已经使用过 SQLAlchemy。它是一个对象关系映射器，提供了连接数据库、执行 SQL (DDL 和 DML)等实用工具，并且在默认情况下，提供了连接大多数事务数据库的连接器。作为这样一个常用的工具，分析数据库也在实现它们的连接器(查看附录章节的方言页面)。</p><p id="5626" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在上一篇文章中，我已经用它删除并重新创建了托管 Postgres 表:</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi ms"><img src="../Images/77240003683339b60a5ec7c56299228b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*HQtrBwb6AJ60dKCE.png"/></div></div></figure><p id="53f7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">通过使用 sqlalchemy 连接器，我们可以开始用底层数据库的方言定义表:我们可以定义键、约束和默认值。更重要的是，通过我们自己管理模式，我们可以轻松地确保我们的流程是<a class="ae ki" href="https://ownyourdata.ai/wp/a-way-to-ensure-auditability-in-data-processing/" rel="noopener ugc nofollow" target="_blank">可审计的</a>，这是我们无法通过自动模式发现实现的(在数据库世界中，通过 Spark 我们可以利用元数据信息！).</p><h1 id="b4ea" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">alembic 简介</h1><p id="9bbc" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">Alembic 是一个数据库迁移工具，使用它您可以:</p><ol class=""><li id="2987" class="lm ln in jm b jn jo jr js jv lo jz lp kd lq kh mx ls lt lu bi translated">执行您自己的 DDL/DML</li><li id="fda6" class="lm ln in jm b jn lv jr lw jv lx jz ly kd lz kh mx ls lt lu bi translated">为您自动生成 CREATE 和 ALTER 语句</li><li id="9e12" class="lm ln in jm b jn lv jr lw jv lx jz ly kd lz kh mx ls lt lu bi translated">作为部署管道的一部分执行迁移</li></ol><h2 id="fc0f" class="mn kk in bd kl my mz dn kp na nb dp kt jv nc nd kx jz ne nf lb kd ng nh lf ni bi translated">设置</h2><p id="3c5a" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">用<code class="fe nj nk nl mj b">pip install alembic</code>或<code class="fe nj nk nl mj b">poetry add alembic</code>安装 alembic。运行<code class="fe nj nk nl mj b">alembic init database_management</code>，这将创建:</p><ul class=""><li id="0017" class="lm ln in jm b jn jo jr js jv lo jz lp kd lq kh lr ls lt lu bi translated">将保存迁移文件的名为<code class="fe nj nk nl mj b">database_management</code>的目录</li><li id="5faf" class="lm ln in jm b jn lv jr lw jv lx jz ly kd lz kh lr ls lt lu bi translated">需要配置连接字符串的文件<code class="fe nj nk nl mj b">alembic.ini</code>:</li></ul><pre class="mb mc md me gt mi mj mk ml aw mm bi"><span id="5750" class="mn kk in mj b gy mo mp l mq mr">sqlalchemy.url = postgresql://postgres:postgres@postgres_db:5432/postgres</span></pre><p id="b314" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">首先，我在一个. py 文件中创建一个 SQLAlchemy 模型:</p><pre class="mb mc md me gt mi mj mk ml aw mm bi"><span id="2448" class="mn kk in mj b gy mo mp l mq mr">from sqlalchemy.ext.declarative import declarative_base</span><span id="85c3" class="mn kk in mj b gy nm mp l mq mr">from sqlalchemy import Column<br/>from sqlalchemy import DateTime<br/>from sqlalchemy import Integer<br/>from sqlalchemy import String<br/>from sqlalchemy.sql import func</span><span id="623c" class="mn kk in mj b gy nm mp l mq mr">Base = declarative_base()<br/></span><span id="9fe8" class="mn kk in mj b gy nm mp l mq mr">class RawCustomer(Base):<br/>    __tablename__ = "raw_customer"</span><span id="6333" class="mn kk in mj b gy nm mp l mq mr">    id = Column(Integer, primary_key=True, index=True)<br/>    email_address = Column(String(320), unique=True)<br/>    first_name = Column(String(100))<br/>    last_name = Column(String(100))<br/>    inserted_datetime = Column(DateTime, server_default=func.now())</span><span id="434e" class="mn kk in mj b gy nm mp l mq mr">    class Config:<br/>        orm_mode = True</span></pre><p id="eed2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我通过运行<code class="fe nj nk nl mj b">alembic revision --autogenerate -m "Create Raw Customer table"</code>生成迁移脚本，这将在<code class="fe nj nk nl mj b">data_management/versions</code>下生成一个迁移文件:</p><pre class="mb mc md me gt mi mj mk ml aw mm bi"><span id="9fe4" class="mn kk in mj b gy mo mp l mq mr">"""Create Raw Customer table</span><span id="6da4" class="mn kk in mj b gy nm mp l mq mr">Revision ID: 8d79a6002e55<br/>Revises: <br/>Create Date: 2022-11-10 07:47:35.492949</span><span id="8522" class="mn kk in mj b gy nm mp l mq mr">"""<br/>from alembic import op<br/>import sqlalchemy as sa<br/></span><span id="58fc" class="mn kk in mj b gy nm mp l mq mr"># revision identifiers, used by Alembic.<br/>revision = '8d79a6002e55'<br/>down_revision = None<br/>branch_labels = None<br/>depends_on = None<br/></span><span id="817d" class="mn kk in mj b gy nm mp l mq mr">def upgrade() -&gt; None:<br/>    # ### commands auto generated by Alembic - please adjust! ###<br/>    op.create_table('raw_customer',<br/>    sa.Column('id', sa.Integer(), nullable=False),<br/>    sa.Column('email_address', sa.String(length=320), nullable=True),<br/>    sa.Column('first_name', sa.String(length=100), nullable=True),<br/>    sa.Column('last_name', sa.String(length=100), nullable=True),<br/>    sa.Column('inserted_datetime', sa.DateTime(), server_default=sa.text('now()'), nullable=True),<br/>    sa.PrimaryKeyConstraint('id'),<br/>    sa.UniqueConstraint('email_address')<br/>    )<br/>    op.create_index(op.f('ix_raw_customer_id'), 'raw_customer', ['id'], unique=False)<br/>    # ### end Alembic commands ###<br/></span><span id="ed4e" class="mn kk in mj b gy nm mp l mq mr">def downgrade() -&gt; None:<br/>    # ### commands auto generated by Alembic - please adjust! ###<br/>    op.drop_index(op.f('ix_raw_customer_id'), table_name='raw_customer')<br/>    op.drop_table('raw_customer')<br/>    # ### end Alembic commands ###</span></pre><p id="b3d0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了应用它，只需运行<code class="fe nj nk nl mj b">alembic upgrade head</code>，现在就在数据库上创建了表:</p><pre class="mb mc md me gt mi mj mk ml aw mm bi"><span id="30da" class="mn kk in mj b gy mo mp l mq mr">postgres=# \d raw_customer<br/>                                            Table "public.raw_customer"<br/>      Column       |            Type             | Collation | Nullable |                 Default                  <br/>-------------------+-----------------------------+-----------+----------+------------------------------------------<br/> id                | integer                     |           | not null | nextval('raw_customer_id_seq'::regclass)<br/> email_address     | character varying(320)      |           |          | <br/> first_name        | character varying(100)      |           |          | <br/> last_name         | character varying(100)      |           |          | <br/> inserted_datetime | timestamp without time zone |           |          | now()<br/>Indexes:<br/>    "raw_customer_pkey" PRIMARY KEY, btree (id)<br/>    "ix_raw_customer_id" btree (id)<br/>    "raw_customer_email_address_key" UNIQUE CONSTRAINT, btree (email_address)</span></pre><p id="e7b3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了撤销迁移，只需运行<code class="fe nj nk nl mj b">alembic downgrade base</code>，它将执行迁移文件中的所有降级功能。现在该表已不存在:</p><pre class="mb mc md me gt mi mj mk ml aw mm bi"><span id="2377" class="mn kk in mj b gy mo mp l mq mr">postgres=# \d raw_customer<br/>Did not find any relation named "raw_customer".</span></pre><p id="acef" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用上面的方法，所有的模式都作为代码生成，并且它们成为您的 CI/CD 管道的一部分，受益于代码审查和单元测试。</p><h1 id="2503" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">结论</h1><p id="6d0a" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">虽然模式可以从数据中导出，但它是一个基础设施组件，需要像这样管理:通过 DDL 脚本、terraform 或代码。通过这样做，您可以从 CI/CD 的积极方面以及底层存储系统提供的功能中获益。</p><h1 id="85cd" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">附录</h1><ol class=""><li id="ed5b" class="lm ln in jm b jn lh jr li jv nn jz no kd np kh mx ls lt lu bi translated"><a class="ae ki" href="https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/glue_catalog_table" rel="noopener ugc nofollow" target="_blank"> Terraform AWS 胶水</a></li><li id="97ba" class="lm ln in jm b jn lv jr lw jv lx jz ly kd lz kh mx ls lt lu bi translated"><a class="ae ki" href="https://registry.terraform.io/providers/hashicorp/azurerm/latest/docs/resources/data_factory_dataset_parquet" rel="noopener ugc nofollow" target="_blank"> Terraform Azure 数据工厂拼花地板</a></li><li id="c576" class="lm ln in jm b jn lv jr lw jv lx jz ly kd lz kh mx ls lt lu bi translated"><a class="ae ki" href="https://registry.terraform.io/providers/hashicorp/google/latest/docs/resources/bigquery_table" rel="noopener ugc nofollow" target="_blank"> Terraform Google BigQuery </a></li><li id="7816" class="lm ln in jm b jn lv jr lw jv lx jz ly kd lz kh mx ls lt lu bi translated"><a class="ae ki" href="https://www.sqlalchemy.org/" rel="noopener ugc nofollow" target="_blank"> SQLAlchemy </a></li><li id="b718" class="lm ln in jm b jn lv jr lw jv lx jz ly kd lz kh mx ls lt lu bi translated"><a class="ae ki" href="https://docs.sqlalchemy.org/en/14/dialects/" rel="noopener ugc nofollow" target="_blank"> SQLAlchemy 方言</a></li><li id="cc3a" class="lm ln in jm b jn lv jr lw jv lx jz ly kd lz kh mx ls lt lu bi translated"><a class="ae ki" href="https://alembic.sqlalchemy.org/en/latest/" rel="noopener ugc nofollow" target="_blank"> Alembic </a></li></ol></div></div>    
</body>
</html>