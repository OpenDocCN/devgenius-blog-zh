<html>
<head>
<title>GraphQL with spring-boot-starter-graphql</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带弹簧启动启动器的图表</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/graphql-with-spring-boot-starter-graphql-7b406998c0b5?source=collection_archive---------0-----------------------#2022-05-30">https://blog.devgenius.io/graphql-with-spring-boot-starter-graphql-7b406998c0b5?source=collection_archive---------0-----------------------#2022-05-30</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="12b9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">终于，经过 10 个月的等待，GraphQL 集成了最新发布的<a class="ae ki" href="https://spring.io/blog/2022/05/19/spring-boot-2-7-0-available-now" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> spring boot 2.7.0 </strong> </a>。在这个版本中，<strong class="jm io">spring-boot-starter-graph QL</strong>取代了当前的<strong class="jm io"> GraphQL java spring </strong>。有关此版本的更多详情，请查看此处的<a class="ae ki" href="https://spring.io/blog/2022/05/19/spring-for-graphql-1-0-release" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="0fa4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在本文中，我们将看到如何开始使用这个新的 graphql starter 或者简单地迁移您现有的项目。这里，我使用的是我之前用 graphql java spring 构建的<a class="ae ki" href="https://medium.com/@dhakresumitra5/graphql-with-spring-boot-java-d2fa3ca1b12c" rel="noopener">项目</a>。</p><h1 id="62c3" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">要求</h1><p id="20ee" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">您需要的设置:</p><ul class=""><li id="a5f7" class="lm ln in jm b jn jo jr js jv lo jz lp kd lq kh lr ls lt lu bi translated">对 spring boot 和 GraphQL 有基本的了解</li><li id="bced" class="lm ln in jm b jn lv jr lw jv lx jz ly kd lz kh lr ls lt lu bi translated">现有的 graphql java 项目或克隆一个<a class="ae ki" href="https://github.com/dhakre/APIBook/tree/graphqlTypes" rel="noopener ugc nofollow" target="_blank">在这里</a></li><li id="7932" class="lm ln in jm b jn lv jr lw jv lx jz ly kd lz kh lr ls lt lu bi translated">安装在您机器上的 Docker</li><li id="f3d2" class="lm ln in jm b jn lv jr lw jv lx jz ly kd lz kh lr ls lt lu bi translated">您选择的 Intellij 或 IDE</li><li id="0db0" class="lm ln in jm b jn lv jr lw jv lx jz ly kd lz kh lr ls lt lu bi translated">测试 API 的邮递员</li></ul><h1 id="90aa" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">项目迁移</h1><p id="a7a5" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">与以前不同，使用<strong class="jm io"><em class="ma">spring boot 2 . 7 . 0</em></strong>我们只需要一个依赖项就可以将 GraphQL 集成到我们的项目中。所以我从升级 spring boot 版本开始</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="0728" class="mk kk in mg b gy ml mm l mn mo">&lt;parent&gt;<br/>    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br/>    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;<br/>    &lt;version&gt;2.7.0&lt;/version&gt;<br/>    &lt;relativePath/&gt;</span></pre><p id="c20c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后我<strong class="jm io">移除了</strong>之前的 graphql 依赖项<strong class="jm io"> graphql-java-tools </strong>和<strong class="jm io">graph QL-spring-boot-starter。</strong></p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="518c" class="mk kk in mg b gy ml mm l mn mo">&lt;dependency&gt;<br/>    &lt;groupId&gt;com.graphql-java-kickstart&lt;/groupId&gt;<br/>    &lt;artifactId&gt;graphql-java-tools&lt;/artifactId&gt;<br/>    &lt;version&gt;12.0.0&lt;/version&gt;<br/>&lt;/dependency&gt;<br/>&lt;dependency&gt;<br/>    &lt;groupId&gt;com.graphql-java-kickstart&lt;/groupId&gt;<br/>    &lt;artifactId&gt;graphql-spring-boot-starter&lt;/artifactId&gt;<br/>    &lt;version&gt;12.0.0&lt;/version&gt;<br/>&lt;/dependency&gt;</span></pre><p id="e792" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">并且<strong class="jm io">增加了新的弹簧靴 graphql 启动器</strong></p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="249a" class="mk kk in mg b gy ml mm l mn mo">&lt;dependency&gt;<br/>    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br/>    &lt;artifactId&gt;spring-boot-starter-graphql&lt;/artifactId&gt;<br/>&lt;/dependency&gt;</span></pre><p id="874b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">之后，删除所有已实现的解析器，并通过删除 graphql java spring 的所有导入来清理项目。</p><figure class="mb mc md me gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi mp"><img src="../Images/211156e4c0fe5038a5b2c7198597b8d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kSn40Z1k_l-lw-vHZvLMxw.png"/></div></div></figure><p id="078b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在我们的项目是干净的，并且更新了新的依赖项。根据<a class="ae ki" href="https://docs.spring.io/spring-graphql/docs/current-SNAPSHOT/reference/html/#overview" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> spring graphql 文档</strong> </a>，最大的变化来自于<em class="ma">新的带注释的控制器</em>。模式文件的<a class="ae ki" href="https://docs.spring.io/spring-boot/docs/2.7.0-SNAPSHOT/reference/html/web.html#web.graphql.schema" rel="noopener ugc nofollow" target="_blank">默认位置是<strong class="jm io"><em class="ma">src/main/resources/graph QL/* *</em></strong>。这里就是这种情况，所以我们不需要接触 graphql 模式文件。所有文件都将被 spring graphql starter 自动拾取。</a></p><figure class="mb mc md me gt mq gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/4acd092cbdfad929a43139116759703d.png" data-original-src="https://miro.medium.com/v2/resize:fit:552/format:webp/1*xGFVwa1NnMuuiw3md4Rgtg.png"/></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">架构文件位置</figcaption></figure><p id="00b2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您还可以在<em class="ma">应用程序中自定义模式文件的位置。但是这里我们将使用默认值。</em></p><figure class="mb mc md me gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi nc"><img src="../Images/01ea199a584a0d23a9b87f364e26e320.png" data-original-src="https://miro.medium.com/v2/resize:fit:814/format:webp/1*O4Azxnt8q-8-B6YGmX7PMA.png"/></div></div></figure><h1 id="a3d1" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">GraphQL 注释</h1><p id="0ef9" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">使用 Graphql spring java，需要解析器组件来实现<em class="ma"> GraphQLQueryResolver </em>或<em class="ma">graphqlmationresolver</em>类。但是随着<strong class="jm io"><em class="ma">spring boot start</em>r g<em class="ma">raph QL</em></strong>，它被移到了一个<a class="ae ki" href="https://docs.spring.io/spring-graphql/docs/current-SNAPSHOT/reference/html/#controllers" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> <em class="ma">基于注释的编程</em> </strong> </a>模型。简而言之，以前的解析器被注释所取代:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="a13d" class="mk kk in mg b gy ml mm l mn mo"><strong class="mg io">GraphQLMutationResolver -&gt; @MutationMapping</strong></span><span id="4bc3" class="mk kk in mg b gy nd mm l mn mo"><strong class="mg io">GraphQLQueryResolver -&gt; @QueryMapping</strong></span></pre><p id="f0cf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">并且<strong class="jm io"><em class="ma">@控制器</em> </strong> <em class="ma">组件</em>使用<em class="ma">带注释的处理程序方法</em>来绑定和解析 graphql 模式字段/查询。</p><h2 id="c8af" class="mk kk in bd kl ne nf dn kp ng nh dp kt jv ni nj kx jz nk nl lb kd nm nn lf no bi translated">查询映射</h2><p id="4ade" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">顾名思义，这个注释将<strong class="jm io">处理程序方法</strong>映射到 graphql 模式中的<strong class="jm io">查询类型。</strong></p><figure class="mb mc md me gt mq gh gi paragraph-image"><div class="gh gi np"><img src="../Images/7240f4957dacc376c31c3590d10028b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1006/format:webp/1*xb69_zHVLcoqrD36VgtZEg.png"/></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">查询模式</figcaption></figure><figure class="mb mc md me gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi nq"><img src="../Images/84845576cac137b94e03ea300dc6c65d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AStc_kFGbOjBKzYW41kU9g.png"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">带有注释查询方法的 BookQuery 类</figcaption></figure><p id="5acd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在让我们通过用<strong class="jm io"><em class="ma">@ query mapping</em></strong><em class="ma">对查询方法进行注释来配置我们的查询方法。</em>对于<em class="ma">映射查询参数</em>我们可以使用注释<a class="ae ki" href="https://docs.spring.io/spring-graphql/docs/1.0.0/reference/html/#controllers-schema-mapping-argument" rel="noopener ugc nofollow" target="_blank"><strong class="jm io">@参数</strong> </a>。为了更加灵活，您还可以为参数定义别名，例如</p><figure class="mb mc md me gt mq gh gi paragraph-image"><div class="gh gi np"><img src="../Images/30e7b9ef653b6a3327c8ca93bb96e40f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1006/format:webp/1*LzCFaNIJYCrrCRxU8JWr9w.png"/></div></figure><p id="9854" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">查询<strong class="jm io"><em class="ma">getBookByName</em></strong>在<strong class="jm io">模式</strong>和<strong class="jm io">处理程序方法</strong>中有一个参数<strong class="jm io"> <em class="ma"> filter </em> </strong>，它是<strong class="jm io"> bookFilter </strong>。所以我们需要用<strong class="jm io"><em class="ma">@实参(" filter") </em> </strong>定义一个别名。如果您忘记这样做，您的项目将会成功部署，但是查询将会以 NPE 结束。我浪费了一些时间，后来发现它只是缺少正确匹配的参数名。</p><h1 id="348e" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">模式映射</h1><p id="dc49" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">该注释将处理程序映射并绑定到 GraphQL 模式中的字段，它可以在<strong class="jm io">方法</strong>或<strong class="jm io">类级别</strong>使用。它接受两个参数<strong class="jm io">类型名= </strong>和<strong class="jm io">字段= </strong>。它也是其他特定于查询的注释的父注释。</p><figure class="mb mc md me gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi nr"><img src="../Images/351930ee67cb18743826d881ef96aede.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kfTigEsXEJx_R4RcctDtag.png"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">模式映射元注释</figcaption></figure><p id="0c08" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们将需要这个注释来解析图书类型的<strong class="jm io">作者</strong> <strong class="jm io">字段类型</strong>。</p><figure class="mb mc md me gt mq gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/8711706c9dfd5cc7e433ce1e95bc1b11.png" data-original-src="https://miro.medium.com/v2/resize:fit:788/format:webp/1*e__s9pLa-aztdAKieH1sPg.png"/></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">模式中的图书类型</figcaption></figure><figure class="mb mc md me gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi nt"><img src="../Images/e0227cfbf6bd3a3cc74e44c41ff41013.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZkUlV72DeAqcC4m6fMxWOw.png"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">具有模式映射注释的作者解析器方法</figcaption></figure><p id="4ab9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里我们用参数定义了<em class="ma"> @SchemaMapping </em>注释</p><ul class=""><li id="84f9" class="lm ln in jm b jn jo jr js jv lo jz lp kd lq kh lr ls lt lu bi translated"><strong class="jm io"> typeName= Book </strong>，即作者字段所属的类型</li><li id="5707" class="lm ln in jm b jn lv jr lw jv lx jz ly kd lz kh lr ls lt lu bi translated"><strong class="jm io"> field= author </strong>，指定指定的<em class="ma"> typeName </em>的哪个字段将被这个 handler 方法解析。</li></ul><p id="736b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">之后，我定义了字段上的<strong class="jm io">参数，用<em class="ma">@参数</em>注释排序</strong>。由于在模式和处理程序方法中有相同的名字<strong class="jm io"> order </strong>，spring 将自动映射它。因为我们在方法级别定义了<strong class="jm io">模式注释，所以先前的<strong class="jm io"> BookAuthorResolver </strong>类是不必要的，所以我移除了它，并将该方法移到了<strong class="jm io"> BookQuery </strong>类。</strong></p><figure class="mb mc md me gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi nu"><img src="../Images/6ac5e55c9676757f321bccafedee4d86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dYfnMEwRqOjn9yHvUzocAQ.png"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">具有查询处理程序和作者解析器方法的 BookQuery 类</figcaption></figure><h1 id="7190" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">突变作图</h1><p id="36b1" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">该注释将处理程序方法与 GraphQL 模式中的变异查询进行映射。</p><figure class="mb mc md me gt mq gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/b084c9af1ab9200ccffb05421c321116.png" data-original-src="https://miro.medium.com/v2/resize:fit:1148/format:webp/1*M1X9Lla6Eb_zQQBJBTRmNw.png"/></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">突变模式</figcaption></figure><figure class="mb mc md me gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi nw"><img src="../Images/3a747666e6df305aa9f5e84de10af7c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Lab0bUJzcKKCu79Q7Eli6g.png"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">具有突变注释的 deleteBook 方法</figcaption></figure><p id="0e81" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">就像我们对 queryMapping 所做的更改一样，将@MutationMapping 添加到突变查询方法中，并用别名用<strong class="jm io"><em class="ma">@ Argument(" input ")</em></strong>批注来批注突变参数。</p><p id="24b1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">由于<strong class="jm io">变异</strong>和<strong class="jm io">查询</strong>映射注释是 SchemaMapping 的<strong class="jm io">元注释，</strong>我们也可以这样替换。</p><figure class="mb mc md me gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi nx"><img src="../Images/2926ff9ceede9c771efafba4313d4d4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kyN7eDtc9xLeAx_Wsqs07w.png"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">用@SchemaMapping 注释定义突变方法</figcaption></figure><h1 id="c49d" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">测试 API</h1><p id="86e3" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">现在所有的更改都完成了，让我们构建并运行项目。</p><blockquote class="ny nz oa"><p id="b063" class="jk jl ma jm b jn jo jp jq jr js jt ju ob jw jx jy oc ka kb kc od ke kf kg kh ig bi translated">mvn 全新安装</p></blockquote><p id="c220" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后用 docker 部署。</p><blockquote class="ny nz oa"><p id="646b" class="jk jl ma jm b jn jo jp jq jr js jt ju ob jw jx jy oc ka kb kc od ke kf kg kh ig bi translated">docker-撰写向上-d</p></blockquote><figure class="mb mc md me gt mq gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/4f5e1d13274ad5f65fe0a47dfb53a41f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1316/format:webp/1*eclqVsNJqlHrErW3FrkUUA.png"/></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">码头集装箱</figcaption></figure><p id="db23" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们先测试一个<strong class="jm io">查询</strong></p><figure class="mb mc md me gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi of"><img src="../Images/625357c3ac7d5e175fa13a65b89f7618.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Pl-EtOS9EEPkx3HBEEiq9A.png"/></div></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">邮递员中的所有图书查询</figcaption></figure><p id="b200" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">正如规范中提到的，新的 spring graphql starter 使用<strong class="jm io">运行时连接</strong>到<strong class="jm io">注册处理程序方法</strong>到 graphql.schema.Datafetcher</p><figure class="mb mc md me gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi mp"><img src="../Images/4f9b9b267577348ec2c973f055bfb2ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*999ERE_p4GajhPwrZU0t8g.png"/></div></div></figure><p id="33c6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您不会看到任何错误，但结果不会是预期的。所以在注释处理程序方法时要小心。</p><figure class="mb mc md me gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi og"><img src="../Images/a1749f7fd63dec469e1a50c822bba45f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-TqDAw-qC86bqz3i8JNe3Q.png"/></div></div></figure><p id="5703" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在我们来测试一个<strong class="jm io">突变</strong>。</p><figure class="mb mc md me gt mq gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/c73adfbc1635bfc39a60cb4d7f234e00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/1*NxnrFpXzAlx-Oiew3X_Oqw.png"/></div><figcaption class="my mz gj gh gi na nb bd b be z dk translated">《邮差》中的新书突变</figcaption></figure><p id="d1fd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">API 按预期工作。我希望这篇简短的文章能帮助你开始使用新的<strong class="jm io"><em class="ma">spring-boot-graph QL-starter</em></strong>并体验它的其他酷功能。你可以在<a class="ae ki" href="https://github.com/dhakre/APIBook/tree/springGraphQL" rel="noopener ugc nofollow" target="_blank"> github 上点击</a>查看这个项目。如果你喜欢这篇文章，一定要看看我的其他与弹簧靴相关的<a class="ae ki" href="https://medium.com/@dhakresumitra5/list/graphql-with-spring-boot-java-6bbc89446107" rel="noopener">文章。</a></p></div></div>    
</body>
</html>