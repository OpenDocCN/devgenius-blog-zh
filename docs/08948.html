<html>
<head>
<title>Golang context, The significance.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Golang 的背景，意义。</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/golang-context-the-significance-1611fc248d25?source=collection_archive---------6-----------------------#2022-07-20">https://blog.devgenius.io/golang-context-the-significance-1611fc248d25?source=collection_archive---------6-----------------------#2022-07-20</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><blockquote class="jk jl jm"><p id="789c" class="jn jo jp jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ig bi translated">“没有上下文的内容就是噪音。”</p></blockquote><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/b16ba8bfe88d70b98931bc81a4302e99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hm7d4D-fbsd2ItraW0zlAw.jpeg"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">演职员表:<a class="ae lc" href="https://unsplash.com/@mightyhummingbird" rel="noopener ugc nofollow" target="_blank">@ mighty hummbird</a></figcaption></figure><p id="e71e" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">在惯用的 go 中使用<code class="fe lg lh li lj b">context</code>是不可避免的，尤其是当你使用 Go 并发时。正如“语境”的定义所述:- <em class="jp">形成事件、陈述或想法的背景的环境，根据这些环境可以完全理解</em>；简单地说，<code class="fe lg lh li lj b">context</code>包可以用来让函数或<a class="ae lc" href="https://go.dev/tour/concurrency/1" rel="noopener ugc nofollow" target="_blank"> goroutines </a>根据系统中的某些事件来动作。</p><p id="0ef1" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">下面这篇文章介绍了为什么上下文包很重要，以及如何在生产系统中使用它来提高性能和功能，并揭开<code class="fe lg lh li lj b">ctx</code>变量的神秘面纱，不要在看到以<code class="fe lg lh li lj b">context.Context</code>作为第一个参数的函数时就使用<code class="fe lg lh li lj b">context.Background()</code>。让我们来了解一下 Golang 中的上下文包。</p><h1 id="f0c3" class="lk ll in bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">说真的，我们为什么需要上下文包？</h1><p id="fa71" class="pw-post-body-paragraph jn jo in jq b jr mi jt ju jv mj jx jy ld mk kb kc le ml kf kg lf mm kj kk kl ig bi translated">每当我们想要在应用程序中传递“上下文”或公共范围数据<em class="jp"> </em>时，我们就使用上下文包。归结起来就是以下几个概念。</p><ul class=""><li id="1e7a" class="mn mo in jq b jr js jv jw ld mp le mq lf mr kl ms mt mu mv bi translated"><strong class="jq io">听取消。<br/> </strong> <em class="jp">场景</em>:上下文取消的一个经典例子是服务的正常关闭。当系统关闭时，它应该取消所有后台进程，并在后台处理正在进行的任务。</li><li id="e676" class="mn mo in jq b jr mw jv mx ld my le mz lf na kl ms mt mu mv bi translated"><strong class="jq io">通知超时和截止时间。</strong> <br/> <em class="jp">场景</em>:我们构建的系统请求一个服务，它有一个有限的超时(比如说 5 秒)，所以如果服务超时，我们需要取消我们的 goroutines，不要浪费计算资源。</li><li id="36b9" class="mn mo in jq b jr mw jv mx ld my le mz lf na kl ms mt mu mv bi translated"><strong class="jq io">传递杂项键值。<br/> </strong> <em class="jp">场景</em>:当您创建一个中间件来解析令牌并转发经过身份验证的用户信息时，您可以使用请求<code class="fe lg lh li lj b">context</code>并为其附加键值。</li></ul><p id="5560" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">上下文接口定义如下，<a class="ae lc" href="https://github.com/golang/go/blob/master/src/context/context.go" rel="noopener ugc nofollow" target="_blank">检查源代码</a>，当您开始一个实现时，您可以选择创建一个基本上下文，并将其传递给<a class="ae lc" href="https://go.dev/tour/concurrency/1" rel="noopener ugc nofollow" target="_blank"> go 例程</a>。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nb nc l"/></div></figure><h1 id="bfcc" class="lk ll in bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">上下文接口</h1><p id="1ebb" class="pw-post-body-paragraph jn jo in jq b jr mi jt ju jv mj jx jy ld mk kb kc le ml kf kg lf mm kj kk kl ig bi translated">你总是使用<code class="fe lg lh li lj b">context.Background()</code>或<code class="fe lg lh li lj b">context.Todo()</code>创建一个基本上下文，当你在官方 go 源代码中检查实现时，你可以看到这些上下文实际上是一个整数<code class="fe lg lh li lj b">emptyCtx</code>实现了<code class="fe lg lh li lj b">context interface</code>。</p><p id="44b3" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">由<code class="fe lg lh li lj b">Background()</code>返回的上下文通常被用作整个上下文调用链的根上下文，作为一个抽象，它实际上什么也不做。</p><p id="8a2d" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">从技术上讲，当你查看<a class="ae lc" href="https://github.com/golang/go/blob/17083a2fdf4475c3f11a3e6a0ef8cb595a5fc4d6/src/context/context.go#L199-L202" rel="noopener ugc nofollow" target="_blank">源</a>时，<code class="fe lg lh li lj b">context.Background()</code>和<code class="fe lg lh li lj b">context.Todo()</code>都是一样的，都是<code class="fe lg lh li lj b">emptyCtx.</code>，那么我们为什么需要<code class="fe lg lh li lj b">context.Todo()</code>？当您不确定如何处理上下文，但需要编写惯用的 go 时，它用于重构和代码分析。</p><blockquote class="jk jl jm"><p id="c933" class="jn jo jp jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ig bi translated">代码应该使用上下文。当不清楚使用哪个上下文或者上下文不可用时(因为周围的函数还没有被扩展以接受上下文参数)，TODO。</p></blockquote><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nb nc l"/></div></figure></div><div class="ab cl nd ne hr nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ig ih ii ij ik"><h1 id="88fe" class="lk ll in bd lm ln nk lp lq lr nl lt lu lv nm lx ly lz nn mb mc md no mf mg mh bi translated"><strong class="ak"> 1。听听取消。</strong></h1><p id="397d" class="pw-post-body-paragraph jn jo in jq b jr mi jt ju jv mj jx jy ld mk kb kc le ml kf kg lf mm kj kk kl ig bi translated">您可以在整个程序中使用<code class="fe lg lh li lj b">context.Context</code>来处理取消。当您在应用程序中传递一个主上下文时，侦听关闭事件并在系统中触发优雅的关闭级联。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="694a" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">在上面的例子中，你可以看到<code class="fe lg lh li lj b">context.WithCancel</code>是通过<code class="fe lg lh li lj b">longBackgroundWorker</code>函数传递的，我们使用一个 ticker 来模拟一个正在运行的进程。</p><p id="8658" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">当<code class="fe lg lh li lj b">Ctrl+C</code>或中断被触发时，程序将<a class="ae lc" href="https://gist.github.com/sivsivsree/d731e58c30379f11a7d70a4ef163d9bd#file-ctx_listen-go-L17" rel="noopener ugc nofollow" target="_blank">通知</a>或<code class="fe lg lh li lj b">exit chan</code>，并将通过将值传递给完成中的通道来取消上下文。</p><blockquote class="jk jl jm"><p id="3e31" class="jn jo jp jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ig bi translated">取消不止一次是可以的，但是第一次之后，就没用了。</p></blockquote><h2 id="286d" class="np ll in bd lm nq nr dn lq ns nt dp lu ld nu nv ly le nw nx mc lf ny nz mg oa bi translated">可以用在哪里？</h2><p id="2356" class="pw-post-body-paragraph jn jo in jq b jr mi jt ju jv mj jx jy ld mk kb kc le ml kf kg lf mm kj kk kl ig bi translated">正常关机场景如上所述，另一个场景是，当程序在分块和流式传输过程中中断时，您正在将一个大文件流式传输到另一个系统，您可以保留一个检查点并通知另一端发生了中断，稍后从您离开的地方继续…您明白了吗？</p></div><div class="ab cl nd ne hr nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ig ih ii ij ik"><h1 id="5111" class="lk ll in bd lm ln nk lp lq lr nl lt lu lv nm lx ly lz nn mb mc md no mf mg mh bi translated">2.通知超时和截止日期。</h1><p id="512e" class="pw-post-body-paragraph jn jo in jq b jr mi jt ju jv mj jx jy ld mk kb kc le ml kf kg lf mm kj kk kl ig bi translated">超时允许程序继续运行，为最终用户提供了更好的体验。超时/截止时间是针对损坏或失败的依赖关系的一种有用的防御措施。</p><p id="fe59" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated"><code class="fe lg lh li lj b">context.Timeout</code>和<code class="fe lg lh li lj b">context.Deadline</code>在概念上类似。设置一个<code class="fe lg lh li lj b">context.Timeout</code>需要持续的时间- <code class="fe lg lh li lj b">time.Duration.</code></p><pre class="kn ko kp kq gt ob lj oc od aw oe bi"><span id="0795" class="np ll in lj b gy of og l oh oi">ctx, cancel := context.WithTimeout(ctx, 3*time.Second)</span></pre><p id="a7c3" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated"><code class="fe lg lh li lj b">context.Deadline</code>是类似的，除了你指定一个截止日期<code class="fe lg lh li lj b">time</code>当你想要上下文取消，而不是一个持续时间。</p><pre class="kn ko kp kq gt ob lj oc od aw oe bi"><span id="695b" class="np ll in lj b gy of og l oh oi">notAfter := time.Date(2023, time.May, 12, 45, 0, 0, 0, time.UTC)<br/>ctx, cancel := context.WithDeadline(ctx, notAfter)</span></pre><p id="ffca" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">以下代码是如何使用超时的示例。它将每隔<a class="ae lc" href="https://gist.github.com/sivsivsree/c53c6db8a57f704cc1d3ce8d967d58bc#file-ctx_timeouts-go-L22" rel="noopener ugc nofollow" target="_blank">一秒</a>调用一次提供的 URL，并在提供的持续时间内等待获得结果，如<a class="ae lc" href="https://gist.github.com/sivsivsree/c53c6db8a57f704cc1d3ce8d967d58bc#file-ctx_timeouts-go-L41" rel="noopener ugc nofollow" target="_blank">第 41 行</a>所示。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nb nc l"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">请求中使用超时的示例</figcaption></figure><h2 id="ead6" class="np ll in bd lm nq nr dn lq ns nt dp lu ld nu nv ly le nw nx mc lf ny nz mg oa bi translated">为什么要使用超时/截止时间</h2><ol class=""><li id="7c3e" class="mn mo in jq b jr mi jv mj ld oj le ok lf ol kl om mt mu mv bi translated"><strong class="jq io">返回一个错误</strong>:当一些事情发生时，比如网络请求、数据库连接，我们不希望我们的程序挂起并无限期等待，而是尝试一段时间并提供一个错误。</li><li id="649a" class="mn mo in jq b jr mw jv mx ld my le mz lf na kl om mt mu mv bi translated"><strong class="jq io">回退值</strong>:同样，如果事情出了问题，并且期望一个比错误值更大的值，我们可以返回一个回退值，比如上次缓存、默认值等等。</li><li id="5515" class="mn mo in jq b jr mw jv mx ld my le mz lf na kl om mt mu mv bi translated"><strong class="jq io">启动重试</strong>:我们可以在指定的超时后再次尝试错误的依赖关系。</li></ol><blockquote class="jk jl jm"><p id="9b60" class="jn jo jp jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ig bi translated">在这么多要担心的事情中，暂停真的是一件好事。</p></blockquote></div><div class="ab cl nd ne hr nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ig ih ii ij ik"><h1 id="0595" class="lk ll in bd lm ln nk lp lq lr nl lt lu lv nm lx ly lz nn mb mc md no mf mg mh bi translated">3.<strong class="ak">传递杂项键值。</strong></h1><p id="4be8" class="pw-post-body-paragraph jn jo in jq b jr mi jt ju jv mj jx jy ld mk kb kc le ml kf kg lf mm kj kk kl ig bi translated">使用上下文的另一个好处是。程序中的上下文是通过上下文传递键值的能力。以下方法可用于通过上下文传递和检索值。</p><pre class="kn ko kp kq gt ob lj oc od aw oe bi"><span id="2e69" class="np ll in lj b gy of og l oh oi">// Add value to context<br/>context.WithValue(ctx context.Context, key string, value interface)<br/></span><span id="6630" class="np ll in lj b gy on og l oh oi">// Get the value from context by key<br/>context.Value(key string) interface {}</span></pre><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nb nc l"/></div></figure><blockquote class="jk jl jm"><p id="5cc3" class="jn jo jp jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl ig bi translated">将所有数据放在一个上下文中并跨函数使用，而不是传入参数，这看起来很诱人，但这可能会导致代码可读性下降、不必要的依赖以及代码库维护方面的挑战。</p></blockquote><p id="a08d" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated"><strong class="jq io">何时通过上下文传递值。</strong></p><p id="1536" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">只有在需要传播时，您才应该绝对地跨程序层通过上下文传递值。</p><p id="6ed9" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">在上面的代码示例中，在中间件函数中使用它来传递<code class="fe lg lh li lj b">auth</code>或相关信息。同样，当你测试程序并在函数间传递<code class="fe lg lh li lj b">traceId</code>或上下文信息(主要是元信息)时。</p></div><div class="ab cl nd ne hr nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ig ih ii ij ik"><h1 id="8e76" class="lk ll in bd lm ln nk lp lq lr nl lt lu lv nm lx ly lz nn mb mc md no mf mg mh bi translated">结论</h1><p id="3632" class="pw-post-body-paragraph jn jo in jq b jr mi jt ju jv mj jx jy ld mk kb kc le ml kf kg lf mm kj kk kl ig bi translated">Golang <code class="fe lg lh li lj b">context</code> package 是设计程序的一个有价值的工具集。使用<code class="fe lg lh li lj b">context.TODO()</code>和<code class="fe lg lh li lj b">context.Background()</code>来创建空的上下文，并通过用<code class="fe lg lh li lj b">WithTimeouts</code>、<code class="fe lg lh li lj b">WithDeadline</code>或<code class="fe lg lh li lj b">WithCancel</code>来控制程序的流程，使其更加强大。</p><p id="e2ae" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">整个上下文包是这样包装的，</p><ul class=""><li id="8c17" class="mn mo in jq b jr js jv jw ld mp le mq lf mr kl ms mt mu mv bi translated">在整个呼叫链中存储和传递信息的能力。</li><li id="4ddb" class="mn mo in jq b jr mw jv mx ld my le mz lf na kl ms mt mu mv bi translated">控制取消的能力，如果任何事情超出或出乎意料。</li></ul><p id="13ec" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">如果您是新手，或者对上下文的工作方式感到困惑，我认为这篇文章比以前更加清晰。</p><p id="5723" class="pw-post-body-paragraph jn jo in jq b jr js jt ju jv jw jx jy ld ka kb kc le ke kf kg lf ki kj kk kl ig bi translated">谢了。</p></div></div>    
</body>
</html>