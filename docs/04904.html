<html>
<head>
<title>Merge k Sorted Lists</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">合并k个排序列表</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/merge-k-sorted-lists-a7462bfd102c?source=collection_archive---------1-----------------------#2021-05-19">https://blog.devgenius.io/merge-k-sorted-lists-a7462bfd102c?source=collection_archive---------1-----------------------#2021-05-19</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="ef82" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如何合并多个排序链表中所有节点的集合？</p><blockquote class="ki kj kk"><p id="a65b" class="jk jl kl jm b jn jo jp jq jr js jt ju km jw jx jy kn ka kb kc ko ke kf kg kh ig bi translated">Leetcode问题23(<a class="ae kp" href="https://leetcode.com/problems/merge-k-sorted-lists/" rel="noopener ugc nofollow" target="_blank">https://leetcode.com/problems/merge-k-sorted-lists/</a></p></blockquote><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi kq"><img src="../Images/58d8f42c853238941791f209a2cf375f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M91sQU9KEV1qqjExEliLUQ.jpeg"/></div></div><figcaption class="lc ld gj gh gi le lf bd b be z dk translated">leet code—<a class="ae kp" href="https://leetcode.com/" rel="noopener ugc nofollow" target="_blank">https://leetcode.com/</a></figcaption></figure><p id="64ae" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">本文是一个新系列的一部分，在这个系列中，我将解决一些Leetcode问题，然后详细解释它们的解决方案。<br/>在所有这些文章中，我将遵循一个由四部分组成的策略—</p><ol class=""><li id="1110" class="lg lh in jm b jn jo jr js jv li jz lj kd lk kh ll lm ln lo bi translated">问题的描述</li><li id="9244" class="lg lh in jm b jn lp jr lq jv lr jz ls kd lt kh ll lm ln lo bi translated">关于如何解决文章的提示</li><li id="7897" class="lg lh in jm b jn lp jr lq jv lr jz ls kd lt kh ll lm ln lo bi translated">详细的实际解决方案</li><li id="d5be" class="lg lh in jm b jn lp jr lq jv lr jz ls kd lt kh ll lm ln lo bi translated">解的时间复杂度和空间复杂度</li></ol><p id="ed63" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我强烈建议每个人先阅读提示，然后尝试自己解决问题。一旦他们尝试解决，他们可以参考我的解决方案，看看他们的方法与我的有何不同。最后，您可以回顾时间和空间复杂性，以真正深入地理解解决方案。</p></div><div class="ab cl lu lv hr lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ig ih ii ij ik"><h1 id="4df6" class="mb mc in bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated"><strong class="ak">问题</strong></h1><blockquote class="ki kj kk"><p id="9fa8" class="jk jl kl jm b jn jo jp jq jr js jt ju km jw jx jy kn ka kb kc ko ke kf kg kh ig bi translated">给你一个<code class="fe mz na nb nc b"><em class="in">k</em></code>链表<code class="fe mz na nb nc b"><em class="in">lists</em></code>的数组，每个链表按升序排序。</p><p id="6ae8" class="jk jl kl jm b jn jo jp jq jr js jt ju km jw jx jy kn ka kb kc ko ke kf kg kh ig bi translated"><em class="in">将所有链表合并成一个排序后的链表并返回。</em></p></blockquote><p id="ace3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">例1: </strong></p><pre class="kr ks kt ku gt nd nc ne nf aw ng bi"><span id="e523" class="nh mc in nc b gy ni nj l nk nl"><strong class="nc io">Input:</strong> lists = [[1,4,5],[1,3,4],[2,6]]<br/><strong class="nc io">Output:</strong> [1,1,2,3,4,4,5,6]<br/><strong class="nc io">Explanation:</strong> The linked-lists are:<br/>[<br/>  1-&gt;4-&gt;5,<br/>  1-&gt;3-&gt;4,<br/>  2-&gt;6<br/>]<br/>merging them into one sorted list:<br/>1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</span></pre><p id="254b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">例2: </strong></p><pre class="kr ks kt ku gt nd nc ne nf aw ng bi"><span id="575b" class="nh mc in nc b gy ni nj l nk nl"><strong class="nc io">Input:</strong> lists = []<br/><strong class="nc io">Output:</strong> []</span></pre><p id="0199" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">例3: </strong></p><pre class="kr ks kt ku gt nd nc ne nf aw ng bi"><span id="5939" class="nh mc in nc b gy ni nj l nk nl"><strong class="nc io">Input:</strong> lists = [[]]<br/><strong class="nc io">Output:</strong> []</span></pre></div><div class="ab cl lu lv hr lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ig ih ii ij ik"><h1 id="543b" class="mb mc in bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated"><strong class="ak">提示</strong></h1><p id="e980" class="pw-post-body-paragraph jk jl in jm b jn nm jp jq jr nn jt ju jv no jx jy jz np kb kc kd nq kf kg kh ig bi translated">方法一:暴力</p><p id="3547" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您可以遍历所有的链表，将每个值添加到一个数组中，最后将数组的排序版本作为一个链表返回。</p><p id="7709" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">方法2:使用优先级队列</strong></p><p id="c4b1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">优先级队列只不过是一个为每个元素分配了优先级的队列。具有高优先级的元素在具有低优先级的元素之前被服务。当元素从优先级队列中弹出时，所获得的结果或者按升序排序，或者按降序排序。而当从简单队列中弹出元素时，在结果中获得数据的FIFO顺序。</p><h1 id="7938" class="mb mc in bd md me nr mg mh mi ns mk ml mm nt mo mp mq nu ms mt mu nv mw mx my bi translated">解决办法</h1><h2 id="53fc" class="nh mc in bd md nw nx dn mh ny nz dp ml jv oa ob mp jz oc od mt kd oe of mx og bi translated"><strong class="ak">方法一:蛮力</strong></h2><pre class="kr ks kt ku gt nd nc ne nf aw ng bi"><span id="18eb" class="nh mc in nc b gy ni nj l nk nl"># Definition for singly-linked list.<br/># class ListNode:<br/>#     def __init__(self, val=0, next=None):<br/>#         self.val = val<br/>#         self.next = next<br/>class Solution:<br/>    def mergeKLists(self, lists: List[ListNode]) -&gt; ListNode:<br/>        <br/>        nodes = []<br/>        head = point = ListNode(0)<br/>        for l in lists:<br/>            while l:<br/>                nodes.append(l.val)<br/>                l = l.next<br/>        <br/>        for k in sorted(nodes):<br/>            point.next = ListNode(k)<br/>            point = point.next<br/>        return head.next</span></pre><p id="e8ab" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们将每个列表中每个节点的值保存在节点列表中。然后我们遍历一个排序列表，并保持指针指向排序节点列表中的下一个元素。最后，我们返回<code class="fe mz na nb nc b"> head.next</code>,它只不过是最后一个链表的开始，这个链表按照升序排列。</p><h2 id="8da5" class="nh mc in bd md nw nx dn mh ny nz dp ml jv oa ob mp jz oc od mt kd oe of mx og bi translated">方法2:使用优先级队列</h2><pre class="kr ks kt ku gt nd nc ne nf aw ng bi"><span id="a488" class="nh mc in nc b gy ni nj l nk nl">from heapq import heappush, heappop, heapify</span><span id="20f4" class="nh mc in nc b gy oh nj l nk nl">class Solution(object):<br/>    <!-- --> def mergeKLists(self, lists):<br/>        """<br/>        :type lists: List[ListNode]<br/>        :rtype: ListNode<br/>        """<br/>        <br/>        pre = cur = ListNode(0)<br/>           <br/>        heap = []<br/>        for i in range(len(lists)):<br/>            if lists[i]: <br/>                heapq.heappush(heap, (lists[i].val, i, lists[i]))<br/>                <br/>        while heap:<br/>            idx, node = heapq.heappop(heap)<br/>            cur.next = node<br/>            cur = cur.next<br/>            <br/>            if cur.next:<br/>                heapq.heappush(heap, (cur.next.val, idx, cur.next))<br/><br/>        return pre.next</span></pre><p id="4e19" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们首先使用<code class="fe mz na nb nc b">heapq </code>作为<code class="fe mz na nb nc b">heap</code>声明一个优先级队列，并将所有值放入这个队列中。现在我们迭代这个优先级队列并弹出这些值，这些值将按升序从队列中弹出，并保存在<code class="fe mz na nb nc b">idx</code>和<code class="fe mz na nb nc b">node</code>中。接下来，我们简单地迭代<code class="fe mz na nb nc b">cur</code>并更新<code class="fe mz na nb nc b">cur </code>以指向下一个值。</p><h1 id="7830" class="mb mc in bd md me nr mg mh mi ns mk ml mm nt mo mp mq nu ms mt mu nv mw mx my bi translated">复杂性</h1><h2 id="40b2" class="nh mc in bd md nw nx dn mh ny nz dp ml jv oa ob mp jz oc od mt kd oe of mx og bi translated">方法1:使用暴力</h2><p id="672c" class="pw-post-body-paragraph jk jl in jm b jn nm jp jq jr nn jt ju jv no jx jy jz np kb kc kd nq kf kg kh ig bi translated"><strong class="jm io">时间复杂度:</strong> <br/> <em class="kl"> O(NlogN) </em>其中<em class="kl"> N </em>为节点总数。</p><ul class=""><li id="b8b1" class="lg lh in jm b jn jo jr js jv li jz lj kd lk kh oi lm ln lo bi translated">收集所有值花费<em class="kl"> O </em> ( <em class="kl"> N </em>)时间。</li><li id="fdca" class="lg lh in jm b jn lp jr lq jv lr jz ls kd lt kh oi lm ln lo bi translated">一个稳定的排序算法需要花费<em class="kl">O</em>(<em class="kl">N</em>log<em class="kl">N</em>)的时间。</li><li id="f5fb" class="lg lh in jm b jn lp jr lq jv lr jz ls kd lt kh oi lm ln lo bi translated">创建链表的迭代花费<em class="kl"> O </em> ( <em class="kl"> N </em>)时间。</li></ul><p id="1e60" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">空间复杂度:</strong><br/><em class="kl">O</em>(<em class="kl">N</em>)</p><ul class=""><li id="4b57" class="lg lh in jm b jn jo jr js jv li jz lj kd lk kh oi lm ln lo bi translated">排序代价<em class="kl"> O </em> ( <em class="kl"> N </em>)空间(取决于你选择的算法)。</li><li id="75da" class="lg lh in jm b jn lp jr lq jv lr jz ls kd lt kh oi lm ln lo bi translated">创建一个新的链表需要花费<em class="kl"> O </em> ( <em class="kl"> N </em>)的空间。</li></ul><h2 id="5c4d" class="nh mc in bd md nw nx dn mh ny nz dp ml jv oa ob mp jz oc od mt kd oe of mx og bi translated">方法2:使用优先级队列</h2><p id="4f7c" class="pw-post-body-paragraph jk jl in jm b jn nm jp jq jr nn jt ju jv no jx jy jz np kb kc kd nq kf kg kh ig bi translated">它的运行时间将是O(nklog(k))。<br/>while循环将运行k * n顺序的列表中的所有节点，其中n是列表的长度。每次在while循环中，heappop和heap replace花费O(log(k))时间，因为我们在堆中最多有k个元素。所以while循环的运行时间是O(nklog(k))。</p></div><div class="ab cl lu lv hr lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ig ih ii ij ik"><p id="1239" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我希望你对这篇文章感兴趣，如果你能想出其他方法来解决这个问题，请告诉我。如果您发现我的现有解决方案有任何改进，请联系我。我很想听到你的反馈。<br/>你也可以在<a class="ae kp" href="https://twitter.com/RahilSarvaiya" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上关注我，我会在Twitter上发布我的软件开发之旅，也会更新我的最新文章。</p></div></div>    
</body>
</html>