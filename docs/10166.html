<html>
<head>
<title>React Redux Basics + Boilerplate CRUD Todo App</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React Redux 基础+样板 CRUD Todo 应用程序</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/react-redux-basics-boilerplate-crud-todo-app-6a9f9d5e7c27?source=collection_archive---------3-----------------------#2022-10-12">https://blog.devgenius.io/react-redux-basics-boilerplate-crud-todo-app-6a9f9d5e7c27?source=collection_archive---------3-----------------------#2022-10-12</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><h1 id="8169" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">在本文中，我们将探讨 Redux 的概念，包括它的优点和缺点，以及与之相关的术语。我们还将为 Todo 应用程序创建一个 Redux 样板文件。</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/50f1d2466ee60cd9b7a84ca026fa7c3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PlfOdg-PAWKVERli7DYbIA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">反应还原</figcaption></figure><h2 id="33e9" class="ky jl in bd jm kz la dn jq lb lc dp ju ld le lf jy lg lh li kc lj lk ll kg lm bi translated"><strong class="ak">🎈简介</strong></h2><p id="420c" class="pw-post-body-paragraph ln lo in lp b lq lr ls lt lu lv lw lx ld ly lz ma lg mb mc md lj me mf mg mh ig bi translated">Redux 是一个为 JavaScript 应用程序提供状态容器的库。它是由 Dan Abramov 和 Andrew Clark 开发的，用于管理应用程序的数据。它允许应用程序的不同组件通过动作、reducers 和中间件相互通信和交互。</p><p id="d00e" class="pw-post-body-paragraph ln lo in lp b lq mi ls lt lu mj lw lx ld mk lz ma lg ml mc md lj mm mf mg mh ig bi translated">Redux 通过提供一种标准的方法来处理应用程序中的状态，让我们的生活变得更加轻松。</p><h2 id="d5a3" class="ky jl in bd jm kz la dn jq lb lc dp ju ld le lf jy lg lh li kc lj lk ll kg lm bi translated">🎈Redux 原则</h2><p id="1f7c" class="pw-post-body-paragraph ln lo in lp b lq lr ls lt lu lv lw lx ld ly lz ma lg mb mc md lj me mf mg mh ig bi translated">这个库可以运行在不同的环境中，如客户机服务器或本机环境。Redux 通过将状态存储在一个名为 store 的全局对象中来管理状态</p><ul class=""><li id="5cc2" class="mn mo in lp b lq mi lu mj ld mp lg mq lj mr mh ms mt mu mv bi translated">状态为只读</li><li id="2356" class="mn mo in lp b lq mw lu mx ld my lg mz lj na mh ms mt mu mv bi translated">真理的单一来源</li><li id="128f" class="mn mo in lp b lq mw lu mx ld my lg mz lj na mh ms mt mu mv bi translated">纯粹的函数做改变</li></ul><h2 id="ae33" class="ky jl in bd jm kz la dn jq lb lc dp ju ld le lf jy lg lh li kc lj lk ll kg lm bi translated">Redux 的✅优点:</h2><ul class=""><li id="5505" class="mn mo in lp b lq lr lu lv ld nb lg nc lj nd mh ms mt mu mv bi translated">状态的可预见性</li><li id="4555" class="mn mo in lp b lq mw lu mx ld my lg mz lj na mh ms mt mu mv bi translated">高度可维护</li><li id="52da" class="mn mo in lp b lq mw lu mx ld my lg mz lj na mh ms mt mu mv bi translated">防止重新渲染</li><li id="da93" class="mn mo in lp b lq mw lu mx ld my lg mz lj na mh ms mt mu mv bi translated">调试更容易</li></ul><h2 id="fe65" class="ky jl in bd jm kz la dn jq lb lc dp ju ld le lf jy lg lh li kc lj lk ll kg lm bi translated">Redux 的❌ Cons</h2><ul class=""><li id="60e3" class="mn mo in lp b lq lr lu lv ld nb lg nc lj nd mh ms mt mu mv bi translated">无数据封装</li><li id="19c8" class="mn mo in lp b lq mw lu mx ld my lg mz lj na mh ms mt mu mv bi translated">受限设计</li><li id="9ce7" class="mn mo in lp b lq mw lu mx ld my lg mz lj na mh ms mt mu mv bi translated">由于状态不变性而导致内存使用过量</li><li id="d300" class="mn mo in lp b lq mw lu mx ld my lg mz lj na mh ms mt mu mv bi translated">耗时的实施</li></ul><h1 id="ce79" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">📚Redux 中的术语</h1><p id="124e" class="pw-post-body-paragraph ln lo in lp b lq lr ls lt lu lv lw lx ld ly lz ma lg mb mc md lj me mf mg mh ig bi translated"><strong class="lp io">🏬Store </strong> — Store 是一个保存 React 应用程序所有状态的对象。整个 Redux 应用程序应该有一个存储。状态变化是作为减速器的动作而发生的。</p><ul class=""><li id="353e" class="mn mo in lp b lq mi lu mj ld mp lg mq lj mr mh ms mt mu mv bi translated">getState()返回存储的当前状态。</li></ul><p id="6f01" class="pw-post-body-paragraph ln lo in lp b lq mi ls lt lu mj lw lx ld mk lz ma lg ml mc md lj mm mf mg mh ig bi translated">Reducers 是纯粹的函数，它决定应用程序的状态如何改变，以响应发送到存储的动作。</p><p id="b0f2" class="pw-post-body-paragraph ln lo in lp b lq mi ls lt lu mj lw lx ld mk lz ma lg ml mc md lj mm mf mg mh ig bi translated">本质上，reducer 监听事件(动作)并相应地更新状态。reducer 函数接受当前状态和一个 action 对象，并返回一个新状态:(state，action) =&gt; newState。本质上，这是一种根据收到的动作类型来指定状态应该如何更新的方法。</p><p id="e7f5" class="pw-post-body-paragraph ln lo in lp b lq mi ls lt lu mj lw lx ld mk lz ma lg ml mc md lj mm mf mg mh ig bi translated"><strong class="lp io">您可以将 reducer 看作一个事件监听器，它根据接收到的动作(事件)类型来处理事件。</strong></p><ul class=""><li id="a8e3" class="mn mo in lp b lq mi lu mj ld mp lg mq lj mr mh ms mt mu mv bi translated">动作只描述发生了什么，而不描述应用程序的状态如何变化。</li><li id="7d08" class="mn mo in lp b lq mw lu mx ld my lg mz lj na mh ms mt mu mv bi translated">reducer 是一个函数，它接受当前状态和动作，并通过执行的动作返回一个新状态。</li><li id="74eb" class="mn mo in lp b lq mw lu mx ld my lg mz lj na mh ms mt mu mv bi translated">combineReducers()实用程序是一个有用的工具，可以将一个应用程序中的所有 reducer 合并到一个索引 reducer 中。这使得应用程序的维护更加容易，因为所有的减速器都位于一个地方。</li><li id="214c" class="mn mo in lp b lq mw lu mx ld my lg mz lj na mh ms mt mu mv bi translated"><strong class="lp io">分派</strong>()分派一个动作。这是更新应用程序状态的唯一方法。</li><li id="a752" class="mn mo in lp b lq mw lu mx ld my lg mz lj na mh ms mt mu mv bi translated"><strong class="lp io"> subscribe </strong>()向状态订阅一个更改监听器。</li><li id="a357" class="mn mo in lp b lq mw lu mx ld my lg mz lj na mh ms mt mu mv bi translated"><strong class="lp io"> unsubscribe </strong>()在状态改变时不再想调用监听器方法时很有用。</li></ul><p id="e4bf" class="pw-post-body-paragraph ln lo in lp b lq mi ls lt lu mj lw lx ld mk lz ma lg ml mc md lj mm mf mg mh ig bi translated">一个<strong class="lp io">动作</strong>是一个普通的对象，表示改变状态的意图。它们必须有一个属性来指示要执行的操作类型。</p><ul class=""><li id="4fa7" class="mn mo in lp b lq mi lu mj ld mp lg mq lj mr mh ms mt mu mv bi translated">动作是将数据从应用程序发送到商店的信息负载。</li><li id="1fa4" class="mn mo in lp b lq mw lu mx ld my lg mz lj na mh ms mt mu mv bi translated">任何数据，无论是来自 UI 事件还是网络回调，最终都需要作为动作进行调度。</li><li id="b2ed" class="mn mo in lp b lq mw lu mx ld my lg mz lj na mh ms mt mu mv bi translated">动作必须有一个类型字段，指示正在执行的动作的类型。</li></ul><p id="8825" class="pw-post-body-paragraph ln lo in lp b lq mi ls lt lu mj lw lx ld mk lz ma lg ml mc md lj mm mf mg mh ig bi translated"><strong class="lp io">📌选择器</strong>是可以从存储状态值中提取特定信息的函数。随着应用程序的增长，它们会很有帮助，因为当应用程序的不同部分需要访问相同的数据时，它们允许您避免重复逻辑。这有助于提高应用程序的可维护性。</p><p id="e1fb" class="pw-post-body-paragraph ln lo in lp b lq mi ls lt lu mj lw lx ld mk lz ma lg ml mc md lj mm mf mg mh ig bi translated"><code class="fe ne nf ng nh b">const selectCounterValue = state =&gt; state.value<br/><br/>const currentValue = selectCounterValue(store.getState())<br/>console.log(currentValue)<br/>// 2</code></p><h1 id="54ff" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">数据流</h1><p id="1f68" class="pw-post-body-paragraph ln lo in lp b lq lr ls lt lu lv lw lx ld ly lz ma lg mb mc md lj me mf mg mh ig bi translated">我们可以用这个图来总结 Redux 应用程序的数据流。它代表了:</p><ul class=""><li id="4192" class="mn mo in lp b lq mi lu mj ld mp lg mq lj mr mh ms mt mu mv bi translated">响应用户交互(如点击)而分派动作</li><li id="95bc" class="mn mo in lp b lq mw lu mx ld my lg mz lj na mh ms mt mu mv bi translated">存储运行 reducer 函数来计算新的状态</li><li id="1aa7" class="mn mo in lp b lq mw lu mx ld my lg mz lj na mh ms mt mu mv bi translated">UI 读取新状态以显示新值</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/3c0a009349b460782f3a04ba8edb7222.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UsOxK-UdTMFchsoqzsDD0A.png"/></div></div></figure><h1 id="d4a4" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">🎨为 Todo 应用程序反应 Redux 样板文件</h1><ol class=""><li id="d731" class="mn mo in lp b lq lr lu lv ld nb lg nc lj nd mh nj mt mu mv bi translated">第一步，我们需要创建商店</li></ol><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/424ac51ce3bca090d8d2eca6b99d0132.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GNJtyCygGKukQ5fEznJv5Q.png"/></div></div></figure><p id="70aa" class="pw-post-body-paragraph ln lo in lp b lq mi ls lt lu mj lw lx ld mk lz ma lg ml mc md lj mm mf mg mh ig bi translated">2.在 index.js 中创建提供者，并将存储作为道具传递</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nl"><img src="../Images/f6dd92c4f84bf002c755c7dc88720ef3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fl1P0TEixhXu4Ulddt7TxQ.png"/></div></div></figure><p id="26a5" class="pw-post-body-paragraph ln lo in lp b lq mi ls lt lu mj lw lx ld mk lz ma lg ml mc md lj mm mf mg mh ig bi translated">3.创建切片器:</p><ul class=""><li id="80f2" class="mn mo in lp b lq mi lu mj ld mp lg mq lj mr mh ms mt mu mv bi translated">切片器的名称</li><li id="7999" class="mn mo in lp b lq mw lu mx ld my lg mz lj na mh ms mt mu mv bi translated">初态</li><li id="162c" class="mn mo in lp b lq mw lu mx ld my lg mz lj na mh ms mt mu mv bi translated">减速器(保存所有动作的地方)</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nm"><img src="../Images/2015618b8994ccdfb15803e7345c5de8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*41nazeLgaZ3lLSuhvNThqg.png"/></div></div></figure><p id="b0a2" class="pw-post-body-paragraph ln lo in lp b lq mi ls lt lu mj lw lx ld mk lz ma lg ml mc md lj mm mf mg mh ig bi translated">3.访问该州</p><ul class=""><li id="b563" class="mn mo in lp b lq mi lu mj ld mp lg mq lj mr mh ms mt mu mv bi translated">使用 useSelector 钩子可以访问 Redux 的状态</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/105da69af18478dd1e291f79d24ed3ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pFu13v7pJuHKSuGUOQj7_w.png"/></div></div></figure><p id="0153" class="pw-post-body-paragraph ln lo in lp b lq mi ls lt lu mj lw lx ld mk lz ma lg ml mc md lj mm mf mg mh ig bi translated">4.为了使用减速器，我们必须做到以下几点:</p><ul class=""><li id="7dc9" class="mn mo in lp b lq mi lu mj ld mp lg mq lj mr mh ms mt mu mv bi translated">需要导入 useDispatch 钩子</li><li id="026c" class="mn mo in lp b lq mw lu mx ld my lg mz lj na mh ms mt mu mv bi translated">导入要使用的减速器</li><li id="2df8" class="mn mo in lp b lq mw lu mx ld my lg mz lj na mh ms mt mu mv bi translated">使用如下<em class="no">调度(减速器(有效载荷参数))</em></li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/b9df9fb28793ceefbd6acf38116443d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2lEX7PMJ_FGkDcTw7G58MQ.png"/></div></div></figure><p id="a419" class="pw-post-body-paragraph ln lo in lp b lq mi ls lt lu mj lw lx ld mk lz ma lg ml mc md lj mm mf mg mh ig bi translated">5.在切片器中创建每个减速器</p><ul class=""><li id="f36b" class="mn mo in lp b lq mi lu mj ld mp lg mq lj mr mh ms mt mu mv bi translated">动作可以保存附加信息的字段，按照惯例，它保存在“有效载荷”中</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nq"><img src="../Images/18c0d04e97d3648c3dd7256e5e37cc90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*glLyqq28zgUJULxRFc2Agw.png"/></div></div></figure><p id="1453" class="pw-post-body-paragraph ln lo in lp b lq mi ls lt lu mj lw lx ld mk lz ma lg ml mc md lj mm mf mg mh ig bi translated"><strong class="lp io">快乐编码！💻</strong></p></div></div>    
</body>
</html>