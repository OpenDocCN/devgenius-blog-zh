# 计算机中浮点数的速成课程，第三部分

> 原文：<https://blog.devgenius.io/a-crash-course-on-floating-point-numbers-in-a-computer-part-iii-624f43a100aa?source=collection_archive---------2----------------------->

![](img/037794de56c63fc41edb74c9f10622bd.png)

詹·西奥多在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的照片

计算机编程语言中的数字数据类型是什么？这是初学者首先要学的东西之一。在大多数情况下，初学者了解到该语言至少有一种整数类型和至少一种浮点数类型，这些类型是什么，以及这些类型的范围是什么。

许多程序使用浮点计算，但是许多程序员没有意识到浮点运算的复杂性，直到精度损失导致令人不快的令人惊讶的问题。

初学者了解到整数类型有一个可以表示的最小整数(0 或负整数)和一个最大整数(几乎可以肯定是小于 2 的正整数)。

整数类型可以表示从最小值到最大值的任何整数。只要计算不超过最小值和最大值所限定的范围，就没有问题。

浮点类型也有它能表示的最小有理数和它能表示的最大有理数。然而，有无限多的有理数看起来在浮点类型的范围内，但它们必须是近似的。

而且几乎不用说，所有的无理数(像√2 和π)都必须用浮点数的有理数来近似，或者用正无穷大或者负无穷大来近似。

浮点数是如此的复杂，以至于这篇仅仅解释基础知识的文章也变得相当长。时间太长了，所以我决定把它分成两部分，后来又分成三部分。

在[第一部分](https://medium.com/dev-genius/a-crash-course-on-floating-point-numbers-in-a-computer-part-i-a7a70f67a27)中，我解释了符号位、指数位和尾数位，浮点中“负”零的存在，以及符号、指数和尾数的什么组合代表无穷大和“不是一个数”(NaN)。

我还解释了“正常”和“次正常”(或“反正常”)数字之间的区别。

在第二部分的[中，我解释了一点关于浮点运算的工作原理，以及浮点运算的优势和劣势。](https://medium.com/dev-genius/a-crash-course-on-floating-point-numbers-in-a-computer-part-ii-6fca16a0a321)

如果这些概念对你来说听起来很陌生，我强烈建议你在阅读这一部分之前先阅读第一部分和第二部分。

第二部分应该以浮点如何在主要的计算机编程语言中可用来结束。但我中断了内容，这就是这一部分的内容。

# 声明和初始化浮点变量

今天的 Java 程序员认为 Java 中的原始数据类型是理所当然的。这包括可作为 32 位“单精度”浮点的`float`和可作为 64 位“双精度”浮点的`double`。

C#程序员同样认为 C#中的原始数据类型是理所当然的。这包括`float`和`double`，它们就像 Java 的一样，还有特殊类型`decimal`，它比`float`或`double`更适合表示美元和美分(但我仍然建议使用第三方库或创建自己的`CurrencyAmount`类)。

在。NET 方案的东西，C#类型`float`、`double`、`decimal`对应`System.Single`、`System.Double`、`System.Decimal`。想必这三个也适用于 Visual Basic。

`double`类型是 Java 中的“默认”浮点类型。任何包含小数点但不包含后缀“`f`”或“`F`”的数字文字都被理解为`double`。

例如，“`3.5`”被理解为一个`double`，即使它可以被表示为一个`float`而没有任何精度损失；如果它是一个`float`，你必须写下`3.5f`或者`3.5F`。

在 Java 和几乎所有具有浮点类型的编程语言中，使用小数点是编写浮点文字最明显的方式。

可能所有这些语言都提供了对数字文字的“科学记数法”，其中“`e`”或“`E`”后跟一个整数代表“× 10”的整数次方。比如，“`1.5E10`”表示 1.5×10⁰；`1.5E-10`表示 1.5 × 1/10 ⁰.

这对于小数点一侧有很多零的数字来说非常方便。以下是一些例子:

您可能知道，在 Java 中，您可以使用十六进制来表示整数。原来在 Java 中，你也可以用十六进制来表示浮点文字。

然而，由于十六进制文字对阐明浮点数和位模式的关系没有什么帮助，所以它们与本文没有太大关系。在我看来，它们与十进制文字相比几乎没有任何优势。

C++中有三种浮点类型:`float`、`double`和`long double`。但是 C++标准没有定义这些类型的字节长度，只定义了它们的最小值。所以`float`至少应该是 32 位，`double`至少应该是 64 位，`long double`应该比`double`长。

在 C++中，你需要小心浮点文字。举例来说，如果你试图为一个`double`使用一个文字，但是把它放在一个`float`变量中，编译器将不得不转换它，并且转换可能是不正确的。

仔细想想，不管使用什么编程语言，这都应该是一个问题。至少对于 Java，你会得到关于从`double`到`float`可能有损转换的非常明确的警告。

Java 刚出来的时候，C++程序员不能依赖运行微软 Windows 的电脑拥有浮点硬件。例如，有必要检查 Intel 80386 的 CPU ID 的浮点单元位。

如果该位为 on，程序可以使用更快的 80387 浮点指令(可以使用更老的 80287，它仍然有助于浮点计算的改进)。如果它是关闭的，浮点将不得不用整数模拟。那一定是件痛苦的事。

Intel 80486 包括浮点功能而不需要额外的芯片，在 Java 刚出现时就已经出现了，但很可能当时仍在普遍使用较老的 80386 芯片。

这意味着早期 Java 运行时的程序员必须考虑这些细节，从而使 Java 程序员不必担心任何特定的芯片是否能进行浮点运算。

我不打算试图弄清楚 C++中浮点类型的转换是如何工作的或者应该如何工作的。Java 中浮点变量的转换要简单得多，而且更有可能在不同的操作系统中保持一致。

万一您担心一些操作系统可能会以不同的方式执行浮点运算，Java 有`strictfp`关键字，它要求编译器和运行时严格按照 IEEE 754 标准执行浮点运算。

通常的笑话是，有了`strictfp`，你可以保证浮点计算在所有操作系统中都是同样错误的。我还没有找到一个计算和硬件结合的具体例子，在这个例子中`strictfp`可以产生可以被检测到的最微小的差异。

当 Martin Odersky 创建 Scala 时，他继承了某些 Java 概念，但没有继承其他概念。Scala 拥有和 Java 一样的浮点“原语”类型(对于程序员来说是对象)，但是 Scala 一开始没有`strictfp`。

直到最近，Scala 才添加了`@strictfp`注释，这表明 Odersky 最初并不认为`strictfp`是必要的，甚至是相关的，因为几乎所有的新 CPU 都有浮点功能。

Java 不像 C++有`sizeof()`，但是 Java 包装类`Float`和`Double`都有常量`BYTES`。我们看到`Float.BYTES`总是 4，`Double.BYTES`总是 8。

每个 Java 包装器类都有一个常量`MAX_VALUE`，它保存该类型可以保存的最大正有限值。在`double`的情况下，那大概是 1.7976931348623157 × 10 ⁰⁸.

与整数原语的 Java 包装类不同，浮点原语的包装类中的每个`MIN_VALUE`常量都保存一个正数，而不是负数。

那个正数只比零稍多一点。对于`float`和`double`，`MIN_VALUE`都是一个非规格化的数字。在`double`的情况下，它等于 1 除以 2 ⁰⁷⁴.对于`float`和`double`，`MIN_VALUE`的位模式分别对应于`int`和`long`中的 1。

由于浮点中正数和负数之间的对称性，不需要常数来保存该类型可以表示的离零最远的有限负数。如果你需要，你可以写`-Double.MAX_VALUE`。

但是在 Scala 中，`Float.MinValue`和`Double.MinValue`分别对应`-Float.MIN_VALUE`和`-Double.MIN_VALUE`。

我重申，浮点数不能代表其所在区间的每一个有理数。例如，在`float`的情况下，这意味着一个`float`不能代表`Float.MIN_VALUE`和`Float.MAX_VALUE`之间的每一个正有理数。

`Double`和`Float`类有两个重要的函数，对我在本文中的研究很有帮助:`floatToIntBits()`和`doubleToLongBits()`。我用他们从我当地的斯卡拉 REPL。

然而，Java 有一个“规范 NaN”的概念，在这个概念下，`floatToIntBits()`和`doubleToLongBits()`会“折叠”任何 NaN 值，对于`float`为 7FC0 0000，对于`double`为 7FF8 0000 0000 0000。但是`Float`和`Double`也提供了`floatToRawIntBits()`和`doubleToRawLongBits()`的功能。

在我的系统上使用这些函数，`0f / 0`给出的 NaN 是 40 0000 而不是 7FC0 0000，操作`0 / 0`和调用`Math.sqrt(-1)`给出的 NaN 是 0000 0000 00 而不是 7FF8 0000 0000 0。我想我们可以称之为“积极的”和“消极的”NaNs。

JavaScript(“脚本”语言只是表面上与 Java 相关)的许多奇怪之处之一是，它只有一种内置的数字数据类型，而且是 64 位浮点型。

几年前，我读到一个关于在 JavaScript 中添加“大整数”的提议。除了 Internet Explorer，似乎所有主要的网络浏览器现在都支持 JavaScript 中的`BigInt`(希望现在所有 Windows 10 用户都有 Edge)。

这意味着 JavaScript 只有两种数值数据类型，TypeScript 也是如此。这两种语言都没有任何“大浮动”。

据我所知，FORTRAN 一直都有浮点数，但是就像 C++一样，它们也不是很标准化。显然 COBOL 确实有浮点运算，但它似乎非常依赖于系统。

我想我至少应该提到 Python。它有三种浮点类型，至少在名称上与 C#中的浮点类型相同。也许有人可以在评论里详细阐述一下。

# 在数字类型之间转换

另一件我们认为理所当然的事情是不同数值类型之间的转换。有时我们需要从整数转换成浮点，有时反过来。

其他时候，我们需要在不同位宽的整数类型或浮点类型之间进行转换。这些转换可以很容易地分为“缩小”转换和“扩大”转换。

例如，作为 16 位有符号整数，3 和 7 分别具有位模式 0003 和 FFF9(十六进制是表示位模式的一种非常方便的方式，因为十六进制数字和二进制位之间存在 1 到 4 的对应关系)。

将 16 位有符号整数扩展为 32 位有符号整数只需将符号位复制到额外的 16 位即可。例如，0003 扩展为 0000 0003，FFF9 扩展为 FFFF FFF9(为了可读性，我在两者中各加了一个空格)。

对于收缩转换，“额外”的位被简单地砍掉。如果被截断的比特都是相同的，就不会有信息丢失。例如，FFFF FFF9 可以缩小到 FFF9，或者进一步缩小到 F9，在这两种情况下都表示 7(前提是这些都是有符号整数格式)。

但是像 0003 FFF9 这样的 32 位有符号整数也会缩小到 FFF9 或 F9。在这两种情况下，变窄导致了不正确的符号更改，因为 262137 = 3 × 59 × 1481 超出了 8 位和 16 位整数的范围，无论有符号还是无符号。

浮点类型之间的收缩转换一点也不简单，但是它们通常不会导致不正确的符号变化。尽管这肯定会降低精确度。

比如 64 位浮点中的π，用位模式 4009 21FB 5444 2D18 来近似(见 Evan Wallace 的 [Float Toy](http://evanw.github.io/float-toy/) )。要将它缩小到 32 位浮点，必须去掉 32 位。

但是哪三十二位呢？特别是来自指数位的最低三位和来自尾数位的最低二十九位。以π为例，我们得到 4049 0FDA。

表示的数字显示为 3.1415925。但是，64 位表示中显示的数字是 3.141592653589793。使用十进制运算，我们可能会将其四舍五入为 3.1415927。

通过简单的截断，我们忽略了 1/16777216 的位，它是开的。为了补偿，我们应该将 1/16777216 向上舍入到 1/8388608，得到 4049 0FDB，显示为 3.1415927。

然而，这种简单的截断额外位的方法相当有效，部分原因是指数位偏置在这种情况下对我们有利，也就是说，2⁰总是偏置到前导指数位开启，其余的关闭。

假设我们想缩小 2π ≈ 6 的 64 位近似值的范围。28851 . 768686866866 位模式是 4019 21FB 5444 2D18。

但是像前面那样截断得到的不是 40C9 0FDA 而是 4049 0FDA，对应的是 3.1415925 而不是 6.283185。这意味着加倍在指数位的截断中丢失了。

因此，为了完成缩小转换，尾数位可以被截断或舍入，这可能会导致精度损失，但指数位需要更仔细的调整。

当收缩转换涉及到从正常转换到次正常转换时，就更加复杂了。例如，1/2 × 1/2 ⁶是一个可以用 64 位浮点精确表示为 36A0 0000 0000 0000 的数字。

它也可以用 32 位浮点精确表示，但请记住，在 32 位浮点中，指数只有 8 位，必要的指数 149 超出范围(也请记住，00000001 偏向 126，因此 10010101 偏向 22)。

然后，这种收缩转换需要将 64 位的正常数字转换为 32 位的次正常数字。所有指数位都偏离 126，因此没有隐含的前导“1”第 23 个尾数位可以仅表示 1/2，而不是 1 + 1/2。

这使我们得到 1/2 ⁴⁹和位模式 0000 0000 0000 0001(这是十六进制的，并不重要)。所以 1/2 ⁴⁹是可以用 32 位浮点表示的最小正数。

任何可以用 64 位浮点表示的较小的正数在收缩转换为 32 位时都将丢失为零。

浮点类型之间的扩大转换可以通过调整指数位并简单地在尾数位右边填充零来实现。

但是请注意，扩大转换不能弥补精度损失，就像对非常压缩的 JPEG 图像进行上采样几乎肯定不能恢复原始图像一样。

以π的 64 位近似值为例，我们将其“下采样”为 32 位。将其转换回 64 位浮点型，得到大约 3.1415927410125732，这对于大多数实际计算来说已经足够了，但对于天文计算来说可能不够。

当然，从整数到浮点的转换通常更有用，反之亦然。从有符号 32 位整数到 64 位浮点的转换可以看作是一种扩展转换。

由于 64 位浮点尾数有 52 位，因此任何 32 位有符号整数都可以用 64 位浮点精确表示。

但是，正如您可能已经想到的，这不是简单地将比特复制到正确的位置。如果整数是负的，就需要把它改成正的，并打开目标 64 位浮点数的符号位。当然，0 必须被视为一个特例，因为它是一个低于正常的数字。

对于正数，删除最高有效位并移动其他位，以便第二个最高有效位现在是浮点数的最高有效显式尾数位。

这样，剩下要做的就是计算指数，加上偏差，并相应地设置指数位。如果 Java 还没有提供进行这种转换的方法，我们可能需要编写如下代码:

或者，不丢弃正整数的最高有效位，将它向左移动适当的空格数，然后用最低有效指数位替换最高有效位，可能会容易得多。

幸运的是，Java 为我们提供了一种简单的方法，通过使用强制转换语法将`int`转换成`double`。

对于 Java 虚拟机来说，在任何语言中编写这样的函数都是不必要的，因为只要需要转换 32 位整数变量，编译器就可以使用`i2d`指令。

然而，人们希望编译器不要将这种转换应用于整数文字，而是将整数文字视为编写浮点文字，只要这样更有效。

Scala 没有为这些转换使用强制转换语法，所有的“原始”数值类型都有`toDouble()`函数(为了一致，包括`Double`)。因此，如果`number`的类型是`Int`，`number.toDouble`得到的转换与`(double) number`在 Java 中得到的相同。

在 Scala 中，你甚至可以做一些类似于`-73.toDouble`的事情，这当然比`-73.0`更冗长。我猜在科特林也差不多。

如果整数的绝对值不大于 2⁵，某些 64 位整数可以精确地转换为 64 位浮点。

你可能认为极限实际上是 2⁵，因为 64 位浮点只有 52 个尾数位。我也是这么想的，但是我忘了一个“正常”的浮点数实际上有五十三个尾数位:五十二个显式位和隐含的前导 1。

像 2⁵ + 7 = 4503599627370503 这样的数字可以用 64 位浮点精确表示，因为它变成了 4.5009627370503×10 ⁵.

但是 2⁵ + 1 = 9007199254740993 在转换中变成了 9.007199254740992 × 10 ⁵。转换为 64 位浮点的最大有符号 64 位整数 9223372036854775807 显示为 9.223372036854776 × 10 ⁸.

从技术上来说，2 到 2 ⁰的所有幂都可以用 64 位浮点精确表示，但不能用整数精度显示。和 2 ⁰ ⁴作为正无穷大丢失。

如果这是一门有分数的实际课程，我会布置以下额外的学分问题:在 64 位浮点中变成正无穷大的最小整数是什么？提示:它大于 2 ⁰ + 2 ⁰。想通了就贴在评论里吧。

回答这个额外的学分问题需要使用某种“大整数”类(`java.math.BigInteger`和`scala.math.BigInt`是您可能会有的几个选项)。

# 对浮点值进行操作

这要等[第四部](https://medium.com/dev-genius/a-crash-course-on-floating-point-numbers-in-a-computer-part-iv-40549c7b7a93)了。从那以后再也不会分开了，我保证。