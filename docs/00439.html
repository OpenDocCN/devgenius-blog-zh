<html>
<head>
<title>Memory Leaks in Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java 中的内存泄漏</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/memory-leaks-in-java-b92558fba65?source=collection_archive---------16-----------------------#2020-06-07">https://blog.devgenius.io/memory-leaks-in-java-b92558fba65?source=collection_archive---------16-----------------------#2020-06-07</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/d00c933bc5a1955ecd83391bfd8c434d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Kr4olZ5XwL6pmHKJCtYg2A.jpeg"/></div></div></figure><p id="1b23" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这个故事中，我们将看到什么是内存泄漏、垃圾收集器、Java 中的泄漏示例以及检测泄漏的工具。</p><p id="b892" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Java 的一个关键好处是内存管理主要由 Java 虚拟机或者更具体的 Java 垃圾收集器(GC)来处理。Java 垃圾收集器负责堆上对象的分配和释放。</p><h1 id="32c4" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">什么是内存泄漏</h1><p id="b2f2" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">在计算机科学中，内存泄漏是指计算机程序通过不释放不需要的资源来错误地管理内存分配。在 Java 中，当应用程序不再使用某个对象，但垃圾收集器无法将它从工作内存(堆)中移除时，就会发生内存泄漏。从长远来看，积累物体而不能清除它们会导致<code class="fe lw lx ly lz b">OutOfMemoryError</code></p><h1 id="3bb5" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">为什么对象没有被垃圾收集</h1><p id="4ddd" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">对象是否会从工作记忆中移除取决于对象的类型。有两种类型，被引用和未被引用。GC 会定期收集未被引用的对象，另一方面，GC 无法收集具有有效引用的对象。</p><p id="5483" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了更好的理解，请看下图。</p><figure class="mb mc md me gt jo gh gi paragraph-image"><div class="gh gi ma"><img src="../Images/5842358f7b1a86a33e6a79e57c59f153.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*RngkF0HKqEFI6ZMr-q9_ww.png"/></div></figure><p id="2e24" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">此外，Java 中有四种类型的引用可以用来管理 GC 如何以及何时收集对象。</p><ul class=""><li id="0e65" class="mf mg in jx b jy jz kc kd kg mh kk mi ko mj ks mk ml mm mn bi translated"><strong class="jx io">强引用</strong> —这是默认的对象引用。除非引用指向 null，否则无法收集具有强引用的对象。</li><li id="72d8" class="mf mg in jx b jy mo kc mp kg mq kk mr ko ms ks mk ml mm mn bi translated"><strong class="jx io">软引用</strong> —使用<code class="fe lw lx ly lz b">java.lang.ref.SoftReference</code>类引用的对象不会被收集，即使该对象对于 GC 是自由的。一旦 JVM 需要内存，就需要 GC 来清除所有的软引用。</li><li id="5b57" class="mf mg in jx b jy mo kc mp kg mq kk mr ko ms ks mk ml mm mn bi translated"><strong class="jx io">弱引用</strong> —如果 JVM 检测到没有强引用或软引用链接到任何对象，使用<code class="fe lw lx ly lz b">java.lang.ref.WeakReference</code>类引用的对象将被标记为 GC。</li><li id="6367" class="mf mg in jx b jy mo kc mp kg mq kk mr ko ms ks mk ml mm mn bi translated"><strong class="jx io">幻象引用</strong> —使用<code class="fe lw lx ly lz b">java.lang.ref.PhantomReference</code>引用的对象不会被 GC 自动清理，需要手动清理。在其引用对象的<code class="fe lw lx ly lz b">finalize</code>方法被执行后，虚引用被放入引用队列。</li></ul><h1 id="d83a" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">什么是垃圾收集器</h1><p id="7234" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">垃圾收集器是一个 JVM 守护线程，它定期从堆内存中收集未引用的对象。当一个对象不再被引用时，它就有资格从堆内存中被逐出。堆内存分为三大区域:<strong class="jx io">年轻一代</strong>(伊甸园空间、S0 幸存者空间和 S1 幸存者空间)<strong class="jx io">老一代</strong>和<strong class="jx io">永久一代</strong>。</p><p id="17ab" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">垃圾收集器也有四种类型:<strong class="jx io">串行垃圾收集器、并行垃圾收集器</strong>(默认 JVM GC) <strong class="jx io">、CMS 垃圾收集器和 G1 垃圾收集器。</strong></p><p id="d980" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">垃圾收集器之间的区别:</p><ul class=""><li id="1e42" class="mf mg in jx b jy jz kc kd kg mh kk mi ko mj ks mk ml mm mn bi translated"><strong class="jx io">串行垃圾收集器</strong>是为单线程环境设计的，它使用单线程来收集对象。这个 GC 适用于命令行应用程序，并通过使用<code class="fe lw lx ly lz b">-XX:+UseSerialGC</code> JVM 参数来启用。</li><li id="ab10" class="mf mg in jx b jy mo kc mp kg mq kk mr ko ms ks mk ml mm mn bi translated"><strong class="jx io">并行垃圾收集器</strong>是默认的 JVM 垃圾收集器，与串行 GC 不同，并行 GC 使用多线程从工作内存中收集未被引用的对象。</li><li id="e481" class="mf mg in jx b jy mo kc mp kg mq kk mr ko ms ks mk ml mm mn bi translated"><strong class="jx io"> CMS 垃圾收集器</strong>或<strong class="jx io"> </strong>并发标记清除垃圾收集器使用多线程来收集未引用的对象，它是为偏好缩短的 GC 暂停的应用程序而设计的。要启用 CMS 垃圾收集器，请使用<code class="fe lw lx ly lz b">-XX:UseConcMarkSweepGC</code> JVM 参数。</li><li id="f4d2" class="mf mg in jx b jy mo kc mp kg mq kk mr ko ms ks mk ml mm mn bi translated"><strong class="jx io"> G1 垃圾收集器</strong>用于大堆区。它使用技术将堆内存分成多个区域，并并行进行对象收集。要启用 G1 GC，请使用<code class="fe lw lx ly lz b">-XX:+UseG1GC</code> JVM 参数。</li></ul><h1 id="8758" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">内存泄漏的示例</h1><p id="ff6e" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">为了更快地再现内存泄漏，例如，我将使用 JVM 参数<code class="fe lw lx ly lz b">-Xmx125m</code>将堆大小降低到 125MB</p><p id="86a8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">内存泄漏最常见的情况之一是引用大量元素作为静态字段。让我们来看一个例子:</p><pre class="mb mc md me gt mt lz mu mv aw mw bi"><span id="b32f" class="mx ku in lz b gy my mz l na nb">private static final List&lt;String&gt; <em class="nc">listOfStrings </em>= new ArrayList&lt;&gt;(100000);<br/><br/>public static void main(String[] args) {<br/>    <em class="nc">fillStaticList</em>();<br/><br/>    try {<br/>        Thread.<em class="nc">sleep</em>(100_000);<br/>    } catch (InterruptedException e) {<br/>        e.printStackTrace();<br/>    }<br/>}<br/><br/>private static void fillStaticList() {<br/>    for (int i = 0; i &lt; 100000; i++) {<br/>        <em class="nc">listOfStrings</em>.add("Some large text + " + i);<br/>    }<br/>}</span></pre><figure class="mb mc md me gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nd"><img src="../Images/1d1a36fb5e9d0cc6c97d26255249b0f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8IeY2hzaLc9uFwuq3PiYgg.png"/></div></div></figure><p id="1f93" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在 JVM 进程生存期内，静态收集永远不会被 GC 收集。现在，我将在示例中声明 heavy collection 作为局部变量:</p><pre class="mb mc md me gt mt lz mu mv aw mw bi"><span id="cefc" class="mx ku in lz b gy my mz l na nb">public static void main(String[] args) {<br/>    <em class="nc">fillLocalList</em>();<br/><br/>    try {<br/>        Thread.<em class="nc">sleep</em>(100_000);<br/>    } catch (InterruptedException e) {<br/>        e.printStackTrace();<br/>    }<br/>}<br/><br/>private static void fillLocalList() {<br/>    List&lt;String&gt; listOfStrings = new ArrayList&lt;&gt;(100000);<br/>    for (int i = 0; i &lt; 100000; i++) {<br/>        listOfStrings.add("Some large text + " + i);<br/>    }<br/>}</span></pre><figure class="mb mc md me gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ne"><img src="../Images/4c778322b62e953c6d91fa41168eb54a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5hF7hd7KurJkt1WhtFbO7w.png"/></div></div></figure><p id="3d22" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">正如您可以从分析器中注意到的，一旦方法执行完毕，集合就会被 GC 移除。</p><h2 id="ef69" class="mx ku in bd kv nf ng dn kz nh ni dp ld kg nj nk lh kk nl nm ll ko nn no lp np bi translated">Java 分析器</h2><p id="a8d7" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">Java Profiler 是一个在 JVM 级别监控操作的工具。有许多可用的 Java Profilers，其中一些最流行的是 YourKit、JProfiler 和 VisualVM。</p></div></div>    
</body>
</html>