<html>
<head>
<title>How to test custom React Apollo hook using Jest Mock</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用 Jest Mock 测试自定义的 React Apollo 钩子</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/how-to-test-custom-react-apollo-hook-using-jest-mock-beb410671539?source=collection_archive---------1-----------------------#2022-05-03">https://blog.devgenius.io/how-to-test-custom-react-apollo-hook-using-jest-mock-beb410671539?source=collection_archive---------1-----------------------#2022-05-03</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/379569bf5a057f7872ff552e5e25fbe8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pfMI1Fp6IF2ttStZEC8PMw.png"/></div></div></figure><div class="jv jw gp gr jx jy"><a href="https://www.devdecks.io/2021-jest-testing-cheatsheet" rel="noopener  ugc nofollow" target="_blank"><div class="jz ab fo"><div class="ka ab kb cl cj kc"><h2 class="bd io gy z fp kd fr fs ke fu fw im bi translated">用 React cheatsheet 进行 Jest 测试</h2><div class="kf l"><h3 class="bd b gy z fp kd fr fs ke fu fw dk translated">当需要使用 Jest 和 React 编写 JavaScript 测试时，需要参考一些注意事项:*这不是一篇全面的帖子…</h3></div><div class="kg l"><p class="bd b dl z fp kd fr fs ke fu fw dk translated">www.devdecks.io</p></div></div></div></a></div><p id="3d89" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">我坚信编写好的测试是交付高质量产品的一个关键组成部分，并且我知道这并不总是简单明了的。在这篇文章中，我想分享我是如何使用 Jest Mock 函数测试一个用 Apollo 构建的自定义 React 钩子的。我正在使用<strong class="kj io">打字稿</strong>。</p><p id="0d08" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated"><strong class="kj io">章节概述:</strong></p><ol class=""><li id="c566" class="lf lg in kj b kk kl ko kp ks lh kw li la lj le lk ll lm ln bi translated">关于钩子<br/> 我将在另一篇文章中分享如何使用 Apollo 构建一个定制的 React 钩子。然而，在这篇文章中，我想简单回顾一下这个阿波罗钩子做了什么，以便理解我们正在测试的东西。</li><li id="71e7" class="lf lg in kj b kk lo ko lp ks lq kw lr la ls le lk ll lm ln bi translated"><strong class="kj io">使用模拟函数时 Jest 测试的基本结构/设置<br/> </strong>我将分享<strong class="kj io">我最喜欢的 Jest 模拟函数类比。</strong></li><li id="c81b" class="lf lg in kj b kk lo ko lp ks lq kw lr la ls le lk ll lm ln bi translated"><strong class="kj io">测试</strong></li><li id="e6e8" class="lf lg in kj b kk lo ko lp ks lq kw lr la ls le lk ll lm ln bi translated"><strong class="kj io">一些我觉得有用的测试技巧</strong></li></ol></div><div class="ab cl lt lu hr lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ig ih ii ij ik"><h1 id="f490" class="ma mb in bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">1.钩子！</h1><p id="5ed1" class="pw-post-body-paragraph kh ki in kj b kk my km kn ko mz kq kr ks na ku kv kw nb ky kz la nc lc ld le ig bi translated">钩子是一种函数。在 React 中，作为开发人员，钩子允许我们从组件中提取<strong class="kj io">有状态逻辑</strong>，以便<strong class="kj io">重用和独立测试，而不改变组件层次结构</strong>。</p><p id="29a7" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">现在，看一下这个定制挂钩:</p><figure class="nd ne nf ng gt jo"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="2fc1" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">这个定制钩子<code class="fe nj nk nl nm b">yourFunction</code>使用 Apollo 的<code class="fe nj nk nl nm b">useQuery</code>，这是一个在 React 应用程序中执行查询的 Apollo 钩子，并返回一个具有值<code class="fe nj nk nl nm b">loading</code>、<code class="fe nj nk nl nm b">error</code>和<code class="fe nj nk nl nm b">data</code>的对象。</p><p id="351a" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">我将<code class="fe nj nk nl nm b">yourFunction</code>定制为返回<code class="fe nj nk nl nm b">loading</code>、<code class="fe nj nk nl nm b">error</code>、<code class="fe nj nk nl nm b">isName</code>，而不是返回<code class="fe nj nk nl nm b">loading</code>、<code class="fe nj nk nl nm b">error</code>和<code class="fe nj nk nl nm b">data</code>的值。</p><p id="fc0a" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated"><code class="fe nj nk nl nm b">isName</code>从第 18 行<code class="fe nj nk nl nm b">useQuery</code>输出的数据中返回<code class="fe nj nk nl nm b">name</code>的字符串值。</p><p id="a9ee" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">你可以在阿波罗的网站上了解更多关于<code class="fe nj nk nl nm b">useQuery</code>的信息:</p><div class="jv jw gp gr jx jy"><a href="https://www.apollographql.com/docs/react/api/react/hooks/#example-2" rel="noopener  ugc nofollow" target="_blank"><div class="jz ab fo"><div class="ka ab kb cl cj kc"><h2 class="bd io gy z fp kd fr fs ke fu fw im bi translated">钩住</h2><div class="kf l"><h3 class="bd b gy z fp kd fr fs ke fu fw dk translated">Apollo Client &gt;= 3 包括现成的 React hooks 功能。你不需要安装任何额外的…</h3></div><div class="kg l"><p class="bd b dl z fp kd fr fs ke fu fw dk translated">www.apollographql.com</p></div></div><div class="nn l"><div class="no l np nq nr nn ns jt jy"/></div></div></a></div><p id="c789" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">现在我们已经了解了我们的定制钩子，我们可以开始测试了。</p><h1 id="b1a0" class="ma mb in bd mc md nt mf mg mh nu mj mk ml nv mn mo mp nw mr ms mt nx mv mw mx bi translated">2.测试的基本结构/设置</h1><figure class="nd ne nf ng gt jo"><div class="bz fp l di"><div class="ny ni l"/></div><figcaption class="nz oa gj gh gi ob oc bd b be z dk translated">夜幕降临时，狼人挑选他们的受害者</figcaption></figure><p id="cc38" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">我艰难地学习了 Jest，但是如果你知道 Jest 如何工作和它的基本测试结构，它实际上并不复杂。</p><p id="b194" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">在进入实际步骤之前，让我们确保我们知道 Mock 函数是做什么的。</p><p id="3574" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">根据<a class="ae od" href="https://jestjs.io/docs/mock-functions" rel="noopener ugc nofollow" target="_blank"> Jest </a>，</p><blockquote class="oe of og"><p id="56fa" class="kh ki oh kj b kk kl km kn ko kp kq kr oi kt ku kv oj kx ky kz ok lb lc ld le ig bi translated">模拟函数允许您通过<strong class="kj io">删除函数</strong>、<strong class="kj io">捕获对函数的调用</strong>(以及这些调用中传递的参数)、<strong class="kj io">在用<code class="fe nj nk nl nm b"><em class="in">new</em></code>实例化时捕获构造函数的实例</strong>，并允许返回值的测试时配置，来测试代码之间的链接。</p></blockquote><p id="b577" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">了解 Jest 的工作原理后，我觉得和打<a class="ae od" href="https://en.wikipedia.org/wiki/Mafia_(party_game)" rel="noopener ugc nofollow" target="_blank"> <strong class="kj io">狼人</strong> </a> <strong class="kj io">差不多。</strong>在游戏中，版主(我一直是这样玩游戏的。这一直是版主的工作……)(1)<strong class="kj io">给玩家分配角色；</strong>和(2) <strong class="kj io">协调玩家</strong> <strong class="kj io">的动作，让玩家完成自己的角色。之后，玩家采取行动。</strong></p><p id="61c1" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">当我完成每个步骤时，这将更有意义:</p><p id="9f79" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">A.首先，我们需要将您的函数导入到测试文件中，就像邀请人们玩狼人游戏一样。</p><pre class="nd ne nf ng gt ol nm om on aw oo bi"><span id="c4f2" class="op mb in nm b gy oq or l os ot">import yourFunction from '...'</span></pre><p id="710b" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">B.类似于版主给玩家分配角色，使用<code class="fe nj nk nl nm b">.mock</code>让应用程序知道你在用<code class="fe nj nk nl nm b">jest.mock</code>嘲笑这个功能</p><p id="4bf4" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">模仿函数主要有两种方式:(1)创建一个模仿函数实例；(2)写一个<code class="fe nj nk nl nm b"><a class="ae od" href="https://jestjs.io/docs/manual-mocks" rel="noopener ugc nofollow" target="_blank"><em class="oh">manual mock</em></a></code>来覆盖一个模块依赖。</p><p id="b47a" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">对于第一种方法，我们需要为<em class="oh"> yourFunction </em>定义<em class="oh">类型</em>。</p><pre class="nd ne nf ng gt ol nm om on aw oo bi"><span id="349e" class="op mb in nm b gy oq or l os ot">let yourFunction: jest.Mock;</span></pre><p id="30ee" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">如果您以上述方式定义<em class="oh">类型</em>，您将需要在以后声明<code class="fe nj nk nl nm b">yourFunction</code>的用途，如下所示:</p><pre class="nd ne nf ng gt ol nm om on aw oo bi"><span id="2d6e" class="op mb in nm b gy oq or l os ot">yourFunction = jest.fn()</span></pre><p id="fc92" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">注意<code class="fe nj nk nl nm b">jest.fn()</code>方法默认返回<code class="fe nj nk nl nm b">undefined</code>。我们可以通过不同的<a class="ae od" href="https://jestjs.io/docs/mock-function-api" rel="noopener ugc nofollow" target="_blank">模拟函数</a>来控制返回值。我将在这篇文章的后面讨论这一部分。</p><p id="77b1" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">前面讨论的第二种方法是模仿一个模块。这是我们将要用来实现测试的方法。</p><p id="f2fe" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">请注意，第一个参数<code class="fe nj nk nl nm b">jest.mock('./moduleName')</code>是必需的。</p><pre class="nd ne nf ng gt ol nm om on aw oo bi"><span id="b452" class="op mb in nm b gy oq or l os ot"><em class="oh">jest</em>.mock('file directory of yourFunction module', () =&gt; ({</span><span id="93bb" class="op mb in nm b gy ou or l os ot">    yourFunction: <em class="oh">jest</em>.fn(),</span><span id="fb82" class="op mb in nm b gy ou or l os ot">}));</span></pre><p id="5b14" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">还要注意它使用了隐式返回。这是用<code class="fe nj nk nl nm b">yourFunction: jest.fn()</code>返回一个对象。<em class="oh">键</em>为<code class="fe nj nk nl nm b">yourFunction</code>，<em class="oh">值</em>为<code class="fe nj nk nl nm b">jest.fn()</code>。</p><p id="c86f" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">除了上述方法，您还可以这样做:</p><pre class="nd ne nf ng gt ol nm om on aw oo bi"><span id="4fc3" class="op mb in nm b gy oq or l os ot">jest.mock('file directory of your function');</span></pre><p id="16a2" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">这也可以写成:</p><pre class="nd ne nf ng gt ol nm om on aw oo bi"><span id="9def" class="op mb in nm b gy oq or l os ot">jest.mock(‘file directory of your function’, ()=&gt; jest.fn());</span></pre><p id="2ced" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">注意，第二个参数是可选的，但默认为<code class="fe nj nk nl nm b">jest.fn()</code>:</p><pre class="nd ne nf ng gt ol nm om on aw oo bi"><span id="82a8" class="op mb in nm b gy oq or l os ot">jest.mock('file directory of yourFunction module', () =&gt; () =&gt; [  </span><span id="bcb3" class="op mb in nm b gy ou or l os ot">    jest.fn(),  { someKey: true },</span><span id="8a46" class="op mb in nm b gy ou or l os ot">]);</span></pre><p id="5eea" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated"><em class="oh"> C. </em>现在游戏正在进行中，玩家们正全力投入到他们被分配的角色中。从这里开始，玩家将根据他们的角色实施不同的策略，并开始<strong class="kj io">采取行动</strong>。</p><p id="0fe8" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">以同样的方式<em class="oh">，</em>你需要确切地定义函数如何模仿以及为了什么目的。<a class="ae od" href="https://jestjs.io/docs/mock-function-api" rel="noopener ugc nofollow" target="_blank"> Jest </a>将模拟函数描述为"<em class="oh">间谍</em>"，因为它们允许我们"<em class="oh">窥探被其他代码间接调用的函数的行为，而不仅仅是测试输出。</em></p><pre class="nd ne nf ng gt ol nm om on aw oo bi"><span id="8f67" class="op mb in nm b gy oq or l os ot">(yourFunction as <em class="oh">jest</em>.<em class="oh">Mock</em>).mockImplementationOnce(() =&gt; result);</span></pre><p id="7e9a" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">类似于狼人如何伪装成村民，这些模拟函数可以改变返回值和实现。</p><p id="87aa" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">在上面的代码示例中，我使用了<code class="fe nj nk nl nm b">mockImplementationOnce()</code>。您可以使用不同的模拟方法。</p><h1 id="f0bd" class="ma mb in bd mc md nt mf mg mh nu mj mk ml nv mn mo mp nw mr ms mt nx mv mw mx bi translated">3.测试:将不同的例子放在一起:)</h1><figure class="nd ne nf ng gt jo"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="d68f" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">完成了！</p><h1 id="43c7" class="ma mb in bd mc md nt mf mg mh nu mj mk ml nv mn mo mp nw mr ms mt nx mv mw mx bi translated">4.一些提示</h1><p id="94f7" class="pw-post-body-paragraph kh ki in kj b kk my km kn ko mz kq kr ks na ku kv kw nb ky kz la nc lc ld le ig bi translated">(a)在<code class="fe nj nk nl nm b">beforeEach</code>功能中设置模拟功能。</p><p id="d402" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">(b)如果你的结构不正确，有时模仿一个函数/模块会产生错误，污染其他测试。每个函数都应该有一个新的设置。通过在每个测试规范之后清除模拟，确保您的代码没有“泄漏”:</p><pre class="nd ne nf ng gt ol nm om on aw oo bi"><span id="9e56" class="op mb in nm b gy oq or l os ot">afterEach(()) =&gt; {<br/>   jest.clearAllMocks();<br/>});</span></pre></div><div class="ab cl lt lu hr lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ig ih ii ij ik"><p id="b9e4" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">当你鼓掌时👏我的帖子和订阅，你支持我的科技之旅，我将不胜感激:)</p><p id="a28d" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">谢谢，祝编码愉快！</p></div></div>    
</body>
</html>