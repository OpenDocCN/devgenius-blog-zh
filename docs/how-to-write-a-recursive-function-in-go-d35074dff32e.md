# 如何在 Go 中编写递归函数

> 原文：<https://blog.devgenius.io/how-to-write-a-recursive-function-in-go-d35074dff32e?source=collection_archive---------24----------------------->

![](img/2a37743f3164eba18d6066d5244a4071.png)

我不知道你，但是当我开始编程时，递归这个术语让我有点发抖。老实说，我认为这是一种自然的反应。新事物会让人害怕！我也不理解在代码中使用递归的重要性或潜在影响。如果你对递归没有很好的理解，你很幸运！我将讨论如何利用递归的力量，并在你的围棋程序中使用它。

# 那么，什么是递归？

> 过程或定义的重复应用

递归在编程中的一个常见用法是在同一个函数内部调用一个函数。让我给你看一个例子:

`main`:

*   在`func` `main`内部，我们声明变量`n`，并将`n`赋给`factorial`函数的返回值
*   `factorial`函数有一个类型为`int`的参数`4`
*   在下一行执行中，使用`fmt`包，我们打印出`n`的值

> 快速提示:在每一个递归函数中，都需要有一个“基本情况”。
> 
> 基本情况是最常见的 if 语句，当评估为“真”时
> 
> 将停止调用函数内的函数(停止递归)
> 
> 并将允许程序从函数中返回

`factorial`:

*   在`main`函数下面，我们声明了一个标识符为`factorial`的函数
*   函数`factorial`有一个类型为`int`的参数`n`
*   函数`factorial`返回一个`int`类型的值
*   在本例中，`factorial`中的*基本用例*是一个`if`语句，用于检查`n`的值是否为`0`
*   因为我们的参数`n`是`4`，所以计算结果为`false`，我们继续执行下一行
*   我们的下一行是一个表达式为`n * factorial(n-1)`的`return`语句，这是什么意思？

-我们的下一行是一个表达式为`n * factorial(n-1)`的`return`语句，这是什么意思？

`n * factorial(n-1)`:

*   在第一次迭代中，`n`的值是`4`，所以我们可以这样写这个表达式:`4 * factorial(4–1)`
*   我们可以为`factorial`的自变量做减法，当我们做的时候，表达式看起来像这样:`4 * factorial(3)`
*   现在，我们知道我们有了`4`的值；然而，我们用参数`3`再次调用`factorial`
*   因为我们调用了`factorial`，所以我们跳转到函数的第一行执行

*   我们知道`n`的值现在是`3`；因此，我们的*基础案例*仍然评估为`false`
*   现在`n`的值是`3`，我们的`return`语句现在看起来像这样:`4 * 3 * factorial(3–1)`
*   简体:`4 * 3 * factorial(2)`
*   我们再次调用`factorial`，参数是类型`int`的值`2`

*   我们的*基础案例*仍然评估为`false`，因为`2`不等于`0`
*   我们的`return`语句现在看起来像这样:`4 * 3 * 2 * factorial(2–1)`
*   简体:`4 * 3 * 2 * factorial(1)`
*   我们再次调用`factorial`，参数是类型`int`的值`1`

*   我们的*基础案例*仍然评估为`false`，因为`1`不等于`0`
*   我们的`return`语句现在看起来像这样:`4 * 3 * 2 * 1 * factorial(1–1)`
*   简体:`4 * 3 * 2 * 1 * factorial(0)`

*   这一次，我们的*基础用例*仍然评估为`true`，因为`0` *等于*和`0`
*   在我们的*基础案例*中，我们返回类型`int`的值`1`
*   既然我们的递归已经完成，我们最后的`return`语句将看起来像这样:`return 4 * 3 * 2 * 1`，它计算出类型`int`的值`24`

`main`:

*   现在所有的执行都完成了，`n`的值被计算为`24`，这个值在下一行打印出来

# 概括起来

我希望你喜欢学习递归。尽管这个例子并不太复杂，但我希望你在阅读完这篇文章后，能够更好地理解*递归*的原理，并将它们应用到你的工作流程中。我会说，在编写递归函数时，应该有一定程度的谨慎。如果您的*基础用例*不健全，您可能会发现自己处于一个函数可以不断调用自身并且不可避免地导致[堆栈溢出](https://en.wikipedia.org/wiki/Stack_overflow)的位置。然而，如果做对了，*递归*允许我们写出干净、简洁、高效的代码。

下周我将讨论*指针、JSON 编组和 JSON 解组*。到时候见！