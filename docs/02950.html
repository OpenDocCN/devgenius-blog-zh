<html>
<head>
<title>Best of Modern JavaScript — let and const</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">现代JavaScript的精华— let和const</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/best-of-modern-javascript-let-and-const-c49d19751753?source=collection_archive---------14-----------------------#2020-09-14">https://blog.devgenius.io/best-of-modern-javascript-let-and-const-c49d19751753?source=collection_archive---------14-----------------------#2020-09-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/f2896a3edc00842d995b3fc1aa34f25b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*EolTbuG97lNF_qcY"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">约翰·邓肯在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="7a07" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">自2015年以来，JavaScript有了巨大的进步。</p><p id="c894" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在用起来比以前舒服多了。</p><p id="193a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究JavaScript变量。</p><h1 id="d270" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><code class="fe lz ma mb mc b">const</code>创建不可变变量</h1><p id="000d" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">我们可以用<code class="fe lz ma mb mc b">const</code>创建不可变变量。</p><p id="7fab" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="aaac" class="mq lc iq mc b gy mr ms l mt mu">const<!-- --> <!-- -->foo<!-- --> <!-- -->=<!-- --> <!-- -->'abc';<br/>foo<!-- --> <!-- -->=<!-- --> <!-- -->'baz';</span></pre><p id="83c6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们有一个类型错误。</p><h1 id="ec5c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><code class="fe lz ma mb mc b">const</code>并不使价值不可变</h1><p id="7883" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">即使变量不能被重新分配，它的值仍然可以改变。</p><p id="9e4b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有一个对象:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="a936" class="mq lc iq mc b gy mr ms l mt mu">const<!-- --> <!-- -->obj<!-- --> <!-- -->=<!-- --> <!-- -->{};</span></pre><p id="9239" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以给它添加属性:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="3512" class="mq lc iq mc b gy mr ms l mt mu">const<!-- --> <!-- -->obj<!-- --> <!-- -->=<!-- --> <!-- -->{};<br/>obj.prop<!-- --> <!-- -->=<!-- --> 'foo'<!-- -->;<br/>console.log(obj.prop);</span></pre><p id="3a08" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lz ma mb mc b">obj.prop</code>会是<code class="fe lz ma mb mc b">'foo'</code>。</p><p id="05f1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们想让对象不可变，我们可以调用<code class="fe lz ma mb mc b">Object.freeze</code>方法:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="c226" class="mq lc iq mc b gy mr ms l mt mu">const obj = Object.freeze({});</span></pre><p id="af87" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lz ma mb mc b">Object.freeze</code>仅阻止顶级改变。</p><p id="2f56" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">存储在其属性中的对象仍然是可变的。</p><p id="80f2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们有:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="9599" class="mq lc iq mc b gy mr ms l mt mu">const<!-- --> <!-- -->obj<!-- --> <!-- -->=<!-- --> <!-- -->Object.freeze({<!-- --> <!-- -->foo:<!-- --> <!-- -->{}<!-- --> <!-- -->});</span></pre><p id="6a58" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以写:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="3e66" class="mq lc iq mc b gy mr ms l mt mu">obj.foo.qux = 'baz';</span></pre><p id="22ea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是可行的。</p><h1 id="78ed" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><code class="fe lz ma mb mc b">const</code>在循环体中</h1><p id="9b50" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">我们可以在循环体中使用<code class="fe lz ma mb mc b">const</code>。</p><p id="9084" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="8e72" class="mq lc iq mc b gy mr ms l mt mu">function logArgs(...args) {<br/>  for (const [index, elem] of args.entries()) { <br/>    console.log(index, elem);<br/>  }<br/>}</span></pre><p id="2b12" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们调用<code class="fe lz ma mb mc b">entries</code>方法，该方法返回带有条目索引的<code class="fe lz ma mb mc b">index</code>和带有条目本身的<code class="fe lz ma mb mc b">elem</code>的条目。</p><p id="52eb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lz ma mb mc b">const</code>防止数组赋值。</p><h1 id="a83c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><code class="fe lz ma mb mc b">var</code>声明变量的生命周期</h1><p id="ec28" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lz ma mb mc b">var</code>变量没有时间死区。</p><p id="c3cf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这意味着它们在其范围内随处可见。</p><p id="6bea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它的声明被提升了，但值却没有。</p><h1 id="76d8" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><code class="fe lz ma mb mc b">let</code>声明变量的生命周期</h1><p id="86cf" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lz ma mb mc b">let</code>变量只有在声明后才可用。</p><p id="8fd0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这意味着在块内，时间死区在块的开始和它们被声明之间。</p><p id="8e60" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这和<code class="fe lz ma mb mc b">const</code>是一样的。</p><p id="17d9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们试图在声明这些变量之前访问它们，我们将得到一个<code class="fe lz ma mb mc b">ReferenceError</code>。</p><p id="8e83" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果没有给<code class="fe lz ma mb mc b">let</code>变量赋值，它将是<code class="fe lz ma mb mc b">undefined</code>。</p><p id="4dbe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="99a8" class="mq lc iq mc b gy mr ms l mt mu">let foo = true;<br/>if (true) {<br/>  console.log(foo);</span><span id="702c" class="mq lc iq mc b gy mv ms l mt mu">  let foo;<br/>  console.log(foo);</span><span id="5116" class="mq lc iq mc b gy mv ms l mt mu">  foo = 123;<br/>  console.log(foo);<br/>}<br/>console.log(foo)</span></pre><p id="9448" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后<code class="fe lz ma mb mc b">console.log(foo);</code>会给我们弄个<code class="fe lz ma mb mc b">ReferenceError</code>。</p><p id="bac8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并且:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="fa89" class="mq lc iq mc b gy mr ms l mt mu">let foo;<br/>console.log(foo);</span></pre><p id="e430" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">将日志<code class="fe lz ma mb mc b">undefined</code>。</p><p id="ef61" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并且:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="e1bd" class="mq lc iq mc b gy mr ms l mt mu">foo = 123;<br/>console.log(foo);</span></pre><p id="cc1b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">日志123。</p><p id="d253" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而<code class="fe lz ma mb mc b">foo</code>就是<code class="fe lz ma mb mc b">true</code>。</p><h1 id="bf2f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><code class="fe lz ma mb mc b">typeof</code>为临时交易区的变量抛出一个<code class="fe lz ma mb mc b">ReferenceError</code></h1><p id="0b85" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">我们不能将<code class="fe lz ma mb mc b">typeof</code>与尚未声明的<code class="fe lz ma mb mc b">let</code>和<code class="fe lz ma mb mc b">const</code>变量一起使用。</p><p id="f7bf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="1d64" class="mq lc iq mc b gy mr ms l mt mu">if (true) {<br/>  console.log(typeof foo);<br/>  let foo;<br/>}</span></pre><p id="e765" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，如果我们运行代码，我们将得到一个<code class="fe lz ma mb mc b">ReferenceError</code>。</p><p id="7b38" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们想停止它，我们应该把<code class="fe lz ma mb mc b">typeof</code>移到<code class="fe lz ma mb mc b">let</code>声明的下面。</p><p id="0c4d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有一个时间死区可以让我们捕捉编程错误。</p><p id="e04b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JavaScript将来也可能有守卫来做数据类型和内容检查。</p><p id="12e9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，在进行检查之前，我们应该确保数据可用。</p><p id="e099" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果它们只有在声明后才可用，那么检查就很容易完成。</p><h1 id="8907" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">循环头中的<code class="fe lz ma mb mc b">let</code>和<code class="fe lz ma mb mc b">const</code></h1><p id="cde5" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">我们可以在for、for-in和for-of循环的循环头中使用<code class="fe lz ma mb mc b">let</code>和<code class="fe lz ma mb mc b">const</code>。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/e588f237c28d150340060999478679aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*W_DzvkVkY6KfIf0T"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">丹尼尔·罗伯特在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="dbf9" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="a733" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lz ma mb mc b">let</code>和<code class="fe lz ma mb mc b">const</code>提供了很多<code class="fe lz ma mb mc b">var</code>没有的好处。</p></div></div>    
</body>
</html>