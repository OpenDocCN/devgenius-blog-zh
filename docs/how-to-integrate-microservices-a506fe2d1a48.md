# 如何整合微服务

> 原文：<https://blog.devgenius.io/how-to-integrate-microservices-a506fe2d1a48?source=collection_archive---------6----------------------->

![](img/6cdd7c839f2006512dc8f0b1b5c0054e.png)

为了了解*如何*，我们首先需要问一个问题，*为什么*我们要集成服务。
我们集成服务是因为我们想要访问外部数据:
*【获取当前钱包余额】*
或者因为我们想要命令其他服务执行操作:
*【向电子钱包转账】*
其他服务也可以自行执行操作，当特定事件发生时:
*【当个人帐户被禁止时，阻止其电子钱包】*

命令和事件在系统中产生动作，导致数据改变或副作用(如发送电子邮件/短信)。
另一端的查询只是为了获取数据，无论如何不会改变服务的状态。

区分查询和动作(命令和事件)很重要，不要把它们混在一起。我们马上就会知道这有什么关系。

# 通过 HTTP 集成服务

集成的第一种可能性是使用 HTTP。我们向特定的端点发出 HTTP 请求，并得到响应。
HTTP 的强大之处在于马上得到反馈(响应)。

然而，HTTP 集成有一些缺点:

*   我们需要依赖正在运行的服务。万一服务中断，我们无法呼叫它
*   服务可能超载或只是工作缓慢，这可能会造成我们这边的延迟问题
*   它创建了服务之间的耦合

即使考虑到上述问题，立即获得响应的可能性使其非常适合查询集成。

> 另一方面，动作的 HTTP 集成可能会在系统中产生不一致性。

假设注册用户后，我们调用另一个服务来发送电子邮件。当服务停止时，会发生什么？
我们将无法调用，因此我们创建了一系列需要解决的问题:
-如果我们想要保持注册，我们将需要消除错误。
- *I* 如果我们无论如何都要发送电子邮件，我们将需要存储失败的数据，以便我们可以重试它
- *W* e 将需要具有延迟的重试机制，因为服务可能在 10 秒或 20 分钟内启动并运行。

假设另一个场景，我们调用另一个服务，以便从钱包中扣除钱，请求超时。这对我们意味着什么？我们不可能真的知道，因为服务可以执行动作，但也可以不执行。如果系统不提供某种重复数据删除机制，如果我们重新发送请求，我们可能会扣除两次费用。而且，如果我们不这样做，我们可能会陷入钱根本没有被扣除的境地。嗯，现在的情况真的不太好，对吧？:)

> HTTP 非常适合查询，但是对于处理动作，有一个更健壮的解决方案，消息传递。

# 通过消息传递集成服务

![](img/a7b48b3e894a5a280c0a8b94fbd99d77.png)

信息传递就像邮递员，我们就像发送信件(信息)的客户。信件包含标题和内容(在消息传递中，我们称之为内容——有效载荷)。
我们正在给邮递员提供信件，邮递员将信件投递到收件人的信箱。
当收信人准备好了，他就把信从盒子里拿出来，阅读信头和内容，然后采取行动。

把它推到编程层次，邮递员可以是 [RabbitMQ](https://www.rabbitmq.com/) ，我们连接到它提供消息传递。RabbitMQ 知道如何把它传递到给定的盒子(队列)。当它在接收者的队列中结束时，他可能会在对他最合适的时候消费掉它。

让我们看看消息传递如何解决 HTTP 的缺点:

*   HTTP 问题#1:我们需要依赖正在运行的服务。万一服务中断，我们无法呼叫它

我们把信交给邮递员，收件人准备好了就从箱子里取出信。
这允许我们向通知服务(收件人)发送说明“向 X 发送 sms”的信件，即使该服务已关闭。当服务生起床时，他会挑选字母并执行动作。

> 有了消息传递，我们变得独立于周围的服务状态

*   HTTP 问题#2:服务可能超载或者只是运行缓慢，这给我们造成了延迟问题

当我们通过 HTTP 调用服务时，我们处于请求-响应模型中。
这种模式会产生延迟，因为我们要等待收到响应。

> 在信息传递方面，我们采用的是“一劳永逸”的模式。这意味着我们只连接到邮递员(消息代理)来发送消息，不管当前接收者的状态如何，消息流都会继续。
> 这将我们从其他服务的响应时间中解放出来。

*   HTTP 问题#3:与其他服务的耦合

如果客户端在我们的系统中注册，我们可能希望在其他服务中执行一些操作。
如在钱包服务中创建钱包，使用通知服务发送电子邮件。
如果我们通过 HTTP 进行集成，我们将需要调用这些服务来通知它们新的注册。这当然带来了所有 HTTP 的缺点，乘以我们调用的服务数量。
在消息传递的情况下，我们只与 Postman 集成。我们将使用 Postman 发布事件消息，任何感兴趣的服务都可以订阅。
收件人可以随时加入或退出订阅。邮递员将负责将消息传递给所有订阅服务。

> 消息传递创建了解耦的解决方案，其中每个服务可以控制它们想要知道(订阅)的内容。

# 作为命令或事件的操作

在信息传递中，我们发送的一切都是一条信息，然而，我们可以根据我们想如何使用它们来区分两种类型的信息。

> 命令是向具体服务发送消息以执行操作的方式。

例如，当我们向通知服务发送命令“向张诗钟·布拉沃发送电子邮件”时，我们希望它仅被传递给该服务，因为其他服务可能不提供这样的动作。

> 事件是发布消息的方式，因此感兴趣的服务可以订阅它。

例如，我们可以发布声明“订单已下”的事件。我们不是对任何具体的服务说，我们只是陈述刚刚发生的事实。任何它愿意基于该事实采取行动的服务都可以订阅它。

# 摘要

在消息传递中，我们不依赖于其他服务的可用性，因此很难期待响应。这产生了良好的解耦，但是使得消息传递很难用于查询。

> 消息传递对于行动来说很棒，因为它可靠且稳定。它帮助我们保持服务之间的一致性。

在下一篇文章中，我们将看到如何使用 PHP 和[生态交错带框架](https://github.com/ecotoneFramework/ecotone)在实践中应用这一理论。
[点击这里进入下一篇文章。](https://dariuszgafka.medium.com/starting-with-microservices-in-php-6e3c411f3d27)