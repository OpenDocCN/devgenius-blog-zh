<html>
<head>
<title>Build a timer with Go WASM</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 Go WASM 建立一个计时器</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/build-a-timer-with-go-wasm-bfcf5d964b08?source=collection_archive---------5-----------------------#2022-08-03">https://blog.devgenius.io/build-a-timer-with-go-wasm-bfcf5d964b08?source=collection_archive---------5-----------------------#2022-08-03</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/560b8e225a7fa47541de6bc36bde30eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Twm6aoL5C1PC-Cbs"/></div></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk translated">照片由<a class="ae ja" href="https://unsplash.com/@pankajpatel?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Pankaj Patel </a>在<a class="ae ja" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><div class=""/><p id="bf60" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在与 WASM 一起构建了我的第一个程序后，我想看看 Goroutines 能做些什么。我想到的用例是构建一个计时器，一个由 Goroutine 管理的计时器。在这篇文章中，我将详细介绍我尝试用 WASM 构建一个计时器。我选择构建一个计时器，因为我想构建一个具有状态管理的程序。我还想展示 Go 如何简化定时器的编写。我将跳过 WASM 设置步骤，直接开始编写程序的 Go 代码。</p><h1 id="9f36" class="ky kz jd bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">基本组件</h1><p id="ae7d" class="pw-post-body-paragraph ka kb jd kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">计时器虽然简单，但需要某种形式的状态管理。这是跟踪开始时间和当前时间之间的持续时间所必需的。为了添加状态，我将定义一个结构类型。该结构将存储开始时间以及其他有用的信息。我将定义 struct 方法来操纵状态，这是为了防止需要任何全局变量。下面是结构定义:</p><figure class="mc md me mf gt ip gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/e8690070ab03d87a4146534ab30b6a43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1290/format:webp/1*CcT8oBrrmb6Su6ktoTa03Q.png"/></div></figure><p id="daa5" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我的自定义结构类型将有一个名为<code class="fe mg mh mi mj b">start</code>的方法。正如您所知，该方法将启动一个 Go 例程，并通过存储的通道监听退出信号。<code class="fe mg mh mi mj b">start</code>的函数签名与<code class="fe mg mh mi mj b">js.Func</code>的匹配，我这样做是为了以后可以将 struct 方法设置为浏览器函数。下一步是在我的浏览器上测试它。</p><h1 id="5afe" class="ky kz jd bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">和 WASM 一起去</h1><p id="a52a" class="pw-post-body-paragraph ka kb jd kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">我编译了二进制文件，并将其加载到我的浏览器上。我很兴奋能在浏览器上测试 Goroutines。Goroutine 独立刷新 HTML 值的想法很棒。我从浏览器窗口调用功能<code class="fe mg mh mi mj b">start</code>，然后……控制台死机了。Goroutine 阻止了我的 chrome 控制台上的任何执行。然而，我不会放弃和 WASM 一起制作计时器。我利用我作为 web 开发人员的经验来绕过这个限制。我问自己，如果浏览器可以调用刷新功能会怎么样？这将是理想的浏览器与<code class="fe mg mh mi mj b">setInterval</code>，我可以使用<code class="fe mg mh mi mj b">setInterval</code>来设置一个理论上的刷新率。<code class="fe mg mh mi mj b">setInterval</code>是非线程阻塞的，这使得它成为替代 Goroutines 的理想选择。最棒的是，我可以使用一个函数，而不用将它暴露给浏览器。下面是我的计时器的主要功能:</p><figure class="mc md me mf gt ip gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/5db861505723d866d3803d9150c9b4a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1324/format:webp/1*KhG36T6lB7Q1kOWPoTCPlA.png"/></div></figure><p id="27fc" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在最后一行，我调用 setInterval 来每 50 毫秒调用一次方法更新。setInterval 将负责线程管理，而不是 Goroutines。在我不使用 Goroutines 更新状态之后，是时候更新代码来使用 setInterval 管理状态了。下面是类型<code class="fe mg mh mi mj b">Watch</code>将如何实现:</p><figure class="mc md me mf gt ip gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/4f65b5ad3ceefd13f2da97e68601722c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1288/format:webp/1*CZAtHItQyqpP8QBqr4uXrQ.png"/></div></figure><p id="cc0f" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Goroutine 已从方法<code class="fe mg mh mi mj b">start</code>中移除。新的设置将依靠浏览器来请求更新。这是最佳选择，因为 Javascript 在异步执行时性能更好。它还能让浏览器以自己的速度刷新。如果程序规定了刷新率，浏览器就会死机。下面是 Chrome 控制台上的方法更新:</p><figure class="mc md me mf gt ip gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/a1ead0800d1ab429ac4bbcb736531d2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1252/format:webp/1*pG3r4AMe2iD7FZhDMf0aaw.png"/></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk translated">更新被调用了 68 次。</figcaption></figure><h1 id="9c1e" class="ky kz jd bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">刷新率</h1><p id="fab7" class="pw-post-body-paragraph ka kb jd kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">我希望这个程序能够更新网页的 HTML。Go 的<code class="fe mg mh mi mj b">fmt</code>包有很棒的字符串格式化功能。我希望计时器显示 1 位数的值为 2 位数的值。例如，如果计时器有 1 秒，我希望它显示为 01。这将使计时器看起来比数字手表更熟悉。下面是修改后的更新方法:</p><figure class="mc md me mf gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi mn"><img src="../Images/97fef4850dcf5d1662f53f0b994b6203.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eTqq8NrLs1PL9duQsPLxWg.png"/></div></div></figure><p id="1917" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里传递的字符串格式是<code class="fe mg mh mi mj b">%02d</code>，这是将我的 1 位数变成 2 位数的格式。如果计时器尚未启动，该方法将提前返回。该函数还将设置一个 ID 为 timer 的 HTML 元素的 innerHTML。因此，要在网页上显示程序的输出，我们需要一个 ID 为 timer 的元素。下面是一个运行中的定时器的 GIF 图，带有期望的行为:</p><figure class="mc md me mf gt ip gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/3070dbaccdc07eea9aa2c4cb37fd45c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*oE9n9zjyvSacIlzHhr72qA.gif"/></div></figure><h1 id="1b13" class="ky kz jd bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">结论</h1><p id="b973" class="pw-post-body-paragraph ka kb jd kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">我学到的一件事是，要建立一个成功的 WASM 程序，必须了解浏览器的生命周期。在写这篇文章之前，我想到可以使用一个 Go 例程来跟踪计时器状态。虽然这对于其他的建造目标是可能的，但是对于 WASM 来说并不合适。这些是在浏览器虚拟机中运行代码的限制，WASM 在所述虚拟机中执行。也就是说，使用 Go 来格式化将显示给浏览器的字符串数据，以及使用<code class="fe mg mh mi mj b">time</code>包来测量时间是很好的。我知道这是一个简单的例子，但是我想说明的是如何实现浏览器友好的代码。以及如何有效地管理和显示程序的状态。您可以在下面的源代码部分找到完整程序的链接。</p><h1 id="eb9d" class="ky kz jd bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">来源</h1><div class="im in gp gr io mp"><a href="https://github.com/cheikhshift/medium_examples/tree/main/wasmtimer" rel="noopener  ugc nofollow" target="_blank"><div class="mq ab fo"><div class="mr ab ms cl cj mt"><h2 class="bd je gy z fp mu fr fs mv fu fw jc bi translated">medium _ examples/wasmtimer at main cheikh shift/medium _ examples</h2><div class="mw l"><h3 class="bd b gy z fp mu fr fs mv fu fw dk translated">中型文章的代码示例。在 GitHub 上创建一个帐户，为 cheikhshift/medium_examples 开发做贡献。</h3></div><div class="mx l"><p class="bd b dl z fp mu fr fs mv fu fw dk translated">github.com</p></div></div><div class="my l"><div class="mz l na nb nc my nd iu mp"/></div></div></a></div></div></div>    
</body>
</html>