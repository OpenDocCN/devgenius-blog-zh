<html>
<head>
<title>The Algorithmic Approach in Life-Understanding a package manager</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">生活中的算法——理解一个包管理器</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/the-algorithmic-approach-in-life-e5ccb3fb0dd?source=collection_archive---------17-----------------------#2020-07-06">https://blog.devgenius.io/the-algorithmic-approach-in-life-e5ccb3fb0dd?source=collection_archive---------17-----------------------#2020-07-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/6fdf1d688e6852cbfb83feeb4d7791f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*x2ZFu0tis7OjXYqF"/></div></div></figure><p id="bbdb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们使用<a class="ae kw" href="https://en.wikipedia.org/wiki/Package_manager" rel="noopener ugc nofollow" target="_blank">包管理器</a>来为我们的项目安装包。假设我们的项目需要包 A、B 和 C，其中 A 和 B 有一些依赖关系。</p><ul class=""><li id="97c9" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated"><strong class="ka ir"> A 依赖 D </strong>，<strong class="ka ir"> E. </strong></li><li id="471a" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated"><strong class="ka ir"> B 依赖于 F </strong>。</li><li id="dcb5" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated"><strong class="ka ir"> D 和 E 依赖于 G </strong>。</li></ul><p id="3b9a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后需要安装所有的<strong class="ka ir"> A、B、C、D、E、F 和 G。</strong>软件包管理器以正确的顺序安装主软件包 A、B 和 C 以及这些主软件包的所有依赖项。</p><p id="11f8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它是如何发生的？下一节我们来试着理解一下。</p><h1 id="1975" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">首先，让我们试着想象一下</h1><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/011a3e9600c0dcb34dee25696042a5ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1258/0*T2Et5qmj0qclrLvj"/></div></figure></div><div class="ab cl mo mp hu mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ij ik il im in"><h1 id="09ce" class="ll lm iq bd ln lo mv lq lr ls mw lu lv lw mx ly lz ma my mc md me mz mg mh mi bi translated"><strong class="ak">首次安装方法</strong></h1><p id="1e94" class="pw-post-body-paragraph jy jz iq ka b kb na kd ke kf nb kh ki kj nc kl km kn nd kp kq kr ne kt ku kv ij bi translated">我们将开始安装主要的、直接在配置文件中定义的包，然后以自顶向下的方式安装它们的依赖项等等。</p><p id="a1dc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，我们将首先安装包 A、它的依赖项 D 和 E，然后安装包 G。现在我们将安装包 B 和它的依赖项 f。在此之后，将安装包 C。</p><p id="03d0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">安装顺序为<em class="nf"> A、D、E、G、B、F、C </em></p><h1 id="f822" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">上述方法的问题</h1><p id="4047" class="pw-post-body-paragraph jy jz iq ka b kb na kd ke kf nb kh ki kj nc kl km kn nd kp kq kr ne kt ku kv ij bi translated">为了理解上述方法的问题，让我们首先理解包的版本控制。</p><p id="e947" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果软件包版本是 5.4.2，那么 5 是主要版本，4 是次要版本，2 是修补版本</p><ol class=""><li id="a607" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv ng ld le lf bi translated">主要版本变化代表不兼容的 API 变化，</li><li id="da37" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv ng ld le lf bi translated">次要版本更改以向后兼容的方式表示功能更改</li><li id="9c5a" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv ng ld le lf bi translated">补丁版本更改代表向后兼容的错误修复。</li></ol><p id="1763" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，如果我们需要 4.5.2 版本的软件包，我们不能安装 5.0.0，但 4.x.x 是可以接受的。</p><p id="c27d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可以在这里了解更多:<a class="ae kw" href="https://semver.org/" rel="noopener ugc nofollow" target="_blank">语义版本</a></p><p id="9f17" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们来讨论一个场景</p><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nh"><img src="../Images/dbcd742626eb19eb6b464ec0e89b6140.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Bcgd7Qe-v9VLow-D"/></div></div></figure><p id="b723" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们看到上图，D 需要一个 5.2.1 版本的 G，E 需要一个 6.1.0 版本的 G，如果我们从顶部开始，安装顺序将是 A，D，E 但是由于需要不同的<strong class="ka ir"> major </strong>版本，安装过程将在 G 处失败。如果有不同的次要版本，那么可以安装一个通用版本的 G。</p><h1 id="b899" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">第二种安装方法</h1><p id="6b14" class="pw-post-body-paragraph jy jz iq ka b kb na kd ke kf nb kh ki kj nc kl km kn nd kp kq kr ne kt ku kv ij bi translated">正如我们在前面的例子中看到的，在安装包时，我们有时会遇到<a class="ae kw" href="https://en.wikipedia.org/wiki/Dependency_hell#:~:text=Dependency%20hell%20is%20a%20colloquial,versions%20of%20other%20software%20packages." rel="noopener ugc nofollow" target="_blank">版本冲突</a>的问题。如果我们从主包开始，只有当我们试图安装它们的依赖项时，我们才会知道这个版本冲突。</p><p id="6f69" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了解决这个问题，我们将从一个不依赖于任何其他包的包开始安装，然后我们将以自下而上的方式安装主包。</p><p id="4f91" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，要安装主包，安装顺序将是<em class="nf"> G、D、E 和 A。</em>这种自底向上的方法将有助于在早期阶段发现版本冲突问题。</p><p id="8cf4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">从以上方法中，我们可以看出包的安装顺序很重要，第二种方法有助于我们更早地发现版本冲突问题</strong>。</p><h1 id="be09" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">结论</h1><p id="0675" class="pw-post-body-paragraph jy jz iq ka b kb na kd ke kf nb kh ki kj nc kl km kn nd kp kq kr ne kt ku kv ij bi translated">这篇博客的目的是给出一个包管理器用来安装依赖项的不同方法的简要概述。</p><p id="4a05" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如需进一步阅读，请查看以下链接-</p><ul class=""><li id="148a" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated"><a class="ae kw" href="https://www.geeksforgeeks.org/find-the-ordering-of-tasks-from-given-dependencies/?ref=rp" rel="noopener ugc nofollow" target="_blank">https://www . geeks forgeeks . org/find-the-ordering-of-tasks-from-given-dependencies/？ref=rp </a></li><li id="1704" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated"><a class="ae kw" href="https://docs.npmjs.com/specifying-dependencies-and-devdependencies-in-a-package-json-file" rel="noopener ugc nofollow" target="_blank">https://docs . npmjs . com/specifying-dependencies-and-dev dependencies-in-a-package-JSON-file</a></li></ul><p id="4973" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此外，您可以查看本系列的第 1 部分<a class="ae kw" href="https://medium.com/dev-genius/the-algorithmic-approach-in-life-de0b2ecbff23" rel="noopener">,它讲述了如何有效地发现项目中的 bug。</a></p></div></div>    
</body>
</html>