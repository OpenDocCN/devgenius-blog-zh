<html>
<head>
<title>Housekeeping task Post POD formation and before a POD dies</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在荚果形成之后和荚果死亡之前的内务处理任务</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/housekeeping-task-post-pod-formation-and-before-a-pod-dies-ce8ec2b6423f?source=collection_archive---------3-----------------------#2019-05-12">https://blog.devgenius.io/housekeeping-task-post-pod-formation-and-before-a-pod-dies-ce8ec2b6423f?source=collection_archive---------3-----------------------#2019-05-12</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/a24d502a530c64660a531f1570aff185.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*sFBeommEDFicTHOq"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk translated">照片由<a class="ae jz" href="https://unsplash.com/@sigmund?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">西格蒙德</a>在<a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="bf83" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果你想在谷歌云平台(GCP)上，在 POD 创建后或 POD 死亡前做一些整理/清理工作，那么这篇文章就是为你准备的。</p><p id="9e51" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你会发现很多关于什么是豆荚、容器以及如何用库伯奈特人建造一个帝国的理论，我不会深入讨论这些细节，这里的<a class="ae jz" href="https://kubernetes.io/docs/concepts/overview/what-is-kubernetes/" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"/></a>是对库伯奈特人的快速参考。我会尽量把重点放在如何调用一个程序上，一旦荚果形成，荚果即将死亡，……简单:)。</p><p id="a271" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们将尝试使用 postStart 和 preStop 容器处理程序。我们将首先看到<strong class="kc io"> postStart </strong>，因为我们将能够查看容器并看到输出。然后，我们将尝试使用<strong class="kc io"> preStop </strong>事件删除 Google Cloud 发布/订阅。此处  <strong class="kc io"> </strong>参照<a class="ae jz" href="https://kubernetes.io/docs/tasks/configure-pod-container/attach-handler-lifecycle-event/" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io">了解容器生命周期事件。</strong></a></p><p id="aa0e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所以让我们开始旅程吧…</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="f0b1" class="lh li in ld b gy lj lk l ll lm">Step 1- Have your environment ready</span><span id="7dc6" class="lh li in ld b gy ln lk l ll lm">Step 2- Using "postStart" event</span><span id="efe3" class="lh li in ld b gy ln lk l ll lm">Step 3- Using "preStop" event</span></pre><p id="e12e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">第一步</strong> - <strong class="kc io">准备好你的环境</strong>。尝试获得或构建一个 kubernetes 环境(集群),该环境由一个包含 NodeJS 的容器组成。在这个容器中，我希望“/usr”文件夹下有一个 demo.js 文件。创建这样的容器有不同的方法。我自己创造了一个新的码头工人形象。接下来的步骤将创建您自己的图像，该图像将包含“/usr”下的 demo.js 文件</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="9428" class="lh li in ld b gy lj lk l ll lm">1. docker pull node</span><span id="1d57" class="lh li in ld b gy ln lk l ll lm">2. docker run -it — name=”hellonode_test” node:latest /bin/bash</span><span id="d169" class="lh li in ld b gy ln lk l ll lm">3. Goto "/usr" folder. Create a file demo.js and put following javascript code.</span><span id="dca1" class="lh li in ld b gy ln lk l ll lm"><strong class="ld io"><em class="lo">function testimony() {console.log(‘This is function only to prove my point.’); } testimony()</em></strong></span><span id="d75e" class="lh li in ld b gy ln lk l ll lm">Easy way to do this is following<br/> <br/>echo "<strong class="ld io"><em class="lo">function testimony() {console.log(‘This is function only to prove my point.’); } testimony()</em></strong>" &gt; demo.js</span><span id="aa6f" class="lh li in ld b gy ln lk l ll lm">4. docker commit -m=”This a test hellonode image” hellonode_test hellonodejs</span><span id="1514" class="lh li in ld b gy ln lk l ll lm">5. docker tag hellonodejs gcr.io/&lt;your project id&gt;/hellonodejs</span><span id="6ef7" class="lh li in ld b gy ln lk l ll lm">6. docker push gcr.io/&lt;your project id&gt;/hellonodejs</span></pre><p id="b8b3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">步骤 2 </strong> - <strong class="kc io">使用“postStart”事件</strong>-【Kubernetes 在容器创建后立即发送 postStart 事件】<strong class="kc io">。我将在这里尝试演示 postStart 事件的用法。</strong></p><p id="16cd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在第一步中，我们已经准备好部署映像。让我们继续，并使用下面的最小配置来部署它。yaml "配置如下所示。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="e2ae" class="lh li in ld b gy lj lk l ll lm">apiVersion: extensions/v1beta1<br/>kind: Deployment<br/>metadata:<br/> name: my-pod<br/>spec:<br/> replicas: 1<br/> selector:<br/> matchLabels:<br/> app: testhellonode<br/> template:<br/> metadata:<br/> labels:<br/> app: testhellonode<br/> spec:<br/> containers:<br/> — name: my-container<br/> image: gcr.io/&lt;your project id&gt;/hellonodejs<br/> imagePullPolicy: Always<br/> command: [“/bin/sh”, “-c”, “while :; do sleep 1; done”]<br/> lifecycle:<br/> postStart:<br/> exec:<br/> command: [“/bin/sh”, “-c”, “node ./usr/demo.js &gt; /usr/share/message”]</span></pre><blockquote class="lp lq lr"><p id="c83b" class="ka kb lo kc b kd ke kf kg kh ki kj kk ls km kn ko lt kq kr ks lu ku kv kw kx ig bi translated">命令推上面的配置- <strong class="kc io"> <em class="in"> kubectl apply -f " &lt;路径到 yaml &gt; " </em> </strong></p></blockquote><p id="adea" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一旦部署成功，您可以使用类似于<strong class="kc io"> kubectl get deployments </strong>和/或<strong class="kc io"> kubectl get pods 这样的命令来验证。</strong>尝试获取 POD 的名称(POD_Name)。现在尝试运行以下命令</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="12e9" class="lh li in ld b gy lj lk l ll lm"><strong class="ld io">kubectl exec -it &lt;POD_Name&gt; — /bin/bash</strong></span><span id="a393" class="lh li in ld b gy ln lk l ll lm">cat /usr/share/message</span></pre><p id="dc46" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您应该会看到一条消息“这只是用来证明我的观点的函数。”已显示。</p><p id="eda1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">此消息是作为 postStart 处理程序的结果生成的，在该处理程序中，我们尝试运行 demo.js 并将其传输到“/usr/share/message”。这证明了我们应该能够调用任何编程逻辑来执行某些任务。在我的例子中，我成功地调用了 javascript。</p><p id="2fa0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">第三步</strong> - <strong class="kc io">使用“preStop”事件</strong>。要查看“preStop”事件的证据，我们将无法使用日志，因为 POD 将被销毁，我们无法登录 POD 来查看日志。因此，要看到这个事件正在工作，我们必须从外部改变一些状态，我们可以去那里验证。我们可以使用很多方法，比如将一个条目写入持久存储(数据库)等等。我将尝试删除现有的云发布/订阅。</p><p id="b044" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">先决条件-尝试在主题“hellotopic”上手动创建一个名为“hellosub”的云发布/订阅。参考<a class="ae jz" href="https://cloud.google.com/pubsub/docs/quickstart-console" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io">此处</strong> </a>关于如何创建订阅。</p><p id="75f0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当“preStop”事件发生时，我们将使用下面的 javascript 代码删除订阅。我将把这段代码放在一个名为“delsub.js”的文件中。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="d0fe" class="lh li in ld b gy lj lk l ll lm">async function deleteSubscription() {</span><span id="3ede" class="lh li in ld b gy ln lk l ll lm">const subscriptionName = ‘hellosub’;</span><span id="c767" class="lh li in ld b gy ln lk l ll lm">const { PubSub } = require(‘@google-cloud/pubsub’);</span><span id="ba48" class="lh li in ld b gy ln lk l ll lm">const pubsub = new PubSub();</span><span id="998d" class="lh li in ld b gy ln lk l ll lm">await pubsub.subscription(subscriptionName).delete();</span><span id="590b" class="lh li in ld b gy ln lk l ll lm">}</span><span id="7857" class="lh li in ld b gy ln lk l ll lm">deleteSubscription()</span></pre><p id="9632" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">同样，为了让上面的代码工作，我们必须有一个 kubernetes 环境(集群)，由一个带有单个容器的 POD 组成，具有 NodeJS 和所需的节点模块(“@google-cloud/pubsub”)。我们可以创建一个包含所有上述所需组件的新映像，并尝试将文件 delsub.js 放在“/usr”文件夹下。参考<a class="ae jz" href="https://cloud.google.com/pubsub/docs/reference/libraries#client-libraries-install-nodejs" rel="noopener ugc nofollow" target="_blank">此处</a>的云发布/订阅客户端。</p><p id="f150" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我将尝试在前面的 yaml 文件中的 PostStart 旁边添加以下预停止条目</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="4c47" class="lh li in ld b gy lj lk l ll lm">         <strong class="ld io">preStop:<br/>            exec:<br/>              command: ["/bin/sh", "-c", "node ./usr/delsub.js"]</strong></span></pre><p id="3397" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，yaml 文件现在将如下所示</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="ff3a" class="lh li in ld b gy lj lk l ll lm">apiVersion: extensions/v1beta1<br/>kind: Deployment<br/>metadata:<br/> name: my-pod<br/>spec:<br/> replicas: 1<br/> selector:<br/> matchLabels:<br/> app: testhellonode<br/> template:<br/> metadata:<br/> labels:<br/> app: testhellonode<br/> spec:<br/> containers:<br/> — name: my-container<br/> image: gcr.io/&lt;your project id&gt;/hellonodejs<br/> imagePullPolicy: Always<br/> command: [“/bin/sh”, “-c”, “while :; do sleep 1; done”]<br/> lifecycle:<br/> postStart:<br/> exec:<br/> command: [“/bin/sh”, “-c”, “node ./usr/demo.js &gt; /usr/share/message”]<br/> <strong class="ld io">preStop:<br/> exec:<br/> command: ["/bin/sh", "-c", "node ./usr/delsub.js"]</strong></span></pre><p id="f7fa" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">使用上述 yaml 文件进行重新部署。</p><p id="33ff" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">preStop 事件仅在 POD 死亡时触发，因此要重现/触发 preStop 事件，我们必须杀死 POD，有不同的方法可以做到这一点，但缩小 POD 大小是最简单的方法。因此，我将把 POD 大小从 1 缩小到 0(零)。一旦我们将大小缩小到 0，就会触发 preStop 事件，这将删除“hellosub”订阅。我们可以通过查看订阅列表来验证这一点。</p></div><div class="ab cl lv lw hr lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ig ih ii ij ik"><p id="4d2f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">总结</strong>:在这篇文章中，我们看到了如何从容器生命周期事件“postStart”和“preStop”中调用 javascript 代码。这比调用简单的脚本前进了一小步。类似地，我们可以定义一个处理程序来调用不同编程语言的代码或脚本，我将把它留给您做进一步的探索。总之，这些事件可用于在荚果形成后或荚果死亡前完成一些内务/重要任务。</p></div></div>    
</body>
</html>