<html>
<head>
<title>PHP: Securing JSON into the server</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">PHP:保护服务器中的JSON</h1>
<blockquote>原文：<a href="https://blog.devgenius.io/php-securing-json-into-the-server-d7facec30cc1?source=collection_archive---------11-----------------------#2020-07-13">https://blog.devgenius.io/php-securing-json-into-the-server-d7facec30cc1?source=collection_archive---------11-----------------------#2020-07-13</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="5619" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">让我在这上面签名，以免被篡改</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/fcee7a28dab33e669bb27c062d6f4d84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*A13rnzLq3161kcmf"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk translated">照片由<a class="ae ks" href="https://unsplash.com/@yogesh_7?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">约格什·佩达姆卡</a>在<a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="fbfd" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">不久前，我想知道是否可以将一个对象序列化为JSON。虽然这在技术上是可能的，但是当服务器从某个地方接收到相同的JSON字符串时，不能保证有人修改过它:</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="2d28" class="lu lv in lq b gy lw lx l ly lz">{<br/>    "name": "My name",<br/>    "email": "attacker.mail@email.com"<br/>}</span></pre><p id="a0a1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">幸运的是，有一种方法可以确保这些数据没有被以任何方式更改，那就是给它添加一个“哈希”，也称为“签名”。有两种方法可以签署一份数据，至少不需要深入细节，也不需要太过专业以至于这篇文章成为一张壁纸:</p><ol class=""><li id="79bf" class="mb mc in kv b kw kx kz la lc md lg me lk mf lo mg mh mi mj bi translated">对称:使用一个公共密钥或秘密密钥。</li><li id="6c37" class="mb mc in kv b kw mk kz ml lc mm lg mn lk mo lo mg mh mi mj bi translated">不对称:使用公钥/私钥。</li></ol><p id="e91b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我要使用的是<strong class="kv io">公共或秘密密钥</strong>。这是因为只有一方处理密钥，因此保密。如果我需要另一方以安全的方式验证数据，就需要一个公钥/私钥。</p><p id="832c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">主要思想是将签名附加到JSON有效负载上，发送它，然后检索它，而不用担心未经同意就被修改。此外，我们应该意识到<strong class="kv io">接收者可以窥视数据本身</strong>。</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="daa2" class="lu lv in lq b gy lw lx l ly lz">{<br/>    "name": "John Doe",<br/>    "email": "john.doe@mail.com",<br/>    "signature": "b3eeb0da04ebbc73ee17549d4354ce5de7e7445b3c82eeac"<br/>}</span></pre><h1 id="b408" class="mp lv in bd mq mr ms mt mu mv mw mx my jt mz ju na jw nb jx nc jz nd ka ne nf bi translated">签署数据</h1><p id="9266" class="pw-post-body-paragraph kt ku in kv b kw ng jo ky kz nh jr lb lc ni le lf lg nj li lj lk nk lm ln lo ig bi translated">假设我们有一个简单的对象，在一个数组中保存用户名和电子邮件。我们可以简单地获取数组，将其转换为JSON，并使用该数据串来计算签名。</p><blockquote class="nl nm nn"><p id="f6ec" class="kt ku ma kv b kw kx jo ky kz la jr lb no ld le lf np lh li lj nq ll lm ln lo ig bi translated">坦率地说，我们添加的签名是使用SHA-256算法编码的数据的简单散列。你可以使用SHA-512或SHA-3，但对于这个例子和普通用户来说，由于其速度和常见用法，SHA-256已经足够了。</p></blockquote><p id="a614" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">为此，我们可以使用<code class="fe nr ns nt lq b"><a class="ae ks" href="https://www.php.net/manual/en/function.hash-hmac.php" rel="noopener ugc nofollow" target="_blank">hash_hmac()</a></code>，这是一个简单的函数，它用一个秘密密钥散列一个给定的字符串，并返回散列本身。</p><p id="bbe4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在做任何事情之前，我们必须确保有一个用于签名的密钥。对于这个例子，我们可以在数据库中保存一个假设的随机密钥。这个密钥应该是256位的二进制字符串。我们可以用32字节的<code class="fe nr ns nt lq b"><a class="ae ks" href="https://www.php.net/manual/en/function.random-bytes.php" rel="noopener ugc nofollow" target="_blank">random_bytes()</a></code>快速创建一个。</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="c421" class="lu lv in lq b gy lw lx l ly lz">$object-&gt;key = random_bytes(32);</span></pre><p id="5cc5" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我将把它的持久性留给你。<code class="fe nr ns nt lq b"><a class="ae ks" href="https://www.php.net/manual/en/function.bin2hex.php" rel="noopener ugc nofollow" target="_blank">bin2hex()</a></code>函数可以很好的用十六进制字符串来存储它。</p><p id="3bb4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">一旦一切准备就绪，我们将使用一种方法来接收数据，并用一个新的签名返回它:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="ca16" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们将把数组复制到一个“原始”数组中。我们稍后将使用这个数组将签名作为最后一个参数。</p><p id="c7e8" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">对于复制的数组，我们将使用<code class="fe nr ns nt lq b">ksort()</code>对它们进行排序。然后我们将把它转换成JSON，并使用结果字符串计算散列。使用“签名”密钥将散列附加到“原始”数组。</p><h1 id="72f3" class="mp lv in bd mq mr ms mt mu mv mw mx my jt mz ju na jw nb jx nc jz nd ka ne nf bi translated">验证签名</h1><p id="ebed" class="pw-post-body-paragraph kt ku in kv b kw ng jo ky kz nh jr lb lc ni le lf lg nj li lj lk nk lm ln lo ig bi translated">我假设您想方便地获取一个JSON字符串并从中创建一个新的对象实例。没问题，静态方法可以帮助我们做到这一点。</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="047d" class="lu lv in lq b gy lw lx l ly lz">public static function fromJson(string $data, string $key)<br/>{<br/>    $data = json_decode($data, true);</span><span id="fe80" class="lu lv in lq b gy nw lx l ly lz">    $signature = $data['signature'];</span><span id="ed01" class="lu lv in lq b gy nw lx l ly lz">    unset($data['signature']);</span><span id="b263" class="lu lv in lq b gy nw lx l ly lz">    ksort($data);</span><span id="d7ef" class="lu lv in lq b gy nw lx l ly lz">    if (hash_equals(hash_hmac('sha256', json_encode($data), $key)), $signature) {<br/>        return new static($data);<br/>    }</span><span id="d66a" class="lu lv in lq b gy nw lx l ly lz">    throw new \Exception('Invalid signature');<br/>}</span></pre><p id="9408" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在我们使用<code class="fe nr ns nt lq b"><a class="ae ks" href="https://www.php.net/manual/en/function.json-decode.php" rel="noopener ugc nofollow" target="_blank">json_decode()</a></code>将数据解码成一个数组后，我们可以简单地从数组中取出签名，像以前一样对其进行排序，并重新创建签名。</p><p id="f3e5" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在的区别是，我们将使用<code class="fe nr ns nt lq b"><a class="ae ks" href="https://www.php.net/manual/en/function.hash-equals.php" rel="noopener ugc nofollow" target="_blank">hash_equals()</a></code>来检查我们从数据中创建的散列是否等于包含的散列，而不是返回带有签名的数据。而且，这避免了<a class="ae ks" href="https://en.wikipedia.org/wiki/Timing_attack" rel="noopener ugc nofollow" target="_blank">定时攻击</a>。</p><p id="3e44" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果一切正常，我们可以使用经过验证的数据数组返回一个新的实例。如果失败了，我们将返回一个异常。</p><p id="cea2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">差不多就是这样。我们可以安全地共享这些信息，而不必担心有人会修改它。</p></div><div class="ab cl nx ny hr nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="ig ih ii ij ik"><p id="5980" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">你可以在我的<a class="ae ks" href="https://github.com/DarkGhostHunter/Laratraits" rel="noopener ugc nofollow" target="_blank"> Laratraits包</a>中找到这个特性和其他助手。如果你发现在你的项目中有用的东西，给它一个机会。</p></div></div>    
</body>
</html>